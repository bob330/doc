<!doctype html><html class=theme-light lang=ja><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content><meta name=keywords content><meta name=copyright content="1995-2024 The FreeBSD Foundation"><link rel=canonical href=http://172.16.201.134:1313/ja/books/faq/><title>FreeBSD 2.X、3.X、4.X についての FAQ (よくある質問とその答え) | FreeBSD Documentation Portal</title>
<meta name=theme-color content="#790000"><meta name=color-scheme content="system light dark high-contrast"><link rel="shortcut icon" href=http://172.16.201.134:1313/favicon.ico><link rel=stylesheet href=http://172.16.201.134:1313/styles/main.min.css><link rel=stylesheet href=http://172.16.201.134:1313/css/font-awesome-min.css><script defer src=/js/theme-chooser.min.js></script><script defer src=/js/copy-clipboard.min.js></script><script defer src=/js/search.min.js></script><meta name=twitter:card content="summary"><meta name=twitter:domain content="docs.FreeBSD.org"><meta name=twitter:site content="@freebsd"><meta name=twitter:url content="https://twitter.com/freebsd"><meta property="og:title" content="FreeBSD 2.X、3.X、4.X についての FAQ (よくある質問とその答え)"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:image" content="http://172.16.201.134:1313/favicon.ico"><meta property="og:image:alt" content="FreeBSD Logo"><meta property="og:locale" content="ja"><meta property="og:url" content="http://172.16.201.134:1313/ja/books/faq/"><meta property="og:site_name" content="FreeBSD Documentation Portal"><script type=application/ld+json>{"@context":"http://schema.org","@type":"Article","url":"http:\/\/172.16.201.134:1313\/ja\/books\/faq\/","name":"FreeBSD Documentation Portal","headline":"FreeBSD Documentation Portal","description":"FreeBSD Documentation Portal"}</script></head><body><header><div class=header-container><div class=logo-menu-bars-container><a href=https://www.FreeBSD.org class=logo><img src=http://172.16.201.134:1313/images/FreeBSD-monochromatic.svg width=160 height=50 alt="FreeBSD logo">
</a><label class=menu-bars for=menu-bars><i class="fa fa-bars" aria-hidden=true></i></label></div><input id=menu-bars type=checkbox><nav><ul class=menu><li class=menu-item><input id=about type=checkbox>
<a href=# aria-label="Navigate to About section"><label class=menu-item-description for=about>About
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/about/ target=_blank>About</a></li><li><a href=https://www.freebsd.org/about/ target=_blank>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/about-us/about-the-foundation/ target=_blank>FreeBSD Foundation</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct/ target=_blank>Code of Conduct</a></li></ul></li><li class=menu-item><input id=download type=checkbox>
<a href=# aria-label="Navigate to get FreeBSD section"><label class=menu-item-description for=download>Get FreeBSD
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/where/ target=_blank>Get FreeBSD</a></li><li><a href=https://www.freebsd.org/releases/ target=_blank>Release Information</a></li><li><a href=https://www.freebsd.org/releng/ target=_blank>Release Engineering</a></li><li><a href=https://www.freebsd.org/security/ target=_blank>Security Advisories</a></li></ul></li><li class=menu-item><input id=documentation type=checkbox>
<a href=# aria-label="Navigate to get Documentation section"><label class=menu-item-description for=documentation>Documentation
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=/ja>Documentation portal</a></li><li><a href=http://172.16.201.134:1313/ja/books/handbook>FreeBSD Handbook</a></li><li><a href=http://172.16.201.134:1313/ja/books/porters-handbook>Porter's Handbook</a></li><li><a href=https://docs.FreeBSD.org/en/books/fdp-primer>Documentation Project Handbook</a></li><li><a href=https://man.FreeBSD.org target=_blank>Manual pages</a></li><li><a href=https://papers.FreeBSD.org target=_blank>Presentations and papers</a></li><li><a href=https://wiki.FreeBSD.org target=_blank>Wiki</a></li><li><a href=http://172.16.201.134:1313/ja/books>Books</a></li><li><a href=http://172.16.201.134:1313/ja/articles>Articles</a></li></ul></li><li class=menu-item><input id=community type=checkbox>
<a href=# aria-label="Navigate to get Community section"><label class=menu-item-description for=community>Community
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/community/>Community</a></li><li><a href=http://172.16.201.134:1313/ja/articles/contributing>Get involved</a></li><li><a href=https://forums.freebsd.org/ target=_blank>Forum</a></li><li><a href=https://lists.freebsd.org/ target=_blank>Mailing lists</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank>IRC Channels</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank>Bug Tracker</a></li><li><a href=https://www.freebsd.org/support/ target=_blank>Support</a></li></ul></li></ul></nav><div class=search-donate-container><form class=search method=get id=search-header-form action=https://docs.freebsd.org/search name=search-header-form><input type=hidden name=DB value=ja>
<input id=words name=P type=text size=20 maxlength=255>
<button>
<i class="fa fa-search" aria-hidden=true></i></button></form><div class=donate><a href=https://freebsdfoundation.org/donate/ target=_blank><span class=heart>♥</span>
Donate</a></div></div></div></header><input type=checkbox class="hidden toggle" id=menu-control><main class=main-wrapper-book><a id=top></a><div class=book><h1 class=title>FreeBSD 2.X、3.X、4.X についての FAQ (よくある質問とその答え)</h1><div class="admonitionblock note"><p><i class="fa fa-exclamation-circle" aria-hidden=true></i>
This translation may be out of date. To help with the translations please access the <a href=https://translate-dev.freebsd.org/ target=_blank>FreeBSD translations instance</a>.</p></div><div class=copyright>Copyright © 1995-2020 The FreeBSD Documentation Project</div><div class=legalnotice><a id=trademarks></a><details><summary>trademarks</summary><p>FreeBSD は The FreeBSD Foundation の登録商標です。</p><p>IBM, AIX, OS/2, PowerPC, PS/2, S/390 および ThinkPad は アメリカ合衆国、その他の国、または両方における International Business Machines Corporation の商標です。</p><p>IEEE, POSIX および 802 は アメリカ合衆国における Institute of Electrical and Electronics Engineers, Inc. の登録商標です。</p><p>Adobe, Acrobat, Acrobat Reader, Flash および PostScript は アメリカ合衆国および/またはその他の国の Adobe Systems Incorporated の登録商標または商標です。</p><p>Intel, Celeron, Centrino, Core, EtherExpress, i386, i486, Itanium, Pentium および Xeon はアメリカ合衆国およびその他の国における Intel Corporation またはその関連会社の商標または登録商標です。</p><p>Linux は Linus Torvalds の登録商標です。</p><p>Microsoft, IntelliMouse, MS-DOS, Outlook, Windows, Windows Media および Windows NT は アメリカ合衆国および/またはその他の国における Microsoft Corporation の登録商標または商標です。</p><p>Motif, OSF/1 および UNIX は アメリカ合衆国およびその他の国における The Open Group の登録商標で、 IT DialTone および The Open Group は同じく商標です。</p><p>Sun, Sun Microsystems, Java, Java Virtual Machine, JDK, JRE, JSP, JVM, Netra, OpenJDK, Solaris, StarOffice, SunOS および VirtualBox は アメリカ合衆国およびその他の国における Sun Microsystems, Inc. の 商標または登録商標です。</p><p>NetBSD は the NetBSD Foundation の登録商標です。</p><p>製造者および販売者が製品を区別するのに 用いている表示の多くは、商標とされています。この文書に登場する表示のうち FreeBSD Project がその商標を確認しているものには、その表示に続いて“™” または “®” 記号がおかれています。</p></details></div><div class=toc-mobile><h3>目次</h3><nav id=TableOfContents><ul><li><a href=#preface>まえがき</a></li><li><a href=#_インストール>1. インストール</a></li><li><a href=#hardware>2. ハードウェアコンパチビリティ</a></li><li><a href=#_トラブルシューティング>3. トラブルシューティング</a></li><li><a href=#_商用アプリケーション>4. 商用アプリケーション</a></li><li><a href=#_ユーザアプリケーション>5. ユーザアプリケーション</a></li><li><a href=#_カーネルコンフィグレーション>6. カーネルコンフィグレーション</a></li><li><a href=#_システム管理>7. システム管理</a></li><li><a href=#_x_window_system_と仮想コンソール>8. X Window System と仮想コンソール</a></li><li><a href=#networking>9. ネットワーキング</a></li><li><a href=#_ppp>10. PPP</a></li><li><a href=#_シリアル接続>11. シリアル接続</a></li><li><a href=#_その他の質問>12. その他の質問</a></li><li><a href=#_まじめな_freebsd_ハッカーだけの話題>13. まじめな FreeBSD ハッカーだけの話題</a></li><li><a href=#_謝辞>14. 謝辞</a></li><li><a href=#_freebsd_faq_日本語化について>15. FreeBSD FAQ 日本語化について</a></li><li><a href=#bibliography>有用な書籍</a></li></ul></nav></div><div class=book-content><div id=preamble><div class=sectionbody><div class="paragraph abstract-title"><p>概要</p></div><div class=paragraph><p>この文書は FreeBSD システム・バージョン 2.X、3.X、4.X についての FAQ です。 特に断わりがない限り、どの項目も FreeBSD 2.0.5 以降のものを想定しています。 &lt;XXX> のついている項目はまだ作業中のものです。 この FreeBSD ドキュメンテーションプロジェクトに協力したいと思われる方は、 <a href=https://lists.FreeBSD.org/subscription/freebsd-doc>FreeBSD documentation project メーリングリスト</a> まで (英語で) 電子メールを送ってください。 この文書の最新バージョンは、いつでも <a href=http://www.jp.FreeBSD.org/>日本国内版 FreeBSD World Wide Web サーバ</a>や <a href=http://www.FreeBSD.org/>FreeBSD World Wide Web サーバ</a>で 見ることができます。 また、ひとつの巨大な <a href=.>HTML</a> ファイルとして HTTP でダウンロードすることもできます。 プレーンテキスト、PostScript、PDF、およびその他の形式のものは <a href=ftp://ftp.FreeBSD.org/pub/FreeBSD/doc/>FreeBSD FTP サーバ</a>に置かれています。 また、<a href=http://www.FreeBSD.org/search/>FAQ の検索</a>も可能です。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>2005 年 6 月現在、HTML 版以外の日本語 FAQ は用意されていません。</p></div></td></tr></tbody></table></div><div class=paragraph><p>日本語版の作成は FreeBSD 日本語ドキュメンテーションプロジェクトが オリジナルの英語版をもとにして行なっています。 FreeBSD FAQ 日本語訳および、 FreeBSD FAQ 日本語版のみに関連することは、 日本語ドキュメンテーションプロジェクト &lt;<a href=mailto:doc-jp@jp.FreeBSD.org>doc-jp@jp.FreeBSD.org</a>> において日本語で議論されています。 必要に応じて日本語ドキュメンテーションプロジェクトから、 FreeBSD Documentation Project に対してフィードバックを行ないますので、 英語が得意でない方は 日本語ドキュメンテーションプロジェクト &lt;<a href=mailto:doc-jp@jp.FreeBSD.org>doc-jp@jp.FreeBSD.org</a>> まで日本語でコメントをお寄せください。</p></div><div class=paragraph><p>また、この FreeBSD FAQ とは別に、日本の FreeBSD ユーザ有志によって FreeBSD users-jp メーリングリスト &lt;<a href=mailto:FreeBSD-users-jp@jp.FreeBSD.org>FreeBSD-users-jp@jp.FreeBSD.org</a>> やニュースグループ <a href=news:fj.os.bsd.freebsd>fj.os.bsd.freebsd</a> などへの投稿をもとに作成された <a href=http://www.jp.FreeBSD.org/QandA/>QandA</a> が公開されています。 特に日本語環境など日本固有の話題が充実していますので、 こちらも合わせてご覧ください。</p></div><hr></div></div><div class=sect1><h2 id=preface>まえがき<a class=anchor href=#preface></a></h2><div class=sectionbody><div class=paragraph><p>FreeBSD 2.X-4.X FAQ へようこそ!</p></div><div class=paragraph><p>Usenet の FAQ がそうであるように、 この文書も FreeBSD オペレーティングシステムに関して 頻繁に尋ねられる質問を網羅することを目的としています (もちろんそれに対する答えも!)。 FAQ は本来バンド幅を減らし、 同じ質問が何度も繰り返されるのを避けるために作られたものですが、 最近は有用な情報源と見なされるようになってきました。</p></div><div class=paragraph><p>この FAQ をできる限り有用なものにしようと、 あらゆる努力がはらわれています。 もし何かしらの改善案が浮かんだら、ぜひ FAQ 管理者 &lt;<a href=mailto:faq@FreeBSD.org>faq@FreeBSD.org</a>> までメールを送ってください。</p></div><div class=sect2><h3 id=_freebsd_って何>FreeBSD って何?<a class=anchor href=#_freebsd_って何></a></h3><div class=paragraph><p>FreeBSD とは一言で言えば、カリフォルニア大学バークレイ校から リリースされた "4.4BSD-Lite" と "4.4BSD-Lite2" による 強化の一部に由来する、 i386 および Alpha/AXP 系のプラットフォーム向けの UN*X ライクなオペレーティングシステムです。 間接的には同じバークレイ校の "Net/2" を William Jolitz が i386 系に移植した "386BSD" も基にしていますが、 386BSD のコードはほとんど残っていません。 FreeBSD についての詳細と、何ができるかについては <a href=http://www.FreeBSD.org/>FreeBSD のホームページ</a> を参照してください。</p></div><div class=paragraph><p>FreeBSD は企業やインターネットサービスプロバイダ、研究者、 コンピュータ専門家、学生、家庭のユーザなどにより、業務や教育、 娯楽に用いられています。これらに関しては <a href=http://www.FreeBSD.org/gallery/gallery/>FreeBSD ギャラリー</a>をご覧ください。</p></div><div class=paragraph><p>FreeBSD に関するより詳しい情報は <a href=https://docs.freebsd.org/ja/books/handbook/>FreeBSD ハンドブック</a>を参照してください。</p></div></div><div class=sect2><h3 id=_freebsd_が目指しているもの>FreeBSD が目指しているもの<a class=anchor href=#_freebsd_が目指しているもの></a></h3><div class=paragraph><p>FreeBSD プロジェクトの目的は、 いかなる用途にも使用でき、 何ら制限のないソフトウェアを供給することです。 私たちの多くは、 コード (そしてプロジェクト) に対してかなりの投資をしてきており、 これからも多少の代償はあっても投資を続けて行くつもりです。 ただ、他の人達にも同じような負担をするように主張しているわけではありません。 FreeBSD に興味を持っている一人残らずすべての人々に、 目的を限定しないでコードを提供すること。 これが、 私たちの最初のそして最大の「任務」であると信じています。 そうすれば、コードは可能な限り広く使われ、 最大の恩恵をもたらすことができるでしょう。 これが、私たちが熱烈に支持しているフリーソフトウェアの最も基本的な目的であると、 私は信じています。</p></div><div class=paragraph><p>私たちのソースツリーに含まれるソースのうち、GNU 一般公有使用許諾 (GPL) または GNU ライブラリ 一般公有使用許諾 (LGPL) に従っているものについては、 多少制限が科されています。ただし、 ソースコードへのアクセスの保証という、 一般の制限とはいわば逆の制限です。 ただし GPL ソフトウェアを商用で利用する場合、 さらに複雑になるのは避けられません。 そのため、それらのソフトウェアを、より制限の少ない BSD 著作権に従ったソフトウェアで置き換える努力を、 可能な限り日々続けています。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>GPL では、「ソースコードを実際に受け取るか、 あるいは希望しさえすればそれを入手することが可能であること」を求めています。</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=_どうして_freebsd_と呼ばれているのですか>どうして FreeBSD と呼ばれているのですか?<a class=anchor href=#_どうして_freebsd_と呼ばれているのですか></a></h3><div class=ulist><ul><li><p>無料 (free) で使うことができる (商利用も含む)。</p></li><li><p>オペレーティングシステムの完全なソースコードが自由 (freely) に手に入り、 商利用・非商利用にかかわらず、最低限の制限で他の仕事への利用、配布、導入が可能。</p></li><li><p>改良やバグフィックスがある場合、 誰でも (free) そのコードを提出でき、 ソースツリーに加えることができます (いくつかの簡単な条件には従ってもらいます)。</p></li></ul></div><div class=paragraph><p>母国語が英語でない読者のために、ここでは "free" という単語が二つの意味で用いられていることを指摘しておくと分かりやすいかも知れません。 ひとつは「無料である」ということ、 もうひとつは「自分のやりたいようにできる」ということです。 FreeBSD のコードで<em>できない</em>いくつかのこと (自分が書いたものだと偽るなど) を除けば、 あなたは自分のやりたいことをやることが可能なのです。</p></div></div><div class=sect2><h3 id=_freebsd_の最新バージョンは>FreeBSD の最新バージョンは?<a class=anchor href=#_freebsd_の最新バージョンは></a></h3><div class=paragraph><p><a href=ftp://ftp.FreeBSD.org/pub/FreeBSD/releases/i386/4.3-RELEASE/>4.3</a> が最新の <em>STABLE</em> バージョンで、 2001 年 4 月にリリースされました。 また、これは最新の <em>RELEASE</em> バージョンでもあります。</p></div><div class=paragraph><p>簡単に言ってしまうと、<em>-STABLE</em> は最新の <em>-CURRENT</em> のスナップショットのすばらしい新機能の数々よりも、 安定性と変更回数の少なさを好む ISP や、 他の企業のユーザをターゲットにしています。 リリースはこの二種類のブランチで行なわれますが、 (<em>-STABLE</em> と比較すると多少) 不安定な動作があるということを許容できるなら、 必要となるのは <em>-CURRENT</em> の方だけでしょう。</p></div><div class=paragraph><p>各リリースは<a href=#release-freq>数カ月毎</a>にしか行なわれません。 多くの人々が FreeBSD のソースをそのリリースよりも 最新の状態に維持している (<a href=#current>FreeBSD-current</a> と <a href=#stable>FreeBSD-stable</a> に関する質問も参照してください) のですが、 ソースというのは常に改変され続けているため、 そうすることは一種の慣例になっています。</p></div></div><div class=sect2><h3 id=_freebsd_currentって何>FreeBSD-CURRENTって何?<a class=anchor href=#_freebsd_currentって何></a></h3><div class=paragraph><p><a href=https://docs.freebsd.org/ja/books/handbook/updating-upgrading#current>FreeBSD-CURRENT</a> はオペレーティングシステムの開発バージョンで、 やがて 5.0-RELEASE となります。よってこれは、そこに携わっている開発者や、 どんな障害をも乗り越えていけるタフな愛好家たちにとってのみ興味の対象となるものです。 -CURRENT の使用に際しての詳細は <a href=https://docs.freebsd.org/ja/books/handbook/>FreeBSD ハンドブック</a> の <a href=https://docs.freebsd.org/ja/books/handbook/updating-upgrading#current>関連するセクション</a> を参照してください。</p></div><div class=paragraph><p>オペレーティングシステムに馴染みがない場合や、 それが一時的に発生している問題なのか、 それとも本質的な問題かを見極める能力がない場合は、 FreeBSD-CURRENT を使うべきではありません。 このブランチは時々急激に拡張されたり、 システムが構築できない状態になることもしょっちゅうあります。 FreeBSD-CURRENT を使う人は問題を分析し、 「小さな欠陥」ではなく、 明らかに間違いであると思われるものだけを報告できるものと想定されています。 「make world したら group 関係でエラーがでました」のような質問は、 -CURRENT メーリングリストでは軽蔑の眼差しであしらわれることもあります。</p></div><div class=paragraph><p>毎日、その時点の -CURRENT と -STABLE のコードを元に <a href=http://www.FreeBSD.org/releases/snapshots/>snapshot</a> が作成されています。 現在は、その snapshot の配布も利用可能です。 それぞれの snapshot には以下のような目的があります。</p></div><div class=ulist><ul><li><p>インストールプログラムの最新版のテスト。</p></li><li><p>試してみたいけれど、 基礎的な所から毎日変わるようなものを追いかける時間もバンド幅も無い、 という人にも -CURRENT や -STABLE を使えるようにする。 また、そのような人たちのシステム移行のための手っ取り早い方法を提供する。</p></li><li><p>あとでとんでもないことをしてしまった時のために、 問題となるコードの特定の参照基準点を保存しておく。 (通常は CVS がこういうハプニングのような恐ろしい事態を防止して いるんですけどね :)</p></li><li><p>テストが必要な新しい機能を、 できる限り多くの隠れテスターに試してもらう。</p></li></ul></div><div class=paragraph><p>どんな目的であれ、-CURRENT snapshot が "製品レベルの品質" であるとの考えに基づく要求は行わないでください。 安定性やテスト十分性にこだわる人は、 完全なリリース、あるいは -STABLE snapshot から離れてはいけません。</p></div><div class=paragraph><p>スナップショットリリースは、5.0-CURRENT が <a href=ftp://current.FreeBSD.org/pub/FreeBSD/>ftp://current.FreeBSD.org/pub/FreeBSD/</a> から、4-STABLE が <a href=ftp://releng4.FreeBSD.org/pub/FreeBSD>releng4.FreeBSD.org</a> から直接入手可能です。 また、3-STABLE スナップショットは、 この文章の執筆時点 (2000 年 5 月) で作成されていません。</p></div><div class=paragraph><p>スナップショットリリースは、 現在、開発や保守作業が行なわれているすべてのブランチにおいて、 平均して一日一回作成されます。</p></div></div><div class=sect2><h3 id=_freebsd_stable_のコンセプトは何ですか>FreeBSD-STABLE のコンセプトは何ですか?<a class=anchor href=#_freebsd_stable_のコンセプトは何ですか></a></h3><div class=paragraph><p>FreeBSD 2.0.5 がリリースされた後、私たちは FreeBSD の開発を 2 系統に分割することにしました。 一つは <a href=https://docs.freebsd.org/ja/books/handbook/cutting-edge#stable>-STABLE</a> というブランチで、バグの修正はしっかりテストされ、 機能の強化は少しずつしか行われません (急な変更や実験的機能を望まない、 インターネットサービスプロバイダや営利企業向け)。 もう一方のブランチは <a href=https://docs.freebsd.org/ja/books/handbook/cutting-edge#current>-CURRENT</a> で、2.0 がリリースされて以来 5.0-RELEASE (そしてその後も) へ向けて脈々と続いているものです。 ASCII で描いた簡単な図がわかりやすいかは自信がありませんが、 こんな感じになります。</p></div><div class="literalblock programlisting"><div class=content><pre>                2.0
                |
                |
                |  [2.1-STABLE]
*BRANCH*       2.0.5 -&gt; 2.1 -&gt; 2.1.5 -&gt; 2.1.6 -&gt; 2.1.7.1  [2.1-STABLE 終了]
                |                         (1997/03)
                |
                |
                |  [2.2-STABLE]
*BRANCH*       2.2.1 -&gt; 2.2.2-RELEASE -&gt; 2.2.5 -&gt; 2.2.6 -&gt; 2.2.7 -&gt; 2.2.8 [終了]
                |         (1997/03)     (1997/10)   (1998/04)   (1998/07)   (1998/12)
                |
                |
              3.0-SNAPs  (1997 年第一四半期開始)
                |
                |
              3.0-RELEASE (1998/10)
                |
                |  [3.0-STABLE]
*BRANCH*      3.1-RELEASE  (1999/02) -&gt; 3.2 -&gt; 3.3 -&gt; 3.4 -&gt; 3.5 -&gt; 3.5.1
                |                   (1999/05) (1999/09) (1999/12) (2000/06) (2000/07)
                |  [4.0-STABLE]
*BRANCH*        4.0  (2000/03) -&gt;4.1 -&gt; 4.1.1 -&gt; 4.2 -&gt; 4.3 -&gt; ... 将来の 4.x リリース ...
                |
                |             (2000/07)   (2000/09)   (2000/11)
                |
                \|/
                +
        [5.0-CURRENT として継続中]</pre></div></div><div class=paragraph><p>-CURRENT ブランチは 5.0 とその先へ向けてゆっくりと進化を続けています。 従来あった 2.2-STABLE ブランチは 2.2.8 のリリースをもって終了しました。 3-STABLE がそれに代わり、2000 年 7 月に 3.5.1-RELEASE (最後の 3.X リリース) がリリースされました。 2000 年 3 月 (3.5 の公開前になりますが) には、 3-STABLE ブランチはほぼ、4-STABLE ブランチによって置き換えられました。 4.3-RELEASE は 2001 年 4 月にリリースされました。 4-STABLE は現在 -STABLE ブランチで活発に開発が続けられていますが、 3-STABLE へのバグの修正 (ほとんどがセキュリティ関連のもの) もまだ行なわれています。 3.X ブランチは 2000 年の夏には公式に開発が終了する予定です。 現在の "current branch" は 5.0-CURRENT であり、 最初の 5.0 系列のリリース予定はまだ決定していません。</p></div></div><div class=sect2><h3 id=_freebsd_のリリースはいつ作られるのですか>FreeBSD のリリースはいつ作られるのですか?<a class=anchor href=#_freebsd_のリリースはいつ作られるのですか></a></h3><div class=paragraph><p>FreeBSD コアチームは原則的に、 新しい機能やバグフィックスが充分集まり、 リリースの安定性を損なうことが無いよう、 さまざまな変更が十分に安定しているという条件を満たしている場合にのみ、 新しいバージョンの FreeBSD をリリースします。 たとえこの用心深さが新しい機能が使えるようになることを 待ち望んでいるユーザを欲求不満にさせるとしても、 多くのユーザはこのことを FreeBSD の最も良い所の一つだと考えています。</p></div><div class=paragraph><p>リリースの作成は、平均的に言っておよそ 4 ヶ月ごとに行なわれます。</p></div><div class=paragraph><p>もう少し刺激が欲しい (あるいは待ち遠しい) 方々向けには、 毎日バイナリスナップショットが作成されています。 上記を参照してください。</p></div></div><div class=sect2><h3 id=_freebsd_は_pc_用だけしかないの>FreeBSD は PC 用だけしかないの?<a class=anchor href=#_freebsd_は_pc_用だけしかないの></a></h3><div class=paragraph><p>FreeBSD 3.x 以降は x86 アーキテクチャと同様、 <a href=http://www.FreeBSD.org/alpha/>DEC Alpha</a> でも動作します。 また、SPARC、PowerPC、IA64 への移植という興味深い話もあります。</p></div><div class=paragraph><p>異なるアーキテクチャのマシンを 持っていて、ゆっくり待てないという場合には次の URL を 参照してください。</p></div><div class=paragraph><p><a href=http://www.netbsd.org/>NetBSD</a> または <a href=http://www.openbsd.org/>OpenBSD</a>。</p></div></div><div class=sect2><h3 id=_freebsd_の責任者はいったい誰>FreeBSD の責任者はいったい誰?<a class=anchor href=#_freebsd_の責任者はいったい誰></a></h3><div class=paragraph><p>プロジェクトの全体的な方向性や、 誰にソースツリーにコードの書き込み権限を与えるか、 などといった FreeBSD プロジェクトに関する重要な意思決定は、 9 名からなる<a href=https://docs.freebsd.org/ja/books/handbook/>コアチーム (core team)</a> によってなされます。 ソースツリーを直接変更できる人はもっと多く、 200 名以上の<a href=https://docs.freebsd.org/ja/books/handbook/>ソースツリー管理者 (committer)</a> がいます。</p></div><div class=paragraph><p>しかし、<a href=#mailing>メーリングリスト</a>で先行して議論される、 通常の変更ではないものの議論への参加には、一切制限はありません。</p></div></div><div class=sect2><h3 id=_どこから_freebsd_を入手できますか>どこから FreeBSD を入手できますか?<a class=anchor href=#_どこから_freebsd_を入手できますか></a></h3><div class=paragraph><p>FreeBSD のすべての主要なリリースは anonymous FTP 経由で <a href=ftp://ftp.FreeBSD.org/pub/FreeBSD/>FreeBSD FTP サイト</a> から入手できます。</p></div><div class=ulist><ul><li><p>現在の 3.X-STABLE リリース、3.5.1-RELEASE は <a href=ftp://ftp.FreeBSD.org/pub/FreeBSD/releases/i386/3.5.1-RELEASE/>3.5.1-RELEASE のディレクトリ</a>にあります。</p></li><li><p>現在の 4-STABLE リリース、4.3-RELEASE は <a href=ftp://ftp.FreeBSD.org/pub/FreeBSD/releases/i386/4.3-RELEASE/>4.3-RELEASE のディレクトリ</a>にあります。</p></li><li><p><a href=ftp://releng4.FreeBSD.org/pub/FreeBSD/>4.X Snapshot</a> は、ほぼ一日に一回作成されています。</p></li><li><p><a href=ftp://current.FreeBSD.org/pub/FreeBSD/>5.0 Snapshot</a> リリースは <a href=#current>-CURRENT</a> ブランチ用に一日に一回作成されており、 これらは純粋に最先端の開発者およびテスターのために提供されています。</p></li></ul></div><div class=paragraph><p>また、FreeBSD は CD-ROM でも入手でき、次のところで注文できます。</p></div><div class=paragraph><p>BSDi<br>4041 Pike Lane, Suite F<br>Concord, CA<br>94520<br>USA</p></div><div class=paragraph><p>Orders: +1 800 786-9907<br>Questions: +1 925 674-0783<br>FAX: +1 925 674-0821<br>email: BSDi Orders address<br>WWW: BSDi Home pageOrders: +1 800 786-9907</p></div><div class=paragraph><p>オーストラリアでは、次のところに問い合わせてください。</p></div><div class=paragraph><p>Advanced Multimedia Distributors<br>Factory 1/1 Ovata Drive<br>Tullamarine, Melbourne<br>Victoria<br>Australia<br>Voice: +61 3 9338 6777</p></div><div class=paragraph><p>CDROM Support BBS<br>17 Irvine St<br>Peppermint Grove, WA<br>6011<br>Voice: +61 9 385-3793<br>Fax: +61 9 385-2360</p></div><div class=paragraph><p>イギリスの場合は次のところです。</p></div><div class=paragraph><p>The Public Domain & Shareware Library<br>Winscombe House, Beacon Rd<br>Crowborough<br>Sussex. TN6 1UL<br>Voice: +44 1892 663-298<br>Fax: +44 1892 667-473</p></div></div><div class=sect2><h3 id=_freebsd_のメーリングリストについて知りたいのですが>FreeBSD のメーリングリストについて知りたいのですが?<a class=anchor href=#_freebsd_のメーリングリストについて知りたいのですが></a></h3><div class=paragraph><p>完全な情報が <a href=https://docs.freebsd.org/ja/books/handbook/eresources#eresources-mail>FreeBSD ハンドブックのメーリングリストの節</a> にあります。</p></div></div><div class=sect2><h3 id=_freebsd_のニュースグループは何がありますか>FreeBSD のニュースグループは何がありますか?<a class=anchor href=#_freebsd_のニュースグループは何がありますか></a></h3><div class=paragraph><p>完全な情報が <a href=https://docs.freebsd.org/ja/books/handbook/eresources#eresources-news>FreeBSD ハンドブックのニュースグループの節</a>にあります。</p></div></div><div class=sect2><h3 id=_freebsd_の_irc_internet_relay_chat_について何か情報はありますか>FreeBSD の IRC (Internet Relay Chat) について何か情報はありますか?<a class=anchor href=#_freebsd_の_irc_internet_relay_chat_について何か情報はありますか></a></h3><div class=paragraph><p>あります。 以下のように、ほとんどの有名な IRC ネットワークには FreeBSD のチャットチャンネルがあります。</p></div><div class=ulist><ul><li><p>EFNet の Channel <code>#FreeBSD</code> は FreeBSD 関係のフォーラムですが、 そこで技術的サポートを期待してはいけません。 そこにいる人たちはあなたをマニュアルページを読むとか、 研究をするとかといった苦労から遠ざけようとします。 まず第一に、これはチャットチャンネルであり、 そこにあるトピックスは恋人募集、スポーツ、 核兵器といったようなものであり、 FreeBSD も同列に扱われています。 一応注意しましたからね! これは <code>irc.chat.org</code> のサーバー上にあります。</p></li><li><p>EFNet の Channel <em>#FreeBSDhelp</em> は FreeBSD ユーザのヘルプ専用チャネルです。 参加者は <em>#FreeBSD</em> チャネルよりも親切に質問に答えてくれます。</p></li><li><p>DALNET の Channel <code>#FreeBSD</code> はアメリカでは <code>irc.dal.net</code>、 ヨーロッパでは <code>irc.eu.dal.net</code> にあります。</p></li><li><p>UNDERNET の Channel <code>#FreeBSD</code> はアメリカでは <code>us.undernet.org</code>、 ヨーロッパでは <code>eu.undernet.org</code> にあります。 ここはヘルプチャンネルです。 ドキュメントを読める準備をしてから利用してください。</p></li><li><p><a href=http://www.hybnet.net/>HybNet</a> の Channel <code>#FreeBSD</code>。 このチャンネルはへルプチャンネル<em>です</em>。 サーバーのリストは <a href=http://www.hybnet.net/>HybNet のウェブサイト</a> にあります。</p></li></ul></div><div class=paragraph><p>それぞれのチャンネルは別個のもので、 互いに接続されていません。 チャットのスタイルも違っていますので、 自分のチャットのスタイルにあったものを見つけるために一つ一つ試すのもいいでしょう。 あらゆる種類の IRC トラフィックのため、失礼なことをいう若者たち (年輩の方は少数です) のために機嫌を損ねたり、 手に負えなくなっても気にしてはいけません。</p></div></div><div class=sect2><h3 id=_freebsd_の本>FreeBSD の本<a class=anchor href=#_freebsd_の本></a></h3><div class=paragraph><p><a href=https://lists.FreeBSD.org/subscription/freebsd-doc>FreeBSD documentation project メーリングリスト</a> にコンタクトしてみてください (さらに参加すればもっとよいでしょう)。 このメーリングリストは FreeBSD 関連の文書に関する議論のためのものです。 FreeBSD に関する質問に対しては、 <a href=https://lists.FreeBSD.org/subscription/freebsd-questions>FreeBSD general questions メーリングリスト</a> というメーリングリストがあります。</p></div><div class=paragraph><p><a href=https://docs.freebsd.org/ja/books/handbook/>FreeBSD ハンドブック</a>もあります。 これは現在作業中で、 不完全だったり最新情報でないものが含まれていることに注意してください。</p></div><div class=paragraph><p>FreeBSD のガイド本の決定版は、 Greg Lehey 氏による "The Complete FreeBSD" です。 これは BSDi (以前の Walnut Creek CDROM) Books から出版されています。 現在は第三版になっていて、 インストール、システム管理ガイド、プログラム設定のヘルプ、 マニュアルページまでの内容が 773 ページにわたって書かれています。 この本は (そして現在の FreeBSD リリースは) <a href=http://www.osd.bsdi.com/>BSDi</a>、 <a href=http://www.cheapbytes.com/>CheapBytes</a>、 または最寄りの書店で注文することができます。 ISBN コードは 1-57176-246-9 です (これ以外のコードの場合もあるかもしれません)。</p></div><div class=paragraph><p>また、FreeBSD は Berkeley 4.4BSD-Lite ベースなので、多くの 4.4BSD のマニュアルが FreeBSD にも応用できます。 O’Reilly and Associates が以下のマニュアルを出版しています。</p></div><div class=paragraph><p>これらの詳細な説明が WWW 経由で <a href=http://gnn.com/gnn/bus/ora/category/bsd.html>4.4BSD books description</a> から読むことができます。 販売数が少ないためこれらのマニュアルは入手しにくいかもしれません。</p></div><div class=paragraph><p>4.4BSD のカーネル構成についてより徹底的に知りたいのなら、 <a href=#biblio-44kernel>[biblio-44kernel]</a> なら間違いないでしょう。</p></div><div class=paragraph><p>システム管理についての良書が <a href=#biblio-nemeth3rd>[biblio-nemeth3rd]</a> です。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>初版ではなく、紫色のカバーの第三版であるか確認してくだ さい。</p></div></td></tr></tbody></table></div><div class=paragraph><p>この本は TCP/IP だけでなく DNS、NFS、SLIP/PPP、sendmail、 INN/NNTP、印刷などの基礎を扱っています。 高価ですが、買う価値はあります。 第三版では、Solaris, HP/UX, FreeBSD および Linux を取り扱っています。</p></div></div><div class=sect2><h3 id=_障害報告_pr_problem_report_データベースにアクセスする方法は>障害報告 (PR; Problem Report) データベースにアクセスする方法は?<a class=anchor href=#_障害報告_pr_problem_report_データベースにアクセスする方法は></a></h3><div class=paragraph><p>ユーザからの変更要求がまとめられている Problem Report データベースは、 障害報告の web ベースのインタフェースを通して、 <a href=http://www.FreeBSD.org/ja/send-pr/>提出</a>と<a href=http://www.FreeBSD.org/cgi/query-pr-summary.cgi?query>問い合わせ</a>を行なうことができます。 また、<a href="https://man.freebsd.org/cgi/man.cgi?query=send-pr&amp;sektion=1&amp;format=html">send-pr(1)</a> コマンドを使用して、 電子メール経由で障害報告や変更要求を提出することもできます。</p></div></div><div class=sect2><h3 id=_プレインテキスト_ascii_版_や_postscript_版の_freebsd_文書はないのでしょうか>プレインテキスト (ASCII) 版 や PostScript 版の FreeBSD 文書はないのでしょうか?<a class=anchor href=#_プレインテキスト_ascii_版_や_postscript_版の_freebsd_文書はないのでしょうか></a></h3><div class=paragraph><p>はい、もちろんあります。 数多くの異なるフォーマット、圧縮形式の文書が FreeBSD FTP サイトの <a href=ftp://ftp.FreeBSD.org/pub/FreeBSD/doc/>/pub/FreeBSD/doc/</a> というディレクトリから入手可能です。</p></div><div class=paragraph><p>文書は、次のようなさまざまな観点から分類されています。</p></div><div class=ulist><ul><li><p><code>faq</code> や <code>handbook</code> といった文書名による分類。</p></li><li><p>文書の言語とエンコーディングによる分類。これは FreeBSD システムの <span class=filename>/usr/shared/locale</span> にある locale 名に基づいています。 現在利用可能な言語、エンコーディングは以下のとおりです。</p><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">名前</th><th class="tableblock halign-left valign-top">意味</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>en_US.ISO8859-1</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>英語 (米国)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>de_DE.ISO_8859-1</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>ドイツ語</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>es_ES.ISO8859-1</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>スペイン語</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>fr_FR.ISO8859-1</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>フランス語</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>ja_JP.eucJP</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>日本語 (EUC エンコーディング)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>ru_RU.KOI8-R</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>ロシア語 (KOI8-R エンコーディング)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>zh_TW.Big5</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>中国語 (Big5 エンコーディング)</p></td></tr></tbody></table><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>言語によっては準備されていない文書も存在します。</p></div></td></tr></tbody></table></div></li><li><p>文書の形式による分類。 文書は数多くの異なる出力形式を用意し、 可能な限り柔軟な対応ができるようにしています。 現在、利用可能な文書形式は以下のとおりです。</p><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">文書形式</th><th class="tableblock halign-left valign-top">意味</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>html-split</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>サイズの小さい、 リンクされた複数の HTML ファイル</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>html</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>文書全体を含んだ、単一の大きなファイル</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>pdb</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://www.iSilo.com/>iSilo</a> で利用可能な Palm Pilot データベース形式</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>pdf</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Adobe 社の PDF (Portable Document Format) 形式</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>ps</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Postscript 形式</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>rtf</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Microsoft 社のリッチテキスト形式</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>txt</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>プレインテキスト形式</p></td></tr></tbody></table></li><li><p>圧縮と package 形式による分類。 現在利用されているのは次の 3 種類です。</p><div class="olist loweralpha"><ol class=loweralpha type=a><li><p><code>html-split</code> 形式の場合、 ファイルはまず、<a href="https://man.freebsd.org/cgi/man.cgi?query=tar&amp;sektion=1&amp;format=html">tar(1)</a> を使ってまとめられ、 まとめられた <span class=filename>.tar</span> ファイルは次に解説する方式で圧縮されます。</p></li><li><p>その他の形式の場合、ファイルは <span class=filename>book.format</span> (たとえば <span class=filename>book.pdb</span>、 <span class=filename>book.html</span> など) という単一のファイルです。</p><div class=paragraph><p>上にあげたファイルは 3 種類の方式のいずれかで圧縮されます。</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">方式</th><th class="tableblock halign-left valign-top">説明</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>zip</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Zip 形式。 FreeBSD で圧縮を元に戻すには、まず <span class=filename>archivers/unzip</span> の port をインストールする必要があります。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>gz</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>GNU Zip 形式。圧縮を元に戻すには、 FreeBSD に含まれる <a href="https://man.freebsd.org/cgi/man.cgi?query=gunzip&amp;sektion=1&amp;format=html">gunzip(1)</a> を使います。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>bz2</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>BZip2 形式。 他の形式に比べて普及していませんが、 一般的にファイルサイズが小さくなります。 圧縮を元に戻すには、 <span class=filename>archivers/bzip2</span> port をインストールしてください。</p></td></tr></tbody></table><div class=paragraph><p>Postscript 版のハンドブックが BZip2 形式で圧縮されている場合、ファイル名は <span class=filename>handbook/</span> ディレクトリの中の <span class=filename>book.xml.bz2</span> になります。</p></div></li><li><p>さまざまな形式に整形された文書は、以下に述べるように FreeBSD の package としても提供されています。</p></li></ol></div></li></ul></div><div class=paragraph><p>ダウンロードする文書と圧縮形式を選択したら、 文書を FreeBSD <em>package</em> としてダウンロードするかどうか決めなければなりません。</p></div><div class=paragraph><p>package としてダウンロードしてインストールする場合には、 文書を <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg_add&amp;sektion=1&amp;format=html">pkg_add(1)</a> や <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg_delete&amp;sektion=1&amp;format=html">pkg_delete(1)</a> といった、普通の FreeBSD package 管理システムを用いた管理が可能であるという利点があります。</p></div><div class=paragraph><p>文書の package をダウンロードしてインストールすることに決めたら、 まずはダウンロードするファイル名を知る必要があります。 文書の package は、<span class=filename>packages</span> というディレクトリに置かれています。 そしてそれぞれの package ファイルは、 <span class=filename>文書名.言語.エンコーディング.形式.tgz</span> というような名前になっています。</p></div><div class=paragraph><p>たとえば、FAQ の英語版で PDF 形式のものは、 <span class=filename>faq.en_US.ISO8859-1.pdf.tgz</span> というファイル名です。</p></div><div class=paragraph><p>ファイル名がわかったら、 次のようなコマンドで英語版の PDF 形式 FAQ の package をインストールすることができます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg_add ftp://ftp.FreeBSD.org/pub/FreeBSD/doc/packages/faq.en_US.ISO8859-1.pdf.tgz</span></code></pre></div></div><div class=paragraph><p>インストールの終了後は <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg_info&amp;sektion=1&amp;format=html">pkg_info(1)</a> を使い、 ファイルがどこにインストールされたかを調べることができます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg_info -f faq.en_US.ISO8859-1.pdf</span>
Information <span class=k>for </span>faq.en_US.ISO8859-1.pdf:

Packing list:
        Package name: faq.en_US.ISO8859-1.pdf
        CWD to /usr/shared/doc/en_US.ISO8859-1/books/faq
File: book.pdf
        CWD to <span class=nb>.</span>
File: +COMMENT <span class=o>(</span>ignored<span class=o>)</span>
File: +DESC <span class=o>(</span>ignored<span class=o>)</span></code></pre></div></div><div class=paragraph><p>ご覧になるとわかるとおり、<span class=filename>book.pdf</span> は <span class=filename>/usr/shared/doc/en_US.ISO8859-1/books/faq</span> にインストールされます。</p></div><div class=paragraph><p>package を利用しない場合は、 自分で圧縮されたファイルをダウンロードして元に戻し、 適切な場所にそれをコピーする必要があります。</p></div><div class=paragraph><p>たとえば、分割された HTML 版の FAQ で、 <a href="https://man.freebsd.org/cgi/man.cgi?query=gzip&amp;sektion=1&amp;format=html">gzip(1)</a> で圧縮されているものは <span class=filename>en_US.ISO8859-1/books/faq/book.html-split.tar.gz</span> というファイルです。 これをダウンロードして圧縮を元に戻すには、次のようにする必要があるでしょう。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># fetch ftp://ftp.freebsd.org/pub/FreeBSD/doc/en_US.ISO8859-1/books/faq/book.html-split.tar.gz</span>
<span class=c># gzip -d book.html-split.tar.gz</span>
<span class=c># tar xvf book.html-split.tar</span></code></pre></div></div><div class=paragraph><p>こうすると、複数の <span class=filename>.html</span> ファイルが作成されます。 中心となっているのは <span class=filename>index.html</span> という名前のファイルで、 目次や前書き、文書の他の部分へのリンクが含まれています。 これらのファイルは、必要に応じて他の場所にコピーしても構いません。</p></div></div><div class=sect2><h3 id=_freebsd_のウェブサイトのミラーサイトになりたいです>FreeBSD のウェブサイトのミラーサイトになりたいです!<a class=anchor href=#_freebsd_のウェブサイトのミラーサイトになりたいです></a></h3><div class=paragraph><p>承知しました! ウェブページをミラーするにはいくつかの手段があります。</p></div><div class=ulist><ul><li><p>CVSup を使います。 CVSup を使って CVSup サーバに接続することで、 整形されたファイルを取ってくることができます。</p><div class=paragraph><p>ウェブページを取得する場合は、 <span class=filename>/usr/shared/examples/cvsup/www-supfile</span> にある supfile の例を参考にしてください。</p></div></li><li><p>FTP を使ってミラーリングします。 あなたの好きな FTP ミラーリングツールを使って、 FTP サーバに置いてある web サイトのコピーをダウンロードすることができます。 タウンロードは単純に <a href=ftp://ftp.FreeBSD.org/pub/FreeBSD/FreeBSD-CURRENT/www class=bare>ftp://ftp.FreeBSD.org/pub/FreeBSD/FreeBSD-CURRENT/www</a> から始めてください。</p></li></ul></div></div><div class=sect2><h3 id=_この文書を他の言語に翻訳したいのですが>この文書を他の言語に翻訳したいのですが?<a class=anchor href=#_この文書を他の言語に翻訳したいのですが></a></h3><div class=paragraph><p>報酬は支払えませんが、 文書の翻訳を提出してくださる方には、 フリーの CD、T シャツの手配や、 ハンドブックにある貢献者一覧への登録を行ないたいと思います。 翻訳作業をはじめる前に、 <a href=https://lists.FreeBSD.org/subscription/freebsd-doc>FreeBSD documentation project メーリングリスト</a> へ連絡するようにお願いします。 翻訳作業を手伝うという人が現われるかも知れませんし。 既に翻訳チームがあって、あなたの参加を歓迎してくれるかも知れません。</p></div></div><div class=sect2><h3 id=_その他の情報>その他の情報<a class=anchor href=#_その他の情報></a></h3><div class=paragraph><p>以下のニュースグループには FreeBSD ユーザに直接関係のある議論が行われてます。</p></div><div class=ulist><ul><li><p><a href=news:comp.unix.bsd.freebsd.announce>comp.unix.bsd.freebsd.announce</a> (moderated)</p></li><li><p><a href=news:comp.unix.bsd.freebsd.misc>comp.unix.bsd.freebsd.misc</a></p></li><li><p><a href=news:comp.unix.bsd.misc>comp.unix.bsd.misc</a></p></li></ul></div><div class=paragraph><p>Web 上のリソース:</p></div><div class=ulist><ul><li><p><a href=http://www.FreeBSD.org/>FreeBSD のホームページ</a></p></li><li><p><a id=pao></a>ラップトップ PC を持っている方は、 迷うことなく日本の<a href=http://www.jp.FreeBSD.org/PAO/>細川 達己氏の Mobile Computing のページ</a> を見ましょう。</p></li><li><p><a id=smp></a>SMP (Symmetric MultiProcessing) に関する情報は、 <a href=http://people.FreeBSD.org/~fsmp/SMP/SMP.html>SMP サポートページ</a>をご覧ください。</p></li><li><p><a id=multimedia></a>FreeBSD のマルチメディアアプリケーションに関する情報は、 <a href=http://people.FreeBSD.org/~faulkner/multimedia/mm.html>マルチメディア</a>のページをご覧ください。 特に <a href=http://people.FreeBSD.org/~ahasty/Bt848.html>Bt848</a> ビデオキャプチャチップに興味のある方は、 リンクをたどってみてください。</p></li></ul></div><div class=paragraph><p>FreeBSD ハンドブックには、 実に完成された<a href=https://docs.freebsd.org/ja/books/handbook/bibliography#bibliography>参考図書</a>の一覧があり、 買うべき本をさがしている方は読む価値があります。</p></div></div></div></div><div class=sect1><h2 id=_インストール>1. インストール<a class=anchor href=#_インストール></a></h2><div class=sectionbody><div class=sect2><h3 id=_freebsd_を入手するにはどのファイルをダウンロードすれば良いのでしょうか>1.1. FreeBSD を入手するには、どのファイルをダウンロードすれば良いのでしょうか?<a class=anchor href=#_freebsd_を入手するにはどのファイルをダウンロードすれば良いのでしょうか></a></h3><div class=paragraph><p>FreeBSD 3.1-RELEASE 以前では、 インストールの際に必要なのは <span class=filename>floppies/boot.flp</span> と名前のついた 一つのフロッピーディスクイメージだけでした。 しかし FreeBSD 3.1-RELEASE 以降、 幅広い種類のハードウェアサポートが基本システムに追加され、 そのサポートが必要とする容量を補うため、 3.X と 4.X の系列では新たに、 <span class=filename>floppies/kernel.flp</span> および <span class=filename>floppies/mfsroot.flp</span> という、二つのフロッピーディスクイメージを使うようになりました。 これらのイメージをフロッピーディスクに書き込むには、 <code>fdimage</code> や <a href="https://man.freebsd.org/cgi/man.cgi?query=dd&amp;sektion=1&amp;format=html">dd(1)</a> といったツールが必要となります。</p></div><div class=paragraph><p>(DOS ファイルシステムからのインストールなどで) あなた自身が手動で配布ファイルをダウンロードする場合には、 以下の配布ファイルをダウンロードすることをおすすめします。</p></div><div class=ulist><ul><li><p><span class=filename>bin/</span></p></li><li><p><span class=filename>manpages/</span></p></li><li><p><span class=filename>compat*/</span></p></li><li><p><span class=filename>doc/</span></p></li><li><p><span class=filename>src/ssys.*</span></p></li></ul></div><div class=paragraph><p>この手順の完全な説明と、一般的なインストール時の問題については <a href=https://docs.freebsd.org/ja/books/handbook/install#install>FreeBSD ハンドブックのインストールの節</a> を参照してください。</p></div></div><div class=sect2><h3 id=_ブートフロッピーイメージが一枚のフロッピーディスクに納まらないみたい>1.2. ブートフロッピーイメージが一枚のフロッピーディスクに納まらないみたい!<a class=anchor href=#_ブートフロッピーイメージが一枚のフロッピーディスクに納まらないみたい></a></h3><div class=paragraph><p>3.5 インチ (1.44MB) のフロッピーディスクには、 1474560 バイトのデータを格納できます。 ブートイメージはちょうど 1474560 バイトの大きさです。</p></div><div class=paragraph><p>ブートフロッピーディスクを準備する際のよくある間違いには、 以下のものがあります。</p></div><div class=ulist><ul><li><p>FTP によってフロッピーイメージをダウンロードする際に、 <em>バイナリ (binary)</em> モードにしていなかった。</p><div class=paragraph><p>FTP クライアントの中には、 転送モードのデフォルトを<em>アスキー (ascii)</em> モードにして、 クライアント側システムの慣習にあうよう、 すべての行末の文字を変更するものがあります。 この場合は常に、ブートイメージが壊れたものになります。 ダウンロードしたブートイメージのサイズをチェックしてください。 サーバ上のものと<em>正確に</em>一致しなければ、 ダウンロードの処理を疑いましょう。</p></div><div class=paragraph><p>これを回避するには、 サーバに接続してイメージのダウンロードを開始する前に FTP のコマンドプロンプトで <code>binary</code> とタイプします。</p></div></li><li><p>ブートイメージを DOS の <code>copy</code> コマンド (または GUI の同等のツール) でフロッピーディスクへ転送した。</p><div class=paragraph><p><code>copy</code> のようなプログラムは、 直接起動するように作成されたブートイメージをうまく処理できません。 イメージにはフロッピーディスクの完全な中身がトラック単位で格納されており、 フロッピーディスク上に通常のファイルとして 格納されるように想定されているわけではありません。 <a href=https://docs.freebsd.org/ja/books/handbook/install#install>FreeBSD のインストール</a>に記述されているように、 低レベルのツール (たとえば <code>fdimage</code> や <code>rawrite</code>) を使用して "そのままの (raw)" の状態でフロッピーディスクに 転送する必要があります。</p></div></li></ul></div></div><div class=sect2><h3 id=_freebsd_のインストールについての説明書はどこにありますか>1.3. FreeBSD のインストールについての説明書はどこにありますか?<a class=anchor href=#_freebsd_のインストールについての説明書はどこにありますか></a></h3><div class=paragraph><p>インストールの説明書は<a href=https://docs.freebsd.org/ja/books/handbook/install#install>FreeBSD ハンドブックのインストールの章</a>にあります。</p></div></div><div class=sect2><h3 id=_freebsd_を動作させるには何が必要ですか>1.4. FreeBSD を動作させるには何が必要ですか?<a class=anchor href=#_freebsd_を動作させるには何が必要ですか></a></h3><div class=paragraph><p>386 以上の PC、5MB 以上の RAM、 そして最低 60MB のハードディスク容量が必要となります。 ローエンドの MDA カードでも動作しますが、 X11R6 を使うには VGA かそれ以上のビデオカードが必要となります。</p></div><div class=paragraph><p><a href=#hardware>ハードウェアコンパチビリティ</a> もご覧ください。</p></div></div><div class=sect2><h3 id=_4mb_しかメモリがないのですがインストールできますか>1.5. 4MB しかメモリがないのですが、インストールできますか?<a class=anchor href=#_4mb_しかメモリがないのですがインストールできますか></a></h3><div class=paragraph><p>4MB のシステムにインストールできた最後の FreeBSD は FreeBSD 2.1.7 でした。2.2 を含むより新しいバージョンの FreeBSD は新規のインストールに最低 5MB は必要になります。</p></div><div class=paragraph><p>ただし、インストールプログラムが 4MB では動作しないだけで、 3.0 を含む FreeBSD のすべてのバージョンは 4MB の RAM で<em>動作可能</em>です。 インストールする時だけさらに 4MB 追加しておき、 システムがセットアップされて動作するようになった後、 また 4MB を取り出して元に戻すこともできます。 あるいは 4MB より多くメモリを搭載したシステムにディスクを持っていき、 そのマシンでインストールした後にディスクを戻すこともできます。</p></div><div class=paragraph><p>また、FreeBSD 2.1.7 であっても、4MB ではインストールできない場合があります。 正確には、640KB のベースメモリ + 3MB の拡張メモリでは、 インストールはできません。もしマシンのマザーボードが 640KB から 1MB の領域で「失われた」メモリを再マップできる場合は、 FreeBSD 2.1.7 をインストールできるかもしれません。</p></div><div class=paragraph><p>BIOS のセットアップ画面で、"remap" のオプションを探して有効 (enable) にしてみてください。 また、ROM shadowing を無効 (disable) にする必要もあります。</p></div><div class=paragraph><p>簡単なやり方としては、インストールする時だけあと 4MB 追加しておく方法があります。 必要なオプションだけを選択してカスタムカーネルを構築し、 また 4MB を取り出してもとに戻せばいいのです。</p></div><div class=paragraph><p>また、2.0.5 をインストールして、 それから 2.1.7 のインストーラの "upgrade" オプションでシステムを 2.1.7 へアップグレード するというやり方もあります。</p></div><div class=paragraph><p>インストールしたあとでカスタムカーネルの構築をした場合には、 4MB でも動作します。 2MB で起動に成功した人もいます (でもそのシステムは、 ほとんど使いものになりませんでした :-))。</p></div></div><div class=sect2><h3 id=_自分用のインストールフロッピーを作るには>1.6. 自分用のインストールフロッピーを作るには?<a class=anchor href=#_自分用のインストールフロッピーを作るには></a></h3><div class=paragraph><p>現在はカスタムインストールフロッピーディスク「だけ」を作る方法はありません。 カスタムインストールフロッピーディスクイメージを含む、 release 環境全体を新たに作る必要があります。</p></div><div class=paragraph><p>カスタムの release 環境をつくるには、 <a href=#custrel>ここの指示</a>にしたがってください。</p></div></div><div class=sect2><h3 id=_同じマシンで_windows_9598_と共存できますか>1.7. 同じマシンで Windows 95/98 と共存できますか?<a class=anchor href=#_同じマシンで_windows_9598_と共存できますか></a></h3><div class=paragraph><p>まず Windows 95/98 をインストールしてから、そのあとで FreeBSD をインストールしてください。FreeBSD のブートマネージャが Win95 と FreeBSD のブート管理をしてくれるようになります。 Windows 95/98 を後にインストールした場合はひどいことに、 問い合わせることもなくブートマネージャを上書きしてしまいます。 そうなってしまった場合は次の節をご覧ください。</p></div></div><div class=sect2><h3 id=_windows_9598_がブートマネージャを潰しちゃった_どうやって戻すの>1.8. Windows 95/98 がブートマネージャを潰しちゃった! どうやって戻すの?<a class=anchor href=#_windows_9598_がブートマネージャを潰しちゃった_どうやって戻すの></a></h3><div class=paragraph><p>ブートマネージャの再インストールの方法として、 FreeBSD では以下に示す三通りの方法が用意されています。</p></div><div class=ulist><ul><li><p>DOS を起動し、FreeBSD の配布物の中にある <span class=filename>tools/</span> ディレクトリへ移動し、 <span class=filename>bootinst.exe</span> を探してください。 そして次のように実行します。</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>...<span class=se>\T</span>OOLS&gt; bootinst.exe boot.bin</code></pre></div></div><div class=paragraph><p>こうすることで、 ブートマネージャが再インストールされます。</p></div></li><li><p>FreeBSD のブートフロッピーディスクから起動し、 「カスタム」インストールメニューを選択し、 続いて「パーティション」を選択します。 ブートマネージャがインストールされていたドライブ (多分最初のもの) を選択し、 パーティションエディタにたどり着いたら、 (何も変更せず) そのまま (W)rite を指定します。 確認のメッセージが出ますので「はい(Y)」と答え、 ブートマネージャ選択の画面で確実に "Boot Manager" を選択します。 これでブートマネージャがディスクに再び書き込まれます。 インストールメニューから抜けて再起動すると、 ハードディスクは元通りになります。</p></li><li><p>FreeBSD 起動フロッピー (もしくは CD-ROM) から起動し、 "Fixit" メニューを選択します。 Fixit フロッピーか CD-ROM #2 ("live" ファイルシステムオプション) の好きな方を選択して fixit シェルに入ります。 そして、次のコマンドを実行してください。</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Fixit# fdisk <span class=nt>-B</span> <span class=nt>-b</span> /boot/boot0 起動デバイス</code></pre></div></div><div class=paragraph><p><em>起動デバイス</em> の部分は、たとえば <span class=filename>ad0</span> (一番目の IDE ディスク)、 <span class=filename>ad4</span> (セカンダリ IDE コントローラの一番目の IDE ディスク)、 <span class=filename>da0</span> (一番目の SCSI ディスク) などといった、実際の起動デバイスを表しています。</p></div></li></ul></div></div><div class=sect2><h3 id=_ibm_thinkpad_の_atx_シリーズのいずれかを持っています_freebsd_をインストールしたら起動しなくなってしまいました_どうすればいいですか>1.9. IBM Thinkpad の A、T、X シリーズのいずれかを持っています。 FreeBSD をインストールしたら起動しなくなってしまいました。 どうすればいいですか?<a class=anchor href=#_ibm_thinkpad_の_atx_シリーズのいずれかを持っています_freebsd_をインストールしたら起動しなくなってしまいました_どうすればいいですか></a></h3><div class=paragraph><p>これらのマシンに使われている初期のリビジョンの IBM BIOS にはバグがあり、FreeBSD のパーティションをディスクサスペンド用の FAT 領域だと誤認します。 そのため、BIOS が FreeBSD のパーティションを 検出したところでシステムがハング (停止) してしまいます。</p></div><div class=paragraph><p>IBM によれば、以下のモデル/BIOS リリース番号には修正が含まれています。</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">モデル</th><th class="tableblock halign-left valign-top">BIOS リビジョン番号</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>T20</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>IYET49WW 以降</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>T21</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>KZET22WW 以降</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>A20p</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>IVET62WW 以降</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>A20m</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>IWET54WW 以降</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>A21p</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>KYET27WW 以降</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>A21m</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>KXET24WW 以降</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>A21e</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>KUET30WW</p></td></tr></tbody></table><div class=paragraph><p>それより新しいリビジョンの BIOS にまたバグが入り込んだか もしれないという報告がありました。Jacques Vidrine は <a href=mailto:mobile@freebsd.org>mobile@freebsd.org</a> メーリングリストにあてた <a href="http://www.FreeBSD.org/cgi/getmsg.cgi?fetch=200565+208320+/usr/local/www/db/text/2001/freebsd-mobile/20010429.freebsd-mobile">メッセージ</a> で、これ以降の IBM の laptop で FreeBSD が正常に起動しない 場合におそらくうまく行く、BIOS をアップグレードまたは ダウングレードできる手順を説明しています。</p></div><div class=paragraph><p>もし問題のある BIOS を使っていてアップグレードが選べない場合、 FreeBSD をインストールしてから FreeBSD が使っているパーティション ID を変更し、 変更されたパーティション ID を正しく扱うことのできる 新しい起動ブロックをインストールすることで解決することができます。</p></div><div class=paragraph><p>それにはまず、 セルフテスト画面を通過する状態にまでマシンを回復させる必要があります。 そのためには、マシンがプライマリディスクから FreeBSD パーティションを見つけないようにして起動しなければなりません。 たとえば、一度ハードディスクを外してしまって、そのディスクを古い ThinkPad (ThinkPad 600 など) やデスクトップ PC に適切な変換ケーブルで接続します。 その後 FreeBSD のパーティションを削除し、 ハードディスクを元の ThinkPad に戻します。 こうすることで ThinkPad は起動可能な状態に戻るはずです。</p></div><div class=paragraph><p>マシンがちゃんと動くようになったら、 以下の復旧手順に従って FreeBSD をインストールすることができます。</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p><a href=http://people.freebsd.org/~bmah/ThinkPad/>http://people.freebsd.org/~bmah/ThinkPad/</a> から <span class=filename>boot1</span> と <span class=filename>boot2</span> をダウンロードします。 これらのファイルは、 あとで必要になった時、取り出せる場所に置いておきます。</p></li><li><p>ThinkPad に普通に FreeBSD をインストールします。 ただし、<code>Dangerously Dedicated</code> モードを使っては<em>いけません</em>。 また、インストールが終わっても再起動しては<em>いけません</em>。</p></li><li><p>"緊急ホログラフィックシェル (Emergency Holographic Shell)" (<span class=keyseq><kbd>ALT</kbd>+<kbd>F4</kbd></span>) に切り替えるか、"fixit" シェルを起動します。</p></li><li><p><a href="https://man.freebsd.org/cgi/man.cgi?query=fdisk&amp;sektion=8&amp;format=html">fdisk(8)</a> を使って FreeBSD のパーティション ID を <code>165</code> から <code>166</code> に 変更します (これは OpenBSD で使われているものです)。</p></li><li><p><span class=filename>boot1</span> と <span class=filename>boot2</span> のファイルをローカルファイルシステムに持って来ます。</p></li><li><p><a href="https://man.freebsd.org/cgi/man.cgi?query=disklabel&amp;sektion=8&amp;format=html">disklabel(8)</a> を使って <span class=filename>boot1</span> と <span class=filename>boot2</span> を FreeBSD のスライスに書き込みます。</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># disklabel -B -b boot1 -s boot2 ad0sn</span></code></pre></div></div><div class=paragraph><p><em>n</em> は、 あなたが FreeBSD をインストールしたスライスの番号です。</p></div></li><li><p>再起動します。起動プロンプトは <code>OpenBSD</code> と示しますが、実際には、それで FreeBSD が起動します。</p></li></ol></div></div></div><div class=paragraph><p>この方法で FreeBSD と OpenBSD をデュアルブートする方法は、読者への練習問題としましょう。</p></div></div><div class=sect2><h3 id=_不良ブロックのあるディスクにインストールできますか>1.10. 不良ブロックのあるディスクにインストールできますか?<a class=anchor href=#_不良ブロックのあるディスクにインストールできますか></a></h3><div class=paragraph><p>FreeBSD 3.0 以前のシステムでは、 不良ブロックを自動的に再マッピングする <code>bad144</code> というユーティリティが含まれていましたが、 現在の IDE ドライブはドライブ自身がこの機能を備えているため、 <code>bad144</code> は FreeBSD ソースツリーから削除されました。 FreeBSD 3.0 かそれ以降をインストールしたいと思っているなら、 比較的新しいディスクドライブを購入することを強くおすすめします。 新しいドライブを購入する気がなければ、FreeBSD 2.x を利用するべきです。</p></div><div class=paragraph><p>現在の IDE ドライブで不良ブロックによるエラーが発生した場合、 まもなくドライブが故障する可能性があります (それはそのドライブ内蔵の再マッピング機能では 不良ブロックが修正できなくなったということであり、 ディスクがひどく壊れていることを意味します)。 新しいハードディスクドライブに交換しましょう。</p></div><div class=paragraph><p>不良ブロックのある SCSI ドライブの場合は、 <a href=#awre>この回答</a>を参照してください。</p></div></div><div class=sect2><h3 id=_インストーラから起動したら変なことになりました>1.11. インストーラから起動したら変なことになりました!<a class=anchor href=#_インストーラから起動したら変なことになりました></a></h3><div class=paragraph><p>インストーラから起動しようとしたときに、マシンが固まってし まうとか自然と再起動してしまうといった現象であれば、 次の三つの項目を確認してください。</p></div><div class="olist arabic"><ol class=arabic><li><p>新品の、フォーマットしたての、 エラーのないフロッピーディスクを使っていますか? (三年間もベッドの下に放置されていた雑誌の付録みたいなやつではなくて、 買ってきたばかりの新品を使ってください)</p></li><li><p>フロッピーイメージをバイナリモードでダウンロードしましたか? (困った顔をしないでください。私たちの中で一番優秀な人でさえ、 少なくとも一回はバイナリファイルを ASCII モードで思いがけずダウンロードしたことがあるのです!)</p></li><li><p>Windows95 あるいは Windows98 を使用しているなら、 ありのままの本物の DOS で <code>fdimage</code> か <code>rawrite</code> を実行しましたか? これらの OS はディスク作成プログラムのような、 ハードウェアに直接書き込みを行なうプログラムに干渉する可能性があります。 GUI の中の DOS シェル内部で動作している場合でも、 この問題は発生します。</p></li></ol></div><div class=paragraph><p>また、Netscape でブートイメージをダウンロードする場合も問題があることが報告されていますので、 できれば別の FTP クライアントを使うのがよいでしょう。</p></div></div><div class=sect2><h3 id=_atapi_cd_rom_から起動したのですが_インストールプログラムは_cd_rom_が見つかりませんと言ってきます_cd_rom_はどこに行ってしまったのでしょうか>1.12. ATAPI CD-ROM から起動したのですが、 インストールプログラムは CD-ROM が見つかりませんと言ってきます。 CD-ROM はどこに行ってしまったのでしょうか?<a class=anchor href=#_atapi_cd_rom_から起動したのですが_インストールプログラムは_cd_rom_が見つかりませんと言ってきます_cd_rom_はどこに行ってしまったのでしょうか></a></h3><div class=paragraph><p>この問題は通常、CD-ROM ドライブの設定ミスによって発生します。 大部分の PC の CD-ROM ドライブは、 セカンダリ側の IDE コントローラのスレーブデバイスとして接続され、 マスタデバイスがない状態で出荷されています。 この接続方法は ATAPI 規格違反なので、 Windows は規格どおりに動いたり、動かなかったりしますが、 BIOS は起動時に規格違反を無視します。 そのため BIOS は起動時に CD-ROM を見つけられますが、 FreeBSD は CD-ROM を見つけられず、 インストールを完了できないのです。</p></div><div class=paragraph><p>CD-ROM が 接続されている IDE コントローラのマスタデバイスとなるように設定するか、 もしくはマスタ、 スレーブの両方にデバイスが接続されているようにシステムを再構成してください。</p></div></div><div class=sect2><h3 id=_あれれ_テープからインストールできません>1.13. あれれ? テープからインストールできません!<a class=anchor href=#_あれれ_テープからインストールできません></a></h3><div class=paragraph><p>FreeBSD 2.1.7R をテープからインストールする場合、 tar ブロックサイズを 10 (5120 バイト) にしたテープを作る必要があります。 デフォルト の tar ブロックサイズは 20 (10240 バイト) で、 このデフォルトサイズで作られたテープでは FreeBSD 2.1.7R をインストールすることはできません。 もしこうしたテープを使うと、 レコードサイズが大きすぎるというエラーが起きることになります。</p></div></div><div class=sect2><h3 id=_plip_経由で二つ_freebsd_box_を接続したいのですが>1.14. PLIP 経由で二つ FreeBSD box を接続したいのですが<a class=anchor href=#_plip_経由で二つ_freebsd_box_を接続したいのですが></a></h3><div class=paragraph><p>Laplink パラレルケーブルを用意して、 両方の PC のカーネルに <span class=filename>lpt</span> ドライバが組み込まれていることを確認してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% dmesg | <span class=nb>grep </span>lp
lpt0 at 0x378-0x37f irq 7 on isa
lpt0: Interrupt-driven port
lp0: TCP/IP capable interface</code></pre></div></div><div class=paragraph><p>パラレルインタフェースに Laplink パラレルケーブルを接続します。</p></div><div class=paragraph><p><code>root</code> になって、両方で <span class=filename>lp0</span> のネットワークインタフェースパラメータを設定します。 たとえば、ホスト <code>max</code> と <code>moritz</code> を接続したい場合、</p></div><div class="literalblock programlisting"><div class=content><pre>              max &lt;-----&gt; moritz
IP Address      10.0.0.1        10.0.0.2</pre></div></div><div class=paragraph><p>max 側で次のようにして、</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig lp0 10.0.0.1 10.0.0.2</span></code></pre></div></div><div class=paragraph><p>moritz 側で同様に次のようにします。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig lp0 10.0.0.2 10.0.0.1</span></code></pre></div></div><div class=paragraph><p>以上です! <a href="https://man.freebsd.org/cgi/man.cgi?query=lp&amp;sektion=4&amp;format=html">lp(4)</a> と <a href="https://man.freebsd.org/cgi/man.cgi?query=lpt&amp;sektion=4&amp;format=html">lpt(4)</a> のマニュアルページも参照してください。</p></div><div class=paragraph><p>また、 <span class=filename>/etc/hosts</span> にホストの追加もしましょう。</p></div><div class="literalblock programlisting"><div class=content><pre>127.0.0.1               localhost.my.domain localhost
10.0.0.1                max.my.domain max
10.0.0.2                moritz.my.domain moritz</pre></div></div><div class=paragraph><p>動作確認は次のようにします。</p></div><div class=paragraph><p><code>max</code> 側:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ifconfig lp0
lp0: <span class=nv>flags</span><span class=o>=</span>8851&lt;UP,POINTOPOINT,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
        inet 10.0.0.1 <span class=nt>--</span><span class=o>&gt;</span> 10.0.0.2 netmask 0xff000000</code></pre></div></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% netstat <span class=nt>-r</span>
Routing tables

Internet:
Destination        Gateway            Flags     Refs     Use     Netif Expire
moritz              max              UH          4   127592       lp0</code></pre></div></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ping <span class=nt>-c</span> 4 moritz
PING moritz <span class=o>(</span>10.0.0.2<span class=o>)</span>: 56 data bytes
64 bytes from 10.0.0.2: <span class=nv>icmp_seq</span><span class=o>=</span>0 <span class=nv>ttl</span><span class=o>=</span>255 <span class=nb>time</span><span class=o>=</span>2.774 ms
64 bytes from 10.0.0.2: <span class=nv>icmp_seq</span><span class=o>=</span>1 <span class=nv>ttl</span><span class=o>=</span>255 <span class=nb>time</span><span class=o>=</span>2.530 ms
64 bytes from 10.0.0.2: <span class=nv>icmp_seq</span><span class=o>=</span>2 <span class=nv>ttl</span><span class=o>=</span>255 <span class=nb>time</span><span class=o>=</span>2.556 ms
64 bytes from 10.0.0.2: <span class=nv>icmp_seq</span><span class=o>=</span>3 <span class=nv>ttl</span><span class=o>=</span>255 <span class=nb>time</span><span class=o>=</span>2.714 ms

<span class=nt>---</span> moritz ping statistics <span class=nt>---</span>
4 packets transmitted, 4 packets received, 0% packet loss
round-trip min/avg/max/stddev <span class=o>=</span> 2.530/2.643/2.774/0.103 ms</code></pre></div></div></div><div class=sect2><h3 id=_ラップトップ_pc_に_plip_経由でインストールできますか>1.15. ラップトップ PC に PLIP 経由でインストールできますか?<a class=anchor href=#_ラップトップ_pc_に_plip_経由でインストールできますか></a></h3><div class=paragraph><p>次のようにして、二つのコンピュータを Laplink パラレルケーブルで接続してください。</p></div><table class="tableblock frame-all grid-all stretch"><caption class=title>表 1. ネットワーク接続用のパラレルケーブルの結線</caption><col style=width:20%><col style=width:20%><col style=width:20%><col style=width:20%><col style=width:20%><thead><tr><th class="tableblock halign-left valign-top">A-name</th><th class="tableblock halign-left valign-top">A 側</th><th class="tableblock halign-left valign-top">B 側</th><th class="tableblock halign-left valign-top">説明</th><th class="tableblock halign-left valign-top">ポート / ビット</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><div class=literal><pre>....
DATA0
-ERROR
....</pre></div></td><td class="tableblock halign-left valign-top"><div class=literal><pre>....
2
15
....</pre></div></td><td class="tableblock halign-left valign-top"><div class=literal><pre>....
15
2
....</pre></div></td><td class="tableblock halign-left valign-top"><p class=tableblock>Data</p></td><td class="tableblock halign-left valign-top"><div class=literal><pre>....
0/0x01
1/0x08
....</pre></div></td></tr><tr><td class="tableblock halign-left valign-top"><div class=literal><pre>....
DATA1
+SLCT
....</pre></div></td><td class="tableblock halign-left valign-top"><div class=literal><pre>....
3
13
....</pre></div></td><td class="tableblock halign-left valign-top"><div class=literal><pre>....
13
3
....</pre></div></td><td class="tableblock halign-left valign-top"><p class=tableblock>Data</p></td><td class="tableblock halign-left valign-top"><div class=literal><pre>....
0/0x02
1/0x10
....</pre></div></td></tr><tr><td class="tableblock halign-left valign-top"><div class=literal><pre>....
DATA2
+PE
....</pre></div></td><td class="tableblock halign-left valign-top"><div class=literal><pre>....
4
12
....</pre></div></td><td class="tableblock halign-left valign-top"><div class=literal><pre>....
12
4
....</pre></div></td><td class="tableblock halign-left valign-top"><p class=tableblock>Data</p></td><td class="tableblock halign-left valign-top"><div class=literal><pre>....
0/0x04
1/0x20
....</pre></div></td></tr><tr><td class="tableblock halign-left valign-top"><div class=literal><pre>....
DATA3
-ACK
....</pre></div></td><td class="tableblock halign-left valign-top"><div class=literal><pre>....
5
10
....</pre></div></td><td class="tableblock halign-left valign-top"><div class=literal><pre>....
10
5
....</pre></div></td><td class="tableblock halign-left valign-top"><p class=tableblock>Strobe</p></td><td class="tableblock halign-left valign-top"><div class=literal><pre>....
0/0x08
1/0x40
....</pre></div></td></tr><tr><td class="tableblock halign-left valign-top"><div class=literal><pre>....
DATA4
BUSY
....</pre></div></td><td class="tableblock halign-left valign-top"><div class=literal><pre>....
6
11
....</pre></div></td><td class="tableblock halign-left valign-top"><div class=literal><pre>....
11
6
....</pre></div></td><td class="tableblock halign-left valign-top"><p class=tableblock>Data</p></td><td class="tableblock halign-left valign-top"><div class=literal><pre>....
0/0x10
1/0x80
....</pre></div></td></tr><tr><td class="tableblock halign-left valign-top"><div class=literal><pre>GND</pre></div></td><td class="tableblock halign-left valign-top"><div class=literal><pre>18-25</pre></div></td><td class="tableblock halign-left valign-top"><div class=literal><pre>18-25</pre></div></td><td class="tableblock halign-left valign-top"><p class=tableblock>GND</p></td><td class="tableblock halign-left valign-top"><div class=literal><pre>-</pre></div></td></tr></tbody></table><div class=paragraph><p>また、 <a href=#pao>Mobile Computing についてのページ</a>もご覧ください。</p></div></div><div class=sect2><h3 id=_ハードディスクドライブには_どのジオメトリを使うべきでしょうか>1.16. ハードディスクドライブには、 どのジオメトリを使うべきでしょうか?<a class=anchor href=#_ハードディスクドライブには_どのジオメトリを使うべきでしょうか></a></h3><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>ここでディスクの「ジオメトリ」とは、ディスクのシリンダ、ヘッダ、 トラック当りのセクタの数を意味しています - 便宜上、 C/H/S とすることにします。これはディスクのどの領域で読み書きを 行なうかを PC の BIOS が決定する手段となります。</p></div></td></tr></tbody></table></div><div class=paragraph><p>これについてはある理由のために、誤解されている点が多いようです。 まず最初に、FreeBSD はディスクブロックで動作しているため、 SCSI ドライブの "物理的" なジオメトリという言い方は、 まったく見当違いのものです。事実、 セクタの密度はディスクによってまちまちであるため、 物理的なジオメトリというものは存在しません。 製造者が "本当の" 物理的なジオメトリと公表しているものは通常、 彼らが検査して得た最小の使用不可容量の結果のジオメトリのことです。 IDE の場合、FreeBSD は C/H/S で動作しますが、 最近のドライブはすべて、これを内部で参照するブロックに変換しています。</p></div><div class=paragraph><p>問題はとなるのは<em>論理的な</em>ジオメトリです。 これは BIOS がそのディスクのジオメトリについて調べた際に取得されるものであり、 その後のディスクへのアクセスに使用します。 FreeBSD は起動時に BIOS を使用するため、 これを正しく取得することは非常に重要なことなのです。 実際に、ディスク上に複数のオペレーティングシステムがある場合は、 ジオメトリはどこからでも同じように解釈される必要があります。 そうしないと、起動時に深刻な問題が発生します。</p></div><div class=paragraph><p>SCSI ディスクでは、 使用するジオメトリはコントローラの拡張 BIOS トランスレーション (">1GB の DOS ディスクドライブのサポート" とも呼ばれます) が有効になっているかどうかによります。 無効になっている場合、N シリンダ、64 ヘッド、 32 セクタ/トラックを使用しますが、 ここで <code>N</code> は MB 単位のディスク容量です。 たとえば、2GB ディスクは見かけ上 2048 シリンダ、64 ヘッド、 32 セクタ/トラックとなります。</p></div><div class=paragraph><p>それが「有効」になっており (MS-DOS ではこの方法で、ある制限を回避する場合もあります)、 ディスク容量が 1GB を越える場合は、M シリンダ、 63 セクタ/トラック (64 「ではなく」)、 255 ヘッドを使用します。 <code>M</code> は MB 単位のディスク容量を 7.844238(!) で割った値となります。 ということで、2GB ディスクの例では、 261 シリンダ、63 セクタ/トラック、255 ヘッドとなります。 (訳注: 以上は Adaptec 社と NCR 社製の SCSI アダプタの場合です。 SCSI アダプタによって変換の数値が変わってくるのでマニュアルを 参照してください)。</p></div><div class=paragraph><p>これについてよく分からない場合や FreeBSD がインストール中に正しくジオメトリを取得できない場合、 これを回避するもっとも簡単な方法は、 ディスクに小さな DOS パーティションを作ることです。 そうすると正しいジオメトリが取得されるはずです (そして、 残しておきたくないとか、 ネットワークカードのプログラミング用に使いたい場合などには、 いつでもパーティションエディタで DOS パーティションを削除することができます)。</p></div><div class=paragraph><p>もう一つの方法として、FreeBSD と一緒に配布されているフリーで使えるユーティリティに <span class=filename>pfdisk.exe</span> (FreeBSD CD-ROM の <span class=filename>tools</span> ディレクトリや、他のさまざまな FTP サイトにあります)と呼ばれるものがあり、 ディスク上の他のオペレーティングシステムが使用している ジオメトリを調べるのに役立ちます。 このジオメトリ情報は、 パーティションエディタに入力することができます。</p></div></div><div class=sect2><h3 id=_ディスクの分割の仕方で何か制限はありますか>1.17. ディスクの分割の仕方で何か制限はありますか?<a class=anchor href=#_ディスクの分割の仕方で何か制限はありますか></a></h3><div class=paragraph><p>はい。 BIOS がカーネルを起動できるようにルートパーティションが 1024 シリンダ以内にあることを確認する必要があります (これは FreeBSD ではなく PC の BIOS の制限です)。</p></div><div class=paragraph><p>SCSI ドライブでは、通常はルートパーティションが最初の 1024MB に収まっていることが前提となります (または拡張 BIOS トランスレーションが有効になっている場合は最初の 4096MB - 他の質問をご覧ください)。IDE でそれに相当する値は 504MB となります (訳注: E-IDE 対応の BIOS 搭載マシンの場合は IDE の 504MB という制限はありません)。</p></div></div><div class=sect2><h3 id=_大容量ディスクを持っていますがディスクマネージャは使えますか>1.18. 大容量ディスクを持っていますが、ディスクマネージャは使えますか?<a class=anchor href=#_大容量ディスクを持っていますがディスクマネージャは使えますか></a></h3><div class=paragraph><p>FreeBSD は Ontrack Disk Manager を認識し、これを考慮にいれます。 他のディスクマネージャはサポートしません。</p></div><div class=paragraph><p>ディスク全体を FreeBSD で使いたい場合、 ディスクマネージャは必要ありません。 BIOS が扱える容量 (通常 504MB) いっぱいでディスクの設定を行なうと、 FreeBSD は実際の容量を算出するはずです。 MFM コントローラ付きの古いディスクを使っている場合は、 FreeBSD に使用するシリンダ数を詳細に指定する必要があります。</p></div><div class=paragraph><p>FreeBSD と他のオペレーティングシステムが入っているディスクを使用したい場合は、 ディスクマネージャなしでもできるでしょう。 FreeBSD の起動パーティションと他のオペレーティングシステム用のスライスが、 最初の 1024 シリンダ内に収まっている事を確認するだけです。 気になる方は、起動パーティションを 20 メガバイトぐらいにして大きめにするとよいでしょう。</p></div></div><div class=sect2><h3 id=_freebsd_の起動時に_missing_operating_system_と表示されます>1.19. FreeBSD の起動時に Missing Operating System と表示されます<a class=anchor href=#_freebsd_の起動時に_missing_operating_system_と表示されます></a></h3><div class=paragraph><p>これは FreeBSD や DOS、 そのほかの OS がディスク領域<a href=#geometry>ジオメトリ</a> のとらえ方で衝突しあっていることから起こる典型的な例です。 こうなったら FreeBSD をインストールし直す以外にはありませんが、 他のところで説明した手順にしたがってやれば、 ほぼ間違いなくうまくいくはずです。</p></div></div><div class=sect2><h3 id=_ブートマネージャの_f_プロンプトが表示されません>1.20. ブートマネージャの F? プロンプトが表示されません。<a class=anchor href=#_ブートマネージャの_f_プロンプトが表示されません></a></h3><div class=paragraph><p>これはすでに前に質問されている問題のもう一つの症状です。 BIOS のジオメトリと FreeBSD のジオメトリ設定が一致していないのです! コントローラや BIOS がシリンダの変換 (<code>>1GB ドライブの サポート</code>とも呼ばれます) をサポートしていたら、 その設定を無効化して FreeBSD をインストールし直してみてください。</p></div></div><div class=sect2><h3 id=_ソースを全部インストールする必要はありますか>1.21. ソースを全部インストールする必要はありますか?<a class=anchor href=#_ソースを全部インストールする必要はありますか></a></h3><div class=paragraph><p>一般的には「いいえ」です。 しかし最低でも、<code>base</code> ソースキット (これにはこの FAQ で述べられているファイルのいくつかが含まれています) と、 <code>sys</code> (kernel) ソースキット (これにはカーネルのソースが含まれています) をインストールする事を強くおすすめします。 通常、何かの実行にソースが必要になる事はありません。 しかし、カーネルをコンフィグレーションするためのプログラム <a href="https://man.freebsd.org/cgi/man.cgi?query=config&amp;sektion=8&amp;format=html">config(8)</a> を実行する時は例外です。 カーネルのソースをインストールしなくてもよい例として、 どこか別の場所からカーネルのソースを読み込み専用で NFS マウントすることができます。また、 そこから新しいバイナリを作成できるようにもなっています (カーネルソースの制限があるので、直接 <span class=filename>/usr/src</span> をマウントする事はおすすめできません。 それよりもどこか別のディレクトリにマウントして、 ソースツリーの複製ができるように適切にシンボリックリンクを張ってください)。</p></div><div class=paragraph><p>ソースをネットワーク上に持ち、 そこからシステムをビルドするようにしておけば、 FreeBSD の将来のリリースへのアップグレードがずっと簡単になります。</p></div><div class=paragraph><p>実際にソースのサブセットを選択するには、 システムインストールツールの「配布ファイル」メニューにある、 「カスタム」メニューを使用します。</p></div></div><div class=sect2><h3 id=_カーネルは必ず作り直さなくちゃならないんですか>1.22. カーネルは必ず作り直さなくちゃならないんですか?<a class=anchor href=#_カーネルは必ず作り直さなくちゃならないんですか></a></h3><div class=paragraph><p>カーネルを新しく作り直すのは元々、 FreeBSD のインストール時に必須の作業でした。 でも最近のリリースでは、 とてもユーザフレンドリなカーネル設定ツールの恩恵を受けています。 FreeBSD の起動プロンプト (boot:) で <code>-c</code> とタイプすればビジュアルな設定画面になり、 ほとんどの一般的な ISA カードについてのカーネルの設定をすることができるのです。</p></div><div class=paragraph><p>今でも、 必要なデバイスドライバだけを組み込んだカーネルを作ることはよい事とされています。 ほんのちょっとだけメモリを節約できますからね。 でもほとんどのシステムでは、 もはやどうしてもやらなくちゃならないことではないのです。</p></div></div><div class=sect2><h3 id=_des_と_md5どちらのパスワードを使うべきなのでしょうか_またユーザがどちらを使うことになるか指定する方法はありますか>1.23. DES と MD5、どちらのパスワードを使うべきなのでしょうか? また、ユーザがどちらを使うことになるか指定する方法はありますか?<a class=anchor href=#_des_と_md5どちらのパスワードを使うべきなのでしょうか_またユーザがどちらを使うことになるか指定する方法はありますか></a></h3><div class=paragraph><p>FreeBSD の標準のパスワードフォーマットは <em>MD5</em> を使ったものです。 これは <em>DES</em> アルゴリズムに基づいた手法を用いる UNIX の伝統的なパスワードフォーマットより安全 (secure) だと 信じられているものです。 DES パスワードは あなたが FreeBSD のパスワードファイルを、 安全性に劣るパスワードフォーマットを利用している古い OS と共有しなければならなくなったときのために 利用可能になっています (これは利用するためには、 sysinstall から "crypto" 配布物のインストール 選ぶか、ソースから build しているなら、 crypto のソースがインストールされている必要があります)。 新しいパスワードにどちらのパスワードフォーマットを使うかは <span class=filename>/etc/login.conf</span> の中の "passwd_format" という login ケーパビリティで制御されます。このケーパビリティは "des" (利用できるなら) か "md5" のどちらかの値を取ります。 login ケーパビリティの詳細については <a href="https://man.freebsd.org/cgi/man.cgi?query=login.conf&amp;sektion=5&amp;format=html">login.conf(5)</a> を 参照してください。</p></div></div><div class=sect2><h3 id=_ブートフロッピーで起動すると_probing_devices_の画面でハングアップします>1.24. ブートフロッピーで起動すると、 Probing Devices…​ の画面でハングアップします。<a class=anchor href=#_ブートフロッピーで起動すると_probing_devices_の画面でハングアップします></a></h3><div class=paragraph><p>IDE Zip か Jaz ドライブが接続されていたら、 それを取り外してもう一度試してみましょう。 ブートフロッピーはこの種のドライブを誤認してしまうのです。 システムがインストールされた後は、そのドライブを再度接続することができます。 うまくいけばこの問題は将来のリリースで解決されるでしょう。</p></div></div><div class=sect2><h3 id=_インストール終了後にシステムを再起動すると_panic_cant_mount_root_のエラーとなります>1.25. インストール終了後にシステムを再起動すると、 panic: cant mount root のエラーとなります。<a class=anchor href=#_インストール終了後にシステムを再起動すると_panic_cant_mount_root_のエラーとなります></a></h3><div class=paragraph><p>このエラーはディスクデバイスについて、 起動ブロックとカーネルの認識が混乱しているために起こります。 このエラーは通常、 2 台の IDE ディスクがそれぞれ別の IDE コントローラのマスターに一つずつ接続されているシステムにおいて、 FreeBSD がセカンダリ IDE コントローラに接続されたディスクにインストールされている場合に発生します。 起動ブロックは FreeBSD が wd1 (2 台目の BIOS ディスク) にインストール されていると認識するのに対し、 カーネルはセカンダリ IDE の 1 台目のハードディスクである wd2 にインストールされていると認識するのです。 デバイス検出後で、 カーネルは起動ブロックが起動ディスクだと認識したディスクである wd1 をマウントしようとします。 しかし、実際には起動ディスクは wd2 なので失敗してしまうのです。</p></div><div class=paragraph><p>この問題を解決するには、以下のどれか一つを行ってください。</p></div><div class="olist arabic"><ol class=arabic><li><p>FreeBSD 3.3 以降を利用している場合には、 システムを再起動して、<code>Booting kernel in 10 seconds; hit [Enter] to interrupt</code> が表示されている間に <code>Enter</code> キーを押します。 すると、ブートローダに移行します。</p><div class=paragraph><p>そうしたら、<code>set root_disk_unit="disk_number"</code> と入力します。 FreeBSD が最初の IDE コントローラのマスターに接続されたドライブにインストールされていれば、 <em>disk_number</em> は <code>0</code> です。 また、 最初の IDE コントローラのスレーブなら <code>1</code>、 二番目の IDE コントローラのマスターなら <code>2</code>、 二番目の IDE コントローラのスレーブなら <code>3</code> になります。</p></div><div class=paragraph><p>その後、<code>boot</code> と入力します。 システムはきちんと再起動するはずです。</p></div><div class=paragraph><p>この変更を恒久的なものにする (つまり、 再起動や電源を入れる度にこの操作をする必要がないようにする) には、 <span class=filename>/boot/loader.conf.local</span> に <code>root_disk_unit="disk_number"</code> という行を追加してください。</p></div></li><li><p>FreeBSD 3.2 以前を利用している場合は、 Boot: プロンプトで <code>1:wd(2,a)kernel</code> と入力してエンターキーを押します。 システムが起動したら、 <code>echo "1:wd(2,a)kernel" > /boot.config</code> というコマンドを実行してこれをデフォルトのブート文字列とします。</p></li><li><p>FreeBSD のディスクをプライマリ IDE コントローラに接続して、 ハードディスクが連続したドライブ番号で認識されるようにします。</p></li><li><p>カーネルのコンフィグレーションファイルで wd の行を以下のように変更し、 <a href=https://docs.freebsd.org/ja/books/handbook/kernelconfig#kernelconfig>カーネルの再構築</a>を行って、 新しいカーネルをインストールします。</p><div class="literalblock programlisting"><div class=content><pre>controller      wdc0    at isa? port &#34;IO_WD1&#34; bio irq 14 vector wdintr
disk            wd0     at wdc0 drive 0
# disk            wd1     at wdc0 drive 1 # この行をコメントアウト

controller      wdc1    at isa? port &#34;IO_WD2&#34; bio irq 15 vector wdintr
disk            wd1     at wdc1 drive 0 # wd2 から wd1 へ変更
disk            wd2     at wdc1 drive 1 # wd3 から wd2 へ変更</pre></div></div><div class=paragraph><p>ディスクの接続を変更して元の設定に戻したい場合は、ディスクを お望みの設定の通りの接続に戻してから再起動します。 システムは正常に起動するはずです。</p></div></li></ol></div></div><div class=sect2><h3 id=_メモリの大きさの制限は>1.26. メモリの大きさの制限は?<a class=anchor href=#_メモリの大きさの制限は></a></h3><div class=paragraph><p>認識できるメモリの上限は、4GB です。 この構成は試験済みで、 詳細は <a href=ftp://ftp.cdrom.com/archive-info/configuration>wcarchive’s configuration</a> をご覧ください。 このようにたくさんのメモリをマシンに導入しようという場合には、 注意が必要です。ECC 機能をサポートし、なおかつ 容量性負荷 (訳注: 多くのメモリ素子は容量性負荷として働きますが、 メモリバス上に容量性負荷が増えると信号の伝達が遅れ、誤動作の原因となります) を 低減させるため、18 チップ構成のメモリモジュールより 9 チップ構成のメモリモジュールを選択することが、おそらく望ましいでしょう。</p></div></div><div class=sect2><h3 id=_ffs_ファイルシステムの大きさの制限は>1.27. ffs ファイルシステムの大きさの制限は?<a class=anchor href=#_ffs_ファイルシステムの大きさの制限は></a></h3><div class=paragraph><p>ffs ファイルシステムの場合、 論理的な最大の上限は 8 TB (2G ブロック)、 デフォルトのブロックサイズを 8K とすると 16 TBとなります。 実際問題として、1 TB のソフトウェアの限界がありますが、 修正すれば 4 TB のファイルシステムが可能です (実際に存在します)。</p></div><div class=paragraph><p>一つの ffs のファイルの最大のサイズは、ブロックサイズが 4K の場合で 約 1G ブロック (4 TB)です。</p></div><table class="tableblock frame-all grid-all stretch"><caption class=title>表 2. 最大ファイルサイズ</caption><col style=width:20%><col style=width:20%><col style=width:20%><col style=width:20%><col style=width:20%><thead><tr><th class="tableblock halign-left valign-top">fs ブロックサイズ</th><th class="tableblock halign-left valign-top">2.2.7-stable</th><th class="tableblock halign-left valign-top">3.0-current</th><th class="tableblock halign-left valign-top">動作確認済みのサイズ</th><th class="tableblock halign-left valign-top">動作するはずのサイズ</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>4K</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>4T-1</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>4T-1</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>4T-1</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>>4T</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>8K</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>>32G</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>8T-1</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>>32G</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>32T-1</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>16K</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>>128G</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>16T-1</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>>128G</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>32T-1</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>32K</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>>512G</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>32T-1</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>>512G</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>64T-1</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>64K</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>>2048G</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>64T-1</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>>2048G</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>128T-1</p></td></tr></tbody></table><div class=paragraph><p>fs ブロックサイズが 4K の場合は三重間接ブロックが使用され、 いずれの場合でも三重間接ブロックを使用して表現できる最大の fs ブロック番号 (およそ 1K^3 + 1K^2 + 1K) に制限されるはずなのですが、 実際は fs ブロック番号の (間違った) 上限 1G-1 で制限されます。 fs ブロック番号の制限は 2G-1 となるはずです。2G-1 付近に fs ブロック番号のバグが多少ありますが、fs ブロックサイズが 4K の場合は、ここまでのブロック番号には到達しません。</p></div><div class=paragraph><p>ブロックサイズが 8K 以上の場合、いずれの場合も fs ブロック番号の上限 2G-1 で制限されるはずですが、 実際は fs ブロック番号の上限 1G-1 で制限されます。 例外的に -STABLE では三重間接ブロックまでは到達しないため、 制限は二重間接ブロックで表現できる最大の fs ブロック番号 (およそ (blocksize/4)^2 + (blocksize/4)) となります。 -CURRENT ではこの制限を超えると問題を引き起こすかもしれません。 正しい制限値である 2G-1 ブロックを使用すると明らかに問題が出ます。</p></div></div><div class=sect2><h3 id=_フロッピーに_1_tb_のファイルを格納するには>1.28. フロッピーに 1 TB のファイルを格納するには?<a class=anchor href=#_フロッピーに_1_tb_のファイルを格納するには></a></h3><div class=paragraph><p>わたしのところでは、 フロッピーにいくつかの実際のファイルを保存しています :-)。 最大のファイルサイズは最大のディスクサイズとはあまり関係はありません。 最大のディスクサイズは 1 TB です。 ファイルサイズがディスクサイズより大きくなりうるというのは仕様です。</p></div><div class=paragraph><p>以下の例は、32K のディスク容量 (3 つの間接ブロックと 1 つのデータブロック) を使って、 小さなルートパーティションに 8T-1 の大きさのファイルを作成します。 ここでの dd コマンドは大きなファイルが扱えるものが必要です。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>cat </span>foo
<span class=nb>df</span> <span class=nb>.</span>
<span class=nb>dd </span><span class=k>if</span><span class=o>=</span>/dev/zero <span class=nv>of</span><span class=o>=</span>z <span class=nv>bs</span><span class=o>=</span>1 <span class=nv>seek</span><span class=o>=</span><span class=sb>`</span><span class=nb>echo </span>2^43 - 2 | bc<span class=sb>`</span> <span class=nv>count</span><span class=o>=</span>1
<span class=nb>ls</span> <span class=nt>-l</span> z
<span class=nb>du </span>z
<span class=nb>df</span> <span class=nb>.</span>
% sh foo
Filesystem  1024-blocks     Used    Avail Capacity  Mounted on
/dev/da0a         64479    27702    31619    47%    /
1+0 records <span class=k>in
</span>1+0 records out
1 bytes transferred <span class=k>in </span>0.000187 secs <span class=o>(</span>5346 bytes/sec<span class=o>)</span>
<span class=nt>-rw-r--r--</span>  1 bde  bin  8796093022207 Sep  7 16:04 z
32      z
Filesystem  1024-blocks     Used    Avail Capacity  Mounted on
/dev/da0a         64479    27734    31587    47%    /</code></pre></div></div></div><div class=sect2><h3 id=_新しいカーネルをコンパイルしたら起動時に_archsw_readin_failed_というエラーメッセージが表示されるようになってしまいました>1.29. 新しいカーネルをコンパイルしたら、起動時に archsw.readin.failed というエラーメッセージが表示されるようになってしまいました。<a class=anchor href=#_新しいカーネルをコンパイルしたら起動時に_archsw_readin_failed_というエラーメッセージが表示されるようになってしまいました></a></h3><div class=paragraph><p>ローダがスタートする前の | が表示されているときに何かキーを押すことで、 起動のセカンドステージから直接、起動するカーネルを指定して起動することができます。 特に、カーネルのソースを更新し、<em>make world しないで</em>新しいカーネルだけインストールした場合にこの症状が現われます。 こういう操作は動作が保証されません。きちんと make world してください。</p></div></div><div class=sect2><h3 id=_3_x_から_4_x_にアップグレードするにはどうしたら良いのですか>1.30. 3.X から 4.X にアップグレードするにはどうしたら良いのですか?<a class=anchor href=#_3_x_から_4_x_にアップグレードするにはどうしたら良いのですか></a></h3><div class=paragraph><p>アップグレードには、 バイナリスナップショットを使うことを<em>強く</em>おすすめします。 4-STABLE スナップショットは <a href=ftp://releng4.FreeBSD.org/>releng4.FreeBSD.org</a> から入手可能です。</p></div><div class=paragraph><p>ソースを使ってアップグレードする場合は、詳細について <a href=https://docs.freebsd.org/ja/books/handbook/updating-upgrading#cutting-edge>FreeBSD ハンドブック</a>を参照するようにしてください。</p></div><div class="admonitionblock caution"><table><tbody><tr><td class=icon><i class="fa icon-caution" title=Caution></i></td><td class=content><div class=paragraph><p>ソースを使ったアップグレードは、 慣れていないユーザにはまったくおすすめできません。 3.X から 4.X への場合は特にそうです。 ソースを使ったアップグレードを試す前に、 手順を注意深く読むように心がけてください。</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=_セキュリティプロファイル_security_profiles_とは何ですか>1.31. セキュリティプロファイル (security profiles) とは何ですか?<a class=anchor href=#_セキュリティプロファイル_security_profiles_とは何ですか></a></h3><div class=paragraph><p>"セキュリティプロファイル"とは、特定の プログラムやその他の設定を有効にしたり無効にすることで、求める 比率で安全と便利さを実現しようとする構成の選択肢の集まりの ことです。セキュリティプロファイルが厳しいほど、デフォルトで 有効になるプログラムが減ります。これは、動かさなければならない もの以外は、何も動かしてはいけないというセキュリティの 基本的原則の一つです。</p></div><div class=paragraph><p>セキュリティプロファイルは、単にデフォルトの設定である ということに気をつけてください。FreeBSD をインストールした あとに <span class=filename>/etc/rc.conf</span> に適切な行を編集したり 追加すれば、どのプログラムでも有効にしたり無効にしたりできます。 後者について詳しいことは <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a> のマニュアルを ご覧ください。</p></div><div class=paragraph><p>以下に、各セキュリティプロファイルが何を行うかを説明した 表を掲載します。列はセキュリティプロファイルの選択肢で、行は 有効または無効になるプログラムや機能です。</p></div><table class="tableblock frame-all grid-all stretch"><caption class=title>表 3. 指定できるセキュリティプロファイル</caption><col style=width:20%><col style=width:20%><col style=width:20%><col style=width:20%><col style=width:20%><thead><tr><th class="tableblock halign-left valign-top"></th><th class="tableblock halign-left valign-top">Extreme</th><th class="tableblock halign-left valign-top">High</th><th class="tableblock halign-left valign-top">Moderate</th><th class="tableblock halign-left valign-top">Low</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href="https://man.freebsd.org/cgi/man.cgi?query=inetd&amp;sektion=8&amp;format=html">inetd(8)</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>NO</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>NO</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>YES</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>YES</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href="https://man.freebsd.org/cgi/man.cgi?query=sendmail&amp;sektion=8&amp;format=html">sendmail(8)</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>NO</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>YES</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>YES</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>YES</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href="https://man.freebsd.org/cgi/man.cgi?query=sshd&amp;sektion=8&amp;format=html">sshd(8)</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>NO</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>YES</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>YES</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>YES</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href="https://man.freebsd.org/cgi/man.cgi?query=portmap&amp;sektion=8&amp;format=html">portmap(8)</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>NO</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>NO</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>おそらく (インストール時に、すでにマシンを NFS クライアントまたはサーバとして設定していると、 ポートマッパが有効になります。)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>YES</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>NFS server</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>NO</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>NO</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>YES</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>YES</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href="https://man.freebsd.org/cgi/man.cgi?query=securelevel&amp;sektion=8&amp;format=html">securelevel(8)</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>YES (2) (securelevel を設定するセキュリティプロファイル (Extreme または High) を選択する場合、その影響を 承知していなければなりません。<a href="https://man.freebsd.org/cgi/man.cgi?query=init&amp;sektion=8&amp;format=html">init(8)</a> のマニュアルを 読み、セキュリティレベルの意味について特に注意を 払ってください。そうしないと、後で深刻な問題が 起きるかもしれません。)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>YES (1)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>NO</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>NO</p></td></tr></tbody></table><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>セキュリティプロファイルは魔法の薬ではありません。 High に設定したら、適当な <a href=https://docs.freebsd.org/ja/books/handbook/eresources#eresources-mail>メーリングリスト</a>を読んだり、良質なパスワードや パスフレーズを用いたり、セキュリティについてのよい習慣を 守ったりしなくていいわけではありません。求めるセキュリティと 便利さの比率を手軽に設定してくれるだけです。</p></div></td></tr></tbody></table></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>セキュリティプロファイルの機構は、FreeBSD を最初に インストールする時に使うことを想定しています。すでに FreeBSD がインストールされているなら、単に求める機能を 有効にしたり無効にしたりする方が、おそらく効率が よいでしょう。もし、本当にセキュリティプロファイルを 使いたいのであれば、<a href="https://man.freebsd.org/cgi/man.cgi?query=sysinstall&amp;sektion=8&amp;format=html">sysinstall(8)</a> を再実行すれば 設定できます。</p></div></td></tr></tbody></table></div></div></div></div><div class=sect1><h2 id=hardware>2. ハードウェアコンパチビリティ<a class=anchor href=#hardware></a></h2><div class=sectionbody><div class=sect2><h3 id=_freebsd_は_どんなハードディスクドライブをサポートしているのですか>2.1. FreeBSD は、 どんなハードディスクドライブをサポートしているのですか?<a class=anchor href=#_freebsd_は_どんなハードディスクドライブをサポートしているのですか></a></h3><div class=paragraph><p>FreeBSD は、EIDE と SCSI ハードディスクドライブをサポートしています (互換コントローラも含みます。 次の節参照)。 また独自の "Western Digital" インタフェースを使用しているすべてのドライブ (MFM、 RLL、ESDI、もちろん IDE) もサポートしています。 独自仕様のインタフェースを使用する ESDI コントローラでは動作しないものがあり、 WD1002/3/6/7 とその互換インタフェースと衝突します。</p></div></div><div class=sect2><h3 id=_どの_scsi_コントローラをサポートしているのですか>2.2. どの SCSI コントローラをサポートしているのですか?<a class=anchor href=#_どの_scsi_コントローラをサポートしているのですか></a></h3><div class=paragraph><p><a href=https://docs.freebsd.org/ja/books/handbook/>FreeBSD ハンドブック</a>に記されている完全なリストを参照してください。</p></div></div><div class=sect2><h3 id=_どんな_cd_rom_ドライブをサポートしているのですか>2.3. どんな CD-ROM ドライブをサポートしているのですか?<a class=anchor href=#_どんな_cd_rom_ドライブをサポートしているのですか></a></h3><div class=paragraph><p>サポートされている SCSI コントローラに接続できる SCSI ドライブは、すべてサポートされています。</p></div><div class=paragraph><p>また、以下の専用 CD-ROM インタフェースもサポートしています。</p></div><div class=ulist><ul><li><p>ミツミ LU002 (8bit)、LU005 (16bit) および FX001D (16bit 2倍速)。</p></li><li><p>ソニー CDU 31/33A</p></li><li><p>Sound Blaster 非 SCSI タイプの CD-ROM</p></li><li><p>松下/Panasonic CD-ROM</p></li><li><p>ATAPI 互換の IDE CD-ROM</p></li></ul></div><div class=paragraph><p>SCSI でないカードはすべて、SCSI ドライブよりも極めて動作速度が 遅いことが知られており、ATAPI CD-ROM には動作しないものもあるようです。</p></div><div class=paragraph><p>BSDi の FreeBSD 2.2 CD-ROM からは CD からの直接起動が サポートされています。</p></div></div><div class=sect2><h3 id=_freebsd_はどの_cd_rw_ドライブに対応していますか>2.4. FreeBSD は、どの CD-RW ドライブに対応していますか?<a class=anchor href=#_freebsd_はどの_cd_rw_ドライブに対応していますか></a></h3><div class=paragraph><p>FreeBSD は ATAPI 互換の IDE CD-R または CD-RW ドライブで あれば対応しています。FreeBSD バージョン 4.0 以降については、 <a href="https://man.freebsd.org/cgi/man.cgi?query=burncd&amp;sektion=8&amp;format=html">burncd(8)</a> のマニュアルをご覧ください。それ以前の バージョンの FreeBSD では、 <span class=filename>/usr/shared/examples/atapi</span> にある例を ご覧ください。</p></div><div class=paragraph><p>また、FreeBSD は SCSI の CD-R または CD-RW ドライブにも 対応しています。ports または packages から <code>cdrecord</code> コマンドをインストールして、 カーネルに <span class=filename>pass</span> デバイスが組み込まれて いることを確認してください。</p></div></div><div class=sect2><h3 id=_zip_ドライブをサポートしていますか>2.5. ZIP ドライブをサポートしていますか?<a class=anchor href=#_zip_ドライブをサポートしていますか></a></h3><div class=paragraph><p>もちろん、 FreeBSD は SCSI ZIP ドライブ (外付け) をサポートしています。 ZIP ドライブは SCSI ID を 5 か 6 に設定した状態でなら使用できますが、 もし SCSI ホストアダプタの BIOS がサポートしてさえいれば ZIP ドライブから起動させることもできます。 どのホストアダプタが SCSI ID を 0 や 1 以外に設定したデバイスから 起動できるのかはわかりません。そうしたい場合は、アダプタの ドキュメントを参照しなければなりません。</p></div><div class=paragraph><p>ATAPI (IDE) ZIP ドライブは、FreeBSD 2.2.6 以降のバージョンでサポートされています。</p></div><div class=paragraph><p>バージョン 3.0 以降の FreeBSD では、 パラレルポート接続の ZIP ドライブをサポートしています。 最近のバージョンの FreeBSD をお使いでしたら、 カーネルコンフィグレーションファイルに <span class=filename>scbus0</span>、 <span class=filename>da0</span>、 <span class=filename>ppbus0</span>、 <span class=filename>vp0</span> の各ドライバが記述されていることを確認してください。 (GENERIC カーネルには <span class=filename>vp0</span> を除くすべてのドライバが含まれています)。 これらすべてのドライバがあれば、 パラレルポートのドライブは <span class=filename>/dev/da0s4</span> となります。 ディスクは <code>mount /dev/da0s4 /mnt</code> とするか <code>mount_msdos /dev/da0s4 /mnt</code> (DOS ディスクの場合) とすることでマウントできます。</p></div><div class=paragraph><p>それから<a href=#jaz>リムーバブルドライブに関する注意</a>および、 <a href=#disklabel>「フォーマット」に関する注意</a>についても 確認しておいてください。</p></div></div><div class=sect2><h3 id=_ではjaz_や_ez_それからその他のリムーバブルドライブはサポートしていますか>2.6. では、JAZ や EZ、 それからその他のリムーバブルドライブはサポートしていますか?<a class=anchor href=#_ではjaz_や_ez_それからその他のリムーバブルドライブはサポートしていますか></a></h3><div class=paragraph><p>FreeBSD では、IDE バージョンの EZ ドライブを除くすべての SCSI デバイスは、 SCSI のディスクと同等に扱われます。 また IDE EZ は IDE ドライブと同等となります。</p></div><div class=paragraph><p><a id=jaz></a>システム稼働中のメディア交換について FreeBSD がどれほどうまく動くか定かではありません。 もちろんメディアを入れ替える前にそのドライブのマウントを解除しなければいけないでしょうし、 FreeBSD がそれらを認識するには、 起動時に外部ユニットにも電源が投入されていることを確認しなければいけないでしょう。</p></div><div class=paragraph><p><a href=#disklabel>「フォーマット」に関する注意</a>も参照のこと。</p></div></div><div class=sect2><h3 id=_どのマルチポートシリアルカードをサポートしていますか>2.7. どのマルチポートシリアルカードをサポートしていますか?<a class=anchor href=#_どのマルチポートシリアルカードをサポートしていますか></a></h3><div class=paragraph><p>一覧は <a href=https://docs.freebsd.org/ja/books/handbook/>その他のデバイス</a>の節にあります。</p></div><div class=paragraph><p>無名のカードにもうまく動くものがあり、 特に AST 互換といわれているものに多く見られます。</p></div><div class=paragraph><p>カード設定の詳細な情報は、<a href="https://man.freebsd.org/cgi/man.cgi?query=sio&amp;sektion=4&amp;format=html">sio(4)</a> のマニュアルページを参照してください。</p></div></div><div class=sect2><h3 id=_usb_キーボードを持っているのですがfreebsd_で使えますか>2.8. USB キーボードを持っているのですが、FreeBSD で使えますか?<a class=anchor href=#_usb_キーボードを持っているのですがfreebsd_で使えますか></a></h3><div class=paragraph><p>USB デバイスは FreeBSD 3.1 からサポートされましたが、 実装は FreeBSD 3.2 であってもまだ完全ではないため、 必ずしも安定して動作するとは限りません。 もし、それでも USB キーボードを使ってみたいという人は、 以下の手順を試してみてください。</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>FreeBSD 3.2 か、それ以降を使います。</p></li><li><p>カーネルコンフィグレーションファイルに以下の行を追加し、 カーネルを再構築します。</p><div class="literalblock programlisting"><div class=content><pre>device  uhci
device  ohci
device  usb
device  ukbd
options KBD_INSTALL_CDEV</pre></div></div><div class=paragraph><p>FreeBSD 4.0 より前のバージョンでは、 代わりに次のようにします。</p></div><div class="literalblock programlisting"><div class=content><pre>controller      uhci0
controller      ohci0
controller      usb0
controller      ukbd0
options         KBD_INSTALL_CDEV</pre></div></div></li><li><p><span class=filename>/dev</span> ディレクトリに移動し、 次のようにしてデバイスノードを作成します。</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /dev</span>
<span class=c># ./MAKEDEV kbd0 kbd1</span></code></pre></div></div></li><li><p><span class=filename>/etc/rc.conf</span> を編集し、 以下の行を追加します。</p><div class="literalblock programlisting"><div class=content><pre>usbd_enable=&#34;YES&#34;
usbd_flags=&#34;&#34;</pre></div></div></li></ol></div></div></div><div class=paragraph><p>システムを再起動させた後、 AT、USB 両方のキーボードが接続されていれば、 AT キーボードは <span class=filename>/dev/kbd0</span> に、 USB キーボードは <span class=filename>/dev/kbd1</span>になります。 一方、USB キーボードだけが接続されているなら、 <span class=filename>/dev/ukbd0</span> となります。</p></div><div class=paragraph><p>USB キーボードをコンソールで利用するには、 それをコンソールドライバに対して明示的に指定する必要があります。 システムの初期化の際に、次に示すようなコマンドを実行してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kbdcontrol -k /dev/kbd1 &lt; /dev/ttyv0 &gt; /dev/null</span></code></pre></div></div><div class=paragraph><p>ただし、USB キーボードしか接続されていない場合、それは <span class=filename>/dev/kbd0</span> としてアクセスされますので、 コマンドは次のようにしなければなりません。ご注意ください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kbdcontrol -k /dev/kbd0 &lt; /dev/ttyv0 &gt; /dev/null</span></code></pre></div></div><div class=paragraph><p>上のコマンドは、<span class=filename>/etc/rc.i386</span> に追加すると良いでしょう。</p></div><div class=paragraph><p>この設定を一度行なっていれば、 X 環境でも特に他の設定なしに USB キーボードが利用できます。</p></div><div class=paragraph><p>USB キーボードの活線挿抜 (ホットプラグ機能) は、 まだおそらくきちんと動作しないと思われます。 トラブルを避けるためにも、キーボードはシステムを起動させる前に接続しておき、 シャットダウンするまではずさないようにした方が良いでしょう。</p></div><div class=paragraph><p>詳細については、<a href="https://man.freebsd.org/cgi/man.cgi?query=ukbd:&amp;sektion=4&amp;format=html">ukbd:(4)</a> のマニュアルページを参照してください。</p></div></div><div class=sect2><h3 id=_珍しいバスマウスを持っているのですがどのように設定すればいいのですか>2.9. 珍しいバスマウスを持っているのですが、どのように設定すればいいのですか?<a class=anchor href=#_珍しいバスマウスを持っているのですがどのように設定すればいいのですか></a></h3><div class=paragraph><p>FreeBSD は Microsoft、Logitech、 ATI 等のメーカーから出ているバスマウスと InPort バスマウスをサポートしています。FreeBSD 2.X の場合、 バスマウスのデバイスドライバは GENERIC カーネルに標準で含まれますが、 FreeBSD 3.X 以降では標準で含まれていません。もしバスマウスのデバイス ドライバを含むカーネルを自分で構築する場合には、 カーネルコンフィグレーションファイルに以下の行が含まれていることを確認してください。</p></div><div class=paragraph><p>それは FreeBSD 3.0 を含む、それ以前のリリースの場合は次のとおり、</p></div><div class="literalblock programlisting"><div class=content><pre>device mse0 at isa? port 0x23c tty irq5 vector mseintr</pre></div></div><div class=paragraph><p>FreeBSD 3.X では、次のとおりです。</p></div><div class="literalblock programlisting"><div class=content><pre>device mse0 at isa? port 0x23c tty irq5</pre></div></div><div class=paragraph><p>そして FreeBSD 4.X とそれ以降では、次のようになります。</p></div><div class="literalblock programlisting"><div class=content><pre>device mse0 at isa? port 0x23c irq5</pre></div></div><div class=paragraph><p>通常バスマウスには専用のインタフェースカードが附属しています。 インタフェースカードによってはポートアドレスや割り込み番号を上記の 設定以外に変更できるかもしれません。詳しくはバスマウスのマニュアルと <a href="https://man.freebsd.org/cgi/man.cgi?query=mse&amp;sektion=4&amp;format=html">mse(4)</a> のマニュアルページを参照してください。</p></div></div><div class=sect2><h3 id=_ps2_マウス_マウスポートマウスキーボードマウス_を_使うにはどのように設定すればいいのですか>2.10. PS/2 マウス (「マウスポートマウス」、「キーボードマウス」) を 使うにはどのように設定すればいいのですか?<a class=anchor href=#_ps2_マウス_マウスポートマウスキーボードマウス_を_使うにはどのように設定すればいいのですか></a></h3><div class=paragraph><p>あなたが 2.2.5 以降のバージョン FreeBSD を使っているのなら、 必要なドライバ <span class=filename>psm</span> はカーネルに含まれていて有効になっています。 カーネルは起動時に PS/2 マウスを検出するでしょう。</p></div><div class=paragraph><p>あなたの使っている FreeBSD が比較的新しいけれど前のバージョン (2.1.x 以降) のものなら、 インストールの時に、単にカーネルのコンフィグレーションのメニュー上で PS/2 マウスを有効化するだけです、あるいは後で <code>boot:</code> プロンプト上で <code>-c</code> を指定することでもメニューは現れます。 デフォルトでは無効に設定されていますので、 明示的に有効化してあげないといけません。</p></div><div class=paragraph><p>あなたの使っている FreeBSD が比較的古いものなら、 カーネルコンフィグレーションファイルに以下の行を加えて カーネルを再コンパイルする必要があります。</p></div><div class=paragraph><p>それは FreeBSD 3.0 を含む、それ以前のリリースでは次のとおり、</p></div><div class="literalblock programlisting"><div class=content><pre>device psm0 at isa? port &#34;IO_KBD&#34; conflicts tty irq 12 vector psmintr</pre></div></div><div class=paragraph><p>FreeBSD 3.1 を含む、それ以降のリリースでは次のとおり、</p></div><div class="literalblock programlisting"><div class=content><pre>device psm0 at isa? tty irq 12</pre></div></div><div class=paragraph><p>FreeBSD 4.0 とそれ以降のリリースでは次のとおりです。</p></div><div class="literalblock programlisting"><div class=content><pre>device psm0 at atkbdc? irq 12</pre></div></div><div class=paragraph><p>カーネルの再構築についてよく知らないのであれば、 <a href=https://docs.freebsd.org/ja/books/handbook/kernelconfig#kernelconfig>カーネルのコンフィグレーション</a>を参照してください。</p></div><div class=paragraph><p>起動時にカーネルが <span class=filename>psm0</span> を検出したら、 <span class=filename>psm0</span> のエントリが <span class=filename>/dev</span> の中にあることを確認してください。それには、以下のようにします。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /dev; sh MAKEDEV psm0</span></code></pre></div></div><div class=paragraph><p>これは <code>root</code> でログインしているときに行なってください。</p></div></div><div class=sect2><h3 id=moused>2.11. X Window System 以外の環境でマウスを使うことは可能ですか?<a class=anchor href=#moused></a></h3><div class=paragraph><p>もしデフォルトのコンソールドライバである syscons を使っているのであれば、 テキストコンソール上でマウスを使って、 テキストのカットアンドペーストができます。 マウスデーモンである moused を起動し、 仮想コンソールでマウスポインタを有効にしてください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># moused -p /dev/xxxx -t yyyy</span>
<span class=c># vidcontrol -m on</span></code></pre></div></div><div class=paragraph><p>ここで <em>xxxx</em> はマウスのデバイス名、 <em>yyyy</em> はマウスのプロトコルタイプです。 サポートされているプロトコルタイプについては <a href="https://man.freebsd.org/cgi/man.cgi?query=moused&amp;sektion=8&amp;format=html">moused(8)</a> のマニュアルページを参照してください。</p></div><div class=paragraph><p>システムを起動する時に自動的に moused を起動したい場合には、次のようにします。 FreeBSD 2.2.1 では以下の変数を <span class=filename>/etc/sysconfig</span> で設定してください。</p></div><div class="literalblock programlisting"><div class=content><pre>mousedtype=&#34;yyyy&#34;
mousedport=&#34;xxxx&#34;
mousedflags=&#34;&#34;</pre></div></div><div class=paragraph><p>FreeBSD 2.2.2 以降のバージョンでは <span class=filename>/etc/rc.conf</span> で以下のように設定します。</p></div><div class="literalblock programlisting"><div class=content><pre>moused_type=&#34;yyyy&#34;
moused_port=&#34;xxxx&#34;
moused_flags=&#34;&#34;</pre></div></div><div class=paragraph><p>FreeBSD 3.1 とそれ以降で PS/2 マウスを利用する場合は、 <code>moused_enable="YES"</code> を <span class=filename>/etc/rc.conf</span> に書き加えるだけです。</p></div><div class=paragraph><p>また、起動時にすべての仮想端末で、 標準のコンソールに加えマウスデーモンも使えるようにしたい、 という場合には、以下の行を <span class=filename>/etc/rc.conf</span> に加えます。</p></div><div class="literalblock programlisting"><div class=content><pre>allscreens_flags=&#34;-m on&#34;</pre></div></div><div class=paragraph><p>FreeBSD 2.2.6 以降の場合で 比較的新しいシリアルマウスを使っているならば、 マウスデーモンはマウスのプロトコルタイプを自動判別できます。 自動判別を試みるには、プロトコルタイプとして <code>auto</code> を指定します。</p></div><div class=paragraph><p>マウスデーモンを実行中は、マウスデーモンと他のプログラム (たとえば X Window System) の間でマウスへのアクセスを調整しなければなりません。 この問題については <a href=#x-and-moused>X とマウス</a>をご覧ください。</p></div></div><div class=sect2><h3 id=_マウスを使って_テキストコンソールでカットアンドペーストするにはどうしたらよいのですか>2.12. マウスを使って、 テキストコンソールでカットアンドペーストするにはどうしたらよいのですか?<a class=anchor href=#_マウスを使って_テキストコンソールでカットアンドペーストするにはどうしたらよいのですか></a></h3><div class=paragraph><p>マウスデーモンを起動 (<a href=#moused>前の質問に対する答え</a>を参照してください) したあと、 ボタン 1 (左ボタン) を押しながらマウスを動かして範囲を指定します。 ボタン 2 (中ボタン) またはボタン 3 (右ボタン) をクリックするとテキスト カーソルの位置に選択した範囲のテキストがペーストされます。</p></div><div class=paragraph><p>FreeBSD 2.2.6 以降では、ボタン 2 をクリックするとペーストされ、ボタン 3 をクリックした場合に既存の選択範囲が現在のマウスポインタの位置まで 「延長または短縮」されます。もしマウスに中ボタンがないなら、 moused のオプションを使って中ボタンのエミュレーションをするか、 他のボタンを中ボタンとして使う事ができます。 詳しくは <a href="https://man.freebsd.org/cgi/man.cgi?query=moused&amp;sektion=8&amp;format=html">moused(8)</a> のマニュアルページを参照してください。</p></div></div><div class=sect2><h3 id=_usb_マウスを持っているのですがfreebsd_で使えますか>2.13. USB マウスを持っているのですが、FreeBSD で使えますか?<a class=anchor href=#_usb_マウスを持っているのですがfreebsd_で使えますか></a></h3><div class=paragraph><p>USB デバイスは FreeBSD 3.1 からサポートされましたが、 実装は FreeBSD 3.2 であってもまだ完全ではないため、 必ずしも安定して動作するとは限りません。 もし、それでも USB マウスを使ってみたいという人は、 以下の手順を試してみてください。</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>FreeBSD 3.2 か、それ以降を使います。</p></li><li><p>カーネルコンフィグレーションファイルに以下の行を追加し、 カーネルを再構築します。</p><div class="literalblock programlisting"><div class=content><pre>device  uhci
device  ohci
device  usb
device  ums</pre></div></div><div class=paragraph><p>FreeBSD 4.0 より前のバージョンでは、 代わりに次のようにします。</p></div><div class="literalblock programlisting"><div class=content><pre>controller      uhci0
controller      ohci0
controller      usb0
device          ums0</pre></div></div></li><li><p><span class=filename>/dev</span> ディレクトリに移動し、 次のようにしてデバイスノードを作成します。</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /dev</span>
<span class=c># ./MAKEDEV ums0</span></code></pre></div></div></li><li><p><span class=filename>/etc/rc.conf</span> を編集し、 以下の行を追加します。</p><div class="literalblock programlisting"><div class=content><pre>moused_enable=&#34;YES&#34;
moused_type=&#34;auto&#34;
moused_port=&#34;/dev/ums0&#34;
moused_flags=&#34;&#34;
usbd_enable=&#34;YES&#34;
usbd_flags=&#34;&#34;</pre></div></div><div class=paragraph><p>moused の設定の詳細については、 <a href=#moused>前項</a>も参照してください。</p></div></li><li><p>X のセッションで USB マウスを使うには、 <span class=filename>XF86Config</span> を編集する必要があります。 XFree86 3.3.2、もしくはそれ以降を利用している場合は、 <em>Pointer</em> セクションが次のようになっていることを確認してください。</p><div class="literalblock programlisting"><div class=content><pre>Device          &#34;/dev/sysmouse&#34;
Protocol        &#34;Auto&#34;</pre></div></div><div class=paragraph><p>それより前のバージョンの XFree86 を利用している場合は、 <em>Pointer</em> セクションが次のようになっていることを確認してください。</p></div><div class="literalblock programlisting"><div class=content><pre>Device          &#34;/dev/sysmouse&#34;
Protocol        &#34;SysMouse&#34;</pre></div></div></li></ol></div></div></div><div class=paragraph><p>X 環境でのマウスの利用については、 <a href=#x-and-moused>他の項</a>も参照してください。</p></div><div class=paragraph><p>USB マウスの活線挿抜 (ホットプラグ機能) は、 まだおそらくきちんと動作しないと思われます。 トラブルを避けるためにも、マウスはシステムを起動させる前に接続しておき、 シャットダウンするまではずさないようにした方が良いでしょう。</p></div></div><div class=sect2><h3 id=_わたしのマウスにはホイール機能や便利なボタンがついているのですが_これは_freebsd_でも使えるのですか>2.14. わたしのマウスにはホイール機能や便利なボタンがついているのですが、 これは FreeBSD でも使えるのですか?<a class=anchor href=#_わたしのマウスにはホイール機能や便利なボタンがついているのですが_これは_freebsd_でも使えるのですか></a></h3><div class=paragraph><p>答えは残念ながら「場合によります」です。 こうしたマウスの付加的な機能は大抵の場合、特殊なドライバを必要とします。 マウスのデバイスドライバやユーザのプログラムが そのマウスに対する固有のサポートをしていない場合には、 標準的な 2 ボタン/3 ボタンマウスのように振舞います。</p></div><div class=paragraph><p>X ウィンドウシステムの環境でのホイールの使い方については、 <a href=#x-and-wheel>X とホイール</a>の項をご覧ください。</p></div></div><div class=sect2><h3 id=_わたしのマウスはきちんと動いてくれないようです_マウスカーソルが画面中をとびまわります_このマウスにはホイールがついていて_接続は_ps2_ポートです>2.15. わたしのマウスはきちんと動いてくれないようです。 マウスカーソルが画面中をとびまわります。 このマウスにはホイールがついていて、 接続は PS/2 ポートです。<a class=anchor href=#_わたしのマウスはきちんと動いてくれないようです_マウスカーソルが画面中をとびまわります_このマウスにはホイールがついていて_接続は_ps2_ポートです></a></h3><div class=paragraph><p>FreeBSD 3.2 およびそれ以前の PS/2 マウスドライバ psm には、 Logitech モデル M-S48 とその OEM のホイールマウスで不具合が発生します。 以下のパッチを <span class=filename>/sys/i386/isa/psm.c</span> に適用して、カーネルを再構築してください。</p></div><div class="literalblock programlisting"><div class=content><pre>Index: psm.c
===================================================================
RCS file: /src/CVS/src/sys/i386/isa/Attic/psm.c,v
retrieving revision 1.60.2.1
retrieving revision 1.60.2.2
diff -u -r1.60.2.1 -r1.60.2.2
--- psm.c	1999/06/03 12:41:13	1.60.2.1
+++ psm.c	1999/07/12 13:40:52	1.60.2.2
@@ -959,14 +959,28 @@
    sc-&gt;mode.packetsize = vendortype[i].packetsize;

    /* set mouse parameters */
+#if 0
+    /*
+     * A version of Logitech FirstMouse+ won&#39;t report wheel movement,
+     * if SET_DEFAULTS is sent...  Don&#39;t use this command.
+     * This fix was found by Takashi Nishida.
+     */
    i = send_aux_command(sc-&gt;kbdc, PSMC_SET_DEFAULTS);
    if (verbose &gt;= 2)
printf(&#34;psm%d: SET_DEFAULTS return code:%04x\n&#34;, unit, i);
+#endif
    if (sc-&gt;config &amp; PSM_CONFIG_RESOLUTION) {
        sc-&gt;mode.resolution
    = set_mouse_resolution(sc-&gt;kbdc,
-	        (sc-&gt;config &amp; PSM_CONFIG_RESOLUTION) - 1);
+				   (sc-&gt;config &amp; PSM_CONFIG_RESOLUTION) - 1);
+    } else if (sc-&gt;mode.resolution &gt;= 0) {
+	sc-&gt;mode.resolution
+	    = set_mouse_resolution(sc-&gt;kbdc, sc-&gt;dflt_mode.resolution);
+    }
+    if (sc-&gt;mode.rate &gt; 0) {
+	sc-&gt;mode.rate = set_mouse_sampling_rate(sc-&gt;kbdc, sc-&gt;dflt_mode.rate);
    }
+    set_mouse_scaling(sc-&gt;kbdc, 1);

    /* request a data packet and extract sync. bits */
    if (get_mouse_status(sc-&gt;kbdc, stat, 1, 3) &lt; 3) {</pre></div></div><div class=paragraph><p>FreeBSD 3.2 より新しいリリースではきちんと動作するはずです。</p></div></div><div class=sect2><h3 id=_ラップトップ_pc_のマウストラックボールタッチパッドは使えますか>2.16. ラップトップ PC のマウス/トラックボール/タッチパッドは使えますか?<a class=anchor href=#_ラップトップ_pc_のマウストラックボールタッチパッドは使えますか></a></h3><div class=paragraph><p><a href=#ps2mouse>前の質問に対する答え</a>と、 <a href=#pao>モバイルコンピューティングのページ</a>をご覧ください。</p></div></div><div class=sect2><h3 id=_どんなテープドライブをサポートしていますか>2.17. どんなテープドライブをサポートしていますか?<a class=anchor href=#_どんなテープドライブをサポートしていますか></a></h3><div class=paragraph><p>FreeBSD は SCSI と QIC-36 (QIC-02 インタフェース付き) をサポートしています。 これらには 8-mm (Exabyte と呼ばれています) や DAT ドライブも含まれています。</p></div><div class=paragraph><p>初期の 8-mm ドライブの中には SCSI-2 とまったく互換性を持たないものがあります。 これらは FreeBSD 上では動作しません。</p></div></div><div class=sect2><h3 id=_どんなテープチェンジャーをサポートしていますか>2.18. どんなテープチェンジャーをサポートしていますか?<a class=anchor href=#_どんなテープチェンジャーをサポートしていますか></a></h3><div class=paragraph><p>FreeBSD 2.2 は <a href="https://man.freebsd.org/cgi/man.cgi?query=ch&amp;sektion=4&amp;format=html">ch(4)</a> デバイスと <a href="https://man.freebsd.org/cgi/man.cgi?query=chio&amp;sektion=1&amp;format=html">chio(1)</a> コマンドを使用した SCSI チェンジャーをサポートしています。 実際のチェンジャーの制御方法の詳細は、<a href="https://man.freebsd.org/cgi/man.cgi?query=chio&amp;sektion=1&amp;format=html">chio(1)</a> のマニュアルページを参照してください。</p></div><div class=paragraph><p>使用している製品が AMANDA のようにチェンジャーに対応済みのものでない場合は、 次のことについて留意してください。 それらの製品は任意のポイント間のテープの移動を制御するだけなので、 テープがどのスロットに入っているか、現在ドライブにあるテープが どのスロットに戻るべきかを把握しておく必要があります。</p></div></div><div class=sect2><h3 id=_どんなサウンドカードをサポートしていますか>2.19. どんなサウンドカードをサポートしていますか?<a class=anchor href=#_どんなサウンドカードをサポートしていますか></a></h3><div class=paragraph><p>FreeBSD は SoundBlaster、SoundBlaster Pro、SoundBlaster 16、 Pro Audio Spectrum 16、AdLib それから Gravis UltraSound サウンドカードを サポートしています。MPU-401 やその互換カードも機能に制限はあるものの サポートされています。マイクロソフトサウンドシステムのスペックに準拠 したカードも、<span class=filename>pcm</span> ドライバでサポートされています。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>これらはサウンドについてのみの話です! これらのドライバは CD-ROM、SCSI、カード上にあるジョイスティックをサポートしていません (SoundBlaster は例外です)。SoundBlaster SCSI インタフェースと非 SCSI CD-ROM はサポートしていますが、そのデバイスからは起動できません。</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=_pcm_ドライバで_es1370_から音が出ないのはどうにかなりませんか>2.20. pcm ドライバで es1370 から音が出ないのはどうにかなりませんか?<a class=anchor href=#_pcm_ドライバで_es1370_から音が出ないのはどうにかなりませんか></a></h3><div class=paragraph><p>マシンを起動するごとに以下のコマンドを実行してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mixer pcm 100 vol 100 cd 100</span></code></pre></div></div></div><div class=sect2><h3 id=_どんなネットワークカードをサポートしていますか>2.21. どんなネットワークカードをサポートしていますか?<a class=anchor href=#_どんなネットワークカードをサポートしていますか></a></h3><div class=paragraph><p>より完全な一覧については<a href=https://docs.freebsd.org/ja/books/handbook/>イーサネットカード</a>の節を参照してください。</p></div></div><div class=sect2><h3 id=_数値演算コプロセッサを持っていませんが何かまずいでしょうか>2.22. 数値演算コプロセッサを持っていませんが、何かまずいでしょうか?<a class=anchor href=#_数値演算コプロセッサを持っていませんが何かまずいでしょうか></a></h3><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>これらは 386/486SX/486SLC を持っている場合に影響します - ほかのマシンでは CPU に内蔵されています。</p></div></td></tr></tbody></table></div><div class=paragraph><p>一般にこれらは問題とはなりません。 しかし、数値演算エミュレーションコードのパフォーマンスか、 正確さのいずれかを選択する状況があります (詳しくは <a href=#emul>FP エミュレーション</a> についての節をご覧ください)。 とくに、X 上で弧を描く際にとても遅くなることでしょう。 数値演算コプロセッサを購入されることを強くおすすめします。 とても役立つことでしょう。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>他の数値演算コプロセッサよりも優れたコプロセッサもあります。 これは言いにくいことなのですが、Intel を買うために躍起になる人もいないでしょう。 それが FreeBSD 上で動くという確信がないのなら、クローンにご用心を。</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=_freebsd_がサポートするデバイスは他にもあるんでしょうか>2.23. FreeBSD がサポートするデバイスは他にもあるんでしょうか?<a class=anchor href=#_freebsd_がサポートするデバイスは他にもあるんでしょうか></a></h3><div class=paragraph><p><a href=https://docs.freebsd.org/ja/books/handbook/>FreeBSD ハンドブック</a>に記されている、 サポートされている他のデバイスの一覧を参照してください。</p></div></div><div class=sect2><h3 id=_パワーマネージメント機能付きのラップトップ_pc_を持っているのですが>2.24. パワーマネージメント機能付きのラップトップ PC を持っているのですが…。<a class=anchor href=#_パワーマネージメント機能付きのラップトップ_pc_を持っているのですが></a></h3><div class=paragraph><p>FreeBSD は一部のマシンの APM をサポートしています。 <span class=filename>LINT</span> カーネルコンフィグファイル の APM の部分をご覧ください。 さらに詳しいことは <a href="https://man.freebsd.org/cgi/man.cgi?query=apm&amp;sektion=4&amp;format=html">apm(4)</a> に載っています。</p></div></div><div class=sect2><h3 id=_micron_システムが起動時に固まってしまいます>2.25. Micron システムが起動時に固まってしまいます。<a class=anchor href=#_micron_システムが起動時に固まってしまいます></a></h3><div class=paragraph><p>特定の Micron 製のマザーボードの中には、PCI BIOS が規格通りに 実装されていないために FreeBSD の起動に失敗するものがあります。 その BIOS は、PCI デバイスをあるアドレスで設定したと報告するにも 関わらず、実際にはそうしていないのです。</p></div><div class=paragraph><p>この問題を回避するには、BIOS の "Plug and Play Operating System" を無効に設定してください。また、より詳しい情報は <a href=http://cesdis.gsfc.nasa.gov/linux/drivers/vortex.html#micron>http://cesdis.gsfc.nasa.gov/linux/drivers/vortex.html#micron</a> を参照してください。</p></div></div><div class=sect2><h3 id=_新しい_adaptec_コントローラを持っているのですが_freebsd_が検出できないようです>2.26. 新しい Adaptec コントローラを持っているのですが、 FreeBSD が検出できないようです。<a class=anchor href=#_新しい_adaptec_コントローラを持っているのですが_freebsd_が検出できないようです></a></h3><div class=paragraph><p>新しい AIC789x シリーズの Adaptec チップは、3.0 でデビューした CAM SCSI フレームワークでサポートされています。 2.2-STABLE のパッチは <a href=ftp://ftp.FreeBSD.org/pub/FreeBSD/development/cam/>ftp://ftp.FreeBSD.org/pub/FreeBSD/development/cam/</a> にあります。 CAM システムが入っている高機能ブートフロッピーは <a href=http://people.FreeBSD.org/~abial/cam-boot/>http://people.FreeBSD.org/~abial/cam-boot/</a> にあります。 どちらの場合にしても、作業を始める前に <span class=filename>README</span> をお読みください。</p></div></div><div class=sect2><h3 id=_内蔵の_plug_play_モデムを持っているのですがfreebsd_が検出できないようです>2.27. 内蔵の Plug & Play モデムを持っているのですが、FreeBSD が検出できないようです。<a class=anchor href=#_内蔵の_plug_play_モデムを持っているのですがfreebsd_が検出できないようです></a></h3><div class=paragraph><p>モデムの PnP ID を シリアルドライバの PnP ID リストに追加する必要があるでしょう。 Plug & Play サポートを有効にするには、 <code>controller pnp0</code> をコンフィグレーション ファイルに付け加え、 新しいカーネルをコンパイルしてシステムを再起動してください。 カーネルは、検出したすべてのデバイスの PnP ID を表示します。 モデムの欄にある PnP ID を <span class=filename>/sys/i386/isa/sio.c</span> の 2777 行目くらいにあるテーブルに書き入れてください。 テーブルを見つけるには、構造体 <code>siopnp_ids[]</code> の文字列 <code>SUP1310</code> を探します。 カーネルを作り直したらインストールし、システムを再起動してください。 そうすれば、モデムが検出されるはずです。</p></div><div class=paragraph><p>起動時のコンフィグレーションの際に、<code>pnp</code> コマンドを使用して PnP の設定をマニュアルで行なわなければならないかもしれません。 その場合、モデムを検出させるためのコマンドは</p></div><div class="literalblock programlisting"><div class=content><pre>pnp 1 0 enable os irq0 3 drq0 0 port0 0x2f8</pre></div></div><div class=paragraph><p>のようになります。</p></div></div><div class=sect2><h3 id=_シリアルコンソールで_boot_プロンプトを表示するにはどうすればいい>2.28. シリアルコンソールで boot: プロンプトを表示するにはどうすればいい?<a class=anchor href=#_シリアルコンソールで_boot_プロンプトを表示するにはどうすればいい></a></h3><div class="olist arabic"><ol class=arabic><li><p><code>options COMCONSOLE</code> を指定してカーネルを構築してください。</p></li><li><p>そして <span class=filename>/boot.config</span> を作成して <code>-P</code> とだけ書き入れてください。</p></li><li><p>その後、キーボードをシステムから抜きます。</p></li></ol></div><div class=paragraph><p><span class=filename>/usr/src/sys/i386/boot/biosboot/README.serial</span> に、 これに関する情報が書かれています。</p></div></div><div class=sect2><h3 id=_なぜ_micron_コンピュータで_3com_pci_ネットワークカードが動かないのでしょう>2.29. なぜ Micron コンピュータで 3Com PCI ネットワークカードが動かないのでしょう?<a class=anchor href=#_なぜ_micron_コンピュータで_3com_pci_ネットワークカードが動かないのでしょう></a></h3><div class=paragraph><p>特定の Micron 製のマザーボードの中には、PCI BIOS が規格通りに 実装されていないために FreeBSD の起動に失敗するものがあります。 その BIOS は、PCI デバイスをあるアドレスで設定したと報告するにも 関わらず、実際にはそうしていないのです。</p></div><div class=paragraph><p>この問題を回避するには、BIOS の "Plug and Play Operating System" を無効に設定してください。また、より詳しい情報は <a href=http://cesdis.gsfc.nasa.gov/linux/drivers/vortex.html#micron>http://cesdis.gsfc.nasa.gov/linux/drivers/vortex.html#micron</a> を参照してください。</p></div></div><div class=sect2><h3 id=_対称型マルチプロセシング_smp_をサポートしていますか>2.30. 対称型マルチプロセシング (SMP) をサポートしていますか?<a class=anchor href=#_対称型マルチプロセシング_smp_をサポートしていますか></a></h3><div class=paragraph><p>SMP は、3.0-STABLE とそれ以降のリリースでのみサポートされています。 <em>GENERIC</em> カーネルでは SMP は有効化されていませんので、 SMP を有効化するにはカーネルを再構築する必要があります。 <span class=filename>/sys/i386/conf/LINT</span> を見て、 カーネルコンフィグファイルにどのオプションを追加すれば良いのか確かめてください。</p></div></div><div class=sect2><h3 id=_asus_k7v_マザーボードのシステムでブートフロッピーを使うと_システムがハングアップします_対応策はありませんか>2.31. ASUS K7V マザーボードのシステムでブートフロッピーを使うと、 システムがハングアップします。 対応策はありませんか?<a class=anchor href=#_asus_k7v_マザーボードのシステムでブートフロッピーを使うと_システムがハングアップします_対応策はありませんか></a></h3><div class=paragraph><p>BIOS セットアップで "起動時のウィルス保護機能" を無効化してください。</p></div></div></div></div><div class=sect1><h2 id=_トラブルシューティング>3. トラブルシューティング<a class=anchor href=#_トラブルシューティング></a></h2><div class=sectionbody><div class=sect2><h3 id=_ハードディスクに不良ブロックがあります>3.1. ハードディスクに不良ブロックがあります!<a class=anchor href=#_ハードディスクに不良ブロックがあります></a></h3><div class=paragraph><p>SCSI ディスクの場合は自動的に再マップする機能があるはずです。 しかし、理解し難い理由から多くのドライブがこの機能が無効化 されて出荷されています…​。</p></div><div class=paragraph><p>これを有効化するには、 最初のデバイスのモードページを変更する必要があります。 これは次のコマンドを実行することで、FreeBSD 上で行なうことができます (<code>root</code> 権限で行ないます)。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># scsi -f /dev/rsd0c -m 1 -e -P 3</span></code></pre></div></div><div class=paragraph><p>そして、AWRE と ARRE の値を 0 から 1 へ変更します</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>AWRE <span class=o>(</span>Auto Write Reallocation Enbld<span class=o>)</span>:  1
ARRE <span class=o>(</span>Auto Read Reallocation Enbld<span class=o>)</span>:  1</code></pre></div></div><div class=paragraph><p>以下は、<a href=mailto:tedm@toybox.placo.com>Ted Mittelstaedt 氏</a>から寄せられたものです。</p></div><div class=paragraph><p>IDE ドライブの場合は通常、不良ブロックは潜在的な障害の兆候です。 最近の IDE ドライブは、内部の不良ブロック再マッピング機能を有効にした状態で 出荷されています。また、今日の IDE ハードディスクメーカは、 出荷以降に不良ブロックが発生することに関して保証を提供していて、 不良ブロックのあるディスクドライブを交換するサービスを行なっています。</p></div><div class=paragraph><p>もし、不良ブロックのある IDE ディスクドライブを復旧しようと思うなら、 IDE ドライブメーカが提供する IDE 診断プログラムをダウンロードして、 そのドライブに使ってみてください。この種のプログラムは大抵、 ドライブの制御部分に対して不良ブロックを再走査し、 不良ブロックを使用不能にするようにセットすることができます。</p></div><div class=paragraph><p>ESDI、RLL および MFM ドライブの場合、 不良ブロックはドライブの正常な部分であり、 一般的に言って障害を表すものではありません。 PC では、ディスクドライブコントローラカードと BIOS が不良ブロックの使用不能化の作業を行ないます。 DOS など、ディスクアクセスに BIOS を経由する OS にとっては有効に働きますが、FreeBSD のディスクドライバは BIOS を利用しません。そのため、 代替として bad144 という機構が存在します。 bad144 は、wd ドライバでだけ (つまり FreeBSD 4.0 ではサポートされていない)動作し、SCSI ドライバに利用することは <em>できません</em>。bad144 は、 検出された不良セクタをスペシャルファイルに記録するという機能を持っています。</p></div><div class=paragraph><p>bad144 を利用する上で、注意しなければならない点が一つあります。 それは、不良ブロックスペシャルファイルは、 ディスクの最終トラックに置かれるということです。 このファイルには、ディスクの先頭の付近、 <span class=filename>/kernel</span> ファイルが位置しているであろう部分で発生した不良セクタが記録されています。 したがって、このファイルは BIOS コールを使ってカーネルファイルを読み込む起動プログラムが、 アクセス可能でなければなりません。 これはつまり、bad144 を利用するディスクは 1024 シリンダ、16 ヘッド、63 セクタを超えてはならないということを意味し、 bad144 を利用したディスクが実質 500MB を超えられないことになります。</p></div><div class=paragraph><p>bad144 を使うには、FreeBSD のインストール時に表示される fdisk 画面で "Bad Block" 走査を ON に設定するだけです。 これは、FreeBSD 2.2.7 以降で機能します。 ディスクは、1024 シリンダ以内でなければなりません。 ディスクドライブは事前に少なくとも 4 時間、 ディスクが温度によって膨張し、 トラックに曲がりが出るまで回転させることをお薦めします (訳注: 温度変化に対する膨張によって、 ディスクが微小変形することにより発生する不良セクタを確実に検出するためです)。</p></div><div class=paragraph><p>大容量の ESDI ドライブのように 1024 シリンダを超えるディスクの場合、 DOS 上でそのディスクが利用できるよう、 ESDI コントローラは特殊な変換モードを利用します。 fdisk の "set geometry" コマンドを使って "変換された (translated)" ジオメトリに切替えると、wd ドライバはこの変換モードを解釈できます。 その際、FreeBSD パーティションを作成するのに "dangerously dedicated" モードを利用してはいけません。 このモードは、そのようなジオメトリを無視するからです。 たとえ fdisk がオーバーライドされたジオメトリ情報を使ったとしても、 依然としてディスクの真の大きさを保持しているため、大きすぎる FreeBSD パーティションを作成しようとしてしまうでしょう。 ディスクジオメトリ情報が変換されたジオメトリ情報にかわっている場合は、 手動でブロック数を入力し、 パーティションを作成する必要があります。</p></div><div class=paragraph><p>大容量の ESDI ディスクを ESDI コントローラでセットアップするには、 ちょっとしたトリックを使います。まず、DOS のディスクで起動して そのディスクを DOS パーティションとしてフォーマットします。 そして FreeBSD を起動し、インストーラの fdisk 画面で DOS パーティションのブロックサイズとブロック数を読みとり、メモしておきます。 ジオメトリ情報を DOS が利用しているものと同一に再設定し、 DOS パーティションを削除して "cooperative" FreeBSD パーティションを 先程記録したブロックサイズを使って作成してください。 そのパーティションを起動可能パーティションに設定し、不良ブロック走査を 有効にします。 実際のインストールでは、ファイルシステムが作成される前に bad144 が最初に実行されます (Alt-F2 を押すことで状況を確認できます)。 不良セクタファイルを作成中に何らかの障害が発生したなら、 システムを再起動して、もう一度最初からやり直しになります。 おそらくディスクジオメトリ情報の設定を大きくしすぎているのでしょう (やり直しは、DOS によるフォーマットとパーティション確保を含みます)。</p></div><div class=paragraph><p>もし、不良ブロックの再マッピングを有効にしていて不良ブロックが見付かったら、 ドライブの交換を考えてください。不良ブロックは、時間とともに悪化するからです。</p></div></div><div class=sect2><h3 id=_bustek_742a_eisa_scsi_が認識されません>3.2. Bustek 742a EISA SCSI が認識されません。<a class=anchor href=#_bustek_742a_eisa_scsi_が認識されません></a></h3><div class=paragraph><p>この情報は 742a のためのものですが、他の Buslogic カードについても 同様のことが言えます。(Bustek = Buslogic)</p></div><div class=paragraph><p>742a カードには大きくわけて 2 つの「バージョン」が存在します。 ハードウェアリビジョンの A-G と H 以降です。リビジョンの 文字はカードの隅にあるアセンブリ番号の後ろにあります。 742a は二つの ROM チップを持っており、一つは BIOS チップで もう一つはファームウェアチップです。FreeBSD はあなたの 持っているものがどの BIOS バージョンかは問題ありませんが、 ファームウェアバージョンについては問題となります。 Buslogic の技術サポート部門に連絡すれば、アップグレード版の ROM を送ってくれることでしょう。BIOS チップと ファームウェアチップはペアで出荷されます。 アダプタカードのハードウェアリビジョンにあわせた 最も新しいファームウェア ROM を使用しなければなりません。</p></div><div class=paragraph><p>リビジョン A-G のカードには、2.41/2.21 までの BIOS/ファームウェアのセットを使用することができます。 リビジョン H 以降のカードには、最新のものである 4.70/3.37 の BIOS/ファームウェアのセットを 使用することができます。これらのファームウェアの違いは、 ファームウェア 3.37 が 「ラウンドロビン方式」 をサポートしているところからきています。</p></div><div class=paragraph><p>Buslogic のカードには、製造番号も刻印されています。古い ハードウェアリビジョンのカードを持っている場合は、Buslogic の RMA 部門に問い合わせて製造番号を伝えると、新しいハードウェアリビジョンの カードに交換することもできます。もしカードが十分新しければ、彼らは 交換に応じてくれるでしょう。</p></div><div class=paragraph><p>FreeBSD 2.1 は ファームウェアリビジョン 2.21 以降のものをサポートしています。 これよりも古いファームウェアリビジョンのものは、 Buslogic カードとして正常に認識されません。 しかし、Adaptec 1540 として認識されるかもしれません。 初期の Buslogic のファームウェアは AHA1540 「互換」モードを 持っています。しかし、EISA カードにとってこれは よいことではありません。</p></div><div class=paragraph><p>古いハードウェアリビジョンのカードを持っていてファームウェア 2.21 を入手するのであれば、ジャンパ W1 の位置をデフォルトの A-B から B-C に合わせる必要があるでしょう。</p></div></div><div class=sect2><h3 id=_hp_netserver_上のオンボード_scsi_コントローラが認識されません>3.3. HP Netserver 上のオンボード SCSI コントローラが認識されません。<a class=anchor href=#_hp_netserver_上のオンボード_scsi_コントローラが認識されません></a></h3><div class=paragraph><p>基本的にこれは既知の問題です。HP Netserver マシンの EISA オンボード SCSI コントローラは EISA のスロット番号 11 を占有しますが、「本当の」EISA スロットはすべてそれよりも前のアドレスに配置されているのです。 残念ながら、 10 番以上の EISA スロットは PCI に割り当てられたアドレス空間と衝突し、FreeBSD の自動コンフィグレーションは、 現状ではうまくこの状況を処理できていないのです。</p></div><div class=paragraph><p>ですから現時点での最良の方法は、カーネルオプションの <code>EISA_SLOTS</code> を 12 に変え、 アドレス空間の衝突がないかの ようなふりをさせることです :) <a href=https://docs.freebsd.org/ja/books/handbook/kernelconfig#kernelconfig>カーネルの再構築</a>に記述されているようにしてカーネルを再構築してください。</p></div><div class=paragraph><p>もちろん、これはこのようなマシンにインストールする際に 「卵が先か、 鶏が先か」といった問題を生み出すことになります。 この問題を回避するために、 <em>ユーザコンフィグ (UserConfig)</em> の中には特別な仕組みが組み込まれています。 このとき "visual" インタフェースは使用せず、 コマンドラインインタフェースを使用してください。単純に</p></div><div class="literalblock programlisting"><div class=content><pre>eisa 12
quit</pre></div></div><div class=paragraph><p>とプロンプト上から打ち込み、 後は普通にインストールを行なってください。 とにかくカスタムカーネルのコンパイルとインストールを行なうことを おすすめします。</p></div><div class=paragraph><p>うまくいけば、将来のバージョンではこの問題が解決していることでしょう。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>HP Netserver では<code>危険覚悟の専用ディスク</code>は使用できません。 詳細については <a href=#dedicate>この注意事項</a>をご覧ください。</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=_この_cmd640_ide_コントローラはどこかおかしいようです>3.4. この CMD640 IDE コントローラはどこかおかしいようです。<a class=anchor href=#_この_cmd640_ide_コントローラはどこかおかしいようです></a></h3><div class=paragraph><p>それは壊れているのです。両方のチャンネルを同時に制御できないのです。</p></div><div class=paragraph><p>現在、このチップを使っているシステムを自動的に検出して、 うまく動かすためのしくみが使えるようになっています。 くわしくは wd(4) のマニュアルページを参照してください。</p></div><div class=paragraph><p>CMD640 IDE コントローラを使っているシステムで FreeBSD 2.2.1 あるいは 2.2.2 を使い、 かつセカンダリのチャネルを使いたいのであれば、 <code>options "CMD640"</code> を有効にしてカーネルを作り直してください。 FreeBSD 2.2.5 以降では、デフォルトでそうなっています。</p></div></div><div class=sect2><h3 id=_ed1_timeout_のようなメッセージがいつも出ます>3.5. ed1: timeout のようなメッセージがいつも出ます。<a class=anchor href=#_ed1_timeout_のようなメッセージがいつも出ます></a></h3><div class=paragraph><p>たぶん IRQ の衝突が原因でしょう (二つのボードが同じ IRQ を使用しているなど)。FreeBSD 2.0.5R 以前はこれに関して寛大で、 IRQ の衝突があってもネットワークドライバは機能していました。 しかし 2.0.5R 以降はもはや、IRQ の衝突に寛大ではありません。 <code>-c</code> オプションをつけて起動し、 ed0/de0/…​ のエントリをボードの設定に合わせてください。</p></div><div class=paragraph><p>ネットワークカードの BNC コネクタ (訳注: 10BASE-2 タイプのインタフェース) を使っている場合、 デバイスのタイムアウトはターミネーションの不良によっても起きます。 これをチェックするにはケーブルを外してターミネータを直接 NIC に接続します。そしてエラーメッセージが消えるかどうか 確認します。</p></div><div class=paragraph><p>NE2000 コンパチブルカードのなかには、 UTP ポートのリンクがなかったりケーブルが接続されていない場合に このエラーを出すものがあります。</p></div></div><div class=sect2><h3 id=_cdrom_をマウントしようとすると_incorrect_super_block_と言われます>3.6. CDROM をマウントしようとすると Incorrect super block と言われます。<a class=anchor href=#_cdrom_をマウントしようとすると_incorrect_super_block_と言われます></a></h3><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a> にマウントしたいデバイスのタイプを指定する必要があります。 デフォルトでは <a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a> はファイルシステムを <code>ufs</code> とみなします。CDROM のファイルシステムを マウントしたいのであれば <code>-t cd9660</code> と <a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a> にオプションをつけて明示する必要があります。 これはもちろん CDROM が ISO 9660 ファイルシステムである場合です。ほとんどの CDROM はこの形式です。1.1R の FreeBSD では (訳注: 2.1.5R、 2.2R でも同様です) 自動的に Rock Ridge 拡張 (長いファイル名への対応) をうまく解釈します。</p></div><div class=paragraph><p>CDROM のデバイス <span class=filename>/dev/cd0c</span> を <span class=filename>/mnt</span> にマウントしたい場合の例では、次のようにします。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount -t cd9660 /dev/cd0c /mnt</span></code></pre></div></div><div class=paragraph><p>デバイスの名前はインタフェースによっては別の名前になっている かもしれないので注意してください (<span class=filename>/dev/cd0c</span> はこの場合の例です)。 オプション <code>-t cd9660</code> によって <code>mount_cd9660</code> コマンドが実行されることに注意してください。 このため例は次のようにすることもできます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount_cd9660 /dev/cd0c /mnt</span></code></pre></div></div></div><div class=sect2><h3 id=_cdrom_をマウントしようとすると_device_not_configured_と言われます>3.7. CDROM をマウントしようとすると Device not configured と言われます。<a class=anchor href=#_cdrom_をマウントしようとすると_device_not_configured_と言われます></a></h3><div class=paragraph><p>これは 一般的に CDROM ドライブの中に CDROM が入っていないか、 ドライブがバス上に見えないことを意味します。ドライブに CDROM を入れるか、IDE (ATAPI) であれば master/slave の状態をチェックしてください。 また、CDROM ドライブに CDROM を入れてから認識するまでには数秒かかりますので、 少し待ってみてください。</p></div><div class=paragraph><p>SCSI CDROM ではバスリセットへの応答時間が遅いために、 失敗することがあるかもしれません。 SCSI CDROM を持っている場合は、 カーネルコンフィグレーションファイルに以下の行を加えて 再コンパイルして試してみてください。</p></div><div class="literalblock programlisting"><div class=content><pre>options &#34;SCSI_DELAY=15&#34;</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>現在の GENERIC カーネルでは上の設定はデフォルトになっています。 問題がある場合は <code>SCSI_DELAY</code> の数値を増やしてみてください。</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=_cdrom_をマウントするとファイル名中の英数字以外の_文字が_と表示されてしまいます>3.8. CDROM をマウントすると、ファイル名中の英数字以外の 文字が、? と表示されてしまいます。<a class=anchor href=#_cdrom_をマウントするとファイル名中の英数字以外の_文字が_と表示されてしまいます></a></h3><div class=paragraph><p>もっともありそうなのは、その CDROM が "Joliet" 拡張を利用してファイルおよび ディレクトリに関する情報を保存しているということです。この拡張は、 すべてのファイル名を Unicode の 2 バイト文字で保存するように 規定しています。現在、FreeBSD カーネルに汎用的な Unicode インタフェースを導入する作業が行われていますが、 まだ完了していません。したがって、CD9660 ドライバはファイル名の文字を解読できません。</p></div><div class=paragraph><p>一時的な解決策として、FreeBSD 4.3R 以降では、CD9660 ドライバに特別な仕掛けを施して、ユーザーがその場で適切な 変換表を読み込めるようにしました。一般的なエンコーディングに 対応したいくつかのモジュールが <span class=filename>sysutils/cd9660_unicode</span> port で提供されています。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>この記述は古くなっています。<a href=#CDROM-UNICODE-FILENAMES>英語版の記述</a>をご覧ください。</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=_私のプリンタはとてつもなく遅いのです_どうしたらよいのでしょう>3.9. 私のプリンタはとてつもなく遅いのです。 どうしたらよいのでしょう?<a class=anchor href=#_私のプリンタはとてつもなく遅いのです_どうしたらよいのでしょう></a></h3><div class=paragraph><p>パラレルインタフェースで、問題はとんでもなく遅いだけであるなら、 プリンタボートを "polled" モードに設定してみてください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># lptcontrol -p</span></code></pre></div></div><div class=paragraph><p>HP の新しいプリンタには、 割り込みモードで使えないものがあるようです (完全にわかったわけではありませんが)。 タイミングの問題のように思われます。</p></div></div><div class=sect2><h3 id=_わたしのプログラムは時々_signal_11_のエラーで止まってしまいます>3.10. わたしのプログラムは時々 Signal 11 のエラーで止まってしまいます。<a class=anchor href=#_わたしのプログラムは時々_signal_11_のエラーで止まってしまいます></a></h3><div class=paragraph><p>Signal 11 エラーはオペレーティングシステムが 許可を与えていないメモリにアクセスしようとしたときに発生します。 このようなことがランダムな間隔で起っているようなら、 注意深く調査していった方が良いです。</p></div><div class=paragraph><p>この手の問題はたいていの場合、以下のどちらかです。</p></div><div class="olist arabic"><ol class=arabic><li><p>その問題が特定の、 あなたが自分で開発したアプリケーションでのみ起っているなら、 あなたのコードにバグがあるのでしょう。</p></li><li><p>それが FreeBSD のベースシステムの一部と関連する問題なら、 コードにバグがあるということになります。 しかしほとんどの場合、 普通の FAQ の読者がそのようなコードを使うようになるずっと前に、 そういった問題は発見され、修正されているはずです (それが -current の役目なのですから)。</p></li></ol></div><div class=paragraph><p>それが FreeBSD のバグでは「ない」という決定的なケースとして、 その問題の発生がプログラムをコンパイルしているときであり、 コンパイル毎に毎回、コンパイラの挙動が変るというものがあります。</p></div><div class=paragraph><p>たとえば、あなたが "make buildworld" を実行していて、 コンパイラが ls.c から ls.o をコンパイルしようとしたときに コンパイルに失敗したとします。もう一度 "make buildworld" を実行したときに、まったく同じ場所でコンパイルが失敗したのなら、 それは build が壊れている (訳注: つまりソースにバグがある) と言うことです — ソースを更新してやりなおしてみてください。 もしコンパイルが別の場所でしくじっていたら、 それはハードウェアの問題です。</p></div><div class=paragraph><p>あなたのやるべき事は:</p></div><div class=paragraph><p>前者の場合は、 そのプログラムの間違ったアドレスへアクセスしようとしている部分を、 gdb 等のデバッガで見つけて修正します。</p></div><div class=paragraph><p>後者の場合は、 ハードウェアに問題がないことを確かめる必要があります。</p></div><div class=paragraph><p>その一般的な原因として :</p></div><div class="olist arabic"><ol class=arabic><li><p>ハードディスクが熱を持ちすぎているかも知れません: ケースのファンがちゃんと動いていてディスクを冷やしているか 確かめてください (たぶん、他の部品も過熱しています)。</p></li><li><p>CPU がオーバーヒートしています: CPU をオーバークロックしていませんか? さもなければ CPU ファンが死んでいるのかもしれません。 いずれにせよ、少なくとも問題解決の間では ハードウェアが動くべく指定された条件で動かしてください。 クロックはデフォルトの設定に戻してください。</p><div class=paragraph><p>もしあなたがクロックアップをしているのなら、 遅いシステムでも、システムが焼き付いて 買い換えなければならなくなるよりずっとマシだということを 覚えておいた方が良いでしょう。 大きいコミュニティでは特に、 あなたがそれが安全だと思っているかどうかは関係なく、 オーバークロックしたシステムに発生した問題には同情的ではありません。</p></div></li><li><p>怪しいメモリ: もし複数の SIMM や DIMM を使っているならそれを全部抜いてから 各 SIMM や DIMM を別個に組み込んだシステムを立ち上げてることで どの DIMM/SIMM が怪しいのか、それとも組合わせが悪いのか と問題の幅が狭まります。</p></li><li><p>楽観的すぎるマザーボードの設定: ほとんどの場合に標準設定で十分なタイミングを、 BIOS の設定やマザーボード上のジャンパピンを変えることで、 さまざまに変更することができます。しかし時には RAM の アクセスウェイトを低くしすぎたり "RAM Speed: Turbo" や その手の BIOS の設定でおかしな挙動が起こることがあります。 BIOS を標準の設定に戻すというのはいいアイディアですが、 その前にあなたの設定を書き留めておいた方がいいでしょう。</p></li><li><p>マザーボードへの電源が安定していない。 もし使っていない I/O ボードやハードディスク、 CDROM 等があるなら、一旦それらから電源ケーブルを抜き、 電源が小さな負荷ならなんとか動作するか確認しましょう。 あるいは別の電源を試してみましょう。 その時はなるべく、少し容量の大きいもので試しましょう (たとえば、今の電源容量が 250W だったら 300W のものを試します)。</p></li></ol></div><div class=paragraph><p>SIG11 FAQ (下に示します) にはこれらの問題のすべてが 詳しく説明されています。Linux の視点に基づくものですが、 これも読んでおいた方がいいでしょう。そこではまた、 メモリのテストを行うソフトウェアや、 ハードウェアがなぜ問題のあるメモリを見逃してしまうかについても 議論されています。</p></div><div class=paragraph><p>最後に、これらがどれも助けにならなかったら、 FreeBSD のバグを発見した可能性があります。 以下の説明を読んで障害報告を送ってください。</p></div><div class=paragraph><p>詳細な FAQ は、<a href=http://www.bitwizard.nl/sig11/>the SIG11 problem FAQ</a> にあります。</p></div></div><div class=sect2><h3 id=_起動の時に画面が真っ暗になって同期も取れません>3.11. 起動の時に画面が真っ暗になって同期も取れません。<a class=anchor href=#_起動の時に画面が真っ暗になって同期も取れません></a></h3><div class=paragraph><p>これは ATI Mach 64 ビデオカードの既知の問題です。 この問題はカードがアドレス <code>2e8</code> を使い、 4 番目のシリアルポートもここを使うということにあります。 <a href="https://man.freebsd.org/cgi/man.cgi?query=sio&amp;sektion=4&amp;format=html">sio(4)</a> ドライバのバグ (仕様?) のため、 4 番目のシリアルポートがなくても、 通常このアドレスを使う sio3 (4 番目のポートにあたります) を無効にしても、ドライバはこのアドレスをさわります。</p></div><div class=paragraph><p>バグが修正されるまでは、次のようにして対処してください。</p></div><div class="olist arabic"><ol class=arabic><li><p>起動プロンプトが出たら <code>-c</code> と入力します (これによりカーネルはコンフィグレーションモードに入ります)。</p></li><li><p><span class=filename>sio0</span>, <span class=filename>sio1</span>, <span class=filename>sio2</span>, <span class=filename>sio3</span> (これらすべて) を無効にします。 これによって <a href="https://man.freebsd.org/cgi/man.cgi?query=sio&amp;sektion=4&amp;format=html">sio(4)</a> ドライバは動作しなくなりますが、問題はありません。</p></li><li><p>exit と入力して起動を続行します。</p></li></ol></div><div class=paragraph><p>もしシリアルポートを有効にしたいのであれば以下の変更を行なって 新しいカーネルを作る必要があります。 <span class=filename>/usr/src/sys/i386/isa/sio.c</span> の中で 1 ヵ所ある <code>0x2e8</code> という文字列を探し、 この文字列とその手前にあるコンマを削除します (後ろのコンマは残します)。 後は通常の手続きにしたがって新しいカーネルを作ります。</p></div><div class=paragraph><p>この対処を行なった後でもまだ X ウィンドウシステムはうまく動かないかもしれません。 その場合は、 使用している XFree86 がすくなくとも XFree86 3.3.3 以降であることを確かめてください。 それ以降のバージョンでは、 Mach64 カードやそれらのカードのためにつくられた X サーバ の組込みをサポートします。</p></div></div><div class=sect2><h3 id=_128mb_の_ram_があるのですが64mb_しか認識しません>3.12. 128MB の RAM があるのですが、64MB しか認識しません。<a class=anchor href=#_128mb_の_ram_があるのですが64mb_しか認識しません></a></h3><div class=paragraph><p>FreeBSD がメモリのサイズを BIOS から取得する方法の制限により、 KB 単位で 16 ビット分までしか検出できません (すなわち最大 65535KB=64MB です。これより少ない場合もあります。 ある BIOS の場合はメモリサイズが 16MB に制限されます)。 64MB 以上のメモリを積んでいる場合、 FreeBSD はそれを検出しようとします。 しかしその試みは失敗するかもしれません。</p></div><div class=paragraph><p>この問題を回避するには、 以下に示すカーネルオプションを使用する必要があります。 完全なメモリ情報を BIOS から取得する方法もありますが、 起動ブロックに空きが無いため実装できません。 起動ブロックの問題が解決されれば、 いつか拡張 BIOS 機能を使用して完全なメモリ情報を取得できるようになるでしょう。 とりあえず現在は、カーネルオプションを使ってください。</p></div><div class=paragraph><p><code>options "MAXMEM=n"</code></p></div><div class=paragraph><p><em>n</em> には、 キロバイト単位でメモリの量を指定します。128MB の場合は、<code>131072</code> となります。</p></div></div><div class=sect2><h3 id=_freebsd_2_0_が_kmem_map_too_small_と言ってパニックします>3.13. FreeBSD 2.0 が kmem_map too small! と言ってパニックします。<a class=anchor href=#_freebsd_2_0_が_kmem_map_too_small_と言ってパニックします></a></h3><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>メッセージは、<code>mb_map too small!</code> の場合もあります。</p></div></td></tr></tbody></table></div><div class=paragraph><p>このパニックは、ネットワークバッファ (特に mbuf クラスタ) の仮想メモリが無くなったことを示します。 以下のオプションをカーネルコンフィグファイルに追加して mbuf クラスタに使用できる仮想メモリの量を増やしてください。</p></div><div class=paragraph><p><code>options "NMBCLUSTERS=n"</code></p></div><div class=paragraph><p><em>n</em> には、 同時に使用したい TCP コネクションの数に応じて 512 から 4096 までの数値を指定できます。 とりあえず 2048 を試してみるのをおすすめします。 これでパニックは完全の予防できるはずです。 mbuf クラスタの割り当て、使用状況については、 <code>netstat -m</code> で知ることができます (<a href="https://man.freebsd.org/cgi/man.cgi?query=netstat&amp;sektion=1&amp;format=html">netstat(1)</a> をご覧ください)。 <code>NMBCLUSTERS</code> のデフォルト値は <code>512 + MAXUSERS * 16</code> です。</p></div></div><div class=sect2><h3 id=_新しいカーネルで再起動すると_cmap_busy_panic_となってパニックを起こしてしまいます>3.14. 新しいカーネルで再起動すると CMAP busy panic となってパニックを起こしてしまいます。<a class=anchor href=#_新しいカーネルで再起動すると_cmap_busy_panic_となってパニックを起こしてしまいます></a></h3><div class=paragraph><p>ファイル <span class=filename>/var/db/kvm_*.db</span> において範囲外のデータを検出するためのロジックは失敗することがあり、 こうした矛盾のあるファイルを使用することでパニックを引き起こすことがあります。</p></div><div class=paragraph><p>これが起こったなら、シングルユーザで再起動した後に、 以下のコマンドを実行してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># rm /var/db/kvm_*.db</span></code></pre></div></div></div><div class=sect2><h3 id=_ahc0_brkadrint_illegal_host_access_at_seqaddr_0x0_というエラーが出ます>3.15. ahc0: brkadrint, Illegal Host Access at seqaddr 0x0 というエラーが出ます<a class=anchor href=#_ahc0_brkadrint_illegal_host_access_at_seqaddr_0x0_というエラーが出ます></a></h3><div class=paragraph><p>これは Ultrastor SCSI Host Adapter と衝突しています。</p></div><div class=paragraph><p>起動時に kernel configuration メニューに入り、 問題を起こしている <span class=filename>uha0</span> を disable にしましょう。</p></div></div><div class=sect2><h3 id=_sendmail_が_mail_loops_back_to_myself_というメッセージを出すのですが>3.16. sendmail が mail loops back to myself というメッセージを出すのですが。<a class=anchor href=#_sendmail_が_mail_loops_back_to_myself_というメッセージを出すのですが></a></h3><div class=paragraph><p>この事は、sendmail FAQ に次のように書いてあります。</p></div><div class=literalblock><div class=content><pre>      * &#34;Local configuration error&#34; というメッセージが出ます。たとえば:

      553 relay.domain.net config error: mail loops back to myself
      554 &lt;user@domain.net&gt;... Local configuration error

      のような物ですが、どのようにしたらこの問題を解決できますか?

      これは、たとえば domain.net のようなドメイン宛てのメールを MX record で
      特定のホスト (ここでは relay.domain.net) に送ろうとしたのに、
      そのホストでは domain.net 宛てのメールを受け取れるような設定に
      なっていない場合です。設定の際に FEATURE(use_cw_file) を
      指定してある場合には /etc/sendmail.cw の中に domain.net を
      追加してください。もしくは、/etc/sendmail.cf の中に
      &#34;Cw domain.net&#34; を追加してください。</pre></div></div><div class=paragraph><p>もはや現在の <a href=ftp://rtfm.mit.edu/pub/usenet/news.answers/mail/sendmail-faq>sendmail FAQ</a> は sendmail release とは一緒には保守されていません。 しかし次のネットニュースに定期的に投稿されてます。 <a href=news:comp.mail.sendmail>comp.mail.sendmail</a>、 <a href=news:comp.mail.misc>comp.mail.misc</a>、 <a href=news:comp.mail.smail>comp.mail.smail</a>、 <a href=news:comp.answers>comp.answers</a>、 <a href=news:news.answers>news.answers</a>。 また、メール経由でコピーを入手する場合は <a href=mailto:mail-server@rtfm.mit.edu>mail-server@rtfm.mit.edu</a> 宛まで本文に <code>send usenet/news.answers/mail/sendmail-faq</code> と書いて送ります。</p></div></div><div class=sect2><h3 id=_リモートマシン上のフルスクリーンアプリケーションがうまく動かない>3.17. リモートマシン上のフルスクリーンアプリケーションがうまく動かない<a class=anchor href=#_リモートマシン上のフルスクリーンアプリケーションがうまく動かない></a></h3><div class=paragraph><p>リモートマシンのターミナルタイプが FreeBSD のコンソールで必要とされている <code>cons25</code> 以外のものです。</p></div><div class=paragraph><p>この問題を解決しうる方法はいろいろあります:</p></div><div class=ulist><ul><li><p>リモートマシンにログインした後、 そのリモートマシンが <code>ansi</code> か <code>sco</code> のターミナルタイプを知っているなら、 shell 変数の TERM にそれらのいずれかを設定します。</p></li><li><p>FreeBSD のコンソール側で screen のような VT100 エミュレータを使用します。 screen は一つのターミナルの中で複数のセッションを並列動作させることができますし、 本来の機能も優れています。 各々の screen のウィンドウは VT100 ターミナルのように振る舞うので、 リモート側で設定されるべき TERM 変数は <code>vt100</code> となります。</p></li><li><p>リモートマシンのターミナルデータベースに <code>cons25</code> のエントリをインストールします。 このインストール方法はリモートマシンのオペレーティングシステムに依存します。 リモートのシステムのシステム管理マニュアルが役に立つことでしょう。</p></li><li><p>FreeBSD 側で X サーバを起動して、 リモートマシンに <code>xterm</code> や <code>rxvt</code> のような X ベースのターミナルエミュレータを使ってログインします。 (訳注: 日本語が必要な場合は <code>kterm</code> 等を 利用します) リモートホストの TERM 変数は <code>xterm</code> もしくは <code>vt100</code> (訳注: もしくは <code>kterm</code>) に設定します。</p></li></ul></div></div><div class=sect2><h3 id=_私のマシンで_calcru_negative_time_と表示されるのですが>3.18. 私のマシンで calcru: negative time…​ と表示されるのですが<a class=anchor href=#_私のマシンで_calcru_negative_time_と表示されるのですが></a></h3><div class=paragraph><p>これは、割り込みに関連するさまざまな不具合によって発生します。 あるいは、あるデバイスが元々持っているバグが表面化したのかも知れません。 この症状を再現させる一つの方法として、パラレルポート上で、 TCP/IP を 大きな MTU で走らせるというものがあります。 グラフィックアクセラレータがこの症状を起こすことがありますが、 その場合はまず、カードの割り込み設定を確認してください。</p></div><div class=paragraph><p>この問題の副作用として、 プロセスが "SIGXCPU exceeded cpu time limit" というメッセージとともに終了してしまう、というものがあります。</p></div><div class=paragraph><p>1998 年 11 月 29 日に公開された FreeBSD 3.0 以降で この問題が解決しないなら、次の sysctl 変数をセットしてください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl -w kern.timecounter.method=1</span></code></pre></div></div><div class=paragraph><p>これは、パフォーマンスへ強い影響を与えますが、 問題の発生に比べればおそらく気にならない程度でしょう。 もし、これでもまだ問題が残るようなら、 カーネルオプションの <code>NTIMECOUNTER</code> を大きな値に増やしてください。 <code>NTIMECOUNTER=20</code> にまで増やしても解決しない場合は、 計時処理の信頼性が保てない程の割り込みが、 そのマシン上で起こっていることを意味します。</p></div></div><div class=sect2><h3 id=_pcm0_not_found_という表示を見たり_カーネルコンフィグレーションファイルには_device_pcm0_と_書いてあるのにサウンドカードが_pcm1_として_発見されたりします>3.19. pcm0 not found という表示を見たり カーネルコンフィグレーションファイルには device pcm0 と 書いてあるのにサウンドカードが pcm1 として 発見されたりします。<a class=anchor href=#_pcm0_not_found_という表示を見たり_カーネルコンフィグレーションファイルには_device_pcm0_と_書いてあるのにサウンドカードが_pcm1_として_発見されたりします></a></h3><div class=paragraph><p>これは FreeBSD 3.x で PCI のサウンドカードを使っているときに 発生します。<code>pcm0</code> デバイスは ISA のカード専用に予約されているものです。このため、 あなたが PCI カードを持っているときはこのエラーが表示され、 カードは <code>pcm1</code> として検出されます。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>この警告を、単にカーネルコンフィグファイルの当該行を <code>device pcm1</code> に変更することで 抑制することはできません。その時は <code>pcm1</code> が ISA カードのために予約され、PCI のカードは <code>pcm2</code> として (<code>pcm1 not found</code> の警告とともに) 検出されます。</p></div></td></tr></tbody></table></div><div class=paragraph><p>PCI のサウンドカードを持っているのならば、以下のようにして <code>snd0</code> デバイスのかわりに <code>snd1</code> を作る必要があります。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /dev</span>
<span class=c># ./MAKEDEV snd1</span></code></pre></div></div><div class=paragraph><p>この状況は FreeBSD 4.x では生じません。多くの努力の結果より <em>PnP 中心</em>に作り替えられ、 現在、<code>pcm0</code> デバイスは ISA カード専用に予約されたものではなくなりました。</p></div></div><div class=sect2><h3 id=_プラグアンドプレイのカードが認識されなくなりました_またはunknown_と認識されるようになりました>3.20. プラグアンドプレイのカードが認識されなくなりました (または、unknown と認識されるようになりました)。<a class=anchor href=#_プラグアンドプレイのカードが認識されなくなりました_またはunknown_と認識されるようになりました></a></h3><div class=paragraph><p>現在の FreeBSD 4.x はより <em>PnP 中心</em>に なっています。その副作用の影響で、FreeBSD 3.x で動いていた PnP デバイス (たとえばサウンドカードや内蔵モデム) の中には、 動かなくなってしまったものもあります。</p></div><div class=paragraph><p>この挙動の原因は Peter Wemm が freebsd-questions メーリングリストに書いた、以下の 「FreeBSD 4.x にアップグレードしたところ内蔵モデムが 見つからなくなった」というメールで解説されています。 (わかりやすくするために <code>[]</code> 内に コメントを加えました)。</p></div><div class=paragraph><p>PnP BIOS はあらかじめ、[モデムを] ポート空間に存在しているかのように設定します。 そのため [3.x では] 従来の手法に基づく ISA デバイスの検索により、モデムの存在を「発見」できます。</p></div><div class=paragraph><p>4.0 の ISA コードは、より PnP 中心になっています。 [3.x では] ISA デバイスの検索が「はぐれた」デバイスを発見して、 次に PNP デバイス ID のマッチが行なわれることでリソースの競合が発生し、 デバイスの検索に失敗する可能性があります。 したがって、4.0 の ISA コードでは 二重に検索しないよう、プログラマブルなカードを 最初に無効にしています。 これは、対応している PnP ハードウェアの PnP ID が、 予めわかっている必要がある、ということを意味します。 ユーザがこの挙動にもっと手を入れられるようにすることが TODO リスト中にあげられています。</p></div><div class=paragraph><p>3.0 で動作していたデバイスを 4.0 でも動作するようにするには、 それの PnP ID を調べ、ISA デバイスの検索が PnP デバイスの識別に使っているリストにそれを追加する必要があります。 デバイスの検索に使われる <a href="https://man.freebsd.org/cgi/man.cgi?query=pnpinfo&amp;sektion=8&amp;format=html">pnpinfo(8)</a> を用いて、 PnP ID を得ることができます。 たとえば、内蔵モデムに関する <a href="https://man.freebsd.org/cgi/man.cgi?query=pnpinfo&amp;sektion=8&amp;format=html">pnpinfo(8)</a> の出力は、 以下のようになります。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pnpinfo</span>
Checking <span class=k>for </span>Plug-n-Play devices...

Card assigned CSN <span class=c>#1</span>
Vendor ID PMC2430 <span class=o>(</span>0x3024a341<span class=o>)</span>, Serial Number 0xffffffff
PnP Version 1.0, Vendor Version 0
Device Description: Pace 56 Voice Internal Plug &amp; Play Modem

Logical Device ID: PMC2430 0x3024a341 <span class=c>#0</span>
        Device supports I/O Range Check
TAG Start DF
    I/O Range 0x3f8 .. 0x3f8, alignment 0x8, len 0x8
        <span class=o>[</span>16-bit addr]
    IRQ: 4  - only one <span class=nb>type</span> <span class=o>(</span><span class=nb>true</span>/edge<span class=o>)</span></code></pre></div></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>TAG End DF
End Tag

Successfully got 31 resources, 1 logical fdevs
<span class=nt>--</span> card <span class=k>select</span> <span class=c># 0x0001</span>

CSN PMC2430 <span class=o>(</span>0x3024a341<span class=o>)</span>, Serial Number 0xffffffff

Logical device <span class=c>#0</span>
IO:  0x03e8 0x03e8 0x03e8 0x03e8 0x03e8 0x03e8 0x03e8 0x03e8
IRQ 5 0
DMA 4 0
IO range check 0x00 activate 0x01</code></pre></div></div><div class=paragraph><p>必要な情報は、出力の冒頭にある "Vendor ID" 行にあります。 かっこの中の 16 進数 (例の中では 0x3024a341) が PnP ID で、 直前の文字列 (PMC2430) はユニークな ASCII ID です。 この情報はファイル <span class=filename>/usr/src/sys/isa/sio.c</span> に 追加する必要があります。</p></div><div class=paragraph><p>まず失敗したときに備えて <span class=filename>sio.c</span> の バックアップを取るべきです。障害報告を送るために修正パッチを 作る時にも必要になるでしょう (send-pr しようとしていますよね?)。 <span class=filename>sio.c</span> を編集して以下の行を探してください。</p></div><div class="literalblock programlisting"><div class=content><pre>static struct isa_pnp_id sio_ids[] = {</pre></div></div><div class=paragraph><p>そしてあなたのデバイスのエントリを追加する正しい場所を探します。 エントリは以下のような形をしていて、<a href="https://man.freebsd.org/cgi/man.cgi?query=pnpinfo&amp;sektion=8&amp;format=html">pnpinfo(8)</a> の 出力にある <em>デバイスの説明</em>の全部 (もし収まれば) か一部とともに行の右の方のコメント領域に書かれている ASCII ベンダ ID でソートされています。</p></div><div class="literalblock programlisting"><div class=content><pre>{0x0f804f3f, NULL},     /* OZO800f - Zoom 2812 (56k Modem) */
{0x39804f3f, NULL},     /* OZO8039 - Zoom 56k flex */
{0x3024a341, NULL},     /* PMC2430 - Pace 56 Voice Internal Modem */
{0x1000eb49, NULL},     /* ROK0010 - Rockwell ? */
{0x5002734a, NULL},     /* RSS0250 - 5614Jx3(G) Internal Modem */</pre></div></div><div class=paragraph><p>あなたのデバイスの16進数のベンダ ID を正しい場所に 追加し、ファイルをセーブしてカーネルを作り直して再起動します。 あなたのデバイスは FreeBSD 3.x の時と同じように <code>sio</code> として見つかるようになっているはずです。</p></div></div><div class=sect2><h3 id=_top_や_systat_の_実行中に_nlist_failed_という_エラーがでます>3.21. top や systat の 実行中に nlist failed という エラーがでます。<a class=anchor href=#_top_や_systat_の_実行中に_nlist_failed_という_エラーがでます></a></h3><div class=paragraph><p>このエラーは、 実行しようとしたアプリケーションが あるカーネルシンボルを検索した結果、 何らかの理由でその検索に失敗した、ということを意味しています。 これは、以下に示すいずれかの理由によるものです。</p></div><div class=ulist><ul><li><p>カーネルとユーザランドが同期していない (つまり カーネルは新しいものを構築したが、 <code>installworld</code> は行なっていない。 あるいはその逆) ので、 シンボルテーブルがユーザアプリケーションの考えているものと異なっている。 もしこのケースなら、一連のアップグレード手順に従ってアップグレードを行なってください (正しいやり方は <span class=filename>/usr/src/UPDATING</span> に書いてあります)。</p></li><li><p>カーネルをロードするのに <code>/boot/loader</code> を使わず、 直接 boot2 (<a href="https://man.freebsd.org/cgi/man.cgi?query=boot&amp;sektion=8&amp;format=html">boot(8)</a> 参照) からロードしている。 もちろん <code>/boot/loader</code> を使わなくとも問題はないのですが、 <code>/boot/loader</code> は一般的に、 ユーザアプリケーションからカーネルシンボルを アクセスできるようにするための機能を持っています。</p></li></ul></div></div><div class=sect2><h3 id=_ssh1_や_telnet1_でコンピュータに接続する_のにどうしてこんなに時間がかかるのですか>3.22. <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh&amp;sektion=1&amp;format=html">ssh(1)</a> や <a href="https://man.freebsd.org/cgi/man.cgi?query=telnet&amp;sektion=1&amp;format=html">telnet(1)</a> でコンピュータに接続する のに、どうしてこんなに時間がかかるのですか?<a class=anchor href=#_ssh1_や_telnet1_でコンピュータに接続する_のにどうしてこんなに時間がかかるのですか></a></h3><div class=paragraph><p>症状: TCP コネクションが確立してから、 クライアントソフトウェアがパスワードを尋ねてくるまで (<a href="https://man.freebsd.org/cgi/man.cgi?query=telnet&amp;sektion=1&amp;format=html">telnet(1)</a> の場合は、ログインプロンプトが表示されるまで) に長い時間がかかる、というもの。</p></div><div class=paragraph><p>問題: おそらく、サーバソフトウェアがクライアントの IP アドレスからホスト名を解決しようとして、遅れが生じている のでしょう。FreeBSD に付属する SSH や Telnet を含む多くの サーバソフトウェアは、この名前解決をおこないます。これは、 管理者が後日参照するログファイルに、その他の情報と一緒に ホスト名を記録できるようにするのが目的です。</p></div><div class=paragraph><p>対処法: もし、あなたのコンピュータ (クライアント) からどのサーバに接続する場合にも問題が起こるのであれば、 クライアントに問題があります。そして、誰かがあなたの コンピュータ (サーバ) に接続するときだけ問題が起こるのであれば、 そのサーバの問題です。</p></div><div class=paragraph><p>問題がクライアントにある場合、唯一の対処法は サーバがそのクライアントの名前を解決できるように DNS を修正することです。 症状がローカルネットワークで発生しているなら、サーバの設定に 原因がありますので、このまま続きを読みましょう。 そうではなく、グローバルなインターネット環境で発生しているなら、 ISP に連絡して問題の修正をお願いしなければならない可能性が高いでしょう。</p></div><div class=paragraph><p>問題がサーバにあって、症状がローカルネットワークで 発生しているなら、ローカルのアドレス範囲にあるアドレスを、 それに対応するホスト名に解決する問合せを処理できるように、 サーバを設定する必要があります。 詳しくは、<a href="https://man.freebsd.org/cgi/man.cgi?query=hosts&amp;sektion=5&amp;format=html">hosts(5)</a> および <a href="https://man.freebsd.org/cgi/man.cgi?query=named&amp;sektion=8&amp;format=html">named(8)</a> のマニュアルをご覧ください。グローバルなインターネット環境の場合は、 サーバのリゾルバが正しく動作していないのが原因かもしれません。 確認するには、他のホスト (たとえば <code>www.yahoo.com</code>) を引いてみてください。 うまくいかなければ、あなたのコンピュータの問題です。</p></div></div><div class=sect2><h3 id=_file_table_is_full_という_メッセージが繰り返し_dmesg_にあらわれます>3.23. file: table is full という メッセージが繰り返し dmesg にあらわれます。<a class=anchor href=#_file_table_is_full_という_メッセージが繰り返し_dmesg_にあらわれます></a></h3><div class=paragraph><p>このエラーは、システムのファイル記述子を使い果たして しまった時に発生します。メモリ中のファイルテーブルが一杯に なっているのです。</p></div><div class=paragraph><p>解決法:</p></div><div class=paragraph><p>手動で sysctl 変数 <code>kern.maxfiles</code> の限界値を調整します。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl -w kern.maxfiles=n</span></code></pre></div></div><div class=paragraph><p><code>n</code> は、システム要件に合わせてください。 オープンされたファイル、ソケットまたは fifo のそれぞれが ファイル記述子を消費します。規模の大きなサーバは、 同時に実行されるサービスに応じて、いともたやすく何万もの ファイル記述子を要求します。</p></div><div class=paragraph><p>カーネルに設定されたデフォルトのファイル記述子の 数を決定するのは、次の</p></div><div class="literalblock programlisting"><div class=content><pre>maxusers        32</pre></div></div><div class=paragraph><p>カーネル設定ファイルの <code>maxusers</code> 行 です。<code>kern.maxfiles</code> はこの値に比例して 増加します。</p></div><div class=paragraph><p>現在設定されている <code>kern.maxfiles</code> の 値は、次のコマンドで調べることができます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl kern.maxfiles</span>
kern.maxfiles: 1064</code></pre></div></div></div><div class=sect2><h3 id=_laptop_の時間が狂って大きく進んだり遅れたりします>3.24. laptop の時間が狂って、大きく進んだり遅れたりします。<a class=anchor href=#_laptop_の時間が狂って大きく進んだり遅れたりします></a></h3><div class=paragraph><p>laptop には二つ以上の時計が内蔵されていますが、FreeBSD が間違った方を選択して使用しています。</p></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=dmesg&amp;sektion=8&amp;format=html">dmesg(8)</a> を実行して <code>Timecounter</code> を含む行を確認してください。 最後に出力された行が FreeBSD が選択したもので、まず間違い なく <code>TSC</code> でしょう。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dmesg | grep Timecounter</span>
Timecounter <span class=s2>&#34;i8254&#34;</span>  frequency 1193182 Hz
Timecounter <span class=s2>&#34;TSC&#34;</span>  frequency 595573479 Hz</code></pre></div></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=3&amp;format=html">sysctl(3)</a> 変数 <code>kern.timecounter.hardware</code> を確認すれば 裏付けがとれます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl kern.timecounter.hardware</span>
kern.timecounter.hardware: TSC</code></pre></div></div><div class=paragraph><p>バッテリ駆動している時に、BIOS が CPU の速度を変えるために TSC クロックを変更したり、電力節約モードに入ることがあります。 しかし、FreeBSD はそういった調整を関知しないので、 時間が早まったり遅れたりするようです。</p></div><div class=paragraph><p>上記の例では、<code>i8254</code> クロックも利用できます。 <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=3&amp;format=html">sysctl(3)</a> 変数 <code>kern.timecounter.hardware</code> にその名称を書き込んで選択できます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl -w kern.timecounter.hardware=i8254</span>
kern.timecounter.hardware: TSC -&gt; i8254</code></pre></div></div><div class=paragraph><p>これで、laptop はより正確な時間を刻むでしょう。</p></div><div class=paragraph><p>この変更を起動時に自動で行うには、次の行を <span class=filename>/etc/sysctl.conf</span> に追加してください。</p></div><div class="literalblock programlisting"><div class=content><pre>kern.timecounter.hardware=i8254</pre></div></div></div><div class=sect2><h3 id=_bios_画面が出た後freebsd_のブートローダが_read_error_と表示して止まって_しまいます>3.25. BIOS 画面が出た後、FreeBSD のブートローダが Read error と表示して止まって しまいます。<a class=anchor href=#_bios_画面が出た後freebsd_のブートローダが_read_error_と表示して止まって_しまいます></a></h3><div class=paragraph><p>FreeBSD のブートローダがハードディスクのジオメトリを正しく 認識していないようです。FreeBSD のスライスを fdisk によって手動で作成したり変更したりする際に、 ジオメトリを誤って指定してしまったのでしょう。</p></div><div class=paragraph><p>ハードディスクのジオメトリの正しい値は、マシンの BIOS から 得られます。そのハードディスクのシリンダ、ヘッド、セクタの 数を探してください。</p></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=sysinstall&amp;sektion=8&amp;format=html">sysinstall(8)</a> の fdisk において、 <kbd>G</kbd> を入力してハードディスクのジオメトリを 設定してください。</p></div><div class=paragraph><p>シリンダ、ヘッド、セクタの数を入力するダイアログが出てきます。 BIOS から得た値を斜線 (/) で区切って入力してください。</p></div><div class=paragraph><p>5000 シリンダ、250 ヘッド、60 セクタなら、 <code>5000/250/60</code> と入力します。</p></div><div class=paragraph><p>リターンキーを押して値を設定してください。それから <kbd>W</kbd> を入力してハードディスクに新しいパーティ ションテーブルを書き込んでください。</p></div></div><div class=sect2><h3 id=_別のオペレーティングシステムがブートマネージャを_壊してしまいましたどうすれば復旧できるでしょうか>3.26. 別のオペレーティングシステムが、ブートマネージャを 壊してしまいました。どうすれば復旧できるでしょうか。<a class=anchor href=#_別のオペレーティングシステムがブートマネージャを_壊してしまいましたどうすれば復旧できるでしょうか></a></h3><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=sysinstall&amp;sektion=8&amp;format=html">sysinstall(8)</a> を立ち上げて Configure (設定)、Fdisk の順に選択してください。ブートマネージャが置かれていた ディスクを選択して、<kbd>スペース</kbd>キーを 押してください。<kbd>W</kbd> を押して変更を ディスクに書き込んでください。どのブートローダを インストールするか尋ねられます。ここで選択すれば戻せます。</p></div></div></div></div><div class=sect1><h2 id=_商用アプリケーション>4. 商用アプリケーション<a class=anchor href=#_商用アプリケーション></a></h2><div class=sectionbody><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>この章はまだまだ情報が足りません。 情報を追加してくれるような企業を待ち望んでいます。 FreeBSD グループはここに載っている企業からの金銭的な支援を期待してはいませんので、 奉仕作業の一つとして掲載しています (そして FreeBSD が係わる宣伝は、長い目で見ると FreeBSD に対してよい方向へ働くと思っています)。 私たちは商用ソフトウェアベンダに、 ここで製品を宣伝してもらうことを望んでいます。詳しくは、 <a href=http://www.FreeBSD.org/commercial/commercial/>商用ソフトウェアベンダ覧のページ</a>をご覧ください。</p></div></td></tr></tbody></table></div><div class=sect2><h3 id=_freebsd_用のオフィススイートはどこで入手できますか>4.1. FreeBSD 用のオフィススイートはどこで入手できますか?<a class=anchor href=#_freebsd_用のオフィススイートはどこで入手できますか></a></h3><div class=ulist><ul><li><p><a href=http://www.wccdrom.com>BSDi</a> は FreeBSD ネイティブ版の <a href=http://www.vistasource.com>VistaSource</a> ApplixWare 5 を提供しています。</p><div class=paragraph><p>ApplixWare は、豪華で機能満載の FreeBSD 向けの 商用オフィススイートで、ワードプロセッサ、表計算、 プレゼンテーションソフトウェア、ベクタ描画ソフトウェア、 その他のアプリケーションを揃えています。</p></div><div class=paragraph><p>FreeBSD 版の ApplixWare の購入は <a href=http://www.wccdrom.com/titles/freebsd/applix.phtml>こちら</a>からどうぞ。</p></div></li><li><p>Linux 版の <a href=http://www.sun.com/staroffice>StarOffice</a> は FreeBSD で完璧に動作します。Linux 版の StarOffice をインストールするもっとも簡単な方法は、<a href=https://docs.freebsd.org/ja/books/handbook/ports#ports>FreeBSD Ports コレクション</a>を利用することです。 また、オープンソースの <a href=http://www.openoffice.org>OpenOffice</a> も将来のバージョンで動作するでしょう。</p></li></ul></div></div><div class=sect2><h3 id=_freebsd_用の_motif_はどうやったら手に入りますか>4.2. FreeBSD 用の Motif はどうやったら手に入りますか<a class=anchor href=#_freebsd_用の_motif_はどうやったら手に入りますか></a></h3><div class=paragraph><p>FreeBSD 用の廉価版 ELF Motif 2.1.20 (i386 版、Alpha 版) に関する情報は<a href=#apps2go>Apps2go</a> から 手に入れることができます。<a id=apps2go></a></p></div><div class=paragraph><p>この製品には、「開発者版 (development edition)」 と、 より安価な「ランタイム版 (runtime edition)」 の二つの版があります。これらの製品は以下の物が含まれています。</p></div><div class=ulist><ul><li><p>OSF/Motif manager、xmbind、panner、wsm。</p></li><li><p>uil、mrm、xm、xmcxx、インクルードファイルや Imake ファイルといった開発者向けキット</p></li><li><p>FreeBSD 3.0 以降で利用できる ELF 版スタティックライブラリ、 およびダイナミックライブラリ</p></li><li><p>デモンストレーションプログラム</p></li></ul></div><div class=paragraph><p>注文する際には FreeBSD 用の Motif であることをきちんと 確認してください (あなたの欲しいアーキテクチャを指定するのも 忘れないでください!)。NetBSD や OpenBSD 用の Motif もまた、 <em>Apps2go</em>から販売されています。現在、FTP による ダウンロードのみ利用可能です。</p></div><div class=dlist><dl><dt class=hdlist1>より詳しい情報は</dt><dd><p><a href=http://www.apps2go.com/>Apps2go WWW page</a></p></dd><dt class=hdlist1>問い合わせは</dt><dd><p><a href=mailto:sales@apps2go.com>Sales</a> または <a href=mailto:support@apps2go.com>Support</a> 電子メールアドレス。</p></dd><dt class=hdlist1>もしくは</dt><dd><p>phone (817) 431 8775 or +1 817 431-8775</p></dd></dl></div><div class=paragraph><p>他の FreeBSD 用 Motif 2.1 (ELF 版、a.out 版) に関する情報は <a href=#metrox>Metro Link</a> から手に入れることができます。</p></div><div class=paragraph><p>この製品は以下の物が含まれています。</p></div><div class=ulist><ul><li><p>OSF/Motif manager、xmbind、panner、wsm。</p></li><li><p>uil、mrm、xm、xmcxx、インクルードファイルや Imake ファイルといった開発者向けキット</p></li><li><p>スタティックライブラリ、およびダイナミックライブラリ。 (FreeBSD 3.0 以降で利用できる ELF 版か、 FreeBSD 2.2.8 以前で利用できる a.out 版を指定してください)</p></li><li><p>デモンストレーションプログラム</p></li><li><p>整形済みのマニュアルページ</p></li></ul></div><div class=paragraph><p>注文する際には FreeBSD 用の Motif であることをきちんと 確認してください。Linux 用の Motif も <em>Metro Link</em> から販売されています。現在、CDROM および FTP によるダウンロードが利用可能です。</p></div><div class=paragraph><p>FreeBSD 用の a.out 版 Motif 2.0 に関する情報は <a href=#xig>Xi Graphics</a> から 手に入れることができます。</p></div><div class=paragraph><p>この製品には以下の物が含まれています。</p></div><div class=ulist><ul><li><p>OSF/Motif manager、xmbind、panner、wsm。</p></li><li><p>uil、mrm、xm、xmcxx、インクルードファイルや Imake ファイルといった開発者向けキット</p></li><li><p>FreeBSD 2.2.8 以前のバージョンで利用できるスタティックライブラリ、 およびダイナミックライブラリ</p></li><li><p>デモンストレーションプログラム</p></li><li><p>整形済みのマニュアルページ</p></li></ul></div><div class=paragraph><p>注文する際には FreeBSD 用の Motif であることをきちんと 確認してください。BSDI や Linux 用の Motif もまた、<em>Xi Graphics</em> から販売されています。現在フロッピーディスク 4枚組ですが、 将来的には CDE のように統合された CD に変わるでしょう。</p></div></div><div class=sect2><h3 id=_freebsd_用の_cde_はどうやったら手に入りますか>4.3. FreeBSD 用の CDE はどうやったら手に入りますか<a class=anchor href=#_freebsd_用の_cde_はどうやったら手に入りますか></a></h3><div class=paragraph><p>以前 <a href=#xig>Xi Graphics</a> より FreeBSD 用の CDE が 販売されていましたが、現在は既に販売が終了しています。</p></div><div class=paragraph><p><a href=http://www.kde.org/>KDE</a> 多くの点で CDE と類似しているオープンソースの X11 デスクトップ環境です。 <a href=http://www.xfce.org/>xfce</a> の ルック & フィール (訳注: 外観や操作方法のこと) も気に入るかも知れません。 KDE、xfce は、いずれも <a href=http://www.FreeBSD.org/ports/>FreeBSD Ports Collection</a> に含まれています。</p></div></div><div class=sect2><h3 id=_高機能な商用_x_サーバってあるんですか>4.4. 高機能な商用 X サーバってあるんですか?<a class=anchor href=#_高機能な商用_x_サーバってあるんですか></a></h3><div class=paragraph><p>はい、<a href=http://www.xig.com/>Xi Graphics</a> と <a href=http://www.metrolink.com/>Metro Link</a> から、FreeBSD ほか Intel ベースのシステムで動作する Accelerated-X という製品が販売されています。</p></div><div class=paragraph><p>Metro Link は、FreeBSD のパッケージ操作ツールを利用することで 容易に設定が行なえるほか、数多くのビデオボードをサポートした 高機能な X サーバを提供しています。配布はバイナリ形式のみで、 FTP が利用可能です。もちろん、とても安価 ($39) に手に入れることができます。 <a id=metrox></a></p></div><div class=paragraph><p>また、Metro Link は ELF 版、a.out 版の FreeBSD 用 Motif も販売しています (前を参照)。</p></div><div class=dlist><dl><dt class=hdlist1>より詳しい情報は</dt><dd><p><a href=http://www.metrolink.com/>Metro Link WWW page</a></p></dd><dt class=hdlist1>問い合わせは</dt><dd><p><a href=mailto:sales@metrolink.com>Sales</a> または <a href=mailto:tech@metrolink.com>Support</a> 電子メールアドレス</p></dd><dt class=hdlist1>もしくは</dt><dd><p>phone (954) 938-0283 or +1 954 938-0283</p></dd></dl></div><div class=paragraph><p>Xi Graphics が提供している高性能な X サーバは楽に設定を行なえるほか、 数多くのビデオボード をサポートしています。サーバはバイナリのみが含まれます。 FreeBSD 用と Linux 用の統合されたフロッピーディスクに入っています。 Xi Graphics は Laptop サポートに特化した高性能 X サーバも提供しています。 <a id=xig></a></p></div><div class=paragraph><p>バージョン 5.0 の「互換デモ」が無料で入手できます。</p></div><div class=paragraph><p>また Xi Graphics は FreeBSD 用の Motif と CDE も販売しています (前を参照)。</p></div><div class=dlist><dl><dt class=hdlist1>より詳しい情報は</dt><dd><p><a href=http://www.xig.com/>Xi Graphics WWW page</a></p></dd><dt class=hdlist1>問い合せは</dt><dd><p><a href=mailto:sales@xig.com>Sales</a> または <a href=mailto:support@xig.com>Support</a></p></dd><dt class=hdlist1>もしくは</dt><dd><p>phone (800) 946 7433 or +1 303 298-7478.</p></dd></dl></div></div><div class=sect2><h3 id=_freebsd_用のデータベースシステムはありますか>4.5. FreeBSD 用のデータベースシステムはありますか?<a class=anchor href=#_freebsd_用のデータベースシステムはありますか></a></h3><div class=paragraph><p>もちろんです。FreeBSD のウェブサイトにある <a href=http://www.FreeBSD.org/commercial/software_bycat/#CATEGORY_DATABASE>商用ベンダー</a> というセクションをご覧ください。</p></div><div class=paragraph><p>また、FreeBSD Ports Collection の<a href=http://www.FreeBSD.org/ports/>データベース</a>のセクションも参考になるでしょう。</p></div></div><div class=sect2><h3 id=_oracle_を_freebsd_上で動かすことはできますか>4.6. Oracle を FreeBSD 上で動かすことはできますか?<a class=anchor href=#_oracle_を_freebsd_上で動かすことはできますか></a></h3><div class=paragraph><p>はい。Linux 版 Oracle を FreeBSD でセットアップするための方法は、 次に示すページに詳しく書かれています。</p></div><div class=ulist><ul><li><p><a href=http://www.scc.nl/~marcel/howto-oracle.html>http://www.scc.nl/~marcel/howto-oracle.html</a></p></li><li><p><a href=http://www.lf.net/lf/pi/oracle/install-linux-oracle-on-freebsd>http://www.lf.net/lf/pi/oracle/install-linux-oracle-on-freebsd</a></p></li></ul></div></div></div></div><div class=sect1><h2 id=_ユーザアプリケーション>5. ユーザアプリケーション<a class=anchor href=#_ユーザアプリケーション></a></h2><div class=sectionbody><div class=sect2><h3 id=_そういうユーザアプリケーションはどこにあるの>5.1. そういうユーザアプリケーションはどこにあるの?<a class=anchor href=#_そういうユーザアプリケーションはどこにあるの></a></h3><div class=paragraph><p>FreeBSDに移植されたソフトウェアパッケージについては、 <a href=http://www.FreeBSD.org/ports/>FreeBSD Ports Collection のページ</a>をご覧ください。 このリストには現在 3400 を越える項目があり、 しかも毎日更新されています。このページをこまめに訪れるか、 <code>freebsd-announce</code><a href=#mailing>メーリングリスト</a>を購読すると、 新しく入った ports を定期的にチェックすることができます。</p></div><div class=paragraph><p>大部分の ports は 2.2 と 3.x および 4.x ブランチで利用できるはずです。 多くは 2.1.x 系のシステムでも同様に動作するでしょう。 FreeBSD のリリースが出る度に、そのリリースの時点での ports ツリーの スナップショットが撮られ、<span class=filename>ports/</span> ディレクトリに 納められることになっています。</p></div><div class=paragraph><p>また、"package" という考えも採用されています。これは基本的には gzip で圧縮されたバイナリディストリビューションに、 インストール時に環境に合わせた作業が必要になった場合、 行う機能を多少付け加えたものです。 package を使えば、どのようなファイルが配布物として含まれているか、 と言った細かい事柄にいちいち煩わされることなく、 簡単にインストールやアンインストールを繰り返すことができます。</p></div><div class=paragraph><p>インストールしたい package があるなら、 <span class=filename>/stand/sysinstall</span>の、 「インストール後の FreeBSD の設定を行う」の下にある package のインストールメニューを使うか、 package のファイル名を指定して <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg_add&amp;sektion=1&amp;format=html">pkg_add(1)</a> を使用してください。 package のファイル名には、 通常末尾に <span class=filename>.tgz</span> がついています。 CDROM をご使用の方は、CD の <span class=filename>packages/All</span> ディレクトリからそれらのファイルを利用することができます。 また、以下の場所から、 FreeBSD の各種バージョンにあわせた package をダウンロードする こともできます。</p></div><div class=dlist><dl><dt class=hdlist1>2.2.8-RELEASE/2.2.8-STABLE 用</dt><dd><p><a href=ftp://ftp.FreeBSD.org/pub/FreeBSD/ports/i386/packages-2.2.8/>ftp://ftp.FreeBSD.org/pub/FreeBSD/ports/i386/packages-2.2.8/</a></p></dd><dt class=hdlist1>3.X-RELEASE/3.X-STABLE 用</dt><dd><p><a href=ftp://ftp.FreeBSD.org/pub/FreeBSD/ports/i386/packages-3-stable/>ftp://ftp.FreeBSD.org/pub/FreeBSD/ports/i386/packages-3-stable/</a></p></dd><dt class=hdlist1>4.X-RELEASE/4-STABLE 用</dt><dd><p><a href=ftp://ftp.FreeBSD.org/pub/FreeBSD/ports/i386/packages-4-stable/>ftp://ftp.FreeBSD.org/pub/FreeBSD/ports/i386/packages-4-stable/</a></p></dd><dt class=hdlist1>5.X-CURRENT 用</dt><dd><p><a href=ftp://ftp.FreeBSD.org/pub/FreeBSD/ports/i386/packages-5-current/>ftp://ftp.FreeBSD.org/pub/FreeBSD/ports/i386/packages-5-current</a></p></dd></dl></div><div class=paragraph><p>お近くのミラーサイトもご利用ください。</p></div><div class=paragraph><p>新しい ports が続々と追加されている状態なので、すべての ports に 対応する package が存在するわけではないことを覚えておいてください。 定期的に <a href=ftp://ftp.FreeBSD.org/pub/FreeBSD/>ftp.FreeBSD.org</a> マスターサイトを訪れて、どのような package が利用できるのかチェックするのも良いでしょう。</p></div></div><div class=sect2><h3 id=_なぜ_binsh_はこんなに低機能なのですか_どうして_bash_や他のシェルを採用しないのでしょう>5.2. なぜ /bin/sh はこんなに低機能なのですか? どうして bash や他のシェルを採用しないのでしょう?<a class=anchor href=#_なぜ_binsh_はこんなに低機能なのですか_どうして_bash_や他のシェルを採用しないのでしょう></a></h3><div class=paragraph><p>それは、POSIX がそのようなシェルがあることを規定しているからです。</p></div><div class=paragraph><p>もっと込み入った回答: 多くのユーザは、多くのシステムで同じように動作できるシェルスクリプトを書く必要があります。 これが、POSIX でシェルやユーティリティコマンドが細く規定されている理由です。 ほとんどすべてのスクリプトは Bourne shell で書かれているのですが、 それは、数多くの重要なプログラミングインタフェイス (<a href="https://man.freebsd.org/cgi/man.cgi?query=make&amp;sektion=1&amp;format=html">make(1)</a>、 <a href="https://man.freebsd.org/cgi/man.cgi?query=system&amp;sektion=3&amp;format=html">system(3)</a>、<a href="https://man.freebsd.org/cgi/man.cgi?query=popen&amp;sektion=3&amp;format=html">popen(3)</a>、や Perl や Tcl 等の類似の 高水準スクリプト言語) が、コマンドの解釈に Bourne shell を使うからです。 このように Bourne shell が極めて頻繁にかつ広範囲で使われているため、 素早く起動できて確実に動作し、メモリを少ししか消費しないということが 重要になります。</p></div><div class=paragraph><p>既存の実装は、 私たちに可能な限りこれらの多くの要求を同時に満足することができる最良のものです。 <code>/bin/sh</code> を小さいままに保つため、 私たちは他のシェルが持つ様々な便利な機能を提供していません。 Ports コレクションが bash や scsh、tcsh、zsh などの 多機能なシェルを含んでいるからです (これらのシェルすべての メモリ使用状況は、<code>ps -u</code> の "VSZ" や "RSS" の行で、あなた自身が確認することができます)。</p></div></div><div class=sect2><h3 id=_libc_so_3_0_はどこにありますか>5.3. libc.so.3.0 はどこにありますか?<a class=anchor href=#_libc_so_3_0_はどこにありますか></a></h3><div class=paragraph><p>FreeBSD 2.1.x のシステムで 2.2 以降用の package を動かそうとしていますね? 前のセクションを読んで、システムに合った正しい port/package を入手してください。</p></div></div><div class=sect2><h3 id=_error_cant_find_libc_so_4_0_というメッセージが表示されるのですが>5.4. Error: can’t find libc.so.4.0 というメッセージが表示されるのですが。<a class=anchor href=#_error_cant_find_libc_so_4_0_というメッセージが表示されるのですが></a></h3><div class=paragraph><p>何かの手違いで、4.X と 5.X のシステム用 package をダウンロードし、 FreeBSD 2.X、もしくは 3.X のシステムにインストールしてしまったのでしょう。 対応する正しいバージョンの package をダウンロードしてください。</p></div></div><div class=sect2><h3 id=_386486sx_のマシンで_ghostscript_を動かすとエラーがでます>5.5. 386/486SX のマシンで ghostscript を動かすとエラーがでます。<a class=anchor href=#_386486sx_のマシンで_ghostscript_を動かすとエラーがでます></a></h3><div class=paragraph><p>あなたのマシンには数値演算プロセッサが搭載されていませんね? カーネルにコプロセッサの代わりとなる数値演算エミュレータを追加する必要があります。 以下のオプションをカーネルのコンフィグレーションファイルに追加して、 カーネルを再構築してください。</p></div><div class="literalblock programlisting"><div class=content><pre>options GPL_MATH_EMULATE</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>このオプションを追加する場合、 <code>MATH_EMULATE</code> の行を削除してください。</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=_scoibcs2_のアプリケーションを実行すると_socksys_で落ちてしまいます_freebsd_3_0_とそれ以前のみ>5.6. SCO/iBCS2 のアプリケーションを実行すると、 socksys で落ちてしまいます。 (FreeBSD 3.0 とそれ以前のみ)<a class=anchor href=#_scoibcs2_のアプリケーションを実行すると_socksys_で落ちてしまいます_freebsd_3_0_とそれ以前のみ></a></h3><div class=paragraph><p>まず最初に <span class=filename>/etc/sysconfig</span> (または <span class=filename>/etc/rc.conf</span>, <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a> 参照) の最後のセクションを編集し、 以下の変数を <code>YES</code> に直します。</p></div><div class="literalblock programlisting"><div class=content><pre># Set to YES if you want ibcs2 (SCO) emulation loaded at startup
ibcs2=NO</pre></div></div><div class=paragraph><p>これでシステムの起動時に ibcs2 カーネルモジュールが読み込まるようになります。</p></div><div class=paragraph><p>次に /compat/ibcs2/dev/ を以下のように編集します。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>lrwxr-xr-x  1 root  wheel         9 Oct 15 22:20 X0R@ -&gt; /dev/null
lrwxr-xr-x  1 root  wheel         7 Oct 15 22:20 nfsd@ -&gt; socksys
<span class=nt>-rw-rw-r--</span>  1 root  wheel         0 Oct 28 12:02 null
lrwxr-xr-x  1 root  wheel         9 Oct 15 22:20 socksys@ -&gt; /dev/null
crw-rw-rw-  1 root  wheel   41,   1 Oct 15 22:14 spx</code></pre></div></div><div class=paragraph><p>open や close の処理は、 socksys から <span class=filename>/dev/null</span> (<a href="https://man.freebsd.org/cgi/man.cgi?query=null&amp;sektion=4&amp;format=html">null(4)</a> 参照) へシンボリックリンクを張ることで代用します。 残りの処理は、-CURRENT に入っているコードが担当しています。 これは以前のものより ずっとスッキリした方法です。</p></div></div><div class=sect2><h3 id=_inn_インターネットニュース_の設定方法は>5.7. INN (インターネットニュース) の設定方法は?<a class=anchor href=#_inn_インターネットニュース_の設定方法は></a></h3><div class=paragraph><p>inn の package や port をインストールしたあとに <a href=http://www.cis.ohio-state.edu/~barr/INN.html>Dave Barr’s INN Page</a> を見てみましょう。初心者向けの INN FAQ があります。</p></div></div><div class=sect2><h3 id=_どのバージョンの_microsoft_frontpage_を手に入れる必要がありますか>5.8. どのバージョンの Microsoft FrontPage を手に入れる必要がありますか?<a class=anchor href=#_どのバージョンの_microsoft_frontpage_を手に入れる必要がありますか></a></h3><div class=paragraph><p>ルーク、ports を使うのだ! パッチ処理済みの Apache が ports ツリーから入手できます。</p></div></div><div class=sect2><h3 id=_freebsd_は_java_をサポートしていますか>5.9. FreeBSD は Java をサポートしていますか?<a class=anchor href=#_freebsd_は_java_をサポートしていますか></a></h3><div class=paragraph><p>はい。 <a href=http://www.FreeBSD.org/java/>http://www.FreeBSD.org/java/</a> をご覧ください。 <a href=https://www.FreeBSD.org/java/>日本語訳</a> もあります。</p></div></div><div class=sect2><h3 id=_3_x_stable_を載せているマシンで_port_がコンパイルできないことがありますそれはどうしてですか>5.10. 3.x-STABLE を載せているマシンで port がコンパイルできないことがあります。それはどうしてですか?<a class=anchor href=#_3_x_stable_を載せているマシンで_port_がコンパイルできないことがありますそれはどうしてですか></a></h3><div class=paragraph><p>もし、その時点の -CURRENT か -STABLE に比べてずっと古いバージョンの FreeBSD を利用しているなら、 <a href=http://www.FreeBSD.org/ports/>http://www.FreeBSD.org/ports/</a> にある ports アップグレードキットが必要です。 最新の FreeBSD を利用しているのに発生する場合はおそらく、 -CURRENT では正常なのに -STABLE ではうまく動かなくなるような変更がその port に対して行なわれ、受理されてしまっているのでしょう。 ports コレクションは -CURRENT と -STABLE、 両方のブランチで動かなければならないものですので、 もしそれを発見したら <a href="https://man.freebsd.org/cgi/man.cgi?query=send-pr&amp;sektion=1&amp;format=html">send-pr(1)</a> コマンドを使ってバグレポートの提出をお願いします。</p></div></div><div class=sect2><h3 id=_ld_so_はどこにありますか>5.11. ld.so はどこにありますか?<a class=anchor href=#_ld_so_はどこにありますか></a></h3><div class=paragraph><p>3.1-R 以降などの Elf 化されたマシンで Netscape Navigator などの aout 形式のアプリケーションを動かすときには、 <span class=filename>/usr/libexec/ld.so</span> と aout ライブラリのファイルが必要です。 それらは配布物の <code>compat22</code> に納められています。 <span class=filename>/stand/sysinstall</span> や <span class=filename>compat22</span> サブディレクトリ内の <span class=filename>install.sh</span> を使って <code>compat22</code> をインストールしてください。 合わせて 3.1-R と 3.2-R の ERRATA もお読みください。</p></div></div><div class=sect2><h3 id=_ソースコードを更新しましたさてインストール済みの_ports_を更新するにはどうすればよいでしょうか>5.12. ソースコードを更新しました。さて、インストール済みの ports を更新するにはどうすればよいでしょうか?<a class=anchor href=#_ソースコードを更新しましたさてインストール済みの_ports_を更新するにはどうすればよいでしょうか></a></h3><div class=paragraph><p>残念ながら、インストール済みの ports を更新する簡単な 方法はありません。<code>pkg_version</code> コマンドを 用いて ports ツリー中の新しいバージョンに更新する スクリプトを次のように生成することができます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg_version -c &gt; /tmp/myscript</span></code></pre></div></div><div class=paragraph><p>出力されたスクリプトを使う前に、手で 編集<em>しなければなりません</em>。現在のバージョンの <code>pkg_version</code> では、スクリプトの先頭に <code>exit</code> を挿入して強制しています。</p></div><div class=paragraph><p>スクリプトの出力には、更新された packages に依存する packages が記載されているので、保存しておきましょう。これらも やはり更新する必要があるかもしれません。通常、更新が 必要となるのは、共有ライブラリのバージョンが変化し、 そのライブラリを利用している ports が新しいライブラリを用いるために 再構築する必要がある場合です。</p></div><div class=paragraph><p>システムが常時稼動しているならば、 <span class=filename>/etc/periodic.conf</span> に <code>weekly_status_pkg_enable="YES"</code> を 設定して、<a href="https://man.freebsd.org/cgi/man.cgi?query=periodic&amp;sektion=8&amp;format=html">periodic(8)</a> システムによって毎週更新が必要な ports の一覧を生成できます。</p></div></div></div></div><div class=sect1><h2 id=_カーネルコンフィグレーション>6. カーネルコンフィグレーション<a class=anchor href=#_カーネルコンフィグレーション></a></h2><div class=sectionbody><div class=sect2><h3 id=_カーネルをカスタマイズしたいんですが難しいですか>6.1. カーネルをカスタマイズしたいんですが、難しいですか?<a class=anchor href=#_カーネルをカスタマイズしたいんですが難しいですか></a></h3><div class=paragraph><p>全然難しくありません。 <a href=https://docs.freebsd.org/ja/books/handbook/kernelconfig#kernelconfig>カーネルの再構築</a>を調べてください。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>うまく動作するカーネルができたら、 日付入りのカーネルのスナップショットを <span class=filename>kernel.YYMMDD</span> のように作成することをおすすめします。 こうしておけば、次にカーネルの構築をやってうまくいかなくなってしまっても、 <span class=filename>kernel.GENERIC</span> にわざわざ戻る必要がなくなります。 これは、GENERIC カーネルでサポートされないデバイスから起動している場合は、 特に重要です。</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=_hw_float_が無いのでカーネルのコンパイルがうまくいきません>6.2. _hw_float が無いので、カーネルのコンパイルがうまくいきません。<a class=anchor href=#_hw_float_が無いのでカーネルのコンパイルがうまくいきません></a></h3><div class=paragraph><p>推測ですが、数値演算コプロセッサを持ってないからと思って、 <span class=filename>npx0</span> (<a href="https://man.freebsd.org/cgi/man.cgi?query=npx&amp;sektion=4&amp;format=html">npx(4)</a> 参照) をカーネルコンフィグファイルから削除してしまったのではないでしょうか? <span class=filename>npx0</span> は<em>必須</em>です。 コプロセッサがなくても、<span class=filename>npx0</span> デバイスは削除してはいけません。</p></div></div><div class=sect2><h3 id=_わたしのカーネルはどうしてこんなに大きい_10mb_以上_のでしょうか>6.3. わたしのカーネルはどうしてこんなに大きい (10MB 以上) のでしょうか?<a class=anchor href=#_わたしのカーネルはどうしてこんなに大きい_10mb_以上_のでしょうか></a></h3><div class=paragraph><p>これは<em>デバッグモード</em>でカーネルを構築していることが原因です。 デバッグモードで構築されたカーネルは、 デバッグに用いられる膨大なシンボル情報を含んでいるため、 カーネルのサイズが非常に大きくなります。 ただし FreeBSD 3.0 とそれ以降のシステムの場合は カーネルのサイズは小さくなりますし、 デバッグカーネルを実行する時のパフォーマンスの低下もありません。 また、そのカーネルはシステムがパニックした場合に有用です。</p></div><div class=paragraph><p>しかし、容量の小さなディスクでシステムを運用していたり、 単にデバッグカーネルを実行したくない場合は、 以下の両方が当てはまっているかどうか確認してください。</p></div><div class=ulist><ul><li><p>カーネルコンフィグファイルに以下の行が書かれていないこと。</p><div class="literalblock programlisting"><div class=content><pre>makeoptions DEBUG=-g</pre></div></div></li><li><p><code>config</code> を実行する際、 <code>-g</code> オプションを付けていないこと。</p></li></ul></div><div class=paragraph><p>上に書かれた指定は両方ともカーネルをデバッグモードで構築するためのものです。 上の手順を従っている限り、カーネルを普通に構築してサイズの小さなカーネルを得ることができます。 その場合のカーネルサイズは、およそ 1.5MB から 2MB 程度になります。</p></div></div><div class=sect2><h3 id=_マルチポートシリアルのコードで割り込みが衝突しています>6.4. マルチポートシリアルのコードで割り込みが衝突しています。<a class=anchor href=#_マルチポートシリアルのコードで割り込みが衝突しています></a></h3><div class=paragraph><p>マルチポートシリアルを サポートするコードを含んだカーネルをコンパイルしようとすると、 最初のポートだけ検出され、 残りのポートは割り込みの競合のためスキップされたと言われます。 どうやったらいいでしょうか?</p></div><div class=paragraph><p>ここでの問題は、FreeBSD にはハードウェアまたはソフトウェアの競合により、 カーネルがクラッシュするのを防ぐコードが含まれているという点です。 解決するには、最初のポートにだけ IRQ の設定を書き、 残りは IRQ の設定を削除します。 以下に例を示します。</p></div><div class="literalblock programlisting"><div class=content><pre># Multiport high-speed serial line - 16550 UARTS
#
device sio2 at isa? port 0x2a0 tty irq 5 flags 0x501 vector siointr
device sio3 at isa? port 0x2a8 tty flags 0x501 vector siointr
device sio4 at isa? port 0x2b0 tty flags 0x501 vector siointr
device sio5 at isa? port 0x2b8 tty flags 0x501 vector siointr</pre></div></div></div><div class=sect2><h3 id=_カーネルを構築にいつも失敗します_generic_カーネルも構築できません>6.5. カーネルを構築にいつも失敗します。 GENERIC カーネルも構築できません。<a class=anchor href=#_カーネルを構築にいつも失敗します_generic_カーネルも構築できません></a></h3><div class=paragraph><p>さまざまな理由が考えられます。以下、順に列記します。</p></div><div class=ulist><ul><li><p>あなたは新しい <code>make buildkernel</code> や <code>make installkernel</code> ターゲットを使わず、 現在走っているシステムを構築した時と異なるソースツリーを 構築しようとしている (たとえば、4.0-RELEASE のシステム上で 4.3-RELEASE を構築しようとしている) のではないでしょうか? もしシステムをアップグレードしようとしているのなら、 <span class=filename>/usr/src/UPDATING</span> ファイルを "共通項目 (COMMON ITEMS)" 節に注意しながら最後までお読みください。</p></li><li><p>あなたは新しい <code>make buildkernel</code> や <code>make installkernel</code> ターゲットを 使っているのにも関わらず、 <code>make buildworld</code> を行なっていないのではないでしょうか? <code>make buildkernel</code> ターゲットは、 <code>make buildworld</code> ターゲットによって作られるファイルに依存しています そのため、<code>make buildkernel</code> が正常に終了するためには <code>make buildworld</code> ターゲットが正常に完了している必要があります。</p></li><li><p>構築しようとしているのが <a href=#stable>FreeBSD-STABLE</a> だったとしても、あなたが入手したソースツリーが何らかの理由で 書き換わったり、壊れてしまっているのかも知れません。 <a href=#stable>FreeBSD-STABLE</a> はほとんどの場合、きちんと構築できるようになっていますが、 確実に構築可能であることが保証されているのは リリース版だけです。一度ソースツリーを再取得して、 問題が解決しないかどうか試してみてください。 また、あるサーバから取得した時に問題が発生したら、 別のサーバを試すのも効果があるかも知れません。</p></li></ul></div></div></div></div><div class=sect1><h2 id=_システム管理>7. システム管理<a class=anchor href=#_システム管理></a></h2><div class=sectionbody><div class=sect2><h3 id=_システムスタートアップファイルはどこにあるのですか>7.1. システムスタートアップファイルはどこにあるのですか?<a class=anchor href=#_システムスタートアップファイルはどこにあるのですか></a></h3><div class=paragraph><p>FreeBSD 2.0.5R から 2.2.1R までは、 プライマリコンフィグレーションファイルは <span class=filename>/etc/sysconfig</span> にあります。 オプションはすべてこのファイルで設定され、他の <span class=filename>/etc/rc</span> (<a href="https://man.freebsd.org/cgi/man.cgi?query=rc&amp;sektion=8&amp;format=html">rc(8)</a> 参照) および <span class=filename>/etc/netstart</span> といった ファイルはこれを読み込むだけです。</p></div><div class=paragraph><p>ファイル <span class=filename>/etc/sysconfig</span> を見て、システムに適合するように変更してください。 このファイルには、 それぞれの場所に何を書けばいいのかを表すコメントがたくさん書かれています。</p></div><div class=paragraph><p>FreeBSD 2.2.2 から 3.0 までのシステムでは、 <span class=filename>/etc/sysconfig</span> は、 より分りやすい名前の <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a> に改名され、それに従って書式もいくぶん改められています。 <span class=filename>/etc/netstart</span> も <span class=filename>/etc/rc.network</span> に改名され、 全部のファイルを <code>cp /usr/src/etc/rc* /etc</code> で一度にコピーすることが出来るようになります。</p></div><div class=paragraph><p>FreeBSD 3.1 とそれ以降では、 <span class=filename>/etc/rc.conf</span> が <span class=filename>/etc/defaults/rc.conf</span> に移動しました。 <em>このファイルを編集してはいけません!</em> 代わりに、 <span class=filename>/etc/defaults/rc.conf</span> の中で変えたいエントリの行を <span class=filename>/etc/rc.conf</span> にコピーし、 そこで変更するようにしてください。</p></div><div class=paragraph><p>たとえば named を起動したいとしましょう。 FreeBSD 3.1 かそれ以降のシステムで FreeBSD 付属の DNS サーバを起動するには、次のようにするだけです。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># echo named_enable=&#34;YES&#34; &gt;&gt;</span>
            /etc/rc.conf</code></pre></div></div><div class=paragraph><p>FreeBSD 3.1 かそれ以降でローカルサービスを起動するためには、 <span class=filename>/usr/local/etc/rc.d</span> ディレクトリにシェルスクリプトを置きます。 シェルスクリプトは起動可能に設定し、ファイル名が .sh で終わっていなければなりません。 FreeBSD 3.0 とそれ以前のリリースでは、 <span class=filename>/etc/rc.local</span> を編集する必要があります。</p></div><div class=paragraph><p>ファイル <span class=filename>/etc/rc.serial</span> はシリアルポートの初期化 (たとえばポートの設定を固定したり等々) のためにあります。</p></div><div class=paragraph><p>ファイル <span class=filename>/etc/rc.i386</span> は iBCS2 エミュレーションのような Intel アーキテクチャ固有の設定や、 PC システムコンソール設定のためにあります。</p></div></div><div class=sect2><h3 id=_簡単にユーザを追加するにはどうすればいいのですか>7.2. 簡単にユーザを追加するにはどうすればいいのですか?<a class=anchor href=#_簡単にユーザを追加するにはどうすればいいのですか></a></h3><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=adduser&amp;sektion=8&amp;format=html">adduser(8)</a> コマンドを使用してください。 また、<a href="https://man.freebsd.org/cgi/man.cgi?query=pw&amp;sektion=8&amp;format=html">pw(8)</a> コマンドを用いることで、さらに細かい操作が可能です。</p></div><div class=paragraph><p>ユーザを削除するには <a href="https://man.freebsd.org/cgi/man.cgi?query=rmuser&amp;sektion=8&amp;format=html">rmuser(8)</a> コマンドを使用してください。 繰り返しになりますが、<a href="https://man.freebsd.org/cgi/man.cgi?query=pw&amp;sektion=8&amp;format=html">pw(8)</a> でも構いません。</p></div></div><div class=sect2><h3 id=_新しいリムーバブルドライブを持っていますがどうやって使うの>7.3. 新しいリムーバブルドライブを持っていますが、どうやって使うの?<a class=anchor href=#_新しいリムーバブルドライブを持っていますがどうやって使うの></a></h3><div class=paragraph><p>そのリムーバブルドライブが ZIP であれ EZ drive であれ (あるいはもしそういう風に使いたいのなら、フロッピーであれ)、 またハードディスクであれ、一旦システムにインストールされて認識され、 カートリッジ、フロッピー等々が挿入されていれば、 ことはどのデバイスでも全く同じように進みます。</p></div><div class=paragraph><p><a id=disklabel></a>(このセクションは<a href=http://www.vmunix.com/mark/FreeBSD/ZIP-FAQ.html>Mark Mayo’s ZIP FAQ</a> に基づいています)</p></div><div class=paragraph><p>ZIP ドライブやフロッピーで、すでに DOS のファイルシステムで フォーマットしてある場合、次のコマンドを使うことができます。 これはフロッピーの場合です。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount -t msdos /dev/fd0c /floppy</span></code></pre></div></div><div class=paragraph><p>出荷時の設定の ZIP ディスクではこうです。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount -t msdos /dev/da2s4 /zip</span></code></pre></div></div><div class=paragraph><p>その他のディスクに関しては、<a href="https://man.freebsd.org/cgi/man.cgi?query=fdisk&amp;sektion=8&amp;format=html">fdisk(8)</a> や <span class=filename>/stand/sysinstall</span> を使って、 どのようにレイアウトされているか確かめてください。</p></div><div class=paragraph><p>以降は ZIP ドライブが 3 番目の SCSI ディスクで、 da2 と認識されている場合の例です。</p></div><div class=paragraph><p>他人と共有しなければならないフロッピーやリムーバブルディスク でなければ、BSD ファイルシステムを載せてしまうのが良い考えでしょう。 ロングファイル名もサポートされ、パフォーマンスは少なくとも 2 倍は向上しますし、おまけにずっと安定しています。 まず最初に、DOS レベルでのパーティション <span class=filename>/</span> ファイルシステムを無効にしておく必要があります。使用するのは <code>fdisk</code> でも <span class=filename>/stand/sysinstall</span> でも結構です。 複数のオペレーティングシステムを入れることを考慮する 必要がないような容量の小さなドライブの場合は、 次のように FAT パーティションテーブル (スライス) 全体を飛ばして、BSD のパーティション設定を行うだけで良いでしょう。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dd if=/dev/zero of=/dev/rda2 count=2</span>
<span class=c># disklabel -Brw da2 auto</span></code></pre></div></div><div class=paragraph><p>複数の BSD パーティションをつくる場合、 <code>disklabel</code> か <span class=filename>/stand/sysinstall</span> を使います。 固定ディスク上にスワップ領域を加える場合、 そういうことをしたいと思うのはもっともですが、 ZIP のようなリムーバブルドライブの上ではそういう考えは不適切 でしょう。</p></div><div class=paragraph><p>最後に、新しいファイルシステムをつくります。ディスク全体を使用する ZIP ドライブの場合は、以下のようにします。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># newfs /dev/rda2c</span></code></pre></div></div><div class=paragraph><p>次にマウントします。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount /dev/da2c /zip</span></code></pre></div></div><div class=paragraph><p>また、次のような行を <span class=filename>/etc/fstab</span> (<a href="https://man.freebsd.org/cgi/man.cgi?query=fstab&amp;sektion=5&amp;format=html">fstab(5)</a> 参照) に入れておくのも良い考えでしょう。 <code>mount /zip</code> と入力するだけでマウントできるようになります。</p></div><div class="literalblock programlisting"><div class=content><pre>/dev/da2c /zip ffs rw,noauto 0 0</pre></div></div></div><div class=sect2><h3 id=_自分の_crontab_ファイルを編集した後_root_not_found_のようなメッセージが延々と表示されるのですが_これはなぜですか>7.4. 自分の crontab ファイルを編集した後 root: not found のようなメッセージが延々と表示されるのですが、 これはなぜですか?<a class=anchor href=#_自分の_crontab_ファイルを編集した後_root_not_found_のようなメッセージが延々と表示されるのですが_これはなぜですか></a></h3><div class=paragraph><p>これは通常、システム crontab (<span class=filename>/etc/crontab</span>) を編集し、<a href="https://man.freebsd.org/cgi/man.cgi?query=crontab&amp;sektion=1&amp;format=html">crontab(1)</a> を使ってインストールした場合に起こります。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># crontab /etc/crontab</span></code></pre></div></div><div class=paragraph><p>この方法は正しくありません。 システム crontab のフォーマットは <a href="https://man.freebsd.org/cgi/man.cgi?query=crontab&amp;sektion=1&amp;format=html">crontab(1)</a> が更新する各ユーザの crontab とは異なります (フォーマットの相違点の詳細は <a href="https://man.freebsd.org/cgi/man.cgi?query=crontab&amp;sektion=5&amp;format=html">crontab(5)</a> で説明されています)。</p></div><div class=paragraph><p>もしこのような操作をしてしまったなら、 あらたな crontab は誤ったフォーマットの <span class=filename>/etc/crontab</span> のコピーになってしまっているからです。 以下のコマンドで削除してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># crontab -r</span></code></pre></div></div><div class=paragraph><p>今度 <span class=filename>/etc/crontab</span> を編集する時は、 その変更を <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a> に伝えるような操作をしてはいけません。 <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a> は、自動的にその変更を認識するからです。</p></div><div class=paragraph><p>もしあなたが何かを一日一回、あるいは一週間や一ヶ月に一回だけ 実行させたいなら、シェルスクリプトを <span class=filename>/usr/local/etc/periodic</span> に追加し、 <a href="https://man.freebsd.org/cgi/man.cgi?query=periodic&amp;sektion=8&amp;format=html">periodic(8)</a> コマンドにシステムの cron スケジュールから 他の定期的なシステムのタスクとともに 実行させたほうが良いかもしれません。</p></div><div class=paragraph><p>このエラーの実際の原因は、システム crontab には どのユーザ権限でコマンドを実行するかを指定する余分なフィールドがあることによるものです。 FreeBSD に添付されている標準のシステム crontab には、 すべてのエントリに <code>root</code> が書かれています。 この crontab が <code>root</code> ユーザの crontab (システム crontab とは <em>異なります</em>) として使われた場合、<a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a> は <code>root</code> を実行するコマンドの最初の単語だと認識しますが、 そのようなコマンドは存在しないのです。</p></div></div><div class=sect2><h3 id=_su1_コマンドを実行して_root_になろうとすると_su_が_you_are_not_in_the_correct_group_to_su_root_と警告します>7.5. <a href="https://man.freebsd.org/cgi/man.cgi?query=su&amp;sektion=1&amp;format=html">su(1)</a> コマンドを実行して root になろうとすると、 su が you are not in the correct group to su root と警告します。<a class=anchor href=#_su1_コマンドを実行して_root_になろうとすると_su_が_you_are_not_in_the_correct_group_to_su_root_と警告します></a></h3><div class=paragraph><p>これは、セキュリティ上の機能です。su コマンドを実行して <code>root</code> (またはスーパーユーザ権限を持つ 他のアカウント) になるには、<code>wheel</code> グループに所属していなければなりません。この機能がないと、 システムにアカウントがあって <code>root</code> の パスワードを見つけさえすれば、誰でもスーパーユーザ権限で システムにアクセスできてしまいます。この機能がある場合は、 必ずしもそうはなりません。<code>wheel</code> グループに 所属していなければ、<a href="https://man.freebsd.org/cgi/man.cgi?query=su&amp;sektion=1&amp;format=html">su(1)</a> がパスワードの入力すら 拒否するからです。</p></div><div class=paragraph><p>誰かが <code>root</code> に su できるように するには、その人を <code>wheel</code> グループに追加してください。</p></div></div><div class=sect2><h3 id=_rc_conf_やその他の_スタートアップファイルを書き間違えてしまいました_しかもそのためファイルシステムがリードオンリーになってしまっていて_編集ができませんどうすればいいですか>7.6. rc.conf やその他の スタートアップファイルを書き間違えてしまいました。 しかもそのためファイルシステムがリードオンリーになってしまっていて 編集ができません。どうすればいいですか?<a class=anchor href=#_rc_conf_やその他の_スタートアップファイルを書き間違えてしまいました_しかもそのためファイルシステムがリードオンリーになってしまっていて_編集ができませんどうすればいいですか></a></h3><div class=paragraph><p>シェルのパス名を入力するプロンプトが表示されたときに、 単に <code>ENTER</code> を押し、<code>mount /</code> を 実行してそルートファイルシステムを再マウントさせます。 また、お気に入りのエディタがあるファイルシステムを マウントするために <code>mount -a -t ufs</code> を する必要があるかも知れません。あなたのお気に入りのエディタが ネットワークファイルシステム上にある場合は、 ネットワークファイルシステムをマウントする前にネットワークを 手動で設定するか、<a href="https://man.freebsd.org/cgi/man.cgi?query=ed&amp;sektion=1&amp;format=html">ed(1)</a> のようなローカルファイルシステムにある エディタを使うかしなければなりません。</p></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=vi&amp;sektion=1&amp;format=html">vi(1)</a> や <a href="https://man.freebsd.org/cgi/man.cgi?query=emacs&amp;sektion=1&amp;format=html">emacs(1)</a> の様なフルスクリーンエディタを 使うつもりなら <code>export TERM=cons25</code> と やってエディタが <a href="https://man.freebsd.org/cgi/man.cgi?query=termcap&amp;sektion=5&amp;format=html">termcap(5)</a> データベースから正しい データを読み取れるようにしなければなりません。</p></div><div class=paragraph><p>これを行ったあとはいつもと同様、 <span class=filename>/etc/rc.conf</span> を編集して間違いを訂正することができるようになります。 カーネル起動メッセージの直後に表示されたエラーメッセージには、 問題の起こったファイル内での行番号を表示されているはずです。</p></div></div><div class=sect2><h3 id=_どのようにしたら_dos_の拡張パーティションをマウントできますか>7.7. どのようにしたら DOS の拡張パーティションをマウントできますか?<a class=anchor href=#_どのようにしたら_dos_の拡張パーティションをマウントできますか></a></h3><div class=paragraph><p>DOS 拡張パーティションは、 すべての基本パーティションの後に認識されます。 たとえば、2台目の SCSIドライブの拡張パーティションに "E" パーティションがあるとしますと、 これは <span class=filename>/dev</span> に「スライス 5 」のスペシャルファイルを作る必要があり、 <span class=filename>/dev/da1s5</span> としてマウントされます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /dev</span>
<span class=c># ./MAKEDEV da1s5</span>
<span class=c># mount -t msdos /dev/da1s5 /dos/e</span></code></pre></div></div></div><div class=sect2><h3 id=_他のシステムのファイルシステムを_freebsd_でマウントすることはできますか>7.8. 他のシステムのファイルシステムを FreeBSD でマウントすることはできますか?<a class=anchor href=#_他のシステムのファイルシステムを_freebsd_でマウントすることはできますか></a></h3><div class=paragraph><p><code>Digital UNIX</code>: UFS CDROM は直接 FreeBSD でマウントすることができます。 Digital UNIX やそれ以外のシステムのサポートする UFS のディスクパーティションをマウントすることはもっと複雑なことで、 オペレーティングシステムのディスクパーティションの詳細に依存します。</p></div><div class=paragraph><p><code>Linux</code>: 2.2 以降は <code>ext2fs</code> パーティションをサポートします。 詳しくは、<a href="https://man.freebsd.org/cgi/man.cgi?query=mount_ext2fs&amp;sektion=8&amp;format=html">mount_ext2fs(8)</a> を見てください。</p></div><div class=paragraph><p><code>NT</code>: FreeBSD 用の読みだしのみ可能な NTFS ドライバがあります。 詳しくは、Mark Ovens 氏によって書かれたチュートリアル <a href=http://ukug.uk.freebsd.org/~mark/ntfs_install.html>http://ukug.uk.freebsd.org/~mark/ntfs_install.html</a> をご覧ください。</p></div><div class=paragraph><p>この問題について他の情報があれば、他の人から感謝されるでしょう。</p></div></div><div class=sect2><h3 id=_どのようにしたら_freebsd_を_nt_ローダーから起動させることができますか>7.9. どのようにしたら FreeBSD を NT ローダーから起動させることができますか?<a class=anchor href=#_どのようにしたら_freebsd_を_nt_ローダーから起動させることができますか></a></h3><div class=paragraph><p>この手順は 2.2.x と (起動が 3 つのステージに分かれている) 3.x のシステムとで多少異なります。</p></div><div class=paragraph><p>FreeBSD のネイティブルートパーティションの最初のセクタをファイルにして DOS/NT パーティション上に置くという画期的なアイディアがあります。 ファイル名を <span class=filename>c:\bootsect.bsd</span> (<span class=filename>c:\bootsect.dos</span> からの発想です) としたとします。 <span class=filename>c:\boot.ini</span>ファイルを次のように編集します。</p></div><div class="literalblock programlisting"><div class=content><pre>[boot loader]
timeout=30
default=multi(0)disk(0)rdisk(0)partition(1)\WINDOWS
[operating systems]
multi(0)disk(0)rdisk(0)partition(1)\WINDOWS=&#34;Windows NT&#34;
C:\BOOTSECT.BSD=&#34;FreeBSD&#34;
C:\=&#34;DOS&#34;</pre></div></div><div class=paragraph><p>この手順は、利用しているシステムが 2.2.x であり、DOS、NT、FreeBSD あるいはその他のオペレーティングシステムがすべて、 <em>同じ</em>ディスクのそれぞれの fdisk パーティションにインストールされていることを想定しています。 この例は、DOS と NT を最初の fdisk パーティションにおき、 FreeBSD は 2 番目においたシステムで確認しています。 また、FreeBSD は MBR を使わずに、 ネイティブパーティションから起動するように設定してあります (訳注: FreeBSD のインストールで、ブートマネジャを使わずに標準 MBR を使う場合に相当します)。</p></div><div class=paragraph><p>(もし NTFS に変換してしまっているなら)DOS フォーマットのフロッピーディスクか FAT パーティションを <span class=filename>/mnt</span> に DOS マウントします。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dd if=/dev/rda0a of=/mnt/bootsect.bsd bs=512 count=1</span></code></pre></div></div><div class=paragraph><p>再起動して DOS か NT に切替えます。NTFS ユーザは <span class=filename>bootsect.bsd</span> や <span class=filename>bootsect.lnx</span> をフロッピーディスクから <span class=filename>C:\</span> へコピーします。 <span class=filename>boot.ini</span> のファイル属性 (パーミッション) の変更を以下のように行ないます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=o>&gt;</span> attrib <span class=nt>-s</span> <span class=nt>-r</span> c:<span class=se>\b</span>oot.ini</code></pre></div></div><div class=paragraph><p>上の例の <span class=filename>boot.ini</span> で示したような正しいエントリを加え、 ファイル属性を元に戻します。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=o>&gt;</span> attrib +s +r c:<span class=se>\b</span>oot.ini</code></pre></div></div><div class=paragraph><p>FreeBSD が MBR から起動するようになっている場合、 それぞれのネイティブパーティションから起動するように設定した後で、 DOS から <code>fdisk</code> コマンドを実行して元に戻してください。</p></div><div class=paragraph><p>FreeBSD 3.X における手順は、これよりいくぶん簡単です。</p></div><div class=paragraph><p>FreeBSD が NT 起動パーティションとして同じディスクにインストールされている場合には、 <span class=filename>/boot/boot1</span> を単純に <span class=filename>C:\BOOTSECT.BSD</span> へコピーします。 もし FreeBSD が異なったディスクにインストールされている場合には、 <span class=filename>/boot/boot1</span> では動作しませんので、 <span class=filename>/boot/boot0</span> が必要です。</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>ここで <span class=filename>/boot/boot1</span> の代わりに <span class=filename>/boot/boot0</span> をコピーするようなことをしてはいけません! そうすると、パーティションテーブルを上書きしてしまい、 コンピュータが起動できなくなってしまいます。</p></div></td></tr></tbody></table></div><div class=paragraph><p><span class=filename>/boot/boot0</span> をインストールするには、 sysinstall のブートマネージャを利用するかどうか尋ねられる画面で FreeBSD ブートマネージャを選択する必要があります。 <span class=filename>/boot/boot0</span> のパーティションテーブル部分は NULL 文字で埋められているのですが、 sysinstall は <span class=filename>/boot/boot0</span> を MBR にコピーする前にパーティションテーブルをきちんとコピーしてくれるからです。</p></div><div class=paragraph><p>FreeBSD ブートマネージャは最後に起動した OS を記録するために パーティションテーブルの最後に起動した OS のエントリにあるアクティブフラグをセットし、512 バイト全体を MBR に書き戻します。 これは <span class=filename>/boot/boot0</span> を <span class=filename>C:\BOOTSECT.BSD</span> にコピーし、 エントリの一つにアクティブフラグをセットして空のパーティションテーブルを MBR に書き込むことと同じです。</p></div></div><div class=sect2><h3 id=_freebsd_と_linux_を_lilo_から起動するには>7.10. FreeBSD と Linux を LILO から起動するには?<a class=anchor href=#_freebsd_と_linux_を_lilo_から起動するには></a></h3><div class=paragraph><p>FreeBSD と Linux が同じディスクにインストールされている場合、 単に Linux 以外の OS を起動するための LILO のインストール手順に 従えばいいだけです。非常に簡単にではありますが、記してみましょう。</p></div><div class=paragraph><p>Linux を起動し、<span class=filename>/etc/lilo.conf</span> に以下の行を加えて ください。</p></div><div class="literalblock programlisting"><div class=content><pre>other=/dev/hda2
      table=/dev/hda
      label=FreeBSD</pre></div></div><div class=paragraph><p>(上記の手順は FreeBSD のスライスが Linux から <span class=filename>/dev/hda2</span> という名前で見えていると仮定しています。 あなたの設定にあわせてください) その後、<code>lilo</code> を <code>root</code> で実行すれば完了です。</p></div><div class=paragraph><p>FreeBSD が別のディスクにインストールされているのなら、 LILO のエントリに <code>loader=/boot/chain.b</code> を追加してください。たとえば、このようになります。</p></div><div class="literalblock programlisting"><div class=content><pre>other=/dev/dab4
      table=/dev/dab
      loader=/boot/chain.b
      label=FreeBSD</pre></div></div><div class=paragraph><p>場合によっては、二つ目のディスクを正しく起動するために FreeBSD ブートローダに BIOS ドライブ番号を指定する必要があるかもしれません。 たとえば、FreeBSD SCSI ディスクが BIOS によって BIOS ディスク 1 として認識されるのなら、 FreeBSD のブートローダのプロンプトで、次のように指定する必要があります。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Boot: 1:da<span class=o>(</span>0,a<span class=o>)</span>/kernel</code></pre></div></div><div class=paragraph><p>FreeBSD 2.2.5 やそれ以降の版では、<a href="https://man.freebsd.org/cgi/man.cgi?query=boot&amp;sektion=8&amp;format=html">boot(8)</a> を設定すれば 起動時に上記のことが自動的に行えます。</p></div><div class=paragraph><p><a href=http://sunsite.unc.edu/LDP/HOWTO/mini/Linux+FreeBSD.html>Linux+FreeBSD mini-HOWTO</a> が FreeBSD と Linux とを相互に使えるようにするためのよい参考資料になるでしょう。</p></div></div><div class=sect2><h3 id=_freebsd_と_linux_を_booteasy_から起動するには>7.11. FreeBSD と Linux を BootEasy から起動するには?<a class=anchor href=#_freebsd_と_linux_を_booteasy_から起動するには></a></h3><div class=paragraph><p>LILO をマスターブートレコード (MBR) ではなく Linux の起動パーティションにインストールしてください。 これで BootEasy から LILO を起動できるようになります。</p></div><div class=paragraph><p>Windows95 と Linux を使用している場合は、 いずれにせよ後者の方がおすすめです。 Windows95 を再インストールする必要にかられたとき、 Linux を起動可能に戻す手続きが簡単ですむからです (Windows95 は偏屈なオペレーティングシステムで、 マスターブートレコード (MBR) から他のオペレーティングシステムを追い払ってしまうのです)。</p></div></div><div class=sect2><h3 id=_危険覚悟の専用_dangerously_dedicated_ディスクは健康に悪いの>7.12. 「危険覚悟の専用 (dangerously dedicated) ディスク」は健康に悪いの?<a class=anchor href=#_危険覚悟の専用_dangerously_dedicated_ディスクは健康に悪いの></a></h3><div class=paragraph><p><a id=dedicate></a>インストール作業中、 ハードディスクのパーティションを切る際に 2 つの方法を選ぶことができます。 デフォルトの方法では、fdisk のテーブルエントリ (FreeBSD ではスライスと呼ばれる) を使って、 自身のパーティションを使用する FreeBSD のスライスを、 同じマシンの他のオペレーティングシステムと互換性のある形にします。 それに付随して、ブートセレクタをインストールすれば、 ディスク上の使用可能なオペレーティングシステムを切り替えることができます。 もう一つの方法はディスクすべてを FreeBSD で使うというもので、 この場合ほかのオペレーティングシステムとの互換性を考慮しないことになります。</p></div><div class=paragraph><p>では、なぜこれが 「危険覚悟の」と言われるのでしょう? このモードのディスクが、通常の PC のユーティリティが有効な fdisk テーブルと見なす情報を持っていないからです。 ユーティリティの出来如何によりますが、 そのようなディスクを発見したとき、 警告を出すものもあります。また、もっと悪い場合、 確認も通告もなしに BSD のブートストラップにダメージを与えるものもあるでしょう。 さらには、「危険覚悟の」ディスクレイアウトは多数の BIOS、 AWARD (たとえば HP Netserver や Micronics システム、 他多数で使用されていた) や Symbios/NCR (人気のあるSCSI コントローラ 53C8xx 用) などを混乱させることが分かっています。 これは完全なリストではありません。 他にもまだまだあります。この混乱の兆候は、 起動時にシステムがロックするというだけでなく、 FreeBSD のブートストラップが自分自身を見つけられないために表示する "read error" というメッセージなどにも現れることでしょう。</p></div><div class=paragraph><p>そもそもいったいなぜこのモードがあるのでしょうか? これはわずかに数キロバイトのディスク容量を節約するのみであり、 新規インストールで実際に問題を生ずるのです。 「危険覚悟の」モードの起源は新しい FreeBSD インストーラでの、 BIOS から見えるディスクの 「ジオメトリ」の値とディスク自身との整合性という、 もっとも一般的な問題のひとつを回避したいという要求が背景にあります。</p></div><div class=paragraph><p>「ジオメトリ」は時代遅れの概念ですが、 未だに PC BIOS とディスクへの相互作用の中核をなしています。 FreeBSD のインストーラがスライスを作る時、 ディスク上のスライスを BIOS が見つけられるように、 スライス位置をディスク上に記録します。それが誤っていれば、 起動できなくなってしまうでしょう。</p></div><div class=paragraph><p>「危険覚悟の」モードはこれを、 問題を単純にすることで回避しようとします。 状況によってはこれでうまくいきます。 しかし次善の策として使われているに過ぎません。 この問題を解決するもっと良い方法はいくらでもあるのです。</p></div><div class=paragraph><p>では、 インストール時に「危険覚悟の専用」モードが必要になる 状況を回避するにはどうすればよいのでしょうか? まず BIOS が報告するディスクのジオメトリの値を覚えておくことからはじめましょう。 "boot:" プロンプトで “-v” を指定するか、ローダで "boot -v" と指定して、 起動時にカーネルにこの値を表示させることができます。 インストーラが起動する直前に、 カーネルがジオメトリ値のリストを表示するでしょう。 パニックを起こさないでください。 インストーラが起動するのを待ち、 逆スクロールでさかのぼって値を確認してください。 普通は BIOS ディスクユニット番号は、 FreeBSD がディスクを検出する順序と同様であり、 最初に IDE、次に SCSI となります。</p></div><div class=paragraph><p>ディスクをスライシングする際に、 FDISK の画面で表示されるディスクのジオメトリが正しいこと (BIOS の返す値と一致しているか) を確認してください。 万一異なっていたら “g” を押して修正してください。 ディスクにまったくなにもない場合や、 他のシステムから持ってきたディスクの場合は これを行なう必要があるかもしれません。 これはそのディスクから起動させようとしている場合にのみ、 問題になることに注意してください。 FreeBSD はそのディスクをうまい具合いに他のディスクと区別してくれます。</p></div><div class=paragraph><p>ディスクのジオメトリについて BIOS と FreeBSD 間で一致させることができたら、この問題はほぼ解決したと思ってよいでしょう。 そしてもはや「危険覚悟の専用」モードは必要ありません。 しかし、まだ起動時に恐怖の "read error" メッセージが出るようであれば、 お祈りを捧げて新しいディスクを買いましょう。 もう失うものは何もありません。</p></div><div class=paragraph><p>「危険覚悟の専用ディスク」を通常の PC での使用法に戻すには、 原則として 2 つ方法があります。1 つは十分な NULL バイトを MBR に書き込んで、 きたるべきインストーラにディスクはまっさらだと思い込ませる方法です。 たとえば、こんな感じです。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dd if=/dev/zero of=/dev/rda0 count=15</span></code></pre></div></div><div class=paragraph><p>また、マニュアルには書かれていない DOS の「機能」</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=o>&gt;</span> fdisk /mbr</code></pre></div></div><div class=paragraph><p>は、BSD ブートストラップを追い払ってくれる上に、 新しいマスターブートレコードをインストールしてくれます。</p></div></div><div class=sect2><h3 id=_どのようにしたらスワップ領域を増やせますか>7.13. どのようにしたらスワップ領域を増やせますか?<a class=anchor href=#_どのようにしたらスワップ領域を増やせますか></a></h3><div class=paragraph><p>スワップパーティションのサイズを増やすのが最良の方法ですが、 別のディスクを追加しなくて済むという利点のある方法があります。 経験から得た一般的な方法はメインメモリの 2倍程度のスワップ領域を とるというものです。しかしごく小さなメインメモリしかない場合は、 それ以上のスワップを構成したいと思うでしょう。また、将来のメモリの アップグレードに備え、後でスワップの構成を変更する必要がないように 十分なスワップを構成しておくことは良い考えです。</p></div><div class=paragraph><p>スワップを別のディスク上に追加することは、単純に同じディスク上 にスワップを追加する場合よりも高速に動作するようになります。 例に挙げれば、あるディスク上のソースをコンパイルしているとして、 スワップが別のディスク上に作られていれば、これらが同じディスク上 にある場合よりも断然速いです。SCSI ディスクの場合は特にそうだと言えます。</p></div><div class=paragraph><p>ディスクが複数ある場合、スワップパーティションを各ディスクに 作るように構成すると、使用中のディスク上にスワップを置いたとしても、 通常の場合は有益です。一般的に、システムにある高速なディスクには スワップを作るようにすべきでしょう。 FreeBSD はデフォルトでインターリーブなスワップデバイスを 4つまで サポートします。複数のスワップパーティションを構成する際に、 普通はそれらを大体同じくらいの大きさにして作りたいところですが、 カーネルのコアダンプを取るのに都合が良いようにメインの スワップパーティションを大きめにとる人もいます。 メインのスワップパーティションはカーネルのコアがとれるように 最低でも実メモリと同じ大きさにすべきでしょう。</p></div><div class=paragraph><p>IDE ドライブは同時に同じチャネル上の複数のドライブには アクセスできません (FreeBSD は mode 4 をサポートしていないので、 すべての IDE ディスク I/O は "programmed" です)。 IDE の場合であってもやはり、スワップを別のハードディスク上に 作成することをおすすめします。 ドライブは実に安いものです、心配するだけ無駄です。</p></div><div class=paragraph><p>NFS 越しにスワッピングさせる方法は、 スワップ用のローカルディスクが無い場合にのみ推奨されます。 NFS 越しのスワッピングは遅く、FreeBSD 4.x より前のリリースでは 効率が悪いのですが、4.0 以降ではそれなりに高速になります。 そうはいっても、利用できるネットワークの太さに制限されますし、 NFS サーバに余計な負荷がかかります。</p></div><div class=paragraph><p>これは 64MBの vn-swap を作る例です (ここでは <span class=filename>/usr/swap0</span> としますが、もちろん好きな名前を使うことができます)。</p></div><div class=paragraph><p>カーネルが次の行を含むコンフィグファイルから構成されているかを 確認します。GENERIC カーネルには、この行が含まれています。</p></div><div class="literalblock programlisting"><div class=content><pre>pseudo-device   vn 1   #Vnode driver (turns a file into a device)</pre></div></div><div class="olist arabic"><ol class=arabic><li><p>vn デバイスを作ります</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /dev</span>
<span class=c># sh ./MAKEDEV vn0</span></code></pre></div></div></li><li><p>スワップファイルを作ります (<span class=filename>/usr/swap0</span>)</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dd if=/dev/zero of=/usr/swap0 bs=1024k count=64</span></code></pre></div></div></li><li><p>スワップファイルに適切なパーミッションを設定します</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># chmod 0600 /usr/swap0</span></code></pre></div></div></li><li><p><span class=filename>/etc/rc.conf</span> でスワップファイルを有効化させます</p><div class="literalblock programlisting"><div class=content><pre>swapfile=&#34;/usr/swap0&#34;   # Set to name of swapfile if aux swapfile desired.</pre></div></div></li><li><p>マシンを再起動します</p></li></ol></div><div class=paragraph><p>スワップファイルをすぐに有効化させたいのなら以下のようにタイプします。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># vnconfig -e /dev/vn0b /usr/swap0 swap</span></code></pre></div></div></div><div class=sect2><h3 id=_プリンタのセットアップで問題があります>7.14. プリンタのセットアップで問題があります<a class=anchor href=#_プリンタのセットアップで問題があります></a></h3><div class=paragraph><p>ハンドブックのプリンタの部分を参照してください。 探している問題のほとんどが書かれているはずです。 <a href=https://docs.freebsd.org/ja/books/handbook/printing#printing>FreeBSD ハンドブックの「プリンタの利用」</a>をご覧ください。</p></div><div class=paragraph><p>プリンタによっては、印刷するのにホスト側にドライバが 必要です。これら "WinPrinters" と呼ばれるものは、 素の FreeBSD では使えません。DOS や Windows NT 4.0 で動作しない なら、そのプリンタはおそらく WinPrinter でしょう。 ただし、唯一の希望が残されています。 <span class=filename>ports/print/pnm2ppa</span> の port が 対応しているかどうか確認してみてください。<a href=http://www.freebsd.org/cgi/url.cgi?ports/print/pnm2ppa/pkg-descr> パッケージの説明</a>にはこう書いてあります。</p></div><div class=paragraph><p>このソフトウェアは PPA (printer performance architecture) プロトコルの出力を行います。このプロトコル は HP の "Windows 専用" プリンタの一部に使われています。 そのなかには、HP Deskjet 820C シリーズ、HP DeskJet 720 シリーズ、および HP DeskJet 1000 シリーズがあります。(略)</p></div><div class=paragraph><p>WWW: <a href=http://pnm2ppa.sourceforge.net/>http://pnm2ppa.sourceforge.net/</a></p></div></div><div class=sect2><h3 id=_私のシステムのキーボードマッピングは間違っています>7.15. 私のシステムのキーボードマッピングは間違っています。<a class=anchor href=#_私のシステムのキーボードマッピングは間違っています></a></h3><div class=paragraph><p><code>kbdcontrol</code> プログラムは、 キーボードマップファイルを読み込むためのオプションを備えています。 <span class=filename>/usr/shared/syscons/keymaps</span> の下にたくさんのマップファイルがあります。 システムに関連のあるものを一つ選んで、ロードしてください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kbdcontrol -l uk.iso</span></code></pre></div></div><div class=paragraph><p><span class=filename>/usr/shared/syscons/keymaps</span> と拡張子 <span class=filename>.kbd</span> は、どちらも <a href="https://man.freebsd.org/cgi/man.cgi?query=kbdcontrol&amp;sektion=1&amp;format=html">kbdcontrol(1)</a> によって使用されます。</p></div><div class=paragraph><p>これは <span class=filename>/etc/sysconfig</span> (または <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a>) 中で設定することができます。 このファイル中にあるそれぞれのコメントを参照してください。</p></div><div class=paragraph><p>FreeBSD 2.0.5R やそれ以降の版では、 テキストフォントやキーボードマッピングに関係のあるものはすべて、 <span class=filename>/usr/shared/examples/syscons</span> の中におさめられています。</p></div><div class=paragraph><p>現在以下のマッピングがサポートされています。</p></div><div class=ulist><ul><li><p>Belgian ISO-8859-1</p></li><li><p>Brazilian 275 keyboard Codepage 850</p></li><li><p>Brazilian 275 keyboard ISO-8859-1</p></li><li><p>Danish Codepage 865</p></li><li><p>Danish ISO-8859-1</p></li><li><p>French ISO-8859-1</p></li><li><p>German Codepage 850</p></li><li><p>German ISO-8859-1</p></li><li><p>Italian ISO-8859-1</p></li><li><p>Japanese 106</p></li><li><p>Japanese 106x</p></li><li><p>Latin American</p></li><li><p>Norwegian ISO-8859-1</p></li><li><p>Polish ISO-8859-2 (programmer’s)</p></li><li><p>Russian Codepage 866 (alternative)</p></li><li><p>Russian utf-8 (shift)</p></li><li><p>Russian utf-8</p></li><li><p>Spanish ISO-8859-1</p></li><li><p>Swedish Codepage 850</p></li><li><p>Swedish ISO-8859-1</p></li><li><p>Swiss-German ISO-8859-1</p></li><li><p>United Kingdom Codepage 850</p></li><li><p>United Kingdom ISO-8859-1</p></li><li><p>United States of America ISO-8859-1</p></li><li><p>United States of America dvorak</p></li><li><p>United States of America dvorakx</p></li></ul></div></div><div class=sect2><h3 id=_起動時にunknown_pnp0303_cant_assign_resources_というメッセージが表示されるのですが>7.16. 起動時に、unknown: &lt;PNP0303> can’t assign resources というメッセージが表示されるのですが?<a class=anchor href=#_起動時にunknown_pnp0303_cant_assign_resources_というメッセージが表示されるのですが></a></h3><div class=paragraph><p>以下は、freebsd-current メーリングリストへの投稿からの 抜粋です。</p></div><div class=paragraph><p>Garrett Wollman &lt;<a href=mailto:wollman@FreeBSD.org>wollman@FreeBSD.org</a>>, 2001 年 4 月 24 日
"can’t assign resources" というメッセージは、 そのデバイスがレガシー ISA デバイスで、PnP を意識していない ドライバがカーネルに組み込まれていることを示します。 これには、キーボードコントローラ、プログラム可能な 割り込み制御 IC やその他さまざまな標準的なデバイスが あります。リソースが割り当てられないのは、既にそのアドレスを 使っているドライバがあるからです。</p></div></div><div class=sect2><h3 id=_ユーザディスククォータが正常に動作していないようです>7.17. ユーザディスククォータが正常に動作していないようです。<a class=anchor href=#_ユーザディスククォータが正常に動作していないようです></a></h3><div class="olist arabic"><ol class=arabic><li><p>"<span class=filename>/</span>" にはディスククォータを設定しないでください。</p></li><li><p>クォータファイルが置かれるファイルシステム上に クォータファイルを置くようにしてください。</p><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Filesystem</th><th class="tableblock halign-left valign-top">Quota file</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/admin/quotas</span></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/home</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/home/admin/quotas</span></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>…​</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>…​</p></td></tr></tbody></table></li></ol></div></div><div class=sect2><h3 id=_わたしの_ccd_は_何が適合していない_inappropriate_のでしょう>7.18. わたしの ccd は、 何が適合していない (Inappropriate) のでしょう?<a class=anchor href=#_わたしの_ccd_は_何が適合していない_inappropriate_のでしょう></a></h3><div class=paragraph><p>次のような症状が現れます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ccdconfig -C</span>
ccdconfig: ioctl <span class=o>(</span>CCDIOCSET<span class=o>)</span>: /dev/ccd0c: Inappropriate file <span class=nb>type </span>or format</code></pre></div></div><div class=paragraph><p>通常この現象はタイプを「未使用 (unused)」のまま放っておかれた <code>c</code> パーティションをつなげようとした場合に現れます。ccd ドライバは FS_BSDFFS タイプをベースとするパーティションを要求します。 つなげようとしているディスクのディスクラベルを編集して、 パーティションのタイプを <code>4.2BSD</code> に変更してください。</p></div></div><div class=sect2><h3 id=_どうしてわたしの_ccd_のディスクラベルを変更することができないのでしょう>7.19. どうしてわたしの ccd のディスクラベルを変更することができないのでしょう?<a class=anchor href=#_どうしてわたしの_ccd_のディスクラベルを変更することができないのでしょう></a></h3><div class=paragraph><p>次のような症状が現れます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># disklabel ccd0</span>
<span class=o>(</span>it prints something sensible here, so <span class=nb>let</span><span class=s1>&#39;s try to edit it)
# disklabel -e ccd0
(edit, save, quit)
disklabel: ioctl DIOCWDINFO: No disk label on disk;
use &#34;disklabel -r&#34; to install initial label</span></code></pre></div></div><div class=paragraph><p>これは ccd から返されるディスクラベルが、 実はディスク上にはないまったくの偽の情報だからです。 これを明示的に書き直すことで問題を解消できます、 それには、つぎのようにします。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># disklabel ccd0 &gt; /tmp/disklabel.tmp</span>
<span class=c># disklabel -Rr ccd0 /tmp/disklabel.tmp</span>
<span class=c># disklabel -e ccd0</span>
<span class=o>(</span>this will work now<span class=o>)</span></code></pre></div></div></div><div class=sect2><h3 id=_freebsd_は_system_v_の_ipc_プリミティブをサポートしますか>7.20. FreeBSD は System V の IPC プリミティブをサポートしますか?<a class=anchor href=#_freebsd_は_system_v_の_ipc_プリミティブをサポートしますか></a></h3><div class=paragraph><p>はい。 FreeBSD は System-V スタイルの IPC をサポートします。 共有メモリ、メッセージ、セマフォが含まれます。 以下の行をカーネルコンフィグファイルに加えると、 サポートが有効になります。</p></div><div class="literalblock programlisting"><div class=content><pre>options    SYSVSHM          # enable shared memory
options    SYSVSEM          # enable for semaphores
options    SYSVMSG          # enable for messaging</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>FreeBSD 3.2 とそれ以降では、 これらのオプションがあらかじめ <em>GENERIC</em> カーネルに含まれていますので、 あなたのシステムにはすでに組み込まれています。</p></div></td></tr></tbody></table></div><div class=paragraph><p>カーネルを再構築してインストールしてください。</p></div></div><div class=sect2><h3 id=_uucp_でメールを配送するには_sendmail_をどう使えばよいのですか>7.21. UUCP でメールを配送するには sendmail をどう使えばよいのですか?<a class=anchor href=#_uucp_でメールを配送するには_sendmail_をどう使えばよいのですか></a></h3><div class=paragraph><p>FreeBSD に付属している sendmail は、 インターネットに直接つながっているサイトにあわせて設定してあります。 UUCP 経由で mail を交換したい場合には sendmail の設定ファイルを改めてインストールしなければなりません。</p></div><div class=paragraph><p><span class=filename>/etc/sendmail.cf</span> を自分の手で改造するのは純粋主義者のやるような事です。 sendmail の version 8 は <a href="https://man.freebsd.org/cgi/man.cgi?query=m4&amp;sektion=1&amp;format=html">m4(1)</a> のようなプリプロセッサを通して設定ファイルを生成する新しいアプローチを取っており、 より抽象化されたレベルの設定ファイルを編集します。 <span class=filename>/usr/src/usr.sbin/sendmail/cf</span> ディレクトリの中にある設定ファイルを使用してください。</p></div><div class=paragraph><p>もしすべてのソースをインストールしていない場合には sendmail の設定ツールは、別の tar ファイルにまとめてあります。CD-ROM が mount されている場合には、次のようにしてください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /cdrom/src</span>
<span class=c># cat scontrib.?? | tar xzf - -C /usr/src contrib/sendmail</span></code></pre></div></div><div class=paragraph><p>これはたった数 100Kbyte ですから心配ないでしょう。 <span class=filename>cf</span> ディレクトリにある <span class=filename>README</span> に、m4 での設定の基本的な説明があります。</p></div><div class=paragraph><p>UUCP での配送のためには、<code>mailertable</code> を使用すれば よいでしょう。これによって、sendmail が配送方式を決定するデータベースを 作成することができます。</p></div><div class=paragraph><p>まずはじめに、 <span class=filename>.mc</span> ファイルを作成しなければなりません。 <span class=filename>/usr/src/usr.sbin/sendmail/cf/cf</span> というディレクトリが、 これらのファイルを作成する場所です。既にいくつか例があると思います。 これから作成するファイルの名前を <span class=filename>foo.mc</span> とすると、 <span class=filename>sendmail.cf</span> を求めているような形式に変換するには、 次のようにしてください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/src/usr.sbin/sendmail/cf/cf</span>
<span class=c># make foo.cf</span>
<span class=c># cp foo.cf /etc/sendmail.cf</span></code></pre></div></div><div class=paragraph><p>標準的な <span class=filename>.mc</span> ファイルは次のようになります。</p></div><div class="literalblock programlisting"><div class=content><pre>include(`../m4/cf.m4&#39;)
VERSIONID(`Your version number&#39;)
OSTYPE(bsd4.4)

FEATURE(nodns)
FEATURE(nocanonify)
FEATURE(mailertable)

define(`UUCP_RELAY&#39;, your.uucp.relay)
define(`UUCP_MAX_SIZE&#39;, 200000)

MAILER(local)
MAILER(smtp)
MAILER(uucp)

Cw    your.alias.host.name
Cw    youruucpnodename.UUCP</pre></div></div><div class=paragraph><p><code>nodns</code> と <code>nocanonify</code> という指定をすることで、 mail の配送に DNS を使用しなくなります。 <code>UUCP_RELAY</code> という 行に関しては、 ある理由から必要ですがそれは聞かないでください。 .UUCP で終わる仮想ドメインを処理することのできるインターネット上での ホスト名をここに書いてください。通常は、ISP の mail リレーホストを 書くことになると思います。</p></div><div class=paragraph><p>これが終了したら、次に <span class=filename>/etc/mailertable</span> というファイルが必要です。標準的な例は次のとおりです。</p></div><div class="literalblock programlisting"><div class=content><pre>#
# makemap hash /etc/mailertable.db &lt; /etc/mailertable
#
horus.interface-business.de   uucp-dom:horus
.interface-business.de        uucp-dom:if-bus
interface-business.de         uucp-dom:if-bus
.heep.sax.de                  smtp8:%1
horus.UUCP                    uucp-dom:horus
if-bus.UUCP                   uucp-dom:if-bus
.                             uucp-dom:</pre></div></div><div class=paragraph><p>見れば分かるように、これは実在する設定のファイルです。はじめの 3 行はドメイン名で指定されたメールが default の経路で配送されずに、 「近道」するために UUCP で隣りのサイトに送るための特別な状況を 処理するものです。 次の行は Ethernet でつながっているローカルのドメインに対しては SMTP で送るための設定です。 最後に、UUCP での隣りのサイトが .UUCP で終わる仮想ドメインの書式で 指定されており、default の rule を <code>uucp-neighbour! recipient</code> で上書きするためのものです。一番最後の行はいつもドットを一つ書きます。 これは、ここまでの行でマッチしなかったすべてのホストにマッチし、 このサイトから世界に向けて出ていくための mail gateway に UUCP で配送するためのものです。 <code>uucp-dom:</code> に続けて書かれているノード名は、 <code>uuname</code> コマンドで指定することによって UUCP で直接配送される正しいノード名でなければなりません。</p></div><div class=paragraph><p>最後に、このファイルは使用する前に DBM データベースのファイルに 変換する必要があります。これを行なうコマンドラインは mailertable の最初のコメントに書いてあります。mailertable を変更した時には、 必ずこのコマンドを実行してください。</p></div><div class=paragraph><p>最後のヒントです: もし特定のメール配送がうまく作動するかどうか 確かめたい場合には、sendmail の<code>-bt</code> オプションを 使用してください。このオプションによって sendmail は <em>アドレステストモード</em>で起動します。 <code>0</code> の後に配送したいアドレスを書いてください。最後の行に、実際に使用される mail agent、この mail agent で送られる送信先のホスト、そして (多分変換されている) アドレスが表示されます。このモードを抜けるには Control-D を押してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% sendmail <span class=nt>-bt</span>
ADDRESS TEST MODE <span class=o>(</span>ruleset 3 NOT automatically invoked<span class=o>)</span>
Enter &lt;ruleset&gt; &lt;address&gt;
<span class=o>&gt;</span> 0 foo@interface-business.de
rewrite: ruleset  0   input: foo @ interface-business <span class=nb>.</span> de
...
rewrite: ruleset  0 returns: <span class=nv>$# </span>uucp-dom <span class=nv>$@</span> <span class=k>if</span><span class=nt>-bus</span> <span class=nv>$:</span> foo <span class=se>\</span>
&lt; @ interface-business <span class=nb>.</span> de <span class=o>&gt;</span>
<span class=o>&gt;</span> ^D</code></pre></div></div></div><div class=sect2><h3 id=_ダイアルアップでインターネットに接続する環境でメールをセットアップするにはどうやるの>7.22. ダイアルアップでインターネットに接続する環境でメールをセットアップするにはどうやるの?<a class=anchor href=#_ダイアルアップでインターネットに接続する環境でメールをセットアップするにはどうやるの></a></h3><div class=paragraph><p>静的に IP アドレスが割り当てられる場合は、 デフォルトの状態を変更する必要はありません。 割り当てられた名前をホストネームと するだけで、sendmail が後のことを引き受けてくれます。</p></div><div class=paragraph><p>ダイアルアップ ppp を インターネット接続に使用し、動的に IP アドレスが割り当てられる場合は、 インターネットサービスプロバイダ (ISP) のメールサーバにメールボックスがあるはずです。 ISP のドメインが <code>myISP.com</code> で、あなたのユーザ名が <code>user</code> だと仮定します。 また、あなたが自分のマシンを <code>bsd.home</code> と呼んでおり、ISP が <code>relay.myISP.com</code> をメールリレーとして使用できると言っているとしましょう。</p></div><div class=paragraph><p>メールボックスからメールを取ってくるためには、 回収 (retrieval) エージェントをインストールする必要があります。 Fetchmail は多種多様なプロトコルをサポートしているのでお勧めです。 ISP が使用しているのは、大抵 POP3 プロトコルです。 ユーザ ppp を使用している場合、 <span class=filename>/etc/ppp/ppp.linkup</span> に以下のように記述すると、 インターネットと接続が完了した時点で自動的にメールを取得するようになります。</p></div><div class="literalblock programlisting"><div class=content><pre>MYADDR:
      !bg su user -c fetchmail</pre></div></div><div class=paragraph><p>ローカルでないアカウントにメールを配送するのに sendmail を使用している場合 (後述)、 上に示したエントリの後に</p></div><div class="literalblock programlisting"><div class=content><pre>      !bg su user -c &#34;sendmail -q&#34;</pre></div></div><div class=paragraph><p>を記述します。これはネットワーク接続が確立したらすぐに sendmail に溜っている mailqueue を強制的に処理させるようにします。</p></div><div class=paragraph><p>この例では、<code>user</code> が <code>bsd.home</code> にアカウントを持ち、 <code>bsd.home</code> 上の <code>user</code> のホームディレクトリに、以下のような <span class=filename>.fetchmailrc</span> ファイルがつくられていることを想定しています。</p></div><div class="literalblock programlisting"><div class=content><pre>poll myISP.com protocol pop3 fetchall pass MySecret;</pre></div></div><div class=paragraph><p>言うまでもなく、このファイルは <code>user</code> 以外のユーザが読むことが出来ないようにしなくてはなりません。 内容にパスワード <code>MySecret</code> が含まれているからです。</p></div><div class=paragraph><p>正しい <code>from:</code> ヘッダをつけてメールを送るためには、 sendmail に <code>user@bsd.home</code> ではなく <code>user@myISP.com</code> を使用するよう教える必要があります。 メールをより早く転送するために、すべてのメールを <code>relay.myISP.com</code> へ送るように sendmail に 指示しておくのも良いでしょう。</p></div><div class=paragraph><p>上の要件を満たすには、以下のような <span class=filename>.mc</span> ファイルが適しています。</p></div><div class="literalblock programlisting"><div class=content><pre>VERSIONID(`bsd.home.mc version 1.0&#39;)
OSTYPE(bsd4.4)dnl
FEATURE(nouucp)dnl
MAILER(local)dnl
MAILER(smtp)dnl
Cwlocalhost
Cwbsd.home
MASQUERADE_AS(`myISP.com&#39;)dnl
FEATURE(allmasquerade)dnl
FEATURE(masquerade_envelope)dnl
FEATURE(nocanonify)dnl
FEATURE(nodns)dnl
define(`SMART_HOST&#39;, `relay.myISP.com&#39;)
Dmbsd.home
define(`confDOMAIN_NAME&#39;,`bsd.home&#39;)dnl
define(`confDELIVERY_MODE&#39;, `deferred&#39;)dnl</pre></div></div><div class=paragraph><p><span class=filename>.mc</span> ファイルから <span class=filename>sendmail.cf</span> への変換方法については、 前のセクションを参照してください. sendmail.cf を更新した後に sendmail をリスタートするのもお忘れなく。</p></div></div><div class=sect2><h3 id=_この_uid_が_0_の_toor_という_アカウントとは何ですか_危険にさらされているのでしょうか>7.23. この UID が 0 の toor という アカウントとは何ですか? 危険にさらされているのでしょうか?<a class=anchor href=#_この_uid_が_0_の_toor_という_アカウントとは何ですか_危険にさらされているのでしょうか></a></h3><div class=paragraph><p>心配無用です。<code>toor</code> は "代替の" スーパーユーザーアカウントです (toor は root を逆に綴ったものです)。 以前は、<a href="https://man.freebsd.org/cgi/man.cgi?query=bash&amp;sektion=1&amp;format=html">bash(1)</a> シェルがインストールされた時に 作成されていましたが、現在は標準で作成されています。 このユーザーが作成されるのは、 スーパーユーザが非標準のシェルを使う場合を想定しており、 <code>root</code> の標準のシェルを変更しなくてもよくなっています。 基本配布に含まれていないシェル (たとえば ports や packages からインストールされるシェル) は、デフォルトでは別のファイルシステムに存在する 可能性のある <span class=filename>/usr/local/bin</span> に インストールされることが多いので、これは重要です。 <code>root</code> のシェルが <span class=filename>/usr/local/bin</span> にあり、 <span class=filename>/usr</span> (または、<span class=filename>/usr/local/bin</span> があるいずれかのファイルシステム) が何らかの理由でマウントされていないとすると、 <code>root</code> は問題を解決するために ログインすることができません (シングルユーザーモードで再起動すれば、 シェルのパスの入力を促されるのですが)。</p></div><div class=paragraph><p><code>toor</code> を日々の root の仕事を 非標準のシェルで行うために使い、<code>root</code> は シングルユーザーモードや緊急時のために、標準のシェルのままに している人がいます。何もしなければ、パスワードを無効にしてあるので <code>toor</code> ではログインできません。 使いたいなら、<code>root</code> でログインして <code>toor</code> の パスワードを設定しましょう。</p></div></div><div class=sect2><h3 id=_しまった_root_のパスワードを忘れてしまった>7.24. しまった! root のパスワードを忘れてしまった!<a class=anchor href=#_しまった_root_のパスワードを忘れてしまった></a></h3><div class=paragraph><p>慌てないでください! 単にシステムを再起動し、 シングルユーザモードに移るために <code>Boot:</code> と表示されるプロンプトで <code>boot -s</code> と入力してください (FreeBSD の 3.2 より前のリリースでは <code>-s</code>となります)。 どのシェルを使うのかという質問には、ENTER キーを押してください。# に移ることができるでしょう。 <code>mount -u /</code> と入力して ルートファイルシステムの読み書きを再マウントし、 <code>mount -a</code> と入力して、 すべてのファイルシステムをマウントし直した後、 <code>passwd root</code> と入力して <code>root</code> のパスワードを設定し直してください。 その後、<code>exit</code> と入力すれば、起動が続けられます。</p></div></div><div class=sect2><h3 id=_control_alt_delete_でシステムが再起動しないようにするにはどうすればいい>7.25. Control-Alt-Delete でシステムが再起動しないようにするにはどうすればいい?<a class=anchor href=#_control_alt_delete_でシステムが再起動しないようにするにはどうすればいい></a></h3><div class=paragraph><p>FreeBSD 2.2.7-RELEASE 以降で syscons (デフォルトのコンソールドライバ) を使用している場合には、次の行をカーネルコンフィグレーションファイルに追加して カーネルを再構築し、インストールしてください。</p></div><div class="literalblock programlisting"><div class=content><pre>options SC_DISABLE_REBOOT</pre></div></div><div class=paragraph><p>FreeBSD 2.2.5-RELEASE 以降で PCVT コンソールドライバを使用している 場合には、同様に次の行をカーネルコンフィグレーションファイルに追加して カーネルを再構築し、インストールしてください。</p></div><div class="literalblock programlisting"><div class=content><pre>options PCVT_CTRL_ALT_DEL</pre></div></div><div class=paragraph><p>上にあげたものよりも古い FreeBSD の場合、 現在コンソールが使用しているキーマップを編集し、 キーワード <code>boot</code> を <code>nop</code> に書き換えてください。 <span class=filename>/usr/shared/syscons/keymaps/us.iso.kbd</span> にあります。 その変更を反映させようとして、 このキーマップのロードを明示的に行なうために、 <span class=filename>/etc/rc.conf</span> を実行すべきかもしれません。 もちろん他の国のキーマップを使っているのであれば、 代わりにそのキーマップファイルを編集してください。</p></div></div><div class=sect2><h3 id=_dos_のテキストファイルを_unix_のテキストファイルに整形するにはどうすればいい>7.26. DOS のテキストファイルを UNIX のテキストファイルに整形するにはどうすればいい?<a class=anchor href=#_dos_のテキストファイルを_unix_のテキストファイルに整形するにはどうすればいい></a></h3><div class=paragraph><p>単に次の perl コマンドを実行してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% perl <span class=nt>-i</span>.bak <span class=nt>-npe</span> <span class=s1>&#39;s/\r\n/\n/g&#39;</span> file ...</code></pre></div></div><div class=paragraph><p>file の部分には処理するファイルを指定してください。 整形後のファイルは元のファイル名で作成され、 整形前のファイルはバックアップとして元の ファイル名の末尾に拡張子 <span class=filename>.bak</span> のつけられた名前で作成されます。</p></div><div class=paragraph><p>あるいは <a href="https://man.freebsd.org/cgi/man.cgi?query=tr&amp;sektion=1&amp;format=html">tr(1)</a> コマンドを使うこともできます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>tr</span> <span class=nt>-d</span> <span class=s1>&#39;\r&#39;</span> &lt; dos-text-file <span class=o>&gt;</span> unix-file</code></pre></div></div><div class=paragraph><p><em>dos-text-file</em> は DOS 形式のテストファイル、 <em>unix-file</em> には変換された出力が格納されます。 perl を使うよりほんのちょっぴり速くなります。</p></div></div><div class=sect2><h3 id=_名前で指定してプロセスにシグナルを送るにはどうすればいい>7.27. 名前で指定してプロセスにシグナルを送るにはどうすればいい?<a class=anchor href=#_名前で指定してプロセスにシグナルを送るにはどうすればいい></a></h3><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=killall&amp;sektion=1&amp;format=html">killall(1)</a> を使ってください。</p></div></div><div class=sect2><h3 id=_su_が_not_in_roots_acl_と言って私を悩ませるのはなぜ>7.28. su が not in root’s ACL と言って私を悩ませるのはなぜ?<a class=anchor href=#_su_が_not_in_roots_acl_と言って私を悩ませるのはなぜ></a></h3><div class=paragraph><p>Kerberos の認証システムからくるエラーです。 この問題は致命的なものではなく、 うっとおしいといったものです。 <code>su</code> に <code>-K</code> オプションをつけて起動するか、 次の質問で説明されている方法で Kerberos をアンインストールしてください。</p></div></div><div class=sect2><h3 id=_kerberos_をアンインストールするにはどうすればいいの>7.29. Kerberos をアンインストールするにはどうすればいいの?<a class=anchor href=#_kerberos_をアンインストールするにはどうすればいいの></a></h3><div class=paragraph><p>システムから Kerberos を削除するには、 あなたの動かしているリリースの bin ディストリビューションを再インストールしてください。 もし CDROM を持っているのなら、 その CDROM をマウント (マウントポイントは <span class=filename>/cdrom</span> と仮定) して、 次のように入力してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /cdrom/bin</span>
<span class=c># ./install.sh</span></code></pre></div></div></div><div class=sect2><h3 id=_疑似ターミナルを追加するには>7.30. 疑似ターミナルを追加するには?<a class=anchor href=#_疑似ターミナルを追加するには></a></h3><div class=paragraph><p>telnet、ssh、X、screen をたくさん利用されている場合、 疑似ターミナルが足りなくなっている可能性があります。 これを増やすには次のようにします。</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>次の行をカーネルコンフィグレーションファイルに追加して</p><div class="literalblock programlisting"><div class=content><pre>pseudo-device pty 256</pre></div></div><div class=paragraph><p>新たにカーネルを作りインストールします。</p></div></li><li><p>次のコマンドを実行して</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /dev</span>
<span class=c># ./MAKEDEV pty{1,2,3,4,5,6,7}</span></code></pre></div></div><div class=paragraph><p>新たなターミナル用の 256 個のデバイスノードを作ります。</p></div></li><li><p><span class=filename>/etc/ttys</span> を編集し 256 個のターミナルごとの定義を追加します。 既存のエントリーの形式にあわせる必要があるでしょう。 たとえばこんな感じです。</p><div class="literalblock programlisting"><div class=content><pre>ttyqc none network</pre></div></div><div class=paragraph><p>正規表現を使った指定は <code>tty[pqrsPQRS][0-9a-v]</code> となります。</p></div></li><li><p>新しいカーネルでシステムを再起動すると完了です。</p></li></ol></div></div></div></div><div class=sect2><h3 id=_snd0_デバイスを作成することができません>7.31. snd0 デバイスを作成することができません!<a class=anchor href=#_snd0_デバイスを作成することができません></a></h3><div class=paragraph><p><span class=filename>snd</span> というデバイスは存在しません。 この名前は、FreeBSD サウンドドライバによって作成されるさまざまなデバイス、 <span class=filename>mixer</span> や <span class=filename>sequencer</span>、 <span class=filename>dsp</span> などを総称したものです。</p></div><div class=paragraph><p>これらのデバイスを作成するには、次のようにする必要があります。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /dev</span>
<span class=c># sh MAKEDEV snd0</span></code></pre></div></div></div><div class=sect2><h3 id=_再起動せずにもう一度_etcrc_conf_を読み込んで_etcrc_を開始させるには>7.32. 再起動せずにもう一度 /etc/rc.conf を読み込んで /etc/rc を開始させるには?<a class=anchor href=#_再起動せずにもう一度_etcrc_conf_を読み込んで_etcrc_を開始させるには></a></h3><div class=paragraph><p>シングルユーザモードに移行して、 マルチユーザモードに戻ってください。</p></div><div class=paragraph><p>コンソールで次のように実行します。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># shutdown now(注: -r や -h は付けません)</span>
<span class=c># return</span>
<span class=c># exit</span></code></pre></div></div></div><div class=sect2><h3 id=_砂場_sandbox_とは何ですか>7.33. 砂場 (sandbox) とは何ですか?<a class=anchor href=#_砂場_sandbox_とは何ですか></a></h3><div class=paragraph><p>"砂場 (Sandbox)" とはセキュリティ用語の一つで、 次の二つの意味があります。</p></div><div class=ulist><ul><li><p>一つ目は、「仮想的な『防壁』で囲まれているプロセス」です。 その『防壁』は、そのプロセスに侵入した第三者が、 さらにシステムの広い範囲に影響を与えることを防ぐように設計されます。</p><div class=paragraph><p>このプロセスの振舞いは、『防壁』の中だけに制限される、と表現できます。 つまり、このプロセスにおいて、『防壁』を越えるようなコードの実行は できないという意味です。そのため、コードの実行におけるセキュリティは 確かなものであると保証でき、実行の詳細な追跡を行なう必要はなくなります。</p></div><div class=paragraph><p>その『防壁』とは、たとえばユーザ ID がそれにあたるでしょう。 この定義は、security(7) や named(8) のマニュアルページで用いられています。</p></div><div class=paragraph><p><code>ntalk</code> サービス (/etc/inetd.conf 参照のこと) を例にとってみます。 このサービスはかつて、実行時の ユーザ ID として root を用いていましたが、現在では tty というユーザ ID で動作します。 ユーザ tty は、 ntalk を経由してシステムの侵入に成功した第三者が そのユーザ ID 以上の権限を得ることを、 より一層困難にするために設計された砂場 (sandbox) なのです。</p></div></li><li><p>二つ目は「シミュレートされたマシンの内側で実行されるプロセス」のことで、 こちらはより中核的です。 普通に考えれば、あるプロセスに侵入することができる第三者は、 マシンのより広い範囲にも侵入できると信じるものなのですが、 この種のプロセスの場合、それは実際にはシミュレートされたマシンに 侵入しただけなので、現実のデータを変更することは何一つできません。</p><div class=paragraph><p>これを実現するための最も広く用いられている方法は、 シミュレートされた環境をサブディレクトリに構築し、 そのディレクトリに chroot して、そのディレクトリで プロセスを実行すること (つまり、そのプロセスにとって <span class=filename>/</span> は システムの実際のルートディレクトリ <span class=filename>/</span> ではなく、 chroot されたサブディレクトリを指す) です。</p></div><div class=paragraph><p>広く用いられているもう一つの方法があります。 それは、既に存在しているファイルシステムを 読み込み専用 (read-only) でマウントし、その上に、あるプロセスに対して そのファイルシステムが書き込み可能であるように見せるような、 もう一つのファイルシステムの層を用意するものです。すると、 そのプロセスはファイルを書き込むことができると認識し、 実際に書き込むことができるのもその特定のプロセスだけ - システムにある他のプロセスは書き込めないのに対して - であるという状況を実現することができます。</p></div><div class=paragraph><p>この種の砂場 (sandbox) は、 その非常に透過的な性質を使って、ユーザ (もしくは侵入者) が その事実に気付かないように実現されます。</p></div></li></ul></div><div class=paragraph><p>UNIX は、内部的に二つの砂場 (sandbox) を実装しています。 一つはプロセスレベルのもの、もう一つはユーザ ID レベルのものです。</p></div><div class=paragraph><p>UNIX プロセスはすべて、他の UNIX プロセスから完全に隔離されています。 どのプロセスも、他のプロセスのアドレス空間を変更することはできません。 これは、あるプロセスが他のプロセスのアドレス空間を上書きできるような、 クラッシュにつながる行為が容易に実現できる Windows とは全く異なるものです。</p></div><div class=paragraph><p>UNIX プロセスは、特定のユーザ ID が所有します。 もし、実行者のユーザ ID が <code>root</code> ユーザのものでなければ、 ユーザ ID は、他のユーザが所有するプロセスから そのプロセスを守る機能を果たすわけです。 また、そのユーザ ID は、ディスク上にあるデータを 保護するのにも使われています。</p></div></div><div class=sect2><h3 id=_セキュアレベル_securelevel_って何ですか>7.34. セキュアレベル (securelevel) って何ですか?<a class=anchor href=#_セキュアレベル_securelevel_って何ですか></a></h3><div class=paragraph><p>セキュアレベルとはカーネルに実装されているセキュリティ機構の一つです。 簡単に言うと、カーネルはセキュアレベルが正の値の時に、 ある特定の操作を制限します。この制限は、たとえスーパユーザ (<code>root</code> のこと) であっても例外ではありません。 この文を書いている時点では、 セキュアレベル機構を使って以下のような操作を制限することができます。</p></div><div class=ulist><ul><li><p><code>schg</code> (system immutable flag) のようなファイルフラグの変更</p></li><li><p><span class=filename>/dev/mem</span> および <span class=filename>/dev/kmem</span> 経由でのカーネルメモリへの書き込み</p></li><li><p>カーネルモジュールのロード</p></li><li><p><a href="https://man.freebsd.org/cgi/man.cgi?query=ipfirewall&amp;sektion=4&amp;format=html">ipfirewall(4)</a> ルールの変更</p></li></ul></div><div class=paragraph><p>稼働中のシステムでセキュアレベルの状態をチェックするには、 次のコマンドを実行します。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl kern.securelevel</span></code></pre></div></div><div class=paragraph><p>出力には、<a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> 変数 (今の場合は <code>kern.securelevel</code>) と数字が現れます。 数字が現在のセキュアレベルの値です。 これがもし正の値なら、 何らかのセキュアレベルによる制限が有効になっています。</p></div><div class=paragraph><p>システム稼働中にセキュアレベルを下げることはできません。 これは、それを可能にするとセキュアレベルの意味がなくなってしまうからです。 セキュアレベルが正の値でないことを要求する操作 (たとえば <code>installworld</code> や日付の変更など) を行なう必要がある場合は、<span class=filename>/etc/rc.conf</span> にあるセキュアレベルの設定 (<code>kern_securelevel</code> と <code>kern_securelevel_enable</code> という変数) を変更して再起動する必要があります。</p></div><div class=paragraph><p>セキュアレベルに関する詳しい情報や、 各レベルで実現される機能に関しては <a href="https://man.freebsd.org/cgi/man.cgi?query=init&amp;sektion=8&amp;format=html">init(8)</a> のマニュアルページを参照してください。</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>セキュアレベルは万能というわけではなく、 弱点も数多く存在します。また、場合によっては、 セキュリティを低下させてしまうこともあります。</p></div><div class=paragraph><p>最も大きな問題の一つに、 セキュアレベルの機能を有効にするには、 起動処理でセキュアレベルが設定されるまでに使われるすべてのファイルを 保護する必要があるということがあります。 もし攻撃者が、システムがセキュアレベルを設定する前にコードを実行することができるとしたら、 セキュアレベルによる保護は無意味になってしまいます (起動時には低いセキュアレベルでしか実行できない処理を行なう必要があるため、 セキュアレベルの設定は、起動処理の最後の方で行なわれます)。 起動処理で使われるすべてのファイルを保護することは技術的に不可能です。 もしそうできたとしても、システムの保守はまさに悪夢となるでしょう。 設定ファイル一つ書き換えるのにも、 シングルユーザモードに切替えなければならなくなるのですから。</p></div><div class=paragraph><p>以上で説明した内容やその他の点については、 メーリングリストでも良く話題にのぼります。 議論のようすを<a href=http://www.FreeBSD.org/search/>このページ</a>から検索してみてください。 セキュアレベルは、 いずれより粒度の細かい機構にとって代わるだろうと考えている人々もいますが、 その点についてはまだ不透明なままです。</p></div><div class=paragraph><p>どうか注意するようにしてください。</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=_フロッピーや_cdrom_や他のリムーバブルメディアのマウントを一般ユーザーに許可するには>7.35. フロッピーや CDROM や他のリムーバブルメディアのマウントを一般ユーザーに許可するには?<a class=anchor href=#_フロッピーや_cdrom_や他のリムーバブルメディアのマウントを一般ユーザーに許可するには></a></h3><div class=paragraph><p>一般ユーザーでもデバイスをマウントできるようにすることができます。 手順は次のとおりです。</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p><code>root</code> になって、 sysctl 変数である <code>vfs.usermount</code> を <code>1</code> に設定します。</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl -w vfs.usermount=1</span></code></pre></div></div></li><li><p><code>root</code> になって、 リムーバブルメディアに関連するブロックデバイスに適切なパーミッションを設定します。</p><div class=paragraph><p>例として、最初のフロッピーデバイスをユーザーがマウントできるようにするには、 次のようにします。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># chmod 666 /dev/fd0</span></code></pre></div></div><div class=paragraph><p><code>operator</code> グループに所属するユーザが CDROM ドライブをマウントできるようにするには 以下のようにします。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># chgrp operator /dev/cd0c</span>
<span class=c># chmod 640 /dev/cd0c</span></code></pre></div></div></li><li><p>最後に <code>vfs.usermount=1</code> という行を <span class=filename>/etc/sysctl.conf</span> ファイルに追加し、 ブート時にセットされるようにしておきます。</p></li></ol></div></div></div><div class=paragraph><p>これで、すべてのユーザは フロッピー <span class=filename>/dev/fd0</span> を 自身の所有するディレクトリへマウントすることができます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>mkdir</span> ~/my-mount-point
% mount <span class=nt>-t</span> msdos /dev/fd0 ~/my-mount-point</code></pre></div></div><div class=paragraph><p>これで、<code>operator</code> グループに所属するユーザは CDROM <span class=filename>/dev/cd0c</span> を 自身の所有するディレクトリへマウントすることができます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>mkdir</span> ~/my-mount-point
% mount <span class=nt>-t</span> msdos /dev/cd0c ~/my-mount-point</code></pre></div></div><div class=paragraph><p>デバイスのアンマウントは簡単です。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% umount ~/my-mount-point</code></pre></div></div><div class=paragraph><p>しかし、 <code>vfs.usermount</code> を有効にすることは、セキュリティ上よいことではありません。 MSDOS 形式のメディアにアクセスには、Ports コレクションにある パッケージ <a href="http://www.freebsd.org/cgi/ports.cgi?query=%5Emtools-&amp;stype=name">mtools</a> を使用した方がよいでしょう。</p></div></div><div class=sect2><h3 id=_システムを新しい巨大ディスクへ移すにはどうするのですか>7.36. システムを新しい巨大ディスクへ移すにはどうするのですか?<a class=anchor href=#_システムを新しい巨大ディスクへ移すにはどうするのですか></a></h3><div class=paragraph><p>一番良いのは新しいディスクに OS を再インストールして、 それからユーザデータを移すことです。特にあなたが -stable を 複数のリリースを跨いで追い掛けている場合にはこの方法をおすすめします。 あなたは <a href="https://man.freebsd.org/cgi/man.cgi?query=boot0cfg&amp;sektion=8&amp;format=html">boot0cfg(8)</a> を使うことで booteasy を両方の ディスクにインストールでき、新しい配置で満足している間 デュアルブートができます。これを行ったあとデータを移す 方法を探すなら次の段落は読み飛ばしてください。</p></div><div class=paragraph><p>何もないディスクへインストールしないことに決めたならば <span class=filename>/stand/sysinstall</span>、なり <a href="https://man.freebsd.org/cgi/man.cgi?query=fdisk&amp;sektion=8&amp;format=html">fdisk(8)</a> と <a href="https://man.freebsd.org/cgi/man.cgi?query=disklabel&amp;sektion=8&amp;format=html">disklabel(8)</a> なりを使って新しいディスクに パーティションとディスクラベルを作らなければなりません。 また <a href="https://man.freebsd.org/cgi/man.cgi?query=boot0cfg&amp;sektion=8&amp;format=html">boot0cfg(8)</a> で booteasy を両方のディスクに インストールして、コピーの作業が終わったあとに 古いシステムからでも新しいディスクからでも起動できるように しておく必要があります。この作業の詳細は <a href=http://www.freebsd.org/tutorials/formatting-media/>formatting-media tutorial</a> を見てください。</p></div><div class=paragraph><p>新しいディスクの立ち上げが終わってデータの移動を 待つばかりになりました。しかし悲しいかな、無闇やたらと コピーすればいいというものではありません。デバイスファイル (<span class=filename>/dev</span>) やシンボリックリンクなどは 失敗の元になります。これらを理解するツール、すなわち <a href="https://man.freebsd.org/cgi/man.cgi?query=dump&amp;sektion=8&amp;format=html">dump(8)</a> や <a href="https://man.freebsd.org/cgi/man.cgi?query=tar&amp;sektion=1&amp;format=html">tar(1)</a> 等を使う必要があります。 データの移転はシングルユーザで行うことをお勧めしますが、 絶対と言うわけではありません。</p></div><div class=paragraph><p>あなたは <a href="https://man.freebsd.org/cgi/man.cgi?query=dump&amp;sektion=8&amp;format=html">dump(8)</a> と <a href="https://man.freebsd.org/cgi/man.cgi?query=restore&amp;sektion=8&amp;format=html">restore(8)</a> 以外のもので root ファイルシステムを移行してはなりません。 <a href="https://man.freebsd.org/cgi/man.cgi?query=tar&amp;sektion=1&amp;format=html">tar(1)</a> コマンドでもたぶんうまく行くでしょうが、 やらないほうがいいでしょう。パーティション一つを もう一つのからのパーティションに移すときは <a href="https://man.freebsd.org/cgi/man.cgi?query=dump&amp;sektion=8&amp;format=html">dump(8)</a> と <a href="https://man.freebsd.org/cgi/man.cgi?query=restore&amp;sektion=8&amp;format=html">restore(8)</a> 使うべきです。 パーティションのデータを新しいパーティションに移すのに dump を使うやり方は以下の通りです。</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>新しいパーティションに newfs をかける。</p></li><li><p>それを暫定的なマウントポイントにマウントする。</p></li><li><p>そのディレクトリに cd。</p></li><li><p>古いパーティションを dump し、 その出力をパイプで新しい方へ。</p></li></ol></div></div></div><div class=paragraph><p>たとえば root を <span class=filename>/dev/ad1s1a</span> へ、暫定的なマウントポイントを <span class=filename>/mnt</span> として移そうとすると以下のようになります。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># newfs /dev/ad1s1a</span>
<span class=c># mount /dev/ad1s1a</span>
<span class=c># cd /mnt</span>
<span class=c># dump 0uaf - / | restore xf -</span></code></pre></div></div><div class=paragraph><p>もしパーティションの構成を変えようと思っているなら - つまり一つだったものを二つにしたり二つだったものをくっつけたり しようとしているなら、自前であるディレクトリ以下のすべてを 新しい場所へ移す必要が出てくるかも知れません。<a href="https://man.freebsd.org/cgi/man.cgi?query=dump&amp;sektion=8&amp;format=html">dump(8)</a> は ファイルシステムに働くのでこの目的には使えません。この場合は <a href="https://man.freebsd.org/cgi/man.cgi?query=tar&amp;sektion=1&amp;format=html">tar(1)</a> を使います。一般に <span class=filename>/old</span> から <span class=filename>/new</span> への移動は <a href="https://man.freebsd.org/cgi/man.cgi?query=tar&amp;sektion=1&amp;format=html">tar(1)</a> で 以下のようにします。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># (cd /old; tar cf - .) | (cd /new; tar xpf -)</span></code></pre></div></div><div class=paragraph><p><span class=filename>/old</span> に他のファイルシステムが マウントされていて、そのデータの移動までは考えてないならば 最初の <a href="https://man.freebsd.org/cgi/man.cgi?query=tar&amp;sektion=1&amp;format=html">tar(1)</a> に 'l' フラグを追加します。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># (cd /old; tar clf - .) | (cd /new; tar xpf -).</span></code></pre></div></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=tar&amp;sektion=1&amp;format=html">tar(1)</a> のかわりに <a href="https://man.freebsd.org/cgi/man.cgi?query=cpio&amp;sektion=1&amp;format=html">cpio(1)</a> や <a href="https://man.freebsd.org/cgi/man.cgi?query=pax&amp;sektion=1&amp;format=html">pax(1)</a>, cpdup (ports/sysutils/cpdup) 等を 使っても構いません。</p></div></div><div class=sect2><h3 id=_システムを最新の_stable_にアップデートしようとしたのですが_rc_や_beta_になってしまいました_何が起こったのですか>7.37. システムを最新の -STABLE にアップデートしようとしたのですが -RC や -BETA になってしまいました! 何が起こったのですか?<a class=anchor href=#_システムを最新の_stable_にアップデートしようとしたのですが_rc_や_beta_になってしまいました_何が起こったのですか></a></h3><div class=paragraph><p>短い答え: ただの名前です。RC は "リリース候補 (Release Candidate)" に 由来するもので、リリースが間近であることを意味します。 また、FreeBSD における -BETA は通常、 リリース前のコードフリーズ期間に入っているという意味になります。</p></div><div class=paragraph><p>長い答え: FreeBSD はそのリリースを 2 ヶ所あるうちの 一方から派生させます。3.0-RELEASE や 4.0-RELEASE の様な (0 のマイナー番号を持つ) メジャーリリースは、一般に <a href=#current>-CURRENT</a> と呼ばれる 開発版の流れから分岐させられてできます。3.1-RELEASE や 4.2-RELEASE などのマイナーリリースはアクティブな <a href=#stable>-STABLE</a> ブランチ (枝) の スナップショットでした。 4.3-RELEASE からは、リリース毎にブランチが作成されるように なりました。ものすごく保守的な開発速度 (主にセキュリティ 勧告のみ) を求めている人は、このブランチを追跡すると よいでしょう。</p></div><div class=paragraph><p>リリースを作る時になるとそれを分岐させるブランチは 特定のプロセスへ突入します。そのプロセスの一つは コードフリーズ (コードの凍結) です。コードフリーズが 始まると、そのブランチの名前がリリースになろうとしていることを 反映するものに変えられます。たとえば、4.0-STABLE と 呼ばれていたブランチは名前が 4.1-BETA へと 変えられ、コードフリーズとリリース前のテストが 始まったことを示します。 バグの修正はリリースの一部としてコミットされます。 ソースコードがリリースの形を取ったなら名前が 4.1-RC へと 変えられ、それからリリースが作られることを示します。 ひとたび RC のステージになってしまうと、発見された もっとも致命的なバグの修正しかできなくなります。 ひとたびリリースが (この例では 4.1-RELEASE) 作られれば、 そのブランチは 4.1-STABLE と改名されます。</p></div></div><div class=sect2><h3 id=_新しいカーネルを入れようとしたのですが_chflags_に失敗しますどうすれば良いのでしょう>7.38. 新しいカーネルを入れようとしたのですが、 chflags に失敗します。どうすれば良いのでしょう?<a class=anchor href=#_新しいカーネルを入れようとしたのですが_chflags_に失敗しますどうすれば良いのでしょう></a></h3><div class=paragraph><p>簡単な回答: 多分、セキュアレベルが 0 より大きくなっているのでしょう。 直接シングルユーザモードで再起動して、 カーネルをインストールしてください。</p></div><div class=paragraph><p>詳しい回答: FreeBSD では、セキュアレベルが 0 より大きい場合、 システムフラグの変更が禁止されます。 現在のセキュアレベルは、次のコマンドを使って調べることができます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl kern.securelevel</span></code></pre></div></div><div class=paragraph><p>セキュアレベルを下げる操作は、できないようになっています。 そのため、カーネルをインストールするには、 シングルユーザモードで起動するか、<span class=filename>/etc/rc.conf</span> のセキュリティ設定を変更して再起動する必要があります。 セキュアレベルの詳細は <a href="https://man.freebsd.org/cgi/man.cgi?query=init&amp;sektion=8&amp;format=html">init(8)</a> を、 rc.conf の詳細は <span class=filename>/etc/defaults/rc.conf</span> および、 <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a> のマニュアルページをご覧ください。</p></div></div><div class=sect2><h3 id=_システムの時刻を_1_秒以上変更することができないのです_どうすれば良いのでしょう>7.39. システムの時刻を 1 秒以上変更することができないのです! どうすれば良いのでしょう?<a class=anchor href=#_システムの時刻を_1_秒以上変更することができないのです_どうすれば良いのでしょう></a></h3><div class=paragraph><p>簡単な回答: 多分、セキュアレベルが 1 より大きくなっているのでしょう。 直接シングルユーザモードで再起動して、 時刻の変更をしてください。</p></div><div class=paragraph><p>詳しい回答: FreeBSD では、セキュアレベルが 1 より大きい場合、 1 秒以上の時刻変更が禁止されます。 現在のセキュアレベルは、次のコマンドを使って調べることができます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl kern.securelevel</span></code></pre></div></div><div class=paragraph><p>セキュアレベルを下げる操作は、できないようになっています。 そのため、システムの時刻を変更するには、 シングルユーザモードで起動するか、<span class=filename>/etc/rc.conf</span> のセキュリティ設定を変更して再起動する必要ばあります。 セキュアレベルの詳細は <a href="https://man.freebsd.org/cgi/man.cgi?query=init&amp;sektion=8&amp;format=html">init(8)</a> を、 rc.conf の詳細は <span class=filename>/etc/defaults/rc.conf</span> および、 <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a> のマニュアルページをご覧ください。</p></div></div><div class=sect2><h3 id=_rpc_statd8_にメモリリークを見つけました_メモリを_256_メガバイトも使っています>7.40. <a href="https://man.freebsd.org/cgi/man.cgi?query=rpc.statd&amp;sektion=8&amp;format=html">rpc.statd(8)</a> にメモリリークを見つけました! メモリを 256 メガバイトも使っています。<a class=anchor href=#_rpc_statd8_にメモリリークを見つけました_メモリを_256_メガバイトも使っています></a></h3><div class=paragraph><p>いいえ。それはメモリリークではありませんし、 256 メガバイトのメモリを使っている、ということでもありません。 おそらく (ほとんどの場合)、 処理に都合が良いように非常にたくさんの量のメモリを そのプロセスのアドレス空間にマッピングしているのでしょう。 技術的な見地から考えても、これは大きな害があることではなく、 単に <a href="https://man.freebsd.org/cgi/man.cgi?query=top&amp;sektion=1&amp;format=html">top(1)</a> や <a href="https://man.freebsd.org/cgi/man.cgi?query=ps&amp;sektion=1&amp;format=html">ps(1)</a> といったツールの表示に影響がある程度です。</p></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=rpc.statd&amp;sektion=8&amp;format=html">rpc.statd(8)</a> は、(<span class=filename>/var</span> にある) ステータスファイルを自分のアドレス空間にマッピングします。 マッピングは、後で大きな空間が必要になった時に再マッピングしないで済むよう、 非常に大きなサイズを指定して行なわれます。 これは、ソースコードに含まれる <a href="https://man.freebsd.org/cgi/man.cgi?query=mmap&amp;sektion=2&amp;format=html">mmap(2)</a> 関数のマッピング長を示す引数に <code>0x10000000</code> が指定されていることからも分かります。 この数字が IA32 アーキテクチャの持つアドレススペース全体の 16 分の 1、すなわち、ちょうど 256 メガバイトに相当するのです。</p></div></div></div></div><div class=sect1><h2 id=_x_window_system_と仮想コンソール>8. X Window System と仮想コンソール<a class=anchor href=#_x_window_system_と仮想コンソール></a></h2><div class=sectionbody><div class=sect2><h3 id=_x_を動かしたいのですがどうすればいいのですか>8.1. X を動かしたいのですが、どうすればいいのですか?<a class=anchor href=#_x_を動かしたいのですがどうすればいいのですか></a></h3><div class=paragraph><p>もっとも簡単な方法は FreeBSD のインストールの際に X を動かすことを指定するだけです。</p></div><div class=paragraph><p>それから <code>xf86config</code> ツールのドキュメントを読んでこれに従ってください。 このツールはあなたのグラフィックカードやマウスなどに合わせて XFree86™ の設定を行うのを助けてくれます。</p></div><div class=paragraph><p>Xaccel サーバーについて調べてみるのもいいでしょう。 詳しくは <a href=#xig>Xi Graphics について</a> か <a href=#metrox>Metro Link</a> をご覧ください。</p></div></div><div class=sect2><h3 id=_x_を実行しようとして_startx_と入力したのですが_kdenabio_failed_operation_not_permitted_というエラーが表示されます_何かおかしなことをやってしまったんでしょうか>8.2. X を実行しようとして startx と入力したのですが、 KDENABIO failed (Operation not permitted) というエラーが表示されます。 何かおかしなことをやってしまったんでしょうか?<a class=anchor href=#_x_を実行しようとして_startx_と入力したのですが_kdenabio_failed_operation_not_permitted_というエラーが表示されます_何かおかしなことをやってしまったんでしょうか></a></h3><div class=paragraph><p>あなたのシステムは高いセキュアレベルで運用されていますね? 実は、高いセキュアレベルで X を起動することはできないのです。 どうしてなのかについては、<a href="https://man.freebsd.org/cgi/man.cgi?query=init&amp;sektion=8&amp;format=html">init(8)</a> のマニュアルページに書かれています。</p></div><div class=paragraph><p>では、代わりにどうすれば良いのかお答えしましょう。 基本的に 2 つの方法があります。 一つはセキュアレベルを 0 にする (通常、これは <span class=filename>/etc/rc.conf</span> で指定します) こと、 もう一つは起動時 (セキュアレベルを上げる前) に <a href="https://man.freebsd.org/cgi/man.cgi?query=xdm&amp;sektion=1&amp;format=html">xdm(1)</a> を実行するかです。</p></div><div class=paragraph><p>起動時に <a href="https://man.freebsd.org/cgi/man.cgi?query=xdm&amp;sektion=1&amp;format=html">xdm(1)</a> を実行する方法の詳細については、 <a href=#xdm-boot>XDM を起動時に起動させるにはどうしますか?</a> を参照してください。</p></div></div><div class=sect2><h3 id=_私のマウスはなぜ_x_で動かないのでしょうか>8.3. 私のマウスはなぜ X で動かないのでしょうか?<a class=anchor href=#_私のマウスはなぜ_x_で動かないのでしょうか></a></h3><div class=paragraph><p>syscons (デフォルトのコンソールドライバ) を使っているのであれば、 それぞれの仮想スクリーンでマウスポインターをサポートするように FreeBSD を設定できます。X でのマウスの衝突を避けるために、syscons は <span class=filename>/dev/sysmouse</span> という仮想デバイスをサポートしています。 本物のマウスデバイスから入力されたすべてのマウスのイベントは、 moused を経由して sysmouse デバイスへ出力されます。 一つ以上の仮想コンソールと X の <em>両方で</em> マウスを使いたい場合、 <a href=#moused>X Window System 以外の環境でマウスを使うことは可能ですか?</a> を参照して moused を設定してください。</p></div><div class=paragraph><p>そして、<span class=filename>/etc/XF86Config</span> を編集し、 次のように書かれていることを確認してください。</p></div><div class="literalblock programlisting"><div class=content><pre>Section         Pointer
Protocol        &#34;SysMouse&#34;
Device          &#34;/dev/sysmouse&#34;
.....</pre></div></div><div class=paragraph><p>上の例は、XFree86 3.3.2 以降の場合の例です。 それより前のバージョンでは、 <em>Protocol</em> という部分を <em>MouseSystems</em> と置き換える必要があります。</p></div><div class=paragraph><p>X で <span class=filename>/dev/mouse</span> を使うのを好む人もいます。 この場合は、 <span class=filename>/dev/mouse</span> を <span class=filename>/dev/sysmouse</span> (<a href="https://man.freebsd.org/cgi/man.cgi?query=sysmouse&amp;sektion=4&amp;format=html">sysmouse(4)</a> 参照) にリンクしてください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /dev</span>
<span class=c># rm -f mouse</span>
<span class=c># ln -s sysmouse mouse</span></code></pre></div></div></div><div class=sect2><h3 id=_わたしのマウスにはホイール機能が付いているのですがx_で使うことはできますか>8.4. わたしのマウスにはホイール機能が付いているのですが、X で使うことはできますか?<a class=anchor href=#_わたしのマウスにはホイール機能が付いているのですがx_で使うことはできますか></a></h3><div class=paragraph><p>はい、もちろん使えますが、そのためには X クライアントプログラムを適切に設定する必要があります。これについては、 <a href=http://www.inria.fr/koala/colas/mouse-wheel-scroll/>Colas Nahaboo 氏のウェブページ(http://www.inria.fr/koala/colas/mouse-wheel-scroll/)</a> を参照してください。</p></div><div class=paragraph><p>imwheel というプログラムを使う場合は、 次のような簡単な手順にしたがってください。</p></div><div class="olist arabic"><ol class=arabic><li><p>ホイールイベントの変換</p><div class=paragraph><p>imwheel は、 マウスのボタン 4、ボタン 5 をキー押下イベントに変換するプログラムです。 そのためホイールマウスで利用するには、マウスホイールのイベントをボタン 4、 ボタン 5 のイベントに変換するマウスドライバを利用する必要があります。 この変換を行なうには二つの方法があります。 一つは <a href="https://man.freebsd.org/cgi/man.cgi?query=moused&amp;sektion=8&amp;format=html">moused(8)</a> で行なう方法、二つめは X サーバ自身に変換を行なわせる方法です。</p></div><div class="olist loweralpha"><ol class=loweralpha type=a><li><p>ホイールイベントの変換に <a href="https://man.freebsd.org/cgi/man.cgi?query=moused&amp;sektion=8&amp;format=html">moused(8)</a> を使う</p><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=moused&amp;sektion=8&amp;format=html">moused(8)</a> にイベントを変換させるには、 <a href="https://man.freebsd.org/cgi/man.cgi?query=moused&amp;sektion=8&amp;format=html">moused(8)</a> 起動時にオプション <code>-z 4</code> を追加します。 たとえば、普段 <a href="https://man.freebsd.org/cgi/man.cgi?query=moused&amp;sektion=8&amp;format=html">moused(8)</a> を <code>moused -p /dev/psm0</code> として起動しているなら、その代わりに <code>moused -p /dev/psm0 -z 4</code> とします。 もし、 <span class=filename>/etc/rc.conf</span> を使って自動的に起動するように設定しているなら、 <span class=filename>/etc/rc.conf</span> の中の <code>moused_flags</code> という変数に <code>-z 4</code> を追加するだけです。</p></div><div class=paragraph><p>そして、5 ボタンマウスを使うことを X サーバに伝える必要があります。 これを行なうには <span class=filename>/etc/XF86Config</span> の "Pointer" セクションに <code>Buttons 5</code> という行を追加するだけです。 そうすると <span class=filename>/etc/XF86Config</span> の "Pointer" は、 たとえば次のようになるでしょう。</p></div><div class=exampleblock><div class=title>例 1. moused による変換を利用してホイールマウスを 使用するための XFree86 3.3.x 系列の XF86Config の "Pointer" セクションの設定例</div><div class=content><div class="literalblock programlisting"><div class=content><pre>Section &#34;Pointer&#34;
  Protocol        &#34;SysMouse&#34;
  Device          &#34;/dev/sysmouse&#34;
  Buttons         5
EndSection</pre></div></div></div></div><div class=exampleblock><div class=title>例 2. 自動的なプロトコル認識機能およびボタン配置変換機能を 利用し、ホイールマウスを使用するための XFree86 4.x 系列の XF86Config の "InputDevice" セクションの設定例</div><div class=content><div class="literalblock programlisting"><div class=content><pre>Section &#34;InputDevice&#34;
  Identifier      &#34;Mouse1&#34;
  Driver          &#34;mouse&#34;
  Option          &#34;Protocol&#34; &#34;auto&#34;
  Option          &#34;Device&#34; &#34;/dev/psm0&#34;
  Option          &#34;Buttons&#34; &#34;5&#34;
  Option          &#34;ZAxisMapping&#34; &#34;4 5&#34;
EndSection</pre></div></div></div></div><div class=exampleblock><div class=title>例 3. ホイールマウスで Emacs 上でのページスクロールを 行うための ".emacs" の設定例</div><div class=content><div class="literalblock programlisting"><div class=content><pre>;; wheel mouse
(global-set-key [mouse-4] &#39;scroll-down)
(global-set-key [mouse-5] &#39;scroll-up)</pre></div></div></div></div></li><li><p>X サーバを使ったホイールイベントの変換</p><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=moused&amp;sektion=8&amp;format=html">moused(8)</a> を起動していなかったり、 ホイールイベントの変換に <a href="https://man.freebsd.org/cgi/man.cgi?query=moused&amp;sektion=8&amp;format=html">moused(8)</a> を起動したくない場合には、その代わりに X サーバを使うことができます。 これには、<span class=filename>/etc/XF86Config</span> ファイルを書き換える必要があります。 まず最初に必要なのは、 マウスがどのプロトコルを使っているのかを確認することです。 ほとんどのホイールマウスは "IntelliMouse" プロトコルを使用していますが、 XFree86 サーバはその他のプロトコル、 たとえば Logitech MouseMan+ マウスが利用している "MouseManPlusPS/2" プロトコルなどもサポートしています。 使用されているプロトコルが確認できたら "Pointer" セクションに <code>Protocol</code> の行を追加してください。</p></div><div class=paragraph><p>つぎに、 ホイールのスクロールイベントをマウスボタン 4、 マウスボタン 5 に割り当てることを X サーバに伝えます。 これを行なうには <code>ZAxisMapping</code> オプションを使用します。</p></div><div class=paragraph><p>たとえば、<a href="https://man.freebsd.org/cgi/man.cgi?query=moused&amp;sektion=8&amp;format=html">moused(8)</a> が起動していない状態で、 PS/2 マウスポートに IntelliMouse が接続されているとしたら <span class=filename>/etc/XF86Config</span> はおそらく次のようになります。</p></div></li></ol></div></li><li><p>X サーバによる変換を利用してホイールマウスを使用するための XF86Config の "Pointer" セクションの設定例</p><div class=exampleblock><div class=content><div class="literalblock programlisting"><div class=content><pre>Section &#34;Pointer&#34;
  Protocol        &#34;IntelliMouse&#34;
  Device          &#34;/dev/psm0&#34;
  ZAxisMapping    4 5
EndSection</pre></div></div></div></div></li><li><p>imwheel のインストール</p><div class=paragraph><p>さて、つぎに Ports Collection から imwheel をインストールします。 これがあるのは <span class=filename>x11</span> カテゴリです。 このプログラムは、 マウスイベントをキーボードイベントに変換します。 たとえば、マウスホイールを前に回した時、 imwheel は <kbd>PageUp</kbd> をアプリケーションプログラムに送るような動作をするわけです。 Imwheel はホイールイベントとキーボード押下の対応を設定ファイルを使って設定するため、 アプリケーション毎に異なる対応を持たせることも可能です。 imwheel のデフォルトの設定ファイルは <span class=filename>/usr/X11R6/etc/imwheelrc</span> にインストールされます。 これを <span class=filename>~/.imwheelrc</span> にコピーして編集し、 お好きなように imwheel で利用したいアプリケーションの設定をカスタマイズしてください。 設定ファイルの書式は <a href="https://man.freebsd.org/cgi/man.cgi?query=imwheel&amp;sektion=1&amp;format=html">imwheel(1)</a> に説明されています。</p></div></li><li><p>Emacs で Imwheel を使うように設定する (<em>必須ではありません</em>)</p><div class=paragraph><p>emacs や Xemacs で利用するには、 <span class=filename>~/.emacs</span> にいくらか書き加える必要があります。 emacs の場合は次の部分を追加してください。</p></div><div class=exampleblock><div class=title>例 4. Imwheel を利用するための Emacs の設定例</div><div class=content><div class="literalblock programlisting"><div class=content><pre>;;; For imwheel
(setq imwheel-scroll-interval 3)
(defun imwheel-scroll-down-some-lines ()
(interactive)
(scroll-down imwheel-scroll-interval))
(defun imwheel-scroll-up-some-lines ()
(interactive)
(scroll-up imwheel-scroll-interval))
(global-set-key [?\M-\C-\)] &#39;imwheel-scroll-up-some-lines)
(global-set-key [?\M-\C-\(] &#39;imwheel-scroll-down-some-lines)
;;; end imwheel section</pre></div></div></div></div><div class=paragraph><p>Xemacs の場合は <span class=filename>~/.emacs</span> に次の部分を追加してください。</p></div><div class=exampleblock><div class=title>例 5. Imwheel を利用するための XEmacs の設定例</div><div class=content><div class="literalblock programlisting"><div class=content><pre>;;; For imwheel
(setq imwheel-scroll-interval 3)
(defun imwheel-scroll-down-some-lines ()
(interactive)
(scroll-down imwheel-scroll-interval))
(defun imwheel-scroll-up-some-lines ()
(interactive)
(scroll-up imwheel-scroll-interval))
(define-key global-map [(control meta \))] &#39;imwheel-scroll-up-some-lines)
(define-key global-map [(control meta \()] &#39;imwheel-scroll-down-some-lines)
;;; end imwheel section</pre></div></div></div></div></li><li><p>Imwheel の実行</p><div class=paragraph><p>インストールが完了していれば、単に xterm (訳注: 日本語環境で広く使われている kterm でも構いません) から <code>imwheel</code> を入力するだけで起動できます。 起動するとバックグラウンドで動作し、すぐに利用できます。 imwheel をいつも使うように設定するには、 <span class=filename>.xinitrc</span> か <span class=filename>.xsession</span> のファイルにそのままコマンドを追加してください。 imwheel が PID ファイルに関する警告を表示するかも知れませんが、 無視しても危険はありません。この警告が意味を持つのは、 Linux 版の imwheel だけです。</p></div></li></ol></div></div><div class=sect2><h3 id=_x_のメニューやダイアログボックスがうまく動きません>8.5. X のメニューやダイアログボックスがうまく動きません。<a class=anchor href=#_x_のメニューやダイアログボックスがうまく動きません></a></h3><div class=paragraph><p>Num Lock キーをオフにしてください。</p></div><div class=paragraph><p>Num Lock キーがデフォルトで起動時にオンになる場合は、 <span class=filename>XF86Config</span> ファイルの <code>Keyboard</code> セクションに以下の行を加えてもいいでしょう。</p></div><div class="literalblock programlisting"><div class=content><pre># Let the server do the NumLock processing.  This should only be
# required when using pre-R6 clients
  ServerNumLock</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>この問題は XFree86 3.2 以降では解決しています。</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=_仮想コンソールとは何ですか_どうやったら使えますか>8.6. 仮想コンソールとは何ですか? どうやったら使えますか?<a class=anchor href=#_仮想コンソールとは何ですか_どうやったら使えますか></a></h3><div class=paragraph><p>仮想コンソールは、簡単にいうと、ネットワークや X を動かすなどの複雑なことを行なわずに、 いくつかのセッションを同時に行なうことを可能にします。</p></div><div class=paragraph><p>システムのスタート時には、 起動メッセージが出た後に login プロンプトが表示されます。そこで ログイン名とパスワードを入力すると 1 番目の仮想コンソール上で仕事 (あるいは遊び) を始めることができます。</p></div><div class=paragraph><p>他のセッションを始めたい場合もあるでしょう。 それは動かしているプログラムのドキュメントを見たり、 FTP の転送が終わるまで待つ間、 メールを読もうとしたりすることかもしれません。 <kbd>Alt</kbd>-<kbd>F2</kbd> を押す (<kbd>Alt</kbd> キーを押しながら <kbd>F2</kbd> キーを押す) と、 2 番目の「仮想コンソール」で ログインプロンプトが待機していることがわかります。 最初のセッションに戻りたいときは <kbd>Alt</kbd>-<kbd>F1</kbd> を押します。</p></div><div class=paragraph><p>標準の FreeBSDインストールでは、 3 枚 (3.3-RELEASE では 8 枚) の仮想コンソールが有効になっていて、 <kbd>Alt</kbd>-<kbd>F1</kbd>、 <kbd>Alt</kbd>-<kbd>F2</kbd>、 <kbd>Alt</kbd>-<kbd>F3</kbd> で仮想コンソール間の切替えを行ないます。</p></div><div class=paragraph><p>より多くの仮想コンソールを有効にするには、 <span class=filename>/etc/ttys</span> (<a href="https://man.freebsd.org/cgi/man.cgi?query=ttys&amp;sektion=5&amp;format=html">ttys(5)</a> 参照) を編集して "Virtual terminals" のコメント行の後に <span class=filename>ttyv4</span> から <span class=filename>ttyvc</span> の手前までのエントリを加えます (以下の例は先頭には空白は入りません)。</p></div><div class="literalblock programlisting"><div class=content><pre># /etc/ttys には ttyv3 がありますので
# &#34;off&#34; を &#34;on&#34; に変更します。
ttyv3   &#34;/usr/libexec/getty Pc&#34;         cons25  on secure
ttyv4   &#34;/usr/libexec/getty Pc&#34;         cons25  on secure
ttyv5   &#34;/usr/libexec/getty Pc&#34;         cons25  on secure
ttyv6   &#34;/usr/libexec/getty Pc&#34;         cons25  on secure
ttyv7   &#34;/usr/libexec/getty Pc&#34;         cons25  on secure
ttyv8   &#34;/usr/libexec/getty Pc&#34;         cons25  on secure
ttyv9   &#34;/usr/libexec/getty Pc&#34;         cons25  on secure
ttyva   &#34;/usr/libexec/getty Pc&#34;         cons25  on secure
ttyvb   &#34;/usr/libexec/getty Pc&#34;         cons25  on secure</pre></div></div><div class=paragraph><p>多くするか少なくするかはあなたの自由です。 より多くの仮想ターミナルを使うとより多くのリソースを使うことになります。 8MB 以下のメモリしかない場合はこれは重要な問題です。 もし必要があれば <code>secure</code> を <code>insecure</code> に変更してください。</p></div><div class="admonitionblock important"><table><tbody><tr><td class=icon><i class="fa icon-important" title=Important></i></td><td class=content><div class=paragraph><p>X を使いたいのであれば、 最低一つの仮想ターミナル (のエントリ) を使わずに残しておくか、 off にしておく必要があります。 つまり、12 個の <kbd>Alt</kbd>-ファンクションキーすべてでログインプロンプトを 出したいのならば、 残念ながら X は利用できないということです。 同じマシンで X サーバーも動かしたいのならば 11 個しか使えません。</p></div></td></tr></tbody></table></div><div class=paragraph><p>仮想コンソールを無効にするもっとも簡単な方法は、 コンソールを off にすることです。 たとえば 12 個すべてのターミナルを割り当てている状態で X を動かしたいときは、 仮想ターミナル 12 を変更します。</p></div><div class="literalblock programlisting"><div class=content><pre>ttyvb   &#34;/usr/libexec/getty Pc&#34;         cons25  on secure</pre></div></div><div class=paragraph><p>これを次のように変更します。</p></div><div class="literalblock programlisting"><div class=content><pre>ttyvb   &#34;/usr/libexec/getty Pc&#34;         cons25  off secure</pre></div></div><div class=paragraph><p>キーボードにファンクションキーが 10 個しかないのであれば、 次のように設定します。</p></div><div class="literalblock programlisting"><div class=content><pre>ttyv9   &#34;/usr/libexec/getty Pc&#34;         cons25  off secure
ttyva   &#34;/usr/libexec/getty Pc&#34;         cons25  off secure
ttyvb   &#34;/usr/libexec/getty Pc&#34;         cons25  off secure</pre></div></div><div class=paragraph><p>(これらの行を消すだけでもいいです。)</p></div><div class=paragraph><p><span class=filename>/etc/ttys</span> を編集したら、 次は十分な数の仮想ターミナルデバイスを作らなくてはなりません。 もっとも簡単な方法を示します。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /dev</span>
<span class=c># ./MAKEDEV vty12(12 個のデバイスをつくる場合)</span></code></pre></div></div><div class=paragraph><p>さて、仮想コンソールを有効にするもっとも簡単 (そして確実) な方法は、 再起動することです。しかし、再起動したくない場合は、 X ウィンドウシステムを終了させて次の内容を (<code>root</code>権限で) 実行します。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kill -HUP 1</span></code></pre></div></div><div class=paragraph><p>重要な点は、 このコマンドを実行する前に X ウィンドウシステムを完全に終了させておくことです。 もしそうしないと <code>kill</code> コマンドを実行した後、 システムはおそらくハングアップするでしょう。</p></div></div><div class=sect2><h3 id=_x_から仮想コンソールに切替えるにはどうすればよいのですか>8.7. X から仮想コンソールに切替えるにはどうすればよいのですか?<a class=anchor href=#_x_から仮想コンソールに切替えるにはどうすればよいのですか></a></h3><div class=paragraph><p>仮想コンソールへ戻るには <span class=keyseq><kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>Fn</kbd></span> を使ってください。 最初の仮想コンソールへは <span class=keyseq><kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>F1</kbd></span> で戻れます。</p></div><div class=paragraph><p>テキストコンソールへ移った後は、その中で移動するのに 今度はいつもどおり <span class=keyseq><kbd>Alt</kbd>+<kbd>Fn</kbd></span> を使ってください。</p></div><div class=paragraph><p>X のセッションへ戻るには X の走っている仮想コンソールへ 切り替える必要があります。もしあなたが X をコマンドラインから 実行していたのであれば (たとえば <code>startx</code> を使う) X のセッションはそれを実行したテキストコンソールではなく 最初の使われていない仮想コンソールに割り当てられているはずです。 あなたが仮想端末を 8 個用意している場合は X を 9 番目の コンソールにいるはずで、 <span class=keyseq><kbd>Alt</kbd>+<kbd>F9</kbd></span> を使うことになります。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>X に戻るには、 3 枚の仮想コンソールが有効になっている場合は <kbd>Alt</kbd>-<kbd>F4</kbd> です。 有効な仮想コンソールの数 +1 のファンクションキーの 位置に X が割り当てられます。</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=xdm-boot>8.8. XDM を起動時に起動させるにはどうしますか?<a class=anchor href=#xdm-boot></a></h3><div class=paragraph><p><a href="http://www.FreeBSD.org/cgi/man.cgi?manpath=xfree86&amp;query=xdm">xdm</a> の起動方法については二つの流派があります。 一方の流派では提供された例を使用して xdm を <span class=filename>/etc/ttys</span> (<a href="https://man.freebsd.org/cgi/man.cgi?query=ttys&amp;sektion=5&amp;format=html">ttys(5)</a> 参照) から起動し、もう一方の流派では xdm を単に <span class=filename>rc.local</span> (<a href="https://man.freebsd.org/cgi/man.cgi?query=rc&amp;sektion=8&amp;format=html">rc(8)</a> 参照) または <span class=filename>/usr/local/etc/rc.d</span> においた <span class=filename>X.sh</span> スクリプトから起動します。 どちらも正しく、片方が動作しない場合は、もう片方が動作するでしょう。 どちらも場合でも結果は同じであり、X はグラフィカルな <code>login:</code> プロンプトを表示します。</p></div><div class=paragraph><p><span class=filename>ttys</span> を利用する方法の利点は、 どの vty で X が起動したかの記録が残せることと、 ログアウト時に X サーバを再起動する責任を init に押しつけることができることでしょう。</p></div><div class=paragraph><p><span class=filename>rc.local</span> からロードされる場合、 <code>xdm</code> は引数を持たずに (すなわち、デーモンとして) 起動します。 <code>xdm</code> は <code>getty</code> が起動した後にロードされなければなりません。 そうでないと、<code>xdm</code> は <code>getty</code> と衝突し、コンソールをロックアウトしてしまいます。 この問題に対処する最善の方法は、 起動スクリプト (訳注: <span class=filename>rc.local</span> のこと) で 10 秒ほどの <code>sleep</code> を実行させ、 その後に <code>xdm</code> をロードすることです。</p></div><div class=paragraph><p><span class=filename>/etc/ttys</span> から <code>xdm</code> を起動させている場合には、 <code>xdm</code> と <code>getty</code> が衝突する可能性があります。 この問題を回避するには、<span class=filename>/usr/X11R6/lib/X11/xdm/Xservers</span> に <code>vt</code> 番号を追加してください。</p></div><div class="literalblock programlisting"><div class=content><pre>:0 local /usr/X11R6/bin/X vt4</pre></div></div><div class=paragraph><p>上の例は、<span class=filename>/dev/ttyv3</span> を X サーバに対応させます。番号は 1 から始まりますので注意してください。 X サーバは vty を 1 から数えますが、 FreeBSD カーネルは vty を 0 から数えます。</p></div></div><div class=sect2><h3 id=_xconsole_を動かそうとすると_couldnt_open_console_とエラーが出ます>8.9. xconsole を動かそうとすると Couldn’t open console とエラーが出ます。<a class=anchor href=#_xconsole_を動かそうとすると_couldnt_open_console_とエラーが出ます></a></h3><div class=paragraph><p>X を <code>startx</code> で起動しますと、<span class=filename>/dev/console</span> のパーミッションは <em>変更できない</em>ようになっていますので、 <code>xterm -C</code> や <code>xconsole</code> は動きません。</p></div><div class=paragraph><p>これはコンソールのパーミッションが、 標準ではそのように設定されているからです。 マルチユーザシステムでは、 ユーザの誰もがシステムコンソールに書き込むことが可能である必要は必ずしもありません。 VTY を使い直接マシンにログインするユーザのために、 このような問題を解決するために <a href="https://man.freebsd.org/cgi/man.cgi?query=fbtab&amp;sektion=5&amp;format=html">fbtab(5)</a> というファイルがあります。</p></div><div class=paragraph><p>要点を述べると、次のような形式の行を <span class=filename>/etc/fbtab</span> (<a href="https://man.freebsd.org/cgi/man.cgi?query=fbtab&amp;sektion=5&amp;format=html">fbtab(5)</a> 参照) に加えます。</p></div><div class="literalblock programlisting"><div class=content><pre>/dev/ttyv0 0600 /dev/console</pre></div></div><div class=paragraph><p>そうすると、 <span class=filename>/dev/ttyv0</span> からログインしたユーザが コンソールを所有することになるでしょう。</p></div></div><div class=sect2><h3 id=_わたしはいつも_xfree86_を一般ユーザから起動していたのですが_最近になって_root_ユーザでなければな_らないと言われるようになりました>8.10. わたしはいつも XFree86 を一般ユーザから起動していたのですが、 最近になって root ユーザでなければな らないと言われるようになりました。<a class=anchor href=#_わたしはいつも_xfree86_を一般ユーザから起動していたのですが_最近になって_root_ユーザでなければな_らないと言われるようになりました></a></h3><div class=paragraph><p>すべての X サーバは、 ビデオハードウェアに直接アクセスするために <code>root</code> ユーザで実行される必要があります。 古いバージョンの XFree86 (⇐ 3.3.6) に含まれるすべてのサーバは、 自動的に <code>root</code> 権限で実行されるように (<code>root</code> ユーザに setuid されて) インストールされます。 X サーバは大きく複雑なプログラムであり、 これは明らかにセキュリティを危険に晒す要因となります。 そのため新しいバージョンの XFree86 では、 サーバを <code>root</code> ユーザに setuid しないでインストールするようになりました。</p></div><div class=paragraph><p>X サーバを root ユーザで動かすというのは、 明らかにセキュリティ的に不適当で受け入れられないことです。 X を一般ユーザで実行するには、二つの方法があります。 一つは <code>xdm</code> や、その他のディスプレイマネージャ (たとえば <code>kdm</code> など) を使うこと、 もう一つは <code>Xwrapper</code> を使うことです。</p></div><div class=paragraph><p><code>xdm</code> は、 グラフィカルなログイン画面を扱うデーモンです。 通常、起動時に実行され、 各ユーザの認証とユーザセションを開始させる機能を実現します。 基本的に、<code>getty</code> と <code>login</code> のグラフィック版、と考えて良いでしょう。 <code>xdm</code> の詳細については、 <a href=http://www.xfree86.org/support.html>XFree86 関連文書</a> および <a href=#xdm-boot>FAQ 項目</a>をご覧ください。</p></div><div class=paragraph><p><code>Xwrapper</code> とは、X サーバ用のラッパ (wrapper) のことです。 これは必要なセキュリティを確保しつつ、一般ユーザが X サーバを実行できるようにした小さなユーティリティで、 コマンドライン引数の正当性チェックを行ない、 それを通過すれば適切な X サーバを起動します。 何らかの理由でディスプレイマネージャを使いたくない場合に これを使うと良いでしょう。 Ports Collection 全体をインストールしていれば、 <span class=filename>/usr/ports/x11/wrapper</span> にあります。</p></div></div><div class=sect2><h3 id=_私の_ps2_マウスは_x_ウィンドウシステム上でうまく動きません>8.11. 私の PS/2 マウスは X ウィンドウシステム上でうまく動きません。<a class=anchor href=#_私の_ps2_マウスは_x_ウィンドウシステム上でうまく動きません></a></h3><div class=paragraph><p>あなたのマウスとマウスドライバがうまく同期していないからかもしれません。</p></div><div class=paragraph><p>FreeBSD 2.2.5 までのバージョンでは、X から仮想ターミナルへ切替えて、 また X へ戻ると再同期するかもしれません。 この問題がよく起きるようであれば、カーネルコンフィグレーション ファイルに次のオプションを書いてカーネルを再構成してみてください。</p></div><div class="literalblock programlisting"><div class=content><pre>options PSM_CHECKSYNC</pre></div></div><div class=paragraph><p>もし、カーネルの再構築を行なったことがないのであれば、 <a href=#make-kernel>カーネルを構築する</a>の項を参照してください。</p></div><div class=paragraph><p>このオプションにより、 マウスとドライバの同期で問題が起きる可能性は少なくなるでしょう。 もしそれでもこの問題が起きるようならば、 再同期させるにはマウスを動かさないようにしておいて マウスボタンのどれかを押してください。</p></div><div class=paragraph><p>このオプションは残念ながらすべてのシステムで働くわけではなく、 また、PS/2 マウスポートにつながれているのが タップ (tap) 機能を持つ アルプス社製 GlidePoint デバイスの場合、 タップ機能が無効となってしまいます。</p></div><div class=paragraph><p>FreeBSD 2.2.6 以降のバージョンでは、 同期のチェック方法が少し改善されたので標準で有効になっています。 GlidePoint でもうまく働きます (同期チェックが標準の機能になったので <code>PSM_CHECKSYNC</code> オプションはこれらのバージョンからは削除されました)。 しかしながら、 まれにドライバが間違って (訳注: 問題がないのに) 同期に関して問題があると報告し、カーネルから</p></div><div class="literalblock programlisting"><div class=content><pre>psmintr: out of sync (xxxx != yyyy)</pre></div></div><div class=paragraph><p>というメッセージが出力されて、マウスが正しく動作していないように見える ことがあるかもしれません。</p></div><div class=paragraph><p>もしこのようなことが起こる場合には、PS/2 マウスドライバのフラグに 0x100 を指定して同期チェックを無効にしてください。システムの起動時に “-c” 起動オプションを与えて <em>UserConfig</em> に入ります。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>boot: <span class=nt>-c</span></code></pre></div></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>boot: <span class=nt>-c</span></code></pre></div></div><div class=paragraph><p><em>UserConfig</em> のコマンドラインで以下のように入力してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>UserConfig&gt; flags psm0 0x100
UserConfig&gt; quit</code></pre></div></div></div><div class=sect2><h3 id=_mousesystems_の_ps2_マウスがうまく動きません>8.12. MouseSystems の PS/2 マウスがうまく動きません。<a class=anchor href=#_mousesystems_の_ps2_マウスがうまく動きません></a></h3><div class=paragraph><p>MouseSystems の PS/2 マウスのあるモデルは、 高解像度モードの場合にのみ正しく動作するということが報告されています。 それ以外のモードでは、 マウスカーソルがしょっちゅうスクリーン左上に行ってしまうかもしれません。</p></div><div class=paragraph><p>残念ながら FreeBSD 2.0.X や 2.1.X のバージョンでは、 この問題を解決する方法はありません。 2.2 から 2.2.5 のバージョンでは、 以下のパッチを <span class=filename>/sys/i386/isa/psm.c</span> に適用しカーネルの再構築を行なってください。</p></div><div class=paragraph><p>もし、カーネルの再構築を行なったことがないのであれば、 <a href=#make-kernel>カーネルの構築</a>の項を参照してください。</p></div><div class="literalblock programlisting"><div class=content><pre>@@ -766,6 +766,8 @@
    if (verbose &gt;= 2)
        log(LOG_DEBUG, &#34;psm%d: SET_DEFAULTS return code:%04x\n&#34;,
            unit, i);
+    set_mouse_resolution(sc-&gt;kbdc, PSMD_RES_HIGH);
+
#if 0
    set_mouse_scaling(sc-&gt;kbdc);    /* 1:1 scaling */
    set_mouse_mode(sc-&gt;kbdc);               /* stream mode */</pre></div></div><div class=paragraph><p>FreeBSD 2.2.6 以降のバージョンでは、 PS/2 マウスドライバのフラグに 0x04 を指定してマウスを高解像度モードにします。 システムの起動時に <code>-c</code> 起動オプションを与えて <em>UserConfig</em> に入ります。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>boot: <span class=nt>-c</span></code></pre></div></div><div class=paragraph><p><em>UserConfig</em> のコマンドラインで以下のように入力してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>UserConfig&gt; flags psm0 0x04
UserConfig&gt; quit</code></pre></div></div><div class=paragraph><p>マウスに関する不具合の他の原因の可能性については、 直前のセクションも見てみてください。</p></div></div><div class=sect2><h3 id=_x_のアプリケーションを構築する時に_imake_cant_find_imake_tmpl_となりますどこにあるのでしょうか>8.13. X のアプリケーションを構築する時に、 imake can’t find Imake.tmpl となります。どこにあるのでしょうか?<a class=anchor href=#_x_のアプリケーションを構築する時に_imake_cant_find_imake_tmpl_となりますどこにあるのでしょうか></a></h3><div class=paragraph><p><span class=filename>Imake.tmpl</span> は X の標準アプリケーション構築ツールである Imake パッケージの一部です。 <span class=filename>Imake.tmpl</span> は、 X アプリケーションの構築に必要な多くのヘッダファイルと同様に、 X のプログラムディストリビューションに含まれています。 <code>sysinstall</code> を使うか、 手動で X のディストリビューションファイルからインストールすることができます。</p></div></div><div class=sect2><h3 id=_マウスのボタンを入れ替える方法はありますか>8.14. マウスのボタンを入れ替える方法はありますか?<a class=anchor href=#_マウスのボタンを入れ替える方法はありますか></a></h3><div class=paragraph><p><span class=filename>.xinitrc</span> か <span class=filename>.xsession</span> で</p></div><div class="literalblock programlisting"><div class=content><pre>xmodmap -e &#34;pointer = 3 2 1&#34;</pre></div></div><div class=paragraph><p>というコマンドを実行してください。</p></div></div><div class=sect2><h3 id=_スプラッシュスクリーンのインストールはどうするのですか_どこで見つけることができますか>8.15. スプラッシュスクリーンのインストールはどうするのですか。 どこで見つけることができますか?<a class=anchor href=#_スプラッシュスクリーンのインストールはどうするのですか_どこで見つけることができますか></a></h3><div class=paragraph><p>FreeBSD 3.1 のリリース直前に、起動メッセージの表示期間に いわゆる "スプラッシュ" スクリーンを表示させることができる新しい機能が追加されました。 いまのところスプラッシュスクリーンは 256 色のビットマップ (<span class=filename>*.BMP</span>) か ZSoft PCX (<span class=filename>*.PCX</span>) ファイルです。 それに加えて、標準の VGA アダプタでの動作させるには 320x200 以下の解像度である必要があります。 カーネルに VESA サポートを追加すれば 1024x768 までのより大きいビットマップを使用できます。 VESA サポートを有効化するにはまず、 カーネルが <code>VM86</code> カーネルオプションとともにコンパイルされている必要があることに注意してください。 VESA サポートそのものは <code>VESA</code> カーネルコンフィグオプション によって直接カーネル中にコンパイルするか、 起動時に VESA kld モジュールを読み込ませることができます。</p></div><div class=paragraph><p>スプラッシュスクリーンを使うには、 FreeBSD の起動プロセスをコントロールするスタートアップファイルを書き換える必要があります。 これらのファイルは FreeBSD 3.2 のリリース以前に変更されましたので、 現在は、スプラッシュスクリーンを読み込む方法が二つあります。</p></div><div class=ulist><ul><li><p>FreeBSD 3.1 の場合</p><div class=paragraph><p>まず最初のステップは、 スプラッシュスクリーンのビットマップ版を探してくることです。 3.1-RELEASE では Windows のビットマップ形式のスプラッシュスクリーンだけをサポートしています。 お望みのスプラッシュスクリーンを見つけたなら、それを <span class=filename>/boot/splash.bmp</span> にコピーします。次に、これらの行が書かれた <span class=filename>/boot/loader.rc</span> ファイルが必要です。</p></div><div class="literalblock programlisting"><div class=content><pre>load kernel
load -t splash_image_data /boot/splash.bmp
load splash_bmp
autoboot</pre></div></div></li><li><p>FreeBSD 3.2 以降の場合</p><div class=paragraph><p>PCX 形式のスプラッシュスクリーンのサポートが追加されると同時に、 FreeBSD 3.2 には起動プロセスを設定する、 より洗練された方法が含まれています。 もしお望みなら、上に示した FreeBSD 3.1 用の方法を使うこともできます。 もしそうしたくて、かつ PCX 形式を使いたいなら、 <code>splash_bmp</code> を <code>splash_pcx</code> と読み換えてください。 そうではなくて、新しい起動設定方法を使うのなら、 次の数行が書かれた <span class=filename>/boot/loader.rc</span> ファイルと、</p></div><div class="literalblock programlisting"><div class=content><pre>include /boot/loader.4th
start</pre></div></div><div class=paragraph><p>次の数行が含まれた <span class=filename>/boot/loader.conf</span> ファイルを作ることが必要です。</p></div><div class="literalblock programlisting"><div class=content><pre>splash_bmp_load=&#34;YES&#34;
bitmap_load=&#34;YES&#34;</pre></div></div><div class=paragraph><p>この例では、スプラッシュスクリーンとして <span class=filename>/boot/splash.bmp</span> を使うことを想定しています。PCX 形式のファイルを使う場合には、 そのファイルを <span class=filename>/boot/splash.pcx</span> にコピーして、 上で示したように <span class=filename>/boot/loader.rc</span> を作ります。 そして、次の内容の <span class=filename>/boot/loader.conf</span> というファイルを作ってください。</p></div><div class="literalblock programlisting"><div class=content><pre>splash_pcx_load=&#34;YES&#34;
bitmap_load=&#34;YES&#34;
bitmap_name=&#34;/boot/splash.pcx&#34;</pre></div></div></li></ul></div><div class=paragraph><p>さて、あとはスプラッシュスクリーンを用意するだけです。 それには <a href=http://www.baldwin.cx/splash/>http://www.baldwin.cx/splash/</a> のギャラリーをサーフしてみてください。</p></div></div><div class=sect2><h3 id=_x_で_windows_キーを使うことはできるのでしょうか>8.16. X で Windows™ キーを使うことはできるのでしょうか?<a class=anchor href=#_x_で_windows_キーを使うことはできるのでしょうか></a></h3><div class=paragraph><p>はい、もちろん。 どういう動作をするかについて定義するには <a href="https://man.freebsd.org/cgi/man.cgi?query=xmodmap&amp;sektion=1&amp;format=html">xmodmap(1)</a> を使います。</p></div><div class=paragraph><p>標準的な "Windows™" キーボードの場合、 対応するキーコードは 3 種類あります。</p></div><div class=ulist><ul><li><p>115 - 左の Ctrl と Alt の間にある Windows™ キー</p></li><li><p>116 - 右の Alt と Gr の間にある Windows™ キー</p></li><li><p>117 - 右の Ctrl の左隣にあるメニューキー</p></li></ul></div><div class=paragraph><p>左にある Windows™ キーを押すとカンマ記号が入力されるようにするには、 こんな風にします。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># xmodmap -e &#34;keycode 115 = comma&#34;</span></code></pre></div></div><div class=paragraph><p>設定を反映させるには、おそらくウィンドウマネージャを再起動する必要があります。</p></div><div class=paragraph><p>Windows™ キーのキーマップを X 起動時に毎回、 自動的に有効化するには <code>xmodmap</code> コマンドを <span class=filename>~/.xinitrc</span> に追加するか、 もしくはおすすめできる方法として <span class=filename>~/.xmodmaprc</span> というファイルを作成して、 そのファイルの一行一行に <code>xmodmap</code> のオプションを記述し、次の一行</p></div><div class="literalblock programlisting"><div class=content><pre>xmodmap $HOME/.xmodmaprc</pre></div></div><div class=paragraph><p>を <span class=filename>~/.xinitrc</span> に追加するという方法があります。</p></div><div class=paragraph><p>たとえば、先ほどあげた三つのキーを F13、F14、F15 に割り当てるとします。 こうしておけば、後ほど示すように、アプリケーションや ウィンドウマネージャの便利な機能を その三つのキーに簡単に割り当てることができます。</p></div><div class=paragraph><p>こうするには、次の内容を <span class=filename>~/.xmodmaprc</span> に追加します。</p></div><div class="literalblock programlisting"><div class=content><pre>keycode 115 = F13
keycode 116 = F14
keycode 117 = F15</pre></div></div><div class=paragraph><p>たとえば <code>fvwm2</code> を使っていたら、 F13 をカーソル下のウィンドウのアイコン化、 F14 をウィンドウの前面/背面化、 F15 を、あたかもデスクトップにカーソルが存在しないかのように、 メインワークスペース (アプリケーション) のメニューを呼び出せる機能に割り当てられます。 最後の機能は、そのデスクトップがまったく見えないときに便利です。 (また、キートップのロゴにもぴったりです)</p></div><div class=paragraph><p><span class=filename>~/.fvwmrc</span> の次のエントリは、前述の 設定を実現します。</p></div><div class="literalblock programlisting"><div class=content><pre>Key F13        FTIWS    A        Iconify
Key F14        FTIWS    A        RaiseLower
Key F15        A        A        Menu Workplace Nop</pre></div></div></div></div></div><div class=sect1><h2 id=networking>9. ネットワーキング<a class=anchor href=#networking></a></h2><div class=sectionbody><div class=sect2><h3 id=_ディスクレスブート_diskless_boot_に関する情報はどこで得られますか>9.1. ディスクレスブート (diskless boot) に関する情報はどこで得られますか?<a class=anchor href=#_ディスクレスブート_diskless_boot_に関する情報はどこで得られますか></a></h3><div class=paragraph><p>"ディスクレスブート (diskless boot)" というのは、FreeBSD がネットワーク上で起動し、 必要なファイルを自分のハードディスクではなくてサーバから読み込むものです。 詳細については <a href=https://docs.freebsd.org/ja/books/handbook/boot#diskless>FreeBSD ハンドブックの「ディスクレスブート」</a>を読んでください。</p></div></div><div class=sect2><h3 id=_freebsd_をネットワークのルータ_router_として使用することはできますか>9.2. FreeBSD をネットワークのルータ (router) として使用することはできますか?<a class=anchor href=#_freebsd_をネットワークのルータ_router_として使用することはできますか></a></h3><div class=paragraph><p>インターネット標準やこれまでのよい経験によって指摘されている通り、 FreeBSD は標準ではパケットを転送 (forward) するように設定されていません。 しかし、 <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a> の中で次の変数の値を <code>YES</code> とする事によってこの機能を有効にすることができます。</p></div><div class="literalblock programlisting"><div class=content><pre>gateway_enable=YES          # Set to YES if this host will be a gateway</pre></div></div><div class=paragraph><p>このオプションによって <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> の変数 <code>net.inet.ip.forwarding</code> が <code>1</code> になります。</p></div><div class=paragraph><p>ほとんどの場合、 ルータについての情報を同じネットワークの他の計算機等に知らせるために、 経路制御のためのプロセスを走らせる必要があるでしょう。 FreeBSD には BSD の標準経路制御デーモンである <a href="https://man.freebsd.org/cgi/man.cgi?query=routed&amp;sektion=8&amp;format=html">routed(8)</a> が付属していますが、より複雑な状況に対処するためには GaTeD(<a href=http://www.gated.org/>http://www.gated.org/</a> から入手可能) を使用することもできます。 3_5Alpha7 において FreeBSD がサポートされています。</p></div><div class=paragraph><p>注意してほしいのは、FreeBSD をこのようにして使用している場合でも、 ルータに関するインターネット標準の必要条件を完全には満たしていない ということです。しかし、普通に使用する場合にはほとんど問題ありません。</p></div></div><div class=sect2><h3 id=_win95_の走っているマシンをfreebsd_経由でインターネットに接続できますか>9.3. Win95 の走っているマシンを、FreeBSD 経由でインターネットに接続できますか?<a class=anchor href=#_win95_の走っているマシンをfreebsd_経由でインターネットに接続できますか></a></h3><div class=paragraph><p>通常、この質問が出てくる状況は自宅に二台の PC があり、一台では FreeBSD が、もう一台では Win95 が走っているような場合です。 ここでやろうとしていう事は FreeBSD の走っている計算機をインターネット に接続し、Win95 の走っているマシンからは FreeBSD の走っているマシンを経由して接続を行なう事です。 これは二つ前の質問の特別な場合に相当します。</p></div><div class=paragraph><p>…​で、答えは「はい」です。 FreeBSD 3.x のユーザモード ppp には <code>-nat</code> オプションがあります。 ppp を <code>-nat</code> オプション付きで起動し、 <span class=filename>/etc/rc.conf</span> にある <code>gateway_enable</code> を <em>YES</em> に設定します。 そして Windows マシンを正しく設定すれば、 きちんと動作するでしょう。</p></div><div class=paragraph><p>設定に関するさらに詳しい情報は、 Steve Sims 氏による <a href=http://www.FreeBSD.org/tutorials/ppp/>Pedantic PPP Primer</a> にあります。</p></div><div class=paragraph><p>カーネルモード ppp を利用する場合や、 インターネットとのイーサネット接続が利用できる場合は、 <code>natd</code> を利用する必要があります。 この FAQ の <a href=#natd>natd</a> のセクションを参照してください。</p></div></div><div class=sect2><h3 id=_isc_からリリースされている_bind_の最新版はコンパイルできないんでしょうか>9.4. ISC からリリースされている BIND の最新版はコンパイルできないんでしょうか?<a class=anchor href=#_isc_からリリースされている_bind_の最新版はコンパイルできないんでしょうか></a></h3><div class=paragraph><p>BIND の配布物と FreeBSD とでは <span class=filename>cdefs.h</span> というファイルの中でデータ型の矛盾があります。 <span class=filename>compat/include/sys/cdefs.h</span> を削除してください。</p></div></div><div class=sect2><h3 id=_freebsd_で_slip_と_ppp_は使えますか>9.5. FreeBSD で SLIP と PPP は使えますか?<a class=anchor href=#_freebsd_で_slip_と_ppp_は使えますか></a></h3><div class=paragraph><p>使えます。FreeBSD を用いて他のサイトに接続する場合には、 <a href="https://man.freebsd.org/cgi/man.cgi?query=slattach&amp;sektion=8&amp;format=html">slattach(8)</a>、<a href="https://man.freebsd.org/cgi/man.cgi?query=sliplogin&amp;sektion=8&amp;format=html">sliplogin(8)</a>、<a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> そして <a href="https://man.freebsd.org/cgi/man.cgi?query=pppd&amp;sektion=8&amp;format=html">pppd(8)</a> のマニュアルページをご覧ください。 <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> と <a href="https://man.freebsd.org/cgi/man.cgi?query=pppd&amp;sektion=8&amp;format=html">pppd(8)</a> は、 PPP のサーバ、クライアント両方の機能を持っています。 その一方で、<a href="https://man.freebsd.org/cgi/man.cgi?query=sliplogin&amp;sektion=8&amp;format=html">sliplogin(8)</a> は SLIP のサーバ専用で、 <a href="https://man.freebsd.org/cgi/man.cgi?query=slattach&amp;sektion=8&amp;format=html">slattach(8)</a> は SLIP のクライアント専用です。</p></div><div class=paragraph><p>これらを使うためのさらなる情報については、<a href=https://docs.freebsd.org/ja/books/handbook/ppp-and-slip#ppp-and-slip>ハンドブックの PPP と SLIP の章</a>をご覧ください。</p></div><div class=paragraph><p>「シェルアカウント」を通じてのみインターネットへアクセス可能な場合、 slirp package みたいなものが欲しくなるかもしれませんね。 これを使えば、ローカルマシンから直接 ftp や http のようなサービスに (限定的ではありますが) アクセスすることができます。</p></div></div><div class=sect2><h3 id=_freebsd_は_nat_か_ip_マスカレードをサポートしていますか>9.6. FreeBSD は NAT か IP マスカレードをサポートしていますか?<a class=anchor href=#_freebsd_は_nat_か_ip_マスカレードをサポートしていますか></a></h3><div class=paragraph><p>ローカルなサブネット (一台以上のローカルマシン) を持っているが、 インターネットプロバイダから 1 つしか IP アドレスの割り当てを受けていない場合 (または IP アドレスを動的に割り当てられている場合でも)、 <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> プログラムを使いたくなるかもしれませんね。 <code>natd</code> を使えば、 1 つしか IP アドレスを持っていない場合でも、 サブネット全体をインターネットに接続させることができます。</p></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> も同様の機能を持っており、<code>-nat</code> スイッチで有効にすることができます。 どちらの場合も alias ライブラリ (<a href="https://man.freebsd.org/cgi/man.cgi?query=libalias&amp;sektion=3&amp;format=html">libalias(3)</a>) が使われます。</p></div></div><div class=sect2><h3 id=_deved0_デバイスを作成することができません>9.7. /dev/ed0 デバイスを作成することができません。<a class=anchor href=#_deved0_デバイスを作成することができません></a></h3><div class=paragraph><p>Berkeley UNIX におけるネットワークの構成において、 ネットワークのインタフェースはカーネルコードからのみ、 直接あつかうことができます。 より詳しく知りたい場合は、 <span class=filename>/etc/rc.network</span> というファイルや、 このファイルの中に書いてある、 さまざまなプログラムについてのマニュアルページを見てください。 それでもまだ分からない場合には、 他の BSD 系の OS のネットワーク管理についての本を読むべきでしょう。 ごく少しの例外をのぞいては、FreeBSD のネットワーク管理は SunOS 4.0 や Ultrix と基本的に同じです。</p></div></div><div class=sect2><h3 id=_ethernet_アドレスのエイリアス_alias_はどのようにして設定できますか>9.8. Ethernet アドレスのエイリアス (alias) はどのようにして設定できますか?<a class=anchor href=#_ethernet_アドレスのエイリアス_alias_はどのようにして設定できますか></a></h3><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a> のコマンドラインに <code>netmask 0xffffffff</code> を追加して、次のように書いてください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig ed0 alias 204.141.95.2 netmask 0xffffffff</span></code></pre></div></div></div><div class=sect2><h3 id=_3c503_で他のネットワークポートを使用するにはどのようにすればよいですか>9.9. 3C503 で他のネットワークポートを使用するにはどのようにすればよいですか?<a class=anchor href=#_3c503_で他のネットワークポートを使用するにはどのようにすればよいですか></a></h3><div class=paragraph><p>他のポートを使用したい場合には、 <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a> のコマンドラインにパラメータを追加しなければなりません。 デフォルトでは <code>link0</code> が用いられるようになっています。 BNC のかわりに AUI ポートを使用したい場合には、 <code>link2</code> というパラメータを追加してください。 これらのフラグは、 <span class=filename>/etc/rc.conf</span> (<a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a> 参照) にある ifconfig_* の変数を使って指定されるはずです。</p></div></div><div class=sect2><h3 id=_freebsd_との間で_nfs_がうまくできません>9.10. FreeBSD との間で NFS がうまくできません。<a class=anchor href=#_freebsd_との間で_nfs_がうまくできません></a></h3><div class=paragraph><p>PC 用のネットワークカードによっては、 NFS のような、 ネットワークを酷使するアプリケーションにおいて問題を起こすものがあります。</p></div><div class=paragraph><p>この点に関しては <a href=https://docs.freebsd.org/ja/books/handbook/>FreeBSD ハンドブックの「NFS」</a>を参照してください。</p></div></div><div class=sect2><h3 id=_何故_linux_のディスクを_nfs_マウントできないのでしょうか>9.11. 何故 Linux のディスクを NFS マウントできないのでしょうか?<a class=anchor href=#_何故_linux_のディスクを_nfs_マウントできないのでしょうか></a></h3><div class=paragraph><p>Linux の NFS のコードには、 許可されたポートからのリクエストしか受けつけないものがあります。 以下を試してみてください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount -o -P linuxbox:/blah /mnt</span></code></pre></div></div></div><div class=sect2><h3 id=_何故_sun_のディスクを_nfs_マウントできないのでしょうか>9.12. 何故 Sun のディスクを NFS マウントできないのでしょうか?<a class=anchor href=#_何故_sun_のディスクを_nfs_マウントできないのでしょうか></a></h3><div class=paragraph><p>SunOS 4.X が走っている Sun Workstation は、 許可されたポートからのマウント要求しか受けつけません。 以下を試してみてください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount -o -P sunbox:/blah /mnt</span></code></pre></div></div></div><div class=sect2><h3 id=_mountd_から_cant_change_attributes_というメッセージがずっと出続けていて_freebsd_の_nfs_サーバでは_bad_exports_list_と表示されますこれは何が原因なのでしょう>9.13. mountd から can’t change attributes というメッセージがずっと出続けていて、 FreeBSD の NFS サーバでは bad exports list と表示されます。これは何が原因なのでしょう?<a class=anchor href=#_mountd_から_cant_change_attributes_というメッセージがずっと出続けていて_freebsd_の_nfs_サーバでは_bad_exports_list_と表示されますこれは何が原因なのでしょう></a></h3><div class=paragraph><p>最も良くある問題は、<a href="https://man.freebsd.org/cgi/man.cgi?query=exports&amp;sektion=5&amp;format=html">exports(5)</a> のマニュアルページの以下の部分を正しく理解していないことです。</p></div><div class="paragraph blockquote"><p>このファイルの各行 (# ではじまるコメント行を除く) は、 NFS サーバのローカルファイルシステムに存在する、 他のホストにエクスポートされるマウントポイント (複数可) と、 それに対するエクスポートフラグを指定します。 特定のエクスポート先ホストおよび、 すべてのホストに適用されるデフォルトエントリは両方とも、 サーバの各ローカルファイルシステムに対して一回だけしか指定できません。</p></div><div class=paragraph><p>さて、ありがちな間違いをご覧になればはっきりするでしょう。 もし <span class=filename>/usr</span> 以下が単一のファイルシステムである (つまり <span class=filename>/usr</span> に何もマウントされない) 場合、 次の exports リストは正しくありません。</p></div><div class="literalblock programlisting"><div class=content><pre>/usr/src   client
/usr/ports client</pre></div></div><div class=paragraph><p>一つのファイルシステムに対して属性の指定が二行になっています。 <span class=filename>/usr</span> は同じホスト <code>client</code> にエクスポートされますから、 正しい書き方は次のようになります。</p></div><div class="literalblock programlisting"><div class=content><pre>/usr/src /usr/ports  client</pre></div></div><div class=paragraph><p>もう一度マニュアルページの文章を確認すると、 あるホストにエクスポートされる各ファイルシステムの属性は すべて一行に書かれていなければならない、となっています (ここでは、「アクセス可能なすべてのホスト」 も一つの独立したホストとして扱われることに注意してください)。 このことは、ファイルシステムをエクスポートするために 奇妙な書式を使わなければならない原因にもなっているのですが、 ほとんどの人にとって、これは問題にはならないでしょう。</p></div><div class=paragraph><p>次に示すのは、有効な exports リストの例です。 ここでは、<span class=filename>/usr</span> と <span class=filename>/exports</span> がローカルファイルシステムです。</p></div><div class="literalblock programlisting"><div class=content><pre># Export src and ports to client01 and client02, but only
# client01 has root privileges on it
/usr/src /usr/ports -maproot=0    client01
/usr/src /usr/ports               client02
# The &#34;client&#34; machines have root and can mount anywhere
# up /exports. The world can mount /exports/obj read-only
/exports -alldirs -maproot=0      client01 client02
/exports/obj -ro</pre></div></div></div><div class=sect2><h3 id=_ppp_で_nextstep_に接続する際に問題があるのですが>9.14. PPP で NeXTStep に接続する際に問題があるのですが。<a class=anchor href=#_ppp_で_nextstep_に接続する際に問題があるのですが></a></h3><div class=paragraph><p><span class=filename>/etc/rc.conf</span> (<a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a> 参照) の中で次の変数を NO にして、 TCP extension を無効にしてみてください。</p></div><div class="literalblock programlisting"><div class=content><pre>tcp_extensions=NO</pre></div></div><div class=paragraph><p>Xylogic の Annex も同様の問題がありますので、 Annex 経由で PPP を行なう場合にもこの変更を行ってください。</p></div></div><div class=sect2><h3 id=_ip_マルチキャスト_multicast_を有効にするには>9.15. IP マルチキャスト (multicast) を有効にするには?<a class=anchor href=#_ip_マルチキャスト_multicast_を有効にするには></a></h3><div class=paragraph><p>FreeBSD 2.0 かそれ以降では、 標準の状態で完全にマルチキャストに対応しています。 現在使用している計算機をマルチキャストのルータ (router) として使用するには、 <code>MROUTING</code> というオプションを定義したカーネルを作ったうえで、 <code>mrouted</code> を走らせる必要があります。2.2 かそれ以降の FreeBSD ならば、 <span class=filename>/etc/rc.conf</span> でフラグ <code>mrouted_enable</code> を <code>YES</code> にセットしておくことで、 起動時に <code>mrouted</code> を起動できます。</p></div><div class=paragraph><p>MBONE 用のツールは ports 内の専用のカテゴリー mbone にあります。 <code>vic</code> や <code>vat</code> といった会議用のツールを探している場合は、 この場所を見てください。</p></div><div class=paragraph><p>詳しい情報は <a href=http://www.mbone.com/>Mbone Information Web</a> にあります。</p></div></div><div class=sect2><h3 id=_dec_の_pci_チップセットを用いているネットワークカードには_どのような物がありますか>9.16. DEC の PCI チップセットを用いているネットワークカードには、 どのような物がありますか?<a class=anchor href=#_dec_の_pci_チップセットを用いているネットワークカードには_どのような物がありますか></a></h3><div class=paragraph><p><a href=mailto:gfoster@driver.nsta.org>Glen Foster 氏</a>による一覧に、 最近の製品を追加したものを以下に示します。</p></div><div class="literalblock programlisting"><div class=content><pre>Vendor          Model
----------------------------------------------
ASUS            PCI-L101-TB
Accton          ENI1203
Cogent          EM960PCI
Compex          ENET32-PCI
D-Link          DE-530
Dayna           DP1203, DP2100
DEC             DE435, DE450
Danpex          EN-9400P3
JCIS            Condor JC1260
Linksys         EtherPCI
Mylex           LNP101
SMC             EtherPower 10/100 (Model 9332)
SMC             EtherPower (Model 8432)
TopWare         TE-3500P
Znyx            (2.2.X) ZX312, ZX314, ZX342, ZX345, ZX346, ZX348
              (3.X) ZX345Q, ZX346Q, ZX348Q, ZX412Q, ZX414, ZX442,
                    ZX444, ZX474, ZX478, ZX212, ZX214 (10mbps/hd)</pre></div></div></div><div class=sect2><h3 id=_何故自分のサイトのホストに対して_fqdn_を使用する必要があるのですか>9.17. 何故自分のサイトのホストに対して FQDN を使用する必要があるのですか?<a class=anchor href=#_何故自分のサイトのホストに対して_fqdn_を使用する必要があるのですか></a></h3><div class=paragraph><p>実際にはそのホストは別のドメインにあるのではないですか。 たとえば、foo.bar.edu というドメインの中から、 <code>bar.edu</code> ドメインにある <code>mumble</code> というホストを指定したい場合には、 <code>mumble</code> だけではダメで、 <code>mumble.bar.edu</code> という FQDN (fully-qualified domain name) で指定しなければなりません。</p></div><div class=paragraph><p>伝統的に、BSD の BIND のリゾルバ (resolver) ではこのような事は可能でしたが、 FreeBSD に入っている bind (<a href="https://man.freebsd.org/cgi/man.cgi?query=named&amp;sektion=8&amp;format=html">named(8)</a> 参照) の現在のバージョンでは、 自分以外のドメインに対して FQDN でない別名を自動的につけてくれるような事はありません。 したがって <code>mumble</code> というホスト名は、 <code>mumble.foo.bar.edu</code> という名前か、もしくは root ドメイン内にある場合にしか適用されません。</p></div><div class=paragraph><p>これは、 <code>mumble.bar.edu</code> と <code>mumble.edu</code> ということなったドメイン名に対してホスト名のサーチが行なわれていた 以前の振る舞いとは異なったものです。このような事が悪い例もしくは セキュリティホールとみなされる理由については RFC 1535 を見てください。</p></div><div class=paragraph><p><span class=filename>/etc/resolv.conf</span> ファイル (<a href="https://man.freebsd.org/cgi/man.cgi?query=resolv.conf&amp;sektion=5&amp;format=html">resolv.conf(5)</a> 参照) の中で</p></div><div class="literalblock programlisting"><div class=content><pre>domain foo.bar.edu</pre></div></div><div class=paragraph><p>と書いてある行を、 <code>search foo.bar.edu bar.edu</code> のように書きかえることで、上のような事ができます。しかし、 RFC 1535 にあるように、 検索順序が「内部 (local) と外部 (public) の管理の境界」をまたがないようにしてください。</p></div></div><div class=sect2><h3 id=_すべてのネットワークの操作に対して_permission_denied_というメッセージが表示されるのですが>9.18. すべてのネットワークの操作に対して Permission denied というメッセージが表示されるのですが。<a class=anchor href=#_すべてのネットワークの操作に対して_permission_denied_というメッセージが表示されるのですが></a></h3><div class=paragraph><p><code>IPFIREWALL</code> オプションを付けてカーネルをコンパイルした場合には、 2.1-STABLE の開発の途中から変更になった 2.1.7R の標準的な方針として、 明示的に許可されていないすべてのパケットは落とされる設定 になっている事を覚えておいてください。</p></div><div class=paragraph><p>もしファイアウォールの設定を間違えた場合にネットワークの操作が再びできる ようにするには、<code>root</code> でログインして次のコマンドを実行してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ipfw add 65534 allow all from any to any</span></code></pre></div></div><div class=paragraph><p><span class=filename>/etc/rc.conf</span> に <code>firewall_type='open'</code> を追加してもよいでしょう。</p></div><div class=paragraph><p>FreeBSD のファイアウォールの設定についての情報は <a href=https://docs.freebsd.org/ja/books/handbook/firewalls#firewalls>FreeBSD ハンドブックの「ファイアウォール」</a>にあります。</p></div></div><div class=sect2><h3 id=_ipfw_のオーバヘッドはどのくらいでしょうか>9.19. IPFW のオーバヘッドはどのくらいでしょうか?<a class=anchor href=#_ipfw_のオーバヘッドはどのくらいでしょうか></a></h3><div class=paragraph><p>この答えは、 使っているルールセットとプロセッサのスピードによってほとんど決まります。 イーサネットに対して少しのルールセットだけを使っている場合には、 ほとんどその影響は無視できる程度です。 実際の測定値を見ないと満足できない方々のために、 実際の測定結果をお見せしましょう。</p></div><div class=paragraph><p>次の測定は 486-66 (訳注: Intel 社製 CPU i486、66MHz のこと) 上で 2.2.5-STABLE を使用して行なわれました。 IPFW は変更が加えられて、<code>ip_fw_chk</code> ルーチン内でかかる時間を 測定して 1000 パケット毎に結果をコンソールに表示するようになっています。</p></div><div class=paragraph><p>それぞれ 1000 ずつのルールが入っている 2 つのルールセットでテストが行なわれました。 ひとつ目のルールセットは最悪のケースを見るために</p></div><div class="literalblock programlisting"><div class=content><pre>ipfw add deny tcp from any to any 55555</pre></div></div><div class=paragraph><p>というルールを繰り返したものです。</p></div><div class=paragraph><p>IPFW のパケットチェックルーチンは、 パケットが (ポート番号のせいで) このルールにマッチしないことがわかるまでに、 何度も実行されます。そのため、これは最悪のケースを示します。 このルールを 999 個繰り返し並べた後に</p></div><div class="literalblock programlisting"><div class=content><pre>allow ip from any to any</pre></div></div><div class=paragraph><p>が書かれています。</p></div><div class=paragraph><p>2つ目のルールセットは、なるべく早くチェックが終了するように書かれたものです。</p></div><div class="literalblock programlisting"><div class=content><pre>ipfw add deny ip from 1.2.3.4 to 1.2.3.4</pre></div></div><div class=paragraph><p>このルールでは、発信元の IP アドレスがマッチしないので、 チェックはすぐに終了します。上のルールセットとおなじように、 1000 個目のルールは</p></div><div class="literalblock programlisting"><div class=content><pre>allow ip from any to any</pre></div></div><div class=paragraph><p>です。</p></div><div class=paragraph><p>1 つ目のルールセットの場合、 パケットあたりのオーバヘッドはおよそ 2.703ms/packet、 これはだいたい 1 つのルールあたり 2.7 マイクロ秒かかっていることになります。 したがって、 このルールにおけるパケット処理時間の理論的な限界は、 毎秒約 370 パケットです。 10Mbps のイーサネットで 1500 バイト以下のパケットサイズを仮定すると、 バンド幅の利用効率は 55.5% が限界となることになります。</p></div><div class=paragraph><p>2 つ目のルールセットでは、それぞれのパケットがおよそ 1.172msで処理されていますので、 だいたい 1 つのルールあたり 1.2 マイクロ秒かかっていることになります。 パケット処理時間の理論的な限界は、 毎秒約 853 パケットとなりますので、 10Mbps Ethernet のバンド幅を使い切ることができます。</p></div><div class=paragraph><p>このテストでのルール数は多過ぎるため、 実際に使用する際の結果を反映している訳ではありません。 これらは上に示した数値を出すためだけに用いられたものです。 効率の良いルールセットを作るためには、 次のような事を考えておけばよいでしょう。</p></div><div class=ulist><ul><li><p>「確定している」ルールは先頭の方に持ってきてください。 これは、多数の TCP のトラフィックがこのルールで処理されるためです。 そしてこのルールの前には <code>allow tcp</code> という記述を置かないでください。</p></li><li><p>良く使われるルールを、あまり良く使われないルールよりも 前の方に (もちろん<em>ファイアウォールの許可設定を変えない範囲で</em>) 持ってきてください。 <code>ipfw -a l</code> のようしてパケット数の統計を取ることで、 どのルールが最もよく使われているかを調べることができます。</p></li></ul></div></div><div class=sect2><h3 id=_ipfw8_fwd_ルールを使って他のマシンにサービスをリダイレクトしたのですが_うまく動いてくれないようですどうしてなんでしょう>9.20. <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfw&amp;sektion=8&amp;format=html">ipfw(8)</a> fwd ルールを使って他のマシンにサービスをリダイレクトしたのですが、 うまく動いてくれないようです。どうしてなんでしょう?<a class=anchor href=#_ipfw8_fwd_ルールを使って他のマシンにサービスをリダイレクトしたのですが_うまく動いてくれないようですどうしてなんでしょう></a></h3><div class=paragraph><p>おそらく、あなたが期待している動作とは、 単なるパケット転送ではなくネットワークアドレス変換 (NAT) と呼ばれるものだからでしょう。 "fwd" ルールは文字どおり、本当に転送しか行ないません。 パケットの中身については一切手を加えないのです。 そのため、次のようなルールを設定したとすると、</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>01000 fwd 10.0.0.1 from any to foo 21</code></pre></div></div><div class=paragraph><p>宛先アドレスに <em>foo</em> と書かれたパケットが このルールを設定したマシンに到着した場合、そのパケットは <em>10.0.0.1</em> に転送されますが、宛先アドレスは <em>foo</em> のままになります。 つまり、パケットに宛先アドレスが <em>10.0.0.1</em> に書き換えられるということは<em>ありません</em>。 自分宛でないパケットを受けとったマシンは、 おそらくほとんどの場合、そのパケットを破棄すると思います。 そのため "fwd" ルールは、 そのルールを書いたユーザが意図したようには動かないことが良くあります。 この動作はバグではなく、仕様なのです。</p></div><div class=paragraph><p>サービスの転送をきちんと動作させる方法については、 <a href=#service-redirect>サービスのリダイレクトに関する FAQ</a> や <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> のマニュアルページ、 <a href=https://www.FreeBSD.org/ports/>Ports Collection</a> にいくつか含まれているポート転送ユーティリティなどをご覧になると良いでしょう。</p></div></div><div class=sect2><h3 id=_サービス要求を他のマシンにリダイレクトするには>9.21. サービス要求を他のマシンにリダイレクトするには?<a class=anchor href=#_サービス要求を他のマシンにリダイレクトするには></a></h3><div class=paragraph><p>FTP などのサービスのリクエストは、"socket" パッケージを利用してリダイレクトできます。 "socket" パッケージは ports の <span class=filename>sysutils</span> カテゴリに含まれています。 (<span class=filename>/etc/inet.conf</span>に書かれている) コマンド行を、次のように "socket" を呼ぶように変更してください。</p></div><div class="literalblock programlisting"><div class=content><pre>ftp stream tcp nowait nobody /usr/local/bin/socket socket ftp.foo.com ftp</pre></div></div><div class=paragraph><p>ここで <em>ftp.foo.com</em> はリダイレクト先のホスト名、 行の最後の <em>ftp</em> はポート名です。</p></div></div><div class=sect2><h3 id=_バンド幅の管理を行なえるツールはどこで手に入れられますか>9.22. バンド幅の管理を行なえるツールはどこで手に入れられますか?<a class=anchor href=#_バンド幅の管理を行なえるツールはどこで手に入れられますか></a></h3><div class=paragraph><p>FreeBSD 用のバンド幅管理ツールには、無料で手に入れられる <a href=http://www.csl.sony.co.jp/person/kjc/programs.html>ALTQ</a> と、 <a href=http://www.etinc.com/>Emerging Technologies</a> から入手できる Bandwidth Manager という市販のものの 2 種類があります。</p></div></div><div class=sect2><h3 id=_bind_named_が53_番ポートのほかに_大きな番号のポートで受け付けています私のホストは_乗っ取られたのでしょうか>9.23. BIND (named) が、53 番ポートのほかに 大きな番号のポートで受け付けています。私のホストは 乗っ取られたのでしょうか。<a class=anchor href=#_bind_named_が53_番ポートのほかに_大きな番号のポートで受け付けています私のホストは_乗っ取られたのでしょうか></a></h3><div class=paragraph><p>おそらく違います。FreeBSD 3.0 以降では、外向けの問合せに ランダムな大きな番号のポートを用いるバージョンの BIND を 用いています。ファイアウォールを通すため、またはあなたの 気分で、外向きの問合せを 53 番ポートから行いたいならば、 <span class=filename>/etc/namedb/named.conf</span> に次のように 設定してみてください。</p></div><div class="literalblock programlisting"><div class=content><pre>options {
      query-source address * port 53;
};</pre></div></div><div class=paragraph><p>更に限定したければ、<code>*</code> を単一の IP アドレスに置き換えることもできます。</p></div><div class=paragraph><p>それはともかく、おめでとうごさいます。 <code>sockstat</code> の出力を見て、おかしな現象に 注目するのはよい習慣です。</p></div></div><div class=sect2><h3 id=_なぜ_devbpf0_device_not_configured_が出るのでしょうか>9.24. なぜ /dev/bpf0: device not configured が出るのでしょうか?<a class=anchor href=#_なぜ_devbpf0_device_not_configured_が出るのでしょうか></a></h3><div class=paragraph><p>バークレーパケットフィルタ (<a href="https://man.freebsd.org/cgi/man.cgi?query=bpf&amp;sektion=4&amp;format=html">bpf(4)</a>) ドライバは、それを利用するプログラムを実行する前に有効にしておく必要があります。 カーネルコンフィグファイルに、次のように追加してカーネルの再構築をしてください。</p></div><div class="literalblock programlisting"><div class=content><pre>pseudo-device bpfilter		# Berkeley Packet Filter</pre></div></div><div class=paragraph><p>そして再起動してから、次にデバイスノードを作成する必要があります。 これは、次のように入力し、<span class=filename>/dev</span> を変更することで行ないます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sh MAKEDEV bpf0</span></code></pre></div></div><div class=paragraph><p>デバイスノードの作成の詳細は、 <a href=https://docs.freebsd.org/ja/books/handbook/#kernelconfig-nodes>FreeBSD ハンドブックの「デバイスノード」</a>を参照してください。</p></div></div><div class=sect2><h3 id=_linux_の_smbmount_のように_ネットワーク上の_windows_マシンのディスクをマウントするにはどうしたら良いのでしょう>9.25. Linux の smbmount のように、 ネットワーク上の Windows マシンのディスクをマウントするにはどうしたら良いのでしょう?<a class=anchor href=#_linux_の_smbmount_のように_ネットワーク上の_windows_マシンのディスクをマウントするにはどうしたら良いのでしょう></a></h3><div class=paragraph><p>Ports Collection に含まれる sharity light パッケージを使ってください、</p></div></div><div class=sect2><h3 id=_icmp_response_bandwidth_limit_300200_pps_というメッセージがログファイルに現れるのですが_どういうことでしょう>9.26. icmp-response bandwidth limit 300/200 pps というメッセージがログファイルに現れるのですが、 どういうことでしょう?<a class=anchor href=#_icmp_response_bandwidth_limit_300200_pps_というメッセージがログファイルに現れるのですが_どういうことでしょう></a></h3><div class=paragraph><p>これは、カーネル自身から「ICMP や TCP のリセット (RST) 応答を、妥当な数よりも多く送っている」ということを、 あなたに伝えるメッセージです。 ICMP 応答は良く、使われていない UDP ポートに接続しようとした結果として生成されます。 また、TCP リセットはオープンされていない TCP ポートに接続しようとした結果として生成されます。 その他、これらのメッセージが表示される原因となる状況として、 以下のようなものがあります。</p></div><div class=ulist><ul><li><p>(特定のセキュリティ上の弱点を悪用しようとする攻撃ではなく) 膨大な数のパケットを使った強引なサービス妨害 (DoS) 攻撃。</p></li><li><p>(一部のウェルノウンポートを狙ったものではなく) 非常に広い範囲のポートに接続を試みるポートスキャン。</p></li></ul></div><div class=paragraph><p>メッセージ中の最初の数字は、 上限を設定しなかった場合にカーネルが送っていたであろうパケットの数を示し、 二番目の数字は、パケット数の上限値を示します。 この上限値は <code>net.inet.icmp.icmplim</code> という sysctl 変数を使うことで、以下のように変更可能です。 ここでは上限を 1 秒あたりのパケット数で <code>300</code> にしています。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl -w net.inet.icmp.icmplim=300</span></code></pre></div></div><div class=paragraph><p>カーネルの応答制限を無効にせず、 ログファイル中のメッセージだけを抑制したい場合、 <code>net.inet.icmp.icmplim_output</code> sysctl 変数を次のようにすることで出力を止めることができます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl -w net.inet.icmp.icmplim_output=0</span></code></pre></div></div><div class=paragraph><p>最後に、もし応答制限を無効にしたい場合は、 <code>net.inet.icmp.icmplim</code> sysctl 変数に (上の例のようにして) <code>0</code> を設定することで実現できます。 ただし応答制限を無効化するのは、上記の理由からおすすめしません。</p></div></div></div></div><div class=sect1><h2 id=_ppp>10. PPP<a class=anchor href=#_ppp></a></h2><div class=sectionbody><div class=sect2><h3 id=_ppp_が動きませんどこを間違えているのでしょう>10.1. ppp が動きません。どこを間違えているのでしょう?<a class=anchor href=#_ppp_が動きませんどこを間違えているのでしょう></a></h3><div class=paragraph><p>まず <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> のマニュアルと、 <a href=https://docs.freebsd.org/ja/books/handbook/ppp-and-slip#userppp>FreeBSD ハンドブックの「PPP」</a>を読んでみましょう。 次に、</p></div><div class="literalblock programlisting"><div class=content><pre>set log Phase Chat Connect Carrier lcp ipcp ccp command</pre></div></div><div class=paragraph><p>という命令を ppp のコマンドプロンプトに対して打ち込むか、 設定ファイル <span class=filename>/etc/ppp/ppp.conf</span> に加えて (<code>default</code> セクションの先頭に加えるのが一番良いでしょう) ログを有効にしてみてください。 その際、 <span class=filename>/etc/syslog.conf</span> (<a href="https://man.freebsd.org/cgi/man.cgi?query=syslog.conf&amp;sektion=5&amp;format=html">syslog.conf(5)</a> 参照) に</p></div><div class="literalblock programlisting"><div class=content><pre>!ppp
*.*              /var/log/ppp.log</pre></div></div><div class=paragraph><p>と書かれた行が含まれているか、また、 <span class=filename>/var/log/ppp.log</span> が存在しているかどうか確かめておいてください。 さて、これで何が起きているのか突き止めるために、 ログファイルからたくさんの情報を得られるようになりました。 ログに訳の分らない部分があっても心配ご無用。 あなたが助けを求めた誰かにとっては、 その部分が意味をなす場合があるのです。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>ログの取得に syslog を使用するようになったのは 2.2.5 以降からです。</p></div></td></tr></tbody></table></div><div class=paragraph><p>使用中の <code>ppp</code> のバージョンで “set log” 命令を解釈しない場合は、<a href=http://people.FreeBSD.org/\~brian/>最新版</a>をダウンロードすべきです。 FreeBSD の 2.1.5 以降でビルドできます。</p></div></div><div class=sect2><h3 id=_ppp_を実行するとハングします>10.2. ppp を実行するとハングします<a class=anchor href=#_ppp_を実行するとハングします></a></h3><div class=paragraph><p>ホスト名の解決がうまくいっていないのでしょう。まず、 リゾルバ (resolver) が <span class=filename>/etc/hosts</span>を参照するように、 <span class=filename>/etc/host.conf</span> の最初の行に <code>host</code> と書き込んでください。 つぎに、<span class=filename>/etc/hosts</span> に使用しているマシンのエントリを書き加えます。 ローカルでネットワークを使用していない場合は、 <code>localhost</code> の行を以下のように変更してください。</p></div><div class="literalblock programlisting"><div class=content><pre>127.0.0.1      foo.bar.com foo localhost</pre></div></div><div class=paragraph><p>使用しているホストのエントリを追加してもかまいません。 詳細は関連するマンページを参照してください。</p></div></div><div class=sect2><h3 id=_ppp_が_auto_モードでダイアルしてくれない>10.3. ppp が -auto モードでダイアルしてくれない<a class=anchor href=#_ppp_が_auto_モードでダイアルしてくれない></a></h3><div class=paragraph><p>まず最初に、デフォルトルートが確立しているかどうかチェックしてください。 <code>netstat -rn</code> (<a href="https://man.freebsd.org/cgi/man.cgi?query=netstat&amp;sektion=1&amp;format=html">netstat(1)</a> 参照) を実行すると、以下のような情報が表示されるはずです。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Destination        Gateway            Flags     Refs     Use     Netif Expire
default            10.0.0.2           UGSc        0        0      tun0
10.0.0.2           10.0.0.1           UH          0        0      tun0</code></pre></div></div><div class=paragraph><p>これはあなたがハンドブックやマニュアル、 <span class=filename>ppp.conf.sample</span> の中で出てくるアドレスを使用していると仮定した場合の例です。 デフォルトルートが確立していない場合、 <span class=filename>ppp.conf</span> の中の <code>HISADDR</code> が理解できない、 古いバージョンの <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> が走っている可能性があります。 FreeBSD 2.2.5 より前のバージョンに付属していた ppp を使用している場合、</p></div><div class="literalblock programlisting"><div class=content><pre>add 0 0 HISADDR</pre></div></div><div class=paragraph><p>と書かれた行を以下のように修正してください。</p></div><div class="literalblock programlisting"><div class=content><pre>add 0 0 10.0.0.2</pre></div></div><div class=paragraph><p><code>netstat -rn</code> でデフォルトルートの情報が表示されない場合、もう一つ、 <span class=filename>/etc/rc.conf</span> (<a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a> 参照) (2.2.2 より前のリリースでは <span class=filename>/etc/sysconfig</span> と呼ばれていました) の中でデフォルトのルータを誤って設定し、 <span class=filename>ppp.conf</span> から</p></div><div class="literalblock programlisting"><div class=content><pre>delete ALL</pre></div></div><div class=paragraph><p>の行をうっかり消してしまった可能性があります。 この場合は、 <a href=https://docs.freebsd.org/ja/books/handbook/ppp-and-slip#userppp-final>FreeBSD ハンドブックの「システムの最終設定」</a>の項を読み直してください。</p></div></div><div class=sect2><h3 id=_no_route_to_host_とはどういう意味ですか>10.4. No route to host とはどういう意味ですか?<a class=anchor href=#_no_route_to_host_とはどういう意味ですか></a></h3><div class=paragraph><p>このエラーは通常、 <span class=filename>/etc/ppp/ppp.linkup</span> に以下のようなセクションが無い場合に起こります。</p></div><div class="literalblock programlisting"><div class=content><pre>MYADDR:
delete ALL
add 0 0 HISADDR</pre></div></div><div class=paragraph><p>これは動的 IP アドレスを使用している場合、 またはゲートウェイのアドレスを知らない場合にのみ必要な設定です。 インタラクティブモードを使用している場合、 <em>パケットモード</em>に入った後で (プロンプトが PPP と大文字に変わったらパケットモードに入ったしるしです)、 以下の命令を入力してください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>delete ALL
add 0 0 HISADDR</code></pre></div></div><div class=paragraph><p>詳しい情報については、 <a href=https://docs.freebsd.org/ja/books/handbook/ppp-and-slip#userppp-dynamicip>FreeBSD ハンドブックの「PPP と動的 IP 設定」</a>の項を参照してください。</p></div></div><div class=sect2><h3 id=_3_分ほど経つと接続が切れてしまう>10.5. 3 分ほど経つと接続が切れてしまう<a class=anchor href=#_3_分ほど経つと接続が切れてしまう></a></h3><div class=paragraph><p><code>ppp</code> のタイムアウトは デフォルトでは 3 分です。 これは</p></div><div class="literalblock programlisting"><div class=content><pre>set timeout NNN</pre></div></div><div class=paragraph><p>という命令によって調整することができます。 <em>NNN</em> には、 接続が切れるまでのアイドル時間が秒数で入ります。 <em>NNN</em> が 0 の場合、 タイムアウトによる切断は起こりません。 このコマンドは <span class=filename>ppp.conf</span> に入れることも、 インタラクティブモードでプロンプトから入力することも できます。 ソケットを用いる <a href="https://man.freebsd.org/cgi/man.cgi?query=telnet&amp;sektion=1&amp;format=html">telnet(1)</a> か <a href="https://man.freebsd.org/cgi/man.cgi?query=pppctl&amp;sektion=8&amp;format=html">pppctl(8)</a> を使用し、 ppp サーバに接続することによって、 回線がアクティブな間に限定してタイムアウトの時間を調整することも可能です。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p><code>pppctl</code> は 2.2.5R からです。</p></div></td></tr></tbody></table></div><div class=paragraph><p>詳しい情報は <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> のマニュアルページを参照してください。</p></div></div><div class=sect2><h3 id=_負荷が高いと接続が切れてしまう>10.6. 負荷が高いと接続が切れてしまう<a class=anchor href=#_負荷が高いと接続が切れてしまう></a></h3><div class=paragraph><p>Link Quality Reporting (LQR) の設定を行っている場合、 マシンと接続先の間で非常にたくさんの LQR パケットが失われている可能性があります。結果として <code>ppp</code> は回線の具合いが悪いと考え、 回線を切断するのです。2.2.5 より前のバージョンの FreeBSD では LQR はデフォルトで有効になっています。 現在ではデフォルトの状態で無効です。 LQR は以下の命令で無効にすることができます。</p></div><div class="literalblock programlisting"><div class=content><pre>disable lqr</pre></div></div></div><div class=sect2><h3 id=_接続がランダムに切れてしまう>10.7. 接続がランダムに切れてしまう<a class=anchor href=#_接続がランダムに切れてしまう></a></h3><div class=paragraph><p>ノイズの多い回線、あるいは待ち機能付きの回線では、 時々モデムが (誤って) キャリアを失ったと思い込み、 回線が切断されてしまうことがあります。</p></div><div class=paragraph><p>大多数のモデムでは、 一時的なキャリアの喪失をどれくらいの時間で検出するかを、 設定で決めることができます。 たとえば USR Sportster では、S10 レジスタ の値を 10 倍した秒数がその値になります。 この場合、モデムをもっとのんびり屋さんにするには、 dial 行に次のような文字列を加えると良いでしょう。</p></div><div class="literalblock programlisting"><div class=content><pre>set dial &#34;...... ATS10=10 OK ......&#34;</pre></div></div><div class=paragraph><p>詳しくはお使いのモデムのマニュアルをご覧ください。</p></div></div><div class=sect2><h3 id=_接続が不規則にハングアップしてしまう>10.8. 接続が不規則にハングアップしてしまう<a class=anchor href=#_接続が不規則にハングアップしてしまう></a></h3><div class=paragraph><p>たくさんの人が、原因不明のハングアップを経験しています。 検証のために必要なのは、まずどちら側のリンクでそれが起こっているか、 ということです。</p></div><div class=paragraph><p>外部接続型モデムを利用しているなら、 単に <code>ping</code> を使うことで、 データを送信するときに TD ランプが点灯するかどうかを確認することができます。 もし、TD ランプが点灯して、 RD ランプが点灯しなければ、 問題は回線の向こう側にあります。TD が点灯しなければ、 問題は回線のこちら側です。内蔵型モデムの場合、 <span class=filename>ppp.conf</span> ファイルに <code>set server</code> コマンドを入れる必要があるでしょう。 回線が切断されたとき、<code>pppctl</code> を使って <code>ppp</code> に接続してください。 そのとき、 ネットワーク接続が急に復旧 (診断ソケットへのアクセスで、 <code>ppp</code> が復活します) するか、 もしくは接続自体が全くできない (ただし、 <code>ppp</code> 起動時に <code>set socket</code> コマンドがちゃんと実行されているとします) としたら、 問題は回線のこちら側です。 もし、接続可能で、かつ状況が変化しなければ、 <code>set log local async</code> を使ってローカル非同期ログ (async logging) を有効にし、 <code>ping</code> を他のウィンドウかターミナルから使ってください。 非同期ログには、こちら側のリンクの送受信データが記録されます。 もし、データが送信されたにもかかわらず返って来ていなければ、 問題は回線の向こう側にあることになります。</p></div><div class=paragraph><p>問題が回線のどちら側かにあることが分かったら、 つぎの二つの可能性が考えられるでしょう。</p></div></div><div class=sect2><h3 id=_回線の向こう側での反応がない>10.9. 回線の向こう側での反応がない<a class=anchor href=#_回線の向こう側での反応がない></a></h3><div class=paragraph><p>これに対処できることはほとんどありません。大部分の ISP は、Microsoft 社製 OS 以外の利用者に対してのサポートを拒否するでしょう。 <span class=filename>ppp.conf</span> ファイルの中に <code>enable lqr</code> を記述することで <code>ppp</code> が回線の向こう側で発生する切断を検出することができますが、 この検出は比較的遅いため、あまり役に立ちません。また、あなたは user-ppp を利用していることを ISP に知られたくないと思うかも知れませんね。</p></div><div class=paragraph><p>まず最初に、こちら側の圧縮機能をすべて無効にしてみてください。 それには、設定ファイルをつぎのようにします。</p></div><div class="literalblock programlisting"><div class=content><pre>disable pred1 deflate deflate24 protocomp acfcomp shortseq vj
deny pred1 deflate deflate24 protocomp acfcomp shortseq vj</pre></div></div><div class=paragraph><p>そして再接続し、変更前と同じように通信できることを確認します。 もしこれによって状況が改善されるか、完全に解決したら、 (上の設定のうち) どの設定で状況が変化したのかを、 色々な組合せで試してみてください。これは、ISP に問い合わせを行なうときの有効な情報となります (ただし、 あなたが Microsoft 社製品以外のものを利用していることも明らかにしてしまいますが)。</p></div><div class=paragraph><p>ISP に問い合わせを行なう前に、こちら側の非同期ログを有効にして、 接続がハングアップするまで待ってください。この作業は、 非常に多くのディスク空間を消費するかも知れません。 興味の対象となっているのは、通信ポートから最後に読み込まれたデータです。 それは通常 ASCII データで、 問題点の詳細 (“Memory fault, core dump” など) が 記載されている可能性があります。</p></div><div class=paragraph><p>回線の向こう側で通信ログを監視することは可能なはずですので、 切断が発生した時、ISP の対応が好意的ならば どうして ISP 側で問題が発生したのかこちらに伝えてくれるかも知れません。 <a href=mailto:brian@Awfulhak.org>brian@Awfulhak.org</a> まで詳細を送って頂くか、ISP に直接私に連絡するように伝えて下さっても構いません。</p></div></div><div class=sect2><h3 id=_ppp_がハングアップする>10.10. ppp がハングアップする<a class=anchor href=#_ppp_がハングアップする></a></h3><div class=paragraph><p>ベストな方法は、 <code>CFLAGS+=-g</code> と <code>STRIP=</code> を <code>ppp</code> の <span class=filename>Makefile</span> に追加して、 <code>ppp</code> を再構築し、 そして <code>make clean && make && make install</code> を行なうことです。 <code>ppp</code> がハングアップした時、 <code>ps ajxww | fgrep ppp</code> を使って <code>ppp</code> のプロセス ID を調べ、 <code>gdb ppp PID</code> を実行してください。 <code>gdb</code> のプロンプトから、 <code>bt</code> を使ってスタックをトレースすることができます。</p></div><div class=paragraph><p>スタックトレースの結果は、<a href=mailto:brian@Awfulhak.org>brian@Awfulhak.org</a> まで送ってください。</p></div></div><div class=sect2><h3 id=_login_ok_のメッセージが出た後何も起こらない>10.11. Login OK! のメッセージが出た後、何も起こらない<a class=anchor href=#_login_ok_のメッセージが出た後何も起こらない></a></h3><div class=paragraph><p>2.2.5 より前のリリースの FreeBSD では、 <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> はリンクが確立した後、接続先が Line Control Protocol (LCP) を発信するのを待ちます。しかし、多くの ISP ではネゴシエーションを自分からは起こさず、 クライアントが起こすのを待っています。 ppp に強制的に LCP を発信させるには、 次の命令を使います。</p></div><div class="literalblock programlisting"><div class=content><pre>set openmode active</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>両方の側がネゴジェーションを起こしても、 大抵の場合は何の問題もありません。 ですから、現在では openmode はデフォルトで有効になっています。 次のセクションでこれが<em>問題になる場合</em>を説明します。</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=_でもまだ_magic_is_the_same_というエラーが出る>10.12. でもまだ magic is the same というエラーが出る<a class=anchor href=#_でもまだ_magic_is_the_same_というエラーが出る></a></h3><div class=paragraph><p>時折、接続直後のログに “magic is the same” というメッセージがあらわれることがあります。 このメッセージがあらわれても何も起きない場合もありますし、 どちらかの側が接続を切ってしまう場合もあります。 <code>ppp</code> の実装の多くはこの問題に対応できておらず、 その場合にはちゃんと link が上がっている状態であっても、 <code>ppp</code> が最終的にあきらめてしまい、 接続を切るまで設定のリクエストが繰り返し送られ、 設定が行われたという通知がログファイルに残ると思います。</p></div><div class=paragraph><p>これは通常、 ディスクアクセスの遅いサーバマシンのシリアルポートで <code>getty</code> が生きていて、 <code>ppp</code> がログインスクリプトか、 ログイン直後に起動されたプログラムから実行されている場合に起こります。 <code>slirp</code> を使用している場合に同様の症状が見られたという報告もあります。 原因は <code>getty</code> の終了されるまでと、 <code>ppp</code> が実行され、 クライアント側の <code>ppp</code> が Line Control Protocol (LCP) を送り始めるまでのタイミングにあります。 サーバ側のシリアルポートで <code>ECHO</code> が有効なままになっているので、 クライアント側の <code>ppp</code> にパケットが「反射」してしまうのです。</p></div><div class=paragraph><p>LCP ネゴシエーションの一部として、 リンクの両サイドで magic number を定めて、 「反射」が起きていないかどうか確かめる作業があります。 規約では、接続相手がこちらと同じ magic number を提示してきたら、 NAK を送って新しい magic number を選択しなければならないと定めています。 この作業の間、サーバのシリアルポートの <code>ECHO</code> がずっと有効になったままなので、 クライアント側の <code>ppp</code> は LCP パケットを送り、 パケットが反射して全く同じ magic number が送られてくるのを見つけ、 それに対して NAK を送るのです。一方 NAK 自体も (これは <code>ppp</code> が magic number を変更しなければいけないことを意味しています) 反射してくるので、 結果として magic number が数えきれないほど変更され、 そのすべてがサーバの tty バッファの中に積み重なることになるのです。 サーバでスタートした <code>ppp</code> は、すぐに magic number であふれかえってしまい、 LCP のネゴシエーションを十分に行ったものと判断して、 さっさと接続を切ってしまいます。 一方、 クライアント側は反射が帰ってこなくなったので満足しますが、 それもサーバが接続を切ったことを知るまでです。</p></div><div class=paragraph><p>この事態は、以下の行を <span class=filename>ppp.conf</span> の中に書いて、 相手がネゴシエーションを開始できるようにする事によって回避できます。</p></div><div class="literalblock programlisting"><div class=content><pre>set openmode passive</pre></div></div><div class=paragraph><p>これで <code>ppp</code> はサーバが LCP ネゴシエーションを起こすのを待つようになります。 しかし、 自分からは決してネゴジェーションを起こさないサーバもあるかもしれません。 もしこの状況に遭遇した場合には、次のようにしてください。</p></div><div class="literalblock programlisting"><div class=content><pre>set openmode active 3</pre></div></div><div class=paragraph><p>これによって <code>ppp</code> は 3 秒間 passive モードを続けた後で、 LCP リクエストを送り始めます。 この間に相手がリクエストを送り始めた場合には 3 秒間待たずにこのリクエストに即座に応答します。</p></div></div><div class=sect2><h3 id=_接続が切れるまで_lcp_のネゴシエーションが続くのですが>10.13. 接続が切れるまで LCP のネゴシエーションが続くのですが。<a class=anchor href=#_接続が切れるまで_lcp_のネゴシエーションが続くのですが></a></h3><div class=paragraph><p>現在の ppp は、まだ LCP や CCP、 IPCP の返事が、 元のリクエストと連携してくれる機能がきちんと実装されていません。 その結果、ある ppp の実装が相手よりも 6 秒以上遅い場合には、 LCP 設定のリクエストをさらに 2 回送ります。 これは致命的な物です。</p></div><div class=paragraph><p><code>A</code> と <code>B</code>という 2 つの実装を考えてみましょう。 <code>A</code> が接続の直後に LCP リクエストを送り、 一方 <code>B</code> の方はスタートするのに 7 秒かかったとします。<code>B</code> がスタートする時には <code>A</code> は LCP リクエストを 3 回送ってしまっています。 前の節で述べた magic number の問題が起きないよう、 <code>ECHO</code> は <code>off</code> になっていると考えています。 <code>B</code> は REQ を送ります。 するとこれは <code>A</code> の REQ のうち、 最初の物に対する ACK となります。 結果として、<code>A</code> は OPENED の状態に入り、 <code>B</code> に対して (最初の) ACK を送ります。 そのうちに <code>B</code> は、<code>B</code> がスタートする前に <code>A</code> から送られたもう 2 つの REQ に対する ACK を送り返します。 <code>B</code> は <code>A</code> からの最初の ACK を受け取り OPENED の状態に入ります。 <code>A</code> は <code>B</code> からの 2 つ目の ACK を受け取りますので、 REQ-SENTの状態に戻り、 さらに、RFC のとおりに (4 つ目の) REQ を送ります。そして 3 つ目の ACK を受け取って OPENED 状態に入ります。 一方、<code>B</code> は <code>A</code> からの 4 つ目の REQ を受け取りますので、 ACK-SENT の状態に入り、2 つ目の REQ と 4 つ目の ACK を RFC のとおりに送ります。 <code>A</code>は、 REQ を受けとると REQ-SENT の状態になり、さらに REQ を送ります。 そしてすぐに ACK を受け取って OPENED の状態に入ります。</p></div><div class=paragraph><p>これが、片方の <code>ppp</code> があきらめてしまうまで続きます。</p></div><div class=paragraph><p>これを回避する最も良い方法は、 片方を <code>passive</code> モードに設定する、 すなわち反対側がネゴシエーションを開始するまで待つようにする事です。 これは、</p></div><div class="literalblock programlisting"><div class=content><pre>set openmode passive</pre></div></div><div class=paragraph><p>というコマンドでできます。 このオプションは気を付けて使わないといけません。さらに</p></div><div class="literalblock programlisting"><div class=content><pre>set stopped N</pre></div></div><div class=paragraph><p>というコマンドを追加して、 ppp がネゴシエーションが開始するまで待つ 最大の時間を設定してください。もしくは、</p></div><div class="literalblock programlisting"><div class=content><pre>set openmode active N</pre></div></div><div class=paragraph><p>というコマンド (ここで、 <em>N</em> はネゴシエーションが始まるまで待つ時間) を使うこともできます。 詳しくはマニュアルページを参照してください。</p></div></div><div class=sect2><h3 id=_ppp_が接続直後に固まってしまう>10.14. ppp が接続直後に固まってしまう<a class=anchor href=#_ppp_が接続直後に固まってしまう></a></h3><div class=paragraph><p>2.2.5 より前のバージョンの FreeBSD では、ppp が Predictor1 圧縮のネゴシエーションを誤って解釈して、 接続直後にリンクを無効にしている可能性があります。 これは両サイドが異なる Compression Control Protocols (CCP) を使ってネゴジェーションを行った場合にのみ発生します。 この問題は現在は解決していますが、あなたの走らせている ppp のバージョンが古い場合でも、次の命令で解決することができます。</p></div><div class="literalblock programlisting"><div class=content><pre>disable pred1</pre></div></div></div><div class=sect2><h3 id=_ppp_の内部でシェルを起動しようとすると固まってしまう>10.15. ppp の内部でシェルを起動しようとすると固まってしまう<a class=anchor href=#_ppp_の内部でシェルを起動しようとすると固まってしまう></a></h3><div class=paragraph><p><code>shell</code> あるいは <code>!</code> コマンドを使用すると、 ppp はシェルを起動し (何か引数を渡した場合は、 ppp は引数も実行します)、 コマンドが終了するまで処理を中断します。 コマンドを実行中に ppp のリンクを使おうとすると、 リンクが固まっているように見えますが、 これは ppp がコマンドの終了を待っているからです。</p></div><div class=paragraph><p>このような場合は、代わりに <code>!bg</code> コマンドを使用してください。 与えられたコマンドがバックグラウンドで実行されるので、 <code>ppp</code> はリンクに関するサービスを継続することができます。</p></div></div><div class=sect2><h3 id=_ヌルモデムケーブルを使用しているとき_ppp_が終了しない>10.16. ヌルモデムケーブルを使用しているとき、 ppp が終了しない<a class=anchor href=#_ヌルモデムケーブルを使用しているとき_ppp_が終了しない></a></h3><div class=paragraph><p>ヌルモデムケーブルを使用して直接接続している場合、 ppp は自動的には接続の終了を知ることができません。 これはヌルモデムシリアルケーブルの配線に起因しています。 この種の接続形態を用いる場合は、 以下の命令を用いて LQR を常に有効にする必要があります。</p></div><div class="literalblock programlisting"><div class=content><pre>enable lqr</pre></div></div><div class=paragraph><p>こうすると、接続先がネゴシエーションを行う場合、デフォルトで LQR の使用を受け入れるようになります。</p></div></div><div class=sect2><h3 id=_ppp_を_auto_モードで動かすと_勝手にダイアルすることがある>10.17. ppp を -auto モードで動かすと、 勝手にダイアルすることがある<a class=anchor href=#_ppp_を_auto_モードで動かすと_勝手にダイアルすることがある></a></h3><div class=paragraph><p>ppp が思いもしないときにダイアルを始める場合、その原因を突き止め、 防止のためにダイヤルフィルタ (dfilters) をかけてやる 必要があります。</p></div><div class=paragraph><p>原因を突き止めるためには、以下の命令を使用してください。</p></div><div class="literalblock programlisting"><div class=content><pre>set log +tcp/ip</pre></div></div><div class=paragraph><p>これで接続を通過するすべてのトラフィックをログに残すことができるようになりました。 次に突然回線がつながったときのログのタイムスタンプをたどれば、 原因を突き止めることができるはずです。</p></div><div class=paragraph><p>原因がわかったら、次に、このような状況ではダイヤルが起こらないようにしましょう。 通常、この手の問題は、DNS で名前の解決をしようとしたために起こります。 DNS による名前の解決によって、 接続が行われるのを防止するには、 次のような手段を用います (これは ppp の既に確立した接続に関してパケットのフィルタリングをするものでは<em>ありません</em>)。</p></div><div class="literalblock programlisting"><div class=content><pre>set dfilter 1 deny udp src eq 53
set dfilter 2 deny udp dst eq 53
set dfilter 3 permit 0/0 0/0</pre></div></div><div class=paragraph><p>これはデマンドダイヤル機能に問題を生じさせるため、 常に適切であるとはかぎりません。 ほとんどのプログラムは他のネットワーク関連の処理を行なう前に DNS への問い合わせが必要になります。</p></div><div class=paragraph><p>DNS の場合は、 何が実際にホスト名を検索しようとしているのかを突き止めるべきでしょう。 大抵の場合は、 <a href="https://man.freebsd.org/cgi/man.cgi?query=sendmail&amp;sektion=8&amp;format=html">sendmail(8)</a> が犯人です。 設定ファイルで sendmail が DNS に問い合わせないようになっているか確認すべきです。 自分用の設定ファイルを作成するための詳しい方法は、 <a href=#ispmail>メールの設定</a> の項をご覧ください。 または、 <span class=filename>.mc</span> ファイルに次のような行を追加してもよいでしょう。</p></div><div class="literalblock programlisting"><div class=content><pre>define(`confDELIVERY_MODE&#39;, `d&#39;)dnl</pre></div></div><div class=paragraph><p>この行を追加すると、sendmail はメールキューを処理する (通常 sendmail は 30 分ごとにキューを処理するよう、 “-bd -q30m” というオプションを付けて起動されます) までか、 または (多分 <span class=filename>ppp.linkup</span> というファイルの中で) “sendmail -q” というコマンドが実行されるまで、 すべてのメールをキューに溜めるようになります。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=title>訳注</div><div class=paragraph><p>“sendmail -q” はその時点のメールキューの内容を処理して終了します。</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=_ccp_エラーとはどういう意味ですか>10.18. CCP エラーとはどういう意味ですか<a class=anchor href=#_ccp_エラーとはどういう意味ですか></a></h3><div class=paragraph><p>ログファイル中の以下のエラーは、</p></div><div class="literalblock programlisting"><div class=content><pre>CCP: CcpSendConfigReq
CCP: Received Terminate Ack (1) state = Req-Sent (6)</pre></div></div><div class=paragraph><p>のネゴシエーションにおいて <code>ppp</code> は Predictor1 圧縮を用いるべく主張したのに対して、 接続先は圧縮を使用しないことを主張した場合に起こります。 このメッセージには何の害もありませんが、 出るのが嫌なら、以下の命令を用いてこちら側でも Predictor1 圧縮を無効にすることで対応できます。</p></div><div class="literalblock programlisting"><div class=content><pre>disable pred1</pre></div></div></div><div class=sect2><h3 id=_ファイル転送の途中でppp_が_io_エラーを出して固まってしまう>10.19. ファイル転送の途中で、ppp が IO エラーを出して固まってしまう<a class=anchor href=#_ファイル転送の途中でppp_が_io_エラーを出して固まってしまう></a></h3><div class=paragraph><p>FreeBSD 2.2.2 以前のバージョンの <span class=filename>tun</span> ドライバには、<span class=filename>tun</span> インタフェースの MTU のサイズより大きなパケットを受け取ることができないというバグがありました。 MTU のサイズより大きなパケットを受け付けると IO エラーが起こり、 <code>syslogd</code> 経由で記録されるのです。</p></div><div class=paragraph><p><code>ppp</code> の仕様では、 LCP のネゴシエーションを行う場合を含む<em>どのような場合でも</em>最低 1500 オクテットの Maximum Receive Unit (MRU) を受け入れる必要があります。 ですから、MTU を 1500 以下に設定した場合でも、ISP はそれに関係なく 1500 の大きさのパケットを送ってくるでしょう。 そしてこのイケてない機能にぶちあたって、 リンクが固まるのを目にすることになるのです。</p></div><div class=paragraph><p>FreeBSD 2.2.2 以前のバージョンでは、MTU を決して 1500 より小さくしないことで、 この問題を回避することができます。</p></div></div><div class=sect2><h3 id=_どうして_ppp_は接続速度をログに残さないんでしょう>10.20. どうして ppp は接続速度をログに残さないんでしょう?<a class=anchor href=#_どうして_ppp_は接続速度をログに残さないんでしょう></a></h3><div class=paragraph><p>モデムとの「やり取り」すべての行をログに残すには、 以下のようにして接続速度のログの有効化を行ってください。</p></div><div class="literalblock programlisting"><div class=content><pre>set log +connect</pre></div></div><div class=paragraph><p>これは <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> に最後にくることが要求されている “expect” という文字列がくるまでのすべてのものをログに記録させます。</p></div><div class=paragraph><p>接続速度はログにとりたいけれど、PAP や CHAP を使っている (その結果、ダイヤルスクリプト中の <code>CONNECT</code> 以降に全く「やりとり」を行わない - “set login” スクリプトには何も書かない) のであれば、 ppp に “expect” を含んだ <code>CONNECT</code> 行すべてがくるまで待たせるようにしないといけません、 以下のようになります。</p></div><div class="literalblock programlisting"><div class=content><pre>set dial &#34;ABORT BUSY ABORT NO\\sCARRIER TIMEOUT 4 \&#34;\&#34; ATZ OK-ATZ-OK ATDT\\T TIMEOUT 60 CONNECT \\c \\n&#34;</pre></div></div><div class=paragraph><p>ここで、<code>CONNECT</code> を受信してから、 何も送らず、復帰改行 (linefeed) を待っています、 ppp に <code>CONNECT</code> の応答すべてを読み込ませているわけです。</p></div></div><div class=sect2><h3 id=_私の_chat_スクリプトでは_という文字を_ppp_が解釈してくれません>10.21. 私の chat スクリプトでは \ という文字を PPP が解釈してくれません。<a class=anchor href=#_私の_chat_スクリプトでは_という文字を_ppp_が解釈してくれません></a></h3><div class=paragraph><p><code>PPP</code> は設定ファイルを読み込むときに、 <code>set phone "123 456 789"</code> のような文字列を正しく解釈し、 番号が実際に<em>1 つの</em>引数であると理解します。 """ という文字を指定するには、バックスラッシュ (backslash; “\”) でエスケープしなければなりません。</p></div><div class=paragraph><p><code>chat</code> の各引数が解釈されるときには、 “\P” や “\T” のような特別なエスケープシーケンス (マニュアルページ参照のこと) を見付けるために、 もう 1 回、字句解析を行います。 このように字句解析は 2 回繰り返されますので、 正しい回数だけエスケープ処理を行わないといけません。</p></div><div class=paragraph><p>モデムにたとえば “\” のような文字を送りたい場合には、 次のようにする必要があります。</p></div><div class="literalblock programlisting"><div class=content><pre>set dial &#34;\&#34;\&#34; ATZ OK-ATZ-OK AT\\\\X OK&#34;</pre></div></div><div class=paragraph><p>実際にモデムに送られる文字列は次のようになります。</p></div><div class="literalblock programlisting"><div class=content><pre>ATZ
OK
AT\X
OK</pre></div></div><div class=paragraph><p>他の例ですと</p></div><div class="literalblock programlisting"><div class=content><pre>set phone 1234567
            set dial &#34;\&#34;\&#34; ATZ OK ATDT\\T&#34;</pre></div></div><div class=paragraph><p>は次のようになります。</p></div><div class="literalblock programlisting"><div class=content><pre>ATZ
OK
ATDT1234567</pre></div></div></div><div class=sect2><h3 id=_ppp_が_segmentation_fault_になるのですが_ppp_core_ファイルがありません>10.22. ppp が segmentation fault になるのですが、 ppp.core ファイルがありません<a class=anchor href=#_ppp_が_segmentation_fault_になるのですが_ppp_core_ファイルがありません></a></h3><div class=paragraph><p>ppp (や他のプログラム) は決して core を吐いてはいけません。 ppp は実効 uid が 0 で動いていますので、 オペレーティングシステムは ppp を終了させる前にディスクに core イメージを書き込みません。 しかし ppp は実際にはセグメンテーション違反や、 他の core を吐く原因となるようなシグナルによって終了しており、 <em>さらに</em>最新のバージョン (このセクションの始めを見てください) を使用しているならば、次のようにしてください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>tar </span>xfz ppp-<span class=k>*</span>.src.tar.gz
% <span class=nb>cd </span>ppp<span class=k>*</span>/ppp
% <span class=nb>echo </span><span class=nv>STRIP</span><span class=o>=</span> <span class=o>&gt;&gt;</span>Makefile
% <span class=nb>echo </span>CFLAGS+<span class=o>=</span><span class=nt>-g</span> <span class=o>&gt;&gt;</span>Makefile
% make clean all
% su
<span class=c># make install</span>
<span class=c># chmod 555 /usr/sbin/ppp</span></code></pre></div></div><div class=paragraph><p>これでデバッグ可能なバージョンの ppp がインストールされます。 <code>root</code> で ppp を実行し、 すべての特権が無効になっているようにする必要があるでしょう。 ppp を実行する時には、 カレントディレクトリが <code>make</code> したディレクトリであるようにしてください。</p></div><div class=paragraph><p>これで、ppp がセグメンテーション例外を受け取ったときには <span class=filename>ppp.core</span> という名前の core ファイルを吐くようになります。core が 吐かれたら次のようにしてください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% su
<span class=c># gdb /usr/sbin/ppp ppp.core</span>
<span class=o>(</span>gdb<span class=o>)</span> bt
..
<span class=o>(</span>gdb<span class=o>)</span> f 0
..
<span class=o>(</span>gdb<span class=o>)</span> i args
..
<span class=o>(</span>gdb<span class=o>)</span> l
..</code></pre></div></div><div class=paragraph><p>質問する際には、これらすべての情報を提供して、 問題点の分析ができるようにしてください。</p></div><div class=paragraph><p><code>gdb</code> の使い方に慣れている場合には、実際に dump の原因となった理由やそのアドレス、 関連した変数の値なども調べる事ができるでしょう。</p></div></div><div class=sect2><h3 id=_auto_モードでダイアルをするようなプロセスが接続されない>10.23. auto モードでダイアルをするようなプロセスが接続されない。<a class=anchor href=#_auto_モードでダイアルをするようなプロセスが接続されない></a></h3><div class=paragraph><p>これは ppp がローカル側の IP アドレスを、 動的に通信相手と交渉するように設定されている時に発生する良く知られた障害でした。 最新のバージョンでは、 この問題は修正されています。 <code>iface</code> をマニュアルページから検索してみてください。</p></div><div class=paragraph><p>これは、最初のプログラムが <a href="https://man.freebsd.org/cgi/man.cgi?query=connect&amp;sektion=2&amp;format=html">connect(2)</a> を呼び出した時、<span class=filename>tun</span> インターフェイスの IP アドレスが、 ソケットの終端に割り当てられてしまうという問題です。 カーネルは、 外へ出ていく最初のパケットを作り、それを <span class=filename>tun</span> デバイスへ書き込みます。 そして ppp は、 そのパケットを読み込んで接続を確立します。 ppp は動的に IP アドレスを割り当てるため、 もしインターフェイスのアドレスが変化してしまうと、 最初に割り当てられたソケット終端の IP アドレスは無効になってしまいます。 そのため、それ以降相手に送られるすべてのパケットは通常、 相手に届くことはないでしょう。もし仮に届いたとしても、 既にこちらの IP アドレスは変更されているので、 どんな反応も最初のマシンには戻ってきません。</p></div><div class=paragraph><p>この問題に対処する理論的な方法がいくつかあります。もし可能なら、 相手が再度、同じ IP アドレスを割り当ててくれることが一番です <code>:-)</code>ppp の現在のバージョンはこれを行ないますが、 他のほとんどの実装はそういった動作をしません。</p></div><div class=paragraph><p>我々の側から対処できる最も簡単な方法は、<span class=filename>tun</span> インターフェイスの IP アドレスを固定する事です。またそのかわりに、 外に出ていくパケットを変更して、 発信元 IP アドレスをインターフェイスの IP アドレスから、交渉によって得られた IP アドレスに、 適宜書きかえる事によっても対処できます。 これは、基本的に ppp の最新バージョンにある <code>iface-alias</code> オプションが行なっていることと同じです (<a href="https://man.freebsd.org/cgi/man.cgi?query=libalias&amp;sektion=3&amp;format=html">libalias(3)</a> および、ppp の <code>-nat</code> スイッチにも関係します)。それは、以前の IP アドレスをすべて管理し、 それらを最後の交渉によって得られた IP アドレスに対して NAT 機能を有効化します。</p></div><div class=paragraph><p>もう 1 つの (おそらく最も信頼できる) 方法は、bind された すべてのソケットの IP アドレスを、 異なるものに変更できるシステムコールを実装することです。 pppは、 新しい IP アドレスが割り当てられた時、 このシステムコールを用いて実行されているプログラムにある、 すべてのソケットを書きかえてやるわけです。 同じシステムコールが、DHCP クライアントが利用するソケットを 強制的に再 bind するのにも使うことができるでしょう。</p></div><div class=paragraph><p>3 つ目の方法は、IP アドレスを指定しないでインターフェイスを利用できるようにすることです。 外に出ていくパケットは、最初の <code>SIOCAIFADDR</code> ioctl の完了まで、 255.255.255.255 という IP アドレスが与えられます。 これによって、ソケットは常に bind することができます。 発信元 IP アドレスを変更するのは ppp の仕事です。ただし、 それは発信元 IP アドレスが 255.255.255.255 になっていて、IP アドレスと IP チェックサムを変更する必要がある場合だけです。 これは、カーネルが不適切に設定されたインターフェイスへは 異常なパケットを送出しようとすることを利用して、なにか他の 仕組みが遡及的に修正を行ってくれることを前提にしている、 割り切った方法ではあります。</p></div></div><div class=sect2><h3 id=_何故ほとんどのゲームが_nat_スイッチ付きだと動かないんですか>10.24. 何故ほとんどのゲームが -nat スイッチ付きだと動かないんですか?<a class=anchor href=#_何故ほとんどのゲームが_nat_スイッチ付きだと動かないんですか></a></h3><div class=paragraph><p>libalias を使っている時にゲームなどの類のものが動作しない理由は、 外側にあるマシンが接続しようとしているか、内側にあるマシンに (余計な) UDP パケットを送信しようとしているからです。 内側のマシンにこれらのパケットを送るべきかについて、 NAT ソフトウェアは関知しません。</p></div><div class=paragraph><p>うまく動かすためには、 実行中のものが問題の発生しているソフトウェアだけであるかを確認し、 ゲートウェイの <span class=filename>tun</span> インタフェースに対して <code>tcpdump</code> を実行するか、 ゲートウェイ上で <code>ppp</code> の TCP/IP ログ記録を有効化 (“set log +tcp/ip”) してください。</p></div><div class=paragraph><p>行儀の悪いソフトウェアを起動する際に、 ゲートウェイマシンを通過するパケットを監視すべきです。 外側から何かパケットが戻ってきた時に、 そのパケットは破棄されるでしょう (それが問題なのです)。 これらのパケットのポート番号に注意して、 その行儀の悪いソフトウェアを停止してください。 これを数回繰り返してポート番号が常に同じであるかを確認してみてください。 同じであった場合は、 <span class=filename>/etc/ppp/ppp.conf</span> の適切なセクションに次の行を入れると、 そのソフトウェアは動作するようになるでしょう。</p></div><div class="literalblock programlisting"><div class=content><pre>nat port proto internalmachine:port port</pre></div></div><div class=paragraph><p>ここで <em>proto</em> は <code>tcp</code> か <code>udp</code> であり、 <em>internalmachine</em> はパケットを送りたいマシン、そして <em>port</em> はパケットの送信先のポート番号です。</p></div><div class=paragraph><p>上記のコマンドを変更せずに、 他のマシン上でそのソフトウェアを使用できるようにはしたくないかもしれません。 そして同時に二つの内部のマシン上でそのソフトウェアを実行することは、 この質問の範囲を超えています。結局、外側の世界からは、 内部ネットワーク全体がただ一つのマシンとして見えるのです。</p></div><div class=paragraph><p>ポート番号が常に同じとは限らない場合、さらに三つのオプションがあります。</p></div><div class="olist arabic"><ol class=arabic><li><p>libalias でサポートするようにし、結果を送り付ける。 特定の場合の例は <span class=filename>/usr/src/lib/libalias/alias_*.c</span> にあります (<span class=filename>alias_ftp.c</span> は良いプロトタイプです)。これには通常、外向きの特定のパケットを読み、 内部の計算機のある特定のポートへの接続を開始するような命令が、 外部の計算機対して送られていることを見分け、 後続のパケットがどこに行けばいいのかが分かるように、 エイリアステーブル中の "<em>route</em>" の部分を設定する、という作業が含まれます。</p><div class=paragraph><p>これは最も難しい方法ですが、最も良い方法でもありますし、ソフトウェアが 複数の計算機で動くようにできます。</p></div></li><li><p>プロキシ (proxy) を使う。アプリケーションが、たとえば socks5 をサポートしているか、(cvsup のように) "passive" オプションを持っているとこの方法が使えます。 "passive" とは相手側のほうから接続を求めてくることを避けるためにあるオプションです。</p></li><li><p>“nat addr” を使ってなんでもかんでも内部の計算機に向けて流してしまう。 これはちょっと無理矢理な解決法です。</p></li></ol></div></div><div class=sect2><h3 id=_有用なポート番号のリストはありませんか>10.25. 有用なポート番号のリストはありませんか?<a class=anchor href=#_有用なポート番号のリストはありませんか></a></h3><div class=paragraph><p>まだ出来ていません。しかし、 これは (関心を持って頂けるならば) そういったリストにしていく予定です。 それぞれの例にある <em>internal</em> は、 ゲームで遊ぶマシンの IP アドレスに置き換えてください。</p></div><div class=dlist><dl><dt class=hdlist1>Asheron’s Call</dt></dl></div><div class="literalblock programlisting"><div class=content><pre>nat port udp internal:65000 65000</pre></div></div><div class=paragraph><p>手動でゲームのポート番号を 65000 に変更してください。 マシンが複数ある場合は、それぞれのマシンに重複しないポート番号 (つまり 65001、65002 など) を設定し、その設定ごとに <code>nat port</code> の行を追加します。</p></div><div class=dlist><dl><dt class=hdlist1>Half Life</dt></dl></div><div class="literalblock programlisting"><div class=content><pre>nat port udp internal:27005 27015</pre></div></div><div class=dlist><dl><dt class=hdlist1>PCAnywhere 8.0</dt></dl></div><div class="literalblock programlisting"><div class=content><pre>nat port udp internal:5632 5632
nat port tcp internal:5631 5631</pre></div></div><div class=dlist><dl><dt class=hdlist1>Quake</dt></dl></div><div class="literalblock programlisting"><div class=content><pre>nat port udp internal:6112 6112</pre></div></div><div class=paragraph><p>このように設定する代わりに、 <a href=http://www.battle.net/support/proxy/>www.battle.net</a> で Quake のプロキシ (proxy) がサポートされているか調べてもいいでしょう。</p></div><div class=dlist><dl><dt class=hdlist1>Quake2</dt></dl></div><div class="literalblock programlisting"><div class=content><pre>alias port udp internal:27901 27910</pre></div></div><div class=dlist><dl><dt class=hdlist1>Red Alert</dt></dl></div><div class="literalblock programlisting"><div class=content><pre>nat port udp internal:8675 8675
nat port udp internal:5009 5009</pre></div></div></div><div class=sect2><h3 id=_fcs_エラーって何>10.26. FCS エラーって何?<a class=anchor href=#_fcs_エラーって何></a></h3><div class=paragraph><p>FCS とは <code>F</code>rame <code>C</code>heck <code>S</code>equence (フレームチェックシーケンス) の略です。 個々の ppp パケットには、 送受信するデータが正しいかを調べるためのチェックサムが含まれています。 受信したパケットの FCS が正しくない場合は、そのパケットは廃棄され、 HDLCFCS カウントが増やされます。 HDLC エラーの数は、 <code>show hdlc</code> コマンドを使って表示できます。</p></div><div class=paragraph><p>リンクの品質が悪かったり、 シリアルドライバがパケットを取りこぼしていたりすると、 FCS エラーがたびたび発生します。 FCS エラーは、 圧縮プロトコルの速度低下の原因にはなりますが、 特に心配する必要はありません。 外付けモデムを使っている場合は、 ケーブルがちゃんとシールドされているかを確認してください。 そうでない場合、 FCS エラーの原因となる場合があります。</p></div><div class=paragraph><p>接続直後からリンクがフリーズし、大量の FCS エラーが発生する場合は、 リンクが 8 ビットクリーンでない可能性があります。 ソフトウェアフロー制御 (XON/XOFF) が使われていないことを確認してください。 どうしてもソフトウェアフロー制御を使わなければならない場合は、 <code>set accmap 0x000a0000</code> コマンドを使用して、 ppp に <code>^Q</code> と <code>^S</code> をエスケープさせてください。</p></div><div class=paragraph><p>リモートホストが PPP プロトコルを使用してない場合も、大量の FCS エラーが発生します。 この場合はログをとりながら<em>非同期</em>で接続し、 ログインプロンプトやシェルプロンプトが送られて来ていないか確認してください。</p></div><div class=paragraph><p>ログファイルにリンクを終了した原因となるような記録がない場合は、 リモートホスト (プロバイダ?) の管理者に、 セッションを終了された理由を尋ねてください。</p></div></div><div class=sect2><h3 id=PPPoEwithNAT>10.27. ゲートウェイで PPPoE を実行すると MacOS や Windows 98 との接続がフリーズしてしまうのですが、 これはなぜなのでしょうか?<a class=anchor href=#PPPoEwithNAT></a></h3><div class=paragraph><p>Michael Wozniak <a href=mailto:mwozniak@netcom.ca>mwozniak@netcom.ca</a> 氏が、この現象に関して説明してくれました。 また、Dan Flemming <a href=mailto:danflemming@mac.com>danflemming@mac.com</a> 氏は MacOS での解決策を提供してくれました。 情報の提供に感謝します。</p></div><div class=paragraph><p>これは、いわゆる「ブラックホールルータ (Black Hole router)」に原因があります。 Windows 98 と MacOS (および、おそらく他の Microsoft 社製 OS) の TCP パケット送出は、 PPPoE のフレーム (Ethernet の MTU は標準で 1500) に入らないような大きなセグメントサイズを要求します。 <em>そしてさらに</em>分割禁止 ("don’t fragment") フラグビットを (TCP パケットにデフォルトで) セットするのですが、 Telco のルータは、分割が必須 ("must fragment") であることを示す ICMP メッセージを、接続しようとするウェブサイトに対して送出しません (つまり、ルータは正しく ICMP パケットを送出しているのですが、 ウェブサイトのファイアウォールがそれを落としているのです)。 そのためウェブサーバが PPPoE 接続に対して大きすぎるフレームを送出すると Telco のルータはそのフレームを捨ててしまい、 見ようとしたページが表示されないという症状が現われます (MSS より小さいページや画像は表示されます)。 ほとんどの Telco PPPoE 設定は、標準でこのように設定されているようです。 (ああ、彼らがルーティングプログラムの作り方を理解してさえいれば…​)。</p></div><div class=paragraph><p>一つの解決法は、Windows 95/98 マシンで regedit を使い、 次のレジストリエントリを追加することです。</p></div><div class="literalblock programlisting"><div class=content><pre>HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\Class\NetTrans\0000\MaxMTU</pre></div></div><div class=paragraph><p>レジストリエントリは、"1450" の値 (もっと正確に言うと、TCP パケットを PPPoE フレームに完全に適合させるには "1464" であるべきでですが、 "1450" とすると、現われる可能性がある他の IP プロトコルに対してエラーマージンを確保することができます) にする必要があります。 このレジストリキーは、Windows2000 で <code>Tcpip\Parameters\Interfaces\ID for adapter\MTU</code> に移されたという報告がありました。</p></div><div class=paragraph><p>FreeBSD/NAT/PPPoE ルータと共存させるために Windoze の MTU を変更する方法に関する詳細は、 <a href=http://search.support.microsoft.com/kb>Microsoft Knowledge Base</a> にある、 番号 "Q158474 - Windows TCPIP Registry Entries"、 および番号 "Q120642 - TCPIP & NBT Configuration Parameters for Windows NT" を参照してください。</p></div><div class=paragraph><p>残念なことに、MacOS には TCP/IP 設定を変更する方法がありません。 しかし、<a href=http://www.softworks.com/>Sustainable Softworks 社</a> が販売している OTAdvancedTuner (OT は OpenTransport という MacOS の TCP/IP スタックの名前のこと) のような商用ソフトウェアが存在します。 このソフトウェアは、ユーザから TCP/IP 設定の変更を行なうことを可能にします。 MacOS NAT ユーザはドロップダウンメニューから <code>ip_interface_MTU</code> を選択し、 ボックスにある <code>1500</code> の代わりに <code>1450</code> を入力し、 <code>Save as Auto Configure</code> の隣のボックスをクリックして <code>Make Active</code> をクリックする必要があります。</p></div><div class=paragraph><p>ppp の最新版 (2.3 かそれ以降) には、自動的に MSS を適切な値に調節する <code>enable tcpmssfixup</code> コマンドがあります。 この機能は標準で有効になっています。 もし旧バージョンの ppp を使わなければならない状況にあるなら、 tcpmssd の port をご覧になると良いでしょう。</p></div></div><div class=sect2><h3 id=_どれにも当てはまらない_どうしたらいいの>10.28. どれにも当てはまらない! どうしたらいいの?<a class=anchor href=#_どれにも当てはまらない_どうしたらいいの></a></h3><div class=paragraph><p>これまでのすべての質問に当てはまらない場合、設定ファイル、 ppp の実行方法、ログファイルの該当部分と <code>netstat -rn</code> コマンドの出力 (接続前と接続後) を含む、 あなたの持っているすべての情報を <a href=https://lists.FreeBSD.org/subscription/freebsd-questions>FreeBSD general questions メーリングリスト</a> や <a href=news:comp.unix.bsd.freebsd.misc>comp.unix.bsd.freebsd.misc</a> ニュースグループへ送ってください。誰かがあなたを正しい方向へ導いてくれるでしょう。</p></div></div></div></div><div class=sect1><h2 id=_シリアル接続>11. シリアル接続<a class=anchor href=#_シリアル接続></a></h2><div class=sectionbody><div class=paragraph><p>このセクションでは、FreeBSD でシリアル接続をする時の一般的な質問に答えます。 PPP および SLIP については、 <a href=#networking>ネットワーキング</a>のセクションを参照してください。</p></div><div class=sect2><h3 id=_どうやったら_freebsd_がシリアルポートを認識したことを知る事ができますか>11.1. どうやったら FreeBSD がシリアルポートを認識したことを知る事ができますか?<a class=anchor href=#_どうやったら_freebsd_がシリアルポートを認識したことを知る事ができますか></a></h3><div class=paragraph><p>FreeBSD のカーネルが起動する時、カーネルはその設定にしたがって、 システムのシリアルポートを検出します。起動時に表示されるメッセージをよく観察するか、 起動後に次のコマンドを実行する事によって確認できます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>dmesg | <span class=nb>grep </span>sio</code></pre></div></div><div class=paragraph><p>ここに上に挙げたコマンドの出力例を示します。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>sio0 at 0x3f8-0x3ff irq 4 on isa
sio0: <span class=nb>type </span>16550A
sio1 at 0x2f8-0x2ff irq 3 on isa
sio1: <span class=nb>type </span>16550A</code></pre></div></div><div class=paragraph><p>これは、二つのシリアルポートを示しています。1 番目は、 irq が 4 で <code>0x3f8</code> のポートアドレスを使用しています。 そして、16550A-type UART チップが存在します。 2 番目は、同じチップを使っていますが、 irq は 3 で、<code>0x2f8</code> のポートアドレスを使用しています。内蔵のモデムカードは、 通常のシリアルポートと同じように扱われますが、 常時シリアルポートにモデムが接続されているという点で異なります。</p></div><div class=paragraph><p>GENERIC カーネルは、上の例と同じ irq とポートアドレスの設定の二つのシリアルポートをサポートしています。 これらの設定があなたのシステムに合わない場合、 またはモデムカードを追加した場合やカーネルの設定以上にシリアルポートを持っている場合は、 カーネルを再構築してください。 詳しくは、 <a href=#make-kernel>カーネルの構築</a>の項を参照してください。</p></div></div><div class=sect2><h3 id=_どうやったら_freebsd_がモデムカードを認識したことを知ることができますか>11.2. どうやったら FreeBSD がモデムカードを認識したことを知ることができますか?<a class=anchor href=#_どうやったら_freebsd_がモデムカードを認識したことを知ることができますか></a></h3><div class=paragraph><p>前の質問を参照してください。</p></div></div><div class=sect2><h3 id=_freebsd_2_0_5_にアップグレードしたら_tty0x_が見つからなくなってしまったのですが>11.3. FreeBSD 2.0.5 にアップグレードしたら tty0X が見つからなくなってしまったのですが<a class=anchor href=#_freebsd_2_0_5_にアップグレードしたら_tty0x_が見つからなくなってしまったのですが></a></h3><div class=paragraph><p>心配ありません。 <span class=filename>ttydX</span> に統合されました。 ただ、古い設定ファイルのすべてを更新する必要があります。</p></div></div><div class=sect2><h3 id=_どうやったら_freebsd_でシリアルポートにアクセスできますか>11.4. どうやったら FreeBSD でシリアルポートにアクセスできますか?<a class=anchor href=#_どうやったら_freebsd_でシリアルポートにアクセスできますか></a></h3><div class=paragraph><p>3 番目のポート <span class=filename>sio2</span> (<a href="https://man.freebsd.org/cgi/man.cgi?query=sio&amp;sektion=4&amp;format=html">sio(4)</a> をご覧ください。DOS では、<span class=filename>COM3</span> と呼ばれます。) には、 ダイヤルアウトデバイスとしては <span class=filename>/dev/cuaa2</span>、 ダイヤルインデバイスとして <span class=filename>/dev/ttyd2</span> があります。 それではこの両者にはどのような違いがあるのでしょうか?</p></div><div class=paragraph><p>まず、ダイヤルインの時には <span class=filename>ttydX</span> を使います。 <span class=filename>/dev/ttydX</span> をブロッキングモードでオープンすると、プロセスは対応する <span class=filename>cuaaX</span> デバイスがインアクティブになるのを待ちます。 次に CD 信号がアクティブになるのを待ちます。 <span class=filename>cuaaX</span> デバイスをオープンすると、シリアルポートが <span class=filename>ttydX</span> デバイスによってすでに使われていないかどうかを確認します。 もしこのポートが使用可能であれば、ポートの使用権を <span class=filename>ttydX</span> から「奪い取る」のです。また、 <span class=filename>cuaaX</span> デバイスは CD 信号を監視しません。 この仕組みと自動応答モデムによって、 リモートユーザーをログインさせたり、 同じモデムでダイヤルアウトしたりすることができ、 システムのあらゆるトラブルの面倒を見ることができるでしょう。</p></div></div><div class=sect2><h3 id=_マルチポートシリアルカードをサポートさせるにはどうしたらよいのでしょうか>11.5. マルチポートシリアルカードをサポートさせるにはどうしたらよいのでしょうか?<a class=anchor href=#_マルチポートシリアルカードをサポートさせるにはどうしたらよいのでしょうか></a></h3><div class=paragraph><p>繰り返しになりますが、 <a href=#make-kernel>カーネルコンフィグレーション</a>のセクションでは、 あなたのカーネルの設定についての情報が得られるでしょう。 マルチポートシリアルカードを使用するためには、カーネルの設定ファイルに、 カードの持つそれぞれのシリアルポートに対応する <a href="https://man.freebsd.org/cgi/man.cgi?query=sio&amp;sektion=4&amp;format=html">sio(4)</a> の行を記述する必要があります。しかし、 irq とベクタアドレスは一つのエントリにのみ記述してください。 カード上のすべてのポートは一つの irq を共有しなければなりません。 一貫性を持たせるためにも、 最後のシリアルポートの所で irq を指定してください。 また、<code>COM_MULTIPORT</code> オプションも付けてください。</p></div><div class=paragraph><p>次に示す例は、AST の 4 ポートシリアルカードを irq 7 で設定したものです。</p></div><div class="literalblock programlisting"><div class=content><pre>options &#34;COM_MULTIPORT&#34;
device sio4 at isa? port 0x2a0 tty flags 0x781
device sio5 at isa? port 0x2a8 tty flags 0x781
device sio6 at isa? port 0x2b0 tty flags 0x781
device sio7 at isa? port 0x2b8 tty flags 0x781 irq 7 vector siointr</pre></div></div><div class=paragraph><p>このフラグはマスタポートがマイナー番号 7 (<code>0x700</code>) を持っていて、 検出時の診断機能を有効にし (<code>0x080</code>)、 そしてすべてのポートで irq を共有する (<code>0x001</code>) ということを意味しています。</p></div></div><div class=sect2><h3 id=_freebsd_で複数のマルチポートシリアルカード間で_irq_を共有することはできますか>11.6. FreeBSD で複数のマルチポートシリアルカード間で irq を共有することはできますか?<a class=anchor href=#_freebsd_で複数のマルチポートシリアルカード間で_irq_を共有することはできますか></a></h3><div class=paragraph><p>現在のところはできません。それぞれのカード毎に異なった irq を使ってください。</p></div></div><div class=sect2><h3 id=_ポートにデフォルトのパラメータを設定する事は出来ますか>11.7. ポートにデフォルトのパラメータを設定する事は出来ますか?<a class=anchor href=#_ポートにデフォルトのパラメータを設定する事は出来ますか></a></h3><div class=paragraph><p><span class=filename>ttydX</span> デバイス (または <span class=filename>cuaaX</span> デバイス) は、 アプリケーションのためにオープンする標準的なデバイスです。 プロセスがそのポートをオープンする時、 プロセスはデフォルトの端末 I/O 設定を取得します。 これらの設定は次のコマンドで確認することができます。</p></div><div class="literalblock programlisting"><div class=content><pre>stty -a -f /dev/ttyd1</pre></div></div><div class=paragraph><p>このデバイスに対する設定を変更した場合、 その設定はデバイスをクローズするまで有効です。 デバイスを再オープンした場合、それらの設定はデフォルトに戻ってしまいます。 デフォルトの設定に変更を加えるために、 「初期設定」デバイスをオープンし、 設定を修正することができます。 たとえば、CLOCAL モード、8 ビット、 XON/XOFF フロー制御という設定を <span class=filename>ttyd5</span> のデフォルトにしたい場合、次のように行なってください。</p></div><div class="literalblock programlisting"><div class=content><pre>stty -f /dev/ttyid5 clocal cs8 ixon ixoff</pre></div></div><div class=paragraph><p>この設定を行なうためのコマンドを記述するのに適切なファイルは、 <span class=filename>/etc/rc.serial</span> です。 これでアプリケーションが <span class=filename>ttyd5</span> をオープンした時に、 これらの設定をデフォルトで取得します。 しかし、こういったリンクによる設定は変更可能です。</p></div><div class=paragraph><p>「設定固定」デバイスを調整してやることによって、 アプリケーションによる設定の変更を禁止することができます。 たとえば、<span class=filename>ttyd5</span> の通信速度を 57600bps に固定するには、次のように行ってください。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># stty -f /dev/ttyld5 57600</span></code></pre></div></div><div class=paragraph><p>これにより、アプリケーションは <span class=filename>ttyd5</span> をオープンし、ポートの通信速度を変更しようとしますが、 通信速度は 57600bps のままになります。</p></div><div class=paragraph><p>当然のことながら、初期設定デバイスおよび、設定固定デバイスは <code>root</code> のみが書き込みできるようになっていなければなりません。 しかし、<a href="https://man.freebsd.org/cgi/man.cgi?query=MAKEDEV&amp;sektion=8&amp;format=html">MAKEDEV(8)</a> スクリプトはデバイスエントリを作成する時に、 このような設定は<em>行いません</em>。</p></div></div><div class=sect2><h3 id=_どのようにしたらモデム経由でダイヤルアップログインができるのでしょうか>11.8. どのようにしたらモデム経由でダイヤルアップログインができるのでしょうか?<a class=anchor href=#_どのようにしたらモデム経由でダイヤルアップログインができるのでしょうか></a></h3><div class=paragraph><p>つまり、インターネットサービスプロバイダーになりたいのですね。 それにはまず、1 台ないし複数の自動応答モデムが必要です。 モデムには、キャリアーを検出した時には CD 信号を出力し、 そうでない場合には出力しないことが必要とされます。 また DTR 信号が on から off になった時には、 電話回線を切断し、モデム自身をリセットしなければなりません。 おそらく、RTS/CTS フロー制御を使うか、 ローカルフロー制御をまったく使わないかのどちらかでしょう。 最後に、コンピュータとモデムの間は固定速度でなければなりません。 ただ、(ダイヤルアップの発呼者に対して親切であるためには、 ) こちらのモデムと相手側のモデムの間の速度を、 モデム間で自動調整できるようにすべきでしょう。</p></div><div class=paragraph><p>多くあるヘイズコマンド互換モデムに対して、次のコマンドはこれらの設定を行ない、 その設定を不揮発性メモリーに保存します。</p></div><div class="literalblock programlisting"><div class=content><pre>AT&amp;C1&amp;D3&amp;K3&amp;Q6S0=1&amp;W</pre></div></div><div class=paragraph><p>MS-DOS のターミナルプログラムに頼らずに AT コマンドを送出するには、 <a href=#direct-at>「AT コマンドを入力するには」</a>のセクションを参照してください。</p></div><div class=paragraph><p>次に、モデム用のエントリを <span class=filename>/etc/ttys</span> (<a href="https://man.freebsd.org/cgi/man.cgi?query=ttys&amp;sektion=5&amp;format=html">ttys(5)</a> 参照) に作成しましょう。 このファイルには、 オペレーティングシステムがログインを待っているすべてのポートが記述されています。 以下のような行を追加してください。</p></div><div class="literalblock programlisting"><div class=content><pre>ttyd1 &#34;/usr/libexec/getty std.57600&#34; dialup on insecure</pre></div></div><div class=paragraph><p>この行は、2 番目のシリアルポート (<span class=filename>/dev/ttyd1</span>) には、 57600bps の通信速度でノンパリティ (<code>std.57600</code>: これは <span class=filename>/etc/gettytab</span> に記述されています。<a href="https://man.freebsd.org/cgi/man.cgi?query=gettytab&amp;sektion=5&amp;format=html">gettytab(5)</a> 参照) のモデムが接続されていることを示しています。 このポートの端末タイプは <code>dialup</code> です。 またこのポートは、<code>on</code> すなわちログイン可能であり、<code>insecure</code> です。 これは <code>root</code> がこのポートから直接ログインするのは、 許可されていないということを意味します。 このようなダイヤルインポートに対しては、 <span class=filename>ttydX</span> のエントリを使用してください。</p></div><div class=paragraph><p>これが一般的な、ターミナルタイプとして <code>dialup</code> を使う方法です。多くのユーザーは、 <span class=filename>.profile</span> や <span class=filename>.login</span> で、 ログイン時の端末タイプが <code>dialup</code> であった場合には、 実際の端末タイプをユーザーに問い合わせるように設定しています。 この例は、ポートが <code>insecure</code> でした。このポートで <code>root</code> になるには、 一般ユーザーとしてログインし、それから "<a href=http://www.FreeBSD.org/cgi/man.cgi?su>su</a>" を使って <code>root</code> になってください。 もし、<code>secure</code> を指定したならば、 直接 <code>root</code> がそのポートからログインできます。</p></div><div class=paragraph><p><span class=filename>/etc/ttys</span> に変更を加えた後は、HUP シグナル (SIGHUP) を <a href="https://man.freebsd.org/cgi/man.cgi?query=init&amp;sektion=8&amp;format=html">init(8)</a> プロセスに送る必要があります。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kill -HUP 1</span></code></pre></div></div><div class=paragraph><p>この操作は <code>init</code> プロセスに <span class=filename>/etc/ttys</span> を再読み込みさせます。 これにより、init プロセスは <code>getty</code> プロセスをすべての <code>on</code> となっているポートに起動させます。 次のようにして、ポートがログイン可能かを知ることができます。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ps <span class=nt>-ax</span> | <span class=nb>grep</span> <span class=s1>&#39;[t]tyd1&#39;</span></code></pre></div></div><div class=paragraph><p>ログイン可能であれば、次のような出力が得られるはずです。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>747 ??  I      0:00.04 /usr/libexec/getty std.57600 ttyd1</code></pre></div></div></div><div class=sect2><h3 id=_ダムターミナルを_freebsd_マシンに接続するにはどうしたらよいのでしょうか>11.9. ダムターミナルを FreeBSD マシンに接続するにはどうしたらよいのでしょうか?<a class=anchor href=#_ダムターミナルを_freebsd_マシンに接続するにはどうしたらよいのでしょうか></a></h3><div class=paragraph><p>もし、他のコンピューターを FreeBSD の端末として接続したいのならば、 お互いのシリアルポート間をつなぐヌルモデムケーブル (訳注: リバースケーブルもしくはクロスケーブルとも呼ばれます) を用意してください。 もし、既製の端末を使う場合は、付属するマニュアルを参照してください。</p></div><div class=paragraph><p>そして、<span class=filename>/etc/ttys</span> (<a href="https://man.freebsd.org/cgi/man.cgi?query=ttys&amp;sektion=5&amp;format=html">ttys(5)</a> 参照) を上と同じように変更してください。 たとえば、WYSE-50 という端末を 5 番目のポートに接続するならば、 次のようなエントリを使用してください。</p></div><div class="literalblock programlisting"><div class=content><pre>ttyd4 &#34;/usr/libexec/getty std.38400&#34; wyse50 on secure</pre></div></div><div class=paragraph><p>この例は、<span class=filename>/dev/ttyd4</span> ポートにノンパリティ、 端末タイプが wyse50、通信速度が 38400bps (<code>std.38400</code>: この設定は、 <span class=filename>/etc/gettytab</span> に記述されています。<a href="https://man.freebsd.org/cgi/man.cgi?query=gettytab&amp;sektion=5&amp;format=html">gettytab(5)</a> 参照) の端末が存在しており、 <code>root</code> のログインが許可されている (<code>secure</code>) であることを示しています。</p></div></div><div class=sect2><h3 id=_どうして_tip_や_cu_が動かないのですか>11.10. どうして tip や cu が動かないのですか?<a class=anchor href=#_どうして_tip_や_cu_が動かないのですか></a></h3><div class=paragraph><p>おそらくあなたのシステムでは <a href="https://man.freebsd.org/cgi/man.cgi?query=tip&amp;sektion=1&amp;format=html">tip(1)</a> や <a href="https://man.freebsd.org/cgi/man.cgi?query=cu&amp;sektion=1&amp;format=html">cu(1)</a> は <code>uucp</code> ユーザーか、 <code>dialer</code> グループによってのみ実行可能なのでしょう。 <code>dialer</code> グループは、 モデムやリモートシステムにアクセスするユーザーを管理するために、 使用することができます。 それには、<span class=filename>/etc/group</span> ファイルの <code>dialer</code> グループにあなた自身を追加してください。</p></div><div class=paragraph><p>そうする代わりに、次のようにタイプすることにより、 あなたのシステムの全ユーザーが <code>tip</code> や <code>cu</code> を実行できるようになります。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># chmod 4511 /usr/bin/cu</span>
<span class=c># chmod 4511 /usr/bin/tip</span></code></pre></div></div></div><div class=sect2><h3 id=_私の_hayes_モデムはサポートされていないのですが_どうしたらいいのでしょうか>11.11. 私の Hayes モデムはサポートされていないのですが、 どうしたらいいのでしょうか。<a class=anchor href=#_私の_hayes_モデムはサポートされていないのですが_どうしたらいいのでしょうか></a></h3><div class=paragraph><p>実際、 <a href="https://man.freebsd.org/cgi/man.cgi?query=tip&amp;sektion=1&amp;format=html">tip(1)</a> のオンラインマニュアルは古くなっています。 すでに、Hayes ダイアラが実装されています。 <span class=filename>/etc/remote</span> ファイル (<a href="https://man.freebsd.org/cgi/man.cgi?query=remote&amp;sektion=5&amp;format=html">remote(5)</a> 参照) で、 “at=hayes” と指定してください。</p></div><div class=paragraph><p>Hayes ドライバは、最近のモデムの新しい機能である、 <code>BUSY</code>、 <code>NO DIALTONE</code>、 <code>CONNECT 115200</code> などのメッセージを認識できるほど賢くはなく、 単に混乱を起こすだけです。 <a href="https://man.freebsd.org/cgi/man.cgi?query=tip&amp;sektion=1&amp;format=html">tip(1)</a> を使う場合には (<code>ATX0&amp;W</code>とするなどして)、 これらのメッセージを表示させないようにしなくてはいけません。</p></div><div class=paragraph><p>また、<code>tip</code> のダイヤルのタイムアウトは 60 秒です。 モデムのタイムアウト設定はそれより短くすべきであり、 そうしないと <code>tip</code> は通信に問題があると判断するでしょう。 <code>ATS7=45&amp;W</code> を実行してください。</p></div><div class=paragraph><p>実際、デフォルトの <code>tip</code> は Hayes の完全なサポートをしているわけではありません。 解決方法は <span class=filename>/usr/src/usr.bin/tip/tip</span> の下の <span class=filename>tipconf.h</span> を変更することです。 もちろん、これにはソース配布ファイルが必要です。</p></div><div class=paragraph><p>“#define HAYES 0” と記述されている行を “#define HAYES1” と変更し、そして “make” と “make install” を実行します。これでうまく動作するでしょう。</p></div></div><div class=sect2><h3 id=_これらの_at_コマンドを入力するには>11.12. これらの AT コマンドを入力するには?<a class=anchor href=#_これらの_at_コマンドを入力するには></a></h3><div class=paragraph><p><span class=filename>/etc/remote</span> ファイル (<a href="https://man.freebsd.org/cgi/man.cgi?query=remote&amp;sektion=5&amp;format=html">remote(5)</a> 参照) の中で "direct" エントリを作ります。 たとえばモデムが 1 番目のシリアルポートである [.filename]#/dev/cuaa0#に接続されている場合、 次のようにします。</p></div><div class="literalblock programlisting"><div class=content><pre>cuaa0:dv=/dev/cuaa0:br#19200:pa=none</pre></div></div><div class=paragraph><p>モデムがサポートする最大の bps レートを <code>br</code> フィールドに使います。 そして <code>tip cuaa0</code> (<a href="https://man.freebsd.org/cgi/man.cgi?query=tip&amp;sektion=1&amp;format=html">tip(1)</a> 参照) を実行すると、モデムが利用できるようになります。</p></div><div class=paragraph><p><span class=filename>/dev/cuaa0</span>がシステムに存在しない場合は、次のようにします。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /dev</span>
<span class=c># ./MAKEDEV cuaa0</span></code></pre></div></div><div class=paragraph><p>または <code>root</code> になって以下のように cu を使います。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cu -lline -sspeed</span></code></pre></div></div><div class=paragraph><p><em>line</em> にはシリアルポート (たとえば <span class=filename>/dev/cuaa0</span>)を指定します。 そして <em>speed</em> には接続する速度 (たとえば <code>57600</code>) を指定します。 その後 AT コマンドを実行したら、 <code>~.</code> と入力すれば終了します。</p></div></div><div class=sect2><h3 id=_pn_機能の_記号が使えません>11.13. pn 機能の &lt;@> 記号が使えません!<a class=anchor href=#_pn_機能の_記号が使えません></a></h3><div class=paragraph><p>電話番号 (pn) 機能の中での <code>&lt;@></code> 記号は、 <code>tip</code> に <span class=filename>/etc/phones</span> にある電話番号を参照するように伝えます。しかし <code>&lt;@></code> の文字は <span class=filename>/etc/remote</span> のような設定ファイルの中では特殊文字となります。 そこで、バックスラッシュを使ってエスケープを行います。</p></div><div class="literalblock programlisting"><div class=content><pre>pn=\@</pre></div></div></div><div class=sect2><h3 id=_コマンドラインから電話番号を指定するには>11.14. コマンドラインから電話番号を指定するには?<a class=anchor href=#_コマンドラインから電話番号を指定するには></a></h3><div class=paragraph><p>“generic” エントリと呼ばれるものを <span class=filename>/etc/remote</span> ファイル (<a href="https://man.freebsd.org/cgi/man.cgi?query=remote&amp;sektion=5&amp;format=html">remote(5)</a> 参照) に追加します。 たとえば、次のようにします。</p></div><div class="literalblock programlisting"><div class=content><pre>tip115200|Dial any phone number at 115200 bps:\
:dv=/dev/cuaa0:br#115200:at=hayes:pa=none:du:
tip57600|Dial any phone number at 57600 bps:\
:dv=/dev/cuaa0:br#57600:at=hayes:pa=none:du:</pre></div></div><div class=paragraph><p>そして “tip -115200 5551234” のように利用できます。 <a href="https://man.freebsd.org/cgi/man.cgi?query=tip&amp;sektion=1&amp;format=html">tip(1)</a> より <a href="https://man.freebsd.org/cgi/man.cgi?query=cu&amp;sektion=1&amp;format=html">cu(1)</a> を使いたい場合、 <code>cu</code> の <code>generic</code> エントリを使います。</p></div><div class="literalblock programlisting"><div class=content><pre>cu115200|Use cu to dial any number at 115200bps:\
:dv=/dev/cuaa1:br#57600:at=hayes:pa=none:du:</pre></div></div><div class=paragraph><p>そして “cu 5551234 -s 115200” と実行します。</p></div></div><div class=sect2><h3 id=_毎回_bps_レートを入力しなければいけませんか>11.15. 毎回 bps レートを入力しなければいけませんか?<a class=anchor href=#_毎回_bps_レートを入力しなければいけませんか></a></h3><div class=paragraph><p><code>tip1200</code> や <code>cu1200</code> 用のエントリを記述し、 適切な通信速度を <code>br</code> フィールドに設定します。 <a href="https://man.freebsd.org/cgi/man.cgi?query=tip&amp;sektion=1&amp;format=html">tip(1)</a> は 1200bps が正しいデフォルト値であるとみなすので、 “tip1200” エントリを参照します。 もちろん 1200bps を使わなければならないわけではありません。</p></div></div><div class=sect2><h3 id=_ターミナルサーバを経由して複数のホストへアクセスしたいのですが>11.16. ターミナルサーバを経由して複数のホストへアクセスしたいのですが。<a class=anchor href=#_ターミナルサーバを経由して複数のホストへアクセスしたいのですが></a></h3><div class=paragraph><p>毎回接続されるのを待って “CONNECT &lt;host>” と入力するかわりに、 <code>tip</code> の <code>cm</code> 機能を使います。 たとえば、<span class=filename>/etc/remote</span> (<a href="https://man.freebsd.org/cgi/man.cgi?query=remote&amp;sektion=5&amp;format=html">remote(5)</a> 参照) に次のようなエントリを追加します。</p></div><div class="literalblock programlisting"><div class=content><pre>pain|pain.deep13.com|Forrester&#39;s machine:\
:cm=CONNECT pain\n:tc=deep13:
muffin|muffin.deep13.com|Frank&#39;s machine:\
:cm=CONNECT muffin\n:tc=deep13:
deep13:Gizmonics Institute terminal server:\
:dv=/dev/cuaa2:br#38400:at=hayes:du:pa=none:pn=5551234:</pre></div></div><div class=paragraph><p>これで、“tip pain” や “tip muffin” と実行すると <code>pain</code> や <code>muffin</code> のホストに接続することができ、 “tip deep13” を実行するとターミナルサーバに接続します。</p></div></div><div class=sect2><h3 id=_tip_を使ってそれぞれのサイトの複数の回線に接続できますか>11.17. tip を使ってそれぞれのサイトの複数の回線に接続できますか?<a class=anchor href=#_tip_を使ってそれぞれのサイトの複数の回線に接続できますか></a></h3><div class=paragraph><p>これは大学に電話回線がいくつかあって、 数千人の学生が接続しようとする場合によくある問題です。</p></div><div class=paragraph><p>あなたの大学のエントリを <span class=filename>/etc/remote</span> ファイル (<a href="https://man.freebsd.org/cgi/man.cgi?query=remote&amp;sektion=5&amp;format=html">remote(5)</a> 参照) に作成して、 <code>pn</code> のフィールドには <code>&lt;\@></code> を使います。</p></div><div class="literalblock programlisting"><div class=content><pre>big-university:\
:pn=\@:tc=dialout
dialout:\
:dv=/dev/cuaa3:br#9600:at=courier:du:pa=none:</pre></div></div><div class=paragraph><p>そして <span class=filename>/etc/phones</span> ファイル (<a href="https://man.freebsd.org/cgi/man.cgi?query=phones&amp;sektion=5&amp;format=html">phones(5)</a> 参照) に大学の電話番号の一覧を書きます。</p></div><div class="literalblock programlisting"><div class=content><pre>big-university 5551111
big-university 5551112
big-university 5551113
big-university 5551114</pre></div></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=tip&amp;sektion=1&amp;format=html">tip(1)</a> は一連の電話番号を上から順に試みて、 最終的に接続できなければあきらめます。リトライを続けさせたい場合は、 <code>tip</code> を while ループに入れて実行します。</p></div></div><div class=sect2><h3 id=_ctrlp_を_1_回送るために_2_度押す必要があるのはなぜ>11.18. CTRL+P を 1 回送るために 2 度押す必要があるのはなぜ?<a class=anchor href=#_ctrlp_を_1_回送るために_2_度押す必要があるのはなぜ></a></h3><div class=paragraph><p><kbd>CTRL</kbd>+<kbd>P</kbd> は通常「強制 (force)」文字であり、 <a href="https://man.freebsd.org/cgi/man.cgi?query=tip&amp;sektion=1&amp;format=html">tip(1)</a> に次の文字がリテラルデータであることを伝えます。 強制文字は「変数の設定」を意味する <code>~s</code> エスケープによって、 他の文字にすることができます。</p></div><div class=paragraph><p>“~sforce=&lt;single-char>” と入力して改行します。 <em>&lt;single-char></em> は、任意の 1 バイト文字です。 <em>&lt;single-char></em> を省略すると <code>NUL</code> 文字になり、 これは <kbd>CTRL</kbd>+<kbd>2</kbd> や <kbd>CTRL</kbd>+<kbd>SPACE</kbd> を押しても入力できます。 いくつかのターミナルサーバで使われているのを見ただけですが、 <em>&lt;single-char></em> に <kbd>SHIFT</kbd>+<kbd>CTRL</kbd>+<kbd>6</kbd> に割り当てるのもよいでしょう。</p></div><div class=paragraph><p><span class=filename>$HOME/.tiprc</span> に次のように定義することで、 任意の文字を強制文字として利用できます。</p></div><div class="literalblock programlisting"><div class=content><pre>force=&lt;single-char&gt;</pre></div></div></div><div class=sect2><h3 id=_打ち込んだ文字が突然すべて大文字になりました>11.19. 打ち込んだ文字が突然すべて大文字になりました??<a class=anchor href=#_打ち込んだ文字が突然すべて大文字になりました></a></h3><div class=paragraph><p><kbd>CTRL</kbd>+<kbd>A</kbd> を押してしまい、<kbd>caps-lock</kbd> キーが壊れている場合のために設計された <a href="https://man.freebsd.org/cgi/man.cgi?query=tip&amp;sektion=1&amp;format=html">tip(1)</a> の "raise character" モードに入ったのでしょう。 既に述べた <code>~s</code> を使って、 "raisechar" をより適切な値に変更してください。 もしこれら両方の機能を使用しないのであれば、 強制文字と同じ設定にすることもできます。</p></div><div class=paragraph><p>以下は <kbd>CTRL</kbd>+<kbd>2</kbd> や <kbd>CTRL</kbd>+<kbd>A</kbd> などを頻繁に使う必要のある Emacs ユーザにうってつけの <span class=filename>.tiprc</span> ファイルのサンプルです。</p></div><div class="literalblock programlisting"><div class=content><pre>force=^^
raisechar=^^</pre></div></div><div class=paragraph><p><code>^</code> は <kbd>SHIFT</kbd>+<kbd>CTRL</kbd>+<kbd>6</kbd> です。</p></div></div><div class=sect2><h3 id=_tip_でファイルを転送するには>11.20. tip でファイルを転送するには?<a class=anchor href=#_tip_でファイルを転送するには></a></h3><div class=paragraph><p>もし他の UNIX のシステムと接続しているなら、 <code>~p</code> (送信) や <code>~t</code> (受信) でファイルの送受信ができます。 これらのコマンドは、相手のシステムの上で <a href="https://man.freebsd.org/cgi/man.cgi?query=cat&amp;sektion=1&amp;format=html">cat(1)</a> や <a href="https://man.freebsd.org/cgi/man.cgi?query=echo&amp;sektion=1&amp;format=html">echo(1)</a> を実行することで送受信をします。書式は以下のようになります。</p></div><div class="literalblock programlisting"><div class=content><pre>~p &lt;ローカルのファイル名&gt; [&lt;リモートのファイル名&gt;]
~t &lt;リモートのファイル名&gt; [&lt;ローカルのファイル名&gt;]</pre></div></div><div class=paragraph><p>この方法ではエラーチェックを行いませんので、 zmodem などの他のプロトコルを使った方がよいでしょう。</p></div></div><div class=sect2><h3 id=_tip_から_zmodem_を実行するには>11.21. tip から zmodem を実行するには?<a class=anchor href=#_tip_から_zmodem_を実行するには></a></h3><div class=paragraph><p>まず始めに、FreeBSD Ports Collection から zmodem プログラムのいずれか (lrzszと rzsz の、通信カテゴリーの2 つのプログラムのどちらか) をインストールします。</p></div><div class=paragraph><p>ファイルを受信するには、リモート側で送信プログラムを起動します。 そして、<kbd>Enter</kbd> キーを押してから “~C rz” (lrzsz をインストールした場合は “~C lrz”) と入力すると、 ローカル側へのファイルの受信が始まります。</p></div><div class=paragraph><p>ファイルを送信するには、リモート側で受信プログラムを起動します。 そして、<kbd>Enter</kbd> キーを押してから “~C sz &lt;files>” (lrzsz をインストールした場合は “~C lsz &lt;files>”) と入力すると、リモート側へのファイルの送信が始まります。</p></div></div><div class=sect2><h3 id=_設定が正しいのにもかかわらずfreebsd_がシリアルポートを見付けられません>11.22. 設定が正しいのにもかかわらず、FreeBSD がシリアルポートを見付けられません。<a class=anchor href=#_設定が正しいのにもかかわらずfreebsd_がシリアルポートを見付けられません></a></h3><div class=paragraph><p>マザーボードやシリアルカードが Acer の UART チップを使った物の場合、 FreeBSD の <span class=filename>sio</span> ドライバでは正しく検出する事が出来ません。 この問題を解決するためには、 <a href=http://www.lemis.com/serial-port-patch.html>www.lemis.com</a> からパッチを入手してください。</p></div></div></div></div><div class=sect1><h2 id=_その他の質問>12. その他の質問<a class=anchor href=#_その他の質問></a></h2><div class=sectionbody><div class=sect2><h3 id=_freebsd_は_linux_より多くのスワップ領域を消費するのはなぜですか>12.1. FreeBSD は Linux より多くのスワップ領域を消費するのはなぜですか?<a class=anchor href=#_freebsd_は_linux_より多くのスワップ領域を消費するのはなぜですか></a></h3><div class=paragraph><p>実際にはそうではありません。 FreeBSD は Linux よりもスワップを多く使っているように見えるだけです。 この点における FreeBSD と Linux の主な違いは、 FreeBSD はより多くのメインメモリを有効利用できるようにするため、 完全にアイドルになったものやメインメモリ上の使われなくなったページを、 スワップにあらかじめ積極的に移動しているということです。 Linux では、 最後の手段としてページをスワップに移動させるだけという傾向があります。 このスワップの使い方は、 メインメモリをより効果的に使用することによってバランスが保たれています。</p></div><div class=paragraph><p>FreeBSD はこのような状況では先手策を取りますが、 システムが本当に空き状態の時に、 理由も無くページをスワップしようと決めることはないということに注意してください。 したがって、 夜中に使わずにおいたシステムが朝起きたとき、 すべてページアウトされているということはないのです。</p></div></div><div class=sect2><h3 id=_ほとんどプログラムは実行されていないのに_どうして_top1_は非常に少ない_free_memory_を報告するのでしょうか>12.2. ほとんどプログラムは実行されていないのに、 どうして <a href="https://man.freebsd.org/cgi/man.cgi?query=top&amp;sektion=1&amp;format=html">top(1)</a> は非常に少ない free memory を報告するのでしょうか?<a class=anchor href=#_ほとんどプログラムは実行されていないのに_どうして_top1_は非常に少ない_free_memory_を報告するのでしょうか></a></h3><div class=paragraph><p>簡単に言えば、free memory とは無駄になっているメモリのことだからです。 プログラムが確保しているメモリ以外のすべてのメモリは、 FreeBSD カーネル内でディスクキャッシュとして利用されます。 この値は <a href="https://man.freebsd.org/cgi/man.cgi?query=top&amp;sektion=1&amp;format=html">top(1)</a> において <code>Inact</code>、 <code>Cache Buf</code> として表示され、 それぞれは異なるエージングレベル (訳注: データがどれだけ古いかを示す評価値) でキャッシュされた全データを表します。 データがキャッシュされると言うのは、 最近アクセスされたデータであれば、 再度そのデータをアクセスするためにシステムが遅いディスクにアクセスする必要がない、 ということを意味します。 そのため、全体のパフォーマンスが向上します。 一般的に、<a href="https://man.freebsd.org/cgi/man.cgi?query=top&amp;sektion=1&amp;format=html">top(1)</a> で表示される <code>Free</code> メモリが小さい値を示すことは良いことで、 自由に使えるメモリの残量が<em>本当に</em>少ない、 ということを表しているわけではありません。</p></div></div><div class=sect2><h3 id=_freebsd_の実行フォーマットの_a_outelf_とはどのようなものですか_またa_outelf_を使う理由は何でしょう>12.3. FreeBSD の実行フォーマットの a.out、ELF とはどのようなものですか? また、a.out、ELF を使う理由は何でしょう?<a class=anchor href=#_freebsd_の実行フォーマットの_a_outelf_とはどのようなものですか_またa_outelf_を使う理由は何でしょう></a></h3><div class=paragraph><p>FreeBSD が何故 ELF フォーマットを利用しているのかを理解するためには、 まず UNIXにおいて現在「優勢」な 3 種類の実行フォーマットについて いくらか知っておく必要があります。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>FreeBSD 3.x より前の FreeBSD では a.out フォーマットが使われていました。</p></div></td></tr></tbody></table></div><div class=ulist><ul><li><p><a href="https://man.freebsd.org/cgi/man.cgi?query=a.out&amp;sektion=5&amp;format=html">a.out(5)</a></p><div class=paragraph><p>最も古く 「由緒正しい」 unix オブジェクトフォーマットです。 マジックナンバを含む短くてコンパクトなヘッダが先頭にあり、 これがフォーマットの特徴とされています (<a href="https://man.freebsd.org/cgi/man.cgi?query=a.out&amp;sektion=5&amp;format=html">a.out(5)</a> に詳細な内容があります)。 ロードされる 3種類のセグメント、 <code>.text</code>、 <code>.data</code>、 <code>.bss</code> と加えてシンボルテーブルと文字列テーブルを含みます。</p></div></li><li><p>COFF</p><div class=paragraph><p>SVR3 のオブジェクトフォーマットです。 ヘッダは単一のセクションテーブルから成り、 <code>.text</code>、 <code>.data</code>、 <code>.bss</code> セクション以外の部分を持つことができます。</p></div></li><li><p>ELF</p><div class=paragraph><p>COFFの後継です。複数のセクションをサポートし、32-bit と 64-bitのいずれの値も可能です。大きな欠点の一つは、ELF はそれぞれのシステムアーキテクチャ毎に単一の ABI のみが存在するという仮定で設計されていることです。 この仮定はまったく正しくありません。 商用の SYSV の世界でさえそうです (少なくとも SVR4、 Solaris、SCO の 3種類の ABI があります)。</p></div><div class=paragraph><p>FreeBSD はこの問題を解決するための試みとして、 既知の ELF 実行ファイルに ABI に応じた情報を <em>書き加える</em>ユーティリティを提供しています。 詳しくは <a href="https://man.freebsd.org/cgi/man.cgi?query=brandelf&amp;sektion=1&amp;format=html">brandelf(1)</a> のマニュアルページを参照してください。</p></div></li></ul></div><div class=paragraph><p>FreeBSD は伝統的な立場をとり、数多くの世代の BSD のリリースで試され、実証されてきた <a href="https://man.freebsd.org/cgi/man.cgi?query=a.out&amp;sektion=5&amp;format=html">a.out(5)</a> フォーマットを伝統的に使用しています。 いつかは FreeBSD システムでネイティブ ELF バイナリを作り、 実行することができるようになるかもしれませんが、 初期の頃 FreeBSD では ELF をデフォルトのフォーマットに変更するという動きは ありませんでした。なぜでしょうか? ところで Linux においては、 ELF への苦痛をともなった変更は、 その時に <span class=filename>a.out</span> 実行フォーマットから逃れたというよりは、 ジャンプテーブルベースの共有ライブラリのメカニズムの柔軟性の低さからの脱却でした。 これはベンダや開発者全体にとって、 共有ライブラリの作成が非常に難しかった原因でした。 ELF のツールには共有ライブラリの問題を解決することができるものが提供されており、 またいずれにせよ一般的に「進歩」していると考えられます。 このため移行のコストは必要なものとして容認され、 移行は行なわれました。</p></div><div class=paragraph><p>FreeBSD の場合は、共有ライブラリのメカニズムは Sun の SunOS 形式の共有ライブラリの メカニズムに極めて近いものになっていて、 非常に使いやすいものになっています。 しかしながら、FreeBSD では 3.0 から ELF バイナリをデフォルトのフォーマットとして公式にサポートしています。 a.out 実行フォーマットはよいものを私達に提供してくれているものの、 私たちの使っているコンパイラの作者である GNU の人々は a.out フォーマットのサポートをやめてしまったのでした。 このことは、 私たちに別バージョンのコンパイラとリンカを保守することを余儀なくされることとなり、 最新の GNU 開発の努力による恩恵から遠ざかることになります。 その上、ISO C++ の、 とくにコンストラクタやデストラクタがらみの要求もあって、今後の FreeBSD のリリースでネイティブの ELF のサポートされる方向へと話が進んでいます。</p></div></div><div class=sect2><h3 id=_それにしてもなぜそんなに多くのフォーマットがあるのですか>12.4. それにしても、なぜそんなに多くのフォーマットがあるのですか?<a class=anchor href=#_それにしてもなぜそんなに多くのフォーマットがあるのですか></a></h3><div class=paragraph><p>もうおぼろげになってしまった暗い過去に、単純なハードウェアがありました。 この単純なハードウェアは、単純で小さなシステムをサポートしていました。 a.out はこの単純なシステム (PDP-11) での作業を行なうバイナリとして完全に適したものだったのです。 人々はこの単純なシステムから UNIX を移植する際に、a.out フォーマットをそのまま使いました。というのは Motorola 68k、VAXen、 といったアーキテクチャへの UNIX の初期の移植ではこれで十分だったからです。</p></div><div class=paragraph><p>やがてある聡明なエンジニアが、 ソフトウェアでちょっとしたトリックを使うことを決めました。 彼はいくつかのゲートを削り取って CPU のコアをより速く走らせることができたのです。 これは新しい種類のハードウェア (今日では RISC として知られています) で動いたのです。 a.out はこのハードウェアには適していなかったので、 このハードウェア上で多くのフォーマットが、 限定された単純な a.out フォーマットでのものよりもより良いパフォーマンスを出すことを目指して開発されたのです。 COFF、ECOFF、 そしていくつかの有名でないフォーマットが ELF が標準になる前に開発され、 それらの限界が探求されたのです。</p></div><div class=paragraph><p>さらに、プログラムサイズは巨大になり、 ディスク (および物理メモリ) は依然として相対的に小さかったため、 共用ライブラリのコンセプトが誕生しました。 また、VM システムはより複雑なものになりました。 これらの個々の進歩は a.out フォーマットを使用して遂げられましたが、 その有用性は新しい機能とともにどんどん広がってきました。 これらに加え、実行時に必要なものを動的にロードする、 または初期化コードの実行後にプログラムの一部を破棄し、 コアメモリおよびスワップ空間を節約するという要望が高まりました。 プログラミング言語はさらに複雑になり、<code>main</code> 関数の前に自動的にコールされるコードの要望が高まりました。 多くの機能拡張が行なわれ、a.out フォーマットがこれらすべてを実現できるようになり、 それらはしばらくは基本的に動作していました。 やがて、a.out はコードでのオーバヘッドと複雑さを増大させずに、 これらの問題すべてを処理することに無理がでてきました。 一方、ELF はこれらの問題の多くを解決しますが、 現状稼働しているシステムからの切替えは厄介なものになるでしょう。 そのため ELF は、a.out のままでいることが ELF への移行よりももっと厄介なものになるまで待つ必要がありました。</p></div><div class=paragraph><p>しかし時が経つにつれ、FreeBSD のビルドツールの元となったツール群 (特にアセンブラとローダ) と FreeBSD のビルドツール群は異なった進化の経路をたどりました。 FreeBSD のツリーでは、共有ライブラリが追加され、 バグフィックスも行われました。 もともとのツール群を作成した GNU の人たちは、プログラムを書き直し、 クロスコンパイラのサポート、 異なるフォーマットを任意に取り込む機能などを追加していきました。 多くの人々が FreeBSD をターゲットとしたクロスコンパイラの構築を試みましたが、 FreeBSD の使っている <code>as</code> と <code>ld</code> の古いプログラムコードはクロスコンパイルをサポートしておらず、 うまくいきませんでした。 新しい GNU のツール群 (binutils) は、 クロスコンパイル、共有ライブラリ、C++ 拡張などの機能をサポートしています。 さらに数多くのベンダが ELF バイナリをリリースしています。 FreeBSD にとって ELF バイナリが実行できることは、 非常にメリットがあります。ELF バイナリが FreeBSD で動くのなら、a.out を動かすのに手間をかける必要はありませんね。 長い間忠実によく働いた老いた馬は、 そろそろ牧草地で休ませてあげましょう。</p></div><div class=paragraph><p>ELF は a.out に比べてより表現力があり、 ベースのシステムに対してより幅広い拡張性を提供できます。 ELF 用のツールはよりよく保守されています。 また多くの人にとって重要なクロスコンパイルもサポートしています。 ELF の実行速度は、ほんの少し a.out より遅いかもしれませんが、 実際に速度の差をはかるのは困難でしょう。 ELF と a.out の間には、ページマッピング、 初期化コードの処理など多くの違いがありますが、 とりたてて重要なものはありません。しかし違いがあるのは確かです。ほどなく、 GENERIC カーネルから a.out のサポートが外されます。 a.out のプログラムを実行する必要性がなくなれば、 最終的に a.out のサポートはカーネルから削除されます。</p></div></div><div class=sect2><h3 id=_シンボリックリンクの許可属性を_chmod_で変えられないのはなぜですか>12.5. シンボリックリンクの許可属性を chmod で変えられないのはなぜですか?<a class=anchor href=#_シンボリックリンクの許可属性を_chmod_で変えられないのはなぜですか></a></h3><div class=paragraph><p>シンボリックリンクは許可属性を持ちません。 また <a href="https://man.freebsd.org/cgi/man.cgi?query=chmod&amp;sektion=1&amp;format=html">chmod(1)</a> のデフォルト動作は、 シンボリックリンクをたどってリンク先のファイルの許可属性を変更するようになっていません。 そのため、 <span class=filename>foo</span> というファイルがあり、 このファイルへのシンボリックリンク <span class=filename>bar</span> があったとすると、 以下のコマンドは常に成功します。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>chmod </span>g-w bar</code></pre></div></div><div class=paragraph><p>しかしこの場合、<span class=filename>foo</span> の許可属性は変更されません。</p></div><div class=paragraph><p>この場合、“-H” か “-L” のどちらかのオプションを “-R” と同時に使う必要があります。 <a href="https://man.freebsd.org/cgi/man.cgi?query=chmod&amp;sektion=1&amp;format=html">chmod(1)</a> と <a href="https://man.freebsd.org/cgi/man.cgi?query=symlink&amp;sektion=7&amp;format=html">symlink(7)</a> のマニュアルページにはもっと詳しい情報があります。</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>“-R” オプションは<em>再帰的に</em> <a href="https://man.freebsd.org/cgi/man.cgi?query=chmod&amp;sektion=1&amp;format=html">chmod(1)</a> を実行します。ディレクトリやディレクトリへのシンボリックリンクを <code>chmod</code> する場合は気をつけてください。 シンボリックリンクで参照されている単一のディレクトリのパーミッションを変更したい場合は、 <a href="https://man.freebsd.org/cgi/man.cgi?query=chmod&amp;sektion=1&amp;format=html">chmod(1)</a> をオプションをつけずに、 シンボリックリンクの名前の後ろにスラッシュ ("<span class=filename>/</span>") をつけて使います。たとえば、"<span class=filename>foo</span>" がディレクトリ "<span class=filename>bar</span>" へのシンボリックリンクである場合、 "<span class=filename>foo</span>" (実際には "<span class=filename>bar</span>") のパーミッションを変更したい場合には、このようにします。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>chmod </span>555 foo/</code></pre></div></div><div class=paragraph><p>後ろにスラッシュをつけると、 <a href="https://man.freebsd.org/cgi/man.cgi?query=chmod&amp;sektion=1&amp;format=html">chmod(1)</a> はシンボリックリンク "<span class=filename>foo</span>" を追いかけてディレクトリ "<span class=filename>bar</span>" のパーミッションを変更します。</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=_ログイン名がいまだに_8_文字に制限されているのはなぜですか>12.6. ログイン名がいまだに 8 文字に制限されているのはなぜですか?<a class=anchor href=#_ログイン名がいまだに_8_文字に制限されているのはなぜですか></a></h3><div class=paragraph><p><code>UT_NAMESIZE</code> を変更してシステム全体を作り直せば十分で、 それだけでうまくいくだろうとあなたは考えるかもしれません。 残念ながら多くのアプリケーションやユーティリティ (システムツールも含めて) は、 小さな数値を構造体やバッファなどに使っています (必ずしも "8" や "9" ではなく、 "15" や "20" などの変った値を使うものもあります)。 (固定長のレコードを期待するところで可変長レコードになるため、 ) 台無しになったログファイルを得ることになるということだけでなく、 Sun の NIS のクライアントの場合は問題が起きますし、他の UNIX システムとの関連においてこれら以外の問題も起きる可能性があります。</p></div><div class=paragraph><p>しかし、FreeBSD 3.0 以降では 16 文字となり、 多くのユーティリティのハードコードされた名前の長さの問題も解決されます。 実際にはシステムのあまりに多くの部分を修正するために、 3.0 になるまでは変更が行われませんでした。</p></div><div class=paragraph><p>それ以前のバージョンでは、これらの問題が起こった場合に、 問題を自分自身で発見し、解決できることに絶対的な自信がある場合は <span class=filename>/usr/include/utmp.h</span> を編集し、 <code>UT_NAMESIZE</code> の変更にしたがって、 長いユーザ名を使うことができます。 また、 <code>UT_NAMESIZE</code> の変更と一致するように <span class=filename>/usr/include/sys/param.h</span> の <code>MAXLOGNAME</code> 更新しなくてはなりません。 最後に、ソースからビルドする場合は <span class=filename>/usr/include</span> を毎回アップデートする必要があることを忘れないように! <span class=filename>/usr/src/..</span> 上のファイルを変更しておいて置き換えましょう。</p></div></div><div class=sect2><h3 id=_freebsd_上で_dos_のバイナリを動かすことはできますか>12.7. FreeBSD 上で DOS のバイナリを動かすことはできますか?<a class=anchor href=#_freebsd_上で_dos_のバイナリを動かすことはできますか></a></h3><div class=paragraph><p>はい、FreeBSD 3.0 からは、 統合と改良が重ねられた BSDI の doscmd DOS エミュレーションサブシステムを使ってできるようになりました。 今なお続けられているこの努力に興味を持って参加していただけるなら、 <a href=https://lists.FreeBSD.org/subscription/freebsd-emulation>FreeBSD-emulation メーリングリスト</a> へメールを送ってください。</p></div><div class=paragraph><p>FreeBSD 3.0 以前のシステムでは、 pcemu という巧妙なユーティリティが FreeBSD Ports Collection にあり、 8088 のエミュレーションと DOS のテキストモードアプリケーションを動かすに十分な BIOS サービスを行ないます。これは X ウィンドウシステムが必要です (XFree86 として提供されています)。</p></div></div><div class=sect2><h3 id=_どこで無料の_freebsd_のアカウントを取得できますか>12.8. どこで無料の FreeBSD のアカウントを取得できますか?<a class=anchor href=#_どこで無料の_freebsd_のアカウントを取得できますか></a></h3><div class=paragraph><p>FreeBSD はいずれのサーバーにもアクセスを開放していませんが、 Unix システムへの自由なアクセスを提供しているところがあります。 費用はまちまちで、限定されたサービスが利用できます。</p></div><div class=paragraph><p>M-Net としても知られる <a href=http://www.arbornet.org/>Arbornet, Inc</a> は 1983 年から Unix システムへのアクセスを提供しています。 System III が動作する Altos に始まり、1991 年には BSD/OS に移行しました。2000 年 6 月には、再び FreeBSD に 移行しています。M-Net には SSH または telnet 経由で アクセスすることができ、FreeBSD ソフトウェア一式が 利用できるようになっています。ただし、ネットワーク接続は 会員と、非営利組織として運営されているシステムに寄付をする 後援者に制限されています。また、M-Net は掲示板システムと 双方向チャットも提供しています。</p></div><div class=paragraph><p><a href=http://www.grex.org/>Grex</a> は、 掲示板システムと双方向チャットソフトウェアが同じであることも含め、 M-Net とよく似たサイトを提供しています。しかし、 マシンは Sun 4M で、SunOS が動作しています。</p></div></div><div class=sect2><h3 id=_sup_とは何で_どのようにして使うものなのでしょうか>12.9. sup とは何で、 どのようにして使うものなのでしょうか?<a class=anchor href=#_sup_とは何で_どのようにして使うものなのでしょうか></a></h3><div class=paragraph><p><a href=http://www.FreeBSD.org/cgi/ports.cgi?^sup>SUP</a> とは、ソフトウェアアップデートプロトコル (Software Update Protocol) で カーネギーメロン大学 (CMU) で開発ツリーの同期のために開発されました。 私たちの中心開発ツリーをリモートサイトで同期させるために使っていました。</p></div><div class=paragraph><p>SUP はバンド幅を浪費しますので、今は使っていません。 ソースコードのアップデートの現在のおすすめの方法は <a href=https://docs.freebsd.org/ja/books/handbook/mirrors#cvsup>FreeBSD ハンドブックの「CVSup」</a>にあります。</p></div></div><div class=sect2><h3 id=_freebsd_をクールに使うには>12.10. FreeBSD をクールに使うには?<a class=anchor href=#_freebsd_をクールに使うには></a></h3><div class=paragraph><p>いいえ。 私たちは 250 マイクログラムの LSD-25 をあらかじめ与えておいたボランティアに対する、 目隠し味覚テストを大量に行なっています。 35% のボランティアは FreeBSD はオレンジのような味がすると言っているのに対し、 Linux は紫煙のような味わいがあると言っている人もいます。 両方のグループとも温度の不一致については何も触れていません。 この調査で、非常に多くのボランティアがテストを行なった部屋から不思議そうに出てきて、 このようなおかしな結果を示したことに私たちは当惑させられました。 私たちは、ほとんどのボランティアは Apple にいて彼らの最新の「引っかいて匂いをかぐ」GUI を使っているのではないかと考えています。 私たちは奇妙な古い仕事をしているのでしょう!</p></div><div class=paragraph><p>真面目に言うと、FreeBSD や Linux は共に "HLT" (停止) 命令をシステムのアイドル (idle) 時に使い、 エネルギーの消費を押えていますので熱の発生も少なくなります。 また、APM (advanced power management) を設定してあるなら FreeBSD は CPU をローパワーモードにすることができます。</p></div></div><div class=sect2><h3 id=_誰かが私のメモリカードをひっかいているのですか>12.11. 誰かが私のメモリカードをひっかいているのですか??<a class=anchor href=#_誰かが私のメモリカードをひっかいているのですか></a></h3><div class=paragraph><p>その通り! BSD の文書には良く、デーモン (daemon) という言葉が出てきます。 ほとんどの人は知らないのですが、 デーモンとは、あなたのコンピュータを依り代とする、 純粋で非物質的な存在のことです。 メモリから聞こえるひっかくような音は、 さまざまあるシステム管理タスクの扱いをいかに最善なものにするか、 といったことを決めるときにデーモンたちが交わす、 かん高いささやき声なのです。</p></div><div class=paragraph><p>この雑音が聞こえたとき、DOS から “fdisk /mbr” というプログラムを実行すれば、 うまくデーモンを追い出すことができるでしょう。 でも、デーモンはそれに歯向かって <code>fdisk</code> の実行をやめさせようとするかも知れません。 もし、それを実行しているときにスピーカならビル ゲイツ (Bill Gates) の悪魔のささやきが聞こえてきたら、 すぐに立ち上がって逃げてください。決して振り返ってはいけません! BSD のデーモンたちが押え込んでいた双子のデーモン、DOS と Windows が解放され、 あなたの魂を永遠の破滅へ導こうとマシンを再び支配してしまうことでしょう。 それを知った今や、選べと言われたら、 むしろひっかき音に慣れる方を選ぶのではありませんか?</p></div></div><div class=sect2><h3 id=_mfc_とはどういう意味ですか>12.12. "MFC" とはどういう意味ですか<a class=anchor href=#_mfc_とはどういう意味ですか></a></h3><div class=paragraph><p>MFC とは、 「CURRENT との合流 (Merged From -CURRENT)」の頭文字をとったものです。 CVS ログで -CURRENT から -STABLE ブランチへの合流を示します。</p></div></div><div class=sect2><h3 id=_bsd_とはどういう意味ですか>12.13. "BSD" とはどういう意味ですか?<a class=anchor href=#_bsd_とはどういう意味ですか></a></h3><div class=paragraph><p>この言葉は、仲間うちだけに分かる隠語で何とかという意味です。 文字どおりに訳すことはできませんが、 BSD の訳は「F1 のレーシングチーム」か「ペンギンはおいしいスナック」、 あるいは「俺たちゃ Linux より洒落は利いてるぜ」とかそのへんだと言っておけばおっけーでしょう。 <code>:-)</code></p></div><div class=paragraph><p>冗談はさておき、BSD とは、Berkeley CSRG (コンピュータシステム評議会) が彼らの UNIX の配布形態の名前として当時選んだ "Berkeley Software Distribution" の略です。</p></div></div><div class=sect2><h3 id=_リポジトリコピー_repo_copy_とは一体何のことでしょう>12.14. リポジトリ・コピー (repo-copy) とは一体何のことでしょう?<a class=anchor href=#_リポジトリコピー_repo_copy_とは一体何のことでしょう></a></h3><div class=paragraph><p>repo-copy ("repository copy" の略) とは、 CVS リポジトリの中で直接ファイルをコピーすることを示す用語です。</p></div><div class=paragraph><p>repo-copy を行なわない場合を考えます。 リポジトリの中の異なる場所にファイルをコピーしたり、 移動したりする必要性が生じると、コミッターは ファイルを新しい場所に置くために <code>cvs add</code> を、 そして古いファイルが削除される場合は、古いファイルに対して <code>cvs rm</code> を実行するでしょう。</p></div><div class=paragraph><p>この方法の欠点は、ファイルの変更履歴 (たとえば CVS ログのエントリ) が新しい場所にコピーされないことです。 FreeBSD プロジェクトではこの変更履歴をとても有用なものだと考えているため、 前述の方法の代わりにリポジトリコピーが良く用いられます。 この操作は <code>cvs</code> プログラムを利用するのではなく、 リポジトリの管理担当者がリポジトリの中でファイルを直接コピーすることによって行なわれます。</p></div></div><div class=sect2><h3 id=_なんでバイク小屋_bikeshed_の色にまで気を使わなければいけないんですか>12.15. なんでバイク小屋 (bikeshed) の色にまで気を使わなければいけないんですか?<a class=anchor href=#_なんでバイク小屋_bikeshed_の色にまで気を使わなければいけないんですか></a></h3><div class=paragraph><p>一言で言ってしまえば、そうすべきではありません。 もう少し詳しく説明しましょう。 たとえば、あなたがバイク小屋を建てる技術を持っていたとします。 しかしそれは、塗ろうとしている色が気に入らないからと言って、 他人がバイク小屋を建てようとしているのを止めて良い理由にはなりませんよね。 これは、自分の行動について十分な理解を持っているなら、 あなたは細かな機能すべてにわたって議論する必要はないことを示す比喩です。 ある変更によって産み出されるノイズの総量は、 その変更の複雑さに反比例するのだと言っている人達もいます。</p></div><div class=paragraph><p>さらに詳しく、完全な回答を紹介しましょう。 Poul-Henning Kamp は、 「<a href="https://man.freebsd.org/cgi/man.cgi?query=sleep&amp;sektion=1&amp;format=html">sleep(1)</a> は分数の秒数を引数として取るべきか」という 非常に長い議論の後で、 "<a href="http://www.FreeBSD.org/cgi/getmsg.cgi?fetch=506636+517178+/usr/local/www/db/text/1999/freebsd-hackers/19991003.freebsd-hackers">A bike shed (any colour will do) on greener grass…​</a>" というタイトルの長文を投稿しました。 関係のある部分だけを以下に掲載します。</p></div><div class=paragraph><p>1999 年 10 月 2 日 freebsd-hackers にて Poul-Henning Kamp
"このバイク小屋、どうだろう?" 誰かがたずねました。</p></div><div class=paragraph><p>長い…​というか、むしろ古い話になりますが、 中身はわりと簡単な話です。パーキンソン (C. Northcote Parkinson) は 1960 年代初頭に "パーキンソンの法則" と呼ばれる本を書きました。 この中にはさまざまな経営の力学に関する洞察が含まれています。</p></div><div class=paragraph><p>[ この本に関する解説があったが省略 ]</p></div><div class=paragraph><p>バイク小屋に関連する例として、 もう一つの重要な構成要素となっているのは原子力発電所です。 この本の年代がわかりますね。</p></div><div class=paragraph><p>パーキンソンは、あなたが重役会に出席して 数百万から数10億ドル規模の原子力発電所の建設の承認を得る ことはできるでしょうが、あなたが建てたいのがバイク小屋ならば、 終わりなき議論に巻き込まれるだろうと言っています。</p></div><div class=paragraph><p>パーキンソンはこのように説明しています。 これは原発が余りに巨大で高価で複雑なので誰もこれを一手に握ることができず、 それを試みるくらいならむしろ、手が出せなくなる前に 他の誰かがすべてを詳細にチェックすることを 引き受けることに頼るのです。 リチャード・ファインマン (Richard P. Feynmann) は、 ロスアラモスでこの手の重要な経験を何度も見てきたと本に書いています。</p></div><div class=paragraph><p>一方でバイク小屋の場合は、誰でも週末にこれを作り上げることができ、 しかも TV の試合を見る時間があまるほどです。 なので、どんなに準備が整えてあって、どんなに計画が順当であったとしても、 わたしは仕事をやっているよ、 わたしは注意を払っているよ、そして わたしは<em>ここ</em>にいるよ、 ということを示そうとする人が必ず現れます。</p></div><div class=paragraph><p>デンマークではこれを「指紋をつける」と呼んでいます。 これは個人的なプライドや名声を求め、 ある場所を指し示して「ここ! ここは<em>俺</em>が やったんだぜ～」というようなものです。 これは政治家に見られる強い特徴ですが、 その他のほとんどの人もこういう風に振舞う可能性はあるのです。 生乾きのセメントにつけられた足跡のことを考えればお分かりでしょう。</p></div></div><div class=sect2><h3 id=_ひとつの電球を取り替えるのに何人の_freebsd_ハッカーが必要>12.16. ひとつの電球を取り替えるのに、何人の FreeBSD ハッカーが必要?<a class=anchor href=#_ひとつの電球を取り替えるのに何人の_freebsd_ハッカーが必要></a></h3><div class=paragraph><p>1,172人です。</p></div><div class=ulist><ul><li><p>電球が消えていると -CURRENT で文句を言うのに 23 人。</p></li><li><p>設定上の問題で -questions で話をすべきことについて騒ぐのに 4 人。</p></li><li><p>それを send-pr (訳注: 障害報告) するのに 3 人 (そのうちのひとつは間違って doc カテゴリに送りつけられたうえに、 内容が「暗くなった」というだけのもの)。</p></li><li><p>buildworld を失敗させ、5 分後には元に戻されるような電球を テストもせずにコミットするのに 1 人。</p></li><li><p>send-pr した人に、パッチが含まれていないと「いちゃもん」を付けるのに 8 人。</p></li><li><p>buildworld が失敗すると文句を言うのに 5 人。</p></li><li><p>自分のところではちゃんと動く、 cvsup したタイミングが悪かったんだろうと答えるのに 31 人。</p></li><li><p>新しい電球のためのパッチを -hackers に投げるのに 1 人。</p></li><li><p>自分は 3 年も前にパッチを作ったが、それを -CURRENT に投げたときには無視されただけだった、 自分は send-pr のシステムには嫌な経験があると (おまけに、 提案された新しい電球には柔軟性が無いとまで) 文句を言うのに 1 人。</p></li><li><p>電球が基本システムに組み込まれていない、 committer はコミュニティの意見を聞くこと無しにこんなことをする権利は無いと叫び、 「こんなときに -core は何をやってるんだ!?」とわめきちらすのに 37 人。</p></li><li><p>自転車置き場の色に文句を言うのに 200 人。</p></li><li><p>パッチが <a href="https://man.freebsd.org/cgi/man.cgi?query=style&amp;sektion=9&amp;format=html">style(9)</a> 違反だと指摘するのに 3 人。</p></li><li><p>提案された新しい電球は GPL の下にあると文句を言うのに 70 人。</p></li><li><p>GPL と BSD ライセンスと MIT ライセンスと NPL と、 某 FSF 創立者らの個人的な健康法の優位性についての論争を戦わすのに 586 人。</p></li><li><p>スレッドのあちこちの枝を -chat や -advocacy に移動するのに 7 人。</p></li><li><p>提案された電球を、古いのよりずっと薄暗いのにコミットしてしまうのに 1 人。</p></li><li><p>FreeBSD に薄暗い電球を付けるくらいなら真っ暗のほうがましだという、 コミットメッセージへの凄まじい非難の嵐によって、 それを元に戻すのに 2 人。</p></li><li><p>薄暗い電球が帳消しにされたことに対してどなり声で口論し、 -core の声明を要求するのに 46 人。</p></li><li><p>もし FreeBSD をたまごっちに移植することになったときに都合がいいように、 もっと小さな電球を要求するのに 11 人。</p></li><li><p>-hackers と -chat の S/N比に文句を言い、 抗議のため講読を取りやめるのに 73 人。</p></li><li><p>「unsubscribe」「どうやったら講読をやめられるんですか?」 「このメーリングリストからわたしを外してください」といった メッセージを、例のフッタをくっつけて投稿するのに 13 人。</p></li><li><p>みんなが激論を戦わせるのに忙がしくて気付かない間に、 作業中の電球をコミットするのに 1 人。</p></li><li><p>新しい電球は TenDRA を使ってコンパイルされた場合に 0.364% も明るくなる (ただし電球を立方体にしなければならない)、 だから FreeBSD は EGCS から TenDRA に変えるべきだと指摘するのに 31 人。</p></li><li><p>新しい電球は美しさに欠けていると文句を言うのに 1 人。</p></li><li><p>「MFC って何ですか?」と聞くのに 9 人 (send-pr した人も含む)。</p></li><li><p>電球が取り替えられてから 2 週間も消えっぱなしだと文句を言うのに 57 人。</p></li></ul></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=title>Nik Clayton &lt;<a href=mailto:nik@FreeBSD.org>nik@FreeBSD.org</a>> による追記:</div><div class=paragraph><p>これには爆笑しました。</p></div><div class=paragraph><p>それからわたしは考えました。 「ちょっと待てよ? このリストのどこかに、 『これを文書にまとめるのに 1人』というのがあってもいいんじゃないか?」</p></div><div class=paragraph><p>それからわたしは悟りを開いたのです <code>:-)</code></p></div></td></tr></tbody></table></div><div class=paragraph><p><em>この項目の著作権は Copyright (c) 1999 Dag-Erling Smørgrav &lt;<a href=mailto:des@FreeBSD.org>des@FreeBSD.org</a>> にあります。 無断で使用しないでください。</em></p></div></div></div></div><div class=sect1><h2 id=_まじめな_freebsd_ハッカーだけの話題>13. まじめな FreeBSD ハッカーだけの話題<a class=anchor href=#_まじめな_freebsd_ハッカーだけの話題></a></h2><div class=sectionbody><div class=sect2><h3 id=_snap_とか_release_とかは何>13.1. SNAP とか RELEASE とかは何?<a class=anchor href=#_snap_とか_release_とかは何></a></h3><div class=paragraph><p>現在、FreeBSD の <a href=http://www.FreeBSD.org/cgi/cvsweb.cgi>CVS リポジトリ</a> には、三つのアクティブ/準アクティブなブランチがあります (アクティブな開発ブランチは三つしか存在しないため、 おそらく RELENG_2 ブランチの変更は年に 2 回だけになるでしょう)。</p></div><div class=ulist><ul><li><p><code>RELENG_2_2</code> 通称 <em>2.2-STABLE</em></p></li><li><p><code>RELENG_3</code> 通称 <em>3.X-STABLE</em></p></li><li><p><code>RELENG_4</code> 通称 <em>4-STABLE</em></p></li><li><p>HEAD 通称 <code>-CURRENT</code> あるいは <em>5.0-CURRENT</em></p></li></ul></div><div class=paragraph><p>HEAD は他の二つと違って、 実際のブランチタグではなく、 <em>「current、 分岐していない開発本流」</em>のための単なるシンボリックな定数です。 私たちはこれを <code>-CURRENT</code> と呼んでいます。</p></div><div class=paragraph><p>現在、 "-CURRENT" は 5.0 の開発本流であり、 <code>4.0-STABLE</code> ブランチ、 つまり <code>RELENG_4</code> は 2000 年 3 月に "-CURRENT" から分岐しています。</p></div><div class=paragraph><p><code>2.2-STABLE</code> ブランチ、 <code>RELENG_2_2</code> は 1996 年 11 月に "-CURRENT" から分岐しました。 これは保守が完全に終了しています。</p></div></div><div class=sect2><h3 id=_自分用のカスタムリリースを構築するには>13.2. 自分用のカスタムリリースを構築するには?<a class=anchor href=#_自分用のカスタムリリースを構築するには></a></h3><div class=paragraph><p>リリースを構築するには三つのことが必要です。まず、 <a href="https://man.freebsd.org/cgi/man.cgi?query=vn&amp;sektion=4&amp;format=html">vn(4)</a> ドライバが組み込まれたカーネルを実行させている必要があります。 以下をカーネルコンフィグレーションファイルに追加し、 カーネルを作り直してください。</p></div><div class="literalblock programlisting"><div class=content><pre>pseudo-device vn         #Vnode driver (turns a file into a device)</pre></div></div><div class=paragraph><p>次に、CVS リポジトリ全体を手元においておく必要があります。 これを入手するには <a href=https://docs.freebsd.org/ja/books/handbook/mirrors#cvsup>CVSUP</a> が使用できますが、supfile で release の名称を cvs にして 他のタグや date フィールドを削除する必要があります。</p></div><div class="literalblock programlisting"><div class=content><pre>*default prefix=/home/ncvs
*default base=/a
*default host=cvsup.FreeBSD.org
*default release=cvs
*default delete compress use-rel-suffix

## Main Source Tree
src-all
src-eBones
src-secure

# Other stuff
ports-all
www
doc-all</pre></div></div><div class=paragraph><p>そして <code>cvsup -g supfile</code> を実行して自分のマシンに CVS リポジトリ全体をコピーします…​。</p></div><div class=paragraph><p>最後に、ビルド用にかなりの空き領域を用意する必要があります。 そのディレクトリを <span class=filename>/some/big/filesystem</span> として、 上の例で CVS リポジトリを <span class=filename>/home/ncvs</span> に置いたものとすると、 以下のようにしてリリースを構築します。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># setenv CVSROOT /home/ncvs</span>
 <span class=c># or export CVSROOT=/home/ncvs</span>
<span class=c># cd /usr/src</span>
<span class=c># make buildworld</span>
<span class=c># cd /usr/src/release</span>
<span class=c># make release BUILDNAME=3.0-MY-SNAP CHROOTDIR=/some/big/filesystem/release</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>ただし、すでに <span class=filename>/usr/obj</span> 以下に構築物が存在しているなら、buildworld の必要は<em>ありません</em>。</p></div></td></tr></tbody></table></div><div class=paragraph><p>処理が終了すると、 リリース全体が <span class=filename>/some/big/filesystem/release</span> に構築され、完全な FTP インストール用の配布物が <span class=filename>/some/big/filesystem/release/R/ftp</span> に作成されます。 -current 以外の開発ブランチの SNAP を自分で構築したい場合は、 <code>RELEASETAG=SOMETAG</code> を上の <code>make release</code> のコマンドラインに追加します。 たとえば、<code>RELEASETAG=RELENG_2_2</code> とすると最新の 2.2-STABLE snapshot が構築されます。</p></div></div><div class=sect2><h3 id=_カスタムのインストールディスクを作るにはどうすればいいのですか>13.3. カスタムのインストールディスクを作るにはどうすればいいのですか?<a class=anchor href=#_カスタムのインストールディスクを作るにはどうすればいいのですか></a></h3><div class=paragraph><p><span class=filename>/usr/src/release/Makefile</span> のいろいろなターゲットとしてインストールディスク、 ソース、バイナリアーカイブを作る完全な処理を自動的に行なうようになっています。 <span class=filename>Makefile</span> に十分な情報があります。 しかし、実行には "make world" が必要で、 多くの時間とディスクの容量が必要です。</p></div></div><div class=sect2><h3 id=_make_world_を行なうと既存のバイナリを上書きしてしまうのですが>13.4. make world を行なうと既存のバイナリを上書きしてしまうのですが。<a class=anchor href=#_make_world_を行なうと既存のバイナリを上書きしてしまうのですが></a></h3><div class=paragraph><p>ええ、それが一般的な考え方です。名前が示しているように "make world" はすべてのシステムのバイナリを最初から作り直しますので、結果として、 クリーンで一貫性のある環境を得ることができます (これがそれだけ長い時間がかかる理由です)。</p></div><div class=paragraph><p>環境変数 <code>DESTDIR</code> を <code>make world</code> や <code>make install</code> を実行する時に定義しておくと、新しく作られたバイナリは <code>${DESTDIR}</code>を <code>root</code> とみなしたディレクトリツリーにインストールされます。 あるでたらめな共有ライブラリの変更やプログラムの再構築によって <code>make world</code> は失敗することもあります。</p></div></div><div class=sect2><h3 id=_システム起動時に_bus_speed_defaulted_とメッセージが出ます>13.5. システム起動時に (bus speed defaulted) とメッセージが出ます。<a class=anchor href=#_システム起動時に_bus_speed_defaulted_とメッセージが出ます></a></h3><div class=paragraph><p>Adaptec の 1542 SCSI ホストアダプタは、 ユーザがソフトウェア的にバスアクセス速度の設定を行なうことができます。 以前のバージョンの 1542 ドライバは、 使用可能な最大の速度を求めてアダプタをその設定にしようとしました。 これは特定のユーザのシステムでは問題がある事がわかり、 現在ではカーネルコンフィグオプションに "TUNE_1542" が加えられています。 これを使用すると、これが働くシステムではディスクが速くなりますが、 データの衝突が起きて速くはならないシステムもあるでしょう</p></div></div><div class=sect2><h3 id=_インターネットアクセスに制限があっても_current_を追いかけられますか>13.6. インターネットアクセスに制限があっても current を追いかけられますか?<a class=anchor href=#_インターネットアクセスに制限があっても_current_を追いかけられますか></a></h3><div class=paragraph><p>はい、 <a href=https://docs.freebsd.org/ja/books/handbook/>CTM システム</a>を使って、 ソースツリー全体のダウンロードを<em>行なわず</em>に追いかけることができます。</p></div></div><div class=sect2><h3 id=_どのようにして配布ファイルを_240kb_に分割しているのですか>13.7. どのようにして配布ファイルを 240KB に分割しているのですか?<a class=anchor href=#_どのようにして配布ファイルを_240kb_に分割しているのですか></a></h3><div class=paragraph><p>比較的新しい BSD ベースのシステムでは、 <code>split</code> に任意のバイト境界で分割する “-b” オプションがあります。</p></div><div class=paragraph><p>以下は <span class=filename>/usr/src/Makefile</span> からの例です。</p></div><div class="literalblock programlisting"><div class=content><pre>bin-tarball:
            (cd ${DISTDIR}; \
            tar cf - . \
            gzip --no-name -9 -c | \
            split -b 240640 - \
            ${RELEASEDIR}/tarballs/bindist/bin_tgz.)</pre></div></div></div><div class=sect2><h3 id=_私はカーネルに拡張を行ないました_誰に送ればいいですか>13.8. 私はカーネルに拡張を行ないました。 誰に送ればいいですか?<a class=anchor href=#_私はカーネルに拡張を行ないました_誰に送ればいいですか></a></h3><div class=paragraph><p><a href=https://docs.freebsd.org/ja/books/handbook/>FreeBSD ハンドブックの「FreeBSD への貢献」</a>を参照してください。</p></div><div class=paragraph><p>あなたのアイディアに感謝します!</p></div></div><div class=sect2><h3 id=_pnp_isa_カードの検出と初期化はどのように行なうのですか>13.9. PnP ISA カードの検出と初期化はどのように行なうのですか?<a class=anchor href=#_pnp_isa_カードの検出と初期化はどのように行なうのですか></a></h3><div class=paragraph><p><a href=mailto:uhclem@nemesis.lonestar.org>Frank Durda IV 氏</a> より:</p></div><div class=paragraph><p>要点は、ホストが認識されていないボードを探す時に、すべての PnP ボードが応答することのできる少数の I/O ポートがあるということです。 それにより、PnP プローブルーチンが開始したとき、PnP ボードが存在するなら、すべての PnP ボードは自分のモデル番号を返します。 そのポートを I/O read するとプローブルーチンは問いに対するワイアード-OR された "yes" を得ます。この場合は 少なくとも 1 ビットが ON になります。 そして、プローブルーチンはモデル ID (Microsoft/Intel によって割り当てられています)が X より小さいボードを "オフライン" にすることができます。 この操作を行ない、問い合わせに応答しているボードがまだ 残っているかどうかを調べます。 もし “0” が返ってくるなら X より大きな ID を持つボードはないことになります。 今度は "X" よりも小さな値を持つボードについて問い合わせます。 もしあるのであれば、 プローブルーチンはモデル番号が X より小さいことを知ります。 今度は、X-(limit/4) より大きな値を持つボードをオフラインにして問い合わせを繰り返します。 この ID の範囲による準バイナリサーチを十分繰り返すことにより、 プローブルーチンはマシンに存在するすべての PnP ボードの値を最終的に得ることができます。その繰り返しの回数は 2^64 よりはるかに少ない回数です。</p></div><div class=paragraph><p>ID は二つの 32-bit (つまり 64bit) フィールド + 8 bit チェックサムからなります。最初の 32 bits はベンダの識別子です。 これは公表されてはいませんが、 同一のベンダから供給されている異なるタイプのボードでは異なる 32-bit ベンダ ID を持つことができるように考えられます。 製造元を特定するだけのために 32-bit はいくらか過剰です。</p></div><div class=paragraph><p>下位の 32-bit はシリアル番号、 イーサネットアドレスなどのボードを特定するものです。 ベンダは上位 32 bits が異なっていないのであれば、 下位 32-bit が同一である 2枚目のボードを製造することはありません。 したがって、同じタイプの複数のボードをマシンにいれることができ、 この場合でも 64-bit 全体ではユニークです。</p></div><div class=paragraph><p>32-bit のフィールドはすべてを 0 にすることはできません。 これは初期化のバイナリサーチの間ワイアード-OR によって 0 ではない ビットを参照するからです。</p></div><div class=paragraph><p>システムがすべてのボードの与えられた ID を認識すると、 それぞれのボードに対応した処理を一つずつ (同一の I/O ポートを通して) 行ないます。 そして、利用できる割り込みの選択などのボードが必要とするリソースを検出します。 すべてのボードについてこの情報を集めます。</p></div><div class=paragraph><p>この情報はハードディスク上の ECU ファイルなどの情報とまとめられ、 マザーボードの BIOS にも結合されます。 マザーボード上のハードウェアへの ECU と BIOS PnP のサポートは通常は統合されていますが、 周辺機器については真の PnPであるとはいえません。 しかし、BIOS の情報に ECU の情報を加えて調査することで、 プローブルーチンは PnP デバイスが再配置できなくなることを避けることができます。</p></div><div class=paragraph><p>それから、再度 PnP デバイスにアクセスし、I/O、DMA、IRQ、 メモリマップアドレスの設定をします。 デバイスはこのアドレスに見えるようになり、 次に再起動するまでこの位置を占めます。しかし、 あなたの望む時に移動させることが不可能である、 といっているわけではありません。</p></div><div class=paragraph><p>以上の話では大きく単純化をしてありますが、 基本的な考え方は得られたでしょう。</p></div><div class=paragraph><p>マイクロソフトは、ボードのロジックが対立する I/O サイクルではデコードしていない (訳注: おそらく read 時しかデコードされていず write 時はポートが空いているという意味でしょう)、 プライマリプリンタのステータスポートのいくつかを PnP のために占有しました。 私は初期の PnP の提案レビュー時に IBM 純正のプリンタボードでステータスポートの write のデコードがされているということに気がつきましたが、 MS は "tough (頑固、不運、無法な)" と言っています。 そしてプリンタのステータスポートへアドレスの設定のために write を行なっています。また、 そのアドレス + <code>0x800</code> と read のための 3番目の I/O ポートが <code>0x200</code> から <code>0x3ff</code> の間のどこかに置かれるでしょう。</p></div></div><div class=sect2><h3 id=_freebsd_は他のアーキテクチャをサポートしないんですか>13.10. FreeBSD は、他のアーキテクチャをサポートしないんですか?<a class=anchor href=#_freebsd_は他のアーキテクチャをサポートしないんですか></a></h3><div class=paragraph><p>いくつかのグループの人々が、FreeBSD の他のアーキテクチャへの移植に関心を示しており、 FreeBSD/AXP (ALPHA) はこれらの成果としてはとても成功したものの一つです。 FreeBSD/AXP は現在 <a href=ftp://ftp.FreeBSD.org/pub/FreeBSD/alpha/>ftp://ftp.FreeBSD.org/pub/FreeBSD/alpha</a> から入手できます。 ALPHA への移植版が現在動く機種は増えつつあり、 その中には AlphaStation、AXPpci、PC164、Miata そして Multia といったモデルが含まれています。 現状についての情報を得るには <a href=mailto:freebsd-alpha@FreeBSD.org>freebsd-alpha@FreeBSD.org</a><a href=#mailing>メーリングリスト</a>に参加してください。</p></div><div class=paragraph><p>その他に FreeBSD の SPARC アーキテクチャへの移植があります。 プロジェクトへの参加に興味がある方は <a href=mailto:freebsd-sparc@FreeBSD.org>freebsd-sparc@FreeBSD.org</a><a href=#mailing>メーリングリスト</a> に参加してください。 進行中のプラットホームのリストにもっとも最近追加されたのが IA-64 と PowerPCです。詳細は <a href=mailto:freebsd-ia64@FreeBSD.org>freebsd-ia64@FreeBSD.org</a> および/あるいは <a href=mailto:freebsd-ppc@FreeBSD.org>freebsd-ppc@FreeBSD.org</a><a href=#mailing>メーリングリスト</a>に参加してください。 新しいアーキテクチャに関する一般的な議論については 新しいアーキテクチャに関する一般的な議論については <a href=mailto:freebsd-platforms@FreeBSD.org>freebsd-platforms@FreeBSD.org</a><a href=#mailing>メーリングリスト</a> へ参加してください。</p></div></div><div class=sect2><h3 id=_デバイスドライバを開発したのでメジャー番号が欲しいのですが>13.11. デバイスドライバを開発したので、メジャー番号が欲しいのですが。<a class=anchor href=#_デバイスドライバを開発したのでメジャー番号が欲しいのですが></a></h3><div class=paragraph><p>これは、開発したドライバを公開するかどうかに依存します。 公開するのであれば、ドライバのソースコード、 <span class=filename>files.i386</span> の変更、 コンフィグファイルのサンプル、 デバイスが使うスペシャルファイルを作成する <a href="https://man.freebsd.org/cgi/man.cgi?query=MAKEDEV&amp;sektion=8&amp;format=html">MAKEDEV(8)</a> のコードを私たちに送ってください。 公開するつもりがない場合、ライセンスの問題により公開できない場合は、 キャラクタメジャー番号 32 および、 ブロックメジャー番号 8 がこのような目的のために予約されています。 これらの番号を使用してください。 どちらの場合であれ、ドライバに関する情報を <a href=https://lists.FreeBSD.org/subscription/freebsd-hackers>FreeBSD technical discussions メーリングリスト</a> に流して頂けると助かります。</p></div></div><div class=sect2><h3 id=_代替のディレクトリ配置ポリシー>13.12. 代替のディレクトリ配置ポリシー<a class=anchor href=#_代替のディレクトリ配置ポリシー></a></h3><div class=paragraph><p>現在使われているディレクトリの配置ポリシーは、 私が 1983 年に書いたものから全く変更されていません。 私は当初の配置ポリシーを、オリジナルの fast filesystem のために書き、 まったく改定していません。 このポリシーはシリンダグループを使い尽くすのを防ぐにはうまくいきましたが、 お気づきの方もいる通り find の動作には不適切です。 ほとんどのファイルシステムの内容は、 深さ優先検索 (ftw とも呼ばれます) によって作られたアーカイブから、 抽出 (restore) して作成されます。この際、 ディレクトリは、シリンダグループにまたがって配置され、 以降の深さ優先検索を行うには、 考え得る限り最悪の状態になります。 もし作成するディレクトリの総数がわかっていれば、 解決方法はあります。(総数/シリンダグループ数) 個のディレクトリを、 シリンダグループごとにまとめて作成すれば良いのです。 もちろん最適なディレクトリ配置になるように、 総数を予測する方法を考えなければなりません。 しかし仮にシリンダグループあたりのディレクトリ数を 10 くらいの小さな数に固定してしまったとしても、 大幅な改善が望めるでしょう。 このポリシーを用いるべきリストア作業を、通常の作業 (おそらく既存のポリシーを使用したほうが良いでしょう) を区別するには、 10 秒間の間に作成されたディレクトリを最大 10 個までまとめて単一のシリンダグループに書き込むという手順が使えるでしょう。 とにかく私の結論は、そろそろ実験を始めて見る時期だろうということです。</p></div></div><div class=sect2><h3 id=_カーネルパニックを最大限に利用する>13.13. カーネルパニックを最大限に利用する<a class=anchor href=#_カーネルパニックを最大限に利用する></a></h3><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>この節は、freebsd-current <a href=#mailing>メーリングリスト</a>に Bill Paul &lt;<a href=mailto:wpaul@FreeBSD.org>wpaul@FreeBSD.org</a>> 氏が投稿したメールを、 Dag-Erling Smørgrav &lt;<a href=mailto:des@FreeBSD.org>des@FreeBSD.org</a>> 氏が校正し、[] 内のコメントを追加して引用したものです。</p></div></td></tr></tbody></table></div><div class="literalblock programlisting"><div class=content><pre>From: Bill Paul &lt;wpaul@skynet.ctr.columbia.edu&gt;
Subject: Re: the fs fun never stops
To: ben@rosengart.com
Date: Sun, 20 Sep 1998 15:22:50 -0400 (EDT)
Cc: current@FreeBSD.ORG</pre></div></div><div class=paragraph><p><em>[&lt;<a href=mailto:ben@rosengart.com>ben@rosengart.com</a>> が以下のパニックメッセージを投稿しました。]</em></p></div><div class="literalblock programlisting"><div class=content><pre>&gt; Fatal trap 12: page fault while in kernel mode
&gt; fault virtual address   = 0x40
&gt; fault code              = supervisor read, page not present
&gt; instruction pointer     = 0x8:0xf014a7e5
                              ^^^^^^^^^^
&gt; stack pointer           = 0x10:0xf4ed6f24
&gt; frame pointer           = 0x10:0xf4ed6f28
&gt; code segment            = base 0x0, limit 0xfffff, type 0x1b
&gt;                         = DPL 0, pres 1, def32 1, gran 1
&gt; processor eflags        = interrupt enabled, resume, IOPL = 0
&gt; current process         = 80 (mount)
&gt; interrupt mask          =
&gt; trap number             = 12
&gt; panic: page fault</pre></div></div><div class=paragraph><p>このようなメッセージが表示された場合、問題が起きる状況を確認して、 情報を送るだけでは十分ではありません。 下線をつけた命令ポインタ値は重要な値ですが、 残念ながらこの値は構成に依存します。つまり、 この値は使っているカーネルのイメージに依存するのです。 もしスナップショットなどの GENERIC カーネルを使っているのであれば、 他の人間が問題のある関数について追試をすることができますが、 カスタマイズされたカーネルの場合は、 使っている本人にしか問題の起こった場所は特定できないのです。</p></div><div class=paragraph><p>何をすれば良いのでしょう?</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>命令ポインタ値をメモします。 <code>0x8:</code> という部分は今回必要ありません。 必要なのは <code>0xf0xxxxxx</code> という部分です。</p></li><li><p>システムが再起動したら、以下の操作を行います。</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% nm <span class=nt>-n</span> /kernel.that.caused.the.panic | <span class=nb>grep </span>f0xxxxxx</code></pre></div></div><div class=paragraph><p>ここで、<code>f0xxxxxx</code> は命令ポインタ値です。 カーネルシンボルのテーブルは関数のエントリポイントを含み、 命令ポインタ値は、関数内部のある点であり最初の点ではないため、 この操作を行っても完全に一致するものが表示されない場合もあります。 この場合は、 最後の桁を省いてもういちどやってみてください。 このようになります。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% nm <span class=nt>-n</span> /kernel.that.caused.the.panic | <span class=nb>grep </span>f0xxxxx</code></pre></div></div><div class=paragraph><p>これでも一致しない場合は、 桁を減らしながら何らかの出力があるまで繰り返してください。 何か出力されたら、 それがカーネルパニックを引き起こした可能性のある関数のリストです。 これは、問題点を見付ける正確な方法ではありませんが、何もないよりましです。</p></div></li></ol></div></div></div><div class=paragraph><p>このようなパニックメッセージを投稿している人はよく見掛けますが、 このように、命令ポインタ値を、 カーネルシンボルテーブルの中の関数とつき合わせて調べている人はまれです。</p></div><div class=paragraph><p>パニックの原因を突き止める最良の方法は、クラッシュダンプをとり、 <a href="https://man.freebsd.org/cgi/man.cgi?query=gdb&amp;sektion=1&amp;format=html">gdb(1)</a> でスタックトレースを行うことです。</p></div><div class=paragraph><p>どっちにしろ、私は普通以下のようにします。</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>カーネルコンフィグファイルを作ります。 カーネルデバッガが必要そうであれば <code>options 'DDB'</code> を加えても良いです (私は永久ループが起こっていそうな場合に、 ブレークポイントを設定するのに使っています)。</p></li><li><p><code>config -g KERNELCONFIG</code> としてビルドディレクトリを設定します。</p></li><li><p><code>cd /sys/compile/KERNELCONFIG; make</code> を実行します。</p></li><li><p>カーネルのコンパイルが終了するのを待ちます。</p></li><li><p><code>make install</code> を実行します。</p></li><li><p>再起動します。</p></li></ol></div></div></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=make&amp;sektion=1&amp;format=html">make(1)</a> プロセスは２つのカーネル、 <span class=filename>kernel</span> と <span class=filename>kernel.debug</span> をビルドします。 <span class=filename>kernel</span> は <span class=filename>/kernel</span> としてインストールされ、 <span class=filename>kernel.debug</span> は <a href="https://man.freebsd.org/cgi/man.cgi?query=gdb&amp;sektion=1&amp;format=html">gdb(1)</a> のデバッグ用シンボル情報を取り出すために利用されます。</p></div><div class=paragraph><p>確実にクラッシュダンプをとるには、<span class=filename>/etc/rc.conf</span> を編集して <code>dumpdev</code> を使用しているスワップパーティションに指定する必要があります。 こうすると <a href="https://man.freebsd.org/cgi/man.cgi?query=rc&amp;sektion=8&amp;format=html">rc(8)</a> スクリプトから <a href="https://man.freebsd.org/cgi/man.cgi?query=dumpon&amp;sektion=8&amp;format=html">dumpon(8)</a> コマンドが実行され、 クラッシュダンプ機能が有効になります。 手動で <a href="https://man.freebsd.org/cgi/man.cgi?query=dumpon&amp;sektion=8&amp;format=html">dumpon(8)</a> コマンドを実行してもかまいません。 パニックの後、クラッシュダンプは <a href="https://man.freebsd.org/cgi/man.cgi?query=savecore&amp;sektion=8&amp;format=html">savecore(8)</a> コマンドを使用して取り出すこと ができます。 <code>dumpdev</code> が <span class=filename>/etc/rc.conf</span> で設定されていれば、 <a href="https://man.freebsd.org/cgi/man.cgi?query=rc&amp;sektion=8&amp;format=html">rc(8)</a> スクリプトから <a href="https://man.freebsd.org/cgi/man.cgi?query=savecore&amp;sektion=8&amp;format=html">savecore(8)</a> が自動的に実行され、クラッシュダンプを <span class=filename>/var/crash</span> に保存します。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>FreeBSD のクラッシュダンプのサイズは、 ふつう物理メモリサイズと同じです。 つまり 64MB のメモリを積んでいれば、 64MB のクラッシュダンプが生成されることになります。 <span class=filename>/var/crash</span> に十分な空き容量があることを確認してください。手動で <a href="https://man.freebsd.org/cgi/man.cgi?query=savecore&amp;sektion=8&amp;format=html">savecore(8)</a> を実行すれば、 もっと空き容量のあるディレクトリにクラッシュダンプを保存できます。 <code>options MAXMEM=(foo)</code> という行をカーネルコンフィグファイルに追加することで、 カーネルのメモリ使用量を制限できます。 たとえば 128MB のメモリがある場合も、 カーネルのメモリ使用量を 16MB に制限し、クラッシュダンプのサイズも 128MB ではなく 16MB にすることができます。</p></div></td></tr></tbody></table></div><div class=paragraph><p>クラッシュダンプを取り出せたら、 以下のように <a href="https://man.freebsd.org/cgi/man.cgi?query=gdb&amp;sektion=1&amp;format=html">gdb(1)</a> を使ってスタックトレースをとります。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% gdb <span class=nt>-k</span> /sys/compile/KERNELCONFIG/kernel.debug /var/crash/vmcore.0
<span class=o>(</span>gdb<span class=o>)</span> where</code></pre></div></div><div class=paragraph><p>必要な情報が 1 画面に収まらないことも多いので、できれば <a href="https://man.freebsd.org/cgi/man.cgi?query=script&amp;sektion=1&amp;format=html">script(1)</a> を使って出力を記録します。 strip していないカーネルイメージを使うことで、 すべてのデバッグシンボルが参照でき、 パニックの発生したカーネルのソースコードの行が表示されているはずです。 通常、正確なクラッシュへの過程を追跡するには、 出力を最後の行から逆方向に読まなければなりません。 また <a href="https://man.freebsd.org/cgi/man.cgi?query=gdb&amp;sektion=1&amp;format=html">gdb(1)</a> を使って、 変数や構造体の内容を表示させ、 クラッシュした時のシステムの状態を調べられます。</p></div><div class=paragraph><p>もしあなたがデバッグ狂で、同時に別のコンピュータを利用できる環境にあれば、 <a href="https://man.freebsd.org/cgi/man.cgi?query=gdb&amp;sektion=1&amp;format=html">gdb(1)</a> をリモートデバッグに使うこともできます。 リモートデバッグを使うと、あるコンピュータ上の <a href="https://man.freebsd.org/cgi/man.cgi?query=gdb&amp;sektion=1&amp;format=html">gdb(1)</a> を使って、 別のコンピュータのカーネルをデバッグできます。 ブレークポイントの設定、カーネルコードのステップ実行など、 ふつうのプログラムのデバッグと変わりません。 コンピュータを 2 台並べてデバッグするチャンスにはなかなか恵まれないので、 私はまだリモートデバッグを試したことはありません。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=title>Bill による追記:</div><div class=paragraph><p>DDB を有効にしていてカーネルがデバッガに 落ちたら、ddb のプロンプトで “panic” と入力すれば、強制的にパニックを起こしクラッシュダンプさせることができます。 パニックの途中で、再びデバッガに落ちるかもしれませんが、 “continue” と入力すれば、 クラッシュダンプを最後まで実行させられます。</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=_dlsym_が_elf_実行形式では動作しなくなります>13.14. dlsym() が ELF 実行形式では動作しなくなります!<a class=anchor href=#_dlsym_が_elf_実行形式では動作しなくなります></a></h3><div class=paragraph><p>ELF のツール類は、 デフォルトでは実行形式の中に定義されているシンボルを、 ダイナミックリンカから見えるようにはしません。 このため、<code>dlopen(NULL, flags)</code> を呼び出して得られたハンドルに対して、 <code>dlsym()</code> で探索を行っても、 こういったシンボルを見つけられません。</p></div><div class=paragraph><p>もし、あなたがプロセスの中心にあたる実行形式の中にあるシンボルを探索したければ、 ELF リンカ (<a href="https://man.freebsd.org/cgi/man.cgi?query=ld&amp;sektion=1&amp;format=html">ld(1)</a>) に <code>-export-dynamic</code> オプションを付けて実行形式をリンクする必要があります。</p></div></div><div class=sect2><h3 id=_カーネルアドレス空間を大きくしたり_小さくするにはどうしたら良いのですか>13.15. カーネルアドレス空間を大きくしたり、 小さくするにはどうしたら良いのですか?<a class=anchor href=#_カーネルアドレス空間を大きくしたり_小さくするにはどうしたら良いのですか></a></h3><div class=paragraph><p>カーネルアドレス空間は、FreeBSD 3.X 上で 256MB、FreeBSD 4.X 上で 1GB がデフォルトになっています。 負荷の高いネットワークサーバ (たとえば大きな FTP、HTTP サーバ) を運用する場合は、256MB では足りないことに気付くかも知れません。</p></div><div class=paragraph><p>では、アドレス空間を大きくするにはどうしたら良いのでしょうか? それには、二つの段階を踏みます。まず、 より大きいアドレス空間を割り当てることをカーネルに知らせる必要があります。 次に、カーネルはアドレス空間の先頭にロードされるため、 アドレスの先頭が天井 (訳注:カーネルアドレス空間の最下端アドレスのこと) と ぶつかることのないように、ロードアドレスを今までより低位に設定する必要があります。</p></div><div class=paragraph><p>最初の段階は、<span class=filename>src/sys/i386/include/pmap.h</span> にある <code>NKPDE</code> の値を増加させることで行ないます。 ここに 1GB のアドレス空間にするために、どのようにすれば良いかを示します。</p></div><div class="literalblock programlisting"><div class=content><pre>#ifndef NKPDE
#ifdef SMP
#define NKPDE                   254     /* addressable number of page tables/pde&#39;s */
#else
#define NKPDE                   255     /* addressable number of page tables/pde&#39;s */
#endif  /* SMP */
#endif</pre></div></div><div class=paragraph><p>正確な <code>NKPDE</code> の値を計算するには、 望みのアドレス空間の大きさ (メガバイト単位) を 4 で割って、 それから単一プロセッサ (UP) なら 1、SMP なら 2 を引き算してください。</p></div><div class=paragraph><p>次の段階を行なうには、ロードアドレスを正確に計算することが必要です。 単純に、アドレス空間の大きさ (バイト単位) を 0x100100000 から引き算してください。 1GB アドレス空間の場合、その結果は 0xc0100000 になります。 そして、<span class=filename>src/sys/i386/conf/Makefile.i386</span> にある LOAD_ADDRESS に、今計算した値を入れます。また、次のように <span class=filename>src/sys/i386/conf/kernel.script</span> のセクションの始めの方にあるロケーションカウンタにも同じ値を入れてください。</p></div><div class="literalblock programlisting"><div class=content><pre>OUTPUT_FORMAT(&#34;elf32-i386&#34;, &#34;elf32-i386&#34;, &#34;elf32-i386&#34;)
OUTPUT_ARCH(i386)
ENTRY(btext)
SEARCH_DIR(/usr/lib); SEARCH_DIR(/usr/obj/elf/home/src/tmp/usr/i386-unknown-freebsdelf/lib);
SECTIONS
{
/* Read-only sections, merged into text segment: */
. = 0xc0100000 + SIZEOF_HEADERS;
.interp     : { *(.interp)    }</pre></div></div><div class=paragraph><p>それが完了したら、<code>config</code> し直してカーネルを再構築してください。 おそらく、<a href="https://man.freebsd.org/cgi/man.cgi?query=ps&amp;sektion=1&amp;format=html">ps(1)</a>、<a href="https://man.freebsd.org/cgi/man.cgi?query=top&amp;sektion=1&amp;format=html">top(1)</a> などに不具合が出るでしょう。 それらを正常にするために、<code>make world</code> (もしくは、変更した <span class=filename>pmap.h</span> を <span class=filename>/usr/include/vm/</span> にコピーした後に、 <span class=filename>libkvm</span>、 <code>ps</code> および <code>top</code> を手動で再構築すること) を行なうべきです。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>カーネルアドレス空間の大きさは、4MB の倍数である必要があります。</p></div></td></tr></tbody></table></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=title>David Greenman &lt;<a href=mailto:dg@FreeBSD.org>dg@FreeBSD.org</a>> 氏による補足:</div><div class=paragraph><p>カーネルアドレス空間は 2 の乗数である必要があると思いますが、 それが確かなことかどうかははっきりしていません。 昔の起動コードには、良く高位アドレスビットのトリックが使われていたため、 少なくとも 256MB の粒度であることが想定されていたと思います。</p></div></td></tr></tbody></table></div></div></div></div><div class=sect1><h2 id=_謝辞>14. 謝辞<a class=anchor href=#_謝辞></a></h2><div class=sectionbody><div class=paragraph><p>FreeBSD Core Team
この FAQ について問題を見つけたり、何か登録したい場合は、 FAQ 管理者 &lt;<a href=mailto:faq@FreeBSD.org>faq@FreeBSD.org</a>> までメールを送ってください。 フィードバックしてくれるみなさんには感謝感謝なのです。 みなさんに手伝ってもらわないとこの FAQ はよくなりませんから!</p></div><div class=dlist><dl><dt class=hdlist1>Jordan K. Hubbard &lt;<a href=mailto:jkh@FreeBSD.org>jkh@FreeBSD.org</a>></dt><dd><p>たまに起こす FAQ の並べ替えや更新の発作</p></dd><dt class=hdlist1>Doug White &lt;<a href=mailto:dwhite@FreeBSD.org>dwhite@FreeBSD.org</a>></dt><dd><p>freebsd-questions メーリングリストでの義務を超えたサービス</p></dd><dt class=hdlist1>Jörg Wunsch &lt;<a href=mailto:joerg@FreeBSD.org>joerg@FreeBSD.org</a>></dt><dd><p>Usenet (NetNews) での義務を超えたサービス</p></dd><dt class=hdlist1>Garrett Wollman &lt;<a href=mailto:wollman@FreeBSD.org>wollman@FreeBSD.org</a>></dt><dd><p>ネットワーク節の執筆と文書整形</p></dd><dt class=hdlist1>Jim Lowe</dt><dd><p>マルチキャストについて</p></dd><dt class=hdlist1>Peter da Silva &lt;<a href=mailto:pds@FreeBSD.org>pds@FreeBSD.org</a>></dt><dd><p>FreeBSD FAQ タイピング機械奴隷</p></dd><dt class=hdlist1>FreeBSD チーム</dt><dd><p>不平を言ったり、うめいたり、情報提供してくれたり</p></dd></dl></div><div class=paragraph><p>あと、抜けてしまった他の方々に対して、謝罪と心からの感謝を捧げます!</p></div></div></div><div class=sect1><h2 id=_freebsd_faq_日本語化について>15. FreeBSD FAQ 日本語化について<a class=anchor href=#_freebsd_faq_日本語化について></a></h2><div class=sectionbody><div class=paragraph><p>FreeBSD 日本語ドキュメンテーションプロジェクトは、 FreeBSD 関係の日本語文書が少ないことを嘆いた数人の FreeBSD ユーザの提唱によって 1996 年 2 月 26 日にスタートし、 FreeBSD 日本語ハンドブックの作成をはじめとした活動を行なってきました。 FreeBSD FAQ の日本語化についてはオリジナルの翻訳作業だけでなく、 日本国内に固有の話題についても広く情報を集め、 日本の FreeBSD ユーザにとって真に有益なドキュメントを提供しようと考えています。 オリジナルの FAQ は日毎に更新されており、 私たちもまたこれに追い付くために作業を続けていきます。もちろん、新しいメンバも大歓迎です。 日本語翻訳版について、何かお気づきの点がありましたら、 日本語ドキュメンテーションプロジェクト &lt;<a href=mailto:doc-jp@jp.FreeBSD.org>doc-jp@jp.FreeBSD.org</a>> までご連絡ください。 また、もし私たちの作業を手伝ってくれるなら、 <a href=http://www.jp.FreeBSD.org/doc-jp/>FreeBSD 日本語ドキュメンテーションプロジェクトのページ</a>をご覧の上、是非参加してください。</p></div><div class=sect2><h3 id=_翻訳者_五十音順>15.1. 翻訳者 (五十音順)<a class=anchor href=#_翻訳者_五十音順></a></h3><div class=ulist><ul><li><p>有村 光晴 &lt;<a href=mailto:arimura@jp.FreeBSD.org>arimura@jp.FreeBSD.org</a>></p></li><li><p>一宮 亮 &lt;<a href=mailto:ryo@azusa.shinshu-u.ac.jp>ryo@azusa.shinshu-u.ac.jp</a>></p></li><li><p>岩崎 満 &lt;<a href=mailto:iwasaki@jp.FreeBSD.org>iwasaki@jp.FreeBSD.org</a>></p></li><li><p>内川 喜章 &lt;<a href=mailto:yoshiaki@kt.rim.or.jp>yoshiaki@kt.rim.or.jp</a>></p></li><li><p>栗山 淳 &lt;<a href=mailto:kuriyama@FreeBSD.org>kuriyama@FreeBSD.org</a>></p></li><li><p>こがよういちろう &lt;<a href=mailto:y-koga@ccs.mt.nec.co.jp>y-koga@ccs.mt.nec.co.jp</a>></p></li><li><p>今野 元之 &lt;<a href=mailto:motoyuki@FreeBSD.org>motoyuki@FreeBSD.org</a>></p></li><li><p>杉村 貴士 &lt;<a href=mailto:sugimura@jp.FreeBSD.org>sugimura@jp.FreeBSD.org</a>></p></li><li><p>中井 幸博 &lt;<a href=mailto:nakai@FreeBSD.org>nakai@FreeBSD.org</a>></p></li><li><p>にしか &lt;<a href=mailto:nishika@cheerful.com>nishika@cheerful.com</a>></p></li><li><p>花井 浩之 &lt;<a href=mailto:hanai@FreeBSD.org>hanai@FreeBSD.org</a>></p></li><li><p>はらだ きろう &lt;<a href=mailto:kiroh@jp.FreeBSD.org>kiroh@jp.FreeBSD.org</a>></p></li><li><p>広瀬 昌一 &lt;<a href=mailto:shou@kt.rim.or.jp>shou@kt.rim.or.jp</a>></p></li><li><p>福間 康弘 &lt;<a href=mailto:yasuf@big.or.jp>yasuf@big.or.jp</a>></p></li><li><p>むらたしゅういちろう &lt;<a href=mailto:mrt@mickey.ai.kyutech.ac.jp>mrt@mickey.ai.kyutech.ac.jp</a>></p></li><li><p>山下 淳 &lt;<a href=mailto:junkun@esys.tsukuba.ac.jp>junkun@esys.tsukuba.ac.jp</a>></p></li></ul></div></div><div class=sect2><h3 id=_査読者_五十音順>15.2. 査読者 (五十音順)<a class=anchor href=#_査読者_五十音順></a></h3><div class=ulist><ul><li><p>浅見 賢 &lt;<a href=mailto:asami@FreeBSD.org>asami@FreeBSD.org</a>></p></li><li><p>岩崎 満 &lt;<a href=mailto:iwasaki@jp.FreeBSD.org>iwasaki@jp.FreeBSD.org</a>></p></li><li><p>内川 喜章 &lt;<a href=mailto:yoshiaki@kt.rim.or.jp>yoshiaki@kt.rim.or.jp</a>></p></li><li><p>大橋 健 &lt;<a href=mailto:ohashi@mickey.ai.kyutech.ac.jp>ohashi@mickey.ai.kyutech.ac.jp</a>></p></li><li><p>栗山 淳 &lt;<a href=mailto:kuriyama@FreeBSD.org>kuriyama@FreeBSD.org</a>></p></li><li><p>今野 元之 &lt;<a href=mailto:motoyuki@FreeBSD.org>motoyuki@FreeBSD.org</a>></p></li><li><p>佐伯 隆司 &lt;<a href=mailto:saeki@jp.FreeBSD.org>saeki@jp.FreeBSD.org</a>></p></li><li><p>杉村 貴士 &lt;<a href=mailto:sugimura@jp.FreeBSD.org>sugimura@jp.FreeBSD.org</a>></p></li><li><p>花井 浩之 &lt;<a href=mailto:hanai@FreeBSD.org>hanai@FreeBSD.org</a>></p></li><li><p>浜田 直樹 &lt;<a href=mailto:nao@tom-yam.or.jp>nao@tom-yam.or.jp</a>></p></li><li><p>はらだ きろう &lt;<a href=mailto:kiroh@jp.FreeBSD.org>kiroh@jp.FreeBSD.org</a>></p></li><li><p>日野 浩志 &lt;<a href=mailto:hino@ccm.cl.nec.co.jp>hino@ccm.cl.nec.co.jp</a>></p></li><li><p>檜山 卓 &lt;<a href=mailto:shiyama@intercity.or.jp>shiyama@intercity.or.jp</a>></p></li><li><p>広瀬 昌一 &lt;<a href=mailto:shou@kt.rim.or.jp>shou@kt.rim.or.jp</a>></p></li><li><p>むらたしゅういちろう &lt;<a href=mailto:mrt@mickey.ai.kyutech.ac.jp>mrt@mickey.ai.kyutech.ac.jp</a>></p></li><li><p>若井 久史 &lt;<a href=mailto:earth@hokuto7.or.jp>earth@hokuto7.or.jp</a>></p></li></ul></div></div><div class=sect2><h3 id=_作業環境整備_五十音順>15.3. 作業環境整備 (五十音順)<a class=anchor href=#_作業環境整備_五十音順></a></h3><div class=ulist><ul><li><p>一宮 亮 &lt;<a href=mailto:ryo@azusa.shinshu-u.ac.jp>ryo@azusa.shinshu-u.ac.jp</a>></p></li><li><p>岩崎 満 &lt;<a href=mailto:iwasaki@jp.FreeBSD.org>iwasaki@jp.FreeBSD.org</a>></p></li><li><p>下川 英敏 &lt;<a href=mailto:simokawa@jp.FreeBSD.org>simokawa@jp.FreeBSD.org</a>></p></li><li><p>鈴木 秀幸 &lt;<a href=mailto:hideyuki@jp.FreeBSD.org>hideyuki@jp.FreeBSD.org</a>></p></li></ul></div></div></div></div><div class=sect1><h2 id=bibliography>有用な書籍<a class=anchor href=#bibliography></a></h2><div class=sectionbody><div id=biblio-44sysman class=paragraph><p>[biblio-44sysman] 4.4BSD System Manager’s Manual. Computer Systems Research Group, University of California, Berkeley. O’Reilly and Associates. 1st Edition. June 1994. 804 pages. ISBN 1-56592-080-5.</p></div><div id=biblio-44userman class=paragraph><p>[biblio-44userman] 4.4BSD User’s Reference Manual. Computer Systems Research Group, University of California, Berkeley. O’Reilly and Associates. 1st Edition. June 1994. 905 pages. ISBN 1-56592-075-9.</p></div><div id=biblio-44suppman class=paragraph><p>[biblio-44suppman] 4.4BSD User’s Supplementary Documents. Computer Systems Research Group, University of California, Berkeley. O’Reilly and Associates. 1st Edition. June 1994. 712 pages. ISBN 1-56592-076-7.</p></div><div id=biblio-44progman class=paragraph><p>[biblio-44progman] 4.4BSD Programmer’s Reference Manual. Computer Systems Research Group, University of California, Berkeley. O’Reilly and Associates. 1st Edition. June 1994. 866 pages. ISBN 1-56592-078-3.</p></div><div id=biblio-44progsupp class=paragraph><p>[biblio-44progsupp] 4.4BSD Programmer’s Supplementary Documents. Computer Systems Research Group, University of California, Berkeley. O’Reilly and Associates. 1st Edition. June 1994. 596 pages. ISBN 1-56592-079-1.</p></div><div id=biblio-44kernel class=paragraph><p>[biblio-44kernel] The Design and Implementation of the 4.4BSD Operating System. McKusick M. K. [FAMILY Given], Marshall Kirk [FAMILY Given], Bostic Keith [FAMILY Given], Karels Michael J [FAMILY Given], 、 Quarterman John [FAMILY Given]. Addison-Wesley. Reading MA . 1996. ISBN 0-201-54979-4.</p></div><div id=biblio-nemeth3rd class=paragraph><p>[biblio-nemeth3rd] Unix System Administration Handbook. Nemeth Evi [FAMILY Given], Snyder Garth [FAMILY Given], Seebass Scott [FAMILY Given], Hein Trent R. [FAMILY Given], 、 Quarterman John [FAMILY Given]. Prentice-Hall. 3rd edition. 2000. ISBN 0-13-020601-6.</p></div><div id=lehey3rd class=paragraph><p>[lehey3rd] The Complete FreeBSD. Lehey Greg [FAMILY Given]. Walnut Creek. 3rd edition. June 1999. 773 pages. ISBN 1-57176-246-9.</p></div><div id=biblio-mckusick-1 class=paragraph><p>[McKusick et al, 1994] Berkeley Software Architecture Manual, 4.4BSD Edition. McKusick M. K. [FAMILY Given], Karels M. J. [FAMILY Given], Leffler S. J. [FAMILY Given], Joy W. N. [FAMILY Given], 、 Faber R. S. [FAMILY Given]. 5:1-42.</p></div></div></div></div><hr><div class=last-modified><p><strong>最終更新日</strong>: 2021年11月3日 by <a href="https://cgit.freebsd.org/doc/commit/?id=64acd169b8" target=_blank>Sergio Carlavilla Delgado</a></p></div><div class=buttons><div class=home><i class="fa fa-home" aria-hidden=true title=Home></i><div class=container><a href=../ class=direction>Home</a></div></div></div><label class="hidden book-menu-overlay" for=menu-control></label></div><aside class=toc><div class=toc-content><h3>目次</h3><nav id=TableOfContents><ul><li><a href=#preface>まえがき</a></li><li><a href=#_インストール>1. インストール</a></li><li><a href=#hardware>2. ハードウェアコンパチビリティ</a></li><li><a href=#_トラブルシューティング>3. トラブルシューティング</a></li><li><a href=#_商用アプリケーション>4. 商用アプリケーション</a></li><li><a href=#_ユーザアプリケーション>5. ユーザアプリケーション</a></li><li><a href=#_カーネルコンフィグレーション>6. カーネルコンフィグレーション</a></li><li><a href=#_システム管理>7. システム管理</a></li><li><a href=#_x_window_system_と仮想コンソール>8. X Window System と仮想コンソール</a></li><li><a href=#networking>9. ネットワーキング</a></li><li><a href=#_ppp>10. PPP</a></li><li><a href=#_シリアル接続>11. シリアル接続</a></li><li><a href=#_その他の質問>12. その他の質問</a></li><li><a href=#_まじめな_freebsd_ハッカーだけの話題>13. まじめな FreeBSD ハッカーだけの話題</a></li><li><a href=#_謝辞>14. 謝辞</a></li><li><a href=#_freebsd_faq_日本語化について>15. FreeBSD FAQ 日本語化について</a></li><li><a href=#bibliography>有用な書籍</a></li></ul></nav><hr><div class=resources><h3>リソース</h3><ul class=contents><li><i class="fa fa-file-pdf-o" aria-hidden=true title="PDF 版のダウンロード"></i><a href=https://download.freebsd.org/doc/ja/books/faq/faq_ja.pdf>PDF 版のダウンロード</a></li><li><i class="fa fa-pencil-square-o" aria-hidden=true title="Edit this page"></i><a href=https://github.com/freebsd/freebsd-doc/blob/main/documentation/content/ja/_index target=_blank>Edit this page</a></li></ul></div></div></aside><a class=to-top href=#top><i class="fa fa-arrow-circle-up" aria-hidden=true></i></a></main><footer><div class=footer-container><section class=logo-column><img src=http://172.16.201.134:1313/images/FreeBSD-colors.svg width=160 height=50 alt="FreeBSD logo"><div class=options-container><div class=language-container><a id=languages href=http://172.16.201.134:1313/ja/languages><img src=http://172.16.201.134:1313/images/language.png class=language-image alt="Choose language">
<span>日本語</span></a></div><div class=theme-container><select id=theme-chooser><option value=theme-system>System</option><option value=theme-light>Light</option><option value=theme-dark>Dark</option><option value=theme-high-contrast>High contrast</option></select></div></div></section><section class=about-column><h3 class=column-title>About</h3><ul class=column-elements-container><li><a href=https://www.freebsd.org/about/ target=_blank class=column-element>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/ target=_blank class=column-element>FreeBSD Foundation</a></li><li><a href=https://www.freebsd.org/where/ target=_blank class=column-element>Get FreeBSD</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct target=_blank class=column-element>Code of Conduct</a></li><li><a href=https://www.freebsd.org/security/ target=_blank class=column-element>Security Advisories</a></li></ul></section><section class=documentation-column><h3 class=column-title>Documentation</h3><ul class=column-elements-container><li><a href=/ja class=column-element>Documentation portal</a></li><li><a href=https://man.FreeBSD.org target=_blank class=column-element>Manual pages</a></li><li><a href=https://papers.FreeBSD.org target=_blank class=column-element>Presentations and papers</a></li><li><a href=https://docs-archive.freebsd.org/doc/ target=_blank class=column-element>Previous versions</a></li><li><a href=https://docs-archive.freebsd.org/44doc/ target=_blank class=column-element>4.4BSD Documents</a></li><li><a href=https://wiki.freebsd.org/ target=_blank class=column-element>Wiki</a></li></ul></section><section class=community-column><h3 class=column-title>Community</h3><ul class=column-elements-container><li><a href=http://172.16.201.134:1313/ja/articles/contributing class=column-element>Get involved</a></li><li><a href=https://forums.freebsd.org/ target=_blank class=column-element>Community forum</a></li><li><a href=https://lists.freebsd.org/ target=_blank class=column-element>Mailing lists</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank class=column-element>IRC Channels</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank class=column-element>Bug Tracker</a></li></ul></section><section class=legal-column><h3 class=column-title>Legal</h3><ul class=column-elements-container><li><a href=https://freebsdfoundation.org/donate/ target=_blank class=column-element>Donations</a></li><li><a href=https://www.freebsd.org/copyright/freebsd-license/ target=_blank class=column-element>Licensing</a></li><li><a href=https://www.freebsd.org/privacy/ target=_blank class=column-element>Privacy Policy</a></li><li><a href=https://www.freebsd.org/copyright/ target=_blank class=column-element>Legal notices</a></li></ul></section><section class=copyright-column><p>&copy; 1994-2024 The FreeBSD Project. All rights reserved</p><span>Made with <span class=heart>♥</span> by the FreeBSD Community</span></section></div></footer></body></html>