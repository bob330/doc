<!doctype html><html class=theme-light lang=zh-tw><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content><meta name=keywords content><meta name=copyright content="1995-2024 The FreeBSD Foundation"><link rel=canonical href=https://docs.freebsd.org/zh-tw/books/handbook/advanced-networking/><title>章 31. 進階網路設定 | FreeBSD Documentation Portal</title>
<meta name=theme-color content="#790000"><meta name=color-scheme content="system light dark high-contrast"><link rel="shortcut icon" href=https://docs.freebsd.org/favicon.ico><link rel=stylesheet href=https://docs.freebsd.org/styles/main.min.css><link rel=stylesheet href=https://docs.freebsd.org/css/font-awesome-min.css><script defer src=/js/theme-chooser.min.js></script><script defer src=/js/copy-clipboard.min.js></script><script defer src=/js/search.min.js></script><meta name=twitter:card content="summary"><meta name=twitter:domain content="docs.FreeBSD.org"><meta name=twitter:site content="@freebsd"><meta name=twitter:url content="https://twitter.com/freebsd"><meta property="og:title" content="章 31. 進階網路設定"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:image" content="https://docs.freebsd.org/favicon.ico"><meta property="og:image:alt" content="FreeBSD Logo"><meta property="og:locale" content="zh-tw"><meta property="og:url" content="https://docs.freebsd.org/zh-tw/books/handbook/advanced-networking/"><meta property="og:site_name" content="FreeBSD Documentation Portal"><script type=application/ld+json>{"@context":"http://schema.org","@type":"Article","url":"https:\/\/docs.freebsd.org\/zh-tw\/books\/handbook\/advanced-networking\/","name":"FreeBSD Documentation Portal","headline":"FreeBSD Documentation Portal","description":"FreeBSD Documentation Portal"}</script></head><body><header><div class=header-container><div class=logo-menu-bars-container><a href=https://www.FreeBSD.org class=logo><img src=https://docs.freebsd.org/images/FreeBSD-monochromatic.svg width=160 height=50 alt="FreeBSD logo">
</a><label class=menu-bars for=menu-bars><i class="fa fa-bars" aria-hidden=true></i></label></div><input id=menu-bars type=checkbox><nav><ul class=menu><li class=menu-item><input id=about type=checkbox>
<a href=# aria-label="Navigate to About section"><label class=menu-item-description for=about>About
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/about/ target=_blank>About</a></li><li><a href=https://www.freebsd.org/about/ target=_blank>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/about-us/about-the-foundation/ target=_blank>FreeBSD Foundation</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct/ target=_blank>Code of Conduct</a></li></ul></li><li class=menu-item><input id=download type=checkbox>
<a href=# aria-label="Navigate to get FreeBSD section"><label class=menu-item-description for=download>Get FreeBSD
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/where/ target=_blank>Get FreeBSD</a></li><li><a href=https://www.freebsd.org/releases/ target=_blank>Release Information</a></li><li><a href=https://www.freebsd.org/releng/ target=_blank>Release Engineering</a></li><li><a href=https://www.freebsd.org/security/ target=_blank>Security Advisories</a></li></ul></li><li class=menu-item><input id=documentation type=checkbox>
<a href=# aria-label="Navigate to get Documentation section"><label class=menu-item-description for=documentation>Documentation
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=/zh-tw>Documentation portal</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook>FreeBSD Handbook</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/porters-handbook>Porter's Handbook</a></li><li><a href=https://docs.FreeBSD.org/en/books/fdp-primer>Documentation Project Handbook</a></li><li><a href=https://man.FreeBSD.org target=_blank>Manual pages</a></li><li><a href=https://papers.FreeBSD.org target=_blank>Presentations and papers</a></li><li><a href=https://wiki.FreeBSD.org target=_blank>Wiki</a></li><li><a href=https://docs.freebsd.org/zh-tw/books>Books</a></li><li><a href=https://docs.freebsd.org/zh-tw/articles>Articles</a></li></ul></li><li class=menu-item><input id=community type=checkbox>
<a href=# aria-label="Navigate to get Community section"><label class=menu-item-description for=community>Community
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/community/>Community</a></li><li><a href=https://docs.freebsd.org/zh-tw/articles/contributing>Get involved</a></li><li><a href=https://forums.freebsd.org/ target=_blank>Forum</a></li><li><a href=https://lists.freebsd.org/ target=_blank>Mailing lists</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank>IRC Channels</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank>Bug Tracker</a></li><li><a href=https://www.freebsd.org/support/ target=_blank>Support</a></li></ul></li></ul></nav><div class=search-donate-container><form class=search method=get id=search-header-form action=https://docs.freebsd.org/search name=search-header-form><input type=hidden name=DB value=zh-tw>
<input id=words name=P type=text size=20 maxlength=255>
<button>
<i class="fa fa-search" aria-hidden=true></i></button></form><div class=donate><a href=https://freebsdfoundation.org/donate/ target=_blank><span class=heart>♥</span>
Donate</a></div></div></div></header><input type=checkbox class="hidden toggle" id=menu-control><main class=main-wrapper-book><a id=top></a><aside class=book-menu><div class=book-menu-content><input id=search-book type=text placeholder=Search aria-label=Search maxlength=128><nav id=MenuContents><ul><li><input type=checkbox id=chapter-eb2a98ce203d8afd517726e6d8776be3 class=toggle>
<label class="icon cursor" for=chapter-eb2a98ce203d8afd517726e6d8776be3><a role=button></a></label><a href=https://docs.freebsd.org/zh-tw/books/handbook/preface/>序</a><ul><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/preface/#preface-audience>給讀者的話</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/preface/#preface-changes-from3>自第三版後的主要修訂</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/preface/#preface-changes-from2>自第二版後的主要修訂 (2004)</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/preface/#preface-changes>自第一版後的主要修訂 (2001)</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/preface/#preface-overview>本書架構</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/preface/#preface-conv>本書的編排體裁</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/preface/#preface-acknowledgements>銘謝</a></li></ul></li><li><input type=checkbox id=chapter-14a525fce014b90b8a458a894818255a class=toggle>
<label for=chapter-14a525fce014b90b8a458a894818255a><a role=button></a></label><a href=https://docs.freebsd.org/zh-tw/books/handbook/parti/>部 I. 入門</a></li><li><input type=checkbox id=chapter-f9c9f3451644df30d224350da97d5da6 class=toggle>
<label class="icon cursor" for=chapter-f9c9f3451644df30d224350da97d5da6><a role=button></a></label><a href=https://docs.freebsd.org/zh-tw/books/handbook/introduction/>章 1. 簡介</a><ul><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/introduction/#introduction-synopsis>1.1. 概述</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/introduction/#nutshell>1.2. 歡迎使用 FreeBSD！</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/introduction/#history>1.3. 關於 FreeBSD 計劃</a></li></ul></li><li><input type=checkbox id=chapter-f693a3fa687a72d63ec8129ee302d664 class=toggle>
<label class="icon cursor" for=chapter-f693a3fa687a72d63ec8129ee302d664><a role=button></a></label><a href=https://docs.freebsd.org/zh-tw/books/handbook/bsdinstall/>章 2. 安裝 FreeBSD</a><ul><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/bsdinstall/#bsdinstall-synopsis>2.1. 概述</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/bsdinstall/#bsdinstall-hardware>2.2. 最低硬體需求</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/bsdinstall/#bsdinstall-pre>2.3. 安裝前準備工作</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/bsdinstall/#bsdinstall-start>2.4. 開始安裝</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/bsdinstall/#using-bsdinstall>2.5. 使用 bsdinstall</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/bsdinstall/#bsdinstall-partitioning>2.6. 配置磁碟空間</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/bsdinstall/#bsdinstall-final-warning>2.7. 確認安裝</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/bsdinstall/#bsdinstall-post>2.8. 安裝後注意事項</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/bsdinstall/#bsdinstall-install-trouble>2.9. 疑難排解</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/bsdinstall/#using-live-cd>2.10. 使用 Live CD</a></li></ul></li><li><input type=checkbox id=chapter-9f6db261075f578742036fcc6000eecd class=toggle>
<label class="icon cursor" for=chapter-9f6db261075f578742036fcc6000eecd><a role=button></a></label><a href=https://docs.freebsd.org/zh-tw/books/handbook/basics/>章 3. FreeBSD 基礎</a><ul><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/basics/#basics-synopsis>3.1. 概述</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/basics/#consoles>3.2. 虛擬 Console 與終端機</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/basics/#users-synopsis>3.3. 使用者與基礎帳號管理</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/basics/#permissions>3.4. 權限</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/basics/#dirstructure>3.5. 目錄結構</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/basics/#disk-organization>3.6. 磁碟組織</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/basics/#mount-unmount>3.7. 掛載與卸載檔案系統</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/basics/#basics-processes>3.8. 程序與 Daemon</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/basics/#shells>3.9. Shell</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/basics/#editors>3.10. 文字編輯器</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/basics/#basics-devices>3.11. 裝置及裝置節點</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/basics/#basics-more-information>3.12. 操作手冊</a></li></ul></li><li><input type=checkbox id=chapter-01c5707e95d14c0ff84bf62600c958d1 class=toggle>
<label class="icon cursor" for=chapter-01c5707e95d14c0ff84bf62600c958d1><a role=button></a></label><a href=https://docs.freebsd.org/zh-tw/books/handbook/ports/>章 4. 安裝應用程式：套件與 Port</a><ul><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/ports/#ports-synopsis>4.1. 概述</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/ports/#ports-overview>4.2. 安裝軟體的概要</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/ports/#ports-finding-applications>4.3. 搜尋軟體</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/ports/#pkgng-intro>4.4. 使用 pkg 管理 Binary 套件</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/ports/#ports-using>4.5. 使用 Port 套件集</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/ports/#ports-poudriere>4.6. 使用 Poudriere 編譯套件</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/ports/#ports-nextsteps>4.7. 安裝後的注意事項</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/ports/#ports-broken>4.8. 處理損壞的 Port</a></li></ul></li><li><input type=checkbox id=chapter-3405c00581365a8b5d16af70fe4d1b72 class=toggle>
<label class="icon cursor" for=chapter-3405c00581365a8b5d16af70fe4d1b72><a role=button></a></label><a href=https://docs.freebsd.org/zh-tw/books/handbook/x11/>章 5. X Window 系統</a><ul><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/x11/#x11-synopsis>5.1. 概述</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/x11/#x-understanding>5.2. 術語</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/x11/#x-install>5.3. 安裝 Xorg</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/x11/#x-config>5.4. Xorg 設定</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/x11/#x-fonts>5.5. 在 Xorg 使用字型</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/x11/#x-xdm>5.6. X 顯示管理程式</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/x11/#x11-wm>5.7. 桌面環境</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/x11/#x-compiz-fusion>5.8. 安裝 Compiz Fusion</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/x11/#x11-understanding>5.9. 疑難排解</a></li></ul></li><li><input type=checkbox id=chapter-0eab3565e8f59f5a8a896dfba7eb3680 class=toggle>
<label for=chapter-0eab3565e8f59f5a8a896dfba7eb3680><a role=button></a></label><a href=https://docs.freebsd.org/zh-tw/books/handbook/partii/>部 II. 一般作業</a></li><li><input type=checkbox id=chapter-b33cf28993f3f7bf5baf036e79da0f39 class=toggle>
<label class="icon cursor" for=chapter-b33cf28993f3f7bf5baf036e79da0f39><a role=button></a></label><a href=https://docs.freebsd.org/zh-tw/books/handbook/desktop/>章 6. 桌面應用程式</a><ul><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/desktop/#desktop-synopsis>6.1. 概述</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/desktop/#desktop-browsers>6.2. 瀏覽器</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/desktop/#desktop-productivity>6.3. 辦工工具</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/desktop/#desktop-viewers>6.4. 文件閱覽程式</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/desktop/#desktop-finance>6.5. 財務</a></li></ul></li><li><input type=checkbox id=chapter-152f694a19312ad72ec7bb4e1c3c33b2 class=toggle>
<label class="icon cursor" for=chapter-152f694a19312ad72ec7bb4e1c3c33b2><a role=button></a></label><a href=https://docs.freebsd.org/zh-tw/books/handbook/multimedia/>章 7. 多媒體</a><ul><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/multimedia/#multimedia-synopsis>7.1. 概述</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/multimedia/#sound-setup>7.2. 設定音效卡</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/multimedia/#sound-mp3>7.3. MP3 音樂</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/multimedia/#video-playback>7.4. 影片播放</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/multimedia/#tvcard>7.5. 電視卡</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/multimedia/#mythtv>7.6. MythTV</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/multimedia/#scanners>7.7. 影像掃描器</a></li></ul></li><li><input type=checkbox id=chapter-80888b4ee02e3e409e5f71cf97a36450 class=toggle>
<label class="icon cursor" for=chapter-80888b4ee02e3e409e5f71cf97a36450><a role=button></a></label><a href=https://docs.freebsd.org/zh-tw/books/handbook/kernelconfig/>章 8. 設定 FreeBSD 核心</a><ul><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/kernelconfig/#kernelconfig-synopsis>8.1. 概述</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/kernelconfig/#kernelconfig-custom-kernel>8.2. 為何要編譯自訂的核心?</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/kernelconfig/#kernelconfig-devices>8.3. 偵測系統硬體</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/kernelconfig/#kernelconfig-config>8.4. 設定檔</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/kernelconfig/#kernelconfig-building>8.5. 編譯與安裝自訂核心</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/kernelconfig/#kernelconfig-trouble>8.6. 如果發生錯誤</a></li></ul></li><li><input type=checkbox id=chapter-cb174c55879b17ab955f2f16989a79e0 class=toggle>
<label class="icon cursor" for=chapter-cb174c55879b17ab955f2f16989a79e0><a role=button></a></label><a href=https://docs.freebsd.org/zh-tw/books/handbook/printing/>章 9. 列印</a><ul><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/printing/#printing-quick-start>9.1. 快速開始</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/printing/#printing-connections>9.2. 印表機連線</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/printing/#printing-pdls>9.3. 常見的頁面描述語言</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/printing/#printing-direct>9.4. 直接列印</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/printing/#printing-lpd>9.5. LPD (行列式印表機 Daemon)</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/printing/#printing-other>9.6. 其他列印系統</a></li></ul></li><li><input type=checkbox id=chapter-c12b8c3f2a8fcefce87087241f695c83 class=toggle>
<label class="icon cursor" for=chapter-c12b8c3f2a8fcefce87087241f695c83><a role=button></a></label><a href=https://docs.freebsd.org/zh-tw/books/handbook/linuxemu/>章 10. Linux® Binary 相容性</a><ul><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/linuxemu/#linuxemu-synopsis>10.1. 概述</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/linuxemu/#linuxemu-lbc-install>10.2. 設定 Linux™ Binary 相容性</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/linuxemu/#linuxemu-advanced>10.3. 進階主題</a></li></ul></li><li><input type=checkbox id=chapter-03b11ba627b9a0c85b247f5641bde272 class=toggle>
<label for=chapter-03b11ba627b9a0c85b247f5641bde272><a role=button></a></label><a href=https://docs.freebsd.org/zh-tw/books/handbook/partiii/>部 III. 系統管理</a></li><li><input type=checkbox id=chapter-6c31587f8d736319f099cd4dc1961301 class=toggle>
<label class="icon cursor" for=chapter-6c31587f8d736319f099cd4dc1961301><a role=button></a></label><a href=https://docs.freebsd.org/zh-tw/books/handbook/config/>章 11. 設定與調校</a><ul><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/config/#config-synopsis>11.1. 概述</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/config/#configtuning-starting-services>11.2. 啟動服務</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/config/#configtuning-cron>11.3. 設定 cron(8)</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/config/#configtuning-rcd>11.4. 管理 FreeBSD 中的服務</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/config/#config-network-setup>11.5. 設定網路介面卡</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/config/#configtuning-virtual-hosts>11.6. 虛擬主機</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/config/#configtuning-syslog>11.7. 設定系統日誌</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/config/#configtuning-configfiles>11.8. 設定檔</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/config/#configtuning-sysctl>11.9. 使用 sysctl(8) 調校</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/config/#configtuning-disk>11.10. 調校磁碟</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/config/#configtuning-kernel-limits>11.11. 調校核心限制</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/config/#adding-swap-space>11.12. 增加交換空間</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/config/#acpi-overview>11.13. 電源與資源管理</a></li></ul></li><li><input type=checkbox id=chapter-459f0012b3b4f0b6b123010f029da5e4 class=toggle>
<label class="icon cursor" for=chapter-459f0012b3b4f0b6b123010f029da5e4><a role=button></a></label><a href=https://docs.freebsd.org/zh-tw/books/handbook/boot/>章 12. FreeBSD 開機程序</a><ul><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/boot/#boot-synopsis>12.1. 概述</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/boot/#boot-introduction>12.2. FreeBSD 開機程序</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/boot/#boot-splash>12.3. 設定開機啟動畫面</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/boot/#device-hints>12.4. 裝置提示</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/boot/#boot-shutdown>12.5. 關機程序</a></li></ul></li><li><input type=checkbox id=chapter-917c75fcffbb14d48ed6d0a48e7028f2 class=toggle>
<label class="icon cursor" for=chapter-917c75fcffbb14d48ed6d0a48e7028f2><a role=button></a></label><a href=https://docs.freebsd.org/zh-tw/books/handbook/security/>章 13. 安全性</a><ul><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/security/#security-synopsis>13.1. 概述</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/security/#security-intro>13.2. 簡介</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/security/#one-time-passwords>13.3. 一次性密碼</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/security/#tcpwrappers>13.4. TCP Wrapper</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/security/#kerberos5>13.5. Kerberos</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/security/#openssl>13.6. OpenSSL</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/security/#ipsec>13.7. VPN over IPsec</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/security/#openssh>13.8. OpenSSH</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/security/#fs-acl>13.9. 存取控制清單</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/security/#security-pkg>13.10. 監視第三方安全性問題</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/security/#security-advisories>13.11. FreeBSD 安全報告</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/security/#security-accounting>13.12. 程序追蹤</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/security/#security-resourcelimits>13.13. 限制資源</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/security/#security-sudo>13.14. 使用 Sudo 分享管理權限</a></li></ul></li><li><input type=checkbox id=chapter-1a2a8e719703649c2c66d99aa7a25fd4 class=toggle>
<label class="icon cursor" for=chapter-1a2a8e719703649c2c66d99aa7a25fd4><a role=button></a></label><a href=https://docs.freebsd.org/zh-tw/books/handbook/jails/>章 14. Jail</a><ul><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/jails/#jails-synopsis>14.1. 概述</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/jails/#jails-terms>14.2. Jail 相關術語</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/jails/#jails-build>14.3. 建立和控制 Jail</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/jails/#jails-tuning>14.4. 調校與管理</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/jails/#jails-application>14.5. 更新多個 Jail</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/jails/#jails-ezjail>14.6. 使用 ezjail 管理 Jail</a></li></ul></li><li><input type=checkbox id=chapter-8f4620c77e572cbb58917911a33c73cf class=toggle>
<label class="icon cursor" for=chapter-8f4620c77e572cbb58917911a33c73cf><a role=button></a></label><a href=https://docs.freebsd.org/zh-tw/books/handbook/mac/>章 15. 強制存取控制 (MAC)</a><ul><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/mac/#mac-synopsis>15.1. 概述</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/mac/#mac-inline-glossary>15.2. 關鍵詞</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/mac/#mac-understandlabel>15.3. 了解 MAC 標籤</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/mac/#mac-planning>15.4. 規劃安全架構</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/mac/#mac-policies>15.5. 可用的 MAC 管理政策</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/mac/#mac-userlocked>15.6. User Lock Down</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/mac/#mac-implementing>15.7. 在 MAC Jail 中使用 Nagios</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/mac/#mac-troubleshoot>15.8. MAC 架構疑難排解</a></li></ul></li><li><input type=checkbox id=chapter-9598d66a76cb3182057b6bcd775149a0 class=toggle>
<label class="icon cursor" for=chapter-9598d66a76cb3182057b6bcd775149a0><a role=button></a></label><a href=https://docs.freebsd.org/zh-tw/books/handbook/audit/>章 16. 安全事件稽查</a><ul><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/audit/#audit-synopsis>16.1. 概述</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/audit/#audit-inline-glossary>16.2. 關鍵詞</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/audit/#audit-config>16.3. 稽查設定</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/audit/#audit-administration>16.4. 查看稽查線索</a></li></ul></li><li><input type=checkbox id=chapter-e1edcad13d9db6e8e4cb645d378ecfaf class=toggle>
<label class="icon cursor" for=chapter-e1edcad13d9db6e8e4cb645d378ecfaf><a role=button></a></label><a href=https://docs.freebsd.org/zh-tw/books/handbook/disks/>章 17. 儲存設備</a><ul><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/disks/#disks-synopsis>17.1. 概述</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/disks/#disks-adding>17.2. 加入磁碟</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/disks/#disks-growing>17.3. 重設大小與擴增磁碟</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/disks/#usb-disks>17.4. USB 儲存裝置</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/disks/#creating-cds>17.5. 建立與使用 CD 媒體</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/disks/#creating-dvds>17.6. 建立與使用 DVD 媒體</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/disks/#floppies>17.7. 建立與使用軟碟</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/disks/#backup-basics>17.8. 備份基礎概念</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/disks/#disks-virtual>17.9. 記憶體磁碟</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/disks/#snapshots>17.10. 檔案系統快照</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/disks/#quotas>17.11. 磁碟配額</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/disks/#disks-encrypting>17.12. 磁碟分割區加密</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/disks/#swap-encrypting>17.13. 交換空間加密</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/disks/#disks-hast>17.14. 高可用存儲空間 (HAST)</a></li></ul></li><li><input type=checkbox id=chapter-dde37901a0e0ea32745b67607854900f class=toggle>
<label class="icon cursor" for=chapter-dde37901a0e0ea32745b67607854900f><a role=button></a></label><a href=https://docs.freebsd.org/zh-tw/books/handbook/geom/>章 18. GEOM: 模組化磁碟轉換框架</a><ul><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/geom/#geom-synopsis>18.1. 概述</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/geom/#geom-striping>18.2. RAID0 - 串連 (Striping)</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/geom/#geom-mirror>18.3. RAID1 - 鏡像 (Mirroring)</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/geom/#geom-raid3>18.4. RAID3 - 位元級串連與獨立奇偶校驗</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/geom/#geom-graid>18.5. 軟體 RAID 裝置</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/geom/#geom-ggate>18.6. GEOM Gate Network</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/geom/#geom-glabel>18.7. 磁碟裝置標籤</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/geom/#geom-gjournal>18.8. UFS Journaling 透過 GEOM</a></li></ul></li><li><input type=checkbox id=chapter-73e82560fcb7145b7c0e2ec47af8fc04 class=toggle>
<label class="icon cursor" for=chapter-73e82560fcb7145b7c0e2ec47af8fc04><a role=button></a></label><a href=https://docs.freebsd.org/zh-tw/books/handbook/zfs/>章 19. Z 檔案系統 (ZFS)</a><ul><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/zfs/#zfs-differences>19.1. 什麼使 ZFS 與眾不同</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/zfs/#zfs-quickstart>19.2. 快速入門指南</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/zfs/#zfs-zpool>19.3. <code>zpool</code> 管理</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/zfs/#zfs-zfs>19.4. <code>zfs</code> 管理</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/zfs/#zfs-zfs-allow>19.5. 委託管理</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/zfs/#zfs-advanced>19.6. 進階主題</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/zfs/#zfs-links>19.7. 其他資源</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/zfs/#zfs-term>19.8. ZFS 特色與術語</a></li></ul></li><li><input type=checkbox id=chapter-7af71270807eb7b70cd3eedc6577b254 class=toggle>
<label class="icon cursor" for=chapter-7af71270807eb7b70cd3eedc6577b254><a role=button></a></label><a href=https://docs.freebsd.org/zh-tw/books/handbook/filesystems/>章 20. 其他檔案系統</a><ul><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/filesystems/#filesystems-synopsis>20.1. 概述</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/filesystems/#filesystems-linux>20.2. Linux™ 檔案系統</a></li></ul></li><li><input type=checkbox id=chapter-375257268d95faaf87faf4f7a2e6aa67 class=toggle>
<label class="icon cursor" for=chapter-375257268d95faaf87faf4f7a2e6aa67><a role=button></a></label><a href=https://docs.freebsd.org/zh-tw/books/handbook/virtualization/>章 21. 虛擬化</a><ul><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/virtualization/#virtualization-synopsis>21.1. 概述</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/virtualization/#virtualization-guest-parallels>21.2. 在 Mac OS™ X 的 Parallels 安裝 FreeBSD 為客端</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/virtualization/#virtualization-guest-virtualpc>21.3. 在 Windows™ 的 Virtual PC 安裝 FreeBSD 為客端</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/virtualization/#virtualization-guest-vmware>21.4. 在 Mac OS™ 的 VMware Fusion 安裝 FreeBSD 為客端</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/virtualization/#virtualization-guest-virtualbox>21.5. 在 VirtualBox™ 安裝 FreeBSD 作為客端</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/virtualization/#virtualization-host-virtualbox>21.6. 以 FreeBSD 作為主端使用 VirtualBox™</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/virtualization/#virtualization-host-bhyve>21.7. 以 FreeBSD 作為主端安裝 bhyve</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/virtualization/#virtualization-host-xen>21.8. 以 FreeBSD 作為主端安裝 Xen™</a></li></ul></li><li><input type=checkbox id=chapter-49f1e96591c090304ea532012257f4ef class=toggle>
<label class="icon cursor" for=chapter-49f1e96591c090304ea532012257f4ef><a role=button></a></label><a href=https://docs.freebsd.org/zh-tw/books/handbook/l10n/>章 22. 在地化 - i18n/L10n 使用與安裝</a><ul><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/l10n/#l10n-synopsis>22.1. 概述</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/l10n/#using-localization>22.2. 使用語系</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/l10n/#l10n-compiling>22.3. 尋找 i18n 應用程式</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/l10n/#lang-setup>22.4. 特定語言的語系設定</a></li></ul></li><li><input type=checkbox id=chapter-dead2b4c5ea325dd390a9b0dccd8f763 class=toggle>
<label class="icon cursor" for=chapter-dead2b4c5ea325dd390a9b0dccd8f763><a role=button></a></label><a href=https://docs.freebsd.org/zh-tw/books/handbook/cutting-edge/>章 23. 更新與升級 FreeBSD</a><ul><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/cutting-edge/#updating-upgrading-synopsis>23.1. 概述</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/cutting-edge/#updating-upgrading-freebsdupdate>23.2. FreeBSD 更新</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/cutting-edge/#updating-upgrading-documentation>23.3. 更新文件集</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/cutting-edge/#current-stable>23.4. 追蹤開發分支</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/cutting-edge/#makeworld>23.5. 從原始碼更新 FreeBSD</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/cutting-edge/#small-lan>23.6. 多部機器追蹤</a></li></ul></li><li><input type=checkbox id=chapter-913e72bfb3d6947b2869d3e9447a6eaa class=toggle>
<label class="icon cursor" for=chapter-913e72bfb3d6947b2869d3e9447a6eaa><a role=button></a></label><a href=https://docs.freebsd.org/zh-tw/books/handbook/usb-device-mode/>章 25. USB Device Mode / USB OTG</a><ul><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/usb-device-mode/#usb-device-mode-synopsis>25.1. 概述</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/usb-device-mode/#usb-device-mode-terminals>25.2. USB 虛擬序列埠</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/usb-device-mode/#usb-device-mode-network>25.3. USB 裝置模式網路介面</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/usb-device-mode/#usb-device-mode-storage>25.4. USB 虛擬儲存裝置</a></li></ul></li><li><input type=checkbox id=chapter-bbd25f9a194f9c39ca2d658c75767db5 class=toggle>
<label for=chapter-bbd25f9a194f9c39ca2d658c75767db5><a role=button></a></label><a href=https://docs.freebsd.org/zh-tw/books/handbook/partiv/>部 IV. 網路通訊</a></li><li><input type=checkbox id=chapter-29c1eeb0e9dedc487a98399e2737ee8a class=toggle>
<label class="icon cursor" for=chapter-29c1eeb0e9dedc487a98399e2737ee8a><a role=button></a></label><a href=https://docs.freebsd.org/zh-tw/books/handbook/dtrace/>章 24. DTrace</a><ul><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/dtrace/#dtrace-synopsis>24.1. 概述</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/dtrace/#dtrace-implementation>24.2. 實作差異</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/dtrace/#dtrace-enable>24.3. 開啟 DTrace 支援</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/dtrace/#dtrace-using>24.4. 使用 DTrace</a></li></ul></li><li><input type=checkbox id=chapter-499dab596afd7ddac77e80295314e0dd class=toggle>
<label class="icon cursor" for=chapter-499dab596afd7ddac77e80295314e0dd><a role=button></a></label><a href=https://docs.freebsd.org/zh-tw/books/handbook/serialcomms/>章 26. 序列通訊</a><ul><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/serialcomms/#serial-synopsis>26.1. 概述</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/serialcomms/#serial>26.2. 序列術語與硬體</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/serialcomms/#term>26.3. 終端機</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/serialcomms/#dialup>26.4. 撥入服務</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/serialcomms/#dialout>26.5. 撥出服務</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/serialcomms/#serialconsole-setup>26.6. 設定序列 Console</a></li></ul></li><li><input type=checkbox id=chapter-95e4571c48bee1cced5e84a538d302e3 class=toggle>
<label class="icon cursor" for=chapter-95e4571c48bee1cced5e84a538d302e3><a role=button></a></label><a href=https://docs.freebsd.org/zh-tw/books/handbook/ppp-and-slip/>章 27. PPP</a><ul><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/ppp-and-slip/#ppp-and-slip-synopsis>27.1. 概述</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/ppp-and-slip/#userppp>27.2. 設定 PPP</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/ppp-and-slip/#ppp-troubleshoot>27.3. PPP 連線疑難排解</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/ppp-and-slip/#pppoe>27.4. 在乙太網路使用 PPP (PPPoE)</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/ppp-and-slip/#pppoa>27.5. 在 ATM 使用 PPP (PPPoA)</a></li></ul></li><li><input type=checkbox id=chapter-f089ac726c401c9b4bd5c34a295e11bb class=toggle>
<label class="icon cursor" for=chapter-f089ac726c401c9b4bd5c34a295e11bb><a role=button></a></label><a href=https://docs.freebsd.org/zh-tw/books/handbook/mail/>章 28. 電子郵件</a><ul><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/mail/#mail-synopsis>28.1. 概述</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/mail/#mail-using>28.2. 郵件組成</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/mail/#sendmail>28.3. Sendmail 設定檔</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/mail/#mail-changingmta>28.4. 更改郵件傳輸代理程式</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/mail/#mail-trouble>28.5. 疑難排解</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/mail/#mail-advanced>28.6. 進階主題</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/mail/#outgoing-only>28.7. 寄件設定</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/mail/#SMTP-dialup>28.8. 在撥號連線使用郵件</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/mail/#SMTP-Auth>28.9. SMTP 認證</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/mail/#mail-agents>28.10. 郵件使用者代理程式</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/mail/#mail-fetchmail>28.11. 使用 fetchmail</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/mail/#mail-procmail>28.12. 使用 procmail</a></li></ul></li><li><input type=checkbox id=chapter-6de4de3fe925639d4175ce4b6f8c1829 class=toggle>
<label class="icon cursor" for=chapter-6de4de3fe925639d4175ce4b6f8c1829><a role=button></a></label><a href=https://docs.freebsd.org/zh-tw/books/handbook/network-servers/>章 29. 網路伺服器</a><ul><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/network-servers/#network-servers-synopsis>29.1. 概述</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/network-servers/#network-inetd>29.2. inetd 超級伺服器</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/network-servers/#network-nfs>29.3. 網路檔案系統 (NFS)</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/network-servers/#network-nis>29.4. 網路資訊系統 (NIS)</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/network-servers/#network-ldap>29.5. 輕量級目錄存取協定 (LDAP)</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/network-servers/#network-dhcp>29.6. 動態主機設置協定 (DHCP)</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/network-servers/#network-dns>29.7. 網域名稱系統 (DNS)</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/network-servers/#network-apache>29.8. Apache HTTP 伺服器</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/network-servers/#network-ftp>29.9. 檔案傳輸協定 (FTP)</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/network-servers/#network-samba>29.10. Microsoft™Windows™ 用戶端檔案與列印服務 (Samba)</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/network-servers/#network-ntp>29.11. NTP 時間校對</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/network-servers/#network-iscsi>29.12. iSCSI Initiator 與 Target 設定</a></li></ul></li><li><input type=checkbox id=chapter-776d855c7b75e048f90b5c2c9b35ffe0 class=toggle>
<label class="icon cursor" for=chapter-776d855c7b75e048f90b5c2c9b35ffe0><a role=button></a></label><a href=https://docs.freebsd.org/zh-tw/books/handbook/firewalls/>章 30. 防火牆</a><ul><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/firewalls/#firewalls-intro>30.1. 概述</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/firewalls/#firewalls-concepts>30.2. 防火牆概念</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/firewalls/#firewalls-pf>30.3. PF</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/firewalls/#firewalls-ipfw>30.4. IPFW</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/firewalls/#firewalls-ipf>30.5. IPFILTER (IPF)</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/firewalls/#firewalls-blacklistd>30.6. Blacklistd</a></li></ul></li><li><input type=checkbox id=chapter-5b07f776a0e6155c1c89aa0d15610380 class=toggle checked>
<label class="icon cursor" for=chapter-5b07f776a0e6155c1c89aa0d15610380><a role=button></a></label><a href=https://docs.freebsd.org/zh-tw/books/handbook/advanced-networking/>章 31. 進階網路設定</a><ul><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/advanced-networking/#advanced-networking-synopsis>31.1. 概述</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/advanced-networking/#network-routing>31.2. 通訊閘與路由</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/advanced-networking/#network-wireless>31.3. 無線網路</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/advanced-networking/#network-usb-tethering>31.4. USB 網路共享</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/advanced-networking/#network-bluetooth>31.5. 藍牙</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/advanced-networking/#network-bridging>31.6. 橋接</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/advanced-networking/#network-aggregation>31.7. Link Aggregation 與容錯移轉</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/advanced-networking/#network-diskless>31.8. PXE 無磁碟作業</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/advanced-networking/#network-ipv6>31.9. IPv6</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/advanced-networking/#carp>31.10. 共用位址備援協定 (CARP)</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/advanced-networking/#network-vlan>31.11. VLANs</a></li></ul></li><li><input type=checkbox id=chapter-171a77aa9d067a1024f849470e1f33e8 class=toggle>
<label for=chapter-171a77aa9d067a1024f849470e1f33e8><a role=button></a></label><a href=https://docs.freebsd.org/zh-tw/books/handbook/partv/>部 V. 附錄</a></li><li><input type=checkbox id=chapter-8050f436a0a7986a4aaded93d8e49469 class=toggle>
<label class="icon cursor" for=chapter-8050f436a0a7986a4aaded93d8e49469><a role=button></a></label><a href=https://docs.freebsd.org/zh-tw/books/handbook/mirrors/>附錄 A. 取得 FreeBSD</a><ul><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/mirrors/#mirrors-cdrom>A.1. CD 與 DVD 合集</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/mirrors/#mirrors-ftp>A.2. FTP 站</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/mirrors/#svn>A.3. 使用 Subversion</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/mirrors/#mirrors-rsync>A.4. 使用 rsync</a></li></ul></li><li><input type=checkbox id=chapter-128b630a8f88f158e7027fe6c2184d21 class=toggle>
<label class="icon cursor" for=chapter-128b630a8f88f158e7027fe6c2184d21><a role=button></a></label><a href=https://docs.freebsd.org/zh-tw/books/handbook/bibliography/>附錄 B. 參考書目</a><ul><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/bibliography/#bibliography-freebsd>B.1. FreeBSD 相關書籍</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/bibliography/#bibliography-userguides>B.2. 使用指南</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/bibliography/#bibliography-adminguides>B.3. 管理指南</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/bibliography/#bibliography-programmers>B.4. 開發指南</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/bibliography/#bibliography-osinternals>B.5. 深入作業系統</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/bibliography/#bibliography-security>B.6. 安全性參考文獻</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/bibliography/#bibliography-hardware>B.7. 硬體參考文獻</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/bibliography/#bibliography-history>B.8. UNIX™ 歷史</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/bibliography/#bibliography-journals>B.9. 期刊與雜誌</a></li></ul></li><li><input type=checkbox id=chapter-8bbb8867c46dac315e2253945d8c18a8 class=toggle>
<label class="icon cursor" for=chapter-8bbb8867c46dac315e2253945d8c18a8><a role=button></a></label><a href=https://docs.freebsd.org/zh-tw/books/handbook/eresources/>附錄 C. 網路資源</a><ul><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/eresources/#eresources-www>C.1. 網站</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/eresources/#eresources-mail>C.2. 郵遞論壇 (Mailing List)</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/eresources/#eresources-news>C.3. Usenet 新聞群組</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/eresources/#eresources-web>C.4. 官方鏡像站</a></li></ul></li><li><input type=checkbox id=chapter-a80ea4f5a4480b8725422710f954ef36 class=toggle>
<label class="icon cursor" for=chapter-a80ea4f5a4480b8725422710f954ef36><a role=button></a></label><a href=https://docs.freebsd.org/zh-tw/books/handbook/pgpkeys/>附錄 D. OpenPGP 金鑰</a><ul><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/pgpkeys/#pgpkeys-officers>D.1. Officers</a></li></ul></li><li></li></ul></nav></div></aside><div class=book><div class=book-menu-mobile><label for=menu-control><span class=menu-control-button><i class="fa fa-list" aria-hidden=true title="Book menu"></i>
Book menu</span></label></div><h1 class=title>章 31. 進階網路設定</h1><div class="admonitionblock note"><p><i class="fa fa-exclamation-circle" aria-hidden=true></i>
This translation may be out of date. To help with the translations please access the <a href=https://translate-dev.freebsd.org/ target=_blank>FreeBSD translations instance</a>.</p></div><div class=toc-mobile><h3>目錄</h3><nav id=TableOfContents><ul><li><a href=#advanced-networking-synopsis>31.1. 概述</a></li><li><a href=#network-routing>31.2. 通訊閘與路由</a></li><li><a href=#network-wireless>31.3. 無線網路</a></li><li><a href=#network-usb-tethering>31.4. USB 網路共享</a></li><li><a href=#network-bluetooth>31.5. 藍牙</a></li><li><a href=#network-bridging>31.6. 橋接</a></li><li><a href=#network-aggregation>31.7. Link Aggregation 與容錯移轉</a></li><li><a href=#network-diskless>31.8. PXE 無磁碟作業</a></li><li><a href=#network-ipv6>31.9. IPv6</a></li><li><a href=#carp>31.10. 共用位址備援協定 (CARP)</a></li><li><a href=#network-vlan>31.11. VLANs</a></li></ul></nav></div><div class=book-content><div id=preamble><div class=sectionbody></div></div><div class=sect1><h2 id=advanced-networking-synopsis>31.1. 概述<a class=anchor href=#advanced-networking-synopsis></a></h2><div class=sectionbody><div class=paragraph><p>This chapter covers a number of advanced networking topics.</p></div><div class=paragraph><p>讀完這章，您將了解：</p></div><div class=ulist><ul><li><p>The basics of gateways and routes.</p></li><li><p>How to set up USB tethering.</p></li><li><p>How to set up IEEE™ 802.11 and Bluetooth™ devices.</p></li><li><p>How to make FreeBSD act as a bridge.</p></li><li><p>How to set up network PXE booting.</p></li><li><p>How to set up IPv6 on a FreeBSD machine.</p></li><li><p>How to enable and utilize the features of the Common Address Redundancy Protocol (CARP) in FreeBSD.</p></li><li><p>如何在 FreeBSD 上設定多個 VLAN。</p></li><li><p>Configure bluetooth headset.</p></li></ul></div><div class=paragraph><p>在開始閱讀這章之前，您需要：</p></div><div class=ulist><ul><li><p>Understand the basics of the <span class=filename>/etc/rc</span> scripts.</p></li><li><p>熟悉基本網路術語。</p></li><li><p>Know how to configure and install a new FreeBSD kernel (<a href=../kernelconfig/#kernelconfig>設定 FreeBSD 核心</a>).</p></li><li><p>了解如何安裝其他第三方軟體 (<a href=../ports/#ports>安裝應用程式：套件與 Port</a>)。</p></li></ul></div></div></div><div class=sect1><h2 id=network-routing>31.2. 通訊閘與路由<a class=anchor href=#network-routing></a></h2><div class=sectionbody><div class=paragraph><p><em>Routing</em> is the mechanism that allows a system to find the network path to another system. A <em>route</em> is a defined pair of addresses which represent the "destination" and a "gateway". The route indicates that when trying to get to the specified destination, send the packets through the specified gateway. There are three types of destinations: individual hosts, subnets, and "default". The "default route" is used if no other routes apply. There are also three types of gateways: individual hosts, interfaces, also called links, and Ethernet hardware (MAC) addresses. Known routes are stored in a routing table.</p></div><div class=paragraph><p>This section provides an overview of routing basics. It then demonstrates how to configure a FreeBSD system as a router and offers some troubleshooting tips.</p></div><div class=sect2><h3 id=network-routing-default>31.2.1. 路由基礎概念<a class=anchor href=#network-routing-default></a></h3><div class=paragraph><p>To view the routing table of a FreeBSD system, use <a href="https://man.freebsd.org/cgi/man.cgi?query=netstat&amp;sektion=1&amp;format=html">netstat(1)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% netstat <span class=nt>-r</span>
Routing tables

Internet:
Destination      Gateway            Flags     Refs     Use     Netif Expire
default          outside-gw         UGS        37      418       em0
localhost        localhost          UH          0      181       lo0
test0            0:e0:b5:36:cf:4f   UHLW        5    63288       re0     77
10.20.30.255     <span class=nb>link</span><span class=c>#1             UHLW        1     2421</span>
example.com      <span class=nb>link</span><span class=c>#1             UC          0        0</span>
host1            0:e0:a8:37:8:1e    UHLW        3     4601       lo0
host2            0:e0:a8:37:8:1e    UHLW        0        5       lo0 <span class=o>=&gt;</span>
host2.example.com <span class=nb>link</span><span class=c>#1            UC          0        0</span>
224              <span class=nb>link</span><span class=c>#1             UC          0        0</span></code></pre></div></div><div class=paragraph><p>The entries in this example are as follows:</p></div><div class=dlist><dl><dt class=hdlist1>default</dt><dd><p>The first route in this table specifies the <code>default</code> route. When the local system needs to make a connection to a remote host, it checks the routing table to determine if a known path exists. If the remote host matches an entry in the table, the system checks to see if it can connect using the interface specified in that entry.</p><div class=paragraph><p>If the destination does not match an entry, or if all known paths fail, the system uses the entry for the default route. For hosts on a local area network, the <code>Gateway</code> field in the default route is set to the system which has a direct connection to the Internet. When reading this entry, verify that the <code>Flags</code> column indicates that the gateway is usable (<code>UG</code>).</p></div><div class=paragraph><p>The default route for a machine which itself is functioning as the gateway to the outside world will be the gateway machine at the Internet Service Provider (ISP).</p></div></dd><dt class=hdlist1>localhost</dt><dd><p>The second route is the <code>localhost</code> route. The interface specified in the <code>Netif</code> column for <code>localhost</code> is <span class=filename>lo0</span>, also known as the loopback device. This indicates that all traffic for this destination should be internal, rather than sending it out over the network.</p></dd><dt class=hdlist1>MAC address</dt><dd><p>The addresses beginning with <code>0:e0:</code> are MAC addresses. FreeBSD will automatically identify any hosts, <code>test0</code> in the example, on the local Ethernet and add a route for that host over the Ethernet interface, <span class=filename>re0</span>. This type of route has a timeout, seen in the <code>Expire</code> column, which is used if the host does not respond in a specific amount of time. When this happens, the route to this host will be automatically deleted. These hosts are identified using the Routing Information Protocol (RIP), which calculates routes to local hosts based upon a shortest path determination.</p></dd><dt class=hdlist1>subnet</dt><dd><p>FreeBSD will automatically add subnet routes for the local subnet. In this example, <code>10.20.30.255</code> is the broadcast address for the subnet <code>10.20.30</code> and <code>example.com</code> is the domain name associated with that subnet. The designation <code>link#1</code> refers to the first Ethernet card in the machine.</p><div class=paragraph><p>Local network hosts and local subnets have their routes automatically configured by a daemon called <a href="https://man.freebsd.org/cgi/man.cgi?query=routed&amp;sektion=8&amp;format=html">routed(8)</a>. If it is not running, only routes which are statically defined by the administrator will exist.</p></div></dd><dt class=hdlist1>host</dt><dd><p>The <code>host1</code> line refers to the host by its Ethernet address. Since it is the sending host, FreeBSD knows to use the loopback interface (<span class=filename>lo0</span>) rather than the Ethernet interface.</p><div class=paragraph><p>The two <code>host2</code> lines represent aliases which were created using <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a>. The <code>⇒</code> symbol after the <span class=filename>lo0</span> interface says that an alias has been set in addition to the loopback address. Such routes only show up on the host that supports the alias and all other hosts on the local network will have a <code>link#1</code> line for such routes.</p></div></dd><dt class=hdlist1>224</dt><dd><p>The final line (destination subnet <code>224</code>) deals with multicasting.</p></dd></dl></div><div class=paragraph><p>Various attributes of each route can be seen in the <code>Flags</code> column. <a href=#routeflags>常見路由表標記</a> summarizes some of these flags and their meanings:</p></div><table id=routeflags class="tableblock frame-none grid-all stretch"><caption class=title>表 1. 常見路由表標記</caption><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">指令</th><th class="tableblock halign-left valign-top">用途</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>U</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>The route is active (up).</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>H</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>The route destination is a single host.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>G</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Send anything for this destination on to this gateway, which will figure out from there where to send it.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>S</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>This route was statically configured.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>C</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Clones a new route based upon this route for machines to connect to. This type of route is normally used for local networks.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>W</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>The route was auto-configured based upon a local area network (clone) route.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>L</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Route involves references to Ethernet (link) hardware.</p></td></tr></tbody></table><div class=paragraph><p>On a FreeBSD system, the default route can defined in <span class=filename>/etc/rc.conf</span> by specifying the IP address of the default gateway:</p></div><div class="literalblock programlisting"><div class=content><pre>defaultrouter=&#34;10.20.30.1&#34;</pre></div></div><div class=paragraph><p>It is also possible to manually add the route using <code>route</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># route add default 10.20.30.1</span></code></pre></div></div><div class=paragraph><p>Note that manually added routes will not survive a reboot. For more information on manual manipulation of network routing tables, refer to <a href="https://man.freebsd.org/cgi/man.cgi?query=route&amp;sektion=8&amp;format=html">route(8)</a>.</p></div></div><div class=sect2><h3 id=network-static-routes>31.2.2. 設定路由器使用靜態路由<a class=anchor href=#network-static-routes></a></h3><div class=paragraph><p>A FreeBSD system can be configured as the default gateway, or router, for a network if it is a dual-homed system. A dual-homed system is a host which resides on at least two different networks. Typically, each network is connected to a separate network interface, though IP aliasing can be used to bind multiple addresses, each on a different subnet, to one physical interface.</p></div><div class=paragraph><p>In order for the system to forward packets between interfaces, FreeBSD must be configured as a router. Internet standards and good engineering practice prevent the FreeBSD Project from enabling this feature by default, but it can be configured to start at boot by adding this line to <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>gateway_enable=&#34;YES&#34;          # Set to YES if this host will be a gateway</pre></div></div><div class=paragraph><p>To enable routing now, set the <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> variable <code>net.inet.ip.forwarding</code> to <code>1</code>. To stop routing, reset this variable to <code>0</code>.</p></div><div class=paragraph><p>The routing table of a router needs additional routes so it knows how to reach other networks. Routes can be either added manually using static routes or routes can be automatically learned using a routing protocol. Static routes are appropriate for small networks and this section describes how to add a static routing entry for a small network.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>For large networks, static routes quickly become unscalable. FreeBSD comes with the standard BSD routing daemon <a href="https://man.freebsd.org/cgi/man.cgi?query=routed&amp;sektion=8&amp;format=html">routed(8)</a>, which provides the routing protocols RIP, versions 1 and 2, and IRDP. Support for the BGP and OSPF routing protocols can be installed using the <a class=package href=https://cgit.freebsd.org/ports/tree/net/zebra/>net/zebra</a> package or port.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Consider the following network:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/advanced-networking/static-routes.png alt="static routes"></div></div><div class=paragraph><p>In this scenario, <code>RouterA</code> is a FreeBSD machine that is acting as a router to the rest of the Internet. It has a default route set to <code>10.0.0.1</code> which allows it to connect with the outside world. <code>RouterB</code> is already configured to use <code>192.168.1.1</code> as its default gateway.</p></div><div class=paragraph><p>Before adding any static routes, the routing table on <code>RouterA</code> looks like this:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% netstat <span class=nt>-nr</span>
Routing tables

Internet:
Destination        Gateway            Flags    Refs      Use  Netif  Expire
default            10.0.0.1           UGS         0    49378    xl0
127.0.0.1          127.0.0.1          UH          0        6    lo0
10.0.0.0/24        link1             UC          0        0    xl0
192.168.1.0/24     link2             UC          0        0    xl1</code></pre></div></div><div class=paragraph><p>With the current routing table, <code>RouterA</code> does not have a route to the <code>192.168.2.0/24</code> network. The following command adds the <code>Internal Net 2</code> network to <code>RouterA</code>'s routing table using <code>192.168.1.2</code> as the next hop:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># route add -net 192.168.2.0/24 192.168.1.2</span></code></pre></div></div><div class=paragraph><p>Now, <code>RouterA</code> can reach any host on the <code>192.168.2.0/24</code> network. However, the routing information will not persist if the FreeBSD system reboots. If a static route needs to be persistent, add it to <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre># Add Internal Net 2 as a persistent static route
static_routes=&#34;internalnet2&#34;
route_internalnet2=&#34;-net 192.168.2.0/24 192.168.1.2&#34;</pre></div></div><div class=paragraph><p>The <code>static_routes</code> configuration variable is a list of strings separated by a space, where each string references a route name. The variable <code><em>route_internalnet2</em></code> contains the static route for that route name.</p></div><div class=paragraph><p>Using more than one string in <code>static_routes</code> creates multiple static routes. The following shows an example of adding static routes for the <code>192.168.0.0/24</code> and <code>192.168.1.0/24</code> networks:</p></div><div class="literalblock programlisting"><div class=content><pre>static_routes=&#34;net1 net2&#34;
route_net1=&#34;-net 192.168.0.0/24 192.168.0.1&#34;
route_net2=&#34;-net 192.168.1.0/24 192.168.1.1&#34;</pre></div></div></div><div class=sect2><h3 id=network-routing-troubleshooting>31.2.3. 疑難排解<a class=anchor href=#network-routing-troubleshooting></a></h3><div class=paragraph><p>When an address space is assigned to a network, the service provider configures their routing tables so that all traffic for the network will be sent to the link for the site. But how do external sites know to send their packets to the network’s ISP?</p></div><div class=paragraph><p>There is a system that keeps track of all assigned address spaces and defines their point of connection to the Internet backbone, or the main trunk lines that carry Internet traffic across the country and around the world. Each backbone machine has a copy of a master set of tables, which direct traffic for a particular network to a specific backbone carrier, and from there down the chain of service providers until it reaches a particular network.</p></div><div class=paragraph><p>It is the task of the service provider to advertise to the backbone sites that they are the point of connection, and thus the path inward, for a site. This is known as route propagation.</p></div><div class=paragraph><p>Sometimes, there is a problem with route propagation and some sites are unable to connect. Perhaps the most useful command for trying to figure out where routing is breaking down is <code>traceroute</code>. It is useful when <code>ping</code> fails.</p></div><div class=paragraph><p>When using <code>traceroute</code>, include the address of the remote host to connect to. The output will show the gateway hosts along the path of the attempt, eventually either reaching the target host, or terminating because of a lack of connection. For more information, refer to <a href="https://man.freebsd.org/cgi/man.cgi?query=traceroute&amp;sektion=8&amp;format=html">traceroute(8)</a>.</p></div></div><div class=sect2><h3 id=network-routing-multicast>31.2.4. 群播 (Multicast) 注意事項<a class=anchor href=#network-routing-multicast></a></h3><div class=paragraph><p>FreeBSD natively supports both multicast applications and multicast routing. Multicast applications do not require any special configuration in order to run on FreeBSD. Support for multicast routing requires that the following option be compiled into a custom kernel:</p></div><div class="literalblock programlisting"><div class=content><pre>options MROUTING</pre></div></div><div class=paragraph><p>The multicast routing daemon, mrouted can be installed using the <a class=package href=https://cgit.freebsd.org/ports/tree/net/mrouted/>net/mrouted</a> package or port. This daemon implements the DVMRP multicast routing protocol and is configured by editing <span class=filename>/usr/local/etc/mrouted.conf</span> in order to set up the tunnels and DVMRP. The installation of mrouted also installs map-mbone and mrinfo, as well as their associated man pages. Refer to these for configuration examples.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>DVMRP has largely been replaced by the PIM protocol in many multicast installations. Refer to <a href="https://man.freebsd.org/cgi/man.cgi?query=pim&amp;sektion=4&amp;format=html">pim(4)</a> for more information.</p></div></td></tr></tbody></table></div></div></div></div><div class=sect1><h2 id=network-wireless>31.3. 無線網路<a class=anchor href=#network-wireless></a></h2><div class=sectionbody><div class=sect2><h3 id=_無線網路基礎>31.3.1. 無線網路基礎<a class=anchor href=#_無線網路基礎></a></h3><div class=paragraph><p>Most wireless networks are based on the IEEE™ 802.11 standards. A basic wireless network consists of multiple stations communicating with radios that broadcast in either the 2.4GHz or 5GHz band, though this varies according to the locale and is also changing to enable communication in the 2.3GHz and 4.9GHz ranges.</p></div><div class=paragraph><p>802.11 networks are organized in two ways. In <em>infrastructure mode</em>, one station acts as a master with all the other stations associating to it, the network is known as a BSS, and the master station is termed an access point (AP). In a BSS, all communication passes through the AP; even when one station wants to communicate with another wireless station, messages must go through the AP. In the second form of network, there is no master and stations communicate directly. This form of network is termed an IBSS and is commonly known as an <em>ad-hoc network</em>.</p></div><div class=paragraph><p>802.11 networks were first deployed in the 2.4GHz band using protocols defined by the IEEE™ 802.11 and 802.11b standard. These specifications include the operating frequencies and the MAC layer characteristics, including framing and transmission rates, as communication can occur at various rates. Later, the 802.11a standard defined operation in the 5GHz band, including different signaling mechanisms and higher transmission rates. Still later, the 802.11g standard defined the use of 802.11a signaling and transmission mechanisms in the 2.4GHz band in such a way as to be backwards compatible with 802.11b networks.</p></div><div class=paragraph><p>Separate from the underlying transmission techniques, 802.11 networks have a variety of security mechanisms. The original 802.11 specifications defined a simple security protocol called WEP. This protocol uses a fixed pre-shared key and the RC4 cryptographic cipher to encode data transmitted on a network. Stations must all agree on the fixed key in order to communicate. This scheme was shown to be easily broken and is now rarely used except to discourage transient users from joining networks. Current security practice is given by the IEEE™ 802.11i specification that defines new cryptographic ciphers and an additional protocol to authenticate stations to an access point and exchange keys for data communication. Cryptographic keys are periodically refreshed and there are mechanisms for detecting and countering intrusion attempts. Another security protocol specification commonly used in wireless networks is termed WPA, which was a precursor to 802.11i. WPA specifies a subset of the requirements found in 802.11i and is designed for implementation on legacy hardware. Specifically, WPA requires only the TKIP cipher that is derived from the original WEP cipher. 802.11i permits use of TKIP but also requires support for a stronger cipher, AES-CCM, for encrypting data. The AES cipher was not required in WPA because it was deemed too computationally costly to be implemented on legacy hardware.</p></div><div class=paragraph><p>The other standard to be aware of is 802.11e. It defines protocols for deploying multimedia applications, such as streaming video and voice over IP (VoIP), in an 802.11 network. Like 802.11i, 802.11e also has a precursor specification termed WME (later renamed WMM) that has been defined by an industry group as a subset of 802.11e that can be deployed now to enable multimedia applications while waiting for the final ratification of 802.11e. The most important thing to know about 802.11e and WME/WMM is that it enables prioritized traffic over a wireless network through Quality of Service (QoS) protocols and enhanced media access protocols. Proper implementation of these protocols enables high speed bursting of data and prioritized traffic flow.</p></div><div class=paragraph><p>FreeBSD supports networks that operate using 802.11a, 802.11b, and 802.11g. The WPA and 802.11i security protocols are likewise supported (in conjunction with any of 11a, 11b, and 11g) and QoS and traffic prioritization required by the WME/WMM protocols are supported for a limited set of wireless devices.</p></div></div><div class=sect2><h3 id=network-wireless-quick-start>31.3.2. 快速開始<a class=anchor href=#network-wireless-quick-start></a></h3><div class=paragraph><p>Connecting a computer to an existing wireless network is a very common situation. This procedure shows the steps required.</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Obtain the SSID (Service Set Identifier) and PSK (Pre-Shared Key) for the wireless network from the network administrator.</p></li><li><p>Identify the wireless adapter. The FreeBSD <span class=filename>GENERIC</span> kernel includes drivers for many common wireless adapters. If the wireless adapter is one of those models, it will be shown in the output from <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a>:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ifconfig | <span class=nb>grep</span> <span class=nt>-B3</span> <span class=nt>-i</span> wireless</code></pre></div></div><div class=paragraph><p>On FreeBSD 11 or higher, use this command instead:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% sysctl net.wlan.devices</code></pre></div></div><div class=paragraph><p>If a wireless adapter is not listed, an additional kernel module might be required, or it might be a model not supported by FreeBSD.</p></div><div class=paragraph><p>This example shows the Atheros <code>ath0</code> wireless adapter.</p></div></li><li><p>Add an entry for this network to <span class=filename>/etc/wpa_supplicant.conf</span>. If the file does not exist, create it. Replace <em>myssid</em> and <em>mypsk</em> with the SSID and PSK provided by the network administrator.</p><div class="literalblock programlisting"><div class=content><pre>network={
	ssid=&#34;myssid&#34;
	psk=&#34;mypsk&#34;
}</pre></div></div></li><li><p>Add entries to <span class=filename>/etc/rc.conf</span> to configure the network on startup:</p><div class="literalblock programlisting"><div class=content><pre>wlans_ath0=&#34;wlan0&#34;
ifconfig_wlan0=&#34;WPA SYNCDHCP&#34;</pre></div></div></li><li><p>Restart the computer, or restart the network service to connect to the network:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service netif restart</span></code></pre></div></div></li></ol></div></div></div></div><div class=sect2><h3 id=network-wireless-basic>31.3.3. 基礎設定<a class=anchor href=#network-wireless-basic></a></h3><div class=sect3><h4 id=_核心設定>31.3.3.1. 核心設定<a class=anchor href=#_核心設定></a></h4><div class=paragraph><p>To use wireless networking, a wireless networking card is needed and the kernel needs to be configured with the appropriate wireless networking support. The kernel is separated into multiple modules so that only the required support needs to be configured.</p></div><div class=paragraph><p>The most commonly used wireless devices are those that use parts made by Atheros. These devices are supported by <a href="https://man.freebsd.org/cgi/man.cgi?query=ath&amp;sektion=4&amp;format=html">ath(4)</a> and require the following line to be added to <span class=filename>/boot/loader.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>if_ath_load=&#34;YES&#34;</pre></div></div><div class=paragraph><p>The Atheros driver is split up into three separate pieces: the driver (<a href="https://man.freebsd.org/cgi/man.cgi?query=ath&amp;sektion=4&amp;format=html">ath(4)</a>), the hardware support layer that handles chip-specific functions (<a href="https://man.freebsd.org/cgi/man.cgi?query=ath_hal&amp;sektion=4&amp;format=html">ath_hal(4)</a>), and an algorithm for selecting the rate for transmitting frames. When this support is loaded as kernel modules, any dependencies are automatically handled. To load support for a different type of wireless device, specify the module for that device. This example is for devices based on the Intersil Prism parts (<a href="https://man.freebsd.org/cgi/man.cgi?query=wi&amp;sektion=4&amp;format=html">wi(4)</a>) driver:</p></div><div class="literalblock programlisting"><div class=content><pre>if_wi_load=&#34;YES&#34;</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>The examples in this section use an <a href="https://man.freebsd.org/cgi/man.cgi?query=ath&amp;sektion=4&amp;format=html">ath(4)</a> device and the device name in the examples must be changed according to the configuration. A list of available wireless drivers and supported adapters can be found in the FreeBSD Hardware Notes, available on the <a href=https://www.FreeBSD.org/releases/>Release Information</a> page of the FreeBSD website. If a native FreeBSD driver for the wireless device does not exist, it may be possible to use the Windows™ driver with the help of the <a href=../config/#config-network-ndis>NDIS</a> driver wrapper.</p></div></td></tr></tbody></table></div><div class=paragraph><p>In addition, the modules that implement cryptographic support for the security protocols to use must be loaded. These are intended to be dynamically loaded on demand by the <a href="https://man.freebsd.org/cgi/man.cgi?query=wlan&amp;sektion=4&amp;format=html">wlan(4)</a> module, but for now they must be manually configured. The following modules are available: <a href="https://man.freebsd.org/cgi/man.cgi?query=wlan_wep&amp;sektion=4&amp;format=html">wlan_wep(4)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=wlan_ccmp&amp;sektion=4&amp;format=html">wlan_ccmp(4)</a>, and <a href="https://man.freebsd.org/cgi/man.cgi?query=wlan_tkip&amp;sektion=4&amp;format=html">wlan_tkip(4)</a>. The <a href="https://man.freebsd.org/cgi/man.cgi?query=wlan_ccmp&amp;sektion=4&amp;format=html">wlan_ccmp(4)</a> and <a href="https://man.freebsd.org/cgi/man.cgi?query=wlan_tkip&amp;sektion=4&amp;format=html">wlan_tkip(4)</a> drivers are only needed when using the WPA or 802.11i security protocols. If the network does not use encryption, <a href="https://man.freebsd.org/cgi/man.cgi?query=wlan_wep&amp;sektion=4&amp;format=html">wlan_wep(4)</a> support is not needed. To load these modules at boot time, add the following lines to <span class=filename>/boot/loader.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>wlan_wep_load=&#34;YES&#34;
wlan_ccmp_load=&#34;YES&#34;
wlan_tkip_load=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Once this information has been added to <span class=filename>/boot/loader.conf</span>, reboot the FreeBSD box. Alternately, load the modules by hand using <a href="https://man.freebsd.org/cgi/man.cgi?query=kldload&amp;sektion=8&amp;format=html">kldload(8)</a>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>For users who do not want to use modules, it is possible to compile these drivers into the kernel by adding the following lines to a custom kernel configuration file:</p></div><div class="literalblock programlisting"><div class=content><pre>device wlan              # 802.11 support
device wlan_wep          # 802.11 WEP support
device wlan_ccmp         # 802.11 CCMP support
device wlan_tkip         # 802.11 TKIP support
device wlan_amrr         # AMRR transmit rate control algorithm
device ath               # Atheros pci/cardbus NIC&#39;s
device ath_hal           # pci/cardbus chip support
options AH_SUPPORT_AR5416 # enable AR5416 tx/rx descriptors
device ath_rate_sample   # SampleRate tx rate control for ath</pre></div></div><div class=paragraph><p>With this information in the kernel configuration file, recompile the kernel and reboot the FreeBSD machine.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Information about the wireless device should appear in the boot messages, like this:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>ath0: &lt;Atheros 5212&gt; mem 0x88000000-0x8800ffff irq 11 at device 0.0 on cardbus1
ath0: <span class=o>[</span>ITHREAD]
ath0: AR2413 mac 7.9 RF2413 phy 4.5</code></pre></div></div></div><div class=sect3><h4 id=_設定正確的區域>31.3.3.2. 設定正確的區域<a class=anchor href=#_設定正確的區域></a></h4><div class=paragraph><p>Since the regulatory situation is different in various parts of the world, it is necessary to correctly set the domains that apply to your location to have the correct information about what channels can be used.</p></div><div class=paragraph><p>The available region definitions can be found in <span class=filename>/etc/regdomain.xml</span>. To set the data at runtime, use <code>ifconfig</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0 regdomain ETSI country AT</span></code></pre></div></div><div class=paragraph><p>To persist the settings, add it to <span class=filename>/etc/rc.conf</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysrc create_args_wlan0=&#34;country AT regdomain ETSI&#34;</span></code></pre></div></div></div></div><div class=sect2><h3 id=_主從式_infrastructure>31.3.4. 主從式 (Infrastructure)<a class=anchor href=#_主從式_infrastructure></a></h3><div class=paragraph><p>Infrastructure (BSS) mode is the mode that is typically used. In this mode, a number of wireless access points are connected to a wired network. Each wireless network has its own name, called the SSID. Wireless clients connect to the wireless access points.</p></div><div class=sect3><h4 id=_freebsd_客戶端>31.3.4.1. FreeBSD 客戶端<a class=anchor href=#_freebsd_客戶端></a></h4><div class=sect4><h5 id=_如何尋找存取點>31.3.4.1.1. 如何尋找存取點<a class=anchor href=#_如何尋找存取點></a></h5><div class=paragraph><p>To scan for available networks, use <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a>. This request may take a few moments to complete as it requires the system to switch to each available wireless frequency and probe for available access points. Only the superuser can initiate a scan:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0 create wlandev ath0</span>
<span class=c># ifconfig wlan0 up scan</span>
SSID/MESH ID    BSSID              CHAN RATE   S:N     INT CAPS
dlinkap         00:13:46:49:41:76   11   54M <span class=nt>-90</span>:96   100 EPS  WPA WME
freebsdap       00:11:95:c3:0d:ac    1   54M <span class=nt>-83</span>:96   100 EPS  WPA</code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>The interface must be <code>up</code> before it can scan. Subsequent scan requests do not require the interface to be marked as up again.</p></div></td></tr></tbody></table></div><div class=paragraph><p>The output of a scan request lists each BSS/IBSS network found. Besides listing the name of the network, the <code>SSID</code>, the output also shows the <code>BSSID</code>, which is the MAC address of the access point. The <code>CAPS</code> field identifies the type of each network and the capabilities of the stations operating there:</p></div><table class="tableblock frame-none grid-all stretch"><caption class=title>表 2. 站台功能代號</caption><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">功能代號</th><th class="tableblock halign-left valign-top">意義</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>E</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Extended Service Set (ESS). Indicates that the station is part of an infrastructure network rather than an IBSS/ad-hoc network.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>I</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>IBSS/ad-hoc network. Indicates that the station is part of an ad-hoc network rather than an ESS network.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>P</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Privacy. Encryption is required for all data frames exchanged within the BSS using cryptographic means such as WEP, TKIP or AES-CCMP.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>S</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Short Preamble. Indicates that the network is using short preambles, defined in 802.11b High Rate/DSSS PHY, and utilizes a 56 bit sync field rather than the 128 bit field used in long preamble mode.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>s</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Short slot time. Indicates that the 802.11g network is using a short slot time because there are no legacy (802.11b) stations present.</p></td></tr></tbody></table><div class=paragraph><p>One can also display the current list of known networks with:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0 list scan</span></code></pre></div></div><div class=paragraph><p>This information may be updated automatically by the adapter or manually with a <code>scan</code> request. Old data is automatically removed from the cache, so over time this list may shrink unless more scans are done.</p></div></div><div class=sect4><h5 id=_基礎設定>31.3.4.1.2. 基礎設定<a class=anchor href=#_基礎設定></a></h5><div class=paragraph><p>This section provides a simple example of how to make the wireless network adapter work in FreeBSD without encryption. Once familiar with these concepts, it is strongly recommend to use <a href=#network-wireless-wpa>WPA</a> to set up the wireless network.</p></div><div class=paragraph><p>There are three basic steps to configure a wireless network: select an access point, authenticate the station, and configure an IP address. The following sections discuss each step.</p></div><div class=sect5><h6 id=_選擇存取點>31.3.4.1.2.1. 選擇存取點<a class=anchor href=#_選擇存取點></a></h6><div class=paragraph><p>Most of the time, it is sufficient to let the system choose an access point using the builtin heuristics. This is the default behavior when an interface is marked as up or it is listed in <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>wlans_ath0=&#34;wlan0&#34;
ifconfig_wlan0=&#34;DHCP&#34;</pre></div></div><div class=paragraph><p>If there are multiple access points, a specific one can be selected by its SSID:</p></div><div class="literalblock programlisting"><div class=content><pre>wlans_ath0=&#34;wlan0&#34;
ifconfig_wlan0=&#34;ssid your_ssid_here DHCP&#34;</pre></div></div><div class=paragraph><p>In an environment where there are multiple access points with the same SSID, which is often done to simplify roaming, it may be necessary to associate to one specific device. In this case, the BSSID of the access point can be specified, with or without the SSID:</p></div><div class="literalblock programlisting"><div class=content><pre>wlans_ath0=&#34;wlan0&#34;
ifconfig_wlan0=&#34;ssid your_ssid_here bssid xx:xx:xx:xx:xx:xx DHCP&#34;</pre></div></div><div class=paragraph><p>There are other ways to constrain the choice of an access point, such as limiting the set of frequencies the system will scan on. This may be useful for a multi-band wireless card as scanning all the possible channels can be time-consuming. To limit operation to a specific band, use the <code>mode</code> parameter:</p></div><div class="literalblock programlisting"><div class=content><pre>wlans_ath0=&#34;wlan0&#34;
ifconfig_wlan0=&#34;mode 11g ssid your_ssid_here DHCP&#34;</pre></div></div><div class=paragraph><p>This example will force the card to operate in 802.11g, which is defined only for 2.4GHz frequencies so any 5GHz channels will not be considered. This can also be achieved with the <code>channel</code> parameter, which locks operation to one specific frequency, and the <code>chanlist</code> parameter, to specify a list of channels for scanning. More information about these parameters can be found in <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a>.</p></div></div><div class=sect5><h6 id=_認證>31.3.4.1.2.2. 認證<a class=anchor href=#_認證></a></h6><div class=paragraph><p>Once an access point is selected, the station needs to authenticate before it can pass data. Authentication can happen in several ways. The most common scheme, open authentication, allows any station to join the network and communicate. This is the authentication to use for test purposes the first time a wireless network is setup. Other schemes require cryptographic handshakes to be completed before data traffic can flow, either using pre-shared keys or secrets, or more complex schemes that involve backend services such as RADIUS. Open authentication is the default setting. The next most common setup is WPA-PSK, also known as WPA Personal, which is described in <a href=#network-wireless-wpa-wpa-psk>WPA-PSK</a>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>If using an Apple™AirPort™ Extreme base station for an access point, shared-key authentication together with a WEP key needs to be configured. This can be configured in <span class=filename>/etc/rc.conf</span> or by using <a href="https://man.freebsd.org/cgi/man.cgi?query=wpa_supplicant&amp;sektion=8&amp;format=html">wpa_supplicant(8)</a>. For a single AirPort™ base station, access can be configured with:</p></div><div class="literalblock programlisting"><div class=content><pre>wlans_ath0=&#34;wlan0&#34;
ifconfig_wlan0=&#34;authmode shared wepmode on weptxkey 1 wepkey 01234567 DHCP&#34;</pre></div></div><div class=paragraph><p>In general, shared key authentication should be avoided because it uses the WEP key material in a highly-constrained manner, making it even easier to crack the key. If WEP must be used for compatibility with legacy devices, it is better to use WEP with <code>open</code> authentication. More information regarding WEP can be found in <a href=#network-wireless-wep>WEP</a>.</p></div></td></tr></tbody></table></div></div><div class=sect5><h6 id=_使用_dhcp_取得_ip_位址>31.3.4.1.2.3. 使用 DHCP 取得 IP 位址<a class=anchor href=#_使用_dhcp_取得_ip_位址></a></h6><div class=paragraph><p>Once an access point is selected and the authentication parameters are set, an IP address must be obtained in order to communicate. Most of the time, the IP address is obtained via DHCP. To achieve that, edit <span class=filename>/etc/rc.conf</span> and add <code>DHCP</code> to the configuration for the device:</p></div><div class="literalblock programlisting"><div class=content><pre>wlans_ath0=&#34;wlan0&#34;
ifconfig_wlan0=&#34;DHCP&#34;</pre></div></div><div class=paragraph><p>The wireless interface is now ready to bring up:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service netif start</span></code></pre></div></div><div class=paragraph><p>Once the interface is running, use <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a> to see the status of the interface <span class=filename>ath0</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0</span>
wlan0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
        ether 00:11:95:d5:43:62
        inet 192.168.1.100 netmask 0xffffff00 broadcast 192.168.1.255
        media: IEEE 802.11 Wireless Ethernet OFDM/54Mbps mode 11g
        status: associated
        ssid dlinkap channel 11 <span class=o>(</span>2462 Mhz 11g<span class=o>)</span> bssid 00:13:46:49:41:76
        country US ecm authmode OPEN privacy OFF txpower 21.5 bmiss 7
        scanvalid 60 bgscan bgscanintvl 300 bgscanidle 250 roam:rssi 7
        roam:rate 5 protmode CTS wme burst</code></pre></div></div><div class=paragraph><p>The <code>status: associated</code> line means that it is connected to the wireless network. The <code>bssid 00:13:46:49:41:76</code> is the MAC address of the access point and <code>authmode OPEN</code> indicates that the communication is not encrypted.</p></div></div><div class=sect5><h6 id=_靜態_ip_位址>31.3.4.1.2.4. 靜態 IP 位址<a class=anchor href=#_靜態_ip_位址></a></h6><div class=paragraph><p>If an IP address cannot be obtained from a DHCP server, set a fixed IP address. Replace the <code>DHCP</code> keyword shown above with the address information. Be sure to retain any other parameters for selecting the access point:</p></div><div class="literalblock programlisting"><div class=content><pre>wlans_ath0=&#34;wlan0&#34;
ifconfig_wlan0=&#34;inet 192.168.1.100 netmask 255.255.255.0 ssid your_ssid_here&#34;</pre></div></div></div></div><div class=sect4><h5 id=network-wireless-wpa>31.3.4.1.3. WPA<a class=anchor href=#network-wireless-wpa></a></h5><div class=paragraph><p>Wi-Fi Protected Access (WPA) is a security protocol used together with 802.11 networks to address the lack of proper authentication and the weakness of WEP. WPA leverages the 802.1X authentication protocol and uses one of several ciphers instead of WEP for data integrity. The only cipher required by WPA is the Temporary Key Integrity Protocol (TKIP). TKIP is a cipher that extends the basic RC4 cipher used by WEP by adding integrity checking, tamper detection, and measures for responding to detected intrusions. TKIP is designed to work on legacy hardware with only software modification. It represents a compromise that improves security but is still not entirely immune to attack. WPA also specifies the AES-CCMP cipher as an alternative to TKIP, and that is preferred when possible. For this specification, the term WPA2 or RSN is commonly used.</p></div><div class=paragraph><p>WPA defines authentication and encryption protocols. Authentication is most commonly done using one of two techniques: by 802.1X and a backend authentication service such as RADIUS, or by a minimal handshake between the station and the access point using a pre-shared secret. The former is commonly termed WPA Enterprise and the latter is known as WPA Personal. Since most people will not set up a RADIUS backend server for their wireless network, WPA-PSK is by far the most commonly encountered configuration for WPA.</p></div><div class=paragraph><p>The control of the wireless connection and the key negotiation or authentication with a server is done using <a href="https://man.freebsd.org/cgi/man.cgi?query=wpa_supplicant&amp;sektion=8&amp;format=html">wpa_supplicant(8)</a>. This program requires a configuration file, <span class=filename>/etc/wpa_supplicant.conf</span>, to run. More information regarding this file can be found in <a href="https://man.freebsd.org/cgi/man.cgi?query=wpa_supplicant.conf&amp;sektion=5&amp;format=html">wpa_supplicant.conf(5)</a>.</p></div><div class=sect5><h6 id=network-wireless-wpa-wpa-psk>31.3.4.1.3.1. WPA-PSK<a class=anchor href=#network-wireless-wpa-wpa-psk></a></h6><div class=paragraph><p>WPA-PSK, also known as WPA Personal, is based on a pre-shared key (PSK) which is generated from a given password and used as the master key in the wireless network. This means every wireless user will share the same key. WPA-PSK is intended for small networks where the use of an authentication server is not possible or desired.</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Always use strong passwords that are sufficiently long and made from a rich alphabet so that they will not be easily guessed or attacked.</p></div></td></tr></tbody></table></div><div class=paragraph><p>The first step is the configuration of <span class=filename>/etc/wpa_supplicant.conf</span> with the SSID and the pre-shared key of the network:</p></div><div class="literalblock programlisting"><div class=content><pre>network={
  ssid=&#34;freebsdap&#34;
  psk=&#34;freebsdmall&#34;
}</pre></div></div><div class=paragraph><p>Then, in <span class=filename>/etc/rc.conf</span>, indicate that the wireless device configuration will be done with WPA and the IP address will be obtained with DHCP:</p></div><div class="literalblock programlisting"><div class=content><pre>wlans_ath0=&#34;wlan0&#34;
ifconfig_wlan0=&#34;WPA DHCP&#34;</pre></div></div><div class=paragraph><p>Then, bring up the interface:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service netif start</span>
Starting wpa_supplicant.
DHCPDISCOVER on wlan0 to 255.255.255.255 port 67 interval 5
DHCPDISCOVER on wlan0 to 255.255.255.255 port 67 interval 6
DHCPOFFER from 192.168.0.1
DHCPREQUEST on wlan0 to 255.255.255.255 port 67
DHCPACK from 192.168.0.1
bound to 192.168.0.254 <span class=nt>--</span> renewal <span class=k>in </span>300 seconds.
wlan0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
      ether 00:11:95:d5:43:62
      inet 192.168.0.254 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet OFDM/36Mbps mode 11g
      status: associated
      ssid freebsdap channel 1 <span class=o>(</span>2412 Mhz 11g<span class=o>)</span> bssid 00:11:95:c3:0d:ac
      country US ecm authmode WPA2/802.11i privacy ON deftxkey UNDEF
      AES-CCM 3:128-bit txpower 21.5 bmiss 7 scanvalid 450 bgscan
      bgscanintvl 300 bgscanidle 250 roam:rssi 7 roam:rate 5 protmode CTS
      wme burst roaming MANUAL</code></pre></div></div><div class=paragraph><p>Or, try to configure the interface manually using the information in <span class=filename>/etc/wpa_supplicant.conf</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># wpa_supplicant -i wlan0 -c /etc/wpa_supplicant.conf</span>
Trying to associate with 00:11:95:c3:0d:ac <span class=o>(</span><span class=nv>SSID</span><span class=o>=</span><span class=s1>&#39;freebsdap&#39;</span> <span class=nv>freq</span><span class=o>=</span>2412 MHz<span class=o>)</span>
Associated with 00:11:95:c3:0d:ac
WPA: Key negotiation completed with 00:11:95:c3:0d:ac <span class=o>[</span><span class=nv>PTK</span><span class=o>=</span>CCMP <span class=nv>GTK</span><span class=o>=</span>CCMP]
CTRL-EVENT-CONNECTED - Connection to 00:11:95:c3:0d:ac completed <span class=o>(</span>auth<span class=o>)</span> <span class=o>[</span><span class=nb>id</span><span class=o>=</span>0 <span class=nv>id_str</span><span class=o>=]</span></code></pre></div></div><div class=paragraph><p>The next operation is to launch <a href="https://man.freebsd.org/cgi/man.cgi?query=dhclient&amp;sektion=8&amp;format=html">dhclient(8)</a> to get the IP address from the DHCP server:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dhclient wlan0</span>
DHCPREQUEST on wlan0 to 255.255.255.255 port 67
DHCPACK from 192.168.0.1
bound to 192.168.0.254 <span class=nt>--</span> renewal <span class=k>in </span>300 seconds.
<span class=c># ifconfig wlan0</span>
wlan0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
      ether 00:11:95:d5:43:62
      inet 192.168.0.254 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet OFDM/36Mbps mode 11g
      status: associated
      ssid freebsdap channel 1 <span class=o>(</span>2412 Mhz 11g<span class=o>)</span> bssid 00:11:95:c3:0d:ac
      country US ecm authmode WPA2/802.11i privacy ON deftxkey UNDEF
      AES-CCM 3:128-bit txpower 21.5 bmiss 7 scanvalid 450 bgscan
      bgscanintvl 300 bgscanidle 250 roam:rssi 7 roam:rate 5 protmode CTS
      wme burst roaming MANUAL</code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>If <span class=filename>/etc/rc.conf</span> has an <code>ifconfig_wlan0="DHCP"</code> entry, <a href="https://man.freebsd.org/cgi/man.cgi?query=dhclient&amp;sektion=8&amp;format=html">dhclient(8)</a> will be launched automatically after <a href="https://man.freebsd.org/cgi/man.cgi?query=wpa_supplicant&amp;sektion=8&amp;format=html">wpa_supplicant(8)</a> associates with the access point.</p></div></td></tr></tbody></table></div><div class=paragraph><p>If DHCP is not possible or desired, set a static IP address after <a href="https://man.freebsd.org/cgi/man.cgi?query=wpa_supplicant&amp;sektion=8&amp;format=html">wpa_supplicant(8)</a> has authenticated the station:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0 inet 192.168.0.100 netmask 255.255.255.0</span>
<span class=c># ifconfig wlan0</span>
wlan0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
      ether 00:11:95:d5:43:62
      inet 192.168.0.100 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet OFDM/36Mbps mode 11g
      status: associated
      ssid freebsdap channel 1 <span class=o>(</span>2412 Mhz 11g<span class=o>)</span> bssid 00:11:95:c3:0d:ac
      country US ecm authmode WPA2/802.11i privacy ON deftxkey UNDEF
      AES-CCM 3:128-bit txpower 21.5 bmiss 7 scanvalid 450 bgscan
      bgscanintvl 300 bgscanidle 250 roam:rssi 7 roam:rate 5 protmode CTS
      wme burst roaming MANUAL</code></pre></div></div><div class=paragraph><p>When DHCP is not used, the default gateway and the nameserver also have to be manually set:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># route add default your_default_router</span>
<span class=c># echo &#34;nameserver your_DNS_server&#34; &gt;&gt; /etc/resolv.conf</span></code></pre></div></div></div><div class=sect5><h6 id=network-wireless-wpa-eap-tls>31.3.4.1.3.2. WPA 加上 EAP-TLS<a class=anchor href=#network-wireless-wpa-eap-tls></a></h6><div class=paragraph><p>The second way to use WPA is with an 802.1X backend authentication server. In this case, WPA is called WPA Enterprise to differentiate it from the less secure WPA Personal. Authentication in WPA Enterprise is based on the Extensible Authentication Protocol (EAP).</p></div><div class=paragraph><p>EAP does not come with an encryption method. Instead, EAP is embedded inside an encrypted tunnel. There are many EAP authentication methods, but EAP-TLS, EAP-TTLS, and EAP-PEAP are the most common.</p></div><div class=paragraph><p>EAP with Transport Layer Security (EAP-TLS) is a well-supported wireless authentication protocol since it was the first EAP method to be certified by the <a href=http://www.wi-fi.org/>Wi-Fi Alliance</a>. EAP-TLS requires three certificates to run: the certificate of the Certificate Authority (CA) installed on all machines, the server certificate for the authentication server, and one client certificate for each wireless client. In this EAP method, both the authentication server and wireless client authenticate each other by presenting their respective certificates, and then verify that these certificates were signed by the organization’s CA.</p></div><div class=paragraph><p>As previously, the configuration is done via <span class=filename>/etc/wpa_supplicant.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>network={
  ssid=&#34;freebsdap&#34; <i class=conum data-value=1></i><b>(1)</b>
  proto=RSN  <i class=conum data-value=2></i><b>(2)</b>
  key_mgmt=WPA-EAP <i class=conum data-value=3></i><b>(3)</b>
  eap=TLS <i class=conum data-value=4></i><b>(4)</b>
  identity=&#34;loader&#34; <i class=conum data-value=5></i><b>(5)</b>
  ca_cert=&#34;/etc/certs/cacert.pem&#34; <i class=conum data-value=6></i><b>(6)</b>
  client_cert=&#34;/etc/certs/clientcert.pem&#34; <i class=conum data-value=7></i><b>(7)</b>
  private_key=&#34;/etc/certs/clientkey.pem&#34; <i class=conum data-value=8></i><b>(8)</b>
  private_key_passwd=&#34;freebsdmallclient&#34; <i class=conum data-value=9></i><b>(9)</b>
}</pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>This field indicates the network name (SSID).</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td>This example uses the RSN IEEE™ 802.11i protocol, also known as WPA2.</td></tr><tr><td><i class=conum data-value=3></i><b>3</b></td><td>The <code>key_mgmt</code> line refers to the key management protocol to use. In this example, it is WPA using EAP authentication.</td></tr><tr><td><i class=conum data-value=4></i><b>4</b></td><td>This field indicates the EAP method for the connection.</td></tr><tr><td><i class=conum data-value=5></i><b>5</b></td><td>The <code>identity</code> field contains the identity string for EAP.</td></tr><tr><td><i class=conum data-value=6></i><b>6</b></td><td>The <code>ca_cert</code> field indicates the pathname of the CA certificate file. This file is needed to verify the server certificate.</td></tr><tr><td><i class=conum data-value=7></i><b>7</b></td><td>The <code>client_cert</code> line gives the pathname to the client certificate file. This certificate is unique to each wireless client of the network.</td></tr><tr><td><i class=conum data-value=8></i><b>8</b></td><td>The <code>private_key</code> field is the pathname to the client certificate private key file.</td></tr><tr><td><i class=conum data-value=9></i><b>9</b></td><td>The <code>private_key_passwd</code> field contains the passphrase for the private key.</td></tr></tbody></table></div><div class=paragraph><p>Then, add the following lines to <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>wlans_ath0=&#34;wlan0&#34;
ifconfig_wlan0=&#34;WPA DHCP&#34;</pre></div></div><div class=paragraph><p>The next step is to bring up the interface:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service netif start</span>
Starting wpa_supplicant.
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 7
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 15
DHCPACK from 192.168.0.20
bound to 192.168.0.254 <span class=nt>--</span> renewal <span class=k>in </span>300 seconds.
wlan0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
      ether 00:11:95:d5:43:62
      inet 192.168.0.254 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet DS/11Mbps mode 11g
      status: associated
      ssid freebsdap channel 1 <span class=o>(</span>2412 Mhz 11g<span class=o>)</span> bssid 00:11:95:c3:0d:ac
      country US ecm authmode WPA2/802.11i privacy ON deftxkey UNDEF
      AES-CCM 3:128-bit txpower 21.5 bmiss 7 scanvalid 450 bgscan
      bgscanintvl 300 bgscanidle 250 roam:rssi 7 roam:rate 5 protmode CTS
      wme burst roaming MANUAL</code></pre></div></div><div class=paragraph><p>It is also possible to bring up the interface manually using <a href="https://man.freebsd.org/cgi/man.cgi?query=wpa_supplicant&amp;sektion=8&amp;format=html">wpa_supplicant(8)</a> and <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a>.</p></div></div><div class=sect5><h6 id=network-wireless-wpa-eap-ttls>31.3.4.1.3.3. WPA 加上 EAP-TTLS<a class=anchor href=#network-wireless-wpa-eap-ttls></a></h6><div class=paragraph><p>With EAP-TLS, both the authentication server and the client need a certificate. With EAP-TTLS, a client certificate is optional. This method is similar to a web server which creates a secure SSL tunnel even if visitors do not have client-side certificates. EAP-TTLS uses an encrypted TLS tunnel for safe transport of the authentication data.</p></div><div class=paragraph><p>The required configuration can be added to <span class=filename>/etc/wpa_supplicant.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>network={
  ssid=&#34;freebsdap&#34;
  proto=RSN
  key_mgmt=WPA-EAP
  eap=TTLS <i class=conum data-value=1></i><b>(1)</b>
  identity=&#34;test&#34; <i class=conum data-value=2></i><b>(2)</b>
  password=&#34;test&#34; <i class=conum data-value=3></i><b>(3)</b>
  ca_cert=&#34;/etc/certs/cacert.pem&#34; <i class=conum data-value=4></i><b>(4)</b>
  phase2=&#34;auth=MD5&#34; <i class=conum data-value=5></i><b>(5)</b>
}</pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>This field specifies the EAP method for the connection.</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td>The <code>identity</code> field contains the identity string for EAP authentication inside the encrypted TLS tunnel.</td></tr><tr><td><i class=conum data-value=3></i><b>3</b></td><td>The <code>password</code> field contains the passphrase for the EAP authentication.</td></tr><tr><td><i class=conum data-value=4></i><b>4</b></td><td>The <code>ca_cert</code> field indicates the pathname of the CA certificate file. This file is needed to verify the server certificate.</td></tr><tr><td><i class=conum data-value=5></i><b>5</b></td><td>This field specifies the authentication method used in the encrypted TLS tunnel. In this example, EAP with MD5-Challenge is used. The "inner authentication" phase is often called "phase2".</td></tr></tbody></table></div><div class=paragraph><p>Next, add the following lines to <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>wlans_ath0=&#34;wlan0&#34;
ifconfig_wlan0=&#34;WPA DHCP&#34;</pre></div></div><div class=paragraph><p>The next step is to bring up the interface:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service netif start</span>
Starting wpa_supplicant.
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 7
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 15
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 21
DHCPACK from 192.168.0.20
bound to 192.168.0.254 <span class=nt>--</span> renewal <span class=k>in </span>300 seconds.
wlan0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
      ether 00:11:95:d5:43:62
      inet 192.168.0.254 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet DS/11Mbps mode 11g
      status: associated
      ssid freebsdap channel 1 <span class=o>(</span>2412 Mhz 11g<span class=o>)</span> bssid 00:11:95:c3:0d:ac
      country US ecm authmode WPA2/802.11i privacy ON deftxkey UNDEF
      AES-CCM 3:128-bit txpower 21.5 bmiss 7 scanvalid 450 bgscan
      bgscanintvl 300 bgscanidle 250 roam:rssi 7 roam:rate 5 protmode CTS
      wme burst roaming MANUAL</code></pre></div></div></div><div class=sect5><h6 id=network-wireless-wpa-eap-peap>31.3.4.1.3.4. WPA 加上 EAP-PEAP<a class=anchor href=#network-wireless-wpa-eap-peap></a></h6><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>PEAPv0/EAP-MSCHAPv2 is the most common PEAP method. In this chapter, the term PEAP is used to refer to that method.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Protected EAP (PEAP) is designed as an alternative to EAP-TTLS and is the most used EAP standard after EAP-TLS. In a network with mixed operating systems, PEAP should be the most supported standard after EAP-TLS.</p></div><div class=paragraph><p>PEAP is similar to EAP-TTLS as it uses a server-side certificate to authenticate clients by creating an encrypted TLS tunnel between the client and the authentication server, which protects the ensuing exchange of authentication information. PEAP authentication differs from EAP-TTLS as it broadcasts the username in the clear and only the password is sent in the encrypted TLS tunnel. EAP-TTLS will use the TLS tunnel for both the username and password.</p></div><div class=paragraph><p>Add the following lines to <span class=filename>/etc/wpa_supplicant.conf</span> to configure the EAP-PEAP related settings:</p></div><div class="literalblock programlisting"><div class=content><pre>network={
  ssid=&#34;freebsdap&#34;
  proto=RSN
  key_mgmt=WPA-EAP
  eap=PEAP <i class=conum data-value=1></i><b>(1)</b>
  identity=&#34;test&#34; <i class=conum data-value=2></i><b>(2)</b>
  password=&#34;test&#34; <i class=conum data-value=3></i><b>(3)</b>
  ca_cert=&#34;/etc/certs/cacert.pem&#34; <i class=conum data-value=4></i><b>(4)</b>
  phase1=&#34;peaplabel=0&#34; <i class=conum data-value=5></i><b>(5)</b>
  phase2=&#34;auth=MSCHAPV2&#34; <i class=conum data-value=6></i><b>(6)</b>
}</pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>This field specifies the EAP method for the connection.</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td>The <code>identity</code> field contains the identity string for EAP authentication inside the encrypted TLS tunnel.</td></tr><tr><td><i class=conum data-value=3></i><b>3</b></td><td>The <code>password</code> field contains the passphrase for the EAP authentication.</td></tr><tr><td><i class=conum data-value=4></i><b>4</b></td><td>The <code>ca_cert</code> field indicates the pathname of the CA certificate file. This file is needed to verify the server certificate.</td></tr><tr><td><i class=conum data-value=5></i><b>5</b></td><td>This field contains the parameters for the first phase of authentication, the TLS tunnel. According to the authentication server used, specify a specific label for authentication. Most of the time, the label will be "client EAP encryption" which is set by using <code>peaplabel=0</code>. More information can be found in <a href="https://man.freebsd.org/cgi/man.cgi?query=wpa_supplicant.conf&amp;sektion=5&amp;format=html">wpa_supplicant.conf(5)</a>.</td></tr><tr><td><i class=conum data-value=6></i><b>6</b></td><td>This field specifies the authentication protocol used in the encrypted TLS tunnel. In the case of PEAP, it is <code>auth=MSCHAPV2</code>.</td></tr></tbody></table></div><div class=paragraph><p>將以下參數加到 <span class=filename>/etc/rc.conf</span>：</p></div><div class="literalblock programlisting"><div class=content><pre>wlans_ath0=&#34;wlan0&#34;
ifconfig_wlan0=&#34;WPA DHCP&#34;</pre></div></div><div class=paragraph><p>Then, bring up the interface:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service netif start</span>
Starting wpa_supplicant.
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 7
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 15
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 21
DHCPACK from 192.168.0.20
bound to 192.168.0.254 <span class=nt>--</span> renewal <span class=k>in </span>300 seconds.
wlan0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
      ether 00:11:95:d5:43:62
      inet 192.168.0.254 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet DS/11Mbps mode 11g
      status: associated
      ssid freebsdap channel 1 <span class=o>(</span>2412 Mhz 11g<span class=o>)</span> bssid 00:11:95:c3:0d:ac
      country US ecm authmode WPA2/802.11i privacy ON deftxkey UNDEF
      AES-CCM 3:128-bit txpower 21.5 bmiss 7 scanvalid 450 bgscan
      bgscanintvl 300 bgscanidle 250 roam:rssi 7 roam:rate 5 protmode CTS
      wme burst roaming MANUAL</code></pre></div></div></div></div><div class=sect4><h5 id=network-wireless-wep>31.3.4.1.4. WEP<a class=anchor href=#network-wireless-wep></a></h5><div class=paragraph><p>Wired Equivalent Privacy (WEP) is part of the original 802.11 standard. There is no authentication mechanism, only a weak form of access control which is easily cracked.</p></div><div class=paragraph><p>WEP can be set up using <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0 create wlandev ath0</span>
<span class=c># ifconfig wlan0 inet 192.168.1.100 netmask 255.255.255.0 \</span>
	    ssid my_net wepmode on weptxkey 3 wepkey 3:0x3456789012</code></pre></div></div><div class=ulist><ul><li><p>The <code>weptxkey</code> specifies which WEP key will be used in the transmission. This example uses the third key. This must match the setting on the access point. When unsure which key is used by the access point, try <code>1</code> (the first key) for this value.</p></li><li><p>The <code>wepkey</code> selects one of the WEP keys. It should be in the format <em>index:key</em>. Key <code>1</code> is used by default; the index only needs to be set when using a key other than the first key.</p><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Replace the <code>0x3456789012</code> with the key configured for use on the access point.</p></div></td></tr></tbody></table></div></li></ul></div><div class=paragraph><p>Refer to <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a> for further information.</p></div><div class=paragraph><p>The <a href="https://man.freebsd.org/cgi/man.cgi?query=wpa_supplicant&amp;sektion=8&amp;format=html">wpa_supplicant(8)</a> facility can be used to configure a wireless interface with WEP. The example above can be set up by adding the following lines to <span class=filename>/etc/wpa_supplicant.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>network={
  ssid=&#34;my_net&#34;
  key_mgmt=NONE
  wep_key3=3456789012
  wep_tx_keyidx=3
}</pre></div></div><div class=paragraph><p>Then:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># wpa_supplicant -i wlan0 -c /etc/wpa_supplicant.conf</span>
Trying to associate with 00:13:46:49:41:76 <span class=o>(</span><span class=nv>SSID</span><span class=o>=</span><span class=s1>&#39;dlinkap&#39;</span> <span class=nv>freq</span><span class=o>=</span>2437 MHz<span class=o>)</span>
Associated with 00:13:46:49:41:76</code></pre></div></div></div></div></div><div class=sect2><h3 id=_對等式_ad_hoc>31.3.5. 對等式 (Ad-hoc)<a class=anchor href=#_對等式_ad_hoc></a></h3><div class=paragraph><p>IBSS mode, also called ad-hoc mode, is designed for point to point connections. For example, to establish an ad-hoc network between the machines <code>A</code> and <code>B</code>, choose two IP addresses and a SSID.</p></div><div class=paragraph><p>On <code>A</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0 create wlandev ath0 wlanmode adhoc</span>
<span class=c># ifconfig wlan0 inet 192.168.0.1 netmask 255.255.255.0 ssid freebsdap</span>
<span class=c># ifconfig wlan0</span>
  wlan0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
	  ether 00:11:95:c3:0d:ac
	  inet 192.168.0.1 netmask 0xffffff00 broadcast 192.168.0.255
	  media: IEEE 802.11 Wireless Ethernet autoselect mode 11g &lt;adhoc&gt;
	  status: running
	  ssid freebsdap channel 2 <span class=o>(</span>2417 Mhz 11g<span class=o>)</span> bssid 02:11:95:c3:0d:ac
	  country US ecm authmode OPEN privacy OFF txpower 21.5 scanvalid 60
	  protmode CTS wme burst</code></pre></div></div><div class=paragraph><p>The <code>adhoc</code> parameter indicates that the interface is running in IBSS mode.</p></div><div class=paragraph><p><code>B</code> should now be able to detect <code>A</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0 create wlandev ath0 wlanmode adhoc</span>
<span class=c># ifconfig wlan0 up scan</span>
  SSID/MESH ID    BSSID              CHAN RATE   S:N     INT CAPS
  freebsdap       02:11:95:c3:0d:ac    2   54M <span class=nt>-64</span>:-96  100 IS   WME</code></pre></div></div><div class=paragraph><p>The <code>I</code> in the output confirms that <code>A</code> is in ad-hoc mode. Now, configure <code>B</code> with a different IP address:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0 inet 192.168.0.2 netmask 255.255.255.0 ssid freebsdap</span>
<span class=c># ifconfig wlan0</span>
  wlan0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
	  ether 00:11:95:d5:43:62
	  inet 192.168.0.2 netmask 0xffffff00 broadcast 192.168.0.255
	  media: IEEE 802.11 Wireless Ethernet autoselect mode 11g &lt;adhoc&gt;
	  status: running
	  ssid freebsdap channel 2 <span class=o>(</span>2417 Mhz 11g<span class=o>)</span> bssid 02:11:95:c3:0d:ac
	  country US ecm authmode OPEN privacy OFF txpower 21.5 scanvalid 60
	  protmode CTS wme burst</code></pre></div></div><div class=paragraph><p>Both <code>A</code> and <code>B</code> are now ready to exchange information.</p></div></div><div class=sect2><h3 id=network-wireless-ap>31.3.6. FreeBSD 主機存取點<a class=anchor href=#network-wireless-ap></a></h3><div class=paragraph><p>FreeBSD can act as an Access Point (AP) which eliminates the need to buy a hardware AP or run an ad-hoc network. This can be particularly useful when a FreeBSD machine is acting as a gateway to another network such as the Internet.</p></div><div class=sect3><h4 id=network-wireless-ap-basic>31.3.6.1. 基礎設定<a class=anchor href=#network-wireless-ap-basic></a></h4><div class=paragraph><p>Before configuring a FreeBSD machine as an AP, the kernel must be configured with the appropriate networking support for the wireless card as well as the security protocols being used. For more details, see <a href=#network-wireless-basic>基礎設定</a>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>The NDIS driver wrapper for Windows™ drivers does not currently support AP operation. Only native FreeBSD wireless drivers support AP mode.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Once wireless networking support is loaded, check if the wireless device supports the host-based access point mode, also known as hostap mode:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0 create wlandev ath0</span>
<span class=c># ifconfig wlan0 list caps</span>
<span class=nv>drivercaps</span><span class=o>=</span>6f85edc1&lt;STA,FF,TURBOP,IBSS,HOSTAP,AHDEMO,TXPMGT,SHSLOT,SHPREAMBLE,MONITOR,MBSS,WPA1,WPA2,BURST,WME,WDS,BGSCAN,TXFRAG&gt;
<span class=nv>cryptocaps</span><span class=o>=</span>1f&lt;WEP,TKIP,AES,AES_CCM,TKIPMIC&gt;</code></pre></div></div><div class=paragraph><p>This output displays the card’s capabilities. The <code>HOSTAP</code> word confirms that this wireless card can act as an AP. Various supported ciphers are also listed: WEP, TKIP, and AES. This information indicates which security protocols can be used on the AP.</p></div><div class=paragraph><p>The wireless device can only be put into hostap mode during the creation of the network pseudo-device, so a previously created device must be destroyed first:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0 destroy</span></code></pre></div></div><div class=paragraph><p>then regenerated with the correct option before setting the other parameters:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0 create wlandev ath0 wlanmode hostap</span>
<span class=c># ifconfig wlan0 inet 192.168.0.1 netmask 255.255.255.0 ssid freebsdap mode 11g channel 1</span></code></pre></div></div><div class=paragraph><p>Use <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a> again to see the status of the <span class=filename>wlan0</span> interface:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0</span>
  wlan0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
	  ether 00:11:95:c3:0d:ac
	  inet 192.168.0.1 netmask 0xffffff00 broadcast 192.168.0.255
	  media: IEEE 802.11 Wireless Ethernet autoselect mode 11g &lt;hostap&gt;
	  status: running
	  ssid freebsdap channel 1 <span class=o>(</span>2412 Mhz 11g<span class=o>)</span> bssid 00:11:95:c3:0d:ac
	  country US ecm authmode OPEN privacy OFF txpower 21.5 scanvalid 60
	  protmode CTS wme burst dtimperiod 1 <span class=nt>-dfs</span></code></pre></div></div><div class=paragraph><p>The <code>hostap</code> parameter indicates the interface is running in the host-based access point mode.</p></div><div class=paragraph><p>The interface configuration can be done automatically at boot time by adding the following lines to <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>wlans_ath0=&#34;wlan0&#34;
create_args_wlan0=&#34;wlanmode hostap&#34;
ifconfig_wlan0=&#34;inet 192.168.0.1 netmask 255.255.255.0 ssid freebsdap mode 11g channel 1&#34;</pre></div></div></div><div class=sect3><h4 id=_無認證或加密的_host_based_存取點>31.3.6.2. 無認證或加密的 Host-based 存取點<a class=anchor href=#_無認證或加密的_host_based_存取點></a></h4><div class=paragraph><p>Although it is not recommended to run an AP without any authentication or encryption, this is a simple way to check if the AP is working. This configuration is also important for debugging client issues.</p></div><div class=paragraph><p>Once the AP is configured, initiate a scan from another wireless machine to find the AP:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0 create wlandev ath0</span>
<span class=c># ifconfig wlan0 up scan</span>
SSID/MESH ID    BSSID              CHAN RATE   S:N     INT CAPS
freebsdap       00:11:95:c3:0d:ac    1   54M <span class=nt>-66</span>:-96  100 ES   WME</code></pre></div></div><div class=paragraph><p>The client machine found the AP and can be associated with it:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0 inet 192.168.0.2 netmask 255.255.255.0 ssid freebsdap</span>
<span class=c># ifconfig wlan0</span>
  wlan0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
	  ether 00:11:95:d5:43:62
	  inet 192.168.0.2 netmask 0xffffff00 broadcast 192.168.0.255
	  media: IEEE 802.11 Wireless Ethernet OFDM/54Mbps mode 11g
	  status: associated
	  ssid freebsdap channel 1 <span class=o>(</span>2412 Mhz 11g<span class=o>)</span> bssid 00:11:95:c3:0d:ac
	  country US ecm authmode OPEN privacy OFF txpower 21.5 bmiss 7
	  scanvalid 60 bgscan bgscanintvl 300 bgscanidle 250 roam:rssi 7
	  roam:rate 5 protmode CTS wme burst</code></pre></div></div></div><div class=sect3><h4 id=network-wireless-ap-wpa>31.3.6.3. WPA2 Host-based 存取點<a class=anchor href=#network-wireless-ap-wpa></a></h4><div class=paragraph><p>This section focuses on setting up a FreeBSD access point using the WPA2 security protocol. More details regarding WPA and the configuration of WPA-based wireless clients can be found in <a href=#network-wireless-wpa>WPA</a>.</p></div><div class=paragraph><p>The <a href="https://man.freebsd.org/cgi/man.cgi?query=hostapd&amp;sektion=8&amp;format=html">hostapd(8)</a> daemon is used to deal with client authentication and key management on the WPA2-enabled AP.</p></div><div class=paragraph><p>The following configuration operations are performed on the FreeBSD machine acting as the AP. Once the AP is correctly working, <a href="https://man.freebsd.org/cgi/man.cgi?query=hostapd&amp;sektion=8&amp;format=html">hostapd(8)</a> can be automatically started at boot with this line in <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>hostapd_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Before trying to configure <a href="https://man.freebsd.org/cgi/man.cgi?query=hostapd&amp;sektion=8&amp;format=html">hostapd(8)</a>, first configure the basic settings introduced in <a href=#network-wireless-ap-basic>基礎設定</a>.</p></div><div class=sect4><h5 id=_wpa2_psk>31.3.6.3.1. WPA2-PSK<a class=anchor href=#_wpa2_psk></a></h5><div class=paragraph><p>WPA2-PSK is intended for small networks where the use of a backend authentication server is not possible or desired.</p></div><div class=paragraph><p>The configuration is done in <span class=filename>/etc/hostapd.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>interface=wlan0                  <i class=conum data-value=1></i><b>(1)</b>
debug=1                          <i class=conum data-value=2></i><b>(2)</b>
ctrl_interface=/var/run/hostapd  <i class=conum data-value=3></i><b>(3)</b>
ctrl_interface_group=wheel       <i class=conum data-value=4></i><b>(4)</b>
ssid=freebsdap                   <i class=conum data-value=5></i><b>(5)</b>
wpa=2                            <i class=conum data-value=6></i><b>(6)</b>
wpa_passphrase=freebsdmall       <i class=conum data-value=7></i><b>(7)</b>
wpa_key_mgmt=WPA-PSK             <i class=conum data-value=8></i><b>(8)</b>
wpa_pairwise=CCMP                <i class=conum data-value=9></i><b>(9)</b></pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>Wireless interface used for the access point.</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td>Level of verbosity used during the execution of <a href="https://man.freebsd.org/cgi/man.cgi?query=hostapd&amp;sektion=8&amp;format=html">hostapd(8)</a>. A value of <code>1</code> represents the minimal level.</td></tr><tr><td><i class=conum data-value=3></i><b>3</b></td><td>Pathname of the directory used by <a href="https://man.freebsd.org/cgi/man.cgi?query=hostapd&amp;sektion=8&amp;format=html">hostapd(8)</a> to store domain socket files for communication with external programs such as <a href="https://man.freebsd.org/cgi/man.cgi?query=hostapd_cli&amp;sektion=8&amp;format=html">hostapd_cli(8)</a>. The default value is used in this example.</td></tr><tr><td><i class=conum data-value=4></i><b>4</b></td><td>The group allowed to access the control interface files.</td></tr><tr><td><i class=conum data-value=5></i><b>5</b></td><td>The wireless network name, or SSID, that will appear in wireless scans.</td></tr><tr><td><i class=conum data-value=6></i><b>6</b></td><td>Enable WPA and specify which WPA authentication protocol will be required. A value of <code>2</code> configures the AP for WPA2 and is recommended. Set to <code>1</code> only if the obsolete WPA is required.</td></tr><tr><td><i class=conum data-value=7></i><b>7</b></td><td>ASCII passphrase for WPA authentication.</td></tr><tr><td><i class=conum data-value=8></i><b>8</b></td><td>The key management protocol to use. This example sets WPA-PSK.</td></tr><tr><td><i class=conum data-value=9></i><b>9</b></td><td>Encryption algorithms accepted by the access point. In this example, only the CCMP (AES) cipher is accepted. CCMP is an alternative to TKIP and is strongly preferred when possible. TKIP should be allowed only when there are stations incapable of using CCMP.</td></tr></tbody></table></div><div class=paragraph><p>The next step is to start <a href="https://man.freebsd.org/cgi/man.cgi?query=hostapd&amp;sektion=8&amp;format=html">hostapd(8)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service hostapd forcestart</span></code></pre></div></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0</span>
wlan0: <span class=nv>flags</span><span class=o>=</span>8943&lt;UP,BROADCAST,RUNNING,PROMISC,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
	ether 04:f0:21:16:8e:10
	inet6 fe80::6f0:21ff:fe16:8e10%wlan0 prefixlen 64 scopeid 0x9
	nd6 <span class=nv>options</span><span class=o>=</span>21&lt;PERFORMNUD,AUTO_LINKLOCAL&gt;
	media: IEEE 802.11 Wireless Ethernet autoselect mode 11na &lt;hostap&gt;
	status: running
	ssid No5ignal channel 36 <span class=o>(</span>5180 MHz 11a ht/40+<span class=o>)</span> bssid 04:f0:21:16:8e:10
	country US ecm authmode WPA2/802.11i privacy MIXED deftxkey 2
	AES-CCM 2:128-bit AES-CCM 3:128-bit txpower 17 mcastrate 6 mgmtrate 6
	scanvalid 60 ampdulimit 64k ampdudensity 8 shortgi wme burst
	dtimperiod 1 <span class=nt>-dfs</span>
	<span class=nb>groups</span>: wlan</code></pre></div></div><div class=paragraph><p>Once the AP is running, the clients can associate with it. See <a href=#network-wireless-wpa>WPA</a> for more details. It is possible to see the stations associated with the AP using <code>ifconfig <em>wlan0</em> list sta</code>.</p></div></div></div><div class=sect3><h4 id=_wep_host_based_存取點>31.3.6.4. WEP Host-based 存取點<a class=anchor href=#_wep_host_based_存取點></a></h4><div class=paragraph><p>It is not recommended to use WEP for setting up an AP since there is no authentication mechanism and the encryption is easily cracked. Some legacy wireless cards only support WEP and these cards will only support an AP without authentication or encryption.</p></div><div class=paragraph><p>The wireless device can now be put into hostap mode and configured with the correct SSID and IP address:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0 create wlandev ath0 wlanmode hostap</span>
<span class=c># ifconfig wlan0 inet 192.168.0.1 netmask 255.255.255.0 \</span>
	ssid freebsdap wepmode on weptxkey 3 wepkey 3:0x3456789012 mode 11g</code></pre></div></div><div class=ulist><ul><li><p>The <code>weptxkey</code> indicates which WEP key will be used in the transmission. This example uses the third key as key numbering starts with <code>1</code>. This parameter must be specified in order to encrypt the data.</p></li><li><p>The <code>wepkey</code> sets the selected WEP key. It should be in the format <em>index:key</em>. If the index is not given, key <code>1</code> is set. The index needs to be set when using keys other than the first key.</p></li></ul></div><div class=paragraph><p>Use <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a> to see the status of the <span class=filename>wlan0</span> interface:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0</span>
  wlan0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
	  ether 00:11:95:c3:0d:ac
	  inet 192.168.0.1 netmask 0xffffff00 broadcast 192.168.0.255
	  media: IEEE 802.11 Wireless Ethernet autoselect mode 11g &lt;hostap&gt;
	  status: running
	  ssid freebsdap channel 4 <span class=o>(</span>2427 Mhz 11g<span class=o>)</span> bssid 00:11:95:c3:0d:ac
	  country US ecm authmode OPEN privacy ON deftxkey 3 wepkey 3:40-bit
	  txpower 21.5 scanvalid 60 protmode CTS wme burst dtimperiod 1 <span class=nt>-dfs</span></code></pre></div></div><div class=paragraph><p>From another wireless machine, it is now possible to initiate a scan to find the AP:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0 create wlandev ath0</span>
<span class=c># ifconfig wlan0 up scan</span>
SSID            BSSID              CHAN RATE  S:N   INT CAPS
freebsdap       00:11:95:c3:0d:ac    1   54M 22:1   100 EPS</code></pre></div></div><div class=paragraph><p>In this example, the client machine found the AP and can associate with it using the correct parameters. See <a href=#network-wireless-wep>WEP</a> for more details.</p></div></div></div><div class=sect2><h3 id=_同時使用有線及無線連線>31.3.7. 同時使用有線及無線連線<a class=anchor href=#_同時使用有線及無線連線></a></h3><div class=paragraph><p>A wired connection provides better performance and reliability, while a wireless connection provides flexibility and mobility. Laptop users typically want to roam seamlessly between the two types of connections.</p></div><div class=paragraph><p>On FreeBSD, it is possible to combine two or even more network interfaces together in a "failover" fashion. This type of configuration uses the most preferred and available connection from a group of network interfaces, and the operating system switches automatically when the link state changes.</p></div><div class=paragraph><p>Link aggregation and failover is covered in <a href=#network-aggregation>Link Aggregation 與容錯移轉</a> and an example for using both wired and wireless connections is provided at <a href=#networking-lagg-wired-and-wireless>乙太網路與無線介面間的容錯移轉模式</a>.</p></div></div><div class=sect2><h3 id=_疑難排解>31.3.8. 疑難排解<a class=anchor href=#_疑難排解></a></h3><div class=paragraph><p>This section describes a number of steps to help troubleshoot common wireless networking problems.</p></div><div class=ulist><ul><li><p>If the access point is not listed when scanning, check that the configuration has not limited the wireless device to a limited set of channels.</p></li><li><p>If the device cannot associate with an access point, verify that the configuration matches the settings on the access point. This includes the authentication scheme and any security protocols. Simplify the configuration as much as possible. If using a security protocol such as WPA or WEP, configure the access point for open authentication and no security to see if traffic will pass.</p><div class=paragraph><p>Debugging support is provided by <a href="https://man.freebsd.org/cgi/man.cgi?query=wpa_supplicant&amp;sektion=8&amp;format=html">wpa_supplicant(8)</a>. Try running this utility manually with <code>-dd</code> and look at the system logs.</p></div></li><li><p>Once the system can associate with the access point, diagnose the network configuration using tools like <a href="https://man.freebsd.org/cgi/man.cgi?query=ping&amp;sektion=8&amp;format=html">ping(8)</a>.</p></li><li><p>There are many lower-level debugging tools. Debugging messages can be enabled in the 802.11 protocol support layer using <a href="https://man.freebsd.org/cgi/man.cgi?query=wlandebug&amp;sektion=8&amp;format=html">wlandebug(8)</a>. For example, to enable console messages related to scanning for access points and the 802.11 protocol handshakes required to arrange communication:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># wlandebug -i wlan0 +scan+auth+debug+assoc</span>
  net.wlan.0.debug: 0 <span class=o>=&gt;</span> 0xc80000&lt;assoc,auth,scan&gt;</code></pre></div></div><div class=paragraph><p>Many useful statistics are maintained by the 802.11 layer and <code>wlanstats</code>, found in <span class=filename>/usr/src/tools/tools/net80211</span>, will dump this information. These statistics should display all errors identified by the 802.11 layer. However, some errors are identified in the device drivers that lie below the 802.11 layer so they may not show up. To diagnose device-specific problems, refer to the drivers' documentation.</p></div></li></ul></div><div class=paragraph><p>If the above information does not help to clarify the problem, submit a problem report and include output from the above tools.</p></div></div></div></div><div class=sect1><h2 id=network-usb-tethering>31.4. USB 網路共享<a class=anchor href=#network-usb-tethering></a></h2><div class=sectionbody><div class=paragraph><p>Many cellphones provide the option to share their data connection over USB (often called "tethering"). This feature uses either the RNDIS, CDC or a custom Apple™iPhone™/iPad™ protocol.</p></div><div class=ulist><ul><li><p>Android™ devices generally use the <a href="https://man.freebsd.org/cgi/man.cgi?query=urndis&amp;sektion=4&amp;format=html">urndis(4)</a> driver.</p></li><li><p>Apple™ devices use the <a href="https://man.freebsd.org/cgi/man.cgi?query=ipheth&amp;sektion=4&amp;format=html">ipheth(4)</a> driver.</p></li><li><p>Older devices will often use the <a href="https://man.freebsd.org/cgi/man.cgi?query=cdce&amp;sektion=4&amp;format=html">cdce(4)</a> driver.</p></li></ul></div><div class=paragraph><p>Before attaching a device, load the appropriate driver into the kernel:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload if_urndis</span>
<span class=c># kldload if_cdce</span>
<span class=c># kldload if_ipheth</span></code></pre></div></div><div class=paragraph><p>Once the device is attached <code>ue<em>0</em></code> will be available for use like a normal network device. Be sure that the "USB tethering" option is enabled on the device.</p></div></div></div><div class=sect1><h2 id=network-bluetooth>31.5. 藍牙<a class=anchor href=#network-bluetooth></a></h2><div class=sectionbody><div class=paragraph><p>Bluetooth is a wireless technology for creating personal networks operating in the 2.4 GHz unlicensed band, with a range of 10 meters. Networks are usually formed ad-hoc from portable devices such as cellular phones, handhelds, and laptops. Unlike Wi-Fi wireless technology, Bluetooth offers higher level service profiles, such as FTP-like file servers, file pushing, voice transport, serial line emulation, and more.</p></div><div class=paragraph><p>This section describes the use of a USB Bluetooth dongle on a FreeBSD system. It then describes the various Bluetooth protocols and utilities.</p></div><div class=sect2><h3 id=_載入藍牙支援>31.5.1. 載入藍牙支援<a class=anchor href=#_載入藍牙支援></a></h3><div class=paragraph><p>The Bluetooth stack in FreeBSD is implemented using the <a href="https://man.freebsd.org/cgi/man.cgi?query=netgraph&amp;sektion=4&amp;format=html">netgraph(4)</a> framework. A broad variety of Bluetooth USB dongles is supported by <a href="https://man.freebsd.org/cgi/man.cgi?query=ng_ubt&amp;sektion=4&amp;format=html">ng_ubt(4)</a>. Broadcom BCM2033 based Bluetooth devices are supported by the <a href="https://man.freebsd.org/cgi/man.cgi?query=ubtbcmfw&amp;sektion=4&amp;format=html">ubtbcmfw(4)</a> and <a href="https://man.freebsd.org/cgi/man.cgi?query=ng_ubt&amp;sektion=4&amp;format=html">ng_ubt(4)</a> drivers. The 3Com Bluetooth PC Card 3CRWB60-A is supported by the <a href="https://man.freebsd.org/cgi/man.cgi?query=ng_bt3c&amp;sektion=4&amp;format=html">ng_bt3c(4)</a> driver. Serial and UART based Bluetooth devices are supported by <a href="https://man.freebsd.org/cgi/man.cgi?query=sio&amp;sektion=4&amp;format=html">sio(4)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=ng_h4&amp;sektion=4&amp;format=html">ng_h4(4)</a>, and <a href="https://man.freebsd.org/cgi/man.cgi?query=hcseriald&amp;sektion=8&amp;format=html">hcseriald(8)</a>.</p></div><div class=paragraph><p>Before attaching a device, determine which of the above drivers it uses, then load the driver. For example, if the device uses the <a href="https://man.freebsd.org/cgi/man.cgi?query=ng_ubt&amp;sektion=4&amp;format=html">ng_ubt(4)</a> driver:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload ng_ubt</span></code></pre></div></div><div class=paragraph><p>If the Bluetooth device will be attached to the system during system startup, the system can be configured to load the module at boot time by adding the driver to <span class=filename>/boot/loader.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>ng_ubt_load=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Once the driver is loaded, plug in the USB dongle. If the driver load was successful, output similar to the following should appear on the console and in <span class=filename>/var/log/messages</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>ubt0: vendor 0x0a12 product 0x0001, rev 1.10/5.25, addr 2
ubt0: Interface 0 endpoints: <span class=nv>interrupt</span><span class=o>=</span>0x81, bulk-in<span class=o>=</span>0x82, bulk-out<span class=o>=</span>0x2
ubt0: Interface 1 <span class=o>(</span>alt.config 5<span class=o>)</span> endpoints: isoc-in<span class=o>=</span>0x83, isoc-out<span class=o>=</span>0x3,
      <span class=nv>wMaxPacketSize</span><span class=o>=</span>49, <span class=nv>nframes</span><span class=o>=</span>6, buffer <span class=nv>size</span><span class=o>=</span>294</code></pre></div></div><div class=paragraph><p>To start and stop the Bluetooth stack, use its startup script. It is a good idea to stop the stack before unplugging the device. Starting the bluetooth stack might require <a href="https://man.freebsd.org/cgi/man.cgi?query=hcsecd&amp;sektion=8&amp;format=html">hcsecd(8)</a> to be started. When starting the stack, the output should be similar to the following:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service bluetooth start ubt0</span>
BD_ADDR: 00:02:72:00:d4:1a
Features: 0xff 0xff 0xf 00 00 00 00 00
&lt;3-Slot&gt; &lt;5-Slot&gt; &lt;Encryption&gt; &lt;Slot offset&gt;
&lt;Timing accuracy&gt; &lt;Switch&gt; &lt;Hold mode&gt; &lt;Sniff mode&gt;
&lt;Park mode&gt; &lt;RSSI&gt; &lt;Channel quality&gt; &lt;SCO <span class=nb>link</span><span class=o>&gt;</span>
&lt;HV2 packets&gt; &lt;HV3 packets&gt; &lt;u-law log&gt; &lt;A-law log&gt; &lt;CVSD&gt;
&lt;Paging scheme&gt; &lt;Power control&gt; &lt;Transparent SCO data&gt;
Max. ACL packet size: 192 bytes
Number of ACL packets: 8
Max. SCO packet size: 64 bytes
Number of SCO packets: 8</code></pre></div></div></div><div class=sect2><h3 id=_尋找其他藍牙裝置>31.5.2. 尋找其他藍牙裝置<a class=anchor href=#_尋找其他藍牙裝置></a></h3><div class=paragraph><p>The Host Controller Interface (HCI) provides a uniform method for accessing Bluetooth baseband capabilities. In FreeBSD, a netgraph HCI node is created for each Bluetooth device. For more details, refer to <a href="https://man.freebsd.org/cgi/man.cgi?query=ng_hci&amp;sektion=4&amp;format=html">ng_hci(4)</a>.</p></div><div class=paragraph><p>One of the most common tasks is discovery of Bluetooth devices within RF proximity. This operation is called <em>inquiry</em>. Inquiry and other HCI related operations are done using <a href="https://man.freebsd.org/cgi/man.cgi?query=hccontrol&amp;sektion=8&amp;format=html">hccontrol(8)</a>. The example below shows how to find out which Bluetooth devices are in range. The list of devices should be displayed in a few seconds. Note that a remote device will only answer the inquiry if it is set to <em>discoverable</em> mode.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% hccontrol <span class=nt>-n</span> ubt0hci inquiry
Inquiry result, <span class=nv>num_responses</span><span class=o>=</span>1
Inquiry result <span class=c>#0</span>
       BD_ADDR: 00:80:37:29:19:a4
       Page Scan Rep. Mode: 0x1
       Page Scan Period Mode: 00
       Page Scan Mode: 00
       Class: 52:02:04
       Clock offset: 0x78ef
Inquiry complete. Status: No error <span class=o>[</span>00]</code></pre></div></div><div class=paragraph><p>The <code>BD_ADDR</code> is the unique address of a Bluetooth device, similar to the MAC address of a network card. This address is needed for further communication with a device and it is possible to assign a human readable name to a <code>BD_ADDR</code>. Information regarding the known Bluetooth hosts is contained in <span class=filename>/etc/bluetooth/hosts</span>. The following example shows how to obtain the human readable name that was assigned to the remote device:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% hccontrol <span class=nt>-n</span> ubt0hci remote_name_request 00:80:37:29:19:a4
BD_ADDR: 00:80:37:29:19:a4
Name: Pav<span class=s1>&#39;s T39</span></code></pre></div></div><div class=paragraph><p>If an inquiry is performed on a remote Bluetooth device, it will find the computer as "your.host.name (ubt0)". The name assigned to the local device can be changed at any time.</p></div><div class=paragraph><p>Remote devices can be assigned aliases in <span class=filename>/etc/bluetooth/hosts</span>. More information about <span class=filename>/etc/bluetooth/hosts</span> file might be found in <a href="https://man.freebsd.org/cgi/man.cgi?query=bluetooth.hosts&amp;sektion=5&amp;format=html">bluetooth.hosts(5)</a>.</p></div><div class=paragraph><p>The Bluetooth system provides a point-to-point connection between two Bluetooth units, or a point-to-multipoint connection which is shared among several Bluetooth devices. The following example shows how to create a connection to a remote device:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% hccontrol <span class=nt>-n</span> ubt0hci create_connection BT_ADDR</code></pre></div></div><div class=paragraph><p><code>create_connection</code> accepts <code>BT_ADDR</code> as well as host aliases in <span class=filename>/etc/bluetooth/hosts</span>.</p></div><div class=paragraph><p>The following example shows how to obtain the list of active baseband connections for the local device:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% hccontrol <span class=nt>-n</span> ubt0hci read_connection_list
Remote BD_ADDR    Handle Type Mode Role Encrypt Pending Queue State
00:80:37:29:19:a4     41  ACL    0 MAST    NONE       0     0 OPEN</code></pre></div></div><div class=paragraph><p>A <em>connection handle</em> is useful when termination of the baseband connection is required, though it is normally not required to do this by hand. The stack will automatically terminate inactive baseband connections.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># hccontrol -n ubt0hci disconnect 41</span>
Connection handle: 41
Reason: Connection terminated by <span class=nb>local </span>host <span class=o>[</span>0x16]</code></pre></div></div><div class=paragraph><p>Type <code>hccontrol help</code> for a complete listing of available HCI commands. Most of the HCI commands do not require superuser privileges.</p></div></div><div class=sect2><h3 id=_裝置配對>31.5.3. 裝置配對<a class=anchor href=#_裝置配對></a></h3><div class=paragraph><p>By default, Bluetooth communication is not authenticated, and any device can talk to any other device. A Bluetooth device, such as a cellular phone, may choose to require authentication to provide a particular service. Bluetooth authentication is normally done with a <em>PIN code</em>, an ASCII string up to 16 characters in length. The user is required to enter the same PIN code on both devices. Once the user has entered the PIN code, both devices will generate a <em>link key</em>. After that, the link key can be stored either in the devices or in a persistent storage. Next time, both devices will use the previously generated link key. This procedure is called <em>pairing</em>. Note that if the link key is lost by either device, the pairing must be repeated.</p></div><div class=paragraph><p>The <a href="https://man.freebsd.org/cgi/man.cgi?query=hcsecd&amp;sektion=8&amp;format=html">hcsecd(8)</a> daemon is responsible for handling Bluetooth authentication requests. The default configuration file is <span class=filename>/etc/bluetooth/hcsecd.conf</span>. An example section for a cellular phone with the PIN code set to <code>1234</code> is shown below:</p></div><div class="literalblock programlisting"><div class=content><pre>device {
        bdaddr  00:80:37:29:19:a4;
        name    &#34;Pav&#39;s T39&#34;;
        key     nokey;
        pin     &#34;1234&#34;;
      }</pre></div></div><div class=paragraph><p>The only limitation on PIN codes is length. Some devices, such as Bluetooth headsets, may have a fixed PIN code built in. The <code>-d</code> switch forces <a href="https://man.freebsd.org/cgi/man.cgi?query=hcsecd&amp;sektion=8&amp;format=html">hcsecd(8)</a> to stay in the foreground, so it is easy to see what is happening. Set the remote device to receive pairing and initiate the Bluetooth connection to the remote device. The remote device should indicate that pairing was accepted and request the PIN code. Enter the same PIN code listed in <span class=filename>hcsecd.conf</span>. Now the computer and the remote device are paired. Alternatively, pairing can be initiated on the remote device.</p></div><div class=paragraph><p>The following line can be added to <span class=filename>/etc/rc.conf</span> to configure <a href="https://man.freebsd.org/cgi/man.cgi?query=hcsecd&amp;sektion=8&amp;format=html">hcsecd(8)</a> to start automatically on system start:</p></div><div class="literalblock programlisting"><div class=content><pre>hcsecd_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>The following is a sample of the <a href="https://man.freebsd.org/cgi/man.cgi?query=hcsecd&amp;sektion=8&amp;format=html">hcsecd(8)</a> daemon output:</p></div><div class="literalblock programlisting"><div class=content><pre>hcsecd[16484]: Got Link_Key_Request event from &#39;ubt0hci&#39;, remote bdaddr 0:80:37:29:19:a4
hcsecd[16484]: Found matching entry, remote bdaddr 0:80:37:29:19:a4, name &#39;Pav&#39;s T39&#39;, link key doesn&#39;t exist
hcsecd[16484]: Sending Link_Key_Negative_Reply to &#39;ubt0hci&#39; for remote bdaddr 0:80:37:29:19:a4
hcsecd[16484]: Got PIN_Code_Request event from &#39;ubt0hci&#39;, remote bdaddr 0:80:37:29:19:a4
hcsecd[16484]: Found matching entry, remote bdaddr 0:80:37:29:19:a4, name &#39;Pav&#39;s T39&#39;, PIN code exists
hcsecd[16484]: Sending PIN_Code_Reply to &#39;ubt0hci&#39; for remote bdaddr 0:80:37:29:19:a4</pre></div></div></div><div class=sect2><h3 id=_使用_ppp_profile_存取網路>31.5.4. 使用 PPP Profile 存取網路<a class=anchor href=#_使用_ppp_profile_存取網路></a></h3><div class=paragraph><p>A Dial-Up Networking (DUN) profile can be used to configure a cellular phone as a wireless modem for connecting to a dial-up Internet access server. It can also be used to configure a computer to receive data calls from a cellular phone.</p></div><div class=paragraph><p>Network access with a PPP profile can be used to provide LAN access for a single Bluetooth device or multiple Bluetooth devices. It can also provide PC to PC connection using PPP networking over serial cable emulation.</p></div><div class=paragraph><p>In FreeBSD, these profiles are implemented with <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> and the <a href="https://man.freebsd.org/cgi/man.cgi?query=rfcomm_pppd&amp;sektion=8&amp;format=html">rfcomm_pppd(8)</a> wrapper which converts a Bluetooth connection into something PPP can use. Before a profile can be used, a new PPP label must be created in <span class=filename>/etc/ppp/ppp.conf</span>. Consult <a href="https://man.freebsd.org/cgi/man.cgi?query=rfcomm_pppd&amp;sektion=8&amp;format=html">rfcomm_pppd(8)</a> for examples.</p></div><div class=paragraph><p>In this example, <a href="https://man.freebsd.org/cgi/man.cgi?query=rfcomm_pppd&amp;sektion=8&amp;format=html">rfcomm_pppd(8)</a> is used to open a connection to a remote device with a <code>BD_ADDR</code> of <code>00:80:37:29:19:a4</code> on a DUNRFCOMM channel:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># rfcomm_pppd -a 00:80:37:29:19:a4 -c -C dun -l rfcomm-dialup</span></code></pre></div></div><div class=paragraph><p>The actual channel number will be obtained from the remote device using the SDP protocol. It is possible to specify the RFCOMM channel by hand, and in this case <a href="https://man.freebsd.org/cgi/man.cgi?query=rfcomm_pppd&amp;sektion=8&amp;format=html">rfcomm_pppd(8)</a> will not perform the SDP query. Use <a href="https://man.freebsd.org/cgi/man.cgi?query=sdpcontrol&amp;sektion=8&amp;format=html">sdpcontrol(8)</a> to find out the RFCOMM channel on the remote device.</p></div><div class=paragraph><p>In order to provide network access with the PPPLAN service, <a href="https://man.freebsd.org/cgi/man.cgi?query=sdpd&amp;sektion=8&amp;format=html">sdpd(8)</a> must be running and a new entry for LAN clients must be created in <span class=filename>/etc/ppp/ppp.conf</span>. Consult <a href="https://man.freebsd.org/cgi/man.cgi?query=rfcomm_pppd&amp;sektion=8&amp;format=html">rfcomm_pppd(8)</a> for examples. Finally, start the RFCOMMPPP server on a valid RFCOMM channel number. The RFCOMMPPP server will automatically register the Bluetooth LAN service with the local SDP daemon. The example below shows how to start the RFCOMMPPP server.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># rfcomm_pppd -s -C 7 -l rfcomm-server</span></code></pre></div></div></div><div class=sect2><h3 id=_藍牙通訊協定>31.5.5. 藍牙通訊協定<a class=anchor href=#_藍牙通訊協定></a></h3><div class=paragraph><p>This section provides an overview of the various Bluetooth protocols, their function, and associated utilities.</p></div><div class=sect3><h4 id=_logical_link_control_and_adaptation_protocol_l2cap>31.5.5.1. Logical Link Control and Adaptation Protocol (L2CAP)<a class=anchor href=#_logical_link_control_and_adaptation_protocol_l2cap></a></h4><div class=paragraph><p>The Logical Link Control and Adaptation Protocol (L2CAP) provides connection-oriented and connectionless data services to upper layer protocols. L2CAP permits higher level protocols and applications to transmit and receive L2CAP data packets up to 64 kilobytes in length.</p></div><div class=paragraph><p>L2CAP is based around the concept of <em>channels</em>. A channel is a logical connection on top of a baseband connection, where each channel is bound to a single protocol in a many-to-one fashion. Multiple channels can be bound to the same protocol, but a channel cannot be bound to multiple protocols. Each L2CAP packet received on a channel is directed to the appropriate higher level protocol. Multiple channels can share the same baseband connection.</p></div><div class=paragraph><p>In FreeBSD, a netgraph L2CAP node is created for each Bluetooth device. This node is normally connected to the downstream Bluetooth HCI node and upstream Bluetooth socket nodes. The default name for the L2CAP node is "devicel2cap". For more details refer to <a href="https://man.freebsd.org/cgi/man.cgi?query=ng_l2cap&amp;sektion=4&amp;format=html">ng_l2cap(4)</a>.</p></div><div class=paragraph><p>A useful command is <a href="https://man.freebsd.org/cgi/man.cgi?query=l2ping&amp;sektion=8&amp;format=html">l2ping(8)</a>, which can be used to ping other devices. Some Bluetooth implementations might not return all of the data sent to them, so <code>0 bytes</code> in the following example is normal.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># l2ping -a 00:80:37:29:19:a4</span>
0 bytes from 0:80:37:29:19:a4 <span class=nv>seq_no</span><span class=o>=</span>0 <span class=nb>time</span><span class=o>=</span>48.633 ms <span class=nv>result</span><span class=o>=</span>0
0 bytes from 0:80:37:29:19:a4 <span class=nv>seq_no</span><span class=o>=</span>1 <span class=nb>time</span><span class=o>=</span>37.551 ms <span class=nv>result</span><span class=o>=</span>0
0 bytes from 0:80:37:29:19:a4 <span class=nv>seq_no</span><span class=o>=</span>2 <span class=nb>time</span><span class=o>=</span>28.324 ms <span class=nv>result</span><span class=o>=</span>0
0 bytes from 0:80:37:29:19:a4 <span class=nv>seq_no</span><span class=o>=</span>3 <span class=nb>time</span><span class=o>=</span>46.150 ms <span class=nv>result</span><span class=o>=</span>0</code></pre></div></div><div class=paragraph><p>The <a href="https://man.freebsd.org/cgi/man.cgi?query=l2control&amp;sektion=8&amp;format=html">l2control(8)</a> utility is used to perform various operations on L2CAP nodes. This example shows how to obtain the list of logical connections (channels) and the list of baseband connections for the local device:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% l2control <span class=nt>-a</span> 00:02:72:00:d4:1a read_channel_list
L2CAP channels:
Remote BD_ADDR     SCID/ DCID   PSM  IMTU/ OMTU State
00:07:e0:00:0b:ca    66/   64     3   132/  672 OPEN
% l2control <span class=nt>-a</span> 00:02:72:00:d4:1a read_connection_list
L2CAP connections:
Remote BD_ADDR    Handle Flags Pending State
00:07:e0:00:0b:ca     41 O           0 OPEN</code></pre></div></div><div class=paragraph><p>Another diagnostic tool is <a href="https://man.freebsd.org/cgi/man.cgi?query=btsockstat&amp;sektion=1&amp;format=html">btsockstat(1)</a>. It is similar to <a href="https://man.freebsd.org/cgi/man.cgi?query=netstat&amp;sektion=1&amp;format=html">netstat(1)</a>, but for Bluetooth network-related data structures. The example below shows the same logical connection as <a href="https://man.freebsd.org/cgi/man.cgi?query=l2control&amp;sektion=8&amp;format=html">l2control(8)</a> above.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% btsockstat
Active L2CAP sockets
PCB      Recv-Q Send-Q Local address/PSM       Foreign address   CID   State
c2afe900      0      0 00:02:72:00:d4:1a/3     00:07:e0:00:0b:ca 66    OPEN
Active RFCOMM sessions
L2PCB    PCB      Flag MTU   Out-Q DLCs State
c2afe900 c2b53380 1    127   0     Yes  OPEN
Active RFCOMM sockets
PCB      Recv-Q Send-Q Local address     Foreign address   Chan DLCI State
c2e8bc80      0    250 00:02:72:00:d4:1a 00:07:e0:00:0b:ca 3    6    OPEN</code></pre></div></div></div><div class=sect3><h4 id=_radio_frequency_communication_rfcomm>31.5.5.2. Radio Frequency Communication (RFCOMM)<a class=anchor href=#_radio_frequency_communication_rfcomm></a></h4><div class=paragraph><p>The RFCOMM protocol provides emulation of serial ports over the L2CAP protocol. RFCOMM is a simple transport protocol, with additional provisions for emulating the 9 circuits of RS-232 (EIATIA-232-E) serial ports. It supports up to 60 simultaneous connections (RFCOMM channels) between two Bluetooth devices.</p></div><div class=paragraph><p>For the purposes of RFCOMM, a complete communication path involves two applications running on the communication endpoints with a communication segment between them. RFCOMM is intended to cover applications that make use of the serial ports of the devices in which they reside. The communication segment is a direct connect Bluetooth link from one device to another.</p></div><div class=paragraph><p>RFCOMM is only concerned with the connection between the devices in the direct connect case, or between the device and a modem in the network case. RFCOMM can support other configurations, such as modules that communicate via Bluetooth wireless technology on one side and provide a wired interface on the other side.</p></div><div class=paragraph><p>In FreeBSD, RFCOMM is implemented at the Bluetooth sockets layer.</p></div></div><div class=sect3><h4 id=_service_discovery_protocol_sdp>31.5.5.3. Service Discovery Protocol (SDP)<a class=anchor href=#_service_discovery_protocol_sdp></a></h4><div class=paragraph><p>The Service Discovery Protocol (SDP) provides the means for client applications to discover the existence of services provided by server applications as well as the attributes of those services. The attributes of a service include the type or class of service offered and the mechanism or protocol information needed to utilize the service.</p></div><div class=paragraph><p>SDP involves communication between a SDP server and a SDP client. The server maintains a list of service records that describe the characteristics of services associated with the server. Each service record contains information about a single service. A client may retrieve information from a service record maintained by the SDP server by issuing a SDP request. If the client, or an application associated with the client, decides to use a service, it must open a separate connection to the service provider in order to utilize the service. SDP provides a mechanism for discovering services and their attributes, but it does not provide a mechanism for utilizing those services.</p></div><div class=paragraph><p>Normally, a SDP client searches for services based on some desired characteristics of the services. However, there are times when it is desirable to discover which types of services are described by an SDP server’s service records without any prior information about the services. This process of looking for any offered services is called <em>browsing</em>.</p></div><div class=paragraph><p>The Bluetooth SDP server, <a href="https://man.freebsd.org/cgi/man.cgi?query=sdpd&amp;sektion=8&amp;format=html">sdpd(8)</a>, and command line client, <a href="https://man.freebsd.org/cgi/man.cgi?query=sdpcontrol&amp;sektion=8&amp;format=html">sdpcontrol(8)</a>, are included in the standard FreeBSD installation. The following example shows how to perform a SDP browse query.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% sdpcontrol <span class=nt>-a</span> 00:01:03:fc:6e:ec browse
Record Handle: 00000000
Service Class ID List:
        Service Discovery Server <span class=o>(</span>0x1000<span class=o>)</span>
Protocol Descriptor List:
        L2CAP <span class=o>(</span>0x0100<span class=o>)</span>
                Protocol specific parameter <span class=c>#1: u/int/uuid16 1</span>
                Protocol specific parameter <span class=c>#2: u/int/uuid16 1</span>

Record Handle: 0x00000001
Service Class ID List:
        Browse Group Descriptor <span class=o>(</span>0x1001<span class=o>)</span>

Record Handle: 0x00000002
Service Class ID List:
        LAN Access Using PPP <span class=o>(</span>0x1102<span class=o>)</span>
Protocol Descriptor List:
        L2CAP <span class=o>(</span>0x0100<span class=o>)</span>
        RFCOMM <span class=o>(</span>0x0003<span class=o>)</span>
                Protocol specific parameter <span class=c>#1: u/int8/bool 1</span>
Bluetooth Profile Descriptor List:
        LAN Access Using PPP <span class=o>(</span>0x1102<span class=o>)</span> ver. 1.0</code></pre></div></div><div class=paragraph><p>Note that each service has a list of attributes, such as the RFCOMM channel. Depending on the service, the user might need to make note of some of the attributes. Some Bluetooth implementations do not support service browsing and may return an empty list. In this case, it is possible to search for the specific service. The example below shows how to search for the OBEX Object Push (OPUSH) service:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% sdpcontrol <span class=nt>-a</span> 00:01:03:fc:6e:ec search OPUSH</code></pre></div></div><div class=paragraph><p>Offering services on FreeBSD to Bluetooth clients is done with the <a href="https://man.freebsd.org/cgi/man.cgi?query=sdpd&amp;sektion=8&amp;format=html">sdpd(8)</a> server. The following line can be added to <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>sdpd_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Then the <a href="https://man.freebsd.org/cgi/man.cgi?query=sdpd&amp;sektion=8&amp;format=html">sdpd(8)</a> daemon can be started with:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service sdpd start</span></code></pre></div></div><div class=paragraph><p>The local server application that wants to provide a Bluetooth service to remote clients will register the service with the local SDP daemon. An example of such an application is <a href="https://man.freebsd.org/cgi/man.cgi?query=rfcomm_pppd&amp;sektion=8&amp;format=html">rfcomm_pppd(8)</a>. Once started, it will register the Bluetooth LAN service with the local SDP daemon.</p></div><div class=paragraph><p>The list of services registered with the local SDP server can be obtained by issuing a SDP browse query via the local control channel:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sdpcontrol -l browse</span></code></pre></div></div></div><div class=sect3><h4 id=_obex_object_push_opush>31.5.5.4. OBEX Object Push (OPUSH)<a class=anchor href=#_obex_object_push_opush></a></h4><div class=paragraph><p>Object Exchange (OBEX) is a widely used protocol for simple file transfers between mobile devices. Its main use is in infrared communication, where it is used for generic file transfers between notebooks or PDAs, and for sending business cards or calendar entries between cellular phones and other devices with Personal Information Manager (PIM) applications.</p></div><div class=paragraph><p>The OBEX server and client are implemented by obexapp, which can be installed using the <a class=package href=https://cgit.freebsd.org/ports/tree/comms/obexapp/>comms/obexapp</a> package or port.</p></div><div class=paragraph><p>The OBEX client is used to push and/or pull objects from the OBEX server. An example object is a business card or an appointment. The OBEX client can obtain the RFCOMM channel number from the remote device via SDP. This can be done by specifying the service name instead of the RFCOMM channel number. Supported service names are: <code>IrMC</code>, <code>FTRN</code>, and <code>OPUSH</code>. It is also possible to specify the RFCOMM channel as a number. Below is an example of an OBEX session where the device information object is pulled from the cellular phone, and a new object, the business card, is pushed into the phone’s directory.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% obexapp <span class=nt>-a</span> 00:80:37:29:19:a4 <span class=nt>-C</span> IrMC
obex&gt; get telecom/devinfo.txt devinfo-t39.txt
Success, response: OK, Success <span class=o>(</span>0x20<span class=o>)</span>
obex&gt; put new.vcf
Success, response: OK, Success <span class=o>(</span>0x20<span class=o>)</span>
obex&gt; di
Success, response: OK, Success <span class=o>(</span>0x20<span class=o>)</span></code></pre></div></div><div class=paragraph><p>In order to provide the OPUSH service, <a href="https://man.freebsd.org/cgi/man.cgi?query=sdpd&amp;sektion=8&amp;format=html">sdpd(8)</a> must be running and a root folder, where all incoming objects will be stored, must be created. The default path to the root folder is <span class=filename>/var/spool/obex</span>. Finally, start the OBEX server on a valid RFCOMM channel number. The OBEX server will automatically register the OPUSH service with the local SDP daemon. The example below shows how to start the OBEX server.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># obexapp -s -C 10</span></code></pre></div></div></div><div class=sect3><h4 id=_serial_port_profile_spp>31.5.5.5. Serial Port Profile (SPP)<a class=anchor href=#_serial_port_profile_spp></a></h4><div class=paragraph><p>The Serial Port Profile (SPP) allows Bluetooth devices to perform serial cable emulation. This profile allows legacy applications to use Bluetooth as a cable replacement, through a virtual serial port abstraction.</p></div><div class=paragraph><p>In FreeBSD, <a href="https://man.freebsd.org/cgi/man.cgi?query=rfcomm_sppd&amp;sektion=1&amp;format=html">rfcomm_sppd(1)</a> implements SPP and a pseudo tty is used as a virtual serial port abstraction. The example below shows how to connect to a remote device’s serial port service. A RFCOMM channel does not have to be specified as <a href="https://man.freebsd.org/cgi/man.cgi?query=rfcomm_sppd&amp;sektion=1&amp;format=html">rfcomm_sppd(1)</a> can obtain it from the remote device via SDP. To override this, specify a RFCOMM channel on the command line.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># rfcomm_sppd -a 00:07:E0:00:0B:CA -t</span>
rfcomm_sppd[94692]: Starting on /dev/pts/6...
/dev/pts/6</code></pre></div></div><div class=paragraph><p>Once connected, the pseudo tty can be used as serial port:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cu -l /dev/pts/6</span></code></pre></div></div><div class=paragraph><p>The pseudo tty is printed on stdout and can be read by wrapper scripts:</p></div><div class="literalblock programlisting"><div class=content><pre>PTS=`rfcomm_sppd -a 00:07:E0:00:0B:CA -t`
cu -l $PTS</pre></div></div></div></div><div class=sect2><h3 id=_疑難排解_2>31.5.6. 疑難排解<a class=anchor href=#_疑難排解_2></a></h3><div class=paragraph><p>By default, when FreeBSD is accepting a new connection, it tries to perform a role switch and become master. Some older Bluetooth devices which do not support role switching will not be able to connect. Since role switching is performed when a new connection is being established, it is not possible to ask the remote device if it supports role switching. However, there is a HCI option to disable role switching on the local side:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># hccontrol -n ubt0hci write_node_role_switch 0</span></code></pre></div></div><div class=paragraph><p>To display Bluetooth packets, use the third-party package hcidump, which can be installed using the <a class=package href=https://cgit.freebsd.org/ports/tree/comms/hcidump/>comms/hcidump</a> package or port. This utility is similar to <a href="https://man.freebsd.org/cgi/man.cgi?query=tcpdump&amp;sektion=1&amp;format=html">tcpdump(1)</a> and can be used to display the contents of Bluetooth packets on the terminal and to dump the Bluetooth packets to a file.</p></div></div></div></div><div class=sect1><h2 id=network-bridging>31.6. 橋接<a class=anchor href=#network-bridging></a></h2><div class=sectionbody><div class=paragraph><p>It is sometimes useful to divide a network, such as an Ethernet segment, into network segments without having to create IP subnets and use a router to connect the segments together. A device that connects two networks together in this fashion is called a "bridge".</p></div><div class=paragraph><p>A bridge works by learning the MAC addresses of the devices on each of its network interfaces. It forwards traffic between networks only when the source and destination MAC addresses are on different networks. In many respects, a bridge is like an Ethernet switch with very few ports. A FreeBSD system with multiple network interfaces can be configured to act as a bridge.</p></div><div class=paragraph><p>Bridging can be useful in the following situations:</p></div><div class=dlist><dl><dt class=hdlist1>Connecting Networks</dt><dd><p>The basic operation of a bridge is to join two or more network segments. There are many reasons to use a host-based bridge instead of networking equipment, such as cabling constraints or firewalling. A bridge can also connect a wireless interface running in hostap mode to a wired network and act as an access point.</p></dd><dt class=hdlist1>Filtering/Traffic Shaping Firewall</dt><dd><p>A bridge can be used when firewall functionality is needed without routing or Network Address Translation (NAT).</p><div class=paragraph><p>An example is a small company that is connected via DSL or ISDN to an ISP. There are thirteen public IP addresses from the ISP and ten computers on the network. In this situation, using a router-based firewall is difficult because of subnetting issues. A bridge-based firewall can be configured without any IP addressing issues.</p></div></dd><dt class=hdlist1>Network Tap</dt><dd><p>A bridge can join two network segments in order to inspect all Ethernet frames that pass between them using <a href="https://man.freebsd.org/cgi/man.cgi?query=bpf&amp;sektion=4&amp;format=html">bpf(4)</a> and <a href="https://man.freebsd.org/cgi/man.cgi?query=tcpdump&amp;sektion=1&amp;format=html">tcpdump(1)</a> on the bridge interface or by sending a copy of all frames out an additional interface known as a span port.</p></dd><dt class=hdlist1>Layer 2 VPN</dt><dd><p>Two Ethernet networks can be joined across an IP link by bridging the networks to an EtherIP tunnel or a <a href="https://man.freebsd.org/cgi/man.cgi?query=tap&amp;sektion=4&amp;format=html">tap(4)</a> based solution such as OpenVPN.</p></dd><dt class=hdlist1>Layer 2 Redundancy</dt><dd><p>A network can be connected together with multiple links and use the Spanning Tree Protocol (STP) to block redundant paths.</p></dd></dl></div><div class=paragraph><p>This section describes how to configure a FreeBSD system as a bridge using <a href="https://man.freebsd.org/cgi/man.cgi?query=if_bridge&amp;sektion=4&amp;format=html">if_bridge(4)</a>. A netgraph bridging driver is also available, and is described in <a href="https://man.freebsd.org/cgi/man.cgi?query=ng_bridge&amp;sektion=4&amp;format=html">ng_bridge(4)</a>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Packet filtering can be used with any firewall package that hooks into the <a href="https://man.freebsd.org/cgi/man.cgi?query=pfil&amp;sektion=9&amp;format=html">pfil(9)</a> framework. The bridge can be used as a traffic shaper with <a href="https://man.freebsd.org/cgi/man.cgi?query=altq&amp;sektion=4&amp;format=html">altq(4)</a> or <a href="https://man.freebsd.org/cgi/man.cgi?query=dummynet&amp;sektion=4&amp;format=html">dummynet(4)</a>.</p></div></td></tr></tbody></table></div><div class=sect2><h3 id=_開啟橋接>31.6.1. 開啟橋接<a class=anchor href=#_開啟橋接></a></h3><div class=paragraph><p>In FreeBSD, <a href="https://man.freebsd.org/cgi/man.cgi?query=if_bridge&amp;sektion=4&amp;format=html">if_bridge(4)</a> is a kernel module which is automatically loaded by <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a> when creating a bridge interface. It is also possible to compile bridge support into a custom kernel by adding <code>device if_bridge</code> to the custom kernel configuration file.</p></div><div class=paragraph><p>The bridge is created using interface cloning. To create the bridge interface:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig bridge create</span>
bridge0
<span class=c># ifconfig bridge0</span>
bridge0: <span class=nv>flags</span><span class=o>=</span>8802&lt;BROADCAST,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        ether 96:3d:4b:f1:79:7a
        <span class=nb>id </span>00:00:00:00:00:00 priority 32768 hellotime 2 fwddelay 15
        maxage 20 holdcnt 6 proto rstp maxaddr 100 <span class=nb>timeout </span>1200
        root <span class=nb>id </span>00:00:00:00:00:00 priority 0 ifcost 0 port 0</code></pre></div></div><div class=paragraph><p>When a bridge interface is created, it is automatically assigned a randomly generated Ethernet address. The <code>maxaddr</code> and <code>timeout</code> parameters control how many MAC addresses the bridge will keep in its forwarding table and how many seconds before each entry is removed after it is last seen. The other parameters control how STP operates.</p></div><div class=paragraph><p>Next, specify which network interfaces to add as members of the bridge. For the bridge to forward packets, all member interfaces and the bridge need to be up:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig bridge0 addm fxp0 addm fxp1 up</span>
<span class=c># ifconfig fxp0 up</span>
<span class=c># ifconfig fxp1 up</span></code></pre></div></div><div class=paragraph><p>The bridge can now forward Ethernet frames between <span class=filename>fxp0</span> and <span class=filename>fxp1</span>. Add the following lines to <span class=filename>/etc/rc.conf</span> so the bridge is created at startup:</p></div><div class="literalblock programlisting"><div class=content><pre>cloned_interfaces=&#34;bridge0&#34;
ifconfig_bridge0=&#34;addm fxp0 addm fxp1 up&#34;
ifconfig_fxp0=&#34;up&#34;
ifconfig_fxp1=&#34;up&#34;</pre></div></div><div class=paragraph><p>If the bridge host needs an IP address, set it on the bridge interface, not on the member interfaces. The address can be set statically or via DHCP. This example sets a static IP address:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig bridge0 inet 192.168.0.1/24</span></code></pre></div></div><div class=paragraph><p>It is also possible to assign an IPv6 address to a bridge interface. To make the changes permanent, add the addressing information to <span class=filename>/etc/rc.conf</span>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>When packet filtering is enabled, bridged packets will pass through the filter inbound on the originating interface on the bridge interface, and outbound on the appropriate interfaces. Either stage can be disabled. When direction of the packet flow is important, it is best to firewall on the member interfaces rather than the bridge itself.</p></div><div class=paragraph><p>The bridge has several configurable settings for passing non-IP and IP packets, and layer2 firewalling with <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfw&amp;sektion=8&amp;format=html">ipfw(8)</a>. See <a href="https://man.freebsd.org/cgi/man.cgi?query=if_bridge&amp;sektion=4&amp;format=html">if_bridge(4)</a> for more information.</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=_開啟_spanning_tree>31.6.2. 開啟 Spanning Tree<a class=anchor href=#_開啟_spanning_tree></a></h3><div class=paragraph><p>For an Ethernet network to function properly, only one active path can exist between two devices. The STP protocol detects loops and puts redundant links into a blocked state. Should one of the active links fail, STP calculates a different tree and enables one of the blocked paths to restore connectivity to all points in the network.</p></div><div class=paragraph><p>The Rapid Spanning Tree Protocol (RSTP or 802.1w) provides backwards compatibility with legacy STP. RSTP provides faster convergence and exchanges information with neighboring switches to quickly transition to forwarding mode without creating loops. FreeBSD supports RSTP and STP as operating modes, with RSTP being the default mode.</p></div><div class=paragraph><p>STP can be enabled on member interfaces using <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a>. For a bridge with <span class=filename>fxp0</span> and <span class=filename>fxp1</span> as the current interfaces, enable STP with:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig bridge0 stp fxp0 stp fxp1</span>
bridge0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        ether d6:cf:d5:a0:94:6d
        <span class=nb>id </span>00:01:02:4b:d4:50 priority 32768 hellotime 2 fwddelay 15
        maxage 20 holdcnt 6 proto rstp maxaddr 100 <span class=nb>timeout </span>1200
        root <span class=nb>id </span>00:01:02:4b:d4:50 priority 32768 ifcost 0 port 0
        member: fxp0 <span class=nv>flags</span><span class=o>=</span>1c7&lt;LEARNING,DISCOVER,STP,AUTOEDGE,PTP,AUTOPTP&gt;
                port 3 priority 128 path cost 200000 proto rstp
                role designated state forwarding
        member: fxp1 <span class=nv>flags</span><span class=o>=</span>1c7&lt;LEARNING,DISCOVER,STP,AUTOEDGE,PTP,AUTOPTP&gt;
                port 4 priority 128 path cost 200000 proto rstp
                role designated state forwarding</code></pre></div></div><div class=paragraph><p>This bridge has a spanning tree ID of <code>00:01:02:4b:d4:50</code> and a priority of <code>32768</code>. As the <code>root id</code> is the same, it indicates that this is the root bridge for the tree.</p></div><div class=paragraph><p>Another bridge on the network also has STP enabled:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>bridge0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        ether 96:3d:4b:f1:79:7a
        <span class=nb>id </span>00:13:d4:9a:06:7a priority 32768 hellotime 2 fwddelay 15
        maxage 20 holdcnt 6 proto rstp maxaddr 100 <span class=nb>timeout </span>1200
        root <span class=nb>id </span>00:01:02:4b:d4:50 priority 32768 ifcost 400000 port 4
        member: fxp0 <span class=nv>flags</span><span class=o>=</span>1c7&lt;LEARNING,DISCOVER,STP,AUTOEDGE,PTP,AUTOPTP&gt;
                port 4 priority 128 path cost 200000 proto rstp
                role root state forwarding
        member: fxp1 <span class=nv>flags</span><span class=o>=</span>1c7&lt;LEARNING,DISCOVER,STP,AUTOEDGE,PTP,AUTOPTP&gt;
                port 5 priority 128 path cost 200000 proto rstp
                role designated state forwarding</code></pre></div></div><div class=paragraph><p>The line <code>root id 00:01:02:4b:d4:50 priority 32768 ifcost 400000 port 4</code> shows that the root bridge is <code>00:01:02:4b:d4:50</code> and has a path cost of <code>400000</code> from this bridge. The path to the root bridge is via <code>port 4</code> which is <span class=filename>fxp0</span>.</p></div></div><div class=sect2><h3 id=_橋接介面參數>31.6.3. 橋接介面參數<a class=anchor href=#_橋接介面參數></a></h3><div class=paragraph><p>Several <code>ifconfig</code> parameters are unique to bridge interfaces. This section summarizes some common uses for these parameters. The complete list of available parameters is described in <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a>.</p></div><div class=dlist><dl><dt class=hdlist1>private</dt><dd><p>A private interface does not forward any traffic to any other port that is also designated as a private interface. The traffic is blocked unconditionally so no Ethernet frames will be forwarded, including ARP packets. If traffic needs to be selectively blocked, a firewall should be used instead.</p></dd><dt class=hdlist1>span</dt><dd><p>A span port transmits a copy of every Ethernet frame received by the bridge. The number of span ports configured on a bridge is unlimited, but if an interface is designated as a span port, it cannot also be used as a regular bridge port. This is most useful for snooping a bridged network passively on another host connected to one of the span ports of the bridge. For example, to send a copy of all frames out the interface named <span class=filename>fxp4</span>:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig bridge0 span fxp4</span></code></pre></div></div></dd><dt class=hdlist1>sticky</dt><dd><p>If a bridge member interface is marked as sticky, dynamically learned address entries are treated as static entries in the forwarding cache. Sticky entries are never aged out of the cache or replaced, even if the address is seen on a different interface. This gives the benefit of static address entries without the need to pre-populate the forwarding table. Clients learned on a particular segment of the bridge cannot roam to another segment.</p><div class=paragraph><p>An example of using sticky addresses is to combine the bridge with VLANs in order to isolate customer networks without wasting IP address space. Consider that <code>CustomerA</code> is on <code>vlan100</code>, <code>CustomerB</code> is on <code>vlan101</code>, and the bridge has the address <code>192.168.0.1</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig bridge0 addm vlan100 sticky vlan100 addm vlan101 sticky vlan101</span>
<span class=c># ifconfig bridge0 inet 192.168.0.1/24</span></code></pre></div></div><div class=paragraph><p>In this example, both clients see <code>192.168.0.1</code> as their default gateway. Since the bridge cache is sticky, one host cannot spoof the MAC address of the other customer in order to intercept their traffic.</p></div><div class=paragraph><p>Any communication between the VLANs can be blocked using a firewall or, as seen in this example, private interfaces:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig bridge0 private vlan100 private vlan101</span></code></pre></div></div><div class=paragraph><p>The customers are completely isolated from each other and the full <code>/24</code> address range can be allocated without subnetting.</p></div><div class=paragraph><p>The number of unique source MAC addresses behind an interface can be limited. Once the limit is reached, packets with unknown source addresses are dropped until an existing host cache entry expires or is removed.</p></div><div class=paragraph><p>The following example sets the maximum number of Ethernet devices for <code>CustomerA</code> on <code>vlan100</code> to 10:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig bridge0 ifmaxaddr vlan100 10</span></code></pre></div></div></dd></dl></div><div class=paragraph><p>Bridge interfaces also support monitor mode, where the packets are discarded after <a href="https://man.freebsd.org/cgi/man.cgi?query=bpf&amp;sektion=4&amp;format=html">bpf(4)</a> processing and are not processed or forwarded further. This can be used to multiplex the input of two or more interfaces into a single <a href="https://man.freebsd.org/cgi/man.cgi?query=bpf&amp;sektion=4&amp;format=html">bpf(4)</a> stream. This is useful for reconstructing the traffic for network taps that transmit the RX/TX signals out through two separate interfaces. For example, to read the input from four network interfaces as one stream:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig bridge0 addm fxp0 addm fxp1 addm fxp2 addm fxp3 monitor up</span>
<span class=c># tcpdump -i bridge0</span></code></pre></div></div></div><div class=sect2><h3 id=_snmp_監視>31.6.4. SNMP 監視<a class=anchor href=#_snmp_監視></a></h3><div class=paragraph><p>The bridge interface and STP parameters can be monitored via <a href="https://man.freebsd.org/cgi/man.cgi?query=bsnmpd&amp;sektion=1&amp;format=html">bsnmpd(1)</a> which is included in the FreeBSD base system. The exported bridge MIBs conform to IETF standards so any SNMP client or monitoring package can be used to retrieve the data.</p></div><div class=paragraph><p>To enable monitoring on the bridge, uncomment this line in <span class=filename>/etc/snmpd.config</span> by removing the beginning <code>#</code> symbol:</p></div><div class="literalblock programlisting"><div class=content><pre>begemotSnmpdModulePath.&#34;bridge&#34; = &#34;/usr/lib/snmp_bridge.so&#34;</pre></div></div><div class=paragraph><p>Other configuration settings, such as community names and access lists, may need to be modified in this file. See <a href="https://man.freebsd.org/cgi/man.cgi?query=bsnmpd&amp;sektion=1&amp;format=html">bsnmpd(1)</a> and <a href="https://man.freebsd.org/cgi/man.cgi?query=snmp_bridge&amp;sektion=3&amp;format=html">snmp_bridge(3)</a> for more information. Once these edits are saved, add this line to <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>bsnmpd_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Then, start <a href="https://man.freebsd.org/cgi/man.cgi?query=bsnmpd&amp;sektion=1&amp;format=html">bsnmpd(1)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service bsnmpd start</span></code></pre></div></div><div class=paragraph><p>The following examples use the Net-SNMP software (<a class=package href=https://cgit.freebsd.org/ports/tree/net-mgmt/net-snmp/>net-mgmt/net-snmp</a>) to query a bridge from a client system. The <a class=package href=https://cgit.freebsd.org/ports/tree/net-mgmt/bsnmptools/>net-mgmt/bsnmptools</a> port can also be used. From the SNMP client which is running Net-SNMP, add the following lines to <span class=filename>$HOME/.snmp/snmp.conf</span> in order to import the bridge MIB definitions:</p></div><div class="literalblock programlisting"><div class=content><pre>mibdirs +/usr/shared/snmp/mibs
mibs +BRIDGE-MIB:RSTP-MIB:BEGEMOT-MIB:BEGEMOT-BRIDGE-MIB</pre></div></div><div class=paragraph><p>To monitor a single bridge using the IETF BRIDGE-MIB (RFC4188):</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% snmpwalk <span class=nt>-v</span> 2c <span class=nt>-c</span> public bridge1.example.com mib-2.dot1dBridge
BRIDGE-MIB::dot1dBaseBridgeAddress.0 <span class=o>=</span> STRING: 66:fb:9b:6e:5c:44
BRIDGE-MIB::dot1dBaseNumPorts.0 <span class=o>=</span> INTEGER: 1 ports
BRIDGE-MIB::dot1dStpTimeSinceTopologyChange.0 <span class=o>=</span> Timeticks: <span class=o>(</span>189959<span class=o>)</span> 0:31:39.59 centi-seconds
BRIDGE-MIB::dot1dStpTopChanges.0 <span class=o>=</span> Counter32: 2
BRIDGE-MIB::dot1dStpDesignatedRoot.0 <span class=o>=</span> Hex-STRING: 80 00 00 01 02 4B D4 50
...
BRIDGE-MIB::dot1dStpPortState.3 <span class=o>=</span> INTEGER: forwarding<span class=o>(</span>5<span class=o>)</span>
BRIDGE-MIB::dot1dStpPortEnable.3 <span class=o>=</span> INTEGER: enabled<span class=o>(</span>1<span class=o>)</span>
BRIDGE-MIB::dot1dStpPortPathCost.3 <span class=o>=</span> INTEGER: 200000
BRIDGE-MIB::dot1dStpPortDesignatedRoot.3 <span class=o>=</span> Hex-STRING: 80 00 00 01 02 4B D4 50
BRIDGE-MIB::dot1dStpPortDesignatedCost.3 <span class=o>=</span> INTEGER: 0
BRIDGE-MIB::dot1dStpPortDesignatedBridge.3 <span class=o>=</span> Hex-STRING: 80 00 00 01 02 4B D4 50
BRIDGE-MIB::dot1dStpPortDesignatedPort.3 <span class=o>=</span> Hex-STRING: 03 80
BRIDGE-MIB::dot1dStpPortForwardTransitions.3 <span class=o>=</span> Counter32: 1
RSTP-MIB::dot1dStpVersion.0 <span class=o>=</span> INTEGER: rstp<span class=o>(</span>2<span class=o>)</span></code></pre></div></div><div class=paragraph><p>The <code>dot1dStpTopChanges.0</code> value is two, indicating that the STP bridge topology has changed twice. A topology change means that one or more links in the network have changed or failed and a new tree has been calculated. The <code>dot1dStpTimeSinceTopologyChange.0</code> value will show when this happened.</p></div><div class=paragraph><p>To monitor multiple bridge interfaces, the private BEGEMOT-BRIDGE-MIB can be used:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% snmpwalk <span class=nt>-v</span> 2c <span class=nt>-c</span> public bridge1.example.com
enterprises.fokus.begemot.begemotBridge
BEGEMOT-BRIDGE-MIB::begemotBridgeBaseName.<span class=s2>&#34;bridge0&#34;</span> <span class=o>=</span> STRING: bridge0
BEGEMOT-BRIDGE-MIB::begemotBridgeBaseName.<span class=s2>&#34;bridge2&#34;</span> <span class=o>=</span> STRING: bridge2
BEGEMOT-BRIDGE-MIB::begemotBridgeBaseAddress.<span class=s2>&#34;bridge0&#34;</span> <span class=o>=</span> STRING: e:ce:3b:5a:9e:13
BEGEMOT-BRIDGE-MIB::begemotBridgeBaseAddress.<span class=s2>&#34;bridge2&#34;</span> <span class=o>=</span> STRING: 12:5e:4d:74:d:fc
BEGEMOT-BRIDGE-MIB::begemotBridgeBaseNumPorts.<span class=s2>&#34;bridge0&#34;</span> <span class=o>=</span> INTEGER: 1
BEGEMOT-BRIDGE-MIB::begemotBridgeBaseNumPorts.<span class=s2>&#34;bridge2&#34;</span> <span class=o>=</span> INTEGER: 1
...
BEGEMOT-BRIDGE-MIB::begemotBridgeStpTimeSinceTopologyChange.<span class=s2>&#34;bridge0&#34;</span> <span class=o>=</span> Timeticks: <span class=o>(</span>116927<span class=o>)</span> 0:19:29.27 centi-seconds
BEGEMOT-BRIDGE-MIB::begemotBridgeStpTimeSinceTopologyChange.<span class=s2>&#34;bridge2&#34;</span> <span class=o>=</span> Timeticks: <span class=o>(</span>82773<span class=o>)</span> 0:13:47.73 centi-seconds
BEGEMOT-BRIDGE-MIB::begemotBridgeStpTopChanges.<span class=s2>&#34;bridge0&#34;</span> <span class=o>=</span> Counter32: 1
BEGEMOT-BRIDGE-MIB::begemotBridgeStpTopChanges.<span class=s2>&#34;bridge2&#34;</span> <span class=o>=</span> Counter32: 1
BEGEMOT-BRIDGE-MIB::begemotBridgeStpDesignatedRoot.<span class=s2>&#34;bridge0&#34;</span> <span class=o>=</span> Hex-STRING: 80 00 00 40 95 30 5E 31
BEGEMOT-BRIDGE-MIB::begemotBridgeStpDesignatedRoot.<span class=s2>&#34;bridge2&#34;</span> <span class=o>=</span> Hex-STRING: 80 00 00 50 8B B8 C6 A9</code></pre></div></div><div class=paragraph><p>To change the bridge interface being monitored via the <code>mib-2.dot1dBridge</code> subtree:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% snmpset <span class=nt>-v</span> 2c <span class=nt>-c</span> private bridge1.example.com
BEGEMOT-BRIDGE-MIB::begemotBridgeDefaultBridgeIf.0 s bridge2</code></pre></div></div></div></div></div><div class=sect1><h2 id=network-aggregation>31.7. Link Aggregation 與容錯移轉<a class=anchor href=#network-aggregation></a></h2><div class=sectionbody><div class=paragraph><p>FreeBSD provides the <a href="https://man.freebsd.org/cgi/man.cgi?query=lagg&amp;sektion=4&amp;format=html">lagg(4)</a> interface which can be used to aggregate multiple network interfaces into one virtual interface in order to provide failover and link aggregation. Failover allows traffic to continue to flow as long as at least one aggregated network interface has an established link. Link aggregation works best on switches which support LACP, as this protocol distributes traffic bi-directionally while responding to the failure of individual links.</p></div><div class=paragraph><p>The aggregation protocols supported by the lagg interface determine which ports are used for outgoing traffic and whether or not a specific port accepts incoming traffic. The following protocols are supported by <a href="https://man.freebsd.org/cgi/man.cgi?query=lagg&amp;sektion=4&amp;format=html">lagg(4)</a>:</p></div><div class=dlist><dl><dt class=hdlist1>failover</dt><dd><p>This mode sends and receives traffic only through the master port. If the master port becomes unavailable, the next active port is used. The first interface added to the virtual interface is the master port and all subsequently added interfaces are used as failover devices. If failover to a non-master port occurs, the original port becomes master once it becomes available again.</p></dd><dt class=hdlist1>fec / loadbalance</dt><dd><p>Cisco™ Fast EtherChannel™ (FEC) is found on older Cisco™ switches. It provides a static setup and does not negotiate aggregation with the peer or exchange frames to monitor the link. If the switch supports LACP, that should be used instead.</p></dd><dt class=hdlist1>lacp</dt><dd><p>The IEEE™ 802.3ad Link Aggregation Control Protocol (LACP) negotiates a set of aggregable links with the peer into one or more Link Aggregated Groups (LAGs). Each LAG is composed of ports of the same speed, set to full-duplex operation, and traffic is balanced across the ports in the LAG with the greatest total speed. Typically, there is only one LAG which contains all the ports. In the event of changes in physical connectivity, LACP will quickly converge to a new configuration.</p><div class=paragraph><p>LACP balances outgoing traffic across the active ports based on hashed protocol header information and accepts incoming traffic from any active port. The hash includes the Ethernet source and destination address and, if available, the VLAN tag, and the IPv4 or IPv6 source and destination address.</p></div></dd><dt class=hdlist1>roundrobin</dt><dd><p>This mode distributes outgoing traffic using a round-robin scheduler through all active ports and accepts incoming traffic from any active port. Since this mode violates Ethernet frame ordering, it should be used with caution.</p></dd></dl></div><div class=sect2><h3 id=_設定範例>31.7.1. 設定範例<a class=anchor href=#_設定範例></a></h3><div class=paragraph><p>This section demonstrates how to configure a Cisco™ switch and a FreeBSD system for LACP load balancing. It then shows how to configure two Ethernet interfaces in failover mode as well as how to configure failover mode between an Ethernet and a wireless interface.</p></div><div id=networking-lacp-aggregation-cisco class=exampleblock><div class=title>例 1. Cisco™ 交換器上設定 LACP Aggregation</div><div class=content><div class=paragraph><p>This example connects two <a href="https://man.freebsd.org/cgi/man.cgi?query=fxp&amp;sektion=4&amp;format=html">fxp(4)</a> Ethernet interfaces on a FreeBSD machine to the first two Ethernet ports on a Cisco™ switch as a single load balanced and fault tolerant link. More interfaces can be added to increase throughput and fault tolerance. Replace the names of the Cisco™ ports, Ethernet devices, channel group number, and IP address shown in the example to match the local configuration.</p></div><div class=paragraph><p>Frame ordering is mandatory on Ethernet links and any traffic between two stations always flows over the same physical link, limiting the maximum speed to that of one interface. The transmit algorithm attempts to use as much information as it can to distinguish different traffic flows and balance the flows across the available interfaces.</p></div><div class=paragraph><p>On the Cisco™ switch, add the <em>FastEthernet0/1</em> and <em>FastEthernet0/2</em> interfaces to channel group <em>1</em>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>interface FastEthernet0/1
 channel-group 1 mode active
 channel-protocol lacp
<span class=o>!</span>
interface FastEthernet0/2
 channel-group 1 mode active
 channel-protocol lacp</code></pre></div></div><div class=paragraph><p>On the FreeBSD system, create the <a href="https://man.freebsd.org/cgi/man.cgi?query=lagg&amp;sektion=4&amp;format=html">lagg(4)</a> interface using the physical interfaces <em>fxp0</em> and <em>fxp1</em> and bring the interfaces up with an IP address of <em>10.0.0.3/24</em>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig fxp0 up</span>
<span class=c># ifconfig fxp1 up</span>
<span class=c># ifconfig lagg0 create</span>
<span class=c># ifconfig lagg0 up laggproto lacp laggport fxp0 laggport fxp1 10.0.0.3/24</span></code></pre></div></div><div class=paragraph><p>Next, verify the status of the virtual interface:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig lagg0</span>
lagg0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        <span class=nv>options</span><span class=o>=</span>8&lt;VLAN_MTU&gt;
        ether 00:05:5d:71:8d:b8
        inet 10.0.0.3 netmask 0xffffff00 broadcast 10.0.0.255
        media: Ethernet autoselect
        status: active
        laggproto lacp
        laggport: fxp1 <span class=nv>flags</span><span class=o>=</span>1c&lt;ACTIVE,COLLECTING,DISTRIBUTING&gt;
        laggport: fxp0 <span class=nv>flags</span><span class=o>=</span>1c&lt;ACTIVE,COLLECTING,DISTRIBUTING&gt;</code></pre></div></div><div class=paragraph><p>Ports marked as <code>ACTIVE</code> are part of the LAG that has been negotiated with the remote switch. Traffic will be transmitted and received through these active ports. Add <code>-v</code> to the above command to view the LAG identifiers.</p></div><div class=paragraph><p>To see the port status on the Cisco™ switch:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>switch# show lacp neighbor
Flags:  S - Device is requesting Slow LACPDUs
        F - Device is requesting Fast LACPDUs
        A - Device is <span class=k>in </span>Active mode       P - Device is <span class=k>in </span>Passive mode

Channel group 1 neighbors

Partner<span class=s1>&#39;s information:

                  LACP port                        Oper    Port     Port
Port      Flags   Priority  Dev ID         Age     Key     Number   State
Fa0/1     SA      32768     0005.5d71.8db8  29s    0x146   0x3      0x3D
Fa0/2     SA      32768     0005.5d71.8db8  29s    0x146   0x4      0x3D</span></code></pre></div></div><div class=paragraph><p>For more detail, type <code>show lacp neighbor detail</code>.</p></div><div class=paragraph><p>To retain this configuration across reboots, add the following entries to <span class=filename>/etc/rc.conf</span> on the FreeBSD system:</p></div><div class="literalblock programlisting"><div class=content><pre>ifconfig_fxp0=&#34;up&#34;
ifconfig_fxp1=&#34;up&#34;
cloned_interfaces=&#34;lagg0&#34;
ifconfig_lagg0=&#34;laggproto lacp laggport fxp0 laggport fxp1 10.0.0.3/24&#34;</pre></div></div></div></div><div id=networking-lagg-failover class=exampleblock><div class=title>例 2. 容錯移轉模式</div><div class=content><div class=paragraph><p>Failover mode can be used to switch over to a secondary interface if the link is lost on the master interface. To configure failover, make sure that the underlying physical interfaces are up, then create the <a href="https://man.freebsd.org/cgi/man.cgi?query=lagg&amp;sektion=4&amp;format=html">lagg(4)</a> interface. In this example, <em>fxp0</em> is the master interface, <em>fxp1</em> is the secondary interface, and the virtual interface is assigned an IP address of <em>10.0.0.15/24</em>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig fxp0 up</span>
<span class=c># ifconfig fxp1 up</span>
<span class=c># ifconfig lagg0 create</span>
<span class=c># ifconfig lagg0 up laggproto failover laggport fxp0 laggport fxp1 10.0.0.15/24</span></code></pre></div></div><div class=paragraph><p>The virtual interface should look something like this:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig lagg0</span>
lagg0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        <span class=nv>options</span><span class=o>=</span>8&lt;VLAN_MTU&gt;
        ether 00:05:5d:71:8d:b8
        inet 10.0.0.15 netmask 0xffffff00 broadcast 10.0.0.255
        media: Ethernet autoselect
        status: active
        laggproto failover
        laggport: fxp1 <span class=nv>flags</span><span class=o>=</span>0&lt;<span class=o>&gt;</span>
        laggport: fxp0 <span class=nv>flags</span><span class=o>=</span>5&lt;MASTER,ACTIVE&gt;</code></pre></div></div><div class=paragraph><p>Traffic will be transmitted and received on <em>fxp0</em>. If the link is lost on <em>fxp0</em>, <em>fxp1</em> will become the active link. If the link is restored on the master interface, it will once again become the active link.</p></div><div class=paragraph><p>To retain this configuration across reboots, add the following entries to <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>ifconfig_fxp0=&#34;up&#34;
ifconfig_fxp1=&#34;up&#34;
cloned_interfaces=&#34;lagg0&#34;
ifconfig_lagg0=&#34;laggproto failover laggport fxp0 laggport fxp1 10.0.0.15/24&#34;</pre></div></div></div></div><div id=networking-lagg-wired-and-wireless class=exampleblock><div class=title>例 3. 乙太網路與無線介面間的容錯移轉模式</div><div class=content><div class=paragraph><p>For laptop users, it is usually desirable to configure the wireless device as a secondary which is only used when the Ethernet connection is not available. With <a href="https://man.freebsd.org/cgi/man.cgi?query=lagg&amp;sektion=4&amp;format=html">lagg(4)</a>, it is possible to configure a failover which prefers the Ethernet connection for both performance and security reasons, while maintaining the ability to transfer data over the wireless connection.</p></div><div class=paragraph><p>This is achieved by overriding the physical wireless interface’s MAC address with that of the Ethernet interface.</p></div><div class=paragraph><p>In this example, the Ethernet interface, <em>bge0</em>, is the master and the wireless interface, <em>wlan0</em>, is the failover. The <em>wlan0</em> device was created from <em>iwn0</em> wireless interface, which will be configured with the MAC address of the Ethernet interface. First, determine the MAC address of the Ethernet interface:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig bge0</span>
bge0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
	<span class=nv>options</span><span class=o>=</span>19b&lt;RXCSUM,TXCSUM,VLAN_MTU,VLAN_HWTAGGING,VLAN_HWCSUM,TSO4&gt;
	ether 00:21:70:da:ae:37
	inet6 fe80::221:70ff:feda:ae37%bge0 prefixlen 64 scopeid 0x2
	nd6 <span class=nv>options</span><span class=o>=</span>29&lt;PERFORMNUD,IFDISABLED,AUTO_LINKLOCAL&gt;
	media: Ethernet autoselect <span class=o>(</span>1000baseT &lt;full-duplex&gt;<span class=o>)</span>
	status: active</code></pre></div></div><div class=paragraph><p>Replace <em>bge0</em> to match the system’s Ethernet interface name. The <code>ether</code> line will contain the MAC address of the specified interface. Now, change the MAC address of the underlying wireless interface:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig iwn0 ether 00:21:70:da:ae:37</span></code></pre></div></div><div class=paragraph><p>Bring the wireless interface up, but do not set an IP address:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0 create wlandev iwn0 ssid my_router up</span></code></pre></div></div><div class=paragraph><p>Make sure the <em>bge0</em> interface is up, then create the <a href="https://man.freebsd.org/cgi/man.cgi?query=lagg&amp;sektion=4&amp;format=html">lagg(4)</a> interface with <em>bge0</em> as master with failover to <em>wlan0</em>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig bge0 up</span>
<span class=c># ifconfig lagg0 create</span>
<span class=c># ifconfig lagg0 up laggproto failover laggport bge0 laggport wlan0</span></code></pre></div></div><div class=paragraph><p>The virtual interface should look something like this:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig lagg0</span>
lagg0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        <span class=nv>options</span><span class=o>=</span>8&lt;VLAN_MTU&gt;
        ether 00:21:70:da:ae:37
        media: Ethernet autoselect
        status: active
        laggproto failover
        laggport: wlan0 <span class=nv>flags</span><span class=o>=</span>0&lt;<span class=o>&gt;</span>
        laggport: bge0 <span class=nv>flags</span><span class=o>=</span>5&lt;MASTER,ACTIVE&gt;</code></pre></div></div><div class=paragraph><p>Then, start the DHCP client to obtain an IP address:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dhclient lagg0</span></code></pre></div></div><div class=paragraph><p>To retain this configuration across reboots, add the following entries to <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>ifconfig_bge0=&#34;up&#34;
wlans_iwn0=&#34;wlan0&#34;
ifconfig_wlan0=&#34;WPA&#34;
create_args_wlan0=&#34;wlanaddr 00:21:70:da:ae:37&#34;
cloned_interfaces=&#34;lagg0&#34;
ifconfig_lagg0=&#34;up laggproto failover laggport bge0 laggport wlan0 DHCP&#34;</pre></div></div></div></div></div></div></div><div class=sect1><h2 id=network-diskless>31.8. PXE 無磁碟作業<a class=anchor href=#network-diskless></a></h2><div class=sectionbody><div class=paragraph><p>The Intel™ Preboot eXecution Environment (PXE) allows an operating system to boot over the network. For example, a FreeBSD system can boot over the network and operate without a local disk, using file systems mounted from an NFS server. PXE support is usually available in the BIOS. To use PXE when the machine starts, select the <code>Boot from network</code> option in the BIOS setup or type a function key during system initialization.</p></div><div class=paragraph><p>In order to provide the files needed for an operating system to boot over the network, a PXE setup also requires properly configured DHCP, TFTP, and NFS servers, where:</p></div><div class=ulist><ul><li><p>Initial parameters, such as an IP address, executable boot filename and location, server name, and root path are obtained from the DHCP server.</p></li><li><p>The operating system loader file is booted using TFTP.</p></li><li><p>The file systems are loaded using NFS.</p></li></ul></div><div class=paragraph><p>When a computer PXE boots, it receives information over DHCP about where to obtain the initial boot loader file. After the host computer receives this information, it downloads the boot loader via TFTP and then executes the boot loader. In FreeBSD, the boot loader file is <span class=filename>/boot/pxeboot</span>. After <span class=filename>/boot/pxeboot</span> executes, the FreeBSD kernel is loaded and the rest of the FreeBSD bootup sequence proceeds, as described in <a href=../boot/#boot>FreeBSD 開機程序</a>.</p></div><div class=paragraph><p>This section describes how to configure these services on a FreeBSD system so that other systems can PXE boot into FreeBSD. Refer to <a href="https://man.freebsd.org/cgi/man.cgi?query=diskless&amp;sektion=8&amp;format=html">diskless(8)</a> for more information.</p></div><div class="admonitionblock caution"><table><tbody><tr><td class=icon><i class="fa icon-caution" title=Caution></i></td><td class=content><div class=paragraph><p>As described, the system providing these services is insecure. It should live in a protected area of a network and be untrusted by other hosts.</p></div></td></tr></tbody></table></div><div class=sect2><h3 id=network-pxe-nfs>31.8.1. 設定 PXE 環境<a class=anchor href=#network-pxe-nfs></a></h3><div class=paragraph><p>The steps shown in this section configure the built-in NFS and TFTP servers. The next section demonstrates how to install and configure the DHCP server. In this example, the directory which will contain the files used by PXE users is <span class=filename>/b/tftpboot/FreeBSD/install</span>. It is important that this directory exists and that the same directory name is set in both <span class=filename>/etc/inetd.conf</span> and <span class=filename>/usr/local/etc/dhcpd.conf</span>.</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Create the root directory which will contain a FreeBSD installation to be NFS mounted:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># export NFSROOTDIR=/b/tftpboot/FreeBSD/install</span>
<span class=c># mkdir -p ${NFSROOTDIR}</span></code></pre></div></div></li><li><p>Enable the NFS server by adding this line to <span class=filename>/etc/rc.conf</span>:</p><div class="literalblock programlisting"><div class=content><pre>nfs_server_enable=&#34;YES&#34;</pre></div></div></li><li><p>Export the diskless root directory via NFS by adding the following to <span class=filename>/etc/exports</span>:</p><div class="literalblock programlisting"><div class=content><pre>/b -ro -alldirs -maproot=root</pre></div></div></li><li><p>Start the NFS server:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service nfsd start</span></code></pre></div></div></li><li><p>Enable <a href="https://man.freebsd.org/cgi/man.cgi?query=inetd&amp;sektion=8&amp;format=html">inetd(8)</a> by adding the following line to <span class=filename>/etc/rc.conf</span>:</p><div class="literalblock programlisting"><div class=content><pre>inetd_enable=&#34;YES&#34;</pre></div></div></li><li><p>Uncomment the following line in <span class=filename>/etc/inetd.conf</span> by making sure it does not start with a <code>#</code> symbol:</p><div class="literalblock programlisting"><div class=content><pre>tftp dgram udp wait root /usr/libexec/tftpd tftpd -l -s /b/tftpboot</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Some PXE versions require the TCP version of TFTP. In this case, uncomment the second <code>tftp</code> line which contains <code>stream tcp</code>.</p></div></td></tr></tbody></table></div></li><li><p>Start <a href="https://man.freebsd.org/cgi/man.cgi?query=inetd&amp;sektion=8&amp;format=html">inetd(8)</a>:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service inetd start</span></code></pre></div></div></li><li><p>Install the base system into <span class=filename>${NFSROOTDIR}</span>, either by decompressing the official archives or by rebuilding the FreeBSD kernel and userland (refer to <a href=../cutting-edge/#makeworld>從原始碼更新 FreeBSD</a> for more detailed instructions, but do not forget to add <code>DESTDIR=<em>${NFSROOTDIR}</em></code> when running the <code>make installkernel</code> and <code>make installworld</code> commands.</p></li><li><p>Test that the TFTP server works and can download the boot loader which will be obtained via PXE:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># tftp localhost</span>
tftp&gt; get FreeBSD/install/boot/pxeboot
Received 264951 bytes <span class=k>in </span>0.1 seconds</code></pre></div></div></li><li><p>Edit <span class=filename>${NFSROOTDIR}/etc/fstab</span> and create an entry to mount the root file system over NFS:</p><div class="literalblock programlisting"><div class=content><pre># Device                                         Mountpoint    FSType   Options  Dump Pass
myhost.example.com:/b/tftpboot/FreeBSD/install       /         nfs      ro        0    0</pre></div></div><div class=paragraph><p>Replace <em>myhost.example.com</em> with the hostname or IP address of the NFS server. In this example, the root file system is mounted read-only in order to prevent NFS clients from potentially deleting the contents of the root file system.</p></div></li><li><p>Set the root password in the PXE environment for client machines which are PXE booting :</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># chroot ${NFSROOTDIR}</span>
<span class=c># passwd</span></code></pre></div></div></li><li><p>If needed, enable <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh&amp;sektion=1&amp;format=html">ssh(1)</a> root logins for client machines which are PXE booting by editing <span class=filename>${NFSROOTDIR}/etc/ssh/sshd_config</span> and enabling <code>PermitRootLogin</code>. This option is documented in <a href="https://man.freebsd.org/cgi/man.cgi?query=sshd_config&amp;sektion=5&amp;format=html">sshd_config(5)</a>.</p></li><li><p>Perform any other needed customizations of the PXE environment in <span class=filename>${NFSROOTDIR}</span>. These customizations could include things like installing packages or editing the password file with <a href="https://man.freebsd.org/cgi/man.cgi?query=vipw&amp;sektion=8&amp;format=html">vipw(8)</a>.</p></li></ol></div></div></div><div class=paragraph><p>When booting from an NFS root volume, <span class=filename>/etc/rc</span> detects the NFS boot and runs <span class=filename>/etc/rc.initdiskless</span>. In this case, <span class=filename>/etc</span> and <span class=filename>/var</span> need to be memory backed file systems so that these directories are writable but the NFS root directory is read-only:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># chroot ${NFSROOTDIR}</span>
<span class=c># mkdir -p conf/base</span>
<span class=c># tar -c -v -f conf/base/etc.cpio.gz --format cpio --gzip etc</span>
<span class=c># tar -c -v -f conf/base/var.cpio.gz --format cpio --gzip var</span></code></pre></div></div><div class=paragraph><p>When the system boots, memory file systems for <span class=filename>/etc</span> and <span class=filename>/var</span> will be created and mounted and the contents of the <span class=filename>cpio.gz</span> files will be copied into them. By default, these file systems have a maximum capacity of 5 megabytes. If your archives do not fit, which is usually the case for <span class=filename>/var</span> when binary packages have been installed, request a larger size by putting the number of 512 byte sectors needed (e.g., 5 megabytes is 10240 sectors) in <span class=filename>${NFSROOTDIR}/conf/base/etc/md_size</span> and <span class=filename>${NFSROOTDIR}/conf/base/var/md_size</span> files for <span class=filename>/etc</span> and <span class=filename>/var</span> file systems respectively.</p></div></div><div class=sect2><h3 id=network-pxe-setting-up-dhcp>31.8.2. 設定 DHCP 伺服器<a class=anchor href=#network-pxe-setting-up-dhcp></a></h3><div class=paragraph><p>The DHCP server does not need to be the same machine as the TFTP and NFS server, but it needs to be accessible in the network.</p></div><div class=paragraph><p>DHCP is not part of the FreeBSD base system but can be installed using the <a class=package href=https://cgit.freebsd.org/ports/tree/net/isc-dhcp44-server/>net/isc-dhcp44-server</a> port or package.</p></div><div class=paragraph><p>Once installed, edit the configuration file, <span class=filename>/usr/local/etc/dhcpd.conf</span>. Configure the <code>next-server</code>, <code>filename</code>, and <code>root-path</code> settings as seen in this example:</p></div><div class="literalblock programlisting"><div class=content><pre>subnet 192.168.0.0 netmask 255.255.255.0 {
   range 192.168.0.2 192.168.0.3 ;
   option subnet-mask 255.255.255.0 ;
   option routers 192.168.0.1 ;
   option broadcast-address 192.168.0.255 ;
   option domain-name-servers 192.168.35.35, 192.168.35.36 ;
   option domain-name &#34;example.com&#34;;

   # IP address of TFTP server
   next-server 192.168.0.1 ;

   # path of boot loader obtained via tftp
   filename &#34;FreeBSD/install/boot/pxeboot&#34; ;

   # pxeboot boot loader will try to NFS mount this directory for root FS
   option root-path &#34;192.168.0.1:/b/tftpboot/FreeBSD/install/&#34; ;

}</pre></div></div><div class=paragraph><p>The <code>next-server</code> directive is used to specify the IP address of the TFTP server.</p></div><div class=paragraph><p>The <code>filename</code> directive defines the path to <span class=filename>/boot/pxeboot</span>. A relative filename is used, meaning that <span class=filename>/b/tftpboot</span> is not included in the path.</p></div><div class=paragraph><p>The <code>root-path</code> option defines the path to the NFS root file system.</p></div><div class=paragraph><p>Once the edits are saved, enable DHCP at boot time by adding the following line to <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>dhcpd_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Then start the DHCP service:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service isc-dhcpd start</span></code></pre></div></div></div><div class=sect2><h3 id=_pxe_問題除錯>31.8.3. PXE 問題除錯<a class=anchor href=#_pxe_問題除錯></a></h3><div class=paragraph><p>Once all of the services are configured and started, PXE clients should be able to automatically load FreeBSD over the network. If a particular client is unable to connect, when that client machine boots up, enter the BIOS configuration menu and confirm that it is set to boot from the network.</p></div><div class=paragraph><p>This section describes some troubleshooting tips for isolating the source of the configuration problem should no clients be able to PXE boot.</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Use the <a class=package href=https://cgit.freebsd.org/ports/tree/net/wireshark/>net/wireshark</a> package or port to debug the network traffic involved during the PXE booting process, which is illustrated in the diagram below.</p><div class=imageblock><div class=content><img src=../../../../images/books/handbook/advanced-networking/pxe-nfs.png alt="pxe nfs"></div><div class=title>图 1. 使用 NFS Root Mount 進行 PXE 開機程序</div></div></li><li><p>On the TFTP server, read <span class=filename>/var/log/xferlog</span> to ensure that <span class=filename>pxeboot</span> is being retrieved from the correct location. To test this example configuration:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># tftp 192.168.0.1</span>
tftp&gt; get FreeBSD/install/boot/pxeboot
Received 264951 bytes <span class=k>in </span>0.1 seconds</code></pre></div></div><div class=paragraph><p>The <code>BUGS</code> sections in <a href="https://man.freebsd.org/cgi/man.cgi?query=tftpd&amp;sektion=8&amp;format=html">tftpd(8)</a> and <a href="https://man.freebsd.org/cgi/man.cgi?query=tftp&amp;sektion=1&amp;format=html">tftp(1)</a> document some limitations with TFTP.</p></div></li><li><p>Make sure that the root file system can be mounted via NFS. To test this example configuration:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount -t nfs 192.168.0.1:/b/tftpboot/FreeBSD/install /mnt</span></code></pre></div></div></li></ol></div></div></div></div></div></div><div class=sect1><h2 id=network-ipv6>31.9. IPv6<a class=anchor href=#network-ipv6></a></h2><div class=sectionbody><div class=paragraph><p>IPv6 is the new version of the well known IP protocol, also known as IPv4. IPv6 provides several advantages over IPv4 as well as many new features:</p></div><div class=ulist><ul><li><p>Its 128-bit address space allows for 340,282,366,920,938,463,463,374,607,431,768,211,456 addresses. This addresses the IPv4 address shortage and eventual IPv4 address exhaustion.</p></li><li><p>Routers only store network aggregation addresses in their routing tables, thus reducing the average space of a routing table to 8192 entries. This addresses the scalability issues associated with IPv4, which required every allocated block of IPv4 addresses to be exchanged between Internet routers, causing their routing tables to become too large to allow efficient routing.</p></li><li><p>Address autoconfiguration (<a href=http://www.ietf.org/rfc/rfc2462.txt>RFC2462</a>).</p></li><li><p>Mandatory multicast addresses.</p></li><li><p>Built-in IPsec (IP security).</p></li><li><p>Simplified header structure.</p></li><li><p>Support for mobile IP.</p></li><li><p>IPv6-to-IPv4 transition mechanisms.</p></li></ul></div><div class=paragraph><p>FreeBSD includes the <a href=http://www.kame.net/>http://www.kame.net/</a>IPv6 reference implementation and comes with everything needed to use IPv6. This section focuses on getting IPv6 configured and running.</p></div><div class=sect2><h3 id=_ipv6_位址的背景知識>31.9.1. IPv6 位址的背景知識<a class=anchor href=#_ipv6_位址的背景知識></a></h3><div class=paragraph><p>There are three different types of IPv6 addresses:</p></div><div class=dlist><dl><dt class=hdlist1>Unicast</dt><dd><p>A packet sent to a unicast address arrives at the interface belonging to the address.</p></dd><dt class=hdlist1>Anycast</dt><dd><p>These addresses are syntactically indistinguishable from unicast addresses but they address a group of interfaces. The packet destined for an anycast address will arrive at the nearest router interface. Anycast addresses are only used by routers.</p></dd><dt class=hdlist1>Multicast</dt><dd><p>These addresses identify a group of interfaces. A packet destined for a multicast address will arrive at all interfaces belonging to the multicast group. The IPv4 broadcast address, usually <code>xxx.xxx.xxx.255</code>, is expressed by multicast addresses in IPv6.</p></dd></dl></div><div class=paragraph><p>When reading an IPv6 address, the canonical form is represented as <code>x:x:x:x:x:x:x:x</code>, where each <code>x</code> represents a 16 bit hex value. An example is <code>FEBC:A574:382B:23C1:AA49:4592:4EFE:9982</code>.</p></div><div class=paragraph><p>Often, an address will have long substrings of all zeros. A <code>::</code> (double colon) can be used to replace one substring per address. Also, up to three leading <code>0</code>s per hex value can be omitted. For example, <code>fe80::1</code> corresponds to the canonical form <code>fe80:0000:0000:0000:0000:0000:0000:0001</code>.</p></div><div class=paragraph><p>A third form is to write the last 32 bits using the well known IPv4 notation. For example, <code>2002::10.0.0.1</code> corresponds to the hexadecimal canonical representation <code>2002:0000:0000:0000:0000:0000:0a00:0001</code>, which in turn is equivalent to <code>2002::a00:1</code>.</p></div><div class=paragraph><p>To view a FreeBSD system’s IPv6 address, use <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig</span></code></pre></div></div><div class="literalblock programlisting"><div class=content><pre>rl0: flags=8943&lt;UP,BROADCAST,RUNNING,PROMISC,SIMPLEX,MULTICAST&gt; mtu 1500
         inet 10.0.0.10 netmask 0xffffff00 broadcast 10.0.0.255
         inet6 fe80::200:21ff:fe03:8e1%rl0 prefixlen 64 scopeid 0x1
         ether 00:00:21:03:08:e1
         media: Ethernet autoselect (100baseTX )
         status: active</pre></div></div><div class=paragraph><p>In this example, the <span class=filename>rl0</span> interface is using <code>fe80::200:21ff:fe03:8e1%rl0</code>, an auto-configured link-local address which was automatically generated from the MAC address.</p></div><div class=paragraph><p>Some IPv6 addresses are reserved. A summary of these reserved addresses is seen in <a href=#reservedip6>已保留的 IPv6 位址</a>:</p></div><table id=reservedip6 class="tableblock frame-none grid-all stretch"><caption class=title>表 3. 已保留的 IPv6 位址</caption><col style=width:25%><col style=width:25%><col style=width:25%><col style=width:25%><thead><tr><th class="tableblock halign-left valign-top">IPv6 address</th><th class="tableblock halign-left valign-top">Prefixlength (Bits)</th><th class="tableblock halign-left valign-top">說明</th><th class="tableblock halign-left valign-top">說明</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>::</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>128 bits</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>unspecified</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Equivalent to <code>0.0.0.0</code> in IPv4.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>::1</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>128 bits</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>loopback address</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Equivalent to <code>127.0.0.1</code> in IPv4.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>::00:xx:xx:xx:xx</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>96 bits</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>embedded IPv4</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>The lower 32 bits are the compatible IPv4 address.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>::ff:xx:xx:xx:xx</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>96 bits</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>IPv4 mapped IPv6 address</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>The lower 32 bits are the IPv4 address for hosts which do not support IPv6.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>fe80::/10</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>10 bits</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>link-local</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Equivalent to 169.254.0.0/16 in IPv4.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>fc00::/7</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>7 bits</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>unique-local</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Unique local addresses are intended for local communication and are only routable within a set of cooperating sites.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>ff00::</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>8 bits</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>multicast</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>2000::-3fff:</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>3 bits</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>global unicast</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>All global unicast addresses are assigned from this pool. The first 3 bits are <code>001</code>.</p></td></tr></tbody></table><div class=paragraph><p>For further information on the structure of IPv6 addresses, refer to <a href=http://www.ietf.org/rfc/rfc3513.txt>RFC3513</a>.</p></div></div><div class=sect2><h3 id=_設定_ipv6>31.9.2. 設定 IPv6<a class=anchor href=#_設定_ipv6></a></h3><div class=paragraph><p>To configure a FreeBSD system as an IPv6 client, add these two lines to <span class=filename>rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>ifconfig_rl0_ipv6=&#34;inet6 accept_rtadv&#34;
rtsold_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>The first line enables the specified interface to receive router advertisement messages. The second line enables the router solicitation daemon, <a href="https://man.freebsd.org/cgi/man.cgi?query=rtsol&amp;sektion=8&amp;format=html">rtsol(8)</a>.</p></div><div class=paragraph><p>If the interface needs a statically assigned IPv6 address, add an entry to specify the static address and associated prefix length:</p></div><div class="literalblock programlisting"><div class=content><pre>ifconfig_rl0_ipv6=&#34;inet6 2001:db8:4672:6565:2026:5043:2d42:5344 prefixlen 64&#34;</pre></div></div><div class=paragraph><p>To assign a default router, specify its address:</p></div><div class="literalblock programlisting"><div class=content><pre>ipv6_defaultrouter=&#34;2001:db8:4672:6565::1&#34;</pre></div></div></div><div class=sect2><h3 id=_連線到_provider>31.9.3. 連線到 Provider<a class=anchor href=#_連線到_provider></a></h3><div class=paragraph><p>In order to connect to other IPv6 networks, one must have a provider or a tunnel that supports IPv6:</p></div><div class=ulist><ul><li><p>Contact an Internet Service Provider to see if they offer IPv6.</p></li><li><p><a href=http://www.tunnelbroker.net>Hurricane Electric</a> offers tunnels with end-points all around the globe.</p></li></ul></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Install the <a class=package href=https://cgit.freebsd.org/ports/tree/net/freenet6/>net/freenet6</a> package or port for a dial-up connection.</p></div></td></tr></tbody></table></div><div class=paragraph><p>This section demonstrates how to take the directions from a tunnel provider and convert them into <span class=filename>/etc/rc.conf</span> settings that will persist through reboots.</p></div><div class=paragraph><p>The first <span class=filename>/etc/rc.conf</span> entry creates the generic tunneling interface <span class=filename>gif0</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>cloned_interfaces=&#34;gif0&#34;</pre></div></div><div class=paragraph><p>Next, configure that interface with the IPv4 addresses of the local and remote endpoints. Replace <em>MY_IPv4_ADDR</em> and <em>REMOTE_IPv4_ADDR</em> with the actual IPv4 addresses:</p></div><div class="literalblock programlisting"><div class=content><pre>create_args_gif0=&#34;tunnel MY_IPv4_ADDR REMOTE_IPv4_ADDR&#34;</pre></div></div><div class=paragraph><p>To apply the IPv6 address that has been assigned for use as the IPv6 tunnel endpoint, add this line, replacing <em>MY_ASSIGNED_IPv6_TUNNEL_ENDPOINT_ADDR</em> with the assigned address:</p></div><div class="literalblock programlisting"><div class=content><pre>ifconfig_gif0_ipv6=&#34;inet6 MY_ASSIGNED_IPv6_TUNNEL_ENDPOINT_ADDR&#34;</pre></div></div><div class=paragraph><p>Then, set the default route for the other side of the IPv6 tunnel. Replace <em>MY_IPv6_REMOTE_TUNNEL_ENDPOINT_ADDR</em> with the default gateway address assigned by the provider:</p></div><div class="literalblock programlisting"><div class=content><pre>ipv6_defaultrouter=&#34;MY_IPv6_REMOTE_TUNNEL_ENDPOINT_ADDR&#34;</pre></div></div><div class=paragraph><p>If the FreeBSD system will route IPv6 packets between the rest of the network and the world, enable the gateway using this line:</p></div><div class="literalblock programlisting"><div class=content><pre>ipv6_gateway_enable=&#34;YES&#34;</pre></div></div></div><div class=sect2><h3 id=_router_advertisement_與_host_auto_configuration>31.9.4. Router Advertisement 與 Host Auto Configuration<a class=anchor href=#_router_advertisement_與_host_auto_configuration></a></h3><div class=paragraph><p>This section demonstrates how to setup <a href="https://man.freebsd.org/cgi/man.cgi?query=rtadvd&amp;sektion=8&amp;format=html">rtadvd(8)</a> to advertise the IPv6 default route.</p></div><div class=paragraph><p>To enable <a href="https://man.freebsd.org/cgi/man.cgi?query=rtadvd&amp;sektion=8&amp;format=html">rtadvd(8)</a>, add the following to <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>rtadvd_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>It is important to specify the interface on which to do IPv6 router advertisement. For example, to tell <a href="https://man.freebsd.org/cgi/man.cgi?query=rtadvd&amp;sektion=8&amp;format=html">rtadvd(8)</a> to use <span class=filename>rl0</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>rtadvd_interfaces=&#34;rl0&#34;</pre></div></div><div class=paragraph><p>Next, create the configuration file, <span class=filename>/etc/rtadvd.conf</span> as seen in this example:</p></div><div class="literalblock programlisting"><div class=content><pre>rl0:\
	:addrs#1:addr=&#34;2001:db8:1f11:246::&#34;:prefixlen#64:tc=ether:</pre></div></div><div class=paragraph><p>Replace <span class=filename>rl0</span> with the interface to be used and <code>2001:db8:1f11:246::</code> with the prefix of the allocation.</p></div><div class=paragraph><p>For a dedicated <code>/64</code> subnet, nothing else needs to be changed. Otherwise, change the <code>prefixlen#</code> to the correct value.</p></div></div><div class=sect2><h3 id=_ipv6_與_ipv6_位址對應表>31.9.5. IPv6 與 IPv6 位址對應表<a class=anchor href=#_ipv6_與_ipv6_位址對應表></a></h3><div class=paragraph><p>When IPv6 is enabled on a server, there may be a need to enable IPv4 mapped IPv6 address communication. This compatibility option allows for IPv4 addresses to be represented as IPv6 addresses. Permitting IPv6 applications to communicate with IPv4 and vice versa may be a security issue.</p></div><div class=paragraph><p>This option may not be required in most cases and is available only for compatibility. This option will allow IPv6-only applications to work with IPv4 in a dual stack environment. This is most useful for third party applications which may not support an IPv6-only environment. To enable this feature, add the following to <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>ipv6_ipv4mapping=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Reviewing the information in RFC 3493, section 3.6 and 3.7 as well as RFC 4038 section 4.2 may be useful to some administrators.</p></div></div></div></div><div class=sect1><h2 id=carp>31.10. 共用位址備援協定 (CARP)<a class=anchor href=#carp></a></h2><div class=sectionbody><div class=paragraph><p>The Common Address Redundancy Protocol (CARP) allows multiple hosts to share the same IP address and Virtual Host ID (VHID) in order to provide <em>high availability</em> for one or more services. This means that one or more hosts can fail, and the other hosts will transparently take over so that users do not see a service failure.</p></div><div class=paragraph><p>In addition to the shared IP address, each host has its own IP address for management and configuration. All of the machines that share an IP address have the same VHID. The VHID for each virtual IP address must be unique across the broadcast domain of the network interface.</p></div><div class=paragraph><p>High availability using CARP is built into FreeBSD, though the steps to configure it vary slightly depending upon the FreeBSD version. This section provides the same example configuration for versions before and equal to or after FreeBSD 10.</p></div><div class=paragraph><p>This example configures failover support with three hosts, all with unique IP addresses, but providing the same web content. It has two different masters named <code>hosta.example.org</code> and <code>hostb.example.org</code>, with a shared backup named <code>hostc.example.org</code>.</p></div><div class=paragraph><p>These machines are load balanced with a Round Robin DNS configuration. The master and backup machines are configured identically except for their hostnames and management IP addresses. These servers must have the same configuration and run the same services. When the failover occurs, requests to the service on the shared IP address can only be answered correctly if the backup server has access to the same content. The backup machine has two additional CARP interfaces, one for each of the master content server’s IP addresses. When a failure occurs, the backup server will pick up the failed master machine’s IP address.</p></div><div class=sect2><h3 id=carp-10x>31.10.1. 使用 CARP 於 FreeBSD 10 及之後版本<a class=anchor href=#carp-10x></a></h3><div class=paragraph><p>Enable boot-time support for CARP by adding an entry for the <span class=filename>carp.ko</span> kernel module in <span class=filename>/boot/loader.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>carp_load=&#34;YES&#34;</pre></div></div><div class=paragraph><p>To load the module now without rebooting:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload carp</span></code></pre></div></div><div class=paragraph><p>For users who prefer to use a custom kernel, include the following line in the custom kernel configuration file and compile the kernel as described in <a href=../kernelconfig/#kernelconfig>設定 FreeBSD 核心</a>:</p></div><div class="literalblock programlisting"><div class=content><pre>device	carp</pre></div></div><div class=paragraph><p>The hostname, management IP address and subnet mask, shared IP address, and VHID are all set by adding entries to <span class=filename>/etc/rc.conf</span>. This example is for <code>hosta.example.org</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>hostname=&#34;hosta.example.org&#34;
ifconfig_em0=&#34;inet 192.168.1.3 netmask 255.255.255.0&#34;
ifconfig_em0_alias0=&#34;inet vhid 1 pass testpass alias 192.168.1.50/32&#34;</pre></div></div><div class=paragraph><p>The next set of entries are for <code>hostb.example.org</code>. Since it represents a second master, it uses a different shared IP address and VHID. However, the passwords specified with <code>pass</code> must be identical as CARP will only listen to and accept advertisements from machines with the correct password.</p></div><div class="literalblock programlisting"><div class=content><pre>hostname=&#34;hostb.example.org&#34;
ifconfig_em0=&#34;inet 192.168.1.4 netmask 255.255.255.0&#34;
ifconfig_em0_alias0=&#34;inet vhid 2 pass testpass alias 192.168.1.51/32&#34;</pre></div></div><div class=paragraph><p>The third machine, <code>hostc.example.org</code>, is configured to handle failover from either master. This machine is configured with two CARPVHIDs, one to handle the virtual IP address for each of the master hosts. The CARP advertising skew, <code>advskew</code>, is set to ensure that the backup host advertises later than the master, since <code>advskew</code> controls the order of precedence when there are multiple backup servers.</p></div><div class="literalblock programlisting"><div class=content><pre>hostname=&#34;hostc.example.org&#34;
ifconfig_em0=&#34;inet 192.168.1.5 netmask 255.255.255.0&#34;
ifconfig_em0_alias0=&#34;inet vhid 1 advskew 100 pass testpass alias 192.168.1.50/32&#34;
ifconfig_em0_alias1=&#34;inet vhid 2 advskew 100 pass testpass alias 192.168.1.51/32&#34;</pre></div></div><div class=paragraph><p>Having two CARPVHIDs configured means that <code>hostc.example.org</code> will notice if either of the master servers becomes unavailable. If a master fails to advertise before the backup server, the backup server will pick up the shared IP address until the master becomes available again.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>If the original master server becomes available again, <code>hostc.example.org</code> will not release the virtual IP address back to it automatically. For this to happen, preemption has to be enabled. The feature is disabled by default, it is controlled via the <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> variable <code>net.inet.carp.preempt</code>. The administrator can force the backup server to return the IP address to the master:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig em0 vhid 1 state backup</span></code></pre></div></div></td></tr></tbody></table></div><div class=paragraph><p>Once the configuration is complete, either restart networking or reboot each system. High availability is now enabled.</p></div><div class=paragraph><p>CARP functionality can be controlled via several <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> variables documented in the <a href="https://man.freebsd.org/cgi/man.cgi?query=carp&amp;sektion=4&amp;format=html">carp(4)</a> manual pages. Other actions can be triggered from CARP events by using <a href="https://man.freebsd.org/cgi/man.cgi?query=devd&amp;sektion=8&amp;format=html">devd(8)</a>.</p></div></div><div class=sect2><h3 id=carp-9x>31.10.2. 使用 CARP 於 FreeBSD 9 及先前版本<a class=anchor href=#carp-9x></a></h3><div class=paragraph><p>The configuration for these versions of FreeBSD is similar to the one described in the previous section, except that a CARP device must first be created and referred to in the configuration.</p></div><div class=paragraph><p>Enable boot-time support for CARP by loading the <span class=filename>if_carp.ko</span> kernel module in <span class=filename>/boot/loader.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>if_carp_load=&#34;YES&#34;</pre></div></div><div class=paragraph><p>To load the module now without rebooting:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload carp</span></code></pre></div></div><div class=paragraph><p>For users who prefer to use a custom kernel, include the following line in the custom kernel configuration file and compile the kernel as described in <a href=../kernelconfig/#kernelconfig>設定 FreeBSD 核心</a>:</p></div><div class="literalblock programlisting"><div class=content><pre>device	carp</pre></div></div><div class=paragraph><p>Next, on each host, create a CARP device:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig carp0 create</span></code></pre></div></div><div class=paragraph><p>Set the hostname, management IP address, the shared IP address, and VHID by adding the required lines to <span class=filename>/etc/rc.conf</span>. Since a virtual CARP device is used instead of an alias, the actual subnet mask of <code>/24</code> is used instead of <code>/32</code>. Here are the entries for <code>hosta.example.org</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>hostname=&#34;hosta.example.org&#34;
ifconfig_fxp0=&#34;inet 192.168.1.3 netmask 255.255.255.0&#34;
cloned_interfaces=&#34;carp0&#34;
ifconfig_carp0=&#34;vhid 1 pass testpass 192.168.1.50/24&#34;</pre></div></div><div class=paragraph><p>On <code>hostb.example.org</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>hostname=&#34;hostb.example.org&#34;
ifconfig_fxp0=&#34;inet 192.168.1.4 netmask 255.255.255.0&#34;
cloned_interfaces=&#34;carp0&#34;
ifconfig_carp0=&#34;vhid 2 pass testpass 192.168.1.51/24&#34;</pre></div></div><div class=paragraph><p>The third machine, <code>hostc.example.org</code>, is configured to handle failover from either of the master hosts:</p></div><div class="literalblock programlisting"><div class=content><pre>hostname=&#34;hostc.example.org&#34;
ifconfig_fxp0=&#34;inet 192.168.1.5 netmask 255.255.255.0&#34;
cloned_interfaces=&#34;carp0 carp1&#34;
ifconfig_carp0=&#34;vhid 1 advskew 100 pass testpass 192.168.1.50/24&#34;
ifconfig_carp1=&#34;vhid 2 advskew 100 pass testpass 192.168.1.51/24&#34;</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Preemption is disabled in the <span class=filename>GENERIC</span> FreeBSD kernel. If preemption has been enabled with a custom kernel, <code>hostc.example.org</code> may not release the IP address back to the original content server. The administrator can force the backup server to return the IP address to the master with the command:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig carp0 down &amp;&amp; ifconfig carp0 up</span></code></pre></div></div><div class=paragraph><p>This should be done on the <span class=filename>carp</span> interface which corresponds to the correct host.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Once the configuration is complete, either restart networking or reboot each system. High availability is now enabled.</p></div></div></div></div><div class=sect1><h2 id=network-vlan>31.11. VLANs<a class=anchor href=#network-vlan></a></h2><div class=sectionbody><div class=paragraph><p>VLANs are a way of virtually dividing up a network into many different subnetworks, also referred to as segmenting. Each segment will have its own broadcast domain and be isolated from other VLANs.</p></div><div class=paragraph><p>在 FreeBSD 上，要使用 VLANs 必須有網路卡驅動程式的支援，要查看那些驅動程式支援 vlan，請參考 <a href="https://man.freebsd.org/cgi/man.cgi?query=vlan&amp;sektion=4&amp;format=html">vlan(4)</a> 操作手冊。</p></div><div class=paragraph><p>When configuring a VLAN, a couple pieces of information must be known. First, which network interface? Second, what is the VLAN tag?</p></div><div class=paragraph><p>To configure VLANs at run time, with a NIC of <code>em0</code> and a VLAN tag of <code>5</code> the command would look like this:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig em0.5 create vlan 5 vlandev em0 inet 192.168.20.20/24</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>See how the interface name includes the NIC driver name and the VLAN tag, separated by a period? This is a best practice to make maintaining the VLAN configuration easy when many VLANs are present on a machine.</p></div></td></tr></tbody></table></div><div class=paragraph><p>To configure VLANs at boot time, <span class=filename>/etc/rc.conf</span> must be updated. To duplicate the configuration above, the following will need to be added:</p></div><div class="literalblock programlisting"><div class=content><pre>vlans_em0=&#34;5&#34;
ifconfig_em0_5=&#34;inet 192.168.20.20/24&#34;</pre></div></div><div class=paragraph><p>Additional VLANs may be added, by simply adding the tag to the <code>vlans<em>em0</em></code> field and adding an additional line configuring the network on that VLAN tag’s interface.</p></div><div class=paragraph><p>It is useful to assign a symbolic name to an interface so that when the associated hardware is changed, only a few configuration variables need to be updated. For example, security cameras need to be run over VLAN 1 on <code>em0</code>. Later, if the <code>em0</code> card is replaced with a card that uses the <a href="https://man.freebsd.org/cgi/man.cgi?query=ixgb&amp;sektion=4&amp;format=html">ixgb(4)</a> driver, all references to <code>em0.1</code> will not have to change to <code>ixgb0.1</code>.</p></div><div class=paragraph><p>To configure VLAN <code>5</code>, on the NIC <code>em0</code>, assign the interface name <code>cameras</code>, and assign the interface an IP address of <code><em>192.168.20.20</em></code> with a <code>24</code>-bit prefix, use this command:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig em0.5 create vlan 5 vlandev em0 name cameras inet 192.168.20.20/24</span></code></pre></div></div><div class=paragraph><p>For an interface named <code>video</code>, use the following:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig video.5 create vlan 5 vlandev video name cameras inet 192.168.20.20/24</span></code></pre></div></div><div class=paragraph><p>To apply the changes at boot time, add the following lines to <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>vlans_video=&#34;camera&#34;
create_args_camera=&#34;vlan 5&#34;
ifconfig_camera=&#34;inet 192.168.20.20/24&#34;</pre></div></div></div></div></div><hr><div class=last-modified><p><strong>最後修改於</strong>: March 9, 2024 由 <a href="https://cgit.freebsd.org/doc/commit/?id=6199af92e7" target=_blank>Danilo G. Baio</a></p></div><div class=buttons><div class=prev><i class="fa fa-angle-left" aria-hidden=true title=Prev></i><div class=container><a href=https://docs.freebsd.org/zh-tw/books/handbook/firewalls class=direction>Prev</a></div></div><div class=home><i class="fa fa-home" aria-hidden=true title=Home></i><div class=container><a href=../ class=direction>Home</a></div></div><div class=next><div class=container><a href=https://docs.freebsd.org/zh-tw/books/handbook/partv class=direction>Next</a></div><i class="fa fa-angle-right" aria-hidden=true title=Next></i></div></div><label class="hidden book-menu-overlay" for=menu-control></label></div><aside class=toc><div class=toc-content><h3>目錄</h3><nav id=TableOfContents><ul><li><a href=#advanced-networking-synopsis>31.1. 概述</a></li><li><a href=#network-routing>31.2. 通訊閘與路由</a></li><li><a href=#network-wireless>31.3. 無線網路</a></li><li><a href=#network-usb-tethering>31.4. USB 網路共享</a></li><li><a href=#network-bluetooth>31.5. 藍牙</a></li><li><a href=#network-bridging>31.6. 橋接</a></li><li><a href=#network-aggregation>31.7. Link Aggregation 與容錯移轉</a></li><li><a href=#network-diskless>31.8. PXE 無磁碟作業</a></li><li><a href=#network-ipv6>31.9. IPv6</a></li><li><a href=#carp>31.10. 共用位址備援協定 (CARP)</a></li><li><a href=#network-vlan>31.11. VLANs</a></li></ul></nav><hr><div class=resources><h3>資源</h3><ul class=contents><li><i class="fa fa-file-pdf-o" aria-hidden=true title="下載 PDF"></i><a href=https://download.freebsd.org/doc/zh-tw/books/handbook/handbook_zh-tw.pdf>下載 PDF</a></li><li><i class="fa fa-pencil-square-o" aria-hidden=true title=編輯此頁></i><a href=https://github.com/freebsd/freebsd-doc/blob/main/documentation/content/zh-tw/_index target=_blank>編輯此頁</a></li></ul></div></div></aside><a class=to-top href=#top><i class="fa fa-arrow-circle-up" aria-hidden=true></i></a></main><footer><div class=footer-container><section class=logo-column><img src=https://docs.freebsd.org/images/FreeBSD-colors.svg width=160 height=50 alt="FreeBSD logo"><div class=options-container><div class=language-container><a id=languages href=https://docs.freebsd.org/zh-tw/languages><img src=https://docs.freebsd.org/images/language.png class=language-image alt=選擇語言>
<span>繁體中文</span></a></div><div class=theme-container><select id=theme-chooser><option value=theme-system>System</option><option value=theme-light>淺色</option><option value=theme-dark>深色</option><option value=theme-high-contrast>高對比</option></select></div></div></section><section class=about-column><h3 class=column-title>About</h3><ul class=column-elements-container><li><a href=https://www.freebsd.org/about/ target=_blank class=column-element>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/ target=_blank class=column-element>FreeBSD Foundation</a></li><li><a href=https://www.freebsd.org/where/ target=_blank class=column-element>Get FreeBSD</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct target=_blank class=column-element>Code of Conduct</a></li><li><a href=https://www.freebsd.org/security/ target=_blank class=column-element>Security Advisories</a></li></ul></section><section class=documentation-column><h3 class=column-title>Documentation</h3><ul class=column-elements-container><li><a href=/zh-tw class=column-element>Documentation portal</a></li><li><a href=https://man.FreeBSD.org target=_blank class=column-element>Manual pages</a></li><li><a href=https://papers.FreeBSD.org target=_blank class=column-element>Presentations and papers</a></li><li><a href=https://docs-archive.freebsd.org/doc/ target=_blank class=column-element>Previous versions</a></li><li><a href=https://docs-archive.freebsd.org/44doc/ target=_blank class=column-element>4.4BSD Documents</a></li><li><a href=https://wiki.freebsd.org/ target=_blank class=column-element>Wiki</a></li></ul></section><section class=community-column><h3 class=column-title>Community</h3><ul class=column-elements-container><li><a href=https://docs.freebsd.org/zh-tw/articles/contributing class=column-element>Get involved</a></li><li><a href=https://forums.freebsd.org/ target=_blank class=column-element>Community forum</a></li><li><a href=https://lists.freebsd.org/ target=_blank class=column-element>Mailing lists</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank class=column-element>IRC Channels</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank class=column-element>Bug Tracker</a></li></ul></section><section class=legal-column><h3 class=column-title>Legal</h3><ul class=column-elements-container><li><a href=https://freebsdfoundation.org/donate/ target=_blank class=column-element>Donations</a></li><li><a href=https://www.freebsd.org/copyright/freebsd-license/ target=_blank class=column-element>Licensing</a></li><li><a href=https://www.freebsd.org/privacy/ target=_blank class=column-element>Privacy Policy</a></li><li><a href=https://www.freebsd.org/copyright/ target=_blank class=column-element>Legal notices</a></li></ul></section><section class=copyright-column><p>&copy; 1994-2024 The FreeBSD Project. All rights reserved</p><span>Made with <span class=heart>♥</span> by the FreeBSD Community</span></section></div></footer></body></html>