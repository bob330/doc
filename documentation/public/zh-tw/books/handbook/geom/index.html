<!doctype html><html class=theme-light lang=zh-tw><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content><meta name=keywords content><meta name=copyright content="1995-2024 The FreeBSD Foundation"><link rel=canonical href=http://172.16.201.134:1313/zh-tw/books/handbook/geom/><title>章 18. GEOM: 模組化磁碟轉換框架 | FreeBSD Documentation Portal</title>
<meta name=theme-color content="#790000"><meta name=color-scheme content="system light dark high-contrast"><link rel="shortcut icon" href=http://172.16.201.134:1313/favicon.ico><link rel=stylesheet href=http://172.16.201.134:1313/styles/main.min.css><link rel=stylesheet href=http://172.16.201.134:1313/css/font-awesome-min.css><script defer src=/js/theme-chooser.min.js></script><script defer src=/js/copy-clipboard.min.js></script><script defer src=/js/search.min.js></script><meta name=twitter:card content="summary"><meta name=twitter:domain content="docs.FreeBSD.org"><meta name=twitter:site content="@freebsd"><meta name=twitter:url content="https://twitter.com/freebsd"><meta property="og:title" content="章 18. GEOM: 模組化磁碟轉換框架"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:image" content="http://172.16.201.134:1313/favicon.ico"><meta property="og:image:alt" content="FreeBSD Logo"><meta property="og:locale" content="zh-tw"><meta property="og:url" content="http://172.16.201.134:1313/zh-tw/books/handbook/geom/"><meta property="og:site_name" content="FreeBSD Documentation Portal"><script type=application/ld+json>{"@context":"http://schema.org","@type":"Article","url":"http:\/\/172.16.201.134:1313\/zh-tw\/books\/handbook\/geom\/","name":"FreeBSD Documentation Portal","headline":"FreeBSD Documentation Portal","description":"FreeBSD Documentation Portal"}</script></head><body><header><div class=header-container><div class=logo-menu-bars-container><a href=https://www.FreeBSD.org class=logo><img src=http://172.16.201.134:1313/images/FreeBSD-monochromatic.svg width=160 height=50 alt="FreeBSD logo">
</a><label class=menu-bars for=menu-bars><i class="fa fa-bars" aria-hidden=true></i></label></div><input id=menu-bars type=checkbox><nav><ul class=menu><li class=menu-item><input id=about type=checkbox>
<a href=# aria-label="Navigate to About section"><label class=menu-item-description for=about>About
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/about/ target=_blank>About</a></li><li><a href=https://www.freebsd.org/about/ target=_blank>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/about-us/about-the-foundation/ target=_blank>FreeBSD Foundation</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct/ target=_blank>Code of Conduct</a></li></ul></li><li class=menu-item><input id=download type=checkbox>
<a href=# aria-label="Navigate to get FreeBSD section"><label class=menu-item-description for=download>Get FreeBSD
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/where/ target=_blank>Get FreeBSD</a></li><li><a href=https://www.freebsd.org/releases/ target=_blank>Release Information</a></li><li><a href=https://www.freebsd.org/releng/ target=_blank>Release Engineering</a></li><li><a href=https://www.freebsd.org/security/ target=_blank>Security Advisories</a></li></ul></li><li class=menu-item><input id=documentation type=checkbox>
<a href=# aria-label="Navigate to get Documentation section"><label class=menu-item-description for=documentation>Documentation
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=/zh-tw>Documentation portal</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook>FreeBSD Handbook</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/porters-handbook>Porter's Handbook</a></li><li><a href=https://docs.FreeBSD.org/en/books/fdp-primer>Documentation Project Handbook</a></li><li><a href=https://man.FreeBSD.org target=_blank>Manual pages</a></li><li><a href=https://papers.FreeBSD.org target=_blank>Presentations and papers</a></li><li><a href=https://wiki.FreeBSD.org target=_blank>Wiki</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books>Books</a></li><li><a href=http://172.16.201.134:1313/zh-tw/articles>Articles</a></li></ul></li><li class=menu-item><input id=community type=checkbox>
<a href=# aria-label="Navigate to get Community section"><label class=menu-item-description for=community>Community
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/community/>Community</a></li><li><a href=http://172.16.201.134:1313/zh-tw/articles/contributing>Get involved</a></li><li><a href=https://forums.freebsd.org/ target=_blank>Forum</a></li><li><a href=https://lists.freebsd.org/ target=_blank>Mailing lists</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank>IRC Channels</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank>Bug Tracker</a></li><li><a href=https://www.freebsd.org/support/ target=_blank>Support</a></li></ul></li></ul></nav><div class=search-donate-container><form class=search method=get id=search-header-form action=https://docs.freebsd.org/search name=search-header-form><input type=hidden name=DB value=zh-tw>
<input id=words name=P type=text size=20 maxlength=255>
<button>
<i class="fa fa-search" aria-hidden=true></i></button></form><div class=donate><a href=https://freebsdfoundation.org/donate/ target=_blank><span class=heart>♥</span>
Donate</a></div></div></div></header><input type=checkbox class="hidden toggle" id=menu-control><main class=main-wrapper-book><a id=top></a><aside class=book-menu><div class=book-menu-content><input id=search-book type=text placeholder=Search aria-label=Search maxlength=128><nav id=MenuContents><ul><li><input type=checkbox id=chapter-eb2a98ce203d8afd517726e6d8776be3 class=toggle>
<label class="icon cursor" for=chapter-eb2a98ce203d8afd517726e6d8776be3><a role=button></a></label><a href=http://172.16.201.134:1313/zh-tw/books/handbook/preface/>序</a><ul><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/preface/#preface-audience>給讀者的話</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/preface/#preface-changes-from3>自第三版後的主要修訂</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/preface/#preface-changes-from2>自第二版後的主要修訂 (2004)</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/preface/#preface-changes>自第一版後的主要修訂 (2001)</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/preface/#preface-overview>本書架構</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/preface/#preface-conv>本書的編排體裁</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/preface/#preface-acknowledgements>銘謝</a></li></ul></li><li><input type=checkbox id=chapter-14a525fce014b90b8a458a894818255a class=toggle>
<label for=chapter-14a525fce014b90b8a458a894818255a><a role=button></a></label><a href=http://172.16.201.134:1313/zh-tw/books/handbook/parti/>部 I. 入門</a></li><li><input type=checkbox id=chapter-f9c9f3451644df30d224350da97d5da6 class=toggle>
<label class="icon cursor" for=chapter-f9c9f3451644df30d224350da97d5da6><a role=button></a></label><a href=http://172.16.201.134:1313/zh-tw/books/handbook/introduction/>章 1. 簡介</a><ul><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/introduction/#introduction-synopsis>1.1. 概述</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/introduction/#nutshell>1.2. 歡迎使用 FreeBSD！</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/introduction/#history>1.3. 關於 FreeBSD 計劃</a></li></ul></li><li><input type=checkbox id=chapter-f693a3fa687a72d63ec8129ee302d664 class=toggle>
<label class="icon cursor" for=chapter-f693a3fa687a72d63ec8129ee302d664><a role=button></a></label><a href=http://172.16.201.134:1313/zh-tw/books/handbook/bsdinstall/>章 2. 安裝 FreeBSD</a><ul><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/bsdinstall/#bsdinstall-synopsis>2.1. 概述</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/bsdinstall/#bsdinstall-hardware>2.2. 最低硬體需求</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/bsdinstall/#bsdinstall-pre>2.3. 安裝前準備工作</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/bsdinstall/#bsdinstall-start>2.4. 開始安裝</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/bsdinstall/#using-bsdinstall>2.5. 使用 bsdinstall</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/bsdinstall/#bsdinstall-partitioning>2.6. 配置磁碟空間</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/bsdinstall/#bsdinstall-final-warning>2.7. 確認安裝</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/bsdinstall/#bsdinstall-post>2.8. 安裝後注意事項</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/bsdinstall/#bsdinstall-install-trouble>2.9. 疑難排解</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/bsdinstall/#using-live-cd>2.10. 使用 Live CD</a></li></ul></li><li><input type=checkbox id=chapter-9f6db261075f578742036fcc6000eecd class=toggle>
<label class="icon cursor" for=chapter-9f6db261075f578742036fcc6000eecd><a role=button></a></label><a href=http://172.16.201.134:1313/zh-tw/books/handbook/basics/>章 3. FreeBSD 基礎</a><ul><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/basics/#basics-synopsis>3.1. 概述</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/basics/#consoles>3.2. 虛擬 Console 與終端機</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/basics/#users-synopsis>3.3. 使用者與基礎帳號管理</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/basics/#permissions>3.4. 權限</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/basics/#dirstructure>3.5. 目錄結構</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/basics/#disk-organization>3.6. 磁碟組織</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/basics/#mount-unmount>3.7. 掛載與卸載檔案系統</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/basics/#basics-processes>3.8. 程序與 Daemon</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/basics/#shells>3.9. Shell</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/basics/#editors>3.10. 文字編輯器</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/basics/#basics-devices>3.11. 裝置及裝置節點</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/basics/#basics-more-information>3.12. 操作手冊</a></li></ul></li><li><input type=checkbox id=chapter-01c5707e95d14c0ff84bf62600c958d1 class=toggle>
<label class="icon cursor" for=chapter-01c5707e95d14c0ff84bf62600c958d1><a role=button></a></label><a href=http://172.16.201.134:1313/zh-tw/books/handbook/ports/>章 4. 安裝應用程式：套件與 Port</a><ul><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/ports/#ports-synopsis>4.1. 概述</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/ports/#ports-overview>4.2. 安裝軟體的概要</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/ports/#ports-finding-applications>4.3. 搜尋軟體</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/ports/#pkgng-intro>4.4. 使用 pkg 管理 Binary 套件</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/ports/#ports-using>4.5. 使用 Port 套件集</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/ports/#ports-poudriere>4.6. 使用 Poudriere 編譯套件</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/ports/#ports-nextsteps>4.7. 安裝後的注意事項</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/ports/#ports-broken>4.8. 處理損壞的 Port</a></li></ul></li><li><input type=checkbox id=chapter-3405c00581365a8b5d16af70fe4d1b72 class=toggle>
<label class="icon cursor" for=chapter-3405c00581365a8b5d16af70fe4d1b72><a role=button></a></label><a href=http://172.16.201.134:1313/zh-tw/books/handbook/x11/>章 5. X Window 系統</a><ul><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/x11/#x11-synopsis>5.1. 概述</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/x11/#x-understanding>5.2. 術語</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/x11/#x-install>5.3. 安裝 Xorg</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/x11/#x-config>5.4. Xorg 設定</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/x11/#x-fonts>5.5. 在 Xorg 使用字型</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/x11/#x-xdm>5.6. X 顯示管理程式</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/x11/#x11-wm>5.7. 桌面環境</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/x11/#x-compiz-fusion>5.8. 安裝 Compiz Fusion</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/x11/#x11-understanding>5.9. 疑難排解</a></li></ul></li><li><input type=checkbox id=chapter-0eab3565e8f59f5a8a896dfba7eb3680 class=toggle>
<label for=chapter-0eab3565e8f59f5a8a896dfba7eb3680><a role=button></a></label><a href=http://172.16.201.134:1313/zh-tw/books/handbook/partii/>部 II. 一般作業</a></li><li><input type=checkbox id=chapter-b33cf28993f3f7bf5baf036e79da0f39 class=toggle>
<label class="icon cursor" for=chapter-b33cf28993f3f7bf5baf036e79da0f39><a role=button></a></label><a href=http://172.16.201.134:1313/zh-tw/books/handbook/desktop/>章 6. 桌面應用程式</a><ul><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/desktop/#desktop-synopsis>6.1. 概述</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/desktop/#desktop-browsers>6.2. 瀏覽器</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/desktop/#desktop-productivity>6.3. 辦工工具</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/desktop/#desktop-viewers>6.4. 文件閱覽程式</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/desktop/#desktop-finance>6.5. 財務</a></li></ul></li><li><input type=checkbox id=chapter-152f694a19312ad72ec7bb4e1c3c33b2 class=toggle>
<label class="icon cursor" for=chapter-152f694a19312ad72ec7bb4e1c3c33b2><a role=button></a></label><a href=http://172.16.201.134:1313/zh-tw/books/handbook/multimedia/>章 7. 多媒體</a><ul><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/multimedia/#multimedia-synopsis>7.1. 概述</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/multimedia/#sound-setup>7.2. 設定音效卡</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/multimedia/#sound-mp3>7.3. MP3 音樂</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/multimedia/#video-playback>7.4. 影片播放</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/multimedia/#tvcard>7.5. 電視卡</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/multimedia/#mythtv>7.6. MythTV</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/multimedia/#scanners>7.7. 影像掃描器</a></li></ul></li><li><input type=checkbox id=chapter-80888b4ee02e3e409e5f71cf97a36450 class=toggle>
<label class="icon cursor" for=chapter-80888b4ee02e3e409e5f71cf97a36450><a role=button></a></label><a href=http://172.16.201.134:1313/zh-tw/books/handbook/kernelconfig/>章 8. 設定 FreeBSD 核心</a><ul><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/kernelconfig/#kernelconfig-synopsis>8.1. 概述</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/kernelconfig/#kernelconfig-custom-kernel>8.2. 為何要編譯自訂的核心?</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/kernelconfig/#kernelconfig-devices>8.3. 偵測系統硬體</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/kernelconfig/#kernelconfig-config>8.4. 設定檔</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/kernelconfig/#kernelconfig-building>8.5. 編譯與安裝自訂核心</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/kernelconfig/#kernelconfig-trouble>8.6. 如果發生錯誤</a></li></ul></li><li><input type=checkbox id=chapter-cb174c55879b17ab955f2f16989a79e0 class=toggle>
<label class="icon cursor" for=chapter-cb174c55879b17ab955f2f16989a79e0><a role=button></a></label><a href=http://172.16.201.134:1313/zh-tw/books/handbook/printing/>章 9. 列印</a><ul><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/printing/#printing-quick-start>9.1. 快速開始</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/printing/#printing-connections>9.2. 印表機連線</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/printing/#printing-pdls>9.3. 常見的頁面描述語言</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/printing/#printing-direct>9.4. 直接列印</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/printing/#printing-lpd>9.5. LPD (行列式印表機 Daemon)</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/printing/#printing-other>9.6. 其他列印系統</a></li></ul></li><li><input type=checkbox id=chapter-c12b8c3f2a8fcefce87087241f695c83 class=toggle>
<label class="icon cursor" for=chapter-c12b8c3f2a8fcefce87087241f695c83><a role=button></a></label><a href=http://172.16.201.134:1313/zh-tw/books/handbook/linuxemu/>章 10. Linux® Binary 相容性</a><ul><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/linuxemu/#linuxemu-synopsis>10.1. 概述</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/linuxemu/#linuxemu-lbc-install>10.2. 設定 Linux™ Binary 相容性</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/linuxemu/#linuxemu-advanced>10.3. 進階主題</a></li></ul></li><li><input type=checkbox id=chapter-03b11ba627b9a0c85b247f5641bde272 class=toggle>
<label for=chapter-03b11ba627b9a0c85b247f5641bde272><a role=button></a></label><a href=http://172.16.201.134:1313/zh-tw/books/handbook/partiii/>部 III. 系統管理</a></li><li><input type=checkbox id=chapter-6c31587f8d736319f099cd4dc1961301 class=toggle>
<label class="icon cursor" for=chapter-6c31587f8d736319f099cd4dc1961301><a role=button></a></label><a href=http://172.16.201.134:1313/zh-tw/books/handbook/config/>章 11. 設定與調校</a><ul><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/config/#config-synopsis>11.1. 概述</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/config/#configtuning-starting-services>11.2. 啟動服務</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/config/#configtuning-cron>11.3. 設定 cron(8)</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/config/#configtuning-rcd>11.4. 管理 FreeBSD 中的服務</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/config/#config-network-setup>11.5. 設定網路介面卡</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/config/#configtuning-virtual-hosts>11.6. 虛擬主機</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/config/#configtuning-syslog>11.7. 設定系統日誌</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/config/#configtuning-configfiles>11.8. 設定檔</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/config/#configtuning-sysctl>11.9. 使用 sysctl(8) 調校</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/config/#configtuning-disk>11.10. 調校磁碟</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/config/#configtuning-kernel-limits>11.11. 調校核心限制</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/config/#adding-swap-space>11.12. 增加交換空間</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/config/#acpi-overview>11.13. 電源與資源管理</a></li></ul></li><li><input type=checkbox id=chapter-459f0012b3b4f0b6b123010f029da5e4 class=toggle>
<label class="icon cursor" for=chapter-459f0012b3b4f0b6b123010f029da5e4><a role=button></a></label><a href=http://172.16.201.134:1313/zh-tw/books/handbook/boot/>章 12. FreeBSD 開機程序</a><ul><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/boot/#boot-synopsis>12.1. 概述</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/boot/#boot-introduction>12.2. FreeBSD 開機程序</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/boot/#boot-splash>12.3. 設定開機啟動畫面</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/boot/#device-hints>12.4. 裝置提示</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/boot/#boot-shutdown>12.5. 關機程序</a></li></ul></li><li><input type=checkbox id=chapter-917c75fcffbb14d48ed6d0a48e7028f2 class=toggle>
<label class="icon cursor" for=chapter-917c75fcffbb14d48ed6d0a48e7028f2><a role=button></a></label><a href=http://172.16.201.134:1313/zh-tw/books/handbook/security/>章 13. 安全性</a><ul><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/security/#security-synopsis>13.1. 概述</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/security/#security-intro>13.2. 簡介</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/security/#one-time-passwords>13.3. 一次性密碼</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/security/#tcpwrappers>13.4. TCP Wrapper</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/security/#kerberos5>13.5. Kerberos</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/security/#openssl>13.6. OpenSSL</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/security/#ipsec>13.7. VPN over IPsec</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/security/#openssh>13.8. OpenSSH</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/security/#fs-acl>13.9. 存取控制清單</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/security/#security-pkg>13.10. 監視第三方安全性問題</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/security/#security-advisories>13.11. FreeBSD 安全報告</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/security/#security-accounting>13.12. 程序追蹤</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/security/#security-resourcelimits>13.13. 限制資源</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/security/#security-sudo>13.14. 使用 Sudo 分享管理權限</a></li></ul></li><li><input type=checkbox id=chapter-1a2a8e719703649c2c66d99aa7a25fd4 class=toggle>
<label class="icon cursor" for=chapter-1a2a8e719703649c2c66d99aa7a25fd4><a role=button></a></label><a href=http://172.16.201.134:1313/zh-tw/books/handbook/jails/>章 14. Jail</a><ul><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/jails/#jails-synopsis>14.1. 概述</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/jails/#jails-terms>14.2. Jail 相關術語</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/jails/#jails-build>14.3. 建立和控制 Jail</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/jails/#jails-tuning>14.4. 調校與管理</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/jails/#jails-application>14.5. 更新多個 Jail</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/jails/#jails-ezjail>14.6. 使用 ezjail 管理 Jail</a></li></ul></li><li><input type=checkbox id=chapter-8f4620c77e572cbb58917911a33c73cf class=toggle>
<label class="icon cursor" for=chapter-8f4620c77e572cbb58917911a33c73cf><a role=button></a></label><a href=http://172.16.201.134:1313/zh-tw/books/handbook/mac/>章 15. 強制存取控制 (MAC)</a><ul><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/mac/#mac-synopsis>15.1. 概述</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/mac/#mac-inline-glossary>15.2. 關鍵詞</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/mac/#mac-understandlabel>15.3. 了解 MAC 標籤</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/mac/#mac-planning>15.4. 規劃安全架構</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/mac/#mac-policies>15.5. 可用的 MAC 管理政策</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/mac/#mac-userlocked>15.6. User Lock Down</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/mac/#mac-implementing>15.7. 在 MAC Jail 中使用 Nagios</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/mac/#mac-troubleshoot>15.8. MAC 架構疑難排解</a></li></ul></li><li><input type=checkbox id=chapter-9598d66a76cb3182057b6bcd775149a0 class=toggle>
<label class="icon cursor" for=chapter-9598d66a76cb3182057b6bcd775149a0><a role=button></a></label><a href=http://172.16.201.134:1313/zh-tw/books/handbook/audit/>章 16. 安全事件稽查</a><ul><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/audit/#audit-synopsis>16.1. 概述</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/audit/#audit-inline-glossary>16.2. 關鍵詞</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/audit/#audit-config>16.3. 稽查設定</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/audit/#audit-administration>16.4. 查看稽查線索</a></li></ul></li><li><input type=checkbox id=chapter-e1edcad13d9db6e8e4cb645d378ecfaf class=toggle>
<label class="icon cursor" for=chapter-e1edcad13d9db6e8e4cb645d378ecfaf><a role=button></a></label><a href=http://172.16.201.134:1313/zh-tw/books/handbook/disks/>章 17. 儲存設備</a><ul><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/disks/#disks-synopsis>17.1. 概述</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/disks/#disks-adding>17.2. 加入磁碟</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/disks/#disks-growing>17.3. 重設大小與擴增磁碟</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/disks/#usb-disks>17.4. USB 儲存裝置</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/disks/#creating-cds>17.5. 建立與使用 CD 媒體</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/disks/#creating-dvds>17.6. 建立與使用 DVD 媒體</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/disks/#floppies>17.7. 建立與使用軟碟</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/disks/#backup-basics>17.8. 備份基礎概念</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/disks/#disks-virtual>17.9. 記憶體磁碟</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/disks/#snapshots>17.10. 檔案系統快照</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/disks/#quotas>17.11. 磁碟配額</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/disks/#disks-encrypting>17.12. 磁碟分割區加密</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/disks/#swap-encrypting>17.13. 交換空間加密</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/disks/#disks-hast>17.14. 高可用存儲空間 (HAST)</a></li></ul></li><li><input type=checkbox id=chapter-dde37901a0e0ea32745b67607854900f class=toggle checked>
<label class="icon cursor" for=chapter-dde37901a0e0ea32745b67607854900f><a role=button></a></label><a href=http://172.16.201.134:1313/zh-tw/books/handbook/geom/>章 18. GEOM: 模組化磁碟轉換框架</a><ul><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/geom/#geom-synopsis>18.1. 概述</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/geom/#geom-striping>18.2. RAID0 - 串連 (Striping)</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/geom/#geom-mirror>18.3. RAID1 - 鏡像 (Mirroring)</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/geom/#geom-raid3>18.4. RAID3 - 位元級串連與獨立奇偶校驗</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/geom/#geom-graid>18.5. 軟體 RAID 裝置</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/geom/#geom-ggate>18.6. GEOM Gate Network</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/geom/#geom-glabel>18.7. 磁碟裝置標籤</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/geom/#geom-gjournal>18.8. UFS Journaling 透過 GEOM</a></li></ul></li><li><input type=checkbox id=chapter-73e82560fcb7145b7c0e2ec47af8fc04 class=toggle>
<label class="icon cursor" for=chapter-73e82560fcb7145b7c0e2ec47af8fc04><a role=button></a></label><a href=http://172.16.201.134:1313/zh-tw/books/handbook/zfs/>章 19. Z 檔案系統 (ZFS)</a><ul><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/zfs/#zfs-differences>19.1. 什麼使 ZFS 與眾不同</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/zfs/#zfs-quickstart>19.2. 快速入門指南</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/zfs/#zfs-zpool>19.3. <code>zpool</code> 管理</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/zfs/#zfs-zfs>19.4. <code>zfs</code> 管理</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/zfs/#zfs-zfs-allow>19.5. 委託管理</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/zfs/#zfs-advanced>19.6. 進階主題</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/zfs/#zfs-links>19.7. 其他資源</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/zfs/#zfs-term>19.8. ZFS 特色與術語</a></li></ul></li><li><input type=checkbox id=chapter-7af71270807eb7b70cd3eedc6577b254 class=toggle>
<label class="icon cursor" for=chapter-7af71270807eb7b70cd3eedc6577b254><a role=button></a></label><a href=http://172.16.201.134:1313/zh-tw/books/handbook/filesystems/>章 20. 其他檔案系統</a><ul><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/filesystems/#filesystems-synopsis>20.1. 概述</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/filesystems/#filesystems-linux>20.2. Linux™ 檔案系統</a></li></ul></li><li><input type=checkbox id=chapter-375257268d95faaf87faf4f7a2e6aa67 class=toggle>
<label class="icon cursor" for=chapter-375257268d95faaf87faf4f7a2e6aa67><a role=button></a></label><a href=http://172.16.201.134:1313/zh-tw/books/handbook/virtualization/>章 21. 虛擬化</a><ul><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/virtualization/#virtualization-synopsis>21.1. 概述</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/virtualization/#virtualization-guest-parallels>21.2. 在 Mac OS™ X 的 Parallels 安裝 FreeBSD 為客端</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/virtualization/#virtualization-guest-virtualpc>21.3. 在 Windows™ 的 Virtual PC 安裝 FreeBSD 為客端</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/virtualization/#virtualization-guest-vmware>21.4. 在 Mac OS™ 的 VMware Fusion 安裝 FreeBSD 為客端</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/virtualization/#virtualization-guest-virtualbox>21.5. 在 VirtualBox™ 安裝 FreeBSD 作為客端</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/virtualization/#virtualization-host-virtualbox>21.6. 以 FreeBSD 作為主端使用 VirtualBox™</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/virtualization/#virtualization-host-bhyve>21.7. 以 FreeBSD 作為主端安裝 bhyve</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/virtualization/#virtualization-host-xen>21.8. 以 FreeBSD 作為主端安裝 Xen™</a></li></ul></li><li><input type=checkbox id=chapter-49f1e96591c090304ea532012257f4ef class=toggle>
<label class="icon cursor" for=chapter-49f1e96591c090304ea532012257f4ef><a role=button></a></label><a href=http://172.16.201.134:1313/zh-tw/books/handbook/l10n/>章 22. 在地化 - i18n/L10n 使用與安裝</a><ul><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/l10n/#l10n-synopsis>22.1. 概述</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/l10n/#using-localization>22.2. 使用語系</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/l10n/#l10n-compiling>22.3. 尋找 i18n 應用程式</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/l10n/#lang-setup>22.4. 特定語言的語系設定</a></li></ul></li><li><input type=checkbox id=chapter-dead2b4c5ea325dd390a9b0dccd8f763 class=toggle>
<label class="icon cursor" for=chapter-dead2b4c5ea325dd390a9b0dccd8f763><a role=button></a></label><a href=http://172.16.201.134:1313/zh-tw/books/handbook/cutting-edge/>章 23. 更新與升級 FreeBSD</a><ul><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/cutting-edge/#updating-upgrading-synopsis>23.1. 概述</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/cutting-edge/#updating-upgrading-freebsdupdate>23.2. FreeBSD 更新</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/cutting-edge/#updating-upgrading-documentation>23.3. 更新文件集</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/cutting-edge/#current-stable>23.4. 追蹤開發分支</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/cutting-edge/#makeworld>23.5. 從原始碼更新 FreeBSD</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/cutting-edge/#small-lan>23.6. 多部機器追蹤</a></li></ul></li><li><input type=checkbox id=chapter-913e72bfb3d6947b2869d3e9447a6eaa class=toggle>
<label class="icon cursor" for=chapter-913e72bfb3d6947b2869d3e9447a6eaa><a role=button></a></label><a href=http://172.16.201.134:1313/zh-tw/books/handbook/usb-device-mode/>章 25. USB Device Mode / USB OTG</a><ul><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/usb-device-mode/#usb-device-mode-synopsis>25.1. 概述</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/usb-device-mode/#usb-device-mode-terminals>25.2. USB 虛擬序列埠</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/usb-device-mode/#usb-device-mode-network>25.3. USB 裝置模式網路介面</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/usb-device-mode/#usb-device-mode-storage>25.4. USB 虛擬儲存裝置</a></li></ul></li><li><input type=checkbox id=chapter-bbd25f9a194f9c39ca2d658c75767db5 class=toggle>
<label for=chapter-bbd25f9a194f9c39ca2d658c75767db5><a role=button></a></label><a href=http://172.16.201.134:1313/zh-tw/books/handbook/partiv/>部 IV. 網路通訊</a></li><li><input type=checkbox id=chapter-29c1eeb0e9dedc487a98399e2737ee8a class=toggle>
<label class="icon cursor" for=chapter-29c1eeb0e9dedc487a98399e2737ee8a><a role=button></a></label><a href=http://172.16.201.134:1313/zh-tw/books/handbook/dtrace/>章 24. DTrace</a><ul><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/dtrace/#dtrace-synopsis>24.1. 概述</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/dtrace/#dtrace-implementation>24.2. 實作差異</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/dtrace/#dtrace-enable>24.3. 開啟 DTrace 支援</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/dtrace/#dtrace-using>24.4. 使用 DTrace</a></li></ul></li><li><input type=checkbox id=chapter-499dab596afd7ddac77e80295314e0dd class=toggle>
<label class="icon cursor" for=chapter-499dab596afd7ddac77e80295314e0dd><a role=button></a></label><a href=http://172.16.201.134:1313/zh-tw/books/handbook/serialcomms/>章 26. 序列通訊</a><ul><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/serialcomms/#serial-synopsis>26.1. 概述</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/serialcomms/#serial>26.2. 序列術語與硬體</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/serialcomms/#term>26.3. 終端機</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/serialcomms/#dialup>26.4. 撥入服務</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/serialcomms/#dialout>26.5. 撥出服務</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/serialcomms/#serialconsole-setup>26.6. 設定序列 Console</a></li></ul></li><li><input type=checkbox id=chapter-95e4571c48bee1cced5e84a538d302e3 class=toggle>
<label class="icon cursor" for=chapter-95e4571c48bee1cced5e84a538d302e3><a role=button></a></label><a href=http://172.16.201.134:1313/zh-tw/books/handbook/ppp-and-slip/>章 27. PPP</a><ul><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/ppp-and-slip/#ppp-and-slip-synopsis>27.1. 概述</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/ppp-and-slip/#userppp>27.2. 設定 PPP</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/ppp-and-slip/#ppp-troubleshoot>27.3. PPP 連線疑難排解</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/ppp-and-slip/#pppoe>27.4. 在乙太網路使用 PPP (PPPoE)</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/ppp-and-slip/#pppoa>27.5. 在 ATM 使用 PPP (PPPoA)</a></li></ul></li><li><input type=checkbox id=chapter-f089ac726c401c9b4bd5c34a295e11bb class=toggle>
<label class="icon cursor" for=chapter-f089ac726c401c9b4bd5c34a295e11bb><a role=button></a></label><a href=http://172.16.201.134:1313/zh-tw/books/handbook/mail/>章 28. 電子郵件</a><ul><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/mail/#mail-synopsis>28.1. 概述</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/mail/#mail-using>28.2. 郵件組成</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/mail/#sendmail>28.3. Sendmail 設定檔</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/mail/#mail-changingmta>28.4. 更改郵件傳輸代理程式</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/mail/#mail-trouble>28.5. 疑難排解</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/mail/#mail-advanced>28.6. 進階主題</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/mail/#outgoing-only>28.7. 寄件設定</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/mail/#SMTP-dialup>28.8. 在撥號連線使用郵件</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/mail/#SMTP-Auth>28.9. SMTP 認證</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/mail/#mail-agents>28.10. 郵件使用者代理程式</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/mail/#mail-fetchmail>28.11. 使用 fetchmail</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/mail/#mail-procmail>28.12. 使用 procmail</a></li></ul></li><li><input type=checkbox id=chapter-6de4de3fe925639d4175ce4b6f8c1829 class=toggle>
<label class="icon cursor" for=chapter-6de4de3fe925639d4175ce4b6f8c1829><a role=button></a></label><a href=http://172.16.201.134:1313/zh-tw/books/handbook/network-servers/>章 29. 網路伺服器</a><ul><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/network-servers/#network-servers-synopsis>29.1. 概述</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/network-servers/#network-inetd>29.2. inetd 超級伺服器</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/network-servers/#network-nfs>29.3. 網路檔案系統 (NFS)</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/network-servers/#network-nis>29.4. 網路資訊系統 (NIS)</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/network-servers/#network-ldap>29.5. 輕量級目錄存取協定 (LDAP)</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/network-servers/#network-dhcp>29.6. 動態主機設置協定 (DHCP)</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/network-servers/#network-dns>29.7. 網域名稱系統 (DNS)</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/network-servers/#network-apache>29.8. Apache HTTP 伺服器</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/network-servers/#network-ftp>29.9. 檔案傳輸協定 (FTP)</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/network-servers/#network-samba>29.10. Microsoft™Windows™ 用戶端檔案與列印服務 (Samba)</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/network-servers/#network-ntp>29.11. NTP 時間校對</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/network-servers/#network-iscsi>29.12. iSCSI Initiator 與 Target 設定</a></li></ul></li><li><input type=checkbox id=chapter-776d855c7b75e048f90b5c2c9b35ffe0 class=toggle>
<label class="icon cursor" for=chapter-776d855c7b75e048f90b5c2c9b35ffe0><a role=button></a></label><a href=http://172.16.201.134:1313/zh-tw/books/handbook/firewalls/>章 30. 防火牆</a><ul><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/firewalls/#firewalls-intro>30.1. 概述</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/firewalls/#firewalls-concepts>30.2. 防火牆概念</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/firewalls/#firewalls-pf>30.3. PF</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/firewalls/#firewalls-ipfw>30.4. IPFW</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/firewalls/#firewalls-ipf>30.5. IPFILTER (IPF)</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/firewalls/#firewalls-blacklistd>30.6. Blacklistd</a></li></ul></li><li><input type=checkbox id=chapter-5b07f776a0e6155c1c89aa0d15610380 class=toggle>
<label class="icon cursor" for=chapter-5b07f776a0e6155c1c89aa0d15610380><a role=button></a></label><a href=http://172.16.201.134:1313/zh-tw/books/handbook/advanced-networking/>章 31. 進階網路設定</a><ul><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/advanced-networking/#advanced-networking-synopsis>31.1. 概述</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/advanced-networking/#network-routing>31.2. 通訊閘與路由</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/advanced-networking/#network-wireless>31.3. 無線網路</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/advanced-networking/#network-usb-tethering>31.4. USB 網路共享</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/advanced-networking/#network-bluetooth>31.5. 藍牙</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/advanced-networking/#network-bridging>31.6. 橋接</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/advanced-networking/#network-aggregation>31.7. Link Aggregation 與容錯移轉</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/advanced-networking/#network-diskless>31.8. PXE 無磁碟作業</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/advanced-networking/#network-ipv6>31.9. IPv6</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/advanced-networking/#carp>31.10. 共用位址備援協定 (CARP)</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/advanced-networking/#network-vlan>31.11. VLANs</a></li></ul></li><li><input type=checkbox id=chapter-171a77aa9d067a1024f849470e1f33e8 class=toggle>
<label for=chapter-171a77aa9d067a1024f849470e1f33e8><a role=button></a></label><a href=http://172.16.201.134:1313/zh-tw/books/handbook/partv/>部 V. 附錄</a></li><li><input type=checkbox id=chapter-8050f436a0a7986a4aaded93d8e49469 class=toggle>
<label class="icon cursor" for=chapter-8050f436a0a7986a4aaded93d8e49469><a role=button></a></label><a href=http://172.16.201.134:1313/zh-tw/books/handbook/mirrors/>附錄 A. 取得 FreeBSD</a><ul><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/mirrors/#mirrors-cdrom>A.1. CD 與 DVD 合集</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/mirrors/#mirrors-ftp>A.2. FTP 站</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/mirrors/#svn>A.3. 使用 Subversion</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/mirrors/#mirrors-rsync>A.4. 使用 rsync</a></li></ul></li><li><input type=checkbox id=chapter-128b630a8f88f158e7027fe6c2184d21 class=toggle>
<label class="icon cursor" for=chapter-128b630a8f88f158e7027fe6c2184d21><a role=button></a></label><a href=http://172.16.201.134:1313/zh-tw/books/handbook/bibliography/>附錄 B. 參考書目</a><ul><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/bibliography/#bibliography-freebsd>B.1. FreeBSD 相關書籍</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/bibliography/#bibliography-userguides>B.2. 使用指南</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/bibliography/#bibliography-adminguides>B.3. 管理指南</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/bibliography/#bibliography-programmers>B.4. 開發指南</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/bibliography/#bibliography-osinternals>B.5. 深入作業系統</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/bibliography/#bibliography-security>B.6. 安全性參考文獻</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/bibliography/#bibliography-hardware>B.7. 硬體參考文獻</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/bibliography/#bibliography-history>B.8. UNIX™ 歷史</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/bibliography/#bibliography-journals>B.9. 期刊與雜誌</a></li></ul></li><li><input type=checkbox id=chapter-8bbb8867c46dac315e2253945d8c18a8 class=toggle>
<label class="icon cursor" for=chapter-8bbb8867c46dac315e2253945d8c18a8><a role=button></a></label><a href=http://172.16.201.134:1313/zh-tw/books/handbook/eresources/>附錄 C. 網路資源</a><ul><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/eresources/#eresources-www>C.1. 網站</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/eresources/#eresources-mail>C.2. 郵遞論壇 (Mailing List)</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/eresources/#eresources-news>C.3. Usenet 新聞群組</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/eresources/#eresources-web>C.4. 官方鏡像站</a></li></ul></li><li><input type=checkbox id=chapter-a80ea4f5a4480b8725422710f954ef36 class=toggle>
<label class="icon cursor" for=chapter-a80ea4f5a4480b8725422710f954ef36><a role=button></a></label><a href=http://172.16.201.134:1313/zh-tw/books/handbook/pgpkeys/>附錄 D. OpenPGP 金鑰</a><ul><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/pgpkeys/#pgpkeys-officers>D.1. Officers</a></li></ul></li><li></li></ul></nav></div></aside><div class=book><div class=book-menu-mobile><label for=menu-control><span class=menu-control-button><i class="fa fa-list" aria-hidden=true title="Book menu"></i>
Book menu</span></label></div><h1 class=title>章 18. GEOM: 模組化磁碟轉換框架</h1><div class="admonitionblock note"><p><i class="fa fa-exclamation-circle" aria-hidden=true></i>
This translation may be out of date. To help with the translations please access the <a href=https://translate-dev.freebsd.org/ target=_blank>FreeBSD translations instance</a>.</p></div><div class=toc-mobile><h3>目錄</h3><nav id=TableOfContents><ul><li><a href=#geom-synopsis>18.1. 概述</a></li><li><a href=#geom-striping>18.2. RAID0 - 串連 (Striping)</a></li><li><a href=#geom-mirror>18.3. RAID1 - 鏡像 (Mirroring)</a></li><li><a href=#geom-raid3>18.4. RAID3 - 位元級串連與獨立奇偶校驗</a></li><li><a href=#geom-graid>18.5. 軟體 RAID 裝置</a></li><li><a href=#geom-ggate>18.6. GEOM Gate Network</a></li><li><a href=#geom-glabel>18.7. 磁碟裝置標籤</a></li><li><a href=#geom-gjournal>18.8. UFS Journaling 透過 GEOM</a></li></ul></nav></div><div class=book-content><div id=preamble><div class=sectionbody></div></div><div class=sect1><h2 id=geom-synopsis>18.1. 概述<a class=anchor href=#geom-synopsis></a></h2><div class=sectionbody><div class=paragraph><p>在 FreeBSD 中，GEOM 可允許對類別做存取與控制，例如：主開機記錄 (Master Boot Record) 與 BSD 標籤，透過利用提供者，或在 <span class=filename>/dev</span> 中的磁碟裝置。透過支援各種 RAID 的配置，GEOM 透明的提供了對作業系統與作業系統工具的存取。</p></div><div class=paragraph><p>This chapter covers the use of disks under the GEOM framework in FreeBSD. This includes the major RAID control utilities which use the framework for configuration. This chapter is not a definitive guide to RAID configurations and only GEOM-supported RAID classifications are discussed.</p></div><div class=paragraph><p>讀完這章，您將了解：</p></div><div class=ulist><ul><li><p>What type of RAID support is available through GEOM.</p></li><li><p>How to use the base utilities to configure, maintain, and manipulate the various RAID levels.</p></li><li><p>How to mirror, stripe, encrypt, and remotely connect disk devices through GEOM.</p></li><li><p>How to troubleshoot disks attached to the GEOM framework.</p></li></ul></div><div class=paragraph><p>在開始閱讀這章之前，您需要：</p></div><div class=ulist><ul><li><p>Understand how FreeBSD treats disk devices (<a href=../disks/#disks>儲存設備</a>).</p></li><li><p>了解如何設定並安裝新的核心 (<a href=../kernelconfig/#kernelconfig>設定 FreeBSD 核心</a>)。</p></li></ul></div></div></div><div class=sect1><h2 id=geom-striping>18.2. RAID0 - 串連 (Striping)<a class=anchor href=#geom-striping></a></h2><div class=sectionbody><div class=paragraph><p>串連會合併數個磁碟成單一個磁碟區 (Volume)，可以透過使用硬體 RAID 控制器來做到串連。GEOM 磁碟子系統提供了軟體支援的磁碟串連，也就是所謂的 RAID0，而不需要 RAID 磁碟控制器。</p></div><div class=paragraph><p>在 RAID0 中，資料會被切割成數個資料區塊 (Block) 寫入到磁碟陣列中的每一個磁碟機。如下圖所示，取代以往等候系統寫入 256k 到一個磁碟的時間， RAID0 可以同時寫入 64k 到磁碟陣列中四個磁碟的每個磁碟，這可提供優異的 I/O 效能，若使用多個磁碟控制器可增加更多的效能。</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/geom/striping.png alt="Disk Striping Illustration"></div></div><div class=paragraph><p>在 RAID0 串連中的每個磁碟必須要相同大小，因為 I/O 的請求是平行交錯讀取或寫入到多個磁碟的。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>RAID0 並<em>不</em>提供任何備援 (Redundancy) 功能。這意謂著若磁碟陣列中的其中一個磁碟故障，所有在該磁碟上的資料便會遺失。若資料很重要，請規畫備份策略，定期儲存備份到遠端系統或裝置。</p></div></td></tr></tbody></table></div><div class=paragraph><p>The process for creating a software, GEOM-based RAID0 on a FreeBSD system using commodity disks is as follows. Once the stripe is created, refer to <a href="https://man.freebsd.org/cgi/man.cgi?query=gstripe&amp;sektion=8&amp;format=html">gstripe(8)</a> for more information on how to control an existing stripe.</p></div><div class="exampleblock procedure"><div class=content><div class=paragraph><p><strong>Procedure: Creating a Stripe of Unformatted ATA Disks</strong></p></div><div class="olist arabic"><ol class=arabic><li><p>Load the <span class=filename>geom_stripe.ko</span> module:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload geom_stripe</span></code></pre></div></div></li><li><p>Ensure that a suitable mount point exists. If this volume will become a root partition, then temporarily use another mount point such as <span class=filename>/mnt</span>.</p></li><li><p>Determine the device names for the disks which will be striped, and create the new stripe device. For example, to stripe two unused and unpartitioned ATA disks with device names of <span class=filename>/dev/ad2</span> and <span class=filename>/dev/ad3</span>:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gstripe label -v st0 /dev/ad2 /dev/ad3</span>
Metadata value stored on /dev/ad2.
Metadata value stored on /dev/ad3.
Done.</code></pre></div></div></li><li><p>Write a standard label, also known as a partition table, on the new volume and install the default bootstrap code:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># bsdlabel -wB /dev/stripe/st0</span></code></pre></div></div></li><li><p>This process should create two other devices in <span class=filename>/dev/stripe</span> in addition to <span class=filename>st0</span>. Those include <span class=filename>st0a</span> and <span class=filename>st0c</span>. At this point, a UFS file system can be created on <span class=filename>st0a</span> using <code>newfs</code>:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># newfs -U /dev/stripe/st0a</span></code></pre></div></div><div class=paragraph><p>Many numbers will glide across the screen, and after a few seconds, the process will be complete. The volume has been created and is ready to be mounted.</p></div></li><li><p>To manually mount the created disk stripe:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount /dev/stripe/st0a /mnt</span></code></pre></div></div></li><li><p>To mount this striped file system automatically during the boot process, place the volume information in <span class=filename>/etc/fstab</span>. In this example, a permanent mount point, named <span class=filename>stripe</span>, is created:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mkdir /stripe</span>
<span class=c># echo &#34;/dev/stripe/st0a /stripe ufs rw 2 2&#34; \</span>
<span class=o>&gt;&gt;</span> /etc/fstab</code></pre></div></div></li><li><p>The <span class=filename>geom_stripe.ko</span> module must also be automatically loaded during system initialization, by adding a line to <span class=filename>/boot/loader.conf</span>:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysrc -f /boot/loader.conf geom_stripe_load=YES</span></code></pre></div></div></li></ol></div></div></div></div></div><div class=sect1><h2 id=geom-mirror>18.3. RAID1 - 鏡像 (Mirroring)<a class=anchor href=#geom-mirror></a></h2><div class=sectionbody><div class=paragraph><p>RAID1 或<em>鏡像</em>是一項寫入相同資料到超過一個磁碟機的技術。鏡像通常用來保護資料因磁碟機故障導致的損失，每個在鏡像中的磁碟機會擁有完全相同的資料，當各別磁碟機故障時，鏡像會繼續運作，由還可運作的磁碟機提供資料。電腦會繼續執行，等到管理者有時間更換故障的硬碟，而不會被使用者中斷運作。</p></div><div class=paragraph><p>Two common situations are illustrated in these examples. The first creates a mirror out of two new drives and uses it as a replacement for an existing single drive. The second example creates a mirror on a single new drive, copies the old drive’s data to it, then inserts the old drive into the mirror. While this procedure is slightly more complicated, it only requires one new drive.</p></div><div class=paragraph><p>Traditionally, the two drives in a mirror are identical in model and capacity, but <a href="https://man.freebsd.org/cgi/man.cgi?query=gmirror&amp;sektion=8&amp;format=html">gmirror(8)</a> does not require that. Mirrors created with dissimilar drives will have a capacity equal to that of the smallest drive in the mirror. Extra space on larger drives will be unused. Drives inserted into the mirror later must have at least as much capacity as the smallest drive already in the mirror.</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>The mirroring procedures shown here are non-destructive, but as with any major disk operation, make a full backup first.</p></div></td></tr></tbody></table></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>While <a href="https://man.freebsd.org/cgi/man.cgi?query=dump&amp;sektion=8&amp;format=html">dump(8)</a> is used in these procedures to copy file systems, it does not work on file systems with soft updates journaling. See <a href="https://man.freebsd.org/cgi/man.cgi?query=tunefs&amp;sektion=8&amp;format=html">tunefs(8)</a> for information on detecting and disabling soft updates journaling.</p></div></td></tr></tbody></table></div><div class=sect2><h3 id=geom-mirror-metadata>18.3.1. Metadata 問題<a class=anchor href=#geom-mirror-metadata></a></h3><div class=paragraph><p>Many disk systems store metadata at the end of each disk. Old metadata should be erased before reusing the disk for a mirror. Most problems are caused by two particular types of leftover metadata: GPT partition tables and old metadata from a previous mirror.</p></div><div class=paragraph><p>GPT metadata can be erased with <a href="https://man.freebsd.org/cgi/man.cgi?query=gpart&amp;sektion=8&amp;format=html">gpart(8)</a>. This example erases both primary and backup GPT partition tables from disk <span class=filename>ada8</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gpart destroy -F ada8</span></code></pre></div></div><div class=paragraph><p>A disk can be removed from an active mirror and the metadata erased in one step using <a href="https://man.freebsd.org/cgi/man.cgi?query=gmirror&amp;sektion=8&amp;format=html">gmirror(8)</a>. Here, the example disk <span class=filename>ada8</span> is removed from the active mirror <span class=filename>gm4</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gmirror remove gm4 ada8</span></code></pre></div></div><div class=paragraph><p>If the mirror is not running, but old mirror metadata is still on the disk, use <code>gmirror clear</code> to remove it:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gmirror clear ada8</span></code></pre></div></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=gmirror&amp;sektion=8&amp;format=html">gmirror(8)</a> stores one block of metadata at the end of the disk. Because GPT partition schemes also store metadata at the end of the disk, mirroring entire GPT disks with <a href="https://man.freebsd.org/cgi/man.cgi?query=gmirror&amp;sektion=8&amp;format=html">gmirror(8)</a> is not recommended. MBR partitioning is used here because it only stores a partition table at the start of the disk and does not conflict with the mirror metadata.</p></div></div><div class=sect2><h3 id=geom-mirror-two-new-disks>18.3.2. 使用兩個新磁碟建立鏡像<a class=anchor href=#geom-mirror-two-new-disks></a></h3><div class=paragraph><p>In this example, FreeBSD has already been installed on a single disk, <span class=filename>ada0</span>. Two new disks, <span class=filename>ada1</span> and <span class=filename>ada2</span>, have been connected to the system. A new mirror will be created on these two disks and used to replace the old single disk.</p></div><div class=paragraph><p>The <span class=filename>geom_mirror.ko</span> kernel module must either be built into the kernel or loaded at boot- or run-time. Manually load the kernel module now:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gmirror load</span></code></pre></div></div><div class=paragraph><p>Create the mirror with the two new drives:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gmirror label -v gm0 /dev/ada1 /dev/ada2</span></code></pre></div></div><div class=paragraph><p><span class=filename>gm0</span> is a user-chosen device name assigned to the new mirror. After the mirror has been started, this device name appears in <span class=filename>/dev/mirror/</span>.</p></div><div class=paragraph><p>MBR and bsdlabel partition tables can now be created on the mirror with <a href="https://man.freebsd.org/cgi/man.cgi?query=gpart&amp;sektion=8&amp;format=html">gpart(8)</a>. This example uses a traditional file system layout, with partitions for <span class=filename>/</span>, swap, <span class=filename>/var</span>, <span class=filename>/tmp</span>, and <span class=filename>/usr</span>. A single <span class=filename>/</span> and a swap partition will also work.</p></div><div class=paragraph><p>Partitions on the mirror do not have to be the same size as those on the existing disk, but they must be large enough to hold all the data already present on <span class=filename>ada0</span>.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gpart create -s MBR mirror/gm0</span>
<span class=c># gpart add -t freebsd -a 4k mirror/gm0</span>
<span class=c># gpart show mirror/gm0</span>
<span class=o>=&gt;</span>       63  156301423  mirror/gm0  MBR  <span class=o>(</span>74G<span class=o>)</span>
         63         63                    - free -  <span class=o>(</span>31k<span class=o>)</span>
        126  156301299                 1  freebsd  <span class=o>(</span>74G<span class=o>)</span>
  156301425         61                    - free -  <span class=o>(</span>30k<span class=o>)</span></code></pre></div></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gpart create -s BSD mirror/gm0s1</span>
<span class=c># gpart add -t freebsd-ufs  -a 4k -s 2g mirror/gm0s1</span>
<span class=c># gpart add -t freebsd-swap -a 4k -s 4g mirror/gm0s1</span>
<span class=c># gpart add -t freebsd-ufs  -a 4k -s 2g mirror/gm0s1</span>
<span class=c># gpart add -t freebsd-ufs  -a 4k -s 1g mirror/gm0s1</span>
<span class=c># gpart add -t freebsd-ufs  -a 4k       mirror/gm0s1</span>
<span class=c># gpart show mirror/gm0s1</span>
<span class=o>=&gt;</span>        0  156301299  mirror/gm0s1  BSD  <span class=o>(</span>74G<span class=o>)</span>
          0          2                      - free -  <span class=o>(</span>1.0k<span class=o>)</span>
          2    4194304                   1  freebsd-ufs  <span class=o>(</span>2.0G<span class=o>)</span>
    4194306    8388608                   2  freebsd-swap  <span class=o>(</span>4.0G<span class=o>)</span>
   12582914    4194304                   4  freebsd-ufs  <span class=o>(</span>2.0G<span class=o>)</span>
   16777218    2097152                   5  freebsd-ufs  <span class=o>(</span>1.0G<span class=o>)</span>
   18874370  137426928                   6  freebsd-ufs  <span class=o>(</span>65G<span class=o>)</span>
  156301298          1                      - free -  <span class=o>(</span>512B<span class=o>)</span></code></pre></div></div><div class=paragraph><p>Make the mirror bootable by installing bootcode in the MBR and bsdlabel and setting the active slice:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gpart bootcode -b /boot/mbr mirror/gm0</span>
<span class=c># gpart set -a active -i 1 mirror/gm0</span>
<span class=c># gpart bootcode -b /boot/boot mirror/gm0s1</span></code></pre></div></div><div class=paragraph><p>Format the file systems on the new mirror, enabling soft-updates.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># newfs -U /dev/mirror/gm0s1a</span>
<span class=c># newfs -U /dev/mirror/gm0s1d</span>
<span class=c># newfs -U /dev/mirror/gm0s1e</span>
<span class=c># newfs -U /dev/mirror/gm0s1f</span></code></pre></div></div><div class=paragraph><p>File systems from the original <span class=filename>ada0</span> disk can now be copied onto the mirror with <a href="https://man.freebsd.org/cgi/man.cgi?query=dump&amp;sektion=8&amp;format=html">dump(8)</a> and <a href="https://man.freebsd.org/cgi/man.cgi?query=restore&amp;sektion=8&amp;format=html">restore(8)</a>.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount /dev/mirror/gm0s1a /mnt</span>
<span class=c># dump -C16 -b64 -0aL -f - / | (cd /mnt &amp;&amp; restore -rf -)</span>
<span class=c># mount /dev/mirror/gm0s1d /mnt/var</span>
<span class=c># mount /dev/mirror/gm0s1e /mnt/tmp</span>
<span class=c># mount /dev/mirror/gm0s1f /mnt/usr</span>
<span class=c># dump -C16 -b64 -0aL -f - /var | (cd /mnt/var &amp;&amp; restore -rf -)</span>
<span class=c># dump -C16 -b64 -0aL -f - /tmp | (cd /mnt/tmp &amp;&amp; restore -rf -)</span>
<span class=c># dump -C16 -b64 -0aL -f - /usr | (cd /mnt/usr &amp;&amp; restore -rf -)</span></code></pre></div></div><div class=paragraph><p>Edit <span class=filename>/mnt/etc/fstab</span> to point to the new mirror file systems:</p></div><div class="literalblock programlisting"><div class=content><pre># Device		Mountpoint	FStype	Options	Dump	Pass#
/dev/mirror/gm0s1a	/		ufs	rw	1	1
/dev/mirror/gm0s1b	none		swap	sw	0	0
/dev/mirror/gm0s1d	/var		ufs	rw	2	2
/dev/mirror/gm0s1e	/tmp		ufs	rw	2	2
/dev/mirror/gm0s1f	/usr		ufs	rw	2	2</pre></div></div><div class=paragraph><p>If the <span class=filename>geom_mirror.ko</span> kernel module has not been built into the kernel, <span class=filename>/mnt/boot/loader.conf</span> is edited to load the module at boot:</p></div><div class="literalblock programlisting"><div class=content><pre>geom_mirror_load=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Reboot the system to test the new mirror and verify that all data has been copied. The BIOS will see the mirror as two individual drives rather than a mirror. Because the drives are identical, it does not matter which is selected to boot.</p></div><div class=paragraph><p>See <a href=#gmirror-troubleshooting>疑難排解</a> if there are problems booting. Powering down and disconnecting the original <span class=filename>ada0</span> disk will allow it to be kept as an offline backup.</p></div><div class=paragraph><p>In use, the mirror will behave just like the original single drive.</p></div></div><div class=sect2><h3 id=geom-mirror-existing-drive>18.3.3. 使用既有磁碟建立鏡像<a class=anchor href=#geom-mirror-existing-drive></a></h3><div class=paragraph><p>In this example, FreeBSD has already been installed on a single disk, <span class=filename>ada0</span>. A new disk, <span class=filename>ada1</span>, has been connected to the system. A one-disk mirror will be created on the new disk, the existing system copied onto it, and then the old disk will be inserted into the mirror. This slightly complex procedure is required because <code>gmirror</code> needs to put a 512-byte block of metadata at the end of each disk, and the existing <span class=filename>ada0</span> has usually had all of its space already allocated.</p></div><div class=paragraph><p>Load the <span class=filename>geom_mirror.ko</span> kernel module:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gmirror load</span></code></pre></div></div><div class=paragraph><p>Check the media size of the original disk with <code>diskinfo</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># diskinfo -v ada0 | head -n3</span>
/dev/ada0
	512             <span class=c># sectorsize</span>
	1000204821504   <span class=c># mediasize in bytes (931G)</span></code></pre></div></div><div class=paragraph><p>Create a mirror on the new disk. To make certain that the mirror capacity is not any larger than the original <span class=filename>ada0</span> drive, <a href="https://man.freebsd.org/cgi/man.cgi?query=gnop&amp;sektion=8&amp;format=html">gnop(8)</a> is used to create a fake drive of the exact same size. This drive does not store any data, but is used only to limit the size of the mirror. When <a href="https://man.freebsd.org/cgi/man.cgi?query=gmirror&amp;sektion=8&amp;format=html">gmirror(8)</a> creates the mirror, it will restrict the capacity to the size of <span class=filename>gzero.nop</span>, even if the new <span class=filename>ada1</span> drive has more space. Note that the <em>1000204821504</em> in the second line is equal to <span class=filename>ada0</span>'s media size as shown by <code>diskinfo</code> above.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># geom zero load</span>
<span class=c># gnop create -s 1000204821504 gzero</span>
<span class=c># gmirror label -v gm0 gzero.nop ada1</span>
<span class=c># gmirror forget gm0</span></code></pre></div></div><div class=paragraph><p>Since <span class=filename>gzero.nop</span> does not store any data, the mirror does not see it as connected. The mirror is told to "forget" unconnected components, removing references to <span class=filename>gzero.nop</span>. The result is a mirror device containing only a single disk, <span class=filename>ada1</span>.</p></div><div class=paragraph><p>After creating <span class=filename>gm0</span>, view the partition table on <span class=filename>ada0</span>. This output is from a 1 TB drive. If there is some unallocated space at the end of the drive, the contents may be copied directly from <span class=filename>ada0</span> to the new mirror.</p></div><div class=paragraph><p>However, if the output shows that all of the space on the disk is allocated, as in the following listing, there is no space available for the 512-byte mirror metadata at the end of the disk.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gpart show ada0</span>
<span class=o>=&gt;</span>        63  1953525105        ada0  MBR  <span class=o>(</span>931G<span class=o>)</span>
          63  1953525105           1  freebsd  <span class=o>[</span>active]  <span class=o>(</span>931G<span class=o>)</span></code></pre></div></div><div class=paragraph><p>In this case, the partition table must be edited to reduce the capacity by one sector on <span class=filename>mirror/gm0</span>. The procedure will be explained later.</p></div><div class=paragraph><p>In either case, partition tables on the primary disk should be first copied using <code>gpart backup</code> and <code>gpart restore</code>.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gpart backup ada0 &gt; table.ada0</span>
<span class=c># gpart backup ada0s1 &gt; table.ada0s1</span></code></pre></div></div><div class=paragraph><p>These commands create two files, <span class=filename>table.ada0</span> and <span class=filename>table.ada0s1</span>. This example is from a 1 TB drive:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cat table.ada0</span>
MBR 4
1 freebsd         63 1953525105   <span class=o>[</span>active]</code></pre></div></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cat table.ada0s1</span>
BSD 8
1  freebsd-ufs          0    4194304
2 freebsd-swap    4194304   33554432
4  freebsd-ufs   37748736   50331648
5  freebsd-ufs   88080384   41943040
6  freebsd-ufs  130023424  838860800
7  freebsd-ufs  968884224  984640881</code></pre></div></div><div class=paragraph><p>If no free space is shown at the end of the disk, the size of both the slice and the last partition must be reduced by one sector. Edit the two files, reducing the size of both the slice and last partition by one. These are the last numbers in each listing.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cat table.ada0</span>
MBR 4
1 freebsd         63 1953525104   <span class=o>[</span>active]</code></pre></div></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cat table.ada0s1</span>
BSD 8
1  freebsd-ufs          0    4194304
2 freebsd-swap    4194304   33554432
4  freebsd-ufs   37748736   50331648
5  freebsd-ufs   88080384   41943040
6  freebsd-ufs  130023424  838860800
7  freebsd-ufs  968884224  984640880</code></pre></div></div><div class=paragraph><p>If at least one sector was unallocated at the end of the disk, these two files can be used without modification.</p></div><div class=paragraph><p>Now restore the partition table into <span class=filename>mirror/gm0</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gpart restore mirror/gm0 &lt; table.ada0</span>
<span class=c># gpart restore mirror/gm0s1 &lt; table.ada0s1</span></code></pre></div></div><div class=paragraph><p>Check the partition table with <code>gpart show</code>. This example has <span class=filename>gm0s1a</span> for <span class=filename>/</span>, <span class=filename>gm0s1d</span> for <span class=filename>/var</span>, <span class=filename>gm0s1e</span> for <span class=filename>/usr</span>, <span class=filename>gm0s1f</span> for <span class=filename>/data1</span>, and <span class=filename>gm0s1g</span> for <span class=filename>/data2</span>.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gpart show mirror/gm0</span>
<span class=o>=&gt;</span>        63  1953525104  mirror/gm0  MBR  <span class=o>(</span>931G<span class=o>)</span>
          63  1953525042           1  freebsd  <span class=o>[</span>active]  <span class=o>(</span>931G<span class=o>)</span>
  1953525105          62              - free -  <span class=o>(</span>31k<span class=o>)</span>

<span class=c># gpart show mirror/gm0s1</span>
<span class=o>=&gt;</span>         0  1953525042  mirror/gm0s1  BSD  <span class=o>(</span>931G<span class=o>)</span>
           0     2097152             1  freebsd-ufs  <span class=o>(</span>1.0G<span class=o>)</span>
     2097152    16777216             2  freebsd-swap  <span class=o>(</span>8.0G<span class=o>)</span>
    18874368    41943040             4  freebsd-ufs  <span class=o>(</span>20G<span class=o>)</span>
    60817408    20971520             5  freebsd-ufs  <span class=o>(</span>10G<span class=o>)</span>
    81788928   629145600             6  freebsd-ufs  <span class=o>(</span>300G<span class=o>)</span>
   710934528  1242590514             7  freebsd-ufs  <span class=o>(</span>592G<span class=o>)</span>
  1953525042          63                - free -  <span class=o>(</span>31k<span class=o>)</span></code></pre></div></div><div class=paragraph><p>Both the slice and the last partition must have at least one free block at the end of the disk.</p></div><div class=paragraph><p>Create file systems on these new partitions. The number of partitions will vary to match the original disk, <span class=filename>ada0</span>.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># newfs -U /dev/mirror/gm0s1a</span>
<span class=c># newfs -U /dev/mirror/gm0s1d</span>
<span class=c># newfs -U /dev/mirror/gm0s1e</span>
<span class=c># newfs -U /dev/mirror/gm0s1f</span>
<span class=c># newfs -U /dev/mirror/gm0s1g</span></code></pre></div></div><div class=paragraph><p>Make the mirror bootable by installing bootcode in the MBR and bsdlabel and setting the active slice:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gpart bootcode -b /boot/mbr mirror/gm0</span>
<span class=c># gpart set -a active -i 1 mirror/gm0</span>
<span class=c># gpart bootcode -b /boot/boot mirror/gm0s1</span></code></pre></div></div><div class=paragraph><p>Adjust <span class=filename>/etc/fstab</span> to use the new partitions on the mirror. Back up this file first by copying it to <span class=filename>/etc/fstab.orig</span>.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cp /etc/fstab /etc/fstab.orig</span></code></pre></div></div><div class=paragraph><p>Edit <span class=filename>/etc/fstab</span>, replacing <span class=filename>/dev/ada0</span> with <span class=filename>mirror/gm0</span>.</p></div><div class="literalblock programlisting"><div class=content><pre># Device		Mountpoint	FStype	Options	Dump	Pass#
/dev/mirror/gm0s1a	/		ufs	rw	1	1
/dev/mirror/gm0s1b	none		swap	sw	0	0
/dev/mirror/gm0s1d	/var		ufs	rw	2	2
/dev/mirror/gm0s1e	/usr		ufs	rw	2	2
/dev/mirror/gm0s1f	/data1		ufs	rw	2	2
/dev/mirror/gm0s1g	/data2		ufs	rw	2	2</pre></div></div><div class=paragraph><p>If the <span class=filename>geom_mirror.ko</span> kernel module has not been built into the kernel, edit <span class=filename>/boot/loader.conf</span> to load it at boot:</p></div><div class="literalblock programlisting"><div class=content><pre>geom_mirror_load=&#34;YES&#34;</pre></div></div><div class=paragraph><p>File systems from the original disk can now be copied onto the mirror with <a href="https://man.freebsd.org/cgi/man.cgi?query=dump&amp;sektion=8&amp;format=html">dump(8)</a> and <a href="https://man.freebsd.org/cgi/man.cgi?query=restore&amp;sektion=8&amp;format=html">restore(8)</a>. Each file system dumped with <code>dump -L</code> will create a snapshot first, which can take some time.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount /dev/mirror/gm0s1a /mnt</span>
<span class=c># dump -C16 -b64 -0aL -f - /    | (cd /mnt &amp;&amp; restore -rf -)</span>
<span class=c># mount /dev/mirror/gm0s1d /mnt/var</span>
<span class=c># mount /dev/mirror/gm0s1e /mnt/usr</span>
<span class=c># mount /dev/mirror/gm0s1f /mnt/data1</span>
<span class=c># mount /dev/mirror/gm0s1g /mnt/data2</span>
<span class=c># dump -C16 -b64 -0aL -f - /usr | (cd /mnt/usr &amp;&amp; restore -rf -)</span>
<span class=c># dump -C16 -b64 -0aL -f - /var | (cd /mnt/var &amp;&amp; restore -rf -)</span>
<span class=c># dump -C16 -b64 -0aL -f - /data1 | (cd /mnt/data1 &amp;&amp; restore -rf -)</span>
<span class=c># dump -C16 -b64 -0aL -f - /data2 | (cd /mnt/data2 &amp;&amp; restore -rf -)</span></code></pre></div></div><div class=paragraph><p>Restart the system, booting from <span class=filename>ada1</span>. If everything is working, the system will boot from <span class=filename>mirror/gm0</span>, which now contains the same data as <span class=filename>ada0</span> had previously. See <a href=#gmirror-troubleshooting>疑難排解</a> if there are problems booting.</p></div><div class=paragraph><p>At this point, the mirror still consists of only the single <span class=filename>ada1</span> disk.</p></div><div class=paragraph><p>After booting from <span class=filename>mirror/gm0</span> successfully, the final step is inserting <span class=filename>ada0</span> into the mirror.</p></div><div class="admonitionblock important"><table><tbody><tr><td class=icon><i class="fa icon-important" title=Important></i></td><td class=content><div class=paragraph><p>When <span class=filename>ada0</span> is inserted into the mirror, its former contents will be overwritten by data from the mirror. Make certain that <span class=filename>mirror/gm0</span> has the same contents as <span class=filename>ada0</span> before adding <span class=filename>ada0</span> to the mirror. If the contents previously copied by <a href="https://man.freebsd.org/cgi/man.cgi?query=dump&amp;sektion=8&amp;format=html">dump(8)</a> and <a href="https://man.freebsd.org/cgi/man.cgi?query=restore&amp;sektion=8&amp;format=html">restore(8)</a> are not identical to what was on <span class=filename>ada0</span>, revert <span class=filename>/etc/fstab</span> to mount the file systems on <span class=filename>ada0</span>, reboot, and start the whole procedure again.</p></div></td></tr></tbody></table></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gmirror insert gm0 ada0</span>
GEOM_MIRROR: Device gm0: rebuilding provider ada0</code></pre></div></div><div class=paragraph><p>Synchronization between the two disks will start immediately. Use <code>gmirror status</code> to view the progress.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gmirror status</span>
      Name    Status  Components
mirror/gm0  DEGRADED  ada1 <span class=o>(</span>ACTIVE<span class=o>)</span>
                      ada0 <span class=o>(</span>SYNCHRONIZING, 64%<span class=o>)</span></code></pre></div></div><div class=paragraph><p>After a while, synchronization will finish.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>GEOM_MIRROR: Device gm0: rebuilding provider ada0 finished.
<span class=c># gmirror status</span>
      Name    Status  Components
mirror/gm0  COMPLETE  ada1 <span class=o>(</span>ACTIVE<span class=o>)</span>
                      ada0 <span class=o>(</span>ACTIVE<span class=o>)</span></code></pre></div></div><div class=paragraph><p><span class=filename>mirror/gm0</span> now consists of the two disks <span class=filename>ada0</span> and <span class=filename>ada1</span>, and the contents are automatically synchronized with each other. In use, <span class=filename>mirror/gm0</span> will behave just like the original single drive.</p></div></div><div class=sect2><h3 id=gmirror-troubleshooting>18.3.4. 疑難排解<a class=anchor href=#gmirror-troubleshooting></a></h3><div class=paragraph><p>If the system no longer boots, BIOS settings may have to be changed to boot from one of the new mirrored drives. Either mirror drive can be used for booting, as they contain identical data.</p></div><div class=paragraph><p>If the boot stops with this message, something is wrong with the mirror device:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Mounting from ufs:/dev/mirror/gm0s1a failed with error 19.

Loader variables:
  vfs.root.mountfrom<span class=o>=</span>ufs:/dev/mirror/gm0s1a
  vfs.root.mountfrom.options<span class=o>=</span>rw

Manual root filesystem specification:
  &lt;fstype&gt;:&lt;device&gt; <span class=o>[</span>options]
      Mount &lt;device&gt; using filesystem &lt;fstype&gt;
      and with the specified <span class=o>(</span>optional<span class=o>)</span> option list.

    eg. ufs:/dev/da0s1a
        zfs:tank
        cd9660:/dev/acd0 ro
          <span class=o>(</span>which is equivalent to: mount <span class=nt>-t</span> cd9660 <span class=nt>-o</span> ro /dev/acd0 /<span class=o>)</span>

  ?               List valid disk boot devices
  <span class=nb>.</span>               Yield 1 second <span class=o>(</span><span class=k>for </span>background tasks<span class=o>)</span>
  &lt;empty line&gt;    Abort manual input

mountroot&gt;</code></pre></div></div><div class=paragraph><p>Forgetting to load the <span class=filename>geom_mirror.ko</span> module in <span class=filename>/boot/loader.conf</span> can cause this problem. To fix it, boot from a FreeBSD installation media and choose <code>Shell</code> at the first prompt. Then load the mirror module and mount the mirror device:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gmirror load</span>
<span class=c># mount /dev/mirror/gm0s1a /mnt</span></code></pre></div></div><div class=paragraph><p>Edit <span class=filename>/mnt/boot/loader.conf</span>, adding a line to load the mirror module:</p></div><div class="literalblock programlisting"><div class=content><pre>geom_mirror_load=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Save the file and reboot.</p></div><div class=paragraph><p>Other problems that cause <code>error 19</code> require more effort to fix. Although the system should boot from <span class=filename>ada0</span>, another prompt to select a shell will appear if <span class=filename>/etc/fstab</span> is incorrect. Enter <code>ufs:/dev/ada0s1a</code> at the boot loader prompt and press <kbd>Enter</kbd>. Undo the edits in <span class=filename>/etc/fstab</span> then mount the file systems from the original disk (<span class=filename>ada0</span>) instead of the mirror. Reboot the system and try the procedure again.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Enter full pathname of shell or RETURN <span class=k>for</span> /bin/sh:
<span class=c># cp /etc/fstab.orig /etc/fstab</span>
<span class=c># reboot</span></code></pre></div></div></div><div class=sect2><h3 id=_自磁碟故障復原>18.3.5. 自磁碟故障復原<a class=anchor href=#_自磁碟故障復原></a></h3><div class=paragraph><p>The benefit of disk mirroring is that an individual disk can fail without causing the mirror to lose any data. In the above example, if <span class=filename>ada0</span> fails, the mirror will continue to work, providing data from the remaining working drive, <span class=filename>ada1</span>.</p></div><div class=paragraph><p>To replace the failed drive, shut down the system and physically replace the failed drive with a new drive of equal or greater capacity. Manufacturers use somewhat arbitrary values when rating drives in gigabytes, and the only way to really be sure is to compare the total count of sectors shown by <code>diskinfo -v</code>. A drive with larger capacity than the mirror will work, although the extra space on the new drive will not be used.</p></div><div class=paragraph><p>After the computer is powered back up, the mirror will be running in a "degraded" mode with only one drive. The mirror is told to forget drives that are not currently connected:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gmirror forget gm0</span></code></pre></div></div><div class=paragraph><p>Any old metadata should be cleared from the replacement disk using the instructions in <a href=#geom-mirror-metadata>Metadata 問題</a>. Then the replacement disk, <span class=filename>ada4</span> for this example, is inserted into the mirror:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gmirror insert gm0 /dev/ada4</span></code></pre></div></div><div class=paragraph><p>Resynchronization begins when the new drive is inserted into the mirror. This process of copying mirror data to a new drive can take a while. Performance of the mirror will be greatly reduced during the copy, so inserting new drives is best done when there is low demand on the computer.</p></div><div class=paragraph><p>Progress can be monitored with <code>gmirror status</code>, which shows drives that are being synchronized and the percentage of completion. During resynchronization, the status will be <code>DEGRADED</code>, changing to <code>COMPLETE</code> when the process is finished.</p></div></div></div></div><div class=sect1><h2 id=geom-raid3>18.4. RAID3 - 位元級串連與獨立奇偶校驗<a class=anchor href=#geom-raid3></a></h2><div class=sectionbody><div class=paragraph><p>RAID3 is a method used to combine several disk drives into a single volume with a dedicated parity disk. In a RAID3 system, data is split up into a number of bytes that are written across all the drives in the array except for one disk which acts as a dedicated parity disk. This means that disk reads from a RAID3 implementation access all disks in the array. Performance can be enhanced by using multiple disk controllers. The RAID3 array provides a fault tolerance of 1 drive, while providing a capacity of 1 - 1/n times the total capacity of all drives in the array, where n is the number of hard drives in the array. Such a configuration is mostly suitable for storing data of larger sizes such as multimedia files.</p></div><div class=paragraph><p>At least 3 physical hard drives are required to build a RAID3 array. Each disk must be of the same size, since I/O requests are interleaved to read or write to multiple disks in parallel. Also, due to the nature of RAID3, the number of drives must be equal to 3, 5, 9, 17, and so on, or 2^n + 1.</p></div><div class=paragraph><p>This section demonstrates how to create a software RAID3 on a FreeBSD system.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>While it is theoretically possible to boot from a RAID3 array on FreeBSD, that configuration is uncommon and is not advised.</p></div></td></tr></tbody></table></div><div class=sect2><h3 id=_建立_dedicated_raid3_陣列>18.4.1. 建立 Dedicated RAID3 陣列<a class=anchor href=#_建立_dedicated_raid3_陣列></a></h3><div class=paragraph><p>In FreeBSD, support for RAID3 is implemented by the <a href="https://man.freebsd.org/cgi/man.cgi?query=graid3&amp;sektion=8&amp;format=html">graid3(8)</a>GEOM class. Creating a dedicated RAID3 array on FreeBSD requires the following steps.</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>First, load the <span class=filename>geom_raid3.ko</span> kernel module by issuing one of the following commands:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># graid3 load</span></code></pre></div></div><div class=paragraph><p>or:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload geom_raid3</span></code></pre></div></div></li><li><p>Ensure that a suitable mount point exists. This command creates a new directory to use as the mount point:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mkdir /multimedia</span></code></pre></div></div></li><li><p>Determine the device names for the disks which will be added to the array, and create the new RAID3 device. The final device listed will act as the dedicated parity disk. This example uses three unpartitioned ATA drives: <span class=filename>ada1</span> and <span class=filename>ada2</span> for data, and <span class=filename>ada3</span> for parity.</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># graid3 label -v gr0 /dev/ada1 /dev/ada2 /dev/ada3</span>
Metadata value stored on /dev/ada1.
Metadata value stored on /dev/ada2.
Metadata value stored on /dev/ada3.
Done.</code></pre></div></div></li><li><p>Partition the newly created <span class=filename>gr0</span> device and put a UFS file system on it:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gpart create -s GPT /dev/raid3/gr0</span>
<span class=c># gpart add -t freebsd-ufs /dev/raid3/gr0</span>
<span class=c># newfs -j /dev/raid3/gr0p1</span></code></pre></div></div><div class=paragraph><p>Many numbers will glide across the screen, and after a bit of time, the process will be complete. The volume has been created and is ready to be mounted:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount /dev/raid3/gr0p1 /multimedia/</span></code></pre></div></div><div class=paragraph><p>The RAID3 array is now ready to use.</p></div></li></ol></div></div></div><div class=paragraph><p>Additional configuration is needed to retain this setup across system reboots.</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>The <span class=filename>geom_raid3.ko</span> module must be loaded before the array can be mounted. To automatically load the kernel module during system initialization, add the following line to <span class=filename>/boot/loader.conf</span>:</p><div class="literalblock programlisting"><div class=content><pre>geom_raid3_load=&#34;YES&#34;</pre></div></div></li><li><p>The following volume information must be added to <span class=filename>/etc/fstab</span> in order to automatically mount the array’s file system during the system boot process:</p><div class="literalblock programlisting"><div class=content><pre>/dev/raid3/gr0p1	/multimedia	ufs	rw	2	2</pre></div></div></li></ol></div></div></div></div></div></div><div class=sect1><h2 id=geom-graid>18.5. 軟體 RAID 裝置<a class=anchor href=#geom-graid></a></h2><div class=sectionbody><div class=paragraph><p>Some motherboards and expansion cards add some simple hardware, usually just a ROM, that allows the computer to boot from a RAID array. After booting, access to the RAID array is handled by software running on the computer’s main processor. This "hardware-assisted software RAID" gives RAID arrays that are not dependent on any particular operating system, and which are functional even before an operating system is loaded.</p></div><div class=paragraph><p>Several levels of RAID are supported, depending on the hardware in use. See <a href="https://man.freebsd.org/cgi/man.cgi?query=graid&amp;sektion=8&amp;format=html">graid(8)</a> for a complete list.</p></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=graid&amp;sektion=8&amp;format=html">graid(8)</a> requires the <span class=filename>geom_raid.ko</span> kernel module, which is included in the <span class=filename>GENERIC</span> kernel starting with FreeBSD 9.1. If needed, it can be loaded manually with <code>graid load</code>.</p></div><div class=sect2><h3 id=geom-graid-creating>18.5.1. 建立陣列<a class=anchor href=#geom-graid-creating></a></h3><div class=paragraph><p>Software RAID devices often have a menu that can be entered by pressing special keys when the computer is booting. The menu can be used to create and delete RAID arrays. <a href="https://man.freebsd.org/cgi/man.cgi?query=graid&amp;sektion=8&amp;format=html">graid(8)</a> can also create arrays directly from the command line.</p></div><div class=paragraph><p><code>graid label</code> is used to create a new array. The motherboard used for this example has an Intel software RAID chipset, so the Intel metadata format is specified. The new array is given a label of <span class=filename>gm0</span>, it is a mirror (RAID1), and uses drives <span class=filename>ada0</span> and <span class=filename>ada1</span>.</p></div><div class="admonitionblock caution"><table><tbody><tr><td class=icon><i class="fa icon-caution" title=Caution></i></td><td class=content><div class=paragraph><p>Some space on the drives will be overwritten when they are made into a new array. Back up existing data first!</p></div></td></tr></tbody></table></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># graid label Intel gm0 RAID1 ada0 ada1</span>
GEOM_RAID: Intel-a29ea104: Array Intel-a29ea104 created.
GEOM_RAID: Intel-a29ea104: Disk ada0 state changed from NONE to ACTIVE.
GEOM_RAID: Intel-a29ea104: Subdisk gm0:0-ada0 state changed from NONE to ACTIVE.
GEOM_RAID: Intel-a29ea104: Disk ada1 state changed from NONE to ACTIVE.
GEOM_RAID: Intel-a29ea104: Subdisk gm0:1-ada1 state changed from NONE to ACTIVE.
GEOM_RAID: Intel-a29ea104: Array started.
GEOM_RAID: Intel-a29ea104: Volume gm0 state changed from STARTING to OPTIMAL.
Intel-a29ea104 created
GEOM_RAID: Intel-a29ea104: Provider raid/r0 <span class=k>for </span>volume gm0 created.</code></pre></div></div><div class=paragraph><p>A status check shows the new mirror is ready for use:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># graid status</span>
   Name   Status  Components
raid/r0  OPTIMAL  ada0 <span class=o>(</span>ACTIVE <span class=o>(</span>ACTIVE<span class=o>))</span>
                  ada1 <span class=o>(</span>ACTIVE <span class=o>(</span>ACTIVE<span class=o>))</span></code></pre></div></div><div class=paragraph><p>The array device appears in <span class=filename>/dev/raid/</span>. The first array is called <span class=filename>r0</span>. Additional arrays, if present, will be <span class=filename>r1</span>, <span class=filename>r2</span>, and so on.</p></div><div class=paragraph><p>The BIOS menu on some of these devices can create arrays with special characters in their names. To avoid problems with those special characters, arrays are given simple numbered names like <span class=filename>r0</span>. To show the actual labels, like <span class=filename>gm0</span> in the example above, use <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl kern.geom.raid.name_format=1</span></code></pre></div></div></div><div class=sect2><h3 id=geom-graid-volumes>18.5.2. 多磁碟區<a class=anchor href=#geom-graid-volumes></a></h3><div class=paragraph><p>Some software RAID devices support more than one <em>volume</em> on an array. Volumes work like partitions, allowing space on the physical drives to be split and used in different ways. For example, Intel software RAID devices support two volumes. This example creates a 40 G mirror for safely storing the operating system, followed by a 20 G RAID0 (stripe) volume for fast temporary storage:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># graid label -S 40G Intel gm0 RAID1 ada0 ada1</span>
<span class=c># graid add -S 20G gm0 RAID0</span></code></pre></div></div><div class=paragraph><p>Volumes appear as additional <span class=filename>rX</span> entries in <span class=filename>/dev/raid/</span>. An array with two volumes will show <span class=filename>r0</span> and <span class=filename>r1</span>.</p></div><div class=paragraph><p>See <a href="https://man.freebsd.org/cgi/man.cgi?query=graid&amp;sektion=8&amp;format=html">graid(8)</a> for the number of volumes supported by different software RAID devices.</p></div></div><div class=sect2><h3 id=geom-graid-converting>18.5.3. 轉換單一磁碟為鏡像<a class=anchor href=#geom-graid-converting></a></h3><div class=paragraph><p>Under certain specific conditions, it is possible to convert an existing single drive to a <a href="https://man.freebsd.org/cgi/man.cgi?query=graid&amp;sektion=8&amp;format=html">graid(8)</a> array without reformatting. To avoid data loss during the conversion, the existing drive must meet these minimum requirements:</p></div><div class=ulist><ul><li><p>The drive must be partitioned with the MBR partitioning scheme. GPT or other partitioning schemes with metadata at the end of the drive will be overwritten and corrupted by the <a href="https://man.freebsd.org/cgi/man.cgi?query=graid&amp;sektion=8&amp;format=html">graid(8)</a> metadata.</p></li><li><p>There must be enough unpartitioned and unused space at the end of the drive to hold the <a href="https://man.freebsd.org/cgi/man.cgi?query=graid&amp;sektion=8&amp;format=html">graid(8)</a> metadata. This metadata varies in size, but the largest occupies 64 M, so at least that much free space is recommended.</p></li></ul></div><div class=paragraph><p>If the drive meets these requirements, start by making a full backup. Then create a single-drive mirror with that drive:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># graid label Intel gm0 RAID1 ada0 NONE</span></code></pre></div></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=graid&amp;sektion=8&amp;format=html">graid(8)</a> metadata was written to the end of the drive in the unused space. A second drive can now be inserted into the mirror:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># graid insert raid/r0 ada1</span></code></pre></div></div><div class=paragraph><p>Data from the original drive will immediately begin to be copied to the second drive. The mirror will operate in degraded status until the copy is complete.</p></div></div><div class=sect2><h3 id=geom-graid-inserting>18.5.4. 插入新磁碟到陣列<a class=anchor href=#geom-graid-inserting></a></h3><div class=paragraph><p>Drives can be inserted into an array as replacements for drives that have failed or are missing. If there are no failed or missing drives, the new drive becomes a spare. For example, inserting a new drive into a working two-drive mirror results in a two-drive mirror with one spare drive, not a three-drive mirror.</p></div><div class=paragraph><p>In the example mirror array, data immediately begins to be copied to the newly-inserted drive. Any existing information on the new drive will be overwritten.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># graid insert raid/r0 ada1</span>
GEOM_RAID: Intel-a29ea104: Disk ada1 state changed from NONE to ACTIVE.
GEOM_RAID: Intel-a29ea104: Subdisk gm0:1-ada1 state changed from NONE to NEW.
GEOM_RAID: Intel-a29ea104: Subdisk gm0:1-ada1 state changed from NEW to REBUILD.
GEOM_RAID: Intel-a29ea104: Subdisk gm0:1-ada1 rebuild start at 0.</code></pre></div></div></div><div class=sect2><h3 id=geom-graid-removing>18.5.5. 從陣列移除磁碟<a class=anchor href=#geom-graid-removing></a></h3><div class=paragraph><p>Individual drives can be permanently removed from a from an array and their metadata erased:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># graid remove raid/r0 ada1</span>
GEOM_RAID: Intel-a29ea104: Disk ada1 state changed from ACTIVE to OFFLINE.
GEOM_RAID: Intel-a29ea104: Subdisk gm0:1-[unknown] state changed from ACTIVE to NONE.
GEOM_RAID: Intel-a29ea104: Volume gm0 state changed from OPTIMAL to DEGRADED.</code></pre></div></div></div><div class=sect2><h3 id=geom-graid-stopping>18.5.6. 停止陣列<a class=anchor href=#geom-graid-stopping></a></h3><div class=paragraph><p>An array can be stopped without removing metadata from the drives. The array will be restarted when the system is booted.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># graid stop raid/r0</span></code></pre></div></div></div><div class=sect2><h3 id=geom-graid-status>18.5.7. 檢查陣列狀態<a class=anchor href=#geom-graid-status></a></h3><div class=paragraph><p>Array status can be checked at any time. After a drive was added to the mirror in the example above, data is being copied from the original drive to the new drive:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># graid status</span>
   Name    Status  Components
raid/r0  DEGRADED  ada0 <span class=o>(</span>ACTIVE <span class=o>(</span>ACTIVE<span class=o>))</span>
                   ada1 <span class=o>(</span>ACTIVE <span class=o>(</span>REBUILD 28%<span class=o>))</span></code></pre></div></div><div class=paragraph><p>Some types of arrays, like <code>RAID0</code> or <code>CONCAT</code>, may not be shown in the status report if disks have failed. To see these partially-failed arrays, add <code>-ga</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># graid status -ga</span>
          Name  Status  Components
Intel-e2d07d9a  BROKEN  ada6 <span class=o>(</span>ACTIVE <span class=o>(</span>ACTIVE<span class=o>))</span></code></pre></div></div></div><div class=sect2><h3 id=geom-graid-deleting>18.5.8. 刪除陣列<a class=anchor href=#geom-graid-deleting></a></h3><div class=paragraph><p>Arrays are destroyed by deleting all of the volumes from them. When the last volume present is deleted, the array is stopped and metadata is removed from the drives:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># graid delete raid/r0</span></code></pre></div></div></div><div class=sect2><h3 id=geom-graid-unexpected>18.5.9. 刪除預期之外的陣列<a class=anchor href=#geom-graid-unexpected></a></h3><div class=paragraph><p>Drives may unexpectedly contain <a href="https://man.freebsd.org/cgi/man.cgi?query=graid&amp;sektion=8&amp;format=html">graid(8)</a> metadata, either from previous use or manufacturer testing. <a href="https://man.freebsd.org/cgi/man.cgi?query=graid&amp;sektion=8&amp;format=html">graid(8)</a> will detect these drives and create an array, interfering with access to the individual drive. To remove the unwanted metadata:</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Boot the system. At the boot menu, select <code>2</code> for the loader prompt. Enter:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>OK <span class=nb>set </span>kern.geom.raid.enable<span class=o>=</span>0
OK boot</code></pre></div></div><div class=paragraph><p>The system will boot with <a href="https://man.freebsd.org/cgi/man.cgi?query=graid&amp;sektion=8&amp;format=html">graid(8)</a> disabled.</p></div></li><li><p>Back up all data on the affected drive.</p></li><li><p>As a workaround, <a href="https://man.freebsd.org/cgi/man.cgi?query=graid&amp;sektion=8&amp;format=html">graid(8)</a> array detection can be disabled by adding</p><div class="literalblock programlisting"><div class=content><pre>kern.geom.raid.enable=0</pre></div></div><div class=paragraph><p>to <span class=filename>/boot/loader.conf</span>.</p></div><div class=paragraph><p>To permanently remove the <a href="https://man.freebsd.org/cgi/man.cgi?query=graid&amp;sektion=8&amp;format=html">graid(8)</a> metadata from the affected drive, boot a FreeBSD installation CD-ROM or memory stick, and select <code>Shell</code>. Use <code>status</code> to find the name of the array, typically <code>raid/r0</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># graid status</span>
   Name   Status  Components
raid/r0  OPTIMAL  ada0 <span class=o>(</span>ACTIVE <span class=o>(</span>ACTIVE<span class=o>))</span>
                  ada1 <span class=o>(</span>ACTIVE <span class=o>(</span>ACTIVE<span class=o>))</span></code></pre></div></div><div class=paragraph><p>Delete the volume by name:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># graid delete raid/r0</span></code></pre></div></div><div class=paragraph><p>If there is more than one volume shown, repeat the process for each volume. After the last array has been deleted, the volume will be destroyed.</p></div><div class=paragraph><p>Reboot and verify data, restoring from backup if necessary. After the metadata has been removed, the <code>kern.geom.raid.enable=0</code> entry in <span class=filename>/boot/loader.conf</span> can also be removed.</p></div></li></ol></div></div></div></div></div></div><div class=sect1><h2 id=geom-ggate>18.6. GEOM Gate Network<a class=anchor href=#geom-ggate></a></h2><div class=sectionbody><div class=paragraph><p>GEOM provides a simple mechanism for providing remote access to devices such as disks, CDs, and file systems through the use of the GEOM Gate network daemon, ggated. The system with the device runs the server daemon which handles requests made by clients using ggatec. The devices should not contain any sensitive data as the connection between the client and the server is not encrypted.</p></div><div class=paragraph><p>Similar to NFS, which is discussed in <a href=../network-servers/#network-nfs>網路檔案系統 (NFS)</a>, ggated is configured using an exports file. This file specifies which systems are permitted to access the exported resources and what level of access they are offered. For example, to give the client <code>192.168.1.5</code> read and write access to the fourth slice on the first SCSI disk, create <span class=filename>/etc/gg.exports</span> with this line:</p></div><div class="literalblock programlisting"><div class=content><pre>192.168.1.5 RW /dev/da0s4d</pre></div></div><div class=paragraph><p>Before exporting the device, ensure it is not currently mounted. Then, start ggated:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ggated</span></code></pre></div></div><div class=paragraph><p>Several options are available for specifying an alternate listening port or changing the default location of the exports file. Refer to <a href="https://man.freebsd.org/cgi/man.cgi?query=ggated&amp;sektion=8&amp;format=html">ggated(8)</a> for details.</p></div><div class=paragraph><p>To access the exported device on the client machine, first use <code>ggatec</code> to specify the IP address of the server and the device name of the exported device. If successful, this command will display a <code>ggate</code> device name to mount. Mount that specified device name on a free mount point. This example connects to the <span class=filename>/dev/da0s4d</span> partition on <code>192.168.1.1</code>, then mounts <span class=filename>/dev/ggate0</span> on <span class=filename>/mnt</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ggatec create -o rw 192.168.1.1 /dev/da0s4d</span>
ggate0
<span class=c># mount /dev/ggate0 /mnt</span></code></pre></div></div><div class=paragraph><p>The device on the server may now be accessed through <span class=filename>/mnt</span> on the client. For more details about <code>ggatec</code> and a few usage examples, refer to <a href="https://man.freebsd.org/cgi/man.cgi?query=ggatec&amp;sektion=8&amp;format=html">ggatec(8)</a>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>The mount will fail if the device is currently mounted on either the server or any other client on the network. If simultaneous access is needed to network resources, use NFS instead.</p></div></td></tr></tbody></table></div><div class=paragraph><p>When the device is no longer needed, unmount it with <code>umount</code> so that the resource is available to other clients.</p></div></div></div><div class=sect1><h2 id=geom-glabel>18.7. 磁碟裝置標籤<a class=anchor href=#geom-glabel></a></h2><div class=sectionbody><div class=paragraph><p>During system initialization, the FreeBSD kernel creates device nodes as devices are found. This method of probing for devices raises some issues. For instance, what if a new disk device is added via USB? It is likely that a flash device may be handed the device name of <span class=filename>da0</span> and the original <span class=filename>da0</span> shifted to <span class=filename>da1</span>. This will cause issues mounting file systems if they are listed in <span class=filename>/etc/fstab</span> which may also prevent the system from booting.</p></div><div class=paragraph><p>One solution is to chain SCSI devices in order so a new device added to the SCSI card will be issued unused device numbers. But what about USB devices which may replace the primary SCSI disk? This happens because USB devices are usually probed before the SCSI card. One solution is to only insert these devices after the system has been booted. Another method is to use only a single ATA drive and never list the SCSI devices in <span class=filename>/etc/fstab</span>.</p></div><div class=paragraph><p>A better solution is to use <code>glabel</code> to label the disk devices and use the labels in <span class=filename>/etc/fstab</span>. Because <code>glabel</code> stores the label in the last sector of a given provider, the label will remain persistent across reboots. By using this label as a device, the file system may always be mounted regardless of what device node it is accessed through.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p><code>glabel</code> can create both transient and permanent labels. Only permanent labels are consistent across reboots. Refer to <a href="https://man.freebsd.org/cgi/man.cgi?query=glabel&amp;sektion=8&amp;format=html">glabel(8)</a> for more information on the differences between labels.</p></div></td></tr></tbody></table></div><div class=sect2><h3 id=_標籤類型與範例>18.7.1. 標籤類型與範例<a class=anchor href=#_標籤類型與範例></a></h3><div class=paragraph><p>Permanent labels can be a generic or a file system label. Permanent file system labels can be created with <a href="https://man.freebsd.org/cgi/man.cgi?query=tunefs&amp;sektion=8&amp;format=html">tunefs(8)</a> or <a href="https://man.freebsd.org/cgi/man.cgi?query=newfs&amp;sektion=8&amp;format=html">newfs(8)</a>. These types of labels are created in a sub-directory of <span class=filename>/dev</span>, and will be named according to the file system type. For example, UFS2 file system labels will be created in <span class=filename>/dev/ufs</span>. Generic permanent labels can be created with <code>glabel label</code>. These are not file system specific and will be created in <span class=filename>/dev/label</span>.</p></div><div class=paragraph><p>Temporary labels are destroyed at the next reboot. These labels are created in <span class=filename>/dev/label</span> and are suited to experimentation. A temporary label can be created using <code>glabel create</code>.</p></div><div class=paragraph><p>To create a permanent label for a UFS2 file system without destroying any data, issue the following command:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># tunefs -L home /dev/da3</span></code></pre></div></div><div class=paragraph><p>A label should now exist in <span class=filename>/dev/ufs</span> which may be added to <span class=filename>/etc/fstab</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>/dev/ufs/home		/home            ufs     rw              2      2</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>The file system must not be mounted while attempting to run <code>tunefs</code>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Now the file system may be mounted:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount /home</span></code></pre></div></div><div class=paragraph><p>From this point on, so long as the <span class=filename>geom_label.ko</span> kernel module is loaded at boot with <span class=filename>/boot/loader.conf</span> or the <code>GEOM_LABEL</code> kernel option is present, the device node may change without any ill effect on the system.</p></div><div class=paragraph><p>File systems may also be created with a default label by using the <code>-L</code> flag with <code>newfs</code>. Refer to <a href="https://man.freebsd.org/cgi/man.cgi?query=newfs&amp;sektion=8&amp;format=html">newfs(8)</a> for more information.</p></div><div class=paragraph><p>The following command can be used to destroy the label:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># glabel destroy home</span></code></pre></div></div><div class=paragraph><p>The following example shows how to label the partitions of a boot disk.</p></div><div class=exampleblock><div class=title>例 1. 在開機磁碟標記分割區標籤</div><div class=content><div class=paragraph><p>By permanently labeling the partitions on the boot disk, the system should be able to continue to boot normally, even if the disk is moved to another controller or transferred to a different system. For this example, it is assumed that a single ATA disk is used, which is currently recognized by the system as <span class=filename>ad0</span>. It is also assumed that the standard FreeBSD partition scheme is used, with <span class=filename>/</span>, <span class=filename>/var</span>, <span class=filename>/usr</span> and <span class=filename>/tmp</span>, as well as a swap partition.</p></div><div class=paragraph><p>Reboot the system, and at the <a href="https://man.freebsd.org/cgi/man.cgi?query=loader&amp;sektion=8&amp;format=html">loader(8)</a> prompt, press <kbd>4</kbd> to boot into single user mode. Then enter the following commands:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># glabel label rootfs /dev/ad0s1a</span>
GEOM_LABEL: Label <span class=k>for </span>provider /dev/ad0s1a is label/rootfs
<span class=c># glabel label var /dev/ad0s1d</span>
GEOM_LABEL: Label <span class=k>for </span>provider /dev/ad0s1d is label/var
<span class=c># glabel label usr /dev/ad0s1f</span>
GEOM_LABEL: Label <span class=k>for </span>provider /dev/ad0s1f is label/usr
<span class=c># glabel label tmp /dev/ad0s1e</span>
GEOM_LABEL: Label <span class=k>for </span>provider /dev/ad0s1e is label/tmp
<span class=c># glabel label swap /dev/ad0s1b</span>
GEOM_LABEL: Label <span class=k>for </span>provider /dev/ad0s1b is label/swap
<span class=c># exit</span></code></pre></div></div><div class=paragraph><p>The system will continue with multi-user boot. After the boot completes, edit <span class=filename>/etc/fstab</span> and replace the conventional device names, with their respective labels. The final <span class=filename>/etc/fstab</span> will look like this:</p></div><div class="literalblock programlisting"><div class=content><pre># Device                Mountpoint      FStype  Options         Dump    Pass#
/dev/label/swap         none            swap    sw              0       0
/dev/label/rootfs       /               ufs     rw              1       1
/dev/label/tmp          /tmp            ufs     rw              2       2
/dev/label/usr          /usr            ufs     rw              2       2
/dev/label/var          /var            ufs     rw              2       2</pre></div></div><div class=paragraph><p>The system can now be rebooted. If everything went well, it will come up normally and <code>mount</code> will show:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount</span>
/dev/label/rootfs on / <span class=o>(</span>ufs, <span class=nb>local</span><span class=o>)</span>
devfs on /dev <span class=o>(</span>devfs, <span class=nb>local</span><span class=o>)</span>
/dev/label/tmp on /tmp <span class=o>(</span>ufs, <span class=nb>local</span>, soft-updates<span class=o>)</span>
/dev/label/usr on /usr <span class=o>(</span>ufs, <span class=nb>local</span>, soft-updates<span class=o>)</span>
/dev/label/var on /var <span class=o>(</span>ufs, <span class=nb>local</span>, soft-updates<span class=o>)</span></code></pre></div></div></div></div><div class=paragraph><p>The <a href="https://man.freebsd.org/cgi/man.cgi?query=glabel&amp;sektion=8&amp;format=html">glabel(8)</a> class supports a label type for UFS file systems, based on the unique file system id, <code>ufsid</code>. These labels may be found in <span class=filename>/dev/ufsid</span> and are created automatically during system startup. It is possible to use <code>ufsid</code> labels to mount partitions using <span class=filename>/etc/fstab</span>. Use <code>glabel status</code> to receive a list of file systems and their corresponding <code>ufsid</code> labels:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% glabel status
                  Name  Status  Components
ufsid/486b6fc38d330916     N/A  ad4s1d
ufsid/486b6fc16926168e     N/A  ad4s1f</code></pre></div></div><div class=paragraph><p>In the above example, <span class=filename>ad4s1d</span> represents <span class=filename>/var</span>, while <span class=filename>ad4s1f</span> represents <span class=filename>/usr</span>. Using the <code>ufsid</code> values shown, these partitions may now be mounted with the following entries in <span class=filename>/etc/fstab</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>/dev/ufsid/486b6fc38d330916        /var        ufs        rw        2      2
/dev/ufsid/486b6fc16926168e        /usr        ufs        rw        2      2</pre></div></div><div class=paragraph><p>Any partitions with <code>ufsid</code> labels can be mounted in this way, eliminating the need to manually create permanent labels, while still enjoying the benefits of device name independent mounting.</p></div></div></div></div><div class=sect1><h2 id=geom-gjournal>18.8. UFS Journaling 透過 GEOM<a class=anchor href=#geom-gjournal></a></h2><div class=sectionbody><div class=paragraph><p>Support for journals on UFS file systems is available on FreeBSD. The implementation is provided through the GEOM subsystem and is configured using <code>gjournal</code>. Unlike other file system journaling implementations, the <code>gjournal</code> method is block based and not implemented as part of the file system. It is a GEOM extension.</p></div><div class=paragraph><p>Journaling stores a log of file system transactions, such as changes that make up a complete disk write operation, before meta-data and file writes are committed to the disk. This transaction log can later be replayed to redo file system transactions, preventing file system inconsistencies.</p></div><div class=paragraph><p>This method provides another mechanism to protect against data loss and inconsistencies of the file system. Unlike Soft Updates, which tracks and enforces meta-data updates, and snapshots, which create an image of the file system, a log is stored in disk space specifically for this task. For better performance, the journal may be stored on another disk. In this configuration, the journal provider or storage device should be listed after the device to enable journaling on.</p></div><div class=paragraph><p>The <span class=filename>GENERIC</span> kernel provides support for <code>gjournal</code>. To automatically load the <span class=filename>geom_journal.ko</span> kernel module at boot time, add the following line to <span class=filename>/boot/loader.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>geom_journal_load=&#34;YES&#34;</pre></div></div><div class=paragraph><p>If a custom kernel is used, ensure the following line is in the kernel configuration file:</p></div><div class="literalblock programlisting"><div class=content><pre>options	GEOM_JOURNAL</pre></div></div><div class=paragraph><p>Once the module is loaded, a journal can be created on a new file system using the following steps. In this example, <span class=filename>da4</span> is a new SCSI disk:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gjournal load</span>
<span class=c># gjournal label /dev/da4</span></code></pre></div></div><div class=paragraph><p>This will load the module and create a <span class=filename>/dev/da4.journal</span> device node on <span class=filename>/dev/da4</span>.</p></div><div class=paragraph><p>A UFS file system may now be created on the journaled device, then mounted on an existing mount point:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># newfs -O 2 -J /dev/da4.journal</span>
<span class=c># mount /dev/da4.journal /mnt</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>In the case of several slices, a journal will be created for each individual slice. For instance, if <span class=filename>ad4s1</span> and <span class=filename>ad4s2</span> are both slices, then <code>gjournal</code> will create <span class=filename>ad4s1.journal</span> and <span class=filename>ad4s2.journal</span>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Journaling may also be enabled on current file systems by using <code>tunefs</code>. However, <em>always</em> make a backup before attempting to alter an existing file system. In most cases, <code>gjournal</code> will fail if it is unable to create the journal, but this does not protect against data loss incurred as a result of misusing <code>tunefs</code>. Refer to <a href="https://man.freebsd.org/cgi/man.cgi?query=gjournal&amp;sektion=8&amp;format=html">gjournal(8)</a> and <a href="https://man.freebsd.org/cgi/man.cgi?query=tunefs&amp;sektion=8&amp;format=html">tunefs(8)</a> for more information about these commands.</p></div><div class=paragraph><p>It is possible to journal the boot disk of a FreeBSD system. Refer to the article <a href=https://docs.freebsd.org/en/articles/gjournal-desktop/>Implementing UFS Journaling on a Desktop PC</a> for detailed instructions.</p></div></div></div></div><hr><div class=last-modified><p><strong>最後修改於</strong>: March 9, 2024 由 <a href="https://cgit.freebsd.org/doc/commit/?id=6199af92e7" target=_blank>Danilo G. Baio</a></p></div><div class=buttons><div class=prev><i class="fa fa-angle-left" aria-hidden=true title=Prev></i><div class=container><a href=http://172.16.201.134:1313/zh-tw/books/handbook/disks class=direction>Prev</a></div></div><div class=home><i class="fa fa-home" aria-hidden=true title=Home></i><div class=container><a href=../ class=direction>Home</a></div></div><div class=next><div class=container><a href=http://172.16.201.134:1313/zh-tw/books/handbook/zfs class=direction>Next</a></div><i class="fa fa-angle-right" aria-hidden=true title=Next></i></div></div><label class="hidden book-menu-overlay" for=menu-control></label></div><aside class=toc><div class=toc-content><h3>目錄</h3><nav id=TableOfContents><ul><li><a href=#geom-synopsis>18.1. 概述</a></li><li><a href=#geom-striping>18.2. RAID0 - 串連 (Striping)</a></li><li><a href=#geom-mirror>18.3. RAID1 - 鏡像 (Mirroring)</a></li><li><a href=#geom-raid3>18.4. RAID3 - 位元級串連與獨立奇偶校驗</a></li><li><a href=#geom-graid>18.5. 軟體 RAID 裝置</a></li><li><a href=#geom-ggate>18.6. GEOM Gate Network</a></li><li><a href=#geom-glabel>18.7. 磁碟裝置標籤</a></li><li><a href=#geom-gjournal>18.8. UFS Journaling 透過 GEOM</a></li></ul></nav><hr><div class=resources><h3>資源</h3><ul class=contents><li><i class="fa fa-file-pdf-o" aria-hidden=true title="下載 PDF"></i><a href=https://download.freebsd.org/doc/zh-tw/books/handbook/handbook_zh-tw.pdf>下載 PDF</a></li><li><i class="fa fa-pencil-square-o" aria-hidden=true title=編輯此頁></i><a href=https://github.com/freebsd/freebsd-doc/blob/main/documentation/content/zh-tw/_index target=_blank>編輯此頁</a></li></ul></div></div></aside><a class=to-top href=#top><i class="fa fa-arrow-circle-up" aria-hidden=true></i></a></main><footer><div class=footer-container><section class=logo-column><img src=http://172.16.201.134:1313/images/FreeBSD-colors.svg width=160 height=50 alt="FreeBSD logo"><div class=options-container><div class=language-container><a id=languages href=http://172.16.201.134:1313/zh-tw/languages><img src=http://172.16.201.134:1313/images/language.png class=language-image alt=選擇語言>
<span>繁體中文</span></a></div><div class=theme-container><select id=theme-chooser><option value=theme-system>System</option><option value=theme-light>淺色</option><option value=theme-dark>深色</option><option value=theme-high-contrast>高對比</option></select></div></div></section><section class=about-column><h3 class=column-title>About</h3><ul class=column-elements-container><li><a href=https://www.freebsd.org/about/ target=_blank class=column-element>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/ target=_blank class=column-element>FreeBSD Foundation</a></li><li><a href=https://www.freebsd.org/where/ target=_blank class=column-element>Get FreeBSD</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct target=_blank class=column-element>Code of Conduct</a></li><li><a href=https://www.freebsd.org/security/ target=_blank class=column-element>Security Advisories</a></li></ul></section><section class=documentation-column><h3 class=column-title>Documentation</h3><ul class=column-elements-container><li><a href=/zh-tw class=column-element>Documentation portal</a></li><li><a href=https://man.FreeBSD.org target=_blank class=column-element>Manual pages</a></li><li><a href=https://papers.FreeBSD.org target=_blank class=column-element>Presentations and papers</a></li><li><a href=https://docs-archive.freebsd.org/doc/ target=_blank class=column-element>Previous versions</a></li><li><a href=https://docs-archive.freebsd.org/44doc/ target=_blank class=column-element>4.4BSD Documents</a></li><li><a href=https://wiki.freebsd.org/ target=_blank class=column-element>Wiki</a></li></ul></section><section class=community-column><h3 class=column-title>Community</h3><ul class=column-elements-container><li><a href=http://172.16.201.134:1313/zh-tw/articles/contributing class=column-element>Get involved</a></li><li><a href=https://forums.freebsd.org/ target=_blank class=column-element>Community forum</a></li><li><a href=https://lists.freebsd.org/ target=_blank class=column-element>Mailing lists</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank class=column-element>IRC Channels</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank class=column-element>Bug Tracker</a></li></ul></section><section class=legal-column><h3 class=column-title>Legal</h3><ul class=column-elements-container><li><a href=https://freebsdfoundation.org/donate/ target=_blank class=column-element>Donations</a></li><li><a href=https://www.freebsd.org/copyright/freebsd-license/ target=_blank class=column-element>Licensing</a></li><li><a href=https://www.freebsd.org/privacy/ target=_blank class=column-element>Privacy Policy</a></li><li><a href=https://www.freebsd.org/copyright/ target=_blank class=column-element>Legal notices</a></li></ul></section><section class=copyright-column><p>&copy; 1994-2024 The FreeBSD Project. All rights reserved</p><span>Made with <span class=heart>♥</span> by the FreeBSD Community</span></section></div></footer></body></html>