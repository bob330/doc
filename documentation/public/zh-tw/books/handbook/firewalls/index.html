<!doctype html><html class=theme-light lang=zh-tw><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content><meta name=keywords content><meta name=copyright content="1995-2024 The FreeBSD Foundation"><link rel=canonical href=http://172.16.201.134:1313/zh-tw/books/handbook/firewalls/><title>章 30. 防火牆 | FreeBSD Documentation Portal</title>
<meta name=theme-color content="#790000"><meta name=color-scheme content="system light dark high-contrast"><link rel="shortcut icon" href=http://172.16.201.134:1313/favicon.ico><link rel=stylesheet href=http://172.16.201.134:1313/styles/main.min.css><link rel=stylesheet href=http://172.16.201.134:1313/css/font-awesome-min.css><script defer src=/js/theme-chooser.min.js></script><script defer src=/js/copy-clipboard.min.js></script><script defer src=/js/search.min.js></script><meta name=twitter:card content="summary"><meta name=twitter:domain content="docs.FreeBSD.org"><meta name=twitter:site content="@freebsd"><meta name=twitter:url content="https://twitter.com/freebsd"><meta property="og:title" content="章 30. 防火牆"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:image" content="http://172.16.201.134:1313/favicon.ico"><meta property="og:image:alt" content="FreeBSD Logo"><meta property="og:locale" content="zh-tw"><meta property="og:url" content="http://172.16.201.134:1313/zh-tw/books/handbook/firewalls/"><meta property="og:site_name" content="FreeBSD Documentation Portal"><script type=application/ld+json>{"@context":"http://schema.org","@type":"Article","url":"http:\/\/172.16.201.134:1313\/zh-tw\/books\/handbook\/firewalls\/","name":"FreeBSD Documentation Portal","headline":"FreeBSD Documentation Portal","description":"FreeBSD Documentation Portal"}</script></head><body><header><div class=header-container><div class=logo-menu-bars-container><a href=https://www.FreeBSD.org class=logo><img src=http://172.16.201.134:1313/images/FreeBSD-monochromatic.svg width=160 height=50 alt="FreeBSD logo">
</a><label class=menu-bars for=menu-bars><i class="fa fa-bars" aria-hidden=true></i></label></div><input id=menu-bars type=checkbox><nav><ul class=menu><li class=menu-item><input id=about type=checkbox>
<a href=# aria-label="Navigate to About section"><label class=menu-item-description for=about>About
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/about/ target=_blank>About</a></li><li><a href=https://www.freebsd.org/about/ target=_blank>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/about-us/about-the-foundation/ target=_blank>FreeBSD Foundation</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct/ target=_blank>Code of Conduct</a></li></ul></li><li class=menu-item><input id=download type=checkbox>
<a href=# aria-label="Navigate to get FreeBSD section"><label class=menu-item-description for=download>Get FreeBSD
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/where/ target=_blank>Get FreeBSD</a></li><li><a href=https://www.freebsd.org/releases/ target=_blank>Release Information</a></li><li><a href=https://www.freebsd.org/releng/ target=_blank>Release Engineering</a></li><li><a href=https://www.freebsd.org/security/ target=_blank>Security Advisories</a></li></ul></li><li class=menu-item><input id=documentation type=checkbox>
<a href=# aria-label="Navigate to get Documentation section"><label class=menu-item-description for=documentation>Documentation
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=/zh-tw>Documentation portal</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook>FreeBSD Handbook</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/porters-handbook>Porter's Handbook</a></li><li><a href=https://docs.FreeBSD.org/en/books/fdp-primer>Documentation Project Handbook</a></li><li><a href=https://man.FreeBSD.org target=_blank>Manual pages</a></li><li><a href=https://papers.FreeBSD.org target=_blank>Presentations and papers</a></li><li><a href=https://wiki.FreeBSD.org target=_blank>Wiki</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books>Books</a></li><li><a href=http://172.16.201.134:1313/zh-tw/articles>Articles</a></li></ul></li><li class=menu-item><input id=community type=checkbox>
<a href=# aria-label="Navigate to get Community section"><label class=menu-item-description for=community>Community
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/community/>Community</a></li><li><a href=http://172.16.201.134:1313/zh-tw/articles/contributing>Get involved</a></li><li><a href=https://forums.freebsd.org/ target=_blank>Forum</a></li><li><a href=https://lists.freebsd.org/ target=_blank>Mailing lists</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank>IRC Channels</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank>Bug Tracker</a></li><li><a href=https://www.freebsd.org/support/ target=_blank>Support</a></li></ul></li></ul></nav><div class=search-donate-container><form class=search method=get id=search-header-form action=https://docs.freebsd.org/search name=search-header-form><input type=hidden name=DB value=zh-tw>
<input id=words name=P type=text size=20 maxlength=255>
<button>
<i class="fa fa-search" aria-hidden=true></i></button></form><div class=donate><a href=https://freebsdfoundation.org/donate/ target=_blank><span class=heart>♥</span>
Donate</a></div></div></div></header><input type=checkbox class="hidden toggle" id=menu-control><main class=main-wrapper-book><a id=top></a><aside class=book-menu><div class=book-menu-content><input id=search-book type=text placeholder=Search aria-label=Search maxlength=128><nav id=MenuContents><ul><li><input type=checkbox id=chapter-eb2a98ce203d8afd517726e6d8776be3 class=toggle>
<label class="icon cursor" for=chapter-eb2a98ce203d8afd517726e6d8776be3><a role=button></a></label><a href=http://172.16.201.134:1313/zh-tw/books/handbook/preface/>序</a><ul><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/preface/#preface-audience>給讀者的話</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/preface/#preface-changes-from3>自第三版後的主要修訂</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/preface/#preface-changes-from2>自第二版後的主要修訂 (2004)</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/preface/#preface-changes>自第一版後的主要修訂 (2001)</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/preface/#preface-overview>本書架構</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/preface/#preface-conv>本書的編排體裁</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/preface/#preface-acknowledgements>銘謝</a></li></ul></li><li><input type=checkbox id=chapter-14a525fce014b90b8a458a894818255a class=toggle>
<label for=chapter-14a525fce014b90b8a458a894818255a><a role=button></a></label><a href=http://172.16.201.134:1313/zh-tw/books/handbook/parti/>部 I. 入門</a></li><li><input type=checkbox id=chapter-f9c9f3451644df30d224350da97d5da6 class=toggle>
<label class="icon cursor" for=chapter-f9c9f3451644df30d224350da97d5da6><a role=button></a></label><a href=http://172.16.201.134:1313/zh-tw/books/handbook/introduction/>章 1. 簡介</a><ul><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/introduction/#introduction-synopsis>1.1. 概述</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/introduction/#nutshell>1.2. 歡迎使用 FreeBSD！</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/introduction/#history>1.3. 關於 FreeBSD 計劃</a></li></ul></li><li><input type=checkbox id=chapter-f693a3fa687a72d63ec8129ee302d664 class=toggle>
<label class="icon cursor" for=chapter-f693a3fa687a72d63ec8129ee302d664><a role=button></a></label><a href=http://172.16.201.134:1313/zh-tw/books/handbook/bsdinstall/>章 2. 安裝 FreeBSD</a><ul><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/bsdinstall/#bsdinstall-synopsis>2.1. 概述</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/bsdinstall/#bsdinstall-hardware>2.2. 最低硬體需求</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/bsdinstall/#bsdinstall-pre>2.3. 安裝前準備工作</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/bsdinstall/#bsdinstall-start>2.4. 開始安裝</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/bsdinstall/#using-bsdinstall>2.5. 使用 bsdinstall</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/bsdinstall/#bsdinstall-partitioning>2.6. 配置磁碟空間</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/bsdinstall/#bsdinstall-final-warning>2.7. 確認安裝</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/bsdinstall/#bsdinstall-post>2.8. 安裝後注意事項</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/bsdinstall/#bsdinstall-install-trouble>2.9. 疑難排解</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/bsdinstall/#using-live-cd>2.10. 使用 Live CD</a></li></ul></li><li><input type=checkbox id=chapter-9f6db261075f578742036fcc6000eecd class=toggle>
<label class="icon cursor" for=chapter-9f6db261075f578742036fcc6000eecd><a role=button></a></label><a href=http://172.16.201.134:1313/zh-tw/books/handbook/basics/>章 3. FreeBSD 基礎</a><ul><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/basics/#basics-synopsis>3.1. 概述</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/basics/#consoles>3.2. 虛擬 Console 與終端機</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/basics/#users-synopsis>3.3. 使用者與基礎帳號管理</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/basics/#permissions>3.4. 權限</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/basics/#dirstructure>3.5. 目錄結構</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/basics/#disk-organization>3.6. 磁碟組織</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/basics/#mount-unmount>3.7. 掛載與卸載檔案系統</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/basics/#basics-processes>3.8. 程序與 Daemon</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/basics/#shells>3.9. Shell</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/basics/#editors>3.10. 文字編輯器</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/basics/#basics-devices>3.11. 裝置及裝置節點</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/basics/#basics-more-information>3.12. 操作手冊</a></li></ul></li><li><input type=checkbox id=chapter-01c5707e95d14c0ff84bf62600c958d1 class=toggle>
<label class="icon cursor" for=chapter-01c5707e95d14c0ff84bf62600c958d1><a role=button></a></label><a href=http://172.16.201.134:1313/zh-tw/books/handbook/ports/>章 4. 安裝應用程式：套件與 Port</a><ul><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/ports/#ports-synopsis>4.1. 概述</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/ports/#ports-overview>4.2. 安裝軟體的概要</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/ports/#ports-finding-applications>4.3. 搜尋軟體</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/ports/#pkgng-intro>4.4. 使用 pkg 管理 Binary 套件</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/ports/#ports-using>4.5. 使用 Port 套件集</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/ports/#ports-poudriere>4.6. 使用 Poudriere 編譯套件</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/ports/#ports-nextsteps>4.7. 安裝後的注意事項</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/ports/#ports-broken>4.8. 處理損壞的 Port</a></li></ul></li><li><input type=checkbox id=chapter-3405c00581365a8b5d16af70fe4d1b72 class=toggle>
<label class="icon cursor" for=chapter-3405c00581365a8b5d16af70fe4d1b72><a role=button></a></label><a href=http://172.16.201.134:1313/zh-tw/books/handbook/x11/>章 5. X Window 系統</a><ul><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/x11/#x11-synopsis>5.1. 概述</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/x11/#x-understanding>5.2. 術語</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/x11/#x-install>5.3. 安裝 Xorg</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/x11/#x-config>5.4. Xorg 設定</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/x11/#x-fonts>5.5. 在 Xorg 使用字型</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/x11/#x-xdm>5.6. X 顯示管理程式</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/x11/#x11-wm>5.7. 桌面環境</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/x11/#x-compiz-fusion>5.8. 安裝 Compiz Fusion</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/x11/#x11-understanding>5.9. 疑難排解</a></li></ul></li><li><input type=checkbox id=chapter-0eab3565e8f59f5a8a896dfba7eb3680 class=toggle>
<label for=chapter-0eab3565e8f59f5a8a896dfba7eb3680><a role=button></a></label><a href=http://172.16.201.134:1313/zh-tw/books/handbook/partii/>部 II. 一般作業</a></li><li><input type=checkbox id=chapter-b33cf28993f3f7bf5baf036e79da0f39 class=toggle>
<label class="icon cursor" for=chapter-b33cf28993f3f7bf5baf036e79da0f39><a role=button></a></label><a href=http://172.16.201.134:1313/zh-tw/books/handbook/desktop/>章 6. 桌面應用程式</a><ul><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/desktop/#desktop-synopsis>6.1. 概述</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/desktop/#desktop-browsers>6.2. 瀏覽器</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/desktop/#desktop-productivity>6.3. 辦工工具</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/desktop/#desktop-viewers>6.4. 文件閱覽程式</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/desktop/#desktop-finance>6.5. 財務</a></li></ul></li><li><input type=checkbox id=chapter-152f694a19312ad72ec7bb4e1c3c33b2 class=toggle>
<label class="icon cursor" for=chapter-152f694a19312ad72ec7bb4e1c3c33b2><a role=button></a></label><a href=http://172.16.201.134:1313/zh-tw/books/handbook/multimedia/>章 7. 多媒體</a><ul><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/multimedia/#multimedia-synopsis>7.1. 概述</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/multimedia/#sound-setup>7.2. 設定音效卡</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/multimedia/#sound-mp3>7.3. MP3 音樂</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/multimedia/#video-playback>7.4. 影片播放</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/multimedia/#tvcard>7.5. 電視卡</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/multimedia/#mythtv>7.6. MythTV</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/multimedia/#scanners>7.7. 影像掃描器</a></li></ul></li><li><input type=checkbox id=chapter-80888b4ee02e3e409e5f71cf97a36450 class=toggle>
<label class="icon cursor" for=chapter-80888b4ee02e3e409e5f71cf97a36450><a role=button></a></label><a href=http://172.16.201.134:1313/zh-tw/books/handbook/kernelconfig/>章 8. 設定 FreeBSD 核心</a><ul><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/kernelconfig/#kernelconfig-synopsis>8.1. 概述</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/kernelconfig/#kernelconfig-custom-kernel>8.2. 為何要編譯自訂的核心?</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/kernelconfig/#kernelconfig-devices>8.3. 偵測系統硬體</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/kernelconfig/#kernelconfig-config>8.4. 設定檔</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/kernelconfig/#kernelconfig-building>8.5. 編譯與安裝自訂核心</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/kernelconfig/#kernelconfig-trouble>8.6. 如果發生錯誤</a></li></ul></li><li><input type=checkbox id=chapter-cb174c55879b17ab955f2f16989a79e0 class=toggle>
<label class="icon cursor" for=chapter-cb174c55879b17ab955f2f16989a79e0><a role=button></a></label><a href=http://172.16.201.134:1313/zh-tw/books/handbook/printing/>章 9. 列印</a><ul><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/printing/#printing-quick-start>9.1. 快速開始</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/printing/#printing-connections>9.2. 印表機連線</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/printing/#printing-pdls>9.3. 常見的頁面描述語言</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/printing/#printing-direct>9.4. 直接列印</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/printing/#printing-lpd>9.5. LPD (行列式印表機 Daemon)</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/printing/#printing-other>9.6. 其他列印系統</a></li></ul></li><li><input type=checkbox id=chapter-c12b8c3f2a8fcefce87087241f695c83 class=toggle>
<label class="icon cursor" for=chapter-c12b8c3f2a8fcefce87087241f695c83><a role=button></a></label><a href=http://172.16.201.134:1313/zh-tw/books/handbook/linuxemu/>章 10. Linux® Binary 相容性</a><ul><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/linuxemu/#linuxemu-synopsis>10.1. 概述</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/linuxemu/#linuxemu-lbc-install>10.2. 設定 Linux™ Binary 相容性</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/linuxemu/#linuxemu-advanced>10.3. 進階主題</a></li></ul></li><li><input type=checkbox id=chapter-03b11ba627b9a0c85b247f5641bde272 class=toggle>
<label for=chapter-03b11ba627b9a0c85b247f5641bde272><a role=button></a></label><a href=http://172.16.201.134:1313/zh-tw/books/handbook/partiii/>部 III. 系統管理</a></li><li><input type=checkbox id=chapter-6c31587f8d736319f099cd4dc1961301 class=toggle>
<label class="icon cursor" for=chapter-6c31587f8d736319f099cd4dc1961301><a role=button></a></label><a href=http://172.16.201.134:1313/zh-tw/books/handbook/config/>章 11. 設定與調校</a><ul><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/config/#config-synopsis>11.1. 概述</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/config/#configtuning-starting-services>11.2. 啟動服務</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/config/#configtuning-cron>11.3. 設定 cron(8)</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/config/#configtuning-rcd>11.4. 管理 FreeBSD 中的服務</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/config/#config-network-setup>11.5. 設定網路介面卡</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/config/#configtuning-virtual-hosts>11.6. 虛擬主機</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/config/#configtuning-syslog>11.7. 設定系統日誌</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/config/#configtuning-configfiles>11.8. 設定檔</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/config/#configtuning-sysctl>11.9. 使用 sysctl(8) 調校</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/config/#configtuning-disk>11.10. 調校磁碟</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/config/#configtuning-kernel-limits>11.11. 調校核心限制</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/config/#adding-swap-space>11.12. 增加交換空間</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/config/#acpi-overview>11.13. 電源與資源管理</a></li></ul></li><li><input type=checkbox id=chapter-459f0012b3b4f0b6b123010f029da5e4 class=toggle>
<label class="icon cursor" for=chapter-459f0012b3b4f0b6b123010f029da5e4><a role=button></a></label><a href=http://172.16.201.134:1313/zh-tw/books/handbook/boot/>章 12. FreeBSD 開機程序</a><ul><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/boot/#boot-synopsis>12.1. 概述</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/boot/#boot-introduction>12.2. FreeBSD 開機程序</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/boot/#boot-splash>12.3. 設定開機啟動畫面</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/boot/#device-hints>12.4. 裝置提示</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/boot/#boot-shutdown>12.5. 關機程序</a></li></ul></li><li><input type=checkbox id=chapter-917c75fcffbb14d48ed6d0a48e7028f2 class=toggle>
<label class="icon cursor" for=chapter-917c75fcffbb14d48ed6d0a48e7028f2><a role=button></a></label><a href=http://172.16.201.134:1313/zh-tw/books/handbook/security/>章 13. 安全性</a><ul><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/security/#security-synopsis>13.1. 概述</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/security/#security-intro>13.2. 簡介</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/security/#one-time-passwords>13.3. 一次性密碼</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/security/#tcpwrappers>13.4. TCP Wrapper</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/security/#kerberos5>13.5. Kerberos</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/security/#openssl>13.6. OpenSSL</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/security/#ipsec>13.7. VPN over IPsec</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/security/#openssh>13.8. OpenSSH</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/security/#fs-acl>13.9. 存取控制清單</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/security/#security-pkg>13.10. 監視第三方安全性問題</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/security/#security-advisories>13.11. FreeBSD 安全報告</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/security/#security-accounting>13.12. 程序追蹤</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/security/#security-resourcelimits>13.13. 限制資源</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/security/#security-sudo>13.14. 使用 Sudo 分享管理權限</a></li></ul></li><li><input type=checkbox id=chapter-1a2a8e719703649c2c66d99aa7a25fd4 class=toggle>
<label class="icon cursor" for=chapter-1a2a8e719703649c2c66d99aa7a25fd4><a role=button></a></label><a href=http://172.16.201.134:1313/zh-tw/books/handbook/jails/>章 14. Jail</a><ul><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/jails/#jails-synopsis>14.1. 概述</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/jails/#jails-terms>14.2. Jail 相關術語</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/jails/#jails-build>14.3. 建立和控制 Jail</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/jails/#jails-tuning>14.4. 調校與管理</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/jails/#jails-application>14.5. 更新多個 Jail</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/jails/#jails-ezjail>14.6. 使用 ezjail 管理 Jail</a></li></ul></li><li><input type=checkbox id=chapter-8f4620c77e572cbb58917911a33c73cf class=toggle>
<label class="icon cursor" for=chapter-8f4620c77e572cbb58917911a33c73cf><a role=button></a></label><a href=http://172.16.201.134:1313/zh-tw/books/handbook/mac/>章 15. 強制存取控制 (MAC)</a><ul><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/mac/#mac-synopsis>15.1. 概述</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/mac/#mac-inline-glossary>15.2. 關鍵詞</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/mac/#mac-understandlabel>15.3. 了解 MAC 標籤</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/mac/#mac-planning>15.4. 規劃安全架構</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/mac/#mac-policies>15.5. 可用的 MAC 管理政策</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/mac/#mac-userlocked>15.6. User Lock Down</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/mac/#mac-implementing>15.7. 在 MAC Jail 中使用 Nagios</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/mac/#mac-troubleshoot>15.8. MAC 架構疑難排解</a></li></ul></li><li><input type=checkbox id=chapter-9598d66a76cb3182057b6bcd775149a0 class=toggle>
<label class="icon cursor" for=chapter-9598d66a76cb3182057b6bcd775149a0><a role=button></a></label><a href=http://172.16.201.134:1313/zh-tw/books/handbook/audit/>章 16. 安全事件稽查</a><ul><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/audit/#audit-synopsis>16.1. 概述</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/audit/#audit-inline-glossary>16.2. 關鍵詞</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/audit/#audit-config>16.3. 稽查設定</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/audit/#audit-administration>16.4. 查看稽查線索</a></li></ul></li><li><input type=checkbox id=chapter-e1edcad13d9db6e8e4cb645d378ecfaf class=toggle>
<label class="icon cursor" for=chapter-e1edcad13d9db6e8e4cb645d378ecfaf><a role=button></a></label><a href=http://172.16.201.134:1313/zh-tw/books/handbook/disks/>章 17. 儲存設備</a><ul><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/disks/#disks-synopsis>17.1. 概述</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/disks/#disks-adding>17.2. 加入磁碟</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/disks/#disks-growing>17.3. 重設大小與擴增磁碟</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/disks/#usb-disks>17.4. USB 儲存裝置</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/disks/#creating-cds>17.5. 建立與使用 CD 媒體</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/disks/#creating-dvds>17.6. 建立與使用 DVD 媒體</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/disks/#floppies>17.7. 建立與使用軟碟</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/disks/#backup-basics>17.8. 備份基礎概念</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/disks/#disks-virtual>17.9. 記憶體磁碟</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/disks/#snapshots>17.10. 檔案系統快照</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/disks/#quotas>17.11. 磁碟配額</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/disks/#disks-encrypting>17.12. 磁碟分割區加密</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/disks/#swap-encrypting>17.13. 交換空間加密</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/disks/#disks-hast>17.14. 高可用存儲空間 (HAST)</a></li></ul></li><li><input type=checkbox id=chapter-dde37901a0e0ea32745b67607854900f class=toggle>
<label class="icon cursor" for=chapter-dde37901a0e0ea32745b67607854900f><a role=button></a></label><a href=http://172.16.201.134:1313/zh-tw/books/handbook/geom/>章 18. GEOM: 模組化磁碟轉換框架</a><ul><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/geom/#geom-synopsis>18.1. 概述</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/geom/#geom-striping>18.2. RAID0 - 串連 (Striping)</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/geom/#geom-mirror>18.3. RAID1 - 鏡像 (Mirroring)</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/geom/#geom-raid3>18.4. RAID3 - 位元級串連與獨立奇偶校驗</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/geom/#geom-graid>18.5. 軟體 RAID 裝置</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/geom/#geom-ggate>18.6. GEOM Gate Network</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/geom/#geom-glabel>18.7. 磁碟裝置標籤</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/geom/#geom-gjournal>18.8. UFS Journaling 透過 GEOM</a></li></ul></li><li><input type=checkbox id=chapter-73e82560fcb7145b7c0e2ec47af8fc04 class=toggle>
<label class="icon cursor" for=chapter-73e82560fcb7145b7c0e2ec47af8fc04><a role=button></a></label><a href=http://172.16.201.134:1313/zh-tw/books/handbook/zfs/>章 19. Z 檔案系統 (ZFS)</a><ul><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/zfs/#zfs-differences>19.1. 什麼使 ZFS 與眾不同</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/zfs/#zfs-quickstart>19.2. 快速入門指南</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/zfs/#zfs-zpool>19.3. <code>zpool</code> 管理</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/zfs/#zfs-zfs>19.4. <code>zfs</code> 管理</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/zfs/#zfs-zfs-allow>19.5. 委託管理</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/zfs/#zfs-advanced>19.6. 進階主題</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/zfs/#zfs-links>19.7. 其他資源</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/zfs/#zfs-term>19.8. ZFS 特色與術語</a></li></ul></li><li><input type=checkbox id=chapter-7af71270807eb7b70cd3eedc6577b254 class=toggle>
<label class="icon cursor" for=chapter-7af71270807eb7b70cd3eedc6577b254><a role=button></a></label><a href=http://172.16.201.134:1313/zh-tw/books/handbook/filesystems/>章 20. 其他檔案系統</a><ul><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/filesystems/#filesystems-synopsis>20.1. 概述</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/filesystems/#filesystems-linux>20.2. Linux™ 檔案系統</a></li></ul></li><li><input type=checkbox id=chapter-375257268d95faaf87faf4f7a2e6aa67 class=toggle>
<label class="icon cursor" for=chapter-375257268d95faaf87faf4f7a2e6aa67><a role=button></a></label><a href=http://172.16.201.134:1313/zh-tw/books/handbook/virtualization/>章 21. 虛擬化</a><ul><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/virtualization/#virtualization-synopsis>21.1. 概述</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/virtualization/#virtualization-guest-parallels>21.2. 在 Mac OS™ X 的 Parallels 安裝 FreeBSD 為客端</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/virtualization/#virtualization-guest-virtualpc>21.3. 在 Windows™ 的 Virtual PC 安裝 FreeBSD 為客端</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/virtualization/#virtualization-guest-vmware>21.4. 在 Mac OS™ 的 VMware Fusion 安裝 FreeBSD 為客端</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/virtualization/#virtualization-guest-virtualbox>21.5. 在 VirtualBox™ 安裝 FreeBSD 作為客端</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/virtualization/#virtualization-host-virtualbox>21.6. 以 FreeBSD 作為主端使用 VirtualBox™</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/virtualization/#virtualization-host-bhyve>21.7. 以 FreeBSD 作為主端安裝 bhyve</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/virtualization/#virtualization-host-xen>21.8. 以 FreeBSD 作為主端安裝 Xen™</a></li></ul></li><li><input type=checkbox id=chapter-49f1e96591c090304ea532012257f4ef class=toggle>
<label class="icon cursor" for=chapter-49f1e96591c090304ea532012257f4ef><a role=button></a></label><a href=http://172.16.201.134:1313/zh-tw/books/handbook/l10n/>章 22. 在地化 - i18n/L10n 使用與安裝</a><ul><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/l10n/#l10n-synopsis>22.1. 概述</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/l10n/#using-localization>22.2. 使用語系</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/l10n/#l10n-compiling>22.3. 尋找 i18n 應用程式</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/l10n/#lang-setup>22.4. 特定語言的語系設定</a></li></ul></li><li><input type=checkbox id=chapter-dead2b4c5ea325dd390a9b0dccd8f763 class=toggle>
<label class="icon cursor" for=chapter-dead2b4c5ea325dd390a9b0dccd8f763><a role=button></a></label><a href=http://172.16.201.134:1313/zh-tw/books/handbook/cutting-edge/>章 23. 更新與升級 FreeBSD</a><ul><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/cutting-edge/#updating-upgrading-synopsis>23.1. 概述</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/cutting-edge/#updating-upgrading-freebsdupdate>23.2. FreeBSD 更新</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/cutting-edge/#updating-upgrading-documentation>23.3. 更新文件集</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/cutting-edge/#current-stable>23.4. 追蹤開發分支</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/cutting-edge/#makeworld>23.5. 從原始碼更新 FreeBSD</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/cutting-edge/#small-lan>23.6. 多部機器追蹤</a></li></ul></li><li><input type=checkbox id=chapter-913e72bfb3d6947b2869d3e9447a6eaa class=toggle>
<label class="icon cursor" for=chapter-913e72bfb3d6947b2869d3e9447a6eaa><a role=button></a></label><a href=http://172.16.201.134:1313/zh-tw/books/handbook/usb-device-mode/>章 25. USB Device Mode / USB OTG</a><ul><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/usb-device-mode/#usb-device-mode-synopsis>25.1. 概述</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/usb-device-mode/#usb-device-mode-terminals>25.2. USB 虛擬序列埠</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/usb-device-mode/#usb-device-mode-network>25.3. USB 裝置模式網路介面</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/usb-device-mode/#usb-device-mode-storage>25.4. USB 虛擬儲存裝置</a></li></ul></li><li><input type=checkbox id=chapter-bbd25f9a194f9c39ca2d658c75767db5 class=toggle>
<label for=chapter-bbd25f9a194f9c39ca2d658c75767db5><a role=button></a></label><a href=http://172.16.201.134:1313/zh-tw/books/handbook/partiv/>部 IV. 網路通訊</a></li><li><input type=checkbox id=chapter-29c1eeb0e9dedc487a98399e2737ee8a class=toggle>
<label class="icon cursor" for=chapter-29c1eeb0e9dedc487a98399e2737ee8a><a role=button></a></label><a href=http://172.16.201.134:1313/zh-tw/books/handbook/dtrace/>章 24. DTrace</a><ul><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/dtrace/#dtrace-synopsis>24.1. 概述</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/dtrace/#dtrace-implementation>24.2. 實作差異</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/dtrace/#dtrace-enable>24.3. 開啟 DTrace 支援</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/dtrace/#dtrace-using>24.4. 使用 DTrace</a></li></ul></li><li><input type=checkbox id=chapter-499dab596afd7ddac77e80295314e0dd class=toggle>
<label class="icon cursor" for=chapter-499dab596afd7ddac77e80295314e0dd><a role=button></a></label><a href=http://172.16.201.134:1313/zh-tw/books/handbook/serialcomms/>章 26. 序列通訊</a><ul><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/serialcomms/#serial-synopsis>26.1. 概述</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/serialcomms/#serial>26.2. 序列術語與硬體</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/serialcomms/#term>26.3. 終端機</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/serialcomms/#dialup>26.4. 撥入服務</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/serialcomms/#dialout>26.5. 撥出服務</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/serialcomms/#serialconsole-setup>26.6. 設定序列 Console</a></li></ul></li><li><input type=checkbox id=chapter-95e4571c48bee1cced5e84a538d302e3 class=toggle>
<label class="icon cursor" for=chapter-95e4571c48bee1cced5e84a538d302e3><a role=button></a></label><a href=http://172.16.201.134:1313/zh-tw/books/handbook/ppp-and-slip/>章 27. PPP</a><ul><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/ppp-and-slip/#ppp-and-slip-synopsis>27.1. 概述</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/ppp-and-slip/#userppp>27.2. 設定 PPP</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/ppp-and-slip/#ppp-troubleshoot>27.3. PPP 連線疑難排解</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/ppp-and-slip/#pppoe>27.4. 在乙太網路使用 PPP (PPPoE)</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/ppp-and-slip/#pppoa>27.5. 在 ATM 使用 PPP (PPPoA)</a></li></ul></li><li><input type=checkbox id=chapter-f089ac726c401c9b4bd5c34a295e11bb class=toggle>
<label class="icon cursor" for=chapter-f089ac726c401c9b4bd5c34a295e11bb><a role=button></a></label><a href=http://172.16.201.134:1313/zh-tw/books/handbook/mail/>章 28. 電子郵件</a><ul><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/mail/#mail-synopsis>28.1. 概述</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/mail/#mail-using>28.2. 郵件組成</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/mail/#sendmail>28.3. Sendmail 設定檔</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/mail/#mail-changingmta>28.4. 更改郵件傳輸代理程式</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/mail/#mail-trouble>28.5. 疑難排解</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/mail/#mail-advanced>28.6. 進階主題</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/mail/#outgoing-only>28.7. 寄件設定</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/mail/#SMTP-dialup>28.8. 在撥號連線使用郵件</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/mail/#SMTP-Auth>28.9. SMTP 認證</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/mail/#mail-agents>28.10. 郵件使用者代理程式</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/mail/#mail-fetchmail>28.11. 使用 fetchmail</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/mail/#mail-procmail>28.12. 使用 procmail</a></li></ul></li><li><input type=checkbox id=chapter-6de4de3fe925639d4175ce4b6f8c1829 class=toggle>
<label class="icon cursor" for=chapter-6de4de3fe925639d4175ce4b6f8c1829><a role=button></a></label><a href=http://172.16.201.134:1313/zh-tw/books/handbook/network-servers/>章 29. 網路伺服器</a><ul><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/network-servers/#network-servers-synopsis>29.1. 概述</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/network-servers/#network-inetd>29.2. inetd 超級伺服器</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/network-servers/#network-nfs>29.3. 網路檔案系統 (NFS)</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/network-servers/#network-nis>29.4. 網路資訊系統 (NIS)</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/network-servers/#network-ldap>29.5. 輕量級目錄存取協定 (LDAP)</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/network-servers/#network-dhcp>29.6. 動態主機設置協定 (DHCP)</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/network-servers/#network-dns>29.7. 網域名稱系統 (DNS)</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/network-servers/#network-apache>29.8. Apache HTTP 伺服器</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/network-servers/#network-ftp>29.9. 檔案傳輸協定 (FTP)</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/network-servers/#network-samba>29.10. Microsoft™Windows™ 用戶端檔案與列印服務 (Samba)</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/network-servers/#network-ntp>29.11. NTP 時間校對</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/network-servers/#network-iscsi>29.12. iSCSI Initiator 與 Target 設定</a></li></ul></li><li><input type=checkbox id=chapter-776d855c7b75e048f90b5c2c9b35ffe0 class=toggle checked>
<label class="icon cursor" for=chapter-776d855c7b75e048f90b5c2c9b35ffe0><a role=button></a></label><a href=http://172.16.201.134:1313/zh-tw/books/handbook/firewalls/>章 30. 防火牆</a><ul><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/firewalls/#firewalls-intro>30.1. 概述</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/firewalls/#firewalls-concepts>30.2. 防火牆概念</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/firewalls/#firewalls-pf>30.3. PF</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/firewalls/#firewalls-ipfw>30.4. IPFW</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/firewalls/#firewalls-ipf>30.5. IPFILTER (IPF)</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/firewalls/#firewalls-blacklistd>30.6. Blacklistd</a></li></ul></li><li><input type=checkbox id=chapter-5b07f776a0e6155c1c89aa0d15610380 class=toggle>
<label class="icon cursor" for=chapter-5b07f776a0e6155c1c89aa0d15610380><a role=button></a></label><a href=http://172.16.201.134:1313/zh-tw/books/handbook/advanced-networking/>章 31. 進階網路設定</a><ul><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/advanced-networking/#advanced-networking-synopsis>31.1. 概述</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/advanced-networking/#network-routing>31.2. 通訊閘與路由</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/advanced-networking/#network-wireless>31.3. 無線網路</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/advanced-networking/#network-usb-tethering>31.4. USB 網路共享</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/advanced-networking/#network-bluetooth>31.5. 藍牙</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/advanced-networking/#network-bridging>31.6. 橋接</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/advanced-networking/#network-aggregation>31.7. Link Aggregation 與容錯移轉</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/advanced-networking/#network-diskless>31.8. PXE 無磁碟作業</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/advanced-networking/#network-ipv6>31.9. IPv6</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/advanced-networking/#carp>31.10. 共用位址備援協定 (CARP)</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/advanced-networking/#network-vlan>31.11. VLANs</a></li></ul></li><li><input type=checkbox id=chapter-171a77aa9d067a1024f849470e1f33e8 class=toggle>
<label for=chapter-171a77aa9d067a1024f849470e1f33e8><a role=button></a></label><a href=http://172.16.201.134:1313/zh-tw/books/handbook/partv/>部 V. 附錄</a></li><li><input type=checkbox id=chapter-8050f436a0a7986a4aaded93d8e49469 class=toggle>
<label class="icon cursor" for=chapter-8050f436a0a7986a4aaded93d8e49469><a role=button></a></label><a href=http://172.16.201.134:1313/zh-tw/books/handbook/mirrors/>附錄 A. 取得 FreeBSD</a><ul><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/mirrors/#mirrors-cdrom>A.1. CD 與 DVD 合集</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/mirrors/#mirrors-ftp>A.2. FTP 站</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/mirrors/#svn>A.3. 使用 Subversion</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/mirrors/#mirrors-rsync>A.4. 使用 rsync</a></li></ul></li><li><input type=checkbox id=chapter-128b630a8f88f158e7027fe6c2184d21 class=toggle>
<label class="icon cursor" for=chapter-128b630a8f88f158e7027fe6c2184d21><a role=button></a></label><a href=http://172.16.201.134:1313/zh-tw/books/handbook/bibliography/>附錄 B. 參考書目</a><ul><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/bibliography/#bibliography-freebsd>B.1. FreeBSD 相關書籍</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/bibliography/#bibliography-userguides>B.2. 使用指南</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/bibliography/#bibliography-adminguides>B.3. 管理指南</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/bibliography/#bibliography-programmers>B.4. 開發指南</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/bibliography/#bibliography-osinternals>B.5. 深入作業系統</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/bibliography/#bibliography-security>B.6. 安全性參考文獻</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/bibliography/#bibliography-hardware>B.7. 硬體參考文獻</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/bibliography/#bibliography-history>B.8. UNIX™ 歷史</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/bibliography/#bibliography-journals>B.9. 期刊與雜誌</a></li></ul></li><li><input type=checkbox id=chapter-8bbb8867c46dac315e2253945d8c18a8 class=toggle>
<label class="icon cursor" for=chapter-8bbb8867c46dac315e2253945d8c18a8><a role=button></a></label><a href=http://172.16.201.134:1313/zh-tw/books/handbook/eresources/>附錄 C. 網路資源</a><ul><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/eresources/#eresources-www>C.1. 網站</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/eresources/#eresources-mail>C.2. 郵遞論壇 (Mailing List)</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/eresources/#eresources-news>C.3. Usenet 新聞群組</a></li><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/eresources/#eresources-web>C.4. 官方鏡像站</a></li></ul></li><li><input type=checkbox id=chapter-a80ea4f5a4480b8725422710f954ef36 class=toggle>
<label class="icon cursor" for=chapter-a80ea4f5a4480b8725422710f954ef36><a role=button></a></label><a href=http://172.16.201.134:1313/zh-tw/books/handbook/pgpkeys/>附錄 D. OpenPGP 金鑰</a><ul><li><a href=http://172.16.201.134:1313/zh-tw/books/handbook/pgpkeys/#pgpkeys-officers>D.1. Officers</a></li></ul></li><li></li></ul></nav></div></aside><div class=book><div class=book-menu-mobile><label for=menu-control><span class=menu-control-button><i class="fa fa-list" aria-hidden=true title="Book menu"></i>
Book menu</span></label></div><h1 class=title>章 30. 防火牆</h1><div class="admonitionblock note"><p><i class="fa fa-exclamation-circle" aria-hidden=true></i>
This translation may be out of date. To help with the translations please access the <a href=https://translate-dev.freebsd.org/ target=_blank>FreeBSD translations instance</a>.</p></div><div class=toc-mobile><h3>目錄</h3><nav id=TableOfContents><ul><li><a href=#firewalls-intro>30.1. 概述</a></li><li><a href=#firewalls-concepts>30.2. 防火牆概念</a></li><li><a href=#firewalls-pf>30.3. PF</a></li><li><a href=#firewalls-ipfw>30.4. IPFW</a></li><li><a href=#firewalls-ipf>30.5. IPFILTER (IPF)</a></li><li><a href=#firewalls-blacklistd>30.6. Blacklistd</a></li></ul></nav></div><div class=book-content><div id=preamble><div class=sectionbody></div></div><div class=sect1><h2 id=firewalls-intro>30.1. 概述<a class=anchor href=#firewalls-intro></a></h2><div class=sectionbody><div class=paragraph><p>防火牆能夠過濾透過系統內送 (Incoming) 與外發 (Outgoing) 的流量，防火牆可使用一組或多組 "規則 (Rules)" 來檢查網路連線中進出的網路封包(Network packets)，並且能允許或阻擋其通過。 而防火牆規則可以檢查封包中一個或數個特徵，例如通訊協定類型、來源或目的主機位址，以及來源及目地的連接埠 (Port)。</p></div><div class=paragraph><p>防火牆可以加強主機或網路的安全性，它可以用來完成下列事情：</p></div><div class=ulist><ul><li><p>保護並隔離內部網路的應用程式、服務與主機，避免來自網際網路不必要的存取。</p></li><li><p>限制或者禁止內部網路的主機存取網際網路服務。</p></li><li><p>支援網路位址轉譯 (Network address translation, NAT)，可允許內部網路使用私有 IP 位址並共用一個連線使用一個 IP 位址連到網際網路或者自動分配一個共用池當中的公開位址。</p></li></ul></div><div class=paragraph><p>FreeBSD 有三種內建於基礎系統的防火牆：PF, IPFW 與 IPFILTER 即 IPF。FreeBSD 也提供了兩種流量限制程式 (Traffic shaper) 來控制頻寬的用量：<a href="https://man.freebsd.org/cgi/man.cgi?query=altq&amp;sektion=4&amp;format=html">altq(4)</a> 與 <a href="https://man.freebsd.org/cgi/man.cgi?query=dummynet&amp;sektion=4&amp;format=html">dummynet(4)</a>，ALTQ 一般配合 PF 使用，而 dummynet 會配合 IPFW。每一種防火牆都會使用規則來管制來自與送往 FreeBSD 的封包，儘管它們用不同的方式運作且有不同的規則語法。</p></div><div class=paragraph><p>FreeBSD 提供多個防火牆是為了滿足不同的需求與各種使用者的偏好，每位使用者應評估那一種防火牆最能滿足其需求。</p></div><div class=paragraph><p>讀完這章，您將了解：</p></div><div class=ulist><ul><li><p>如何定義封包過濾規則。</p></li><li><p>FreeBSD 內建防火牆之間的差異。</p></li><li><p>如何使用與設定 PF 防火牆。</p></li><li><p>如何使用與設定 IPFW 防火牆。</p></li><li><p>如何使用與設定 IPFILTER 防火牆。</p></li></ul></div><div class=paragraph><p>在開始閱讀這章之前，您需要：</p></div><div class=ulist><ul><li><p>了解 FreeBSD 基礎及網路概念。</p></li></ul></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>由於所有防火牆均是以監控所選封包的控制欄位值為基礎運作，所以防火牆規則集的建立者必須很明白 TCP/IP 是如何運作的，在封包的控制欄位中會有那些數值，這些數值會被如何用在一般的連線階段，要了解更多相關資訊，可參考 <a href=http://www.ipprimer.com>Daryl’s TCP/IP Primer</a>。</p></div></td></tr></tbody></table></div></div></div><div class=sect1><h2 id=firewalls-concepts>30.2. 防火牆概念<a class=anchor href=#firewalls-concepts></a></h2><div class=sectionbody><div class=paragraph><p>一個規則集 (Ruleset) 中會有一群根據封包內的資料來判斷通過或封鎖的規則，主機間雙向的封包交換構成一個連線階段的對話，防火牆規則集會同時處理接收自網際網路的封包以及由系統所產生的回應封包，每一個 TCP/IP 服務都會預先定義其通訊協定以及要傾聽的埠，要送往指定服務的封包會誕生在來源位址，使用一個不需特殊權限的埠並傳送給目標位址上特定服務的埠，所有上述過程中的參數均可用來當做建立規則的篩選條件，來允許或封鎖服務。</p></div><div class=paragraph><p>要查詢一個不清楚的埠號，可參考 <span class=filename>/etc/services</span>，或者至 <a href=http://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers>http://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers</a> 查詢埠號來找出特定埠號的用途。</p></div><div class=paragraph><p>查看這個連結來了解有 <a href=http://web.archive.org/web/20150803024617/http://www.sans.org/security-resources/idfaq/oddports.php>那些埠號會被木馬程式使用</a>。</p></div><div class=paragraph><p>FTP 有兩個模式：主動 (Active) 模式與被動 (Passive) 模式，兩者的差異在於取得資料通道的方式，被動模式會較安全，由於資料通道會取自 FTP 連線請求者。想要取得 FTP 與兩種模式更進一步的說明，詳見 <a href=http://www.slacksite.com/other/ftp.html>http://www.slacksite.com/other/ftp.html</a>。</p></div><div class=paragraph><p>防火牆規則集可以為排除式 ("exclusive") 或者內含式 ("inclusive")，一個排除式的防火牆會允許所有的連線通過除了符合規則集的連線，內含式的防火牆則會反過來只允許符合規則集的連線並封鎖其他任何的連線。</p></div><div class=paragraph><p>內含式的防火牆對於外發的流量有較好的控制，使其成為提供網際網路服務的系統的最佳選擇，它同時可以控制可存取私有網路的網際網路連線，所有不符合該規則的連線會被封鎖並記錄。一般來說，內含式的防火牆會比排除式的防火牆安全，因為內含式的防火牆可以明顯的減少不必要連線所造成風險。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>除非另有說明，否則所有在此章節的範例規則集均為內含式防火牆規則集。</p></div></td></tr></tbody></table></div><div class=paragraph><p>使用具狀態防火牆 ("Stateful firewall") 可以更進一步加強安全性，這種類型的防火牆可持續追蹤連線，只允許與現有連線相符的封包或符合允許條件的新連線通過。</p></div><div class=paragraph><p>狀態過濾技術 (Stateful filtering) 將所有的流量當做是一個由雙向封包交換所組成的連線階段，當在符合的規則上指定狀態 (State) 時，防火牆會自動產生內部規則來處理該連線階段中每個預期會通過的封包，這種防火牆有足夠的比對能力可以辨別是否為同一個連線階段的封包，任何不符合連線階段樣板的封包都會被自動拒絕。</p></div><div class=paragraph><p>當連線階段結束時，該規則將會動態狀態表 (Dynamic state table) 中移除。</p></div><div class=paragraph><p>Stateful filtering 讓管理者可以專注於封鎖/傳遞新的連線階段，若新的連線階段通過，那麼該連線階段後續的封包將會自動允許通過，且任何假冒的封包會自動被拒絕。若新的連線階最被封鎖，將不允許其任何後續的封包。Stateful filtering 提供了進階的比對能力，能夠抵禦不同種類由攻擊者發動的 flood 攻擊。</p></div><div class=paragraph><p>NAT 代表 <em>Network Address Translation</em> 即網路位址轉譯，NAT 功能讓在防火牆之後的私有 LAN 可以共用一個 ISP 分配的 IP 位址 (甚至是動態分配的)，NAT 每一台在該 LAN 中的電腦均可連線網際網路，而不需要支付 ISP 多個網路帳號或 IP 位址的額外費用。</p></div><div class=paragraph><p>NAT 在當封包要外送到防火牆之外的網際網路時，會自動轉譯每一台電腦在私有 LAN 的 IP 位址成為一個公有 IP 位址，它也同樣會對回傳的封包做反向轉譯。</p></div><div class=paragraph><p>根據 RFC1918，會保留以下範圍的 IP 位址做為私有網路使用，永遠不會被傳送到網際網路，因此可供 NAT 使用：</p></div><div class=ulist><ul><li><p><code>10.0.0.0/8</code>.</p></li><li><p><code>172.16.0.0/12</code>.</p></li><li><p><code>192.168.0.0/16</code>.</p></li></ul></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>在使用防火牆規則時要_非常小心_，有一些設定_會將管理者鎖在伺服器之外_，保險起見的方式是在本機的 Console 做初次的防火牆設定，不要直接由遠端透過 ssh 來設定防火牆。</p></div></td></tr></tbody></table></div></div></div><div class=sect1><h2 id=firewalls-pf>30.3. PF<a class=anchor href=#firewalls-pf></a></h2><div class=sectionbody><div class=paragraph><p>自 FreeBSD 5.3 開始，基礎系統便有內建 OpenBSD’s PF 防火牆的移植版本，PF 是一套完整、多功能的防火牆，並可選擇開啟 ALTQ (Alternate Queuing) 的支援來提供 Quality of Service (QoS) 機制。</p></div><div class=paragraph><p>OpenBSD 計劃有維護一份官方參考文件於 <a href=http://www.openbsd.org/faq/pf/>PF FAQ</a> ，Peter Hansteen 有維一份詳盡的 PF 教學於 <a href=http://home.nuug.no/~peter/pf/>http://home.nuug.no/~peter/pf/</a>。</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>When reading the <a href=http://www.openbsd.org/faq/pf/>PF FAQ</a>, keep in mind that FreeBSD’s version of PF has diverged substantially from the upstream OpenBSD version over the years. Not all features work the same way on FreeBSD as they do in OpenBSD and vice versa.</p></div></td></tr></tbody></table></div><div class=paragraph><p>要詢問有關設定與執行 PF 防火牆的問題可至 <a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-pf>FreeBSD packet filter 郵遞論壇</a>，在詢問問題之前請先查看該郵遞論壇的封存資料，因您的問題可能已有解答。</p></div><div class=paragraph><p>This section of the Handbook focuses on PF as it pertains to FreeBSD. It demonstrates how to enable PF and ALTQ. It also provides several examples for creating rulesets on a FreeBSD system.</p></div><div class=sect2><h3 id=_開啟_pf>30.3.1. 開啟 PF<a class=anchor href=#_開啟_pf></a></h3><div class=paragraph><p>To use PF, its kernel module must be first loaded. This section describes the entries that can be added to <span class=filename>/etc/rc.conf</span> to enable PF.</p></div><div class=paragraph><p>Start by adding <code>pf_enable=yes</code> to <span class=filename>/etc/rc.conf</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysrc pf_enable=yes</span></code></pre></div></div><div class=paragraph><p>Additional options, described in <a href="https://man.freebsd.org/cgi/man.cgi?query=pfctl&amp;sektion=8&amp;format=html">pfctl(8)</a>, can be passed to PF when it is started. Add or change this entry in <span class=filename>/etc/rc.conf</span> and specify any required flags between the two quotes (<code>""</code>):</p></div><div class="literalblock programlisting"><div class=content><pre>pf_flags=&#34;&#34;                     # additional flags for pfctl startup</pre></div></div><div class=paragraph><p>PF will not start if it cannot find its ruleset configuration file. By default, FreeBSD does not ship with a ruleset and there is no <span class=filename>/etc/pf.conf</span>. Example rulesets can be found in <span class=filename>/usr/shared/examples/pf/</span>. If a custom ruleset has been saved somewhere else, add a line to <span class=filename>/etc/rc.conf</span> which specifies the full path to the file:</p></div><div class="literalblock programlisting"><div class=content><pre>pf_rules=&#34;/path/to/pf.conf&#34;</pre></div></div><div class=paragraph><p>Logging support for PF is provided by <a href="https://man.freebsd.org/cgi/man.cgi?query=pflog&amp;sektion=4&amp;format=html">pflog(4)</a>. To enable logging support, add <code>pflog_enable=yes</code> to <span class=filename>/etc/rc.conf</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysrc pflog_enable=yes</span></code></pre></div></div><div class=paragraph><p>The following lines can also be added to change the default location of the log file or to specify any additional flags to pass to <a href="https://man.freebsd.org/cgi/man.cgi?query=pflog&amp;sektion=4&amp;format=html">pflog(4)</a> when it is started:</p></div><div class="literalblock programlisting"><div class=content><pre>pflog_logfile=&#34;/var/log/pflog&#34;  # where pflogd should store the logfile
pflog_flags=&#34;&#34;                  # additional flags for pflogd startup</pre></div></div><div class=paragraph><p>Finally, if there is a LAN behind the firewall and packets need to be forwarded for the computers on the LAN, or NAT is required, enable the following option:</p></div><div class="literalblock programlisting"><div class=content><pre>gateway_enable=&#34;YES&#34;            # Enable as LAN gateway</pre></div></div><div class=paragraph><p>After saving the needed edits, PF can be started with logging support by typing:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service pf start</span>
<span class=c># service pflog start</span></code></pre></div></div><div class=paragraph><p>By default, PF reads its configuration rules from <span class=filename>/etc/pf.conf</span> and modifies, drops, or passes packets according to the rules or definitions specified in this file. The FreeBSD installation includes several sample files located in <span class=filename>/usr/shared/examples/pf/</span>. Refer to the <a href=http://www.openbsd.org/faq/pf/>PF FAQ</a> for complete coverage of PF rulesets.</p></div><div class=paragraph><p>To control PF, use <code>pfctl</code>. <a href=#pfctl>有用的 <code>pfctl</code> 選項</a> summarizes some useful options to this command. Refer to <a href="https://man.freebsd.org/cgi/man.cgi?query=pfctl&amp;sektion=8&amp;format=html">pfctl(8)</a> for a description of all available options:</p></div><table id=pfctl class="tableblock frame-none grid-all stretch"><caption class=title>表 1. 有用的 <code>pfctl</code> 選項</caption><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">指令</th><th class="tableblock halign-left valign-top">用途</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>pfctl -e</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Enable PF.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>pfctl -d</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Disable PF.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>pfctl -F all -f /etc/pf.conf</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Flush all NAT, filter, state, and table rules and reload <span class=filename>/etc/pf.conf</span>.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>pfctl -s [ rules | nat | states ]</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Report on the filter rules, NAT rules, or state table.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>pfctl -vnf /etc/pf.conf</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Check <span class=filename>/etc/pf.conf</span> for errors, but do not load ruleset.</p></td></tr></tbody></table><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p><a class=package href=https://cgit.freebsd.org/ports/tree/security/sudo/>security/sudo</a> is useful for running commands like <code>pfctl</code> that require elevated privileges. It can be installed from the Ports Collection.</p></div></td></tr></tbody></table></div><div class=paragraph><p>To keep an eye on the traffic that passes through the PF firewall, consider installing the <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/pftop/>sysutils/pftop</a> package or port. Once installed, pftop can be run to view a running snapshot of traffic in a format which is similar to <a href="https://man.freebsd.org/cgi/man.cgi?query=top&amp;sektion=1&amp;format=html">top(1)</a>.</p></div></div><div class=sect2><h3 id=pf-tutorial>30.3.2. PF 規則集<a class=anchor href=#pf-tutorial></a></h3><div class=paragraph><p>This section demonstrates how to create a customized ruleset. It starts with the simplest of rulesets and builds upon its concepts using several examples to demonstrate real-world usage of PF’s many features.</p></div><div class=paragraph><p>The simplest possible ruleset is for a single machine that does not run any services and which needs access to one network, which may be the Internet. To create this minimal ruleset, edit <span class=filename>/etc/pf.conf</span> so it looks like this:</p></div><div class="literalblock programlisting"><div class=content><pre>block in all
pass out all keep state</pre></div></div><div class=paragraph><p>The first rule denies all incoming traffic by default. The second rule allows connections created by this system to pass out, while retaining state information on those connections. This state information allows return traffic for those connections to pass back and should only be used on machines that can be trusted. The ruleset can be loaded with:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pfctl -e ; pfctl -f /etc/pf.conf</span></code></pre></div></div><div class=paragraph><p>In addition to keeping state, PF provides <em>lists</em> and <em>macros</em> which can be defined for use when creating rules. Macros can include lists and need to be defined before use. As an example, insert these lines at the very top of the ruleset:</p></div><div class="literalblock programlisting"><div class=content><pre>tcp_services = &#34;{ ssh, smtp, domain, www, pop3, auth, pop3s }&#34;
udp_services = &#34;{ domain }&#34;</pre></div></div><div class=paragraph><p>PF understands port names as well as port numbers, as long as the names are listed in <span class=filename>/etc/services</span>. This example creates two macros. The first is a list of seven TCP port names and the second is one UDP port name. Once defined, macros can be used in rules. In this example, all traffic is blocked except for the connections initiated by this system for the seven specified TCP services and the one specified UDP service:</p></div><div class="literalblock programlisting"><div class=content><pre>tcp_services = &#34;{ ssh, smtp, domain, www, pop3, auth, pop3s }&#34;
udp_services = &#34;{ domain }&#34;
block all
pass out proto tcp to any port $tcp_services keep state
pass proto udp to any port $udp_services keep state</pre></div></div><div class=paragraph><p>Even though UDP is considered to be a stateless protocol, PF is able to track some state information. For example, when a UDP request is passed which asks a name server about a domain name, PF will watch for the response to pass it back.</p></div><div class=paragraph><p>Whenever an edit is made to a ruleset, the new rules must be loaded so they can be used:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pfctl -f /etc/pf.conf</span></code></pre></div></div><div class=paragraph><p>If there are no syntax errors, <code>pfctl</code> will not output any messages during the rule load. Rules can also be tested before attempting to load them:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pfctl -nf /etc/pf.conf</span></code></pre></div></div><div class=paragraph><p>Including <code>-n</code> causes the rules to be interpreted only, but not loaded. This provides an opportunity to correct any errors. At all times, the last valid ruleset loaded will be enforced until either PF is disabled or a new ruleset is loaded.</p></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Adding <code>-v</code> to a <code>pfctl</code> ruleset verify or load will display the fully parsed rules exactly the way they will be loaded. This is extremely useful when debugging rules.</p></div></td></tr></tbody></table></div><div class=sect3><h4 id=pftut-gateway>30.3.2.1. 使用 NAT 的簡單通訊閘<a class=anchor href=#pftut-gateway></a></h4><div class=paragraph><p>This section demonstrates how to configure a FreeBSD system running PF to act as a gateway for at least one other machine. The gateway needs at least two network interfaces, each connected to a separate network. In this example, <span class=filename>xl1</span> is connected to the Internet and <span class=filename>xl0</span> is connected to the internal network.</p></div><div class=paragraph><p>First, enable the gateway to let the machine forward the network traffic it receives on one interface to another interface. This sysctl setting will forward IPv4 packets:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl net.inet.ip.forwarding=1</span></code></pre></div></div><div class=paragraph><p>To forward IPv6 traffic, use:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl net.inet6.ip6.forwarding=1</span></code></pre></div></div><div class=paragraph><p>To enable these settings at system boot, use <a href="https://man.freebsd.org/cgi/man.cgi?query=sysrc&amp;sektion=8&amp;format=html">sysrc(8)</a> to add them to <span class=filename>/etc/rc.conf</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysrc gateway_enable=yes</span>
<span class=c># sysrc ipv6_gateway_enable=yes</span></code></pre></div></div><div class=paragraph><p>Verify with <code>ifconfig</code> that both of the interfaces are up and running.</p></div><div class=paragraph><p>Next, create the PF rules to allow the gateway to pass traffic. While the following rule allows stateful traffic to pass from the Internet to hosts on the network, the <code>to</code> keyword does not guarantee passage all the way from source to destination:</p></div><div class="literalblock programlisting"><div class=content><pre>pass in on xl1 from xl1:network to xl0:network port $ports keep state</pre></div></div><div class=paragraph><p>That rule only lets the traffic pass in to the gateway on the internal interface. To let the packets go further, a matching rule is needed:</p></div><div class="literalblock programlisting"><div class=content><pre>pass out on xl0 from xl1:network to xl0:network port $ports keep state</pre></div></div><div class=paragraph><p>While these two rules will work, rules this specific are rarely needed. For a busy network admin, a readable ruleset is a safer ruleset. The remainder of this section demonstrates how to keep the rules as simple as possible for readability. For example, those two rules could be replaced with one rule:</p></div><div class="literalblock programlisting"><div class=content><pre>pass from xl1:network to any port $ports keep state</pre></div></div><div class=paragraph><p>The <code>interface:network</code> notation can be replaced with a macro to make the ruleset even more readable. For example, a <code>$localnet</code> macro could be defined as the network directly attached to the internal interface (<code>$xl1:network</code>). Alternatively, the definition of <code>$localnet</code> could be changed to an <em>IP address/netmask</em> notation to denote a network, such as <code>192.168.100.1/24</code> for a subnet of private addresses.</p></div><div class=paragraph><p>If required, <code>$localnet</code> could even be defined as a list of networks. Whatever the specific needs, a sensible <code>$localnet</code> definition could be used in a typical pass rule as follows:</p></div><div class="literalblock programlisting"><div class=content><pre>pass from $localnet to any port $ports keep state</pre></div></div><div class=paragraph><p>The following sample ruleset allows all traffic initiated by machines on the internal network. It first defines two macros to represent the external and internal 3COM interfaces of the gateway.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>For dialup users, the external interface will use <span class=filename>tun0</span>. For an ADSL connection, specifically those using PPP over Ethernet (PPPoE), the correct external interface is <span class=filename>tun0</span>, not the physical Ethernet interface.</p></div></td></tr></tbody></table></div><div class="literalblock programlisting"><div class=content><pre>ext_if = &#34;xl0&#34;	# macro for external interface - use tun0 for PPPoE
int_if = &#34;xl1&#34;	# macro for internal interface
localnet = $int_if:network
# ext_if IP address could be dynamic, hence ($ext_if)
nat on $ext_if from $localnet to any -&gt; ($ext_if)
block all
pass from { lo0, $localnet } to any keep state</pre></div></div><div class=paragraph><p>This ruleset introduces the <code>nat</code> rule which is used to handle the network address translation from the non-routable addresses inside the internal network to the IP address assigned to the external interface. The parentheses surrounding the last part of the nat rule <code>($ext_if)</code> is included when the IP address of the external interface is dynamically assigned. It ensures that network traffic runs without serious interruptions even if the external IP address changes.</p></div><div class=paragraph><p>Note that this ruleset probably allows more traffic to pass out of the network than is needed. One reasonable setup could create this macro:</p></div><div class="literalblock programlisting"><div class=content><pre>client_out = &#34;{ ftp-data, ftp, ssh, domain, pop3, auth, nntp, http, \
    https, cvspserver, 2628, 5999, 8000, 8080 }&#34;</pre></div></div><div class=paragraph><p>to use in the main pass rule:</p></div><div class="literalblock programlisting"><div class=content><pre>pass inet proto tcp from $localnet to any port $client_out \
    flags S/SA keep state</pre></div></div><div class=paragraph><p>A few other pass rules may be needed. This one enables SSH on the external interface:</p></div><div class="literalblock programlisting"><div class=content><pre>pass in inet proto tcp to $ext_if port ssh</pre></div></div><div class=paragraph><p>This macro definition and rule allows DNS and NTP for internal clients:</p></div><div class="literalblock programlisting"><div class=content><pre>udp_services = &#34;{ domain, ntp }&#34;
pass quick inet proto { tcp, udp } to any port $udp_services keep state</pre></div></div><div class=paragraph><p>Note the <code>quick</code> keyword in this rule. Since the ruleset consists of several rules, it is important to understand the relationships between the rules in a ruleset. Rules are evaluated from top to bottom, in the sequence they are written. For each packet or connection evaluated by PF, <em>the last matching rule</em> in the ruleset is the one which is applied. However, when a packet matches a rule which contains the <code>quick</code> keyword, the rule processing stops and the packet is treated according to that rule. This is very useful when an exception to the general rules is needed.</p></div></div><div class=sect3><h4 id=pftut-ftp>30.3.2.2. 建立 FTP Proxy<a class=anchor href=#pftut-ftp></a></h4><div class=paragraph><p>Configuring working FTP rules can be problematic due to the nature of the FTP protocol. FTP pre-dates firewalls by several decades and is insecure in its design. The most common points against using FTP include:</p></div><div class=ulist><ul><li><p>Passwords are transferred in the clear.</p></li><li><p>The protocol demands the use of at least two TCP connections (control and data) on separate ports.</p></li><li><p>When a session is established, data is communicated using randomly selected ports.</p></li></ul></div><div class=paragraph><p>All of these points present security challenges, even before considering any potential security weaknesses in client or server software. More secure alternatives for file transfer exist, such as <a href="https://man.freebsd.org/cgi/man.cgi?query=sftp&amp;sektion=1&amp;format=html">sftp(1)</a> or <a href="https://man.freebsd.org/cgi/man.cgi?query=scp&amp;sektion=1&amp;format=html">scp(1)</a>, which both feature authentication and data transfer over encrypted connections..</p></div><div class=paragraph><p>For those situations when FTP is required, PF provides redirection of FTP traffic to a small proxy program called <a href="https://man.freebsd.org/cgi/man.cgi?query=ftp-proxy&amp;sektion=8&amp;format=html">ftp-proxy(8)</a>, which is included in the base system of FreeBSD. The role of the proxy is to dynamically insert and delete rules in the ruleset, using a set of anchors, to correctly handle FTP traffic.</p></div><div class=paragraph><p>To enable the FTP proxy, add this line to <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>ftpproxy_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Then start the proxy by running <code>service ftp-proxy start</code>.</p></div><div class=paragraph><p>For a basic configuration, three elements need to be added to <span class=filename>/etc/pf.conf</span>. First, the anchors which the proxy will use to insert the rules it generates for the FTP sessions:</p></div><div class="literalblock programlisting"><div class=content><pre>nat-anchor &#34;ftp-proxy/*&#34;
rdr-anchor &#34;ftp-proxy/*&#34;</pre></div></div><div class=paragraph><p>Second, a pass rule is needed to allow FTP traffic in to the proxy.</p></div><div class=paragraph><p>Third, redirection and NAT rules need to be defined before the filtering rules. Insert this <code>rdr</code> rule immediately after the <code>nat</code> rule:</p></div><div class="literalblock programlisting"><div class=content><pre>rdr pass on $int_if proto tcp from any to any port ftp -&gt; 127.0.0.1 port 8021</pre></div></div><div class=paragraph><p>Finally, allow the redirected traffic to pass:</p></div><div class="literalblock programlisting"><div class=content><pre>pass out proto tcp from $proxy to any port ftp</pre></div></div><div class=paragraph><p>where <code>$proxy</code> expands to the address the proxy daemon is bound to.</p></div><div class=paragraph><p>Save <span class=filename>/etc/pf.conf</span>, load the new rules, and verify from a client that FTP connections are working:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pfctl -f /etc/pf.conf</span></code></pre></div></div><div class=paragraph><p>This example covers a basic setup where the clients in the local network need to contact FTP servers elsewhere. This basic configuration should work well with most combinations of FTP clients and servers. As shown in <a href="https://man.freebsd.org/cgi/man.cgi?query=ftp-proxy&amp;sektion=8&amp;format=html">ftp-proxy(8)</a>, the proxy’s behavior can be changed in various ways by adding options to the <code>ftpproxy_flags=</code> line. Some clients or servers may have specific quirks that must be compensated for in the configuration, or there may be a need to integrate the proxy in specific ways such as assigning FTP traffic to a specific queue.</p></div><div class=paragraph><p>For ways to run an FTP server protected by PF and <a href="https://man.freebsd.org/cgi/man.cgi?query=ftp-proxy&amp;sektion=8&amp;format=html">ftp-proxy(8)</a>, configure a separate <code>ftp-proxy</code> in reverse mode, using <code>-R</code>, on a separate port with its own redirecting pass rule.</p></div></div><div class=sect3><h4 id=pftut-icmp>30.3.2.3. 管理 ICMP<a class=anchor href=#pftut-icmp></a></h4><div class=paragraph><p>Many of the tools used for debugging or troubleshooting a TCP/IP network rely on the Internet Control Message Protocol (ICMP), which was designed specifically with debugging in mind.</p></div><div class=paragraph><p>The ICMP protocol sends and receives <em>control messages</em> between hosts and gateways, mainly to provide feedback to a sender about any unusual or difficult conditions enroute to the target host. Routers use ICMP to negotiate packet sizes and other transmission parameters in a process often referred to as <em>path MTU discovery</em>.</p></div><div class=paragraph><p>From a firewall perspective, some ICMP control messages are vulnerable to known attack vectors. Also, letting all diagnostic traffic pass unconditionally makes debugging easier, but it also makes it easier for others to extract information about the network. For these reasons, the following rule may not be optimal:</p></div><div class="literalblock programlisting"><div class=content><pre>pass inet proto icmp from any to any</pre></div></div><div class=paragraph><p>One solution is to let all ICMP traffic from the local network through while stopping all probes from outside the network:</p></div><div class="literalblock programlisting"><div class=content><pre>pass inet proto icmp from $localnet to any keep state
pass inet proto icmp from any to $ext_if keep state</pre></div></div><div class=paragraph><p>Additional options are available which demonstrate some of PF’s flexibility. For example, rather than allowing all ICMP messages, one can specify the messages used by <a href="https://man.freebsd.org/cgi/man.cgi?query=ping&amp;sektion=8&amp;format=html">ping(8)</a> and <a href="https://man.freebsd.org/cgi/man.cgi?query=traceroute&amp;sektion=8&amp;format=html">traceroute(8)</a>. Start by defining a macro for that type of message:</p></div><div class="literalblock programlisting"><div class=content><pre>icmp_types = &#34;echoreq&#34;</pre></div></div><div class=paragraph><p>and a rule which uses the macro:</p></div><div class="literalblock programlisting"><div class=content><pre>pass inet proto icmp all icmp-type $icmp_types keep state</pre></div></div><div class=paragraph><p>If other types of ICMP packets are needed, expand <code>icmp_types</code> to a list of those packet types. Type <code>more /usr/src/sbin/pfctl/pfctl_parser.c</code> to see the list of ICMP message types supported by PF. Refer to <a href=http://www.iana.org/assignments/icmp-parameters/icmp-parameters.xhtml>http://www.iana.org/assignments/icmp-parameters/icmp-parameters.xhtml</a> for an explanation of each message type.</p></div><div class=paragraph><p>Since Unix <code>traceroute</code> uses UDP by default, another rule is needed to allow Unix <code>traceroute</code>:</p></div><div class="literalblock programlisting"><div class=content><pre># allow out the default range for traceroute(8):
pass out on $ext_if inet proto udp from any to any port 33433 &gt;&lt; 33626 keep state</pre></div></div><div class=paragraph><p>Since <code>TRACERT.EXE</code> on Microsoft Windows systems uses ICMP echo request messages, only the first rule is needed to allow network traces from those systems. Unix <code>traceroute</code> can be instructed to use other protocols as well, and will use ICMP echo request messages if <code>-I</code> is used. Check the <a href="https://man.freebsd.org/cgi/man.cgi?query=traceroute&amp;sektion=8&amp;format=html">traceroute(8)</a> man page for details.</p></div><div class=sect4><h5 id=pftut-pathmtudisc>30.3.2.3.1. Path MTU Discovery<a class=anchor href=#pftut-pathmtudisc></a></h5><div class=paragraph><p>Internet protocols are designed to be device independent, and one consequence of device independence is that the optimal packet size for a given connection cannot always be predicted reliably. The main constraint on packet size is the <em>Maximum Transmission Unit</em> (MTU) which sets the upper limit on the packet size for an interface. Type <code>ifconfig</code> to view the MTUs for a system’s network interfaces.</p></div><div class=paragraph><p>TCP/IP uses a process known as path MTU discovery to determine the right packet size for a connection. This process sends packets of varying sizes with the "Do not fragment" flag set, expecting an ICMP return packet of "type 3, code 4" when the upper limit has been reached. Type 3 means "destination unreachable", and code 4 is short for "fragmentation needed, but the do-not-fragment flag is set". To allow path MTU discovery in order to support connections to other MTUs, add the <code>destination unreachable</code> type to the <code>icmp_types</code> macro:</p></div><div class="literalblock programlisting"><div class=content><pre>icmp_types = &#34;{ echoreq, unreach }&#34;</pre></div></div><div class=paragraph><p>Since the pass rule already uses that macro, it does not need to be modified to support the new ICMP type:</p></div><div class="literalblock programlisting"><div class=content><pre>pass inet proto icmp all icmp-type $icmp_types keep state</pre></div></div><div class=paragraph><p>PF allows filtering on all variations of ICMP types and codes. The list of possible types and codes are documented in <a href="https://man.freebsd.org/cgi/man.cgi?query=icmp&amp;sektion=4&amp;format=html">icmp(4)</a> and <a href="https://man.freebsd.org/cgi/man.cgi?query=icmp6&amp;sektion=4&amp;format=html">icmp6(4)</a>.</p></div></div></div><div class=sect3><h4 id=pftut-tables>30.3.2.4. 使用 Tables<a class=anchor href=#pftut-tables></a></h4><div class=paragraph><p>Some types of data are relevant to filtering and redirection at a given time, but their definition is too long to be included in the ruleset file. PF supports the use of tables, which are defined lists that can be manipulated without needing to reload the entire ruleset, and which can provide fast lookups. Table names are always enclosed within <code>&lt; ></code>, like this:</p></div><div class="literalblock programlisting"><div class=content><pre>table &lt;clients&gt; { 192.168.2.0/24, !192.168.2.5 }</pre></div></div><div class=paragraph><p>In this example, the <code>192.168.2.0/24</code> network is part of the table, except for the address <code>192.168.2.5</code>, which is excluded using the <code>!</code> operator. It is also possible to load tables from files where each item is on a separate line, as seen in this example <span class=filename>/etc/clients</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>192.168.2.0/24
!192.168.2.5</pre></div></div><div class=paragraph><p>To refer to the file, define the table like this:</p></div><div class="literalblock programlisting"><div class=content><pre>table &lt;clients&gt; persist file &#34;/etc/clients&#34;</pre></div></div><div class=paragraph><p>Once the table is defined, it can be referenced by a rule:</p></div><div class="literalblock programlisting"><div class=content><pre>pass inet proto tcp from &lt;clients&gt; to any port $client_out flags S/SA keep state</pre></div></div><div class=paragraph><p>A table’s contents can be manipulated live, using <code>pfctl</code>. This example adds another network to the table:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pfctl -t clients -T add 192.168.1.0/16</span></code></pre></div></div><div class=paragraph><p>Note that any changes made this way will take affect now, making them ideal for testing, but will not survive a power failure or reboot. To make the changes permanent, modify the definition of the table in the ruleset or edit the file that the table refers to. One can maintain the on-disk copy of the table using a <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a> job which dumps the table’s contents to disk at regular intervals, using a command such as <code>pfctl -t clients -T show >/etc/clients</code>. Alternatively, <span class=filename>/etc/clients</span> can be updated with the in-memory table contents:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pfctl -t clients -T replace -f /etc/clients</span></code></pre></div></div></div><div class=sect3><h4 id=pftut-overload>30.3.2.5. 使用 Overload Tables 保護 SSH<a class=anchor href=#pftut-overload></a></h4><div class=paragraph><p>Those who run SSH on an external interface have probably seen something like this in the authentication logs:</p></div><div class="literalblock programlisting"><div class=content><pre>Sep 26 03:12:34 skapet sshd[25771]: Failed password for root from 200.72.41.31 port 40992 ssh2
Sep 26 03:12:34 skapet sshd[5279]: Failed password for root from 200.72.41.31 port 40992 ssh2
Sep 26 03:12:35 skapet sshd[5279]: Received disconnect from 200.72.41.31: 11: Bye Bye
Sep 26 03:12:44 skapet sshd[29635]: Invalid user admin from 200.72.41.31
Sep 26 03:12:44 skapet sshd[24703]: input_userauth_request: invalid user admin
Sep 26 03:12:44 skapet sshd[24703]: Failed password for invalid user admin from 200.72.41.31 port 41484 ssh2</pre></div></div><div class=paragraph><p>This is indicative of a brute force attack where somebody or some program is trying to discover the user name and password which will let them into the system.</p></div><div class=paragraph><p>If external SSH access is needed for legitimate users, changing the default port used by SSH can offer some protection. However, PF provides a more elegant solution. Pass rules can contain limits on what connecting hosts can do and violators can be banished to a table of addresses which are denied some or all access. It is even possible to drop all existing connections from machines which overreach the limits.</p></div><div class=paragraph><p>To configure this, create this table in the tables section of the ruleset:</p></div><div class="literalblock programlisting"><div class=content><pre>table &lt;bruteforce&gt; persist</pre></div></div><div class=paragraph><p>Then, somewhere early in the ruleset, add rules to block brute access while allowing legitimate access:</p></div><div class="literalblock programlisting"><div class=content><pre>block quick from &lt;bruteforce&gt;
pass inet proto tcp from any to $localnet port $tcp_services \
    flags S/SA keep state \
    (max-src-conn 100, max-src-conn-rate 15/5, \
    overload &lt;bruteforce&gt; flush global)</pre></div></div><div class=paragraph><p>The part in parentheses defines the limits and the numbers should be changed to meet local requirements. It can be read as follows:</p></div><div class=paragraph><p><code>max-src-conn</code> is the number of simultaneous connections allowed from one host.</p></div><div class=paragraph><p><code>max-src-conn-rate</code> is the rate of new connections allowed from any single host (<em>15</em>) per number of seconds (<em>5</em>).</p></div><div class=paragraph><p><code>overload &lt;bruteforce></code> means that any host which exceeds these limits gets its address added to the <code>bruteforce</code> table. The ruleset blocks all traffic from addresses in the <code>bruteforce</code> table.</p></div><div class=paragraph><p>Finally, <code>flush global</code> says that when a host reaches the limit, that all (<code>global</code>) of that host’s connections will be terminated (<code>flush</code>).</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>These rules will <em>not</em> block slow bruteforcers, as described in <a href=http://home.nuug.no/~peter/hailmary2013/>http://home.nuug.no/~peter/hailmary2013/</a>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>This example ruleset is intended mainly as an illustration. For example, if a generous number of connections in general are wanted, but the desire is to be more restrictive when it comes to ssh, supplement the rule above with something like the one below, early on in the rule set:</p></div><div class="literalblock programlisting"><div class=content><pre>pass quick proto { tcp, udp } from any to any port ssh \
    flags S/SA keep state \
    (max-src-conn 15, max-src-conn-rate 5/3, \
    overload &lt;bruteforce&gt; flush global)</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=title>It May Not be Necessary to Block All Overloaders</div><div class=paragraph><p>It is worth noting that the overload mechanism is a general technique which does not apply exclusively to SSH, and it is not always optimal to entirely block all traffic from offenders.</p></div><div class=paragraph><p>For example, an overload rule could be used to protect a mail service or a web service, and the overload table could be used in a rule to assign offenders to a queue with a minimal bandwidth allocation or to redirect to a specific web page.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Over time, tables will be filled by overload rules and their size will grow incrementally, taking up more memory. Sometimes an IP address that is blocked is a dynamically assigned one, which has since been assigned to a host who has a legitimate reason to communicate with hosts in the local network.</p></div><div class=paragraph><p>For situations like these, pfctl provides the ability to expire table entries. For example, this command will remove <code>&lt;bruteforce></code> table entries which have not been referenced for <code>86400</code> seconds:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pfctl -t bruteforce -T expire 86400</span></code></pre></div></div><div class=paragraph><p>Similar functionality is provided by <a class=package href=https://cgit.freebsd.org/ports/tree/security/expiretable/>security/expiretable</a>, which removes table entries which have not been accessed for a specified period of time.</p></div><div class=paragraph><p>Once installed, expiretable can be run to remove <code>&lt;bruteforce></code> table entries older than a specified age. This example removes all entries older than 24 hours:</p></div><div class="literalblock programlisting"><div class=content><pre>/usr/local/sbin/expiretable -v -d -t 24h bruteforce</pre></div></div></div><div class=sect3><h4 id=pftut-spamd>30.3.2.6. SPAM 防護<a class=anchor href=#pftut-spamd></a></h4><div class=paragraph><p>Not to be confused with the spamd daemon which comes bundled with spamassassin, <a class=package href=https://cgit.freebsd.org/ports/tree/mail/spamd/>mail/spamd</a> can be configured with PF to provide an outer defense against SPAM. This spamd hooks into the PF configuration using a set of redirections.</p></div><div class=paragraph><p>Spammers tend to send a large number of messages, and SPAM is mainly sent from a few spammer friendly networks and a large number of hijacked machines, both of which are reported to <em>blacklists</em> fairly quickly.</p></div><div class=paragraph><p>When an SMTP connection from an address in a blacklist is received, spamd presents its banner and immediately switches to a mode where it answers SMTP traffic one byte at a time. This technique, which is intended to waste as much time as possible on the spammer’s end, is called <em>tarpitting</em>. The specific implementation which uses one byte SMTP replies is often referred to as <em>stuttering</em>.</p></div><div class=paragraph><p>This example demonstrates the basic procedure for setting up spamd with automatically updated blacklists. Refer to the man pages which are installed with <a class=package href=https://cgit.freebsd.org/ports/tree/mail/spamd/>mail/spamd</a> for more information.</p></div><div class="exampleblock procedure"><div class=content><div class=paragraph><p><strong>Procedure: Configuring spamd</strong></p></div><div class="olist arabic"><ol class=arabic><li><p>Install the <a class=package href=https://cgit.freebsd.org/ports/tree/mail/spamd/>mail/spamd</a> package or port. To use spamd’s greylisting features, <a href="https://man.freebsd.org/cgi/man.cgi?query=fdescfs&amp;sektion=5&amp;format=html">fdescfs(5)</a> must be mounted at <span class=filename>/dev/fd</span>. Add the following line to <span class=filename>/etc/fstab</span>:</p><div class="literalblock programlisting"><div class=content><pre> fdescfs /dev/fd fdescfs rw 0 0</pre></div></div><div class=paragraph><p>Then, mount the filesystem:</p></div><div class="literalblock programlisting"><div class=content><pre># mount fdescfs</pre></div></div></li><li><p>Next, edit the PF ruleset to include:</p><div class="literalblock programlisting"><div class=content><pre>table &lt;spamd&gt; persist
table &lt;spamd-white&gt; persist
rdr pass on $ext_if inet proto tcp from &lt;spamd&gt; to \
    { $ext_if, $localnet } port smtp -&gt; 127.0.0.1 port 8025
rdr pass on $ext_if inet proto tcp from !&lt;spamd-white&gt; to \
    { $ext_if, $localnet } port smtp -&gt; 127.0.0.1 port 8025</pre></div></div><div class=paragraph><p>The two tables <code>&lt;spamd></code> and <code>&lt;spamd-white></code> are essential. SMTP traffic from an address listed in <code>&lt;spamd></code> but not in <code>&lt;spamd-white></code> is redirected to the spamd daemon listening at port 8025.</p></div></li><li><p>The next step is to configure spamd in <span class=filename>/usr/local/etc/spamd.conf</span> and to add some <span class=filename>rc.conf</span> parameters.</p><div class=paragraph><p>The installation of <a class=package href=https://cgit.freebsd.org/ports/tree/mail/spamd/>mail/spamd</a> includes a sample configuration file (<span class=filename>/usr/local/etc/spamd.conf.sample</span>) and a man page for <span class=filename>spamd.conf</span>. Refer to these for additional configuration options beyond those shown in this example.</p></div><div class=paragraph><p>One of the first lines in the configuration file that does not begin with a <code>#</code> comment sign contains the block which defines the <code>all</code> list, which specifies the lists to use:</p></div><div class="literalblock programlisting"><div class=content><pre>all:\
    :traplist:whitelist:</pre></div></div><div class=paragraph><p>This entry adds the desired blacklists, separated by colons (<code>:</code>). To use a whitelist to subtract addresses from a blacklist, add the name of the whitelist <em>immediately</em> after the name of that blacklist. For example: <code>:blacklist:whitelist:</code>.</p></div><div class=paragraph><p>This is followed by the specified blacklist’s definition:</p></div><div class="literalblock programlisting"><div class=content><pre>traplist:\
    :black:\
    :msg=&#34;SPAM. Your address %A has sent spam within the last 24 hours&#34;:\
    :method=http:\
    :file=www.openbsd.org/spamd/traplist.gz</pre></div></div><div class=paragraph><p>where the first line is the name of the blacklist and the second line specifies the list type. The <code>msg</code> field contains the message to display to blacklisted senders during the SMTP dialogue. The <code>method</code> field specifies how spamd-setup fetches the list data; supported methods are <code>http</code>, <code>ftp</code>, from a <code>file</code> in a mounted file system, and via <code>exec</code> of an external program. Finally, the <code>file</code> field specifies the name of the file spamd expects to receive.</p></div><div class=paragraph><p>The definition of the specified whitelist is similar, but omits the <code>msg</code> field since a message is not needed:</p></div><div class="literalblock programlisting"><div class=content><pre>whitelist:\
    :white:\
    :method=file:\
    :file=/var/mail/whitelist.txt</pre></div></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=title>Choose Data Sources with Care</div><div class=paragraph><p>Using all the blacklists in the sample <span class=filename>spamd.conf</span> will blacklist large blocks of the Internet. Administrators need to edit the file to create an optimal configuration which uses applicable data sources and, when necessary, uses custom lists.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Next, add this entry to <span class=filename>/etc/rc.conf</span>. Additional flags are described in the man page specified by the comment:</p></div><div class="literalblock programlisting"><div class=content><pre>spamd_flags=&#34;-v&#34; # use &#34;&#34; and see spamd-setup(8) for flags</pre></div></div><div class=paragraph><p>When finished, reload the ruleset, start spamd by typing <code>service obspamd start</code>, and complete the configuration using <code>spamd-setup</code>. Finally, create a <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a> job which calls <code>spamd-setup</code> to update the tables at reasonable intervals.</p></div></li></ol></div></div></div><div class=paragraph><p>On a typical gateway in front of a mail server, hosts will soon start getting trapped within a few seconds to several minutes.</p></div><div class=paragraph><p>PF also supports <em>greylisting</em>, which temporarily rejects messages from unknown hosts with <em>45n</em> codes. Messages from greylisted hosts which try again within a reasonable time are let through. Traffic from senders which are set up to behave within the limits set by RFC 1123 and RFC 2821 are immediately let through.</p></div><div class=paragraph><p>More information about greylisting as a technique can be found at the <a href=http://www.greylisting.org/>greylisting.org</a> web site. The most amazing thing about greylisting, apart from its simplicity, is that it still works. Spammers and malware writers have been very slow to adapt to bypass this technique.</p></div><div class=paragraph><p>The basic procedure for configuring greylisting is as follows:</p></div><div class="exampleblock procedure"><div class=content><div class=paragraph><p><strong>Procedure: Configuring Greylisting</strong></p></div><div class="olist arabic"><ol class=arabic><li><p>Make sure that <a href="https://man.freebsd.org/cgi/man.cgi?query=fdescfs&amp;sektion=5&amp;format=html">fdescfs(5)</a> is mounted as described in Step 1 of the previous Procedure.</p></li><li><p>To run spamd in greylisting mode, add this line to <span class=filename>/etc/rc.conf</span>:</p><div class="literalblock programlisting"><div class=content><pre>spamd_grey=&#34;YES&#34;  # use spamd greylisting if YES</pre></div></div><div class=paragraph><p>Refer to the spamd man page for descriptions of additional related parameters.</p></div></li><li><p>To complete the greylisting setup:</p><div class="literalblock programlisting"><div class=content><pre># service obspamd restart
# service obspamlogd start</pre></div></div></li></ol></div></div></div><div class=paragraph><p>Behind the scenes, the spamdb database tool and the spamlogd whitelist updater perform essential functions for the greylisting feature. spamdb is the administrator’s main interface to managing the black, grey, and white lists via the contents of the <span class=filename>/var/db/spamdb</span> database.</p></div></div><div class=sect3><h4 id=pftut-hygiene>30.3.2.7. 網路保健<a class=anchor href=#pftut-hygiene></a></h4><div class=paragraph><p>This section describes how <code>block-policy</code>, <code>scrub</code>, and <code>antispoof</code> can be used to make the ruleset behave sanely.</p></div><div class=paragraph><p>The <code>block-policy</code> is an option which can be set in the <code>options</code> part of the ruleset, which precedes the redirection and filtering rules. This option determines which feedback, if any, PF sends to hosts that are blocked by a rule. The option has two possible values: <code>drop</code> drops blocked packets with no feedback, and <code>return</code> returns a status code such as <code>Connection refused</code>.</p></div><div class=paragraph><p>If not set, the default policy is <code>drop</code>. To change the <code>block-policy</code>, specify the desired value:</p></div><div class="literalblock programlisting"><div class=content><pre>set block-policy return</pre></div></div><div class=paragraph><p>In PF, <code>scrub</code> is a keyword which enables network packet normalization. This process reassembles fragmented packets and drops TCP packets that have invalid flag combinations. Enabling <code>scrub</code> provides a measure of protection against certain kinds of attacks based on incorrect handling of packet fragments. A number of options are available, but the simplest form is suitable for most configurations:</p></div><div class="literalblock programlisting"><div class=content><pre>scrub in all</pre></div></div><div class=paragraph><p>Some services, such as NFS, require specific fragment handling options. Refer to <a href=https://home.nuug.no/~peter/pf/en/scrub.html>https://home.nuug.no/~peter/pf/en/scrub.html</a> for more information.</p></div><div class=paragraph><p>This example reassembles fragments, clears the "do not fragment" bit, and sets the maximum segment size to 1440 bytes:</p></div><div class="literalblock programlisting"><div class=content><pre>scrub in all fragment reassemble no-df max-mss 1440</pre></div></div><div class=paragraph><p>The <code>antispoof</code> mechanism protects against activity from spoofed or forged IP addresses, mainly by blocking packets appearing on interfaces and in directions which are logically not possible.</p></div><div class=paragraph><p>These rules weed out spoofed traffic coming in from the rest of the world as well as any spoofed packets which originate in the local network:</p></div><div class="literalblock programlisting"><div class=content><pre>antispoof for $ext_if
antispoof for $int_if</pre></div></div></div><div class=sect3><h4 id=pftut-unrouteables>30.3.2.8. 處理不可路由 (Non-Routable) 的位址<a class=anchor href=#pftut-unrouteables></a></h4><div class=paragraph><p>Even with a properly configured gateway to handle network address translation, one may have to compensate for other people’s misconfigurations. A common misconfiguration is to let traffic with non-routable addresses out to the Internet. Since traffic from non-routeable addresses can play a part in several DoS attack techniques, consider explicitly blocking traffic from non-routeable addresses from entering the network through the external interface.</p></div><div class=paragraph><p>In this example, a macro containing non-routable addresses is defined, then used in blocking rules. Traffic to and from these addresses is quietly dropped on the gateway’s external interface.</p></div><div class="literalblock programlisting"><div class=content><pre>martians = &#34;{ 127.0.0.0/8, 192.168.0.0/16, 172.16.0.0/12, \
	      10.0.0.0/8, 169.254.0.0/16, 192.0.2.0/24, \
	      0.0.0.0/8, 240.0.0.0/4 }&#34;

block drop in quick on $ext_if from $martians to any
block drop out quick on $ext_if from any to $martians</pre></div></div></div></div><div class=sect2><h3 id=_開啟_altq>30.3.3. 開啟 ALTQ<a class=anchor href=#_開啟_altq></a></h3><div class=paragraph><p>On FreeBSD, ALTQ can be used with PF to provide Quality of Service (QOS). Once ALTQ is enabled, queues can be defined in the ruleset which determine the processing priority of outbound packets.</p></div><div class=paragraph><p>Before enabling ALTQ, refer to <a href="https://man.freebsd.org/cgi/man.cgi?query=altq&amp;sektion=4&amp;format=html">altq(4)</a> to determine if the drivers for the network cards installed on the system support it.</p></div><div class=paragraph><p>ALTQ is not available as a loadable kernel module. If the system’s interfaces support ALTQ, create a custom kernel using the instructions in <a href=../kernelconfig/#kernelconfig>設定 FreeBSD 核心</a>. The following kernel options are available. The first is needed to enable ALTQ. At least one of the other options is necessary to specify the queueing scheduler algorithm:</p></div><div class="literalblock programlisting"><div class=content><pre>options         ALTQ
options         ALTQ_CBQ        # Class Based Queuing (CBQ)
options         ALTQ_RED        # Random Early Detection (RED)
options         ALTQ_RIO        # RED In/Out
options         ALTQ_HFSC       # Hierarchical Packet Scheduler (HFSC)
options         ALTQ_PRIQ       # Priority Queuing (PRIQ)</pre></div></div><div class=paragraph><p>The following scheduler algorithms are available:</p></div><div class=dlist><dl><dt class=hdlist1>CBQ</dt><dd><p>Class Based Queuing (CBQ) is used to divide a connection’s bandwidth into different classes or queues to prioritize traffic based on filter rules.</p></dd><dt class=hdlist1>RED</dt><dd><p>Random Early Detection (RED) is used to avoid network congestion by measuring the length of the queue and comparing it to the minimum and maximum thresholds for the queue. When the queue is over the maximum, all new packets are randomly dropped.</p></dd><dt class=hdlist1>RIO</dt><dd><p>In Random Early Detection In and Out (RIO) mode, RED maintains multiple average queue lengths and multiple threshold values, one for each QOS level.</p></dd><dt class=hdlist1>HFSC</dt><dd><p>Hierarchical Fair Service Curve Packet Scheduler (HFSC) is described in <a href=http://www-2.cs.cmu.edu/~hzhang/HFSC/main.html>http://www-2.cs.cmu.edu/~hzhang/HFSC/main.html</a>.</p></dd><dt class=hdlist1>PRIQ</dt><dd><p>Priority Queuing (PRIQ) always passes traffic that is in a higher queue first.</p></dd></dl></div><div class=paragraph><p>More information about the scheduling algorithms and example rulesets are available at the <a href=https://web.archive.org/web/20151109213426/http://www.openbsd.org/faq/pf/queueing.html>OpenBSD’s web archive</a>.</p></div></div></div></div><div class=sect1><h2 id=firewalls-ipfw>30.4. IPFW<a class=anchor href=#firewalls-ipfw></a></h2><div class=sectionbody><div class=paragraph><p>IPFW 是一套專為 FreeBSD 所寫的具狀態防火牆 (Stateful firewall)，它同時支援 IPv4 與 IPv6，它由數個元件組成：核心防火牆過濾規則處理器與其整合的封包計帳設施、記錄設施、NAT、<a href="https://man.freebsd.org/cgi/man.cgi?query=dummynet&amp;sektion=4&amp;format=html">dummynet(4)</a> 流量限制程式、轉送設施、橋接設施以及 ipstealth 設施。</p></div><div class=paragraph><p>FreeBSD 提供一個範本規則集於 <span class=filename>/etc/rc.firewall</span>，其定義了幾個常見情境會使用的防火牆類型來協助初學的使用者撰寫合適的規則集。IPFW 提供了強大的語法讓進階的使用者可以用來自訂符合環境安全性要求的規則集。</p></div><div class=paragraph><p>本節將介紹如何開啟 IPFW、規則語法的概要以及示範幾種常見情境所使用的規則集。</p></div><div class=sect2><h3 id=firewalls-ipfw-enable>30.4.1. 開啟 IPFW<a class=anchor href=#firewalls-ipfw-enable></a></h3><div class=paragraph><p>IPFW is included in the basic FreeBSD install as a kernel loadable module, meaning that a custom kernel is not needed in order to enable IPFW.</p></div><div class=paragraph><p>For those users who wish to statically compile IPFW support into a custom kernel, see <a href=#firewalls-ipfw-kernelconfig>IPFW 核心選項</a>.</p></div><div class=paragraph><p>To configure the system to enable IPFW at boot time, add <code>firewall_enable="YES"</code> to <span class=filename>/etc/rc.conf</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysrc firewall_enable=&#34;YES&#34;</span></code></pre></div></div><div class=paragraph><p>To use one of the default firewall types provided by FreeBSD, add another line which specifies the type:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysrc firewall_type=&#34;open&#34;</span></code></pre></div></div><div class=paragraph><p>The available types are:</p></div><div class=ulist><ul><li><p><code>open</code>: passes all traffic.</p></li><li><p><code>client</code>: protects only this machine.</p></li><li><p><code>simple</code>: protects the whole network.</p></li><li><p><code>closed</code>: entirely disables IP traffic except for the loopback interface.</p></li><li><p><code>workstation</code>: protects only this machine using stateful rules.</p></li><li><p><code>UNKNOWN</code>: disables the loading of firewall rules.</p></li><li><p><span class=filename>filename</span>: full path of the file containing the firewall ruleset.</p></li></ul></div><div class=paragraph><p>If <code>firewall_type</code> is set to either <code>client</code> or <code>simple</code>, modify the default rules found in <span class=filename>/etc/rc.firewall</span> to fit the configuration of the system.</p></div><div class=paragraph><p>Note that the <code>filename</code> type is used to load a custom ruleset.</p></div><div class=paragraph><p>An alternate way to load a custom ruleset is to set the <code>firewall_script</code> variable to the absolute path of an <em>executable script</em> that includes IPFW commands. The examples used in this section assume that the <code>firewall_script</code> is set to <span class=filename>/etc/ipfw.rules</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysrc firewall_script=&#34;/etc/ipfw.rules&#34;</span></code></pre></div></div><div class=paragraph><p>To enable logging through <a href="https://man.freebsd.org/cgi/man.cgi?query=syslogd&amp;sektion=8&amp;format=html">syslogd(8)</a>, include this line:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysrc firewall_logging=&#34;YES&#34;</span></code></pre></div></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Only firewall rules with the <code>log</code> option will be logged. The default rules do not include this option and it must be manually added. Therefore it is advisable that the default ruleset is edited for logging. In addition, log rotation may be desired if the logs are stored in a separate file.</p></div></td></tr></tbody></table></div><div class=paragraph><p>There is no <span class=filename>/etc/rc.conf</span> variable to set logging limits. To limit the number of times a rule is logged per connection attempt, specify the number using this line in <span class=filename>/etc/sysctl.conf</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># echo &#34;net.inet.ip.fw.verbose_limit=5&#34; &gt;&gt; /etc/sysctl.conf</span></code></pre></div></div><div class=paragraph><p>To enable logging through a dedicated interface named <code>ipfw0</code>, add this line to <span class=filename>/etc/rc.conf</span> instead:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysrc firewall_logif=&#34;YES&#34;</span></code></pre></div></div><div class=paragraph><p>Then use tcpdump to see what is being logged:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># tcpdump -t -n -i ipfw0</span></code></pre></div></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>There is no overhead due to logging unless tcpdump is attached.</p></div></td></tr></tbody></table></div><div class=paragraph><p>After saving the needed edits, start the firewall. To enable logging limits now, also set the <code>sysctl</code> value specified above:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service ipfw start</span>
<span class=c># sysctl net.inet.ip.fw.verbose_limit=5</span></code></pre></div></div></div><div class=sect2><h3 id=firewalls-ipfw-rules>30.4.2. IPFW 規則語法<a class=anchor href=#firewalls-ipfw-rules></a></h3><div class=paragraph><p>When a packet enters the IPFW firewall, it is compared against the first rule in the ruleset and progresses one rule at a time, moving from top to bottom in sequence. When the packet matches the selection parameters of a rule, the rule’s action is executed and the search of the ruleset terminates for that packet. This is referred to as "first match wins". If the packet does not match any of the rules, it gets caught by the mandatory IPFW default rule number 65535, which denies all packets and silently discards them. However, if the packet matches a rule that contains the <code>count</code>, <code>skipto</code>, or <code>tee</code> keywords, the search continues. Refer to <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfw&amp;sektion=8&amp;format=html">ipfw(8)</a> for details on how these keywords affect rule processing.</p></div><div class=paragraph><p>When creating an IPFW rule, keywords must be written in the following order. Some keywords are mandatory while other keywords are optional. The words shown in uppercase represent a variable and the words shown in lowercase must precede the variable that follows it. The <code>#</code> symbol is used to mark the start of a comment and may appear at the end of a rule or on its own line. Blank lines are ignored.</p></div><div class=paragraph><p><em>CMD RULE_NUMBER set SET_NUMBER ACTION log LOG_AMOUNT PROTO from SRC SRC_PORT to DST DST_PORT OPTIONS</em></p></div><div class=paragraph><p>This section provides an overview of these keywords and their options. It is not an exhaustive list of every possible option. Refer to <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfw&amp;sektion=8&amp;format=html">ipfw(8)</a> for a complete description of the rule syntax that can be used when creating IPFW rules.</p></div><div class=dlist><dl><dt class=hdlist1>CMD</dt><dd><p>Every rule must start with <span class=parameter>ipfw add</span>.</p></dd><dt class=hdlist1>RULE_NUMBER</dt><dd><p>Each rule is associated with a number from <code>1</code> to <code>65534</code>. The number is used to indicate the order of rule processing. Multiple rules can have the same number, in which case they are applied according to the order in which they have been added.</p></dd><dt class=hdlist1>SET_NUMBER</dt><dd><p>Each rule is associated with a set number from <code>0</code> to <code>31</code>. Sets can be individually disabled or enabled, making it possible to quickly add or delete a set of rules. If a SET_NUMBER is not specified, the rule will be added to set <code>0</code>.</p></dd><dt class=hdlist1>ACTION</dt><dd><p>A rule can be associated with one of the following actions. The specified action will be executed when the packet matches the selection criterion of the rule.</p><div class=paragraph><p><span class=parameter>allow | accept | pass | permit</span>: these keywords are equivalent and allow packets that match the rule.</p></div><div class=paragraph><p><span class=parameter>check-state</span>: checks the packet against the dynamic state table. If a match is found, execute the action associated with the rule which generated this dynamic rule, otherwise move to the next rule. A <code>check-state</code> rule does not have selection criterion. If no <code>check-state</code> rule is present in the ruleset, the dynamic rules table is checked at the first <code>keep-state</code> or <code>limit</code> rule.</p></div><div class=paragraph><p><span class=parameter>count</span>: updates counters for all packets that match the rule. The search continues with the next rule.</p></div><div class=paragraph><p><span class=parameter>deny | drop</span>: either word silently discards packets that match this rule.</p></div><div class=paragraph><p>Additional actions are available. Refer to <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfw&amp;sektion=8&amp;format=html">ipfw(8)</a> for details.</p></div></dd><dt class=hdlist1>LOG_AMOUNT</dt><dd><p>When a packet matches a rule with the <code>log</code> keyword, a message will be logged to <a href="https://man.freebsd.org/cgi/man.cgi?query=syslogd&amp;sektion=8&amp;format=html">syslogd(8)</a> with a facility name of <code>SECURITY</code>. Logging only occurs if the number of packets logged for that particular rule does not exceed a specified LOG_AMOUNT. If no LOG_AMOUNT is specified, the limit is taken from the value of <code>net.inet.ip.fw.verbose_limit</code>. A value of zero removes the logging limit. Once the limit is reached, logging can be re-enabled by clearing the logging counter or the packet counter for that rule, using <code>ipfw resetlog</code>.</p><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Logging is done after all other packet matching conditions have been met, and before performing the final action on the packet. The administrator decides which rules to enable logging on.</p></div></td></tr></tbody></table></div></dd><dt class=hdlist1>PROTO</dt><dd><p>This optional value can be used to specify any protocol name or number found in <span class=filename>/etc/protocols</span>.</p></dd><dt class=hdlist1>SRC</dt><dd><p>The <code>from</code> keyword must be followed by the source address or a keyword that represents the source address. An address can be represented by <code>any</code>, <code>me</code> (any address configured on an interface on this system), <code>me6</code>, (any IPv6 address configured on an interface on this system), or <code>table</code> followed by the number of a lookup table which contains a list of addresses. When specifying an IP address, it can be optionally followed by its CIDR mask or subnet mask. For example, <code>1.2.3.4/25</code> or <code>1.2.3.4:255.255.255.128</code>.</p></dd><dt class=hdlist1>SRC_PORT</dt><dd><p>An optional source port can be specified using the port number or name from <span class=filename>/etc/services</span>.</p></dd><dt class=hdlist1>DST</dt><dd><p>The <code>to</code> keyword must be followed by the destination address or a keyword that represents the destination address. The same keywords and addresses described in the SRC section can be used to describe the destination.</p></dd><dt class=hdlist1>DST_PORT</dt><dd><p>An optional destination port can be specified using the port number or name from <span class=filename>/etc/services</span>.</p></dd><dt class=hdlist1>OPTIONS</dt><dd><p>Several keywords can follow the source and destination. As the name suggests, OPTIONS are optional. Commonly used options include <code>in</code> or <code>out</code>, which specify the direction of packet flow, <code>icmptypes</code> followed by the type of ICMP message, and <code>keep-state</code>.</p><div class=paragraph><p>When a <span class=parameter>keep-state</span> rule is matched, the firewall will create a dynamic rule which matches bidirectional traffic between the source and destination addresses and ports using the same protocol.</p></div><div class=paragraph><p>The dynamic rules facility is vulnerable to resource depletion from a SYN-flood attack which would open a huge number of dynamic rules. To counter this type of attack with IPFW, use <code>limit</code>. This option limits the number of simultaneous sessions by checking the open dynamic rules, counting the number of times this rule and IP address combination occurred. If this count is greater than the value specified by <code>limit</code>, the packet is discarded.</p></div><div class=paragraph><p>Dozens of OPTIONS are available. Refer to <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfw&amp;sektion=8&amp;format=html">ipfw(8)</a> for a description of each available option.</p></div></dd></dl></div></div><div class=sect2><h3 id=_範例規則集>30.4.3. 範例規則集<a class=anchor href=#_範例規則集></a></h3><div class=paragraph><p>This section demonstrates how to create an example stateful firewall ruleset script named <span class=filename>/etc/ipfw.rules</span>. In this example, all connection rules use <code>in</code> or <code>out</code> to clarify the direction. They also use <code>via</code> <em>interface-name</em> to specify the interface the packet is traveling over.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>When first creating or testing a firewall ruleset, consider temporarily setting this tunable:</p></div><div class="literalblock programlisting"><div class=content><pre>net.inet.ip.fw.default_to_accept=&#34;1&#34;</pre></div></div><div class=paragraph><p>This sets the default policy of <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfw&amp;sektion=8&amp;format=html">ipfw(8)</a> to be more permissive than the default <code>deny ip from any to any</code>, making it slightly more difficult to get locked out of the system right after a reboot.</p></div></td></tr></tbody></table></div><div class=paragraph><p>The firewall script begins by indicating that it is a Bourne shell script and flushes any existing rules. It then creates the <code>cmd</code> variable so that <code>ipfw add</code> does not have to be typed at the beginning of every rule. It also defines the <code>pif</code> variable which represents the name of the interface that is attached to the Internet.</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
# Flush out the list before we begin.
ipfw -q -f flush

# Set rules command prefix
cmd=&#34;ipfw -q add&#34;
pif=&#34;dc0&#34;     # interface name of NIC attached to Internet</pre></div></div><div class=paragraph><p>The first two rules allow all traffic on the trusted internal interface and on the loopback interface:</p></div><div class="literalblock programlisting"><div class=content><pre># Change xl0 to LAN NIC interface name
$cmd 00005 allow all from any to any via xl0

# No restrictions on Loopback Interface
$cmd 00010 allow all from any to any via lo0</pre></div></div><div class=paragraph><p>The next rule allows the packet through if it matches an existing entry in the dynamic rules table:</p></div><div class="literalblock programlisting"><div class=content><pre>$cmd 00101 check-state</pre></div></div><div class=paragraph><p>The next set of rules defines which stateful connections internal systems can create to hosts on the Internet:</p></div><div class="literalblock programlisting"><div class=content><pre># Allow access to public DNS
# Replace x.x.x.x with the IP address of a public DNS server
# and repeat for each DNS server in /etc/resolv.conf
$cmd 00110 allow tcp from any to x.x.x.x 53 out via $pif setup keep-state
$cmd 00111 allow udp from any to x.x.x.x 53 out via $pif keep-state

# Allow access to ISP&#39;s DHCP server for cable/DSL configurations.
# Use the first rule and check log for IP address.
# Then, uncomment the second rule, input the IP address, and delete the first rule
$cmd 00120 allow log udp from any to any 67 out via $pif keep-state
#$cmd 00120 allow udp from any to x.x.x.x 67 out via $pif keep-state

# Allow outbound HTTP and HTTPS connections
$cmd 00200 allow tcp from any to any 80 out via $pif setup keep-state
$cmd 00220 allow tcp from any to any 443 out via $pif setup keep-state

# Allow outbound email connections
$cmd 00230 allow tcp from any to any 25 out via $pif setup keep-state
$cmd 00231 allow tcp from any to any 110 out via $pif setup keep-state

# Allow outbound ping
$cmd 00250 allow icmp from any to any out via $pif keep-state

# Allow outbound NTP
$cmd 00260 allow udp from any to any 123 out via $pif keep-state

# Allow outbound SSH
$cmd 00280 allow tcp from any to any 22 out via $pif setup keep-state

# deny and log all other outbound connections
$cmd 00299 deny log all from any to any out via $pif</pre></div></div><div class=paragraph><p>The next set of rules controls connections from Internet hosts to the internal network. It starts by denying packets typically associated with attacks and then explicitly allows specific types of connections. All the authorized services that originate from the Internet use <code>limit</code> to prevent flooding.</p></div><div class="literalblock programlisting"><div class=content><pre># Deny all inbound traffic from non-routable reserved address spaces
$cmd 00300 deny all from 192.168.0.0/16 to any in via $pif     #RFC 1918 private IP
$cmd 00301 deny all from 172.16.0.0/12 to any in via $pif      #RFC 1918 private IP
$cmd 00302 deny all from 10.0.0.0/8 to any in via $pif         #RFC 1918 private IP
$cmd 00303 deny all from 127.0.0.0/8 to any in via $pif        #loopback
$cmd 00304 deny all from 0.0.0.0/8 to any in via $pif          #loopback
$cmd 00305 deny all from 169.254.0.0/16 to any in via $pif     #DHCP auto-config
$cmd 00306 deny all from 192.0.2.0/24 to any in via $pif       #reserved for docs
$cmd 00307 deny all from 204.152.64.0/23 to any in via $pif    #Sun cluster interconnect
$cmd 00308 deny all from 224.0.0.0/3 to any in via $pif        #Class D &amp; E multicast

# Deny public pings
$cmd 00310 deny icmp from any to any in via $pif

# Deny ident
$cmd 00315 deny tcp from any to any 113 in via $pif

# Deny all Netbios services.
$cmd 00320 deny tcp from any to any 137 in via $pif
$cmd 00321 deny tcp from any to any 138 in via $pif
$cmd 00322 deny tcp from any to any 139 in via $pif
$cmd 00323 deny tcp from any to any 81 in via $pif

# Deny fragments
$cmd 00330 deny all from any to any frag in via $pif

# Deny ACK packets that did not match the dynamic rule table
$cmd 00332 deny tcp from any to any established in via $pif

# Allow traffic from ISP&#39;s DHCP server.
# Replace x.x.x.x with the same IP address used in rule 00120.
#$cmd 00360 allow udp from any to x.x.x.x 67 in via $pif keep-state

# Allow HTTP connections to internal web server
$cmd 00400 allow tcp from any to me 80 in via $pif setup limit src-addr 2

# Allow inbound SSH connections
$cmd 00410 allow tcp from any to me 22 in via $pif setup limit src-addr 2

# Reject and log all other incoming connections
$cmd 00499 deny log all from any to any in via $pif</pre></div></div><div class=paragraph><p>The last rule logs all packets that do not match any of the rules in the ruleset:</p></div><div class="literalblock programlisting"><div class=content><pre># Everything else is denied and logged
$cmd 00999 deny log all from any to any</pre></div></div></div><div class=sect2><h3 id=in-kernel-nat>30.4.4. 核心內 NAT<a class=anchor href=#in-kernel-nat></a></h3><div class=paragraph><p>FreeBSD’s IPFW firewall has two implementations of NAT: one being the userland <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> daemon, and the more recent IPFW’s built-in NAT facility also known as in-kernel NAT. Both work in conjunction with IPFW to provide network address translation. This can be used to provide an Internet Connection Sharing solution so that several internal computers can connect to the Internet using a single public IP address.</p></div><div class=paragraph><p>To do this, the FreeBSD machine connected to the Internet must act as a gateway. This system must have two NICs, where one is connected to the Internet and the other is connected to the internal LAN. Each machine connected to the LAN should be assigned an IP address in the private network space, as defined by <a href=https://www.ietf.org/rfc/rfc1918.txt>RFC 1918</a>.</p></div><div class=paragraph><p>Some additional configuration is needed in order to enable the in-kernel NAT function of IPFW. To enable in-kernel NAT support at boot time, the following must be set in <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>gateway_enable=&#34;YES&#34;
firewall_enable=&#34;YES&#34;
firewall_nat_enable=&#34;YES&#34;</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>When <code>firewall_enable</code> is not set, but <code>firewall_nat_enable</code> is, it will have no effect and do nothing, because the in-kernel NAT implementation is only compatible with IPFW.</p></div></td></tr></tbody></table></div><div class=paragraph><p>When the ruleset contains stateful rules, the positioning of the NAT rule is critical and the <code>skipto</code> action is used. The <code>skipto</code> action requires a rule number so that it knows which rule to jump to. Furthermore, because of the architecture of <a href="https://man.freebsd.org/cgi/man.cgi?query=libalias&amp;sektion=3&amp;format=html">libalias(3)</a>, a library implemented as a kernel module used for the in-kernel NAT facility of IPFW, it is necessary to disable TCP segmentation offloading, or in short TSO. TSO can be disabled on a per network interface basis by using <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a> or on a system wide basis using <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a>. To disable TSO system wide, the following must be set in <span class=filename>/etc/sysctl.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>net.inet.tcp.tso=&#34;0&#34;</pre></div></div><div class=paragraph><p>The example below builds upon the firewall ruleset shown in the previous section. It adds some additional entries and modifies some existing rules in order to configure the firewall for in-kernel NAT. It starts by adding some additional variables which represent the rule number to skip to, the <code>keep-state</code> option, and a list of TCP ports which will be used to reduce the number of rules.</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
ipfw -q -f flush
cmd=&#34;ipfw -q add&#34;
skip=&#34;skipto 1000&#34;
pif=dc0
ks=&#34;keep-state&#34;
good_tcpo=&#34;22,25,37,53,80,443,110&#34;</pre></div></div><div class=paragraph><p>A NAT instance will also be configured. With in-kernel NAT it is possible to have multiple NAT instances each with their own configuration. Although, for this example only one NAT instance is needed; NAT instance number 1. The configuration takes a few arguments and flags such as: <code>if</code> which indicates the public interface, <code>same_ports</code> which takes care that alliased ports and local port numbers are mapped the same, <code>unreg_only</code> will result in only unregistered (private) address spaces to be processed by the NAT instance, and <code>reset</code> which will help to keep a functioning NAT instance even when the public IP address of the IPFW machine changes. For all possible options that can be passed to a single NAT instance configuration consult <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfw&amp;sektion=8&amp;format=html">ipfw(8)</a>. Furthermore, because of the nature of a stateful NATing firewall, it is neseccary to allow translated packets to be reinjected in the firewall for further processing, this can be achieved by disabling <code>one_pass</code> behavior at the start of the firewall script.</p></div><div class="literalblock programlisting"><div class=content><pre>ipfw disable one_pass
ipfw -q nat 1 config if $pif same_ports unreg_only reset</pre></div></div><div class=paragraph><p>The inbound NAT rule is inserted <em>after</em> the two rules which allow all traffic on the trusted and loopback interfaces and after the reassamble rule but <em>before</em> the <code>check-state</code> rule. It is important that the rule number selected for this NAT rule, in this example <code>100</code>, is higher than the first three rules and lower than the <code>check-state</code> rule. Furthermore, because of the behavior of in-kernel NAT it is advised to place a reassamble rule just before the first NAT rule and after the rules that allow traffic on trusted interface. Normally, IP fragmentation should not happen, but when dealing with IPSEC/ESP/GRE tunneling traffic it might and the reassmabling of fragments is necessary before handing the complete packet over to the in-kernel NAT engine.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>The reassemble rule was not needed with userland <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> because the internal workings of the IPFW <code>divert</code> action already takes care of this automatically as also stated in <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfw&amp;sektion=8&amp;format=html">ipfw(8)</a>.</p></div><div class=paragraph><p>The current NAT instance number and NAT rule number does not match with the default NAT instance number and rule number created by <span class=filename>rc.firewall</span> which is a script to set up the baked-in default firewall rulesets present in FreeBSD.</p></div></td></tr></tbody></table></div><div class="literalblock programlisting"><div class=content><pre>$cmd 005 allow all from any to any via xl0  # exclude LAN traffic
$cmd 010 allow all from any to any via lo0  # exclude loopback traffic
$cmd 099 reass all from any to any in       # reassamble inbound packets
$cmd 100 nat 1 ip from any to any in via $pif # NAT any inbound packets
# Allow the packet through if it has an existing entry in the dynamic rules table
$cmd 101 check-state</pre></div></div><div class=paragraph><p>The outbound rules are modified to replace the <code>allow</code> action with the <code>$skip</code> variable, indicating that rule processing will continue at rule <code>1000</code>. The seven <code>tcp</code> rules have been replaced by rule <code>125</code> as the <code>$good_tcpo</code> variable contains the seven allowed outbound ports.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Remember that IPFW’s firewall performance is largely determined by the number of rules present in the ruleset.</p></div></td></tr></tbody></table></div><div class="literalblock programlisting"><div class=content><pre># Authorized outbound packets
$cmd 120 $skip udp from any to x.x.x.x 53 out via $pif $ks
$cmd 121 $skip udp from any to x.x.x.x 67 out via $pif $ks
$cmd 125 $skip tcp from any to any $good_tcpo out via $pif setup $ks
$cmd 130 $skip icmp from any to any out via $pif $ks</pre></div></div><div class=paragraph><p>The inbound rules remain the same, except for the very last rule which removes the <code>via $pif</code> in order to catch both inbound and outbound rules. The NAT rule must follow this last outbound rule, must have a higher number than that last rule, and the rule number must be referenced by the <code>skipto</code> action. In this ruleset, rule number <code>1000</code> handles passing all packets to our configured instance for NAT processing. The next rule allows any packet which has undergone NAT processing to pass.</p></div><div class="literalblock programlisting"><div class=content><pre>$cmd 999 deny log all from any to any
$cmd 1000 nat 1 ip from any to any out via $pif # skipto location for outbound stateful rules
$cmd 1001 allow ip from any to any</pre></div></div><div class=paragraph><p>In this example, rules <code>100</code>, <code>101</code>, <code>125</code>, <code>1000</code>, and <code>1001</code> control the address translation of the outbound and inbound packets so that the entries in the dynamic state table always register the private LANIP address.</p></div><div class=paragraph><p>Consider an internal web browser which initializes a new outbound HTTP session over port 80. When the first outbound packet enters the firewall, it does not match rule <code>100</code> because it is headed out rather than in. It passes rule <code>101</code> because this is the first packet and it has not been posted to the dynamic state table yet. The packet finally matches rule <code>125</code> as it is outbound on an allowed port and has a source IP address from the internal LAN. On matching this rule, two actions take place. First, the <code>keep-state</code> action adds an entry to the dynamic state table and the specified action, <code>skipto rule 1000</code>, is executed. Next, the packet undergoes NAT and is sent out to the Internet. This packet makes its way to the destination web server, where a response packet is generated and sent back. This new packet enters the top of the ruleset. It matches rule <code>100</code> and has its destination IP address mapped back to the original internal address. It then is processed by the <code>check-state</code> rule, is found in the table as an existing session, and is released to the LAN.</p></div><div class=paragraph><p>On the inbound side, the ruleset has to deny bad packets and allow only authorized services. A packet which matches an inbound rule is posted to the dynamic state table and the packet is released to the LAN. The packet generated as a response is recognized by the <code>check-state</code> rule as belonging to an existing session. It is then sent to rule <code>1000</code> to undergo NAT before being released to the outbound interface.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Transition from userland <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> to in-kernel NAT might seem seamless at first but there is small catch. When using the GENERIC kernel, IPFW will load the <span class=filename>libalias.ko</span> kernel module, when <code>firewall_nat_enable</code> is enabled in <span class=filename>rc.conf</span>. Although, the loaded module only provides basic NAT functionality, whereas the userland implementation <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> has all functionality available without any extra configuration from its userland library. All functionality refers to the following kernel modules that can additionally be loaded when needed besides the standard <span class=filename>libalias.ko</span> kernel module: <span class=filename>alias_cuseeme.ko</span>, <span class=filename>alias_ftp.ko</span>, <span class=filename>alias_bbt.ko</span>, <span class=filename>skinny.ko</span>, <span class=filename>irc.ko</span>, <span class=filename>alias_pptp.ko</span> and <span class=filename>alias_smedia.ko</span> using the <code>kld_list</code> directive in <span class=filename>rc.conf</span> to mimic the full functionality of the userland implementation. If a custom kernel is used, the full functionality of the userland library can be compiled in, in the kernel, using the <code>option LIBALIAS</code>.</p></div></td></tr></tbody></table></div><div class=sect3><h4 id=_port_重新導向>30.4.4.1. Port 重新導向<a class=anchor href=#_port_重新導向></a></h4><div class=paragraph><p>The drawback with NAT in general is that the LAN clients are not accessible from the Internet. Clients on the LAN can make outgoing connections to the world but cannot receive incoming ones. This presents a problem if trying to run Internet services on one of the LAN client machines. A simple way around this is to redirect selected Internet ports on the NAT providing machine to a LAN client.</p></div><div class=paragraph><p>For example, an IRC server runs on client <code>A</code> and a web server runs on client <code>B</code>. For this to work properly, connections received on ports 6667 (IRC) and 80 (HTTP) must be redirected to the respective machines.</p></div><div class=paragraph><p>With in-kernel NAT all configuration is done in the NAT instance configuration. For a full list of options that an in-kernel NAT instance can use, consult <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfw&amp;sektion=8&amp;format=html">ipfw(8)</a>. The IPFW syntax follows the syntax of natd. The syntax for <code>redirect_port</code> is as follows:</p></div><div class="literalblock programlisting"><div class=content><pre>redirect_port proto targetIP:targetPORT[-targetPORT]
  [aliasIP:]aliasPORT[-aliasPORT]
  [remoteIP[:remotePORT[-remotePORT]]]</pre></div></div><div class=paragraph><p>To configure the above example setup, the arguments should be:</p></div><div class="literalblock programlisting"><div class=content><pre>redirect_port tcp 192.168.0.2:6667 6667
redirect_port tcp 192.168.0.3:80 80</pre></div></div><div class=paragraph><p>After adding these arguments to the configuration of NAT instance 1 in the above ruleset, the TCP ports will be port forwarded to the LAN client machines running the IRC and HTTP services.</p></div><div class="literalblock programlisting"><div class=content><pre>ipfw -q nat 1 config if $pif same_ports unreg_only reset \
  redirect_port tcp 192.168.0.2:6667 6667 \
  redirect_port tcp 192.1683.0.3:80 80</pre></div></div><div class=paragraph><p>Port ranges over individual ports can be indicated with <code>redirect_port</code>. For example, <em>tcp 192.168.0.2:2000-3000 2000-3000</em> would redirect all connections received on ports 2000 to 3000 to ports 2000 to 3000 on client <code>A</code>.</p></div></div><div class=sect3><h4 id=_位址重新導向>30.4.4.2. 位址重新導向<a class=anchor href=#_位址重新導向></a></h4><div class=paragraph><p>Address redirection is useful if more than one IP address is available. Each LAN client can be assigned its own external IP address by <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfw&amp;sektion=8&amp;format=html">ipfw(8)</a>, which will then rewrite outgoing packets from the LAN clients with the proper external IP address and redirects all traffic incoming on that particular IP address back to the specific LAN client. This is also known as static NAT. For example, if IP addresses <code>128.1.1.1</code>, <code>128.1.1.2</code>, and <code>128.1.1.3</code> are available, <code>128.1.1.1</code> can be used as the <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfw&amp;sektion=8&amp;format=html">ipfw(8)</a> machine’s external IP address, while <code>128.1.1.2</code> and <code>128.1.1.3</code> are forwarded back to LAN clients <code>A</code> and <code>B</code>.</p></div><div class=paragraph><p>The <code>redirect_address</code> syntax is as below, where <code>localIP</code> is the internal IP address of the LAN client, and <code>publicIP</code> the external IP address corresponding to the LAN client.</p></div><div class="literalblock programlisting"><div class=content><pre>redirect_address localIP publicIP</pre></div></div><div class=paragraph><p>In the example, the arguments would read:</p></div><div class="literalblock programlisting"><div class=content><pre>redirect_address 192.168.0.2 128.1.1.2
redirect_address 192.168.0.3 128.1.1.3</pre></div></div><div class=paragraph><p>Like <code>redirect_port</code>, these arguments are placed in a NAT instance configuration. With address redirection, there is no need for port redirection, as all data received on a particular IP address is redirected.</p></div><div class=paragraph><p>The external IP addresses on the <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfw&amp;sektion=8&amp;format=html">ipfw(8)</a> machine must be active and aliased to the external interface. Refer to <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a> for details.</p></div></div><div class=sect3><h4 id=_userspace_nat>30.4.4.3. Userspace NAT<a class=anchor href=#_userspace_nat></a></h4><div class=paragraph><p>Let us start with a statement: the userspace NAT implementation: <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a>, has more overhead than in-kernel NAT. For <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> to translate packets, the packets have to be copied from the kernel to userspace and back which brings in extra overhead that is not present with in-kernel NAT.</p></div><div class=paragraph><p>要在開機時啟動 Userspace 的 NAT daemon <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> 需在 <span class=filename>/etc/rc.conf</span> 中做以下最小設定，其中 <code>natd_interface</code> 要設成連接到網際網路的 NIC 名稱，<a href="https://man.freebsd.org/cgi/man.cgi?query=rc&amp;sektion=8&amp;format=html">rc(8)</a> script of <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> 會自動檢查是否有使用動態 IP 位址，並且自行設定並處理。</p></div><div class="literalblock programlisting"><div class=content><pre>gateway_enable=&#34;YES&#34;
natd_enable=&#34;YES&#34;
natd_interface=&#34;rl0&#34;</pre></div></div><div class=paragraph><p>In general, the above ruleset as explained for in-kernel NAT can also be used together with <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a>. The only exceptions are the configuration of the in-kernel NAT instance <code>(ipfw -q nat 1 config …​)</code> not being applicable any more, rule number 100 and 1000 will have to change sligthly as below, and reassemble rule 99 is not needed anymore as the <code>divert</code> action is used which covers fragmentation.</p></div><div class="literalblock programlisting"><div class=content><pre>$cmd 100 divert natd ip from any to any in via $pif
$cmd 1000 divert natd ip from any to any out via $pif</pre></div></div><div class=paragraph><p>To configure port or address redirection, a similar syntax as with in-kernel NAT is used. Although, now, instead of specifying the configuration in our ruleset script like with in-kernel NAT, configuration of <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> is best done in a configuration file. To do this, an extra flag must be passed via <span class=filename>/etc/rc.conf</span> which specifies the path of the configuration file.</p></div><div class="literalblock programlisting"><div class=content><pre>natd_flags=&#34;-f /etc/natd.conf&#34;</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>The specified file must contain a list of configuration options, one per line. For more information about the configuration file and possible variables, consult <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a>. Below are two example entries, one per line:</p></div><div class="literalblock programlisting"><div class=content><pre>redirect_port tcp 192.168.0.2:6667 6667
redirect_address 192.168.0.3 128.1.1.3</pre></div></div></td></tr></tbody></table></div></div></div><div class=sect2><h3 id=firewalls-ipfw-cmd>30.4.5. IPFW 指令<a class=anchor href=#firewalls-ipfw-cmd></a></h3><div class=paragraph><p><code>ipfw</code> can be used to make manual, single rule additions or deletions to the active firewall while it is running. The problem with using this method is that all the changes are lost when the system reboots. It is recommended to instead write all the rules in a file and to use that file to load the rules at boot time and to replace the currently running firewall rules whenever that file changes.</p></div><div class=paragraph><p><code>ipfw</code> is a useful way to display the running firewall rules to the console screen. The IPFW accounting facility dynamically creates a counter for each rule that counts each packet that matches the rule. During the process of testing a rule, listing the rule with its counter is one way to determine if the rule is functioning as expected.</p></div><div class=paragraph><p>To list all the running rules in sequence:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ipfw list</span></code></pre></div></div><div class=paragraph><p>To list all the running rules with a time stamp of when the last time the rule was matched:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ipfw -t list</span></code></pre></div></div><div class=paragraph><p>The next example lists accounting information and the packet count for matched rules along with the rules themselves. The first column is the rule number, followed by the number of matched packets and bytes, followed by the rule itself.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ipfw -a list</span></code></pre></div></div><div class=paragraph><p>To list dynamic rules in addition to static rules:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ipfw -d list</span></code></pre></div></div><div class=paragraph><p>To also show the expired dynamic rules:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ipfw -d -e list</span></code></pre></div></div><div class=paragraph><p>To zero the counters:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ipfw zero</span></code></pre></div></div><div class=paragraph><p>To zero the counters for just the rule with number <em>NUM</em>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ipfw zero NUM</span></code></pre></div></div><div class=sect3><h4 id=_記錄防火牆訊息>30.4.5.1. 記錄防火牆訊息<a class=anchor href=#_記錄防火牆訊息></a></h4><div class=paragraph><p>Even with the logging facility enabled, IPFW will not generate any rule logging on its own. The firewall administrator decides which rules in the ruleset will be logged, and adds the <code>log</code> keyword to those rules. Normally only deny rules are logged. It is customary to duplicate the "ipfw default deny everything" rule with the <code>log</code> keyword included as the last rule in the ruleset. This way, it is possible to see all the packets that did not match any of the rules in the ruleset.</p></div><div class=paragraph><p>Logging is a two edged sword. If one is not careful, an over abundance of log data or a DoS attack can fill the disk with log files. Log messages are not only written to syslogd, but also are displayed on the root console screen and soon become annoying.</p></div><div class=paragraph><p>The <code>IPFIREWALL_VERBOSE_LIMIT=5</code> kernel option limits the number of consecutive messages sent to <a href="https://man.freebsd.org/cgi/man.cgi?query=syslogd&amp;sektion=8&amp;format=html">syslogd(8)</a>, concerning the packet matching of a given rule. When this option is enabled in the kernel, the number of consecutive messages concerning a particular rule is capped at the number specified. There is nothing to be gained from 200 identical log messages. With this option set to five, five consecutive messages concerning a particular rule would be logged to syslogd and the remainder identical consecutive messages would be counted and posted to syslogd with a phrase like the following:</p></div><div class="literalblock programlisting"><div class=content><pre>last message repeated 45 times</pre></div></div><div class=paragraph><p>All logged packets messages are written by default to <span class=filename>/var/log/security</span>, which is defined in <span class=filename>/etc/syslog.conf</span>.</p></div></div><div class=sect3><h4 id=firewalls-ipfw-rules-script>30.4.5.2. 建立規則 Script<a class=anchor href=#firewalls-ipfw-rules-script></a></h4><div class=paragraph><p>Most experienced IPFW users create a file containing the rules and code them in a manner compatible with running them as a script. The major benefit of doing this is the firewall rules can be refreshed in mass without the need of rebooting the system to activate them. This method is convenient in testing new rules as the procedure can be executed as many times as needed. Being a script, symbolic substitution can be used for frequently used values to be substituted into multiple rules.</p></div><div class=paragraph><p>This example script is compatible with the syntax used by the <a href="https://man.freebsd.org/cgi/man.cgi?query=sh&amp;sektion=1&amp;format=html">sh(1)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=csh&amp;sektion=1&amp;format=html">csh(1)</a>, and <a href="https://man.freebsd.org/cgi/man.cgi?query=tcsh&amp;sektion=1&amp;format=html">tcsh(1)</a> shells. Symbolic substitution fields are prefixed with a dollar sign ($). Symbolic fields do not have the $ prefix. The value to populate the symbolic field must be enclosed in double quotes ("").</p></div><div class=paragraph><p>Start the rules file like this:</p></div><div class="literalblock programlisting"><div class=content><pre>############### start of example ipfw rules script #############
#
ipfw -q -f flush       # Delete all rules
# Set defaults
oif=&#34;tun0&#34;             # out interface
odns=&#34;192.0.2.11&#34;      # ISP&#39;s DNS server IP address
cmd=&#34;ipfw -q add &#34;     # build rule prefix
ks=&#34;keep-state&#34;        # just too lazy to key this each time
$cmd 00500 check-state
$cmd 00502 deny all from any to any frag
$cmd 00501 deny tcp from any to any established
$cmd 00600 allow tcp from any to any 80 out via $oif setup $ks
$cmd 00610 allow tcp from any to $odns 53 out via $oif setup $ks
$cmd 00611 allow udp from any to $odns 53 out via $oif $ks
################### End of example ipfw rules script ############</pre></div></div><div class=paragraph><p>The rules are not important as the focus of this example is how the symbolic substitution fields are populated.</p></div><div class=paragraph><p>If the above example was in <span class=filename>/etc/ipfw.rules</span>, the rules could be reloaded by the following command:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sh /etc/ipfw.rules</span></code></pre></div></div><div class=paragraph><p><span class=filename>/etc/ipfw.rules</span> can be located anywhere and the file can have any name.</p></div><div class=paragraph><p>The same thing could be accomplished by running these commands by hand:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ipfw -q -f flush</span>
<span class=c># ipfw -q add check-state</span>
<span class=c># ipfw -q add deny all from any to any frag</span>
<span class=c># ipfw -q add deny tcp from any to any established</span>
<span class=c># ipfw -q add allow tcp from any to any 80 out via tun0 setup keep-state</span>
<span class=c># ipfw -q add allow tcp from any to 192.0.2.11 53 out via tun0 setup keep-state</span>
<span class=c># ipfw -q add 00611 allow udp from any to 192.0.2.11 53 out via tun0 keep-state</span></code></pre></div></div></div></div><div class=sect2><h3 id=firewalls-ipfw-kernelconfig>30.4.6. IPFW 核心選項<a class=anchor href=#firewalls-ipfw-kernelconfig></a></h3><div class=paragraph><p>In order to statically compile IPFW support into a custom kernel, refer to the instructions in <a href=../kernelconfig/#kernelconfig>設定 FreeBSD 核心</a>. The following options are available for the custom kernel configuration file:</p></div><div class="literalblock programlisting"><div class=content><pre>options    IPFIREWALL			# enables IPFW
options    IPFIREWALL_VERBOSE		# enables logging for rules with log keyword to syslogd(8)
options    IPFIREWALL_VERBOSE_LIMIT=5	# limits number of logged packets per-entry
options    IPFIREWALL_DEFAULT_TO_ACCEPT # sets default policy to pass what is not explicitly denied
options    IPFIREWALL_NAT		# enables in-kernel NAT support
options    IPFIREWALL_NAT64		# enables in-kernel NAT64 support
options    IPFIREWALL_NPTV6		# enables in-kernel IPv6 NPT support
options    IPFIREWALL_PMOD		# enables protocols modification module support
options    IPDIVERT			# enables NAT through natd(8)</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>IPFW can be loaded as a kernel module: options above are built by default as modules or can be set at runtime using tunables.</p></div></td></tr></tbody></table></div></div></div></div><div class=sect1><h2 id=firewalls-ipf>30.5. IPFILTER (IPF)<a class=anchor href=#firewalls-ipf></a></h2><div class=sectionbody><div class=paragraph><p>IPFILTER 即為 IPF，是一套跨平台、開放源碼的防火牆，已被移植到各種作業系統，包含 FreeBSD, NetBSD, OpenBSD 與 Solaris™。</p></div><div class=paragraph><p>IPFILTER 是核心端 (Kernel-side) 的防火牆且 NAT 機制可由 Userland 的程式控制與監控，防火牆規則可以使用 ipf 設定或刪除，NAT 規則可以使用 ipnat 設定或刪除，可使用 ipfstat 來列出 IPFILTER 在核心部份的執行期統計資訊，可使用 ipmon 來記錄 IPFILTER 動作到系統記錄檔。</p></div><div class=paragraph><p>IPF 原來是以 "最後一個符合的條件優先" 的規則處理邏輯所撰寫並只能使用無狀態 (Stateless) 的規則，之後 IPF 才被加強支援快速 (<code>quick</code>) 與保留狀態 (<code>keep state</code>) 的選項。</p></div><div class=paragraph><p>IPF FAQ 位於 <a href=http://www.phildev.net/ipf/index.html>http://www.phildev.net/ipf/index.html</a>，可搜尋的 IPFilter 郵遞論壇封存資料可至 <a href="http://marc.info/?l=ipfilter">http://marc.info/?l=ipfilter</a> 取得。</p></div><div class=paragraph><p>由於 FreeBSD 也支援 IPF 因此操作手冊特別在此章節對此介紹，本節提供幾個有使用快速 (<code>quick</code>) 與保留狀態 (<code>keep state</code>) 選項的規則範例。</p></div><div class=sect2><h3 id=_開啟_ipf>30.5.1. 開啟 IPF<a class=anchor href=#_開啟_ipf></a></h3><div class=paragraph><p>IPF is included in the basic FreeBSD install as a kernel loadable module, meaning that a custom kernel is not needed in order to enable IPF.</p></div><div class=paragraph><p>For users who prefer to statically compile IPF support into a custom kernel, refer to the instructions in <a href=../kernelconfig/#kernelconfig>設定 FreeBSD 核心</a>. The following kernel options are available:</p></div><div class="literalblock programlisting"><div class=content><pre>options IPFILTER
options IPFILTER_LOG
options IPFILTER_LOOKUP
options IPFILTER_DEFAULT_BLOCK</pre></div></div><div class=paragraph><p>where <code>options IPFILTER</code> enables support for IPFILTER, <code>options IPFILTER_LOG</code> enables IPF logging using the <span class=filename>ipl</span> packet logging pseudo-device for every rule that has the <code>log</code> keyword, <code>IPFILTER_LOOKUP</code> enables IP pools in order to speed up IP lookups, and <code>options IPFILTER_DEFAULT_BLOCK</code> changes the default behavior so that any packet not matching a firewall <code>pass</code> rule gets blocked.</p></div><div class=paragraph><p>To configure the system to enable IPF at boot time, add the following entries to <span class=filename>/etc/rc.conf</span>. These entries will also enable logging and <code>default pass all</code>. To change the default policy to <code>block all</code> without compiling a custom kernel, remember to add a <code>block all</code> rule at the end of the ruleset.</p></div><div class="literalblock programlisting"><div class=content><pre>ipfilter_enable=&#34;YES&#34;             # Start ipf firewall
ipfilter_rules=&#34;/etc/ipf.rules&#34;   # loads rules definition text file
ipmon_enable=&#34;YES&#34;                # Start IP monitor log
ipmon_flags=&#34;-Ds&#34;                 # D = start as daemon
                                  # s = log to syslog
                                  # v = log tcp window, ack, seq
                                  # n = map IP &amp; port to names</pre></div></div><div class=paragraph><p>If NAT functionality is needed, also add these lines:</p></div><div class="literalblock programlisting"><div class=content><pre>gateway_enable=&#34;YES&#34;              # Enable as LAN gateway
ipnat_enable=&#34;YES&#34;                # Start ipnat function
ipnat_rules=&#34;/etc/ipnat.rules&#34;    # rules definition file for ipnat</pre></div></div><div class=paragraph><p>Then, to start IPF now:</p></div><div class="literalblock programlisting"><div class=content><pre># service ipfilter start</pre></div></div><div class=paragraph><p>To load the firewall rules, specify the name of the ruleset file using <code>ipf</code>. The following command can be used to replace the currently running firewall rules:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ipf -Fa -f /etc/ipf.rules</span></code></pre></div></div><div class=paragraph><p>where <code>-Fa</code> flushes all the internal rules tables and <code>-f</code> specifies the file containing the rules to load.</p></div><div class=paragraph><p>This provides the ability to make changes to a custom ruleset and update the running firewall with a fresh copy of the rules without having to reboot the system. This method is convenient for testing new rules as the procedure can be executed as many times as needed.</p></div><div class=paragraph><p>Refer to <a href="https://man.freebsd.org/cgi/man.cgi?query=ipf&amp;sektion=8&amp;format=html">ipf(8)</a> for details on the other flags available with this command.</p></div></div><div class=sect2><h3 id=_ipf_規則語法>30.5.2. IPF 規則語法<a class=anchor href=#_ipf_規則語法></a></h3><div class=paragraph><p>This section describes the IPF rule syntax used to create stateful rules. When creating rules, keep in mind that unless the <code>quick</code> keyword appears in a rule, every rule is read in order, with the <em>last matching rule</em> being the one that is applied. This means that even if the first rule to match a packet is a <code>pass</code>, if there is a later matching rule that is a <code>block</code>, the packet will be dropped. Sample rulesets can be found in <span class=filename>/usr/shared/examples/ipfilter</span>.</p></div><div class=paragraph><p>When creating rules, a <code>#</code> character is used to mark the start of a comment and may appear at the end of a rule, to explain that rule’s function, or on its own line. Any blank lines are ignored.</p></div><div class=paragraph><p>The keywords which are used in rules must be written in a specific order, from left to right. Some keywords are mandatory while others are optional. Some keywords have sub-options which may be keywords themselves and also include more sub-options. The keyword order is as follows, where the words shown in uppercase represent a variable and the words shown in lowercase must precede the variable that follows it:</p></div><div class=paragraph><p><em>ACTION DIRECTION OPTIONS proto PROTO_TYPE from SRC_ADDR SRC_PORT to DST_ADDR DST_PORT TCP_FLAG|ICMP_TYPE keep state STATE</em></p></div><div class=paragraph><p>This section describes each of these keywords and their options. It is not an exhaustive list of every possible option. Refer to <a href="https://man.freebsd.org/cgi/man.cgi?query=ipf&amp;sektion=5&amp;format=html">ipf(5)</a> for a complete description of the rule syntax that can be used when creating IPF rules and examples for using each keyword.</p></div><div class=dlist><dl><dt class=hdlist1>ACTION</dt><dd><p>The action keyword indicates what to do with the packet if it matches that rule. Every rule <em>must</em> have an action. The following actions are recognized:</p><div class=paragraph><p><code>block</code>: drops the packet.</p></div><div class=paragraph><p><code>pass</code>: allows the packet.</p></div><div class=paragraph><p><code>log</code>: generates a log record.</p></div><div class=paragraph><p><code>count</code>: counts the number of packets and bytes which can provide an indication of how often a rule is used.</p></div><div class=paragraph><p><code>auth</code>: queues the packet for further processing by another program.</p></div><div class=paragraph><p><code>call</code>: provides access to functions built into IPF that allow more complex actions.</p></div><div class=paragraph><p><code>decapsulate</code>: removes any headers in order to process the contents of the packet.</p></div></dd><dt class=hdlist1>DIRECTION</dt><dd><p>Next, each rule must explicitly state the direction of traffic using one of these keywords:</p><div class=paragraph><p><code>in</code>: the rule is applied against an inbound packet.</p></div><div class=paragraph><p><code>out</code>: the rule is applied against an outbound packet.</p></div><div class=paragraph><p><code>all</code>: the rule applies to either direction.</p></div><div class=paragraph><p>If the system has multiple interfaces, the interface can be specified along with the direction. An example would be <code>in on fxp0</code>.</p></div></dd><dt class=hdlist1>OPTIONS</dt><dd><p>Options are optional. However, if multiple options are specified, they must be used in the order shown here.</p><div class=paragraph><p><code>log</code>: when performing the specified ACTION, the contents of the packet’s headers will be written to the <a href="https://man.freebsd.org/cgi/man.cgi?query=ipl&amp;sektion=4&amp;format=html">ipl(4)</a> packet log pseudo-device.</p></div><div class=paragraph><p><code>quick</code>: if a packet matches this rule, the ACTION specified by the rule occurs and no further processing of any following rules will occur for this packet.</p></div><div class=paragraph><p><code>on</code>: must be followed by the interface name as displayed by <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a>. The rule will only match if the packet is going through the specified interface in the specified direction.</p></div><div class=paragraph><p>When using the <code>log</code> keyword, the following qualifiers may be used in this order:</p></div><div class=paragraph><p><code>body</code>: indicates that the first 128 bytes of the packet contents will be logged after the headers.</p></div><div class=paragraph><p><code>first</code>: if the <code>log</code> keyword is being used in conjunction with a <code>keep state</code> option, this option is recommended so that only the triggering packet is logged and not every packet which matches the stateful connection.</p></div><div class=paragraph><p>Additional options are available to specify error return messages. Refer to <a href="https://man.freebsd.org/cgi/man.cgi?query=ipf&amp;sektion=5&amp;format=html">ipf(5)</a> for more details.</p></div></dd><dt class=hdlist1>PROTO_TYPE</dt><dd><p>The protocol type is optional. However, it is mandatory if the rule needs to specify a SRC_PORT or a DST_PORT as it defines the type of protocol. When specifying the type of protocol, use the <code>proto</code> keyword followed by either a protocol number or name from <span class=filename>/etc/protocols</span>. Example protocol names include <code>tcp</code>, <code>udp</code>, or <code>icmp</code>. If PROTO_TYPE is specified but no SRC_PORT or DST_PORT is specified, all port numbers for that protocol will match that rule.</p></dd><dt class=hdlist1>SRC_ADDR</dt><dd><p>The <code>from</code> keyword is mandatory and is followed by a keyword which represents the source of the packet. The source can be a hostname, an IP address followed by the CIDR mask, an address pool, or the keyword <code>all</code>. Refer to <a href="https://man.freebsd.org/cgi/man.cgi?query=ipf&amp;sektion=5&amp;format=html">ipf(5)</a> for examples.</p><div class=paragraph><p>There is no way to match ranges of IP addresses which do not express themselves easily using the dotted numeric form / mask-length notation. The <a class=package href=https://cgit.freebsd.org/ports/tree/net-mgmt/ipcalc/>net-mgmt/ipcalc</a> package or port may be used to ease the calculation of the CIDR mask. Additional information is available at the utility’s web page: <a href=http://jodies.de/ipcalc>http://jodies.de/ipcalc</a>.</p></div></dd><dt class=hdlist1>SRC_PORT</dt><dd><p>The port number of the source is optional. However, if it is used, it requires PROTO_TYPE to be first defined in the rule. The port number must also be preceded by the <code>proto</code> keyword.</p><div class=paragraph><p>A number of different comparison operators are supported: <code>=</code> (equal to), <code>!=</code> (not equal to), <code>&lt;</code> (less than), <code>></code> (greater than), <code>⇐</code> (less than or equal to), and <code>>=</code> (greater than or equal to).</p></div><div class=paragraph><p>To specify port ranges, place the two port numbers between <code>&lt;></code> (less than and greater than ), <code>>&lt;</code> (greater than and less than ), or <code>:</code> (greater than or equal to and less than or equal to).</p></div></dd><dt class=hdlist1>DST_ADDR</dt><dd><p>The <code>to</code> keyword is mandatory and is followed by a keyword which represents the destination of the packet. Similar to SRC_ADDR, it can be a hostname, an IP address followed by the CIDR mask, an address pool, or the keyword <code>all</code>.</p></dd><dt class=hdlist1>DST_PORT</dt><dd><p>Similar to SRC_PORT, the port number of the destination is optional. However, if it is used, it requires PROTO_TYPE to be first defined in the rule. The port number must also be preceded by the <code>proto</code> keyword.</p></dd><dt class=hdlist1>TCP_FLAG|ICMP_TYPE</dt><dd><p>If <code>tcp</code> is specified as the PROTO_TYPE, flags can be specified as letters, where each letter represents one of the possible TCP flags used to determine the state of a connection. Possible values are: <code>S</code> (SYN), <code>A</code> (ACK), <code>P</code> (PSH), <code>F</code> (FIN), <code>U</code> (URG), <code>R</code> (RST), <code>C</code> (CWN), and <code>E</code> (ECN).</p><div class=paragraph><p>If <code>icmp</code> is specified as the PROTO_TYPE, the ICMP type to match can be specified. Refer to <a href="https://man.freebsd.org/cgi/man.cgi?query=ipf&amp;sektion=5&amp;format=html">ipf(5)</a> for the allowable types.</p></div></dd><dt class=hdlist1>STATE</dt><dd><p>If a <code>pass</code> rule contains <code>keep state</code>, IPF will add an entry to its dynamic state table and allow subsequent packets that match the connection. IPF can track state for TCP, UDP, and ICMP sessions. Any packet that IPF can be certain is part of an active session, even if it is a different protocol, will be allowed.</p><div class=paragraph><p>In IPF, packets destined to go out through the interface connected to the public Internet are first checked against the dynamic state table. If the packet matches the next expected packet comprising an active session conversation, it exits the firewall and the state of the session conversation flow is updated in the dynamic state table. Packets that do not belong to an already active session are checked against the outbound ruleset. Packets coming in from the interface connected to the public Internet are first checked against the dynamic state table. If the packet matches the next expected packet comprising an active session, it exits the firewall and the state of the session conversation flow is updated in the dynamic state table. Packets that do not belong to an already active session are checked against the inbound ruleset.</p></div><div class=paragraph><p>Several keywords can be added after <code>keep state</code>. If used, these keywords set various options that control stateful filtering, such as setting connection limits or connection age. Refer to <a href="https://man.freebsd.org/cgi/man.cgi?query=ipf&amp;sektion=5&amp;format=html">ipf(5)</a> for the list of available options and their descriptions.</p></div></dd></dl></div></div><div class=sect2><h3 id=_範例規則集_2>30.5.3. 範例規則集<a class=anchor href=#_範例規則集_2></a></h3><div class=paragraph><p>This section demonstrates how to create an example ruleset which only allows services matching <code>pass</code> rules and blocks all others.</p></div><div class=paragraph><p>FreeBSD uses the loopback interface (<span class=filename>lo0</span>) and the IP address <code>127.0.0.1</code> for internal communication. The firewall ruleset must contain rules to allow free movement of these internally used packets:</p></div><div class="literalblock programlisting"><div class=content><pre># no restrictions on loopback interface
pass in quick on lo0 all
pass out quick on lo0 all</pre></div></div><div class=paragraph><p>The public interface connected to the Internet is used to authorize and control access of all outbound and inbound connections. If one or more interfaces are cabled to private networks, those internal interfaces may require rules to allow packets originating from the LAN to flow between the internal networks or to the interface attached to the Internet. The ruleset should be organized into three major sections: any trusted internal interfaces, outbound connections through the public interface, and inbound connections through the public interface.</p></div><div class=paragraph><p>These two rules allow all traffic to pass through a trusted LAN interface named <span class=filename>xl0</span>:</p></div><div class="literalblock programlisting"><div class=content><pre># no restrictions on inside LAN interface for private network
pass out quick on xl0 all
pass in quick on xl0 all</pre></div></div><div class=paragraph><p>The rules for the public interface’s outbound and inbound sections should have the most frequently matched rules placed before less commonly matched rules, with the last rule in the section blocking and logging all packets for that interface and direction.</p></div><div class=paragraph><p>This set of rules defines the outbound section of the public interface named <span class=filename>dc0</span>. These rules keep state and identify the specific services that internal systems are authorized for public Internet access. All the rules use <code>quick</code> and specify the appropriate port numbers and, where applicable, destination addresses.</p></div><div class="literalblock programlisting"><div class=content><pre># interface facing Internet (outbound)
# Matches session start requests originating from or behind the
# firewall, destined for the Internet.

# Allow outbound access to public DNS servers.
# Replace x.x.x. with address listed in /etc/resolv.conf.
# Repeat for each DNS server.
pass out quick on dc0 proto tcp from any to x.x.x. port = 53 flags S keep state
pass out quick on dc0 proto udp from any to xxx port = 53 keep state

# Allow access to ISP&#39;s specified DHCP server for cable or DSL networks.
# Use the first rule, then check log for the IP address of DHCP server.
# Then, uncomment the second rule, replace z.z.z.z with the IP address,
# and comment out the first rule
pass out log quick on dc0 proto udp from any to any port = 67 keep state
#pass out quick on dc0 proto udp from any to z.z.z.z port = 67 keep state

# Allow HTTP and HTTPS
pass out quick on dc0 proto tcp from any to any port = 80 flags S keep state
pass out quick on dc0 proto tcp from any to any port = 443 flags S keep state

# Allow email
pass out quick on dc0 proto tcp from any to any port = 110 flags S keep state
pass out quick on dc0 proto tcp from any to any port = 25 flags S keep state

# Allow NTP
pass out quick on dc0 proto tcp from any to any port = 37 flags S keep state

# Allow FTP
pass out quick on dc0 proto tcp from any to any port = 21 flags S keep state

# Allow SSH
pass out quick on dc0 proto tcp from any to any port = 22 flags S keep state

# Allow ping
pass out quick on dc0 proto icmp from any to any icmp-type 8 keep state

# Block and log everything else
block out log first quick on dc0 all</pre></div></div><div class=paragraph><p>This example of the rules in the inbound section of the public interface blocks all undesirable packets first. This reduces the number of packets that are logged by the last rule.</p></div><div class="literalblock programlisting"><div class=content><pre># interface facing Internet (inbound)
# Block all inbound traffic from non-routable or reserved address spaces
block in quick on dc0 from 192.168.0.0/16 to any    #RFC 1918 private IP
block in quick on dc0 from 172.16.0.0/12 to any     #RFC 1918 private IP
block in quick on dc0 from 10.0.0.0/8 to any        #RFC 1918 private IP
block in quick on dc0 from 127.0.0.0/8 to any       #loopback
block in quick on dc0 from 0.0.0.0/8 to any         #loopback
block in quick on dc0 from 169.254.0.0/16 to any    #DHCP auto-config
block in quick on dc0 from 192.0.2.0/24 to any      #reserved for docs
block in quick on dc0 from 204.152.64.0/23 to any   #Sun cluster interconnect
block in quick on dc0 from 224.0.0.0/3 to any       #Class D &amp; E multicast

# Block fragments and too short tcp packets
block in quick on dc0 all with frags
block in quick on dc0 proto tcp all with short

# block source routed packets
block in quick on dc0 all with opt lsrr
block in quick on dc0 all with opt ssrr

# Block OS fingerprint attempts and log first occurrence
block in log first quick on dc0 proto tcp from any to any flags FUP

# Block anything with special options
block in quick on dc0 all with ipopts

# Block public pings and ident
block in quick on dc0 proto icmp all icmp-type 8
block in quick on dc0 proto tcp from any to any port = 113

# Block incoming Netbios services
block in log first quick on dc0 proto tcp/udp from any to any port = 137
block in log first quick on dc0 proto tcp/udp from any to any port = 138
block in log first quick on dc0 proto tcp/udp from any to any port = 139
block in log first quick on dc0 proto tcp/udp from any to any port = 81</pre></div></div><div class=paragraph><p>Any time there are logged messages on a rule with the <code>log first</code> option, run <code>ipfstat -hio</code> to evaluate how many times the rule has been matched. A large number of matches may indicate that the system is under attack.</p></div><div class=paragraph><p>The rest of the rules in the inbound section define which connections are allowed to be initiated from the Internet. The last rule denies all connections which were not explicitly allowed by previous rules in this section.</p></div><div class="literalblock programlisting"><div class=content><pre># Allow traffic in from ISP&#39;s DHCP server. Replace z.z.z.z with
# the same IP address used in the outbound section.
pass in quick on dc0 proto udp from z.z.z.z to any port = 68 keep state

# Allow public connections to specified internal web server
pass in quick on dc0 proto tcp from any to x.x.x.x port = 80 flags S keep state

# Block and log only first occurrence of all remaining traffic.
block in log first quick on dc0 all</pre></div></div></div><div class=sect2><h3 id=_設定_nat>30.5.4. 設定 NAT<a class=anchor href=#_設定_nat></a></h3><div class=paragraph><p>To enable NAT, add these statements to <span class=filename>/etc/rc.conf</span> and specify the name of the file containing the NAT rules:</p></div><div class="literalblock programlisting"><div class=content><pre>gateway_enable=&#34;YES&#34;
ipnat_enable=&#34;YES&#34;
ipnat_rules=&#34;/etc/ipnat.rules&#34;</pre></div></div><div class=paragraph><p>NAT rules are flexible and can accomplish many different things to fit the needs of both commercial and home users. The rule syntax presented here has been simplified to demonstrate common usage. For a complete rule syntax description, refer to <a href="https://man.freebsd.org/cgi/man.cgi?query=ipnat&amp;sektion=5&amp;format=html">ipnat(5)</a>.</p></div><div class=paragraph><p>The basic syntax for a NAT rule is as follows, where <code>map</code> starts the rule and <em>IF</em> should be replaced with the name of the external interface:</p></div><div class="literalblock programlisting"><div class=content><pre>map IF LAN_IP_RANGE -&gt; PUBLIC_ADDRESS</pre></div></div><div class=paragraph><p>The <em>LAN_IP_RANGE</em> is the range of IP addresses used by internal clients. Usually, it is a private address range such as <code>192.168.1.0/24</code>. The <em>PUBLIC_ADDRESS</em> can either be the static external IP address or the keyword <code>0/32</code> which represents the IP address assigned to <em>IF</em>.</p></div><div class=paragraph><p>In IPF, when a packet arrives at the firewall from the LAN with a public destination, it first passes through the outbound rules of the firewall ruleset. Then, the packet is passed to the NAT ruleset which is read from the top down, where the first matching rule wins. IPF tests each NAT rule against the packet’s interface name and source IP address. When a packet’s interface name matches a NAT rule, the packet’s source IP address in the private LAN is checked to see if it falls within the IP address range specified in <em>LAN_IP_RANGE</em>. On a match, the packet has its source IP address rewritten with the public IP address specified by <em>PUBLIC_ADDRESS</em>. IPF posts an entry in its internal NAT table so that when the packet returns from the Internet, it can be mapped back to its original private IP address before being passed to the firewall rules for further processing.</p></div><div class=paragraph><p>For networks that have large numbers of internal systems or multiple subnets, the process of funneling every private IP address into a single public IP address becomes a resource problem. Two methods are available to relieve this issue.</p></div><div class=paragraph><p>The first method is to assign a range of ports to use as source ports. By adding the <code>portmap</code> keyword, NAT can be directed to only use source ports in the specified range:</p></div><div class="literalblock programlisting"><div class=content><pre>map dc0 192.168.1.0/24 -&gt; 0/32 portmap tcp/udp 20000:60000</pre></div></div><div class=paragraph><p>Alternately, use the <code>auto</code> keyword which tells NAT to determine the ports that are available for use:</p></div><div class="literalblock programlisting"><div class=content><pre>map dc0 192.168.1.0/24 -&gt; 0/32 portmap tcp/udp auto</pre></div></div><div class=paragraph><p>The second method is to use a pool of public addresses. This is useful when there are too many LAN addresses to fit into a single public address and a block of public IP addresses is available. These public addresses can be used as a pool from which NAT selects an IP address as a packet’s address is mapped on its way out.</p></div><div class=paragraph><p>The range of public IP addresses can be specified using a netmask or CIDR notation. These two rules are equivalent:</p></div><div class="literalblock programlisting"><div class=content><pre>map dc0 192.168.1.0/24 -&gt; 204.134.75.0/255.255.255.0
map dc0 192.168.1.0/24 -&gt; 204.134.75.0/24</pre></div></div><div class=paragraph><p>A common practice is to have a publically accessible web server or mail server segregated to an internal network segment. The traffic from these servers still has to undergo NAT, but port redirection is needed to direct inbound traffic to the correct server. For example, to map a web server using the internal address <code>10.0.10.25</code> to its public IP address of <code>20.20.20.5</code>, use this rule:</p></div><div class="literalblock programlisting"><div class=content><pre>rdr dc0 20.20.20.5/32 port 80 -&gt; 10.0.10.25 port 80</pre></div></div><div class=paragraph><p>If it is the only web server, this rule would also work as it redirects all external HTTP requests to <code>10.0.10.25</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>rdr dc0 0.0.0.0/0 port 80 -&gt; 10.0.10.25 port 80</pre></div></div><div class=paragraph><p>IPF has a built in FTP proxy which can be used with NAT. It monitors all outbound traffic for active or passive FTP connection requests and dynamically creates temporary filter rules containing the port number used by the FTP data channel. This eliminates the need to open large ranges of high order ports for FTP connections.</p></div><div class=paragraph><p>In this example, the first rule calls the proxy for outbound FTP traffic from the internal LAN. The second rule passes the FTP traffic from the firewall to the Internet, and the third rule handles all non-FTP traffic from the internal LAN:</p></div><div class="literalblock programlisting"><div class=content><pre>map dc0 10.0.10.0/29 -&gt; 0/32 proxy port 21 ftp/tcp
map dc0 0.0.0.0/0 -&gt; 0/32 proxy port 21 ftp/tcp
map dc0 10.0.10.0/29 -&gt; 0/32</pre></div></div><div class=paragraph><p>The FTP <code>map</code> rules go before the NAT rule so that when a packet matches an FTP rule, the FTP proxy creates temporary filter rules to let the FTP session packets pass and undergo NAT. All LAN packets that are not FTP will not match the FTP rules but will undergo NAT if they match the third rule.</p></div><div class=paragraph><p>Without the FTP proxy, the following firewall rules would instead be needed. Note that without the proxy, all ports above <code>1024</code> need to be allowed:</p></div><div class="literalblock programlisting"><div class=content><pre># Allow out LAN PC client FTP to public Internet
# Active and passive modes
pass out quick on rl0 proto tcp from any to any port = 21 flags S keep state

# Allow out passive mode data channel high order port numbers
pass out quick on rl0 proto tcp from any to any port &gt; 1024 flags S keep state

# Active mode let data channel in from FTP server
pass in quick on rl0 proto tcp from any to any port = 20 flags S keep state</pre></div></div><div class=paragraph><p>Whenever the file containing the NAT rules is edited, run <code>ipnat</code> with <code>-CF</code> to delete the current NAT rules and flush the contents of the dynamic translation table. Include <code>-f</code> and specify the name of the NAT ruleset to load:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ipnat -CF -f /etc/ipnat.rules</span></code></pre></div></div><div class=paragraph><p>To display the NAT statistics:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ipnat -s</span></code></pre></div></div><div class=paragraph><p>To list the NAT table’s current mappings:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ipnat -l</span></code></pre></div></div><div class=paragraph><p>To turn verbose mode on and display information relating to rule processing and active rules and table entries:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ipnat -v</span></code></pre></div></div></div><div class=sect2><h3 id=_檢視_ipf_統計資訊>30.5.5. 檢視 IPF 統計資訊<a class=anchor href=#_檢視_ipf_統計資訊></a></h3><div class=paragraph><p>IPF includes <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfstat&amp;sektion=8&amp;format=html">ipfstat(8)</a> which can be used to retrieve and display statistics which are gathered as packets match rules as they go through the firewall. Statistics are accumulated since the firewall was last started or since the last time they were reset to zero using <code>ipf -Z</code>.</p></div><div class=paragraph><p>The default <code>ipfstat</code> output looks like this:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>input packets: blocked 99286 passed 1255609 nomatch 14686 counted 0
 output packets: blocked 4200 passed 1284345 nomatch 14687 counted 0
 input packets logged: blocked 99286 passed 0
 output packets logged: blocked 0 passed 0
 packets logged: input 0 output 0
 log failures: input 3898 output 0
 fragment state<span class=o>(</span><span class=k>in</span><span class=o>)</span>: kept 0 lost 0
 fragment state<span class=o>(</span>out<span class=o>)</span>: kept 0 lost 0
 packet state<span class=o>(</span><span class=k>in</span><span class=o>)</span>: kept 169364 lost 0
 packet state<span class=o>(</span>out<span class=o>)</span>: kept 431395 lost 0
 ICMP replies: 0 TCP RSTs sent: 0
 Result cache hits<span class=o>(</span><span class=k>in</span><span class=o>)</span>: 1215208 <span class=o>(</span>out<span class=o>)</span>: 1098963
 IN Pullups succeeded: 2 failed: 0
 OUT Pullups succeeded: 0 failed: 0
 Fastroute successes: 0 failures: 0
 TCP <span class=nb>cksum </span>fails<span class=o>(</span><span class=k>in</span><span class=o>)</span>: 0 <span class=o>(</span>out<span class=o>)</span>: 0
 Packet log flags <span class=nb>set</span>: <span class=o>(</span>0<span class=o>)</span></code></pre></div></div><div class=paragraph><p>Several options are available. When supplied with either <code>-i</code> for inbound or <code>-o</code> for outbound, the command will retrieve and display the appropriate list of filter rules currently installed and in use by the kernel. To also see the rule numbers, include <code>-n</code>. For example, <code>ipfstat -on</code> displays the outbound rules table with rule numbers:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>@1 pass out on xl0 from any to any
@2 block out on dc0 from any to any
@3 pass out quick on dc0 proto tcp/udp from any to any keep state</code></pre></div></div><div class=paragraph><p>Include <code>-h</code> to prefix each rule with a count of how many times the rule was matched. For example, <code>ipfstat -oh</code> displays the outbound internal rules table, prefixing each rule with its usage count:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>2451423 pass out on xl0 from any to any
354727 block out on dc0 from any to any
430918 pass out quick on dc0 proto tcp/udp from any to any keep state</code></pre></div></div><div class=paragraph><p>To display the state table in a format similar to <a href="https://man.freebsd.org/cgi/man.cgi?query=top&amp;sektion=1&amp;format=html">top(1)</a>, use <code>ipfstat -t</code>. When the firewall is under attack, this option provides the ability to identify and see the attacking packets. The optional sub-flags give the ability to select the destination or source IP, port, or protocol to be monitored in real time. Refer to <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfstat&amp;sektion=8&amp;format=html">ipfstat(8)</a> for details.</p></div></div><div class=sect2><h3 id=_ipf_日誌>30.5.6. IPF 日誌<a class=anchor href=#_ipf_日誌></a></h3><div class=paragraph><p>IPF provides <code>ipmon</code>, which can be used to write the firewall’s logging information in a human readable format. It requires that <code>options IPFILTER_LOG</code> be first added to a custom kernel using the instructions in <a href=../kernelconfig/#kernelconfig>設定 FreeBSD 核心</a>.</p></div><div class=paragraph><p>This command is typically run in daemon mode in order to provide a continuous system log file so that logging of past events may be reviewed. Since FreeBSD has a built in <a href="https://man.freebsd.org/cgi/man.cgi?query=syslogd&amp;sektion=8&amp;format=html">syslogd(8)</a> facility to automatically rotate system logs, the default <span class=filename>rc.conf</span><code>ipmon_flags</code> statement uses <code>-Ds</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>ipmon_flags=&#34;-Ds&#34; # D = start as daemon
                  # s = log to syslog
                  # v = log tcp window, ack, seq
                  # n = map IP &amp; port to names</pre></div></div><div class=paragraph><p>Logging provides the ability to review, after the fact, information such as which packets were dropped, what addresses they came from, and where they were going. This information is useful in tracking down attackers.</p></div><div class=paragraph><p>Once the logging facility is enabled in <span class=filename>rc.conf</span> and started with <code>service ipmon start</code>, IPF will only log the rules which contain the <code>log</code> keyword. The firewall administrator decides which rules in the ruleset should be logged and normally only deny rules are logged. It is customary to include the <code>log</code> keyword in the last rule in the ruleset. This makes it possible to see all the packets that did not match any of the rules in the ruleset.</p></div><div class=paragraph><p>By default, <code>ipmon -Ds</code> mode uses <code>local0</code> as the logging facility. The following logging levels can be used to further segregate the logged data:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>LOG_INFO - packets logged using the <span class=s2>&#34;log&#34;</span> keyword as the action rather than pass or block.
LOG_NOTICE - packets logged which are also passed
LOG_WARNING - packets logged which are also blocked
LOG_ERR - packets which have been logged and which can be considered short due to an incomplete header</code></pre></div></div><div class=paragraph><p>In order to setup IPF to log all data to <span class=filename>/var/log/ipfilter.log</span>, first create the empty file:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># touch /var/log/ipfilter.log</span></code></pre></div></div><div class=paragraph><p>Then, to write all logged messages to the specified file, add the following statement to <span class=filename>/etc/syslog.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>local0.* /var/log/ipfilter.log</pre></div></div><div class=paragraph><p>To activate the changes and instruct <a href="https://man.freebsd.org/cgi/man.cgi?query=syslogd&amp;sektion=8&amp;format=html">syslogd(8)</a> to read the modified <span class=filename>/etc/syslog.conf</span>, run <code>service syslogd reload</code>.</p></div><div class=paragraph><p>Do not forget to edit <span class=filename>/etc/newsyslog.conf</span> to rotate the new log file.</p></div><div class=paragraph><p>Messages generated by <code>ipmon</code> consist of data fields separated by white space. Fields common to all messages are:</p></div><div class="olist arabic"><ol class=arabic><li><p>The date of packet receipt.</p></li><li><p>The time of packet receipt. This is in the form HH:MM:SS.F, for hours, minutes, seconds, and fractions of a second.</p></li><li><p>The name of the interface that processed the packet.</p></li><li><p>The group and rule number of the rule in the format <code>@0:17</code>.</p></li><li><p>The action: <code>p</code> for passed, <code>b</code> for blocked, <code>S</code> for a short packet, <code>n</code> did not match any rules, and <code>L</code> for a log rule.</p></li><li><p>The addresses written as three fields: the source address and port separated by a comma, the → symbol, and the destination address and port. For example: <code>209.53.17.22,80 → 198.73.220.17,1722</code>.</p></li><li><p><code>PR</code> followed by the protocol name or number: for example, <code>PR tcp</code>.</p></li><li><p><code>len</code> followed by the header length and total length of the packet: for example, <code>len 20 40</code>.</p></li></ol></div><div class=paragraph><p>If the packet is a TCP packet, there will be an additional field starting with a hyphen followed by letters corresponding to any flags that were set. Refer to <a href="https://man.freebsd.org/cgi/man.cgi?query=ipf&amp;sektion=5&amp;format=html">ipf(5)</a> for a list of letters and their flags.</p></div><div class=paragraph><p>If the packet is an ICMP packet, there will be two fields at the end: the first always being "icmp" and the next being the ICMP message and sub-message type, separated by a slash. For example: <code>icmp 3/3</code> for a port unreachable message.</p></div></div></div></div><div class=sect1><h2 id=firewalls-blacklistd>30.6. Blacklistd<a class=anchor href=#firewalls-blacklistd></a></h2><div class=sectionbody><div class=paragraph><p>Blacklistd is a daemon listening to sockets to receive notifications from other daemons about connection attempts that failed or were successful. It is most widely used in blocking too many connection attempts on open ports. A prime example is SSH running on the internet getting a lot of requests from bots or scripts trying to guess passwords and gain access. Using blacklistd, the daemon can notify the firewall to create a filter rule to block excessive connection attempts from a single source after a number of tries. Blacklistd was first developed on NetBSD and appeared there in version 7. FreeBSD 11 imported blacklistd from NetBSD.</p></div><div class=paragraph><p>This chapter describes how to set up blacklistd, configure it, and provides examples on how to use it. Readers should be familiar with basic firewall concepts like rules. For details, refer to the firewall chapter. PF is used in the examples, but other firewalls available on FreeBSD should be able to work with blacklistd, too.</p></div><div class=sect2><h3 id=_開啟_blacklistd>30.6.1. 開啟 Blacklistd<a class=anchor href=#_開啟_blacklistd></a></h3><div class=paragraph><p>The main configuration for blacklistd is stored in <a href="https://man.freebsd.org/cgi/man.cgi?query=blacklistd.conf&amp;sektion=5&amp;format=html">blacklistd.conf(5)</a>. Various command line options are also available to change blacklistd’s run-time behavior. Persistent configuration across reboots should be stored in <span class=filename>/etc/blacklistd.conf</span>. To enable the daemon during system boot, add a <code>blacklistd_enable</code> line to <span class=filename>/etc/rc.conf</span> like this:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysrc blacklistd_enable=yes</span></code></pre></div></div><div class=paragraph><p>To start the service manually, run this command:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service blacklistd start</span></code></pre></div></div></div><div class=sect2><h3 id=_建立_blacklistd_規則集>30.6.2. 建立 Blacklistd 規則集<a class=anchor href=#_建立_blacklistd_規則集></a></h3><div class=paragraph><p>Rules for blacklistd are configured in <a href="https://man.freebsd.org/cgi/man.cgi?query=blacklistd.conf&amp;sektion=5&amp;format=html">blacklistd.conf(5)</a> with one entry per line. Each rule contains a tuple separated by spaces or tabs. Rules either belong to a <code>local</code> or a <code>remote</code>, which applies to the machine where blacklistd is running or an outside source, respectively.</p></div><div class=sect3><h4 id=_本地規則>30.6.2.1. 本地規則<a class=anchor href=#_本地規則></a></h4><div class=paragraph><p>An example blacklistd.conf entry for a local rule looks like this:</p></div><div class="literalblock programlisting"><div class=content><pre>[local]
ssh             stream  *       *               *       3       24h</pre></div></div><div class=paragraph><p>All rules that follow the <code>[local]</code> section are treated as local rules (which is the default), applying to the local machine. When a <code>[remote]</code> section is encountered, all rules that follow it are handled as remote machine rules.</p></div><div class=paragraph><p>Seven fields define a rule separated by either tabs or spaces. The first four fields identify the traffic that should be blacklisted. The three fields that follow define backlistd’s behavior. Wildcards are denoted as asterisks (<code>*</code>), matching anything in this field. The first field defines the location. In local rules, these are the network ports. The syntax for the location field is as follows:</p></div><div class="literalblock programlisting"><div class=content><pre>[address|interface][/mask][:port]</pre></div></div><div class=paragraph><p>Adressses can be specified as IPv4 in numeric format or IPv6 in square brackets. An interface name like <code><em>em0</em></code> can also be used.</p></div><div class=paragraph><p>The socket type is defined by the second field. TCP sockets are of type <code>stream</code>, whereas UDP is denoted as <code>dgram</code>. The example above uses TCP, since SSH is using that protocol.</p></div><div class=paragraph><p>A protocol can be used in the third field of a blacklistd rule. The following protocols can be used: <code>tcp</code>, <code>udp</code>, <code>tcp6</code>, <code>udp6</code>, or numeric. A wildcard, like in the example, is typically used to match all protocols unless there is a reason to distinguish traffic by a certain protocol.</p></div><div class=paragraph><p>In the fourth field, the effective user or owner of the daemon process that is reporting the event is defined. The username or UID can be used here, as well as a wildcard (see example rule above).</p></div><div class=paragraph><p>The packet filter rule name is declared by the fifth field, which starts the behavior part of the rule. By default, blacklistd puts all blocks under a pf anchor called <code>blacklistd</code> in <span class=filename>pf.conf</span> like this:</p></div><div class="literalblock programlisting"><div class=content><pre>anchor &#34;blacklistd/*&#34; in on $ext_if
block in
pass out</pre></div></div><div class=paragraph><p>For separate blacklists, an anchor name can be used in this field. In other cases, the wildcard will suffice. When a name starts with a hyphen (<code>-</code>) it means that an anchor with the default rule name prepended should be used. A modified example from the above using the hyphen would look like this:</p></div><div class="literalblock programlisting"><div class=content><pre>ssh             stream  *       *               -ssh       3       24h</pre></div></div><div class=paragraph><p>With such a rule, any new blacklist rules are added to an anchor called <code>blacklistd-ssh</code>.</p></div><div class=paragraph><p>To block whole subnets for a single rule violation, a <code>/</code> in the rule name can be used. This causes the remaining portion of the name to be interpreted as the mask to be applied to the address specified in the rule. For example, this rule would block every address adjoining <code>/24</code>.</p></div><div class="literalblock programlisting"><div class=content><pre>22              stream  tcp       *               */24    3       24h</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>It is important to specify the proper protocol here. IPv4 and IPv6 treat /24 differently, that is the reason why <code>*</code> cannot be used in the third field for this rule.</p></div></td></tr></tbody></table></div><div class=paragraph><p>This rule defines that if any one host in that network is misbehaving, everything else on that network will be blocked, too.</p></div><div class=paragraph><p>The sixth field, called <code>nfail</code>, sets the number of login failures required to blacklist the remote IP in question. When a wildcard is used at this position, it means that blocks will never happen. In the example rule above, a limit of three is defined meaning that after three attempts to log into SSH on one connection, the IP is blocked.</p></div><div class=paragraph><p>The last field in a blacklistd rule definition specifies how long a host is blacklisted. The default unit is seconds, but suffixes like <code>m</code>, <code>h</code>, and <code>d</code> can also be specified for minutes, hours, and days, respectively.</p></div><div class=paragraph><p>The example rule in its entirety means that after three times authenticating to SSH will result in a new PF block rule for that host. Rule matches are performed by first checking local rules one after another, from most specific to least specific. When a match occurs, the <code>remote</code> rules are applied and the name, <code>nfail</code>, and disable fields are changed by the <code>remote</code> rule that matched.</p></div></div><div class=sect3><h4 id=_遠端規則>30.6.2.2. 遠端規則<a class=anchor href=#_遠端規則></a></h4><div class=paragraph><p>Remote rules are used to specify how blacklistd changes its behavior depending on the remote host currently being evaluated. Each field in a remote rule is the same as in a local rule. The only difference is in the way blacklistd is using them. To explain it, this example rule is used:</p></div><div class="literalblock programlisting"><div class=content><pre>[remote]
203.0.113.128/25 *      *       *               =/25    =       48h</pre></div></div><div class=paragraph><p>The address field can be an IP address (either v4 or v6), a port or both. This allows setting special rules for a specific remote address range like in this example. The fields for type, protocol and owner are identically interpreted as in the local rule.</p></div><div class=paragraph><p>The name fields is different though: the equal sign (<code>=</code>) in a remote rule tells blacklistd to use the value from the matching local rule. It means that the firewall rule entry is taken and the <code>/25</code> prefix (a netmask of <code>255.255.255.128</code>) is added. When a connection from that address range is blacklisted, the entire subnet is affected. A PF anchor name can also be used here, in which case blacklistd will add rules for this address block to the anchor of that name. The default table is used when a wildcard is specified.</p></div><div class=paragraph><p>A custom number of failures in the <code>nfail</code> column can be defined for an address. This is useful for exceptions to a specific rule, to maybe allow someone a less strict application of rules or a bit more leniency in login tries. Blocking is disabled when an asterisk is used in this sixth field.</p></div><div class=paragraph><p>Remote rules allow a stricter enforcement of limits on attempts to log in compared to attempts coming from a local network like an office.</p></div></div></div><div class=sect2><h3 id=_blacklistd_客戶端設定>30.6.3. Blacklistd 客戶端設定<a class=anchor href=#_blacklistd_客戶端設定></a></h3><div class=paragraph><p>There are a few software packages in FreeBSD that can utilize blacklistd’s functionality. The two most prominent ones are <a href="https://man.freebsd.org/cgi/man.cgi?query=ftpd&amp;sektion=8&amp;format=html">ftpd(8)</a> and <a href="https://man.freebsd.org/cgi/man.cgi?query=sshd&amp;sektion=8&amp;format=html">sshd(8)</a> to block excessive connection attempts. To activate blacklistd in the SSH daemon, add the following line to <span class=filename>/etc/ssh/sshd_config</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>UseBlacklist yes</pre></div></div><div class=paragraph><p>接著重新啟動 sshd 來使變更生效。</p></div><div class=paragraph><p>Blacklisting for <a href="https://man.freebsd.org/cgi/man.cgi?query=ftpd&amp;sektion=8&amp;format=html">ftpd(8)</a> is enabled using <code>-B</code>, either in <span class=filename>/etc/inetd.conf</span> or as a flag in <span class=filename>/etc/rc.conf</span> like this:</p></div><div class="literalblock programlisting"><div class=content><pre>ftpd_flags=&#34;-B&#34;</pre></div></div><div class=paragraph><p>That is all that is needed to make these programs talk to blacklistd.</p></div></div><div class=sect2><h3 id=_blacklistd_管理>30.6.4. Blacklistd 管理<a class=anchor href=#_blacklistd_管理></a></h3><div class=paragraph><p>Blacklistd provides the user with a management utility called <a href="https://man.freebsd.org/cgi/man.cgi?query=blacklistctl&amp;sektion=8&amp;format=html">blacklistctl(8)</a>. It displays blocked addresses and networks that are blacklisted by the rules defined in <a href="https://man.freebsd.org/cgi/man.cgi?query=blacklistd.conf&amp;sektion=5&amp;format=html">blacklistd.conf(5)</a>. To see the list of currently blocked hosts, use <code>dump</code> combined with <code>-b</code> like this.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># blacklistctl dump -b</span>
      address/ma:port <span class=nb>id      </span>nfail   last access
213.0.123.128/25:22   OK      6/3     2019/06/08 14:30:19</code></pre></div></div><div class=paragraph><p>This example shows that there were 6 out of three permitted attempts on port 22 coming from the address range <code>213.0.123.128/25</code>. There are more attempts listed than are allowed because SSH allows a client to try multiple logins on a single TCP connection. A connection that is currently going on is not stopped by blacklistd. The last connection attempt is listed in the <code>last access</code> column of the output.</p></div><div class=paragraph><p>To see the remaining time that this host will be on the blacklist, add <code>-r</code> to the previous command.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># blacklistctl dump -br</span>
      address/ma:port <span class=nb>id      </span>nfail   remaining <span class=nb>time
</span>213.0.123.128/25:22   OK      6/3     36s</code></pre></div></div><div class=paragraph><p>In this example, there are 36s seconds left until this host will not be blocked any more.</p></div></div><div class=sect2><h3 id=_從封鎖清單移除主機>30.6.5. 從封鎖清單移除主機<a class=anchor href=#_從封鎖清單移除主機></a></h3><div class=paragraph><p>Sometimes it is necessary to remove a host from the block list before the remaining time expires. Unfortunately, there is no functionality in blacklistd to do that. However, it is possible to remove the address from the PF table using pfctl. For each blocked port, there is a child anchor inside the blacklistd anchor defined in <span class=filename>/etc/pf.conf</span>. For example, if there is a child anchor for blocking port 22 it is called <code>blacklistd/22</code>. There is a table inside that child anchor that contains the blocked addresses. This table is called port followed by the port number. In this example, it would be called <code>port22</code>. With that information at hand, it is now possible to use <a href="https://man.freebsd.org/cgi/man.cgi?query=pfctl&amp;sektion=8&amp;format=html">pfctl(8)</a> to display all addresses listed like this:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pfctl -a blacklistd/22 -t port22 -T show</span>
...
213.0.123.128/25
...</code></pre></div></div><div class=paragraph><p>After identifying the address to be unblocked from the list, the following command removes it from the list:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pfctl -a blacklistd/22 -T delete 213.0.123.128/25</span></code></pre></div></div><div class=paragraph><p>The address is now removed from PF, but will still show up in the blacklistctl list, since it does not know about any changes made in PF. The entry in blacklistd’s database will eventually expire and be removed from its output eventually. The entry will be added again if the host is matching one of the block rules in blacklistd again.</p></div></div></div></div></div><hr><div class=last-modified><p><strong>最後修改於</strong>: March 9, 2024 由 <a href="https://cgit.freebsd.org/doc/commit/?id=6199af92e7" target=_blank>Danilo G. Baio</a></p></div><div class=buttons><div class=prev><i class="fa fa-angle-left" aria-hidden=true title=Prev></i><div class=container><a href=http://172.16.201.134:1313/zh-tw/books/handbook/network-servers class=direction>Prev</a></div></div><div class=home><i class="fa fa-home" aria-hidden=true title=Home></i><div class=container><a href=../ class=direction>Home</a></div></div><div class=next><div class=container><a href=http://172.16.201.134:1313/zh-tw/books/handbook/advanced-networking class=direction>Next</a></div><i class="fa fa-angle-right" aria-hidden=true title=Next></i></div></div><label class="hidden book-menu-overlay" for=menu-control></label></div><aside class=toc><div class=toc-content><h3>目錄</h3><nav id=TableOfContents><ul><li><a href=#firewalls-intro>30.1. 概述</a></li><li><a href=#firewalls-concepts>30.2. 防火牆概念</a></li><li><a href=#firewalls-pf>30.3. PF</a></li><li><a href=#firewalls-ipfw>30.4. IPFW</a></li><li><a href=#firewalls-ipf>30.5. IPFILTER (IPF)</a></li><li><a href=#firewalls-blacklistd>30.6. Blacklistd</a></li></ul></nav><hr><div class=resources><h3>資源</h3><ul class=contents><li><i class="fa fa-file-pdf-o" aria-hidden=true title="下載 PDF"></i><a href=https://download.freebsd.org/doc/zh-tw/books/handbook/handbook_zh-tw.pdf>下載 PDF</a></li><li><i class="fa fa-pencil-square-o" aria-hidden=true title=編輯此頁></i><a href=https://github.com/freebsd/freebsd-doc/blob/main/documentation/content/zh-tw/_index target=_blank>編輯此頁</a></li></ul></div></div></aside><a class=to-top href=#top><i class="fa fa-arrow-circle-up" aria-hidden=true></i></a></main><footer><div class=footer-container><section class=logo-column><img src=http://172.16.201.134:1313/images/FreeBSD-colors.svg width=160 height=50 alt="FreeBSD logo"><div class=options-container><div class=language-container><a id=languages href=http://172.16.201.134:1313/zh-tw/languages><img src=http://172.16.201.134:1313/images/language.png class=language-image alt=選擇語言>
<span>繁體中文</span></a></div><div class=theme-container><select id=theme-chooser><option value=theme-system>System</option><option value=theme-light>淺色</option><option value=theme-dark>深色</option><option value=theme-high-contrast>高對比</option></select></div></div></section><section class=about-column><h3 class=column-title>About</h3><ul class=column-elements-container><li><a href=https://www.freebsd.org/about/ target=_blank class=column-element>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/ target=_blank class=column-element>FreeBSD Foundation</a></li><li><a href=https://www.freebsd.org/where/ target=_blank class=column-element>Get FreeBSD</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct target=_blank class=column-element>Code of Conduct</a></li><li><a href=https://www.freebsd.org/security/ target=_blank class=column-element>Security Advisories</a></li></ul></section><section class=documentation-column><h3 class=column-title>Documentation</h3><ul class=column-elements-container><li><a href=/zh-tw class=column-element>Documentation portal</a></li><li><a href=https://man.FreeBSD.org target=_blank class=column-element>Manual pages</a></li><li><a href=https://papers.FreeBSD.org target=_blank class=column-element>Presentations and papers</a></li><li><a href=https://docs-archive.freebsd.org/doc/ target=_blank class=column-element>Previous versions</a></li><li><a href=https://docs-archive.freebsd.org/44doc/ target=_blank class=column-element>4.4BSD Documents</a></li><li><a href=https://wiki.freebsd.org/ target=_blank class=column-element>Wiki</a></li></ul></section><section class=community-column><h3 class=column-title>Community</h3><ul class=column-elements-container><li><a href=http://172.16.201.134:1313/zh-tw/articles/contributing class=column-element>Get involved</a></li><li><a href=https://forums.freebsd.org/ target=_blank class=column-element>Community forum</a></li><li><a href=https://lists.freebsd.org/ target=_blank class=column-element>Mailing lists</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank class=column-element>IRC Channels</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank class=column-element>Bug Tracker</a></li></ul></section><section class=legal-column><h3 class=column-title>Legal</h3><ul class=column-elements-container><li><a href=https://freebsdfoundation.org/donate/ target=_blank class=column-element>Donations</a></li><li><a href=https://www.freebsd.org/copyright/freebsd-license/ target=_blank class=column-element>Licensing</a></li><li><a href=https://www.freebsd.org/privacy/ target=_blank class=column-element>Privacy Policy</a></li><li><a href=https://www.freebsd.org/copyright/ target=_blank class=column-element>Legal notices</a></li></ul></section><section class=copyright-column><p>&copy; 1994-2024 The FreeBSD Project. All rights reserved</p><span>Made with <span class=heart>♥</span> by the FreeBSD Community</span></section></div></footer></body></html>