<!doctype html><html class=theme-light lang=zh-tw><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content><meta name=keywords content><meta name=copyright content="1995-2024 The FreeBSD Foundation"><link rel=canonical href=https://docs.freebsd.org/zh-tw/books/handbook/config/><title>章 11. 設定與調校 | FreeBSD Documentation Portal</title>
<meta name=theme-color content="#790000"><meta name=color-scheme content="system light dark high-contrast"><link rel="shortcut icon" href=https://docs.freebsd.org/favicon.ico><link rel=stylesheet href=https://docs.freebsd.org/styles/main.min.css><link rel=stylesheet href=https://docs.freebsd.org/css/font-awesome-min.css><script defer src=/js/theme-chooser.min.js></script><script defer src=/js/copy-clipboard.min.js></script><script defer src=/js/search.min.js></script><meta name=twitter:card content="summary"><meta name=twitter:domain content="docs.FreeBSD.org"><meta name=twitter:site content="@freebsd"><meta name=twitter:url content="https://twitter.com/freebsd"><meta property="og:title" content="章 11. 設定與調校"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:image" content="https://docs.freebsd.org/favicon.ico"><meta property="og:image:alt" content="FreeBSD Logo"><meta property="og:locale" content="zh-tw"><meta property="og:url" content="https://docs.freebsd.org/zh-tw/books/handbook/config/"><meta property="og:site_name" content="FreeBSD Documentation Portal"><script type=application/ld+json>{"@context":"http://schema.org","@type":"Article","url":"https:\/\/docs.freebsd.org\/zh-tw\/books\/handbook\/config\/","name":"FreeBSD Documentation Portal","headline":"FreeBSD Documentation Portal","description":"FreeBSD Documentation Portal"}</script></head><body><header><div class=header-container><div class=logo-menu-bars-container><a href=https://www.FreeBSD.org class=logo><img src=https://docs.freebsd.org/images/FreeBSD-monochromatic.svg width=160 height=50 alt="FreeBSD logo">
</a><label class=menu-bars for=menu-bars><i class="fa fa-bars" aria-hidden=true></i></label></div><input id=menu-bars type=checkbox><nav><ul class=menu><li class=menu-item><input id=about type=checkbox>
<a href=# aria-label="Navigate to About section"><label class=menu-item-description for=about>About
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/about/ target=_blank>About</a></li><li><a href=https://www.freebsd.org/about/ target=_blank>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/about-us/about-the-foundation/ target=_blank>FreeBSD Foundation</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct/ target=_blank>Code of Conduct</a></li></ul></li><li class=menu-item><input id=download type=checkbox>
<a href=# aria-label="Navigate to get FreeBSD section"><label class=menu-item-description for=download>Get FreeBSD
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/where/ target=_blank>Get FreeBSD</a></li><li><a href=https://www.freebsd.org/releases/ target=_blank>Release Information</a></li><li><a href=https://www.freebsd.org/releng/ target=_blank>Release Engineering</a></li><li><a href=https://www.freebsd.org/security/ target=_blank>Security Advisories</a></li></ul></li><li class=menu-item><input id=documentation type=checkbox>
<a href=# aria-label="Navigate to get Documentation section"><label class=menu-item-description for=documentation>Documentation
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=/zh-tw>Documentation portal</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook>FreeBSD Handbook</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/porters-handbook>Porter's Handbook</a></li><li><a href=https://docs.FreeBSD.org/en/books/fdp-primer>Documentation Project Handbook</a></li><li><a href=https://man.FreeBSD.org target=_blank>Manual pages</a></li><li><a href=https://papers.FreeBSD.org target=_blank>Presentations and papers</a></li><li><a href=https://wiki.FreeBSD.org target=_blank>Wiki</a></li><li><a href=https://docs.freebsd.org/zh-tw/books>Books</a></li><li><a href=https://docs.freebsd.org/zh-tw/articles>Articles</a></li></ul></li><li class=menu-item><input id=community type=checkbox>
<a href=# aria-label="Navigate to get Community section"><label class=menu-item-description for=community>Community
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/community/>Community</a></li><li><a href=https://docs.freebsd.org/zh-tw/articles/contributing>Get involved</a></li><li><a href=https://forums.freebsd.org/ target=_blank>Forum</a></li><li><a href=https://lists.freebsd.org/ target=_blank>Mailing lists</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank>IRC Channels</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank>Bug Tracker</a></li><li><a href=https://www.freebsd.org/support/ target=_blank>Support</a></li></ul></li></ul></nav><div class=search-donate-container><form class=search method=get id=search-header-form action=https://docs.freebsd.org/search name=search-header-form><input type=hidden name=DB value=zh-tw>
<input id=words name=P type=text size=20 maxlength=255>
<button>
<i class="fa fa-search" aria-hidden=true></i></button></form><div class=donate><a href=https://freebsdfoundation.org/donate/ target=_blank><span class=heart>♥</span>
Donate</a></div></div></div></header><input type=checkbox class="hidden toggle" id=menu-control><main class=main-wrapper-book><a id=top></a><aside class=book-menu><div class=book-menu-content><input id=search-book type=text placeholder=Search aria-label=Search maxlength=128><nav id=MenuContents><ul><li><input type=checkbox id=chapter-eb2a98ce203d8afd517726e6d8776be3 class=toggle>
<label class="icon cursor" for=chapter-eb2a98ce203d8afd517726e6d8776be3><a role=button></a></label><a href=https://docs.freebsd.org/zh-tw/books/handbook/preface/>序</a><ul><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/preface/#preface-audience>給讀者的話</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/preface/#preface-changes-from3>自第三版後的主要修訂</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/preface/#preface-changes-from2>自第二版後的主要修訂 (2004)</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/preface/#preface-changes>自第一版後的主要修訂 (2001)</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/preface/#preface-overview>本書架構</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/preface/#preface-conv>本書的編排體裁</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/preface/#preface-acknowledgements>銘謝</a></li></ul></li><li><input type=checkbox id=chapter-14a525fce014b90b8a458a894818255a class=toggle>
<label for=chapter-14a525fce014b90b8a458a894818255a><a role=button></a></label><a href=https://docs.freebsd.org/zh-tw/books/handbook/parti/>部 I. 入門</a></li><li><input type=checkbox id=chapter-f9c9f3451644df30d224350da97d5da6 class=toggle>
<label class="icon cursor" for=chapter-f9c9f3451644df30d224350da97d5da6><a role=button></a></label><a href=https://docs.freebsd.org/zh-tw/books/handbook/introduction/>章 1. 簡介</a><ul><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/introduction/#introduction-synopsis>1.1. 概述</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/introduction/#nutshell>1.2. 歡迎使用 FreeBSD！</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/introduction/#history>1.3. 關於 FreeBSD 計劃</a></li></ul></li><li><input type=checkbox id=chapter-f693a3fa687a72d63ec8129ee302d664 class=toggle>
<label class="icon cursor" for=chapter-f693a3fa687a72d63ec8129ee302d664><a role=button></a></label><a href=https://docs.freebsd.org/zh-tw/books/handbook/bsdinstall/>章 2. 安裝 FreeBSD</a><ul><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/bsdinstall/#bsdinstall-synopsis>2.1. 概述</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/bsdinstall/#bsdinstall-hardware>2.2. 最低硬體需求</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/bsdinstall/#bsdinstall-pre>2.3. 安裝前準備工作</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/bsdinstall/#bsdinstall-start>2.4. 開始安裝</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/bsdinstall/#using-bsdinstall>2.5. 使用 bsdinstall</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/bsdinstall/#bsdinstall-partitioning>2.6. 配置磁碟空間</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/bsdinstall/#bsdinstall-final-warning>2.7. 確認安裝</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/bsdinstall/#bsdinstall-post>2.8. 安裝後注意事項</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/bsdinstall/#bsdinstall-install-trouble>2.9. 疑難排解</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/bsdinstall/#using-live-cd>2.10. 使用 Live CD</a></li></ul></li><li><input type=checkbox id=chapter-9f6db261075f578742036fcc6000eecd class=toggle>
<label class="icon cursor" for=chapter-9f6db261075f578742036fcc6000eecd><a role=button></a></label><a href=https://docs.freebsd.org/zh-tw/books/handbook/basics/>章 3. FreeBSD 基礎</a><ul><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/basics/#basics-synopsis>3.1. 概述</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/basics/#consoles>3.2. 虛擬 Console 與終端機</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/basics/#users-synopsis>3.3. 使用者與基礎帳號管理</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/basics/#permissions>3.4. 權限</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/basics/#dirstructure>3.5. 目錄結構</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/basics/#disk-organization>3.6. 磁碟組織</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/basics/#mount-unmount>3.7. 掛載與卸載檔案系統</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/basics/#basics-processes>3.8. 程序與 Daemon</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/basics/#shells>3.9. Shell</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/basics/#editors>3.10. 文字編輯器</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/basics/#basics-devices>3.11. 裝置及裝置節點</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/basics/#basics-more-information>3.12. 操作手冊</a></li></ul></li><li><input type=checkbox id=chapter-01c5707e95d14c0ff84bf62600c958d1 class=toggle>
<label class="icon cursor" for=chapter-01c5707e95d14c0ff84bf62600c958d1><a role=button></a></label><a href=https://docs.freebsd.org/zh-tw/books/handbook/ports/>章 4. 安裝應用程式：套件與 Port</a><ul><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/ports/#ports-synopsis>4.1. 概述</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/ports/#ports-overview>4.2. 安裝軟體的概要</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/ports/#ports-finding-applications>4.3. 搜尋軟體</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/ports/#pkgng-intro>4.4. 使用 pkg 管理 Binary 套件</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/ports/#ports-using>4.5. 使用 Port 套件集</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/ports/#ports-poudriere>4.6. 使用 Poudriere 編譯套件</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/ports/#ports-nextsteps>4.7. 安裝後的注意事項</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/ports/#ports-broken>4.8. 處理損壞的 Port</a></li></ul></li><li><input type=checkbox id=chapter-3405c00581365a8b5d16af70fe4d1b72 class=toggle>
<label class="icon cursor" for=chapter-3405c00581365a8b5d16af70fe4d1b72><a role=button></a></label><a href=https://docs.freebsd.org/zh-tw/books/handbook/x11/>章 5. X Window 系統</a><ul><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/x11/#x11-synopsis>5.1. 概述</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/x11/#x-understanding>5.2. 術語</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/x11/#x-install>5.3. 安裝 Xorg</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/x11/#x-config>5.4. Xorg 設定</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/x11/#x-fonts>5.5. 在 Xorg 使用字型</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/x11/#x-xdm>5.6. X 顯示管理程式</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/x11/#x11-wm>5.7. 桌面環境</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/x11/#x-compiz-fusion>5.8. 安裝 Compiz Fusion</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/x11/#x11-understanding>5.9. 疑難排解</a></li></ul></li><li><input type=checkbox id=chapter-0eab3565e8f59f5a8a896dfba7eb3680 class=toggle>
<label for=chapter-0eab3565e8f59f5a8a896dfba7eb3680><a role=button></a></label><a href=https://docs.freebsd.org/zh-tw/books/handbook/partii/>部 II. 一般作業</a></li><li><input type=checkbox id=chapter-b33cf28993f3f7bf5baf036e79da0f39 class=toggle>
<label class="icon cursor" for=chapter-b33cf28993f3f7bf5baf036e79da0f39><a role=button></a></label><a href=https://docs.freebsd.org/zh-tw/books/handbook/desktop/>章 6. 桌面應用程式</a><ul><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/desktop/#desktop-synopsis>6.1. 概述</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/desktop/#desktop-browsers>6.2. 瀏覽器</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/desktop/#desktop-productivity>6.3. 辦工工具</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/desktop/#desktop-viewers>6.4. 文件閱覽程式</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/desktop/#desktop-finance>6.5. 財務</a></li></ul></li><li><input type=checkbox id=chapter-152f694a19312ad72ec7bb4e1c3c33b2 class=toggle>
<label class="icon cursor" for=chapter-152f694a19312ad72ec7bb4e1c3c33b2><a role=button></a></label><a href=https://docs.freebsd.org/zh-tw/books/handbook/multimedia/>章 7. 多媒體</a><ul><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/multimedia/#multimedia-synopsis>7.1. 概述</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/multimedia/#sound-setup>7.2. 設定音效卡</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/multimedia/#sound-mp3>7.3. MP3 音樂</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/multimedia/#video-playback>7.4. 影片播放</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/multimedia/#tvcard>7.5. 電視卡</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/multimedia/#mythtv>7.6. MythTV</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/multimedia/#scanners>7.7. 影像掃描器</a></li></ul></li><li><input type=checkbox id=chapter-80888b4ee02e3e409e5f71cf97a36450 class=toggle>
<label class="icon cursor" for=chapter-80888b4ee02e3e409e5f71cf97a36450><a role=button></a></label><a href=https://docs.freebsd.org/zh-tw/books/handbook/kernelconfig/>章 8. 設定 FreeBSD 核心</a><ul><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/kernelconfig/#kernelconfig-synopsis>8.1. 概述</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/kernelconfig/#kernelconfig-custom-kernel>8.2. 為何要編譯自訂的核心?</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/kernelconfig/#kernelconfig-devices>8.3. 偵測系統硬體</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/kernelconfig/#kernelconfig-config>8.4. 設定檔</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/kernelconfig/#kernelconfig-building>8.5. 編譯與安裝自訂核心</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/kernelconfig/#kernelconfig-trouble>8.6. 如果發生錯誤</a></li></ul></li><li><input type=checkbox id=chapter-cb174c55879b17ab955f2f16989a79e0 class=toggle>
<label class="icon cursor" for=chapter-cb174c55879b17ab955f2f16989a79e0><a role=button></a></label><a href=https://docs.freebsd.org/zh-tw/books/handbook/printing/>章 9. 列印</a><ul><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/printing/#printing-quick-start>9.1. 快速開始</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/printing/#printing-connections>9.2. 印表機連線</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/printing/#printing-pdls>9.3. 常見的頁面描述語言</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/printing/#printing-direct>9.4. 直接列印</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/printing/#printing-lpd>9.5. LPD (行列式印表機 Daemon)</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/printing/#printing-other>9.6. 其他列印系統</a></li></ul></li><li><input type=checkbox id=chapter-c12b8c3f2a8fcefce87087241f695c83 class=toggle>
<label class="icon cursor" for=chapter-c12b8c3f2a8fcefce87087241f695c83><a role=button></a></label><a href=https://docs.freebsd.org/zh-tw/books/handbook/linuxemu/>章 10. Linux® Binary 相容性</a><ul><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/linuxemu/#linuxemu-synopsis>10.1. 概述</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/linuxemu/#linuxemu-lbc-install>10.2. 設定 Linux™ Binary 相容性</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/linuxemu/#linuxemu-advanced>10.3. 進階主題</a></li></ul></li><li><input type=checkbox id=chapter-03b11ba627b9a0c85b247f5641bde272 class=toggle>
<label for=chapter-03b11ba627b9a0c85b247f5641bde272><a role=button></a></label><a href=https://docs.freebsd.org/zh-tw/books/handbook/partiii/>部 III. 系統管理</a></li><li><input type=checkbox id=chapter-6c31587f8d736319f099cd4dc1961301 class=toggle checked>
<label class="icon cursor" for=chapter-6c31587f8d736319f099cd4dc1961301><a role=button></a></label><a href=https://docs.freebsd.org/zh-tw/books/handbook/config/>章 11. 設定與調校</a><ul><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/config/#config-synopsis>11.1. 概述</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/config/#configtuning-starting-services>11.2. 啟動服務</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/config/#configtuning-cron>11.3. 設定 cron(8)</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/config/#configtuning-rcd>11.4. 管理 FreeBSD 中的服務</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/config/#config-network-setup>11.5. 設定網路介面卡</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/config/#configtuning-virtual-hosts>11.6. 虛擬主機</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/config/#configtuning-syslog>11.7. 設定系統日誌</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/config/#configtuning-configfiles>11.8. 設定檔</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/config/#configtuning-sysctl>11.9. 使用 sysctl(8) 調校</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/config/#configtuning-disk>11.10. 調校磁碟</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/config/#configtuning-kernel-limits>11.11. 調校核心限制</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/config/#adding-swap-space>11.12. 增加交換空間</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/config/#acpi-overview>11.13. 電源與資源管理</a></li></ul></li><li><input type=checkbox id=chapter-459f0012b3b4f0b6b123010f029da5e4 class=toggle>
<label class="icon cursor" for=chapter-459f0012b3b4f0b6b123010f029da5e4><a role=button></a></label><a href=https://docs.freebsd.org/zh-tw/books/handbook/boot/>章 12. FreeBSD 開機程序</a><ul><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/boot/#boot-synopsis>12.1. 概述</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/boot/#boot-introduction>12.2. FreeBSD 開機程序</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/boot/#boot-splash>12.3. 設定開機啟動畫面</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/boot/#device-hints>12.4. 裝置提示</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/boot/#boot-shutdown>12.5. 關機程序</a></li></ul></li><li><input type=checkbox id=chapter-917c75fcffbb14d48ed6d0a48e7028f2 class=toggle>
<label class="icon cursor" for=chapter-917c75fcffbb14d48ed6d0a48e7028f2><a role=button></a></label><a href=https://docs.freebsd.org/zh-tw/books/handbook/security/>章 13. 安全性</a><ul><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/security/#security-synopsis>13.1. 概述</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/security/#security-intro>13.2. 簡介</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/security/#one-time-passwords>13.3. 一次性密碼</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/security/#tcpwrappers>13.4. TCP Wrapper</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/security/#kerberos5>13.5. Kerberos</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/security/#openssl>13.6. OpenSSL</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/security/#ipsec>13.7. VPN over IPsec</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/security/#openssh>13.8. OpenSSH</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/security/#fs-acl>13.9. 存取控制清單</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/security/#security-pkg>13.10. 監視第三方安全性問題</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/security/#security-advisories>13.11. FreeBSD 安全報告</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/security/#security-accounting>13.12. 程序追蹤</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/security/#security-resourcelimits>13.13. 限制資源</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/security/#security-sudo>13.14. 使用 Sudo 分享管理權限</a></li></ul></li><li><input type=checkbox id=chapter-1a2a8e719703649c2c66d99aa7a25fd4 class=toggle>
<label class="icon cursor" for=chapter-1a2a8e719703649c2c66d99aa7a25fd4><a role=button></a></label><a href=https://docs.freebsd.org/zh-tw/books/handbook/jails/>章 14. Jail</a><ul><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/jails/#jails-synopsis>14.1. 概述</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/jails/#jails-terms>14.2. Jail 相關術語</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/jails/#jails-build>14.3. 建立和控制 Jail</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/jails/#jails-tuning>14.4. 調校與管理</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/jails/#jails-application>14.5. 更新多個 Jail</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/jails/#jails-ezjail>14.6. 使用 ezjail 管理 Jail</a></li></ul></li><li><input type=checkbox id=chapter-8f4620c77e572cbb58917911a33c73cf class=toggle>
<label class="icon cursor" for=chapter-8f4620c77e572cbb58917911a33c73cf><a role=button></a></label><a href=https://docs.freebsd.org/zh-tw/books/handbook/mac/>章 15. 強制存取控制 (MAC)</a><ul><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/mac/#mac-synopsis>15.1. 概述</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/mac/#mac-inline-glossary>15.2. 關鍵詞</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/mac/#mac-understandlabel>15.3. 了解 MAC 標籤</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/mac/#mac-planning>15.4. 規劃安全架構</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/mac/#mac-policies>15.5. 可用的 MAC 管理政策</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/mac/#mac-userlocked>15.6. User Lock Down</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/mac/#mac-implementing>15.7. 在 MAC Jail 中使用 Nagios</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/mac/#mac-troubleshoot>15.8. MAC 架構疑難排解</a></li></ul></li><li><input type=checkbox id=chapter-9598d66a76cb3182057b6bcd775149a0 class=toggle>
<label class="icon cursor" for=chapter-9598d66a76cb3182057b6bcd775149a0><a role=button></a></label><a href=https://docs.freebsd.org/zh-tw/books/handbook/audit/>章 16. 安全事件稽查</a><ul><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/audit/#audit-synopsis>16.1. 概述</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/audit/#audit-inline-glossary>16.2. 關鍵詞</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/audit/#audit-config>16.3. 稽查設定</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/audit/#audit-administration>16.4. 查看稽查線索</a></li></ul></li><li><input type=checkbox id=chapter-e1edcad13d9db6e8e4cb645d378ecfaf class=toggle>
<label class="icon cursor" for=chapter-e1edcad13d9db6e8e4cb645d378ecfaf><a role=button></a></label><a href=https://docs.freebsd.org/zh-tw/books/handbook/disks/>章 17. 儲存設備</a><ul><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/disks/#disks-synopsis>17.1. 概述</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/disks/#disks-adding>17.2. 加入磁碟</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/disks/#disks-growing>17.3. 重設大小與擴增磁碟</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/disks/#usb-disks>17.4. USB 儲存裝置</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/disks/#creating-cds>17.5. 建立與使用 CD 媒體</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/disks/#creating-dvds>17.6. 建立與使用 DVD 媒體</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/disks/#floppies>17.7. 建立與使用軟碟</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/disks/#backup-basics>17.8. 備份基礎概念</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/disks/#disks-virtual>17.9. 記憶體磁碟</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/disks/#snapshots>17.10. 檔案系統快照</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/disks/#quotas>17.11. 磁碟配額</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/disks/#disks-encrypting>17.12. 磁碟分割區加密</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/disks/#swap-encrypting>17.13. 交換空間加密</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/disks/#disks-hast>17.14. 高可用存儲空間 (HAST)</a></li></ul></li><li><input type=checkbox id=chapter-dde37901a0e0ea32745b67607854900f class=toggle>
<label class="icon cursor" for=chapter-dde37901a0e0ea32745b67607854900f><a role=button></a></label><a href=https://docs.freebsd.org/zh-tw/books/handbook/geom/>章 18. GEOM: 模組化磁碟轉換框架</a><ul><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/geom/#geom-synopsis>18.1. 概述</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/geom/#geom-striping>18.2. RAID0 - 串連 (Striping)</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/geom/#geom-mirror>18.3. RAID1 - 鏡像 (Mirroring)</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/geom/#geom-raid3>18.4. RAID3 - 位元級串連與獨立奇偶校驗</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/geom/#geom-graid>18.5. 軟體 RAID 裝置</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/geom/#geom-ggate>18.6. GEOM Gate Network</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/geom/#geom-glabel>18.7. 磁碟裝置標籤</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/geom/#geom-gjournal>18.8. UFS Journaling 透過 GEOM</a></li></ul></li><li><input type=checkbox id=chapter-73e82560fcb7145b7c0e2ec47af8fc04 class=toggle>
<label class="icon cursor" for=chapter-73e82560fcb7145b7c0e2ec47af8fc04><a role=button></a></label><a href=https://docs.freebsd.org/zh-tw/books/handbook/zfs/>章 19. Z 檔案系統 (ZFS)</a><ul><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/zfs/#zfs-differences>19.1. 什麼使 ZFS 與眾不同</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/zfs/#zfs-quickstart>19.2. 快速入門指南</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/zfs/#zfs-zpool>19.3. <code>zpool</code> 管理</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/zfs/#zfs-zfs>19.4. <code>zfs</code> 管理</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/zfs/#zfs-zfs-allow>19.5. 委託管理</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/zfs/#zfs-advanced>19.6. 進階主題</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/zfs/#zfs-links>19.7. 其他資源</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/zfs/#zfs-term>19.8. ZFS 特色與術語</a></li></ul></li><li><input type=checkbox id=chapter-7af71270807eb7b70cd3eedc6577b254 class=toggle>
<label class="icon cursor" for=chapter-7af71270807eb7b70cd3eedc6577b254><a role=button></a></label><a href=https://docs.freebsd.org/zh-tw/books/handbook/filesystems/>章 20. 其他檔案系統</a><ul><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/filesystems/#filesystems-synopsis>20.1. 概述</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/filesystems/#filesystems-linux>20.2. Linux™ 檔案系統</a></li></ul></li><li><input type=checkbox id=chapter-375257268d95faaf87faf4f7a2e6aa67 class=toggle>
<label class="icon cursor" for=chapter-375257268d95faaf87faf4f7a2e6aa67><a role=button></a></label><a href=https://docs.freebsd.org/zh-tw/books/handbook/virtualization/>章 21. 虛擬化</a><ul><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/virtualization/#virtualization-synopsis>21.1. 概述</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/virtualization/#virtualization-guest-parallels>21.2. 在 Mac OS™ X 的 Parallels 安裝 FreeBSD 為客端</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/virtualization/#virtualization-guest-virtualpc>21.3. 在 Windows™ 的 Virtual PC 安裝 FreeBSD 為客端</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/virtualization/#virtualization-guest-vmware>21.4. 在 Mac OS™ 的 VMware Fusion 安裝 FreeBSD 為客端</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/virtualization/#virtualization-guest-virtualbox>21.5. 在 VirtualBox™ 安裝 FreeBSD 作為客端</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/virtualization/#virtualization-host-virtualbox>21.6. 以 FreeBSD 作為主端使用 VirtualBox™</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/virtualization/#virtualization-host-bhyve>21.7. 以 FreeBSD 作為主端安裝 bhyve</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/virtualization/#virtualization-host-xen>21.8. 以 FreeBSD 作為主端安裝 Xen™</a></li></ul></li><li><input type=checkbox id=chapter-49f1e96591c090304ea532012257f4ef class=toggle>
<label class="icon cursor" for=chapter-49f1e96591c090304ea532012257f4ef><a role=button></a></label><a href=https://docs.freebsd.org/zh-tw/books/handbook/l10n/>章 22. 在地化 - i18n/L10n 使用與安裝</a><ul><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/l10n/#l10n-synopsis>22.1. 概述</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/l10n/#using-localization>22.2. 使用語系</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/l10n/#l10n-compiling>22.3. 尋找 i18n 應用程式</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/l10n/#lang-setup>22.4. 特定語言的語系設定</a></li></ul></li><li><input type=checkbox id=chapter-dead2b4c5ea325dd390a9b0dccd8f763 class=toggle>
<label class="icon cursor" for=chapter-dead2b4c5ea325dd390a9b0dccd8f763><a role=button></a></label><a href=https://docs.freebsd.org/zh-tw/books/handbook/cutting-edge/>章 23. 更新與升級 FreeBSD</a><ul><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/cutting-edge/#updating-upgrading-synopsis>23.1. 概述</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/cutting-edge/#updating-upgrading-freebsdupdate>23.2. FreeBSD 更新</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/cutting-edge/#updating-upgrading-documentation>23.3. 更新文件集</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/cutting-edge/#current-stable>23.4. 追蹤開發分支</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/cutting-edge/#makeworld>23.5. 從原始碼更新 FreeBSD</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/cutting-edge/#small-lan>23.6. 多部機器追蹤</a></li></ul></li><li><input type=checkbox id=chapter-913e72bfb3d6947b2869d3e9447a6eaa class=toggle>
<label class="icon cursor" for=chapter-913e72bfb3d6947b2869d3e9447a6eaa><a role=button></a></label><a href=https://docs.freebsd.org/zh-tw/books/handbook/usb-device-mode/>章 25. USB Device Mode / USB OTG</a><ul><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/usb-device-mode/#usb-device-mode-synopsis>25.1. 概述</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/usb-device-mode/#usb-device-mode-terminals>25.2. USB 虛擬序列埠</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/usb-device-mode/#usb-device-mode-network>25.3. USB 裝置模式網路介面</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/usb-device-mode/#usb-device-mode-storage>25.4. USB 虛擬儲存裝置</a></li></ul></li><li><input type=checkbox id=chapter-bbd25f9a194f9c39ca2d658c75767db5 class=toggle>
<label for=chapter-bbd25f9a194f9c39ca2d658c75767db5><a role=button></a></label><a href=https://docs.freebsd.org/zh-tw/books/handbook/partiv/>部 IV. 網路通訊</a></li><li><input type=checkbox id=chapter-29c1eeb0e9dedc487a98399e2737ee8a class=toggle>
<label class="icon cursor" for=chapter-29c1eeb0e9dedc487a98399e2737ee8a><a role=button></a></label><a href=https://docs.freebsd.org/zh-tw/books/handbook/dtrace/>章 24. DTrace</a><ul><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/dtrace/#dtrace-synopsis>24.1. 概述</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/dtrace/#dtrace-implementation>24.2. 實作差異</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/dtrace/#dtrace-enable>24.3. 開啟 DTrace 支援</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/dtrace/#dtrace-using>24.4. 使用 DTrace</a></li></ul></li><li><input type=checkbox id=chapter-499dab596afd7ddac77e80295314e0dd class=toggle>
<label class="icon cursor" for=chapter-499dab596afd7ddac77e80295314e0dd><a role=button></a></label><a href=https://docs.freebsd.org/zh-tw/books/handbook/serialcomms/>章 26. 序列通訊</a><ul><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/serialcomms/#serial-synopsis>26.1. 概述</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/serialcomms/#serial>26.2. 序列術語與硬體</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/serialcomms/#term>26.3. 終端機</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/serialcomms/#dialup>26.4. 撥入服務</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/serialcomms/#dialout>26.5. 撥出服務</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/serialcomms/#serialconsole-setup>26.6. 設定序列 Console</a></li></ul></li><li><input type=checkbox id=chapter-95e4571c48bee1cced5e84a538d302e3 class=toggle>
<label class="icon cursor" for=chapter-95e4571c48bee1cced5e84a538d302e3><a role=button></a></label><a href=https://docs.freebsd.org/zh-tw/books/handbook/ppp-and-slip/>章 27. PPP</a><ul><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/ppp-and-slip/#ppp-and-slip-synopsis>27.1. 概述</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/ppp-and-slip/#userppp>27.2. 設定 PPP</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/ppp-and-slip/#ppp-troubleshoot>27.3. PPP 連線疑難排解</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/ppp-and-slip/#pppoe>27.4. 在乙太網路使用 PPP (PPPoE)</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/ppp-and-slip/#pppoa>27.5. 在 ATM 使用 PPP (PPPoA)</a></li></ul></li><li><input type=checkbox id=chapter-f089ac726c401c9b4bd5c34a295e11bb class=toggle>
<label class="icon cursor" for=chapter-f089ac726c401c9b4bd5c34a295e11bb><a role=button></a></label><a href=https://docs.freebsd.org/zh-tw/books/handbook/mail/>章 28. 電子郵件</a><ul><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/mail/#mail-synopsis>28.1. 概述</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/mail/#mail-using>28.2. 郵件組成</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/mail/#sendmail>28.3. Sendmail 設定檔</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/mail/#mail-changingmta>28.4. 更改郵件傳輸代理程式</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/mail/#mail-trouble>28.5. 疑難排解</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/mail/#mail-advanced>28.6. 進階主題</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/mail/#outgoing-only>28.7. 寄件設定</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/mail/#SMTP-dialup>28.8. 在撥號連線使用郵件</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/mail/#SMTP-Auth>28.9. SMTP 認證</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/mail/#mail-agents>28.10. 郵件使用者代理程式</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/mail/#mail-fetchmail>28.11. 使用 fetchmail</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/mail/#mail-procmail>28.12. 使用 procmail</a></li></ul></li><li><input type=checkbox id=chapter-6de4de3fe925639d4175ce4b6f8c1829 class=toggle>
<label class="icon cursor" for=chapter-6de4de3fe925639d4175ce4b6f8c1829><a role=button></a></label><a href=https://docs.freebsd.org/zh-tw/books/handbook/network-servers/>章 29. 網路伺服器</a><ul><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/network-servers/#network-servers-synopsis>29.1. 概述</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/network-servers/#network-inetd>29.2. inetd 超級伺服器</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/network-servers/#network-nfs>29.3. 網路檔案系統 (NFS)</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/network-servers/#network-nis>29.4. 網路資訊系統 (NIS)</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/network-servers/#network-ldap>29.5. 輕量級目錄存取協定 (LDAP)</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/network-servers/#network-dhcp>29.6. 動態主機設置協定 (DHCP)</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/network-servers/#network-dns>29.7. 網域名稱系統 (DNS)</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/network-servers/#network-apache>29.8. Apache HTTP 伺服器</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/network-servers/#network-ftp>29.9. 檔案傳輸協定 (FTP)</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/network-servers/#network-samba>29.10. Microsoft™Windows™ 用戶端檔案與列印服務 (Samba)</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/network-servers/#network-ntp>29.11. NTP 時間校對</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/network-servers/#network-iscsi>29.12. iSCSI Initiator 與 Target 設定</a></li></ul></li><li><input type=checkbox id=chapter-776d855c7b75e048f90b5c2c9b35ffe0 class=toggle>
<label class="icon cursor" for=chapter-776d855c7b75e048f90b5c2c9b35ffe0><a role=button></a></label><a href=https://docs.freebsd.org/zh-tw/books/handbook/firewalls/>章 30. 防火牆</a><ul><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/firewalls/#firewalls-intro>30.1. 概述</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/firewalls/#firewalls-concepts>30.2. 防火牆概念</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/firewalls/#firewalls-pf>30.3. PF</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/firewalls/#firewalls-ipfw>30.4. IPFW</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/firewalls/#firewalls-ipf>30.5. IPFILTER (IPF)</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/firewalls/#firewalls-blacklistd>30.6. Blacklistd</a></li></ul></li><li><input type=checkbox id=chapter-5b07f776a0e6155c1c89aa0d15610380 class=toggle>
<label class="icon cursor" for=chapter-5b07f776a0e6155c1c89aa0d15610380><a role=button></a></label><a href=https://docs.freebsd.org/zh-tw/books/handbook/advanced-networking/>章 31. 進階網路設定</a><ul><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/advanced-networking/#advanced-networking-synopsis>31.1. 概述</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/advanced-networking/#network-routing>31.2. 通訊閘與路由</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/advanced-networking/#network-wireless>31.3. 無線網路</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/advanced-networking/#network-usb-tethering>31.4. USB 網路共享</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/advanced-networking/#network-bluetooth>31.5. 藍牙</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/advanced-networking/#network-bridging>31.6. 橋接</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/advanced-networking/#network-aggregation>31.7. Link Aggregation 與容錯移轉</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/advanced-networking/#network-diskless>31.8. PXE 無磁碟作業</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/advanced-networking/#network-ipv6>31.9. IPv6</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/advanced-networking/#carp>31.10. 共用位址備援協定 (CARP)</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/advanced-networking/#network-vlan>31.11. VLANs</a></li></ul></li><li><input type=checkbox id=chapter-171a77aa9d067a1024f849470e1f33e8 class=toggle>
<label for=chapter-171a77aa9d067a1024f849470e1f33e8><a role=button></a></label><a href=https://docs.freebsd.org/zh-tw/books/handbook/partv/>部 V. 附錄</a></li><li><input type=checkbox id=chapter-8050f436a0a7986a4aaded93d8e49469 class=toggle>
<label class="icon cursor" for=chapter-8050f436a0a7986a4aaded93d8e49469><a role=button></a></label><a href=https://docs.freebsd.org/zh-tw/books/handbook/mirrors/>附錄 A. 取得 FreeBSD</a><ul><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/mirrors/#mirrors-cdrom>A.1. CD 與 DVD 合集</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/mirrors/#mirrors-ftp>A.2. FTP 站</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/mirrors/#svn>A.3. 使用 Subversion</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/mirrors/#mirrors-rsync>A.4. 使用 rsync</a></li></ul></li><li><input type=checkbox id=chapter-128b630a8f88f158e7027fe6c2184d21 class=toggle>
<label class="icon cursor" for=chapter-128b630a8f88f158e7027fe6c2184d21><a role=button></a></label><a href=https://docs.freebsd.org/zh-tw/books/handbook/bibliography/>附錄 B. 參考書目</a><ul><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/bibliography/#bibliography-freebsd>B.1. FreeBSD 相關書籍</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/bibliography/#bibliography-userguides>B.2. 使用指南</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/bibliography/#bibliography-adminguides>B.3. 管理指南</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/bibliography/#bibliography-programmers>B.4. 開發指南</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/bibliography/#bibliography-osinternals>B.5. 深入作業系統</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/bibliography/#bibliography-security>B.6. 安全性參考文獻</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/bibliography/#bibliography-hardware>B.7. 硬體參考文獻</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/bibliography/#bibliography-history>B.8. UNIX™ 歷史</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/bibliography/#bibliography-journals>B.9. 期刊與雜誌</a></li></ul></li><li><input type=checkbox id=chapter-8bbb8867c46dac315e2253945d8c18a8 class=toggle>
<label class="icon cursor" for=chapter-8bbb8867c46dac315e2253945d8c18a8><a role=button></a></label><a href=https://docs.freebsd.org/zh-tw/books/handbook/eresources/>附錄 C. 網路資源</a><ul><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/eresources/#eresources-www>C.1. 網站</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/eresources/#eresources-mail>C.2. 郵遞論壇 (Mailing List)</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/eresources/#eresources-news>C.3. Usenet 新聞群組</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/eresources/#eresources-web>C.4. 官方鏡像站</a></li></ul></li><li><input type=checkbox id=chapter-a80ea4f5a4480b8725422710f954ef36 class=toggle>
<label class="icon cursor" for=chapter-a80ea4f5a4480b8725422710f954ef36><a role=button></a></label><a href=https://docs.freebsd.org/zh-tw/books/handbook/pgpkeys/>附錄 D. OpenPGP 金鑰</a><ul><li><a href=https://docs.freebsd.org/zh-tw/books/handbook/pgpkeys/#pgpkeys-officers>D.1. Officers</a></li></ul></li><li></li></ul></nav></div></aside><div class=book><div class=book-menu-mobile><label for=menu-control><span class=menu-control-button><i class="fa fa-list" aria-hidden=true title="Book menu"></i>
Book menu</span></label></div><h1 class=title>章 11. 設定與調校</h1><div class="admonitionblock note"><p><i class="fa fa-exclamation-circle" aria-hidden=true></i>
This translation may be out of date. To help with the translations please access the <a href=https://translate-dev.freebsd.org/ target=_blank>FreeBSD translations instance</a>.</p></div><div class=toc-mobile><h3>目錄</h3><nav id=TableOfContents><ul><li><a href=#config-synopsis>11.1. 概述</a></li><li><a href=#configtuning-starting-services>11.2. 啟動服務</a></li><li><a href=#configtuning-cron>11.3. 設定 cron(8)</a></li><li><a href=#configtuning-rcd>11.4. 管理 FreeBSD 中的服務</a></li><li><a href=#config-network-setup>11.5. 設定網路介面卡</a></li><li><a href=#configtuning-virtual-hosts>11.6. 虛擬主機</a></li><li><a href=#configtuning-syslog>11.7. 設定系統日誌</a></li><li><a href=#configtuning-configfiles>11.8. 設定檔</a></li><li><a href=#configtuning-sysctl>11.9. 使用 sysctl(8) 調校</a></li><li><a href=#configtuning-disk>11.10. 調校磁碟</a></li><li><a href=#configtuning-kernel-limits>11.11. 調校核心限制</a></li><li><a href=#adding-swap-space>11.12. 增加交換空間</a></li><li><a href=#acpi-overview>11.13. 電源與資源管理</a></li></ul></nav></div><div class=book-content><div id=preamble><div class=sectionbody></div></div><div class=sect1><h2 id=config-synopsis>11.1. 概述<a class=anchor href=#config-synopsis></a></h2><div class=sectionbody><div class=paragraph><p>在 FreeBSD 使用過程中，相當重要的環節之一就是如何正確設定系統。 本章著重於介紹 FreeBSD 的設定流程，包括一些可以調整 FreeBSD 效能的參數設定。</p></div><div class=paragraph><p>讀完這章，您將了解：</p></div><div class=ulist><ul><li><p><span class=filename>rc.conf</span> 設定的基礎概念及 <span class=filename>/usr/local/etc/rc.d</span> 啟動 Script。</p></li><li><p>如何設定並測試網路卡。</p></li><li><p>如何在網路裝置上設定虛擬主機。</p></li><li><p>如何使用在 <span class=filename>/etc</span> 中的各種設定檔。</p></li><li><p>如何使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> 變數調校 FreeBSD。</p></li><li><p>如何調校磁碟效能及修改核心限制。</p></li></ul></div><div class=paragraph><p>在開始閱讀這章之前，您需要：</p></div><div class=ulist><ul><li><p>了解 UNIX™ 及 FreeBSD 基礎 (<a href=../basics/#basics>FreeBSD 基礎</a>)。</p></li><li><p>熟悉核心設定與編譯的基礎 (<a href=../kernelconfig/#kernelconfig>設定 FreeBSD 核心</a>)。</p></li></ul></div></div></div><div class=sect1><h2 id=configtuning-starting-services>11.2. 啟動服務<a class=anchor href=#configtuning-starting-services></a></h2><div class=sectionbody><div class=paragraph><p>許多使用者會使用 Port 套件集安裝第三方軟體到 FreeBSD 且需要安裝服務在系統初始化時可啟動該軟體。服務，例如 <a class=package href=https://cgit.freebsd.org/ports/tree/mail/postfix/>mail/postfix</a> 或 <a class=package href=https://cgit.freebsd.org/ports/tree/www/apache22/>www/apache22</a> 僅只是在眾多需要在系統初始化時啟動的軟體之中的兩個。本章節將說明可用來啟動第三方軟體的程序。</p></div><div class=paragraph><p>在 FreeBSD 大多數內建的服務，例如 <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a> 也是透過系統啟動 Script 來執行。</p></div><div class=sect2><h3 id=_延伸應用程式設定>11.2.1. 延伸應用程式設定<a class=anchor href=#_延伸應用程式設定></a></h3><div class=paragraph><p>現在 FreeBSD 會引用 <span class=filename>rc.d</span>，設定應用程式啟動變的更簡單且提供更多的功能。使用於 <a href=#configtuning-rcd>管理 FreeBSD 中的服務</a> 所提到的關鍵字，可以設定應用程式在其他特定服務之後啟動且可以透過 <span class=filename>/etc/rc.conf</span> 來傳遞額外的旗標來取代寫死在啟動 Script 中的旗標。一個基本的 Script 可能會如下例所示：</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
#
# PROVIDE: utility
# REQUIRE: DAEMON
# KEYWORD: shutdown

. /etc/rc.subr

name=utility
rcvar=utility_enable

command=&#34;/usr/local/sbin/utility&#34;

load_rc_config $name

#
# DO NOT CHANGE THESE DEFAULT VALUES HERE
# SET THEM IN THE /etc/rc.conf FILE
#
utility_enable=${utility_enable-&#34;NO&#34;}
pidfile=${utility_pidfile-&#34;/var/run/utility.pid&#34;}

run_rc_command &#34;$1&#34;</pre></div></div><div class=paragraph><p>這個 Script 會確保要執行的 <code>utility</code> 會在虛構的服務 <code>DAEMON</code> 之後啟動，也同時提供設定與追蹤程序 ID (Process ID, PID) 的方法。</p></div><div class=paragraph><p>接著此應用程式便可將下行放到 <span class=filename>/etc/rc.conf</span> 中：</p></div><div class="literalblock programlisting"><div class=content><pre>utility_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>使用這種方式可以簡單的處理指令列參數、引用 <span class=filename>/etc/rc.subr</span> 所提供的預設函數、與 <a href="https://man.freebsd.org/cgi/man.cgi?query=rcorder&amp;sektion=8&amp;format=html">rcorder(8)</a> 相容並可在 <span class=filename>rc.conf</span> 簡單的設定。</p></div></div><div class=sect2><h3 id=_使用服務來啟動其他服務>11.2.2. 使用服務來啟動其他服務<a class=anchor href=#_使用服務來啟動其他服務></a></h3><div class=paragraph><p>其他的服務可以使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=inetd&amp;sektion=8&amp;format=html">inetd(8)</a> 來啟動，在 <a href=../network-servers/#network-inetd>inetd 超級伺服器</a> 有如何使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=inetd&amp;sektion=8&amp;format=html">inetd(8)</a> 以及其設定的深入說明。</p></div><div class=paragraph><p>在某些情況更適合使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a> 來啟動系統服務，由於 <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a> 會使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=crontab&amp;sektion=5&amp;format=html">crontab(5)</a> 的擁有者來執行這些程序，所以這個方法有不少優點，這讓一般的使用者也可以啟動與維護自己的應用程式。</p></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a> 的 <code>@reboot</code> 功能，可用來替代指定詳細的時間，而該工作會在系統初始化時執行 <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a> 後執行。</p></div></div></div></div><div class=sect1><h2 id=configtuning-cron>11.3. 設定 <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a><a class=anchor href=#configtuning-cron></a></h2><div class=sectionbody><div class=paragraph><p>在 FreeBSD 其中最有用的其中一項工具便是 cron，這個工具會在背景執行並且定期檢查 <span class=filename>/etc/crontab</span> 是否有要執行的工作然後搜尋 <span class=filename>/var/cron/tabs</span> 是否有自訂的 crontab 檔案，這些檔案用來安排要讓 cron 在指定的時間執行的工作，crontab 中的每一個項目定義了一個要執行的工作，又稱作 <em>cron job</em>。</p></div><div class=paragraph><p>這裡使用了兩種類型的設定檔：其一是系統 crontab，系統 crontab 不應該被修改，其二為使用者 crontab，使用者 crontab 可以依需要建立與編輯。這兩種檔案的格式在 <a href="https://man.freebsd.org/cgi/man.cgi?query=crontab&amp;sektion=5&amp;format=html">crontab(5)</a> 有說明。系統 crontab <span class=filename>/etc/crontab</span> 的格式含有在使用者 crontab 所沒有的 <code>who</code> 欄位，在系統 crontab，cron 會依據該欄位所指定的使用者來執行指令，而在使用者 crontab，會以建立 crontab 的使用者來執行指令。</p></div><div class=paragraph><p>使用者 crontab 讓個別使用者可以安排自己的工作，<code>root</code> 使用者也可有自己的使用者 <span class=filename>crontab</span> 來安排不在系統 <span class=filename>crontab</span> 中的工作。</p></div><div class=paragraph><p>以下為系統 crontab <span class=filename>/etc/crontab</span> 的範例項目：</p></div><div class="literalblock programlisting"><div class=content><pre># /etc/crontab - root&#39;s crontab for FreeBSD
#
# $FreeBSD: head/zh_TW.UTF-8/books/handbook/book.xml 53653 2019-12-03 17:05:41Z rcyu $
#<i class=conum data-value=1></i><b>(1)</b>
SHELL=/bin/sh
PATH=/etc:/bin:/sbin:/usr/bin:/usr/sbin <i class=conum data-value=2></i><b>(2)</b>
#
#minute	hour	mday	month	wday	who	command <i class=conum data-value=3></i><b>(3)</b>
#
*/5	*	*	*	*	root	/usr/libexec/atrun <i class=conum data-value=4></i><b>(4)</b></pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>以 <code>#</code> 字元為首的行代表註解。可在檔案中放置註解提醒要執行什麼動作及為何要執行。註解不可與指令同行，否則會被當做指令的一部份，註解必須在新的一行，空白行則會被忽略掉。</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td>等號 (<code>=</code>) 字元用來定義任何環境設定。在這個例子當中，使用了等號來定義 <code>SHELL</code> 及 <code>PATH</code>。若 <code>SHELL</code> 被省略，cron 則會使用預設的 Bourne shell。若 <code>PATH</code> 被省略，則必須指定指令或 Script 的完整路徑才能執行。</td></tr><tr><td><i class=conum data-value=3></i><b>3</b></td><td>此行定義了在系統 crontab 會使用到的七個欄位：<code>minute</code>, <code>hour</code>, <code>mday</code>, <code>month</code>, <code>wday</code>, <code>who</code> 以及 <code>command</code>。<code>minute</code> 欄位是指定指令要執行的時間中的分，<code>hour</code> 指定指令要執行的時，<code>mday</code> 是月裡面的日，<code>month</code> 是月，以及 <code>wday</code> 是週裡面的日。這些欄位必須數值代表 24 小時制的時間或 <code>\*</code> 來代表所有可能的值。<code>who</code> 這個欄位只有系統 crontab 才有，用來指定要用那一個使用者來執行指令。最後一個欄位則是要執行的指令。</td></tr><tr><td><i class=conum data-value=4></i><b>4</b></td><td>這個項目定義了該工作所使用的數值，<code>*/5</code> 後接著數個 <code>*</code> 字元指的是每個月的每一週的每一日的每個小時的每 5 分鐘會使用 <code>root</code> 執行 <code>/usr/libexec/atrun</code>。指令可含任何數量的參數，但若指令要使用多行則需以反斜線 "\" 連線字元換行。</td></tr></tbody></table></div><div class=sect2><h3 id=configtuning-installcrontab>11.3.1. 建立使用者的 Crontab<a class=anchor href=#configtuning-installcrontab></a></h3><div class=paragraph><p>要建立一個使用者 crontab 可使用編輯模式執行 <code>crontab</code>：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% crontab <span class=nt>-e</span></code></pre></div></div><div class=paragraph><p>這樣會使用預設的文字編輯器來開啟使用者的 crontab，使用者第一次執行這個指令會開啟一個空的檔案，使用者建立 crontab 之後這個指令則會開啟已建立的 crontab 供編輯。</p></div><div class=paragraph><p>加入這些行到 crontab 檔的最上方來設定環境變數以及備忘在 crontab 中欄位的意思非常有用：</p></div><div class="literalblock programlisting"><div class=content><pre>SHELL=/bin/sh
PATH=/etc:/bin:/sbin:/usr/bin:/usr/sbin
# Order of crontab fields
# minute	hour	mday	month	wday	command</pre></div></div><div class=paragraph><p>然後每一個要執行的指令或 Script 加入一行，指定要執行指令的時間。這個例子會每天在下午 2 點執行指定的自訂 Bourne shell script，由於沒有在 <code>PATH</code> 指定 Script 的路徑，所以必須給予完整的 Script 路徑：</p></div><div class="literalblock programlisting"><div class=content><pre>0	14	*	*	*	/usr/home/dru/bin/mycustomscript.sh</pre></div></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>在使用自訂的 Script 之前，請先確定該 Script 可以執行並且使用 cron 在有限的環境變數下測試。要複製一個用來執行上述 cron 項目的環境可以使用：</p></div><div class="literalblock programlisting"><div class=content><pre>env -i SHELL=/bin/sh PATH=/etc:/bin:/sbin:/usr/bin:/usr/sbin HOME=/home/dru LOGNAME=dru /usr/home/dru/bin/mycustomscript.sh</pre></div></div><div class=paragraph><p>在 <a href="https://man.freebsd.org/cgi/man.cgi?query=crontab&amp;sektion=5&amp;format=html">crontab(5)</a> 有討論 cron 使用的環境變數，若 Script 中含有任何會使用萬用字元刪除檔案的指令，那麼檢查 Script 可正常在 cron 的環境運作非常重要。</p></div></td></tr></tbody></table></div><div class=paragraph><p>編輯完成 crontab 之後儲存檔案，編輯完的 crontab 會被自動安裝且 cron 會讀取該 crontab 並在其指定的時指執行其 cron job。要列出 crontab 中有那一些 cron job 可以使用此指令：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% crontab <span class=nt>-l</span>
0	14	<span class=k>*</span>	<span class=k>*</span>	<span class=k>*</span>	/usr/home/dru/bin/mycustomscript.sh</code></pre></div></div><div class=paragraph><p>要移除使用在使用者 crontab 中的 cron job 可：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% crontab <span class=nt>-r</span>
remove crontab <span class=k>for </span>dru? y</code></pre></div></div></div></div></div><div class=sect1><h2 id=configtuning-rcd>11.4. 管理 FreeBSD 中的服務<a class=anchor href=#configtuning-rcd></a></h2><div class=sectionbody><div class=paragraph><p>FreeBSD 在系統初始化時使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=rc&amp;sektion=8&amp;format=html">rc(8)</a> 系統的啟動 Script。列於 <span class=filename>/etc/rc.d</span> 的 Script 提供了基本的服務可使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=service&amp;sektion=8&amp;format=html">service(8)</a> 加上 <code>start</code>, <code>stop</code> 以及 <code>restart</code> 選項來控制。例如，使用以下指令可以重新啟動 <a href="https://man.freebsd.org/cgi/man.cgi?query=sshd&amp;sektion=8&amp;format=html">sshd(8)</a>：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service sshd restart</span></code></pre></div></div><div class=paragraph><p>這個程序可以用來在執行中的系統上啟動服務，而在 <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a> 中有指定的服務則會在開機時自動啟動。例如，要在系統啟動時開啟 <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a>，可入下行到 <span class=filename>/etc/rc.conf</span>：</p></div><div class="literalblock programlisting"><div class=content><pre>natd_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>若 <code>natd_enable="NO"</code> 行已存在，則將 <code>NO</code> 更改為 <code>YES</code>，在下次開機時 <a href="https://man.freebsd.org/cgi/man.cgi?query=rc&amp;sektion=8&amp;format=html">rc(8)</a> script 便會自動載入任何相依的服務，詳細如下所述。</p></div><div class=paragraph><p>由於 <a href="https://man.freebsd.org/cgi/man.cgi?query=rc&amp;sektion=8&amp;format=html">rc(8)</a> 系統主要用於在系統開機與關機時啟動與停止服務，只有當有服務的變數設定在 <span class=filename>/etc/rc.conf</span> 時 <code>start</code>, <code>stop</code> 以及 <code>restart</code> 才會有作用。例如 <code>sshd restart</code> 只會在 <span class=filename>/etc/rc.conf</span> 中的 <code>sshd_enable</code> 設為 <code>YES</code> 時才會運作，若要不透過 <span class=filename>/etc/rc.conf</span> 的設定來 <code>start</code>, <code>stop</code> 或 <code>restart</code> 一個服務則需要在指令前加上 "one"，例如要不透過目前在 <span class=filename>/etc/rc.conf</span> 的設定重新啟動 <a href="https://man.freebsd.org/cgi/man.cgi?query=sshd&amp;sektion=8&amp;format=html">sshd(8)</a> 可執行以下指令：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service sshd onerestart</span></code></pre></div></div><div class=paragraph><p>要檢查一個服務是否有在 <span class=filename>/etc/rc.conf</span> 開啟，可執行服務的 <a href="https://man.freebsd.org/cgi/man.cgi?query=rc&amp;sektion=8&amp;format=html">rc(8)</a> Script 加上 <code>rcvar</code>。這個例子會檢查 <a href="https://man.freebsd.org/cgi/man.cgi?query=sshd&amp;sektion=8&amp;format=html">sshd(8)</a> 是否在 <span class=filename>/etc/rc.conf</span> 已經開啟：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service sshd rcvar</span>
<span class=c># sshd</span>
<span class=c>#</span>
<span class=nv>sshd_enable</span><span class=o>=</span><span class=s2>&#34;YES&#34;</span>
<span class=c>#   (default: &#34;&#34;)</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>行 <code># sshd</code> 的輸出來自上述指令，而非 <code>root</code> console。</p></div></td></tr></tbody></table></div><div class=paragraph><p>要判斷是一個服務是否正在執行，可使用 <code>status</code>，例如要確認 <a href="https://man.freebsd.org/cgi/man.cgi?query=sshd&amp;sektion=8&amp;format=html">sshd(8)</a> 是否正常在執行：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service sshd status</span>
sshd is running as pid 433.</code></pre></div></div><div class=paragraph><p>在某些情況，也可以 <code>reload</code> 一個服務。這個動作會嘗試發送一個信號給指定的服務，強制服務重新載入其設定檔，在大多數的情況下，發送給服務的信號是 <code>SIGHUP</code>。並不是每個服務都有支援此功能。</p></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=rc&amp;sektion=8&amp;format=html">rc(8)</a> 系統會用在網路服務及也應用在大多數的系統初化 。例如執行 <span class=filename>/etc/rc.d/bgfsck</span> Script 會列印出以下訊息：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Starting background file system checks <span class=k>in </span>60 seconds.</code></pre></div></div><div class=paragraph><p>這個 Script 用來在背景做檔案系統檢查，只有在系統初始化時要執行。</p></div><div class=paragraph><p>許多系統服務會相依其他服務來運作，例如 <a href="https://man.freebsd.org/cgi/man.cgi?query=yp&amp;sektion=8&amp;format=html">yp(8)</a> 及其他以 RPC 為基礎的服務在 <a href="https://man.freebsd.org/cgi/man.cgi?query=rpcbind&amp;sektion=8&amp;format=html">rpcbind(8)</a> 服務啟動前可能會啟動失敗。要解決這種問題，就必須在啟動 Script 上方的註解中加入相依及其他 meta-data。在系統初始化時會用 <a href="https://man.freebsd.org/cgi/man.cgi?query=rcorder&amp;sektion=8&amp;format=html">rcorder(8)</a> 程式分析這些註解來決定要以什麼順序來執行系統服務以滿足相依。</p></div><div class=paragraph><p>因 <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.subr&amp;sektion=8&amp;format=html">rc.subr(8)</a> 的需要，以下的關鍵字必須加入到所有的啟動 Script 方可 "enable" 啟動 Script：</p></div><div class=ulist><ul><li><p><code>PROVIDE</code>: 設定此檔案所提供的服務。</p></li></ul></div><div class=paragraph><p>以下關鍵字可能會在每個啟動 Script 的上方引用，雖然非必要，但是對於 <a href="https://man.freebsd.org/cgi/man.cgi?query=rcorder&amp;sektion=8&amp;format=html">rcorder(8)</a> 是非常有用的提示：</p></div><div class=ulist><ul><li><p><code>REQUIRE</code>: 列出此服務需要引用的服務。有使用此關鍵字的 Script 會在指定服務啟動 <em>之後</em> 才執行。</p></li><li><p><code>BEFORE</code>: 列出相依此服務的服務。有使用此關鍵字的 Script 會在指定的服務啟動 <em>之前</em> 執行。</p></li></ul></div><div class=paragraph><p>透過仔細的設定每個啟動 Script 的這些關鍵字，管理者便可對 Script 的啟動順序進行微調，而不需使用到其他 UNIX™ 作業系統所使用的 "runlevels"。</p></div><div class=paragraph><p>額外的資訊可在 <a href="https://man.freebsd.org/cgi/man.cgi?query=rc&amp;sektion=8&amp;format=html">rc(8)</a> 以及 <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.subr&amp;sektion=8&amp;format=html">rc.subr(8)</a> 中找到。請參考 <a href=https://docs.freebsd.org/en/articles/rc-scripting/>此文章</a> 來取得如何建立自訂 <a href="https://man.freebsd.org/cgi/man.cgi?query=rc&amp;sektion=8&amp;format=html">rc(8)</a> Script 的操作說明。</p></div><div class=sect2><h3 id=configtuning-core-configuration>11.4.1. 管理系統特定的設定<a class=anchor href=#configtuning-core-configuration></a></h3><div class=paragraph><p>系統設定資訊的主要位於 <span class=filename>/etc/rc.conf</span>，這個檔案的設定資訊範圍非常廣且會在系統啟動時讀取來設定系統，它也提供設定資訊給 <span class=filename>rc*</span> 檔案使用。</p></div><div class=paragraph><p>在 <span class=filename>/etc/rc.conf</span> 中的設定項目會覆蓋在 <span class=filename>/etc/defaults/rc.conf</span> 的預設設定，不應直接編輯該檔案中的預設設定，所有系統特定的設定應到 <span class=filename>/etc/rc.conf</span> 所修改。</p></div><div class=paragraph><p>在叢集應用時要將系統特定的設定與各站特定的設定分開，藉此減少管理成本有好幾種方法，建議的方法是將系統特定的設定放置在 <span class=filename>/etc/rc.conf.local</span>，例如以下將要套用到所有系統的設定項目放在 <span class=filename>/etc/rc.conf</span>：</p></div><div class="literalblock programlisting"><div class=content><pre>sshd_enable=&#34;YES&#34;
keyrate=&#34;fast&#34;
defaultrouter=&#34;10.1.1.254&#34;</pre></div></div><div class=paragraph><p>而只套用到此系統的設定放在 <span class=filename>/etc/rc.conf.local</span>：</p></div><div class="literalblock programlisting"><div class=content><pre>hostname=&#34;node1.example.org&#34;
ifconfig_fxp0=&#34;inet 10.1.1.1/8&#34;</pre></div></div><div class=paragraph><p>使用應用程式如 rsync 或 puppet 將 <span class=filename>/etc/rc.conf</span> 散布到每個系統，而在各系統保留自己的 <span class=filename>/etc/rc.conf.local</span>。</p></div><div class=paragraph><p>升級系統並不會覆寫 <span class=filename>/etc/rc.conf</span>，所以系統設定資訊不會因此遺失。</p></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p><span class=filename>/etc/rc.conf</span> 以及 <span class=filename>/etc/rc.conf.local</span> 兩個檔案都會使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=sh&amp;sektion=1&amp;format=html">sh(1)</a> 解析，這讓系統操作者能夠建立較複雜的設定方案。請參考 <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a> 來取得更多有關此主題的資訊。</p></div></td></tr></tbody></table></div></div></div></div><div class=sect1><h2 id=config-network-setup>11.5. 設定網路介面卡<a class=anchor href=#config-network-setup></a></h2><div class=sectionbody><div class=paragraph><p>對 FreeBSD 管理者來說加入與設定網路介面卡 (Network Interface Card, NIC) 會是一件常見的工作。</p></div><div class=sect2><h3 id=_找到正確的驅動程式>11.5.1. 找到正確的驅動程式<a class=anchor href=#_找到正確的驅動程式></a></h3><div class=paragraph><p>首先，要先確定 NIC 的型號及其使用的晶片。FreeBSD 支援各種 NIC，可檢查該 FreeBSD 發佈版本的硬體相容性清單來查看是否有支援該 NIC。</p></div><div class=paragraph><p>若有支援該 NIC，接著要確定該 NIC 所要需要的 FreeBSD 驅動程式名稱。請參考 <span class=filename>/usr/src/sys/conf/NOTES</span> 及 <span class=filename>/usr/src/sys/arch/conf/NOTES</span> 來取得 NIC 驅動程式清單及其支援的晶片組相關資訊。當有疑問是，請閱讀該驅動程式的操作手冊，會有提供更多有關支援硬體及該驅動程式已知問題的資訊。</p></div><div class=paragraph><p><span class=filename>GENERIC</span> 核心已有內含常見 NIC 的驅動程式 ，意思是在開機時應該會偵測到 NIC。可以輸入 <code>more /var/run/dmesg.boot</code> 來檢視系統的開機訊息並使用空白鍵捲動文字。在此例中，兩個乙太網路 NIC 使用系統已有的 <a href="https://man.freebsd.org/cgi/man.cgi?query=dc&amp;sektion=4&amp;format=html">dc(4)</a> 驅動程式：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>dc0: &lt;82c169 PNIC 10/100BaseTX&gt; port 0xa000-0xa0ff mem 0xd3800000-0xd38
000ff irq 15 at device 11.0 on pci0
miibus0: &lt;MII bus&gt; on dc0
bmtphy0: &lt;BCM5201 10/100baseTX PHY&gt; PHY 1 on miibus0
bmtphy0:  10baseT, 10baseT-FDX, 100baseTX, 100baseTX-FDX, auto
dc0: Ethernet address: 00:a0:cc:da:da:da
dc0: <span class=o>[</span>ITHREAD]
dc1: &lt;82c169 PNIC 10/100BaseTX&gt; port 0x9800-0x98ff mem 0xd3000000-0xd30
000ff irq 11 at device 12.0 on pci0
miibus1: &lt;MII bus&gt; on dc1
bmtphy1: &lt;BCM5201 10/100baseTX PHY&gt; PHY 1 on miibus1
bmtphy1:  10baseT, 10baseT-FDX, 100baseTX, 100baseTX-FDX, auto
dc1: Ethernet address: 00:a0:cc:da:da:db
dc1: <span class=o>[</span>ITHREAD]</code></pre></div></div><div class=paragraph><p>若在 <span class=filename>GENERIC</span> 中沒有該 NIC 的驅動程式，但有可用的驅動程式，那麼在設定及使用 NIC 前要先載入該驅動程式，有兩種方式可以完成這件事：</p></div><div class=ulist><ul><li><p>最簡單的方式是使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=kldload&amp;sektion=8&amp;format=html">kldload(8)</a> 載入 NIC 要使用的核心模組。要在開機時自動載入，可加入適當的設定到 <span class=filename>/boot/loader.conf</span>。不是所有 NIC 驅動程式皆可當做模組使用。</p></li><li><p>或者，靜態編譯對 NIC 的支援到自訂核心，請參考 <span class=filename>/usr/src/sys/conf/NOTES</span>, <span class=filename>/usr/src/sys/arch/conf/NOTES</span> 及驅動程式的操作手冊來了解要在自訂核心設定檔中要加入那些設定。要取得更多有關重新編譯核心的資訊可參考 <a href=../kernelconfig/#kernelconfig>設定 FreeBSD 核心</a>。若在開機時有偵測到 NIC，就不需要再重新編譯核心。</p></li></ul></div><div class=sect3><h4 id=config-network-ndis>11.5.1.1. 使用 Windows™NDIS 驅動程式<a class=anchor href=#config-network-ndis></a></h4><div class=paragraph><p>很不幸的，仍有很多供應商並沒有提供它們驅動程式的技術文件給開源社群，因為這些文件有涉及商業機密。因此，FreeBSD 及其他作業系統的開發人員只剩下兩種方案可以選擇：透過長期與艱苦的過程做逆向工程來開發驅動程式或是使用現有供 Microsoft™ Windows™ 平台用的驅動程式 Binary。</p></div><div class=paragraph><p>FreeBSD 對 Network Driver Interface Specification (NDIS) 有提供 "原生" 的支援，這包含了 <a href="https://man.freebsd.org/cgi/man.cgi?query=ndisgen&amp;sektion=8&amp;format=html">ndisgen(8)</a> 可用來轉換 Windows™ XP 驅動程式成可在 FreeBSD 上使用的格式。由於 <a href="https://man.freebsd.org/cgi/man.cgi?query=ndis&amp;sektion=4&amp;format=html">ndis(4)</a> 驅動程式使用的是 Windows™ XP binary，所以只能在 i386™ 及 amd64 系統上執行。PCI, CardBus, PCMCIA 以及 USB 裝置也都有支援。</p></div><div class=paragraph><p>要使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=ndisgen&amp;sektion=8&amp;format=html">ndisgen(8)</a> 需要三樣東西：</p></div><div class="olist arabic"><ol class=arabic><li><p>FreeBSD 核心原始碼。</p></li><li><p>一個 <span class=filename>.SYS</span> 附檔名的 Windows™ XP 驅動程式 Binary。</p></li><li><p>一個 <span class=filename>.INF</span> 附檔名的 Windows™ XP 驅動程式設定檔。</p></li></ol></div><div class=paragraph><p>下載供指定 NIC 使用的 <span class=filename>.SYS</span> 及 <span class=filename>.INF</span> 檔。通常這些檔案可以在驅動程式 CD 或者供應商的網站上找到。以下範例會使用 <span class=filename>W32DRIVER.SYS</span> 及 <span class=filename>W32DRIVER.INF</span>。</p></div><div class=paragraph><p>驅動程式的位元寬度必須與 FreeBSD 的版本相符。例如 FreeBSD/i386 需要使用 Windows™ 32-bit 驅動程式，而 FreeBSD/amd64 則需要使用 Windows™ 64-bit 驅動程式。</p></div><div class=paragraph><p>下個步驟是編譯驅動程式 Binary 成可載入的核心模組。以 <code>root</code> 身份使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=ndisgen&amp;sektion=8&amp;format=html">ndisgen(8)</a>：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ndisgen /path/to/W32DRIVER.INF /path/to/W32DRIVER.SYS</span></code></pre></div></div><div class=paragraph><p>這個指令是互動式的，會提示輸入任何所需的額外資訊，新的核心模組會被產生在目前的目錄，使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=kldload&amp;sektion=8&amp;format=html">kldload(8)</a> 來載入新的模組：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload ./W32DRIVER_SYS.ko</span></code></pre></div></div><div class=paragraph><p>除了產生的核心模組之外，<span class=filename>ndis.ko</span> 以及 <span class=filename>if_ndis.ko</span> 也必須載入，會在任何有相依 <a href="https://man.freebsd.org/cgi/man.cgi?query=ndis&amp;sektion=4&amp;format=html">ndis(4)</a> 的模組被載入時一併自動載入。若沒有自動載入，則需使用以下指令手動載入：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload ndis</span>
<span class=c># kldload if_ndis</span></code></pre></div></div><div class=paragraph><p>第一個指令會載入 <a href="https://man.freebsd.org/cgi/man.cgi?query=ndis&amp;sektion=4&amp;format=html">ndis(4)</a> miniport 驅動程式包裝程式，而第二個指令會載入產生的 NIC 驅動程式。</p></div><div class=paragraph><p>檢查 <a href="https://man.freebsd.org/cgi/man.cgi?query=dmesg&amp;sektion=8&amp;format=html">dmesg(8)</a> 查看是否有任何載入錯誤，若一切正常，輸出結果應會如下所示：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>ndis0: &lt;Wireless-G PCI Adapter&gt; mem 0xf4100000-0xf4101fff irq 3 at device 8.0 on pci1
ndis0: NDIS API version: 5.0
ndis0: Ethernet address: 0a:b1:2c:d3:4e:f5
ndis0: 11b rates: 1Mbps 2Mbps 5.5Mbps 11Mbps
ndis0: 11g rates: 6Mbps 9Mbps 12Mbps 18Mbps 36Mbps 48Mbps 54Mbps</code></pre></div></div><div class=paragraph><p>到此之後 <span class=filename>ndis0</span> 可以像任何其他 NIC 設定使用。</p></div><div class=paragraph><p>要設定系統於開機時載入 <a href="https://man.freebsd.org/cgi/man.cgi?query=ndis&amp;sektion=4&amp;format=html">ndis(4)</a> 模組，可複製產生的模組 <span class=filename>W32DRIVER_SYS.ko</span> 到 <span class=filename>/boot/modules</span>。然後加入下行到 <span class=filename>/boot/loader.conf</span>：</p></div><div class="literalblock programlisting"><div class=content><pre>W32DRIVER_SYS_load=&#34;YES&#34;</pre></div></div></div></div><div class=sect2><h3 id=_設定網路卡>11.5.2. 設定網路卡<a class=anchor href=#_設定網路卡></a></h3><div class=paragraph><p>載入正確的 NIC 驅動程式之後，接著需要設定介面卡，這個動作可能在安裝時已經使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=bsdinstall&amp;sektion=8&amp;format=html">bsdinstall(8)</a> 設定過了。</p></div><div class=paragraph><p>要查看 NIC 設定可輸入以下指令：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ifconfig
dc0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        <span class=nv>options</span><span class=o>=</span>80008&lt;VLAN_MTU,LINKSTATE&gt;
        ether 00:a0:cc:da:da:da
        inet 192.168.1.3 netmask 0xffffff00 broadcast 192.168.1.255
        media: Ethernet autoselect <span class=o>(</span>100baseTX &lt;full-duplex&gt;<span class=o>)</span>
        status: active
dc1: <span class=nv>flags</span><span class=o>=</span>8802&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        <span class=nv>options</span><span class=o>=</span>80008&lt;VLAN_MTU,LINKSTATE&gt;
        ether 00:a0:cc:da:da:db
        inet 10.0.0.1 netmask 0xffffff00 broadcast 10.0.0.255
        media: Ethernet 10baseT/UTP
        status: no carrier
lo0: <span class=nv>flags</span><span class=o>=</span>8049&lt;UP,LOOPBACK,RUNNING,MULTICAST&gt; metric 0 mtu 16384
        <span class=nv>options</span><span class=o>=</span>3&lt;RXCSUM,TXCSUM&gt;
        inet6 fe80::1%lo0 prefixlen 64 scopeid 0x4
        inet6 ::1 prefixlen 128
        inet 127.0.0.1 netmask 0xff000000
        nd6 <span class=nv>options</span><span class=o>=</span>3&lt;PERFORMNUD,ACCEPT_RTADV&gt;</code></pre></div></div><div class=paragraph><p>在這個例子中列出了以下裝置：</p></div><div class=ulist><ul><li><p><span class=filename>dc0</span>: 第一個乙太網路介面。</p></li><li><p><span class=filename>dc1</span>: 第二個乙太網路介面。</p></li><li><p><span class=filename>lo0</span>: Loopback 裝置。</p></li></ul></div><div class=paragraph><p>FreeBSD 會使用驅動程式名稱接著開機時所偵測到的介面卡順序來命名 NIC。例如 <span class=filename>sis2</span> 是指在系統上使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=sis&amp;sektion=4&amp;format=html">sis(4)</a> 驅動程式的第三個 NIC。</p></div><div class=paragraph><p>在此例中，<span class=filename>dc0</span> 已經上線並且執行中。主要的依據有：</p></div><div class="olist arabic"><ol class=arabic><li><p><code>UP</code> 代表介面卡已設定好並且準備就緒。</p></li><li><p>介面卡有網際網路 (<code>inet</code>) 位址，<code>192.168.1.3</code>。</p></li><li><p>介面卡有一個有效的子網路遮罩 (<code>netmask</code>)，其中 <code>0xffffff00</code> 等同於 <code>255.255.255.0</code>。</p></li><li><p>介面卡有一個有效的廣播位址，<code>192.168.1.255</code>。</p></li><li><p>介面卡 (<code>ether</code>) 的 MAC 位址是 <code>00:a0:cc:da:da:da</code>。</p></li><li><p>實體媒介選擇為自動選擇模式 (<code>media: Ethernet autoselect (100baseTX &lt;full-duplex>)</code>)。在本例中 <span class=filename>dc1</span> 被設定使用 <code>10baseT/UTP</code> 媒介。要取得更多有關可用的驅動程式媒介類型請參考操作手冊。</p></li><li><p>連結的狀態 (<code>status</code>) 為使用中 (<code>active</code>)，代表有偵測到載波信號 (Carrier Signal)。若 <span class=filename>dc1</span> 所代表的介面卡未插入乙太網路線則狀態為 <code>status: no carrier</code> 是正常的。</p></li></ol></div><div class=paragraph><p>若 <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a> 的輸出結果如下：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>dc0: <span class=nv>flags</span><span class=o>=</span>8843&lt;BROADCAST,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
	<span class=nv>options</span><span class=o>=</span>80008&lt;VLAN_MTU,LINKSTATE&gt;
	ether 00:a0:cc:da:da:da
	media: Ethernet autoselect <span class=o>(</span>100baseTX &lt;full-duplex&gt;<span class=o>)</span>
	status: active</code></pre></div></div><div class=paragraph><p>則代表尚未設定介面卡。</p></div><div class=paragraph><p>介面卡必須以 <code>root</code> 來設定。NIC 的設定可在指令列執行 <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a> 來完成，但重新開機之後變會消失，除非將設定也加到 <span class=filename>/etc/rc.conf</span>。若在 LAN 中有 DHCP 伺服器，則只需加入此行：</p></div><div class="literalblock programlisting"><div class=content><pre>ifconfig_dc0=&#34;DHCP&#34;</pre></div></div><div class=paragraph><p>替換 <em>dc0</em> 為該系統的正確值。</p></div><div class=paragraph><p>加入這行之後，接著依據 <a href=#config-network-testing>測試與疑難排解</a> 指示操作。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>若網路在安裝時已設定，可能會已經有 NIC 的設定項目。在加入任何設定前請再次檢查 <span class=filename>/etc/rc.conf</span>。</p></div></td></tr></tbody></table></div><div class=paragraph><p>在這個例中，沒有 DHCP 伺服器，必須手動設定 NIC。提每一個在系統上的 NIC 加入一行設定，如此例：</p></div><div class="literalblock programlisting"><div class=content><pre>ifconfig_dc0=&#34;inet 192.168.1.3 netmask 255.255.255.0&#34;
ifconfig_dc1=&#34;inet 10.0.0.1 netmask 255.255.255.0 media 10baseT/UTP&#34;</pre></div></div><div class=paragraph><p>替換 <span class=filename>dc0</span> 及 <span class=filename>dc1</span> 以及 IP 位址資訊為系統的正確值。請參考驅動程式的操作手冊、<a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a> 以及 <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a> 取得更多有關可用的選項及 <span class=filename>/etc/rc.conf</span> 的語法。</p></div><div class=paragraph><p>若網路沒有使用 DNS，則編輯 <span class=filename>/etc/hosts</span> 加入 LAN 上主機的名稱與 IP 位址。要取得更多資訊請參考 <a href="https://man.freebsd.org/cgi/man.cgi?query=hosts&amp;sektion=5&amp;format=html">hosts(5)</a> 及 <span class=filename>/usr/shared/examples/etc/hosts</span>。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>若沒有 DHCP 伺服器且需要存取網際網路，那麼需要手動設定預設閘道及名稱伺服器：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># echo &#39;defaultrouter=&#34;your_default_router&#34;&#39; &gt;&gt; /etc/rc.conf</span>
<span class=c># echo &#39;nameserver your_DNS_server&#39; &gt;&gt; /etc/resolv.conf</span></code></pre></div></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=config-network-testing>11.5.3. 測試與疑難排解<a class=anchor href=#config-network-testing></a></h3><div class=paragraph><p>必要的變更儲存到 <span class=filename>/etc/rc.conf</span> 之後，需要重新啟動系統來測試網路設定並檢查系統重新啟動是否沒有任何設定錯誤。或者使用這個指令將設定套用到網路系統：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service netif restart</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>若預設的通訊閘已設定於 <span class=filename>/etc/rc.conf</span> 也同樣要下這個指令：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service routing restart</span></code></pre></div></div></td></tr></tbody></table></div><div class=paragraph><p>網路系統重新啟動後，便可接著測試 NIC。</p></div><div class=sect3><h4 id=_測試乙太網路卡>11.5.3.1. 測試乙太網路卡<a class=anchor href=#_測試乙太網路卡></a></h4><div class=paragraph><p>要檢查乙太網路卡是否已正確設定可 <a href="https://man.freebsd.org/cgi/man.cgi?query=ping&amp;sektion=8&amp;format=html">ping(8)</a> 介面卡自己，然後 <a href="https://man.freebsd.org/cgi/man.cgi?query=ping&amp;sektion=8&amp;format=html">ping(8)</a> 其他於 LAN 上的主機：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ping <span class=nt>-c5</span> 192.168.1.3
PING 192.168.1.3 <span class=o>(</span>192.168.1.3<span class=o>)</span>: 56 data bytes
64 bytes from 192.168.1.3: <span class=nv>icmp_seq</span><span class=o>=</span>0 <span class=nv>ttl</span><span class=o>=</span>64 <span class=nb>time</span><span class=o>=</span>0.082 ms
64 bytes from 192.168.1.3: <span class=nv>icmp_seq</span><span class=o>=</span>1 <span class=nv>ttl</span><span class=o>=</span>64 <span class=nb>time</span><span class=o>=</span>0.074 ms
64 bytes from 192.168.1.3: <span class=nv>icmp_seq</span><span class=o>=</span>2 <span class=nv>ttl</span><span class=o>=</span>64 <span class=nb>time</span><span class=o>=</span>0.076 ms
64 bytes from 192.168.1.3: <span class=nv>icmp_seq</span><span class=o>=</span>3 <span class=nv>ttl</span><span class=o>=</span>64 <span class=nb>time</span><span class=o>=</span>0.108 ms
64 bytes from 192.168.1.3: <span class=nv>icmp_seq</span><span class=o>=</span>4 <span class=nv>ttl</span><span class=o>=</span>64 <span class=nb>time</span><span class=o>=</span>0.076 ms

<span class=nt>---</span> 192.168.1.3 ping statistics <span class=nt>---</span>
5 packets transmitted, 5 packets received, 0% packet loss
round-trip min/avg/max/stddev <span class=o>=</span> 0.074/0.083/0.108/0.013 ms</code></pre></div></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ping <span class=nt>-c5</span> 192.168.1.2
PING 192.168.1.2 <span class=o>(</span>192.168.1.2<span class=o>)</span>: 56 data bytes
64 bytes from 192.168.1.2: <span class=nv>icmp_seq</span><span class=o>=</span>0 <span class=nv>ttl</span><span class=o>=</span>64 <span class=nb>time</span><span class=o>=</span>0.726 ms
64 bytes from 192.168.1.2: <span class=nv>icmp_seq</span><span class=o>=</span>1 <span class=nv>ttl</span><span class=o>=</span>64 <span class=nb>time</span><span class=o>=</span>0.766 ms
64 bytes from 192.168.1.2: <span class=nv>icmp_seq</span><span class=o>=</span>2 <span class=nv>ttl</span><span class=o>=</span>64 <span class=nb>time</span><span class=o>=</span>0.700 ms
64 bytes from 192.168.1.2: <span class=nv>icmp_seq</span><span class=o>=</span>3 <span class=nv>ttl</span><span class=o>=</span>64 <span class=nb>time</span><span class=o>=</span>0.747 ms
64 bytes from 192.168.1.2: <span class=nv>icmp_seq</span><span class=o>=</span>4 <span class=nv>ttl</span><span class=o>=</span>64 <span class=nb>time</span><span class=o>=</span>0.704 ms

<span class=nt>---</span> 192.168.1.2 ping statistics <span class=nt>---</span>
5 packets transmitted, 5 packets received, 0% packet loss
round-trip min/avg/max/stddev <span class=o>=</span> 0.700/0.729/0.766/0.025 ms</code></pre></div></div><div class=paragraph><p>要測試網路解析，可使用主機名稱來替代 IP 位址。若在網路上沒有 DNS 伺服器則必須先設定 <span class=filename>/etc/hosts</span>，若主機尚未設定到 <span class=filename>/etc/hosts</span> 中，則需編輯 <span class=filename>/etc/hosts</span> 加入 LAN 上主機的名稱及 IP 位址，要取得更多資訊請參考 <a href="https://man.freebsd.org/cgi/man.cgi?query=hosts&amp;sektion=5&amp;format=html">hosts(5)</a> 及 <span class=filename>/usr/shared/examples/etc/hosts</span>。</p></div></div><div class=sect3><h4 id=_疑難排解>11.5.3.2. 疑難排解<a class=anchor href=#_疑難排解></a></h4><div class=paragraph><p>在排除硬體及軟體設定問題時，要先檢查幾件簡單的事。網路線插上了沒？網路的服務都正確設定了嗎？防火牆設定是否正確？FreeBSD 是否支援該 NIC？在回報問題之前，永遠要先檢查 Hardware Notes、更新 FreeBSD 到最新的 STABLE 版本、檢查郵遞論壇封存記錄以及上網查詢。</p></div><div class=paragraph><p>若介面卡可以運作，但是效能很差，請閱讀 <a href="https://man.freebsd.org/cgi/man.cgi?query=tuning&amp;sektion=7&amp;format=html">tuning(7)</a>，同時也要檢查網路設定，因為不正確的網路設定會造成連線速度緩慢。</p></div><div class=paragraph><p>部份使用者會遇到一次或兩次 <code>device timeout</code> 的訊息，在對某些介面卡是正常的。若訊息持續發生或很煩的，請確認是否有與其他的裝置衝突，再次檢查網路線，或考慮使用其他介面卡。</p></div><div class=paragraph><p>要解決 <code>watchdog timeout</code> 錯誤，先檢查網路線。許多介面卡需要使用支援 Bus Mastering 的 PCI 插槽，在一些舊型的主機板，只會有一個 PCI 插槽支援，通常是插槽 0。檢查 NIC 以及主機板說明文件來確定是否為此問題。</p></div><div class=paragraph><p>若系統無法路由傳送封包到目標主機則會出現 <code>No route to host</code> 訊息，這可能是因為沒有指定預設的路由或未插上網路線。請檢查 <code>netstat -rn</code> 的輸出並確認有一個有效的路由可連線至主機，若沒有，請閱讀 <a href=../advanced-networking/#network-routing>通訊閘與路由</a>。</p></div><div class=paragraph><p>造成 <code>ping: sendto: Permission denied</code> 錯誤訊息的原因通常是防火牆設定錯誤。若在 FreeBSD 上有開啟防火牆，但卻未定義任何的規則，預設的原則是拒絕所有傳輸，即使是用 <a href="https://man.freebsd.org/cgi/man.cgi?query=ping&amp;sektion=8&amp;format=html">ping(8)</a>。請參考 <a href=../firewalls/#firewalls>防火牆</a> 取得更多資訊。</p></div><div class=paragraph><p>有時介面卡的效能很差或低於平均值，在這種情況可嘗試設定媒介選擇模式由 <code>autoselect</code> 更改為正確的媒介選項，雖然這在大部份硬體可運作，但可能無法解決問題，同樣的，檢查所有網路設定並參考 <a href="https://man.freebsd.org/cgi/man.cgi?query=tuning&amp;sektion=7&amp;format=html">tuning(7)</a>。</p></div></div></div></div></div><div class=sect1><h2 id=configtuning-virtual-hosts>11.6. 虛擬主機<a class=anchor href=#configtuning-virtual-hosts></a></h2><div class=sectionbody><div class=paragraph><p>FreeBSD 最常見的用途之一就是虛擬網站代管，即以一台伺服器在網路上扮演多台伺服器，這可以透過指定多個網路位置到一個網路介面來做到。</p></div><div class=paragraph><p>一個網路介面會有一個 "真實 (Real)" 位址且可以有許多個 "別名 (Alias)" 位址。一般會在 <span class=filename>/etc/rc.conf</span> 中放置別名項目來增加別名，如下例：</p></div><div class="literalblock programlisting"><div class=content><pre>ifconfig_fxp0_alias0=&#34;inet xxx.xxx.xxx.xxx netmask xxx.xxx.xxx.xxx&#34;</pre></div></div><div class=paragraph><p>別名項目必須以 <code>alias<em>0</em></code> 開頭，使用連續數字例如 <code>alias0</code>, <code>alias1</code> 以此類推，設定程序會在第一個遇到缺號的地方中止。</p></div><div class=paragraph><p>要注意別名網路遮罩 (Netmask) 的計算，使用的介面必須至少有一個正確的填寫網路遮罩的位址，而其他所有在此網路中的位址則必須使用全部 <code>1</code> 的網路遮罩，可用 <code>255.255.255.255</code> 或 <code>0xffffffff</code> 來表示。</p></div><div class=paragraph><p>舉例來說，有一個 <span class=filename>fxp0</span> 介面連結到兩個網路：<code>10.1.1.0</code> 使用網路遮罩 <code>255.255.255.0</code> 以及 <code>202.0.75.16</code> 使用網路遮罩 <code>255.255.255.240</code>。而系統將要設定使用範圍 <code>10.1.1.1</code> 到 <code>10.1.1.5</code> 以及 <code>202.0.75.17</code> 到 <code>202.0.75.20</code>。在指定的網路範圍中只有第一個位址應使用真實的網路遮罩，其餘 (<code>10.1.1.2</code> 到 <code>10.1.1.5</code> 及 <code>202.0.75.18</code> 到 <code>202.0.75.20</code>) 則必須設定使用 <code>255.255.255.255</code> 的遮罩。</p></div><div class=paragraph><p>在此情境下正確設定網路介面的方式如下 <span class=filename>/etc/rc.conf</span> 中的項目：</p></div><div class="literalblock programlisting"><div class=content><pre>ifconfig_fxp0=&#34;inet 10.1.1.1 netmask 255.255.255.0&#34;
ifconfig_fxp0_alias0=&#34;inet 10.1.1.2 netmask 255.255.255.255&#34;
ifconfig_fxp0_alias1=&#34;inet 10.1.1.3 netmask 255.255.255.255&#34;
ifconfig_fxp0_alias2=&#34;inet 10.1.1.4 netmask 255.255.255.255&#34;
ifconfig_fxp0_alias3=&#34;inet 10.1.1.5 netmask 255.255.255.255&#34;
ifconfig_fxp0_alias4=&#34;inet 202.0.75.17 netmask 255.255.255.240&#34;
ifconfig_fxp0_alias5=&#34;inet 202.0.75.18 netmask 255.255.255.255&#34;
ifconfig_fxp0_alias6=&#34;inet 202.0.75.19 netmask 255.255.255.255&#34;
ifconfig_fxp0_alias7=&#34;inet 202.0.75.20 netmask 255.255.255.255&#34;</pre></div></div><div class=paragraph><p>有一種更簡單的方式可以表達這些設定，便是使用以空白分隔的 IP 位址清單。只有第一個位址會使用指定的子網路遮罩，其他的位址則會使用 <code>255.255.255.255</code> 的子網路遮罩。</p></div><div class="literalblock programlisting"><div class=content><pre>ifconfig_fxp0_aliases=&#34;inet 10.1.1.1-5/24 inet 202.0.75.17-20/28&#34;</pre></div></div></div></div><div class=sect1><h2 id=configtuning-syslog>11.7. 設定系統日誌<a class=anchor href=#configtuning-syslog></a></h2><div class=sectionbody><div class=paragraph><p>產生與讀取系統日誌對系統管理來說是一件非常重要的事，在系統日誌中的資訊可以用來偵測硬體與軟體的問題，同樣也可以偵測應用程式與系統設定的錯誤。這些資訊在安全性稽查與事件回應也同樣扮演了重要的角色，大多數系統 Daemon 與應用程式都會產生日誌項目。</p></div><div class=paragraph><p>FreeBSD 提供了一個系統日誌程式 syslogd 用來管理日誌。預設 syslogd 會與系統開機時啟動。這可使用在 <span class=filename>/etc/rc.conf</span> 中的變數 <code>syslogd_enable</code> 來控制。而且有數個應用程式參數可在 <span class=filename>/etc/rc.conf</span> 使用 <code>syslogd_flags</code> 來設定。請參考 <a href="https://man.freebsd.org/cgi/man.cgi?query=syslogd&amp;sektion=8&amp;format=html">syslogd(8)</a> 來取得更多可用參數的資訊。</p></div><div class=paragraph><p>此章節會介紹如何設定 FreeBSD 系統日誌程式來做本地與遠端日誌並且介紹如何執行日誌翻轉 (Log rotation) 與日誌管理。</p></div><div class=sect2><h3 id=_設定本地日誌>11.7.1. 設定本地日誌<a class=anchor href=#_設定本地日誌></a></h3><div class=paragraph><p>設定檔 <span class=filename>/etc/syslog.conf</span> 控制 syslogd 收到日誌項目時要做的事情，有數個參數可以用來控制接收到事件時的處理方式。<em>設施 (facility)</em> 用來描述記錄產生訊息的子系統 (subsystem)，如核心或者 Daemon，而 <em>層級 (level)</em> 用來描述所發生的事件嚴重性。也可以依據應用程式所發出的訊息及產生日誌事件機器的主機名稱來決定後續處置的動作。</p></div><div class=paragraph><p>此設定檔中一行代表一個動作，每一行的格式皆為一個選擇器欄位 (Selector field) 接著一個動作欄位 (Action field)。選擇器欄位的格式為 <em>facility.level</em> 可以用來比對來自 <em>facility</em> 於層級 <em>level</em> 或更高層的日誌訊息，也可以在層級前加入選擇性的比對旗標來更確切的指定記錄的內容。同樣一個動作可以使用多個選擇器欄位並使用分號 (<code>;</code>) 來分隔。用 <code>*</code> 可以比對任何東西。動作欄位可用來指定傳送日誌訊息的目標，如一個檔案或遠端日誌主機。範例為以下為 FreeBSD 預設的 <span class=filename>syslog.conf</span>：</p></div><div class="literalblock programlisting"><div class=content><pre># $FreeBSD: head/zh_TW.UTF-8/books/handbook/book.xml 53653 2019-12-03 17:05:41Z rcyu $
#
#       Spaces ARE valid field separators in this file. However,
#       other *nix-like systems still insist on using tabs as field
#       separators. If you are sharing this file between systems, you
#       may want to use only tabs as field separators here.
#       Consult the syslog.conf(5) manpage.
*.err;kern.warning;auth.notice;mail.crit                /dev/console
*.notice;authpriv.none;kern.debug;lpr.info;mail.crit;news.err   /var/log/messages
security.*                                      /var/log/security
auth.info;authpriv.info                         /var/log/auth.log
mail.info                                       /var/log/maillog
lpr.info                                        /var/log/lpd-errs
ftp.info                                        /var/log/xferlog
cron.*                                          /var/log/cron
!-devd
*.=debug                                        /var/log/debug.log
*.emerg                                         *
# uncomment this to log all writes to /dev/console to /var/log/console.log
#console.info                                   /var/log/console.log
# uncomment this to enable logging of all log messages to /var/log/all.log
# touch /var/log/all.log and chmod it to mode 600 before it will work
#*.*                                            /var/log/all.log
# uncomment this to enable logging to a remote loghost named loghost
#*.*                                            @loghost
# uncomment these if you&#39;re running inn
# news.crit                                     /var/log/news/news.crit
# news.err                                      /var/log/news/news.err
# news.notice                                   /var/log/news/news.notice
# Uncomment this if you wish to see messages produced by devd
# !devd
# *.&gt;=info
!ppp
*.*                                             /var/log/ppp.log
!*</pre></div></div><div class=paragraph><p>在這個範例中：</p></div><div class=ulist><ul><li><p>第 8 行會找出所有符合 <code>err</code> 或以上層級的訊息，還有 <code>kern.warning</code>, <code>auth.notice</code> 與 <code>mail.crit</code> 的訊息，然後將這些日誌訊息傳送到 Console (<span class=filename>/dev/console</span>)。</p></li><li><p>第 12 行會找出所有符合 <code>mail</code> 設施中於 <code>info</code> 或以上層級的訊息，並記錄訊息至 <span class=filename>/var/log/maillog</span>。</p></li><li><p>第 17 行使用了比較旗標 (<code>=</code>) 來只找出符合 <code>debug</code> 層級的訊息，並將訊息記錄至 <span class=filename>/var/log/debug.log</span>。</p></li><li><p>第 33 行是指定程式的範例用法。這可以讓在該行以下的規則只對指定的程式生效。在此例中，只有由 ppp 產生的訊息會被記錄到 <span class=filename>/var/log/ppp.log</span>。</p></li></ul></div><div class=paragraph><p>所以可用層級從最嚴重到最不嚴重的順序為 <code>emerg</code>, <code>alert</code>, <code>crit</code>, <code>err</code>, <code>warning</code>, <code>notice</code>, <code>info</code> 以及 <code>debug</code>。</p></div><div class=paragraph><p>設施 (facility) 則無特定順序，可用的有 <code>auth</code>, <code>authpriv</code>, <code>console</code>, <code>cron</code>, <code>daemon</code>, <code>ftp</code>, <code>kern</code>, <code>lpr</code>, <code>mail</code>, <code>mark</code>, <code>news</code>, <code>security</code>, <code>syslog</code>, <code>user</code>, <code>uucp</code> 及 <code>local0</code> 到 <code>local7</code>。要注意在其他作業系統的設施可能會不同。</p></div><div class=paragraph><p>要記錄所有所有 <code>notice</code> 與以上層級的訊息到 <span class=filename>/var/log/daemon.log</span> 可加入以下項目：</p></div><div class="literalblock programlisting"><div class=content><pre>daemon.notice                                        /var/log/daemon.log</pre></div></div><div class=paragraph><p>要取得更多有關不同的層級與設施的資訊請參考 <a href="https://man.freebsd.org/cgi/man.cgi?query=syslog&amp;sektion=3&amp;format=html">syslog(3)</a> 及 <a href="https://man.freebsd.org/cgi/man.cgi?query=syslogd&amp;sektion=8&amp;format=html">syslogd(8)</a>。要取得更多有關 <span class=filename>/etc/syslog.conf</span>、語法以及更多進階用法範例的資訊請參考 <a href="https://man.freebsd.org/cgi/man.cgi?query=syslog.conf&amp;sektion=5&amp;format=html">syslog.conf(5)</a>。</p></div></div><div class=sect2><h3 id=_日誌管理與翻轉>11.7.2. 日誌管理與翻轉<a class=anchor href=#_日誌管理與翻轉></a></h3><div class=paragraph><p>日誌檔案會成長的非常快速，這會消耗磁碟空間並且會更難在日誌中找到有用的資訊，日誌管理便是為了嘗試減緩這種問題。在 FreeBSD 可以使用 newsyslog 來管理日誌檔案，這個內建的程式會定期翻轉 (Rotate) 與壓縮日誌檔案，並且可選擇性的建立遺失的日誌檔案並在日誌檔案被移動位置時通知程式。日誌檔案可能會由 syslogd 產生或由其他任何會產生日誌檔案的程式。newsyslog 正常會由 <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a> 來執行，它並非一個系統 Daemon，預設會每個小時執行一次。</p></div><div class=paragraph><p>newsyslog 會讀取其設定檔 <span class=filename>/etc/newsyslog.conf</span> 來決定其要採取的動作，每個要由 newsyslog 所管理的日誌檔案會在此設定檔中設定一行，每一行要說明檔案的擁有者、權限、何時要翻轉該檔案、選用的日誌翻轉旗標，如：壓縮，以及日誌翻轉時要通知的程式。以下為 FreeBSD 的預設設定：</p></div><div class="literalblock programlisting"><div class=content><pre># configuration file for newsyslog
# $FreeBSD: head/zh_TW.UTF-8/books/handbook/book.xml 53653 2019-12-03 17:05:41Z rcyu $
#
# Entries which do not specify the &#39;/pid_file&#39; field will cause the
# syslogd process to be signalled when that log file is rotated.  This
# action is only appropriate for log files which are written to by the
# syslogd process (ie, files listed in /etc/syslog.conf).  If there
# is no process which needs to be signalled when a given log file is
# rotated, then the entry for that file should include the &#39;N&#39; flag.
#
# The &#39;flags&#39; field is one or more of the letters: BCDGJNUXZ or a &#39;-&#39;.
#
# Note: some sites will want to select more restrictive protections than the
# defaults.  In particular, it may be desirable to switch many of the 644
# entries to 640 or 600.  For example, some sites will consider the
# contents of maillog, messages, and lpd-errs to be confidential.  In the
# future, these defaults may change to more conservative ones.
#
# logfilename          [owner:group]    mode count size when  flags [/pid_file] [sig_num]
/var/log/all.log                        600  7     *    @T00  J
/var/log/amd.log                        644  7     100  *     J
/var/log/auth.log                       600  7     100  @0101T JC
/var/log/console.log                    600  5     100  *     J
/var/log/cron                           600  3     100  *     JC
/var/log/daily.log                      640  7     *    @T00  JN
/var/log/debug.log                      600  7     100  *     JC
/var/log/kerberos.log                   600  7     100  *     J
/var/log/lpd-errs                       644  7     100  *     JC
/var/log/maillog                        640  7     *    @T00  JC
/var/log/messages                       644  5     100  @0101T JC
/var/log/monthly.log                    640  12    *    $M1D0 JN
/var/log/pflog                          600  3     100  *     JB    /var/run/pflogd.pid
/var/log/ppp.log        root:network    640  3     100  *     JC
/var/log/devd.log                       644  3     100  *     JC
/var/log/security                       600  10    100  *     JC
/var/log/sendmail.st                    640  10    *    168   B
/var/log/utx.log                        644  3     *    @01T05 B
/var/log/weekly.log                     640  5     1    $W6D0 JN
/var/log/xferlog                        600  7     100  *     JC</pre></div></div><div class=paragraph><p>每一行的開始為要翻轉的日誌名稱、接著是供翻轉與新建檔案使用的擁有者及群組 (選填)。<code>mode</code> 欄位可設定日誌檔案的權限，<code>count</code> 代表要保留多少個翻轉過的日誌檔案，而 <code>size</code> 與 <code>when</code> 欄位會告訴 newsyslog 何時要翻轉該檔案。日誌檔案會在當其檔案超過 <code>size</code> 欄位的大小或已超過 <code>when</code> 欄位指定的時間時翻轉，可使用星號 (<code>*</code>) 忽略該欄位。<em>flags</em> 欄位可以給予進階的參數，例如：如何壓縮翻轉後檔案或建立遺失的日誌檔案。最後兩個欄位皆為選填，可指定程序的程序 ID (PID) 檔名稱以及檔案翻轉後要傳送給該程序的信號 (Signal) 編號。</p></div><div class=paragraph><p>要取的更多有關所有欄位、可用的旗標及如何指定翻轉時間，請參考 <a href="https://man.freebsd.org/cgi/man.cgi?query=newsyslog.conf&amp;sektion=5&amp;format=html">newsyslog.conf(5)</a>。由於 newsyslog 是由 <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a> 執行，因此無法比其在 <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a> 中所排定的時間間距內更頻繁的執行翻轉檔案。</p></div></div><div class=sect2><h3 id=network-syslogd>11.7.3. 設定遠端日誌<a class=anchor href=#network-syslogd></a></h3><div class=paragraph><p>Monitoring the log files of multiple hosts can become unwieldy as the number of systems increases. Configuring centralized logging can reduce some of the administrative burden of log file administration.</p></div><div class=paragraph><p>In FreeBSD, centralized log file aggregation, merging, and rotation can be configured using syslogd and newsyslog. This section demonstrates an example configuration, where host <code>A</code>, named <code>logserv.example.com</code>, will collect logging information for the local network. Host <code>B</code>, named <code>logclient.example.com</code>, will be configured to pass logging information to the logging server.</p></div><div class=sect3><h4 id=_日誌伺服器設定>11.7.3.1. 日誌伺服器設定<a class=anchor href=#_日誌伺服器設定></a></h4><div class=paragraph><p>A log server is a system that has been configured to accept logging information from other hosts. Before configuring a log server, check the following:</p></div><div class=ulist><ul><li><p>If there is a firewall between the logging server and any logging clients, ensure that the firewall ruleset allows UDP port 514 for both the clients and the server.</p></li><li><p>The logging server and all client machines must have forward and reverse entries in the local DNS. If the network does not have a DNS server, create entries in each system’s <span class=filename>/etc/hosts</span>. Proper name resolution is required so that log entries are not rejected by the logging server.</p></li></ul></div><div class=paragraph><p>On the log server, edit <span class=filename>/etc/syslog.conf</span> to specify the name of the client to receive log entries from, the logging facility to be used, and the name of the log to store the host’s log entries. This example adds the hostname of <code>B</code>, logs all facilities, and stores the log entries in <span class=filename>/var/log/logclient.log</span>.</p></div><div class=exampleblock><div class=title>例 1. 日誌伺服器設定範例</div><div class=content><div class="literalblock programlisting"><div class=content><pre>+logclient.example.com
*.*     /var/log/logclient.log</pre></div></div></div></div><div class=paragraph><p>When adding multiple log clients, add a similar two-line entry for each client. More information about the available facilities may be found in <a href="https://man.freebsd.org/cgi/man.cgi?query=syslog.conf&amp;sektion=5&amp;format=html">syslog.conf(5)</a>.</p></div><div class=paragraph><p>Next, configure <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>syslogd_enable=&#34;YES&#34;
syslogd_flags=&#34;-a logclient.example.com -v -v&#34;</pre></div></div><div class=paragraph><p>The first entry starts syslogd at system boot. The second entry allows log entries from the specified client. The <code>-v -v</code> increases the verbosity of logged messages. This is useful for tweaking facilities as administrators are able to see what type of messages are being logged under each facility.</p></div><div class=paragraph><p>Multiple <code>-a</code> options may be specified to allow logging from multiple clients. IP addresses and whole netblocks may also be specified. Refer to <a href="https://man.freebsd.org/cgi/man.cgi?query=syslogd&amp;sektion=8&amp;format=html">syslogd(8)</a> for a full list of possible options.</p></div><div class=paragraph><p>Finally, create the log file:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># touch /var/log/logclient.log</span></code></pre></div></div><div class=paragraph><p>At this point, syslogd should be restarted and verified:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service syslogd restart</span>
<span class=c># pgrep syslog</span></code></pre></div></div><div class=paragraph><p>If a PID is returned, the server restarted successfully, and client configuration can begin. If the server did not restart, consult <span class=filename>/var/log/messages</span> for the error.</p></div></div><div class=sect3><h4 id=_日誌客戶端設定>11.7.3.2. 日誌客戶端設定<a class=anchor href=#_日誌客戶端設定></a></h4><div class=paragraph><p>A logging client sends log entries to a logging server on the network. The client also keeps a local copy of its own logs.</p></div><div class=paragraph><p>Once a logging server has been configured, edit <span class=filename>/etc/rc.conf</span> on the logging client:</p></div><div class="literalblock programlisting"><div class=content><pre>syslogd_enable=&#34;YES&#34;
syslogd_flags=&#34;-s -v -v&#34;</pre></div></div><div class=paragraph><p>The first entry enables syslogd on boot up. The second entry prevents logs from being accepted by this client from other hosts (<code>-s</code>) and increases the verbosity of logged messages.</p></div><div class=paragraph><p>Next, define the logging server in the client’s <span class=filename>/etc/syslog.conf</span>. In this example, all logged facilities are sent to a remote system, denoted by the <code>@</code> symbol, with the specified hostname:</p></div><div class="literalblock programlisting"><div class=content><pre>*.*		@logserv.example.com</pre></div></div><div class=paragraph><p>After saving the edit, restart syslogd for the changes to take effect:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service syslogd restart</span></code></pre></div></div><div class=paragraph><p>To test that log messages are being sent across the network, use <a href="https://man.freebsd.org/cgi/man.cgi?query=logger&amp;sektion=1&amp;format=html">logger(1)</a> on the client to send a message to syslogd:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># logger &#34;Test message from logclient&#34;</span></code></pre></div></div><div class=paragraph><p>This message should now exist both in <span class=filename>/var/log/messages</span> on the client and <span class=filename>/var/log/logclient.log</span> on the log server.</p></div></div><div class=sect3><h4 id=_日誌伺服器除錯>11.7.3.3. 日誌伺服器除錯<a class=anchor href=#_日誌伺服器除錯></a></h4><div class=paragraph><p>If no messages are being received on the log server, the cause is most likely a network connectivity issue, a hostname resolution issue, or a typo in a configuration file. To isolate the cause, ensure that both the logging server and the logging client are able to <code>ping</code> each other using the hostname specified in their <span class=filename>/etc/rc.conf</span>. If this fails, check the network cabling, the firewall ruleset, and the hostname entries in the DNS server or <span class=filename>/etc/hosts</span> on both the logging server and clients. Repeat until the <code>ping</code> is successful from both hosts.</p></div><div class=paragraph><p>If the <code>ping</code> succeeds on both hosts but log messages are still not being received, temporarily increase logging verbosity to narrow down the configuration issue. In the following example, <span class=filename>/var/log/logclient.log</span> on the logging server is empty and <span class=filename>/var/log/messages</span> on the logging client does not indicate a reason for the failure. To increase debugging output, edit the <code>syslogd_flags</code> entry on the logging server and issue a restart:</p></div><div class="literalblock programlisting"><div class=content><pre>syslogd_flags=&#34;-d -a logclient.example.com -v -v&#34;</pre></div></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service syslogd restart</span></code></pre></div></div><div class=paragraph><p>Debugging data similar to the following will flash on the console immediately after the restart:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>logmsg: pri 56, flags 4, from logserv.example.com, msg syslogd: restart
syslogd: restarted
logmsg: pri 6, flags 4, from logserv.example.com, msg syslogd: kernel boot file is /boot/kernel/kernel
Logging to FILE /var/log/messages
syslogd: kernel boot file is /boot/kernel/kernel
cvthname<span class=o>(</span>192.168.1.10<span class=o>)</span>
validate: dgram from IP 192.168.1.10, port 514, name logclient.example.com<span class=p>;</span>
rejected <span class=k>in </span>rule 0 due to name mismatch.</code></pre></div></div><div class=paragraph><p>In this example, the log messages are being rejected due to a typo which results in a hostname mismatch. The client’s hostname should be <code>logclient</code>, not <code>logclien</code>. Fix the typo, issue a restart, and verify the results:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service syslogd restart</span>
logmsg: pri 56, flags 4, from logserv.example.com, msg syslogd: restart
syslogd: restarted
logmsg: pri 6, flags 4, from logserv.example.com, msg syslogd: kernel boot file is /boot/kernel/kernel
syslogd: kernel boot file is /boot/kernel/kernel
logmsg: pri 166, flags 17, from logserv.example.com,
msg Dec 10 20:55:02 &lt;syslog.err&gt; logserv.example.com syslogd: exiting on signal 2
cvthname<span class=o>(</span>192.168.1.10<span class=o>)</span>
validate: dgram from IP 192.168.1.10, port 514, name logclient.example.com<span class=p>;</span>
accepted <span class=k>in </span>rule 0.
logmsg: pri 15, flags 0, from logclient.example.com, msg Dec 11 02:01:28 trhodes: Test message 2
Logging to FILE /var/log/logclient.log
Logging to FILE /var/log/messages</code></pre></div></div><div class=paragraph><p>At this point, the messages are being properly received and placed in the correct file.</p></div></div><div class=sect3><h4 id=_安全注意事項>11.7.3.4. 安全注意事項<a class=anchor href=#_安全注意事項></a></h4><div class=paragraph><p>As with any network service, security requirements should be considered before implementing a logging server. Log files may contain sensitive data about services enabled on the local host, user accounts, and configuration data. Network data sent from the client to the server will not be encrypted or password protected. If a need for encryption exists, consider using <a class=package href=https://cgit.freebsd.org/ports/tree/security/stunnel/>security/stunnel</a>, which will transmit the logging data over an encrypted tunnel.</p></div><div class=paragraph><p>Local security is also an issue. Log files are not encrypted during use or after log rotation. Local users may access log files to gain additional insight into system configuration. Setting proper permissions on log files is critical. The built-in log rotator, newsyslog, supports setting permissions on newly created and rotated log files. Setting log files to mode <code>600</code> should prevent unwanted access by local users. Refer to <a href="https://man.freebsd.org/cgi/man.cgi?query=newsyslog.conf&amp;sektion=5&amp;format=html">newsyslog.conf(5)</a> for additional information.</p></div></div></div></div></div><div class=sect1><h2 id=configtuning-configfiles>11.8. 設定檔<a class=anchor href=#configtuning-configfiles></a></h2><div class=sectionbody><div class=sect2><h3 id=_etc_配置>11.8.1. <span class=filename>/etc</span> 配置<a class=anchor href=#_etc_配置></a></h3><div class=paragraph><p>有數個目錄中儲存著設定資訊，這些目錄有：</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/etc</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>通用系統特定的設定資訊。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/etc/defaults</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>系統設定檔的預設版本。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/etc/mail</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a href="https://man.freebsd.org/cgi/man.cgi?query=sendmail&amp;sektion=8&amp;format=html">sendmail(8)</a> 額外的設定以及其他 MTA 設定檔。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/etc/ppp</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>user- 及 kernel-ppp 程式的設定。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/local/etc</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>已安裝應用程式的設定檔，可能會有以應用程式區分的子目錄。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/local/etc/rc.d</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>已安裝應用程式的 <a href="https://man.freebsd.org/cgi/man.cgi?query=rc&amp;sektion=8&amp;format=html">rc(8)</a> Script。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/var/db</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>自動產生的系統特定資料庫檔案，例如套件資料庫以及 <a href="https://man.freebsd.org/cgi/man.cgi?query=locate&amp;sektion=1&amp;format=html">locate(1)</a> 資料庫。</p></td></tr></tbody></table></div><div class=sect2><h3 id=_主機名稱>11.8.2. 主機名稱<a class=anchor href=#_主機名稱></a></h3><div class=sect3><h4 id=_etcresolv_conf>11.8.2.1. <span class=filename>/etc/resolv.conf</span><a class=anchor href=#_etcresolv_conf></a></h4><div class=paragraph><p>FreeBSD 要如何存取網際網路網域名稱系統 (Internet Domain Name System, DNS) 是由 <a href="https://man.freebsd.org/cgi/man.cgi?query=resolv.conf&amp;sektion=5&amp;format=html">resolv.conf(5)</a> 來控制。</p></div><div class=paragraph><p><span class=filename>/etc/resolv.conf</span> 中最常用的項目為：</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>nameserver</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>解析程式 (Resolver) 要查詢的名稱伺服器 IP 位置，這些伺服器會依所列的順序來查詢，最多可以有三個。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>search</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>主機名稱查詢使用的搜尋清單。這通常會使用本機主機名稱所在的網域。</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>domain</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>本地網域名稱。</p></td></tr></tbody></table><div class=paragraph><p>典型的 <span class=filename>/etc/resolv.conf</span> 會如下：</p></div><div class="literalblock programlisting"><div class=content><pre>search example.com
nameserver 147.11.1.11
nameserver 147.11.100.30</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p><code>search</code> 與 <code>domain</code> 選項應擇一使用。</p></div></td></tr></tbody></table></div><div class=paragraph><p>當使用 DHCP 時，<a href="https://man.freebsd.org/cgi/man.cgi?query=dhclient&amp;sektion=8&amp;format=html">dhclient(8)</a> 通常會使用從 DHCP 伺服器所接收到的資訊覆寫 <span class=filename>/etc/resolv.conf</span>。</p></div></div><div class=sect3><h4 id=_etchosts>11.8.2.2. <span class=filename>/etc/hosts</span><a class=anchor href=#_etchosts></a></h4><div class=paragraph><p><span class=filename>/etc/hosts</span> 是簡單的文字資料庫，會與 DNS 及 NIS 一併使用來提供主機名稱與 IP 位址的對應。可將透過 LAN 所連結的在地電腦項目加入到這個檔案做最簡單的命名，來替代設定一個 <a href="https://man.freebsd.org/cgi/man.cgi?query=named&amp;sektion=8&amp;format=html">named(8)</a> 伺服器。除此之外 <span class=filename>/etc/hosts</span> 可以用來提供本地的網際網路名稱記錄，來減少常用名稱向外部 DNS 伺服器查詢的需求。</p></div><div class="literalblock programlisting"><div class=content><pre># $FreeBSD: head/zh_TW.UTF-8/books/handbook/book.xml 53653 2019-12-03 17:05:41Z rcyu $
#
#
# Host Database
#
# This file should contain the addresses and aliases for local hosts that
# share this file.  Replace &#39;my.domain&#39; below with the domainname of your
# machine.
#
# In the presence of the domain name service or NIS, this file may
# not be consulted at all; see /etc/nsswitch.conf for the resolution order.
#
#
::1			localhost localhost.my.domain
127.0.0.1		localhost localhost.my.domain
#
# Imaginary network.
#10.0.0.2		myname.my.domain myname
#10.0.0.3		myfriend.my.domain myfriend
#
# According to RFC 1918, you can use the following IP networks for
# private nets which will never be connected to the Internet:
#
#	10.0.0.0	-   10.255.255.255
#	172.16.0.0	-   172.31.255.255
#	192.168.0.0	-   192.168.255.255
#
# In case you want to be able to connect to the Internet, you need
# real official assigned numbers.  Do not try to invent your own network
# numbers but instead get one from your network provider (if any) or
# from your regional registry (ARIN, APNIC, LACNIC, RIPE NCC, or AfriNIC.)
#</pre></div></div><div class=paragraph><p><span class=filename>/etc/hosts</span> 的格式如下：</p></div><div class="literalblock programlisting"><div class=content><pre>[Internet address] [official hostname] [alias1] [alias2] ...</pre></div></div><div class=paragraph><p>例如：</p></div><div class="literalblock programlisting"><div class=content><pre>10.0.0.1 myRealHostname.example.com myRealHostname foobar1 foobar2</pre></div></div><div class=paragraph><p>請參考 <a href="https://man.freebsd.org/cgi/man.cgi?query=hosts&amp;sektion=5&amp;format=html">hosts(5)</a> 取得更多資訊。</p></div></div></div></div></div><div class=sect1><h2 id=configtuning-sysctl>11.9. 使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> 調校<a class=anchor href=#configtuning-sysctl></a></h2><div class=sectionbody><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> 可用來更改執行中的 FreeBSD 系統，這包含許多 TCP/IP 堆疊及虛擬記憶體系統的進階選項，讓有經驗的系統管理者能夠簡單的提升效能。有超過五百個系統變數可以使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> 來讀取與設定。</p></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> 主要提供兩個功能：讀取與修改系統設定。</p></div><div class=paragraph><p>檢視所有可讀取的變數：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% sysctl <span class=nt>-a</span></code></pre></div></div><div class=paragraph><p>要讀取特定變數只要指定其名稱：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% sysctl kern.maxproc
kern.maxproc: 1044</code></pre></div></div><div class=paragraph><p>要設定特定變數可使用 <em>variable</em>=<em>value</em> 語法：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl kern.maxfiles=5000</span>
kern.maxfiles: 2088 -&gt; 5000</code></pre></div></div><div class=paragraph><p>sysctl 的設定值通常為字串、數字或布林值，其中布林值的 <code>1</code> 代表是，<code>0</code> 代表否。</p></div><div class=paragraph><p>要在每次機器開機時自動設定一些變數可將其加入到 <span class=filename>/etc/sysctl.conf</span>。要取得更多的資訊請參考 <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl.conf&amp;sektion=5&amp;format=html">sysctl.conf(5)</a> 及 <a href=#configtuning-sysctlconf><span class=filename>sysctl.conf</span></a>。</p></div><div class=sect2><h3 id=configtuning-sysctlconf>11.9.1. <span class=filename>sysctl.conf</span><a class=anchor href=#configtuning-sysctlconf></a></h3><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> 的設定檔於 <span class=filename>/etc/sysctl.conf</span>，內容很像 <span class=filename>/etc/rc.conf</span>，設定數值使用 <code>variable=value</code> 格式。指定的數值會在系統進入多使用者模式時設定，但並非所有變數皆可在此模式設定。</p></div><div class=paragraph><p>例如，要關閉嚴重信號 (Fatal signal) 中止的記錄並避免使用者看到其他使用者所執行的程序，可加入以下設定到 <span class=filename>/etc/sysctl.conf</span>：</p></div><div class="literalblock programlisting"><div class=content><pre># Do not log fatal signal exits (e.g., sig 11)
kern.logsigexit=0

# Prevent users from seeing information about processes that
# are being run under another UID.
security.bsd.see_other_uids=0</pre></div></div></div><div class=sect2><h3 id=sysctl-readonly>11.9.2. 唯讀 <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a><a class=anchor href=#sysctl-readonly></a></h3><div class=paragraph><p>在有些情況可能會需要修改唯讀的 <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> 數值，而這會需要重新啟動系統。</p></div><div class=paragraph><p>例如，某些筆電型號的 <a href="https://man.freebsd.org/cgi/man.cgi?query=cardbus&amp;sektion=4&amp;format=html">cardbus(4)</a> 裝置無法偵測到記憶體範圍而且會失效並有類似以下的錯誤：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>cbb0: Could not map register memory
device_probe_and_attach: cbb0 attach returned 12</code></pre></div></div><div class=paragraph><p>這個修正需要修改唯讀的 <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> 設定。加入 <code>hw.pci.allow_unsupported_io_range=1</code> 到 <span class=filename>/boot/loader.conf</span> 然後重新啟動。現在 <a href="https://man.freebsd.org/cgi/man.cgi?query=cardbus&amp;sektion=4&amp;format=html">cardbus(4)</a> 應可正常運作。</p></div></div></div></div><div class=sect1><h2 id=configtuning-disk>11.10. 調校磁碟<a class=anchor href=#configtuning-disk></a></h2><div class=sectionbody><div class=paragraph><p>接下來的章節會討論在磁碟裝置上各種可調校的機制與選項。在大多數案例中，有使用機械元件的硬碟，如 SCSI 磁碟機，會成為導致整體系統效能低下的瓶頸。雖然已經有不使用機械元件的磁碟機解決方案，如，固態硬碟，但使用機械元件的磁碟機短期內並不會消失。在調校磁碟時，建議可以利用 <a href="https://man.freebsd.org/cgi/man.cgi?query=iostat&amp;sektion=8&amp;format=html">iostat(8)</a> 指令的功能來測試各種對系統的變更，這個指令可讓使用者取得系統 IO 相關的有用資訊。</p></div><div class=sect2><h3 id=_sysctl_變數>11.10.1. Sysctl 變數<a class=anchor href=#_sysctl_變數></a></h3><div class=sect3><h4 id=_vfs_vmiodirenable>11.10.1.1. <code>vfs.vmiodirenable</code><a class=anchor href=#_vfs_vmiodirenable></a></h4><div class=paragraph><p>The <code>vfs.vmiodirenable</code> <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> variable may be set to either <code>0</code> (off) or <code>1</code> (on). It is set to <code>1</code> by default. This variable controls how directories are cached by the system. Most directories are small, using just a single fragment (typically 1 K) in the file system and typically 512 bytes in the buffer cache. With this variable turned off, the buffer cache will only cache a fixed number of directories, even if the system has a huge amount of memory. When turned on, this <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> allows the buffer cache to use the VM page cache to cache the directories, making all the memory available for caching directories. However, the minimum in-core memory used to cache a directory is the physical page size (typically 4 K) rather than 512 bytes. Keeping this option enabled is recommended if the system is running any services which manipulate large numbers of files. Such services can include web caches, large mail systems, and news systems. Keeping this option on will generally not reduce performance, even with the wasted memory, but one should experiment to find out.</p></div></div><div class=sect3><h4 id=_vfs_write_behind>11.10.1.2. <code>vfs.write_behind</code><a class=anchor href=#_vfs_write_behind></a></h4><div class=paragraph><p>The <code>vfs.write_behind</code> <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> variable defaults to <code>1</code> (on). This tells the file system to issue media writes as full clusters are collected, which typically occurs when writing large sequential files. This avoids saturating the buffer cache with dirty buffers when it would not benefit I/O performance. However, this may stall processes and under certain circumstances should be turned off.</p></div></div><div class=sect3><h4 id=_vfs_hirunningspace>11.10.1.3. <code>vfs.hirunningspace</code><a class=anchor href=#_vfs_hirunningspace></a></h4><div class=paragraph><p>The <code>vfs.hirunningspace</code> <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> variable determines how much outstanding write I/O may be queued to disk controllers system-wide at any given instance. The default is usually sufficient, but on machines with many disks, try bumping it up to four or five <em>megabytes</em>. Setting too high a value which exceeds the buffer cache’s write threshold can lead to bad clustering performance. Do not set this value arbitrarily high as higher write values may add latency to reads occurring at the same time.</p></div><div class=paragraph><p>There are various other buffer cache and VM page cache related <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> values. Modifying these values is not recommended as the VM system does a good job of automatically tuning itself.</p></div></div><div class=sect3><h4 id=_vm_swap_idle_enabled>11.10.1.4. <code>vm.swap_idle_enabled</code><a class=anchor href=#_vm_swap_idle_enabled></a></h4><div class=paragraph><p>The <code>vm.swap_idle_enabled</code> <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> variable is useful in large multi-user systems with many active login users and lots of idle processes. Such systems tend to generate continuous pressure on free memory reserves. Turning this feature on and tweaking the swapout hysteresis (in idle seconds) via <code>vm.swap_idle_threshold1</code> and <code>vm.swap_idle_threshold2</code> depresses the priority of memory pages associated with idle processes more quickly then the normal pageout algorithm. This gives a helping hand to the pageout daemon. Only turn this option on if needed, because the tradeoff is essentially pre-page memory sooner rather than later which eats more swap and disk bandwidth. In a small system this option will have a determinable effect, but in a large system that is already doing moderate paging, this option allows the VM system to stage whole processes into and out of memory easily.</p></div></div><div class=sect3><h4 id=_hw_ata_wc>11.10.1.5. <code>hw.ata.wc</code><a class=anchor href=#_hw_ata_wc></a></h4><div class=paragraph><p>Turning off IDE write caching reduces write bandwidth to IDE disks, but may sometimes be necessary due to data consistency issues introduced by hard drive vendors. The problem is that some IDE drives lie about when a write completes. With IDE write caching turned on, IDE hard drives write data to disk out of order and will sometimes delay writing some blocks indefinitely when under heavy disk load. A crash or power failure may cause serious file system corruption. Check the default on the system by observing the <code>hw.ata.wc</code> <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> variable. If IDE write caching is turned off, one can set this read-only variable to <code>1</code> in <span class=filename>/boot/loader.conf</span> in order to enable it at boot time.</p></div><div class=paragraph><p>For more information, refer to <a href="https://man.freebsd.org/cgi/man.cgi?query=ata&amp;sektion=4&amp;format=html">ata(4)</a>.</p></div></div><div class=sect3><h4 id=_scsi_delay_kern_cam_scsi_delay>11.10.1.6. <code>SCSI_DELAY</code> (<code>kern.cam.scsi_delay</code>)<a class=anchor href=#_scsi_delay_kern_cam_scsi_delay></a></h4><div class=paragraph><p>The <code>SCSI_DELAY</code> kernel configuration option may be used to reduce system boot times. The defaults are fairly high and can be responsible for <code>15</code> seconds of delay in the boot process. Reducing it to <code>5</code> seconds usually works with modern drives. The <code>kern.cam.scsi_delay</code> boot time tunable should be used. The tunable and kernel configuration option accept values in terms of <em>milliseconds</em> and <em>not seconds</em>.</p></div></div></div><div class=sect2><h3 id=soft-updates>11.10.2. 軟更新<a class=anchor href=#soft-updates></a></h3><div class=paragraph><p>To fine-tune a file system, use <a href="https://man.freebsd.org/cgi/man.cgi?query=tunefs&amp;sektion=8&amp;format=html">tunefs(8)</a>. This program has many different options. To toggle Soft Updates on and off, use:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># tunefs -n enable /filesystem</span>
<span class=c># tunefs -n disable /filesystem</span></code></pre></div></div><div class=paragraph><p>A file system cannot be modified with <a href="https://man.freebsd.org/cgi/man.cgi?query=tunefs&amp;sektion=8&amp;format=html">tunefs(8)</a> while it is mounted. A good time to enable Soft Updates is before any partitions have been mounted, in single-user mode.</p></div><div class=paragraph><p>Soft Updates is recommended for UFS file systems as it drastically improves meta-data performance, mainly file creation and deletion, through the use of a memory cache. There are two downsides to Soft Updates to be aware of. First, Soft Updates guarantee file system consistency in the case of a crash, but could easily be several seconds or even a minute behind updating the physical disk. If the system crashes, unwritten data may be lost. Secondly, Soft Updates delay the freeing of file system blocks. If the root file system is almost full, performing a major update, such as <code>make installworld</code>, can cause the file system to run out of space and the update to fail.</p></div><div class=sect3><h4 id=_有關軟更新的更多詳細資訊>11.10.2.1. 有關軟更新的更多詳細資訊<a class=anchor href=#_有關軟更新的更多詳細資訊></a></h4><div class=paragraph><p>Meta-data updates are updates to non-content data like inodes or directories. There are two traditional approaches to writing a file system’s meta-data back to disk.</p></div><div class=paragraph><p>Historically, the default behavior was to write out meta-data updates synchronously. If a directory changed, the system waited until the change was actually written to disk. The file data buffers (file contents) were passed through the buffer cache and backed up to disk later on asynchronously. The advantage of this implementation is that it operates safely. If there is a failure during an update, meta-data is always in a consistent state. A file is either created completely or not at all. If the data blocks of a file did not find their way out of the buffer cache onto the disk by the time of the crash, <a href="https://man.freebsd.org/cgi/man.cgi?query=fsck&amp;sektion=8&amp;format=html">fsck(8)</a> recognizes this and repairs the file system by setting the file length to <code>0</code>. Additionally, the implementation is clear and simple. The disadvantage is that meta-data changes are slow. For example, <code>rm -r</code> touches all the files in a directory sequentially, but each directory change will be written synchronously to the disk. This includes updates to the directory itself, to the inode table, and possibly to indirect blocks allocated by the file. Similar considerations apply for unrolling large hierarchies using <code>tar -x</code>.</p></div><div class=paragraph><p>The second approach is to use asynchronous meta-data updates. This is the default for a UFS file system mounted with <code>mount -o async</code>. Since all meta-data updates are also passed through the buffer cache, they will be intermixed with the updates of the file content data. The advantage of this implementation is there is no need to wait until each meta-data update has been written to disk, so all operations which cause huge amounts of meta-data updates work much faster than in the synchronous case. This implementation is still clear and simple, so there is a low risk for bugs creeping into the code. The disadvantage is that there is no guarantee for a consistent state of the file system. If there is a failure during an operation that updated large amounts of meta-data, like a power failure or someone pressing the reset button, the file system will be left in an unpredictable state. There is no opportunity to examine the state of the file system when the system comes up again as the data blocks of a file could already have been written to the disk while the updates of the inode table or the associated directory were not. It is impossible to implement a <a href="https://man.freebsd.org/cgi/man.cgi?query=fsck&amp;sektion=8&amp;format=html">fsck(8)</a> which is able to clean up the resulting chaos because the necessary information is not available on the disk. If the file system has been damaged beyond repair, the only choice is to reformat it and restore from backup.</p></div><div class=paragraph><p>The usual solution for this problem is to implement <em>dirty region logging</em>, which is also referred to as <em>journaling</em>. Meta-data updates are still written synchronously, but only into a small region of the disk. Later on, they are moved to their proper location. Because the logging area is a small, contiguous region on the disk, there are no long distances for the disk heads to move, even during heavy operations, so these operations are quicker than synchronous updates. Additionally, the complexity of the implementation is limited, so the risk of bugs being present is low. A disadvantage is that all meta-data is written twice, once into the logging region and once to the proper location, so performance "pessimization" might result. On the other hand, in case of a crash, all pending meta-data operations can be either quickly rolled back or completed from the logging area after the system comes up again, resulting in a fast file system startup.</p></div><div class=paragraph><p>Kirk McKusick, the developer of Berkeley FFS, solved this problem with Soft Updates. All pending meta-data updates are kept in memory and written out to disk in a sorted sequence ("ordered meta-data updates"). This has the effect that, in case of heavy meta-data operations, later updates to an item "catch" the earlier ones which are still in memory and have not already been written to disk. All operations are generally performed in memory before the update is written to disk and the data blocks are sorted according to their position so that they will not be on the disk ahead of their meta-data. If the system crashes, an implicit "log rewind" causes all operations which were not written to the disk appear as if they never happened. A consistent file system state is maintained that appears to be the one of 30 to 60 seconds earlier. The algorithm used guarantees that all resources in use are marked as such in their blocks and inodes. After a crash, the only resource allocation error that occurs is that resources are marked as "used" which are actually "free". <a href="https://man.freebsd.org/cgi/man.cgi?query=fsck&amp;sektion=8&amp;format=html">fsck(8)</a> recognizes this situation, and frees the resources that are no longer used. It is safe to ignore the dirty state of the file system after a crash by forcibly mounting it with <code>mount -f</code>. In order to free resources that may be unused, <a href="https://man.freebsd.org/cgi/man.cgi?query=fsck&amp;sektion=8&amp;format=html">fsck(8)</a> needs to be run at a later time. This is the idea behind the <em>background <a href="https://man.freebsd.org/cgi/man.cgi?query=fsck&amp;sektion=8&amp;format=html">fsck(8)</a></em>: at system startup time, only a <em>snapshot</em> of the file system is recorded and <a href="https://man.freebsd.org/cgi/man.cgi?query=fsck&amp;sektion=8&amp;format=html">fsck(8)</a> is run afterwards. All file systems can then be mounted "dirty", so the system startup proceeds in multi-user mode. Then, background <a href="https://man.freebsd.org/cgi/man.cgi?query=fsck&amp;sektion=8&amp;format=html">fsck(8)</a> is scheduled for all file systems where this is required, to free resources that may be unused. File systems that do not use Soft Updates still need the usual foreground <a href="https://man.freebsd.org/cgi/man.cgi?query=fsck&amp;sektion=8&amp;format=html">fsck(8)</a>.</p></div><div class=paragraph><p>The advantage is that meta-data operations are nearly as fast as asynchronous updates and are faster than <em>logging</em>, which has to write the meta-data twice. The disadvantages are the complexity of the code, a higher memory consumption, and some idiosyncrasies. After a crash, the state of the file system appears to be somewhat "older". In situations where the standard synchronous approach would have caused some zero-length files to remain after the <a href="https://man.freebsd.org/cgi/man.cgi?query=fsck&amp;sektion=8&amp;format=html">fsck(8)</a>, these files do not exist at all with Soft Updates because neither the meta-data nor the file contents have been written to disk. Disk space is not released until the updates have been written to disk, which may take place some time after running <a href="https://man.freebsd.org/cgi/man.cgi?query=rm&amp;sektion=1&amp;format=html">rm(1)</a>. This may cause problems when installing large amounts of data on a file system that does not have enough free space to hold all the files twice.</p></div></div></div></div></div><div class=sect1><h2 id=configtuning-kernel-limits>11.11. 調校核心限制<a class=anchor href=#configtuning-kernel-limits></a></h2><div class=sectionbody><div class=sect2><h3 id=file-process-limits>11.11.1. 檔案/程序限制<a class=anchor href=#file-process-limits></a></h3><div class=sect3><h4 id=kern-maxfiles>11.11.1.1. <code>kern.maxfiles</code><a class=anchor href=#kern-maxfiles></a></h4><div class=paragraph><p>The <code>kern.maxfiles</code> <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> variable can be raised or lowered based upon system requirements. This variable indicates the maximum number of file descriptors on the system. When the file descriptor table is full, <code>file: table is full</code> will show up repeatedly in the system message buffer, which can be viewed using <a href="https://man.freebsd.org/cgi/man.cgi?query=dmesg&amp;sektion=8&amp;format=html">dmesg(8)</a>.</p></div><div class=paragraph><p>Each open file, socket, or fifo uses one file descriptor. A large-scale production server may easily require many thousands of file descriptors, depending on the kind and number of services running concurrently.</p></div><div class=paragraph><p>In older FreeBSD releases, the default value of <code>kern.maxfiles</code> is derived from <code>maxusers</code> in the kernel configuration file. <code>kern.maxfiles</code> grows proportionally to the value of <code>maxusers</code>. When compiling a custom kernel, consider setting this kernel configuration option according to the use of the system. From this number, the kernel is given most of its pre-defined limits. Even though a production machine may not have 256 concurrent users, the resources needed may be similar to a high-scale web server.</p></div><div class=paragraph><p>The read-only <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> variable <code>kern.maxusers</code> is automatically sized at boot based on the amount of memory available in the system, and may be determined at run-time by inspecting the value of <code>kern.maxusers</code>. Some systems require larger or smaller values of <code>kern.maxusers</code> and values of <code>64</code>, <code>128</code>, and <code>256</code> are not uncommon. Going above <code>256</code> is not recommended unless a huge number of file descriptors is needed. Many of the tunable values set to their defaults by <code>kern.maxusers</code> may be individually overridden at boot-time or run-time in <span class=filename>/boot/loader.conf</span>. Refer to <a href="https://man.freebsd.org/cgi/man.cgi?query=loader.conf&amp;sektion=5&amp;format=html">loader.conf(5)</a> and <span class=filename>/boot/defaults/loader.conf</span> for more details and some hints.</p></div><div class=paragraph><p>In older releases, the system will auto-tune <code>maxusers</code> if it is set to <code>0</code>. . When setting this option, set <code>maxusers</code> to at least <code>4</code>, especially if the system runs Xorg or is used to compile software. The most important table set by <code>maxusers</code> is the maximum number of processes, which is set to <code>20 + 16 * maxusers</code>. If <code>maxusers</code> is set to <code>1</code>, there can only be <code>36</code> simultaneous processes, including the <code>18</code> or so that the system starts up at boot time and the <code>15</code> or so used by Xorg. Even a simple task like reading a manual page will start up nine processes to filter, decompress, and view it. Setting <code>maxusers</code> to <code>64</code> allows up to <code>1044</code> simultaneous processes, which should be enough for nearly all uses. If, however, the error is displayed when trying to start another program, or a server is running with a large number of simultaneous users, increase the number and rebuild.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p><code>maxusers</code> does <em>not</em> limit the number of users which can log into the machine. It instead sets various table sizes to reasonable values considering the maximum number of users on the system and how many processes each user will be running.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=_kern_ipc_soacceptqueue>11.11.1.2. <code>kern.ipc.soacceptqueue</code><a class=anchor href=#_kern_ipc_soacceptqueue></a></h4><div class=paragraph><p>The <code>kern.ipc.soacceptqueue</code> <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> variable limits the size of the listen queue for accepting new <code>TCP</code> connections. The default value of <code>128</code> is typically too low for robust handling of new connections on a heavily loaded web server. For such environments, it is recommended to increase this value to <code>1024</code> or higher. A service such as <a href="https://man.freebsd.org/cgi/man.cgi?query=sendmail&amp;sektion=8&amp;format=html">sendmail(8)</a>, or Apache may itself limit the listen queue size, but will often have a directive in its configuration file to adjust the queue size. Large listen queues do a better job of avoiding Denial of Service (DoS) attacks.</p></div></div></div><div class=sect2><h3 id=nmbclusters>11.11.2. 網路限制<a class=anchor href=#nmbclusters></a></h3><div class=paragraph><p>The <code>NMBCLUSTERS</code> kernel configuration option dictates the amount of network Mbufs available to the system. A heavily-trafficked server with a low number of Mbufs will hinder performance. Each cluster represents approximately 2 K of memory, so a value of <code>1024</code> represents <code>2</code> megabytes of kernel memory reserved for network buffers. A simple calculation can be done to figure out how many are needed. A web server which maxes out at <code>1000</code> simultaneous connections where each connection uses a 6 K receive and 16 K send buffer, requires approximately 32 MB worth of network buffers to cover the web server. A good rule of thumb is to multiply by <code>2</code>, so 2x32 MB / 2 KB = 64 MB / 2 kB = <code>32768</code>. Values between <code>4096</code> and <code>32768</code> are recommended for machines with greater amounts of memory. Never specify an arbitrarily high value for this parameter as it could lead to a boot time crash. To observe network cluster usage, use <code>-m</code> with <a href="https://man.freebsd.org/cgi/man.cgi?query=netstat&amp;sektion=1&amp;format=html">netstat(1)</a>.</p></div><div class=paragraph><p>The <code>kern.ipc.nmbclusters</code> loader tunable should be used to tune this at boot time. Only older versions of FreeBSD will require the use of the <code>NMBCLUSTERS</code> kernel <a href="https://man.freebsd.org/cgi/man.cgi?query=config&amp;sektion=8&amp;format=html">config(8)</a> option.</p></div><div class=paragraph><p>For busy servers that make extensive use of the <a href="https://man.freebsd.org/cgi/man.cgi?query=sendfile&amp;sektion=2&amp;format=html">sendfile(2)</a> system call, it may be necessary to increase the number of <a href="https://man.freebsd.org/cgi/man.cgi?query=sendfile&amp;sektion=2&amp;format=html">sendfile(2)</a> buffers via the <code>NSFBUFS</code> kernel configuration option or by setting its value in <span class=filename>/boot/loader.conf</span> (see <a href="https://man.freebsd.org/cgi/man.cgi?query=loader&amp;sektion=8&amp;format=html">loader(8)</a> for details). A common indicator that this parameter needs to be adjusted is when processes are seen in the <code>sfbufa</code> state. The <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> variable <code>kern.ipc.nsfbufs</code> is read-only. This parameter nominally scales with <code>kern.maxusers</code>, however it may be necessary to tune accordingly.</p></div><div class="admonitionblock important"><table><tbody><tr><td class=icon><i class="fa icon-important" title=Important></i></td><td class=content><div class=paragraph><p>Even though a socket has been marked as non-blocking, calling <a href="https://man.freebsd.org/cgi/man.cgi?query=sendfile&amp;sektion=2&amp;format=html">sendfile(2)</a> on the non-blocking socket may result in the <a href="https://man.freebsd.org/cgi/man.cgi?query=sendfile&amp;sektion=2&amp;format=html">sendfile(2)</a> call blocking until enough <code>struct sf_buf</code>'s are made available.</p></div></td></tr></tbody></table></div><div class=sect3><h4 id=_net_inet_ip_portrange>11.11.2.1. <code>net.inet.ip.portrange.*</code><a class=anchor href=#_net_inet_ip_portrange></a></h4><div class=paragraph><p>The <code>net.inet.ip.portrange.*</code> <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> variables control the port number ranges automatically bound to <code>TCP</code> and <code>UDP</code> sockets. There are three ranges: a low range, a default range, and a high range. Most network programs use the default range which is controlled by <code>net.inet.ip.portrange.first</code> and <code>net.inet.ip.portrange.last</code>, which default to <code>1024</code> and <code>5000</code>, respectively. Bound port ranges are used for outgoing connections and it is possible to run the system out of ports under certain circumstances. This most commonly occurs when running a heavily loaded web proxy. The port range is not an issue when running a server which handles mainly incoming connections, such as a web server, or has a limited number of outgoing connections, such as a mail relay. For situations where there is a shortage of ports, it is recommended to increase <code>net.inet.ip.portrange.last</code> modestly. A value of <code>10000</code>, <code>20000</code> or <code>30000</code> may be reasonable. Consider firewall effects when changing the port range. Some firewalls may block large ranges of ports, usually low-numbered ports, and expect systems to use higher ranges of ports for outgoing connections. For this reason, it is not recommended that the value of <code>net.inet.ip.portrange.first</code> be lowered.</p></div></div><div class=sect3><h4 id=_tcp_頻寬延遲乘積>11.11.2.2. <code>TCP</code> 頻寬延遲乘積<a class=anchor href=#_tcp_頻寬延遲乘積></a></h4><div class=paragraph><p><code>TCP</code> bandwidth delay product limiting can be enabled by setting the <code>net.inet.tcp.inflight.enable</code> <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> variable to <code>1</code>. This instructs the system to attempt to calculate the bandwidth delay product for each connection and limit the amount of data queued to the network to just the amount required to maintain optimum throughput.</p></div><div class=paragraph><p>This feature is useful when serving data over modems, Gigabit Ethernet, high speed <code>WAN</code> links, or any other link with a high bandwidth delay product, especially when also using window scaling or when a large send window has been configured. When enabling this option, also set <code>net.inet.tcp.inflight.debug</code> to <code>0</code> to disable debugging. For production use, setting <code>net.inet.tcp.inflight.min</code> to at least <code>6144</code> may be beneficial. Setting high minimums may effectively disable bandwidth limiting, depending on the link. The limiting feature reduces the amount of data built up in intermediate route and switch packet queues and reduces the amount of data built up in the local host’s interface queue. With fewer queued packets, interactive connections, especially over slow modems, will operate with lower <em>Round Trip Times</em>. This feature only effects server side data transmission such as uploading. It has no effect on data reception or downloading.</p></div><div class=paragraph><p>Adjusting <code>net.inet.tcp.inflight.stab</code> is <em>not</em> recommended. This parameter defaults to <code>20</code>, representing 2 maximal packets added to the bandwidth delay product window calculation. The additional window is required to stabilize the algorithm and improve responsiveness to changing conditions, but it can also result in higher <a href="https://man.freebsd.org/cgi/man.cgi?query=ping&amp;sektion=8&amp;format=html">ping(8)</a> times over slow links, though still much lower than without the inflight algorithm. In such cases, try reducing this parameter to <code>15</code>, <code>10</code>, or <code>5</code> and reducing <code>net.inet.tcp.inflight.min</code> to a value such as <code>3500</code> to get the desired effect. Reducing these parameters should be done as a last resort only.</p></div></div></div><div class=sect2><h3 id=_虛擬記憶體>11.11.3. 虛擬記憶體<a class=anchor href=#_虛擬記憶體></a></h3><div class=sect3><h4 id=_kern_maxvnodes>11.11.3.1. <code>kern.maxvnodes</code><a class=anchor href=#_kern_maxvnodes></a></h4><div class=paragraph><p>A vnode is the internal representation of a file or directory. Increasing the number of vnodes available to the operating system reduces disk I/O. Normally, this is handled by the operating system and does not need to be changed. In some cases where disk I/O is a bottleneck and the system is running out of vnodes, this setting needs to be increased. The amount of inactive and free RAM will need to be taken into account.</p></div><div class=paragraph><p>To see the current number of vnodes in use:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl vfs.numvnodes</span>
vfs.numvnodes: 91349</code></pre></div></div><div class=paragraph><p>To see the maximum vnodes:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl kern.maxvnodes</span>
kern.maxvnodes: 100000</code></pre></div></div><div class=paragraph><p>If the current vnode usage is near the maximum, try increasing <code>kern.maxvnodes</code> by a value of <code>1000</code>. Keep an eye on the number of <code>vfs.numvnodes</code>. If it climbs up to the maximum again, <code>kern.maxvnodes</code> will need to be increased further. Otherwise, a shift in memory usage as reported by <a href="https://man.freebsd.org/cgi/man.cgi?query=top&amp;sektion=1&amp;format=html">top(1)</a> should be visible and more memory should be active.</p></div></div></div></div></div><div class=sect1><h2 id=adding-swap-space>11.12. 增加交換空間<a class=anchor href=#adding-swap-space></a></h2><div class=sectionbody><div class=paragraph><p>有時系統會需要更多的交換 (Swap) 空間，本章節會介紹兩種增加交換空間的方式：一種是在既有的分割區或新的硬碟增加交換空間，另一種則是在既有的分割區中建立一個交換檔。</p></div><div class=paragraph><p>要取得更多有關如何加密交換空間的資訊、有那些可用的選項以及為何要做加密，可參考 <a href=../disks/#swap-encrypting>交換空間加密</a>。</p></div><div class=sect2><h3 id=new-drive-swap>11.12.1. 使用新硬碟或既有分割區增加交換空間<a class=anchor href=#new-drive-swap></a></h3><div class=paragraph><p>在新的磁碟上增加交換空間比起使用既有硬碟上的分割區會有較佳的效率。設定分割區與硬碟在 <a href=../disks/#disks-adding>加入磁碟</a> 中有說明，另外 <a href=../bsdinstall/#configtuning-initial>規劃分割區配置</a> 會討論到分割區的配置與交換分割區大小需考量的事項。</p></div><div class=paragraph><p>使用 <code>swapon</code> 來增加交換分割區到系統，例：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># swapon /dev/ada1s1b</span></code></pre></div></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>可以使用任何尚未掛載過、甚至已經有內含資料的分割區做為交換空間，但在含有資料的分割區上使用 <code>swapon</code> 會覆寫並清除該分割區上所有的資料，請在執行 <code>swapon</code> 之前確認真的要使用該分割區增加交換空間。</p></div></td></tr></tbody></table></div><div class=paragraph><p>要在開機時自動加入此交換分割區，可加入以下項目到 <span class=filename>/etc/fstab</span>：</p></div><div class="literalblock programlisting"><div class=content><pre>/dev/ada1s1b	none	swap	sw	0	0</pre></div></div><div class=paragraph><p>請參考 <a href="https://man.freebsd.org/cgi/man.cgi?query=fstab&amp;sektion=5&amp;format=html">fstab(5)</a> 來取得在 <span class=filename>/etc/fstab</span> 中項目的說明。更多有關 <code>swapon</code> 的資訊 可以在 <a href="https://man.freebsd.org/cgi/man.cgi?query=swapon&amp;sektion=8&amp;format=html">swapon(8)</a> 找到。</p></div></div><div class=sect2><h3 id=create-swapfile>11.12.2. 建立交換檔<a class=anchor href=#create-swapfile></a></h3><div class=paragraph><p>以下例子會建立一個 64M 的交換檔於 <span class=filename>/usr/swap0</span> 來替代使用分割區建立交換空間。</p></div><div class=paragraph><p>使用交換檔開啟交換空間前需要在核心編譯或載入 <a href="https://man.freebsd.org/cgi/man.cgi?query=md&amp;sektion=4&amp;format=html">md(4)</a> 所需的模組，請參考 <a href=../kernelconfig/#kernelconfig>設定 FreeBSD 核心</a> 了解有關編譯自訂核心的資訊。</p></div><div id=swapfile-10-and-later class=exampleblock><div class=title>例 2. 建立交換檔於 FreeBSD 10.<em>X</em> 及以後版本</div><div class=content><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>建立交換檔：</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dd if=/dev/zero of=/usr/swap0 bs=1m count=64</span></code></pre></div></div></li><li><p>在新檔案設定適當的權限：</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># chmod 0600 /usr/swap0</span></code></pre></div></div></li><li><p>加入行到 <span class=filename>/etc/fstab</span> 以讓系統知道交換檔的資訊：</p><div class="literalblock programlisting"><div class=content><pre>md99	none	swap	sw,file=/usr/swap0,late	0	0</pre></div></div><div class=paragraph><p>已使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=md&amp;sektion=4&amp;format=html">md(4)</a> 裝置的 <span class=filename>md99</span>，保留較低的裝置編號供互動操作時使用。</p></div></li><li><p>交換空間會於系統啟動時增加。若要立即增加交換空間，請參考 <a href="https://man.freebsd.org/cgi/man.cgi?query=swapon&amp;sektion=8&amp;format=html">swapon(8)</a>：</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># swapon -aL</span></code></pre></div></div></li></ol></div></div></div></div></div><div id=swapfile-9-and-earlier class=exampleblock><div class=title>例 3. 建立交換檔於 FreeBSD 9.<em>X</em> 及先前版本</div><div class=content><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>建立交換檔 <span class=filename>/usr/swap0</span>：</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dd if=/dev/zero of=/usr/swap0 bs=1m count=64</span></code></pre></div></div></li><li><p>設定適當的權限於 <span class=filename>/usr/swap0</span>：</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># chmod 0600 /usr/swap0</span></code></pre></div></div></li><li><p>在 <span class=filename>/etc/rc.conf</span> 開啟交換檔：</p><div class="literalblock programlisting"><div class=content><pre>swapfile=&#34;/usr/swap0&#34;   # Set to name of swap file</pre></div></div></li><li><p>交換空間會於系統啟動時增加。若要立即增加交換空間，可指定一個未使用的記憶體裝置。請參考 <a href=../disks/#disks-virtual>記憶體磁碟</a> 取得更多有關記憶體裝置的資訊。</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mdconfig -a -t vnode -f /usr/swap0 -u 0 &amp;&amp; swapon /dev/md0</span></code></pre></div></div></li></ol></div></div></div></div></div></div></div></div><div class=sect1><h2 id=acpi-overview>11.13. 電源與資源管理<a class=anchor href=#acpi-overview></a></h2><div class=sectionbody><div class=paragraph><p>以有效率的方式運用硬體資源是很重要的，電源與資源管理讓作業系統可以監控系統的限制，並且在系統溫度意外升高時能夠發出警報。早期提供電源管理的規範是進階電源管理 (Advanced Power Management, APM)，APM 可根據系統的使用狀況來來控制電源用量。然而，使用 APM 要作業系統來管理系統的電源用量和溫度屬性是困難且沒有彈性的，因為硬體是由 BIOS 所管理，使用者對電源管理設定只有有限的設定性與可見性，且 APMBIOS 是由供應商提供且特定於某些硬體平台，而作業系統中必透過 APM 驅動程式做為中介存取 APM 軟體介面才能夠管理電源等級。</p></div><div class=paragraph><p>在 APM 有四個主要的問題。第一，電源管理是由供應商特定的 BIOS 來完成，與作業系統是分開的。例如，使用者可在 APMBIOS 設定硬碟的閒置時間值，在超過時間時 BIOS 可在未徵得作業系統的同意下降低硬碟的轉速。第二，APM 的邏輯是內嵌在 BIOS 當中的，並且在作業系統範圍之外運作，這代表使用者只能夠透過燒錄新的韌體到 ROM 來修正 APMBIOS 中的問題，而這樣的程序是危險的，若失敗，可能會讓系統進入無法復原的狀態。第三，APM 是供應商特定的技術，這代表有許多重複的工作，在一個供應商的 BIOS 找到的問題在其他的供應商卻沒有解決。最後一點，APMBIOS 並沒有足夠的空間來實作複雜的電源管理政策或可良好適應主機用途的程式。</p></div><div class=paragraph><p>Plug and Play BIOS (PNPBIOS) 在很多情況下並不可靠，PNPBIOS 是 16 位元的技術，所以作業系統必須模擬 16 位元才能存取 PNPBIOS。FreeBSD 提供了一個 APM 驅動程式來做 APM，應可用在 2000 年之前所製造的系統，該驅動程式的說明於 <a href="https://man.freebsd.org/cgi/man.cgi?query=apm&amp;sektion=4&amp;format=html">apm(4)</a>。</p></div><div class=paragraph><p>APM 的後繼者是進階設置與電源介面 (Advanced Configuration and Power Interface, ACPI)。ACPI 是一套由供應商聯盟所搛寫出的標準，提供了硬體資源與電源管理的介面，它是 <em>作業系統直接設置與電源管理 (Operating System-directed configuration and Power Management)</em> 關鍵的要素，提供了作業系統更多的控制方式與彈性。</p></div><div class=paragraph><p>本章節將示範如何在 FreeBSD 設定 ACPI，然後提供一些如何對 ACPI 除錯的提示以及如何提交包含除錯資訊的問題回報，讓開發人員能夠診斷並修正 ACPI 的問題。</p></div><div class=sect2><h3 id=acpi-config>11.13.1. 設定 ACPI<a class=anchor href=#acpi-config></a></h3><div class=paragraph><p>在 FreeBSD <a href="https://man.freebsd.org/cgi/man.cgi?query=acpi&amp;sektion=4&amp;format=html">acpi(4)</a> 驅動程式預設會在系統開始時載入，且<em>不</em>應被編譯到核心當中。這個驅動程式在開機之後無法被卸載，因為系統匯流排會使用它做各種硬體互動。雖然如此，若系統遇到問題，ACPI 還是可以被關閉，在 <span class=filename>/boot/loader.conf</span> 中設定 <code>hint.acpi.0.disabled="1"</code> 之後重新開機或在載入程式提示時設定這個變數，如 <a href=../boot/#boot-loader>階段三</a> 中的說明。</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>ACPI 與 APM 不能同時存在且應分開使用，若有偵測到有另一個正在執行，要載入的後者將會中斷。</p></div></td></tr></tbody></table></div><div class=paragraph><p>ACPI 可以用來讓系統進入睡眠模式，使用 <code>acpiconf</code> 與 <code>-s</code> 旗標再加上由 <code>1</code> 到 <code>5</code> 的數字。大多數使用者只需使用 <code>1</code> (快速待命到 RAM) 或 <code>3</code> (待命到 RAM)，選項 <code>5</code> 會執行軟關機 (Soft-off)，如同執行 <code>halt -p</code> 一樣。</p></div><div class=paragraph><p>其他的選項可使用 <code>sysctl</code> 來設定，請參考 <a href="https://man.freebsd.org/cgi/man.cgi?query=acpi&amp;sektion=4&amp;format=html">acpi(4)</a> 以及 <a href="https://man.freebsd.org/cgi/man.cgi?query=acpiconf&amp;sektion=8&amp;format=html">acpiconf(8)</a> 以取得更多資訊。</p></div></div><div class=sect2><h3 id=ACPI-comprob>11.13.2. 常見問題<a class=anchor href=#ACPI-comprob></a></h3><div class=paragraph><p>ACPI is present in all modern computers that conform to the ia32 (x86), ia64 (Itanium), and amd64 (AMD) architectures. The full standard has many features including CPU performance management, power planes control, thermal zones, various battery systems, embedded controllers, and bus enumeration. Most systems implement less than the full standard. For instance, a desktop system usually only implements bus enumeration while a laptop might have cooling and battery management support as well. Laptops also have suspend and resume, with their own associated complexity.</p></div><div class=paragraph><p>An ACPI-compliant system has various components. The BIOS and chipset vendors provide various fixed tables, such as FADT, in memory that specify things like the APIC map (used for SMP), config registers, and simple configuration values. Additionally, a bytecode table, the Differentiated System Description Table DSDT, specifies a tree-like name space of devices and methods.</p></div><div class=paragraph><p>The ACPI driver must parse the fixed tables, implement an interpreter for the bytecode, and modify device drivers and the kernel to accept information from the ACPI subsystem. For FreeBSD, Intel™ has provided an interpreter (ACPI-CA) that is shared with Linux™ and NetBSD. The path to the ACPI-CA source code is <span class=filename>src/sys/contrib/dev/acpica</span>. The glue code that allows ACPI-CA to work on FreeBSD is in <span class=filename>src/sys/dev/acpica/Osd</span>. Finally, drivers that implement various ACPI devices are found in <span class=filename>src/sys/dev/acpica</span>.</p></div><div class=paragraph><p>For ACPI to work correctly, all the parts have to work correctly. Here are some common problems, in order of frequency of appearance, and some possible workarounds or fixes. If a fix does not resolve the issue, refer to <a href=#ACPI-submitdebug>取得與回報除錯資訊</a> for instructions on how to submit a bug report.</p></div><div class=sect3><h4 id=_滑鼠問題>11.13.2.1. 滑鼠問題<a class=anchor href=#_滑鼠問題></a></h4><div class=paragraph><p>In some cases, resuming from a suspend operation will cause the mouse to fail. A known work around is to add <code>hint.psm.0.flags="0x3000"</code> to <span class=filename>/boot/loader.conf</span>.</p></div></div><div class=sect3><h4 id=_待機喚醒>11.13.2.2. 待機/喚醒<a class=anchor href=#_待機喚醒></a></h4><div class=paragraph><p>ACPI has three suspend to RAM (STR) states, <code>S1</code>-<code>S3</code>, and one suspend to disk state (STD), called <code>S4</code>. STD can be implemented in two separate ways. The <code>S4</code>BIOS is a BIOS-assisted suspend to disk and <code>S4</code>OS is implemented entirely by the operating system. The normal state the system is in when plugged in but not powered up is "soft off" (<code>S5</code>).</p></div><div class=paragraph><p>Use <code>sysctl hw.acpi</code> to check for the suspend-related items. These example results are from a Thinkpad:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>hw.acpi.supported_sleep_state: S3 S4 S5
hw.acpi.s4bios: 0</code></pre></div></div><div class=paragraph><p>Use <code>acpiconf -s</code> to test <code>S3</code>, <code>S4</code>, and <code>S5</code>. An <code>s4bios</code> of one (<code>1</code>) indicates <code>S4</code>BIOS support instead of <code>S4</code> operating system support.</p></div><div class=paragraph><p>When testing suspend/resume, start with <code>S1</code>, if supported. This state is most likely to work since it does not require much driver support. No one has implemented <code>S2</code>, which is similar to <code>S1</code>. Next, try <code>S3</code>. This is the deepest STR state and requires a lot of driver support to properly reinitialize the hardware.</p></div><div class=paragraph><p>A common problem with suspend/resume is that many device drivers do not save, restore, or reinitialize their firmware, registers, or device memory properly. As a first attempt at debugging the problem, try:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl debug.bootverbose=1</span>
<span class=c># sysctl debug.acpi.suspend_bounce=1</span>
<span class=c># acpiconf -s 3</span></code></pre></div></div><div class=paragraph><p>This test emulates the suspend/resume cycle of all device drivers without actually going into <code>S3</code> state. In some cases, problems such as losing firmware state, device watchdog time out, and retrying forever, can be captured with this method. Note that the system will not really enter <code>S3</code> state, which means devices may not lose power, and many will work fine even if suspend/resume methods are totally missing, unlike real <code>S3</code> state.</p></div><div class=paragraph><p>Harder cases require additional hardware, such as a serial port and cable for debugging through a serial console, a Firewire port and cable for using <a href="https://man.freebsd.org/cgi/man.cgi?query=dcons&amp;sektion=4&amp;format=html">dcons(4)</a>, and kernel debugging skills.</p></div><div class=paragraph><p>To help isolate the problem, unload as many drivers as possible. If it works, narrow down which driver is the problem by loading drivers until it fails again. Typically, binary drivers like <span class=filename>nvidia.ko</span>, display drivers, and USB will have the most problems while Ethernet interfaces usually work fine. If drivers can be properly loaded and unloaded, automate this by putting the appropriate commands in <span class=filename>/etc/rc.suspend</span> and <span class=filename>/etc/rc.resume</span>. Try setting <code>hw.acpi.reset_video</code> to <code>1</code> if the display is messed up after resume. Try setting longer or shorter values for <code>hw.acpi.sleep_delay</code> to see if that helps.</p></div><div class=paragraph><p>Try loading a recent Linux™ distribution to see if suspend/resume works on the same hardware. If it works on Linux™, it is likely a FreeBSD driver problem. Narrowing down which driver causes the problem will assist developers in fixing the problem. Since the ACPI maintainers rarely maintain other drivers, such as sound or ATA, any driver problems should also be posted to the <a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-current>freebsd-current</a> list and mailed to the driver maintainer. Advanced users can include debugging <a href="https://man.freebsd.org/cgi/man.cgi?query=printf&amp;sektion=3&amp;format=html">printf(3)</a>s in a problematic driver to track down where in its resume function it hangs.</p></div><div class=paragraph><p>Finally, try disabling ACPI and enabling APM instead. If suspend/resume works with APM, stick with APM, especially on older hardware (pre-2000). It took vendors a while to get ACPI support correct and older hardware is more likely to have BIOS problems with ACPI.</p></div></div><div class=sect3><h4 id=_系統無回應>11.13.2.3. 系統無回應<a class=anchor href=#_系統無回應></a></h4><div class=paragraph><p>Most system hangs are a result of lost interrupts or an interrupt storm. Chipsets may have problems based on boot, how the BIOS configures interrupts before correctness of the APIC (MADT) table, and routing of the System Control Interrupt (SCI).</p></div><div class=paragraph><p>Interrupt storms can be distinguished from lost interrupts by checking the output of <code>vmstat -i</code> and looking at the line that has <code>acpi0</code>. If the counter is increasing at more than a couple per second, there is an interrupt storm. If the system appears hung, try breaking to DDB (<span class=keyseq><kbd>CTRL</kbd>+<kbd>ALT</kbd>+<kbd>ESC</kbd></span> on console) and type <code>show interrupts</code>.</p></div><div class=paragraph><p>When dealing with interrupt problems, try disabling APIC support with <code>hint.apic.0.disabled="1"</code> in <span class=filename>/boot/loader.conf</span>.</p></div></div><div class=sect3><h4 id=_當機>11.13.2.4. 當機<a class=anchor href=#_當機></a></h4><div class=paragraph><p>Panics are relatively rare for ACPI and are the top priority to be fixed. The first step is to isolate the steps to reproduce the panic, if possible, and get a backtrace. Follow the advice for enabling <code>options DDB</code> and setting up a serial console in <a href=../serialcomms/#serialconsole-ddb>從序列線路 (Serial Line) 進入 DDB 除錯程式</a> or setting up a dump partition. To get a backtrace in DDB, use <code>tr</code>. When handwriting the backtrace, get at least the last five and the top five lines in the trace.</p></div><div class=paragraph><p>Then, try to isolate the problem by booting with ACPI disabled. If that works, isolate the ACPI subsystem by using various values of <code>debug.acpi.disable</code>. See <a href="https://man.freebsd.org/cgi/man.cgi?query=acpi&amp;sektion=4&amp;format=html">acpi(4)</a> for some examples.</p></div></div><div class=sect3><h4 id=_系統在待機或關機後仍開機>11.13.2.5. 系統在待機或關機後仍開機<a class=anchor href=#_系統在待機或關機後仍開機></a></h4><div class=paragraph><p>First, try setting <code>hw.acpi.disable_on_poweroff="0"</code> in <span class=filename>/boot/loader.conf</span>. This keeps ACPI from disabling various events during the shutdown process. Some systems need this value set to <code>1</code> (the default) for the same reason. This usually fixes the problem of a system powering up spontaneously after a suspend or poweroff.</p></div></div><div class=sect3><h4 id=ACPI-aslanddump>11.13.2.6. BIOS 含有有問題的 Bytecode<a class=anchor href=#ACPI-aslanddump></a></h4><div class=paragraph><p>Some BIOS vendors provide incorrect or buggy bytecode. This is usually manifested by kernel console messages like this:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>ACPI-1287: <span class=k>***</span> Error: Method execution failed <span class=o>[</span><span class=se>\\</span>_SB_.PCI0.LPC0.FIGD._STA] <span class=se>\\</span>
<span class=o>(</span>Node 0xc3f6d160<span class=o>)</span>, AE_NOT_FOUND</code></pre></div></div><div class=paragraph><p>Often, these problems may be resolved by updating the BIOS to the latest revision. Most console messages are harmless, but if there are other problems, like the battery status is not working, these messages are a good place to start looking for problems.</p></div></div></div><div class=sect2><h3 id=_覆蓋預設的_aml>11.13.3. 覆蓋預設的 AML<a class=anchor href=#_覆蓋預設的_aml></a></h3><div class=paragraph><p>The BIOS bytecode, known as ACPI Machine Language (AML), is compiled from a source language called ACPI Source Language (ASL). The AML is found in the table known as the Differentiated System Description Table (DSDT).</p></div><div class=paragraph><p>The goal of FreeBSD is for everyone to have working ACPI without any user intervention. Workarounds are still being developed for common mistakes made by BIOS vendors. The Microsoft™ interpreter (<span class=filename>acpi.sys</span> and <span class=filename>acpiec.sys</span>) does not strictly check for adherence to the standard, and thus many BIOS vendors who only test ACPI under Windows™ never fix their ASL. FreeBSD developers continue to identify and document which non-standard behavior is allowed by Microsoft™'s interpreter and replicate it so that FreeBSD can work without forcing users to fix the ASL.</p></div><div class=paragraph><p>To help identify buggy behavior and possibly fix it manually, a copy can be made of the system’s ASL. To copy the system’s ASL to a specified file name, use <code>acpidump</code> with <code>-t</code>, to show the contents of the fixed tables, and <code>-d</code>, to disassemble the AML:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># acpidump -td &gt; my.asl</span></code></pre></div></div><div class=paragraph><p>Some AML versions assume the user is running Windows™. To override this, set <code>hw.acpi.osname=<em>"Windows 2009"</em></code> in <span class=filename>/boot/loader.conf</span>, using the most recent Windows™ version listed in the ASL.</p></div><div class=paragraph><p>Other workarounds may require <span class=filename>my.asl</span> to be customized. If this file is edited, compile the new ASL using the following command. Warnings can usually be ignored, but errors are bugs that will usually prevent ACPI from working correctly.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># iasl -f my.asl</span></code></pre></div></div><div class=paragraph><p>Including <code>-f</code> forces creation of the AML, even if there are errors during compilation. Some errors, such as missing return statements, are automatically worked around by the FreeBSD interpreter.</p></div><div class=paragraph><p>The default output filename for <code>iasl</code> is <span class=filename>DSDT.aml</span>. Load this file instead of the BIOS’s buggy copy, which is still present in flash memory, by editing <span class=filename>/boot/loader.conf</span> as follows:</p></div><div class="literalblock programlisting"><div class=content><pre>acpi_dsdt_load=&#34;YES&#34;
acpi_dsdt_name=&#34;/boot/DSDT.aml&#34;</pre></div></div><div class=paragraph><p>Be sure to copy <span class=filename>DSDT.aml</span> to <span class=filename>/boot</span>, then reboot the system. If this fixes the problem, send a <a href="https://man.freebsd.org/cgi/man.cgi?query=diff&amp;sektion=1&amp;format=html">diff(1)</a> of the old and new ASL to <a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-acpi>freebsd-acpi</a> so that developers can work around the buggy behavior in <span class=filename>acpica</span>.</p></div></div><div class=sect2><h3 id=ACPI-submitdebug>11.13.4. 取得與回報除錯資訊<a class=anchor href=#ACPI-submitdebug></a></h3><div class=paragraph><p>The ACPI driver has a flexible debugging facility. A set of subsystems and the level of verbosity can be specified. The subsystems to debug are specified as layers and are broken down into components (<code>ACPI_ALL_COMPONENTS</code>) and ACPI hardware support (<code>ACPI_ALL_DRIVERS</code>). The verbosity of debugging output is specified as the level and ranges from just report errors (<code>ACPI_LV_ERROR</code>) to everything (<code>ACPI_LV_VERBOSE</code>). The level is a bitmask so multiple options can be set at once, separated by spaces. In practice, a serial console should be used to log the output so it is not lost as the console message buffer flushes. A full list of the individual layers and levels is found in <a href="https://man.freebsd.org/cgi/man.cgi?query=acpi&amp;sektion=4&amp;format=html">acpi(4)</a>.</p></div><div class=paragraph><p>Debugging output is not enabled by default. To enable it, add <code>options ACPI_DEBUG</code> to the custom kernel configuration file if ACPI is compiled into the kernel. Add <code>ACPI_DEBUG=1</code> to <span class=filename>/etc/make.conf</span> to enable it globally. If a module is used instead of a custom kernel, recompile just the <span class=filename>acpi.ko</span> module as follows:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /sys/modules/acpi/acpi &amp;&amp; make clean &amp;&amp; make ACPI_DEBUG=1</span></code></pre></div></div><div class=paragraph><p>Copy the compiled <span class=filename>acpi.ko</span> to <span class=filename>/boot/kernel</span> and add the desired level and layer to <span class=filename>/boot/loader.conf</span>. The entries in this example enable debug messages for all ACPI components and hardware drivers and output error messages at the least verbose level:</p></div><div class="literalblock programlisting"><div class=content><pre>debug.acpi.layer=&#34;ACPI_ALL_COMPONENTS ACPI_ALL_DRIVERS&#34;
debug.acpi.level=&#34;ACPI_LV_ERROR&#34;</pre></div></div><div class=paragraph><p>If the required information is triggered by a specific event, such as a suspend and then resume, do not modify <span class=filename>/boot/loader.conf</span>. Instead, use <code>sysctl</code> to specify the layer and level after booting and preparing the system for the specific event. The variables which can be set using <code>sysctl</code> are named the same as the tunables in <span class=filename>/boot/loader.conf</span>.</p></div><div class=paragraph><p>Once the debugging information is gathered, it can be sent to <a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-acpi>freebsd-acpi</a> so that it can be used by the FreeBSD ACPI maintainers to identify the root cause of the problem and to develop a solution.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Before submitting debugging information to this mailing list, ensure the latest BIOS version is installed and, if available, the embedded controller firmware version.</p></div></td></tr></tbody></table></div><div class=paragraph><p>When submitting a problem report, include the following information:</p></div><div class=ulist><ul><li><p>Description of the buggy behavior, including system type, model, and anything that causes the bug to appear. Note as accurately as possible when the bug began occurring if it is new.</p></li><li><p>The output of <code>dmesg</code> after running <code>boot -v</code>, including any error messages generated by the bug.</p></li><li><p>The <code>dmesg</code> output from <code>boot -v</code> with ACPI disabled, if disabling ACPI helps to fix the problem.</p></li><li><p>Output from <code>sysctl hw.acpi</code>. This lists which features the system offers.</p></li><li><p>The URL to a pasted version of the system’s ASL. Do <em>not</em> send the ASL directly to the list as it can be very large. Generate a copy of the ASL by running this command:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># acpidump -dt &gt; name-system.asl</span></code></pre></div></div><div class=paragraph><p>Substitute the login name for <em>name</em> and manufacturer/model for <em>system</em>. For example, use <span class=filename>njl-FooCo6000.asl</span>.</p></div></li></ul></div><div class=paragraph><p>Most FreeBSD developers watch the <a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-current>FreeBSD-CURRENT mailing list</a>, but one should submit problems to <a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-acpi>freebsd-acpi</a> to be sure it is seen. Be patient when waiting for a response. If the bug is not immediately apparent, submit a bug report. When entering a PR, include the same information as requested above. This helps developers to track the problem and resolve it. Do not send a PR without emailing <a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-acpi>freebsd-acpi</a> first as it is likely that the problem has been reported before.</p></div></div><div class=sect2><h3 id=ACPI-References>11.13.5. 參考文獻<a class=anchor href=#ACPI-References></a></h3><div class=paragraph><p>More information about ACPI may be found in the following locations:</p></div><div class=ulist><ul><li><p>The FreeBSD ACPI Mailing List Archives (<a href=https://lists.freebsd.org/pipermail/freebsd-acpi/>https://lists.freebsd.org/pipermail/freebsd-acpi/</a>)</p></li><li><p>The <a href=https://uefi.org/specifications#ACPI>ACPI Specification</a></p></li><li><p><a href="https://man.freebsd.org/cgi/man.cgi?query=acpi&amp;sektion=4&amp;format=html">acpi(4)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=acpi_thermal&amp;sektion=4&amp;format=html">acpi_thermal(4)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=acpidump&amp;sektion=8&amp;format=html">acpidump(8)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=iasl&amp;sektion=8&amp;format=html">iasl(8)</a>, and <a href="https://man.freebsd.org/cgi/man.cgi?query=acpidb&amp;sektion=8&amp;format=html">acpidb(8)</a></p></li></ul></div></div></div></div></div><hr><div class=last-modified><p><strong>最後修改於</strong>: March 9, 2024 由 <a href="https://cgit.freebsd.org/doc/commit/?id=6199af92e7" target=_blank>Danilo G. Baio</a></p></div><div class=buttons><div class=prev><i class="fa fa-angle-left" aria-hidden=true title=Prev></i><div class=container><a href=https://docs.freebsd.org/zh-tw/books/handbook/partiii class=direction>Prev</a></div></div><div class=home><i class="fa fa-home" aria-hidden=true title=Home></i><div class=container><a href=../ class=direction>Home</a></div></div><div class=next><div class=container><a href=https://docs.freebsd.org/zh-tw/books/handbook/boot class=direction>Next</a></div><i class="fa fa-angle-right" aria-hidden=true title=Next></i></div></div><label class="hidden book-menu-overlay" for=menu-control></label></div><aside class=toc><div class=toc-content><h3>目錄</h3><nav id=TableOfContents><ul><li><a href=#config-synopsis>11.1. 概述</a></li><li><a href=#configtuning-starting-services>11.2. 啟動服務</a></li><li><a href=#configtuning-cron>11.3. 設定 cron(8)</a></li><li><a href=#configtuning-rcd>11.4. 管理 FreeBSD 中的服務</a></li><li><a href=#config-network-setup>11.5. 設定網路介面卡</a></li><li><a href=#configtuning-virtual-hosts>11.6. 虛擬主機</a></li><li><a href=#configtuning-syslog>11.7. 設定系統日誌</a></li><li><a href=#configtuning-configfiles>11.8. 設定檔</a></li><li><a href=#configtuning-sysctl>11.9. 使用 sysctl(8) 調校</a></li><li><a href=#configtuning-disk>11.10. 調校磁碟</a></li><li><a href=#configtuning-kernel-limits>11.11. 調校核心限制</a></li><li><a href=#adding-swap-space>11.12. 增加交換空間</a></li><li><a href=#acpi-overview>11.13. 電源與資源管理</a></li></ul></nav><hr><div class=resources><h3>資源</h3><ul class=contents><li><i class="fa fa-file-pdf-o" aria-hidden=true title="下載 PDF"></i><a href=https://download.freebsd.org/doc/zh-tw/books/handbook/handbook_zh-tw.pdf>下載 PDF</a></li><li><i class="fa fa-pencil-square-o" aria-hidden=true title=編輯此頁></i><a href=https://github.com/freebsd/freebsd-doc/blob/main/documentation/content/zh-tw/_index target=_blank>編輯此頁</a></li></ul></div></div></aside><a class=to-top href=#top><i class="fa fa-arrow-circle-up" aria-hidden=true></i></a></main><footer><div class=footer-container><section class=logo-column><img src=https://docs.freebsd.org/images/FreeBSD-colors.svg width=160 height=50 alt="FreeBSD logo"><div class=options-container><div class=language-container><a id=languages href=https://docs.freebsd.org/zh-tw/languages><img src=https://docs.freebsd.org/images/language.png class=language-image alt=選擇語言>
<span>繁體中文</span></a></div><div class=theme-container><select id=theme-chooser><option value=theme-system>System</option><option value=theme-light>淺色</option><option value=theme-dark>深色</option><option value=theme-high-contrast>高對比</option></select></div></div></section><section class=about-column><h3 class=column-title>About</h3><ul class=column-elements-container><li><a href=https://www.freebsd.org/about/ target=_blank class=column-element>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/ target=_blank class=column-element>FreeBSD Foundation</a></li><li><a href=https://www.freebsd.org/where/ target=_blank class=column-element>Get FreeBSD</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct target=_blank class=column-element>Code of Conduct</a></li><li><a href=https://www.freebsd.org/security/ target=_blank class=column-element>Security Advisories</a></li></ul></section><section class=documentation-column><h3 class=column-title>Documentation</h3><ul class=column-elements-container><li><a href=/zh-tw class=column-element>Documentation portal</a></li><li><a href=https://man.FreeBSD.org target=_blank class=column-element>Manual pages</a></li><li><a href=https://papers.FreeBSD.org target=_blank class=column-element>Presentations and papers</a></li><li><a href=https://docs-archive.freebsd.org/doc/ target=_blank class=column-element>Previous versions</a></li><li><a href=https://docs-archive.freebsd.org/44doc/ target=_blank class=column-element>4.4BSD Documents</a></li><li><a href=https://wiki.freebsd.org/ target=_blank class=column-element>Wiki</a></li></ul></section><section class=community-column><h3 class=column-title>Community</h3><ul class=column-elements-container><li><a href=https://docs.freebsd.org/zh-tw/articles/contributing class=column-element>Get involved</a></li><li><a href=https://forums.freebsd.org/ target=_blank class=column-element>Community forum</a></li><li><a href=https://lists.freebsd.org/ target=_blank class=column-element>Mailing lists</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank class=column-element>IRC Channels</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank class=column-element>Bug Tracker</a></li></ul></section><section class=legal-column><h3 class=column-title>Legal</h3><ul class=column-elements-container><li><a href=https://freebsdfoundation.org/donate/ target=_blank class=column-element>Donations</a></li><li><a href=https://www.freebsd.org/copyright/freebsd-license/ target=_blank class=column-element>Licensing</a></li><li><a href=https://www.freebsd.org/privacy/ target=_blank class=column-element>Privacy Policy</a></li><li><a href=https://www.freebsd.org/copyright/ target=_blank class=column-element>Legal notices</a></li></ul></section><section class=copyright-column><p>&copy; 1994-2024 The FreeBSD Project. All rights reserved</p><span>Made with <span class=heart>♥</span> by the FreeBSD Community</span></section></div></footer></body></html>