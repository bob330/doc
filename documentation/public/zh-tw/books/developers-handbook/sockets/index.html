<!doctype html><html class=theme-light lang=zh-tw><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content><meta name=keywords content><meta name=copyright content="1995-2024 The FreeBSD Foundation"><link rel=canonical href=https://docs.freebsd.org/zh-tw/books/developers-handbook/sockets/><title>章 7. Sockets | FreeBSD Documentation Portal</title>
<meta name=theme-color content="#790000"><meta name=color-scheme content="system light dark high-contrast"><link rel="shortcut icon" href=https://docs.freebsd.org/favicon.ico><link rel=stylesheet href=https://docs.freebsd.org/styles/main.min.css><link rel=stylesheet href=https://docs.freebsd.org/css/font-awesome-min.css><script defer src=/js/theme-chooser.min.js></script><script defer src=/js/copy-clipboard.min.js></script><script defer src=/js/search.min.js></script><meta name=twitter:card content="summary"><meta name=twitter:domain content="docs.FreeBSD.org"><meta name=twitter:site content="@freebsd"><meta name=twitter:url content="https://twitter.com/freebsd"><meta property="og:title" content="章 7. Sockets"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:image" content="https://docs.freebsd.org/favicon.ico"><meta property="og:image:alt" content="FreeBSD Logo"><meta property="og:locale" content="zh-tw"><meta property="og:url" content="https://docs.freebsd.org/zh-tw/books/developers-handbook/sockets/"><meta property="og:site_name" content="FreeBSD Documentation Portal"><script type=application/ld+json>{"@context":"http://schema.org","@type":"Article","url":"https:\/\/docs.freebsd.org\/zh-tw\/books\/developers-handbook\/sockets\/","name":"FreeBSD Documentation Portal","headline":"FreeBSD Documentation Portal","description":"FreeBSD Documentation Portal"}</script></head><body><header><div class=header-container><div class=logo-menu-bars-container><a href=https://www.FreeBSD.org class=logo><img src=https://docs.freebsd.org/images/FreeBSD-monochromatic.svg width=160 height=50 alt="FreeBSD logo">
</a><label class=menu-bars for=menu-bars><i class="fa fa-bars" aria-hidden=true></i></label></div><input id=menu-bars type=checkbox><nav><ul class=menu><li class=menu-item><input id=about type=checkbox>
<a href=# aria-label="Navigate to About section"><label class=menu-item-description for=about>About
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/about/ target=_blank>About</a></li><li><a href=https://www.freebsd.org/about/ target=_blank>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/about-us/about-the-foundation/ target=_blank>FreeBSD Foundation</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct/ target=_blank>Code of Conduct</a></li></ul></li><li class=menu-item><input id=download type=checkbox>
<a href=# aria-label="Navigate to get FreeBSD section"><label class=menu-item-description for=download>Get FreeBSD
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/where/ target=_blank>Get FreeBSD</a></li><li><a href=https://www.freebsd.org/releases/ target=_blank>Release Information</a></li><li><a href=https://www.freebsd.org/releng/ target=_blank>Release Engineering</a></li><li><a href=https://www.freebsd.org/security/ target=_blank>Security Advisories</a></li></ul></li><li class=menu-item><input id=documentation type=checkbox>
<a href=# aria-label="Navigate to get Documentation section"><label class=menu-item-description for=documentation>Documentation
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=/zh-tw>Documentation portal</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook>FreeBSD Handbook</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/porters-handbook>Porter's Handbook</a></li><li><a href=https://docs.FreeBSD.org/en/books/fdp-primer>Documentation Project Handbook</a></li><li><a href=https://man.FreeBSD.org target=_blank>Manual pages</a></li><li><a href=https://papers.FreeBSD.org target=_blank>Presentations and papers</a></li><li><a href=https://wiki.FreeBSD.org target=_blank>Wiki</a></li><li><a href=https://docs.freebsd.org/zh-tw/books>Books</a></li><li><a href=https://docs.freebsd.org/zh-tw/articles>Articles</a></li></ul></li><li class=menu-item><input id=community type=checkbox>
<a href=# aria-label="Navigate to get Community section"><label class=menu-item-description for=community>Community
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/community/>Community</a></li><li><a href=https://docs.freebsd.org/zh-tw/articles/contributing>Get involved</a></li><li><a href=https://forums.freebsd.org/ target=_blank>Forum</a></li><li><a href=https://lists.freebsd.org/ target=_blank>Mailing lists</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank>IRC Channels</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank>Bug Tracker</a></li><li><a href=https://www.freebsd.org/support/ target=_blank>Support</a></li></ul></li></ul></nav><div class=search-donate-container><form class=search method=get id=search-header-form action=https://docs.freebsd.org/search name=search-header-form><input type=hidden name=DB value=zh-tw>
<input id=words name=P type=text size=20 maxlength=255>
<button>
<i class="fa fa-search" aria-hidden=true></i></button></form><div class=donate><a href=https://freebsdfoundation.org/donate/ target=_blank><span class=heart>♥</span>
Donate</a></div></div></div></header><input type=checkbox class="hidden toggle" id=menu-control><main class=main-wrapper-book><a id=top></a><aside class=book-menu><div class=book-menu-content><input id=search-book type=text placeholder=Search aria-label=Search maxlength=128><nav id=MenuContents><ul><li><input type=checkbox id=chapter-b1b18a35567534d1699b4dd27b58b2ff class=toggle>
<label for=chapter-b1b18a35567534d1699b4dd27b58b2ff><a role=button></a></label><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/parti/>Part I. Grundlagen</a></li><li><input type=checkbox id=chapter-3af9d0cd3607fbe44d37e3a13957c40f class=toggle>
<label class="icon cursor" for=chapter-3af9d0cd3607fbe44d37e3a13957c40f><a role=button></a></label><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/introduction/>章 1. 簡介</a><ul><li><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/introduction/#introduction-devel>1.1. 在 FreeBSD 開發程式</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/introduction/#introduction-bsdvision>1.2. The BSD Vision</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/introduction/#introduction-archguide>1.3. 程式架構指南</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/introduction/#introduction-layout>1.4. <span class=filename>/usr/src</span> 的架構</a></li></ul></li><li><input type=checkbox id=chapter-15219234c513f9a79d9cb2d3bcf73d13 class=toggle>
<label class="icon cursor" for=chapter-15219234c513f9a79d9cb2d3bcf73d13><a role=button></a></label><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/tools/>章 2. 程式開發工具</a><ul><li><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/tools/#tools-synopsis>2.1. 概敘</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/tools/#tools-intro>2.2. 簡介</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/tools/#tools-programming>2.3. Programming 概念</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/tools/#tools-compiling>2.4. 用 <code>cc</code> 來編譯程式</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/tools/#tools-make>2.5. Make</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/tools/#debugging>2.6. Debugging</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/tools/#emacs>2.7. Using Emacs as a Development Environment</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/tools/#tools-reading>2.8. Further Reading</a></li></ul></li><li><input type=checkbox id=chapter-7319f5d899d5be33daaf1f2d5f180558 class=toggle>
<label class="icon cursor" for=chapter-7319f5d899d5be33daaf1f2d5f180558><a role=button></a></label><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/secure/>章 3. Secure Programming</a><ul><li><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/secure/#secure-synopsis>3.1. Synopsis</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/secure/#secure-philosophy>3.2. Secure Design Methodology</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/secure/#secure-bufferov>3.3. Buffer Overflows</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/secure/#secure-setuid>3.4. SetUID issues</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/secure/#secure-chroot>3.5. Limiting your program’s environment</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/secure/#secure-trust>3.6. Trust</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/secure/#secure-race-conditions>3.7. Race Conditions</a></li></ul></li><li><input type=checkbox id=chapter-0240ccaf7010beed911378cfab7bd8fc class=toggle>
<label class="icon cursor" for=chapter-0240ccaf7010beed911378cfab7bd8fc><a role=button></a></label><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/l10n/>章 4. Localization and Internationalization - L10N and I18N</a><ul><li><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/l10n/#l10n-programming>4.1. Programming I18N Compliant Applications</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/l10n/#posix-nls>4.2. Localized Messages with POSIX.1 Native Language Support (NLS)</a></li></ul></li><li><input type=checkbox id=chapter-c3107aaf64e60e1ee09bc33fc9fd641a class=toggle>
<label class="icon cursor" for=chapter-c3107aaf64e60e1ee09bc33fc9fd641a><a role=button></a></label><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/policies/>章 5. Source Tree Guidelines and Policies</a><ul><li><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/policies/#policies-style>5.1. Style Guidelines</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/policies/#policies-maintainer>5.2. <code>MAINTAINER</code> on Makefiles</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/policies/#policies-contributed>5.3. Contributed Software</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/policies/#policies-encumbered>5.4. Encumbered Files</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/policies/#policies-shlib>5.5. Shared Libraries</a></li></ul></li><li><input type=checkbox id=chapter-c7b4fd5a7f8f049234fe3bc225acef44 class=toggle>
<label class="icon cursor" for=chapter-c7b4fd5a7f8f049234fe3bc225acef44><a role=button></a></label><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/testing/>章 6. Regression and Performance Testing</a><ul><li><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/testing/#testing-micro-benchmark>6.1. Micro Benchmark Checklist</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/testing/#testing-tinderbox>6.2. The FreeBSD Source Tinderbox</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/testing/#_the_index_cgi_script>6.3. The <span class=filename>index.cgi</span> Script</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/testing/#_official_build_servers>6.4. Official Build Servers</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/testing/#_official_summary_site>6.5. Official Summary Site</a></li></ul></li><li><input type=checkbox id=chapter-1f9b02a65f2bc5d4015a050d706fa837 class=toggle>
<label for=chapter-1f9b02a65f2bc5d4015a050d706fa837><a role=button></a></label><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/partii/>Part II. Interprozess-Kommunikation</a></li><li><input type=checkbox id=chapter-5e03777f678dd5731a581d7956d19c13 class=toggle checked>
<label class="icon cursor" for=chapter-5e03777f678dd5731a581d7956d19c13><a role=button></a></label><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/sockets/>章 7. Sockets</a><ul><li><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/sockets/#sockets-synopsis>7.1. Synopsis</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/sockets/#sockets-diversity>7.2. Networking and Diversity</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/sockets/#sockets-protocols>7.3. Protocols</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/sockets/#sockets-model>7.4. The Sockets Model</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/sockets/#sockets-essential-functions>7.5. Essential Socket Functions</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/sockets/#sockets-helper-functions>7.6. Helper Functions</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/sockets/#sockets-concurrent-servers>7.7. Concurrent Servers</a></li></ul></li><li><input type=checkbox id=chapter-5cbeeaa29a95a5f152e5ccc3901d0fd3 class=toggle>
<label class="icon cursor" for=chapter-5cbeeaa29a95a5f152e5ccc3901d0fd3><a role=button></a></label><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/ipv6/>章 8. IPv6 Internals</a><ul><li><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/ipv6/#ipv6-implementation>8.1. IPv6/IPsec Implementation</a></li></ul></li><li><input type=checkbox id=chapter-c9a07b517dc2e43d169c8e013e23cfc1 class=toggle>
<label for=chapter-c9a07b517dc2e43d169c8e013e23cfc1><a role=button></a></label><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/partiii/>Part III. Kernel</a></li><li><input type=checkbox id=chapter-db22f8e5e5e9496dbc711815e2e05f36 class=toggle>
<label class="icon cursor" for=chapter-db22f8e5e5e9496dbc711815e2e05f36><a role=button></a></label><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/kernelbuild/>章 9. Building and Installing a FreeBSD Kernel</a><ul><li><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/kernelbuild/#kernelbuild-traditional>9.1. Building the Faster but Brittle Way</a></li></ul></li><li><input type=checkbox id=chapter-3036877c53948cfb76174f2776bbdf64 class=toggle>
<label class="icon cursor" for=chapter-3036877c53948cfb76174f2776bbdf64><a role=button></a></label><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/kerneldebug/>章 10. Kernel Debugging</a><ul><li><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/kerneldebug/#kerneldebug-obtain>10.1. Obtaining a Kernel Crash Dump</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/kerneldebug/#kerneldebug-gdb>10.2. Debugging a Kernel Crash Dump with <code>kgdb</code></a></li><li><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/kerneldebug/#kerneldebug-online-ddb>10.3. On-Line Kernel Debugging Using DDB</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/kerneldebug/#kerneldebug-online-gdb>10.4. On-Line Kernel Debugging Using Remote GDB</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/kerneldebug/#kerneldebug-console>10.5. Debugging a Console Driver</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/kerneldebug/#kerneldebug-deadlocks>10.6. Debugging Deadlocks</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/kerneldebug/#kerneldebug-dcons>10.7. Kernel debugging with Dcons</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/kerneldebug/#kerneldebug-options>10.8. Glossary of Kernel Options for Debugging</a></li></ul></li><li><input type=checkbox id=chapter-86707094ce48d6e89e5f45569c084cea class=toggle>
<label for=chapter-86707094ce48d6e89e5f45569c084cea><a role=button></a></label><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/partiv/>Part IV. Architekturen</a></li><li><input type=checkbox id=chapter-43b1e1e6d2a94eb8b161876bc22ce644 class=toggle>
<label class="icon cursor" for=chapter-43b1e1e6d2a94eb8b161876bc22ce644><a role=button></a></label><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/x86/>章 11. x86 Assembly Language Programming</a><ul><li><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/x86/#x86-intro>11.1. Synopsis</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/x86/#x86-the-tools>11.2. The Tools</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/x86/#x86-system-calls>11.3. System Calls</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/x86/#x86-return-values>11.4. Return Values</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/x86/#x86-portable-code>11.5. Creating Portable Code</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/x86/#x86-first-program>11.6. Our First Program</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/x86/#x86-unix-filters>11.7. Writing UNIX® Filters</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/x86/#x86-buffered-io>11.8. Buffered Input and Output</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/x86/#x86-command-line>11.9. Command Line Arguments</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/x86/#x86-environment>11.10. UNIX® Environment</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/x86/#x86-files>11.11. Working with Files</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/x86/#x86-one-pointed-mind>11.12. One-Pointed Mind</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/x86/#x86-fpu>11.13. Using the FPU</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/x86/#x86-caveats>11.14. Caveats</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/x86/#x86-acknowledgements>11.15. Acknowledgements</a></li></ul></li><li><input type=checkbox id=chapter-c49dfe630861d471fb2f58f5b554ed84 class=toggle>
<label for=chapter-c49dfe630861d471fb2f58f5b554ed84><a role=button></a></label><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/partv/>Part V. Appendices</a></li><li><input type=checkbox id=chapter-ac9541a3f38001d13964c1b0b324bb83 class=toggle>
<label for=chapter-ac9541a3f38001d13964c1b0b324bb83><a role=button></a></label><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/bibliography/>附錄</a></li><li></li></ul></nav></div></aside><div class=book><div class=book-menu-mobile><label for=menu-control><span class=menu-control-button><i class="fa fa-list" aria-hidden=true title="Book menu"></i>
Book menu</span></label></div><h1 class=title>章 7. Sockets</h1><div class="admonitionblock note"><p><i class="fa fa-exclamation-circle" aria-hidden=true></i>
This translation may be out of date. To help with the translations please access the <a href=https://translate-dev.freebsd.org/ target=_blank>FreeBSD translations instance</a>.</p></div><div class=toc-mobile><h3>目錄</h3><nav id=TableOfContents><ul><li><a href=#sockets-synopsis>7.1. Synopsis</a></li><li><a href=#sockets-diversity>7.2. Networking and Diversity</a></li><li><a href=#sockets-protocols>7.3. Protocols</a></li><li><a href=#sockets-model>7.4. The Sockets Model</a></li><li><a href=#sockets-essential-functions>7.5. Essential Socket Functions</a></li><li><a href=#sockets-helper-functions>7.6. Helper Functions</a></li><li><a href=#sockets-concurrent-servers>7.7. Concurrent Servers</a></li></ul></nav></div><div class=book-content><div id=preamble><div class=sectionbody></div></div><div class=sect1><h2 id=sockets-synopsis>7.1. Synopsis<a class=anchor href=#sockets-synopsis></a></h2><div class=sectionbody><div class=paragraph><p>BSD sockets take interprocess communications to a new level. It is no longer necessary for the communicating processes to run on the same machine. They still <em>can</em>, but they do not have to.</p></div><div class=paragraph><p>Not only do these processes not have to run on the same machine, they do not have to run under the same operating system. Thanks to BSD sockets, your FreeBSD software can smoothly cooperate with a program running on a Macintosh®, another one running on a Sun™ workstation, yet another one running under Windows® 2000, all connected with an Ethernet-based local area network.</p></div><div class=paragraph><p>But your software can equally well cooperate with processes running in another building, or on another continent, inside a submarine, or a space shuttle.</p></div><div class=paragraph><p>It can also cooperate with processes that are not part of a computer (at least not in the strict sense of the word), but of such devices as printers, digital cameras, medical equipment. Just about anything capable of digital communications.</p></div></div></div><div class=sect1><h2 id=sockets-diversity>7.2. Networking and Diversity<a class=anchor href=#sockets-diversity></a></h2><div class=sectionbody><div class=paragraph><p>We have already hinted on the <em>diversity</em> of networking. Many different systems have to talk to each other. And they have to speak the same language. They also have to <em>understand</em> the same language the same way.</p></div><div class=paragraph><p>People often think that <em>body language</em> is universal. But it is not. Back in my early teens, my father took me to Bulgaria. We were sitting at a table in a park in Sofia, when a vendor approached us trying to sell us some roasted almonds.</p></div><div class=paragraph><p>I had not learned much Bulgarian by then, so, instead of saying no, I shook my head from side to side, the "universal" body language for <em>no</em>. The vendor quickly started serving us some almonds.</p></div><div class=paragraph><p>I then remembered I had been told that in Bulgaria shaking your head sideways meant <em>yes</em>. Quickly, I started nodding my head up and down. The vendor noticed, took his almonds, and walked away. To an uninformed observer, I did not change the body language: I continued using the language of shaking and nodding my head. What changed was the <em>meaning</em> of the body language. At first, the vendor and I interpreted the same language as having completely different meaning. I had to adjust my own interpretation of that language so the vendor would understand.</p></div><div class=paragraph><p>It is the same with computers: The same symbols may have different, even outright opposite meaning. Therefore, for two computers to understand each other, they must not only agree on the same <em>language</em>, but on the same <em>interpretation</em> of the language.</p></div></div></div><div class=sect1><h2 id=sockets-protocols>7.3. Protocols<a class=anchor href=#sockets-protocols></a></h2><div class=sectionbody><div class=paragraph><p>While various programming languages tend to have complex syntax and use a number of multi-letter reserved words (which makes them easy for the human programmer to understand), the languages of data communications tend to be very terse. Instead of multi-byte words, they often use individual <em>bits</em>. There is a very convincing reason for it: While data travels <em>inside</em> your computer at speeds approaching the speed of light, it often travels considerably slower between two computers.</p></div><div class=paragraph><p>Because the languages used in data communications are so terse, we usually refer to them as <em>protocols</em> rather than languages.</p></div><div class=paragraph><p>As data travels from one computer to another, it always uses more than one protocol. These protocols are <em>layered</em>. The data can be compared to the inside of an onion: You have to peel off several layers of "skin" to get to the data. This is best illustrated with a picture:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/developers-handbook/layers.png alt="Protocol Layers"></div></div><div class=paragraph><p>In this example, we are trying to get an image from a web page we are connected to via an Ethernet.</p></div><div class=paragraph><p>The image consists of raw data, which is simply a sequence of RGB values that our software can process, i.e., convert into an image and display on our monitor.</p></div><div class=paragraph><p>Alas, our software has no way of knowing how the raw data is organized: Is it a sequence of RGB values, or a sequence of grayscale intensities, or perhaps of CMYK encoded colors? Is the data represented by 8-bit quanta, or are they 16 bits in size, or perhaps 4 bits? How many rows and columns does the image consist of? Should certain pixels be transparent?</p></div><div class=paragraph><p>I think you get the picture…​</p></div><div class=paragraph><p>To inform our software how to handle the raw data, it is encoded as a PNG file. It could be a GIF, or a JPEG, but it is a PNG.</p></div><div class=paragraph><p>And PNG is a protocol.</p></div><div class=paragraph><p>At this point, I can hear some of you yelling, <em>"No, it is not! It is a file format!"</em></p></div><div class=paragraph><p>Well, of course it is a file format. But from the perspective of data communications, a file format is a protocol: The file structure is a <em>language</em>, a terse one at that, communicating to our <em>process</em> how the data is organized. Ergo, it is a <em>protocol</em>.</p></div><div class=paragraph><p>Alas, if all we received was the PNG file, our software would be facing a serious problem: How is it supposed to know the data is representing an image, as opposed to some text, or perhaps a sound, or what not? Secondly, how is it supposed to know the image is in the PNG format as opposed to GIF, or JPEG, or some other image format?</p></div><div class=paragraph><p>To obtain that information, we are using another protocol: HTTP. This protocol can tell us exactly that the data represents an image, and that it uses the PNG protocol. It can also tell us some other things, but let us stay focused on protocol layers here.</p></div><div class=paragraph><p>So, now we have some data wrapped in the PNG protocol, wrapped in the HTTP protocol. How did we get it from the server?</p></div><div class=paragraph><p>By using TCP/IP over Ethernet, that is how. Indeed, that is three more protocols. Instead of continuing inside out, I am now going to talk about Ethernet, simply because it is easier to explain the rest that way.</p></div><div class=paragraph><p>Ethernet is an interesting system of connecting computers in a <em>local area network</em> (LAN). Each computer has a <em>network interface card</em> (NIC), which has a unique 48-bit ID called its <em>address</em>. No two Ethernet NICs in the world have the same address.</p></div><div class=paragraph><p>These NICs are all connected with each other. Whenever one computer wants to communicate with another in the same Ethernet LAN, it sends a message over the network. Every NIC sees the message. But as part of the Ethernet <em>protocol</em>, the data contains the address of the destination NIC (among other things). So, only one of all the network interface cards will pay attention to it, the rest will ignore it.</p></div><div class=paragraph><p>But not all computers are connected to the same network. Just because we have received the data over our Ethernet does not mean it originated in our own local area network. It could have come to us from some other network (which may not even be Ethernet based) connected with our own network via the Internet.</p></div><div class=paragraph><p>All data is transferred over the Internet using IP, which stands for <em>Internet Protocol</em>. Its basic role is to let us know where in the world the data has arrived from, and where it is supposed to go to. It does not <em>guarantee</em> we will receive the data, only that we will know where it came from <em>if</em> we do receive it.</p></div><div class=paragraph><p>Even if we do receive the data, IP does not guarantee we will receive various chunks of data in the same order the other computer has sent it to us. So, we can receive the center of our image before we receive the upper left corner and after the lower right, for example.</p></div><div class=paragraph><p>It is TCP (<em>Transmission Control Protocol</em>) that asks the sender to resend any lost data and that places it all into the proper order.</p></div><div class=paragraph><p>All in all, it took <em>five</em> different protocols for one computer to communicate to another what an image looks like. We received the data wrapped into the PNG protocol, which was wrapped into the HTTP protocol, which was wrapped into the TCP protocol, which was wrapped into the IP protocol, which was wrapped into the Ethernet protocol.</p></div><div class=paragraph><p>Oh, and by the way, there probably were several other protocols involved somewhere on the way. For example, if our LAN was connected to the Internet through a dial-up call, it used the PPP protocol over the modem which used one (or several) of the various modem protocols, et cetera, et cetera, et cetera…​</p></div><div class=paragraph><p>As a developer you should be asking by now, <em>"How am I supposed to handle it all?"</em></p></div><div class=paragraph><p>Luckily for you, you are <em>not</em> supposed to handle it all. You <em>are</em> supposed to handle some of it, but not all of it. Specifically, you need not worry about the physical connection (in our case Ethernet and possibly PPP, etc). Nor do you need to handle the Internet Protocol, or the Transmission Control Protocol.</p></div><div class=paragraph><p>In other words, you do not have to do anything to receive the data from the other computer. Well, you do have to <em>ask</em> for it, but that is almost as simple as opening a file.</p></div><div class=paragraph><p>Once you have received the data, it is up to you to figure out what to do with it. In our case, you would need to understand the HTTP protocol and the PNG file structure.</p></div><div class=paragraph><p>To use an analogy, all the internetworking protocols become a gray area: Not so much because we do not understand how it works, but because we are no longer concerned about it. The sockets interface takes care of this gray area for us:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/developers-handbook/slayers.png alt="Sockets Covered Protocol Layers"></div></div><div class=paragraph><p>We only need to understand any protocols that tell us how to <em>interpret the data</em>, not how to <em>receive</em> it from another process, nor how to <em>send</em> it to another process.</p></div></div></div><div class=sect1><h2 id=sockets-model>7.4. The Sockets Model<a class=anchor href=#sockets-model></a></h2><div class=sectionbody><div class=paragraph><p>BSD sockets are built on the basic UNIX® model: <em>Everything is a file.</em> In our example, then, sockets would let us receive an <em>HTTP file</em>, so to speak. It would then be up to us to extract the <em>PNG file</em> from it.</p></div><div class=paragraph><p>Because of the complexity of internetworking, we cannot just use the <code>open</code> system call, or the <code>open()</code> C function. Instead, we need to take several steps to "opening" a socket.</p></div><div class=paragraph><p>Once we do, however, we can start treating the <em>socket</em> the same way we treat any <em>file descriptor</em>: We can <code>read</code> from it, <code>write</code> to it, <code>pipe</code> it, and, eventually, <code>close</code> it.</p></div></div></div><div class=sect1><h2 id=sockets-essential-functions>7.5. Essential Socket Functions<a class=anchor href=#sockets-essential-functions></a></h2><div class=sectionbody><div class=paragraph><p>While FreeBSD offers different functions to work with sockets, we only <em>need</em> four to "open" a socket. And in some cases we only need two.</p></div><div class=sect2><h3 id=sockets-client-server>7.5.1. The Client-Server Difference<a class=anchor href=#sockets-client-server></a></h3><div class=paragraph><p>Typically, one of the ends of a socket-based data communication is a <em>server</em>, the other is a <em>client</em>.</p></div><div class=sect3><h4 id=sockets-common-elements>7.5.1.1. The Common Elements<a class=anchor href=#sockets-common-elements></a></h4><div class=sect4><h5 id=sockets-socket>7.5.1.1.1. <code>socket</code><a class=anchor href=#sockets-socket></a></h5><div class=paragraph><p>The one function used by both, clients and servers, is <a href="https://man.freebsd.org/cgi/man.cgi?query=socket&amp;sektion=2&amp;format=html">socket(2)</a>. It is declared this way:</p></div><div class="literalblock programlisting"><div class=content><pre>int socket(int domain, int type, int protocol);</pre></div></div><div class=paragraph><p>The return value is of the same type as that of <code>open</code>, an integer. FreeBSD allocates its value from the same pool as that of file handles. That is what allows sockets to be treated the same way as files.</p></div><div class=paragraph><p>The <code>domain</code> argument tells the system what <em>protocol family</em> you want it to use. Many of them exist, some are vendor specific, others are very common. They are declared in <span class=filename>sys/socket.h</span>.</p></div><div class=paragraph><p>Use <code>PF_INET</code> for UDP, TCP and other Internet protocols (IPv4).</p></div><div class=paragraph><p>Five values are defined for the <code>type</code> argument, again, in <span class=filename>sys/socket.h</span>. All of them start with “SOCK_”. The most common one is <code>SOCK_STREAM</code>, which tells the system you are asking for a <em>reliable stream delivery service</em> (which is TCP when used with <code>PF_INET</code>).</p></div><div class=paragraph><p>If you asked for <code>SOCK_DGRAM</code>, you would be requesting a <em>connectionless datagram delivery service</em> (in our case, UDP).</p></div><div class=paragraph><p>If you wanted to be in charge of the low-level protocols (such as IP), or even network interfaces (e.g., the Ethernet), you would need to specify <code>SOCK_RAW</code>.</p></div><div class=paragraph><p>Finally, the <code>protocol</code> argument depends on the previous two arguments, and is not always meaningful. In that case, use <code>0</code> for its value.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=title>The Unconnected Socket</div><div class=paragraph><p>Nowhere, in the <code>socket</code> function have we specified to what other system we should be connected. Our newly created socket remains <em>unconnected</em>.</p></div><div class=paragraph><p>This is on purpose: To use a telephone analogy, we have just attached a modem to the phone line. We have neither told the modem to make a call, nor to answer if the phone rings.</p></div></td></tr></tbody></table></div></div><div class=sect4><h5 id=sockets-sockaddr>7.5.1.1.2. <code>sockaddr</code><a class=anchor href=#sockets-sockaddr></a></h5><div class=paragraph><p>Various functions of the sockets family expect the address of (or pointer to, to use C terminology) a small area of the memory. The various C declarations in the <span class=filename>sys/socket.h</span> refer to it as <code>struct sockaddr</code>. This structure is declared in the same file:</p></div><div class="literalblock programlisting"><div class=content><pre>/*
 * Structure used by kernel to store most
 * addresses.
 */
struct sockaddr {
	unsigned char	sa_len;		/* total length */
	sa_family_t	sa_family;	/* address family */
	char		sa_data[14];	/* actually longer; address value */
};
#define	SOCK_MAXADDRLEN	255		/* longest possible addresses */</pre></div></div><div class=paragraph><p>Please note the <em>vagueness</em> with which the <code>sa_data</code> field is declared, just as an array of <code>14</code> bytes, with the comment hinting there can be more than <code>14</code> of them.</p></div><div class=paragraph><p>This vagueness is quite deliberate. Sockets is a very powerful interface. While most people perhaps think of it as nothing more than the Internet interface-and most applications probably use it for that nowadays-sockets can be used for just about <em>any</em> kind of interprocess communications, of which the Internet (or, more precisely, IP) is only one.</p></div><div class=paragraph><p>The <span class=filename>sys/socket.h</span> refers to the various types of protocols sockets will handle as <em>address families</em>, and lists them right before the definition of <code>sockaddr</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>/*
 * Address families.
 */
#define	AF_UNSPEC	0		/* unspecified */
#define	AF_LOCAL	1		/* local to host (pipes, portals) */
#define	AF_UNIX		AF_LOCAL	/* backward compatibility */
#define	AF_INET		2		/* internetwork: UDP, TCP, etc. */
#define	AF_IMPLINK	3		/* arpanet imp addresses */
#define	AF_PUP		4		/* pup protocols: e.g. BSP */
#define	AF_CHAOS	5		/* mit CHAOS protocols */
#define	AF_NS		6		/* XEROX NS protocols */
#define	AF_ISO		7		/* ISO protocols */
#define	AF_OSI		AF_ISO
#define	AF_ECMA		8		/* European computer manufacturers */
#define	AF_DATAKIT	9		/* datakit protocols */
#define	AF_CCITT	10		/* CCITT protocols, X.25 etc */
#define	AF_SNA		11		/* IBM SNA */
#define AF_DECnet	12		/* DECnet */
#define AF_DLI		13		/* DEC Direct data link interface */
#define AF_LAT		14		/* LAT */
#define	AF_HYLINK	15		/* NSC Hyperchannel */
#define	AF_APPLETALK	16		/* Apple Talk */
#define	AF_ROUTE	17		/* Internal Routing Protocol */
#define	AF_LINK		18		/* Link layer interface */
#define	pseudo_AF_XTP	19		/* eXpress Transfer Protocol (no AF) */
#define	AF_COIP		20		/* connection-oriented IP, aka ST II */
#define	AF_CNT		21		/* Computer Network Technology */
#define pseudo_AF_RTIP	22		/* Help Identify RTIP packets */
#define	AF_IPX		23		/* Novell Internet Protocol */
#define	AF_SIP		24		/* Simple Internet Protocol */
#define	pseudo_AF_PIP	25		/* Help Identify PIP packets */
#define	AF_ISDN		26		/* Integrated Services Digital Network*/
#define	AF_E164		AF_ISDN		/* CCITT E.164 recommendation */
#define	pseudo_AF_KEY	27		/* Internal key-management function */
#define	AF_INET6	28		/* IPv6 */
#define	AF_NATM		29		/* native ATM access */
#define	AF_ATM		30		/* ATM */
#define pseudo_AF_HDRCMPLT 31		/* Used by BPF to not rewrite headers
					 * in interface output routine
					 */
#define	AF_NETGRAPH	32		/* Netgraph sockets */
#define	AF_SLOW		33		/* 802.3ad slow protocol */
#define	AF_SCLUSTER	34		/* Sitara cluster protocol */
#define	AF_ARP		35
#define	AF_BLUETOOTH	36		/* Bluetooth sockets */
#define	AF_MAX		37</pre></div></div><div class=paragraph><p>The one used for IP is AF_INET. It is a symbol for the constant <code>2</code>.</p></div><div class=paragraph><p>It is the <em>address family</em> listed in the <code>sa_family</code> field of <code>sockaddr</code> that decides how exactly the vaguely named bytes of <code>sa_data</code> will be used.</p></div><div class=paragraph><p>Specifically, whenever the <em>address family</em> is AF_INET, we can use <code>struct sockaddr_in</code> found in <span class=filename>netinet/in.h</span>, wherever <code>sockaddr</code> is expected:</p></div><div class="literalblock programlisting"><div class=content><pre>/*
 * Socket address, internet style.
 */
struct sockaddr_in {
	uint8_t		sin_len;
	sa_family_t	sin_family;
	in_port_t	sin_port;
	struct	in_addr sin_addr;
	char	sin_zero[8];
};</pre></div></div><div class=paragraph><p>We can visualize its organization this way:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/developers-handbook/sain.png alt=sockaddr_in></div></div><div class=paragraph><p>The three important fields are <code>sin_family</code>, which is byte 1 of the structure, <code>sin_port</code>, a 16-bit value found in bytes 2 and 3, and <code>sin_addr</code>, a 32-bit integer representation of the IP address, stored in bytes 4-7.</p></div><div class=paragraph><p>Now, let us try to fill it out. Let us assume we are trying to write a client for the <em>daytime</em> protocol, which simply states that its server will write a text string representing the current date and time to port 13. We want to use TCP/IP, so we need to specify <code>AF_INET</code> in the address family field. <code>AF_INET</code> is defined as <code>2</code>. Let us use the IP address of <code>192.43.244.18</code>, which is the time server of US federal government (<code>time.nist.gov</code>).</p></div><div class=imageblock><div class=content><img src=../../../../images/books/developers-handbook/sainfill.png alt="Specific example of sockaddr_in"></div></div><div class=paragraph><p>By the way the <code>sin_addr</code> field is declared as being of the <code>struct in_addr</code> type, which is defined in <span class=filename>netinet/in.h</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>/*
 * Internet address (a structure for historical reasons)
 */
struct in_addr {
	in_addr_t s_addr;
};</pre></div></div><div class=paragraph><p>In addition, <code>in_addr_t</code> is a 32-bit integer.</p></div><div class=paragraph><p>The <code>192.43.244.18</code> is just a convenient notation of expressing a 32-bit integer by listing all of its 8-bit bytes, starting with the <em>most significant</em> one.</p></div><div class=paragraph><p>So far, we have viewed <code>sockaddr</code> as an abstraction. Our computer does not store <code>short</code> integers as a single 16-bit entity, but as a sequence of 2 bytes. Similarly, it stores 32-bit integers as a sequence of 4 bytes.</p></div><div class=paragraph><p>Suppose we coded something like this:</p></div><div class="literalblock programlisting"><div class=content><pre>sa.sin_family      = AF_INET;
sa.sin_port        = 13;
sa.sin_addr.s_addr = (((((192 &lt;&lt; 8) | 43) &lt;&lt; 8) | 244) &lt;&lt; 8) | 18;</pre></div></div><div class=paragraph><p>What would the result look like?</p></div><div class=paragraph><p>Well, that depends, of course. On a Pentium®, or other x86, based computer, it would look like this:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/developers-handbook/sainlsb.png alt="sockaddr_in on an Intel system"></div></div><div class=paragraph><p>On a different system, it might look like this:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/developers-handbook/sainmsb.png alt="sockaddr_in on an MSB system"></div></div><div class=paragraph><p>And on a PDP it might look different yet. But the above two are the most common ways in use today.</p></div><div class=paragraph><p>Ordinarily, wanting to write portable code, programmers pretend that these differences do not exist. And they get away with it (except when they code in assembly language). Alas, you cannot get away with it that easily when coding for sockets.</p></div><div class=paragraph><p>Why?</p></div><div class=paragraph><p>Because when communicating with another computer, you usually do not know whether it stores data <em>most significant byte</em> (MSB) or <em>least significant byte</em> (LSB) first.</p></div><div class=paragraph><p>You might be wondering, <em>"So, will sockets not handle it for me?"</em></p></div><div class=paragraph><p>It will not.</p></div><div class=paragraph><p>While that answer may surprise you at first, remember that the general sockets interface only understands the <code>sa_len</code> and <code>sa_family</code> fields of the <code>sockaddr</code> structure. You do not have to worry about the byte order there (of course, on FreeBSD <code>sa_family</code> is only 1 byte anyway, but many other UNIX® systems do not have <code>sa_len</code> and use 2 bytes for <code>sa_family</code>, and expect the data in whatever order is native to the computer).</p></div><div class=paragraph><p>But the rest of the data is just <code>sa_data[14]</code> as far as sockets goes. Depending on the <em>address family</em>, sockets just forwards that data to its destination.</p></div><div class=paragraph><p>Indeed, when we enter a port number, it is because we want the other computer to know what service we are asking for. And, when we are the server, we read the port number so we know what service the other computer is expecting from us. Either way, sockets only has to forward the port number as data. It does not interpret it in any way.</p></div><div class=paragraph><p>Similarly, we enter the IP address to tell everyone on the way where to send our data to. Sockets, again, only forwards it as data.</p></div><div class=paragraph><p>That is why, we (the <em>programmers</em>, not the <em>sockets</em>) have to distinguish between the byte order used by our computer and a conventional byte order to send the data in to the other computer.</p></div><div class=paragraph><p>We will call the byte order our computer uses the <em>host byte order</em>, or just the <em>host order</em>.</p></div><div class=paragraph><p>There is a convention of sending the multi-byte data over IP <em>MSB first</em>. This, we will refer to as the <em>network byte order</em>, or simply the <em>network order</em>.</p></div><div class=paragraph><p>Now, if we compiled the above code for an Intel based computer, our <em>host byte order</em> would produce:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/developers-handbook/sainlsb.png alt="Host byte order on an Intel system"></div></div><div class=paragraph><p>But the <em>network byte order</em> requires that we store the data MSB first:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/developers-handbook/sainmsb.png alt="Network byte order"></div></div><div class=paragraph><p>Unfortunately, our <em>host order</em> is the exact opposite of the <em>network order</em>.</p></div><div class=paragraph><p>We have several ways of dealing with it. One would be to <em>reverse</em> the values in our code:</p></div><div class="literalblock programlisting"><div class=content><pre>sa.sin_family      = AF_INET;
sa.sin_port        = 13 &lt;&lt; 8;
sa.sin_addr.s_addr = (((((18 &lt;&lt; 8) | 244) &lt;&lt; 8) | 43) &lt;&lt; 8) | 192;</pre></div></div><div class=paragraph><p>This will <em>trick</em> our compiler into storing the data in the <em>network byte order</em>. In some cases, this is exactly the way to do it (e.g., when programming in assembly language). In most cases, however, it can cause a problem.</p></div><div class=paragraph><p>Suppose, you wrote a sockets-based program in C. You know it is going to run on a Pentium®, so you enter all your constants in reverse and force them to the <em>network byte order</em>. It works well.</p></div><div class=paragraph><p>Then, some day, your trusted old Pentium® becomes a rusty old Pentium®. You replace it with a system whose <em>host order</em> is the same as the <em>network order</em>. You need to recompile all your software. All of your software continues to perform well, except the one program you wrote.</p></div><div class=paragraph><p>You have since forgotten that you had forced all of your constants to the opposite of the <em>host order</em>. You spend some quality time tearing out your hair, calling the names of all gods you ever heard of (and some you made up), hitting your monitor with a nerf bat, and performing all the other traditional ceremonies of trying to figure out why something that has worked so well is suddenly not working at all.</p></div><div class=paragraph><p>Eventually, you figure it out, say a couple of swear words, and start rewriting your code.</p></div><div class=paragraph><p>Luckily, you are not the first one to face the problem. Someone else has created the <a href="https://man.freebsd.org/cgi/man.cgi?query=htons&amp;sektion=3&amp;format=html">htons(3)</a> and <a href="https://man.freebsd.org/cgi/man.cgi?query=htonl&amp;sektion=3&amp;format=html">htonl(3)</a> C functions to convert a <code>short</code> and <code>long</code> respectively from the <em>host byte order</em> to the <em>network byte order</em>, and the <a href="https://man.freebsd.org/cgi/man.cgi?query=ntohs&amp;sektion=3&amp;format=html">ntohs(3)</a> and <a href="https://man.freebsd.org/cgi/man.cgi?query=ntohl&amp;sektion=3&amp;format=html">ntohl(3)</a> C functions to go the other way.</p></div><div class=paragraph><p>On <em>MSB-first</em> systems these functions do nothing. On <em>LSB-first</em> systems they convert values to the proper order.</p></div><div class=paragraph><p>So, regardless of what system your software is compiled on, your data will end up in the correct order if you use these functions.</p></div></div></div><div class=sect3><h4 id=sockets-client-functions>7.5.1.2. Client Functions<a class=anchor href=#sockets-client-functions></a></h4><div class=paragraph><p>Typically, the client initiates the connection to the server. The client knows which server it is about to call: It knows its IP address, and it knows the <em>port</em> the server resides at. It is akin to you picking up the phone and dialing the number (the <em>address</em>), then, after someone answers, asking for the person in charge of wingdings (the <em>port</em>).</p></div><div class=sect4><h5 id=sockets-connect>7.5.1.2.1. <code>connect</code><a class=anchor href=#sockets-connect></a></h5><div class=paragraph><p>Once a client has created a socket, it needs to connect it to a specific port on a remote system. It uses <a href="https://man.freebsd.org/cgi/man.cgi?query=connect&amp;sektion=2&amp;format=html">connect(2)</a>:</p></div><div class="literalblock programlisting"><div class=content><pre>int connect(int s, const struct sockaddr *name, socklen_t namelen);</pre></div></div><div class=paragraph><p>The <code>s</code> argument is the socket, i.e., the value returned by the <code>socket</code> function. The <code>name</code> is a pointer to <code>sockaddr</code>, the structure we have talked about extensively. Finally, <code>namelen</code> informs the system how many bytes are in our <code>sockaddr</code> structure.</p></div><div class=paragraph><p>If <code>connect</code> is successful, it returns <code>0</code>. Otherwise it returns <code>-1</code> and stores the error code in <code>errno</code>.</p></div><div class=paragraph><p>There are many reasons why <code>connect</code> may fail. For example, with an attempt to an Internet connection, the IP address may not exist, or it may be down, or just too busy, or it may not have a server listening at the specified port. Or it may outright <em>refuse</em> any request for specific code.</p></div></div><div class=sect4><h5 id=sockets-first-client>7.5.1.2.2. Our First Client<a class=anchor href=#sockets-first-client></a></h5><div class=paragraph><p>We now know enough to write a very simple client, one that will get current time from <code>192.43.244.18</code> and print it to <span class=filename>stdout</span>.</p></div><div class="literalblock programlisting"><div class=content><pre>/*
 * daytime.c
 *
 * Programmed by G. Adam Stanislav
 */
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;

int main() {
  register int s;
  register int bytes;
  struct sockaddr_in sa;
  char buffer[BUFSIZ+1];

  if ((s = socket(PF_INET, SOCK_STREAM, 0)) &lt; 0) {
    perror(&#34;socket&#34;);
    return 1;
  }

  bzero(&amp;sa, sizeof sa);

  sa.sin_family = AF_INET;
  sa.sin_port = htons(13);
  sa.sin_addr.s_addr = htonl((((((192 &lt;&lt; 8) | 43) &lt;&lt; 8) | 244) &lt;&lt; 8) | 18);
  if (connect(s, (struct sockaddr *)&amp;sa, sizeof sa) &lt; 0) {
    perror(&#34;connect&#34;);
    close(s);
    return 2;
  }

  while ((bytes = read(s, buffer, BUFSIZ)) &gt; 0)
    write(1, buffer, bytes);

  close(s);
  return 0;
}</pre></div></div><div class=paragraph><p>Go ahead, enter it in your editor, save it as <span class=filename>daytime.c</span>, then compile and run it:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% cc <span class=nt>-O3</span> <span class=nt>-o</span> daytime daytime.c
% ./daytime

52079 01-06-19 02:29:25 50 0 1 543.9 UTC<span class=o>(</span>NIST<span class=o>)</span> <span class=k>*</span>
%</code></pre></div></div><div class=paragraph><p>In this case, the date was June 19, 2001, the time was 02:29:25 UTC. Naturally, your results will vary.</p></div></div></div><div class=sect3><h4 id=sockets-server-functions>7.5.1.3. Server Functions<a class=anchor href=#sockets-server-functions></a></h4><div class=paragraph><p>The typical server does not initiate the connection. Instead, it waits for a client to call it and request services. It does not know when the client will call, nor how many clients will call. It may be just sitting there, waiting patiently, one moment, The next moment, it can find itself swamped with requests from a number of clients, all calling in at the same time.</p></div><div class=paragraph><p>The sockets interface offers three basic functions to handle this.</p></div><div class=sect4><h5 id=sockets-bind>7.5.1.3.1. <code>bind</code><a class=anchor href=#sockets-bind></a></h5><div class=paragraph><p>Ports are like extensions to a phone line: After you dial a number, you dial the extension to get to a specific person or department.</p></div><div class=paragraph><p>There are 65535 IP ports, but a server usually processes requests that come in on only one of them. It is like telling the phone room operator that we are now at work and available to answer the phone at a specific extension. We use <a href="https://man.freebsd.org/cgi/man.cgi?query=bind&amp;sektion=2&amp;format=html">bind(2)</a> to tell sockets which port we want to serve.</p></div><div class="literalblock programlisting"><div class=content><pre>int bind(int s, const struct sockaddr *addr, socklen_t addrlen);</pre></div></div><div class=paragraph><p>Beside specifying the port in <code>addr</code>, the server may include its IP address. However, it can just use the symbolic constant INADDR_ANY to indicate it will serve all requests to the specified port regardless of what its IP address is. This symbol, along with several similar ones, is declared in <span class=filename>netinet/in.h</span></p></div><div class="literalblock programlisting"><div class=content><pre>#define	INADDR_ANY		(u_int32_t)0x00000000</pre></div></div><div class=paragraph><p>Suppose we were writing a server for the <em>daytime</em> protocol over TCP/IP. Recall that it uses port 13. Our <code>sockaddr_in</code> structure would look like this:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/developers-handbook/sainserv.png alt="Example Server sockaddr_in"></div></div></div><div class=sect4><h5 id=sockets-listen>7.5.1.3.2. <code>listen</code><a class=anchor href=#sockets-listen></a></h5><div class=paragraph><p>To continue our office phone analogy, after you have told the phone central operator what extension you will be at, you now walk into your office, and make sure your own phone is plugged in and the ringer is turned on. Plus, you make sure your call waiting is activated, so you can hear the phone ring even while you are talking to someone.</p></div><div class=paragraph><p>The server ensures all of that with the <a href="https://man.freebsd.org/cgi/man.cgi?query=listen&amp;sektion=2&amp;format=html">listen(2)</a> function.</p></div><div class="literalblock programlisting"><div class=content><pre>int listen(int s, int backlog);</pre></div></div><div class=paragraph><p>In here, the <code>backlog</code> variable tells sockets how many incoming requests to accept while you are busy processing the last request. In other words, it determines the maximum size of the queue of pending connections.</p></div></div><div class=sect4><h5 id=sockets-accept>7.5.1.3.3. <code>accept</code><a class=anchor href=#sockets-accept></a></h5><div class=paragraph><p>After you hear the phone ringing, you accept the call by answering the call. You have now established a connection with your client. This connection remains active until either you or your client hang up.</p></div><div class=paragraph><p>The server accepts the connection by using the <a href="https://man.freebsd.org/cgi/man.cgi?query=accept&amp;sektion=2&amp;format=html">accept(2)</a> function.</p></div><div class="literalblock programlisting"><div class=content><pre>int accept(int s, struct sockaddr *addr, socklen_t *addrlen);</pre></div></div><div class=paragraph><p>Note that this time <code>addrlen</code> is a pointer. This is necessary because in this case it is the socket that fills out <code>addr</code>, the <code>sockaddr_in</code> structure.</p></div><div class=paragraph><p>The return value is an integer. Indeed, the <code>accept</code> returns a <em>new socket</em>. You will use this new socket to communicate with the client.</p></div><div class=paragraph><p>What happens to the old socket? It continues to listen for more requests (remember the <code>backlog</code> variable we passed to <code>listen</code>?) until we <code>close</code> it.</p></div><div class=paragraph><p>Now, the new socket is meant only for communications. It is fully connected. We cannot pass it to <code>listen</code> again, trying to accept additional connections.</p></div></div><div class=sect4><h5 id=sockets-first-server>7.5.1.3.4. Our First Server<a class=anchor href=#sockets-first-server></a></h5><div class=paragraph><p>Our first server will be somewhat more complex than our first client was: Not only do we have more sockets functions to use, but we need to write it as a daemon.</p></div><div class=paragraph><p>This is best achieved by creating a <em>child process</em> after binding the port. The main process then exits and returns control to the shell (or whatever program invoked it).</p></div><div class=paragraph><p>The child calls <code>listen</code>, then starts an endless loop, which accepts a connection, serves it, and eventually closes its socket.</p></div><div class="literalblock programlisting"><div class=content><pre>/*
 * daytimed - a port 13 server
 *
 * Programmed by G. Adam Stanislav
 * June 19, 2001
 */
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;time.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;

#define BACKLOG 4

int main() {
    register int s, c;
    int b;
    struct sockaddr_in sa;
    time_t t;
    struct tm *tm;
    FILE *client;

    if ((s = socket(PF_INET, SOCK_STREAM, 0)) &lt; 0) {
        perror(&#34;socket&#34;);
        return 1;
    }

    bzero(&amp;sa, sizeof sa);

    sa.sin_family = AF_INET;
    sa.sin_port   = htons(13);

    if (INADDR_ANY)
        sa.sin_addr.s_addr = htonl(INADDR_ANY);

    if (bind(s, (struct sockaddr *)&amp;sa, sizeof sa) &lt; 0) {
        perror(&#34;bind&#34;);
        return 2;
    }

    switch (fork()) {
        case -1:
            perror(&#34;fork&#34;);
            return 3;
            break;
        default:
            close(s);
            return 0;
            break;
        case 0:
            break;
    }

    listen(s, BACKLOG);

    for (;;) {
        b = sizeof sa;

        if ((c = accept(s, (struct sockaddr *)&amp;sa, &amp;b)) &lt; 0) {
            perror(&#34;daytimed accept&#34;);
            return 4;
        }

        if ((client = fdopen(c, &#34;w&#34;)) == NULL) {
            perror(&#34;daytimed fdopen&#34;);
            return 5;
        }

        if ((t = time(NULL)) &lt; 0) {
            perror(&#34;daytimed time&#34;);

            return 6;
        }

        tm = gmtime(&amp;t);
        fprintf(client, &#34;%.4i-%.2i-%.2iT%.2i:%.2i:%.2iZ\n&#34;,
            tm-&gt;tm_year + 1900,
            tm-&gt;tm_mon + 1,
            tm-&gt;tm_mday,
            tm-&gt;tm_hour,
            tm-&gt;tm_min,
            tm-&gt;tm_sec);

        fclose(client);
    }
}</pre></div></div><div class=paragraph><p>We start by creating a socket. Then we fill out the <code>sockaddr_in</code> structure in <code>sa</code>. Note the conditional use of INADDR_ANY:</p></div><div class="literalblock programlisting"><div class=content><pre>if (INADDR_ANY)
        sa.sin_addr.s_addr = htonl(INADDR_ANY);</pre></div></div><div class=paragraph><p>Its value is <code>0</code>. Since we have just used <code>bzero</code> on the entire structure, it would be redundant to set it to <code>0</code> again. But if we port our code to some other system where INADDR_ANY is perhaps not a zero, we need to assign it to <code>sa.sin_addr.s_addr</code>. Most modern C compilers are clever enough to notice that INADDR_ANY is a constant. As long as it is a zero, they will optimize the entire conditional statement out of the code.</p></div><div class=paragraph><p>After we have called <code>bind</code> successfully, we are ready to become a <em>daemon</em>: We use <code>fork</code> to create a child process. In both, the parent and the child, the <code>s</code> variable is our socket. The parent process will not need it, so it calls <code>close</code>, then it returns <code>0</code> to inform its own parent it had terminated successfully.</p></div><div class=paragraph><p>Meanwhile, the child process continues working in the background. It calls <code>listen</code> and sets its backlog to <code>4</code>. It does not need a large value here because <em>daytime</em> is not a protocol many clients request all the time, and because it can process each request instantly anyway.</p></div><div class=paragraph><p>Finally, the daemon starts an endless loop, which performs the following steps:</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Call <code>accept</code>. It waits here until a client contacts it. At that point, it receives a new socket, <code>c</code>, which it can use to communicate with this particular client.</p></li><li><p>It uses the C function <code>fdopen</code> to turn the socket from a low-level <em>file descriptor</em> to a C-style <code>FILE</code> pointer. This will allow the use of <code>fprintf</code> later on.</p></li><li><p>It checks the time, and prints it in the <em>ISO 8601</em> format to the <code>client</code> "file". It then uses <code>fclose</code> to close the file. That will automatically close the socket as well.</p></li></ol></div></div></div><div class=paragraph><p>We can <em>generalize</em> this, and use it as a model for many other servers:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/developers-handbook/serv.png alt="Sequential Server"></div></div><div class=paragraph><p>This flowchart is good for <em>sequential servers</em>, i.e., servers that can serve one client at a time, just as we were able to with our <em>daytime</em> server. This is only possible whenever there is no real "conversation" going on between the client and the server: As soon as the server detects a connection to the client, it sends out some data and closes the connection. The entire operation may take nanoseconds, and it is finished.</p></div><div class=paragraph><p>The advantage of this flowchart is that, except for the brief moment after the parent <code>fork</code>s and before it exits, there is always only one <em>process</em> active: Our server does not take up much memory and other system resources.</p></div><div class=paragraph><p>Note that we have added <em>initialize daemon</em> in our flowchart. We did not need to initialize our own daemon, but this is a good place in the flow of the program to set up any <code>signal</code> handlers, open any files we may need, etc.</p></div><div class=paragraph><p>Just about everything in the flow chart can be used literally on many different servers. The <em>serve</em> entry is the exception. We think of it as a <em>"black box"</em>, i.e., something you design specifically for your own server, and just "plug it into the rest."</p></div><div class=paragraph><p>Not all protocols are that simple. Many receive a request from the client, reply to it, then receive another request from the same client. Because of that, they do not know in advance how long they will be serving the client. Such servers usually start a new process for each client. While the new process is serving its client, the daemon can continue listening for more connections.</p></div><div class=paragraph><p>Now, go ahead, save the above source code as <span class=filename>daytimed.c</span> (it is customary to end the names of daemons with the letter <code>d</code>). After you have compiled it, try running it:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ./daytimed
<span class=nb>bind</span>: Permission denied
%</code></pre></div></div><div class=paragraph><p>What happened here? As you will recall, the <em>daytime</em> protocol uses port 13. But all ports below 1024 are reserved to the superuser (otherwise, anyone could start a daemon pretending to serve a commonly used port, while causing a security breach).</p></div><div class=paragraph><p>Try again, this time as the superuser:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ./daytimed</span>
<span class=c>#</span></code></pre></div></div><div class=paragraph><p>What…​ Nothing? Let us try again:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ./daytimed</span>

<span class=nb>bind</span>: Address already <span class=k>in </span>use
<span class=c>#</span></code></pre></div></div><div class=paragraph><p>Every port can only be bound by one program at a time. Our first attempt was indeed successful: It started the child daemon and returned quietly. It is still running and will continue to run until you either kill it, or any of its system calls fail, or you reboot the system.</p></div><div class=paragraph><p>Fine, we know it is running in the background. But is it working? How do we know it is a proper <em>daytime</em> server? Simple:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% telnet localhost 13

Trying ::1...
telnet: connect to address ::1: Connection refused
Trying 127.0.0.1...
Connected to localhost.
Escape character is <span class=s1>&#39;^]&#39;</span><span class=nb>.</span>
2001-06-19T21:04:42Z
Connection closed by foreign host.
%</code></pre></div></div><div class=paragraph><p>telnet tried the new IPv6, and failed. It retried with IPv4 and succeeded. The daemon works.</p></div><div class=paragraph><p>If you have access to another UNIX® system via telnet, you can use it to test accessing the server remotely. My computer does not have a static IP address, so this is what I did:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>who

</span>whizkid          ttyp0   Jun 19 16:59   <span class=o>(</span>216.127.220.143<span class=o>)</span>
xxx              ttyp1   Jun 19 16:06   <span class=o>(</span>xx.xx.xx.xx<span class=o>)</span>
% telnet 216.127.220.143 13

Trying 216.127.220.143...
Connected to r47.bfm.org.
Escape character is <span class=s1>&#39;^]&#39;</span><span class=nb>.</span>
2001-06-19T21:31:11Z
Connection closed by foreign host.
%</code></pre></div></div><div class=paragraph><p>Again, it worked. Will it work using the domain name?</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% telnet r47.bfm.org 13

Trying 216.127.220.143...
Connected to r47.bfm.org.
Escape character is <span class=s1>&#39;^]&#39;</span><span class=nb>.</span>
2001-06-19T21:31:40Z
Connection closed by foreign host.
%</code></pre></div></div><div class=paragraph><p>By the way, telnet prints the <em>Connection closed by foreign host</em> message after our daemon has closed the socket. This shows us that, indeed, using <code>fclose(client);</code> in our code works as advertised.</p></div></div></div></div></div></div><div class=sect1><h2 id=sockets-helper-functions>7.6. Helper Functions<a class=anchor href=#sockets-helper-functions></a></h2><div class=sectionbody><div class=paragraph><p>FreeBSD C library contains many helper functions for sockets programming. For example, in our sample client we hard coded the <code>time.nist.gov</code> IP address. But we do not always know the IP address. Even if we do, our software is more flexible if it allows the user to enter the IP address, or even the domain name.</p></div><div class=sect2><h3 id=sockets-gethostbyname>7.6.1. <code>gethostbyname</code><a class=anchor href=#sockets-gethostbyname></a></h3><div class=paragraph><p>While there is no way to pass the domain name directly to any of the sockets functions, the FreeBSD C library comes with the <a href="https://man.freebsd.org/cgi/man.cgi?query=gethostbyname&amp;sektion=3&amp;format=html">gethostbyname(3)</a> and <a href="https://man.freebsd.org/cgi/man.cgi?query=gethostbyname2&amp;sektion=3&amp;format=html">gethostbyname2(3)</a> functions, declared in <span class=filename>netdb.h</span>.</p></div><div class="literalblock programlisting"><div class=content><pre>struct hostent * gethostbyname(const char *name);
struct hostent * gethostbyname2(const char *name, int af);</pre></div></div><div class=paragraph><p>Both return a pointer to the <code>hostent</code> structure, with much information about the domain. For our purposes, the <code>h_addr_list[0]</code> field of the structure points at <code>h_length</code> bytes of the correct address, already stored in the <em>network byte order</em>.</p></div><div class=paragraph><p>This allows us to create a much more flexible-and much more useful-version of our daytime program:</p></div><div class="literalblock programlisting"><div class=content><pre>/*
 * daytime.c
 *
 * Programmed by G. Adam Stanislav
 * 19 June 2001
 */
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;netdb.h&gt;

int main(int argc, char *argv[]) {
  register int s;
  register int bytes;
  struct sockaddr_in sa;
  struct hostent *he;
  char buf[BUFSIZ+1];
  char *host;

  if ((s = socket(PF_INET, SOCK_STREAM, 0)) &lt; 0) {
    perror(&#34;socket&#34;);
    return 1;
  }

  bzero(&amp;sa, sizeof sa);

  sa.sin_family = AF_INET;
  sa.sin_port = htons(13);

  host = (argc &gt; 1) ? (char *)argv[1] : &#34;time.nist.gov&#34;;

  if ((he = gethostbyname(host)) == NULL) {
    herror(host);
    return 2;
  }

  bcopy(he-&gt;h_addr_list[0],&amp;sa.sin_addr, he-&gt;h_length);

  if (connect(s, (struct sockaddr *)&amp;sa, sizeof sa) &lt; 0) {
    perror(&#34;connect&#34;);
    return 3;
  }

  while ((bytes = read(s, buf, BUFSIZ)) &gt; 0)
    write(1, buf, bytes);

  close(s);
  return 0;
}</pre></div></div><div class=paragraph><p>We now can type a domain name (or an IP address, it works both ways) on the command line, and the program will try to connect to its <em>daytime</em> server. Otherwise, it will still default to <code>time.nist.gov</code>. However, even in this case we will use <code>gethostbyname</code> rather than hard coding <code>192.43.244.18</code>. That way, even if its IP address changes in the future, we will still find it.</p></div><div class=paragraph><p>Since it takes virtually no time to get the time from your local server, you could run daytime twice in a row: First to get the time from <code>time.nist.gov</code>, the second time from your own system. You can then compare the results and see how exact your system clock is:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% daytime <span class=p>;</span> daytime localhost

52080 01-06-20 04:02:33 50 0 0 390.2 UTC<span class=o>(</span>NIST<span class=o>)</span> <span class=k>*</span>
2001-06-20T04:02:35Z
%</code></pre></div></div><div class=paragraph><p>As you can see, my system was two seconds ahead of the NIST time.</p></div></div><div class=sect2><h3 id=sockets-getservbyname>7.6.2. <code>getservbyname</code><a class=anchor href=#sockets-getservbyname></a></h3><div class=paragraph><p>Sometimes you may not be sure what port a certain service uses. The <a href="https://man.freebsd.org/cgi/man.cgi?query=getservbyname&amp;sektion=3&amp;format=html">getservbyname(3)</a> function, also declared in <span class=filename>netdb.h</span> comes in very handy in those cases:</p></div><div class="literalblock programlisting"><div class=content><pre>struct servent * getservbyname(const char *name, const char *proto);</pre></div></div><div class=paragraph><p>The <code>servent</code> structure contains the <code>s_port</code>, which contains the proper port, already in <em>network byte order</em>.</p></div><div class=paragraph><p>Had we not known the correct port for the <em>daytime</em> service, we could have found it this way:</p></div><div class="literalblock programlisting"><div class=content><pre>struct servent *se;
  ...
  if ((se = getservbyname(&#34;daytime&#34;, &#34;tcp&#34;)) == NULL {
    fprintf(stderr, &#34;Cannot determine which port to use.\n&#34;);
    return 7;
  }
  sa.sin_port = se-&gt;s_port;</pre></div></div><div class=paragraph><p>You usually do know the port. But if you are developing a new protocol, you may be testing it on an unofficial port. Some day, you will register the protocol and its port (if nowhere else, at least in your <span class=filename>/etc/services</span>, which is where <code>getservbyname</code> looks). Instead of returning an error in the above code, you just use the temporary port number. Once you have listed the protocol in <span class=filename>/etc/services</span>, your software will find its port without you having to rewrite the code.</p></div></div></div></div><div class=sect1><h2 id=sockets-concurrent-servers>7.7. Concurrent Servers<a class=anchor href=#sockets-concurrent-servers></a></h2><div class=sectionbody><div class=paragraph><p>Unlike a sequential server, a <em>concurrent server</em> has to be able to serve more than one client at a time. For example, a <em>chat server</em> may be serving a specific client for hours-it cannot wait till it stops serving a client before it serves the next one.</p></div><div class=paragraph><p>This requires a significant change in our flowchart:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/developers-handbook/serv2.png alt="Concurrent Server"></div></div><div class=paragraph><p>We moved the <em>serve</em> from the <em>daemon process</em> to its own <em>server process</em>. However, because each child process inherits all open files (and a socket is treated just like a file), the new process inherits not only the <em>"accepted handle,"</em> i.e., the socket returned by the <code>accept</code> call, but also the <em>top socket</em>, i.e., the one opened by the top process right at the beginning.</p></div><div class=paragraph><p>However, the <em>server process</em> does not need this socket and should <code>close</code> it immediately. Similarly, the <em>daemon process</em> no longer needs the <em>accepted socket</em>, and not only should, but <em>must</em> <code>close</code> it-otherwise, it will run out of available <em>file descriptors</em> sooner or later.</p></div><div class=paragraph><p>After the <em>server process</em> is done serving, it should close the <em>accepted socket</em>. Instead of returning to <code>accept</code>, it now exits.</p></div><div class=paragraph><p>Under UNIX®, a process does not really <em>exit</em>. Instead, it <em>returns</em> to its parent. Typically, a parent process <code>wait</code>s for its child process, and obtains a return value. However, our <em>daemon process</em> cannot simply stop and wait. That would defeat the whole purpose of creating additional processes. But if it never does <code>wait</code>, its children will become <em>zombies</em>-no longer functional but still roaming around.</p></div><div class=paragraph><p>For that reason, the <em>daemon process</em> needs to set <em>signal handlers</em> in its <em>initialize daemon</em> phase. At least a SIGCHLD signal has to be processed, so the daemon can remove the zombie return values from the system and release the system resources they are taking up.</p></div><div class=paragraph><p>That is why our flowchart now contains a <em>process signals</em> box, which is not connected to any other box. By the way, many servers also process SIGHUP, and typically interpret as the signal from the superuser that they should reread their configuration files. This allows us to change settings without having to kill and restart these servers.</p></div></div></div></div><hr><div class=last-modified><p><strong>最後修改於</strong>: March 9, 2024 由 <a href="https://cgit.freebsd.org/doc/commit/?id=6199af92e7" target=_blank>Danilo G. Baio</a></p></div><div class=buttons><div class=prev><i class="fa fa-angle-left" aria-hidden=true title=Prev></i><div class=container><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/partii class=direction>Prev</a></div></div><div class=home><i class="fa fa-home" aria-hidden=true title=Home></i><div class=container><a href=../ class=direction>Home</a></div></div><div class=next><div class=container><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/ipv6 class=direction>Next</a></div><i class="fa fa-angle-right" aria-hidden=true title=Next></i></div></div><label class="hidden book-menu-overlay" for=menu-control></label></div><aside class=toc><div class=toc-content><h3>目錄</h3><nav id=TableOfContents><ul><li><a href=#sockets-synopsis>7.1. Synopsis</a></li><li><a href=#sockets-diversity>7.2. Networking and Diversity</a></li><li><a href=#sockets-protocols>7.3. Protocols</a></li><li><a href=#sockets-model>7.4. The Sockets Model</a></li><li><a href=#sockets-essential-functions>7.5. Essential Socket Functions</a></li><li><a href=#sockets-helper-functions>7.6. Helper Functions</a></li><li><a href=#sockets-concurrent-servers>7.7. Concurrent Servers</a></li></ul></nav><hr><div class=resources><h3>資源</h3><ul class=contents><li><i class="fa fa-file-pdf-o" aria-hidden=true title="下載 PDF"></i><a href=https://download.freebsd.org/doc/zh-tw/books/developers-handbook/developers-handbook_zh-tw.pdf>下載 PDF</a></li><li><i class="fa fa-pencil-square-o" aria-hidden=true title=編輯此頁></i><a href=https://github.com/freebsd/freebsd-doc/blob/main/documentation/content/zh-tw/_index target=_blank>編輯此頁</a></li></ul></div></div></aside><a class=to-top href=#top><i class="fa fa-arrow-circle-up" aria-hidden=true></i></a></main><footer><div class=footer-container><section class=logo-column><img src=https://docs.freebsd.org/images/FreeBSD-colors.svg width=160 height=50 alt="FreeBSD logo"><div class=options-container><div class=language-container><a id=languages href=https://docs.freebsd.org/zh-tw/languages><img src=https://docs.freebsd.org/images/language.png class=language-image alt=選擇語言>
<span>繁體中文</span></a></div><div class=theme-container><select id=theme-chooser><option value=theme-system>System</option><option value=theme-light>淺色</option><option value=theme-dark>深色</option><option value=theme-high-contrast>高對比</option></select></div></div></section><section class=about-column><h3 class=column-title>About</h3><ul class=column-elements-container><li><a href=https://www.freebsd.org/about/ target=_blank class=column-element>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/ target=_blank class=column-element>FreeBSD Foundation</a></li><li><a href=https://www.freebsd.org/where/ target=_blank class=column-element>Get FreeBSD</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct target=_blank class=column-element>Code of Conduct</a></li><li><a href=https://www.freebsd.org/security/ target=_blank class=column-element>Security Advisories</a></li></ul></section><section class=documentation-column><h3 class=column-title>Documentation</h3><ul class=column-elements-container><li><a href=/zh-tw class=column-element>Documentation portal</a></li><li><a href=https://man.FreeBSD.org target=_blank class=column-element>Manual pages</a></li><li><a href=https://papers.FreeBSD.org target=_blank class=column-element>Presentations and papers</a></li><li><a href=https://docs-archive.freebsd.org/doc/ target=_blank class=column-element>Previous versions</a></li><li><a href=https://docs-archive.freebsd.org/44doc/ target=_blank class=column-element>4.4BSD Documents</a></li><li><a href=https://wiki.freebsd.org/ target=_blank class=column-element>Wiki</a></li></ul></section><section class=community-column><h3 class=column-title>Community</h3><ul class=column-elements-container><li><a href=https://docs.freebsd.org/zh-tw/articles/contributing class=column-element>Get involved</a></li><li><a href=https://forums.freebsd.org/ target=_blank class=column-element>Community forum</a></li><li><a href=https://lists.freebsd.org/ target=_blank class=column-element>Mailing lists</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank class=column-element>IRC Channels</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank class=column-element>Bug Tracker</a></li></ul></section><section class=legal-column><h3 class=column-title>Legal</h3><ul class=column-elements-container><li><a href=https://freebsdfoundation.org/donate/ target=_blank class=column-element>Donations</a></li><li><a href=https://www.freebsd.org/copyright/freebsd-license/ target=_blank class=column-element>Licensing</a></li><li><a href=https://www.freebsd.org/privacy/ target=_blank class=column-element>Privacy Policy</a></li><li><a href=https://www.freebsd.org/copyright/ target=_blank class=column-element>Legal notices</a></li></ul></section><section class=copyright-column><p>&copy; 1994-2024 The FreeBSD Project. All rights reserved</p><span>Made with <span class=heart>♥</span> by the FreeBSD Community</span></section></div></footer></body></html>