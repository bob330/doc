<!doctype html><html class=theme-light lang=zh-tw><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content><meta name=keywords content><meta name=copyright content="1995-2024 The FreeBSD Foundation"><link rel=canonical href=https://docs.freebsd.org/zh-tw/books/developers-handbook/ipv6/><title>章 8. IPv6 Internals | FreeBSD Documentation Portal</title>
<meta name=theme-color content="#790000"><meta name=color-scheme content="system light dark high-contrast"><link rel="shortcut icon" href=https://docs.freebsd.org/favicon.ico><link rel=stylesheet href=https://docs.freebsd.org/styles/main.min.css><link rel=stylesheet href=https://docs.freebsd.org/css/font-awesome-min.css><script defer src=/js/theme-chooser.min.js></script><script defer src=/js/copy-clipboard.min.js></script><script defer src=/js/search.min.js></script><meta name=twitter:card content="summary"><meta name=twitter:domain content="docs.FreeBSD.org"><meta name=twitter:site content="@freebsd"><meta name=twitter:url content="https://twitter.com/freebsd"><meta property="og:title" content="章 8. IPv6 Internals"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:image" content="https://docs.freebsd.org/favicon.ico"><meta property="og:image:alt" content="FreeBSD Logo"><meta property="og:locale" content="zh-tw"><meta property="og:url" content="https://docs.freebsd.org/zh-tw/books/developers-handbook/ipv6/"><meta property="og:site_name" content="FreeBSD Documentation Portal"><script type=application/ld+json>{"@context":"http://schema.org","@type":"Article","url":"https:\/\/docs.freebsd.org\/zh-tw\/books\/developers-handbook\/ipv6\/","name":"FreeBSD Documentation Portal","headline":"FreeBSD Documentation Portal","description":"FreeBSD Documentation Portal"}</script></head><body><header><div class=header-container><div class=logo-menu-bars-container><a href=https://www.FreeBSD.org class=logo><img src=https://docs.freebsd.org/images/FreeBSD-monochromatic.svg width=160 height=50 alt="FreeBSD logo">
</a><label class=menu-bars for=menu-bars><i class="fa fa-bars" aria-hidden=true></i></label></div><input id=menu-bars type=checkbox><nav><ul class=menu><li class=menu-item><input id=about type=checkbox>
<a href=# aria-label="Navigate to About section"><label class=menu-item-description for=about>About
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/about/ target=_blank>About</a></li><li><a href=https://www.freebsd.org/about/ target=_blank>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/about-us/about-the-foundation/ target=_blank>FreeBSD Foundation</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct/ target=_blank>Code of Conduct</a></li></ul></li><li class=menu-item><input id=download type=checkbox>
<a href=# aria-label="Navigate to get FreeBSD section"><label class=menu-item-description for=download>Get FreeBSD
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/where/ target=_blank>Get FreeBSD</a></li><li><a href=https://www.freebsd.org/releases/ target=_blank>Release Information</a></li><li><a href=https://www.freebsd.org/releng/ target=_blank>Release Engineering</a></li><li><a href=https://www.freebsd.org/security/ target=_blank>Security Advisories</a></li></ul></li><li class=menu-item><input id=documentation type=checkbox>
<a href=# aria-label="Navigate to get Documentation section"><label class=menu-item-description for=documentation>Documentation
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=/zh-tw>Documentation portal</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook>FreeBSD Handbook</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/porters-handbook>Porter's Handbook</a></li><li><a href=https://docs.FreeBSD.org/en/books/fdp-primer>Documentation Project Handbook</a></li><li><a href=https://man.FreeBSD.org target=_blank>Manual pages</a></li><li><a href=https://papers.FreeBSD.org target=_blank>Presentations and papers</a></li><li><a href=https://wiki.FreeBSD.org target=_blank>Wiki</a></li><li><a href=https://docs.freebsd.org/zh-tw/books>Books</a></li><li><a href=https://docs.freebsd.org/zh-tw/articles>Articles</a></li></ul></li><li class=menu-item><input id=community type=checkbox>
<a href=# aria-label="Navigate to get Community section"><label class=menu-item-description for=community>Community
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/community/>Community</a></li><li><a href=https://docs.freebsd.org/zh-tw/articles/contributing>Get involved</a></li><li><a href=https://forums.freebsd.org/ target=_blank>Forum</a></li><li><a href=https://lists.freebsd.org/ target=_blank>Mailing lists</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank>IRC Channels</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank>Bug Tracker</a></li><li><a href=https://www.freebsd.org/support/ target=_blank>Support</a></li></ul></li></ul></nav><div class=search-donate-container><form class=search method=get id=search-header-form action=https://docs.freebsd.org/search name=search-header-form><input type=hidden name=DB value=zh-tw>
<input id=words name=P type=text size=20 maxlength=255>
<button>
<i class="fa fa-search" aria-hidden=true></i></button></form><div class=donate><a href=https://freebsdfoundation.org/donate/ target=_blank><span class=heart>♥</span>
Donate</a></div></div></div></header><input type=checkbox class="hidden toggle" id=menu-control><main class=main-wrapper-book><a id=top></a><aside class=book-menu><div class=book-menu-content><input id=search-book type=text placeholder=Search aria-label=Search maxlength=128><nav id=MenuContents><ul><li><input type=checkbox id=chapter-b1b18a35567534d1699b4dd27b58b2ff class=toggle>
<label for=chapter-b1b18a35567534d1699b4dd27b58b2ff><a role=button></a></label><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/parti/>Part I. Grundlagen</a></li><li><input type=checkbox id=chapter-3af9d0cd3607fbe44d37e3a13957c40f class=toggle>
<label class="icon cursor" for=chapter-3af9d0cd3607fbe44d37e3a13957c40f><a role=button></a></label><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/introduction/>章 1. 簡介</a><ul><li><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/introduction/#introduction-devel>1.1. 在 FreeBSD 開發程式</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/introduction/#introduction-bsdvision>1.2. The BSD Vision</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/introduction/#introduction-archguide>1.3. 程式架構指南</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/introduction/#introduction-layout>1.4. <span class=filename>/usr/src</span> 的架構</a></li></ul></li><li><input type=checkbox id=chapter-15219234c513f9a79d9cb2d3bcf73d13 class=toggle>
<label class="icon cursor" for=chapter-15219234c513f9a79d9cb2d3bcf73d13><a role=button></a></label><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/tools/>章 2. 程式開發工具</a><ul><li><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/tools/#tools-synopsis>2.1. 概敘</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/tools/#tools-intro>2.2. 簡介</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/tools/#tools-programming>2.3. Programming 概念</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/tools/#tools-compiling>2.4. 用 <code>cc</code> 來編譯程式</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/tools/#tools-make>2.5. Make</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/tools/#debugging>2.6. Debugging</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/tools/#emacs>2.7. Using Emacs as a Development Environment</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/tools/#tools-reading>2.8. Further Reading</a></li></ul></li><li><input type=checkbox id=chapter-7319f5d899d5be33daaf1f2d5f180558 class=toggle>
<label class="icon cursor" for=chapter-7319f5d899d5be33daaf1f2d5f180558><a role=button></a></label><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/secure/>章 3. Secure Programming</a><ul><li><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/secure/#secure-synopsis>3.1. Synopsis</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/secure/#secure-philosophy>3.2. Secure Design Methodology</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/secure/#secure-bufferov>3.3. Buffer Overflows</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/secure/#secure-setuid>3.4. SetUID issues</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/secure/#secure-chroot>3.5. Limiting your program’s environment</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/secure/#secure-trust>3.6. Trust</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/secure/#secure-race-conditions>3.7. Race Conditions</a></li></ul></li><li><input type=checkbox id=chapter-0240ccaf7010beed911378cfab7bd8fc class=toggle>
<label class="icon cursor" for=chapter-0240ccaf7010beed911378cfab7bd8fc><a role=button></a></label><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/l10n/>章 4. Localization and Internationalization - L10N and I18N</a><ul><li><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/l10n/#l10n-programming>4.1. Programming I18N Compliant Applications</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/l10n/#posix-nls>4.2. Localized Messages with POSIX.1 Native Language Support (NLS)</a></li></ul></li><li><input type=checkbox id=chapter-c3107aaf64e60e1ee09bc33fc9fd641a class=toggle>
<label class="icon cursor" for=chapter-c3107aaf64e60e1ee09bc33fc9fd641a><a role=button></a></label><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/policies/>章 5. Source Tree Guidelines and Policies</a><ul><li><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/policies/#policies-style>5.1. Style Guidelines</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/policies/#policies-maintainer>5.2. <code>MAINTAINER</code> on Makefiles</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/policies/#policies-contributed>5.3. Contributed Software</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/policies/#policies-encumbered>5.4. Encumbered Files</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/policies/#policies-shlib>5.5. Shared Libraries</a></li></ul></li><li><input type=checkbox id=chapter-c7b4fd5a7f8f049234fe3bc225acef44 class=toggle>
<label class="icon cursor" for=chapter-c7b4fd5a7f8f049234fe3bc225acef44><a role=button></a></label><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/testing/>章 6. Regression and Performance Testing</a><ul><li><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/testing/#testing-micro-benchmark>6.1. Micro Benchmark Checklist</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/testing/#testing-tinderbox>6.2. The FreeBSD Source Tinderbox</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/testing/#_the_index_cgi_script>6.3. The <span class=filename>index.cgi</span> Script</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/testing/#_official_build_servers>6.4. Official Build Servers</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/testing/#_official_summary_site>6.5. Official Summary Site</a></li></ul></li><li><input type=checkbox id=chapter-1f9b02a65f2bc5d4015a050d706fa837 class=toggle>
<label for=chapter-1f9b02a65f2bc5d4015a050d706fa837><a role=button></a></label><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/partii/>Part II. Interprozess-Kommunikation</a></li><li><input type=checkbox id=chapter-5e03777f678dd5731a581d7956d19c13 class=toggle>
<label class="icon cursor" for=chapter-5e03777f678dd5731a581d7956d19c13><a role=button></a></label><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/sockets/>章 7. Sockets</a><ul><li><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/sockets/#sockets-synopsis>7.1. Synopsis</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/sockets/#sockets-diversity>7.2. Networking and Diversity</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/sockets/#sockets-protocols>7.3. Protocols</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/sockets/#sockets-model>7.4. The Sockets Model</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/sockets/#sockets-essential-functions>7.5. Essential Socket Functions</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/sockets/#sockets-helper-functions>7.6. Helper Functions</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/sockets/#sockets-concurrent-servers>7.7. Concurrent Servers</a></li></ul></li><li><input type=checkbox id=chapter-5cbeeaa29a95a5f152e5ccc3901d0fd3 class=toggle checked>
<label class="icon cursor" for=chapter-5cbeeaa29a95a5f152e5ccc3901d0fd3><a role=button></a></label><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/ipv6/>章 8. IPv6 Internals</a><ul><li><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/ipv6/#ipv6-implementation>8.1. IPv6/IPsec Implementation</a></li></ul></li><li><input type=checkbox id=chapter-c9a07b517dc2e43d169c8e013e23cfc1 class=toggle>
<label for=chapter-c9a07b517dc2e43d169c8e013e23cfc1><a role=button></a></label><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/partiii/>Part III. Kernel</a></li><li><input type=checkbox id=chapter-db22f8e5e5e9496dbc711815e2e05f36 class=toggle>
<label class="icon cursor" for=chapter-db22f8e5e5e9496dbc711815e2e05f36><a role=button></a></label><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/kernelbuild/>章 9. Building and Installing a FreeBSD Kernel</a><ul><li><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/kernelbuild/#kernelbuild-traditional>9.1. Building the Faster but Brittle Way</a></li></ul></li><li><input type=checkbox id=chapter-3036877c53948cfb76174f2776bbdf64 class=toggle>
<label class="icon cursor" for=chapter-3036877c53948cfb76174f2776bbdf64><a role=button></a></label><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/kerneldebug/>章 10. Kernel Debugging</a><ul><li><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/kerneldebug/#kerneldebug-obtain>10.1. Obtaining a Kernel Crash Dump</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/kerneldebug/#kerneldebug-gdb>10.2. Debugging a Kernel Crash Dump with <code>kgdb</code></a></li><li><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/kerneldebug/#kerneldebug-online-ddb>10.3. On-Line Kernel Debugging Using DDB</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/kerneldebug/#kerneldebug-online-gdb>10.4. On-Line Kernel Debugging Using Remote GDB</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/kerneldebug/#kerneldebug-console>10.5. Debugging a Console Driver</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/kerneldebug/#kerneldebug-deadlocks>10.6. Debugging Deadlocks</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/kerneldebug/#kerneldebug-dcons>10.7. Kernel debugging with Dcons</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/kerneldebug/#kerneldebug-options>10.8. Glossary of Kernel Options for Debugging</a></li></ul></li><li><input type=checkbox id=chapter-86707094ce48d6e89e5f45569c084cea class=toggle>
<label for=chapter-86707094ce48d6e89e5f45569c084cea><a role=button></a></label><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/partiv/>Part IV. Architekturen</a></li><li><input type=checkbox id=chapter-43b1e1e6d2a94eb8b161876bc22ce644 class=toggle>
<label class="icon cursor" for=chapter-43b1e1e6d2a94eb8b161876bc22ce644><a role=button></a></label><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/x86/>章 11. x86 Assembly Language Programming</a><ul><li><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/x86/#x86-intro>11.1. Synopsis</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/x86/#x86-the-tools>11.2. The Tools</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/x86/#x86-system-calls>11.3. System Calls</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/x86/#x86-return-values>11.4. Return Values</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/x86/#x86-portable-code>11.5. Creating Portable Code</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/x86/#x86-first-program>11.6. Our First Program</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/x86/#x86-unix-filters>11.7. Writing UNIX® Filters</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/x86/#x86-buffered-io>11.8. Buffered Input and Output</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/x86/#x86-command-line>11.9. Command Line Arguments</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/x86/#x86-environment>11.10. UNIX® Environment</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/x86/#x86-files>11.11. Working with Files</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/x86/#x86-one-pointed-mind>11.12. One-Pointed Mind</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/x86/#x86-fpu>11.13. Using the FPU</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/x86/#x86-caveats>11.14. Caveats</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/x86/#x86-acknowledgements>11.15. Acknowledgements</a></li></ul></li><li><input type=checkbox id=chapter-c49dfe630861d471fb2f58f5b554ed84 class=toggle>
<label for=chapter-c49dfe630861d471fb2f58f5b554ed84><a role=button></a></label><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/partv/>Part V. Appendices</a></li><li><input type=checkbox id=chapter-ac9541a3f38001d13964c1b0b324bb83 class=toggle>
<label for=chapter-ac9541a3f38001d13964c1b0b324bb83><a role=button></a></label><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/bibliography/>附錄</a></li><li></li></ul></nav></div></aside><div class=book><div class=book-menu-mobile><label for=menu-control><span class=menu-control-button><i class="fa fa-list" aria-hidden=true title="Book menu"></i>
Book menu</span></label></div><h1 class=title>章 8. IPv6 Internals</h1><div class="admonitionblock note"><p><i class="fa fa-exclamation-circle" aria-hidden=true></i>
This translation may be out of date. To help with the translations please access the <a href=https://translate-dev.freebsd.org/ target=_blank>FreeBSD translations instance</a>.</p></div><div class=toc-mobile><h3>目錄</h3><nav id=TableOfContents><ul><li><a href=#ipv6-implementation>8.1. IPv6/IPsec Implementation</a></li></ul></nav></div><div class=book-content><div id=preamble><div class=sectionbody></div></div><div class=sect1><h2 id=ipv6-implementation>8.1. IPv6/IPsec Implementation<a class=anchor href=#ipv6-implementation></a></h2><div class=sectionbody><div class=paragraph><p>This section should explain IPv6 and IPsec related implementation internals. These functionalities are derived from <a href=http://www.kame.net/>KAME project</a></p></div><div class=sect2><h3 id=ipv6details>8.1.1. IPv6<a class=anchor href=#ipv6details></a></h3><div class=sect3><h4 id=_conformance>8.1.1.1. Conformance<a class=anchor href=#_conformance></a></h4><div class=paragraph><p>The IPv6 related functions conforms, or tries to conform to the latest set of IPv6 specifications. For future reference we list some of the relevant documents below (<em>NOTE</em>: this is not a complete list - this is too hard to maintain…​).</p></div><div class=paragraph><p>For details please refer to specific chapter in the document, RFCs, manual pages, or comments in the source code.</p></div><div class=paragraph><p>Conformance tests have been performed on the KAME STABLE kit at TAHI project. Results can be viewed at <a href=http://www.tahi.org/report/KAME/>http://www.tahi.org/report/KAME/</a>. We also attended University of New Hampshire IOL tests (<a href=http://www.iol.unh.edu/>http://www.iol.unh.edu/</a>) in the past, with our past snapshots.</p></div><div class=ulist><ul><li><p>RFC1639: FTP Operation Over Big Address Records (FOOBAR)</p><div class=ulist><ul><li><p>RFC2428 is preferred over RFC1639. FTP clients will first try RFC2428, then RFC1639 if failed.</p></li></ul></div></li><li><p>RFC1886: DNS Extensions to support IPv6</p></li><li><p>RFC1933: Transition Mechanisms for IPv6 Hosts and Routers</p><div class=ulist><ul><li><p>IPv4 compatible address is not supported.</p></li><li><p>automatic tunneling (described in 4.3 of this RFC) is not supported.</p></li><li><p><a href="https://man.freebsd.org/cgi/man.cgi?query=gif&amp;sektion=4&amp;format=html">gif(4)</a> interface implements IPv[46]-over-IPv[46] tunnel in a generic way, and it covers "configured tunnel" described in the spec. See <a href=#gif>23.5.1.5</a> in this document for details.</p></li></ul></div></li><li><p>RFC1981: Path MTU Discovery for IPv6</p></li><li><p>RFC2080: RIPng for IPv6</p><div class=ulist><ul><li><p>usr.sbin/route6d support this.</p></li></ul></div></li><li><p>RFC2292: Advanced Sockets API for IPv6</p><div class=ulist><ul><li><p>For supported library functions/kernel APIs, see <span class=filename>sys/netinet6/ADVAPI</span>.</p></li></ul></div></li><li><p>RFC2362: Protocol Independent Multicast-Sparse Mode (PIM-SM)</p><div class=ulist><ul><li><p>RFC2362 defines packet formats for PIM-SM. <span class=filename>draft-ietf-pim-ipv6-01.txt</span> is written based on this.</p></li></ul></div></li><li><p>RFC2373: IPv6 Addressing Architecture</p><div class=ulist><ul><li><p>supports node required addresses, and conforms to the scope requirement.</p></li></ul></div></li><li><p>RFC2374: An IPv6 Aggregatable Global Unicast Address Format</p><div class=ulist><ul><li><p>supports 64-bit length of Interface ID.</p></li></ul></div></li><li><p>RFC2375: IPv6 Multicast Address Assignments</p><div class=ulist><ul><li><p>Userland applications use the well-known addresses assigned in the RFC.</p></li></ul></div></li><li><p>RFC2428: FTP Extensions for IPv6 and NATs</p><div class=ulist><ul><li><p>RFC2428 is preferred over RFC1639. FTP clients will first try RFC2428, then RFC1639 if failed.</p></li></ul></div></li><li><p>RFC2460: IPv6 specification</p></li><li><p>RFC2461: Neighbor discovery for IPv6</p><div class=ulist><ul><li><p>See <a href=#neighbor-discovery>23.5.1.2</a> in this document for details.</p></li></ul></div></li><li><p>RFC2462: IPv6 Stateless Address Autoconfiguration</p><div class=ulist><ul><li><p>See <a href=#ipv6-pnp>23.5.1.4</a> in this document for details.</p></li></ul></div></li><li><p>RFC2463: ICMPv6 for IPv6 specification</p><div class=ulist><ul><li><p>See <a href=#icmpv6>23.5.1.9</a> in this document for details.</p></li></ul></div></li><li><p>RFC2464: Transmission of IPv6 Packets over Ethernet Networks</p></li><li><p>RFC2465: MIB for IPv6: Textual Conventions and General Group</p><div class=ulist><ul><li><p>Necessary statistics are gathered by the kernel. Actual IPv6 MIB support is provided as a patchkit for ucd-snmp.</p></li></ul></div></li><li><p>RFC2466: MIB for IPv6: ICMPv6 group</p><div class=ulist><ul><li><p>Necessary statistics are gathered by the kernel. Actual IPv6 MIB support is provided as patchkit for ucd-snmp.</p></li></ul></div></li><li><p>RFC2467: Transmission of IPv6 Packets over FDDI Networks</p></li><li><p>RFC2497: Transmission of IPv6 packet over ARCnet Networks</p></li><li><p>RFC2553: Basic Socket Interface Extensions for IPv6</p><div class=ulist><ul><li><p>IPv4 mapped address (3.7) and special behavior of IPv6 wildcard bind socket (3.8) are supported. See <a href=#ipv6-wildcard-socket>23.5.1.12</a> in this document for details.</p></li></ul></div></li><li><p>RFC2675: IPv6 Jumbograms</p><div class=ulist><ul><li><p>See <a href=#ipv6-jumbo>23.5.1.7</a> in this document for details.</p></li></ul></div></li><li><p>RFC2710: Multicast Listener Discovery for IPv6</p></li><li><p>RFC2711: IPv6 router alert option</p></li><li><p><span class=filename>draft-ietf-ipngwg-router-renum-08</span>: Router renumbering for IPv6</p></li><li><p><span class=filename>draft-ietf-ipngwg-icmp-namelookups-02</span>: IPv6 Name Lookups Through ICMP</p></li><li><p><span class=filename>draft-ietf-ipngwg-icmp-name-lookups-03</span>: IPv6 Name Lookups Through ICMP</p></li><li><p><span class=filename>draft-ietf-pim-ipv6-01.txt</span>: PIM for IPv6</p><div class=ulist><ul><li><p><a href="https://man.freebsd.org/cgi/man.cgi?query=pim6dd&amp;sektion=8&amp;format=html">pim6dd(8)</a> implements dense mode. <a href="https://man.freebsd.org/cgi/man.cgi?query=pim6sd&amp;sektion=8&amp;format=html">pim6sd(8)</a> implements sparse mode.</p></li></ul></div></li><li><p><span class=filename>draft-itojun-ipv6-tcp-to-anycast-00</span>: Disconnecting TCP connection toward IPv6 anycast address</p></li><li><p><span class=filename>draft-yamamoto-wideipv6-comm-model-00</span></p><div class=ulist><ul><li><p>See <a href=#ipv6-sas>23.5.1.6</a> in this document for details.</p></li></ul></div></li><li><p><span class=filename>draft-ietf-ipngwg-scopedaddr-format-00.txt</span>: An Extension of Format for IPv6 Scoped Addresses</p></li></ul></div></div><div class=sect3><h4 id=neighbor-discovery>8.1.1.2. Neighbor Discovery<a class=anchor href=#neighbor-discovery></a></h4><div class=paragraph><p>Neighbor Discovery is fairly stable. Currently Address Resolution, Duplicated Address Detection, and Neighbor Unreachability Detection are supported. In the near future we will be adding Proxy Neighbor Advertisement support in the kernel and Unsolicited Neighbor Advertisement transmission command as admin tool.</p></div><div class=paragraph><p>If DAD fails, the address will be marked "duplicated" and message will be generated to syslog (and usually to console). The "duplicated" mark can be checked with <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a>. It is administrators' responsibility to check for and recover from DAD failures. The behavior should be improved in the near future.</p></div><div class=paragraph><p>Some of the network driver loops multicast packets back to itself, even if instructed not to do so (especially in promiscuous mode). In such cases DAD may fail, because DAD engine sees inbound NS packet (actually from the node itself) and considers it as a sign of duplicate. You may want to look at #if condition marked "heuristics" in sys/netinet6/nd6_nbr.c:nd6_dad_timer() as workaround (note that the code fragment in "heuristics" section is not spec conformant).</p></div><div class=paragraph><p>Neighbor Discovery specification (RFC2461) does not talk about neighbor cache handling in the following cases:</p></div><div class="olist arabic"><ol class=arabic><li><p>when there was no neighbor cache entry, node received unsolicited RS/NS/NA/redirect packet without link-layer address</p></li><li><p>neighbor cache handling on medium without link-layer address (we need a neighbor cache entry for IsRouter bit)</p></li></ol></div><div class=paragraph><p>For first case, we implemented workaround based on discussions on IETF ipngwg mailing list. For more details, see the comments in the source code and email thread started from (IPng 7155), dated Feb 6 1999.</p></div><div class=paragraph><p>IPv6 on-link determination rule (RFC2461) is quite different from assumptions in BSD network code. At this moment, no on-link determination rule is supported where default router list is empty (RFC2461, section 5.2, last sentence in 2nd paragraph - note that the spec misuse the word "host" and "node" in several places in the section).</p></div><div class=paragraph><p>To avoid possible DoS attacks and infinite loops, only 10 options on ND packet is accepted now. Therefore, if you have 20 prefix options attached to RA, only the first 10 prefixes will be recognized. If this troubles you, please ask it on FREEBSD-CURRENT mailing list and/or modify nd6_maxndopt in <span class=filename>sys/netinet6/nd6.c</span>. If there are high demands we may provide sysctl knob for the variable.</p></div></div><div class=sect3><h4 id=ipv6-scope-index>8.1.1.3. Scope Index<a class=anchor href=#ipv6-scope-index></a></h4><div class=paragraph><p>IPv6 uses scoped addresses. Therefore, it is very important to specify scope index (interface index for link-local address, or site index for site-local address) with an IPv6 address. Without scope index, scoped IPv6 address is ambiguous to the kernel, and kernel will not be able to determine the outbound interface for a packet.</p></div><div class=paragraph><p>Ordinary userland applications should use advanced API (RFC2292) to specify scope index, or interface index. For similar purpose, sin6_scope_id member in sockaddr_in6 structure is defined in RFC2553. However, the semantics for sin6_scope_id is rather vague. If you care about portability of your application, we suggest you to use advanced API rather than sin6_scope_id.</p></div><div class=paragraph><p>In the kernel, an interface index for link-local scoped address is embedded into 2nd 16bit-word (3rd and 4th byte) in IPv6 address. For example, you may see something like:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>	fe80:1::200:f8ff:fe01:6317</code></pre></div></div><div class=paragraph><p>in the routing table and interface address structure (struct in6_ifaddr). The address above is a link-local unicast address which belongs to a network interface whose interface identifier is 1. The embedded index enables us to identify IPv6 link local addresses over multiple interfaces effectively and with only a little code change.</p></div><div class=paragraph><p>Routing daemons and configuration programs, like <a href="https://man.freebsd.org/cgi/man.cgi?query=route6d&amp;sektion=8&amp;format=html">route6d(8)</a> and <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a>, will need to manipulate the "embedded" scope index. These programs use routing sockets and ioctls (like SIOCGIFADDR_IN6) and the kernel API will return IPv6 addresses with 2nd 16bit-word filled in. The APIs are for manipulating kernel internal structure. Programs that use these APIs have to be prepared about differences in kernels anyway.</p></div><div class=paragraph><p>When you specify scoped address to the command line, NEVER write the embedded form (such as ff02:1::1 or fe80:2::fedc). This is not supposed to work. Always use standard form, like ff02::1 or fe80::fedc, with command line option for specifying interface (like <code>ping6 -I ne0 ff02::1</code>). In general, if a command does not have command line option to specify outgoing interface, that command is not ready to accept scoped address. This may seem to be opposite from IPv6’s premise to support "dentist office" situation. We believe that specifications need some improvements for this.</p></div><div class=paragraph><p>Some of the userland tools support extended numeric IPv6 syntax, as documented in <span class=filename>draft-ietf-ipngwg-scopedaddr-format-00.txt</span>. You can specify outgoing link, by using name of the outgoing interface like "fe80::1%ne0". This way you will be able to specify link-local scoped address without much trouble.</p></div><div class=paragraph><p>To use this extension in your program, you will need to use <a href="https://man.freebsd.org/cgi/man.cgi?query=getaddrinfo&amp;sektion=3&amp;format=html">getaddrinfo(3)</a>, and <a href="https://man.freebsd.org/cgi/man.cgi?query=getnameinfo&amp;sektion=3&amp;format=html">getnameinfo(3)</a> with NI_WITHSCOPEID. The implementation currently assumes 1-to-1 relationship between a link and an interface, which is stronger than what specs say.</p></div></div><div class=sect3><h4 id=ipv6-pnp>8.1.1.4. Plug and Play<a class=anchor href=#ipv6-pnp></a></h4><div class=paragraph><p>Most of the IPv6 stateless address autoconfiguration is implemented in the kernel. Neighbor Discovery functions are implemented in the kernel as a whole. Router Advertisement (RA) input for hosts is implemented in the kernel. Router Solicitation (RS) output for endhosts, RS input for routers, and RA output for routers are implemented in the userland.</p></div><div class=sect4><h5 id=_assignment_of_link_local_and_special_addresses>8.1.1.4.1. Assignment of link-local, and special addresses<a class=anchor href=#_assignment_of_link_local_and_special_addresses></a></h5><div class=paragraph><p>IPv6 link-local address is generated from IEEE802 address (Ethernet MAC address). Each of interface is assigned an IPv6 link-local address automatically, when the interface becomes up (IFF_UP). Also, direct route for the link-local address is added to routing table.</p></div><div class=paragraph><p>Here is an output of netstat command:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Internet6:
Destination                   Gateway                   Flags      Netif Expire
fe80:1::%ed0/64               <span class=nb>link</span><span class=c>#1                    UC          ed0</span>
fe80:2::%ep0/64               <span class=nb>link</span><span class=c>#2                    UC          ep0</span></code></pre></div></div><div class=paragraph><p>Interfaces that has no IEEE802 address (pseudo interfaces like tunnel interfaces, or ppp interfaces) will borrow IEEE802 address from other interfaces, such as Ethernet interfaces, whenever possible. If there is no IEEE802 hardware attached, a last resort pseudo-random value, MD5(hostname), will be used as source of link-local address. If it is not suitable for your usage, you will need to configure the link-local address manually.</p></div><div class=paragraph><p>If an interface is not capable of handling IPv6 (such as lack of multicast support), link-local address will not be assigned to that interface. See section 2 for details.</p></div><div class=paragraph><p>Each interface joins the solicited multicast address and the link-local all-nodes multicast addresses (e.g., fe80::1:ff01:6317 and ff02::1, respectively, on the link the interface is attached). In addition to a link-local address, the loopback address (::1) will be assigned to the loopback interface. Also, ::1/128 and ff01::/32 are automatically added to routing table, and loopback interface joins node-local multicast group ff01::1.</p></div></div><div class=sect4><h5 id=_stateless_address_autoconfiguration_on_hosts>8.1.1.4.2. Stateless address autoconfiguration on Hosts<a class=anchor href=#_stateless_address_autoconfiguration_on_hosts></a></h5><div class=paragraph><p>In IPv6 specification, nodes are separated into two categories: <em>routers</em> and <em>hosts</em>. Routers forward packets addressed to others, hosts does not forward the packets. net.inet6.ip6.forwarding defines whether this node is router or host (router if it is 1, host if it is 0).</p></div><div class=paragraph><p>When a host hears Router Advertisement from the router, a host may autoconfigure itself by stateless address autoconfiguration. This behavior can be controlled by net.inet6.ip6.accept_rtadv (host autoconfigures itself if it is set to 1). By autoconfiguration, network address prefix for the receiving interface (usually global address prefix) is added. Default route is also configured. Routers periodically generate Router Advertisement packets. To request an adjacent router to generate RA packet, a host can transmit Router Solicitation. To generate a RS packet at any time, use the <em>rtsol</em> command. <a href="https://man.freebsd.org/cgi/man.cgi?query=rtsold&amp;sektion=8&amp;format=html">rtsold(8)</a> daemon is also available. <a href="https://man.freebsd.org/cgi/man.cgi?query=rtsold&amp;sektion=8&amp;format=html">rtsold(8)</a> generates Router Solicitation whenever necessary, and it works great for nomadic usage (notebooks/laptops). If one wishes to ignore Router Advertisements, use sysctl to set net.inet6.ip6.accept_rtadv to 0.</p></div><div class=paragraph><p>To generate Router Advertisement from a router, use the <a href="https://man.freebsd.org/cgi/man.cgi?query=rtadvd&amp;sektion=8&amp;format=html">rtadvd(8)</a> daemon.</p></div><div class=paragraph><p>Note that, IPv6 specification assumes the following items, and nonconforming cases are left unspecified:</p></div><div class=ulist><ul><li><p>Only hosts will listen to router advertisements</p></li><li><p>Hosts have single network interface (except loopback)</p></li></ul></div><div class=paragraph><p>Therefore, this is unwise to enable net.inet6.ip6.accept_rtadv on routers, or multi-interface host. A misconfigured node can behave strange (nonconforming configuration allowed for those who would like to do some experiments).</p></div><div class=paragraph><p>To summarize the sysctl knob:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>	accept_rtadv	forwarding	role of the node
	<span class=nt>---</span>		<span class=nt>---</span>		<span class=nt>---</span>
	0		0		host <span class=o>(</span>to be manually configured<span class=o>)</span>
	0		1		router
	1		0		autoconfigured host
					<span class=o>(</span>spec assumes that host has single
					interface only, autoconfigured host
					with multiple interface is
					out-of-scope<span class=o>)</span>
	1		1		invalid, or experimental
					<span class=o>(</span>out-of-scope of spec<span class=o>)</span></code></pre></div></div><div class=paragraph><p>RFC2462 has validation rule against incoming RA prefix information option, in 5.5.3 (e). This is to protect hosts from malicious (or misconfigured) routers that advertise very short prefix lifetime. There was an update from Jim Bound to ipngwg mailing list (look for "(ipng 6712)" in the archive) and it is implemented Jim’s update.</p></div><div class=paragraph><p>See <a href=#neighbor-discovery>23.5.1.2</a> in the document for relationship between DAD and autoconfiguration.</p></div></div></div><div class=sect3><h4 id=gif>8.1.1.5. Generic Tunnel Interface<a class=anchor href=#gif></a></h4><div class=paragraph><p>GIF (Generic InterFace) is a pseudo interface for configured tunnel. Details are described in <a href="https://man.freebsd.org/cgi/man.cgi?query=gif&amp;sektion=4&amp;format=html">gif(4)</a>. Currently</p></div><div class=ulist><ul><li><p>v6 in v6</p></li><li><p>v6 in v4</p></li><li><p>v4 in v6</p></li><li><p>v4 in v4</p></li></ul></div><div class=paragraph><p>are available. Use <a href="https://man.freebsd.org/cgi/man.cgi?query=gifconfig&amp;sektion=8&amp;format=html">gifconfig(8)</a> to assign physical (outer) source and destination address to gif interfaces. Configuration that uses same address family for inner and outer IP header (v4 in v4, or v6 in v6) is dangerous. It is very easy to configure interfaces and routing tables to perform infinite level of tunneling. <em>Please be warned</em>.</p></div><div class=paragraph><p>gif can be configured to be ECN-friendly. See <a href=#ipsec-ecn>23.5.4.5</a> for ECN-friendliness of tunnels, and <a href="https://man.freebsd.org/cgi/man.cgi?query=gif&amp;sektion=4&amp;format=html">gif(4)</a> for how to configure.</p></div><div class=paragraph><p>If you would like to configure an IPv4-in-IPv6 tunnel with gif interface, read <a href="https://man.freebsd.org/cgi/man.cgi?query=gif&amp;sektion=4&amp;format=html">gif(4)</a> carefully. You will need to remove IPv6 link-local address automatically assigned to the gif interface.</p></div></div><div class=sect3><h4 id=ipv6-sas>8.1.1.6. Source Address Selection<a class=anchor href=#ipv6-sas></a></h4><div class=paragraph><p>Current source selection rule is scope oriented (there are some exceptions - see below). For a given destination, a source IPv6 address is selected by the following rule:</p></div><div class="olist arabic"><ol class=arabic><li><p>If the source address is explicitly specified by the user (e.g., via the advanced API), the specified address is used.</p></li><li><p>If there is an address assigned to the outgoing interface (which is usually determined by looking up the routing table) that has the same scope as the destination address, the address is used.</p><div class=paragraph><p>This is the most typical case.</p></div></li><li><p>If there is no address that satisfies the above condition, choose a global address assigned to one of the interfaces on the sending node.</p></li><li><p>If there is no address that satisfies the above condition, and destination address is site local scope, choose a site local address assigned to one of the interfaces on the sending node.</p></li><li><p>If there is no address that satisfies the above condition, choose the address associated with the routing table entry for the destination. This is the last resort, which may cause scope violation.</p></li></ol></div><div class=paragraph><p>For instance, ::1 is selected for ff01::1, fe80:1::200:f8ff:fe01:6317 for fe80:1::2a0:24ff:feab:839b (note that embedded interface index - described in <a href=#ipv6-scope-index>23.5.1.3</a> - helps us choose the right source address. Those embedded indices will not be on the wire). If the outgoing interface has multiple address for the scope, a source is selected longest match basis (rule 3). Suppose 2001:0DB8:808:1:200:f8ff:fe01:6317 and 2001:0DB8:9:124:200:f8ff:fe01:6317 are given to the outgoing interface. 2001:0DB8:808:1:200:f8ff:fe01:6317 is chosen as the source for the destination 2001:0DB8:800::1.</p></div><div class=paragraph><p>Note that the above rule is not documented in the IPv6 spec. It is considered "up to implementation" item. There are some cases where we do not use the above rule. One example is connected TCP session, and we use the address kept in tcb as the source. Another example is source address for Neighbor Advertisement. Under the spec (RFC2461 7.2.2) NA’s source should be the target address of the corresponding NS’s target. In this case we follow the spec rather than the above longest-match rule.</p></div><div class=paragraph><p>For new connections (when rule 1 does not apply), deprecated addresses (addresses with preferred lifetime = 0) will not be chosen as source address if other choices are available. If no other choices are available, deprecated address will be used as a last resort. If there are multiple choice of deprecated addresses, the above scope rule will be used to choose from those deprecated addresses. If you would like to prohibit the use of deprecated address for some reason, configure net.inet6.ip6.use_deprecated to 0. The issue related to deprecated address is described in RFC2462 5.5.4 (NOTE: there is some debate underway in IETF ipngwg on how to use "deprecated" address).</p></div></div><div class=sect3><h4 id=ipv6-jumbo>8.1.1.7. Jumbo Payload<a class=anchor href=#ipv6-jumbo></a></h4><div class=paragraph><p>The Jumbo Payload hop-by-hop option is implemented and can be used to send IPv6 packets with payloads longer than 65,535 octets. But currently no physical interface whose MTU is more than 65,535 is supported, so such payloads can be seen only on the loopback interface (i.e., lo0).</p></div><div class=paragraph><p>If you want to try jumbo payloads, you first have to reconfigure the kernel so that the MTU of the loopback interface is more than 65,535 bytes; add the following to the kernel configuration file:</p></div><div class=paragraph><p><code>options "LARGE_LOMTU" #To test jumbo payload</code></p></div><div class=paragraph><p>and recompile the new kernel.</p></div><div class=paragraph><p>Then you can test jumbo payloads by the <a href="https://man.freebsd.org/cgi/man.cgi?query=ping6&amp;sektion=8&amp;format=html">ping6(8)</a> command with -b and -s options. The -b option must be specified to enlarge the size of the socket buffer and the -s option specifies the length of the packet, which should be more than 65,535. For example, type as follows:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ping6 <span class=nt>-b</span> 70000 <span class=nt>-s</span> 68000 ::1</code></pre></div></div><div class=paragraph><p>The IPv6 specification requires that the Jumbo Payload option must not be used in a packet that carries a fragment header. If this condition is broken, an ICMPv6 Parameter Problem message must be sent to the sender. specification is followed, but you cannot usually see an ICMPv6 error caused by this requirement.</p></div><div class=paragraph><p>When an IPv6 packet is received, the frame length is checked and compared to the length specified in the payload length field of the IPv6 header or in the value of the Jumbo Payload option, if any. If the former is shorter than the latter, the packet is discarded and statistics are incremented. You can see the statistics as output of <a href="https://man.freebsd.org/cgi/man.cgi?query=netstat&amp;sektion=8&amp;format=html">netstat(8)</a> command with `-s -p ip6' option:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% netstat <span class=nt>-s</span> <span class=nt>-p</span> ip6
	  ip6:
		<span class=o>(</span>snip<span class=o>)</span>
		1 with data size &lt; data length</code></pre></div></div><div class=paragraph><p>So, kernel does not send an ICMPv6 error unless the erroneous packet is an actual Jumbo Payload, that is, its packet size is more than 65,535 bytes. As described above, currently no physical interface with such a huge MTU is supported, so it rarely returns an ICMPv6 error.</p></div><div class=paragraph><p>TCP/UDP over jumbogram is not supported at this moment. This is because we have no medium (other than loopback) to test this. Contact us if you need this.</p></div><div class=paragraph><p>IPsec does not work on jumbograms. This is due to some specification twists in supporting AH with jumbograms (AH header size influences payload length, and this makes it real hard to authenticate inbound packet with jumbo payload option as well as AH).</p></div><div class=paragraph><p>There are fundamental issues in *BSD support for jumbograms. We would like to address those, but we need more time to finalize these. To name a few:</p></div><div class=ulist><ul><li><p>mbuf pkthdr.len field is typed as "int" in 4.4BSD, so it will not hold jumbogram with len > 2G on 32bit architecture CPUs. If we would like to support jumbogram properly, the field must be expanded to hold 4G + IPv6 header + link-layer header. Therefore, it must be expanded to at least int64_t (u_int32_t is NOT enough).</p></li><li><p>We mistakingly use "int" to hold packet length in many places. We need to convert them into larger integral type. It needs a great care, as we may experience overflow during packet length computation.</p></li><li><p>We mistakingly check for ip6_plen field of IPv6 header for packet payload length in various places. We should be checking mbuf pkthdr.len instead. ip6_input() will perform sanity check on jumbo payload option on input, and we can safely use mbuf pkthdr.len afterwards.</p></li><li><p>TCP code needs a careful update in bunch of places, of course.</p></li></ul></div></div><div class=sect3><h4 id=_loop_prevention_in_header_processing>8.1.1.8. Loop Prevention in Header Processing<a class=anchor href=#_loop_prevention_in_header_processing></a></h4><div class=paragraph><p>IPv6 specification allows arbitrary number of extension headers to be placed onto packets. If we implement IPv6 packet processing code in the way BSD IPv4 code is implemented, kernel stack may overflow due to long function call chain. sys/netinet6 code is carefully designed to avoid kernel stack overflow. Because of this, sys/netinet6 code defines its own protocol switch structure, as "struct ip6protosw" (see <span class=filename>netinet6/ip6protosw.h</span>). There is no such update to IPv4 part (sys/netinet) for compatibility, but small change is added to its pr_input() prototype. So "struct ipprotosw" is also defined. Because of this, if you receive IPsec-over-IPv4 packet with massive number of IPsec headers, kernel stack may blow up. IPsec-over-IPv6 is okay. (Off-course, for those all IPsec headers to be processed, each such IPsec header must pass each IPsec check. So an anonymous attacker will not be able to do such an attack.)</p></div></div><div class=sect3><h4 id=icmpv6>8.1.1.9. ICMPv6<a class=anchor href=#icmpv6></a></h4><div class=paragraph><p>After RFC2463 was published, IETF ipngwg has decided to disallow ICMPv6 error packet against ICMPv6 redirect, to prevent ICMPv6 storm on a network medium. This is already implemented into the kernel.</p></div></div><div class=sect3><h4 id=_applications>8.1.1.10. Applications<a class=anchor href=#_applications></a></h4><div class=paragraph><p>For userland programming, we support IPv6 socket API as specified in RFC2553, RFC2292 and upcoming Internet drafts.</p></div><div class=paragraph><p>TCP/UDP over IPv6 is available and quite stable. You can enjoy <a href="https://man.freebsd.org/cgi/man.cgi?query=telnet&amp;sektion=1&amp;format=html">telnet(1)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=ftp&amp;sektion=1&amp;format=html">ftp(1)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=rlogin&amp;sektion=1&amp;format=html">rlogin(1)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=rsh&amp;sektion=1&amp;format=html">rsh(1)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh&amp;sektion=1&amp;format=html">ssh(1)</a>, etc. These applications are protocol independent. That is, they automatically chooses IPv4 or IPv6 according to DNS.</p></div></div><div class=sect3><h4 id=_kernel_internals>8.1.1.11. Kernel Internals<a class=anchor href=#_kernel_internals></a></h4><div class=paragraph><p>While ip_forward() calls ip_output(), ip6_forward() directly calls if_output() since routers must not divide IPv6 packets into fragments.</p></div><div class=paragraph><p>ICMPv6 should contain the original packet as long as possible up to 1280. UDP6/IP6 port unreach, for instance, should contain all extension headers and the <strong>unchanged</strong> UDP6 and IP6 headers. So, all IP6 functions except TCP never convert network byte order into host byte order, to save the original packet.</p></div><div class=paragraph><p>tcp_input(), udp6_input() and icmp6_input() can not assume that IP6 header is preceding the transport headers due to extension headers. So, in6_cksum() was implemented to handle packets whose IP6 header and transport header is not continuous. TCP/IP6 nor UDP6/IP6 header structures do not exist for checksum calculation.</p></div><div class=paragraph><p>To process IP6 header, extension headers and transport headers easily, network drivers are now required to store packets in one internal mbuf or one or more external mbufs. A typical old driver prepares two internal mbufs for 96 - 204 bytes data, however, now such packet data is stored in one external mbuf.</p></div><div class=paragraph><p><code>netstat -s -p ip6</code> tells you whether or not your driver conforms such requirement. In the following example, "cce0" violates the requirement. (For more information, refer to Section 2.)</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Mbuf statistics:
                317 one mbuf
                two or more mbuf::
                        lo0 <span class=o>=</span> 8
			cce0 <span class=o>=</span> 10
                3282 one ext mbuf
                0 two or more ext mbuf</code></pre></div></div><div class=paragraph><p>Each input function calls IP6_EXTHDR_CHECK in the beginning to check if the region between IP6 and its header is continuous. IP6_EXTHDR_CHECK calls m_pullup() only if the mbuf has M_LOOP flag, that is, the packet comes from the loopback interface. m_pullup() is never called for packets coming from physical network interfaces.</p></div><div class=paragraph><p>Both IP and IP6 reassemble functions never call m_pullup().</p></div></div><div class=sect3><h4 id=ipv6-wildcard-socket>8.1.1.12. IPv4 Mapped Address and IPv6 Wildcard Socket<a class=anchor href=#ipv6-wildcard-socket></a></h4><div class=paragraph><p>RFC2553 describes IPv4 mapped address (3.7) and special behavior of IPv6 wildcard bind socket (3.8). The spec allows you to:</p></div><div class=ulist><ul><li><p>Accept IPv4 connections by AF_INET6 wildcard bind socket.</p></li><li><p>Transmit IPv4 packet over AF_INET6 socket by using special form of the address like ::ffff:10.1.1.1.</p></li></ul></div><div class=paragraph><p>but the spec itself is very complicated and does not specify how the socket layer should behave. Here we call the former one "listening side" and the latter one "initiating side", for reference purposes.</p></div><div class=paragraph><p>You can perform wildcard bind on both of the address families, on the same port.</p></div><div class=paragraph><p>The following table show the behavior of FreeBSD 4.x.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>listening side          initiating side
                <span class=o>(</span>AF_INET6 wildcard      <span class=o>(</span>connection to ::ffff:10.1.1.1<span class=o>)</span>
                socket gets IPv4 conn.<span class=o>)</span>
                <span class=nt>---</span>                     <span class=nt>---</span>
FreeBSD 4.x     configurable            supported
                default: enabled</code></pre></div></div><div class=paragraph><p>The following sections will give you more details, and how you can configure the behavior.</p></div><div class=paragraph><p>Comments on listening side:</p></div><div class=paragraph><p>It looks that RFC2553 talks too little on wildcard bind issue, especially on the port space issue, failure mode and relationship between AF_INET/INET6 wildcard bind. There can be several separate interpretation for this RFC which conform to it but behaves differently. So, to implement portable application you should assume nothing about the behavior in the kernel. Using <a href="https://man.freebsd.org/cgi/man.cgi?query=getaddrinfo&amp;sektion=3&amp;format=html">getaddrinfo(3)</a> is the safest way. Port number space and wildcard bind issues were discussed in detail on ipv6imp mailing list, in mid March 1999 and it looks that there is no concrete consensus (means, up to implementers). You may want to check the mailing list archives.</p></div><div class=paragraph><p>If a server application would like to accept IPv4 and IPv6 connections, there will be two alternatives.</p></div><div class=paragraph><p>One is using AF_INET and AF_INET6 socket (you will need two sockets). Use <a href="https://man.freebsd.org/cgi/man.cgi?query=getaddrinfo&amp;sektion=3&amp;format=html">getaddrinfo(3)</a> with AI_PASSIVE into ai_flags, and <a href="https://man.freebsd.org/cgi/man.cgi?query=socket&amp;sektion=2&amp;format=html">socket(2)</a> and <a href="https://man.freebsd.org/cgi/man.cgi?query=bind&amp;sektion=2&amp;format=html">bind(2)</a> to all the addresses returned. By opening multiple sockets, you can accept connections onto the socket with proper address family. IPv4 connections will be accepted by AF_INET socket, and IPv6 connections will be accepted by AF_INET6 socket.</p></div><div class=paragraph><p>Another way is using one AF_INET6 wildcard bind socket. Use <a href="https://man.freebsd.org/cgi/man.cgi?query=getaddrinfo&amp;sektion=3&amp;format=html">getaddrinfo(3)</a> with AI_PASSIVE into ai_flags and with AF_INET6 into ai_family, and set the 1st argument hostname to NULL. And <a href="https://man.freebsd.org/cgi/man.cgi?query=socket&amp;sektion=2&amp;format=html">socket(2)</a> and <a href="https://man.freebsd.org/cgi/man.cgi?query=bind&amp;sektion=2&amp;format=html">bind(2)</a> to the address returned. (should be IPv6 unspecified addr). You can accept either of IPv4 and IPv6 packet via this one socket.</p></div><div class=paragraph><p>To support only IPv6 traffic on AF_INET6 wildcard binded socket portably, always check the peer address when a connection is made toward AF_INET6 listening socket. If the address is IPv4 mapped address, you may want to reject the connection. You can check the condition by using IN6_IS_ADDR_V4MAPPED() macro.</p></div><div class=paragraph><p>To resolve this issue more easily, there is system dependent <a href="https://man.freebsd.org/cgi/man.cgi?query=setsockopt&amp;sektion=2&amp;format=html">setsockopt(2)</a> option, IPV6_BINDV6ONLY, used like below.</p></div><div class="literalblock programlisting"><div class=content><pre>	int on;

	setsockopt(s, IPPROTO_IPV6, IPV6_BINDV6ONLY,
		   (char *)&amp;on, sizeof (on)) &lt; 0));</pre></div></div><div class=paragraph><p>When this call succeed, then this socket only receive IPv6 packets.</p></div><div class=paragraph><p>Comments on initiating side:</p></div><div class=paragraph><p>Advise to application implementers: to implement a portable IPv6 application (which works on multiple IPv6 kernels), we believe that the following is the key to the success:</p></div><div class=ulist><ul><li><p>NEVER hardcode AF_INET nor AF_INET6.</p></li><li><p>Use <a href="https://man.freebsd.org/cgi/man.cgi?query=getaddrinfo&amp;sektion=3&amp;format=html">getaddrinfo(3)</a> and <a href="https://man.freebsd.org/cgi/man.cgi?query=getnameinfo&amp;sektion=3&amp;format=html">getnameinfo(3)</a> throughout the system. Never use gethostby*(), getaddrby*(), inet_*() or getipnodeby*(). (To update existing applications to be IPv6 aware easily, sometime getipnodeby*() will be useful. But if possible, try to rewrite the code to use <a href="https://man.freebsd.org/cgi/man.cgi?query=getaddrinfo&amp;sektion=3&amp;format=html">getaddrinfo(3)</a> and <a href="https://man.freebsd.org/cgi/man.cgi?query=getnameinfo&amp;sektion=3&amp;format=html">getnameinfo(3)</a>.)</p></li><li><p>If you would like to connect to destination, use <a href="https://man.freebsd.org/cgi/man.cgi?query=getaddrinfo&amp;sektion=3&amp;format=html">getaddrinfo(3)</a> and try all the destination returned, like <a href="https://man.freebsd.org/cgi/man.cgi?query=telnet&amp;sektion=1&amp;format=html">telnet(1)</a> does.</p></li><li><p>Some of the IPv6 stack is shipped with buggy <a href="https://man.freebsd.org/cgi/man.cgi?query=getaddrinfo&amp;sektion=3&amp;format=html">getaddrinfo(3)</a>. Ship a minimal working version with your application and use that as last resort.</p></li></ul></div><div class=paragraph><p>If you would like to use AF_INET6 socket for both IPv4 and IPv6 outgoing connection, you will need to use <a href="https://man.freebsd.org/cgi/man.cgi?query=getipnodebyname&amp;sektion=3&amp;format=html">getipnodebyname(3)</a>. When you would like to update your existing application to be IPv6 aware with minimal effort, this approach might be chosen. But please note that it is a temporal solution, because <a href="https://man.freebsd.org/cgi/man.cgi?query=getipnodebyname&amp;sektion=3&amp;format=html">getipnodebyname(3)</a> itself is not recommended as it does not handle scoped IPv6 addresses at all. For IPv6 name resolution, <a href="https://man.freebsd.org/cgi/man.cgi?query=getaddrinfo&amp;sektion=3&amp;format=html">getaddrinfo(3)</a> is the preferred API. So you should rewrite your application to use <a href="https://man.freebsd.org/cgi/man.cgi?query=getaddrinfo&amp;sektion=3&amp;format=html">getaddrinfo(3)</a>, when you get the time to do it.</p></div><div class=paragraph><p>When writing applications that make outgoing connections, story goes much simpler if you treat AF_INET and AF_INET6 as totally separate address family. {set,get}sockopt issue goes simpler, DNS issue will be made simpler. We do not recommend you to rely upon IPv4 mapped address.</p></div><div class=sect4><h5 id=_unified_tcp_and_inpcb_code>8.1.1.12.1. unified tcp and inpcb code<a class=anchor href=#_unified_tcp_and_inpcb_code></a></h5><div class=paragraph><p>FreeBSD 4.x uses shared tcp code between IPv4 and IPv6 (from sys/netinet/tcp*) and separate udp4/6 code. It uses unified inpcb structure.</p></div><div class=paragraph><p>The platform can be configured to support IPv4 mapped address. Kernel configuration is summarized as follows:</p></div><div class=ulist><ul><li><p>By default, AF_INET6 socket will grab IPv4 connections in certain condition, and can initiate connection to IPv4 destination embedded in IPv4 mapped IPv6 address.</p></li><li><p>You can disable it on entire system with sysctl like below.</p><div class=paragraph><p><code>sysctl net.inet6.ip6.mapped_addr=0</code></p></div></li></ul></div><div class=sect5><h6 id=_listening_side>8.1.1.12.1.1. Listening Side<a class=anchor href=#_listening_side></a></h6><div class=paragraph><p>Each socket can be configured to support special AF_INET6 wildcard bind (enabled by default). You can disable it on each socket basis with <a href="https://man.freebsd.org/cgi/man.cgi?query=setsockopt&amp;sektion=2&amp;format=html">setsockopt(2)</a> like below.</p></div><div class="literalblock programlisting"><div class=content><pre>	int on;

	setsockopt(s, IPPROTO_IPV6, IPV6_BINDV6ONLY,
		   (char *)&amp;on, sizeof (on)) &lt; 0));</pre></div></div><div class=paragraph><p>Wildcard AF_INET6 socket grabs IPv4 connection if and only if the following conditions are satisfied:</p></div><div class=ulist><ul><li><p>there is no AF_INET socket that matches the IPv4 connection</p></li><li><p>the AF_INET6 socket is configured to accept IPv4 traffic, i.e., getsockopt(IPV6_BINDV6ONLY) returns 0.</p></li></ul></div><div class=paragraph><p>There is no problem with open/close ordering.</p></div></div><div class=sect5><h6 id=_initiating_side>8.1.1.12.1.2. Initiating Side<a class=anchor href=#_initiating_side></a></h6><div class=paragraph><p>FreeBSD 4.x supports outgoing connection to IPv4 mapped address (::ffff:10.1.1.1), if the node is configured to support IPv4 mapped address.</p></div></div></div></div><div class=sect3><h4 id=_sockaddr_storage>8.1.1.13. sockaddr_storage<a class=anchor href=#_sockaddr_storage></a></h4><div class=paragraph><p>When RFC2553 was about to be finalized, there was discussion on how struct sockaddr_storage members are named. One proposal is to prepend "<em>" to the members (like "</em>ss_len") as they should not be touched. The other proposal was not to prepend it (like "ss_len") as we need to touch those members directly. There was no clear consensus on it.</p></div><div class=paragraph><p>As a result, RFC2553 defines struct sockaddr_storage as follows:</p></div><div class="literalblock programlisting"><div class=content><pre>	struct sockaddr_storage {
		u_char	__ss_len;	/* address length */
		u_char	__ss_family;	/* address family */
		/* and bunch of padding */
	};</pre></div></div><div class=paragraph><p>On the contrary, XNET draft defines as follows:</p></div><div class="literalblock programlisting"><div class=content><pre>	struct sockaddr_storage {
		u_char	ss_len;		/* address length */
		u_char	ss_family;	/* address family */
		/* and bunch of padding */
	};</pre></div></div><div class=paragraph><p>In December 1999, it was agreed that RFC2553bis should pick the latter (XNET) definition.</p></div><div class=paragraph><p>Current implementation conforms to XNET definition, based on RFC2553bis discussion.</p></div><div class=paragraph><p>If you look at multiple IPv6 implementations, you will be able to see both definitions. As an userland programmer, the most portable way of dealing with it is to:</p></div><div class="olist arabic"><ol class=arabic><li><p>ensure ss_family and/or ss_len are available on the platform, by using GNU autoconf,</p></li><li><p>have -Dss_family=<em>ss_family to unify all occurrences (including header file) into </em>ss_family, or</p></li><li><p>never touch __ss_family. cast to sockaddr * and use sa_family like:</p><div class="literalblock programlisting"><div class=content><pre>	struct sockaddr_storage ss;
	family = ((struct sockaddr *)&amp;ss)-&gt;sa_family</pre></div></div></li></ol></div></div></div><div class=sect2><h3 id=_network_drivers>8.1.2. Network Drivers<a class=anchor href=#_network_drivers></a></h3><div class=paragraph><p>Now following two items are required to be supported by standard drivers:</p></div><div class="olist arabic"><ol class=arabic><li><p>mbuf clustering requirement. In this stable release, we changed MINCLSIZE into MHLEN+1 for all the operating systems in order to make all the drivers behave as we expect.</p></li><li><p>multicast. If <a href="https://man.freebsd.org/cgi/man.cgi?query=ifmcstat&amp;sektion=8&amp;format=html">ifmcstat(8)</a> yields no multicast group for a interface, that interface has to be patched.</p></li></ol></div><div class=paragraph><p>If any of the drivers do not support the requirements, then the drivers cannot be used for IPv6 and/or IPsec communication. If you find any problem with your card using IPv6/IPsec, then, please report it to the <a href=https://lists.FreeBSD.org/subscription/freebsd-bugs>FreeBSD problem reports 郵遞論壇</a>.</p></div><div class=paragraph><p>(NOTE: In the past we required all PCMCIA drivers to have a call to in6_ifattach(). We have no such requirement any more)</p></div></div><div class=sect2><h3 id=_translator>8.1.3. Translator<a class=anchor href=#_translator></a></h3><div class=paragraph><p>We categorize IPv4/IPv6 translator into 4 types:</p></div><div class=ulist><ul><li><p><em>Translator A</em> --- It is used in the early stage of transition to make it possible to establish a connection from an IPv6 host in an IPv6 island to an IPv4 host in the IPv4 ocean.</p></li><li><p><em>Translator B</em> --- It is used in the early stage of transition to make it possible to establish a connection from an IPv4 host in the IPv4 ocean to an IPv6 host in an IPv6 island.</p></li><li><p><em>Translator C</em> --- It is used in the late stage of transition to make it possible to establish a connection from an IPv4 host in an IPv4 island to an IPv6 host in the IPv6 ocean.</p></li><li><p><em>Translator D</em> --- It is used in the late stage of transition to make it possible to establish a connection from an IPv6 host in the IPv6 ocean to an IPv4 host in an IPv4 island.</p></li></ul></div></div><div class=sect2><h3 id=ipsec-implementation>8.1.4. IPsec<a class=anchor href=#ipsec-implementation></a></h3><div class=paragraph><p>IPsec is mainly organized by three components.</p></div><div class="olist arabic"><ol class=arabic><li><p>Policy Management</p></li><li><p>Key Management</p></li><li><p>AH and ESP handling</p></li></ol></div><div class=sect3><h4 id=_policy_management>8.1.4.1. Policy Management<a class=anchor href=#_policy_management></a></h4><div class=paragraph><p>The kernel implements experimental policy management code. There are two way to manage security policy. One is to configure per-socket policy using <a href="https://man.freebsd.org/cgi/man.cgi?query=setsockopt&amp;sektion=2&amp;format=html">setsockopt(2)</a>. In this cases, policy configuration is described in <a href="https://man.freebsd.org/cgi/man.cgi?query=ipsec_set_policy&amp;sektion=3&amp;format=html">ipsec_set_policy(3)</a>. The other is to configure kernel packet filter-based policy using PF_KEY interface, via <a href="https://man.freebsd.org/cgi/man.cgi?query=setkey&amp;sektion=8&amp;format=html">setkey(8)</a>.</p></div><div class=paragraph><p>The policy entry is not re-ordered with its indexes, so the order of entry when you add is very significant.</p></div></div><div class=sect3><h4 id=_key_management>8.1.4.2. Key Management<a class=anchor href=#_key_management></a></h4><div class=paragraph><p>The key management code implemented in this kit (sys/netkey) is a home-brew PFKEY v2 implementation. This conforms to RFC2367.</p></div><div class=paragraph><p>The home-brew IKE daemon, "racoon" is included in the kit (kame/kame/racoon). Basically you will need to run racoon as daemon, then set up a policy to require keys (like <code>ping -P 'out ipsec esp/transport//use'</code>). The kernel will contact racoon daemon as necessary to exchange keys.</p></div></div><div class=sect3><h4 id=_ah_and_esp_handling>8.1.4.3. AH and ESP Handling<a class=anchor href=#_ah_and_esp_handling></a></h4><div class=paragraph><p>IPsec module is implemented as "hooks" to the standard IPv4/IPv6 processing. When sending a packet, ip{,6}_output() checks if ESP/AH processing is required by checking if a matching SPD (Security Policy Database) is found. If ESP/AH is needed, {esp,ah}{4,6}_output() will be called and mbuf will be updated accordingly. When a packet is received, {esp,ah}4_input() will be called based on protocol number, i.e., (*inetsw[proto])(). {esp,ah}4_input() will decrypt/check authenticity of the packet, and strips off daisy-chained header and padding for ESP/AH. It is safe to strip off the ESP/AH header on packet reception, since we will never use the received packet in "as is" form.</p></div><div class=paragraph><p>By using ESP/AH, TCP4/6 effective data segment size will be affected by extra daisy-chained headers inserted by ESP/AH. Our code takes care of the case.</p></div><div class=paragraph><p>Basic crypto functions can be found in directory "sys/crypto". ESP/AH transform are listed in {esp,ah}_core.c with wrapper functions. If you wish to add some algorithm, add wrapper function in {esp,ah}_core.c, and add your crypto algorithm code into sys/crypto.</p></div><div class=paragraph><p>Tunnel mode is partially supported in this release, with the following restrictions:</p></div><div class=ulist><ul><li><p>IPsec tunnel is not combined with GIF generic tunneling interface. It needs a great care because we may create an infinite loop between ip_output() and tunnelifp→if_output(). Opinion varies if it is better to unify them, or not.</p></li><li><p>MTU and Don’t Fragment bit (IPv4) considerations need more checking, but basically works fine.</p></li><li><p>Authentication model for AH tunnel must be revisited. We will need to improve the policy management engine, eventually.</p></li></ul></div></div><div class=sect3><h4 id=_conformance_to_rfcs_and_ids>8.1.4.4. Conformance to RFCs and IDs<a class=anchor href=#_conformance_to_rfcs_and_ids></a></h4><div class=paragraph><p>The IPsec code in the kernel conforms (or, tries to conform) to the following standards:</p></div><div class=paragraph><p>"old IPsec" specification documented in <span class=filename>rfc182[5-9].txt</span></p></div><div class=paragraph><p>"new IPsec" specification documented in <span class=filename>rfc240[1-6].txt</span>, <span class=filename>rfc241[01].txt</span>, <span class=filename>rfc2451.txt</span> and <span class=filename>draft-mcdonald-simple-ipsec-api-01.txt</span> (draft expired, but you can take from <a href=ftp://ftp.kame.net/pub/internet-drafts/>ftp://ftp.kame.net/pub/internet-drafts/</a>). (NOTE: IKE specifications, <span class=filename>rfc241[7-9].txt</span> are implemented in userland, as "racoon" IKE daemon)</p></div><div class=paragraph><p>Currently supported algorithms are:</p></div><div class=ulist><ul><li><p>old IPsec AH</p><div class=ulist><ul><li><p>null crypto checksum (no document, just for debugging)</p></li><li><p>keyed MD5 with 128bit crypto checksum (<span class=filename>rfc1828.txt</span>)</p></li><li><p>keyed SHA1 with 128bit crypto checksum (no document)</p></li><li><p>HMAC MD5 with 128bit crypto checksum (<span class=filename>rfc2085.txt</span>)</p></li><li><p>HMAC SHA1 with 128bit crypto checksum (no document)</p></li></ul></div></li><li><p>old IPsec ESP</p><div class=ulist><ul><li><p>null encryption (no document, similar to <span class=filename>rfc2410.txt</span>)</p></li><li><p>DES-CBC mode (<span class=filename>rfc1829.txt</span>)</p></li></ul></div></li><li><p>new IPsec AH</p><div class=ulist><ul><li><p>null crypto checksum (no document, just for debugging)</p></li><li><p>keyed MD5 with 96bit crypto checksum (no document)</p></li><li><p>keyed SHA1 with 96bit crypto checksum (no document)</p></li><li><p>HMAC MD5 with 96bit crypto checksum (<span class=filename>rfc2403.txt</span>)</p></li><li><p>HMAC SHA1 with 96bit crypto checksum (<span class=filename>rfc2404.txt</span>)</p></li></ul></div></li><li><p>new IPsec ESP</p><div class=ulist><ul><li><p>null encryption (<span class=filename>rfc2410.txt</span>)</p></li><li><p>DES-CBC with derived IV (<span class=filename>draft-ietf-ipsec-ciph-des-derived-01.txt</span>, draft expired)</p></li><li><p>DES-CBC with explicit IV (<span class=filename>rfc2405.txt</span>)</p></li><li><p>3DES-CBC with explicit IV (<span class=filename>rfc2451.txt</span>)</p></li><li><p>BLOWFISH CBC (<span class=filename>rfc2451.txt</span>)</p></li><li><p>CAST128 CBC (<span class=filename>rfc2451.txt</span>)</p></li><li><p>RC5 CBC (<span class=filename>rfc2451.txt</span>)</p></li><li><p>each of the above can be combined with:</p><div class=ulist><ul><li><p>ESP authentication with HMAC-MD5(96bit)</p></li><li><p>ESP authentication with HMAC-SHA1(96bit)</p></li></ul></div></li></ul></div></li></ul></div><div class=paragraph><p>The following algorithms are NOT supported:</p></div><div class=ulist><ul><li><p>old IPsec AH</p><div class=ulist><ul><li><p>HMAC MD5 with 128bit crypto checksum + 64bit replay prevention (<span class=filename>rfc2085.txt</span>)</p></li><li><p>keyed SHA1 with 160bit crypto checksum + 32bit padding (<span class=filename>rfc1852.txt</span>)</p></li></ul></div></li></ul></div><div class=paragraph><p>IPsec (in kernel) and IKE (in userland as "racoon") has been tested at several interoperability test events, and it is known to interoperate with many other implementations well. Also, current IPsec implementation as quite wide coverage for IPsec crypto algorithms documented in RFC (we cover algorithms without intellectual property issues only).</p></div></div><div class=sect3><h4 id=ipsec-ecn>8.1.4.5. ECN Consideration on IPsec Tunnels<a class=anchor href=#ipsec-ecn></a></h4><div class=paragraph><p>ECN-friendly IPsec tunnel is supported as described in <span class=filename>draft-ipsec-ecn-00.txt</span>.</p></div><div class=paragraph><p>Normal IPsec tunnel is described in RFC2401. On encapsulation, IPv4 TOS field (or, IPv6 traffic class field) will be copied from inner IP header to outer IP header. On decapsulation outer IP header will be simply dropped. The decapsulation rule is not compatible with ECN, since ECN bit on the outer IP TOS/traffic class field will be lost.</p></div><div class=paragraph><p>To make IPsec tunnel ECN-friendly, we should modify encapsulation and decapsulation procedure. This is described in <a href=http://www.aciri.org/floyd/papers/draft-ipsec-ecn-00.txt>http://www.aciri.org/floyd/papers/draft-ipsec-ecn-00.txt</a>, chapter 3.</p></div><div class=paragraph><p>IPsec tunnel implementation can give you three behaviors, by setting net.inet.ipsec.ecn (or net.inet6.ipsec6.ecn) to some value:</p></div><div class=ulist><ul><li><p>RFC2401: no consideration for ECN (sysctl value -1)</p></li><li><p>ECN forbidden (sysctl value 0)</p></li><li><p>ECN allowed (sysctl value 1)</p></li></ul></div><div class=paragraph><p>Note that the behavior is configurable in per-node manner, not per-SA manner (draft-ipsec-ecn-00 wants per-SA configuration, but it looks too much for me).</p></div><div class=paragraph><p>The behavior is summarized as follows (see source code for more detail):</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>encapsulate                     decapsulate
                <span class=nt>---</span>                             <span class=nt>---</span>
RFC2401         copy all TOS bits               drop TOS bits on outer
                from inner to outer.            <span class=o>(</span>use inner TOS bits as is<span class=o>)</span>

ECN forbidden   copy TOS bits except <span class=k>for </span>ECN    drop TOS bits on outer
                <span class=o>(</span>masked with 0xfc<span class=o>)</span> from inner   <span class=o>(</span>use inner TOS bits as is<span class=o>)</span>
                to outer.  <span class=nb>set </span>ECN bits to 0.

ECN allowed     copy TOS bits except <span class=k>for </span>ECN    use inner TOS bits with some
                CE <span class=o>(</span>masked with 0xfe<span class=o>)</span> from      change.  <span class=k>if </span>outer ECN CE bit
                inner to outer.                 is 1, <span class=nb>enable </span>ECN CE bit on
                <span class=nb>set </span>ECN CE bit to 0.            the inner.</code></pre></div></div><div class=paragraph><p>General strategy for configuration is as follows:</p></div><div class=ulist><ul><li><p>if both IPsec tunnel endpoint are capable of ECN-friendly behavior, you should better configure both end to "ECN allowed" (sysctl value 1).</p></li><li><p>if the other end is very strict about TOS bit, use "RFC2401" (sysctl value -1).</p></li><li><p>in other cases, use "ECN forbidden" (sysctl value 0).</p></li></ul></div><div class=paragraph><p>The default behavior is "ECN forbidden" (sysctl value 0).</p></div><div class=paragraph><p>For more information, please refer to:</p></div><div class=paragraph><p><a href=http://www.aciri.org/floyd/papers/draft-ipsec-ecn-00.txt>http://www.aciri.org/floyd/papers/draft-ipsec-ecn-00.txt</a>, RFC2481 (Explicit Congestion Notification), src/sys/netinet6/{ah,esp}_input.c</p></div><div class=paragraph><p>(Thanks goes to Kenjiro Cho <a href=mailto:kjc@csl.sony.co.jp>kjc@csl.sony.co.jp</a> for detailed analysis)</p></div></div><div class=sect3><h4 id=_interoperability>8.1.4.6. Interoperability<a class=anchor href=#_interoperability></a></h4><div class=paragraph><p>Here are (some of) platforms that KAME code have tested IPsec/IKE interoperability in the past. Note that both ends may have modified their implementation, so use the following list just for reference purposes.</p></div><div class=paragraph><p>Altiga, Ashley-laurent (vpcom.com), Data Fellows (F-Secure), Ericsson ACC, FreeS/WAN, HITACHI, IBM AIX®, IIJ, Intel, Microsoft® Windows NT®, NIST (linux IPsec + plutoplus), Netscreen, OpenBSD, RedCreek, Routerware, SSH, Secure Computing, Soliton, Toshiba, VPNet, Yamaha RT100i</p></div></div></div></div></div></div><hr><div class=last-modified><p><strong>最後修改於</strong>: March 9, 2024 由 <a href="https://cgit.freebsd.org/doc/commit/?id=6199af92e7" target=_blank>Danilo G. Baio</a></p></div><div class=buttons><div class=prev><i class="fa fa-angle-left" aria-hidden=true title=Prev></i><div class=container><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/sockets class=direction>Prev</a></div></div><div class=home><i class="fa fa-home" aria-hidden=true title=Home></i><div class=container><a href=../ class=direction>Home</a></div></div><div class=next><div class=container><a href=https://docs.freebsd.org/zh-tw/books/developers-handbook/partiii class=direction>Next</a></div><i class="fa fa-angle-right" aria-hidden=true title=Next></i></div></div><label class="hidden book-menu-overlay" for=menu-control></label></div><aside class=toc><div class=toc-content><h3>目錄</h3><nav id=TableOfContents><ul><li><a href=#ipv6-implementation>8.1. IPv6/IPsec Implementation</a></li></ul></nav><hr><div class=resources><h3>資源</h3><ul class=contents><li><i class="fa fa-file-pdf-o" aria-hidden=true title="下載 PDF"></i><a href=https://download.freebsd.org/doc/zh-tw/books/developers-handbook/developers-handbook_zh-tw.pdf>下載 PDF</a></li><li><i class="fa fa-pencil-square-o" aria-hidden=true title=編輯此頁></i><a href=https://github.com/freebsd/freebsd-doc/blob/main/documentation/content/zh-tw/_index target=_blank>編輯此頁</a></li></ul></div></div></aside><a class=to-top href=#top><i class="fa fa-arrow-circle-up" aria-hidden=true></i></a></main><footer><div class=footer-container><section class=logo-column><img src=https://docs.freebsd.org/images/FreeBSD-colors.svg width=160 height=50 alt="FreeBSD logo"><div class=options-container><div class=language-container><a id=languages href=https://docs.freebsd.org/zh-tw/languages><img src=https://docs.freebsd.org/images/language.png class=language-image alt=選擇語言>
<span>繁體中文</span></a></div><div class=theme-container><select id=theme-chooser><option value=theme-system>System</option><option value=theme-light>淺色</option><option value=theme-dark>深色</option><option value=theme-high-contrast>高對比</option></select></div></div></section><section class=about-column><h3 class=column-title>About</h3><ul class=column-elements-container><li><a href=https://www.freebsd.org/about/ target=_blank class=column-element>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/ target=_blank class=column-element>FreeBSD Foundation</a></li><li><a href=https://www.freebsd.org/where/ target=_blank class=column-element>Get FreeBSD</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct target=_blank class=column-element>Code of Conduct</a></li><li><a href=https://www.freebsd.org/security/ target=_blank class=column-element>Security Advisories</a></li></ul></section><section class=documentation-column><h3 class=column-title>Documentation</h3><ul class=column-elements-container><li><a href=/zh-tw class=column-element>Documentation portal</a></li><li><a href=https://man.FreeBSD.org target=_blank class=column-element>Manual pages</a></li><li><a href=https://papers.FreeBSD.org target=_blank class=column-element>Presentations and papers</a></li><li><a href=https://docs-archive.freebsd.org/doc/ target=_blank class=column-element>Previous versions</a></li><li><a href=https://docs-archive.freebsd.org/44doc/ target=_blank class=column-element>4.4BSD Documents</a></li><li><a href=https://wiki.freebsd.org/ target=_blank class=column-element>Wiki</a></li></ul></section><section class=community-column><h3 class=column-title>Community</h3><ul class=column-elements-container><li><a href=https://docs.freebsd.org/zh-tw/articles/contributing class=column-element>Get involved</a></li><li><a href=https://forums.freebsd.org/ target=_blank class=column-element>Community forum</a></li><li><a href=https://lists.freebsd.org/ target=_blank class=column-element>Mailing lists</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank class=column-element>IRC Channels</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank class=column-element>Bug Tracker</a></li></ul></section><section class=legal-column><h3 class=column-title>Legal</h3><ul class=column-elements-container><li><a href=https://freebsdfoundation.org/donate/ target=_blank class=column-element>Donations</a></li><li><a href=https://www.freebsd.org/copyright/freebsd-license/ target=_blank class=column-element>Licensing</a></li><li><a href=https://www.freebsd.org/privacy/ target=_blank class=column-element>Privacy Policy</a></li><li><a href=https://www.freebsd.org/copyright/ target=_blank class=column-element>Legal notices</a></li></ul></section><section class=copyright-column><p>&copy; 1994-2024 The FreeBSD Project. All rights reserved</p><span>Made with <span class=heart>♥</span> by the FreeBSD Community</span></section></div></footer></body></html>