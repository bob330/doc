<!doctype html><html class=theme-light lang=zh-tw><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content><meta name=keywords content><meta name=copyright content="1995-2024 The FreeBSD Foundation"><link rel=canonical href=https://docs.freebsd.org/zh-tw/books/developers-handbook/book/><title>FreeBSD Developers' Handbook | FreeBSD Documentation Portal</title>
<meta name=theme-color content="#790000"><meta name=color-scheme content="system light dark high-contrast"><link rel="shortcut icon" href=https://docs.freebsd.org/favicon.ico><link rel=stylesheet href=https://docs.freebsd.org/styles/main.min.css><link rel=stylesheet href=https://docs.freebsd.org/css/font-awesome-min.css><script defer src=/js/theme-chooser.min.js></script><script defer src=/js/copy-clipboard.min.js></script><script defer src=/js/search.min.js></script><meta name=twitter:card content="summary"><meta name=twitter:domain content="docs.FreeBSD.org"><meta name=twitter:site content="@freebsd"><meta name=twitter:url content="https://twitter.com/freebsd"><meta property="og:title" content="FreeBSD Developers' Handbook"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:image" content="https://docs.freebsd.org/favicon.ico"><meta property="og:image:alt" content="FreeBSD Logo"><meta property="og:locale" content="zh-tw"><meta property="og:url" content="https://docs.freebsd.org/zh-tw/books/developers-handbook/book/"><meta property="og:site_name" content="FreeBSD Documentation Portal"><script type=application/ld+json>{"@context":"http://schema.org","@type":"Article","url":"https:\/\/docs.freebsd.org\/zh-tw\/books\/developers-handbook\/book\/","name":"FreeBSD Documentation Portal","headline":"FreeBSD Documentation Portal","description":"FreeBSD Documentation Portal"}</script></head><body><header><div class=header-container><div class=logo-menu-bars-container><a href=https://www.FreeBSD.org class=logo><img src=https://docs.freebsd.org/images/FreeBSD-monochromatic.svg width=160 height=50 alt="FreeBSD logo">
</a><label class=menu-bars for=menu-bars><i class="fa fa-bars" aria-hidden=true></i></label></div><input id=menu-bars type=checkbox><nav><ul class=menu><li class=menu-item><input id=about type=checkbox>
<a href=# aria-label="Navigate to About section"><label class=menu-item-description for=about>About
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/about/ target=_blank>About</a></li><li><a href=https://www.freebsd.org/about/ target=_blank>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/about-us/about-the-foundation/ target=_blank>FreeBSD Foundation</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct/ target=_blank>Code of Conduct</a></li></ul></li><li class=menu-item><input id=download type=checkbox>
<a href=# aria-label="Navigate to get FreeBSD section"><label class=menu-item-description for=download>Get FreeBSD
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/where/ target=_blank>Get FreeBSD</a></li><li><a href=https://www.freebsd.org/releases/ target=_blank>Release Information</a></li><li><a href=https://www.freebsd.org/releng/ target=_blank>Release Engineering</a></li><li><a href=https://www.freebsd.org/security/ target=_blank>Security Advisories</a></li></ul></li><li class=menu-item><input id=documentation type=checkbox>
<a href=# aria-label="Navigate to get Documentation section"><label class=menu-item-description for=documentation>Documentation
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=/zh-tw>Documentation portal</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/handbook>FreeBSD Handbook</a></li><li><a href=https://docs.freebsd.org/zh-tw/books/porters-handbook>Porter's Handbook</a></li><li><a href=https://docs.FreeBSD.org/en/books/fdp-primer>Documentation Project Handbook</a></li><li><a href=https://man.FreeBSD.org target=_blank>Manual pages</a></li><li><a href=https://papers.FreeBSD.org target=_blank>Presentations and papers</a></li><li><a href=https://wiki.FreeBSD.org target=_blank>Wiki</a></li><li><a href=https://docs.freebsd.org/zh-tw/books>Books</a></li><li><a href=https://docs.freebsd.org/zh-tw/articles>Articles</a></li></ul></li><li class=menu-item><input id=community type=checkbox>
<a href=# aria-label="Navigate to get Community section"><label class=menu-item-description for=community>Community
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/community/>Community</a></li><li><a href=https://docs.freebsd.org/zh-tw/articles/contributing>Get involved</a></li><li><a href=https://forums.freebsd.org/ target=_blank>Forum</a></li><li><a href=https://lists.freebsd.org/ target=_blank>Mailing lists</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank>IRC Channels</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank>Bug Tracker</a></li><li><a href=https://www.freebsd.org/support/ target=_blank>Support</a></li></ul></li></ul></nav><div class=search-donate-container><form class=search method=get id=search-header-form action=https://docs.freebsd.org/search name=search-header-form><input type=hidden name=DB value=zh-tw>
<input id=words name=P type=text size=20 maxlength=255>
<button>
<i class="fa fa-search" aria-hidden=true></i></button></form><div class=donate><a href=https://freebsdfoundation.org/donate/ target=_blank><span class=heart>♥</span>
Donate</a></div></div></div></header><input type=checkbox class="hidden toggle" id=menu-control><main class=main-wrapper-book><a id=top></a><div class=book><h1 class=title>FreeBSD Developers' Handbook</h1><div class="admonitionblock note"><p><i class="fa fa-exclamation-circle" aria-hidden=true></i>
This translation may be out of date. To help with the translations please access the <a href=https://translate-dev.freebsd.org/ target=_blank>FreeBSD translations instance</a>.</p></div><div class=copyright>Copyright © 1995-2020 The FreeBSD Documentation Project</div><div class=legalnotice><a id=trademarks></a><details><summary>註冊商標</summary><p>FreeBSD 是 FreeBSD 基金會的註冊商標。</p><p>IBM, AIX, OS/2, PowerPC, PS/2, S/390 以及 ThinkPad 是 International Business Machines Corporation 在美國和其他國家的商標。</p><p>IEEE, POSIX 以及 802 是 Institute of Electrical and Electronics Engineers, Inc. 在美國的註冊商標。</p><p>Apple, AirPort, FireWire, iMac, iPhone, iPad, Mac, Macintosh, Mac OS, Quicktime 以及 TrueType 是 Apple Inc. 在美國以及其他國家的註冊商標。</p><p>Intel, Celeron, Centrino, Core, EtherExpress, i386, i486, Itanium, Pentium 以及 Xeon 是 Intel Corporation 及其分支機構在美國和其他國家的商標或註冊商標。</p><p>Linux 是 Linus Torvalds 的註冊商標。</p><p>Microsoft, IntelliMouse, MS-DOS, Outlook, Windows, Windows Media 以及 Windows NT 是 Microsoft Corporation 在美國和/或其他國家的商標或註冊商標。</p><p>Motif, OSF/1, 和 UNIX 是 The Open Group 在美國和其他國家的註冊商標； IT DialTone 和 The Open Group 是其商標。</p><p>Sun, Sun Microsystems, Java, Java Virtual Machine, JDK, JRE, JSP, JVM, Netra, OpenJDK, Solaris, StarOffice, SunOS 以及 VirtualBox 是 Sun Microsystems, Inc. 在美國和其他國家的商標或註冊商標。</p><p>許多製造商和經銷商使用一些稱為商標的圖案或文字設計來區別自己的產品。 本文件中出現的眾多商標，以及 FreeBSD Project 本身廣所人知的商標，後面將以 “™” 或 “®” 符號來標示。</p></details></div><div class=toc-mobile><h3>目錄</h3><nav id=TableOfContents><ul><li><a href=#basics>Part I: 基本概念</a><ul><li><a href=#introduction>Chapter 1. 簡介</a></li><li><a href=#tools>Chapter 2. 程式開發工具</a></li><li><a href=#secure>Chapter 3. Secure Programming</a></li><li><a href=#l10n>Chapter 4. Localization and Internationalization - L10N and I18N</a></li><li><a href=#policies>Chapter 5. Source Tree Guidelines and Policies</a></li><li><a href=#testing>Chapter 6. Regression and Performance Testing</a></li></ul></li><li><a href=#ipc>Part II: Interprocess Communication(IPC)</a><ul><li><a href=#sockets>Chapter 7. Sockets</a></li><li><a href=#ipv6>Chapter 8. IPv6 Internals</a></li></ul></li><li><a href=#kernel>Part III: Kernel(核心)</a><ul><li><a href=#kernelbuild>Chapter 9. Building and Installing a FreeBSD Kernel</a></li><li><a href=#kerneldebug>Chapter 10. Kernel Debugging</a></li></ul></li><li><a href=#architectures>Part IV: Architectures(電腦架構)</a><ul><li><a href=#x86>Chapter 11. x86 Assembly Language Programming</a></li></ul></li><li><a href=#appendices>Part V: Appendices</a><ul><li><a href=#bibliography>附錄</a></li></ul></li></ul></nav></div><div>[ <a href=../>Split HTML</a> / Single HTML ]</div><div class=book-content><div id=preamble><div class=sectionbody><div class="quoteblock abstract abstract-title"><blockquote>摘要</blockquote></div><div class=paragraph><p>歡迎使用 Developers' Handbook！ 這份文件是由許多人 <em>不斷撰寫</em> 而成的， 而且許多章節仍需更新或者內容還是一片空白， 如果你想幫忙 FreeBSD 文件計劃， 請寄信到 <a href=https://lists.FreeBSD.org/subscription/freebsd-doc>FreeBSD documentation project 郵遞論壇</a>。</p></div><div class=paragraph><p>最新版的文件都在 <a href=https://www.FreeBSD.org>FreeBSD 官網</a> 上面， 也可從 <a href=ftp://ftp.FreeBSD.org/pub/FreeBSD/doc/>FreeBSD FTP server</a> 下載不同格式的資料。 當然也可以在其他的 <a href=https://docs.freebsd.org/en/books/handbook/mirrors/#mirrors-ftp>mirror站</a>下載。</p></div><hr></div></div><h1 id=basics class=sect0>Part I: 基本概念<a class=anchor href=#basics></a></h1><div class=sect1><h2 id=introduction>Chapter 1. 簡介<a class=anchor href=#introduction></a></h2><div class=sectionbody><div class=sect2><h3 id=introduction-devel>1.1. 在 FreeBSD 開發程式<a class=anchor href=#introduction-devel></a></h3><div class=paragraph><p>好了我們開始吧！我想你的 FreeBSD 已經安裝好了，而且已經準備好要用它寫點程式了吧？ 但是要從哪裡開始呢？ 有提供寫程式的程式或環境嗎？ 身為 programer 的我可以做什麼呢？</p></div><div class=paragraph><p>本章試著回答你一些問題，當然，單就 programming 程度來說可分很多種層次， 有的人只是單純當興趣，有的則是他的專業， 本章主要內容是針對程式初學者， 當然，對於那些不熟 的程式開發者而言，本文件內容也是十分實用的。</p></div></div><div class=sect2><h3 id=introduction-bsdvision>1.2. The BSD Vision<a class=anchor href=#introduction-bsdvision></a></h3><div class=paragraph><p>為了讓你寫出來的程式在 like系統上具有良好的使用性、效能和穩定性， 我們必須跟你介紹一些程式概念(original software tools ideology)。</p></div></div><div class=sect2><h3 id=introduction-archguide>1.3. 程式架構指南<a class=anchor href=#introduction-archguide></a></h3><div class=paragraph><p>我們想介紹的概念如下</p></div><div class=ulist><ul><li><p>在整個程式還沒寫完前，不要增加新的功能。</p></li><li><p>另外一個重點就是，讓你自己選擇你的程式將會具有何種功能， 而不是讓別人決定，不想要去滿足全世界的需求，除非你想讓你的程式具有擴充性或相容性。</p></li><li><p>千萬記住：在沒有相關經驗時，參考範例程式碼所寫出來的程式， 會比自己憑空寫出來的好。</p></li><li><p>當你寫的程式沒辦法完全解決問題時，最好的方法就是不要試著要去解決它。</p></li><li><p>若用 10% 的心力就能輕鬆完成 90% 的工作份量，就用這個簡單法子吧。</p></li><li><p>盡可能地簡化問題的複雜。</p></li><li><p>提供機制(mechanism)，而非原則(policy)。 比方說，把使用者介面選擇權交由使用者來決定。</p></li></ul></div><div class=paragraph><p>以上摘自 Scheifler Gettys 的 "X Window System" 論文</p></div></div><div class=sect2><h3 id=introduction-layout>1.4. <span class=filename>/usr/src</span> 的架構<a class=anchor href=#introduction-layout></a></h3><div class=paragraph><p>完整的 FreeBSD 原始碼都在公開的 CVS repository 中。 通常 FreeBSD 原始碼都會裝在 <span class=filename>/usr/src</span>， 而且包含下列子目錄：</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Directory</th><th class="tableblock halign-left valign-top">Description</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>bin/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Source for files in <span class=filename>/bin</span></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>contrib/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Source for files from contributed software.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>crypto/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Cryptographical sources</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>etc/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Source for files in <span class=filename>/etc</span></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>games/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Source for files in <span class=filename>/usr/games</span></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>gnu/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Utilities covered by the GNU Public License</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>include/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Source for files in <span class=filename>/usr/include</span></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>kerberos5/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Source for Kerberos version 5</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>lib/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Source for files in <span class=filename>/usr/lib</span></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>libexec/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Source for files in <span class=filename>/usr/libexec</span></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>release/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Files required to produce a FreeBSD release</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>rescue/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Build system for the <span class=filename>/rescue</span> utilities</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>sbin/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Source for files in <span class=filename>/sbin</span></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>secure/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>FreeSec sources</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>share/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Source for files in <span class=filename>/usr/share</span></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>sys/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Kernel source files</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>tools/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Tools used for maintenance and testing of FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>usr.bin/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Source for files in <span class=filename>/usr/bin</span></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>usr.sbin/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Source for files in <span class=filename>/usr/sbin</span></p></td></tr></tbody></table></div></div></div><div class=sect1><h2 id=tools>Chapter 2. 程式開發工具<a class=anchor href=#tools></a></h2><div class=sectionbody><div class=sect2><h3 id=tools-synopsis>2.1. 概敘<a class=anchor href=#tools-synopsis></a></h3><div class=paragraph><p>本章將介紹如何使用一些 FreeBSD 所提供的程式開發工具(programing tools)， 本章所介紹的工具程式在其他版本的 上也可使用， 在此 <em>並不會</em> 嘗試描述寫程式時的每個細節， 本章大部分篇幅都是假設你以前沒有或只有少數的寫程式經驗， 不過，還是希望大多數的程式開發人員都能從中重新得到一些啟發。</p></div></div><div class=sect2><h3 id=tools-intro>2.2. 簡介<a class=anchor href=#tools-intro></a></h3><div class=paragraph><p>FreeBSD 提供一個非常棒的開發環境， 比如說像是 C、C++、Fortran 和 assembler(組合語言)的編譯器(compiler), 在 FreeBSD 中都已經包含在基本的系統中了 更別提 Perl 和其他標準 工具，像是<code>sed</code> 以及 <code>awk</code>， 如果你還是覺得不夠，FreeBSD在 Ports collection 中還提供其他的編譯器和直譯器(interpreter), FreeBSD 相容許多標準，像是 和 ANSI C， 當然還有它所繼承的 BSD 傳統。 所以在 FreeBSD 上寫的程式不需修改或頂多稍微修改，就可以在許多平台上編譯、執行。</p></div><div class=paragraph><p>無論如何，就算你從來沒在 平台上寫過程式，也可以徹底感受到FreeBSD 令人無法抗拒的迷人魔力。 本章的目標就是協助你快速上手，而暫時不需深入太多進階主題， 並且講解一些基礎概念，以讓你可以瞭解我們在講些什麼。</p></div><div class=paragraph><p>本章內容並不要求你得有程式開發經驗，或者你只有一點點的經驗而已。 不過，我們假設你已經會 系統的基本操作， 而且更重要的是，請保持樂於學習的心態！</p></div></div><div class=sect2><h3 id=tools-programming>2.3. Programming 概念<a class=anchor href=#tools-programming></a></h3><div class=paragraph><p>簡單的說，程式只是一堆指令的集合體；而這些指令是用來告訴電腦應該要作那些事情。 有時候，指令的執行取決於前一個指令的結果而定。 本章將會告訴你有 2 個主要的方法，讓你可以對電腦下達這些指示(instruction) 或 "命令(commands)"。 第一個方法就是 <em>直譯器(interpreter)</em>， 而第二個方法是 <em>編譯器(compiler)</em>。 由於對於電腦而言，人類語言的語意過於模糊而太難理解， 因此命令(commands)就常會以一種(或多種)程式語言寫成，用來指示電腦所要執行的特定動作為何。</p></div><div class=sect3><h4 id=_直譯器>2.3.1. 直譯器<a class=anchor href=#_直譯器></a></h4><div class=paragraph><p>使用直譯器時，所使用的程式語言就像變成一個會和你互動的環境。 當在命令提示列上打上命令時，直譯器會即時執行該命令。 在比較複雜的程式中，可以把所有想下達的命令統統輸入到某檔案裡面去， 然後呼叫直譯器去讀取該檔案，並且執行你寫在這個檔案中的指令。 如果所下的指令有錯誤產生，大多數的直譯器會進入偵錯模式(debugger)， 並且顯示相關錯誤訊息，以便對程式除錯。</p></div><div class=paragraph><p>這種方式好處在於：可以立刻看到指令的執行結果，以及錯誤也可迅速修正。 相對的，最大的壞處便是當你想把你寫的程式分享給其他人時，這些人必須要有跟你一樣的直譯器。 而且別忘了，他們也要會使用直譯器直譯程式才行。 當然使用者也不希望不小心按錯鍵，就進入偵錯模式而不知所措。 就執行效率而言，直譯器會使用到很多的記憶體， 而且這類直譯式程式，通常並不會比編譯器所編譯的程式的更有效率。</p></div><div class=paragraph><p>筆者個人認為，如果你之前沒有學過任何程式語言，最好先學學習直譯式語言(interpreted languages)， 像是 Lisp，Smalltalk，Perl 和 Basic 都是， 的 shell 像是 <code>sh</code> 和 <code>csh</code> 它們本身就是直譯器，事實上，很多人都在它們自己機器上撰寫各式的 shell "script"， 來順利完成各項 "housekeeping(維護)" 任務。 的使用哲學之一就是提供大量的小工具， 並使用 shell script 來組合運用這些小工具，以便工作更有效率。</p></div></div><div class=sect3><h4 id=_freebsd_提供的直譯器>2.3.2. FreeBSD 提供的直譯器<a class=anchor href=#_freebsd_提供的直譯器></a></h4><div class=paragraph><p>下面這邊有份 Ports Collection 所提供的直譯器清單，還有討論一些比較受歡迎的直譯式語言</p></div><div class=paragraph><p>至於如何使用 Ports Collection 安裝的說明，可參閱 FreeBSD Handbook 中的 <a href=https://docs.freebsd.org/en/books/handbook/ports#ports-using>Ports章節</a>。</p></div><div class=dlist><dl><dt class=hdlist1>BASIC</dt><dd><p>BASIC 是 Beginner’s ALL-purpose Symbolic Instruction Code 的縮寫。 BASIC 於 1950 年代開始發展，最初開發這套語言的目的是為了教導當時的大學學生如何寫程式。 到了 1980，BASIC已經是很多 programmer 第一個學習的程式語言了。 此外，BASIC 也是 Visual Basic 的基礎。</p><div class=paragraph><p>FreeBSD Ports Collection 也有收錄相關的 BASIC 直譯器。 Bywater Basic 直譯器放在 <a class=package href=https://cgit.freebsd.org/ports/tree/lang/bwbasic/>lang/bwbasic</a>。 而 Phil Cockroft’s Basic 直譯器(早期也叫 Rabbit Basic)放在 <a class=package href=https://cgit.freebsd.org/ports/tree/lang/pbasic/>lang/pbasic</a>。</p></div></dd><dt class=hdlist1>Lisp</dt><dd><p>LISP 是在 1950 年代開始發展的一個直譯式語言，而且 LISP 就是一種 "number-crunching" languages(迅速進行大量運算的程式語言)，在當時算是一個普遍的程式語言。 LISP 的表達不是基於數字(numbers)，而是基於表(lists)。 而最能表示出 LISP 特色的地方就在於： LISP 是 "List Processing" 的縮寫。 在人工智慧(Artificial Intelligence, AI)領域上 LISP 的各式應用非常普遍。</p><div class=paragraph><p>LISP 是非常強悍且複雜的程式語言，但是缺點是程式碼會非常大而且難以操作。</p></div><div class=paragraph><p>絕大部分的 LISP 直譯器都可以在 系統上運作，當然 的 Ports Collection 也有收錄。 GNU Common Lisp 收錄在 <a class=package href=https://cgit.freebsd.org/ports/tree/lang/gcl/>lang/gcl</a>， Bruno Haible 和 Michael Stoll 的 CLISP 收錄在 <a class=package href=https://cgit.freebsd.org/ports/tree/lang/clisp/>lang/clisp</a> ，此外 CMUCL(包含一個已經最佳化的編譯器)， 以及其他簡化版的 LISP 直譯器(比如以 C 語言寫的 SLisp，只用幾百行程式碼就實作大多數 Common Lisp 的功能) 則是分別收錄在 <a class=package href=https://cgit.freebsd.org/ports/tree/lang/cmucl/>lang/cmucl</a> 以及 <a class=package href=https://cgit.freebsd.org/ports/tree/lang/slisp/>lang/slisp</a>。</p></div></dd><dt class=hdlist1>Perl</dt><dd><p>對系統管理者而言，最愛用 perl 來撰寫 scripts 以管理主機， 同時也經常用來寫 WWW 主機上的 CGI Script 程式。</p><div class=paragraph><p>Perl 在 Ports Collection 內的 <a class=package href=https://cgit.freebsd.org/ports/tree/lang/perl5/>lang/perl5</a>。 而 4.X 則是把 Perl 裝在 <code>/usr/bin/perl</code>。</p></div></dd><dt class=hdlist1>Scheme</dt><dd><p>Scheme 是 LISP 的另一分支，Scheme 的特點就是比 Common LISP 還要簡潔有力。 由於 Scheme 簡單，所以很多大學拿來當作第一堂程式語言教學教材。 而且對於研究人員來說也可以快速的開發他們所需要的程式。</p><div class=paragraph><p>Scheme 收錄在 <a class=package href=https://cgit.freebsd.org/ports/tree/lang/elk/>lang/elk</a>， Elk Scheme 直譯器(由麻省理工學院所發展的 Scheme 直譯器)收錄在 <a class=package href=https://cgit.freebsd.org/ports/tree/lang/mit-scheme/>lang/mit-scheme</a>， SCM Scheme Interpreter 收錄在 <a class=package href=https://cgit.freebsd.org/ports/tree/lang/scm/>lang/scm</a>。</p></div></dd><dt class=hdlist1>Icon</dt><dd><p>Icon 屬高階程式語言，Icon 具有強大的字串(String)和結構(Structure)處理能力。 Ports Collection 所收錄的 Icon 直譯器版本則是放在 <a class=package href=https://cgit.freebsd.org/ports/tree/lang/icon/>lang/icon</a>。</p></dd><dt class=hdlist1>Logo</dt><dd><p>Logo 是種容易學習的程式語言，最常在一些教學課程中被拿來當作開頭範例。 如果要給小朋友開始上程式語言課的話，Logo 是相當不錯的選擇。 因為，即使對小朋友來說，要用 Logo 來秀出複雜多邊形圖形是相當輕鬆容易的。</p><div class=paragraph><p>Logo 在 Ports Collection 的最新版則是放在 <a class=package href=https://cgit.freebsd.org/ports/tree/lang/logo/>lang/logo</a>。</p></div></dd><dt class=hdlist1>Python</dt><dd><p>Python 是物件導向的直譯式語言， Python 的擁護者總是宣稱 Python 是最好入門的程式語言。 雖然 Python 可以很簡單的開始，但是不代表它就會輸給其他直譯式語言(像是 Perl 和 Tcl)， 事實證明 Python 也可以拿來開發大型、複雜的應用程式。</p><div class=paragraph><p>Ports Collection 收錄在 <a class=package href=https://cgit.freebsd.org/ports/tree/lang/python/>lang/python</a>。</p></div></dd><dt class=hdlist1>Ruby</dt><dd><p>Ruby 是純物件導向的直譯式語言。 Ruby 目前非常流行，原因在於他易懂的程式語法結構，在撰寫程式時的彈性， 以及天生具有輕易的發展維護大型專案的能力。</p><div class=paragraph><p>Ports Collection 收錄在 <a class=package href=https://cgit.freebsd.org/ports/tree/lang/ruby8/>lang/ruby8</a>。</p></div></dd><dt class=hdlist1>Tcl and Tk</dt><dd><p>Tcl 是內嵌式的直譯式語言，讓 Tcl 可以如此廣泛運用的原因是 Tcl 的移植性。 Tcl 也可以快速發展一個簡單但是具有雛型的程式或者具有完整功能的程式。</p><div class=paragraph><p>Tcl 許多的版本都可在 上運作，而最新的 Tcl 版本為 Tcl 8.4， Ports Collection 收錄在 <a class=package href=https://cgit.freebsd.org/ports/tree/lang/tcl84/>lang/tcl84</a>。</p></div></dd></dl></div></div><div class=sect3><h4 id=_編譯器>2.3.3. 編譯器<a class=anchor href=#_編譯器></a></h4><div class=paragraph><p>編譯器和直譯器兩者相比的話，有些不同，首先就是必須先把程式碼統統寫入到檔案裡面， 然後必須執行編譯器來試著編譯程式，如果編譯器不接受所寫的程式，那就必須一直修改程式， 直到編譯器接受且把你的程式編譯成執行檔。 此外，也可以在提示命令列，或在除錯器中執行你編譯好的程式看看它是否可以運作。</p></div><div class=paragraph><p>很明顯的，使用編譯器並不像直譯器般可以馬上得到結果。 不管如何，編譯器允許你作很多直譯器不可能或者是很難達到的事情。 例如：撰寫和作業系統密切互動的程式，甚至是你自己寫的作業系統！ 當你想要寫出高效率的程式時，編譯器便派上用場了。 編譯器可以在編譯時順便最佳化你的程式，但是直譯器卻不行。 而編譯器與直譯器最大的差別在於：當你想把你寫好的程式拿到另外一台機器上跑時， 你只要將編譯器編譯出來的可執行檔，拿到新機器上便可以執行， 而直譯器則必須要求新機器上，必須要有跟另一台機器上相同的直譯器， 才能組譯執行你的程式！</p></div><div class=paragraph><p>編譯式的程式語言包含 Pascal、C 和 c++， C 和 c++ 不是一個親和力十足的語言，但是很適合具有經驗的 Programmer。 Pascal 其實是一個設計用來教學用的程式語言，而且也很適合用來入門， 預設並沒有把 Pascal 整合進 base system 中， 但是 GNU Pascal Compiler 和 Free Pascal Compiler 都可分別在 <a class=package href=https://cgit.freebsd.org/ports/tree/lang/gpc/>lang/gpc</a> 和 <a class=package href=https://cgit.freebsd.org/ports/tree/lang/fpc/>lang/fpc</a> 中找到。</p></div><div class=paragraph><p>如果你用不同的程式來寫編譯式程式，那麼不斷地編輯-編譯-執行-除錯的這個循環肯定會很煩人， 為了更簡化、方便程式開發流程，很多商業編譯器廠商開始發展所謂的 IDE (Integrated Development Environments) 開發環境， FreeBSD 預設並沒有把 IDE 整合進 base system 中， 但是你可透過 <a class=package href=https://cgit.freebsd.org/ports/tree/devel/kdevelop/>devel/kdevelop</a> 安裝 kdevelop 或使用 Emacs 來體驗 IDE 開發環境。 在後面的 <a href=#emacs>Using Emacs as a Development Environment</a> 專題將介紹，如何以 Emacs 來作為 IDE 開發環境。</p></div></div></div><div class=sect2><h3 id=tools-compiling>2.4. 用 <code>cc</code> 來編譯程式<a class=anchor href=#tools-compiling></a></h3><div class=paragraph><p>本章範例只有針對 GNU C compiler 和 GNU C++ compiler 作說明， 這兩個在 FreeBSD base system 中就有了， 直接打 <code>cc</code> 或 <code>gcc</code> 就可以執行。 至於，如何用直譯器產生程式的說明，通常可在直譯器的文件或線上文件找到說明，因此不再贅述。</p></div><div class=paragraph><p>當你寫完你的傑作後，接下來便是讓這個程式可以在 FreeBSD 上執行， 通常這些要一些步驟才能完成，有些步驟則需要不同程式來完成。</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>預先處理(Pre-process)你的程式碼，移除程式內的註解，和其他技巧， 像是 expanding(擴大) C 的 marco。</p></li><li><p>確認你的程式語法是否確實遵照 C/C++ 的規定，如果沒有符合的話，編譯器會出現警告。</p></li><li><p>將原始碼轉成組合語言 它跟機器語言(machine code)非常相近，但仍在人類可理解的範圍內(據說應該是這樣)。</p></li><li><p>把組合語言轉成機器語言 是的，這裡說的機器語言就是常提到的 bit 和 byte，也就是 1 和 0。</p></li><li><p>確認程式中用到的函式呼叫、全域變數是否正確，舉例來說：如若呼叫了不存在的函式，編譯器會顯示警告。</p></li><li><p>如果程式是由程式碼檔案來編譯，編譯器會整合起來。</p></li><li><p>編譯器會負責產生東西，讓系統上的 run-time loader 可以把程式載入記憶體內執行。</p></li><li><p>最後會把編譯完的執行檔存在硬碟上。</p></li></ol></div></div></div><div class=paragraph><p>通常 <em>編譯(compiling)</em> 是指第 1 到第 4 個步驟。 其他步驟則稱為 <em>連結(linking)</em>， 有時候步驟 1 也可以是指 <em>預先處理(pre-processing)</em>， 而步驟 3 到步驟 4 則是 <em>組譯(assembling)</em>。</p></div><div class=paragraph><p>幸運的是，你可以不用理會以上細節，編譯器都會自動完成。 因為 <code>cc</code> 只是是個前端程式(front end)，它會依照正確的參數來呼叫相關程式幫你處理。 只需打：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% cc foobar.c</code></pre></div></div><div class=paragraph><p>上述指令會把 <span class=filename>foobar.c</span> 開始編譯，並完成上述動作。 如果你有許多檔案需要編譯，那請打類似下列指令即可：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% cc foo.c bar.c</code></pre></div></div><div class=paragraph><p>記住語法錯誤檢查就是 純粹檢查語法錯誤與否， 而不會幫你檢測任何邏輯錯誤，比如：無限迴圈，或是排序方式想用 binary sort 卻弄成 bubble sort。</p></div><div class=paragraph><p><code>cc</code> 有非常多的選項，都可透過線上手冊來查。 下面只提一些必要且重要的選項，以作為例子。</p></div><div class=dlist><dl><dt class=hdlist1><code>-o <em>檔名</em></code></dt><dd><p><code>-o</code> 編譯後的執行檔檔名，如果沒有使用這選項的話， 編譯好的程式預設檔名將會是 <span class=filename>a.out</span></p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% cc foobar.c               執行檔就是 a.out
% cc <span class=nt>-o</span> foobar foobar.c     執行檔就是 foobar</code></pre></div></div></dd><dt class=hdlist1><code>-c</code></dt><dd><p>使用 <code>-c</code> 時，只會編譯原始碼，而不作連結(linking)。 當只想確認語法是否正確或使用 Makefile 來編譯程式時，這個選項非常有用。</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> % cc <span class=nt>-c</span> foobar.c</code></pre></div></div><div class=paragraph><p>這會產生叫做 <span class=filename>foobar</span> 的 <em>object file</em>(非執行檔)。 這檔可以與其他的 object file 連結在一起，而成執行檔。</p></div></dd><dt class=hdlist1><code>-g</code></dt><dd><p><code>-g</code> 將會把一些給 gdb 用的除錯訊息包進去執行檔裡面，所謂的除錯訊息例如： 程式在第幾行出錯、那個程式第幾行做什麼函式呼叫等等。除錯資訊<em>非常</em>好用。 但缺點就是：對於程式來說，額外的除錯訊息會讓編譯出來的程式比較肥些。 <code>-g</code> 的適用時機在於：當程式還在開發時使用就好， 而當你要釋出你的 "發行版本(release version)" 或者確認程式可運作正常的話，就不必用 <code>-g</code> 這選項了。</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% cc <span class=nt>-g</span> foobar.c</code></pre></div></div><div class=paragraph><p>這動作會產生有含除錯訊息的執行檔。</p></div></dd><dt class=hdlist1><code>-O</code></dt><dd><p><code>-O</code> 會產生最佳化的執行檔， 編譯器會使用一些技巧，來讓程式可以跑的比未經最佳化的程式還快， 可以在大寫 O 後面加上數字來指明想要的最佳化層級。 但是最佳化還是會有一些錯誤，舉例來說在 FreeBSD 2.10 release 中用 <code>cc</code> 且指定 <code>-O2</code> 時，在某些情形下會產生錯誤的執行檔。</p><div class=paragraph><p>只有當要釋出發行版本、或者加速程式時，才需要使用最佳化選項。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% cc <span class=nt>-O</span> <span class=nt>-o</span> foobar foobar.c</code></pre></div></div><div class=paragraph><p>這會產生 <span class=filename>foobar</span> 執行檔的最佳化版本。</p></div></dd></dl></div><div class=paragraph><p>以下三個參數將會強迫 <code>cc</code> 確認程式碼是否符合一些國際標準的規範， 也就是通常說的 ANSI 標準， 而 ANSI 嚴格來講屬 ISO 標準。</p></div><div class=dlist><dl><dt class=hdlist1><code>-Wall</code></dt><dd><p><code>-Wall</code> 顯示 <code>cc</code> 維護者所認為值得注意的所有警告訊息。 不過這名字可能會造成誤解，事實上它並未完全顯示 <code>cc</code> 所能注意到的各項警告訊息。</p></dd><dt class=hdlist1><code>-ansi</code></dt><dd><p><code>-ansi</code> 關閉 <code>cc</code> 特有的某些特殊非 ANSI C 標準功能。 不過這名字可能會造成誤解，事實上它並不保證你的程式會完全符合 ANSI 標準。</p></dd><dt class=hdlist1><code>-pedantic</code></dt><dd><p>全面關閉 <code>cc</code> 所特有的非 ANSI C 標準功能。</p></dd></dl></div><div class=paragraph><p>除了這些參數，<code>cc</code> 還允許你使用一些額外的參數取代標準參數，有些額外參數非常有用， 但是實際上並不是所有的編譯器都有提供這些參數。 照標準來寫程式的最主要目的就是，希望你寫出來的程式可以在所有編譯器上編譯、執行無誤， 當程式可以達成上述目的時，就稱為 <em>portable code(移植性良好的程式碼)</em>。</p></div><div class=paragraph><p>一般來說，在撰寫程式時就應要注意『移植性』。 否則。當想把程式拿到另外一台機器上跑的時候，就可能得需要重寫程式。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% cc <span class=nt>-Wall</span> <span class=nt>-ansi</span> <span class=nt>-pedantic</span> <span class=nt>-o</span> foobar foobar.c</code></pre></div></div><div class=paragraph><p>上述指令會確認 <span class=filename>foobar.c</span> 內的語法是否符合標準， 並且產生名為 <span class=filename>foobar</span> 的執行檔。</p></div><div class=dlist><dl><dt class=hdlist1><code>-l <em>library</em></code></dt><dd><p>告訴 gcc 在連結(linking)程式時你需要用到的函式庫名稱。</p><div class=paragraph><p>最常見的情況就是，當你在程式中使用了 C 數學函式庫， 跟其他作業平台不一樣的是，這函示學函式都不在標準函式庫(library)中， 因此編譯器並不知道這函式庫名稱，你必須告訴編譯器要加上它才行。</p></div><div class=paragraph><p>規則很簡單，如果有個函式庫叫做 <span class=filename>libsomething.a</span>， 就必須在編譯時加上參數 <code>-l <em>something</em></code> 才行。 舉例來說，數學函式庫叫做 <span class=filename>libm.a</span>， 所以你必須給 <code>cc</code> 的參數就是 <code>-lm</code>。 一般情況下，通常會把這參數必須放在指令的最後。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% cc <span class=nt>-o</span> foobar foobar.c <span class=nt>-lm</span></code></pre></div></div><div class=paragraph><p>上面這指令會讓 gcc 跟數學函式庫作連結，以便你的程式可以呼叫函式庫內含的數學函式。</p></div><div class=paragraph><p>如果你正在編譯的程式是 C++ 程式碼，你還必須額外指定 -lg++ 或者是 -lstdc++。 如果你的 FreeBSD 是 2.2(含)以後版本， 你可以用指令 c++ 來取代 <code>cc</code>。 在 FreeBSD 上 c++ 也可以用 g++ 取代。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% cc <span class=nt>-o</span> foobar foobar.cc <span class=nt>-lg</span>++     適用 FreeBSD 2.1.6 或更早期的版本
% cc <span class=nt>-o</span> foobar foobar.cc <span class=nt>-lstdc</span>++  適用 FreeBSD 2.2 及之後的版本
% c++ <span class=nt>-o</span> foobar foobar.cc</code></pre></div></div><div class=paragraph><p>上述指令都會從原始檔 <span class=filename>foobar.cc</span> 編譯產生名為 <span class=filename>fooboar</span> 的執行檔。 這邊要提醒的是在 系統中 c++ 程式傳統都以 <span class=filename>.C</span>、 <span class=filename>.cxx</span> 或者是 <span class=filename>.cc</span> 作為副檔名， 而非 那種以 <span class=filename>.cpp</span> 作為副檔名的命名方式(不過也越來越普遍了)。 <code>gcc</code> 會依副檔名來決定用哪一種編譯器編譯， 然而，現在已經不再限制副檔名了， 所以可以自由的使用 <span class=filename>.cpp</span> 作為 c++ 程式碼的副檔名！</p></div></dd></dl></div><div class=sect3><h4 id=_常見的_cc_問題>2.4.1. 常見的 <code>cc</code> 問題<a class=anchor href=#_常見的_cc_問題></a></h4><div class=sect4><h5 id=_我用_sin_函示撰寫我的程式_但是有個錯誤訊息如下這代表著>2.4.1.1. 我用 sin() 函示撰寫我的程式， 但是有個錯誤訊息(如下)，這代表著？<a class=anchor href=#_我用_sin_函示撰寫我的程式_但是有個錯誤訊息如下這代表著></a></h5><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>/var/tmp/cc0143941.o: Undefined symbol <span class=sb>`</span>_sin<span class=s1>&#39; referenced from text segment</span></code></pre></div></div><div class=paragraph><p>當使用 <code>sin()</code> 這類的數學函示時， 你必須告訴 cc 要和數學函式庫作連結(linking)，就像這樣：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% cc temp.c <span class=nt>-lm</span></code></pre></div></div></div><div class=sect4><h5 id=_好吧我試著寫些簡單的程式來練習使用_lm_選項該程式會運算_2_1_的_6_次方>2.4.1.2. 好吧，我試著寫些簡單的程式，來練習使用 -lm 選項(該程式會運算 2.1 的 6 次方)<a class=anchor href=#_好吧我試著寫些簡單的程式來練習使用_lm_選項該程式會運算_2_1_的_6_次方></a></h5><div class=paragraph><p>當編譯器發現你呼叫一個函示時，它會確認該函示的回傳值類型(prototype)， 如果沒有特別指明，則預設的回傳值類型為 <span class=type>int(整數)</span>。 很明顯的，你的程式所需要的並不是回傳值類別為 <span class=type>int</span>。</p></div></div><div class=sect4><h5 id=_那如何才可以修正剛所說的問題>2.4.1.3. 那如何才可以修正剛所說的問題？<a class=anchor href=#_那如何才可以修正剛所說的問題></a></h5><div class=paragraph><p>數學函示的回傳值類型(prototype)會定義在 <span class=filename>math.h</span>， 如果你有 include 這檔，編譯器就會知道該函示的回傳值類型，如此一來該運算就會得到正確的結果！</p></div><div class="literalblock programlisting"><div class=content><pre>#include &lt;stdio.h&gt;

int main() {
	float f;

	f = pow(2.1, 6);
	printf(&#34;2.1 ^ 6 = %f\n&#34;, f);
	return 0;
}</pre></div></div><div class=paragraph><p>編譯後執行程式，得到下面這結果：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% cc temp.c <span class=nt>-lm</span></code></pre></div></div><div class=paragraph><p>加了上述內容之後，再重新編譯，最後執行：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ./a.out
2.1 ^ 6 <span class=o>=</span> 85.766121</code></pre></div></div><div class=paragraph><p>如果有用到數學函式，<em>請確定</em>要有 include <span class=filename>math.h</span> 這檔， 而且記得要和數學函式庫作連結。</p></div></div><div class=sect4><h5 id=_已經編譯好_foobar_c_但是編譯後找不到_foobar_執行檔_該去哪邊找呢>2.4.1.4. 已經編譯好 foobar.c， 但是編譯後找不到 foobar 執行檔。 該去哪邊找呢？<a class=anchor href=#_已經編譯好_foobar_c_但是編譯後找不到_foobar_執行檔_該去哪邊找呢></a></h5><div class=paragraph><p>記得，除非有指定編譯結果的執行檔檔名，否則預設的執行檔檔名是 a.out。 用 <code>-o <em>filename</em></code> 參數， 就可以達到所想要的結果，比如：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% cc <span class=nt>-o</span> foobar foobar.c</code></pre></div></div></div><div class=sect4><h5 id=_好有個編譯好的程式叫做_foobar_用_ls_指令時可以看到_但執行時訊息卻說卻沒有這檔案為什麼>2.4.1.5. 好，有個編譯好的程式叫做 foobar， 用 ls 指令時可以看到， 但執行時，訊息卻說卻沒有這檔案。為什麼？<a class=anchor href=#_好有個編譯好的程式叫做_foobar_用_ls_指令時可以看到_但執行時訊息卻說卻沒有這檔案為什麼></a></h5><div class=paragraph><p>與 不同的是，除非有指定執行檔的路徑， 否則 系統並不會在目前的目錄下尋找你想執行的檔案。 在指令列下打 <code>./foobar</code> 代表 "執行在這個目錄底下名為 <span class=filename>foobar</span> 的程式"， 或者也可以更改 <code>PATH</code> 環境變數設定如下，以達成類似效果：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>bin:/usr/bin:/usr/local/bin:.</code></pre></div></div><div class=paragraph><p>上一行最後的 "." 代表"如果在前面寫的其他目錄找不到，就找目前的目錄"。</p></div></div><div class=sect4><h5 id=_試著執行_test_執行檔_但是卻沒有任何事發生到底是哪裡出錯了>2.4.1.6. 試著執行 test 執行檔， 但是卻沒有任何事發生，到底是哪裡出錯了？<a class=anchor href=#_試著執行_test_執行檔_但是卻沒有任何事發生到底是哪裡出錯了></a></h5><div class=paragraph><p>大多數的 系統都會在路徑 <span class=filename>/usr/bin</span> 擺放執行檔。 除非有指定使用在目前目錄內的 <span class=filename>test</span>，否則 shell 會優先選擇位在 <span class=filename>/usr/bin</span> 的 <span class=filename>test</span>， 要指定檔名的話，作法類似：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ./test</code></pre></div></div><div class=paragraph><p>為了避免上述困擾，請為你的程式取更好的名稱吧！</p></div></div><div class=sect4><h5 id=_當執行我寫的程式時剛開始正常_接下來卻出現_core_dumped_錯誤訊息這錯誤訊息到底代表什麼>2.4.1.7. 當執行我寫的程式時剛開始正常， 接下來卻出現 core dumped 錯誤訊息。這錯誤訊息到底代表什麼？<a class=anchor href=#_當執行我寫的程式時剛開始正常_接下來卻出現_core_dumped_錯誤訊息這錯誤訊息到底代表什麼></a></h5><div class=paragraph><p>關於 <em>core dumped</em> 這個名稱的由來， 可以追溯到早期的 系統開始使用 core memory 對資料排序時。 基本上當程式在很多情況下發生錯誤後， 作業系統會把 core memory 中的資訊寫入 <span class=filename>core</span> 這檔案中， 以便讓 programmer 知道程式到底是為何出錯。</p></div></div><div class=sect4><h5 id=_真是太神奇了程式居然發生_core_dumped_了該怎麼辦>2.4.1.8. 真是太神奇了！程式居然發生 core dumped 了，該怎麼辦？<a class=anchor href=#_真是太神奇了程式居然發生_core_dumped_了該怎麼辦></a></h5><div class=paragraph><p>請用 <code>gdb</code> 來分析 core 結果(詳情請參考 <a href=#debugging>Debugging</a>)。</p></div></div><div class=sect4><h5 id=_當程式已經把_core_memory_資料_dump_出來後_同時也出現另一個錯誤_segmentation_fault_這意思是>2.4.1.9. 當程式已經把 core memory 資料 dump 出來後， 同時也出現另一個錯誤 segmentation fault 這意思是？<a class=anchor href=#_當程式已經把_core_memory_資料_dump_出來後_同時也出現另一個錯誤_segmentation_fault_這意思是></a></h5><div class=paragraph><p>基本上，這個錯誤表示你的程式在記憶體中試著做一個嚴重的非法運作(illegal operation)， 就是被設計來保護整個作業系統免於被惡質的程式破壞，所以才會告訴你這個訊息。</p></div><div class=paragraph><p>最常造成"segmentation fault"的原因通常為：</p></div><div class=ulist><ul><li><p>試著對一個 NULL 的指標(pointer)作寫入的動作，如</p><div class="literalblock programlisting"><div class=content><pre>char *foo = NULL;
strcpy(foo, &#34;bang!&#34;);</pre></div></div></li><li><p>使用一個尚未初始化(initialized)的指標，如：</p><div class="literalblock programlisting"><div class=content><pre>char *foo;
strcpy(foo, &#34;bang!&#34;);</pre></div></div><div class=paragraph><p>尚未初始化的指標的初始值將會是隨機的，如果你夠幸運的話， 這個指標的初始值會指向 kernel 已經用到的記憶體位置， kernel 會結束掉這個程式以確保系統運作正常。如果你不夠幸運， 初始指到的記憶體位置是你程式必須要用到的資料結構(data structures)的位置， 當這個情形發生時程式將會當的不知其所以然。</p></div></li><li><p>試著寫入超過陣列(array)元素個數，如：</p><div class="literalblock programlisting"><div class=content><pre>int bar[20];
bar[27] = 6;</pre></div></div></li><li><p>試著讀寫在唯讀記憶體(read-only memory)中的資料，如：</p><div class="literalblock programlisting"><div class=content><pre>char *foo = &#34;My string&#34;;
strcpy(foo, &#34;bang!&#34;);</pre></div></div><div class=paragraph><p>UNIX® compilers often put string literals like <code>"My string"</code> into read-only areas of memory.</p></div></li><li><p>Doing naughty things with <code>malloc()</code> and <code>free()</code>, eg</p><div class="literalblock programlisting"><div class=content><pre>char bar[80];
free(bar);</pre></div></div><div class=paragraph><p>or</p></div><div class="literalblock programlisting"><div class=content><pre>char *foo = malloc(27);
free(foo);
free(foo);</pre></div></div></li></ul></div><div class=paragraph><p>Making one of these mistakes will not always lead to an error, but they are always bad practice. Some systems and compilers are more tolerant than others, which is why programs that ran well on one system can crash when you try them on an another.</p></div></div><div class=sect4><h5 id=_sometimes_when_i_get_a_core_dump_it_says_bus_error_it_says_in_my_unix_book_that_this_means_a_hardware_problem_but_the_computer_still_seems_to_be_working_is_this_true>2.4.1.10. Sometimes when I get a core dump it says bus error. It says in my UNIX® book that this means a hardware problem, but the computer still seems to be working. Is this true?<a class=anchor href=#_sometimes_when_i_get_a_core_dump_it_says_bus_error_it_says_in_my_unix_book_that_this_means_a_hardware_problem_but_the_computer_still_seems_to_be_working_is_this_true></a></h5><div class=paragraph><p>No, fortunately not (unless of course you really do have a hardware problem…​). This is usually another way of saying that you accessed memory in a way you should not have.</p></div></div><div class=sect4><h5 id=_this_dumping_core_business_sounds_as_though_it_could_be_quite_useful_if_i_can_make_it_happen_when_i_want_to_can_i_do_this_or_do_i_have_to_wait_until_there_is_an_error>2.4.1.11. This dumping core business sounds as though it could be quite useful, if I can make it happen when I want to. Can I do this, or do I have to wait until there is an error?<a class=anchor href=#_this_dumping_core_business_sounds_as_though_it_could_be_quite_useful_if_i_can_make_it_happen_when_i_want_to_can_i_do_this_or_do_i_have_to_wait_until_there_is_an_error></a></h5><div class=paragraph><p>Yes, just go to another console or xterm, do</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ps</code></pre></div></div><div class=paragraph><p>to find out the process ID of your program, and do</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>kill</span> <span class=nt>-ABRT</span> pid</code></pre></div></div><div class=paragraph><p>where <code><em>pid</em></code> is the process ID you looked up.</p></div><div class=paragraph><p>This is useful if your program has got stuck in an infinite loop, for instance. If your program happens to trap SIGABRT, there are several other signals which have a similar effect.</p></div><div class=paragraph><p>Alternatively, you can create a core dump from inside your program, by calling the <code>abort()</code> function. See the manual page of <a href="https://man.freebsd.org/cgi/man.cgi?query=abort&amp;sektion=3&amp;format=html">abort(3)</a> to learn more.</p></div><div class=paragraph><p>If you want to create a core dump from outside your program, but do not want the process to terminate, you can use the <code>gcore</code> program. See the manual page of <a href="https://man.freebsd.org/cgi/man.cgi?query=gcore&amp;sektion=1&amp;format=html">gcore(1)</a> for more information.</p></div></div></div></div><div class=sect2><h3 id=tools-make>2.5. Make<a class=anchor href=#tools-make></a></h3><div class=sect3><h4 id=_what_is_make>2.5.1. What is <code>make</code>?<a class=anchor href=#_what_is_make></a></h4><div class=paragraph><p>When you are working on a simple program with only one or two source files, typing in</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% cc file1.c file2.c</code></pre></div></div><div class=paragraph><p>is not too bad, but it quickly becomes very tedious when there are several files-and it can take a while to compile, too.</p></div><div class=paragraph><p>One way to get around this is to use object files and only recompile the source file if the source code has changed. So we could have something like:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% cc file1.o file2.o … file37.c …</code></pre></div></div><div class=paragraph><p>if we had changed <span class=filename>file37.c</span>, but not any of the others, since the last time we compiled. This may speed up the compilation quite a bit, but does not solve the typing problem.</p></div><div class=paragraph><p>Or we could write a shell script to solve the typing problem, but it would have to re-compile everything, making it very inefficient on a large project.</p></div><div class=paragraph><p>What happens if we have hundreds of source files lying about? What if we are working in a team with other people who forget to tell us when they have changed one of their source files that we use?</p></div><div class=paragraph><p>Perhaps we could put the two solutions together and write something like a shell script that would contain some kind of magic rule saying when a source file needs compiling. Now all we need now is a program that can understand these rules, as it is a bit too complicated for the shell.</p></div><div class=paragraph><p>This program is called <code>make</code>. It reads in a file, called a <em>makefile</em>, that tells it how different files depend on each other, and works out which files need to be re-compiled and which ones do not. For example, a rule could say something like "if <span class=filename>fromboz.o</span> is older than <span class=filename>fromboz.c</span>, that means someone must have changed <span class=filename>fromboz.c</span>, so it needs to be re-compiled." The makefile also has rules telling make <em>how</em> to re-compile the source file, making it a much more powerful tool.</p></div><div class=paragraph><p>Makefiles are typically kept in the same directory as the source they apply to, and can be called <span class=filename>makefile</span>, <span class=filename>Makefile</span> or <span class=filename>MAKEFILE</span>. Most programmers use the name <span class=filename>Makefile</span>, as this puts it near the top of a directory listing, where it can easily be seen.<sup class=footnote>[<a id=_footnoteref_1 class=footnote href=#_footnotedef_1 title="View footnote.">1</a>]</sup></p></div></div><div class=sect3><h4 id=_example_of_using_make>2.5.2. Example of Using <code>make</code><a class=anchor href=#_example_of_using_make></a></h4><div class=paragraph><p>Here is a very simple make file:</p></div><div class="literalblock programlisting"><div class=content><pre>foo: foo.c
	cc -o foo foo.c</pre></div></div><div class=paragraph><p>It consists of two lines, a dependency line and a creation line.</p></div><div class=paragraph><p>The dependency line here consists of the name of the program (known as the <em>target</em>), followed by a colon, then whitespace, then the name of the source file. When <code>make</code> reads this line, it looks to see if <span class=filename>foo</span> exists; if it exists, it compares the time <span class=filename>foo</span> was last modified to the time <span class=filename>foo.c</span> was last modified. If <span class=filename>foo</span> does not exist, or is older than <span class=filename>foo.c</span>, it then looks at the creation line to find out what to do. In other words, this is the rule for working out when <span class=filename>foo.c</span> needs to be re-compiled.</p></div><div class=paragraph><p>The creation line starts with a tab (press <kbd>tab</kbd>) and then the command you would type to create <span class=filename>foo</span> if you were doing it at a command prompt. If <span class=filename>foo</span> is out of date, or does not exist, <code>make</code> then executes this command to create it. In other words, this is the rule which tells make how to re-compile <span class=filename>foo.c</span>.</p></div><div class=paragraph><p>So, when you type <code>make</code>, it will make sure that <span class=filename>foo</span> is up to date with respect to your latest changes to <span class=filename>foo.c</span>. This principle can be extended to <span class=filename>Makefile</span>'s with hundreds of targets-in fact, on FreeBSD, it is possible to compile the entire operating system just by typing <code>make world</code> in the appropriate directory!</p></div><div class=paragraph><p>Another useful property of makefiles is that the targets do not have to be programs. For instance, we could have a make file that looks like this:</p></div><div class="literalblock programlisting"><div class=content><pre>foo: foo.c
	cc -o foo foo.c

install:
	cp foo /home/me</pre></div></div><div class=paragraph><p>We can tell make which target we want to make by typing:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% make target</code></pre></div></div><div class=paragraph><p><code>make</code> will then only look at that target and ignore any others. For example, if we type <code>make foo</code> with the makefile above, make will ignore the <code>install</code> target.</p></div><div class=paragraph><p>If we just type <code>make</code> on its own, make will always look at the first target and then stop without looking at any others. So if we typed <code>make</code> here, it will just go to the <code>foo</code> target, re-compile <span class=filename>foo</span> if necessary, and then stop without going on to the <code>install</code> target.</p></div><div class=paragraph><p>Notice that the <code>install</code> target does not actually depend on anything! This means that the command on the following line is always executed when we try to make that target by typing <code>make install</code>. In this case, it will copy <span class=filename>foo</span> into the user’s home directory. This is often used by application makefiles, so that the application can be installed in the correct directory when it has been correctly compiled.</p></div><div class=paragraph><p>This is a slightly confusing subject to try to explain. If you do not quite understand how <code>make</code> works, the best thing to do is to write a simple program like "hello world" and a make file like the one above and experiment. Then progress to using more than one source file, or having the source file include a header file. <code>touch</code> is very useful here-it changes the date on a file without you having to edit it.</p></div></div><div class=sect3><h4 id=_make_and_include_files>2.5.3. Make and include-files<a class=anchor href=#_make_and_include_files></a></h4><div class=paragraph><p>C code often starts with a list of files to include, for example stdio.h. Some of these files are system-include files, some of them are from the project you are now working on:</p></div><div class="literalblock programlisting"><div class=content><pre>#include &lt;stdio.h&gt;
#include &#34;foo.h&#34;

int main(....</pre></div></div><div class=paragraph><p>To make sure that this file is recompiled the moment <span class=filename>foo.h</span> is changed, you have to add it in your <span class=filename>Makefile</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>foo: foo.c foo.h</pre></div></div><div class=paragraph><p>The moment your project is getting bigger and you have more and more own include-files to maintain, it will be a pain to keep track of all include files and the files which are depending on it. If you change an include-file but forget to recompile all the files which are depending on it, the results will be devastating. <code>clang</code> has an option to analyze your files and to produce a list of include-files and their dependencies: <code>-MM</code>.</p></div><div class=paragraph><p>If you add this to your Makefile:</p></div><div class="literalblock programlisting"><div class=content><pre>depend:
	cc -E -MM *.c &gt; .depend</pre></div></div><div class=paragraph><p>and run <code>make depend</code>, the file <span class=filename>.depend</span> will appear with a list of object-files, C-files and the include-files:</p></div><div class="literalblock programlisting"><div class=content><pre>foo.o: foo.c foo.h</pre></div></div><div class=paragraph><p>If you change <span class=filename>foo.h</span>, next time you run <code>make</code> all files depending on <span class=filename>foo.h</span> will be recompiled.</p></div><div class=paragraph><p>Do not forget to run <code>make depend</code> each time you add an include-file to one of your files.</p></div></div><div class=sect3><h4 id=_freebsd_makefiles>2.5.4. FreeBSD Makefiles<a class=anchor href=#_freebsd_makefiles></a></h4><div class=paragraph><p>Makefiles can be rather complicated to write. Fortunately, BSD-based systems like FreeBSD come with some very powerful ones as part of the system. One very good example of this is the FreeBSD ports system. Here is the essential part of a typical ports <span class=filename>Makefile</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>MASTER_SITES=   ftp://freefall.cdrom.com/pub/FreeBSD/LOCAL_PORTS/
DISTFILES=      scheme-microcode+dist-7.3-freebsd.tgz

.include &lt;bsd.port.mk&gt;</pre></div></div><div class=paragraph><p>Now, if we go to the directory for this port and type <code>make</code>, the following happens:</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>A check is made to see if the source code for this port is already on the system.</p></li><li><p>If it is not, an FTP connection to the URL in MASTER_SITES is set up to download the source.</p></li><li><p>The checksum for the source is calculated and compared it with one for a known, good, copy of the source. This is to make sure that the source was not corrupted while in transit.</p></li><li><p>Any changes required to make the source work on FreeBSD are applied-this is known as <em>patching</em>.</p></li><li><p>Any special configuration needed for the source is done. (Many UNIX® program distributions try to work out which version of UNIX® they are being compiled on and which optional UNIX® features are present-this is where they are given the information in the FreeBSD ports scenario).</p></li><li><p>The source code for the program is compiled. In effect, we change to the directory where the source was unpacked and do <code>make</code>-the program’s own make file has the necessary information to build the program.</p></li><li><p>We now have a compiled version of the program. If we wish, we can test it now; when we feel confident about the program, we can type <code>make install</code>. This will cause the program and any supporting files it needs to be copied into the correct location; an entry is also made into a <code>package database</code>, so that the port can easily be uninstalled later if we change our mind about it.</p></li></ol></div></div></div><div class=paragraph><p>Now I think you will agree that is rather impressive for a four line script!</p></div><div class=paragraph><p>The secret lies in the last line, which tells <code>make</code> to look in the system makefile called <span class=filename>bsd.port.mk</span>. It is easy to overlook this line, but this is where all the clever stuff comes from-someone has written a makefile that tells <code>make</code> to do all the things above (plus a couple of other things I did not mention, including handling any errors that may occur) and anyone can get access to that just by putting a single line in their own make file!</p></div><div class=paragraph><p>If you want to have a look at these system makefiles, they are in <span class=filename>/usr/shared/mk</span>, but it is probably best to wait until you have had a bit of practice with makefiles, as they are very complicated (and if you do look at them, make sure you have a flask of strong coffee handy!)</p></div></div><div class=sect3><h4 id=_more_advanced_uses_of_make>2.5.5. More Advanced Uses of <code>make</code><a class=anchor href=#_more_advanced_uses_of_make></a></h4><div class=paragraph><p><code>Make</code> is a very powerful tool, and can do much more than the simple example above shows. Unfortunately, there are several different versions of <code>make</code>, and they all differ considerably. The best way to learn what they can do is probably to read the documentation-hopefully this introduction will have given you a base from which you can do this.</p></div><div class=paragraph><p>The version of make that comes with FreeBSD is the Berkeley make; there is a tutorial for it in <span class=filename>/usr/shared/doc/psd/12.make</span>. To view it, do</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% zmore paper.ascii.gz</code></pre></div></div><div class=paragraph><p>in that directory.</p></div><div class=paragraph><p>Many applications in the ports use GNU make, which has a very good set of "info" pages. If you have installed any of these ports, GNU make will automatically have been installed as <code>gmake</code>. It is also available as a port and package in its own right.</p></div><div class=paragraph><p>To view the info pages for GNU make, you will have to edit <span class=filename>dir</span> in the <span class=filename>/usr/local/info</span> directory to add an entry for it. This involves adding a line like</p></div><div class="literalblock programlisting"><div class=content><pre> * Make: (make).                 The GNU Make utility.</pre></div></div><div class=paragraph><p>to the file. Once you have done this, you can type <code>info</code> and then select <span class=guimenuitem>make</span> from the menu (or in Emacs, do <code>C-h i</code>).</p></div></div></div><div class=sect2><h3 id=debugging>2.6. Debugging<a class=anchor href=#debugging></a></h3><div class=sect3><h4 id=_introduction_to_available_debuggers>2.6.1. Introduction to Available Debuggers<a class=anchor href=#_introduction_to_available_debuggers></a></h4><div class=paragraph><p>Using a debugger allows running the program under more controlled circumstances. Typically, it is possible to step through the program a line at a time, inspect the value of variables, change them, tell the debugger to run up to a certain point and then stop, and so on. It is also possible to attach to a program that is already running, or load a core file to investigate why the program crashed. It is even possible to debug the kernel, though that is a little trickier than the user applications we will be discussing in this section.</p></div><div class=paragraph><p>This section is intended to be a quick introduction to using debuggers and does not cover specialized topics such as debugging the kernel. For more information about that, refer to <a href=./#kerneldebug>Kernel Debugging</a>.</p></div><div class=paragraph><p>The standard debugger supplied with FreeBSD 12.1 is called <code>lldb</code> (LLVM debugger). As it is part of the standard installation for that release, there is no need to do anything special to use it. It has good command help, accessible via the <code>help</code> command, as well as <a href=https://lldb.llvm.org/>a web tutorial and documentation</a>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>The <code>lldb</code> command is available for FreeBSD 11.3 <a href=https://docs.freebsd.org/en/books/handbook/ports/#ports-using>from ports or packages</a> as <a class=package href=https://cgit.freebsd.org/ports/tree/devel/llvm/>devel/llvm</a>. This will install the default version of lldb (currently 9.0).</p></div></td></tr></tbody></table></div><div class=paragraph><p>The other debugger available with FreeBSD is called <code>gdb</code> (GNU debugger). Unlike lldb, it is not installed by default on FreeBSD 12.1; to use it, <a href=https://docs.freebsd.org/en/books/handbook/ports/#ports-using>install</a> <a class=package href=https://cgit.freebsd.org/ports/tree/devel/gdb/>devel/gdb</a> from ports or packages. The version installed by default on FreeBSD 11.3 is old; instead, install <a class=package href=https://cgit.freebsd.org/ports/tree/devel/gdb/>devel/gdb</a> there as well. It has quite good on-line help, as well as a set of info pages.</p></div><div class=paragraph><p>Which one to use is largely a matter of taste. If familiar with one only, use that one. People familiar with neither or both but wanting to use one from inside Emacs will need to use <code>gdb</code> as <code>lldb</code> is unsupported by Emacs. Otherwise, try both and see which one you prefer.</p></div></div><div class=sect3><h4 id=_using_lldb>2.6.2. Using lldb<a class=anchor href=#_using_lldb></a></h4><div class=sect4><h5 id=_starting_lldb>2.6.2.1. Starting lldb<a class=anchor href=#_starting_lldb></a></h5><div class=paragraph><p>Start up lldb by typing</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% lldb <span class=nt>--</span> progname</code></pre></div></div></div><div class=sect4><h5 id=_running_a_program_with_lldb>2.6.2.2. Running a Program with lldb<a class=anchor href=#_running_a_program_with_lldb></a></h5><div class=paragraph><p>Compile the program with <code>-g</code> to get the most out of using <code>lldb</code>. It will work without, but will only display the name of the function currently running, instead of the source code. If it displays a line like:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Breakpoint 1: where <span class=o>=</span> temp<span class=sb>`</span>main, address <span class=o>=</span> …</code></pre></div></div><div class=paragraph><p>(without an indication of source code filename and line number) when setting a breakpoint, this means that the program was not compiled with <code>-g</code>.</p></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Most <code>lldb</code> commands have shorter forms that can be used instead. The longer forms are used here for clarity.</p></div></td></tr></tbody></table></div><div class=paragraph><p>At the <code>lldb</code> prompt, type <code>breakpoint set -n main</code>. This will tell the debugger not to display the preliminary set-up code in the program being run and to stop execution at the beginning of the program’s code. Now type <code>process launch</code> to actually start the program- it will start at the beginning of the set-up code and then get stopped by the debugger when it calls <code>main()</code>.</p></div><div class=paragraph><p>To step through the program a line at a time, type <code>thread step-over</code>. When the program gets to a function call, step into it by typing <code>thread step-in</code>. Once in a function call, return from it by typing <code>thread step-out</code> or use <code>up</code> and <code>down</code> to take a quick look at the caller.</p></div><div class=paragraph><p>Here is a simple example of how to spot a mistake in a program with <code>lldb</code>. This is our program (with a deliberate mistake):</p></div><div class="literalblock programlisting"><div class=content><pre>#include &lt;stdio.h&gt;

int bazz(int anint);

main() {
	int i;

	printf(&#34;This is my program\n&#34;);
	bazz(i);
	return 0;
}

int bazz(int anint) {
	printf(&#34;You gave me %d\n&#34;, anint);
	return anint;
}</pre></div></div><div class=paragraph><p>This program sets i to be <code>5</code> and passes it to a function <code>bazz()</code> which prints out the number we gave it.</p></div><div class=paragraph><p>Compiling and running the program displays</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% cc <span class=nt>-g</span> <span class=nt>-o</span> temp temp.c
% ./temp
This is my program
anint <span class=o>=</span> <span class=nt>-5360</span></code></pre></div></div><div class=paragraph><p>That is not what was expected! Time to see what is going on!</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% lldb <span class=nt>--</span> temp
<span class=o>(</span>lldb<span class=o>)</span> target create <span class=s2>&#34;temp&#34;</span>
Current executable <span class=nb>set </span>to <span class=s1>&#39;temp&#39;</span> <span class=o>(</span>x86_64<span class=o>)</span><span class=nb>.</span>
<span class=o>(</span>lldb<span class=o>)</span> breakpoint <span class=nb>set</span> <span class=nt>-n</span> main				Skip the set-up code
Breakpoint 1: where <span class=o>=</span> temp<span class=sb>`</span>main + 15 at temp.c:8:2, address <span class=o>=</span> 0x00000000002012ef	lldb puts breakpoint at main<span class=o>()</span>
<span class=o>(</span>lldb<span class=o>)</span> process launch					Run as far as main<span class=o>()</span>
Process 9992 launching
Process 9992 launched: <span class=s1>&#39;/home/pauamma/tmp/temp&#39;</span> <span class=o>(</span>x86_64<span class=o>)</span>	Program starts running

Process 9992 stopped
<span class=k>*</span> thread <span class=c>#1, name = &#39;temp&#39;, stop reason = breakpoint 1.1	lldb stops at main()</span>
    frame <span class=c>#0: 0x00000000002012ef temp`main at temp.c:8:2</span>
   5	main<span class=o>()</span> <span class=o>{</span>
   6		int i<span class=p>;</span>
   7
-&gt; 8		<span class=nb>printf</span><span class=o>(</span><span class=s2>&#34;This is my program</span><span class=se>\n</span><span class=s2>&#34;</span><span class=o>)</span><span class=p>;</span>			Indicates the line where it stopped
   9		bazz<span class=o>(</span>i<span class=o>)</span><span class=p>;</span>
   10		<span class=k>return </span>0<span class=p>;</span>
   11	<span class=o>}</span>
<span class=o>(</span>lldb<span class=o>)</span> thread step-over			Go to next line
This is my program						Program prints out
Process 9992 stopped
<span class=k>*</span> thread <span class=c>#1, name = &#39;temp&#39;, stop reason = step over</span>
    frame <span class=c>#0: 0x0000000000201300 temp`main at temp.c:9:7</span>
   6		int i<span class=p>;</span>
   7
   8		<span class=nb>printf</span><span class=o>(</span><span class=s2>&#34;This is my program</span><span class=se>\n</span><span class=s2>&#34;</span><span class=o>)</span><span class=p>;</span>
-&gt; 9		bazz<span class=o>(</span>i<span class=o>)</span><span class=p>;</span>
   10		<span class=k>return </span>0<span class=p>;</span>
   11	<span class=o>}</span>
   12
<span class=o>(</span>lldb<span class=o>)</span> thread step-in			step into bazz<span class=o>()</span>
Process 9992 stopped
<span class=k>*</span> thread <span class=c>#1, name = &#39;temp&#39;, stop reason = step in</span>
    frame <span class=c>#0: 0x000000000020132b temp`bazz(anint=-5360) at temp.c:14:29	lldb displays stack frame</span>
   11	<span class=o>}</span>
   12
   13	int bazz<span class=o>(</span>int anint<span class=o>)</span> <span class=o>{</span>
-&gt; 14		<span class=nb>printf</span><span class=o>(</span><span class=s2>&#34;You gave me %d</span><span class=se>\n</span><span class=s2>&#34;</span>, anint<span class=o>)</span><span class=p>;</span>
   15		<span class=k>return </span>anint<span class=p>;</span>
   16	<span class=o>}</span>
<span class=o>(</span>lldb<span class=o>)</span></code></pre></div></div><div class=paragraph><p>Hang on a minute! How did anint get to be <code>-5360</code>? Was it not set to <code>5</code> in <code>main()</code>? Let us move up to <code>main()</code> and have a look.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=o>(</span>lldb<span class=o>)</span> up		Move up call stack
frame <span class=c>#1: 0x000000000020130b temp`main at temp.c:9:2		lldb displays stack frame</span>
   6		int i<span class=p>;</span>
   7
   8		<span class=nb>printf</span><span class=o>(</span><span class=s2>&#34;This is my program</span><span class=se>\n</span><span class=s2>&#34;</span><span class=o>)</span><span class=p>;</span>
-&gt; 9		bazz<span class=o>(</span>i<span class=o>)</span><span class=p>;</span>
   10		<span class=k>return </span>0<span class=p>;</span>
   11	<span class=o>}</span>
   12
<span class=o>(</span>lldb<span class=o>)</span> frame variable i			Show us the value of i
<span class=o>(</span>int<span class=o>)</span> i <span class=o>=</span> <span class=nt>-5360</span>							lldb displays <span class=nt>-5360</span></code></pre></div></div><div class=paragraph><p>Oh dear! Looking at the code, we forgot to initialize i. We meant to put</p></div><div class="literalblock programlisting"><div class=content><pre>...
main() {
	int i;

	i = 5;
	printf(&#34;This is my program\n&#34;);
...</pre></div></div><div class=paragraph><p>but we left the <code>i=5;</code> line out. As we did not initialize i, it had whatever number happened to be in that area of memory when the program ran, which in this case happened to be <code>-5360</code>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>The <code>lldb</code> command displays the stack frame every time we go into or out of a function, even if we are using <code>up</code> and <code>down</code> to move around the call stack. This shows the name of the function and the values of its arguments, which helps us keep track of where we are and what is going on. (The stack is a storage area where the program stores information about the arguments passed to functions and where to go when it returns from a function call.)</p></div></td></tr></tbody></table></div></div><div class=sect4><h5 id=_examining_a_core_file_with_lldb>2.6.2.3. Examining a Core File with lldb<a class=anchor href=#_examining_a_core_file_with_lldb></a></h5><div class=paragraph><p>A core file is basically a file which contains the complete state of the process when it crashed.
In "the good old days", programmers had to print out hex listings of core files and sweat over machine code manuals, but now life is a bit easier.
Incidentally, under FreeBSD and other 4.4BSD systems, a core file is called <span class=filename>progname.core</span> instead of just <span class=filename>core</span>, to make it clearer which program a core file belongs to.</p></div><div class=paragraph><p>To examine a core file, specify the name of the core file in addition to the program itself.
Instead of starting up <code>lldb</code> in the usual way, type <code>lldb -c <em>progname</em>.core -- <em>progname</em></code>.</p></div><div class=paragraph><p>The debugger will display something like this:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% lldb <span class=nt>-c</span> <span class=o><span class="</span>.filename">progname.core</span> <span class=nt>--</span> <span class=o><span class="</span>.filename">progname</span>
<span class=o>(</span>lldb<span class=o>)</span> target create <span class=s2>&#34;<span class=filename>progname</span>&#34;</span> <span class=nt>--core</span> <span class=s2>&#34;<span class=filename>progname</span>.core&#34;</span>
Core file <span class=s1>&#39;/home/pauamma/tmp/<span class=filename>progname.core</span>&#39;</span> <span class=o>(</span>x86_64<span class=o>)</span> was loaded.
<span class=o>(</span>lldb<span class=o>)</span></span></span></code></pre></div></div><div class=paragraph><p>In this case, the program was called <span class=filename>progname</span>, so the core file is called <span class=filename>progname.core</span>.
The debugger does not display why the program crashed or where.
For this, use <code>thread backtrace all</code>.
This will also show how the function where the program dumped core was called.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=o>(</span>lldb<span class=o>)</span> thread backtrace all
<span class=k><strong></strong></span><strong> thread <span class=c>#1, name = &#39;progname&#39;, stop reason = signal SIGSEGV</span>
  <span class=k></span></strong> frame <span class=c>#0: 0x0000000000201347 progname`bazz(anint=5) at temp2.c:17:10</span>
    frame <span class=c>#1: 0x0000000000201312 progname`main at temp2.c:10:2</span>
    frame <span class=c>#2: 0x000000000020110f progname`_start(ap=&lt;unavailable&gt;, cleanup=&lt;unavailable&gt;) at crt1.c:76:7</span>
<span class=o>(</span>lldb<span class=o>)</span></code></pre></div></div><div class=paragraph><p><code>SIGSEGV</code> indicates that the program tried to access memory (run code or read/write data usually) at a location that does not belong to it, but does not give any specifics.
For that, look at the source code at line 10 of file temp2.c, in <code>bazz()</code>.
The backtrace also says that in this case, <code>bazz()</code> was called from <code>main()</code>.</p></div></div><div class=sect4><h5 id=_attaching_to_a_running_program_with_lldb>2.6.2.4. Attaching to a Running Program with lldb<a class=anchor href=#_attaching_to_a_running_program_with_lldb></a></h5><div class=paragraph><p>One of the neatest features about <code>lldb</code> is that it can attach to a program that is already running. Of course, that requires sufficient permissions to do so. A common problem is stepping through a program that forks and wanting to trace the child, but the debugger will only trace the parent.</p></div><div class=paragraph><p>To do that, start up another <code>lldb</code>, use <code>ps</code> to find the process ID for the child, and do</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=o>(</span>lldb<span class=o>)</span> process attach <span class=nt>-p</span> pid</code></pre></div></div><div class=paragraph><p>in <code>lldb</code>, and then debug as usual.</p></div><div class=paragraph><p>For that to work well, the code that calls <code>fork</code> to create the child needs to do something like the following (courtesy of the <code>gdb</code> info pages):</p></div><div class="literalblock programlisting"><div class=content><pre>...
if ((pid = fork()) &lt; 0)		/* _Always_ check this */
	error();
else if (pid == 0) {		/* child */
	int PauseMode = 1;

	while (PauseMode)
		sleep(10);	/* Wait until someone attaches to us */
	...
} else {			/* parent */
	...</pre></div></div><div class=paragraph><p>Now all that is needed is to attach to the child, set PauseMode to <code>0</code> with <code>expr PauseMode = 0</code> and wait for the <code>sleep()</code> call to return.</p></div></div></div><div class=sect3><h4 id=_using_gdb>2.6.3. Using gdb<a class=anchor href=#_using_gdb></a></h4><div class=sect4><h5 id=_starting_gdb>2.6.3.1. Starting gdb<a class=anchor href=#_starting_gdb></a></h5><div class=paragraph><p>Start up gdb by typing</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% gdb progname</code></pre></div></div><div class=paragraph><p>although many people prefer to run it inside Emacs. To do this, type:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> M-x gdb RET progname RET</code></pre></div></div><div class=paragraph><p>Finally, for those finding its text-based command-prompt style off-putting, there is a graphical front-end for it (<a class=package href=https://cgit.freebsd.org/ports/tree/devel/xxgdb/>devel/xxgdb</a>) in the Ports Collection.</p></div></div><div class=sect4><h5 id=_running_a_program_with_gdb>2.6.3.2. Running a Program with gdb<a class=anchor href=#_running_a_program_with_gdb></a></h5><div class=paragraph><p>Compile the program with <code>-g</code> to get the most out of using <code>gdb</code>. It will work without, but will only display the name of the function currently running, instead of the source code. A line like:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>... <span class=o>(</span>no debugging symbols found<span class=o>)</span> ...</code></pre></div></div><div class=paragraph><p>when <code>gdb</code> starts up means that the program was not compiled with <code>-g</code>.</p></div><div class=paragraph><p>At the <code>gdb</code> prompt, type <code>break main</code>. This will tell the debugger to skip the preliminary set-up code in the program being run and to stop execution at the beginning of the program’s code. Now type <code>run</code> to start the program- it will start at the beginning of the set-up code and then get stopped by the debugger when it calls <code>main()</code>.</p></div><div class=paragraph><p>To step through the program a line at a time, press <code>n</code>. When at a function call, step into it by pressing <code>s</code>. Once in a function call, return from it by pressing <code>f</code>, or use <code>up</code> and <code>down</code> to take a quick look at the caller.</p></div><div class=paragraph><p>Here is a simple example of how to spot a mistake in a program with <code>gdb</code>. This is our program (with a deliberate mistake):</p></div><div class="literalblock programlisting"><div class=content><pre>#include &lt;stdio.h&gt;

int bazz(int anint);

main() {
	int i;

	printf(&#34;This is my program\n&#34;);
	bazz(i);
	return 0;
}

int bazz(int anint) {
	printf(&#34;You gave me %d\n&#34;, anint);
	return anint;
}</pre></div></div><div class=paragraph><p>This program sets i to be <code>5</code> and passes it to a function <code>bazz()</code> which prints out the number we gave it.</p></div><div class=paragraph><p>Compiling and running the program displays</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% cc <span class=nt>-g</span> <span class=nt>-o</span> temp temp.c
% ./temp
This is my program
anint <span class=o>=</span> 4231</code></pre></div></div><div class=paragraph><p>That was not what we expected! Time to see what is going on!</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% gdb temp
GDB is free software and you are welcome to distribute copies of it
 under certain conditions<span class=p>;</span> <span class=nb>type</span> <span class=s2>&#34;show copying&#34;</span> to see the conditions.
There is absolutely no warranty <span class=k>for </span>GDB<span class=p>;</span> <span class=nb>type</span> <span class=s2>&#34;show warranty&#34;</span> <span class=k>for </span>details.
GDB 4.13 <span class=o>(</span>i386-unknown-freebsd<span class=o>)</span>, Copyright 1994 Free Software Foundation, Inc.
<span class=o>(</span>gdb<span class=o>)</span> <span class=nb>break </span>main				Skip the set-up code
Breakpoint 1 at 0x160f: file temp.c, line 9.	gdb puts breakpoint at main<span class=o>()</span>
<span class=o>(</span>gdb<span class=o>)</span> run					Run as far as main<span class=o>()</span>
Starting program: /home/james/tmp/temp		Program starts running

Breakpoint 1, main <span class=o>()</span> at temp.c:9		gdb stops at main<span class=o>()</span>
<span class=o>(</span>gdb<span class=o>)</span> n						Go to next line
This is my program				Program prints out
<span class=o>(</span>gdb<span class=o>)</span> s						step into bazz<span class=o>()</span>
bazz <span class=o>(</span><span class=nv>anint</span><span class=o>=</span>4231<span class=o>)</span> at temp.c:17			gdb displays stack frame
<span class=o>(</span>gdb<span class=o>)</span></code></pre></div></div><div class=paragraph><p>Hang on a minute! How did anint get to be <code>4231</code>? Was it not set to <code>5</code> in <code>main()</code>? Let us move up to <code>main()</code> and have a look.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=o>(</span>gdb<span class=o>)</span> up					Move up call stack
<span class=c>#1  0x1625 in main () at temp.c:11		gdb displays stack frame</span>
<span class=o>(</span>gdb<span class=o>)</span> p i					Show us the value of i
<span class=nv>$1</span> <span class=o>=</span> 4231					gdb displays 4231</code></pre></div></div><div class=paragraph><p>Oh dear! Looking at the code, we forgot to initialize i. We meant to put</p></div><div class="literalblock programlisting"><div class=content><pre>...
main() {
	int i;

	i = 5;
	printf(&#34;This is my program\n&#34;);
...</pre></div></div><div class=paragraph><p>but we left the <code>i=5;</code> line out. As we did not initialize i, it had whatever number happened to be in that area of memory when the program ran, which in this case happened to be <code>4231</code>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>The <code>gdb</code> command displays the stack frame every time we go into or out of a function, even if we are using <code>up</code> and <code>down</code> to move around the call stack. This shows the name of the function and the values of its arguments, which helps us keep track of where we are and what is going on. (The stack is a storage area where the program stores information about the arguments passed to functions and where to go when it returns from a function call.)</p></div></td></tr></tbody></table></div></div><div class=sect4><h5 id=_examining_a_core_file_with_gdb>2.6.3.3. Examining a Core File with gdb<a class=anchor href=#_examining_a_core_file_with_gdb></a></h5><div class=paragraph><p>A core file is basically a file which contains the complete state of the process when it crashed. In "the good old days", programmers had to print out hex listings of core files and sweat over machine code manuals, but now life is a bit easier. Incidentally, under FreeBSD and other 4.4BSD systems, a core file is called <span class=filename>progname.core</span> instead of just <span class=filename>core</span>, to make it clearer which program a core file belongs to.</p></div><div class=paragraph><p>To examine a core file, start up <code>gdb</code> in the usual way. Instead of typing <code>break</code> or <code>run</code>, type</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=o>(</span>gdb<span class=o>)</span> core progname.core</code></pre></div></div><div class=paragraph><p>If the core file is not in the current directory, type <code>dir /path/to/core/file</code> first.</p></div><div class=paragraph><p>The debugger should display something like this:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% gdb <span class=o><span class="</span>.filename">progname</span>
GDB is free software and you are welcome to distribute copies of it
 under certain conditions<span class=p>;</span> <span class=nb>type</span> <span class=s2>&#34;show copying&#34;</span> to see the conditions.
There is absolutely no warranty <span class=k>for </span>GDB<span class=p>;</span> <span class=nb>type</span> <span class=s2>&#34;show warranty&#34;</span> <span class=k>for </span>details.
GDB 4.13 <span class=o>(</span>i386-unknown-freebsd<span class=o>)</span>, Copyright 1994 Free Software Foundation, Inc.
<span class=o>(</span>gdb<span class=o>)</span> core <span class=o><span class="</span>.filename">progname.core</span>
Core was generated by <span class=sb>`</span><span class=o><span class="</span>.filename">progname</span><span class=s1>&#39;.
Program terminated with signal 11, Segmentation fault.
Cannot access memory at address 0x7020796d.
#0  0x164a in bazz (anint=0x5) at temp.c:17
(gdb)</span></span></span></span></code></pre></div></div><div class=paragraph><p>In this case, the program was called <span class=filename>progname</span>, so the core file is called <span class=filename>progname.core</span>. We can see that the program crashed due to trying to access an area in memory that was not available to it in a function called <code>bazz</code>.</p></div><div class=paragraph><p>Sometimes it is useful to be able to see how a function was called, as the problem could have occurred a long way up the call stack in a complex program. <code>bt</code> causes <code>gdb</code> to print out a back-trace of the call stack:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=o>(</span>gdb<span class=o>)</span> bt
<span class=c>#0  0x164a in bazz (anint=0x5) at temp.c:17</span>
<span class=c>#1  0xefbfd888 in end ()</span>
<span class=c>#2  0x162c in main () at temp.c:11</span>
<span class=o>(</span>gdb<span class=o>)</span></code></pre></div></div><div class=paragraph><p>The <code>end()</code> function is called when a program crashes; in this case, the <code>bazz()</code> function was called from <code>main()</code>.</p></div></div><div class=sect4><h5 id=_attaching_to_a_running_program_with_gdb>2.6.3.4. Attaching to a Running Program with gdb<a class=anchor href=#_attaching_to_a_running_program_with_gdb></a></h5><div class=paragraph><p>One of the neatest features about <code>gdb</code> is that it can attach to a program that is already running. Of course, that requires sufficient permissions to do so. A common problem is stepping through a program that forks and wanting to trace the child, but the debugger will only trace the parent.</p></div><div class=paragraph><p>To do that, start up another <code>gdb</code>, use <code>ps</code> to find the process ID for the child, and do</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=o>(</span>gdb<span class=o>)</span> attach pid</code></pre></div></div><div class=paragraph><p>in <code>gdb</code>, and then debug as usual.</p></div><div class=paragraph><p>For that to work well, the code that calls <code>fork</code> to create the child needs to do something like the following (courtesy of the <code>gdb</code> info pages):</p></div><div class="literalblock programlisting"><div class=content><pre>...
if ((pid = fork()) &lt; 0)		/* _Always_ check this */
	error();
else if (pid == 0) {		/* child */
	int PauseMode = 1;

	while (PauseMode)
		sleep(10);	/* Wait until someone attaches to us */
	...
} else {			/* parent */
	...</pre></div></div><div class=paragraph><p>Now all that is needed is to attach to the child, set PauseMode to <code>0</code>, and wait for the <code>sleep()</code> call to return!</p></div></div></div></div><div class=sect2><h3 id=emacs>2.7. Using Emacs as a Development Environment<a class=anchor href=#emacs></a></h3><div class=sect3><h4 id=_emacs>2.7.1. Emacs<a class=anchor href=#_emacs></a></h4><div class=paragraph><p>Emacs is a highly customizable editor-indeed, it has been customized to the point where it is more like an operating system than an editor! Many developers and sysadmins do in fact spend practically all their time working inside Emacs, leaving it only to log out.</p></div><div class=paragraph><p>It is impossible even to summarize everything Emacs can do here, but here are some of the features of interest to developers:</p></div><div class=ulist><ul><li><p>Very powerful editor, allowing search-and-replace on both strings and regular expressions (patterns), jumping to start/end of block expression, etc, etc.</p></li><li><p>Pull-down menus and online help.</p></li><li><p>Language-dependent syntax highlighting and indentation.</p></li><li><p>Completely customizable.</p></li><li><p>You can compile and debug programs within Emacs.</p></li><li><p>On a compilation error, you can jump to the offending line of source code.</p></li><li><p>Friendly-ish front-end to the <code>info</code> program used for reading GNU hypertext documentation, including the documentation on Emacs itself.</p></li><li><p>Friendly front-end to <code>gdb</code>, allowing you to look at the source code as you step through your program.</p></li></ul></div><div class=paragraph><p>And doubtless many more that have been overlooked.</p></div><div class=paragraph><p>Emacs can be installed on FreeBSD using the <a class=package href=https://cgit.freebsd.org/ports/tree/editors/emacs/>editors/emacs</a> port.</p></div><div class=paragraph><p>Once it is installed, start it up and do <code>C-h t</code> to read an Emacs tutorial-that means hold down <kbd>control</kbd>, press <kbd>h</kbd>, let go of <kbd>control</kbd>, and then press <kbd>t</kbd>. (Alternatively, you can use the mouse to select <span class=guimenuitem>Emacs Tutorial</span> from the <b class=menuref>Help</b> menu.)</p></div><div class=paragraph><p>Although Emacs does have menus, it is well worth learning the key bindings, as it is much quicker when you are editing something to press a couple of keys than to try to find the mouse and then click on the right place. And, when you are talking to seasoned Emacs users, you will find they often casually throw around expressions like “M-x replace-s RET foo RET bar RET” so it is useful to know what they mean. And in any case, Emacs has far too many useful functions for them to all fit on the menu bars.</p></div><div class=paragraph><p>Fortunately, it is quite easy to pick up the key-bindings, as they are displayed next to the menu item. My advice is to use the menu item for, say, opening a file until you understand how it works and feel confident with it, then try doing C-x C-f. When you are happy with that, move on to another menu command.</p></div><div class=paragraph><p>If you cannot remember what a particular combination of keys does, select <span class=guimenuitem>Describe Key</span> from the <b class=menuref>Help</b> menu and type it in-Emacs will tell you what it does. You can also use the <span class=guimenuitem>Command Apropos</span> menu item to find out all the commands which contain a particular word in them, with the key binding next to it.</p></div><div class=paragraph><p>By the way, the expression above means hold down the <kbd>Meta</kbd> key, press <kbd>x</kbd>, release the <kbd>Meta</kbd> key, type <code>replace-s</code> (short for <code>replace-string</code>-another feature of Emacs is that you can abbreviate commands), press the <kbd>return</kbd> key, type <code>foo</code> (the string you want replaced), press the <kbd>return</kbd> key, type bar (the string you want to replace <code>foo</code> with) and press <kbd>return</kbd> again. Emacs will then do the search-and-replace operation you have just requested.</p></div><div class=paragraph><p>If you are wondering what on earth <kbd>Meta</kbd> is, it is a special key that many UNIX® workstations have. Unfortunately, PC’s do not have one, so it is usually <kbd>alt</kbd> (or if you are unlucky, the <kbd>escape</kbd> key).</p></div><div class=paragraph><p>Oh, and to get out of Emacs, do <code>C-x C-c</code> (that means hold down the <kbd>control</kbd> key, press <kbd>x</kbd>, press <kbd>c</kbd> and release the <kbd>control</kbd> key). If you have any unsaved files open, Emacs will ask you if you want to save them. (Ignore the bit in the documentation where it says <code>C-z</code> is the usual way to leave Emacs-that leaves Emacs hanging around in the background, and is only really useful if you are on a system which does not have virtual terminals).</p></div></div><div class=sect3><h4 id=_configuring_emacs>2.7.2. Configuring Emacs<a class=anchor href=#_configuring_emacs></a></h4><div class=paragraph><p>Emacs does many wonderful things; some of them are built in, some of them need to be configured.</p></div><div class=paragraph><p>Instead of using a proprietary macro language for configuration, Emacs uses a version of Lisp specially adapted for editors, known as Emacs Lisp. Working with Emacs Lisp can be quite helpful if you want to go on and learn something like Common Lisp. Emacs Lisp has many features of Common Lisp, although it is considerably smaller (and thus easier to master).</p></div><div class=paragraph><p>The best way to learn Emacs Lisp is to download the <a href=ftp://ftp.gnu.org/old-gnu/emacs/elisp-manual-19-2.4.tar.gz>Emacs Tutorial</a></p></div><div class=paragraph><p>However, there is no need to actually know any Lisp to get started with configuring Emacs, as I have included a sample <span class=filename>.emacs</span>, which should be enough to get you started. Just copy it into your home directory and restart Emacs if it is already running; it will read the commands from the file and (hopefully) give you a useful basic setup.</p></div></div><div class=sect3><h4 id=_a_sample_emacs>2.7.3. A Sample <span class=filename>.emacs</span><a class=anchor href=#_a_sample_emacs></a></h4><div class=paragraph><p>Unfortunately, there is far too much here to explain it in detail; however there are one or two points worth mentioning.</p></div><div class=ulist><ul><li><p>Everything beginning with a <code>;</code> is a comment and is ignored by Emacs.</p></li><li><p>In the first line, the <code>-<strong>- Emacs-Lisp -</strong>-</code> is so that we can edit <span class=filename>.emacs</span> itself within Emacs and get all the fancy features for editing Emacs Lisp. Emacs usually tries to guess this based on the filename, and may not get it right for <span class=filename>.emacs</span>.</p></li><li><p>The <kbd>tab</kbd> key is bound to an indentation function in some modes, so when you press the tab key, it will indent the current line of code. If you want to put a tab character in whatever you are writing, hold the <kbd>control</kbd> key down while you are pressing the <kbd>tab</kbd> key.</p></li><li><p>This file supports syntax highlighting for C, C++, Perl, Lisp and Scheme, by guessing the language from the filename.</p></li><li><p>Emacs already has a pre-defined function called <code>next-error</code>. In a compilation output window, this allows you to move from one compilation error to the next by doing <code>M-n</code>; we define a complementary function, <code>previous-error</code>, that allows you to go to a previous error by doing <code>M-p</code>. The nicest feature of all is that <code>C-c C-c</code> will open up the source file in which the error occurred and jump to the appropriate line.</p></li><li><p>We enable Emacs’s ability to act as a server, so that if you are doing something outside Emacs and you want to edit a file, you can just type in</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% emacsclient filename</code></pre></div></div><div class=paragraph><p>and then you can edit the file in your Emacs!<sup class=footnote>[<a id=_footnoteref_2 class=footnote href=#_footnotedef_2 title="View footnote.">2</a>]</sup></p></div></li></ul></div><div class=exampleblock><div class=title>例 1. A Sample <span class=filename>.emacs</span></div><div class=content><div class="literalblock programlisting"><div class=content><pre>;; -*-Emacs-Lisp-*-

;; This file is designed to be re-evaled; use the variable first-time
;; to avoid any problems with this.
(defvar first-time t
  &#34;Flag signifying this is the first time that .emacs has been evaled&#34;)

;; Meta
(global-set-key &#34;\M- &#34; &#39;set-mark-command)
(global-set-key &#34;\M-\C-h&#34; &#39;backward-kill-word)
(global-set-key &#34;\M-\C-r&#34; &#39;query-replace)
(global-set-key &#34;\M-r&#34; &#39;replace-string)
(global-set-key &#34;\M-g&#34; &#39;goto-line)
(global-set-key &#34;\M-h&#34; &#39;help-command)

;; Function keys
(global-set-key [f1] &#39;manual-entry)
(global-set-key [f2] &#39;info)
(global-set-key [f3] &#39;repeat-complex-command)
(global-set-key [f4] &#39;advertised-undo)
(global-set-key [f5] &#39;eval-current-buffer)
(global-set-key [f6] &#39;buffer-menu)
(global-set-key [f7] &#39;other-window)
(global-set-key [f8] &#39;find-file)
(global-set-key [f9] &#39;save-buffer)
(global-set-key [f10] &#39;next-error)
(global-set-key [f11] &#39;compile)
(global-set-key [f12] &#39;grep)
(global-set-key [C-f1] &#39;compile)
(global-set-key [C-f2] &#39;grep)
(global-set-key [C-f3] &#39;next-error)
(global-set-key [C-f4] &#39;previous-error)
(global-set-key [C-f5] &#39;display-faces)
(global-set-key [C-f8] &#39;dired)
(global-set-key [C-f10] &#39;kill-compilation)

;; Keypad bindings
(global-set-key [up] &#34;\C-p&#34;)
(global-set-key [down] &#34;\C-n&#34;)
(global-set-key [left] &#34;\C-b&#34;)
(global-set-key [right] &#34;\C-f&#34;)
(global-set-key [home] &#34;\C-a&#34;)
(global-set-key [end] &#34;\C-e&#34;)
(global-set-key [prior] &#34;\M-v&#34;)
(global-set-key [next] &#34;\C-v&#34;)
(global-set-key [C-up] &#34;\M-\C-b&#34;)
(global-set-key [C-down] &#34;\M-\C-f&#34;)
(global-set-key [C-left] &#34;\M-b&#34;)
(global-set-key [C-right] &#34;\M-f&#34;)
(global-set-key [C-home] &#34;\M-&lt;&#34;)
(global-set-key [C-end] &#34;\M-&gt;&#34;)
(global-set-key [C-prior] &#34;\M-&lt;&#34;)
(global-set-key [C-next] &#34;\M-&gt;&#34;)

;; Mouse
(global-set-key [mouse-3] &#39;imenu)

;; Misc
(global-set-key [C-tab] &#34;\C-q\t&#34;)	; Control tab quotes a tab.
(setq backup-by-copying-when-mismatch t)

;; Treat &#39;y&#39; or &lt;CR&gt; as yes, &#39;n&#39; as no.
(fset &#39;yes-or-no-p &#39;y-or-n-p)
(define-key query-replace-map [return] &#39;act)
(define-key query-replace-map [?\C-m] &#39;act)

;; Load packages
(require &#39;desktop)
(require &#39;tar-mode)

;; Pretty diff mode
(autoload &#39;ediff-buffers &#34;ediff&#34; &#34;Intelligent Emacs interface to diff&#34; t)
(autoload &#39;ediff-files &#34;ediff&#34; &#34;Intelligent Emacs interface to diff&#34; t)
(autoload &#39;ediff-files-remote &#34;ediff&#34;
  &#34;Intelligent Emacs interface to diff&#34;)

(if first-time
    (setq auto-mode-alist
	  (append &#39;((&#34;\\.cpp$&#34; . c++-mode)
		    (&#34;\\.hpp$&#34; . c++-mode)
		    (&#34;\\.lsp$&#34; . lisp-mode)
		    (&#34;\\.scm$&#34; . scheme-mode)
		    (&#34;\\.pl$&#34; . perl-mode)
		    ) auto-mode-alist)))

;; Auto font lock mode
(defvar font-lock-auto-mode-list
  (list &#39;c-mode &#39;c++-mode &#39;c++-c-mode &#39;emacs-lisp-mode &#39;lisp-mode &#39;perl-mode &#39;scheme-mode)
  &#34;List of modes to always start in font-lock-mode&#34;)

(defvar font-lock-mode-keyword-alist
  &#39;((c++-c-mode . c-font-lock-keywords)
    (perl-mode . perl-font-lock-keywords))
  &#34;Associations between modes and keywords&#34;)

(defun font-lock-auto-mode-select ()
  &#34;Automatically select font-lock-mode if the current major mode is in font-lock-auto-mode-list&#34;
  (if (memq major-mode font-lock-auto-mode-list)
      (progn
	(font-lock-mode t))
    )
  )

(global-set-key [M-f1] &#39;font-lock-fontify-buffer)

;; New dabbrev stuff
;(require &#39;new-dabbrev)
(setq dabbrev-always-check-other-buffers t)
(setq dabbrev-abbrev-char-regexp &#34;\\sw\\|\\s_&#34;)
(add-hook &#39;emacs-lisp-mode-hook
	  &#39;(lambda ()
	     (set (make-local-variable &#39;dabbrev-case-fold-search) nil)
	     (set (make-local-variable &#39;dabbrev-case-replace) nil)))
(add-hook &#39;c-mode-hook
	  &#39;(lambda ()
	     (set (make-local-variable &#39;dabbrev-case-fold-search) nil)
	     (set (make-local-variable &#39;dabbrev-case-replace) nil)))
(add-hook &#39;text-mode-hook
	  &#39;(lambda ()
	     (set (make-local-variable &#39;dabbrev-case-fold-search) t)
	     (set (make-local-variable &#39;dabbrev-case-replace) t)))

;; C++ and C mode...
(defun my-c++-mode-hook ()
  (setq tab-width 4)
  (define-key c++-mode-map &#34;\C-m&#34; &#39;reindent-then-newline-and-indent)
  (define-key c++-mode-map &#34;\C-ce&#34; &#39;c-comment-edit)
  (setq c++-auto-hungry-initial-state &#39;none)
  (setq c++-delete-function &#39;backward-delete-char)
  (setq c++-tab-always-indent t)
  (setq c-indent-level 4)
  (setq c-continued-statement-offset 4)
  (setq c++-empty-arglist-indent 4))

(defun my-c-mode-hook ()
  (setq tab-width 4)
  (define-key c-mode-map &#34;\C-m&#34; &#39;reindent-then-newline-and-indent)
  (define-key c-mode-map &#34;\C-ce&#34; &#39;c-comment-edit)
  (setq c-auto-hungry-initial-state &#39;none)
  (setq c-delete-function &#39;backward-delete-char)
  (setq c-tab-always-indent t)
;; BSD-ish indentation style
  (setq c-indent-level 4)
  (setq c-continued-statement-offset 4)
  (setq c-brace-offset -4)
  (setq c-argdecl-indent 0)
  (setq c-label-offset -4))

;; Perl mode
(defun my-perl-mode-hook ()
  (setq tab-width 4)
  (define-key c++-mode-map &#34;\C-m&#34; &#39;reindent-then-newline-and-indent)
  (setq perl-indent-level 4)
  (setq perl-continued-statement-offset 4))

;; Scheme mode...
(defun my-scheme-mode-hook ()
  (define-key scheme-mode-map &#34;\C-m&#34; &#39;reindent-then-newline-and-indent))

;; Emacs-Lisp mode...
(defun my-lisp-mode-hook ()
  (define-key lisp-mode-map &#34;\C-m&#34; &#39;reindent-then-newline-and-indent)
  (define-key lisp-mode-map &#34;\C-i&#34; &#39;lisp-indent-line)
  (define-key lisp-mode-map &#34;\C-j&#34; &#39;eval-print-last-sexp))

;; Add all of the hooks...
(add-hook &#39;c++-mode-hook &#39;my-c++-mode-hook)
(add-hook &#39;c-mode-hook &#39;my-c-mode-hook)
(add-hook &#39;scheme-mode-hook &#39;my-scheme-mode-hook)
(add-hook &#39;emacs-lisp-mode-hook &#39;my-lisp-mode-hook)
(add-hook &#39;lisp-mode-hook &#39;my-lisp-mode-hook)
(add-hook &#39;perl-mode-hook &#39;my-perl-mode-hook)

;; Complement to next-error
(defun previous-error (n)
  &#34;Visit previous compilation error message and corresponding source code.&#34;
  (interactive &#34;p&#34;)
  (next-error (- n)))

;; Misc...
(transient-mark-mode 1)
(setq mark-even-if-inactive t)
(setq visible-bell nil)
(setq next-line-add-newlines nil)
(setq compile-command &#34;make&#34;)
(setq suggest-key-bindings nil)
(put &#39;eval-expression &#39;disabled nil)
(put &#39;narrow-to-region &#39;disabled nil)
(put &#39;set-goal-column &#39;disabled nil)
(if (&gt;= emacs-major-version 21)
	(setq show-trailing-whitespace t))

;; Elisp archive searching
(autoload &#39;format-lisp-code-directory &#34;lispdir&#34; nil t)
(autoload &#39;lisp-dir-apropos &#34;lispdir&#34; nil t)
(autoload &#39;lisp-dir-retrieve &#34;lispdir&#34; nil t)
(autoload &#39;lisp-dir-verify &#34;lispdir&#34; nil t)

;; Font lock mode
(defun my-make-face (face color &amp;optional bold)
  &#34;Create a face from a color and optionally make it bold&#34;
  (make-face face)
  (copy-face &#39;default face)
  (set-face-foreground face color)
  (if bold (make-face-bold face))
  )

(if (eq window-system &#39;x)
    (progn
      (my-make-face &#39;blue &#34;blue&#34;)
      (my-make-face &#39;red &#34;red&#34;)
      (my-make-face &#39;green &#34;dark green&#34;)
      (setq font-lock-comment-face &#39;blue)
      (setq font-lock-string-face &#39;bold)
      (setq font-lock-type-face &#39;bold)
      (setq font-lock-keyword-face &#39;bold)
      (setq font-lock-function-name-face &#39;red)
      (setq font-lock-doc-string-face &#39;green)
      (add-hook &#39;find-file-hooks &#39;font-lock-auto-mode-select)

      (setq baud-rate 1000000)
      (global-set-key &#34;\C-cmm&#34; &#39;menu-bar-mode)
      (global-set-key &#34;\C-cms&#34; &#39;scroll-bar-mode)
      (global-set-key [backspace] &#39;backward-delete-char)
					;      (global-set-key [delete] &#39;delete-char)
      (standard-display-european t)
      (load-library &#34;iso-transl&#34;)))

;; X11 or PC using direct screen writes
(if window-system
    (progn
      ;;      (global-set-key [M-f1] &#39;hilit-repaint-command)
      ;;      (global-set-key [M-f2] [?\C-u M-f1])
      (setq hilit-mode-enable-list
	    &#39;(not text-mode c-mode c++-mode emacs-lisp-mode lisp-mode
		  scheme-mode)
	    hilit-auto-highlight nil
	    hilit-auto-rehighlight &#39;visible
	    hilit-inhibit-hooks nil
	    hilit-inhibit-rebinding t)
      (require &#39;hilit19)
      (require &#39;paren))
  (setq baud-rate 2400)			; For slow serial connections
  )

;; TTY type terminal
(if (and (not window-system)
	 (not (equal system-type &#39;ms-dos)))
    (progn
      (if first-time
	  (progn
	    (keyboard-translate ?\C-h ?\C-?)
	    (keyboard-translate ?\C-? ?\C-h)))))

;; Under UNIX
(if (not (equal system-type &#39;ms-dos))
    (progn
      (if first-time
	  (server-start))))

;; Add any face changes here
(add-hook &#39;term-setup-hook &#39;my-term-setup-hook)
(defun my-term-setup-hook ()
  (if (eq window-system &#39;pc)
      (progn
;;	(set-face-background &#39;default &#34;red&#34;)
	)))

;; Restore the &#34;desktop&#34; - do this as late as possible
(if first-time
    (progn
      (desktop-load-default)
      (desktop-read)))

;; Indicate that this file has been read at least once
(setq first-time nil)

;; No need to debug anything now

(setq debug-on-error nil)

;; All done
(message &#34;All done, %s%s&#34; (user-login-name) &#34;.&#34;)</pre></div></div></div></div></div><div class=sect3><h4 id=_extending_the_range_of_languages_emacs_understands>2.7.4. Extending the Range of Languages Emacs Understands<a class=anchor href=#_extending_the_range_of_languages_emacs_understands></a></h4><div class=paragraph><p>Now, this is all very well if you only want to program in the languages already catered for in <span class=filename>.emacs</span> (C, C++, Perl, Lisp and Scheme), but what happens if a new language called "whizbang" comes out, full of exciting features?</p></div><div class=paragraph><p>The first thing to do is find out if whizbang comes with any files that tell Emacs about the language. These usually end in <span class=filename>.el</span>, short for "Emacs Lisp". For example, if whizbang is a FreeBSD port, we can locate these files by doing</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% find /usr/ports/lang/whizbang <span class=nt>-name</span> <span class=s2>&#34;*.el&#34;</span> <span class=nt>-print</span></code></pre></div></div><div class=paragraph><p>and install them by copying them into the Emacs site Lisp directory. On FreeBSD, this is <span class=filename>/usr/local/shared/emacs/site-lisp</span>.</p></div><div class=paragraph><p>So for example, if the output from the find command was</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>/usr/ports/lang/whizbang/work/misc/whizbang.el</code></pre></div></div><div class=paragraph><p>we would do</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cp /usr/ports/lang/whizbang/work/misc/whizbang.el /usr/local/shared/emacs/site-lisp</span></code></pre></div></div><div class=paragraph><p>Next, we need to decide what extension whizbang source files have. Let us say for the sake of argument that they all end in <span class=filename>.wiz</span>. We need to add an entry to our <span class=filename>.emacs</span> to make sure Emacs will be able to use the information in <span class=filename>whizbang.el</span>.</p></div><div class=paragraph><p>Find the auto-mode-alist entry in <span class=filename>.emacs</span> and add a line for whizbang, such as:</p></div><div class="literalblock programlisting"><div class=content><pre>...
(&#34;\\.lsp$&#34; . lisp-mode)
(&#34;\\.wiz$&#34; . whizbang-mode)
(&#34;\\.scm$&#34; . scheme-mode)
...</pre></div></div><div class=paragraph><p>This means that Emacs will automatically go into <code>whizbang-mode</code> when you edit a file ending in <span class=filename>.wiz</span>.</p></div><div class=paragraph><p>Just below this, you will find the font-lock-auto-mode-list entry. Add <code>whizbang-mode</code> to it like so:</p></div><div class="literalblock programlisting"><div class=content><pre>;; Auto font lock mode
(defvar font-lock-auto-mode-list
  (list &#39;c-mode &#39;c++-mode &#39;c++-c-mode &#39;emacs-lisp-mode &#39;whizbang-mode &#39;lisp-mode &#39;perl-mode &#39;scheme-mode)
  &#34;List of modes to always start in font-lock-mode&#34;)</pre></div></div><div class=paragraph><p>This means that Emacs will always enable <code>font-lock-mode</code> (ie syntax highlighting) when editing a <span class=filename>.wiz</span> file.</p></div><div class=paragraph><p>And that is all that is needed. If there is anything else you want done automatically when you open up <span class=filename>.wiz</span>, you can add a <code>whizbang-mode hook</code> (see <code>my-scheme-mode-hook</code> for a simple example that adds <code>auto-indent</code>).</p></div></div></div><div class=sect2><h3 id=tools-reading>2.8. Further Reading<a class=anchor href=#tools-reading></a></h3><div class=paragraph><p>For information about setting up a development environment for contributing fixes to FreeBSD itself, please see <a href="https://man.freebsd.org/cgi/man.cgi?query=development&amp;sektion=7&amp;format=html">development(7)</a>.</p></div><div class=ulist><ul><li><p>Brian Harvey and Matthew Wright <em>Simply Scheme</em> MIT 1994. ISBN 0-262-08226-8</p></li><li><p>Randall Schwartz <em>Learning Perl</em> O’Reilly 1993 ISBN 1-56592-042-2</p></li><li><p>Patrick Henry Winston and Berthold Klaus Paul Horn <em>Lisp (3rd Edition)</em> Addison-Wesley 1989 ISBN 0-201-08319-1</p></li><li><p>Brian W. Kernighan and Rob Pike <em>The Unix Programming Environment</em> Prentice-Hall 1984 ISBN 0-13-937681-X</p></li><li><p>Brian W. Kernighan and Dennis M. Ritchie <em>The C Programming Language (2nd Edition)</em> Prentice-Hall 1988 ISBN 0-13-110362-8</p></li><li><p>Bjarne Stroustrup <em>The C++ Programming Language</em> Addison-Wesley 1991 ISBN 0-201-53992-6</p></li><li><p>W. Richard Stevens <em>Advanced Programming in the Unix Environment</em> Addison-Wesley 1992 ISBN 0-201-56317-7</p></li><li><p>W. Richard Stevens <em>Unix Network Programming</em> Prentice-Hall 1990 ISBN 0-13-949876-1</p></li></ul></div></div></div></div><div class=sect1><h2 id=secure>Chapter 3. Secure Programming<a class=anchor href=#secure></a></h2><div class=sectionbody><div class=sect2><h3 id=secure-synopsis>3.1. Synopsis<a class=anchor href=#secure-synopsis></a></h3><div class=paragraph><p>This chapter describes some of the security issues that have plagued UNIX® programmers for decades and some of the new tools available to help programmers avoid writing exploitable code.</p></div></div><div class=sect2><h3 id=secure-philosophy>3.2. Secure Design Methodology<a class=anchor href=#secure-philosophy></a></h3><div class=paragraph><p>Writing secure applications takes a very scrutinous and pessimistic outlook on life. Applications should be run with the principle of "least privilege" so that no process is ever running with more than the bare minimum access that it needs to accomplish its function. Previously tested code should be reused whenever possible to avoid common mistakes that others may have already fixed.</p></div><div class=paragraph><p>One of the pitfalls of the UNIX® environment is how easy it is to make assumptions about the sanity of the environment. Applications should never trust user input (in all its forms), system resources, inter-process communication, or the timing of events. UNIX® processes do not execute synchronously so logical operations are rarely atomic.</p></div></div><div class=sect2><h3 id=secure-bufferov>3.3. Buffer Overflows<a class=anchor href=#secure-bufferov></a></h3><div class=paragraph><p>Buffer Overflows have been around since the very beginnings of the von Neumann <a href=./#COD>1</a> architecture. They first gained widespread notoriety in 1988 with the Morris Internet worm. Unfortunately, the same basic attack remains effective today. By far the most common type of buffer overflow attack is based on corrupting the stack.</p></div><div class=paragraph><p>Most modern computer systems use a stack to pass arguments to procedures and to store local variables. A stack is a last in first out (LIFO) buffer in the high memory area of a process image. When a program invokes a function a new "stack frame" is created. This stack frame consists of the arguments passed to the function as well as a dynamic amount of local variable space. The "stack pointer" is a register that holds the current location of the top of the stack. Since this value is constantly changing as new values are pushed onto the top of the stack, many implementations also provide a "frame pointer" that is located near the beginning of a stack frame so that local variables can more easily be addressed relative to this value. <a href=./#COD>1</a> The return address for function calls is also stored on the stack, and this is the cause of stack-overflow exploits since overflowing a local variable in a function can overwrite the return address of that function, potentially allowing a malicious user to execute any code he or she wants.</p></div><div class=paragraph><p>Although stack-based attacks are by far the most common, it would also be possible to overrun the stack with a heap-based (malloc/free) attack.</p></div><div class=paragraph><p>The C programming language does not perform automatic bounds checking on arrays or pointers as many other languages do. In addition, the standard C library is filled with a handful of very dangerous functions.</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>strcpy</code>(char *dest, const char *src)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>May overflow the dest buffer</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>strcat</code>(char *dest, const char *src)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>May overflow the dest buffer</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>getwd</code>(char *buf)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>May overflow the buf buffer</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>gets</code>(char *s)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>May overflow the s buffer</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>[vf]scanf</code>(const char *format, …​)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>May overflow its arguments.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>realpath</code>(char *path, char resolved_path[])</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>May overflow the path buffer</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>[v]sprintf</code>(char *str, const char *format, …​)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>May overflow the str buffer.</p></td></tr></tbody></table><div class=sect3><h4 id=_example_buffer_overflow>3.3.1. Example Buffer Overflow<a class=anchor href=#_example_buffer_overflow></a></h4><div class=paragraph><p>The following example code contains a buffer overflow designed to overwrite the return address and skip the instruction immediately following the function call. (Inspired by <a href=./#Phrack>4</a>)</p></div><div class="literalblock programlisting"><div class=content><pre>#include &lt;stdio.h&gt;

void manipulate(char *buffer) {
  char newbuffer[80];
  strcpy(newbuffer,buffer);
}

int main() {
  char ch,buffer[4096];
  int i=0;

  while ((buffer[i++] = getchar()) != &#39;\n&#39;) {};

  i=1;
  manipulate(buffer);
  i=2;
  printf(&#34;The value of i is : %d\n&#34;,i);
  return 0;
}</pre></div></div><div class=paragraph><p>Let us examine what the memory image of this process would look like if we were to input 160 spaces into our little program before hitting return.</p></div><div class=paragraph><p>Obviously more malicious input can be devised to execute actual compiled instructions (such as exec(/bin/sh)).</p></div></div><div class=sect3><h4 id=_avoiding_buffer_overflows>3.3.2. Avoiding Buffer Overflows<a class=anchor href=#_avoiding_buffer_overflows></a></h4><div class=paragraph><p>The most straightforward solution to the problem of stack-overflows is to always use length restricted memory and string copy functions. <code>strncpy</code> and <code>strncat</code> are part of the standard C library. These functions accept a length value as a parameter which should be no larger than the size of the destination buffer. These functions will then copy up to 'length' bytes from the source to the destination. However there are a number of problems with these functions. Neither function guarantees NUL termination if the size of the input buffer is as large as the destination. The length parameter is also used inconsistently between strncpy and strncat so it is easy for programmers to get confused as to their proper usage. There is also a significant performance loss compared to <code>strcpy</code> when copying a short string into a large buffer since <code>strncpy</code> NUL fills up the size specified.</p></div><div class=paragraph><p>Another memory copy implementation exists to get around these problems. The <code>strlcpy</code> and <code>strlcat</code> functions guarantee that they will always null terminate the destination string when given a non-zero length argument.</p></div><div class=sect4><h5 id=_compiler_based_run_time_bounds_checking>3.3.2.1. Compiler based run-time bounds checking<a class=anchor href=#_compiler_based_run_time_bounds_checking></a></h5><div class=paragraph><p>Unfortunately there is still a very large assortment of code in public use which blindly copies memory around without using any of the bounded copy routines we just discussed. Fortunately, there is a way to help prevent such attacks - run-time bounds checking, which is implemented by several C/C++ compilers.</p></div><div class=paragraph><p>ProPolice is one such compiler feature, and is integrated into <a href="https://man.freebsd.org/cgi/man.cgi?query=gcc&amp;sektion=1&amp;format=html">gcc(1)</a> versions 4.1 and later. It replaces and extends the earlier StackGuard <a href="https://man.freebsd.org/cgi/man.cgi?query=gcc&amp;sektion=1&amp;format=html">gcc(1)</a> extension.</p></div><div class=paragraph><p>ProPolice helps to protect against stack-based buffer overflows and other attacks by laying pseudo-random numbers in key areas of the stack before calling any function. When a function returns, these "canaries" are checked and if they are found to have been changed the executable is immediately aborted. Thus any attempt to modify the return address or other variable stored on the stack in an attempt to get malicious code to run is unlikely to succeed, as the attacker would have to also manage to leave the pseudo-random canaries untouched.</p></div><div class=paragraph><p>Recompiling your application with ProPolice is an effective means of stopping most buffer-overflow attacks, but it can still be compromised.</p></div></div><div class=sect4><h5 id=_library_based_run_time_bounds_checking>3.3.2.2. Library based run-time bounds checking<a class=anchor href=#_library_based_run_time_bounds_checking></a></h5><div class=paragraph><p>Compiler-based mechanisms are completely useless for binary-only software for which you cannot recompile. For these situations there are a number of libraries which re-implement the unsafe functions of the C-library (<code>strcpy</code>, <code>fscanf</code>, <code>getwd</code>, etc..) and ensure that these functions can never write past the stack pointer.</p></div><div class=ulist><ul><li><p>libsafe</p></li><li><p>libverify</p></li><li><p>libparanoia</p></li></ul></div><div class=paragraph><p>Unfortunately these library-based defenses have a number of shortcomings. These libraries only protect against a very small set of security related issues and they neglect to fix the actual problem. These defenses may fail if the application was compiled with -fomit-frame-pointer. Also, the LD_PRELOAD and LD_LIBRARY_PATH environment variables can be overwritten/unset by the user.</p></div></div></div></div><div class=sect2><h3 id=secure-setuid>3.4. SetUID issues<a class=anchor href=#secure-setuid></a></h3><div class=paragraph><p>There are at least 6 different IDs associated with any given process. Because of this you have to be very careful with the access that your process has at any given time. In particular, all seteuid applications should give up their privileges as soon as it is no longer required.</p></div><div class=paragraph><p>The real user ID can only be changed by a superuser process. The login program sets this when a user initially logs in and it is seldom changed.</p></div><div class=paragraph><p>The effective user ID is set by the <code>exec()</code> functions if a program has its seteuid bit set. An application can call <code>seteuid()</code> at any time to set the effective user ID to either the real user ID or the saved set-user-ID. When the effective user ID is set by <code>exec()</code> functions, the previous value is saved in the saved set-user-ID.</p></div></div><div class=sect2><h3 id=secure-chroot>3.5. Limiting your program’s environment<a class=anchor href=#secure-chroot></a></h3><div class=paragraph><p>The traditional method of restricting a process is with the <code>chroot()</code> system call. This system call changes the root directory from which all other paths are referenced for a process and any child processes. For this call to succeed the process must have execute (search) permission on the directory being referenced. The new environment does not actually take effect until you <code>chdir()</code> into your new environment. It should also be noted that a process can easily break out of a chroot environment if it has root privilege. This could be accomplished by creating device nodes to read kernel memory, attaching a debugger to a process outside of the <a href="https://man.freebsd.org/cgi/man.cgi?query=chroot&amp;sektion=8&amp;format=html">chroot(8)</a> environment, or in many other creative ways.</p></div><div class=paragraph><p>The behavior of the <code>chroot()</code> system call can be controlled somewhat with the kern.chroot_allow_open_directories <code>sysctl</code> variable. When this value is set to 0, <code>chroot()</code> will fail with EPERM if there are any directories open. If set to the default value of 1, then <code>chroot()</code> will fail with EPERM if there are any directories open and the process is already subject to a <code>chroot()</code> call. For any other value, the check for open directories will be bypassed completely.</p></div><div class=sect3><h4 id=_freebsds_jail_functionality>3.5.1. FreeBSD’s jail functionality<a class=anchor href=#_freebsds_jail_functionality></a></h4><div class=paragraph><p>The concept of a Jail extends upon the <code>chroot()</code> by limiting the powers of the superuser to create a true `virtual server'. Once a prison is set up all network communication must take place through the specified IP address, and the power of "root privilege" in this jail is severely constrained.</p></div><div class=paragraph><p>While in a prison, any tests of superuser power within the kernel using the <code>suser()</code> call will fail. However, some calls to <code>suser()</code> have been changed to a new interface <code>suser_xxx()</code>. This function is responsible for recognizing or denying access to superuser power for imprisoned processes.</p></div><div class=paragraph><p>A superuser process within a jailed environment has the power to:</p></div><div class=ulist><ul><li><p>Manipulate credential with <code>setuid</code>, <code>seteuid</code>, <code>setgid</code>, <code>setegid</code>, <code>setgroups</code>, <code>setreuid</code>, <code>setregid</code>, <code>setlogin</code></p></li><li><p>Set resource limits with <code>setrlimit</code></p></li><li><p>Modify some sysctl nodes (kern.hostname)</p></li><li><p><code>chroot()</code></p></li><li><p>Set flags on a vnode: <code>chflags</code>, <code>fchflags</code></p></li><li><p>Set attributes of a vnode such as file permission, owner, group, size, access time, and modification time.</p></li><li><p>Bind to privileged ports in the Internet domain (ports &lt; 1024)</p></li></ul></div><div class=paragraph><p><code>Jail</code> is a very useful tool for running applications in a secure environment but it does have some shortcomings. Currently, the IPC mechanisms have not been converted to the <code>suser_xxx</code> so applications such as MySQL cannot be run within a jail. Superuser access may have a very limited meaning within a jail, but there is no way to specify exactly what "very limited" means.</p></div></div><div class=sect3><h4 id=_posix_1e_process_capabilities>3.5.2. POSIX®.1e Process Capabilities<a class=anchor href=#_posix_1e_process_capabilities></a></h4><div class=paragraph><p>POSIX® has released a working draft that adds event auditing, access control lists, fine grained privileges, information labeling, and mandatory access control.</p></div><div class=paragraph><p>This is a work in progress and is the focus of the <a href=http://www.trustedbsd.org/>TrustedBSD</a> project. Some of the initial work has been committed to FreeBSD-CURRENT (cap_set_proc(3)).</p></div></div></div><div class=sect2><h3 id=secure-trust>3.6. Trust<a class=anchor href=#secure-trust></a></h3><div class=paragraph><p>An application should never assume that anything about the users environment is sane. This includes (but is certainly not limited to): user input, signals, environment variables, resources, IPC, mmaps, the filesystem working directory, file descriptors, the # of open files, etc.</p></div><div class=paragraph><p>You should never assume that you can catch all forms of invalid input that a user might supply. Instead, your application should use positive filtering to only allow a specific subset of inputs that you deem safe. Improper data validation has been the cause of many exploits, especially with CGI scripts on the world wide web. For filenames you need to be extra careful about paths ("../", "/"), symbolic links, and shell escape characters.</p></div><div class=paragraph><p>Perl has a really cool feature called "Taint" mode which can be used to prevent scripts from using data derived outside the program in an unsafe way. This mode will check command line arguments, environment variables, locale information, the results of certain syscalls (<code>readdir()</code>, <code>readlink()</code>, <code>getpwxxx()</code>), and all file input.</p></div></div><div class=sect2><h3 id=secure-race-conditions>3.7. Race Conditions<a class=anchor href=#secure-race-conditions></a></h3><div class=paragraph><p>A race condition is anomalous behavior caused by the unexpected dependence on the relative timing of events. In other words, a programmer incorrectly assumed that a particular event would always happen before another.</p></div><div class=paragraph><p>Some of the common causes of race conditions are signals, access checks, and file opens. Signals are asynchronous events by nature so special care must be taken in dealing with them. Checking access with <code>access(2)</code> then <code>open(2)</code> is clearly non-atomic. Users can move files in between the two calls. Instead, privileged applications should <code>seteuid()</code> and then call <code>open()</code> directly. Along the same lines, an application should always set a proper umask before <code>open()</code> to obviate the need for spurious <code>chmod()</code> calls.</p></div></div></div></div><div class=sect1><h2 id=l10n>Chapter 4. Localization and Internationalization - L10N and I18N<a class=anchor href=#l10n></a></h2><div class=sectionbody><div class=sect2><h3 id=l10n-programming>4.1. Programming I18N Compliant Applications<a class=anchor href=#l10n-programming></a></h3><div class=paragraph><p>To make your application more useful for speakers of other languages, we hope that you will program I18N compliant. The GNU gcc compiler and GUI libraries like QT and GTK support I18N through special handling of strings. Making a program I18N compliant is very easy. It allows contributors to port your application to other languages quickly. Refer to the library specific I18N documentation for more details.</p></div><div class=paragraph><p>In contrast with common perception, I18N compliant code is easy to write. Usually, it only involves wrapping your strings with library specific functions. In addition, please be sure to allow for wide or multibyte character support.</p></div><div class=sect3><h4 id=_a_call_to_unify_the_i18n_effort>4.1.1. A Call to Unify the I18N Effort<a class=anchor href=#_a_call_to_unify_the_i18n_effort></a></h4><div class=paragraph><p>It has come to our attention that the individual I18N/L10N efforts for each country has been repeating each others' efforts. Many of us have been reinventing the wheel repeatedly and inefficiently. We hope that the various major groups in I18N could congregate into a group effort similar to the Core Team’s responsibility.</p></div><div class=paragraph><p>Currently, we hope that, when you write or port I18N programs, you would send it out to each country’s related FreeBSD mailing list for testing. In the future, we hope to create applications that work in all the languages out-of-the-box without dirty hacks.</p></div><div class=paragraph><p>The <a href=https://lists.FreeBSD.org/subscription/freebsd-i18n>FreeBSD internationalization 郵遞論壇</a> has been established. If you are an I18N/L10N developer, please send your comments, ideas, questions, and anything you deem related to it.</p></div></div><div class=sect3><h4 id=_perl_and_python>4.1.2. Perl and Python<a class=anchor href=#_perl_and_python></a></h4><div class=paragraph><p>Perl and Python have I18N and wide character handling libraries. Please use them for I18N compliance.</p></div></div></div><div class=sect2><h3 id=posix-nls>4.2. Localized Messages with POSIX.1 Native Language Support (NLS)<a class=anchor href=#posix-nls></a></h3><div class=paragraph><p>Beyond the basic I18N functions, like supporting various input encodings or supporting national conventions, such as the different decimal separators, at a higher level of I18N, it is possible to localize the messages written to the output by the various programs. A common way of doing this is using the POSIX.1 NLS functions, which are provided as a part of the FreeBSD base system.</p></div><div class=sect3><h4 id=nls-catalogs>4.2.1. Organizing Localized Messages into Catalog Files<a class=anchor href=#nls-catalogs></a></h4><div class=paragraph><p>POSIX.1 NLS is based on catalog files, which contain the localized messages in the desired encoding. The messages are organized into sets and each message is identified by an integer number in the containing set. The catalog files are conventionally named after the locale they contain localized messages for, followed by the <code>.msg</code> extension. For instance, the Hungarian messages for ISO8859-2 encoding should be stored in a file called <span class=filename>hu_HU.ISO8859-2</span>.</p></div><div class=paragraph><p>These catalog files are common text files that contain the numbered messages. It is possible to write comments by starting the line with a <code>$</code> sign. Set boundaries are also separated by special comments, where the keyword <code>set</code> must directly follow the <code>$</code> sign. The <code>set</code> keyword is then followed by the set number. For example:</p></div><div class="literalblock programlisting"><div class=content><pre>$set 1</pre></div></div><div class=paragraph><p>The actual message entries start with the message number and followed by the localized message. The well-known modifiers from <a href="https://man.freebsd.org/cgi/man.cgi?query=printf&amp;sektion=3&amp;format=html">printf(3)</a> are accepted:</p></div><div class="literalblock programlisting"><div class=content><pre>15 &#34;File not found: %s\n&#34;</pre></div></div><div class=paragraph><p>The language catalog files have to be compiled into a binary form before they can be opened from the program. This conversion is done with the <a href="https://man.freebsd.org/cgi/man.cgi?query=gencat&amp;sektion=1&amp;format=html">gencat(1)</a> utility. Its first argument is the filename of the compiled catalog and its further arguments are the input catalogs. The localized messages can also be organized into more catalog files and then all of them can be processed with <a href="https://man.freebsd.org/cgi/man.cgi?query=gencat&amp;sektion=1&amp;format=html">gencat(1)</a>.</p></div></div><div class=sect3><h4 id=nls-using>4.2.2. Using the Catalog Files from the Source Code<a class=anchor href=#nls-using></a></h4><div class=paragraph><p>Using the catalog files is simple. To use the related functions, <span class=filename>nl_types.h</span> must be included. Before using a catalog, it has to be opened with <a href="https://man.freebsd.org/cgi/man.cgi?query=catopen&amp;sektion=3&amp;format=html">catopen(3)</a>. The function takes two arguments. The first parameter is the name of the installed and compiled catalog. Usually, the name of the program is used, such as grep. This name will be used when looking for the compiled catalog file. The <a href="https://man.freebsd.org/cgi/man.cgi?query=catopen&amp;sektion=3&amp;format=html">catopen(3)</a> call looks for this file in <span class=filename>/usr/shared/nls/locale/catname</span> and in <span class=filename>/usr/local/shared/nls/locale/catname</span>, where <code>locale</code> is the locale set and <code>catname</code> is the catalog name being discussed. The second parameter is a constant, which can have two values:</p></div><div class=ulist><ul><li><p><code>NL_CAT_LOCALE</code>, which means that the used catalog file will be based on <code>LC_MESSAGES</code>.</p></li><li><p><code>0</code>, which means that <code>LANG</code> has to be used to open the proper catalog.</p></li></ul></div><div class=paragraph><p>The <a href="https://man.freebsd.org/cgi/man.cgi?query=catopen&amp;sektion=3&amp;format=html">catopen(3)</a> call returns a catalog identifier of type <code>nl_catd</code>. Please refer to the manual page for a list of possible returned error codes.</p></div><div class=paragraph><p>After opening a catalog <a href="https://man.freebsd.org/cgi/man.cgi?query=catgets&amp;sektion=3&amp;format=html">catgets(3)</a> can be used to retrieve a message. The first parameter is the catalog identifier returned by <a href="https://man.freebsd.org/cgi/man.cgi?query=catopen&amp;sektion=3&amp;format=html">catopen(3)</a>, the second one is the number of the set, the third one is the number of the messages, and the fourth one is a fallback message, which will be returned if the requested message cannot be retrieved from the catalog file.</p></div><div class=paragraph><p>After using the catalog file, it must be closed by calling <a href="https://man.freebsd.org/cgi/man.cgi?query=catclose&amp;sektion=3&amp;format=html">catclose(3)</a>, which has one argument, the catalog id.</p></div></div><div class=sect3><h4 id=nls-example>4.2.3. A Practical Example<a class=anchor href=#nls-example></a></h4><div class=paragraph><p>The following example will demonstrate an easy solution on how to use NLS catalogs in a flexible way.</p></div><div class=paragraph><p>The below lines need to be put into a common header file of the program, which is included into all source files where localized messages are necessary:</p></div><div class="literalblock programlisting"><div class=content><pre>#ifdef WITHOUT_NLS
#define getstr(n)	 nlsstr[n]
#else
#include nl_types.h

extern nl_catd		 catalog;
#define getstr(n)	 catgets(catalog, 1, n, nlsstr[n])
#endif

extern char		*nlsstr[];</pre></div></div><div class=paragraph><p>Next, put these lines into the global declaration part of the main source file:</p></div><div class="literalblock programlisting"><div class=content><pre>#ifndef WITHOUT_NLS
#include nl_types.h
nl_catd	 catalog;
#endif

/*
 * Default messages to use when NLS is disabled or no catalog
 * is found.
 */
char    *nlsstr[] = {
        &#34;&#34;,
/* 1*/  &#34;some random message&#34;,
/* 2*/  &#34;some other message&#34;
};</pre></div></div><div class=paragraph><p>Next come the real code snippets, which open, read, and close the catalog:</p></div><div class="literalblock programlisting"><div class=content><pre>#ifndef WITHOUT_NLS
	catalog = catopen(&#34;myapp&#34;, NL_CAT_LOCALE);
#endif

...

printf(getstr(1));

...

#ifndef WITHOUT_NLS
	catclose(catalog);
#endif</pre></div></div><div class=sect4><h5 id=_reducing_strings_to_localize>4.2.3.1. Reducing Strings to Localize<a class=anchor href=#_reducing_strings_to_localize></a></h5><div class=paragraph><p>There is a good way of reducing the strings that need to be localized by using libc error messages. This is also useful to just avoid duplication and provide consistent error messages for the common errors that can be encountered by a great many of programs.</p></div><div class=paragraph><p>First, here is an example that does not use libc error messages:</p></div><div class="literalblock programlisting"><div class=content><pre>#include err.h
...
if (!S_ISDIR(st.st_mode))
	errx(1, &#34;argument is not a directory&#34;);</pre></div></div><div class=paragraph><p>This can be transformed to print an error message by reading <code>errno</code> and printing an error message accordingly:</p></div><div class="literalblock programlisting"><div class=content><pre>#include err.h
#include errno.h
...
if (!S_ISDIR(st.st_mode)) {
	errno = ENOTDIR;
	err(1, NULL);
}</pre></div></div><div class=paragraph><p>In this example, the custom string is eliminated, thus translators will have less work when localizing the program and users will see the usual "Not a directory" error message when they encounter this error. This message will probably seem more familiar to them. Please note that it was necessary to include <span class=filename>errno.h</span> in order to directly access <code>errno</code>.</p></div><div class=paragraph><p>It is worth to note that there are cases when <code>errno</code> is set automatically by a preceding call, so it is not necessary to set it explicitly:</p></div><div class="literalblock programlisting"><div class=content><pre>#include err.h
...
if ((p = malloc(size)) == NULL)
	err(1, NULL);</pre></div></div></div></div><div class=sect3><h4 id=nls-mk>4.2.4. Making use of <span class=filename>bsd.nls.mk</span><a class=anchor href=#nls-mk></a></h4><div class=paragraph><p>Using the catalog files requires few repeatable steps, such as compiling the catalogs and installing them to the proper location. In order to simplify this process even more, <span class=filename>bsd.nls.mk</span> introduces some macros. It is not necessary to include <span class=filename>bsd.nls.mk</span> explicitly, it is pulled in from the common Makefiles, such as <span class=filename>bsd.prog.mk</span> or <span class=filename>bsd.lib.mk</span>.</p></div><div class=paragraph><p>Usually it is enough to define <code>NLSNAME</code>, which should have the catalog name mentioned as the first argument of <a href="https://man.freebsd.org/cgi/man.cgi?query=catopen&amp;sektion=3&amp;format=html">catopen(3)</a> and list the catalog files in <code>NLS</code> without their <code>.msg</code> extension. Here is an example, which makes it possible to to disable NLS when used with the code examples before. The <code>WITHOUT_NLS</code> <a href="https://man.freebsd.org/cgi/man.cgi?query=make&amp;sektion=1&amp;format=html">make(1)</a> variable has to be defined in order to build the program without NLS support.</p></div><div class="literalblock programlisting"><div class=content><pre>.if !defined(WITHOUT_NLS)
NLS=	es_ES.ISO8859-1
NLS+=	hu_HU.ISO8859-2
NLS+=	pt_BR.ISO8859-1
.else
CFLAGS+=	-DWITHOUT_NLS
.endif</pre></div></div><div class=paragraph><p>Conventionally, the catalog files are placed under the <span class=filename>nls</span> subdirectory and this is the default behavior of <span class=filename>bsd.nls.mk</span>. It is possible, though to override the location of the catalogs with the <code>NLSSRCDIR</code> <a href="https://man.freebsd.org/cgi/man.cgi?query=make&amp;sektion=1&amp;format=html">make(1)</a> variable. The default name of the precompiled catalog files also follow the naming convention mentioned before. It can be overridden by setting the <code>NLSNAME</code> variable. There are other options to fine tune the processing of the catalog files but usually it is not needed, thus they are not described here. For further information on <span class=filename>bsd.nls.mk</span>, please refer to the file itself, it is short and easy to understand.</p></div></div></div></div></div><div class=sect1><h2 id=policies>Chapter 5. Source Tree Guidelines and Policies<a class=anchor href=#policies></a></h2><div class=sectionbody><div class=paragraph><p>This chapter documents various guidelines and policies in force for the FreeBSD source tree.</p></div><div class=sect2><h3 id=policies-style>5.1. Style Guidelines<a class=anchor href=#policies-style></a></h3><div class=paragraph><p>Consistent coding style is extremely important, particularly with large projects like FreeBSD. Code should follow the FreeBSD coding styles described in <a href="https://man.freebsd.org/cgi/man.cgi?query=style&amp;sektion=9&amp;format=html">style(9)</a> and <a href="https://man.freebsd.org/cgi/man.cgi?query=style.Makefile&amp;sektion=5&amp;format=html">style.Makefile(5)</a>.</p></div></div><div class=sect2><h3 id=policies-maintainer>5.2. <code>MAINTAINER</code> on Makefiles<a class=anchor href=#policies-maintainer></a></h3><div class=paragraph><p>If a particular portion of the FreeBSD <span class=filename>src/</span> distribution is being maintained by a person or group of persons, this is communicated through an entry in <span class=filename>src/MAINTAINERS</span>. Maintainers of ports within the Ports Collection express their maintainership to the world by adding a <code>MAINTAINER</code> line to the <span class=filename>Makefile</span> of the port in question:</p></div><div class="literalblock programlisting"><div class=content><pre>MAINTAINER= email-addresses</pre></div></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>For other parts of the repository, or for sections not listed as having a maintainer, or when you are unsure who the active maintainer is, try looking at the recent commit history of the relevant parts of the source tree. It is quite often the case that a maintainer is not explicitly named, but the people who are actively working in a part of the source tree for, say, the last couple of years are interested in reviewing changes. Even if this is not specifically mentioned in the documentation or the source itself, asking for a review as a form of courtesy is a very reasonable thing to do.</p></div></td></tr></tbody></table></div><div class=paragraph><p>The role of the maintainer is as follows:</p></div><div class=ulist><ul><li><p>The maintainer owns and is responsible for that code. This means that he or she is responsible for fixing bugs and answering problem reports pertaining to that piece of the code, and in the case of contributed software, for tracking new versions, as appropriate.</p></li><li><p>Changes to directories which have a maintainer defined shall be sent to the maintainer for review before being committed. Only if the maintainer does not respond for an unacceptable period of time, to several emails, will it be acceptable to commit changes without review by the maintainer. However, it is suggested that you try to have the changes reviewed by someone else if at all possible.</p></li><li><p>It is of course not acceptable to add a person or group as maintainer unless they agree to assume this duty. On the other hand it does not have to be a committer and it can easily be a group of people.</p></li></ul></div></div><div class=sect2><h3 id=policies-contributed>5.3. Contributed Software<a class=anchor href=#policies-contributed></a></h3><div class=paragraph><p>Some parts of the FreeBSD distribution consist of software that is actively being maintained outside the FreeBSD project. For historical reasons, we call this <em>contributed</em> software. Some examples are sendmail, gcc and patch.</p></div><div class=paragraph><p>Over the last couple of years, various methods have been used in dealing with this type of software and all have some number of advantages and drawbacks. No clear winner has emerged.</p></div><div class=paragraph><p>Since this is the case, after some debate one of these methods has been selected as the "official" method and will be required for future imports of software of this kind. Furthermore, it is strongly suggested that existing contributed software converge on this model over time, as it has significant advantages over the old method, including the ability to easily obtain diffs relative to the "official" versions of the source by everyone (even without direct repository access). This will make it significantly easier to return changes to the primary developers of the contributed software.</p></div><div class=paragraph><p>Ultimately, however, it comes down to the people actually doing the work. If using this model is particularly unsuited to the package being dealt with, exceptions to these rules may be granted only with the approval of the core team and with the general consensus of the other developers. The ability to maintain the package in the future will be a key issue in the decisions.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Because it makes it harder to import future versions minor, trivial and/or cosmetic changes are <em>strongly discouraged</em> on files that are still tracking the vendor branch.</p></div></td></tr></tbody></table></div><div class=sect3><h4 id=vendor-import-svn>5.3.1. Vendor Imports with SVN<a class=anchor href=#vendor-import-svn></a></h4><div class=paragraph><p>This section describes the vendor import procedure with Subversion in details.</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p><strong>Preparing the Tree</strong></p><div class=paragraph><p>If this is your first import after the switch to SVN, you will have to flatten and clean up the vendor tree, and bootstrap merge history in the main tree. If not, you can safely omit this step.</p></div><div class=paragraph><p>During the conversion from CVS to SVN, vendor branches were imported with the same layout as the main tree. For example, the foo vendor sources ended up in <span class=filename>vendor/foo/dist/contrib/foo</span>, but it is pointless and rather inconvenient. What we really want is to have the vendor source directly in <span class=filename>vendor/foo/dist</span>, like this:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>cd </span>vendor/foo/dist/contrib/foo
% svn move <span class=si>$(</span>svn list<span class=si>)</span> ../..
% <span class=nb>cd</span> ../..
% svn remove contrib
% svn propdel <span class=nt>-R</span> svn:mergeinfo
% svn commit</code></pre></div></div><div class=paragraph><p>Note that, the <code>propdel</code> bit is necessary because starting with 1.5, Subversion will automatically add <code>svn:mergeinfo</code> to any directory you copy or move. In this case, you will not need this information, since you are not going to merge anything from the tree you deleted.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>You may want to flatten the tags as well. The procedure is exactly the same. If you do this, put off the commit until the end.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Check the <span class=filename>dist</span> tree and perform any cleanup that is deemed to be necessary. You may want to disable keyword expansion, as it makes no sense on unmodified vendor code. In some cases, it can be even be harmful.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% svn propdel svn:keywords <span class=nt>-R</span> <span class=nb>.</span>
% svn commit</code></pre></div></div><div class=paragraph><p>Bootstrapping of <code>svn:mergeinfo</code> on the target directory (in the main tree) to the revision that corresponds to the last change was made to the vendor tree prior to importing new sources is also needed:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>cd head</span>/contrib/foo
% svn merge <span class=nt>--record-only</span> ^/vendor/foo/dist@12345678 <span class=nb>.</span>
% svn commit</code></pre></div></div><div class=paragraph><p>With some shells, the <code>^</code> in the above command may need to be escaped with a backslash.</p></div></li><li><p><strong>Importing New Sources</strong></p><div class=paragraph><p>Prepare a full, clean tree of the vendor sources. With SVN, we can keep a full distribution in the vendor tree without bloating the main tree. Import everything but merge only what is needed.</p></div><div class=paragraph><p>Note that you will need to add any files that were added since the last vendor import, and remove any that were removed. To facilitate this, you should prepare sorted lists of the contents of the vendor tree and of the sources you are about to import:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>cd </span>vendor/foo/dist
% svn list <span class=nt>-R</span> | <span class=nb>grep</span> <span class=nt>-v</span> <span class=s1>&#39;/$&#39;</span> | <span class=nb>sort</span> <span class=o>&gt;</span> ../old
% <span class=nb>cd</span> ../foo-9.9
% find <span class=nb>.</span> <span class=nt>-type</span> f | <span class=nb>cut</span> <span class=nt>-c</span> 3- | <span class=nb>sort</span> <span class=o>&gt;</span> ../new</code></pre></div></div><div class=paragraph><p>With these two files, the following command will list removed files (files only in <span class=filename>old</span>):</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>comm</span> <span class=nt>-23</span> ../old ../new</code></pre></div></div><div class=paragraph><p>While the command below will list added files (files only in <span class=filename>new</span>):</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>comm</span> <span class=nt>-13</span> ../old ../new</code></pre></div></div><div class=paragraph><p>Let us put this together:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>cd </span>vendor/foo/foo-9.9
% <span class=nb>tar </span>cf - <span class=nb>.</span> | <span class=nb>tar </span>xf - <span class=nt>-C</span> ../dist
% <span class=nb>cd</span> ../dist
% <span class=nb>comm</span> <span class=nt>-23</span> ../old ../new | xargs svn remove
% <span class=nb>comm</span> <span class=nt>-13</span> ../old ../new | xargs svn add</code></pre></div></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>If there are new directories in the new distribution, the last command will fail. You will have to add the directories, and run it again. Conversely, if any directories were removed, you will have to remove them manually.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Check properties on any new files:</p></div><div class=ulist><ul><li><p>All text files should have <code>svn:eol-style</code> set to <code>native</code>.</p></li><li><p>All binary files should have <code>svn:mime-type</code> set to <code>application/octet-stream</code>, unless there is a more appropriate media type.</p></li><li><p>Executable files should have <code>svn:executable</code> set to <code>*</code>.</p></li><li><p>There should be no other properties on any file in the tree.</p><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>You are ready to commit, but you should first check the output of <code>svn stat</code> and <code>svn diff</code> to make sure everything is in order.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Once you have committed the new vendor release, you should tag it for future reference. The best and quickest way is to do it directly in the repository:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% svn copy ^/vendor/foo/dist svn_base/vendor/foo/9.9</code></pre></div></div><div class=paragraph><p>To get the new tag, you can update your working copy of <span class=filename>vendor/foo</span>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>If you choose to do the copy in the checkout instead, do not forget to remove the generated <code>svn:mergeinfo</code> as described above.</p></div></td></tr></tbody></table></div></li></ul></div></li><li><p><strong>Merging to <em>-HEAD</em></strong></p><div class=paragraph><p>After you have prepared your import, it is time to merge. Option <code>--accept=postpone</code> tells SVN not to handle merge conflicts yet, because they will be taken care of manually:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>cd head</span>/contrib/foo
% svn update
% svn merge <span class=nt>--accept</span><span class=o>=</span>postpone ^/vendor/foo/dist</code></pre></div></div><div class=paragraph><p>Resolve any conflicts, and make sure that any files that were added or removed in the vendor tree have been properly added or removed in the main tree. It is always a good idea to check differences against the vendor branch:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% svn diff <span class=nt>--no-diff-deleted</span> <span class=nt>--old</span><span class=o>=</span>^/vendor/foo/dist <span class=nt>--new</span><span class=o>=</span>.</code></pre></div></div><div class=paragraph><p><code>--no-diff-deleted</code> tells SVN not to check files that are in the vendor tree but not in the main tree.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>With SVN, there is no concept of on or off the vendor branch. If a file that previously had local modifications no longer does, just remove any left-over cruft, such as FreeBSD version tags, so it no longer shows up in diffs against the vendor tree.</p></div></td></tr></tbody></table></div><div class=paragraph><p>If any changes are required for the world to build with the new sources, make them now - and test until you are satisfied that everything build and runs correctly.</p></div></li><li><p><strong>Commit</strong></p><div class=paragraph><p>Now, you are ready to commit. Make sure you get everything in one go. Ideally, you would have done all steps in a clean tree, in which case you can just commit from the top of that tree. That is the best way to avoid surprises. If you do it properly, the tree will move atomically from a consistent state with the old code to a consistent state with the new code.</p></div></li></ol></div></div></div></div></div><div class=sect2><h3 id=policies-encumbered>5.4. Encumbered Files<a class=anchor href=#policies-encumbered></a></h3><div class=paragraph><p>It might occasionally be necessary to include an encumbered file in the FreeBSD source tree. For example, if a device requires a small piece of binary code to be loaded to it before the device will operate, and we do not have the source to that code, then the binary file is said to be encumbered. The following policies apply to including encumbered files in the FreeBSD source tree.</p></div><div class="olist arabic"><ol class=arabic><li><p>Any file which is interpreted or executed by the system CPU(s) and not in source format is encumbered.</p></li><li><p>Any file with a license more restrictive than BSD or GNU is encumbered.</p></li><li><p>A file which contains downloadable binary data for use by the hardware is not encumbered, unless (1) or (2) apply to it. It must be stored in an architecture neutral ASCII format (file2c or uuencoding is recommended).</p></li><li><p>Any encumbered file requires specific approval from the <a href=https://www.FreeBSD.org/administration/#t-core>Core Team</a> before it is added to the repository.</p></li><li><p>Encumbered files go in <span class=filename>src/contrib</span> or <span class=filename>src/sys/contrib</span>.</p></li><li><p>The entire module should be kept together. There is no point in splitting it, unless there is code-sharing with non-encumbered code.</p></li><li><p>Object files are named <span class=filename>arch/filename.o.uu></span>.</p></li><li><p>Kernel files:</p><div class="olist loweralpha"><ol class=loweralpha type=a><li><p>Should always be referenced in <span class=filename>conf/files.*</span> (for build simplicity).</p></li><li><p>Should always be in <span class=filename>LINT</span>, but the <a href=https://www.FreeBSD.org/administration/#t-core>Core Team</a> decides per case if it should be commented out or not. The <a href=https://www.FreeBSD.org/administration/#t-core>Core Team</a> can, of course, change their minds later on.</p></li><li><p>The <em>Release Engineer</em> decides whether or not it goes into the release.</p></li></ol></div></li><li><p>User-land files:</p><div class="olist loweralpha"><ol class=loweralpha type=a><li><p>The <a href=https://www.FreeBSD.org/administration/#t-core>Core team</a> decides if the code should be part of <code>make world</code>.</p></li><li><p>The <a href=https://www.FreeBSD.org/administration/#t-re>Release Engineering</a> decides if it goes into the release.</p></li></ol></div></li></ol></div></div><div class=sect2><h3 id=policies-shlib>5.5. Shared Libraries<a class=anchor href=#policies-shlib></a></h3><div class=paragraph><p>If you are adding shared library support to a port or other piece of software that does not have one, the version numbers should follow these rules. Generally, the resulting numbers will have nothing to do with the release version of the software.</p></div><div class=paragraph><p>The three principles of shared library building are:</p></div><div class=ulist><ul><li><p>Start from <code>1.0</code></p></li><li><p>If there is a change that is backwards compatible, bump minor number (note that ELF systems ignore the minor number)</p></li><li><p>If there is an incompatible change, bump major number</p></li></ul></div><div class=paragraph><p>For instance, added functions and bugfixes result in the minor version number being bumped, while deleted functions, changed function call syntax, etc. will force the major version number to change.</p></div><div class=paragraph><p>Stick to version numbers of the form major.minor (<code><em>x</em>.<em>y</em></code>). Our a.out dynamic linker does not handle version numbers of the form <code><em>x</em>.<em>y</em>.<em>z</em></code> well. Any version number after the <code><em>y</em></code> (i.e., the third digit) is totally ignored when comparing shared lib version numbers to decide which library to link with. Given two shared libraries that differ only in the "micro" revision, <code>ld.so</code> will link with the higher one. That is, if you link with <span class=filename>libfoo.so.3.3.3</span>, the linker only records <code>3.3</code> in the headers, and will link with anything starting with <code><em>libfoo.so.3</em>.<em>(anything >= 3)</em>.<em>(highest available)</em></code>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p><code>ld.so</code> will always use the highest "minor" revision. For instance, it will use <span class=filename>libc.so.2.2</span> in preference to <span class=filename>libc.so.2.0</span>, even if the program was initially linked with <span class=filename>libc.so.2.0</span>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>In addition, our ELF dynamic linker does not handle minor version numbers at all. However, one should still specify a major and minor version number as our <span class=filename>Makefile</span>'s "do the right thing" based on the type of system.</p></div><div class=paragraph><p>For non-port libraries, it is also our policy to change the shared library version number only once between releases. In addition, it is our policy to change the major shared library version number only once between major OS releases (i.e., from 6.0 to 7.0). When you make a change to a system library that requires the version number to be bumped, check the <span class=filename>Makefile</span>'s commit logs. It is the responsibility of the committer to ensure that the first such change since the release will result in the shared library version number in the <span class=filename>Makefile</span> to be updated, and any subsequent changes will not.</p></div></div></div></div><div class=sect1><h2 id=testing>Chapter 6. Regression and Performance Testing<a class=anchor href=#testing></a></h2><div class=sectionbody><div class=paragraph><p>Regression tests are used to exercise a particular bit of the system to check that it works as expected, and to make sure that old bugs are not reintroduced.</p></div><div class=paragraph><p>The FreeBSD regression testing tools can be found in the FreeBSD source tree in the directory <span class=filename>src/tools/regression</span>.</p></div><div class=sect2><h3 id=testing-micro-benchmark>6.1. Micro Benchmark Checklist<a class=anchor href=#testing-micro-benchmark></a></h3><div class=paragraph><p>This section contains hints for doing proper micro-benchmarking on FreeBSD or of FreeBSD itself.</p></div><div class=paragraph><p>It is not possible to use all of the suggestions below every single time, but the more used, the better the benchmark’s ability to test small differences will be.</p></div><div class=ulist><ul><li><p>Disable APM and any other kind of clock fiddling (ACPI ?).</p></li><li><p>Run in single user mode. E.g., <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a>, and other daemons only add noise. The <a href="https://man.freebsd.org/cgi/man.cgi?query=sshd&amp;sektion=8&amp;format=html">sshd(8)</a> daemon can also cause problems. If ssh access is required during testing either disable the SSHv1 key regeneration, or kill the parent <code>sshd</code> daemon during the tests.</p></li><li><p>Do not run <a href="https://man.freebsd.org/cgi/man.cgi?query=ntpd&amp;sektion=8&amp;format=html">ntpd(8)</a>.</p></li><li><p>If <a href="https://man.freebsd.org/cgi/man.cgi?query=syslog&amp;sektion=3&amp;format=html">syslog(3)</a> events are generated, run <a href="https://man.freebsd.org/cgi/man.cgi?query=syslogd&amp;sektion=8&amp;format=html">syslogd(8)</a> with an empty <span class=filename>/etc/syslogd.conf</span>, otherwise, do not run it.</p></li><li><p>Minimize disk-I/O, avoid it entirely if possible.</p></li><li><p>Do not mount file systems that are not needed.</p></li><li><p>Mount <span class=filename>/</span>, <span class=filename>/usr</span>, and any other file system as read-only if possible. This removes atime updates to disk (etc.) from the I/O picture.</p></li><li><p>Reinitialize the read/write test file system with <a href="https://man.freebsd.org/cgi/man.cgi?query=newfs&amp;sektion=8&amp;format=html">newfs(8)</a> and populate it from a <a href="https://man.freebsd.org/cgi/man.cgi?query=tar&amp;sektion=1&amp;format=html">tar(1)</a> or <a href="https://man.freebsd.org/cgi/man.cgi?query=dump&amp;sektion=8&amp;format=html">dump(8)</a> file before every run. Unmount and mount it before starting the test. This results in a consistent file system layout. For a worldstone test this would apply to <span class=filename>/usr/obj</span> (just reinitialize with <code>newfs</code> and mount). To get 100% reproducibility, populate the file system from a <a href="https://man.freebsd.org/cgi/man.cgi?query=dd&amp;sektion=1&amp;format=html">dd(1)</a> file (i.e.: <code>dd if=myimage of=/dev/ad0s1h bs=1m</code>)</p></li><li><p>Use malloc backed or preloaded <a href="https://man.freebsd.org/cgi/man.cgi?query=md&amp;sektion=4&amp;format=html">md(4)</a> partitions.</p></li><li><p>Reboot between individual iterations of the test, this gives a more consistent state.</p></li><li><p>Remove all non-essential device drivers from the kernel. For instance if USB is not needed for the test, do not put USB in the kernel. Drivers which attach often have timeouts ticking away.</p></li><li><p>Unconfigure hardware that are not in use. Detach disks with <a href="https://man.freebsd.org/cgi/man.cgi?query=atacontrol&amp;sektion=8&amp;format=html">atacontrol(8)</a> and <a href="https://man.freebsd.org/cgi/man.cgi?query=camcontrol&amp;sektion=8&amp;format=html">camcontrol(8)</a> if the disks are not used for the test.</p></li><li><p>Do not configure the network unless it is being tested, or wait until after the test has been performed to ship the results off to another computer.</p><div class=paragraph><p>If the system must be connected to a public network, watch out for spikes of broadcast traffic. Even though it is hardly noticeable, it will take up CPU cycles. Multicast has similar caveats.</p></div></li><li><p>Put each file system on its own disk. This minimizes jitter from head-seek optimizations.</p></li><li><p>Minimize output to serial or VGA consoles. Running output into files gives less jitter. (Serial consoles easily become a bottleneck.) Do not touch keyboard while the test is running, even <kbd>space</kbd> or <kbd>back-space</kbd> shows up in the numbers.</p></li><li><p>Make sure the test is long enough, but not too long. If the test is too short, timestamping is a problem. If it is too long temperature changes and drift will affect the frequency of the quartz crystals in the computer. Rule of thumb: more than a minute, less than an hour.</p></li><li><p>Try to keep the temperature as stable as possible around the machine. This affects both quartz crystals and disk drive algorithms. To get real stable clock, consider stabilized clock injection. E.g., get a OCXO + PLL, inject output into clock circuits instead of motherboard xtal. Contact Poul-Henning Kamp &lt;<a href=mailto:phk@FreeBSD.org>phk@FreeBSD.org</a>> for more information about this.</p></li><li><p>Run the test at least 3 times but it is better to run more than 20 times both for "before" and "after" code. Try to interleave if possible (i.e.: do not run 20 times before then 20 times after), this makes it possible to spot environmental effects. Do not interleave 1:1, but 3:3, this makes it possible to spot interaction effects.</p><div class=paragraph><p>A good pattern is: <code>bababa{bbbaaa}*</code>. This gives hint after the first 1+1 runs (so it is possible to stop the test if it goes entirely the wrong way), a standard deviation after the first 3+3 (gives a good indication if it is going to be worth a long run) and trending and interaction numbers later on.</p></div></li><li><p>Use <a href="https://man.freebsd.org/cgi/man.cgi?query=ministat&amp;sektion=1&amp;format=html">ministat(1)</a> to see if the numbers are significant. Consider buying "Cartoon guide to statistics" ISBN: 0062731025, highly recommended, if you have forgotten or never learned about standard deviation and Student’s T.</p></li><li><p>Do not use background <a href="https://man.freebsd.org/cgi/man.cgi?query=fsck&amp;sektion=8&amp;format=html">fsck(8)</a> unless the test is a benchmark of background <code>fsck</code>. Also, disable <code>background_fsck</code> in <span class=filename>/etc/rc.conf</span> unless the benchmark is not started at least 60+"<code>fsck</code> runtime" seconds after the boot, as <a href="https://man.freebsd.org/cgi/man.cgi?query=rc&amp;sektion=8&amp;format=html">rc(8)</a> wakes up and checks if <code>fsck</code> needs to run on any file systems when background <code>fsck</code> is enabled. Likewise, make sure there are no snapshots lying around unless the benchmark is a test with snapshots.</p></li><li><p>If the benchmark show unexpected bad performance, check for things like high interrupt volume from an unexpected source. Some versions of ACPI have been reported to "misbehave" and generate excess interrupts. To help diagnose odd test results, take a few snapshots of <code>vmstat -i</code> and look for anything unusual.</p></li><li><p>Make sure to be careful about optimization parameters for kernel and userspace, likewise debugging. It is easy to let something slip through and realize later the test was not comparing the same thing.</p></li><li><p>Do not ever benchmark with the <code>WITNESS</code> and <code>INVARIANTS</code> kernel options enabled unless the test is interested to benchmarking those features. <code>WITNESS</code> can cause 400%+ drops in performance. Likewise, userspace <a href="https://man.freebsd.org/cgi/man.cgi?query=malloc&amp;sektion=3&amp;format=html">malloc(3)</a> parameters default differently in -CURRENT from the way they ship in production releases.</p></li></ul></div></div><div class=sect2><h3 id=testing-tinderbox>6.2. The FreeBSD Source Tinderbox<a class=anchor href=#testing-tinderbox></a></h3><div class=paragraph><p>The source Tinderbox consists of:</p></div><div class=ulist><ul><li><p>A build script, <span class=filename>tinderbox</span>, that automates checking out a specific version of the FreeBSD source tree and building it.</p></li><li><p>A supervisor script, <span class=filename>tbmaster</span>, that monitors individual Tinderbox instances, logs their output, and emails failure notices.</p></li><li><p>A CGI script named <span class=filename>index.cgi</span> that reads a set of tbmaster logs and presents an easy-to-read HTML summary of them.</p></li><li><p>A set of build servers that continually test the tip of the most important FreeBSD code branches.</p></li><li><p>A webserver that keeps a complete set of Tinderbox logs and displays an up-to-date summary.</p></li></ul></div><div class=paragraph><p>The scripts are maintained and were developed by Dag-Erling Smørgrav &lt;<a href=mailto:des@FreeBSD.org>des@FreeBSD.org</a>>, and are now written in Perl, a move on from their original incarnation as shell scripts. All scripts and configuration files are kept in <a href=https://www.freebsd.org/cgi/cvsweb.cgi/projects/tinderbox/>/projects/tinderbox/</a>.</p></div><div class=paragraph><p>For more information about the tinderbox and tbmaster scripts at this stage, see their respective man pages: tinderbox(1) and tbmaster(1).</p></div></div><div class=sect2><h3 id=_the_index_cgi_script>6.3. The <span class=filename>index.cgi</span> Script<a class=anchor href=#_the_index_cgi_script></a></h3><div class=paragraph><p>The <span class=filename>index.cgi</span> script generates the HTML summary of tinderbox and tbmaster logs. Although originally intended to be used as a CGI script, as indicated by its name, this script can also be run from the command line or from a <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a> job, in which case it will look for logs in the directory where the script is located. It will automatically detect context, generating HTTP headers when it is run as a CGI script. It conforms to XHTML standards and is styled using CSS.</p></div><div class=paragraph><p>The script starts in the <code>main()</code> block by attempting to verify that it is running on the official Tinderbox website. If it is not, a page indicating it is not an official website is produced, and a URL to the official site is provided.</p></div><div class=paragraph><p>Next, it scans the log directory to get an inventory of configurations, branches and architectures for which log files exist, to avoid hard-coding a list into the script and potentially ending up with blank rows or columns. This information is derived from the names of the log files matching the following pattern:</p></div><div class="literalblock programlisting"><div class=content><pre>tinderbox-$config-$branch-$arch-$machine.{brief,full}</pre></div></div><div class=paragraph><p>The configurations used on the official Tinderbox build servers are named for the branches they build. For example, the <code>releng_8</code> configuration is used to build <code>RELENG_8</code> as well as all still-supported release branches.</p></div><div class=paragraph><p>Once all of this startup procedure has been successfully completed, <code>do_config()</code> is called for each configuration.</p></div><div class=paragraph><p>The <code>do_config()</code> function generates HTML for a single Tinderbox configuration.</p></div><div class=paragraph><p>It works by first generating a header row, then iterating over each branch build with the specified configuration, producing a single row of results for each in the following manner:</p></div><div class=ulist><ul><li><p>For each item:</p><div class=ulist><ul><li><p>For each machine within that architecture:</p><div class=ulist><ul><li><p>If a brief log file exists, then:</p><div class=ulist><ul><li><p>Call <code>success()</code> to determine the outcome of the build.</p></li><li><p>Output the modification size.</p></li><li><p>Output the size of the brief log file with a link to the log file itself.</p></li><li><p>If a full log file also exists, then:</p><div class=ulist><ul><li><p>Output the size of the full log file with a link to the log file itself.</p></li></ul></div></li></ul></div></li><li><p>Otherwise:</p><div class=ulist><ul><li><p>No output.</p></li></ul></div></li></ul></div></li></ul></div></li></ul></div><div class=paragraph><p>The <code>success()</code> function mentioned above scans a brief log file for the string "tinderbox run completed" in order to determine whether the build was successful.</p></div><div class=paragraph><p>Configurations and branches are sorted according to their branch rank. This is computed as follows:</p></div><div class=ulist><ul><li><p><code>HEAD</code> and <code>CURRENT</code> have rank 9999.</p></li><li><p><code>RELENG_x</code> has rank <em><code>xx</code></em>99.</p></li><li><p><code>RELENG_x_y</code> has rank <em>xxyy</em>.</p></li></ul></div><div class=paragraph><p>This means that <code>HEAD</code> always ranks highest, and <code>RELENG</code> branches are ranked in numerical order, with each <code>STABLE</code> branch ranking higher than the release branches forked off of it. For instance, for FreeBSD 8, the order from highest to lowest would be:</p></div><div class=ulist><ul><li><p><code>RELENG_8</code> (branch rank 899).</p></li><li><p><code>RELENG_8_3</code> (branch rank 803).</p></li><li><p><code>RELENG_8_2</code> (branch rank 802).</p></li><li><p><code>RELENG_8_1</code> (branch rank 801).</p></li><li><p><code>RELENG_8_0</code> (branch rank 800).</p></li></ul></div><div class=paragraph><p>The colors that Tinderbox uses for each cell in the table are defined by CSS. Successful builds are displayed with green text; unsuccessful builds are displayed with red text. The color fades as time passes since the corresponding build, with every half an hour bringing the color closer to grey.</p></div></div><div class=sect2><h3 id=_official_build_servers>6.4. Official Build Servers<a class=anchor href=#_official_build_servers></a></h3><div class=paragraph><p>The official Tinderbox build servers are hosted by <a href=http://www.sentex.ca>Sentex Data Communications</a>, who also host the FreeBSD Netperf Cluster.</p></div><div class=paragraph><p>Three build servers currently exist:</p></div><div class=paragraph><p><em>freebsd-current.sentex.ca</em> builds:</p></div><div class=ulist><ul><li><p><code>HEAD</code> for amd64, arm, i386, i386/pc98, ia64, mips, powerpc, powerpc64, and sparc64.</p></li><li><p><code>RELENG_9</code> and supported 9.<em>X</em> branches for amd64, arm, i386, i386/pc98, ia64, mips, powerpc, powerpc64, and sparc64.</p></li></ul></div><div class=paragraph><p><em>freebsd-stable.sentex.ca</em> builds:</p></div><div class=ulist><ul><li><p><code>RELENG_8</code> and supported 8.<em>X</em> branches for amd64, i386, i386/pc98, ia64, mips, powerpc and sparc64.</p></li></ul></div><div class=paragraph><p><em>freebsd-legacy.sentex.ca</em> builds:</p></div><div class=ulist><ul><li><p><code>RELENG_7</code> and supported 7.<em>X</em> branches for amd64, i386, i386/pc98, ia64, powerpc, and sparc64.</p></li></ul></div></div><div class=sect2><h3 id=_official_summary_site>6.5. Official Summary Site<a class=anchor href=#_official_summary_site></a></h3><div class=paragraph><p>Summaries and logs from the official build servers are available online at <a href=http://tinderbox.FreeBSD.org>http://tinderbox.FreeBSD.org</a>, hosted by Dag-Erling Smørgrav &lt;<a href=mailto:des@FreeBSD.org>des@FreeBSD.org</a>> and set up as follows:</p></div><div class=ulist><ul><li><p>A <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a> job checks the build servers at regular intervals and downloads any new log files using <a href="https://man.freebsd.org/cgi/man.cgi?query=rsync&amp;sektion=1&amp;format=html">rsync(1)</a>.</p></li><li><p>Apache is set up to use <span class=filename>index.cgi</span> as <code>DirectoryIndex</code>.</p></li></ul></div></div></div></div><h1 id=ipc class=sect0>Part II: Interprocess Communication(IPC)<a class=anchor href=#ipc></a></h1><div class=sect1><h2 id=sockets>Chapter 7. Sockets<a class=anchor href=#sockets></a></h2><div class=sectionbody><div class=sect2><h3 id=sockets-synopsis>7.1. Synopsis<a class=anchor href=#sockets-synopsis></a></h3><div class=paragraph><p>BSD sockets take interprocess communications to a new level. It is no longer necessary for the communicating processes to run on the same machine. They still <em>can</em>, but they do not have to.</p></div><div class=paragraph><p>Not only do these processes not have to run on the same machine, they do not have to run under the same operating system. Thanks to BSD sockets, your FreeBSD software can smoothly cooperate with a program running on a Macintosh®, another one running on a Sun™ workstation, yet another one running under Windows® 2000, all connected with an Ethernet-based local area network.</p></div><div class=paragraph><p>But your software can equally well cooperate with processes running in another building, or on another continent, inside a submarine, or a space shuttle.</p></div><div class=paragraph><p>It can also cooperate with processes that are not part of a computer (at least not in the strict sense of the word), but of such devices as printers, digital cameras, medical equipment. Just about anything capable of digital communications.</p></div></div><div class=sect2><h3 id=sockets-diversity>7.2. Networking and Diversity<a class=anchor href=#sockets-diversity></a></h3><div class=paragraph><p>We have already hinted on the <em>diversity</em> of networking. Many different systems have to talk to each other. And they have to speak the same language. They also have to <em>understand</em> the same language the same way.</p></div><div class=paragraph><p>People often think that <em>body language</em> is universal. But it is not. Back in my early teens, my father took me to Bulgaria. We were sitting at a table in a park in Sofia, when a vendor approached us trying to sell us some roasted almonds.</p></div><div class=paragraph><p>I had not learned much Bulgarian by then, so, instead of saying no, I shook my head from side to side, the "universal" body language for <em>no</em>. The vendor quickly started serving us some almonds.</p></div><div class=paragraph><p>I then remembered I had been told that in Bulgaria shaking your head sideways meant <em>yes</em>. Quickly, I started nodding my head up and down. The vendor noticed, took his almonds, and walked away. To an uninformed observer, I did not change the body language: I continued using the language of shaking and nodding my head. What changed was the <em>meaning</em> of the body language. At first, the vendor and I interpreted the same language as having completely different meaning. I had to adjust my own interpretation of that language so the vendor would understand.</p></div><div class=paragraph><p>It is the same with computers: The same symbols may have different, even outright opposite meaning. Therefore, for two computers to understand each other, they must not only agree on the same <em>language</em>, but on the same <em>interpretation</em> of the language.</p></div></div><div class=sect2><h3 id=sockets-protocols>7.3. Protocols<a class=anchor href=#sockets-protocols></a></h3><div class=paragraph><p>While various programming languages tend to have complex syntax and use a number of multi-letter reserved words (which makes them easy for the human programmer to understand), the languages of data communications tend to be very terse. Instead of multi-byte words, they often use individual <em>bits</em>. There is a very convincing reason for it: While data travels <em>inside</em> your computer at speeds approaching the speed of light, it often travels considerably slower between two computers.</p></div><div class=paragraph><p>Because the languages used in data communications are so terse, we usually refer to them as <em>protocols</em> rather than languages.</p></div><div class=paragraph><p>As data travels from one computer to another, it always uses more than one protocol. These protocols are <em>layered</em>. The data can be compared to the inside of an onion: You have to peel off several layers of "skin" to get to the data. This is best illustrated with a picture:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/developers-handbook/layers.png alt="Protocol Layers"></div></div><div class=paragraph><p>In this example, we are trying to get an image from a web page we are connected to via an Ethernet.</p></div><div class=paragraph><p>The image consists of raw data, which is simply a sequence of RGB values that our software can process, i.e., convert into an image and display on our monitor.</p></div><div class=paragraph><p>Alas, our software has no way of knowing how the raw data is organized: Is it a sequence of RGB values, or a sequence of grayscale intensities, or perhaps of CMYK encoded colors? Is the data represented by 8-bit quanta, or are they 16 bits in size, or perhaps 4 bits? How many rows and columns does the image consist of? Should certain pixels be transparent?</p></div><div class=paragraph><p>I think you get the picture…​</p></div><div class=paragraph><p>To inform our software how to handle the raw data, it is encoded as a PNG file. It could be a GIF, or a JPEG, but it is a PNG.</p></div><div class=paragraph><p>And PNG is a protocol.</p></div><div class=paragraph><p>At this point, I can hear some of you yelling, <em>"No, it is not! It is a file format!"</em></p></div><div class=paragraph><p>Well, of course it is a file format. But from the perspective of data communications, a file format is a protocol: The file structure is a <em>language</em>, a terse one at that, communicating to our <em>process</em> how the data is organized. Ergo, it is a <em>protocol</em>.</p></div><div class=paragraph><p>Alas, if all we received was the PNG file, our software would be facing a serious problem: How is it supposed to know the data is representing an image, as opposed to some text, or perhaps a sound, or what not? Secondly, how is it supposed to know the image is in the PNG format as opposed to GIF, or JPEG, or some other image format?</p></div><div class=paragraph><p>To obtain that information, we are using another protocol: HTTP. This protocol can tell us exactly that the data represents an image, and that it uses the PNG protocol. It can also tell us some other things, but let us stay focused on protocol layers here.</p></div><div class=paragraph><p>So, now we have some data wrapped in the PNG protocol, wrapped in the HTTP protocol. How did we get it from the server?</p></div><div class=paragraph><p>By using TCP/IP over Ethernet, that is how. Indeed, that is three more protocols. Instead of continuing inside out, I am now going to talk about Ethernet, simply because it is easier to explain the rest that way.</p></div><div class=paragraph><p>Ethernet is an interesting system of connecting computers in a <em>local area network</em> (LAN). Each computer has a <em>network interface card</em> (NIC), which has a unique 48-bit ID called its <em>address</em>. No two Ethernet NICs in the world have the same address.</p></div><div class=paragraph><p>These NICs are all connected with each other. Whenever one computer wants to communicate with another in the same Ethernet LAN, it sends a message over the network. Every NIC sees the message. But as part of the Ethernet <em>protocol</em>, the data contains the address of the destination NIC (among other things). So, only one of all the network interface cards will pay attention to it, the rest will ignore it.</p></div><div class=paragraph><p>But not all computers are connected to the same network. Just because we have received the data over our Ethernet does not mean it originated in our own local area network. It could have come to us from some other network (which may not even be Ethernet based) connected with our own network via the Internet.</p></div><div class=paragraph><p>All data is transferred over the Internet using IP, which stands for <em>Internet Protocol</em>. Its basic role is to let us know where in the world the data has arrived from, and where it is supposed to go to. It does not <em>guarantee</em> we will receive the data, only that we will know where it came from <em>if</em> we do receive it.</p></div><div class=paragraph><p>Even if we do receive the data, IP does not guarantee we will receive various chunks of data in the same order the other computer has sent it to us. So, we can receive the center of our image before we receive the upper left corner and after the lower right, for example.</p></div><div class=paragraph><p>It is TCP (<em>Transmission Control Protocol</em>) that asks the sender to resend any lost data and that places it all into the proper order.</p></div><div class=paragraph><p>All in all, it took <em>five</em> different protocols for one computer to communicate to another what an image looks like. We received the data wrapped into the PNG protocol, which was wrapped into the HTTP protocol, which was wrapped into the TCP protocol, which was wrapped into the IP protocol, which was wrapped into the Ethernet protocol.</p></div><div class=paragraph><p>Oh, and by the way, there probably were several other protocols involved somewhere on the way. For example, if our LAN was connected to the Internet through a dial-up call, it used the PPP protocol over the modem which used one (or several) of the various modem protocols, et cetera, et cetera, et cetera…​</p></div><div class=paragraph><p>As a developer you should be asking by now, <em>"How am I supposed to handle it all?"</em></p></div><div class=paragraph><p>Luckily for you, you are <em>not</em> supposed to handle it all. You <em>are</em> supposed to handle some of it, but not all of it. Specifically, you need not worry about the physical connection (in our case Ethernet and possibly PPP, etc). Nor do you need to handle the Internet Protocol, or the Transmission Control Protocol.</p></div><div class=paragraph><p>In other words, you do not have to do anything to receive the data from the other computer. Well, you do have to <em>ask</em> for it, but that is almost as simple as opening a file.</p></div><div class=paragraph><p>Once you have received the data, it is up to you to figure out what to do with it. In our case, you would need to understand the HTTP protocol and the PNG file structure.</p></div><div class=paragraph><p>To use an analogy, all the internetworking protocols become a gray area: Not so much because we do not understand how it works, but because we are no longer concerned about it. The sockets interface takes care of this gray area for us:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/developers-handbook/slayers.png alt="Sockets Covered Protocol Layers"></div></div><div class=paragraph><p>We only need to understand any protocols that tell us how to <em>interpret the data</em>, not how to <em>receive</em> it from another process, nor how to <em>send</em> it to another process.</p></div></div><div class=sect2><h3 id=sockets-model>7.4. The Sockets Model<a class=anchor href=#sockets-model></a></h3><div class=paragraph><p>BSD sockets are built on the basic UNIX® model: <em>Everything is a file.</em> In our example, then, sockets would let us receive an <em>HTTP file</em>, so to speak. It would then be up to us to extract the <em>PNG file</em> from it.</p></div><div class=paragraph><p>Because of the complexity of internetworking, we cannot just use the <code>open</code> system call, or the <code>open()</code> C function. Instead, we need to take several steps to "opening" a socket.</p></div><div class=paragraph><p>Once we do, however, we can start treating the <em>socket</em> the same way we treat any <em>file descriptor</em>: We can <code>read</code> from it, <code>write</code> to it, <code>pipe</code> it, and, eventually, <code>close</code> it.</p></div></div><div class=sect2><h3 id=sockets-essential-functions>7.5. Essential Socket Functions<a class=anchor href=#sockets-essential-functions></a></h3><div class=paragraph><p>While FreeBSD offers different functions to work with sockets, we only <em>need</em> four to "open" a socket. And in some cases we only need two.</p></div><div class=sect3><h4 id=sockets-client-server>7.5.1. The Client-Server Difference<a class=anchor href=#sockets-client-server></a></h4><div class=paragraph><p>Typically, one of the ends of a socket-based data communication is a <em>server</em>, the other is a <em>client</em>.</p></div><div class=sect4><h5 id=sockets-common-elements>7.5.1.1. The Common Elements<a class=anchor href=#sockets-common-elements></a></h5><div class=sect5><h6 id=sockets-socket>7.5.1.1.1. <code>socket</code><a class=anchor href=#sockets-socket></a></h6><div class=paragraph><p>The one function used by both, clients and servers, is <a href="https://man.freebsd.org/cgi/man.cgi?query=socket&amp;sektion=2&amp;format=html">socket(2)</a>. It is declared this way:</p></div><div class="literalblock programlisting"><div class=content><pre>int socket(int domain, int type, int protocol);</pre></div></div><div class=paragraph><p>The return value is of the same type as that of <code>open</code>, an integer. FreeBSD allocates its value from the same pool as that of file handles. That is what allows sockets to be treated the same way as files.</p></div><div class=paragraph><p>The <code>domain</code> argument tells the system what <em>protocol family</em> you want it to use. Many of them exist, some are vendor specific, others are very common. They are declared in <span class=filename>sys/socket.h</span>.</p></div><div class=paragraph><p>Use <code>PF_INET</code> for UDP, TCP and other Internet protocols (IPv4).</p></div><div class=paragraph><p>Five values are defined for the <code>type</code> argument, again, in <span class=filename>sys/socket.h</span>. All of them start with “SOCK_”. The most common one is <code>SOCK_STREAM</code>, which tells the system you are asking for a <em>reliable stream delivery service</em> (which is TCP when used with <code>PF_INET</code>).</p></div><div class=paragraph><p>If you asked for <code>SOCK_DGRAM</code>, you would be requesting a <em>connectionless datagram delivery service</em> (in our case, UDP).</p></div><div class=paragraph><p>If you wanted to be in charge of the low-level protocols (such as IP), or even network interfaces (e.g., the Ethernet), you would need to specify <code>SOCK_RAW</code>.</p></div><div class=paragraph><p>Finally, the <code>protocol</code> argument depends on the previous two arguments, and is not always meaningful. In that case, use <code>0</code> for its value.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=title>The Unconnected Socket</div><div class=paragraph><p>Nowhere, in the <code>socket</code> function have we specified to what other system we should be connected. Our newly created socket remains <em>unconnected</em>.</p></div><div class=paragraph><p>This is on purpose: To use a telephone analogy, we have just attached a modem to the phone line. We have neither told the modem to make a call, nor to answer if the phone rings.</p></div></td></tr></tbody></table></div></div><div class=sect5><h6 id=sockets-sockaddr>7.5.1.1.2. <code>sockaddr</code><a class=anchor href=#sockets-sockaddr></a></h6><div class=paragraph><p>Various functions of the sockets family expect the address of (or pointer to, to use C terminology) a small area of the memory. The various C declarations in the <span class=filename>sys/socket.h</span> refer to it as <code>struct sockaddr</code>. This structure is declared in the same file:</p></div><div class="literalblock programlisting"><div class=content><pre>/*
 * Structure used by kernel to store most
 * addresses.
 */
struct sockaddr {
	unsigned char	sa_len;		/* total length */
	sa_family_t	sa_family;	/* address family */
	char		sa_data[14];	/* actually longer; address value */
};
#define	SOCK_MAXADDRLEN	255		/* longest possible addresses */</pre></div></div><div class=paragraph><p>Please note the <em>vagueness</em> with which the <code>sa_data</code> field is declared, just as an array of <code>14</code> bytes, with the comment hinting there can be more than <code>14</code> of them.</p></div><div class=paragraph><p>This vagueness is quite deliberate. Sockets is a very powerful interface. While most people perhaps think of it as nothing more than the Internet interface-and most applications probably use it for that nowadays-sockets can be used for just about <em>any</em> kind of interprocess communications, of which the Internet (or, more precisely, IP) is only one.</p></div><div class=paragraph><p>The <span class=filename>sys/socket.h</span> refers to the various types of protocols sockets will handle as <em>address families</em>, and lists them right before the definition of <code>sockaddr</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>/*
 * Address families.
 */
#define	AF_UNSPEC	0		/* unspecified */
#define	AF_LOCAL	1		/* local to host (pipes, portals) */
#define	AF_UNIX		AF_LOCAL	/* backward compatibility */
#define	AF_INET		2		/* internetwork: UDP, TCP, etc. */
#define	AF_IMPLINK	3		/* arpanet imp addresses */
#define	AF_PUP		4		/* pup protocols: e.g. BSP */
#define	AF_CHAOS	5		/* mit CHAOS protocols */
#define	AF_NS		6		/* XEROX NS protocols */
#define	AF_ISO		7		/* ISO protocols */
#define	AF_OSI		AF_ISO
#define	AF_ECMA		8		/* European computer manufacturers */
#define	AF_DATAKIT	9		/* datakit protocols */
#define	AF_CCITT	10		/* CCITT protocols, X.25 etc */
#define	AF_SNA		11		/* IBM SNA */
#define AF_DECnet	12		/* DECnet */
#define AF_DLI		13		/* DEC Direct data link interface */
#define AF_LAT		14		/* LAT */
#define	AF_HYLINK	15		/* NSC Hyperchannel */
#define	AF_APPLETALK	16		/* Apple Talk */
#define	AF_ROUTE	17		/* Internal Routing Protocol */
#define	AF_LINK		18		/* Link layer interface */
#define	pseudo_AF_XTP	19		/* eXpress Transfer Protocol (no AF) */
#define	AF_COIP		20		/* connection-oriented IP, aka ST II */
#define	AF_CNT		21		/* Computer Network Technology */
#define pseudo_AF_RTIP	22		/* Help Identify RTIP packets */
#define	AF_IPX		23		/* Novell Internet Protocol */
#define	AF_SIP		24		/* Simple Internet Protocol */
#define	pseudo_AF_PIP	25		/* Help Identify PIP packets */
#define	AF_ISDN		26		/* Integrated Services Digital Network*/
#define	AF_E164		AF_ISDN		/* CCITT E.164 recommendation */
#define	pseudo_AF_KEY	27		/* Internal key-management function */
#define	AF_INET6	28		/* IPv6 */
#define	AF_NATM		29		/* native ATM access */
#define	AF_ATM		30		/* ATM */
#define pseudo_AF_HDRCMPLT 31		/* Used by BPF to not rewrite headers
					 * in interface output routine
					 */
#define	AF_NETGRAPH	32		/* Netgraph sockets */
#define	AF_SLOW		33		/* 802.3ad slow protocol */
#define	AF_SCLUSTER	34		/* Sitara cluster protocol */
#define	AF_ARP		35
#define	AF_BLUETOOTH	36		/* Bluetooth sockets */
#define	AF_MAX		37</pre></div></div><div class=paragraph><p>The one used for IP is AF_INET. It is a symbol for the constant <code>2</code>.</p></div><div class=paragraph><p>It is the <em>address family</em> listed in the <code>sa_family</code> field of <code>sockaddr</code> that decides how exactly the vaguely named bytes of <code>sa_data</code> will be used.</p></div><div class=paragraph><p>Specifically, whenever the <em>address family</em> is AF_INET, we can use <code>struct sockaddr_in</code> found in <span class=filename>netinet/in.h</span>, wherever <code>sockaddr</code> is expected:</p></div><div class="literalblock programlisting"><div class=content><pre>/*
 * Socket address, internet style.
 */
struct sockaddr_in {
	uint8_t		sin_len;
	sa_family_t	sin_family;
	in_port_t	sin_port;
	struct	in_addr sin_addr;
	char	sin_zero[8];
};</pre></div></div><div class=paragraph><p>We can visualize its organization this way:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/developers-handbook/sain.png alt=sockaddr_in></div></div><div class=paragraph><p>The three important fields are <code>sin_family</code>, which is byte 1 of the structure, <code>sin_port</code>, a 16-bit value found in bytes 2 and 3, and <code>sin_addr</code>, a 32-bit integer representation of the IP address, stored in bytes 4-7.</p></div><div class=paragraph><p>Now, let us try to fill it out. Let us assume we are trying to write a client for the <em>daytime</em> protocol, which simply states that its server will write a text string representing the current date and time to port 13. We want to use TCP/IP, so we need to specify <code>AF_INET</code> in the address family field. <code>AF_INET</code> is defined as <code>2</code>. Let us use the IP address of <code>192.43.244.18</code>, which is the time server of US federal government (<code>time.nist.gov</code>).</p></div><div class=imageblock><div class=content><img src=../../../../images/books/developers-handbook/sainfill.png alt="Specific example of sockaddr_in"></div></div><div class=paragraph><p>By the way the <code>sin_addr</code> field is declared as being of the <code>struct in_addr</code> type, which is defined in <span class=filename>netinet/in.h</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>/*
 * Internet address (a structure for historical reasons)
 */
struct in_addr {
	in_addr_t s_addr;
};</pre></div></div><div class=paragraph><p>In addition, <code>in_addr_t</code> is a 32-bit integer.</p></div><div class=paragraph><p>The <code>192.43.244.18</code> is just a convenient notation of expressing a 32-bit integer by listing all of its 8-bit bytes, starting with the <em>most significant</em> one.</p></div><div class=paragraph><p>So far, we have viewed <code>sockaddr</code> as an abstraction. Our computer does not store <code>short</code> integers as a single 16-bit entity, but as a sequence of 2 bytes. Similarly, it stores 32-bit integers as a sequence of 4 bytes.</p></div><div class=paragraph><p>Suppose we coded something like this:</p></div><div class="literalblock programlisting"><div class=content><pre>sa.sin_family      = AF_INET;
sa.sin_port        = 13;
sa.sin_addr.s_addr = (((((192 &lt;&lt; 8) | 43) &lt;&lt; 8) | 244) &lt;&lt; 8) | 18;</pre></div></div><div class=paragraph><p>What would the result look like?</p></div><div class=paragraph><p>Well, that depends, of course. On a Pentium®, or other x86, based computer, it would look like this:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/developers-handbook/sainlsb.png alt="sockaddr_in on an Intel system"></div></div><div class=paragraph><p>On a different system, it might look like this:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/developers-handbook/sainmsb.png alt="sockaddr_in on an MSB system"></div></div><div class=paragraph><p>And on a PDP it might look different yet. But the above two are the most common ways in use today.</p></div><div class=paragraph><p>Ordinarily, wanting to write portable code, programmers pretend that these differences do not exist. And they get away with it (except when they code in assembly language). Alas, you cannot get away with it that easily when coding for sockets.</p></div><div class=paragraph><p>Why?</p></div><div class=paragraph><p>Because when communicating with another computer, you usually do not know whether it stores data <em>most significant byte</em> (MSB) or <em>least significant byte</em> (LSB) first.</p></div><div class=paragraph><p>You might be wondering, <em>"So, will sockets not handle it for me?"</em></p></div><div class=paragraph><p>It will not.</p></div><div class=paragraph><p>While that answer may surprise you at first, remember that the general sockets interface only understands the <code>sa_len</code> and <code>sa_family</code> fields of the <code>sockaddr</code> structure. You do not have to worry about the byte order there (of course, on FreeBSD <code>sa_family</code> is only 1 byte anyway, but many other UNIX® systems do not have <code>sa_len</code> and use 2 bytes for <code>sa_family</code>, and expect the data in whatever order is native to the computer).</p></div><div class=paragraph><p>But the rest of the data is just <code>sa_data[14]</code> as far as sockets goes. Depending on the <em>address family</em>, sockets just forwards that data to its destination.</p></div><div class=paragraph><p>Indeed, when we enter a port number, it is because we want the other computer to know what service we are asking for. And, when we are the server, we read the port number so we know what service the other computer is expecting from us. Either way, sockets only has to forward the port number as data. It does not interpret it in any way.</p></div><div class=paragraph><p>Similarly, we enter the IP address to tell everyone on the way where to send our data to. Sockets, again, only forwards it as data.</p></div><div class=paragraph><p>That is why, we (the <em>programmers</em>, not the <em>sockets</em>) have to distinguish between the byte order used by our computer and a conventional byte order to send the data in to the other computer.</p></div><div class=paragraph><p>We will call the byte order our computer uses the <em>host byte order</em>, or just the <em>host order</em>.</p></div><div class=paragraph><p>There is a convention of sending the multi-byte data over IP <em>MSB first</em>. This, we will refer to as the <em>network byte order</em>, or simply the <em>network order</em>.</p></div><div class=paragraph><p>Now, if we compiled the above code for an Intel based computer, our <em>host byte order</em> would produce:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/developers-handbook/sainlsb.png alt="Host byte order on an Intel system"></div></div><div class=paragraph><p>But the <em>network byte order</em> requires that we store the data MSB first:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/developers-handbook/sainmsb.png alt="Network byte order"></div></div><div class=paragraph><p>Unfortunately, our <em>host order</em> is the exact opposite of the <em>network order</em>.</p></div><div class=paragraph><p>We have several ways of dealing with it. One would be to <em>reverse</em> the values in our code:</p></div><div class="literalblock programlisting"><div class=content><pre>sa.sin_family      = AF_INET;
sa.sin_port        = 13 &lt;&lt; 8;
sa.sin_addr.s_addr = (((((18 &lt;&lt; 8) | 244) &lt;&lt; 8) | 43) &lt;&lt; 8) | 192;</pre></div></div><div class=paragraph><p>This will <em>trick</em> our compiler into storing the data in the <em>network byte order</em>. In some cases, this is exactly the way to do it (e.g., when programming in assembly language). In most cases, however, it can cause a problem.</p></div><div class=paragraph><p>Suppose, you wrote a sockets-based program in C. You know it is going to run on a Pentium®, so you enter all your constants in reverse and force them to the <em>network byte order</em>. It works well.</p></div><div class=paragraph><p>Then, some day, your trusted old Pentium® becomes a rusty old Pentium®. You replace it with a system whose <em>host order</em> is the same as the <em>network order</em>. You need to recompile all your software. All of your software continues to perform well, except the one program you wrote.</p></div><div class=paragraph><p>You have since forgotten that you had forced all of your constants to the opposite of the <em>host order</em>. You spend some quality time tearing out your hair, calling the names of all gods you ever heard of (and some you made up), hitting your monitor with a nerf bat, and performing all the other traditional ceremonies of trying to figure out why something that has worked so well is suddenly not working at all.</p></div><div class=paragraph><p>Eventually, you figure it out, say a couple of swear words, and start rewriting your code.</p></div><div class=paragraph><p>Luckily, you are not the first one to face the problem. Someone else has created the <a href="https://man.freebsd.org/cgi/man.cgi?query=htons&amp;sektion=3&amp;format=html">htons(3)</a> and <a href="https://man.freebsd.org/cgi/man.cgi?query=htonl&amp;sektion=3&amp;format=html">htonl(3)</a> C functions to convert a <code>short</code> and <code>long</code> respectively from the <em>host byte order</em> to the <em>network byte order</em>, and the <a href="https://man.freebsd.org/cgi/man.cgi?query=ntohs&amp;sektion=3&amp;format=html">ntohs(3)</a> and <a href="https://man.freebsd.org/cgi/man.cgi?query=ntohl&amp;sektion=3&amp;format=html">ntohl(3)</a> C functions to go the other way.</p></div><div class=paragraph><p>On <em>MSB-first</em> systems these functions do nothing. On <em>LSB-first</em> systems they convert values to the proper order.</p></div><div class=paragraph><p>So, regardless of what system your software is compiled on, your data will end up in the correct order if you use these functions.</p></div></div></div><div class=sect4><h5 id=sockets-client-functions>7.5.1.2. Client Functions<a class=anchor href=#sockets-client-functions></a></h5><div class=paragraph><p>Typically, the client initiates the connection to the server. The client knows which server it is about to call: It knows its IP address, and it knows the <em>port</em> the server resides at. It is akin to you picking up the phone and dialing the number (the <em>address</em>), then, after someone answers, asking for the person in charge of wingdings (the <em>port</em>).</p></div><div class=sect5><h6 id=sockets-connect>7.5.1.2.1. <code>connect</code><a class=anchor href=#sockets-connect></a></h6><div class=paragraph><p>Once a client has created a socket, it needs to connect it to a specific port on a remote system. It uses <a href="https://man.freebsd.org/cgi/man.cgi?query=connect&amp;sektion=2&amp;format=html">connect(2)</a>:</p></div><div class="literalblock programlisting"><div class=content><pre>int connect(int s, const struct sockaddr *name, socklen_t namelen);</pre></div></div><div class=paragraph><p>The <code>s</code> argument is the socket, i.e., the value returned by the <code>socket</code> function. The <code>name</code> is a pointer to <code>sockaddr</code>, the structure we have talked about extensively. Finally, <code>namelen</code> informs the system how many bytes are in our <code>sockaddr</code> structure.</p></div><div class=paragraph><p>If <code>connect</code> is successful, it returns <code>0</code>. Otherwise it returns <code>-1</code> and stores the error code in <code>errno</code>.</p></div><div class=paragraph><p>There are many reasons why <code>connect</code> may fail. For example, with an attempt to an Internet connection, the IP address may not exist, or it may be down, or just too busy, or it may not have a server listening at the specified port. Or it may outright <em>refuse</em> any request for specific code.</p></div></div><div class=sect5><h6 id=sockets-first-client>7.5.1.2.2. Our First Client<a class=anchor href=#sockets-first-client></a></h6><div class=paragraph><p>We now know enough to write a very simple client, one that will get current time from <code>192.43.244.18</code> and print it to <span class=filename>stdout</span>.</p></div><div class="literalblock programlisting"><div class=content><pre>/*
 * daytime.c
 *
 * Programmed by G. Adam Stanislav
 */
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;

int main() {
  register int s;
  register int bytes;
  struct sockaddr_in sa;
  char buffer[BUFSIZ+1];

  if ((s = socket(PF_INET, SOCK_STREAM, 0)) &lt; 0) {
    perror(&#34;socket&#34;);
    return 1;
  }

  bzero(&amp;sa, sizeof sa);

  sa.sin_family = AF_INET;
  sa.sin_port = htons(13);
  sa.sin_addr.s_addr = htonl((((((192 &lt;&lt; 8) | 43) &lt;&lt; 8) | 244) &lt;&lt; 8) | 18);
  if (connect(s, (struct sockaddr *)&amp;sa, sizeof sa) &lt; 0) {
    perror(&#34;connect&#34;);
    close(s);
    return 2;
  }

  while ((bytes = read(s, buffer, BUFSIZ)) &gt; 0)
    write(1, buffer, bytes);

  close(s);
  return 0;
}</pre></div></div><div class=paragraph><p>Go ahead, enter it in your editor, save it as <span class=filename>daytime.c</span>, then compile and run it:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% cc <span class=nt>-O3</span> <span class=nt>-o</span> daytime daytime.c
% ./daytime

52079 01-06-19 02:29:25 50 0 1 543.9 UTC<span class=o>(</span>NIST<span class=o>)</span> <span class=k>*</span>
%</code></pre></div></div><div class=paragraph><p>In this case, the date was June 19, 2001, the time was 02:29:25 UTC. Naturally, your results will vary.</p></div></div></div><div class=sect4><h5 id=sockets-server-functions>7.5.1.3. Server Functions<a class=anchor href=#sockets-server-functions></a></h5><div class=paragraph><p>The typical server does not initiate the connection. Instead, it waits for a client to call it and request services. It does not know when the client will call, nor how many clients will call. It may be just sitting there, waiting patiently, one moment, The next moment, it can find itself swamped with requests from a number of clients, all calling in at the same time.</p></div><div class=paragraph><p>The sockets interface offers three basic functions to handle this.</p></div><div class=sect5><h6 id=sockets-bind>7.5.1.3.1. <code>bind</code><a class=anchor href=#sockets-bind></a></h6><div class=paragraph><p>Ports are like extensions to a phone line: After you dial a number, you dial the extension to get to a specific person or department.</p></div><div class=paragraph><p>There are 65535 IP ports, but a server usually processes requests that come in on only one of them. It is like telling the phone room operator that we are now at work and available to answer the phone at a specific extension. We use <a href="https://man.freebsd.org/cgi/man.cgi?query=bind&amp;sektion=2&amp;format=html">bind(2)</a> to tell sockets which port we want to serve.</p></div><div class="literalblock programlisting"><div class=content><pre>int bind(int s, const struct sockaddr *addr, socklen_t addrlen);</pre></div></div><div class=paragraph><p>Beside specifying the port in <code>addr</code>, the server may include its IP address. However, it can just use the symbolic constant INADDR_ANY to indicate it will serve all requests to the specified port regardless of what its IP address is. This symbol, along with several similar ones, is declared in <span class=filename>netinet/in.h</span></p></div><div class="literalblock programlisting"><div class=content><pre>#define	INADDR_ANY		(u_int32_t)0x00000000</pre></div></div><div class=paragraph><p>Suppose we were writing a server for the <em>daytime</em> protocol over TCP/IP. Recall that it uses port 13. Our <code>sockaddr_in</code> structure would look like this:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/developers-handbook/sainserv.png alt="Example Server sockaddr_in"></div></div></div><div class=sect5><h6 id=sockets-listen>7.5.1.3.2. <code>listen</code><a class=anchor href=#sockets-listen></a></h6><div class=paragraph><p>To continue our office phone analogy, after you have told the phone central operator what extension you will be at, you now walk into your office, and make sure your own phone is plugged in and the ringer is turned on. Plus, you make sure your call waiting is activated, so you can hear the phone ring even while you are talking to someone.</p></div><div class=paragraph><p>The server ensures all of that with the <a href="https://man.freebsd.org/cgi/man.cgi?query=listen&amp;sektion=2&amp;format=html">listen(2)</a> function.</p></div><div class="literalblock programlisting"><div class=content><pre>int listen(int s, int backlog);</pre></div></div><div class=paragraph><p>In here, the <code>backlog</code> variable tells sockets how many incoming requests to accept while you are busy processing the last request. In other words, it determines the maximum size of the queue of pending connections.</p></div></div><div class=sect5><h6 id=sockets-accept>7.5.1.3.3. <code>accept</code><a class=anchor href=#sockets-accept></a></h6><div class=paragraph><p>After you hear the phone ringing, you accept the call by answering the call. You have now established a connection with your client. This connection remains active until either you or your client hang up.</p></div><div class=paragraph><p>The server accepts the connection by using the <a href="https://man.freebsd.org/cgi/man.cgi?query=accept&amp;sektion=2&amp;format=html">accept(2)</a> function.</p></div><div class="literalblock programlisting"><div class=content><pre>int accept(int s, struct sockaddr *addr, socklen_t *addrlen);</pre></div></div><div class=paragraph><p>Note that this time <code>addrlen</code> is a pointer. This is necessary because in this case it is the socket that fills out <code>addr</code>, the <code>sockaddr_in</code> structure.</p></div><div class=paragraph><p>The return value is an integer. Indeed, the <code>accept</code> returns a <em>new socket</em>. You will use this new socket to communicate with the client.</p></div><div class=paragraph><p>What happens to the old socket? It continues to listen for more requests (remember the <code>backlog</code> variable we passed to <code>listen</code>?) until we <code>close</code> it.</p></div><div class=paragraph><p>Now, the new socket is meant only for communications. It is fully connected. We cannot pass it to <code>listen</code> again, trying to accept additional connections.</p></div></div><div class=sect5><h6 id=sockets-first-server>7.5.1.3.4. Our First Server<a class=anchor href=#sockets-first-server></a></h6><div class=paragraph><p>Our first server will be somewhat more complex than our first client was: Not only do we have more sockets functions to use, but we need to write it as a daemon.</p></div><div class=paragraph><p>This is best achieved by creating a <em>child process</em> after binding the port. The main process then exits and returns control to the shell (or whatever program invoked it).</p></div><div class=paragraph><p>The child calls <code>listen</code>, then starts an endless loop, which accepts a connection, serves it, and eventually closes its socket.</p></div><div class="literalblock programlisting"><div class=content><pre>/*
 * daytimed - a port 13 server
 *
 * Programmed by G. Adam Stanislav
 * June 19, 2001
 */
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;time.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;

#define BACKLOG 4

int main() {
    register int s, c;
    int b;
    struct sockaddr_in sa;
    time_t t;
    struct tm *tm;
    FILE *client;

    if ((s = socket(PF_INET, SOCK_STREAM, 0)) &lt; 0) {
        perror(&#34;socket&#34;);
        return 1;
    }

    bzero(&amp;sa, sizeof sa);

    sa.sin_family = AF_INET;
    sa.sin_port   = htons(13);

    if (INADDR_ANY)
        sa.sin_addr.s_addr = htonl(INADDR_ANY);

    if (bind(s, (struct sockaddr *)&amp;sa, sizeof sa) &lt; 0) {
        perror(&#34;bind&#34;);
        return 2;
    }

    switch (fork()) {
        case -1:
            perror(&#34;fork&#34;);
            return 3;
            break;
        default:
            close(s);
            return 0;
            break;
        case 0:
            break;
    }

    listen(s, BACKLOG);

    for (;;) {
        b = sizeof sa;

        if ((c = accept(s, (struct sockaddr *)&amp;sa, &amp;b)) &lt; 0) {
            perror(&#34;daytimed accept&#34;);
            return 4;
        }

        if ((client = fdopen(c, &#34;w&#34;)) == NULL) {
            perror(&#34;daytimed fdopen&#34;);
            return 5;
        }

        if ((t = time(NULL)) &lt; 0) {
            perror(&#34;daytimed time&#34;);

            return 6;
        }

        tm = gmtime(&amp;t);
        fprintf(client, &#34;%.4i-%.2i-%.2iT%.2i:%.2i:%.2iZ\n&#34;,
            tm-&gt;tm_year + 1900,
            tm-&gt;tm_mon + 1,
            tm-&gt;tm_mday,
            tm-&gt;tm_hour,
            tm-&gt;tm_min,
            tm-&gt;tm_sec);

        fclose(client);
    }
}</pre></div></div><div class=paragraph><p>We start by creating a socket. Then we fill out the <code>sockaddr_in</code> structure in <code>sa</code>. Note the conditional use of INADDR_ANY:</p></div><div class="literalblock programlisting"><div class=content><pre>if (INADDR_ANY)
        sa.sin_addr.s_addr = htonl(INADDR_ANY);</pre></div></div><div class=paragraph><p>Its value is <code>0</code>. Since we have just used <code>bzero</code> on the entire structure, it would be redundant to set it to <code>0</code> again. But if we port our code to some other system where INADDR_ANY is perhaps not a zero, we need to assign it to <code>sa.sin_addr.s_addr</code>. Most modern C compilers are clever enough to notice that INADDR_ANY is a constant. As long as it is a zero, they will optimize the entire conditional statement out of the code.</p></div><div class=paragraph><p>After we have called <code>bind</code> successfully, we are ready to become a <em>daemon</em>: We use <code>fork</code> to create a child process. In both, the parent and the child, the <code>s</code> variable is our socket. The parent process will not need it, so it calls <code>close</code>, then it returns <code>0</code> to inform its own parent it had terminated successfully.</p></div><div class=paragraph><p>Meanwhile, the child process continues working in the background. It calls <code>listen</code> and sets its backlog to <code>4</code>. It does not need a large value here because <em>daytime</em> is not a protocol many clients request all the time, and because it can process each request instantly anyway.</p></div><div class=paragraph><p>Finally, the daemon starts an endless loop, which performs the following steps:</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Call <code>accept</code>. It waits here until a client contacts it. At that point, it receives a new socket, <code>c</code>, which it can use to communicate with this particular client.</p></li><li><p>It uses the C function <code>fdopen</code> to turn the socket from a low-level <em>file descriptor</em> to a C-style <code>FILE</code> pointer. This will allow the use of <code>fprintf</code> later on.</p></li><li><p>It checks the time, and prints it in the <em>ISO 8601</em> format to the <code>client</code> "file". It then uses <code>fclose</code> to close the file. That will automatically close the socket as well.</p></li></ol></div></div></div><div class=paragraph><p>We can <em>generalize</em> this, and use it as a model for many other servers:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/developers-handbook/serv.png alt="Sequential Server"></div></div><div class=paragraph><p>This flowchart is good for <em>sequential servers</em>, i.e., servers that can serve one client at a time, just as we were able to with our <em>daytime</em> server. This is only possible whenever there is no real "conversation" going on between the client and the server: As soon as the server detects a connection to the client, it sends out some data and closes the connection. The entire operation may take nanoseconds, and it is finished.</p></div><div class=paragraph><p>The advantage of this flowchart is that, except for the brief moment after the parent <code>fork</code>s and before it exits, there is always only one <em>process</em> active: Our server does not take up much memory and other system resources.</p></div><div class=paragraph><p>Note that we have added <em>initialize daemon</em> in our flowchart. We did not need to initialize our own daemon, but this is a good place in the flow of the program to set up any <code>signal</code> handlers, open any files we may need, etc.</p></div><div class=paragraph><p>Just about everything in the flow chart can be used literally on many different servers. The <em>serve</em> entry is the exception. We think of it as a <em>"black box"</em>, i.e., something you design specifically for your own server, and just "plug it into the rest."</p></div><div class=paragraph><p>Not all protocols are that simple. Many receive a request from the client, reply to it, then receive another request from the same client. Because of that, they do not know in advance how long they will be serving the client. Such servers usually start a new process for each client. While the new process is serving its client, the daemon can continue listening for more connections.</p></div><div class=paragraph><p>Now, go ahead, save the above source code as <span class=filename>daytimed.c</span> (it is customary to end the names of daemons with the letter <code>d</code>). After you have compiled it, try running it:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ./daytimed
<span class=nb>bind</span>: Permission denied
%</code></pre></div></div><div class=paragraph><p>What happened here? As you will recall, the <em>daytime</em> protocol uses port 13. But all ports below 1024 are reserved to the superuser (otherwise, anyone could start a daemon pretending to serve a commonly used port, while causing a security breach).</p></div><div class=paragraph><p>Try again, this time as the superuser:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ./daytimed</span>
<span class=c>#</span></code></pre></div></div><div class=paragraph><p>What…​ Nothing? Let us try again:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ./daytimed</span>

<span class=nb>bind</span>: Address already <span class=k>in </span>use
<span class=c>#</span></code></pre></div></div><div class=paragraph><p>Every port can only be bound by one program at a time. Our first attempt was indeed successful: It started the child daemon and returned quietly. It is still running and will continue to run until you either kill it, or any of its system calls fail, or you reboot the system.</p></div><div class=paragraph><p>Fine, we know it is running in the background. But is it working? How do we know it is a proper <em>daytime</em> server? Simple:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% telnet localhost 13

Trying ::1...
telnet: connect to address ::1: Connection refused
Trying 127.0.0.1...
Connected to localhost.
Escape character is <span class=s1>&#39;^]&#39;</span><span class=nb>.</span>
2001-06-19T21:04:42Z
Connection closed by foreign host.
%</code></pre></div></div><div class=paragraph><p>telnet tried the new IPv6, and failed. It retried with IPv4 and succeeded. The daemon works.</p></div><div class=paragraph><p>If you have access to another UNIX® system via telnet, you can use it to test accessing the server remotely. My computer does not have a static IP address, so this is what I did:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>who

</span>whizkid          ttyp0   Jun 19 16:59   <span class=o>(</span>216.127.220.143<span class=o>)</span>
xxx              ttyp1   Jun 19 16:06   <span class=o>(</span>xx.xx.xx.xx<span class=o>)</span>
% telnet 216.127.220.143 13

Trying 216.127.220.143...
Connected to r47.bfm.org.
Escape character is <span class=s1>&#39;^]&#39;</span><span class=nb>.</span>
2001-06-19T21:31:11Z
Connection closed by foreign host.
%</code></pre></div></div><div class=paragraph><p>Again, it worked. Will it work using the domain name?</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% telnet r47.bfm.org 13

Trying 216.127.220.143...
Connected to r47.bfm.org.
Escape character is <span class=s1>&#39;^]&#39;</span><span class=nb>.</span>
2001-06-19T21:31:40Z
Connection closed by foreign host.
%</code></pre></div></div><div class=paragraph><p>By the way, telnet prints the <em>Connection closed by foreign host</em> message after our daemon has closed the socket. This shows us that, indeed, using <code>fclose(client);</code> in our code works as advertised.</p></div></div></div></div></div><div class=sect2><h3 id=sockets-helper-functions>7.6. Helper Functions<a class=anchor href=#sockets-helper-functions></a></h3><div class=paragraph><p>FreeBSD C library contains many helper functions for sockets programming. For example, in our sample client we hard coded the <code>time.nist.gov</code> IP address. But we do not always know the IP address. Even if we do, our software is more flexible if it allows the user to enter the IP address, or even the domain name.</p></div><div class=sect3><h4 id=sockets-gethostbyname>7.6.1. <code>gethostbyname</code><a class=anchor href=#sockets-gethostbyname></a></h4><div class=paragraph><p>While there is no way to pass the domain name directly to any of the sockets functions, the FreeBSD C library comes with the <a href="https://man.freebsd.org/cgi/man.cgi?query=gethostbyname&amp;sektion=3&amp;format=html">gethostbyname(3)</a> and <a href="https://man.freebsd.org/cgi/man.cgi?query=gethostbyname2&amp;sektion=3&amp;format=html">gethostbyname2(3)</a> functions, declared in <span class=filename>netdb.h</span>.</p></div><div class="literalblock programlisting"><div class=content><pre>struct hostent * gethostbyname(const char *name);
struct hostent * gethostbyname2(const char *name, int af);</pre></div></div><div class=paragraph><p>Both return a pointer to the <code>hostent</code> structure, with much information about the domain. For our purposes, the <code>h_addr_list[0]</code> field of the structure points at <code>h_length</code> bytes of the correct address, already stored in the <em>network byte order</em>.</p></div><div class=paragraph><p>This allows us to create a much more flexible-and much more useful-version of our daytime program:</p></div><div class="literalblock programlisting"><div class=content><pre>/*
 * daytime.c
 *
 * Programmed by G. Adam Stanislav
 * 19 June 2001
 */
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;netdb.h&gt;

int main(int argc, char *argv[]) {
  register int s;
  register int bytes;
  struct sockaddr_in sa;
  struct hostent *he;
  char buf[BUFSIZ+1];
  char *host;

  if ((s = socket(PF_INET, SOCK_STREAM, 0)) &lt; 0) {
    perror(&#34;socket&#34;);
    return 1;
  }

  bzero(&amp;sa, sizeof sa);

  sa.sin_family = AF_INET;
  sa.sin_port = htons(13);

  host = (argc &gt; 1) ? (char *)argv[1] : &#34;time.nist.gov&#34;;

  if ((he = gethostbyname(host)) == NULL) {
    herror(host);
    return 2;
  }

  bcopy(he-&gt;h_addr_list[0],&amp;sa.sin_addr, he-&gt;h_length);

  if (connect(s, (struct sockaddr *)&amp;sa, sizeof sa) &lt; 0) {
    perror(&#34;connect&#34;);
    return 3;
  }

  while ((bytes = read(s, buf, BUFSIZ)) &gt; 0)
    write(1, buf, bytes);

  close(s);
  return 0;
}</pre></div></div><div class=paragraph><p>We now can type a domain name (or an IP address, it works both ways) on the command line, and the program will try to connect to its <em>daytime</em> server. Otherwise, it will still default to <code>time.nist.gov</code>. However, even in this case we will use <code>gethostbyname</code> rather than hard coding <code>192.43.244.18</code>. That way, even if its IP address changes in the future, we will still find it.</p></div><div class=paragraph><p>Since it takes virtually no time to get the time from your local server, you could run daytime twice in a row: First to get the time from <code>time.nist.gov</code>, the second time from your own system. You can then compare the results and see how exact your system clock is:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% daytime <span class=p>;</span> daytime localhost

52080 01-06-20 04:02:33 50 0 0 390.2 UTC<span class=o>(</span>NIST<span class=o>)</span> <span class=k>*</span>
2001-06-20T04:02:35Z
%</code></pre></div></div><div class=paragraph><p>As you can see, my system was two seconds ahead of the NIST time.</p></div></div><div class=sect3><h4 id=sockets-getservbyname>7.6.2. <code>getservbyname</code><a class=anchor href=#sockets-getservbyname></a></h4><div class=paragraph><p>Sometimes you may not be sure what port a certain service uses. The <a href="https://man.freebsd.org/cgi/man.cgi?query=getservbyname&amp;sektion=3&amp;format=html">getservbyname(3)</a> function, also declared in <span class=filename>netdb.h</span> comes in very handy in those cases:</p></div><div class="literalblock programlisting"><div class=content><pre>struct servent * getservbyname(const char *name, const char *proto);</pre></div></div><div class=paragraph><p>The <code>servent</code> structure contains the <code>s_port</code>, which contains the proper port, already in <em>network byte order</em>.</p></div><div class=paragraph><p>Had we not known the correct port for the <em>daytime</em> service, we could have found it this way:</p></div><div class="literalblock programlisting"><div class=content><pre>struct servent *se;
  ...
  if ((se = getservbyname(&#34;daytime&#34;, &#34;tcp&#34;)) == NULL {
    fprintf(stderr, &#34;Cannot determine which port to use.\n&#34;);
    return 7;
  }
  sa.sin_port = se-&gt;s_port;</pre></div></div><div class=paragraph><p>You usually do know the port. But if you are developing a new protocol, you may be testing it on an unofficial port. Some day, you will register the protocol and its port (if nowhere else, at least in your <span class=filename>/etc/services</span>, which is where <code>getservbyname</code> looks). Instead of returning an error in the above code, you just use the temporary port number. Once you have listed the protocol in <span class=filename>/etc/services</span>, your software will find its port without you having to rewrite the code.</p></div></div></div><div class=sect2><h3 id=sockets-concurrent-servers>7.7. Concurrent Servers<a class=anchor href=#sockets-concurrent-servers></a></h3><div class=paragraph><p>Unlike a sequential server, a <em>concurrent server</em> has to be able to serve more than one client at a time. For example, a <em>chat server</em> may be serving a specific client for hours-it cannot wait till it stops serving a client before it serves the next one.</p></div><div class=paragraph><p>This requires a significant change in our flowchart:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/developers-handbook/serv2.png alt="Concurrent Server"></div></div><div class=paragraph><p>We moved the <em>serve</em> from the <em>daemon process</em> to its own <em>server process</em>. However, because each child process inherits all open files (and a socket is treated just like a file), the new process inherits not only the <em>"accepted handle,"</em> i.e., the socket returned by the <code>accept</code> call, but also the <em>top socket</em>, i.e., the one opened by the top process right at the beginning.</p></div><div class=paragraph><p>However, the <em>server process</em> does not need this socket and should <code>close</code> it immediately. Similarly, the <em>daemon process</em> no longer needs the <em>accepted socket</em>, and not only should, but <em>must</em> <code>close</code> it-otherwise, it will run out of available <em>file descriptors</em> sooner or later.</p></div><div class=paragraph><p>After the <em>server process</em> is done serving, it should close the <em>accepted socket</em>. Instead of returning to <code>accept</code>, it now exits.</p></div><div class=paragraph><p>Under UNIX®, a process does not really <em>exit</em>. Instead, it <em>returns</em> to its parent. Typically, a parent process <code>wait</code>s for its child process, and obtains a return value. However, our <em>daemon process</em> cannot simply stop and wait. That would defeat the whole purpose of creating additional processes. But if it never does <code>wait</code>, its children will become <em>zombies</em>-no longer functional but still roaming around.</p></div><div class=paragraph><p>For that reason, the <em>daemon process</em> needs to set <em>signal handlers</em> in its <em>initialize daemon</em> phase. At least a SIGCHLD signal has to be processed, so the daemon can remove the zombie return values from the system and release the system resources they are taking up.</p></div><div class=paragraph><p>That is why our flowchart now contains a <em>process signals</em> box, which is not connected to any other box. By the way, many servers also process SIGHUP, and typically interpret as the signal from the superuser that they should reread their configuration files. This allows us to change settings without having to kill and restart these servers.</p></div></div></div></div><div class=sect1><h2 id=ipv6>Chapter 8. IPv6 Internals<a class=anchor href=#ipv6></a></h2><div class=sectionbody><div class=sect2><h3 id=ipv6-implementation>8.1. IPv6/IPsec Implementation<a class=anchor href=#ipv6-implementation></a></h3><div class=paragraph><p>This section should explain IPv6 and IPsec related implementation internals. These functionalities are derived from <a href=http://www.kame.net/>KAME project</a></p></div><div class=sect3><h4 id=ipv6details>8.1.1. IPv6<a class=anchor href=#ipv6details></a></h4><div class=sect4><h5 id=_conformance>8.1.1.1. Conformance<a class=anchor href=#_conformance></a></h5><div class=paragraph><p>The IPv6 related functions conforms, or tries to conform to the latest set of IPv6 specifications. For future reference we list some of the relevant documents below (<em>NOTE</em>: this is not a complete list - this is too hard to maintain…​).</p></div><div class=paragraph><p>For details please refer to specific chapter in the document, RFCs, manual pages, or comments in the source code.</p></div><div class=paragraph><p>Conformance tests have been performed on the KAME STABLE kit at TAHI project. Results can be viewed at <a href=http://www.tahi.org/report/KAME/>http://www.tahi.org/report/KAME/</a>. We also attended University of New Hampshire IOL tests (<a href=http://www.iol.unh.edu/>http://www.iol.unh.edu/</a>) in the past, with our past snapshots.</p></div><div class=ulist><ul><li><p>RFC1639: FTP Operation Over Big Address Records (FOOBAR)</p><div class=ulist><ul><li><p>RFC2428 is preferred over RFC1639. FTP clients will first try RFC2428, then RFC1639 if failed.</p></li></ul></div></li><li><p>RFC1886: DNS Extensions to support IPv6</p></li><li><p>RFC1933: Transition Mechanisms for IPv6 Hosts and Routers</p><div class=ulist><ul><li><p>IPv4 compatible address is not supported.</p></li><li><p>automatic tunneling (described in 4.3 of this RFC) is not supported.</p></li><li><p><a href="https://man.freebsd.org/cgi/man.cgi?query=gif&amp;sektion=4&amp;format=html">gif(4)</a> interface implements IPv[46]-over-IPv[46] tunnel in a generic way, and it covers "configured tunnel" described in the spec. See <a href=#gif>23.5.1.5</a> in this document for details.</p></li></ul></div></li><li><p>RFC1981: Path MTU Discovery for IPv6</p></li><li><p>RFC2080: RIPng for IPv6</p><div class=ulist><ul><li><p>usr.sbin/route6d support this.</p></li></ul></div></li><li><p>RFC2292: Advanced Sockets API for IPv6</p><div class=ulist><ul><li><p>For supported library functions/kernel APIs, see <span class=filename>sys/netinet6/ADVAPI</span>.</p></li></ul></div></li><li><p>RFC2362: Protocol Independent Multicast-Sparse Mode (PIM-SM)</p><div class=ulist><ul><li><p>RFC2362 defines packet formats for PIM-SM. <span class=filename>draft-ietf-pim-ipv6-01.txt</span> is written based on this.</p></li></ul></div></li><li><p>RFC2373: IPv6 Addressing Architecture</p><div class=ulist><ul><li><p>supports node required addresses, and conforms to the scope requirement.</p></li></ul></div></li><li><p>RFC2374: An IPv6 Aggregatable Global Unicast Address Format</p><div class=ulist><ul><li><p>supports 64-bit length of Interface ID.</p></li></ul></div></li><li><p>RFC2375: IPv6 Multicast Address Assignments</p><div class=ulist><ul><li><p>Userland applications use the well-known addresses assigned in the RFC.</p></li></ul></div></li><li><p>RFC2428: FTP Extensions for IPv6 and NATs</p><div class=ulist><ul><li><p>RFC2428 is preferred over RFC1639. FTP clients will first try RFC2428, then RFC1639 if failed.</p></li></ul></div></li><li><p>RFC2460: IPv6 specification</p></li><li><p>RFC2461: Neighbor discovery for IPv6</p><div class=ulist><ul><li><p>See <a href=#neighbor-discovery>23.5.1.2</a> in this document for details.</p></li></ul></div></li><li><p>RFC2462: IPv6 Stateless Address Autoconfiguration</p><div class=ulist><ul><li><p>See <a href=#ipv6-pnp>23.5.1.4</a> in this document for details.</p></li></ul></div></li><li><p>RFC2463: ICMPv6 for IPv6 specification</p><div class=ulist><ul><li><p>See <a href=#icmpv6>23.5.1.9</a> in this document for details.</p></li></ul></div></li><li><p>RFC2464: Transmission of IPv6 Packets over Ethernet Networks</p></li><li><p>RFC2465: MIB for IPv6: Textual Conventions and General Group</p><div class=ulist><ul><li><p>Necessary statistics are gathered by the kernel. Actual IPv6 MIB support is provided as a patchkit for ucd-snmp.</p></li></ul></div></li><li><p>RFC2466: MIB for IPv6: ICMPv6 group</p><div class=ulist><ul><li><p>Necessary statistics are gathered by the kernel. Actual IPv6 MIB support is provided as patchkit for ucd-snmp.</p></li></ul></div></li><li><p>RFC2467: Transmission of IPv6 Packets over FDDI Networks</p></li><li><p>RFC2497: Transmission of IPv6 packet over ARCnet Networks</p></li><li><p>RFC2553: Basic Socket Interface Extensions for IPv6</p><div class=ulist><ul><li><p>IPv4 mapped address (3.7) and special behavior of IPv6 wildcard bind socket (3.8) are supported. See <a href=#ipv6-wildcard-socket>23.5.1.12</a> in this document for details.</p></li></ul></div></li><li><p>RFC2675: IPv6 Jumbograms</p><div class=ulist><ul><li><p>See <a href=#ipv6-jumbo>23.5.1.7</a> in this document for details.</p></li></ul></div></li><li><p>RFC2710: Multicast Listener Discovery for IPv6</p></li><li><p>RFC2711: IPv6 router alert option</p></li><li><p><span class=filename>draft-ietf-ipngwg-router-renum-08</span>: Router renumbering for IPv6</p></li><li><p><span class=filename>draft-ietf-ipngwg-icmp-namelookups-02</span>: IPv6 Name Lookups Through ICMP</p></li><li><p><span class=filename>draft-ietf-ipngwg-icmp-name-lookups-03</span>: IPv6 Name Lookups Through ICMP</p></li><li><p><span class=filename>draft-ietf-pim-ipv6-01.txt</span>: PIM for IPv6</p><div class=ulist><ul><li><p><a href="https://man.freebsd.org/cgi/man.cgi?query=pim6dd&amp;sektion=8&amp;format=html">pim6dd(8)</a> implements dense mode. <a href="https://man.freebsd.org/cgi/man.cgi?query=pim6sd&amp;sektion=8&amp;format=html">pim6sd(8)</a> implements sparse mode.</p></li></ul></div></li><li><p><span class=filename>draft-itojun-ipv6-tcp-to-anycast-00</span>: Disconnecting TCP connection toward IPv6 anycast address</p></li><li><p><span class=filename>draft-yamamoto-wideipv6-comm-model-00</span></p><div class=ulist><ul><li><p>See <a href=#ipv6-sas>23.5.1.6</a> in this document for details.</p></li></ul></div></li><li><p><span class=filename>draft-ietf-ipngwg-scopedaddr-format-00.txt</span>: An Extension of Format for IPv6 Scoped Addresses</p></li></ul></div></div><div class=sect4><h5 id=neighbor-discovery>8.1.1.2. Neighbor Discovery<a class=anchor href=#neighbor-discovery></a></h5><div class=paragraph><p>Neighbor Discovery is fairly stable. Currently Address Resolution, Duplicated Address Detection, and Neighbor Unreachability Detection are supported. In the near future we will be adding Proxy Neighbor Advertisement support in the kernel and Unsolicited Neighbor Advertisement transmission command as admin tool.</p></div><div class=paragraph><p>If DAD fails, the address will be marked "duplicated" and message will be generated to syslog (and usually to console). The "duplicated" mark can be checked with <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a>. It is administrators' responsibility to check for and recover from DAD failures. The behavior should be improved in the near future.</p></div><div class=paragraph><p>Some of the network driver loops multicast packets back to itself, even if instructed not to do so (especially in promiscuous mode). In such cases DAD may fail, because DAD engine sees inbound NS packet (actually from the node itself) and considers it as a sign of duplicate. You may want to look at #if condition marked "heuristics" in sys/netinet6/nd6_nbr.c:nd6_dad_timer() as workaround (note that the code fragment in "heuristics" section is not spec conformant).</p></div><div class=paragraph><p>Neighbor Discovery specification (RFC2461) does not talk about neighbor cache handling in the following cases:</p></div><div class="olist arabic"><ol class=arabic><li><p>when there was no neighbor cache entry, node received unsolicited RS/NS/NA/redirect packet without link-layer address</p></li><li><p>neighbor cache handling on medium without link-layer address (we need a neighbor cache entry for IsRouter bit)</p></li></ol></div><div class=paragraph><p>For first case, we implemented workaround based on discussions on IETF ipngwg mailing list. For more details, see the comments in the source code and email thread started from (IPng 7155), dated Feb 6 1999.</p></div><div class=paragraph><p>IPv6 on-link determination rule (RFC2461) is quite different from assumptions in BSD network code. At this moment, no on-link determination rule is supported where default router list is empty (RFC2461, section 5.2, last sentence in 2nd paragraph - note that the spec misuse the word "host" and "node" in several places in the section).</p></div><div class=paragraph><p>To avoid possible DoS attacks and infinite loops, only 10 options on ND packet is accepted now. Therefore, if you have 20 prefix options attached to RA, only the first 10 prefixes will be recognized. If this troubles you, please ask it on FREEBSD-CURRENT mailing list and/or modify nd6_maxndopt in <span class=filename>sys/netinet6/nd6.c</span>. If there are high demands we may provide sysctl knob for the variable.</p></div></div><div class=sect4><h5 id=ipv6-scope-index>8.1.1.3. Scope Index<a class=anchor href=#ipv6-scope-index></a></h5><div class=paragraph><p>IPv6 uses scoped addresses. Therefore, it is very important to specify scope index (interface index for link-local address, or site index for site-local address) with an IPv6 address. Without scope index, scoped IPv6 address is ambiguous to the kernel, and kernel will not be able to determine the outbound interface for a packet.</p></div><div class=paragraph><p>Ordinary userland applications should use advanced API (RFC2292) to specify scope index, or interface index. For similar purpose, sin6_scope_id member in sockaddr_in6 structure is defined in RFC2553. However, the semantics for sin6_scope_id is rather vague. If you care about portability of your application, we suggest you to use advanced API rather than sin6_scope_id.</p></div><div class=paragraph><p>In the kernel, an interface index for link-local scoped address is embedded into 2nd 16bit-word (3rd and 4th byte) in IPv6 address. For example, you may see something like:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>	fe80:1::200:f8ff:fe01:6317</code></pre></div></div><div class=paragraph><p>in the routing table and interface address structure (struct in6_ifaddr). The address above is a link-local unicast address which belongs to a network interface whose interface identifier is 1. The embedded index enables us to identify IPv6 link local addresses over multiple interfaces effectively and with only a little code change.</p></div><div class=paragraph><p>Routing daemons and configuration programs, like <a href="https://man.freebsd.org/cgi/man.cgi?query=route6d&amp;sektion=8&amp;format=html">route6d(8)</a> and <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a>, will need to manipulate the "embedded" scope index. These programs use routing sockets and ioctls (like SIOCGIFADDR_IN6) and the kernel API will return IPv6 addresses with 2nd 16bit-word filled in. The APIs are for manipulating kernel internal structure. Programs that use these APIs have to be prepared about differences in kernels anyway.</p></div><div class=paragraph><p>When you specify scoped address to the command line, NEVER write the embedded form (such as ff02:1::1 or fe80:2::fedc). This is not supposed to work. Always use standard form, like ff02::1 or fe80::fedc, with command line option for specifying interface (like <code>ping6 -I ne0 ff02::1</code>). In general, if a command does not have command line option to specify outgoing interface, that command is not ready to accept scoped address. This may seem to be opposite from IPv6’s premise to support "dentist office" situation. We believe that specifications need some improvements for this.</p></div><div class=paragraph><p>Some of the userland tools support extended numeric IPv6 syntax, as documented in <span class=filename>draft-ietf-ipngwg-scopedaddr-format-00.txt</span>. You can specify outgoing link, by using name of the outgoing interface like "fe80::1%ne0". This way you will be able to specify link-local scoped address without much trouble.</p></div><div class=paragraph><p>To use this extension in your program, you will need to use <a href="https://man.freebsd.org/cgi/man.cgi?query=getaddrinfo&amp;sektion=3&amp;format=html">getaddrinfo(3)</a>, and <a href="https://man.freebsd.org/cgi/man.cgi?query=getnameinfo&amp;sektion=3&amp;format=html">getnameinfo(3)</a> with NI_WITHSCOPEID. The implementation currently assumes 1-to-1 relationship between a link and an interface, which is stronger than what specs say.</p></div></div><div class=sect4><h5 id=ipv6-pnp>8.1.1.4. Plug and Play<a class=anchor href=#ipv6-pnp></a></h5><div class=paragraph><p>Most of the IPv6 stateless address autoconfiguration is implemented in the kernel. Neighbor Discovery functions are implemented in the kernel as a whole. Router Advertisement (RA) input for hosts is implemented in the kernel. Router Solicitation (RS) output for endhosts, RS input for routers, and RA output for routers are implemented in the userland.</p></div><div class=sect5><h6 id=_assignment_of_link_local_and_special_addresses>8.1.1.4.1. Assignment of link-local, and special addresses<a class=anchor href=#_assignment_of_link_local_and_special_addresses></a></h6><div class=paragraph><p>IPv6 link-local address is generated from IEEE802 address (Ethernet MAC address). Each of interface is assigned an IPv6 link-local address automatically, when the interface becomes up (IFF_UP). Also, direct route for the link-local address is added to routing table.</p></div><div class=paragraph><p>Here is an output of netstat command:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Internet6:
Destination                   Gateway                   Flags      Netif Expire
fe80:1::%ed0/64               <span class=nb>link</span><span class=c>#1                    UC          ed0</span>
fe80:2::%ep0/64               <span class=nb>link</span><span class=c>#2                    UC          ep0</span></code></pre></div></div><div class=paragraph><p>Interfaces that has no IEEE802 address (pseudo interfaces like tunnel interfaces, or ppp interfaces) will borrow IEEE802 address from other interfaces, such as Ethernet interfaces, whenever possible. If there is no IEEE802 hardware attached, a last resort pseudo-random value, MD5(hostname), will be used as source of link-local address. If it is not suitable for your usage, you will need to configure the link-local address manually.</p></div><div class=paragraph><p>If an interface is not capable of handling IPv6 (such as lack of multicast support), link-local address will not be assigned to that interface. See section 2 for details.</p></div><div class=paragraph><p>Each interface joins the solicited multicast address and the link-local all-nodes multicast addresses (e.g., fe80::1:ff01:6317 and ff02::1, respectively, on the link the interface is attached). In addition to a link-local address, the loopback address (::1) will be assigned to the loopback interface. Also, ::1/128 and ff01::/32 are automatically added to routing table, and loopback interface joins node-local multicast group ff01::1.</p></div></div><div class=sect5><h6 id=_stateless_address_autoconfiguration_on_hosts>8.1.1.4.2. Stateless address autoconfiguration on Hosts<a class=anchor href=#_stateless_address_autoconfiguration_on_hosts></a></h6><div class=paragraph><p>In IPv6 specification, nodes are separated into two categories: <em>routers</em> and <em>hosts</em>. Routers forward packets addressed to others, hosts does not forward the packets. net.inet6.ip6.forwarding defines whether this node is router or host (router if it is 1, host if it is 0).</p></div><div class=paragraph><p>When a host hears Router Advertisement from the router, a host may autoconfigure itself by stateless address autoconfiguration. This behavior can be controlled by net.inet6.ip6.accept_rtadv (host autoconfigures itself if it is set to 1). By autoconfiguration, network address prefix for the receiving interface (usually global address prefix) is added. Default route is also configured. Routers periodically generate Router Advertisement packets. To request an adjacent router to generate RA packet, a host can transmit Router Solicitation. To generate a RS packet at any time, use the <em>rtsol</em> command. <a href="https://man.freebsd.org/cgi/man.cgi?query=rtsold&amp;sektion=8&amp;format=html">rtsold(8)</a> daemon is also available. <a href="https://man.freebsd.org/cgi/man.cgi?query=rtsold&amp;sektion=8&amp;format=html">rtsold(8)</a> generates Router Solicitation whenever necessary, and it works great for nomadic usage (notebooks/laptops). If one wishes to ignore Router Advertisements, use sysctl to set net.inet6.ip6.accept_rtadv to 0.</p></div><div class=paragraph><p>To generate Router Advertisement from a router, use the <a href="https://man.freebsd.org/cgi/man.cgi?query=rtadvd&amp;sektion=8&amp;format=html">rtadvd(8)</a> daemon.</p></div><div class=paragraph><p>Note that, IPv6 specification assumes the following items, and nonconforming cases are left unspecified:</p></div><div class=ulist><ul><li><p>Only hosts will listen to router advertisements</p></li><li><p>Hosts have single network interface (except loopback)</p></li></ul></div><div class=paragraph><p>Therefore, this is unwise to enable net.inet6.ip6.accept_rtadv on routers, or multi-interface host. A misconfigured node can behave strange (nonconforming configuration allowed for those who would like to do some experiments).</p></div><div class=paragraph><p>To summarize the sysctl knob:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>	accept_rtadv	forwarding	role of the node
	<span class=nt>---</span>		<span class=nt>---</span>		<span class=nt>---</span>
	0		0		host <span class=o>(</span>to be manually configured<span class=o>)</span>
	0		1		router
	1		0		autoconfigured host
					<span class=o>(</span>spec assumes that host has single
					interface only, autoconfigured host
					with multiple interface is
					out-of-scope<span class=o>)</span>
	1		1		invalid, or experimental
					<span class=o>(</span>out-of-scope of spec<span class=o>)</span></code></pre></div></div><div class=paragraph><p>RFC2462 has validation rule against incoming RA prefix information option, in 5.5.3 (e). This is to protect hosts from malicious (or misconfigured) routers that advertise very short prefix lifetime. There was an update from Jim Bound to ipngwg mailing list (look for "(ipng 6712)" in the archive) and it is implemented Jim’s update.</p></div><div class=paragraph><p>See <a href=#neighbor-discovery>23.5.1.2</a> in the document for relationship between DAD and autoconfiguration.</p></div></div></div><div class=sect4><h5 id=gif>8.1.1.5. Generic Tunnel Interface<a class=anchor href=#gif></a></h5><div class=paragraph><p>GIF (Generic InterFace) is a pseudo interface for configured tunnel. Details are described in <a href="https://man.freebsd.org/cgi/man.cgi?query=gif&amp;sektion=4&amp;format=html">gif(4)</a>. Currently</p></div><div class=ulist><ul><li><p>v6 in v6</p></li><li><p>v6 in v4</p></li><li><p>v4 in v6</p></li><li><p>v4 in v4</p></li></ul></div><div class=paragraph><p>are available. Use <a href="https://man.freebsd.org/cgi/man.cgi?query=gifconfig&amp;sektion=8&amp;format=html">gifconfig(8)</a> to assign physical (outer) source and destination address to gif interfaces. Configuration that uses same address family for inner and outer IP header (v4 in v4, or v6 in v6) is dangerous. It is very easy to configure interfaces and routing tables to perform infinite level of tunneling. <em>Please be warned</em>.</p></div><div class=paragraph><p>gif can be configured to be ECN-friendly. See <a href=#ipsec-ecn>23.5.4.5</a> for ECN-friendliness of tunnels, and <a href="https://man.freebsd.org/cgi/man.cgi?query=gif&amp;sektion=4&amp;format=html">gif(4)</a> for how to configure.</p></div><div class=paragraph><p>If you would like to configure an IPv4-in-IPv6 tunnel with gif interface, read <a href="https://man.freebsd.org/cgi/man.cgi?query=gif&amp;sektion=4&amp;format=html">gif(4)</a> carefully. You will need to remove IPv6 link-local address automatically assigned to the gif interface.</p></div></div><div class=sect4><h5 id=ipv6-sas>8.1.1.6. Source Address Selection<a class=anchor href=#ipv6-sas></a></h5><div class=paragraph><p>Current source selection rule is scope oriented (there are some exceptions - see below). For a given destination, a source IPv6 address is selected by the following rule:</p></div><div class="olist arabic"><ol class=arabic><li><p>If the source address is explicitly specified by the user (e.g., via the advanced API), the specified address is used.</p></li><li><p>If there is an address assigned to the outgoing interface (which is usually determined by looking up the routing table) that has the same scope as the destination address, the address is used.</p><div class=paragraph><p>This is the most typical case.</p></div></li><li><p>If there is no address that satisfies the above condition, choose a global address assigned to one of the interfaces on the sending node.</p></li><li><p>If there is no address that satisfies the above condition, and destination address is site local scope, choose a site local address assigned to one of the interfaces on the sending node.</p></li><li><p>If there is no address that satisfies the above condition, choose the address associated with the routing table entry for the destination. This is the last resort, which may cause scope violation.</p></li></ol></div><div class=paragraph><p>For instance, ::1 is selected for ff01::1, fe80:1::200:f8ff:fe01:6317 for fe80:1::2a0:24ff:feab:839b (note that embedded interface index - described in <a href=#ipv6-scope-index>23.5.1.3</a> - helps us choose the right source address. Those embedded indices will not be on the wire). If the outgoing interface has multiple address for the scope, a source is selected longest match basis (rule 3). Suppose 2001:0DB8:808:1:200:f8ff:fe01:6317 and 2001:0DB8:9:124:200:f8ff:fe01:6317 are given to the outgoing interface. 2001:0DB8:808:1:200:f8ff:fe01:6317 is chosen as the source for the destination 2001:0DB8:800::1.</p></div><div class=paragraph><p>Note that the above rule is not documented in the IPv6 spec. It is considered "up to implementation" item. There are some cases where we do not use the above rule. One example is connected TCP session, and we use the address kept in tcb as the source. Another example is source address for Neighbor Advertisement. Under the spec (RFC2461 7.2.2) NA’s source should be the target address of the corresponding NS’s target. In this case we follow the spec rather than the above longest-match rule.</p></div><div class=paragraph><p>For new connections (when rule 1 does not apply), deprecated addresses (addresses with preferred lifetime = 0) will not be chosen as source address if other choices are available. If no other choices are available, deprecated address will be used as a last resort. If there are multiple choice of deprecated addresses, the above scope rule will be used to choose from those deprecated addresses. If you would like to prohibit the use of deprecated address for some reason, configure net.inet6.ip6.use_deprecated to 0. The issue related to deprecated address is described in RFC2462 5.5.4 (NOTE: there is some debate underway in IETF ipngwg on how to use "deprecated" address).</p></div></div><div class=sect4><h5 id=ipv6-jumbo>8.1.1.7. Jumbo Payload<a class=anchor href=#ipv6-jumbo></a></h5><div class=paragraph><p>The Jumbo Payload hop-by-hop option is implemented and can be used to send IPv6 packets with payloads longer than 65,535 octets. But currently no physical interface whose MTU is more than 65,535 is supported, so such payloads can be seen only on the loopback interface (i.e., lo0).</p></div><div class=paragraph><p>If you want to try jumbo payloads, you first have to reconfigure the kernel so that the MTU of the loopback interface is more than 65,535 bytes; add the following to the kernel configuration file:</p></div><div class=paragraph><p><code>options "LARGE_LOMTU" #To test jumbo payload</code></p></div><div class=paragraph><p>and recompile the new kernel.</p></div><div class=paragraph><p>Then you can test jumbo payloads by the <a href="https://man.freebsd.org/cgi/man.cgi?query=ping6&amp;sektion=8&amp;format=html">ping6(8)</a> command with -b and -s options. The -b option must be specified to enlarge the size of the socket buffer and the -s option specifies the length of the packet, which should be more than 65,535. For example, type as follows:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ping6 <span class=nt>-b</span> 70000 <span class=nt>-s</span> 68000 ::1</code></pre></div></div><div class=paragraph><p>The IPv6 specification requires that the Jumbo Payload option must not be used in a packet that carries a fragment header. If this condition is broken, an ICMPv6 Parameter Problem message must be sent to the sender. specification is followed, but you cannot usually see an ICMPv6 error caused by this requirement.</p></div><div class=paragraph><p>When an IPv6 packet is received, the frame length is checked and compared to the length specified in the payload length field of the IPv6 header or in the value of the Jumbo Payload option, if any. If the former is shorter than the latter, the packet is discarded and statistics are incremented. You can see the statistics as output of <a href="https://man.freebsd.org/cgi/man.cgi?query=netstat&amp;sektion=8&amp;format=html">netstat(8)</a> command with `-s -p ip6' option:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% netstat <span class=nt>-s</span> <span class=nt>-p</span> ip6
	  ip6:
		<span class=o>(</span>snip<span class=o>)</span>
		1 with data size &lt; data length</code></pre></div></div><div class=paragraph><p>So, kernel does not send an ICMPv6 error unless the erroneous packet is an actual Jumbo Payload, that is, its packet size is more than 65,535 bytes. As described above, currently no physical interface with such a huge MTU is supported, so it rarely returns an ICMPv6 error.</p></div><div class=paragraph><p>TCP/UDP over jumbogram is not supported at this moment. This is because we have no medium (other than loopback) to test this. Contact us if you need this.</p></div><div class=paragraph><p>IPsec does not work on jumbograms. This is due to some specification twists in supporting AH with jumbograms (AH header size influences payload length, and this makes it real hard to authenticate inbound packet with jumbo payload option as well as AH).</p></div><div class=paragraph><p>There are fundamental issues in *BSD support for jumbograms. We would like to address those, but we need more time to finalize these. To name a few:</p></div><div class=ulist><ul><li><p>mbuf pkthdr.len field is typed as "int" in 4.4BSD, so it will not hold jumbogram with len > 2G on 32bit architecture CPUs. If we would like to support jumbogram properly, the field must be expanded to hold 4G + IPv6 header + link-layer header. Therefore, it must be expanded to at least int64_t (u_int32_t is NOT enough).</p></li><li><p>We mistakingly use "int" to hold packet length in many places. We need to convert them into larger integral type. It needs a great care, as we may experience overflow during packet length computation.</p></li><li><p>We mistakingly check for ip6_plen field of IPv6 header for packet payload length in various places. We should be checking mbuf pkthdr.len instead. ip6_input() will perform sanity check on jumbo payload option on input, and we can safely use mbuf pkthdr.len afterwards.</p></li><li><p>TCP code needs a careful update in bunch of places, of course.</p></li></ul></div></div><div class=sect4><h5 id=_loop_prevention_in_header_processing>8.1.1.8. Loop Prevention in Header Processing<a class=anchor href=#_loop_prevention_in_header_processing></a></h5><div class=paragraph><p>IPv6 specification allows arbitrary number of extension headers to be placed onto packets. If we implement IPv6 packet processing code in the way BSD IPv4 code is implemented, kernel stack may overflow due to long function call chain. sys/netinet6 code is carefully designed to avoid kernel stack overflow. Because of this, sys/netinet6 code defines its own protocol switch structure, as "struct ip6protosw" (see <span class=filename>netinet6/ip6protosw.h</span>). There is no such update to IPv4 part (sys/netinet) for compatibility, but small change is added to its pr_input() prototype. So "struct ipprotosw" is also defined. Because of this, if you receive IPsec-over-IPv4 packet with massive number of IPsec headers, kernel stack may blow up. IPsec-over-IPv6 is okay. (Off-course, for those all IPsec headers to be processed, each such IPsec header must pass each IPsec check. So an anonymous attacker will not be able to do such an attack.)</p></div></div><div class=sect4><h5 id=icmpv6>8.1.1.9. ICMPv6<a class=anchor href=#icmpv6></a></h5><div class=paragraph><p>After RFC2463 was published, IETF ipngwg has decided to disallow ICMPv6 error packet against ICMPv6 redirect, to prevent ICMPv6 storm on a network medium. This is already implemented into the kernel.</p></div></div><div class=sect4><h5 id=_applications>8.1.1.10. Applications<a class=anchor href=#_applications></a></h5><div class=paragraph><p>For userland programming, we support IPv6 socket API as specified in RFC2553, RFC2292 and upcoming Internet drafts.</p></div><div class=paragraph><p>TCP/UDP over IPv6 is available and quite stable. You can enjoy <a href="https://man.freebsd.org/cgi/man.cgi?query=telnet&amp;sektion=1&amp;format=html">telnet(1)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=ftp&amp;sektion=1&amp;format=html">ftp(1)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=rlogin&amp;sektion=1&amp;format=html">rlogin(1)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=rsh&amp;sektion=1&amp;format=html">rsh(1)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh&amp;sektion=1&amp;format=html">ssh(1)</a>, etc. These applications are protocol independent. That is, they automatically chooses IPv4 or IPv6 according to DNS.</p></div></div><div class=sect4><h5 id=_kernel_internals>8.1.1.11. Kernel Internals<a class=anchor href=#_kernel_internals></a></h5><div class=paragraph><p>While ip_forward() calls ip_output(), ip6_forward() directly calls if_output() since routers must not divide IPv6 packets into fragments.</p></div><div class=paragraph><p>ICMPv6 should contain the original packet as long as possible up to 1280. UDP6/IP6 port unreach, for instance, should contain all extension headers and the <strong>unchanged</strong> UDP6 and IP6 headers. So, all IP6 functions except TCP never convert network byte order into host byte order, to save the original packet.</p></div><div class=paragraph><p>tcp_input(), udp6_input() and icmp6_input() can not assume that IP6 header is preceding the transport headers due to extension headers. So, in6_cksum() was implemented to handle packets whose IP6 header and transport header is not continuous. TCP/IP6 nor UDP6/IP6 header structures do not exist for checksum calculation.</p></div><div class=paragraph><p>To process IP6 header, extension headers and transport headers easily, network drivers are now required to store packets in one internal mbuf or one or more external mbufs. A typical old driver prepares two internal mbufs for 96 - 204 bytes data, however, now such packet data is stored in one external mbuf.</p></div><div class=paragraph><p><code>netstat -s -p ip6</code> tells you whether or not your driver conforms such requirement. In the following example, "cce0" violates the requirement. (For more information, refer to Section 2.)</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Mbuf statistics:
                317 one mbuf
                two or more mbuf::
                        lo0 <span class=o>=</span> 8
			cce0 <span class=o>=</span> 10
                3282 one ext mbuf
                0 two or more ext mbuf</code></pre></div></div><div class=paragraph><p>Each input function calls IP6_EXTHDR_CHECK in the beginning to check if the region between IP6 and its header is continuous. IP6_EXTHDR_CHECK calls m_pullup() only if the mbuf has M_LOOP flag, that is, the packet comes from the loopback interface. m_pullup() is never called for packets coming from physical network interfaces.</p></div><div class=paragraph><p>Both IP and IP6 reassemble functions never call m_pullup().</p></div></div><div class=sect4><h5 id=ipv6-wildcard-socket>8.1.1.12. IPv4 Mapped Address and IPv6 Wildcard Socket<a class=anchor href=#ipv6-wildcard-socket></a></h5><div class=paragraph><p>RFC2553 describes IPv4 mapped address (3.7) and special behavior of IPv6 wildcard bind socket (3.8). The spec allows you to:</p></div><div class=ulist><ul><li><p>Accept IPv4 connections by AF_INET6 wildcard bind socket.</p></li><li><p>Transmit IPv4 packet over AF_INET6 socket by using special form of the address like ::ffff:10.1.1.1.</p></li></ul></div><div class=paragraph><p>but the spec itself is very complicated and does not specify how the socket layer should behave. Here we call the former one "listening side" and the latter one "initiating side", for reference purposes.</p></div><div class=paragraph><p>You can perform wildcard bind on both of the address families, on the same port.</p></div><div class=paragraph><p>The following table show the behavior of FreeBSD 4.x.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>listening side          initiating side
                <span class=o>(</span>AF_INET6 wildcard      <span class=o>(</span>connection to ::ffff:10.1.1.1<span class=o>)</span>
                socket gets IPv4 conn.<span class=o>)</span>
                <span class=nt>---</span>                     <span class=nt>---</span>
FreeBSD 4.x     configurable            supported
                default: enabled</code></pre></div></div><div class=paragraph><p>The following sections will give you more details, and how you can configure the behavior.</p></div><div class=paragraph><p>Comments on listening side:</p></div><div class=paragraph><p>It looks that RFC2553 talks too little on wildcard bind issue, especially on the port space issue, failure mode and relationship between AF_INET/INET6 wildcard bind. There can be several separate interpretation for this RFC which conform to it but behaves differently. So, to implement portable application you should assume nothing about the behavior in the kernel. Using <a href="https://man.freebsd.org/cgi/man.cgi?query=getaddrinfo&amp;sektion=3&amp;format=html">getaddrinfo(3)</a> is the safest way. Port number space and wildcard bind issues were discussed in detail on ipv6imp mailing list, in mid March 1999 and it looks that there is no concrete consensus (means, up to implementers). You may want to check the mailing list archives.</p></div><div class=paragraph><p>If a server application would like to accept IPv4 and IPv6 connections, there will be two alternatives.</p></div><div class=paragraph><p>One is using AF_INET and AF_INET6 socket (you will need two sockets). Use <a href="https://man.freebsd.org/cgi/man.cgi?query=getaddrinfo&amp;sektion=3&amp;format=html">getaddrinfo(3)</a> with AI_PASSIVE into ai_flags, and <a href="https://man.freebsd.org/cgi/man.cgi?query=socket&amp;sektion=2&amp;format=html">socket(2)</a> and <a href="https://man.freebsd.org/cgi/man.cgi?query=bind&amp;sektion=2&amp;format=html">bind(2)</a> to all the addresses returned. By opening multiple sockets, you can accept connections onto the socket with proper address family. IPv4 connections will be accepted by AF_INET socket, and IPv6 connections will be accepted by AF_INET6 socket.</p></div><div class=paragraph><p>Another way is using one AF_INET6 wildcard bind socket. Use <a href="https://man.freebsd.org/cgi/man.cgi?query=getaddrinfo&amp;sektion=3&amp;format=html">getaddrinfo(3)</a> with AI_PASSIVE into ai_flags and with AF_INET6 into ai_family, and set the 1st argument hostname to NULL. And <a href="https://man.freebsd.org/cgi/man.cgi?query=socket&amp;sektion=2&amp;format=html">socket(2)</a> and <a href="https://man.freebsd.org/cgi/man.cgi?query=bind&amp;sektion=2&amp;format=html">bind(2)</a> to the address returned. (should be IPv6 unspecified addr). You can accept either of IPv4 and IPv6 packet via this one socket.</p></div><div class=paragraph><p>To support only IPv6 traffic on AF_INET6 wildcard binded socket portably, always check the peer address when a connection is made toward AF_INET6 listening socket. If the address is IPv4 mapped address, you may want to reject the connection. You can check the condition by using IN6_IS_ADDR_V4MAPPED() macro.</p></div><div class=paragraph><p>To resolve this issue more easily, there is system dependent <a href="https://man.freebsd.org/cgi/man.cgi?query=setsockopt&amp;sektion=2&amp;format=html">setsockopt(2)</a> option, IPV6_BINDV6ONLY, used like below.</p></div><div class="literalblock programlisting"><div class=content><pre>	int on;

	setsockopt(s, IPPROTO_IPV6, IPV6_BINDV6ONLY,
		   (char *)&amp;on, sizeof (on)) &lt; 0));</pre></div></div><div class=paragraph><p>When this call succeed, then this socket only receive IPv6 packets.</p></div><div class=paragraph><p>Comments on initiating side:</p></div><div class=paragraph><p>Advise to application implementers: to implement a portable IPv6 application (which works on multiple IPv6 kernels), we believe that the following is the key to the success:</p></div><div class=ulist><ul><li><p>NEVER hardcode AF_INET nor AF_INET6.</p></li><li><p>Use <a href="https://man.freebsd.org/cgi/man.cgi?query=getaddrinfo&amp;sektion=3&amp;format=html">getaddrinfo(3)</a> and <a href="https://man.freebsd.org/cgi/man.cgi?query=getnameinfo&amp;sektion=3&amp;format=html">getnameinfo(3)</a> throughout the system. Never use gethostby*(), getaddrby*(), inet_*() or getipnodeby*(). (To update existing applications to be IPv6 aware easily, sometime getipnodeby*() will be useful. But if possible, try to rewrite the code to use <a href="https://man.freebsd.org/cgi/man.cgi?query=getaddrinfo&amp;sektion=3&amp;format=html">getaddrinfo(3)</a> and <a href="https://man.freebsd.org/cgi/man.cgi?query=getnameinfo&amp;sektion=3&amp;format=html">getnameinfo(3)</a>.)</p></li><li><p>If you would like to connect to destination, use <a href="https://man.freebsd.org/cgi/man.cgi?query=getaddrinfo&amp;sektion=3&amp;format=html">getaddrinfo(3)</a> and try all the destination returned, like <a href="https://man.freebsd.org/cgi/man.cgi?query=telnet&amp;sektion=1&amp;format=html">telnet(1)</a> does.</p></li><li><p>Some of the IPv6 stack is shipped with buggy <a href="https://man.freebsd.org/cgi/man.cgi?query=getaddrinfo&amp;sektion=3&amp;format=html">getaddrinfo(3)</a>. Ship a minimal working version with your application and use that as last resort.</p></li></ul></div><div class=paragraph><p>If you would like to use AF_INET6 socket for both IPv4 and IPv6 outgoing connection, you will need to use <a href="https://man.freebsd.org/cgi/man.cgi?query=getipnodebyname&amp;sektion=3&amp;format=html">getipnodebyname(3)</a>. When you would like to update your existing application to be IPv6 aware with minimal effort, this approach might be chosen. But please note that it is a temporal solution, because <a href="https://man.freebsd.org/cgi/man.cgi?query=getipnodebyname&amp;sektion=3&amp;format=html">getipnodebyname(3)</a> itself is not recommended as it does not handle scoped IPv6 addresses at all. For IPv6 name resolution, <a href="https://man.freebsd.org/cgi/man.cgi?query=getaddrinfo&amp;sektion=3&amp;format=html">getaddrinfo(3)</a> is the preferred API. So you should rewrite your application to use <a href="https://man.freebsd.org/cgi/man.cgi?query=getaddrinfo&amp;sektion=3&amp;format=html">getaddrinfo(3)</a>, when you get the time to do it.</p></div><div class=paragraph><p>When writing applications that make outgoing connections, story goes much simpler if you treat AF_INET and AF_INET6 as totally separate address family. {set,get}sockopt issue goes simpler, DNS issue will be made simpler. We do not recommend you to rely upon IPv4 mapped address.</p></div><div class=sect5><h6 id=_unified_tcp_and_inpcb_code>8.1.1.12.1. unified tcp and inpcb code<a class=anchor href=#_unified_tcp_and_inpcb_code></a></h6><div class=paragraph><p>FreeBSD 4.x uses shared tcp code between IPv4 and IPv6 (from sys/netinet/tcp*) and separate udp4/6 code. It uses unified inpcb structure.</p></div><div class=paragraph><p>The platform can be configured to support IPv4 mapped address. Kernel configuration is summarized as follows:</p></div><div class=ulist><ul><li><p>By default, AF_INET6 socket will grab IPv4 connections in certain condition, and can initiate connection to IPv4 destination embedded in IPv4 mapped IPv6 address.</p></li><li><p>You can disable it on entire system with sysctl like below.</p><div class=paragraph><p><code>sysctl net.inet6.ip6.mapped_addr=0</code></p></div></li></ul></div><div class=sect6><h7 id=_listening_side>8.1.1.12.1.1. Listening Side<a class=anchor href=#_listening_side></a></h7><div class=paragraph><p>Each socket can be configured to support special AF_INET6 wildcard bind (enabled by default). You can disable it on each socket basis with <a href="https://man.freebsd.org/cgi/man.cgi?query=setsockopt&amp;sektion=2&amp;format=html">setsockopt(2)</a> like below.</p></div><div class="literalblock programlisting"><div class=content><pre>	int on;

	setsockopt(s, IPPROTO_IPV6, IPV6_BINDV6ONLY,
		   (char *)&amp;on, sizeof (on)) &lt; 0));</pre></div></div><div class=paragraph><p>Wildcard AF_INET6 socket grabs IPv4 connection if and only if the following conditions are satisfied:</p></div><div class=ulist><ul><li><p>there is no AF_INET socket that matches the IPv4 connection</p></li><li><p>the AF_INET6 socket is configured to accept IPv4 traffic, i.e., getsockopt(IPV6_BINDV6ONLY) returns 0.</p></li></ul></div><div class=paragraph><p>There is no problem with open/close ordering.</p></div></div><div class=sect6><h7 id=_initiating_side>8.1.1.12.1.2. Initiating Side<a class=anchor href=#_initiating_side></a></h7><div class=paragraph><p>FreeBSD 4.x supports outgoing connection to IPv4 mapped address (::ffff:10.1.1.1), if the node is configured to support IPv4 mapped address.</p></div></div></div></div><div class=sect4><h5 id=_sockaddr_storage>8.1.1.13. sockaddr_storage<a class=anchor href=#_sockaddr_storage></a></h5><div class=paragraph><p>When RFC2553 was about to be finalized, there was discussion on how struct sockaddr_storage members are named. One proposal is to prepend "<em>" to the members (like "</em>ss_len") as they should not be touched. The other proposal was not to prepend it (like "ss_len") as we need to touch those members directly. There was no clear consensus on it.</p></div><div class=paragraph><p>As a result, RFC2553 defines struct sockaddr_storage as follows:</p></div><div class="literalblock programlisting"><div class=content><pre>	struct sockaddr_storage {
		u_char	__ss_len;	/* address length */
		u_char	__ss_family;	/* address family */
		/* and bunch of padding */
	};</pre></div></div><div class=paragraph><p>On the contrary, XNET draft defines as follows:</p></div><div class="literalblock programlisting"><div class=content><pre>	struct sockaddr_storage {
		u_char	ss_len;		/* address length */
		u_char	ss_family;	/* address family */
		/* and bunch of padding */
	};</pre></div></div><div class=paragraph><p>In December 1999, it was agreed that RFC2553bis should pick the latter (XNET) definition.</p></div><div class=paragraph><p>Current implementation conforms to XNET definition, based on RFC2553bis discussion.</p></div><div class=paragraph><p>If you look at multiple IPv6 implementations, you will be able to see both definitions. As an userland programmer, the most portable way of dealing with it is to:</p></div><div class="olist arabic"><ol class=arabic><li><p>ensure ss_family and/or ss_len are available on the platform, by using GNU autoconf,</p></li><li><p>have -Dss_family=<em>ss_family to unify all occurrences (including header file) into </em>ss_family, or</p></li><li><p>never touch __ss_family. cast to sockaddr * and use sa_family like:</p><div class="literalblock programlisting"><div class=content><pre>	struct sockaddr_storage ss;
	family = ((struct sockaddr *)&amp;ss)-&gt;sa_family</pre></div></div></li></ol></div></div></div><div class=sect3><h4 id=_network_drivers>8.1.2. Network Drivers<a class=anchor href=#_network_drivers></a></h4><div class=paragraph><p>Now following two items are required to be supported by standard drivers:</p></div><div class="olist arabic"><ol class=arabic><li><p>mbuf clustering requirement. In this stable release, we changed MINCLSIZE into MHLEN+1 for all the operating systems in order to make all the drivers behave as we expect.</p></li><li><p>multicast. If <a href="https://man.freebsd.org/cgi/man.cgi?query=ifmcstat&amp;sektion=8&amp;format=html">ifmcstat(8)</a> yields no multicast group for a interface, that interface has to be patched.</p></li></ol></div><div class=paragraph><p>If any of the drivers do not support the requirements, then the drivers cannot be used for IPv6 and/or IPsec communication. If you find any problem with your card using IPv6/IPsec, then, please report it to the <a href=https://lists.FreeBSD.org/subscription/freebsd-bugs>FreeBSD problem reports 郵遞論壇</a>.</p></div><div class=paragraph><p>(NOTE: In the past we required all PCMCIA drivers to have a call to in6_ifattach(). We have no such requirement any more)</p></div></div><div class=sect3><h4 id=_translator>8.1.3. Translator<a class=anchor href=#_translator></a></h4><div class=paragraph><p>We categorize IPv4/IPv6 translator into 4 types:</p></div><div class=ulist><ul><li><p><em>Translator A</em> --- It is used in the early stage of transition to make it possible to establish a connection from an IPv6 host in an IPv6 island to an IPv4 host in the IPv4 ocean.</p></li><li><p><em>Translator B</em> --- It is used in the early stage of transition to make it possible to establish a connection from an IPv4 host in the IPv4 ocean to an IPv6 host in an IPv6 island.</p></li><li><p><em>Translator C</em> --- It is used in the late stage of transition to make it possible to establish a connection from an IPv4 host in an IPv4 island to an IPv6 host in the IPv6 ocean.</p></li><li><p><em>Translator D</em> --- It is used in the late stage of transition to make it possible to establish a connection from an IPv6 host in the IPv6 ocean to an IPv4 host in an IPv4 island.</p></li></ul></div></div><div class=sect3><h4 id=ipsec-implementation>8.1.4. IPsec<a class=anchor href=#ipsec-implementation></a></h4><div class=paragraph><p>IPsec is mainly organized by three components.</p></div><div class="olist arabic"><ol class=arabic><li><p>Policy Management</p></li><li><p>Key Management</p></li><li><p>AH and ESP handling</p></li></ol></div><div class=sect4><h5 id=_policy_management>8.1.4.1. Policy Management<a class=anchor href=#_policy_management></a></h5><div class=paragraph><p>The kernel implements experimental policy management code. There are two way to manage security policy. One is to configure per-socket policy using <a href="https://man.freebsd.org/cgi/man.cgi?query=setsockopt&amp;sektion=2&amp;format=html">setsockopt(2)</a>. In this cases, policy configuration is described in <a href="https://man.freebsd.org/cgi/man.cgi?query=ipsec_set_policy&amp;sektion=3&amp;format=html">ipsec_set_policy(3)</a>. The other is to configure kernel packet filter-based policy using PF_KEY interface, via <a href="https://man.freebsd.org/cgi/man.cgi?query=setkey&amp;sektion=8&amp;format=html">setkey(8)</a>.</p></div><div class=paragraph><p>The policy entry is not re-ordered with its indexes, so the order of entry when you add is very significant.</p></div></div><div class=sect4><h5 id=_key_management>8.1.4.2. Key Management<a class=anchor href=#_key_management></a></h5><div class=paragraph><p>The key management code implemented in this kit (sys/netkey) is a home-brew PFKEY v2 implementation. This conforms to RFC2367.</p></div><div class=paragraph><p>The home-brew IKE daemon, "racoon" is included in the kit (kame/kame/racoon). Basically you will need to run racoon as daemon, then set up a policy to require keys (like <code>ping -P 'out ipsec esp/transport//use'</code>). The kernel will contact racoon daemon as necessary to exchange keys.</p></div></div><div class=sect4><h5 id=_ah_and_esp_handling>8.1.4.3. AH and ESP Handling<a class=anchor href=#_ah_and_esp_handling></a></h5><div class=paragraph><p>IPsec module is implemented as "hooks" to the standard IPv4/IPv6 processing. When sending a packet, ip{,6}_output() checks if ESP/AH processing is required by checking if a matching SPD (Security Policy Database) is found. If ESP/AH is needed, {esp,ah}{4,6}_output() will be called and mbuf will be updated accordingly. When a packet is received, {esp,ah}4_input() will be called based on protocol number, i.e., (*inetsw[proto])(). {esp,ah}4_input() will decrypt/check authenticity of the packet, and strips off daisy-chained header and padding for ESP/AH. It is safe to strip off the ESP/AH header on packet reception, since we will never use the received packet in "as is" form.</p></div><div class=paragraph><p>By using ESP/AH, TCP4/6 effective data segment size will be affected by extra daisy-chained headers inserted by ESP/AH. Our code takes care of the case.</p></div><div class=paragraph><p>Basic crypto functions can be found in directory "sys/crypto". ESP/AH transform are listed in {esp,ah}_core.c with wrapper functions. If you wish to add some algorithm, add wrapper function in {esp,ah}_core.c, and add your crypto algorithm code into sys/crypto.</p></div><div class=paragraph><p>Tunnel mode is partially supported in this release, with the following restrictions:</p></div><div class=ulist><ul><li><p>IPsec tunnel is not combined with GIF generic tunneling interface. It needs a great care because we may create an infinite loop between ip_output() and tunnelifp→if_output(). Opinion varies if it is better to unify them, or not.</p></li><li><p>MTU and Don’t Fragment bit (IPv4) considerations need more checking, but basically works fine.</p></li><li><p>Authentication model for AH tunnel must be revisited. We will need to improve the policy management engine, eventually.</p></li></ul></div></div><div class=sect4><h5 id=_conformance_to_rfcs_and_ids>8.1.4.4. Conformance to RFCs and IDs<a class=anchor href=#_conformance_to_rfcs_and_ids></a></h5><div class=paragraph><p>The IPsec code in the kernel conforms (or, tries to conform) to the following standards:</p></div><div class=paragraph><p>"old IPsec" specification documented in <span class=filename>rfc182[5-9].txt</span></p></div><div class=paragraph><p>"new IPsec" specification documented in <span class=filename>rfc240[1-6].txt</span>, <span class=filename>rfc241[01].txt</span>, <span class=filename>rfc2451.txt</span> and <span class=filename>draft-mcdonald-simple-ipsec-api-01.txt</span> (draft expired, but you can take from <a href=ftp://ftp.kame.net/pub/internet-drafts/>ftp://ftp.kame.net/pub/internet-drafts/</a>). (NOTE: IKE specifications, <span class=filename>rfc241[7-9].txt</span> are implemented in userland, as "racoon" IKE daemon)</p></div><div class=paragraph><p>Currently supported algorithms are:</p></div><div class=ulist><ul><li><p>old IPsec AH</p><div class=ulist><ul><li><p>null crypto checksum (no document, just for debugging)</p></li><li><p>keyed MD5 with 128bit crypto checksum (<span class=filename>rfc1828.txt</span>)</p></li><li><p>keyed SHA1 with 128bit crypto checksum (no document)</p></li><li><p>HMAC MD5 with 128bit crypto checksum (<span class=filename>rfc2085.txt</span>)</p></li><li><p>HMAC SHA1 with 128bit crypto checksum (no document)</p></li></ul></div></li><li><p>old IPsec ESP</p><div class=ulist><ul><li><p>null encryption (no document, similar to <span class=filename>rfc2410.txt</span>)</p></li><li><p>DES-CBC mode (<span class=filename>rfc1829.txt</span>)</p></li></ul></div></li><li><p>new IPsec AH</p><div class=ulist><ul><li><p>null crypto checksum (no document, just for debugging)</p></li><li><p>keyed MD5 with 96bit crypto checksum (no document)</p></li><li><p>keyed SHA1 with 96bit crypto checksum (no document)</p></li><li><p>HMAC MD5 with 96bit crypto checksum (<span class=filename>rfc2403.txt</span>)</p></li><li><p>HMAC SHA1 with 96bit crypto checksum (<span class=filename>rfc2404.txt</span>)</p></li></ul></div></li><li><p>new IPsec ESP</p><div class=ulist><ul><li><p>null encryption (<span class=filename>rfc2410.txt</span>)</p></li><li><p>DES-CBC with derived IV (<span class=filename>draft-ietf-ipsec-ciph-des-derived-01.txt</span>, draft expired)</p></li><li><p>DES-CBC with explicit IV (<span class=filename>rfc2405.txt</span>)</p></li><li><p>3DES-CBC with explicit IV (<span class=filename>rfc2451.txt</span>)</p></li><li><p>BLOWFISH CBC (<span class=filename>rfc2451.txt</span>)</p></li><li><p>CAST128 CBC (<span class=filename>rfc2451.txt</span>)</p></li><li><p>RC5 CBC (<span class=filename>rfc2451.txt</span>)</p></li><li><p>each of the above can be combined with:</p><div class=ulist><ul><li><p>ESP authentication with HMAC-MD5(96bit)</p></li><li><p>ESP authentication with HMAC-SHA1(96bit)</p></li></ul></div></li></ul></div></li></ul></div><div class=paragraph><p>The following algorithms are NOT supported:</p></div><div class=ulist><ul><li><p>old IPsec AH</p><div class=ulist><ul><li><p>HMAC MD5 with 128bit crypto checksum + 64bit replay prevention (<span class=filename>rfc2085.txt</span>)</p></li><li><p>keyed SHA1 with 160bit crypto checksum + 32bit padding (<span class=filename>rfc1852.txt</span>)</p></li></ul></div></li></ul></div><div class=paragraph><p>IPsec (in kernel) and IKE (in userland as "racoon") has been tested at several interoperability test events, and it is known to interoperate with many other implementations well. Also, current IPsec implementation as quite wide coverage for IPsec crypto algorithms documented in RFC (we cover algorithms without intellectual property issues only).</p></div></div><div class=sect4><h5 id=ipsec-ecn>8.1.4.5. ECN Consideration on IPsec Tunnels<a class=anchor href=#ipsec-ecn></a></h5><div class=paragraph><p>ECN-friendly IPsec tunnel is supported as described in <span class=filename>draft-ipsec-ecn-00.txt</span>.</p></div><div class=paragraph><p>Normal IPsec tunnel is described in RFC2401. On encapsulation, IPv4 TOS field (or, IPv6 traffic class field) will be copied from inner IP header to outer IP header. On decapsulation outer IP header will be simply dropped. The decapsulation rule is not compatible with ECN, since ECN bit on the outer IP TOS/traffic class field will be lost.</p></div><div class=paragraph><p>To make IPsec tunnel ECN-friendly, we should modify encapsulation and decapsulation procedure. This is described in <a href=http://www.aciri.org/floyd/papers/draft-ipsec-ecn-00.txt>http://www.aciri.org/floyd/papers/draft-ipsec-ecn-00.txt</a>, chapter 3.</p></div><div class=paragraph><p>IPsec tunnel implementation can give you three behaviors, by setting net.inet.ipsec.ecn (or net.inet6.ipsec6.ecn) to some value:</p></div><div class=ulist><ul><li><p>RFC2401: no consideration for ECN (sysctl value -1)</p></li><li><p>ECN forbidden (sysctl value 0)</p></li><li><p>ECN allowed (sysctl value 1)</p></li></ul></div><div class=paragraph><p>Note that the behavior is configurable in per-node manner, not per-SA manner (draft-ipsec-ecn-00 wants per-SA configuration, but it looks too much for me).</p></div><div class=paragraph><p>The behavior is summarized as follows (see source code for more detail):</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>encapsulate                     decapsulate
                <span class=nt>---</span>                             <span class=nt>---</span>
RFC2401         copy all TOS bits               drop TOS bits on outer
                from inner to outer.            <span class=o>(</span>use inner TOS bits as is<span class=o>)</span>

ECN forbidden   copy TOS bits except <span class=k>for </span>ECN    drop TOS bits on outer
                <span class=o>(</span>masked with 0xfc<span class=o>)</span> from inner   <span class=o>(</span>use inner TOS bits as is<span class=o>)</span>
                to outer.  <span class=nb>set </span>ECN bits to 0.

ECN allowed     copy TOS bits except <span class=k>for </span>ECN    use inner TOS bits with some
                CE <span class=o>(</span>masked with 0xfe<span class=o>)</span> from      change.  <span class=k>if </span>outer ECN CE bit
                inner to outer.                 is 1, <span class=nb>enable </span>ECN CE bit on
                <span class=nb>set </span>ECN CE bit to 0.            the inner.</code></pre></div></div><div class=paragraph><p>General strategy for configuration is as follows:</p></div><div class=ulist><ul><li><p>if both IPsec tunnel endpoint are capable of ECN-friendly behavior, you should better configure both end to "ECN allowed" (sysctl value 1).</p></li><li><p>if the other end is very strict about TOS bit, use "RFC2401" (sysctl value -1).</p></li><li><p>in other cases, use "ECN forbidden" (sysctl value 0).</p></li></ul></div><div class=paragraph><p>The default behavior is "ECN forbidden" (sysctl value 0).</p></div><div class=paragraph><p>For more information, please refer to:</p></div><div class=paragraph><p><a href=http://www.aciri.org/floyd/papers/draft-ipsec-ecn-00.txt>http://www.aciri.org/floyd/papers/draft-ipsec-ecn-00.txt</a>, RFC2481 (Explicit Congestion Notification), src/sys/netinet6/{ah,esp}_input.c</p></div><div class=paragraph><p>(Thanks goes to Kenjiro Cho <a href=mailto:kjc@csl.sony.co.jp>kjc@csl.sony.co.jp</a> for detailed analysis)</p></div></div><div class=sect4><h5 id=_interoperability>8.1.4.6. Interoperability<a class=anchor href=#_interoperability></a></h5><div class=paragraph><p>Here are (some of) platforms that KAME code have tested IPsec/IKE interoperability in the past. Note that both ends may have modified their implementation, so use the following list just for reference purposes.</p></div><div class=paragraph><p>Altiga, Ashley-laurent (vpcom.com), Data Fellows (F-Secure), Ericsson ACC, FreeS/WAN, HITACHI, IBM AIX®, IIJ, Intel, Microsoft® Windows NT®, NIST (linux IPsec + plutoplus), Netscreen, OpenBSD, RedCreek, Routerware, SSH, Secure Computing, Soliton, Toshiba, VPNet, Yamaha RT100i</p></div></div></div></div></div></div><h1 id=kernel class=sect0>Part III: Kernel(核心)<a class=anchor href=#kernel></a></h1><div class=sect1><h2 id=kernelbuild>Chapter 9. Building and Installing a FreeBSD Kernel<a class=anchor href=#kernelbuild></a></h2><div class=sectionbody><div class=paragraph><p>Being a kernel developer requires understanding of the kernel build process. To debug the FreeBSD kernel it is required to be able to build one. There are two known ways to do so:</p></div><div class=paragraph><p>The supported procedure to build and install a kernel is documented in the <a href=https://docs.freebsd.org/en/books/handbook/kernelconfig/#kernelconfig-building>Building and Installing a Custom Kernel</a> chapter of the FreeBSD Handbook.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>It is supposed that the reader of this chapter is familiar with the information described in the <a href=https://docs.freebsd.org/en/books/handbook/kernelconfig/#kernelconfig-building>Building and Installing a Custom Kernel</a> chapter of the FreeBSD Handbook. If this is not the case, please read through the above mentioned chapter to understand how the build process works.</p></div></td></tr></tbody></table></div><div class=sect2><h3 id=kernelbuild-traditional>9.1. Building the Faster but Brittle Way<a class=anchor href=#kernelbuild-traditional></a></h3><div class=paragraph><p>Building the kernel this way may be useful when working on the kernel code and it may actually be faster than the documented procedure when only a single option or two were tweaked in the kernel configuration file. On the other hand, it might lead to unexpected kernel build breakage.</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Run <a href="https://man.freebsd.org/cgi/man.cgi?query=config&amp;sektion=8&amp;format=html">config(8)</a> to generate the kernel source code:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /usr/sbin/config MYKERNEL</span></code></pre></div></div></li><li><p>Change into the build directory. <a href="https://man.freebsd.org/cgi/man.cgi?query=config&amp;sektion=8&amp;format=html">config(8)</a> will print the name of this directory after being run as above.</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd ../compile/MYKERNEL</span></code></pre></div></div></li><li><p>Compile the kernel:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># make depend</span>
<span class=c># make</span></code></pre></div></div></li><li><p>Install the new kernel:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># make install</span></code></pre></div></div></li></ol></div></div></div></div></div></div><div class=sect1><h2 id=kerneldebug>Chapter 10. Kernel Debugging<a class=anchor href=#kerneldebug></a></h2><div class=sectionbody><div class=sect2><h3 id=kerneldebug-obtain>10.1. Obtaining a Kernel Crash Dump<a class=anchor href=#kerneldebug-obtain></a></h3><div class=paragraph><p>When running a development kernel (e.g., FreeBSD-CURRENT), such as a kernel under extreme conditions (e.g., very high load averages, tens of thousands of connections, exceedingly high number of concurrent users, hundreds of <a href="https://man.freebsd.org/cgi/man.cgi?query=jail&amp;sektion=8&amp;format=html">jail(8)</a>s, etc.), or using a new feature or device driver on FreeBSD-STABLE (e.g., PAE), sometimes a kernel will panic. In the event that it does, this chapter will demonstrate how to extract useful information out of a crash.</p></div><div class=paragraph><p>A system reboot is inevitable once a kernel panics. Once a system is rebooted, the contents of a system’s physical memory (RAM) is lost, as well as any bits that are on the swap device before the panic. To preserve the bits in physical memory, the kernel makes use of the swap device as a temporary place to store the bits that are in RAM across a reboot after a crash. In doing this, when FreeBSD boots after a crash, a kernel image can now be extracted and debugging can take place.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>A swap device that has been configured as a dump device still acts as a swap device. Dumps to non-swap devices (such as tapes or CDRWs, for example) are not supported at this time. A "swap device" is synonymous with a "swap partition."</p></div></td></tr></tbody></table></div><div class=paragraph><p>Several types of kernel crash dumps are available:</p></div><div class=dlist><dl><dt class=hdlist1>Full memory dumps</dt><dd><p>Hold the complete contents of physical memory.</p></dd><dt class=hdlist1>Minidumps</dt><dd><p>Hold only memory pages in use by the kernel (FreeBSD 6.2 and higher).</p></dd><dt class=hdlist1>Textdumps</dt><dd><p>Hold captured, scripted, or interactive debugger output (FreeBSD 7.1 and higher).</p></dd></dl></div><div class=paragraph><p>Minidumps are the default dump type as of FreeBSD 7.0, and in most cases will capture all necessary information present in a full memory dump, as most problems can be isolated only using kernel state.</p></div><div class=sect3><h4 id=config-dumpdev>10.1.1. Configuring the Dump Device<a class=anchor href=#config-dumpdev></a></h4><div class=paragraph><p>Before the kernel will dump the contents of its physical memory to a dump device, a dump device must be configured. A dump device is specified by using the <a href="https://man.freebsd.org/cgi/man.cgi?query=dumpon&amp;sektion=8&amp;format=html">dumpon(8)</a> command to tell the kernel where to save kernel crash dumps. The <a href="https://man.freebsd.org/cgi/man.cgi?query=dumpon&amp;sektion=8&amp;format=html">dumpon(8)</a> program must be called after the swap partition has been configured with <a href="https://man.freebsd.org/cgi/man.cgi?query=swapon&amp;sektion=8&amp;format=html">swapon(8)</a>. This is normally handled by setting the <code>dumpdev</code> variable in <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a> to the path of the swap device (the recommended way to extract a kernel dump) or <code>AUTO</code> to use the first configured swap device. The default for <code>dumpdev</code> is <code>AUTO</code> in HEAD, and changed to <code>NO</code> on RELENG_* branches (except for RELENG_7, which was left set to <code>AUTO</code>). On FreeBSD 9.0-RELEASE and later versions, bsdinstall will ask whether crash dumps should be enabled on the target system during the install process.</p></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Check <span class=filename>/etc/fstab</span> or <a href="https://man.freebsd.org/cgi/man.cgi?query=swapinfo&amp;sektion=8&amp;format=html">swapinfo(8)</a> for a list of swap devices.</p></div></td></tr></tbody></table></div><div class="admonitionblock important"><table><tbody><tr><td class=icon><i class="fa icon-important" title=Important></i></td><td class=content><div class=paragraph><p>Make sure the <code>dumpdir</code> specified in <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a> exists before a kernel crash!</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mkdir /var/crash</span>
<span class=c># chmod 700 /var/crash</span></code></pre></div></div><div class=paragraph><p>Also, remember that the contents of <span class=filename>/var/crash</span> is sensitive and very likely contains confidential information such as passwords.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=extract-dump>10.1.2. Extracting a Kernel Dump<a class=anchor href=#extract-dump></a></h4><div class=paragraph><p>Once a dump has been written to a dump device, the dump must be extracted before the swap device is mounted. To extract a dump from a dump device, use the <a href="https://man.freebsd.org/cgi/man.cgi?query=savecore&amp;sektion=8&amp;format=html">savecore(8)</a> program. If <code>dumpdev</code> has been set in <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=savecore&amp;sektion=8&amp;format=html">savecore(8)</a> will be called automatically on the first multi-user boot after the crash and before the swap device is mounted. The location of the extracted core is placed in the <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a> value <code>dumpdir</code>, by default <span class=filename>/var/crash</span> and will be named <span class=filename>vmcore.0</span>.</p></div><div class=paragraph><p>In the event that there is already a file called <span class=filename>vmcore.0</span> in <span class=filename>/var/crash</span> (or whatever <code>dumpdir</code> is set to), the kernel will increment the trailing number for every crash to avoid overwriting an existing <span class=filename>vmcore</span> (e.g., <span class=filename>vmcore.1</span>). <a href="https://man.freebsd.org/cgi/man.cgi?query=savecore&amp;sektion=8&amp;format=html">savecore(8)</a> will always create a symbolic link to named <span class=filename>vmcore.last</span> in <span class=filename>/var/crash</span> after a dump is saved. This symbolic link can be used to locate the name of the most recent dump.</p></div><div class=paragraph><p>The <a href="https://man.freebsd.org/cgi/man.cgi?query=crashinfo&amp;sektion=8&amp;format=html">crashinfo(8)</a> utility generates a text file containing a summary of information from a full memory dump or minidump. If <code>dumpdev</code> has been set in <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=crashinfo&amp;sektion=8&amp;format=html">crashinfo(8)</a> will be invoked automatically after <a href="https://man.freebsd.org/cgi/man.cgi?query=savecore&amp;sektion=8&amp;format=html">savecore(8)</a>. The output is saved to a file in <code>dumpdir</code> named <span class=filename>core.txt.N</span>.</p></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>If you are testing a new kernel but need to boot a different one in order to get your system up and running again, boot it only into single user mode using the <code>-s</code> flag at the boot prompt, and then perform the following steps:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># fsck -p</span>
<span class=c># mount -a -t ufs       # make sure /var/crash is writable</span>
<span class=c># savecore /var/crash /dev/ad0s1b</span>
<span class=c># exit                  # exit to multi-user</span></code></pre></div></div><div class=paragraph><p>This instructs <a href="https://man.freebsd.org/cgi/man.cgi?query=savecore&amp;sektion=8&amp;format=html">savecore(8)</a> to extract a kernel dump from <span class=filename>/dev/ad0s1b</span> and place the contents in <span class=filename>/var/crash</span>. Do not forget to make sure the destination directory <span class=filename>/var/crash</span> has enough space for the dump. Also, do not forget to specify the correct path to your swap device as it is likely different than <span class=filename>/dev/ad0s1b</span>!</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=_testing_kernel_dump_configuration>10.1.3. Testing Kernel Dump Configuration<a class=anchor href=#_testing_kernel_dump_configuration></a></h4><div class=paragraph><p>The kernel includes a <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> node that requests a kernel panic. This can be used to verify that your system is properly configured to save kernel crash dumps. You may wish to remount existing file systems as read-only in single user mode before triggering the crash to avoid data loss.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># shutdown now</span>
...
Enter full pathname of shell or RETURN <span class=k>for</span> /bin/sh:
<span class=c># mount -a -u -r</span>
<span class=c># sysctl debug.kdb.panic=1</span>
debug.kdb.panic:panic: kdb_sysctl_panic
...</code></pre></div></div><div class=paragraph><p>After rebooting, your system should save a dump in <span class=filename>/var/crash</span> along with a matching summary from <a href="https://man.freebsd.org/cgi/man.cgi?query=crashinfo&amp;sektion=8&amp;format=html">crashinfo(8)</a>.</p></div></div></div><div class=sect2><h3 id=kerneldebug-gdb>10.2. Debugging a Kernel Crash Dump with <code>kgdb</code><a class=anchor href=#kerneldebug-gdb></a></h3><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>This section covers <a href="https://man.freebsd.org/cgi/man.cgi?query=kgdb&amp;sektion=1&amp;format=html">kgdb(1)</a>. The latest version is included in the <a class=package href=https://cgit.freebsd.org/ports/tree/devel/gdb/>devel/gdb</a>. An older version is also present in FreeBSD 11 and earlier.</p></div></td></tr></tbody></table></div><div class=paragraph><p>To enter into the debugger and begin getting information from the dump, start kgdb:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kgdb -n N</span></code></pre></div></div><div class=paragraph><p>Where <em>N</em> is the suffix of the <span class=filename>vmcore.N</span> to examine. To open the most recent dump use:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kgdb -n last</span></code></pre></div></div><div class=paragraph><p>Normally, <a href="https://man.freebsd.org/cgi/man.cgi?query=kgdb&amp;sektion=1&amp;format=html">kgdb(1)</a> should be able to locate the kernel running at the time the dump was generated. If it is not able to locate the correct kernel, pass the pathname of the kernel and dump as two arguments to kgdb:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kgdb /boot/kernel/kernel /var/crash/vmcore.0</span></code></pre></div></div><div class=paragraph><p>You can debug the crash dump using the kernel sources just like you can for any other program.</p></div><div class=paragraph><p>This dump is from a 5.2-BETA kernel and the crash comes from deep within the kernel. The output below has been modified to include line numbers on the left. This first trace inspects the instruction pointer and obtains a back trace. The address that is used on line 41 for the <code>list</code> command is the instruction pointer and can be found on line 17. Most developers will request having at least this information sent to them if you are unable to debug the problem yourself. If, however, you do solve the problem, make sure that your patch winds its way into the source tree via a problem report, mailing lists, or by being able to commit it!</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> 1:# <span class=nb>cd</span> /usr/obj/usr/src/sys/KERNCONF
 2:# kgdb kernel.debug /var/crash/vmcore.0
 3:GNU gdb 5.2.1 <span class=o>(</span>FreeBSD<span class=o>)</span>
 4:Copyright 2002 Free Software Foundation, Inc.
 5:GDB is free software, covered by the GNU General Public License, and you are
 6:welcome to change it and/or distribute copies of it under certain conditions.
 7:Type <span class=s2>&#34;show copying&#34;</span> to see the conditions.
 8:There is absolutely no warranty <span class=k>for </span>GDB.  Type <span class=s2>&#34;show warranty&#34;</span> <span class=k>for </span>details.
 9:This GDB was configured as <span class=s2>&#34;i386-undermydesk-freebsd&#34;</span>...
10:panic: page fault
11:panic messages:
12:---
13:Fatal <span class=nb>trap </span>12: page fault <span class=k>while in </span>kernel mode
14:cpuid <span class=o>=</span> 0<span class=p>;</span> apic <span class=nb>id</span> <span class=o>=</span> 00
15:fault virtual address   <span class=o>=</span> 0x300
16:fault code:             <span class=o>=</span> supervisor <span class=nb>read</span>, page not present
17:instruction pointer     <span class=o>=</span> 0x8:0xc0713860
18:stack pointer           <span class=o>=</span> 0x10:0xdc1d0b70
19:frame pointer           <span class=o>=</span> 0x10:0xdc1d0b7c
20:code segment            <span class=o>=</span> base 0x0, limit 0xfffff, <span class=nb>type </span>0x1b
21:                        <span class=o>=</span> DPL 0, pres 1, def32 1, gran 1
22:processor eflags        <span class=o>=</span> resume, IOPL <span class=o>=</span> 0
23:current process         <span class=o>=</span> 14394 <span class=o>(</span><span class=nb>uname</span><span class=o>)</span>
24:trap number             <span class=o>=</span> 12
25:panic: page fault
26      cpuid <span class=o>=</span> 0<span class=p>;</span>
27:Stack backtrace:
28
29:syncing disks, buffers remaining... 2199 2199 panic: mi_switch: switch <span class=k>in </span>a critical section
30:cpuid <span class=o>=</span> 0<span class=p>;</span>
31:Uptime: 2h43m19s
32:Dumping 255 MB
33: 16 32 48 64 80 96 112 128 144 160 176 192 208 224 240
34:---
35:Reading symbols from /boot/kernel/snd_maestro3.ko...done.
36:Loaded symbols <span class=k>for</span> /boot/kernel/snd_maestro3.ko
37:Reading symbols from /boot/kernel/snd_pcm.ko...done.
38:Loaded symbols <span class=k>for</span> /boot/kernel/snd_pcm.ko
39:#0  doadump <span class=o>()</span> at /usr/src/sys/kern/kern_shutdown.c:240
40:240             dumping++<span class=p>;</span>
41:<span class=o>(</span>kgdb<span class=o>)</span> list <span class=k>*</span>0xc0713860
42:0xc0713860 is <span class=k>in </span>lapic_ipi_wait <span class=o>(</span>/usr/src/sys/i386/i386/local_apic.c:663<span class=o>)</span><span class=nb>.</span>
43:658                     incr <span class=o>=</span> 0<span class=p>;</span>
44:659                     delay <span class=o>=</span> 1<span class=p>;</span>
45:660             <span class=o>}</span> <span class=k>else
</span>46:661                     incr <span class=o>=</span> 1<span class=p>;</span>
47:662             <span class=k>for</span> <span class=o>(</span>x <span class=o>=</span> 0<span class=p>;</span> x &lt; delay<span class=p>;</span> x +<span class=o>=</span> incr<span class=o>)</span> <span class=o>{</span>
48:663                     <span class=k>if</span> <span class=o>((</span>lapic-&gt;icr_lo &amp; APIC_DELSTAT_MASK<span class=o>)</span> <span class=o>==</span> APIC_DELSTAT_IDLE<span class=o>)</span>
49:664                             <span class=k>return</span> <span class=o>(</span>1<span class=o>)</span><span class=p>;</span>
50:665                     ia32_pause<span class=o>()</span><span class=p>;</span>
51:666             <span class=o>}</span>
52:667             <span class=k>return</span> <span class=o>(</span>0<span class=o>)</span><span class=p>;</span>
53:<span class=o>(</span>kgdb<span class=o>)</span> backtrace
54:#0  doadump <span class=o>()</span> at /usr/src/sys/kern/kern_shutdown.c:240
55:#1  0xc055fd9b <span class=k>in </span>boot <span class=o>(</span><span class=nv>howto</span><span class=o>=</span>260<span class=o>)</span> at /usr/src/sys/kern/kern_shutdown.c:372
56:#2  0xc056019d <span class=k>in </span>panic <span class=o>()</span> at /usr/src/sys/kern/kern_shutdown.c:550
57:#3  0xc0567ef5 <span class=k>in </span>mi_switch <span class=o>()</span> at /usr/src/sys/kern/kern_synch.c:470
58:#4  0xc055fa87 <span class=k>in </span>boot <span class=o>(</span><span class=nv>howto</span><span class=o>=</span>256<span class=o>)</span> at /usr/src/sys/kern/kern_shutdown.c:312
59:#5  0xc056019d <span class=k>in </span>panic <span class=o>()</span> at /usr/src/sys/kern/kern_shutdown.c:550
60:#6  0xc0720c66 <span class=k>in </span>trap_fatal <span class=o>(</span><span class=nv>frame</span><span class=o>=</span>0xdc1d0b30, <span class=nv>eva</span><span class=o>=</span>0<span class=o>)</span>
61:    at /usr/src/sys/i386/i386/trap.c:821
62:#7  0xc07202b3 <span class=k>in </span><span class=nb>trap</span> <span class=o>(</span><span class=nv>frame</span><span class=o>=</span>
63:      <span class=o>{</span>tf_fs <span class=o>=</span> <span class=nt>-1065484264</span>, tf_es <span class=o>=</span> <span class=nt>-1065484272</span>, tf_ds <span class=o>=</span> <span class=nt>-1065484272</span>, tf_edi <span class=o>=</span> 1, tf_esi <span class=o>=</span> 0, tf_ebp <span class=o>=</span> <span class=nt>-602076292</span>, tf_isp <span class=o>=</span> <span class=nt>-602076324</span>, tf_ebx <span class=o>=</span> 0, tf_edx <span class=o>=</span> 0, tf_ecx <span class=o>=</span> 1000000, tf_eax <span class=o>=</span> 243, tf_trapno <span class=o>=</span> 12, tf_err <span class=o>=</span> 0, tf_eip <span class=o>=</span> <span class=nt>-1066321824</span>, tf_cs <span class=o>=</span> 8, tf_eflags <span class=o>=</span> 65671, tf_esp <span class=o>=</span> 243, tf_ss <span class=o>=</span> 0<span class=o>})</span>
64:    at /usr/src/sys/i386/i386/trap.c:250
65:#8  0xc070c9f8 <span class=k>in </span>calltrap <span class=o>()</span> at <span class=o>{</span>standard input<span class=o>}</span>:94
66:#9  0xc07139f3 <span class=k>in </span>lapic_ipi_vectored <span class=o>(</span><span class=nv>vector</span><span class=o>=</span>0, <span class=nv>dest</span><span class=o>=</span>0<span class=o>)</span>
67:    at /usr/src/sys/i386/i386/local_apic.c:733
68:#10 0xc0718b23 <span class=k>in </span>ipi_selected <span class=o>(</span><span class=nv>cpus</span><span class=o>=</span>1, <span class=nv>ipi</span><span class=o>=</span>1<span class=o>)</span>
69:    at /usr/src/sys/i386/i386/mp_machdep.c:1115
70:#11 0xc057473e <span class=k>in </span>kseq_notify <span class=o>(</span><span class=nv>ke</span><span class=o>=</span>0xcc05e360, <span class=nv>cpu</span><span class=o>=</span>0<span class=o>)</span>
71:    at /usr/src/sys/kern/sched_ule.c:520
72:#12 0xc0575cad <span class=k>in </span>sched_add <span class=o>(</span><span class=nv>td</span><span class=o>=</span>0xcbcf5c80<span class=o>)</span>
73:    at /usr/src/sys/kern/sched_ule.c:1366
74:#13 0xc05666c6 <span class=k>in </span>setrunqueue <span class=o>(</span><span class=nv>td</span><span class=o>=</span>0xcc05e360<span class=o>)</span>
75:    at /usr/src/sys/kern/kern_switch.c:422
76:#14 0xc05752f4 <span class=k>in </span>sched_wakeup <span class=o>(</span><span class=nv>td</span><span class=o>=</span>0xcbcf5c80<span class=o>)</span>
77:    at /usr/src/sys/kern/sched_ule.c:999
78:#15 0xc056816c <span class=k>in </span>setrunnable <span class=o>(</span><span class=nv>td</span><span class=o>=</span>0xcbcf5c80<span class=o>)</span>
79:    at /usr/src/sys/kern/kern_synch.c:570
80:#16 0xc0567d53 <span class=k>in </span>wakeup <span class=o>(</span><span class=nv>ident</span><span class=o>=</span>0xcbcf5c80<span class=o>)</span>
81:    at /usr/src/sys/kern/kern_synch.c:411
82:#17 0xc05490a8 <span class=k>in </span>exit1 <span class=o>(</span><span class=nv>td</span><span class=o>=</span>0xcbcf5b40, <span class=nv>rv</span><span class=o>=</span>0<span class=o>)</span>
83:    at /usr/src/sys/kern/kern_exit.c:509
84:#18 0xc0548011 <span class=k>in </span>sys_exit <span class=o>()</span> at /usr/src/sys/kern/kern_exit.c:102
85:#19 0xc0720fd0 <span class=k>in </span>syscall <span class=o>(</span><span class=nv>frame</span><span class=o>=</span>
86:      <span class=o>{</span>tf_fs <span class=o>=</span> 47, tf_es <span class=o>=</span> 47, tf_ds <span class=o>=</span> 47, tf_edi <span class=o>=</span> 0, tf_esi <span class=o>=</span> <span class=nt>-1</span>, tf_ebp <span class=o>=</span> <span class=nt>-1077940712</span>, tf_isp <span class=o>=</span> <span class=nt>-602075788</span>, tf_ebx <span class=o>=</span> 672411944, tf_edx <span class=o>=</span> 10, tf_ecx <span class=o>=</span> 672411600, tf_eax <span class=o>=</span> 1, tf_trapno <span class=o>=</span> 12, tf_err <span class=o>=</span> 2, tf_eip <span class=o>=</span> 671899563, tf_cs <span class=o>=</span> 31, tf_eflags <span class=o>=</span> 642, tf_esp <span class=o>=</span> <span class=nt>-1077940740</span>, tf_ss <span class=o>=</span> 47<span class=o>})</span>
87:    at /usr/src/sys/i386/i386/trap.c:1010
88:#20 0xc070ca4d <span class=k>in </span>Xint0x80_syscall <span class=o>()</span> at <span class=o>{</span>standard input<span class=o>}</span>:136
89:---Can<span class=s1>&#39;t read userspace from dump, or kernel process---
90:(kgdb) quit</span></code></pre></div></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>If your system is crashing regularly and you are running out of disk space, deleting old <span class=filename>vmcore</span> files in <span class=filename>/var/crash</span> could save a considerable amount of disk space!</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=kerneldebug-online-ddb>10.3. On-Line Kernel Debugging Using DDB<a class=anchor href=#kerneldebug-online-ddb></a></h3><div class=paragraph><p>While <code>kgdb</code> as an off-line debugger provides a very high level of user interface, there are some things it cannot do. The most important ones being breakpointing and single-stepping kernel code.</p></div><div class=paragraph><p>If you need to do low-level debugging on your kernel, there is an on-line debugger available called DDB. It allows setting of breakpoints, single-stepping kernel functions, examining and changing kernel variables, etc. However, it cannot access kernel source files, and only has access to the global and static symbols, not to the full debug information like <code>kgdb</code> does.</p></div><div class=paragraph><p>To configure your kernel to include DDB, add the options</p></div><div class="literalblock programlisting"><div class=content><pre>options KDB</pre></div></div><div class="literalblock programlisting"><div class=content><pre>options DDB</pre></div></div><div class=paragraph><p>to your config file, and rebuild. (See <a href=https://docs.freebsd.org/en/books/handbook//>The FreeBSD Handbook</a> for details on configuring the FreeBSD kernel).</p></div><div class=paragraph><p>Once your DDB kernel is running, there are several ways to enter DDB. The first, and earliest way is to use the boot flag <code>-d</code>. The kernel will start up in debug mode and enter DDB prior to any device probing. Hence you can even debug the device probe/attach functions. To use this, exit the loader’s boot menu and enter <code>boot -d</code> at the loader prompt.</p></div><div class=paragraph><p>The second scenario is to drop to the debugger once the system has booted. There are two simple ways to accomplish this. If you would like to break to the debugger from the command prompt, simply type the command:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl debug.kdb.enter=1</span></code></pre></div></div><div class=paragraph><p>Alternatively, if you are at the system console, you may use a hot-key on the keyboard. The default break-to-debugger sequence is <span class=keyseq><kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>ESC</kbd></span>. For syscons, this sequence can be remapped and some of the distributed maps out there do this, so check to make sure you know the right sequence to use. There is an option available for serial consoles that allows the use of a serial line BREAK on the console line to enter DDB (<code>options BREAK_TO_DEBUGGER</code> in the kernel config file). It is not the default since there are a lot of serial adapters around that gratuitously generate a BREAK condition, for example when pulling the cable.</p></div><div class=paragraph><p>The third way is that any panic condition will branch to DDB if the kernel is configured to use it. For this reason, it is not wise to configure a kernel with DDB for a machine running unattended.</p></div><div class=paragraph><p>To obtain the unattended functionality, add:</p></div><div class="literalblock programlisting"><div class=content><pre>options	KDB_UNATTENDED</pre></div></div><div class=paragraph><p>to the kernel configuration file and rebuild/reinstall.</p></div><div class=paragraph><p>The DDB commands roughly resemble some <code>gdb</code> commands. The first thing you probably need to do is to set a breakpoint:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> <span class=nb>break </span><span class=k>function</span><span class=nt>-name</span> address</code></pre></div></div><div class=paragraph><p>Numbers are taken hexadecimal by default, but to make them distinct from symbol names; hexadecimal numbers starting with the letters <code>a-f</code> need to be preceded with <code>0x</code> (this is optional for other numbers). Simple expressions are allowed, for example: <code>function-name + 0x103</code>.</p></div><div class=paragraph><p>To exit the debugger and continue execution, type:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> <span class=k>continue</span></code></pre></div></div><div class=paragraph><p>To get a stack trace of the current thread, use:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> trace</code></pre></div></div><div class=paragraph><p>To get a stack trace of an arbitrary thread, specify a process ID or thread ID as a second argument to <code>trace</code>.</p></div><div class=paragraph><p>If you want to remove a breakpoint, use</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> del
 del address-expression</code></pre></div></div><div class=paragraph><p>The first form will be accepted immediately after a breakpoint hit, and deletes the current breakpoint. The second form can remove any breakpoint, but you need to specify the exact address; this can be obtained from:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> show b</code></pre></div></div><div class=paragraph><p>or:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> show <span class=nb>break</span></code></pre></div></div><div class=paragraph><p>To single-step the kernel, try:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> s</code></pre></div></div><div class=paragraph><p>This will step into functions, but you can make DDB trace them until the matching return statement is reached by:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> n</code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>This is different from <code>gdb</code>'s <code>next</code> statement; it is like <code>gdb</code>'s <code>finish</code>. Pressing <kbd>n</kbd> more than once will cause a continue.</p></div></td></tr></tbody></table></div><div class=paragraph><p>To examine data from memory, use (for example):</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> x/wx 0xf0133fe0,40
 x/hd db_symtab_space
 x/bc termbuf,10
 x/s stringbuf</code></pre></div></div><div class=paragraph><p>for word/halfword/byte access, and hexadecimal/decimal/character/ string display. The number after the comma is the object count. To display the next 0x10 items, simply use:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> x ,10</code></pre></div></div><div class=paragraph><p>Similarly, use</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> x/ia foofunc,10</code></pre></div></div><div class=paragraph><p>to disassemble the first 0x10 instructions of <code>foofunc</code>, and display them along with their offset from the beginning of <code>foofunc</code>.</p></div><div class=paragraph><p>To modify memory, use the write command:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> w/b termbuf 0xa 0xb 0
 w/w 0xf0010030 0 0</code></pre></div></div><div class=paragraph><p>The command modifier (<code>b</code>/<code>h</code>/<code>w</code>) specifies the size of the data to be written, the first following expression is the address to write to and the remainder is interpreted as data to write to successive memory locations.</p></div><div class=paragraph><p>If you need to know the current registers, use:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> show reg</code></pre></div></div><div class=paragraph><p>Alternatively, you can display a single register value by e.g.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> p <span class=nv>$eax</span></code></pre></div></div><div class=paragraph><p>and modify it by:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> <span class=nb>set</span> <span class=nv>$eax</span> new-value</code></pre></div></div><div class=paragraph><p>Should you need to call some kernel functions from DDB, simply say:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> call func<span class=o>(</span>arg1, arg2, ...<span class=o>)</span></code></pre></div></div><div class=paragraph><p>The return value will be printed.</p></div><div class=paragraph><p>For a <a href="https://man.freebsd.org/cgi/man.cgi?query=ps&amp;sektion=1&amp;format=html">ps(1)</a> style summary of all running processes, use:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> ps</code></pre></div></div><div class=paragraph><p>Now you have examined why your kernel failed, and you wish to reboot. Remember that, depending on the severity of previous malfunctioning, not all parts of the kernel might still be working as expected. Perform one of the following actions to shut down and reboot your system:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> panic</code></pre></div></div><div class=paragraph><p>This will cause your kernel to dump core and reboot, so you can later analyze the core on a higher level with <a href="https://man.freebsd.org/cgi/man.cgi?query=kgdb&amp;sektion=1&amp;format=html">kgdb(1)</a>.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> call boot<span class=o>(</span>0<span class=o>)</span></code></pre></div></div><div class=paragraph><p>Might be a good way to cleanly shut down the running system, <code>sync()</code> all disks, and finally, in some cases, reboot. As long as the disk and filesystem interfaces of the kernel are not damaged, this could be a good way for an almost clean shutdown.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> reset</code></pre></div></div><div class=paragraph><p>This is the final way out of disaster and almost the same as hitting the Big Red Button.</p></div><div class=paragraph><p>If you need a short command summary, simply type:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> <span class=nb>help</span></code></pre></div></div><div class=paragraph><p>It is highly recommended to have a printed copy of the <a href="https://man.freebsd.org/cgi/man.cgi?query=ddb&amp;sektion=4&amp;format=html">ddb(4)</a> manual page ready for a debugging session. Remember that it is hard to read the on-line manual while single-stepping the kernel.</p></div></div><div class=sect2><h3 id=kerneldebug-online-gdb>10.4. On-Line Kernel Debugging Using Remote GDB<a class=anchor href=#kerneldebug-online-gdb></a></h3><div class=paragraph><p>This feature has been supported since FreeBSD 2.2, and it is actually a very neat one.</p></div><div class=paragraph><p>GDB has already supported <em>remote debugging</em> for a long time. This is done using a very simple protocol along a serial line. Unlike the other methods described above, you will need two machines for doing this. One is the host providing the debugging environment, including all the sources, and a copy of the kernel binary with all the symbols in it, and the other one is the target machine that simply runs a similar copy of the very same kernel (but stripped of the debugging information).</p></div><div class=paragraph><p>You should configure the kernel in question with <code>config -g</code> if building the "traditional" way. If building the "new" way, make sure that <code>makeoptions DEBUG=-g</code> is in the configuration. In both cases, include <code>DDB</code> in the configuration, and compile it as usual. This gives a large binary, due to the debugging information. Copy this kernel to the target machine, strip the debugging symbols off with <code>strip -x</code>, and boot it using the <code>-d</code> boot option. Connect the serial line of the target machine that has "flags 080" set on its uart device to any serial line of the debugging host. See <a href="https://man.freebsd.org/cgi/man.cgi?query=uart&amp;sektion=4&amp;format=html">uart(4)</a> for information on how to set the flags on an uart device. Now, on the debugging machine, go to the compile directory of the target kernel, and start <code>gdb</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% kgdb kernel
GDB is free software and you are welcome to distribute copies of it
 under certain conditions<span class=p>;</span> <span class=nb>type</span> <span class=s2>&#34;show copying&#34;</span> to see the conditions.
There is absolutely no warranty <span class=k>for </span>GDB<span class=p>;</span> <span class=nb>type</span> <span class=s2>&#34;show warranty&#34;</span> <span class=k>for </span>details.
GDB 4.16 <span class=o>(</span>i386-unknown-freebsd<span class=o>)</span>,
Copyright 1996 Free Software Foundation, Inc...
<span class=o>(</span>kgdb<span class=o>)</span></code></pre></div></div><div class=paragraph><p>Initialize the remote debugging session (assuming the first serial port is being used) by:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=o>(</span>kgdb<span class=o>)</span> target remote /dev/cuau0</code></pre></div></div><div class=paragraph><p>Now, on the target host (the one that entered DDB right before even starting the device probe), type:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Debugger<span class=o>(</span><span class=s2>&#34;Boot flags requested debugger&#34;</span><span class=o>)</span>
Stopped at Debugger+0x35: movb	<span class=nv>$0</span>, edata+0x51bc
db&gt; gdb</code></pre></div></div><div class=paragraph><p>DDB will respond with:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Next <span class=nb>trap </span>will enter GDB remote protocol mode</code></pre></div></div><div class=paragraph><p>Every time you type <code>gdb</code>, the mode will be toggled between remote GDB and local DDB. In order to force a next trap immediately, simply type <code>s</code> (step). Your hosting GDB will now gain control over the target kernel:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Remote debugging using /dev/cuau0
Debugger <span class=o>(</span><span class=nv>msg</span><span class=o>=</span>0xf01b0383 <span class=s2>&#34;Boot flags requested debugger&#34;</span><span class=o>)</span>
    at ../../i386/i386/db_interface.c:257
<span class=o>(</span>kgdb<span class=o>)</span></code></pre></div></div><div class=paragraph><p>You can use this session almost as any other GDB session, including full access to the source, running it in gud-mode inside an Emacs window (which gives you an automatic source code display in another Emacs window), etc.</p></div></div><div class=sect2><h3 id=kerneldebug-console>10.5. Debugging a Console Driver<a class=anchor href=#kerneldebug-console></a></h3><div class=paragraph><p>Since you need a console driver to run DDB on, things are more complicated if the console driver itself is failing. You might remember the use of a serial console (either with modified boot blocks, or by specifying <code>-h</code> at the <code>Boot:</code> prompt), and hook up a standard terminal onto your first serial port. DDB works on any configured console driver, including a serial console.</p></div></div><div class=sect2><h3 id=kerneldebug-deadlocks>10.6. Debugging Deadlocks<a class=anchor href=#kerneldebug-deadlocks></a></h3><div class=paragraph><p>You may experience so called deadlocks, a situation where a system stops doing useful work. To provide a helpful bug report in this situation, use <a href="https://man.freebsd.org/cgi/man.cgi?query=ddb&amp;sektion=4&amp;format=html">ddb(4)</a> as described in the previous section. Include the output of <code>ps</code> and <code>trace</code> for suspected processes in the report.</p></div><div class=paragraph><p>If possible, consider doing further investigation. The recipe below is especially useful if you suspect that a deadlock occurs in the VFS layer. Add these options to the kernel configuration file.</p></div><div class="literalblock programlisting"><div class=content><pre>makeoptions 	DEBUG=-g
options 	INVARIANTS
options 	INVARIANT_SUPPORT
options 	WITNESS
options 	WITNESS_SKIPSPIN
options 	DEBUG_LOCKS
options 	DEBUG_VFS_LOCKS
options 	DIAGNOSTIC</pre></div></div><div class=paragraph><p>When a deadlock occurs, in addition to the output of the <code>ps</code> command, provide information from the <code>show pcpu</code>, <code>show allpcpu</code>, <code>show locks</code>, <code>show alllocks</code>, <code>show lockedvnods</code> and <code>alltrace</code>.</p></div><div class=paragraph><p>To obtain meaningful backtraces for threaded processes, use <code>thread thread-id</code> to switch to the thread stack, and do a backtrace with <code>where</code>.</p></div></div><div class=sect2><h3 id=kerneldebug-dcons>10.7. Kernel debugging with Dcons<a class=anchor href=#kerneldebug-dcons></a></h3><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=dcons&amp;sektion=4&amp;format=html">dcons(4)</a> is a very simple console driver that is not directly connected with any physical devices. It just reads and writes characters from and to a buffer in a kernel or loader. Due to its simple nature, it is very useful for kernel debugging, especially with a FireWire® device. Currently, FreeBSD provides two ways to interact with the buffer from outside of the kernel using <a href="https://man.freebsd.org/cgi/man.cgi?query=dconschat&amp;sektion=8&amp;format=html">dconschat(8)</a>.</p></div><div class=sect3><h4 id=_dcons_over_firewire>10.7.1. Dcons over FireWire®<a class=anchor href=#_dcons_over_firewire></a></h4><div class=paragraph><p>Most FireWire® (IEEE1394) host controllers are based on the OHCI specification that supports physical access to the host memory. This means that once the host controller is initialized, we can access the host memory without the help of software (kernel). We can exploit this facility for interaction with <a href="https://man.freebsd.org/cgi/man.cgi?query=dcons&amp;sektion=4&amp;format=html">dcons(4)</a>. <a href="https://man.freebsd.org/cgi/man.cgi?query=dcons&amp;sektion=4&amp;format=html">dcons(4)</a> provides similar functionality as a serial console. It emulates two serial ports, one for the console and DDB, the other for GDB. Because remote memory access is fully handled by the hardware, the <a href="https://man.freebsd.org/cgi/man.cgi?query=dcons&amp;sektion=4&amp;format=html">dcons(4)</a> buffer is accessible even when the system crashes.</p></div><div class=paragraph><p>FireWire® devices are not limited to those integrated into motherboards. PCI cards exist for desktops, and a cardbus interface can be purchased for laptops.</p></div><div class=sect4><h5 id=_enabling_firewire_and_dcons_support_on_the_target_machine>10.7.1.1. Enabling FireWire® and Dcons support on the target machine<a class=anchor href=#_enabling_firewire_and_dcons_support_on_the_target_machine></a></h5><div class=paragraph><p>To enable FireWire® and Dcons support in the kernel of the <em>target machine</em>:</p></div><div class=ulist><ul><li><p>Make sure your kernel supports <code>dcons</code>, <code>dcons_crom</code> and <code>firewire</code>. <code>Dcons</code> should be statically linked with the kernel. For <code>dcons_crom</code> and <code>firewire</code>, modules should be OK.</p></li><li><p>Make sure physical DMA is enabled. You may need to add <code>hw.firewire.phydma_enable=1</code> to <span class=filename>/boot/loader.conf</span>.</p></li><li><p>Add options for debugging.</p></li><li><p>Add <code>dcons_gdb=1</code> in <span class=filename>/boot/loader.conf</span> if you use GDB over FireWire®.</p></li><li><p>Enable <code>dcons</code> in <span class=filename>/etc/ttys</span>.</p></li><li><p>Optionally, to force <code>dcons</code> to be the high-level console, add <code>hw.firewire.dcons_crom.force_console=1</code> to <span class=filename>loader.conf</span>.</p></li></ul></div><div class=paragraph><p>To enable FireWire® and Dcons support in <a href="https://man.freebsd.org/cgi/man.cgi?query=loader&amp;sektion=8&amp;format=html">loader(8)</a> on i386 or amd64:</p></div><div class=paragraph><p>Add <code>LOADER_FIREWIRE_SUPPORT=YES</code> in <span class=filename>/etc/make.conf</span> and rebuild <a href="https://man.freebsd.org/cgi/man.cgi?query=loader&amp;sektion=8&amp;format=html">loader(8)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /sys/boot/i386 &amp;&amp; make clean &amp;&amp; make &amp;&amp; make install</span></code></pre></div></div><div class=paragraph><p>To enable <a href="https://man.freebsd.org/cgi/man.cgi?query=dcons&amp;sektion=4&amp;format=html">dcons(4)</a> as an active low-level console, add <code>boot_multicons="YES"</code> to <span class=filename>/boot/loader.conf</span>.</p></div><div class=paragraph><p>Here are a few configuration examples. A sample kernel configuration file would contain:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>device dcons
device dcons_crom
options KDB
options DDB
options GDB
options ALT_BREAK_TO_DEBUGGER</code></pre></div></div><div class=paragraph><p>And a sample <span class=filename>/boot/loader.conf</span> would contain:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=nv>dcons_crom_load</span><span class=o>=</span><span class=s2>&#34;YES&#34;</span>
<span class=nv>dcons_gdb</span><span class=o>=</span>1
<span class=nv>boot_multicons</span><span class=o>=</span><span class=s2>&#34;YES&#34;</span>
hw.firewire.phydma_enable<span class=o>=</span>1
hw.firewire.dcons_crom.force_console<span class=o>=</span>1</code></pre></div></div></div><div class=sect4><h5 id=_enabling_firewire_and_dcons_support_on_the_host_machine>10.7.1.2. Enabling FireWire® and Dcons support on the host machine<a class=anchor href=#_enabling_firewire_and_dcons_support_on_the_host_machine></a></h5><div class=paragraph><p>To enable FireWire® support in the kernel on the <em>host machine</em>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload firewire</span></code></pre></div></div><div class=paragraph><p>Find out the EUI64 (the unique 64 bit identifier) of the FireWire® host controller, and use <a href="https://man.freebsd.org/cgi/man.cgi?query=fwcontrol&amp;sektion=8&amp;format=html">fwcontrol(8)</a> or <code>dmesg</code> to find the EUI64 of the target machine.</p></div><div class=paragraph><p>Run <a href="https://man.freebsd.org/cgi/man.cgi?query=dconschat&amp;sektion=8&amp;format=html">dconschat(8)</a>, with:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dconschat -e \# -br -G 12345 -t 00-11-22-33-44-55-66-77</span></code></pre></div></div><div class=paragraph><p>The following key combinations can be used once <a href="https://man.freebsd.org/cgi/man.cgi?query=dconschat&amp;sektion=8&amp;format=html">dconschat(8)</a> is running:</p></div><table class="tableblock frame-all grid-all stretch informaltable"><col style=width:50%><col style=width:50%><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=keyseq><kbd>~</kbd>+<kbd>.</kbd></span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Disconnect</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><kbd>~</kbd></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>ALT BREAK</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><kbd>~</kbd></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>RESET target</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><kbd>~</kbd></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Suspend dconschat</p></td></tr></tbody></table><div class=paragraph><p>Attach remote GDB by starting <a href="https://man.freebsd.org/cgi/man.cgi?query=kgdb&amp;sektion=1&amp;format=html">kgdb(1)</a> with a remote debugging session:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> kgdb <span class=nt>-r</span> :12345 kernel</code></pre></div></div></div><div class=sect4><h5 id=_some_general_tips>10.7.1.3. Some general tips<a class=anchor href=#_some_general_tips></a></h5><div class=paragraph><p>Here are some general tips:</p></div><div class=paragraph><p>To take full advantage of the speed of FireWire®, disable other slow console drivers:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># conscontrol delete ttyd0	     # serial console</span>
<span class=c># conscontrol delete consolectl	# video/keyboard</span></code></pre></div></div><div class=paragraph><p>There exists a GDB mode for <a href="https://man.freebsd.org/cgi/man.cgi?query=emacs&amp;sektion=1&amp;format=html">emacs(1)</a>; this is what you will need to add to your <span class=filename>.emacs</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=o>(</span>setq gud-gdba-command-name <span class=s2>&#34;kgdb -a -a -a -r :12345&#34;</span><span class=o>)</span>
<span class=o>(</span>setq gdb-many-windows t<span class=o>)</span>
<span class=o>(</span>xterm-mouse-mode 1<span class=o>)</span>
M-x gdba</code></pre></div></div><div class=paragraph><p>And for DDD (<span class=filename>devel/ddd</span>):</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># remote serial protocol</span>
<span class=nv>LANG</span><span class=o>=</span>C ddd <span class=nt>--debugger</span> kgdb <span class=nt>-r</span> :12345 kernel
<span class=c># live core debug</span>
<span class=nv>LANG</span><span class=o>=</span>C ddd <span class=nt>--debugger</span> kgdb kernel /dev/fwmem0.2</code></pre></div></div></div></div><div class=sect3><h4 id=_dcons_with_kvm>10.7.2. Dcons with KVM<a class=anchor href=#_dcons_with_kvm></a></h4><div class=paragraph><p>We can directly read the <a href="https://man.freebsd.org/cgi/man.cgi?query=dcons&amp;sektion=4&amp;format=html">dcons(4)</a> buffer via <span class=filename>/dev/mem</span> for live systems, and in the core dump for crashed systems. These give you similar output to <code>dmesg -a</code>, but the <a href="https://man.freebsd.org/cgi/man.cgi?query=dcons&amp;sektion=4&amp;format=html">dcons(4)</a> buffer includes more information.</p></div><div class=sect4><h5 id=_using_dcons_with_kvm>10.7.2.1. Using Dcons with KVM<a class=anchor href=#_using_dcons_with_kvm></a></h5><div class=paragraph><p>To use <a href="https://man.freebsd.org/cgi/man.cgi?query=dcons&amp;sektion=4&amp;format=html">dcons(4)</a> with KVM:</p></div><div class=paragraph><p>Dump a <a href="https://man.freebsd.org/cgi/man.cgi?query=dcons&amp;sektion=4&amp;format=html">dcons(4)</a> buffer of a live system:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dconschat -1</span></code></pre></div></div><div class=paragraph><p>Dump a <a href="https://man.freebsd.org/cgi/man.cgi?query=dcons&amp;sektion=4&amp;format=html">dcons(4)</a> buffer of a crash dump:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dconschat -1 -M vmcore.XX</span></code></pre></div></div><div class=paragraph><p>Live core debugging can be done via:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># fwcontrol -m target_eui64</span>
<span class=c># kgdb kernel /dev/fwmem0.2</span></code></pre></div></div></div></div></div><div class=sect2><h3 id=kerneldebug-options>10.8. Glossary of Kernel Options for Debugging<a class=anchor href=#kerneldebug-options></a></h3><div class=paragraph><p>This section provides a brief glossary of compile-time kernel options used for debugging:</p></div><div class=ulist><ul><li><p><code>options KDB</code>: compiles in the kernel debugger framework. Required for <code>options DDB</code> and <code>options GDB</code>. Little or no performance overhead. By default, the debugger will be entered on panic instead of an automatic reboot.</p></li><li><p><code>options KDB_UNATTENDED</code>: change the default value of the <code>debug.debugger_on_panic</code> sysctl to 0, which controls whether the debugger is entered on panic. When <code>options KDB</code> is not compiled into the kernel, the behavior is to automatically reboot on panic; when it is compiled into the kernel, the default behavior is to drop into the debugger unless <code>options KDB_UNATTENDED</code> is compiled in. If you want to leave the kernel debugger compiled into the kernel but want the system to come back up unless you’re on-hand to use the debugger for diagnostics, use this option.</p></li><li><p><code>options KDB_TRACE</code>: change the default value of the <code>debug.trace_on_panic</code> sysctl to 1, which controls whether the debugger automatically prints a stack trace on panic. Especially if running with <code>options KDB_UNATTENDED</code>, this can be helpful to gather basic debugging information on the serial or firewire console while still rebooting to recover.</p></li><li><p><code>options DDB</code>: compile in support for the console debugger, DDB. This interactive debugger runs on whatever the active low-level console of the system is, which includes the video console, serial console, or firewire console. It provides basic integrated debugging facilities, such as stack tracing, process and thread listing, dumping of lock state, VM state, file system state, and kernel memory management. DDB does not require software running on a second machine or being able to generate a core dump or full debugging kernel symbols, and provides detailed diagnostics of the kernel at run-time. Many bugs can be fully diagnosed using only DDB output. This option depends on <code>options KDB</code>.</p></li><li><p><code>options GDB</code>: compile in support for the remote debugger, GDB, which can operate over serial cable or firewire. When the debugger is entered, GDB may be attached to inspect structure contents, generate stack traces, etc. Some kernel state is more awkward to access than in DDB, which is able to generate useful summaries of kernel state automatically, such as automatically walking lock debugging or kernel memory management structures, and a second machine running the debugger is required. On the other hand, GDB combines information from the kernel source and full debugging symbols, and is aware of full data structure definitions, local variables, and is scriptable. This option is not required to run GDB on a kernel core dump. This option depends on <code>options KDB</code>.</p></li><li><p><code>options BREAK_TO_DEBUGGER</code>, <code>options ALT_BREAK_TO_DEBUGGER</code>: allow a break signal or alternative signal on the console to enter the debugger. If the system hangs without a panic, this is a useful way to reach the debugger. Due to the current kernel locking, a break signal generated on a serial console is significantly more reliable at getting into the debugger, and is generally recommended. This option has little or no performance impact.</p></li><li><p><code>options INVARIANTS</code>: compile into the kernel a large number of run-time assertion checks and tests, which constantly test the integrity of kernel data structures and the invariants of kernel algorithms. These tests can be expensive, so are not compiled in by default, but help provide useful "fail stop" behavior, in which certain classes of undesired behavior enter the debugger before kernel data corruption occurs, making them easier to debug. Tests include memory scrubbing and use-after-free testing, which is one of the more significant sources of overhead. This option depends on <code>options INVARIANT_SUPPORT</code>.</p></li><li><p><code>options INVARIANT_SUPPORT</code>: many of the tests present in <code>options INVARIANTS</code> require modified data structures or additional kernel symbols to be defined.</p></li><li><p><code>options WITNESS</code>: this option enables run-time lock order tracking and verification, and is an invaluable tool for deadlock diagnosis. WITNESS maintains a graph of acquired lock orders by lock type, and checks the graph at each acquire for cycles (implicit or explicit). If a cycle is detected, a warning and stack trace are generated to the console, indicating that a potential deadlock might have occurred. WITNESS is required in order to use the <code>show locks</code>, <code>show witness</code> and <code>show alllocks</code> DDB commands. This debug option has significant performance overhead, which may be somewhat mitigated through the use of <code>options WITNESS_SKIPSPIN</code>. Detailed documentation may be found in <a href="https://man.freebsd.org/cgi/man.cgi?query=witness&amp;sektion=4&amp;format=html">witness(4)</a>.</p></li><li><p><code>options WITNESS_SKIPSPIN</code>: disable run-time checking of spinlock lock order with WITNESS. As spin locks are acquired most frequently in the scheduler, and scheduler events occur often, this option can significantly speed up systems running with WITNESS. This option depends on <code>options WITNESS</code>.</p></li><li><p><code>options WITNESS_KDB</code>: change the default value of the <code>debug.witness.kdb</code> sysctl to 1, which causes WITNESS to enter the debugger when a lock order violation is detected, rather than simply printing a warning. This option depends on <code>options WITNESS</code>.</p></li><li><p><code>options SOCKBUF_DEBUG</code>: perform extensive run-time consistency checking on socket buffers, which can be useful for debugging both socket bugs and race conditions in protocols and device drivers that interact with sockets. This option significantly impacts network performance, and may change the timing in device driver races.</p></li><li><p><code>options DEBUG_VFS_LOCKS</code>: track lock acquisition points for lockmgr/vnode locks, expanding the amount of information displayed by <code>show lockedvnods</code> in DDB. This option has a measurable performance impact.</p></li><li><p><code>options DEBUG_MEMGUARD</code>: a replacement for the <a href="https://man.freebsd.org/cgi/man.cgi?query=malloc&amp;sektion=9&amp;format=html">malloc(9)</a> kernel memory allocator that uses the VM system to detect reads or writes from allocated memory after free. Details may be found in <a href="https://man.freebsd.org/cgi/man.cgi?query=memguard&amp;sektion=9&amp;format=html">memguard(9)</a>. This option has a significant performance impact, but can be very helpful in debugging kernel memory corruption bugs.</p></li><li><p><code>options DIAGNOSTIC</code>: enable additional, more expensive diagnostic tests along the lines of <code>options INVARIANTS</code>.</p></li></ul></div></div></div></div><h1 id=architectures class=sect0>Part IV: Architectures(電腦架構)<a class=anchor href=#architectures></a></h1><div class=sect1><h2 id=x86>Chapter 11. x86 Assembly Language Programming<a class=anchor href=#x86></a></h2><div class=sectionbody><div class=paragraph><p><em>This chapter was written by G. Adam Stanislav &lt;<a href=mailto:adam@redprince.net>adam@redprince.net</a>>.</em></p></div><div class=sect2><h3 id=x86-intro>11.1. Synopsis<a class=anchor href=#x86-intro></a></h3><div class=paragraph><p>Assembly language programming under UNIX® is highly undocumented. It is generally assumed that no one would ever want to use it because various UNIX® systems run on different microprocessors, so everything should be written in C for portability.</p></div><div class=paragraph><p>In reality, C portability is quite a myth. Even C programs need to be modified when ported from one UNIX® to another, regardless of what processor each runs on. Typically, such a program is full of conditional statements depending on the system it is compiled for.</p></div><div class=paragraph><p>Even if we believe that all of UNIX® software should be written in C, or some other high-level language, we still need assembly language programmers: Who else would write the section of C library that accesses the kernel?</p></div><div class=paragraph><p>In this chapter I will attempt to show you how you can use assembly language writing UNIX® programs, specifically under FreeBSD.</p></div><div class=paragraph><p>This chapter does not explain the basics of assembly language. There are enough resources about that (for a complete online course in assembly language, see Randall Hyde’s <a href=http://webster.cs.ucr.edu/>Art of Assembly Language</a>; or if you prefer a printed book, take a look at Jeff Duntemann’s Assembly Language Step-by-Step (ISBN: 0471375233). However, once the chapter is finished, any assembly language programmer will be able to write programs for FreeBSD quickly and efficiently.</p></div><div class=paragraph><p>Copyright ® 2000-2001 G. Adam Stanislav. All rights reserved.</p></div></div><div class=sect2><h3 id=x86-the-tools>11.2. The Tools<a class=anchor href=#x86-the-tools></a></h3><div class=sect3><h4 id=x86-the-assembler>11.2.1. The Assembler<a class=anchor href=#x86-the-assembler></a></h4><div class=paragraph><p>The most important tool for assembly language programming is the assembler, the software that converts assembly language code into machine language.</p></div><div class=paragraph><p>Two very different assemblers are available for FreeBSD. One is <a href="https://man.freebsd.org/cgi/man.cgi?query=as&amp;sektion=1&amp;format=html">as(1)</a>, which uses the traditional UNIX® assembly language syntax. It comes with the system.</p></div><div class=paragraph><p>The other is /usr/ports/devel/nasm. It uses the Intel syntax. Its main advantage is that it can assemble code for many operating systems. It needs to be installed separately, but is completely free.</p></div><div class=paragraph><p>This chapter uses nasm syntax because most assembly language programmers coming to FreeBSD from other operating systems will find it easier to understand. And, because, quite frankly, that is what I am used to.</p></div></div><div class=sect3><h4 id=x86-the-linker>11.2.2. The Linker<a class=anchor href=#x86-the-linker></a></h4><div class=paragraph><p>The output of the assembler, like that of any compiler, needs to be linked to form an executable file.</p></div><div class=paragraph><p>The standard <a href="https://man.freebsd.org/cgi/man.cgi?query=ld&amp;sektion=1&amp;format=html">ld(1)</a> linker comes with FreeBSD. It works with the code assembled with either assembler.</p></div></div></div><div class=sect2><h3 id=x86-system-calls>11.3. System Calls<a class=anchor href=#x86-system-calls></a></h3><div class=sect3><h4 id=x86-default-calling-convention>11.3.1. Default Calling Convention<a class=anchor href=#x86-default-calling-convention></a></h4><div class=paragraph><p>By default, the FreeBSD kernel uses the C calling convention. Further, although the kernel is accessed using <code>int 80h</code>, it is assumed the program will call a function that issues <code>int 80h</code>, rather than issuing <code>int 80h</code> directly.</p></div><div class=paragraph><p>This convention is very convenient, and quite superior to the Microsoft® convention used by MS-DOS®. Why? Because the UNIX® convention allows any program written in any language to access the kernel.</p></div><div class=paragraph><p>An assembly language program can do that as well. For example, we could open a file:</p></div><div class="literalblock programlisting"><div class=content><pre>kernel:
	int	80h	; Call kernel
	ret

open:
	push	dword mode
	push	dword flags
	push	dword path
	mov	eax, 5
	call	kernel
	add	esp, byte 12
	ret</pre></div></div><div class=paragraph><p>This is a very clean and portable way of coding. If you need to port the code to a UNIX® system which uses a different interrupt, or a different way of passing parameters, all you need to change is the kernel procedure.</p></div><div class=paragraph><p>But assembly language programmers like to shave off cycles. The above example requires a <code>call/ret</code> combination. We can eliminate it by <code>push</code>ing an extra dword:</p></div><div class="literalblock programlisting"><div class=content><pre>open:
	push	dword mode
	push	dword flags
	push	dword path
	mov	eax, 5
	push	eax		; Or any other dword
	int	80h
	add	esp, byte 16</pre></div></div><div class=paragraph><p>The <code>5</code> that we have placed in <code>EAX</code> identifies the kernel function, in this case <code>open</code>.</p></div></div><div class=sect3><h4 id=x86-alternate-calling-convention>11.3.2. Alternate Calling Convention<a class=anchor href=#x86-alternate-calling-convention></a></h4><div class=paragraph><p>FreeBSD is an extremely flexible system. It offers other ways of calling the kernel. For it to work, however, the system must have Linux emulation installed.</p></div><div class=paragraph><p>Linux is a UNIX® like system. However, its kernel uses the same system-call convention of passing parameters in registers MS-DOS® does. As with the UNIX® convention, the function number is placed in <code>EAX</code>. The parameters, however, are not passed on the stack but in <code>EBX, ECX, EDX, ESI, EDI, EBP</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>open:
	mov	eax, 5
	mov	ebx, path
	mov	ecx, flags
	mov	edx, mode
	int	80h</pre></div></div><div class=paragraph><p>This convention has a great disadvantage over the UNIX® way, at least as far as assembly language programming is concerned: Every time you make a kernel call you must <code>push</code> the registers, then <code>pop</code> them later. This makes your code bulkier and slower. Nevertheless, FreeBSD gives you a choice.</p></div><div class=paragraph><p>If you do choose the Linux convention, you must let the system know about it. After your program is assembled and linked, you need to brand the executable:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% brandelf <span class=nt>-t</span> Linux filename</code></pre></div></div></div><div class=sect3><h4 id=x86-use-geneva>11.3.3. Which Convention Should You Use?<a class=anchor href=#x86-use-geneva></a></h4><div class=paragraph><p>If you are coding specifically for FreeBSD, you should always use the UNIX® convention: It is faster, you can store global variables in registers, you do not have to brand the executable, and you do not impose the installation of the Linux emulation package on the target system.</p></div><div class=paragraph><p>If you want to create portable code that can also run on Linux, you will probably still want to give the FreeBSD users as efficient a code as possible. I will show you how you can accomplish that after I have explained the basics.</p></div></div><div class=sect3><h4 id=x86-call-numbers>11.3.4. Call Numbers<a class=anchor href=#x86-call-numbers></a></h4><div class=paragraph><p>To tell the kernel which system service you are calling, place its number in <code>EAX</code>. Of course, you need to know what the number is.</p></div><div class=sect4><h5 id=x86-the-syscalls-file>11.3.4.1. The <span class=filename>syscalls</span> File<a class=anchor href=#x86-the-syscalls-file></a></h5><div class=paragraph><p>The numbers are listed in <span class=filename>syscalls</span>. <code>locate syscalls</code> finds this file in several different formats, all produced automatically from <span class=filename>syscalls.master</span>.</p></div><div class=paragraph><p>You can find the master file for the default UNIX® calling convention in <span class=filename>/usr/src/sys/kern/syscalls.master</span>. If you need to use the other convention implemented in the Linux emulation mode, read <span class=filename>/usr/src/sys/i386/linux/syscalls.master</span>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Not only do FreeBSD and Linux use different calling conventions, they sometimes use different numbers for the same functions.</p></div></td></tr></tbody></table></div><div class=paragraph><p><span class=filename>syscalls.master</span> describes how the call is to be made:</p></div><div class="literalblock programlisting"><div class=content><pre>0	STD	NOHIDE	{ int nosys(void); } syscall nosys_args int
1	STD	NOHIDE	{ void exit(int rval); } exit rexit_args void
2	STD	POSIX	{ int fork(void); }
3	STD	POSIX	{ ssize_t read(int fd, void *buf, size_t nbyte); }
4	STD	POSIX	{ ssize_t write(int fd, const void *buf, size_t nbyte); }
5	STD	POSIX	{ int open(char *path, int flags, int mode); }
6	STD	POSIX	{ int close(int fd); }
etc...</pre></div></div><div class=paragraph><p>It is the leftmost column that tells us the number to place in <code>EAX</code>.</p></div><div class=paragraph><p>The rightmost column tells us what parameters to <code>push</code>. They are <code>push</code>ed <em>from right to left</em>.</p></div><div class=paragraph><p>For example, to <code>open</code> a file, we need to <code>push</code> the <code>mode</code> first, then <code>flags</code>, then the address at which the <code>path</code> is stored.</p></div></div></div></div><div class=sect2><h3 id=x86-return-values>11.4. Return Values<a class=anchor href=#x86-return-values></a></h3><div class=paragraph><p>A system call would not be useful most of the time if it did not return some kind of a value: The file descriptor of an open file, the number of bytes read to a buffer, the system time, etc.</p></div><div class=paragraph><p>Additionally, the system needs to inform us if an error occurs: A file does not exist, system resources are exhausted, we passed an invalid parameter, etc.</p></div><div class=sect3><h4 id=x86-man-pages>11.4.1. Man Pages<a class=anchor href=#x86-man-pages></a></h4><div class=paragraph><p>The traditional place to look for information about various system calls under UNIX® systems are the manual pages. FreeBSD describes its system calls in section 2, sometimes in section 3.</p></div><div class=paragraph><p>For example, <a href="https://man.freebsd.org/cgi/man.cgi?query=open&amp;sektion=2&amp;format=html">open(2)</a> says:</p></div><div class="paragraph blockquote"><p>If successful, <code>open()</code> returns a non-negative integer, termed a file descriptor. It returns <code>-1</code> on failure, and sets <code>errno</code> to indicate the error.</p></div><div class=paragraph><p>The assembly language programmer new to UNIX® and FreeBSD will immediately ask the puzzling question: Where is <code>errno</code> and how do I get to it?</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>The information presented in the manual pages applies to C programs. The assembly language programmer needs additional information.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=x86-where-return-values>11.4.2. Where Are the Return Values?<a class=anchor href=#x86-where-return-values></a></h4><div class=paragraph><p>Unfortunately, it depends…​ For most system calls it is in <code>EAX</code>, but not for all. A good rule of thumb, when working with a system call for the first time, is to look for the return value in <code>EAX</code>. If it is not there, you need further research.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>I am aware of one system call that returns the value in <code>EDX</code>: <code>SYS_fork</code>. All others I have worked with use <code>EAX</code>. But I have not worked with them all yet.</p></div></td></tr></tbody></table></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>If you cannot find the answer here or anywhere else, study libc source code and see how it interfaces with the kernel.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=x86-where-errno>11.4.3. Where Is <code>errno</code>?<a class=anchor href=#x86-where-errno></a></h4><div class=paragraph><p>Actually, nowhere…​</p></div><div class=paragraph><p><code>errno</code> is part of the C language, not the UNIX® kernel. When accessing kernel services directly, the error code is returned in <code>EAX</code>, the same register the proper return value generally ends up in.</p></div><div class=paragraph><p>This makes perfect sense. If there is no error, there is no error code. If there is an error, there is no return value. One register can contain either.</p></div></div><div class=sect3><h4 id=x86-how-to-know-error>11.4.4. Determining an Error Occurred<a class=anchor href=#x86-how-to-know-error></a></h4><div class=paragraph><p>When using the standard FreeBSD calling convention, the <code>carry flag</code> is cleared upon success, set upon failure.</p></div><div class=paragraph><p>When using the Linux emulation mode, the signed value in <code>EAX</code> is non-negative upon success, and contains the return value. In case of an error, the value is negative, i.e., <code>-errno</code>.</p></div></div></div><div class=sect2><h3 id=x86-portable-code>11.5. Creating Portable Code<a class=anchor href=#x86-portable-code></a></h3><div class=paragraph><p>Portability is generally not one of the strengths of assembly language. Yet, writing assembly language programs for different platforms is possible, especially with nasm. I have written assembly language libraries that can be assembled for such different operating systems as Windows® and FreeBSD.</p></div><div class=paragraph><p>It is all the more possible when you want your code to run on two platforms which, while different, are based on similar architectures.</p></div><div class=paragraph><p>For example, FreeBSD is UNIX®, Linux is UNIX® like. I only mentioned three differences between them (from an assembly language programmer’s perspective): The calling convention, the function numbers, and the way of returning values.</p></div><div class=sect3><h4 id=x86-deal-with-function-numbers>11.5.1. Dealing with Function Numbers<a class=anchor href=#x86-deal-with-function-numbers></a></h4><div class=paragraph><p>In many cases the function numbers are the same. However, even when they are not, the problem is easy to deal with: Instead of using numbers in your code, use constants which you have declared differently depending on the target architecture:</p></div><div class="literalblock programlisting"><div class=content><pre>%ifdef	LINUX
%define	SYS_execve	11
%else
%define	SYS_execve	59
%endif</pre></div></div></div><div class=sect3><h4 id=x86-deal-with-geneva>11.5.2. Dealing with Conventions<a class=anchor href=#x86-deal-with-geneva></a></h4><div class=paragraph><p>Both, the calling convention, and the return value (the <code>errno</code> problem) can be resolved with macros:</p></div><div class="literalblock programlisting"><div class=content><pre>%ifdef	LINUX

%macro	system	0
	call	kernel
%endmacro

align 4
kernel:
	push	ebx
	push	ecx
	push	edx
	push	esi
	push	edi
	push	ebp

	mov	ebx, [esp+32]
	mov	ecx, [esp+36]
	mov	edx, [esp+40]
	mov	esi, [esp+44]
	mov	ebp, [esp+48]
	int	80h

	pop	ebp
	pop	edi
	pop	esi
	pop	edx
	pop	ecx
	pop	ebx

	or	eax, eax
	js	.errno
	clc
	ret

.errno:
	neg	eax
	stc
	ret

%else

%macro	system	0
	int	80h
%endmacro

%endif</pre></div></div></div><div class=sect3><h4 id=x86-deal-with-other-portability>11.5.3. Dealing with Other Portability Issues<a class=anchor href=#x86-deal-with-other-portability></a></h4><div class=paragraph><p>The above solutions can handle most cases of writing code portable between FreeBSD and Linux. Nevertheless, with some kernel services the differences are deeper.</p></div><div class=paragraph><p>In that case, you need to write two different handlers for those particular system calls, and use conditional assembly. Luckily, most of your code does something other than calling the kernel, so usually you will only need a few such conditional sections in your code.</p></div></div><div class=sect3><h4 id=x86-portable-library>11.5.4. Using a Library<a class=anchor href=#x86-portable-library></a></h4><div class=paragraph><p>You can avoid portability issues in your main code altogether by writing a library of system calls. Create a separate library for FreeBSD, a different one for Linux, and yet other libraries for more operating systems.</p></div><div class=paragraph><p>In your library, write a separate function (or procedure, if you prefer the traditional assembly language terminology) for each system call. Use the C calling convention of passing parameters. But still use <code>EAX</code> to pass the call number in. In that case, your FreeBSD library can be very simple, as many seemingly different functions can be just labels to the same code:</p></div><div class="literalblock programlisting"><div class=content><pre>sys.open:
sys.close:
[etc...]
	int	80h
	ret</pre></div></div><div class=paragraph><p>Your Linux library will require more different functions. But even here you can group system calls using the same number of parameters:</p></div><div class="literalblock programlisting"><div class=content><pre>sys.exit:
sys.close:
[etc... one-parameter functions]
	push	ebx
	mov	ebx, [esp+12]
	int	80h
	pop	ebx
	jmp	sys.return

...

sys.return:
	or	eax, eax
	js	sys.err
	clc
	ret

sys.err:
	neg	eax
	stc
	ret</pre></div></div><div class=paragraph><p>The library approach may seem inconvenient at first because it requires you to produce a separate file your code depends on. But it has many advantages: For one, you only need to write it once and can use it for all your programs. You can even let other assembly language programmers use it, or perhaps use one written by someone else. But perhaps the greatest advantage of the library is that your code can be ported to other systems, even by other programmers, by simply writing a new library without any changes to your code.</p></div><div class=paragraph><p>If you do not like the idea of having a library, you can at least place all your system calls in a separate assembly language file and link it with your main program. Here, again, all porters have to do is create a new object file to link with your main program.</p></div></div><div class=sect3><h4 id=x86-portable-include>11.5.5. Using an Include File<a class=anchor href=#x86-portable-include></a></h4><div class=paragraph><p>If you are releasing your software as (or with) source code, you can use macros and place them in a separate file, which you include in your code.</p></div><div class=paragraph><p>Porters of your software will simply write a new include file. No library or external object file is necessary, yet your code is portable without any need to edit the code.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>This is the approach we will use throughout this chapter. We will name our include file <span class=filename>system.inc</span>, and add to it whenever we deal with a new system call.</p></div></td></tr></tbody></table></div><div class=paragraph><p>We can start our <span class=filename>system.inc</span> by declaring the standard file descriptors:</p></div><div class="literalblock programlisting"><div class=content><pre>%define	stdin	0
%define	stdout	1
%define	stderr	2</pre></div></div><div class=paragraph><p>Next, we create a symbolic name for each system call:</p></div><div class="literalblock programlisting"><div class=content><pre>%define	SYS_nosys	0
%define	SYS_exit	1
%define	SYS_fork	2
%define	SYS_read	3
%define	SYS_write	4
; [etc...]</pre></div></div><div class=paragraph><p>We add a short, non-global procedure with a long name, so we do not accidentally reuse the name in our code:</p></div><div class="literalblock programlisting"><div class=content><pre>section	.text
align 4
access.the.bsd.kernel:
	int	80h
	ret</pre></div></div><div class=paragraph><p>We create a macro which takes one argument, the syscall number:</p></div><div class="literalblock programlisting"><div class=content><pre>%macro	system	1
	mov	eax, %1
	call	access.the.bsd.kernel
%endmacro</pre></div></div><div class=paragraph><p>Finally, we create macros for each syscall. These macros take no arguments.</p></div><div class="literalblock programlisting"><div class=content><pre>%macro	sys.exit	0
	system	SYS_exit
%endmacro

%macro	sys.fork	0
	system	SYS_fork
%endmacro

%macro	sys.read	0
	system	SYS_read
%endmacro

%macro	sys.write	0
	system	SYS_write
%endmacro

; [etc...]</pre></div></div><div class=paragraph><p>Go ahead, enter it into your editor and save it as <span class=filename>system.inc</span>. We will add more to it as we discuss more syscalls.</p></div></div></div><div class=sect2><h3 id=x86-first-program>11.6. Our First Program<a class=anchor href=#x86-first-program></a></h3><div class=paragraph><p>We are now ready for our first program, the mandatory Hello, World!</p></div><div class="literalblock programlisting"><div class=content><pre>1:	%include	&#39;system.inc&#39;
 2:
 3:	section	.data
 4:	hello	db	&#39;Hello, World!&#39;, 0Ah
 5:	hbytes	equ	$-hello
 6:
 7:	section	.text
 8:	global	_start
 9:	_start:
10:	push	dword hbytes
11:	push	dword hello
12:	push	dword stdout
13:	sys.write
14:
15:	push	dword 0
16:	sys.exit</pre></div></div><div class=paragraph><p>Here is what it does: Line 1 includes the defines, the macros, and the code from <span class=filename>system.inc</span>.</p></div><div class=paragraph><p>Lines 3-5 are the data: Line 3 starts the data section/segment. Line 4 contains the string "Hello, World!" followed by a new line (<code>0Ah</code>). Line 5 creates a constant that contains the length of the string from line 4 in bytes.</p></div><div class=paragraph><p>Lines 7-16 contain the code. Note that FreeBSD uses the <em>elf</em> file format for its executables, which requires every program to start at the point labeled <code>_start</code> (or, more precisely, the linker expects that). This label has to be global.</p></div><div class=paragraph><p>Lines 10-13 ask the system to write <code>hbytes</code> bytes of the <code>hello</code> string to <code>stdout</code>.</p></div><div class=paragraph><p>Lines 15-16 ask the system to end the program with the return value of <code>0</code>. The <code>SYS_exit</code> syscall never returns, so the code ends there.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>If you have come to UNIX® from MS-DOS® assembly language background, you may be used to writing directly to the video hardware. You will never have to worry about this in FreeBSD, or any other flavor of UNIX®. As far as you are concerned, you are writing to a file known as <span class=filename>stdout</span>. This can be the video screen, or a telnet terminal, or an actual file, or even the input of another program. Which one it is, is for the system to figure out.</p></div></td></tr></tbody></table></div><div class=sect3><h4 id=x86-assemble-1>11.6.1. Assembling the Code<a class=anchor href=#x86-assemble-1></a></h4><div class=paragraph><p>Type the code (except the line numbers) in an editor, and save it in a file named <span class=filename>hello.asm</span>. You need nasm to assemble it.</p></div><div class=sect4><h5 id=x86-get-nasm>11.6.1.1. Installing nasm<a class=anchor href=#x86-get-nasm></a></h5><div class=paragraph><p>If you do not have nasm, type:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% su
Password:your root password
<span class=c># cd /usr/ports/devel/nasm</span>
<span class=c># make install</span>
<span class=c># exit</span>
%</code></pre></div></div><div class=paragraph><p>You may type <code>make install clean</code> instead of just <code>make install</code> if you do not want to keep nasm source code.</p></div><div class=paragraph><p>Either way, FreeBSD will automatically download nasm from the Internet, compile it, and install it on your system.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>If your system is not FreeBSD, you need to get nasm from its <a href=https://sourceforge.net/projects/nasm>home page</a>. You can still use it to assemble FreeBSD code.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Now you can assemble, link, and run the code:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% nasm <span class=nt>-f</span> elf hello.asm
% ld <span class=nt>-s</span> <span class=nt>-o</span> hello hello.o
% ./hello
Hello, World!
%</code></pre></div></div></div></div></div><div class=sect2><h3 id=x86-unix-filters>11.7. Writing UNIX® Filters<a class=anchor href=#x86-unix-filters></a></h3><div class=paragraph><p>A common type of UNIX® application is a filter-a program that reads data from the <span class=filename>stdin</span>, processes it somehow, then writes the result to <span class=filename>stdout</span>.</p></div><div class=paragraph><p>In this chapter, we shall develop a simple filter, and learn how to read from <span class=filename>stdin</span> and write to <span class=filename>stdout</span>. This filter will convert each byte of its input into a hexadecimal number followed by a blank space.</p></div><div class="literalblock programlisting"><div class=content><pre>%include	&#39;system.inc&#39;

section	.data
hex	db	&#39;0123456789ABCDEF&#39;
buffer	db	0, 0, &#39; &#39;

section	.text
global	_start
_start:
	; read a byte from stdin
	push	dword 1
	push	dword buffer
	push	dword stdin
	sys.read
	add	esp, byte 12
	or	eax, eax
	je	.done

	; convert it to hex
	movzx	eax, byte [buffer]
	mov	edx, eax
	shr	dl, 4
	mov	dl, [hex+edx]
	mov	[buffer], dl
	and	al, 0Fh
	mov	al, [hex+eax]
	mov	[buffer+1], al

	; print it
	push	dword 3
	push	dword buffer
	push	dword stdout
	sys.write
	add	esp, byte 12
	jmp	short _start

.done:
	push	dword 0
	sys.exit</pre></div></div><div class=paragraph><p>In the data section we create an array called <code>hex</code>. It contains the 16 hexadecimal digits in ascending order. The array is followed by a buffer which we will use for both input and output. The first two bytes of the buffer are initially set to <code>0</code>. This is where we will write the two hexadecimal digits (the first byte also is where we will read the input). The third byte is a space.</p></div><div class=paragraph><p>The code section consists of four parts: Reading the byte, converting it to a hexadecimal number, writing the result, and eventually exiting the program.</p></div><div class=paragraph><p>To read the byte, we ask the system to read one byte from <span class=filename>stdin</span>, and store it in the first byte of the <code>buffer</code>. The system returns the number of bytes read in <code>EAX</code>. This will be <code>1</code> while data is coming, or <code>0</code>, when no more input data is available. Therefore, we check the value of <code>EAX</code>. If it is <code>0</code>, we jump to <code>.done</code>, otherwise we continue.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>For simplicity sake, we are ignoring the possibility of an error condition at this time.</p></div></td></tr></tbody></table></div><div class=paragraph><p>The hexadecimal conversion reads the byte from the <code>buffer</code> into <code>EAX</code>, or actually just <code>AL</code>, while clearing the remaining bits of <code>EAX</code> to zeros. We also copy the byte to <code>EDX</code> because we need to convert the upper four bits (nibble) separately from the lower four bits. We store the result in the first two bytes of the buffer.</p></div><div class=paragraph><p>Next, we ask the system to write the three bytes of the buffer, i.e., the two hexadecimal digits and the blank space, to <span class=filename>stdout</span>. We then jump back to the beginning of the program and process the next byte.</p></div><div class=paragraph><p>Once there is no more input left, we ask the system to exit our program, returning a zero, which is the traditional value meaning the program was successful.</p></div><div class=paragraph><p>Go ahead, and save the code in a file named <span class=filename>hex.asm</span>, then type the following (the <code>^D</code> means press the control key and type <code>D</code> while holding the control key down):</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% nasm <span class=nt>-f</span> elf hex.asm
% ld <span class=nt>-s</span> <span class=nt>-o</span> hex hex.o
% ./hex
Hello, World!
48 65 6C 6C 6F 2C 20 57 6F 72 6C 64 21 0A Here I come!
48 65 72 65 20 49 20 63 6F 6D 65 21 0A ^D %</code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>If you are migrating to UNIX® from MS-DOS®, you may be wondering why each line ends with <code>0A</code> instead of <code>0D 0A</code>. This is because UNIX® does not use the cr/lf convention, but a "new line" convention, which is <code>0A</code> in hexadecimal.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Can we improve this? Well, for one, it is a bit confusing because once we have converted a line of text, our input no longer starts at the beginning of the line. We can modify it to print a new line instead of a space after each <code>0A</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>%include	&#39;system.inc&#39;

section	.data
hex	db	&#39;0123456789ABCDEF&#39;
buffer	db	0, 0, &#39; &#39;

section	.text
global	_start
_start:
	mov	cl, &#39; &#39;

.loop:
	; read a byte from stdin
	push	dword 1
	push	dword buffer
	push	dword stdin
	sys.read
	add	esp, byte 12
	or	eax, eax
	je	.done

	; convert it to hex
	movzx	eax, byte [buffer]
	mov	[buffer+2], cl
	cmp	al, 0Ah
	jne	.hex
	mov	[buffer+2], al

.hex:
	mov	edx, eax
	shr	dl, 4
	mov	dl, [hex+edx]
	mov	[buffer], dl
	and	al, 0Fh
	mov	al, [hex+eax]
	mov	[buffer+1], al

	; print it
	push	dword 3
	push	dword buffer
	push	dword stdout
	sys.write
	add	esp, byte 12
	jmp	short .loop

.done:
	push	dword 0
	sys.exit</pre></div></div><div class=paragraph><p>We have stored the space in the <code>CL</code> register. We can do this safely because, unlike Microsoft® Windows®, UNIX® system calls do not modify the value of any register they do not use to return a value in.</p></div><div class=paragraph><p>That means we only need to set <code>CL</code> once. We have, therefore, added a new label <code>.loop</code> and jump to it for the next byte instead of jumping at <code>_start</code>. We have also added the <code>.hex</code> label so we can either have a blank space or a new line as the third byte of the <code>buffer</code>.</p></div><div class=paragraph><p>Once you have changed <span class=filename>hex.asm</span> to reflect these changes, type:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% nasm <span class=nt>-f</span> elf hex.asm
% ld <span class=nt>-s</span> <span class=nt>-o</span> hex hex.o
% ./hex
Hello, World!
48 65 6C 6C 6F 2C 20 57 6F 72 6C 64 21 0A
Here I come!
48 65 72 65 20 49 20 63 6F 6D 65 21 0A
^D %</code></pre></div></div><div class=paragraph><p>That looks better. But this code is quite inefficient! We are making a system call for every single byte twice (once to read it, another time to write the output).</p></div></div><div class=sect2><h3 id=x86-buffered-io>11.8. Buffered Input and Output<a class=anchor href=#x86-buffered-io></a></h3><div class=paragraph><p>We can improve the efficiency of our code by buffering our input and output. We create an input buffer and read a whole sequence of bytes at one time. Then we fetch them one by one from the buffer.</p></div><div class=paragraph><p>We also create an output buffer. We store our output in it until it is full. At that time we ask the kernel to write the contents of the buffer to <span class=filename>stdout</span>.</p></div><div class=paragraph><p>The program ends when there is no more input. But we still need to ask the kernel to write the contents of our output buffer to <span class=filename>stdout</span> one last time, otherwise some of our output would make it to the output buffer, but never be sent out. Do not forget that, or you will be wondering why some of your output is missing.</p></div><div class="literalblock programlisting"><div class=content><pre>%include	&#39;system.inc&#39;

%define	BUFSIZE	2048

section	.data
hex	db	&#39;0123456789ABCDEF&#39;

section .bss
ibuffer	resb	BUFSIZE
obuffer	resb	BUFSIZE

section	.text
global	_start
_start:
	sub	eax, eax
	sub	ebx, ebx
	sub	ecx, ecx
	mov	edi, obuffer

.loop:
	; read a byte from stdin
	call	getchar

	; convert it to hex
	mov	dl, al
	shr	al, 4
	mov	al, [hex+eax]
	call	putchar

	mov	al, dl
	and	al, 0Fh
	mov	al, [hex+eax]
	call	putchar

	mov	al, &#39; &#39;
	cmp	dl, 0Ah
	jne	.put
	mov	al, dl

.put:
	call	putchar
	jmp	short .loop

align 4
getchar:
	or	ebx, ebx
	jne	.fetch

	call	read

.fetch:
	lodsb
	dec	ebx
	ret

read:
	push	dword BUFSIZE
	mov	esi, ibuffer
	push	esi
	push	dword stdin
	sys.read
	add	esp, byte 12
	mov	ebx, eax
	or	eax, eax
	je	.done
	sub	eax, eax
	ret

align 4
.done:
	call	write		; flush output buffer
	push	dword 0
	sys.exit

align 4
putchar:
	stosb
	inc	ecx
	cmp	ecx, BUFSIZE
	je	write
	ret

align 4
write:
	sub	edi, ecx	; start of buffer
	push	ecx
	push	edi
	push	dword stdout
	sys.write
	add	esp, byte 12
	sub	eax, eax
	sub	ecx, ecx	; buffer is empty now
	ret</pre></div></div><div class=paragraph><p>We now have a third section in the source code, named <code>.bss</code>. This section is not included in our executable file, and, therefore, cannot be initialized. We use <code>resb</code> instead of <code>db</code>. It simply reserves the requested size of uninitialized memory for our use.</p></div><div class=paragraph><p>We take advantage of the fact that the system does not modify the registers: We use registers for what, otherwise, would have to be global variables stored in the <code>.data</code> section. This is also why the UNIX® convention of passing parameters to system calls on the stack is superior to the Microsoft convention of passing them in the registers: We can keep the registers for our own use.</p></div><div class=paragraph><p>We use <code>EDI</code> and <code>ESI</code> as pointers to the next byte to be read from or written to. We use <code>EBX</code> and <code>ECX</code> to keep count of the number of bytes in the two buffers, so we know when to dump the output to, or read more input from, the system.</p></div><div class=paragraph><p>Let us see how it works now:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% nasm <span class=nt>-f</span> elf hex.asm
% ld <span class=nt>-s</span> <span class=nt>-o</span> hex hex.o
% ./hex
Hello, World!
Here I come!
48 65 6C 6C 6F 2C 20 57 6F 72 6C 64 21 0A
48 65 72 65 20 49 20 63 6F 6D 65 21 0A
^D %</code></pre></div></div><div class=paragraph><p>Not what you expected? The program did not print the output until we pressed <code>^D</code>. That is easy to fix by inserting three lines of code to write the output every time we have converted a new line to <code>0A</code>. I have marked the three lines with > (do not copy the > in your <span class=filename>hex.asm</span>).</p></div><div class="literalblock programlisting"><div class=content><pre>%include	&#39;system.inc&#39;

%define	BUFSIZE	2048

section	.data
hex	db	&#39;0123456789ABCDEF&#39;

section .bss
ibuffer	resb	BUFSIZE
obuffer	resb	BUFSIZE

section	.text
global	_start
_start:
	sub	eax, eax
	sub	ebx, ebx
	sub	ecx, ecx
	mov	edi, obuffer

.loop:
	; read a byte from stdin
	call	getchar

	; convert it to hex
	mov	dl, al
	shr	al, 4
	mov	al, [hex+eax]
	call	putchar

	mov	al, dl
	and	al, 0Fh
	mov	al, [hex+eax]
	call	putchar

	mov	al, &#39; &#39;
	cmp	dl, 0Ah
	jne	.put
	mov	al, dl

.put:
	call	putchar
&gt;	cmp	al, 0Ah
&gt;	jne	.loop
&gt;	call	write
	jmp	short .loop

align 4
getchar:
	or	ebx, ebx
	jne	.fetch

	call	read

.fetch:
	lodsb
	dec	ebx
	ret

read:
	push	dword BUFSIZE
	mov	esi, ibuffer
	push	esi
	push	dword stdin
	sys.read
	add	esp, byte 12
	mov	ebx, eax
	or	eax, eax
	je	.done
	sub	eax, eax
	ret

align 4
.done:
	call	write		; flush output buffer
	push	dword 0
	sys.exit

align 4
putchar:
	stosb
	inc	ecx
	cmp	ecx, BUFSIZE
	je	write
	ret

align 4
write:
	sub	edi, ecx	; start of buffer
	push	ecx
	push	edi
	push	dword stdout
	sys.write
	add	esp, byte 12
	sub	eax, eax
	sub	ecx, ecx	; buffer is empty now
	ret</pre></div></div><div class=paragraph><p>Now, let us see how it works:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% nasm <span class=nt>-f</span> elf hex.asm
% ld <span class=nt>-s</span> <span class=nt>-o</span> hex hex.o
% ./hex
Hello, World!
48 65 6C 6C 6F 2C 20 57 6F 72 6C 64 21 0A
Here I come!
48 65 72 65 20 49 20 63 6F 6D 65 21 0A
^D %</code></pre></div></div><div class=paragraph><p>Not bad for a 644-byte executable, is it!</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>This approach to buffered input/output still contains a hidden danger. I will discuss-and fix-it later, when I talk about the <a href=#x86-buffered-dark-side>dark side of buffering</a>.</p></div></td></tr></tbody></table></div><div class=sect3><h4 id=x86-ungetc>11.8.1. How to Unread a Character<a class=anchor href=#x86-ungetc></a></h4><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>This may be a somewhat advanced topic, mostly of interest to programmers familiar with the theory of compilers. If you wish, you may <a href=#x86-command-line>skip to the next section</a>, and perhaps read this later.</p></div></td></tr></tbody></table></div><div class=paragraph><p>While our sample program does not require it, more sophisticated filters often need to look ahead. In other words, they may need to see what the next character is (or even several characters). If the next character is of a certain value, it is part of the token currently being processed. Otherwise, it is not.</p></div><div class=paragraph><p>For example, you may be parsing the input stream for a textual string (e.g., when implementing a language compiler): If a character is followed by another character, or perhaps a digit, it is part of the token you are processing. If it is followed by white space, or some other value, then it is not part of the current token.</p></div><div class=paragraph><p>This presents an interesting problem: How to return the next character back to the input stream, so it can be read again later?</p></div><div class=paragraph><p>One possible solution is to store it in a character variable, then set a flag. We can modify <code>getchar</code> to check the flag, and if it is set, fetch the byte from that variable instead of the input buffer, and reset the flag. But, of course, that slows us down.</p></div><div class=paragraph><p>The C language has an <code>ungetc()</code> function, just for that purpose. Is there a quick way to implement it in our code? I would like you to scroll back up and take a look at the <code>getchar</code> procedure and see if you can find a nice and fast solution before reading the next paragraph. Then come back here and see my own solution.</p></div><div class=paragraph><p>The key to returning a character back to the stream is in how we are getting the characters to start with:</p></div><div class=paragraph><p>First we check if the buffer is empty by testing the value of <code>EBX</code>. If it is zero, we call the <code>read</code> procedure.</p></div><div class=paragraph><p>If we do have a character available, we use <code>lodsb</code>, then decrease the value of <code>EBX</code>. The <code>lodsb</code> instruction is effectively identical to:</p></div><div class="literalblock programlisting"><div class=content><pre>mov	al, [esi]
	inc	esi</pre></div></div><div class=paragraph><p>The byte we have fetched remains in the buffer until the next time <code>read</code> is called. We do not know when that happens, but we do know it will not happen until the next call to <code>getchar</code>. Hence, to "return" the last-read byte back to the stream, all we have to do is decrease the value of <code>ESI</code> and increase the value of <code>EBX</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>ungetc:
	dec	esi
	inc	ebx
	ret</pre></div></div><div class=paragraph><p>But, be careful! We are perfectly safe doing this if our look-ahead is at most one character at a time. If we are examining more than one upcoming character and call <code>ungetc</code> several times in a row, it will work most of the time, but not all the time (and will be tough to debug). Why?</p></div><div class=paragraph><p>Because as long as <code>getchar</code> does not have to call <code>read</code>, all of the pre-read bytes are still in the buffer, and our <code>ungetc</code> works without a glitch. But the moment <code>getchar</code> calls <code>read</code>, the contents of the buffer change.</p></div><div class=paragraph><p>We can always rely on <code>ungetc</code> working properly on the last character we have read with <code>getchar</code>, but not on anything we have read before that.</p></div><div class=paragraph><p>If your program reads more than one byte ahead, you have at least two choices:</p></div><div class=paragraph><p>If possible, modify the program so it only reads one byte ahead. This is the simplest solution.</p></div><div class=paragraph><p>If that option is not available, first of all determine the maximum number of characters your program needs to return to the input stream at one time. Increase that number slightly, just to be sure, preferably to a multiple of 16-so it aligns nicely. Then modify the <code>.bss</code> section of your code, and create a small "spare" buffer right before your input buffer, something like this:</p></div><div class="literalblock programlisting"><div class=content><pre>section	.bss
	resb	16	; or whatever the value you came up with
ibuffer	resb	BUFSIZE
obuffer	resb	BUFSIZE</pre></div></div><div class=paragraph><p>You also need to modify your <code>ungetc</code> to pass the value of the byte to unget in <code>AL</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>ungetc:
	dec	esi
	inc	ebx
	mov	[esi], al
	ret</pre></div></div><div class=paragraph><p>With this modification, you can call <code>ungetc</code> up to 17 times in a row safely (the first call will still be within the buffer, the remaining 16 may be either within the buffer or within the "spare").</p></div></div></div><div class=sect2><h3 id=x86-command-line>11.9. Command Line Arguments<a class=anchor href=#x86-command-line></a></h3><div class=paragraph><p>Our hex program will be more useful if it can read the names of an input and output file from its command line, i.e., if it can process the command line arguments. But…​ Where are they?</p></div><div class=paragraph><p>Before a UNIX® system starts a program, it <code>push</code>es some data on the stack, then jumps at the <code>_start</code> label of the program. Yes, I said jumps, not calls. That means the data can be accessed by reading <code>[esp+offset]</code>, or by simply <code>pop</code>ping it.</p></div><div class=paragraph><p>The value at the top of the stack contains the number of command line arguments. It is traditionally called <code>argc</code>, for "argument count."</p></div><div class=paragraph><p>Command line arguments follow next, all <code>argc</code> of them. These are typically referred to as <code>argv</code>, for "argument value(s)." That is, we get <code>argv[0]</code>, <code>argv[1]</code>, <code>…​</code>, <code>argv[argc-1]</code>. These are not the actual arguments, but pointers to arguments, i.e., memory addresses of the actual arguments. The arguments themselves are NUL-terminated character strings.</p></div><div class=paragraph><p>The <code>argv</code> list is followed by a NULL pointer, which is simply a <code>0</code>. There is more, but this is enough for our purposes right now.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>If you have come from the MS-DOS® programming environment, the main difference is that each argument is in a separate string. The second difference is that there is no practical limit on how many arguments there can be.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Armed with this knowledge, we are almost ready for the next version of <span class=filename>hex.asm</span>. First, however, we need to add a few lines to <span class=filename>system.inc</span>:</p></div><div class=paragraph><p>First, we need to add two new entries to our list of system call numbers:</p></div><div class="literalblock programlisting"><div class=content><pre>%define	SYS_open	5
%define	SYS_close	6</pre></div></div><div class=paragraph><p>Then we add two new macros at the end of the file:</p></div><div class="literalblock programlisting"><div class=content><pre>%macro	sys.open	0
	system	SYS_open
%endmacro

%macro	sys.close	0
	system	SYS_close
%endmacro</pre></div></div><div class=paragraph><p>Here, then, is our modified source code:</p></div><div class="literalblock programlisting"><div class=content><pre>%include	&#39;system.inc&#39;

%define	BUFSIZE	2048

section	.data
fd.in	dd	stdin
fd.out	dd	stdout
hex	db	&#39;0123456789ABCDEF&#39;

section .bss
ibuffer	resb	BUFSIZE
obuffer	resb	BUFSIZE

section	.text
align 4
err:
	push	dword 1		; return failure
	sys.exit

align 4
global	_start
_start:
	add	esp, byte 8	; discard argc and argv[0]

	pop	ecx
	jecxz	.init		; no more arguments

	; ECX contains the path to input file
	push	dword 0		; O_RDONLY
	push	ecx
	sys.open
	jc	err		; open failed

	add	esp, byte 8
	mov	[fd.in], eax

	pop	ecx
	jecxz	.init		; no more arguments

	; ECX contains the path to output file
	push	dword 420	; file mode (644 octal)
	push	dword 0200h | 0400h | 01h
	; O_CREAT | O_TRUNC | O_WRONLY
	push	ecx
	sys.open
	jc	err

	add	esp, byte 12
	mov	[fd.out], eax

.init:
	sub	eax, eax
	sub	ebx, ebx
	sub	ecx, ecx
	mov	edi, obuffer

.loop:
	; read a byte from input file or stdin
	call	getchar

	; convert it to hex
	mov	dl, al
	shr	al, 4
	mov	al, [hex+eax]
	call	putchar

	mov	al, dl
	and	al, 0Fh
	mov	al, [hex+eax]
	call	putchar

	mov	al, &#39; &#39;
	cmp	dl, 0Ah
	jne	.put
	mov	al, dl

.put:
	call	putchar
	cmp	al, dl
	jne	.loop
	call	write
	jmp	short .loop

align 4
getchar:
	or	ebx, ebx
	jne	.fetch

	call	read

.fetch:
	lodsb
	dec	ebx
	ret

read:
	push	dword BUFSIZE
	mov	esi, ibuffer
	push	esi
	push	dword [fd.in]
	sys.read
	add	esp, byte 12
	mov	ebx, eax
	or	eax, eax
	je	.done
	sub	eax, eax
	ret

align 4
.done:
	call	write		; flush output buffer

	; close files
	push	dword [fd.in]
	sys.close

	push	dword [fd.out]
	sys.close

	; return success
	push	dword 0
	sys.exit

align 4
putchar:
	stosb
	inc	ecx
	cmp	ecx, BUFSIZE
	je	write
	ret

align 4
write:
	sub	edi, ecx	; start of buffer
	push	ecx
	push	edi
	push	dword [fd.out]
	sys.write
	add	esp, byte 12
	sub	eax, eax
	sub	ecx, ecx	; buffer is empty now
	ret</pre></div></div><div class=paragraph><p>In our <code>.data</code> section we now have two new variables, <code>fd.in</code> and <code>fd.out</code>. We store the input and output file descriptors here.</p></div><div class=paragraph><p>In the <code>.text</code> section we have replaced the references to <code>stdin</code> and <code>stdout</code> with <code>[fd.in]</code> and <code>[fd.out]</code>.</p></div><div class=paragraph><p>The <code>.text</code> section now starts with a simple error handler, which does nothing but exit the program with a return value of <code>1</code>. The error handler is before <code>_start</code> so we are within a short distance from where the errors occur.</p></div><div class=paragraph><p>Naturally, the program execution still begins at <code>_start</code>. First, we remove <code>argc</code> and <code>argv[0]</code> from the stack: They are of no interest to us (in this program, that is).</p></div><div class=paragraph><p>We pop <code>argv[1]</code> to <code>ECX</code>. This register is particularly suited for pointers, as we can handle NULL pointers with <code>jecxz</code>. If <code>argv[1]</code> is not NULL, we try to open the file named in the first argument. Otherwise, we continue the program as before: Reading from <code>stdin</code>, writing to <code>stdout</code>. If we fail to open the input file (e.g., it does not exist), we jump to the error handler and quit.</p></div><div class=paragraph><p>If all went well, we now check for the second argument. If it is there, we open the output file. Otherwise, we send the output to <code>stdout</code>. If we fail to open the output file (e.g., it exists and we do not have the write permission), we, again, jump to the error handler.</p></div><div class=paragraph><p>The rest of the code is the same as before, except we close the input and output files before exiting, and, as mentioned, we use <code>[fd.in]</code> and <code>[fd.out]</code>.</p></div><div class=paragraph><p>Our executable is now a whopping 768 bytes long.</p></div><div class=paragraph><p>Can we still improve it? Of course! Every program can be improved. Here are a few ideas of what we could do:</p></div><div class=ulist><ul><li><p>Have our error handler print a message to <code>stderr</code>.</p></li><li><p>Add error handlers to the <code>read</code> and <code>write</code> functions.</p></li><li><p>Close <code>stdin</code> when we open an input file, <code>stdout</code> when we open an output file.</p></li><li><p>Add command line switches, such as <code>-i</code> and <code>-o</code>, so we can list the input and output files in any order, or perhaps read from <code>stdin</code> and write to a file.</p></li><li><p>Print a usage message if command line arguments are incorrect.</p></li></ul></div><div class=paragraph><p>I shall leave these enhancements as an exercise to the reader: You already know everything you need to know to implement them.</p></div></div><div class=sect2><h3 id=x86-environment>11.10. UNIX® Environment<a class=anchor href=#x86-environment></a></h3><div class=paragraph><p>An important UNIX® concept is the environment, which is defined by <em>environment variables</em>. Some are set by the system, others by you, yet others by the shell, or any program that loads another program.</p></div><div class=sect3><h4 id=x86-find-environment>11.10.1. How to Find Environment Variables<a class=anchor href=#x86-find-environment></a></h4><div class=paragraph><p>I said earlier that when a program starts executing, the stack contains <code>argc</code> followed by the NULL-terminated <code>argv</code> array, followed by something else. The "something else" is the <em>environment</em>, or, to be more precise, a NULL-terminated array of pointers to <em>environment variables</em>. This is often referred to as <code>env</code>.</p></div><div class=paragraph><p>The structure of <code>env</code> is the same as that of <code>argv</code>, a list of memory addresses followed by a NULL (<code>0</code>). In this case, there is no <code>"envc"</code>-we figure out where the array ends by searching for the final NULL.</p></div><div class=paragraph><p>The variables usually come in the <code>name=value</code> format, but sometimes the <code>=value</code> part may be missing. We need to account for that possibility.</p></div></div><div class=sect3><h4 id=x86-webvar>11.10.2. webvars<a class=anchor href=#x86-webvar></a></h4><div class=paragraph><p>I could just show you some code that prints the environment the same way the UNIX® env command does. But I thought it would be more interesting to write a simple assembly language CGI utility.</p></div><div class=sect4><h5 id=x86-cgi>11.10.2.1. CGI: a Quick Overview<a class=anchor href=#x86-cgi></a></h5><div class=paragraph><p>I have a <a href=http://www.whizkidtech.redprince.net/cgi-bin/tutorial>detailed CGI tutorial</a> on my web site, but here is a very quick overview of CGI:</p></div><div class=ulist><ul><li><p>The web server communicates with the CGI program by setting <em>environment variables</em>.</p></li><li><p>The CGI program sends its output to <span class=filename>stdout</span>. The web server reads it from there.</p></li><li><p>It must start with an HTTP header followed by two blank lines.</p></li><li><p>It then prints the HTML code, or whatever other type of data it is producing.</p></li></ul></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>While certain <em>environment variables</em> use standard names, others vary, depending on the web server. That makes webvars quite a useful diagnostic tool.</p></div></td></tr></tbody></table></div></div><div class=sect4><h5 id=x86-webvars-the-code>11.10.2.2. The Code<a class=anchor href=#x86-webvars-the-code></a></h5><div class=paragraph><p>Our webvars program, then, must send out the HTTP header followed by some HTML mark-up. It then must read the <em>environment variables</em> one by one and send them out as part of the HTML page.</p></div><div class=paragraph><p>The code follows. I placed comments and explanations right inside the code:</p></div><div class="literalblock programlisting"><div class=content><pre>;;;;;;; webvars.asm ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Copyright (c) 2000 G. Adam Stanislav
; All rights reserved.
;
; Redistribution and use in source and binary forms, with or without
; modification, are permitted provided that the following conditions
; are met:
; 1. Redistributions of source code must retain the above copyright
;    notice, this list of conditions and the following disclaimer.
; 2. Redistributions in binary form must reproduce the above copyright
;    notice, this list of conditions and the following disclaimer in the
;    documentation and/or other materials provided with the distribution.
;
; THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS&#39;&#39; AND
; ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
; ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
; FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
; DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
; OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
; HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
; LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
; OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
; SUCH DAMAGE.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Version 1.0
;
; Started:	 8-Dec-2000
; Updated:	 8-Dec-2000
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%include	&#39;system.inc&#39;

section	.data
http	db	&#39;Content-type: text/html&#39;, 0Ah, 0Ah
	db	&#39;&lt;?xml version=&#34;1.0&#34; encoding=&#34;utf-8&#34;?&gt;&#39;, 0Ah
	db	&#39;&lt;!DOCTYPE html PUBLIC &#34;-//W3C/DTD XHTML Strict//EN&#34; &#39;
	db	&#39;&#34;DTD/xhtml1-strict.dtd&#34;&gt;&#39;, 0Ah
	db	&#39;&lt;html xmlns=&#34;http://www.w3.org/1999/xhtml&#34; &#39;
	db	&#39;xml.lang=&#34;en&#34; lang=&#34;en&#34;&gt;&#39;, 0Ah
	db	&#39;&lt;head&gt;&#39;, 0Ah
	db	&#39;&lt;title&gt;Web Environment&lt;/title&gt;&#39;, 0Ah
	db	&#39;&lt;meta name=&#34;author&#34; content=&#34;G. Adam Stanislav&#34; /&gt;&#39;, 0Ah
	db	&#39;&lt;/head&gt;&#39;, 0Ah, 0Ah
	db	&#39;&lt;body bgcolor=&#34;#ffffff&#34; text=&#34;#000000&#34; link=&#34;#0000ff&#34; &#39;
	db	&#39;vlink=&#34;#840084&#34; alink=&#34;#0000ff&#34;&gt;&#39;, 0Ah
	db	&#39;&lt;div class=&#34;webvars&#34;&gt;&#39;, 0Ah
	db	&#39;&lt;h1&gt;Web Environment&lt;/h1&gt;&#39;, 0Ah
	db	&#39;&lt;p&gt;The following &lt;b&gt;environment variables&lt;/b&gt; are defined &#39;
	db	&#39;on this web server:&lt;/p&gt;&#39;, 0Ah, 0Ah
	db	&#39;&lt;table align=&#34;center&#34; width=&#34;80&#34; border=&#34;0&#34; cellpadding=&#34;10&#34; &#39;
	db	&#39;cellspacing=&#34;0&#34; class=&#34;webvars&#34;&gt;&#39;, 0Ah
httplen	equ	$-http
left	db	&#39;&lt;tr&gt;&#39;, 0Ah
	db	&#39;&lt;td class=&#34;name&#34;&gt;&lt;tt&gt;&#39;
leftlen	equ	$-left
middle	db	&#39;&lt;/tt&gt;&lt;/td&gt;&#39;, 0Ah
	db	&#39;&lt;td class=&#34;value&#34;&gt;&lt;tt&gt;&lt;b&gt;&#39;
midlen	equ	$-middle
undef	db	&#39;&lt;i&gt;(undefined)&lt;/i&gt;&#39;
undeflen	equ	$-undef
right	db	&#39;&lt;/b&gt;&lt;/tt&gt;&lt;/td&gt;&#39;, 0Ah
	db	&#39;&lt;/tr&gt;&#39;, 0Ah
rightlen	equ	$-right
wrap	db	&#39;&lt;/table&gt;&#39;, 0Ah
	db	&#39;&lt;/div&gt;&#39;, 0Ah
	db	&#39;&lt;/body&gt;&#39;, 0Ah
	db	&#39;&lt;/html&gt;&#39;, 0Ah, 0Ah
wraplen	equ	$-wrap

section	.text
global	_start
_start:
	; First, send out all the http and xhtml stuff that is
	; needed before we start showing the environment
	push	dword httplen
	push	dword http
	push	dword stdout
	sys.write

	; Now find how far on the stack the environment pointers
	; are. We have 12 bytes we have pushed before &#34;argc&#34;
	mov	eax, [esp+12]

	; We need to remove the following from the stack:
	;
	;	The 12 bytes we pushed for sys.write
	;	The  4 bytes of argc
	;	The EAX*4 bytes of argv
	;	The  4 bytes of the NULL after argv
	;
	; Total:
	;	20 + eax * 4
	;
	; Because stack grows down, we need to ADD that many bytes
	; to ESP.
	lea	esp, [esp+20+eax*4]
	cld		; This should already be the case, but let&#39;s be sure.

	; Loop through the environment, printing it out
.loop:
	pop	edi
	or	edi, edi	; Done yet?
	je	near .wrap

	; Print the left part of HTML
	push	dword leftlen
	push	dword left
	push	dword stdout
	sys.write

	; It may be tempting to search for the &#39;=&#39; in the env string next.
	; But it is possible there is no &#39;=&#39;, so we search for the
	; terminating NUL first.
	mov	esi, edi	; Save start of string
	sub	ecx, ecx
	not	ecx		; ECX = FFFFFFFF
	sub	eax, eax
repne	scasb
	not	ecx		; ECX = string length + 1
	mov	ebx, ecx	; Save it in EBX

	; Now is the time to find &#39;=&#39;
	mov	edi, esi	; Start of string
	mov	al, &#39;=&#39;
repne	scasb
	not	ecx
	add	ecx, ebx	; Length of name

	push	ecx
	push	esi
	push	dword stdout
	sys.write

	; Print the middle part of HTML table code
	push	dword midlen
	push	dword middle
	push	dword stdout
	sys.write

	; Find the length of the value
	not	ecx
	lea	ebx, [ebx+ecx-1]

	; Print &#34;undefined&#34; if 0
	or	ebx, ebx
	jne	.value

	mov	ebx, undeflen
	mov	edi, undef

.value:
	push	ebx
	push	edi
	push	dword stdout
	sys.write

	; Print the right part of the table row
	push	dword rightlen
	push	dword right
	push	dword stdout
	sys.write

	; Get rid of the 60 bytes we have pushed
	add	esp, byte 60

	; Get the next variable
	jmp	.loop

.wrap:
	; Print the rest of HTML
	push	dword wraplen
	push	dword wrap
	push	dword stdout
	sys.write

	; Return success
	push	dword 0
	sys.exit</pre></div></div><div class=paragraph><p>This code produces a 1,396-byte executable. Most of it is data, i.e., the HTML mark-up we need to send out.</p></div><div class=paragraph><p>Assemble and link it as usual:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% nasm <span class=nt>-f</span> elf webvars.asm
% ld <span class=nt>-s</span> <span class=nt>-o</span> webvars webvars.o</code></pre></div></div><div class=paragraph><p>To use it, you need to upload <span class=filename>webvars</span> to your web server. Depending on how your web server is set up, you may have to store it in a special <span class=filename>cgi-bin</span> directory, or perhaps rename it with a <span class=filename>.cgi</span> extension.</p></div><div class=paragraph><p>Then you need to use your browser to view its output. To see its output on my web server, please go to <a href=http://www.int80h.org/webvars/>http://www.int80h.org/webvars/</a>. If curious about the additional environment variables present in a password protected web directory, go to <a href=http://www.int80h.org/private/>http://www.int80h.org/private/</a>, using the name <code>asm</code> and password <code>programmer</code>.</p></div></div></div></div><div class=sect2><h3 id=x86-files>11.11. Working with Files<a class=anchor href=#x86-files></a></h3><div class=paragraph><p>We have already done some basic file work: We know how to open and close them, how to read and write them using buffers. But UNIX® offers much more functionality when it comes to files. We will examine some of it in this section, and end up with a nice file conversion utility.</p></div><div class=paragraph><p>Indeed, let us start at the end, that is, with the file conversion utility. It always makes programming easier when we know from the start what the end product is supposed to do.</p></div><div class=paragraph><p>One of the first programs I wrote for UNIX® was <a href=ftp://ftp.int80h.org/unix/tuc/>tuc</a>, a text-to-UNIX® file converter. It converts a text file from other operating systems to a UNIX® text file. In other words, it changes from different kind of line endings to the newline convention of UNIX®. It saves the output in a different file. Optionally, it converts a UNIX® text file to a DOS text file.</p></div><div class=paragraph><p>I have used tuc extensively, but always only to convert from some other OS to UNIX®, never the other way. I have always wished it would just overwrite the file instead of me having to send the output to a different file. Most of the time, I end up using it like this:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% tuc myfile tempfile
% <span class=nb>mv </span>tempfile myfile</code></pre></div></div><div class=paragraph><p>It would be nice to have a ftuc, i.e., <em>fast tuc</em>, and use it like this:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ftuc myfile</code></pre></div></div><div class=paragraph><p>In this chapter, then, we will write ftuc in assembly language (the original tuc is in C), and study various file-oriented kernel services in the process.</p></div><div class=paragraph><p>At first sight, such a file conversion is very simple: All you have to do is strip the carriage returns, right?</p></div><div class=paragraph><p>If you answered yes, think again: That approach will work most of the time (at least with MS DOS text files), but will fail occasionally.</p></div><div class=paragraph><p>The problem is that not all non UNIX® text files end their line with the carriage return / line feed sequence. Some use carriage returns without line feeds. Others combine several blank lines into a single carriage return followed by several line feeds. And so on.</p></div><div class=paragraph><p>A text file converter, then, must be able to handle any possible line endings:</p></div><div class=ulist><ul><li><p>carriage return / line feed</p></li><li><p>carriage return</p></li><li><p>line feed / carriage return</p></li><li><p>line feed</p></li></ul></div><div class=paragraph><p>It should also handle files that use some kind of a combination of the above (e.g., carriage return followed by several line feeds).</p></div><div class=sect3><h4 id=x86-finite-state-machine>11.11.1. Finite State Machine<a class=anchor href=#x86-finite-state-machine></a></h4><div class=paragraph><p>The problem is easily solved by the use of a technique called <em>finite state machine</em>, originally developed by the designers of digital electronic circuits. A <em>finite state machine</em> is a digital circuit whose output is dependent not only on its input but on its previous input, i.e., on its state. The microprocessor is an example of a <em>finite state machine</em>: Our assembly language code is assembled to machine language in which some assembly language code produces a single byte of machine language, while others produce several bytes. As the microprocessor fetches the bytes from the memory one by one, some of them simply change its state rather than produce some output. When all the bytes of the op code are fetched, the microprocessor produces some output, or changes the value of a register, etc.</p></div><div class=paragraph><p>Because of that, all software is essentially a sequence of state instructions for the microprocessor. Nevertheless, the concept of <em>finite state machine</em> is useful in software design as well.</p></div><div class=paragraph><p>Our text file converter can be designer as a <em>finite state machine</em> with three possible states. We could call them states 0-2, but it will make our life easier if we give them symbolic names:</p></div><div class=ulist><ul><li><p>ordinary</p></li><li><p>cr</p></li><li><p>lf</p></li></ul></div><div class=paragraph><p>Our program will start in the ordinary state. During this state, the program action depends on its input as follows:</p></div><div class=ulist><ul><li><p>If the input is anything other than a carriage return or line feed, the input is simply passed on to the output. The state remains unchanged.</p></li><li><p>If the input is a carriage return, the state is changed to cr. The input is then discarded, i.e., no output is made.</p></li><li><p>If the input is a line feed, the state is changed to lf. The input is then discarded.</p></li></ul></div><div class=paragraph><p>Whenever we are in the cr state, it is because the last input was a carriage return, which was unprocessed. What our software does in this state again depends on the current input:</p></div><div class=ulist><ul><li><p>If the input is anything other than a carriage return or line feed, output a line feed, then output the input, then change the state to ordinary.</p></li><li><p>If the input is a carriage return, we have received two (or more) carriage returns in a row. We discard the input, we output a line feed, and leave the state unchanged.</p></li><li><p>If the input is a line feed, we output the line feed and change the state to ordinary. Note that this is not the same as the first case above - if we tried to combine them, we would be outputting two line feeds instead of one.</p></li></ul></div><div class=paragraph><p>Finally, we are in the lf state after we have received a line feed that was not preceded by a carriage return. This will happen when our file already is in UNIX® format, or whenever several lines in a row are expressed by a single carriage return followed by several line feeds, or when line ends with a line feed / carriage return sequence. Here is how we need to handle our input in this state:</p></div><div class=ulist><ul><li><p>If the input is anything other than a carriage return or line feed, we output a line feed, then output the input, then change the state to ordinary. This is exactly the same action as in the cr state upon receiving the same kind of input.</p></li><li><p>If the input is a carriage return, we discard the input, we output a line feed, then change the state to ordinary.</p></li><li><p>If the input is a line feed, we output the line feed, and leave the state unchanged.</p></li></ul></div><div class=sect4><h5 id=x86-final-state>11.11.1.1. The Final State<a class=anchor href=#x86-final-state></a></h5><div class=paragraph><p>The above <em>finite state machine</em> works for the entire file, but leaves the possibility that the final line end will be ignored. That will happen whenever the file ends with a single carriage return or a single line feed. I did not think of it when I wrote tuc, just to discover that occasionally it strips the last line ending.</p></div><div class=paragraph><p>This problem is easily fixed by checking the state after the entire file was processed. If the state is not ordinary, we simply need to output one last line feed.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Now that we have expressed our algorithm as a <em>finite state machine</em>, we could easily design a dedicated digital electronic circuit (a "chip") to do the conversion for us. Of course, doing so would be considerably more expensive than writing an assembly language program.</p></div></td></tr></tbody></table></div></div><div class=sect4><h5 id=x86-tuc-counter>11.11.1.2. The Output Counter<a class=anchor href=#x86-tuc-counter></a></h5><div class=paragraph><p>Because our file conversion program may be combining two characters into one, we need to use an output counter. We initialize it to <code>0</code>, and increase it every time we send a character to the output. At the end of the program, the counter will tell us what size we need to set the file to.</p></div></div></div><div class=sect3><h4 id=x86-software-fsm>11.11.2. Implementing FSM in Software<a class=anchor href=#x86-software-fsm></a></h4><div class=paragraph><p>The hardest part of working with a <em>finite state machine</em> is analyzing the problem and expressing it as a <em>finite state machine</em>. That accomplished, the software almost writes itself.</p></div><div class=paragraph><p>In a high-level language, such as C, there are several main approaches. One is to use a <code>switch</code> statement which chooses what function should be run. For example,</p></div><div class="literalblock programlisting"><div class=content><pre>switch (state) {
	default:
	case REGULAR:
		regular(inputchar);
		break;
	case CR:
		cr(inputchar);
		break;
	case LF:
		lf(inputchar);
		break;
	}</pre></div></div><div class=paragraph><p>Another approach is by using an array of function pointers, something like this:</p></div><div class="literalblock programlisting"><div class=content><pre>(output[state])(inputchar);</pre></div></div><div class=paragraph><p>Yet another is to have <code>state</code> be a function pointer, set to point at the appropriate function:</p></div><div class="literalblock programlisting"><div class=content><pre>(*state)(inputchar);</pre></div></div><div class=paragraph><p>This is the approach we will use in our program because it is very easy to do in assembly language, and very fast, too. We will simply keep the address of the right procedure in <code>EBX</code>, and then just issue:</p></div><div class="literalblock programlisting"><div class=content><pre>call	ebx</pre></div></div><div class=paragraph><p>This is possibly faster than hardcoding the address in the code because the microprocessor does not have to fetch the address from the memory-it is already stored in one of its registers. I said <em>possibly</em> because with the caching modern microprocessors do, either way may be equally fast.</p></div></div><div class=sect3><h4 id=memory-mapped-files>11.11.3. Memory Mapped Files<a class=anchor href=#memory-mapped-files></a></h4><div class=paragraph><p>Because our program works on a single file, we cannot use the approach that worked for us before, i.e., to read from an input file and to write to an output file.</p></div><div class=paragraph><p>UNIX® allows us to map a file, or a section of a file, into memory. To do that, we first need to open the file with the appropriate read/write flags. Then we use the <code>mmap</code> system call to map it into the memory. One nice thing about <code>mmap</code> is that it automatically works with virtual memory: We can map more of the file into the memory than we have physical memory available, yet still access it through regular memory op codes, such as <code>mov</code>, <code>lods</code>, and <code>stos</code>. Whatever changes we make to the memory image of the file will be written to the file by the system. We do not even have to keep the file open: As long as it stays mapped, we can read from it and write to it.</p></div><div class=paragraph><p>The 32-bit Intel microprocessors can access up to four gigabytes of memory - physical or virtual. The FreeBSD system allows us to use up to a half of it for file mapping.</p></div><div class=paragraph><p>For simplicity sake, in this tutorial we will only convert files that can be mapped into the memory in their entirety. There are probably not too many text files that exceed two gigabytes in size. If our program encounters one, it will simply display a message suggesting we use the original tuc instead.</p></div><div class=paragraph><p>If you examine your copy of <span class=filename>syscalls.master</span>, you will find two separate syscalls named <code>mmap</code>. This is because of evolution of UNIX®: There was the traditional BSD <code>mmap</code>, syscall 71. That one was superseded by the POSIX® <code>mmap</code>, syscall 197. The FreeBSD system supports both because older programs were written by using the original BSD version. But new software uses the POSIX® version, which is what we will use.</p></div><div class=paragraph><p>The <span class=filename>syscalls.master</span> lists the POSIX® version like this:</p></div><div class="literalblock programlisting"><div class=content><pre>197	STD	BSD	{ caddr_t mmap(caddr_t addr, size_t len, int prot, \
			    int flags, int fd, long pad, off_t pos); }</pre></div></div><div class=paragraph><p>This differs slightly from what <a href="https://man.freebsd.org/cgi/man.cgi?query=mmap&amp;sektion=2&amp;format=html">mmap(2)</a> says. That is because <a href="https://man.freebsd.org/cgi/man.cgi?query=mmap&amp;sektion=2&amp;format=html">mmap(2)</a> describes the C version.</p></div><div class=paragraph><p>The difference is in the <code>long pad</code> argument, which is not present in the C version. However, the FreeBSD syscalls add a 32-bit pad after <code>push</code>ing a 64-bit argument. In this case, <code>off_t</code> is a 64-bit value.</p></div><div class=paragraph><p>When we are finished working with a memory-mapped file, we unmap it with the <code>munmap</code> syscall:</p></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>For an in-depth treatment of <code>mmap</code>, see W. Richard Stevens' <a href="http://www.int80h.org/cgi-bin/isbn?isbn=0130810819">Unix Network Programming, Volume 2, Chapter 12</a>.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=x86-file-size>11.11.4. Determining File Size<a class=anchor href=#x86-file-size></a></h4><div class=paragraph><p>Because we need to tell <code>mmap</code> how many bytes of the file to map into the memory, and because we want to map the entire file, we need to determine the size of the file.</p></div><div class=paragraph><p>We can use the <code>fstat</code> syscall to get all the information about an open file that the system can give us. That includes the file size.</p></div><div class=paragraph><p>Again, <span class=filename>syscalls.master</span> lists two versions of <code>fstat</code>, a traditional one (syscall 62), and a POSIX® one (syscall 189). Naturally, we will use the POSIX® version:</p></div><div class="literalblock programlisting"><div class=content><pre>189	STD	POSIX	{ int fstat(int fd, struct stat *sb); }</pre></div></div><div class=paragraph><p>This is a very straightforward call: We pass to it the address of a <code>stat</code> structure and the descriptor of an open file. It will fill out the contents of the <code>stat</code> structure.</p></div><div class=paragraph><p>I do, however, have to say that I tried to declare the <code>stat</code> structure in the <code>.bss</code> section, and <code>fstat</code> did not like it: It set the carry flag indicating an error. After I changed the code to allocate the structure on the stack, everything was working fine.</p></div></div><div class=sect3><h4 id=x86-ftruncate>11.11.5. Changing the File Size<a class=anchor href=#x86-ftruncate></a></h4><div class=paragraph><p>Because our program may combine carriage return / line feed sequences into straight line feeds, our output may be smaller than our input. However, since we are placing our output into the same file we read the input from, we may have to change the size of the file.</p></div><div class=paragraph><p>The <code>ftruncate</code> system call allows us to do just that. Despite its somewhat misleading name, the <code>ftruncate</code> system call can be used to both truncate the file (make it smaller) and to grow it.</p></div><div class=paragraph><p>And yes, we will find two versions of <code>ftruncate</code> in <span class=filename>syscalls.master</span>, an older one (130), and a newer one (201). We will use the newer one:</p></div><div class="literalblock programlisting"><div class=content><pre>201	STD	BSD	{ int ftruncate(int fd, int pad, off_t length); }</pre></div></div><div class=paragraph><p>Please note that this one contains a <code>int pad</code> again.</p></div></div><div class=sect3><h4 id=x86-ftuc>11.11.6. ftuc<a class=anchor href=#x86-ftuc></a></h4><div class=paragraph><p>We now know everything we need to write ftuc. We start by adding some new lines in <span class=filename>system.inc</span>. First, we define some constants and structures, somewhere at or near the beginning of the file:</p></div><div class="literalblock programlisting"><div class=content><pre>;;;;;;; open flags
%define	O_RDONLY	0
%define	O_WRONLY	1
%define	O_RDWR	2

;;;;;;; mmap flags
%define	PROT_NONE	0
%define	PROT_READ	1
%define	PROT_WRITE	2
%define	PROT_EXEC	4
;;
%define	MAP_SHARED	0001h
%define	MAP_PRIVATE	0002h

;;;;;;; stat structure
struc	stat
st_dev		resd	1	; = 0
st_ino		resd	1	; = 4
st_mode		resw	1	; = 8, size is 16 bits
st_nlink	resw	1	; = 10, ditto
st_uid		resd	1	; = 12
st_gid		resd	1	; = 16
st_rdev		resd	1	; = 20
st_atime	resd	1	; = 24
st_atimensec	resd	1	; = 28
st_mtime	resd	1	; = 32
st_mtimensec	resd	1	; = 36
st_ctime	resd	1	; = 40
st_ctimensec	resd	1	; = 44
st_size		resd	2	; = 48, size is 64 bits
st_blocks	resd	2	; = 56, ditto
st_blksize	resd	1	; = 64
st_flags	resd	1	; = 68
st_gen		resd	1	; = 72
st_lspare	resd	1	; = 76
st_qspare	resd	4	; = 80
endstruc</pre></div></div><div class=paragraph><p>We define the new syscalls:</p></div><div class="literalblock programlisting"><div class=content><pre>%define	SYS_mmap	197
%define	SYS_munmap	73
%define	SYS_fstat	189
%define	SYS_ftruncate	201</pre></div></div><div class=paragraph><p>We add the macros for their use:</p></div><div class="literalblock programlisting"><div class=content><pre>%macro	sys.mmap	0
	system	SYS_mmap
%endmacro

%macro	sys.munmap	0
	system	SYS_munmap
%endmacro

%macro	sys.ftruncate	0
	system	SYS_ftruncate
%endmacro

%macro	sys.fstat	0
	system	SYS_fstat
%endmacro</pre></div></div><div class=paragraph><p>And here is our code:</p></div><div class="literalblock programlisting"><div class=content><pre>;;;;;;; Fast Text-to-Unix Conversion (ftuc.asm) ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Started:	21-Dec-2000
;; Updated:	22-Dec-2000
;;
;; Copyright 2000 G. Adam Stanislav.
;; All rights reserved.
;;
;;;;;;; v.1 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%include	&#39;system.inc&#39;

section	.data
	db	&#39;Copyright 2000 G. Adam Stanislav.&#39;, 0Ah
	db	&#39;All rights reserved.&#39;, 0Ah
usg	db	&#39;Usage: ftuc filename&#39;, 0Ah
usglen	equ	$-usg
co	db	&#34;ftuc: Can&#39;t open file.&#34;, 0Ah
colen	equ	$-co
fae	db	&#39;ftuc: File access error.&#39;, 0Ah
faelen	equ	$-fae
ftl	db	&#39;ftuc: File too long, use regular tuc instead.&#39;, 0Ah
ftllen	equ	$-ftl
mae	db	&#39;ftuc: Memory allocation error.&#39;, 0Ah
maelen	equ	$-mae

section	.text

align 4
memerr:
	push	dword maelen
	push	dword mae
	jmp	short error

align 4
toolong:
	push	dword ftllen
	push	dword ftl
	jmp	short error

align 4
facerr:
	push	dword faelen
	push	dword fae
	jmp	short error

align 4
cantopen:
	push	dword colen
	push	dword co
	jmp	short error

align 4
usage:
	push	dword usglen
	push	dword usg

error:
	push	dword stderr
	sys.write

	push	dword 1
	sys.exit

align 4
global	_start
_start:
	pop	eax		; argc
	pop	eax		; program name
	pop	ecx		; file to convert
	jecxz	usage

	pop	eax
	or	eax, eax	; Too many arguments?
	jne	usage

	; Open the file
	push	dword O_RDWR
	push	ecx
	sys.open
	jc	cantopen

	mov	ebp, eax	; Save fd

	sub	esp, byte stat_size
	mov	ebx, esp

	; Find file size
	push	ebx
	push	ebp		; fd
	sys.fstat
	jc	facerr

	mov	edx, [ebx + st_size + 4]

	; File is too long if EDX != 0 ...
	or	edx, edx
	jne	near toolong
	mov	ecx, [ebx + st_size]
	; ... or if it is above 2 GB
	or	ecx, ecx
	js	near toolong

	; Do nothing if the file is 0 bytes in size
	jecxz	.quit

	; Map the entire file in memory
	push	edx
	push	edx		; starting at offset 0
	push	edx		; pad
	push	ebp		; fd
	push	dword MAP_SHARED
	push	dword PROT_READ | PROT_WRITE
	push	ecx		; entire file size
	push	edx		; let system decide on the address
	sys.mmap
	jc	near memerr

	mov	edi, eax
	mov	esi, eax
	push	ecx		; for SYS_munmap
	push	edi

	; Use EBX for state machine
	mov	ebx, ordinary
	mov	ah, 0Ah
	cld

.loop:
	lodsb
	call	ebx
	loop	.loop

	cmp	ebx, ordinary
	je	.filesize

	; Output final lf
	mov	al, ah
	stosb
	inc	edx

.filesize:
	; truncate file to new size
	push	dword 0		; high dword
	push	edx		; low dword
	push	eax		; pad
	push	ebp
	sys.ftruncate

	; close it (ebp still pushed)
	sys.close

	add	esp, byte 16
	sys.munmap

.quit:
	push	dword 0
	sys.exit

align 4
ordinary:
	cmp	al, 0Dh
	je	.cr

	cmp	al, ah
	je	.lf

	stosb
	inc	edx
	ret

align 4
.cr:
	mov	ebx, cr
	ret

align 4
.lf:
	mov	ebx, lf
	ret

align 4
cr:
	cmp	al, 0Dh
	je	.cr

	cmp	al, ah
	je	.lf

	xchg	al, ah
	stosb
	inc	edx

	xchg	al, ah
	; fall through

.lf:
	stosb
	inc	edx
	mov	ebx, ordinary
	ret

align 4
.cr:
	mov	al, ah
	stosb
	inc	edx
	ret

align 4
lf:
	cmp	al, ah
	je	.lf

	cmp	al, 0Dh
	je	.cr

	xchg	al, ah
	stosb
	inc	edx

	xchg	al, ah
	stosb
	inc	edx
	mov	ebx, ordinary
	ret

align 4
.cr:
	mov	ebx, ordinary
	mov	al, ah
	; fall through

.lf:
	stosb
	inc	edx
	ret</pre></div></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Do not use this program on files stored on a disk formatted by MS-DOS® or Windows®. There seems to be a subtle bug in the FreeBSD code when using <code>mmap</code> on these drives mounted under FreeBSD: If the file is over a certain size, <code>mmap</code> will just fill the memory with zeros, and then copy them to the file overwriting its contents.</p></div></td></tr></tbody></table></div></div></div><div class=sect2><h3 id=x86-one-pointed-mind>11.12. One-Pointed Mind<a class=anchor href=#x86-one-pointed-mind></a></h3><div class=paragraph><p>As a student of Zen, I like the idea of a one-pointed mind: Do one thing at a time, and do it well.</p></div><div class=paragraph><p>This, indeed, is very much how UNIX® works as well. While a typical Windows® application is attempting to do everything imaginable (and is, therefore, riddled with bugs), a typical UNIX® program does only one thing, and it does it well.</p></div><div class=paragraph><p>The typical UNIX® user then essentially assembles his own applications by writing a shell script which combines the various existing programs by piping the output of one program to the input of another.</p></div><div class=paragraph><p>When writing your own UNIX® software, it is generally a good idea to see what parts of the problem you need to solve can be handled by existing programs, and only write your own programs for that part of the problem that you do not have an existing solution for.</p></div><div class=sect3><h4 id=x86-csv>11.12.1. CSV<a class=anchor href=#x86-csv></a></h4><div class=paragraph><p>I will illustrate this principle with a specific real-life example I was faced with recently:</p></div><div class=paragraph><p>I needed to extract the 11th field of each record from a database I downloaded from a web site. The database was a CSV file, i.e., a list of <em>comma-separated values</em>. That is quite a standard format for sharing data among people who may be using different database software.</p></div><div class=paragraph><p>The first line of the file contains the list of various fields separated by commas. The rest of the file contains the data listed line by line, with values separated by commas.</p></div><div class=paragraph><p>I tried awk, using the comma as a separator. But because several lines contained a quoted comma, awk was extracting the wrong field from those lines.</p></div><div class=paragraph><p>Therefore, I needed to write my own software to extract the 11th field from the CSV file. However, going with the UNIX® spirit, I only needed to write a simple filter that would do the following:</p></div><div class=ulist><ul><li><p>Remove the first line from the file;</p></li><li><p>Change all unquoted commas to a different character;</p></li><li><p>Remove all quotation marks.</p></li></ul></div><div class=paragraph><p>Strictly speaking, I could use sed to remove the first line from the file, but doing so in my own program was very easy, so I decided to do it and reduce the size of the pipeline.</p></div><div class=paragraph><p>At any rate, writing a program like this took me about 20 minutes. Writing a program that extracts the 11th field from the CSV file would take a lot longer, and I could not reuse it to extract some other field from some other database.</p></div><div class=paragraph><p>This time I decided to let it do a little more work than a typical tutorial program would:</p></div><div class=ulist><ul><li><p>It parses its command line for options;</p></li><li><p>It displays proper usage if it finds wrong arguments;</p></li><li><p>It produces meaningful error messages.</p></li></ul></div><div class=paragraph><p>Here is its usage message:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Usage: csv <span class=o>[</span><span class=nt>-t</span>&lt;delim&gt;] <span class=o>[</span><span class=nt>-c</span>&lt;comma&gt;] <span class=o>[</span><span class=nt>-p</span><span class=o>]</span> <span class=o>[</span><span class=nt>-o</span> &lt;outfile&gt;] <span class=o>[</span><span class=nt>-i</span> &lt;infile&gt;]</code></pre></div></div><div class=paragraph><p>All parameters are optional, and can appear in any order.</p></div><div class=paragraph><p>The <code>-t</code> parameter declares what to replace the commas with. The <code>tab</code> is the default here. For example, <code>-t;</code> will replace all unquoted commas with semicolons.</p></div><div class=paragraph><p>I did not need the <code>-c</code> option, but it may come in handy in the future. It lets me declare that I want a character other than a comma replaced with something else. For example, <code>-c@</code> will replace all at signs (useful if you want to split a list of email addresses to their user names and domains).</p></div><div class=paragraph><p>The <code>-p</code> option preserves the first line, i.e., it does not delete it. By default, we delete the first line because in a CSV file it contains the field names rather than data.</p></div><div class=paragraph><p>The <code>-i</code> and <code>-o</code> options let me specify the input and the output files. Defaults are <span class=filename>stdin</span> and <span class=filename>stdout</span>, so this is a regular UNIX® filter.</p></div><div class=paragraph><p>I made sure that both <code>-i filename</code> and <code>-ifilename</code> are accepted. I also made sure that only one input and one output files may be specified.</p></div><div class=paragraph><p>To get the 11th field of each record, I can now do:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% csv <span class=s1>&#39;-t;&#39;</span> data.csv | <span class=nb>awk</span> <span class=s1>&#39;-F;&#39;</span> <span class=s1>&#39;{print $11}&#39;</span></code></pre></div></div><div class=paragraph><p>The code stores the options (except for the file descriptors) in <code>EDX</code>: The comma in <code>DH</code>, the new separator in <code>DL</code>, and the flag for the <code>-p</code> option in the highest bit of <code>EDX</code>, so a check for its sign will give us a quick decision what to do.</p></div><div class=paragraph><p>Here is the code:</p></div><div class="literalblock programlisting"><div class=content><pre>;;;;;;; csv.asm ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Convert a comma-separated file to a something-else separated file.
;
; Started:	31-May-2001
; Updated:	 1-Jun-2001
;
; Copyright (c) 2001 G. Adam Stanislav
; All rights reserved.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

%include	&#39;system.inc&#39;

%define	BUFSIZE	2048

section	.data
fd.in	dd	stdin
fd.out	dd	stdout
usg	db	&#39;Usage: csv [-t&lt;delim&gt;] [-c&lt;comma&gt;] [-p] [-o &lt;outfile&gt;] [-i &lt;infile&gt;]&#39;, 0Ah
usglen	equ	$-usg
iemsg	db	&#34;csv: Can&#39;t open input file&#34;, 0Ah
iemlen	equ	$-iemsg
oemsg	db	&#34;csv: Can&#39;t create output file&#34;, 0Ah
oemlen	equ	$-oemsg

section .bss
ibuffer	resb	BUFSIZE
obuffer	resb	BUFSIZE

section	.text
align 4
ierr:
	push	dword iemlen
	push	dword iemsg
	push	dword stderr
	sys.write
	push	dword 1		; return failure
	sys.exit

align 4
oerr:
	push	dword oemlen
	push	dword oemsg
	push	dword stderr
	sys.write
	push	dword 2
	sys.exit

align 4
usage:
	push	dword usglen
	push	dword usg
	push	dword stderr
	sys.write
	push	dword 3
	sys.exit

align 4
global	_start
_start:
	add	esp, byte 8	; discard argc and argv[0]
	mov	edx, (&#39;,&#39; &lt;&lt; 8) | 9

.arg:
	pop	ecx
	or	ecx, ecx
	je	near .init		; no more arguments

	; ECX contains the pointer to an argument
	cmp	byte [ecx], &#39;-&#39;
	jne	usage

	inc	ecx
	mov	ax, [ecx]

.o:
	cmp	al, &#39;o&#39;
	jne	.i

	; Make sure we are not asked for the output file twice
	cmp	dword [fd.out], stdout
	jne	usage

	; Find the path to output file - it is either at [ECX+1],
	; i.e., -ofile --
	; or in the next argument,
	; i.e., -o file

	inc	ecx
	or	ah, ah
	jne	.openoutput
	pop	ecx
	jecxz	usage

.openoutput:
	push	dword 420	; file mode (644 octal)
	push	dword 0200h | 0400h | 01h
	; O_CREAT | O_TRUNC | O_WRONLY
	push	ecx
	sys.open
	jc	near oerr

	add	esp, byte 12
	mov	[fd.out], eax
	jmp	short .arg

.i:
	cmp	al, &#39;i&#39;
	jne	.p

	; Make sure we are not asked twice
	cmp	dword [fd.in], stdin
	jne	near usage

	; Find the path to the input file
	inc	ecx
	or	ah, ah
	jne	.openinput
	pop	ecx
	or	ecx, ecx
	je near usage

.openinput:
	push	dword 0		; O_RDONLY
	push	ecx
	sys.open
	jc	near ierr		; open failed

	add	esp, byte 8
	mov	[fd.in], eax
	jmp	.arg

.p:
	cmp	al, &#39;p&#39;
	jne	.t
	or	ah, ah
	jne	near usage
	or	edx, 1 &lt;&lt; 31
	jmp	.arg

.t:
	cmp	al, &#39;t&#39;		; redefine output delimiter
	jne	.c
	or	ah, ah
	je	near usage
	mov	dl, ah
	jmp	.arg

.c:
	cmp	al, &#39;c&#39;
	jne	near usage
	or	ah, ah
	je	near usage
	mov	dh, ah
	jmp	.arg

align 4
.init:
	sub	eax, eax
	sub	ebx, ebx
	sub	ecx, ecx
	mov	edi, obuffer

	; See if we are to preserve the first line
	or	edx, edx
	js	.loop

.firstline:
	; get rid of the first line
	call	getchar
	cmp	al, 0Ah
	jne	.firstline

.loop:
	; read a byte from stdin
	call	getchar

	; is it a comma (or whatever the user asked for)?
	cmp	al, dh
	jne	.quote

	; Replace the comma with a tab (or whatever the user wants)
	mov	al, dl

.put:
	call	putchar
	jmp	short .loop

.quote:
	cmp	al, &#39;&#34;&#39;
	jne	.put

	; Print everything until you get another quote or EOL. If it
	; is a quote, skip it. If it is EOL, print it.
.qloop:
	call	getchar
	cmp	al, &#39;&#34;&#39;
	je	.loop

	cmp	al, 0Ah
	je	.put

	call	putchar
	jmp	short .qloop

align 4
getchar:
	or	ebx, ebx
	jne	.fetch

	call	read

.fetch:
	lodsb
	dec	ebx
	ret

read:
	jecxz	.read
	call	write

.read:
	push	dword BUFSIZE
	mov	esi, ibuffer
	push	esi
	push	dword [fd.in]
	sys.read
	add	esp, byte 12
	mov	ebx, eax
	or	eax, eax
	je	.done
	sub	eax, eax
	ret

align 4
.done:
	call	write		; flush output buffer

	; close files
	push	dword [fd.in]
	sys.close

	push	dword [fd.out]
	sys.close

	; return success
	push	dword 0
	sys.exit

align 4
putchar:
	stosb
	inc	ecx
	cmp	ecx, BUFSIZE
	je	write
	ret

align 4
write:
	jecxz	.ret	; nothing to write
	sub	edi, ecx	; start of buffer
	push	ecx
	push	edi
	push	dword [fd.out]
	sys.write
	add	esp, byte 12
	sub	eax, eax
	sub	ecx, ecx	; buffer is empty now
.ret:
	ret</pre></div></div><div class=paragraph><p>Much of it is taken from <span class=filename>hex.asm</span> above. But there is one important difference: I no longer call <code>write</code> whenever I am outputting a line feed. Yet, the code can be used interactively.</p></div><div class=paragraph><p>I have found a better solution for the interactive problem since I first started writing this chapter. I wanted to make sure each line is printed out separately only when needed. After all, there is no need to flush out every line when used non-interactively.</p></div><div class=paragraph><p>The new solution I use now is to call <code>write</code> every time I find the input buffer empty. That way, when running in the interactive mode, the program reads one line from the user’s keyboard, processes it, and sees its input buffer is empty. It flushes its output and reads the next line.</p></div><div class=sect4><h5 id=x86-buffered-dark-side>11.12.1.1. The Dark Side of Buffering<a class=anchor href=#x86-buffered-dark-side></a></h5><div class=paragraph><p>This change prevents a mysterious lockup in a very specific case. I refer to it as the <em>dark side of buffering</em>, mostly because it presents a danger that is not quite obvious.</p></div><div class=paragraph><p>It is unlikely to happen with a program like the csv above, so let us consider yet another filter: In this case we expect our input to be raw data representing color values, such as the <em>red</em>, <em>green</em>, and <em>blue</em> intensities of a pixel. Our output will be the negative of our input.</p></div><div class=paragraph><p>Such a filter would be very simple to write. Most of it would look just like all the other filters we have written so far, so I am only going to show you its inner loop:</p></div><div class="literalblock programlisting"><div class=content><pre>.loop:
	call	getchar
	not	al		; Create a negative
	call	putchar
	jmp	short .loop</pre></div></div><div class=paragraph><p>Because this filter works with raw data, it is unlikely to be used interactively.</p></div><div class=paragraph><p>But it could be called by image manipulation software. And, unless it calls <code>write</code> before each call to <code>read</code>, chances are it will lock up.</p></div><div class=paragraph><p>Here is what might happen:</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>The image editor will load our filter using the C function <code>popen()</code>.</p></li><li><p>It will read the first row of pixels from a bitmap or pixmap.</p></li><li><p>It will write the first row of pixels to the <em>pipe</em> leading to the <code>fd.in</code> of our filter.</p></li><li><p>Our filter will read each pixel from its input, turn it to a negative, and write it to its output buffer.</p></li><li><p>Our filter will call <code>getchar</code> to fetch the next pixel.</p></li><li><p><code>getchar</code> will find an empty input buffer, so it will call <code>read</code>.</p></li><li><p><code>read</code> will call the <code>SYS_read</code> system call.</p></li><li><p>The <em>kernel</em> will suspend our filter until the image editor sends more data to the pipe.</p></li><li><p>The image editor will read from the other pipe, connected to the <code>fd.out</code> of our filter so it can set the first row of the output image <em>before</em> it sends us the second row of the input.</p></li><li><p>The <em>kernel</em> suspends the image editor until it receives some output from our filter, so it can pass it on to the image editor.</p></li></ol></div></div></div><div class=paragraph><p>At this point our filter waits for the image editor to send it more data to process, while the image editor is waiting for our filter to send it the result of the processing of the first row. But the result sits in our output buffer.</p></div><div class=paragraph><p>The filter and the image editor will continue waiting for each other forever (or, at least, until they are killed). Our software has just entered a <a href=#secure-race-conditions>race condition</a>.</p></div><div class=paragraph><p>This problem does not exist if our filter flushes its output buffer <em>before</em> asking the <em>kernel</em> for more input data.</p></div></div></div></div><div class=sect2><h3 id=x86-fpu>11.13. Using the FPU<a class=anchor href=#x86-fpu></a></h3><div class=paragraph><p>Strangely enough, most of assembly language literature does not even mention the existence of the FPU, or <em>floating point unit</em>, let alone discuss programming it.</p></div><div class=paragraph><p>Yet, never does assembly language shine more than when we create highly optimized FPU code by doing things that can be done <em>only</em> in assembly language.</p></div><div class=sect3><h4 id=x86-fpu-organization>11.13.1. Organization of the FPU<a class=anchor href=#x86-fpu-organization></a></h4><div class=paragraph><p>The FPU consists of 8 80-bit floating-point registers. These are organized in a stack fashion-you can <code>push</code> a value on TOS (<em>top of stack</em>) and you can <code>pop</code> it.</p></div><div class=paragraph><p>That said, the assembly language op codes are not <code>push</code> and <code>pop</code> because those are already taken.</p></div><div class=paragraph><p>You can <code>push</code> a value on TOS by using <code>fld</code>, <code>fild</code>, and <code>fbld</code>. Several other op codes let you <code>push</code> many common <em>constants</em>-such as <em>pi</em>-on the TOS.</p></div><div class=paragraph><p>Similarly, you can <code>pop</code> a value by using <code>fst</code>, <code>fstp</code>, <code>fist</code>, <code>fistp</code>, and <code>fbstp</code>. Actually, only the op codes that end with a <em>p</em> will literally <code>pop</code> the value, the rest will <code>store</code> it somewhere else without removing it from the TOS.</p></div><div class=paragraph><p>We can transfer the data between the TOS and the computer memory either as a 32-bit, 64-bit, or 80-bit <em>real</em>, a 16-bit, 32-bit, or 64-bit <em>integer</em>, or an 80-bit <em>packed decimal</em>.</p></div><div class=paragraph><p>The 80-bit <em>packed decimal</em> is a special case of <em>binary coded decimal</em> which is very convenient when converting between the ASCII representation of data and the internal data of the FPU. It allows us to use 18 significant digits.</p></div><div class=paragraph><p>No matter how we represent data in the memory, the FPU always stores it in the 80-bit <em>real</em> format in its registers.</p></div><div class=paragraph><p>Its internal precision is at least 19 decimal digits, so even if we choose to display results as ASCII in the full 18-digit precision, we are still showing correct results.</p></div><div class=paragraph><p>We can perform mathematical operations on the TOS: We can calculate its <em>sine</em>, we can <em>scale</em> it (i.e., we can multiply or divide it by a power of 2), we can calculate its base-2 <em>logarithm</em>, and many other things.</p></div><div class=paragraph><p>We can also <em>multiply</em> or <em>divide</em> it by, <em>add</em> it to, or <em>subtract</em> it from, any of the FPU registers (including itself).</p></div><div class=paragraph><p>The official Intel op code for the TOS is <code>st</code>, and for the <em>registers</em> <code>st(0)</code>-<code>st(7)</code>. <code>st</code> and <code>st(0)</code>, then, refer to the same register.</p></div><div class=paragraph><p>For whatever reasons, the original author of nasm has decided to use different op codes, namely <code>st0</code>-<code>st7</code>. In other words, there are no parentheses, and the TOS is always <code>st0</code>, never just <code>st</code>.</p></div><div class=sect4><h5 id=x86-fpu-packed-decimal>11.13.1.1. The Packed Decimal Format<a class=anchor href=#x86-fpu-packed-decimal></a></h5><div class=paragraph><p>The <em>packed decimal</em> format uses 10 bytes (80 bits) of memory to represent 18 digits. The number represented there is always an <em>integer</em>.</p></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>You can use it to get decimal places by multiplying the TOS by a power of 10 first.</p></div></td></tr></tbody></table></div><div class=paragraph><p>The highest bit of the highest byte (byte 9) is the <em>sign bit</em>: If it is set, the number is <em>negative</em>, otherwise, it is <em>positive</em>. The rest of the bits of this byte are unused/ignored.</p></div><div class=paragraph><p>The remaining 9 bytes store the 18 digits of the number: 2 digits per byte.</p></div><div class=paragraph><p>The <em>more significant digit</em> is stored in the high <em>nibble</em> (4 bits), the <em>less significant digit</em> in the low <em>nibble</em>.</p></div><div class=paragraph><p>That said, you might think that <code>-1234567</code> would be stored in the memory like this (using hexadecimal notation):</p></div><div class="literalblock programlisting"><div class=content><pre>80 00 00 00 00 00 01 23 45 67</pre></div></div><div class=paragraph><p>Alas it is not! As with everything else of Intel make, even the <em>packed decimal</em> is <em>little-endian</em>.</p></div><div class=paragraph><p>That means our <code>-1234567</code> is stored like this:</p></div><div class="literalblock programlisting"><div class=content><pre>67 45 23 01 00 00 00 00 00 80</pre></div></div><div class=paragraph><p>Remember that, or you will be pulling your hair out in desperation!</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>The book to read-if you can find it-is Richard Startz' <a href=http://www.amazon.com/exec/obidos/ASIN/013246604X/whizkidtechnomag>8087/80287/80387 for the IBM PC & Compatibles</a>. Though it does seem to take the fact about the little-endian storage of the <em>packed decimal</em> for granted. I kid you not about the desperation of trying to figure out what was wrong with the filter I show below <em>before</em> it occurred to me I should try the little-endian order even for this type of data.</p></div></td></tr></tbody></table></div></div></div><div class=sect3><h4 id=x86-pinhole-photography>11.13.2. Excursion to Pinhole Photography<a class=anchor href=#x86-pinhole-photography></a></h4><div class=paragraph><p>To write meaningful software, we must not only understand our programming tools, but also the field we are creating software for.</p></div><div class=paragraph><p>Our next filter will help us whenever we want to build a <em>pinhole camera</em>, so, we need some background in <em>pinhole photography</em> before we can continue.</p></div><div class=sect4><h5 id=x86-camera>11.13.2.1. The Camera<a class=anchor href=#x86-camera></a></h5><div class=paragraph><p>The easiest way to describe any camera ever built is as some empty space enclosed in some lightproof material, with a small hole in the enclosure.</p></div><div class=paragraph><p>The enclosure is usually sturdy (e.g., a box), though sometimes it is flexible (the bellows). It is quite dark inside the camera. However, the hole lets light rays in through a single point (though in some cases there may be several). These light rays form an image, a representation of whatever is outside the camera, in front of the hole.</p></div><div class=paragraph><p>If some light sensitive material (such as film) is placed inside the camera, it can capture the image.</p></div><div class=paragraph><p>The hole often contains a <em>lens</em>, or a lens assembly, often called the <em>objective</em>.</p></div></div><div class=sect4><h5 id=x86-the-pinhole>11.13.2.2. The Pinhole<a class=anchor href=#x86-the-pinhole></a></h5><div class=paragraph><p>But, strictly speaking, the lens is not necessary: The original cameras did not use a lens but a <em>pinhole</em>. Even today, <em>pinholes</em> are used, both as a tool to study how cameras work, and to achieve a special kind of image.</p></div><div class=paragraph><p>The image produced by the <em>pinhole</em> is all equally sharp. Or <em>blurred</em>. There is an ideal size for a pinhole: If it is either larger or smaller, the image loses its sharpness.</p></div></div><div class=sect4><h5 id=x86-focal-length>11.13.2.3. Focal Length<a class=anchor href=#x86-focal-length></a></h5><div class=paragraph><p>This ideal pinhole diameter is a function of the square root of <em>focal length</em>, which is the distance of the pinhole from the film.</p></div><div class="literalblock programlisting"><div class=content><pre>D = PC * sqrt(FL)</pre></div></div><div class=paragraph><p>In here, <code>D</code> is the ideal diameter of the pinhole, <code>FL</code> is the focal length, and <code>PC</code> is a pinhole constant. According to Jay Bender, its value is <code>0.04</code>, while Kenneth Connors has determined it to be <code>0.037</code>. Others have proposed other values. Plus, this value is for the daylight only: Other types of light will require a different constant, whose value can only be determined by experimentation.</p></div></div><div class=sect4><h5 id=x86-f-number>11.13.2.4. The F-Number<a class=anchor href=#x86-f-number></a></h5><div class=paragraph><p>The f-number is a very useful measure of how much light reaches the film. A light meter can determine that, for example, to expose a film of specific sensitivity with f5.6 mkay require the exposure to last 1/1000 sec.</p></div><div class=paragraph><p>It does not matter whether it is a 35-mm camera, or a 6x9cm camera, etc. As long as we know the f-number, we can determine the proper exposure.</p></div><div class=paragraph><p>The f-number is easy to calculate:</p></div><div class="literalblock programlisting"><div class=content><pre>F = FL / D</pre></div></div><div class=paragraph><p>In other words, the f-number equals the focal length divided by the diameter of the pinhole. It also means a higher f-number either implies a smaller pinhole or a larger focal distance, or both. That, in turn, implies, the higher the f-number, the longer the exposure has to be.</p></div><div class=paragraph><p>Furthermore, while pinhole diameter and focal distance are one-dimensional measurements, both, the film and the pinhole, are two-dimensional. That means that if you have measured the exposure at f-number <code>A</code> as <code>t</code>, then the exposure at f-number <code>B</code> is:</p></div><div class="literalblock programlisting"><div class=content><pre>t * (B / A)²</pre></div></div></div><div class=sect4><h5 id=x86-normalized-f-number>11.13.2.5. Normalized F-Number<a class=anchor href=#x86-normalized-f-number></a></h5><div class=paragraph><p>While many modern cameras can change the diameter of their pinhole, and thus their f-number, quite smoothly and gradually, such was not always the case.</p></div><div class=paragraph><p>To allow for different f-numbers, cameras typically contained a metal plate with several holes of different sizes drilled to them.</p></div><div class=paragraph><p>Their sizes were chosen according to the above formula in such a way that the resultant f-number was one of standard f-numbers used on all cameras everywhere. For example, a very old Kodak Duaflex IV camera in my possession has three such holes for f-numbers 8, 11, and 16.</p></div><div class=paragraph><p>A more recently made camera may offer f-numbers of 2.8, 4, 5.6, 8, 11, 16, 22, and 32 (as well as others). These numbers were not chosen arbitrarily: They all are powers of the square root of 2, though they may be rounded somewha.</p></div></div><div class=sect4><h5 id=x86-f-stop>11.13.2.6. The F-Stop<a class=anchor href=#x86-f-stop></a></h5><div class=paragraph><p>A typical camera is designed in such a way that setting any of the normalized f-numbers changes the feel of the dial. It will naturally <em>stop</em> in that position. Because of that, these positions of the dial are called f-stops.</p></div><div class=paragraph><p>Since the f-numbers at each stop are powers of the square root of 2, moving the dial by 1 stop will double the amount of light required for proper exposure. Moving it by 2 stops will quadruple the required exposure. Moving the dial by 3 stops will require the increase in exposure 8 times, etc.</p></div></div></div><div class=sect3><h4 id=x86-pinhole-software>11.13.3. Designing the Pinhole Software<a class=anchor href=#x86-pinhole-software></a></h4><div class=paragraph><p>We are now ready to decide what exactly we want our pinhole software to do.</p></div><div class=sect4><h5 id=xpinhole-processing-input>11.13.3.1. Processing Program Input<a class=anchor href=#xpinhole-processing-input></a></h5><div class=paragraph><p>Since its main purpose is to help us design a working pinhole camera, we will use the <em>focal length</em> as the input to the program. This is something we can determine without software: Proper focal length is determined by the size of the film and by the need to shoot "regular" pictures, wide angle pictures, or telephoto pictures.</p></div><div class=paragraph><p>Most of the programs we have written so far worked with individual characters, or bytes, as their input: The hex program converted individual bytes into a hexadecimal number, the csv program either let a character through, or deleted it, or changed it to a different character, etc.</p></div><div class=paragraph><p>One program, ftuc used the state machine to consider at most two input bytes at a time.</p></div><div class=paragraph><p>But our pinhole program cannot just work with individual characters, it has to deal with larger syntactic units.</p></div><div class=paragraph><p>For example, if we want the program to calculate the pinhole diameter (and other values we will discuss later) at the focal lengths of <code>100 mm</code>, <code>150 mm</code>, and <code>210 mm</code>, we may want to enter something like this:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> 100, 150, 210</code></pre></div></div><div class=paragraph><p>Our program needs to consider more than a single byte of input at a time. When it sees the first <code>1</code>, it must understand it is seeing the first digit of a decimal number. When it sees the <code>0</code> and the other <code>0</code>, it must know it is seeing more digits of the same number.</p></div><div class=paragraph><p>When it encounters the first comma, it must know it is no longer receiving the digits of the first number. It must be able to convert the digits of the first number into the value of <code>100</code>. And the digits of the second number into the value of <code>150</code>. And, of course, the digits of the third number into the numeric value of <code>210</code>.</p></div><div class=paragraph><p>We need to decide what delimiters to accept: Do the input numbers have to be separated by a comma? If so, how do we treat two numbers separated by something else?</p></div><div class=paragraph><p>Personally, I like to keep it simple. Something either is a number, so I process it. Or it is not a number, so I discard it. I do not like the computer complaining about me typing in an extra character when it is <em>obvious</em> that it is an extra character. Duh!</p></div><div class=paragraph><p>Plus, it allows me to break up the monotony of computing and type in a query instead of just a number:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>What is the best pinhole diameter <span class=k>for </span>the
	    focal length of 150?</code></pre></div></div><div class=paragraph><p>There is no reason for the computer to spit out a number of complaints:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Syntax error: What
Syntax error: is
Syntax error: the
Syntax error: best</code></pre></div></div><div class=paragraph><p>Et cetera, et cetera, et cetera.</p></div><div class=paragraph><p>Secondly, I like the <code>#</code> character to denote the start of a comment which extends to the end of the line. This does not take too much effort to code, and lets me treat input files for my software as executable scripts.</p></div><div class=paragraph><p>In our case, we also need to decide what units the input should come in: We choose <em>millimeters</em> because that is how most photographers measure the focus length.</p></div><div class=paragraph><p>Finally, we need to decide whether to allow the use of the decimal point (in which case we must also consider the fact that much of the world uses a decimal <em>comma</em>).</p></div><div class=paragraph><p>In our case allowing for the decimal point/comma would offer a false sense of precision: There is little if any noticeable difference between the focus lengths of <code>50</code> and <code>51</code>, so allowing the user to input something like <code>50.5</code> is not a good idea. This is my opinion, mind you, but I am the one writing this program. You can make other choices in yours, of course.</p></div></div><div class=sect4><h5 id=x86-pinhole-options>11.13.3.2. Offering Options<a class=anchor href=#x86-pinhole-options></a></h5><div class=paragraph><p>The most important thing we need to know when building a pinhole camera is the diameter of the pinhole. Since we want to shoot sharp images, we will use the above formula to calculate the pinhole diameter from focal length. As experts are offering several different values for the <code>PC</code> constant, we will need to have the choice.</p></div><div class=paragraph><p>It is traditional in UNIX® programming to have two main ways of choosing program parameters, plus to have a default for the time the user does not make a choice.</p></div><div class=paragraph><p>Why have two ways of choosing?</p></div><div class=paragraph><p>One is to allow a (relatively) <em>permanent</em> choice that applies automatically each time the software is run without us having to tell it over and over what we want it to do.</p></div><div class=paragraph><p>The permanent choices may be stored in a configuration file, typically found in the user’s home directory. The file usually has the same name as the application but is started with a dot. Often <em>"rc"</em> is added to the file name. So, ours could be <span class=filename>~/.pinhole</span> or <span class=filename>~/.pinholerc</span>. (The <span class=filename>~/</span> means current user’s home directory.)</p></div><div class=paragraph><p>The configuration file is used mostly by programs that have many configurable parameters. Those that have only one (or a few) often use a different method: They expect to find the parameter in an <em>environment variable</em>. In our case, we might look at an environment variable named <code>PINHOLE</code>.</p></div><div class=paragraph><p>Usually, a program uses one or the other of the above methods. Otherwise, if a configuration file said one thing, but an environment variable another, the program might get confused (or just too complicated).</p></div><div class=paragraph><p>Because we only need to choose <em>one</em> such parameter, we will go with the second method and search the environment for a variable named <code>PINHOLE</code>.</p></div><div class=paragraph><p>The other way allows us to make <em>ad hoc</em> decisions: <em>"Though I usually want you to use 0.039, this time I want 0.03872."</em> In other words, it allows us to <em>override</em> the permanent choice.</p></div><div class=paragraph><p>This type of choice is usually done with command line parameters.</p></div><div class=paragraph><p>Finally, a program <em>always</em> needs a <em>default</em>. The user may not make any choices. Perhaps he does not know what to choose. Perhaps he is "just browsing." Preferably, the default will be the value most users would choose anyway. That way they do not need to choose. Or, rather, they can choose the default without an additional effort.</p></div><div class=paragraph><p>Given this system, the program may find conflicting options, and handle them this way:</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>If it finds an <em>ad hoc</em> choice (e.g., command line parameter), it should accept that choice. It must ignore any permanent choice and any default.</p></li><li><p><em>Otherwise</em>, if it finds a permanent option (e.g., an environment variable), it should accept it, and ignore the default.</p></li><li><p><em>Otherwise</em>, it should use the default.</p></li></ol></div></div></div><div class=paragraph><p>We also need to decide what <em>format</em> our <code>PC</code> option should have.</p></div><div class=paragraph><p>At first site, it seems obvious to use the <code>PINHOLE=0.04</code> format for the environment variable, and <code>-p0.04</code> for the command line.</p></div><div class=paragraph><p>Allowing that is actually a security risk. The <code>PC</code> constant is a very small number. Naturally, we will test our software using various small values of <code>PC</code>. But what will happen if someone runs the program choosing a huge value?</p></div><div class=paragraph><p>It may crash the program because we have not designed it to handle huge numbers.</p></div><div class=paragraph><p>Or, we may spend more time on the program so it can handle huge numbers. We might do that if we were writing commercial software for computer illiterate audience.</p></div><div class=paragraph><p>Or, we might say, <em>"Tough! The user should know better.""</em></p></div><div class=paragraph><p>Or, we just may make it impossible for the user to enter a huge number. This is the approach we will take: We will use an <em>implied 0.</em> prefix.</p></div><div class=paragraph><p>In other words, if the user wants <code>0.04</code>, we will expect him to type <code>-p04</code>, or set <code>PINHOLE=04</code> in his environment. So, if he says <code>-p9999999</code>, we will interpret it as <code>0.9999999</code>-still ridiculous but at least safer.</p></div><div class=paragraph><p>Secondly, many users will just want to go with either Bender’s constant or Connors' constant. To make it easier on them, we will interpret <code>-b</code> as identical to <code>-p04</code>, and <code>-c</code> as identical to <code>-p037</code>.</p></div></div><div class=sect4><h5 id=x86-pinhole-output>11.13.3.3. The Output<a class=anchor href=#x86-pinhole-output></a></h5><div class=paragraph><p>We need to decide what we want our software to send to the output, and in what format.</p></div><div class=paragraph><p>Since our input allows for an unspecified number of focal length entries, it makes sense to use a traditional database-style output of showing the result of the calculation for each focal length on a separate line, while separating all values on one line by a <code>tab</code> character.</p></div><div class=paragraph><p>Optionally, we should also allow the user to specify the use of the CSV format we have studied earlier. In this case, we will print out a line of comma-separated names describing each field of every line, then show our results as before, but substituting a <code>comma</code> for the <code>tab</code>.</p></div><div class=paragraph><p>We need a command line option for the CSV format. We cannot use <code>-c</code> because that already means <em>use Connors' constant</em>. For some strange reason, many web sites refer to CSV files as <em>"Excel spreadsheet"</em> (though the CSV format predates Excel). We will, therefore, use the <code>-e</code> switch to inform our software we want the output in the CSV format.</p></div><div class=paragraph><p>We will start each line of the output with the focal length. This may sound repetitious at first, especially in the interactive mode: The user types in the focal length, and we are repeating it.</p></div><div class=paragraph><p>But the user can type several focal lengths on one line. The input can also come in from a file or from the output of another program. In that case the user does not see the input at all.</p></div><div class=paragraph><p>By the same token, the output can go to a file which we will want to examine later, or it could go to the printer, or become the input of another program.</p></div><div class=paragraph><p>So, it makes perfect sense to start each line with the focal length as entered by the user.</p></div><div class=paragraph><p>No, wait! Not as entered by the user. What if the user types in something like this:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> 00000000150</code></pre></div></div><div class=paragraph><p>Clearly, we need to strip those leading zeros.</p></div><div class=paragraph><p>So, we might consider reading the user input as is, converting it to binary inside the FPU, and printing it out from there.</p></div><div class=paragraph><p>But…​</p></div><div class=paragraph><p>What if the user types something like this:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> 17459765723452353453534535353530530534563507309676764423</code></pre></div></div><div class=paragraph><p>Ha! The packed decimal FPU format lets us input 18-digit numbers. But the user has entered more than 18 digits. How do we handle that?</p></div><div class=paragraph><p>Well, we <em>could</em> modify our code to read the first 18 digits, enter it to the FPU, then read more, multiply what we already have on the TOS by 10 raised to the number of additional digits, then <code>add</code> to it.</p></div><div class=paragraph><p>Yes, we could do that. But in <em>this</em> program it would be ridiculous (in a different one it may be just the thing to do): Even the circumference of the Earth expressed in millimeters only takes 11 digits. Clearly, we cannot build a camera that large (not yet, anyway).</p></div><div class=paragraph><p>So, if the user enters such a huge number, he is either bored, or testing us, or trying to break into the system, or playing games-doing anything but designing a pinhole camera.</p></div><div class=paragraph><p>What will we do?</p></div><div class=paragraph><p>We will slap him in the face, in a manner of speaking:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>17459765723452353453534535353530530534563507309676764423	???	???	???	???	???</code></pre></div></div><div class=paragraph><p>To achieve that, we will simply ignore any leading zeros. Once we find a non-zero digit, we will initialize a counter to <code>0</code> and start taking three steps:</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Send the digit to the output.</p></li><li><p>Append the digit to a buffer we will use later to produce the packed decimal we can send to the FPU.</p></li><li><p>Increase the counter.</p></li></ol></div></div></div><div class=paragraph><p>Now, while we are taking these three steps, we also need to watch out for one of two conditions:</p></div><div class=ulist><ul><li><p>If the counter grows above 18, we stop appending to the buffer. We continue reading the digits and sending them to the output.</p></li><li><p>If, or rather <em>when</em>, the next input character is not a digit, we are done inputting for now.</p><div class=paragraph><p>Incidentally, we can simply discard the non-digit, unless it is a <code>#</code>, which we must return to the input stream. It starts a comment, so we must see it after we are done producing output and start looking for more input.</p></div></li></ul></div><div class=paragraph><p>That still leaves one possibility uncovered: If all the user enters is a zero (or several zeros), we will never find a non-zero to display.</p></div><div class=paragraph><p>We can determine this has happened whenever our counter stays at <code>0</code>. In that case we need to send <code>0</code> to the output, and perform another "slap in the face":</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>0	???	???	???	???	???</code></pre></div></div><div class=paragraph><p>Once we have displayed the focal length and determined it is valid (greater than <code>0</code> but not exceeding 18 digits), we can calculate the pinhole diameter.</p></div><div class=paragraph><p>It is not by coincidence that <em>pinhole</em> contains the word <em>pin</em>. Indeed, many a pinhole literally is a <em>pin hole</em>, a hole carefully punched with the tip of a pin.</p></div><div class=paragraph><p>That is because a typical pinhole is very small. Our formula gets the result in millimeters. We will multiply it by <code>1000</code>, so we can output the result in <em>microns</em>.</p></div><div class=paragraph><p>At this point we have yet another trap to face: <em>Too much precision.</em></p></div><div class=paragraph><p>Yes, the FPU was designed for high precision mathematics. But we are not dealing with high precision mathematics. We are dealing with physics (optics, specifically).</p></div><div class=paragraph><p>Suppose we want to convert a truck into a pinhole camera (we would not be the first ones to do that!). Suppose its box is <code>12</code> meters long, so we have the focal length of <code>12000</code>. Well, using Bender’s constant, it gives us square root of <code>12000</code> multiplied by <code>0.04</code>, which is <code>4.381780460</code> millimeters, or <code>4381.780460</code> microns.</p></div><div class=paragraph><p>Put either way, the result is absurdly precise. Our truck is not <em>exactly</em> <code>12000</code> millimeters long. We did not measure its length with such a precision, so stating we need a pinhole with the diameter of <code>4.381780460</code> millimeters is, well, deceiving. <code>4.4</code> millimeters would do just fine.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>I "only" used ten digits in the above example. Imagine the absurdity of going for all 18!</p></div></td></tr></tbody></table></div><div class=paragraph><p>We need to limit the number of significant digits of our result. One way of doing it is by using an integer representing microns. So, our truck would need a pinhole with the diameter of <code>4382</code> microns. Looking at that number, we still decide that <code>4400</code> microns, or <code>4.4</code> millimeters is close enough.</p></div><div class=paragraph><p>Additionally, we can decide that no matter how big a result we get, we only want to display four significant digits (or any other number of them, of course). Alas, the FPU does not offer rounding to a specific number of digits (after all, it does not view the numbers as decimal but as binary).</p></div><div class=paragraph><p>We, therefore, must devise an algorithm to reduce the number of significant digits.</p></div><div class=paragraph><p>Here is mine (I think it is awkward-if you know a better one, <em>please</em>, let me know):</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Initialize a counter to <code>0</code>.</p></li><li><p>While the number is greater than or equal to <code>10000</code>, divide it by <code>10</code> and increase the counter.</p></li><li><p>Output the result.</p></li><li><p>While the counter is greater than <code>0</code>, output <code>0</code> and decrease the counter.</p></li></ol></div></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>The <code>10000</code> is only good if you want <em>four</em> significant digits. For any other number of significant digits, replace <code>10000</code> with <code>10</code> raised to the number of significant digits.</p></div></td></tr></tbody></table></div><div class=paragraph><p>We will, then, output the pinhole diameter in microns, rounded off to four significant digits.</p></div><div class=paragraph><p>At this point, we know the <em>focal length</em> and the <em>pinhole diameter</em>. That means we have enough information to also calculate the <em>f-number</em>.</p></div><div class=paragraph><p>We will display the f-number, rounded to four significant digits. Chances are the f-number will tell us very little. To make it more meaningful, we can find the nearest <em>normalized f-number</em>, i.e., the nearest power of the square root of 2.</p></div><div class=paragraph><p>We do that by multiplying the actual f-number by itself, which, of course, will give us its <code>square</code>. We will then calculate its base-2 logarithm, which is much easier to do than calculating the base-square-root-of-2 logarithm! We will round the result to the nearest integer. Next, we will raise 2 to the result. Actually, the FPU gives us a good shortcut to do that: We can use the <code>fscale</code> op code to "scale" 1, which is analogous to <code>shift</code>ing an integer left. Finally, we calculate the square root of it all, and we have the nearest normalized f-number.</p></div><div class=paragraph><p>If all that sounds overwhelming-or too much work, perhaps-it may become much clearer if you see the code. It takes 9 op codes altogether:</p></div><div class="literalblock programlisting"><div class=content><pre>fmul	st0, st0
	fld1
	fld	st1
	fyl2x
	frndint
	fld1
	fscale
	fsqrt
	fstp	st1</pre></div></div><div class=paragraph><p>The first line, <code>fmul st0, st0</code>, squares the contents of the TOS (top of the stack, same as <code>st</code>, called <code>st0</code> by nasm). The <code>fld1</code> pushes <code>1</code> on the TOS.</p></div><div class=paragraph><p>The next line, <code>fld st1</code>, pushes the square back to the TOS. At this point the square is both in <code>st</code> and <code>st(2)</code> (it will become clear why we leave a second copy on the stack in a moment). <code>st(1)</code> contains <code>1</code>.</p></div><div class=paragraph><p>Next, <code>fyl2x</code> calculates base-2 logarithm of <code>st</code> multiplied by <code>st(1)</code>. That is why we placed <code>1</code> on <code>st(1)</code> before.</p></div><div class=paragraph><p>At this point, <code>st</code> contains the logarithm we have just calculated, <code>st(1)</code> contains the square of the actual f-number we saved for later.</p></div><div class=paragraph><p><code>frndint</code> rounds the TOS to the nearest integer. <code>fld1</code> pushes a <code>1</code>. <code>fscale</code> shifts the <code>1</code> we have on the TOS by the value in <code>st(1)</code>, effectively raising 2 to <code>st(1)</code>.</p></div><div class=paragraph><p>Finally, <code>fsqrt</code> calculates the square root of the result, i.e., the nearest normalized f-number.</p></div><div class=paragraph><p>We now have the nearest normalized f-number on the TOS, the base-2 logarithm rounded to the nearest integer in <code>st(1)</code>, and the square of the actual f-number in <code>st(2)</code>. We are saving the value in <code>st(2)</code> for later.</p></div><div class=paragraph><p>But we do not need the contents of <code>st(1)</code> anymore. The last line, <code>fstp st1</code>, places the contents of <code>st</code> to <code>st(1)</code>, and pops. As a result, what was <code>st(1)</code> is now <code>st</code>, what was <code>st(2)</code> is now <code>st(1)</code>, etc. The new <code>st</code> contains the normalized f-number. The new <code>st(1)</code> contains the square of the actual f-number we have stored there for posterity.</p></div><div class=paragraph><p>At this point, we are ready to output the normalized f-number. Because it is normalized, we will not round it off to four significant digits, but will send it out in its full precision.</p></div><div class=paragraph><p>The normalized f-number is useful as long as it is reasonably small and can be found on our light meter. Otherwise we need a different method of determining proper exposure.</p></div><div class=paragraph><p>Earlier we have figured out the formula of calculating proper exposure at an arbitrary f-number from that measured at a different f-number.</p></div><div class=paragraph><p>Every light meter I have ever seen can determine proper exposure at f5.6. We will, therefore, calculate an <em>"f5.6 multiplier,"</em> i.e., by how much we need to multiply the exposure measured at f5.6 to determine the proper exposure for our pinhole camera.</p></div><div class=paragraph><p>From the above formula we know this factor can be calculated by dividing our f-number (the actual one, not the normalized one) by <code>5.6</code>, and squaring the result.</p></div><div class=paragraph><p>Mathematically, dividing the square of our f-number by the square of <code>5.6</code> will give us the same result.</p></div><div class=paragraph><p>Computationally, we do not want to square two numbers when we can only square one. So, the first solution seems better at first.</p></div><div class=paragraph><p>But…​</p></div><div class=paragraph><p><code>5.6</code> is a <em>constant</em>. We do not have to have our FPU waste precious cycles. We can just tell it to divide the square of the f-number by whatever <code>5.6²</code> equals to. Or we can divide the f-number by <code>5.6</code>, and then square the result. The two ways now seem equal.</p></div><div class=paragraph><p>But, they are not!</p></div><div class=paragraph><p>Having studied the principles of photography above, we remember that the <code>5.6</code> is actually square root of 2 raised to the fifth power. An <em>irrational</em> number. The square of this number is <em>exactly</em> <code>32</code>.</p></div><div class=paragraph><p>Not only is <code>32</code> an integer, it is a power of 2. We do not need to divide the square of the f-number by <code>32</code>. We only need to use <code>fscale</code> to shift it right by five positions. In the FPU lingo it means we will <code>fscale</code> it with <code>st(1)</code> equal to <code>-5</code>. That is <em>much faster</em> than a division.</p></div><div class=paragraph><p>So, now it has become clear why we have saved the square of the f-number on the top of the FPU stack. The calculation of the f5.6 multiplier is the easiest calculation of this entire program! We will output it rounded to four significant digits.</p></div><div class=paragraph><p>There is one more useful number we can calculate: The number of stops our f-number is from f5.6. This may help us if our f-number is just outside the range of our light meter, but we have a shutter which lets us set various speeds, and this shutter uses stops.</p></div><div class=paragraph><p>Say, our f-number is 5 stops from f5.6, and the light meter says we should use 1/1000 sec. Then we can set our shutter speed to 1/1000 first, then move the dial by 5 stops.</p></div><div class=paragraph><p>This calculation is quite easy as well. All we have to do is to calculate the base-2 logarithm of the f5.6 multiplier we had just calculated (though we need its value from before we rounded it off). We then output the result rounded to the nearest integer. We do not need to worry about having more than four significant digits in this one: The result is most likely to have only one or two digits anyway.</p></div></div></div><div class=sect3><h4 id=x86-fpu-optimizations>11.13.4. FPU Optimizations<a class=anchor href=#x86-fpu-optimizations></a></h4><div class=paragraph><p>In assembly language we can optimize the FPU code in ways impossible in high languages, including C.</p></div><div class=paragraph><p>Whenever a C function needs to calculate a floating-point value, it loads all necessary variables and constants into FPU registers. It then does whatever calculation is required to get the correct result. Good C compilers can optimize that part of the code really well.</p></div><div class=paragraph><p>It "returns" the value by leaving the result on the TOS. However, before it returns, it cleans up. Any variables and constants it used in its calculation are now gone from the FPU.</p></div><div class=paragraph><p>It cannot do what we just did above: We calculated the square of the f-number and kept it on the stack for later use by another function.</p></div><div class=paragraph><p>We <em>knew</em> we would need that value later on. We also knew we had enough room on the stack (which only has room for 8 numbers) to store it there.</p></div><div class=paragraph><p>A C compiler has no way of knowing that a value it has on the stack will be required again in the very near future.</p></div><div class=paragraph><p>Of course, the C programmer may know it. But the only recourse he has is to store the value in a memory variable.</p></div><div class=paragraph><p>That means, for one, the value will be changed from the 80-bit precision used internally by the FPU to a C <em>double</em> (64 bits) or even <em>single</em> (32 bits).</p></div><div class=paragraph><p>That also means that the value must be moved from the TOS into the memory, and then back again. Alas, of all FPU operations, the ones that access the computer memory are the slowest.</p></div><div class=paragraph><p>So, whenever programming the FPU in assembly language, look for the ways of keeping intermediate results on the FPU stack.</p></div><div class=paragraph><p>We can take that idea even further! In our program we are using a <em>constant</em> (the one we named <code>PC</code>).</p></div><div class=paragraph><p>It does not matter how many pinhole diameters we are calculating: 1, 10, 20, 1000, we are always using the same constant. Therefore, we can optimize our program by keeping the constant on the stack all the time.</p></div><div class=paragraph><p>Early on in our program, we are calculating the value of the above constant. We need to divide our input by <code>10</code> for every digit in the constant.</p></div><div class=paragraph><p>It is much faster to multiply than to divide. So, at the start of our program, we divide <code>10</code> into <code>1</code> to obtain <code>0.1</code>, which we then keep on the stack: Instead of dividing the input by <code>10</code> for every digit, we multiply it by <code>0.1</code>.</p></div><div class=paragraph><p>By the way, we do not input <code>0.1</code> directly, even though we could. We have a reason for that: While <code>0.1</code> can be expressed with just one decimal place, we do not know how many <em>binary</em> places it takes. We, therefore, let the FPU calculate its binary value to its own high precision.</p></div><div class=paragraph><p>We are using other constants: We multiply the pinhole diameter by <code>1000</code> to convert it from millimeters to microns. We compare numbers to <code>10000</code> when we are rounding them off to four significant digits. So, we keep both, <code>1000</code> and <code>10000</code>, on the stack. And, of course, we reuse the <code>0.1</code> when rounding off numbers to four digits.</p></div><div class=paragraph><p>Last but not least, we keep <code>-5</code> on the stack. We need it to scale the square of the f-number, instead of dividing it by <code>32</code>. It is not by coincidence we load this constant last. That makes it the top of the stack when only the constants are on it. So, when the square of the f-number is being scaled, the <code>-5</code> is at <code>st(1)</code>, precisely where <code>fscale</code> expects it to be.</p></div><div class=paragraph><p>It is common to create certain constants from scratch instead of loading them from the memory. That is what we are doing with <code>-5</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>	fld1			; TOS =  1
	fadd	st0, st0	; TOS =  2
	fadd	st0, st0	; TOS =  4
	fld1			; TOS =  1
	faddp	st1, st0	; TOS =  5
	fchs			; TOS = -5</pre></div></div><div class=paragraph><p>We can generalize all these optimizations into one rule: <em>Keep repeat values on the stack!</em></p></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p><em>PostScript®</em> is a stack-oriented programming language. There are many more books available about PostScript® than about the FPU assembly language: Mastering PostScript® will help you master the FPU.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=x86-pinhole-the-code>11.13.5. pinhole-The Code<a class=anchor href=#x86-pinhole-the-code></a></h4><div class="literalblock programlisting"><div class=content><pre>;;;;;;; pinhole.asm ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Find various parameters of a pinhole camera construction and use
;
; Started:	 9-Jun-2001
; Updated:	10-Jun-2001
;
; Copyright (c) 2001 G. Adam Stanislav
; All rights reserved.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

%include	&#39;system.inc&#39;

%define	BUFSIZE	2048

section	.data
align 4
ten	dd	10
thousand	dd	1000
tthou	dd	10000
fd.in	dd	stdin
fd.out	dd	stdout
envar	db	&#39;PINHOLE=&#39;	; Exactly 8 bytes, or 2 dwords long
pinhole	db	&#39;04,&#39;, 		; Bender&#39;s constant (0.04)
connors	db	&#39;037&#39;, 0Ah	; Connors&#39; constant
usg	db	&#39;Usage: pinhole [-b] [-c] [-e] [-p &lt;value&gt;] [-o &lt;outfile&gt;] [-i &lt;infile&gt;]&#39;, 0Ah
usglen	equ	$-usg
iemsg	db	&#34;pinhole: Can&#39;t open input file&#34;, 0Ah
iemlen	equ	$-iemsg
oemsg	db	&#34;pinhole: Can&#39;t create output file&#34;, 0Ah
oemlen	equ	$-oemsg
pinmsg	db	&#34;pinhole: The PINHOLE constant must not be 0&#34;, 0Ah
pinlen	equ	$-pinmsg
toobig	db	&#34;pinhole: The PINHOLE constant may not exceed 18 decimal places&#34;, 0Ah
biglen	equ	$-toobig
huhmsg	db	9, &#39;???&#39;
separ	db	9, &#39;???&#39;
sep2	db	9, &#39;???&#39;
sep3	db	9, &#39;???&#39;
sep4	db	9, &#39;???&#39;, 0Ah
huhlen	equ	$-huhmsg
header	db	&#39;focal length in millimeters,pinhole diameter in microns,&#39;
	db	&#39;F-number,normalized F-number,F-5.6 multiplier,stops &#39;
	db	&#39;from F-5.6&#39;, 0Ah
headlen	equ	$-header

section .bss
ibuffer	resb	BUFSIZE
obuffer	resb	BUFSIZE
dbuffer	resb	20		; decimal input buffer
bbuffer	resb	10		; BCD buffer

section	.text
align 4
huh:
	call	write
	push	dword huhlen
	push	dword huhmsg
	push	dword [fd.out]
	sys.write
	add	esp, byte 12
	ret

align 4
perr:
	push	dword pinlen
	push	dword pinmsg
	push	dword stderr
	sys.write
	push	dword 4		; return failure
	sys.exit

align 4
consttoobig:
	push	dword biglen
	push	dword toobig
	push	dword stderr
	sys.write
	push	dword 5		; return failure
	sys.exit

align 4
ierr:
	push	dword iemlen
	push	dword iemsg
	push	dword stderr
	sys.write
	push	dword 1		; return failure
	sys.exit

align 4
oerr:
	push	dword oemlen
	push	dword oemsg
	push	dword stderr
	sys.write
	push	dword 2
	sys.exit

align 4
usage:
	push	dword usglen
	push	dword usg
	push	dword stderr
	sys.write
	push	dword 3
	sys.exit

align 4
global	_start
_start:
	add	esp, byte 8	; discard argc and argv[0]
	sub	esi, esi

.arg:
	pop	ecx
	or	ecx, ecx
	je	near .getenv		; no more arguments

	; ECX contains the pointer to an argument
	cmp	byte [ecx], &#39;-&#39;
	jne	usage

	inc	ecx
	mov	ax, [ecx]
	inc	ecx

.o:
	cmp	al, &#39;o&#39;
	jne	.i

	; Make sure we are not asked for the output file twice
	cmp	dword [fd.out], stdout
	jne	usage

	; Find the path to output file - it is either at [ECX+1],
	; i.e., -ofile --
	; or in the next argument,
	; i.e., -o file

	or	ah, ah
	jne	.openoutput
	pop	ecx
	jecxz	usage

.openoutput:
	push	dword 420	; file mode (644 octal)
	push	dword 0200h | 0400h | 01h
	; O_CREAT | O_TRUNC | O_WRONLY
	push	ecx
	sys.open
	jc	near oerr

	add	esp, byte 12
	mov	[fd.out], eax
	jmp	short .arg

.i:
	cmp	al, &#39;i&#39;
	jne	.p

	; Make sure we are not asked twice
	cmp	dword [fd.in], stdin
	jne	near usage

	; Find the path to the input file
	or	ah, ah
	jne	.openinput
	pop	ecx
	or	ecx, ecx
	je near usage

.openinput:
	push	dword 0		; O_RDONLY
	push	ecx
	sys.open
	jc	near ierr		; open failed

	add	esp, byte 8
	mov	[fd.in], eax
	jmp	.arg

.p:
	cmp	al, &#39;p&#39;
	jne	.c
	or	ah, ah
	jne	.pcheck

	pop	ecx
	or	ecx, ecx
	je	near usage

	mov	ah, [ecx]

.pcheck:
	cmp	ah, &#39;0&#39;
	jl	near usage
	cmp	ah, &#39;9&#39;
	ja	near usage
	mov	esi, ecx
	jmp	.arg

.c:
	cmp	al, &#39;c&#39;
	jne	.b
	or	ah, ah
	jne	near usage
	mov	esi, connors
	jmp	.arg

.b:
	cmp	al, &#39;b&#39;
	jne	.e
	or	ah, ah
	jne	near usage
	mov	esi, pinhole
	jmp	.arg

.e:
	cmp	al, &#39;e&#39;
	jne	near usage
	or	ah, ah
	jne	near usage
	mov	al, &#39;,&#39;
	mov	[huhmsg], al
	mov	[separ], al
	mov	[sep2], al
	mov	[sep3], al
	mov	[sep4], al
	jmp	.arg

align 4
.getenv:
	; If ESI = 0, we did not have a -p argument,
	; and need to check the environment for &#34;PINHOLE=&#34;
	or	esi, esi
	jne	.init

	sub	ecx, ecx

.nextenv:
	pop	esi
	or	esi, esi
	je	.default	; no PINHOLE envar found

	; check if this envar starts with &#39;PINHOLE=&#39;
	mov	edi, envar
	mov	cl, 2		; &#39;PINHOLE=&#39; is 2 dwords long
rep	cmpsd
	jne	.nextenv

	; Check if it is followed by a digit
	mov	al, [esi]
	cmp	al, &#39;0&#39;
	jl	.default
	cmp	al, &#39;9&#39;
	jbe	.init
	; fall through

align 4
.default:
	; We got here because we had no -p argument,
	; and did not find the PINHOLE envar.
	mov	esi, pinhole
	; fall through

align 4
.init:
	sub	eax, eax
	sub	ebx, ebx
	sub	ecx, ecx
	sub	edx, edx
	mov	edi, dbuffer+1
	mov	byte [dbuffer], &#39;0&#39;

	; Convert the pinhole constant to real
.constloop:
	lodsb
	cmp	al, &#39;9&#39;
	ja	.setconst
	cmp	al, &#39;0&#39;
	je	.processconst
	jb	.setconst

	inc	dl

.processconst:
	inc	cl
	cmp	cl, 18
	ja	near consttoobig
	stosb
	jmp	short .constloop

align 4
.setconst:
	or	dl, dl
	je	near perr

	finit
	fild	dword [tthou]

	fld1
	fild	dword [ten]
	fdivp	st1, st0

	fild	dword [thousand]
	mov	edi, obuffer

	mov	ebp, ecx
	call	bcdload

.constdiv:
	fmul	st0, st2
	loop	.constdiv

	fld1
	fadd	st0, st0
	fadd	st0, st0
	fld1
	faddp	st1, st0
	fchs

	; If we are creating a CSV file,
	; print header
	cmp	byte [separ], &#39;,&#39;
	jne	.bigloop

	push	dword headlen
	push	dword header
	push	dword [fd.out]
	sys.write

.bigloop:
	call	getchar
	jc	near done

	; Skip to the end of the line if you got &#39;#&#39;
	cmp	al, &#39;#&#39;
	jne	.num
	call	skiptoeol
	jmp	short .bigloop

.num:
	; See if you got a number
	cmp	al, &#39;0&#39;
	jl	.bigloop
	cmp	al, &#39;9&#39;
	ja	.bigloop

	; Yes, we have a number
	sub	ebp, ebp
	sub	edx, edx

.number:
	cmp	al, &#39;0&#39;
	je	.number0
	mov	dl, 1

.number0:
	or	dl, dl		; Skip leading 0&#39;s
	je	.nextnumber
	push	eax
	call	putchar
	pop	eax
	inc	ebp
	cmp	ebp, 19
	jae	.nextnumber
	mov	[dbuffer+ebp], al

.nextnumber:
	call	getchar
	jc	.work
	cmp	al, &#39;#&#39;
	je	.ungetc
	cmp	al, &#39;0&#39;
	jl	.work
	cmp	al, &#39;9&#39;
	ja	.work
	jmp	short .number

.ungetc:
	dec	esi
	inc	ebx

.work:
	; Now, do all the work
	or	dl, dl
	je	near .work0

	cmp	ebp, 19
	jae	near .toobig

	call	bcdload

	; Calculate pinhole diameter

	fld	st0	; save it
	fsqrt
	fmul	st0, st3
	fld	st0
	fmul	st5
	sub	ebp, ebp

	; Round off to 4 significant digits
.diameter:
	fcom	st0, st7
	fstsw	ax
	sahf
	jb	.printdiameter
	fmul	st0, st6
	inc	ebp
	jmp	short .diameter

.printdiameter:
	call	printnumber	; pinhole diameter

	; Calculate F-number

	fdivp	st1, st0
	fld	st0

	sub	ebp, ebp

.fnumber:
	fcom	st0, st6
	fstsw	ax
	sahf
	jb	.printfnumber
	fmul	st0, st5
	inc	ebp
	jmp	short .fnumber

.printfnumber:
	call	printnumber	; F number

	; Calculate normalized F-number
	fmul	st0, st0
	fld1
	fld	st1
	fyl2x
	frndint
	fld1
	fscale
	fsqrt
	fstp	st1

	sub	ebp, ebp
	call	printnumber

	; Calculate time multiplier from F-5.6

	fscale
	fld	st0

	; Round off to 4 significant digits
.fmul:
	fcom	st0, st6
	fstsw	ax
	sahf

	jb	.printfmul
	inc	ebp
	fmul	st0, st5
	jmp	short .fmul

.printfmul:
	call	printnumber	; F multiplier

	; Calculate F-stops from 5.6

	fld1
	fxch	st1
	fyl2x

	sub	ebp, ebp
	call	printnumber

	mov	al, 0Ah
	call	putchar
	jmp	.bigloop

.work0:
	mov	al, &#39;0&#39;
	call	putchar

align 4
.toobig:
	call	huh
	jmp	.bigloop

align 4
done:
	call	write		; flush output buffer

	; close files
	push	dword [fd.in]
	sys.close

	push	dword [fd.out]
	sys.close

	finit

	; return success
	push	dword 0
	sys.exit

align 4
skiptoeol:
	; Keep reading until you come to cr, lf, or eof
	call	getchar
	jc	done
	cmp	al, 0Ah
	jne	.cr
	ret

.cr:
	cmp	al, 0Dh
	jne	skiptoeol
	ret

align 4
getchar:
	or	ebx, ebx
	jne	.fetch

	call	read

.fetch:
	lodsb
	dec	ebx
	clc
	ret

read:
	jecxz	.read
	call	write

.read:
	push	dword BUFSIZE
	mov	esi, ibuffer
	push	esi
	push	dword [fd.in]
	sys.read
	add	esp, byte 12
	mov	ebx, eax
	or	eax, eax
	je	.empty
	sub	eax, eax
	ret

align 4
.empty:
	add	esp, byte 4
	stc
	ret

align 4
putchar:
	stosb
	inc	ecx
	cmp	ecx, BUFSIZE
	je	write
	ret

align 4
write:
	jecxz	.ret	; nothing to write
	sub	edi, ecx	; start of buffer
	push	ecx
	push	edi
	push	dword [fd.out]
	sys.write
	add	esp, byte 12
	sub	eax, eax
	sub	ecx, ecx	; buffer is empty now
.ret:
	ret

align 4
bcdload:
	; EBP contains the number of chars in dbuffer
	push	ecx
	push	esi
	push	edi

	lea	ecx, [ebp+1]
	lea	esi, [dbuffer+ebp-1]
	shr	ecx, 1

	std

	mov	edi, bbuffer
	sub	eax, eax
	mov	[edi], eax
	mov	[edi+4], eax
	mov	[edi+2], ax

.loop:
	lodsw
	sub	ax, 3030h
	shl	al, 4
	or	al, ah
	mov	[edi], al
	inc	edi
	loop	.loop

	fbld	[bbuffer]

	cld
	pop	edi
	pop	esi
	pop	ecx
	sub	eax, eax
	ret

align 4
printnumber:
	push	ebp
	mov	al, [separ]
	call	putchar

	; Print the integer at the TOS
	mov	ebp, bbuffer+9
	fbstp	[bbuffer]

	; Check the sign
	mov	al, [ebp]
	dec	ebp
	or	al, al
	jns	.leading

	; We got a negative number (should never happen)
	mov	al, &#39;-&#39;
	call	putchar

.leading:
	; Skip leading zeros
	mov	al, [ebp]
	dec	ebp
	or	al, al
	jne	.first
	cmp	ebp, bbuffer
	jae	.leading

	; We are here because the result was 0.
	; Print &#39;0&#39; and return
	mov	al, &#39;0&#39;
	jmp	putchar

.first:
	; We have found the first non-zero.
	; But it is still packed
	test	al, 0F0h
	jz	.second
	push	eax
	shr	al, 4
	add	al, &#39;0&#39;
	call	putchar
	pop	eax
	and	al, 0Fh

.second:
	add	al, &#39;0&#39;
	call	putchar

.next:
	cmp	ebp, bbuffer
	jb	.done

	mov	al, [ebp]
	push	eax
	shr	al, 4
	add	al, &#39;0&#39;
	call	putchar
	pop	eax
	and	al, 0Fh
	add	al, &#39;0&#39;
	call	putchar

	dec	ebp
	jmp	short .next

.done:
	pop	ebp
	or	ebp, ebp
	je	.ret

.zeros:
	mov	al, &#39;0&#39;
	call	putchar
	dec	ebp
	jne	.zeros

.ret:
	ret</pre></div></div><div class=paragraph><p>The code follows the same format as all the other filters we have seen before, with one subtle exception:</p></div><div class=quoteblock><blockquote><div class=paragraph><p>We are no longer assuming that the end of input implies the end of things to do, something we took for granted in the <em>character-oriented</em> filters.</p></div><div class=paragraph><p>This filter does not process characters. It processes a <em>language</em> (albeit a very simple one, consisting only of numbers).</p></div><div class=paragraph><p>When we have no more input, it can mean one of two things:</p></div><div class=ulist><ul><li><p>We are done and can quit. This is the same as before.</p></li><li><p>The last character we have read was a digit. We have stored it at the end of our ASCII-to-float conversion buffer. We now need to convert the contents of that buffer into a number and write the last line of our output.</p></li></ul></div><div class=paragraph><p>For that reason, we have modified our <code>getchar</code> and our <code>read</code> routines to return with the <code>carry flag</code> <em>clear</em> whenever we are fetching another character from the input, or the <code>carry flag</code> <em>set</em> whenever there is no more input.</p></div><div class=paragraph><p>Of course, we are still using assembly language magic to do that! Take a good look at <code>getchar</code>. It <em>always</em> returns with the <code>carry flag</code> <em>clear</em>.</p></div><div class=paragraph><p>Yet, our main code relies on the <code>carry flag</code> to tell it when to quit-and it works.</p></div><div class=paragraph><p>The magic is in <code>read</code>. Whenever it receives more input from the system, it just returns to <code>getchar</code>, which fetches a character from the input buffer, <em>clears</em> the <code>carry flag</code> and returns.</p></div><div class=paragraph><p>But when <code>read</code> receives no more input from the system, it does <em>not</em> return to <code>getchar</code> at all. Instead, the <code>add esp, byte 4</code> op code adds <code>4</code> to <code>ESP</code>, <em>sets</em> the <code>carry flag</code>, and returns.</p></div><div class=paragraph><p>So, where does it return to? Whenever a program uses the <code>call</code> op code, the microprocessor <code>push</code>es the return address, i.e., it stores it on the top of the stack (not the FPU stack, the system stack, which is in the memory). When a program uses the <code>ret</code> op code, the microprocessor <code>pop</code>s the return value from the stack, and jumps to the address that was stored there.</p></div><div class=paragraph><p>But since we added <code>4</code> to <code>ESP</code> (which is the stack pointer register), we have effectively given the microprocessor a minor case of <em>amnesia</em>: It no longer remembers it was <code>getchar</code> that <code>call</code>ed <code>read</code>.</p></div><div class=paragraph><p>And since <code>getchar</code> never <code>push</code>ed anything before <code>call</code>ing <code>read</code>, the top of the stack now contains the return address to whatever or whoever <code>call</code>ed <code>getchar</code>. As far as that caller is concerned, he <code>call</code>ed <code>getchar</code>, which <code>ret</code>urned with the <code>carry flag</code> set!</p></div></blockquote></div><div class=paragraph><p>Other than that, the <code>bcdload</code> routine is caught up in the middle of a Lilliputian conflict between the Big-Endians and the Little-Endians.</p></div><div class=paragraph><p>It is converting the text representation of a number into that number: The text is stored in the big-endian order, but the <em>packed decimal</em> is little-endian.</p></div><div class=paragraph><p>To solve the conflict, we use the <code>std</code> op code early on. We cancel it with <code>cld</code> later on: It is quite important we do not <code>call</code> anything that may depend on the default setting of the <em>direction flag</em> while <code>std</code> is active.</p></div><div class=paragraph><p>Everything else in this code should be quit eclear, providing you have read the entire chapter that precedes it.</p></div><div class=paragraph><p>It is a classical example of the adage that programming requires a lot of thought and only a little coding. Once we have thought through every tiny detail, the code almost writes itself.</p></div></div><div class=sect3><h4 id=x86-pinhole-using>11.13.6. Using pinhole<a class=anchor href=#x86-pinhole-using></a></h4><div class=paragraph><p>Because we have decided to make the program <em>ignore</em> any input except for numbers (and even those inside a comment), we can actually perform <em>textual queries</em>. We do not <em>have to</em>, but we <em>can</em>.</p></div><div class=paragraph><p>In my humble opinion, forming a textual query, instead of having to follow a very strict syntax, makes software much more user friendly.</p></div><div class=paragraph><p>Suppose we want to build a pinhole camera to use the 4x5 inch film. The standard focal length for that film is about 150mm. We want to <em>fine-tune</em> our focal length so the pinhole diameter is as round a number as possible. Let us also suppose we are quite comfortable with cameras but somewhat intimidated by computers. Rather than just have to type in a bunch of numbers, we want to <em>ask</em> a couple of questions.</p></div><div class=paragraph><p>Our session might look like this:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% pinhole

Computer,

What size pinhole <span class=k>do </span>I need <span class=k>for </span>the focal length of 150?
150	490	306	362	2930	12
Hmmm... How about 160?
160	506	316	362	3125	12
Let<span class=s1>&#39;s make it 155, please.
155	498	311	362	3027	12
Ah, let&#39;</span>s try 157...
157	501	313	362	3066	12
156?
156	500	312	362	3047	12
That<span class=s1>&#39;s it! Perfect! Thank you very much!
^D</span></code></pre></div></div><div class=paragraph><p>We have found that while for the focal length of 150, our pinhole diameter should be 490 microns, or 0.49 mm, if we go with the almost identical focal length of 156 mm, we can get away with a pinhole diameter of exactly one half of a millimeter.</p></div></div><div class=sect3><h4 id=x86-pinhole-scripting>11.13.7. Scripting<a class=anchor href=#x86-pinhole-scripting></a></h4><div class=paragraph><p>Because we have chosen the <code>#</code> character to denote the start of a comment, we can treat our pinhole software as a <em>scripting language</em>.</p></div><div class=paragraph><p>You have probably seen shell <em>scripts</em> that start with:</p></div><div class="literalblock programlisting"><div class=content><pre>#! /bin/sh</pre></div></div><div class=paragraph><p>…​or…​</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh</pre></div></div><div class=paragraph><p>…​because the blank space after the <code>#!</code> is optional.</p></div><div class=paragraph><p>Whenever UNIX® is asked to run an executable file which starts with the <code>#!</code>, it assumes the file is a script. It adds the command to the rest of the first line of the script, and tries to execute that.</p></div><div class=paragraph><p>Suppose now that we have installed pinhole in /usr/local/bin/, we can now write a script to calculate various pinhole diameters suitable for various focal lengths commonly used with the 120 film.</p></div><div class=paragraph><p>The script might look something like this:</p></div><div class="literalblock programlisting"><div class=content><pre>#! /usr/local/bin/pinhole -b -i
# Find the best pinhole diameter
# for the 120 film

### Standard
80

### Wide angle
30, 40, 50, 60, 70

### Telephoto
100, 120, 140</pre></div></div><div class=paragraph><p>Because 120 is a medium size film, we may name this file medium.</p></div><div class=paragraph><p>We can set its permissions to execute, and run it as if it were a program:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>chmod </span>755 medium
% ./medium</code></pre></div></div><div class=paragraph><p>UNIX® will interpret that last command as:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% /usr/local/bin/pinhole <span class=nt>-b</span> <span class=nt>-i</span> ./medium</code></pre></div></div><div class=paragraph><p>It will run that command and display:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>80	358	224	256	1562	11
30	219	137	128	586	9
40	253	158	181	781	10
50	283	177	181	977	10
60	310	194	181	1172	10
70	335	209	181	1367	10
100	400	250	256	1953	11
120	438	274	256	2344	11
140	473	296	256	2734	11</code></pre></div></div><div class=paragraph><p>Now, let us enter:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ./medium <span class=nt>-c</span></code></pre></div></div><div class=paragraph><p>UNIX® will treat that as:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% /usr/local/bin/pinhole <span class=nt>-b</span> <span class=nt>-i</span> ./medium <span class=nt>-c</span></code></pre></div></div><div class=paragraph><p>That gives it two conflicting options: <code>-b</code> and <code>-c</code> (Use Bender’s constant and use Connors' constant). We have programmed it so later options override early ones-our program will calculate everything using Connors' constant:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>80	331	242	256	1826	11
30	203	148	128	685	9
40	234	171	181	913	10
50	262	191	181	1141	10
60	287	209	181	1370	10
70	310	226	256	1598	11
100	370	270	256	2283	11
120	405	296	256	2739	11
140	438	320	362	3196	12</code></pre></div></div><div class=paragraph><p>We decide we want to go with Bender’s constant after all. We want to save its values as a comma-separated file:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ./medium <span class=nt>-b</span> <span class=nt>-e</span> <span class=o>&gt;</span> bender
% <span class=nb>cat </span>bender
focal length <span class=k>in </span>millimeters,pinhole diameter <span class=k>in </span>microns,F-number,normalized F-number,F-5.6 multiplier,stops from F-5.6
80,358,224,256,1562,11
30,219,137,128,586,9
40,253,158,181,781,10
50,283,177,181,977,10
60,310,194,181,1172,10
70,335,209,181,1367,10
100,400,250,256,1953,11
120,438,274,256,2344,11
140,473,296,256,2734,11
%</code></pre></div></div></div></div><div class=sect2><h3 id=x86-caveats>11.14. Caveats<a class=anchor href=#x86-caveats></a></h3><div class=paragraph><p>Assembly language programmers who "grew up" under MS-DOS® and Windows® often tend to take shortcuts. Reading the keyboard scan codes and writing directly to video memory are two classical examples of practices which, under MS-DOS® are not frowned upon but considered the right thing to do.</p></div><div class=paragraph><p>The reason? Both the PC BIOS and MS-DOS® are notoriously slow when performing these operations.</p></div><div class=paragraph><p>You may be tempted to continue similar practices in the UNIX® environment. For example, I have seen a web site which explains how to access the keyboard scan codes on a popular UNIX® clone.</p></div><div class=paragraph><p>That is generally a <em>very bad idea</em> in UNIX® environment! Let me explain why.</p></div><div class=sect3><h4 id=x86-protected>11.14.1. UNIX® Is Protected<a class=anchor href=#x86-protected></a></h4><div class=paragraph><p>For one thing, it may simply not be possible. UNIX® runs in protected mode. Only the kernel and device drivers are allowed to access hardware directly. Perhaps a particular UNIX® clone will let you read the keyboard scan codes, but chances are a real UNIX® operating system will not. And even if one version may let you do it, the next one may not, so your carefully crafted software may become a dinosaur overnight.</p></div></div><div class=sect3><h4 id=x86-abstraction>11.14.2. UNIX® Is an Abstraction<a class=anchor href=#x86-abstraction></a></h4><div class=paragraph><p>But there is a much more important reason not to try accessing the hardware directly (unless, of course, you are writing a device driver), even on the UNIX® like systems that let you do it:</p></div><div class=paragraph><p><em>UNIX® is an abstraction!</em></p></div><div class=paragraph><p>There is a major difference in the philosophy of design between MS-DOS® and UNIX®. MS-DOS® was designed as a single-user system. It is run on a computer with a keyboard and a video screen attached directly to that computer. User input is almost guaranteed to come from that keyboard. Your program’s output virtually always ends up on that screen.</p></div><div class=paragraph><p>This is NEVER guaranteed under UNIX®. It is quite common for a UNIX® user to pipe and redirect program input and output:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% program1 | program2 | program3 <span class=o>&gt;</span> file1</code></pre></div></div><div class=paragraph><p>If you have written program2, your input does not come from the keyboard but from the output of program1. Similarly, your output does not go to the screen but becomes the input for program3 whose output, in turn, goes to <span class=filename>file1</span>.</p></div><div class=paragraph><p>But there is more! Even if you made sure that your input comes from, and your output goes to, the terminal, there is no guarantee the terminal is a PC: It may not have its video memory where you expect it, nor may its keyboard be producing PC-style scan codes. It may be a Macintosh®, or any other computer.</p></div><div class=paragraph><p>Now you may be shaking your head: My software is in PC assembly language, how can it run on a Macintosh®? But I did not say your software would be running on a Macintosh®, only that its terminal may be a Macintosh®.</p></div><div class=paragraph><p>Under UNIX®, the terminal does not have to be directly attached to the computer that runs your software, it can even be on another continent, or, for that matter, on another planet. It is perfectly possible that a Macintosh® user in Australia connects to a UNIX® system in North America (or anywhere else) via telnet. The software then runs on one computer, while the terminal is on a different computer: If you try to read the scan codes, you will get the wrong input!</p></div><div class=paragraph><p>Same holds true about any other hardware: A file you are reading may be on a disk you have no direct access to. A camera you are reading images from may be on a space shuttle, connected to you via satellites.</p></div><div class=paragraph><p>That is why under UNIX® you must never make any assumptions about where your data is coming from and going to. Always let the system handle the physical access to the hardware.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>These are caveats, not absolute rules. Exceptions are possible. For example, if a text editor has determined it is running on a local machine, it may want to read the scan codes directly for improved control. I am not mentioning these caveats to tell you what to do or what not to do, just to make you aware of certain pitfalls that await you if you have just arrived to UNIX® form MS-DOS®. Of course, creative people often break rules, and it is OK as long as they know they are breaking them and why.</p></div></td></tr></tbody></table></div></div></div><div class=sect2><h3 id=x86-acknowledgements>11.15. Acknowledgements<a class=anchor href=#x86-acknowledgements></a></h3><div class=paragraph><p>This tutorial would never have been possible without the help of many experienced FreeBSD programmers from the <a href=https://lists.FreeBSD.org/subscription/freebsd-hackers>FreeBSD technical discussions 郵遞論壇</a>, many of whom have patiently answered my questions, and pointed me in the right direction in my attempts to explore the inner workings of UNIX® system programming in general and FreeBSD in particular.</p></div><div class=paragraph><p>Thomas M. Sommers opened the door for me . His <a href=https://web.archive.org/web/20090914064615/http://www.codebreakers-journal.com/content/view/262/27>How do I write "Hello, world" in FreeBSD assembler?</a> web page was my first encounter with an example of assembly language programming under FreeBSD.</p></div><div class=paragraph><p>Jake Burkholder has kept the door open by willingly answering all of my questions and supplying me with example assembly language source code.</p></div><div class=paragraph><p>Copyright ® 2000-2001 G. Adam Stanislav. All rights reserved.</p></div></div></div></div><h1 id=appendices class=sect0>Part V: Appendices<a class=anchor href=#appendices></a></h1><div class=sect1><h2 id=bibliography>附錄<a class=anchor href=#bibliography></a></h2><div class=sectionbody><div class=paragraph><p><a id=COD></a>[1] Dave A Patterson and John L Hennessy. Copyright® 1998 Morgan Kaufmann Publishers, Inc. 1-55860-428-6. Morgan Kaufmann Publishers, Inc. Computer Organization and Design. The Hardware / Software Interface. 1-2.</p></div><div class=paragraph><p><a id=APUE></a>[2] W. Richard Stevens. Copyright® 1993 Addison Wesley Longman, Inc. 0-201-56317-7. Addison Wesley Longman, Inc. Advanced Programming in the Unix Environment. 1-2.</p></div><div class=paragraph><p><a id=DIFOS></a>[3] Marshall Kirk McKusick and George Neville-Neil. Copyright® 2004 Addison-Wesley. 0-201-70245-2. Addison-Wesley. The Design and Implementation of the FreeBSD Operating System. 1-2.</p></div><div class=paragraph><p><a id=Phrack></a>[4] Aleph One. Phrack 49; "Smashing the Stack for Fun and Profit".</p></div><div class=paragraph><p><a id=StackGuard></a>[5] Chrispin Cowan, Calton Pu, and Dave Maier. StackGuard; Automatic Adaptive Detection and Prevention of Buffer-Overflow Attacks.</p></div><div class=paragraph><p><a id=OpenBSD></a>[6] Todd Miller and Theo de Raadt. strlcpy and strlcat — consistent, safe string copy and concatenation.</p></div></div></div><div id=footnotes><hr><div class=footnote id=_footnotedef_1><a href=#_footnoteref_1>1</a>. They do not use the MAKEFILE form as block capitals are often used for documentation files like README.</div><div class=footnote id=_footnotedef_2><a href=#_footnoteref_2>2</a>. Many Emacs users set their EDITOR environment to emacsclient so this happens every time they need to edit a file.</div></div></div><hr><div class=last-modified><p><strong>最後修改於</strong>: December 11, 2021 由 <a href="https://cgit.freebsd.org/doc/commit/?id=2b027dd017" target=_blank>Sergio Carlavilla Delgado</a></p></div><div class=buttons><div class=home><i class="fa fa-home" aria-hidden=true title=Home></i><div class=container><a href=../ class=direction>Home</a></div></div></div><label class="hidden book-menu-overlay" for=menu-control></label></div><aside class=toc><div class=toc-content><h3>目錄</h3><nav id=TableOfContents><ul><li><a href=#basics>Part I: 基本概念</a><ul><li><a href=#introduction>Chapter 1. 簡介</a></li><li><a href=#tools>Chapter 2. 程式開發工具</a></li><li><a href=#secure>Chapter 3. Secure Programming</a></li><li><a href=#l10n>Chapter 4. Localization and Internationalization - L10N and I18N</a></li><li><a href=#policies>Chapter 5. Source Tree Guidelines and Policies</a></li><li><a href=#testing>Chapter 6. Regression and Performance Testing</a></li></ul></li><li><a href=#ipc>Part II: Interprocess Communication(IPC)</a><ul><li><a href=#sockets>Chapter 7. Sockets</a></li><li><a href=#ipv6>Chapter 8. IPv6 Internals</a></li></ul></li><li><a href=#kernel>Part III: Kernel(核心)</a><ul><li><a href=#kernelbuild>Chapter 9. Building and Installing a FreeBSD Kernel</a></li><li><a href=#kerneldebug>Chapter 10. Kernel Debugging</a></li></ul></li><li><a href=#architectures>Part IV: Architectures(電腦架構)</a><ul><li><a href=#x86>Chapter 11. x86 Assembly Language Programming</a></li></ul></li><li><a href=#appendices>Part V: Appendices</a><ul><li><a href=#bibliography>附錄</a></li></ul></li></ul></nav><hr><div class=resources><h3>資源</h3><ul class=contents><li><i class="fa fa-file-pdf-o" aria-hidden=true title="下載 PDF"></i><a href=https://download.freebsd.org/doc/zh-tw/books/developers-handbook/developers-handbook_zh-tw.pdf>下載 PDF</a></li><li><i class="fa fa-pencil-square-o" aria-hidden=true title=編輯此頁></i><a href=https://github.com/freebsd/freebsd-doc/blob/main/documentation/content/zh-tw/book target=_blank>編輯此頁</a></li></ul></div></div></aside><a class=to-top href=#top><i class="fa fa-arrow-circle-up" aria-hidden=true></i></a></main><footer><div class=footer-container><section class=logo-column><img src=https://docs.freebsd.org/images/FreeBSD-colors.svg width=160 height=50 alt="FreeBSD logo"><div class=options-container><div class=language-container><a id=languages href=https://docs.freebsd.org/zh-tw/languages><img src=https://docs.freebsd.org/images/language.png class=language-image alt=選擇語言>
<span>繁體中文</span></a></div><div class=theme-container><select id=theme-chooser><option value=theme-system>System</option><option value=theme-light>淺色</option><option value=theme-dark>深色</option><option value=theme-high-contrast>高對比</option></select></div></div></section><section class=about-column><h3 class=column-title>About</h3><ul class=column-elements-container><li><a href=https://www.freebsd.org/about/ target=_blank class=column-element>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/ target=_blank class=column-element>FreeBSD Foundation</a></li><li><a href=https://www.freebsd.org/where/ target=_blank class=column-element>Get FreeBSD</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct target=_blank class=column-element>Code of Conduct</a></li><li><a href=https://www.freebsd.org/security/ target=_blank class=column-element>Security Advisories</a></li></ul></section><section class=documentation-column><h3 class=column-title>Documentation</h3><ul class=column-elements-container><li><a href=/zh-tw class=column-element>Documentation portal</a></li><li><a href=https://man.FreeBSD.org target=_blank class=column-element>Manual pages</a></li><li><a href=https://papers.FreeBSD.org target=_blank class=column-element>Presentations and papers</a></li><li><a href=https://docs-archive.freebsd.org/doc/ target=_blank class=column-element>Previous versions</a></li><li><a href=https://docs-archive.freebsd.org/44doc/ target=_blank class=column-element>4.4BSD Documents</a></li><li><a href=https://wiki.freebsd.org/ target=_blank class=column-element>Wiki</a></li></ul></section><section class=community-column><h3 class=column-title>Community</h3><ul class=column-elements-container><li><a href=https://docs.freebsd.org/zh-tw/articles/contributing class=column-element>Get involved</a></li><li><a href=https://forums.freebsd.org/ target=_blank class=column-element>Community forum</a></li><li><a href=https://lists.freebsd.org/ target=_blank class=column-element>Mailing lists</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank class=column-element>IRC Channels</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank class=column-element>Bug Tracker</a></li></ul></section><section class=legal-column><h3 class=column-title>Legal</h3><ul class=column-elements-container><li><a href=https://freebsdfoundation.org/donate/ target=_blank class=column-element>Donations</a></li><li><a href=https://www.freebsd.org/copyright/freebsd-license/ target=_blank class=column-element>Licensing</a></li><li><a href=https://www.freebsd.org/privacy/ target=_blank class=column-element>Privacy Policy</a></li><li><a href=https://www.freebsd.org/copyright/ target=_blank class=column-element>Legal notices</a></li></ul></section><section class=copyright-column><p>&copy; 1994-2024 The FreeBSD Project. All rights reserved</p><span>Made with <span class=heart>♥</span> by the FreeBSD Community</span></section></div></footer></body></html>