<!doctype html><html class=theme-light lang=pt-br><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content><meta name=keywords content><meta name=copyright content="1995-2024 The FreeBSD Foundation"><link rel=canonical href=http://172.16.201.134:1313/pt-br/articles/serial-uart/><title>Tutorial sobre Comunicações Seriais e UART | FreeBSD Documentation Portal</title>
<meta name=theme-color content="#790000"><meta name=color-scheme content="system light dark high-contrast"><link rel="shortcut icon" href=http://172.16.201.134:1313/favicon.ico><link rel=stylesheet href=http://172.16.201.134:1313/styles/main.min.css><link rel=stylesheet href=http://172.16.201.134:1313/css/font-awesome-min.css><script defer src=/js/theme-chooser.min.js></script><script defer src=/js/copy-clipboard.min.js></script><script defer src=/js/search.min.js></script><meta name=twitter:card content="summary"><meta name=twitter:domain content="docs.FreeBSD.org"><meta name=twitter:site content="@freebsd"><meta name=twitter:url content="https://twitter.com/freebsd"><meta property="og:title" content="Tutorial sobre Comunicações Seriais e UART"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:image" content="http://172.16.201.134:1313/favicon.ico"><meta property="og:image:alt" content="FreeBSD Logo"><meta property="og:locale" content="pt-br"><meta property="og:url" content="http://172.16.201.134:1313/pt-br/articles/serial-uart/"><meta property="og:site_name" content="FreeBSD Documentation Portal"><script type=application/ld+json>{"@context":"http://schema.org","@type":"Article","url":"http:\/\/172.16.201.134:1313\/pt-br\/articles\/serial-uart\/","name":"FreeBSD Documentation Portal","headline":"FreeBSD Documentation Portal","description":"FreeBSD Documentation Portal"}</script></head><body><header><div class=header-container><div class=logo-menu-bars-container><a href=https://www.FreeBSD.org class=logo><img src=http://172.16.201.134:1313/images/FreeBSD-monochromatic.svg width=160 height=50 alt="FreeBSD logo">
</a><label class=menu-bars for=menu-bars><i class="fa fa-bars" aria-hidden=true></i></label></div><input id=menu-bars type=checkbox><nav><ul class=menu><li class=menu-item><input id=about type=checkbox>
<a href=# aria-label="Navigate to About section"><label class=menu-item-description for=about>About
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/about/ target=_blank>About</a></li><li><a href=https://www.freebsd.org/about/ target=_blank>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/about-us/about-the-foundation/ target=_blank>FreeBSD Foundation</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct/ target=_blank>Code of Conduct</a></li></ul></li><li class=menu-item><input id=download type=checkbox>
<a href=# aria-label="Navigate to get FreeBSD section"><label class=menu-item-description for=download>Get FreeBSD
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/where/ target=_blank>Get FreeBSD</a></li><li><a href=https://www.freebsd.org/releases/ target=_blank>Release Information</a></li><li><a href=https://www.freebsd.org/releng/ target=_blank>Release Engineering</a></li><li><a href=https://www.freebsd.org/security/ target=_blank>Security Advisories</a></li></ul></li><li class=menu-item><input id=documentation type=checkbox>
<a href=# aria-label="Navigate to get Documentation section"><label class=menu-item-description for=documentation>Documentation
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=/pt-br>Documentation portal</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook>FreeBSD Handbook</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/porters-handbook>Porter's Handbook</a></li><li><a href=https://docs.FreeBSD.org/en/books/fdp-primer>Documentation Project Handbook</a></li><li><a href=https://man.FreeBSD.org target=_blank>Manual pages</a></li><li><a href=https://papers.FreeBSD.org target=_blank>Presentations and papers</a></li><li><a href=https://wiki.FreeBSD.org target=_blank>Wiki</a></li><li><a href=http://172.16.201.134:1313/pt-br/books>Books</a></li><li><a href=http://172.16.201.134:1313/pt-br/articles>Articles</a></li></ul></li><li class=menu-item><input id=community type=checkbox>
<a href=# aria-label="Navigate to get Community section"><label class=menu-item-description for=community>Community
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/community/>Community</a></li><li><a href=http://172.16.201.134:1313/pt-br/articles/contributing>Get involved</a></li><li><a href=https://forums.freebsd.org/ target=_blank>Forum</a></li><li><a href=https://lists.freebsd.org/ target=_blank>Mailing lists</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank>IRC Channels</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank>Bug Tracker</a></li><li><a href=https://www.freebsd.org/support/ target=_blank>Support</a></li></ul></li></ul></nav><div class=search-donate-container><form class=search method=get id=search-header-form action=https://docs.freebsd.org/search name=search-header-form><input type=hidden name=DB value=pt-br>
<input id=words name=P type=text size=20 maxlength=255>
<button>
<i class="fa fa-search" aria-hidden=true></i></button></form><div class=donate><a href=https://freebsdfoundation.org/donate/ target=_blank><span class=heart>♥</span>
Donate</a></div></div></div></header><main class=main-wrapper-article><div class=article><h1 class=title>Tutorial sobre Comunicações Seriais e UART</h1><div class="admonitionblock note"><p><i class="fa fa-exclamation-circle" aria-hidden=true></i>
Esta tradução pode estar desatualizada. Para ajudar com as traduções, acesse a <a href=https://translate-dev.freebsd.org/ target=_blank>ferramenta de traduções do FreeBSD</a>.</p></div><div class=legalnotice><a id=trademarks></a><details><summary>trademarks</summary><p>FreeBSD is a registered trademark of the FreeBSD Foundation.</p><p>Microsoft, IntelliMouse, MS-DOS, Outlook, Windows, Windows Media and Windows NT are either registered trademarks or trademarks of Microsoft Corporation in the United States and/or other countries.</p><p>Many of the designations used by manufacturers and sellers to distinguish their products are claimed as trademarks. Where those designations appear in this document, and the FreeBSD Project was aware of the trademark claim, the designations have been followed by the “™” or the “®” symbol.</p></details></div><div class=toc-mobile><h3>Índice</h3><nav id=TableOfContents><ul><li><a href=#uart>1. A UART: O que é e como funciona</a></li><li><a href=#sio>2. Configurando o driver <span class=filename>sio</span></a></li><li><a href=#cy>3. Configurando o driver <span class=filename>cy</span></a></li><li><a href=#_configurando_o_driver_si>4. Configurando o driver <span class=filename>si</span></a></li></ul></nav></div><div id=preamble><div class=sectionbody><div class="paragraph abstract-title"><p>Resumo</p></div><div class=paragraph><p>Este artigo fala sobre o uso de hardware serial com o FreeBSD.</p></div><hr></div></div><div class=sect1><h2 id=uart>1. A UART: O que é e como funciona<a class=anchor href=#uart></a></h2><div class=sectionbody><div class=paragraph><p><em>Copyright © 1996 Frank Durda IV <a href=mailto:uhclem@FreeBSD.org>uhclem@FreeBSD.org</a>, Todos os direitos reservados. 13 de Janeiro de 1996.</em></p></div><div class=paragraph><p>O controlador UART (Universal Asynchronous Receiver / Transmitter) é o componente chave do subsistema de comunicação serial de um computador. O UART pega bytes de dados e transmite os bits individuais de forma seqüencial. No destino, um segundo UART reúne os bits em bytes completos.</p></div><div class=paragraph><p>A transmissão serial é comumente usada com modems e para comunicação entre computadores, terminais e outros dispositivos sem rede.</p></div><div class=paragraph><p>Existem duas formas primárias de transmissão serial: Síncrona e Assíncrona. Dependendo dos modos suportados pelo hardware, o nome do subsistema de comunicação geralmente incluirá um <code>A</code> se ele suportar comunicações assíncronas, e um <code>S</code> se ele suportar Comunicações síncronas. Ambas as formas são descritas abaixo.</p></div><div class=paragraph><p>Algumas siglas comuns são:</p></div><div class="paragraph blockquote"><p>UART Universal Asynchronous Receiver/Transmitter</p></div><div class="paragraph blockquote"><p>USART Universal Synchronous-Asynchronous Receiver/Transmitter</p></div><div class=sect2><h3 id=_transmissão_serial_síncrona>1.1. Transmissão Serial Síncrona<a class=anchor href=#_transmissão_serial_síncrona></a></h3><div class=paragraph><p>A transmissão serial síncrona requer que o emissor e o receptor compartilhem um clock entre si, ou que o remetente forneça um sinal estroboscópico ou outro sinal de tempo para que o receptor saiba quando deve "ler" o próximo bit dos dados. Na maioria das formas de comunicação serial síncrona, se não houver dados disponíveis em um dado instante para transmitir, um caractere de preenchimento deve ser enviado para que os dados sejam sempre transmitidos. A comunicação síncrona é geralmente mais eficiente, pois somente os bits de dados são transmitidos entre o emissor e o receptor, e a comunicação síncrona pode ser mais cara se fios e circuitos extras forem necessários para compartilhar um sinal de relógio entre o emissor e o receptor.</p></div><div class=paragraph><p>Uma forma de transmissão síncrona é usada com impressoras e dispositivos de disco fixo em que os dados são enviados em um conjunto de fios enquanto um clock ou strobe é enviado em um fio diferente. Impressoras e dispositivos de disco fixo normalmente não são dispositivos seriais porque a maioria dos padrões de interface de disco fixo envia uma palavra inteira de dados para cada sinal de clock ou de strobe usando um fio separado para cada bit da palavra. Na indústria de PCs, esses são conhecidos como dispositivos paralelos.</p></div><div class=paragraph><p>O hardware de comunicação serial padrão no PC não suporta operações síncronas. Este modo é descrito aqui apenas para fins de comparação.</p></div></div><div class=sect2><h3 id=_transmissão_serial_assíncrona>1.2. Transmissão Serial Assíncrona<a class=anchor href=#_transmissão_serial_assíncrona></a></h3><div class=paragraph><p>A transmissão assíncrona permite que os dados sejam transmitidos sem que o emissor tenha que enviar um sinal de relógio ao receptor. Em vez disso, o remetente e o receptor devem concordar com os parâmetros de tempo de antecedência e bits especiais são adicionados a cada palavra, os quais são usados para sincronizar as unidades de envio e recebimento.</p></div><div class=paragraph><p>Quando uma palavra é dada ao UART para uma transmissão assíncrona, um bit chamado "Start Bit" é adicionado ao início de cada palavra que deve ser transmitida. O Start Bit é usado para alertar o receptor de que uma palavra de dados está prestes a ser enviada e para forçar o clock do receptor a sincronizar-se com o clock do transmissor. Estes dois clocks devem ser precisos o suficiente para não ter um desvio de frequência em mais de 10% durante a transmissão dos bits restantes na palavra. (Esse requisito foi definido nos dias das teleimpressoras mecânicas e é facilmente atendido pelos equipamentos eletrônicos modernos.)</p></div><div class=paragraph><p>Após o Start Bit, os bits individuais da palavra de dados são enviados, com o Bit Menos Significativo (LSB) sendo enviado primeiro. Cada bit na transmissão é transmitido exatamente pelo mesmo período de tempo que todos os outros bits, e o receptor "olha" para o fio aproximadamente na metade do período atribuído a cada bit para determinar se o bit é um <code>1</code> ou um <code>0</code>. Por exemplo, se forem necessários dois segundos para enviar cada bit, o receptor examinará o sinal para determinar se é um <code>1</code> ou um <code>0</code> após ter passado um segundo, ele esperará dois segundos e examinará o valor do próximo bit, e assim por diante.</p></div><div class=paragraph><p>O remetente não sabe quando o receptor "olhou" para o valor do bit. O remetente só sabe quando o clock diz para começar a transmitir o próximo bit da palavra.</p></div><div class=paragraph><p>Quando toda a palavra de dados foi enviada, o transmissor pode adicionar um Bit de Paridade que o transmissor gera. O Bit de Paridade pode ser usado pelo receptor para executar uma verificação de erros simples. Então pelo menos um Stop Bit é enviado pelo transmissor.</p></div><div class=paragraph><p>Quando o receptor recebeu todos os bits na palavra de dados, ele pode verificar os bits de paridade (tanto o remetente quanto o receptor devem concordar se um bit de paridade deve ser usado), e então o receptor procura um Stop Bit. Se o Stop Bit não aparecer quando é suposto aparecer, o UART considera a palavra inteira como ilegível e irá relatar um Framing Error para o processador do host quando a palavra de dados é lida. A causa comum de um Framing Error é que os clocks do emissor e do receptor não estavam sendo executados na mesma velocidade ou que o sinal foi interrompido.</p></div><div class=paragraph><p>Independentemente de os dados terem sido recebidos corretamente ou não, o UART descarta automaticamente os Bits de Start, Paridade e Stop. Se o emissor e o receptor forem configurados de forma idêntica, esses bits não serão passados ​​para o host.</p></div><div class=paragraph><p>Se outra palavra estiver pronta para transmissão, o Start Bit da nova palavra pode ser enviado assim que o Stop Bit da palavra anterior for enviado.</p></div><div class=paragraph><p>Como os dados assíncronos são "auto-sincronizados", se não houver dados para transmitir, a linha de transmissão pode ficar inativa.</p></div></div><div class=sect2><h3 id=_outras_funções_uart>1.3. Outras funções UART<a class=anchor href=#_outras_funções_uart></a></h3><div class=paragraph><p>Além do trabalho básico de conversão de dados de paralelo para serial para transmissão e de serial para paralelo na recepção, um UART normalmente fornecerá circuitos adicionais para sinais que podem ser usados ​​para indicar o estado da mídia de transmissão, e para regular o fluxo de dados no caso de o dispositivo remoto não estar preparado para aceitar mais dados. Por exemplo, quando o dispositivo conectado à UART é um modem, o modem pode informar a presença de uma operadora na linha telefônica enquanto o computador pode instruir o modem a reinicializar a si mesmo ou a não atender chamadas, aumentando ou diminuindo mais um desses sinais extras. A função de cada um desses sinais adicionais é definida no padrão EIA RS232-C.</p></div></div><div class=sect2><h3 id=_os_padrões_rs232_c_e_v_24>1.4. Os padrões RS232-C e V.24<a class=anchor href=#_os_padrões_rs232_c_e_v_24></a></h3><div class=paragraph><p>Na maioria dos sistemas de computador, o UART é conectado a um circuito que gera sinais que atendem à especificação EIA RS232-C. Há também um padrão CCITT chamado V.24 que reflete as especificações incluídas no RS232-C.</p></div><div class=sect3><h4 id=_atribuições_de_bit_rs232_c_marcas_e_espaços>1.4.1. Atribuições de bit RS232-C (marcas e espaços)<a class=anchor href=#_atribuições_de_bit_rs232_c_marcas_e_espaços></a></h4><div class=paragraph><p>No RS232-C, um valor de <code>1</code> é chamado de <code>Mark</code> e um valor de <code>0</code> é chamado de <code>Space</code>. Quando uma linha de comunicação está inativa, a linha é chamada de "Marking", ou seja, está transmitindo o valor <code>1</code> continuamente.</p></div><div class=paragraph><p>O bit de início sempre tem um valor de <code>0</code> (um space). O bit de parada sempre tem um valor de <code>1</code> (uma mark). Isso significa que sempre haverá uma transição Mark (1) para Space (0) na linha no início de cada palavra, mesmo quando várias palavras forem transmitidas de volta para trás. Isso garante que o remetente e o destinatário possam ressincronizar seus relógios independentemente do conteúdo dos bits de dados que estão sendo transmitidos.</p></div><div class=paragraph><p>O tempo inativo entre os bits de Stop e Start não precisa ser um múltiplo exato (incluindo zero) da taxa de bits do link de comunicação, mas a maioria dos UARTs é projetada dessa maneira para simplificar.</p></div><div class=paragraph><p>No RS232-C, o sinal "Marking" (a <code>1</code>) é representado por uma tensão entre -2 VDC e -12 VDC, e um sinal "Spacing" (um <code>0</code>) é representado por uma tensão entre 0 e +12 VDC. O transmissor deve enviar +12 VDC ou -12 VCC, e o receptor deve permitir alguma perda de tensão em cabos longos. Alguns transmissores em dispositivos de baixa potência (como computadores portáteis) às vezes usam apenas +5 VCC e -5 VCC, mas esses valores ainda são aceitáveis ​​para um receptor RS232-C, desde que os comprimentos dos cabos sejam curtos.</p></div></div><div class=sect3><h4 id=_sinal_de_quebra_rs232_c>1.4.2. Sinal de quebra RS232-C<a class=anchor href=#_sinal_de_quebra_rs232_c></a></h4><div class=paragraph><p>O RS232-C também especifica um sinal chamado de <code>Break</code> (quebra), que é causado pelo envio de valores contínuos de espaçamento (sem bits de início ou de parada). Quando não há eletricidade presente no circuito de dados, a linha é considerada como enviando um <code>Break</code>.</p></div><div class=paragraph><p>O sinal <code>Break</code> deve ter uma duração maior que o tempo que leva para enviar um byte completo mais os bits Start, Stop e Paridade. A maioria das UARTs pode distinguir entre um Framing Error e um intervalo, mas se a UART não puder fazer isso, a detecção de Framing Error pode ser usada para identificar quebras.</p></div><div class=paragraph><p>Nos dias das teleimpressoras, quando numerosas impressoras em todo o país eram conectadas em série (como serviços de notícias), qualquer unidade poderia causar um <code>Break</code> abrindo temporariamente todo o circuito de modo que nenhuma corrente fluísse. Isso foi usado para permitir que um local com notícias urgentes interrompesse algum outro local que estava enviando informações no momento.</p></div><div class=paragraph><p>Nos sistemas modernos existem dois tipos de sinais de quebra. Se o Break for maior que 1,6 segundos, será considerado um "Modem Break", e alguns modems podem ser programados para encerrar a conversa e colocar no gancho ou entrar no modo de comando dos modems quando o modem detectar este sinal. Se a quebra for menor que 1,6 segundos, significa uma quebra de dados e cabe ao computador remoto responder a esse sinal. Às vezes essa forma de quebra é usada como um sinal de Atenção ou Interrupção e às vezes é aceita como um substituto para o caractere ASCII CONTROL-C.</p></div><div class=paragraph><p>Marcas e espaços também são equivalentes a "furos" e "sem furos" em sistemas de fita de papel.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>As quebras não podem ser geradas a partir da fita de papel ou de qualquer outro valor de byte, uma vez que os bytes são sempre enviados com bit Start e Stop. A UART geralmente é capaz de gerar o sinal de espaçamento contínuo em resposta a um comando especial do processador host.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=_dispositivos_rs232_c_dte_e_dce>1.4.3. Dispositivos RS232-C DTE e DCE<a class=anchor href=#_dispositivos_rs232_c_dte_e_dce></a></h4><div class=paragraph><p>A especificação RS232-C define dois tipos de equipamento: o Data Terminal Equipment (DTE) e o Data Carrier Equipment (DCE). Normalmente, o dispositivo DTE é o terminal (ou computador) e o DCE é um modem. Em toda a linha telefônica, no outro extremo de uma conversa, o modem receptor também é um dispositivo DCE e o computador conectado a esse modem é um dispositivo DTE. O dispositivo DCE recebe sinais nos pinos que o dispositivo DTE transmite e vice-versa.</p></div><div class=paragraph><p>Quando dois dispositivos DTE ou DCE devem ser conectados sem utilizar um modem ou um tradutor de mídia similar entre eles, um modem NULL deve ser usado. O modem NULL reorganiza eletricamente o cabeamento para que a saída do transmissor seja conectada à entrada do receptor no outro dispositivo e vice-versa. Traduções semelhantes são executadas em todos os sinais de controle, de modo que cada dispositivo veja o que acha que são sinais de DCE (ou DTE) do outro dispositivo.</p></div><div class=paragraph><p>O número de sinais gerados pelos dispositivos DTE e DCE não é simétrico. O dispositivo DTE gera menos sinais para o dispositivo DCE do que o dispositivo DTE recebe do DCE.</p></div></div><div class=sect3><h4 id=_atribuições_de_pinos_rs232_c>1.4.4. Atribuições de pinos RS232-C<a class=anchor href=#_atribuições_de_pinos_rs232_c></a></h4><div class=paragraph><p>A especificação EIA RS232-C (e o equivalente ITU, V.24) requer um conector de vinte e cinco pinos (geralmente um DB25) e define a finalidade da maioria dos pinos nesse conector.</p></div><div class=paragraph><p>No IBM Personal Computer e em sistemas semelhantes, um subconjunto de sinais RS232-C é fornecido por meio de conectores de nove pinos (DB9). Os sinais que não estão incluídos no conector do PC lidam principalmente com a operação síncrona, e esse modo de transmissão não é suportado pelo UART que a IBM selecionou para uso no IBM PC.</p></div><div class=paragraph><p>Dependendo do fabricante do computador, um DB25, um DB9 ou ambos os tipos de conectores podem ser usados ​​para comunicações RS232-C. (O IBM PC também usa um conector DB25 para a interface de impressora paralela, o que causa alguma confusão.)</p></div><div class=paragraph><p>Abaixo está uma tabela das atribuições de sinal RS232-C nos conectores DB25 e DB9.</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:14.2857%><col style=width:14.2857%><col style=width:14.2857%><col style=width:14.2857%><col style=width:14.2857%><col style=width:14.2857%><col style=width:14.2858%><thead><tr><th class="tableblock halign-left valign-top">Pinos DB25 RS232-C</th><th class="tableblock halign-left valign-top">Pinos DB9 IBM PC</th><th class="tableblock halign-left valign-top">Símbolo do Circuito EIA</th><th class="tableblock halign-left valign-top">Símbolo do Circuito CCITT</th><th class="tableblock halign-left valign-top">Nome Comum</th><th class="tableblock halign-left valign-top">Fonte de sinal</th><th class="tableblock halign-left valign-top">Descrição</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>1</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>-</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>AA</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>101</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>PG/FG</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>-</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Quadro / aterramento de proteção</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>2</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>3</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>BA</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>103</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>TD</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>DTE</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Transmit Data</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>3</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>2</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>BB</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>104</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>RD</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>DCE</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Receive Data</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>4</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>7</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>CA</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>105</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>RTS</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>DTE</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Request to Send</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>5</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>8</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>CB</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>106</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>CTS</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>DCE</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Clear to Send</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>6</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>6</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>CC</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>107</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>DSR</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>DCE</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Data Set Ready</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>7</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>5</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>AV</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>102</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>SG/GND</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>-</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Signal Ground</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>8</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>1</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>CF</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>109</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>DCD/CD</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>DCE</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Data Carrier Detect</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>9</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>-</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>-</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>-</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>-</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>-</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Reserved for Test</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>10</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>-</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>-</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>-</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>-</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>-</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Reserved for Test</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>11</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>-</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>-</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>-</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>-</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>-</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Reserved for Test</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>12</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>-</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>CI</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>122</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>SRLSD</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>DCE</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Sec. Recv. Line Signal Detector</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>13</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>-</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>SCB</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>121</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>SCTS</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>DCE</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Secondary Clear to Send</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>14</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>-</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>SBA</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>118</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>DST</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>DTE</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Secondary Transmit Data</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>15</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>-</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>DB</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>114</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>TSET</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>DCE</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Trans. Sig. Element Timing</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>16</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>-</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>SBB</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>119</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>SRD</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>DCE</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Secondary Received Data</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>17</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>-</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>DD</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>115</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>RSET</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>DCE</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Receiver Signal Element Timing</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>18</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>-</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>-</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>141</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>LOOP</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>DTE</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Local Loopback</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>19</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>-</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>SCA</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>120</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>SRS</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>DTE</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Secondary Request to Send</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>20</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>4</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>CD</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>108.2</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>DTR</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>DTE</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Data Terminal Ready</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>21</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>-</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>-</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>-</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>RDL</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>DTE</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Remote Digital Loopback</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>22</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>9</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>CE</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>125</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>RI</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>DCE</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Ring Indicator</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>23</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>-</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>CH</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>111</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>DSRS</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>DTE</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Data Signal Rate Selector</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>24</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>-</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>DA</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>113</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>TSET</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>DTE</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Trans. Sig. Element Timing</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>25</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>-</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>-</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>142</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>-</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>DCE</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Test Mode</p></td></tr></tbody></table></div></div><div class=sect2><h3 id=_bits_baud_e_simbolos>1.5. Bits, Baud e Simbolos<a class=anchor href=#_bits_baud_e_simbolos></a></h3><div class=paragraph><p>Baud é uma medida de velocidade de transmissão em comunicação assíncrona. Devido aos avanços na tecnologia de comunicação por modem, esse termo é frequentemente mal utilizado na descrição das taxas de dados em dispositivos mais recentes.</p></div><div class=paragraph><p>Tradicionalmente, uma taxa de transmissão representa o número de bits que estão realmente sendo enviados pela mídia, não a quantidade de dados que é realmente movida de um dispositivo DTE para outro. A contagem de Baud inclui os bits de Start, Stop e Paridade que são gerados pelo UART de envio e removidos pelo UART de recebimento. Isso significa que palavras de dados de sete bits na verdade levam 10 bits para serem completamente transmitidas. Portanto, um modem capaz de mover 300 bits por segundo de um lugar para outro normalmente só pode mover 30 palavras de 7 bits se a Paridade for usada e um bit de Start e Stop estiver presente.</p></div><div class=paragraph><p>Se palavras de dados de 8 bits são usadas e bits de paridade também são usados, a taxa de dados cai para 27,27 palavras por segundo, porque agora leva 11 bits para enviar as palavras de oito bits, e o modem ainda envia apenas 300 bits por segundo.</p></div><div class=paragraph><p>A fórmula para converter bytes por segundo em uma taxa de transmissão e vice-versa era simples até que os modems de correção de erros apareceram. Esses modems recebem o fluxo serial de bits da UART no computador host (mesmo quando os modems internos são usados, os dados ainda são frequentemente serializados) e convertem os bits de volta em bytes. Esses bytes são então combinados em pacotes e enviados pela linha telefônica usando um método de transmissão síncrona. Isso significa que os bits de Stop, Start e Paridade adicionados pelo UART no DTE (o computador) foram removidos pelo modem antes da transmissão pelo modem de envio. Quando esses bytes são recebidos pelo modem remoto, o modem remoto adiciona bits de Start, Stop e paridade às palavras, converte-os em um formato serial e envia-os para o UART receptor no computador remoto, que retira o Start, Stop e bits de paridade.</p></div><div class=paragraph><p>A razão pela qual todas essas conversões extras são feitas é para que os dois modems possam executar a correção de erros, o que significa que o modem receptor pode solicitar ao modem de envio para reenviar um bloco de dados que não foi recebido com a soma de verificação correta. Essa verificação é feita pelos modems, e os dispositivos DTE geralmente não sabem que o processo está ocorrendo.</p></div><div class=paragraph><p>Ao separar os bits de Start, Stop e Paridade, os bits adicionais de dados que os dois modems devem compartilhar entre si para executar a correção de erros são praticamente ocultados da taxa de transmissão efetiva vista pelo equipamento DTE de envio e recebimento. Por exemplo, se um modem enviar dez palavras de 7 bits para outro modem sem incluir os bits Start, Stop e Paridade, o modem de envio poderá adicionar 30 bits de suas próprias informações que o modem receptor pode usar para corrigir erros. sem afetar a velocidade de transmissão dos dados reais.</p></div><div class=paragraph><p>O uso do termo Baud é ainda mais confuso pelos modems que executam compressão. Uma única palavra de 8 bits transmitida pela linha telefônica pode representar uma dúzia de palavras que foram transmitidas para o modem de envio. O modem de recebimento irá expandir os dados de volta ao seu conteúdo original e passar esses dados para o DTE de recebimento.</p></div><div class=paragraph><p>Os modems modernos também incluem buffers que permitem que a taxa na qual os bits se movem pela linha telefônica (do DCE para o DCE) seja uma velocidade diferente da velocidade que os bits se movem entre o DTE e o DCE em ambas as extremidades da conversação. Normalmente, a velocidade entre o DTE e o DCE é maior que a velocidade do DCE para o DCE devido ao uso de compactação pelos modems.</p></div><div class=paragraph><p>Como o número de bits necessários para descrever um byte variou durante a viagem entre as duas máquinas, mais as diferentes velocidades de bits por segundo usadas nos links DTE-DCE e DCE-DCE, o uso do termo Baud para descrever a velocidade geral de comunicação causa problemas e pode deturpar a velocidade real de transmissão. Então Bits Por Segundo (bps) é o termo correto a ser usado para descrever a taxa de transmissão na interface DCE para DCE e Baud ou Bits Por Segundo são termos aceitáveis ​​para uso quando uma conexão é feita entre dois sistemas com uma conexão com fio ou se estiver em uso um modem que não esteja executando correção de erros ou compactação.</p></div><div class=paragraph><p>Os modernos modems de alta velocidade (2400, 9600, 14.400 e 19.200bps) na realidade ainda operam a 2400 ou abaixo de 2400 baud, ou mais precisamente, 2400 símbolos por segundo. O modem de alta velocidade é capaz de codificar mais bits de dados em cada Symbol usando uma técnica chamada Constellation Stuffing, é por isso que a taxa efetiva de bits por segundo do modem é maior, mas o modem continua a operar dentro da largura de banda limitada de áudio que o sistema telefônico fornece. Modems operando a 28.800 e velocidades mais altas têm taxas variáveis ​​de Symbol, mas a técnica é a mesma.</p></div></div><div class=sect2><h3 id=_o_computador_pessoal_ibm_e_o_uart>1.6. O computador pessoal IBM e o UART<a class=anchor href=#_o_computador_pessoal_ibm_e_o_uart></a></h3><div class=paragraph><p>Começando com o IBM Personal Computer original, a IBM selecionou o National Semiconductor INS8250 UART para uso no adaptador IBM PC Paralelo/Serial. Gerações subsequentes de computadores compatíveis da IBM e de outros fornecedores continuaram a usar o INS8250 ou versões aprimoradas da família UART da National Semiconductor.</p></div><div class=sect3><h4 id=_árvore_genealógica_da_national_semiconductor_uart>1.6.1. Árvore Genealógica da National Semiconductor UART<a class=anchor href=#_árvore_genealógica_da_national_semiconductor_uart></a></h4><div class=paragraph><p>Houve várias versões e gerações subseqüentes do INSART50 UART. Cada versão principal está descrita abaixo.</p></div><div class="literalblock programlisting"><div class=content><pre>INS8250  -&gt; INS8250B
  \
   \
    \-&gt; INS8250A -&gt; INS82C50A
             \
              \
               \-&gt; NS16450 -&gt; NS16C450
                        \
                         \
                          \-&gt; NS16550 -&gt; NS16550A -&gt; PC16550D</pre></div></div><div class=dlist><dl><dt class=hdlist1>INS8250</dt><dd><p>Esta parte foi usada no IBM PC original e no IBM PC/XT. O nome original para esta parte era o INS8250 ACE (Elemento de Comunicação Assíncrona) e ele era feito com tecnologia NMOS.</p><div class=paragraph><p>O 8250 usa oito portas de I/O e tem um envio de um byte e um buffer de recebimento de um byte. Esta UART original tem várias "race conditions" e outras falhas. O IBM BIOS original incluia código para contornar essas falhas, mas isso tornava o BIOS dependente das falhas estarem presentes, portanto, componentes subsequentes como o 8250A, 16450 ou 16550 não podiam ser usados no IBM PC original ou no IBM PC/XT.</p></div></dd><dt class=hdlist1>INS8250-B</dt><dd><p>Esta é a velocidade mais lenta do INS8250 feito a partir da tecnologia NMOS. Ele contém os mesmos problemas que o INS8250 original.</p></dd><dt class=hdlist1>INS8250A</dt><dd><p>Uma versão melhorada do INS8250 usando a tecnologia XMOS com várias falhas funcionais corrigidas. O INS8250A foi usado inicialmente em computadores clones de PC por fornecedores que usavam projetos de BIOS "limpos". Devido às correções no chip, este componente não pode ser usado com um BIOS compatível com o INS8250 ou o INS8250B.</p></dd><dt class=hdlist1>INS82C50A</dt><dd><p>Esta é uma versão CMOS (baixo consumo de energia) do INS8250A e possui características funcionais semelhantes.</p></dd><dt class=hdlist1>NS16450</dt><dd><p>O mesmo que o NS8250A com melhorias para que possa ser usado com projetos de barramento de CPU mais rápidos. A IBM usou esse componente no IBM AT e atualizou o IBM BIOS para não depender mais dos erros no INS8250.</p></dd><dt class=hdlist1>NS16C450</dt><dd><p>Esta é uma versão CMOS (baixo consumo de energia) do NS16450.</p></dd><dt class=hdlist1>NS16550</dt><dd><p>O mesmo que NS16450 com um buffer de envio e recebimento de 16 bytes, mas o design do buffer era falho e não podia ser usado com segurança.</p></dd><dt class=hdlist1>NS16550A</dt><dd><p>O mesmo que NS16550 com as falhas de buffer corrigidas. O 16550A e seus sucessores se tornaram o projeto UART mais popular na indústria de PCs, principalmente devido à sua capacidade de lidar de forma confiável com taxas de dados mais altas em sistemas operacionais com tempos de resposta de interrupção lentos.</p></dd><dt class=hdlist1>NS16C552</dt><dd><p>Este componente consiste em dois UARTs CMOS NS16C550A em um único chip.</p></dd><dt class=hdlist1>PC16550D</dt><dd><p>O mesmo que NS16550A com falhas sutis corrigidas. Esta é a revisão D da família 16550 e é o mais recente projeto disponível da National Semiconductor.</p></dd></dl></div></div><div class=sect3><h4 id=_o_ns16550af_e_o_pc16550d_são_a_mesma_coisa>1.6.2. O NS16550AF e o PC16550D são a mesma coisa<a class=anchor href=#_o_ns16550af_e_o_pc16550d_são_a_mesma_coisa></a></h4><div class=paragraph><p>A National reorganizou seu sistema de numeração de peças há alguns anos e o NS16550AFN não existe mais com esse nome. (Se você tiver um NS16550AFN, observe o código de data da peça, que é um número de quatro dígitos que geralmente começa com nove. Os dois primeiros dígitos do número são o ano, e os dois últimos dígitos são a semana do ano em que a peça foi fabricada. Se você tem um NS16550AFN, ele provavelmente tem alguns anos.)</p></div><div class=paragraph><p>Os novos números são como PC16550DV, com pequenas diferenças nas letras de sufixo, dependendo do material da embalagem e sua forma. (Uma descrição do sistema de numeração pode ser encontrada abaixo.)</p></div><div class=paragraph><p>É importante entender que em algumas lojas, você pode pagar US$ 15 por um NS16550AFN fabricado em 1990 e no próximo bin encontrar as novas peças PC16550DN com pequenas correções que o National fez desde que a peça AFN estava em produção, o PC16550DN foi provavelmente feito nos últimos seis meses e custa metade (tão baixo quanto US$ 5 se comprado em volume) do NS16550AFN porque ele está prontamente disponível.</p></div><div class=paragraph><p>Como o fornecimento de chips NS16550AFN continua encolhendo, o preço provavelmente continuará aumentando até que mais pessoas descubram e aceitem que o PC16550DN realmente tem a mesma função que o número de peça antigo.</p></div></div><div class=sect3><h4 id=_sistema_de_numeração_de_peças_da_national_semiconductor>1.6.3. Sistema de Numeração de Peças da National Semiconductor<a class=anchor href=#_sistema_de_numeração_de_peças_da_national_semiconductor></a></h4><div class=paragraph><p>Os números de peça mais antigos NS<em>nnnnnrqp</em> agora são do formato PC<em>nnnnnrgp</em>.</p></div><div class=paragraph><p>O <em>r</em> é o campo de revisão. A revisão atual do 16550 da National Semiconductor é <code>D</code>.</p></div><div class=paragraph><p>O <em>p</em> é o campo que define o tipo de encapsulamento. Os tipos são:</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>"F"</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>QFP</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>(quad flat pack) L lead type</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>"N"</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>DIP</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>(dual inline package) through hole straight lead type</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>"V"</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>LPCC</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>(lead plastic chip carrier) J lead type</p></td></tr></tbody></table><div class=paragraph><p>O <em>g</em> é o campo de classificação do produto. Se um <code>I</code> precede a letra do tipo de encapsulamento, ele indica uma parte de classe "industrial", que possui especificações mais altas que uma parte padrão, mas não tão alta quanto o componente Especificação Militar (Milspec) . Este é um campo opcional.</p></div><div class=paragraph><p>Então, o que costumávamos chamar de NS16550AFN (Pacote DIP) agora é chamado de PC16550DN ou PC16550DIN.</p></div></div></div><div class=sect2><h3 id=_outros_fornecedores_e_uarts_semelhantes>1.7. Outros fornecedores e UARTs semelhantes<a class=anchor href=#_outros_fornecedores_e_uarts_semelhantes></a></h3><div class=paragraph><p>Ao longo dos anos, o 8250, o 8250A, o 16450 e o 16550 foram licenciados ou copiados por outros fornecedores de chips. No caso do 8250, 8250A e 16450, o circuito exato (o "megacell") foi licenciado para muitos fornecedores, incluindo a Western Digital e a Intel. Outros fornecedores realizaram engenharia reversa da peça ou produziram emulações que tiveram comportamento semelhante.</p></div><div class=paragraph><p>Nos modems internos, o projetista de modem freqüentemente emula o 8250A/16450 com o microprocessador de modem, e o UART emulado frequentemente terá um buffer oculto que consiste em várias centenas de bytes. Por causa do tamanho do buffer, essas emulações podem ser tão confiáveis ​​quanto uma 16550A em sua capacidade de lidar com dados de alta velocidade. No entanto, a maioria dos sistemas operacionais ainda relatará que o UART é apenas um 8250A ou 16450, e pode não fazer uso efetivo do buffer extra presente no UART emulado, a menos que drivers especiais sejam usados.</p></div><div class=paragraph><p>Alguns fabricantes de modem são motivados pelas forças do mercado a abandonar um design que possui centenas de bytes de buffer e, em vez disso, usam uma UART 16550A para que o produto compare favoravelmente nas comparações de mercado, embora o desempenho efetivo possa ser reduzido por essa ação.</p></div><div class=paragraph><p>Um equívoco comum é que todas as partes com "16550A" escritas nelas são idênticas no desempenho. Existem diferenças e, em alguns casos, falhas definitivas na maioria desses clones 16550A.</p></div><div class=paragraph><p>Quando o NS16550 foi desenvolvido, a National Semiconductor obteve várias patentes sobre o projeto e também limitou o licenciamento, tornando mais difícil para outros fornecedores fornecer um chip com características semelhantes. Por causa das patentes, projetos de engenharia reversa e emulações tiveram que evitar infringir as reivindicações cobertas pelas patentes. Posteriormente, essas cópias quase nunca funcionam exatamente da mesma forma que a NS16550A ou a PC16550D, que são as peças que a maioria dos fabricantes de computadores e modems deseja comprar, mas às vezes não estão dispostas a pagar o preço necessário para obter a peça genuína.</p></div><div class=paragraph><p>Algumas das diferenças nas peças do clone 16550A não são importantes, enquanto outras podem impedir que o dispositivo seja usado com um determinado sistema operacional ou driver. Essas diferenças podem aparecer ao usar outros drivers ou quando ocorrem determinadas combinações de eventos que não foram bem testadas ou consideradas no driver Windows®. Isso ocorre porque a maioria dos fornecedores de modem e de fabricantes de clones do 16550 usam os drivers da Microsoft do Windows® para Workgroups 3.11 e Microsoft®MS-DOS® como o principal teste de compatibilidade com o NS16550A. Esse critério excessivamente simplista e significa que se um sistema operacional diferente for usado, poderão surgir problemas devido a diferenças sutis entre os clones e os componentes genuínos.</p></div><div class=paragraph><p>A National Semiconductor disponibilizou um programa chamado COMTEST que realiza testes de compatibilidade independentemente de qualquer driver do sistema operacional. Deve ser lembrado que o propósito deste tipo de programa é demonstrar as falhas nos produtos dos concorrentes, de modo que o programa reportará diferenças importantes e extremamente sutis no comportamento da peça que está sendo testada.</p></div><div class=paragraph><p>Em uma série de testes realizados pelo autor deste documento em 1994, componentes fabricados pela National Semiconductor, TI, StarTech e CMD, bem como megacells e emulações incorporadas em modems internos foram testados com o COMTEST. Uma contagem de diferença para alguns desses componentes está listada abaixo. Como esses testes foram realizados em 1994, eles podem não refletir o desempenho atual do produto de um determinado fornecedor.</p></div><div class=paragraph><p>Deve-se notar que o COMTEST normalmente aborta quando um número excessivo ou certos tipos de problemas são detectados. Como parte desse teste, o COMTEST foi modificado para não abortar, independentemente de quantas diferenças fossem encontradas.</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Fornecedor</th><th class="tableblock halign-left valign-top">Número da peça</th><th class="tableblock halign-left valign-top">Erros (também conhecidos como "diferenças")</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>National</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>(PC16550DV)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>0</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>National</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>(NS16550AFN)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>0</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>National</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>(NS16C552V)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>0</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>TI</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>(TL16550AFN)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>3</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>CMD</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>(16C550PE)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>19</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>StarTech</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>(ST16C550J)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>23</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Rockwell</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Modem de referência com 16550 interno ou uma emulação (RC144DPi / C3000-25)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>117</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Sierra</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Modem com um 16550 interno (SC11951/SC11351)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>91</p></td></tr></tbody></table><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Até o momento, o autor deste documento não encontrou nenhuma peça não-National que relate diferença zero usando o programa COMTEST. Também deve ser notado que a National teve cinco versões do 16550 ao longo dos anos e as partes mais novas se comportam de maneira um pouco diferente do NS16550AFN clássico que é considerado o benchmark para funcionalidade. O COMTEST parece fechar os olhos para as diferenças dentro da linha de produto da National e não relata nenhum erro nas peças da National (exceto para o original 16550) mesmo quando há erratas oficiais que descrevem erros nas revisões A, B e C das partes, então este viés no COMTEST deve ser levado em consideração.</p></div></td></tr></tbody></table></div><div class=paragraph><p>É importante entender que uma simples contagem de diferenças do COMTEST não revela muito sobre quais diferenças são importantes e quais não são. Por exemplo, cerca de metade das diferenças relatadas nos dois modems listados acima que têm UARTs internas foram causadas pelos clones UARTs que não suportam modos de caractere de cinco e seis bits. Todos os UARTs 16550, 16450 e 8250 reais suportam esses modos e o COMTEST verifica a funcionalidade desses modos, de modo que mais de cinquenta diferenças são relatadas. No entanto, quase nenhum modem moderno suporta caracteres de cinco ou seis bits, particularmente aqueles com recursos de correção de erros e compressão. Isso significa que as diferenças relacionadas aos modos de caractere de cinco e seis bits podem ser desconsideradas.</p></div><div class=paragraph><p>Muitas das diferenças que o COMTEST reporta têm a ver com o tempo. Em muitos projetos de clones, quando o host lê de uma porta, os bits de status em alguma outra porta podem não ser atualizados na mesma quantidade de tempo (alguns mais rápidos, alguns mais lentos) que um NS16550AFN <em>real</em> e o COMTEST procura por essas diferenças. Isso significa que o número de diferenças pode ser enganoso, pois um dispositivo pode ter apenas uma ou duas diferenças, mas elas serem extremamente sérias, e algum outro dispositivo que atualiza o status de registro mais rápido ou mais devagar que a peça de referência (que provavelmente nunca afetaria o operação de um driver devidamente escrito) poderia ter dezenas de diferenças relatadas.</p></div><div class=paragraph><p>O COMTEST pode ser usado como uma ferramenta de triagem para alertar o administrador sobre a presença de componentes potencialmente incompatíveis que podem causar problemas ou que precisam ser tratados como um caso especial.</p></div><div class=paragraph><p>Se você executar o COMTEST em um 16550 que esteja em um modem ou se um modem estiver conectado à porta serial, será necessário primeiro emitir um comando ATE0&amp;W para o modem para que o modem não faça eco de nenhum dos caracteres de teste. Se você esquecer de fazer isso, o COMTEST informará pelo menos essa diferença:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Error <span class=o>(</span>6<span class=o>)</span>...Timeout interrupt failed: IIR <span class=o>=</span> c1  LSR <span class=o>=</span> 61</code></pre></div></div></div><div class=sect2><h3 id=_registradores_82501645016550>1.8. Registradores 8250/16450/16550<a class=anchor href=#_registradores_82501645016550></a></h3><div class=paragraph><p>O UART 8250/16450/16550 ocupa oito endereços contíguos de porta de I/O. No IBM PC, há dois locais definidos para essas oito portas e eles são conhecidos coletivamente como <span class=filename>COM1</span> e <span class=filename>COM2</span>. Os fabricantes de PC-clones e placas adicionais criaram duas áreas adicionais conhecidas como <span class=filename>COM3</span> e <span class=filename>COM4</span>, mas essas portas COM extras entram em conflito com outro hardware em alguns sistemas. O conflito mais comum é com adaptadores de vídeo que fornecem emulação IBM 8514.</p></div><div class=paragraph><p>A <span class=filename>COM1</span> está localizada de 0x3f8 a 0x3ff e normalmente usa o IRQ 4. A <span class=filename>COM2</span> está localizada de 0x2f8 a 0x2ff e normalmente usa IRQ 3. A <span class=filename>COM3</span> está localizada de 0x3e8 a 0x3ef e não tem IRQ padronizado. A <span class=filename>COM4</span> está localizada de 0x2e8 a 0x2ef e não tem IRQ padronizado.</p></div><div class=paragraph><p>Uma descrição das portas I/O da UART 8250/16450/16550 é fornecida abaixo.</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:10%><col style=width:10%><col style=width:80%><thead><tr><th class="tableblock halign-left valign-top">Porta I/O</th><th class="tableblock halign-left valign-top">Acesso permitido</th><th class="tableblock halign-left valign-top">Descrição</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>+0x00</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>write (DLAB==0)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Transmit Holding Register (THR).</p><p class=tableblock>As informações gravadas nessa porta são tratadas como palavras de dados e serão transmitidas pela UART.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>+0x00</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>read (DLAB==0)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Receive Buffer Register (RBR).</p><p class=tableblock>Quaisquer palavras de dados recebidas pelo UART a partir do link serial são acessadas pelo host lendo esta porta.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>+0x00</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>write/read (DLAB==1)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Divisor Latch LSB (DLL)</p><p class=tableblock>Este valor será dividido a partir do clock de entrada principal (no IBM PC, o clock principal é 1.8432MHz) e o clock resultante determinará a taxa de transmissão do UART. Este registrador contém os bits de 0 a 7 do divisor.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>+0x01</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>write/read (DLAB==1)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Divisor Latch MSB (DLH)</p><p class=tableblock>Este valor será dividido a partir do clock de entrada principal (no IBM PC, o clock principal é 1.8432MHz) e o clock resultante determinará a taxa de transmissão do UART. Este registrador contém os bits 8 a 15 do divisor.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>+0x01</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>write/read (DLAB==0)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Interrupt Enable Register (IER)<br></p><p class=tableblock>A UART 8250/16450/16550 classifica os eventos em uma de quatro categorias. Cada categoria pode ser configurada para gerar uma interrupção quando qualquer um dos eventos ocorrer. A UART 8250/16450/16550 gera um único sinal de interrupção externa, independentemente de quantos eventos nas categorias ativadas ocorreram. Cabe ao processador host responder à interrupção e depois pesquisar as categorias de interrupção ativadas (geralmente todas as categorias têm interrupções ativadas) para determinar a(s) causa(s) verdadeira(s) da interrupção.<br>Bit 7 → Reserved, always 0.<br>Bit 6 → Reserved, always 0.<br>Bit 5 → Reserved, always 0.<br>Bit 4 → Reserved, always 0.<br>Bit 3 → Ativa o Modem Status Interrupt (EDSSI). Definir esse bit como "1" permite que o UART gere uma interrupção quando ocorrer uma alteração em uma ou mais das linhas de status.<br>Bit 2 → Ativa a interrupção de status da linha receptora (ELSI) Configurar este bit como "1" faz com que o UART gere uma interrupção quando um erro (ou um sinal BREAK) for detectado nos dados de entrada.<br>Bit 1 → Ativa a Interrupção Vazia do Registro de Holding do Transmissor (ETBEI) Configurar este bit como "1" faz com que o UART gere uma interrupção quando o UART tiver espaço para um ou mais caracteres adicionais que serão transmitidos.<br>Bit 0 → Ativar a Interrupção Disponível de Dados Recebidos (ERBFI) Configurar este bit para "1" faz com que o UART gere uma interrupção quando o UART tiver recebido caracteres suficientes para exceder o nível de disparo do FIFO, ou o temporizador FIFO tiver expirado (dados antigos) ou um único caractere tiver sido recebido quando o FIFO está desativado.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>+0x02</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>write</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Registro de Controle FIFO (FCR) (Esta porta não existe no UART 8250 e 16450).<br>Bit 7 → Receiver Trigger Bit #1<br>Bit 6 → Trigger do Receptor Bit #0<br></p><p class=tableblock>Esses dois bits controlam em que ponto o receptor deve gerar uma interrupção quando o FIFO está ativo.<br>7 6 Quantas palavras são recebidas antes que uma interrupção seja gerada<br>0 0 1<br>0 1 4<br>1 0 8<br>1 1 14<br>Bit 5 → Reserved, always 0.<br>Bit 4 → Reserved, always 0.<br>Bit 3 → DMA Mode Select. Se o Bit 0 for ajustado para "1" (FIFOs habilitado), a configuração deste bit altera a operação dos sinais -RXRDY e -TXRDY do Modo 0 para o Modo 1.<br>Bit 2 → Transmit FIFO Reset. Quando um "1" é gravado neste bit, o conteúdo do FIFO é descartado. Qualquer palavra atualmente sendo transmitida será enviada intacta. Esta função é útil para anular transferências.<br>Bit 1 → Receiver FIFO Reset. Quando um "1" é gravado neste bit, o conteúdo do FIFO é descartado. Qualquer palavra atualmente montada no registrador de turno será recebida intacta.<br>Bit 0 → 16550 FIFO Enable. Quando configurado, os FIFOs de transmissão e recepção estão ativados. Qualquer conteúdo no registro de espera, registradores de deslocamento ou FIFOs são perdidos quando as FIFOs são ativadas ou desativadas.<br></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>+0x02</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>read</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Registro de identificação de interrupção<br>Bit 7 → FIFOs habilitado. No 8250/16450 UART, esse bit é zero.<br>Bit 6 → FIFOs habilitado. No 8250/16450 UART, esse bit é zero.<br>Bit 5 → Reserved, always 0.<br>Bit 4 → Reserved, always 0.<br>Bit 3 → ID de Interrupção Bit #2. No 8250/16450 UART, esse bit é zero.<br>Bit 2 → ID de Interrupção Bit #1<br>Bit 1 → ID de Interrupção Bit #0.Esses três bits se combinam para relatar a categoria de evento que causou a interrupção que está em andamento. Essas categorias têm prioridades, portanto, se várias categorias de eventos ocorrerem ao mesmo tempo, a UART relatará os eventos mais importantes primeiro e o host precisará resolver os eventos na ordem em que forem relatados. Todos os eventos que causaram a interrupção atual devem ser resolvidos antes que novas interrupções sejam geradas. (Esta é uma limitação da arquitetura do PC.)<br>2 1 0 Prioridade Descrição<br>0 1 1 Primeiro Received Error (OE, PE, BI, or FE)<br>0 1 0 Segundo Dados Recebidos Disponíveis<br>1 1 0 Segundo Identificação do nível de gatilho (dados obsoletos no buffer de recebimento)<br>0 0 1 Terceiro Transmissor tem espaço para mais palavras (THRE)<br>0 0 0 Quarto Alteração de status do modem (-CTS, -DSR, -RI ou -DCD)<br>Bit 0 → Interromper Bit Pendente. Se este bit estiver definido como "0", pelo menos uma interrupção está pendente.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>+0x03</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>write/read</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Registro de Controle de Linha (LCR)<br>Bit 7 → Divisor Latch Access Bit (DLAB). Quando configurado, o acesso ao registro de transmissão / recepção de dados (THR / RBR) e ao Registro de Ativação de Interrupção (ITA) é desabilitado. Qualquer acesso a essas portas é agora redirecionado para os Registradores de Latch do Divisor. Definir esse bit, carregar os Registradores do Divisor e limpar o DLAB deve ser feito com as interrupções desativadas.<br>Bit 6 → Set Break. Quando definido para "1", o transmissor começa a transmitir espaçamento contínuo até que este bit seja definido como "0". Isso substitui todos os bits de caracteres que estão sendo transmitidos.<br>Bit 5 → Paridade da varStick Parity. Quando a paridade está ativada, a configuração desse bit faz com que a paridade seja sempre "1" ou "0", com base no valor do Bit 4.
Bit 4 → Even Parity Select (EPS). Quando a paridade é ativada e o bit 5 é "0", a configuração desse bit faz com que a paridade par seja transmitida e esperada. Caso contrário, a paridade ímpar é usada.<br>Bit 3 → Parity Enable (PEN). Quando definido para "1", um bit de paridade é inserido entre o último bit dos dados e o bit de Stop. A UART também espera que a paridade esteja presente nos dados recebidos.<br>Bit 2 → Number of Stop Bits (STB). Se definido como "1" e usando palavras de dados de 5 bits, 1.5 bits de parada são transmitidos e esperados em cada palavra de dados. Para palavras de dados de 6, 7 e 8 bits, 2 Stop Bits são transmitidos e esperados. Quando este bit é definido como "0", um bit de parada é usado em cada palavra de dados.<br>Bit 1 → Comprimento de palavra selecione bit #1 (WLSB1)<br>Bit 0 → Comprimento de palavra selecione bit #0 (WLSB0)<br>Juntos, esses bits especificam o número de bits em cada palavra de dados.<br>1 0 Comprimento da palavra<br>0 0 5 bits de dados<br>0 1 6 bits de dados<br>1 0 7 bits de dados<br>1 1 8 bits de dados<br></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>+0x04</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>write/read</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Registro de Controle de Modem (MCR)<br>Bit 7 → Reserved, always 0.<br>Bit 6 → Reserved, always 0.<br>Bit 5 → Reserved, always 0.<br>Bit 4 → Loop-Back Enable. Quando definido para "1", o transmissor e o receptor UART são conectados internamente para permitir operações de diagnóstico. Além disso, as saídas de controle do modem UART são conectadas às entradas de controle do modem UART. O CTS está conectado a RTS, o DTR está conectado a DSR, o OUT1 está conectado a RI e o OUT 2 está conectado a DCD.<br>Bit 3 → OUT 2. É uma saída auxiliar que o processador host pode definir como alta ou baixa. No adaptador serial IBM PC (e na maioria dos clones), OUT 2 é usado para triestar (desabilitar) o sinal de interrupção do UART 8250/16450/16550.<br>Bit 2 → OUT 1. É uma saída auxiliar que o processador host pode definir como alta ou baixa. Essa saída não é usada no adaptador serial IBM PC.<br>Bit 1 → Solicitação para enviar (RTS). Quando definido para "1", a saída da linha UART-RTS é Baixa (Ativo).<br>Bit 0 → Data Terminal Ready (DTR). Quando definido para "1", a saída da linha UART-DTR é baixa (ativa).<br></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>+0x05</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>write/read</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Registro de status de linha (LSR)<br>Bit 7 → Error in Receiver FIFO. No UART 8250/16450, esse bit é zero. Esse bit é definido como "1" quando qualquer um dos bytes no FIFO tem uma ou mais das seguintes condições de erro: PE, FE ou BI.<br>Bit 6 → Transmitter Empty (TEMT). Quando definido para "1", não há palavras restantes no FIFO de transmissão ou no registrador de deslocamento de transmissão. O transmissor está completamente ocioso.<br>Bit 5 → Transmissor Holding Register Empty (THRE). Quando definido para "1", o FIFO (ou registrador de retenção) agora tem espaço para pelo menos uma palavra adicional para transmitir. O transmissor ainda pode estar transmitindo quando este bit está definido para "1".<br>Bit 4 → Break Interrupt (BI). O receptor detectou um sinal de Break.<br>Bit 3 → Framing Error (FE). Um Bit de Início foi detectado, mas o Bit de Stop não apareceu no horário esperado. A palavra recebida é provavelmente truncada.<br>Bit 2 → Parity Error (PE). O bit de paridade estava incorreto para a palavra recebida.<br>Bit 1 → Overrun Error (OE). Uma nova palavra foi recebida e não havia espaço no buffer de recebimento. A palavra recém-chegada no registrador de deslocamento é descartada. Nos UARTs 8250/16450, a palavra no registro de retenção é descartada e a palavra recém-chegada é colocada no registro de retenção.<br>Bit 0 → Data Ready (DR). Uma ou mais palavras estão no FIFO de recepção que o host pode ler. Uma palavra deve ser completamente recebida e movida do registrador de deslocamento para o FIFO (ou registrador de sustentação para desenhos do 8250/16450) antes que este bit seja definido.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>+0x06</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>write/read</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Registro de status de modem (MSR)<br>Bit 7 → Data Carrier Detect (DCD). Reflete o estado da linha DCD no UART.<br>Bit 6 → Indicador de anel (RI). Reflete o estado da linha RI no UART.<br>Bit 5 → Conjunto de dados pronto (DSR). Reflete o estado da linha DSR no UART.<br>Bit 4 → Limpar para enviar (CTS). Reflete o estado da linha CTS no UART.<br>Bit 3 → Delta Data Carrier Detect (DDCD). Defina para "1" se a linha -DCD mudou de estado mais uma vez desde a última vez em que o MSR foi lido pelo host.<br>Bit 2 → Trailing Edge Ring Indicator (TERI). Defina para "1" se a linha -RI teve uma transição baixa para alta desde a última vez em que o MSR foi lido pelo host.<br>Bit 1 → Delta Data Set Ready (DDSR). Defina para "1" se a linha -DSR mudou de estado mais uma vez desde a última vez em que o MSR foi lido pelo host.<br>Bit 0 → Delta Clear To Send (DCTS). Defina para "1" se a linha -CTS mudou de estado mais uma vez desde a última vez em que o MSR foi lido pelo host.<br></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>+0x07</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>write/read</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Scratch Register (SCR). Este registro não executa nenhuma função no UART. Qualquer valor pode ser gravado pelo host para este local e lido pelo host mais tarde.</p></td></tr></tbody></table></div><div class=sect2><h3 id=_além_do_uart_16550a>1.9. Além do UART 16550A<a class=anchor href=#_além_do_uart_16550a></a></h3><div class=paragraph><p>Embora a National Semiconductor não tenha oferecido nenhum componente compatível com o 16550 que forneça recursos adicionais, vários outros fornecedores oferecem. Alguns desses componentes são descritos abaixo. Deve ser entendido que para utilizar efetivamente essas melhorias, os drivers podem ter que ser fornecidos pelo fornecedor do chip, já que a maioria dos sistemas operacionais populares não suportam recursos além daqueles fornecidos pelo 16550.</p></div><div class=dlist><dl><dt class=hdlist1>ST16650</dt><dd><p>Por padrão, essa peça é semelhante ao NS16550A, mas um buffer de envio e recebimento de 32 bytes estendido pode ser opcionalmente ativado. Fabricado pela StarTech.</p></dd><dt class=hdlist1>TIL16660</dt><dd><p>Por padrão, essa peça se comporta de maneira semelhante ao NS16550A, mas um buffer de envio e recebimento de 64 bytes estendido pode ser opcionalmente ativado. Fabricado pela Texas Instruments.</p></dd><dt class=hdlist1>Hayes ESP</dt><dd><p>Esta placa plug-in proprietária contém um buffer de envio e recebimento de 2048 bytes e suporta taxas de dados de até 230,4 Kbit/s. Fabricada pela Hayes.</p></dd></dl></div><div class=paragraph><p>Além desses UARTs "dumb", muitos fornecedores produzem placas de comunicação serial inteligentes. Esse tipo de design geralmente fornece um microprocessador que faz interface com vários UARTs, processa e armazena os dados em buffer e, em seguida, alerta o processador principal do PC quando necessário. Como os UARTs não são acessados ​​diretamente pelo processador do PC nesse tipo de sistema de comunicação, não é necessário que o fornecedor use UARTs compatíveis com o UART 8250, 16450 ou 16550. Isso deixa o designer livre para usar componentes que tenham melhores características de desempenho.</p></div></div></div></div><div class=sect1><h2 id=sio>2. Configurando o driver <span class=filename>sio</span><a class=anchor href=#sio></a></h2><div class=sectionbody><div class=paragraph><p>O driver <span class=filename>sio</span> fornece suporte para interfaces de comunicação EIA RS-232C (CCITT V.24) baseadas em NS8250-, NS16450-, NS16550 e NS16550A. Várias placas multiportas também são suportadas. Consulte a página de manual <a href="https://man.freebsd.org/cgi/man.cgi?query=sio&amp;sektion=4&amp;format=html">sio(4)</a> para obter documentação técnica detalhada.</p></div><div class=sect2><h3 id=_digi_international_digiboard_pc8>2.1. Digi International (DigiBoard) PC/8<a class=anchor href=#_digi_international_digiboard_pc8></a></h3><div class=paragraph><p><em>Contribuição de Andrew Webster <a href=mailto:awebster@pubnix.net>awebster@pubnix.net</a>. 26 de agosto de 1995.</em></p></div><div class=paragraph><p>Aqui está um trecho de configuração de uma máquina com uma placa Digi International PC/8 com 16550. Ela tem 8 modems conectados a essas 8 linhas e eles funcionam muito bem. Não se esqueça de adicionar <code>options COM_MULTIPORT</code> ao seu kernel ou ela não funcionará muito bem!</p></div><div class="literalblock programlisting"><div class=content><pre>device          sio4    at isa? port 0x100 flags 0xb05
device          sio5    at isa? port 0x108 flags 0xb05
device          sio6    at isa? port 0x110 flags 0xb05
device          sio7    at isa? port 0x118 flags 0xb05
device          sio8    at isa? port 0x120 flags 0xb05
device          sio9    at isa? port 0x128 flags 0xb05
device          sio10   at isa? port 0x130 flags 0xb05
device          sio11   at isa? port 0x138 flags 0xb05 irq 9</pre></div></div><div class=paragraph><p>O truque para configurá-la é que o MSB dos flags representa a última porta SIO, neste caso 11, então as flags são 0xb05.</p></div></div><div class=sect2><h3 id=_boca_16>2.2. Boca 16<a class=anchor href=#_boca_16></a></h3><div class=paragraph><p><em>Contribuição de Don Whiteside <a href=mailto:whiteside@acm.org>whiteside@acm.org</a>. 26 de agosto de 1995.</em></p></div><div class=paragraph><p>Os procedimentos para fazer uma placa multiporta Boca 16 funcionar com o FreeBSD são bastante diretos, mas você precisará de algumas coisas para fazê-la funcionar:</p></div><div class="olist arabic"><ol class=arabic><li><p>Você precisa do código fonte do kernel instalado para poder recompilar as opções necessárias ou precisará de alguém para compilá-las para você. O kernel padrão 2.0.5 <em>não</em> vem com suporte a múltiplas portas ativado e você precisará adicionar uma entrada de dispositivo para cada porta de qualquer maneira.</p></li><li><p>Dois, você precisará saber a configuração de interrupção e de I/O da sua placa Boca para que você possa definir essas opções corretamente no kernel.</p></li></ol></div><div class=paragraph><p>Uma nota importante - os chips UART reais para a Boca 16 estão nos conectores, não na própria placa interna. Então, se você os tiver desconectado, os probes destas portas falharão. Eu nunca testei a inicialização com a caixa desconectada e conectando-a novamente, e sugiro que você também não o faça.</p></div><div class=paragraph><p>Se você ainda não tiver um arquivo de configuração de kernel personalizado, consulte o capitulo <a href=https://docs.freebsd.org/pt-br/books/handbook/book//#kernelconfig>Configuração do Kernel</a> no Handbook do FreeBSD para os procedimentos gerais. A seguir estão as especificações para a placa Boca 16 e supõe-se que você esteja usando o nome do kernel MYKERNEL e editando com o vi.</p></div><div class="olist arabic procedure"><ol class=arabic><li><p>Adicione a linha</p><div class="literalblock programlisting"><div class=content><pre>options COM_MULTIPORT</pre></div></div><div class=paragraph><p>ao arquivo de configuração.</p></div></li><li><p>Onde as linhas atuais do dispositivo <code>device sio<em>n</em></code> estão, você precisará adicionar mais 16 dispositivos. O exemplo a seguir é para uma placa Boca com uma interrupção de 3 e um endereço de IO base de 100h. O endereço IO para cada porta é +8 hexadecimal da porta anterior, portanto, os endereços são 100h, 108h, 110h …​.</p><div class="literalblock programlisting"><div class=content><pre>device sio1 at isa? port 0x100 flags 0x1005
device sio2 at isa? port 0x108 flags 0x1005
device sio3 at isa? port 0x110 flags 0x1005
device sio4 at isa? port 0x118 flags 0x1005
…
device sio15 at isa? port 0x170 flags 0x1005
device sio16 at isa? port 0x178 flags 0x1005 irq 3</pre></div></div><div class=paragraph><p>A entrada de flags <em>deve</em> ser alterada deste exemplo, a menos que você esteja usando exatamente as mesmas atribuições de sio. As sinalizações são definidas de acordo com 0x<code><em>MYY</em></code> onde <em>M</em> indica o número menor da porta principal (a última porta em uma Boca 16) e <em>YY</em> indica se o FIFO está ativado ou desativado (ativado), o compartilhamento de IRQ é usado (sim) e se há um registro de controle de IRQ compatível com AST/4 (não). Neste exemplo,</p></div><div class="literalblock programlisting"><div class=content><pre> flags
	      0x1005</pre></div></div><div class=paragraph><p>indica que a porta principal é a sio16. Se eu adicionasse outra placa e atribuísse do sio17 até sio28, os sinalizadores para todas as 16 portas <em>nesta</em> placa seriam 0x1C05, onde 1C indica o menor número da porta principal. Não altere a configuração 05.</p></div></li><li><p>Salve e complete a configuração do kernel, recompile, instale e reinicialize. Presumindo que você tenha instalado com sucesso o kernel recompilado e configurado para o endereço e IRQ correto, sua mensagem de boot deve indicar o teste bem-sucedido das portas Boca da seguinte forma: (obviamente os números sio, IO e IRQ podem ser diferentes)</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>sio1 at 0x100-0x107 flags 0x1005 on isa
sio1: <span class=nb>type </span>16550A <span class=o>(</span>multiport<span class=o>)</span>
sio2 at 0x108-0x10f flags 0x1005 on isa
sio2: <span class=nb>type </span>16550A <span class=o>(</span>multiport<span class=o>)</span>
sio3 at 0x110-0x117 flags 0x1005 on isa
sio3: <span class=nb>type </span>16550A <span class=o>(</span>multiport<span class=o>)</span>
sio4 at 0x118-0x11f flags 0x1005 on isa
sio4: <span class=nb>type </span>16550A <span class=o>(</span>multiport<span class=o>)</span>
sio5 at 0x120-0x127 flags 0x1005 on isa
sio5: <span class=nb>type </span>16550A <span class=o>(</span>multiport<span class=o>)</span>
sio6 at 0x128-0x12f flags 0x1005 on isa
sio6: <span class=nb>type </span>16550A <span class=o>(</span>multiport<span class=o>)</span>
sio7 at 0x130-0x137 flags 0x1005 on isa
sio7: <span class=nb>type </span>16550A <span class=o>(</span>multiport<span class=o>)</span>
sio8 at 0x138-0x13f flags 0x1005 on isa
sio8: <span class=nb>type </span>16550A <span class=o>(</span>multiport<span class=o>)</span>
sio9 at 0x140-0x147 flags 0x1005 on isa
sio9: <span class=nb>type </span>16550A <span class=o>(</span>multiport<span class=o>)</span>
sio10 at 0x148-0x14f flags 0x1005 on isa
sio10: <span class=nb>type </span>16550A <span class=o>(</span>multiport<span class=o>)</span>
sio11 at 0x150-0x157 flags 0x1005 on isa
sio11: <span class=nb>type </span>16550A <span class=o>(</span>multiport<span class=o>)</span>
sio12 at 0x158-0x15f flags 0x1005 on isa
sio12: <span class=nb>type </span>16550A <span class=o>(</span>multiport<span class=o>)</span>
sio13 at 0x160-0x167 flags 0x1005 on isa
sio13: <span class=nb>type </span>16550A <span class=o>(</span>multiport<span class=o>)</span>
sio14 at 0x168-0x16f flags 0x1005 on isa
sio14: <span class=nb>type </span>16550A <span class=o>(</span>multiport<span class=o>)</span>
sio15 at 0x170-0x177 flags 0x1005 on isa
sio15: <span class=nb>type </span>16550A <span class=o>(</span>multiport<span class=o>)</span>
sio16 at 0x178-0x17f irq 3 flags 0x1005 on isa
sio16: <span class=nb>type </span>16550A <span class=o>(</span>multiport master<span class=o>)</span></code></pre></div></div><div class=paragraph><p>Se as mensagens forem muito rápidas para serem visualizadas,</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dmesg | more</span></code></pre></div></div><div class=paragraph><p>mostrará as mensagens de inicialização.</p></div></li><li><p>Em seguida, as entradas apropriadas em <span class=filename>/dev</span> para os dispositivos devem ser criadas usando o script <span class=filename>/dev/MAKEDEV</span>. Esta etapa pode ser omitida se você estiver executando o FreeBSD 5.X com um kernel que tenha sido compilado com o suporte ao <a href="https://man.freebsd.org/cgi/man.cgi?query=devfs&amp;sektion=5&amp;format=html">devfs(5)</a>.</p><div class=paragraph><p>Se você precisar criar as entradas <span class=filename>/dev</span>, execute o seguinte como <code>root</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /dev</span>
<span class=c># ./MAKEDEV tty1</span>
<span class=c># ./MAKEDEV cua1</span>
<span class=o>(</span>everything <span class=k>in </span>between<span class=o>)</span>
<span class=c># ./MAKEDEV ttyg</span>
<span class=c># ./MAKEDEV cuag</span></code></pre></div></div><div class=paragraph><p>Se você não quiser ou precisar de dispositivos de chamada por algum motivo, você pode dispensar o uso dos dispositivos <span class=filename>cua*</span>.</p></div></li><li><p>Se você quiser uma maneira rápida e desleixada de se certificar de que os dispositivos estão funcionando, você pode simplesmente conectar um modem em cada porta e (como root)</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># echo at &gt; ttyd*</span></code></pre></div></div><div class=paragraph><p>para cada dispositivo que você fez. Você <em>deve</em> ver as luzes RX piscando para cada porta em funcionamento.</p></div></li></ol></div></div><div class=sect2><h3 id=_suporte_para_cartões_multi_uart_baratos>2.3. Suporte para cartões Multi-UART baratos<a class=anchor href=#_suporte_para_cartões_multi_uart_baratos></a></h3><div class=paragraph><p><em>Contribuição de Helge Oldach <a href=mailto:hmo@sep.hamburg.com>hmo@sep.hamburg.com</a>, setembro de 1999</em></p></div><div class=paragraph><p>Já se perguntou se o FreeBSD suporta a sua placa multi-I/O de US$ 20 com duas (ou mais) portas COM, compartilhando IRQs? Aqui está como:</p></div><div class=paragraph><p>Normalmente, a única opção para suportar esse tipo de placa é usar um IRQ distinto para cada porta. Por exemplo, se a placa da CPU tiver uma porta <span class=filename>COM1</span> integrada (também conhecida como <span class=filename>sio0</span> - endereço de I/O 0x3F8 e IRQ 4) e você tiver uma placa de extensão com dois UARTs , você normalmente precisará configurá-los como <span class=filename>COM2</span> (também conhecido como <span class=filename>sio1</span> - endereço de I/O 0x2F8 e IRQ 3) e a terceira porta (também conhecida como <span class=filename>sio2</span>) como I/O 0x3E8 e IRQ 5. Obviamente, isso é um desperdício de recursos de IRQ, já que deve ser basicamente possível executar ambas as portas da placa de extensão usando um único IRQ com a configuração <code>COM_MULTIPORT</code> descrita nas seções anteriores.</p></div><div class=paragraph><p>Essas placas de I/O baratas geralmente têm uma matriz de jumpers de 4 por 3 para as portas COM, semelhante à seguinte:</p></div><div class="literalblock programlisting"><div class=content><pre>            o  o  o  *
Port A               |
            o  *  o  *
Port B         |
            o  *  o  o
IRQ         2  3  4  5</pre></div></div><div class=paragraph><p>É mostrada aqui a porta A com fiação para IRQ 5 e a porta B com fiação para IRQ 3. As colunas de IRQ em sua placa específica podem variar - outras placas podem fornecer jumpers para IRQs 3, 4, 5 e 7.</p></div><div class=paragraph><p>Pode-se concluir que a fiação de ambas as portas para o IRQ 3 usando um jumper feito a mão e feito à mão cobrindo todos os três pontos de conexão na coluna IRQ 3 resolveria o problema, mas não. Você não pode duplicar o IRQ 3 porque os drivers de saída de cada UART estão conectados de forma "totem pole", portanto, se um dos UARTs ativar o IRQ 3, o sinal de saída não será o esperado. Dependendo da implementação da placa de extensão ou da placa-mãe, a linha IRQ 3 permanecerá sempre ativa ou sempre baixa.</p></div><div class=paragraph><p>Você precisa separar os drivers de IRQ para as duas UARTs, de modo que a linha IRQ da placa só suba se (e somente se) uma das UARTs ativar uma IRQ e permanecendo abaixo de outra forma. A solução foi proposta por Joerg Wunsch <a href=mailto:j@ida.interface-business.de>j@ida.interface-business.de</a>: Soldar um cabo - ou consistindo de dois diodos (de Germânio ou do tipo-Schottky são fortemente preferidos) e um resistor de 1 kOhm. Aqui está o esquema, a partir do campo de jumper 4 por 3 acima:</p></div><div class="literalblock programlisting"><div class=content><pre>                          Diode
                +----------&gt;|-------+
               /                    |
            o  *  o  o              |     1 kOhm
Port A                              +----|######|-------+
            o  *  o  o              |                   |
Port B          `-------------------+                 ==+==
            o  *  o  o              |                 Ground
                \                   |
                 +---------&gt;|-------+
IRQ         2  3  4  5    Diode</pre></div></div><div class=paragraph><p>Os cátodos dos diodos estão conectados a um ponto comum, junto com um resistor de 1 kOhm. É essencial conectar o resistor ao terra para evitar a flutuação da linha IRQ no barramento.</p></div><div class=paragraph><p>Agora estamos prontos para configurar um kernel. Ficando com este exemplo, nós configuraríamos:</p></div><div class="literalblock programlisting"><div class=content><pre># standard on-board COM1 port
device          sio0    at isa? port &#34;IO_COM1&#34; flags 0x10
# patched-up multi-I/O extension board
options         COM_MULTIPORT
device          sio1    at isa? port &#34;IO_COM2&#34; flags 0x205
device          sio2    at isa? port &#34;IO_COM3&#34; flags 0x205 irq 3</pre></div></div><div class=paragraph><p>Note que a configuração das <code>flags</code> para <span class=filename>sio1</span> e <span class=filename>sio2</span> é realmente essencial; consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=sio&amp;sektion=4&amp;format=html">sio(4)</a> para detalhes. (Geralmente, o <code>2</code> no atributo "flags" refere-se ao <span class=filename>sio2</span> que contém o IRQ, e você certamente deseja um "nibble" abaixo de <code>5</code>. ) Com o modo verboso do kernel ativado, isso deve render algo semelhante a isto:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>sio0: irq maps: 0x1 0x11 0x1 0x1
sio0 at 0x3f8-0x3ff irq 4 flags 0x10 on isa
sio0: <span class=nb>type </span>16550A
sio1: irq maps: 0x1 0x9 0x1 0x1
sio1 at 0x2f8-0x2ff flags 0x205 on isa
sio1: <span class=nb>type </span>16550A <span class=o>(</span>multiport<span class=o>)</span>
sio2: irq maps: 0x1 0x9 0x1 0x1
sio2 at 0x3e8-0x3ef irq 3 flags 0x205 on isa
sio2: <span class=nb>type </span>16550A <span class=o>(</span>multiport master<span class=o>)</span></code></pre></div></div><div class=paragraph><p>Embora o <span class=filename>/sys/i386/isa/sio.c</span> seja um pouco enigmático com o uso do array "irq maps" acima, a ideia básica é que você observe <code>0x1</code> no primeiro, terceiro e quarto lugar. Isso significa que o IRQ correspondente foi definido na saída e limpo depois, o que é exatamente o que esperaríamos. Se o seu kernel não exibir esse comportamento, provavelmente há algo errado com a sua fiação.</p></div></div></div></div><div class=sect1><h2 id=cy>3. Configurando o driver <span class=filename>cy</span><a class=anchor href=#cy></a></h2><div class=sectionbody><div class=paragraph><p><em>Contribuição de Alex Nash. 6 de Junho de 1996.</em></p></div><div class=paragraph><p>As placas multiseriais da Cyclades são baseadas no driver <span class=filename>cy</span> em vez do driver usual <span class=filename>sio</span> usado por outras placas multiseriais. Configuração é uma simples questão de:</p></div><div class="olist arabic procedure"><ol class=arabic><li><p>Adicione o dispositivo <span class=filename>cy</span> à sua configuração do kernel (observe que suas configurações irq e iomem podem ser diferentes).</p><div class="literalblock programlisting"><div class=content><pre>device cy0 at isa? irq 10 iomem 0xd4000 iosiz 0x2000</pre></div></div></li><li><p>Recompile e instale o novo kernel.</p></li><li><p>Crie os device nodes digitando (o exemplo a seguir assume uma placa de 8 portas) <sup class=footnote>[<a id=_footnoteref_1 class=footnote href=#_footnotedef_1 title="View footnote.">1</a>]</sup>:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /dev</span>
<span class=c># for i in 0 1 2 3 4 5 6 7;do ./MAKEDEV cuac$i ttyc$i;done</span></code></pre></div></div></li><li><p>Se apropriado, adicione entradas de discagem ao <span class=filename>/etc/ttys</span> duplicando as entradas dos dispositivos seriais (<code>ttyd</code>) e usando <code>ttyc</code> no lugar de <code>ttyd</code>. Por exemplo:</p><div class="literalblock programlisting"><div class=content><pre>ttyc0   &#34;/usr/libexec/getty std.38400&#34;  unknown on insecure
ttyc1   &#34;/usr/libexec/getty std.38400&#34;  unknown on insecure
ttyc2   &#34;/usr/libexec/getty std.38400&#34;  unknown on insecure
…
ttyc7   &#34;/usr/libexec/getty std.38400&#34;  unknown on insecure</pre></div></div></li><li><p>Reinicie com o novo kernel.</p></li></ol></div></div></div><div class=sect1><h2 id=_configurando_o_driver_si>4. Configurando o driver <span class=filename>si</span><a class=anchor href=#_configurando_o_driver_si></a></h2><div class=sectionbody><div class=paragraph><p><em>Contribuição de Nick Sayer <a href=mailto:nsayer@FreeBSD.org>nsayer@FreeBSD.org</a>. 25 de Março de 1998.</em></p></div><div class=paragraph><p>As placas multiportas Specialix SI/XIO e SX usam o driver <span class=filename>si</span>. Uma única máquina pode ter até 4 placas host. As seguintes placas host são suportadas:</p></div><div class=ulist><ul><li><p>ISA SI/XIO host card (2 versions)</p></li><li><p>EISA SI/XIO host card</p></li><li><p>PCI SI/XIO host card</p></li><li><p>ISA SX host card</p></li><li><p>PCI SX host card</p></li></ul></div><div class=paragraph><p>Embora as placas host SX e SI/XIO pareçam marcadamente diferentes, sua funcionalidade é basicamente a mesma. Os cartões de host não usam locais de I/O, mas exigem um bloco de memória de 32K. A configuração de fábrica para cartões ISA coloca isso em <code>0xd0000-0xd7fff</code>. Elas também exigem um IRQ. As placas PCI, é claro, se configuram automaticamente.</p></div><div class=paragraph><p>Você pode anexar até 4 módulos externos a cada placa de host. Os módulos externos contêm 4 ou 8 portas seriais. Eles vêm nas seguintes variedades:</p></div><div class=ulist><ul><li><p>Módulos de portas SI 4 ou 8. Até 57600 bps em cada porta suportada.</p></li><li><p>Módulos de porta XIO 8. Até 115.200 bps em cada porta suportada. Um tipo de módulo XIO possui 7 portas seriais e 1 porta paralela.</p></li><li><p>Módulos de porta SXDC 8. Até 921.600 bps em cada porta suportada. Tal como no XIO, um módulo está disponível com uma porta paralela também.</p></li></ul></div><div class=paragraph><p>Para configurar uma placa de host ISA, adicione a seguinte linha ao seu arquivo de configuração do kernel, alterando os números conforme apropriado:</p></div><div class="literalblock programlisting"><div class=content><pre>device si0 at isa? iomem 0xd0000 irq 11</pre></div></div><div class=paragraph><p>Números de IRQ válidos são 9, 10, 11, 12 e 15 para placas host SX ISA e 11, 12 e 15 para placas host ISA/XIO ISA.</p></div><div class=paragraph><p>Para configurar uma placa de host EISA ou PCI, use esta linha:</p></div><div class="literalblock programlisting"><div class=content><pre>device si0</pre></div></div><div class=paragraph><p>Depois de adicionar a entrada de configuração, recompile e instale seu novo kernel.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>A etapa seguinte, não é necessária se você estiver usando o <a href="https://man.freebsd.org/cgi/man.cgi?query=devfs&amp;sektion=5&amp;format=html">devfs(5)</a> no FreeBSD 5.<em>X</em>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Após a reinicialização com o novo kernel, você precisa criar os device nodes no <span class=filename>/dev</span>. O script <span class=filename>MAKEDEV</span> cuidará disso para você. Conte quantas portas totais você tem e digite:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /dev</span>
<span class=c># ./MAKEDEV ttyAnn cuaAnn</span></code></pre></div></div><div class=paragraph><p>(no qual <em>nn</em> é o número de portas)</p></div><div class=paragraph><p>Se você quiser que as solicitações de login apareçam nessas portas, você precisará adicionar linhas como esta para <span class=filename>/etc/ttys</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>ttyA01  &#34;/usr/libexec/getty std.9600&#34;   vt100   on insecure</pre></div></div><div class=paragraph><p>Altere o tipo de terminal conforme apropriado. Para modems, <code>dialup</code> ou <code>unknown</code> está bem.</p></div></div></div><div id=footnotes><hr><div class=footnote id=_footnotedef_1><a href=#_footnoteref_1>1</a>. Você pode omitir esta parte se você estiver executando o FreeBSD 5.X com devfs5.</div></div><hr><div class=last-modified><p><strong>Última alteração em</strong>: 3 de novembro de 2021 por <a href="https://cgit.freebsd.org/doc/commit/?id=64acd169b8" target=_blank>Sergio Carlavilla Delgado</a></p></div></div><aside class=toc><div class=toc-content><h3>Índice</h3><nav id=TableOfContents><ul><li><a href=#uart>1. A UART: O que é e como funciona</a></li><li><a href=#sio>2. Configurando o driver <span class=filename>sio</span></a></li><li><a href=#cy>3. Configurando o driver <span class=filename>cy</span></a></li><li><a href=#_configurando_o_driver_si>4. Configurando o driver <span class=filename>si</span></a></li></ul></nav><hr><div class=resources><h3>Recursos</h3><ul class=contents><li><i class="fa fa-file-pdf-o" aria-hidden=true title="Download PDF"></i><a href=https://download.freebsd.org/doc/pt-br/articles/serial-uart/serial-uart_pt-br.pdf>Download PDF</a></li><li><i class="fa fa-pencil-square-o" aria-hidden=true title="Edite essa página"></i><a href=https://github.com/freebsd/freebsd-doc/blob/main/documentation/content/pt-br/_index target=_blank>Edite essa página</a></li></ul></div></div></aside></main><footer><div class=footer-container><section class=logo-column><img src=http://172.16.201.134:1313/images/FreeBSD-colors.svg width=160 height=50 alt="FreeBSD logo"><div class=options-container><div class=language-container><a id=languages href=http://172.16.201.134:1313/pt-br/languages><img src=http://172.16.201.134:1313/images/language.png class=language-image alt="Escolha o idioma">
<span>Brazilian Portuguese</span></a></div><div class=theme-container><select id=theme-chooser><option value=theme-system>System</option><option value=theme-light>Light</option><option value=theme-dark>Dark</option><option value=theme-high-contrast>Alto contraste</option></select></div></div></section><section class=about-column><h3 class=column-title>About</h3><ul class=column-elements-container><li><a href=https://www.freebsd.org/about/ target=_blank class=column-element>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/ target=_blank class=column-element>FreeBSD Foundation</a></li><li><a href=https://www.freebsd.org/where/ target=_blank class=column-element>Get FreeBSD</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct target=_blank class=column-element>Code of Conduct</a></li><li><a href=https://www.freebsd.org/security/ target=_blank class=column-element>Security Advisories</a></li></ul></section><section class=documentation-column><h3 class=column-title>Documentation</h3><ul class=column-elements-container><li><a href=/pt-br class=column-element>Documentation portal</a></li><li><a href=https://man.FreeBSD.org target=_blank class=column-element>Manual pages</a></li><li><a href=https://papers.FreeBSD.org target=_blank class=column-element>Presentations and papers</a></li><li><a href=https://docs-archive.freebsd.org/doc/ target=_blank class=column-element>Previous versions</a></li><li><a href=https://docs-archive.freebsd.org/44doc/ target=_blank class=column-element>4.4BSD Documents</a></li><li><a href=https://wiki.freebsd.org/ target=_blank class=column-element>Wiki</a></li></ul></section><section class=community-column><h3 class=column-title>Community</h3><ul class=column-elements-container><li><a href=http://172.16.201.134:1313/pt-br/articles/contributing class=column-element>Get involved</a></li><li><a href=https://forums.freebsd.org/ target=_blank class=column-element>Community forum</a></li><li><a href=https://lists.freebsd.org/ target=_blank class=column-element>Mailing lists</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank class=column-element>IRC Channels</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank class=column-element>Bug Tracker</a></li></ul></section><section class=legal-column><h3 class=column-title>Legal</h3><ul class=column-elements-container><li><a href=https://freebsdfoundation.org/donate/ target=_blank class=column-element>Donations</a></li><li><a href=https://www.freebsd.org/copyright/freebsd-license/ target=_blank class=column-element>Licensing</a></li><li><a href=https://www.freebsd.org/privacy/ target=_blank class=column-element>Privacy Policy</a></li><li><a href=https://www.freebsd.org/copyright/ target=_blank class=column-element>Legal notices</a></li></ul></section><section class=copyright-column><p>&copy; 1994-2024 The FreeBSD Project. All rights reserved</p><span>Made with <span class=heart>♥</span> by the FreeBSD Community</span></section></div></footer></body></html>