<!doctype html><html class=theme-light lang=pt-br><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Um guia para escrever novos scripts rc.d e entender aqueles que já existem"><meta name=keywords content="rc.d,scripting,guide,tutorial,FreeBSD"><meta name=copyright content="1995-2024 The FreeBSD Foundation"><link rel=canonical href=https://docs.freebsd.org/pt-br/articles/rc-scripting/><title>Scripting rc.d na prática no BSD | FreeBSD Documentation Portal</title>
<meta name=theme-color content="#790000"><meta name=color-scheme content="system light dark high-contrast"><link rel="shortcut icon" href=https://docs.freebsd.org/favicon.ico><link rel=stylesheet href=https://docs.freebsd.org/styles/main.min.css><link rel=stylesheet href=https://docs.freebsd.org/css/font-awesome-min.css><script defer src=/js/theme-chooser.min.js></script><script defer src=/js/copy-clipboard.min.js></script><script defer src=/js/search.min.js></script><meta name=twitter:card content="summary"><meta name=twitter:domain content="docs.FreeBSD.org"><meta name=twitter:site content="@freebsd"><meta name=twitter:url content="https://twitter.com/freebsd"><meta property="og:title" content="Scripting rc.d na prática no BSD"><meta property="og:description" content="Um guia para escrever novos scripts rc.d e entender aqueles que já existem"><meta property="og:type" content="website"><meta property="og:image" content="https://docs.freebsd.org/favicon.ico"><meta property="og:image:alt" content="FreeBSD Logo"><meta property="og:locale" content="pt-br"><meta property="og:url" content="https://docs.freebsd.org/pt-br/articles/rc-scripting/"><meta property="og:site_name" content="FreeBSD Documentation Portal"><script type=application/ld+json>{"@context":"http://schema.org","@type":"Article","url":"https:\/\/docs.freebsd.org\/pt-br\/articles\/rc-scripting\/","name":"FreeBSD Documentation Portal","headline":"FreeBSD Documentation Portal","description":"FreeBSD Documentation Portal"}</script></head><body><header><div class=header-container><div class=logo-menu-bars-container><a href=https://www.FreeBSD.org class=logo><img src=https://docs.freebsd.org/images/FreeBSD-monochromatic.svg width=160 height=50 alt="FreeBSD logo">
</a><label class=menu-bars for=menu-bars><i class="fa fa-bars" aria-hidden=true></i></label></div><input id=menu-bars type=checkbox><nav><ul class=menu><li class=menu-item><input id=about type=checkbox>
<a href=# aria-label="Navigate to About section"><label class=menu-item-description for=about>About
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/about/ target=_blank>About</a></li><li><a href=https://www.freebsd.org/about/ target=_blank>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/about-us/about-the-foundation/ target=_blank>FreeBSD Foundation</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct/ target=_blank>Code of Conduct</a></li></ul></li><li class=menu-item><input id=download type=checkbox>
<a href=# aria-label="Navigate to get FreeBSD section"><label class=menu-item-description for=download>Get FreeBSD
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/where/ target=_blank>Get FreeBSD</a></li><li><a href=https://www.freebsd.org/releases/ target=_blank>Release Information</a></li><li><a href=https://www.freebsd.org/releng/ target=_blank>Release Engineering</a></li><li><a href=https://www.freebsd.org/security/ target=_blank>Security Advisories</a></li></ul></li><li class=menu-item><input id=documentation type=checkbox>
<a href=# aria-label="Navigate to get Documentation section"><label class=menu-item-description for=documentation>Documentation
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=/pt-br>Documentation portal</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook>FreeBSD Handbook</a></li><li><a href=https://docs.freebsd.org/pt-br/books/porters-handbook>Porter's Handbook</a></li><li><a href=https://docs.FreeBSD.org/en/books/fdp-primer>Documentation Project Handbook</a></li><li><a href=https://man.FreeBSD.org target=_blank>Manual pages</a></li><li><a href=https://papers.FreeBSD.org target=_blank>Presentations and papers</a></li><li><a href=https://wiki.FreeBSD.org target=_blank>Wiki</a></li><li><a href=https://docs.freebsd.org/pt-br/books>Books</a></li><li><a href=https://docs.freebsd.org/pt-br/articles>Articles</a></li></ul></li><li class=menu-item><input id=community type=checkbox>
<a href=# aria-label="Navigate to get Community section"><label class=menu-item-description for=community>Community
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/community/>Community</a></li><li><a href=https://docs.freebsd.org/pt-br/articles/contributing>Get involved</a></li><li><a href=https://forums.freebsd.org/ target=_blank>Forum</a></li><li><a href=https://lists.freebsd.org/ target=_blank>Mailing lists</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank>IRC Channels</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank>Bug Tracker</a></li><li><a href=https://www.freebsd.org/support/ target=_blank>Support</a></li></ul></li></ul></nav><div class=search-donate-container><form class=search method=get id=search-header-form action=https://docs.freebsd.org/search name=search-header-form><input type=hidden name=DB value=pt-br>
<input id=words name=P type=text size=20 maxlength=255>
<button>
<i class="fa fa-search" aria-hidden=true></i></button></form><div class=donate><a href=https://freebsdfoundation.org/donate/ target=_blank><span class=heart>♥</span>
Donate</a></div></div></div></header><main class=main-wrapper-article><div class=article><h1 class=title>Scripting rc.d na prática no BSD</h1><div class="admonitionblock note"><p><i class="fa fa-exclamation-circle" aria-hidden=true></i>
Esta tradução pode estar desatualizada. Para ajudar com as traduções, acesse a <a href=https://translate-dev.freebsd.org/ target=_blank>ferramenta de traduções do FreeBSD</a>.</p></div><div class=copyright>Copyright © 2005-2006, 2012 The FreeBSD Project</div><div class=legalnotice><a id=trademarks></a><details><summary>trademarks</summary><p>FreeBSD is a registered trademark of the FreeBSD Foundation.</p><p>NetBSD is a registered trademark of the NetBSD Foundation.</p><p>Many of the designations used by manufacturers and sellers to distinguish their products are claimed as trademarks. Where those designations appear in this document, and the FreeBSD Project was aware of the trademark claim, the designations have been followed by the “™” or the “®” symbol.</p></details></div><div class=toc-mobile><h3>Índice</h3><nav id=TableOfContents><ul><li><a href=#rcng-intro>1. Introdução</a></li><li><a href=#rcng-task>2. Esboçando a tarefa</a></li><li><a href=#rcng-dummy>3. Um script fictício</a></li><li><a href=#rcng-confdummy>4. Um script fictício configurável</a></li><li><a href=#rcng-daemon>5. Inicialização e desligamento de um daemon simples</a></li><li><a href=#rcng-daemon-adv>6. Inicialização e desligamento de um daemon avançado</a></li><li><a href=#rcng-hookup>7. Conectando um script ao framework rc.d</a></li><li><a href=#rcng-args>8. Dando mais flexibilidade a um script rc.d</a></li><li><a href=#rcng-furthur>9. Leitura adicional</a></li></ul></nav></div><div id=preamble><div class=sectionbody><div class="paragraph abstract-title"><p>Resumo</p></div><div class=paragraph><p>Os iniciantes podem achar difícil relacionar os fatos da documentação formal sobre o framework <span class=filename>rc.d</span> do BSD com as tarefas práticas de escrever scripts <span class=filename>rc.d</span>. Neste artigo, consideramos alguns casos típicos de crescente complexidade, mostramos recursos do <span class=filename>rc.d</span> adequados para cada caso e discutimos como eles funcionam. Essa análise deve fornecer pontos de referência para estudos posteriores do design e aplicação eficiente do <span class=filename>rc.d</span>.</p></div><hr></div></div><div class=sect1><h2 id=rcng-intro>1. Introdução<a class=anchor href=#rcng-intro></a></h2><div class=sectionbody><div class=paragraph><p>No histórico BSD, havia um script de inicialização monolítico, <span class=filename>/etc/rc</span>. Ele era invocado pelo <a href="https://man.freebsd.org/cgi/man.cgi?query=init&amp;sektion=8&amp;format=html">init(8)</a> no momento da inicialização do sistema e realizava todas as tarefas de usuário necessárias para a operação multiusuário: verificação e montagem de sistemas de arquivos, configuração da rede, inicialização de daemons e assim por diante. A lista precisa de tarefas não era a mesma em todos os sistemas; os administradores precisavam personalizá-la. Com poucas exceções, o <span class=filename>/etc/rc</span> tinha que ser modificado, e os verdadeiros hackers gostavam disso.</p></div><div class=paragraph><p>O problema real com a abordagem monolítica era que ela não fornecia controle sobre os componentes individuais iniciados a partir do <span class=filename>/etc/rc</span>. Por exemplo, o <span class=filename>/etc/rc</span> não podia reiniciar um único daemon. O administrador do sistema tinha que encontrar o processo do daemon manualmente, matá-lo, aguardar até que ele realmente finalizasse, navegar por <span class=filename>/etc/rc</span> em busca das flags e, finalmente, digitar a linha de comando completa para iniciar o daemon novamente. A tarefa se tornaria ainda mais difícil e propensa a erros se o serviço a ser reiniciado consistisse em mais de um daemon ou exigisse ações adicionais. Em poucas palavras, o script único falhou em cumprir o objetivo pelo qual um script é criado: tornar a vida do administrador do sistema mais fácil.</p></div><div class=paragraph><p>Mais tarde, houve uma tentativa de dividir algumas partes do <span class=filename>/etc/rc</span> para iniciar os subsistemas mais importantes separadamente. O exemplo notório foi o <span class=filename>/etc/netstart</span> para iniciar a rede. Isso permitiu o acesso à rede no modo de usuário único, mas não se integrou bem ao processo de inicialização automática porque partes de seu código precisavam intercalar com ações essencialmente não relacionadas à rede. Foi por isso que o <span class=filename>/etc/netstart</span> se transformou em <span class=filename>/etc/rc.network</span>. Este último não era mais um script comum; era composto de grandes funções <a href="https://man.freebsd.org/cgi/man.cgi?query=sh&amp;sektion=1&amp;format=html">sh(1)</a> complexas chamadas pelo <span class=filename>/etc/rc</span> em diferentes estágios da inicialização do sistema. No entanto, à medida que as tarefas de inicialização ficaram mais diversas e sofisticadas, a abordagem "quase modular" tornou-se ainda mais pesada do que o monolítico <span class=filename>/etc/rc</span> tinha sido.</p></div><div class=paragraph><p>Sem um framework limpo e bem projetado, os scripts de inicialização tiveram que se dobrar para atender às necessidades dos sistemas operacionais baseados em BSD que estavam em rápida evolução. Tornou-se evidente, finalmente, que mais etapas eram necessárias para se chegar a um sistema <span class=filename>rc</span> refinado, granular e extensível. Assim nasceu o <span class=filename>rc.d</span> do BSD. Seus pais reconhecidos foram Luke Mewburn e a comunidade NetBSD. Mais tarde, foi importado para o FreeBSD. Seu nome se refere ao local dos scripts do sistema para serviços individuais, que está em <span class=filename>/etc/rc.d</span>. Em breve, aprenderemos mais sobre os componentes do sistema <span class=filename>rc.d</span> e veremos como os scripts individuais são invocados.</p></div><div class=paragraph><p>As ideias básicas por trás do <span class=filename>rc.d</span> do BSD são <em>modularidade fina</em> e <em>reutilização de código</em>. <em>Modularidade fina</em> significa que cada "serviço" básico, como um daemon do sistema ou uma tarefa de inicialização primitiva, possui seu próprio script <a href="https://man.freebsd.org/cgi/man.cgi?query=sh&amp;sektion=1&amp;format=html">sh(1)</a> capaz de iniciar o serviço, pará-lo, recarregá-lo e verificar seu status. Uma ação específica é escolhida pelo argumento da linha de comando do script. O script <span class=filename>/etc/rc</span> ainda conduz a inicialização do sistema, mas agora ele apenas invoca os scripts menores um por um com o argumento <code>start</code>. Também é fácil realizar tarefas de desligamento executando o mesmo conjunto de scripts com o argumento <code>stop</code>, que é feito por <span class=filename>/etc/rc.shutdown</span>. Observe como isso segue de perto a maneira Unix de ter um conjunto de ferramentas especializadas pequenas, cada uma cumprindo sua tarefa da melhor maneira possível. <em>Reutilização de código</em> significa que operações comuns são implementadas como funções <a href="https://man.freebsd.org/cgi/man.cgi?query=sh&amp;sektion=1&amp;format=html">sh(1)</a> e coletadas em <span class=filename>/etc/rc.subr</span>. Agora, um script típico pode ser composto apenas de algumas linhas de código <a href="https://man.freebsd.org/cgi/man.cgi?query=sh&amp;sektion=1&amp;format=html">sh(1)</a>. Finalmente, uma parte importante do framework <span class=filename>rc.d</span> é o <a href="https://man.freebsd.org/cgi/man.cgi?query=rcorder&amp;sektion=8&amp;format=html">rcorder(8)</a>, que ajuda o <span class=filename>/etc/rc</span> a executar os pequenos scripts de maneira ordenada com respeito às dependências entre eles. Isso também pode ajudar o <span class=filename>/etc/rc.shutdown</span>, porque a ordem apropriada para a sequência de desligamento é oposta à de inicialização.</p></div><div class=paragraph><p>O design do BSD <span class=filename>rc.d</span> é descrito no <a href=#lukem>artigo original de Luke Mewburn</a>, e os componentes do <span class=filename>rc.d</span> são documentados em grande detalhe nas <a href=#manpages>respectivas páginas do manual</a>. No entanto, pode não ser óbvio para um iniciante no <span class=filename>rc.d</span> como ele deve unir as numerosas partes para criar um script bem estruturado para uma tarefa específica. Portanto, este artigo tentará abordar o <span class=filename>rc.d</span> de forma diferente. Mostrará quais recursos devem ser usados em vários casos típicos e por que. Observe que este não é um documento de "como fazer", porque nosso objetivo não é fornecer receitas prontas, mas mostrar algumas entradas fáceis no mundo do <span class=filename>rc.d</span>. Este artigo também não substitui as páginas do manual relevantes. Não hesite em consultá-las para obter documentação mais formal e completa enquanto lê este artigo.</p></div><div class=paragraph><p>Existem pré-requisitos para entender este artigo. Em primeiro lugar, você deve estar familiarizado com a linguagem de script <a href="https://man.freebsd.org/cgi/man.cgi?query=sh&amp;sektion=1&amp;format=html">sh(1)</a> para dominar o <span class=filename>rc.d</span>. Além disso, você deve saber como o sistema realiza tarefas de inicialização e desligamento do espaço do usuário, o que é descrito em <a href="https://man.freebsd.org/cgi/man.cgi?query=rc&amp;sektion=8&amp;format=html">rc(8)</a>.</p></div><div class=paragraph><p>Este artigo foca no ramo do FreeBSD do <span class=filename>rc.d</span>. No entanto, ele pode ser útil também para desenvolvedores do NetBSD, pois os dois ramos do <span class=filename>rc.d</span> não apenas compartilham o mesmo design, mas também permanecem similares em seus aspectos visíveis aos autores de scripts.</p></div></div></div><div class=sect1><h2 id=rcng-task>2. Esboçando a tarefa<a class=anchor href=#rcng-task></a></h2><div class=sectionbody><div class=paragraph><p>Uma pequena reflexão antes de iniciar o <code>$EDITOR</code> não fará mal. Para escrever um script <span class=filename>rc.d</span> bem elaborado para um serviço do sistema, devemos ser capazes de responder às seguintes perguntas primeiro:</p></div><div class=ulist><ul><li><p>O serviço é obrigatório ou opcional?</p></li><li><p>O script servirá um único programa, por exemplo, um daemon, ou realizará ações mais complexas?</p></li><li><p>De quais outros serviços nosso serviço dependerá e vice-versa?</p></li></ul></div><div class=paragraph><p>A partir dos exemplos que se seguem, veremos o porque é importante conhecer as respostas a essas perguntas.</p></div></div></div><div class=sect1><h2 id=rcng-dummy>3. Um script fictício<a class=anchor href=#rcng-dummy></a></h2><div class=sectionbody><div class=paragraph><p>O script a seguir apenas emite uma mensagem toda vez que o sistema é inicializado:</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh <i class=conum data-value=1></i><b>(1)</b>

. /etc/rc.subr <i class=conum data-value=2></i><b>(2)</b>

name=&#34;dummy&#34; <i class=conum data-value=3></i><b>(3)</b>
start_cmd=&#34;${name}_start&#34; <i class=conum data-value=4></i><b>(4)</b>
stop_cmd=&#34;:&#34; <i class=conum data-value=5></i><b>(5)</b>

dummy_start() <i class=conum data-value=6></i><b>(6)</b>
{
	echo &#34;Nothing started.&#34;
}

load_rc_config $name <i class=conum data-value=7></i><b>(7)</b>
run_rc_command &#34;$1&#34; <i class=conum data-value=8></i><b>(8)</b></pre></div></div><div class=paragraph><p>Os pontos a serem observados são:</p></div><div class=paragraph><p>➊ Um script interpretado deve começar com a linha mágica "shebang". Essa linha especifica o programa interpretador para o script. Devido à linha shebang, o script pode ser invocado exatamente como um programa binário, desde que tenha o bit de execução definido. (Veja <a href="https://man.freebsd.org/cgi/man.cgi?query=chmod&amp;sektion=1&amp;format=html">chmod(1)</a>.) Por exemplo, um administrador do sistema pode executar nosso script manualmente, a partir da linha de comando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /etc/rc.d/dummy start</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Para ser gerenciado corretamente pelo framework <span class=filename>rc.d</span>, os scripts devem ser escritos na linguagem <a href="https://man.freebsd.org/cgi/man.cgi?query=sh&amp;sektion=1&amp;format=html">sh(1)</a>. Se você tiver um serviço ou port que usa um utilitário de controle binário ou uma rotina de inicialização escrita em outra linguagem, instale esse elemento em <span class=filename>/usr/sbin</span> (para o sistema) ou <span class=filename>/usr/local/sbin</span> (para ports) e chame-o a partir de um script <a href="https://man.freebsd.org/cgi/man.cgi?query=sh&amp;sektion=1&amp;format=html">sh(1)</a> no diretório <span class=filename>rc.d</span> apropriado.</p></div></td></tr></tbody></table></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Se você gostaria de aprender os detalhes de por que os scripts <span class=filename>rc.d</span> devem ser escritos na linguagem <a href="https://man.freebsd.org/cgi/man.cgi?query=sh&amp;sektion=1&amp;format=html">sh(1)</a>, veja como o <span class=filename>/etc/rc</span> os invoca por meio de <code>run_rc_script</code> e, em seguida, estude a implementação de <code>run_rc_script</code> em <span class=filename>/etc/rc.subr</span>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>➋ Em <span class=filename>/etc/rc.subr</span>, uma série de funções <a href="https://man.freebsd.org/cgi/man.cgi?query=sh&amp;sektion=1&amp;format=html">sh(1)</a> estão definidas para serem utilizadas por um script <span class=filename>rc.d</span>. As funções estão documentadas em <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.subr&amp;sektion=8&amp;format=html">rc.subr(8)</a>. Embora seja teoricamente possível escrever um script <span class=filename>rc.d</span> sem nunca usar o <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.subr&amp;sektion=8&amp;format=html">rc.subr(8)</a>, suas funções provam ser extremamente úteis e tornam o trabalho uma ordem de magnitude mais fácil. Portanto, não é surpresa que todo mundo recorra ao <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.subr&amp;sektion=8&amp;format=html">rc.subr(8)</a> em scripts <span class=filename>rc.d</span>. Não seremos uma exceção.</p></div><div class=paragraph><p>Um script <span class=filename>rc.d</span> deve fazer o "source" do <span class=filename>/etc/rc.subr</span> (inclua-o usando “.”) <em>antes</em> de chamar as funções <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.subr&amp;sektion=8&amp;format=html">rc.subr(8)</a> para que o <a href="https://man.freebsd.org/cgi/man.cgi?query=sh&amp;sektion=1&amp;format=html">sh(1)</a> tenha a oportunidade de aprender as funções. O estilo preferido é incluir o <span class=filename>/etc/rc.subr</span> antes de tudo.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Algumas funções úteis relacionadas à rede são fornecidas por outro arquivo de inclusão, o <span class=filename>/etc/network.subr</span>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>➌ A variável obrigatória <code>name</code> especifica o nome do nosso script. Ela é exigida pelo <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.subr&amp;sektion=8&amp;format=html">rc.subr(8)</a>. Isso significa que cada script <span class=filename>rc.d</span> <em>deve</em> definir <code>name</code> antes de chamar funções do <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.subr&amp;sektion=8&amp;format=html">rc.subr(8)</a>.</p></div><div class=paragraph><p>Agora é o momento certo para escolher um nome exclusivo para o nosso script de uma vez por todas. Vamos usá-lo em vários lugares enquanto desenvolvemos o script. Para começar, também vamos dar o mesmo nome ao arquivo de script.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>O estilo atual de escrita de scripts <span class=filename>rc.d</span> é envolver os valores atribuídos às variáveis em aspas duplas. Tenha em mente que isso é apenas uma questão de estilo que nem sempre é aplicável. Você pode seguramente omitir as aspas ao redor de palavras simples sem metacaracteres <a href="https://man.freebsd.org/cgi/man.cgi?query=sh&amp;sektion=1&amp;format=html">sh(1)</a>, enquanto em certos casos você precisará de aspas simples para evitar qualquer interpretação do valor por <a href="https://man.freebsd.org/cgi/man.cgi?query=sh&amp;sektion=1&amp;format=html">sh(1)</a>. Um programador deve ser capaz de distinguir a sintaxe da linguagem das convenções de estilo e usá-las sabiamente.</p></div></td></tr></tbody></table></div><div class=paragraph><p>➍ Cada script <span class=filename>rc.d</span> fornece manipuladores, ou métodos, para o <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.subr&amp;sektion=8&amp;format=html">rc.subr(8)</a> invocar. Em particular, <code>start</code>, <code>stop</code>, e outros argumentos para um script <span class=filename>rc.d</span> são manipulados desta forma. Um método é uma expressão <a href="https://man.freebsd.org/cgi/man.cgi?query=sh&amp;sektion=1&amp;format=html">sh(1)</a> armazenada em uma variável chamada <code>argument_cmd</code>, onde <em>argument</em> corresponde ao que pode ser especificado na linha de comando do script. Veremos mais tarde como o <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.subr&amp;sektion=8&amp;format=html">rc.subr(8)</a> fornece métodos padrão para os argumentos padrão.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Para tornar o código em <span class=filename>rc.d</span> mais uniforme, é comum usar <code>${name}</code> sempre que apropriado. Assim, várias linhas podem ser simplesmente copiadas de um script para outro.</p></div></td></tr></tbody></table></div><div class=paragraph><p>➎ Devemos ter em mente que o <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.subr&amp;sektion=8&amp;format=html">rc.subr(8)</a> fornece métodos padrões para os argumentos padrões. Consequentemente, devemos substituir um método padrão por uma expressão <a href="https://man.freebsd.org/cgi/man.cgi?query=sh&amp;sektion=1&amp;format=html">sh(1)</a> sem efeito se quisermos que ele não faça nada.</p></div><div class=paragraph><p>➏ O corpo de um método sofisticado pode ser implementado como uma função. É uma boa ideia dar um nome significativo à função.</p></div><div class="admonitionblock important"><table><tbody><tr><td class=icon><i class="fa icon-important" title=Important></i></td><td class=content><div class=paragraph><p>Recomenda-se fortemente adicionar o prefixo <code>${name}</code> aos nomes de todas as funções definidas no nosso script para que nunca entrem em conflito com as funções de <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.subr&amp;sektion=8&amp;format=html">rc.subr(8)</a> ou outro arquivo de inclusão comum.</p></div></td></tr></tbody></table></div><div class=paragraph><p>➐ Essa chamada para o <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.subr&amp;sektion=8&amp;format=html">rc.subr(8)</a> carrega as variáveis do <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a>. Nosso script ainda não as usa, mas ainda é recomendável carregar o <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a> porque pode haver variáveis do <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a> controlando o <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.subr&amp;sektion=8&amp;format=html">rc.subr(8)</a> em si.</p></div><div class=paragraph><p>➑ Geralmente, esse é o último comando em um script <span class=filename>rc.d</span>. Ele invoca a maquinaria do <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.subr&amp;sektion=8&amp;format=html">rc.subr(8)</a> para realizar a ação solicitada usando as variáveis e métodos que o nosso script forneceu.</p></div></div></div><div class=sect1><h2 id=rcng-confdummy>4. Um script fictício configurável<a class=anchor href=#rcng-confdummy></a></h2><div class=sectionbody><div class=paragraph><p>Agora vamos adicionar alguns controles ao nosso script fictício. Como você deve saber, scripts <span class=filename>rc.d</span> são controlados com o <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a>. Felizmente, o <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.subr&amp;sektion=8&amp;format=html">rc.subr(8)</a> oculta todas as complicações para nós. O script a seguir usa o <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a> por meio do <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.subr&amp;sektion=8&amp;format=html">rc.subr(8)</a> para verificar se está habilitado em primeiro lugar e para buscar uma mensagem para ser exibida na inicialização. Essas duas tarefas, na verdade, são independentes. Por um lado, um script <span class=filename>rc.d</span> pode apenas suportar a habilitação e desabilitação do seu serviço. Por outro lado, um script <span class=filename>rc.d</span> obrigatório pode ter variáveis de configuração. No entanto, faremos as duas coisas no mesmo script:</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh

. /etc/rc.subr

name=dummy
rcvar=dummy_enable <i class=conum data-value=1></i><b>(1)</b>

start_cmd=&#34;${name}_start&#34;
stop_cmd=&#34;:&#34;

load_rc_config $name <i class=conum data-value=2></i><b>(2)</b>
: ${dummy_enable:=no} <i class=conum data-value=3></i><b>(3)</b>
: ${dummy_msg=&#34;Nothing started.&#34;} <i class=conum data-value=4></i><b>(4)</b>

dummy_start()
{
	echo &#34;$dummy_msg&#34; <i class=conum data-value=5></i><b>(5)</b>
}

run_rc_command &#34;$1&#34;</pre></div></div><div class=paragraph><p>O que mudou neste exemplo?</p></div><div class=paragraph><p>➊ A variável <code>rcvar</code> especifica o nome da variável do botão LIGA/DESLIGA.</p></div><div class=paragraph><p>➋ Agora, o <code>load_rc_config</code> é invocado mais cedo no script, antes que quaisquer variáveis do <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a> sejam acessadas.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Enquanto examina os scripts <span class=filename>rc.d</span>, tenha em mente que o <a href="https://man.freebsd.org/cgi/man.cgi?query=sh&amp;sektion=1&amp;format=html">sh(1)</a> adia a avaliação de expressões em uma função até que esta seja chamada. Portanto, não é um erro invocar <code>load_rc_config</code> tão tarde quanto logo antes de <code>run_rc_command</code> e ainda assim acessar as variáveis <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a> das funções de método exportadas para <code>run_rc_command</code>. Isso ocorre porque as funções de método devem ser chamadas por <code>run_rc_command</code>, que é invocado <em>após</em> <code>load_rc_config</code>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>➌ Aviso será emitido pelo <code>run_rc_command</code> se o <code>rcvar</code> em si estiver configurado, mas a variável de controle indicada estiver desativada. Se o seu script <span class=filename>rc.d</span> é para o sistema base, você deve adicionar uma configuração padrão para o knob em <span class=filename>/etc/defaults/rc.conf</span> e documentá-lo em <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a>. Caso contrário, é seu script que deve fornecer uma configuração padrão para o knob. A abordagem canônica para o último caso é mostrada no exemplo.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Você pode fazer o <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.subr&amp;sektion=8&amp;format=html">rc.subr(8)</a> agir como se o botão estivesse definido como <code>ON</code>, independentemente de sua configuração atual, prefixando o argumento do script com <code>one</code> ou <code>force</code>, como em <code>onestart</code> ou <code>forcestop</code>. No entanto, tenha em mente que <code>force</code> tem outros efeitos perigosos que abordaremos abaixo, enquanto <code>one</code> apenas substitui o botão ON/OFF. Por exemplo, suponha que <code>dummy_enable</code> esteja definido como <code>OFF</code>. O seguinte comando executará o método <code>start</code> apesar da configuração:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /etc/rc.d/dummy onestart</span></code></pre></div></div></td></tr></tbody></table></div><div class=paragraph><p>➍ Agora a mensagem a ser exibida na inicialização não é mais codificada no script. É especificada por uma variável <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a> chamada <code>dummy_msg</code>. Este é um exemplo trivial de como as variáveis <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a> podem controlar um script <span class=filename>rc.d</span>.</p></div><div class="admonitionblock important"><table><tbody><tr><td class=icon><i class="fa icon-important" title=Important></i></td><td class=content><div class=paragraph><p>Os nomes de todas as variáveis <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a> usadas exclusivamente pelo nosso script <em>devem</em> ter o mesmo prefixo: <code>${name}_</code>. Por exemplo: <code>dummy_mode</code>, <code>dummy_state_file</code>, e assim por diante.</p></div></td></tr></tbody></table></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Embora seja possível usar um nome mais curto internamente, por exemplo, apenas <code>msg</code>, adicionar o prefixo único <code>${name}_</code> a todos os nomes globais introduzidos pelo nosso script nos salvará de possíveis colisões com o namespace do <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.subr&amp;sektion=8&amp;format=html">rc.subr(8)</a>.</p></div><div class=paragraph><p>Como regra geral, os scripts <span class=filename>rc.d</span> do sistema base não precisam fornecer valores padrão para suas variáveis <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a>, pois os valores padrão devem ser definidos em <span class=filename>/etc/defaults/rc.conf</span>. Por outro lado, os scripts <span class=filename>rc.d</span> para ports devem fornecer os valores padrão conforme mostrado no exemplo.</p></div></td></tr></tbody></table></div><div class=paragraph><p>➎ Aqui usamos <code>dummy_msg</code> para controlar nosso script, ou seja, para emitir uma mensagem variável. O uso de uma função shell é excessivo aqui, uma vez que ela executa apenas um único comando; uma alternativa igualmente válida é:</p></div><div class="literalblock programlisting"><div class=content><pre>start_cmd=&#34;echo \&#34;$dummy_msg\&#34;&#34;</pre></div></div></div></div><div class=sect1><h2 id=rcng-daemon>5. Inicialização e desligamento de um daemon simples<a class=anchor href=#rcng-daemon></a></h2><div class=sectionbody><div class=paragraph><p>Dissemos anteriormente que o <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.subr&amp;sektion=8&amp;format=html">rc.subr(8)</a> pode fornecer métodos padrões. Obviamente, tais padrões não podem ser muito gerais. Eles são adequados para o caso comum de iniciar e desligar um programa de daemon simples. Vamos supor agora que precisamos escrever um script <span class=filename>rc.d</span> para um daemon chamado <code>mumbled</code>. Aqui está:</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh

. /etc/rc.subr

name=mumbled
rcvar=mumbled_enable

command=&#34;/usr/sbin/${name}&#34; <i class=conum data-value=1></i><b>(1)</b>

load_rc_config $name
run_rc_command &#34;$1&#34;</pre></div></div><div class=paragraph><p>Agradavelmente simples, não é? Vamos examinar nosso pequeno script. A única coisa nova a observar é o seguinte:</p></div><div class=paragraph><p>➊ A variável <code>command</code> é significativa para <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.subr&amp;sektion=8&amp;format=html">rc.subr(8)</a>. Se ela estiver definida, <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.subr&amp;sektion=8&amp;format=html">rc.subr(8)</a> agirá de acordo com o cenário de servir a um daemon convencional. Em particular, os métodos padrão serão fornecidos para esses argumentos: <code>start</code>, <code>stop</code>, <code>restart</code>, <code>poll</code> e <code>status</code>.</p></div><div class=paragraph><p>O daemon será iniciado executando <code>$command</code> com as flags de linha de comando especificadas por <code>$mumbled_flags</code>. Assim, todos os dados de entrada para o método <code>start</code> padrão estão disponíveis nas variáveis definidas pelo nosso script. Ao contrário de <code>start</code>, outros métodos podem exigir informações adicionais sobre o processo iniciado. Por exemplo, <code>stop</code> deve saber o PID do processo para terminá-lo. No caso presente, <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.subr&amp;sektion=8&amp;format=html">rc.subr(8)</a> irá pesquisar a lista de todos os processos, procurando por um processo com o nome igual a <code>procname</code>. Este último é outra variável com significado para <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.subr&amp;sektion=8&amp;format=html">rc.subr(8)</a>, e seu valor padrão é o de <code>command</code>. Em outras palavras, quando definimos <code>command</code>, <code>procname</code> é efetivamente definido para o mesmo valor. Isso permite que nosso script mate o daemon e verifique se ele está em execução.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Algumas vezes, programas são de fato scripts executáveis. O sistema executa esse script iniciando o seu interpretador e passando o nome do script como um argumento na linha de comando. Isso é refletido na lista de processos, o que pode confundir <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.subr&amp;sektion=8&amp;format=html">rc.subr(8)</a>. Você deve adicionalmente definir <code>command_interpreter</code> para que <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.subr&amp;sektion=8&amp;format=html">rc.subr(8)</a> saiba o nome real do processo se <code>$command</code> for um script.</p></div><div class=paragraph><p>A cada script <span class=filename>rc.d</span>, há uma variável opcional do <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a> que tem precedência sobre <code>command</code>. Seu nome é construído da seguinte forma: <code>${name}_program</code>, onde <code>name</code> é a variável obrigatória discutida anteriormente. Por exemplo, neste caso, será <code>mumbled_program</code>. É o <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.subr&amp;sektion=8&amp;format=html">rc.subr(8)</a> que arruma <code>${name}_program</code> para substituir <code>command</code>.</p></div><div class=paragraph><p>Claro que o <a href="https://man.freebsd.org/cgi/man.cgi?query=sh&amp;sektion=1&amp;format=html">sh(1)</a> permite definir <code>${name}_program</code> a partir do <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a> ou do próprio script, mesmo se <code>command</code> não estiver definido. Nesse caso, as propriedades especiais de <code>${name}_program</code> são perdidas, e ela se torna uma variável comum que o script pode usar para seus próprios fins. No entanto, o uso exclusivo de <code>${name}_program</code> é desencorajado, pois usá-la em conjunto com <code>command</code> se tornou idiomático em <span class=filename>rc.d</span> scripting.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Para obter informações mais detalhadas sobre os métodos padrões, consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.subr&amp;sektion=8&amp;format=html">rc.subr(8)</a>.</p></div></div></div><div class=sect1><h2 id=rcng-daemon-adv>6. Inicialização e desligamento de um daemon avançado<a class=anchor href=#rcng-daemon-adv></a></h2><div class=sectionbody><div class=paragraph><p>Vamos adicionar um pouco de carne aos ossos do script anterior e torná-lo mais complexo e cheio de funcionalidades. Os métodos padrões podem fazer um bom trabalho para nós, mas podemos precisar ajustar alguns dos seus aspectos. Agora vamos aprender como ajustar os métodos padrões para as nossas necessidades.</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh

. /etc/rc.subr

name=mumbled
rcvar=mumbled_enable

command=&#34;/usr/sbin/${name}&#34;
command_args=&#34;mock arguments &gt; /dev/null 2&gt;&amp;1&#34; <i class=conum data-value=1></i><b>(1)</b>

pidfile=&#34;/var/run/${name}.pid&#34; <i class=conum data-value=2></i><b>(2)</b>

required_files=&#34;/etc/${name}.conf /usr/share/misc/${name}.rules&#34; <i class=conum data-value=3></i><b>(3)</b>

sig_reload=&#34;USR1&#34; <i class=conum data-value=4></i><b>(4)</b>

start_precmd=&#34;${name}_prestart&#34; <i class=conum data-value=5></i><b>(5)</b>
stop_postcmd=&#34;echo Bye-bye&#34; <i class=conum data-value=6></i><b>(6)</b>

extra_commands=&#34;reload plugh xyzzy&#34; <i class=conum data-value=7></i><b>(7)</b>

plugh_cmd=&#34;mumbled_plugh&#34; <i class=conum data-value=8></i><b>(8)</b>
xyzzy_cmd=&#34;echo &#39;Nothing happens.&#39;&#34;

mumbled_prestart()
{
	if checkyesno mumbled_smart; then <i class=conum data-value=9></i><b>(9)</b>
		rc_flags=&#34;-o smart ${rc_flags}&#34; <i class=conum data-value=10></i><b>(10)</b>
	fi
	case &#34;$mumbled_mode&#34; in
	foo)
		rc_flags=&#34;-frotz ${rc_flags}&#34;
		;;
	bar)
		rc_flags=&#34;-baz ${rc_flags}&#34;
		;;
	*)
		warn &#34;Invalid value for mumbled_mode&#34; <i class=conum data-value=11></i><b>(11)</b>
		return 1 <i class=conum data-value=12></i><b>(12)</b>
		;;
	esac
	run_rc_command xyzzy <i class=conum data-value=13></i><b>(13)</b>
	return 0
}

mumbled_plugh() <i class=conum data-value=14></i><b>(14)</b>
{
	echo &#39;A hollow voice says &#34;plugh&#34;.&#39;
}

load_rc_config $name
run_rc_command &#34;$1&#34;</pre></div></div><div class=paragraph><p>➊ Argumentos adicionais para <code>$command</code> podem ser passados em <code>command_args</code>. Eles serão adicionados à linha de comando após <code>$mumbled_flags</code>. Como a linha de comando final é passada para <code>eval</code> para sua execução real, redirecionamentos de entrada e saída podem ser especificados em <code>command_args</code>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p><em>Nunca</em> inclua opções com hífen, como <code>-X</code> ou <code>--foo</code>, em <code>command_args</code>. O conteúdo de <code>command_args</code> aparecerá no final da linha de comando final, portanto, é provável que sigam argumentos presentes em <code>${name}_flags</code>; mas a maioria dos comandos não reconhecerá opções com hífen após argumentos comuns. Uma maneira melhor de passar opções adicionais para <code>$command</code> é adicioná-las no início de <code>${name}_flags</code>. Outra maneira é modificar <code>rc_flags</code> <a href=#rc-flags>conforme mostrado posteriormente</a>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>➋ Um daemon bem comportado deve criar um <em>pidfile</em> para que seu processo possa ser encontrado de forma mais fácil e confiável. A variável <code>pidfile</code>, se definida, informa ao <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.subr&amp;sektion=8&amp;format=html">rc.subr(8)</a> onde ele pode encontrar o pidfile para ser utilizado em seus métodos padrões.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>De fato, o <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.subr&amp;sektion=8&amp;format=html">rc.subr(8)</a> também usa o pidfile para ver se o daemon já está em execução antes de iniciá-lo. Essa verificação pode ser ignorada usando o argumento <code>faststart</code>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>➌ Se o daemon não puder ser executado a menos que certos arquivos existam, basta listá-los em <code>required_files</code>, e o <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.subr&amp;sektion=8&amp;format=html">rc.subr(8)</a> verificará se esses arquivos existem antes de iniciar o daemon. Existem também <code>required_dirs</code> e <code>required_vars</code> para diretórios e variáveis de ambiente, respectivamente. Todos eles são descritos em detalhes no <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.subr&amp;sektion=8&amp;format=html">rc.subr(8)</a>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>O método padrão do <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.subr&amp;sektion=8&amp;format=html">rc.subr(8)</a> pode ser forçado a pular as verificações de pré-requisito usando <code>forcestart</code> como argumento para o script.</p></div></td></tr></tbody></table></div><div class=paragraph><p>➍ Podemos personalizar sinais a serem enviados ao daemon caso eles difiram dos sinais conhecidos. Em particular, <code>sig_reload</code> especifica o sinal que faz com que o daemon recarregue sua configuração; por padrão, é o SIGHUP. Outro sinal é enviado para interromper o processo do daemon; o padrão é o SIGTERM, mas isso pode ser alterado configurando <code>sig_stop</code> adequadamente.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>As sinalizações devem ser especificadas para o <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.subr&amp;sektion=8&amp;format=html">rc.subr(8)</a> sem o prefixo <code>SIG</code>, como é mostrado no exemplo. A versão do FreeBSD do <a href="https://man.freebsd.org/cgi/man.cgi?query=kill&amp;sektion=1&amp;format=html">kill(1)</a> pode reconhecer o prefixo <code>SIG</code>, mas as versões de outros sistemas operacionais podem não reconhecer.</p></div></td></tr></tbody></table></div><div class=paragraph><p>➎➏ Realizar tarefas adicionais antes ou depois dos métodos padrões é fácil. Para cada argumento de comando suportado por nosso script, podemos definir <code>argument_precmd</code> e <code>argument_postcmd</code>. Esses comandos <a href="https://man.freebsd.org/cgi/man.cgi?query=sh&amp;sektion=1&amp;format=html">sh(1)</a> são invocados antes e depois do respectivo método, como é evidente pelos seus nomes.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Sobrescrever um método padrão com um <code>argument_cmd</code> personalizado ainda não nos impede de usar <code>argument_precmd</code> ou <code>argument_postcmd</code> se precisarmos. Em particular, o primeiro é bom para verificar condições personalizadas e sofisticadas que devem ser atendidas antes de executar o próprio comando. Usar <code>argument_precmd</code> juntamente com <code>argument_cmd</code> nos permite separar logicamente as verificações da ação.</p></div><div class=paragraph><p>Não se esqueça de que você pode colocar qualquer expressão válida do <a href="https://man.freebsd.org/cgi/man.cgi?query=sh&amp;sektion=1&amp;format=html">sh(1)</a> nos métodos, pre e pós comandos que você define. Invocar uma função que realiza o trabalho real é um bom estilo na maioria dos casos, mas nunca deixe o estilo limitar sua compreensão do que está acontecendo nos bastidores.</p></div></td></tr></tbody></table></div><div class=paragraph><p>➐ Se quisermos implementar argumentos personalizados, que também podem ser considerados como <em>comandos</em> para o nosso script, precisamos listá-los em <code>extra_commands</code> e fornecer métodos para lidar com eles.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>O comando <code>reload</code> é especial. Por um lado, ele possui um método predefinido em <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.subr&amp;sektion=8&amp;format=html">rc.subr(8)</a>. Por outro lado, <code>reload</code> não é oferecido por padrão. A razão é que nem todos os daemons usam o mesmo mecanismo de recarga e alguns não têm nada para recarregar. Portanto, precisamos pedir explicitamente que a funcionalidade integrada seja fornecida. Podemos fazer isso por meio de <code>extra_commands</code>.</p></div><div class=paragraph><p>O que recebemos do método padrão para <code>reload</code>? Muitas vezes, os daemons recarregam sua configuração após receber um sinal - geralmente, SIGHUP. Portanto, o <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.subr&amp;sektion=8&amp;format=html">rc.subr(8)</a> tenta recarregar o daemon enviando um sinal para ele. O sinal é pré-definido como SIGHUP, mas pode ser personalizado via <code>sig_reload</code>, se necessário.</p></div></td></tr></tbody></table></div><div class=paragraph><p>➑⓮ O nosso script suporta dois comandos não padrão, <code>plugh</code> e <code>xyzzy</code>. Nós os vimos listados em <code>extra_commands</code>, e agora é hora de fornecer métodos para eles. O método para <code>xyzzy</code> é apenas inserido em linha enquanto que para <code>plugh</code> é implementado como a função <code>mumbled_plugh</code>.</p></div><div class=paragraph><p>Comandos não padrão não são invocados durante a inicialização ou desligamento. Geralmente, eles são para a conveniência do administrador do sistema. Eles também podem ser usados em outros subsistemas, por exemplo, o <a href="https://man.freebsd.org/cgi/man.cgi?query=devd&amp;sektion=8&amp;format=html">devd(8)</a> se especificados em <a href="https://man.freebsd.org/cgi/man.cgi?query=devd.conf&amp;sektion=5&amp;format=html">devd.conf(5)</a>.</p></div><div class=paragraph><p>A lista completa de comandos disponíveis pode ser encontrada na linha de uso impressa pelo <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.subr&amp;sektion=8&amp;format=html">rc.subr(8)</a> quando o script é invocado sem argumentos. Por exemplo, aqui está a linha de uso do script em estudo:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /etc/rc.d/mumbled</span>
Usage: /etc/rc.d/mumbled <span class=o>[</span>fast|force|one]<span class=o>(</span>start|stop|restart|rcvar|reload|plugh|xyzzy|status|poll<span class=o>)</span></code></pre></div></div><div class=paragraph><p>⓭ Um script pode invocar seus próprios comandos padrão ou não-padrão, se necessário. Isso pode parecer semelhante a chamar funções, mas sabemos que comandos e funções do shell nem sempre são a mesma coisa. Por exemplo, <code>xyzzy</code> não é implementado como uma função aqui. Além disso, pode haver um pré-comando e um pós-comando, que devem ser invocados ordenadamente. Portanto, a maneira adequada para um script executar seu próprio comando é por meio do <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.subr&amp;sektion=8&amp;format=html">rc.subr(8)</a>, como mostrado no exemplo.</p></div><div class=paragraph><p>➒ Uma função útil chamada <code>checkyesno</code> é fornecida pelo <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.subr&amp;sektion=8&amp;format=html">rc.subr(8)</a>. Ela recebe um nome de variável como argumento e retorna um código de saída zero se e somente se a variável estiver definida como <code>YES</code>, ou <code>TRUE</code>, ou <code>ON</code>, ou <code>1</code>, insensível a maiúsculas e minúsculas; um código de saída não-zero é retornado caso contrário. Neste último caso, a função testa se a variável está definida como <code>NO</code>, <code>FALSE</code>, <code>OFF</code> ou <code>0</code>, insensível a maiúsculas e minúsculas; ela imprime uma mensagem de aviso se a variável contiver qualquer outra coisa, ou seja, lixo.</p></div><div class=paragraph><p>Tenha em mente que para o <a href="https://man.freebsd.org/cgi/man.cgi?query=sh&amp;sektion=1&amp;format=html">sh(1)</a>, um código de saída zero significa verdadeiro e um código de saída não-zero significa falso.</p></div><div class="admonitionblock important"><table><tbody><tr><td class=icon><i class="fa icon-important" title=Important></i></td><td class=content><div class=paragraph><p>A função <code>checkyesno</code> recebe um <em>nome de variável</em>. Não passe o <em>valor expandido</em> de uma variável para ela; isso não funcionará como esperado.</p></div><div class=paragraph><p>Aqui está o uso correto de <code>checkyesno</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>if checkyesno mumbled_enable; then
        foo
fi</pre></div></div><div class=paragraph><p>Ao contrário, chamar <code>checkyesno</code> como mostrado abaixo não funcionará - pelo menos não como esperado:</p></div><div class="literalblock programlisting"><div class=content><pre>if checkyesno &#34;${mumbled_enable}&#34;; then
        foo
fi</pre></div></div></td></tr></tbody></table></div><div class=paragraph><p>➓ <a id=rc-flags></a>Podemos afetar as flags que serão passadas para <code>$command</code> modificando <code>rc_flags</code> em <code>$start_precmd</code>.</p></div><div class=paragraph><p>⓫ Em certos casos, podemos precisar emitir uma mensagem importante que também deve ser registrada no <code>syslog</code>. Isso pode ser feito facilmente com as seguintes funções do <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.subr&amp;sektion=8&amp;format=html">rc.subr(8)</a>: <code>debug</code>, <code>info</code>, <code>warn</code> e <code>err</code>. Esta última função finaliza o script com o código especificado.</p></div><div class=paragraph><p>⓬ Os códigos de saída dos métodos e seus pre-comandos não são apenas ignorados por padrão. Se <code>argument_precmd</code> retornar um código de saída diferente de zero, o método principal não será executado. Por sua vez, <code>argument_postcmd</code> não será chamado, a menos que o método principal retorne um código de saída igual a zero.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Entretanto, é possível instruir o <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.subr&amp;sektion=8&amp;format=html">rc.subr(8)</a> a ignorar esses códigos de saída e executar todos os comandos mesmo assim, adicionando um argumento com o prefixo <code>force</code>, como em <code>forcestart</code>.</p></div></td></tr></tbody></table></div></div></div><div class=sect1><h2 id=rcng-hookup>7. Conectando um script ao framework rc.d<a class=anchor href=#rcng-hookup></a></h2><div class=sectionbody><div class=paragraph><p>Depois que um script é escrito, ele precisa ser integrado ao <span class=filename>rc.d</span>. O passo crucial é instalar o script em <span class=filename>/etc/rc.d</span> (para o sistema base) ou <span class=filename>/usr/local/etc/rc.d</span> (para o ports). Tanto o <span class=filename>bsd.prog.mk</span> quanto o <span class=filename>bsd.port.mk</span> fornecem ganchos convenientes para isso, e geralmente você não precisa se preocupar com a propriedade e o modo adequados. Os scripts do sistema devem ser instalados a partir de <span class=filename>src/libexec/rc/rc.d</span> através do <span class=filename>Makefile</span> encontrado lá. Scripts de ports podem ser instalados usando <code>USE_RC_SUBR</code> como descrito no <a href=https://docs.freebsd.org/pt-br/books/porters-handbook/#rc-scripts>Porter’s Handbook</a>.</p></div><div class=paragraph><p>No entanto, devemos considerar antecipadamente o local do nosso script na sequência de inicialização do sistema. O serviço manipulado pelo nosso script provavelmente depende de outros serviços. Por exemplo, um daemon de rede não pode funcionar sem as interfaces de rede e o roteamento em funcionamento. Mesmo que um serviço pareça não exigir nada, dificilmente pode ser iniciado antes que os sistemas de arquivos básicos tenham sido verificados e montados.</p></div><div class=paragraph><p>Nós já mencionamos o <a href="https://man.freebsd.org/cgi/man.cgi?query=rcorder&amp;sektion=8&amp;format=html">rcorder(8)</a>. Agora é hora de dar uma olhada mais de perto nele. Em poucas palavras, o <a href="https://man.freebsd.org/cgi/man.cgi?query=rcorder&amp;sektion=8&amp;format=html">rcorder(8)</a> pega um conjunto de arquivos, examina seus conteúdos e imprime uma lista ordenada por dependência dos arquivos do conjunto no <code>stdout</code>. O objetivo é manter as informações de dependência <em>dentro</em> dos arquivos, de modo que cada arquivo possa falar apenas por si mesmo. Um arquivo pode especificar as seguintes informações:</p></div><div class=ulist><ul><li><p>os nomes das "condições" (ou seja, serviços para nós) que ele <em>fornece</em>;</p></li><li><p>os nomes das "condições" que ele <em>requer</em>;</p></li><li><p>os nomes das "condições" que este arquivo deve ser executado <em>antes</em>;</p></li><li><p>palavras-chave adicionais que podem ser usadas para selecionar um subconjunto do conjunto completo de arquivos (<a href="https://man.freebsd.org/cgi/man.cgi?query=rcorder&amp;sektion=8&amp;format=html">rcorder(8)</a> pode ser instruído via opções para incluir ou omitir os arquivos que possuem determinadas palavras-chave listadas.)</p></li></ul></div><div class=paragraph><p>Não é surpresa que o <a href="https://man.freebsd.org/cgi/man.cgi?query=rcorder&amp;sektion=8&amp;format=html">rcorder(8)</a> possa lidar apenas com arquivos de texto com uma sintaxe próxima à do <a href="https://man.freebsd.org/cgi/man.cgi?query=sh&amp;sektion=1&amp;format=html">sh(1)</a>. Ou seja, as linhas especiais entendidas pelo <a href="https://man.freebsd.org/cgi/man.cgi?query=rcorder&amp;sektion=8&amp;format=html">rcorder(8)</a> se parecem com comentários do <a href="https://man.freebsd.org/cgi/man.cgi?query=sh&amp;sektion=1&amp;format=html">sh(1)</a>. A sintaxe dessas linhas especiais é bastante rígida para simplificar seu processamento. Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=rcorder&amp;sektion=8&amp;format=html">rcorder(8)</a> para obter detalhes.</p></div><div class=paragraph><p>Além de usar as linhas especiais entendidas pelo <a href="https://man.freebsd.org/cgi/man.cgi?query=rcorder&amp;sektion=8&amp;format=html">rcorder(8)</a>, um script pode exigir sua dependência de outro serviço simplesmente iniciando-o forçadamente. Isso pode ser necessário quando o outro serviço é opcional e não iniciará por si só porque o administrador do sistema o desativou por engano em <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a>.</p></div><div class=paragraph><p>Com este conhecimento geral em mente, vamos considerar o simples script daemon aprimorado com coisas de dependência:</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh

# PROVIDE: mumbled oldmumble <i class=conum data-value=1></i><b>(1)</b>
# REQUIRE: DAEMON cleanvar frotz <i class=conum data-value=2></i><b>(2)</b>
# BEFORE:  LOGIN <i class=conum data-value=3></i><b>(3)</b>
# KEYWORD: nojail shutdown <i class=conum data-value=4></i><b>(4)</b>

. /etc/rc.subr

name=mumbled
rcvar=mumbled_enable

command=&#34;/usr/sbin/${name}&#34;
start_precmd=&#34;${name}_prestart&#34;

mumbled_prestart()
{
	if ! checkyesno frotz_enable &amp;&amp; \
	    ! /etc/rc.d/frotz forcestatus 1&gt;/dev/null 2&gt;&amp;1; then
		force_depend frotz || return 1 <i class=conum data-value=5></i><b>(5)</b>
	fi
	return 0
}

load_rc_config $name
run_rc_command &#34;$1&#34;</pre></div></div><div class=paragraph><p>Como antes, a análise detalhada segue:</p></div><div class=paragraph><p>➊ Essa linha declara os nomes das "condições" que nosso script fornece. Agora, outros scripts podem registrar uma dependência em nosso script por esses nomes.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Geralmente, um script especifica uma única condição fornecida. No entanto, nada nos impede de listar várias condições, por exemplo, por razões de compatibilidade.</p></div><div class=paragraph><p>Em qualquer caso, o nome da condição principal, ou única, <code>PROVIDE:</code> deve ser o mesmo que <code>${name}</code>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>➋➌ Então, nosso script indica em quais "condições" fornecidas por outros scripts ele depende. De acordo com as linhas, nosso script pede para o <a href="https://man.freebsd.org/cgi/man.cgi?query=rcorder&amp;sektion=8&amp;format=html">rcorder(8)</a> colocá-lo após o(s) script(s) fornecendo o <span class=filename>DAEMON</span> e o <span class=filename>cleanvar</span>, mas antes daquele que fornece <span class=filename>LOGIN</span>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>A linha <code>BEFORE:</code> não deve ser usada para contornar uma lista de dependências incompleta em outro script. O caso apropriado para usar <code>BEFORE:</code> é quando o outro script não se importa com o nosso, mas nosso script pode executar sua tarefa melhor se for executado antes do outro. Um exemplo típico da vida real é a relação entre as interfaces de rede e o firewall: embora as interfaces não dependam do firewall para fazer o trabalho delas, a segurança do sistema se beneficiará se o firewall estiver pronto antes de haver qualquer tráfego de rede.</p></div><div class=paragraph><p>Além das condições correspondentes a um único serviço, existem meta-condições e seus scripts "placeholder" usados para garantir que certos grupos de operações sejam executados antes de outros. Estes são denotados por nomes em <span class=filename>UPPERCASE</span>. Sua lista e propósitos podem ser encontrados no manual <a href="https://man.freebsd.org/cgi/man.cgi?query=rc&amp;sektion=8&amp;format=html">rc(8)</a>.</p></div><div class=paragraph><p>Lembre-se de que colocar o nome de um serviço na linha <code>REQUIRE:</code> não garante que o serviço realmente estará em execução no momento em que o script começar. O serviço necessário pode falhar ao iniciar ou simplesmente ser desativado em <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a>. Obviamente, o <a href="https://man.freebsd.org/cgi/man.cgi?query=rcorder&amp;sektion=8&amp;format=html">rcorder(8)</a> não pode controlar esses detalhes e o <a href="https://man.freebsd.org/cgi/man.cgi?query=rc&amp;sektion=8&amp;format=html">rc(8)</a> também não fará isso. Consequentemente, a aplicação iniciada pelo nosso script deve ser capaz de lidar com qualquer serviço necessário que esteja indisponível. Em certos casos, podemos ajudá-lo conforme discutido <a href=#forcedep>abaixo</a></p></div></td></tr></tbody></table></div><div class=paragraph><p><a id=keywords></a>➍ Como lembramos do texto acima, as palavras-chave do <a href="https://man.freebsd.org/cgi/man.cgi?query=rcorder&amp;sektion=8&amp;format=html">rcorder(8)</a> podem ser usadas para selecionar ou deixar de fora alguns scripts. Qualquer consumidor do <a href="https://man.freebsd.org/cgi/man.cgi?query=rcorder&amp;sektion=8&amp;format=html">rcorder(8)</a> pode especificar, através das opções <code>-k</code> e <code>-s</code>, quais palavras-chave estarão na "lista de manutenção" e na "lista de exclusão", respectivamente. De todos os arquivos a serem ordenados por dependência, <a href="https://man.freebsd.org/cgi/man.cgi?query=rcorder&amp;sektion=8&amp;format=html">rcorder(8)</a> escolherá apenas aqueles que tiverem uma palavra-chave da lista de manutenção (a menos que esteja vazia) e que não tiverem uma palavra-chave da lista de exclusão.</p></div><div class=paragraph><p>No FreeBSD, o <a href="https://man.freebsd.org/cgi/man.cgi?query=rcorder&amp;sektion=8&amp;format=html">rcorder(8)</a> é usado por <span class=filename>/etc/rc</span> e <span class=filename>/etc/rc.shutdown</span>. Esses dois scripts definem a lista padrão de palavras-chaves do FreeBSD <span class=filename>rc.d</span> e seus significados da seguinte forma:</p></div><div class=dlist><dl><dt class=hdlist1>nojail</dt><dd><p>O serviço não é para ambiente <a href="https://man.freebsd.org/cgi/man.cgi?query=jail&amp;sektion=8&amp;format=html">jail(8)</a>. Os procedimentos automáticos de inicialização e desligamento ignorarão o script se estiver dentro de uma jail.</p></dd><dt class=hdlist1>nostart</dt><dd><p>O serviço deve ser iniciado manualmente ou não iniciado de forma alguma. O procedimento de inicialização automático ignorará o script. Em conjunto com a palavra-chave <span class=filename>shutdown</span>, isso pode ser usado para escrever scripts que fazem algo apenas no desligamento do sistema.</p></dd><dt class=hdlist1>shutdown</dt><dd><p>Este palavra-chave deve ser listada de forma <em>explícita</em> se o serviço precisa ser parado antes do desligamento do sistema.</p></dd></dl></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Quando o sistema está prestes a desligar, o arquivo <span class=filename>/etc/rc.shutdown</span> é executado. Ele assume que a maioria dos scripts <span class=filename>rc.d</span> não tem nada a fazer nesse momento. Portanto, o <span class=filename>/etc/rc.shutdown</span> invoca seletivamente scripts <span class=filename>rc.d</span> com a palavra-chave <span class=filename>shutdown</span>, ignorando efetivamente o restante dos scripts. Para desligamento ainda mais rápido, o <span class=filename>/etc/rc.shutdown</span> passa o comando <span class=filename>faststop</span> para os scripts que executa para que eles pulem verificações preliminares, como a verificação do pidfile. Como os serviços dependentes devem ser interrompidos antes de suas dependências, o <span class=filename>/etc/rc.shutdown</span> executa os scripts em ordem de dependência reversa. Se você está escrevendo um script <span class=filename>rc.d</span> real, deve considerar se ele é relevante no momento do desligamento do sistema. Por exemplo, se o seu script faz seu trabalho apenas em resposta ao comando <span class=filename>start</span>, então você não precisa incluir essa palavra-chave. No entanto, se o seu script gerencia um serviço, é provavelmente uma boa ideia pará-lo antes que o sistema prossiga para o estágio final de sua sequência de desligamento descrita em <a href="https://man.freebsd.org/cgi/man.cgi?query=halt&amp;sektion=8&amp;format=html">halt(8)</a>. Em particular, um serviço deve ser interrompido explicitamente se precisar de tempo considerável ou ações especiais para ser desligado corretamente. Um exemplo típico desse tipo de serviço é um mecanismo de banco de dados.</p></div></td></tr></tbody></table></div><div class=paragraph><p><a id=forcedep></a>➎ Em primeiro lugar, <code>force_depend</code> deve ser usado com muito cuidado. Geralmente, é melhor revisar a hierarquia das variáveis de configuração para seus scripts <span class=filename>rc.d</span> se eles são interdependentes.</p></div><div class=paragraph><p>Se ainda assim você não puder abrir mão do <code>force_depend</code>, o exemplo oferece um exemplo de como invocá-lo condicionalmente. No exemplo, nosso daemon <code>mumbled</code> requer que outro daemon, <code>frotz</code>, seja iniciado antecipadamente. No entanto, <code>frotz</code> também é opcional; e o <a href="https://man.freebsd.org/cgi/man.cgi?query=rcorder&amp;sektion=8&amp;format=html">rcorder(8)</a> não conhece esses detalhes. Felizmente, nosso script tem acesso a todas as variáveis de <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a>. Se <code>frotz_enable</code> for verdadeiro, esperamos o melhor e confiamos no <span class=filename>rc.d</span> para ter iniciado <code>frotz</code>. Caso contrário, verificamos forçadamente o status de <code>frotz</code>. Finalmente, impomos nossa dependência em <code>frotz</code> se ele não estiver em execução. Uma mensagem de aviso será emitida por <code>force_depend</code>, pois ele só deve ser invocado se uma configuração incorreta for detectada.</p></div></div></div><div class=sect1><h2 id=rcng-args>8. Dando mais flexibilidade a um script rc.d<a class=anchor href=#rcng-args></a></h2><div class=sectionbody><div class=paragraph><p>Quando invocado durante a inicialização ou desligamento, um script <span class=filename>rc.d</span> deve agir em todo o subsistema pelo qual é responsável. Por exemplo, o <span class=filename>/etc/rc.d/netif</span> deve iniciar ou parar todas as interfaces de rede descritas em <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a>. Cada tarefa pode ser indicada por um único argumento de comando, como <code>start</code> ou <code>stop</code>. Entre a inicialização e o desligamento, os scripts <span class=filename>rc.d</span> ajudam o administrador a controlar o sistema em execução e é quando surge a necessidade de mais flexibilidade e precisão. Por exemplo, o administrador pode querer adicionar as configurações de uma nova interface de rede em <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a> e, em seguida, iniciá-la sem interferir na operação das interfaces existentes. Na próxima vez, o administrador pode precisar desligar uma única interface de rede. Para facilitar o uso na linha de comando, o respectivo script <span class=filename>rc.d</span> pede um argumento extra, o nome da interface.</p></div><div class=paragraph><p>Felizmente, o <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.subr&amp;sektion=8&amp;format=html">rc.subr(8)</a> permite passar qualquer número de argumentos para os métodos do script (dentro dos limites do sistema). Devido a isso, as mudanças no próprio script podem ser mínimas.</p></div><div class=paragraph><p>Como o <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.subr&amp;sektion=8&amp;format=html">rc.subr(8)</a> pode ter acesso aos argumentos adicionais da linha de comando? Ele deve simplesmente pegá-los diretamente? De maneira alguma! Em primeiro lugar, uma função do <a href="https://man.freebsd.org/cgi/man.cgi?query=sh&amp;sektion=1&amp;format=html">sh(1)</a> não tem acesso aos parâmetros posicionais de quem a chamou, mas o <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.subr&amp;sektion=8&amp;format=html">rc.subr(8)</a> é apenas um conjunto dessas funções. Em segundo lugar, a boa prática do <span class=filename>rc.d</span> dita que é responsabilidade do script principal decidir quais argumentos devem ser passados para seus métodos.</p></div><div class=paragraph><p>Portanto, a abordagem adotada pelo <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.subr&amp;sektion=8&amp;format=html">rc.subr(8)</a> é a seguinte: <code>run_rc_command</code> passa todos os seus argumentos, exceto o primeiro, ao respectivo método sem alterações. O primeiro argumento omitido é o nome do método em si: <code>start</code>, <code>stop</code>, etc. Ele será removido por <code>run_rc_command</code>, então o que é <code>$2</code> na linha de comando original será apresentado como <code>$1</code> para o método, e assim por diante.</p></div><div class=paragraph><p>Para ilustrar essa oportunidade, vamos modificar o script fictício primitivo para que suas mensagens dependam dos argumentos adicionais fornecidos. Aqui vamos nós:</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh

. /etc/rc.subr

name=&#34;dummy&#34;
start_cmd=&#34;${name}_start&#34;
stop_cmd=&#34;:&#34;
kiss_cmd=&#34;${name}_kiss&#34;
extra_commands=&#34;kiss&#34;

dummy_start()
{
        if [ $# -gt 0 ]; then <i class=conum data-value=1></i><b>(1)</b>
                echo &#34;Greeting message: $*&#34;
        else
                echo &#34;Nothing started.&#34;
        fi
}

dummy_kiss()
{
        echo -n &#34;A ghost gives you a kiss&#34;
        if [ $# -gt 0 ]; then <i class=conum data-value=2></i><b>(2)</b>
                echo -n &#34; and whispers: $*&#34;
        fi
        case &#34;$*&#34; in
        *[.!?])
                echo
                ;;
        *)
                echo .
                ;;
        esac
}

load_rc_config $name
run_rc_command &#34;$@&#34; <i class=conum data-value=3></i><b>(3)</b></pre></div></div><div class=paragraph><p>Quais mudanças essenciais podemos notar no script?</p></div><div class=paragraph><p>➊ Todos os argumentos que você digita após <code>start</code> podem acabar como parâmetros posicionais para o respectivo método. Podemos usá-los de qualquer maneira de acordo com nossa tarefa, habilidades e gosto. No exemplo atual, simplesmente passamos todos eles para o <a href="https://man.freebsd.org/cgi/man.cgi?query=echo&amp;sektion=1&amp;format=html">echo(1)</a> como uma única string na próxima linha - observe o <code>$*</code> dentro das aspas duplas. Aqui está como o script pode ser invocado agora:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /etc/rc.d/dummy start</span>
Nothing started.

<span class=c># /etc/rc.d/dummy start Hello world!</span>
Greeting message: Hello world!</code></pre></div></div><div class=paragraph><p>➋ O mesmo se aplica a qualquer método que nosso script ofereça, não apenas a um padrão. Adicionamos um método personalizado chamado <code>kiss</code>, e ele pode tirar proveito dos argumentos extras da mesma forma que o <code>start</code> pode. Por exemplo:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /etc/rc.d/dummy kiss</span>
A ghost gives you a kiss.

<span class=c># /etc/rc.d/dummy kiss Once I was Etaoin Shrdlu...</span>
A ghost gives you a kiss and whispers: Once I was Etaoin Shrdlu...</code></pre></div></div><div class=paragraph><p>➌ Se quisermos apenas passar todos os argumentos extras para qualquer método, podemos simplesmente substituir <code>"$1"</code> por <code>"$@"</code> na última linha do nosso script, onde invocamos <code>run_rc_command</code>.</p></div><div class="admonitionblock important"><table><tbody><tr><td class=icon><i class="fa icon-important" title=Important></i></td><td class=content><div class=paragraph><p>Um programador em <a href="https://man.freebsd.org/cgi/man.cgi?query=sh&amp;sektion=1&amp;format=html">sh(1)</a> deve entender a diferença sutil entre <code>$*</code> e <code>$@</code> como formas de designar todos os parâmetros posicionais. Para uma discussão aprofundada, consulte um bom manual de <a href="https://man.freebsd.org/cgi/man.cgi?query=sh&amp;sektion=1&amp;format=html">sh(1)</a>. Não use essas expressões até entender completamente o seu uso, pois o uso incorreto pode resultar em scripts com bugs e inseguros.</p></div></td></tr></tbody></table></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Atualmente, o <code>run_rc_command</code> pode ter um bug que o impede de manter as fronteiras originais entre os argumentos. Ou seja, argumentos com espaços em branco embutidos podem não ser processados corretamente. O bug decorre do uso inadequado de <code>$*</code>.</p></div></td></tr></tbody></table></div></div></div><div class=sect1><h2 id=rcng-furthur>9. Leitura adicional<a class=anchor href=#rcng-furthur></a></h2><div class=sectionbody><div class=paragraph><p><a id=lukem></a><a href=http://www.mewburn.net/luke/papers/rc.d.pdf>O artigo original de Luke Mewburn</a> oferece uma visão geral do <span class=filename>rc.d</span> e uma justificativa detalhada para suas decisões de design. Ele fornece uma compreensão do quadro geral do <span class=filename>rc.d</span> e seu lugar em um sistema operacional BSD moderno.</p></div><div class=paragraph><p><a id=manpages></a>As páginas do manual para <a href="https://man.freebsd.org/cgi/man.cgi?query=rc&amp;sektion=8&amp;format=html">rc(8)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.subr&amp;sektion=8&amp;format=html">rc.subr(8)</a> e <a href="https://man.freebsd.org/cgi/man.cgi?query=rcorder&amp;sektion=8&amp;format=html">rcorder(8)</a> documentam em detalhes os componentes do sistema <span class=filename>rc.d</span>. Você não pode aproveitar completamente o poder do <span class=filename>rc.d</span> sem estudar as páginas do manual e consultá-las ao escrever seus próprios scripts.</p></div><div class=paragraph><p>A principal fonte de exemplos práticos e funcionais é o diretório <span class=filename>/etc/rc.d</span> em um sistema em operação. O seu conteúdo é fácil e agradável de ler, pois a maioria das partes difíceis está escondida profundamente em <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.subr&amp;sektion=8&amp;format=html">rc.subr(8)</a>. No entanto, tenha em mente que os scripts em <span class=filename>/etc/rc.d</span> não foram escritos por anjos, então eles podem conter bugs e decisões de design subótimas. Agora você pode melhorá-los!</p></div></div></div><hr><div class=last-modified><p><strong>Última alteração em</strong>: 30 de abril de 2023 por <a href="https://cgit.freebsd.org/doc/commit/?id=e310196197" target=_blank>Edson Brandi</a></p></div></div><aside class=toc><div class=toc-content><h3>Índice</h3><nav id=TableOfContents><ul><li><a href=#rcng-intro>1. Introdução</a></li><li><a href=#rcng-task>2. Esboçando a tarefa</a></li><li><a href=#rcng-dummy>3. Um script fictício</a></li><li><a href=#rcng-confdummy>4. Um script fictício configurável</a></li><li><a href=#rcng-daemon>5. Inicialização e desligamento de um daemon simples</a></li><li><a href=#rcng-daemon-adv>6. Inicialização e desligamento de um daemon avançado</a></li><li><a href=#rcng-hookup>7. Conectando um script ao framework rc.d</a></li><li><a href=#rcng-args>8. Dando mais flexibilidade a um script rc.d</a></li><li><a href=#rcng-furthur>9. Leitura adicional</a></li></ul></nav><hr><div class=resources><h3>Recursos</h3><ul class=contents><li><i class="fa fa-file-pdf-o" aria-hidden=true title="Download PDF"></i><a href=https://download.freebsd.org/doc/pt-br/articles/rc-scripting/rc-scripting_pt-br.pdf>Download PDF</a></li><li><i class="fa fa-pencil-square-o" aria-hidden=true title="Edite essa página"></i><a href=https://github.com/freebsd/freebsd-doc/blob/main/documentation/content/pt-br/_index target=_blank>Edite essa página</a></li></ul></div></div></aside></main><footer><div class=footer-container><section class=logo-column><img src=https://docs.freebsd.org/images/FreeBSD-colors.svg width=160 height=50 alt="FreeBSD logo"><div class=options-container><div class=language-container><a id=languages href=https://docs.freebsd.org/pt-br/languages><img src=https://docs.freebsd.org/images/language.png class=language-image alt="Escolha o idioma">
<span>Brazilian Portuguese</span></a></div><div class=theme-container><select id=theme-chooser><option value=theme-system>System</option><option value=theme-light>Light</option><option value=theme-dark>Dark</option><option value=theme-high-contrast>Alto contraste</option></select></div></div></section><section class=about-column><h3 class=column-title>About</h3><ul class=column-elements-container><li><a href=https://www.freebsd.org/about/ target=_blank class=column-element>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/ target=_blank class=column-element>FreeBSD Foundation</a></li><li><a href=https://www.freebsd.org/where/ target=_blank class=column-element>Get FreeBSD</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct target=_blank class=column-element>Code of Conduct</a></li><li><a href=https://www.freebsd.org/security/ target=_blank class=column-element>Security Advisories</a></li></ul></section><section class=documentation-column><h3 class=column-title>Documentation</h3><ul class=column-elements-container><li><a href=/pt-br class=column-element>Documentation portal</a></li><li><a href=https://man.FreeBSD.org target=_blank class=column-element>Manual pages</a></li><li><a href=https://papers.FreeBSD.org target=_blank class=column-element>Presentations and papers</a></li><li><a href=https://docs-archive.freebsd.org/doc/ target=_blank class=column-element>Previous versions</a></li><li><a href=https://docs-archive.freebsd.org/44doc/ target=_blank class=column-element>4.4BSD Documents</a></li><li><a href=https://wiki.freebsd.org/ target=_blank class=column-element>Wiki</a></li></ul></section><section class=community-column><h3 class=column-title>Community</h3><ul class=column-elements-container><li><a href=https://docs.freebsd.org/pt-br/articles/contributing class=column-element>Get involved</a></li><li><a href=https://forums.freebsd.org/ target=_blank class=column-element>Community forum</a></li><li><a href=https://lists.freebsd.org/ target=_blank class=column-element>Mailing lists</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank class=column-element>IRC Channels</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank class=column-element>Bug Tracker</a></li></ul></section><section class=legal-column><h3 class=column-title>Legal</h3><ul class=column-elements-container><li><a href=https://freebsdfoundation.org/donate/ target=_blank class=column-element>Donations</a></li><li><a href=https://www.freebsd.org/copyright/freebsd-license/ target=_blank class=column-element>Licensing</a></li><li><a href=https://www.freebsd.org/privacy/ target=_blank class=column-element>Privacy Policy</a></li><li><a href=https://www.freebsd.org/copyright/ target=_blank class=column-element>Legal notices</a></li></ul></section><section class=copyright-column><p>&copy; 1994-2024 The FreeBSD Project. All rights reserved</p><span>Made with <span class=heart>♥</span> by the FreeBSD Community</span></section></div></footer></body></html>