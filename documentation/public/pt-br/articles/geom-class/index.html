<!doctype html><html class=theme-light lang=pt-br><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Um guia sobre os internals do GEOM e sobre como escrever sua própria classe GEOM"><meta name=keywords content="GEOM,kernel,modules,FreeBSD"><meta name=copyright content="1995-2024 The FreeBSD Foundation"><link rel=canonical href=http://172.16.201.134:1313/pt-br/articles/geom-class/><title>Escrevendo uma classe GEOM | FreeBSD Documentation Portal</title>
<meta name=theme-color content="#790000"><meta name=color-scheme content="system light dark high-contrast"><link rel="shortcut icon" href=http://172.16.201.134:1313/favicon.ico><link rel=stylesheet href=http://172.16.201.134:1313/styles/main.min.css><link rel=stylesheet href=http://172.16.201.134:1313/css/font-awesome-min.css><script defer src=/js/theme-chooser.min.js></script><script defer src=/js/copy-clipboard.min.js></script><script defer src=/js/search.min.js></script><meta name=twitter:card content="summary"><meta name=twitter:domain content="docs.FreeBSD.org"><meta name=twitter:site content="@freebsd"><meta name=twitter:url content="https://twitter.com/freebsd"><meta property="og:title" content="Escrevendo uma classe GEOM"><meta property="og:description" content="Um guia sobre os internals do GEOM e sobre como escrever sua própria classe GEOM"><meta property="og:type" content="website"><meta property="og:image" content="http://172.16.201.134:1313/favicon.ico"><meta property="og:image:alt" content="FreeBSD Logo"><meta property="og:locale" content="pt-br"><meta property="og:url" content="http://172.16.201.134:1313/pt-br/articles/geom-class/"><meta property="og:site_name" content="FreeBSD Documentation Portal"><script type=application/ld+json>{"@context":"http://schema.org","@type":"Article","url":"http:\/\/172.16.201.134:1313\/pt-br\/articles\/geom-class\/","name":"FreeBSD Documentation Portal","headline":"FreeBSD Documentation Portal","description":"FreeBSD Documentation Portal"}</script></head><body><header><div class=header-container><div class=logo-menu-bars-container><a href=https://www.FreeBSD.org class=logo><img src=http://172.16.201.134:1313/images/FreeBSD-monochromatic.svg width=160 height=50 alt="FreeBSD logo">
</a><label class=menu-bars for=menu-bars><i class="fa fa-bars" aria-hidden=true></i></label></div><input id=menu-bars type=checkbox><nav><ul class=menu><li class=menu-item><input id=about type=checkbox>
<a href=# aria-label="Navigate to About section"><label class=menu-item-description for=about>About
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/about/ target=_blank>About</a></li><li><a href=https://www.freebsd.org/about/ target=_blank>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/about-us/about-the-foundation/ target=_blank>FreeBSD Foundation</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct/ target=_blank>Code of Conduct</a></li></ul></li><li class=menu-item><input id=download type=checkbox>
<a href=# aria-label="Navigate to get FreeBSD section"><label class=menu-item-description for=download>Get FreeBSD
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/where/ target=_blank>Get FreeBSD</a></li><li><a href=https://www.freebsd.org/releases/ target=_blank>Release Information</a></li><li><a href=https://www.freebsd.org/releng/ target=_blank>Release Engineering</a></li><li><a href=https://www.freebsd.org/security/ target=_blank>Security Advisories</a></li></ul></li><li class=menu-item><input id=documentation type=checkbox>
<a href=# aria-label="Navigate to get Documentation section"><label class=menu-item-description for=documentation>Documentation
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=/pt-br>Documentation portal</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook>FreeBSD Handbook</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/porters-handbook>Porter's Handbook</a></li><li><a href=https://docs.FreeBSD.org/en/books/fdp-primer>Documentation Project Handbook</a></li><li><a href=https://man.FreeBSD.org target=_blank>Manual pages</a></li><li><a href=https://papers.FreeBSD.org target=_blank>Presentations and papers</a></li><li><a href=https://wiki.FreeBSD.org target=_blank>Wiki</a></li><li><a href=http://172.16.201.134:1313/pt-br/books>Books</a></li><li><a href=http://172.16.201.134:1313/pt-br/articles>Articles</a></li></ul></li><li class=menu-item><input id=community type=checkbox>
<a href=# aria-label="Navigate to get Community section"><label class=menu-item-description for=community>Community
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/community/>Community</a></li><li><a href=http://172.16.201.134:1313/pt-br/articles/contributing>Get involved</a></li><li><a href=https://forums.freebsd.org/ target=_blank>Forum</a></li><li><a href=https://lists.freebsd.org/ target=_blank>Mailing lists</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank>IRC Channels</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank>Bug Tracker</a></li><li><a href=https://www.freebsd.org/support/ target=_blank>Support</a></li></ul></li></ul></nav><div class=search-donate-container><form class=search method=get id=search-header-form action=https://docs.freebsd.org/search name=search-header-form><input type=hidden name=DB value=pt-br>
<input id=words name=P type=text size=20 maxlength=255>
<button>
<i class="fa fa-search" aria-hidden=true></i></button></form><div class=donate><a href=https://freebsdfoundation.org/donate/ target=_blank><span class=heart>♥</span>
Donate</a></div></div></div></header><main class=main-wrapper-article><div class=article><h1 class=title>Escrevendo uma classe GEOM</h1><div class="admonitionblock note"><p><i class="fa fa-exclamation-circle" aria-hidden=true></i>
Esta tradução pode estar desatualizada. Para ajudar com as traduções, acesse a <a href=https://translate-dev.freebsd.org/ target=_blank>ferramenta de traduções do FreeBSD</a>.</p></div><div class=legalnotice><a id=trademarks></a><details><summary>trademarks</summary><p>FreeBSD is a registered trademark of the FreeBSD Foundation.</p><p>Intel, Celeron, Centrino, Core, EtherExpress, i386, i486, Itanium, Pentium, and Xeon are trademarks or registered trademarks of Intel Corporation or its subsidiaries in the United States and other countries.</p><p>Many of the designations used by manufacturers and sellers to distinguish their products are claimed as trademarks. Where those designations appear in this document, and the FreeBSD Project was aware of the trademark claim, the designations have been followed by the “™” or the “®” symbol.</p></details></div><div class=toc-mobile><h3>Índice</h3><nav id=TableOfContents><ul><li><a href=#intro>1. Introdução</a></li><li><a href=#prelim>2. Preliminares</a></li><li><a href=#kernelprog>3. Programação do kernel do FreeBSD</a></li><li><a href=#geom>4. Programação GEOM</a></li></ul></nav></div><div id=preamble><div class=sectionbody><div class="paragraph abstract-title"><p>Resumo</p></div><div class=paragraph><p>Este texto documenta alguns pontos de partida no desenvolvimento de classes GEOM e módulos de kernel em geral. Pressupõe-se que o leitor esteja familiarizado com a programação de espaço de usuário em C.</p></div><hr></div></div><div class=sect1><h2 id=intro>1. Introdução<a class=anchor href=#intro></a></h2><div class=sectionbody><div class=sect2><h3 id=intro-docs>1.1. Documentação<a class=anchor href=#intro-docs></a></h3><div class=paragraph><p>A documentação sobre programação de kernel é escassa - é uma das poucas áreas em que quase não há tutoriais amigáveis, e a frase "use o código fonte!" realmente é verdadeira. No entanto, existem alguns fragmentos (alguns deles seriamente desatualizados) circulando que devem ser estudados antes de começar a codificar:</p></div><div class=ulist><ul><li><p>O <a href=https://docs.freebsd.org/en/books/developers-handbook/>Handbook do Desenvolvedor do FreeBSD</a> - parte do projeto de documentação, não contém nada específico sobre programação do kernel, mas sim algumas informações úteis em geral.</p></li><li><p>O <a href=https://docs.freebsd.org/en/books/arch-handbook/>Handbook de Arquitetura do FreeBSD</a> - também do projeto de documentação, contém descrições de várias instalações e procedimentos de baixo nível. O capítulo mais importante é o 13, <a href=https://docs.freebsd.org/en/books/arch-handbook/#driverbasics>Escrevendo drivers de dispositivos FreeBSD</a>.</p></li><li><p>A seção Blueprints do site <a href=http://www.freebsddiary.org class=bare>http://www.freebsddiary.org</a> contém vários artigos interessantes sobre as facilidades do kernel.</p></li><li><p>As páginas de manual da seção 9 - para documentação importante sobre as funções do kernel.</p></li><li><p>A página de manual <a href="https://man.freebsd.org/cgi/man.cgi?query=geom&amp;sektion=4&amp;format=html">geom(4)</a> e os slides sobre o GEOM do PHK em <a href=http://phk.freebsd.dk/pubs/ class=bare>http://phk.freebsd.dk/pubs/</a> - para uma introdução geral ao subsistema GEOM.</p></li><li><p>As páginas de manual <a href="https://man.freebsd.org/cgi/man.cgi?query=g_bio&amp;sektion=9&amp;format=html">g_bio(9)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=g_event&amp;sektion=9&amp;format=html">g_event(9)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=g_data&amp;sektion=9&amp;format=html">g_data(9)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=g_geom&amp;sektion=9&amp;format=html">g_geom(9)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=g_provider&amp;sektion=9&amp;format=html">g_provider(9)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=g_consumer&amp;sektion=9&amp;format=html">g_consumer(9)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=g_access&amp;sektion=9&amp;format=html">g_access(9)</a> e outras vinculadas a elas, para documentação sobre funcionalidades específicas.</p></li><li><p>A página de manual <a href="https://man.freebsd.org/cgi/man.cgi?query=style&amp;sektion=9&amp;format=html">style(9)</a> - para documentação sobre as convenções de estilo de codificação que devem ser seguidas para qualquer código que seja commitado para a árvore do FreeBSD.</p></li></ul></div></div></div></div><div class=sect1><h2 id=prelim>2. Preliminares<a class=anchor href=#prelim></a></h2><div class=sectionbody><div class=paragraph><p>A melhor maneira de desenvolver para o kernel é ter (pelo menos) dois computadores separados. Um deles conteria o ambiente de desenvolvimento e as fontes, e o outro seria usado para testar o código recém-escrito por meio do boot e montagem de sistemas de arquivos por rede do primeiro. Dessa forma, se o novo código contiver erros e travar a máquina, ele não afetará as fontes (e outros dados "ao vivo"). O segundo sistema nem mesmo precisa de uma tela adequada. Em vez disso, ele pode ser conectado com um cabo serial ou KVM para o primeiro.</p></div><div class=paragraph><p>No entanto, como nem todo mundo tem dois ou mais computadores disponíveis, existem algumas coisas que podem ser feitas para preparar um sistema "ao vivo" para o desenvolvimento de código do kernel. Essa configuração também é aplicável para desenvolvimento em uma máquina virtual <a href=http://www.vmware.com/>VMWare</a> ou <a href=http://www.qemu.org/>QEmu</a> (a próxima melhor opção depois de uma máquina de desenvolvimento dedicada).</p></div><div class=sect2><h3 id=prelim-system>2.1. Modificando um sistema para desenvolvimento<a class=anchor href=#prelim-system></a></h3><div class=paragraph><p>Para qualquer programação de kernel, é essencial ter um kernel com <code>INVARIANTS</code> ativado. Portanto, adicione as seguintes opções no arquivo de configuração do kernel:</p></div><div class="literalblock programlisting"><div class=content><pre>options INVARIANT_SUPPORT
options INVARIANTS</pre></div></div><div class=paragraph><p>Para obter mais depuração, você também deve incluir o suporte a WITNESS, que alertará sobre erros de bloqueio:</p></div><div class="literalblock programlisting"><div class=content><pre>options WITNESS_SUPPORT
options WITNESS</pre></div></div><div class=paragraph><p>Para depurar despejos de falhas (crash dumps), é necessário um kernel com símbolos de depuração:</p></div><div class="literalblock programlisting"><div class=content><pre>  makeoptions    DEBUG=-g</pre></div></div><div class=paragraph><p>Com a maneira usual de instalar o kernel (<code>make installkernel</code>), o kernel de depuração não será instalado automaticamente. Ele é chamado de <span class=filename>kernel.debug</span> e fica localizado em <span class=filename>/usr/obj/usr/src/sys/NOME_DO_KERNEL/</span>. Por conveniência, ele deve ser copiado para <span class=filename>/boot/kernel/</span>.</p></div><div class=paragraph><p>Outra conveniência é habilitar o depurador do kernel para que você possa examinar um kernel panic quando ele ocorrer. Para isso, adicione as seguintes linhas no arquivo de configuração do kernel:</p></div><div class="literalblock programlisting"><div class=content><pre>options KDB
options DDB
options KDB_TRACE</pre></div></div><div class=paragraph><p>Para que isso funcione, você pode precisar definir um sysctl (se ele não estiver ativado por padrão):</p></div><div class="literalblock programlisting"><div class=content><pre>  debug.debugger_on_panic=1</pre></div></div><div class=paragraph><p>Panics do kernel podem acontecer, portanto, é preciso ter cuidado com o cache do sistema de arquivos. Em particular, ter softupdates pode significar que a versão mais recente de um arquivo pode ser perdida se ocorrer um panic antes que seja gravada no armazenamento. Desabilitar o softupdates implica em uma grande perda de desempenho e ainda não garante a consistência dos dados. É necessário montar o sistema de arquivos com a opção "sync" para garantir isso. Como um compromisso, os atrasos do cache do softupdates podem ser encurtados. Existem três sysctl que são úteis para isso (melhor configurados em <span class=filename>/etc/sysctl.conf</span>):</p></div><div class="literalblock programlisting"><div class=content><pre>kern.filedelay=5
kern.dirdelay=4
kern.metadelay=3</pre></div></div><div class=paragraph><p>Os números representam segundos.</p></div><div class=paragraph><p>Para depurar panics do kernel, são necessários os despejos de núcleo do kernel. Como um kernel panic pode tornar os sistemas de arquivos inutilizáveis, este despejo de falhas é primeiro gravado em uma partição raw. Geralmente, isso é feito na partição de swap. Esta partição deve ter pelo menos o tamanho da RAM física da máquina. No próximo boot, o despejo é copiado para um arquivo regular. Isso acontece após a verificação e montagem dos sistemas de arquivos e antes que o swap seja ativado. Isso é controlado com duas variáveis do arquivo <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>dumpdev=&#34;/dev/ad0s4b&#34;
dumpdir=&#34;/usr/core</pre></div></div><div class=paragraph><p>A variável <code>dumpdev</code> especifica a partição de swap e <code>dumpdir</code> informa ao sistema onde no sistema de arquivos realocar o core dump no reboot.</p></div><div class=paragraph><p>Gravar o core dump do kernel é lento e leva muito tempo, portanto, se você tiver muita memória (>256 MB) e muitos panics, pode ser frustrante esperar enquanto isso é feito (duas vezes - primeiro para gravá-lo na troca, depois para realocá-lo no sistema de arquivos). É conveniente, portanto, limitar a quantidade de RAM que o sistema usará por meio de um ajuste no <span class=filename>/boot/loader.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>  hw.physmem=&#34;256M&#34;</pre></div></div><div class=paragraph><p>Se os panics forem frequentes e os sistemas de arquivos forem grandes (ou se você simplesmente não confiar no softupdates + fsck em segundo plano), é aconselhável desativar o fsck em segundo plano por meio da seguinte variável no arquivo <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>  background_fsck=&#34;NO&#34;</pre></div></div><div class=paragraph><p>Dessa forma, os sistemas de arquivos serão sempre verificados quando necessário. Observe que, com o fsck em segundo plano, um novo panic pode ocorrer enquanto os discos estão sendo verificados. Novamente, a maneira mais segura é não ter muitos sistemas de arquivos locais, usando outro computador como um servidor NFS.</p></div></div><div class=sect2><h3 id=prelim-starting>2.2. Começando o projeto<a class=anchor href=#prelim-starting></a></h3><div class=paragraph><p>Para criar uma nova classe GEOM, um subdiretório vazio deve ser criado em um diretório arbitrário acessível pelo usuário. Você não precisa criar o diretório do módulo em <span class=filename>/usr/src</span>.</p></div></div><div class=sect2><h3 id=prelim-makefile>2.3. O Makefile<a class=anchor href=#prelim-makefile></a></h3><div class=paragraph><p>É uma boa prática criar arquivos <span class=filename>Makefile</span> para todos os projetos de codificação não triviais, o que inclui, é claro, módulos do kernel.</p></div><div class=paragraph><p>Criar o arquivo <span class=filename>Makefile</span> é simples graças a um extenso conjunto de rotinas auxiliares fornecidas pelo sistema. Em resumo, aqui está como um <span class=filename>Makefile</span> mínimo se parece para um módulo do kernel:</p></div><div class="literalblock programlisting"><div class=content><pre>SRCS=g_journal.c
KMOD=geom_journal

.include &lt;bsd.kmod.mk&gt;</pre></div></div><div class=paragraph><p>Este <span class=filename>Makefile</span> (com nomes de arquivo alterados) serve para qualquer módulo do kernel e uma classe GEOM pode residir em apenas um módulo do kernel. Se mais de um arquivo for necessário, liste-os na variável <code>SRCS</code>, separados por espaço de outros nomes de arquivo.</p></div></div></div></div><div class=sect1><h2 id=kernelprog>3. Programação do kernel do FreeBSD<a class=anchor href=#kernelprog></a></h2><div class=sectionbody><div class=sect2><h3 id=kernelprog-memalloc>3.1. Alocação de memória<a class=anchor href=#kernelprog-memalloc></a></h3><div class=paragraph><p>Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=malloc&amp;sektion=9&amp;format=html">malloc(9)</a>. A alocação básica de memória é apenas ligeiramente diferente da sua equivalente no espaço do usuário. Mais notavelmente, <code>malloc()</code> e <code>free()</code> aceitam parâmetros adicionais conforme descrito na página do manual.</p></div><div class=paragraph><p>Um "malloc type" deve ser declarado na seção de declaração de um arquivo de código fonte, por exemplo desta forma:</p></div><div class="literalblock programlisting"><div class=content><pre>  static MALLOC_DEFINE(M_GJOURNAL, &#34;gjournal data&#34;, &#34;GEOM_JOURNAL Data&#34;);</pre></div></div><div class=paragraph><p>Para usar essa macro, os cabeçalhos <span class=filename>sys/param.h</span>, <span class=filename>sys/kernel.h</span> e <span class=filename>sys/malloc.h</span> devem ser incluídos.</p></div><div class=paragraph><p>Existe outro mecanismo para alocar memória, o UMA (Universal Memory Allocator). Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=uma&amp;sektion=9&amp;format=html">uma(9)</a> para obter detalhes, mas é um tipo especial de alocador usado principalmente para alocação rápida de listas compostas por itens do mesmo tamanho (por exemplo, matrizes dinâmicas de estruturas).</p></div></div><div class=sect2><h3 id=kernelprog-lists>3.2. Listas e filas<a class=anchor href=#kernelprog-lists></a></h3><div class=paragraph><p>Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=queue&amp;sektion=3&amp;format=html">queue(3)</a>. Existem MUITOS casos em que uma lista de coisas precisa ser mantida. Felizmente, essa estrutura de dados é implementada (de várias maneiras) por macros em C incluídas no sistema. O tipo de lista mais usado é TAILQ porque é o mais flexível. Também é o que tem os maiores requisitos de memória (seus elementos são duplamente vinculados) e também o mais lento (embora a variação de velocidade seja da ordem de algumas instruções de CPU a mais, então não deve ser levado a sério).</p></div><div class=paragraph><p>Se a velocidade de recuperação de dados é muito importante, consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=tree&amp;sektion=3&amp;format=html">tree(3)</a> e <a href="https://man.freebsd.org/cgi/man.cgi?query=hashinit&amp;sektion=9&amp;format=html">hashinit(9)</a>.</p></div></div><div class=sect2><h3 id=kernelprog-bios>3.3. BIOS<a class=anchor href=#kernelprog-bios></a></h3><div class=paragraph><p>A estrutura <code>bio</code> é usada para todas e quaisquer operações de entrada/saída relacionadas ao GEOM. Basicamente, ela contém informações sobre qual dispositivo ('provider') deve satisfazer a solicitação, tipo de solicitação, deslocamento, comprimento, ponteiro para um buffer e um conjunto de flags e campos "específicos do usuário" que podem ajudar a implementar vários ajustes.</p></div><div class=paragraph><p>O importante aqui é que os <code>bio</code>s são manipulados de forma assíncrona. Isso significa que, na maioria das partes do código, não há um análogo das chamadas <a href="https://man.freebsd.org/cgi/man.cgi?query=read&amp;sektion=2&amp;format=html">read(2)</a> e <a href="https://man.freebsd.org/cgi/man.cgi?query=write&amp;sektion=2&amp;format=html">write(2)</a> do espaço do usuário que não retornam até que uma solicitação seja concluída. Em vez disso, uma função fornecida pelo desenvolvedor é chamada como uma notificação quando a solicitação é concluída (ou resulta em erro).</p></div><div class=paragraph><p>O modelo de programação assíncrono (também chamado de "event-driven") é um pouco mais difícil do que o muito usado modelo imperativo usado no espaço do usuário (pelo menos leva um tempo para se acostumar). Em alguns casos, as rotinas auxiliares <code>g_write_data()</code> e <code>g_read_data()</code> podem ser usadas, mas <em>nem sempre</em>. Em particular, elas não podem ser usadas quando um mutex é mantido; por exemplo, o mutex de topologia GEOM ou o mutex interno mantido durante as funções <code>.start()</code> e <code>.stop()</code>.</p></div></div></div></div><div class=sect1><h2 id=geom>4. Programação GEOM<a class=anchor href=#geom></a></h2><div class=sectionbody><div class=sect2><h3 id=geom-ggate>4.1. Ggate<a class=anchor href=#geom-ggate></a></h3><div class=paragraph><p>Se o desempenho máximo não for necessário, uma maneira muito mais simples de fazer uma transformação de dados é implementá-lo na área do usuário por meio do recurso ggate (GEOM gate). Infelizmente, não existe uma maneira fácil de converter ou até mesmo compartilhar código entre as duas abordagens.</p></div></div><div class=sect2><h3 id=geom-class>4.2. Classe GEOM<a class=anchor href=#geom-class></a></h3><div class=paragraph><p>As classes GEOM são transformações nos dados. Essas transformações podem ser combinadas de maneira semelhante a uma árvore. As instâncias de classes GEOM são chamadas de <em>geoms</em>.</p></div><div class=paragraph><p>Cada classe GEOM tem vários "métodos de classe" que são chamados quando não há uma instância geom disponível (ou simplesmente não estão vinculados a uma única instância):</p></div><div class=ulist><ul><li><p>O <code>.init</code> é chamado quando o GEOM toma conhecimento de uma classe GEOM (quando o módulo do kernel é carregado.)</p></li><li><p>O <code>.fini</code> é chamado quando o GEOM abandona a classe (quando o módulo é descarregado)</p></li><li><p>O <code>.taste</code> é chamado em seguida, uma vez para cada provider que o sistema tem disponível. Se aplicável, esta função geralmente criará e iniciará uma instância geom.</p></li><li><p>O <code>.destroy_geom</code> é chamado quando o geom deve ser desmontado</p></li><li><p>O <code>.ctlconf</code> é chamado quando o usuário solicita a reconfiguração do geom existente</p></li></ul></div><div class=paragraph><p>Também são definidas as funções de evento GEOM, que serão copiadas para a instância geom.</p></div><div class=paragraph><p>O campo <code>.geom</code> na estrutura <code>g_class</code> é uma LISTA de geoms instanciados a partir da classe.</p></div><div class=paragraph><p>Estas funções são chamadas a partir da thread g_event do kernel.</p></div></div><div class=sect2><h3 id=geom-softc>4.3. Softc<a class=anchor href=#geom-softc></a></h3><div class=paragraph><p>O nome "softc" é um termo legado para "dados privados do driver". O nome provavelmente vem do termo arcaico "bloco de controle de software". No GEOM, é uma estrutura (mais precisamente, um ponteiro para uma estrutura) que pode ser anexada a uma instância geom para manter quaisquer dados que sejam privados à instância geom. A maioria das classes GEOM tem os seguintes membros:</p></div><div class=ulist><ul><li><p><code>struct g_provider *provider</code>: Instância geom criada a partir do provider correspondente</p></li><li><p><code>uint16_t n_disks</code>: Número de consumidores que esta instância geom consome</p></li><li><p><code>struct g_consumer **disks</code>: Array de <code>struct g_consumer*</code>. (Não é possível usar apenas uma única indireção porque os <code>struct g_consumer*</code> são criados em nosso nome pelo GEOM).</p></li></ul></div><div class=paragraph><p>A estrutura <code>softc</code> contém todo o estado da instância geom. Cada instância geom tem sua própria estrutura <code>softc</code>.</p></div></div><div class=sect2><h3 id=geom-metadata>4.4. Metadados<a class=anchor href=#geom-metadata></a></h3><div class=paragraph><p>O formato dos metadados é mais ou menos dependente da classe, mas DEVE começar com:</p></div><div class=ulist><ul><li><p>Buffer de 16 bytes para uma assinatura de terminação nula (geralmente o nome da classe)</p></li><li><p>ID da versão uint32</p></li></ul></div><div class=paragraph><p>Assume-se que as classes geom sabem como lidar com metadados com ID de versão menores que os deles.</p></div><div class=paragraph><p>Os metadados estão localizados no último setor do provedor (e, portanto, devem caber nele).</p></div><div class=paragraph><p>(Tudo isso depende da implementação, mas todo o código existente funciona assim, e é suportado por bibliotecas.)</p></div></div><div class=sect2><h3 id=geom-creating>4.5. Rotulando/criando um GEOM<a class=anchor href=#geom-creating></a></h3><div class=paragraph><p>A sequência de eventos é:</p></div><div class=ulist><ul><li><p>O usuário chama o utilitário <a href="https://man.freebsd.org/cgi/man.cgi?query=geom&amp;sektion=8&amp;format=html">geom(8)</a> (ou um comandos alternativos para o mesmo utilitário)</p></li><li><p>O utilitário determina qual classe geom ele deve manipular e procura pela biblioteca <span class=filename>geom_CLASSNAME.so</span> (geralmente em <span class=filename>/lib/geom</span>).</p></li><li><p>O utilitário utiliza a função <a href="https://man.freebsd.org/cgi/man.cgi?query=dlopen&amp;sektion=3&amp;format=html">dlopen(3)</a> para carregar dinamicamente a biblioteca, extrair as definições dos parâmetros de linha de comando e funções auxiliares.</p></li></ul></div><div class=paragraph><p>No caso da criação/rotulação de um novo geom, isso é o que acontece:</p></div><div class=ulist><ul><li><p>O comando <a href="https://man.freebsd.org/cgi/man.cgi?query=geom&amp;sektion=8&amp;format=html">geom(8)</a> procura na linha de comando pelo comando (geralmente <code>label</code>) e chama uma função auxiliar correspondente.</p></li><li><p>A função auxiliar verifica parâmetros e reúne metadados, que são gravados em todos os provedores envolvidos.</p></li><li><p>Isso "anula" os geoms existentes (se houver) e inicializa uma nova rodada de "degustação" dos providers. A classe geom pretendida reconhece os metadados e coloca o geom em funcionamento.</p></li></ul></div><div class=paragraph><p>(A sequência de eventos acima é dependente da implementação, mas todo o código existente funciona assim, e é suportado pelas bibliotecas.)</p></div></div><div class=sect2><h3 id=geom-command>4.6. Estrutura do Comando GEOM<a class=anchor href=#geom-command></a></h3><div class=paragraph><p>A biblioteca auxiliar <span class=filename>geom_CLASSNAME.so</span> exporta a estrutura <code>class_commands</code>, que é um array de elementos <code>struct g_command</code>. Os comandos têm um formato uniforme e se parecem com:</p></div><div class="literalblock programlisting"><div class=content><pre>  verb [-options] geomname [other]</pre></div></div><div class=paragraph><p>Verbos comuns são:</p></div><div class=ulist><ul><li><p>label - para escrever metadados nos dispositivos para que possam ser reconhecidos durante o processo de "tasting" e trazidos à tona em geoms</p></li><li><p>destroy - para destruir metadados, fazendo com que os geoms sejam destruídos</p></li></ul></div><div class=paragraph><p>Opções comuns são:</p></div><div class=ulist><ul><li><p><code>-v</code> : ser verboso (mostrar mais informações)</p></li><li><p><code>-f</code> : forçar</p></li></ul></div><div class=paragraph><p>Muitas ações, como rotular e destruir metadados, podem ser executadas no espaço de usuário. Para isso, <code>struct g_command</code> fornece o campo <code>gc_func</code>, que pode ser definido como uma função (no mesmo arquivo <span class=filename>.so</span>) que será chamada para processar um verbo. Se <code>gc_func</code> for NULL, o comando será passado para o módulo do kernel, para a função <code>.ctlreq</code> da classe geom.</p></div></div><div class=sect2><h3 id=geom-geoms>4.7. Geoms<a class=anchor href=#geom-geoms></a></h3><div class=paragraph><p>Os Geoms são instâncias das classes GEOM. Eles têm dados internos (uma estrutura softc) e algumas funções com as quais eles respondem a eventos externos.</p></div><div class=paragraph><p>As funções de evento são:</p></div><div class=ulist><ul><li><p><code>.access</code> : calcula as permissões (leitura/escrita/exclusiva)</p></li><li><p><code>.dumpconf</code> : uma função que retorna informações formatadas em XML sobre o geom</p></li><li><p><code>.orphan</code> : chamado quando algum provedor subjacente é desconectado</p></li><li><p><code>.spoiled</code> : chamado quando algum provedor subjacente é escrito</p></li><li><p><code>.start</code> : lida com operações de entrada/saída (I/O)</p></li></ul></div><div class=paragraph><p>Essas funções são chamadas a partir da thread do kernel <code>g_down</code> e não é permitido dormir nesse contexto (consulte a definição de dormir em outro lugar), o que limita bastante o que pode ser feito, mas força o tratamento a ser rápido.</p></div><div class=paragraph><p>A função mais importante para realizar trabalho útil é a função <code>.start()</code>, que é chamada quando uma solicitação BIO chega para um provider gerenciado por uma instância de classe geom.</p></div></div><div class=sect2><h3 id=geom-threads>4.8. Threads GEOM<a class=anchor href=#geom-threads></a></h3><div class=paragraph><p>Existem três threads de kernel criados e executados pelo framework GEOM:</p></div><div class=ulist><ul><li><p><code>g_down</code> : responsável por lidar com solicitações vindas de entidades de alto nível (como uma solicitação do espaço do usuário) a caminho de dispositivos físicos</p></li><li><p><code>g_up</code> : Lida com as respostas dos drivers de dispositivo às solicitações feitas por entidades de nível superior</p></li><li><p><code>g_event</code> : lida com todos os outros casos: criação de instâncias de geom, contagem de acesso, eventos de "spoil", etc.</p></li></ul></div><div class=paragraph><p>Quando um processo do usuário emite uma solicitação para "ler dados X no deslocamento Y de um arquivo", o seguinte acontece:</p></div><div class=ulist><ul><li><p>O sistema de arquivos converte o pedido em uma instância struct bio e o transmite para o subsistema GEOM. Ele sabe o que a instância geom deve manipular porque os sistemas de arquivos são hospedados diretamente em uma instância geom.</p></li><li><p>A requisição termina como uma chamada para a função <code>.start</code>() feita para a thread g_down e atinge a instância geom de nível superior.</p></li><li><p>Esta instância geom de nível superior (por exemplo, o "partition slicer") determina que a solicitação deve ser encaminhada para uma instância de nível inferior (por exemplo, o driver de disco). Ela faz uma cópia da solicitação bio (solicitações bio PRECISAM SEMPRE ser copiadas entre instâncias, com <code>g_clone_bio</code>()!), modifica o deslocamento dos dados e os campos do provider de destino e executa a cópia com <code>g_io_request</code>()</p></li><li><p>O driver de disco também recebe a requisição bio como uma chamada para <code>.start</code>() na thread <code>g_down</code>. Ele conversa com o hardware, recebe os dados de volta e chama <code>g_io_deliver</code>() na bio.</p></li><li><p>Agora, a notificação da conclusão do bio "sobe" na thread <code>g_up</code>. Primeiro, o particionador recebe <code>.done</code>() chamado na thread <code>g_up</code>, usa as informações armazenadas no bio para liberar a estrutura de <code>bio</code> clonada (com <code>g_destroy_bio</code>()) e chama <code>g_io_deliver</code>() no pedido original.</p></li><li><p>O sistema de arquivos obtém os dados e os transfere para o usuário.</p></li></ul></div><div class=paragraph><p>Consulte a página do manual <a href="https://man.freebsd.org/cgi/man.cgi?query=g_bio&amp;sektion=9&amp;format=html">g_bio(9)</a> para obter informações sobre como os dados são passados de um lado para o outro na estrutura <code>bio</code> (observe em particular os campos <code>bio_parent</code> e <code>bio_children</code> e como eles são manipulados).</p></div><div class=paragraph><p>Uma característica importante é que <em>NÃO PODEM HAVER CHAMADAS DE FUNÇÃO QUE BLOQUEIEM O PROCESSO (DURMAM) NAS THREADS G_UP E G_DOWN</em>. Isso significa que nenhuma das seguintes coisas pode ser feita nesses threads (a lista é apenas informativa e não completa):</p></div><div class=ulist><ul><li><p>Chamadas para <code>msleep</code>() e <code>tsleep</code>(), obviamente.</p></li><li><p>Chamadas para <code>g_write_data</code>() e <code>g_read_data()</code>, pois elas dormem entre a passagem dos dados para os consumidores e o retorno.</p></li><li><p>Aguardando I/O.</p></li><li><p>Chamadas a <a href="https://man.freebsd.org/cgi/man.cgi?query=malloc&amp;sektion=9&amp;format=html">malloc(9)</a> e <code>uma_zalloc</code>() com a flag <code>M_WAITOK</code> definida</p></li><li><p>sx e outros tipos de bloqueios sleepable</p></li></ul></div><div class=paragraph><p>Essa restrição foi imposta para evitar que o código GEOM obstrua o caminho de solicitação de E/S, já que a espera geralmente não está relacionada ao tempo e não há garantias sobre quanto tempo levará (há outras razões técnicas também). Isso também significa que não há muito o que se possa fazer nessas threads; por exemplo, quase qualquer coisa complexa requer alocação de memória. Felizmente, há uma saída: criar threads adicionais do kernel.</p></div></div><div class=sect2><h3 id=geom-kernelthreads>4.9. Threads de kernel para uso no código GEOM<a class=anchor href=#geom-kernelthreads></a></h3><div class=paragraph><p>Threads do Kernel são criados com a função <a href="https://man.freebsd.org/cgi/man.cgi?query=kthread_create&amp;sektion=9&amp;format=html">kthread_create(9)</a>, e eles são parecidos com threads de espaço de usuário em termos de comportamento, apenas que não podem retornar ao chamador para indicar término, mas devem chamar <a href="https://man.freebsd.org/cgi/man.cgi?query=kthread_exit&amp;sektion=9&amp;format=html">kthread_exit(9)</a>.</p></div><div class=paragraph><p>No código do GEOM, o uso usual de threads é para descarregar o processamento de solicitações da thread <code>g_down</code> (a função <code>.start()</code>). Essas threads se parecem com "manipuladores de eventos": elas têm uma lista vinculada de eventos associados a elas (na qual eventos podem ser postados por várias funções em várias threads, então ela deve ser protegida por um mutex), pegam os eventos da lista um por um e os processam em uma grande declaração <code>switch()</code>.</p></div><div class=paragraph><p>O principal benefício de usar uma thread para lidar com as solicitações de E/S é que ela pode dormir quando necessário. Agora, isso parece bom, mas deve ser cuidadosamente pensado. Dormir é bem conveniente, mas pode destruir efetivamente o desempenho da transformação geom. As classes extremamente sensíveis ao desempenho provavelmente devem fazer todo o trabalho na chamada de função <code>.start()</code>, tendo muito cuidado para lidar com erros de falta de memória e similares.</p></div><div class=paragraph><p>O outro benefício de ter uma thread de tratamento de eventos é a serialização de todas as solicitações e respostas vindas de diferentes threads do geom em uma única thread. Isso também é muito conveniente, mas pode ser lento. Na maioria dos casos, o tratamento de solicitações <code>.done</code>() pode ser deixado para a thread <code>g_up</code>.</p></div><div class=paragraph><p>Mutexes no kernel do FreeBSD (veja <a href="https://man.freebsd.org/cgi/man.cgi?query=mutex&amp;sektion=9&amp;format=html">mutex(9)</a>) possuem uma distinção em relação às suas contrapartes mais comuns no userland - o código não pode dormir enquanto segura um mutex. Se o código precisa dormir muito, as travas <a href="https://man.freebsd.org/cgi/man.cgi?query=sx&amp;sektion=9&amp;format=html">sx(9)</a> podem ser mais apropriadas. Por outro lado, se você fizer quase tudo em um único thread, pode se livrar completamente do uso de mutexes.</p></div></div></div></div><hr><div class=last-modified><p><strong>Última alteração em</strong>: 4 de maio de 2023 por <a href="https://cgit.freebsd.org/doc/commit/?id=c769bddba1" target=_blank>Edson Brandi</a></p></div></div><aside class=toc><div class=toc-content><h3>Índice</h3><nav id=TableOfContents><ul><li><a href=#intro>1. Introdução</a></li><li><a href=#prelim>2. Preliminares</a></li><li><a href=#kernelprog>3. Programação do kernel do FreeBSD</a></li><li><a href=#geom>4. Programação GEOM</a></li></ul></nav><hr><div class=resources><h3>Recursos</h3><ul class=contents><li><i class="fa fa-file-pdf-o" aria-hidden=true title="Download PDF"></i><a href=https://download.freebsd.org/doc/pt-br/articles/geom-class/geom-class_pt-br.pdf>Download PDF</a></li><li><i class="fa fa-pencil-square-o" aria-hidden=true title="Edite essa página"></i><a href=https://github.com/freebsd/freebsd-doc/blob/main/documentation/content/pt-br/_index target=_blank>Edite essa página</a></li></ul></div></div></aside></main><footer><div class=footer-container><section class=logo-column><img src=http://172.16.201.134:1313/images/FreeBSD-colors.svg width=160 height=50 alt="FreeBSD logo"><div class=options-container><div class=language-container><a id=languages href=http://172.16.201.134:1313/pt-br/languages><img src=http://172.16.201.134:1313/images/language.png class=language-image alt="Escolha o idioma">
<span>Brazilian Portuguese</span></a></div><div class=theme-container><select id=theme-chooser><option value=theme-system>System</option><option value=theme-light>Light</option><option value=theme-dark>Dark</option><option value=theme-high-contrast>Alto contraste</option></select></div></div></section><section class=about-column><h3 class=column-title>About</h3><ul class=column-elements-container><li><a href=https://www.freebsd.org/about/ target=_blank class=column-element>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/ target=_blank class=column-element>FreeBSD Foundation</a></li><li><a href=https://www.freebsd.org/where/ target=_blank class=column-element>Get FreeBSD</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct target=_blank class=column-element>Code of Conduct</a></li><li><a href=https://www.freebsd.org/security/ target=_blank class=column-element>Security Advisories</a></li></ul></section><section class=documentation-column><h3 class=column-title>Documentation</h3><ul class=column-elements-container><li><a href=/pt-br class=column-element>Documentation portal</a></li><li><a href=https://man.FreeBSD.org target=_blank class=column-element>Manual pages</a></li><li><a href=https://papers.FreeBSD.org target=_blank class=column-element>Presentations and papers</a></li><li><a href=https://docs-archive.freebsd.org/doc/ target=_blank class=column-element>Previous versions</a></li><li><a href=https://docs-archive.freebsd.org/44doc/ target=_blank class=column-element>4.4BSD Documents</a></li><li><a href=https://wiki.freebsd.org/ target=_blank class=column-element>Wiki</a></li></ul></section><section class=community-column><h3 class=column-title>Community</h3><ul class=column-elements-container><li><a href=http://172.16.201.134:1313/pt-br/articles/contributing class=column-element>Get involved</a></li><li><a href=https://forums.freebsd.org/ target=_blank class=column-element>Community forum</a></li><li><a href=https://lists.freebsd.org/ target=_blank class=column-element>Mailing lists</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank class=column-element>IRC Channels</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank class=column-element>Bug Tracker</a></li></ul></section><section class=legal-column><h3 class=column-title>Legal</h3><ul class=column-elements-container><li><a href=https://freebsdfoundation.org/donate/ target=_blank class=column-element>Donations</a></li><li><a href=https://www.freebsd.org/copyright/freebsd-license/ target=_blank class=column-element>Licensing</a></li><li><a href=https://www.freebsd.org/privacy/ target=_blank class=column-element>Privacy Policy</a></li><li><a href=https://www.freebsd.org/copyright/ target=_blank class=column-element>Legal notices</a></li></ul></section><section class=copyright-column><p>&copy; 1994-2024 The FreeBSD Project. All rights reserved</p><span>Made with <span class=heart>♥</span> by the FreeBSD Community</span></section></div></footer></body></html>