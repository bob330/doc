<!doctype html><html class=theme-light lang=pt-br><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content><meta name=keywords content><meta name=copyright content="1995-2024 The FreeBSD Foundation"><link rel=canonical href=https://docs.freebsd.org/pt-br/articles/vinum/><title>O Gerenciador de Volume vinum | FreeBSD Documentation Portal</title>
<meta name=theme-color content="#790000"><meta name=color-scheme content="system light dark high-contrast"><link rel="shortcut icon" href=https://docs.freebsd.org/favicon.ico><link rel=stylesheet href=https://docs.freebsd.org/styles/main.min.css><link rel=stylesheet href=https://docs.freebsd.org/css/font-awesome-min.css><script defer src=/js/theme-chooser.min.js></script><script defer src=/js/copy-clipboard.min.js></script><script defer src=/js/search.min.js></script><meta name=twitter:card content="summary"><meta name=twitter:domain content="docs.FreeBSD.org"><meta name=twitter:site content="@freebsd"><meta name=twitter:url content="https://twitter.com/freebsd"><meta property="og:title" content="O Gerenciador de Volume vinum"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:image" content="https://docs.freebsd.org/favicon.ico"><meta property="og:image:alt" content="FreeBSD Logo"><meta property="og:locale" content="pt-br"><meta property="og:url" content="https://docs.freebsd.org/pt-br/articles/vinum/"><meta property="og:site_name" content="FreeBSD Documentation Portal"><script type=application/ld+json>{"@context":"http://schema.org","@type":"Article","url":"https:\/\/docs.freebsd.org\/pt-br\/articles\/vinum\/","name":"FreeBSD Documentation Portal","headline":"FreeBSD Documentation Portal","description":"FreeBSD Documentation Portal"}</script></head><body><header><div class=header-container><div class=logo-menu-bars-container><a href=https://www.FreeBSD.org class=logo><img src=https://docs.freebsd.org/images/FreeBSD-monochromatic.svg width=160 height=50 alt="FreeBSD logo">
</a><label class=menu-bars for=menu-bars><i class="fa fa-bars" aria-hidden=true></i></label></div><input id=menu-bars type=checkbox><nav><ul class=menu><li class=menu-item><input id=about type=checkbox>
<a href=# aria-label="Navigate to About section"><label class=menu-item-description for=about>About
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/about/ target=_blank>About</a></li><li><a href=https://www.freebsd.org/about/ target=_blank>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/about-us/about-the-foundation/ target=_blank>FreeBSD Foundation</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct/ target=_blank>Code of Conduct</a></li></ul></li><li class=menu-item><input id=download type=checkbox>
<a href=# aria-label="Navigate to get FreeBSD section"><label class=menu-item-description for=download>Get FreeBSD
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/where/ target=_blank>Get FreeBSD</a></li><li><a href=https://www.freebsd.org/releases/ target=_blank>Release Information</a></li><li><a href=https://www.freebsd.org/releng/ target=_blank>Release Engineering</a></li><li><a href=https://www.freebsd.org/security/ target=_blank>Security Advisories</a></li></ul></li><li class=menu-item><input id=documentation type=checkbox>
<a href=# aria-label="Navigate to get Documentation section"><label class=menu-item-description for=documentation>Documentation
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=/pt-br>Documentation portal</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook>FreeBSD Handbook</a></li><li><a href=https://docs.freebsd.org/pt-br/books/porters-handbook>Porter's Handbook</a></li><li><a href=https://docs.FreeBSD.org/en/books/fdp-primer>Documentation Project Handbook</a></li><li><a href=https://man.FreeBSD.org target=_blank>Manual pages</a></li><li><a href=https://papers.FreeBSD.org target=_blank>Presentations and papers</a></li><li><a href=https://wiki.FreeBSD.org target=_blank>Wiki</a></li><li><a href=https://docs.freebsd.org/pt-br/books>Books</a></li><li><a href=https://docs.freebsd.org/pt-br/articles>Articles</a></li></ul></li><li class=menu-item><input id=community type=checkbox>
<a href=# aria-label="Navigate to get Community section"><label class=menu-item-description for=community>Community
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/community/>Community</a></li><li><a href=https://docs.freebsd.org/pt-br/articles/contributing>Get involved</a></li><li><a href=https://forums.freebsd.org/ target=_blank>Forum</a></li><li><a href=https://lists.freebsd.org/ target=_blank>Mailing lists</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank>IRC Channels</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank>Bug Tracker</a></li><li><a href=https://www.freebsd.org/support/ target=_blank>Support</a></li></ul></li></ul></nav><div class=search-donate-container><form class=search method=get id=search-header-form action=https://docs.freebsd.org/search name=search-header-form><input type=hidden name=DB value=pt-br>
<input id=words name=P type=text size=20 maxlength=255>
<button>
<i class="fa fa-search" aria-hidden=true></i></button></form><div class=donate><a href=https://freebsdfoundation.org/donate/ target=_blank><span class=heart>♥</span>
Donate</a></div></div></div></header><main class=main-wrapper-article><div class=article><h1 class=title>O Gerenciador de Volume vinum</h1><div class="admonitionblock note"><p><i class="fa fa-exclamation-circle" aria-hidden=true></i>
Esta tradução pode estar desatualizada. Para ajudar com as traduções, acesse a <a href=https://translate-dev.freebsd.org/ target=_blank>ferramenta de traduções do FreeBSD</a>.</p></div><div class=toc-mobile><h3>Índice</h3><nav id=TableOfContents><ul><li><a href=#vinum-synopsis>1. Sinopse</a></li><li><a href=#vinum-access-bottlenecks>2. Gargalos de Acesso</a></li><li><a href=#vinum-data-integrity>3. Integridade de dados</a></li><li><a href=#vinum-objects>4. Objetos do <span class=filename>vinum</span></a></li><li><a href=#vinum-examples>5. Alguns exemplos</a></li><li><a href=#vinum-object-naming>6. Nomeação de Objetos</a></li><li><a href=#vinum-config>7. Configurando o <span class=filename>vinum</span></a></li><li><a href=#vinum-root>8. Usando o <span class=filename>vinum</span> para o sistema de arquivos raiz</a></li></ul></nav></div><div id=preamble><div class=sectionbody><hr></div></div><div class=sect1><h2 id=vinum-synopsis>1. Sinopse<a class=anchor href=#vinum-synopsis></a></h2><div class=sectionbody><div class=paragraph><p>Não importa o tipo de disco, sempre há problemas em potencial. Os discos podem ser muito pequenos, muito lentos ou pouco confiáveis para atender aos requisitos do sistema. Enquanto os discos estão ficando maiores, também ficam maiores os requisitos para armazenamento de dados. Geralmente, é necessário um sistema de arquivos maior que a capacidade de um disco. Várias soluções para esses problemas foram propostas e implementadas.</p></div><div class=paragraph><p>Um método é através do uso de vários discos, e às vezes discos redundantes. Além de suportar várias placas e controladoras para sistemas <code>RAID</code> (Redundant Array of Independent Disks), o sistema básico do FreeBSD inclui o gerenciador de volumes <span class=filename>vinum</span>, um driver de dispositivo de bloco que implementa discos virtuais e aborda esses três problemas. O <span class=filename>vinum</span> oferece mais flexibilidade, desempenho e confiabilidade do que o armazenamento em disco tradicional e implementa os modelos <code>RAID</code>-0, <code>RAID</code>-1 e <code>RAID</code>-5, tanto individualmente quanto combinados.</p></div><div class=paragraph><p>Este capítulo fornece uma visão geral dos possíveis problemas com o armazenamento em disco tradicional e uma introdução ao gerenciador de volumes <span class=filename>vinum</span>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Começando com o FreeBSD 5, o <span class=filename>vinum</span> foi reescrito para se encaixar na <a href=https://docs.freebsd.org/pt-br/books/handbook/book/geom#geom>Arquitetura GEOM</a>, mantendo as idéias originais, a terminologia e os metadados no disco. Esta reescrita é chamada <em>gvinum</em> (para <em>GEOM vinum</em>). Enquanto este capítulo usa o termo <span class=filename>vinum</span>, qualquer invocação de comandos deve ser executada com o <code>gvinum</code>. O nome do módulo do kernel mudou do original <span class=filename>vinum.ko</span> para <span class=filename>geom_vinum.ko</span>, e todos os device nodes residem em <span class=filename>/dev/gvinum</span> em vez de <span class=filename>/dev/vinum</span>. A partir do FreeBSD 6, a implementação original do <span class=filename>vinum</span> não está mais disponível no código base.</p></div></td></tr></tbody></table></div></div></div><div class=sect1><h2 id=vinum-access-bottlenecks>2. Gargalos de Acesso<a class=anchor href=#vinum-access-bottlenecks></a></h2><div class=sectionbody><div class=paragraph><p>Sistemas modernos frequentemente precisam acessar dados de uma maneira altamente concorrente. Por exemplo, grandes servidores FTP ou HTTP podem manter milhares de sessões simultâneas e ter múltiplas conexões de 100 Mbit/s para o mundo externo, muito além da taxa de transferência sustentada da maioria dos discos.</p></div><div class=paragraph><p>As unidades de disco atuais podem transferir dados sequencialmente a até 70 MB/s, mas esse valor é de pouca importância em um ambiente em que muitos processos independentes acessam uma unidade e onde podem obter apenas uma fração desses valores. Nesses casos, é mais interessante visualizar o problema do ponto de vista do subsistema de disco. O parâmetro importante é a carga que uma transferência coloca no subsistema ou o tempo pelo qual uma transferência ocupa as unidades envolvidas na transferência.</p></div><div class=paragraph><p>Em qualquer transferência de disco, a unidade deve primeiro posicionar as cabeças, aguardar que o primeiro setor passe sob a cabeça de leitura e depois realizar a transferência. Essas ações podem ser consideradas atômicas, pois não faz sentido interrompê-las.</p></div><div class=paragraph><p><a id=vinum-latency></a>Considere uma transferência típica de cerca de 10 kB: a geração atual de discos de alto desempenho pode posicionar as cabeças em uma média de 3,5 ms. As unidades mais rápidas giram a 15.000 rpm, portanto a latência rotacional média (meia revolução) é de 2 ms. A 70 MB/s, a própria transferência leva cerca de 150 μs, quase nada em comparação com o tempo de posicionamento. Nesse caso, a taxa de transferência efetiva cai para pouco mais de 1 MB/s e é claramente altamente dependente do tamanho da transferência.</p></div><div class=paragraph><p>A solução tradicional e óbvia para esse gargalo é "mais eixos": em vez de usar um disco grande, use vários discos menores com o mesmo espaço de armazenamento agregado. Cada disco é capaz de se posicionar e transferir de forma independente, portanto, o rendimento efetivo aumenta em um fator próximo ao número de discos usados.</p></div><div class=paragraph><p>A melhoria real da taxa de transferência é menor que o número de discos envolvidos. Embora cada unidade seja capaz de transferir em paralelo, não há como garantir que as solicitações sejam distribuídas uniformemente pelas unidades. Inevitavelmente, a carga em uma unidade será maior que em outra.</p></div><div class=paragraph><p>A uniformidade da carga nos discos é fortemente dependente da maneira como os dados são compartilhados entre as unidades. Na discussão a seguir, é conveniente pensar no armazenamento em disco como um grande número de setores de dados que são endereçáveis por número, mais ou menos como as páginas de um livro. O método mais óbvio é dividir o disco virtual em grupos de setores consecutivos do tamanho dos discos físicos individuais e armazená-los dessa maneira, mais ou menos como pegar um livro grande e dividi-lo em seções menores. Esse método é chamado de <em>concatenação</em> e tem a vantagem de os discos não precisarem ter nenhum relacionamento de tamanho específico. Ele funciona bem quando o acesso ao disco virtual é distribuído uniformemente sobre seu espaço de endereço. Quando o acesso é concentrado em uma área menor, a melhoria é menos acentuada. <a href=#vinum-concat>Concatenated Organization</a> ilustra a seqüência na qual as unidades de armazenamento são alocadas em uma organização concatenada.</p></div><div id=vinum-concat class=imageblock><div class=content><img src=../../../images/articles/vinum/vinum-concat.png alt="vinum concat"></div><div class=title>Figura 1. Organização Concatenada</div></div><div class=paragraph><p>Um mapeamento alternativo é dividir o espaço de endereço em componentes menores e de tamanhos iguais e armazená-los sequencialmente em diferentes dispositivos. Por exemplo, os primeiros 256 setores podem ser armazenados no primeiro disco, os próximos 256 setores no próximo disco e assim por diante. Depois de preencher o último disco, o processo é repetido até que os discos estejam cheios. Este mapeamento é chamado <em>striping</em> ou RAID-0.</p></div><div class=paragraph><p>O <code>RAID</code> oferece várias formas de tolerância a falhas, embora o RAID-0 seja um pouco enganador, pois não fornece redundância. O striping requer um pouco mais de esforço para localizar os dados e pode causar carga de I/O (INPUT/OUTPUT) adicional, onde uma transferência é distribuída por vários discos, mas também pode fornecer uma carga mais constante nos discos. <a href=#vinum-striped>Striped Organization</a> ilustra a seqüência na qual as unidades de armazenamento são alocadas em uma organização distribuída.</p></div><div id=vinum-striped class=imageblock><div class=content><img src=../../../images/articles/vinum/vinum-striped.png alt="vinum striped"></div><div class=title>Figura 2. Organização do modo distribuido (Striped)</div></div></div></div><div class=sect1><h2 id=vinum-data-integrity>3. Integridade de dados<a class=anchor href=#vinum-data-integrity></a></h2><div class=sectionbody><div class=paragraph><p>O problema final com os discos é que eles não são confiáveis. Embora a confiabilidade tenha aumentado tremendamente nos últimos anos, as unidades de disco ainda são o componente central mais provável de um servidor para falhar. Quando o fazem, os resultados podem ser catastróficos e substituir uma unidade de disco com falha e a restauração de dados pode resultar em tempo de inatividade do servidor.</p></div><div class=paragraph><p>Uma abordagem para esse problema é o <em>mirroring (espelhamento)</em>, ou RAID-1, que mantém duas cópias dos dados em diferentes hardwares físicos. Qualquer gravação no volume grava em ambos os discos; uma leitura pode ser satisfeita de qualquer um, portanto, se uma unidade falhar, os dados ainda estarão disponíveis na outra unidade.</p></div><div class=paragraph><p>O mirroring tem dois problemas:</p></div><div class=ulist><ul><li><p>Requer o dobro de armazenamento em disco que uma solução não redundante.</p></li><li><p>As gravações devem ser executadas em ambas as unidades, então ela usa o dobro da largura de banda de um volume não espelhado. As leituras não sofrem uma penalidade de desempenho e podem até ser mais rápidas.</p></li></ul></div><div class=paragraph><p>Uma solução alternativa é a <em>parity (paridade)</em>, implementada nos níveis <code>RAID</code> 2, 3, 4 e 5. Destes, o RAID-5 é o mais interessante. Como implementado no <span class=filename>vinum</span>, é uma variante em uma organização striped que dedica um bloco de cada distribuição à paridade de um dos outros blocos. Como implementado por <span class=filename>vinum</span>, um plex RAID-5 é semelhante a um plex striped, exceto que ele implementa RAID-5 incluindo um bloco de paridade em cada stripe. Conforme exigido pelo RAID-5, o local desse bloco de paridade muda de um stripe para o próximo. Os números nos blocos de dados indicam os números de blocos relativos.</p></div><div id=vinum-raid5-org class=imageblock><div class=content><img src=../../../images/articles/vinum/vinum-raid5-org.png alt="vinum raid5 org"></div><div class=title>Figura 3. Organização <code>RAID</code>-5</div></div><div class=paragraph><p>Comparado ao mirroring, o RAID-5 tem a vantagem de exigir significativamente menos espaço de armazenamento. O acesso de leitura é semelhante ao das organizações distribuídas, mas o acesso de gravação é significativamente mais lento, aproximadamente 25% do desempenho de leitura. Se uma unidade falhar, a matriz pode continuar a operar no modo degradado, onde uma leitura de uma das unidades acessíveis restantes continua normalmente, mas uma leitura da unidade com falha é recalculada a partir do bloco correspondente de todas as unidades restantes.</p></div></div></div><div class=sect1><h2 id=vinum-objects>4. Objetos do <span class=filename>vinum</span><a class=anchor href=#vinum-objects></a></h2><div class=sectionbody><div class=paragraph><p>A fim de resolver estes problemas, o <span class=filename>vinum</span> implementa uma hierarquia de quatro níveis de objetos:</p></div><div class=ulist><ul><li><p>O objeto mais visível é o disco virtual, chamado <em>volume</em>. Os volumes têm essencialmente as mesmas propriedades de uma unidade de disco UNIX®, embora haja algumas pequenas diferenças. Por um lado, eles não têm limitações de tamanho.</p></li><li><p>Os volumes são compostos de <em>plexes</em>, cada um dos quais representa o espaço de endereço total de um volume. Este nível na hierarquia fornece redundância. Pense em plexes como discos individuais em uma matriz espelhada, cada um contendo os mesmos dados.</p></li><li><p>Como o <span class=filename>vinum</span> existe dentro do framework de armazenamento em disco UNIX®, seria possível usar as partições UNIX® como bloco de construção para plexes de vários discos. Na verdade, isso acaba sendo muito inflexível, pois os discos UNIX® podem ter apenas um número limitado de partições. Em vez disso, o <span class=filename>vinum</span> subdivide uma única partição UNIX®, a <em>unidade</em>, em áreas contíguas chamadas <em>subdiscos</em> , que são usados como blocos de construção para plexes.</p></li><li><p>Subdiscos residem em <span class=filename>vinum</span> <em>drives</em>, atualmente partições UNIX®. Unidades <span class=filename>vinum</span> podem conter qualquer número de subdiscos. Com exceção de uma pequena área no início da unidade, que é usada para armazenar informações de configuração e estado, a unidade inteira está disponível para armazenamento de dados.</p></li></ul></div><div class=paragraph><p>As seções a seguir descrevem a maneira como esses objetos fornecem a funcionalidade necessária do <span class=filename>vinum</span>.</p></div><div class=sect2><h3 id=_considerações_sobre_o_tamanho_do_volume>4.1. Considerações sobre o tamanho do volume<a class=anchor href=#_considerações_sobre_o_tamanho_do_volume></a></h3><div class=paragraph><p>Os plexes podem incluir vários subdiscos distribuídos por todas as unidades na configuração <span class=filename>vinum</span>. Como resultado, o tamanho de uma unidade individual não limita o tamanho de um plex ou de um volume.</p></div></div><div class=sect2><h3 id=_armazenamento_de_dados_redundantes>4.2. Armazenamento de Dados Redundantes<a class=anchor href=#_armazenamento_de_dados_redundantes></a></h3><div class=paragraph><p>O <span class=filename>vinum</span> implementa o espelhamento anexando vários plexes a um volume. Cada plex é uma representação dos dados em um volume. Um volume pode conter entre um e oito plexes.</p></div><div class=paragraph><p>Embora um plex represente os dados completos de um volume, é possível que partes da representação estejam fisicamente ausentes, seja por design (por não definir um subdisco para partes do plex) ou por acidente (como resultado da falha de representação). Contanto que pelo menos um plex possa fornecer os dados para o intervalo de endereços completo do volume, o volume estará totalmente funcional.</p></div></div><div class=sect2><h3 id=_quais_são_as_organizações_disponíveis_para_um_plex>4.3. Quais são as organizações disponíveis para um Plex?<a class=anchor href=#_quais_são_as_organizações_disponíveis_para_um_plex></a></h3><div class=paragraph><p>O <span class=filename>vinum</span> implementa a concatenação e o striping no nível plex:</p></div><div class=ulist><ul><li><p>Um <em>plex concatenado</em> usa o espaço de endereço de cada subdisco um de cada vez. Plexes concatenados são os mais flexíveis, pois podem conter qualquer número de subdiscos e os subdiscos podem ser de tamanho diferente. O plex pode ser estendido adicionando subdiscos adicionais. Eles exigem menos tempo de CPU do que os plexes distribuídos, embora a diferença na sobrecarga de CPU não seja mensurável. Por outro lado, eles são mais suscetíveis a hot spots, nos quais um disco é muito ativo e outros ficam ociosos.</p></li><li><p>Um <em>plex striped</em> distribui os dados uniformemente entre cada subdisco. Os subdiscos devem ser todos do mesmo tamanho e deve haver pelo menos dois subdiscos para distingui-los de um plex concatenado. A maior vantagem dos plexes striped é que eles reduzem os hot spots. Ao escolher uma faixa de tamanho ideal, de cerca de 256 kB, a carga pode ser nivelada nas unidades de componentes. Estender um complexo adicionando novos subdiscos é algo tão complicado que o <span class=filename>vinum</span> não o implementa.</p></li></ul></div><div class=paragraph><p><a href=#vinum-comparison><span class=filename>vinum</span> Plex Organizations</a> resume as vantagens e desvantagens de cada organização plex.</p></div><table id=vinum-comparison class="tableblock frame-none grid-all stretch"><caption class=title>Tabela 1. Organizações Plex do <span class=filename>vinum</span></caption><col style=width:20%><col style=width:20%><col style=width:20%><col style=width:20%><col style=width:20%><thead><tr><th class="tableblock halign-left valign-top">Tipo plex</th><th class="tableblock halign-left valign-top">Subdiscos mínimos</th><th class="tableblock halign-left valign-top">Pode adicionar subdiscos</th><th class="tableblock halign-left valign-top">Deve ser de tamanho igual</th><th class="tableblock halign-left valign-top">Aplicação</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>concatenado</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>1</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>sim</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>não</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Armazenamento de dados grandes com flexibilidade máxima de posicionamento e desempenho moderado</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>striped</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>2</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>não</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>sim</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Alto desempenho em combinação com acesso altamente concorrente</p></td></tr></tbody></table></div></div></div><div class=sect1><h2 id=vinum-examples>5. Alguns exemplos<a class=anchor href=#vinum-examples></a></h2><div class=sectionbody><div class=paragraph><p>O <span class=filename>vinum</span> mantém um <em>banco de dados de configuração</em> que descreve os objetos conhecidos de um sistema individual. Inicialmente, o usuário cria o banco de dados de configuração a partir de um ou mais arquivos de configuração usando <a href="https://man.freebsd.org/cgi/man.cgi?query=gvinum&amp;sektion=8&amp;format=html">gvinum(8)</a>. O <span class=filename>vinum</span> armazena uma cópia de seu banco de dados de configuração em cada <em>dispositivo</em> de disco sob seu controle. Este banco de dados é atualizado em cada mudança de estado, de modo que uma reinicialização restaura com precisão o estado de cada objeto <span class=filename>vinum</span>.</p></div><div class=sect2><h3 id=_o_arquivo_de_configuração>5.1. O arquivo de configuração<a class=anchor href=#_o_arquivo_de_configuração></a></h3><div class=paragraph><p>O arquivo de configuração descreve objetos <span class=filename>vinum</span> individuais. A definição de um volume simples pode ser:</p></div><div class="literalblock programlisting"><div class=content><pre>    drive a device /dev/da3h
    volume myvol
      plex org concat
        sd length 512m drive a</pre></div></div><div class=paragraph><p>Este arquivo descreve quatro objetos <span class=filename>vinum</span>:</p></div><div class=ulist><ul><li><p>A linha <em>drive</em> descreve uma partição de disco (<em>drive</em>) e sua localização relativa ao hardware subjacente. É dado o nome simbólico <em>a</em>. Essa separação de nomes simbólicos de nomes de dispositivos permite que os discos sejam movidos de um local para outro sem confusão.</p></li><li><p>A linha <em>volume</em> descreve um volume. O único atributo obrigatório é o nome, neste caso <em>myvol</em>.</p></li><li><p>A linha <em>plex</em> define um plex. O único parâmetro requerido é a organização, neste caso <em>concat</em>. Nenhum nome é necessário, pois o sistema gera automaticamente um nome a partir do nome do volume, adicionando o sufixo <em>.px</em>, onde <em>x</em> é o número de o plex no volume. Assim, este plex será chamado <em>myvol.p0</em>.</p></li><li><p>A linha <em>sd</em> descreve um subdisco. As especificações mínimas são o nome de uma unidade na qual irá armazená-lo e o tamanho do subdisco. Nenhum nome é necessário porque o sistema atribui automaticamente nomes derivados do nome do plex adicionando o sufixo <em>.sx</em>, onde <em>x</em> é o número do subdisco no plex. Assim, <span class=filename>vinum</span> dá ao subdisco o nome <em>myvol.p0.s0</em>.</p></li></ul></div><div class=paragraph><p>Depois de processar este arquivo, o <a href="https://man.freebsd.org/cgi/man.cgi?query=gvinum&amp;sektion=8&amp;format=html">gvinum(8)</a> produz a seguinte saída:</p></div><div class="literalblock programlisting"><div class=content><pre># gvinum -&gt; create config1
Configuration summary
Drives:         1 (4 configured)
Volumes:        1 (4 configured)
Plexes:         1 (8 configured)
Subdisks:       1 (16 configured)

  D a                     State: up       Device /dev/da3h      Avail: 2061/2573 MB (80%)

  V myvol                 State: up       Plexes:       1 Size:      512 MB

  P myvol.p0            C State: up       Subdisks:     1 Size:      512 MB

  S myvol.p0.s0           State: up       PO:        0  B Size:      512 MB</pre></div></div><div class=paragraph><p>Esta saída mostra o formato de listagem breve de <a href="https://man.freebsd.org/cgi/man.cgi?query=gvinum&amp;sektion=8&amp;format=html">gvinum(8)</a>. Ele está representado graficamente em <a href=#vinum-simple-vol>A Simple <span class=filename>vinum</span> Volume</a>.</p></div><div id=vinum-simple-vol class=imageblock><div class=content><img src=../../../images/articles/vinum/vinum-simple-vol.png alt="vinum simple vol"></div><div class=title>Figura 4. Um volume <span class=filename>vinum</span> simples</div></div><div class=paragraph><p>Esta figura, e as que se seguem, representam um volume, que contém os plexes, que por sua vez contém os subdiscos. Neste exemplo, o volume contém um plex e o plex contém um subdisco.</p></div><div class=paragraph><p>Este volume específico não tem nenhuma vantagem específica sobre uma partição de disco convencional. Ele contém um único plex, por isso não é redundante. O plex contém um único subdisco, portanto, não há diferença na alocação de armazenamento de uma partição de disco convencional. As seções a seguir ilustram vários métodos de configuração mais interessantes.</p></div></div><div class=sect2><h3 id=_maior_resiliência_espelhamento>5.2. Maior Resiliência: Espelhamento<a class=anchor href=#_maior_resiliência_espelhamento></a></h3><div class=paragraph><p>A resiliência de um volume pode ser aumentada pelo espelhamento. Ao dispor um volume espelhado, é importante garantir que os subdiscos de cada plex estejam em unidades diferentes, de modo que uma falha no dispositivo não derrubará os dois plexes. A configuração a seguir espelha um volume:</p></div><div class="literalblock programlisting"><div class=content><pre>	drive b device /dev/da4h
	volume mirror
      plex org concat
        sd length 512m drive a
	  plex org concat
	    sd length 512m drive b</pre></div></div><div class=paragraph><p>Neste exemplo, não foi necessário especificar uma definição de drive <em>a</em> novamente, já que o <span class=filename>vinum</span> registra todos os objetos em seu banco de dados de configuração. Depois de processar esta definição, a configuração se parece com:</p></div><div class="literalblock programlisting"><div class=content><pre>	Drives:         2 (4 configured)
	Volumes:        2 (4 configured)
	Plexes:         3 (8 configured)
	Subdisks:       3 (16 configured)

	D a                     State: up       Device /dev/da3h       Avail: 1549/2573 MB (60%)
	D b                     State: up       Device /dev/da4h       Avail: 2061/2573 MB (80%)

    V myvol                 State: up       Plexes:       1 Size:        512 MB
    V mirror                State: up       Plexes:       2 Size:        512 MB

    P myvol.p0            C State: up       Subdisks:     1 Size:        512 MB
    P mirror.p0           C State: up       Subdisks:     1 Size:        512 MB
    P mirror.p1           C State: initializing     Subdisks:     1 Size:        512 MB

    S myvol.p0.s0           State: up       PO:        0  B Size:        512 MB
	S mirror.p0.s0          State: up       PO:        0  B Size:        512 MB
	S mirror.p1.s0          State: empty    PO:        0  B Size:        512 MB</pre></div></div><div class=paragraph><p><a href=#vinum-mirrored-vol>A Mirrored <span class=filename>vinum</span> Volume</a> mostra a estrutura graficamente.</p></div><div id=vinum-mirrored-vol class=imageblock><div class=content><img src=../../../images/articles/vinum/vinum-mirrored-vol.png alt="vinum mirrored vol"></div><div class=title>Figura 5. Um volume <span class=filename>vinum</span> espelhado</div></div><div class=paragraph><p>Neste exemplo, cada plex contém os 512 MB completos do espaço de endereço. Como no exemplo anterior, cada plex contém apenas um único subdisco.</p></div></div><div class=sect2><h3 id=_otimizando_o_desempenho>5.3. Otimizando o desempenho<a class=anchor href=#_otimizando_o_desempenho></a></h3><div class=paragraph><p>O volume espelhado no exemplo anterior é mais resistente a falhas do que um volume não espelhado, mas seu desempenho é menor, pois cada gravação no volume requer uma gravação nas duas unidades, utilizando uma grande parte da largura de banda total do disco. As considerações de desempenho exigem uma abordagem diferente: em vez de espelhar, os dados são distribuídos em quantas unidades de disco forem possíveis. A configuração a seguir mostra um volume com um plex distribuído em quatro unidades de disco:</p></div><div class="literalblock programlisting"><div class=content><pre>	drive c device /dev/da5h
	drive d device /dev/da6h
	volume stripe
	plex org striped 512k
	  sd length 128m drive a
	  sd length 128m drive b
	  sd length 128m drive c
	  sd length 128m drive d</pre></div></div><div class=paragraph><p>Como antes, não é necessário definir as unidades que já são conhecidas por <span class=filename>vinum</span>. Depois de processar esta definição, a configuração se parece com:</p></div><div class="literalblock programlisting"><div class=content><pre>	Drives:         4 (4 configured)
	Volumes:        3 (4 configured)
	Plexes:         4 (8 configured)
	Subdisks:       7 (16 configured)

    D a                     State: up       Device /dev/da3h        Avail: 1421/2573 MB (55%)
    D b                     State: up       Device /dev/da4h        Avail: 1933/2573 MB (75%)
    D c                     State: up       Device /dev/da5h        Avail: 2445/2573 MB (95%)
    D d                     State: up       Device /dev/da6h        Avail: 2445/2573 MB (95%)

    V myvol                 State: up       Plexes:       1 Size:        512 MB
    V mirror                State: up       Plexes:       2 Size:        512 MB
    V striped               State: up       Plexes:       1 Size:        512 MB

    P myvol.p0            C State: up       Subdisks:     1 Size:        512 MB
    P mirror.p0           C State: up       Subdisks:     1 Size:        512 MB
    P mirror.p1           C State: initializing     Subdisks:     1 Size:        512 MB
    P striped.p1            State: up       Subdisks:     1 Size:        512 MB

    S myvol.p0.s0           State: up       PO:        0  B Size:        512 MB
    S mirror.p0.s0          State: up       PO:        0  B Size:        512 MB
    S mirror.p1.s0          State: empty    PO:        0  B Size:        512 MB
    S striped.p0.s0         State: up       PO:        0  B Size:        128 MB
    S striped.p0.s1         State: up       PO:      512 kB Size:        128 MB
    S striped.p0.s2         State: up       PO:     1024 kB Size:        128 MB
    S striped.p0.s3         State: up       PO:     1536 kB Size:        128 MB</pre></div></div><div id=vinum-striped-vol class=imageblock><div class=content><img src=../../../images/articles/vinum/vinum-striped-vol.png alt="vinum striped vol"></div><div class=title>Figura 6. Um volume <span class=filename>vinum</span> concatenado</div></div><div class=paragraph><p>Este volume é representado em <a href=#vinum-striped-vol>A Striped <span class=filename>vinum</span> Volume</a>. A escuridão das strips indica a posição dentro do espaço de endereço plex, onde as faixas mais claras vêm primeiro e as mais escuras por último.</p></div></div><div class=sect2><h3 id=_resiliência_e_desempenho>5.4. Resiliência e Desempenho<a class=anchor href=#_resiliência_e_desempenho></a></h3><div class=paragraph><p><a id=vinum-resilience></a>Com hardware suficiente, é possível construir volumes que mostrem maior resiliência e melhor desempenho em comparação com as partições padrão UNIX®. Um arquivo de configuração típico pode ser:</p></div><div class="literalblock programlisting"><div class=content><pre>	volume raid10
      plex org striped 512k
        sd length 102480k drive a
        sd length 102480k drive b
        sd length 102480k drive c
        sd length 102480k drive d
        sd length 102480k drive e
      plex org striped 512k
        sd length 102480k drive c
        sd length 102480k drive d
        sd length 102480k drive e
        sd length 102480k drive a
        sd length 102480k drive b</pre></div></div><div class=paragraph><p>Os subdiscos do segundo plex são compensados por duas unidades daquelas do primeiro plex. Isso ajuda a garantir que as gravações não vão para os mesmos subdiscos, mesmo que uma transferência passe por duas unidades.</p></div><div class=paragraph><p><a href=#vinum-raid10-vol>A Mirrored, Striped <span class=filename>vinum</span> Volume</a> representa a estrutura deste volume.</p></div><div id=vinum-raid10-vol class=imageblock><div class=content><img src=../../../images/articles/vinum/vinum-raid10-vol.png alt="vinum raid10 vol"></div><div class=title>Figura 7. Um volume <span class=filename>vinum</span> espelhado e concatenado</div></div></div></div></div><div class=sect1><h2 id=vinum-object-naming>6. Nomeação de Objetos<a class=anchor href=#vinum-object-naming></a></h2><div class=sectionbody><div class=paragraph><p>O <span class=filename>vinum</span> atribui nomes padrões a plexes e subdiscos, embora eles possam ser substituídos. Substituir os nomes padrões não é recomendado, pois não isso traz nenhuma vantagem significativa e pode causar confusão.</p></div><div class=paragraph><p>Os nomes podem conter qualquer caractere não-branco, mas é recomendado restringi-los a letras, dígitos e caracteres de sublinhado. Os nomes de volumes, plexes e subdiscos podem ter até 64 caracteres e os nomes das unidades podem ter até 32 caracteres.</p></div><div class=paragraph><p>Os objetos <span class=filename>vinum</span> são designados a device nodes na hierarquia <span class=filename>/dev/gvinum</span>. A configuração mostrada acima faria com que o <span class=filename>vinum</span> criasse os seguintes device nodes:</p></div><div class=ulist><ul><li><p>Entradas de dispositivos para cada volume. Estes são os principais dispositivos usados pelo <span class=filename>vinum</span>. A configuração acima incluiria os dispositivos <span class=filename>/dev/gvinum/myvol</span>, <span class=filename>/dev/gvinum/mirror</span>, <span class=filename>/dev/gvinum/striped</span>, <span class=filename>/dev/gvinum/raid5</span> e o <span class=filename>/dev/gvinum/raid10</span>.</p></li><li><p>Todos os volumes recebem entradas diretas em <span class=filename>/dev/gvinum/</span>.</p></li><li><p>Os diretórios <span class=filename>/dev/gvinum/plex</span>, e <span class=filename>/dev/gvinum/sd</span> são aqueles que contém device nodes para cada plex e para cada subdisco, respectivamente.</p></li></ul></div><div class=paragraph><p>Por exemplo, considere o seguinte arquivo de configuração:</p></div><div class="literalblock programlisting"><div class=content><pre>	drive drive1 device /dev/sd1h
	drive drive2 device /dev/sd2h
	drive drive3 device /dev/sd3h
	drive drive4 device /dev/sd4h
    volume s64 setupstate
      plex org striped 64k
        sd length 100m drive drive1
        sd length 100m drive drive2
        sd length 100m drive drive3
        sd length 100m drive drive4</pre></div></div><div class=paragraph><p>Depois de processar este arquivo, o <a href="https://man.freebsd.org/cgi/man.cgi?query=gvinum&amp;sektion=8&amp;format=html">gvinum(8)</a> cria a seguinte estrutura em <span class=filename>/dev/gvinum</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>	drwxr-xr-x  2 root  wheel       512 Apr 13
16:46 plex
	crwxr-xr--  1 root  wheel   91,   2 Apr 13 16:46 s64
	drwxr-xr-x  2 root  wheel       512 Apr 13 16:46 sd

    /dev/vinum/plex:
    total 0
    crwxr-xr--  1 root  wheel   25, 0x10000002 Apr 13 16:46 s64.p0

    /dev/vinum/sd:
    total 0
    crwxr-xr--  1 root  wheel   91, 0x20000002 Apr 13 16:46 s64.p0.s0
    crwxr-xr--  1 root  wheel   91, 0x20100002 Apr 13 16:46 s64.p0.s1
    crwxr-xr--  1 root  wheel   91, 0x20200002 Apr 13 16:46 s64.p0.s2
    crwxr-xr--  1 root  wheel   91, 0x20300002 Apr 13 16:46 s64.p0.s3</pre></div></div><div class=paragraph><p>Embora seja recomendado que os plexes e subdiscos não sejam atribuídos a nomes específicos, as unidades <span class=filename>vinum</span> devem ser nomeadas. Isso possibilita mover uma unidade para um local diferente e ainda reconhecê-la automaticamente. Os nomes dos drives podem ter até 32 caracteres.</p></div><div class=sect2><h3 id=_criando_sistemas_de_arquivos>6.1. Criando sistemas de arquivos<a class=anchor href=#_criando_sistemas_de_arquivos></a></h3><div class=paragraph><p>Para o sistema os volumes são idênticos aos discos, com uma exceção. Ao contrário das unidades UNIX®, o <span class=filename>vinum</span> não particiona os volumes, e, portanto, não contêm uma tabela de partições. Isso exigiu modificação em alguns dos utilitários de disco, notavelmente no <a href="https://man.freebsd.org/cgi/man.cgi?query=newfs&amp;sektion=8&amp;format=html">newfs(8)</a>, para que ele não tente interpretar a última letra de um nome do volume <span class=filename>vinum</span> como um identificador de partição. Por exemplo, uma unidade de disco pode ter um nome como <span class=filename>/dev/ad0a</span> ou <span class=filename>/dev/da2h</span>. Esses nomes representam a primeira partição (<span class=filename>a</span>) no primeiro (0) disco IDE (<span class=filename>ad</span>) e a oitava partição (<span class=filename>h</span>) no terceiro (2) disco SCSI (<span class=filename>da</span>) respectivamente. Por outro lado, um volume <span class=filename>vinum</span> pode ser chamado de <span class=filename>/dev/gvinum/concat</span>, que não tem relação com o nome da partição.</p></div><div class=paragraph><p>Para criar um sistema de arquivos neste volume, use <a href="https://man.freebsd.org/cgi/man.cgi?query=newfs&amp;sektion=8&amp;format=html">newfs(8)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># newfs /dev/gvinum/concat</span></code></pre></div></div></div></div></div><div class=sect1><h2 id=vinum-config>7. Configurando o <span class=filename>vinum</span><a class=anchor href=#vinum-config></a></h2><div class=sectionbody><div class=paragraph><p>O kernel <span class=filename>GENERIC</span> não suporta o <span class=filename>vinum</span>. É possível compilar um kernel customizado que inclua o suporte estático ao <span class=filename>vinum</span>, mas isso não é recomendado. A maneira padrão de iniciar o <span class=filename>vinum</span> é como um módulo do kernel. O uso do <a href="https://man.freebsd.org/cgi/man.cgi?query=kldload&amp;sektion=8&amp;format=html">kldload(8)</a> não é necessário porque quando o <a href="https://man.freebsd.org/cgi/man.cgi?query=gvinum&amp;sektion=8&amp;format=html">gvinum(8)</a> é iniciado, ele verifica se o módulo já foi carregado e, se ele não tiver sido, ele será carregado automaticamente.</p></div><div class=sect2><h3 id=_começando>7.1. Começando<a class=anchor href=#_começando></a></h3><div class=paragraph><p>O <span class=filename>vinum</span> armazena as informações de configuração nos slices dos discos essencialmente da mesma forma que nos arquivos de configuração. Ao ler a partir do banco de dados de configuração, o <span class=filename>vinum</span> reconhece um número de palavras-chave que não são permitidas nos arquivos de configuração. Por exemplo, uma configuração de disco pode conter o seguinte texto:</p></div><div class="literalblock programlisting"><div class=content><pre>volume myvol state up
volume bigraid state down
plex name myvol.p0 state up org concat vol myvol
plex name myvol.p1 state up org concat vol myvol
plex name myvol.p2 state init org striped 512b vol myvol
plex name bigraid.p0 state initializing org raid5 512b vol bigraid
sd name myvol.p0.s0 drive a plex myvol.p0 state up len 1048576b driveoffset 265b plexoffset 0b
sd name myvol.p0.s1 drive b plex myvol.p0 state up len 1048576b driveoffset 265b plexoffset 1048576b
sd name myvol.p1.s0 drive c plex myvol.p1 state up len 1048576b driveoffset 265b plexoffset 0b
sd name myvol.p1.s1 drive d plex myvol.p1 state up len 1048576b driveoffset 265b plexoffset 1048576b
sd name myvol.p2.s0 drive a plex myvol.p2 state init len 524288b driveoffset 1048841b plexoffset 0b
sd name myvol.p2.s1 drive b plex myvol.p2 state init len 524288b driveoffset 1048841b plexoffset 524288b
sd name myvol.p2.s2 drive c plex myvol.p2 state init len 524288b driveoffset 1048841b plexoffset 1048576b
sd name myvol.p2.s3 drive d plex myvol.p2 state init len 524288b driveoffset 1048841b plexoffset 1572864b
sd name bigraid.p0.s0 drive a plex bigraid.p0 state initializing len 4194304b driveoff set 1573129b plexoffset 0b
sd name bigraid.p0.s1 drive b plex bigraid.p0 state initializing len 4194304b driveoff set 1573129b plexoffset 4194304b
sd name bigraid.p0.s2 drive c plex bigraid.p0 state initializing len 4194304b driveoff set 1573129b plexoffset 8388608b
sd name bigraid.p0.s3 drive d plex bigraid.p0 state initializing len 4194304b driveoff set 1573129b plexoffset 12582912b
sd name bigraid.p0.s4 drive e plex bigraid.p0 state initializing len 4194304b driveoff set 1573129b plexoffset 16777216b</pre></div></div><div class=paragraph><p>As diferenças óbvias aqui são a presença de informações explícitas de localização e nomeação, as quais são ambas permitidas mas desencorajadas, e as informações sobre os estados. O <span class=filename>vinum</span> não armazena informações sobre unidades nas informações de configuração. Ele encontra as unidades varrendo as unidades de disco configuradas em busca de partições com um rótulo <span class=filename>vinum</span>. Isso permite que o <span class=filename>vinum</span> identifique as unidades corretamente, mesmo que elas tenham recebido diferentes IDs de unidade UNIX®.</p></div><div class=sect3><h4 id=vinum-rc-startup>7.1.1. Inicialização automática<a class=anchor href=#vinum-rc-startup></a></h4><div class=paragraph><p>O <em>Gvinum</em> apresenta sempre uma inicialização automática assim que o módulo do kernel é carregado, através do <a href="https://man.freebsd.org/cgi/man.cgi?query=loader.conf&amp;sektion=5&amp;format=html">loader.conf(5)</a>. Para carregar o módulo <em>Gvinum</em> no momento da inicialização, adicione <code>geom_vinum_load="YES"</code> ao arquivo <span class=filename>/boot/loader.conf</span>.</p></div><div class=paragraph><p>Quando o <span class=filename>vinum</span> é iniciado com <code>gvinum start</code>, o <span class=filename>vinum</span> lê o banco de dados de configuração de uma das unidades <span class=filename>vinum</span>. Em circunstâncias normais, cada unidade contém uma cópia idêntica do banco de dados de configuração, portanto, não importa qual unidade é lida. Após uma falha, no entanto, o <span class=filename>vinum</span> deve determinar qual unidade foi atualizada mais recentemente e ler a configuração desta unidade. Em seguida, atualiza a configuração, se necessário, de unidades progressivamente a partir das mais antigas.</p></div></div></div></div></div><div class=sect1><h2 id=vinum-root>8. Usando o <span class=filename>vinum</span> para o sistema de arquivos raiz<a class=anchor href=#vinum-root></a></h2><div class=sectionbody><div class=paragraph><p>Para uma máquina que tenha sistemas de arquivos totalmente espelhados usando <span class=filename>vinum</span>, é desejável também espelhar o sistema de arquivos raiz. Efetuar esta configuração é menos trivial do que espelhar um sistema de arquivos arbitrário porque:</p></div><div class=ulist><ul><li><p>O sistema de arquivos raiz deve estar disponível muito cedo durante o processo de inicialização, portanto a infraestrutura <span class=filename>vinum</span> já deve estar disponível no momento.</p></li><li><p>O volume que contém o sistema de arquivos raiz também contém a auto-inicialização do sistema e o kernel. Eles devem ser lidos usando os utilitários nativos do sistema, como o BIOS, que muitas vezes não pode ser instruído sobre os detalhes do <span class=filename>vinum</span>.</p></li></ul></div><div class=paragraph><p>Nas seções a seguir, o termo "volume raiz" é geralmente usado para descrever o volume <span class=filename>vinum</span> que contém o sistema de arquivos raiz (/).</p></div><div class=sect2><h3 id=_iniciando_o_vinum_cedo_o_suficiente_para_o_sistema_de_arquivos_raiz>8.1. Iniciando o <span class=filename>vinum</span> cedo o suficiente para o sistema de arquivos raiz<a class=anchor href=#_iniciando_o_vinum_cedo_o_suficiente_para_o_sistema_de_arquivos_raiz></a></h3><div class=paragraph><p>O <span class=filename>vinum</span> deve estar disponível no início da inicialização do sistema pois o <a href="https://man.freebsd.org/cgi/man.cgi?query=loader&amp;sektion=8&amp;format=html">loader(8)</a> deve ser capaz de carregar o módulo do kernel vinum antes de iniciar o kernel. Isto pode ser feito colocando esta linha no <span class=filename>/boot/loader.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>geom_vinum_load=&#34;YES&#34;</pre></div></div></div><div class=sect2><h3 id=_tornando_um_volume_raiz_baseado_em_vinum_acessível_ao_bootstrap>8.2. Tornando um volume raiz baseado em <span class=filename>vinum</span> acessível ao Bootstrap<a class=anchor href=#_tornando_um_volume_raiz_baseado_em_vinum_acessível_ao_bootstrap></a></h3><div class=paragraph><p>O bootstrap atual do FreeBSD tem apenas 7.5 KB de código e não entende as estruturas internas do <span class=filename>vinum</span>. Isso significa que não é possível analisar os dados de configuração <span class=filename>vinum</span> ou descobrir os elementos de um volume de inicialização. Assim, algumas soluções alternativas são necessárias para fornecer ao código de inicialização a ilusão de que ele está trabalhando com uma partição padrão <code>a</code> que contém o sistema de arquivos raiz.</p></div><div class=paragraph><p>Para que isso seja possível, os seguintes requisitos devem ser atendidos para o volume raiz:</p></div><div class=ulist><ul><li><p>O volume raiz não pode ser uma stripe ou <code>RAID</code> -5.</p></li><li><p>O volume raiz não deve conter mais de um subdisco concatenado por plex.</p></li></ul></div><div class=paragraph><p>Observe que é desejável e possível usar vários plexes, cada um contendo uma réplica do sistema de arquivos raiz. O processo de bootstrap usará apenas uma réplica para localizar o bootstrap e todos os arquivos de inicialização, até que o kernel monte o sistema de arquivos raiz. Cada subdisco dentro desses plexes precisa da sua própria ilusão de partição <code>a</code>, para que o respectivo dispositivo seja inicializável. Não é estritamente necessário que cada uma dessas falsas partições <code>a</code> estejam localizadas no mesmo deslocamento dentro de seu dispositivo, em comparação com outros dispositivos contendo plexes do volume raiz. No entanto, é provavelmente uma boa ideia criar os volumes <span class=filename>vinum</span> dessa forma para que os dispositivos espelhados resultantes sejam simétricos, para evitar confusão.</p></div><div class=paragraph><p>Para configurar essas partições <code>a</code> para cada dispositivo contendo parte do volume raiz, é necessário o seguinte:</p></div><div class="olist arabic procedure"><ol class=arabic><li><p>A localização, offset desde o início do dispositivo, e o tamanho do subdisco desse dispositivo que faz parte do volume raiz precisam ser examinados, usando o comando:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gvinum l -rv root</span></code></pre></div></div><div class=paragraph><p>Os offsets (deslocamentos) e tamanhos do <span class=filename>vinum</span> são medidos em bytes. Eles devem ser divididos por 512 para obter os números de blocos que serão usados pelo <code>bsdlabel</code>.</p></div></li><li><p>Execute este comando para cada dispositivo que participa do volume raiz:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># bsdlabel -e devname</span></code></pre></div></div><div class=paragraph><p>No comando acima <em>devname</em> deve ser o nome do disco, como <span class=filename>da0</span> para discos sem uma tabela de slices, ou o nome da slice, como <span class=filename>ad0s1</span>.</p></div><div class=paragraph><p>Se já existir uma partição <code>a</code> no dispositivo a partir de um sistema de arquivos raiz pré-<span class=filename>vinum</span>, ela deve ser renomeada para outra coisa para que permaneça acessível (apenas nesse caso), mas ela não será mais usada por padrão para inicializar o sistema. Um sistema de arquivos raiz atualmente montado não pode ser renomeado, portanto, de forma que o processo ser executado quando o sistema for inicializado a partir de uma mídia "Fixit" ou em um processo de duas etapas em que, em um espelho, o disco que ainda não foi inicializado é manipulado primeiro.</p></div><div class=paragraph><p>O offset da partição <span class=filename>vinum</span> neste dispositivo (se houver) deve ser adicionado ao deslocamento do respectivo subdisco de volume raiz neste dispositivo. O valor resultante se tornará o valor do <code>offset</code> para a nova partição <code>a</code>. O valor do <code>size</code> para esta partição também pode ser obtido a partir do cálculo acima. O <code>fstype</code> deve ser <code>4.2BSD</code>. Os valores de <code>fsize</code>, <code>bsize</code> e <code>cpg</code> devem ser escolhidos para corresponder ao sistema de arquivos atual, embora eles sejam relativamente sem importância dentro deste contexto.</p></div><div class=paragraph><p>Desta forma, uma nova partição <code>a</code> será estabelecida sobrepondo a partição <span class=filename>vinum</span> neste dispositivo. O <code>bsdlabel</code> só permitirá essa sobreposição se a partição <span class=filename>vinum</span> tiver sido marcada corretamente usando o modo fstype do <code>vinum</code>.</p></div></li><li><p>Temos agora uma falsa partição <code>a</code> em cada dispositivo que possui uma réplica do volume raiz. É altamente recomendável verificar o resultado usando um comando como:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># fsck -n /dev/devnamea</span></code></pre></div></div></li></ol></div><div class=paragraph><p>Deve ser lembrado que todos os arquivos contendo informações de controle devem ser relativos ao sistema de arquivos raiz no volume <span class=filename>vinum</span> e que, ao configurarmos um novo volume raiz <span class=filename>vinum</span>, ele pode não corresponder o sistema de arquivos raiz que está atualmente ativo. Então, em particular, o <span class=filename>/etc/fstab</span> e <span class=filename>/boot/loader.conf</span> precisam ser ajustados.</p></div><div class=paragraph><p>Na próxima reinicialização, o bootstrap deve descobrir as informações de controle apropriadas do novo sistema de arquivos raiz baseado no <span class=filename>vinum</span> e agir de acordo. No final do processo de inicialização do kernel, após todos os dispositivos terem sido anunciados, o aviso de destaque que mostra o sucesso desta configuração é uma mensagem como:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Mounting root from ufs:/dev/gvinum/root</code></pre></div></div></div><div class=sect2><h3 id=_exemplo_de_uma_configuração_raiz_baseada_em_vinum>8.3. Exemplo de uma configuração raiz baseada em <span class=filename>vinum</span><a class=anchor href=#_exemplo_de_uma_configuração_raiz_baseada_em_vinum></a></h3><div class=paragraph><p>Depois que o volume raiz <span class=filename>vinum</span> foi configurado, a saída de <code>gvinum l -rv root</code> pode parecer com:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>...
Subdisk root.p0.s0:
		Size:        125829120 bytes <span class=o>(</span>120 MB<span class=o>)</span>
		State: up
		Plex root.p0 at offset 0 <span class=o>(</span>0  B<span class=o>)</span>
		Drive disk0 <span class=o>(</span>/dev/da0h<span class=o>)</span> at offset 135680 <span class=o>(</span>132 kB<span class=o>)</span>

Subdisk root.p1.s0:
		Size:        125829120 bytes <span class=o>(</span>120 MB<span class=o>)</span>
		State: up
		Plex root.p1 at offset 0 <span class=o>(</span>0  B<span class=o>)</span>
		Drive disk1 <span class=o>(</span>/dev/da1h<span class=o>)</span> at offset 135680 <span class=o>(</span>132 kB<span class=o>)</span></code></pre></div></div><div class=paragraph><p>Os valores a serem observados são <code>135680</code> para o offset, relativo à partição <span class=filename>/dev/da0h</span>. Isso se traduz em 265 blocos de discos de 512 bytes nos termos do <code>bsdlabel</code>. Da mesma forma, o tamanho desse volume raiz é de 245760 blocos de 512 bytes. O <span class=filename>/dev/da1h</span>, contém a segunda réplica deste volume raiz, e possui uma configuração simétrica.</p></div><div class=paragraph><p>O bsdlabel para esses dispositivos pode se parecer com:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>...
8 partitions:
<span class=c>#        size   offset    fstype   [fsize bsize bps/cpg]</span>
  a:   245760      281    4.2BSD     2048 16384     0  <span class=c># (Cyl.    0*- 15*)</span>
  c: 71771688        0    unused        0     0        <span class=c># (Cyl.    0 - 4467*)</span>
  h: 71771672       16     vinum                       <span class=c># (Cyl.    0*- 4467*)</span></code></pre></div></div><div class=paragraph><p>Pode-se observar que o parâmetro <code>size</code> para a falsa partição <code>a</code> corresponde ao valor descrito acima, enquanto o parâmetro <code>offset</code> é a soma do deslocamento dentro da partição <span class=filename>vinum</span><code>h</code>, e o offset desta partição dentro do dispositivo ou slice. Esta é uma configuração típica que é necessária para evitar o problema descrito em <a href=#vinum-root-panic>Nothing Boots, the Bootstrap Panics</a>. A partição <code>a</code> inteira está completamente dentro da partição <code>h</code> que contém todos os dados <span class=filename>vinum</span> para este dispositivo.</p></div><div class=paragraph><p>No exemplo acima, todo o dispositivo é dedicado ao <span class=filename>vinum</span> e não há sobra de partição raiz pré-<span class=filename>vinum</span>.</p></div></div><div class=sect2><h3 id=_soluções_de_problemas>8.4. Soluções de problemas<a class=anchor href=#_soluções_de_problemas></a></h3><div class=paragraph><p>A lista a seguir contém algumas armadilhas e soluções conhecidas.</p></div><div class=sect3><h4 id=_sistema_de_bootstrap_carrega_mas_o_sistema_não>8.4.1. Sistema de bootstrap carrega, mas o sistema não<a class=anchor href=#_sistema_de_bootstrap_carrega_mas_o_sistema_não></a></h4><div class=paragraph><p>Se por algum motivo o sistema não continuar a inicialização, o bootstrap pode ser interrompido pressionando <kbd>espaço</kbd> no aviso de 10 segundos. A variável <code>vinum.autostart</code> do loader pode ser examinada digitando <code>show</code> e manipulada usando <code>set</code> ou <code>unset</code>.</p></div><div class=paragraph><p>Se o módulo do kernel <span class=filename>vinum</span> ainda não estava na lista de módulos para carregar automaticamente, digite <code>load geom_vinum</code>.</p></div><div class=paragraph><p>Quando estiver pronto, o processo de inicialização pode ser continuado digitando-se <code>boot -as</code>, no qual <code>-as</code> solicita ao kernel que peça ao sistema de arquivos raiz para montar (<code>-a</code>) e fazer com que o processo de inicialização pare no modo single user(<code>-s</code>), em que o sistema de arquivos raiz é montado como somente leitura. Dessa forma, mesmo que apenas um plex de um volume multi-plex tenha sido montado, não estaremos arriscando nenhuma inconsistência de dados entre os plexes.</p></div><div class=paragraph><p>No prompt solicitando que um sistema de arquivos raiz seja montado, qualquer dispositivo que contenha um sistema de arquivos raiz válido pode ser inserido. Se o <span class=filename>/etc/fstab</span> estiver configurado corretamente, o padrão deve ser algo como <code>ufs:/dev/gvinum/root</code>. Uma opção alternativa típica seria algo como <code>ufs:da0d</code>, que poderia ser uma partição hipotética contendo o sistema de arquivos raiz pré-<span class=filename>vinum</span>. Deve-se tomar cuidado se uma das partições alias <code>a</code> for inserida aqui, para verificar se ela realmente faz referência aos subdiscos do dispositivo raiz <span class=filename>vinum</span>, porque em uma configuração espelhada, isso apenas montaria uma parte de um dispositivo raiz espelhado. Se este sistema de arquivos tiver que ser montado no modo read-write mais tarde, será necessário remover o(s) outro(s) plex(es) do volume raiz <span class=filename>vinum</span>, já que esses plexes carregariam dados inconsistentes.</p></div></div><div class=sect3><h4 id=_apenas_o_bootstrap_primário_carrega>8.4.2. Apenas o bootstrap primário carrega<a class=anchor href=#_apenas_o_bootstrap_primário_carrega></a></h4><div class=paragraph><p>Se o <span class=filename>/boot/loader</span> falhar ao carregar, mas o bootstrap primário ainda carregar (visível por um único traço na coluna esquerda da tela logo após o processo de boot ser iniciado), uma tentativa pode ser feita para interromper o bootstrap primário pressionando <kbd>espaço</kbd>. Isso fará com que o bootstrap pare no <a href=https://docs.freebsd.org/pt-br/books/handbook/book/boot#boot-boot1>estágio dois</a>. Uma tentativa pode ser feita aqui para inicializar uma partição alternativa, como a partição que contém o sistema de arquivos raiz anterior que foi movido de <code>a</code>.</p></div></div><div class=sect3><h4 id=vinum-root-panic>8.4.3. Nada carrega e o Bootstrap entra em panic<a class=anchor href=#vinum-root-panic></a></h4><div class=paragraph><p>Esta situação acontecerá se o bootstrap tiver sido destruído pela instalação do <span class=filename>vinum</span>. Infelizmente, o <span class=filename>vinum</span> acidentalmente deixa apenas 4 KB no início de sua partição livre antes de começar a escrever suas informações de cabeçalho <span class=filename>vinum</span>. No entanto, o estágio um e dois bootstraps mais o bsdlabel exigem 8 KB. Portanto, se uma partição <span class=filename>vinum</span> tiver sido iniciada no offset 0 dentro de uma slice ou disco que deveria ser inicializável, a configuração do <span class=filename>vinum</span> irá estragar o bootstrap.</p></div><div class=paragraph><p>Da mesma forma, se a situação acima foi recuperada, inicializando de uma mídia "Fixit", e o bootstrap foi reinstalado usando <code>bsdlabel -B</code> como descrito em <a href=https://docs.freebsd.org/pt-br/books/handbook/book/boot#boot-boot1>Estágio Um e Estágio Dois</a>, o bootstrap irá estragar o cabeçalho <span class=filename>vinum</span> e o <span class=filename>vinum</span> não encontrará mais seu(s) disco(s). Entretando nenhum dado de configuração real do <span class=filename>vinum</span> e nenhum volume <span class=filename>vinum</span> de dados foi descartado, sendo possível recuperá-los digitando de novo exatamente as mesmas configurações do <span class=filename>vinum</span>, a situação é difícil de corrigir de forma definitiva. Pois será necessário mover toda a partição <span class=filename>vinum</span> em pelo menos 4 KB, para que o cabeçalho <span class=filename>vinum</span> e o bootstrap do sistema não colidam mais.</p></div></div></div></div></div><hr><div class=last-modified><p><strong>Última alteração em</strong>: 3 de novembro de 2021 por <a href="https://cgit.freebsd.org/doc/commit/?id=64acd169b8" target=_blank>Sergio Carlavilla Delgado</a></p></div></div><aside class=toc><div class=toc-content><h3>Índice</h3><nav id=TableOfContents><ul><li><a href=#vinum-synopsis>1. Sinopse</a></li><li><a href=#vinum-access-bottlenecks>2. Gargalos de Acesso</a></li><li><a href=#vinum-data-integrity>3. Integridade de dados</a></li><li><a href=#vinum-objects>4. Objetos do <span class=filename>vinum</span></a></li><li><a href=#vinum-examples>5. Alguns exemplos</a></li><li><a href=#vinum-object-naming>6. Nomeação de Objetos</a></li><li><a href=#vinum-config>7. Configurando o <span class=filename>vinum</span></a></li><li><a href=#vinum-root>8. Usando o <span class=filename>vinum</span> para o sistema de arquivos raiz</a></li></ul></nav><hr><div class=resources><h3>Recursos</h3><ul class=contents><li><i class="fa fa-file-pdf-o" aria-hidden=true title="Download PDF"></i><a href=https://download.freebsd.org/doc/pt-br/articles/vinum/vinum_pt-br.pdf>Download PDF</a></li><li><i class="fa fa-pencil-square-o" aria-hidden=true title="Edite essa página"></i><a href=https://github.com/freebsd/freebsd-doc/blob/main/documentation/content/pt-br/_index target=_blank>Edite essa página</a></li></ul></div></div></aside></main><footer><div class=footer-container><section class=logo-column><img src=https://docs.freebsd.org/images/FreeBSD-colors.svg width=160 height=50 alt="FreeBSD logo"><div class=options-container><div class=language-container><a id=languages href=https://docs.freebsd.org/pt-br/languages><img src=https://docs.freebsd.org/images/language.png class=language-image alt="Escolha o idioma">
<span>Brazilian Portuguese</span></a></div><div class=theme-container><select id=theme-chooser><option value=theme-system>System</option><option value=theme-light>Light</option><option value=theme-dark>Dark</option><option value=theme-high-contrast>Alto contraste</option></select></div></div></section><section class=about-column><h3 class=column-title>About</h3><ul class=column-elements-container><li><a href=https://www.freebsd.org/about/ target=_blank class=column-element>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/ target=_blank class=column-element>FreeBSD Foundation</a></li><li><a href=https://www.freebsd.org/where/ target=_blank class=column-element>Get FreeBSD</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct target=_blank class=column-element>Code of Conduct</a></li><li><a href=https://www.freebsd.org/security/ target=_blank class=column-element>Security Advisories</a></li></ul></section><section class=documentation-column><h3 class=column-title>Documentation</h3><ul class=column-elements-container><li><a href=/pt-br class=column-element>Documentation portal</a></li><li><a href=https://man.FreeBSD.org target=_blank class=column-element>Manual pages</a></li><li><a href=https://papers.FreeBSD.org target=_blank class=column-element>Presentations and papers</a></li><li><a href=https://docs-archive.freebsd.org/doc/ target=_blank class=column-element>Previous versions</a></li><li><a href=https://docs-archive.freebsd.org/44doc/ target=_blank class=column-element>4.4BSD Documents</a></li><li><a href=https://wiki.freebsd.org/ target=_blank class=column-element>Wiki</a></li></ul></section><section class=community-column><h3 class=column-title>Community</h3><ul class=column-elements-container><li><a href=https://docs.freebsd.org/pt-br/articles/contributing class=column-element>Get involved</a></li><li><a href=https://forums.freebsd.org/ target=_blank class=column-element>Community forum</a></li><li><a href=https://lists.freebsd.org/ target=_blank class=column-element>Mailing lists</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank class=column-element>IRC Channels</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank class=column-element>Bug Tracker</a></li></ul></section><section class=legal-column><h3 class=column-title>Legal</h3><ul class=column-elements-container><li><a href=https://freebsdfoundation.org/donate/ target=_blank class=column-element>Donations</a></li><li><a href=https://www.freebsd.org/copyright/freebsd-license/ target=_blank class=column-element>Licensing</a></li><li><a href=https://www.freebsd.org/privacy/ target=_blank class=column-element>Privacy Policy</a></li><li><a href=https://www.freebsd.org/copyright/ target=_blank class=column-element>Legal notices</a></li></ul></section><section class=copyright-column><p>&copy; 1994-2024 The FreeBSD Project. All rights reserved</p><span>Made with <span class=heart>♥</span> by the FreeBSD Community</span></section></div></footer></body></html>