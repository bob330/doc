<!doctype html><html class=theme-light lang=pt-br><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content><meta name=keywords content><meta name=copyright content="1995-2024 The FreeBSD Foundation"><link rel=canonical href=http://172.16.201.134:1313/pt-br/books/handbook/geom/><title>Capítulo 18. GEOM: Framework de Transformação de Disco Modular | FreeBSD Documentation Portal</title>
<meta name=theme-color content="#790000"><meta name=color-scheme content="system light dark high-contrast"><link rel="shortcut icon" href=http://172.16.201.134:1313/favicon.ico><link rel=stylesheet href=http://172.16.201.134:1313/styles/main.min.css><link rel=stylesheet href=http://172.16.201.134:1313/css/font-awesome-min.css><script defer src=/js/theme-chooser.min.js></script><script defer src=/js/copy-clipboard.min.js></script><script defer src=/js/search.min.js></script><meta name=twitter:card content="summary"><meta name=twitter:domain content="docs.FreeBSD.org"><meta name=twitter:site content="@freebsd"><meta name=twitter:url content="https://twitter.com/freebsd"><meta property="og:title" content="Capítulo 18. GEOM: Framework de Transformação de Disco Modular"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:image" content="http://172.16.201.134:1313/favicon.ico"><meta property="og:image:alt" content="FreeBSD Logo"><meta property="og:locale" content="pt-br"><meta property="og:url" content="http://172.16.201.134:1313/pt-br/books/handbook/geom/"><meta property="og:site_name" content="FreeBSD Documentation Portal"><script type=application/ld+json>{"@context":"http://schema.org","@type":"Article","url":"http:\/\/172.16.201.134:1313\/pt-br\/books\/handbook\/geom\/","name":"FreeBSD Documentation Portal","headline":"FreeBSD Documentation Portal","description":"FreeBSD Documentation Portal"}</script></head><body><header><div class=header-container><div class=logo-menu-bars-container><a href=https://www.FreeBSD.org class=logo><img src=http://172.16.201.134:1313/images/FreeBSD-monochromatic.svg width=160 height=50 alt="FreeBSD logo">
</a><label class=menu-bars for=menu-bars><i class="fa fa-bars" aria-hidden=true></i></label></div><input id=menu-bars type=checkbox><nav><ul class=menu><li class=menu-item><input id=about type=checkbox>
<a href=# aria-label="Navigate to About section"><label class=menu-item-description for=about>About
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/about/ target=_blank>About</a></li><li><a href=https://www.freebsd.org/about/ target=_blank>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/about-us/about-the-foundation/ target=_blank>FreeBSD Foundation</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct/ target=_blank>Code of Conduct</a></li></ul></li><li class=menu-item><input id=download type=checkbox>
<a href=# aria-label="Navigate to get FreeBSD section"><label class=menu-item-description for=download>Get FreeBSD
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/where/ target=_blank>Get FreeBSD</a></li><li><a href=https://www.freebsd.org/releases/ target=_blank>Release Information</a></li><li><a href=https://www.freebsd.org/releng/ target=_blank>Release Engineering</a></li><li><a href=https://www.freebsd.org/security/ target=_blank>Security Advisories</a></li></ul></li><li class=menu-item><input id=documentation type=checkbox>
<a href=# aria-label="Navigate to get Documentation section"><label class=menu-item-description for=documentation>Documentation
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=/pt-br>Documentation portal</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook>FreeBSD Handbook</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/porters-handbook>Porter's Handbook</a></li><li><a href=https://docs.FreeBSD.org/en/books/fdp-primer>Documentation Project Handbook</a></li><li><a href=https://man.FreeBSD.org target=_blank>Manual pages</a></li><li><a href=https://papers.FreeBSD.org target=_blank>Presentations and papers</a></li><li><a href=https://wiki.FreeBSD.org target=_blank>Wiki</a></li><li><a href=http://172.16.201.134:1313/pt-br/books>Books</a></li><li><a href=http://172.16.201.134:1313/pt-br/articles>Articles</a></li></ul></li><li class=menu-item><input id=community type=checkbox>
<a href=# aria-label="Navigate to get Community section"><label class=menu-item-description for=community>Community
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/community/>Community</a></li><li><a href=http://172.16.201.134:1313/pt-br/articles/contributing>Get involved</a></li><li><a href=https://forums.freebsd.org/ target=_blank>Forum</a></li><li><a href=https://lists.freebsd.org/ target=_blank>Mailing lists</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank>IRC Channels</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank>Bug Tracker</a></li><li><a href=https://www.freebsd.org/support/ target=_blank>Support</a></li></ul></li></ul></nav><div class=search-donate-container><form class=search method=get id=search-header-form action=https://docs.freebsd.org/search name=search-header-form><input type=hidden name=DB value=pt-br>
<input id=words name=P type=text size=20 maxlength=255>
<button>
<i class="fa fa-search" aria-hidden=true></i></button></form><div class=donate><a href=https://freebsdfoundation.org/donate/ target=_blank><span class=heart>♥</span>
Donate</a></div></div></div></header><input type=checkbox class="hidden toggle" id=menu-control><main class=main-wrapper-book><a id=top></a><aside class=book-menu><div class=book-menu-content><input id=search-book type=text placeholder=Pesquisar aria-label=Pesquisar maxlength=128><nav id=MenuContents><ul><li><input type=checkbox id=chapter-eb2a98ce203d8afd517726e6d8776be3 class=toggle>
<label class="icon cursor" for=chapter-eb2a98ce203d8afd517726e6d8776be3><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/preface/>Prefácio</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/preface/#preface-audience>Audiência Pretendida</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/preface/#preface-changes-from3>Mudanças desde a Terceira Edição</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/preface/#preface-changes-from2>Mudanças desde a Segunda Edição (2004)</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/preface/#preface-changes>Mudanças desde a Primeira Edição (2001)</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/preface/#preface-overview>Organização deste Livro</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/preface/#preface-conv>Convenções utilizadas neste livro</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/preface/#preface-acknowledgements>Agradecimentos</a></li></ul></li><li><input type=checkbox id=chapter-14a525fce014b90b8a458a894818255a class=toggle>
<label for=chapter-14a525fce014b90b8a458a894818255a><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/parti/>Parte I. Primeiros Passos</a></li><li><input type=checkbox id=chapter-f9c9f3451644df30d224350da97d5da6 class=toggle>
<label class="icon cursor" for=chapter-f9c9f3451644df30d224350da97d5da6><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/introduction/>Capítulo 1. Introdução</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/introduction/#introduction-synopsis>1.1. Sinopse</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/introduction/#nutshell>1.2. Bem vindo ao FreeBSD!</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/introduction/#history>1.3. Sobre o Projeto FreeBSD</a></li></ul></li><li><input type=checkbox id=chapter-f693a3fa687a72d63ec8129ee302d664 class=toggle>
<label class="icon cursor" for=chapter-f693a3fa687a72d63ec8129ee302d664><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/bsdinstall/>Capítulo 2. Instalando o FreeBSD</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/bsdinstall/#bsdinstall-synopsis>2.1. Sinopse</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/bsdinstall/#bsdinstall-hardware>2.2. Requisitos mínimos de hardware</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/bsdinstall/#bsdinstall-pre>2.3. Tarefas de Pré-instalação</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/bsdinstall/#bsdinstall-start>2.4. Iniciando a instalação</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/bsdinstall/#using-bsdinstall>2.5. Usando o bsdinstall</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/bsdinstall/#bsdinstall-partitioning>2.6. Alocando o espaço em disco</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/bsdinstall/#bsdinstall-fetching-distribution>2.7. Fazendo o download dos arquivos de distribuição</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/bsdinstall/#bsdinstall-post>2.8. Contas, Time Zone, Serviços e Hardening</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/bsdinstall/#bsdinstall-network>2.9. Interfaces de Rede</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/bsdinstall/#bsdinstall-install-trouble>2.10. Solução de problemas</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/bsdinstall/#using-live-cd>2.11. Usando o Live CD</a></li></ul></li><li><input type=checkbox id=chapter-9f6db261075f578742036fcc6000eecd class=toggle>
<label class="icon cursor" for=chapter-9f6db261075f578742036fcc6000eecd><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/basics/>Capítulo 3. Fundamentos do FreeBSD</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/basics/#basics-synopsis>3.1. Sinopse</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/basics/#consoles>3.2. Consoles e Terminais Virtuais</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/basics/#users-synopsis>3.3. Usuários e Gerenciamento Básico de Contas</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/basics/#permissions>3.4. Permissões</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/basics/#dirstructure>3.5. Estrutura de Diretórios</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/basics/#disk-organization>3.6. Organização dos Discos</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/basics/#mount-unmount>3.7. Montando e Desmontando Sistemas de Arquivos</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/basics/#basics-processes>3.8. Processos e Daemons</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/basics/#shells>3.9. Shells</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/basics/#editors>3.10. Editores de Texto</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/basics/#basics-devices>3.11. Dispositivos e nós de dispositivos</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/basics/#basics-more-information>3.12. Páginas de Manual</a></li></ul></li><li><input type=checkbox id=chapter-01c5707e95d14c0ff84bf62600c958d1 class=toggle>
<label class="icon cursor" for=chapter-01c5707e95d14c0ff84bf62600c958d1><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/ports/>Capítulo 4. Instalando Aplicativos: Pacotes e Ports</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/ports/#ports-synopsis>4.1. Sinopse</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/ports/#ports-overview>4.2. Visão geral sobre a Instalação de Software</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/ports/#ports-finding-applications>4.3. Encontrando Software</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/ports/#pkgng-intro>4.4. Usando o pkg para o gerenciamento de pacotes binários</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/ports/#ports-using>4.5. Usando a Coleção de Ports</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/ports/#ports-poudriere>4.6. Compilando Pacotes com o Poudriere</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/ports/#ports-nextsteps>4.7. Considerações pós-instalação</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/ports/#ports-broken>4.8. Lidando com ports quebrados</a></li></ul></li><li><input type=checkbox id=chapter-3405c00581365a8b5d16af70fe4d1b72 class=toggle>
<label class="icon cursor" for=chapter-3405c00581365a8b5d16af70fe4d1b72><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/x11/>Capítulo 5. O sistema X Window</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/x11/#x11-synopsis>5.1. Sinopse</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/x11/#x-understanding>5.2. Terminologia</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/x11/#x-install>5.3. Instalando o Xorg</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/x11/#x-config>5.4. Configuração do Xorg</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/x11/#x-fonts>5.5. Usando fontes no Xorg</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/x11/#x-xdm>5.6. O Gerenciador de Display X</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/x11/#x11-wm>5.7. Ambientes de desktop</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/x11/#x-compiz-fusion>5.8. Instalando o Compiz Fusion</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/x11/#x11-troubleshooting>5.9. Solução de problemas</a></li></ul></li><li><input type=checkbox id=chapter-0eab3565e8f59f5a8a896dfba7eb3680 class=toggle>
<label for=chapter-0eab3565e8f59f5a8a896dfba7eb3680><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/partii/>Parte II. Tarefas comuns</a></li><li><input type=checkbox id=chapter-b33cf28993f3f7bf5baf036e79da0f39 class=toggle>
<label class="icon cursor" for=chapter-b33cf28993f3f7bf5baf036e79da0f39><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/desktop/>Capítulo 6. Aplicações de Desktop</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/desktop/#desktop-synopsis>6.1. Sinopse</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/desktop/#desktop-browsers>6.2. Navegadores</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/desktop/#desktop-productivity>6.3. Produtividade</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/desktop/#desktop-viewers>6.4. Visualizadores de Documentos</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/desktop/#desktop-finance>6.5. Finanças</a></li></ul></li><li><input type=checkbox id=chapter-152f694a19312ad72ec7bb4e1c3c33b2 class=toggle>
<label class="icon cursor" for=chapter-152f694a19312ad72ec7bb4e1c3c33b2><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/multimedia/>Capítulo 7. Multimídia</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/multimedia/#multimedia-synopsis>7.1. Sinopse</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/multimedia/#sound-setup>7.2. Configurando a Placa de Som</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/multimedia/#sound-mp3>7.3. Áudio MP3</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/multimedia/#video-playback>7.4. Reprodução de Vídeo</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/multimedia/#tvcard>7.5. Placas de TV</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/multimedia/#mythtv>7.6. MythTV</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/multimedia/#scanners>7.7. Scanners de Imagem</a></li></ul></li><li><input type=checkbox id=chapter-80888b4ee02e3e409e5f71cf97a36450 class=toggle>
<label class="icon cursor" for=chapter-80888b4ee02e3e409e5f71cf97a36450><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/kernelconfig/>Capítulo 8. Configurando o kernel do FreeBSD</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/kernelconfig/#kernelconfig-synopsis>8.1. Sinopse</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/kernelconfig/#kernelconfig-custom-kernel>8.2. Por que compilar um kernel personalizado?</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/kernelconfig/#kernelconfig-devices>8.3. Encontrando o hardware do sistema</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/kernelconfig/#kernelconfig-config>8.4. O Arquivo de Configuração</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/kernelconfig/#kernelconfig-building>8.5. Criando e Instalando um Kernel Customizado</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/kernelconfig/#kernelconfig-trouble>8.6. Se algo der errado</a></li></ul></li><li><input type=checkbox id=chapter-cb174c55879b17ab955f2f16989a79e0 class=toggle>
<label class="icon cursor" for=chapter-cb174c55879b17ab955f2f16989a79e0><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/printing/>Capítulo 9. Impressão</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/printing/#printing-quick-start>9.1. Inicio Rápido</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/printing/#printing-connections>9.2. Conexões de Impressora</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/printing/#printing-pdls>9.3. Linguagens de Descrição de Página Comuns</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/printing/#printing-direct>9.4. Impressão Direta</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/printing/#printing-lpd>9.5. LPD (Daemon de impressora de linha)</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/printing/#printing-other>9.6. Outros sistemas de impressão</a></li></ul></li><li><input type=checkbox id=chapter-c12b8c3f2a8fcefce87087241f695c83 class=toggle>
<label class="icon cursor" for=chapter-c12b8c3f2a8fcefce87087241f695c83><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/linuxemu/>Capítulo 10. Compatibilidade binária com o Linux®</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/linuxemu/#linuxemu-synopsis>10.1. Sinopse</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/linuxemu/#linuxemu-lbc-install>10.2. Configurando a compatibilidade binária com o Linux™</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/linuxemu/#linuxemu-advanced>10.3. Tópicos Avançados</a></li></ul></li><li><input type=checkbox id=chapter-03b11ba627b9a0c85b247f5641bde272 class=toggle>
<label for=chapter-03b11ba627b9a0c85b247f5641bde272><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/partiii/>Parte III. Administração do Sistema</a></li><li><input type=checkbox id=chapter-6c31587f8d736319f099cd4dc1961301 class=toggle>
<label class="icon cursor" for=chapter-6c31587f8d736319f099cd4dc1961301><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/config/>Capítulo 11. Configuração e Ajuste</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/config/#config-synopsis>11.1. Sinopse</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/config/#configtuning-starting-services>11.2. Inicialização de Serviços</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/config/#configtuning-cron>11.3. Configurando o cron(8)</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/config/#configtuning-rcd>11.4. Gerenciando Serviços no FreeBSD</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/config/#config-network-setup>11.5. Configurando Placas de Interface de Rede</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/config/#configtuning-virtual-hosts>11.6. Hosts Virtuais</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/config/#configtuning-syslog>11.7. Configurando o log do sistema</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/config/#configtuning-configfiles>11.8. Arquivos de Configuração</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/config/#configtuning-sysctl>11.9. Efetuando ajustes com o sysctl(8)</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/config/#configtuning-disk>11.10. Otimização de Discos</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/config/#configtuning-kernel-limits>11.11. Ajustando os Limites do Kernel</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/config/#adding-swap-space>11.12. Adicionando Espaço de Swap</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/config/#acpi-overview>11.13. Gerenciamento de energia e recursos</a></li></ul></li><li><input type=checkbox id=chapter-459f0012b3b4f0b6b123010f029da5e4 class=toggle>
<label class="icon cursor" for=chapter-459f0012b3b4f0b6b123010f029da5e4><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/boot/>Capítulo 12. O processo de inicialização do FreeBSD</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/boot/#boot-synopsis>12.1. Sinopse</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/boot/#boot-introduction>12.2. Processo de Inicialização do FreeBSD</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/boot/#boot-splash>12.3. Configurando telas iniciais de inicialização</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/boot/#device-hints>12.4. Sugestões de dispositivos</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/boot/#boot-shutdown>12.5. Sequência de Desligamento</a></li></ul></li><li><input type=checkbox id=chapter-917c75fcffbb14d48ed6d0a48e7028f2 class=toggle>
<label class="icon cursor" for=chapter-917c75fcffbb14d48ed6d0a48e7028f2><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/security/>Capítulo 13. Segurança</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/security/#security-synopsis>13.1. Sinopse</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/security/#security-intro>13.2. Introdução</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/security/#one-time-passwords>13.3. Senhas de Uso Unico</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/security/#tcpwrappers>13.4. TCP Wrapper</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/security/#kerberos5>13.5. Kerberos</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/security/#openssl>13.6. OpenSSL</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/security/#ipsec>13.7. VPN Sobre IPsec</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/security/#openssh>13.8. OpenSSH</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/security/#fs-acl>13.9. Listas de Controle de Acesso</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/security/#security-pkg>13.10. Monitorando Problemas de Segurança de Terceiros</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/security/#security-advisories>13.11. Avisos de Segurança do FreeBSD</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/security/#security-accounting>13.12. Auditoria de Processo</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/security/#security-resourcelimits>13.13. Limites de Recursos</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/security/#security-sudo>13.14. Administração Compartilhada com Sudo</a></li></ul></li><li><input type=checkbox id=chapter-1a2a8e719703649c2c66d99aa7a25fd4 class=toggle>
<label class="icon cursor" for=chapter-1a2a8e719703649c2c66d99aa7a25fd4><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/jails/>Capítulo 14. Jails</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/jails/#jails-synopsis>14.1. Sinopse</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/jails/#jails-terms>14.2. Termos Relacionados à Jails</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/jails/#jails-build>14.3. Criando e Controlando Jails</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/jails/#jails-tuning>14.4. Tuning e Administração</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/jails/#jails-application>14.5. Atualizando Múltiplas Jails</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/jails/#jails-ezjail>14.6. Gerenciando Jails com o ezjail</a></li></ul></li><li><input type=checkbox id=chapter-8f4620c77e572cbb58917911a33c73cf class=toggle>
<label class="icon cursor" for=chapter-8f4620c77e572cbb58917911a33c73cf><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/mac/>Capítulo 15. Controle de acesso obrigatório</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/mac/#mac-synopsis>15.1. Sinopse</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/mac/#mac-inline-glossary>15.2. Termos chave</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/mac/#mac-understandlabel>15.3. Entendendo os rótulos MAC</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/mac/#mac-planning>15.4. Planejando a configuração de segurança</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/mac/#mac-policies>15.5. Políticas MAC Disponíveis</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/mac/#mac-userlocked>15.6. Bloqueio do Usuário</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/mac/#mac-implementing>15.7. Nagios em Jail MAC</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/mac/#mac-troubleshoot>15.8. Solução de problemas do framework MAC</a></li></ul></li><li><input type=checkbox id=chapter-9598d66a76cb3182057b6bcd775149a0 class=toggle>
<label class="icon cursor" for=chapter-9598d66a76cb3182057b6bcd775149a0><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/audit/>Capítulo 16. Auditoria de Evento de Segurança</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/audit/#audit-synopsis>16.1. Sinopse</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/audit/#audit-inline-glossary>16.2. Termos chave</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/audit/#audit-config>16.3. Configuração de Auditoria</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/audit/#audit-administration>16.4. Trabalhando com Trilhas de Auditoria</a></li></ul></li><li><input type=checkbox id=chapter-e1edcad13d9db6e8e4cb645d378ecfaf class=toggle>
<label class="icon cursor" for=chapter-e1edcad13d9db6e8e4cb645d378ecfaf><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/disks/>Capítulo 17. Armazenamento</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/disks/#disks-synopsis>17.1. Sinopse</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/disks/#disks-adding>17.2. Adicionando Discos</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/disks/#disks-growing>17.3. Redimensionando e Ampliando Discos</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/disks/#usb-disks>17.4. Dispositivos de Armazenamento USB</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/disks/#creating-cds>17.5. Criando e Usando Mídia em CD</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/disks/#creating-dvds>17.6. Criando e Usando Mídia de DVD</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/disks/#floppies>17.7. Criando e Usando Disquetes</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/disks/#backup-basics>17.8. Noções Básicas de Backup</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/disks/#disks-virtual>17.9. Discos de Memória</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/disks/#snapshots>17.10. Snapshots de Sistemas de Arquivos</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/disks/#quotas>17.11. Cotas de Disco</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/disks/#disks-encrypting>17.12. Criptografando Partições de Disco</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/disks/#swap-encrypting>17.13. Criptografando Swap</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/disks/#disks-hast>17.14. Alta Disponibilidade de Armazenamento (HAST)</a></li></ul></li><li><input type=checkbox id=chapter-dde37901a0e0ea32745b67607854900f class=toggle checked>
<label class="icon cursor" for=chapter-dde37901a0e0ea32745b67607854900f><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/geom/>Capítulo 18. GEOM: Framework de Transformação de Disco Modular</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/geom/#geom-synopsis>18.1. Sinopse</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/geom/#geom-striping>18.2. RAID0 - Striping</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/geom/#geom-mirror>18.3. RAID1 - Espelhamento</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/geom/#geom-raid3>18.4. RAID3 - Distribuição em Nível de Byte com Paridade Dedicada</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/geom/#geom-graid>18.5. Dispositivos RAID por Software</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/geom/#geom-ggate>18.6. GEOM Network Gate</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/geom/#geom-glabel>18.7. Rotulando Dispositivos de Disco</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/geom/#geom-gjournal>18.8. Journaling UFS através do GEOM</a></li></ul></li><li><input type=checkbox id=chapter-73e82560fcb7145b7c0e2ec47af8fc04 class=toggle>
<label class="icon cursor" for=chapter-73e82560fcb7145b7c0e2ec47af8fc04><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/zfs/>Capítulo 19. O sistema de arquivos Z (ZFS)</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/zfs/#zfs-differences>19.1. O que torna o ZFS diferente</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/zfs/#zfs-quickstart>19.2. Guia de Início Rápido</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/zfs/#zfs-zpool>19.3. Administração <code>zpool</code></a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/zfs/#zfs-zfs>19.4. Administração do <code>zfs</code></a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/zfs/#zfs-zfs-allow>19.5. Administração Delegada</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/zfs/#zfs-advanced>19.6. Tópicos Avançados</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/zfs/#zfs-links>19.7. Recursos adicionais</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/zfs/#zfs-term>19.8. Recursos e terminologia do ZFS</a></li></ul></li><li><input type=checkbox id=chapter-7af71270807eb7b70cd3eedc6577b254 class=toggle>
<label class="icon cursor" for=chapter-7af71270807eb7b70cd3eedc6577b254><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/filesystems/>Capítulo 20. Outros Sistemas de Arquivos</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/filesystems/#filesystems-synopsis>20.1. Sinopse</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/filesystems/#filesystems-linux>20.2. Sistemas de arquivos do Linux™</a></li></ul></li><li><input type=checkbox id=chapter-375257268d95faaf87faf4f7a2e6aa67 class=toggle>
<label class="icon cursor" for=chapter-375257268d95faaf87faf4f7a2e6aa67><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/virtualization/>Capítulo 21. Virtualização</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/virtualization/#virtualization-synopsis>21.1. Sinopse</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/virtualization/#virtualization-guest-parallels>21.2. FreeBSD como Sistema Operacional Convidado no Parallels para Mac OS™ X</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/virtualization/#virtualization-guest-virtualpc>21.3. FreeBSD como sistema convidado no Virtual PC para Windows™</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/virtualization/#virtualization-guest-vmware>21.4. FreeBSD como Sistema Operacional Convidado no VMware Fusion para Mac OS™</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/virtualization/#virtualization-guest-virtualbox>21.5. FreeBSD como Sistema Operacional Convidado no VirtualBox™</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/virtualization/#virtualization-host-virtualbox>21.6. FreeBSD como Host com VirtualBox™</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/virtualization/#virtualization-host-bhyve>21.7. FreeBSD como um Host bhyve</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/virtualization/#virtualization-host-xen>21.8. FreeBSD como Host Xen™</a></li></ul></li><li><input type=checkbox id=chapter-49f1e96591c090304ea532012257f4ef class=toggle>
<label class="icon cursor" for=chapter-49f1e96591c090304ea532012257f4ef><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/l10n/>Capítulo 22. Localização - Uso e Configuração do i18n/L10n</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/l10n/#l10n-synopsis>22.1. Sinopse</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/l10n/#using-localization>22.2. Usando Localização</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/l10n/#l10n-compiling>22.3. Encontrando Aplicações i18n</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/l10n/#lang-setup>22.4. Configuração de Localização para Idiomas Específicos</a></li></ul></li><li><input type=checkbox id=chapter-dead2b4c5ea325dd390a9b0dccd8f763 class=toggle>
<label class="icon cursor" for=chapter-dead2b4c5ea325dd390a9b0dccd8f763><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/cutting-edge/>Capítulo 23. Atualização e Upgrade do FreeBSD</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/cutting-edge/#updating-upgrading-synopsis>23.1. Sinopse</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/cutting-edge/#updating-upgrading-freebsdupdate>23.2. Atualização do FreeBSD</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/cutting-edge/#updating-upgrading-documentation>23.3. Atualizando o Conjunto de Documentação</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/cutting-edge/#current-stable>23.4. Acompanhando um ramo de desenvolvimento</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/cutting-edge/#makeworld>23.5. Atualizando o FreeBSD a partir do código fonte</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/cutting-edge/#small-lan>23.6. Atualização de várias máquinas</a></li></ul></li><li><input type=checkbox id=chapter-29c1eeb0e9dedc487a98399e2737ee8a class=toggle>
<label class="icon cursor" for=chapter-29c1eeb0e9dedc487a98399e2737ee8a><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/dtrace/>Chapter 24. DTrace</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/dtrace/#dtrace-synopsis>24.1. Sinopse</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/dtrace/#dtrace-implementation>24.2. Diferenças de Implementação</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/dtrace/#dtrace-enable>24.3. Ativando o Suporte do DTrace</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/dtrace/#dtrace-using>24.4. Usando o DTrace</a></li></ul></li><li><input type=checkbox id=chapter-913e72bfb3d6947b2869d3e9447a6eaa class=toggle>
<label class="icon cursor" for=chapter-913e72bfb3d6947b2869d3e9447a6eaa><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/usb-device-mode/>Capítulo 25. Modo de dispositivo USB/USB OTG</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/usb-device-mode/#usb-device-mode-synopsis>25.1. Sinopse</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/usb-device-mode/#usb-device-mode-terminals>25.2. Portas Seriais Virtuais USB</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/usb-device-mode/#usb-device-mode-network>25.3. Interfaces de rede do modo de dispositivo USB</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/usb-device-mode/#usb-device-mode-storage>25.4. Dispositivo de armazenamento virtual USB</a></li></ul></li><li><input type=checkbox id=chapter-bbd25f9a194f9c39ca2d658c75767db5 class=toggle>
<label for=chapter-bbd25f9a194f9c39ca2d658c75767db5><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/partiv/>Parte IV. Comunicação de rede</a></li><li><input type=checkbox id=chapter-499dab596afd7ddac77e80295314e0dd class=toggle>
<label class="icon cursor" for=chapter-499dab596afd7ddac77e80295314e0dd><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/serialcomms/>Capítulo 26. Comunicações Seriais</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/serialcomms/#serial-synopsis>26.1. Sinopse</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/serialcomms/#serial>26.2. Terminologia serial e hardware</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/serialcomms/#term>26.3. Terminais</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/serialcomms/#dialup>26.4. Serviço Dial-in</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/serialcomms/#dialout>26.5. Serviço de Dial-in</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/serialcomms/#serialconsole-setup>26.6. Configurando o Console Serial</a></li></ul></li><li><input type=checkbox id=chapter-95e4571c48bee1cced5e84a538d302e3 class=toggle>
<label class="icon cursor" for=chapter-95e4571c48bee1cced5e84a538d302e3><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/ppp-and-slip/>Capítulo 27. PPP</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/ppp-and-slip/#ppp-and-slip-synopsis>27.1. Sinopse</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/ppp-and-slip/#userppp>27.2. Configurando o PPP</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/ppp-and-slip/#ppp-troubleshoot>27.3. Solução de problemas de conexões PPP</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/ppp-and-slip/#pppoe>27.4. Usando o PPP sobre Ethernet (PPPoE)</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/ppp-and-slip/#pppoa>27.5. Usando PPP sobre ATM (PPPoA)</a></li></ul></li><li><input type=checkbox id=chapter-f089ac726c401c9b4bd5c34a295e11bb class=toggle>
<label class="icon cursor" for=chapter-f089ac726c401c9b4bd5c34a295e11bb><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/mail/>Capítulo 28. Correio Eletrônico</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/mail/#mail-synopsis>28.1. Sinopse</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/mail/#mail-using>28.2. Componentes de Email</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/mail/#sendmail>28.3. Arquivos de Configuração do Sendmail</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/mail/#mail-changingmta>28.4. Alterando o Mail Transfer Agent</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/mail/#mail-trouble>28.5. Solução de problemas</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/mail/#mail-advanced>28.6. Tópicos Avançados</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/mail/#outgoing-only>28.7. Configurando Apenas Envio</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/mail/#SMTP-dialup>28.8. Usando Email com uma Conexão Dialup</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/mail/#SMTP-Auth>28.9. Autenticação SMTP</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/mail/#mail-agents>28.10. Mail User Agents</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/mail/#mail-fetchmail>28.11. Usando o fetchmail</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/mail/#mail-procmail>28.12. Usando o procmail</a></li></ul></li><li><input type=checkbox id=chapter-6de4de3fe925639d4175ce4b6f8c1829 class=toggle>
<label class="icon cursor" for=chapter-6de4de3fe925639d4175ce4b6f8c1829><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/network-servers/>Capítulo 29. Servidores de Rede</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/network-servers/#network-servers-synopsis>29.1. Sinopse</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/network-servers/#network-inetd>29.2. O super-servidor inetd</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/network-servers/#network-nfs>29.3. Network File System (NFS)</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/network-servers/#network-nis>29.4. Sistema de Informação de Rede (NIS)</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/network-servers/#network-ldap>29.5. Protocolo leve de acesso de diretório ( LDAP )</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/network-servers/#network-dhcp>29.6. Protocolo de configuração dinâmica de hosts (DHCP)</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/network-servers/#network-dns>29.7. Sistema de Nomes de Domínio (DNS)</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/network-servers/#network-apache>29.8. Servidor HTTP Apache</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/network-servers/#network-ftp>29.9. Protocolo de Transferência de Arquivos (FTP)</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/network-servers/#network-samba>29.10. Serviços de arquivos e impressão para clientes Microsoft™Windows™ Clients (Samba)</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/network-servers/#network-ntp>29.11. Sincronização de Relógio com NTP</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/network-servers/#network-iscsi>29.12. Inicializador iSCSI e Configuração Alvo</a></li></ul></li><li><input type=checkbox id=chapter-776d855c7b75e048f90b5c2c9b35ffe0 class=toggle>
<label class="icon cursor" for=chapter-776d855c7b75e048f90b5c2c9b35ffe0><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/firewalls/>Capítulo 30. Firewalls</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/firewalls/#firewalls-intro>30.1. Sinopse</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/firewalls/#firewalls-concepts>30.2. Conceitos de Firewall</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/firewalls/#firewalls-pf>30.3. PF</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/firewalls/#firewalls-ipfw>30.4. IPFW</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/firewalls/#firewalls-ipf>30.5. IPFILTER (IPF)</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/firewalls/#firewalls-blacklistd>30.6. Blacklistd</a></li></ul></li><li><input type=checkbox id=chapter-5b07f776a0e6155c1c89aa0d15610380 class=toggle>
<label class="icon cursor" for=chapter-5b07f776a0e6155c1c89aa0d15610380><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/advanced-networking/>Capítulo 31. Rede Avançada</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/advanced-networking/#advanced-networking-synopsis>31.1. Sinopse</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/advanced-networking/#network-routing>31.2. Gateways e Rotas</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/advanced-networking/#network-wireless>31.3. Rede sem fio</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/advanced-networking/#network-usb-tethering>31.4. USB Tethering</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/advanced-networking/#network-bluetooth>31.5. Bluetooth</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/advanced-networking/#network-bridging>31.6. Bridging</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/advanced-networking/#network-aggregation>31.7. Agregação de links e failover</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/advanced-networking/#network-diskless>31.8. Operação Diskless com PXE</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/advanced-networking/#network-ipv6>31.9. IPv6</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/advanced-networking/#carp>31.10. Protocolo Comum de Redundância de Endereços (CARP)</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/advanced-networking/#network-vlan>31.11. VLANs</a></li></ul></li><li><input type=checkbox id=chapter-171a77aa9d067a1024f849470e1f33e8 class=toggle>
<label for=chapter-171a77aa9d067a1024f849470e1f33e8><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/partv/>Parte V. Apêndices</a></li><li><input type=checkbox id=chapter-8050f436a0a7986a4aaded93d8e49469 class=toggle>
<label class="icon cursor" for=chapter-8050f436a0a7986a4aaded93d8e49469><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/mirrors/>Apêndice A. Obtendo o FreeBSD</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/mirrors/#mirrors-cdrom>A.1. CD and DVD Sets</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/mirrors/#mirrors-ftp>A.2. Sites de FTP</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/mirrors/#svn>A.3. Usando o Subversion</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/mirrors/#mirrors-rsync>A.4. Usando o rsync</a></li></ul></li><li><input type=checkbox id=chapter-128b630a8f88f158e7027fe6c2184d21 class=toggle>
<label class="icon cursor" for=chapter-128b630a8f88f158e7027fe6c2184d21><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/bibliography/>Apêndice B. Bibliografia</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/bibliography/#bibliography-freebsd>B.1. Livros específicos para o FreeBSD</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/bibliography/#bibliography-userguides>B.2. Guias de usuários</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/bibliography/#bibliography-adminguides>B.3. Guias de Administradores</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/bibliography/#bibliography-programmers>B.4. Guias de programadores</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/bibliography/#bibliography-osinternals>B.5. Internals do sistema operacional</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/bibliography/#bibliography-security>B.6. Referências de segurança</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/bibliography/#bibliography-hardware>B.7. Referências de Hardware</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/bibliography/#bibliography-history>B.8. História do UNIX™</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/bibliography/#bibliography-journals>B.9. Periódicos, Jornais e Revistas</a></li></ul></li><li><input type=checkbox id=chapter-8bbb8867c46dac315e2253945d8c18a8 class=toggle>
<label class="icon cursor" for=chapter-8bbb8867c46dac315e2253945d8c18a8><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/eresources/>Apêndice C. Recursos na Internet</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/eresources/#eresources-www>C.1. Websites</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/eresources/#eresources-mail>C.2. Listas de Discussão</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/eresources/#eresources-news>C.3. Grupos de Notícias Usenet</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/eresources/#eresources-web>C.4. Espelhos Oficiais</a></li></ul></li><li><input type=checkbox id=chapter-a80ea4f5a4480b8725422710f954ef36 class=toggle>
<label class="icon cursor" for=chapter-a80ea4f5a4480b8725422710f954ef36><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/pgpkeys/>Apêndice D. Chaves OpenPGP</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/pgpkeys/#pgpkeys-officers>D.1. Administradores</a></li></ul></li><li></li></ul></nav></div></aside><div class=book><div class=book-menu-mobile><label for=menu-control><span class=menu-control-button><i class="fa fa-list" aria-hidden=true title=Menu></i>
Menu</span></label></div><h1 class=title>Capítulo 18. GEOM: Framework de Transformação de Disco Modular</h1><div class="admonitionblock note"><p><i class="fa fa-exclamation-circle" aria-hidden=true></i>
Esta tradução pode estar desatualizada. Para ajudar com as traduções, acesse a <a href=https://translate-dev.freebsd.org/ target=_blank>ferramenta de traduções do FreeBSD</a>.</p></div><div class=toc-mobile><h3>Índice</h3><nav id=TableOfContents><ul><li><a href=#geom-synopsis>18.1. Sinopse</a></li><li><a href=#geom-striping>18.2. RAID0 - Striping</a></li><li><a href=#geom-mirror>18.3. RAID1 - Espelhamento</a></li><li><a href=#geom-raid3>18.4. RAID3 - Distribuição em Nível de Byte com Paridade Dedicada</a></li><li><a href=#geom-graid>18.5. Dispositivos RAID por Software</a></li><li><a href=#geom-ggate>18.6. GEOM Network Gate</a></li><li><a href=#geom-glabel>18.7. Rotulando Dispositivos de Disco</a></li><li><a href=#geom-gjournal>18.8. Journaling UFS através do GEOM</a></li></ul></nav></div><div class=book-content><div id=preamble><div class=sectionbody></div></div><div class=sect1><h2 id=geom-synopsis>18.1. Sinopse<a class=anchor href=#geom-synopsis></a></h2><div class=sectionbody><div class=paragraph><p>No FreeBSD, o framework GEOM permite acesso e controle à classes, tais como Master Boot Records e labels BSD, através do uso de provedores, ou dos dispositivos de disco em <span class=filename>/dev</span>. Ao suportar várias configurações de RAID via software, o GEOM fornece, de forma transparente, acesso ao sistema operacional e aos utilitários do sistema operacional.</p></div><div class=paragraph><p>Este capítulo aborda o uso de discos sob o framework do GEOM no FreeBSD. Isso inclui os principais utilitários de controle RAID os quais usam o framework para configuração. Este capítulo não é um guia definitivo para as configurações de RAID e somente as classificações de RAID suportadas pelo GEOM são discutidas.</p></div><div class=paragraph><p>Depois de ler este capítulo, você saberá:</p></div><div class=ulist><ul><li><p>Que tipo de suporte a RAID está disponível através do GEOM.</p></li><li><p>Como usar os utilitários da base para configurar, manter e manipular os vários níveis de RAID.</p></li><li><p>Como espelhar, distribuir, criptografar e conectar remotamente dispositivos de disco por meio do GEOM.</p></li><li><p>Como solucionar problemas de discos conectados ao framework do GEOM.</p></li></ul></div><div class=paragraph><p>Antes de ler este capítulo, você deve:</p></div><div class=ulist><ul><li><p>Entender como o FreeBSD trata os dispositivos de disco (<a href=../disks/#disks>Armazenamento</a>).</p></li><li><p>Saber como configurar e instalar um novo kernel (<a href=../kernelconfig/#kernelconfig>Configurando o kernel do FreeBSD</a>).</p></li></ul></div></div></div><div class=sect1><h2 id=geom-striping>18.2. RAID0 - Striping<a class=anchor href=#geom-striping></a></h2><div class=sectionbody><div class=paragraph><p>O striping combina várias unidades de disco em um único volume. O striping pode ser realizado através do uso de hardwares controladores de RAID. O subsistema de disco GEOM fornece suporte de software para striping de disco, também conhecido como RAID0, sem a necessidade de um controlador RAID de disco.</p></div><div class=paragraph><p>No RAID0, os dados são divididos em blocos que são gravados em todas as unidades do array. Como pode ser visto na ilustração a seguir, em vez de esperar no sistema para gravar 256k em um disco, o RAID0 pode gravar 64k simultaneamente em cada um dos quatro discos do array, oferecendo um desempenho de I/O superior. Esse desempenho pode ser aprimorado ainda mais usando vários controladores de disco.</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/geom/striping.png alt="Disk Striping Illustration"></div></div><div class=paragraph><p>Cada disco em um stripe RAID0 deve ser do mesmo tamanho, pois as solicitações de I/O são intercaladas para ler ou gravar em vários discos em paralelo.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>O RAID0 <em>não</em> fornece qualquer redundância. Isso significa que, se um disco no array falhar, todos os dados nos discos serão perdidos. Se os dados forem importantes, implemente uma estratégia de backup que salva regularmente os backups em um sistema ou dispositivo remoto.</p></div></td></tr></tbody></table></div><div class=paragraph><p>O processo para criar um RAID0 por software, baseado no GEOM, em um sistema FreeBSD usando discos comuns é o seguinte. Uma vez que o stripe tiver sido criado, consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=gstripe&amp;sektion=8&amp;format=html">gstripe(8)</a> para obter maioress informações sobre como controlar uma stripe existente.</p></div><div class="exampleblock procedure"><div class=content><div class=paragraph><p><strong>Procedure: Criando um Stripe de Discos ATA Não Formatados</strong></p></div><div class="olist arabic"><ol class=arabic><li><p>Carregue o módulo <span class=filename>geom_stripe.ko</span>:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload geom_stripe</span></code></pre></div></div></li><li><p>Assegure-se de que exista um ponto de montagem adequado. Se esse volume se tornar uma partição root, use temporariamente outro ponto de montagem, como <span class=filename>/mnt</span>.</p></li><li><p>Determine os nomes dos dispositivos para os discos que serão striped e crie o novo dispositivo de stripe. Por exemplo, para distribuir dois discos ATA não utilizados e não particionados com nomes de dispositivos <span class=filename>/dev/ad2</span> e <span class=filename>/dev/ad3</span>:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gstripe label -v st0 /dev/ad2 /dev/ad3</span>
Metadata value stored on /dev/ad2.
Metadata value stored on /dev/ad3.
Done.</code></pre></div></div></li><li><p>Escreva um label padrão, também conhecido como tabela de partição, no novo volume e instale o código do bootstrap padrão:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># bsdlabel -wB /dev/stripe/st0</span></code></pre></div></div></li><li><p>Este processo deve criar dois outros dispositivos em <span class=filename>/dev/stripe</span> além de <span class=filename>st0</span>. Esses incluem o <span class=filename>st0a</span> e o <span class=filename>st0c</span>. Neste ponto, um sistema de arquivos UFS pode ser criado no <span class=filename>st0a</span> usando o <code>newfs</code>:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># newfs -U /dev/stripe/st0a</span></code></pre></div></div><div class=paragraph><p>Muitos números irão deslizar pela tela e, após alguns segundos, o processo será concluído. O volume foi criado e está pronto para ser montado.</p></div></li><li><p>Para montar manualmente o stripe de disco criado:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount /dev/stripe/st0a /mnt</span></code></pre></div></div></li><li><p>Para montar este sistema de arquivos distribuído automaticamente durante o processo de inicialização, coloque as informações do volume no arquivo <span class=filename>/etc/fstab</span>. Neste exemplo, um ponto de montagem permanente, chamado <span class=filename>stripe</span>, é criado:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mkdir /stripe</span>
<span class=c># echo &#34;/dev/stripe/st0a /stripe ufs rw 2 2&#34; \</span>
<span class=o>&gt;&gt;</span> /etc/fstab</code></pre></div></div></li><li><p>O módulo <span class=filename>geom_stripe.ko</span> também deve ser carregado automaticamente durante a inicialização do sistema, adicionando uma linha ao arquivo <span class=filename>/boot/loader.conf</span>:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># echo &#39;geom_stripe_load=&#34;YES&#34;&#39; &gt;&gt; /boot/loader.conf</span></code></pre></div></div></li></ol></div></div></div></div></div><div class=sect1><h2 id=geom-mirror>18.3. RAID1 - Espelhamento<a class=anchor href=#geom-mirror></a></h2><div class=sectionbody><div class=paragraph><p>O RAID1, ou <em>espelhamento</em>, é a técnica de gravar os mesmos dados em mais de uma unidade de disco. Os espelhos são geralmente usados para proteger contra perda de dados devido a falhas na unidade. Cada unidade espelhada contém uma cópia idêntica dos dados. Quando uma unidade individual falha, o espelhamento continua a funcionar, fornecendo dados a partir das unidades que ainda estão funcionando. O computador continua funcionando e o administrador tem tempo para substituir a unidade com falha sem impactar o usuário.</p></div><div class=paragraph><p>Duas situações comuns são ilustradas nesses exemplos. O primeiro cria um espelhamento de dois novos discos e usa-o como um substituto para um único disco existente. O segundo exemplo cria um espelho em um único disco novo, copia os dados do disco antigo para ele e insere o disco antigo no espelho. Embora esse procedimento seja um pouco mais complicado, ele requer apenas um novo disco.</p></div><div class=paragraph><p>Tradicionalmente, os dois discos em um espelhamento são idênticos em modelo e capacidade, mas o <a href="https://man.freebsd.org/cgi/man.cgi?query=gmirror&amp;sektion=8&amp;format=html">gmirror(8)</a> não requer isso. Os espelhamentos criados com discos diferentes terão uma capacidade igual à da menor unidade no espelhamento. O espaço extra em discos maiores não será usado. Os discos inseridos posteriormente no espelhamento devem ter pelo menos a mesma capacidade que o menor disco já existente no espelhamento.</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Os procedimentos de espelhamento mostrados aqui são não-destrutivos, mas como em qualquer grande operação de disco, faça um backup completo primeiro.</p></div></td></tr></tbody></table></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Embora o <a href="https://man.freebsd.org/cgi/man.cgi?query=dump&amp;sektion=8&amp;format=html">dump(8)</a> seja usado nesses procedimentos para copiar sistemas de arquivos, ele não funciona em sistemas de arquivos com Soft Updates Journaling. Consulte o <a href="https://man.freebsd.org/cgi/man.cgi?query=tunefs&amp;sektion=8&amp;format=html">tunefs(8)</a> para obter informações sobre como detectar e desativar o Soft Updates Journaling.</p></div></td></tr></tbody></table></div><div class=sect2><h3 id=geom-mirror-metadata>18.3.1. Problemas de Metadados<a class=anchor href=#geom-mirror-metadata></a></h3><div class=paragraph><p>Muitos sistemas de disco armazenam metadados no final de cada disco. Metadados antigos devem ser apagados antes de reutilizar o disco em um espelhamento. A maioria dos problemas é causada por dois tipos particulares de metadados residuais: tabelas de partição GPT e metadados antigos de um espelhamento anterior.</p></div><div class=paragraph><p>Os metadados GPT podem ser apagados com <a href="https://man.freebsd.org/cgi/man.cgi?query=gpart&amp;sektion=8&amp;format=html">gpart(8)</a>. Este exemplo apaga as tabelas de partições primárias e de backup do GPT do disco <span class=filename>ada8</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gpart destroy -F ada8</span></code></pre></div></div><div class=paragraph><p>Um disco pode ser removido de um espelhamento ativo e os metadados apagados em uma etapa usando <a href="https://man.freebsd.org/cgi/man.cgi?query=gmirror&amp;sektion=8&amp;format=html">gmirror(8)</a>. Aqui, o disco de exemplo <span class=filename>ada8</span> é removido do espelhamento ativo <span class=filename>gm4</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gmirror remove gm4 ada8</span></code></pre></div></div><div class=paragraph><p>Se o espelhamento não estiver em execução, mas os metadados do espelhamento antigo ainda estiverem no disco, use o comando <code>gmirror clear</code> para removê-lo:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gmirror clear ada8</span></code></pre></div></div><div class=paragraph><p>O <a href="https://man.freebsd.org/cgi/man.cgi?query=gmirror&amp;sektion=8&amp;format=html">gmirror(8)</a> armazena um bloco de metadados no final do disco. Como os esquemas de partição GPT também armazenam metadados no final do disco, espelhar discos GPT inteiros com <a href="https://man.freebsd.org/cgi/man.cgi?query=gmirror&amp;sektion=8&amp;format=html">gmirror(8)</a> não é recomendado. O particionamento MBR é usado aqui porque armazena apenas uma tabela de partição no início do disco e não entra em conflito com os metadados espelhados.</p></div></div><div class=sect2><h3 id=geom-mirror-two-new-disks>18.3.2. Criando um Espelhamento com Dois Discos Novos<a class=anchor href=#geom-mirror-two-new-disks></a></h3><div class=paragraph><p>Neste exemplo, o FreeBSD já foi instalado em um único disco, <span class=filename>ada0</span>. Dois novos discos, <span class=filename>ada1</span> e <span class=filename>ada2</span>, foram conectados ao sistema. Um novo espelhamento será criado nesses dois discos e usado para substituir o antigo disco único.</p></div><div class=paragraph><p>O módulo do kernel <span class=filename>geom_mirror.ko</span> deve ser compilado no kernel ou carregado no boot ou em tempo de execução. Carregue manualmente o módulo do kernel agora:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gmirror load</span></code></pre></div></div><div class=paragraph><p>Crie o espelho com as duas novas unidades:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gmirror label -v gm0 /dev/ada1 /dev/ada2</span></code></pre></div></div><div class=paragraph><p>O <span class=filename>gm0</span> é um nome de dispositivo escolhido pelo usuário atribuído ao novo espelhamento. Depois que o espelhamento for iniciado, o nome desse dispositivo aparecerá em <span class=filename>/dev/mirror/</span>.</p></div><div class=paragraph><p>As tabelas de partição MBR e bsdlabel agora podem ser criadas no mirror com o <a href="https://man.freebsd.org/cgi/man.cgi?query=gpart&amp;sektion=8&amp;format=html">gpart(8)</a>. Este exemplo usa um layout de sistema de arquivos tradicional, com partições para <span class=filename>/</span>, swap, <span class=filename>/var</span>, <span class=filename>/tmp</span> e <span class=filename>/usr</span>. Um único <span class=filename>/</span> e uma partição swap também funcionarão.</p></div><div class=paragraph><p>As partições no espelho não precisam ser do mesmo tamanho que as do disco existente, mas devem ser grandes o suficiente para conter todos os dados já presentes no disco <span class=filename>ada0</span>.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gpart create -s MBR mirror/gm0</span>
<span class=c># gpart add -t freebsd -a 4k mirror/gm0</span>
<span class=c># gpart show mirror/gm0</span>
<span class=o>=&gt;</span>       63  156301423  mirror/gm0  MBR  <span class=o>(</span>74G<span class=o>)</span>
         63         63                    - free -  <span class=o>(</span>31k<span class=o>)</span>
        126  156301299                 1  freebsd  <span class=o>(</span>74G<span class=o>)</span>
  156301425         61                    - free -  <span class=o>(</span>30k<span class=o>)</span></code></pre></div></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gpart create -s BSD mirror/gm0s1</span>
<span class=c># gpart add -t freebsd-ufs  -a 4k -s 2g mirror/gm0s1</span>
<span class=c># gpart add -t freebsd-swap -a 4k -s 4g mirror/gm0s1</span>
<span class=c># gpart add -t freebsd-ufs  -a 4k -s 2g mirror/gm0s1</span>
<span class=c># gpart add -t freebsd-ufs  -a 4k -s 1g mirror/gm0s1</span>
<span class=c># gpart add -t freebsd-ufs  -a 4k       mirror/gm0s1</span>
<span class=c># gpart show mirror/gm0s1</span>
<span class=o>=&gt;</span>        0  156301299  mirror/gm0s1  BSD  <span class=o>(</span>74G<span class=o>)</span>
          0          2                      - free -  <span class=o>(</span>1.0k<span class=o>)</span>
          2    4194304                   1  freebsd-ufs  <span class=o>(</span>2.0G<span class=o>)</span>
    4194306    8388608                   2  freebsd-swap  <span class=o>(</span>4.0G<span class=o>)</span>
   12582914    4194304                   4  freebsd-ufs  <span class=o>(</span>2.0G<span class=o>)</span>
   16777218    2097152                   5  freebsd-ufs  <span class=o>(</span>1.0G<span class=o>)</span>
   18874370  137426928                   6  freebsd-ufs  <span class=o>(</span>65G<span class=o>)</span>
  156301298          1                      - free -  <span class=o>(</span>512B<span class=o>)</span></code></pre></div></div><div class=paragraph><p>Torne o espelhamento inicializável instalando o bootcode no MBR e no bsdlabel e definindo a slice ativa:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gpart bootcode -b /boot/mbr mirror/gm0</span>
<span class=c># gpart set -a active -i 1 mirror/gm0</span>
<span class=c># gpart bootcode -b /boot/boot mirror/gm0s1</span></code></pre></div></div><div class=paragraph><p>Formate os sistemas de arquivos no novo espelhamento, habilitando as atualizações simples.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># newfs -U /dev/mirror/gm0s1a</span>
<span class=c># newfs -U /dev/mirror/gm0s1d</span>
<span class=c># newfs -U /dev/mirror/gm0s1e</span>
<span class=c># newfs -U /dev/mirror/gm0s1f</span></code></pre></div></div><div class=paragraph><p>Os sistemas de arquivos do disco original <span class=filename>ada0</span> agora podem ser copiados para o espelho com o <a href="https://man.freebsd.org/cgi/man.cgi?query=dump&amp;sektion=8&amp;format=html">dump(8)</a> e o <a href="https://man.freebsd.org/cgi/man.cgi?query=restore&amp;sektion=8&amp;format=html">restore(8)</a>.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount /dev/mirror/gm0s1a /mnt</span>
<span class=c># dump -C16 -b64 -0aL -f - / | (cd /mnt &amp;&amp; restore -rf -)</span>
<span class=c># mount /dev/mirror/gm0s1d /mnt/var</span>
<span class=c># mount /dev/mirror/gm0s1e /mnt/tmp</span>
<span class=c># mount /dev/mirror/gm0s1f /mnt/usr</span>
<span class=c># dump -C16 -b64 -0aL -f - /var | (cd /mnt/var &amp;&amp; restore -rf -)</span>
<span class=c># dump -C16 -b64 -0aL -f - /tmp | (cd /mnt/tmp &amp;&amp; restore -rf -)</span>
<span class=c># dump -C16 -b64 -0aL -f - /usr | (cd /mnt/usr &amp;&amp; restore -rf -)</span></code></pre></div></div><div class=paragraph><p>Edite o arquivo <span class=filename>/mnt/etc/fstab</span> para apontar para os novos sistemas de arquivos espelhados:</p></div><div class="literalblock programlisting"><div class=content><pre># Device		Mountpoint	FStype	Options	Dump	Pass#
/dev/mirror/gm0s1a	/		ufs	rw	1	1
/dev/mirror/gm0s1b	none		swap	sw	0	0
/dev/mirror/gm0s1d	/var		ufs	rw	2	2
/dev/mirror/gm0s1e	/tmp		ufs	rw	2	2
/dev/mirror/gm0s1f	/usr		ufs	rw	2	2</pre></div></div><div class=paragraph><p>Se o módulo do kernel <span class=filename>geom_mirror.ko</span> não foi compilado no kernel, o <span class=filename>/mnt/boot/loader.conf</span> é editado para carregar o módulo na inicialização:</p></div><div class="literalblock programlisting"><div class=content><pre>geom_mirror_load=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Reinicialize o sistema para testar o novo espelhamento e verifique se todos os dados foram copiados. A BIOS verá o espelhamento como duas unidades individuais em vez de um espelhamento. Como as unidades são idênticas, não importa qual seja selecionado para inicializar.</p></div><div class=paragraph><p>Veja <a href=#gmirror-troubleshooting>Solução de problemas</a> se houver problemas ao inicializar. Desligar e desconectar o disco original <span class=filename>ada0</span> permitirá que ele seja mantido como um backup offline.</p></div><div class=paragraph><p>Em uso, o espelhamento se comportará exatamente como a unidade original.</p></div></div><div class=sect2><h3 id=geom-mirror-existing-drive>18.3.3. Criando um Espelhamento com Uma Unidade Existente<a class=anchor href=#geom-mirror-existing-drive></a></h3><div class=paragraph><p>Neste exemplo, o FreeBSD já foi instalado em um único disco, <span class=filename>ada0</span>. Um novo disco, <span class=filename>ada1</span>, foi conectado ao sistema. Um espelhamento de um disco será criado no novo disco, o sistema existente será copiado para ele e, em seguida, o disco antigo será inserido no espelho. Esse procedimento um pouco complexo é necessário porque o <code>gmirror</code> precisa colocar um bloco de metadados de 512 bytes no final de cada disco, e o <span class=filename>ada0</span> geralmente possui todo o seu espaço já alocado.</p></div><div class=paragraph><p>Carregue o módulo do kernel <span class=filename>geom_mirror.ko</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gmirror load</span></code></pre></div></div><div class=paragraph><p>Verifique o tamanho da mídia do disco original com <code>diskinfo</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># diskinfo -v ada0 | head -n3</span>
/dev/ada0
	512             <span class=c># sectorsize</span>
	1000204821504   <span class=c># mediasize in bytes (931G)</span></code></pre></div></div><div class=paragraph><p>Crie um espelhamento no novo disco. Para garantir que a capacidade do espelhamento não seja maior do que a unidade <span class=filename>ada0</span> original, <a href="https://man.freebsd.org/cgi/man.cgi?query=gnop&amp;sektion=8&amp;format=html">gnop(8)</a> é usado para criar uma unidade falsa exatamente do mesmo tamanho. Esta unidade não armazena dados, mas é usada apenas para limitar o tamanho do espelhamento. Quando o <a href="https://man.freebsd.org/cgi/man.cgi?query=gmirror&amp;sektion=8&amp;format=html">gmirror(8)</a> cria o espelhamento, ele irá restringir a capacidade ao tamanho de <span class=filename>gzero.nop</span>, mesmo se a nova unidade <span class=filename>ada1</span> tiver mais espaço. Note que o <em>1000204821504</em> na segunda linha é igual ao tamanho de mídia do <span class=filename>ada0</span> como mostrado pelo comando <code>diskinfo</code> acima.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># geom zero load</span>
<span class=c># gnop create -s 1000204821504 gzero</span>
<span class=c># gmirror label -v gm0 gzero.nop ada1</span>
<span class=c># gmirror forget gm0</span></code></pre></div></div><div class=paragraph><p>Como o <span class=filename>gzero.nop</span> não armazena nenhum dado, o espelhamento não o vê como conectado. É dito para o espelhamento "esquecer" os componentes desconectados, removendo referências para <span class=filename>gzero.nop</span>. O resultado é um dispositivo espelhado contendo apenas um único disco, <span class=filename>ada1</span>.</p></div><div class=paragraph><p>Depois de criar o <span class=filename>gm0</span>, veja a tabela de partições em <span class=filename>ada0</span>. Esta saída é de uma unidade de 1 TB. Se houver algum espaço não alocado no final da unidade, o conteúdo pode ser copiado diretamente de <span class=filename>ada0</span> para o novo espelho.</p></div><div class=paragraph><p>No entanto, se a saída mostrar que todo o espaço no disco está alocado, como na listagem a seguir, não há espaço disponível para os 512-bytes de metadados de espelhamento no final do disco.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gpart show ada0</span>
<span class=o>=&gt;</span>        63  1953525105        ada0  MBR  <span class=o>(</span>931G<span class=o>)</span>
          63  1953525105           1  freebsd  <span class=o>[</span>active]  <span class=o>(</span>931G<span class=o>)</span></code></pre></div></div><div class=paragraph><p>Neste caso, a tabela de partição deve ser editada para reduzir a capacidade de um setor em <span class=filename>mirror/gm0</span>. O procedimento será explicado mais tarde.</p></div><div class=paragraph><p>Em qualquer um dos casos, as tabelas de partição no disco principal devem ser primeiro copiadas usando <code>gpart backup</code> e <code>gpart restore</code>.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gpart backup ada0 &gt; table.ada0</span>
<span class=c># gpart backup ada0s1 &gt; table.ada0s1</span></code></pre></div></div><div class=paragraph><p>Esses comandos criam dois arquivos, <span class=filename>table.ada0</span> e <span class=filename>table.ada0s1</span>. Este exemplo é de uma unidade de 1 TB:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cat table.ada0</span>
MBR 4
1 freebsd         63 1953525105   <span class=o>[</span>active]</code></pre></div></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cat table.ada0s1</span>
BSD 8
1  freebsd-ufs          0    4194304
2 freebsd-swap    4194304   33554432
4  freebsd-ufs   37748736   50331648
5  freebsd-ufs   88080384   41943040
6  freebsd-ufs  130023424  838860800
7  freebsd-ufs  968884224  984640881</code></pre></div></div><div class=paragraph><p>Se nenhum espaço livre for exibido no final do disco, o tamanho da slice e da última partição deve ser reduzido por um setor. Edite os dois arquivos, reduzindo o tamanho da fatia e da última partição em um. Estes são os últimos números em cada listagem.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cat table.ada0</span>
MBR 4
1 freebsd         63 1953525104   <span class=o>[</span>active]</code></pre></div></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cat table.ada0s1</span>
BSD 8
1  freebsd-ufs          0    4194304
2 freebsd-swap    4194304   33554432
4  freebsd-ufs   37748736   50331648
5  freebsd-ufs   88080384   41943040
6  freebsd-ufs  130023424  838860800
7  freebsd-ufs  968884224  984640880</code></pre></div></div><div class=paragraph><p>Se pelo menos um setor não foi alocado no final do disco, esses dois arquivos podem ser usados sem modificação.</p></div><div class=paragraph><p>Agora restaure a tabela de partições em <span class=filename>mirror/gm0</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gpart restore mirror/gm0 &lt; table.ada0</span>
<span class=c># gpart restore mirror/gm0s1 &lt; table.ada0s1</span></code></pre></div></div><div class=paragraph><p>Verifique a tabela de partições com o comando <code>gpart show</code>. Este exemplo tem <span class=filename>gm0s1a</span> para <span class=filename>/</span>, <span class=filename>gm0s1d</span> para <span class=filename>/var</span>, <span class=filename>gm0s1e</span> para <span class=filename>/usr</span>, <span class=filename>gm0s1f</span> para <span class=filename>/data1</span> e <span class=filename>gm0s1g</span> para <span class=filename>/data2</span>.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gpart show mirror/gm0</span>
<span class=o>=&gt;</span>        63  1953525104  mirror/gm0  MBR  <span class=o>(</span>931G<span class=o>)</span>
          63  1953525042           1  freebsd  <span class=o>[</span>active]  <span class=o>(</span>931G<span class=o>)</span>
  1953525105          62              - free -  <span class=o>(</span>31k<span class=o>)</span>

<span class=c># gpart show mirror/gm0s1</span>
<span class=o>=&gt;</span>         0  1953525042  mirror/gm0s1  BSD  <span class=o>(</span>931G<span class=o>)</span>
           0     2097152             1  freebsd-ufs  <span class=o>(</span>1.0G<span class=o>)</span>
     2097152    16777216             2  freebsd-swap  <span class=o>(</span>8.0G<span class=o>)</span>
    18874368    41943040             4  freebsd-ufs  <span class=o>(</span>20G<span class=o>)</span>
    60817408    20971520             5  freebsd-ufs  <span class=o>(</span>10G<span class=o>)</span>
    81788928   629145600             6  freebsd-ufs  <span class=o>(</span>300G<span class=o>)</span>
   710934528  1242590514             7  freebsd-ufs  <span class=o>(</span>592G<span class=o>)</span>
  1953525042          63                - free -  <span class=o>(</span>31k<span class=o>)</span></code></pre></div></div><div class=paragraph><p>Tanto a fatia quanto a última partição devem ter pelo menos um bloco livre no final do disco.</p></div><div class=paragraph><p>Crie sistemas de arquivos nessas novas partições. O número de partições varia de acordo com o disco original, <span class=filename>ada0</span>.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># newfs -U /dev/mirror/gm0s1a</span>
<span class=c># newfs -U /dev/mirror/gm0s1d</span>
<span class=c># newfs -U /dev/mirror/gm0s1e</span>
<span class=c># newfs -U /dev/mirror/gm0s1f</span>
<span class=c># newfs -U /dev/mirror/gm0s1g</span></code></pre></div></div><div class=paragraph><p>Torne o espelhamento inicializável instalando o bootcode no MBR e no bsdlabel e definindo a slice ativa:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gpart bootcode -b /boot/mbr mirror/gm0</span>
<span class=c># gpart set -a active -i 1 mirror/gm0</span>
<span class=c># gpart bootcode -b /boot/boot mirror/gm0s1</span></code></pre></div></div><div class=paragraph><p>Ajuste o arquivo <span class=filename>/etc/fstab</span> para usar as novas partições no espelhamento.Primeiro faça o backup deste arquivo copiando ele para <span class=filename>/etc/fstab.orig</span>.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cp /etc/fstab /etc/fstab.orig</span></code></pre></div></div><div class=paragraph><p>Edite o arquivo <span class=filename>/etc/fstab</span>, substituindo <span class=filename>/dev/ada0</span> por <span class=filename>mirror/gm0</span>.</p></div><div class="literalblock programlisting"><div class=content><pre># Device		Mountpoint	FStype	Options	Dump	Pass#
/dev/mirror/gm0s1a	/		ufs	rw	1	1
/dev/mirror/gm0s1b	none		swap	sw	0	0
/dev/mirror/gm0s1d	/var		ufs	rw	2	2
/dev/mirror/gm0s1e	/usr		ufs	rw	2	2
/dev/mirror/gm0s1f	/data1		ufs	rw	2	2
/dev/mirror/gm0s1g	/data2		ufs	rw	2	2</pre></div></div><div class=paragraph><p>Se o módulo do kernel <span class=filename>geom_mirror.ko</span> não foi carregado no kernel, edite o arquivo <span class=filename>/boot/loader.conf</span> para carregá-lo no boot:</p></div><div class="literalblock programlisting"><div class=content><pre>geom_mirror_load=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Os sistemas de arquivos do disco original agora podem ser copiados para o espelhamento com o <a href="https://man.freebsd.org/cgi/man.cgi?query=dump&amp;sektion=8&amp;format=html">dump(8)</a> e o <a href="https://man.freebsd.org/cgi/man.cgi?query=restore&amp;sektion=8&amp;format=html">restore(8)</a>. Cada sistema de arquivos copiados com o <code>dump -L</code> irá primeiro criar um snapshot, o que pode levar algum tempo.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount /dev/mirror/gm0s1a /mnt</span>
<span class=c># dump -C16 -b64 -0aL -f - /    | (cd /mnt &amp;&amp; restore -rf -)</span>
<span class=c># mount /dev/mirror/gm0s1d /mnt/var</span>
<span class=c># mount /dev/mirror/gm0s1e /mnt/usr</span>
<span class=c># mount /dev/mirror/gm0s1f /mnt/data1</span>
<span class=c># mount /dev/mirror/gm0s1g /mnt/data2</span>
<span class=c># dump -C16 -b64 -0aL -f - /usr | (cd /mnt/usr &amp;&amp; restore -rf -)</span>
<span class=c># dump -C16 -b64 -0aL -f - /var | (cd /mnt/var &amp;&amp; restore -rf -)</span>
<span class=c># dump -C16 -b64 -0aL -f - /data1 | (cd /mnt/data1 &amp;&amp; restore -rf -)</span>
<span class=c># dump -C16 -b64 -0aL -f - /data2 | (cd /mnt/data2 &amp;&amp; restore -rf -)</span></code></pre></div></div><div class=paragraph><p>Reinicie o sistema, inicializando a partir do <span class=filename>ada1</span>. Se tudo estiver funcionando, o sistema irá inicializar a partir de <span class=filename>mirror/gm0</span>, que agora contém os mesmos dados que o <span class=filename>ada0</span> tinha anteriormente. Veja <a href=#gmirror-troubleshooting>Solução de problemas</a> se houver problemas ao inicializar.</p></div><div class=paragraph><p>Neste ponto, o espelhamento ainda consiste apenas no único disco <span class=filename>ada1</span>.</p></div><div class=paragraph><p>Após inicializar a partir de <span class=filename>mirror/gm0</span> com sucesso, a etapa final é inserir <span class=filename>ada0</span> no espelhamento.</p></div><div class="admonitionblock important"><table><tbody><tr><td class=icon><i class="fa icon-important" title=Important></i></td><td class=content><div class=paragraph><p>Quando o <span class=filename>ada0</span> for inserido no espelhamento, seu conteúdo anterior será substituído pelos dados do espelhamento. Certifique-se de que <span class=filename>mirror/gm0</span> tenha o mesmo conteúdo do <span class=filename>ada0</span> antes de adicionar o <span class=filename>ada0</span> ao espelhamento. Se o conteúdo anteriormente copiado pelo <a href="https://man.freebsd.org/cgi/man.cgi?query=dump&amp;sektion=8&amp;format=html">dump(8)</a> e <a href="https://man.freebsd.org/cgi/man.cgi?query=restore&amp;sektion=8&amp;format=html">restore(8)</a> não forem idênticos ao que estava em <span class=filename>ada0</span>, reverta o arquivo <span class=filename>/etc/fstab</span> para montar os sistemas de arquivos em <span class=filename>ada0</span>, e reinicie todo o procedimento novamente.</p></div></td></tr></tbody></table></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gmirror insert gm0 ada0</span>
GEOM_MIRROR: Device gm0: rebuilding provider ada0</code></pre></div></div><div class=paragraph><p>A sincronização entre os dois discos será iniciada imediatamente. Use <code>gmirror status</code> para visualizar o progresso.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gmirror status</span>
      Name    Status  Components
mirror/gm0  DEGRADED  ada1 <span class=o>(</span>ACTIVE<span class=o>)</span>
                      ada0 <span class=o>(</span>SYNCHRONIZING, 64%<span class=o>)</span></code></pre></div></div><div class=paragraph><p>Depois de um tempo, a sincronização será concluída.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>GEOM_MIRROR: Device gm0: rebuilding provider ada0 finished.
<span class=c># gmirror status</span>
      Name    Status  Components
mirror/gm0  COMPLETE  ada1 <span class=o>(</span>ACTIVE<span class=o>)</span>
                      ada0 <span class=o>(</span>ACTIVE<span class=o>)</span></code></pre></div></div><div class=paragraph><p>O <span class=filename>mirror/gm0</span> agora consiste de dois discos <span class=filename>ada0</span> e <span class=filename>ada1</span>, e o conteúdo é automaticamente sincronizado entre eles. Em uso, o <span class=filename>mirror/gm0</span> irá se comportar como a única unidade original.</p></div></div><div class=sect2><h3 id=gmirror-troubleshooting>18.3.4. Solução de problemas<a class=anchor href=#gmirror-troubleshooting></a></h3><div class=paragraph><p>Se o sistema não inicializar mais, as configurações da BIOS podem ter que ser alteradas para inicializar a partir de uma das novas unidades espelhadas. Qualquer uma das unidades espelhadas pode ser usada para inicializar, pois elas contêm dados idênticos.</p></div><div class=paragraph><p>Se a inicialização parar com esta mensagem, algo está errado com o dispositivo espelhado:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Mounting from ufs:/dev/mirror/gm0s1a failed with error 19.

Loader variables:
  vfs.root.mountfrom<span class=o>=</span>ufs:/dev/mirror/gm0s1a
  vfs.root.mountfrom.options<span class=o>=</span>rw

Manual root filesystem specification:
  &lt;fstype&gt;:&lt;device&gt; <span class=o>[</span>options]
      Mount &lt;device&gt; using filesystem &lt;fstype&gt;
      and with the specified <span class=o>(</span>optional<span class=o>)</span> option list.

    eg. ufs:/dev/da0s1a
        zfs:tank
        cd9660:/dev/acd0 ro
          <span class=o>(</span>which is equivalent to: mount <span class=nt>-t</span> cd9660 <span class=nt>-o</span> ro /dev/acd0 /<span class=o>)</span>

  ?               List valid disk boot devices
  <span class=nb>.</span>               Yield 1 second <span class=o>(</span><span class=k>for </span>background tasks<span class=o>)</span>
  &lt;empty line&gt;    Abort manual input

mountroot&gt;</code></pre></div></div><div class=paragraph><p>Esquecer de carregar o módulo <span class=filename>geom_mirror.ko</span> no arquivo <span class=filename>/boot/loader.conf</span> pode causar este problema. Para consertá-lo, inicialize a partir de uma mídia de instalação do FreeBSD e escolha <code>Shell</code> no primeiro prompt. Em seguida, carregue o módulo de espelhamento e monte o dispositivo espelhado:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gmirror load</span>
<span class=c># mount /dev/mirror/gm0s1a /mnt</span></code></pre></div></div><div class=paragraph><p>Edite o arquivo <span class=filename>/mnt/boot/loader.conf</span>, adicionando uma linha para carregar o módulo de espelhamento:</p></div><div class="literalblock programlisting"><div class=content><pre>geom_mirror_load=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Salve o arquivo e reinicie.</p></div><div class=paragraph><p>Outros problemas que causam o <code>error 19</code> requerem mais esforço para serem corrigidos. Embora o sistema deva inicializar a partir de <span class=filename>ada0</span>, outro prompt para selecionar um shell aparecerá se o arquivo <span class=filename>/etc/fstab</span> estiver incorreto. Digite <code>ufs:/dev/ada0s1a</code> no prompt do carregador de boot e pressione <kbd>Enter</kbd>. Desfaça as edições no arquivo <span class=filename>/etc/fstab</span> e monte os sistemas de arquivos a partir do disco original (<span class=filename>ada0</span>) em vez do espelhado. Reinicialize o sistema e tente o procedimento novamente.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Enter full pathname of shell or RETURN <span class=k>for</span> /bin/sh:
<span class=c># cp /etc/fstab.orig /etc/fstab</span>
<span class=c># reboot</span></code></pre></div></div></div><div class=sect2><h3 id=_recuperando_de_uma_falha_de_disco>18.3.5. Recuperando de Uma Falha de Disco<a class=anchor href=#_recuperando_de_uma_falha_de_disco></a></h3><div class=paragraph><p>O benefício do espelhamento de disco é que um disco individual pode falhar sem fazer com que o espelho perca qualquer dado. No exemplo acima, se <span class=filename>ada0</span> falhar, o espelho continuará funcionando, fornecendo dados a partir do disco que continua operacional, <span class=filename>ada1</span>.</p></div><div class=paragraph><p>Para substituir a unidade com falha, desligue o sistema e substitua fisicamente a unidade com falha por uma nova unidade com capacidade igual ou maior. Os fabricantes usam valores um tanto arbitrários ao classificar drives em gigabytes, e a única maneira de realmente ter certeza é comparar a contagem total de setores mostrados por <code>diskinfo -v</code>. Uma unidade com maior capacidade que o espelho funcionará, embora o espaço extra na nova unidade não seja usado.</p></div><div class=paragraph><p>Depois que o computador for ligado novamente, o espelho será executado em um modo "degradado" com apenas uma unidade. O espelho é avisado para esquecer as unidades que não estão conectadas no momento:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gmirror forget gm0</span></code></pre></div></div><div class=paragraph><p>Quaisquer metadados antigos devem ser apagados do disco de substituição usando as instruções em <a href=#geom-mirror-metadata>Problemas de Metadados</a>. Em seguida, o disco de substituição, <span class=filename>ada4</span> para este exemplo, é inserido no espelho:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gmirror insert gm0 /dev/ada4</span></code></pre></div></div><div class=paragraph><p>A ressincronização começa quando a nova unidade é inserida no espelho. Esse processo de copiar dados espelhados para uma nova unidade pode demorar um pouco. O desempenho do espelho será bastante reduzido durante a cópia, portanto, a inserção de novos discos é deve ser executada quando houver pouca demanda no computador.</p></div><div class=paragraph><p>O progresso pode ser monitorado com o comando <code>gmirror status</code>, que mostra as unidades que estão sendo sincronizadas e a porcentagem de conclusão. Durante a ressincronização, o status será <code>DEGRADED</code>, mudando para <code>COMPLETE</code> quando o processo for concluído.</p></div></div></div></div><div class=sect1><h2 id=geom-raid3>18.4. RAID3 - Distribuição em Nível de Byte com Paridade Dedicada<a class=anchor href=#geom-raid3></a></h2><div class=sectionbody><div class=paragraph><p>O RAID3 é um método usado para combinar várias unidades de disco em um único volume com um disco de paridade dedicado. Em um sistema RAID3, os dados são divididos em vários bytes que são escritos em todas as unidades da matriz, exceto por um disco que atua como um disco de paridade dedicado. Isso significa que as leituras de disco de uma implementação de RAID3 acessam todos os discos na matriz. O desempenho pode ser aprimorado usando vários controladores de disco. O array RAID3 fornece uma tolerância a falhas de 1 unidade, enquanto fornece uma capacidade de 1 - 1/n vezes a capacidade total de todas as unidades no array, onde n é o número de unidades de disco rígido no array. Essa configuração é adequada principalmente para armazenar dados de tamanhos maiores, como arquivos multimídia.</p></div><div class=paragraph><p>Pelo menos 3 discos rígidos físicos são necessários para criar um array RAID3. Cada disco deve ter o mesmo tamanho, pois as solicitações de I/O são intercaladas para ler ou gravar em vários discos em paralelo. Além disso, devido à natureza do RAID3, o número de unidades deve ser igual a 3, 5, 9, 17 e assim por diante, ou 2^n + 1.</p></div><div class=paragraph><p>Esta seção demonstra como criar um RAID3 via software em um sistema FreeBSD.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Embora seja teoricamente possível inicializar a partir de um array RAID3 no FreeBSD, essa configuração é incomum e não é recomendada.</p></div></td></tr></tbody></table></div><div class=sect2><h3 id=_criando_uma_matriz_raid3_dedicada>18.4.1. Criando uma Matriz RAID3 Dedicada<a class=anchor href=#_criando_uma_matriz_raid3_dedicada></a></h3><div class=paragraph><p>No FreeBSD, o suporte para RAID3 é implementado pela classe GEOM<a href="https://man.freebsd.org/cgi/man.cgi?query=graid3&amp;sektion=8&amp;format=html">graid3(8)</a>. Criar um array dedicado de RAID3 no FreeBSD requer os seguintes passos.</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Primeiro, carregue o módulo do kernel <span class=filename>geom_raid3.ko</span> emitindo um dos seguintes comandos:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># graid3 load</span></code></pre></div></div><div class=paragraph><p>ou:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload geom_raid3</span></code></pre></div></div></li><li><p>Assegure-se de que exista um ponto de montagem adequado. Este comando cria um novo diretório para usar como ponto de montagem:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mkdir /multimedia</span></code></pre></div></div></li><li><p>Determine os nomes dos dispositivos para os discos que serão adicionados à matriz e crie o novo dispositivo RAID3. O dispositivo final listado atuará como o disco de paridade dedicado. Este exemplo usa três unidades ATA não-particionadas: <span class=filename>ada1</span> e <span class=filename>ada2</span> para dados e <span class=filename>ada3</span> para paridade.</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># graid3 label -v gr0 /dev/ada1 /dev/ada2 /dev/ada3</span>
Metadata value stored on /dev/ada1.
Metadata value stored on /dev/ada2.
Metadata value stored on /dev/ada3.
Done.</code></pre></div></div></li><li><p>Particione o dispositivo <span class=filename>gr0</span> recém-criado e coloque um sistema de arquivos UFS:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gpart create -s GPT /dev/raid3/gr0</span>
<span class=c># gpart add -t freebsd-ufs /dev/raid3/gr0</span>
<span class=c># newfs -j /dev/raid3/gr0p1</span></code></pre></div></div><div class=paragraph><p>Muitos números irão ser exibios na tela e, após algum tempo, o processo será concluído. O volume foi criado e está pronto para ser montado:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount /dev/raid3/gr0p1 /multimedia/</span></code></pre></div></div><div class=paragraph><p>A matriz RAID3 está agora pronta para uso.</p></div></li></ol></div></div></div><div class=paragraph><p>Uma configuração adicional é necessária para manter essa configuração nas reinicializações do sistema.</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>O módulo <span class=filename>geom_raid3.ko</span> deve ser carregado antes que o array possa ser montado. Para carregar automaticamente o módulo do kernel durante a inicialização do sistema, adicione a seguinte linha ao arquivo <span class=filename>/boot/loader.conf</span>:</p><div class="literalblock programlisting"><div class=content><pre>geom_raid3_load=&#34;YES&#34;</pre></div></div></li><li><p>As seguintes informações de volume devem ser adicionadas ao arquivo <span class=filename>/etc/fstab</span> para montar automaticamente o sistema de arquivos do array durante o processo de inicialização do sistema:</p><div class="literalblock programlisting"><div class=content><pre>/dev/raid3/gr0p1	/multimedia	ufs	rw	2	2</pre></div></div></li></ol></div></div></div></div></div></div><div class=sect1><h2 id=geom-graid>18.5. Dispositivos RAID por Software<a class=anchor href=#geom-graid></a></h2><div class=sectionbody><div class=paragraph><p>Algumas placas-mãe e placas de expansão adicionam um hardware simples, geralmente apenas uma ROM, que permite que o computador inicialize a partir de um array RAID. Após a inicialização, o acesso ao array RAID é feito pelo software em execução no processador principal do computador. Este "RAID via software assistido por hardware" fornece arrays RAID que não dependem de nenhum sistema operacional em particular, e que são funcionais antes mesmo de um sistema operacional ser carregado.</p></div><div class=paragraph><p>Vários níveis de RAID são suportados, dependendo do hardware em uso. Veja <a href="https://man.freebsd.org/cgi/man.cgi?query=graid&amp;sektion=8&amp;format=html">graid(8)</a> para uma lista completa.</p></div><div class=paragraph><p>O <a href="https://man.freebsd.org/cgi/man.cgi?query=graid&amp;sektion=8&amp;format=html">graid(8)</a> requer o módulo do kernel <span class=filename>geom_raid.ko</span>, que está incluído no kernel <span class=filename>GENERIC</span> a partir do FreeBSD 9.1. Se necessário, ele pode ser carregado manualmente com o comando <code>graid load</code>.</p></div><div class=sect2><h3 id=geom-graid-creating>18.5.1. Criando um Array<a class=anchor href=#geom-graid-creating></a></h3><div class=paragraph><p>Os dispositivos de RAID via software geralmente têm um menu que pode ser acessado pressionando teclas especiais quando o computador está inicializando. O menu pode ser usado para criar e excluir arrays RAID. O <a href="https://man.freebsd.org/cgi/man.cgi?query=graid&amp;sektion=8&amp;format=html">graid(8)</a> também pode criar arrays diretamente a partir da linha de comando.</p></div><div class=paragraph><p>O <code>graid label</code> é usado para criar um novo array. A placa-mãe usada neste exemplo tem um chipset RAID da Intel, portanto, o formato de metadados da Intel é especificado. A nova matriz recebe um rótulo de <span class=filename>gm0</span>, é um espelhamento (RAID1) e usa as unidades <span class=filename>ada0</span> e <span class=filename>ada1</span>.</p></div><div class="admonitionblock caution"><table><tbody><tr><td class=icon><i class="fa icon-caution" title=Caution></i></td><td class=content><div class=paragraph><p>Algum espaço nas unidades será sobrescrito quando elas forem transformadas em um novo array. Faça o backup dos dados existentes primeiro!</p></div></td></tr></tbody></table></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># graid label Intel gm0 RAID1 ada0 ada1</span>
GEOM_RAID: Intel-a29ea104: Array Intel-a29ea104 created.
GEOM_RAID: Intel-a29ea104: Disk ada0 state changed from NONE to ACTIVE.
GEOM_RAID: Intel-a29ea104: Subdisk gm0:0-ada0 state changed from NONE to ACTIVE.
GEOM_RAID: Intel-a29ea104: Disk ada1 state changed from NONE to ACTIVE.
GEOM_RAID: Intel-a29ea104: Subdisk gm0:1-ada1 state changed from NONE to ACTIVE.
GEOM_RAID: Intel-a29ea104: Array started.
GEOM_RAID: Intel-a29ea104: Volume gm0 state changed from STARTING to OPTIMAL.
Intel-a29ea104 created
GEOM_RAID: Intel-a29ea104: Provider raid/r0 <span class=k>for </span>volume gm0 created.</code></pre></div></div><div class=paragraph><p>Uma verificação de status mostra que o novo espelhamento está pronto para uso:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># graid status</span>
   Name   Status  Components
raid/r0  OPTIMAL  ada0 <span class=o>(</span>ACTIVE <span class=o>(</span>ACTIVE<span class=o>))</span>
                  ada1 <span class=o>(</span>ACTIVE <span class=o>(</span>ACTIVE<span class=o>))</span></code></pre></div></div><div class=paragraph><p>O dispositivo de array aparece em <span class=filename>/dev/raid/</span>. O primeiro array é chamado de <span class=filename>r0</span>. Arrays adicionais, se presentes, serão <span class=filename>r1</span>, <span class=filename>r2</span> e assim por diante.</p></div><div class=paragraph><p>O menu da BIOS em alguns desses dispositivos pode criar arrays com caracteres especiais em seus nomes. Para evitar problemas com esses caracteres especiais, os arrays recebem nomes numerados simples como <span class=filename>r0</span>. Para mostrar os rótulos reais, como <span class=filename>gm0</span> no exemplo acima, use o <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl kern.geom.raid.name_format=1</span></code></pre></div></div></div><div class=sect2><h3 id=geom-graid-volumes>18.5.2. Múltiplos Volumes<a class=anchor href=#geom-graid-volumes></a></h3><div class=paragraph><p>Alguns dispositivos de RAID via software suportam mais de um <em>volume</em> em um array. Os volumes funcionam como partições, permitindo que o espaço nas unidades físicas seja dividido e usado de diferentes maneiras. Por exemplo, os dispositivos RAID via software Intel suportam dois volumes. Este exemplo cria um espelho de 40 G para armazenar com segurança o sistema operacional, seguido por um volume de 20 G RAID0 (stripe) para armazenamento temporário rápido:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># graid label -S 40G Intel gm0 RAID1 ada0 ada1</span>
<span class=c># graid add -S 20G gm0 RAID0</span></code></pre></div></div><div class=paragraph><p>Os volumes aparecem como entradas adicionais <span class=filename>rX</span> em <span class=filename>/dev/raid/</span>. Um array com dois volumes mostrará <span class=filename>r0</span> e <span class=filename>r1</span>.</p></div><div class=paragraph><p>Veja <a href="https://man.freebsd.org/cgi/man.cgi?query=graid&amp;sektion=8&amp;format=html">graid(8)</a> para o número de volumes suportados por diferentes dispositivos RAID via software.</p></div></div><div class=sect2><h3 id=geom-graid-converting>18.5.3. Convertendo uma Única Unidade em um Espelho<a class=anchor href=#geom-graid-converting></a></h3><div class=paragraph><p>Sob certas condições específicas, é possível converter uma única unidade existente em um array <a href="https://man.freebsd.org/cgi/man.cgi?query=graid&amp;sektion=8&amp;format=html">graid(8)</a> sem reformatar. Para evitar a perda de dados durante a conversão, a unidade existente deve atender a esses requisitos mínimos:</p></div><div class=ulist><ul><li><p>A unidade deve ser particionada com o esquema de particionamento MBR. O GPT ou outros esquemas de particionamento com metadados no final da unidade serão sobrescritos e corrompidos pelos metadados do <a href="https://man.freebsd.org/cgi/man.cgi?query=graid&amp;sektion=8&amp;format=html">graid(8)</a>.</p></li><li><p>Deve haver espaço não particionado e não utilizado o suficiente no final da unidade para conter os metadados do <a href="https://man.freebsd.org/cgi/man.cgi?query=graid&amp;sektion=8&amp;format=html">graid(8)</a>. Esses metadados variam em tamanho, mas o maior ocupa 64 M, então pelo menos este espaço livre é recomendado.</p></li></ul></div><div class=paragraph><p>Se a unidade atender a esses requisitos, comece fazendo um backup completo. Em seguida, crie um espelhamento de unidade única com essa unidade:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># graid label Intel gm0 RAID1 ada0 NONE</span></code></pre></div></div><div class=paragraph><p>Os metadados do <a href="https://man.freebsd.org/cgi/man.cgi?query=graid&amp;sektion=8&amp;format=html">graid(8)</a> foram gravados no final da unidade no espaço não utilizado. Uma segunda unidade pode agora ser inserida no espelhamento:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># graid insert raid/r0 ada1</span></code></pre></div></div><div class=paragraph><p>Os dados da unidade original começarão imediatamente a ser copiados para a segunda unidade. O espelhamento operará em status degradado até que a cópia seja concluída.</p></div></div><div class=sect2><h3 id=geom-graid-inserting>18.5.4. Inserindo Novos Discos no Array<a class=anchor href=#geom-graid-inserting></a></h3><div class=paragraph><p>As unidades podem ser inseridas em uma matriz como substitutos de unidades que falharam ou estão faltando. Se não houver unidades com falha ou ausentes, a nova unidade se tornará uma reserva. Por exemplo, inserir uma nova unidade em um espelhamento de duas unidades de trabalho resulta em um espelhamento de duas unidades com uma unidade sobressalente, não em um espelhamento de três unidades.</p></div><div class=paragraph><p>No array de espelho do exemplo, os dados começam a ser copiados imediatamente para a unidade recém-inserida. Qualquer informação existente na nova unidade será substituída.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># graid insert raid/r0 ada1</span>
GEOM_RAID: Intel-a29ea104: Disk ada1 state changed from NONE to ACTIVE.
GEOM_RAID: Intel-a29ea104: Subdisk gm0:1-ada1 state changed from NONE to NEW.
GEOM_RAID: Intel-a29ea104: Subdisk gm0:1-ada1 state changed from NEW to REBUILD.
GEOM_RAID: Intel-a29ea104: Subdisk gm0:1-ada1 rebuild start at 0.</code></pre></div></div></div><div class=sect2><h3 id=geom-graid-removing>18.5.5. Removendo Discos do Array<a class=anchor href=#geom-graid-removing></a></h3><div class=paragraph><p>Discos individuais podem ser permanentemente removidos de um array e seus metadados apagados:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># graid remove raid/r0 ada1</span>
GEOM_RAID: Intel-a29ea104: Disk ada1 state changed from ACTIVE to OFFLINE.
GEOM_RAID: Intel-a29ea104: Subdisk gm0:1-[unknown] state changed from ACTIVE to NONE.
GEOM_RAID: Intel-a29ea104: Volume gm0 state changed from OPTIMAL to DEGRADED.</code></pre></div></div></div><div class=sect2><h3 id=geom-graid-stopping>18.5.6. Parando o Array<a class=anchor href=#geom-graid-stopping></a></h3><div class=paragraph><p>Um array pode ser interrompido sem remover os metadados das unidades. O array será reiniciado quando o sistema for inicializado.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># graid stop raid/r0</span></code></pre></div></div></div><div class=sect2><h3 id=geom-graid-status>18.5.7. Verificando o Status do Array<a class=anchor href=#geom-graid-status></a></h3><div class=paragraph><p>O status do array pode ser verificado a qualquer momento. Depois que um disco foi adicionado ao espelho no exemplo acima, os dados estarão sendo copiados do disco original para o novo disco:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># graid status</span>
   Name    Status  Components
raid/r0  DEGRADED  ada0 <span class=o>(</span>ACTIVE <span class=o>(</span>ACTIVE<span class=o>))</span>
                   ada1 <span class=o>(</span>ACTIVE <span class=o>(</span>REBUILD 28%<span class=o>))</span></code></pre></div></div><div class=paragraph><p>Alguns tipos de arrays, como <code>RAID0</code> ou <code>CONCAT</code>, podem não ser mostrados no relatório de status se os discos falharem. Para ver esses arrays com falhas parciais, adicione <code>-ga</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># graid status -ga</span>
          Name  Status  Components
Intel-e2d07d9a  BROKEN  ada6 <span class=o>(</span>ACTIVE <span class=o>(</span>ACTIVE<span class=o>))</span></code></pre></div></div></div><div class=sect2><h3 id=geom-graid-deleting>18.5.8. Excluindo Arrays<a class=anchor href=#geom-graid-deleting></a></h3><div class=paragraph><p>Arrays são destruídos, excluindo todos os volumes deles. Quando o último volume presente é excluído, o array é interrompido e os metadados são removidos dos discos:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># graid delete raid/r0</span></code></pre></div></div></div><div class=sect2><h3 id=geom-graid-unexpected>18.5.9. Excluindo Arrays Inesperados<a class=anchor href=#geom-graid-unexpected></a></h3><div class=paragraph><p>Os discos podem conter metadados <a href="https://man.freebsd.org/cgi/man.cgi?query=graid&amp;sektion=8&amp;format=html">graid(8)</a> inesperados, originados no seu uso anterior ou em testes do fabricante. O <a href="https://man.freebsd.org/cgi/man.cgi?query=graid&amp;sektion=8&amp;format=html">graid(8)</a> detectará estes discos e criará um array, interferindo no acesso ao disco individual. Para remover os metadados indesejados:</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Inicialize o sistema. No menu de inicialização, selecione <code>2</code> para o prompt do utilitário de boot. Entre:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>OK <span class=nb>set </span>kern.geom.raid.enable<span class=o>=</span>0
OK boot</code></pre></div></div><div class=paragraph><p>O sistema inicializará com o <a href="https://man.freebsd.org/cgi/man.cgi?query=graid&amp;sektion=8&amp;format=html">graid(8)</a> desativado.</p></div></li><li><p>Fazer backup de todos os dados na unidade afetada.</p></li><li><p>Como solução alternativa, a detecção de arrays <a href="https://man.freebsd.org/cgi/man.cgi?query=graid&amp;sektion=8&amp;format=html">graid(8)</a> pode ser desativada incluindo se a variável</p><div class="literalblock programlisting"><div class=content><pre>kern.geom.raid.enable=0</pre></div></div><div class=paragraph><p>no arquivo <span class=filename>/boot/loader.conf</span>.</p></div><div class=paragraph><p>Para remover permanentemente os metadados <a href="https://man.freebsd.org/cgi/man.cgi?query=graid&amp;sektion=8&amp;format=html">graid(8)</a> do disco afetado, inicialize uma instalação do FreeBSD usando um CD-ROM ou um memory stick e selecione a opção <code>Shell</code>. Use o comando <code>status</code> para encontrar o nome do array, normalmente <code>raid/r0</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># graid status</span>
   Name   Status  Components
raid/r0  OPTIMAL  ada0 <span class=o>(</span>ACTIVE <span class=o>(</span>ACTIVE<span class=o>))</span>
                  ada1 <span class=o>(</span>ACTIVE <span class=o>(</span>ACTIVE<span class=o>))</span></code></pre></div></div><div class=paragraph><p>Exclua o volume pelo nome:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># graid delete raid/r0</span></code></pre></div></div><div class=paragraph><p>Se houver mais de um volume exibido, repita o processo para cada volume. Após o último array ter sido excluído, o volume será destruído.</p></div><div class=paragraph><p>Reinicialize e verifique os dados, restaurando a partir do backup, se necessário. Depois que os metadados forem removidos, a entrada <code>kern.geom.raid.enable=0</code> no arquivo <span class=filename>/boot/loader.conf</span> também pode ser removida.</p></div></li></ol></div></div></div></div></div></div><div class=sect1><h2 id=geom-ggate>18.6. GEOM Network Gate<a class=anchor href=#geom-ggate></a></h2><div class=sectionbody><div class=paragraph><p>O GEOM fornece um mecanismo simples para fornecer acesso remoto a dispositivos como discos, CDs e sistemas de arquivos através do uso do daemon GEOM Network Gate, ggated. O sistema com o dispositivo executa o daemon do servidor que manipula solicitações feitas por clientes usando o ggatec. Os dispositivos não devem conter dados confidenciais, pois a conexão entre o cliente e o servidor não é criptografada.</p></div><div class=paragraph><p>Semelhante ao NFS, que é discutido em <a href=../network-servers/#network-nfs>Network File System (NFS)</a>, o ggated é configurado usando um arquivo de exportação. Este arquivo especifica quais sistemas têm permissão para acessar os recursos exportados e em qual nível de acesso eles são oferecidos. Por exemplo, para fornecer ao cliente <code>192.168.1.5</code> acesso de leitura e gravação à quarta slice do primeiro disco SCSI, crie o arquivo <span class=filename>/etc/gg.exports</span> com esta linha:</p></div><div class="literalblock programlisting"><div class=content><pre>192.168.1.5 RW /dev/da0s4d</pre></div></div><div class=paragraph><p>Antes de exportar o dispositivo, verifique se ele não está montado no momento. Em seguida, inicie o ggated:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ggated</span></code></pre></div></div><div class=paragraph><p>Várias opções estão disponíveis para especificar uma porta de escuta alternativa ou para alterar o local padrão do arquivo de exportação. Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=ggated&amp;sektion=8&amp;format=html">ggated(8)</a> para maiores detalhes.</p></div><div class=paragraph><p>Para acessar o dispositivo exportado na máquina cliente, primeiro use o comando <code>ggatec</code> para especificar o endereço IP do servidor e o nome do dispositivo exportado. Se bem sucedido, este comando irá exibir um nome de dispositivo <code>ggate</code> para montar. Monte esse nome de dispositivo especificado em um ponto de montagem livre. Este exemplo conecta-se à partição <span class=filename>/dev/da0s4d</span> no <code>192.168.1.1</code>, em seguida, monta o <span class=filename>/dev/ggate0</span> em <span class=filename>/mnt</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ggatec create -o rw 192.168.1.1 /dev/da0s4d</span>
ggate0
<span class=c># mount /dev/ggate0 /mnt</span></code></pre></div></div><div class=paragraph><p>O dispositivo no servidor pode agora ser acessado por meio do <span class=filename>/mnt</span> no cliente. Para maiores detalhes sobre o <code>ggatec</code> e alguns exemplos de uso, consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=ggatec&amp;sektion=8&amp;format=html">ggatec(8)</a>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>A montagem falhará se o dispositivo estiver atualmente montado no servidor ou em qualquer outro cliente na rede. Se for necessário acesso simultâneo aos recursos de rede, use o NFS.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Quando o dispositivo não for mais necessário, desmonte-o com o <code>umount</code> para que o recurso fique disponível para outros clientes.</p></div></div></div><div class=sect1><h2 id=geom-glabel>18.7. Rotulando Dispositivos de Disco<a class=anchor href=#geom-glabel></a></h2><div class=sectionbody><div class=paragraph><p>Durante a inicialização do sistema, o kernel do FreeBSD cria nós de dispositivos conforme os dispositivos são encontrados. Esse método de detectar dispositivos gera alguns problemas. Por exemplo, e se um novo dispositivo de disco for adicionado via USB? É provável que um dispositivo flash receba o nome do dispositivo <span class=filename>da0</span> e o <span class=filename>da0</span> original alterado para <span class=filename>da1</span>. Isso causará problemas ao montar sistemas de arquivos se eles estiverem listados no <span class=filename>/etc/fstab</span>, o que também pode impedir que o sistema seja inicializado.</p></div><div class=paragraph><p>Uma solução é encadear os dispositivos SCSI para que um novo dispositivo adicionado à placa SCSI receba números de dispositivo não utilizados. Mas e os dispositivos USB que podem substituir o disco principal SCSI? Isso acontece porque os dispositivos USB geralmente são examinados antes da placa SCSI. Uma solução é inserir esses dispositivos apenas após o sistema ter sido inicializado. Outro método é usar apenas uma única unidade ATA e nunca listar os dispositivos SCSI no arquivo <span class=filename>/etc/fstab</span>.</p></div><div class=paragraph><p>Uma solução melhor é usar o <code>glabel</code> para rotular os dispositivos de disco e usar os rótulos no arquivo <span class=filename>/etc/fstab</span>. Como o <code>glabel</code> armazena o rótulo no último setor de um determinado provedor, o rótulo permanecerá persistente nas reinicializações. Ao usar esse rótulo como um dispositivo, o sistema de arquivos pode sempre ser montado independentemente do nó do dispositivo pelo qual ele é acessado.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>O <code>glabel</code> pode criar rótulos transitórios e permanentes. Somente rótulos permanentes são consistentes nas reinicializações. Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=glabel&amp;sektion=8&amp;format=html">glabel(8)</a> para obter mais informações sobre as diferenças entre os rótulos.</p></div></td></tr></tbody></table></div><div class=sect2><h3 id=_tipos_de_rótulos_e_exemplos>18.7.1. Tipos de Rótulos e Exemplos<a class=anchor href=#_tipos_de_rótulos_e_exemplos></a></h3><div class=paragraph><p>Os rótulos permanentes podem ser um rótulo genérico ou de um sistema de arquivos. Rótulos de sistema de arquivos permanentes podem ser criados com <a href="https://man.freebsd.org/cgi/man.cgi?query=tunefs&amp;sektion=8&amp;format=html">tunefs(8)</a> ou <a href="https://man.freebsd.org/cgi/man.cgi?query=newfs&amp;sektion=8&amp;format=html">newfs(8)</a>. Esses tipos de rótulos são criados em um subdiretório <span class=filename>/dev</span> e serão nomeados de acordo com o tipo de sistema de arquivos. Por exemplo, os rótulos do sistema de arquivos UFS2 serão criados em <span class=filename>/dev/ufs</span>. Rótulos permanentes genéricos podem ser criados com o <code>glabel label</code>. Estes não são específicos do sistema de arquivos e serão criados em <span class=filename>/dev/label</span>.</p></div><div class=paragraph><p>Os rótulos temporários são destruídos na próxima reinicialização. Esses rótulos são criados em <span class=filename>/dev/label</span> e são adequados para experimentação. Um rótulo temporário pode ser criado usando <code>glabel create</code>.</p></div><div class=paragraph><p>Para criar um rótulo permanente para um sistema de arquivos UFS2 sem destruir nenhum dado, emita o seguinte comando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># tunefs -L home /dev/da3</span></code></pre></div></div><div class=paragraph><p>Um rótulo deve agora existir em <span class=filename>/dev/ufs</span> que pode ser adicionado ao arquivo <span class=filename>/etc/fstab</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>/dev/ufs/home		/home            ufs     rw              2      2</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>O sistema de arquivos não deve ser montado durante a tentativa de executar o <code>tunefs</code>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Agora o sistema de arquivos pode ser montado:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount /home</span></code></pre></div></div><div class=paragraph><p>A partir deste ponto, desde que o módulo do kernel <span class=filename>geom_label.ko</span> seja carregado na inicialização com o <span class=filename>/boot/loader.conf</span> ou com a opção do kernel <code>GEOM_LABEL</code> estando presente, o nó do dispositivo pode mudar sem qualquer efeito negativo no sistema.</p></div><div class=paragraph><p>Os sistemas de arquivos também podem ser criados com um rótulo padrão usando a flag <code>-L</code> com o comando <code>newfs</code>. Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=newfs&amp;sektion=8&amp;format=html">newfs(8)</a> para obter maiores informações.</p></div><div class=paragraph><p>O seguinte comando pode ser usado para destruir o rótulo:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># glabel destroy home</span></code></pre></div></div><div class=paragraph><p>O exemplo a seguir mostra como rotular as partições de um disco de inicialização.</p></div><div class=exampleblock><div class=title>Exemplo 1. Rotulando Partições no Disco de Inicialização</div><div class=content><div class=paragraph><p>Ao marcar permanentemente as partições no disco de inicialização, o sistema deve poder continuar a inicializar normalmente, mesmo se o disco for movido para outro controlador ou transferido para um sistema diferente. Para este exemplo, presume-se que um único disco ATA é usado, que é atualmente reconhecido pelo sistema como <span class=filename>ad0</span>. Também é assumido que o esquema de partição padrão do FreeBSD é usado, com <span class=filename>/</span>, <span class=filename>/var</span>, <span class=filename>/usr</span> e <span class=filename>/tmp</span>, bem como uma partição de swap.</p></div><div class=paragraph><p>Reinicialize o sistema e, no prompt do <a href="https://man.freebsd.org/cgi/man.cgi?query=loader&amp;sektion=8&amp;format=html">loader(8)</a>, pressione <kbd>4</kbd> para inicializar no modo de usuário único. Em seguida, insira os seguintes comandos:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># glabel label rootfs /dev/ad0s1a</span>
GEOM_LABEL: Label <span class=k>for </span>provider /dev/ad0s1a is label/rootfs
<span class=c># glabel label var /dev/ad0s1d</span>
GEOM_LABEL: Label <span class=k>for </span>provider /dev/ad0s1d is label/var
<span class=c># glabel label usr /dev/ad0s1f</span>
GEOM_LABEL: Label <span class=k>for </span>provider /dev/ad0s1f is label/usr
<span class=c># glabel label tmp /dev/ad0s1e</span>
GEOM_LABEL: Label <span class=k>for </span>provider /dev/ad0s1e is label/tmp
<span class=c># glabel label swap /dev/ad0s1b</span>
GEOM_LABEL: Label <span class=k>for </span>provider /dev/ad0s1b is label/swap
<span class=c># exit</span></code></pre></div></div><div class=paragraph><p>O sistema continuará com a inicialização multiusuário. Depois que a inicialização terminar, edite o arquivo <span class=filename>/etc/fstab</span> e substitua os nomes de dispositivos convencionais por seus respectivos rótulos. No final o <span class=filename>/etc/fstab</span> ficará assim:</p></div><div class="literalblock programlisting"><div class=content><pre># Device                Mountpoint      FStype  Options         Dump    Pass#
/dev/label/swap         none            swap    sw              0       0
/dev/label/rootfs       /               ufs     rw              1       1
/dev/label/tmp          /tmp            ufs     rw              2       2
/dev/label/usr          /usr            ufs     rw              2       2
/dev/label/var          /var            ufs     rw              2       2</pre></div></div><div class=paragraph><p>O sistema agora pode ser reinicializado. Se tudo correr bem, ele aparecerá normalmente e o comando <code>mount</code> mostrará:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount</span>
/dev/label/rootfs on / <span class=o>(</span>ufs, <span class=nb>local</span><span class=o>)</span>
devfs on /dev <span class=o>(</span>devfs, <span class=nb>local</span><span class=o>)</span>
/dev/label/tmp on /tmp <span class=o>(</span>ufs, <span class=nb>local</span>, soft-updates<span class=o>)</span>
/dev/label/usr on /usr <span class=o>(</span>ufs, <span class=nb>local</span>, soft-updates<span class=o>)</span>
/dev/label/var on /var <span class=o>(</span>ufs, <span class=nb>local</span>, soft-updates<span class=o>)</span></code></pre></div></div></div></div><div class=paragraph><p>A classe <a href="https://man.freebsd.org/cgi/man.cgi?query=glabel&amp;sektion=8&amp;format=html">glabel(8)</a> suporta um tipo de rótulo para sistemas de arquivos UFS, com base no ID do sistema de arquivos exclusivo <code>ufsid</code>. Esses rótulos podem ser encontrados em <span class=filename>/dev/ufsid</span> e são criados automaticamente durante a inicialização do sistema. É possível usar rótulos <code>ufsid</code> para montar partições usando o <span class=filename>/etc/fstab</span>. Use o <code>glabel status</code> para receber uma lista de sistemas de arquivos e seus rótulos <code>ufsid</code> correspondentes:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% glabel status
                  Name  Status  Components
ufsid/486b6fc38d330916     N/A  ad4s1d
ufsid/486b6fc16926168e     N/A  ad4s1f</code></pre></div></div><div class=paragraph><p>No exemplo acima, <span class=filename>ad4s1d</span> representa <span class=filename>/var</span>, enquanto <span class=filename>ad4s1f</span> representa <span class=filename>/usr</span>. Usando os valores <code>ufsid</code> mostrados, essas partições podem agora ser montadas com as seguintes entradas em <span class=filename>/etc/fstab</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>/dev/ufsid/486b6fc38d330916        /var        ufs        rw        2      2
/dev/ufsid/486b6fc16926168e        /usr        ufs        rw        2      2</pre></div></div><div class=paragraph><p>Quaisquer partições com rótulos <code>ufsid</code> podem ser montadas dessa forma, eliminando a necessidade de criar manualmente rótulos permanentes, enquanto ainda desfruta dos benefícios da montagem independente do nome do dispositivo.</p></div></div></div></div><div class=sect1><h2 id=geom-gjournal>18.8. Journaling UFS através do GEOM<a class=anchor href=#geom-gjournal></a></h2><div class=sectionbody><div class=paragraph><p>Suporte para journaling em sistemas de arquivos UFS está disponível no FreeBSD. A implementação é fornecida através do subsistema GEOM e é configurada usando o comando <code>gjournal</code>. Ao contrário de outras implementações de journaling de sistemas de arquivos, o método <code>gjournal</code> é baseado em blocos e não é implementado como parte do sistema de arquivos. É uma extensão do GEOM.</p></div><div class=paragraph><p>O jornaling armazena um log de transações do sistema de arquivos, como alterações que compõem uma operação de gravação em disco completa, antes que os metadados e as gravações de arquivos sejam confirmados no disco. Esse log de transação pode ser repetido posteriormente para refazer as transações do sistema de arquivos, evitando inconsistências no sistema de arquivos.</p></div><div class=paragraph><p>Esse método fornece outro mecanismo para proteger contra perda de dados e inconsistências do sistema de arquivos. Ao contrário das Soft Updates, que rastreiam e impõem atualizações de metadados e snapshots, que criam uma imagem do sistema de arquivos, um log é armazenado no espaço em disco especificamente para essa tarefa. Para melhor desempenho, o journal pode ser armazenado em outro disco. Nessa configuração, o provedor do journal ou o dispositivo de armazenamento deve ser listado após o dispositivo para ativar o journaling.</p></div><div class=paragraph><p>O kernel <span class=filename>GENERIC</span> fornece suporte para o <code>gjournal</code>. Para carregar automaticamente o módulo do kernel <span class=filename>geom_journal.ko</span> no momento da inicialização, adicione a seguinte linha ao arquivo <span class=filename>/boot/loader.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>geom_journal_load=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Se um kernel personalizado for usado, certifique-se de que a linha a seguir esteja no arquivo de configuração do kernel:</p></div><div class="literalblock programlisting"><div class=content><pre>options	GEOM_JOURNAL</pre></div></div><div class=paragraph><p>Depois que o módulo é carregado, um journal pode ser criado em um novo sistema de arquivos usando as etapas a seguir. Neste exemplo, <span class=filename>da4</span> é um novo disco SCSI:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gjournal load</span>
<span class=c># gjournal label /dev/da4</span></code></pre></div></div><div class=paragraph><p>Isto irá carregar o módulo e criar um nó de dispositivo <span class=filename>/dev/da4.journal</span> em <span class=filename>/dev/da4</span>.</p></div><div class=paragraph><p>Um sistema de arquivos UFS pode agora ser criado no dispositivo journaled e depois montado em um ponto de montagem existente:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># newfs -O 2 -J /dev/da4.journal</span>
<span class=c># mount /dev/da4.journal /mnt</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>No caso de várias slices, será criado um journal para cada slice individual. Por exemplo, se <span class=filename>ad4s1</span> e <span class=filename>ad4s2</span> forem slices, o <code>gjournal</code> criará <span class=filename>ad4s1.journal</span> e <span class=filename>ad4s2.journal</span>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>O journaling também pode ser ativado nos sistemas de arquivos atuais usando o <code>tunefs</code>. No entanto, <em>sempre</em> faça um backup antes de tentar alterar um sistema de arquivos existente. Na maioria dos casos, o <code>gjournal</code> falhará se não for possível criar o registro de log, mas isso não protege contra a perda de dados incorrida como resultado do uso indevido do <code>tunefs</code>. Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=gjournal&amp;sektion=8&amp;format=html">gjournal(8)</a> e <a href="https://man.freebsd.org/cgi/man.cgi?query=tunefs&amp;sektion=8&amp;format=html">tunefs(8)</a> para maiores informações sobre esses comandos.</p></div><div class=paragraph><p>É possível fazer o journaling do disco de inicialização de um sistema FreeBSD. Consulte o artigo <a href=https://docs.freebsd.org/pt-br/articles/gjournal-desktop/>Implementando o journaling do UFS em um PC de mesa</a> para obter instruções detalhadas.</p></div></div></div></div><hr><div class=last-modified><p><strong>Última alteração em</strong>: 9 de março de 2024 por <a href="https://cgit.freebsd.org/doc/commit/?id=6199af92e7" target=_blank>Danilo G. Baio</a></p></div><div class=buttons><div class=prev><i class="fa fa-angle-left" aria-hidden=true title=Anterior></i><div class=container><a href=http://172.16.201.134:1313/pt-br/books/handbook/disks class=direction>Anterior</a></div></div><div class=home><i class="fa fa-home" aria-hidden=true title=Início></i><div class=container><a href=../ class=direction>Início</a></div></div><div class=next><div class=container><a href=http://172.16.201.134:1313/pt-br/books/handbook/zfs class=direction>Próximo</a></div><i class="fa fa-angle-right" aria-hidden=true title=Próximo></i></div></div><label class="hidden book-menu-overlay" for=menu-control></label></div><aside class=toc><div class=toc-content><h3>Índice</h3><nav id=TableOfContents><ul><li><a href=#geom-synopsis>18.1. Sinopse</a></li><li><a href=#geom-striping>18.2. RAID0 - Striping</a></li><li><a href=#geom-mirror>18.3. RAID1 - Espelhamento</a></li><li><a href=#geom-raid3>18.4. RAID3 - Distribuição em Nível de Byte com Paridade Dedicada</a></li><li><a href=#geom-graid>18.5. Dispositivos RAID por Software</a></li><li><a href=#geom-ggate>18.6. GEOM Network Gate</a></li><li><a href=#geom-glabel>18.7. Rotulando Dispositivos de Disco</a></li><li><a href=#geom-gjournal>18.8. Journaling UFS através do GEOM</a></li></ul></nav><hr><div class=resources><h3>Recursos</h3><ul class=contents><li><i class="fa fa-file-pdf-o" aria-hidden=true title="Download PDF"></i><a href=https://download.freebsd.org/doc/pt-br/books/handbook/handbook_pt-br.pdf>Download PDF</a></li><li><i class="fa fa-pencil-square-o" aria-hidden=true title="Edite essa página"></i><a href=https://github.com/freebsd/freebsd-doc/blob/main/documentation/content/pt-br/_index target=_blank>Edite essa página</a></li></ul></div></div></aside><a class=to-top href=#top><i class="fa fa-arrow-circle-up" aria-hidden=true></i></a></main><footer><div class=footer-container><section class=logo-column><img src=http://172.16.201.134:1313/images/FreeBSD-colors.svg width=160 height=50 alt="FreeBSD logo"><div class=options-container><div class=language-container><a id=languages href=http://172.16.201.134:1313/pt-br/languages><img src=http://172.16.201.134:1313/images/language.png class=language-image alt="Escolha o idioma">
<span>Brazilian Portuguese</span></a></div><div class=theme-container><select id=theme-chooser><option value=theme-system>System</option><option value=theme-light>Light</option><option value=theme-dark>Dark</option><option value=theme-high-contrast>Alto contraste</option></select></div></div></section><section class=about-column><h3 class=column-title>About</h3><ul class=column-elements-container><li><a href=https://www.freebsd.org/about/ target=_blank class=column-element>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/ target=_blank class=column-element>FreeBSD Foundation</a></li><li><a href=https://www.freebsd.org/where/ target=_blank class=column-element>Get FreeBSD</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct target=_blank class=column-element>Code of Conduct</a></li><li><a href=https://www.freebsd.org/security/ target=_blank class=column-element>Security Advisories</a></li></ul></section><section class=documentation-column><h3 class=column-title>Documentation</h3><ul class=column-elements-container><li><a href=/pt-br class=column-element>Documentation portal</a></li><li><a href=https://man.FreeBSD.org target=_blank class=column-element>Manual pages</a></li><li><a href=https://papers.FreeBSD.org target=_blank class=column-element>Presentations and papers</a></li><li><a href=https://docs-archive.freebsd.org/doc/ target=_blank class=column-element>Previous versions</a></li><li><a href=https://docs-archive.freebsd.org/44doc/ target=_blank class=column-element>4.4BSD Documents</a></li><li><a href=https://wiki.freebsd.org/ target=_blank class=column-element>Wiki</a></li></ul></section><section class=community-column><h3 class=column-title>Community</h3><ul class=column-elements-container><li><a href=http://172.16.201.134:1313/pt-br/articles/contributing class=column-element>Get involved</a></li><li><a href=https://forums.freebsd.org/ target=_blank class=column-element>Community forum</a></li><li><a href=https://lists.freebsd.org/ target=_blank class=column-element>Mailing lists</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank class=column-element>IRC Channels</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank class=column-element>Bug Tracker</a></li></ul></section><section class=legal-column><h3 class=column-title>Legal</h3><ul class=column-elements-container><li><a href=https://freebsdfoundation.org/donate/ target=_blank class=column-element>Donations</a></li><li><a href=https://www.freebsd.org/copyright/freebsd-license/ target=_blank class=column-element>Licensing</a></li><li><a href=https://www.freebsd.org/privacy/ target=_blank class=column-element>Privacy Policy</a></li><li><a href=https://www.freebsd.org/copyright/ target=_blank class=column-element>Legal notices</a></li></ul></section><section class=copyright-column><p>&copy; 1994-2024 The FreeBSD Project. All rights reserved</p><span>Made with <span class=heart>♥</span> by the FreeBSD Community</span></section></div></footer></body></html>