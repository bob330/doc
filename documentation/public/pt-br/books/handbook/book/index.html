<!doctype html><html class=theme-light lang=pt-br><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content><meta name=keywords content><meta name=copyright content="1995-2024 The FreeBSD Foundation"><link rel=canonical href=https://docs.freebsd.org/pt-br/books/handbook/book/><title>FreeBSD Handbook | FreeBSD Documentation Portal</title>
<meta name=theme-color content="#790000"><meta name=color-scheme content="system light dark high-contrast"><link rel="shortcut icon" href=https://docs.freebsd.org/favicon.ico><link rel=stylesheet href=https://docs.freebsd.org/styles/main.min.css><link rel=stylesheet href=https://docs.freebsd.org/css/font-awesome-min.css><script defer src=/js/theme-chooser.min.js></script><script defer src=/js/copy-clipboard.min.js></script><script defer src=/js/search.min.js></script><meta name=twitter:card content="summary"><meta name=twitter:domain content="docs.FreeBSD.org"><meta name=twitter:site content="@freebsd"><meta name=twitter:url content="https://twitter.com/freebsd"><meta property="og:title" content="FreeBSD Handbook"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:image" content="https://docs.freebsd.org/favicon.ico"><meta property="og:image:alt" content="FreeBSD Logo"><meta property="og:locale" content="pt-br"><meta property="og:url" content="https://docs.freebsd.org/pt-br/books/handbook/book/"><meta property="og:site_name" content="FreeBSD Documentation Portal"><script type=application/ld+json>{"@context":"http://schema.org","@type":"Article","url":"https:\/\/docs.freebsd.org\/pt-br\/books\/handbook\/book\/","name":"FreeBSD Documentation Portal","headline":"FreeBSD Documentation Portal","description":"FreeBSD Documentation Portal"}</script></head><body><header><div class=header-container><div class=logo-menu-bars-container><a href=https://www.FreeBSD.org class=logo><img src=https://docs.freebsd.org/images/FreeBSD-monochromatic.svg width=160 height=50 alt="FreeBSD logo">
</a><label class=menu-bars for=menu-bars><i class="fa fa-bars" aria-hidden=true></i></label></div><input id=menu-bars type=checkbox><nav><ul class=menu><li class=menu-item><input id=about type=checkbox>
<a href=# aria-label="Navigate to About section"><label class=menu-item-description for=about>About
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/about/ target=_blank>About</a></li><li><a href=https://www.freebsd.org/about/ target=_blank>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/about-us/about-the-foundation/ target=_blank>FreeBSD Foundation</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct/ target=_blank>Code of Conduct</a></li></ul></li><li class=menu-item><input id=download type=checkbox>
<a href=# aria-label="Navigate to get FreeBSD section"><label class=menu-item-description for=download>Get FreeBSD
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/where/ target=_blank>Get FreeBSD</a></li><li><a href=https://www.freebsd.org/releases/ target=_blank>Release Information</a></li><li><a href=https://www.freebsd.org/releng/ target=_blank>Release Engineering</a></li><li><a href=https://www.freebsd.org/security/ target=_blank>Security Advisories</a></li></ul></li><li class=menu-item><input id=documentation type=checkbox>
<a href=# aria-label="Navigate to get Documentation section"><label class=menu-item-description for=documentation>Documentation
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=/pt-br>Documentation portal</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook>FreeBSD Handbook</a></li><li><a href=https://docs.freebsd.org/pt-br/books/porters-handbook>Porter's Handbook</a></li><li><a href=https://docs.FreeBSD.org/en/books/fdp-primer>Documentation Project Handbook</a></li><li><a href=https://man.FreeBSD.org target=_blank>Manual pages</a></li><li><a href=https://papers.FreeBSD.org target=_blank>Presentations and papers</a></li><li><a href=https://wiki.FreeBSD.org target=_blank>Wiki</a></li><li><a href=https://docs.freebsd.org/pt-br/books>Books</a></li><li><a href=https://docs.freebsd.org/pt-br/articles>Articles</a></li></ul></li><li class=menu-item><input id=community type=checkbox>
<a href=# aria-label="Navigate to get Community section"><label class=menu-item-description for=community>Community
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/community/>Community</a></li><li><a href=https://docs.freebsd.org/pt-br/articles/contributing>Get involved</a></li><li><a href=https://forums.freebsd.org/ target=_blank>Forum</a></li><li><a href=https://lists.freebsd.org/ target=_blank>Mailing lists</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank>IRC Channels</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank>Bug Tracker</a></li><li><a href=https://www.freebsd.org/support/ target=_blank>Support</a></li></ul></li></ul></nav><div class=search-donate-container><form class=search method=get id=search-header-form action=https://docs.freebsd.org/search name=search-header-form><input type=hidden name=DB value=pt-br>
<input id=words name=P type=text size=20 maxlength=255>
<button>
<i class="fa fa-search" aria-hidden=true></i></button></form><div class=donate><a href=https://freebsdfoundation.org/donate/ target=_blank><span class=heart>♥</span>
Donate</a></div></div></div></header><input type=checkbox class="hidden toggle" id=menu-control><main class=main-wrapper-book><a id=top></a><div class=book><h1 class=title>FreeBSD Handbook</h1><div class="admonitionblock note"><p><i class="fa fa-exclamation-circle" aria-hidden=true></i>
Esta tradução pode estar desatualizada. Para ajudar com as traduções, acesse a <a href=https://translate-dev.freebsd.org/ target=_blank>ferramenta de traduções do FreeBSD</a>.</p></div><div class=copyright>Copyright © 1995-2020 The FreeBSD Documentation Project</div><div class=legalnotice><a id=trademarks></a><details><summary>trademarks</summary><p>FreeBSD is a registered trademark of the FreeBSD Foundation.</p><p>IBM, AIX, OS/2, PowerPC, PS/2, S/390, and ThinkPad are trademarks of International Business Machines Corporation in the United States, other countries, or both.</p><p>IEEE, POSIX, and 802 are registered trademarks of Institute of Electrical and Electronics Engineers, Inc. in the United States.</p><p>Red Hat, RPM, are trademarks or registered trademarks of Red Hat, Inc. in the United States and other countries.</p><p>3Com and HomeConnect are registered trademarks of 3Com Corporation.</p><p>Adobe, Acrobat, Acrobat Reader, Flash and PostScript are either registered trademarks or trademarks of Adobe Systems Incorporated in the United States and/or other countries.</p><p>Apple, AirPort, FireWire, iMac, iPhone, iPad, Mac, Macintosh, Mac OS, Quicktime, and TrueType are trademarks of Apple Inc., registered in the U.S. and other countries.</p><p>Intel, Celeron, Centrino, Core, EtherExpress, i386, i486, Itanium, Pentium, and Xeon are trademarks or registered trademarks of Intel Corporation or its subsidiaries in the United States and other countries.</p><p>Linux is a registered trademark of Linus Torvalds.</p><p>Microsoft, IntelliMouse, MS-DOS, Outlook, Windows, Windows Media and Windows NT are either registered trademarks or trademarks of Microsoft Corporation in the United States and/or other countries.</p><p>Motif, OSF/1, and UNIX are registered trademarks and IT DialTone and The Open Group are trademarks of The Open Group in the United States and other countries.</p><p>Sun, Sun Microsystems, Java, Java Virtual Machine, JDK, JRE, JSP, JVM, Netra, OpenJDK, Solaris, StarOffice, SunOS and VirtualBox are trademarks or registered trademarks of Sun Microsystems, Inc. in the United States and other countries.</p><p>RealNetworks, RealPlayer, and RealAudio are the registered trademarks of RealNetworks, Inc.</p><p>Oracle is a registered trademark of Oracle Corporation.</p><p>3ware is a registered trademark of 3ware Inc.</p><p>ARM is a registered trademark of ARM Limited.</p><p>Adaptec is a registered trademark of Adaptec, Inc.</p><p>Android is a trademark of Google Inc.</p><p>Heidelberg, Helvetica, Palatino, and Times Roman are either registered trademarks or trademarks of Heidelberger Druckmaschinen AG in the U.S. and other countries.</p><p>Intuit and Quicken are registered trademarks and/or registered service marks of Intuit Inc., or one of its subsidiaries, in the United States and other countries.</p><p>LSI Logic, AcceleRAID, eXtremeRAID, MegaRAID and Mylex are trademarks or registered trademarks of LSI Logic Corp.</p><p>MATLAB is a registered trademark of The MathWorks, Inc.</p><p>SpeedTouch is a trademark of Thomson.</p><p>VMware is a trademark of VMware, Inc.</p><p>Mathematica is a registered trademark of Wolfram Research, Inc.</p><p>Ogg Vorbis and Xiph.Org are trademarks of Xiph.Org.</p><p>XFree86 is a trademark of The XFree86 Project, Inc.</p><p>Many of the designations used by manufacturers and sellers to distinguish their products are claimed as trademarks. Where those designations appear in this document, and the FreeBSD Project was aware of the trademark claim, the designations have been followed by the “™” or the “®” symbol.</p></details></div><div class=toc-mobile><h3>Índice</h3><nav id=TableOfContents><ul><li><a href=#book-preface>Prefácio</a><ul><li><a href=#preface-audience>Audiência Pretendida</a></li><li><a href=#preface-changes-from3>Mudanças desde a Terceira Edição</a></li><li><a href=#preface-changes-from2>Mudanças desde a Segunda Edição (2004)</a></li><li><a href=#preface-changes>Mudanças desde a Primeira Edição (2001)</a></li><li><a href=#preface-overview>Organização deste Livro</a></li><li><a href=#preface-conv>Convenções utilizadas neste livro</a></li><li><a href=#preface-acknowledgements>Agradecimentos</a></li></ul></li><li><a href=#getting-started>Parte I: Primeiros Passos</a><ul><li><a href=#introduction>Capítulo 1. Introdução</a></li><li><a href=#bsdinstall>Capítulo 2. Instalando o FreeBSD</a></li><li><a href=#basics>Capítulo 3. Fundamentos do FreeBSD</a></li><li><a href=#ports>Capítulo 4. Instalando Aplicativos: Pacotes e Ports</a></li><li><a href=#x11>Capítulo 5. O sistema X Window</a></li></ul></li><li><a href=#common-tasks>Parte II: Tarefas comuns</a><ul><li><a href=#desktop>Capítulo 6. Aplicações de Desktop</a></li><li><a href=#multimedia>Capítulo 7. Multimídia</a></li><li><a href=#kernelconfig>Capítulo 8. Configurando o kernel do FreeBSD</a></li><li><a href=#printing>Capítulo 9. Impressão</a></li><li><a href=#linuxemu>Capítulo 10. Compatibilidade binária com o Linux®</a></li></ul></li><li><a href=#system-administration>Parte III: Administração do Sistema</a><ul><li><a href=#config-tuning>Capítulo 11. Configuração e Ajuste</a></li><li><a href=#boot>Capítulo 12. O processo de inicialização do FreeBSD</a></li><li><a href=#security>Capítulo 13. Segurança</a></li><li><a href=#jails>Capítulo 14. Jails</a></li><li><a href=#mac>Capítulo 15. Controle de acesso obrigatório</a></li><li><a href=#audit>Capítulo 16. Auditoria de Evento de Segurança</a></li><li><a href=#disks>Capítulo 17. Armazenamento</a></li><li><a href=#geom>Capítulo 18. GEOM: Framework de Transformação de Disco Modular</a></li><li><a href=#zfs>Capítulo 19. O sistema de arquivos Z (ZFS)</a></li><li><a href=#filesystems>Capítulo 20. Outros Sistemas de Arquivos</a></li><li><a href=#virtualization>Capítulo 21. Virtualização</a></li><li><a href=#l10n>Capítulo 22. Localização - Uso e Configuração do i18n/L10n</a></li><li><a href=#updating-upgrading>Capítulo 23. Atualização e Upgrade do FreeBSD</a></li><li><a href=#dtrace>Capítulo 24. DTrace</a></li><li><a href=#usb-device-mode>Capítulo 25. Modo de dispositivo USB/USB OTG</a></li></ul></li><li><a href=#network-communication>Parte IV: Comunicação de rede</a><ul><li><a href=#serialcomms>Capítulo 26. Comunicações Seriais</a></li><li><a href=#ppp-and-slip>Capítulo 27. PPP</a></li><li><a href=#mail>Capítulo 28. Correio Eletrônico</a></li><li><a href=#network-servers>Capítulo 29. Servidores de Rede</a></li><li><a href=#firewalls>Capítulo 30. Firewalls</a></li><li><a href=#advanced-networking>Capítulo 31. Rede Avançada</a></li></ul></li><li><a href=#appendices>Parte V: Apêndices</a><ul><li><a href=#mirrors>Apêndice A: Obtendo o FreeBSD</a></li><li><a href=#bibliography>Apêndice B: Bibliografia</a></li><li><a href=#eresources>Apêndice C: Recursos na Internet</a></li><li><a href=#pgpkeys>Apêndice D: Chaves OpenPGP</a></li></ul></li></ul></nav></div><div class=book-content><div id=preamble><div class=sectionbody><div class="quoteblock abstract abstract-title"><blockquote>Resumo</blockquote></div><div class=paragraph><p>Bem vindo ao FreeBSD! Este manual cobre a instalação e o uso diário do <em>FreeBSD 12.1-RELEASE</em> e do <em>FreeBSD 11.4-RELEASE</em>. Este livro é o resultado do trabalho contínuo de muitas pessoas. Algumas seções podem estar desatualizadas. Os interessados em ajudar a atualizar e expandir este documento devem enviar e-mails para a <a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-doc>lista de discussão do projeto de documentação do FreeBSD</a>.</p></div><div class=paragraph><p>A última versão deste livro está disponível no <a href=https://www.FreeBSD.org/>site do FreeBSD</a>. Versões anteriores podem ser obtidas em <a href=https://docs.FreeBSD.org/doc/>https://docs.FreeBSD.org/doc/</a>. O livro pode ser baixado em uma variedade de formatos e opções de compressão do <a href=https://download.freebsd.org/doc/>servidor FTP do FreeBSD</a> ou de um dos inúmeros <a href=#mirrors-ftp>sites espelho</a>. Cópias impressas podem ser adquiridas da <a href=https://www.freebsdmall.com/>FreeBSD Mall</a>. As pesquisas podem ser realizadas no manual e em outros documentos na <a href=https://www.FreeBSD.org/search/>página de busca</a>.</p></div><hr></div></div><div class=sect1><h2 id=book-preface>Prefácio<a class=anchor href=#book-preface></a></h2><div class=sectionbody><div class=sect2><h3 id=preface-audience>Audiência Pretendida<a class=anchor href=#preface-audience></a></h3><div class=paragraph><p>O novato no FreeBSD descobrirá que a primeira seção deste livro guia o usuário através do processo de instalação do FreeBSD e gentilmente apresenta os conceitos e convenções que sustentam o UNIX™. Trabalhar através desta seção exige pouco mais do que o desejo de explorar, e a capacidade de incorporar novos conceitos à medida que eles são introduzidos.</p></div><div class=paragraph><p>Uma vez que você chegou até aqui, a segunda seção do Handbook, muito maior, é uma referência abrangente a todos os tópicos de interesse para administradores de sistemas FreeBSD. Alguns destes capítulos podem recomendar que você faça alguma leitura prévia, e isto é destacado na sinopse no início de cada capítulo.</p></div><div class=paragraph><p>Para uma lista de fontes adicionais de informação, por favor veja o <a href=./#bibliography>Bibliografia</a>.</p></div></div><div class=sect2><h3 id=preface-changes-from3>Mudanças desde a Terceira Edição<a class=anchor href=#preface-changes-from3></a></h3><div class=paragraph><p>A versão online atual do Handbook representa o esforço cumulativo de muitas centenas de contribuidores nos últimos 10 anos. A seguir estão algumas das mudanças significativas desde a publicação da terceira edição do volume em 2004:</p></div><div class=ulist><ul><li><p><a href=./#dtrace>DTrace</a> foi adicionado com informações sobre a poderosa ferramenta de análise de desempenho DTrace.</p></li><li><p><a href=./#filesystems>Outros Sistemas de Arquivos</a> foi adicionado com informações sobre sistemas de arquivos não-nativos no FreeBSD, como o ZFS da Sun™.</p></li><li><p><a href=./#audit>Auditoria de Evento de Segurança</a> foi adicionado para cobrir os novos recursos de auditoria no FreeBSD e explicar seu uso.</p></li><li><p><a href=./#virtualization>Virtualização</a> foi adicionado com informações sobre a instalação do FreeBSD em ambientes virtualizados.</p></li><li><p><a href=./#bsdinstall>Instalando o FreeBSD</a> foi adicionado para cobrir a instalação do FreeBSD usando o novo utilitário de instalação, bsdinstall.</p></li></ul></div></div><div class=sect2><h3 id=preface-changes-from2>Mudanças desde a Segunda Edição (2004)<a class=anchor href=#preface-changes-from2></a></h3><div class=paragraph><p>A terceira edição foi o culminar de mais de dois anos de trabalho pelos membros dedicados do Projeto de Documentação do FreeBSD. A edição impressa cresceu a tal tamanho que foi necessário publicar como dois volumes separados. A seguir estão as principais mudanças nesta nova edição:</p></div><div class=ulist><ul><li><p><a href=./#config-tuning>Configuração e Ajuste</a> foi expandido com novas informações sobre o gerenciamento de recursos e energia da ACPI, o utilitário de sistema <code>cron</code> e mais opções para ajuste do kernel.</p></li><li><p><a href=./#security>Segurança</a> foi expandido com novas informações sobre redes virtuais privadas (VPNs), listas de controle de acesso (ACLs) do sistema de arquivos e avisos de segurança.</p></li><li><p><a href=./#mac>Controle de acesso obrigatório</a> é um novo capítulo desta edição. Ele explica o que é MAC e como esse mecanismo pode ser usado para proteger um sistema FreeBSD.</p></li><li><p><a href=./#disks>Armazenamento</a> foi expandido com novas informações sobre dispositivos de armazenamento USB, snapshots do sistema de arquivos, cotas do sistema de arquivos, arquivos e sistemas de arquivos com suporte de rede e partições de disco criptografadas.</p></li><li><p>Uma seção de solução de problemas foi adicionada ao <a href=./#ppp-and-slip>PPP</a>.</p></li><li><p><a href=./#mail>Correio Eletrônico</a> foi expandido com novas informações sobre o uso de agentes de transporte alternativos, autenticação SMTP, UUCP, fetchmail, procmail e outros tópicos avançados.</p></li><li><p><a href=./#network-servers>Servidores de Rede</a> é novidade nesta edição. Este capítulo inclui informações sobre a configuração do Servidor HTTP Apache, ftpd e a configuração de um servidor para clientes Microsoft™Windows™ com Samba. Algumas seções do <a href=./#advanced-networking>Rede Avançada</a> foram movidas para cá para melhorar a apresentação.</p></li><li><p><a href=./#advanced-networking>Rede Avançada</a> foi expandido com novas informações sobre o uso de dispositivos Bluetooth™ com o FreeBSD, configuração de redes sem fio e redes ATM (Asynchronous Transfer Mode).</p></li><li><p>Um glossário foi adicionado para fornecer um local central para as definições de termos técnicos utilizados ao longo do livro.</p></li><li><p>Uma série de melhorias estéticas foram feitas nas tabelas e figuras ao longo do livro.</p></li></ul></div></div><div class=sect2><h3 id=preface-changes>Mudanças desde a Primeira Edição (2001)<a class=anchor href=#preface-changes></a></h3><div class=paragraph><p>A segunda edição foi o culminar de mais de dois anos de trabalho pelos membros dedicados do Projeto de Documentação do FreeBSD. A seguir, as principais mudanças nesta edição:</p></div><div class=ulist><ul><li><p>Um índice completo foi adicionado.</p></li><li><p>Todas as figuras ASCII foram substituídas por diagramas gráficos.</p></li><li><p>Uma sinopse padrão foi adicionada a cada capítulo para fornecer um resumo rápido de quais informações o capítulo contém e o que se espera que o leitor saiba.</p></li><li><p>O conteúdo foi logicamente reorganizado em três partes: "Introdução", "Administração do Sistema" e "Apêndices".</p></li><li><p><a href=./#basics>Fundamentos do FreeBSD</a> foi expandido para conter informações adicionais sobre processos, daemons e sinais.</p></li><li><p><a href=./#ports>Instalando Aplicativos. Pacotes e Ports</a> foi expandido para conter informações adicionais sobre o gerenciamento de pacotes binários.</p></li><li><p><a href=./#x11>O sistema X Window</a> foi completamente reescrito com ênfase no uso de tecnologias de desktop modernas como KDE e GNOME sobre o XFree86™ 4.X.</p></li><li><p><a href=./#boot>O processo de inicialização do FreeBSD</a> foi expandido.</p></li><li><p><a href=./#disks>Armazenamento</a> foi escrito a partir do que costumava ser dois capítulos separados em "Discos" e "Backups". Sentimos que os tópicos são mais fáceis de compreender quando apresentados como um único capítulo. Uma seção sobre RAID (hardware e software) também foi adicionada.</p></li><li><p><a href=./#serialcomms>Comunicações Seriais</a> foi completamente reorganizado e atualizado para o FreeBSD 4.X/5.X.</p></li><li><p><a href=./#ppp-and-slip>PPP</a> foi substancialmente atualizado.</p></li><li><p>Muitas novas seções foram adicionadas ao <a href=./#advanced-networking>Rede Avançada</a>.</p></li><li><p><a href=./#mail>Correio Eletrônico</a> foi expandido para incluir mais informações sobre a configuração do sendmail.</p></li><li><p><a href=./#linuxemu>Compatibilidade binária com o Linux®</a> foi expandido para incluir informações sobre como instalar o Oracle™ e o SAP™R/3™.</p></li><li><p>Os novos tópicos a seguir são abordados nesta segunda edição:</p><div class=ulist><ul><li><p><a href=./#config-tuning>Configuração e Ajuste</a>.</p></li><li><p><a href=./#multimedia>Multimídia</a>.</p></li></ul></div></li></ul></div></div><div class=sect2><h3 id=preface-overview>Organização deste Livro<a class=anchor href=#preface-overview></a></h3><div class=paragraph><p>Este livro é dividido em cinco seções logicamente distintas. A primeira seção, <em>Introdução</em>, cobre a instalação e o uso básico do FreeBSD. Espera-se que o leitor siga estes capítulos em sequência, possivelmente ignorando capítulos que abordam tópicos familiares. A segunda seção, <em>Tarefas Comuns</em>, cobre alguns dos recursos mais usados do FreeBSD. Esta seção e todas as seções subsequentes podem ser lidas fora de ordem. Cada capítulo começa com uma sinopse sucinta que descreve o que o capítulo cobre e o que se espera que o leitor já conheça. Isso permite que o leitor casual pule para encontrar capítulos de interesse. A terceira seção, <em>Administração do Sistema</em>, cobre tópicos de administração. A quarta seção, <em>Comunicação de Rede</em>, aborda tópicos sobre redes e servidores. A quinta seção contém apêndices de informações de referência.</p></div><div class=dlist><dl><dt class=hdlist1><em><a href=./#introduction>Introdução</a></em></dt><dd><p>Introduz o FreeBSD para um novo usuário. Descreve a história do projeto FreeBSD, seus objetivos e modelo de desenvolvimento.</p></dd><dt class=hdlist1><em><a href=./#bsdinstall>Instalando o FreeBSD</a></em></dt><dd><p>Guia o usuário durante todo o processo de instalação do FreeBSD 9.<em>x</em> usando o bsdinstall.</p></dd><dt class=hdlist1><em><a href=./#basics>Fundamentos do FreeBSD</a></em></dt><dd><p>Cobre os comandos básicos e a funcionalidade do sistema operacional FreeBSD. Se você está familiarizado com Linux™ ou outro tipo de UNIX™, provavelmente você pode pular este capítulo.</p></dd><dt class=hdlist1><em><a href=./#ports>Instalando Aplicativos. Pacotes e Ports</a></em></dt><dd><p>Cobre a instalação de softwares de terceiros com a inovadora "Coleção de Ports" do FreeBSD, e com pacotes binários tradicionais.</p></dd><dt class=hdlist1><em><a href=./#x11>O sistema X Window</a></em></dt><dd><p>Descreve o Sistema X Window em geral e usa o X11 no FreeBSD em particular. Também descreve ambientes comuns de desktop, como o KDE e GNOME.</p></dd><dt class=hdlist1><em><a href=./#desktop>Aplicações de Desktop</a></em></dt><dd><p>Lista alguns aplicativos comuns de desktop, como navegadores web e pacotes de produtividade, e descreve como instalá-los no FreeBSD.</p></dd><dt class=hdlist1><em><a href=./#multimedia>Multimídia</a></em></dt><dd><p>Mostra como configurar o suporte a reprodução de som e vídeo para o seu sistema. Também descreve alguns exemplos de aplicativos de áudio e vídeo.</p></dd><dt class=hdlist1><em><a href=./#kernelconfig>Configurando o kernel do FreeBSD</a></em></dt><dd><p>Explica o porque que você pode precisar configurar um novo kernel e fornece instruções detalhadas para configurar, compilar e instalar um kernel personalizado.</p></dd><dt class=hdlist1><em><a href=./#printing>Impressão</a></em></dt><dd><p>Descreve o gerenciamento de impressoras no FreeBSD, incluindo informações sobre páginas de banner, contabilidade de impressoras e configuração inicial.</p></dd><dt class=hdlist1><em><a href=./#linuxemu>Compatibilidade binária com o Linux®</a></em></dt><dd><p>Descreve os recursos de compatibilidade Linux™ do FreeBSD. Também fornece instruções detalhadas de instalação para muitos aplicativos Linux™ populares, como o Oracle™ e o Mathematica™.</p></dd><dt class=hdlist1><em><a href=./#config-tuning>Configuração e Ajuste</a></em></dt><dd><p>Descreve os parâmetros disponíveis para os administradores do sistema ajustarem um sistema FreeBSD para um ótimo desempenho. Também descreve os vários arquivos de configuração usados no FreeBSD e onde encontrá-los.</p></dd><dt class=hdlist1><em><a href=./#boot>O processo de inicialização do FreeBSD</a></em></dt><dd><p>Descreve o processo de inicialização do FreeBSD e explica como controlar este processo com opções de configuração.</p></dd><dt class=hdlist1><em><a href=./#security>Segurança</a></em></dt><dd><p>Descreve muitas ferramentas diferentes disponíveis para ajudar a manter seu sistema FreeBSD seguro, incluindo Kerberos, IPsec e OpenSSH.</p></dd><dt class=hdlist1><em><a href=./#jails>Jails</a></em></dt><dd><p>Descreve o framework do jail e as suas vantagens sobre o chroot tradicional do FreeBSD.</p></dd><dt class=hdlist1><em><a href=./#mac>Controle de acesso obrigatório</a></em></dt><dd><p>Explica o que é o Mandatory Access Control (MAC) e como esse mecanismo pode ser usado para proteger um sistema FreeBSD.</p></dd><dt class=hdlist1><em><a href=./#audit>Auditoria de Evento de Segurança</a></em></dt><dd><p>Descreve o que é a Auditoria de Eventos do FreeBSD, como ela pode ser instalada, configurada e como as trilhas de auditoria podem ser inspecionadas ou monitoradas.</p></dd><dt class=hdlist1><em><a href=./#disks>Armazenamento</a></em></dt><dd><p>Descreve como gerenciar mídias de armazenamento e sistemas de arquivos com o FreeBSD. Isto inclui discos físicos, matrizes RAID, mídias óticas e de fita, discos com suporte de memória e sistemas de arquivos de rede.</p></dd><dt class=hdlist1><em><a href=./#geom>GEOM. Framework de Transformação de Disco Modular</a></em></dt><dd><p>Descreve o que é o framework GEOM do FreeBSD e como configurar os vários níveis suportados de RAID.</p></dd><dt class=hdlist1><em><a href=./#filesystems>Outros Sistemas de Arquivos</a></em></dt><dd><p>Examina o suporte a sistemas de arquivos não-nativos no FreeBSD, como o Z File System da Sun™.</p></dd><dt class=hdlist1><em><a href=./#virtualization>Virtualização</a></em></dt><dd><p>Descreve o que os sistemas de virtualização oferecem e como eles podem ser usados com o FreeBSD.</p></dd><dt class=hdlist1><em><a href=./#l10n>Localização - Uso e Configuração do i18n/L10n</a></em></dt><dd><p>Descreve como usar o FreeBSD em outros idiomas além do inglês. Abrange a localização tanto em nível de sistema como em nível de aplicativo.</p></dd><dt class=hdlist1><em><a href=./#updating-upgrading>Atualização e Upgrade do FreeBSD</a></em></dt><dd><p>Explica as diferenças entre FreeBSD-STABLE, FreeBSD-CURRENT e FreeBSD releases. Descreve quais usuários se beneficiariam do uso de um sistema em desenvolvimento e descreve este processo. Cobre os métodos que os usuários podem usar para atualizar seu sistema para a última release de segurança.</p></dd><dt class=hdlist1><em><a href=./#dtrace>DTrace</a></em></dt><dd><p>Descreve como configurar e usar a ferramenta DTrace da Sun™ no FreeBSD. O rastreamento dinâmico pode ajudar a localizar problemas de desempenho, realizando a análise do sistema em tempo real.</p></dd><dt class=hdlist1><em><a href=./#serialcomms>Comunicações Seriais</a></em></dt><dd><p>Explica como conectar terminais e modems ao seu sistema FreeBSD para conexões de discagem de entrada e de saída.</p></dd><dt class=hdlist1><em><a href=./#ppp-and-slip>PPP</a></em></dt><dd><p>Descreve como usar o PPP para se conectar a sistemas remotos com o FreeBSD.</p></dd><dt class=hdlist1><em><a href=./#mail>Correio Eletrônico</a></em></dt><dd><p>Explica os diferentes componentes de um servidor de e-mail e mergulha em tópicos simples de configuração do software mais popular de servidor de e-mails: o sendmail.</p></dd><dt class=hdlist1><em><a href=./#network-servers>Servidores de Rede</a></em></dt><dd><p>Fornece instruções detalhadas e exemplos de arquivos de configuração para configurar sua máquina FreeBSD como um servidor de sistema de arquivos de rede, servidor de nome de domínio, servidor de sistema de informações de rede ou servidor de sincronização de horário.</p></dd><dt class=hdlist1><em><a href=./#firewalls>Firewalls</a></em></dt><dd><p>Explica a filosofia por trás dos firewalls baseados em software e fornece informações detalhadas sobre a configuração dos diferentes firewalls disponíveis para o FreeBSD.</p></dd><dt class=hdlist1><em><a href=./#advanced-networking>Rede Avançada</a></em></dt><dd><p>Descreve muitos tópicos de rede, incluindo o compartilhamento de uma conexão à Internet com outros computadores em sua LAN, tópicos avançados de roteamento, rede sem fio, Bluetooth™, ATM, IPv6 e muito mais.</p></dd><dt class=hdlist1><em><a href=./#mirrors>Obtendo o FreeBSD</a></em></dt><dd><p>Lista diferentes fontes para obter a mídia de instalação do FreeBSD em CD-ROM ou DVD, bem como diferentes sites na Internet que permitem que você baixe e instale o FreeBSD.</p></dd><dt class=hdlist1><em><a href=./#bibliography>Bibliografia</a></em></dt><dd><p>Este livro aborda muitos assuntos diferentes que podem deixá-lo com a curiosidade de uma explicação mais detalhada. A bibliografia lista muitos livros excelentes que são referenciados no texto.</p></dd><dt class=hdlist1><em><a href=./#eresources>Recursos na Internet</a></em></dt><dd><p>Descreve os muitos fóruns disponíveis para usuários do FreeBSD postarem perguntas e se engajarem em conversas técnicas sobre o FreeBSD.</p></dd><dt class=hdlist1><em><a href=./#pgpkeys>Chaves OpenPGP</a></em></dt><dd><p>Lista as fingerprints PGP de vários desenvolvedores do FreeBSD.</p></dd></dl></div></div><div class=sect2><h3 id=preface-conv>Convenções utilizadas neste livro<a class=anchor href=#preface-conv></a></h3><div class=paragraph><p>Para fornecer um texto consistente e fácil de ler, várias convenções são seguidas ao longo do livro.</p></div><div class=sect3><h4 id=preface-conv-typographic>Convenções Tipográficas<a class=anchor href=#preface-conv-typographic></a></h4><div class=dlist><dl><dt class=hdlist1><em>Itálico</em></dt><dd><p>Uma fonte <em>itálica</em> é usada para nomes de arquivos, URLs, textos enfatizados e o primeiro uso de termos técnicos.</p></dd><dt class=hdlist1><code>Monospace</code></dt><dd><p>Uma fonte <code>monoespaçada</code> é usada para mensagens de erro, comandos, variáveis de ambiente, nomes de ports, nomes de host, nomes de usuários, nomes de grupos, nomes de dispositivos, variáveis e fragmentos de código.</p></dd><dt class=hdlist1>Negrito</dt><dd><p>Uma fonte <kbd>negrita</kbd> é usada para aplicativos, comandos e chaves.</p></dd></dl></div></div><div class=sect3><h4 id=preface-conv-commands>Entrada do Usuário<a class=anchor href=#preface-conv-commands></a></h4><div class=paragraph><p>As teclas são mostradas em <strong>negrito</strong> para se destacar do restante do texto. As combinações de teclas que devem ser digitadas simultaneamente são mostradas com <code>+</code> entre as teclas, como:</p></div><div class=paragraph><p><span class=keyseq><kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>Del</kbd></span></p></div><div class=paragraph><p>Isso significa que o usuário deve digitar as teclas <kbd>Ctrl</kbd>, <kbd>Alt</kbd> e <kbd>Del</kbd> ao mesmo tempo.</p></div><div class=paragraph><p>As teclas que devem ser digitadas em sequência serão separadas por vírgulas, por exemplo:</p></div><div class=paragraph><p><span class=keyseq><kbd>Ctrl</kbd>+<kbd>X</kbd></span>, <span class=keyseq><kbd>Ctrl</kbd>+<kbd>S</kbd></span></p></div><div class=paragraph><p>Significaria que o usuário deve digitar as teclas <kbd>Ctrl</kbd> e <kbd>X</kbd> simultaneamente e, em seguida, digitar as teclas <kbd>Ctrl</kbd> e <kbd>S</kbd> simultaneamente.</p></div></div><div class=sect3><h4 id=preface-conv-examples>Exemplos<a class=anchor href=#preface-conv-examples></a></h4><div class=paragraph><p>Exemplos começando com <span class=filename>C:\></span> indicam um comando MS-DOS™. Salvo indicação em contrário, estes comandos podem ser executados a partir de uma janela de "Prompt de Comando" em um ambiente Microsoft™Windows™.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>E:<span class=se>\&gt;</span> tools<span class=se>\f</span>dimage floppies<span class=se>\k</span>ern.flp A:</code></pre></div></div><div class=paragraph><p>Exemplos começando com <code>#</code> indicam um comando que deve ser executado como superusuário no FreeBSD. Você pode logar como <code>root</code> para digitar o comando, ou logar como sua conta normal e usar o comando <a href="https://man.freebsd.org/cgi/man.cgi?query=su&amp;sektion=1&amp;format=html">su(1)</a> para obter privilégios de superusuário.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dd if=kern.flp of=/dev/fd0</span></code></pre></div></div><div class=paragraph><p>Exemplos começando com <code>%</code> indicam um comando que deve ser chamado a partir de uma conta de usuário normal. Salvo indicação em contrário, a sintaxe C-shell é usada para definir variáveis de ambiente e outros comandos do shell.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% top</code></pre></div></div></div></div><div class=sect2><h3 id=preface-acknowledgements>Agradecimentos<a class=anchor href=#preface-acknowledgements></a></h3><div class=paragraph><p>O livro que você está segurando representa os esforços de muitas centenas de pessoas em todo o mundo. Não importa se eles enviaram correções para erros de digitação ou submeteram capítulos completos, todas as contribuições foram úteis.</p></div><div class=paragraph><p>Várias empresas têm apoiado o desenvolvimento deste documento, pagando aos autores para trabalhar em tempo integral, pagando pela publicação, etc. Em particular, a BSDi (posteriormente adquirida pela <a href=http://www.windriver.com>Wind River Systems</a>) pagou membros do Projeto de Documentação do FreeBSD para trabalhar na melhoria deste livro em tempo integral, levando à publicação da primeira edição impressa em março de 2000 (ISBN 1-57176-241-8). A Wind River Systems pagou vários autores adicionais para fazer uma série de melhorias na infraestrutura de impressão e adicionar capítulos adicionais ao texto. Este trabalho culminou com a publicação da segunda edição impressa em novembro de 2001 (ISBN 1-57176-303-1). Em 2003-2004, a <a href=http://www.freebsdmall.com>FreeBSD Mall, Inc.</a> pagou a vários contribuidores para melhorar o Handbook em preparação para a terceira edição impressa.</p></div></div></div></div><h1 id=getting-started class=sect0>Parte I: Primeiros Passos<a class=anchor href=#getting-started></a></h1><div class="openblock partintro"><div class=content><div class=paragraph><p>Esta parte do handbook é destinada aos usuários e administradores que são novos no FreeBSD. Estes capítulos:</p></div><div class=ulist><ul><li><p>Apresentam o FreeBSD.</p></li><li><p>Guiam os leitores através do processo de instalação.</p></li><li><p>Ensinam conceitos básicos e fundamentais do UNIX™.</p></li><li><p>Mostram como instalar a grande variedade de aplicativos de terceiros disponíveis para o FreeBSD.</p></li><li><p>Apresenta o X, o sistema de janelas UNIX™ e detalha como configurar um ambiente de desktop para tornar os usuários mais produtivos.</p></li></ul></div><div class=paragraph><p>O número de referências a tópicos futuros no texto foi mantido no mínimo, para que uma seção possa ser lida do começo ao fim com o mínimo de avanço desnecessário de páginas.</p></div></div></div><div class=sect1><h2 id=introduction>Capítulo 1. Introdução<a class=anchor href=#introduction></a></h2><div class=sectionbody><div class=sect2><h3 id=introduction-synopsis>1.1. Sinopse<a class=anchor href=#introduction-synopsis></a></h3><div class=paragraph><p>Obrigado pelo seu interesse no FreeBSD! O capítulo seguinte cobre vários aspectos do Projeto FreeBSD, como seu histórico, objetivos, modelo de desenvolvimento e assim por diante.</p></div><div class=paragraph><p>Depois de ler este capítulo, você saberá:</p></div><div class=ulist><ul><li><p>Como o FreeBSD se relaciona com outros sistemas operacionais de computadores.</p></li><li><p>A história do projeto FreeBSD.</p></li><li><p>Os objetivos do projeto FreeBSD.</p></li><li><p>O básico do modelo de desenvolvimento de código aberto do FreeBSD.</p></li><li><p>E claro: de onde o nome "FreeBSD" vem.</p></li></ul></div></div><div class=sect2><h3 id=nutshell>1.2. Bem vindo ao FreeBSD!<a class=anchor href=#nutshell></a></h3><div class=paragraph><p>O FreeBSD é um Sistema Operacional de código aberto nos padrões Unix-Like para computadores de arquitetura x86 (32 and 64 bits), ARM™, AArch64, RISC-V™, MIPS™, POWER™, PowerPC™, and Sun UltraSPARC™. Ele fornece todos os recursos que são considerados comuns hoje em dia, como multitarefa preemptiva, proteção de memória, memória virtual, recursos para múltiplos usuários, suporte a SMP, todas as ferramentas de desenvolvimento de código aberto para diferentes linguagens e estruturas e recursos de área de trabalho centralizados no Sistema X Window, KDE ou GNOME. Seus pontos fortes são:</p></div><div class=ulist><ul><li><p><em>Licença Liberal Open Source</em>, que concede a você o direito de modificar e estender livremente seu código-fonte e incorporá-lo em projetos Open Source e produtos fechados, sem impor restrições típicas às licenças copyleft, bem como evita potenciais problemas de incompatibilidade de licença.</p></li><li><p><em>Rede TCP/IP forte</em> - O FreeBSD implementa protocolos padrões da indústria com desempenho e escalabilidade crescentes. Isso faz com que seja uma boa combinação tanto em funções de servidor quanto de roteamento/firewall - e, de fato, muitas empresas e fornecedores o utilizam precisamente para essa finalidade.</p></li><li><p><em>Suporte totalmente integrado ao OpenZFS</em>, incluindo root-on-ZFS, ZFS Boot Environments, gerenciamento de falhas, delegação administrativa, suporte a jails, documentação específica ao FreeBSD e suporte ao instalador do sistema.</p></li><li><p><em>Extensivos recursos de segurança</em>, do Mandatory Access Control ao Capsicum e mecanismos de sandbox.</p></li><li><p><em>Mais de 30 mil pacotes pré-compilados</em> para todas as arquiteturas suportadas, e a Coleção de Ports, que facilita a compilação de seus próprios pacotes personalizados.</p></li><li><p><em>Documentação</em> - além do Handbook e livros de diferentes autores que cobrem tópicos que vão da administração do sistema aos internals do kernel, há também as páginas <a href="https://man.freebsd.org/cgi/man.cgi?query=man&amp;sektion=&amp;format=html">man()</a>, não apenas para daemons do userspace, utilitários e arquivos de configuração, mas também para APIs do driver do kernel (seção 9) e drivers individuais (seção 4).</p></li><li><p><em>Estrutura de repositório simples e consistente e sistema de compilação</em> - O FreeBSD usa um único repositório para todos os seus componentes, tanto para o kernel quanto para o userspace. Isso, juntamente com um sistema de compilação unificado, fácil de personalizar e um processo de desenvolvimento bem pensado, facilita a integração do FreeBSD com a infraestrutura de compilação do seu próprio produto.</p></li><li><p><em>Mantem-se fiel à filosofia do Unix</em>, preferindo heterogeneidade ao invés de deamons monolíticos "all in one" com comportamento codificado (hardcoded).</p></li><li><p><em>Compatibilidade binária</em> com o Linux, o que torna possível executar muitos binários do Linux sem a necessidade de virtualização.</p></li></ul></div><div class=paragraph><p>O FreeBSD é baseado na release 4.4BSD-Lite do Computer Systems Research Group (CSRG) da Universidade da Califórnia em Berkeley, e mantém a tradição distinta do desenvolvimento de sistemas BSD. Além do bom trabalho fornecido pelo CSRG, o Projeto FreeBSD colocou milhares de horas-homem para estender a funcionalidade e ajustar o sistema para o máximo desempenho e confiabilidade em situações de carga reais. O FreeBSD oferece desempenho e confiabilidade a altura de outras ofertas de código aberto e comerciais, combinadas com recursos de ponta não disponíveis em nenhum outro lugar.</p></div><div class=sect3><h4 id=os-overview>1.2.1. O que o FreeBSD Pode Fazer?<a class=anchor href=#os-overview></a></h4><div class=paragraph><p>As aplicações para as quais o FreeBSD pode ser colocado são verdadeiramente limitadas apenas pela sua própria imaginação. Do desenvolvimento de software à automação de fábrica, do controle de estoque à correção de azimute de antenas de satélite remotas; Se isso puder ser feito com um produto comercial UNIX™, é mais do que provável que você também possa fazê-lo com o FreeBSD! O FreeBSD também se beneficia significativamente de milhares de aplicativos de alta qualidade desenvolvidos por centros de pesquisa e universidades em todo o mundo, muitas vezes disponíveis com pouco ou nenhum custo.</p></div><div class=paragraph><p>Como o código-fonte do FreeBSD está disponível gratuitamente, o sistema também pode ser customizado em um grau quase inédito para aplicações ou projetos especiais, e de maneiras que geralmente não são possíveis com a maioria do sistemas operacionais dos principais fornecedores comerciais. Aqui está apenas uma amostra de algumas das aplicações em que as pessoas estão atualmente usando o FreeBSD:</p></div><div class=ulist><ul><li><p><em>Serviços de Internet:</em> A robusta rede TCP/IP incorporada ao FreeBSD torna-o uma plataforma ideal para uma variedade de serviços de Internet, tais como:</p><div class=ulist><ul><li><p>Servidores WEB</p></li><li><p>Roteamento IPv4 e IPv6</p></li><li><p>Firewalls e Gateways NAT ("IP masquerading")</p></li><li><p>Servidores FTP</p></li><li><p>Servidores de Email</p></li><li><p>E mais…​</p></li></ul></div></li><li><p><em>Educação:</em> Você é estudante de ciências da computação ou de engenharia relacionada? Não há melhor maneira de aprender sobre sistemas operacionais, arquitetura de computadores e redes do que colocar as mãos no sistema, uma experiência que o FreeBSD pode oferecer. Os vários pacotes CAD, matemáticos e de design gráfico disponíveis gratuitamente também o tornam altamente útil para aqueles cujo principal interesse em um computador é fazer com que <em>outro</em> trabalho seja feito!</p></li><li><p><em>Pesquisa:</em> Com o código-fonte de todo o sistema disponível, o FreeBSD é uma excelente plataforma para pesquisa em sistemas operacionais, assim como em outros ramos da ciência da computação. A natureza livremente disponível do FreeBSD também possibilita que grupos remotos colaborem em ideias ou desenvolvimento compartilhado sem ter que se preocupar com acordos de licenciamento especiais ou limitações sobre o que pode ser discutido em fóruns abertos.</p></li><li><p><em>Rede:</em> Precisa de um novo roteador? Um servidor de nomes (DNS)? Um firewall para manter as pessoas fora de sua rede interna? O FreeBSD pode facilmente transformar esse PC não utilizado que está encostado em algum canto em um roteador avançado com recursos sofisticados de filtragem de pacotes.</p></li><li><p><em>Embarcado:</em> O FreeBSD é uma excelente plataforma para construir sistemas embarcados. Com suporte para plataformas ARM™, MIPS™ e PowerPC™, juntamente com uma pilha de rede robusta, recursos de ponta e a permissiva <a href=https://www.FreeBSD.org/doc/en_US.ISO8859-1/books/faq/introduction.html#bsd-license-restrictions>Licença BSD</a> o FreeBSD é uma excelente base para a criação de roteadores embarcados, firewalls e outros dispositivos.</p></li><li><p><em>Desktop:</em> O FreeBSD é uma ótima opção para uma solução de desktop barata usando o servidor X11 disponível gratuitamente. O FreeBSD oferece várias opções de ambientes de desktop de código aberto, incluindo as interfaces gráficas de usuário padrão do GNOME e do KDE. O FreeBSD pode até inicializar "diskless" a partir de um servidor central, tornando as estações de trabalho individuais ainda mais baratas e fáceis de administrar.</p></li><li><p><em>Desenvolvimento de Software:</em> O sistema básico do FreeBSD vem com um conjunto completo de ferramentas de desenvolvimento, incluindo um completo compilador e depurador C/C++ . O suporte para muitas outras linguagens também está disponível por meio da coleção de ports e dos pacotes.</p></li></ul></div><div class=paragraph><p>O FreeBSD está disponível para download gratuito, ou pode ser obtido em CD-ROM ou DVD. Por favor, consulte <a href=./#mirrors>Obtendo o FreeBSD</a> para maiores informações sobre como obter o FreeBSD.</p></div></div><div class=sect3><h4 id=introduction-nutshell-users>1.2.2. Quem Usa o FreeBSD?<a class=anchor href=#introduction-nutshell-users></a></h4><div class=paragraph><p>O FreeBSD é conhecido por seus recursos de serviço web - sites que rodam no FreeBSD incluem <a href=https://news.ycombinator.com/>Hacker News</a>, <a href=http://www.netcraft.com/>Netcraft</a>, <a href=http://www.163.com/>NetEase</a>, <a href=https://signup.netflix.com/openconnect>Netflix</a>, <a href=http://www.sina.com/>Sina</a>, <a href=http://www.sony.co.jp/>Sony Japan</a>, <a href=http://www.rambler.ru/>Rambler</a>, <a href=http://www.yahoo.com/>Yahoo!</a>, e <a href=http://www.yandex.ru/>Yandex</a>.</p></div><div class=paragraph><p>Os recursos avançados do FreeBSD, a segurança comprovada, o ciclo de release previsível e a licença permissiva levaram à sua utilização como plataforma para a construção de muitos appliances, dispositivos e produtos tanto comerciais quanto de código aberto. Muitas das maiores empresas de TI do mundo usam o FreeBSD:</p></div><div class=ulist><ul><li><p><a href=http://www.apache.org/>Apache</a> - A Apache Software Foundation executa a maior parte de sua infraestrutura voltada para o público, incluindo possivelmente um dos maiores repositórios SVN do mundo, com mais de 1.4 milhões de commits, no FreeBSD.</p></li><li><p><a href=http://www.apple.com/>Apple</a> - OS X utiliza muito do FreeBSD na sua pilha de rede, no seu sistema de arquivos virtuais e em muitos componentes userland. O Apple iOS também contém elementos emprestados do FreeBSD.</p></li><li><p><a href=http://www.cisco.com/>Cisco</a> - Os appliances de segurança de rede e anti-spam IronPort executam um kernel modificado do FreeBSD.</p></li><li><p><a href=http://www.citrix.com/>Citrix</a> - A linha NetScaler de dispositivos de segurança fornece balanceamento de carga nas camadas 4-7, cache de conteúdo, firewall de aplicativos, VPN segura e acesso móvel à rede em nuvem, juntamente com o poder de um shell do FreeBSD.</p></li><li><p><a href=https://www.emc.com/isilon>Dell EMC Isilon</a> - Os dispositivos de armazenamento corporativo da Isilon são baseados no FreeBSD. A licença extremamente liberal do FreeBSD permitiu que a Isilon integrasse sua propriedade intelectual ao kernel e se concentrasse em construir seu produto ao invés de um sistema operacional.</p></li><li><p><a href=http://www.quest.com/KACE>Quest KACE</a> - Os appliances de gerenciamento de sistemas KACE executam o FreeBSD devido à sua confiabilidade, escalabilidade e a comunidade que apoia seu desenvolvimento contínuo.</p></li><li><p><a href=http://www.ixsystems.com/>iXsystems</a> - A linha TrueNAS de dispositivos de armazenamento unificado é baseada no FreeBSD. Além de seus produtos comerciais, a iXsystems também gerencia o desenvolvimento dos projetos de código aberto TrueOS e FreeNAS.</p></li><li><p><a href=http://www.juniper.net/>Juniper</a> - O sistema operacional JunOS que roda em todos os equipamentos de rede da Juniper (incluindo roteadores, switches, firewalls e dispositivos de rede) é baseado no FreeBSD. A Juniper é um dos muitos fornecedores que mostra a relação simbiótica entre o projeto e os fornecedores de produtos comerciais. Melhorias geradas na Juniper são enviadas para o FreeBSD para reduzir a complexidade de integrar novos recursos do FreeBSD ao JunOS no futuro.</p></li><li><p><a href=http://www.mcafee.com/>McAfee</a> - O SecurOS, a base dos produtos de firewall corporativo da McAfee, incluindo o Sidewinder, é baseado no FreeBSD.</p></li><li><p><a href=http://www.netapp.com/>NetApp</a> - A linha de dispositivos de armazenamento Data ONTAP GX é baseada no FreeBSD. Além disso, a NetApp contribuiu com muitos recursos, incluindo o novo hipervisor licenciado pelo BSD, bhyve.</p></li><li><p><a href=http://www.netflix.com/>Netflix</a> - O appliance OpenConnect que a Netflix usa para transmitir filmes para seus clientes é baseado no FreeBSD. A Netflix fez extensas contribuições para a base de código e trabalha para manter um delta zero a partir do FreeBSD mainline. Os appliances Netflix OpenConnect são responsáveis por entregar mais de 32% de todo o tráfego de Internet na América do Norte.</p></li><li><p><a href=http://www.sandvine.com/>Sandvine</a> - A Sandvine usa o FreeBSD como base de suas plataformas de processamento de rede em tempo real de alto desempenho que compõem seus produtos inteligentes de controle de política de rede.</p></li><li><p><a href=http://www.sony.com/>Sony</a> - O console de videogame PlayStation 4 executa uma versão modificada do FreeBSD.</p></li><li><p><a href=http://www.sophos.com/>Sophos</a> - O produto Sophos Email Appliance é baseado em uma versão modificada (hardened) do FreeBSD e varre as mensagens de entrada em busca por spam e vírus, ao mesmo tempo em que monitora as mensagens de saída quanto a malware, bem como a perda acidental de informações confidenciais.</p></li><li><p><a href=http://www.spectralogic.com/>Spectra Logic</a> - A linha nTier de dispositivos de armazenamento de dados de arquivamento executa o FreeBSD e o OpenZFS.</p></li><li><p><a href=https://www.stormshield.eu>Stormshield</a> - Os dispositivos Stormshield Network Security são baseados em uma versão modificada do FreeBSD. A licença BSD permite que eles integrem sua própria propriedade intelectual ao sistema enquanto retornam uma grande quantidade de desenvolvimento interessante para a comunidade.</p></li><li><p><a href=http://www.weather.com/>The Weather Channel</a> - O appliance IntelliStar que é instalado na central de cada provedor de cabo local e é responsável por injetar previsões meteorológicas locais na programação da rede de TV a cabo, executa o FreeBSD.</p></li><li><p><a href=http://www.verisign.com/>Verisign</a> - A Verisign é responsável por operar os registros de domínio raiz .com e .net, bem como a infra-estrutura de DNS que a acompanha. Eles contam com diversos sistemas operacionais de rede, incluindo o FreeBSD, para garantir que não haja um ponto comum de falha em sua infraestrutura.</p></li><li><p><a href=http://www.voxer.com/>Voxer</a> - A Voxer suporta sua plataforma de mensagem de voz móvel com o ZFS no FreeBSD. A Voxer mudou de um derivativo do Solaris para o FreeBSD por causa da sua documentação superior, comunidade maior e mais ativa e ao ambiente mais favorável ao desenvolvedor. Além de recursos críticos como o ZFS e o DTrace, o FreeBSD também oferece suporte a TRIM no ZFS.</p></li><li><p><a href=https://fudosecurity.com/en/>Fudo Security</a> - O dispositivo de segurança FUDO permite que as empresas monitorem, controlem, registrem e façam auditoria de contratados e administradores que trabalham em seus sistemas. Baseado em todos os melhores recursos de segurança do FreeBSD, incluindo ZFS, GELI, Capsicum, HAST e auditdistd.</p></li></ul></div><div class=paragraph><p>O FreeBSD também gerou vários projetos de código aberto relacionados:</p></div><div class=ulist><ul><li><p><a href=http://bsdrp.net/>BSD Router</a> - Um substituto baseado em FreeBSD para grandes roteadores corporativos projetados para rodar em hardware PC padrão.</p></li><li><p><a href=http://www.freenas.org/>FreeNAS</a> - Um FreeBSD personalizado projetado para ser usado como um dispositivo de servidor de arquivos de rede. Fornece uma interface web baseada em Python para simplificar o gerenciamento dos sistemas de arquivos UFS e ZFS. Inclui suporte para NFS, SMB/CIFS, AFP, FTP e iSCSI. Inclui um sistema extensível de plugins baseado em jails do FreeBSD.</p></li><li><p><a href=https://ghostbsd.org/>GhostBSD</a> - é derivado do FreeBSD, usa o ambiente GTK para fornecer uma aparência bonita e uma experiência confortável na moderna plataforma BSD, oferecendo um ambiente de trabalho natural e nativo UNIX™.</p></li><li><p><a href=http://mfsbsd.vx.sk/>mfsBSD</a> - Um kit de ferramentas para compilar uma imagem do sistema FreeBSD que roda inteiramente da memória.</p></li><li><p><a href=http://www.nas4free.org/>NAS4Free</a> - Uma distribuição de servidor de arquivos baseada no FreeBSD com uma interface web PHP.</p></li><li><p><a href=http://www.opnsense.org/>OPNSense</a> - OPNsense é um firewall e uma plataforma de roteamento open source, baseado em FreeBSD, fácil-de-usar e fácil-de-compilar. O OPNsense inclui a maioria dos recursos disponíveis em firewalls comerciais caros e, em muitos casos, muito mais. Ele traz o rico conjunto de recursos de ofertas comerciais com os benefícios de códigos fonte abertos e verificáveis.</p></li><li><p><a href=https://www.trueos.org>TrueOS</a> - O TrueOS é baseado na lendária segurança e estabilidade do FreeBSD. O TrueOS segue o FreeBSD-CURRENT, com os drivers, atualizações de segurança e pacotes mais recentes disponíveis.</p></li><li><p><a href=https://www.furybsd.org>FuryBSD</a> - é um desktop FreeBSD de código aberto novinho em folha. O FuryBSD presta homenagem aos projetos de BSD de desktop do passado, como PC-BSD e TrueOS com sua interface gráfica e adiciona ferramentas adicionais, como uma imagem live USB/DVD híbrida. O FuryBSD é totalmente gratuito para uso e distribuído sob a licença BSD.</p></li><li><p><a href=https://www.midnightbsd.org>MidnightBSD</a> - é um sistema operacional derivado do FreeBSD desenvolvido com usuários de desktop em mente. Inclui todo o software que você esperaria para suas tarefas diárias: email, navegação web, processamento de texto, jogos e muito mais.</p></li><li><p><a href=http://www.pfsense.org/>pfSense</a> - Uma distribuição de firewall baseada no FreeBSD com uma enorme variedade de recursos e amplo suporte a IPv6.</p></li><li><p><a href=http://zrouter.org/>ZRouter</a> - Um firmware alternativo de código aberto para dispositivos embarcados baseado no FreeBSD. Projetado para substituir o firmware proprietário em roteadores prontos para uso.</p></li></ul></div><div class=paragraph><p>Uma lista de <a href=https://www.freebsdfoundation.org/about/testimonials/>depoimentos de empresas que baseiam seus produtos e serviços no FreeBSD</a> pode ser encontrada no site da Fundação FreeBSD. A Wikipedia também mantém uma <a href=https://en.wikipedia.org/wiki/List_of_products_based_on_FreeBSD>lista de produtos baseados no FreeBSD</a>.</p></div></div></div><div class=sect2><h3 id=history>1.3. Sobre o Projeto FreeBSD<a class=anchor href=#history></a></h3><div class=paragraph><p>A seção a seguir fornece algumas informações básicas sobre o projeto, incluindo um breve histórico, metas do projeto e o modelo de desenvolvimento do projeto.</p></div><div class=sect3><h4 id=intro-history>1.3.1. Uma Breve História do FreeBSD<a class=anchor href=#intro-history></a></h4><div class=paragraph><p>O Projeto FreeBSD teve sua gênese no início de 1993, parcialmente como uma evolução natural do Unofficial 386BSD Patchkit por parte dos três últimos coordenadores: Nate Williams, Rod Grimes e Jordan Hubbard.</p></div><div class=paragraph><p>O objetivo original era produzir um snapshot intermediário do 386BSD, a fim de corrigir um grande número de problemas que o mecanismo do patchkit simplesmente não era capaz de resolver. O título inicial do projeto foi 386BSD 0.5 ou 386BSD Interim em referência a esse fato.</p></div><div class=paragraph><p>O 386BSD era o sistema operacional do Bill Jolitz, que havia até então sofrido bastante com quase um ano de negligência. Como o patchkit inchava cada vez mais desconfortavelmente a cada dia que passava, eles decidiram ajudar o Bill fornecendo este snapshot "limpo". Esses planos foram interrompidos quando, de repente, Bill Jolitz decidiu retirar sua sanção do projeto sem qualquer indicação clara do que seria feito em seu lugar.</p></div><div class=paragraph><p>O trio achou que a meta continuava valendo a pena, mesmo sem o apoio de Bill, e então adotaram o nome "FreeBSD" cunhado por David Greenman. Os objetivos iniciais foram definidos após consultar os usuários atuais do sistema e, uma vez que ficou claro que o projeto estava em vias de se tornar realidade, Jordan entrou em contato com a Walnut Creek CDROM com o objetivo de melhorar os canais de distribuição do FreeBSD para aqueles desafortunados sem acesso fácil à Internet. O Walnut Creek CDROM não apenas apoiou a ideia de distribuir o FreeBSD em CD, mas também chegou a fornecer ao projeto uma máquina para trabalhar e uma conexão rápida à Internet. Sem o grau de fé quase sem precedentes da Walnut Creek CDROM no que era, na época, um projeto completamente desconhecido, é bastante improvável que o FreeBSD tivesse chegado tão longe, tão rápido, como hoje.</p></div><div class=paragraph><p>A primeira distribuição em CD-ROM (e amplo pela rede) foi o FreeBSD 1.0, lançado em dezembro de 1993. Isto foi baseado na fita 4.3BSD-Lite ("Net/2") da U.C. Berkeley, com muitos componentes também fornecidos pelo 386BSD e pela Free Software Foundation. Foi um sucesso bastante razoável para uma primeira oferta, e e eles seguiram com o bem-sucedido FreeBSD 1.1 em maio de 1994.</p></div><div class=paragraph><p>Por esta altura, algumas nuvens de tempestade inesperadas formaram-se no horizonte, como a Novell e U.C. Berkeley resolveram seu longo processo judicial sobre o status legal da fita do Berkeley Net/2. Uma condição desse acordo foi a concessão da U.C. Berkeley de que grande parte do código Net/2 foi "onerado" e era de propriedade da Novell, que por sua vez o adquiriu da AT&amp;T algum tempo antes. O que a Berkeley recebeu em troca foi a "bênção" da Novell de que o lançamento do 4.4BSD-Lite, quando finalmente fosse lançado, seria declarado livre e todos os atuais usuários do Net/2 seriam fortemente encorajados a mudar. Isso incluiu o FreeBSD, e foi dado ao projeto o tempo para interromper o envio de seu próprio produto baseado em Net/2 até o final de julho de 1994. Sob os termos desse acordo, o projeto recebeu um último lançamento antes do prazo final, sendo esse lançamento o FreeBSD 1.1.5.1.</p></div><div class=paragraph><p>O FreeBSD então começou a tarefa árdua de literalmente se reinventar de um conjunto completamente novo e incompleto de bits do 4.4BSD-Lite. As versões "Lite" foram leves em parte porque o CSRG da Berkeley removeu grandes pedaços de código necessários para realmente compilar um sistema inicializável (devido a vários requisitos legais) e o fato de que a port Intel do 4.4 era altamente incompleto. O projeto levou até novembro de 1994 para fazer essa transição, e em dezembro lançou o FreeBSD 2.0 para o mundo. Apesar de ainda ser um pouco mais difícil, o lançamento foi um sucesso significativo e foi seguido pela versão mais robusta e fácil de instalar o FreeBSD 2.0.5 em junho de 1995.</p></div><div class=paragraph><p>Desde aquela época, o FreeBSD fez uma série de lançamentos cada vez melhorando a estabilidade, a velocidade e o conjunto de recursos da versão anterior.</p></div><div class=paragraph><p>Por enquanto, os projetos de desenvolvimento de longo prazo continuam a ocorrer no ramo 10.X-CURRENT (trunk), e os snapshots de release 10.X são continuamente disponibilizados a partir do <a href=ftp://ftp.FreeBSD.org/pub/FreeBSD/snapshots/>servidor de snapshots</a> à medida que o trabalho progride.</p></div></div><div class=sect3><h4 id=goals>1.3.2. Objetivos do Projeto FreeBSD<a class=anchor href=#goals></a></h4><div class=paragraph><p>Os objetivos do Projeto FreeBSD são fornecer software que possa ser usado para qualquer propósito e sem amarras. Muitos de nós temos um investimento significativo no código (e projeto) e certamente não nos importaríamos com uma pequena compensação financeira de vez em quando, mas definitivamente não estamos preparados para insistir nisso. Acreditamos que a nossa primeira e principal "missão" é fornecer código a todos os participantes, e para qualquer finalidade, para que o código obtenha o maior uso possível e forneça o maior benefício possível. Este é, acredito, um dos objetivos mais fundamentais do Software Livre e um dos que apoiamos entusiasticamente.</p></div><div class=paragraph><p>O código em nossa árvore de código-fonte que se enquadra na GNU General Public License (GPL) ou na Library General Public License (LGPL) vem com um pouco mais de amarras, embora pelo menos do lado do acesso imposto, em vez do oposto usual. Devido às complexidades adicionais que podem evoluir no uso comercial de software GPL, no entanto, preferimos software submetido sob licença BSD quando é uma opção razoável fazê-lo.</p></div></div><div class=sect3><h4 id=development>1.3.3. O Modelo de Desenvolvimento do FreeBSD<a class=anchor href=#development></a></h4><div class=paragraph><p>O desenvolvimento do FreeBSD é um processo muito aberto e flexível, sendo construído literalmente a partir das contribuições de milhares de pessoas ao redor do mundo, como pode ser visto na nossa <a href=https://docs.freebsd.org/pt-br/articles/contributors/>lista de contribuidores</a>. A infraestrutura de desenvolvimento do FreeBSD permite que milhares de colaboradores colaborem pela Internet. Estamos constantemente à procura de novos desenvolvedores e ideias, e os interessados em se envolver mais estreitamente com o projeto precisam simplesmente entrar em contato conosco pelas <a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-hackers>lista de discussões técnicas do FreeBSD</a>. A <a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-announce>lista de discussão de anúncios do FreeBSD</a> também está disponível para aqueles que desejam fazer com que outros usuários do FreeBSD conheçam as principais áreas de trabalho.</p></div><div class=paragraph><p>Coisas úteis para saber sobre o Projeto FreeBSD e seu processo de desenvolvimento, seja trabalhando independentemente ou em estreita cooperação:</p></div><div class=dlist><dl><dt class=hdlist1>Os repositórios SVN<a id=development-cvs-repository></a></dt><dd><p>Por vários anos, a árvore de código-fonte central do FreeBSD foi mantida pelo <a href=http://www.nongnu.org/cvs/>CVS</a> (Concurrent Versions Systems), uma ferramenta de controle de código-fonte disponível gratuitamente. Em junho de 2008, o Projeto mudou para o <a href=http://subversion.tigris.org>SVN</a> (Subversion). A troca foi considerada necessária, pois as limitações técnicas impostas pelo CVS estavam se tornando óbvias devido à rápida expansão da árvore de código-fonte e à quantidade de histórico já armazenada. Os repositórios do Projeto de Documentação e da Coleção de Ports também foram movidos do CVS para o SVN em maio de 2012 e julho de 2012, respectivamente. Por favor, consulte a seção <a href=./#synching>Atualizando o código fonte</a> para maiores informações sobre como obter o repositório <code>src/</code> do FreeBSD e <a href=./#ports-using>Usando a Coleção de Ports</a> para detalhes sobre como obter a coleção de ports do FreeBSD.</p></dd><dt class=hdlist1>A lista de committers<a id=development-committers></a></dt><dd><p>Os <em>committers</em> são as pessoas que têm acesso de <em>escrita</em> na árvore do Subversion, e estão autorizados a fazer modificações no código fonte do FreeBSD (o termo "committer" vem de <code>commit</code>, o comando de controle de código-fonte que é usado para trazer novas mudanças para o repositório). Qualquer um pode enviar um relatório de bug para o <a href=https://bugs.FreeBSD.org/submit/>Banco de Dados de Bugs</a>. Antes de enviar um relatório de bug, as listas de discussão, canais de IRC ou fóruns do FreeBSD podem ser usados para ajudar a verificar se um problema é realmente um bug.</p></dd><dt class=hdlist1>O FreeBSD core team<a id=development-core></a></dt><dd><p>O <em>FreeBSD core team</em> seria equivalente a um conselho de diretores se o Projeto FreeBSD fosse uma empresa. A principal tarefa do core team é garantir que o projeto, como um todo, esteja saudável e seguindo na direção certa. Convidar desenvolvedores dedicados e responsáveis a ingressar em nosso grupo de committers é uma das funções do core team, assim como o recrutamento de novos membros do core team à medida que os outros saiam. O core team atual foi eleito a partir de um grupo de committers candidatos em junho de 2020. As eleições são realizadas a cada dois anos.</p><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Como a maioria dos desenvolvedores, a maioria dos membros do core team também são voluntários quando se trata de desenvolvimento do FreeBSD e não se beneficiam financeiramente do projeto, então o "compromisso" também não deve ser interpretado erroneamente como significando "suporte garantido". A analogia do "quadro de diretores" da diretriz acima não é muito precisa, e pode ser mais apropriado dizer que estas são as pessoas que deram suas vidas em favor do FreeBSD contra o seu melhor julgamento!</p></div></td></tr></tbody></table></div></dd><dt class=hdlist1>Contribuidores externos</dt><dd><p>Por último, mas definitivamente não menos importante, o maior grupo de desenvolvedores são os próprios usuários que fornecem feedback e correções de bugs para nós em uma base quase constante. A principal maneira de manter contato com o desenvolvimento não-centralizado do FreeBSD é inscrever-se nas <a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-hackers>listas de discussões técnicas sobre o FreeBSD</a> onde essas coisas são discutidas. Veja <a href=./#eresources>Recursos na Internet</a> para maiores informações sobre as várias listas de discussão do FreeBSD.</p><div class=paragraph><p>A <a href=https://docs.freebsd.org/pt-br/articles/contributors/>Lista de Colaboradores do FreeBSD</a> é extensa e crescente, então por que não se juntar a ela contribuindo com algo para o FreeBSD hoje?</p></div><div class=paragraph><p>Fornecer código não é a única maneira de contribuir para o projeto; para uma lista mais completa de coisas que precisam ser feitas, por favor consulte o <a href=https://www.FreeBSD.org/>web site do Projeto FreeBSD</a>.</p></div></dd></dl></div><div class=paragraph><p>Em resumo, nosso modelo de desenvolvimento é organizado como um conjunto solto de círculos concêntricos. O modelo centralizado é projetado para a conveniência dos <em>usuários</em> do FreeBSD, que são providos com uma maneira fácil de rastrear uma base de código central, e não para manter potenciais colaboradores fora! Nosso desejo é apresentar um sistema operacional estável com um grande conjunto de <a href=./#ports>aplicações</a> coerentes que os usuários possam facilmente instalar e usar - este modelo funciona muito bem em realizar isso.</p></div><div class=paragraph><p>Tudo o que pedimos para aqueles que se juntarem a nós como desenvolvedores do FreeBSD é a mesma dedicação que o pessoal atual tem para o seu sucesso contínuo!</p></div></div><div class=sect3><h4 id=third-party-programs>1.3.4. Programas de Terceiros<a class=anchor href=#third-party-programs></a></h4><div class=paragraph><p>Além das distribuições básicas, o FreeBSD oferece uma coleção de software portada com milhares de programas comumente procurados. No momento da redação deste texto, havia mais de 24.000 ports! A lista de ports varia de servidores http, a jogos, linguagens, editores e quase tudo no meio. Toda a coleção de ports requer aproximadamente 500 MB. Para compilar um port, simplesmente mude para o diretório do programa que você deseja instalar, digite <code>make install</code> e deixe o sistema fazer o resto. A distribuição original completa para cada port que você cria é baixada dinamicamente, para que você precise apenas de espaço em disco suficiente para compilar os ports desejados. Quase todos os ports também são fornecidos como um pacote "pré-compilado", que pode ser instalado com um comando simples (<code>pkg install</code>) por aqueles que não desejam compilar seus próprios ports pelo código fonte. Maiores informações sobre pacotes e ports podem ser encontradas em <a href=./#ports>Instalando Aplicativos. Pacotes e Ports</a>.</p></div></div><div class=sect3><h4 id=_documentação_adicional>1.3.5. Documentação Adicional<a class=anchor href=#_documentação_adicional></a></h4><div class=paragraph><p>Todas as versões suportadas do FreeBSD fornecem uma opção no instalador para instalar documentação adicional em <span class=filename>/usr/local/shar/doc/freebsd</span> durante a configuração inicial do sistema. A documentação também pode ser instalada posteriormente, usando os pacotes descritos em <a href=./#doc-ports-install-package>Atualizando a documentação a partir do ports</a>. Você pode ver os manuais instalados localmente com qualquer navegador compatível com HTML usando as seguintes URLs:</p></div><div class=dlist><dl><dt class=hdlist1>O Handbook do FreeBSD</dt><dd><p><a href=file://localhost/usr/local/shared/doc/freebsd/handbook/index.html>/usr/local/shared/doc/freebsd/handbook/index.html</a></p></dd><dt class=hdlist1>O FAQ do FreeBSD</dt><dd><p><a href=file://localhost/usr/local/shared/doc/freebsd/faq/index.html>/usr/local/shared/doc/freebsd/faq/index.html</a></p></dd></dl></div><div class=paragraph><p>Você também pode visualizar as cópias principais (e atualizadas com mais frequência) em <a href=https://www.FreeBSD.org/>https://www.FreeBSD.org/</a>.</p></div></div></div></div></div><div class=sect1><h2 id=bsdinstall>Capítulo 2. Instalando o FreeBSD<a class=anchor href=#bsdinstall></a></h2><div class=sectionbody><div class=sect2><h3 id=bsdinstall-synopsis>2.1. Sinopse<a class=anchor href=#bsdinstall-synopsis></a></h3><div class=paragraph><p>Existem diversos modos diferentes de colocar o FreeBSD para rodar, dependendo do ambiente. São eles:</p></div><div class=ulist><ul><li><p>Imagens de Máquinas Virtuais, para baixar e importar em um ambiente virtual da sua escolha. Elas podem ser baixadas da página de <a href=https://www.freebsd.org/where/>Download do FreeBSD</a>. Existem imagens para KVM ("qcow2"), VMWare ("vmdk"), Hyper-V ("vhd") e imagens de dispositivos brutos (raw device) que são universalmente suportadas . Estas não são imagens de instalação, mas sim as instâncias pré-configuradas ("já instaladas"), prontas para executar e realizar tarefas de pós-instalação.</p></li><li><p>Imagens de máquinas virtuais disponíveis no <a href=https://aws.amazon.com/marketplace/pp/B07L6QV354>AWS Marketplace</a>, no <a href="https://azuremarketplace.microsoft.com/en-us/marketplace/apps?search=freebsd&amp;page=1">Microsoft Azure Marketplace</a>, e na <a href=https://console.cloud.google.com/marketplace/details/freebsd-cloud/freebsd-12>Plataforma Google Cloud</a>, para executar em seus respectivos serviços de hospedagem. Para obter maiores informações sobre como implantar o FreeBSD no Azure, consulte o capítulo relevante na <a href=https://docs.microsoft.com/en-us/azure/virtual-machines/linux/freebsd-intro-on-azure>Documentação do Azure</a>.</p></li><li><p>Imagens de cartão SD, para sistemas embarcados, como Raspberry Pi ou BeagleBone Black. Eles podem ser baixados da página de <a href=https://www.freebsd.org/where/>Download do FreeBSD</a>. Esses arquivos devem ser descompactados e gravados como uma imagem bruta para um cartão SD, a partir do qual a placa será inicializada.</p></li><li><p>Imagens de instalação, para instalar o FreeBSD no disco rígido de um desktop padrão, laptop ou servidor.</p></li></ul></div><div class=paragraph><p>O resto deste capítulo descreve o quarto caso, explicando como instalar o FreeBSD usando o programa de instalação baseado em texto chamado bsdinstall.</p></div><div class=paragraph><p>Em geral, as instruções de instalação neste capítulo foram escritas para as arquiteturas i386™ e AMD64. Onde aplicável, instruções específicas para outras plataformas serão listadas. Pode haver pequenas diferenças entre o instalador e o que é mostrado aqui, portanto, use este capítulo como um guia geral, e não como um conjunto de instruções literais.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Usuários que preferem instalar o FreeBSD usando uma instaldor gráfico talvez possam se interessar no <a href=https://www.furybsd.org>FuryBSD</a>, <a href=https://ghostbsd.org>GhostBSD</a> ou <a href=https://www.midnightbsd.org>MidnightBSD</a>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Depois de ler este capítulo, você saberá:</p></div><div class=ulist><ul><li><p>Quais os requisitos mínimos de hardware e as arquiteturas suportadas pelo FreeBSD.</p></li><li><p>Como criar a mídia de instalação do FreeBSD.</p></li><li><p>Como iniciar o bsdinstall.</p></li><li><p>As perguntas que o bsdinstall fará, o que elas significam e como respondê-las.</p></li><li><p>Como solucionar problemas de uma instalação com falha.</p></li><li><p>Como acessar uma versão live do FreeBSD antes de se comprometer com uma instalação.</p></li></ul></div><div class=paragraph><p>Antes de ler este capítulo, você deve:</p></div><div class=ulist><ul><li><p>Ler a lista de hardware suportado que acompanha a versão do FreeBSD que será instalada e verificar se o hardware do sistema é suportado.</p></li></ul></div></div><div class=sect2><h3 id=bsdinstall-hardware>2.2. Requisitos mínimos de hardware<a class=anchor href=#bsdinstall-hardware></a></h3><div class=paragraph><p>Os requisitos de hardware para instalar o FreeBSD variam por arquitetura. Arquiteturas de hardware e dispositivos suportados por uma release do FreeBSD estão listados na página <a href=https://www.FreeBSD.org/releases/>Informação de Release do FreeBSD</a>. A <a href=https://www.FreeBSD.org/where/>página de download do FreeBSD</a> também tem recomendações para escolha a imagem correta para as diferentes arquiteturas.</p></div><div class=paragraph><p>Uma instalação do FreeBSD requer um mínimo de 96 MB de RAM e 1,5 GB de espaço livre no disco rígido. No entanto, essas pequenas quantidades de memória e espaço em disco são realmente adequadas apenas para aplicativos personalizados, como dispositivos embarcados. Os sistemas de desktop de uso geral precisam de mais recursos. De 2 a 4 GB de RAM e pelo menos 8 GB de espaço no disco rígido é um bom ponto de partida.</p></div><div class=paragraph><p>Estes são os requisitos do processador para cada arquitetura:</p></div><div class=dlist><dl><dt class=hdlist1>amd64</dt><dd><p>Esse é o tipo de processador de desktop e laptop mais comum, usado na maioria dos sistemas modernos. A Intel ™ chama ele de Intel64. Outros fabricantes às vezes o chamam de x86-64.</p><div class=paragraph><p>Exemplos de processadores compatíveis com AMD64 incluem: AMD Athlon™ 64, AMD Opteron™, multi-core Intel™Xeon™ e processadores Intel™Core™ 2 e posteriores.</p></div></dd><dt class=hdlist1>i386</dt><dd><p>Desktops e laptops mais antigos geralmente usam essa arquitetura x86 de 32 bits.</p><div class=paragraph><p>Quase todos os processadores compatíveis com i386 com uma unidade de ponto flutuante são suportados. Todos os processadores Intel™ 486 ou superior são suportados.</p></div><div class=paragraph><p>O FreeBSD irá aproveitar o suporte a Extensões de Endereços Físicos (PAE) em CPUs com este recurso. Um kernel com o recurso PAE ativado detectará memória acima de 4 GB e permitirá que ela seja usada pelo sistema. No entanto, o uso do PAE coloca restrições em drivers de dispositivos e outros recursos do FreeBSD.</p></div></dd><dt class=hdlist1>powerpc</dt><dd><p>Todos os sistemas New World ROMApple™Mac™ com USB incorporados são suportados. O SMP é suportado em máquinas com vários CPUs.</p><div class=paragraph><p>Um kernel de 32 bits só pode usar os primeiros 2 GB de RAM.</p></div></dd><dt class=hdlist1>sparc64</dt><dd><p>Os sistemas suportados pelo FreeBSD/sparc64 estão listados no <a href=https://www.FreeBSD.org/platforms/sparc/>Projeto FreeBSD/sparc64</a>.</p><div class=paragraph><p>O SMP é suportado em todos os sistemas com mais de 1 processador. Um disco dedicado é necessário, pois não é possível compartilhar um disco com outro sistema operacional neste momento.</p></div></dd></dl></div></div><div class=sect2><h3 id=bsdinstall-pre>2.3. Tarefas de Pré-instalação<a class=anchor href=#bsdinstall-pre></a></h3><div class=paragraph><p>Uma vez determinado que o sistema atende aos requisitos mínimos de hardware para instalar o FreeBSD, o arquivo de instalação deve ser baixado e a mídia de instalação preparada. Antes de fazer isso, verifique se o sistema está pronto para uma instalação, verificando os itens nesta lista de controle:</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Faça backup dos dados importantes</p><div class=paragraph><p>Antes de instalar qualquer sistema operacional, <em>sempre</em> faça backup de todos os dados importantes primeiro. Não armazene o backup no sistema que está sendo instalado. Em vez disso, salve os dados em um disco removível, como uma unidade USB, outro sistema na rede ou um serviço de backup online. Teste o backup antes de iniciar a instalação para garantir que ele contenha todos os arquivos necessários. Depois que o instalador formatar o disco do sistema, todos os dados armazenados nesse disco serão perdidos.</p></div></li><li><p>Decida onde instalar o FreeBSD</p><div class=paragraph><p>Se o FreeBSD for o único sistema operacional instalado, esta etapa pode ser ignorada. Mas se o FreeBSD compartilhar o disco com outro sistema operacional, decida qual disco ou partição será usado para o FreeBSD.</p></div><div class=paragraph><p>Nas arquiteturas i386 e amd64, os discos podem ser divididos em várias partições usando um dos dois esquemas de particionamento. Um <em>registro de inicialização mestre</em> tradicional (MBR) contém uma tabela de partição que define até quatro <em>partições primárias</em>. Por razões históricas, o FreeBSD chama essas partições primárias de <em>slices</em>. Uma dessas partições primárias pode ser transformada em uma <em>partição estendida</em> contendo várias <em>partições lógicas</em>. A <em>Tabela de Partição GUID</em> (GPT) é um método mais novo e mais simples de particionar um disco. Implementações comuns de GPT permitem até 128 partições por disco, eliminando a necessidade de partições lógicas.</p></div><div class=paragraph><p>O boot loader do FreeBSD requer uma partição primária ou GPT. Se todas as partições primárias ou GPT já estiverem em uso, uma deve ser liberada para o FreeBSD. Para criar uma partição sem excluir dados existentes, use uma ferramenta de redimensionamento de partição para reduzir uma partição existente e criar uma nova partição usando o espaço liberado.</p></div><div class=paragraph><p>Uma variedade de ferramentas de redimensionamento de partições comerciais e gratuitas estão listadas em <a href=http://en.wikipedia.org/wiki/List_of_disk_partitioning_software>http://en.wikipedia.org/wiki/List_of_disk_partitioning_software</a>. O GParted Live (<a href=http://gparted.sourceforge.net/livecd.php>http://gparted.sourceforge.net/livecd.php</a>) é um live CD que inclui o editor de partições GParted. O GParted também está incluído em muitas outras distribuições live CD do Linux.</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Quando usados corretamente, os utilitários de encolhimento de disco podem criar espaço com segurança para criar uma nova partição. Como existe a possibilidade de selecionar a partição errada, sempre faça backup de todos os dados importantes e verifique a integridade do backup antes de modificar as partições do disco.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Partições de disco contendo diferentes sistemas operacionais tornam possível instalar vários sistemas operacionais em um computador. Uma alternativa é usar virtualização (<a href=./#virtualization>Virtualização</a>) o que permite que vários sistemas operacionais sejam executados ao mesmo tempo sem modificar nenhuma partição de disco.</p></div></li><li><p>Colete informações de rede</p><div class=paragraph><p>Alguns métodos de instalação do FreeBSD requerem uma conexão de rede para baixar os arquivos de instalação. Após qualquer instalação, o instalador oferecerá a configuração das interfaces de rede do sistema.</p></div><div class=paragraph><p>Se a rede tiver um servidor DHCP, ele poderá ser usado para fornecer configuração de rede automática. Se o DHCP não estiver disponível, as seguintes informações de rede para o sistema devem ser obtidas com o administrador de rede local ou com o provedor de serviços de Internet:</p></div><div id=bsdinstall-collect-network-information class="olist loweralpha"><ol class=loweralpha type=a><li><p>Endereço IP</p></li><li><p>Máscara de sub-rede</p></li><li><p>Endereço do IP do gateway padrão</p></li><li><p>Nome de domínio da rede</p></li><li><p>Endereços IP dos servidores DNS da rede</p></li></ol></div></li><li><p>Verifique a Errata do FreeBSD</p><div class=paragraph><p>Embora o Projeto FreeBSD se esforce para garantir que cada versão do FreeBSD seja o mais estável possível, ocasionalmente, os bugs aparecem no processo. Em raras ocasiões, esses erros afetam o processo de instalação. A medida que esses problemas são descobertos e corrigidos, eles são anotados na Errata do FreeBSD (<a href=https://www.FreeBSD.org/releases/12.1R/errata/>https://www.freebsd.org/releases/12.1R/errata/</a>) no site do FreeBSD. Verifique a errata antes de instalar para certificar-se de que não existem problemas que possam afetar a instalação.</p></div><div class=paragraph><p>Informações e erratas para todos os releases podem ser encontradas na seção de informações de release do site do FreeBSD (<a href=https://www.FreeBSD.org/releases/>https://www.freebsd.org /releases/</a>).</p></div></li></ol></div></div></div><div class=sect3><h4 id=bsdinstall-installation-media>2.3.1. Prepare a mídia de instalação<a class=anchor href=#bsdinstall-installation-media></a></h4><div class=paragraph><p>O instalador do FreeBSD não é um aplicativo que pode ser executado dentro de outro sistema operacional. Em vez disso, baixe um arquivo de instalação do FreeBSD, grave-o na mídia associada ao seu tipo e tamanho (CD, DVD, ou USB), e inicialize o sistema para instalar a partir da mídia inserida.</p></div><div class=paragraph><p>Os arquivos de instalação do FreeBSD estão disponíveis em <a href=https://www.FreeBSD.org/where/>www.freebsd.org/where/</a>. O nome de cada arquivo de instalação inclui a versão de Release do FreeBSD, a arquitetura e o tipo de arquivo. Por exemplo, para instalar o FreeBSD 12.1 em um sistema amd64 de um DVD, baixe o <span class=filename>FreeBSD-12.1-RELEASE-amd64-dvd1.iso</span>, grave este arquivo em um DVD, e inicialize o sistema com o DVD inserido.</p></div><div class=paragraph><p>Os arquivos de instalação estão disponíveis em vários formatos. Os formatos variam dependendo da arquitetura do computador e do tipo de mídia.</p></div><div id=bsdinstall-installation-media-uefi class=paragraph><p>Arquivos de instalação adicionais são incluídos para computadores que inicializam com UEFI (Interface de Firmware Extensível Unificada). Os nomes desses arquivos incluem a string <span class=filename>uefi</span>.</p></div><div class=paragraph><p>Tipos de arquivo:</p></div><div class=ulist><ul><li><p><code>-bootonly.iso</code>: Este é o menor arquivo de instalação, pois contém apenas o instalador. É necessária uma conexão de Internet em funcionamento durante a instalação, pois o instalador fará o download dos arquivos necessários para concluir a instalação do FreeBSD. Este arquivo deve ser gravado em um CD usando um aplicativo de gravação CD.</p></li><li><p><code>-disc1.iso</code>: Este arquivo contém todos os arquivos necessários para instalar o FreeBSD, seu código-fonte e a coleção de ports. Ele deve ser gravado em um CD usando um aplicativo de gravação CD.</p></li><li><p><code>-dvd1.iso</code>: Este arquivo contém todos os arquivos necessários para instalar o FreeBSD, seu código-fonte e a coleção de ports. Ele também contém um conjunto de pacotes binários populares para instalar um gerenciador de janelas e alguns aplicativos para que um sistema completo possa ser instalado a partir da mídia sem a necessidade de uma conexão com a Internet. Este arquivo deve ser gravado em um DVD usando um aplicativo de gravação DVD.</p></li><li><p><code>-memstick.img</code>: Este arquivo contém todos os arquivos necessários para instalar o FreeBSD, seu código-fonte e a coleção de ports. Ele deve ser gravado em um pendrive USB usando as instruções abaixo.</p></li><li><p><code>-mini-memstick.img</code>: Como ` -bootonly.iso `, não inclui arquivos de instalação, mas faz o download conforme necessário. É necessária uma conexão de internet em funcionamento durante a instalação. Grave este arquivo para um pendrive USB como mostrado em <a href=#bsdinstall-usb>Gravando um arquivo de imagem para um pendrive USB</a>.</p></li></ul></div><div class=paragraph><p>Depois de baixar o arquivo de imagem, baixe o <span class=filename>CHECKSUM.SHA256</span> do mesmo diretório. Calcule o <em>checksum</em> para o arquivo de imagem. O FreeBSD fornece o <a href="https://man.freebsd.org/cgi/man.cgi?query=sha256&amp;sektion=1&amp;format=html">sha256(1)</a> para isso, usado como <code>sha256 <em>imagefilename</em></code>. Outros sistemas operacionais possuem programas semelhantes.</p></div><div class=paragraph><p>Compare o checksum calculado com a mostrado em <span class=filename>CHECKSUM.SHA256</span>. Os checksum devem corresponder exatamente. Se os checksums não corresponderem, o arquivo de imagem está corrompido e deve ser baixado novamente.</p></div><div class=sect4><h5 id=bsdinstall-usb>2.3.1.1. Gravando um arquivo de imagem para um pendrive USB<a class=anchor href=#bsdinstall-usb></a></h5><div class=paragraph><p>O arquivo <span class=filename>*. Img</span> é uma <em>imagem</em> do conteúdo completo de um cartão de memória. Ele <em>não pode</em> ser copiado para o dispositivo de destino como um arquivo. Várias aplicações estão disponíveis para escrever o <span class=filename>*. Img</span> para um pendrive USB. Esta seção descreve dois destes utilitários.</p></div><div class="admonitionblock important"><table><tbody><tr><td class=icon><i class="fa icon-important" title=Important></i></td><td class=content><div class=paragraph><p>Antes de continuar, faça backup de todos os dados importantes do pendrive USB. Este procedimento irá apagar todos os dados existentes no mesmo.</p></div></td></tr></tbody></table></div><div id=bsdinstall-usb-dd class="exampleblock procedure"><div class=content><div class=paragraph><p><strong>Procedure: Usando o <code>dd</code> para gravar a imagem</strong></p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Este exemplo usa <span class=filename>/dev/da0</span> como o dispositivo de destino em que a imagem será gravada. Seja <em>muito cuidadoso</em> para que o dispositivo correto seja usado, pois esse comando destruirá os dados existentes no dispositivo de destino especificado.</p></div></td></tr></tbody></table></div><div class="olist arabic"><ol class=arabic><li><p>O utilitário de linha de comando <a href="https://man.freebsd.org/cgi/man.cgi?query=dd&amp;sektion=1&amp;format=html">dd(1)</a> está disponível no BSD, no Linux™ e no Mac OS™. Para gravar a imagem usando o <code>dd</code>, insira o pendrive USB e determine o nome do dispositivo. Em seguida, especifique o nome do arquivo de instalação baixado e o nome do dispositivo para o pendrive USB. Este exemplo grava a imagem de instalação amd64 no primeiro dispositivo USB em um sistema FreeBSD existente.</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dd if=FreeBSD-12.1-RELEASE-amd64-memstick.img of=/dev/da0 bs=1M conv=sync</span></code></pre></div></div><div class=paragraph><p>Se este comando falhar, verifique se o pendrive USB não está montado e se o nome do dispositivo aponta para o disco, não para uma partição. Alguns sistemas operacionais podem requerer que este comando seja executado com o <a href="https://man.freebsd.org/cgi/man.cgi?query=sudo&amp;sektion=8&amp;format=html">sudo(8)</a>. A sintaxe do <a href="https://man.freebsd.org/cgi/man.cgi?query=dd&amp;sektion=1&amp;format=html">dd(1)</a> varia ligeiramente em diferentes plataformas; por exemplo, o Mac OS™ requer um <code>bs=1m</code> em minúsculas. Sistemas como o Linux™ podem gravar em buffer. Para forçar todas as gravações a serem concluídas, use o comando <a href="https://man.freebsd.org/cgi/man.cgi?query=sync&amp;sektion=8&amp;format=html">sync(8)</a>.</p></div></li></ol></div></div></div><div class="exampleblock procedure"><div class=content><div class=paragraph><p><strong>Procedure: Usando o Windows™ para gravar a imagem</strong></p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Certifique-se de fornecer a letra da unidade correta, pois os dados existentes na unidade especificada serão sobrescritos e destruídos.</p></div></td></tr></tbody></table></div><div class="olist arabic"><ol class=arabic><li><p>Obtendo o Image Writer para Windows™</p><div class=paragraph><p>O Image Writer para Windows™ é um aplicativo gratuito que pode gravar corretamente um arquivo de imagem em um cartão de memória. Faça o download a partir de <a href=https://sourceforge.net/projects/win32diskimager/>https://sourceforge.net/projects/win32diskimager/</a> e extraia-o em uma pasta.</p></div></li><li><p>Escrevendo a imagem com o Image Writer</p><div class=paragraph><p>Clique duas vezes no ícone Win32DiskImager para iniciar o programa. Verifique se a letra da unidade mostrada em <code>Device</code> é a unidade com o cartão de memória. Clique no ícone da pasta e selecione a imagem a ser gravada no cartão de memória. Clique em <b class=button>Save</b> para aceitar o nome do arquivo de imagem. Verifique se tudo está correto e se nenhuma pasta do cartão de memória está aberta em outras janelas. Quando tudo estiver pronto, clique em <b class=button>Write</b> para gravar o arquivo de imagem no cartão de memória.</p></div></li></ol></div></div></div><div class=paragraph><p>Agora você está pronto para começar a instalar o FreeBSD.</p></div></div></div></div><div class=sect2><h3 id=bsdinstall-start>2.4. Iniciando a instalação<a class=anchor href=#bsdinstall-start></a></h3><div class="admonitionblock important"><table><tbody><tr><td class=icon><i class="fa icon-important" title=Important></i></td><td class=content><div class=paragraph><p>Por padrão, a instalação não fará alterações no(s) disco(s) antes da seguinte mensagem:</p></div><div class="literalblock programlisting"><div class=content><pre>Your changes will now be written to disk. If you
have chosen to overwrite existing data, it will
be PERMANENTLY ERASED. Are you sure you want to
commit your changes?</pre></div></div><div class=paragraph><p>A instalação pode ser encerrada a qualquer momento antes deste aviso. Se houver uma preocupação de que algo esteja configurado incorretamente, basta desligar o computador antes desse ponto e nenhuma alteração será feita nos discos do sistema.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Esta seção descreve como inicializar o sistema a partir da mídia de instalação que foi preparada usando as instruções em <a href=#bsdinstall-installation-media>Prepare a mídia de instalação</a>. Ao usar um dispositivo USB inicializável, conecte o dispositivo USB antes de ligar o computador. Ao inicializar a partir do CD ou do DVD, ligue o computador e insira a mídia na primeira oportunidade. O procedimento para configurar o sistema para inicializar a partir da mídia inserida depende da arquitetura.</p></div><div class=sect3><h4 id=bsdinstall-starting-i386>2.4.1. Inicializando em i386™ e amd64<a class=anchor href=#bsdinstall-starting-i386></a></h4><div class=paragraph><p>Estas arquiteturas fornecem um menu BIOS para selecionar o dispositivo de inicialização. Dependendo da mídia de instalação usada, selecione o dispositivo de CD/DVD ou o USB como o primeiro dispositivo de inicialização. A maioria dos sistemas também fornece uma chave para selecionar o dispositivo durante a inicialização sem ter que entrar no BIOS. Normalmente, a chave é <kbd>F10</kbd>, <kbd>F11</kbd>, <kbd>F12</kbd> ou <kbd>Escape</kbd>.</p></div><div class=paragraph><p>Se o computador carregar o sistema operacional existente em vez do instalador do FreeBSD, então:</p></div><div class="olist arabic"><ol class=arabic><li><p>A mídia de instalação não foi inserida cedo o suficiente no processo de inicialização. Deixe a mídia inserida e tente reiniciar o computador.</p></li><li><p>As alterações do BIOS estavam incorretas ou não foram salvas. Verifique novamente se o dispositivo de inicialização correto está selecionado como o primeiro dispositivo de inicialização.</p></li><li><p>Este sistema é muito antigo para suportar a inicialização a partir da mídia escolhida. Neste caso, o Plop Boot Manager (<a href=http://www.plop.at/en/bootmanagers.html class=bare>http://www.plop.at/en/bootmanagers.html</a>) pode ser usado para inicializar o sistema a partir da mídia selecionada.</p></li></ol></div></div><div class=sect3><h4 id=_inicializando_no_powerpc>2.4.2. Inicializando no PowerPC™<a class=anchor href=#_inicializando_no_powerpc></a></h4><div class=paragraph><p>Na maioria das máquinas, manter pressionado o <kbd>C</kbd> no teclado durante a inicialização irá inicializar a partir do CD. Caso contrário, mantenha pressionados <span class=keyseq><kbd>Command</kbd>+<kbd>Option</kbd>+<kbd>O</kbd>+<kbd>F</kbd></span>, ou <span class=keyseq><kbd>Windows</kbd>+<kbd>Alt</kbd>+<kbd>O</kbd>+<kbd>F</kbd></span> em teclados não-Apple™. No prompt <code>0 ></code>, digite</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> boot <span class=nb>cd</span>:,<span class=se>\p</span>pc<span class=se>\l</span>oader <span class=nb>cd</span>:0</code></pre></div></div></div><div class=sect3><h4 id=bsdinstall-view-probe>2.4.3. Menu de inicialização do FreeBSD<a class=anchor href=#bsdinstall-view-probe></a></h4><div class=paragraph><p>Quando o sistema inicializar a partir da mídia de instalação, um menu semelhante ao seguinte será exibido:</p></div><div id=bsdinstall-newboot-loader-menu class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-newboot-loader-menu.png alt="bsdinstall newboot loader menu"></div><div class=title>Figura 1. Menu do FreeBSD Boot Loader</div></div><div class=paragraph><p>Por padrão, o menu irá esperar dez segundos por uma ação do usuário antes de inicializar no instalador do FreeBSD ou, se o FreeBSD já estiver instalado, antes de inicializar no FreeBSD. Para pausar o cronômetro de inicialização para rever as seleções, pressione <kbd>Espaço</kbd>. Para selecionar uma opção, pressione seu número, caractere ou tecla destacada. As seguintes opções estão disponíveis.</p></div><div class=ulist><ul><li><p><code>Boot Multi User</code>: Isto irá continuar o processo de inicialização do FreeBSD. Se o temporizador de boot tiver sido pausado, pressione <kbd>1</kbd>, <kbd>B</kbd> maiúsculo ou minúsculo ou <kbd>Enter</kbd>.</p></li><li><p><code>Boot Single User</code>: Este modo pode ser usado para corrigir uma instalação existente do FreeBSD como descrito em <a href=./#boot-singleuser>Modo Single-User</a>. Pressione <kbd>2</kbd> ou <kbd>S</kbd> maiúsculo ou minúsculo para entrar neste modo.</p></li><li><p><code>Escape to loader prompt</code>: Isso inicializará o sistema em um prompt de reparo que contém um número limitado de comandos de baixo nível. Este prompt é descrito em <a href=./#boot-loader>Estágio três</a>. Pressione <kbd>3</kbd> ou <kbd>Esc</kbd> para inicializar neste prompt.</p></li><li><p><code>Reboot</code>: Reinicia o sistema.</p></li><li><p><code>Kernel</code>: Carrega um kernel diferente.</p></li><li><p><code>Configure Boot Options</code>: Abre o menu mostrado e descrito em <a href=#bsdinstall-boot-options-menu>Menu de Opções de Inicialização do FreeBSD</a>.</p></li></ul></div><div id=bsdinstall-boot-options-menu class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-boot-options-menu.png alt="bsdinstall boot options menu"></div><div class=title>Figura 2. Menu de Opções de Inicialização do FreeBSD</div></div><div class=paragraph><p>O menu de opções de inicialização é dividido em duas seções. A primeira seção pode ser usada para retornar ao menu de inicialização principal ou para redefinir quaisquer opções que tenham sido alteradas de volta para seus valores padrões.</p></div><div class=paragraph><p>A próxima seção é usada para alternar as opções disponíveis para <code>On</code> ou <code>Off</code> pressionando o número ou caractere realçado da opção. O sistema sempre inicializará usando as configurações dessas opções até serem modificadas. Várias opções podem ser alternadas usando este menu:</p></div><div class=ulist><ul><li><p><code>ACPI Support</code>: Se o sistema travar durante a inicialização, tente alternar essa opção para <code>Off</code>.</p></li><li><p><code>Safe Mode</code>: Se o sistema ainda travar durante a inicialização, mesmo com <code>Suporte a ACPI</code> definido como <code>Off</code>, tente definir esta opção como <code>On</code>.</p></li><li><p><code>Single User</code>: Alterne esta opção para <code>On</code> para corrigir uma instalação existente do FreeBSD como descrito em <a href=./#boot-singleuser>Modo Single-User</a>. Depois que o problema for corrigido, configure-o de volta para <code>Off</code>.</p></li><li><p><code>Verbose</code>: Alterne esta opção para <code>On</code> para ver mensagens mais detalhadas durante o processo de inicialização. Isso pode ser útil ao solucionar problemas de hardware.</p></li></ul></div><div class=paragraph><p>Depois de fazer as seleções necessárias, pressione <kbd>1</kbd> ou <kbd>Backspace</kbd> para retornar ao menu de boot principal, então pressione <kbd>Enter</kbd> para continuar a inicialização no FreeBSD. Uma série de mensagens de inicialização irão aparecer enquanto o FreeBSD executa seus testes de dispositivos de hardware e carrega o programa de instalação. Quando a inicialização estiver concluída, o menu de boas-vindas mostrado em <a href=#bsdinstall-choose-mode>Menu de boas-vindas</a> será exibido.</p></div><div id=bsdinstall-choose-mode class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-choose-mode.png alt="bsdinstall choose mode"></div><div class=title>Figura 3. Menu de boas-vindas</div></div><div class=paragraph><p>Pressione <kbd>Enter</kbd> para selecionar o padrão de <b class=button>Install</b> para entrar no instalador. O restante deste capítulo descreve como usar este instalador. Caso contrário, use as setas para a direita ou para a esquerda ou a letra colorida para selecionar o item de menu desejado. A opção <b class=button>Shell</b> pode ser usada para acessar um shell do FreeBSD, a fim de usar utilitários de linha de comando para preparar os discos antes da instalação. A opção <b class=button>Live CD</b> pode ser usada para testar o FreeBSD antes de instalá-lo. A versão live é descrita em <a href=#using-live-cd>Usando o Live CD</a>.</p></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Para revisar as mensagens de inicialização, incluindo o probe do dispositivo de hardware, pressione a tecla <kbd>S</kbd> maiúscula ou minúscula e, em seguida, <kbd>Enter</kbd> para acessar um shell. No prompt do shell, digite <code>more /var/run/dmesg.boot</code> e use a barra de espaço para rolar pelas mensagens. Quando terminar, digite <code>exit</code> para retornar ao menu de boas-vindas.</p></div></td></tr></tbody></table></div></div></div><div class=sect2><h3 id=using-bsdinstall>2.5. Usando o bsdinstall<a class=anchor href=#using-bsdinstall></a></h3><div class=paragraph><p>Esta seção mostra a ordem dos menus do bsdinstall e o tipo de informação que será solicitada antes que o sistema seja instalado. Use as teclas de seta para realçar uma opção de menu e, em seguida, a barra de <kbd>Espaço</kbd> para selecionar ou desmarcar esse item de menu. Quando terminar, pressione <kbd>Enter</kbd> para salvar a seleção e passar para a próxima tela.</p></div><div class=sect3><h4 id=bsdinstall-keymap>2.5.1. Selecionando o menu do Keymap (Mapa de teclas)<a class=anchor href=#bsdinstall-keymap></a></h4><div class=paragraph><p>Antes de iniciar o processo, o bsdinstall carregará os arquivos de keymap como mostrado em <a href=#bsdinstall-keymap-loading>Carregamento de Keymap</a>.</p></div><div id=bsdinstall-keymap-loading class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-keymap-loading.png alt="bsdinstall keymap loading"></div><div class=title>Figura 4. Carregamento de Keymap</div></div><div class=paragraph><p>Após o carregamento dos keymaps, o bsdinstall exibe o menu mostrado em <a href=#bsdinstall-keymap-10>Menu de Seleção do Keymap</a>. Use as setas para cima e para baixo para selecionar o mapa de teclas que mais representa o mapeamento do teclado conectado ao sistema. Pressione <kbd>Enter</kbd> para salvar a seleção.</p></div><div id=bsdinstall-keymap-10 class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-keymap-10.png alt="bsdinstall keymap 10"></div><div class=title>Figura 5. Menu de Seleção do Keymap</div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Pressionar <kbd>Esc</kbd> sairá deste menu e usará o mapa de teclas padrão. Se a escolha do mapa de teclado não for clara, a opção <span class=guimenuitem>United States of America ISO-8859-1</span> é uma opção segura.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Além disso, ao selecionar um keymap diferente, o usuário pode testar o keymap e garantir que esteja correto antes de continuar, conforme mostrado em <a href=#bsdinstall-keymap-testing>Menu de Teste do Keymap</a>.</p></div><div id=bsdinstall-keymap-testing class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-keymap-testing.png alt="bsdinstall keymap testing"></div><div class=title>Figura 6. Menu de Teste do Keymap</div></div></div><div class=sect3><h4 id=bsdinstall-hostname>2.5.2. Configurando o nome do host<a class=anchor href=#bsdinstall-hostname></a></h4><div class=paragraph><p>O próximo menu do bsdinstall é usado para definir o nome do host para o sistema recém-instalado.</p></div><div id=bsdinstall-config-hostname class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-config-hostname.png alt="bsdinstall config hostname"></div><div class=title>Figura 7. Configurando o nome do host</div></div><div class=paragraph><p>Digite um nome de host exclusivo para a rede. Ele deve ser um nome de host totalmente qualificado, como <code>machine3.example.com</code>.</p></div></div><div class=sect3><h4 id=bsdinstall-components>2.5.3. Selecionando Componentes para Instalar<a class=anchor href=#bsdinstall-components></a></h4><div class=paragraph><p>Em seguida, o bsdinstall solicitará a seleção de componentes opcionais para instalação.</p></div><div id=bsdinstall-config-components class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-config-components.png alt="bsdinstall config components"></div><div class=title>Figura 8. Selecionando Componentes para Instalar</div></div><div class=paragraph><p>Decidir quais componentes instalar dependerá em grande parte do uso pretendido para o sistema e da quantidade de espaço em disco disponível. O kernel do FreeBSD e o userland, coletivamente conhecidos como o <em>sistema base</em>, são sempre instalados. Dependendo da arquitetura, alguns desses componentes podem não aparecer:</p></div><div class=ulist><ul><li><p><code>base-dbg</code> - Ferramentas básicas como cat, ls entre outras com símbolos de depuração ativados.</p></li><li><p><code>kernel-dbg</code> - Kernel e módulos com símbolos de depuração ativados.</p></li><li><p><code>lib32-dbg</code> - Bibliotecas de compatibilidade para executar aplicativos de 32 bits em uma versão de 64 bits do FreeBSD com símbolos de depuração ativados.</p></li><li><p><code>lib32</code> - Bibliotecas de compatibilidade para executar aplicativos de 32 bits em uma versão de 64 bits do FreeBSD.</p></li><li><p><code>ports</code> - A Coleção de Ports do FreeBSD é uma coleção de arquivos que automatiza o download, a compilação e a instalação de pacotes de software de terceiros. <a href=./#ports>Instalando Aplicativos: Pacotes e Ports</a> discute como usar a coleção de ports.</p><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>O programa de instalação não verifica o espaço em disco adequado. Selecione esta opção apenas se houver espaço suficiente no disco rígido. A Coleção de Ports do FreeBSD ocupa cerca de 500 MB de espaço em disco.</p></div></td></tr></tbody></table></div></li><li><p><code>src</code> - O código-fonte completo do FreeBSD para o kernel e para o userland. Embora não seja necessário para a maioria dos aplicativos, pode ser necessário para compilar drivers de dispositivo, módulos do kernel ou alguns aplicativos da Coleção de Ports. Ele também é usado para desenvolver o próprio FreeBSD. A árvore de código-fonte completa requer 1 GB de espaço em disco e a recompilação de todo o sistema FreeBSD requer 5 GB adicionais de espaço.</p></li><li><p><code>tests</code> - FreeBSD Test Suite.</p></li></ul></div></div><div class=sect3><h4 id=bsdinstall-netinstall>2.5.4. Instalando a partir da rede<a class=anchor href=#bsdinstall-netinstall></a></h4><div class=paragraph><p>O menu mostrado em <a href=#bsdinstall-netinstall-notify>Instalando a partir da rede</a> apenas aparece ao instalar a partir de um <span class=filename>-bootonly.iso</span> ou <span class=filename>-mini-memstick.img</span> pois esta mídia de instalação não possui cópias dos arquivos de instalação. Como os arquivos de instalação devem ser recuperados através de uma conexão de rede, esse menu indica que a interface de rede deve ser configurada primeiro. Se o menu é exibido em qualquer etapa do processo lembre-se de seguir as instruções em <a href=#bsdinstall-config-network-dev>Configurando as Interfaces de Rede</a>.</p></div><div id=bsdinstall-netinstall-notify class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-netinstall-files.png alt="bsdinstall netinstall files"></div><div class=title>Figura 9. Instalando a partir da rede</div></div></div></div><div class=sect2><h3 id=bsdinstall-partitioning>2.6. Alocando o espaço em disco<a class=anchor href=#bsdinstall-partitioning></a></h3><div class=paragraph><p>O próximo menu é usado para determinar o método de alocação de espaço em disco. As opções disponíveis no menu dependem da versão do FreeBSD sendo instalada.</p></div><div id=bsdinstall-zfs-partmenu class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-zfs-partmenu.png alt="bsdinstall zfs partmenu"></div><div class=title>Figura 10. Opções de Particionamento</div></div><div class=paragraph><p>bsdinstall fornece ao usuário quatro métodos para alocar espaço em disco:</p></div><div class=ulist><ul><li><p>O particionamento <code>Auto (UFS)</code> configura automaticamente as partições do disco usando o sistema de arquivos <code>UFS</code>.</p></li><li><p>O particionamento <code>Manual</code> permite que usuários avançados criem partições personalizadas a partir das opções de menu.</p></li><li><p><code>Shell</code> abre um prompt de shell no qual usuários avançados podem criar partições personalizadas usando utilitários de linha de comando como <a href="https://man.freebsd.org/cgi/man.cgi?query=gpart&amp;sektion=8&amp;format=html">gpart(8)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=fdisk&amp;sektion=8&amp;format=html">fdisk(8)</a>, e <a href="https://man.freebsd.org/cgi/man.cgi?query=bsdlabel&amp;sektion=8&amp;format=html">bsdlabel(8)</a>.</p></li><li><p>O particionamento <code>Auto (ZFS)</code> cria um sistema root-on-ZFS com suporte opcional à criptografia GELI para <em>boot environments</em>.</p></li></ul></div><div class=paragraph><p>Esta seção descreve o que considerar ao definir as partições de disco. Em seguida, demonstra como usar os diferentes métodos de particionamento.</p></div><div class=sect3><h4 id=configtuning-initial>2.6.1. Criando o layout da partição<a class=anchor href=#configtuning-initial></a></h4><div class=paragraph><p>Ao criar os sistemas de arquivos, lembre-se de que os discos rígidos transferem dados mais rapidamente das trilhas externas para as internas. Assim, sistemas de arquivos menores e mais acessados devem estar mais próximos da parte externa da unidade, enquanto partições maiores, como <span class=filename>/usr</span>, devem ser colocadas em direção às partes internas do disco. É uma boa idéia criar partições em uma ordem similar a: <span class=filename>/</span>, swap, <span class=filename>/var</span> e <span class=filename>/usr</span>.</p></div><div class=paragraph><p>O tamanho da partição <span class=filename>/var</span> reflete o uso pretendido para a máquina. Esta partição é usada para armazenar caixas de correio, arquivos de log e spools de impressora. Caixas de correio e arquivos de log podem crescer até tamanhos inesperados, dependendo do número de usuários e de quanto tempo os arquivos de log são mantidos. Na média, a maioria dos usuários raramente precisa de mais do que cerca de um gigabyte de espaço livre em disco no <span class=filename>/var</span>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Às vezes, é necessário muito espaço em disco no <span class=filename>/var/tmp</span>. Quando um novo software é instalado, as ferramentas de empacotamento extraem uma cópia temporária dos pacotes no <span class=filename>/var/tmp</span>. Grandes pacotes de software, como o Firefox ou LibreOffice podem ser difíceis de instalar se não houver espaço em disco suficiente no <span class=filename>/var/tmp</span>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>A partição <span class=filename>/usr</span> contém muitos dos arquivos que suportam o sistema, incluindo o a Coleção de Ports do FreeBSD e o código-fonte do sistema. Pelo menos 2 gigabytes de espaço são recomendados para esta partição.</p></div><div class=paragraph><p>Ao selecionar os tamanhos das partições, lembre-se dos requisitos de espaço. Ficar sem espaço em uma partição enquanto mal usa outra pode ser um aborrecimento.</p></div><div class=paragraph><p>Como regra geral, a partição swap deve ter o dobro do tamanho da memória física (RAM). Sistemas com pouca memória RAM podem ter um melhor desempenho com mais swap. Configurar um swap pequeno pode levar a ineficiências no código de verificação de página da VM e pode criar problemas mais tarde, se mais memória for adicionada.</p></div><div class=paragraph><p>Em sistemas maiores com vários discos SCSI ou vários discos IDE operando em diferentes controladoras, é recomendável que uma area de swap seja configurada em cada unidade, até quatro unidades. As partições de swap devem ter aproximadamente o mesmo tamanho. O kernel pode manipular tamanhos arbitrários, mas as estruturas internas de dados podem ser dimensionadas para 4 vezes a maior partição de swap. Manter as partições de swap próximas do mesmo tamanho permitirá que o kernel otimize o espaço de swap entre discos. Partições grandes de swap são uma coisa boa, mesmo se o swap não for muito usado. Pode ser mais fácil de se recuperar de um programa devorador de memória antes de ser forçado a reinicializar.</p></div><div class=paragraph><p>Ao particionar adequadamente um sistema, a fragmentação introduzida nas partições menores e intensas em gravação não vai prejudicar as partições que são maioritariamente de leitura. Manter as partições com maior carga de gravação mais próximas da borda do disco aumentará o desempenho de I/O nas partições onde ela é mais necessária. Embora o desempenho de I/O nas partições maiores possa ser necessário, mudá-las mais para a borda do disco não levará a uma melhoria de desempenho significativa em relação à movimentação de <span class=filename>/var</span> para a borda.</p></div></div><div class=sect3><h4 id=bsdinstall-part-guided>2.6.2. Particionamento Guiado Usando UFS<a class=anchor href=#bsdinstall-part-guided></a></h4><div class=paragraph><p>Quando este método é selecionado, um menu exibirá o(s) disco(s) disponível(s). Se vários discos estiverem conectados, escolha aquele em que o FreeBSD deve ser instalado.</p></div><div id=bsdinstall-part-guided-disk class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-part-guided-disk.png alt="bsdinstall part guided disk"></div><div class=title>Figura 11. Selecionando a partir de vários discos</div></div><div class=paragraph><p>Depois que o disco é selecionado, o próximo menu solicita a instalação no disco inteiro ou a criação de uma partição usando o espaço livre. Se <b class=button>Entire Disk</b> for escolhido, um layout de partição geral que preenche todo o disco é criado automaticamente. Selecionar <b class=button>Partition</b> cria um layout de partição do espaço não utilizado no disco.</p></div><div id=bsdinstall-part-entire-part class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-part-entire-part.png alt="bsdinstall part entire part"></div><div class=title>Figura 12. Selecionando todo o disco ou partição</div></div><div class=paragraph><p>Após <b class=button> Entire Disk </b> ser escolhido, bsdinstall exibe uma caixa de diálogo indicando que o disco será apagado.</p></div><div id=bsdinstall-ufs-warning class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-ufs-warning.png alt="bsdinstall ufs warning"></div><div class=title>Figura 13. Confirmação</div></div><div class=paragraph><p>O próximo menu mostra uma lista com os tipos de esquema de partição. O GPT é geralmente a opção mais apropriada para computadores amd64. Computadores mais antigos que não são compatíveis com o GPT devem usar o MBR. Os outros esquemas de partição são geralmente usados para computadores incomuns ou antigos. Mais informações estão disponíveis em <a href=#partition-schemes>Esquemas de Particionamento</a>.</p></div><div id=bsdinstall-ufs-scheme class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-part-manual-partscheme.png alt="bsdinstall part manual partscheme"></div><div class=title>Figura 14. Selecionar Esquema de Particionamento</div></div><div class=paragraph><p>Depois que o layout da partição tiver sido criado, revise-o para garantir que ele atenda às necessidades da instalação. Selecionar <b class=button>Revert</b> redefinirá as partições para seus valores originais e pressionar <b class=button>Auto</b> recriará as partições automáticas do FreeBSD. As partições também podem ser criadas, modificadas ou excluídas manualmente. Quando o particionamento estiver correto, selecione <b class=button>Finish</b> para continuar com a instalação.</p></div><div id=bsdinstall-part-review class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-part-review.png alt="bsdinstall part review"></div><div class=title>Figura 15. Revise as partições criadas</div></div><div class=paragraph><p>Depois que os discos são configurados, o próximo menu fornece a última chance de fazer alterações antes que os discos selecionados sejam formatados. Se for necessário fazer alterações, selecione <b class=button>Back</b> para retornar ao menu principal de particionamento. <b class=button> Revert & Exit </b> sairá do instalador sem fazer alterações no disco. Selecione <b class=button>Commit</b> para iniciar o processo de instalação.</p></div><div id=bsdinstall-ufs-final-confirmation class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-final-confirmation.png alt="bsdinstall final confirmation"></div><div class=title>Figura 16. Confirmação final</div></div><div class=paragraph><p>Para continuar com o processo de instalação, vá para <a href=#bsdinstall-fetching-distribution>Fazendo o download dos arquivos de distribuição</a>.</p></div></div><div class=sect3><h4 id=bsdinstall-part-manual>2.6.3. Particionamento Manual<a class=anchor href=#bsdinstall-part-manual></a></h4><div class=paragraph><p>Selecionar este método abre o editor de partições:</p></div><div id=bsdinstall-part-manual-create class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-part-manual-create.png alt="bsdinstall part manual create"></div><div class=title>Figura 17. Criar partições manualmente</div></div><div class=paragraph><p>Realce a unidade de instalação (<span class=filename>ada0</span> neste exemplo) e selecione <b class=button>Create</b> para exibir um menu dos esquemas de partição disponíveis:</p></div><div id=bsdinstall-part-manual-partscheme class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-part-manual-partscheme.png alt="bsdinstall part manual partscheme"></div><div class=title>Figura 18. Criar partições manualmente</div></div><div class=paragraph><p>O GPT é geralmente a opção mais apropriada para computadores amd64. Computadores mais antigos que não são compatíveis com o GPT devem usar o MBR. Os outros esquemas de partição são geralmente usados para computadores incomuns ou antigos.</p></div><table id=partition-schemes class="tableblock frame-none grid-all stretch"><caption class=title>Tabela 1. Esquemas de Particionamento</caption><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Abreviação</th><th class="tableblock halign-left valign-top">Descrição</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>APM</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Apple Partition Map, usado no PowerPC™.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>BSD</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>O Label BSD sem um MBR, às vezes chamado de <em>modo perigosamente dedicado</em> porque os utilitários de discos não BSD podem não reconhecê-lo.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>GPT</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Tabela de Partição GUID (<a href=http://en.wikipedia.org/wiki/GUID_Partition_Table> http://en.wikipedia.org/wiki/GUID_Partition_Table </a>).</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>MBR</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Registro mestre de inicialização ou MBR (<a href=http://en.wikipedia.org/wiki/Master_boot_record> http://en.wikipedia.org/wiki/Master_boot_record </a>).</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>VTOC8</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Tabela de Volume do Conteúdo usado pelos computadores Sun SPARC64 e UltraSPARC.</p></td></tr></tbody></table><div class=paragraph><p>Depois que o esquema de particionamento for selecionado e criado, selecione <b class=button>Create</b> novamente para criar as partições.A tecla <kbd>Tab</kbd> é utilizada para navegação entre os campos.</p></div><div id=bsdinstall-part-manual-addpart class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-part-manual-addpart.png alt="bsdinstall part manual addpart"></div><div class=title>Figura 19. Criar partições manualmente</div></div><div class=paragraph><p>Uma instalação padrão do FreeBSD GPT usa pelo menos três partições:</p></div><div class=ulist><ul><li><p><code>freebsd-boot</code> - Mantém o código de inicialização do FreeBSD.</p></li><li><p><code>freebsd-ufs</code> - Um sistema de arquivos UFS do FreeBSD.</p></li><li><p><code>freebsd-zfs</code> - Um sistema de arquivos ZFS do FreeBSD. Mais informações sobre o ZFS estão disponíveis em <a href=./#zfs>O sistema de arquivos Z (ZFS)</a>.</p></li><li><p><code>freebsd-swap</code> - Espaço de swap do FreeBSD.</p></li></ul></div><div class=paragraph><p>Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=gpart&amp;sektion=8&amp;format=html">gpart(8)</a> para obter informações de todos os tipos de partições GPT disponíveis.</p></div><div class=paragraph><p>Várias partições do sistema de arquivos podem ser criadas e algumas pessoas preferem um layout tradicional com partições separadas para <span class=filename>/</span>, <span class=filename>/var</span>, <span class=filename>/tmp</span> e <span class=filename>/usr</span>. Veja <a href=#bsdinstall-part-manual-splitfs>Criando partições tradicionais para um sistema de arquivos dividido</a> para um exemplo.</p></div><div class=paragraph><p>O <code>tamanho</code> pode ser digitado com abreviações comuns: <em>K</em> para kilobytes, <em>M</em> para megabytes, ou <em>G</em> para gigabytes.</p></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>O alinhamento adequado do setor fornece o melhor desempenho, e ao definir os tamanhos das partições em múltiplos de 4K bytes ajuda a garantir o alinhamento em discos com setores de 512 ou 4 bytes. Geralmente, usar tamanhos de partições que são múltiplos de 1M ou 1G é a maneira mais fácil de garantir que cada partição comece em um múltiplo par de 4K. Há uma exceção: a partição <em>freebsd-boot</em> não deve ser maior que 512K devido às limitações atuais do código de inicialização.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Um <code>Mountpoint</code> é necessário se a partição contiver um sistema de arquivos. Se apenas uma única partição UFS for criada, o ponto de montagem deve ser <span class=filename>/</span>.</p></div><div class=paragraph><p>O <code>Label</code> é um nome pelo qual a partição será conhecida. Nomes ou números de unidades podem mudar se a unidade estiver conectada a um controlador ou porta diferente, mas a etiqueta da partição não muda. Referir-se a rótulos em vez de nomes de unidade e números de partição em arquivos como o <span class=filename>/etc/fstab</span> torna o sistema mais tolerante a alterações de hardware. Os rótulos GPT aparecem em <span class=filename>/dev/gpt/</span> quando um disco é anexado. Outros esquemas de particionamento têm diferentes capacidades de rótulos e seus rótulos aparecem em diferentes diretórios no <span class=filename>/dev/</span>.</p></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Use um rótulo único e exclusivo para cada uma das partições para evitar conflitos de rótulos idênticos. Algumas letras do nome, uso ou localização do computador podem ser adicionadas ao rótulo. Por exemplo, use <code>labroot</code> ou <code>rootfslab</code> para a partição raiz UFS no computador chamado <code>lab</code>.</p></div></td></tr></tbody></table></div><div id=bsdinstall-part-manual-splitfs class=exampleblock><div class=title>Exemplo 1. Criando partições tradicionais para um sistema de arquivos dividido</div><div class=content><div class=paragraph><p>Para um layout de partição tradicional em que os diretórios <span class=filename>/</span>, <span class=filename>/var</span>, <span class=filename>/tmp</span> e <span class=filename>/usr</span> são sistemas de arquivos separados em suas próprias partições, crie um esquema de particionamento GPT e crie as partições conforme mostrado. Os tamanhos de partição mostrados são típicos para um disco de destino de 20G. Se houver mais espaço disponível no disco de destino, partições maiores de swap ou <span class=filename>/var</span> podem ser úteis. Os rótulos mostrados aqui são prefixados com <code>ex</code> para "exemplo", mas os leitores devem usar outros valores de rótulo exclusivos, conforme descrito acima.</p></div><div class=paragraph><p>Por padrão, o <span class=filename>gptboot</span> do FreeBSD espera que a primeira partição UFS seja a partição <span class=filename>/</span>.</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:25%><col style=width:25%><col style=width:25%><col style=width:25%><thead><tr><th class="tableblock halign-left valign-top">Tipo de Partição</th><th class="tableblock halign-left valign-top">Tamanho</th><th class="tableblock halign-left valign-top">Ponto de montagem</th><th class="tableblock halign-left valign-top">Rótulo</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>freebsd-boot</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>512K</code></p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>freebsd-ufs</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>2G</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>exrootfs</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>freebsd-swap</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>4G</code></p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>exswap</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>freebsd-ufs</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>2G</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/var</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>exvarfs</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>freebsd-ufs</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>1G</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/tmp</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>extmpfs</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>freebsd-ufs</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>aceite o padrão (restante do disco)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>exusrfs</code></p></td></tr></tbody></table></div></div><div class=paragraph><p>Depois que as partições personalizadas forem criadas, selecione <b class=button>Finish</b> para continuar com a instalação e vá para <a href=#bsdinstall-fetching-distribution>Fazendo o download dos arquivos de distribuição</a>.</p></div></div><div class=sect3><h4 id=bsdinstall-part-zfs>2.6.4. Particionamento Guiado Usando Root-on-ZFS<a class=anchor href=#bsdinstall-part-zfs></a></h4><div class=paragraph><p>Este modo de particionamento funciona apenas com discos inteiros e apagará por completo o conteúdo do disco. O menu de configuração principal do ZFS oferece várias opções para controlar a criação do pool.</p></div><div id=bsdinstall-zfs-menu class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-zfs-menu.png alt="bsdinstall zfs menu"></div><div class=title>Figura 20. Menu de particionamento do ZFS</div></div><div class=paragraph><p>Aqui está um resumo das opções que podem ser usadas neste menu:</p></div><div class=ulist><ul><li><p><code>Instalar</code> - Prosseguir a instalação com as opções selecionadas.</p></li><li><p><code>Tipo de Pool/Discos</code> - Permite configurar o <code>Tipo de Pool</code> e o(s) disco(s ) que irão constituir o pool. Atualmente o instalador ZFS automático suporta apenas a criação de uma única camada superior vdev, exceto em modo stripe. Para criar pools mais complexos, use as instruções em <a href=#bsdinstall-part-shell>Particionamento do modo shell</a> para criar o pool.</p></li><li><p><code>Re-escanear Dispositivos</code> - Re-popular a lista de discos disponíveis.</p></li><li><p><code>Disk Info</code> - Disk Info pode ser usado para inspecionar cada disco, incluindo sua tabela de partição e várias outras informações, como o número do modelo do dispositivo e o número de série, se disponíveis.</p></li><li><p><code>Pool Name</code> - Define o nome do pool. O nome default é <em>zroot</em>.</p></li><li><p><code>Force 4K Sectors?</code> - Forçar o uso de setores em 4K. Por padrão, o instalador irá automaticamente criar partições alinhadas com limites em 4K e forçar o ZFS a usar setores de 4K. Isto é seguro mesmo com discos de setores de 512 bytes, e tem o benefício adicional de garantir que pools criados em discos de 512 bytes conseguirão ter setores de 4K adicionados no futuro, seja como espaço de armazenamento adicional ou como substituição ode discos e falha. Aperte a tecla <kbd>Enter</kbd> para escolher ativar isso ou não.</p></li><li><p><code>Encrypt Disks?</code> - A criptografia dos discos permite ao usuário criptografar os discos usando GELI. Mais informação sobre criptografia de discos está disponível em <a href=#disks-encrypting-geli>Criptografia de Disco com <code>geli</code></a>. Aperte a tecla <kbd>Enter</kbd> para escolher ativá-la ou não.</p></li><li><p><code>Partition Scheme</code> - Permitei escolher o esquema de partição. GPT é a opção recomendada na maioria dos casos. Aperte a tecla <kbd>Enter</kbd> para escolher entre diferentes opções.</p></li><li><p><code>Swap Size</code> - Determina a quantidade de espaço para swap.</p></li><li><p><code>Mirror Swap?</code> - Permite ao usuário espelhar o swap entre os discos. Fique atento, o espelhamento da swap irá quebrar dumps de crash. Pressione a tecla <kbd>Enter</kbd> para ativar ou não.</p></li><li><p><code>Encrypt Swap?</code> - Permite ao usuário criptografar a swap. Criptografa a swap com uma chave temporária toda vez que o sistema inicializa e a descarta na reinicialização. Pressione a tecla <kbd>Enter</kbd> para ativar ou não. Mais informação sobre criptografia de swap em <a href=#swap-encrypting>Criptografando Swap</a>.</p></li></ul></div><div class=paragraph><p>Selecione <kbd>T</kbd> para configurar o <code>Pool Type</code> e o(s) disco(s) que irá constituir o pool.</p></div><div id=bsdinstall-zfs-vdev_type class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-zfs-vdev_type.png alt="bsdinstall zfs vdev type"></div><div class=title>Figura 21. Tipo de pool ZFS</div></div><div class=paragraph><p>Aqui está um resumo dos <code>Pool Type</code> que podem ser selecionados neste menu:</p></div><div class=ulist><ul><li><p><code>stripe</code> - Striping provê a capacidade máxima de todos os dispositivos conectados, mas não redundância. Se um disco falhar os dados do pool estarão perdidos de forma irrevogável.</p></li><li><p><code>mirror</code> - O espelhamento armazena uma completa cópia de todos os dados em todos os discos. O espelhamento provê uma boa performance em leitura porque os dados são lidos the todos os discos em paralelo. A performance da escrita é mais lenta pois os dados precisam ser escritos em todos os discos do pool. Torna possível que haja falha nos discos, menos um. Esta opção requer ao menos dois discos.</p></li><li><p><code>raid10</code> - Striped mirrors. Provê a melhor performance, mas o menor armazenamento. Esta opção necessita de um número par de discos e no mínimo quatro discos.</p></li><li><p><code>raidz1</code> - RAID Único Redundante. Permite que haja falha concorrente de um disco. Esta opção necessita de ao menos três discos.</p></li><li><p><code>raidz2</code> - RAID Duplo Redundante. Permite que até dois discos falhem concorrentemente. Esta opção necessita de ao menos quatro discos.</p></li><li><p><code>raidz3</code> - RAID Triplo Redundante. Permite que até três discos falhem concorrentemente. Esta opção necessita de ao menos cinco discos.</p></li></ul></div><div class=paragraph><p>Quando um <code>Pool Type</code> for selecionado, uma lista de discos disponíveis será exibida, e o usuário é solicitado a selecionar um ou mais discos para compor o pool. A configuração é então validada, para garantir que discos suficientes sejam selecionados. Caso contrário, selecione <b class=button>&lt;Change Selection></b> para retornar à lista de discos ou <b class=button>&lt;Backgt></b> para alterar o <code>Pool Type</code></p></div><div id=bsdinstall-zfs-disk_select class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-zfs-disk_select.png alt="bsdinstall zfs disk select"></div><div class=title>Figura 22. Seleção de disco</div></div><div id=bsdinstall-zfs-vdev_invalid class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-zfs-vdev_invalid.png alt="bsdinstall zfs vdev invalid"></div><div class=title>Figura 23. Seleção inválida</div></div><div class=paragraph><p>Se um ou mais discos estiverem faltando na lista, ou se os discos foram anexados depois que o instalador foi iniciado, selecione <b class=button>- Rescan Devices</b> para preencher novamente a lista de discos disponíveis.</p></div><div id=bsdinstall-zfs-rescan-devices class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-zfs-rescan-devices.png alt="bsdinstall zfs rescan devices"></div><div class=title>Figura 24. Dispositivos de Reescaneamento</div></div><div class=paragraph><p>Para evitar apagar acidentalmente o disco errado, o menu <b class=button>- Disk Info</b> pode ser usado para inspecionar cada disco, incluindo sua tabela de partição e várias outras informações, como o número do modelo do dispositivo e o número de série, se disponíveis.</p></div><div id=bsdinstall-zfs-disk_info class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-zfs-disk_info.png alt="bsdinstall zfs disk info"></div><div class=title>Figura 25. Analisando um disco</div></div><div class=paragraph><p>Selecione <kbd>N</kbd> para configurar o <code>Pool Name</code>. Entre com o nome desejado e então selecione <b class=button>&lt;OK></b> para confirmar ou <b class=button>&lt;Cancel></b> para retornar ao menu principal e deixar o nome padrão.</p></div><div id=bsdinstall-zfs-pool-name class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-zfs-pool-name.png alt="bsdinstall zfs pool name"></div><div class=title>Figura 26. Nome do Pool</div></div><div class=paragraph><p>Selecione <kbd>S</kbd> para escolher a quantidade de swap. Entre com a quantidade desejada e então selecione <b class=button>&lt;OK></b> para confirmar isto ou <b class=button>&lt;Cancel></b> para retornar ao menu principal e deixar a quantidade padrão.</p></div><div id=bsdinstall-zfs-swap-amount class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-zfs-swap-amount.png alt="bsdinstall zfs swap amount"></div><div class=title>Figura 27. Quantidade de Swap</div></div><div class=paragraph><p>Uma vez que todas opções estejam setadas com os valores desejados, selecione a opção <b class=button>>>> Install</b> no topo do menu. O instalador oferece uma última chance de cancelar antes que o conteúdo das unidades selecionadas seja destruído para criar o pool do ZFS.</p></div><div id=bsdinstall-zfs-warning class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-zfs-warning.png alt="bsdinstall zfs warning"></div><div class=title>Figura 28. Última chance</div></div><div class=paragraph><p>Se a criptografia de disco GELI foi ativada, o instalador solicitará duas vezes que a frase secreta seja usada para criptografar os discos. E depois dissoa inicialização da criptografia é iniciado.</p></div><div id=bsdinstall-zfs-geli_password class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-zfs-geli_password.png alt="bsdinstall zfs geli password"></div><div class=title>Figura 29. Senha de criptografia de disco</div></div><div id=bsdinstall-zfs-init-encription class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-zfs-init-encription.png alt="bsdinstall zfs init encription"></div><div class=title>Figura 30. inicializando Criptografia</div></div><div class=paragraph><p>A instalação então prossegue normalmente. Para continuar com a instalação, vá para <a href=#bsdinstall-fetching-distribution>Fazendo o download dos arquivos de distribuição</a>.</p></div></div><div class=sect3><h4 id=bsdinstall-part-shell>2.6.5. Particionamento do modo shell<a class=anchor href=#bsdinstall-part-shell></a></h4><div class=paragraph><p>Ao criar instalações avançadas, os menus de particionamento do bsdinstall podem não fornecer o nível de flexibilidade necessário. Usuários avançados podem selecionar a opção <b class=button>Shell</b> no menu de particionamento para particionar manualmente as unidades, criar o(s) sistema(s) de arquivos, preencher o <span class=filename>/tmp/bsdinstall_etc/fstab</span> e montar os sistemas de arquivos em <span class=filename>/mnt</span>. Feito isso, digite <code>exit</code> para retornar ao bsdinstall e continue com a instalação.</p></div></div></div><div class=sect2><h3 id=bsdinstall-fetching-distribution>2.7. Fazendo o download dos arquivos de distribuição<a class=anchor href=#bsdinstall-fetching-distribution></a></h3><div class=paragraph><p>O tempo de instalação irá variar dependendo das distribuições escolhidas, mídia de instalação e velocidade do computador. Uma série de mensagens indicará o progresso.</p></div><div class=paragraph><p>Primeiro, o instalador formata o(s) disco(s) selecionado(s) e inicializa as partições. Em seguida, no caso de uma <code>bootonly media</code> ou <code>mini memstick</code>, ele faz o download dos componentes selecionados:</p></div><div id=bsdinstall-distfile-fetching class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-distfile-fetching.png alt="bsdinstall distfile fetching"></div><div class=title>Figura 31. Fazendo o download dos arquivos de distribuição</div></div><div class=paragraph><p>Em seguida, a integridade dos arquivos de distribuição é verificada para garantir que eles não tenham sido corrompidos durante o download ou mal interpretados da mídia de instalação:</p></div><div id=bsdinstall-distfile-verify class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-distfile-verifying.png alt="bsdinstall distfile verifying"></div><div class=title>Figura 32. Verificando arquivos de distribuição</div></div><div class=paragraph><p>Finalmente, os arquivos de distribuição verificados são extraídos para o disco:</p></div><div id=bsdinstall-distfile-extract class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-distfile-extracting.png alt="bsdinstall distfile extracting"></div><div class=title>Figura 33. Extraindo arquivos de distribuição</div></div><div class=paragraph><p>Depois que todos os arquivos de distribuição solicitados tiverem sido extraídos, o bsdinstall exibirá a primeira tela de configuração pós-instalação. As opções de configuração pós-instalação disponíveis estão descritas na próxima seção.</p></div></div><div class=sect2><h3 id=bsdinstall-post>2.8. Contas, Time Zone, Serviços e Hardening<a class=anchor href=#bsdinstall-post></a></h3><div class=sect3><h4 id=bsdinstall-post-root>2.8.1. Definindo a Senha de <code>root</code><a class=anchor href=#bsdinstall-post-root></a></h4><div class=paragraph><p>Primeiro, a senha do <code>root</code> deve ser definida. Ao digitar a senha, os caracteres digitados não são exibidos na tela. Depois que a senha for digitada, ela deve ser digitada novamente. Isso ajuda a evitar erros de digitação.</p></div><div id=bsdinstall-post-set-root-passwd class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-post-root-passwd.png alt="bsdinstall post root passwd"></div><div class=title>Figura 34. Definindo a Senha de <code>root</code></div></div></div><div class=sect3><h4 id=bsdinstall-timezone>2.8.2. Defina o fuso horário<a class=anchor href=#bsdinstall-timezone></a></h4><div class=paragraph><p>A próxima série de menus é usada para determinar a hora local correta, selecionando a região geográfica, o país e o fuso horário. Definir o fuso horário permite que o sistema corrija automaticamente as alterações de horário regionais, como horário de verão, e execute outras funções relacionadas ao fuso horário corretamente.</p></div><div class=paragraph><p>O exemplo mostrado aqui é para uma máquina localizada no fuso horário do continente da Espanha, Europa. As seleções variam de acordo com a localização geográfica.</p></div><div id=bsdinstall-timezone-region class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-timezone-region.png alt="bsdinstall timezone region"></div><div class=title>Figura 35. Selecione uma região</div></div><div class=paragraph><p>A região apropriada é selecionada usando as teclas de seta e depois pressionando <kbd>Enter</kbd>.</p></div><div id=bsdinstall-timezone-country class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-timezone-country.png alt="bsdinstall timezone country"></div><div class=title>Figura 36. Selecione um pais</div></div><div class=paragraph><p>Selecione o país apropriado usando as teclas de seta e pressione <kbd>Enter</kbd>.</p></div><div id=bsdinstall-timezone-zone class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-timezone-zone.png alt="bsdinstall timezone zone"></div><div class=title>Figura 37. Selecione um fuso horário</div></div><div class=paragraph><p>O fuso horário apropriado é selecionado usando as teclas de seta e pressionando <kbd>Enter</kbd>.</p></div><div id=bsdinstall-timezone-confirmation class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-timezone-confirm.png alt="bsdinstall timezone confirm"></div><div class=title>Figura 38. Confirme o fuso horário</div></div><div class=paragraph><p>Confirme se a abreviação do fuso horário está correta.</p></div><div id=bsdinstall-timezone-date class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-timezone-date.png alt="bsdinstall timezone date"></div><div class=title>Figura 39. Selecionar Data</div></div><div class=paragraph><p>A data apropriada é selecionada usando as teclas de seta e pressionando <b class=button>Set Date</b>. Caso contrário, a seleção de data pode ser pulada pressionando <b class=button> Skip </b>.</p></div><div id=bsdinstall-timezone-time class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-timezone-time.png alt="bsdinstall timezone time"></div><div class=title>Figura 40. Selecionar Hora</div></div><div class=paragraph><p>O horário apropriado é selecionado usando as teclas de seta e, em seguida, pressionando <b class=button>Set Time</b>. Caso contrário, a seleção da hora pode ser pulada pressionando <b class=button> Skip </b>.</p></div></div><div class=sect3><h4 id=bsdinstall-sysconf>2.8.3. Ativando Serviços<a class=anchor href=#bsdinstall-sysconf></a></h4><div class=paragraph><p>O próximo menu é usado para configurar quais serviços do sistema serão iniciados sempre que o sistema for inicializado. Todos esses serviços são opcionais. Inicie apenas os serviços necessários para o funcionamento do sistema.</p></div><div id=bsdinstall-config-serv class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-config-services.png alt="bsdinstall config services"></div><div class=title>Figura 41. Selecionando Serviços Adicionais para Ativar</div></div><div class=paragraph><p>Aqui está um resumo dos serviços que podem ser ativados neste menu:</p></div><div class=ulist><ul><li><p><code>local_unbound</code> -Ative o DNS local unbound. É necessário ter em mente que esse é o unbound do sistema base e deve ser usado apenas como um cache local de consultas DNS. Se o objetivo é configurar um resolvedor para toda a rede, instale <a class=package href=https://cgit.freebsd.org/ports/tree/dns/unbound/>dns/unbound</a>.</p></li><li><p><code>sshd</code> - O daemon Secure Shell (SSH) é usado para acessar remotamente um sistema através de uma conexão criptografada. Ative este serviço somente se o sistema estiver disponível para logins remotos.</p></li><li><p><code>moused</code> - Ative este serviço se o mouse for usado a partir do console do sistema de linha de comando.</p></li><li><p><code>ntpdate</code> - Ative a sincronização automática do relógio no momento do boot. A funcionalidade deste programa agora está disponível no daemon <a href="https://man.freebsd.org/cgi/man.cgi?query=ntpd&amp;sektion=8&amp;format=html">ntpd(8)</a>. Após um período considerável de luto, o utilitário <a href="https://man.freebsd.org/cgi/man.cgi?query=ntpdate&amp;sektion=8&amp;format=html">ntpdate(8)</a> será aposentado.</p></li><li><p><code>ntpd</code> - O daemon do Network Time Protocol (NTP) para sincronização automática do relógio. Ative este serviço se houver um servidor Windows™, Kerberos ou LDAP na rede.</p></li><li><p><code>powerd</code> - Utilitário de controle de energia do sistema para controle de energia e economia de energia.</p></li><li><p><code>dumpdev</code> - A habilitação de despejos de memória é útil na depuração de problemas com o sistema; portanto, os usuários são incentivados a habilitar despejos de memória.</p></li></ul></div></div><div class=sect3><h4 id=bsdinstall-hardening>2.8.4. Ativando Opções de Segurança (Hardening)<a class=anchor href=#bsdinstall-hardening></a></h4><div class=paragraph><p>O próximo menu é usado para configurar quais opções de segurança serão ativadas. Todas essas opções são opcionais. Mas seu uso é incentivado.</p></div><div id=bsdinstall-hardening-options class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-hardening.png alt="bsdinstall hardening"></div><div class=title>Figura 42. Selecionando Opções de Segurança (Hardening)</div></div><div class=paragraph><p>Aqui está um resumo das opções que podem ser ativadas neste menu:</p></div><div class=ulist><ul><li><p><code>hide_uids</code> - Oculta processos em execução de outros usuários para impedir que usuários sem privilégios vejam processos em execução de outros usuários (UID), impedindo o vazamento de informações.</p></li><li><p><code>hide_gids</code> - Oculta processos em execução de outros grupos para impedir que usuários sem privilégios vejam processos em execução de outros grupos (GID), impedindo o vazamento de informações.</p></li><li><p><code>hide_jail</code> - Oculta processos em execução em jails para impedir que usuários sem privilégios vejam processos em execução dentro das jails.</p></li><li><p><code>read_msgbuf</code> - Desativando a leitura do buffer de mensagens do kernel para usuários sem privilégios, impede o uso do <a href="https://man.freebsd.org/cgi/man.cgi?query=dmesg&amp;sektion=8&amp;format=html">dmesg(8)</a> para exibir mensagens do log do kernel em buffer.</p></li><li><p><code>proc_debug</code> - Desativar os recursos de depuração de processo para usuários sem privilégios desativa uma variedade de serviços de depuração entre processos sem privilégios, incluindo algumas funcionalidades procfs, ptrace() e ktrace(). Observe que isso também irá bloquear ferramentas de depuração, como por exemplo, <a href="https://man.freebsd.org/cgi/man.cgi?query=lldb&amp;sektion=1&amp;format=html">lldb(1)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=truss&amp;sektion=1&amp;format=html">truss(1)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=procstat&amp;sektion=1&amp;format=html">procstat(1)</a>, bem como alguns recursos de depuração integrados em certas linguagens de script como PHP, etc., de funcionar para usuários sem privilégios.</p></li><li><p><code>random_pid</code> - Randomize o PID dos processos recém-criados.</p></li><li><p><code>clear_tmp</code> - Limpar o <span class=filename>/tmp</span> na inicialização do sistema.</p></li><li><p><code>disable_syslogd</code> - Desative a criação de socket de rede do syslogd. Por padrão, o FreeBSD executa o syslogd de maneira segura com <code>-s</code>. Isso impede que o daemon atenda solicitações UDP recebidas na porta 514. Com esta opção ativada, o syslogd será executado com o sinalizador <code>-ss</code>, que impede o syslogd de abrir qualquer porta. Para obter mais informações, consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=syslogd&amp;sektion=8&amp;format=html">syslogd(8)</a>.</p></li><li><p><code>disable_sendmail</code> - Desative o agente de transporte de email sendmail.</p></li><li><p><code>secure_console</code> - Quando esta opção está ativada, o prompt solicita a senha de <code>root</code> ao entrar em modo single-user.</p></li><li><p><code>disable_ddtrace</code> - O DTrace pode ser executado em um modo que realmente afetará o kernel em execução. Ações destrutivas não podem ser usadas, a menos que tenham sido explicitamente ativadas. Para habilitar esta opção ao usar o DTrace, use <code>-w</code>. Para obter mais informações, consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=dtrace&amp;sektion=1&amp;format=html">dtrace(1)</a>.</p></li></ul></div></div><div class=sect3><h4 id=bsdinstall-addusers>2.8.5. Adicione usuários<a class=anchor href=#bsdinstall-addusers></a></h4><div class=paragraph><p>O próximo menu pede para criar pelo menos uma conta de usuário. Recomenda-se fazer login no sistema usando uma conta de usuário em vez de utilizar diretamente o <code>root</code>. Quando logado como <code>root</code>, essencialmente não há limites ou proteção sobre o que pode ser feito. Fazer o login como um usuário normal é mais seguro.</p></div><div class=paragraph><p>Selecione <b class=button>Yes</b> para adicionar novos usuários.</p></div><div id=bsdinstall-add-user1 class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-adduser1.png alt="bsdinstall adduser1"></div><div class=title>Figura 43. Adicione contas de usuário</div></div><div class=paragraph><p>Siga os prompts e insira as informações solicitadas para a conta do usuário. O exemplo mostrado em <a href=#bsdinstall-add-user2>Insira as informações do usuário</a> cria a conta de usuário <code>asample</code>.</p></div><div id=bsdinstall-add-user2 class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-adduser2.png alt="bsdinstall adduser2"></div><div class=title>Figura 44. Insira as informações do usuário</div></div><div class=paragraph><p>Aqui está um resumo das informações para solicitadas:</p></div><div class=ulist><ul><li><p><code>Username</code> - O nome que o usuário digitará para efetuar login. Uma convenção comum é usar a primeira letra do primeiro nome combinada com o sobrenome, desde que cada nome de usuário seja exclusivo para o sistema. O nome de usuário faz distinção entre maiúsculas e minúsculas e não deve conter espaços.</p></li><li><p><code>Username</code> - O nome completo do usuário. Este campo pode conter espaços e é usado como uma descrição para a conta do usuário.</p></li><li><p><code>Uid</code> - ID do Usuário. Normalmente, isso é deixado em branco para que o sistema atribua um valor.</p></li><li><p><code>Login group</code> - O grupo do usuário. Normalmente, isso é deixado em branco para aceitar o padrão.</p></li><li><p><code>Invite <em>user</em> into other groups?</code> - Grupos adicionais aos quais o usuário será adicionado como membro. Se o usuário precisar de acesso administrativo, digite <code>wheel</code> aqui.</p></li><li><p><code>Login class</code> - normalmente deixado em branco para seguir com o padrão.</p></li><li><p><code>Shell</code> - Digite um dos valores listados para definir o shell interativo para o usuário. Consulte <a href=./#shells>Shells</a> para maiores informações sobre shells.</p></li><li><p><code>Home directory</code> - O diretório inicial do usuário. O padrão geralmente está correto.</p></li><li><p><code>Home directory permissions</code> - Permissões no diretório inicial do usuário. O padrão geralmente está correto.</p></li><li><p><code>Use password-based authentication?</code> A resposta deve ser <code>Yes</code> para que o usuário seja solicitado a inserir sua senha no login.</p></li><li><p><code>Use an empty password?</code> - Normalmente a resposta será <code>No</code>, pois é inseguro ter uma senha em branco.</p></li><li><p><code>Use a random password?</code> - Normalmente a resposta será <code>No</code> para que o usuário possa definir sua própria senha no próximo prompt.</p></li><li><p><code>Enter password</code> - Escolha a senha para este usuário. Caracteres digitados não serão exibidos na tela.</p></li><li><p><code>Enter password again</code> - A senha deve ser digitada novamente para verificação.</p></li><li><p><code>Lock out the account after creation?</code> - A reposta normalmente será <code>No</code> para que o usuário possa fazer o login.</p></li></ul></div><div class=paragraph><p>Depois de inserir tudo, um resumo será exibido para revisão. Se algum erro foi cometido, digite <code>no</code> e tente novamente. Se tudo estiver correto, digite <code>yes</code> para criar o novo usuário.</p></div><div id=bsdinstall-add-user3 class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-adduser3.png alt="bsdinstall adduser3"></div><div class=title>Figura 45. Saia do gerenciamento de usuários e grupos</div></div><div class=paragraph><p>Se houver mais usuários para adicionar, responda a pergunta <code>Add another user?</code> com <code>yes</code>. Digite <code>no</code> para concluir a adição de usuários e continuar a instalação.</p></div><div class=paragraph><p>Para obter maiores informações sobre como adicionar usuários e sobre como gerenciá-los de usuários, consulte <a href=./#users-synopsis>Usuários e Gerenciamento Básico de Contas</a>.</p></div></div><div class=sect3><h4 id=bsdinstall-final-conf>2.8.6. Configuração final<a class=anchor href=#bsdinstall-final-conf></a></h4><div class=paragraph><p>Depois que tudo tiver sido instalado e configurado, você terá uma chance final para modificar as configurações.</p></div><div id=bsdinstall-final-config class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-finalconfiguration.png alt="bsdinstall finalconfiguration"></div><div class=title>Figura 46. Configuração final</div></div><div class=paragraph><p>Use este menu para fazer alterações ou fazer qualquer configuração adicional antes de concluir a instalação.</p></div><div class=ulist><ul><li><p><code>Add User</code> - Descrito em <a href=#bsdinstall-addusers>Adicione usuários</a>.</p></li><li><p><code>Root Password</code> - Descrito em <a href=#bsdinstall-post-root>Definindo a Senha de <code>root</code></a>.</p></li><li><p><code>Hostname</code> - Descrito em <a href=#bsdinstall-hostname>Configurando o nome do host</a>.</p></li><li><p><code>Network</code> - Descrito em <a href=#bsdinstall-config-network-dev>Configurando as Interfaces de Rede</a>.</p></li><li><p><code>Services</code> - Descrito em <a href=#bsdinstall-sysconf>Ativando Serviços</a>.</p></li><li><p><code>System Hardening</code> - Descrito em <a href=#bsdinstall-hardening>Ativando Opções de Segurança (Hardening)</a>.</p></li><li><p><code>Time Zone</code> - Descrito em <a href=#bsdinstall-timezone>Defina o fuso horário</a>.</p></li><li><p><code>Handbook</code> - Faça o download e instale o FreeBSD Handbook.</p></li></ul></div><div class=paragraph><p>Depois que completar qualquer configuração final que tenha faltado, selecione <b class=button>Exit</b>.</p></div><div id=bsdinstall-final-modification-shell class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-final-modification-shell.png alt="bsdinstall final modification shell"></div><div class=title>Figura 47. Configuração manual</div></div><div class=paragraph><p>O bsdinstall perguntará se há alguma configuração adicional que precise ser feita antes de reinicializar o novo sistema. Selecione <b class=button>Yes</b> para sair para um shell dentro do novo sistema ou <b class=button>No</b> para prosseguir para a última etapa da instalação.</p></div><div id=bsdinstall-final-main class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-mainexit.png alt="bsdinstall mainexit"></div><div class=title>Figura 48. Conclua a instalação</div></div><div class=paragraph><p>Se outras configurações ou configurações especiais forem necessárias, selecione <b class=button>Live CD</b> para inicializar a mídia de instalação no modo Live CD.</p></div><div class=paragraph><p>Se a instalação estiver completa, selecione <b class=button>Reboot</b> para reiniciar o computador e iniciar o novo sistema FreeBSD. Não se esqueça de remover a mídia de instalação do FreeBSD ou o computador poderá inicializar novamente a partir dela.</p></div><div class=paragraph><p>Quando o FreeBSD inicializa, mensagens informativas são exibidas. Depois que o sistema concluir a inicialização, um prompt de login será exibido. No <code>login:</code>, insira o nome de usuário adicionado durante a instalação. Evite efetuar login como <code>root</code>. Consulte <a href=./#users-superuser>A conta de superusuário</a> para instruções sobre como se tornar o superusuário quando o acesso administrativo for necessário.</p></div><div class=paragraph><p>As mensagens que apareceram durante a inicialização podem ser revisadas pressionando <kbd>Scroll-Lock</kbd> para ativar o buffer de rolagem para trás. As teclas <kbd>PgUp</kbd>, <kbd>PgDn</kbd> e setas podem ser usadas para rolar pelas mensagens. Quando terminar, pressione <kbd>Scroll-Lock</kbd> novamente para desbloquear o visor e retornar ao console. Para revisar essas mensagens depois que o sistema estiver ativo por algum tempo, digite <code>less /var/run/dmesg.boot</code> em um prompt de comando. Pressione <kbd>q</kbd> para retornar à linha de comando após a visualização.</p></div><div class=paragraph><p>Se o sshd foi habilitado em <a href=#bsdinstall-config-serv>Selecionando Serviços Adicionais para Ativar</a>, a primeira inicialização pode ser um pouco mais lenta, pois o sistema gerará as chaves RSA e DSA. As inicializações subseqüentes serão mais rápidas. As impressões digitais das chaves serão exibidas, conforme mostrado neste exemplo:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Generating public/private rsa1 key pair.
Your identification has been saved <span class=k>in</span> /etc/ssh/ssh_host_key.
Your public key has been saved <span class=k>in</span> /etc/ssh/ssh_host_key.pub.
The key fingerprint is:
10:a0:f5:af:93:ae:a3:1a:b2:bb:3c:35:d9:5a:b3:f3 root@machine3.example.com
The key<span class=s1>&#39;s randomart image is:
+--[RSA1 1024]----+
|    o..          |
|   o . .         |
|  .   o          |
|       o         |
|    o   S        |
|   + + o         |
|o . + *          |
|o+ ..+ .         |
|==o..o+E         |
+-----------------+
Generating public/private dsa key pair.
Your identification has been saved in /etc/ssh/ssh_host_dsa_key.
Your public key has been saved in /etc/ssh/ssh_host_dsa_key.pub.
The key fingerprint is:
7e:1c:ce:dc:8a:3a:18:13:5b:34:b5:cf:d9:d1:47:b2 root@machine3.example.com
The key&#39;</span>s randomart image is:
+--[ DSA 1024]----+
|       ..     <span class=nb>.</span> .|
|      o  <span class=nb>.</span>   <span class=nb>.</span> + |
|     <span class=nb>.</span> ..   <span class=nb>.</span> E .|
|    <span class=nb>.</span> <span class=nb>.</span>  o o <span class=nb>.</span> <span class=nb>.</span> |
|     +  S <span class=o>=</span> <span class=nb>.</span>    |
|    +  <span class=nb>.</span> <span class=o>=</span> o     |
|     +  <span class=nb>.</span> <span class=k>*</span> <span class=nb>.</span>    |
|    <span class=nb>.</span> <span class=nb>.</span>  o <span class=nb>.</span>     |
|      .o. <span class=nb>.</span>      |
+-----------------+
Starting sshd.</code></pre></div></div><div class=paragraph><p>Consulte <a href=./#openssh>OpenSSH</a> para maiores informações sobre fingerprints e o SSH.</p></div><div class=paragraph><p>O FreeBSD não instala um ambiente gráfico por padrão. Consulte <a href=./#x11>O sistema X Window</a> para maiores informações sobre como instalar e configurar um gerenciador gráfico de janelas.</p></div><div class=paragraph><p>O desligamento adequado de um computador FreeBSD ajuda a proteger os dados e o hardware contra danos. <em>Não desligue a energia antes do sistema ter sido desligado corretamente!</em> Se o usuário for membro do grupo <code>wheel</code>, torne-se o superusuário digitando <code>su</code> na linha de comando e inserindo a senha do usuário <code>root</code>. Em seguida, digite <code>shutdown -p now</code> e o sistema será desligado corretamente e, se o hardware suportar, irá se desliga-se.</p></div></div></div><div class=sect2><h3 id=bsdinstall-network>2.9. Interfaces de Rede<a class=anchor href=#bsdinstall-network></a></h3><div class=sect3><h4 id=bsdinstall-config-network-dev>2.9.1. Configurando as Interfaces de Rede<a class=anchor href=#bsdinstall-config-network-dev></a></h4><div class=paragraph><p>Em seguida, é mostrada uma lista das interfaces de rede encontradas no computador. Selecione a interface para configurar.</p></div><div id=bsdinstall-configure-net-interface class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-configure-network-interface.png alt="bsdinstall configure network interface"></div><div class=title>Figura 49. Escolha uma interface de rede</div></div><div class=paragraph><p>Se uma interface Ethernet for selecionada, o instalador irá pular para o menu mostrado em <a href=#bsdinstall-configure-net-ipv4>Escolha a rede IPv4</a>. Se uma interface de rede sem fio for escolhida, o sistema procurará pontos de acesso sem fio:</p></div><div id=bsdinstall-wireless-scan class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-configure-wireless-scan.png alt="bsdinstall configure wireless scan"></div><div class=title>Figura 50. Buscando por pontos de acesso sem fio</div></div><div class=paragraph><p>As redes sem fio são identificadas por um identificador de conjunto de serviços (SSID), um nome curto e exclusivo dado a cada rede. Os SSIDs encontrados durante a busca serão listados, seguidos por uma descrição dos tipos de criptografia disponíveis para essa rede. Se o SSID desejado não aparecer na lista, selecione <b class=button>Rescan</b> para buscar novamente. Se a rede desejada ainda não aparecer, verifique se há problemas com as conexões da antena ou tente mover o computador para mais perto do ponto de acesso. refaça a busca após cada alteração ser feita.</p></div><div id=bsdinstall-wireless-accesspoints class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-configure-wireless-accesspoints.png alt="bsdinstall configure wireless accesspoints"></div><div class=title>Figura 51. Escolhendo uma rede sem fio</div></div><div class=paragraph><p>Em seguida, insira as informações de criptografia para se conectar à rede sem fio selecionada. A encriptação WPA2 é fortemente recomendada, pois os tipos de encriptação mais antigos, como o WEP, oferecem pouca segurança. Se a rede usar WPA2, insira a senha, também conhecida como Chave Pré-Compartilhada (PSK). Por motivos de segurança, os caracteres digitados na caixa de entrada são exibidos como asteriscos.</p></div><div id=bsdinstall-wireless-wpa2 class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-configure-wireless-wpa2setup.png alt="bsdinstall configure wireless wpa2setup"></div><div class=title>Figura 52. Configuração WPA2</div></div><div class=paragraph><p>Em seguida, escolha se um endereço IPv4 deve ou não ser configurado na interface Ethernet ou na interface sem fio:</p></div><div id=bsdinstall-configure-net-ipv4 class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-configure-network-interface-ipv4.png alt="bsdinstall configure network interface ipv4"></div><div class=title>Figura 53. Escolha a rede IPv4</div></div><div class=paragraph><p>Existem dois métodos de configuração de IPv4. O DHCP configurará automaticamente a interface de rede da forma correta e deverá ser usado se a rede fornecer um servidor DHCP. Caso contrário, as informações de endereçamento precisam ser inseridas manualmente como em uma configuração estática.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Não insira informações de rede aleatórias, pois isso não funcionará. Se um servidor DHCP não estiver disponível, obtenha as informações listadas em <a href=#bsdinstall-collect-network-information>[bsdinstall-collect-network-information]</a> do administrador da rede ou do provedor de serviços de Internet.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Se um servidor DHCP estiver disponível, selecione <b class=button>Yes</b> no próximo menu para configurar automaticamente a interface de rede. O instalador parecerá pausar por um minuto ou mais enquanto encontra o servidor DHCP e obtém as informações de endereçamento do sistema.</p></div><div id=bsdinstall-net-ipv4-dhcp class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-configure-network-interface-ipv4-dhcp.png alt="bsdinstall configure network interface ipv4 dhcp"></div><div class=title>Figura 54. Escolha a configuração IPv4DHCP</div></div><div class=paragraph><p>Se um servidor DHCP não estiver disponível, selecione <b class=button>No</b> e insira as seguintes informações de endereçamento neste menu:</p></div><div id=bsdinstall-net-ipv4-static class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-configure-network-interface-ipv4-static.png alt="bsdinstall configure network interface ipv4 static"></div><div class=title>Figura 55. Configuração IPv4 estática</div></div><div class=ulist><ul><li><p><code>Endereço IP</code> - O endereço IPv4 atribuído a este computador. O endereço deve ser único e não estar em uso por outro equipamento na rede local.</p></li><li><p><code>Subnet Mask</code> - A máscara de sub-rede da rede.</p></li><li><p><code>Default Router</code> - O endereço IP do gateway padrão da rede.</p></li></ul></div><div class=paragraph><p>A próxima tela perguntará se a interface deve ser configurada para IPv6. Se IPv6 estiver disponível e for desejado, escolha <b class=button>Yes</b> para selecioná-lo.</p></div><div id=bsdinstall-net-ipv6 class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-configure-network-interface-ipv6.png alt="bsdinstall configure network interface ipv6"></div><div class=title>Figura 56. Escolha a rede IPv6</div></div><div class=paragraph><p>O IPv6 também possui dois métodos de configuração. A configuração automática de endereços sem estado (SLAAC) solicitará automaticamente as informações de configuração corretas de um roteador local. Consulte <a href=http://tools.ietf.org/html/rfc4862>rfc4862</a> para maiores informações. A configuração estática requer entrada manual das informações da rede.</p></div><div class=paragraph><p>Se um roteador IPv6 estiver disponível, selecione <b class=button>Yes</b> no próximo menu para configurar automaticamente a interface de rede. O instalador parecerá pausar por um minuto ou mais enquanto localiza o roteador e obtém as informações de endereçamento do sistema.</p></div><div id=bsdinstall-net-ipv6-slaac class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-configure-network-interface-slaac.png alt="bsdinstall configure network interface slaac"></div><div class=title>Figura 57. Escolha a configuração do SLAAC do IPv6</div></div><div class=paragraph><p>Se um roteador IPv6 não estiver disponível, selecione <b class=button>No</b> e insira as seguintes informações de endereçamento neste menu:</p></div><div id=bsdinstall-net-ipv6-static class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-configure-network-interface-ipv6-static.png alt="bsdinstall configure network interface ipv6 static"></div><div class=title>Figura 58. Configuração Estática do IPv6</div></div><div class=ulist><ul><li><p><code>Endereço IPv6</code> - O endereço IPv6 atribuído a este computador. O endereço deve ser único e não estar em uso por outro equipamento na rede local.</p></li><li><p><code>Default Router</code> - O endereço IPv6 do gateway padrão da rede.</p></li></ul></div><div class=paragraph><p>O último menu de configuração de rede é usado para configurar o resolvedor do Sistema de Nomes de Domínio (DNS), que converte nomes de host de e para endereços de rede. Se o DHCP ou SLAAC foi usado para autoconfigurar a interface de rede, os valores do <code>Resolver Configuration</code> podem já estar preenchidos. Caso contrário, insira o domínio da rede local nome no campo <code>Search</code>. <code>DNS # 1</code> e <code>DNS # 2</code> são os endereços IPv4 e/ou IPv6 dos servidores de DNS. Pelo menos um servidor DNS é necessário.</p></div><div id=bsdinstall-net-dns-config class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-configure-network-ipv4-dns.png alt="bsdinstall configure network ipv4 dns"></div><div class=title>Figura 59. Configuração do DNS</div></div><div class=paragraph><p>Quando a interface estiver configurada, selecione um site espelho localizado na mesma região do mundo que o computador no qual o FreeBSD está sendo instalado. Os arquivos podem ser recuperados mais rapidamente quando o espelho está próximo ao computador de destino, reduzindo o tempo de instalação.</p></div><div id=bsdinstall-netinstall-mirror class=imageblock><div class=content><img src=../../../../images/books/handbook/bsdinstall/bsdinstall-netinstall-mirrorselect.png alt="bsdinstall netinstall mirrorselect"></div><div class=title>Figura 60. Escolhendo um Site Espelho</div></div></div></div><div class=sect2><h3 id=bsdinstall-install-trouble>2.10. Solução de problemas<a class=anchor href=#bsdinstall-install-trouble></a></h3><div class=paragraph><p>Esta seção aborda a solução de problemas básicos de instalação, tais como problemas comuns que as pessoas relataram.</p></div><div class=paragraph><p>Verifique o documento Notas de Hardware (<a href=https://www.FreeBSD.org/releases/>https://www.freebsd.org/releases/</a>) para a versão do FreeBSD para garantir que o hardware é suportado. Se o hardware for suportado e houver travamentos ou outros problemas, compile um kernel personalizado usando as instruções em <a href=./#kernelconfig>Configurando o kernel do FreeBSD</a> para adicionar suporte a dispositivos que não estão presentes no kernel <span class=filename>GENERIC</span>. O kernel padrão assume que a maioria dos dispositivos de hardware está na configuração padrão de fábrica em termos de IRQs, endereços de I/O e canais DMA. Se o hardware foi reconfigurado, um arquivo de configuração personalizado do kernel pode dizer ao FreeBSD onde encontrar os dispositivos.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Alguns problemas de instalação podem ser evitados ou aliviados com a atualização do firmware em vários componentes de hardware, principalmente na placa-mãe. O firmware da placa-mãe é geralmente chamado de BIOS. A maioria dos fabricantes de placas-mãe e computadores tem um site para atualizações e para informações sobre as atualizações.</p></div><div class=paragraph><p>Os fabricantes geralmente desaconselham a atualização da BIOS da placa-mãe, a menos que haja uma boa razão para isso, como uma atualização crítica. O processo de atualização <em>pode</em> dar errado, deixando o BIOS incompleto e o computador inoperante.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Se o sistema trava enquanto verifica o hardware durante a inicialização ou se comporta de maneira estranha durante a instalação, o ACPI pode ser o culpado. O FreeBSD faz uso extensivo do sistema ACPI nas plataformas i386 e amd64 para ajudar na configuração do sistema, caso seja detectado durante a inicialização. Infelizmente, alguns bugs ainda existem tanto no driver ACPI como nas placas-mãe do sistema e no firmware BIOS. O ACPI pode ser desativado configurando a opção <code>hint.acpi.0.disabled</code> no terceiro estágio do boot loader:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> <span class=nb>set </span>hint.acpi.0.disabled<span class=o>=</span><span class=s2>&#34;1&#34;</span></code></pre></div></div><div class=paragraph><p>Isso é redefinido toda vez que o sistema é inicializado, portanto é necessário adicionar <code>hint.acpi.0.disabled="1"</code> ao arquivo <span class=filename>/boot/loader.conf</span> . Maiores informações sobre o boot loader podem ser encontradas em <a href=./#boot-synopsis>Sinopse</a>.</p></div></div><div class=sect2><h3 id=using-live-cd>2.11. Usando o Live CD<a class=anchor href=#using-live-cd></a></h3><div class=paragraph><p>O menu de boas-vindas do bsdinstall, mostrado em <a href=#bsdinstall-choose-mode>Menu de boas-vindas</a>, fornece uma opção <b class=button>Live CD</b>. Isto é útil para aqueles que ainda estão se perguntando se o FreeBSD é o sistema operacional correto para eles e quer testar alguns dos recursos antes de instalar.</p></div><div class=paragraph><p>Os seguintes pontos devem ser observados antes de usar o <b class=button>Live CD</b>:</p></div><div class=ulist><ul><li><p>Para obter acesso ao sistema, a autenticação é necessária. O nome de usuário é <code>root</code> e a senha está em branco.</p></li><li><p>Como o sistema é executado diretamente da mídia de instalação, o desempenho será significativamente mais lento do que o de um sistema instalado em um disco rígido.</p></li><li><p>Essa opção fornece apenas um prompt de comando e não uma interface gráfica.</p></li></ul></div></div></div></div><div class=sect1><h2 id=basics>Capítulo 3. Fundamentos do FreeBSD<a class=anchor href=#basics></a></h2><div class=sectionbody><div class=sect2><h3 id=basics-synopsis>3.1. Sinopse<a class=anchor href=#basics-synopsis></a></h3><div class=paragraph><p>Este capítulo cobre os comandos básicos e as funcionalidades do sistema operacional FreeBSD. Grande parte deste material é relevante para qualquer sistema operacional do tipo UNIX™. Novos usuários do FreeBSD são encorajados a ler este capítulo cuidadosamente.</p></div><div class=paragraph><p>Depois de ler este capítulo, você saberá:</p></div><div class=ulist><ul><li><p>Como usar e configurar consoles virtuais.</p></li><li><p>Como criar e gerenciar usuários e grupos no FreeBSD.</p></li><li><p>Como funcionam as permissões de arquivo UNIX™ e as flags de arquivos do FreeBSD.</p></li><li><p>O layout padrão do sistema de arquivos do FreeBSD.</p></li><li><p>A organização do disco no FreeBSD.</p></li><li><p>Como montar e desmontar sistemas de arquivos.</p></li><li><p>O que são processos, daemons e sinais.</p></li><li><p>O que é um shell e como alterar o ambiente de login padrão.</p></li><li><p>Como usar editores de texto básicos.</p></li><li><p>O que são devices e device nodes.</p></li><li><p>Como ler páginas de manual para obter maiores informações.</p></li></ul></div></div><div class=sect2><h3 id=consoles>3.2. Consoles e Terminais Virtuais<a class=anchor href=#consoles></a></h3><div class=paragraph><p>A menos que o FreeBSD tenha sido configurado para iniciar automaticamente um ambiente gráfico durante a inicialização, o sistema inicializará em um prompt de login da linha de comando, como visto neste exemplo:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>FreeBSD/amd64 <span class=o>(</span>pc3.example.org<span class=o>)</span> <span class=o>(</span>ttyv0<span class=o>)</span>

login:</code></pre></div></div><div class=paragraph><p>A primeira linha contém algumas informações sobre o sistema. O <code>amd64</code> indica que o sistema neste exemplo está executando uma versão de 64 bits do FreeBSD. O nome do host é <code>pc3.example.org</code>, e <span class=filename>ttyv0</span> indica que este é o "console do sistema". A segunda linha é o prompt de login.</p></div><div class=paragraph><p>Como o FreeBSD é um sistema multiusuário, ele precisa de alguma maneira distinguir entre usuários diferentes. Isso é feito exigindo que todos os usuários façam login no sistema antes de obter acesso aos programas no sistema. Cada usuário tem um "nome de usuário" único e uma "senha" pessoal.</p></div><div class=paragraph><p>Para efetuar login no console do sistema, digite o nome de usuário que foi configurado durante a instalação do sistema, conforme descrito em <a href=./#bsdinstall-addusers>Adicione usuários</a> e pressione <kbd>Enter</kbd>. Em seguida, insira a senha associada ao nome de usuário e pressione <kbd>Enter</kbd>. A senha não é <em>ecoada</em> por razões de segurança.</p></div><div class=paragraph><p>Uma vez que a senha correta é inserida, a mensagem do dia (MOTD) será exibida, seguida de um prompt de comando. Dependendo do shell que foi selecionado quando o usuário foi criado, este prompt será um caractere <code>#</code>, <code>$</code> ou <code>%</code>. O prompt indica que o usuário está logado no console do sistema FreeBSD e pronto para testar os comandos disponíveis.</p></div><div class=sect3><h4 id=consoles-virtual>3.2.1. Consoles Virtuais<a class=anchor href=#consoles-virtual></a></h4><div class=paragraph><p>Enquanto o console do sistema pode ser usado para interagir com o sistema, um usuário trabalhando a partir da linha de comando no teclado de um sistema FreeBSD normalmente irá efetuar login em um console virtual. Isso ocorre porque as mensagens do sistema são configuradas por padrão para serem exibidas no console do sistema. Essas mensagens serão exibidas por cima do comando ou arquivo em que o usuário estiver trabalhando, dificultando a concentração no trabalho em questão.</p></div><div class=paragraph><p>Por padrão, o FreeBSD é configurado para fornecer vários consoles virtuais para a entrada de comandos. Cada console virtual tem seu próprio prompt de login e shell e é fácil alternar entre os consoles virtuais. Isso essencialmente fornece a linha de comando equivalente a ter várias janelas abertas ao mesmo tempo em um ambiente gráfico.</p></div><div class=paragraph><p>As combinações de teclas <span class=keyseq><kbd>Alt</kbd>+<kbd>F1</kbd></span> até a <span class=keyseq><kbd>Alt</kbd>+<kbd>F8</kbd></span> foram reservadas pelo FreeBSD para alternar entre os consoles virtuais. Use <span class=keyseq><kbd>Alt</kbd>+<kbd>F1</kbd></span> para alternar para o console do sistema (<span class=filename>ttyv0</span>), <span class=keyseq><kbd>Alt</kbd>+<kbd>F2</kbd></span> para acessar o primeiro console virtual (<span class=filename>ttyv1</span>), <span class=keyseq><kbd>Alt</kbd>+<kbd>F3</kbd></span> para acessar o segundo console virtual (<span class=filename>ttyv2</span>) e assim por diante. Ao usar o Xorg como um console gráfico, a combinação <span class=keyseq><kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>F1</kbd></span> é utilizada para retornar para um console virtual baseado em texto.</p></div><div class=paragraph><p>Ao mudar de um console para o próximo, o FreeBSD gerencia a saída da tela. O resultado é uma ilusão de ter várias telas virtuais e teclados que podem ser usados para digitar comandos para o FreeBSD rodar. Os programas executados em um console virtual não param de ser executados quando o usuário alterna para um console virtual diferente.</p></div><div class=paragraph><p>Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=kbdcontrol&amp;sektion=1&amp;format=html">kbdcontrol(1)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=vidcontrol&amp;sektion=1&amp;format=html">vidcontrol(1)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=atkbd:&amp;sektion=4&amp;format=html">atkbd:(4)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=syscons&amp;sektion=4&amp;format=html">syscons(4)</a>, e <a href="https://man.freebsd.org/cgi/man.cgi?query=vt&amp;sektion=4&amp;format=html">vt(4)</a> para uma descrição mais técnica do console do FreeBSD e seus drivers de teclado.</p></div><div class=paragraph><p>No FreeBSD, o número de consoles virtuais disponíveis é configurado nesta seção do <span class=filename>/etc/ttys</span>:</p></div><div class="literalblock programlisting"><div class=content><pre># name    getty                         type  status comments
#
ttyv0   &#34;/usr/libexec/getty Pc&#34;         xterm   on  secure
# Virtual terminals
ttyv1   &#34;/usr/libexec/getty Pc&#34;         xterm   on  secure
ttyv2   &#34;/usr/libexec/getty Pc&#34;         xterm   on  secure
ttyv3   &#34;/usr/libexec/getty Pc&#34;         xterm   on  secure
ttyv4   &#34;/usr/libexec/getty Pc&#34;         xterm   on  secure
ttyv5   &#34;/usr/libexec/getty Pc&#34;         xterm   on  secure
ttyv6   &#34;/usr/libexec/getty Pc&#34;         xterm   on  secure
ttyv7   &#34;/usr/libexec/getty Pc&#34;         xterm   on  secure
ttyv8   &#34;/usr/X11R6/bin/xdm -nodaemon&#34;  xterm   off secure</pre></div></div><div class=paragraph><p>Para desativar um console virtual, coloque um símbolo de comentário (<code><mark></mark></code>) no início da linha que representa esse console virtual. Por exemplo, para reduzir o número de consoles virtuais disponíveis de oito para quatro, coloque um <code></code> na frente das últimas quatro linhas que representam os consoles virtuais de <span class=filename>ttyv5</span> até <span class=filename>ttyv8</span>. <em>Não</em> comente a linha do console do sistema <span class=filename>ttyv0</span>. Note que o último console virtual (<span class=filename>ttyv8</span>) é usado para acessar o ambiente gráfico se o Xorg tiver sido instalado e configurado conforme descrito em <a href=./#x11>O sistema X Window</a>.</p></div><div class=paragraph><p>Para uma descrição detalhada de cada coluna neste arquivo e as opções disponíveis para os consoles virtuais, consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=ttys&amp;sektion=5&amp;format=html">ttys(5)</a>.</p></div></div><div class=sect3><h4 id=consoles-singleuser>3.2.2. Modo "Single User"<a class=anchor href=#consoles-singleuser></a></h4><div class=paragraph><p>O menu de inicialização do FreeBSD fornece uma opção chamada "Boot Single User". Se esta opção for selecionada, o sistema inicializará em um modo especial conhecido como "single user mode". Esse modo é normalmente usado para reparar um sistema que não inicializa ou para redefinir a senha de <code>root</code> quando ela é desconhecida. Quando em modo single user, a rede e outros consoles virtuais não estão disponíveis. No entanto, haverá acesso completo de <code>root</code> ao sistema e, por padrão, a senha de <code>root</code> não é necessária. Por estas razões, o acesso físico ao teclado é necessário para iniciar neste modo e determinar quem tem acesso físico ao teclado é algo a considerar ao proteger um sistema FreeBSD.</p></div><div class=paragraph><p>As configurações que controlam o modo de single user são encontradas nesta seção do <span class=filename>/etc/ttys</span>:</p></div><div class="literalblock programlisting"><div class=content><pre># name  getty                           type  status  comments
#
# If console is marked &#34;insecure&#34;, then init will ask for the root password
# when going to single-user mode.
console none                            unknown  off  secure</pre></div></div><div class=paragraph><p>Por padrão, o status é definido como <code>secure</code>. Isso pressupõe que quem tem acesso físico ao teclado não é importante ou é controlado por uma política de segurança física. Se essa configuração for alterada para <code>insecure</code>, a suposição é que o ambiente em si é inseguro porque qualquer pessoa pode acessar o teclado. Quando esta linha é alterada para <code>insecure</code>, o FreeBSD irá solicitar a senha do <code>root</code> quando um usuário selecionar inicializar no modo single user.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p><em>Tenha cuidado ao alterar esta configuração para <code>inseguro</code></em>! Se a senha do <code>root</code> for esquecida, a inicialização no modo single user ainda é possível, mas pode ser difícil para alguém que não esteja familiarizado com o processo de inicialização do FreeBSD.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=consoles-vidcontrol>3.2.3. Alterar os modos de vídeo do console<a class=anchor href=#consoles-vidcontrol></a></h4><div class=paragraph><p>O modo de vídeo padrão do console do FreeBSD pode ser ajustado para 1024x768, 1280x1024 ou qualquer outro tamanho suportado pelo chip gráfico e monitor. Para usar um modo de vídeo diferente, carregue o módulo <code>VESA</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload vesa</span></code></pre></div></div><div class=paragraph><p>Para determinar quais modos de vídeo são suportados pelo hardware, use <a href="https://man.freebsd.org/cgi/man.cgi?query=vidcontrol&amp;sektion=1&amp;format=html">vidcontrol(1)</a>. Para obter uma lista de modos de vídeo suportados, execute o seguinte:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># vidcontrol -i mode</span></code></pre></div></div><div class=paragraph><p>A saída deste comando lista os modos de vídeo suportados pelo hardware. Para selecionar um novo modo de vídeo, especifique o modo usando <a href="https://man.freebsd.org/cgi/man.cgi?query=vidcontrol&amp;sektion=1&amp;format=html">vidcontrol(1)</a> como o usuário <code>root</code> :</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># vidcontrol MODE_279</span></code></pre></div></div><div class=paragraph><p>Se o novo modo de vídeo for aceitável, ele pode ser definido permanentemente na inicialização, adicionando-o ao <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>allscreens_flags=&#34;MODE_279&#34;</pre></div></div></div></div><div class=sect2><h3 id=users-synopsis>3.3. Usuários e Gerenciamento Básico de Contas<a class=anchor href=#users-synopsis></a></h3><div class=paragraph><p>O FreeBSD permite que múltiplos usuários usem o computador ao mesmo tempo. Enquanto apenas um usuário pode se sentar em frente à tela e usar o teclado a qualquer momento, qualquer número de usuários pode efetuar o login no sistema através da rede. Para usar o sistema, cada usuário deve ter sua própria conta de usuário.</p></div><div class=paragraph><p>Este capítulo descreve:</p></div><div class=ulist><ul><li><p>Os diferentes tipos de contas de usuários em um sistema FreeBSD.</p></li><li><p>Como adicionar, remover e modificar contas de usuários.</p></li><li><p>Como definir limites para controlar os recursos que usuários e grupos podem acessar.</p></li><li><p>Como criar grupos e adicionar usuários como membros de um grupo.</p></li></ul></div><div class=sect3><h4 id=users-introduction>3.3.1. Tipos de conta<a class=anchor href=#users-introduction></a></h4><div class=paragraph><p>Como todo acesso ao sistema FreeBSD é obtido usando contas e todos os processos são executados por usuários, o gerenciamento de usuários e contas é importante.</p></div><div class=paragraph><p>Existem três tipos principais de contas: contas do sistema, contas de usuário e a conta de superusuário.</p></div><div class=sect4><h5 id=users-system>3.3.1.1. Contas do sistema<a class=anchor href=#users-system></a></h5><div class=paragraph><p>As contas do sistema são usadas para executar serviços como DNS, correio e servidores web. A razão para isso é a segurança; se todos os serviços fossem executados como superusuário, eles poderiam agir sem restrições.</p></div><div class=paragraph><p>Exemplos de contas do sistema são <code>daemon</code>, <code>operador</code>, <code>bind</code>, <code>news</code>, e <code>www</code>.</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>É necessário ter cuidado ao usar o grupo operator, pois privilégios de acesso como o de superusuário podem ser concedidos, incluindo e não limitado a, desligamento, reinicialização e acesso a todos os itens em <span class=filename>/dev</span> para o grupo.</p></div></td></tr></tbody></table></div><div class=paragraph><p>A <code>nobody</code> é uma conta genérica sem privilégios do sistema. No entanto, quanto mais serviços usarem <code>nobody</code>, a mais arquivos e processos esse usuário será associado e, portanto, mais privilegiado esse usuário se tornará.</p></div></div><div class=sect4><h5 id=users-user>3.3.1.2. Contas de usuário<a class=anchor href=#users-user></a></h5><div class=paragraph><p>As contas de usuários são atribuídas a pessoas reais e são usadas para efetuar login e usar o sistema. Todas as pessoas que acessam o sistema devem ter uma conta de usuário exclusiva. Isso permite que o administrador descubra quem está fazendo o que e impede que usuários alterem as configurações de outros usuários.</p></div><div class=paragraph><p>Cada usuário pode configurar seu próprio ambiente para adequar o sistema ao seu uso, utilizando suas opções padrão para o shell, editor, atalhos de teclado e idioma.</p></div><div class=paragraph><p>Cada conta de usuário em um sistema FreeBSD tem certas informações associadas:</p></div><div class=dlist><dl><dt class=hdlist1>Nome de usuário</dt><dd><p>O nome do usuário é digitado no prompt <code>login:</code>. Cada usuário deve ter um nome de usuário exclusivo. Existem diversas regras para criar nomes de usuário válidos que estão documentadas em <a href="https://man.freebsd.org/cgi/man.cgi?query=passwd&amp;sektion=5&amp;format=html">passwd(5)</a>. Recomenda-se usar nomes de usuário que tenham oito ou menos caracteres, todos os caracteres devem ser minúsculos para manter a compatibilidade com aplicativos legados.</p></dd><dt class=hdlist1>Senha</dt><dd><p>Cada conta tem uma senha associada.</p></dd><dt class=hdlist1>ID do usuário (UID)</dt><dd><p>O ID do Usuário (UID) é um número usado para identificar unicamente o usuário no sistema FreeBSD. Comandos que permitem que um nome de usuário seja especificado o converterão para o UID. Recomenda-se usar um UID menor que 65535, já que valores mais altos podem causar problemas de compatibilidade com alguns softwares.</p></dd><dt class=hdlist1>ID do grupo (GID)</dt><dd><p>O ID do grupo (GID) é um número usado para identificar unicamente o grupo principal ao qual o usuário pertence. Os grupos são um mecanismo para controlar o acesso a recursos com base no GID de um usuário, em vez de no seu UID. Isso pode reduzir significativamente o tamanho de alguns arquivos de configuração e permite que os usuários sejam membros de mais de um grupo. Recomenda-se usar um GID de 65535 ou inferior, pois GIDs mais altos podem não funcionar com alguns softwares.</p></dd><dt class=hdlist1>Classe de login</dt><dd><p>As classes de login são uma extensão do mecanismo de grupo que fornece flexibilidade adicional ao configurar o sistema para diferentes usuários. As classes de login são discutidas em <a href=./#users-limiting>Configurando Classes de Login</a>.</p></dd><dt class=hdlist1>Tempo para mudança de senha</dt><dd><p>Por padrão as senhas não expiram. No entanto, a expiração de senha pode ser ativada por usuário, forçando alguns ou todos os usuários a alterar suas senhas após um determinado período de tempo.</p></dd><dt class=hdlist1>Tempo de expiração da conta</dt><dd><p>Por padrão o FreeBSD não expira contas. Ao criar contas que precisam de uma vida útil limitada, como contas de alunos em uma escola, especifique a data de expiração da conta usando o <a href="https://man.freebsd.org/cgi/man.cgi?query=pw&amp;sektion=8&amp;format=html">pw(8)</a>. Após o tempo de expiração, a conta não poderá ser usada para efetuar login no sistema, embora os diretórios e arquivos da conta permaneçam no servidor.</p></dd><dt class=hdlist1>Nome completo do usuário</dt><dd><p>O nome de usuário identifica a conta de forma única para o FreeBSD, mas não reflete necessariamente o nome real do usuário. Semelhante a um comentário, essas informações podem conter espaços, caracteres maiúsculos e ter mais de oito caracteres.</p></dd><dt class=hdlist1>Diretório Inicial (home)</dt><dd><p>O diretório "home" é um caminho completo para um diretório no sistema. Este é o diretório inicial do usuário quando o usuário faz o login. Uma convenção comum é colocar todos os diretórios home dos usuários em <span class=filename>/home/username</span> ou <span class=filename>/usr/home/username</span>. Cada usuário armazena seus arquivos e subdiretórios pessoais em seu próprio diretório home.</p></dd><dt class=hdlist1>Shell do usuário</dt><dd><p>O shell fornece o ambiente padrão do usuário para interagir com o sistema. Existem muitos tipos diferentes de shells e usuários experientes terão suas próprias preferências, que podem ser refletidas nas suas configurações da conta.</p></dd></dl></div></div><div class=sect4><h5 id=users-superuser>3.3.1.3. A conta de superusuário<a class=anchor href=#users-superuser></a></h5><div class=paragraph><p>A conta de superusuário, geralmente chamada de <code>root</code>, é usada para gerenciar o sistema sem limitações de privilégios. Por este motivo, não deve ser usado para tarefas do dia-a-dia, como enviar e receber e-mail, exploração geral do sistema ou programação.</p></div><div class=paragraph><p>O superusuário, ao contrário de outras contas de usuário, pode operar sem limites, e o uso indevido da conta de superusuário pode resultar em desastres espetaculares. As contas de usuário não podem destruir o sistema operacional por engano, por isso é recomendável fazer o login como uma conta de usuário e se tornar o superusuário somente quando um comando exigir privilégios extras.</p></div><div class=paragraph><p>Sempre cheque duas ou três vezes todos os comandos emitidos como superusuário, pois um espaço extra ou um caractere ausente pode causar uma perda de dados irreparável.</p></div><div class=paragraph><p>Existem várias maneiras de obter privilégios de superusuário. Embora seja possível efetuar login como <code>root</code>, isso é altamente desencorajado.</p></div><div class=paragraph><p>Em vez disso, use <a href="https://man.freebsd.org/cgi/man.cgi?query=su&amp;sektion=1&amp;format=html">su(1)</a> para se tornar o superusuário. Se <code>-</code> for especificado ao executar este comando, o usuário também herdará o ambiente do usuário root. O usuário que executa este comando deve estar no grupo <code>wheel</code> ou o comando falhará. O usuário também deve saber a senha da conta de usuário <code>root</code>.</p></div><div class=paragraph><p>Neste exemplo, o usuário só se torna superusuário para executar <code>make install</code>, pois isso requer privilégios de superusuário. Quando o comando é concluído, o usuário digita <code>exit</code> para deixar a conta de superusuário e retornar à sua conta de usuário.</p></div><div class=exampleblock><div class=title>Exemplo 2. Instalar um programa como superusuário</div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% configure
% make
% su -
Password:
<span class=c># make install</span>
<span class=c># exit</span>
%</code></pre></div></div></div></div><div class=paragraph><p>O framework integrado <a href="https://man.freebsd.org/cgi/man.cgi?query=su&amp;sektion=1&amp;format=html">su(1)</a> funciona bem para sistemas isolados ou redes pequenas com apenas um administrador. Uma alternativa é instalar o pacote ou port <a class=package href=https://cgit.freebsd.org/ports/tree/security/sudo/>security/sudo</a>. Este software fornece registro de atividades e permite ao administrador configurar quais usuários podem executar quais comandos como superusuário.</p></div></div></div><div class=sect3><h4 id=users-modifying>3.3.2. Gerenciando Contas<a class=anchor href=#users-modifying></a></h4><div class=paragraph><p>O FreeBSD fornece uma variedade de diferentes comandos para gerenciar contas de usuários. Os comandos mais comuns são descritos em <a href=#users-modifying-utilities>Utilitários para gerenciar contas de usuários</a>, seguidos por alguns exemplos de seu uso. Veja a página de manual para cada utilitário para maiores detalhes e exemplos de uso.</p></div><table id=users-modifying-utilities class="tableblock frame-none grid-all stretch"><caption class=title>Tabela 2. Utilitários para gerenciar contas de usuários</caption><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Comando</th><th class="tableblock halign-left valign-top">Resumo</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href="https://man.freebsd.org/cgi/man.cgi?query=adduser&amp;sektion=8&amp;format=html">adduser(8)</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Aplicativo de linha de comando recomendado para adicionar novos usuários.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href="https://man.freebsd.org/cgi/man.cgi?query=rmuser&amp;sektion=8&amp;format=html">rmuser(8)</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Aplicativo de linha de comando recomendado para remover usuários.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href="https://man.freebsd.org/cgi/man.cgi?query=chpass&amp;sektion=1&amp;format=html">chpass(1)</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Uma ferramenta flexível para alterar as informações do usuário.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href="https://man.freebsd.org/cgi/man.cgi?query=passwd&amp;sektion=1&amp;format=html">passwd(1)</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Ferramenta de linha de comando para alterar senhas de usuários.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href="https://man.freebsd.org/cgi/man.cgi?query=pw&amp;sektion=8&amp;format=html">pw(8)</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Uma ferramenta poderosa e flexível para modificar todos os aspectos das contas de usuário.</p></td></tr></tbody></table><div class=sect4><h5 id=users-adduser>3.3.2.1. <code>adduser</code><a class=anchor href=#users-adduser></a></h5><div class=paragraph><p>O programa recomendado para adicionar novos usuários é o <a href="https://man.freebsd.org/cgi/man.cgi?query=adduser&amp;sektion=8&amp;format=html">adduser(8)</a>. Quando um novo usuário é adicionado, este programa atualiza automaticamente o <span class=filename>/etc/passwd</span> e o <span class=filename>/etc/group</span>. Ele também cria um diretório inicial para o novo usuário, copia os arquivos de configuração padrão de <span class=filename>/usr/shared/skel</span> e pode, opcionalmente, enviar uma nova mensagem de boas-vindas ao novo usuário. Este utilitário deve ser executado como o superusuário.</p></div><div class=paragraph><p>O utilitário <a href="https://man.freebsd.org/cgi/man.cgi?query=adduser&amp;sektion=8&amp;format=html">adduser(8)</a> é interativo e percorre as etapas para criar uma nova conta de usuário. Como visto em <a href=#users-modifying-adduser>Adicionando um usuário no FreeBSD</a>, insira as informações necessárias ou pressione <kbd>Enter</kbd> para aceitar o valor padrão mostrado entre colchetes. Neste exemplo, o usuário foi convidado para o grupo <code>wheel</code>, permitindo que ele se tornasse o superusuário com o uso do <a href="https://man.freebsd.org/cgi/man.cgi?query=su&amp;sektion=1&amp;format=html">su(1)</a>. Quando terminar, o utilitário perguntará se deseja criar outro usuário ou finalizar o comando.</p></div><div id=users-modifying-adduser class=exampleblock><div class=title>Exemplo 3. Adicionando um usuário no FreeBSD</div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># adduser</span>
Username: jru
Full name: J. Random User
Uid <span class=o>(</span>Leave empty <span class=k>for </span>default<span class=o>)</span>:
Login group <span class=o>[</span>jru]:
Login group is jru. Invite jru into other <span class=nb>groups</span>? <span class=o>[]</span>: wheel
Login class <span class=o>[</span>default]:
Shell <span class=o>(</span>sh csh tcsh zsh nologin<span class=o>)</span> <span class=o>[</span>sh]: zsh
Home directory <span class=o>[</span>/home/jru]:
Home directory permissions <span class=o>(</span>Leave empty <span class=k>for </span>default<span class=o>)</span>:
Use password-based authentication? <span class=o>[</span><span class=nb>yes</span><span class=o>]</span>:
Use an empty password? <span class=o>(</span><span class=nb>yes</span>/no<span class=o>)</span> <span class=o>[</span>no]:
Use a random password? <span class=o>(</span><span class=nb>yes</span>/no<span class=o>)</span> <span class=o>[</span>no]:
Enter password:
Enter password again:
Lock out the account after creation? <span class=o>[</span>no]:
Username   : jru
Password   : <span class=k>****</span>
Full Name  : J. Random User
Uid        : 1001
Class      :
Groups     : jru wheel
Home       : /home/jru
Shell      : /usr/local/bin/zsh
Locked     : no
OK? <span class=o>(</span><span class=nb>yes</span>/no<span class=o>)</span>: <span class=nb>yes
</span>adduser: INFO: Successfully added <span class=o>(</span>jru<span class=o>)</span> to the user database.
Add another user? <span class=o>(</span><span class=nb>yes</span>/no<span class=o>)</span>: no
Goodbye!
<span class=c>#</span></code></pre></div></div></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Como a senha não é mostrada quando digitada, tenha cuidado para não digitar a senha incorretamente ao criar a conta do usuário.</p></div></td></tr></tbody></table></div></div><div class=sect4><h5 id=users-rmuser>3.3.2.2. <code>rmuser</code><a class=anchor href=#users-rmuser></a></h5><div class=paragraph><p>Para remover completamente um usuário do sistema, execute o <a href="https://man.freebsd.org/cgi/man.cgi?query=rmuser&amp;sektion=8&amp;format=html">rmuser(8)</a> como o superusuário. Este comando executa as seguintes etapas:</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Remove a entrada <a href="https://man.freebsd.org/cgi/man.cgi?query=crontab&amp;sektion=1&amp;format=html">crontab(1)</a> do usuário, se existir.</p></li><li><p>Remove todas as tarefas <a href="https://man.freebsd.org/cgi/man.cgi?query=at&amp;sektion=1&amp;format=html">at(1)</a> pertencentes ao usuário.</p></li><li><p>Elimina todos os processos pertencentes ao usuário.</p></li><li><p>Remove o usuário do arquivo de senhas do sistema.</p></li><li><p>Opcionalmente, remove o diretório pessoal do usuário, se ele for de propriedade do usuário.</p></li><li><p>Remove os arquivos de mensagens recebidas pertencentes ao usuário de <span class=filename>/var/mail</span>.</p></li><li><p>Remove todos os arquivos pertencentes ao usuário das áreas de armazenamento de arquivos temporários, como <span class=filename>/tmp</span>.</p></li><li><p>Finalmente, remove o nome de usuário de todos os grupos aos quais ele pertence em <span class=filename>/etc/group</span>. Se um grupo ficar vazio e o nome do grupo for o mesmo que o nome de usuário, o grupo será removido. Isso complementa os grupos exclusivos por usuário criados por <a href="https://man.freebsd.org/cgi/man.cgi?query=adduser&amp;sektion=8&amp;format=html">adduser(8)</a>.</p></li></ol></div></div></div><div class=paragraph><p>O <a href="https://man.freebsd.org/cgi/man.cgi?query=rmuser&amp;sektion=8&amp;format=html">rmuser(8)</a> não pode ser usado para remover contas de superusuário, pois isso quase sempre ocasiona uma de destruição em massa.</p></div><div class=paragraph><p>Por padrão, um modo interativo é usado, conforme mostrado no exemplo a seguir.</p></div><div class=exampleblock><div class=title>Exemplo 4. Remoção de contas interativas com o <code>rmuser</code></div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># rmuser jru</span>
Matching password entry:
jru:<span class=k>*</span>:1001:1001::0:0:J. Random User:/home/jru:/usr/local/bin/zsh
Is this the entry you wish to remove? y
Remove user<span class=s1>&#39;s home directory (/home/jru)? y
Removing user (jru): mailspool home passwd.
#</span></code></pre></div></div></div></div></div><div class=sect4><h5 id=users-chpass>3.3.2.3. <code>chpass</code><a class=anchor href=#users-chpass></a></h5><div class=paragraph><p>Qualquer usuário pode usar o <a href="https://man.freebsd.org/cgi/man.cgi?query=chpass&amp;sektion=1&amp;format=html">chpass(1)</a> para alterar seu shell padrão e informações pessoais associadas à sua conta de usuário. O superusuário pode usar esse utilitário para alterar informações adicionais da conta de qualquer usuário.</p></div><div class=paragraph><p>Quando não há opções, além de um nome de usuário opcional, o <a href="https://man.freebsd.org/cgi/man.cgi?query=chpass&amp;sektion=1&amp;format=html">chpass(1)</a> exibe um editor contendo informações do usuário. Quando o usuário sai do editor, o banco de dados do usuário é atualizado com as novas informações.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Este utilitário solicitará a senha do usuário ao sair do editor, a menos que o utilitário seja executado como superusuário.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Em <a href=#users-modifying-chpass-su>Usando o <code>chpass</code> como superusuário</a>, o superusuário digitou <code>chpass jru</code> e agora está visualizando os campos que podem ser alterados para este usuário. Se <code>jru</code> executar este comando, apenas os últimos seis campos serão exibidos e estarão disponíveis para edição. Isso é mostrado em <a href=#users-modifying-chpass-ru>Usando o <code>chpass</code> como usuário regular</a>.</p></div><div id=users-modifying-chpass-su class=exampleblock><div class=title>Exemplo 5. Usando o <code>chpass</code> como superusuário</div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c>#Changing user database information for jru.</span>
Login: jru
Password: <span class=k>*</span>
Uid <span class=o>[</span><span class=c>#]: 1001</span>
Gid <span class=o>[</span><span class=c># or name]: 1001</span>
Change <span class=o>[</span>month day year]:
Expire <span class=o>[</span>month day year]:
Class:
Home directory: /home/jru
Shell: /usr/local/bin/zsh
Full Name: J. Random User
Office Location:
Office Phone:
Home Phone:
Other information:</code></pre></div></div></div></div><div id=users-modifying-chpass-ru class=exampleblock><div class=title>Exemplo 6. Usando o <code>chpass</code> como usuário regular</div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c>#Changing user database information for jru.</span>
Shell: /usr/local/bin/zsh
Full Name: J. Random User
Office Location:
Office Phone:
Home Phone:
Other information:</code></pre></div></div></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Os comandos <a href="https://man.freebsd.org/cgi/man.cgi?query=chfn&amp;sektion=1&amp;format=html">chfn(1)</a> e <a href="https://man.freebsd.org/cgi/man.cgi?query=chsh&amp;sektion=1&amp;format=html">chsh(1)</a> são links para <a href="https://man.freebsd.org/cgi/man.cgi?query=chpass&amp;sektion=1&amp;format=html">chpass(1)</a>, como são <a href="https://man.freebsd.org/cgi/man.cgi?query=ypchpass&amp;sektion=1&amp;format=html">ypchpass(1)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=ypchfn&amp;sektion=1&amp;format=html">ypchfn(1)</a>e<a href="https://man.freebsd.org/cgi/man.cgi?query=ypchsh&amp;sektion=1&amp;format=html">ypchsh(1)</a>. Já que o suporte ao NIS é automático, colocar o <code>yp</code> antes do comando não é necessário. Os procedimentos para configurar o NIS está documentado em <a href=./#network-servers>Servidores de Rede</a>.</p></div></td></tr></tbody></table></div></div><div class=sect4><h5 id=users-passwd>3.3.2.4. <code>passwd</code><a class=anchor href=#users-passwd></a></h5><div class=paragraph><p>Qualquer usuário pode alterar facilmente sua senha usando o <a href="https://man.freebsd.org/cgi/man.cgi?query=passwd&amp;sektion=1&amp;format=html">passwd(1)</a>. Para prevenir alterações acidentais ou não autorizadas, este comando irá solicitar a senha atual ao usuário antes de configurar uma nova senha:</p></div><div class=exampleblock><div class=title>Exemplo 7. Alterando Sua Senha</div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% passwd
Changing <span class=nb>local </span>password <span class=k>for </span>jru.
Old password:
New password:
Retype new password:
passwd: updating the database...
passwd: <span class=k>done</span></code></pre></div></div></div></div><div class=paragraph><p>O superusuário pode alterar a senha de qualquer usuário especificando o nome de usuário ao executar o <a href="https://man.freebsd.org/cgi/man.cgi?query=passwd&amp;sektion=1&amp;format=html">passwd(1)</a>. Quando este utilitário é executado como superusuário, ele não solicita a senha atual do usuário. Isso permite que a senha seja alterada quando um usuário não consegue lembrar a senha original.</p></div><div class=exampleblock><div class=title>Exemplo 8. Mudando a senha de outro usuário como superusuário</div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># passwd jru</span>
Changing <span class=nb>local </span>password <span class=k>for </span>jru.
New password:
Retype new password:
passwd: updating the database...
passwd: <span class=k>done</span></code></pre></div></div></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Como com o <a href="https://man.freebsd.org/cgi/man.cgi?query=chpass&amp;sektion=1&amp;format=html">chpass(1)</a>, o <a href="https://man.freebsd.org/cgi/man.cgi?query=yppasswd&amp;sektion=1&amp;format=html">yppasswd(1)</a> é um link para <a href="https://man.freebsd.org/cgi/man.cgi?query=passwd&amp;sektion=1&amp;format=html">passwd(1)</a>, então o NIS funciona com ambos os comandos.</p></div></td></tr></tbody></table></div></div><div class=sect4><h5 id=users-pw>3.3.2.5. <code>pw</code><a class=anchor href=#users-pw></a></h5><div class=paragraph><p>O utilitário <a href="https://man.freebsd.org/cgi/man.cgi?query=pw&amp;sektion=8&amp;format=html">pw(8)</a> pode criar, remover, modificar e exibir usuários e grupos. Funciona como um front-end para o usuário do sistema e para os arquivos de grupo. O <a href="https://man.freebsd.org/cgi/man.cgi?query=pw&amp;sektion=8&amp;format=html">pw(8)</a> tem um conjunto muito poderoso de opções de linha de comando que o torna adequado para uso em shell scripts, mas novos usuários podem achar isso mais complicado que os outros comandos apresentados nesta seção.</p></div></div></div><div class=sect3><h4 id=users-groups>3.3.3. Gerenciando Grupos<a class=anchor href=#users-groups></a></h4><div class=paragraph><p>Um grupo é uma lista de usuários. Um grupo é identificado pelo nome do grupo e pelo GID. No FreeBSD, o kernel usa o UID de um processo, e a lista de grupos a que pertence, para determinar o que o processo pode fazer. Na maioria das vezes, o GID de um usuário ou processo geralmente significa o primeiro grupo na lista.</p></div><div class=paragraph><p>O mapeamento do nome do grupo para o GID está listado em <span class=filename>/etc/group</span>. Este é um arquivo de texto simples com quatro campos delimitados por dois pontos. O primeiro campo é o nome do grupo, o segundo é a senha criptografada, o terceiro é o GID e o quarto é a lista de membros delimitados por vírgulas. Para uma descrição mais completa da sintaxe, consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=group&amp;sektion=5&amp;format=html">group(5)</a>.</p></div><div class=paragraph><p>O superusuário pode modificar o <span class=filename>/etc/group</span> usando um editor de texto. Alternativamente, o <a href="https://man.freebsd.org/cgi/man.cgi?query=pw&amp;sektion=8&amp;format=html">pw(8)</a> pode ser usado para adicionar e editar grupos. Por exemplo, para adicionar um grupo chamado <code>teamtwo</code> e confirmar se ele existe:</p></div><div class=exampleblock><div class=title>Exemplo 9. Adicionando um grupo usando o <a href="https://man.freebsd.org/cgi/man.cgi?query=pw&amp;sektion=8&amp;format=html">pw(8)</a></div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pw groupadd teamtwo</span>
<span class=c># pw groupshow teamtwo</span>
teamtwo:<span class=k>*</span>:1100:</code></pre></div></div></div></div><div class=paragraph><p>Neste exemplo, <code>1100</code> é o GID de <code>teamtwo</code>. No momento, <code>teamtwo</code> não possui membros. Este comando adicionará <code>jru</code> como um membro de <code>teamtwo</code>.</p></div><div class=exampleblock><div class=title>Exemplo 10. Adicionando contas de usuários a um novo grupo usando o <a href="https://man.freebsd.org/cgi/man.cgi?query=pw&amp;sektion=8&amp;format=html">pw(8)</a></div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pw groupmod teamtwo -M jru</span>
<span class=c># pw groupshow teamtwo</span>
teamtwo:<span class=k>*</span>:1100:jru</code></pre></div></div></div></div><div class=paragraph><p>O argumento para a opção <code>-M</code> é uma lista de usuários, delimitada por vírgulas, a serem adicionados a um novo grupo (vazio) ou para substituir os membros de um grupo existente. Para o usuário, essa associação ao grupo é diferente (e adicional ao) do grupo principal do usuário listado no arquivo de senha. Isso significa que o usuário não aparecerá como membro ao usar a opção <code>groupshow</code> com o <a href="https://man.freebsd.org/cgi/man.cgi?query=pw&amp;sektion=8&amp;format=html">pw(8)</a>, mas mostrará quando a informação é consultada via <a href="https://man.freebsd.org/cgi/man.cgi?query=id&amp;sektion=1&amp;format=html">id(1)</a> ou uma ferramenta similar. Quando o <a href="https://man.freebsd.org/cgi/man.cgi?query=pw&amp;sektion=8&amp;format=html">pw(8)</a> é usado para adicionar um usuário a um grupo, ele apenas manipula o <span class=filename>/etc/group</span> e não tenta ler dados adicionais do <span class=filename>/etc/passwd</span>.</p></div><div class=exampleblock><div class=title>Exemplo 11. Adicionando um novo membro a um grupo usando o <a href="https://man.freebsd.org/cgi/man.cgi?query=pw&amp;sektion=8&amp;format=html">pw(8)</a></div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pw groupmod teamtwo -m db</span>
<span class=c># pw groupshow teamtwo</span>
teamtwo:<span class=k>*</span>:1100:jru,db</code></pre></div></div></div></div><div class=paragraph><p>Neste exemplo, o argumento para <code>-m</code> é uma lista delimitada por vírgulas de usuários que devem ser adicionados ao grupo. Ao contrário do exemplo anterior, esses usuários são adicionados ao grupo e não substituem usuários existentes no grupo.</p></div><div class=exampleblock><div class=title>Exemplo 12. Usando o <a href="https://man.freebsd.org/cgi/man.cgi?query=id&amp;sektion=1&amp;format=html">id(1)</a> para determinar a associação ao grupo</div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>id </span>jru
<span class=nv>uid</span><span class=o>=</span>1001<span class=o>(</span>jru<span class=o>)</span> <span class=nv>gid</span><span class=o>=</span>1001<span class=o>(</span>jru<span class=o>)</span> <span class=nb>groups</span><span class=o>=</span>1001<span class=o>(</span>jru<span class=o>)</span>, 1100<span class=o>(</span>teamtwo<span class=o>)</span></code></pre></div></div></div></div><div class=paragraph><p>Neste exemplo, <code>jru</code> é um membro dos grupos <code>jru</code> e <code>teamtwo</code>.</p></div><div class=paragraph><p>Para obter mais informações sobre este comando e o formato do <span class=filename>/etc/group</span>, consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=pw&amp;sektion=8&amp;format=html">pw(8)</a> e <a href="https://man.freebsd.org/cgi/man.cgi?query=group&amp;sektion=5&amp;format=html">group(5)</a>.</p></div></div></div><div class=sect2><h3 id=permissions>3.4. Permissões<a class=anchor href=#permissions></a></h3><div class=paragraph><p>No FreeBSD, todo arquivo e diretório tem um conjunto associado de permissões e vários utilitários estão disponíveis para visualizar e modificar essas permissões. É necessário entender como as permissões funcionam para garantir que os usuários consigam acessar os arquivos que precisam e não consigam acessar os arquivos usados pelo sistema operacional ou de propriedade de outros usuários.</p></div><div class=paragraph><p>Esta seção discute as permissões UNIX™ tradicionais usadas no FreeBSD. Para um controle de acesso ao sistema de arquivos mais refinado, consulte <a href=./#fs-acl>Listas de Controle de Acesso</a>.</p></div><div class=paragraph><p>No UNIX™, as permissões básicas são atribuídas usando três tipos de acesso: ler, escrever e executar. Esses tipos de acesso são usados para determinar o acesso do arquivo ao proprietário, ao grupo e a outros usuários do arquivo (todos os outros). As permissões de leitura, gravação e execução podem ser representadas como as letras <code>r</code>, <code>w</code> e <code>x</code>. Elas também podem ser representados como números binários, pois cada permissão está ativada ou desativada (<code>0</code>). Quando representada como um número, a ordem é sempre lida como <code>rwx</code>, onde <code>r</code> é ativado com o valor <code>4</code>, <code>w</code> é ativado com o valor <code>2</code> e <code>x</code> é ativado com o valor <code>1</code>.</p></div><div class=paragraph><p>A Tabela 4.1 resume as possíveis possibilidades numéricas e alfabéticas. Ao ler a coluna "Listagem do Diretório", um <code>-</code> é usado para representar uma permissão que está desativada.</p></div><table class="tableblock frame-none grid-all stretch"><caption class=title>Tabela 3. Permissões UNIX™</caption><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Valor</th><th class="tableblock halign-left valign-top">Permissão</th><th class="tableblock halign-left valign-top">Listagem de diretório</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>0</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Sem leitura, sem escrita, sem execução</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>---</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>1</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Sem leitura, sem escrita, execução</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>--x</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>2</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Sem leitura, escrita, sem execução</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>-w-</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>3</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Sem leitura, escrita, execução</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>-wx</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>4</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Leitura, sem escrita, sem execução</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>r--</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>5</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Leitura, sem escrita, execução</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>r-x</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>6</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Leitura, escrita, sem execução</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>rw-</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>7</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Leitura, escrita, execução</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>rwx</code></p></td></tr></tbody></table><div class=paragraph><p>Use o argumento <code>-l</code> com o <a href="https://man.freebsd.org/cgi/man.cgi?query=ls&amp;sektion=1&amp;format=html">ls(1)</a> para exibir uma lista longa de diretórios que inclua uma coluna de informações sobre um permissões do arquivo para o proprietário, grupo e outros. Por exemplo, um <code>ls -l</code> em um diretório arbitrário pode mostrar:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>ls</span> <span class=nt>-l</span>
total 530
<span class=nt>-rw-r--r--</span>  1 root  wheel     512 Sep  5 12:31 myfile
<span class=nt>-rw-r--r--</span>  1 root  wheel     512 Sep  5 12:31 otherfile
<span class=nt>-rw-r--r--</span>  1 root  wheel    7680 Sep  5 12:31 email.txt</code></pre></div></div><div class=paragraph><p>O primeiro caractere (mais à esquerda) da primeira coluna indica se esse arquivo é um arquivo normal, um diretório, um dispositivo de caractere especial, um soquete ou qualquer outro dispositivo especial de pseudo-arquivo. Neste exemplo, o <code>-</code> indica um arquivo regular. Os próximos três caracteres, <code>rw-</code> neste exemplo, fornecem as permissões para o proprietário do arquivo. Os próximos três caracteres, <code>r--</code>, fornecem as permissões para o grupo ao qual o arquivo pertence. Os três últimos caracteres, <code>r--</code>, dão as permissões para o resto do mundo. Um traço significa que a permissão está desativada. Neste exemplo, as permissões são definidas para que o proprietário possa ler e gravar no arquivo, o grupo possa ler o arquivo e o resto do mundo só possa ler o arquivo. De acordo com a tabela acima, as permissões para este arquivo seriam <code>644</code>, onde cada dígito representa uma das três partes da permissão do arquivo.</p></div><div class=paragraph><p>Como o sistema controla as permissões nos dispositivos? O FreeBSD trata a maioria dos dispositivos de hardware como um arquivo nos quais os programas podem abrir, ler e gravar dados. Esses arquivos de dispositivos especiais são armazenados em <span class=filename>/dev/</span>.</p></div><div class=paragraph><p>Diretórios também são tratados como arquivos. Eles tem permissões de leitura, gravação e execução. O bit executável de um diretório tem um significado ligeiramente diferente que nos arquivos. Quando um diretório é marcado como executável, isso significa que é possível mudar para esse diretório usando <a href="https://man.freebsd.org/cgi/man.cgi?query=cd&amp;sektion=1&amp;format=html">cd(1)</a>. Isso também significa que é possível acessar os arquivos dentro desse diretório, sujeito às permissões dos próprios arquivos.</p></div><div class=paragraph><p>Para executar uma listagem de diretórios, a permissão de leitura deve estar ativada no diretório. Para deletar um arquivo que se conhece o nome, é necessário ter permissões de escrita <em>e</em> execução no diretório que contém o arquivo.</p></div><div class=paragraph><p>Há mais bits de permissão, mas eles são usados principalmente em circunstâncias especiais, como binários setuid e diretórios fixos. Para obter mais informações sobre permissões de arquivos e como configurá-las, consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=chmod&amp;sektion=1&amp;format=html">chmod(1)</a>.</p></div><div class=sect3><h4 id=_permissões_simbólicas>3.4.1. Permissões simbólicas<a class=anchor href=#_permissões_simbólicas></a></h4><div class=paragraph><p>Permissões simbólicas usam caracteres em vez de valores octais para atribuir permissões a arquivos ou diretórios. Permissões simbólicas usam a sintaxe de (quem) (ação) (permissões), onde os seguintes valores estão disponíveis:</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Opção</th><th class="tableblock halign-left valign-top">Letra</th><th class="tableblock halign-left valign-top">Representa</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>(quem)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>u</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Usuário</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>(quem)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>g</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Grupo</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>(quem)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>o</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Outros</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>(quem)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>a</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Todos ("resto do mundo")</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>(açao)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>+</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Adiciona permissões</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>(açao)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>-</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Remove permissões</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>(açao)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>=</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Permissões definidas explicitamente</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>(permissões)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>r</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Leitura</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>(permissões)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>w</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Escrita</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>(permissões)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>x</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Execução</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>(permissões)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>t</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>bit fixador</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>(permissões)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>s</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Set UID ou GID</p></td></tr></tbody></table><div class=paragraph><p>Esses valores são usados com o <a href="https://man.freebsd.org/cgi/man.cgi?query=chmod&amp;sektion=1&amp;format=html">chmod(1)</a>, mas com letras em vez de números. Por exemplo, o comando a seguir impediria que outros usuários acessassem <em>FILE</em>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>chmod </span><span class=nv>go</span><span class=o>=</span> FILE</code></pre></div></div><div class=paragraph><p>Uma lista separada por vírgula pode ser fornecida quando mais de um conjunto de alterações em um arquivo precisar ser feito. Por exemplo, o comando a seguir remove as permissões de gravação do grupo e "resto do mundo" no <em>FILE</em> e adiciona as permissões de execução para todos:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>chmod </span>go-w,a+x FILE</code></pre></div></div></div><div class=sect3><h4 id=_flags_de_arquivos_no_freebsd>3.4.2. Flags de arquivos no FreeBSD<a class=anchor href=#_flags_de_arquivos_no_freebsd></a></h4><div class=paragraph><p>Além das permissões de arquivo, o FreeBSD suporta o uso de "flags de arquivo". Esses sinalizadores adicionam um nível a mais de segurança e controle sobre os arquivos, mas não nos diretórios. Com flags de arquivos, mesmo o <code>root</code> pode ser impedido de remover ou alterar arquivos.</p></div><div class=paragraph><p>Os sinalizadores de arquivo são modificados usando o <a href="https://man.freebsd.org/cgi/man.cgi?query=chflags&amp;sektion=1&amp;format=html">chflags(1)</a>. Por exemplo, para ativar o sinalizador undeletable do sistema no arquivo <span class=filename>file1</span>, use o seguinte comando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># chflags sunlink file1</span></code></pre></div></div><div class=paragraph><p>Para desabilitar o sinalizador undeletable do sistema, coloque um "no" na frente do <code>sunlink</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># chflags nosunlink file1</span></code></pre></div></div><div class=paragraph><p>Para visualizar os sinalizadores de um arquivo, use <code>-lo</code> com o <a href="https://man.freebsd.org/cgi/man.cgi?query=ls&amp;sektion=1&amp;format=html">ls(1)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ls -lo file1</span></code></pre></div></div><div class="literalblock programlisting"><div class=content><pre>-rw-r--r-- 1 trhodes trhodes sunlnk 0 Mar 1 05:54 file1</pre></div></div><div class=paragraph><p>Vários flags de arquivo só podem ser adicionados ou removidos pelo usuário <code>root</code>. Em outros casos, o proprietário do arquivo pode definir seus sinalizadores. Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=chflags&amp;sektion=1&amp;format=html">chflags(1)</a> e <a href="https://man.freebsd.org/cgi/man.cgi?query=chflags&amp;sektion=2&amp;format=html">chflags(2)</a> para maiores informações.</p></div></div><div class=sect3><h4 id=_as_permissões_setuid_setgid_e_sticky>3.4.3. As permissões <code>setuid</code>, <code>setgid</code> e <code>sticky</code><a class=anchor href=#_as_permissões_setuid_setgid_e_sticky></a></h4><div class=paragraph><p>Além das permissões já discutidas, existem três outras configurações específicas que todos os administradores devem conhecer. Eles são as permissões <code>setuid</code>, <code>setgid</code> e <code>sticky</code>.</p></div><div class=paragraph><p>Essas configurações são importantes para algumas operações UNIX™, pois fornecem funcionalidades normalmente não concedidas a usuários normais. Para compreendê-los, a diferença entre o ID real de usuário e o ID efetivo de usuário deve ser explicada.</p></div><div class=paragraph><p>O ID de usuário real é o UID que inicia ou é o dono do processo. O ID de usuário efetivo é o UID do usuário com o qual o processo é executado. Por exemplo, o <a href="https://man.freebsd.org/cgi/man.cgi?query=passwd&amp;sektion=1&amp;format=html">passwd(1)</a> é executado com o ID do usuário real quando um usuário altera sua senha. No entanto, para atualizar o banco de dados de senhas, o comando é executado como o ID efetivo do usuário <code>root</code>. Isso permite que os usuários alterem suas senhas sem ver um erro <code>Permission Denied</code>.</p></div><div class=paragraph><p>A permissão setuid pode ser definida prefixando um conjunto de permissões com o número quatro (4), conforme mostrado no exemplo a seguir:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># chmod 4755 suidexample.sh</span></code></pre></div></div><div class=paragraph><p>As permissões em <span class=filename>suidexample.sh</span> agora se parecem com o seguinte:</p></div><div class="literalblock programlisting"><div class=content><pre>-rwsr-xr-x   1 trhodes  trhodes    63 Aug 29 06:36 suidexample.sh</pre></div></div><div class=paragraph><p>Observe que um <code>s</code> agora faz parte do conjunto de permissões designado para o proprietário do arquivo, substituindo o bit executável. Isso viabiliza utilitários que precisam de permissões elevadas, como o <a href="https://man.freebsd.org/cgi/man.cgi?query=passwd&amp;sektion=1&amp;format=html">passwd(1)</a>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>A opção <code>nosuid</code> <a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a> fará com que esses binários falhem silenciosamente sem alertar o usuário. Essa opção não é totalmente confiável, já que um wrapper <code>nosuid</code> pode contorná-la.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Para ver isso em tempo real, abra dois terminais. Em um deles, digite <code>passwd</code> como um usuário normal. Enquanto aguarda uma nova senha, verifique a tabela de processos e observe as informações de usuário do <a href="https://man.freebsd.org/cgi/man.cgi?query=passwd&amp;sektion=1&amp;format=html">passwd(1)</a>:</p></div><div class=paragraph><p>No terminal A:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Changing <span class=nb>local </span>password <span class=k>for </span>trhodes
Old Password:</code></pre></div></div><div class=paragraph><p>No terminal B:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ps aux | grep passwd</span></code></pre></div></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>trhodes  5232  0.0  0.2  3420  1608   0  R+    2:10AM   0:00.00 <span class=nb>grep </span>passwd
root     5211  0.0  0.2  3620  1724   2  I+    2:09AM   0:00.01 passwd</code></pre></div></div><div class=paragraph><p>Embora <a href="https://man.freebsd.org/cgi/man.cgi?query=passwd&amp;sektion=1&amp;format=html">passwd(1)</a> seja executado como um usuário normal, ele está usando o UID do <code>root</code>.</p></div><div class=paragraph><p>A permissão <code>setgid</code> executa a mesma função que a permissão <code>setuid</code>; exceto que altera as configurações do grupo. Quando um aplicativo ou utilitário é executado com essa configuração, ele recebe as permissões com base no grupo do arquivo, não no usuário que iniciou o processo.</p></div><div class=paragraph><p>Para definir a permissão <code>setgid</code> em um arquivo, execute o <a href="https://man.freebsd.org/cgi/man.cgi?query=chmod&amp;sektion=1&amp;format=html">chmod(1)</a> com dois (2) no início:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># chmod 2755 sgidexample.sh</span></code></pre></div></div><div class=paragraph><p>Na listagem a seguir, observe que o <code>s</code> está agora no campo designado para as configurações de permissão do grupo:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=nt>-rwxr-sr-x</span>   1 trhodes  trhodes    44 Aug 31 01:49 sgidexample.sh</code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Nestes exemplos, mesmo que o shell script em questão seja um arquivo executável, ele não será executado com um EUID diferente ou um ID de usuário efetivo. Isso ocorre porque os shell scripts podem não acessar as chamadas de sistema <a href="https://man.freebsd.org/cgi/man.cgi?query=setuid&amp;sektion=2&amp;format=html">setuid(2)</a>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Os bits de permissão <code>setuid</code> e <code>setgid</code> podem diminuir a segurança do sistema, permitindo permissões elevadas. A terceira permissão especial, o <code>sticky bit</code>, pode fortalecer a segurança de um sistema.</p></div><div class=paragraph><p>Quando o <code>sticky bit</code> é definido em um diretório, ele permite a exclusão de arquivos apenas pelo proprietário do arquivo. Isso é útil para impedir a exclusão de arquivos em diretórios públicos, como <span class=filename>/tmp</span>, por usuários que não possuem o arquivo. Para utilizar essa permissão, use o um (1) no início das permissões:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># chmod 1777 /tmp</span></code></pre></div></div><div class=paragraph><p>A permissão <code>sticky bit</code> será exibida como um <code>t</code> no final do conjunto de permissões:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ls -al / | grep tmp</span></code></pre></div></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>drwxrwxrwt  10 root  wheel         512 Aug 31 01:49 tmp</code></pre></div></div></div></div><div class=sect2><h3 id=dirstructure>3.5. Estrutura de Diretórios<a class=anchor href=#dirstructure></a></h3><div class=paragraph><p>Entender a hierarquia de diretórios do FreeBSD é fundamental para obter uma compreensão geral do sistema. O diretório mais importante é o root ou raiz ou "/". Esse diretório é o primeiro montado no momento da inicialização e contém a base do sistema necessária para preparar o sistema operacional para a operação multi-usuário. O diretório raiz também contém pontos de montagem para outros sistemas de arquivos que são montados durante a transição para a operação multi-usuário.</p></div><div class=paragraph><p>Um ponto de montagem é um diretório no qual sistemas de arquivos adicionais podem ser disponibilizados em um sistema de arquivos principal (geralmente o sistema de arquivos raiz). Isso é descrito em <a href=#disk-organization>Organização dos Discos</a>. Os pontos de montagem padrão incluem <span class=filename>/usr/</span>, <span class=filename>/var/</span>, <span class=filename>/tmp/</span>, <span class=filename>/mnt/</span> e <span class=filename>/cdrom/</span>. Esses diretórios são geralmente associados a entradas em <span class=filename>/etc/fstab</span>. Este arquivo é uma tabela de vários sistemas de arquivos e pontos de montagem e é lido pelo sistema. A maioria dos sistemas de arquivos em <span class=filename>/etc/fstab</span> é montada automaticamente no momento da inicialização do script <a href="https://man.freebsd.org/cgi/man.cgi?query=rc&amp;sektion=8&amp;format=html">rc(8)</a> a não ser que haja a opção <code>noauto</code>. Maiores detalhes em <a href=#disks-fstab>O arquivo <span class=filename>fstab</span></a>.</p></div><div class=paragraph><p>Uma descrição completa da hierarquia do sistema de arquivos está disponível em <a href="https://man.freebsd.org/cgi/man.cgi?query=hier&amp;sektion=7&amp;format=html">hier(7)</a>. A tabela a seguir fornece uma visão geral dos diretórios mais comuns.</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Diretório</th><th class="tableblock halign-left valign-top">Descrição</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Diretório raiz do sistema de arquivos.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/bin/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Utilitários de usuário fundamentais para ambientes mono e multi-usuário.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/boot/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Programas e arquivos de configuração usados durante o bootstrap do sistema operacional.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/boot/defaults/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Arquivos de configuração de inicialização padrão. Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=loader.conf&amp;sektion=5&amp;format=html">loader.conf(5)</a> para maiores detalhes.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/dev/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Nós de dispositivo (device nodes). Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=intro&amp;sektion=4&amp;format=html">intro(4)</a> para detalhes.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/etc/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Arquivos de configuração do sistema e scripts.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/etc/defaults/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Arquivos padrão de configuração do sistema. Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=rc&amp;sektion=8&amp;format=html">rc(8)</a> para maiores detalhes.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/etc/mail/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Arquivos de configuração para agentes de transporte de mensagens, como o <a href="https://man.freebsd.org/cgi/man.cgi?query=sendmail&amp;sektion=8&amp;format=html">sendmail(8)</a>.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/etc/periodic/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Scripts que são executados diariamente, semanalmente e mensalmente, por meio do <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a>. Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=periodic&amp;sektion=8&amp;format=html">periodic(8)</a> para maiores detalhes.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/etc/ppp/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Arquivos de configuração do <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a>.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/mnt/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Diretório vazio comumente usado pelos administradores do sistema como um ponto de montagem temporário.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/proc/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Sistema de arquivos de processos. Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=procfs&amp;sektion=5&amp;format=html">procfs(5)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=mount_procfs&amp;sektion=8&amp;format=html">mount_procfs(8)</a> para detalhes.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/rescue/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Programas vinculados estaticamente para recuperação de emergência, conforme descrito em <a href="https://man.freebsd.org/cgi/man.cgi?query=rescue&amp;sektion=8&amp;format=html">rescue(8)</a>.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/root/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Diretório da conta <code>root</code>.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/sbin/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Programas do sistema e utilitários de administração fundamentais para ambientes mono e multi-usuário.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/tmp/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Arquivos temporários que normalmente <em>não</em> são preservados em uma reinicialização do sistema. Um sistema de arquivos baseado em memória é frequentemente montado em <span class=filename>/tmp</span>. Isso pode ser automatizado usando as variáveis relacionadas ao tmpmfs do <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a> ou com uma entrada em <span class=filename>/etc/fstab</span>; consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=mdmfs&amp;sektion=8&amp;format=html">mdmfs(8)</a> para maiores detalhes.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>A maioria dos utilitários e aplicativos do usuário.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/bin/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Utilitários comuns, ferramentas de programação e aplicativos.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/include/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Arquivos para "include" do C padrão.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/lib/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Arquivos de biblioteca.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/libdata/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Diversos arquivos de dados de utilitários.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/libexec/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Daemons do sistema e utilitários do sistema executados por outros programas.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/local/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Executáveis e bibliotecas locais. Também é usado como o destino padrão para o framework do ports do FreeBSD. Dentro do <span class=filename>/usr/local</span>, o layout geral esboçado por <a href="https://man.freebsd.org/cgi/man.cgi?query=hier&amp;sektion=7&amp;format=html">hier(7)</a> para <span class=filename>/usr</span> deve ser usado. Exceções são o diretório man, que está diretamente sob <span class=filename>/usr/local</span> em vez de sob <span class=filename>/usr/local/share</span>, e a documentação do ports está em <span class=filename>share/doc/port</span>.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/obj/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Árvore de destino específica da arquitetura produzida pela construção da árvore <span class=filename>/usr/src</span>.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/ports/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>A Coleção de Ports do FreeBSD (opcional).</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/sbin/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Daemons do sistema e utilitários do sistema executados pelos usuários.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/shared/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Arquivos independentes de arquitetura.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/src/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Arquivos do código-fonte do BSD.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/var/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Arquivos de log de múltiplos propósitos, temporários, transientes e de spool. Um sistema de arquivos baseado em memória às vezes é montado em <span class=filename>/var</span>. Isso pode ser automatizado usando as variáveis relacionadas ao varmfs em <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a> ou com uma entrada em <span class=filename>/etc/fstab</span>; consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=mdmfs&amp;sektion=8&amp;format=html">mdmfs(8)</a> para maiores detalhes.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/var/log/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Diversos arquivos de log do sistema.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/var/mail/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Arquivos de caixa de correio do usuário.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/var/spool/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Diretórios de spooling de impressoras e sistemas de email.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/var/tmp/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Arquivos temporários que geralmente são preservados em uma reinicialização do sistema, a menos que <span class=filename>/var</span> seja um sistema de arquivos baseado em memória.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/var/yp/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Mapas de NIS.</p></td></tr></tbody></table></div><div class=sect2><h3 id=disk-organization>3.6. Organização dos Discos<a class=anchor href=#disk-organization></a></h3><div class=paragraph><p>A menor unidade de organização que o FreeBSD usa para encontrar arquivos é o nome do arquivo. Os nomes dos arquivos diferenciam maiúsculas de minúsculas, o que significa que <span class=filename>readme.txt</span> e <span class=filename>README.TXT</span> são dois arquivos distintos. O FreeBSD não usa a extensão de um arquivo para determinar se é um programa, documento ou alguma outra forma de dados.</p></div><div class=paragraph><p>Os arquivos são armazenados em diretórios. Um diretório pode não conter arquivos ou pode conter centenas deles. Um diretório também pode conter outros diretórios, permitindo uma hierarquia de diretórios entre si para organizar os dados.</p></div><div class=paragraph><p>Arquivos e diretórios são referenciados por meio de um nome, seguido por uma barra, <code>/</code>, seguido por qualquer outro nome de diretório que seja necessário. Por exemplo, se o diretório <span class=filename>foo</span> contiver um diretório <span class=filename>bar</span> que contenha o arquivo <span class=filename>readme.txt</span>, o nome completo ou <em>caminho</em>, para o arquivo é <span class=filename>foo/bar/readme.txt</span>. Observe que isso é diferente do Windows™ que usa <code>\</code> para separar nomes de arquivos e diretórios. O FreeBSD não usa letras de unidades ou outros nomes de unidades no caminho. Por exemplo, não se deve digitar <span class=filename>c:\foo\bar\readme.txt</span> no FreeBSD.</p></div><div class=paragraph><p>Diretórios e arquivos são armazenados em um sistema de arquivos. Cada sistema de arquivos contém exatamente um diretório no nível superior, chamado de <em>diretório raiz</em> para esse sistema de arquivos. Este diretório raiz pode conter outros diretórios. Um sistema de arquivos é designado como <em>sistema de arquivos raiz</em> ou <code>/</code>. Todos os outros sistemas de arquivos são <em>montados</em> no sistema de arquivos raiz. Não importa quantos discos estejam no sistema FreeBSD, cada diretório parece fazer parte do mesmo disco.</p></div><div class=paragraph><p>Considere três sistemas de arquivos, chamados <code>A</code>, <code>B</code> e <code>C</code>. Cada sistema de arquivos tem um diretório raiz, que contém dois outros diretórios, chamados <code>A1</code>, <code>A2</code> (e da mesma forma <code>B1</code>, <code>B2</code> e <code>C1</code>, <code>C2</code>).</p></div><div class=paragraph><p>Chame <code>A</code> de sistema de arquivos raiz. Se <a href="https://man.freebsd.org/cgi/man.cgi?query=ls&amp;sektion=1&amp;format=html">ls(1)</a> for usado para visualizar o conteúdo deste diretório, ele mostrará dois subdiretórios, <code>A1</code> e <code>A2</code>. A árvore de diretórios tem esta aparência:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/basics/example-dir1.png alt="example dir1"></div></div><div class=paragraph><p>Um sistema de arquivos deve ser montado em um diretório em outro sistema de arquivos. Ao montar o sistema de arquivos <code>B</code> no diretório <code>A1</code>, o diretório raiz de <code>B</code> substitui <code>A1</code> e os diretórios em <code>B</code> aparecem de acordo:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/basics/example-dir2.png alt="example dir2"></div></div><div class=paragraph><p>Todos os arquivos que estão nos diretórios <code>B1</code> ou <code>B2</code> podem ser alcançados com o caminho <span class=filename>/A1/B1</span> ou <span class=filename>/A1/B2</span>, conforme necessário. Todos os arquivos que estavam em <span class=filename>/A1</span> foram temporariamente ocultados. Eles reaparecerão se <code>B</code> for <em>desmontado</em> de <code>A</code>.</p></div><div class=paragraph><p>Se <code>B</code> tivesse sido montado em <code>A2</code>, o diagrama ficaria assim:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/basics/example-dir3.png alt="example dir3"></div></div><div class=paragraph><p>e os caminhos seriam <span class=filename>/A2/B1</span> e <span class=filename>/A2/B2</span> respectivamente.</p></div><div class=paragraph><p>Os sistemas de arquivos podem ser montados uns em cima dos outros. Continuando o último exemplo, o sistema de arquivos <code>C</code> pode ser montado no topo do diretório <code>B1</code> no sistema de arquivos <code>B</code>, levando a esta disposição:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/basics/example-dir4.png alt="example dir4"></div></div><div class=paragraph><p>Ou <code>C</code> poderia ser montado diretamente no sistema de arquivos <code>A</code>, sob o diretório <code>A1</code>:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/basics/example-dir5.png alt="example dir5"></div></div><div class=paragraph><p>É perfeitamente possível ter um sistema de arquivos raiz grande e não precisar criar nenhum outro. Existem algumas desvantagens nessa abordagem e uma vantagem.</p></div><div class=ulist><div class=title>Benefícios de vários sistemas de arquivos</div><ul><li><p>Sistemas de arquivos diferentes podem ter diferentes <em>opções de montagem</em>. Por exemplo, o sistema de arquivos raiz pode ser montado somente para leitura, impossibilitando que os usuários excluam ou editem inadvertidamente um arquivo crítico. Separar sistemas de arquivos graváveis pelo usuário, como <span class=filename>/home</span>, de outros sistemas de arquivos permite que eles sejam montados como <em>nosuid</em>. Essa opção impede que os bits <em>suid</em>/<em>guid</em> dos executáveis armazenados no sistema de arquivos entrem em vigor, possivelmente melhorando a segurança.</p></li><li><p>O FreeBSD otimiza automaticamente o layout dos arquivos em um sistema de arquivos, dependendo de como o sistema de arquivos está sendo usado. Portanto, um sistema de arquivos que contém muitos arquivos pequenos que são gravados com freqüência terá uma otimização diferente para um que contenha menos arquivos maiores. Ao ter um sistema de arquivos maior, essa otimização é quebrada.</p></li><li><p>Os sistemas de arquivos do FreeBSD são robustos se a energia for perdida. No entanto, uma perda de energia em um ponto crítico ainda pode danificar a estrutura do sistema de arquivos. Ao dividir dados em vários sistemas de arquivos, é mais provável que o sistema ainda inicialize, facilitando a restauração do backup conforme necessário.</p></li></ul></div><div class=ulist><div class=title>Benefício de um sistema de arquivos único</div><ul><li><p>Os sistemas de arquivos são de tamanho fixo. Se você cria um sistema de arquivos quando instala o FreeBSD e dá a ele um tamanho específico, você pode descobrir mais tarde que precisa aumentar a partição. Isso não é facilmente realizado sem um backup, recriando o sistema de arquivos com o novo tamanho e, em seguida, restaurando os dados de backup.</p><div class="admonitionblock important"><table><tbody><tr><td class=icon><i class="fa icon-important" title=Important></i></td><td class=content><div class=paragraph><p>O FreeBSD possui o comando <a href="https://man.freebsd.org/cgi/man.cgi?query=growfs&amp;sektion=8&amp;format=html">growfs(8)</a>, que torna possível aumentar o tamanho do sistema de arquivos enquanto montado, removendo essa limitação.</p></div></td></tr></tbody></table></div></li></ul></div><div class=paragraph><p>Os sistemas de arquivos estão contidos em partições. Isto não tem o mesmo significado que o uso comum do termo partição (por exemplo, a partição MS-DOS™), por causa da herança UNIX™ do FreeBSD. Cada partição é identificada por uma letra de <code>a</code> até <code>h</code>. Cada partição pode conter apenas um sistema de arquivos, o que significa que os sistemas de arquivos geralmente são descritos por seu ponto de montagem típico na hierarquia do sistema de arquivos ou pela letra da partição em que estão contidos.</p></div><div class=paragraph><p>O FreeBSD também usa espaço em disco para <em>espaço de swap</em> para fornecer <em>memória virtual</em>. Isso permite que o seu computador se comporte como se tivesse muito mais memória do que realmente tem. Quando o FreeBSD fica sem memória, ele move alguns dos dados que não estão sendo usados atualmente para o espaço de swap, e os move de volta (removendo alguma outra coisa) quando precisa.</p></div><div class=paragraph><p>Algumas partições possuem certas convenções associadas a elas.</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Partição</th><th class="tableblock halign-left valign-top">Convenção</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>a</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Normalmente contém o sistema de arquivos raiz.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>b</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Normalmente contém espaço de swap.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>c</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Normalmente o mesmo tamanho da slice que a envolve. Isso permite que os programas que precisem trabalhar na slice inteira, como um scanner de bloco defeituoso, trabalhem na partição <code>c</code>. Um sistema de arquivos normalmente não seria criado nessa partição.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>d</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>A partição <code>d</code> costumava ter um significado especial associado a ela, mas isso foi descontinuado e <code>d</code> pode funcionar como qualquer partição normal.</p></td></tr></tbody></table><div class=paragraph><p>Os discos no FreeBSD são divididos em slices, referidas no Windows™ como partições, numeradas de 1 a 4. Estas são então divididas em partições, que contêm sistemas de arquivos, e são rotuladas usando letras.</p></div><div class=paragraph><p>Os números das slices seguem o nome do dispositivo, prefixado com um <code>s</code>, começando em 1. Então "da0<em>s1</em>" é a primeira slice na primeira unidade SCSI. Pode haver apenas quatro slices físicas em um disco, mas pode haver slices lógicas dentro de slices físicas do tipo apropriado. Essas slices estendidas são numeradas a partir de 5, então "ada0<em>s5</em>" é a primeira slice estendida no primeiro disco SATA. Esses dispositivos são usados por sistemas de arquivos que esperam ocupar uma slice.</p></div><div class=paragraph><p>Slices, unidades físicas "perigosamente dedicadas" e outras unidades contêm <em>partições</em>, que são representadas como letras de <code>a</code> até <code>h</code>. Esta letra é adicionada ao nome do dispositivo, então "da0<em>a</em>" é a partição <code>a</code> na primeira unidade <code>da</code>, que é "perigosamente dedicada". A "ada1s3<em>e</em>" é a quinta partição na terceira slice da segunda unidade de disco SATA.</p></div><div class=paragraph><p>Finalmente, cada disco no sistema é identificado. Um nome de disco começa com um código que indica o tipo de disco e, em seguida, um número, indicando qual é o disco. Ao contrário das slices, a numeração de discos começa em 0. Códigos usuais são listados em <a href=#disks-naming>Nomes de dispositivos de disco</a>.</p></div><div class=paragraph><p>Ao se referir a uma partição, inclua o nome do disco, <code>s</code>, o número da slice, em seguida, a letra da partição. Exemplos são mostrados em <a href=#basics-disk-slice-part>Exemplo de Nomes de Disco, Slice e Partição</a>.</p></div><div class=paragraph><p><a href=#basics-concept-disk-model>Modelo conceitual de um disco</a> mostra um modelo conceitual de um layout de disco.</p></div><div class=paragraph><p>Ao instalar o FreeBSD, configure as slices de disco, crie partições dentro da slice a ser usada para o FreeBSD, crie um sistema de arquivos ou espaço de swap em cada partição e decida onde cada sistema de arquivos será montado.</p></div><table id=disks-naming class="tableblock frame-none grid-all stretch"><caption class=title>Tabela 4. Nomes de dispositivos de disco</caption><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Tipo de drive</th><th class="tableblock halign-left valign-top">Nome do drive</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>discos rígidos SATA e IDE</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>ada</code> ou <code>ad</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Discos rígidos SCSI e dispositivos de armazenamento USB</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>da</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>drives de CD-ROMSATA e IDE</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>cd</code> ou <code>acd</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Unidades SCSICD-ROM</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>cd</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Unidades de disquete</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>fd</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Unidades de CD-ROM não-padrão variadas</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>mcd</code> para CD-ROM Mitsumi e <code>scd</code> para dispositivos de CD-ROM Sony</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Unidades de fita SCSI</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>sa</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Unidades de fita IDE</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>ast</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Drives RAID</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Exemplos incluem <code>aacd</code> para Adaptec™ AdvancedRAID, <code>mlxd</code> e <code>mlyd</code> para Mylex™, <code>amrd</code> para AMI MegaRAID™, <code>idad</code> para Compaq Smart RAID, <code>twed</code> para 3ware™ RAID.</p></td></tr></tbody></table><div id=basics-disk-slice-part class=exampleblock><div class=title>Exemplo 13. Exemplo de Nomes de Disco, Slice e Partição</div><div class=content><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Nome</th><th class="tableblock halign-left valign-top">Significado</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>ada0s1a</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>A primeira partição (<code>a</code>) na primeira slice (<code>s1</code>) no primeiro disco SATA (<code>ada0</code>).</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>da1s2e</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>A quinta partição (<code>e</code>) na segunda slice (<code>s2</code>) no segundo disco SCSI (<code>da1</code>).</p></td></tr></tbody></table></div></div><div id=basics-concept-disk-model class=exampleblock><div class=title>Exemplo 14. Modelo conceitual de um disco</div><div class=content><div class=paragraph><p>Este diagrama mostra a visão do FreeBSD do primeiro disco SATA conectado ao sistema. Suponha que o disco tenha 250 GB de tamanho e contenha uma slice de 80 GB e uma slice de 170 GB (partições MS-DOS™). A primeira slice contém um sistema de arquivos Windows™NTFS, <span class=filename>C:</span>, e a segunda fatia contém uma instalação do FreeBSD. Este exemplo de instalação do FreeBSD possui quatro partições de dados e uma partição swap.</p></div><div class=paragraph><p>Cada uma das quatro partições contém um sistema de arquivos. A partição <code>a</code> é usada para o sistema de arquivos raiz, <code>d</code> para <span class=filename>/var/</span>, <code>e</code> para <span class=filename>/tmp/</span> e <code>f</code> para <span class=filename>/usr/</span>. A letra de partição <code>c</code> refere-se à fatia inteira e, portanto, não é usada para partições comuns.</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/basics/disk-layout.png alt="disk layout"></div></div></div></div></div><div class=sect2><h3 id=mount-unmount>3.7. Montando e Desmontando Sistemas de Arquivos<a class=anchor href=#mount-unmount></a></h3><div class=paragraph><p>O sistema de arquivos é melhor visualizado como uma árvore, enraizada, por assim dizer, em <span class=filename>/</span>. O <span class=filename>/dev</span>, <span class=filename>/usr</span>, e os outros diretórios no diretório raiz são ramos, que podem ter suas próprias ramificações, como <span class=filename>/usr/local</span> e assim por diante.</p></div><div class=paragraph><p>Existem várias razões para abrigar alguns desses diretórios em sistemas de arquivos separados. O <span class=filename>/var</span> contém os diretórios <span class=filename>log/</span>, <span class=filename>spool/</span> e vários tipos de arquivos temporários e, como tal, podem encher. Encher completamente o sistema de arquivos raiz não é uma boa ideia, então separar o <span class=filename>/var</span> do <span class=filename>/</span> geralmente é vantajoso.</p></div><div class=paragraph><p>Outro motivo comum para colocar determinadas árvores de diretório em outros sistemas de arquivos é se elas forem ser armazenadas em discos físicos separados ou se são discos virtuais separados, tal como montagens de NFS (Network File System), descritas em <a href=./#network-nfs>Network File System (NFS)</a> ou unidades de CD-ROM.</p></div><div class=sect3><h4 id=disks-fstab>3.7.1. O arquivo <span class=filename>fstab</span><a class=anchor href=#disks-fstab></a></h4><div class=paragraph><p>Durante o processo de inicialização (<a href=./#boot>O processo de inicialização do FreeBSD</a>), os sistemas de arquivos listados em <span class=filename>/etc/fstab</span> são automaticamente montados, exceto pelas entradas que contêm <code>noauto</code>. Este arquivo contém entradas no seguinte formato:</p></div><div class="literalblock programlisting"><div class=content><pre>device       /mount-point fstype     options      dumpfreq     passno</pre></div></div><div class=dlist><dl><dt class=hdlist1><code>device</code></dt><dd><p>Um nome de dispositivo existente, conforme explicado em <a href=#disks-naming>Nomes de dispositivos de disco</a>.</p></dd><dt class=hdlist1><code>mount-point</code></dt><dd><p>Um diretório existente no qual montar o sistema de arquivos.</p></dd><dt class=hdlist1><code>fstype</code></dt><dd><p>O tipo de sistema de arquivos para passar para o <a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a>. O sistema de arquivos padrão do FreeBSD é o <code>ufs</code>.</p></dd><dt class=hdlist1><code>options</code></dt><dd><p><code>rw</code> para sistemas de arquivos de leitura/gravação, ou <code>ro</code> para sistemas de arquivos somente de leitura, seguidos por quaisquer outras opções que possam ser necessárias. Uma opção comum é <code>noauto</code> para sistemas de arquivos normalmente não montados durante a seqüência de inicialização. Outras opções estão listadas em <a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a>.</p></dd><dt class=hdlist1><code>dumpfreq</code></dt><dd><p>Usado pelo <a href="https://man.freebsd.org/cgi/man.cgi?query=dump&amp;sektion=8&amp;format=html">dump(8)</a> para determinar quais sistemas de arquivos requerem o dump. Se o campo estiver faltando, um valor zero será assumido.</p></dd><dt class=hdlist1><code>passno</code></dt><dd><p>Determina a ordem em que os sistemas de arquivos devem ser verificados. Os sistemas de arquivos que devem ser ignorados devem ter seu <code>passno</code> definido como zero. O sistema de arquivos raiz precisa ser verificado antes de todo o restante e deve ter seu <code>passno</code> definido como um. Os outros sistemas de arquivos devem ser configurados para valores maiores que um. Se mais de um sistema de arquivos tiver o mesmo <code>passno</code>, o <a href="https://man.freebsd.org/cgi/man.cgi?query=fsck&amp;sektion=8&amp;format=html">fsck(8)</a> tentará verificar os sistemas de arquivos em paralelo, se possível.</p></dd></dl></div><div class=paragraph><p>Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=fstab&amp;sektion=5&amp;format=html">fstab(5)</a> para obter maiores informações sobre o formato do <span class=filename>/etc/fstab</span> e suas opções.</p></div></div><div class=sect3><h4 id=disks-mount>3.7.2. Usando o <a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a><a class=anchor href=#disks-mount></a></h4><div class=paragraph><p>Os sistemas de arquivos são montados usando o comando <a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a>. A sintaxe mais básica é a seguinte:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount device mountpoint</span></code></pre></div></div><div class=paragraph><p>Este comando fornece muitas opções que são descritas em <a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a>. As opções mais usadas incluem:</p></div><div class=dlist><div class=title>Opções de montagem</div><dl><dt class=hdlist1><code>-a</code></dt><dd><p>Monte todos os sistemas de arquivos listados em <span class=filename>/etc/fstab</span>, exceto aqueles marcados como "noauto", excluídos pela opção <code>-t</code>, ou aqueles que já estão montados.</p></dd><dt class=hdlist1><code>-d</code></dt><dd><p>Faz tudo, exceto a chamada real do sistema de montagem. Esta opção é útil em conjunto com a opção <code>-v</code> para determinar o que o <a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a> está realmente tentando fazer.</p></dd><dt class=hdlist1><code>-f</code></dt><dd><p>Força a montagem de um sistema de arquivos sujo (perigoso) ou a revogação do acesso de gravação ao fazer o downgrade do status de montagem de um sistema de arquivos de leitura/gravação para somente leitura.</p></dd><dt class=hdlist1><code>-r</code></dt><dd><p>Monta o sistema de arquivos somente para leitura. Isso é idêntico ao uso de <code>-o ro</code>.</p></dd><dt class=hdlist1><code>-t</code> <em>fstype</em></dt><dd><p>Monta o tipo de sistema de arquivos especificado ou monta somente sistemas de arquivos do tipo especificado, se <code>-a</code>estiver incluído. "ufs" é o tipo de sistema de arquivos padrão.</p></dd><dt class=hdlist1><code>-u</code></dt><dd><p>Atualiza as opções de montagem no sistema de arquivos.</p></dd><dt class=hdlist1><code>-v</code></dt><dd><p>Fica verboso (mostra mais informações).</p></dd><dt class=hdlist1><code>-w</code></dt><dd><p>Monta o sistema de arquivos para leitura/gravação.</p></dd></dl></div><div class=paragraph><p>As seguintes opções podem ser passadas para <code>-o</code> como uma lista separada por vírgula:</p></div><div class=dlist><dl><dt class=hdlist1>nosuid</dt><dd><p>Não interprete flags setuid ou setgid no sistema de arquivos. Essa também é uma opção de segurança útil.</p></dd></dl></div></div><div class=sect3><h4 id=disks-umount>3.7.3. Usando o <a href="https://man.freebsd.org/cgi/man.cgi?query=umount&amp;sektion=8&amp;format=html">umount(8)</a><a class=anchor href=#disks-umount></a></h4><div class=paragraph><p>Para desmontar um sistema de arquivos use <a href="https://man.freebsd.org/cgi/man.cgi?query=umount&amp;sektion=8&amp;format=html">umount(8)</a>. Esse comando usa um parâmetro que pode ser um ponto de montagem, um nome do dispositivo, <code>-a</code> ou <code>-A</code>.</p></div><div class=paragraph><p>Todos os usos aceitam <code>-f</code> para forçar a desmontagem e <code>-v</code> para ver mais informações. Atenção, em geral <code>-f</code> não é uma boa opção, pois pode travar o computador ou danificar os dados no sistema de arquivos.</p></div><div class=paragraph><p>Para desmontar todos os sistemas de arquivos montados, ou apenas os tipos de sistema de arquivos listados após <code>-t</code>, use <code>-a</code> ou <code>-A</code>. Note que <code>-A</code> não tenta desmontar o sistema de arquivos raiz.</p></div></div></div><div class=sect2><h3 id=basics-processes>3.8. Processos e Daemons<a class=anchor href=#basics-processes></a></h3><div class=paragraph><p>O FreeBSD é um sistema operacional multitarefa. Cada programa em execução a qualquer momento é chamado de <em>processo</em>. Todo comando em execução inicia pelo menos um novo processo e há vários processos de sistema que são executados pelo FreeBSD.</p></div><div class=paragraph><p>Cada processo é identificado exclusivamente por um número chamado <em>ID do processo</em> (PID). Semelhante aos arquivos, cada processo tem um proprietário e um grupo, e as permissões de proprietário e grupo são usadas para determinar quais arquivos e dispositivos o processo pode abrir. A maioria dos processos também possui um processo pai que os iniciou. Por exemplo, o shell é um processo e qualquer comando iniciado no shell é um processo que tem o shell como seu processo pai. A exceção é um processo especial chamado <a href="https://man.freebsd.org/cgi/man.cgi?query=init&amp;sektion=8&amp;format=html">init(8)</a> que é sempre o primeiro processo a rodar na inicialização e que sempre possui um PID de <code>1</code>.</p></div><div class=paragraph><p>Alguns programas não são projetados para serem executados com a entrada contínua do usuário e desconectam do terminal na primeira oportunidade. Por exemplo, um servidor da Web responde a solicitações da Web, em vez de entradas do usuário. Servidores de email são outro exemplo desse tipo de aplicativo. Esses tipos de programas são conhecidos como <em>daemons</em>. O termo daemon vem da mitologia grega e representa uma entidade que não é boa nem má, e que invisivelmente realiza tarefas úteis. É por isso que o mascote do BSD é o daemon de aparência alegre com tênis e um tridente.</p></div><div class=paragraph><p>Existe uma convenção para nomear programas que normalmente são executados como daemons com um "d" à direita. Por exemplo, BIND é o Berkeley Internet Name Domain, mas o programa real que é executado é <code>named</code>. O programa do servidor da web Apache é o <code>httpd</code> e o daemon de spooling da impressora de linha é o <code>lpd</code>. Esta é apenas uma convenção de nomenclatura. Por exemplo, o daemon de correio principal para o aplicativo Sendmail é o <code>sendmail</code> e não <code>maild</code>.</p></div><div class=sect3><h4 id=_visualizando_processos>3.8.1. Visualizando Processos<a class=anchor href=#_visualizando_processos></a></h4><div class=paragraph><p>Para ver os processos em execução no sistema, use o <a href="https://man.freebsd.org/cgi/man.cgi?query=ps&amp;sektion=1&amp;format=html">ps(1)</a> ou o <a href="https://man.freebsd.org/cgi/man.cgi?query=top&amp;sektion=1&amp;format=html">top(1)</a>. Para exibir uma lista estática dos processos em execução no momento, seus PIDs, quanta memória eles estão usando e o comando com o qual eles foram iniciados, use o <a href="https://man.freebsd.org/cgi/man.cgi?query=ps&amp;sektion=1&amp;format=html">ps(1)</a>. Para exibir todos os processos em execução e atualizar a exibição a cada poucos segundos para ver interativamente o que o computador está fazendo, use o <a href="https://man.freebsd.org/cgi/man.cgi?query=top&amp;sektion=1&amp;format=html">top(1)</a>.</p></div><div class=paragraph><p>Por padrão, o <a href="https://man.freebsd.org/cgi/man.cgi?query=ps&amp;sektion=1&amp;format=html">ps(1)</a> mostra apenas os comandos que estão em execução e que são de propriedade do usuário. Por exemplo:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ps
 PID TT  STAT    TIME COMMAND
8203  0  Ss   0:00.59 /bin/csh
8895  0  R+   0:00.00 ps</code></pre></div></div><div class=paragraph><p>A saída do <a href="https://man.freebsd.org/cgi/man.cgi?query=ps&amp;sektion=1&amp;format=html">ps(1)</a> é organizada em várias colunas. A coluna <code>PID</code> exibe o ID do processo. Os PIDs são atribuídos a partir de 1, vão até 99999, e depois retornam ao início. No entanto, um PID não é reatribuído se já estiver em uso. A coluna <code>TT</code> mostra o tty em que o programa está sendo executado e <code>STAT</code> mostra o estado do programa. <code>TIME</code> é a quantidade de tempo que o programa foi executado na CPU. Normalmente, esse não é o tempo decorrido desde que o programa foi iniciado, pois a maioria dos programas gasta muito tempo esperando que as coisas aconteçam antes que precisem gastar tempo na CPU. Finalmente, <code>COMMAND</code> é o comando que foi usado para iniciar o programa.</p></div><div class=paragraph><p>Várias opções diferentes estão disponíveis para alterar as informações exibidas. Um dos conjuntos mais úteis é <code>auxww</code>, onde <code>a</code> exibe informações sobre todos os processos em execução de todos os usuários, <code>u</code> exibe o nome de usuário e o uso de memória do proprietário do processo, <code>x</code> exibe informações sobre os processos do daemon e <code>ww</code> faz com que o <a href="https://man.freebsd.org/cgi/man.cgi?query=ps&amp;sektion=1&amp;format=html">ps(1)</a> exiba a linha de comando completa para cada processo, em vez de truncá-la para caber na tela quando é muito longa.</p></div><div class=paragraph><p>A saída do <a href="https://man.freebsd.org/cgi/man.cgi?query=top&amp;sektion=1&amp;format=html">top(1)</a> é semelhante a abaixo:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% top
last pid:  9609<span class=p>;</span>  load averages:  0.56,  0.45,  0.36              up 0+00:20:03  10:21:46
107 processes: 2 running, 104 sleeping, 1 zombie
CPU:  6.2% user,  0.1% <span class=nb>nice</span>,  8.2% system,  0.4% interrupt, 85.1% idle
Mem: 541M Active, 450M Inact, 1333M Wired, 4064K Cache, 1498M Free
ARC: 992M Total, 377M MFU, 589M MRU, 250K Anon, 5280K Header, 21M Other
Swap: 2048M Total, 2048M Free

  PID USERNAME    THR PRI NICE   SIZE    RES STATE   C   TIME   WCPU COMMAND
  557 root          1 <span class=nt>-21</span>  r31   136M 42296K <span class=k>select  </span>0   2:20  9.96% Xorg
 8198 dru           2  52    0   449M 82736K <span class=k>select  </span>3   0:08  5.96% kdeinit4
 8311 dru          27  30    0  1150M   187M uwait   1   1:37  0.98% firefox
  431 root          1  20    0 14268K  1728K <span class=k>select  </span>0   0:06  0.98% moused
 9551 dru           1  21    0 16600K  2660K CPU3    3   0:01  0.98% top
 2357 dru           4  37    0   718M   141M <span class=k>select  </span>0   0:21  0.00% kdeinit4
 8705 dru           4  35    0   480M    98M <span class=k>select  </span>2   0:20  0.00% kdeinit4
 8076 dru           6  20    0   552M   113M uwait   0   0:12  0.00% soffice.bin
 2623 root          1  30   10 12088K  1636K <span class=k>select  </span>3   0:09  0.00% powerd
 2338 dru           1  20    0   440M 84532K <span class=k>select  </span>1   0:06  0.00% kwin
 1427 dru           5  22    0   605M 86412K <span class=k>select  </span>1   0:05  0.00% kdeinit4</code></pre></div></div><div class=paragraph><p>A saída é dividida em duas seções. O cabeçalho (as primeiras cinco ou seis linhas) mostra o PID do último processo executado, as médias de carga do sistema (que são uma medida de quão ocupado o sistema está), o tempo de atividade do sistema desde a última reinicialização) e a hora atual. As outras informações no cabeçalho se relacionam com quantos processos estão sendo executados, quanta memória e swap estão em uso e quanto tempo o sistema está gastando em diferentes estados da CPU. Se o módulo do sistema de arquivos ZFS foi carregado, uma linha <code>ARC</code> indica a quantidade de dados que foram lidos do cache de memória, e não do disco.</p></div><div class=paragraph><p>Abaixo do cabeçalho há uma série de colunas contendo informações semelhantes à saída do <a href="https://man.freebsd.org/cgi/man.cgi?query=ps&amp;sektion=1&amp;format=html">ps(1)</a>, como o PID, nome de usuário, quantidade de tempo de CPU e o comando que iniciou o processo. Por padrão, o <a href="https://man.freebsd.org/cgi/man.cgi?query=top&amp;sektion=1&amp;format=html">top(1)</a> também exibe a quantidade de espaço de memória ocupada pelo processo. Isso é dividido em duas colunas: uma para o tamanho total e outra para o tamanho do residente. O tamanho total é a quantidade de memória que o aplicativo precisa e o tamanho de residente é o quanto ele está realmente usando agora.</p></div><div class=paragraph><p>O <a href="https://man.freebsd.org/cgi/man.cgi?query=top&amp;sektion=1&amp;format=html">top(1)</a> atualiza automaticamente a exibição a cada dois segundos. Um intervalo diferente pode ser especificado com <code>-s</code>.</p></div></div><div class=sect3><h4 id=basics-daemons>3.8.2. Matando Processos<a class=anchor href=#basics-daemons></a></h4><div class=paragraph><p>Uma maneira de se comunicar com qualquer processo ou daemon em execução é enviar um <em>sinal</em> usando o <a href="https://man.freebsd.org/cgi/man.cgi?query=kill&amp;sektion=1&amp;format=html">kill(1)</a>. Existem vários sinais diferentes; alguns têm um significado específico, enquanto outros são descritos na documentação do comando. Um usuário só pode enviar um sinal para um processo que seja seu. Enviar um sinal para o processo de outra pessoa resultará em um erro de permissão negada. A exceção é o usuário <code>root</code>, que pode enviar sinais para os processos de qualquer pessoa.</p></div><div class=paragraph><p>O sistema operacional também pode enviar um sinal para um processo. Se um aplicativo estiver mal escrito e tentar acessar a memória que não deveria, o FreeBSD enviará ao processo o sinal de "Segmentation Violation" (<code>SIGSEGV</code>). Se uma aplicação foi escrita para usar a chamada de sistema <a href="https://man.freebsd.org/cgi/man.cgi?query=alarm&amp;sektion=3&amp;format=html">alarm(3)</a> para ser alertada após um período de tempo, será enviado o sinal "Alarm" (<code>SIGALRM</code>).</p></div><div class=paragraph><p>Dois sinais podem ser usados para interromper um processo: <code>SIGTERM</code> e <code>SIGKILL</code>. <code>SIGTERM</code> é a maneira educada de eliminar um processo, pois o processo pode ler o sinal, fechar quaisquer arquivos de log que possam estar abertos e tentar terminar o que está fazendo antes de desligar. Em alguns casos, um processo pode ignorar <code>SIGTERM</code> se estiver no meio de alguma tarefa que não pode ser interrompida.</p></div><div class=paragraph><p><code>SIGKILL</code> não pode ser ignorado por um processo. Enviar um <code>SIGKILL</code> para um processo geralmente interromperá esse processo de uma vez por todas. .</p></div><div class=paragraph><p>Outros sinais comumente usados são <code>SIGHUP</code>, <code>SIGUSR1</code> e <code>SIGUSR2</code>. Como esses são sinais de finalidade geral, diferentes aplicativos responderão de maneira diferente.</p></div><div class=paragraph><p>Por exemplo, depois de alterar o arquivo de configuração de um servidor da Web, o servidor da Web precisa ser instruído a reler sua configuração. Reiniciar o <code>httpd</code> resultaria em um breve período de interrupção no servidor da web. Em vez disso, envie ao daemon o sinal <code>SIGHUP</code>. Esteja ciente de que diferentes daemons terão um comportamento diferente, então consulte a documentação do daemon para determinar se <code>SIGHUP</code> terá os resultados desejados.</p></div><div class="exampleblock procedure"><div class=content><div class=paragraph><p><strong>Procedure: Enviando um sinal para um processo</strong></p></div><div class=paragraph><p>Este exemplo mostra como enviar um sinal para o <a href="https://man.freebsd.org/cgi/man.cgi?query=inetd&amp;sektion=8&amp;format=html">inetd(8)</a>. O arquivo de configuração do <a href="https://man.freebsd.org/cgi/man.cgi?query=inetd&amp;sektion=8&amp;format=html">inetd(8)</a> é o <span class=filename>/etc/inetd.conf</span> e o <a href="https://man.freebsd.org/cgi/man.cgi?query=inetd&amp;sektion=8&amp;format=html">inetd(8)</a> irá reler este arquivo de configuração quando for enviado um <code>SIGHUP</code>.</p></div><div class="olist arabic"><ol class=arabic><li><p>Encontre o PID do processo para enviar o sinal usando <a href="https://man.freebsd.org/cgi/man.cgi?query=pgrep&amp;sektion=1&amp;format=html">pgrep(1)</a>. Neste exemplo, o PID do <a href="https://man.freebsd.org/cgi/man.cgi?query=inetd&amp;sektion=8&amp;format=html">inetd(8)</a> é 198:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% pgrep <span class=nt>-l</span> inetd
198  inetd <span class=nt>-wW</span></code></pre></div></div></li><li><p>Use o <a href="https://man.freebsd.org/cgi/man.cgi?query=kill&amp;sektion=1&amp;format=html">kill(1)</a> para enviar o sinal. Como o <a href="https://man.freebsd.org/cgi/man.cgi?query=inetd&amp;sektion=8&amp;format=html">inetd(8)</a> é de propriedade do <code>root</code>, use o <a href="https://man.freebsd.org/cgi/man.cgi?query=su&amp;sektion=1&amp;format=html">su(1)</a> para se tornar <code>root</code> primeiro.</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% su
Password:
<span class=c># /bin/kill -s HUP 198</span></code></pre></div></div><div class=paragraph><p>Como a maioria dos comandos UNIX™, o <a href="https://man.freebsd.org/cgi/man.cgi?query=kill&amp;sektion=1&amp;format=html">kill(1)</a> não imprimirá nenhuma saída se for bem-sucedido. Se um sinal for enviado para um processo que não pertence ao usuário, a mensagem <code>kill: <em>PID</em>: Operation not permitted</code> será exibida. Errar o PID irá enviar o sinal para o processo errado, o que poderia ter resultados negativos, ou enviará o sinal para um PID que não esteja em uso no momento, resultando em o erro <code>kill: <em>PID</em>: No such process</code>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=title>Por que usar o <code>/bin/kill</code>?</div><div class=paragraph><p>Muitos shells fornecem o <code>kill</code> como um comando interno, o que significa que o shell enviará o sinal diretamente, em vez de executar o <span class=filename>/bin/kill</span>. Esteja ciente de que diferentes shells possuem uma sintaxe diferente para especificar o nome do sinal a ser enviado. Em vez de tentar aprender todos eles, pode ser mais simples especificar explicitamente o uso do <code>/bin/kill</code>.</p></div></td></tr></tbody></table></div></li></ol></div></div></div><div class=paragraph><p>Ao enviar outros sinais, substitua <code>TERM</code> ou <code>KILL</code> pelo nome do sinal.</p></div><div class="admonitionblock important"><table><tbody><tr><td class=icon><i class="fa icon-important" title=Important></i></td><td class=content><div class=paragraph><p>Matar um processo aleatório no sistema é uma má ideia. Em particular, o <a href="https://man.freebsd.org/cgi/man.cgi?query=init&amp;sektion=8&amp;format=html">init(8)</a>, PID 1, é especial. Executar <code>/bin/kill -s KILL 1</code> é uma maneira rápida e não recomendada de desligar o sistema. <em>Sempre</em> verifique os argumentos do <a href="https://man.freebsd.org/cgi/man.cgi?query=kill&amp;sektion=1&amp;format=html">kill(1)</a><em>antes</em> de pressionar a tecla <kbd>Enter</kbd>.</p></div></td></tr></tbody></table></div></div></div><div class=sect2><h3 id=shells>3.9. Shells<a class=anchor href=#shells></a></h3><div class=paragraph><p>Um <em>shell</em> fornece uma interface de linha de comandos para interagir com o sistema operacional. Um shell recebe comandos do canal de entrada e os executa. Muitos shells fornecem funções incorporadas para ajudar nas tarefas diárias, como gerenciamento de arquivos, referenciamento de arquivos, edição de linha de comando, macros de comando e variáveis de ambiente. O FreeBSD vem com vários shells, incluindo o shell Bourne (<a href="https://man.freebsd.org/cgi/man.cgi?query=sh&amp;sektion=1&amp;format=html">sh(1)</a>) e o shell C estendido (<a href="https://man.freebsd.org/cgi/man.cgi?query=tcsh&amp;sektion=1&amp;format=html">tcsh(1)</a>). Outros shells estão disponíveis na Coleção de Ports do FreeBSD, como o <code>zsh</code> e o <code>bash</code>.</p></div><div class=paragraph><p>O shell usado é realmente uma questão de gosto. Um programador C pode se sentir mais confortável com um shell semelhante ao C, como o <a href="https://man.freebsd.org/cgi/man.cgi?query=tcsh&amp;sektion=1&amp;format=html">tcsh(1)</a>. Um usuário Linux™ pode preferir o <code>bash</code>. Cada shell tem propriedades únicas que podem ou não funcionar com o ambiente de trabalho preferido de um usuário, e é por isso que existe a opção de qual shell usar.</p></div><div class=paragraph><p>Um recurso de shell comum é a conclusão do nome do arquivo. Depois que um usuário digita as primeiras letras de um comando ou nome de arquivo e pressiona a tecla <kbd>Tab</kbd>, o shell completa o restante do comando ou nome do arquivo. Considere dois arquivos chamados <span class=filename>foobar</span> e <span class=filename>football</span>. Para excluir <span class=filename>foobar</span>, o usuário pode digitar <code>rm foo</code> e pressionar a tecla <kbd>Tab</kbd> para completar o nome do arquivo.</p></div><div class=paragraph><p>Mas se o shell mostrar apenas <code>rm foo</code>. Não foi possível completar o nome do arquivo porque ambos <span class=filename>foobar</span> e <span class=filename>football</span> começam com <code>foo</code>. Algumas shells emitem um sinal sonoro ou mostram todas as opções se houver mais de um nome. O usuário deve digitar mais caracteres para identificar o nome do arquivo desejado. Digitar um <code>t</code> e pressionar a tecla <kbd>Tab</kbd> novamente é suficiente para permitir que o shell determine qual nome de arquivo é desejado e preencha o resto.</p></div><div class=paragraph><p>Outra característica do shell é o uso de variáveis de ambiente. As variáveis de ambiente são um par de variável/chave armazenado no ambiente do shell. Esse ambiente pode ser lido por qualquer programa chamado pela shell e, portanto, contém muitas configurações de programas. <a href=#shell-env-vars>Variáveis de Ambiente Comuns</a> fornece uma lista de variáveis de ambiente comuns e seus significados. Observe que os nomes das variáveis de ambiente estão sempre em maiúsculas.</p></div><table id=shell-env-vars class="tableblock frame-none grid-all stretch"><caption class=title>Tabela 5. Variáveis de Ambiente Comuns</caption><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Variável</th><th class="tableblock halign-left valign-top">Descrição</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>USER</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Nome do usuário atual.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>PATH</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Lista de diretórios separados por dois pontos para pesquisa de binários (progamas).</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>DISPLAY</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Nome de rede do display do Xorg para conexão, se disponível.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>SHELL</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>O shell atual.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>TERM</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>O nome do tipo de terminal do usuário. Usado para determinar os recursos do terminal.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>TERMCAP</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Acesso à base de dados dos códigos de escape do terminal para executar várias funções do terminal.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>OSTYPE</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Tipo de sistema operacional.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>MACHTYPE</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>A arquitetura da CPU do sistema.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>EDITOR</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>O editor de texto preferencial do usuário.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>PAGER</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>O utilitário preferencial do usuário para visualização de texto página à página.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>MANPATH</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Lista de diretórios separados por dois pontos para pesquisar páginas de manual.</p></td></tr></tbody></table><div class=paragraph><p>O processo para definir uma variável de ambiente difere entre as shells. Em <a href="https://man.freebsd.org/cgi/man.cgi?query=tcsh&amp;sektion=1&amp;format=html">tcsh(1)</a> e <a href="https://man.freebsd.org/cgi/man.cgi?query=csh&amp;sektion=1&amp;format=html">csh(1)</a>, use <code>setenv</code> para definir variáveis de ambiente. Em <a href="https://man.freebsd.org/cgi/man.cgi?query=sh&amp;sektion=1&amp;format=html">sh(1)</a> e no <code>bash</code>, use <code>export</code> para definir as variáveis de ambiente atuais. Este exemplo define o <code>EDITOR</code> padrão para <span class=filename>/usr/local/bin/emacs</span> para a shell <a href="https://man.freebsd.org/cgi/man.cgi?query=tcsh&amp;sektion=1&amp;format=html">tcsh(1)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% setenv EDITOR /usr/local/bin/emacs</code></pre></div></div><div class=paragraph><p>O comando equivalente para <code>bash</code> seria:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>export </span><span class=nv>EDITOR</span><span class=o>=</span><span class=s2>&#34;/usr/local/bin/emacs&#34;</span></code></pre></div></div><div class=paragraph><p>Para expandir uma variável de ambiente para ver sua configuração atual, digite um caracter <code>$</code> na frente de seu nome na linha de comando. Por exemplo, <code>echo $TERM</code> exibe a configuração atual do <code>$TERM</code>.</p></div><div class=paragraph><p>Shells tratam caracteres especiais, conhecidos como meta-caracteres, como representações especiais de dados. O meta-caracter mais comum é <code>*</code>, que representa qualquer número de caracteres em um nome de arquivo. Meta-caracteres podem ser usados para executar a globalização de nomes de arquivos. Por exemplo, <code>echo *</code> é equivalente a <code>ls</code> porque a shell pega todos os arquivos que correspondem ao <code>*</code> e <code>echo</code> os lista na linha de comando.</p></div><div class=paragraph><p>Para evitar que a shell interprete um caractere especial, escape-o a partir da shell, iniciando-o com uma barra invertida (<code>\</code>). Por exemplo, <code>echo $TERM</code> imprime a configuração do terminal, enquanto <code>echo \$TERM</code> imprime literalmente a string <code>$TERM</code>.</p></div><div class=sect3><h4 id=changing-shells>3.9.1. Alterando a Shell<a class=anchor href=#changing-shells></a></h4><div class=paragraph><p>A maneira mais fácil de alterar permanentemente a shell padrão é usar o <code>chsh</code>. A execução desse comando abrirá o editor que está configurado na variável de ambiente <code>EDITOR</code>, que por padrão é definido como o <a href="https://man.freebsd.org/cgi/man.cgi?query=vi&amp;sektion=1&amp;format=html">vi(1)</a>. Altere a linha <code>Shell:</code> para o caminho completo da nova shell.</p></div><div class=paragraph><p>Como alternativa, use <code>chsh -s</code>, que irá definir a shell especificada sem abrir um editor. Por exemplo, para alterar a shell para <code>bash</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% chsh <span class=nt>-s</span> /usr/local/bin/bash</code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>A nova shell <em>deve</em> estar presente no arquivo <span class=filename>/etc/shells</span>. Se a shell foi instalada a partir da coleção de ports do FreeBSD, como descrito em <a href=./#ports>Instalando Aplicativos. Pacotes e Ports</a>, ela deve ser adicionada automaticamente a este arquivo. Se estiver faltando, adicione-a usando este comando, substituindo o caminho pelo caminho da shell:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># echo /usr/local/bin/bash &gt;&gt; /etc/shells</span></code></pre></div></div><div class=paragraph><p>Em seguida, execute novamente o <a href="https://man.freebsd.org/cgi/man.cgi?query=chsh&amp;sektion=1&amp;format=html">chsh(1)</a>.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=_técnicas_avançadas_de_shell>3.9.2. Técnicas Avançadas de Shell<a class=anchor href=#_técnicas_avançadas_de_shell></a></h4><div class=paragraph><p>A shell UNIX™ não é apenas um interpretador de comandos, ela atua como uma ferramenta poderosa que permite aos usuários executar comandos, redirecionar sua saída, redirecionar sua entrada e encadear comandos para melhorar o resultado final. Quando essa funcionalidade é mesclada com comandos incorporados, é fornecido ao usuário um ambiente que pode maximizar a eficiência.</p></div><div class=paragraph><p>O redirecionamento de shell é a ação de enviar a saída ou a entrada de um comando para outro comando ou para um arquivo. Para capturar a saída do comando <a href="https://man.freebsd.org/cgi/man.cgi?query=ls&amp;sektion=1&amp;format=html">ls(1)</a>, por exemplo, em um arquivo, redirecione a saída:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>ls</span> <span class=o>&gt;</span> directory_listing.txt</code></pre></div></div><div class=paragraph><p>O conteúdo do diretório agora será listado em <span class=filename>directory_listing.txt</span>. Alguns comandos podem ser usados para ler entradas, como <a href="https://man.freebsd.org/cgi/man.cgi?query=sort&amp;sektion=1&amp;format=html">sort(1)</a>. Para classificar esta listagem, redirecione a entrada:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>sort</span> &lt; directory_listing.txt</code></pre></div></div><div class=paragraph><p>A entrada será classificada e colocada na tela. Para redirecionar essa entrada para outro arquivo, pode-se redirecionar a saída de <a href="https://man.freebsd.org/cgi/man.cgi?query=sort&amp;sektion=1&amp;format=html">sort(1)</a> misturando a direção:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>sort</span> &lt; directory_listing.txt <span class=o>&gt;</span> sorted.txt</code></pre></div></div><div class=paragraph><p>Em todos os exemplos anteriores, os comandos estão executando o redirecionamento usando descritores de arquivos. Todo sistema UNIX™ possui descritores de arquivos, que incluem entrada padrão (stdin), saída padrão (stdout) e erro padrão (stderr). Cada um tem um propósito, onde a entrada pode ser um teclado ou um mouse, algo que fornece entrada. A saída pode ser uma tela ou papel em uma impressora. E erro seria tudo o que pode ser usado para mensagens de diagnóstico ou erro. Todos os três são considerados descritores de arquivos baseados em I/O e, às vezes, considerados fluxos.</p></div><div class=paragraph><p>Através do uso desses descritores, a shell permite que a saída e a entrada sejam passadas por vários comandos e redirecionadas para/ou a partir de um arquivo. Outro método de redirecionamento é o operador de pipe.</p></div><div class=paragraph><p>O operador pipe UNIX™, "|" permite que a saída de um comando seja transmitida diretamente ou direcionada para outro programa. Basicamente, um pipe permite que a saída padrão de um comando seja passada como entrada padrão para outro comando, por exemplo:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>cat </span>directory_listing.txt | <span class=nb>sort</span> | less</code></pre></div></div><div class=paragraph><p>Nesse exemplo, o conteúdo de <span class=filename>directory_listing.txt</span> será classificado e a saída será transmitida para <a href="https://man.freebsd.org/cgi/man.cgi?query=less&amp;sektion=1&amp;format=html">less(1)</a>. Isso permite que o usuário role pela saída em seu próprio ritmo e evite que ela role para fora da tela.</p></div></div></div><div class=sect2><h3 id=editors>3.10. Editores de Texto<a class=anchor href=#editors></a></h3><div class=paragraph><p>A maioria das configurações do FreeBSD é feita através da edição de arquivos de texto. Por isso, é uma boa ideia familiarizar-se com um editor de texto. O FreeBSD vem com alguns como parte do sistema base, e muitos outros estão disponíveis na coleção do ports.</p></div><div class=paragraph><p>Um editor simples para aprender é o <a href="https://man.freebsd.org/cgi/man.cgi?query=ee&amp;sektion=1&amp;format=html">ee(1)</a>, que significa editor fácil (Ease Editor). Para iniciar este editor, digite <code>ee <em>filename</em></code> em que <em>filename</em> é o nome do arquivo a ser editado. Uma vez dentro do editor, todos os comandos para manipular as funções do editor são listados no topo da tela. O cursor (<code>^</code>) representa <kbd>Ctrl</kbd>, então <code>^e</code> expande para <span class=keyseq><kbd>Ctrl</kbd>+<kbd>e</kbd></span>. Para sair do <a href="https://man.freebsd.org/cgi/man.cgi?query=ee&amp;sektion=1&amp;format=html">ee(1)</a>, pressione <kbd>Esc</kbd> e escolha a opção "leave editor" no menu principal. O editor pedirá para salvar as alterações, caso o arquivo tenha sido modificado.</p></div><div class=paragraph><p>O FreeBSD também vem com editores de texto mais poderosos, como o <a href="https://man.freebsd.org/cgi/man.cgi?query=vi&amp;sektion=1&amp;format=html">vi(1)</a>, como parte do sistema base. Outros editores, como <a class=package href=https://cgit.freebsd.org/ports/tree/editors/emacs/>editors/emacs</a> e <a class=package href=https://cgit.freebsd.org/ports/tree/editors/vim/>editors/vim</a>, fazem parte da coleção do ports do FreeBSD. Esses editores oferecem mais funcionalidade às custas de serem mais complicados de aprender. Aprender um editor mais poderoso como o vim ou o Emacs pode economizar mais tempo a longo prazo.</p></div><div class=paragraph><p>Muitos aplicativos que modificam arquivos ou exigem entrada digitada abrirão automaticamente um editor de texto. Para alterar o editor padrão, defina a variável de ambiente <code>EDITOR</code> conforme descrito em <a href=#shells>Shells</a>.</p></div></div><div class=sect2><h3 id=basics-devices>3.11. Dispositivos e nós de dispositivos<a class=anchor href=#basics-devices></a></h3><div class=paragraph><p>Um dispositivo é um termo usado principalmente para atividades relacionadas a hardware em um sistema, incluindo discos, impressoras, placas gráficas e teclados. Quando o FreeBSD inicializa, a maioria das mensagens de inicialização se refere aos dispositivos sendo detectados. Uma cópia das mensagens de inicialização é salva em <span class=filename>/var/run/dmesg.boot</span>.</p></div><div class=paragraph><p>Cada dispositivo tem um nome e um número de dispositivo. Por exemplo, <span class=filename>ada0</span> é o primeiro disco rígido SATA, enquanto <span class=filename>kbd0</span> representa o teclado.</p></div><div class=paragraph><p>A maioria dos dispositivos no FreeBSD deve ser acessada através de arquivos especiais chamados nós de dispositivos (device nodes), que estão localizados em <span class=filename>/dev</span>.</p></div></div><div class=sect2><h3 id=basics-more-information>3.12. Páginas de Manual<a class=anchor href=#basics-more-information></a></h3><div class=paragraph><p>A documentação mais abrangente sobre o FreeBSD está na forma de páginas de manual. Quase todos os programas do sistema vêm com um breve manual de referência explicando a operação básica e os argumentos disponíveis. Estes manuais podem ser visualizados usando o <code>man</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% man <span class=nb>command</span></code></pre></div></div><div class=paragraph><p>onde <em>command</em> é o nome do comando para aprender. Por exemplo, para saber mais sobre o <a href="https://man.freebsd.org/cgi/man.cgi?query=ls&amp;sektion=1&amp;format=html">ls(1)</a>, digite:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% man <span class=nb>ls</span></code></pre></div></div><div class=paragraph><p>As páginas de manual são divididas em seções que representam o tipo de tópico. No FreeBSD, as seguintes seções estão disponíveis:</p></div><div class="olist arabic"><ol class=arabic><li><p>Comandos de usuário.</p></li><li><p>Chamadas do sistema e números de erro.</p></li><li><p>Funções nas bibliotecas C.</p></li><li><p>Drivers de dispositivos.</p></li><li><p>Formatos de arquivo.</p></li><li><p>Jogos e outras diversões.</p></li><li><p>Informações diversas.</p></li><li><p>Comandos de manutenção e operação do sistema.</p></li><li><p>Interfaces do kernel do sistema.</p></li></ol></div><div class=paragraph><p>Em alguns casos, o mesmo tópico pode aparecer em mais de uma seção do manual online. Por exemplo, existe um comando de usuário <code>chmod</code> e uma chamada de sistema <code>chmod()</code>. Para informar ao <a href="https://man.freebsd.org/cgi/man.cgi?query=man&amp;sektion=1&amp;format=html">man(1)</a> qual seção exibir, especifique o número da seção:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% man 1 <span class=nb>chmod</span></code></pre></div></div><div class=paragraph><p>Isto irá mostrar a página de manual do comando <a href="https://man.freebsd.org/cgi/man.cgi?query=chmod&amp;sektion=1&amp;format=html">chmod(1)</a>. Referências a uma seção em particular do manual online são tradicionalmente colocadas entre parênteses na documentação escrita, então <a href="https://man.freebsd.org/cgi/man.cgi?query=chmod&amp;sektion=1&amp;format=html">chmod(1)</a> refere-se ao comando do usuário e <a href="https://man.freebsd.org/cgi/man.cgi?query=chmod&amp;sektion=2&amp;format=html">chmod(2)</a> refere-se à chamada do sistema.</p></div><div class=paragraph><p>Se o nome da página de manual for desconhecido, use <code>man -k</code> para procurar por palavras-chave nas descrições da página de manual:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% man <span class=nt>-k</span> mail</code></pre></div></div><div class=paragraph><p>Este comando exibe uma lista de comandos que possuem a palavra-chave "mail" em suas descrições. Isso é equivalente a usar o <a href="https://man.freebsd.org/cgi/man.cgi?query=apropos&amp;sektion=1&amp;format=html">apropos(1)</a>.</p></div><div class=paragraph><p>Para ler as descrições de todos os comandos em <span class=filename>/usr/bin</span>, digite:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>cd</span> /usr/bin
% man <span class=nt>-f</span> <span class=k>*</span> | more</code></pre></div></div><div class=paragraph><p>ou</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>cd</span> /usr/bin
% whatis <span class=k>*</span> |more</code></pre></div></div><div class=sect3><h4 id=basics-info>3.12.1. Arquivos GNU Info<a class=anchor href=#basics-info></a></h4><div class=paragraph><p>O FreeBSD inclui vários aplicativos e utilitários produzidos pela Free Software Foundation (FSF). Além das páginas de manual, esses programas podem incluir documentos de hipertexto chamados arquivos <code>info</code>. Elas podem ser visualizadas usando <a href="https://man.freebsd.org/cgi/man.cgi?query=info&amp;sektion=1&amp;format=html">info(1)</a> ou, se o <a class=package href=https://cgit.freebsd.org/ports/tree/editors/emacs/>editors/emacs</a> estiver instalado, o modo info do emacs.</p></div><div class=paragraph><p>Para usar o <a href="https://man.freebsd.org/cgi/man.cgi?query=info&amp;sektion=1&amp;format=html">info(1)</a>, digite:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% info</code></pre></div></div><div class=paragraph><p>Para uma breve introdução, digite <code>h</code>. Para uma referência rápida de comandos, digite <code>?</code>.</p></div></div></div></div></div><div class=sect1><h2 id=ports>Capítulo 4. Instalando Aplicativos: Pacotes e Ports<a class=anchor href=#ports></a></h2><div class=sectionbody><div class=sect2><h3 id=ports-synopsis>4.1. Sinopse<a class=anchor href=#ports-synopsis></a></h3><div class=paragraph><p>O FreeBSD tem uma grande coleção de ferramentas dentro do sistema base. Além disso, o FreeBSD fornece duas ferramentas complementares para a instalação de software de terceiros: o a Coleção de Ports do FreeBSD, para instalação a partir do código-fonte, e pacotes, para instalação de binários pré-compilados. Qualquer um dos métodos pode ser usado para instalar um software de uma mídia local ou da rede.</p></div><div class=paragraph><p>Depois de ler este capítulo, você saberá:</p></div><div class=ulist><ul><li><p>A diferença entre pacotes binários e ports.</p></li><li><p>Como encontrar softwares de terceiros que tenham sido portados para o FreeBSD.</p></li><li><p>Como gerenciar pacotes binários usando o pkg.</p></li><li><p>Como compilar software de terceiros a partir do código-fonte usando a coleção de ports.</p></li><li><p>Como encontrar os arquivos instalados do aplicativo para configuração pós-instalação.</p></li><li><p>O que fazer se a instalação do software falhar.</p></li></ul></div></div><div class=sect2><h3 id=ports-overview>4.2. Visão geral sobre a Instalação de Software<a class=anchor href=#ports-overview></a></h3><div class=paragraph><p>As etapas típicas para instalar um software de terceiros em um sistema UNIX™ incluem:</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Encontre e baixe o software, que pode ser distribuído no formato de código-fonte ou como um binário.</p></li><li><p>Desempacote o software a partir do seu formato de distribuição. Tipicamente é um arquivo tarball compactado com um programa como <a href="https://man.freebsd.org/cgi/man.cgi?query=compress&amp;sektion=1&amp;format=html">compress(1)</a>,<a href="https://man.freebsd.org/cgi/man.cgi?query=gzip&amp;sektion=1&amp;format=html">gzip(1)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=bzip2&amp;sektion=1&amp;format=html">bzip2(1)</a> ou <a href="https://man.freebsd.org/cgi/man.cgi?query=xz&amp;sektion=1&amp;format=html">xz(1)</a>.</p></li><li><p>Localize a documentação em <span class=filename>INSTALL</span>, <span class=filename>README</span> ou algum arquivo em um subdiretório <span class=filename>doc/</span> e leia sobre como instalar o software.</p></li><li><p>Se o software foi distribuído como código-fonte, compile-o. Isso pode envolver a edição de um <span class=filename>Makefile</span> ou a execução de um script <code>configure</code>.</p></li><li><p>Teste e instale o software.</p></li></ol></div></div></div><div class=paragraph><p>Um <em>port</em> do FreeBSD é uma coleção de arquivos projetados para automatizar o processo de compilação de um aplicativo a partir do código-fonte. Os arquivos que compõem um port contêm todas as informações necessárias para baixar, extrair, corrigir, compilar e instalar automaticamente o aplicativo.</p></div><div class=paragraph><p>Se o software ainda não foi adaptado e testado no FreeBSD, o código-fonte pode precisar ser editado para que seja instalado e executado corretamente.</p></div><div class=paragraph><p>No entanto, mais de <a href=https://www.FreeBSD.org/ports/>24.000</a> aplicativos de terceiros já foram portados para o FreeBSD. Quando possível, esses aplicativos são disponibilizados para download como <em>pacotes</em> pré-compilados.</p></div><div class=paragraph><p>Pacotes podem ser manipulados com os comandos de gerenciamento de pacotes do FreeBSD.</p></div><div class=paragraph><p>Ambos, pacotes e ports, entendem dependências. Se um pacote ou port for usado para instalar um aplicativo, e uma biblioteca dependente ainda não estiver instalada, a biblioteca será instalada automaticamente primeiro.</p></div><div class=paragraph><p>Um pacote do FreeBSD contém cópias pré-compiladas de todos os comandos para uma aplicação, assim como quaisquer arquivos de configuração e documentação. Um pacote pode ser manipulado com os comandos <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg&amp;sektion=8&amp;format=html">pkg(8)</a>, como <code>pkg install</code>.</p></div><div class=paragraph><p>Mesmo as duas tecnologias sendo semelhantes, os pacotes e os ports têm seus próprios pontos fortes. Selecione a tecnologia que melhor atenda aos seus requisitos para instalar um aplicativo específico.</p></div><div class=ulist><div class=title>Benefícios dos Pacotes</div><ul><li><p>Um tarball compactado de um pacote geralmente é menor que o tarball compactado que contém o código-fonte do aplicativo.</p></li><li><p>Pacotes não requerem tempo de compilação. Para aplicativos grandes, como o Mozilla, KDE ou GNOME, isso pode ser importante em um sistema lento.</p></li><li><p>Pacotes não requerem nenhum entendimento do processo envolvido na compilação de software no FreeBSD.</p></li></ul></div><div class=ulist><div class=title>Benefícios dos Ports</div><ul><li><p>Os pacotes são normalmente compilados com opções conservadoras porque eles precisam ser executados no número máximo de sistemas. Ao compilar a partir do port, podem-se alterar as opções de compilação.</p></li><li><p>Alguns aplicativos têm opções em tempo de compilação relacionadas a quais recursos estão instalados. Por exemplo, o Apache pode ser configurado com uma ampla variedade de diferentes opções internas.</p><div class=paragraph><p>Em alguns casos, vários pacotes existirão para o mesmo aplicativo para especificar determinadas configurações. Por exemplo, o Ghostscript está disponível como um pacote <span class=filename>ghostscript</span> e um pacote <span class=filename>ghostscript-nox11</span>, dependendo se o Xorg está instalado ou não. Criar vários pacotes rapidamente se torna impossível se um aplicativo tiver mais de uma ou duas opções diferentes de tempo de compilação.</p></div></li><li><p>As condições de licenciamento de alguns softwares proíbem sua distribuição em binário. Tais softwares devem ser distribuídos como código-fonte o qual deve ser compilado pelo usuário final.</p></li><li><p>Algumas pessoas não confiam em distribuições binárias ou preferem ler o código-fonte para procurar possíveis problemas.</p></li><li><p>O código-fonte é necessário para aplicar patches personalizados.</p></li></ul></div><div class=paragraph><p>Para acompanhar a atualização dos ports, inscreva-se na <a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-ports>lista de discussão dos ports do FreeBSD </a>e no link <a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-ports-bugs>Lista de discussão de bugs no FreeBSD</a>.</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Antes de instalar qualquer aplicativo, verifique <a href=https://vuxml.freebsd.org/ class=bare>https://vuxml.freebsd.org/</a> para questões de segurança relacionadas ao aplicativo ou digite <code>pkg audit -F</code> para verificar todas as instâncias instaladas aplicativos para vulnerabilidades conhecidas.</p></div></td></tr></tbody></table></div><div class=paragraph><p>O restante deste capítulo explica como usar pacotes e ports para instalar e gerenciar software de terceiros no FreeBSD.</p></div></div><div class=sect2><h3 id=ports-finding-applications>4.3. Encontrando Software<a class=anchor href=#ports-finding-applications></a></h3><div class=paragraph><p>A lista de aplicativos disponíveis do FreeBSD está crescendo o tempo todo. Existem várias maneiras de encontrar softwares para instalar:</p></div><div class=ulist><ul><li><p>O site do FreeBSD mantém uma lista atualizada e pesquisável de todos os aplicativos disponíveis, em <a href=https://www.FreeBSD.org/ports/>https://www.FreeBSD.org/ports/</a>. Os ports podem ser pesquisados por nome do aplicativo ou por categoria de software.</p></li><li><p>Dan Langille mantém o <a href=http://www.FreshPorts.org/>FreshPorts.org</a>, que fornece um utilitário de pesquisa abrangente e também rastreia alterações nos aplicativos da Coleção de Ports. Os usuários registrados podem criar uma lista de observação personalizada para receber um e-mail automatizado quando seus ports sendo monitorados forem atualizados.</p></li><li><p>Se encontrar um aplicativo específico se tornar desafiador, tente pesquisar um site como <a href=http://www.sourceforge.net/>SourceForge.net</a> ou <a href=http://www.github.com/>GitHub.com</a> então volte no <a href=https://www.FreeBSD.org/ports/>site do FreeBSD</a> para ver se o aplicativo foi portado.</p></li><li><p>Para pesquisar o repositório de pacotes binários por um aplicativo:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg search subversion</span>
git-subversion-1.9.2
java-subversion-1.8.8_2
p5-subversion-1.8.8_2
py27-hgsubversion-1.6
py27-subversion-1.8.8_2
ruby-subversion-1.8.8_2
subversion-1.8.8_2
subversion-book-4515
subversion-static-1.8.8_2
subversion16-1.6.23_4
subversion17-1.7.16_2</code></pre></div></div><div class=paragraph><p>Os nomes dos pacotes incluem o número da versão e, no caso de ports baseados em python, o número da versão do pacote python sobre o qual o pacote foi compilado. Alguns ports também possuem várias versões disponíveis. No caso do Subversion, existem diferentes versões disponíveis, bem como diferentes opções de compilação. Neste caso, a versão estaticamente vinculada do Subversion. Ao indicar qual pacote instalar, é melhor especificar o aplicativo pela origem do port, que é o caminho na árvore de ports. Repita o <code>pkg search</code> com <code>-o</code> para listar a origem de cada pacote:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg search -o subversion</span>
devel/git-subversion
java/java-subversion
devel/p5-subversion
devel/py-hgsubversion
devel/py-subversion
devel/ruby-subversion
devel/subversion16
devel/subversion17
devel/subversion
devel/subversion-book
devel/subversion-static</code></pre></div></div><div class=paragraph><p>Pesquisar por shell globs, expressões regulares, correspondência exata, por descrição ou qualquer outro campo no banco de dados do repositório também é suportado pelo <code>pkg search</code>. Depois de instalar o <a class=package href=https://cgit.freebsd.org/ports/tree/ports-mgmt/pkg/>ports-mgmt/pkg</a> ou o <a class=package href=https://cgit.freebsd.org/ports/tree/ports-mgmt/pkg-devel/>ports-mgmt/pkg-devel</a>, veja <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg-search&amp;sektion=8&amp;format=html">pkg-search(8)</a> para maiores detalhes.</p></div></li><li><p>Se a Coleção de Ports já estiver instalada, existem vários métodos para consultar a versão local da árvore de ports. Para descobrir em qual categoria um port está, digite <code>whereis<em>file</em></code>, onde <em>file</em> é o programa a ser instalado:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># whereis lsof</span>
lsof: /usr/ports/sysutils/lsof</code></pre></div></div><div class=paragraph><p>Como alternativa, uma declaração <a href="https://man.freebsd.org/cgi/man.cgi?query=echo&amp;sektion=1&amp;format=html">echo(1)</a> pode ser usada:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># echo /usr/ports/*/*lsof*</span>
/usr/ports/sysutils/lsof</code></pre></div></div><div class=paragraph><p>Observe que isso também retornará todos os arquivos correspondentes baixados no diretório <span class=filename>/usr/ports/distfiles</span>.</p></div></li><li><p>Outra maneira de encontrar software é usando o mecanismo de pesquisa integrado da Coleção de Ports. Para usar o recurso de pesquisa, cd para <span class=filename>/usr/ports</span>, execute <code>make search name=program-name</code> onde <em>program-name</em> é o nome do software. Por exemplo, para procurar por <code>lsof</code>:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports</span>
<span class=c># make search name=lsof</span>
Port:   lsof-4.88.d,8
Path:   /usr/ports/sysutils/lsof
Info:   Lists information about open files <span class=o>(</span>similar to fstat<span class=o>(</span>1<span class=o>))</span>
Maint:  ler@lerctr.org
Index:  sysutils
B-deps:
R-deps:</code></pre></div></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>O mecanismo de pesquisa interna usa um arquivo de informações de índice. Se uma mensagem indicar que o <span class=filename>INDEX</span> é necessário, execute <code>make fetchindex</code> para baixar o arquivo de índice atual. Com o <span class=filename>INDEX</span> presente, o <code>make search</code> poderá realizar a pesquisa solicitada.</p></div></td></tr></tbody></table></div><div class=paragraph><p>A linha "Path:" indica onde encontrar o port.</p></div><div class=paragraph><p>Para receber menos informações, use o recurso <code>quicksearch</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports</span>
<span class=c># make quicksearch name=lsof</span>
Port:   lsof-4.88.d,8
Path:   /usr/ports/sysutils/lsof
Info:   Lists information about open files <span class=o>(</span>similar to fstat<span class=o>(</span>1<span class=o>))</span></code></pre></div></div><div class=paragraph><p>Para uma busca mais aprofundada, use o <code>make search key=<em>string</em></code> ou o <code>make quicksearch key=<em>string</em></code>, onde <em>string</em> é algum texto para procurar. O texto pode estar em comentários, descrições ou dependências para encontrar ports relacionados a um assunto em particular quando o nome do programa é desconhecido.</p></div><div class=paragraph><p>Ao usar <code>pesquisa</code> ou <code>pesquisa rápida</code>, a cadeia de pesquisa não diferencia maiúsculas de minúsculas. Procurar por "LSOF" produzirá os mesmos resultados que procurar por "lsof".</p></div></li></ul></div></div><div class=sect2><h3 id=pkgng-intro>4.4. Usando o pkg para o gerenciamento de pacotes binários<a class=anchor href=#pkgng-intro></a></h3><div class=paragraph><p>O pkg é o substituto da próxima geração para as tradicionais ferramentas de gerenciamento de pacotes do FreeBSD, oferecendo muitos recursos que tornam o processamento de pacotes binários mais rápido e fácil.</p></div><div class=paragraph><p>Para sites que desejam apenas usar pacotes binários pré-construídos a partir dos espelhos do FreeBSD, o gerenciamento de pacotes com pkg pode ser suficiente.</p></div><div class=paragraph><p>No entanto, para aqueles que optarem por compilar suas aplicações a partir do código-fonte ou que utilizarem seus próprios repositórios, será necessária uma <a href=#ports-upgrading-tools>ferramenta de gerenciamento de ports</a> separada.</p></div><div class=paragraph><p>Como o pkg só funciona com pacotes binários, ele não é um substituto para tais ferramentas. Estas ferramentas podem ser usadas para instalar o software a partir de pacotes binários e da Coleção do Ports, enquanto o pkg instala apenas pacotes binários.</p></div><div class=sect3><h4 id=pkgng-initial-setup>4.4.1. Introdução ao pkg<a class=anchor href=#pkgng-initial-setup></a></h4><div class=paragraph><p>O FreeBSD inclui um utilitário de bootstrap que pode ser usado para baixar e instalar o pkg e suas páginas de manual. Este utilitário foi projetado para funcionar com versões do FreeBSD começando com 10.<em>X</em>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Nem todas as versões e arquiteturas do FreeBSD suportam este processo de bootstrap. A lista atual está em <a href=https://pkg.freebsd.org/ class=bare>https://pkg.freebsd.org/</a>. Para outros casos, o pkg deve ser instalado a partir da coleção de ports ou como um pacote binário.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Para inicializar o sistema, execute:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /usr/sbin/pkg</span></code></pre></div></div><div class=paragraph><p>Você deve ter uma conexão com a Internet para que o processo de inicialização seja bem-sucedido.</p></div><div class=paragraph><p>Caso contrário, para instalar o port, execute:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/ports-mgmt/pkg</span>
<span class=c># make</span>
<span class=c># make install clean</span></code></pre></div></div><div class=paragraph><p>Ao atualizar um sistema existente que usava originalmente as ferramentas pkg_* mais antigas, o banco de dados deve ser convertido para o novo formato, para que as novas ferramentas estejam cientes dos pacotes já instalados. Uma vez que o pkg tenha sido instalado, o banco de dados de pacotes deve ser convertido do formato tradicional para o novo formato, executando este comando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg2ng</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Esta etapa não é necessária para novas instalações que ainda não possuem nenhum software de terceiros instalado.</p></div></td></tr></tbody></table></div><div class="admonitionblock important"><table><tbody><tr><td class=icon><i class="fa icon-important" title=Important></i></td><td class=content><div class=paragraph><p>Este passo não é reversível. Uma vez que o banco de dados de pacotes tenha sido convertido para o formato pkg, as ferramentas tradicionais <code>pkg_*</code> não devem mais ser usadas.</p></div></td></tr></tbody></table></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>A conversão do banco de dados de pacotes pode emitir erros conforme o conteúdo é convertido para a nova versão. Geralmente, esses erros podem ser ignorados com segurança. No entanto, uma lista com os softwares que não foram convertidos com sucesso é mostrada após o <code>pkg2ng</code> terminar. Esses aplicativos devem ser reinstalados manualmente.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Para garantir que a Coleção de Ports registre novos softwares com o pkg ao invés do tradicional banco de dados de pacotes, versões do FreeBSD anteriores a 10.<em>X</em> requerem esta linha em <span class=filename>/etc/make.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>WITH_PKGNG=	yes</pre></div></div><div class=paragraph><p>Por padrão, o pkg usa os pacotes binários dos espelhos de pacotes do FreeBSD (o <em>repositório</em>). Para obter informações sobre como criar um repositório de pacotes personalizados, consulte <a href=#ports-poudriere>Compilando Pacotes com o Poudriere</a>.</p></div><div class=paragraph><p>Opções adicionais de configuração do pkg são descritas em <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg.conf&amp;sektion=5&amp;format=html">pkg.conf(5)</a>.</p></div><div class=paragraph><p>As informações de uso do pkg estão disponíveis na página de manual <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg&amp;sektion=8&amp;format=html">pkg(8)</a> ou executando o <code>pkg</code> sem argumentos adicionais.</p></div><div class=paragraph><p>Cada argumento do comando pkg é documentado em uma página de manual específica do comando. Para ler a página de manual do <code>pkg install</code>, por exemplo, execute um destes comandos:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg help install</span></code></pre></div></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># man pkg-install</span></code></pre></div></div><div class=paragraph><p>O restante desta seção demonstra tarefas comuns de gerenciamento de pacotes binários que podem ser executadas usando o pkg. Cada comando demonstrado fornece muitos switches para personalizar seu uso. Consulte a ajuda de um comando ou a página do manual para obter detalhes e mais exemplos.</p></div></div><div class=sect3><h4 id=quarterly-latest-branch>4.4.2. Branches Ports Trimestrais e Mais Recentes<a class=anchor href=#quarterly-latest-branch></a></h4><div class=paragraph><p>As branches <code>Quarterly</code>(trimestrais) provê aos usuários uma experiência mais estável e previsível para instalação e upgrade de ports e pacotes. Isto é feito essencialmente permitindo apenas atualizações que não contém novas features (non-features updates). Branches trimestrais visam receber correções se segurança (que talvez sejam atualizações de versão, ou commits de backports), correções de bugs e compliance de ports ou alterações de frameworks. A branch trimestral é baseada (anualmente) na HEAD no início de Janeiro, Abril, Julho e Outubro. As branches são nomeadas de acordo com o ano (YYYY) e o quarter (Q1-4) em que são criadas. Por exemplo, a branch trimestral criada em Janeiro de 2016, é nomeada 2016Q1. E a branch <code>Latest</code> provê as últimas versões dos pacotes para os usuários.</p></div><div class=paragraph><p>Para alternar de trimestral para latest execute os seguintes comandos:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cp /etc/pkg/FreeBSD.conf /usr/local/etc/pkg/repos/FreeBSD.conf</span></code></pre></div></div><div class=paragraph><p>Edite o arquivo <span class=filename>/usr/local/etc/pkg/repos/FreeBSD.conf</span> and change the string <em>quarterly</em> to <em>latest</em> in the <code>url:</code> line.</p></div><div class=paragraph><p>O resultado deve ser semelhante ao seguinte:</p></div><div class="literalblock programlisting"><div class=content><pre>FreeBSD: {
  url: &#34;pkg+http://pkg.FreeBSD.org/${ABI}/latest&#34;,
  mirror_type: &#34;srv&#34;,
  signature_type: &#34;fingerprints&#34;,
  fingerprints: &#34;/usr/share/keys/pkg&#34;,
  enabled: yes
}</pre></div></div><div class=paragraph><p>E finalmente rode este comando para atualizar do novo (ultimo) meta dado do repositório.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg update -f</span></code></pre></div></div></div><div class=sect3><h4 id=pkgng-pkg-info>4.4.3. Obtendo informações sobre os pacotes instalados<a class=anchor href=#pkgng-pkg-info></a></h4><div class=paragraph><p>Informações sobre os pacotes instalados em um sistema podem ser visualizadas executando <code>pkg info</code> que, quando executado sem qualquer opção, listará a versão do pacote para todos os pacotes instalados ou para o pacote especificado.</p></div><div class=paragraph><p>Por exemplo, para ver qual versão do pkg está instalada, execute:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg info pkg</span>
pkg-1.1.4_1</code></pre></div></div></div><div class=sect3><h4 id=pkgng-installing-deinstalling>4.4.4. Instalando e removendo pacotes<a class=anchor href=#pkgng-installing-deinstalling></a></h4><div class=paragraph><p>Para instalar um pacote binário, use o seguinte comando, em que <em>packagename</em> é o nome do pacote a ser instalado:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install packagename</span></code></pre></div></div><div class=paragraph><p>Esse comando usa os dados do repositório para determinar qual versão do software instalar e se ele possui alguma dependência faltando. Por exemplo, para instalar o curl:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install curl</span>
Updating repository catalogue
/usr/local/tmp/All/curl-7.31.0_1.txz          100% of 1181 kB 1380 kBps 00m01s

/usr/local/tmp/All/ca_root_nss-3.15.1_1.txz   100% of  288 kB 1700 kBps 00m00s

Updating repository catalogue
The following 2 packages will be installed:

        Installing ca_root_nss: 3.15.1_1
        Installing curl: 7.31.0_1

The installation will require 3 MB more space

0 B to be downloaded

Proceed with installing packages <span class=o>[</span>y/N]: y
Checking integrity... <span class=k>done</span>
<span class=o>[</span>1/2] Installing ca_root_nss-3.15.1_1... <span class=k>done</span>
<span class=o>[</span>2/2] Installing curl-7.31.0_1... <span class=k>done
</span>Cleaning up cache files...Done</code></pre></div></div><div class=paragraph><p>O novo pacote e quaisquer pacotes adicionais que foram instalados como dependências podem ser vistos na lista de pacotes instalados:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg info</span>
ca_root_nss-3.15.1_1	The root certificate bundle from the Mozilla Project
curl-7.31.0_1	Non-interactive tool to get files from FTP, GOPHER, HTTP<span class=o>(</span>S<span class=o>)</span> servers
pkg-1.1.4_6	New generation package manager</code></pre></div></div><div class=paragraph><p>Pacotes que não são mais necessários podem ser removidos com <code>pkg delete</code>. Por exemplo:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg delete curl</span>
The following packages will be deleted:

	curl-7.31.0_1

The deletion will free 3 MB

Proceed with deleting packages <span class=o>[</span>y/N]: y
<span class=o>[</span>1/1] Deleting curl-7.31.0_1... <span class=k>done</span></code></pre></div></div></div><div class=sect3><h4 id=pkgng-upgrading>4.4.5. Atualizando os Pacotes Instalados<a class=anchor href=#pkgng-upgrading></a></h4><div class=paragraph><p>Os pacotes instalados podem ser atualizados para as versões mais recentes executando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg upgrade</span></code></pre></div></div><div class=paragraph><p>Este comando irá comparar as versões instaladas com as disponíveis no catálogo do repositório e atualizá-las a partir do repositório.</p></div></div><div class=sect3><h4 id=pkgng-auditing>4.4.6. Auditando os Pacotes Instalados<a class=anchor href=#pkgng-auditing></a></h4><div class=paragraph><p>Vulnerabilidades de software são regularmente descobertas em aplicativos de terceiros. Para resolver isso, o pkg inclui um mecanismo de auditoria integrado. Para determinar se há alguma vulnerabilidade conhecida para o software instalado no sistema, execute:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg audit -F</span></code></pre></div></div></div><div class=sect3><h4 id=pkgng-autoremove>4.4.7. Removendo Pacotes Não Utilizados Automaticamente<a class=anchor href=#pkgng-autoremove></a></h4><div class=paragraph><p>Remover um pacote pode deixar dependências que não são mais necessárias. Pacotes desnecessários que foram instalados como dependências podem ser automaticamente detectados e removidos usando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg autoremove</span>
Packages to be autoremoved:
	ca_root_nss-3.15.1_1

The autoremoval will free 723 kB

Proceed with autoremoval of packages <span class=o>[</span>y/N]: y
Deinstalling ca_root_nss-3.15.1_1... <span class=k>done</span></code></pre></div></div><div class=paragraph><p>Os pacotes instalados como dependências são chamados de pacotes <em>automáticos</em>. Pacotes não automáticos, ou seja, os pacotes que não foram instalados como uma dependência para outro pacote, podem ser listados usando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg prime-list</span>
nginx
openvpn
<span class=nb>sudo</span></code></pre></div></div><div class=paragraph><p>O <code>pkg prime-list</code> é um alias de comando declarado no <span class=filename>/usr/local/etc/pkg.conf</span>. Existem muitos outros que podem ser usados para consultar o banco de dados de pacotes do sistema. Por exemplo, o comando <code>pkg prime-origins</code> pode ser usado para obter o diretório de origem dos ports da lista mencionada acima:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg prime-origins</span>
www/nginx
security/openvpn
security/sudo</code></pre></div></div><div class=paragraph><p>Esta lista pode ser usada para recompilar todos os pacotes instalados em um sistema usando ferramentas de compilação como o <a class=package href=https://cgit.freebsd.org/ports/tree/ports-mgmt/poudriere/>ports-mgmt/poudriere</a> ou o <a class=package href=https://cgit.freebsd.org/ports/tree/ports-mgmt/synth/>ports-mgmt/synth</a>.</p></div><div class=paragraph><p>Marcar um pacote instalado como automático pode ser feito usando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg set -A 1 devel/cmake</span></code></pre></div></div><div class=paragraph><p>Uma vez que um pacote é um pacote orfão e está marcado como automático, ele será selecionado por <code>pkg autoremove</code>.</p></div><div class=paragraph><p>Marcar um pacote instalado como <em>não</em> automático pode ser feito usando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg set -A 0 devel/cmake</span></code></pre></div></div></div><div class=sect3><h4 id=pkgng-backup>4.4.8. Restaurando o banco de dados de pacotes<a class=anchor href=#pkgng-backup></a></h4><div class=paragraph><p>Ao contrário do sistema tradicional de gerenciamento de pacotes, o pkg inclui seu próprio mecanismo de backup de banco de dados de pacotes. Essa funcionalidade é habilitada por padrão.</p></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Para desabilitar o script que faz o backup periódico do banco de dados de pacotes, defina <code>daily_backup_pkgdb_enable="NO"</code> no <a href="https://man.freebsd.org/cgi/man.cgi?query=periodic.conf&amp;sektion=5&amp;format=html">periodic.conf(5)</a>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Para restaurar o conteúdo de um backup anterior do banco de dados de pacotes, execute o seguinte comando substituindo <em>/path/to/pkg.sql</em> pelo local do backup:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg backup -r /path/to/pkg.sql</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Se estiver restaurando um backup feito pelo script periódico, ele deve ser descompactado antes de ser restaurado.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Para executar um backup manual do banco de dados pkg, execute o seguinte comando, substituindo <em>/path/to/pkg.sql</em> por um nome de arquivo e local adequados:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg backup -d /path/to/pkg.sql</span></code></pre></div></div></div><div class=sect3><h4 id=pkgng-clean>4.4.9. Removendo Pacotes Obsoletos<a class=anchor href=#pkgng-clean></a></h4><div class=paragraph><p>Por padrão, o pkg armazena pacotes binários em um diretório de cache definido por <code>PKG_CACHEDIR</code> no <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg.conf&amp;sektion=5&amp;format=html">pkg.conf(5)</a>. Somente cópias dos últimos pacotes instalados são mantidas. Versões mais antigas do pkg mantinham todos os pacotes anteriores. Para remover esses pacotes binários desatualizados, execute:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg clean</span></code></pre></div></div><div class=paragraph><p>O cache inteiro pode ser limpo executando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg clean -a</span></code></pre></div></div></div><div class=sect3><h4 id=pkgng-set>4.4.10. Modificando Metadados de Pacotes<a class=anchor href=#pkgng-set></a></h4><div class=paragraph><p>Os softwares dentro da Coleção de Ports do FreeBSD podem passar por grandes mudanças no número de versão. Para resolver isso, o pkg possui um comando interno para atualizar as origens do pacote. Isto pode ser útil, por exemplo, se <a class=package href=https://cgit.freebsd.org/ports/tree/lang/php5/>lang/php5</a> for renomeado para <a class=package href=https://cgit.freebsd.org/ports/tree/lang/php53/>lang/php53</a> para que <a class=package href=https://cgit.freebsd.org/ports/tree/lang/php5/>lang/php5</a> possa agora representar a versão <code>5.4</code>.</p></div><div class=paragraph><p>Para alterar a origem do pacote para o exemplo acima, execute:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg set -o lang/php5:lang/php53</span></code></pre></div></div><div class=paragraph><p>Como outro exemplo, para atualizar <a class=package href=https://cgit.freebsd.org/ports/tree/lang/ruby18/>lang/ruby18</a> para <a class=package href=https://cgit.freebsd.org/ports/tree/lang/ruby19/>lang/ruby19</a>, execute:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg set -o lang/ruby18:lang/ruby19</span></code></pre></div></div><div class=paragraph><p>Como um exemplo final, para alterar a origem das bibliotecas compartilhadas <span class=filename>libglut</span> de <a class=package href=https://cgit.freebsd.org/ports/tree/graphics/libglut/>graphics/libglut</a> para <a class=package href=https://cgit.freebsd.org/ports/tree/graphics/freeglut/>graphics/freeglut</a>, execute:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install -Rf graphics/freeglut</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Ao alterar as origens do pacote, é importante reinstalar os pacotes que dependem do pacote com a origem modificada. Para forçar uma reinstalação dos pacotes dependentes, execute:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install -Rf graphics/freeglut</span></code></pre></div></div></td></tr></tbody></table></div></div></div><div class=sect2><h3 id=ports-using>4.5. Usando a Coleção de Ports<a class=anchor href=#ports-using></a></h3><div class=paragraph><p>A Coleção de Ports é um conjunto de arquivos <span class=filename>Makefiles</span>s, patches e arquivos de descrição. Cada conjunto desses arquivos é usado para compilar e instalar um aplicativo individual no FreeBSD, e é chamado de <em>port</em>.</p></div><div class=paragraph><p>Por padrão, a própria coleção de ports é armazenada como um subdiretório de <span class=filename>/usr/ports</span>.</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Before installing and using the Ports Collection, please be aware that it is generally ill-advised to use the Ports Collection in conjunction with the binary packages provided via pkg to install software. pkg, by default, tracks quarterly branch-releases of the ports tree and not HEAD. Dependencies could be different for a port in HEAD compared to its counterpart in a quarterly branch release and this could result in conflicts between dependencies installed by pkg and those from the Ports Collection. If the Ports Collection and pkg must be used in conjunction, then be sure that your Ports Collection and pkg are on the same branch release of the ports tree.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Antes que um aplicativo possa ser compilado usando um port, a Coleção de Ports deve primeiro ser instalada. Se ela não foi instalada durante a instalação do FreeBSD, use um dos seguintes métodos para instalá-la:</p></div><div id=ports-using-portsnap-method class="exampleblock procedure"><div class=content><div class=paragraph><p><strong>Procedure: Método Portsnap</strong></p></div><div class=paragraph><p>O sistema base do FreeBSD inclui o Portsnap. Esta é uma ferramenta rápida e de fácil utilização para obter a Coleção de Ports e é a escolha recomendada para a maioria dos usuários que não estão executando o FreeBSD-CURRENT. Este utilitário se conecta a um site do FreeBSD, verifica a chave segura e faz o download de uma nova cópia da Coleção de Ports. A chave é usada para verificar a integridade de todos os arquivos baixados.</p></div><div class="olist arabic"><ol class=arabic><li><p>Para baixar um snapshot compactado da coleção de ports em <span class=filename>/var/db/portsnap</span>:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portsnap fetch</span></code></pre></div></div></li><li><p>Ao executar o Portsnap pela primeira vez, extraia o snapshot em <span class=filename>/usr/ports</span>:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portsnap extract</span></code></pre></div></div></li><li><p>Após o primeiro uso do Portsnap ter sido concluído, como mostrado acima, o <span class=filename>/usr/ports</span> pode ser atualizado conforme necessário executando:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portsnap fetch</span>
<span class=c># portsnap update</span></code></pre></div></div><div class=paragraph><p>Ao usar <code>fetch</code>, a operação <code>extract</code> ou <code>update</code> pode ser executada consecutivamente, da seguinte forma:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portsnap fetch update</span></code></pre></div></div></li></ol></div></div></div><div id=ports-using-subversion-method class="exampleblock procedure"><div class=content><div class=paragraph><p><strong>Procedure: Método Subversion</strong></p></div><div class=paragraph><p>Se for necessário mais controle sobre a árvore de ports ou se as mudanças locais precisarem ser mantidas, ou se estiver executando o FreeBSD-CURRENT, o Subversion pode ser usado para obter a coleção de ports. Consulte <a href=https://docs.freebsd.org/pt-br/articles/committers-guide/#subversion-primer>O Subversion Primer</a> para uma descrição detalhada do Subversion.</p></div><div class="olist arabic"><ol class=arabic><li><p>O Subversion deve ser instalado antes de poder ser usado para fazer o check-out da árvore de ports. Se uma cópia da árvore de ports já estiver presente, instale o Subversion desta forma:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/devel/subversion</span>
<span class=c># make install clean</span></code></pre></div></div><div class=paragraph><p>Se a árvore de ports não estiver disponível, ou o pkg estiver sendo usado para gerenciar pacotes, o Subversion poderá ser instalado como um pacote:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install subversion</span></code></pre></div></div></li><li><p>Check out a copy of the HEAD branch of the ports tree:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># svn checkout https://svn.FreeBSD.org/ports/head /usr/ports</span></code></pre></div></div></li><li><p>Or, check out a copy of a quarterly branch:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># svn checkout https://svn.FreeBSD.org/ports/branches/2020Q3 /usr/ports</span></code></pre></div></div></li><li><p>Conforme necessário, atualize o <span class=filename>/usr/ports</span> após o check out inicial do Subversion:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># svn update /usr/ports</span></code></pre></div></div></li><li><p>As needed, switch <span class=filename>/usr/ports</span> to a different quarterly branch:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># svn switch http://svn.freebsd.org/ports/branches/2020Q4/ /usr/ports</span></code></pre></div></div></li></ol></div></div></div><div class=paragraph><p>A coleção de ports contém diretórios para categorias de software. Dentro de cada categoria estão subdiretórios para aplicativos individuais. Cada subdiretório de aplicativo contém um conjunto de arquivos que informa ao FreeBSD como compilar e instalar esse programa, chamado de <em>esqueleto do ports</em>. Cada esqueleto de port inclui esses arquivos e diretórios:</p></div><div class=ulist><ul><li><p><span class=filename>Makefile</span>: contém instruções que especificam como o aplicativo deve ser compilado e onde seus componentes devem ser instalados.</p></li><li><p><span class=filename>distinfo</span>: contém os nomes e checksums dos arquivos que devem ser baixados para compilar o port.</p></li><li><p><span class=filename>files/</span>: este diretório contém quaisquer patches necessários para o programa compilar e instalar no FreeBSD. Esse diretório também pode conter outros arquivos usados para compilar o port.</p></li><li><p><span class=filename>pkg-descr</span>: fornece uma descrição mais detalhada do programa.</p></li><li><p><span class=filename>pkg-plist</span>: uma lista de todos os arquivos que serão instalados pelo port. Ele também informa ao sistema de ports quais arquivos devem ser removidos após a desinstalação.</p></li></ul></div><div class=paragraph><p>Alguns ports incluem <span class=filename>pkg-message</span> ou outros arquivos para lidar com situações especiais. Para obter mais detalhes sobre esses arquivos e sobre os ports em geral, consulte o <a href=https://docs.freebsd.org/pt-br/books/porters-handbook/>FreeBSD Porter’s Manual</a>.</p></div><div class=paragraph><p>O port não inclui o código-fonte real, também conhecido como <span class=filename>distfile</span>. A etapa de extração da compilação de um port salvará automaticamente o código-fonte transferido por download para <span class=filename>/usr/ports/distfiles</span>.</p></div><div class=sect3><h4 id=ports-skeleton>4.5.1. Instalando Ports<a class=anchor href=#ports-skeleton></a></h4><div class=paragraph><p>Esta seção fornece instruções básicas sobre o uso da Coleção de Ports para instalar ou remover software. A descrição detalhada dos targets disponíveis do <code>make</code> e das variáveis de ambiente está disponível em <a href="https://man.freebsd.org/cgi/man.cgi?query=ports&amp;sektion=7&amp;format=html">ports(7)</a>.</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Antes de compilar qualquer port, certifique-se de atualizar a Coleção de Ports conforme descrito na seção anterior. Como a instalação de qualquer software de terceiros pode introduzir vulnerabilidades de segurança, recomenda-se primeiro verificar <a href=https://vuxml.freebsd.org/ class=bare>https://vuxml.freebsd.org/</a> para problemas de segurança conhecidos relacionados ao port. Alternativamente, execute <code>pkg -f</code> antes de instalar um novo port. Esse comando pode ser configurado para executar automaticamente uma auditoria de segurança e uma atualização do banco de dados de vulnerabilidades durante a verificação diária do sistema de segurança. Para obter maiores informações, consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg-audit&amp;sektion=8&amp;format=html">pkg-audit(8)</a> e <a href="https://man.freebsd.org/cgi/man.cgi?query=periodic&amp;sektion=8&amp;format=html">periodic(8)</a>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>O uso da coleção de ports pressupõe uma conexão de Internet ativa. Também requer privilégios de superusuário.</p></div><div class=paragraph><p>Para compilar e instalar o port, mude para o diretório do port a ser instalado e, em seguida, digite <code>make install</code> no prompt. Mensagens indicarão o progresso:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/sysutils/lsof</span>
<span class=c># make install</span>
<span class=o>&gt;&gt;</span> lsof_4.88D.freebsd.tar.gz doesn<span class=s1>&#39;t seem to exist in /usr/ports/distfiles/.
&gt;&gt; Attempting to fetch from ftp://lsof.itap.purdue.edu/pub/tools/unix/lsof/.
===&gt;  Extracting for lsof-4.88
...
[extraction output snipped]
...
&gt;&gt; Checksum OK for lsof_4.88D.freebsd.tar.gz.
===&gt;  Patching for lsof-4.88.d,8
===&gt;  Applying FreeBSD patches for lsof-4.88.d,8
===&gt;  Configuring for lsof-4.88.d,8
...
[configure output snipped]
...
===&gt;  Building for lsof-4.88.d,8
...
[compilation output snipped]
...

===&gt;  Installing for lsof-4.88.d,8
...
[installation output snipped]
...
===&gt;   Generating temporary packing list
===&gt;   Compressing manual pages for lsof-4.88.d,8
===&gt;   Registering installation for lsof-4.88.d,8
===&gt;  SECURITY NOTE:
      This port has installed the following binaries which execute with
      increased privileges.
/usr/local/sbin/lsof
#</span></code></pre></div></div><div class=paragraph><p>Como o <code>lsof</code> é um programa que é executado com privilégios aumentados, um aviso de segurança é exibido quando é instalado. Quando a instalação estiver concluída, o prompt será retornado.</p></div><div class=paragraph><p>Algumas shells mantêm um cache dos comandos que estão disponíveis nos diretórios listados na variável de ambiente <code>PATH</code>, para acelerar as operações de pesquisa do arquivo executável desses comandos. Os usuários do shell <code>tcsh</code> devem digitar <code>rehash</code> para que um comando recém-instalado possa ser usado sem especificar seu caminho completo. Use <code>hash -r</code> para o shell <code>sh</code>. Consulte a documentação do shell para mais informações.</p></div><div class=paragraph><p>Durante a instalação, é criado um subdiretório de trabalho que contém todos os arquivos temporários usados durante a compilação. A remoção desse diretório economiza espaço em disco e minimiza a possibilidade de problemas mais tarde ao atualizar para a versão mais recente do port:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># make clean</span>
<span class=o>===&gt;</span>  Cleaning <span class=k>for </span>lsof-88.d,8
<span class=c>#</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Para evitar esta etapa extra, use <code>make install clean</code> ao compilar o port.</p></div></td></tr></tbody></table></div><div class=sect4><h5 id=_personalizando_a_instalação_de_ports>4.5.1.1. Personalizando a instalação de ports<a class=anchor href=#_personalizando_a_instalação_de_ports></a></h5><div class=paragraph><p>Alguns ports fornecem opções de compilação que podem ser usadas para habilitar ou desabilitar componentes do aplicativo, fornecer opções de segurança ou permitir outras personalizações. Os exemplos incluem o <a class=package href=https://cgit.freebsd.org/ports/tree/www/firefox/>www/firefox</a>, <a class=package href=https://cgit.freebsd.org/ports/tree/security/gpgme/>security/gpgme</a>, e <a class=package href=https://cgit.freebsd.org/ports/tree/mail/sylpheed-claws/>mail/sylpheed-claws</a>. Se o port depender de outros ports que tenham opções configuráveis, ela poderá pausar várias vezes para interação do usuário, pois o comportamento padrão é solicitar ao usuário que selecione opções de um menu. Para evitar isso e fazer toda a configuração em um lote, execute <code>make config-recursive</code> dentro do diretório do port. Em seguida, execute <code>make install [clean]</code> para compilar e instalar o port.</p></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Ao usar <code>config-recursive</code>, a lista de ports a serem configurados é reunida pelo target <code>all-depends-list</code>. É recomendado executar o <code>make config-recursive</code> até que todas as opções dos ports dependentes tenham sido definidas, e as telas de opções de ports não apareçam mais, para ter certeza de que todas as opções das dependência foram configuradas.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Há várias maneiras de revisitar o menu de opções de compilação de um port para adicionar, remover ou alterar essas opções após a compilação de um port. Um método é efetuar <code>cd</code> no diretório que contém o port e digitar <code>make config</code>. Outra opção é usar o <code>make showconfig</code>. Outra opção é executar <code>make rmconfig</code>, o que removerá todas as opções selecionadas e permitirá que você comece de novo. Todas essas opções, e outras, são explicadas detalhadamente em <a href="https://man.freebsd.org/cgi/man.cgi?query=ports&amp;sektion=7&amp;format=html">ports(7)</a>.</p></div><div class=paragraph><p>O sistema de ports usa o <a href="https://man.freebsd.org/cgi/man.cgi?query=fetch&amp;sektion=1&amp;format=html">fetch(1)</a> para fazer o download dos arquivos com o código-fonte, que suportam várias variáveis de ambiente. As variáveis <code>FTP_PASSIVE_MODE</code>, <code>FTP_PROXY</code> e <code>FTP_PASSWORD</code> podem precisar ser definidas se o sistema FreeBSD estiver por trás de um firewall ou proxy FTP/HTTP. Veja <a href="https://man.freebsd.org/cgi/man.cgi?query=fetch&amp;sektion=3&amp;format=html">fetch(3)</a> para a lista completa de variáveis suportadas.</p></div><div class=paragraph><p>Para usuários que não podem estar conectados à Internet o tempo todo, o <code>make fetch</code> pode ser executado dentro do <span class=filename>/usr/ports</span>, para buscar todos os distfiles, ou dentro de uma categoria, como <span class=filename>/usr/ports/net</span>, ou dentro do diretório de um port especifico. Observe que, se um port tiver alguma dependência, executar este comando em uma categoria ou diretório de um port especifico <em>não</em> buscará os distfiles de ports de outra categoria. Em vez disso, use <code>make fetch-recursive</code> para também buscar os distfiles para todas as dependências de um port.</p></div><div class=paragraph><p>Em casos raros, como quando uma organização tem um repositório local de distfiles, a variável <code>MASTER_SITES</code> pode ser usada para substituir os locais de download especificados no <span class=filename>Makefile</span>. Ao usar, especifique o local alternativo:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/directory</span>
<span class=c># make MASTER_SITE_OVERRIDE= \</span>
ftp://ftp.organization.org/pub/FreeBSD/ports/distfiles/ fetch</code></pre></div></div><div class=paragraph><p>As variáveis <code>WRKDIRPREFIX</code> e <code>PREFIX</code> podem substituir os diretórios de trabalho e de destino padrão. Por exemplo:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># make WRKDIRPREFIX=/usr/home/example/ports install</span></code></pre></div></div><div class=paragraph><p>irá compilar o port em <span class=filename>/usr/home/example/ports</span> e instalar tudo sob <span class=filename>/usr/local</span>.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># make PREFIX=/usr/home/example/local install</span></code></pre></div></div><div class=paragraph><p>irá compilar o port em <span class=filename>/usr/ports</span> e instalá-lo em <span class=filename>/usr/home/example/local</span>. E:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># make WRKDIRPREFIX=../ports PREFIX=../local install</span></code></pre></div></div><div class=paragraph><p>vai combinar os dois.</p></div><div class=paragraph><p>Estes também podem ser definidos como variáveis ambientais. Consulte a página de manual do seu shell para obter instruções sobre como definir uma variável de ambiente.</p></div></div></div><div class=sect3><h4 id=ports-removing>4.5.2. Removendo Ports Instalados<a class=anchor href=#ports-removing></a></h4><div class=paragraph><p>Ports instalados podem ser desinstalados usando <code>pkg delete</code>. Exemplos para usar este comando podem ser encontrados na página de manual <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg-delete&amp;sektion=8&amp;format=html">pkg-delete(8)</a>.</p></div><div class=paragraph><p>Alternativamente, o <code>make deinstall</code> pode ser executado no diretório do port:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/sysutils/lsof</span>
<span class=c># make deinstall</span>
<span class=o>===&gt;</span>  Deinstalling <span class=k>for </span>sysutils/lsof
<span class=o>===&gt;</span>   Deinstalling
Deinstallation has been requested <span class=k>for </span>the following 1 packages:

	lsof-4.88.d,8

The deinstallation will free 229 kB
<span class=o>[</span>1/1] Deleting lsof-4.88.d,8... <span class=k>done</span></code></pre></div></div><div class=paragraph><p>Recomenda-se ler as mensagens quando o port for desinstalado. Se o port tiver algum aplicativo que dependa dele, essas informações serão exibidas, mas a desinstalação continuará. Nesses casos, talvez seja melhor reinstalar o aplicativo para evitar dependências quebradas.</p></div></div><div class=sect3><h4 id=ports-upgrading>4.5.3. Atualizando os Ports<a class=anchor href=#ports-upgrading></a></h4><div class=paragraph><p>Com o tempo, novas versões de software ficam disponíveis na coleção de ports. Esta seção descreve como determinar qual software pode ser atualizado e como executar a atualização.</p></div><div class=paragraph><p>Para determinar se versões mais recentes dos ports instalados estão disponíveis, verifique se a versão mais recente da árvore de ports está instalada, usando o comando de atualização descrito em <a href=#ports-using-portsnap-method>Método Portsnap</a> ou <a href=#ports-using-subversion-method>Método Subversion</a>. No FreeBSD 10 e posterior, ou se o sistema foi convertido para pkg, o seguinte comando listará os ports instalados que estão desatualizadas:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg version -l &#34;&lt;&#34;</span></code></pre></div></div><div class=paragraph><p>Para o FreeBSD 9.<em>X</em> e menor, o seguinte comando listará os ports instalados que estão desatualizados:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg_version -l &#34;&lt;&#34;</span></code></pre></div></div><div class="admonitionblock important"><table><tbody><tr><td class=icon><i class="fa icon-important" title=Important></i></td><td class=content><div class=paragraph><p>Antes de tentar uma atualização, leia o <span class=filename>/usr/ports/UPDATING</span> da parte superior do arquivo até a data mais próxima da última vez em que os ports foram atualizados ou o sistema foi instalado. Este arquivo descreve vários problemas e etapas adicionais que os usuários podem encontrar e precisar executar ao atualizar um port, incluindo coisas como alterações de formato de arquivo, alterações nos locais de arquivos de configuração ou incompatibilidades com versões anteriores. Anote quaisquer instruções que correspondam a qualquer um dos ports que precisam de atualização e siga estas instruções ao executar a atualização.</p></div></td></tr></tbody></table></div><div class=sect4><h5 id=ports-upgrading-tools>4.5.3.1. Ferramentas para atualizar e gerenciar ports<a class=anchor href=#ports-upgrading-tools></a></h5><div class=paragraph><p>A coleção de ports contém vários utilitários para executar a atualização real. Cada um tem seus pontos fortes e fracos.</p></div><div class=paragraph><p>Historicamente, a maioria das instalações usava o Portmaster ou o Portupgrade. O Synth é uma alternativa mais recente.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>A escolha da melhor ferramenta para um determinado sistema depende do administrador do sistema. Recomenda-se a prática de fazer backup de seus dados antes de usar qualquer uma dessas ferramentas.</p></div></td></tr></tbody></table></div></div><div class=sect4><h5 id=portmaster>4.5.3.2. Atualizando Ports Usando o Portmaster<a class=anchor href=#portmaster></a></h5><div class=paragraph><p>O <a class=package href=https://cgit.freebsd.org/ports/tree/ports-mgmt/portmaster/>ports-mgmt/portmaster</a> é um utilitário muito pequeno para atualizar os ports instalados. Ele é projetado para usar as ferramentas instaladas com o sistema base do FreeBSD sem depender de outros ports ou bancos de dados. Para instalar este utilitário como um port:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/ports-mgmt/portmaster</span>
<span class=c># make install clean</span></code></pre></div></div><div class=paragraph><p>O Portmaster define quatro categorias de ports:</p></div><div class=ulist><ul><li><p>Port Root: não tem dependências e não é uma dependência de outros ports.</p></li><li><p>Port Trunk: não tem dependências, mas outros ports dependem dele.</p></li><li><p>Port Branch: tem dependências e outros ports dependem dele.</p></li><li><p>Port Leaf: tem dependências, mas nenhum outro port depende dele.</p></li></ul></div><div class=paragraph><p>Para listar essas categorias e procurar atualizações:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portmaster -L</span>
<span class=o>===&gt;&gt;&gt;</span> Root ports <span class=o>(</span>No dependencies, not depended on<span class=o>)</span>
<span class=o>===&gt;&gt;&gt;</span> ispell-3.2.06_18
<span class=o>===&gt;&gt;&gt;</span> screen-4.0.3
        <span class=o>===&gt;&gt;&gt;</span> New version available: screen-4.0.3_1
<span class=o>===&gt;&gt;&gt;</span> tcpflow-0.21_1
<span class=o>===&gt;&gt;&gt;</span> 7 root ports
...
<span class=o>===&gt;&gt;&gt;</span> Branch ports <span class=o>(</span>Have dependencies, are depended on<span class=o>)</span>
<span class=o>===&gt;&gt;&gt;</span> apache22-2.2.3
        <span class=o>===&gt;&gt;&gt;</span> New version available: apache22-2.2.8
...
<span class=o>===&gt;&gt;&gt;</span> Leaf ports <span class=o>(</span>Have dependencies, not depended on<span class=o>)</span>
<span class=o>===&gt;&gt;&gt;</span> automake-1.9.6_2
<span class=o>===&gt;&gt;&gt;</span> bash-3.1.17
        <span class=o>===&gt;&gt;&gt;</span> New version available: bash-3.2.33
...
<span class=o>===&gt;&gt;&gt;</span> 32 leaf ports

<span class=o>===&gt;&gt;&gt;</span> 137 total installed ports
        <span class=o>===&gt;&gt;&gt;</span> 83 have new versions available</code></pre></div></div><div class=paragraph><p>Este comando é usado para atualizar todos os ports desatualizados:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portmaster -a</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Por padrão, o Portmaster faz um backup do pacote antes de excluir o port existente. Se a instalação da nova versão for bem-sucedida, o Portmaster excluirá o backup. O uso de <code>-b</code> instrui o Portmaster a não excluir automaticamente o backup. Adicionar <code>-i</code> inicia o Portmaster no modo interativo, solicitando a confirmação antes de atualizar cada port. Muitas outras opções estão disponíveis. Leia a página de manual para o <a href="https://man.freebsd.org/cgi/man.cgi?query=portmaster&amp;sektion=8&amp;format=html">portmaster(8)</a> para obter detalhes sobre seu uso.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Se forem encontrados erros durante o processo de atualização, adicione <code>-f</code> para atualizar e recompilar todos os ports:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portmaster -af</span></code></pre></div></div><div class=paragraph><p>O Portmaster também pode ser usado para instalar novos ports no sistema, atualizando todas as dependências antes de compilar e instalar o novo port. Para usar essa função, especifique o local do port na coleção de ports:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portmaster shells/bash</span></code></pre></div></div><div class=paragraph><p>Maiores informações sobre <a class=package href=https://cgit.freebsd.org/ports/tree/ports-mgmt/portmaster/>ports-mgmt/portmaster</a> podem ser encontradas no <span class=filename>pkg-descr</span>.</p></div></div><div class=sect4><h5 id=portupgrade>4.5.3.3. Atualizando Ports Usando o Portupgrade<a class=anchor href=#portupgrade></a></h5><div class=paragraph><p>O <a class=package href=https://cgit.freebsd.org/ports/tree/ports-mgmt/portupgrade/>ports-mgmt/portupgrade</a> é outro utilitário que pode ser usado para atualizar ports. Ele instala um conjunto de aplicativos que podem ser usados para gerenciar ports. No entanto, ele depende do Ruby. Para instalar o port:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/ports-mgmt/portupgrade</span>
<span class=c># make install clean</span></code></pre></div></div><div class=paragraph><p>Antes de executar uma atualização usando esse utilitário, é recomendável verificar a lista de ports instalados usando o <code>pkgdb -F</code> e corrigir todas as inconsistências relatadas.</p></div><div class=paragraph><p>Para atualizar todos os ports desatualizados instalados no sistema, use o <code>portupgrade -a</code>. Como alternativa, inclua <code>-i</code> para ser solicitado da confirmação de cada atualização individual:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portupgrade -ai</span></code></pre></div></div><div class=paragraph><p>Para atualizar apenas um aplicativo especifico em vez de todos os ports disponíveis, use <code>portupgrade <em>pkgname</em></code>. É muito importante incluir <code>-R</code> para primeiro atualizar todos os ports requeridos pelo aplicativo fornecido:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portupgrade -R firefox</span></code></pre></div></div><div class=paragraph><p>Se <code>-P</code> estiver incluído, o Portupgrade procura pacotes disponíveis nos diretórios locais listados em <code>PKG_PATH</code>. Se nenhum estiver disponível localmente, ele buscará pacotes de um site remoto. Se os pacotes não puderem ser encontrados localmente ou buscados remotamente, o Portupgrade utilizará os ports. Para evitar completamente o uso do ports, especifique <code>-PP</code>. Este último conjunto de opções diz ao Portupgrade para cancelar se nenhum pacote estiver disponível:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portupgrade -PP gnome3</span></code></pre></div></div><div class=paragraph><p>Para obter apenas os distfiles do port, ou pacotes, se <code>-P</code> for especificado, sem compilar ou instalar nada, use <code>-F</code>. Para mais informações sobre todas as opções disponíveis, consulte a página de manual do <code>portupgrade</code>.</p></div><div class=paragraph><p>Maiores informações sobre o <a class=package href=https://cgit.freebsd.org/ports/tree/ports-mgmt/portupgrade/>ports-mgmt/portupgrade</a> podem ser encontradas no <span class=filename>pkg-descr</span>.</p></div></div></div><div class=sect3><h4 id=ports-disk-space>4.5.4. Ports e o Espaço em Disco<a class=anchor href=#ports-disk-space></a></h4><div class=paragraph><p>A utilização da coleção de ports irá ocupar espaço em disco ao longo do tempo. Depois de compilar e instalar um port, executar <code>make clean</code> dentro do diretório de um port limpará o diretório temporário de <span class=filename>trabalho</span>. Se o Portmaster for usado para instalar um port, ele removerá automaticamente esse diretório, a menos que <code>-K</code> seja especificado. Se o Portupgrade estiver instalado, este comando removerá todos os diretórios de <span class=filename>trabalho</span> encontrados na cópia local da coleção de ports:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portsclean -C</span></code></pre></div></div><div class=paragraph><p>Além disso, arquivos de distribuição de código-fonte desatualizados se acumulam no <span class=filename>/usr/ports/distfiles</span> ao longo do tempo. Para usar Portupgrade para excluir todos os distfiles que não são mais referenciados por nenhum port:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portsclean -D</span></code></pre></div></div><div class=paragraph><p>O Portupgrade pode remover todos os distfiles não referenciados por qualquer port atualmente instalado no sistema:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portsclean -DD</span></code></pre></div></div><div class=paragraph><p>Se o Portmaster estiver instalado, use:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portmaster --clean-distfiles</span></code></pre></div></div><div class=paragraph><p>Por padrão, esse comando é interativo e solicita que o usuário confirme se um distfile deve ser excluído.</p></div><div class=paragraph><p>Além desses comandos, o <a class=package href=https://cgit.freebsd.org/ports/tree/ports-mgmt/pkg_cutleaves/>ports-mgmt/pkg_cutleaves</a> automatiza a tarefa de remover os ports instalados que não são mais necessários.</p></div></div></div><div class=sect2><h3 id=ports-poudriere>4.6. Compilando Pacotes com o Poudriere<a class=anchor href=#ports-poudriere></a></h3><div class=paragraph><p>O Poudriere é um utilitário licenciado sob a licença BSD para criar e testar pacotes do FreeBSD. Ele usa o jails do FreeBSD para configurar ambientes de compilação isolados. Esses jails podem ser usados para compilar pacotes para versões do FreeBSD que são diferentes do sistema no qual ele está instalado, e também para construir pacotes para o i386 se o host for um sistema amd64. Uma vez que os pacotes são compilados, eles estão em um layout idêntico aos espelhos oficiais. Esses pacotes podem ser usados pelo <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg&amp;sektion=8&amp;format=html">pkg(8)</a> e por outras ferramentas de gerenciamento de pacotes.</p></div><div class=paragraph><p>O Poudriere é instalado usando o pacote ou port <a class=package href=https://cgit.freebsd.org/ports/tree/ports-mgmt/poudriere/>ports-mgmt/poudriere</a>. A instalação inclui um arquivo de configuração de exemplo, <span class=filename>/usr/local/etc/poudriere.conf.sample</span>. Copie este arquivo para <span class=filename>/usr/local/etc/poudriere.conf</span>. Edite o arquivo copiado de acordo com a configuração local.</p></div><div class=paragraph><p>Embora o ZFS não seja necessário no sistema que executa o poudriere, o seu uso é benéfico. Quando o ZFS é usado, o <code>ZPOOL</code> deve ser especificado em <span class=filename>/usr/local/etc/poudriere.conf</span> e o <code>FREEBSD_HOST</code> deve ser definido para um espelho próximo. A definição de <code>CCACHE_DIR</code> permite o uso de <a class=package href=https://cgit.freebsd.org/ports/tree/devel/ccache/>devel/ccache</a> para armazenar em cache a compilação e reduzir os tempos de compilação para o código compilado com freqüência. Pode ser conveniente colocar os conjuntos de dados do poudriere em uma árvore isolada montada em <span class=filename>/poudriere</span>. Os valores padrões para as outras variáveis de configuração são adequados.</p></div><div class=paragraph><p>O número de núcleos do processador detectados é usado para definir quantas compilações serão executadas em paralelo. Forneça memória virtual suficiente, seja por meio de RAM ou espaço de swap. Se a memória virtual se esgotar, as jails de compilação serão interrompidas e desativadas, resultando em mensagens de erro estranhas.</p></div><div class=sect3><h4 id=poudriere-initialization>4.6.1. Inicializar o Jails e o Port Trees<a class=anchor href=#poudriere-initialization></a></h4><div class=paragraph><p>Após a configuração, inicialize o poudriere para que ele instale um jail com a árvore do FreeBSD requerida e uma árvore de ports. Especifique um nome para o jail usando <code>-j</code> e a versão do FreeBSD com <code>-v</code>. Em sistemas que executam o FreeBSD/amd64, a arquitetura pode ser definida com <code>-a</code> para <code>i386</code> ou <code>amd64</code>. O padrão é a arquitetura mostrada pelo <code>uname</code>.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># poudriere jail -c -j 11amd64 -v 11.4-RELEASE</span>
<span class=o>[</span>00:00:00] Creating 11amd64 fs at /poudriere/jails/11amd64... <span class=k>done</span>
<span class=o>[</span>00:00:00] Using pre-distributed MANIFEST <span class=k>for </span>FreeBSD 11.4-RELEASE amd64
<span class=o>[</span>00:00:00] Fetching base <span class=k>for </span>FreeBSD 11.4-RELEASE amd64
/poudriere/jails/11amd64/fromftp/base.txz              125 MB 4110 kBps    31s
<span class=o>[</span>00:00:33] Extracting base... <span class=k>done</span>
<span class=o>[</span>00:00:54] Fetching src <span class=k>for </span>FreeBSD 11.4-RELEASE amd64
/poudriere/jails/11amd64/fromftp/src.txz               154 MB 4178 kBps    38s
<span class=o>[</span>00:01:33] Extracting src... <span class=k>done</span>
<span class=o>[</span>00:02:31] Fetching lib32 <span class=k>for </span>FreeBSD 11.4-RELEASE amd64
/poudriere/jails/11amd64/fromftp/lib32.txz              24 MB 3969 kBps    06s
<span class=o>[</span>00:02:38] Extracting lib32... <span class=k>done</span>
<span class=o>[</span>00:02:42] Cleaning up... <span class=k>done</span>
<span class=o>[</span>00:02:42] Recording filesystem state <span class=k>for </span>clean... <span class=k>done</span>
<span class=o>[</span>00:02:42] Upgrading using ftp
/etc/resolv.conf -&gt; /poudriere/jails/11amd64/etc/resolv.conf
Looking up update.FreeBSD.org mirrors... 3 mirrors found.
Fetching public key from update4.freebsd.org... <span class=k>done</span><span class=nb>.</span>
Fetching metadata signature <span class=k>for </span>11.4-RELEASE from update4.freebsd.org... <span class=k>done</span><span class=nb>.</span>
Fetching metadata index... <span class=k>done</span><span class=nb>.</span>
Fetching 2 metadata files... <span class=k>done</span><span class=nb>.</span>
Inspecting system... <span class=k>done</span><span class=nb>.</span>
Preparing to download files... <span class=k>done</span><span class=nb>.</span>
Fetching 124 patches.....10....20....30....40....50....60....70....80....90....100....110....120.. <span class=k>done</span><span class=nb>.</span>
Applying patches... <span class=k>done</span><span class=nb>.</span>
Fetching 6 files... <span class=k>done</span><span class=nb>.</span>
The following files will be added as part of updating to
11.4-RELEASE-p1:
/usr/src/contrib/unbound/.github
/usr/src/contrib/unbound/.github/FUNDING.yml
/usr/src/contrib/unbound/contrib/drop2rpz
/usr/src/contrib/unbound/contrib/unbound_portable.service.in
/usr/src/contrib/unbound/services/rpz.c
/usr/src/contrib/unbound/services/rpz.h
/usr/src/lib/libc/tests/gen/spawnp_enoexec.sh
The following files will be updated as part of updating to
11.4-RELEASE-p1:
<span class=o>[</span>…]
Installing updates...Scanning //usr/share/certs/blacklisted <span class=k>for </span>certificates...
Scanning //usr/share/certs/trusted <span class=k>for </span>certificates...
 <span class=k>done</span><span class=nb>.</span>
11.4-RELEASE-p1
<span class=o>[</span>00:04:06] Recording filesystem state <span class=k>for </span>clean... <span class=k>done</span>
<span class=o>[</span>00:04:07] Jail 11amd64 11.4-RELEASE-p1 amd64 is ready to be used</code></pre></div></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># poudriere ports -c -p local -m svn+https</span>
<span class=o>[</span>00:00:00] Creating <span class=nb>local </span>fs at /poudriere/ports/local... <span class=k>done</span>
<span class=o>[</span>00:00:00] Checking out the ports tree... <span class=k>done</span></code></pre></div></div><div class=paragraph><p>Em um único computador, o poudriere pode construir ports com várias configurações, em vários jails e de diferentes árvores de ports. Configurações customizadas para estas combinações são chamadas de <em>sets</em>. Veja a seção CUSTOMIZAÇÃO do <a href="https://man.freebsd.org/cgi/man.cgi?query=poudriere&amp;sektion=8&amp;format=html">poudriere(8)</a> para detalhes depois que o <a class=package href=https://cgit.freebsd.org/ports/tree/ports-mgmt/poudriere/>ports-mgmt/poudriere</a> ou o <a class=package href=https://cgit.freebsd.org/ports/tree/ports-mgmt/poudriere-devel/>ports-mgmt/poudriere-devel</a> estiver instalado.</p></div><div class=paragraph><p>A configuração básica mostrada aqui coloca um único jail-, port-, e um set específico <span class=filename>make.conf</span> em <span class=filename>/usr/local/etc/poudriere.d</span>. O nome do arquivo neste exemplo é criado combinando o nome do jail, o nome do port e o nome do set: <span class=filename>11amd64-local-workstation-make.conf</span>. O sistema <span class=filename>make.conf</span> e este novo arquivo são combinados em tempo de compilação para criar o <span class=filename>make.conf</span> usado pela jail de compilação.</p></div><div class=paragraph><p>Os pacotes a serem criados são inseridos em <span class=filename>11amd64-local-workstation-pkglist</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>editors/emacs
devel/git
ports-mgmt/pkg
...</pre></div></div><div class=paragraph><p>Opções e dependências para os ports especificados são configuradas:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># poudriere options -j 11amd64 -p local -z workstation -f 11amd64-local-workstation-pkglist</span></code></pre></div></div><div class=paragraph><p>Finalmente, os pacotes são compilados e um repositório de pacotes é criado:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># poudriere bulk -j 11amd64 -p local -z workstation -f 11amd64-local-workstation-pkglist</span></code></pre></div></div><div class=paragraph><p>Durante a execução, pressionar <span class=keyseq><kbd>Ctrl</kbd>+<kbd>t</kbd></span> exibe o estado atual da compilação. O Poudriere também cria arquivos em <span class=filename>/poudriere/logs/bulk/jailname</span> que podem ser usados com um servidor da Web para exibir informações de compilação.</p></div><div class=paragraph><p>Após a conclusão, os novos pacotes estão agora disponíveis para instalação a partir do repositório poudriere.</p></div><div class=paragraph><p>Para obter maiores informações sobre o uso do poudriere, consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=poudriere&amp;sektion=8&amp;format=html">poudriere(8)</a> e o site principal, <a href=https://github.com/freebsd/poudriere/wiki class=bare>https://github.com/freebsd/poudriere/wiki</a>.</p></div></div><div class=sect3><h4 id=_configurando_clientes_do_pkg_para_usar_um_repositório_de_poudriere>4.6.2. Configurando Clientes do pkg para usar um repositório de Poudriere<a class=anchor href=#_configurando_clientes_do_pkg_para_usar_um_repositório_de_poudriere></a></h4><div class=paragraph><p>Embora seja possível usar um repositório personalizado ao lado do repositório oficial, às vezes é útil desativar o repositório oficial. Isso é feito criando um arquivo de configuração que substitui e desativa o arquivo de configuração oficial. Crie o <span class=filename>/usr/local/etc/pkg/repos/FreeBSD.conf</span> que deverá conter o seguinte:</p></div><div class="literalblock programlisting"><div class=content><pre>FreeBSD: {
	enabled: no
}</pre></div></div><div class=paragraph><p>Geralmente é mais fácil disponibilizar um repositório poudriere para as máquinas clientes via HTTP. Configure um servidor web para disponibilizar o diretório de pacotes, por exemplo: <span class=filename>/usr/local/poudriere/data/packages/11amd64</span>, onde <span class=filename>11amd64</span> é o nome da compilação.</p></div><div class=paragraph><p>Se a URL para o repositório de pacotes for: <code><a href=http://pkg.example.com/11amd64 class=bare>http://pkg.example.com/11amd64</a></code>, o arquivo de configuração do repositório em <span class=filename>/usr/local/etc/pkg/repos/custom.conf</span> ficaria assim:</p></div><div class="literalblock programlisting"><div class=content><pre>custom: {
	url: &#34;http://pkg.example.com/11amd64&#34;,
	enabled: yes,
}</pre></div></div></div></div><div class=sect2><h3 id=ports-nextsteps>4.7. Considerações pós-instalação<a class=anchor href=#ports-nextsteps></a></h3><div class=paragraph><p>Independentemente do software ter sido instalado a partir de um pacote binário ou de um port, a maioria dos aplicativos de terceiros requer algum nível de configuração após a instalação. Os seguintes comandos e locais podem ser usados para ajudar a determinar o que foi instalado com o aplicativo.</p></div><div class=ulist><ul><li><p>A maioria dos aplicativos instala pelo menos um arquivo de configuração padrão em <span class=filename>/usr/local/etc</span>. Nos casos em que um aplicativo possui um grande número de arquivos de configuração, um subdiretório será criado para mantê-los. Geralmente, os arquivos de configuração de exemplo são instalados e terminam com um sufixo, como <span class=filename>.sample</span>. Os arquivos de configuração devem ser revisados e possivelmente editados para atender às necessidades do sistema. Para editar um arquivo de amostra, primeiro copie-o sem a extensão <span class=filename>.sample</span>.</p></li><li><p>As aplicações que fornecem documentação irão instalá-la em <span class=filename>/usr/local/shared/doc</span> e muitos aplicativos também instalam páginas de manual. Esta documentação deve ser consultada antes de continuar.</p></li><li><p>Alguns aplicativos executam serviços que devem ser adicionados ao <span class=filename>/etc/rc.conf</span> antes de iniciar o aplicativo. Esses aplicativos geralmente instalam um script de inicialização em <span class=filename>/usr/local/etc/rc.d</span>. Veja <a href=./#configtuning-starting-services>Iniciando Serviços</a> para maiores informações.</p><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Por padrão, os aplicativos não executam o script de inicialização durante a instalação, nem executam o script de parada após a desinstalação ou atualização. Essa decisão é deixada para o administrador do sistema.</p></div></td></tr></tbody></table></div></li><li><p>Os usuários de <a href="https://man.freebsd.org/cgi/man.cgi?query=csh&amp;sektion=1&amp;format=html">csh(1)</a> devem executar <code>rehash</code> para reconstruir a lista dos binários conhecidos nos shells <code>PATH</code>.</p></li><li><p>Use <code>pkg info</code> para determinar quais arquivos, páginas man e binários foram instalados com o aplicativo.</p></li></ul></div></div><div class=sect2><h3 id=ports-broken>4.8. Lidando com ports quebrados<a class=anchor href=#ports-broken></a></h3><div class=paragraph><p>Quando um port não é compilado ou instalado, tente o seguinte:</p></div><div class="olist arabic"><ol class=arabic><li><p>Procure para ver se há uma correção pendente para o port no <a href=https://www.FreeBSD.org/support/>Banco de Dados do Relatório de Problemas</a>. Nesse caso, implementar a correção proposta pode corrigir o problema.</p></li><li><p>Peça ajuda ao mantenedor do port. Digite <code>make maintainer</code> no diretório do port ou leia o <span class=filename>Makefile</span> do port para encontrar o endereço de e-mail do mantenedor. Lembre-se de incluir a linha <code>$FreeBSD:</code> do <span class=filename>Makefile</span> do port e a saída que leva ao erro no e-mail para o mantenedor.</p><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Alguns ports não são mantidos por um indivíduo, mas sim por um grupo de mantenedores representado por uma <a href=https://docs.freebsd.org/pt-br/articles/mailing-list-faq/>lista de discussão</a>. Muitos, mas não todos, esses endereços se parecem com <a href=mailto:freebsd-listname@FreeBSD.org>freebsd-listname@FreeBSD.org</a>. Por favor, leve isso em consideração ao enviar um email.</p></div><div class=paragraph><p>Em particular, os ports mantidos por <a href=mailto:ports@FreeBSD.org>ports@FreeBSD.org</a> não são mantidos por um indivíduo específico. Em vez disso, quaisquer correções e suporte vêm da comunidade geral que se inscreve nessa lista de discussão. Mais voluntários são sempre necessários!</p></div></td></tr></tbody></table></div><div class=paragraph><p>Se não houver resposta ao email, use o Bugzilla para enviar um relatório de bug usando as instruções em <a href=https://docs.freebsd.org/pt-br/articles/problem-reports/>Escrevendo Relatórios de Problemas do FreeBSD</a>.</p></div></li><li><p>Conserte-o! O <a href=https://docs.freebsd.org/pt-br/books/porters-handbook/>Porters Handbook</a> inclui informações detalhadas sobre a infra-estrutura da arvore de ports para que você possa corrigir possiveis erros na compilacao de um ports que quebrou ou ocasionou um erro de compilacao ou até mesmo submeta seu próprio projeto!</p></li><li><p>Instale o pacote em vez do port usando as instruções em <a href=#pkgng-intro>Usando o pkg para o gerenciamento de pacotes binários</a>.</p></li></ol></div></div></div></div><div class=sect1><h2 id=x11>Capítulo 5. O sistema X Window<a class=anchor href=#x11></a></h2><div class=sectionbody><div class=sect2><h3 id=x11-synopsis>5.1. Sinopse<a class=anchor href=#x11-synopsis></a></h3><div class=paragraph><p>Uma instalação padrão do FreeBSD usando o bsdinstall não irá instalar automaticamente uma interface gráfica para o usuário. Este capítulo descreve como instalar e configurar o Xorg, que fornece o sistema X Window open source usado para fornecer um ambiente gráfico. Em seguida, descreve como encontrar e instalar um ambiente de área de trabalho ou um gerenciador de janelas.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Os usuários que preferem um método de instalação que configure automaticamente o Xorg devem consultar <a href=https://www.furybsd.org>FuryBSD</a>, <a href=https://ghostbsd.org>GhostBSD</a> ou <a href=https://www.midnightbsd.org>MidnightBSD</a>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Para obter maiores informações sobre o hardware de vídeo suportado pelo Xorg, consulte o web site <a href=http://www.x.org/>x.org</a>.</p></div><div class=paragraph><p>Depois de ler este capítulo, você saberá:</p></div><div class=ulist><ul><li><p>Quais são os vários componentes do Sistema X Window e como eles interoperam.</p></li><li><p>Como instalar e configurar o Xorg.</p></li><li><p>Como instalar e configurar vários gerenciadores de janelas e ambientes de desktop.</p></li><li><p>Como usar fontes TrueType™ no Xorg.</p></li><li><p>Como configurar seu sistema para usar um sistema de login gráfico (XDM).</p></li></ul></div><div class=paragraph><p>Antes de ler este capítulo, você deve:</p></div><div class=ulist><ul><li><p>Saber como instalar softwares adicionais de terceiros, conforme descrito em <a href=./#ports>Instalando Aplicativos. Pacotes e Ports</a>.</p></li></ul></div></div><div class=sect2><h3 id=x-understanding>5.2. Terminologia<a class=anchor href=#x-understanding></a></h3><div class=paragraph><p>Embora não seja necessário entender todos os detalhes dos vários componentes do Sistema X Window e como eles interagem, algum conhecimento básico desses componentes pode ser útil.</p></div><div class=dlist><dl><dt class=hdlist1>Servidor X</dt><dd><p>O X foi projetado desde o início para ser centrado em rede e para adotar um modelo "cliente-servidor". Neste modelo, o "Servidor X" é executado no computador que possui o teclado, o monitor e o mouse conectados. A responsabilidade do servidor inclui tarefas como gerenciar o monitor, manipular a entrada do teclado e do mouse e manipular a entrada ou saída de outros dispositivos, como um tablet ou um projetor de vídeo. Isso confunde algumas pessoas, porque a terminologia X é exatamente o oposto do que eles esperam. Eles esperam que o "X server" seja a grande máquina poderosa no final das contas, e o "Ciente X" seja a máquina em sua mesa.</p></dd><dt class=hdlist1>Cliente X</dt><dd><p>Cada aplicativo X, como o XTerm ou o Firefox, é um "cliente". Um cliente envia mensagens para o servidor, como "Por favor, desenhe uma janela nessas coordenadas", e o servidor envia de volta mensagens como "O usuário apenas clicou no botão OK".</p><div class=paragraph><p>Em um ambiente doméstico ou de uma pequena empresa, o servidor X e os clientes X geralmente são executados no mesmo computador. Também é possível executar o servidor X em um computador menos potente e executar os aplicativos X em um sistema mais poderoso. Nesse cenário, a comunicação entre o cliente X e o servidor ocorre através da rede.</p></div></dd><dt class=hdlist1>Gerenciador de janelas</dt><dd><p>O X não dita como as janelas devem se parecer na tela, como movê-las com o mouse, quais teclas devem ser usadas para mover-se entre as janelas, como devem ficar as barras de título em cada janela, se elas têm ou não botões para fechar nelas e assim por diante. Em vez disso, o X delega essa responsabilidade para um gerenciador de janelas separado. Existem <a href=http://www.xwinman.org/>dezenas de gerenciadores de janelas</a> disponíveis. Cada gerenciador de janelas oferece uma aparência diferente: alguns oferecem suporte a desktops virtuais, alguns permitem pressionamentos de tecla personalizados para gerenciar a área de trabalho, alguns têm um botão "Iniciar" e alguns são personalizáveis, permitindo uma alteração completa da aparência da área de trabalho. Os gerenciadores de janelas estão disponíveis na categoria <span class=filename>x11-wm</span> da coleção de ports.</p><div class=paragraph><p>Cada gerenciador de janelas usa um mecanismo de configuração diferente. Alguns esperam que o arquivo de configuração seja escrito à mão, enquanto outros fornecem ferramentas gráficas para a maioria das tarefas de configuração.</p></div></dd><dt class=hdlist1>Ambiente de desktop</dt><dd><p>O KDE e o GNOME são considerados ambientes de desktop, pois incluem um conjunto completo de aplicativos para executar tarefas comuns de desktop. Estes podem incluir pacotes de escritório, navegadores da web e jogos.</p></dd><dt class=hdlist1>Política de foco</dt><dd><p>O gerenciador de janelas é responsável pela política de foco do mouse. Essa política fornece alguns meios para escolher qual janela está recebendo ativamente as teclas digitadas e também deve indicar visivelmente qual janela está ativa no momento.</p><div class=paragraph><p>Uma política de foco é chamada "click-to-focus". Neste modelo, uma janela fica ativa ao receber um clique do mouse. Na política "focus-follows-mouse", a janela que está sob o ponteiro do mouse tem foco e o foco é alterado apontando para outra janela. Se o mouse estiver sobre a janela raiz, esta janela estará focada. No modelo "sloppy-focus", se o mouse for movido sobre a janela raiz, a janela usada mais recentemente ainda terá o foco. Com sloppy-focus, o foco só é alterado quando o cursor entra em uma nova janela, e não ao sair da janela atual. Na política de "click-to-focus", a janela ativa é selecionada pelo clique do mouse. A janela pode então ser destacada para aparecer na frente de todas as outras janelas. Todas as teclas digitadas serão direcionadas para esta janela, mesmo se o cursor for movido para outra janela.</p></div><div class=paragraph><p>Diferentes gerenciadores de janela suportam diferentes modelos de foco. Todos eles suportam click-to-focus, e a maioria deles também suporta outras políticas. Consulte a documentação do gerenciador de janelas para determinar quais modelos de foco estão disponíveis.</p></div></dd><dt class=hdlist1>Widgets</dt><dd><p>Widget é um termo para todos os itens na interface do usuário que podem ser clicados ou manipulados de alguma forma. Isso inclui botões, caixas de seleção, botões de opção, ícones e listas. Um kit de ferramentas de widget é um conjunto de widgets usado para criar aplicativos gráficos. Existem vários toolkits de widgets populares, incluindo o Qt, usado pelo KDE, e o GTK+, usado pelo GNOME. Como resultado, os aplicativos terão uma aparência e comportamentos diferentes, dependendo de qual kit de ferramentas de widget foi usado para criar o aplicativo.</p></dd></dl></div></div><div class=sect2><h3 id=x-install>5.3. Instalando o Xorg<a class=anchor href=#x-install></a></h3><div class=paragraph><p>No FreeBSD, o Xorg pode ser instalado como um pacote ou port.</p></div><div class=paragraph><p>O pacote binário pode ser instalado rapidamente, mas com menos opções de personalização:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install xorg</span></code></pre></div></div><div class=paragraph><p>Para compilar e instalar a partir da Coleção de Ports:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/x11/xorg</span>
<span class=c># make install clean</span></code></pre></div></div><div class=paragraph><p>Qualquer uma dessas instalações resulta no sistema completo do Xorg sendo instalado. Pacotes binários são a melhor opção para a maioria dos usuários.</p></div><div class=paragraph><p>Uma versão menor do sistema X adequada para usuários experientes está disponível em <a class=package href=https://cgit.freebsd.org/ports/tree/x11/xorg-minimal/>x11/xorg-minimal</a>. A maioria dos documentos, bibliotecas e aplicativos não será instalada. Algumas aplicações requerem esses componentes adicionais para funcionarem.</p></div></div><div class=sect2><h3 id=x-config>5.4. Configuração do Xorg<a class=anchor href=#x-config></a></h3><div class=sect3><h4 id=x-config-quick-start>5.4.1. Inicio Rápido<a class=anchor href=#x-config-quick-start></a></h4><div class=paragraph><p>O Xorg suporta as placas de vídeo, teclados e dispositivos USB mais comuns.</p></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Placas de vídeo, monitores e dispositivos de entrada são detectados automaticamente e não exigem nenhuma configuração manual. Não crie o <span class=filename>xorg.conf</span> ou execute o passo <code>-configure</code> a menos que a configuração automática falhe.</p></div></td></tr></tbody></table></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Se o Xorg tiver sido usado neste computador antes, mova ou remova qualquer arquivo de configuração existente:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mv /etc/X11/xorg.conf ~/xorg.conf.etc</span>
<span class=c># mv /usr/local/etc/X11/xorg.conf ~/xorg.conf.localetc</span></code></pre></div></div></li><li><p>Adicione o usuário que executará o Xorg ao grupo <code>video</code> ou <code>wheel</code> para ativar a aceleração 3D quando disponível. Para adicionar o usuário <em>jru</em> ao grupo que estiver disponível:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pw groupmod video -m jru || pw groupmod wheel -m jru</span></code></pre></div></div></li><li><p>O gerenciador de janelas twm é incluído por padrão. Ele é chamado quando o Xorg se inicia:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% startx</code></pre></div></div></li><li><p>Em algumas versões mais antigas do FreeBSD, o console do sistema deve ser definido como <a href="https://man.freebsd.org/cgi/man.cgi?query=vt&amp;sektion=4&amp;format=html">vt(4)</a> antes que a volta para o console de texto funcione corretamente. Veja <a href=#x-config-kms>Configuração do Modo Kernel (KMS)</a>.</p></li></ol></div></div></div></div><div class=sect3><h4 id=x-config-user-group>5.4.2. Grupo de Usuários para Vídeo Acelerado<a class=anchor href=#x-config-user-group></a></h4><div class=paragraph><p>O acesso ao <span class=filename>/dev/dri</span> é necessário para permitir a aceleração 3D nas placas de vídeo. Geralmente é mais simples adicionar o usuário que estará executando o X no grupo <code>video</code> ou no <code>wheel</code>. Aqui, o <a href="https://man.freebsd.org/cgi/man.cgi?query=pw&amp;sektion=8&amp;format=html">pw(8)</a> é usado para adicionar o usuário <em>slurms</em> ao grupo <code>video</code>, ou ao grupo <code>wheel</code> se não houver nenhum grupo <code>video</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pw groupmod video -m slurms || pw groupmod wheel -m slurms</span></code></pre></div></div></div><div class=sect3><h4 id=x-config-kms>5.4.3. Configuração do Modo Kernel (KMS)<a class=anchor href=#x-config-kms></a></h4><div class=paragraph><p>Quando o computador alterna a exibição do console para uma resolução de tela mais alta para o X, ele deve definir o <em>modo</em> da saída de vídeo. Versões recentes do Xorg usam um sistema dentro do kernel para fazer essas mudanças de modo mais eficiente. Versões mais antigas do FreeBSD usam o <a href="https://man.freebsd.org/cgi/man.cgi?query=sc&amp;sektion=4&amp;format=html">sc(4)</a>, que não tem conhecimento do sistema KMS. O resultado final é que depois de fechar o X, o console do sistema fica em branco, embora ainda esteja funcionando. O console <a href="https://man.freebsd.org/cgi/man.cgi?query=vt&amp;sektion=4&amp;format=html">vt(4)</a> mais recente evita esse problema.</p></div><div class=paragraph><p>Adicione esta linha ao <span class=filename>/boot/loader.conf</span> para ativar o <a href="https://man.freebsd.org/cgi/man.cgi?query=vt&amp;sektion=4&amp;format=html">vt(4)</a>:</p></div><div class="literalblock programlisting"><div class=content><pre>kern.vty=vt</pre></div></div></div><div class=sect3><h4 id=x-config-files>5.4.4. Arquivos de Configuração<a class=anchor href=#x-config-files></a></h4><div class=paragraph><p>A configuração manual geralmente não é necessária. Por favor, não crie manualmente arquivos de configuração, a menos que a autoconfiguração não funcione.</p></div><div class=sect4><h5 id=x-config-files-directory>5.4.4.1. Diretório<a class=anchor href=#x-config-files-directory></a></h5><div class=paragraph><p>O Xorg procura em vários diretórios por arquivos de configuração. O <span class=filename>/usr/local/etc/X11/</span> é o diretório recomendado para esses arquivos no FreeBSD. Usar esse diretório ajuda a manter os arquivos dos aplicativos separados dos arquivos do sistema operacional.</p></div><div class=paragraph><p>Armazenar arquivos de configuração no diretório legado <span class=filename>/etc/X11/</span> ainda funciona. No entanto, isso combina arquivos de aplicativos com os arquivos básicos do FreeBSD e não é recomendado.</p></div></div><div class=sect4><h5 id=x-config-files-single-or-multi>5.4.4.2. Arquivos Únicos ou Múltiplos<a class=anchor href=#x-config-files-single-or-multi></a></h5><div class=paragraph><p>É mais fácil usar multiplos arquivos em que cada um controla uma configuração específica ao invés do único e tradicional <span class=filename>xorg.conf</span>. Esses arquivos são armazenados no subdiretório <span class=filename>xorg.conf.d/</span> do diretório principal do arquivo de configuração. O caminho completo é tipicamente <span class=filename>/usr/local/etc/X11/xorg.conf.d/</span>.</p></div><div class=paragraph><p>Exemplos desses arquivos serão mostrados posteriormente nesta seção.</p></div><div class=paragraph><p>O tradicional e único arquivo <span class=filename>xorg.conf</span> ainda funciona, mas não é tão claro e nem tão flexível quanto vários arquivos no subdiretório <span class=filename>xorg.conf.d/</span>.</p></div></div></div><div class=sect3><h4 id=x-config-video-cards>5.4.5. Placas de Vídeo<a class=anchor href=#x-config-video-cards></a></h4><div class=paragraph><p>Devido as mudanças feitas nas versões recentes do FreeBSD, agora é possível usar drivers gráficos fornecidos pelo Framework do Ports, assim como pelos pacotes. Assim sendo, os usuários podem usar um dos seguintes drivers disponíveis em <a class=package href=https://cgit.freebsd.org/ports/tree/graphics/drm-kmod/>graphics/drm-kmod</a>.</p></div><div id=x-config-video-cards-ports class=dlist><dl><dt class=hdlist1>Intel KMS driver</dt><dd><p>A aceleração 2D e 3D é suportada na maioria das placas gráficas do driver Intel KMS fornecidas pela Intel.</p><div class=paragraph><p>Nome do driver: <code>i915kms</code></p></div><div class=paragraph><p>A aceleração 2D e 3D é suportada na maioria das placas gráficas de driver Radeon KMS mais antigas fornecidas pela AMD.</p></div><div class=paragraph><p>Nome do Driver: <code>radeonkms</code></p></div><div class=paragraph><p>A aceleração 2D e 3D é suportada nas mais recentes placas gráficas do driver AMD KMS fornecidas pela AMD.</p></div><div class=paragraph><p>Nome do Driver: <code>amdgpu</code></p></div><div class=paragraph><p>Para referência, veja <a href=https://en.wikipedia.org/wiki/List_of_Intel_graphics_processing_units class=bare>https://en.wikipedia.org/wiki/List_of_Intel_graphics_processing_units</a> ou <a href=https://en.wikipedia.org/wiki/List_of_AMD_graphics_processing_units class=bare>https://en.wikipedia.org/wiki/List_of_AMD_graphics_processing_units</a> para uma lista das GPUs suportadas.</p></div></dd></dl></div><div id=x-config-video-cards-intel class=dlist><dl><dt class=hdlist1>Intel™</dt><dd><p>A aceleração 3D é suportada na maioria dos chipsets gráficos da Intel™ até o Ivy Bridge (HD Graphics 2500, 4000 e P4000), incluindo Iron Lake (HD Graphics) e Sandy Bridge (HD Graphics 2000) .</p><div class=paragraph><p>Nome do driver: <code>intel</code></p></div><div class=paragraph><p>Para referência, veja <a href=https://en.wikipedia.org/wiki/List_of_Intel_graphics_processing_units class=bare>https://en.wikipedia.org/wiki/List_of_Intel_graphics_processing_units</a>.</p></div></dd></dl></div><div id=x-config-video-cards-radeon class=dlist><dl><dt class=hdlist1>AMD™ Radeon</dt><dd><p>Aceleração 2D e 3D é suportada em placas Radeon das mais antigas até a série HD6000.</p><div class=paragraph><p>Nome do Driver: <code>radeon</code></p></div><div class=paragraph><p>Para referência, veja <a href=https://en.wikipedia.org/wiki/List_of_AMD_graphics_processing_units class=bare>https://en.wikipedia.org/wiki/List_of_AMD_graphics_processing_units</a>.</p></div></dd></dl></div><div id=x-config-video-cards-nvidia class=dlist><dl><dt class=hdlist1>NVIDIA</dt><dd><p>Vários drivers da NVIDIA estão disponíveis na categoria <span class=filename>x11</span> da Coleção de Ports. Instale o driver que corresponde à sua placa de vídeo.</p><div class=paragraph><p>Para referência, veja <a href=https://en.wikipedia.org/wiki/List_of_Nvidia_graphics_processing_units class=bare>https://en.wikipedia.org/wiki/List_of_Nvidia_graphics_processing_units</a>.</p></div></dd></dl></div><div id=x-config-video-cards-hybrid class=dlist><dl><dt class=hdlist1>Gráficos Híbridos de Combinação</dt><dd><p>Alguns notebooks adicionam unidades de processamento gráfico adicionais àquelas incorporadas ao chipset ou ao processador. O <em>Optimus</em> combina o hardware da Intel™ e da NVIDIA. O <em>Switchable Graphics</em> ou <em>Hybrid Graphics</em> são uma combinação dos processadores Intel™ ou AMD™ e uma GPUAMD™ Radeon.</p><div class=paragraph><p>As implementações desses sistemas gráficos híbridos variam e o Xorg no FreeBSD não é capaz de controlar todas as versões deles.</p></div><div class=paragraph><p>Alguns computadores fornecem uma opção no BIOS para desativar um dos adaptadores gráficos ou selecionar um modo <em>discreto</em> que pode ser usado com um dos drivers de placa de vídeo padrão. Por exemplo, às vezes é possível desativar a GPU NVIDIA em um sistema Optimus. O vídeo Intel™ pode então ser usado com um driver Intel™.</p></div><div class=paragraph><p>Configurações de BIOS dependem do modelo do computador. Em algumas situações, ambas GPUs podem ser deixadas ativadas, mas criar um arquivo de configuração que use apenas a GPU principal na seção <code>Device</code> é o suficiente para tornar esse sistema funcional.</p></div></dd></dl></div><div id=x-config-video-cards-other class=dlist><dl><dt class=hdlist1>Outras placas de vídeo</dt><dd><p>Drivers para algumas placas de vídeo menos comuns podem ser encontrados no diretório <span class=filename>x11-drivers</span> da Coleção de Ports.</p><div class=paragraph><p>PLacas que não são suportadas por um driver específico ainda podem ser usadas com o driver <a class=package href=https://cgit.freebsd.org/ports/tree/x11-drivers/xf86-video-vesa/>x11-drivers/xf86-video-vesa</a>. Este driver é instalado pelo <a class=package href=https://cgit.freebsd.org/ports/tree/x11/xorg/>x11/xorg</a>. Ele também pode ser instalado manualmente como <a class=package href=https://cgit.freebsd.org/ports/tree/x11-drivers/xf86-video-vesa/>x11-drivers/xf86-video-vesa</a>. O Xorg tenta usar este driver quando um driver específico não é encontrado para a placa de vídeo.</p></div><div class=paragraph><p>O <a class=package href=https://cgit.freebsd.org/ports/tree/x11-drivers/xf86-video-scfb/>x11-drivers/xf86-video-scfb</a> é um driver de vídeo não especializado similar que funciona em muitos computadores UEFI e ARM™.</p></div></dd></dl></div><div id=x-config-video-cards-file class=dlist><dl><dt class=hdlist1>Configurando o driver de vídeo em um arquivo</dt><dd><p>Para definir o driver Intel™ em um arquivo de configuração:</p><div id=x-config-video-cards-file-intel class=exampleblock><div class=title>Exemplo 15. Selecione o driver de vídeo Intel™ em um arquivo</div><div class=content><div class=paragraph><p><span class=filename>/usr/local/etc/X11/xorg.conf.d/driver-intel.conf</span></p></div><div class="literalblock programlisting"><div class=content><pre>Section &#34;Device&#34;
	Identifier &#34;Card0&#34;
	Driver     &#34;intel&#34;
	# BusID    &#34;PCI:1:0:0&#34;
EndSection</pre></div></div><div class=paragraph><p>Se mais de uma placa de vídeo estiver presente, o identificador <code>BusID</code> pode ser descomentado e configurado para selecionar a placa desejada. Uma lista de barramento de placa de vídeo ID pode ser exibida com <code>pciconf -lv | grep -B3 display</code>.</p></div></div></div><div class=paragraph><p>Para definir o driver Radeon em um arquivo de configuração:</p></div><div id=x-config-video-cards-file-radeon class=exampleblock><div class=title>Exemplo 16. Selecione o driver de vídeo Radeon em um arquivo</div><div class=content><div class=paragraph><p><span class=filename>/usr/local/etc/X11/xorg.conf.d/driver-radeon.conf</span></p></div><div class="literalblock programlisting"><div class=content><pre>Section &#34;Device&#34;
	Identifier &#34;Card0&#34;
	Driver     &#34;radeon&#34;
EndSection</pre></div></div></div></div><div class=paragraph><p>Para definir o driver VESA em um arquivo de configuração:</p></div><div id=x-config-video-cards-file-vesa class=exampleblock><div class=title>Exemplo 17. Selecione o driver de vídeo VESA em um arquivo</div><div class=content><div class=paragraph><p><span class=filename>/usr/local/etc/X11/xorg.conf.d/driver-vesa.conf</span></p></div><div class="literalblock programlisting"><div class=content><pre>Section &#34;Device&#34;
	Identifier &#34;Card0&#34;
	Driver     &#34;vesa&#34;
EndSection</pre></div></div></div></div><div class=paragraph><p>Para definir o driver <code>scfb</code> para uso com um computador UEFI ou ARM™:</p></div><div id=x-config-video-cards-file-scfb class=exampleblock><div class=title>Exemplo 18. Selecione o driver de vídeo <code>scfb</code> em um arquivo</div><div class=content><div class=paragraph><p><span class=filename>/usr/local/etc/X11/xorg.conf.d/driver-scfb.conf</span></p></div><div class="literalblock programlisting"><div class=content><pre>Section &#34;Device&#34;
	Identifier &#34;Card0&#34;
	Driver     &#34;scfb&#34;
EndSection</pre></div></div></div></div></dd></dl></div></div><div class=sect3><h4 id=x-config-monitors>5.4.6. Monitores<a class=anchor href=#x-config-monitors></a></h4><div class=paragraph><p>Quase todos os monitores suportam o padrão Extended Display Identification Data (EDID). O Xorg usa o EDID para se comunicar com o monitor e detectar as resoluções e taxas de atualização suportadas. Em seguida, seleciona a combinação mais adequada de configurações para usar com esse monitor.</p></div><div class=paragraph><p>Outras resoluções suportadas pelo monitor podem ser escolhidas definindo a resolução desejada nos arquivos de configuração, ou após o servidor X ter sido iniciado com <a href="https://man.freebsd.org/cgi/man.cgi?query=xrandr&amp;sektion=1&amp;format=html">xrandr(1)</a>.</p></div><div id=x-config-monitors-xrandr class=dlist><dl><dt class=hdlist1>Usando <a href="https://man.freebsd.org/cgi/man.cgi?query=xrandr&amp;sektion=1&amp;format=html">xrandr(1)</a></dt><dd><p>Execute o <a href="https://man.freebsd.org/cgi/man.cgi?query=xrandr&amp;sektion=1&amp;format=html">xrandr(1)</a> sem nenhum parâmetro para ver uma lista de saídas de vídeo e modos de monitor detectados:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% xrandr
Screen 0: minimum 320 x 200, current 3000 x 1920, maximum 8192 x 8192
DVI-0 connected primary 1920x1200+1080+0 <span class=o>(</span>normal left inverted right x axis y axis<span class=o>)</span> 495mm x 310mm
   1920x1200     59.95<span class=k>*</span>+
   1600x1200     60.00
   1280x1024     85.02    75.02    60.02
   1280x960      60.00
   1152x864      75.00
   1024x768      85.00    75.08    70.07    60.00
   832x624       74.55
   800x600       75.00    60.32
   640x480       75.00    60.00
   720x400       70.08
DisplayPort-0 disconnected <span class=o>(</span>normal left inverted right x axis y axis<span class=o>)</span>
HDMI-0 disconnected <span class=o>(</span>normal left inverted right x axis y axis<span class=o>)</span></code></pre></div></div><div class=paragraph><p>Isso mostra que a saída <code>DVI-0</code> está sendo usada para exibir uma resolução de tela de 1920x1200 pixels a uma taxa de atualização de cerca de 60 Hz. Os monitores não estão conectados aos conectores <code>DisplayPort-0</code> e <code>HDMI-0</code>.</p></div><div class=paragraph><p>Qualquer um dos outros modos de exibição pode ser selecionado com <a href="https://man.freebsd.org/cgi/man.cgi?query=xrandr&amp;sektion=1&amp;format=html">xrandr(1)</a>. Por exemplo, para mudar para 1280x1024 a 60 Hz:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% xrandr <span class=nt>--mode</span> 1280x1024 <span class=nt>--rate</span> 60</code></pre></div></div><div class=paragraph><p>Uma tarefa comum é usar a saída de vídeo externa em um notebook para um projetor de vídeo.</p></div><div class=paragraph><p>O tipo e a quantidade de conectores de saída variam entre os dispositivos, e o nome dado a cada saída varia de driver para driver. O que um driver chama de <code>HDMI-1</code>, outro pode chamar de <code>HDMI1</code>. Portanto, o primeiro passo é executar <a href="https://man.freebsd.org/cgi/man.cgi?query=xrandr&amp;sektion=1&amp;format=html">xrandr(1)</a> para listar todas as saídas disponíveis:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% xrandr
Screen 0: minimum 320 x 200, current 1366 x 768, maximum 8192 x 8192
LVDS1 connected 1366x768+0+0 <span class=o>(</span>normal left inverted right x axis y axis<span class=o>)</span> 344mm x 193mm
   1366x768      60.04<span class=k>*</span>+
   1024x768      60.00
   800x600       60.32    56.25
   640x480       59.94
VGA1 connected <span class=o>(</span>normal left inverted right x axis y axis<span class=o>)</span>
   1280x1024     60.02 +  75.02
   1280x960      60.00
   1152x864      75.00
   1024x768      75.08    70.07    60.00
   832x624       74.55
   800x600       72.19    75.00    60.32    56.25
   640x480       75.00    72.81    66.67    60.00
   720x400       70.08
HDMI1 disconnected <span class=o>(</span>normal left inverted right x axis y axis<span class=o>)</span>
DP1 disconnected <span class=o>(</span>normal left inverted right x axis y axis<span class=o>)</span></code></pre></div></div><div class=paragraph><p>Quatro saídas foram encontradas: os conectores <code>LVDS1</code> e <code>VGA1</code>, <code>HDMI1</code> e <code>DP1</code> do painel interno.</p></div><div class=paragraph><p>O projetor foi conectado à saída <code>VGA1</code>. O <a href="https://man.freebsd.org/cgi/man.cgi?query=xrandr&amp;sektion=1&amp;format=html">xrandr(1)</a> agora é usado para definir essa saída para a resolução nativa do projetor e adicionar o espaço adicional à direita da área de trabalho:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% xrandr <span class=nt>--output</span> VGA1 <span class=nt>--auto</span> <span class=nt>--right-of</span> LVDS1</code></pre></div></div><div class=paragraph><p>A opção <code>--auto</code> escolhe a resolução e a taxa de atualização detectadas pelo EDID. Se a resolução não for detectada corretamente, um valor fixo pode ser fornecido com <code>--mode</code> em vez da instrução <code>--auto</code>. Por exemplo, a maioria dos projetores pode ser usada com uma resolução de 1024x768, que é definida com <code>--mode 1024x768</code>.</p></div><div class=paragraph><p>O <a href="https://man.freebsd.org/cgi/man.cgi?query=xrandr&amp;sektion=1&amp;format=html">xrandr(1)</a> geralmente é executado a partir do <span class=filename>.xinitrc</span> para definir o modo apropriado quando o X é iniciado.</p></div></dd></dl></div><div id=x-config-monitors-files class=dlist><dl><dt class=hdlist1>Configurando a resolução do monitor em um arquivo</dt><dd><p>Para definir uma resolução de tela de 1024x768 em um arquivo de configuração:</p><div class=exampleblock><div class=title>Exemplo 19. Defina a resolução de tela em um arquivo</div><div class=content><div class=paragraph><p><span class=filename>/usr/local/etc/X11/xorg.conf.d/screen-resolution.conf</span></p></div><div class="literalblock programlisting"><div class=content><pre>Section &#34;Screen&#34;
	Identifier &#34;Screen0&#34;
	Device     &#34;Card0&#34;
	SubSection &#34;Display&#34;
	Modes      &#34;1024x768&#34;
	EndSubSection
EndSection</pre></div></div></div></div><div class=paragraph><p>Os poucos monitores que não possuem EDID podem ser configurados setando o <code>HorizSync</code> e o <code>VertRefresh</code> para o intervalo de frequências suportado pelo monitor.</p></div><div class=exampleblock><div class=title>Exemplo 20. Configurando Manualmente as Frequências do Monitor</div><div class=content><div class=paragraph><p><span class=filename>/usr/local/etc/X11/xorg.conf.d/monitor0-freq.conf</span></p></div><div class="literalblock programlisting"><div class=content><pre>Section &#34;Monitor&#34;
	Identifier   &#34;Monitor0&#34;
	HorizSync    30-83   # kHz
	VertRefresh  50-76   # Hz
EndSection</pre></div></div></div></div></dd></dl></div></div><div class=sect3><h4 id=x-config-input>5.4.7. Dispositivos de Entrada<a class=anchor href=#x-config-input></a></h4><div class=sect4><h5 id=x-config-input-keyboard>5.4.7.1. Teclados<a class=anchor href=#x-config-input-keyboard></a></h5><div id=x-config-input-keyboard-layout class=dlist><dl><dt class=hdlist1>Layout do Teclado</dt><dd><p>A localização padronizada das teclas em um teclado é chamada de <em>layout</em>. Layouts e outros parâmetros ajustáveis são listados em <a href="https://man.freebsd.org/cgi/man.cgi?query=xkeyboard-config&amp;sektion=7&amp;format=html">xkeyboard-config(7)</a>.</p><div class=paragraph><p>Um layout dos Estados Unidos é o padrão. Para selecionar um layout alternativo, defina as opções <code>XkbLayout</code> e <code>XkbVariant</code> em um <code>InputClass</code>. Isso será aplicado a todos os dispositivos de entrada que correspondam à classe.</p></div><div class=paragraph><p>Este exemplo seleciona um layout de teclado Francês.</p></div><div class=exampleblock><div class=title>Exemplo 21. Definindo um layout de teclado</div><div class=content><div class=paragraph><p><span class=filename>/usr/local/etc/X11/xorg.conf.d/keyboard-fr.conf</span></p></div><div class="literalblock programlisting"><div class=content><pre>Section	&#34;InputClass&#34;
	Identifier	&#34;KeyboardDefaults&#34;
	MatchIsKeyboard	&#34;on&#34;
	Option		&#34;XkbLayout&#34; &#34;fr&#34;
EndSection</pre></div></div></div></div><div class=exampleblock><div class=title>Exemplo 22. Definindo vários layouts de teclado</div><div class=content><div class=paragraph><p>Define os layouts de teclado para Estados Unidos, Espanhol e Ucraniano. Alterne entre esses layouts pressionando <span class=keyseq><kbd>Alt</kbd>+<kbd>Shift</kbd></span>. O <a class=package href=https://cgit.freebsd.org/ports/tree/x11/xxkb/>x11/xxkb</a> ou <a class=package href=https://cgit.freebsd.org/ports/tree/x11/sbxkb/>x11/sbxkb</a> pode ser usado para um melhor controle da mudança de layout e dos indicadores do layout atual.</p></div><div class=paragraph><p><span class=filename>/usr/local/etc/X11/xorg.conf.d/kbd-layout-multi.conf</span></p></div><div class="literalblock programlisting"><div class=content><pre>Section	&#34;InputClass&#34;
	Identifier	&#34;All Keyboards&#34;
	MatchIsKeyboard	&#34;yes&#34;
	Option		&#34;XkbLayout&#34; &#34;us, es, ua&#34;
EndSection</pre></div></div></div></div></dd></dl></div><div id=x-config-input-keyboard-zap class=dlist><dl><dt class=hdlist1>Fechando o Xorg pelo teclado</dt><dd><p>X pode ser fechado com uma combinação de teclas. Por padrão, essa combinação de teclas não está definida porque entra em conflito com os comandos do teclado para alguns aplicativos. Ativar essa opção requer alterações na seção <code>InputDevice</code> do teclado:</p><div class=exampleblock><div class=title>Exemplo 23. Ativando o fechamento de X pelo teclado</div><div class=content><div class=paragraph><p><span class=filename>/usr/local/etc/X11/xorg.conf.d/keyboard-zap.conf</span></p></div><div class="literalblock programlisting"><div class=content><pre>Section	&#34;InputClass&#34;
	Identifier	&#34;KeyboardDefaults&#34;
	MatchIsKeyboard	&#34;on&#34;
	Option		&#34;XkbOptions&#34; &#34;terminate:ctrl_alt_bksp&#34;
EndSection</pre></div></div></div></div></dd></dl></div></div><div class=sect4><h5 id=x11-input-mice>5.4.7.2. Mouse e Dispositivos Similares<a class=anchor href=#x11-input-mice></a></h5><div class="admonitionblock important"><table><tbody><tr><td class=icon><i class="fa icon-important" title=Important></i></td><td class=content><div class=paragraph><p>Se ao usar <a class=package href=https://cgit.freebsd.org/ports/tree/xorg-server/>xorg-server</a> 1.20.8 ou maior no FreeBSD 12.1 e não usar <a href="https://man.freebsd.org/cgi/man.cgi?query=moused&amp;sektion=8&amp;format=html">moused(8)</a>, adicione <code>kern.evdev.rcpt_mask=12</code> ao arquivo <span class=filename>/etc/sysctl.conf</span>:</p></div></td></tr></tbody></table></div><div class=paragraph><p>Muitos parâmetros do mouse podem ser ajustados com opções de configuração. Veja <a href="https://man.freebsd.org/cgi/man.cgi?query=mousedrv&amp;sektion=4&amp;format=html">mousedrv(4)</a> para obter uma lista completa.</p></div><div id=x11-input-mice-buttons class=dlist><dl><dt class=hdlist1>Botões do Mouse</dt><dd><p>O número de botões em um mouse pode ser definido na seção <code>InputDevice</code> do <span class=filename>xorg.conf</span>. Para definir o número de botões para 7:</p><div class=exampleblock><div class=title>Exemplo 24. Definindo o número de botões do mouse</div><div class=content><div class=paragraph><p><span class=filename>/usr/local/etc/X11/xorg.conf.d/mouse0-buttons.conf</span></p></div><div class="literalblock programlisting"><div class=content><pre>Section &#34;InputDevice&#34;
	Identifier  &#34;Mouse0&#34;
	Option      &#34;Buttons&#34; &#34;7&#34;
EndSection</pre></div></div></div></div></dd></dl></div></div></div><div class=sect3><h4 id=x-config-manual-configuration>5.4.8. Configuração manual<a class=anchor href=#x-config-manual-configuration></a></h4><div class=paragraph><p>Em alguns casos, a autoconfiguração do Xorg não funciona com alguns hardwares específicos, ou uma configuração diferente é desejada. Para esses casos, um arquivo de configuração personalizado pode ser criado.</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Não crie arquivos de configuração manualmente, a menos que seja necessário. A configuração manual desnecessária pode impedir o funcionamento adequado.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Um arquivo de configuração pode ser gerado pelo Xorg baseado no hardware detectado. Esse arquivo geralmente é um ponto de partida útil para configurações personalizadas.</p></div><div class=paragraph><p>Gerando um arquivo <span class=filename>xorg.conf</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># Xorg -configure</span></code></pre></div></div><div class=paragraph><p>O arquivo de configuração é salvo em <span class=filename>/root/xorg.conf.new</span>. Faça as alterações desejadas e teste esse arquivo(usando <code>-retro</code> assim será exibido um fundo visível) com:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># Xorg -retro -config /root/xorg.conf.new</span></code></pre></div></div><div class=paragraph><p>Após a nova configuração ter sido ajustada e testada, ela pode ser dividida em arquivos menores no diretorio, <span class=filename>/usr/local/etc/X11/xorg.conf.d/</span>.</p></div></div></div><div class=sect2><h3 id=x-fonts>5.5. Usando fontes no Xorg<a class=anchor href=#x-fonts></a></h3><div class=sect3><h4 id=type1>5.5.1. Fontes Type1<a class=anchor href=#type1></a></h4><div class=paragraph><p>As fontes padrões que vem com o Xorg não são adequadas para muitas aplicações desktop. As fontes grandes aparecem irregulares e com aparência não profissional, e as fontes pequenas são quase ilegíveis. Contudo existem muitas fontes Type1 (PostScript™) gratuitas de alta qualidade prontas para uso no Xorg. Por exemplo, a coleção de fontes URW (<a class=package href=https://cgit.freebsd.org/ports/tree/x11-fonts/urwfonts/>x11-fonts/urwfonts</a>) inclui versões de alta qualidade de fontes type1 padrão (Times Roman™, Helvetica™, Palatino™ e outras). A coleção Freefonts (<a class=package href=https://cgit.freebsd.org/ports/tree/x11-fonts/freefonts/>x11-fonts/freefonts</a>) inclui muito mais fontes, mas a maioria delas direcionadas para uso em softwares gráficos como o Gimp, e não são tão completas para servir como fontes de tela. Além disso, o Xorg pode ser configurado para usar fontes TrueType™ com um minimo esforço. Para maiores detalhes sobre isso veja a página de manual do <a href="https://man.freebsd.org/cgi/man.cgi?query=X&amp;sektion=7&amp;format=html">X(7)</a> ou <a href=#truetype>Fontes TrueType™</a>.</p></div><div class=paragraph><p>Para instalar as coleções de fontes Type1 usando pacotes binários, execute os seguintes comandos:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install urwfonts</span></code></pre></div></div><div class=paragraph><p>Como alternativa, para compilar a partir da coleção de Ports, execute os seguintes comandos:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/x11-fonts/urwfonts</span>
<span class=c># make install clean</span></code></pre></div></div><div class=paragraph><p>Proceda da mesma forma com a freefont ou outras coleções. Para que o servidor X detecte essas fontes, adicione uma linha apropriada ao arquivo de configuração do servidor X (<span class=filename>/etc/X11/xorg.conf</span>):</p></div><div class="literalblock programlisting"><div class=content><pre>FontPath &#34;/usr/local/shared/fonts/urwfonts/&#34;</pre></div></div><div class=paragraph><p>Alternativamente, na linha de comando de execução da sessão X:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% xset fp+ /usr/local/shared/fonts/urwfonts
% xset fp rehash</code></pre></div></div><div class=paragraph><p>Isso funcionará, mas será perdido quando a sessão X for fechada, a menos que seja adicionada ao arquivo de inicialização (<span class=filename>~/.xinitrc</span> para uma sessão <code>startx</code> normal ou <span class=filename>~/.xsession</span> ao efetuar login através de um gerenciador de login gráfico como o XDM). Uma terceira forma é usar o novo <span class=filename>/usr/local/etc/fonts/local.conf</span>, como demonstrado em <a href=#antialias>Fontes com Anti-Alias</a>.</p></div></div><div class=sect3><h4 id=truetype>5.5.2. Fontes TrueType™<a class=anchor href=#truetype></a></h4><div class=paragraph><p>O Xorg tem suporte nativo para renderizar fontes TrueType™. Existem dois módulos diferentes que podem ativar essa funcionalidade. O módulo freetype é usado neste exemplo porque é mais consistente com os outros backends de renderização de fonte. Para habilitar o módulo freetype, basta adicionar a seguinte linha à seção <code>"Module"</code> do <span class=filename>/etc/X11/xorg.conf</span>.</p></div><div class="literalblock programlisting"><div class=content><pre>Load  &#34;freetype&#34;</pre></div></div><div class=paragraph><p>Agora crie um diretório para as fontes TrueType™ (por exemplo, <span class=filename>/usr/local/shared/fonts/TrueType</span>) e copie todas as fontes TrueType™ para este diretório. Tenha em mente que as fontes TrueType™ não podem ser obtidas diretamente de um Apple™Mac™; elas devem estar no formato UNIX™/MS-DOS™/Windows™ para uso pelo Xorg. Uma vez que os arquivos foram copiados para este diretório, use mkfontdir para criar um <span class=filename>fonts.dir</span>, para que o renderizador de fontes do X saiba que esses novos arquivos foram instalados. O <code>mkfontdir</code> pode ser instalado como um pacote binário com o comando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install mkfontdir</span></code></pre></div></div><div class=paragraph><p>Em seguida, crie um índice de arquivos de fontes X em um diretório:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/local/shared/fonts/TrueType</span>
<span class=c># mkfontdir</span></code></pre></div></div><div class=paragraph><p>Agora adicione o diretório TrueType™ ao caminho da fonte. Isso é exatamente o mesmo descrito em <a href=#type1>Fontes Type1</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% xset fp+ /usr/local/shared/fonts/TrueType
% xset fp rehash</code></pre></div></div><div class=paragraph><p>ou adicione uma linha de <code>FontPath</code> ao <span class=filename>xorg.conf</span>.</p></div><div class=paragraph><p>Agora, o Gimp, o Apache OpenOffice e todos os outros aplicativos X devem reconhecer as fontes TrueType™ instaladas. Fontes extremamente pequenas (como o texto em uma tela de alta resolução em uma página da Web) e fontes extremamente grandes (dentro do StarOffice™) ficarão muito melhores agora.</p></div></div><div class=sect3><h4 id=antialias>5.5.3. Fontes com Anti-Alias<a class=anchor href=#antialias></a></h4><div class=paragraph><p>Todas as fontes do Xorg que são encontradas em <span class=filename>/usr/local/shared/fonts/</span> e <span class=filename>~/.fonts/</span> são automaticamente disponibilizadas para anti-aliasing para aplicativos compatíveis com Xft-aware. Os aplicativos mais recentes são compatíveis com o Xft-aware, incluindo o KDE, o GNOME e o Firefox.</p></div><div class=paragraph><p>Para controlar quais fontes são anti-aliased, ou para configurar as propriedades do anti-alias, crie (ou edite, se já existir) o arquivo <span class=filename>/usr/local/etc/fonts/local.conf</span>. Vários recursos avançados do sistema de fontes Xft podem ser ajustados usando este arquivo; Esta seção descreve apenas algumas possibilidades simples. Para maiores detalhes, por favor veja <a href="https://man.freebsd.org/cgi/man.cgi?query=fonts-conf&amp;sektion=5&amp;format=html">fonts-conf(5)</a>.</p></div><div class=paragraph><p>Este arquivo deve estar no formato XML. Preste muita atenção ao uso de letras maiusculas e minusculas e certifique-se de que todas as tags estejam corretamente fechadas. O arquivo começa com o cabeçalho XML usual seguido por uma definição DOCTYPE e, em seguida, a tag <code>&lt;fontconfig></code>:</p></div><div class="literalblock programlisting"><div class=content><pre>&lt;?xml version=&#34;1.0&#34;?&gt;
      &lt;!DOCTYPE fontconfig SYSTEM &#34;fonts.dtd&#34;&gt;
      &lt;fontconfig&gt;</pre></div></div><div class=paragraph><p>Como dito anteriormente, todas as fontes em <span class=filename>/usr/local/shared/fonts/</span> e <span class=filename>~/.fonts/</span> já estão disponíveis para aplicativos Xft-aware. Para adicionar outro diretório fora dessas duas árvores de diretórios, adicione uma linha como essa a <span class=filename>/usr/local/etc/fonts/local.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>&lt;dir&gt;/path/to/my/fonts&lt;/dir&gt;</pre></div></div><div class=paragraph><p>Depois de adicionar novas fontes e especialmente novos diretórios de fontes, reconstrua os caches de fontes:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># fc-cache -f</span></code></pre></div></div><div class=paragraph><p>O anti-aliasing torna as bordas um pouco confusas, o que torna o texto muito pequeno mais legível e remove os "serrilhados" do texto grande, mas pode causar fadiga ocular se aplicado ao texto normal. Para excluir tamanhos de fonte menores que 14 pontos do anti-aliasing, inclua estas linhas:</p></div><div class="literalblock programlisting"><div class=content><pre>        &lt;match target=&#34;font&#34;&gt;
	    &lt;test name=&#34;size&#34; compare=&#34;less&#34;&gt;
		&lt;double&gt;14&lt;/double&gt;
	    &lt;/test&gt;
	    &lt;edit name=&#34;antialias&#34; mode=&#34;assign&#34;&gt;
		&lt;bool&gt;false&lt;/bool&gt;
	    &lt;/edit&gt;
	&lt;/match&gt;
	&lt;match target=&#34;font&#34;&gt;
	    &lt;test name=&#34;pixelsize&#34; compare=&#34;less&#34; qual=&#34;any&#34;&gt;
		&lt;double&gt;14&lt;/double&gt;
	    &lt;/test&gt;
	    &lt;edit mode=&#34;assign&#34; name=&#34;antialias&#34;&gt;
		&lt;bool&gt;false&lt;/bool&gt;
	    &lt;/edit&gt;
	&lt;/match&gt;</pre></div></div><div class=paragraph><p>O espaçamento para algumas fontes monoespaçadas também pode ser inadequado com o anti-aliasing. Este parece ser um problema com o KDE, em particular. Uma possível correção é forçar o espaçamento dessas fontes para que seja 100. Adicione essas linhas:</p></div><div class="literalblock programlisting"><div class=content><pre>	&lt;match target=&#34;pattern&#34; name=&#34;family&#34;&gt;
	   &lt;test qual=&#34;any&#34; name=&#34;family&#34;&gt;
	       &lt;string&gt;fixed&lt;/string&gt;
	   &lt;/test&gt;
	   &lt;edit name=&#34;family&#34; mode=&#34;assign&#34;&gt;
	       &lt;string&gt;mono&lt;/string&gt;
	   &lt;/edit&gt;
	&lt;/match&gt;
	&lt;match target=&#34;pattern&#34; name=&#34;family&#34;&gt;
	    &lt;test qual=&#34;any&#34; name=&#34;family&#34;&gt;
		&lt;string&gt;console&lt;/string&gt;
	    &lt;/test&gt;
	    &lt;edit name=&#34;family&#34; mode=&#34;assign&#34;&gt;
		&lt;string&gt;mono&lt;/string&gt;
	    &lt;/edit&gt;
	&lt;/match&gt;</pre></div></div><div class=paragraph><p>(isto cria um apelido para outros nomes comuns para fontes fixas como <code>"mono"</code>), e então adicione:</p></div><div class="literalblock programlisting"><div class=content><pre>         &lt;match target=&#34;pattern&#34; name=&#34;family&#34;&gt;
	     &lt;test qual=&#34;any&#34; name=&#34;family&#34;&gt;
		 &lt;string&gt;mono&lt;/string&gt;
	     &lt;/test&gt;
	     &lt;edit name=&#34;spacing&#34; mode=&#34;assign&#34;&gt;
		 &lt;int&gt;100&lt;/int&gt;
	     &lt;/edit&gt;
	 &lt;/match&gt;</pre></div></div><div class=paragraph><p>Determinadas fontes, como Helvetica, podem ter um problema com o anti-alias. Geralmente isso se manifesta como uma fonte que parece cortada ao meio na vertical. Na pior das hipóteses, pode causar falhas nos aplicativos. Para evitar isso, considere adicionar o seguinte ao <span class=filename>local.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>         &lt;match target=&#34;pattern&#34; name=&#34;family&#34;&gt;
	     &lt;test qual=&#34;any&#34; name=&#34;family&#34;&gt;
		 &lt;string&gt;Helvetica&lt;/string&gt;
	     &lt;/test&gt;
	     &lt;edit name=&#34;family&#34; mode=&#34;assign&#34;&gt;
		 &lt;string&gt;sans-serif&lt;/string&gt;
	     &lt;/edit&gt;
	 &lt;/match&gt;</pre></div></div><div class=paragraph><p>Depois de editar o <span class=filename>local.conf</span>, certifique-se de finalizar o arquivo com a tag <code>&lt;/fontconfig></code>. Não fazer isso fará com que as alterações sejam ignoradas.</p></div><div class=paragraph><p>Os usuários podem adicionar configurações personalizadas criando seus próprios arquivos <span class=filename>~/.config/fontconfig/fonts.conf</span>. Este arquivo usa o mesmo formato XML descrito acima.</p></div><div class=paragraph><p>Um último ponto: com uma tela de LCD, a amostragem de sub-pixels pode ser desejada. Isso basicamente trata os componentes vermelho, verde e azul (separados horizontalmente) separadamente para melhorar a resolução horizontal; os resultados podem ser dramáticos. Para habilitar isso, adicione a linha em algum lugar do <span class=filename>local.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>	 &lt;match target=&#34;font&#34;&gt;
	     &lt;test qual=&#34;all&#34; name=&#34;rgba&#34;&gt;
		 &lt;const&gt;unknown&lt;/const&gt;
	     &lt;/test&gt;
	     &lt;edit name=&#34;rgba&#34; mode=&#34;assign&#34;&gt;
		 &lt;const&gt;rgb&lt;/const&gt;
	     &lt;/edit&gt;
	 &lt;/match&gt;</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Dependendo do tipo de display, o <code>rgb</code> pode precisar ser alterado para <code>bgr</code>, <code>vrgb</code> ou <code>vbgr</code>: experimente e veja qual funciona melhor.</p></div></td></tr></tbody></table></div></div></div><div class=sect2><h3 id=x-xdm>5.6. O Gerenciador de Display X<a class=anchor href=#x-xdm></a></h3><div class=paragraph><p>O Xorg fornece um Gerenciador de Display X, o XDM, que pode ser usado para o gerenciamento de sessões de login. O XDM fornece uma interface gráfica para escolher em qual servidor de display se conectar para inserir informações de autorização, tal como uma combinação de login e senha.</p></div><div class=paragraph><p>Esta seção demonstra como configurar o X Display Manager no FreeBSD. Alguns ambientes de desktop fornecem seu próprio gerenciador de login gráfico. Consulte <a href=#x11-wm-gnome>GNOME</a> para instruções sobre como configurar o GNOME Display Manager e <a href=#x11-wm-kde>KDE</a> para instruções sobre como configurar o KDE Display Manager.</p></div><div class=sect3><h4 id=_configurando_o_xdm>5.6.1. Configurando o XDM<a class=anchor href=#_configurando_o_xdm></a></h4><div class=paragraph><p>Para instalar o XDM, use o pacote ou ports <a class=package href=https://cgit.freebsd.org/ports/tree/x11/xdm/>x11/xdm</a>. Uma vez instalado, o XDM pode ser configurado para ser executado quando a máquina for inicializada editando esta entrada em <span class=filename>/etc/ttys</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>ttyv8   <span class=s2>&#34;/usr/local/bin/xdm -nodaemon&#34;</span>  xterm   off secure</code></pre></div></div><div class=paragraph><p>Altere o <code>off</code> para <code>on</code> e salve a edição. O <code>ttyv8</code> nesta entrada indica que o XDM será executado no nono terminal virtual.</p></div><div class=paragraph><p>O diretório de configuração do XDM está localizado em <span class=filename>/usr/local/lib/X11/xdm</span>. Esse diretório contém diversos arquivos usados para alterar o comportamento e a aparência do XDM, bem como alguns scripts e programas usados para configurar a área de trabalho quando o XDM está em execução. <a href=#xdm-config-files>Arquivos de Configuração do XDM</a> resume a função de cada um desses arquivos. A sintaxe exata e o uso desses arquivos são descritos em <a href="https://man.freebsd.org/cgi/man.cgi?query=xdm&amp;sektion=1&amp;format=html">xdm(1)</a>.</p></div><table id=xdm-config-files class="tableblock frame-none grid-all stretch"><caption class=title>Tabela 6. Arquivos de Configuração do XDM</caption><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Arquivo</th><th class="tableblock halign-left valign-top">Descrição</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>Xaccess</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>O protocolo para conectar ao XDM é chamado de X Display Manager Connection Protocol (XDMCP). Este arquivo é um conjunto de regras de autorização do cliente para controlar conexões de XDMCP de máquinas remotas. Por padrão, esse arquivo não permite a conexão de nenhum cliente remoto.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>Xresources</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Este arquivo controla a aparência do seletor de display XDM e das telas de login. A configuração padrão é uma janela de login retangular simples com o nome do host da máquina exibido na parte superior em uma fonte grande e "Login:" e "Senha:" solicitado abaixo. O formato deste arquivo é idêntico ao arquivo app-defaults descrito na documentação do Xorg.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>Xservers</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>A lista de exibições locais e remotas que o seletor deve fornecer como opções de login.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>Xsession</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Script de sessão padrão para logins que é executado pelo XDM após um usuário realizar o login. Isso aponta para um script de sessão personalizado em <span class=filename>~/.xsession</span>.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>Xsetup_</span>*</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Script para iniciar automaticamente os aplicativos antes de exibir as interfaces de seleção ou de login. Há um script para cada exibição sendo usada, denominada <span class=filename>Xsetup_*</span>, em que <code>*</code> é o número de exibição local. Geralmente, esses scripts executam um ou dois programas em segundo plano, como <code>xconsole</code>.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>xdm-config</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Configuração global para todos os monitores executados nesta máquina.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>xdm-errors</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Contém os erros gerados pelo programa do servidor. Se um display que o XDM está tentando iniciar travar, procure neste arquivo por mensagens de erro. Essas mensagens também são gravadas no <span class=filename>~/.xsession-errors</span> do usuário.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>xdm-pid</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>O ID do processo XDM em execução.</p></td></tr></tbody></table></div><div class=sect3><h4 id=_configurando_o_acesso_remoto>5.6.2. Configurando o acesso remoto<a class=anchor href=#_configurando_o_acesso_remoto></a></h4><div class=paragraph><p>Por padrão, somente usuários no mesmo sistema podem efetuar login usando o XDM. Para permitir que os usuários em outros sistemas se conectem ao servidor de Display, edite as regras de controle de acesso e ative o listener de conexão.</p></div><div class=paragraph><p>Para configurar o XDM para escutar qualquer conexão remota, comente a linha <code>DisplayManager.requestPort</code> em <span class=filename>/usr/local/etc/X11/xdm/xdm-config</span> colocando um <code>!</code> na frente dele:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=o>!</span> SECURITY: <span class=k>do </span>not listen <span class=k>for </span>XDMCP or Chooser requests
<span class=o>!</span> Comment out this line <span class=k>if </span>you want to manage X terminals with xdm
DisplayManager.requestPort:     0</code></pre></div></div><div class=paragraph><p>Salve as edições e reinicie o XDM. Para restringir o acesso remoto, veja as entradas de exemplo em <span class=filename>/usr/local/lib/X11/xdm/Xaccess</span> e consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=xdm&amp;sektion=1&amp;format=html">xdm(1)</a> para mais informações.</p></div></div></div><div class=sect2><h3 id=x11-wm>5.7. Ambientes de desktop<a class=anchor href=#x11-wm></a></h3><div class=paragraph><p>Esta seção descreve como instalar três ambientes de desktop populares em um sistema FreeBSD. Um ambiente de desktop pode variar de um gerenciador de janelas simples a um conjunto completo de aplicativos de desktop. Mais de cem ambientes de área de trabalho estão disponíveis na categoria <span class=filename>x11-wm</span> da Coleção de Ports.</p></div><div class=sect3><h4 id=x11-wm-gnome>5.7.1. GNOME<a class=anchor href=#x11-wm-gnome></a></h4><div class=paragraph><p>O GNOME é um ambiente de área de trabalho amigável. Ele inclui um painel para iniciar aplicativos e exibir status, uma área de trabalho, um conjunto de ferramentas e aplicativos e um conjunto de convenções que facilitam a cooperação entre os aplicativos e a compatibilidade entre eles. Mais informações sobre o GNOME no FreeBSD podem ser encontradas em <a href=https://www.FreeBSD.org/gnome>https://www.FreeBSD.org/gnome</a>. Esse site contém documentação adicional sobre instalação, configuração e gerenciamento do GNOME no FreeBSD.</p></div><div class=paragraph><p>Este ambiente de desktop pode ser instalado a partir de um pacote binario:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install gnome3</span></code></pre></div></div><div class=paragraph><p>Para instalar o GNOME a partir do ports, use o seguinte comando. O GNOME é um aplicativo grande e levará algum tempo para compilar, mesmo em um computador rápido.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/x11/gnome3</span>
<span class=c># make install clean</span></code></pre></div></div><div class=paragraph><p>O GNOME requer que o <span class=filename>/proc</span> seja montado. Adicione esta linha ao <span class=filename>/etc/fstab</span> para montar este sistema de arquivos automaticamente durante a inicialização do sistema:</p></div><div class="literalblock programlisting"><div class=content><pre>proc           /proc       procfs  rw  0   0</pre></div></div><div class=paragraph><p>O GNOME usa o D-Bus e o HAL para barramento de mensagens e abstração de hardware. Esses aplicativos são instalados automaticamente como dependências do GNOME. Habilite-os em <span class=filename>/etc/rc.conf</span> para que eles sejam iniciados quando o sistema inicializar:</p></div><div class="literalblock programlisting"><div class=content><pre>dbus_enable=&#34;YES&#34;
hald_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Após a instalação, configure o Xorg para iniciar o GNOME. A maneira mais fácil de fazer isso é habilitar o Gerenciador de Display do GNOME, o GDM, que é instalado como parte do pacote ou ports do GNOME. Pode ser ativado adicionando esta linha ao <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>gdm_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Geralmente é desejável também iniciar todos os serviços do GNOME. Para conseguir isso, adicione uma segunda linha ao <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>gnome_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>O GDM será iniciado automaticamente quando o sistema for inicializado.</p></div><div class=paragraph><p>Um segundo método para iniciar o GNOME é digitar <code>startx</code> na linha de comando depois de configurar o <span class=filename>~/.xinitrc</span>. Se este arquivo já existir, substitua a linha que inicia o gerenciador de janelas atual por uma que inicie o <span class=filename>/usr/local/bin/gnome-session</span>. Se este arquivo não existir, crie-o com este comando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>echo</span> <span class=s2>&#34;exec /usr/local/bin/gnome-session&#34;</span> <span class=o>&gt;</span> ~/.xinitrc</code></pre></div></div><div class=paragraph><p>Um terceiro método é usar o XDM como o gerenciador de Display. Neste caso, crie um executável <span class=filename>~/.xsession</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>echo</span> <span class=s2>&#34;exec /usr/local/bin/gnome-session&#34;</span> <span class=o>&gt;</span> ~/.xsession</code></pre></div></div></div><div class=sect3><h4 id=x11-wm-kde>5.7.2. KDE<a class=anchor href=#x11-wm-kde></a></h4><div class=paragraph><p>O KDE é outro ambiente de trabalho fácil de usar. Essa área de trabalho fornece um conjunto de aplicativos com aparência e comportamento consistentes, um menu e barras de ferramentas padronizadas, atalhos de teclado, esquemas de cores, internacionalização e uma configuração de área de trabalho centralizada e orientada a diálogos. Mais informações sobre o KDE podem ser encontradas em <a href=http://www.kde.org/>http://www.kde.org/</a>. Para informações específicas do FreeBSD, consulte <a href=http://freebsd.kde.org/>http://freebsd.kde.org</a>.</p></div><div class=paragraph><p>Para instalar o pacote KDE, digite:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install x11/kde5</span></code></pre></div></div><div class=paragraph><p>Para instalar o KDE via ports, use o seguinte comando. A instalação do ports fornecerá um menu para selecionar quais componentes instalar. O KDE é um aplicativo grande e levará algum tempo para compilar, mesmo em um computador rápido.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/x11/kde5</span>
<span class=c># make install clean</span></code></pre></div></div><div class=paragraph><p>O KDE requer que o <span class=filename>/proc</span> esteja montado. Adicione esta linha ao <span class=filename>/etc/fstab</span> para montar este sistema de arquivos automaticamente durante a inicialização do sistema:</p></div><div class="literalblock programlisting"><div class=content><pre>proc           /proc       procfs  rw  0   0</pre></div></div><div class=paragraph><p>O KDE usa o D-Bus e o HAL para barramento de mensagens e abstração de hardware. Estas aplicações são automaticamente instaladas como dependências do KDE. Habilite-os em <span class=filename>/etc/rc.conf</span> para que eles sejam iniciados quando o sistema inicializar:</p></div><div class="literalblock programlisting"><div class=content><pre>dbus_enable=&#34;YES&#34;
hald_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Desde o KDE Plasma 5, o Gerenciador de Display do KDE, KDM, não é mais desenvolvido. Uma possível substituição é o SDDM. Para instalá-lo, digite:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install x11/sddm</span></code></pre></div></div><div class=paragraph><p>Adicione esta linha em <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>sddm_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Um segundo método para iniciar o KDE Plasma é digitar <code>startx</code> na linha de comando. Para que isso funcione, a seguinte linha é necessária em <span class=filename>~/.xinitrc</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>exec ck-launch-session startplasma-x11</pre></div></div><div class=paragraph><p>Um terceiro método para iniciar o KDE Plasma é através do XDM. Para fazer isso, crie um arquivo executável <span class=filename>~/.xsession</span> da seguinte maneira:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>echo</span> <span class=s2>&#34;exec ck-launch-session startplasma-x11&#34;</span> <span class=o>&gt;</span> ~/.xsession</code></pre></div></div><div class=paragraph><p>Uma vez iniciado o KDE Plasma , consulte o sistema de ajuda integrado para obter mais informações sobre como usar seus diversos menus e aplicativos.</p></div></div><div class=sect3><h4 id=x11-wm-xfce>5.7.3. Xfce<a class=anchor href=#x11-wm-xfce></a></h4><div class=paragraph><p>O Xfce é um ambiente de desktop baseado no kit de ferramentas GTK+ usado pelo GNOME. No entanto, é mais leve e fornece um desktop simples, eficiente e fácil de usar. É totalmente configurável, possui um painel principal com menus, applets e lançadores de aplicativos, fornece um gerenciador de arquivos e um gerenciador de som e é personalizável. Como é rápido, leve e eficiente, é ideal para máquinas mais antigas ou mais lentas com limitações de memória. Mais informações sobre o Xfce podem ser encontradas em <a href=http://www.xfce.org/>http://www.xfce.org</a>.</p></div><div class=paragraph><p>Para instalar o pacote Xfce:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install xfce</span></code></pre></div></div><div class=paragraph><p>Alternativamente , para compilar o port:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/x11-wm/xfce4</span>
<span class=c># make install clean</span></code></pre></div></div><div class=paragraph><p>O Xfce usa o D-Bus para barramento de mensagens. Este aplicativo é instalado automaticamente como dependência do Xfce. Habilite-o em <span class=filename>/etc/rc.conf</span> para que ele seja iniciado quando o sistema inicializar:</p></div><div class="literalblock programlisting"><div class=content><pre>dbus_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Ao contrário do GNOME ou KDE, o Xfce não disponibiliza seu próprio gerenciador de login. Para iniciar o Xfce à partir da linha de comando digitando <code>startx</code>, mas primeiro adicione sua entrada ao <span class=filename>~/.xinitrc</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>echo</span> <span class=s2>&#34;. /usr/local/etc/xdg/xfce4/xinitrc&#34;</span> <span class=o>&gt;</span> ~/.xinitrc</code></pre></div></div><div class=paragraph><p>Um método alternativo é usar o XDM. Para configurar este método, crie um executável <span class=filename>~/.xsession</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>echo</span> <span class=s2>&#34;. /usr/local/etc/xdg/xfce4/xinitrc&#34;</span> <span class=o>&gt;</span> ~/.xsession</code></pre></div></div></div></div><div class=sect2><h3 id=x-compiz-fusion>5.8. Instalando o Compiz Fusion<a class=anchor href=#x-compiz-fusion></a></h3><div class=paragraph><p>Uma maneira de tornar o uso de um computador desktop mais agradável é com bons efeitos 3D.</p></div><div class=paragraph><p>Instalar o pacote Compiz Fusion é fácil, mas a configuração requer alguns passos que não estão descritos na documentação do ports.</p></div><div class=sect3><h4 id=x-compiz-video-card>5.8.1. Configurando o Driver nVidia no FreeBSD<a class=anchor href=#x-compiz-video-card></a></h4><div class=paragraph><p>Os efeitos da área de trabalho podem causar uma carga considerável na placa gráfica. Para uma placa gráfica baseada na nVidia, o driver proprietário é necessário para um bom desempenho. Usuários de outras placas gráficas podem pular esta seção e continuar com a configuração do <span class=filename>xorg.conf</span>.</p></div><div class=paragraph><p>Para determinar qual o driver nVidia é necessário, consulte a <a href=https://docs.freebsd.org/pt-br/books/faq/#idp59950544>Perguntas frequentes sobre o assunto</a>.</p></div><div class=paragraph><p>Tendo determinado o driver correto para usar em sua placa gráfica, a instalação é tão simples quanto instalar qualquer outro pacote.</p></div><div class=paragraph><p>Por exemplo, para instalar o driver mais recente:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install x11/nvidia-driver</span></code></pre></div></div><div class=paragraph><p>O driver irá criar um módulo do kernel, que precisa ser carregado na inicialização do sistema. Adicione a seguinte linha ao <span class=filename>/boot/loader.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>nvidia_load=&#34;YES&#34;</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Para carregar imediatamente o módulo no kernel em execução, você pode executar o comando <code>kldload nvidia</code>. No entanto, foi observado que algumas versões do Xorg não funcionarão corretamente se o driver não for carregado no momento da inicialização. Desta forma, depois de editar o <span class=filename>/boot/loader.conf</span>, é recomendado reiniciar o sistema.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Com o módulo do kernel carregado, você normalmente só precisa alterar uma única linha no <span class=filename>xorg.conf</span> para habilitar o driver proprietário:</p></div><div class=paragraph><p>Encontre a seguinte linha no <span class=filename>/etc/X11/xorg.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>Driver      &#34;nv&#34;</pre></div></div><div class=paragraph><p>e mude para:</p></div><div class="literalblock programlisting"><div class=content><pre>Driver      &#34;nvidia&#34;</pre></div></div><div class=paragraph><p>Inicie a GUI como de costume, e você será saudado pelo splash da nVidia. Tudo deve funcionar como de costume.</p></div></div><div class=sect3><h4 id=xorg-configuration>5.8.2. Configurando o xorg.conf para Efeitos de Desktop<a class=anchor href=#xorg-configuration></a></h4><div class=paragraph><p>Para ativar o Compiz Fusion, o <span class=filename>/etc/X11/xorg.conf</span> precisa ser modificado:</p></div><div class=paragraph><p>Adicione a seguinte seção para habilitar os efeitos compostos:</p></div><div class="literalblock programlisting"><div class=content><pre>Section &#34;Extensions&#34;
    Option         &#34;Composite&#34; &#34;Enable&#34;
EndSection</pre></div></div><div class=paragraph><p>Localize a seção "Screen", que deve ser semelhante à abaixo:</p></div><div class="literalblock programlisting"><div class=content><pre>Section &#34;Screen&#34;
    Identifier     &#34;Screen0&#34;
    Device         &#34;Card0&#34;
    Monitor        &#34;Monitor0&#34;
    ...</pre></div></div><div class=paragraph><p>e adicione as duas linhas seguintes (após "Monitor"):</p></div><div class="literalblock programlisting"><div class=content><pre>DefaultDepth    24
Option         &#34;AddARGBGLXVisuals&#34; &#34;True&#34;</pre></div></div><div class=paragraph><p>Localize a "Subsection" que se refere à resolução da tela que você deseja usar. Por exemplo, se você deseja usar 1280x1024, localize a seção a seguir. Se a resolução desejada não aparecer em nenhuma subseção, você pode adicionar a entrada relevante à mão:</p></div><div class="literalblock programlisting"><div class=content><pre>SubSection     &#34;Display&#34;
    Viewport    0 0
    Modes      &#34;1280x1024&#34;
EndSubSection</pre></div></div><div class=paragraph><p>Uma profundidade de cor de 24 bits é necessária para a composição do desktop, altere a subseção acima para:</p></div><div class="literalblock programlisting"><div class=content><pre>SubSection     &#34;Display&#34;
    Viewport    0 0
    Depth       24
    Modes      &#34;1280x1024&#34;
EndSubSection</pre></div></div><div class=paragraph><p>Finalmente, confirme que os módulos "glx" e "extmod" estão carregados na seção "Module":</p></div><div class="literalblock programlisting"><div class=content><pre>Section &#34;Module&#34;
    Load           &#34;extmod&#34;
    Load           &#34;glx&#34;
    ...</pre></div></div><div class=paragraph><p>A configuração acima pode ser feita automaticamente com o <a class=package href=https://cgit.freebsd.org/ports/tree/x11/nvidia-xconfig/>x11/nvidia-xconfig</a> (executando como <code>root</code>):</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># nvidia-xconfig --add-argb-glx-visuals</span>
<span class=c># nvidia-xconfig --composite</span>
<span class=c># nvidia-xconfig --depth=24</span></code></pre></div></div></div><div class=sect3><h4 id=compiz-fusion>5.8.3. Instalando e Configurando o Compiz Fusion<a class=anchor href=#compiz-fusion></a></h4><div class=paragraph><p>Instalar o Compiz Fusion é tão simples quanto qualquer outro pacote:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install x11-wm/compiz-fusion</span></code></pre></div></div><div class=paragraph><p>Quando a instalação estiver concluída, inicie o Desktop Gráfico e, em um terminal, digite os seguintes comandos (como usuário normal):</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% compiz <span class=nt>--replace</span> <span class=nt>--sm-disable</span> <span class=nt>--ignore-desktop-hints</span> ccp &amp;
% emerald <span class=nt>--replace</span> &amp;</code></pre></div></div><div class=paragraph><p>Sua tela piscará por alguns segundos, pois o gerenciador de janelas (por exemplo, Metacity se você estiver usando o GNOME) será substituído pelo Compiz Fusion. O Emerald cuida das decorações da janela (isto é, botões de fechar, minimizar, maximizar, barras de título e assim por diante).</p></div><div class=paragraph><p>Você pode converter isso em um script trivial e executá-lo na inicialização automaticamente (por exemplo, adicionando a "Sessions" em um Desktop do GNOME):</p></div><div class="literalblock programlisting"><div class=content><pre>#! /bin/sh
compiz --replace --sm-disable --ignore-desktop-hints ccp &amp;
emerald --replace &amp;</pre></div></div><div class=paragraph><p>Salve isso no seu diretório home como, por exemplo, <span class=filename>start-compiz</span> e torne-o executável:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>chmod</span> +x ~/start-compiz</code></pre></div></div><div class=paragraph><p>Em seguida, utilize a GUI para adicioná-lo a <span class=guimenuitem>Startup Programs</span> (localizado em <span class=guimenuitem>System</span>, <span class=guimenuitem>Preferences</span>, <span class=guimenuitem>Sessions</span> em um desktop GNOME).</p></div><div class=paragraph><p>Para selecionar realmente todos os efeitos desejados e suas configurações, execute (novamente como um usuário normal) o Compiz Config Settings Manager:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ccsm</code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>No GNOME, isso também pode ser encontrado no menu <span class=guimenuitem>System</span>, <span class=guimenuitem>Preferences</span>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Se você selecionou "gconf support" durante a compilação, você também será capaz de ver estas configurações usando o <code>gconf-editor</code> sob <code>apps/compiz</code>.</p></div></div></div><div class=sect2><h3 id=x11-troubleshooting>5.9. Solução de problemas<a class=anchor href=#x11-troubleshooting></a></h3><div class=paragraph><p>Se o mouse não funcionar, você precisará primeiro configurá-lo antes de prosseguir. Em versões recentes do Xorg, as seções <code>InputDevice</code> em <span class=filename>xorg.conf</span> são ignoradas em favor dos dispositivos autodetectados. Para restaurar o comportamento antigo, adicione a seguinte linha à seção <code>ServerLayout</code> ou <code>ServerFlags</code> deste arquivo:</p></div><div class="literalblock programlisting"><div class=content><pre>Option &#34;AutoAddDevices&#34; &#34;false&#34;</pre></div></div><div class=paragraph><p>Os dispositivos de entrada podem então ser configurados como nas versões anteriores, juntamente com quaisquer outras opções necessárias (por exemplo, troca do layout de teclado).</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Como explicado anteriormente, o daemon hald irá, por padrão, detectar automaticamente o seu teclado. Há chances de que o layout ou modelo do teclado não esteja correto, ambientes de Desktop como o GNOME, KDE ou Xfce fornecem ferramentas para configurar o teclado. No entanto, é possível definir as propriedades do teclado diretamente com a ajuda do utilitário <a href="https://man.freebsd.org/cgi/man.cgi?query=setxkbmap&amp;sektion=1&amp;format=html">setxkbmap(1)</a> ou com uma regra de configuração do aplicativohald.</p></div><div class=paragraph><p>Por exemplo, se alguém quiser usar um teclado de teclas PC 102 vindo com um layout francês, temos que criar um arquivo de configuração de teclado para o hald chamado <span class=filename>x11-input.fdi</span> e salva-lo no diretório <span class=filename>/usr/local/etc/hal/fdi/policy</span>. Este arquivo deve conter as seguintes linhas:</p></div><div class="literalblock programlisting"><div class=content><pre>&lt;?xml version=&#34;1.0&#34; encoding=&#34;utf-8&#34;?&gt;
&lt;deviceinfo version=&#34;0.2&#34;&gt;
  &lt;device&gt;
    &lt;match key=&#34;info.capabilities&#34; contains=&#34;input.keyboard&#34;&gt;
	  &lt;merge key=&#34;input.x11_options.XkbModel&#34; type=&#34;string&#34;&gt;pc102&lt;/merge&gt;
	  &lt;merge key=&#34;input.x11_options.XkbLayout&#34; type=&#34;string&#34;&gt;fr&lt;/merge&gt;
    &lt;/match&gt;
  &lt;/device&gt;
&lt;/deviceinfo&gt;</pre></div></div><div class=paragraph><p>Se este arquivo já existir, apenas copie e adicione ao seu arquivo as linhas referentes à configuração do teclado.</p></div><div class=paragraph><p>Você terá que reinicializar sua máquina para forçar o hald a ler este arquivo.</p></div><div class=paragraph><p>É possível fazer a mesma configuração a partir de um terminal X ou um script com esta linha de comando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% setxkbmap <span class=nt>-model</span> pc102 <span class=nt>-layout</span> fr</code></pre></div></div><div class=paragraph><p>O <span class=filename>/usr/local/shared/X11/xkb/rules/base.lst</span> lista os vários teclados, layouts e opções disponíveis.</p></div></td></tr></tbody></table></div><div class=paragraph><p>O arquivo de configuração <span class=filename>xorg.conf.new</span> pode agora ser ajustado para o seu gosto. Abra o arquivo em um editor de texto, como <a href="https://man.freebsd.org/cgi/man.cgi?query=emacs&amp;sektion=1&amp;format=html">emacs(1)</a> ou o <a href="https://man.freebsd.org/cgi/man.cgi?query=ee&amp;sektion=1&amp;format=html">ee(1)</a>. Se o monitor for um modelo antigo ou incomum que não suporta a detecção automática de frequências de sincronização, essas configurações podem ser adicionadas ao <span class=filename>xorg.conf.new</span> na seção <code>"Monitor"</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>Section &#34;Monitor&#34;
	Identifier   &#34;Monitor0&#34;
	VendorName   &#34;Monitor Vendor&#34;
	ModelName    &#34;Monitor Model&#34;
	HorizSync    30-107
	VertRefresh  48-120
EndSection</pre></div></div><div class=paragraph><p>A maioria dos monitores suporta autodetecção de frequência de sincronização, tornando desnecessária a entrada manual desses valores. Para os poucos monitores que não suportam a detecção automática, evite possíveis danos inserindo apenas valores fornecidos pelo fabricante.</p></div><div class=paragraph><p>O X permite que os recursos do DPMS (Energy Star) sejam usados com monitores capazes. O programa <a href="https://man.freebsd.org/cgi/man.cgi?query=xset&amp;sektion=1&amp;format=html">xset(1)</a> controla os tempos limite e pode forçar os modos de espera, suspensão ou desativação. Se você deseja habilitar recursos de DPMS para o seu monitor, você deve adicionar a seguinte linha à seção do monitor:</p></div><div class="literalblock programlisting"><div class=content><pre>Option       &#34;DPMS&#34;</pre></div></div><div class=paragraph><p>Enquanto o arquivo de configuração <span class=filename>xorg.conf.new</span> ainda estiver aberto em um editor, selecione a resolução padrão e a profundidade de cor desejada. Isso é definido na seção <code>"Screen"</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>Section &#34;Screen&#34;
	Identifier &#34;Screen0&#34;
	Device     &#34;Card0&#34;
	Monitor    &#34;Monitor0&#34;
	DefaultDepth 24
	SubSection &#34;Display&#34;
		Viewport  0 0
		Depth     24
		Modes     &#34;1024x768&#34;
	EndSubSection
EndSection</pre></div></div><div class=paragraph><p>A palavra-chave <code>DefaultDepth</code> descreve a profundidade de cor a ser executada por padrão. Isto pode ser sobrescrito com a opção de linha de comando <code>-depth</code> para <a href="https://man.freebsd.org/cgi/man.cgi?query=Xorg&amp;sektion=1&amp;format=html">Xorg(1)</a>. A palavra-chave <code>Modes</code> descreve a resolução a ser executada na profundidade de cor especificada. Observe que somente os modos padrão VESA são suportados, conforme definido pelo hardware gráfico do sistema de destino. No exemplo acima, a profundidade de cor padrão é de vinte e quatro bits por pixel. Nesta profundidade de cor, a resolução aceita é 1024 por 768 pixels.</p></div><div class=paragraph><p>Finalmente, escreva o arquivo de configuração e teste-o usando o modo de teste dado acima.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Uma das ferramentas disponíveis para ajudá-lo durante o processo de solução de problemas são os arquivos de log do Xorg, que contêm informações sobre cada dispositivo ao qual o servidor Xorg se conecta. Os nomes de arquivos de log do Xorg estão no formato <span class=filename>/var/log/Xorg.0.log</span>. O nome exato do log pode variar de <span class=filename>Xorg.0.log</span> para <span class=filename>Xorg.8.log</span> e assim por diante.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Se tudo estiver bem, o arquivo de configuração precisa ser instalado em um local comum onde o <a href="https://man.freebsd.org/cgi/man.cgi?query=Xorg&amp;sektion=1&amp;format=html">Xorg(1)</a> possa encontrá-lo. Isto é tipicamente <span class=filename>/etc/X11/xorg.conf</span> ou <span class=filename>/usr/local/etc/X11/xorg.conf</span>.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cp xorg.conf.new /etc/X11/xorg.conf</span></code></pre></div></div><div class=paragraph><p>O processo de configuração do Xorg agora está completo. O Xorg pode agora ser iniciado com o utilitário <a href="https://man.freebsd.org/cgi/man.cgi?query=startx&amp;sektion=1&amp;format=html">startx(1)</a>. O servidor Xorg também pode ser iniciado com o uso de <a href="https://man.freebsd.org/cgi/man.cgi?query=xdm&amp;sektion=1&amp;format=html">xdm(1)</a>.</p></div><div class=sect3><h4 id=_configuração_com_chipsets_gráficos_inteli810>5.9.1. Configuração com Chipsets gráficos Intel™<code>i810</code><a class=anchor href=#_configuração_com_chipsets_gráficos_inteli810></a></h4><div class=paragraph><p>A configuração com chipsets integrados i810 da Intel™ requer a interface de programação AGP <span class=filename>agpgart</span> para o Xorg para conduzir a placa. Consulte a página de manual do driver <a href="https://man.freebsd.org/cgi/man.cgi?query=agp&amp;sektion=4&amp;format=html">agp(4)</a> para obter maiores informações.</p></div><div class=paragraph><p>Isso permitirá a configuração do hardware como qualquer outra placa gráfica. Observe que nos sistemas sem o driver <a href="https://man.freebsd.org/cgi/man.cgi?query=agp&amp;sektion=4&amp;format=html">agp(4)</a> compilado no kernel, tentar carregar o módulo com <a href="https://man.freebsd.org/cgi/man.cgi?query=kldload&amp;sektion=8&amp;format=html">kldload(8)</a> não funcionará. Este driver tem que estar no kernel no momento da inicialização, através da compilação ou usando o <span class=filename>/boot/loader.conf</span>.</p></div></div><div class=sect3><h4 id=_adicionando_um_flatpanel_widescreen_ao_mix>5.9.2. Adicionando um Flatpanel Widescreen ao Mix<a class=anchor href=#_adicionando_um_flatpanel_widescreen_ao_mix></a></h4><div class=paragraph><p>Esta seção pressupõe um pouco de conhecimento avançado de configuração. Se as tentativas de usar as ferramentas de configuração padrão acima não resultaram em uma configuração funcional, há informações suficientes nos arquivos de log para serem úteis para fazer a configuração funcionar. O uso de um editor de texto será necessário.</p></div><div class=paragraph><p>Os formatos widescreen atuais (WSXGA, WSXGA+, WUXGA, WXGA, WXGA+, etc.) suportam formatos ou proporções de formato 16:10 e 10:9 que podem ser problemáticos. Exemplos de algumas resoluções de tela comuns para proporções de 16:10 são:</p></div><div class=ulist><ul><li><p>2560x1600</p></li><li><p>1920x1200</p></li><li><p>1680x1050</p></li><li><p>1440x900</p></li><li><p>1280x800</p></li></ul></div><div class=paragraph><p>Em algum momento, será tão fácil quanto adicionar uma dessas resoluções como um possível <code>Mode</code> na <code>Section "Screen"</code> como tal:</p></div><div class="literalblock programlisting"><div class=content><pre>Section &#34;Screen&#34;
Identifier &#34;Screen0&#34;
Device     &#34;Card0&#34;
Monitor    &#34;Monitor0&#34;
DefaultDepth 24
SubSection &#34;Display&#34;
	Viewport  0 0
	Depth     24
	Modes     &#34;1680x1050&#34;
EndSubSection
EndSection</pre></div></div><div class=paragraph><p>O Xorg é inteligente o suficiente para extrair as informações de resolução da tela widescreen via informações I2C/DDC, para que ele saiba o que o monitor pode suportar em termos de freqüências e resoluções.</p></div><div class=paragraph><p>Se aqueles <code>ModeLines</code> não existem nos drivers, pode ser necessário dar ao Xorg uma pequena dica. Usando o <span class=filename>/var/log/Xorg.0.log</span> pode-se extrair informações suficientes para criar manualmente um <code>ModeLine</code> que funcionará. Basta procurar informações semelhantes:</p></div><div class="literalblock programlisting"><div class=content><pre>(II) MGA(0): Supported additional Video Mode:
(II) MGA(0): clock: 146.2 MHz   Image Size:  433 x 271 mm
(II) MGA(0): h_active: 1680  h_sync: 1784  h_sync_end 1960 h_blank_end 2240 h_border: 0
(II) MGA(0): v_active: 1050  v_sync: 1053  v_sync_end 1059 v_blanking: 1089 v_border: 0
(II) MGA(0): Ranges: V min: 48  V max: 85 Hz, H min: 30  H max: 94 kHz, PixClock max 170 MHz</pre></div></div><div class=paragraph><p>Esta informação é chamada de informação EDID. Criar uma <code>ModeLine</code> a partir disso é apenas uma questão de colocar os números na ordem correta:</p></div><div class="literalblock programlisting"><div class=content><pre>ModeLine &lt;name&gt; &lt;clock&gt; &lt;4 horiz. timings&gt; &lt;4 vert. timings&gt;</pre></div></div><div class=paragraph><p>Assim, o <code>ModeLine</code> na <code>Section "Monitor"</code> para este exemplo ficaria assim:</p></div><div class="literalblock programlisting"><div class=content><pre>Section &#34;Monitor&#34;
Identifier      &#34;Monitor1&#34;
VendorName      &#34;Bigname&#34;
ModelName       &#34;BestModel&#34;
ModeLine        &#34;1680x1050&#34; 146.2 1680 1784 1960 2240 1050 1053 1059 1089
Option          &#34;DPMS&#34;
EndSection</pre></div></div><div class=paragraph><p>Agora, tendo completado estes passos simples de edição, o X deve iniciar no seu novo monitor widescreen.</p></div></div><div class=sect3><h4 id=compiz-troubleshooting>5.9.3. Solução de problemas do Compiz Fusion<a class=anchor href=#compiz-troubleshooting></a></h4><div class=sect4><h5 id=_eu_instalei_o_compiz_fusion_e_depois_de_executar_os_comandos_que_você_mencionou_minhas_janelas_ficaram_sem_barras_de_título_e_botões_o_que_está_errado>5.9.3.1. Eu instalei o Compiz Fusion, e depois de executar os comandos que você mencionou, minhas janelas ficaram sem barras de título e botões. O que está errado?<a class=anchor href=#_eu_instalei_o_compiz_fusion_e_depois_de_executar_os_comandos_que_você_mencionou_minhas_janelas_ficaram_sem_barras_de_título_e_botões_o_que_está_errado></a></h5><div class=paragraph><p>Provavelmente está faltando alguma configuração em <span class=filename>/etc/X11/xorg.conf</span>. Revise este arquivo cuidadosamente e verifique especialmente as diretivas <code>DefaultDepth</code> e <code>AddARGBGLXVisuals</code>.</p></div></div><div class=sect4><h5 id=_quando_executo_o_comando_para_iniciar_o_compiz_fusion_o_servidor_x_trava_e_eu_volto_ao_console_o_que_está_errado>5.9.3.2. Quando executo o comando para iniciar o Compiz Fusion, o servidor X trava e eu volto ao console. O que está errado?<a class=anchor href=#_quando_executo_o_comando_para_iniciar_o_compiz_fusion_o_servidor_x_trava_e_eu_volto_ao_console_o_que_está_errado></a></h5><div class=paragraph><p>Se você verificar o <span class=filename>/var/log/Xorg.0.log</span>, você provavelmente encontrará mensagens de erro durante a inicialização do X. As mais comuns seriam:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=o>(</span>EE<span class=o>)</span> NVIDIA<span class=o>(</span>0<span class=o>)</span>:     Failed to initialize the GLX module<span class=p>;</span> please check <span class=k>in </span>your X
<span class=o>(</span>EE<span class=o>)</span> NVIDIA<span class=o>(</span>0<span class=o>)</span>:     log file that the GLX module has been loaded <span class=k>in </span>your X
<span class=o>(</span>EE<span class=o>)</span> NVIDIA<span class=o>(</span>0<span class=o>)</span>:     server, and that the module is the NVIDIA GLX module.  If
<span class=o>(</span>EE<span class=o>)</span> NVIDIA<span class=o>(</span>0<span class=o>)</span>:     you <span class=k>continue </span>to encounter problems, Please try
<span class=o>(</span>EE<span class=o>)</span> NVIDIA<span class=o>(</span>0<span class=o>)</span>:     reinstalling the NVIDIA driver.</code></pre></div></div><div class=paragraph><p>Este é geralmente o caso quando você atualiza o Xorg. Você precisará reinstalar o pacote <a class=package href=https://cgit.freebsd.org/ports/tree/x11/nvidia-driver/>x11/nvidia-driver</a> para que o glx seja compilado novamente.</p></div></div></div></div></div></div><h1 id=common-tasks class=sect0>Parte II: Tarefas comuns<a class=anchor href=#common-tasks></a></h1><div class="openblock partintro"><div class=content><div class=paragraph><p>Agora que o básico foi abordado, esta parte do livro discute alguns recursos freqüentemente usados do FreeBSD. Estes capítulos:</p></div><div class=ulist><ul><li><p>Introduzem aplicativos de desktop populares e úteis: navegadores, ferramentas de produtividade, visualizadores de documentos e muito mais.</p></li><li><p>Introduzem uma série de ferramentas multimídia disponíveis para o FreeBSD.</p></li><li><p>Explicam o processo de compilação de um kernel customizado do FreeBSD para habilitar funcionalidades extras.</p></li><li><p>Descrevem o sistema de impressão em detalhes, tanto configurações de impressoras conectadas em desktops quanto impressoras conectadas à rede.</p></li><li><p>Mostram como executar aplicativos Linux no sistema FreeBSD.</p></li></ul></div><div class=paragraph><p>Alguns destes capítulos recomendam leituras prévias, e isso é destacado na sinopse no início de cada capítulo.</p></div></div></div><div class=sect1><h2 id=desktop>Capítulo 6. Aplicações de Desktop<a class=anchor href=#desktop></a></h2><div class=sectionbody><div class=sect2><h3 id=desktop-synopsis>6.1. Sinopse<a class=anchor href=#desktop-synopsis></a></h3><div class=paragraph><p>Embora o FreeBSD seja popular como um servidor por seu desempenho e estabilidade, ele também é adequado para o uso diário como desktop. Com mais de 24.000 aplicativos disponíveis como pacotes ou ports para o FreeBSD, é fácil construir um desktop personalizado que executa uma ampla variedade de aplicativos de desktop. Este capítulo demonstra como instalar vários aplicativos de desktop, incluindo navegadores da Web, software de produtividade, visualizadores de documentos e softwares financeiros.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Os usuários que preferem instalar uma versão de desktop pré-configurada do FreeBSD em vez de configurar um do zero devem consultar <a href=http://www.furybsd.org>FuryBSD.</a>, <a href=https://ghostbsd.org>GhostBSD</a> or <a href=https://www.midnightbsd.org>MidnightBSD</a>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Os leitores deste capítulo devem saber como:</p></div><div class=ulist><ul><li><p>Instalar software adicional usando pacotes ou ports, conforme descrito em <a href=./#ports>Instalando Aplicativos. Pacotes e Ports</a>.</p></li><li><p>Instalar o X e um gerenciador de janelas, conforme descrito em <a href=./#x11>O sistema X Window</a>.</p></li></ul></div><div class=paragraph><p>Para obter informações sobre como configurar um ambiente multimídia, consulte <a href=./#multimedia>Multimídia</a>.</p></div></div><div class=sect2><h3 id=desktop-browsers>6.2. Navegadores<a class=anchor href=#desktop-browsers></a></h3><div class=paragraph><p>O FreeBSD não vem com um navegador Web pré-instalado. Em vez disso, a categoria <a href=https://www.FreeBSD.org/ports/>www</a> da Coleção de Ports contém muitos navegadores que podem ser instalados como um pacote ou compilados a partir da coleção de Ports.</p></div><div class=paragraph><p>Os ambientes de área de trabalho KDE e GNOME incluem seu próprio navegador HTML. Consulte <a href=./#x11-wm>Ambientes de desktop</a> para mais informações sobre como configurar esses desktops completos.</p></div><div class=paragraph><p>Alguns navegadores leves incluem o <a class=package href=https://cgit.freebsd.org/ports/tree/www/dillo2/>www/dillo2</a>, o <a class=package href=https://cgit.freebsd.org/ports/tree/www/links/>www/links</a> e o <a class=package href=https://cgit.freebsd.org/ports/tree/www/w3m/>www/w3m</a>.</p></div><div class=paragraph><p>Esta seção demonstra como instalar os seguintes navegadores Web populares e indica se o aplicativo é pesado em recursos, se leva tempo para compilar a partir do Ports ou se possui dependências importantes.</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:25%><col style=width:25%><col style=width:25%><col style=width:25%><thead><tr><th class="tableblock halign-left valign-top">Nome da aplicação</th><th class="tableblock halign-left valign-top">Recursos necessários</th><th class="tableblock halign-left valign-top">Instalação a partir do Ports</th><th class="tableblock halign-left valign-top">Notas</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Firefox</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>médio</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>pesado</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>FreeBSD, Linux™, e versões localizadas estão disponíveis</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Konqueror</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>médio</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>pesado</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Requer bibliotecas do KDE</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Chromium</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>médio</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>pesado</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Requer Gtk+</p></td></tr></tbody></table><div class=sect3><h4 id=_firefox>6.2.1. Firefox<a class=anchor href=#_firefox></a></h4><div class=paragraph><p>O Firefox é um navegador de código-fonte aberto que apresenta um mecanismo de exibição HTML compatível com os padrões, navegação por guias, bloqueio de pop-up, extensões, segurança aprimorada e muito mais. O Firefox é baseado na base de código Mozilla.</p></div><div class=paragraph><p>Para instalar o pacote da versão mais recente do Firefox, digite:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install firefox</span></code></pre></div></div><div class=paragraph><p>Para instalar a versão ESR (Extended Support Release) do Firefox, use:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install firefox-esr</span></code></pre></div></div><div class=paragraph><p>A Coleção de Ports pode ser usada para compilar a versão desejada do Firefox a partir do código-fonte. Este exemplo compila o <a class=package href=https://cgit.freebsd.org/ports/tree/www/firefox/>www/firefox</a>, onde o <code>firefox</code> pode ser substituído pelo ESR ou pela versão localizada para instalar.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/www/firefox</span>
<span class=c># make install clean</span></code></pre></div></div></div><div class=sect3><h4 id=_konqueror>6.2.2. Konqueror<a class=anchor href=#_konqueror></a></h4><div class=paragraph><p>O Konqueror é mais do que um navegador Web, pois também é um gerenciador de arquivos e um visualizador de multimídia. Suporta WebKit assim como seu próprio KHTML. WebKit é um motor de renderização usado por diversos navegadores modernos incluiindo o Chromium.</p></div><div class=paragraph><p>O Konqueror pode ser instalado como um pacote digitando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install konqueror</span></code></pre></div></div><div class=paragraph><p>Para instalar a partir da Coleção de Ports:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/x11-fm/konqueror/</span>
<span class=c># make install clean</span></code></pre></div></div></div><div class=sect3><h4 id=_chromium>6.2.3. Chromium<a class=anchor href=#_chromium></a></h4><div class=paragraph><p>O Chromium é um projeto de navegador de código aberto que visa criar uma experiência de navegação na Web mais segura, mais rápida e mais estável. O Chromium apresenta navegação com guias, bloqueio de pop-up, extensões e muito mais. O Chromium é o projeto de código-fonte aberto no qual o navegador Web do Google Chrome é baseado.</p></div><div class=paragraph><p>O Chromium pode ser instalado como um pacote digitando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install chromium</span></code></pre></div></div><div class=paragraph><p>Alternativamente, o Chromium pode ser compilado a partir do código-fonte usando a Coleção de Ports:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/www/chromium</span>
<span class=c># make install clean</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>O executável do Chromium é <span class=filename>/usr/local/bin/chrome</span>, não <span class=filename>/usr/local/bin/chromium</span>.</p></div></td></tr></tbody></table></div></div></div><div class=sect2><h3 id=desktop-productivity>6.3. Produtividade<a class=anchor href=#desktop-productivity></a></h3><div class=paragraph><p>Quando se trata de produtividade, os usuários geralmente procuram uma suíte de escritório ou um processador de texto fácil de usar. Embora alguns <a href=./#x11-wm>ambientes de desktop</a> como o KDE forneçam uma suíte de escritório, não há um pacote de produtividade padrão. Várias suítes de escritório e processadores de texto gráficos estão disponíveis para o FreeBSD, independentemente do gerenciador de janelas instalado.</p></div><div class=paragraph><p>Esta seção demonstra como instalar os seguintes softwares populares de produtividade e indica se o aplicativo é pesado em recursos, se leva tempo para compilar a partir do ports ou se possui dependências importantes.</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:25%><col style=width:25%><col style=width:25%><col style=width:25%><thead><tr><th class="tableblock halign-left valign-top">Nome da aplicação</th><th class="tableblock halign-left valign-top">Recursos necessários</th><th class="tableblock halign-left valign-top">Instalação a partir do Ports</th><th class="tableblock halign-left valign-top">Principais Dependências</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Calligra</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>leve</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>pesado</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>KDE</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>AbiWord</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>leve</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>leve</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Gtk+ ou GNOME</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>The Gimp</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>leve</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>pesado</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Gtk+</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Apache OpenOffice</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>pesado</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>enorme</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>JDK™ e Mozilla</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>LibreOffice</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>um pouco pesado</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>enorme</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Gtk+, ou KDE/ GNOME, ou JDK™</p></td></tr></tbody></table><div class=sect3><h4 id=_calligra>6.3.1. Calligra<a class=anchor href=#_calligra></a></h4><div class=paragraph><p>O ambiente de área de trabalho do KDE inclui uma suíte de escritório que pode ser instalada separadamente do KDE. O Calligra inclui componentes padrões que podem ser encontrados em outros pacotes de escritório. O Words é o processador de texto, Sheets é o programa de planilha eletrônica, o Stage gerencia apresentações de slides e Karbon é usado para desenhar documentos gráficos.</p></div><div class=paragraph><p>No FreeBSD, o <a class=package href=https://cgit.freebsd.org/ports/tree/editors/calligra/>editors/calligra</a> pode ser instalado como um pacote ou um port. Para instalar o pacote:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install calligra</span></code></pre></div></div><div class=paragraph><p>Se o pacote não estiver disponível, use a Coleção de Ports:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/editors/calligra</span>
<span class=c># make install clean</span></code></pre></div></div></div><div class=sect3><h4 id=_abiword>6.3.2. AbiWord<a class=anchor href=#_abiword></a></h4><div class=paragraph><p>O AbiWord é um programa gratuito de processamento de texto semelhante em aparência ao Microsoft™ Word. É rápido, contém muitos recursos e é de fácil utilização.</p></div><div class=paragraph><p>O AbiWord pode importar ou exportar muitos formatos de arquivo, incluindo alguns formatos proprietários como o Microsoft™<span class=filename>.rtf</span>.</p></div><div class=paragraph><p>Para instalar o pacote do AbiWord:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install abiword</span></code></pre></div></div><div class=paragraph><p>Se o pacote não estiver disponível, ele pode ser compilado a partir da Coleção de Ports:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/editors/abiword</span>
<span class=c># make install clean</span></code></pre></div></div></div><div class=sect3><h4 id=_o_gimp>6.3.3. O GIMP<a class=anchor href=#_o_gimp></a></h4><div class=paragraph><p>Para autoria ou retoque de imagens, o GIMP fornece um sofisticado programa de manipulação de imagens. Ele pode ser usado como um programa de pintura simples ou como um pacote de qualidade para retoque de fotos. Ele suporta um grande número de plugins e possui uma interface de script. O GIMP pode ler e gravar uma grande variedade de formatos de arquivos e suporta interfaces com scanners e tablets.</p></div><div class=paragraph><p>Para instalar o pacote:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install gimp</span></code></pre></div></div><div class=paragraph><p>Como alternativa, use a Coleção de Ports:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/graphics/gimp</span>
<span class=c># make install clean</span></code></pre></div></div><div class=paragraph><p>A categoria de programas gráficos (<a href=https://www.FreeBSD.org/ports/>freebsd.org/ports/</a>) da Coleção de Ports contém vários plugins relacionados ao GIMP, arquivos de ajuda e manuais do usuário.</p></div></div><div class=sect3><h4 id=_apache_openoffice>6.3.4. Apache OpenOffice<a class=anchor href=#_apache_openoffice></a></h4><div class=paragraph><p>O Apache OpenOffice é uma suíte de escritório de código-fonte aberto que é desenvolvida sob a asa da Incubadora da Apache Software Foundation. Ele inclui todos os aplicativos encontrados em um pacote completo de produtividade de escritório: um processador de texto, uma planilha eletrônica, um gerenciador de apresentação e um programa de desenho. Sua interface de usuário é semelhante a outros pacotes de escritório e pode importar e exportar em vários formatos de arquivo populares. Está disponível em vários idiomas diferentes e a internacionalização foi estendida para interfaces, corretores ortográficos e dicionários.</p></div><div class=paragraph><p>O processador de texto do Apache OpenOffice usa um formato de arquivo XML nativo para maior portabilidade e flexibilidade. O programa de planilha eletrônica possui uma linguagem de macros que pode ser conectada a bancos de dados externos. O Apache OpenOffice é estável e roda nativamente em Windows™, Solaris™, Linux™, FreeBSD, e Mac OS™ X. Maiores informações sobre o Apache OpenOffice podem ser encontradas em <a href=http://openoffice.org/>openoffice.org</a>. Para informações específicas do FreeBSD, consulte <a href=http://porting.openoffice.org/freebsd/>porting.openoffice.org/freebsd/</a>.</p></div><div class=paragraph><p>Para instalar o pacote Apache OpenOffice:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install apache-openoffice</span></code></pre></div></div><div class=paragraph><p>Depois que o pacote for instalado, digite o seguinte comando para iniciar o Apache OpenOffice:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% openoffice-X.Y.Z</code></pre></div></div><div class=paragraph><p>onde <em>X.Y.Z</em> é o número da versão instalada do Apache OpenOffice. Na primeira vez que o Apache OpenOffice for iniciado, algumas perguntas serão feitas e uma pasta <span class=filename>.openoffice.org</span> será criada no diretório pessoal do usuário.</p></div><div class=paragraph><p>Se o pacote do Apache OpenOffice desejado não estiver disponível, a compilação do port ainda será uma opção. No entanto, isso requer muito espaço em disco e um tempo bastante longo para compilar:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/editors/openoffice-4</span>
<span class=c># make install clean</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Para compilar uma versão localizada, substitua o comando anterior por:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># make LOCALIZED_LANG=your_language install clean</span></code></pre></div></div><div class=paragraph><p>Substitua <em>your_language</em> pelo código ISO do idioma correto. Uma lista de códigos de idiomas suportados está disponível em <span class=filename>files/Makefile.localized</span>, localizado no diretório do port.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=_libreoffice>6.3.5. LibreOffice<a class=anchor href=#_libreoffice></a></h4><div class=paragraph><p>O LibreOffice é um pacote de software livre desenvolvido por <a href=http://www.documentfoundation.org/>documentfoundation.org</a>. É compatível com outras grandes suítes de escritórios e está disponível em diversas plataformas. Ele é um fork renomeado do Apache OpenOffice e inclui aplicativos encontrados em um pacote completo de produtividade de escritório: processador de texto, planilha, gerenciador de apresentação, programa de desenho, programa de gerenciamento de banco de dados e uma ferramenta para criar e editar fórmulas matemáticas. Está disponível em vários idiomas diferentes e a internacionalização foi estendida para interfaces, corretores ortográficos e dicionários.</p></div><div class=paragraph><p>O processador de texto do LibreOffice usa um formato de arquivo XML nativo para maior portabilidade e flexibilidade. O programa de planilha eletrônica possui uma linguagem de macros que pode ser conectada a bancos de dados externos. O LibreOffice é estável e roda nativamente em Windows™, Linux™, FreeBSD e Mac OS™ X. Maiores informações sobre o LibreOffice podem ser encontradas em <a href=http://www.libreoffice.org/>libreoffice.org</a>.</p></div><div class=paragraph><p>Para instalar a versão em inglês do pacote LibreOffice:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install libreoffice</span></code></pre></div></div><div class=paragraph><p>A categoria de editores de texto (<a href=https://www.FreeBSD.org/ports/>freebsd.org/ports/</a>) da Coleção de Ports contém várias versões versões localizadas do LibreOffice. Ao instalar um pacote localizado, substitua <code>libreoffice</code> pelo nome do pacote localizado.</p></div><div class=paragraph><p>Quando o pacote estiver instalado, digite o seguinte comando para executar o LibreOffice:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% libreoffice</code></pre></div></div><div class=paragraph><p>Durante a primeira execução, algumas perguntas serão feitas e uma pasta <span class=filename>.libreoffice</span> será criada no diretório pessoal do usuário.</p></div><div class=paragraph><p>Se o pacote LibreOffice desejado não estiver disponível, a compilação do port ainda será uma opção. No entanto, isso requer muito espaço em disco e um tempo bastante longo para compilar. Este exemplo compila a versão em inglês:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/editors/libreoffice</span>
<span class=c># make install clean</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Para compilar uma versão localizada, faça <code>cd</code> para o diretório do port do idioma desejado. Os idiomas suportados podem ser encontrados na categoria de editores (<a href=https://www.FreeBSD.org/ports/>freebsd.org/ports/</a>) da Coleção de Ports.</p></div></td></tr></tbody></table></div></div></div><div class=sect2><h3 id=desktop-viewers>6.4. Visualizadores de Documentos<a class=anchor href=#desktop-viewers></a></h3><div class=paragraph><p>Alguns novos formatos de documentos ganharam popularidade desde o advento do UNIX™ e os visualizadores que eles exigem podem não estar disponíveis no sistema base. Esta seção demonstra como instalar os seguintes visualizadores de documentos:</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:25%><col style=width:25%><col style=width:25%><col style=width:25%><thead><tr><th class="tableblock halign-left valign-top">Nome da aplicação</th><th class="tableblock halign-left valign-top">Recursos necessários</th><th class="tableblock halign-left valign-top">Instalação a partir do Ports</th><th class="tableblock halign-left valign-top">Principais Dependências</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Xpdf</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>leve</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>leve</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>FreeType</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>gv</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>leve</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>leve</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Xaw3d</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Geeqie</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>leve</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>leve</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Gtk+ ou GNOME</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>ePDFView</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>leve</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>leve</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Gtk+</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Okular</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>leve</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>pesado</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>KDE</p></td></tr></tbody></table><div class=sect3><h4 id=_xpdf>6.4.1. Xpdf<a class=anchor href=#_xpdf></a></h4><div class=paragraph><p>Para os usuários que preferem um pequeno visualizador de PDF do FreeBSD, o Xpdf fornece um visualizador leve e eficiente que requer poucos recursos. Ele usa as fontes X padrão e não requer nenhum kit de ferramentas adicional.</p></div><div class=paragraph><p>Para instalar o pacote Xpdf:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install xpdf</span></code></pre></div></div><div class=paragraph><p>Se o pacote não estiver disponível, use a Coleção de Ports:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/graphics/xpdf</span>
<span class=c># make install clean</span></code></pre></div></div><div class=paragraph><p>Quando a instalação estiver concluída, inicie o <code>xpdf</code> e use o botão direito do mouse para ativar o menu.</p></div></div><div class=sect3><h4 id=_gv>6.4.2. gv<a class=anchor href=#_gv></a></h4><div class=paragraph><p>O gv é um visualizador de arquivos PostScript™ e PDF. Ele é baseado no ghostview, mas tem uma aparência mais agradável, pois é baseado no kit de ferramentas do widget Xaw3d. O gv possui muitos recursos configuráveis, como orientação, tamanho do papel, escala e anti-aliasing. Quase qualquer operação pode ser executada com o teclado ou com o mouse.</p></div><div class=paragraph><p>Para instalar o gv como um pacote:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install gv</span></code></pre></div></div><div class=paragraph><p>Se um pacote não estiver disponível, use a Coleção de Ports:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/print/gv</span>
<span class=c># make install clean</span></code></pre></div></div></div><div class=sect3><h4 id=_geeqie>6.4.3. Geeqie<a class=anchor href=#_geeqie></a></h4><div class=paragraph><p>O Geeqie é um fork do projeto abandonado GQView, em um esforço para levar o desenvolvimento adiante e integrar os patches existentes. O Geeqie é um gerenciador de imagens que suporta a visualização de um arquivo com um único clique, a execução de um editor externo e a visualização de miniaturas. Ele também possui um modo de apresentação de slides e algumas operações básicas de arquivo, facilitando o gerenciamento das coleções de imagens e a localização de arquivos duplicados. O Geeqie suporta visualização em tela cheia e a internacionalização.</p></div><div class=paragraph><p>Para instalar o pacote Geeqie:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install geeqie</span></code></pre></div></div><div class=paragraph><p>Se o pacote não estiver disponível, use a Coleção de Ports:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/graphics/geeqie</span>
<span class=c># make install clean</span></code></pre></div></div></div><div class=sect3><h4 id=_epdfview>6.4.4. ePDFView<a class=anchor href=#_epdfview></a></h4><div class=paragraph><p>O ePDFView é um visualizador de documentos PDF leve que usa somente as bibliotecas Gtk+ e Poppler. Ele está atualmente em desenvolvimento, mas já abre a maioria dos arquivos PDF (até os criptografados), salva cópias de documentos e tem suporte para impressão usando o CUPS.</p></div><div class=paragraph><p>Para instalar o ePDFView como um pacote:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install epdfview</span></code></pre></div></div><div class=paragraph><p>Se um pacote não estiver disponível, use a Coleção de Ports:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/graphics/epdfview</span>
<span class=c># make install clean</span></code></pre></div></div></div><div class=sect3><h4 id=_okular>6.4.5. Okular<a class=anchor href=#_okular></a></h4><div class=paragraph><p>O Okular é um visualizador de documentos universal baseado no KPDF para KDE. Ele pode abrir muitos formatos de documentos, incluindo PDF, PostScript™, DjVu, CHM, XPS e ePub.</p></div><div class=paragraph><p>Para instalar o Okular como um pacote:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install okular</span></code></pre></div></div><div class=paragraph><p>Se um pacote não estiver disponível, use a Coleção de Ports:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/graphics/okular</span>
<span class=c># make install clean</span></code></pre></div></div></div></div><div class=sect2><h3 id=desktop-finance>6.5. Finanças<a class=anchor href=#desktop-finance></a></h3><div class=paragraph><p>Para gerenciar finanças pessoais em um desktop FreeBSD, alguns aplicativos poderosos e fáceis de usar podem ser instalados. Alguns são compatíveis com formatos de arquivos comuns, como os formatos usados pelo Quicken e Excel.</p></div><div class=paragraph><p>Esta seção cobre estes programas:</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:25%><col style=width:25%><col style=width:25%><col style=width:25%><thead><tr><th class="tableblock halign-left valign-top">Nome da aplicação</th><th class="tableblock halign-left valign-top">Recursos necessários</th><th class="tableblock halign-left valign-top">Instalação a partir do Ports</th><th class="tableblock halign-left valign-top">Principais Dependências</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>GnuCash</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>leve</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>pesado</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>GNOME</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Gnumeric</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>leve</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>pesado</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>GNOME</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>KMyMoney</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>leve</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>pesado</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>KDE</p></td></tr></tbody></table><div class=sect3><h4 id=_gnucash>6.5.1. GnuCash<a class=anchor href=#_gnucash></a></h4><div class=paragraph><p>O GnuCash faz parte do esforço do GNOME para fornecer aplicativos fáceis de usar, mas poderosos, para usuários finais. O GnuCash pode ser usado para acompanhar receitas e despesas, contas bancárias e ações. Ele apresenta uma interface intuitiva, mantendo-se profissional.</p></div><div class=paragraph><p>O GnuCash fornece um registro inteligente, um sistema hierárquico de contas e muitos aceleradores de teclado e métodos de preenchimento automático. Ele pode dividir uma única transação em várias partes mais detalhadas. O GnuCash pode importar e mesclar arquivos QIF do Quicken. Ele também lida com a maioria dos formatos internacionais de data e moeda.</p></div><div class=paragraph><p>Para instalar o pacote GnuCash:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install gnucash</span></code></pre></div></div><div class=paragraph><p>Se o pacote não estiver disponível, use a Coleção de Ports:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/finance/gnucash</span>
<span class=c># make install clean</span></code></pre></div></div></div><div class=sect3><h4 id=_gnumeric>6.5.2. Gnumeric<a class=anchor href=#_gnumeric></a></h4><div class=paragraph><p>O Gnumeric é um programa de planilha eletrônica desenvolvido pela comunidade GNOME. Ele possui adivinhação automática e conveniente de entrada do usuário de acordo com o formato da célula para muitas sequências. Ele pode importar arquivos em vários formatos populares, incluindo Excel, Lotus 1-2-3 e Quattro Pro. Ele tem um grande número de funções internas e permite todos os formatos usuais de célula, como número, moeda, data, hora e muito mais.</p></div><div class=paragraph><p>Para instalar o Gnumeric como um pacote:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install gnumeric</span></code></pre></div></div><div class=paragraph><p>Se o pacote não estiver disponível, use a Coleção de Ports:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/math/gnumeric</span>
<span class=c># make install clean</span></code></pre></div></div></div><div class=sect3><h4 id=_kmymoney>6.5.3. KMyMoney<a class=anchor href=#_kmymoney></a></h4><div class=paragraph><p>O KMyMoney é uma aplicação de finanças pessoais criada pela comunidade KDE. O KMyMoney tem como objetivo fornecer os recursos importantes encontrados em aplicativos comerciais de gerenciamento de finanças pessoais. Ele também destaca a facilidade de uso e a contabilidade adequada de dupla entrada entre seus recursos. O KMyMoney importa a partir de arquivos QIF padrão do Quicken, rastreia investimentos, manipula várias moedas e fornece diversos relatórios.</p></div><div class=paragraph><p>Para instalar o KMyMoney como um pacote:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install kmymoney-kde4</span></code></pre></div></div><div class=paragraph><p>Se o pacote não estiver disponível, use a Coleção de Ports:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/finance/kmymoney-kde4</span>
<span class=c># make install clean</span></code></pre></div></div></div></div></div></div><div class=sect1><h2 id=multimedia>Capítulo 7. Multimídia<a class=anchor href=#multimedia></a></h2><div class=sectionbody><div class=sect2><h3 id=multimedia-synopsis>7.1. Sinopse<a class=anchor href=#multimedia-synopsis></a></h3><div class=paragraph><p>O FreeBSD suporta uma ampla variedade de placas de som, permitindo que os usuários aproveitem a saída de alta fidelidade de um sistema FreeBSD. Isso inclui a capacidade de gravar e reproduzir áudio MPEG Layer 3 (MP3), arquivo de áudio Waveform (WAV), Ogg Vorbis e outros formatos. A coleção de Ports do FreeBSD contém muitas aplicações para editar áudio gravado, adicionar efeitos sonoros e controlar dispositivos MIDI conectados.</p></div><div class=paragraph><p>O FreeBSD também suporta a reprodução de arquivos de vídeo e DVDs. A coleção de Ports do FreeBSD contém aplicativos para codificar, converter e reproduzir várias mídias de vídeo.</p></div><div class=paragraph><p>Este capítulo descreve como configurar placas de som, reprodução de vídeo, placas sintonizadoras de TV e scanners no FreeBSD. Também descreve algumas das aplicações que estão disponíveis para usar esses dispositivos.</p></div><div class=paragraph><p>Depois de ler este capítulo, você irá saber como:</p></div><div class=ulist><ul><li><p>Configurar uma placa de som no FreeBSD.</p></li><li><p>Solucionar problemas de configuração de som.</p></li><li><p>Reproduzir e codificar MP3 e outros áudios.</p></li><li><p>Preparar um sistema FreeBSD para reprodução de vídeo.</p></li><li><p>Reproduzir DVDs, arquivos <span class=filename>.mpg</span> e <span class=filename>.avi</span>.</p></li><li><p>Copiar o conteúdo de um CD ou DVD em arquivos arquivos.</p></li><li><p>Configurar uma placa de TV.</p></li><li><p>Instale e configure o MythTV no FreeBSD</p></li><li><p>Configurar um scanner de imagem.</p></li><li><p>Configurar um headset Bluetooth.</p></li></ul></div><div class=paragraph><p>Antes de ler este capítulo, você deve:</p></div><div class=ulist><ul><li><p>Saber como instalar aplicativos conforme descrito em <a href=./#ports>Instalando Aplicativos. Pacotes e Ports</a>.</p></li></ul></div></div><div class=sect2><h3 id=sound-setup>7.2. Configurando a Placa de Som<a class=anchor href=#sound-setup></a></h3><div class=paragraph><p>Antes de iniciar a configuração, determine o modelo da placa de som e o chip usado. O FreeBSD suporta uma ampla variedade de placas de som. Verifique a lista de dispositivos de áudio compatíveis nas <a href=https://www.FreeBSD.org/releases/12.0r/hardware/>Notas de Hardware</a>, para ver se a placa de som é suportada e quais drivers do FreeBSD que ela usa.</p></div><div class=paragraph><p>Para usar um dispositivo de som, seu driver deve ser carregado. A maneira mais fácil é carregar o módulo do kernel para a placa de som com o <a href="https://man.freebsd.org/cgi/man.cgi?query=kldload&amp;sektion=8&amp;format=html">kldload(8)</a>. Este exemplo carrega o driver para um chipset de áudio integrado baseado na especificação Intel:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload snd_hda</span></code></pre></div></div><div class=paragraph><p>Para automatizar o carregamento desse driver no momento da inicialização, faça edição adicionando a seguinte linha ao arquivo <span class=filename>/boot/loader.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>snd_hda_load=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Outros módulos de som disponíveis estão listados no arquivo <span class=filename>/boot/defaults/loader.conf</span>. Quando não tiver certeza de qual driver usar, carregue o módulo <span class=filename>snd_driver</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload snd_driver</span></code></pre></div></div><div class=paragraph><p>Este é um metadriver que carrega todos os drivers de som mais comuns e pode ser usado para acelerar a busca pelo driver correto. Também é possível carregar todos os drivers de som adicionando o metadriver no arquivo <span class=filename>/boot/loader.conf</span>.</p></div><div class=paragraph><p>Para determinar qual driver foi selecionado para a placa de som após carregar o metadriver <span class=filename>snd_driver</span>, digite, <code>cat /dev/sndstat</code>.</p></div><div class=sect3><h4 id=_configurando_um_kernel_personalizado_com_suporte_de_som>7.2.1. Configurando um kernel Personalizado com Suporte de Som<a class=anchor href=#_configurando_um_kernel_personalizado_com_suporte_de_som></a></h4><div class=paragraph><p>Esta seção é para usuários que preferem compilar estaticamente em suporte para a placa de som em um kernel personalizado. Para mais informações sobre como recompilar um kernel, consulte <a href=./#kernelconfig>Configurando o kernel do FreeBSD</a>.</p></div><div class=paragraph><p>Ao usar um kernel personalizado para fornecer suporte ao som, verifique se o driver do framework de áudio existe no arquivo de configuração do kernel personalizado:</p></div><div class="literalblock programlisting"><div class=content><pre>device sound</pre></div></div><div class=paragraph><p>Em seguida, adicione suporte para a placa de som. Para continuar o exemplo do chipset de áudio integrado baseado na especificação Intel da seção anterior, use a seguinte linha no arquivo de configuração do kernel personalizado:</p></div><div class="literalblock programlisting"><div class=content><pre>device snd_hda</pre></div></div><div class=paragraph><p>Certifique-se de ler a página de manual do driver para o nome do dispositivo a ser usado pelo driver.</p></div><div class=paragraph><p>Placas de som ISA não-PnP podem requerer que as configurações de porta IRQ e I/O da placa sejam adicionadas ao arquivo <span class=filename>/boot/device.hints</span>. Durante o processo de inicialização, o <a href="https://man.freebsd.org/cgi/man.cgi?query=loader&amp;sektion=8&amp;format=html">loader(8)</a> lê este arquivo e passa as configurações para o kernel. Por exemplo, uma placa antiga ISA não-PnP da Creative SoundBlaster™ usará o driver <a href="https://man.freebsd.org/cgi/man.cgi?query=snd_sbc&amp;sektion=4&amp;format=html">snd_sbc(4)</a> em conjunto com <code>snd_sb16</code>. Para esta placa, as seguintes linhas devem ser adicionadas ao arquivo de configuração do kernel:</p></div><div class="literalblock programlisting"><div class=content><pre>device snd_sbc
device snd_sb16</pre></div></div><div class=paragraph><p>Se a placa usar a porta de I/O <code>0x220</code> e a IRQ <code>5</code>, essas linhas também deverão ser adicionadas ao arquivo <span class=filename>/boot/device.hints</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>hint.sbc.0.at=&#34;isa&#34;
hint.sbc.0.port=&#34;0x220&#34;
hint.sbc.0.irq=&#34;5&#34;
hint.sbc.0.drq=&#34;1&#34;
hint.sbc.0.flags=&#34;0x15&#34;</pre></div></div><div class=paragraph><p>A sintaxe usada no arquivo <span class=filename>/boot/device.hints</span> é descrita em <a href="https://man.freebsd.org/cgi/man.cgi?query=sound&amp;sektion=4&amp;format=html">sound(4)</a> e na página de manual do driver da placa de som.</p></div><div class=paragraph><p>As configurações mostradas acima são os padrões. Em alguns casos, a IRQ ou outras configurações podem precisar ser alterados para corresponder à placa. Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=snd_sbc&amp;sektion=4&amp;format=html">snd_sbc(4)</a> para obter mais informações sobre esta placa.</p></div></div><div class=sect3><h4 id=sound-testing>7.2.2. Testando o Som<a class=anchor href=#sound-testing></a></h4><div class=paragraph><p>Depois de carregar o módulo necessário ou reinicializar no kernel personalizado, a placa de som deve ser detectada. Para confirmar, execute <code>dmesg | grep pcm</code>. Este exemplo é de um sistema com um chipset integrado Conexant CX20590:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>pcm0: &lt;NVIDIA <span class=o>(</span>0x001c<span class=o>)</span> <span class=o>(</span>HDMI/DP 8ch<span class=o>)&gt;</span> at nid 5 on hdaa0
pcm1: &lt;NVIDIA <span class=o>(</span>0x001c<span class=o>)</span> <span class=o>(</span>HDMI/DP 8ch<span class=o>)&gt;</span> at nid 6 on hdaa0
pcm2: &lt;Conexant CX20590 <span class=o>(</span>Analog 2.0+HP/2.0<span class=o>)&gt;</span> at nid 31,25 and 35,27 on hdaa1</code></pre></div></div><div class=paragraph><p>O status da placa de som também pode ser verificado usando este comando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cat /dev/sndstat</span>
FreeBSD Audio Driver <span class=o>(</span>newpcm: 64bit 2009061500/amd64<span class=o>)</span>
Installed devices:
pcm0: &lt;NVIDIA <span class=o>(</span>0x001c<span class=o>)</span> <span class=o>(</span>HDMI/DP 8ch<span class=o>)&gt;</span> <span class=o>(</span>play<span class=o>)</span>
pcm1: &lt;NVIDIA <span class=o>(</span>0x001c<span class=o>)</span> <span class=o>(</span>HDMI/DP 8ch<span class=o>)&gt;</span> <span class=o>(</span>play<span class=o>)</span>
pcm2: &lt;Conexant CX20590 <span class=o>(</span>Analog 2.0+HP/2.0<span class=o>)&gt;</span> <span class=o>(</span>play/rec<span class=o>)</span> default</code></pre></div></div><div class=paragraph><p>A saída irá variar dependendo da placa de som. Se nenhum dispositivo <span class=filename>pcm</span> estiver listado, verifique se o driver de dispositivo correto foi carregado ou compilado no kernel. A próxima seção lista alguns problemas comuns e suas soluções.</p></div><div class=paragraph><p>Se tudo correr bem, a placa de som deverá funcionar no FreeBSD. Se a unidade de CD ou DVD estiver corretamente conectada à placa de som, é possível inserir um CD de áudio na unidade e reproduzi-lo com <a href="https://man.freebsd.org/cgi/man.cgi?query=cdcontrol&amp;sektion=1&amp;format=html">cdcontrol(1)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% cdcontrol <span class=nt>-f</span> /dev/acd0 play 1</code></pre></div></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>CD de audio têm codificações especializadas, o que significa que não devem ser montados usando <a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Várias aplicações, como <a class=package href=https://cgit.freebsd.org/ports/tree/audio/workman/>audio/workman</a>, fornecem uma interface mais amigável. O Port <a class=package href=https://cgit.freebsd.org/ports/tree/audio/mpg123/>audio/mpg123</a> pode ser instalado para ouvir arquivos de áudio MP3.</p></div><div class=paragraph><p>Outra maneira rápida de testar a placa é enviar dados para <span class=filename>/dev/dsp</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>cat </span>filename <span class=o>&gt;</span> /dev/dsp</code></pre></div></div><div class=paragraph><p>onde <span class=filename>filename</span> pode ser qualquer tipo de arquivo. Este comando deve produzir algum ruído, confirmando que a placa de som está funcionando.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Os nós de dispositivo <span class=filename>/dev/dsp*</span> serão criados automaticamente conforme necessário. Quando não estão em uso, eles não existem e não aparecerão na saída de <a href="https://man.freebsd.org/cgi/man.cgi?query=ls&amp;sektion=1&amp;format=html">ls(1)</a>.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=bluetooth-headset>7.2.3. Configurando Dispositivos de Som Bluetooth<a class=anchor href=#bluetooth-headset></a></h4><div class=paragraph><p>Conectar a um dispositivo Bluetooth está fora do escopo deste capítulo. Consulte a <a href=./#network-bluetooth>Bluetooth</a> para mais informações.</p></div><div class=paragraph><p>Para que o dispositivo Bluetooth funcione com o sistema de som do FreeBSD, os usuários precisam primeiramente instalar o <a class=package href=https://cgit.freebsd.org/ports/tree/audio/virtual_oss/>audio/virtual_oss</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install virtual_oss</span></code></pre></div></div><div class=paragraph><p><a class=package href=https://cgit.freebsd.org/ports/tree/audio/virtual_oss/>audio/virtual_oss</a> requer <code>cuse</code> para ser carregado no kernel:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload cuse</span></code></pre></div></div><div class=paragraph><p>Para carregar o <code>cuse</code> durante a inicialização do sistema, execute o comando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysrc -f /boot/loader.conf cuse_load=yes</span></code></pre></div></div><div class=paragraph><p>Para usar fones de ouvido como reprodutor de som com <a class=package href=https://cgit.freebsd.org/ports/tree/audio/virtual_oss/>audio/virtual_oss</a>, os usuários precisam criar um dispositivo virtual depois de se conectarem a um dispositivo de áudio Bluetooth:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># virtual_oss -C 2 -c 2 -r 48000 -b 16 -s 768 -R /dev/null -P /dev/bluetooth/headphones -d dsp</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p><em>headphones</em> neste exemplo é o nome de host de <span class=filename>/etc/bluetooth/hosts</span>. <code>BT_ADDR</code> também poderia ser usado.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=virtual_oss&amp;sektion=8&amp;format=html">virtual_oss(8)</a> para mais informações.</p></div></div><div class=sect3><h4 id=troubleshooting>7.2.4. Solução de Problemas de Som<a class=anchor href=#troubleshooting></a></h4><div class=paragraph><p><a href=#multimedia-sound-common-error-messages>Mensagens de Erros Comuns</a> lista algumas mensagens de erros comuns e suas soluções:</p></div><table id=multimedia-sound-common-error-messages class="tableblock frame-none grid-all stretch"><caption class=title>Tabela 7. Mensagens de Erros Comuns</caption><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Erro</th><th class="tableblock halign-left valign-top">Solução</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>sb_dspwr(XX) timed out</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>A porta de I/O não está configurada corretamente.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>bad irq XX</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>A IRQ está definida incorretamente. Certifique-se de que a IRQ definido e a IRQ do som são as mesmas.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>xxx: gus pcm not attached, out of memory</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Não há memória disponível suficiente para usar o dispositivo.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>xxx: can’t open /dev/dsp!</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Digite <code>fstat | grep dsp</code> para verificar se outro aplicativo está mantendo o dispositivo aberto. Os causadores de problemas notáveis são o suporte a som do esound e do KDE.</p></td></tr></tbody></table><div class=paragraph><p>Placas gráficas modernas geralmente vêm com seu próprio driver de som para uso com HDMI. Às vezes, esse dispositivo de som é enumerado antes da placa de som, o que significa que a placa de som não será usada como o dispositivo de reprodução padrão. Para verificar se este é o caso, execute dmesg e procure por <code>pcm</code>. A saída é algo como isto:</p></div><div class="literalblock programlisting"><div class=content><pre>...
hdac0: HDA Driver Revision: 20100226_0142
hdac1: HDA Driver Revision: 20100226_0142
hdac0: HDA Codec #0: NVidia (Unknown)
hdac0: HDA Codec #1: NVidia (Unknown)
hdac0: HDA Codec #2: NVidia (Unknown)
hdac0: HDA Codec #3: NVidia (Unknown)
pcm0: &lt;HDA NVidia (Unknown) PCM #0 DisplayPort&gt; at cad 0 nid 1 on hdac0
pcm1: &lt;HDA NVidia (Unknown) PCM #0 DisplayPort&gt; at cad 1 nid 1 on hdac0
pcm2: &lt;HDA NVidia (Unknown) PCM #0 DisplayPort&gt; at cad 2 nid 1 on hdac0
pcm3: &lt;HDA NVidia (Unknown) PCM #0 DisplayPort&gt; at cad 3 nid 1 on hdac0
hdac1: HDA Codec #2: Realtek ALC889
pcm4: &lt;HDA Realtek ALC889 PCM #0 Analog&gt; at cad 2 nid 1 on hdac1
pcm5: &lt;HDA Realtek ALC889 PCM #1 Analog&gt; at cad 2 nid 1 on hdac1
pcm6: &lt;HDA Realtek ALC889 PCM #2 Digital&gt; at cad 2 nid 1 on hdac1
pcm7: &lt;HDA Realtek ALC889 PCM #3 Digital&gt; at cad 2 nid 1 on hdac1
...</pre></div></div><div class=paragraph><p>Neste exemplo, a placa gráfica (<code>NVidia</code>) foi enumerada antes da placa de som (<code>Realtek ALC889</code>). Para usar a placa de som como o dispositivo de reprodução padrão, altere a variável <code>hw.snd.default_unit</code> para a unidade que deve ser usada para reprodução:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl hw.snd.default_unit=n</span></code></pre></div></div><div class=paragraph><p>onde <code>n</code> é o número do dispositivo de som a ser usado. Neste exemplo, deve ser <code>4</code>. Deixe esta mudança permanente adicionando a seguinte linha ao arquivo <span class=filename>/etc/sysctl.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>hw.snd.default_unit=4</pre></div></div></div><div class=sect3><h4 id=sound-multiple-sources>7.2.5. Utilizando Múltiplas Fontes de Som<a class=anchor href=#sound-multiple-sources></a></h4><div class=paragraph><p>Muitas vezes é desejável ter várias fontes de som capazes de tocar simultaneamente. O FreeBSD usa "Canais de Som Virtuais" para multiplexar a reprodução da placa de som mixando o som no kernel.</p></div><div class=paragraph><p>Três variáveis no <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> estão disponíveis para configurar canais virtuais:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl dev.pcm.0.play.vchans=4</span>
<span class=c># sysctl dev.pcm.0.rec.vchans=4</span>
<span class=c># sysctl hw.snd.maxautovchans=4</span></code></pre></div></div><div class=paragraph><p>Este exemplo aloca quatro canais virtuais, que é um número prático para o uso diário. Ambos <code>dev.pcm.0.play.vchans=4</code> e <code>dev.pcm.0.rec.vchans=4</code> são configuráveis depois que um dispositivo foi anexado e representa o número de canais virtuais <span class=filename>pcm0</span> para reprodução e gravação. Como o módulo <span class=filename>pcm</span> pode ser carregado independentemente dos drivers de hardware, <code>hw.snd.maxautovchans</code> indica quantos canais virtuais serão dados a um dispositivo de áudio quando ele estiver conectado. Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=pcm&amp;sektion=4&amp;format=html">pcm(4)</a> para obter mais informações.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>O número de canais virtuais para um dispositivo não pode ser alterado enquanto estiver em uso. Primeiramente, feche todos os programas usando o dispositivo, como players de música ou daemons de som.</p></div></td></tr></tbody></table></div><div class=paragraph><p>O dispositivo <span class=filename>pcm</span> correto será automaticamente alocado de forma transparente para um programa que solicite <span class=filename>/dev/dsp0</span>.</p></div></div><div class=sect3><h4 id=_configurando_valores_padrões_para_canais_de_mixer>7.2.6. Configurando Valores Padrões para Canais de Mixer<a class=anchor href=#_configurando_valores_padrões_para_canais_de_mixer></a></h4><div class=paragraph><p>Os valores padrões para os diferentes canais do mixer são codificados permanentemente no código-fonte do driver <a href="https://man.freebsd.org/cgi/man.cgi?query=pcm&amp;sektion=4&amp;format=html">pcm(4)</a>. Embora os níveis do mixer da placa de som possam ser alterados usando <a href="https://man.freebsd.org/cgi/man.cgi?query=mixer&amp;sektion=8&amp;format=html">mixer(8)</a> ou aplicativos e daemons de terceiros, essa não é uma solução permanente. Para definir os valores padrões do mixer no nível do driver, defina os valores apropriados no arquivo <span class=filename>/boot/device.hints</span>, conforme mostrado neste exemplo:</p></div><div class="literalblock programlisting"><div class=content><pre>hint.pcm.0.vol=&#34;50&#34;</pre></div></div><div class=paragraph><p>Isso definirá o canal de volume como um valor padrão de <code>50</code> quando o módulo <a href="https://man.freebsd.org/cgi/man.cgi?query=pcm&amp;sektion=4&amp;format=html">pcm(4)</a> for carregado.</p></div></div></div><div class=sect2><h3 id=sound-mp3>7.3. Áudio MP3<a class=anchor href=#sound-mp3></a></h3><div class=paragraph><p>Esta seção descreve alguns players MP3 disponíveis para o FreeBSD, como ripar trilhas de CD de áudio e como codificar e decodificar MP3.</p></div><div class=sect3><h4 id=mp3-players>7.3.1. Players de MP3<a class=anchor href=#mp3-players></a></h4><div class=paragraph><p>Um popular reprodutor gráfico de MP3 é o Audacious. Ele suporta skins do Winamp e plugins adicionais. A interface é intuitiva, com uma lista de reprodução, equalizador gráfico e muito mais. Para aqueles que estão familiarizados com o Winamp, acharão o Audacious simples de usar. No FreeBSD, o Audacious pode ser instalado a partir de pacotes ou coleção de Ports <a class=package href=https://cgit.freebsd.org/ports/tree/multimedia/audacious/>multimedia/audacious</a>. Audacious é descendente do XMMS.</p></div><div class=paragraph><p>O pacote ou Port <a class=package href=https://cgit.freebsd.org/ports/tree/audio/mpg123/>audio/mpg123</a> fornece um reprodutor de MP3 alternativo em linha de comando. Uma vez instalado, especifique o arquivo MP3 para reproduzir na linha de comando. Se o sistema tiver vários dispositivos de áudio, o dispositivo de som também pode ser especificado:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mpg123 -a /dev/dsp1.0 Foobar-GreatestHits.mp3</span>
High Performance MPEG 1.0/2.0/2.5 Audio Player <span class=k>for </span>Layers 1, 2 and 3
        version 1.18.1<span class=p>;</span> written and copyright by Michael Hipp and others
        free software <span class=o>(</span>LGPL<span class=o>)</span> without any warranty but with best wishes

Playing MPEG stream from Foobar-GreatestHits.mp3 ...
MPEG 1.0 layer III, 128 kbit/s, 44100 Hz joint-stereo</code></pre></div></div><div class=paragraph><p>Outros players MP3 estão disponíveis na Coleção de Ports do FreeBSD.</p></div></div><div class=sect3><h4 id=rip-cd>7.3.2. Copiando Trilhas de CD de Áudio<a class=anchor href=#rip-cd></a></h4><div class=paragraph><p>Antes de codificar um CD ou CD para MP3, os dados de áudio no CD devem ser copiados para o disco rígido. Isso é feito copiando os dados brutos do CD Digital Audio (CDDA) como arquivos WAV.</p></div><div class=paragraph><p>A ferramenta <code>cdda2wav</code>, que é instalada com o suite de programas <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/cdrtools/>sysutils/cdrtools</a>, pode ser usada para extrair informações de áudio do CD.</p></div><div class=paragraph><p>Com o CD de áudio na unidade, o seguinte comando pode ser executado como <code>root</code> para ripar um CD inteiro em arquivos WAV, por trilhas:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cdda2wav -D 0,1,0 -B</span></code></pre></div></div><div class=paragraph><p>Neste exemplo, o <code>-D <em>0,1,0</em></code> indica o dispositivo SCSI <span class=filename>0,1,0</span> contendo o CD para ripar. Use o comando <code>cdrecord -scanbus</code> para determinar os parâmetros corretos do dispositivo para o sistema.</p></div><div class=paragraph><p>Para ripar trilhas individuais, use a opção <code>-t</code> para especificar a trilha:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cdda2wav -D 0,1,0 -t 7</span></code></pre></div></div><div class=paragraph><p>Para extrair um intervalo de trilhas, como as trilhas de um a sete, especifique um intervalo:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cdda2wav -D 0,1,0 -t 1+7</span></code></pre></div></div><div class=paragraph><p>Para extrair de uma unidade ATAPI(IDE) CDROM, especifique o nome do dispositivo no lugar dos números da unidade SCSI. Por exemplo, para extrair a trilha 7 de uma unidade IDE:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cdda2wav -D /dev/acd0 -t 7</span></code></pre></div></div><div class=paragraph><p>Alternativamente, o comando <code>dd</code> pode ser usado para extrair trilhas de áudio em unidades ATAPI, conforme descrito em <a href=./#duplicating-audiocds>Duplicando CDs de Áudio</a>.</p></div></div><div class=sect3><h4 id=mp3-encoding>7.3.3. Codificação e Decodificação de MP3<a class=anchor href=#mp3-encoding></a></h4><div class=paragraph><p>Lame é um codificador popular para MP3 que pode ser instalado a partir do port <a class=package href=https://cgit.freebsd.org/ports/tree/audio/lame/>audio/lame</a>. Devido a problemas de patente, o pacote não está disponível.</p></div><div class=paragraph><p>O comando a seguir converterá o arquivo WAV <span class=filename>audio01.wav</span> para <span class=filename>audio01.mp3</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># lame -h -b 128 --tt &#34;Foo Song Title&#34; --ta &#34;FooBar Artist&#34; --tl &#34;FooBar Album&#34; \</span>
<span class=nt>--ty</span> <span class=s2>&#34;2014&#34;</span> <span class=nt>--tc</span> <span class=s2>&#34;Ripped and encoded by Foo&#34;</span> <span class=nt>--tg</span> <span class=s2>&#34;Genre&#34;</span> audio01.wav audio01.mp3</code></pre></div></div><div class=paragraph><p>Os 128 kbits especificados são uma taxa de bits padrão para MP3, enquanto as taxas de bits 160 e 192 fornecem maior qualidade. Quanto maior a taxa de bits, maior o tamanho do arquivo MP3 resultante. A opção <code>-h</code> ativa o modo " de maior qualidade, mas um pouco mais lento ". As opções que começam com <code>--t</code> indicam as tags ID3, que geralmente contêm informações sobre músicas, para serem incorporadas no arquivo MP3. Opções adicionais de codificação podem ser encontradas na página de manual do lame.</p></div><div class=paragraph><p>Para gravar um CD de áudio usando arquivos MP3, primeiro estes devem ser convertidos em um formato de arquivo não compactado. O XMMS pode ser usado para converter para o formato WAV, enquanto o mpg123 pode ser usado para converter para o formato de dados de áudio bruto, Pulse Code Modulation (PCM).</p></div><div class=paragraph><p>Para converter o arquivo <span class=filename>audio01.mp3</span> usando mpg123, especifique o nome do arquivo PCM:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mpg123 -s audio01.mp3 &gt; audio01.pcm</span></code></pre></div></div><div class=paragraph><p>Para usar XMMS para converter um arquivo MP3 para WAV, use esses passos:</p></div><div class="exampleblock procedure"><div class=content><div class=paragraph><p><strong>Procedure: Convertendo para o Formato WAV no XMMS</strong></p></div><div class="olist arabic"><ol class=arabic><li><p>Inicie o XMMS.</p></li><li><p>Clique com o botão direito do mouse na janela para abrir o menu XMMS.</p></li><li><p>Selecione <code>Preferences</code> abaixo de <code>Options</code>.</p></li><li><p>Altere o Plugin de Saída para "Disk Writer Plugin".</p></li><li><p>Pressione <code>Configure</code>.</p></li><li><p>Digite ou procure um diretório para gravar os arquivos descompactados.</p></li><li><p>Carregue o arquivo MP3 no XMMS como de costume, com o volume em 100% e as configurações de EQ desativadas.</p></li><li><p>Pressione <code>Play</code>. O XMMS aparecerá como se estivesse tocando o MP3, mas nenhuma música será ouvida. Na verdade, está tocando o MP3 para um arquivo.</p></li><li><p>Quando terminar, certifique-se de ajustar o Plugin de Saída padrão de volta ao que era antes para ouvir MP3 novamente.</p></li></ol></div></div></div><div class=paragraph><p>Os formatos WAV e PCM podem ser usados com cdrecord. Ao usar arquivos WAV, haverá um pequeno som no início de cada trilha. Este som é o cabeçalho do arquivo WAV. O pacote binário ou port <a class=package href=https://cgit.freebsd.org/ports/tree/audio/sox/>audio/sox</a> pode ser usado para remover o cabeçalho:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% sox <span class=nt>-t</span> wav <span class=nt>-r</span> 44100 <span class=nt>-s</span> <span class=nt>-w</span> <span class=nt>-c</span> 2 track.wav track.raw</code></pre></div></div><div class=paragraph><p>Consulte <a href=./#creating-cds>Criando e Usando Mídia em CD</a> para mais informações sobre o uso de um gravador de CD no FreeBSD.</p></div></div></div><div class=sect2><h3 id=video-playback>7.4. Reprodução de Vídeo<a class=anchor href=#video-playback></a></h3><div class=paragraph><p>Antes de configurar a reprodução de vídeo, determine o modelo e o chipset da placa de vídeo. Embora o Xorg suporte uma ampla variedade de placas de vídeo, nem todas oferecem um bom desempenho de reprodução. Para obter uma lista de extensões suportadas pelo servidor Xorg usando a placa, execute <code>xdpyinfo</code> enquanto o Xorg está sendo executado.</p></div><div class=paragraph><p>É interessante ter um arquivo de teste MPEG pequeno para avaliar vários players e opções. Como alguns aplicativos de DVD procuram por mídia DVD em <span class=filename>/dev/dvd</span> por padrão, ou possuem esse nome de dispositivo codificado neles, pode ser útil fazer um link simbólico para o dispositivo adequado:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ln -sf /dev/cd0 /dev/dvd</span></code></pre></div></div><div class=paragraph><p>Devido à natureza do <a href="https://man.freebsd.org/cgi/man.cgi?query=devfs&amp;sektion=5&amp;format=html">devfs(5)</a>, os links criados manualmente não persistirão após a reinicialização do sistema. Para recriar o link simbólico automaticamente quando o sistema inicializar, adicione a seguinte linha ao arquivo <span class=filename>/etc/devfs.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>link cd0 dvd</pre></div></div><div class=paragraph><p>A decriptografia do DVD invoca certas funções que exigem permissão de gravação para o dispositivo DVD.</p></div><div class=paragraph><p>Para melhorar a interface de memória compartilhada do Xorg, recomenda-se aumentar os valores dessas variáveis <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a>:</p></div><div class="literalblock programlisting"><div class=content><pre>kern.ipc.shmmax=67108864
kern.ipc.shmall=32768</pre></div></div><div class=sect3><h4 id=video-interface>7.4.1. Determinando os Recursos de Vídeo<a class=anchor href=#video-interface></a></h4><div class=paragraph><p>Existem várias maneiras possíveis de exibir vídeo no Xorg e o que funciona é, em grande parte, dependente de hardware. Cada método descrito abaixo terá qualidade variável em diferentes hardwares.</p></div><div class=paragraph><p>Interfaces de vídeo comuns incluem:</p></div><div class="olist arabic"><ol class=arabic><li><p>Xorg: saída normal usando memória compartilhada.</p></li><li><p>XVideo: uma extensão para a interface Xorg que permite que o vídeo seja exibido diretamente em objetos que podem ser desenhados através de uma aceleração especial. Esta extensão oferece reprodução de boa qualidade, mesmo em máquinas de baixo custo. A próxima seção descreve como determinar se esta extensão está sendo executada.</p></li><li><p>SDL: Simple Directmedia Layer é uma camada de portabilidade para muitos sistemas operacionais, permitindo o desenvolvimento de aplicativos multiplataforma que fazem uso eficiente de som e gráficos. O SDL fornece uma abstração de baixo nível para o hardware, que às vezes pode ser mais eficiente que a interface do Xorg. No FreeBSD, o SDL pode ser instalado usando o pacote ou port <a class=package href=https://cgit.freebsd.org/ports/tree/devel/sdl20/>devel/sdl20</a>.</p></li><li><p>DGA: Direct Graphics Access é uma extensão do Xorg que permite que um programa contorne o servidor Xorg e altere diretamente o quadro de buffer. Como ele depende de um mapeamento de memória de baixo nível, os programas que o utilizam devem ser executados como <code>root</code>. A extensão DGA pode ser testada e comparada usando <a href="https://man.freebsd.org/cgi/man.cgi?query=dga&amp;sektion=1&amp;format=html">dga(1)</a>. Quando o <code>dga</code> está em execução, ele altera as cores do display sempre que uma tecla é pressionada. Para sair, pressione <kbd>q</kbd>.</p></li><li><p>SVGAlib: uma camada gráfica de console de baixo nível.</p></li></ol></div><div class=sect4><h5 id=video-interface-xvideo>7.4.1.1. XVideo<a class=anchor href=#video-interface-xvideo></a></h5><div class=paragraph><p>Para verificar se esta extensão está em execução, use <code>xvinfo</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% xvinfo</code></pre></div></div><div class=paragraph><p>O XVideo é suportado pela placa de vídeo se o resultado for semelhante a:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>X-Video Extension version 2.2
  screen <span class=c>#0</span>
  Adaptor <span class=c>#0: &#34;Savage Streams Engine&#34;</span>
    number of ports: 1
    port base: 43
    operations supported: PutImage
    supported visuals:
      depth 16, visualID 0x22
      depth 16, visualID 0x23
    number of attributes: 5
      <span class=s2>&#34;XV_COLORKEY&#34;</span> <span class=o>(</span>range 0 to 16777215<span class=o>)</span>
              client settable attribute
              client gettable attribute <span class=o>(</span>current value is 2110<span class=o>)</span>
      <span class=s2>&#34;XV_BRIGHTNESS&#34;</span> <span class=o>(</span>range <span class=nt>-128</span> to 127<span class=o>)</span>
              client settable attribute
              client gettable attribute <span class=o>(</span>current value is 0<span class=o>)</span>
      <span class=s2>&#34;XV_CONTRAST&#34;</span> <span class=o>(</span>range 0 to 255<span class=o>)</span>
              client settable attribute
              client gettable attribute <span class=o>(</span>current value is 128<span class=o>)</span>
      <span class=s2>&#34;XV_SATURATION&#34;</span> <span class=o>(</span>range 0 to 255<span class=o>)</span>
              client settable attribute
              client gettable attribute <span class=o>(</span>current value is 128<span class=o>)</span>
      <span class=s2>&#34;XV_HUE&#34;</span> <span class=o>(</span>range <span class=nt>-180</span> to 180<span class=o>)</span>
              client settable attribute
              client gettable attribute <span class=o>(</span>current value is 0<span class=o>)</span>
    maximum XvImage size: 1024 x 1024
    Number of image formats: 7
      <span class=nb>id</span>: 0x32595559 <span class=o>(</span>YUY2<span class=o>)</span>
        guid: 59555932-0000-0010-8000-00aa00389b71
        bits per pixel: 16
        number of planes: 1
        <span class=nb>type</span>: YUV <span class=o>(</span>packed<span class=o>)</span>
      <span class=nb>id</span>: 0x32315659 <span class=o>(</span>YV12<span class=o>)</span>
        guid: 59563132-0000-0010-8000-00aa00389b71
        bits per pixel: 12
        number of planes: 3
        <span class=nb>type</span>: YUV <span class=o>(</span>planar<span class=o>)</span>
      <span class=nb>id</span>: 0x30323449 <span class=o>(</span>I420<span class=o>)</span>
        guid: 49343230-0000-0010-8000-00aa00389b71
        bits per pixel: 12
        number of planes: 3
        <span class=nb>type</span>: YUV <span class=o>(</span>planar<span class=o>)</span>
      <span class=nb>id</span>: 0x36315652 <span class=o>(</span>RV16<span class=o>)</span>
        guid: 52563135-0000-0000-0000-000000000000
        bits per pixel: 16
        number of planes: 1
        <span class=nb>type</span>: RGB <span class=o>(</span>packed<span class=o>)</span>
        depth: 0
        red, green, blue masks: 0x1f, 0x3e0, 0x7c00
      <span class=nb>id</span>: 0x35315652 <span class=o>(</span>RV15<span class=o>)</span>
        guid: 52563136-0000-0000-0000-000000000000
        bits per pixel: 16
        number of planes: 1
        <span class=nb>type</span>: RGB <span class=o>(</span>packed<span class=o>)</span>
        depth: 0
        red, green, blue masks: 0x1f, 0x7e0, 0xf800
      <span class=nb>id</span>: 0x31313259 <span class=o>(</span>Y211<span class=o>)</span>
        guid: 59323131-0000-0010-8000-00aa00389b71
        bits per pixel: 6
        number of planes: 3
        <span class=nb>type</span>: YUV <span class=o>(</span>packed<span class=o>)</span>
      <span class=nb>id</span>: 0x0
        guid: 00000000-0000-0000-0000-000000000000
        bits per pixel: 0
        number of planes: 0
        <span class=nb>type</span>: RGB <span class=o>(</span>packed<span class=o>)</span>
        depth: 1
        red, green, blue masks: 0x0, 0x0, 0x0</code></pre></div></div><div class=paragraph><p>Os formatos listados, como YUV2 e YUV12, não estão presentes em todas as implementações do XVideo e sua ausência pode atrapalhar alguns players.</p></div><div class=paragraph><p>Se o resultado, ao invés disso, se parecer com:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>X-Video Extension version 2.2
screen 0
no adaptors present</code></pre></div></div><div class=paragraph><p>O XVideo provavelmente não é compatível com a placa. Isso significa que será mais difícil para o monitor atender às demandas computacionais de renderização de vídeo, dependendo da placa de vídeo e do processador.</p></div></div></div><div class=sect3><h4 id=video-ports>7.4.2. Ports e Pacotes Lidando com Vídeo<a class=anchor href=#video-ports></a></h4><div class=paragraph><p>Esta seção apresenta alguns dos softwares disponíveis na Coleção de Ports do FreeBSD, que podem ser usados para reprodução de vídeo.</p></div><div class=sect4><h5 id=video-mplayer>7.4.2.1. MPlayer e MEncoder<a class=anchor href=#video-mplayer></a></h5><div class=paragraph><p>O MPlayer é um reprodutor de vídeo em linha de comando com uma interface gráfica opcional que visa oferecer velocidade e flexibilidade. Outros front-ends gráficos para o MPlayer estão disponíveis na Coleção de Ports do FreeBSD.</p></div><div class=paragraph><p>O MPlayer pode ser instalado usando o pacote ou port <a class=package href=https://cgit.freebsd.org/ports/tree/multimedia/mplayer/>multimedia/mplayer</a>. Várias opções de compilação estão disponíveis e uma variedade de verificações de hardware ocorre durante o processo de compilação. Por esses motivos, alguns usuários preferem compilar um port ao invés de instalar o pacote.</p></div><div class=paragraph><p>Ao compilar o port, as opções do menu devem ser revisadas para determinar o tipo de suporte a ser compilado no port. Se uma opção não estiver selecionada, o MPlayer não poderá exibir esse tipo de formato de vídeo. Use as setas e a barra de espaço para selecionar os formatos necessários. Quando terminar, pressione <kbd>Enter</kbd> para continuar a compilação e instalação do port.</p></div><div class=paragraph><p>Por padrão, o pacote ou port construirá o utilitário de linha de comando <code>mplayer</code> e o utilitário gráfico <code>gmplayer</code>. Para codificar vídeos, compile o port <a class=package href=https://cgit.freebsd.org/ports/tree/multimedia/mencoder/>multimedia/mencoder</a>. Devido a restrições de licenciamento, um pacote não está disponível para o MEncoder.</p></div><div class=paragraph><p>A primeira vez que o MPlayer for executado, ele criará um arquivo <span class=filename>~/.mplayer</span> no diretório pessoal do usuário. Esse subdiretório contém versões padrões dos arquivos de configurações específicos do usuário.</p></div><div class=paragraph><p>Esta seção descreve apenas alguns usos comuns. Consulte o mplayer(1) para uma descrição completa de suas inúmeras opções.</p></div><div class=paragraph><p>Para reproduzir o arquivo <span class=filename>testfile.avi</span>, especifique as interfaces de vídeo com <code>-vo</code>, conforme mostrado nos exemplos a seguir:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% mplayer <span class=nt>-vo</span> xv testfile.avi</code></pre></div></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% mplayer <span class=nt>-vo</span> sdl testfile.avi</code></pre></div></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% mplayer <span class=nt>-vo</span> x11 testfile.avi</code></pre></div></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mplayer -vo dga testfile.avi</span></code></pre></div></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mplayer -vo &#39;sdl:dga&#39; testfile.avi</span></code></pre></div></div><div class=paragraph><p>Vale a pena tentar todas essas opções, pois seu relativo desempenho depende de muitos fatores e varia significativamente com o hardware.</p></div><div class=paragraph><p>Para reproduzir um DVD, substitua <span class=filename>testfile.avi</span> por <code>dvd://<em>N</em> -dvd-device <em>DEVICE</em></code>, em que <em>N</em> é o número do título a ser reproduzido e <em>DEVICE</em> é o nó do dispositivo para o DVD. Por exemplo, para reproduzir o filme 3 de <span class=filename>/dev/dvd</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mplayer -vo xv dvd://3 -dvd-device /dev/dvd</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>O dispositivo padrão de DVD pode ser definido durante a construção do port MPlayer incluindo a opção <code>WITH_DVD_DEVICE=/path/to/desired/device</code>. Por padrão, o dispositivo é <span class=filename>/dev/cd0</span>. Mais detalhes podem ser encontrados no <span class=filename>Makefile.options</span> do port.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Para parar, pausar, avançar e assim por diante, use uma tecla de atalho. Para ver a lista de atalhos de teclado, execute <code>mplayer -h</code> ou leia o mplayer (1).</p></div><div class=paragraph><p>Opções de reprodução adicionais incluem <code>-fs -zoom</code>, que ativa o modo de tela cheia e <code>-framedrop</code>, o que ajuda no desempenho.</p></div><div class=paragraph><p>Cada usuário pode adicionar opções comumente usadas ao seu <span class=filename>~/.mplayer/config</span> assim:</p></div><div class="literalblock programlisting"><div class=content><pre>vo=xv
fs=yes
zoom=yes</pre></div></div><div class=paragraph><p>O <code>mplayer</code> pode ser usado para copiar um filme de DVD para um arquivo <span class=filename>.vob</span>. Para gravar o filme em um segundo DVD:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mplayer -dumpstream -dumpfile out.vob dvd://2 -dvd-device /dev/dvd</span></code></pre></div></div><div class=paragraph><p>O arquivo de saída, <span class=filename>out.vob</span>, estará no formato MPEG.</p></div><div class=paragraph><p>Qualquer pessoa que deseje obter um alto nível de experiência com vídeo UNIX™ deve consultar <a href=http://www.mplayerhq.hu/DOCS/>mplayerhq.hu/DOCS</a>. Como é tecnicamente informativa, esta documentação deve ser considerada como leitura obrigatória antes de enviar qualquer relatório de bug.</p></div><div class=paragraph><p>Antes de usar o <code>mencoder</code>, é interessante familiarizar-se com as opções descritas em <a href=http://www.mplayerhq.hu/DOCS/HTML/en/mencoder.html>mplayerhq.hu/DOCS/HTML/en/mencoder.html</a>. Existem inúmeras maneiras de melhorar a qualidade, diminuir a taxa de bits e alterar os formatos, e algumas dessas opções podem fazer a diferença entre bom ou mau desempenho. Combinações impróprias de opções de linha de comando podem produzir arquivos de saída que não podem ser reproduzidos até mesmo por <code>mplayer</code>.</p></div><div class=paragraph><p>Aqui está um exemplo de uma cópia simples:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% mencoder input.avi <span class=nt>-oac</span> copy <span class=nt>-ovc</span> copy <span class=nt>-o</span> output.avi</code></pre></div></div><div class=paragraph><p>Para copiar para um arquivo, use <code>-dumpfile</code> com o <code>mplayer</code>.</p></div><div class=paragraph><p>Para converter <span class=filename>input.avi</span> para o codec MPEG4 com codificação de áudio MPEG3, primeiro instale o port <a class=package href=https://cgit.freebsd.org/ports/tree/audio/lame/>audio/lame</a>. Devido a restrições de licenciamento, um pacote não está disponível. Uma vez instalado, digite:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% mencoder input.avi <span class=nt>-oac</span> mp3lame <span class=nt>-lameopts</span> <span class=nv>br</span><span class=o>=</span>192 <span class=se>\</span>
	 <span class=nt>-ovc</span> lavc <span class=nt>-lavcopts</span> <span class=nv>vcodec</span><span class=o>=</span>mpeg4:vhq <span class=nt>-o</span> output.avi</code></pre></div></div><div class=paragraph><p>Isso produzirá uma saída reproduzível por aplicativos como <code>mplayer</code> e <code>xine</code>.</p></div><div class=paragraph><p><span class=filename>input.avi</span> pode ser substituído por <code>dvd://1 -dvd-device /dev/dvd</code> e executado como <code>root</code> para recodificar um filme de DVD diretamente. Como pode levar algumas tentativas para obter o resultado desejado, recomenda-se gravar o arquivo de um filme e trabalhar nele.</p></div></div><div class=sect4><h5 id=video-xine>7.4.2.2. O Player (reprodutor) de Vídeo xine<a class=anchor href=#video-xine></a></h5><div class=paragraph><p>O xine é um reprodutor de vídeo com uma biblioteca base reutilizável e um executável modular que pode ser estendido com plug-ins. Pode ser instalado usando o pacote ou port <a class=package href=https://cgit.freebsd.org/ports/tree/multimedia/xine/>multimedia/xine</a>.</p></div><div class=paragraph><p>Na prática, o xine requer uma CPU rápida com uma placa de vídeo rápida ou suporte para a extensão XVideo. O player de vídeo xine apresenta melhor desempenho nas interfaces XVideo.</p></div><div class=paragraph><p>Por padrão, o player xine inicia uma interface gráfica com o usuário. Os menus podem então ser usados para abrir um arquivo específico.</p></div><div class=paragraph><p>Alternativamente, o xine pode ser executado a partir da linha de comando, especificando o nome do arquivo a ser reproduzido:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% xine <span class=nt>-g</span> <span class=nt>-p</span> mymovie.avi</code></pre></div></div><div class=paragraph><p>Consulte <a href=http://www.xine-project.org/faq>xine-project.org/faq</a> para mais informações e dicas de solução de problemas.</p></div></div><div class=sect4><h5 id=video-ports-transcode>7.4.2.3. As Utilidades do Transcode<a class=anchor href=#video-ports-transcode></a></h5><div class=paragraph><p>O Transcode fornece um conjunto de ferramentas para recodificar arquivos de vídeo e áudio. O Transcode pode ser usado para mesclar arquivos de vídeo ou reparar arquivos quebrados usando ferramentas de linha de comando com interfaces de fluxo stdin/stdout.</p></div><div class=paragraph><p>No FreeBSD, o Transcode pode ser instalado usando o pacote ou port <a class=package href=https://cgit.freebsd.org/ports/tree/multimedia/transcode/>multimedia/transcode</a>. Muitos usuários preferem compilar o port, pois fornece um menu de opções de compilação para especificar o suporte e os codecs a serem compilados. Se uma opção não for selecionada, o Transcode não poderá codificar esse formato. Use as setas e a barra de espaço para selecionar os formatos necessários. Quando terminar, pressione <kbd>Enter</kbd> para continuar a compilação e instalação do port.</p></div><div class=paragraph><p>Este exemplo demonstra como converter um arquivo DivX em um arquivo PAL MPEG-1 (PAL VCD):</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% transcode <span class=nt>-i</span> input.avi <span class=nt>-V</span> <span class=nt>--export_prof</span> vcd-pal <span class=nt>-o</span> output_vcd
% mplex <span class=nt>-f</span> 1 <span class=nt>-o</span> output_vcd.mpg output_vcd.m1v output_vcd.mpa</code></pre></div></div><div class=paragraph><p>O arquivo MPEG resultante, <span class=filename>output_vcd.mpg</span>, está pronto para ser executado com o MPlayer. O arquivo pode ser gravado em uma mídia (CD), para criar um CD de vídeo usando um utilitário como <a class=package href=https://cgit.freebsd.org/ports/tree/multimedia/vcdimager/>multimedia/vcdimager</a> ou <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/cdrdao/>sysutils/cdrdao</a>.</p></div><div class=paragraph><p>Além da página de manual do <code>transcode</code>, consulte <a href=http://www.transcoding.org/cgi-bin/transcode>transcoding.org/cgi-bin/transcode</a> para mais informações e exemplos.</p></div></div></div></div><div class=sect2><h3 id=tvcard>7.5. Placas de TV<a class=anchor href=#tvcard></a></h3><div class=paragraph><p>As placas de TV podem ser usadas para assistir à transmissão ou à TV a cabo em um computador. A maioria das placas aceitam vídeo composto por meio de uma entrada RCA ou S-video e algumas placas incluem um sintonizador de rádio FM.</p></div><div class=paragraph><p>O FreeBSD fornece suporte para placas de TV baseadas em PCI usando um chip de captura de vídeo Brooktree Bt848/849/878/879 com o driver <a href="https://man.freebsd.org/cgi/man.cgi?query=bktr&amp;sektion=4&amp;format=html">bktr(4)</a>. Este driver suporta a maioria das placas de vídeo Pinnacle PCTV. Antes de comprar uma placa de TV, consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=bktr&amp;sektion=4&amp;format=html">bktr(4)</a> para obter uma lista dos sintonizadores suportados.</p></div><div class=sect3><h4 id=_carregando_o_driver>7.5.1. Carregando o Driver<a class=anchor href=#_carregando_o_driver></a></h4><div class=paragraph><p>Para usar a placa, o driver <a href="https://man.freebsd.org/cgi/man.cgi?query=bktr&amp;sektion=4&amp;format=html">bktr(4)</a> deve ser carregado. Para automatizar isso no momento da inicialização, adicione a seguinte linha ao arquivo <span class=filename>/boot/loader.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>bktr_load=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Como alternativa, pode-se compilar estaticamente o suporte para a placa de TV em um kernel personalizado. Nesse caso, adicione as seguintes linhas ao arquivo de configuração do kernel personalizado:</p></div><div class="literalblock programlisting"><div class=content><pre>device	 bktr
device	iicbus
device	iicbb
device	smbus</pre></div></div><div class=paragraph><p>Esses dispositivos adicionais são necessários, pois os componentes da placa são interconectados por meio de um barramento I2C. Em seguida, crie e instale um novo kernel.</p></div><div class=paragraph><p>Para testar se o sintonizador foi detectado corretamente, reinicialize o sistema. A placa de TV deve aparecer nas mensagens de inicialização, conforme mostrado neste exemplo:</p></div><div class="literalblock programlisting"><div class=content><pre>bktr0: &lt;BrookTree 848A&gt; mem 0xd7000000-0xd7000fff irq 10 at device 10.0 on pci0
iicbb0: &lt;I2C bit-banging driver&gt; on bti2c0
iicbus0: &lt;Philips I2C bus&gt; on iicbb0 master-only
iicbus1: &lt;Philips I2C bus&gt; on iicbb0 master-only
smbus0: &lt;System Management Bus&gt; on bti2c0
bktr0: Pinnacle/Miro TV, Philips SECAM tuner.</pre></div></div><div class=paragraph><p>As mensagens serão diferentes de acordo com o hardware. Se necessário, é possível substituir alguns dos parâmetros detectados usando <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> ou opções de configuração de kernel personalizadas. Por exemplo, para forçar o sintonizador a usar um sintonizador SECAM da Philips, adicione a seguinte linha a um arquivo de configuração de kernel personalizado:</p></div><div class="literalblock programlisting"><div class=content><pre>options OVERRIDE_TUNER=6</pre></div></div><div class=paragraph><p>ou, use <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl hw.bt848.tuner=6</span></code></pre></div></div><div class=paragraph><p>Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=bktr&amp;sektion=4&amp;format=html">bktr(4)</a> para obter uma descrição disponível dos parâmetros do <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> e opções do kernel.</p></div></div><div class=sect3><h4 id=_aplicações_úteis>7.5.2. Aplicações Úteis<a class=anchor href=#_aplicações_úteis></a></h4><div class=paragraph><p>Para usar a placa de TV, instale um dos seguintes aplicativos:</p></div><div class=ulist><ul><li><p><a class=package href=https://cgit.freebsd.org/ports/tree/multimedia/fxtv/>multimedia/fxtv</a> oferece recursos de captura de imagem/áudio/vídeo numa transmissão de TV no monitor do computador.</p></li><li><p>O <a class=package href=https://cgit.freebsd.org/ports/tree/multimedia/xawtv/>multimedia/xawtv</a> é outro aplicativo de TV com recursos semelhantes.</p></li><li><p>O <a class=package href=https://cgit.freebsd.org/ports/tree/audio/xmradio/>audio/xmradio</a> fornece uma aplicação para usar o sintonizador de rádio FM de uma placa de TV.</p></li></ul></div><div class=paragraph><p>Mais aplicações estão disponíveis na Coleção de Ports do FreeBSD.</p></div></div><div class=sect3><h4 id=_solução_de_problemas>7.5.3. Solução de problemas<a class=anchor href=#_solução_de_problemas></a></h4><div class=paragraph><p>Se forem encontrados problemas com a placa de TV, verifique se o chip de captura de vídeo e o sintonizador são compatíveis com <a href="https://man.freebsd.org/cgi/man.cgi?query=bktr&amp;sektion=4&amp;format=html">bktr(4)</a> e que as opções corretas de configuração foram usadas. Para obter mais suporte ou para fazer perguntas sobre as placas de TV suportadas, consulte a lista de discussão <a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-multimedia>freebsd-multimedia</a>.</p></div></div></div><div class=sect2><h3 id=mythtv>7.6. MythTV<a class=anchor href=#mythtv></a></h3><div class=paragraph><p>MythTV é um popular aplicativo de gravação de vídeo pessoal (PVR). Esta seção demonstra como instalar e configurar o MythTV no FreeBSD. Consulte <a href=http://www.mythtv.org/wiki/>mythtv.org/wiki</a> para mais informações sobre como usar o MythTV.</p></div><div class=paragraph><p>MythTV requer um frontend e um backend. Esses componentes podem ser instalados no mesmo sistema ou em máquinas diferentes.</p></div><div class=paragraph><p>O frontend pode ser instalado no FreeBSD usando o pacote ou port <a class=package href=https://cgit.freebsd.org/ports/tree/multimedia/mythtv-frontend/>multimedia/mythtv-frontend</a>. O Xorg também deve ser instalado e configurado conforme descrito em <a href=./#x11>O sistema X Window</a>. Idealmente, este sistema tem uma placa de vídeo que suporta Compensação de Movimento de X-Vídeo (XvMC) e, opcionalmente, um controle remoto compatível com o Controle Remoto Infravermelho do Linux (LIRC).</p></div><div class=paragraph><p>Para instalar o backend e o frontend no FreeBSD, use o pacote ou port <a class=package href=https://cgit.freebsd.org/ports/tree/multimedia/mythtv/>multimedia/mythtv</a>. Um servidor de banco de dados MySQL™ também é necessário e deve ser instalado automaticamente como uma dependência. Opcionalmente, este sistema deve ter uma placa sintonizadora e armazenamento suficiente para armazenar os dados gravados.</p></div><div class=sect3><h4 id=_hardware>7.6.1. Hardware<a class=anchor href=#_hardware></a></h4><div class=paragraph><p>O MythTV usa o Video for Linux (V4L) para acessar dispositivos de entrada de vídeo, como codificadores e sintonizadores. No FreeBSD, o MythTV funciona melhor com placas USB DVB-S/C/T, pois são bem suportadas pelo pacote <a class=package href=https://cgit.freebsd.org/ports/tree/multimedia/webcamd/>multimedia/webcamd</a> ou pelo port que forneça uma aplicação V4L userland. Qualquer placa de transmissão de vídeo digital (DVB) suportada pelo webcamd deve funcionar com o MythTV. Uma lista de placas suportadas conhecidas pode ser encontrada em <a href=https://wiki.freebsd.org/WebcamCompat>wiki.freebsd.org/WebcamCompat</a>. Drivers também estão disponíveis para placas Hauppauge nos ports <a class=package href=https://cgit.freebsd.org/ports/tree/multimedia/pvr250/>multimedia/pvr250</a> e <a class=package href=https://cgit.freebsd.org/ports/tree/multimedia/pvrxxx/>multimedia/pvrxxx</a>, mas eles fornecem uma interface de driver não padronizados que não funcionam com versões do MythTV posteriores à 0.23. Devido a restrições de licenciamento, nenhum pacote está disponível e esses dois ports devem ser compilados.</p></div><div class=paragraph><p>A página <a href=https://wiki.freebsd.org/HTPC>wiki.freebsd.org/HTPC</a> contém uma lista de todos os drivers DVB disponíveis.</p></div></div><div class=sect3><h4 id=_configurando_o_backend_mythtv>7.6.2. Configurando o Backend MythTV<a class=anchor href=#_configurando_o_backend_mythtv></a></h4><div class=paragraph><p>Para instalar o MythTV usando pacotes binários:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install mythtv</span></code></pre></div></div><div class=paragraph><p>Como alternativa, para instalar a partir da Coleção de Ports:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/multimedia/mythtv</span>
<span class=c># make install</span></code></pre></div></div><div class=paragraph><p>Uma vez instalado, configure o banco de dados do MythTV:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mysql -uroot -p &lt; /usr/local/shared/mythtv/database/mc.sql</span></code></pre></div></div><div class=paragraph><p>Em seguida, configure o backend:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mythtv-setup</span></code></pre></div></div><div class=paragraph><p>Finalmente, inicie o backend:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysrc mythbackend_enable=yes</span>
<span class=c># service mythbackend start</span></code></pre></div></div></div></div><div class=sect2><h3 id=scanners>7.7. Scanners de Imagem<a class=anchor href=#scanners></a></h3><div class=paragraph><p>No FreeBSD, o acesso aos scanners de imagens é fornecido pelo SANE (Scanner Access Now Easy), que está disponível na Coleção de Ports do FreeBSD. O SANE também usará alguns drivers de dispositivos do FreeBSD para fornecer acesso ao hardware do scanner.</p></div><div class=paragraph><p>O FreeBSD suporta os scanners SCSI e USB. Dependendo da interface do scanner, são necessários drivers de dispositivos diferentes. Certifique-se de que o scanner seja suportado pelo SANE antes de executar qualquer configuração. Consulte <a href=http://www.sane-project.org/sane-supported-devices.html>http://www.sane-project.org/sane-supported-devices.html</a> para obter mais informações sobre os scanners suportados.</p></div><div class=paragraph><p>Este capítulo descreve como determinar se o scanner foi detectado pelo FreeBSD. Em seguida, ele fornece uma visão geral de como configurar e usar o SANE em um sistema FreeBSD.</p></div><div class=sect3><h4 id=scanners-kernel-usb>7.7.1. Verificando o Scanner<a class=anchor href=#scanners-kernel-usb></a></h4><div class=paragraph><p>O kernel <span class=filename>GENERIC</span> inclui os drivers de dispositivos necessários para suportar scanners USB. Usuários com um kernel personalizado devem garantir que as seguintes linhas estejam presentes no arquivo de configuração do kernel personalizado:</p></div><div class="literalblock programlisting"><div class=content><pre>device usb
device uhci
device ohci
device ehci
device xhci</pre></div></div><div class=paragraph><p>Para verificar se o scanner USB foi detectado, conecte-o e execute o comando <code>dmesg</code>, sendo então possível ver se o scanner aparece no buffer de mensagens do sistema. Em caso afirmativo, deve ser exibida uma mensagem semelhante a esta:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>ugen0.2: &lt;EPSON&gt; at usbus0</code></pre></div></div><div class=paragraph><p>Neste exemplo, um scanner EPSON Perfection™ 1650 USB foi detectado em <span class=filename>/dev/ugen0.2</span>.</p></div><div class=paragraph><p>Se o scanner usar uma interface SCSI, é importante saber qual placa controladora SCSI será usada. Dependendo do chipset SCSI, um arquivo de configuração do kernel personalizado pode ser necessário. O kernel <span class=filename>GENERIC</span> suporta os controladores SCSI mais comuns. Consulte <span class=filename>/usr/src/sys/conf/NOTES</span> para determinar a linha correta a ser adicionada a um arquivo de configuração de kernel personalizado. Além do driver de adaptador SCSI, as seguintes linhas são necessárias em um arquivo de configuração de kernel personalizado:</p></div><div class="literalblock programlisting"><div class=content><pre>device scbus
device pass</pre></div></div><div class=paragraph><p>Verifique se o dispositivo é exibido no buffer de mensagens do sistema:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>pass2 at aic0 bus 0 target 2 lun 0
pass2: &lt;AGFA SNAPSCAN 600 1.10&gt; Fixed Scanner SCSI-2 device
pass2: 3.300MB/s transfers</code></pre></div></div><div class=paragraph><p>Se o scanner não foi ligado na inicialização do sistema, ainda é possível forçar manualmente a detecção executando uma varredura de barramento SCSI com o comando <code>camcontrol</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># camcontrol rescan all</span>
Re-scan of bus 0 was successful
Re-scan of bus 1 was successful
Re-scan of bus 2 was successful
Re-scan of bus 3 was successful</code></pre></div></div><div class=paragraph><p>O scanner deve agora aparecer na lista de dispositivos SCSI:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># camcontrol devlist</span>
&lt;IBM DDRS-34560 S97B&gt;              at scbus0 target 5 lun 0 <span class=o>(</span>pass0,da0<span class=o>)</span>
&lt;IBM DDRS-34560 S97B&gt;              at scbus0 target 6 lun 0 <span class=o>(</span>pass1,da1<span class=o>)</span>
&lt;AGFA SNAPSCAN 600 1.10&gt;           at scbus1 target 2 lun 0 <span class=o>(</span>pass3<span class=o>)</span>
&lt;PHILIPS CDD3610 CD-R/RW 1.00&gt;     at scbus2 target 0 lun 0 <span class=o>(</span>pass2,cd0<span class=o>)</span></code></pre></div></div><div class=paragraph><p>Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=scsi&amp;sektion=4&amp;format=html">scsi(4)</a> e <a href="https://man.freebsd.org/cgi/man.cgi?query=camcontrol&amp;sektion=8&amp;format=html">camcontrol(8)</a> para mais detalhes sobre dispositivos SCSI no FreeBSD.</p></div></div><div class=sect3><h4 id=_configuração_do_sane>7.7.2. Configuração do SANE<a class=anchor href=#_configuração_do_sane></a></h4><div class=paragraph><p>O sistma SANE provê o acesso ao scanner via backends (<a class=package href=https://cgit.freebsd.org/ports/tree/graphics/sane-backends/>graphics/sane-backends</a>). Consulte <a href=http://www.sane-project.org/sane-supported-devices.html>http://www.sane-project.org/sane-supported-devices.html</a> para determinar qual backend suporta o scanner. Uma interface gráfica é fornecida por aplicações terceiras como Kooka (<a class=package href=https://cgit.freebsd.org/ports/tree/graphics/kooka/>graphics/kooka</a>) ou XSane (<a class=package href=https://cgit.freebsd.org/ports/tree/graphics/xsane/>graphics/xsane</a>). Os backends do SANE são suficientes para testar o scanner.</p></div><div class=paragraph><p>Para instalar os backends do pacote binário:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install sane-backends</span></code></pre></div></div><div class=paragraph><p>Alternativamente, para instalar a partir da Coleção de Ports</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/graphics/sane-backends</span>
<span class=c># make install clean</span></code></pre></div></div><div class=paragraph><p>Depois de instalar o pacote ou port <a class=package href=https://cgit.freebsd.org/ports/tree/graphics/sane-backends/>graphics/sane-backends</a>, use o comando <code>sane-find-scanner</code> para verificar a detecção do scanner pelo sistema SANE:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sane-find-scanner -q</span>
found SCSI scanner <span class=s2>&#34;AGFA SNAPSCAN 600 1.10&#34;</span> at /dev/pass3</code></pre></div></div><div class=paragraph><p>A saída deve mostrar o tipo de interface do scanner e o nó do dispositivo usado para conectar o scanner ao sistema. O fornecedor e o modelo do produto podem ou não aparecer.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Alguns scanners USB exigem que o firmware seja carregado. Consulte sane-find-scanner(1) e sane(7) para mais detalhes.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Em seguida, verifique se o scanner será identificado por uma interface de digitalização. Os backends SANE incluem o comando <code>scanimage</code>, que pode ser usado para listar os dispositivos e realizar uma aquisição de imagens. Use a opção <code>-L</code> para listar os dispositivos do scanner. O primeiro exemplo é para um scanner SCSI e o segundo é para um scanner USB:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># scanimage -L</span>
device <span class=sb>`</span>snapscan:/dev/pass3<span class=s1>&#39; is a AGFA SNAPSCAN 600 flatbed scanner
# scanimage -L
device &#39;</span>epson2:libusb:000:002<span class=s1>&#39; is a Epson GT-8200 flatbed scanner</span></code></pre></div></div><div class=paragraph><p>Neste segundo exemplo,<code>epson2</code> é o nome do backend e <code>libusb:000:002</code> significa que <code>/dev/ugen0.2</code> é o dispositivo usado pelo scanner.</p></div><div class=paragraph><p>Se o comando <code>scanimage</code> não conseguir identificar o scanner, esta mensagem será exibida:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># scanimage -L</span>

No scanners were identified. If you were expecting something different,
check that the scanner is plugged <span class=k>in</span>, turned on and detected by the
sane-find-scanner tool <span class=o>(</span><span class=k>if </span>appropriate<span class=o>)</span><span class=nb>.</span> Please <span class=nb>read </span>the documentation
which came with this software <span class=o>(</span>README, FAQ, manpages<span class=o>)</span>.</code></pre></div></div><div class=paragraph><p>Se isso acontecer, edite o arquivo de configuração de backend em <span class=filename>/usr/local/etc/sane.d/</span> e defina o dispositivo de scanner usado. Por exemplo, se o modelo de scanner não detectado for um EPSON Perfection™ 1650 e usar o backend <code>epson2</code>, edite o arquivo <span class=filename>/usr/ local/etc/sane.d/epson2.conf</span>. Ao editar, adicione uma linha especificando a interface e o nó do dispositivo usado. Nesse caso, adicione a seguinte linha:</p></div><div class="literalblock programlisting"><div class=content><pre>usb /dev/ugen0.2</pre></div></div><div class=paragraph><p>Salve as edições e verifique se o scanner está identificado com o nome do back-end correto e com o nó do dispositivo:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># scanimage -L</span>
device <span class=s1>&#39;epson2:libusb:000:002&#39;</span> is a Epson GT-8200 flatbed scanner</code></pre></div></div><div class=paragraph><p>Depois que o comando <code>scanimage -L</code> identificar o scanner, a configuração estará completa e o scanner estará pronto para ser usado.</p></div><div class=paragraph><p>Embora o <code>scanimage</code> possa ser usado para realizar uma digitalização de imagem a partir da linha de comando, muitas vezes é preferível usar uma interface gráfica para executar o escaneamento. Aplicações como Kooka ou XSane são interfaces de digitalização populares. Eles oferecem recursos avançados, como vários modos de digitalização, correção de cores e digitalizações em lote. O XSane também pode ser usado como um plugin GIMP.</p></div></div><div class=sect3><h4 id=_permissões_do_scanner>7.7.3. Permissões do Scanner<a class=anchor href=#_permissões_do_scanner></a></h4><div class=paragraph><p>Para ter acesso ao scanner, o usuário precisa ler e gravar as permissões no nó do dispositivo usado pelo scanner. No exemplo anterior, o scanner USB usa o nó do dispositivo <span class=filename>/dev/ugen0.2</span> que é realmente um link simbólico para o nó do dispositivo real <span class=filename>/dev/usb/0.2.0</span>. O link simbólico e o nó do dispositivo pertencem, respectivamente, aos grupos <code>wheel</code> e <code>operator</code>. Adicionando o usuário a esses grupos, será permitido o acesso ao scanner, considera-se inseguro adicionar um usuário a <code>wheel</code>. Uma solução melhor é criar um grupo e tornar o dispositivo de scanner acessível aos membros desse grupo.</p></div><div class=paragraph><p>Este exemplo cria um grupo chamado <code><em>usb</em></code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pw groupadd usb</span></code></pre></div></div><div class=paragraph><p>Então, crie um link simbólico para <span class=filename>/dev/ugen0.2</span> e o nó do dispositivo <span class=filename>/dev/usb/0.2.0</span> para ficarem acessíveis ao grupo <code>usb</code> com permissões de gravação <code>0660</code> ou <code>0664</code> adicionando as seguintes linhas ao <span class=filename>/etc/devfs.rules</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>[system=5]
add path ugen0.2 mode 0660 group usb
add path usb/0.2.0 mode 0666 group usb</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Acontece do nó do dispositivo mudar com a adição ou remoção de dispositivos, então você pode querer dar acesso a todos os dispositivos USB usando esse conjunto de regas:</p></div><div class="literalblock programlisting"><div class=content><pre>[system=5]
add path &#39;ugen*&#39; mode 0660 group usb
add path &#39;usb/*&#39; mode 0666 group usb</pre></div></div></td></tr></tbody></table></div><div class=paragraph><p>Finalmente, adicione os usuários a <code><em>usb</em></code> para permitir acesso ao scanner:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pw groupmod usb -m joe</span></code></pre></div></div><div class=paragraph><p>Para mais detalhes, consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=pw&amp;sektion=8&amp;format=html">pw(8)</a>.</p></div></div></div></div></div><div class=sect1><h2 id=kernelconfig>Capítulo 8. Configurando o kernel do FreeBSD<a class=anchor href=#kernelconfig></a></h2><div class=sectionbody><div class=sect2><h3 id=kernelconfig-synopsis>8.1. Sinopse<a class=anchor href=#kernelconfig-synopsis></a></h3><div class=paragraph><p>O kernel é o núcleo do sistema operacional do FreeBSD. Ele é responsável pelo gerenciamento de memória, aplicação de controles de segurança, rede, acesso ao disco e muito mais. Embora grande parte do FreeBSD seja configurável dinamicamente, ainda é necessário configurar e compilar um kernel personalizado ocasionalmente.</p></div><div class=paragraph><p>Depois de ler este capítulo, você saberá:</p></div><div class=ulist><ul><li><p>Quando compilar um kernel personalizado.</p></li><li><p>Como obter um inventário do hardware.</p></li><li><p>Como personalizar um arquivo de configuração do kernel.</p></li><li><p>Como usar o arquivo de configuração do kernel para criar e compilar um novo kernel.</p></li><li><p>Como instalar o novo kernel.</p></li><li><p>Como solucionar problemas se as coisas derem errado.</p></li></ul></div><div class=paragraph><p>Todos os comandos listados nos exemplos deste capítulo devem ser executados como <code>root</code>.</p></div></div><div class=sect2><h3 id=kernelconfig-custom-kernel>8.2. Por que compilar um kernel personalizado?<a class=anchor href=#kernelconfig-custom-kernel></a></h3><div class=paragraph><p>Tradicionalmente, o FreeBSD usava um kernel monolítico. O kernel era um grande programa, suportava uma lista fixa de dispositivos e, para mudar o comportamento do kernel, era preciso compilar e depois reinicializar em um novo kernel.</p></div><div class=paragraph><p>Hoje, a maior parte da funcionalidade do kernel do FreeBSD está contida em módulos que podem ser dinamicamente carregados e descarregados do kernel, conforme necessário. Isso permite que o kernel em execução se adapte imediatamente ao novo hardware e que novas funcionalidades sejam trazidas para o kernel. Isso é conhecido como um kernel modular.</p></div><div class=paragraph><p>Ocasionalmente, ainda é necessário executar a configuração do kernel estático. Às vezes, a funcionalidade necessária é tão ligada ao kernel que não pode ser carregada dinamicamente. Alguns ambientes de segurança impedem o carregamento e descarregamento de módulos do kernel e exigem que apenas a funcionalidade necessária seja estaticamente compilada no kernel.</p></div><div class=paragraph><p>Construir um kernel personalizado é muitas vezes um rito de passagem para usuários avançados do BSD. Este processo, embora consuma tempo, pode fornecer benefícios ao sistema FreeBSD. Ao contrário do kernel <span class=filename>GENERIC</span>, que deve suportar uma ampla gama de hardware, um kernel personalizado pode ser reduzido para fornecer suporte apenas para o hardware desse computador. Isso tem vários benefícios, tais como:</p></div><div class=ulist><ul><li><p>Tempo de inicialização mais rápido. Uma vez que o kernel irá verificar apenas o hardware existente no sistema, o tempo que o sistema leva para inicializar pode diminuir.</p></li><li><p>Diminuir o uso de memória. Um kernel personalizado geralmente usa menos memória que o kernel <span class=filename>GENERIC</span> ao omitir recursos e drivers de dispositivo que não são utilizados. Isso é importante porque o código do kernel permanece residente na memória física o tempo todo, impedindo que a memória seja usada pelos aplicativos. Por esse motivo, um kernel personalizado é útil em um sistema com uma pequena quantidade de RAM.</p></li><li><p>Suporte adicional de hardware. Um kernel personalizado pode adicionar suporte para dispositivos que não estão presentes no kernel <span class=filename>GENERIC</span>.</p></li></ul></div><div class=paragraph><p>Antes de criar um kernel personalizado, considere a razão para isso. Se houver necessidade de suporte para um hardware específico, ele já pode existir como um módulo.</p></div><div class=paragraph><p>Os módulos do kernel existem em <span class=filename>/boot/kernel</span> e podem ser dinamicamente carregados no kernel em execução usando o <a href="https://man.freebsd.org/cgi/man.cgi?query=kldload&amp;sektion=8&amp;format=html">kldload(8)</a>. A maioria dos drivers do kernel tem um módulo carregável e uma página de manual. Por exemplo, o driver Ethernet sem fio <a href="https://man.freebsd.org/cgi/man.cgi?query=ath&amp;sektion=4&amp;format=html">ath(4)</a> tem as seguintes informações em sua página de manual:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Como alternativa, para carregar o driver como um módulo no momento da inicialização, coloque o a seguinte linha no loader.conf<span class=o>(</span>5<span class=o>)</span>:

    <span class=nv>if_ath_load</span><span class=o>=</span><span class=s2>&#34;YES&#34;</span></code></pre></div></div><div class=paragraph><p>Adicionar <code>if_ath_load="YES"</code> ao <span class=filename>/boot/loader.conf</span> carregará este módulo dinamicamente no momento da inicialização.</p></div><div class=paragraph><p>Em alguns casos, não há nenhum módulo associado em <span class=filename>/boot/kernel</span>. Isso é verdade principalmente para certos subsistemas.</p></div></div><div class=sect2><h3 id=kernelconfig-devices>8.3. Encontrando o hardware do sistema<a class=anchor href=#kernelconfig-devices></a></h3><div class=paragraph><p>Antes de editar o arquivo de configuração do kernel, é recomendável realizar um inventário do hardware da máquina. Em um sistema de inicialização dupla, o inventário pode ser criado a partir do outro sistema operacional. Por exemplo, o Device Manager da Microsoft™ contém informações sobre os dispositivos instalados.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Algumas versões do Microsoft ™Windows™ têm um ícone System que pode ser usado para acessar o Device Manager.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Se o FreeBSD for o único sistema operacional instalado, use o <a href="https://man.freebsd.org/cgi/man.cgi?query=dmesg&amp;sektion=8&amp;format=html">dmesg(8)</a> para determinar o hardware que foi encontrado e listado durante a verificação de inicialização. A maioria dos drivers de dispositivos no FreeBSD tem uma página de manual que lista o hardware suportado pelo driver. Por exemplo, as seguintes linhas indicam que o driver <a href="https://man.freebsd.org/cgi/man.cgi?query=psm&amp;sektion=4&amp;format=html">psm(4)</a> encontrou um mouse:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>psm0: &lt;PS/2 Mouse&gt; irq 12 on atkbdc0
psm0: <span class=o>[</span>GIANT-LOCKED]
psm0: <span class=o>[</span>ITHREAD]
psm0: model Generic PS/2 mouse, device ID 0</code></pre></div></div><div class=paragraph><p>Como esse hardware existe, esse driver não deve ser removido de um arquivo de configuração de kernel personalizado.</p></div><div class=paragraph><p>Se a saída do <code>dmesg</code> não exibir os resultados da saída da verificação de inicialização, leia o conteúdo do <span class=filename>/var/run/dmesg.boot</span>.</p></div><div class=paragraph><p>Outra ferramenta para encontrar hardware é o <a href="https://man.freebsd.org/cgi/man.cgi?query=pciconf&amp;sektion=8&amp;format=html">pciconf(8)</a>, que fornece uma saída mais detalhada. Por exemplo:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% pciconf <span class=nt>-lv</span>
ath0@pci0:3:0:0:        <span class=nv>class</span><span class=o>=</span>0x020000 <span class=nv>card</span><span class=o>=</span>0x058a1014 <span class=nv>chip</span><span class=o>=</span>0x1014168c <span class=nv>rev</span><span class=o>=</span>0x01 <span class=nv>hdr</span><span class=o>=</span>0x00
    vendor     <span class=o>=</span> <span class=s1>&#39;Atheros Communications Inc.&#39;</span>
    device     <span class=o>=</span> <span class=s1>&#39;AR5212 Atheros AR5212 802.11abg wireless&#39;</span>
    class      <span class=o>=</span> network
    subclass   <span class=o>=</span> ethernet</code></pre></div></div><div class=paragraph><p>Esta saída mostra que o driver <span class=filename>ath</span> localizou um dispositivo Ethernet sem fio.</p></div><div class=paragraph><p>O sinalizador <code>-k</code> do <a href="https://man.freebsd.org/cgi/man.cgi?query=man&amp;sektion=1&amp;format=html">man(1)</a> pode ser usado para fornecer informações úteis. Por exemplo, ele pode ser usado para exibir uma lista de páginas de manual que contêm uma marca ou um nome de dispositivo específico:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># man -k Atheros</span>
ath<span class=o>(</span>4<span class=o>)</span>                   - Atheros IEEE 802.11 wireless network driver
ath_hal<span class=o>(</span>4<span class=o>)</span>               - Atheros Hardware Access Layer <span class=o>(</span>HAL<span class=o>)</span></code></pre></div></div><div class=paragraph><p>Depois que a lista de inventário de hardware for criada, consulte-a para garantir que os drivers para o hardware instalado não sejam removidos à medida que a configuração do kernel personalizado é editada.</p></div></div><div class=sect2><h3 id=kernelconfig-config>8.4. O Arquivo de Configuração<a class=anchor href=#kernelconfig-config></a></h3><div class=paragraph><p>Para criar um arquivo de configuração do kernel personalizado e compilar um kernel personalizado, a árvore de código-fonte completa do FreeBSD deve ser instalada primeira.</p></div><div class=paragraph><p>Se o <span class=filename>/usr/src/</span> não existir ou estiver vazio, o código-fonte não foi instalado. O fonte pode ser instalado usando o Subversion e as instruções em <a href=./#svn>Usando o Subversion</a>.</p></div><div class=paragraph><p>Depois que o código-fonte for instalado, revise o conteúdo do <span class=filename>/usr/src/sys</span>. Este diretório contém vários subdiretórios, incluindo aqueles que representam as seguintes arquiteturas suportadas: <span class=filename>amd64</span>, <span class=filename>i386</span>, <span class=filename>powerpc</span> e <span class=filename>sparc64</span>. Tudo dentro do diretório de uma arquitetura em particular lida apenas com essa arquitetura e o restante do código é código independente de máquina comum a todas as plataformas. Cada arquitetura suportada tem um subdiretório <span class=filename>conf</span> que contém o arquivo de configuração do kernel <span class=filename>GENERIC</span> para essa arquitetura.</p></div><div class=paragraph><p>Não faça edições no <span class=filename>GENERIC</span>. Em vez disso, copie o arquivo para um nome diferente e faça edições na cópia. A convenção é usar um nome do host com todas as letras maiúsculas. Ao manter várias máquinas FreeBSD com hardware diferente, é uma boa idéia nomeá-lo com o nome do host da máquina. Este exemplo cria uma cópia, denominada <span class=filename>MYKERNEL</span>, do arquivo de configuração <span class=filename>GENERIC</span> para a arquitetura <code>amd64</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/src/sys/amd64/conf</span>
<span class=c># cp GENERIC MYKERNEL</span></code></pre></div></div><div class=paragraph><p>O <span class=filename>MYKERNEL</span> agora pode ser personalizado com qualquer editor de texto ASCII. O editor padrão é o vi, embora um editor mais fácil para iniciantes, chamado ee, também seja instalado com o FreeBSD.</p></div><div class=paragraph><p>O formato do arquivo de configuração do kernel é simples. Cada linha contém uma palavra-chave que representa um dispositivo ou subsistema, um argumento e uma breve descrição. Qualquer texto depois de um <code><mark></mark></code> é considerado um comentário e ignorado. Para remover o suporte do kernel para um dispositivo ou subsistema, coloque um <code></code> no início da linha que representa esse dispositivo ou subsistema. Não adicione ou remova um <code>#</code> para qualquer linha que você não entenda.</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>É fácil remover o suporte para um dispositivo ou opção e acabar com um kernel quebrado. Por exemplo, se o driver <a href="https://man.freebsd.org/cgi/man.cgi?query=ata&amp;sektion=4&amp;format=html">ata(4)</a> for removido do arquivo de configuração do kernel, um sistema usando os drivers de disco ATA pode não inicializar. Em caso de dúvida, basta deixar o suporte no kernel.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Além das breves descrições fornecidas neste arquivo, descrições adicionais estão contidas no arquivo <span class=filename>NOTES</span>, o qual pode ser encontrado no mesmo diretório que o <span class=filename>GENERIC</span> para aquela arquitetura. Para opções independentes de arquitetura, consulte <span class=filename>/usr/src/sys/conf/NOTES</span>.</p></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Quando terminar de personalizar o arquivo de configuração do kernel, salve uma cópia de backup em um local fora do <span class=filename>/usr/src</span>.</p></div><div class=paragraph><p>Como alternativa, mantenha o arquivo de configuração do kernel em outro lugar e crie um link simbólico para o arquivo:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/src/sys/amd64/conf</span>
<span class=c># mkdir /root/kernels</span>
<span class=c># cp GENERIC /root/kernels/MYKERNEL</span>
<span class=c># ln -s /root/kernels/MYKERNEL</span></code></pre></div></div></td></tr></tbody></table></div><div class=paragraph><p>Uma diretiva <code>include</code> está disponível para uso em arquivos de configuração. Isso permite que outro arquivo de configuração seja incluído no arquivo atual, facilitando a manutenção de pequenas alterações em relação a um arquivo existente. Se apenas um pequeno número de opções ou drivers adicionais forem necessários, isso permitirá que um delta seja mantido com relação ao <span class=filename>GENERIC</span>, conforme mostrado neste exemplo:</p></div><div class="literalblock programlisting"><div class=content><pre>include GENERIC
ident MYKERNEL

options         IPFIREWALL
options         DUMMYNET
options         IPFIREWALL_DEFAULT_TO_ACCEPT
options         IPDIVER</pre></div></div><div class=paragraph><p>Usando este método, o arquivo de configuração local expressa as diferenças locais em relação ao kernel <span class=filename>GENERIC</span>. Conforme as atualizações são realizadas, os novos recursos adicionados ao <span class=filename>GENERIC</span> também serão adicionados ao kernel local, a menos que sejam especificamente evitados usando <code>nooptions</code> ou <code>nodevice</code>. Uma lista abrangente de diretivas de configuração e suas descrições pode ser encontrada em <a href="https://man.freebsd.org/cgi/man.cgi?query=config&amp;sektion=5&amp;format=html">config(5)</a>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Para compilar um arquivo que contém todas as opções disponíveis, execute o seguinte comando como <code>root</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/src/sys/arch/conf &amp;&amp; make LINT</span></code></pre></div></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=kernelconfig-building>8.5. Criando e Instalando um Kernel Customizado<a class=anchor href=#kernelconfig-building></a></h3><div class=paragraph><p>Depois que as edições no arquivo de configuração personalizada forem salvas, o código-fonte do kernel poderá ser compilado usando as seguintes etapas:</p></div><div class="exampleblock procedure"><div class=content><div class=paragraph><p><strong>Procedure: Compilando um Kernel</strong></p></div><div class="olist arabic"><ol class=arabic><li><p>Mude para este diretório:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/src</span></code></pre></div></div></li><li><p>Compile o novo kernel especificando o nome do arquivo de configuração do kernel personalizado:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># make buildkernel KERNCONF=MYKERNEL</span></code></pre></div></div></li><li><p>Instale o novo kernel associado ao arquivo de configuração do kernel especificado. Este comando irá copiar o novo kernel para <span class=filename>/boot/kernel/kernel</span> e salvar o kernel antigo para <span class=filename>/boot/kernel.old/kernel</span>:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># make installkernel KERNCONF=MYKERNEL</span></code></pre></div></div></li><li><p>Desligue o sistema e reinicie no novo kernel. Se algo der errado, consulte <a href=#kernelconfig-noboot>O kernel não inicializa</a>.</p></li></ol></div></div></div><div class=paragraph><p>Por padrão, quando um kernel personalizado é compilado, todos os módulos do kernel são reconstruídos. Para atualizar um kernel mais rapidamente ou para construir apenas módulos customizados, edite o <span class=filename>/etc/make.conf</span> antes de começar a construir o kernel.</p></div><div class=paragraph><p>Por exemplo, esta variável especifica a lista de módulos para compilar em vez de usar o padrão de construir todos os módulos:</p></div><div class="literalblock programlisting"><div class=content><pre>MODULES_OVERRIDE = linux acpi</pre></div></div><div class=paragraph><p>Como alternativa, essa variável lista quais módulos excluir do processo de criação:</p></div><div class="literalblock programlisting"><div class=content><pre>WITHOUT_MODULES = linux acpi sound</pre></div></div><div class=paragraph><p>Variáveis adicionais estão disponíveis. Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=make.conf&amp;sektion=5&amp;format=html">make.conf(5)</a> para detalhes.</p></div></div><div class=sect2><h3 id=kernelconfig-trouble>8.6. Se algo der errado<a class=anchor href=#kernelconfig-trouble></a></h3><div class=paragraph><p>Existem quatro categorias de problemas que podem ocorrer ao criar um kernel personalizado:</p></div><div class=dlist><dl><dt class=hdlist1>falhas na <code>config</code></dt><dd><p>Se o <code>config</code> falhar, ele imprimirá o número da linha que está incorreta. Como exemplo, para a seguinte mensagem, certifique-se de que a linha 17 seja digitada corretamente, comparando-a com <span class=filename>GENERIC</span> ou <span class=filename>NOTES</span>:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>config: line 17: syntax error</code></pre></div></div></dd><dt class=hdlist1>falha no <code>make</code></dt><dd><p>Se o <code>make</code> falhar, geralmente é devido a um erro no arquivo de configuração do kernel que não é grave o suficiente para o <code>config</code> capturar. Revise a configuração, e se o problema não for aparente, envie um email para a <a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-questions>lista de discussão de questões gerais do FreeBSD</a> contendo o arquivo de configuração do kernel.</p></dd></dl></div><div id=kernelconfig-noboot class=dlist><dl><dt class=hdlist1>O kernel não inicializa</dt><dd><p>Se o novo kernel não inicializar ou não reconhecer os dispositivos, não entre em pânico! Felizmente, o FreeBSD possui um excelente mecanismo para recuperação de kernels incompatíveis. Simplesmente escolha o kernel para inicializar a partir do gerenciador de inicialização do FreeBSD. Isso pode ser acessado quando o menu de inicialização do sistema aparecer, selecionando a opção "Escape to a loader prompt". No prompt, digite <code>boot <em>kernel.old</em></code> ou o nome de qualquer outro kernel que seja conhecido por inicializar corretamente.</p><div class=paragraph><p>Após inicializar com um kernel correto, verifique o arquivo de configuração e tente construí-lo novamente. Um recurso útil é o <span class=filename>/var/log/messages</span> que registra as mensagens do kernel de cada inicialização bem-sucedida. Além disso, o <a href="https://man.freebsd.org/cgi/man.cgi?query=dmesg&amp;sektion=8&amp;format=html">dmesg(8)</a> imprimirá as mensagens do kernel a partir da inicialização atual.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Ao solucionar problemas de um kernel, certifique-se de manter uma cópia do <span class=filename>GENERIC</span>, ou algum outro kernel que funcione, como um nome diferente que não será apagado na próxima compilação. Isto é importante porque toda vez que um novo kernel é instalado, o <span class=filename>kernel.old</span> é sobrescrito com o último kernel instalado, que pode ou não ser inicializável. Assim que possível, mova o kernel funcional renomeando o diretório que contém o kernel correto:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mv /boot/kernel /boot/kernel.bad</span>
<span class=c># mv /boot/kernel.good /boot/kernel</span></code></pre></div></div></td></tr></tbody></table></div></dd><dt class=hdlist1>O kernel funciona, mas o <a href="https://man.freebsd.org/cgi/man.cgi?query=ps&amp;sektion=1&amp;format=html">ps(1)</a> não</dt><dd><p>Se a versão do kernel for diferente daquela com a qual os utilitários do sistema foram construídos, por exemplo, um kernel compilado a partir do código-fonte do -CURRENT é instalado em um sistema -RELEASE, muitos comandos de status do sistema como <a href="https://man.freebsd.org/cgi/man.cgi?query=ps&amp;sektion=1&amp;format=html">ps(1)</a> e <a href="https://man.freebsd.org/cgi/man.cgi?query=vmstat&amp;sektion=8&amp;format=html">vmstat(8)</a> não funcionarão. Para corrigir isso, <a href=./#makeworld>recompile e instale o world</a> usando a mesma versão da árvore de código-fonte que o kernel. Nunca é uma boa ideia usar uma versão diferente do kernel do que o resto do sistema operacional.</p></dd></dl></div></div></div></div><div class=sect1><h2 id=printing>Capítulo 9. Impressão<a class=anchor href=#printing></a></h2><div class=sectionbody><div class=paragraph><p>Colocar informações no papel é uma função vital, apesar de muitas tentativas de eliminá-la. A impressão tem dois componentes básicos. Os dados devem ser entregues à impressora e devem estar em um formato que a impressora possa entender.</p></div><div class=sect2><h3 id=printing-quick-start>9.1. Inicio Rápido<a class=anchor href=#printing-quick-start></a></h3><div class=paragraph><p>A impressão básica pode ser configurada rapidamente. A impressora deve ser capaz de imprimir texto simples ASCII. Para imprimir em outros tipos de arquivos, consulte <a href=#printing-lpd-filters>Filtros</a>.</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Crie um diretório para armazenar arquivos enquanto eles estão sendo impressos:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mkdir -p /var/spool/lpd/lp</span>
<span class=c># chown daemon:daemon /var/spool/lpd/lp</span>
<span class=c># chmod 770 /var/spool/lpd/lp</span></code></pre></div></div></li><li><p>Como <code>root</code>, crie <span class=filename>/etc/printcap</span> com estes conteúdos:</p><div class="literalblock programlisting"><div class=content><pre>lp:\
	:lp=/dev/unlpt0:\  <i class=conum data-value=1></i><b>(1)</b>
	:sh:\
	:mx#0:\
	:sd=/var/spool/lpd/lp:\
	:lf=/var/log/lpd-errs:</pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>Esta linha é para uma impressora conectada a uma porta USB.Para uma impressora conectada a uma porta paralela ou uma porta de "impressora", use:Para uma impressora conectada diretamente a uma rede, use:Substitua <em>network-printer-name</em> pelo nome de host DNS da impressora de rede.</td></tr></tbody></table></div></li><li><p>Ative o <code>lpd</code> editando o <span class=filename>/etc/rc.conf</span>, adicionando esta linha:</p><div class="literalblock programlisting"><div class=content><pre>lpd_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Inicie o serviço:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service lpd start</span>
Starting lpd.</code></pre></div></div></li><li><p>Imprima um teste:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># printf &#34;1. This printer can print.\n2. This is the second line.\n&#34; | lpr</span></code></pre></div></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Se ambas as linhas não iniciarem na borda esquerda, mas em "degrau", consulte <a href=#printing-lpd-filters-stairstep>Impedindo degraus em impressoras de texto simples</a>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Arquivos de texto agora podem ser impressos com <code>lpr</code>. Dê o nome do arquivo na linha de comando ou canalize a saída diretamente no <code>lpr</code>.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% lpr textfile.txt
% <span class=nb>ls</span> <span class=nt>-lh</span> | lpr</code></pre></div></div></li></ol></div></div></div></div><div class=sect2><h3 id=printing-connections>9.2. Conexões de Impressora<a class=anchor href=#printing-connections></a></h3><div class=paragraph><p>As impressoras são conectadas a sistemas de computadores de várias maneiras. Geralmente, as impressoras desktop pequenas são conectadas diretamente à porta USB do computador. As impressoras mais antigas são conectadas a uma porta paralela ou a porta de "impressora". Algumas impressoras estão diretamente conectadas a uma rede, facilitando o compartilhamento com vários computadores. Algumas impressoras usam uma rara conexão de porta serial.</p></div><div class=paragraph><p>O FreeBSD pode se comunicar com todos esses tipos de impressoras.</p></div><div id=printing-connections-usb class=dlist><dl><dt class=hdlist1>USB</dt><dd><p>As impressoras USB podem ser conectadas a qualquer porta USB disponível no computador.</p><div class=paragraph><p>Quando o FreeBSD detecta uma impressora USB, duas entradas de dispositivos são criadas: <span class=filename>/dev/ulpt0</span> e <span class=filename>/dev/unlpt0</span>. Os dados enviados para qualquer dispositivo serão retransmitidos para a impressora. Após cada trabalho de impressão, o <span class=filename>ulpt0</span> reseta a porta USB. O reset da porta pode causar problemas em algumas impressoras, portanto, o dispositivo <span class=filename>unlpt0</span> é normalmente usado em seu lugar. O <span class=filename>unlpt0</span> não reseta a porta USB.</p></div></dd></dl></div><div id=printing-connections-parallel class=dlist><dl><dt class=hdlist1>Paralela (IEEE-1284)</dt><dd><p>O dispositivo da porta paralela é o <span class=filename>/dev/lpt0</span>. Este dispositivo aparece independentemente se uma impressora está ou não conectada, ela não é autodetectada.</p><div class=paragraph><p>A maior parte dos fabricantes se afastou destas portas "legadas" e muitos computadores não as têm mais. Adaptadores podem ser usados para conectar uma impressora paralela a uma porta USB. Com este tipo de adaptador, a impressora pode ser tratada como se fosse uma impressora USB. Dispositivos chamados <em>servidores de impressão</em> também podem ser usados para conectar impressoras paralelas diretamente a uma rede.</p></div></dd></dl></div><div id=printing-connections-serial class=dlist><dl><dt class=hdlist1>Serial (RS-232)</dt><dd><p>Portas seriais são outro tipo de porta legada, raramente usada para impressoras, exceto em determinadas aplicações de nicho. Os cabos, os conectores e a fiação necessária variam muito.</p><div class=paragraph><p>Para portas seriais incorporadas em uma placa-mãe, o nome do dispositivo serial é <span class=filename>/dev/cuau0</span> ou <span class=filename>/dev/cuau1</span>. Os adaptadores Seriais USB também podem ser usados, e eles aparecerão como <span class=filename>/dev/cuaU0</span>.</p></div><div class=paragraph><p>Vários parâmetros de comunicação devem ser conhecidos para se comunicar com uma impressora serial. Os mais importantes são <em>baud rate</em> ou BPS (Bits por segundo) e <em>paridade</em>. Os valores variam, mas as impressoras seriais típicas usam uma taxa de transmissão de 9600 e nenhuma paridade.</p></div></dd></dl></div><div id=printing-connections-network class=dlist><dl><dt class=hdlist1>Rede</dt><dd><p>As impressoras de rede estão conectadas diretamente à rede de computadores local.</p><div class=paragraph><p>O nome de host DNS da impressora deve ser conhecido. Se a impressora tiver um endereço dinâmico atribuído por DHCP, o DNS deverá ser atualizado dinamicamente para que o nome do host tenha sempre o endereço IP correto. As impressoras de rede geralmente recebem endereços IP estáticos para evitar esse problema.</p></div><div class=paragraph><p>A maioria das impressoras de rede entende os trabalhos de impressão enviados com o protocolo LPD. Um nome de fila de impressão também pode ser especificado. Algumas impressoras processam dados de maneira diferente, dependendo de qual fila é usada. Por exemplo, uma fila <code>raw</code> imprime os dados inalterados, enquanto a fila <code>text</code> adiciona retornos de carro aos textos simples.</p></div><div class=paragraph><p>Muitas impressoras de rede também podem imprimir dados enviados diretamente para a porta 9100.</p></div></dd></dl></div><div class=sect3><h4 id=printing-connections-summary>9.2.1. Resumo<a class=anchor href=#printing-connections-summary></a></h4><div class=paragraph><p>As conexões de rede com fio geralmente são as mais fáceis de configurar e oferecem a impressão mais rápida. Para conexão direta com o computador, a conexão USB é preferida em função da velocidade e da simplicidade. As conexões paralelas funcionam, mas têm limitações no comprimento do cabo e na velocidade. Conexões seriais são mais difíceis de configurar. A configuração do cabo difere entre os modelos, e os parâmetros de comunicação, como taxa de transmissão e bits de paridade, se somam a complexidade. Felizmente, as impressoras seriais são raras.</p></div></div></div><div class=sect2><h3 id=printing-pdls>9.3. Linguagens de Descrição de Página Comuns<a class=anchor href=#printing-pdls></a></h3><div class=paragraph><p>Os dados enviados a uma impressora devem estar em um idioma que a impressora possa entender. Esses idiomas são chamados de Linguagens de Descrição de Página ou PDLs.</p></div><div id=print-pdls-ascii class=dlist><dl><dt class=hdlist1>ASCII</dt><dd><p>Texto ASCII simples é a maneira mais simples de enviar dados para uma impressora. Os caracteres correspondem um a um com o que será impresso: um <code>A</code> nos dados imprime um <code>A</code> na página. Muito pouca formatação está disponível. Não há como selecionar uma fonte ou espaçamento proporcional. A simplicidade forçada do texto ASCII simples significa que o texto pode ser impresso diretamente do computador com pouca ou nenhuma codificação ou tradução. A saída impressa corresponde diretamente ao que foi enviado.</p><div class=paragraph><p>Algumas impressoras baratas não conseguem imprimir texto ASCII simples. Isso as torna mais difíceis de configurar, mas geralmente ainda é possível fazê-lo.</p></div></dd></dl></div><div id=print-pdls-postscript class=dlist><dl><dt class=hdlist1>PostScript™</dt><dd><p>O PostScript™ é quase o oposto do ASCII. Em vez de um texto simples, um programa PostScript™ é um conjunto de instruções que desenham o documento final. Fontes e gráficos diferentes podem ser usados. No entanto, esse poder tem um preço. O programa que desenha a página deve ser escrito. Geralmente este programa é gerado pelo software aplicativo, portanto, o processo é invisível para o usuário.</p><div class=paragraph><p>Impressoras baratas às vezes deixam de fora a compatibilidade com o PostScript™ como uma medida para economia de custos.</p></div></dd></dl></div><div id=print-pdls-pcl class=dlist><dl><dt class=hdlist1>PCL (linguagem de comando de impressora)</dt><dd><p>A PCL é uma extensão do ASCII, adicionando sequências de escape para formatação, seleção de fontes e impressão de gráficos. Muitas impressoras fornecem suporte para PCL5. Algumas suportam o mais recente PCL6 ou o PCLXL. Essas versões posteriores são superconjuntos do PCL5 e podem fornecer uma impressão mais rápida.</p></dd></dl></div><div id=print-pdls-host-based class=dlist><dl><dt class=hdlist1>Baseado em Host</dt><dd><p>Os fabricantes podem reduzir o custo de uma impressora, oferecendo um processador simples e muito pouca memória. Essas impressoras não são capazes de imprimir texto simples. Em vez disso, bitmaps de texto e gráficos são desenhados por um driver no computador host e, em seguida, enviados para a impressora. Estas são chamadas de impressoras <em>baseadas em host</em>.</p><div class=paragraph><p>A comunicação entre o driver e uma impressora baseada em host geralmente ocorre por meio de protocolos proprietários ou não documentados, tornando-os funcionais apenas nos sistemas operacionais mais comuns.</p></div></dd></dl></div><div class=sect3><h4 id=print-pdls-table>9.3.1. Convertendo PostScript™ para outros PDLs<a class=anchor href=#print-pdls-table></a></h4><div class=paragraph><p>Muitas aplicações da Coleção de Ports e muitos utilitários do FreeBSD produzem uma saída em PostScript™. Esta tabela mostra os utilitários disponíveis para converter o postscript em outros PDLs comuns:</p></div><table id=print-pdls-ps-to-other-tbl class="tableblock frame-none grid-all stretch"><caption class=title>Tabela 8. Saída PDLs</caption><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Saída PDL</th><th class="tableblock halign-left valign-top">Gerado por</th><th class="tableblock halign-left valign-top">Notas</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>PCL ou PCL5</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/print/ghostscript9/>print/ghostscript9</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>-sDEVICE=ljet4</code> para monocromático, e <code>-sDEVICE=cljet5</code> para colorido</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>PCLXL ou PCL6</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/print/ghostscript9/>print/ghostscript9</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>-sDEVICE=pxlmono</code> para monocromático, <code>-sDEVICE=pxlcolor</code> para colorido</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>ESC/P2</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/print/ghostscript9/>print/ghostscript9</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>-sDEVICE=uniprint</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>XQX</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/print/foo2zjs/>print/foo2zjs</a></p></td><td class="tableblock halign-left valign-top"></td></tr></tbody></table></div><div class=sect3><h4 id=print-pdls-summary>9.3.2. Resumo<a class=anchor href=#print-pdls-summary></a></h4><div class=paragraph><p>Para facilitar a impressão, escolha uma impressora que suporte PostScript™. Impressoras que suportam PCL são as próximas preferidas. Com o <a class=package href=https://cgit.freebsd.org/ports/tree/print/ghostscript/>print/ghostscript</a>, essas impressoras podem ser usadas como se entendessem nativamente PostScript™. Impressoras que suportam PostScript™ ou PCL diretamente quase sempre suportam a impressão direta de arquivos de texto simples ASCII também.</p></div><div class=paragraph><p>Impressoras baseadas em linha, como as jatos de tinta comuns, geralmente não suportam PostScript™ ou PCL. Elas geralmente podem imprimir arquivos de texto plano ASCII. O <a class=package href=https://cgit.freebsd.org/ports/tree/print/ghostscript/>print/ghostscript</a> suporta os PDL usados por algumas dessas impressoras. Entretanto, a impressão de uma página inteira baseada em gráficos nessas impressoras costuma ser muito lenta devido à grande quantidade de dados a serem transferidos e impressos.</p></div><div class=paragraph><p>Geralmente, as impressoras baseadas em host são mais difíceis de configurar. Algumas não podem ser usadas por causa de PDLs proprietários. Evite essas impressoras quando possível.</p></div><div class=paragraph><p>Descrições de muitos PDLs podem ser encontradas em <a href=http://www.undocprint.org/formats/page_description_languages class=bare>http://www.undocprint.org/formats/page_description_languages</a>. O PDL específico usado por vários modelos de impressoras pode ser encontrado em <a href=http://www.openprinting.org/printers class=bare>http://www.openprinting.org/printers</a>.</p></div></div></div><div class=sect2><h3 id=printing-direct>9.4. Impressão Direta<a class=anchor href=#printing-direct></a></h3><div class=paragraph><p>Para impressão ocasional, os arquivos podem ser enviados diretamente para um dispositivo de impressora sem qualquer configuração. Por exemplo, um arquivo chamado <span class=filename>exemplo.txt</span> pode ser enviado para uma impressora USB:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cp sample.txt /dev/unlpt0</span></code></pre></div></div><div class=paragraph><p>A impressão direta para impressoras de rede depende das capacidades da impressora, mas a maioria aceita trabalhos de impressão na porta 9100, e o <a href="https://man.freebsd.org/cgi/man.cgi?query=nc&amp;sektion=1&amp;format=html">nc(1)</a> pode ser usado com eles. Para imprimir o mesmo arquivo em uma impressora com o nome de host DNS de <em>netlaser</em>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># nc netlaser 9100 &lt; sample.txt</span></code></pre></div></div></div><div class=sect2><h3 id=printing-lpd>9.5. LPD (Daemon de impressora de linha)<a class=anchor href=#printing-lpd></a></h3><div class=paragraph><p>A impressão de um arquivo em segundo plano é chamada de <em>spooling</em>. Um spooler permite que o usuário continue com outros programas no computador sem ter de esperar que a impressora conclua lentamente o trabalho de impressão.</p></div><div class=paragraph><p>O FreeBSD inclui um spooler chamado <a href="https://man.freebsd.org/cgi/man.cgi?query=lpd&amp;sektion=8&amp;format=html">lpd(8)</a>. Os trabalhos de impressão são enviados com o comando <a href="https://man.freebsd.org/cgi/man.cgi?query=lpr&amp;sektion=1&amp;format=html">lpr(1)</a>.</p></div><div class=sect3><h4 id=printing-lpd-setup>9.5.1. Configuração inicial<a class=anchor href=#printing-lpd-setup></a></h4><div class=paragraph><p>Um diretório para armazenar trabalhos de impressão é criado, a propriedade é definida e as permissões são definidas para impedir que outros usuários visualizem o conteúdo desses arquivos:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mkdir -p /var/spool/lpd/lp</span>
<span class=c># chown daemon:daemon /var/spool/lpd/lp</span>
<span class=c># chmod 770 /var/spool/lpd/lp</span></code></pre></div></div><div class=paragraph><p>As impressoras são definidas no <span class=filename>/etc/printcap</span>. Uma entrada para cada impressora inclui detalhes como um nome, a porta onde ela está conectada e várias outras configurações. Crie <span class=filename>/etc/printcap</span> com estes conteúdos:</p></div><div class="literalblock programlisting"><div class=content><pre>lp:\				<i class=conum data-value=1></i><b>(1)</b>
	:lp=/dev/unlpt0:\	<i class=conum data-value=2></i><b>(2)</b>
	:sh:\			<i class=conum data-value=3></i><b>(3)</b>
	:mx#0:\			<i class=conum data-value=4></i><b>(4)</b>
	:sd=/var/spool/lpd/lp:\	<i class=conum data-value=5></i><b>(5)</b>
	:lf=/var/log/lpd-errs:	<i class=conum data-value=6></i><b>(6)</b></pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>O nome desta impressora. O <a href="https://man.freebsd.org/cgi/man.cgi?query=lpr&amp;sektion=1&amp;format=html">lpr(1)</a> envia trabalhos de impressão para a impressora <code>lp</code>, a menos que outra impressora seja especificada com <code>-P</code>, portanto, a impressora padrão deve ser denominada <code>lp</code>.</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td>O dispositivo em que a impressora está conectada. Substitua esta linha pela apropriada para o tipo de conexão mostrado aqui.</td></tr><tr><td><i class=conum data-value=3></i><b>3</b></td><td>Suprimir a impressão de uma página de cabeçalho no início de um trabalho de impressão.</td></tr><tr><td><i class=conum data-value=4></i><b>4</b></td><td>Não limite o tamanho máximo de um trabalho de impressão.</td></tr><tr><td><i class=conum data-value=5></i><b>5</b></td><td>O caminho para o diretório de spooling desta impressora. Cada impressora usa seu próprio diretório de spooling.</td></tr><tr><td><i class=conum data-value=6></i><b>6</b></td><td>O arquivo de log no qual os erros nesta impressora serão relatados.</td></tr></tbody></table></div><div class=paragraph><p>Depois de criar o <span class=filename>/etc/printcap</span>, use <a href="https://man.freebsd.org/cgi/man.cgi?query=chkprintcap&amp;sektion=8&amp;format=html">chkprintcap(8)</a> para testar se há erros:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># chkprintcap</span></code></pre></div></div><div class=paragraph><p>Corrija quaisquer problemas relatados antes de continuar.</p></div><div class=paragraph><p>Ative o <a href="https://man.freebsd.org/cgi/man.cgi?query=lpd&amp;sektion=8&amp;format=html">lpd(8)</a> no <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>lpd_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Inicie o serviço:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service lpd start</span></code></pre></div></div></div><div class=sect3><h4 id=printing-lpd-lpr>9.5.2. Imprimindo com o <a href="https://man.freebsd.org/cgi/man.cgi?query=lpr&amp;sektion=1&amp;format=html">lpr(1)</a><a class=anchor href=#printing-lpd-lpr></a></h4><div class=paragraph><p>Os documentos são enviados para a impressora com o <code>lpr</code>. Um arquivo a ser impresso pode ser nomeado na linha de comando ou canalizado para o <code>lpr</code>. Esses dois comandos são equivalentes, enviando o conteúdo de <span class=filename>doc.txt</span> para a impressora padrão:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% lpr doc.txt
% <span class=nb>cat </span>doc.txt | lpr</code></pre></div></div><div class=paragraph><p>Impressoras podem ser selecionadas com <code>-P</code>. Para imprimir em uma impressora chamada <em>laser</em>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% lpr <span class=nt>-Plaser</span> doc.txt</code></pre></div></div></div><div class=sect3><h4 id=printing-lpd-filters>9.5.3. Filtros<a class=anchor href=#printing-lpd-filters></a></h4><div class=paragraph><p>Os exemplos mostrados até agora enviaram o conteúdo de um arquivo de texto diretamente para a impressora. Contanto que a impressora entenda o conteúdo desses arquivos, a saída será impressa corretamente.</p></div><div class=paragraph><p>Algumas impressoras não são capazes de imprimir texto simples, e o arquivo de entrada pode nem ser texto simples.</p></div><div class=paragraph><p><em>Filtros</em> permitem que os arquivos sejam traduzidos ou processados. O uso típico é traduzir um tipo de entrada, como texto simples, em um formato que a impressora possa entender, como PostScript™ ou PCL. Os filtros também podem ser usados para fornecer recursos adicionais, como adicionar números de página ou destacar o código-fonte para facilitar a leitura.</p></div><div class=paragraph><p>Os filtros discutidos aqui são <em>filtros de entrada</em> ou <em>filtros de texto</em>. Esses filtros convertem o arquivo recebido em diferentes formatos. Use <a href="https://man.freebsd.org/cgi/man.cgi?query=su&amp;sektion=1&amp;format=html">su(1)</a> para se tornar <code>root</code> antes de criar os arquivos.</p></div><div class=paragraph><p>Os filtros são especificados em <span class=filename>/etc/printcap</span> com o identificador <code>if=</code>. Para usar <span class=filename>/usr/local/libexec/lf2crlf</span> como um filtro, modifique o <span class=filename>/etc/printcap</span> assim:</p></div><div class="literalblock programlisting"><div class=content><pre>lp:\
	:lp=/dev/unlpt0:\
	:sh:\
	:mx#0:\
	:sd=/var/spool/lpd/lp:\
	:if=/usr/local/libexec/lf2crlf:\   <i class=conum data-value=1></i><b>(1)</b>
	:lf=/var/log/lpd-errs:</pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td><code>if=</code> identifica o <em>filtro de entrada</em> que será usado no texto recebido.</td></tr></tbody></table></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Os caracteres backslash de <em>continuação de linha</em> no final das linhas nas entradas do <span class=filename>printcap</span> revelam que uma entrada para uma impressora é na verdade apenas uma linha longa com entradas delimitadas por dois pontos. O exemplo anterior pode ser reescrito como uma única linha menos legível:</p></div><div class="literalblock programlisting"><div class=content><pre>lp:lp=/dev/unlpt0:sh:mx#0:sd=/var/spool/lpd/lp:if=/usr/local/libexec/lf2crlf:lf=/var/log/lpd-errs:</pre></div></div></td></tr></tbody></table></div><div class=sect4><h5 id=printing-lpd-filters-stairstep>9.5.3.1. Impedindo degraus em impressoras de texto simples<a class=anchor href=#printing-lpd-filters-stairstep></a></h5><div class=paragraph><p>Os arquivos de texto típicos do FreeBSD contêm apenas um único caractere de feed de linha no final de cada linha. Estas linhas vão ficar em "degraus" em uma impressora padrão:</p></div><div class="literalblock programlisting"><div class=content><pre>Um arquivo impresso parece
                    como os degraus de uma escada
                                              espalhados pelo vento</pre></div></div><div class=paragraph><p>Um filtro pode converter os caracteres de nova linha em retornos de carro e novas linhas. Os retornos de carro fazem a impressora retornar para a esquerda após cada linha. Crie o <span class=filename>/usr/local/libexec/lf2crlf</span> com este conteúdo:</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
CR=$&#39;\r&#39;
/usr/bin/sed -e &#34;s/$/${CR}/g&#34;</pre></div></div><div class=paragraph><p>Defina as permissões e torne-o executável:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># chmod 555 /usr/local/libexec/lf2crlf</span></code></pre></div></div><div class=paragraph><p>Modifique o <span class=filename>/etc/printcap</span> para usar o novo filtro:</p></div><div class="literalblock programlisting"><div class=content><pre>:if=/usr/local/libexec/lf2crlf:\</pre></div></div><div class=paragraph><p>Teste o filtro imprimindo o mesmo arquivo de texto simples. O procedimento fará com que cada linha comece no lado esquerdo da página.</p></div></div><div class=sect4><h5 id=printing-lpd-filters-enscript>9.5.3.2. Texto simples chique em impressoras PostScript™ com <a class=package href=https://cgit.freebsd.org/ports/tree/print/enscript/>print/enscript</a><a class=anchor href=#printing-lpd-filters-enscript></a></h5><div class=paragraph><p>O GNUEnscript converte arquivos de texto simples em arquivos formatados como PostScript™ para impressão em impressoras PostScript™. Ele adiciona números de página, quebra as linhas longas e fornece vários outros recursos para facilitar a leitura dos arquivos de texto impressos. Dependendo do tamanho do papel local, instale o <a class=package href=https://cgit.freebsd.org/ports/tree/print/enscript-letter/>print/enscript-letter</a> ou o <a class=package href=https://cgit.freebsd.org/ports/tree/print/enscript-a4/>print/enscript-a4</a> da coleção Ports.</p></div><div class=paragraph><p>Crie o <span class=filename>/usr/local/libexec/enscript</span> com este conteúdo:</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
/usr/local/bin/enscript -o -</pre></div></div><div class=paragraph><p>Defina as permissões e torne-o executável:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># chmod 555 /usr/local/libexec/enscript</span></code></pre></div></div><div class=paragraph><p>Modifique o <span class=filename>/etc/printcap</span> para usar o novo filtro:</p></div><div class="literalblock programlisting"><div class=content><pre>:if=/usr/local/libexec/enscript:\</pre></div></div><div class=paragraph><p>Teste o filtro imprimindo um arquivo de texto simples.</p></div></div><div class=sect4><h5 id=printing-lpd-filters-ps2pcl>9.5.3.3. Imprimindo PostScript™ em impressoras PCL<a class=anchor href=#printing-lpd-filters-ps2pcl></a></h5><div class=paragraph><p>Muitos programas produzem documentos PostScript™. No entanto, impressoras baratas geralmente só entendem texto simples ou PCL. Este filtro converte os arquivos PostScript™ para o formato PCL antes de enviá-los para a impressora.</p></div><div class=paragraph><p>Instale o interpretador de PostScript™ Ghostscript, <a class=package href=https://cgit.freebsd.org/ports/tree/print/ghostscript9/>print/ghostscript9</a>, através da Coleção de Ports.</p></div><div class=paragraph><p>Crie o <span class=filename>/usr/local/libexec/ps2pcl</span> com este conteúdo:</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
/usr/local/bin/gs -dSAFER -dNOPAUSE -dBATCH -q -sDEVICE=ljet4 -sOutputFile=- -</pre></div></div><div class=paragraph><p>Defina as permissões e torne-o executável:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># chmod 555 /usr/local/libexec/ps2pcl</span></code></pre></div></div><div class=paragraph><p>A entrada PostScript™ enviada para este script será processada e convertida em PCL antes de ser enviada para a impressora.</p></div><div class=paragraph><p>Modifique o <span class=filename>/etc/printcap</span> para usar este novo filtro de entrada:</p></div><div class="literalblock programlisting"><div class=content><pre>:if=/usr/local/libexec/ps2pcl:\</pre></div></div><div class=paragraph><p>Teste o filtro enviando um pequeno programa PostScript™ para ele:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>printf</span> <span class=s2>&#34;%%</span><span class=se>\!</span><span class=s2>PS </span><span class=se>\n</span><span class=s2> /Helvetica findfont 18 scalefont setfont </span><span class=se>\</span><span class=s2>
72 432 moveto (PostScript printing successful.) show showpage </span><span class=se>\0</span><span class=s2>04&#34;</span> | lpr</code></pre></div></div></div><div class=sect4><h5 id=printing-lpd-filters-smart>9.5.3.4. Filtros Inteligentes<a class=anchor href=#printing-lpd-filters-smart></a></h5><div class=paragraph><p>Um filtro que detecta o tipo de entrada e converte automaticamente para o formato correto da impressora pode ser muito conveniente. Os dois primeiros caracteres de um arquivo PostScript™ são geralmente <code>%!</code>. Um filtro pode detectar esses dois caracteres. Os arquivos PostScript™ podem ser enviados de forma inalterada para uma impressora PostScript™. Arquivos de texto podem ser convertidos para PostScript™ com o Enscript como mostrado anteriormente. Crie o <span class=filename>/usr/local/libexec/psif</span> com este conteúdo:</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
#
#  psif - Print PostScript or plain text on a PostScript printer
#
IFS=&#34;&#34; read -r first_line
first_two_chars=`expr &#34;$first_line&#34; : &#39;\(..\)&#39;`

case &#34;$first_two_chars&#34; in
%!)
    # %! : PostScript job, print it.
    echo &#34;$first_line&#34; &amp;&amp; cat &amp;&amp; exit 0
    exit 2
    ;;
*)
    # otherwise, format with enscript
    ( echo &#34;$first_line&#34;; cat ) | /usr/local/bin/enscript -o - &amp;&amp; exit 0
    exit 2
    ;;
esac</pre></div></div><div class=paragraph><p>Defina as permissões e torne-o executável:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># chmod 555 /usr/local/libexec/psif</span></code></pre></div></div><div class=paragraph><p>Modifique o <span class=filename>/etc/printcap</span> para usar este novo filtro de entrada:</p></div><div class="literalblock programlisting"><div class=content><pre>:if=/usr/local/libexec/psif:\</pre></div></div><div class=paragraph><p>Teste o filtro imprimindo PostScript™ e arquivos de texto simples.</p></div></div></div><div class=sect3><h4 id=printing-lpd-queues>9.5.4. Múltiplas filas<a class=anchor href=#printing-lpd-queues></a></h4><div class=paragraph><p>As entradas no <span class=filename>/etc/printcap</span> são na verdade definições de <em>filas</em>. Pode haver mais de uma fila para uma única impressora. Quando combinadas com filtros, múltiplas filas fornecem aos usuários um maior controle sobre como seus trabalhos são impressos.</p></div><div class=paragraph><p>Por exemplo, considere uma impressora laser PostScript™ em rede num escritório. A maioria dos usuários deseja imprimir texto simples, mas alguns usuários avançados querem poder imprimir diretamente os arquivos PostScript™. Duas entradas podem ser criadas para a mesma impressora no <span class=filename>/etc/printcap</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>textprinter:\
	:lp=9100@officelaser:\
	:sh:\
	:mx#0:\
	:sd=/var/spool/lpd/textprinter:\
	:if=/usr/local/libexec/enscript:\
	:lf=/var/log/lpd-errs:

psprinter:\
	:lp=9100@officelaser:\
	:sh:\
	:mx#0:\
	:sd=/var/spool/lpd/psprinter:\
	:lf=/var/log/lpd-errs:</pre></div></div><div class=paragraph><p>Os documentos enviados para a fila <code>textprinter</code> serão formatados pelo filtro <span class=filename>/usr/local/libexec/enscript</span> mostrado em um exemplo anterior. Usuários avançados podem imprimir arquivos PostScript™ em <code>psprinter</code>, onde nenhuma filtragem é feita.</p></div><div class=paragraph><p>Esta técnica de múltiplas filas pode ser usada para fornecer acesso direto a todos os tipos de recursos da impressora. Uma impressora com um duplexador pode usar duas filas, uma para impressões em apenas um lado da folha e outra com um filtro que envia a seqüência de comandos para habilitar a impressão frente e verso e, em seguida, envia o arquivo recebido.</p></div></div><div class=sect3><h4 id=printing-lpd-monitor>9.5.5. Monitoramento e controle de impressão<a class=anchor href=#printing-lpd-monitor></a></h4><div class=paragraph><p>Vários utilitários estão disponíveis para monitorar trabalhos de impressão e verificar e controlar a operação da impressora.</p></div><div class=sect4><h5 id=printing-lpd-monitor-lpq>9.5.5.1. <a href="https://man.freebsd.org/cgi/man.cgi?query=lpq&amp;sektion=1&amp;format=html">lpq(1)</a><a class=anchor href=#printing-lpd-monitor-lpq></a></h5><div class=paragraph><p>O <a href="https://man.freebsd.org/cgi/man.cgi?query=lpq&amp;sektion=1&amp;format=html">lpq(1)</a> mostra o status das tarefas de impressão de um usuário. Trabalhos de impressão de outros usuários não são mostrados.</p></div><div class=paragraph><p>Mostra os trabalhos pendentes do usuário atual em uma única impressora:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% lpq <span class=nt>-Plp</span>
Rank   Owner      Job  Files                                 Total Size
1st    jsmith     0    <span class=o>(</span>standard input<span class=o>)</span>                      12792 bytes</code></pre></div></div><div class=paragraph><p>Mostra os trabalhos pendentes do usuário atual em todas as impressoras:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% lpq <span class=nt>-a</span>
lp:
Rank   Owner      Job  Files                                 Total Size
1st    jsmith     1    <span class=o>(</span>standard input<span class=o>)</span>                      27320 bytes

laser:
Rank   Owner      Job  Files                                 Total Size
1st    jsmith     287  <span class=o>(</span>standard input<span class=o>)</span>                      22443 bytes</code></pre></div></div></div><div class=sect4><h5 id=printing-lpd-monitor-lprm>9.5.5.2. <a href="https://man.freebsd.org/cgi/man.cgi?query=lprm&amp;sektion=1&amp;format=html">lprm(1)</a><a class=anchor href=#printing-lpd-monitor-lprm></a></h5><div class=paragraph><p>O <a href="https://man.freebsd.org/cgi/man.cgi?query=lprm&amp;sektion=1&amp;format=html">lprm(1)</a> é usado para remover trabalhos de impressão. Usuários normais só podem remover seus próprios trabalhos. O <code>root</code> pode remover qualquer um ou todos os trabalhos.</p></div><div class=paragraph><p>Remova todos os trabalhos pendentes de uma impressora:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># lprm -Plp -</span>
dfA002smithy dequeued
cfA002smithy dequeued
dfA003smithy dequeued
cfA003smithy dequeued
dfA004smithy dequeued
cfA004smithy dequeued</code></pre></div></div><div class=paragraph><p>Remova um único trabalho de uma impressora. O <a href="https://man.freebsd.org/cgi/man.cgi?query=lpq&amp;sektion=1&amp;format=html">lpq(1)</a> é usado para encontrar o número do trabalho.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% lpq
Rank   Owner      Job  Files                                 Total Size
1st    jsmith     5    <span class=o>(</span>standard input<span class=o>)</span>                      12188 bytes
% lprm <span class=nt>-Plp</span> 5
dfA005smithy dequeued
cfA005smithy dequeued</code></pre></div></div></div><div class=sect4><h5 id=printing-lpd-monitor-lpc>9.5.5.3. <a href="https://man.freebsd.org/cgi/man.cgi?query=lpc&amp;sektion=8&amp;format=html">lpc(8)</a><a class=anchor href=#printing-lpd-monitor-lpc></a></h5><div class=paragraph><p>O <a href="https://man.freebsd.org/cgi/man.cgi?query=lpc&amp;sektion=8&amp;format=html">lpc(8)</a> é usado para verificar e modificar o status da impressora. O <code>lpc</code> é seguido por um comando e um nome de impressora opcional. O parâmetro <code>all</code> pode ser usado em vez de um nome de impressora específico, e o comando será aplicado a todas as impressoras. Usuários normais podem visualizar o status com <a href="https://man.freebsd.org/cgi/man.cgi?query=lpc&amp;sektion=8&amp;format=html">lpc(8)</a>. Somente o <code>class="username">root</code> pode usar comandos que modificam o status da impressora.</p></div><div class=paragraph><p>Mostrar o status de todas as impressoras:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% lpc status all
lp:
	queuing is enabled
	printing is enabled
	1 entry <span class=k>in </span>spool area
	printer idle
laser:
	queuing is enabled
	printing is enabled
	1 entry <span class=k>in </span>spool area
	waiting <span class=k>for </span>laser to come up</code></pre></div></div><div class=paragraph><p>Impedindo que uma impressora aceite novos trabalhos e fazendo com que ela comece a aceitar novos trabalhos novamente:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># lpc disable lp</span>
lp:
	queuing disabled
<span class=c># lpc enable lp</span>
lp:
	queuing enabled</code></pre></div></div><div class=paragraph><p>Pare de imprimir, mas continue aceitando novos trabalhos. Em seguida, comece a imprimir novamente:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># lpc stop lp</span>
lp:
	printing disabled
<span class=c># lpc start lp</span>
lp:
	printing enabled
	daemon started</code></pre></div></div><div class=paragraph><p>Reinicie uma impressora após alguma condição de erro:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># lpc restart lp</span>
lp:
	no daemon to abort
	printing enabled
	daemon restarted</code></pre></div></div><div class=paragraph><p>Desative a fila de impressão e desative a impressão, com uma mensagem para explicar o problema aos usuários:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># lpc down lp Repair parts will arrive on Monday</span>
lp:
	printer and queuing disabled
	status message is now: Repair parts will arrive on Monday</code></pre></div></div><div class=paragraph><p>Reative uma impressora que esteja inativa:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># lpc up lp</span>
lp:
	printing enabled
	daemon started</code></pre></div></div><div class=paragraph><p>Veja <a href="https://man.freebsd.org/cgi/man.cgi?query=lpc&amp;sektion=8&amp;format=html">lpc(8)</a> para mais comandos e opções.</p></div></div></div><div class=sect3><h4 id=printing-lpd-shared>9.5.6. Impressoras Compartilhadas<a class=anchor href=#printing-lpd-shared></a></h4><div class=paragraph><p>As impressoras costumam ser compartilhadas por vários usuários em empresas e escolas. Recursos adicionais são fornecidos para tornar as impressoras compartilhadas mais convenientes.</p></div><div class=sect4><h5 id=printing-shared-aliases>9.5.6.1. Aliases<a class=anchor href=#printing-shared-aliases></a></h5><div class=paragraph><p>O nome da impressora é definido na primeira linha da entrada em <span class=filename>/etc/printcap</span>. Nomes adicionais, ou <em>aliases</em>, podem ser adicionados após esse nome. Os aliases são separados do nome e um do outro por barras verticais:</p></div><div class="literalblock programlisting"><div class=content><pre>lp|repairsprinter|salesprinter:\</pre></div></div><div class=paragraph><p>Os aliases podem ser usados no lugar do nome da impressora. Por exemplo, os usuários do departamento de vendas imprimem em sua impressora com</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% lpr <span class=nt>-Psalesprinter</span> sales-report.txt</code></pre></div></div><div class=paragraph><p>Usuários do departamento de Reparos podem imprimir na <em>sua</em> impressora com</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% lpr <span class=nt>-Prepairsprinter</span> repairs-report.txt</code></pre></div></div><div class=paragraph><p>Todos os documentos são impressos nessa única impressora. Quando o departamento de vendas cresce o suficiente para precisar de sua própria impressora, o alias pode ser removido da entrada da impressora compartilhada e usado como o nome de uma nova impressora. Os usuários nos dois departamentos continuam usando os mesmos comandos, mas os documentos de vendas são enviados para a nova impressora.</p></div></div><div class=sect4><h5 id=printing-shared-headers>9.5.6.2. Páginas de cabeçalho<a class=anchor href=#printing-shared-headers></a></h5><div class=paragraph><p>Pode ser difícil para os usuários localizarem seus documentos na pilha de páginas produzidas por uma impressora compartilhada ocupada. <em>Páginas de cabeçalho</em> foram criadas para resolver este problema. Uma página de cabeçalho com o nome de usuário e o nome do documento é impressa antes de cada trabalho de impressão. Estas páginas são por vezes chamadas de páginas <em>banner</em> ou <em>separadoras</em>.</p></div><div class=paragraph><p>A ativação das páginas de cabeçalho é diferente, dependendo se a impressora está conectada diretamente ao computador com um cabo USB, paralelo ou serial, ou se está conectada remotamente por uma rede.</p></div><div class=paragraph><p>As páginas de cabeçalho em impressoras conectadas diretamente são ativadas removendo-se a linha <code>:sh:\</code> (Suprimir Cabeçalho) da entrada no <span class=filename>/etc/printcap</span>. Essas páginas de cabeçalho usam apenas caracteres de feed de linha para novas linhas. Algumas impressoras precisarão do filtro <span class=filename>/usr/shared/examples/printing/hpif</span> para evitar imprimir o texto em escada. O filtro configura impressoras PCL para imprimir retornos de carro e alimentações de linha quando um feed de linha é recebido.</p></div><div class=paragraph><p>As páginas de cabeçalho das impressoras de rede devem ser configuradas na própria impressora. Entradas de página de cabeçalho no <span class=filename>/etc/printcap</span> são ignoradas. As configurações geralmente estão disponíveis no painel frontal da impressora ou em uma página da web de configuração acessível com um navegador da web.</p></div></div></div><div class=sect3><h4 id=printing-lpd-references>9.5.7. Referências<a class=anchor href=#printing-lpd-references></a></h4><div class=paragraph><p>Arquivos de exemplo: <span class=filename>/usr/shared/examples/printing/</span>.</p></div><div class=paragraph><p>O <em>Manual do Spooler de Impressora de Linha do 4.3BSD</em>, <span class=filename>/usr/shared/doc/smm/07.lpd/paper.ascii.gz</span>.</p></div><div class=paragraph><p>Páginas de manual: <a href="https://man.freebsd.org/cgi/man.cgi?query=printcap&amp;sektion=5&amp;format=html">printcap(5)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=lpd&amp;sektion=8&amp;format=html">lpd(8)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=lpr&amp;sektion=1&amp;format=html">lpr(1)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=lpc&amp;sektion=8&amp;format=html">lpc(8)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=lprm&amp;sektion=1&amp;format=html">lprm(1)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=lpq&amp;sektion=1&amp;format=html">lpq(1)</a>.</p></div></div></div><div class=sect2><h3 id=printing-other>9.6. Outros sistemas de impressão<a class=anchor href=#printing-other></a></h3><div class=paragraph><p>Vários outros sistemas de impressão estão disponíveis, além do <a href="https://man.freebsd.org/cgi/man.cgi?query=lpd&amp;sektion=8&amp;format=html">lpd(8)</a>. Esses sistemas oferecem suporte para outros protocolos ou recursos adicionais.</p></div><div class=sect3><h4 id=printing-other-cups>9.6.1. CUPS (Sistema de impressão comum UNIX™)<a class=anchor href=#printing-other-cups></a></h4><div class=paragraph><p>O CUPS é um sistema de impressão popular disponível em muitos sistemas operacionais. Usar o CUPS no FreeBSD está documentado em um artigo separado: <a href=https://docs.freebsd.org/pt-br/articles/cups/>CUPS</a></p></div></div><div class=sect3><h4 id=printing-other-hplip>9.6.2. HPLIP<a class=anchor href=#printing-other-hplip></a></h4><div class=paragraph><p>A Hewlett Packard fornece um sistema de impressão que suporta muitas de suas impressoras a jato de tinta e laser. O port é o <a class=package href=https://cgit.freebsd.org/ports/tree/print/hplip/>print/hplip</a>. A página principal da web está em <a href=http://hplipopensource.com/hplip-web/index.html class=bare>http://hplipopensource.com/hplip-web/index.html</a>. O port lida com todos os detalhes de instalação no FreeBSD. As informações de configuração são mostradas em <a href=http://hplipopensource.com/hplip-web/install/manual/hp_setup.html class=bare>http://hplipopensource.com/hplip-web/install/manual/hp_setup.html</a>.</p></div></div><div class=sect3><h4 id=printing-other-lprng>9.6.3. LPRng<a class=anchor href=#printing-other-lprng></a></h4><div class=paragraph><p>O LPRng foi desenvolvido como uma alternativa aprimorada para o <a href="https://man.freebsd.org/cgi/man.cgi?query=lpd&amp;sektion=8&amp;format=html">lpd(8)</a>. O port é <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/LPRng/>sysutils/LPRng</a>. Para detalhes e documentação, veja <a href=https://lprng.sourceforge.net/ class=bare>https://lprng.sourceforge.net/</a>.</p></div></div></div></div></div><div class=sect1><h2 id=linuxemu>Capítulo 10. Compatibilidade binária com o Linux®<a class=anchor href=#linuxemu></a></h2><div class=sectionbody><div class=sect2><h3 id=linuxemu-synopsis>10.1. Sinopse<a class=anchor href=#linuxemu-synopsis></a></h3><div class=paragraph><p>O FreeBSD fornece compatibilidade binária com o Linux™, permitindo que os usuários instalem e executem a maioria dos binários do Linux™ em um sistema FreeBSD sem ter que primeiro modificar o binário. Foi até relatado que, em algumas situações, os binários Linux™ têm melhor desempenho no FreeBSD do que no Linux™.</p></div><div class=paragraph><p>No entanto, alguns recursos do sistema operacional específicos do Linux™ não são suportados no FreeBSD. Por exemplo, os binários Linux™ não funcionarão no FreeBSD se usarem chamadas específicas i386™, mesmo ativando o modo 8086 virtual.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>O suporte para compatibilidade binária de 64 bits com o Linux™ foi adicionado no FreeBSD 10.3.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Depois de ler este capítulo, você saberá:</p></div><div class=ulist><ul><li><p>Como habilitar a compatibilidade binária com o Linux™ em um sistema FreeBSD.</p></li><li><p>Como instalar bibliotecas compartilhadas adicionais do Linux™.</p></li><li><p>Como instalar aplicativos Linux™ em um sistema FreeBSD.</p></li><li><p>Os detalhes de implementação da compatibilidade com o Linux™ no FreeBSD.</p></li></ul></div><div class=paragraph><p>Antes de ler este capítulo, você deve:</p></div><div class=ulist><ul><li><p>Saiber como instalar <a href=./#ports>software adicional de terceiros</a>.</p></li></ul></div></div><div class=sect2><h3 id=linuxemu-lbc-install>10.2. Configurando a compatibilidade binária com o Linux™<a class=anchor href=#linuxemu-lbc-install></a></h3><div class=paragraph><p>Por padrão, as bibliotecas do Linux™ não estão instaladas e a compatibilidade binária com o Linux™ não está ativada. As bibliotecas Linux™ podem ser instaladas manualmente ou a partir da coleção de Ports do FreeBSD.</p></div><div class=paragraph><p>Antes de tentar compilar o port, carregue o módulo de kernel Linux™, caso contrário a compilação irá falhar:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload linux</span></code></pre></div></div><div class=paragraph><p>Para compatibilidade com 64 bits:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload linux64</span></code></pre></div></div><div class=paragraph><p>Para verificar se o módulo está carregado:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% kldstat
      Id Refs Address    Size     Name
      1    2 0xc0100000 16bdb8   kernel
      7    1 0xc24db000 d000     linux.ko</code></pre></div></div><div class=paragraph><p>O pacote ou port <a class=package href=https://cgit.freebsd.org/ports/tree/emulators/linux_base-c7/>emulators/linux_base-c7</a> é a maneira mais fácil de instalar um conjunto básico de bibliotecas e binários do Linux™ em um sistema FreeBSD. Para instalar o port:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install emulators/linux_base-c7</span></code></pre></div></div><div class=paragraph><p>Para que a compatibilidade com o Linux™ seja ativada durante a inicialização, adicione esta linha ao <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>linux_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Em máquinas de 64 bits, o <span class=filename>/etc/rc.d/abi</span> carregará automaticamente o módulo para emulação de 64 bits.</p></div><div class=paragraph><p>Como a camada de compatibilidade binária do Linux™ ganhou suporte para a execução de binários Linux™ de 32 e 64 bits (em hosts x86 de 64 bits), não é mais possível vincular estaticamente a funcionalidade de emulação a um kernel personalizado.</p></div><div class=sect3><h4 id=linuxemu-libs-manually>10.2.1. Instalando Bibliotecas Adicionais Manualmente<a class=anchor href=#linuxemu-libs-manually></a></h4><div class=paragraph><p>Se um aplicativo Linux™ reclamar sobre a falta de bibliotecas compartilhadas após configurar a compatibilidade binária do Linux™, determine quais bibliotecas compartilhadas o Linux™ precisa e instale-as manualmente.</p></div><div class=paragraph><p>A partir de um sistema Linux™, o <code>ldd</code> pode ser usado para determinar quais bibliotecas compartilhadas o aplicativo precisa. Por exemplo, para verificar quais bibliotecas compartilhadas o <code>linuxdoom</code> precisa, execute este comando a partir de um sistema Linux™ que tenha o Doom instalado:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ldd linuxdoom
libXt.so.3 <span class=o>(</span>DLL Jump 3.1<span class=o>)</span> <span class=o>=&gt;</span> /usr/X11/lib/libXt.so.3.1.0
libX11.so.3 <span class=o>(</span>DLL Jump 3.1<span class=o>)</span> <span class=o>=&gt;</span> /usr/X11/lib/libX11.so.3.1.0
libc.so.4 <span class=o>(</span>DLL Jump 4.5pl26<span class=o>)</span> <span class=o>=&gt;</span> /lib/libc.so.4.6.29</code></pre></div></div><div class=paragraph><p>Então, copie todos os arquivos listados na última coluna da saída do comando no sistema Linux™ para o diretório <span class=filename>/compat/linux</span> no sistema FreeBSD. Depois de copiados, crie links simbólicos para os nomes na primeira coluna. Este exemplo irá resultar nos seguintes arquivos no sistema FreeBSD:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>/compat/linux/usr/X11/lib/libXt.so.3.1.0
/compat/linux/usr/X11/lib/libXt.so.3 -&gt; libXt.so.3.1.0
/compat/linux/usr/X11/lib/libX11.so.3.1.0
/compat/linux/usr/X11/lib/libX11.so.3 -&gt; libX11.so.3.1.0
/compat/linux/lib/libc.so.4.6.29
/compat/linux/lib/libc.so.4 -&gt; libc.so.4.6.29</code></pre></div></div><div class=paragraph><p>Se uma biblioteca compartilhada Linux™ já existir com um número de revisão principal correspondente à primeira coluna da saída do comando <code>ldd</code>, ela não precisará ser copiada para a arquivo nomeado na última coluna, pois a biblioteca existente deve funcionar. No entanto é aconselhável copiar a biblioteca compartilhada se for uma versão mais nova. O arquivo antigo pode ser removido, desde que o link simbólico aponte para o novo.</p></div><div class=paragraph><p>Por exemplo, essas bibliotecas já existem no sistema FreeBSD:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>/compat/linux/lib/libc.so.4.6.27
/compat/linux/lib/libc.so.4 -&gt; libc.so.4.6.27</code></pre></div></div><div class=paragraph><p>e o <code>ldd</code> indica que um binário requer uma versão posterior:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>libc.so.4 <span class=o>(</span>DLL Jump 4.5pl26<span class=o>)</span> -&gt; libc.so.4.6.29</code></pre></div></div><div class=paragraph><p>Como a biblioteca existente tem apenas uma ou duas versões desatualizadas no último dígito, o programa ainda deve funcionar com a versão um pouco mais antiga. No entanto, é seguro substituir o <span class=filename>libc.so</span> existente pela versão mais nova:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>/compat/linux/lib/libc.so.4.6.29
/compat/linux/lib/libc.so.4 -&gt; libc.so.4.6.29</code></pre></div></div><div class=paragraph><p>Geralmente, será necessário procurar as bibliotecas compartilhadas que os binários do Linux™ dependem apenas das primeiras vezes que um programa Linux™ é instalado no FreeBSD. Depois de um tempo, haverá um conjunto suficiente de bibliotecas Linux™ compartilhadas no sistema para poder executar binários Linux™ atualizados sem qualquer trabalho extra.</p></div></div><div class=sect3><h4 id=_instalando_os_binários_linuxelf>10.2.2. Instalando os binários Linux™ELF<a class=anchor href=#_instalando_os_binários_linuxelf></a></h4><div class=paragraph><p>Os binários ELF requerem por vezes um passo extra. Quando um binário ELF sem marca for executado, ele gerará uma mensagem de erro:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ./my-linux-elf-binary
ELF binary <span class=nb>type </span>not known
Abort</code></pre></div></div><div class=paragraph><p>Para ajudar o kernel do FreeBSD a distinguir entre um binário do FreeBSD ELF e um binário Linux™, use <a href="https://man.freebsd.org/cgi/man.cgi?query=brandelf&amp;sektion=1&amp;format=html">brandelf(1)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% brandelf <span class=nt>-t</span> Linux my-linux-elf-binary</code></pre></div></div><div class=paragraph><p>Como o conjunto de ferramentas GNU coloca as informações de branding apropriadas em binários ELF automaticamente, essa etapa geralmente não é necessária.</p></div></div><div class=sect3><h4 id=_instalando_um_aplicativo_baseado_em_linuxrpm>10.2.3. Instalando um aplicativo baseado em Linux™RPM<a class=anchor href=#_instalando_um_aplicativo_baseado_em_linuxrpm></a></h4><div class=paragraph><p>Para instalar um aplicativo baseado em Linux™RPM, primeiro instale o pacote ou o port <a class=package href=https://cgit.freebsd.org/ports/tree/archivers/rpm4/>archivers/rpm4</a>. Uma vez instalado, o usuário <code>root</code> pode usar este comando para instalar um <span class=filename>.rpm</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /compat/linux</span>
<span class=c># rpm2cpio &lt; /path/to/linux.archive.rpm | cpio -id</span></code></pre></div></div><div class=paragraph><p>Se necessário, use o <code>brandelf</code> nos binários ELF instalados . Observe que isso impedirá uma desinstalação limpa.</p></div></div><div class=sect3><h4 id=_configurando_o_resolver_do_hostname>10.2.4. Configurando o Resolver do Hostname<a class=anchor href=#_configurando_o_resolver_do_hostname></a></h4><div class=paragraph><p>Se o DNS não funcionar ou este erro aparecer:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>resolv+: <span class=s2>&#34;bind&#34;</span> is an invalid keyword resolv+:
<span class=s2>&#34;hosts&#34;</span> is an invalid keyword</code></pre></div></div><div class=paragraph><p>configure o <span class=filename>/compat/linux/etc/host.conf</span> como segue:</p></div><div class="literalblock programlisting"><div class=content><pre>order hosts, bind
multi on</pre></div></div><div class=paragraph><p>Isso especifica que o <span class=filename>/etc/hosts</span> deve ser pesquisado primeiro e o DNS deve ser pesquisado em segundo lugar. Quando o <span class=filename>/compat/linux/etc/host.conf</span> não existe, os aplicativos Linux™ usam o <span class=filename>/etc/host.conf</span> e avisam sobre a sintaxe incompatível do FreeBSD. Remova o <code>bind</code> se um servidor de nomes não estiver configurado usando o <span class=filename>/etc/resolv.conf</span>.</p></div></div></div><div class=sect2><h3 id=linuxemu-advanced>10.3. Tópicos Avançados<a class=anchor href=#linuxemu-advanced></a></h3><div class=paragraph><p>Esta seção descreve como funciona a compatibilidade binária com o Linux™ e é baseada em um email escrito para <a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-chat>Lista de discussão do chat do FreeBSD</a> por Terry Lambert <a href=mailto:tlambert@primenet.com>tlambert@primenet.com</a> (Message ID: <code>&lt;<a href=mailto:199906020108.SAA07001@usr09.primenet.com>199906020108.SAA07001@usr09.primenet.com</a>></code>).</p></div><div class=paragraph><p>O FreeBSD tem uma abstração chamada "loader de classes de execução". Esta é uma cunha na chamada de sistema <a href="https://man.freebsd.org/cgi/man.cgi?query=execve&amp;sektion=2&amp;format=html">execve(2)</a> .</p></div><div class=paragraph><p>Historicamente, o loader UNIX™ examinava o número mágico (geralmente os primeiros 4 ou 8 bytes do arquivo) para ver se era um binário conhecido pelo sistema e, em caso afirmativo, invocava o loader binário.</p></div><div class=paragraph><p>Se o arquivo não fosse o tipo binário adequado para o sistema, a chamada <a href="https://man.freebsd.org/cgi/man.cgi?query=execve&amp;sektion=2&amp;format=html">execve(2)</a> retornava uma falha, e o shell tentava iniciar a execução do mesmo como um comando do shell. A suposição era um padrão de "qualquer que seja o shell atual".</p></div><div class=paragraph><p>Posteriormente, foi feito um hack para que o <a href="https://man.freebsd.org/cgi/man.cgi?query=sh&amp;sektion=1&amp;format=html">sh(1)</a> examinasse os dois primeiros caracteres e se eles fossem <code>:\n</code>, ele invocava o shell <a href="https://man.freebsd.org/cgi/man.cgi?query=csh&amp;sektion=1&amp;format=html">csh(1)</a> em seu lugar.</p></div><div class=paragraph><p>O FreeBSD tem uma lista de loaders, em vez de um único loader, com um fallback para o loader <code>#!</code> para executar interpretadores de shell ou scripts de shell.</p></div><div class=paragraph><p>Para o suporte ao Linux™ABI, o FreeBSD vê o número mágico como um binário ELF. O loader ELF procura por uma <em>marca</em> especializada, que é uma seção de comentários na imagem ELF e que não esteja presente nos binários ELF SVR4/Solaris™.</p></div><div class=paragraph><p>Para que os binários Linux™ funcionem, eles devem ser <em>marcados</em> como tipo <code>Linux</code> usando o comando <a href="https://man.freebsd.org/cgi/man.cgi?query=brandelf&amp;sektion=1&amp;format=html">brandelf(1)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># brandelf -t Linux file</span></code></pre></div></div><div class=paragraph><p>Quando o loader ELF vê a marca <code>Linux</code>, ele substitui um ponteiro na estrutura <code>proc</code>. Todas as chamadas do sistema são indexadas por esse ponteiro. Além disso, o processo é sinalizado para manipulação especial do vetor trap para o código de trampolim de sinal, e vários outros (menores) reparos que são manipulados pelo módulo do kernel Linux™.</p></div><div class=paragraph><p>O vetor de chamada do sistema Linux™ contém, entre outras coisas, uma lista de entradas <code>sysent[]</code> cujos endereços residem no módulo do kernel.</p></div><div class=paragraph><p>Quando uma chamada de sistema é acionada pelo binário Linux™, o código de interceptação desreferencia o ponteiro de função de chamada do sistema da estrutura <code>proc</code> e obtém a classe Linux™, não a FreeBSD, como ponto de entrada para a chamada do sistema.</p></div><div class=paragraph><p>O modo Linux™ procura fazer <em>reroots</em> dinamicamente. Isso é, na verdade, equivalente ao <code>union</code> para montagens de sistema de arquivos. Primeiro, é feita uma tentativa de procurar o arquivo em <span class=filename>/compat/linux/original-path</span>. Se isso falhar, a pesquisa será feita em <span class=filename>/original-path</span>. Isso garante que os binários que exigem outros binários possam ser executados. Por exemplo, o conjunto de ferramentas Linux™ pode ser executado sob o suporte da Linux™ABI. Isso também significa que os binários Linux™ podem carregar e executar binários do FreeBSD, se não houver binários Linux™ correspondentes, e que o comando <a href="https://man.freebsd.org/cgi/man.cgi?query=uname&amp;sektion=1&amp;format=html">uname(1)</a> pode ser colocado na árvore de diretórios <span class=filename>/compat/linux</span> para garantir que os binários Linux™ não possam dizer que não estão rodando em Linux™.</p></div><div class=paragraph><p>De fato, existe um kernel Linux™ no kernel do FreeBSD. As várias funções subjacentes que implementam todos os serviços fornecidos pelo kernel são idênticas às entradas da tabela de chamada do sistema FreeBSD, e às entradas da tabela de chamada do sistema Linux™: operações do sistema de arquivos, operações de memória virtual, entrega de sinal e System V IPC. A única diferença é que os binários do FreeBSD obtêm as funções de <em>cola</em> do FreeBSD, e os binários Linux™ recebem as funções de <em>cola</em> do Linux™. As funções de <em>cola</em> do FreeBSD estão estaticamente ligadas ao kernel, e as funções de <em>cola</em> do Linux ™ podem ser estaticamente ligadas, ou podem ser acessadas através de um módulo do kernel.</p></div><div class=paragraph><p>Tecnicamente, isso não é realmente emulação, é uma implementação de ABI. Às vezes é chamado de "emulação™ Linux " porque a implementação foi feita num momento em que não havia outra palavra para descrever o que estava acontecendo. Dizer que o FreeBSD executava os binários do Linux™ não era verdade, já que o código não era compilado nele.</p></div></div></div></div><h1 id=system-administration class=sect0>Parte III: Administração do Sistema<a class=anchor href=#system-administration></a></h1><div class="openblock partintro"><div class=content><div class=paragraph><p>Os capítulos restantes cobrem todos os aspectos da administração do sistema FreeBSD. Cada capítulo começa descrevendo o que será aprendido como resultado da leitura do capítulo e também detalha o que o leitor deve saber antes de abordar o material.</p></div><div class=paragraph><p>Estes capítulos são projetados para serem lidos conforme as informações são necessárias. Eles não precisam ser lidos em nenhuma ordem específica, nem todos precisam ser lidos antes de começar a usar o FreeBSD.</p></div></div></div><div class=sect1><h2 id=config-tuning>Capítulo 11. Configuração e Ajuste<a class=anchor href=#config-tuning></a></h2><div class=sectionbody><div class=sect2><h3 id=config-synopsis>11.1. Sinopse<a class=anchor href=#config-synopsis></a></h3><div class=paragraph><p>Um dos aspectos importantes do FreeBSD é a configuração adequada do sistema. Este capítulo explica muito do processo de configuração do FreeBSD, incluindo alguns dos parâmetros que podem ser configurados para ajustar um sistema FreeBSD.</p></div><div class=paragraph><p>Depois de ler este capítulo, você saberá:</p></div><div class=ulist><ul><li><p>O básico da configuração do <span class=filename>rc.conf</span> e dos scripts de inicialização <span class=filename>/usr/local/etc/rc.d</span>.</p></li><li><p>Como configurar e testar uma placa de rede.</p></li><li><p>Como configurar hosts virtuais em dispositivos de rede.</p></li><li><p>Como usar os vários arquivos de configuração em <span class=filename>/etc</span>.</p></li><li><p>Como ajustar o FreeBSD usando variáveis <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a>.</p></li><li><p>Como ajustar o desempenho do disco e modificar as limitações do kernel.</p></li></ul></div><div class=paragraph><p>Antes de ler este capítulo, você deve:</p></div><div class=ulist><ul><li><p>Entender os fundamentos do UNIX™ e do FreeBSD (<a href=./#basics>Fundamentos do FreeBSD</a>).</p></li><li><p>Estar familiarizado com os conceitos básicos de configuração e compilação do kernel (<a href=./#kernelconfig>Configurando o kernel do FreeBSD</a>).</p></li></ul></div></div><div class=sect2><h3 id=configtuning-starting-services>11.2. Inicialização de Serviços<a class=anchor href=#configtuning-starting-services></a></h3><div class=paragraph><p>Muitos usuários instalam software de terceiros no FreeBSD a partir da coleção de Ports e precisam que os serviços instalados sejam iniciados durante a inicialização do sistema. Serviços como <a class=package href=https://cgit.freebsd.org/ports/tree/mail/postfix/>mail/postfix</a> ou <a class=package href=https://cgit.freebsd.org/ports/tree/www/apache22/>www/apache22</a> são apenas dois dos muitos pacotes de software que podem ser iniciados durante a inicialização do sistema. Esta seção explica os procedimentos disponíveis para iniciar o software de terceiros.</p></div><div class=paragraph><p>No FreeBSD, a maioria dos serviços incluídos, como o <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a>, são iniciados através dos scripts de inicialização do sistema.</p></div><div class=sect3><h4 id=_configuração_estendida_dos_aplicativos>11.2.1. Configuração Estendida dos Aplicativos<a class=anchor href=#_configuração_estendida_dos_aplicativos></a></h4><div class=paragraph><p>Agora que o FreeBSD inclui o <span class=filename>rc.d</span>, a configuração da inicialização do aplicativo é mais fácil e fornece mais recursos. Usando as palavras-chave discutidas em <a href=#configtuning-rcd>Gerenciando Serviços no FreeBSD</a>, os aplicativos podem ser configurados para iniciar depois de certos outros serviços e flags extras poderem ser passadas através do <span class=filename>/etc/rc.conf</span> no lugar de sinalizadores codificados no script de inicialização. Um script básico pode ser semelhante ao seguinte:</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
#
# PROVIDE: utility
# REQUIRE: DAEMON
# KEYWORD: shutdown

. /etc/rc.subr

name=utility
rcvar=utility_enable

command=&#34;/usr/local/sbin/utility&#34;

load_rc_config $name

#
# DO NOT CHANGE THESE DEFAULT VALUES HERE
# SET THEM IN THE /etc/rc.conf FILE
#
utility_enable=${utility_enable-&#34;NO&#34;}
pidfile=${utility_pidfile-&#34;/var/run/utility.pid&#34;}

run_rc_command &#34;$1&#34;</pre></div></div><div class=paragraph><p>Este script irá garantir que o <code>utilitário</code> fornecido será iniciado após o pseudo-serviço <code>DAEMON</code>. Ele também fornece um método para definir e rastrear o ID do processo (PID).</p></div><div class=paragraph><p>Esta aplicação poderia então ter a seguinte linha colocada no <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>utility_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Este método permite a manipulação mais fácil de argumentos de linha de comando, inclusão das funções padrões fornecidas em <span class=filename>/etc/rc.subr</span>, compatibilidade com o <a href="https://man.freebsd.org/cgi/man.cgi?query=rcorder&amp;sektion=8&amp;format=html">rcorder(8)</a>, e fornece uma configuração mais fácil via <span class=filename>rc.conf</span>.</p></div></div><div class=sect3><h4 id=_usando_o_services_para_inicializar_serviços>11.2.2. Usando o Services para Inicializar Serviços<a class=anchor href=#_usando_o_services_para_inicializar_serviços></a></h4><div class=paragraph><p>Outros serviços podem ser iniciados usando o <a href="https://man.freebsd.org/cgi/man.cgi?query=inetd&amp;sektion=8&amp;format=html">inetd(8)</a>. O uso do <a href="https://man.freebsd.org/cgi/man.cgi?query=inetd&amp;sektion=8&amp;format=html">inetd(8)</a> e sua configuração é descrita em profundidade em <a href=./#network-inetd>O super-servidor inetd</a>.</p></div><div class=paragraph><p>Em alguns casos, pode fazer mais sentido usar o <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a> para iniciar os serviços do sistema. Esta abordagem tem várias vantagens, pois o <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a> executa estes processos como o proprietário do <a href="https://man.freebsd.org/cgi/man.cgi?query=crontab&amp;sektion=5&amp;format=html">crontab(5)</a>. Isto permite que usuários regulares iniciem e mantenham seus próprios aplicativos.</p></div><div class=paragraph><p>O recurso <code>@reboot</code> do <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a>, pode ser usado no lugar da especificação de hora. Isso faz com que o job seja executado quando <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a> é iniciado, normalmente durante a inicialização do sistema.</p></div></div></div><div class=sect2><h3 id=configtuning-cron>11.3. Configurando o <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a><a class=anchor href=#configtuning-cron></a></h3><div class=paragraph><p>Um dos utilitários mais úteis no FreeBSD é o cron. Este utilitário é executado em segundo plano e verifica regularmente o <span class=filename>/etc/crontab</span> para que as tarefas sejam executadas e procura <span class=filename>/var/cron/tabs</span> para arquivos crontab personalizados. Estes arquivos são usados para planejar tarefas que o cron executa nos horários especificados. Cada entrada em um crontab define uma tarefa para ser executada e é conhecida como uma <em>tarefa do cron</em>.</p></div><div class=paragraph><p>Dois tipos diferentes de arquivos de configuração são usados: o crontab do sistema, que não deve ser modificado, e crontabs de usuário, que podem ser criados e editados conforme necessário. O formato usado por esses arquivos está documentado em <a href="https://man.freebsd.org/cgi/man.cgi?query=crontab&amp;sektion=5&amp;format=html">crontab(5)</a>. O formato do sistema crontab, <span class=filename>/etc/crontab</span> inclui uma coluna <code>who</code> que não existe nos crontabs de usuário. No crontab do sistema , o cron executa o comando como o usuário especificado nesta coluna. Em um crontab de usuário, todos os comandos são executados como o usuário que criou o crontab.</p></div><div class=paragraph><p>Os crontabs de usuário permitem que usuários individuais programem suas próprias tarefas. O usuário <code>root</code> também pode ter um <span class=filename>crontab</span> de usuário que pode ser usado para agendar tarefas que não existem no <span class=filename>crontab</span> do sistema .</p></div><div class=paragraph><p>Aqui está uma entrada de amostra do crontab do sistema, <span class=filename>/etc/crontab</span>:</p></div><div class="literalblock programlisting"><div class=content><pre># /etc/crontab - root&#39;s crontab for FreeBSD
#
# $FreeBSD: head/pt_BR.ISO8859-1/books/handbook/book.xml 53984 2020-03-15 16:03:31Z dbaio $
#<i class=conum data-value=1></i><b>(1)</b>
SHELL=/bin/sh
PATH=/etc:/bin:/sbin:/usr/bin:/usr/sbin <i class=conum data-value=2></i><b>(2)</b>
#
#minute	hour	mday	month	wday	who	command <i class=conum data-value=3></i><b>(3)</b>
#
*/5	*	*	*	*	root	/usr/libexec/atrun <i class=conum data-value=4></i><b>(4)</b></pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>Linhas que começam com o caractere <code>#</code> são comentários. Um comentário pode ser colocado no arquivo como um lembrete do que uma ação faz e do porque a sua execução é desejada. Comentários não podem estar na mesma linha que um comando ou então serão interpretados como parte do comando; eles devem estar em uma nova linha. Linhas em branco são ignoradas.</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td>O caractere igual (<code>=</code>) é usado para definir qualquer configuração de ambiente. Neste exemplo, ele é usado para definir o <code>SHELL</code> e o <code>PATH</code>. Se o <code>SHELL</code> for omitido, o cron usará o shell Bourne padrão. Se o <code>PATH</code> for omitido, o caminho completo deverá ser fornecido ao comando ou script a ser executado.</td></tr><tr><td><i class=conum data-value=3></i><b>3</b></td><td>Esta linha define os sete campos usados em um crontab do sistema: <code>minute</code>, <code>hora</code>, <code>mday</code>, <code>month</code>, <code>wday</code>, <code>who</code> e <code>command</code>. O campo <code>minute</code> é o tempo em minutos quando o comando especificado será executado, a <code>hour</code> é a hora em que o comando especificado será executado, o <code>mday</code> é o dia do mês, <code>month</code> é o mês e <code>wday</code> é o dia da semana. Estes campos devem ser valores numéricos, representando o relógio de vinte e quatro horas, ou um <code>*</code>, representando todos os valores desse campo. O campo <code>who</code> existe somente no crontab do sistema e especifica com qual usuário o comando deve ser executado. O último campo é o comando a ser executado.</td></tr><tr><td><i class=conum data-value=4></i><b>4</b></td><td>Esta entrada define os valores para este trabalho do cron. O <code><strong>/5</strong></code><strong>, seguido por vários outros caracteres <code></code></strong>, especifica que <code>/usr/libexec/atrun</code> é invocado pelo <code>root</code> a cada cinco minutos de cada hora, de cada dia e dia da semana, de cada mês.Comandos podem incluir qualquer número de opções. No entanto, os comandos que se estendem a várias linhas precisam ser quebrados com o caractere de continuação da barra invertida "\".</td></tr></tbody></table></div><div class=sect3><h4 id=configtuning-installcrontab>11.3.1. Criando um Crontab de Usuário<a class=anchor href=#configtuning-installcrontab></a></h4><div class=paragraph><p>Para criar um crontab de usuário, invoque o <code>crontab</code> no modo editor:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% crontab <span class=nt>-e</span></code></pre></div></div><div class=paragraph><p>Isto irá abrir o crontab do usuário usando o editor de texto padrão. A primeira vez que um usuário executa este comando, ele abre um arquivo vazio. Depois que um usuário cria um crontab, esse comando abrirá este arquivo para edição.</p></div><div class=paragraph><p>É útil adicionar estas linhas a parte superior do arquivo crontab para configurar as variáveis de ambiente e lembrar os significados dos campos no crontab:</p></div><div class="literalblock programlisting"><div class=content><pre>SHELL=/bin/sh
PATH=/etc:/bin:/sbin:/usr/bin:/usr/sbin
# Order of crontab fields
# minute	hour	mday	month	wday	command</pre></div></div><div class=paragraph><p>Em seguida, adicione uma linha para cada comando ou script a ser executado, especificando o horário para executar o comando. Este exemplo executa o script de shell Bourne personalizado especificado todos os dias às duas da tarde. Como o caminho para o script não está especificado em <code>PATH</code>, o caminho completo para o script é fornecido:</p></div><div class="literalblock programlisting"><div class=content><pre>0	14	*	*	*	/usr/home/dru/bin/mycustomscript.sh</pre></div></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Antes de usar um script personalizado, verifique se ele é executável e teste-o com o conjunto limitado de variáveis de ambiente definidas pelo cron. Para replicar o ambiente que seria usado para executar a entrada do cron acima, use:</p></div><div class="literalblock programlisting"><div class=content><pre>env -i SHELL=/bin/sh PATH=/etc:/bin:/sbin:/usr/bin:/usr/sbin HOME=/home/dru LOGNAME=dru /usr/home/dru/bin/mycustomscript.sh</pre></div></div><div class=paragraph><p>O ambiente definido pelo cron é discutido em <a href="https://man.freebsd.org/cgi/man.cgi?query=crontab&amp;sektion=5&amp;format=html">crontab(5)</a>. Verificar se os scripts operam corretamente em um ambiente cron é especialmente importante se incluírem quaisquer comandos que excluam arquivos usando curingas.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Quando terminar de editar o crontab, salve o arquivo. Ele será instalado automaticamente e o cron lerá o crontab e executará seus cron jobs nos horários especificados. Para listar as tarefas agendadas em um crontab, use este comando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% crontab <span class=nt>-l</span>
0	14	<span class=k>*</span>	<span class=k>*</span>	<span class=k>*</span>	/usr/home/dru/bin/mycustomscript.sh</code></pre></div></div><div class=paragraph><p>Para remover todas as tarefas cron em um crontab de usuário:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% crontab <span class=nt>-r</span>
remove crontab <span class=k>for </span>dru? y</code></pre></div></div></div></div><div class=sect2><h3 id=configtuning-rcd>11.4. Gerenciando Serviços no FreeBSD<a class=anchor href=#configtuning-rcd></a></h3><div class=paragraph><p>O FreeBSD usa o sistema <a href="https://man.freebsd.org/cgi/man.cgi?query=rc&amp;sektion=8&amp;format=html">rc(8)</a> de scripts de inicialização durante a inicialização do sistema e para gerenciar serviços. Os scripts listados em <span class=filename>/etc/rc.d</span> fornecem serviços básicos que podem ser controlados com <code>start</code>, <code>stop</code> e <code>restart</code> opções para <a href="https://man.freebsd.org/cgi/man.cgi?query=service&amp;sektion=8&amp;format=html">service(8)</a>. Por exemplo, <a href="https://man.freebsd.org/cgi/man.cgi?query=sshd&amp;sektion=8&amp;format=html">sshd(8)</a> pode ser reiniciado com o seguinte comando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service sshd restart</span></code></pre></div></div><div class=paragraph><p>Este procedimento pode ser usado para iniciar serviços em um sistema em execução. Os serviços serão iniciados automaticamente no momento da inicialização, conforme especificado em <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a>. Por exemplo, para ativar o <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> na inicialização do sistema, adicione a seguinte linha ao <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>natd_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Se uma linha <code>natd_enable="NO"</code> já estiver presente, altere o <code>NO</code> para <code>YES</code>. Os scripts <a href="https://man.freebsd.org/cgi/man.cgi?query=rc&amp;sektion=8&amp;format=html">rc(8)</a> carregarão automaticamente todos os serviços dependentes durante a próxima inicialização, conforme descrito abaixo.</p></div><div class=paragraph><p>Como o sistema <a href="https://man.freebsd.org/cgi/man.cgi?query=rc&amp;sektion=8&amp;format=html">rc(8)</a> é destinado principalmente a iniciar e parar serviços na inicialização do sistema e no tempo de desligamento, o <code>start</code>, as opções <code>stop</code> e <code>restart</code> somente executarão suas ações se a variável apropriada estiver configurada no <span class=filename>/etc/rc.conf</span>. Por exemplo, o <code>sshd restart</code> só funcionará se <code>sshd_enable</code> estiver definido como <code>YES</code> em <span class=filename>/etc/rc.conf</span>. Para <code>iniciar</code>, <code>parar</code> ou <code>reiniciar</code> um serviço independente das configurações em <span class=filename>/etc/rc.conf</span>, estes comandos deve ser prefixado com "one". Por exemplo, para reiniciar <a href="https://man.freebsd.org/cgi/man.cgi?query=sshd&amp;sektion=8&amp;format=html">sshd(8)</a> independentemente da configuração atual do <span class=filename>/etc/rc.conf</span>, execute o seguinte comando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service sshd onerestart</span></code></pre></div></div><div class=paragraph><p>Para verificar se um serviço está habilitado em <span class=filename>/etc/rc.conf</span>, execute o script apropriado <a href="https://man.freebsd.org/cgi/man.cgi?query=rc&amp;sektion=8&amp;format=html">rc(8)</a> com <code>rcvar</code>. Este exemplo verifica se o <a href="https://man.freebsd.org/cgi/man.cgi?query=sshd&amp;sektion=8&amp;format=html">sshd(8)</a> está habilitado no <span class=filename>/etc/rc.conf</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service sshd rcvar</span>
<span class=c># sshd</span>
<span class=c>#</span>
<span class=nv>sshd_enable</span><span class=o>=</span><span class=s2>&#34;YES&#34;</span>
<span class=c>#   (default: &#34;&#34;)</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>A linha <code># sshd</code> é gerada pelo comando acima, não pelo console do <code>root</code>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Para determinar se um serviço está ou não em execução, use <code>status</code>. Por exemplo, para verificar se o <a href="https://man.freebsd.org/cgi/man.cgi?query=sshd&amp;sektion=8&amp;format=html">sshd(8)</a> está em execução:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service sshd status</span>
sshd is running as pid 433.</code></pre></div></div><div class=paragraph><p>Em alguns casos, também é possível fazer o <code>reload</code> denum serviço. Isso tenta enviar um sinal para um serviço individual, forçando o serviço a recarregar seus arquivos de configuração. Na maioria dos casos, isso significa enviar ao serviço um sinal <code>SIGHUP</code>. O suporte para esse recurso não está incluído para todos os serviços.</p></div><div class=paragraph><p>O sistema <a href="https://man.freebsd.org/cgi/man.cgi?query=rc&amp;sektion=8&amp;format=html">rc(8)</a> é usado para serviços de rede e também contribui para a maior parte da inicialização do sistema. Por exemplo, quando o script <span class=filename>/etc/rc.d/bgfsck</span> é executado, ele imprime a seguinte mensagem:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Starting background file system checks <span class=k>in </span>60 seconds.</code></pre></div></div><div class=paragraph><p>Esse script é usado para verificações do sistema de arquivos em segundo plano, que ocorrem apenas durante a inicialização do sistema.</p></div><div class=paragraph><p>Muitos serviços do sistema dependem de outros serviços para funcionar corretamente. Por exemplo, o <a href="https://man.freebsd.org/cgi/man.cgi?query=yp&amp;sektion=8&amp;format=html">yp(8)</a> e outros serviços baseados em RPC podem falhar ao iniciar até que o <a href="https://man.freebsd.org/cgi/man.cgi?query=rpcbind&amp;sektion=8&amp;format=html">rpcbind(8)</a> seja iniciado. Para resolver esse problema, informações sobre dependências e outros meta-dados são incluídas nos comentários na parte superior de cada script de inicialização. O programa <a href="https://man.freebsd.org/cgi/man.cgi?query=rcorder&amp;sektion=8&amp;format=html">rcorder(8)</a> é usado para analisar esses comentários durante a inicialização do sistema para determinar a ordem na qual os serviços do sistema devem ser invocados para satisfazer as dependências.</p></div><div class=paragraph><p>A seguinte palavra-chave deve ser incluída em todos os scripts de inicialização, conforme exigido pelo <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.subr&amp;sektion=8&amp;format=html">rc.subr(8)</a> para "habilitar" o script de inicialização:</p></div><div class=ulist><ul><li><p><code>PROVIDE</code>: Especifica os serviços que este arquivo fornece.</p></li></ul></div><div class=paragraph><p>As seguintes palavras-chave podem ser incluídas na parte superior de cada script de inicialização. Eles não são estritamente necessárias, mas são úteis como sugestões para <a href="https://man.freebsd.org/cgi/man.cgi?query=rcorder&amp;sektion=8&amp;format=html">rcorder(8)</a>:</p></div><div class=ulist><ul><li><p><code>REQUIRE</code>: lista os serviços necessários para este serviço. O script que contém esta palavra chave será executado <em>após</em> os serviços especificados.</p></li><li><p><code>BEFORE</code>: lista os serviços que dependem deste serviço. O script que contém esta palavra chave será executado <em>antes</em> dos serviços especificados.</p></li></ul></div><div class=paragraph><p>Ao definir cuidadosamente essas palavras-chave para cada script de inicialização, um administrador passa a ter um nível refinado de controle da ordem de inicialização dos scripts, sem a necessidade dos "runlevels" usados por alguns sistemas operacionais UNIX™.</p></div><div class=paragraph><p>Informações adicionais podem ser encontradas em <a href="https://man.freebsd.org/cgi/man.cgi?query=rc&amp;sektion=8&amp;format=html">rc(8)</a> e <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.subr&amp;sektion=8&amp;format=html">rc.subr(8)</a>. Consulte <a href=https://docs.freebsd.org/pt-br/articles/rc-scripting/>este artigo</a> para obter instruções sobre como criar um script <a href="https://man.freebsd.org/cgi/man.cgi?query=rc&amp;sektion=8&amp;format=html">rc(8)</a> personalizado.</p></div><div class=sect3><h4 id=configtuning-core-configuration>11.4.1. Gerenciando a configuração específica do sistema<a class=anchor href=#configtuning-core-configuration></a></h4><div class=paragraph><p>A localização principal das informações de configuração do sistema é arquivo <span class=filename>/etc/rc.conf</span>. Este arquivo contém uma ampla gama de informações de configuração e é lido na inicialização do sistema para configurar o sistema. Ele fornece as informações de configuração para os arquivos <span class=filename>rc*</span>.</p></div><div class=paragraph><p>As entradas em <span class=filename>/etc/rc.conf</span> substituem as configurações padrões em <span class=filename>/etc/defaults/rc.conf</span>. O arquivo contendo as configurações padrões não deve ser editado. Ao invés disso, todas as alterações específicas do sistema devem ser feitas em <span class=filename>/etc/rc.conf</span>.</p></div><div class=paragraph><p>Várias estratégias podem ser aplicadas em aplicativos em cluster para separar as configurações que afetam todo o site da configuração específica do sistema para reduzir a sobrecarga de administração. A abordagem recomendada é colocar a configuração específica do sistema em <span class=filename>/etc/rc.conf.local</span>. Por exemplo, estas entradas em <span class=filename>/etc/rc.conf</span> aplicam-se a todos os sistemas:</p></div><div class="literalblock programlisting"><div class=content><pre>sshd_enable=&#34;YES&#34;
keyrate=&#34;fast&#34;
defaultrouter=&#34;10.1.1.254&#34;</pre></div></div><div class=paragraph><p>Considerando que estas entradas em <span class=filename>/etc/rc.conf.local</span> se aplicam somente a este sistema:</p></div><div class="literalblock programlisting"><div class=content><pre>hostname=&#34;node1.example.org&#34;
ifconfig_fxp0=&#34;inet 10.1.1.1/8&#34;</pre></div></div><div class=paragraph><p>Distribua o <span class=filename>/etc/rc.conf</span> para cada sistema usando um aplicativo como o rsync ou o puppet, enquanto o <span class=filename>/etc/rc.conf.local</span> permanece único.</p></div><div class=paragraph><p>A atualização do sistema não sobrescreverá o <span class=filename>/etc/rc.conf</span>, portanto as informações de configuração do sistema não serão perdidas.</p></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Ambos <span class=filename>/etc/rc.conf</span> e <span class=filename>/etc/rc.conf.local</span> são analisados pelo <a href="https://man.freebsd.org/cgi/man.cgi?query=sh&amp;sektion=1&amp;format=html">sh(1)</a>. Isto permite que os operadores do sistema criem cenários de configuração complexos. Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a> para obter mais informações sobre este tópico.</p></div></td></tr></tbody></table></div></div></div><div class=sect2><h3 id=config-network-setup>11.5. Configurando Placas de Interface de Rede<a class=anchor href=#config-network-setup></a></h3><div class=paragraph><p>Adicionar e configurar uma placa de interface de rede (NIC) é uma tarefa comum para qualquer administrador do FreeBSD.</p></div><div class=sect3><h4 id=_localizando_o_driver_correto>11.5.1. Localizando o Driver Correto<a class=anchor href=#_localizando_o_driver_correto></a></h4><div class=paragraph><p>Primeiro, determine o modelo da NIC e o chip utilizado. O FreeBSD suporta uma ampla variedade de NICs. Verifique a lista de compatibilidade de hardware para a release do FreeBSD para ver se a NIC é suportada.</p></div><div class=paragraph><p>Se a NIC é suportada, determine o nome do driver do FreeBSD para a NIC. Consulte <span class=filename>/usr/src/sys/conf/NOTES</span> e <span class=filename>/usr/src/sys/arch/conf/NOTES</span> para a lista de Drivers NIC com algumas informações sobre os chipsets suportados. Em caso de dúvida, leia a página de manual do driver, pois ele fornecerá mais informações sobre o hardware suportado e quaisquer limitações conhecidas do driver.</p></div><div class=paragraph><p>Os drivers para as NICs comuns já estão presentes no kernel <span class=filename>GENERIC</span>, o que significa que a NIC deve ser verificada durante a inicialização. As mensagens de inicialização do sistema podem ser visualizadas digitando <code>more /var/run/dmesg.boot</code> e usando a barra de espaço para percorrer o texto. Neste exemplo, duas NICs Ethernet que utilizam o driver <a href="https://man.freebsd.org/cgi/man.cgi?query=dc&amp;sektion=4&amp;format=html">dc(4)</a> estão presentes no sistema:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>dc0: &lt;82c169 PNIC 10/100BaseTX&gt; port 0xa000-0xa0ff mem 0xd3800000-0xd38
000ff irq 15 at device 11.0 on pci0
miibus0: &lt;MII bus&gt; on dc0
bmtphy0: &lt;BCM5201 10/100baseTX PHY&gt; PHY 1 on miibus0
bmtphy0:  10baseT, 10baseT-FDX, 100baseTX, 100baseTX-FDX, auto
dc0: Ethernet address: 00:a0:cc:da:da:da
dc0: <span class=o>[</span>ITHREAD]
dc1: &lt;82c169 PNIC 10/100BaseTX&gt; port 0x9800-0x98ff mem 0xd3000000-0xd30
000ff irq 11 at device 12.0 on pci0
miibus1: &lt;MII bus&gt; on dc1
bmtphy1: &lt;BCM5201 10/100baseTX PHY&gt; PHY 1 on miibus1
bmtphy1:  10baseT, 10baseT-FDX, 100baseTX, 100baseTX-FDX, auto
dc1: Ethernet address: 00:a0:cc:da:da:db
dc1: <span class=o>[</span>ITHREAD]</code></pre></div></div><div class=paragraph><p>Se o driver da NIC não estiver presente em <span class=filename>GENERIC</span>, mas houver um driver disponível, o driver precisará ser carregado antes que a NIC possa ser configurada e usada. Isso pode ser feito de duas maneiras:</p></div><div class=ulist><ul><li><p>A maneira mais fácil é carregar um módulo do kernel para a NIC usando o <a href="https://man.freebsd.org/cgi/man.cgi?query=kldload&amp;sektion=8&amp;format=html">kldload(8)</a>. Para carregar automaticamente o driver no momento da inicialização, adicione a linha apropriada ao <span class=filename>/boot/loader.conf</span>. Nem todos os drivers NIC estão disponíveis como módulos.</p></li><li><p>Como alternativa, compile estaticamente o suporte para a NIC em um kernel personalizado. Consulte <span class=filename>/usr/src/sys/conf/NOTES</span>, <span class=filename>/usr/src/sys/arch/conf/NOTES</span> e a página de manual do driver para determinar qual linha adicionar ao arquivo de configuração do kernel personalizado. Para mais informações sobre como recompilar o kernel, consulte <a href=./#kernelconfig>Configurando o kernel do FreeBSD</a>. Se a NIC foi detectada na inicialização, o kernel não precisa ser recompilado.</p></li></ul></div><div class=sect4><h5 id=config-network-ndis>11.5.1.1. Utilizando os Drivers Windows™NDIS<a class=anchor href=#config-network-ndis></a></h5><div class=paragraph><p>Infelizmente, ainda existem muitos fornecedores que não fornecem esquemas para seus drivers para a comunidade de código aberto porque consideram essas informações como segredos comerciais. Consequentemente, os desenvolvedores do FreeBSD e de outros sistemas operacionais são deixados com duas opções: desenvolver os drivers por um processo longo e complexo de engenharia reversa ou usar os binários de drivers existentes disponíveis para plataforma Microsoft™ Windows™.</p></div><div class=paragraph><p>O FreeBSD fornece suporte "nativo" para a especificação de interface de driver de rede (NDIS). Ele inclui o <a href="https://man.freebsd.org/cgi/man.cgi?query=ndisgen&amp;sektion=8&amp;format=html">ndisgen(8)</a> que pode ser utilizado para converter um driver Windows™ XP num formato que pode ser usado no FreeBSD. Como o driver <a href="https://man.freebsd.org/cgi/man.cgi?query=ndis&amp;sektion=4&amp;format=html">ndis(4)</a> usa um binário Windows™ XP, ele só é executado em sistemas i386™ e amd64. Dispositivos PCI, CardBus, PCMCIA e USB são suportados.</p></div><div class=paragraph><p>Para usar o <a href="https://man.freebsd.org/cgi/man.cgi?query=ndisgen&amp;sektion=8&amp;format=html">ndisgen(8)</a>, três coisas são necessárias:</p></div><div class="olist arabic"><ol class=arabic><li><p>Código-fonte do kernel do FreeBSD.</p></li><li><p>Um binário do driver do Windows™ XP com uma extensão <span class=filename>.SYS</span>.</p></li><li><p>Um arquivo de configuração do driver do Windows™ XP com uma extensão <span class=filename>.INF</span>.</p></li></ol></div><div class=paragraph><p>Faça o download dos arquivos <span class=filename>.SYS</span> e <span class=filename>.INF</span> para a NIC específica. Geralmente, eles podem ser encontrados no CD do driver ou no site do fornecedor. Os exemplos a seguir usam o <span class=filename>W32DRIVER.SYS</span> e o <span class=filename>W32DRIVER.INF</span>.</p></div><div class=paragraph><p>A largura do bit do driver deve corresponder à versão do FreeBSD. Para FreeBSD/i386, use um driver de 32 bits Windows™. Para o FreeBSD/amd64, é necessário um driver de 64 bits do Windows™.</p></div><div class=paragraph><p>O próximo passo é compilar o binário do driver em um módulo do kernel carregável. Como <code>root</code>, use <a href="https://man.freebsd.org/cgi/man.cgi?query=ndisgen&amp;sektion=8&amp;format=html">ndisgen(8)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ndisgen /path/to/W32DRIVER.INF /path/to/W32DRIVER.SYS</span></code></pre></div></div><div class=paragraph><p>Este comando é interativo e solicita qualquer informação extra necessária. Um novo módulo do kernel será gerado no diretório atual. Use <a href="https://man.freebsd.org/cgi/man.cgi?query=kldload&amp;sektion=8&amp;format=html">kldload(8)</a> para carregar o novo módulo:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload ./W32DRIVER_SYS.ko</span></code></pre></div></div><div class=paragraph><p>Além do módulo do kernel gerado, os módulos <span class=filename>ndis.ko</span> e <span class=filename>if_ndis.ko</span> devem ser carregados. Isso deve acontecer automaticamente quando qualquer módulo que dependa do <a href="https://man.freebsd.org/cgi/man.cgi?query=ndis&amp;sektion=4&amp;format=html">ndis(4)</a> for carregado. Caso contrário, carregue-os manualmente, usando os seguintes comandos:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload ndis</span>
<span class=c># kldload if_ndis</span></code></pre></div></div><div class=paragraph><p>O primeiro comando carrega o wrapper do driver da miniporta <a href="https://man.freebsd.org/cgi/man.cgi?query=ndis&amp;sektion=4&amp;format=html">ndis(4)</a> e o segundo carrega o driver NIC gerado.</p></div><div class=paragraph><p>Execute o comando <a href="https://man.freebsd.org/cgi/man.cgi?query=dmesg&amp;sektion=8&amp;format=html">dmesg(8)</a> para ver se houve algum erro de carregamento. Se tudo correu bem, a saída deve ser semelhante à seguinte:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>ndis0: &lt;Wireless-G PCI Adapter&gt; mem 0xf4100000-0xf4101fff irq 3 at device 8.0 on pci1
ndis0: NDIS API version: 5.0
ndis0: Ethernet address: 0a:b1:2c:d3:4e:f5
ndis0: 11b rates: 1Mbps 2Mbps 5.5Mbps 11Mbps
ndis0: 11g rates: 6Mbps 9Mbps 12Mbps 18Mbps 36Mbps 48Mbps 54Mbps</code></pre></div></div><div class=paragraph><p>A partir daqui, o <span class=filename>ndis0</span> pode ser configurado como qualquer outra NIC.</p></div><div class=paragraph><p>Para configurar o sistema para carregar os módulos <a href="https://man.freebsd.org/cgi/man.cgi?query=ndis&amp;sektion=4&amp;format=html">ndis(4)</a> no momento da inicialização, copie o módulo gerado, <span class=filename>W32DRIVER_SYS.ko</span>, para <span class=filename>/boot/modules</span>. Em seguida, adicione a seguinte linha ao <span class=filename>/boot/loader.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>W32DRIVER_SYS_load=&#34;YES&#34;</pre></div></div></div></div><div class=sect3><h4 id=_configurando_a_placa_de_rede>11.5.2. Configurando a placa de rede<a class=anchor href=#_configurando_a_placa_de_rede></a></h4><div class=paragraph><p>Quando o driver correto é carregado para a NIC, a placa precisa ser configurada. Ele pode ter sido configurado no momento da instalação por <a href="https://man.freebsd.org/cgi/man.cgi?query=bsdinstall&amp;sektion=8&amp;format=html">bsdinstall(8)</a>.</p></div><div class=paragraph><p>Para exibir a configuração da NIC, digite o seguinte comando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ifconfig
dc0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        <span class=nv>options</span><span class=o>=</span>80008&lt;VLAN_MTU,LINKSTATE&gt;
        ether 00:a0:cc:da:da:da
        inet 192.168.1.3 netmask 0xffffff00 broadcast 192.168.1.255
        media: Ethernet autoselect <span class=o>(</span>100baseTX &lt;full-duplex&gt;<span class=o>)</span>
        status: active
dc1: <span class=nv>flags</span><span class=o>=</span>8802&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        <span class=nv>options</span><span class=o>=</span>80008&lt;VLAN_MTU,LINKSTATE&gt;
        ether 00:a0:cc:da:da:db
        inet 10.0.0.1 netmask 0xffffff00 broadcast 10.0.0.255
        media: Ethernet 10baseT/UTP
        status: no carrier
lo0: <span class=nv>flags</span><span class=o>=</span>8049&lt;UP,LOOPBACK,RUNNING,MULTICAST&gt; metric 0 mtu 16384
        <span class=nv>options</span><span class=o>=</span>3&lt;RXCSUM,TXCSUM&gt;
        inet6 fe80::1%lo0 prefixlen 64 scopeid 0x4
        inet6 ::1 prefixlen 128
        inet 127.0.0.1 netmask 0xff000000
        nd6 <span class=nv>options</span><span class=o>=</span>3&lt;PERFORMNUD,ACCEPT_RTADV&gt;</code></pre></div></div><div class=paragraph><p>Neste exemplo, os seguintes dispositivos foram exibidos:</p></div><div class=ulist><ul><li><p><span class=filename>dc0</span>: A primeira interface Ethernet.</p></li><li><p><span class=filename>dc1</span>: A segunda interface Ethernet.</p></li><li><p><span class=filename>lo0</span>: o dispositivo de loopback.</p></li></ul></div><div class=paragraph><p>O FreeBSD usa o nome do driver seguido da ordem em que a placa é detectada na inicialização para nomear a NIC. Por exemplo, <span class=filename>sis2</span> é a terceira NIC no sistema usando driver <a href="https://man.freebsd.org/cgi/man.cgi?query=sis&amp;sektion=4&amp;format=html">sis(4)</a>.</p></div><div class=paragraph><p>Neste exemplo, o <span class=filename>dc0</span> está ativo e em execução. Os principais indicadores são:</p></div><div class="olist arabic"><ol class=arabic><li><p><code>UP</code> significa que a placa está configurada e pronta.</p></li><li><p>A placa tem um endereço da Internet (<code>inet</code>), <code>192.168.1.3</code>.</p></li><li><p>Ela tem uma máscara de sub-rede válida (<code>netmask</code>), onde <code>0xffffff00</code> é o mesmo que <code>255.255.255.0</code> .</p></li><li><p>Tem um endereço de broadcast válido, <code>192.168.1.255</code>.</p></li><li><p>O endereço MAC da placa (<code>ether</code>) é <code>00:a0:cc:da:da:da</code>.</p></li><li><p>A seleção de mídia física está no modo de seleção automática (<code>media:Ethernet autoselect (100baseTX &lt;full-duplex>)</code>). Neste exemplo, o <span class=filename>dc1</span> está configurado para ser executado com a mídia <code>10baseT/UTP</code>. Para obter mais informações sobre tipos de mídia disponíveis para um driver, consulte sua página de manual.</p></li><li><p>O status do link (<code>status</code>) é <code>active</code>, indicando que o sinal da portadora foi detectado. Para <span class=filename>dc1</span>, o status <code>status: no carrier</code> é normal quando um cabo Ethernet não está conectado à placa.</p></li></ol></div><div class=paragraph><p>Se a saída <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a> tivesse mostrado algo semelhante a:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>dc0: <span class=nv>flags</span><span class=o>=</span>8843&lt;BROADCAST,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
	<span class=nv>options</span><span class=o>=</span>80008&lt;VLAN_MTU,LINKSTATE&gt;
	ether 00:a0:cc:da:da:da
	media: Ethernet autoselect <span class=o>(</span>100baseTX &lt;full-duplex&gt;<span class=o>)</span>
	status: active</code></pre></div></div><div class=paragraph><p>isso indicaria que a placa não foi configurada.</p></div><div class=paragraph><p>A placa deve ser configurada como <code>root</code>. A configuração da NIC pode ser realizada a partir da linha de comando com o <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a>, mas não persistirá após uma reinicialização, a menos que a configuração também seja adicionada ao <span class=filename>/etc/rc.conf</span>. Se um servidor DHCP estiver presente na LAN, basta adicionar esta linha:</p></div><div class="literalblock programlisting"><div class=content><pre>ifconfig_dc0=&#34;DHCP&#34;</pre></div></div><div class=paragraph><p>Substitua <em>dc0</em> com o valor correto para o sistema.</p></div><div class=paragraph><p>A linha adicionada, então, segue as instruções dadas em <a href=#config-network-testing>Teste e solução de problemas</a>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Se a rede foi configurada durante a instalação, algumas entradas para a NIC podem já estar presentes. Verifique novamente o <span class=filename>/etc/rc.conf</span> antes de adicionar novas linhas.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Se não existir um servidor DHCP, a NIC deve ser configurada manualmente. Adicione uma linha para cada NIC presente no sistema, conforme mostrado neste exemplo:</p></div><div class="literalblock programlisting"><div class=content><pre>ifconfig_dc0=&#34;inet 192.168.1.3 netmask 255.255.255.0&#34;
ifconfig_dc1=&#34;inet 10.0.0.1 netmask 255.255.255.0 media 10baseT/UTP&#34;</pre></div></div><div class=paragraph><p>Substitua <span class=filename>dc0</span> e <span class=filename>dc1</span> e as informações de endereço IP com os valores corretos para o sistema. Consulte a man page do driver, <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a> e <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a> para maiores detalhes sobre as opções permitidas e a sintaxe de <span class=filename>/etc/rc.conf</span>.</p></div><div class=paragraph><p>Se a rede não estiver usando DNS, edite o <span class=filename>/etc/hosts</span> para adicionar os nomes e endereços IP dos hosts na LAN, se eles ainda não estiverem lá. Para maiores informações, consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=hosts&amp;sektion=5&amp;format=html">hosts(5)</a> e <span class=filename>/usr/shared/examples/etc/hosts</span>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Se não houver um servidor DHCP e o acesso à Internet for necessário, configure manualmente o gateway padrão e o nameserver:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># echo &#39;defaultrouter=&#34;your_default_router&#34;&#39; &gt;&gt; /etc/rc.conf</span>
<span class=c># echo &#39;nameserver your_DNS_server&#39; &gt;&gt; /etc/resolv.conf</span></code></pre></div></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=config-network-testing>11.5.3. Teste e solução de problemas<a class=anchor href=#config-network-testing></a></h4><div class=paragraph><p>Uma vez que as alterações necessárias no <span class=filename>/etc/rc.conf</span> sejam salvas, uma reinicialização pode ser usada para testar a configuração de rede e verificar se o sistema é reiniciado sem nenhum erro. Como alternativa, aplique as configurações ao sistema de rede com este comando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service netif restart</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Se um gateway padrão foi configurado no <span class=filename>/etc/rc.conf</span>, também execute este comando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service routing restart</span></code></pre></div></div></td></tr></tbody></table></div><div class=paragraph><p>Uma vez que o sistema de rede tiver sido reiniciado, teste as NIC.</p></div><div class=sect4><h5 id=_testando_uma_placa_ethernet>11.5.3.1. Testando uma placa Ethernet<a class=anchor href=#_testando_uma_placa_ethernet></a></h5><div class=paragraph><p>Para verificar se uma placa Ethernet está configurada corretamente, execute um <a href="https://man.freebsd.org/cgi/man.cgi?query=ping&amp;sektion=8&amp;format=html">ping(8)</a> na própria interface e, em seguida, <a href="https://man.freebsd.org/cgi/man.cgi?query=ping&amp;sektion=8&amp;format=html">ping(8)</a> outra máquina na LAN:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ping <span class=nt>-c5</span> 192.168.1.3
PING 192.168.1.3 <span class=o>(</span>192.168.1.3<span class=o>)</span>: 56 data bytes
64 bytes from 192.168.1.3: <span class=nv>icmp_seq</span><span class=o>=</span>0 <span class=nv>ttl</span><span class=o>=</span>64 <span class=nb>time</span><span class=o>=</span>0.082 ms
64 bytes from 192.168.1.3: <span class=nv>icmp_seq</span><span class=o>=</span>1 <span class=nv>ttl</span><span class=o>=</span>64 <span class=nb>time</span><span class=o>=</span>0.074 ms
64 bytes from 192.168.1.3: <span class=nv>icmp_seq</span><span class=o>=</span>2 <span class=nv>ttl</span><span class=o>=</span>64 <span class=nb>time</span><span class=o>=</span>0.076 ms
64 bytes from 192.168.1.3: <span class=nv>icmp_seq</span><span class=o>=</span>3 <span class=nv>ttl</span><span class=o>=</span>64 <span class=nb>time</span><span class=o>=</span>0.108 ms
64 bytes from 192.168.1.3: <span class=nv>icmp_seq</span><span class=o>=</span>4 <span class=nv>ttl</span><span class=o>=</span>64 <span class=nb>time</span><span class=o>=</span>0.076 ms

<span class=nt>---</span> 192.168.1.3 ping statistics <span class=nt>---</span>
5 packets transmitted, 5 packets received, 0% packet loss
round-trip min/avg/max/stddev <span class=o>=</span> 0.074/0.083/0.108/0.013 ms</code></pre></div></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ping <span class=nt>-c5</span> 192.168.1.2
PING 192.168.1.2 <span class=o>(</span>192.168.1.2<span class=o>)</span>: 56 data bytes
64 bytes from 192.168.1.2: <span class=nv>icmp_seq</span><span class=o>=</span>0 <span class=nv>ttl</span><span class=o>=</span>64 <span class=nb>time</span><span class=o>=</span>0.726 ms
64 bytes from 192.168.1.2: <span class=nv>icmp_seq</span><span class=o>=</span>1 <span class=nv>ttl</span><span class=o>=</span>64 <span class=nb>time</span><span class=o>=</span>0.766 ms
64 bytes from 192.168.1.2: <span class=nv>icmp_seq</span><span class=o>=</span>2 <span class=nv>ttl</span><span class=o>=</span>64 <span class=nb>time</span><span class=o>=</span>0.700 ms
64 bytes from 192.168.1.2: <span class=nv>icmp_seq</span><span class=o>=</span>3 <span class=nv>ttl</span><span class=o>=</span>64 <span class=nb>time</span><span class=o>=</span>0.747 ms
64 bytes from 192.168.1.2: <span class=nv>icmp_seq</span><span class=o>=</span>4 <span class=nv>ttl</span><span class=o>=</span>64 <span class=nb>time</span><span class=o>=</span>0.704 ms

<span class=nt>---</span> 192.168.1.2 ping statistics <span class=nt>---</span>
5 packets transmitted, 5 packets received, 0% packet loss
round-trip min/avg/max/stddev <span class=o>=</span> 0.700/0.729/0.766/0.025 ms</code></pre></div></div><div class=paragraph><p>Para testar a resolução da rede, use o nome do host em vez do endereço IP. Se não houver nenhum servidor DNS na rede, o <span class=filename>/etc/hosts</span> deve ser configurado primeiro. Para este propósito, edite o <span class=filename>/etc/hosts</span> para adicionar os nomes e os endereços IP dos hosts na LAN, se eles ainda não estiverem lá . Para maiores informações, consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=hosts&amp;sektion=5&amp;format=html">hosts(5)</a> e <span class=filename>/usr/shared/examples/etc/hosts</span>.</p></div></div><div class=sect4><h5 id=_solução_de_problemas_2>11.5.3.2. Solução de problemas<a class=anchor href=#_solução_de_problemas_2></a></h5><div class=paragraph><p>Ao solucionar problemas de configurações de hardware e software, verifique primeiro as coisas simples. O cabo de rede está conectado? Os serviços de rede estão configurados corretamente? O firewall está configurado corretamente? A NIC é suportada pelo FreeBSD? Antes de enviar um relatório de bug, sempre verifique as Notas de Hardware, atualize a versão do FreeBSD para a versão mais recente do STABLE, verifique os arquivos da lista de discussão e pesquise na Internet.</p></div><div class=paragraph><p>Se a placa funcionar, mas o desempenho for ruim, leia <a href="https://man.freebsd.org/cgi/man.cgi?query=tuning&amp;sektion=7&amp;format=html">tuning(7)</a>. Além disso, verifique a configuração da rede, pois configurações de rede incorretas podem causar conexões lentas.</p></div><div class=paragraph><p>Alguns usuários experimentam uma ou duas mensagens de <code>device timeout</code>, o que é normal para algumas placas. Se eles continuarem ou forem incômodos, verifique se o dispositivo está em conflito com outro. Verifique novamente as conexões dos cabos. Considere tentar outra placa.</p></div><div class=paragraph><p>Para resolver erros de <code>watchdog timeout</code>, primeiro verifique o cabo de rede. Muitas placas requerem um slot PCI que suporte a masterização de barramento. Em algumas placas-mãe antigas, apenas um slot PCI permite, normalmente o slot 0. Verifique a NIC e a documentação da placa-mãe para determinar se esse pode ser o problema.</p></div><div class=paragraph><p>As mensagens <code>No route to host</code> ocorrem se o sistema não puder rotear um pacote para o host de destino. Isso pode acontecer se nenhuma rota padrão for especificada ou se um cabo for desconectado. Verifique a saída do <code>netstat -rn</code> e certifique-se de que haja uma rota válida para o host. Se não houver, leia <a href=./#network-routing>Gateways e Rotas</a>.</p></div><div class=paragraph><p>As mensagens de erro <code>ping: sendto: Permission denied</code> são geralmente causadas por um firewall mal configurado. Se um firewall está habilitado no FreeBSD, mas nenhuma regra foi definida, a política padrão é negar todo o tráfego, mesmo o <a href="https://man.freebsd.org/cgi/man.cgi?query=ping&amp;sektion=8&amp;format=html">ping(8)</a>. Consulte <a href=./#firewalls>Firewalls</a> para maiores informações.</p></div><div class=paragraph><p>Às vezes, o desempenho da placa é ruim ou abaixo da média. Nesses casos, tente configurar o modo de seleção de mídia de <code>autoselect</code> para a seleção de mídia correta. Embora isso funcione para a maioria dos hardwares, isso pode ou não resolver o problema. Novamente, verifique todas as configurações de rede e consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=tuning&amp;sektion=7&amp;format=html">tuning(7)</a>.</p></div></div></div></div><div class=sect2><h3 id=configtuning-virtual-hosts>11.6. Hosts Virtuais<a class=anchor href=#configtuning-virtual-hosts></a></h3><div class=paragraph><p>Um uso comum do FreeBSD é a hospedagem de sites virtuais, onde um servidor aparece na rede como muitos servidores. Isso é conseguido atribuindo vários endereços de rede a uma única interface.</p></div><div class=paragraph><p>Uma determinada interface de rede tem um endereço "real" e pode ter qualquer número de endereços "alias". Esses aliases são normalmente adicionados colocando entradas de alias no <span class=filename>/etc/rc.conf</span>, como mostrado neste exemplo:</p></div><div class="literalblock programlisting"><div class=content><pre>ifconfig_fxp0_alias0=&#34;inet xxx.xxx.xxx.xxx netmask xxx.xxx.xxx.xxx&#34;</pre></div></div><div class=paragraph><p>As entradas de alias devem começar com <code>alias_0_</code> usando um número sequencial como <code>alias0</code>, <code>alias1</code> e assim por diante. O processo de configuração será interrompido no primeiro número ausente.</p></div><div class=paragraph><p>O cálculo de máscaras de alias é importante. Para uma determinada interface, deve haver um endereço que represente corretamente a máscara de rede da rede. Qualquer outro endereço dentro dessa rede deve ter uma máscara de rede toda de <code>1</code>s, expressa como <code>255.255.255.255</code> ou <code>0xffffffff</code>.</p></div><div class=paragraph><p>Por exemplo, considere o caso em que a interface <span class=filename>fxp0</span> está conectada a duas redes: <code>10.1.1.0</code> com uma máscara de rede de <code>255.255.255.0</code> e <code>202.0.75.16</code> com uma máscara de rede de <code>255.255.255.240</code>. O sistema deve ser configurado para aparecer nos intervalos <code>10.1.1.1</code> até <code>10.1.1.5</code> e <code>202.0.75.17</code> até <code>202.0.75.20</code>. Somente o primeiro endereço em um determinado intervalo de rede deve ter uma máscara de rede real. Todo o resto de (<code>10.1.1.2</code> até <code>10.1.1.5</code> e de <code>202.0.75.18</code> até <code>202.0.75.20</code>) deve ser configurado com uma máscara de rede <code>255.255.255.255</code>.</p></div><div class=paragraph><p>As seguintes entradas <span class=filename>/etc/rc.conf</span> configuram o adaptador corretamente para este cenário:</p></div><div class="literalblock programlisting"><div class=content><pre>ifconfig_fxp0=&#34;inet 10.1.1.1 netmask 255.255.255.0&#34;
ifconfig_fxp0_alias0=&#34;inet 10.1.1.2 netmask 255.255.255.255&#34;
ifconfig_fxp0_alias1=&#34;inet 10.1.1.3 netmask 255.255.255.255&#34;
ifconfig_fxp0_alias2=&#34;inet 10.1.1.4 netmask 255.255.255.255&#34;
ifconfig_fxp0_alias3=&#34;inet 10.1.1.5 netmask 255.255.255.255&#34;
ifconfig_fxp0_alias4=&#34;inet 202.0.75.17 netmask 255.255.255.240&#34;
ifconfig_fxp0_alias5=&#34;inet 202.0.75.18 netmask 255.255.255.255&#34;
ifconfig_fxp0_alias6=&#34;inet 202.0.75.19 netmask 255.255.255.255&#34;
ifconfig_fxp0_alias7=&#34;inet 202.0.75.20 netmask 255.255.255.255&#34;</pre></div></div><div class=paragraph><p>Uma maneira mais simples de expressar isso é com uma lista separada por espaço de intervalos de endereços IP. O primeiro endereço receberá a máscara de sub-rede indicada e os endereços adicionais terão uma máscara de sub-rede <code>255.255.255.255</code>.</p></div><div class="literalblock programlisting"><div class=content><pre>ifconfig_fxp0_aliases=&#34;inet 10.1.1.1-5/24 inet 202.0.75.17-20/28&#34;</pre></div></div></div><div class=sect2><h3 id=configtuning-syslog>11.7. Configurando o log do sistema<a class=anchor href=#configtuning-syslog></a></h3><div class=paragraph><p>Gerar e ler logs do sistema é um aspecto importante da administração do sistema. As informações nos registros do sistema podem ser usadas para detectar problemas de hardware e software, bem como erros de configuração dos aplicativos e do sistema. Essas informações também desempenham um papel importante na auditoria de segurança e na resposta a incidentes. A maioria dos daemons e aplicativos do sistema geram entradas de log.</p></div><div class=paragraph><p>O FreeBSD fornece um registrador de sistema, o syslogd, para gerenciar o registro. Por padrão, o syslogd é iniciado quando o sistema é inicializado. Isto é controlado pela variável <code>syslogd_enable</code> no <span class=filename>/etc/rc.conf</span>. Existem vários argumentos de aplicação que podem ser definidos usando <code>syslogd_flags</code> no <span class=filename>/etc/rc.conf</span>. Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=syslogd&amp;sektion=8&amp;format=html">syslogd(8)</a> para obter maiores informações sobre os argumentos disponíveis.</p></div><div class=paragraph><p>Esta seção descreve como configurar o criador de logs do sistema FreeBSD para log local e remoto e como executar a rotação de log e o gerenciamento de log.</p></div><div class=sect3><h4 id=_configurando_os_logs_locais>11.7.1. Configurando os logs locais<a class=anchor href=#_configurando_os_logs_locais></a></h4><div class=paragraph><p>O arquivo de configuração, <span class=filename>/etc/syslog.conf</span>, controla o que o syslogd faz com as entradas de log à medida que são recebidas. Existem vários parâmetros para controlar o tratamento de eventos recebidos. O <em>facility</em> descreve qual subsistema gerou a mensagem, como o kernel ou um daemon, e o <em>level</em> descreve a gravidade do evento que ocorreu. Isso possibilita configurar onde uma mensagem de log é registrada, dependendo da instalação e do nível. Também é possível executar uma ação dependendo do aplicativo que enviou a mensagem e, no caso de log remoto, o nome do host da máquina que gera o evento de log.</p></div><div class=paragraph><p>Este arquivo de configuração contém uma linha por ação, em que a sintaxe de cada linha é um campo seletor seguido por um campo de ação. A sintaxe do campo seletor é <em>facility.level</em>, que corresponderá às mensagens de log de <em>facility</em> no nível <em>level</em> ou superior. Também é possível adicionar um sinalizador de comparação opcional antes do nível para especificar mais precisamente o que está registrado. Vários campos seletores podem ser usados para a mesma ação e são separados por um ponto-e-vírgula (<code>;</code>). Usar <code>*</code> irá corresponder a tudo. O campo de ação indica para onde enviar a mensagem de log, como para um arquivo ou host de log remoto. Por exemplo, aqui está o <span class=filename>syslog.conf</span> padrão do FreeBSD:</p></div><div class="literalblock programlisting"><div class=content><pre># $FreeBSD: head/pt_BR.ISO8859-1/books/handbook/book.xml 53984 2020-03-15 16:03:31Z dbaio $
#
#       Spaces ARE valid field separators in this file. However,
#       other *nix-like systems still insist on using tabs as field
#       separators. If you are sharing this file between systems, you
#       may want to use only tabs as field separators here.
#       Consult the syslog.conf(5) manpage.
*.err;kern.warning;auth.notice;mail.crit                /dev/console
*.notice;authpriv.none;kern.debug;lpr.info;mail.crit;news.err   /var/log/messages
security.*                                      /var/log/security
auth.info;authpriv.info                         /var/log/auth.log
mail.info                                       /var/log/maillog
lpr.info                                        /var/log/lpd-errs
ftp.info                                        /var/log/xferlog
cron.*                                          /var/log/cron
!-devd
*.=debug                                        /var/log/debug.log
*.emerg                                         *
# uncomment this to log all writes to /dev/console to /var/log/console.log
#console.info                                   /var/log/console.log
# uncomment this to enable logging of all log messages to /var/log/all.log
# touch /var/log/all.log and chmod it to mode 600 before it will work
#*.*                                            /var/log/all.log
# uncomment this to enable logging to a remote loghost named loghost
#*.*                                            @loghost
# uncomment these if you&#39;re running inn
# news.crit                                     /var/log/news/news.crit
# news.err                                      /var/log/news/news.err
# news.notice                                   /var/log/news/news.notice
# Uncomment this if you wish to see messages produced by devd
# !devd
# *.&gt;=info
!ppp
*.*                                             /var/log/ppp.log
!*</pre></div></div><div class=paragraph><p>Neste exemplo:</p></div><div class=ulist><ul><li><p>A linha 8 combina todas as mensagens com um nível de <code>err</code> ou superior, bem como <code>kern.warning</code>, <code>auth.notice</code> e <code>mail.crit</code>, e envia essas mensagens de log para o console (<span class=filename>/dev/console</span>).</p></li><li><p>A linha 12 combina todas as mensagens do recurso <code>mail</code> no nível <code>info</code> ou acima e registra as mensagens em <span class=filename>/var/log/maillog</span>.</p></li><li><p>A linha 17 usa um sinalizador de comparação (<code>=</code>) para corresponder apenas as mensagens no nível <code>debug</code> e registrá-las em <span class=filename>/var/log/debug.log</span>.</p></li><li><p>A linha 33 é um exemplo de uso de uma especificação de programa. Isso faz com que as regras que a seguem apenas sejam válidas para o programa especificado. Neste caso, somente as mensagens geradas pelo ppp são registradas em <span class=filename>/var/log/ppp.log</span>.</p></li></ul></div><div class=paragraph><p>Os níveis disponíveis, na ordem dos mais para o menos críticos, são <code>emerg</code>, <code>alert</code>, <code>crit</code>, <code>err</code>, <code>warning</code>, <code>notice</code>, <code>info</code>, and <code>debug</code>.</p></div><div class=paragraph><p>As facilities, em nenhuma ordem particular, são <code>auth</code>, <code>authpriv</code>, <code>console</code>, <code>cron</code>, <code>daemon</code>, <code>ftp</code>, <code>kern</code>, <code>lpr</code>, <code>mail</code>, <code>mark</code>, <code>news</code>, <code>security</code>, <code>syslog</code>, <code>user</code>, <code>uucp</code>, and <code>local0</code> through <code>local7</code>. Esteja ciente de que outros sistemas operacionais podem ter recursos diferentes.</p></div><div class=paragraph><p>Para registrar tudo do nível <code>notice</code> e superior para <span class=filename>/var/log/daemon.log</span>, adicione a seguinte entrada:</p></div><div class="literalblock programlisting"><div class=content><pre>daemon.notice                                        /var/log/daemon.log</pre></div></div><div class=paragraph><p>Para obter mais informações sobre os diferentes níveis e facilities, consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=syslog&amp;sektion=3&amp;format=html">syslog(3)</a> e <a href="https://man.freebsd.org/cgi/man.cgi?query=syslogd&amp;sektion=8&amp;format=html">syslogd(8)</a>. Para maiores informações sobre <span class=filename>/etc/syslog.conf</span>, sua sintaxe e exemplos de uso mais avançados, veja <a href="https://man.freebsd.org/cgi/man.cgi?query=syslog.conf&amp;sektion=5&amp;format=html">syslog.conf(5)</a>.</p></div></div><div class=sect3><h4 id=_gerenciamento_de_log_e_rotação>11.7.2. Gerenciamento de log e rotação<a class=anchor href=#_gerenciamento_de_log_e_rotação></a></h4><div class=paragraph><p>Os arquivos de log podem crescer rapidamente, ocupando espaço em disco e dificultando a localização de informações úteis. O gerenciamento de log tenta atenuar isso. No FreeBSD, o newsyslog é usado para gerenciar arquivos de log. Este programa interno rotaciona e comprime periodicamente arquivos de log e, opcionalmente, cria arquivos de log ausentes e sinaliza os programas quando os arquivos de log são movidos. Os arquivos de log podem ser gerados pelo syslogd ou por qualquer outro programa que gere arquivos de log. Enquanto o newsyslog é normalmente executado a partir do <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a>, ele não é um daemon do sistema. Na configuração padrão, ele é executado a cada hora.</p></div><div class=paragraph><p>Para saber quais ações executar, o newsyslog lê seu arquivo de configuração, <span class=filename>/etc/newsyslog.conf</span>. Este arquivo contém uma linha para cada arquivo de log que o newsyslog gerencia. Cada linha indica o proprietário do arquivo, suas permissões, quando rotacionar esse arquivo, flags opcionais que afetam a rotação do log, como compactação, e programas para sinalizar quando o log é rotacionado. Aqui está a configuração padrão no FreeBSD:</p></div><div class="literalblock programlisting"><div class=content><pre># configuration file for newsyslog
# $FreeBSD: head/pt_BR.ISO8859-1/books/handbook/book.xml 53984 2020-03-15 16:03:31Z dbaio $
#
# Entries which do not specify the &#39;/pid_file&#39; field will cause the
# syslogd process to be signalled when that log file is rotated.  This
# action is only appropriate for log files which are written to by the
# syslogd process (ie, files listed in /etc/syslog.conf).  If there
# is no process which needs to be signalled when a given log file is
# rotated, then the entry for that file should include the &#39;N&#39; flag.
#
# The &#39;flags&#39; field is one or more of the letters: BCDGJNUXZ or a &#39;-&#39;.
#
# Note: some sites will want to select more restrictive protections than the
# defaults.  In particular, it may be desirable to switch many of the 644
# entries to 640 or 600.  For example, some sites will consider the
# contents of maillog, messages, and lpd-errs to be confidential.  In the
# future, these defaults may change to more conservative ones.
#
# logfilename          [owner:group]    mode count size when  flags [/pid_file] [sig_num]
/var/log/all.log                        600  7     *    @T00  J
/var/log/amd.log                        644  7     100  *     J
/var/log/auth.log                       600  7     100  @0101T JC
/var/log/console.log                    600  5     100  *     J
/var/log/cron                           600  3     100  *     JC
/var/log/daily.log                      640  7     *    @T00  JN
/var/log/debug.log                      600  7     100  *     JC
/var/log/kerberos.log                   600  7     100  *     J
/var/log/lpd-errs                       644  7     100  *     JC
/var/log/maillog                        640  7     *    @T00  JC
/var/log/messages                       644  5     100  @0101T JC
/var/log/monthly.log                    640  12    *    $M1D0 JN
/var/log/pflog                          600  3     100  *     JB    /var/run/pflogd.pid
/var/log/ppp.log        root:network    640  3     100  *     JC
/var/log/devd.log                       644  3     100  *     JC
/var/log/security                       600  10    100  *     JC
/var/log/sendmail.st                    640  10    *    168   B
/var/log/utx.log                        644  3     *    @01T05 B
/var/log/weekly.log                     640  5     1    $W6D0 JN
/var/log/xferlog                        600  7     100  *     JC</pre></div></div><div class=paragraph><p>Cada linha começa com o nome do log a ser rotacionado, seguido opcionalmente por um proprietário e um grupo para arquivos rotacionados e recém-criados. O campo <code>mode</code> define as permissões no arquivo de log e <code>count</code> indica quantos arquivos de log rotacionados devem ser mantidos. Os campos <code>size</code> e <code>when</code> informam o newsyslog quando rotacionar o arquivo. Um arquivo de log é rotacionado quando seu tamanho é maior que o campo <code>size</code> ou quando o tempo no campo <code>when</code> tiver terminado. Um asterisco (<code>*</code>) significa que este campo é ignorado. O campo <em>flags</em> fornece instruções adicionais, por exemplo, como compactar o arquivo rotacionado ou criar o arquivo de log se ele estiver ausente. Os dois últimos campos são opcionais e especificam o nome do arquivo de ID de Processo (PID) e um número de sinal para enviar a esse processo quando o arquivo é rotacionado.</p></div><div class=paragraph><p>Para obter maiores informações sobre todos os campos, sinalizadores válidos e como sobre especificar o tempo de rotação, consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=newsyslog.conf&amp;sektion=5&amp;format=html">newsyslog.conf(5)</a>. Como o newsyslog é executado a partir do <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a>, ele não pode rotacionar arquivos com mais frequência do que a que está planejada para ser executada no <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a>.</p></div></div><div class=sect3><h4 id=network-syslogd>11.7.3. Configurando o log remoto<a class=anchor href=#network-syslogd></a></h4><div class=paragraph><p>Monitorar os arquivos de log de vários hosts pode se tornar difícil à medida que o número de sistemas aumenta. Configurar o log centralizado pode reduzir parte da carga administrativa da administração dos arquivos de log.</p></div><div class=paragraph><p>No FreeBSD, a agregação, a fusão e a rotação centralizada de arquivos de log podem ser configuradas usando o syslogd e o newsyslog. Esta seção demonstra um exemplo de configuração, em que host o <code>A</code>, chamado <code>logserv.example.com</code>, coletará informações de log para a rede local. O host <code>B</code>, denominado <code>logclient.example.com</code>, será configurado para transmitir informações de log para o servidor de registro em log.</p></div><div class=sect4><h5 id=_configuração_do_servidor_de_log>11.7.3.1. Configuração do servidor de log<a class=anchor href=#_configuração_do_servidor_de_log></a></h5><div class=paragraph><p>Um servidor de log é um sistema que foi configurado para aceitar informações de log de outros hosts. Antes de configurar um servidor de log, verifique o seguinte:</p></div><div class=ulist><ul><li><p>Se houver um firewall entre o servidor de log e qualquer cliente de log, certifique-se de que o conjunto de regras do firewall permita a porta 514 do UDP para os clientes e o servidor.</p></li><li><p>O servidor de log e todas as máquinas clientes devem ter entradas de nome diretas e reversas no DNS local. Se a rede não tiver um servidor DNS, crie entradas no <span class=filename>/etc/hosts</span> de cada sistema. A resolução adequada de nomes é necessária para que as entradas de log não sejam rejeitadas pelo servidor de log.</p></li></ul></div><div class=paragraph><p>No servidor de log, edite o <span class=filename>/etc/syslog.conf</span> para especificar o nome do cliente para receber as entradas de log, o recurso de log a ser usado e o nome do log para armazenar as entradas de log do host. Este exemplo adiciona o nome do host de <code>B</code>, registra todos os recursos e armazena as entradas de log em <span class=filename>/var/log/logclient.log</span>.</p></div><div class=exampleblock><div class=title>Exemplo 25. Configuração do servidor de log de exemplo</div><div class=content><div class="literalblock programlisting"><div class=content><pre>+logclient.example.com
*.*     /var/log/logclient.log</pre></div></div></div></div><div class=paragraph><p>Ao adicionar vários clientes de log, adicione uma entrada semelhante de duas linhas para cada cliente. Maiores informações sobre os recursos disponíveis podem ser encontradas em <a href="https://man.freebsd.org/cgi/man.cgi?query=syslog.conf&amp;sektion=5&amp;format=html">syslog.conf(5)</a>.</p></div><div class=paragraph><p>Em seguida, configure o <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>syslogd_enable=&#34;YES&#34;
syslogd_flags=&#34;-a logclient.example.com -v -v&#34;</pre></div></div><div class=paragraph><p>A primeira entrada inicia o syslogd na inicialização do sistema. A segunda entrada permite entradas de log do cliente especificado. A opção <code>-v -v</code> aumenta a verbosidade das mensagens registradas. Isso é útil para ajustar os recursos, pois os administradores podem ver o tipo de mensagens que estão sendo registradas em cada facility.</p></div><div class=paragraph><p>Múltiplas opções <code>-a</code> podem ser especificadas para permitir o registro de múltiplos clientes. Endereços IP e netblocks inteiros também podem ser especificados. Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=syslogd&amp;sektion=8&amp;format=html">syslogd(8)</a> para obter uma lista completa de opções possíveis.</p></div><div class=paragraph><p>Finalmente, crie o arquivo de log:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># touch /var/log/logclient.log</span></code></pre></div></div><div class=paragraph><p>Neste ponto, o syslogd deve ser reiniciado e verificado:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service syslogd restart</span>
<span class=c># pgrep syslog</span></code></pre></div></div><div class=paragraph><p>Se um PID for retornado, o servidor será reiniciado com êxito e a configuração do cliente poderá ser iniciada. Se o servidor não reiniciar, consulte <span class=filename>/var/log/messages</span> para visualizar o erro.</p></div></div><div class=sect4><h5 id=_configuração_do_cliente_de_log>11.7.3.2. Configuração do cliente de log<a class=anchor href=#_configuração_do_cliente_de_log></a></h5><div class=paragraph><p>Um cliente de log envia entradas de log para um servidor de log na rede. O cliente também mantém uma cópia local de seus próprios logs.</p></div><div class=paragraph><p>Uma vez que o servidor de log foi configurado, edite o <span class=filename>/etc/rc.conf</span> no cliente de registro:</p></div><div class="literalblock programlisting"><div class=content><pre>syslogd_enable=&#34;YES&#34;
syslogd_flags=&#34;-s -v -v&#34;</pre></div></div><div class=paragraph><p>A primeira entrada ativa o syslogd na inicialização. A segunda entrada impede que os logs sejam aceitos por esse cliente de outros hosts (<code>-s</code>) e aumenta a verbosidade das mensagens registradas.</p></div><div class=paragraph><p>Em seguida, defina o servidor de log no <span class=filename>/etc/syslog.conf</span> do cliente. Neste exemplo, todos os facilities registrados são enviados para um sistema remoto, indicado pelo símbolo <code>@</code>, com o nome do host especificado:</p></div><div class="literalblock programlisting"><div class=content><pre>*.*		@logserv.example.com</pre></div></div><div class=paragraph><p>Depois de salvar a edição, reinicie o syslogd para que as alterações entrem em vigor:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service syslogd restart</span></code></pre></div></div><div class=paragraph><p>Para testar se as mensagens de log estão sendo enviadas pela rede, use o <a href="https://man.freebsd.org/cgi/man.cgi?query=logger&amp;sektion=1&amp;format=html">logger(1)</a> no cliente para enviar uma mensagem para syslogd:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># logger &#34;Test message from logclient&#34;</span></code></pre></div></div><div class=paragraph><p>Esta mensagem agora deve existir tanto no <span class=filename>/var/log/messages</span> do cliente e no <span class=filename>/var/log/logclient.log</span> do servidor de log.</p></div></div><div class=sect4><h5 id=_debugando_servidores_de_log>11.7.3.3. Debugando servidores de log<a class=anchor href=#_debugando_servidores_de_log></a></h5><div class=paragraph><p>Se nenhuma mensagem estiver sendo recebida no servidor de log, a causa provavelmente é um problema de conectividade de rede, um problema de resolução de nome de host ou um erro de digitação em um arquivo de configuração. Para isolar a causa, certifique-se de que o servidor de log e o cliente de log sejam capazes de comunicarem através do <code>ping</code> usando o nome do host especificado em seu <span class=filename>/etc/rc.conf</span>. Se isso falhar, verifique o cabeamento da rede, o conjunto de regras do firewall e as entradas de nome de host no servidor DNS ou <span class=filename>/etc/hosts</span> no servidor de log e nos clientes. Repita até que o <code>ping</code> seja bem-sucedido em ambos os hosts.</p></div><div class=paragraph><p>Se o <code>ping</code> for bem-sucedido em ambos os hosts, mas as mensagens de log ainda não estiverem sendo recebidas, aumente temporariamente o detalhamento do log para diminuir o problema de configuração. No exemplo a seguir, o <span class=filename>/var/log/logclient.log</span> no servidor de log está vazio e o <span class=filename>/var/log/messages</span> no cliente de log não indica uma razão para a falha. Para aumentar a saída de debug, edite a entrada <code>syslogd_flags</code> no servidor de log e execute uma reinicialização:</p></div><div class="literalblock programlisting"><div class=content><pre>syslogd_flags=&#34;-d -a logclient.example.com -v -v&#34;</pre></div></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service syslogd restart</span></code></pre></div></div><div class=paragraph><p>Dados de debug semelhantes aos seguintes irão aparecer no console imediatamente após a reinicialização:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>logmsg: pri 56, flags 4, from logserv.example.com, msg syslogd: restart
syslogd: restarted
logmsg: pri 6, flags 4, from logserv.example.com, msg syslogd: kernel boot file is /boot/kernel/kernel
Logging to FILE /var/log/messages
syslogd: kernel boot file is /boot/kernel/kernel
cvthname<span class=o>(</span>192.168.1.10<span class=o>)</span>
validate: dgram from IP 192.168.1.10, port 514, name logclient.example.com<span class=p>;</span>
rejected <span class=k>in </span>rule 0 due to name mismatch.</code></pre></div></div><div class=paragraph><p>Neste exemplo, as mensagens de log estão sendo rejeitadas devido a um erro de digitação que resulta em uma incompatibilidade de nome de host. O nome do host do cliente deve ser <code>logclient</code>, não <code>logclien</code>. Corrija o erro de digitação, execute uma reinicialização e verifique os resultados:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service syslogd restart</span>
logmsg: pri 56, flags 4, from logserv.example.com, msg syslogd: restart
syslogd: restarted
logmsg: pri 6, flags 4, from logserv.example.com, msg syslogd: kernel boot file is /boot/kernel/kernel
syslogd: kernel boot file is /boot/kernel/kernel
logmsg: pri 166, flags 17, from logserv.example.com,
msg Dec 10 20:55:02 &lt;syslog.err&gt; logserv.example.com syslogd: exiting on signal 2
cvthname<span class=o>(</span>192.168.1.10<span class=o>)</span>
validate: dgram from IP 192.168.1.10, port 514, name logclient.example.com<span class=p>;</span>
accepted <span class=k>in </span>rule 0.
logmsg: pri 15, flags 0, from logclient.example.com, msg Dec 11 02:01:28 trhodes: Test message 2
Logging to FILE /var/log/logclient.log
Logging to FILE /var/log/messages</code></pre></div></div><div class=paragraph><p>Neste ponto, as mensagens estão sendo recebidas e colocadas corretamente no arquivo correto.</p></div></div><div class=sect4><h5 id=_considerações_de_segurança>11.7.3.4. Considerações de segurança<a class=anchor href=#_considerações_de_segurança></a></h5><div class=paragraph><p>Como com qualquer serviço de rede, os requisitos de segurança devem ser considerados antes de implementar um servidor de log. Os arquivos de log podem conter dados confidenciais sobre serviços ativados no host local, contas de usuário e dados de configuração. Os dados enviados pela rede do cliente para o servidor não serão criptografados nem protegidos por senha. Se houver necessidade de criptografia, considere o uso do <a class=package href=https://cgit.freebsd.org/ports/tree/security/stunnel/>security/stunnel</a>, que transmitirá os dados de log em um túnel criptografado.</p></div><div class=paragraph><p>A segurança local também é um problema. Os arquivos de log não são criptografados durante o uso ou após a rotação do log. Usuários locais podem acessar arquivos de log para obter informações adicionais sobre a configuração do sistema. Definir permissões adequadas nos arquivos de log é crítico. O rotacionador de log integrado, newsyslog, suporta a configuração de permissões em arquivos de log recém-criados e rotacionados. A configuração de arquivos de log no modo <code>600</code> deve impedir o acesso indesejado por usuários locais. Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=newsyslog.conf&amp;sektion=5&amp;format=html">newsyslog.conf(5)</a> para obter informações adicionais.</p></div></div></div></div><div class=sect2><h3 id=configtuning-configfiles>11.8. Arquivos de Configuração<a class=anchor href=#configtuning-configfiles></a></h3><div class=sect3><h4 id=_layout_do_etc>11.8.1. Layout do <span class=filename>/etc</span><a class=anchor href=#_layout_do_etc></a></h4><div class=paragraph><p>Existem vários diretórios nos quais as informações de configuração são mantidas. Estes incluem:</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/etc</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Informações de configuração específica do sistema genérico.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/etc/defaults</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Versões padrão dos arquivos de configuração do sistema.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/etc/mail</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Configuração extra do <a href="https://man.freebsd.org/cgi/man.cgi?query=sendmail&amp;sektion=8&amp;format=html">sendmail(8)</a> e outros arquivos de configuração MTA.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/etc/ppp</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Configuração para ambos os programas, user- e kernel-ppp.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/local/etc</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Arquivos de configuração para aplicativos instalados. Pode conter subdiretórios para cada aplicativo.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/local/etc/rc.d</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>scripts <a href="https://man.freebsd.org/cgi/man.cgi?query=rc&amp;sektion=8&amp;format=html">rc(8)</a> para os aplicativos instalados.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/var/db</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Arquivos de banco de dados específicos do sistema gerados automaticamente, como o banco de dados de pacotes e o banco de dados <a href="https://man.freebsd.org/cgi/man.cgi?query=locate&amp;sektion=1&amp;format=html">locate(1)</a>.</p></td></tr></tbody></table></div><div class=sect3><h4 id=_hostnames>11.8.2. Hostnames<a class=anchor href=#_hostnames></a></h4><div class=sect4><h5 id=_etcresolv_conf>11.8.2.1. <span class=filename>/etc/resolv.conf</span><a class=anchor href=#_etcresolv_conf></a></h5><div class=paragraph><p>Como um sistema FreeBSD acessa o Sistema de Nomes de Domínio da Internet (Internet Domain Name System - DNS) é controlado por <a href="https://man.freebsd.org/cgi/man.cgi?query=resolv.conf&amp;sektion=5&amp;format=html">resolv.conf(5)</a>.</p></div><div class=paragraph><p>As entradas mais comuns para o <span class=filename>/etc/resolv.conf</span> são:</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>nameserver</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>O endereço IP de um servidor de nomes que o resolvedor deve consultar. Os servidores são consultados na ordem listada com um máximo de três.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>search</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Lista de pesquisa, para busca de nomes de host. Isso é normalmente determinado pelo domínio do nome do host local.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>domain</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>O nome do domínio local.</p></td></tr></tbody></table><div class=paragraph><p>Um típico <span class=filename>/etc/resolv.conf</span> é assim:</p></div><div class="literalblock programlisting"><div class=content><pre>search example.com
nameserver 147.11.1.11
nameserver 147.11.100.30</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Apenas uma das opções <code>search</code> e <code>domain</code> deve ser usada.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Ao usar o DHCP, o <a href="https://man.freebsd.org/cgi/man.cgi?query=dhclient&amp;sektion=8&amp;format=html">dhclient(8)</a> geralmente reescreve o <span class=filename>/etc/resolv.conf</span> com informações recebidas do servidor DHCP.</p></div></div><div class=sect4><h5 id=_etchosts>11.8.2.2. <span class=filename>/etc/hosts</span><a class=anchor href=#_etchosts></a></h5><div class=paragraph><p>O <span class=filename>/etc/hosts</span> é um banco de dados de texto simples que funciona em conjunto com o DNS e o NIS para fornecer o nome do host aos mapeamentos de endereços IP. Entradas para computadores locais conectados através de uma LAN podem ser adicionadas a este arquivo para propósitos simplistas de nomeação em vez de configurar um servidor <a href="https://man.freebsd.org/cgi/man.cgi?query=named&amp;sektion=8&amp;format=html">named(8)</a>. Além disso, o <span class=filename>/etc/hosts</span> pode ser usado para fornecer um registro local de nomes da Internet, reduzindo a necessidade de consultar servidores DNS externos para nomes comumente acessados.</p></div><div class="literalblock programlisting"><div class=content><pre># $FreeBSD: head/pt_BR.ISO8859-1/books/handbook/book.xml 53984 2020-03-15 16:03:31Z dbaio $
#
#
# Host Database
#
# This file should contain the addresses and aliases for local hosts that
# share this file.  Replace &#39;my.domain&#39; below with the domainname of your
# machine.
#
# In the presence of the domain name service or NIS, this file may
# not be consulted at all; see /etc/nsswitch.conf for the resolution order.
#
#
::1			localhost localhost.my.domain
127.0.0.1		localhost localhost.my.domain
#
# Imaginary network.
#10.0.0.2		myname.my.domain myname
#10.0.0.3		myfriend.my.domain myfriend
#
# According to RFC 1918, you can use the following IP networks for
# private nets which will never be connected to the Internet:
#
#	10.0.0.0	-   10.255.255.255
#	172.16.0.0	-   172.31.255.255
#	192.168.0.0	-   192.168.255.255
#
# In case you want to be able to connect to the Internet, you need
# real official assigned numbers.  Do not try to invent your own network
# numbers but instead get one from your network provider (if any) or
# from your regional registry (ARIN, APNIC, LACNIC, RIPE NCC, or AfriNIC.)
#</pre></div></div><div class=paragraph><p>O formato do <span class=filename>/etc/hosts</span> é o seguinte:</p></div><div class="literalblock programlisting"><div class=content><pre>[Internet address] [official hostname] [alias1] [alias2] ...</pre></div></div><div class=paragraph><p>Por exemplo:</p></div><div class="literalblock programlisting"><div class=content><pre>10.0.0.1 myRealHostname.example.com myRealHostname foobar1 foobar2</pre></div></div><div class=paragraph><p>Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=hosts&amp;sektion=5&amp;format=html">hosts(5)</a> para obter maiores informações.</p></div></div></div></div><div class=sect2><h3 id=configtuning-sysctl>11.9. Efetuando ajustes com o <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a><a class=anchor href=#configtuning-sysctl></a></h3><div class=paragraph><p>O <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> é usado para fazer mudanças em um sistema FreeBSD em execução. Isso inclui muitas opções avançadas da stack TCP/IP e do sistema de memória virtual as quais podem melhorar drasticamente o desempenho do FreeBSD para um administrador de sistema experiente. Mais de quinhentas variáveis do sistema podem ser lidas e definidas usando o <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a>.</p></div><div class=paragraph><p>Em sua essência, o <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> serve duas funções: ler e modificar as configurações do sistema.</p></div><div class=paragraph><p>Para ver todas as variáveis legíveis:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% sysctl <span class=nt>-a</span></code></pre></div></div><div class=paragraph><p>Para ler uma variável específica, especifique seu nome:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% sysctl kern.maxproc
kern.maxproc: 1044</code></pre></div></div><div class=paragraph><p>Para definir uma variável específica, use a sintaxe <em>variable</em>=<em>value</em>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl kern.maxfiles=5000</span>
kern.maxfiles: 2088 -&gt; 5000</code></pre></div></div><div class=paragraph><p>As configurações das variáveis sysctl são geralmente strings, números ou booleanos, onde um booleano é <code>1</code> para sim <code>0</code> para não.</p></div><div class=paragraph><p>Para definir automaticamente algumas variáveis sempre que a máquina inicializar, adicione-as ao <span class=filename>/etc/sysctl.conf</span>. Para maiores informações, consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl.conf&amp;sektion=5&amp;format=html">sysctl.conf(5)</a> e <a href=#configtuning-sysctlconf><span class=filename>sysctl.conf</span></a>.</p></div><div class=sect3><h4 id=configtuning-sysctlconf>11.9.1. <span class=filename>sysctl.conf</span><a class=anchor href=#configtuning-sysctlconf></a></h4><div class=paragraph><p>O arquivo de configuração para o <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a>, <span class=filename>/etc/sysctl.conf</span>, se parece muito com o <span class=filename>/etc /rc.conf</span>. Os valores são definidos na forma <code>variable=value</code>. Os valores especificados são definidos após o sistema entrar no modo multiusuário. Nem todas as variáveis são configuráveis neste modo.</p></div><div class=paragraph><p>Por exemplo, para desativar o log de saídas de sinais fatais e impedir que os usuários vejam processos iniciados por outros usuários, os seguintes ajustes podem ser configurados em <span class=filename>/etc/sysctl.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre># Do not log fatal signal exits (e.g., sig 11)
kern.logsigexit=0

# Prevent users from seeing information about processes that
# are being run under another UID.
security.bsd.see_other_uids=0</pre></div></div></div><div class=sect3><h4 id=sysctl-readonly>11.9.2. Variáveis <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> apenas de leitura<a class=anchor href=#sysctl-readonly></a></h4><div class=paragraph><p>Em alguns casos, pode ser desejável modificar os valores de variáveis do <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> que são somente de leitura, o que exigirá uma reinicialização do sistema.</p></div><div class=paragraph><p>Por exemplo, em alguns modelos de laptops, o dispositivo <a href="https://man.freebsd.org/cgi/man.cgi?query=cardbus&amp;sektion=4&amp;format=html">cardbus(4)</a> não examinará os intervalos de memória e falhará com erros semelhantes a:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>cbb0: Could not map register memory
device_probe_and_attach: cbb0 attach returned 12</code></pre></div></div><div class=paragraph><p>A correção requer a modificação de uma configuração definida por uma variável do <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> que é somente de leitura. Adicione <code>hw.pci.allow_unsupported_io_range=1</code> ao arquivo <span class=filename>/boot/loader.conf</span> e reinicie. Agora o <a href="https://man.freebsd.org/cgi/man.cgi?query=cardbus&amp;sektion=4&amp;format=html">cardbus(4)</a> deve funcionar corretamente.</p></div></div></div><div class=sect2><h3 id=configtuning-disk>11.10. Otimização de Discos<a class=anchor href=#configtuning-disk></a></h3><div class=paragraph><p>A seção a seguir discutirá vários mecanismos e opções de ajuste que podem ser aplicados a dispositivos de disco. Em muitos casos, discos com partes mecânicas, como unidades SCSI, serão o gargalo que reduz o desempenho geral do sistema. Embora a solução seja instalar uma unidade sem peças mecânicas, como uma unidade de estado sólido, as unidades mecânicas não irão desaparecer num futuro próximo. Quando estiver otimizando discos, é aconselhável utilizar os recursos do comando <a href="https://man.freebsd.org/cgi/man.cgi?query=iostat&amp;sektion=8&amp;format=html">iostat(8)</a> para testar várias mudanças no sistema. Este comando permitirá ao usuário obter informações valiosas sobre o sistema IO.</p></div><div class=sect3><h4 id=_variáveis_sysctl>11.10.1. Variáveis Sysctl<a class=anchor href=#_variáveis_sysctl></a></h4><div class=sect4><h5 id=_vfs_vmiodirenable>11.10.1.1. <code>vfs.vmiodirenable</code><a class=anchor href=#_vfs_vmiodirenable></a></h5><div class=paragraph><p>A variável <code>vfs.vmiodirenable</code> <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> pode ser definida como <code>0</code> (off ) ou <code>1</code> (on). Está definida para <code>1</code> por padrão. Esta variável controla como os diretórios são armazenados em cache pelo sistema. A maioria dos diretórios é pequena, usando apenas um único fragmento (normalmente 1K) no sistema de arquivos e, normalmente, 512 bytes no cache de buffer. Com esta variável desativada, o cache de buffer armazenará apenas um número fixo de diretórios, mesmo que o sistema tenha uma quantidade enorme de memória. Quando ativado, este <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> permite que o cache de buffer use o cache de página VM para armazenar em cache os diretórios, disponibilizando toda a memória para fazer cache dos diretórios. No entanto, a memória mínima no núcleo usada para armazenar em cache um diretório é o tamanho da página física (geralmente 4K) em vez de 512 bytes. Manter esta opção ativada é recomendado se o sistema estiver executando quaisquer serviços que manipulem um grande número de arquivos. Esses serviços podem incluir caches da web, grandes sistemas de correio e sistemas de notícias. Manter essa opção geralmente não reduz o desempenho, mesmo com a memória desperdiçada, mas deve-se experimentar para descobrir.</p></div></div><div class=sect4><h5 id=_vfs_write_behind>11.10.1.2. <code>vfs.write_behind</code><a class=anchor href=#_vfs_write_behind></a></h5><div class=paragraph><p>A variável <code>vfs.write_behind</code> <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> é padronizada para <code>1</code> (ligada). Isso informa ao sistema de arquivos para emitir gravações de mídia à medida que clusters completos são coletados, o que normalmente ocorre ao gravar arquivos sequenciais grandes. Isso evita saturar o cache de buffer com buffers sujos quando não beneficia o desempenho de I/O. No entanto, isso pode atrasar os processos e, sob certas circunstâncias, deve ser desativado.</p></div></div><div class=sect4><h5 id=_vfs_hirunningspace>11.10.1.3. <code>vfs.hirunningspace</code><a class=anchor href=#_vfs_hirunningspace></a></h5><div class=paragraph><p>A variável <code>vfs.hirunningspace</code> <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> determina quanto de I/O de gravação pendente pode ser enfileirado no sistema de controladores de disco como um todo em qualquer instância. O padrão é geralmente suficiente, mas em máquinas com muitos discos, tente aumentar para quatro ou cinco <em>megabytes</em>. Definir um valor muito alto, que exceda o limite de gravação do cache de buffer, pode levar a um mau desempenho de cluster. Não defina esse valor arbitrariamente alto, pois valores de gravação mais altos podem adicionar latência a leituras que ocorrem ao mesmo tempo.</p></div><div class=paragraph><p>Há vários outros caches de buffer e valores de cache de página VM relacionados a <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a>. Modificar esses valores não é recomendado, pois o sistema VM faz um bom trabalho de ajuste automático.</p></div></div><div class=sect4><h5 id=_vm_swap_idle_enabled>11.10.1.4. <code>vm.swap_idle_enabled</code><a class=anchor href=#_vm_swap_idle_enabled></a></h5><div class=paragraph><p>A variável <code>vm.swap_idle_enabled</code> <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> é útil em grandes sistemas multiusuários com muitos usuários ativos, e muitos processos ociosos. Tais sistemas tendem a gerar pressão contínua nas reservas de memória livre. Ativar esse recurso e aprimorar a histerese de troca (em segundos ociosos) por meio de <code>vm.swap_idle_threshold1</code> e <code>vm.swap_idle_threshold2</code> reduz a prioridade das páginas de memória associadas aos processos inativos mais rapidamente do que no algoritmo de pageout normal. Isso dá uma ajuda ao daemon de pageout. Apenas ative essa opção se necessário, porque a compensação é essencialmente fazer o pre-page da memoria mais cedo, o que consome mais swap e largura de banda de disco. Em um sistema pequeno, esta opção terá um efeito determinável, mas em um sistema grande que já está paginando moderadamente, esta opção permite que o sistema VM instale processos inteiros dentro e fora da memória facilmente.</p></div></div><div class=sect4><h5 id=_hw_ata_wc>11.10.1.5. <code>hw.ata.wc</code><a class=anchor href=#_hw_ata_wc></a></h5><div class=paragraph><p>Desativar o cache de gravação IDE reduz a largura de banda de gravação em discos IDE, mas às vezes pode ser necessário devido a problemas de consistência de dados introduzidos por fornecedores de disco rígido. O problema é que algumas unidades IDE mentem sobre quando uma gravação é concluída. Com o cache de gravação IDE ativado, os discos rígidos IDE gravam os dados fora de ordem e às vezes atrasam a gravação de alguns blocos indefinidamente quando estão sob carga pesada de disco. Uma falha ou falha de energia pode causar corrupção séria do sistema de arquivos. Verifique o padrão no sistema observando a variável <code>hw.ata.wc</code> <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a>. Se o cache de gravação IDE estiver desativado, pode-se definir essa variável somente leitura como <code>1</code> em <span class=filename>/boot/loader.conf</span> para ativar no momento da inicialização.</p></div><div class=paragraph><p>Para maiores informações, consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=ata&amp;sektion=4&amp;format=html">ata(4)</a>.</p></div></div><div class=sect4><h5 id=_scsi_delay_kern_cam_scsi_delay>11.10.1.6. <code>SCSI_DELAY</code> (<code>kern.cam.scsi_delay</code>)<a class=anchor href=#_scsi_delay_kern_cam_scsi_delay></a></h5><div class=paragraph><p>A opção de configuração do kernel <code>SCSI_DELAY</code> pode ser usada para reduzir os tempos de inicialização do sistema. Os padrões são razoavelmente altos e podem ser responsáveis por <code>15</code> segundos de atraso no processo de inicialização. Reduzindo-o para <code>5</code> segundos geralmente funciona com unidades modernas. A variável de tempo de inicialização <code>kern.cam.scsi_delay</code> deve ser usada. A opção de configuração ajustável e a configuração do kernel aceitam valores em termos de <em>milissegundos</em> e <em>não__segundos</em>.</p></div></div></div><div class=sect3><h4 id=soft-updates>11.10.2. Soft Updates<a class=anchor href=#soft-updates></a></h4><div class=paragraph><p>Para ajustar um sistema de arquivos, use <a href="https://man.freebsd.org/cgi/man.cgi?query=tunefs&amp;sektion=8&amp;format=html">tunefs(8)</a>. Este programa tem muitas opções diferentes. Para ativar e desativar o Soft Updates, use:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># tunefs -n enable /filesystem</span>
<span class=c># tunefs -n disable /filesystem</span></code></pre></div></div><div class=paragraph><p>Um sistema de arquivos não pode ser modificado com <a href="https://man.freebsd.org/cgi/man.cgi?query=tunefs&amp;sektion=8&amp;format=html">tunefs(8)</a> enquanto estiver montado. Um bom momento para ativar o Soft Updates é antes que qualquer partição tenha sido montada, no modo de single-user.</p></div><div class=paragraph><p>O Soft Updates é recomendado para sistemas de arquivos UFS, pois melhora drasticamente o desempenho de metadados, principalmente a criação e exclusão de arquivos, através do uso de um cache em memória. Há duas desvantagens no Soft Updates que você deve conhecer. Primeiro, o Soft Updates garante a consistência do sistema de arquivos no caso de uma falha, mas pode facilmente levar vários segundos ou até um minuto para atualizar o disco físico. Se o sistema falhar, os dados não gravados poderão ser perdidos. Em segundo lugar, os Soft Updates atrasam a liberação de blocos do sistema de arquivos. Se o sistema de arquivos raiz estiver quase cheio, a execução de uma atualização importante, como <code>make installworld</code>, poderá causar a falta de espaço do sistema de arquivos e a atualização falhará.</p></div><div class=sect4><h5 id=_mais_detalhes_sobre_soft_updates>11.10.2.1. Mais detalhes sobre soft updates<a class=anchor href=#_mais_detalhes_sobre_soft_updates></a></h5><div class=paragraph><p>As atualizações de metadados são atualizações para dados que não são de conteúdo, como inodes ou diretórios. Existem duas abordagens tradicionais para gravar os metadados de um sistema de arquivos em disco.</p></div><div class=paragraph><p>Historicamente, o comportamento padrão era gravar atualizações de metadados de forma síncrona. Se um diretório fosse alterado, o sistema aguardava até que a alteração fosse gravada no disco. Os buffers de dados do arquivo (conteúdo do arquivo) foram passados pelo cache de buffer e foram copiados para o disco posteriormente de maneira assíncrona. A vantagem dessa implementação é que ela opera com segurança. Se houver uma falha durante uma atualização, os metadados estarão sempre em um estado consistente. Um arquivo é criado completamente ou não é de todo. Se os blocos de dados de um arquivo não encontrarem saída do cache de buffer para o disco no momento da falha, o <a href="https://man.freebsd.org/cgi/man.cgi?query=fsck&amp;sektion=8&amp;format=html">fsck(8)</a> reconhece isso e repara o sistema de arquivos definindo o comprimento do arquivo como <code>0</code>. Além disso, a implementação é clara e simples. A desvantagem é que as alterações nos metadados são lentas. Por exemplo, <code>rm -r</code> toca todos os arquivos em um diretório sequencialmente, mas cada alteração de diretório será gravada de forma síncrona no disco. Isso inclui atualizações para o próprio diretório, para a tabela de inode e possivelmente para blocos indiretos alocados pelo arquivo. Considerações semelhantes aplicam-se ao desenrolar hierarquias grandes usando <code>tar -x</code>.</p></div><div class=paragraph><p>A segunda abordagem é usar atualizações de metadados assíncronas. Este é o padrão para um sistema de arquivos UFS montado com <code>mount -o async</code>. Como todas as atualizações de metadados também são passadas pelo cache de buffer, elas serão mescladas com as atualizações dos dados de conteúdo do arquivo. A vantagem dessa implementação é que não há necessidade de esperar até que cada atualização de metadados seja gravada no disco, portanto, todas as operações que causam grandes quantidades de atualizações de metadados funcionam muito mais rápido do que no caso síncrono. Essa implementação ainda é clara e simples, portanto, há um baixo risco de erros se infiltrarem no código. A desvantagem é que não há garantia para um estado consistente do sistema de arquivos. Se houver uma falha durante uma operação que atualizou grandes quantidades de metadados, como uma falha de energia ou alguém pressionando o botão de reinicialização, o sistema de arquivos será deixado em um estado imprevisível. Não há oportunidade de examinar o estado do sistema de arquivos quando o sistema é reativado, pois os blocos de dados de um arquivo já podem ter sido gravados no disco enquanto as atualizações da tabela de inodes ou do diretório associado não foram. É impossível implementar um <a href="https://man.freebsd.org/cgi/man.cgi?query=fsck&amp;sektion=8&amp;format=html">fsck(8)</a> que é capaz de limpar o caos resultante porque as informações necessárias não estão disponíveis no disco. Se o sistema de arquivos foi danificado além do reparo, a única opção é reformatá-lo e restaurá-lo a partir do backup.</p></div><div class=paragraph><p>A solução usual para este problema é implementar <em>dirty region logging</em>, que também é chamado de <em>journaling</em>. As atualizações de metadados ainda são gravadas de forma síncrona, mas apenas em uma pequena região do disco. Mais tarde, eles são movidos para o local apropriado. Como a área de registro é uma região pequena e contígua no disco, não há longas distâncias para as cabeças de disco se moverem, mesmo durante operações pesadas, portanto, essas operações são mais rápidas do que as atualizações síncronas. Além disso, a complexidade da implementação é limitada, portanto, o risco de erros estarem presentes é baixo. Uma desvantagem é que todos os meta-dados são gravados duas vezes, uma vez na região de registro e uma vez no local apropriado, portanto, pode resultar em "piora" na performance. Por outro lado, em caso de falha, todas as operações de metadados pendentes podem ser rapidamente recuperadas ou concluídas a partir da área de registro depois que o sistema for ativado novamente, resultando em uma inicialização rápida do sistema de arquivos.</p></div><div class=paragraph><p>Kirk McKusick, o desenvolvedor do Berkeley FFS, resolveu esse problema com o Soft Updates. Todas as atualizações de meta-dados pendentes são mantidas na memória e gravadas no disco em uma sequência ordenada ("atualizações de metadados ordenadas"). Isso tem o efeito de que, no caso de operações pesadas de meta-dados, atualizações posteriores em um item "catch" as anteriores que ainda estão na memória e ainda não foram gravadas no disco. Todas as operações são geralmente executadas na memória antes da atualização ser gravada no disco e os blocos de dados são classificados de acordo com sua posição, de modo que não estarão no disco antes de seus meta-dados. Se o sistema travar, um "reenvio de log" implícito faz com que todas as operações que não foram gravadas no disco apareçam como se nunca tivessem acontecido. Um estado consistente do sistema de arquivos é mantido e parece ser o de 30 a 60 segundos antes. O algoritmo usado garante que todos os recursos em uso sejam marcados como tal em seus blocos e inodes. Após uma falha, o único erro de alocação de recursos que ocorre é que os recursos são marcados como "used", que são, na verdade, "free". O <a href="https://man.freebsd.org/cgi/man.cgi?query=fsck&amp;sektion=8&amp;format=html">fsck(8)</a> reconhece essa situação e libera os recursos que não são mais usados. É seguro ignorar o estado sujo do sistema de arquivos após uma falha forçando a montagem com <code>mount -f</code>. Para liberar recursos que podem não ser utilizados, O <a href="https://man.freebsd.org/cgi/man.cgi?query=fsck&amp;sektion=8&amp;format=html">fsck(8)</a> precisa ser executado posteriormente. Esta é a idéia por trás do <em><a href="https://man.freebsd.org/cgi/man.cgi?query=fsck&amp;sektion=8&amp;format=html">fsck(8)</a> em background</em>: no momento da inicialização do sistema, apenas um <em>snapshot</em> do sistema de arquivos é gravado e o <a href="https://man.freebsd.org/cgi/man.cgi?query=fsck&amp;sektion=8&amp;format=html">fsck(8)</a> é executado posteriormente. Todos os sistemas de arquivos podem ser montados "sujos", para que a inicialização do sistema prossiga no modo multiusuário. Em seguida, o <a href="https://man.freebsd.org/cgi/man.cgi?query=fsck&amp;sektion=8&amp;format=html">fsck(8)</a> em background é planejado para todos os sistemas de arquivos em que isso é necessário, para liberar recursos que podem não ser utilizados. Os sistemas de arquivos que não usam Soft Updates ainda precisam executar o <a href="https://man.freebsd.org/cgi/man.cgi?query=fsck&amp;sektion=8&amp;format=html">fsck(8)</a> em primeiro plano de forma usual .</p></div><div class=paragraph><p>A vantagem é que as operações de meta-dados são quase tão rápidas quanto as atualizações assíncronas e são mais rápidas que o <em>logging</em>, que precisa escrever os meta-dados duas vezes. As desvantagens são a complexidade do código, um maior consumo de memória e algumas idiosincrasias. Depois de uma falha, o estado do sistema de arquivos parece ser um pouco mais "velho". Em situações onde a abordagem síncrona padrão teria causado a existencia de alguns arquivos de comprimento zero após o <a href="https://man.freebsd.org/cgi/man.cgi?query=fsck&amp;sektion=8&amp;format=html">fsck(8)</a>, esses arquivos sequer chegam a existir com Soft Updates porque nem os metadados e nem o conteúdo do arquivo foram gravados no disco. O espaço em disco não é liberado até que as atualizações tenham sido gravadas no disco, o que pode ocorrer algum tempo depois de executar <a href="https://man.freebsd.org/cgi/man.cgi?query=rm&amp;sektion=1&amp;format=html">rm(1)</a>. Isso pode causar problemas ao instalar grandes quantidades de dados em um sistema de arquivos que não tenha espaço livre suficiente para armazenar todos os arquivos duas vezes.</p></div></div></div></div><div class=sect2><h3 id=configtuning-kernel-limits>11.11. Ajustando os Limites do Kernel<a class=anchor href=#configtuning-kernel-limits></a></h3><div class=sect3><h4 id=file-process-limits>11.11.1. Limites de arquivos/processos<a class=anchor href=#file-process-limits></a></h4><div class=sect4><h5 id=kern-maxfiles>11.11.1.1. <code>kern.maxfiles</code><a class=anchor href=#kern-maxfiles></a></h5><div class=paragraph><p>A variável <code>kern.maxfiles</code> <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> pode ser aumentada ou diminuída com base nos requisitos do sistema. Essa variável indica o número máximo de descritores de arquivos no sistema. Quando a tabela do descritor de arquivos estiver cheia, o erro <code>file: table is full</code> aparecerá repetidamente no buffer de mensagem do sistema, que pode ser visualizado usando <a href="https://man.freebsd.org/cgi/man.cgi?query=dmesg&amp;sektion=8&amp;format=html">dmesg(8)</a>.</p></div><div class=paragraph><p>Cada arquivo aberto, socket ou fifo usa um descritor de arquivo. Um servidor de produção em larga escala pode facilmente exigir muitos milhares de descritores de arquivos, dependendo do tipo e número de serviços executados simultaneamente.</p></div><div class=paragraph><p>Em versões mais antigas do FreeBSD, o valor padrão de <code>kern.maxfiles</code> é derivado do <code>maxusers</code> no arquivo de configuração do kernel. O <code>kern.maxfiles</code> cresce proporcionalmente ao valor do <code>maxusers</code>. Ao compilar um kernel personalizado, considere configurar esta opção de configuração do kernel de acordo com o uso do sistema. A partir desse número, o kernel recebe a maioria dos seus limites predefinidos. Mesmo que uma máquina de produção não tenha 256 usuários simultâneos, os recursos necessários podem ser semelhantes a um servidor da Web de alta escala.</p></div><div class=paragraph><p>A variável read-only <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a><code>kern.maxusers</code> é dimensionada automaticamente na inicialização com base na quantidade de memória disponível no sistema, e pode ser determinado em tempo de execução, inspecionando o valor de <code>kern.maxusers</code>. Alguns sistemas requerem valores maiores ou menores de <code>kern.maxusers</code> e valores de <code>64</code>, <code>128</code>, e <code>256</code> não são incomuns. Ir acima de <code>256</code> não é recomendado, a menos que seja necessário um grande número de descritores de arquivos. Muitos dos valores ajustáveis definidos para seus padrões por <code>kern.maxusers</code> podem ser individualmente sobrescritos no tempo de inicialização ou em tempo de execução no <span class=filename>/boot/loader.conf</span>. Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=loader.conf&amp;sektion=5&amp;format=html">loader.conf(5)</a> e <span class=filename>/boot/defaults/loader.conf</span> para mais detalhes e algumas dicas.</p></div><div class=paragraph><p>Em versões mais antigas, o sistema ajustará automaticamente o <code>maxusers</code> se ele estiver definido como <code>0</code>. . Ao configurar esta opção, configure o <code>maxusers</code> para pelo menos <code>4</code>, especialmente se o sistema executar o Xorg ou se for usado para compilar software. A tabela mais importante definida por <code>maxusers</code> é o número máximo de processos, que é definido como <code>20 + 16 * maxusers</code>. Se <code>maxusers</code> for definido como <code>1</code>, só podem existir <code>36</code> processos simultâneos, incluindo <code>18</code> ou mais para que o sistema seja iniciado no boot ou <code>15</code> usado pelo Xorg. Até mesmo uma tarefa simples, como ler uma página de manual, iniciará nove processos para filtrar, descompactar e visualizar. Configurar o <code>maxusers</code> para <code>64</code> permite até <code>1044</code> processos simultâneos, o que deve ser suficiente para quase todos os usos. Se, no entanto, o erro for exibido ao tentar iniciar outro programa ou se um servidor estiver sendo executado com um grande número de usuários simultâneos, aumente o número e recompile.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>O <code>maxusers</code> <em>não</em> limita o número de usuários que podem logar na máquina. Em vez disso, ele configura vários tamanhos de tabela para valores razoáveis, considerando o número máximo de usuários no sistema e quantos processos cada usuário executará.</p></div></td></tr></tbody></table></div></div><div class=sect4><h5 id=_kern_ipc_soacceptqueue>11.11.1.2. <code>kern.ipc.soacceptqueue</code><a class=anchor href=#_kern_ipc_soacceptqueue></a></h5><div class=paragraph><p>A variável <code>kern.ipc.soacceptqueue</code> do <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> limita o tamanho da fila de escuta para aceitar novas conexões <code>TCP</code>. O valor padrão de <code>128</code> é normalmente muito baixo para o manuseio robusto de novas conexões em um servidor Web com carga pesada. Para tais ambientes, recomenda-se aumentar este valor para <code>1024</code> ou superior. Um serviço como o <a href="https://man.freebsd.org/cgi/man.cgi?query=sendmail&amp;sektion=8&amp;format=html">sendmail(8)</a>, ou Apache pode limitar por ele mesmo o tamanho da fila de escuta, mas frequentemente terá uma diretiva em seu arquivo de configuração para ajustar o tamanho da fila. Filas de escuta grandes fazem um trabalho melhor evitando ataques de negação de serviço (Denial of Service - DoS).</p></div></div></div><div class=sect3><h4 id=nmbclusters>11.11.2. Limites de rede<a class=anchor href=#nmbclusters></a></h4><div class=paragraph><p>A opção de configuração do kernel <code>NMBCLUSTERS</code> determina a quantidade de Mbufs de rede disponível para o sistema. Um servidor com muito tráfego e um baixo número de Mbufs prejudicará o desempenho. Cada cluster representa aproximadamente 2K de memória, portanto, um valor de <code>1024</code> representa <code>2</code> megabytes de memória do kernel reservada para buffers de rede. Um cálculo simples pode ser feito para descobrir quantos são necessários. Um servidor web que suporte um maximo de <code>1000</code> conexões simultâneas onde cada conexão usa um buffer de envio de 16K e recebe 6K, requer aproximadamente 32 MB de buffers de rede para cobrir o servidor web. Uma boa regra é multiplicar por <code>2</code>, então 2x32MB / 2KB = 64MB / 2kB = <code>32768</code>. Valores entre <code>4096</code> e <code>32768</code> são recomendados para máquinas com maiores quantidades de memória. Nunca especifique um valor arbitrariamente alto para este parâmetro, pois isso pode levar a uma falha no tempo de inicialização. Para observar o uso do cluster de rede, use a opção <code>-m</code> com o <a href="https://man.freebsd.org/cgi/man.cgi?query=netstat&amp;sektion=1&amp;format=html">netstat(1)</a>.</p></div><div class=paragraph><p>A variável <code>kern.ipc.nmbclusters</code> deve ser usada para configurar isso no momento da inicialização. Apenas as versões mais antigas do FreeBSD irão requerer o uso da opção <code>NMBCLUSTERS</code> no <a href="https://man.freebsd.org/cgi/man.cgi?query=config&amp;sektion=8&amp;format=html">config(8)</a> do kernel.</p></div><div class=paragraph><p>Para servidores ocupados que fazem uso extensivo da chamada de sistema <a href="https://man.freebsd.org/cgi/man.cgi?query=sendfile&amp;sektion=2&amp;format=html">sendfile(2)</a>, pode ser necessário aumentar o número de buffers <a href="https://man.freebsd.org/cgi/man.cgi?query=sendfile&amp;sektion=2&amp;format=html">sendfile(2)</a> através da opção de configuração do kernel <code>NSFBUFS</code> ou definindo seu valor no <span class=filename>/boot/loader.conf</span> (veja <a href="https://man.freebsd.org/cgi/man.cgi?query=loader&amp;sektion=8&amp;format=html">loader(8)</a> para detalhes). Um indicador comum de que esse parâmetro precisa ser ajustado é quando os processos são vistos no estado <code>sfbufa</code>. A variável <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a><code>kern.ipc.nsfbufs</code> é somente de leitura. Este parâmetro nominalmente escala com o <code>kern.maxusers</code>, no entanto, pode ser necessário ajustar de acordo.</p></div><div class="admonitionblock important"><table><tbody><tr><td class=icon><i class="fa icon-important" title=Important></i></td><td class=content><div class=paragraph><p>Mesmo que um socket tenha sido marcado como non-blocking, chamar o <a href="https://man.freebsd.org/cgi/man.cgi?query=sendfile&amp;sektion=2&amp;format=html">sendfile(2)</a> em um socket non-blocking pode resultar no bloqueio do <a href="https://man.freebsd.org/cgi/man.cgi?query=sendfile&amp;sektion=2&amp;format=html">sendfile(2)</a> até que sejam disponibilizados <code>struct sf_buf</code> suficientes.</p></div></td></tr></tbody></table></div><div class=sect4><h5 id=_net_inet_ip_portrange>11.11.2.1. <code>net.inet.ip.portrange.*</code><a class=anchor href=#_net_inet_ip_portrange></a></h5><div class=paragraph><p>As variáveis <code>net.inet.ip.portrange.*</code> do <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> controlam os intervalos de números de porta automaticamente ligados a sockets <code>TCP</code> e <code>UDP</code>. Existem três intervalos: um intervalo baixo, um intervalo padrão e um intervalo alto. A maioria dos programas de rede usam o intervalo padrão que é controlado por <code>net.inet.ip.portrange.first</code> e <code>net.inet.ip.portrange.last</code>, cujo padrão é <code>1024</code> e <code>5000</code>, respectivamente. Intervalos de porta ligados são usados para conexões de saída e é possível executar o sistema fora das portas sob certas circunstâncias. Isso ocorre mais comumente ao executar um proxy web com muita carga. O intervalo de portas não é um problema ao executar um servidor que lida principalmente com conexões de entrada, como um servidor Web, ou que tenha um número limitado de conexões de saída, como um mail relay. Para situações em que há falta de portas, é recomendado aumentar modestamente o <code>net.inet.ip.portrange.last</code>. Um valor de <code>10000</code>, <code>20000</code> ou <code>30000</code> pode ser razoável. Considere os efeitos do firewall ao alterar o intervalo de portas. Alguns firewalls podem bloquear grandes intervalos de portas, geralmente portas de numeração baixa, e esperam que os sistemas usem intervalos mais altos de portas para conexões de saída. Por esta razão, não é recomendado que o valor de <code>net.inet.ip.portrange.first</code> seja diminuído.</p></div></div><div class=sect4><h5 id=_produto_de_atraso_de_largura_de_banda_tcp>11.11.2.2. Produto de atraso de largura de banda <code>TCP</code><a class=anchor href=#_produto_de_atraso_de_largura_de_banda_tcp></a></h5><div class=paragraph><p>A limitação do produto de atraso de largura de banda <code>TCP</code> pode ser ativada configurando a variável <code>net.inet.tcp.inflight.enable</code> do <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> para <code>1</code>. Isso instrui o sistema a tentar calcular o produto de atraso de largura de banda para cada conexão e a limitar a quantidade de dados na fila para envio à rede para a quantidade necessária para manter o rendimento ideal.</p></div><div class=paragraph><p>Esse recurso é útil ao servir dados sobre modems, Gigabit Ethernet, links <code>WAN</code> de alta velocidade ou qualquer outro link com um produto de atraso de largura de banda alta, especialmente quando também estiver usando dimensionamento de janela ou quando uma janela de envio grande tiver sido configurado. Ao habilitar essa opção, defina também a variável <code>net.inet.tcp.inflight.debug</code> para <code>0</code> para desabilitar a depuração. Para uso em produção, definir a variável <code>net.inet.tcp.inflight.min</code> para pelo menos <code>6144</code> pode ser benéfico. Definir valores mínimos altos pode efetivamente desabilitar a limitação de largura de banda, dependendo do link. O recurso de limitação reduz a quantidade de dados acumulados nas rotas intermediárias e nas filas de pacotes de switchs e reduz a quantidade de dados acumulados na fila de interface do host local. Com menos pacotes enfileirados, as conexões interativas, especialmente os modems lentos, funcionarão com menores <em>Round Trip Times</em>. Esse recurso afeta apenas a transmissão de dados do lado do servidor, como o upload. Não tem efeito na recepção ou download de dados.</p></div><div class=paragraph><p>Ajustar o valor da variável <code>net.inet.tcp.inflight.stab</code> <em>não</em> é recomendado. Este parâmetro é padronizado para <code>20</code>, representando 2 pacotes máximos adicionados ao cálculo da janela de produto de atraso de largura de banda. A janela adicional é necessária para estabilizar o algoritmo e melhorar a capacidade de resposta às mudanças de condições, mas também pode resultar em um <a href="https://man.freebsd.org/cgi/man.cgi?query=ping&amp;sektion=8&amp;format=html">ping(8)</a> mais alto em links lentos , embora ainda muito menor do que sem o algoritmo inflight. Nesses casos, tente reduzir esse parâmetro para <code>15</code>, <code>10</code> ou <code>5</code> e reduza a variável <code>net.inet.tcp.inflight.min</code> para um valor como <code>3500</code> para obter o efeito desejado. A redução desses parâmetros deve ser feita apenas como último recurso.</p></div></div></div><div class=sect3><h4 id=_memória_virtual>11.11.3. Memória virtual<a class=anchor href=#_memória_virtual></a></h4><div class=sect4><h5 id=_kern_maxvnodes>11.11.3.1. <code>kern.maxvnodes</code><a class=anchor href=#_kern_maxvnodes></a></h5><div class=paragraph><p>Um vnode é a representação interna de um arquivo ou diretório. Aumentar o número de vnodes disponíveis para o sistema operacional reduz a I/O do disco. Normalmente, isso é tratado pelo sistema operacional e não precisa ser alterado. Em alguns casos em que o I/O de disco é um gargalo e o sistema está ficando sem vnodes, essa configuração precisa ser aumentada. A quantidade de RAM inativa e livre precisará ser levada em conta.</p></div><div class=paragraph><p>Para ver o número atual de vnodes em uso:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl vfs.numvnodes</span>
vfs.numvnodes: 91349</code></pre></div></div><div class=paragraph><p>Para ver o máximo de vnodes:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl kern.maxvnodes</span>
kern.maxvnodes: 100000</code></pre></div></div><div class=paragraph><p>Se o uso atual do vnode estiver próximo do máximo, tente aumentar o <code>kern.maxvnodes</code> por um valor de <code>1000</code>. Fique de olho no número de <code>vfs.numvnodes</code>. Se subir até o máximo novamente, o <code>kern.maxvnodes</code> precisará ser aumentado ainda mais. Caso contrário, uma mudança no uso da memória como reportado pelo <a href="https://man.freebsd.org/cgi/man.cgi?query=top&amp;sektion=1&amp;format=html">top(1)</a> deve estar visível e mais memória deve estar ativa.</p></div></div></div></div><div class=sect2><h3 id=adding-swap-space>11.12. Adicionando Espaço de Swap<a class=anchor href=#adding-swap-space></a></h3><div class=paragraph><p>Às vezes, um sistema requer mais espaço de swap. Esta seção descreve dois métodos para aumentar o espaço de troca: adicionar swap a uma partição existente ou em um novo disco rígido e criar um arquivo de swap em uma partição existente.</p></div><div class=paragraph><p>Para obter informações sobre como criptografar o espaço de swap, quais opções existem e por que isso deve ser feito, consulte <a href=./#swap-encrypting>Criptografando Swap</a>.</p></div><div class=sect3><h4 id=new-drive-swap>11.12.1. Swap em um novo disco rígido ou partição existente<a class=anchor href=#new-drive-swap></a></h4><div class=paragraph><p>Adicionar um novo disco rígido para swap resulta em um melhor desempenho do que usando uma partição em uma unidade existente. A configuração de partições e discos rígidos é explicada em <a href=./#disks-adding>Adicionando Discos</a> enquanto <a href=./#configtuning-initial>Criando o layout da partição</a> discute layouts de partições e considerações sobre o tamanho de partições de swap.</p></div><div class=paragraph><p>Use o <code>swapon</code> para adicionar uma partição swap ao sistema. Por exemplo:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># swapon /dev/ada1s1b</span></code></pre></div></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>É possível usar qualquer partição que não esteja atualmente montada, mesmo que já contenha dados. O uso do <code>swapon</code> em uma partição que contém dados sobrescreverá e destruirá esses dados. Certifique-se de que a partição a ser incluída como swap seja realmente a partição pretendida antes de executar o <code>swapon</code>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Para adicionar automaticamente essa partição swap na inicialização, adicione uma entrada ao <span class=filename>/etc/fstab</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>/dev/ada1s1b	none	swap	sw	0	0</pre></div></div><div class=paragraph><p>Veja <a href="https://man.freebsd.org/cgi/man.cgi?query=fstab&amp;sektion=5&amp;format=html">fstab(5)</a> para uma explicação das entradas do <span class=filename>/etc/fstab</span>. Maiores informações sobre <code>swapon</code> podem ser encontradas em <a href="https://man.freebsd.org/cgi/man.cgi?query=swapon&amp;sektion=8&amp;format=html">swapon(8)</a>.</p></div></div><div class=sect3><h4 id=create-swapfile>11.12.2. Criando um arquivo de swap<a class=anchor href=#create-swapfile></a></h4><div class=paragraph><p>Esses exemplos criam um arquivo de swap de 512M chamado <span class=filename>/usr/swap0</span> em vez de usar uma partição.</p></div><div class=paragraph><p>O uso de arquivos de swap requer que o módulo necessário pelo <a href="https://man.freebsd.org/cgi/man.cgi?query=md&amp;sektion=4&amp;format=html">md(4)</a> tenha sido embutido no kernel ou tenha sido carregado antes do swap ser ativado. Veja <a href=./#kernelconfig>Configurando o kernel do FreeBSD</a> para informações sobre como compilar um kernel customizado.</p></div><div id=swapfile-10-and-later class=exampleblock><div class=title>Exemplo 26. Criando um arquivo de swap</div><div class=content><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Crie o arquivo de swap:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dd if=/dev/zero of=/usr/swap0 bs=1m count=512</span></code></pre></div></div></li><li><p>Defina as permissões adequadas no novo arquivo:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># chmod 0600 /usr/swap0</span></code></pre></div></div></li><li><p>Informe o sistema sobre o arquivo de swap adicionando uma linha ao <span class=filename>/etc/fstab</span>:</p><div class="literalblock programlisting"><div class=content><pre>md99	none	swap	sw,file=/usr/swap0,late	0	0</pre></div></div><div class=paragraph><p>O dispositivo <span class=filename>md99</span> do <a href="https://man.freebsd.org/cgi/man.cgi?query=md&amp;sektion=4&amp;format=html">md(4)</a> é usado, deixando números de dispositivos inferiores disponíveis para uso interativo.</p></div></li><li><p>O espaço de swap será adicionado na inicialização do sistema. Para adicionar espaço de swap imediatamente, use o <a href="https://man.freebsd.org/cgi/man.cgi?query=swapon&amp;sektion=8&amp;format=html">swapon(8)</a>:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># swapon -aL</span></code></pre></div></div></li></ol></div></div></div></div></div></div></div><div class=sect2><h3 id=acpi-overview>11.13. Gerenciamento de energia e recursos<a class=anchor href=#acpi-overview></a></h3><div class=paragraph><p>É importante utilizar recursos de hardware de maneira eficiente. O gerenciamento de energia e recursos permite que o sistema operacional monitore os limites do sistema e, possivelmente, forneça um alerta se a temperatura do sistema aumentar inesperadamente. Uma especificação anterior para fornecer gerenciamento de energia foi o recurso Gerenciamento Avançado de Energia (Advanced Power Management - APM). O APM controla o uso de energia de um sistema com base em sua atividade. No entanto, era difícil e inflexível para os sistemas operacionais gerenciar o uso de energia e as propriedades térmicas de um sistema. O hardware era gerenciado pelo BIOS e o usuário tinha configuração e visibilidade limitadas nas configurações de gerenciamento de energia. O APMBIOS fornecido é específico da plataforma de hardware. Um driver APM no sistema operacional intermedia o acesso à interface do software APM, que permite o gerenciamento dos níveis de energia.</p></div><div class=paragraph><p>Existem quatro problemas principais no APM. Primeiro, o gerenciamento de energia é feito pelo BIOS específico do fornecedor, separado do sistema operacional. Por exemplo, o usuário pode definir valores de tempo ocioso para um disco rígido no APMBIOS para que, quando excedido, o BIOS diminua o disco rígido sem o consentimento do sistema operacional. Segundo, a lógica do APM é incorporada no BIOS e opera fora do escopo do sistema operacional. Isso significa que os usuários só podem corrigir problemas no APMBIOS, fazendo o flash de um novo ROM, que é um procedimento perigoso com potencial para deixar o sistema em um estado irrecuperável se falhar. Terceiro, o APM é uma tecnologia específica do fornecedor, o que significa que há muita duplicidade de esforços e que os erros encontrados no BIOS de um fornecedor podem não serem resolvidos em outros. Por fim, o APMBIOS não tinha espaço suficiente para implementar uma política de energia sofisticada ou que pudesse se adaptar bem ao propósito da máquina.</p></div><div class=paragraph><p>O BIOS plug and play (PNPBIOS) não era confiável em muitas situações. O PNPBIOS é uma tecnologia de 16 bits, portanto, o sistema operacional precisa usar a emulação de 16 bits para fazer interface com os métodos PNPBIOS. O FreeBSD fornece um driver APM, pois o APM ainda deve ser usado para sistemas fabricados antes do ano 2000. O driver está documentado em <a href="https://man.freebsd.org/cgi/man.cgi?query=apm&amp;sektion=4&amp;format=html">apm(4)</a>.</p></div><div class=paragraph><p>O sucessor do APM é a Interface Avançada de Configuração e Energia (Advanced Configuration and Power Interface - ACPI). O ACPI é um padrão escrito por uma aliança de fornecedores para fornecer uma interface para recursos de hardware e gerenciamento de energia. É um elemento-chave na <em>configuração direcionada do sistema operacional e gerenciamento de energia</em>, pois proporciona mais controle e flexibilidade ao sistema operacional.</p></div><div class=paragraph><p>Este capítulo demonstra como configurar o ACPI no FreeBSD. Em seguida, ele oferece algumas dicas sobre como depurar o ACPI e como enviar um relatório de problemas contendo informações de depuração para que os desenvolvedores possam diagnosticar e corrigir problemas no ACPI.</p></div><div class=sect3><h4 id=acpi-config>11.13.1. Configurando o ACPI<a class=anchor href=#acpi-config></a></h4><div class=paragraph><p>No FreeBSD, o driver <a href="https://man.freebsd.org/cgi/man.cgi?query=acpi&amp;sektion=4&amp;format=html">acpi(4)</a> é carregado por padrão na inicialização do sistema e <em>não</em> deve ser compilado no kernel. Este driver não pode ser descarregado após a inicialização porque o barramento do sistema o utiliza para várias interações de hardware. No entanto, se o sistema estiver com problemas, o ACPI pode ser desativado completamente ao reinicializar após a configurar <code>hint.acpi.0.disabled="1"</code> no <span class=filename>/boot/loader.conf</span> ou definindo esta variável no prompt do loader, como descrito em <a href=./#boot-loader>Estágio três</a>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>O ACPI e o APM não podem coexistir e devem ser usados separadamente. O último a ser carregado terminará se o driver perceber que o outro já está sendo executado.</p></div></td></tr></tbody></table></div><div class=paragraph><p>O ACPI pode ser usado para colocar o sistema em modo de suspensão com o <code>acpiconf</code>, a opção <code>-s</code> e um número de <code>1</code> a <code>5</code>. A maioria dos usuários só precisa de <code>1</code> (suspensão rápida para RAM) ou <code>3</code> (suspender para RAM). A opção <code>5</code> executa um soft-off que é o mesmo que executar <code>halt -p</code>.</p></div><div class=paragraph><p>Outras opções estão disponíveis usando o <code>sysctl</code>. Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=acpi&amp;sektion=4&amp;format=html">acpi(4)</a> e <a href="https://man.freebsd.org/cgi/man.cgi?query=acpiconf&amp;sektion=8&amp;format=html">acpiconf(8)</a> para maiores informações.</p></div></div><div class=sect3><h4 id=ACPI-comprob>11.13.2. Problemas comuns<a class=anchor href=#ACPI-comprob></a></h4><div class=paragraph><p>O ACPI está presente em todos os computadores modernos que estão em conformidade com as arquiteturas ia32 (x86) e amd64 (AMD). O padrão completo tem muitos recursos, incluindo gerenciamento de desempenho da CPU, controle de planos de energia, zonas térmicas, vários sistemas de bateria, controladores incorporados e enumeração de barramento. A maioria dos sistemas implementa menos que o padrão completo. Por exemplo, um sistema de desktop geralmente só implementa a enumeração de barramento, enquanto um laptop também pode ter suporte a refrigeração e gerenciamento de bateria. Os laptops também têm suspensão e retomada, com sua própria complexidade associada.</p></div><div class=paragraph><p>Um sistema compatível com ACPI possui vários componentes. Os fornecedores de BIOS e chipset fornecem várias tabelas fixas, como FADT, na memória que especificam coisas como o mapa APIC (usado para SMP), registros de configuração e valores simples de configuração. Além disso, uma tabela de bytecode, a Tabela de Descrição de Sistema Diferenciada DSDT, especifica um espaço de nome de dispositivos e métodos em forma de árvore.</p></div><div class=paragraph><p>O driver ACPI deve analisar as tabelas fixas, implementar um interpretador para o bytecode e modificar os drivers de dispositivos e o kernel para aceitar informações do subsistema ACPI. Para o FreeBSD, a Intel™ forneceu um interpretador (ACPI-CA) que é compartilhado com o Linux™ e o NetBSD. O caminho para o código-fonte ACPI-CA é <span class=filename>src/sys/contrib/dev/acpica</span>. O código especifico que permite que o ACPI-CA funcione no FreeBSD está em <span class=filename>src/sys/dev/acpica/Osd</span>. Finalmente, drivers que implementam vários dispositivos ACPI são encontrados em <span class=filename>src/sys/dev/acpica</span>.</p></div><div class=paragraph><p>Para que o ACPI funcione corretamente, todas as partes devem funcionar corretamente. Aqui estão alguns problemas comuns, em ordem de freqüência em que ocorrem, e algumas possíveis soluções ou correções. Se uma correção não resolver o problema, consulte <a href=#ACPI-submitdebug>Obtendo e enviando informações de depuração</a> para obter instruções sobre como enviar um relatório de bug.</p></div><div class=sect4><h5 id=_problemas_do_mouse>11.13.2.1. Problemas do mouse<a class=anchor href=#_problemas_do_mouse></a></h5><div class=paragraph><p>Em alguns casos, retomar a partir de uma operação de suspensão fará com que o mouse falhe. Um work around conhecido é adicionar <code>hint.psm.0.flags="0x3000"</code> ao <span class=filename>/boot/loader.conf</span>.</p></div></div><div class=sect4><h5 id=_suspendresume>11.13.2.2. Suspend/Resume<a class=anchor href=#_suspendresume></a></h5><div class=paragraph><p>O ACPI tem três estados de suspensão para RAM (STR), <code>S1</code>-<code>S3</code>, e um de suspensão de estado para disco (STD), chamado <code>S4</code>. O STD pode ser implementado de duas maneiras separadas. O <code>S4</code> BIOS é uma suspensão para disco auxiliada pelo BIOSe o <code>S4</code>OS é implementado inteiramente pelo sistema operacional. O estado normal em que o sistema se encontra quando conectado, mas não ligado, é "soft off" (<code>S5</code>).</p></div><div class=paragraph><p>Use o <code>sysctl hw.acpi</code> para verificar os itens relacionados à suspensão. Estes resultados de exemplo são de um Thinkpad:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>hw.acpi.supported_sleep_state: S3 S4 S5
hw.acpi.s4bios: 0</code></pre></div></div><div class=paragraph><p>Use o <code>acpiconf -s</code> para testar os estados <code>S3</code>, <code>S4</code> e <code>S5</code>. Um <code>s4bios</code> de um (<code>1</code>) indica suporte ao <code>S4</code> BIOS em vez do <code>S4</code> suportado pelo sistema operacional.</p></div><div class=paragraph><p>Ao testar as ações de suspend/resume, inicie com o <code>S1</code>, se suportado. É mais provável que esse estado funcione, pois não requer muito suporte ao driver. Ninguém implementou <code>S2</code>, que é similar ao <code>S1</code>. Em seguida, tente o <code>S3</code>. Este é o estado mais profundo do STR e requer muito suporte ao driver para reinicializar corretamente o hardware.</p></div><div class=paragraph><p>Um problema comum com suspend/resume é que muitos drivers de dispositivo não salvam, restauram ou reinicializam seu firmware, registros ou memória do dispositivo adequadamente. Como primeira tentativa de depuração do problema, tente:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl debug.bootverbose=1</span>
<span class=c># sysctl debug.acpi.suspend_bounce=1</span>
<span class=c># acpiconf -s 3</span></code></pre></div></div><div class=paragraph><p>Esse teste emula o ciclo de suspend/resume de todos os drivers de dispositivo sem entrar realmente no estado <code>S3</code>. Em alguns casos, problemas como perder o estado do firmware, tempo limite do watchdog do dispositivo e tentar novamente para sempre podem ser capturados com esse método. Note que o sistema não entrará realmente no estado <code>S3</code>, o que significa que os dispositivos não perderão energia, e muitos funcionarão bem mesmo se os métodos suspend/resume estiverem totalmente ausentes, ao contrário do real estado <code>S3</code>.</p></div><div class=paragraph><p>Casos mais difíceis requerem hardware adicional, como uma porta serial e um cabo para depuração através de um console serial, uma porta Firewire e um cabo para o uso do <a href="https://man.freebsd.org/cgi/man.cgi?query=dcons&amp;sektion=4&amp;format=html">dcons(4)</a> e habilidades de depuração do kernel.</p></div><div class=paragraph><p>Para ajudar a isolar o problema, descarregue o maior número possível de drivers. Se funcionar, diminua o driver que é o problema carregando os drivers até que ele falhe novamente. Normalmente, drivers binários como <span class=filename>nvidia.ko</span>, drivers de exibição e USB terão mais problemas, enquanto as interfaces Ethernet normalmente funcionam bem. Se os drivers puderem ser carregados e descarregados adequadamente, automatize isso colocando os comandos apropriados em <span class=filename>/etc/rc.suspend</span> e <span class=filename>/etc/rc.resume</span>. Tente configurar o <code>hw.acpi.reset_video</code> para <code>1</code> se a tela estiver desarrumada após a retomada. Tente definir valores mais longos ou mais curtos para <code>hw.acpi.sleep_delay</code> para ver se isso ajuda.</p></div><div class=paragraph><p>Tente carregar uma distribuição recente do Linux™ para ver se o suspend/resume funciona no mesmo hardware. Se funciona no Linux™, é provável que seja um problema no driver do FreeBSD. Descobrir qual driver causa o problema ajudará os desenvolvedores a corrigir o problema. Como os mantenedores do ACPI raramente mantêm outros drivers, como som ou ATA, qualquer problema de driver também deve ser postado na lista <a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-current>freebsd-current</a> e enviada para o mantenedor do driver. Os usuários avançados podem incluir os <a href="https://man.freebsd.org/cgi/man.cgi?query=printf&amp;sektion=3&amp;format=html">printf(3)</a>s de debug do driver problemático para rastrear onde, em sua função de reinício, ele é interrompido.</p></div><div class=paragraph><p>Por fim, tente desativar o ACPI e ativar o APM. Se o comando suspend/resume funcionar com APM, use o APM, especialmente em hardware mais antigo (anterior a 2000). Demorou algum tempo para que os fornecedores obtivessem suporte ACPI correto e os hardwares antigos são mais prováveis de terem problemas de BIOS com ACPI.</p></div></div><div class=sect4><h5 id=_travamentos_do_sistema>11.13.2.3. Travamentos do sistema<a class=anchor href=#_travamentos_do_sistema></a></h5><div class=paragraph><p>A maioria dos travamentos do sistema é resultado de interrupções perdidas ou de uma tempestade de interrupções. Chipsets podem ter problemas com base na inicialização, como o BIOS configura as interrupções antes da correção da tabela APIC (MADT) e o roteamento do sistema de controle de interrupções (SCI).</p></div><div class=paragraph><p>Tempestades de interrupção podem ser distinguidas de interrupções perdidas, verificando a saída do <code>vmstat -i</code> e observando a linha que possui <code>acpi0</code>. Se o contador está aumentando em mais de um par por segundo, há uma tempestade de interrupção. Se o sistema parece travado, tente acessar o DDB (<span class=keyseq><kbd>CTRL</kbd>+<kbd>ALT</kbd>+<kbd>ESC</kbd></span> no console) e digite <code>show interrupts</code>.</p></div><div class=paragraph><p>Ao lidar com problemas de interrupção, tente desativar o suporte ao APIC com <code>hint.apic.0.disabled="1"</code> no <span class=filename>/boot/loader.conf</span> .</p></div></div><div class=sect4><h5 id=_panics>11.13.2.4. Panics<a class=anchor href=#_panics></a></h5><div class=paragraph><p>Os panics são relativamente raros para ACPI e são a prioridade máxima a ser corrigida. O primeiro passo é isolar as etapas para reproduzir o panic, se possível, e obter um backtrace. Siga as instruções para habilitar <code>options DDB</code> e configurar um console serial em <a href=./#serialconsole-ddb>Entrando no Depurador DDB da Linha Serial</a> ou configurar uma partição de despejo. Para obter um backtrace no DDB, use <code>tr</code>. Ao escrever o backtrace, obtenha pelo menos as cinco últimas e as cinco principais linhas do rastro.</p></div><div class=paragraph><p>Em seguida, tente isolar o problema inicializando com ACPI desabilitado. Se isso funcionar, isole o subsistema ACPI usando vários valores de <code>debug.acpi.disable</code>. Veja <a href="https://man.freebsd.org/cgi/man.cgi?query=acpi&amp;sektion=4&amp;format=html">acpi(4)</a> para alguns exemplos.</p></div></div><div class=sect4><h5 id=_o_sistema_é_ativado_após_a_sua_suspensão_ou_desligamento>11.13.2.5. O sistema é ativado após a sua suspensão ou desligamento<a class=anchor href=#_o_sistema_é_ativado_após_a_sua_suspensão_ou_desligamento></a></h5><div class=paragraph><p>Primeiro, tente definir <code>hw.acpi.disable_on_poweroff="0"</code> no <span class=filename>/boot/loader.conf</span>. Isso impede que a ACPI desative vários eventos durante o processo de desligamento. Alguns sistemas precisam desse valor definido como <code>1</code> (o padrão) pelo mesmo motivo. Isso geralmente corrige o problema de um sistema ser ativado espontaneamente após uma suspensão ou desligamento.</p></div></div><div class=sect4><h5 id=ACPI-aslanddump>11.13.2.6. BIOS contém Bytecode com bugs<a class=anchor href=#ACPI-aslanddump></a></h5><div class=paragraph><p>Alguns fornecedores de BIOS fornecem bytecode incorreto ou com bugs. Isso geralmente é manifestado por mensagens do console do kernel como esta:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>ACPI-1287: <span class=k>***</span> Error: Method execution failed <span class=o>[</span><span class=se>\\</span>_SB_.PCI0.LPC0.FIGD._STA] <span class=se>\\</span>
<span class=o>(</span>Node 0xc3f6d160<span class=o>)</span>, AE_NOT_FOUND</code></pre></div></div><div class=paragraph><p>Geralmente, esses problemas podem ser resolvidos com a atualização do BIOS para a revisão mais recente. A maioria das mensagens do console é inofensiva, mas se houver outros problemas, como o status da bateria não estar funcionando, essas mensagens são um bom lugar para começar a procurar por problemas.</p></div></div></div><div class=sect3><h4 id=_substituindo_o_padrão_aml>11.13.3. Substituindo o padrão AML<a class=anchor href=#_substituindo_o_padrão_aml></a></h4><div class=paragraph><p>O bytecode do BIOS, conhecido como ACPI Machine Language (AML), é compilado de uma linguagem de origem chamada ACPI Source Language (ASL). O AML é encontrado na tabela conhecida como Tabela de Descrição do Sistema Diferenciado (Differentiated System Description Table - DSDT).</p></div><div class=paragraph><p>O objetivo do FreeBSD é que todos trabalhem com ACPI sem qualquer intervenção do usuário. Soluções alternativas ainda estão sendo desenvolvidas para erros comuns feitos pelos fornecedores de BIOS. O interpretador Microsoft™ (<span class=filename>acpi.sys</span> e <span class=filename>acpiec.sys</span>) não verifica rigorosamente a conformidade com o padrão e, portanto, muitos fornecedores de BIOS que testam apenas ACPI sob Windows™ nunca corrigem seu ASL. Os desenvolvedores do FreeBSD continuam a identificar e documentar qual comportamento não padrão é permitido pelo interpretador da Microsoft™ para replicá-lo para que o FreeBSD possa funcionar sem forçar os usuários a corrigir o ASL.</p></div><div class=paragraph><p>Para ajudar a identificar o comportamento de bugs e possivelmente corrigi-lo manualmente, uma cópia pode ser feita do ASL do sistema. Para copiar o ASL do sistema para um nome de arquivo especificado, use <code>acpidump</code> com <code>-t</code>, para mostrar o conteúdo das tabelas fixas e <code>-d</code>, para desmontar o AML:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># acpidump -td &gt; my.asl</span></code></pre></div></div><div class=paragraph><p>Algumas versões de AML assumem que o usuário está executando o Windows™. Para sobrescrever isto, defina <code>hw.acpi.osname=<em>"Windows 2009"</em></code> no <span class=filename>/boot/loader.conf</span>, usando a mais recente versão do Windows™ listada no ASL.</p></div><div class=paragraph><p>Outras soluções alternativas podem exigir que o <span class=filename>my.asl</span> seja personalizado. Se este arquivo for editado, compile o novo ASL usando o seguinte comando. Os avisos geralmente podem ser ignorados, mas erros são bugs que geralmente impedem que o ACPI funcione corretamente.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># iasl -f my.asl</span></code></pre></div></div><div class=paragraph><p>Incluir <code>-f</code> força a criação do AML, mesmo que haja erros durante a compilação. Alguns erros, como a falta de declarações de retorno, são automaticamente contornados pelo interpretador do FreeBSD.</p></div><div class=paragraph><p>O nome do arquivo de saída padrão para <code>iasl</code> é <span class=filename>DSDT.aml</span>. Carregue este arquivo em vez da cópia com bugs do BIOS, que ainda está presente na memória flash, editando o <span class=filename>/boot/loader.conf</span> como segue:</p></div><div class="literalblock programlisting"><div class=content><pre>acpi_dsdt_load=&#34;YES&#34;
acpi_dsdt_name=&#34;/boot/DSDT.aml&#34;</pre></div></div><div class=paragraph><p>Certifique-se de copiar o <span class=filename>DSDT.aml</span> para <span class=filename>/boot</span> e, em seguida, reinicialize o sistema. Se isso resolver o problema, envie um <a href="https://man.freebsd.org/cgi/man.cgi?query=diff&amp;sektion=1&amp;format=html">diff(1)</a> do antigo e novo ASL para a lista <a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-acpi>freebsd-acpi</a> para que os desenvolvedores possam contornar o comportamento de bugs no <span class=filename>acpica</span>.</p></div></div><div class=sect3><h4 id=ACPI-submitdebug>11.13.4. Obtendo e enviando informações de depuração<a class=anchor href=#ACPI-submitdebug></a></h4><div class=paragraph><p>O driver ACPI possui um recurso de depuração flexível. Um conjunto de subsistemas e o nível de detalhamento podem ser especificados. Os subsistemas a serem depurados são especificados como camadas e são divididos em componentes (<code>ACPI_ALL_COMPONENTS</code>) e suporte de hardware ACPI (<code>ACPI_ALL_DRIVERS</code>). O detalhamento da saída de depuração é especificado como o nível e varia de apenas erros de relatório (<code>ACPI_LV_ERROR</code>) para tudo (<code>ACPI_LV_VERBOSE</code>). O nível é uma máscara de bits, por isso, várias opções podem ser definidas de uma só vez, separadas por espaços. Na prática, um console serial deve ser usado para registrar a saída para que ela não seja perdida quando o buffer de mensagem do console for liberado. Uma lista completa das camadas e níveis individuais é encontrada em <a href="https://man.freebsd.org/cgi/man.cgi?query=acpi&amp;sektion=4&amp;format=html">acpi(4)</a>.</p></div><div class=paragraph><p>A saída de depuração não está ativada por padrão. Para ativá-la, adicione as opções <code>ACPI_DEBUG</code> ao arquivo de configuração do kernel personalizado se ACPI estiver compilado no kernel. Adicione <code>ACPI_DEBUG=1</code> ao <span class=filename>/etc/make.conf</span> para ativá-lo globalmente. Se um módulo for usado em vez de um kernel personalizado, recompile apenas o módulo <span class=filename>acpi.ko</span> como segue:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /sys/modules/acpi/acpi &amp;&amp; make clean &amp;&amp; make ACPI_DEBUG=1</span></code></pre></div></div><div class=paragraph><p>Copie o <span class=filename>acpi.ko</span> compilado para <span class=filename>/boot/kernel</span> e adicione o nível e camada desejados ao <span class=filename>/boot/loader.conf</span>. As entradas neste exemplo permitem mensagens de depuração para todos os componentes e drivers de hardware ACPI e mensagens de erro de saída no nível menos detalhado:</p></div><div class="literalblock programlisting"><div class=content><pre>debug.acpi.layer=&#34;ACPI_ALL_COMPONENTS ACPI_ALL_DRIVERS&#34;
debug.acpi.level=&#34;ACPI_LV_ERROR&#34;</pre></div></div><div class=paragraph><p>Se as informações necessárias forem acionadas por um evento específico, como suspend e resume, não modifique o <span class=filename>/boot/loader.conf</span>. Em vez disso, use o <code>sysctl</code> para especificar o layer e o nível após inicializar e preparar o sistema para o evento específico. As variáveis que podem ser definidas usando <code>sysctl</code> são nomeadas da mesma forma que os parâmetros no <span class=filename>/boot/loader.conf</span>.</p></div><div class=paragraph><p>Depois que as informações de depuração forem coletadas, elas podem ser enviadas para a lista <a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-acpi>freebsd-acpi</a> para que possam ser usadas pelos mantenedores do FreeBSD ACPI para identificar a causa raiz do problema e desenvolver uma solução.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Antes de enviar as informações de depuração para esta lista, certifique-se de que a versão mais recente do BIOS esteja instalada e, se disponível, a versão do firmware do controlador incorporado.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Ao enviar um relatório de problemas, inclua as seguintes informações:</p></div><div class=ulist><ul><li><p>Descrição do comportamento de bugs, incluindo tipo de sistema, modelo e qualquer coisa que faça com que o erro apareça. Explique com a maior precisão possível quando o bug começou a ocorrer se for novo.</p></li><li><p>A saída do <code>dmesg</code> após executar <code>boot -v</code>, incluindo quaisquer mensagens de erro geradas pelo bug.</p></li><li><p>A saída <code>dmesg</code> do <code>boot -v</code> com o ACPI desabilitado, se a desativação do ACPI ajudar a corrigir o problema.</p></li><li><p>Saída do <code>sysctl hw.acpi</code>. Isso lista quais recursos o sistema oferece.</p></li><li><p>A URL para uma versão do ASL do sistema hospedada na web. <em>Não</em> envie o ASL diretamente para a lista, pois pode ser muito grande. Gere uma cópia do ASL executando este comando:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># acpidump -dt &gt; name-system.asl</span></code></pre></div></div><div class=paragraph><p>Substitua o nome de login para <em>name</em> e fabricante/modelo para <em>system</em>. Por exemplo, use <span class=filename>njl-FooCo6000.asl</span>.</p></div></li></ul></div><div class=paragraph><p>A maioria dos desenvolvedores do FreeBSD assina a lista de discussão <a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-current>FreeBSD-CURRENT</a>, mas deve-se enviar os problemas para a lista <a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-acpi>freebsd-acpi</a> para ter certeza de que ele será visto. Seja paciente ao esperar por uma resposta. Se o bug não for imediatamente aparente, envie um relatório de bug. Ao inserir um PR, inclua as mesmas informações solicitadas acima. Isso ajuda os desenvolvedores a rastrear o problema e resolvê-lo. Não envie um PR sem enviar primeiro um e-mail para a lista <a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-acpi>freebsd-acpi</a> pois é provável que o problema já tenha sido relatado antes.</p></div></div><div class=sect3><h4 id=ACPI-References>11.13.5. Referências<a class=anchor href=#ACPI-References></a></h4><div class=paragraph><p>Mais informações sobre ACPI podem ser encontradas nos seguintes locais:</p></div><div class=ulist><ul><li><p>Arquivos da lista de e-mail do FreeBSD ACPI (<a href=https://lists.freebsd.org/pipermail/freebsd-acpi/>https://lists.freebsd.org/pipermail/freebsd-acpi/</a>)</p></li><li><p>A <a href=https://uefi.org/specifications#ACPI>especificação ACPI</a></p></li><li><p><a href="https://man.freebsd.org/cgi/man.cgi?query=acpi&amp;sektion=4&amp;format=html">acpi(4)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=acpi_thermal&amp;sektion=4&amp;format=html">acpi_thermal(4)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=acpidump&amp;sektion=8&amp;format=html">acpidump(8)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=iasl&amp;sektion=8&amp;format=html">iasl(8)</a>, e <a href="https://man.freebsd.org/cgi/man.cgi?query=acpidb&amp;sektion=8&amp;format=html">acpidb(8)</a></p></li></ul></div></div></div></div></div><div class=sect1><h2 id=boot>Capítulo 12. O processo de inicialização do FreeBSD<a class=anchor href=#boot></a></h2><div class=sectionbody><div class=sect2><h3 id=boot-synopsis>12.1. Sinopse<a class=anchor href=#boot-synopsis></a></h3><div class=paragraph><p>O processo de iniciar um computador e carregar o sistema operacional é chamado de "processo de bootstrap", ou de "inicialização". O processo de boot do FreeBSD fornece uma grande flexibilidade na personalização do que acontece quando o sistema é iniciado, incluindo a capacidade de selecionar diferentes sistemas operacionais instalados no mesmo computador, diferentes versões do mesmo sistema operacional ou um kernel instalado diferente.</p></div><div class=paragraph><p>Este capítulo detalha as opções de configuração que podem ser definidas. Ele demonstra como personalizar o processo de inicialização do FreeBSD, incluindo tudo o que acontece até que o kernel do FreeBSD tenha iniciado, procurado por dispositivos e iniciado o <a href="https://man.freebsd.org/cgi/man.cgi?query=init&amp;sektion=8&amp;format=html">init(8)</a>. Isso ocorre quando a cor do texto das mensagens de inicialização muda de branco brilhante para cinza.</p></div><div class=paragraph><p>Depois de ler este capítulo, você reconhecerá:</p></div><div class=ulist><ul><li><p>Os componentes do sistema de boot do FreeBSD e como eles interagem.</p></li><li><p>As opções que podem ser passadas para os componentes no bootstrap do FreeBSD para controlar o processo de inicialização.</p></li><li><p>Como configurar uma tela personalizada de inicialização.</p></li><li><p>O básico da configuração de device hints.</p></li><li><p>Como inicializar no modo de usuário único e multiusuário e como encerrar corretamente um sistema FreeBSD.</p></li></ul></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Este capítulo descreve apenas o processo de inicialização do FreeBSD rodando em sistemas x86 e amd64.</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=boot-introduction>12.2. Processo de Inicialização do FreeBSD<a class=anchor href=#boot-introduction></a></h3><div class=paragraph><p>Ligar um computador e iniciar o sistema operacional representa um dilema interessante. Por definição, o computador não sabe como fazer nada até que o sistema operacional seja iniciado. Isso inclui executar programas a partir do disco. Se o computador não pode executar um programa a partir do disco sem o sistema operacional e os programas do sistema operacional estão no disco, como o sistema operacional é iniciado?</p></div><div class=paragraph><p>Este problema é semelhante ao do livro As Aventuras do Barão de Munchausen. Um personagem tinha caído no meio de um bueiro, e se retirou agarrando suas botas e levantando. Nos primeiros dias da computação, o termo <em>bootstrap</em> era aplicado ao mecanismo usado para carregar o sistema operacional. Desde então, foi encurtado para "booting".</p></div><div class=paragraph><p>No hardware x86, o Sistema Básico de Entrada/Saída (BIOS) é responsável por carregar o sistema operacional. O BIOS procura no disco rígido pelo Master Boot Record (MBR), que deve estar localizado em um local específico do disco. O BIOS tem conhecimento suficiente para carregar e executar o MBR, e assume que o MBR pode então executar o restante das tarefas envolvidas no carregamento do sistema operacional, possivelmente com a ajuda do BIOS.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>O FreeBSD permite inicializar a partir do padrão mais antigo do MBR e da nova Tabela de Partição GUID (GPT). O particionamento GPT geralmente é encontrado em computadores com a Interface de Firmware Unificada e Extensivel (UEFI). No entanto, o FreeBSD pode inicializar a partir de partições de GPT mesmo em máquinas com apenas BIOS legado com o <a href="https://man.freebsd.org/cgi/man.cgi?query=gptboot&amp;sektion=8&amp;format=html">gptboot(8)</a>. O trabalho está em andamento para fornecer a inicialização direta a partir do UEFI.</p></div></td></tr></tbody></table></div><div class=paragraph><p>O código dentro do MBR é normalmente chamado de <em>gerenciador de inicialização</em>, especialmente quando ele interage com o usuário. O gerenciador de inicialização geralmente tem mais código na primeira faixa do disco ou dentro do sistema de arquivos. Exemplos de gerenciadores de inicialização incluem o gerenciador de boot padrão do FreeBSD boot0, também chamado Boot Easy, e o Grub, que é usado por muitas distribuições Linux™.</p></div><div class=paragraph><p>Se apenas um sistema operacional estiver instalado, o MBR procura pelo primeiro slice inicializável (ativo) no disco e, em seguida, executa o código nesse slice para carregar o restante do sistema operacional. Quando vários sistemas operacionais estão presentes, um gerenciador de inicialização diferente pode ser instalado para exibir uma lista de sistemas operacionais para que o usuário possa selecionar um para inicializar.</p></div><div class=paragraph><p>O restante do sistema de boot do FreeBSD é dividido em três estágios. O primeiro estágio sabe apenas o suficiente para colocar o computador em um estado específico e executar o segundo estágio. O segundo estágio pode fazer um pouco mais, antes de executar o terceiro estágio. O terceiro estágio termina a tarefa de carregar o sistema operacional. O trabalho é dividido em três etapas porque o MBR coloca limites no tamanho dos programas que podem ser executados nos estágios um e dois. Encadear as tarefas juntas permite que o FreeBSD forneça um carregador mais flexível.</p></div><div class=paragraph><p>O kernel é então iniciado e começa a sondar os dispositivos e inicializá-los para uso. Quando o processo de inicialização do kernel é finalizado, o kernel passa o controle para o processo de usuário <a href="https://man.freebsd.org/cgi/man.cgi?query=init&amp;sektion=8&amp;format=html">init(8)</a>, que garante que os discos estejam em estado utilizável, inicia a configuração de recursos no nível de usuário que monta sistemas de arquivos, configura placas de rede para se comunicar na rede e inicia os processos que foram configurados para serem executados na inicialização.</p></div><div class=paragraph><p>Esta seção descreve esses estágios em mais detalhes e demonstra como interagir com o processo de inicialização do FreeBSD.</p></div><div class=sect3><h4 id=boot-boot0>12.2.1. O gerenciador de inicialização<a class=anchor href=#boot-boot0></a></h4><div class=paragraph><p>O código do gerenciador de inicialização no MBR é às vezes chamado de <em>estágio zero</em> do processo de inicialização. Por padrão, o FreeBSD usa o gerenciador de boot boot0.</p></div><div class=paragraph><p>O MBR instalado pelo instalador do FreeBSD é baseado no <span class=filename>/boot/boot0</span>. O tamanho e a capacidade do boot0 são restritos a 446 bytes devido à tabela de slices e ao identificador <code>0x55AA</code> no final do MBR. Se o boot0 e vários sistemas operacionais estiverem instalados, uma mensagem semelhante a este exemplo será exibida no momento da inicialização:</p></div><div id=boot-boot0-example class=exampleblock><div class=title>Exemplo 27. Captura de tela do <span class=filename>boot0</span></div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>F1 Win
F2 FreeBSD

Default: F2</code></pre></div></div></div></div><div class=paragraph><p>Outros sistemas operacionais sobrescreverão um MBR existente se forem instalados após o FreeBSD. Se isto acontecer, ou para substituir o MBR existente com o MBR do FreeBSD, use o seguinte comando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># fdisk -B -b /boot/boot0 device</span></code></pre></div></div><div class=paragraph><p>onde <em>device</em> é o disco de inicialização, como <span class=filename>ad0</span> para o primeiro disco IDE, <span class=filename>ad2</span> para o primeiro disco IDE em um segundo controlador IDE, ou <span class=filename>da0</span> para o primeiro disco SCSI. Para criar uma configuração personalizada do MBR, consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=boot0cfg&amp;sektion=8&amp;format=html">boot0cfg(8)</a>.</p></div></div><div class=sect3><h4 id=boot-boot1>12.2.2. Estágio Um e Estágio Dois<a class=anchor href=#boot-boot1></a></h4><div class=paragraph><p>Conceitualmente, o primeiro e o segundo estágios fazem parte do mesmo programa na mesma área do disco. Por causa das restrições de espaço, eles foram divididos em dois, mas são sempre instalados juntos. Eles são copiados do combinado <span class=filename>/boot/boot</span> pelo instalador do FreeBSD ou pelo <code>bsdlabel</code>.</p></div><div class=paragraph><p>Estes dois estágios estão localizados fora do sistema de arquivos, na primeira trilha do slice de inicialização, começando pelo primeiro setor. É ali onde o boot0, ou qualquer outro gerenciador de inicialização, espera encontrar um programa para executar, o qual continuará o processo de inicialização.</p></div><div class=paragraph><p>O primeiro estágio, <span class=filename>boot1</span>, é muito simples, pois pode ter apenas 512 bytes de tamanho. Ele sabe o suficiente sobre o FreeBSD <em>bsdlabel</em>, que armazena informações sobre o slice, para localizar e executar o <span class=filename>boot2</span>.</p></div><div class=paragraph><p>O estágio dois, <span class=filename>boot2</span>, é um pouco mais sofisticado, e entende o sistema de arquivos do FreeBSD o suficiente para encontrar arquivos. Ele pode fornecer uma interface simples para escolher o kernel ou loader para ser executado. Ele executa o loader, que é muito mais sofisticado e fornece um arquivo de configuração de inicialização. Se o processo de inicialização for interrompido no estágio dois, a seguinte tela interativa será exibida:</p></div><div id=boot-boot2-example class=exampleblock><div class=title>Exemplo 28. Captura de tela do <span class=filename>boot2</span></div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=o>&gt;&gt;</span> FreeBSD/i386 BOOT
Default: 0:ad<span class=o>(</span>0,a<span class=o>)</span>/boot/loader
boot:</code></pre></div></div></div></div><div class=paragraph><p>Para substituir o <span class=filename>boot1</span> e <span class=filename>boot2</span> instalados, use o <code>bsdlabel</code>, onde <em>diskslice</em> é o disco e o slice para inicializar, como <span class=filename>ad0s1</span> para o primeiro slice no primeiro disco IDE:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># bsdlabel -B diskslice</span></code></pre></div></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Se apenas o nome do disco for usado, como <span class=filename>ad0</span>, o <code>bsdlabel</code> criará o disco no "modo perigosamente dedicado", sem slices. Esta provavelmente não é a ação desejada, então verifique novamente o <em>diskslice</em> antes de pressionar <kbd>Return</kbd>.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=boot-loader>12.2.3. Estágio três<a class=anchor href=#boot-loader></a></h4><div class=paragraph><p>O loader é o estágio final do processo de bootstrap de três estágios. Ele está localizado no sistema de arquivos, geralmente como <span class=filename>/boot/loader</span>.</p></div><div class=paragraph><p>O loader é projetado como um método interativo para configuração, usando um conjunto de comandos embutidos, auxiliado por um interpretador mais poderoso que possui um conjunto de comandos mais complexo.</p></div><div class=paragraph><p>Durante a inicialização, o loader procurará por um console e por discos, e descobrirá de qual disco está sendo inicializado. Ele irá definir as variáveis de acordo, e um interpretador é iniciado onde os comandos do usuário podem ser passados a partir de um script ou usados interativamente.</p></div><div class=paragraph><p>O loader então lerá o <span class=filename>/boot/loader.rc</span>, que por padrão lê o <span class=filename>/boot/defaults/loader.conf</span> que define padrões razoáveis para variáveis e lê o <span class=filename>/boot/loader.conf</span> para mudanças locais nessas variáveis. O <span class=filename>loader.rc</span> então age sobre essas variáveis, carregando os módulos e o kernel selecionados.</p></div><div class=paragraph><p>Finalmente, por padrão, o loader realiza uma espera de 10 segundos por pressionamentos de teclas, e inicializa o kernel se não for interrompido. Se interrompido, o usuário é apresentado a um prompt que compreende o conjunto de comandos, no qual o usuário pode ajustar variáveis, descarregar todos os módulos, carregar módulos e finalmente inicializar ou reinicializar. <a href=#boot-loader-commands>Comandos Internos do Loader</a> lista os comandos do loader mais usados. Para uma discussão completa de todos os comandos disponíveis, consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=loader&amp;sektion=8&amp;format=html">loader(8)</a>.</p></div><table id=boot-loader-commands class="tableblock frame-none grid-all stretch"><caption class=title>Tabela 9. Comandos Internos do Loader</caption><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Variável</th><th class="tableblock halign-left valign-top">Descrição</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>autoboot <em>segundos</em></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Prossegue para inicializar o kernel se não for interrompido dentro do intervalo de tempo dado, em segundos. Ele exibe uma contagem regressiva e o intervalo de tempo padrão é de 10 segundos.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>boot <code>[<em>-options</em>] [<em>kernelname]</em></code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Imediatamente prossegue a inicialização do kernel, com qualquer opção especificada ou nome do kernel. Fornecer um nome de kernel na linha de comando só é aplicável depois que um <code>unload</code> foi emitido. Caso contrário, o kernel previamente carregado será usado. Se o <em>nomedokernel</em> não estiver qualificado, ele será pesquisado em <em>/boot/kernel</em> e <em>/boot/modules</em>.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>boot-conf</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Passa pela mesma configuração automática de módulos baseada em variáveis especificadas, mais comumente <code>kernel</code>. Isso só faz sentido se <code>unload</code> for usado primeiro, antes de alterar algumas variáveis.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>help <code>[<em>tópico</em>]</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Mostra mensagens de ajuda lidas de <span class=filename>/boot/loader.help</span>. Se o tópico fornecido for <code>index</code>, a lista de tópicos disponíveis será exibida.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>include <em>nomedoarquivo</em>…​</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Lê o arquivo especificado e interpreta-o linha por linha. Um erro interrompe imediatamente o <code>include</code>.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>load <code>[-t <em>type</em>]</code> <em>filename</em></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Carrega o kernel, módulo do kernel ou arquivo do tipo especificado, com o nome de arquivo especificado. Quaisquer argumentos após o <em>nomedoarquivo</em> são passados para o arquivo. Se <em>nomedoarquivo</em> não estiver qualificado, ele será pesquisado em <em>/boot/kernel</em> e <em>/boot/modules</em>.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>ls [-l] <code>[<em>path</em>]</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Exibe uma listagem de arquivos do caminho fornecido ou do diretório raiz, se o caminho não for especificado. Se <code>-l</code> for especificado, os tamanhos dos arquivos também serão mostrados.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>lsdev [-v]</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Lista todos os dispositivos dos quais é possível carregar módulos. Se <code>-v</code> for especificado, mais detalhes serão impressos.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>lsmod [-v]</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Exibe os módulos carregados. Se <code>-v</code> for especificado, mais detalhes serão mostrados.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>more <em>nomedoarquivo</em></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Exibe os arquivos especificados, com uma pausa em cada <code>LINES</code> exibidas.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>reboot</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Reinicia imediatamente o sistema.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>set <em>variable</em>, set <em>variable</em>=<em>value</em></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Define as variáveis de ambiente especificadas.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>unload</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Remove todos os módulos carregados.</p></td></tr></tbody></table><div class=paragraph><p>Aqui estão alguns exemplos práticos de uso do loader. Para inicializar o kernel usual no modo single-user :</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> boot <span class=nt>-s</span></code></pre></div></div><div class=paragraph><p>Para descarregar o kernel e os módulos usuais e, em seguida, carregar o kernel anterior ou outro especificado:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> unload
 load kernel.old</code></pre></div></div><div class=paragraph><p>Use o <span class=filename>kernel.GENERIC</span> para se referir ao kernel padrão que vem com uma instalação, ou <span class=filename>kernel.old</span>, para se referir ao kernel previamente instalado antes de uma atualização do sistema ou antes de configurar um kernel personalizado.</p></div><div class=paragraph><p>Use o seguinte para carregar os módulos usuais com outro kernel:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> unload
 <span class=nb>set </span><span class=nv>kernel</span><span class=o>=</span><span class=s2>&#34;kernel.old&#34;</span>
 boot-conf</code></pre></div></div><div class=paragraph><p>Para carregar um script de configuração do kernel automatizado:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> load <span class=nt>-t</span> userconfig_script /boot/kernel.conf</code></pre></div></div></div><div class=sect3><h4 id=boot-init>12.2.4. Último estágio<a class=anchor href=#boot-init></a></h4><div class=paragraph><p>Quando o kernel é carregado pelo loader ou pelo boot2, que ignora o loader, ele examina qualquer flag de inicialização e ajusta seu comportamento conforme necessário. <a href=#boot-kernel>Interação do Kernel durante o Boot</a> lista os flags de inicialização comumente usados. Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=boot&amp;sektion=8&amp;format=html">boot(8)</a> para obter mais informações sobre os outros sinalizadores de inicialização.</p></div><table id=boot-kernel class="tableblock frame-none grid-all stretch"><caption class=title>Tabela 10. Interação do Kernel durante o Boot</caption><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Opção</th><th class="tableblock halign-left valign-top">Descrição</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>-a</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Durante a inicialização do kernel, solicita que o dispositivo seja montado como o sistema de arquivos raiz.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>-C</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Inicialize o sistema de arquivos raiz a partir de um CDROM.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>-s</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Inicialize no modo single-user.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>-v</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Seja mais detalhado durante a inicialização do kernel.</p></td></tr></tbody></table><div class=paragraph><p>Uma vez que o kernel terminou a inicialização, ele passa o controle para o processo de usuário <a href="https://man.freebsd.org/cgi/man.cgi?query=init&amp;sektion=8&amp;format=html">init(8)</a>, localizado em <span class=filename>/sbin/init</span>, ou o caminho do programa especificado na variável <code>init_path</code> no <code>loader</code>. Este é o último estágio do processo de inicialização.</p></div><div class=paragraph><p>A sequência de inicialização garante que os sistemas de arquivos disponíveis no sistema estejam consistentes. Se um sistema de arquivos UFS não estiver e o <code>fsck</code> não puder corrigir as inconsistências, o init jogará o sistema no modo single-user para que o administrador do sistema possa resolver o problema diretamente. Caso contrário, o sistema é inicializado no modo multi-user.</p></div><div class=sect4><h5 id=boot-singleuser>12.2.4.1. Modo Single-User<a class=anchor href=#boot-singleuser></a></h5><div class=paragraph><p>Um usuário pode especificar este modo inicializando com <code>-s</code> ou definindo a variável <code>boot_single</code> no loader. Ele também pode ser alcançado executando o <code>shutdown now</code> do modo multi-user. O modo single-user começa com esta mensagem:</p></div><div class="literalblock programlisting"><div class=content><pre>Enter full pathname of shell or RETURN for /bin/sh:</pre></div></div><div class=paragraph><p>Se o usuário pressionar <kbd>Enter</kbd>, o sistema entrará no Bourne shell padrão. Para especificar um shell diferente, insira o caminho completo para o shell.</p></div><div class=paragraph><p>O modo single-user é geralmente usado para reparar um sistema que não inicializa devido a um sistema de arquivos inconsistente ou a um erro em um arquivo de configuração de inicialização. Ele também pode ser usado para redefinir a senha do <code>root</code> quando ela é desconhecida. Essas ações são possíveis porque o prompt do modo single-user fornece acesso local completo ao sistema e seus arquivos de configuração. Não há rede neste modo.</p></div><div class=paragraph><p>Embora o modo single-user seja útil para reparar um sistema, ele representa um risco de segurança, a menos que o sistema esteja em um local fisicamente seguro. Por padrão, qualquer usuário que possa obter acesso físico a um sistema terá controle total desse sistema após a inicialização no modo single-user.</p></div><div class=paragraph><p>Se o <code>console</code> do sistema for alterado para <code>insecure</code> em <span class=filename>/etc/ttys</span>, o sistema solicitará primeiro a senha do <code>root</code> antes de iniciar o modo single-user. Isso adiciona uma medida de segurança ao remover a capacidade de redefinir a senha do <code>root</code> quando ela é desconhecida.</p></div><div id=boot-insecure-console class=exampleblock><div class=title>Exemplo 29. Configurando um Console Inseguro em <span class=filename>/etc/ttys</span></div><div class=content><div class="literalblock programlisting"><div class=content><pre># name  getty                           type    status          comments
#
# If console is marked &#34;insecure&#34;, then init will ask for the root password
# when going to single-user mode.
console none                            unknown off insecure</pre></div></div></div></div><div class=paragraph><p>Um console <code>inseguro</code> significa que a segurança física para o console é considerada insegura, portanto, apenas alguém que conheça a senha do <code>root</code> pode usar o modo single-user.</p></div></div><div class=sect4><h5 id=boot-multiuser>12.2.4.2. Modo Multi-User<a class=anchor href=#boot-multiuser></a></h5><div class=paragraph><p>Se o init encontrar os sistemas de arquivos em ordem, ou quando o usuário tiver concluído seus comandos no modo de usuário único e tiver digitado <code>exit</code> para deixar o modo single-user, o sistema entra no modo multi-user, no qual inicia a configuração de recursos do sistema.</p></div><div class=paragraph><p>O sistema de configuração de recursos lê os padrões de configuração do <span class=filename>/etc/defaults/rc.conf</span> e detalhes específicos do sistema a partir do <span class=filename>/etc/rc.conf</span>. Em seguida, ele monta os sistemas de arquivos do sistema listados em <span class=filename>/etc/fstab</span>. Ele inicia serviços de rede, daemons diversos do sistema e, em seguida, os scripts de inicialização dos pacotes instalados localmente.</p></div><div class=paragraph><p>Para saber mais sobre o sistema de configuração de recursos, consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=rc&amp;sektion=8&amp;format=html">rc(8)</a> e examine os scripts localizados em <span class=filename>/etc/rc.d</span>.</p></div></div></div></div><div class=sect2><h3 id=boot-splash>12.3. Configurando telas iniciais de inicialização<a class=anchor href=#boot-splash></a></h3><div class=paragraph><p>Normalmente, quando um sistema FreeBSD inicializa, ele exibe seu progresso com uma série de mensagens no console. Uma tela inicial de inicialização cria uma tela de inicialização alternativa que oculta todo o probe de inicialização e as mensagens de inicialização de serviços. Algumas mensagens do boot loader, incluindo o menu de opções de inicialização e um prompt de contagem regressiva de espera, são exibidas no momento da inicialização, mesmo quando a tela inicial está ativada. A exibição da tela inicial pode ser desativada pressionando qualquer tecla do teclado durante o processo de inicialização.</p></div><div class=paragraph><p>Existem dois ambientes básicos disponíveis no FreeBSD. O primeiro é o ambiente padrão de linha de comando do console virtual legado. Depois que o sistema conclui a inicialização, é exibido um prompt de login do console. O segundo ambiente é um ambiente gráfico configurado. Consulte <a href=./#x11>O sistema X Window</a> para obter maiores informações sobre como instalar e configurar um gerenciador gráfico de tela e um gerenciador gráfico de login.</p></div><div class=paragraph><p>Depois que o sistema inicializa, a tela inicial é definida como proteção de tela. Após um período sem uso, a tela inicial será exibida e passará por etapas de mudança de intensidade da imagem, de brilhante a muito escuro e vice-versa. A configuração do protetor de tela inicial pode ser sobrescrita, adicionando-se uma linha <code>saver=</code> ao <span class=filename>/etc/rc.conf</span>. Vários protetores de tela embutidos estão disponíveis e descritos em <a href="https://man.freebsd.org/cgi/man.cgi?query=splash&amp;sektion=4&amp;format=html">splash(4)</a>. A opção <code>saver=</code> aplica-se apenas aos consoles virtuais e não tem efeito nos gerenciadores gráficos de telas.</p></div><div class=paragraph><p>Ao instalar o pacote ou port <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/bsd-splash-changer/>sysutils/bsd-splash-changer</a>, uma imagem inicial aleatória de uma coleção será exibida na inicialização. A função tela inicial suporta 256 cores nos formatos bitmap (<span class=filename>.bmp</span>), ZSoft PCX (<span class=filename>.pcx</span>), ou TheDraw (<span class=filename>.bin</span>). A imagem <span class=filename>.bmp</span>, <span class=filename>.pcx</span>, ou <span class=filename>.bin</span> tem que ser colocada na partição root, em <span class=filename>/boot</span> por exemplo. Os arquivos de imagens iniciais tem que ter a resolução de 320 por 200 pixels ou menos para funcionarem em adaptadores VGA padrão. Para a tela inicial padrão de 256 cores e 320 por 200 pixels ou menos, adicione as seguintes linhas ao <span class=filename>/boot/loader.conf</span>. Substitua <em>splash.bmp</em> com o nome do arquivo bitmap a ser utilizado:</p></div><div class="literalblock programlisting"><div class=content><pre>splash_bmp_load=&#34;YES&#34;
bitmap_load=&#34;YES&#34;
bitmap_name=&#34;/boot/splash.bmp&#34;</pre></div></div><div class=paragraph><p>Para usar um arquivo PCX em vez de um arquivo bitmap:</p></div><div class="literalblock programlisting"><div class=content><pre>splash_pcx_load=&#34;YES&#34;
bitmap_load=&#34;YES&#34;
bitmap_name=&#34;/boot/splash.pcx&#34;</pre></div></div><div class=paragraph><p>Em vez disso, use ASCII art no formato <a href=https://en.wikipedia.org/wiki/TheDraw>https://en.wikipedia.org/wiki/TheDraw</a>:</p></div><div class="literalblock programlisting"><div class=content><pre>splash_txt=&#34;YES&#34;
bitmap_load=&#34;YES&#34;
bitmap_name=&#34;/boot/splash.bin&#34;</pre></div></div><div class=paragraph><p>Outras opções interessantes do arquivo <span class=filename>loader.conf</span> incluem:</p></div><div class=dlist><dl><dt class=hdlist1><code>beastie_disable="YES"</code></dt><dd><p>Isso impedirá que o menu de opções de inicialização seja exibido, mas o prompt de contagem regressiva da espera programada ainda estará presente. Mesmo com a exibição do menu de opções de inicialização desabilitada, entrar com uma seleção de opção no prompt de contagem decrescente de tempo programado ativará a opção de inicialização correspondente.</p></dd><dt class=hdlist1><code>loader_logo="beastie"</code></dt><dd><p>Isso substituirá as palavras padrão "FreeBSD", que são exibidas à direita do menu de opções de inicialização, com o logotipo colorido do beastie.</p></dd></dl></div><div class=paragraph><p>Para maiores informações, consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=splash&amp;sektion=4&amp;format=html">splash(4)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=loader.conf&amp;sektion=5&amp;format=html">loader.conf(5)</a>, and <a href="https://man.freebsd.org/cgi/man.cgi?query=vga&amp;sektion=4&amp;format=html">vga(4)</a>.</p></div></div><div class=sect2><h3 id=device-hints>12.4. Sugestões de dispositivos<a class=anchor href=#device-hints></a></h3><div class=paragraph><p>Durante o começo da inicialização do sistema, o boot <a href="https://man.freebsd.org/cgi/man.cgi?query=loader&amp;sektion=8&amp;format=html">loader(8)</a> lê o <a href="https://man.freebsd.org/cgi/man.cgi?query=device.hints&amp;sektion=5&amp;format=html">device.hints(5)</a>. Este arquivo armazena informações de inicialização do kernel conhecidas como variáveis, algumas vezes referenciadas como "sugestão de devices". Estas "sugestões de devices" são usados pelos drivers de dispositivo para configuração do dispositivo.</p></div><div class=paragraph><p>As sugestões de dispositivos também são especificadas no estágio 3 do prompt do boot loader, conforme demonstrado em <a href=#boot-loader>Estágio três</a>. As variáveis podem ser adicionadas usando <code>set</code>, removidas com <code>unset</code> e visualizadas <code>show</code>. Variáveis configuradas no arquivo <span class=filename>/boot/device.hints</span> também podem ser sobrescritas. As sugestões de dispositivos inseridas no boot loader não são permanentes e não serão aplicadas na próxima reinicialização.</p></div><div class=paragraph><p>Uma vez que o sistema é inicializado, <a href="https://man.freebsd.org/cgi/man.cgi?query=kenv&amp;sektion=1&amp;format=html">kenv(1)</a> pode ser usado para despejar todas as variáveis.</p></div><div class=paragraph><p>A sintaxe para o arquivo <span class=filename>/boot/device.hints</span> é uma variável por linha, usando o hash "#" como marcadores de comentário. As linhas são construídas da seguinte forma:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> hint.driver.unit.keyword<span class=o>=</span><span class=s2>&#34;value&#34;</span></code></pre></div></div><div class=paragraph><p>A sintaxe para o estágio 3 do boot loader é:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> <span class=nb>set </span>hint.driver.unit.keyword<span class=o>=</span>value</code></pre></div></div><div class=paragraph><p>onde <code>driver</code> é o nome do driver de dispositivo, <code>unit</code> é o número da unidade de driver do dispositivo, e <code>keyword</code> é a palavra-chave sugerida. A palavra-chave pode consistir das seguintes opções:</p></div><div class=ulist><ul><li><p><code>at</code>: especifica o barramento ao qual o dispositivo está conectado.</p></li><li><p><code>port</code>: especifica o endereço inicial de I/O a ser usado.</p></li><li><p><code>irq</code>: especifica o número da requisição de interrupção a ser usada.</p></li><li><p><code>drq</code>: especifica o número do canal DMA.</p></li><li><p><code>maddr</code>: especifica o endereço de memória física ocupado pelo dispositivo.</p></li><li><p><code>flags</code>: define vários bits de flags para o dispositivo.</p></li><li><p><code>disabled</code>: se definido como <code>1</code>, o dispositivo é desativado.</p></li></ul></div><div class=paragraph><p>Como os drivers de dispositivo podem aceitar ou exigir mais sugestões não listadas aqui, é recomendável exibir uma página de manual do driver. Para obter mais informações, consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=device.hints&amp;sektion=5&amp;format=html">device.hints(5)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=kenv&amp;sektion=1&amp;format=html">kenv(1)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=loader.conf&amp;sektion=5&amp;format=html">loader.conf(5)</a>, e <a href="https://man.freebsd.org/cgi/man.cgi?query=loader&amp;sektion=8&amp;format=html">loader(8)</a>.</p></div></div><div class=sect2><h3 id=boot-shutdown>12.5. Sequência de Desligamento<a class=anchor href=#boot-shutdown></a></h3><div class=paragraph><p>Após desligamento controlado usando <a href="https://man.freebsd.org/cgi/man.cgi?query=shutdown&amp;sektion=8&amp;format=html">shutdown(8)</a>, o <a href="https://man.freebsd.org/cgi/man.cgi?query=init&amp;sektion=8&amp;format=html">init(8)</a> tentará executar o script <span class=filename>/etc/rc.shutdown</span> e, em seguida, enviará a todos os processos o sinal <code>TERM</code> e, subsequentemente, o sinal <code>KILL</code> para qualquer um que não termine em tempo hábil.</p></div><div class=paragraph><p>Para desligar uma máquina FreeBSD em arquiteturas e sistemas que suportam gerenciamento de energia, use o <code>shutdown -p now</code> para desligar a energia imediatamente. Para reinicializar um sistema FreeBSD, use o <code>shutdown -r now</code>. É preciso ser <code>root</code> ou um membro de <code>operator</code> para executar <a href="https://man.freebsd.org/cgi/man.cgi?query=shutdown&amp;sektion=8&amp;format=html">shutdown(8)</a>. Também é possível usar <a href="https://man.freebsd.org/cgi/man.cgi?query=halt&amp;sektion=8&amp;format=html">halt(8)</a> e <a href="https://man.freebsd.org/cgi/man.cgi?query=reboot&amp;sektion=8&amp;format=html">reboot(8)</a>. Consulte as páginas de manual e o <a href="https://man.freebsd.org/cgi/man.cgi?query=shutdown&amp;sektion=8&amp;format=html">shutdown(8)</a> para obter mais informações.</p></div><div class=paragraph><p>Modifique a associação ao grupo referindo-se a <a href=./#users-synopsis>Usuários e Gerenciamento Básico de Contas</a>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>O gerenciamento de energia requer que o <a href="https://man.freebsd.org/cgi/man.cgi?query=acpi&amp;sektion=4&amp;format=html">acpi(4)</a> seja carregado como um módulo ou estaticamente compilado em um kernel personalizado.</p></div></td></tr></tbody></table></div></div></div></div><div class=sect1><h2 id=security>Capítulo 13. Segurança<a class=anchor href=#security></a></h2><div class=sectionbody><div class=sect2><h3 id=security-synopsis>13.1. Sinopse<a class=anchor href=#security-synopsis></a></h3><div class=paragraph><p>A segurança, seja física ou virtual, é um tópico tão amplo que todo um setor evoluiu em torno dele. Centenas de práticas padrão foram criadas sobre como proteger sistemas e redes e, como usuário do FreeBSD, é essencial entender como se proteger contra ataques e intrusos.</p></div><div class=paragraph><p>Neste capítulo, vários fundamentos e técnicas serão discutidos. O sistema FreeBSD vem com múltiplas camadas de segurança, e muitos outros utilitários de terceiros podem ser adicionados para aumentar a segurança.</p></div><div class=paragraph><p>Depois de ler este capítulo, você saberá:</p></div><div class=ulist><ul><li><p>Conceitos básicos de segurança do sistema FreeBSD.</p></li><li><p>Os vários mecanismos de criptografia disponíveis no FreeBSD.</p></li><li><p>Como configurar a autenticação de senha única.</p></li><li><p>Como configurar o TCP Wrapper para uso com o <a href="https://man.freebsd.org/cgi/man.cgi?query=inetd&amp;sektion=8&amp;format=html">inetd(8)</a>.</p></li><li><p>Como configurar o Kerberos no FreeBSD.</p></li><li><p>Como configurar o IPsec e criar uma VPN.</p></li><li><p>Como configurar e usar o OpenSSH no FreeBSD.</p></li><li><p>Como usar ACLs para o sistema de arquivos .</p></li><li><p>Como usar o pkg para auditar pacotes de software de terceiros instalados a partir da Coleção de Ports.</p></li><li><p>Como utilizar os alertas de segurança do FreeBSD.</p></li><li><p>O que é Auditoria de Processos e como ativá-la no FreeBSD.</p></li><li><p>Como controlar os recursos do usuário usando classes de login ou o banco de dados de limites de recursos.</p></li></ul></div><div class=paragraph><p>Antes de ler este capítulo, você deve:</p></div><div class=ulist><ul><li><p>Entender os conceitos básicos do FreeBSD e de Internet.</p></li></ul></div><div class=paragraph><p>Tópicos de segurança adicionais são abordados em outras partes deste Manual. Por exemplo, o Controle de Acesso Obrigatório é discutido em <a href=./#mac>Controle de acesso obrigatório</a> e os firewalls da Internet são discutidos em <a href=./#firewalls>Firewalls</a>.</p></div></div><div class=sect2><h3 id=security-intro>13.2. Introdução<a class=anchor href=#security-intro></a></h3><div class=paragraph><p>Segurança é responsabilidade de todos. Um ponto de entrada fraco em qualquer sistema pode permitir que intrusos obtenham acesso a informações críticas e causem estragos em toda a rede. Um dos princípios centrais da segurança da informação é a tríade CIA, que significa Confidencialidade, Integridade e Disponibilidade dos sistemas de informação.</p></div><div class=paragraph><p>A tríade CIA é um conceito básico de segurança de computadores, pois os clientes e usuários esperam que seus dados sejam protegidos. Por exemplo, um cliente espera que as informações do cartão de crédito sejam armazenadas com segurança (confidencialidade), que os pedidos não sejam alterados nos bastidores (integridade) e que tenham acesso às informações do pedido em todos os momentos (disponibilidade).</p></div><div class=paragraph><p>Para fornecer CIA, os profissionais de segurança aplicam uma estratégia de defesa em profundidade. A ideia de defesa em profundidade é adicionar várias camadas de segurança para evitar que uma falha em uma única camada e faça com que todo o sistema de segurança entre em colapso. Por exemplo, um administrador do sistema não pode simplesmente ativar um firewall e considerar a rede ou o sistema seguro. É preciso também auditar contas, verificar a integridade dos binários e garantir que ferramentas maliciosas não estejam instaladas. Para implementar uma estratégia de segurança eficaz, é preciso entender as ameaças e como se defender delas.</p></div><div class=paragraph><p>O que é uma ameaça no que se refere à segurança do computador? As ameaças não se limitam a invasores remotos que tentam acessar um sistema sem permissão de um local remoto. As ameaças também incluem funcionários, softwares mal-intencionados, dispositivos de rede não autorizados, desastres naturais, vulnerabilidades de segurança e até corporações concorrentes.</p></div><div class=paragraph><p>Sistemas e redes podem ser acessados sem permissão, às vezes por acidente, ou por atacantes remotos e, em alguns casos, por meio de espionagem corporativa ou ex-funcionários. Como usuário, é importante se preparar e admitir quando um erro levou a uma violação de segurança e relatar possíveis problemas à equipe de segurança. Como administrador, é importante conhecer as ameaças e estar preparado para mitigá-las.</p></div><div class=paragraph><p>Ao aplicar a segurança aos sistemas, recomenda-se começar protegendo as contas básicas e a configuração do sistema e, em seguida, proteger a camada de rede de modo a aderir à política do sistema e aos procedimentos de segurança da organização. Muitas organizações já possuem uma política de segurança que abrange a configuração de dispositivos de tecnologia. A política deve incluir a configuração de segurança de estações de trabalho, desktops, dispositivos móveis, telefones, servidores de produção e servidores de desenvolvimento. Em muitos casos, procedimentos operacionais padrão (SOPs) já existem. Em caso de dúvida, pergunte à equipe de segurança.</p></div><div class=paragraph><p>O restante desta introdução descreve como algumas dessas configurações básicas de segurança são executadas em um sistema FreeBSD. O restante deste capítulo descreve algumas ferramentas específicas que podem ser usadas ao implementar uma política de segurança em um sistema FreeBSD.</p></div><div class=sect3><h4 id=security-accounts>13.2.1. Prevenindo Logins<a class=anchor href=#security-accounts></a></h4><div class=paragraph><p>Ao garantir a segurança de um sistema, um bom ponto de partida é uma auditoria de contas. Assegure-se de que o <code>root</code> tenha uma senha forte e que essa senha não seja compartilhada. Desabilite todas as contas que não precisam de acesso de para logar.</p></div><div class=paragraph><p>Para negar acesso de login a contas, existem dois métodos. O primeiro é bloquear a conta. Este exemplo bloqueia a conta <code>toor</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pw lock toor</span></code></pre></div></div><div class=paragraph><p>O segundo método é impedir o acesso ao login alterando o shell para <span class=filename>/usr/sbin/nologin</span>. Apenas o superusuário pode alterar o shell para outros usuários:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># chsh -s /usr/sbin/nologin toor</span></code></pre></div></div><div class=paragraph><p>O shell <span class=filename>/usr/sbin/nologin</span> impede que o sistema atribua um shell ao usuário quando ele tenta efetuar login.</p></div></div><div class=sect3><h4 id=security-accountmgmt>13.2.2. Escalonamento de Contas Permitido<a class=anchor href=#security-accountmgmt></a></h4><div class=paragraph><p>Em alguns casos, a administração do sistema precisa ser compartilhada com outros usuários. O FreeBSD tem dois métodos para lidar com isso. O primeiro, que não é recomendado, é uma senha de root compartilhada usada por membros do grupo <code>wheel</code>. Com esse método, um usuário digita <code>su</code> e insere a senha para <code>wheel</code> sempre que o acesso do superusuário for necessário. O usuário deve então digitar <code>exit</code> para deixar o acesso privilegiado após terminar os comandos que requereram acesso administrativo. Para adicionar um usuário a este grupo, edite <span class=filename>/etc/group</span> e adicione o usuário ao final da entrada <code>wheel</code>. O usuário deve ser separado por um caractere vírgula sem espaço.</p></div><div class=paragraph><p>O segundo e recomendado método para permitir o escalonamento de privilégios é instalar o pacote ou port <a class=package href=https://cgit.freebsd.org/ports/tree/security/sudo/>security/sudo</a>. Este software fornece auditoria adicional, controle de usuário mais refinado e pode ser configurado para bloquear os usuários para que executem apenas os comandos privilegiados especificados.</p></div><div class=paragraph><p>Após a instalação, use o <code>visudo</code> para editar o <span class=filename>/usr/local/etc/sudoers</span>. Este exemplo cria um novo grupo <code>webadmin</code>, adiciona a conta <code>trhodes</code> a esse grupo e configura esse acesso de grupo para reiniciar o <a class=package href=https://cgit.freebsd.org/ports/tree/apache24/>apache24</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pw groupadd webadmin -M trhodes -g 6000</span>
<span class=c># visudo</span>
%webadmin <span class=nv>ALL</span><span class=o>=(</span>ALL<span class=o>)</span> /usr/sbin/service apache24 <span class=k>*</span></code></pre></div></div></div><div class=sect3><h4 id=security-passwords>13.2.3. Hashes de Senhas<a class=anchor href=#security-passwords></a></h4><div class=paragraph><p>As senhas são um mal necessário da tecnologia. Quando elas devem ser usadas, elas devem ser complexas e um poderoso mecanismo de hash deve ser usado para criptografar a versão armazenada no banco de dados de senhas. O FreeBSD suporta os algoritmos de DES, MD5, SHA256, SHA512 e Blowfish na sua biblioteca <code>crypt()</code>. O padrão de SHA512 não deve ser alterado para um algoritmo hash menos seguro, mas pode ser alterado para o algoritmo Blowfish mais seguro.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>O Blowfish não faz parte do AES e não é considerado compatível com nenhum Federal Information Processing Standard (FIPS). Seu uso pode não ser permitido em alguns ambientes.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Para determinar qual algoritmo de hash é usado para criptografar a senha de um usuário, o superusuário pode visualizar o hash do usuário no banco de dados de senhas do FreeBSD. Cada hash começa com um símbolo que indica o tipo de mecanismo de hash usado para criptografar a senha. Se DES for usado, não haverá símbolo de início. Para MD5, o símbolo é <code>$</code>. Para SHA256 e SHA512, o símbolo é <code>$6$</code>. Para o Blowfish, o símbolo é <code>$2a$</code>. Neste exemplo, a senha para <code>dru</code> é criptografada usando o algoritmo SHA512 padrão quando o hash começa com <code>$6$</code>. Observe que o hash criptografado, não a senha em si, é armazenado no banco de dados de senhas:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># grep dru /etc/master.passwd</span>
dru:<span class=nv>$6$pzIjSvCAn</span>.PBYQBA<span class=nv>$PXpSeWPx3g5kscj3IMiM7tUEUSPmGexxta</span>.8Lt9TGSi2lNQqYGKszsBPuGME0:1001:1001::0:0:dru:/usr/home/dru:/bin/csh</code></pre></div></div><div class=paragraph><p>O mecanismo de hash é definido na classe de login do usuário. Para este exemplo, o usuário está na classe de login <code>default</code> e o algoritmo de hash é definido com esta linha em <span class=filename>/etc/login.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>        :passwd_format=sha512:\</pre></div></div><div class=paragraph><p>Para alterar o algoritmo para Blowfish, modifique a linha para ficar assim:</p></div><div class="literalblock programlisting"><div class=content><pre>        :passwd_format=blf:\</pre></div></div><div class=paragraph><p>Em seguida, execute <code>cap_mkdb /etc/login.conf</code> conforme descrito em <a href=#users-limiting>Configurando Classes de Login</a>. Observe que essa alteração não afetará os hashes de senha existentes. Isso significa que todas as senhas devem ser refeitas pedindo aos usuários que executem <code>passwd</code> para alterar sua senha.</p></div><div class=paragraph><p>Para logins remotos, a autenticação de dois fatores deve ser usada. Um exemplo de autenticação de dois fatores é "algo que você tem", como uma chave, e "algo que você conhece", como a senha para essa chave. Como o OpenSSH é parte do sistema básico do FreeBSD, todos os logins de rede devem ser sobre uma conexão criptografada e usar autenticação baseada em chave em vez de senhas. Para mais informações, consulte <a href=#openssh>OpenSSH</a>. Os usuários do Kerberos podem precisar fazer alterações adicionais para implementar o OpenSSH em sua rede. Essas alterações são descritas em <a href=#kerberos5>Kerberos</a>.</p></div></div><div class=sect3><h4 id=security-pwpolicy>13.2.4. Aplicação de Política de Senha<a class=anchor href=#security-pwpolicy></a></h4><div class=paragraph><p>Aplicar uma política de senha forte para contas locais é um aspecto fundamental da segurança do sistema. No FreeBSD, o tamanho da senha, a força da senha e a complexidade da senha podem ser implementados usando os Módulos de Autenticação Conectáveis (PAM).</p></div><div class=paragraph><p>Esta seção demonstra como configurar o tamanho mínimo e máximo da senha e a imposição de caracteres mistos usando o módulo <span class=filename>pam_passwdqc.so</span>. Este módulo é aplicado quando um usuário altera sua senha.</p></div><div class=paragraph><p>Para configurar este módulo, torne-se o superusuário e remova o comentário da linha contendo <code>pam_passwdqc.so</code> em <span class=filename>/etc/pam.d/passwd</span>. Em seguida, edite essa linha para corresponder à política de senha:</p></div><div class="literalblock programlisting"><div class=content><pre>password        requisite       pam_passwdqc.so         min=disabled,disabled,disabled,12,10 similar=deny retry=3 enforce=users</pre></div></div><div class=paragraph><p>Este exemplo define vários requisitos para novas senhas. A configuração <code>min</code> controla o tamanho mínimo da senha. Ele tem cinco valores porque este módulo define cinco tipos diferentes de senhas com base em sua complexidade. Complexidade é definida pelo tipo de caracteres que devem existir em uma senha, como letras, números, símbolos e maiúsculas e minúsculas. Os tipos de senhas são descritos em <a href="https://man.freebsd.org/cgi/man.cgi?query=pam_passwdqc&amp;sektion=8&amp;format=html">pam_passwdqc(8)</a>. Neste exemplo, os três primeiros tipos de senha são desativados, o que significa que as senhas que atendem a esses requisitos de complexidade não serão aceitas, independentemente da sua duração. O <code>12</code> define uma política de senha mínima de pelo menos doze caracteres, se a senha também contiver caracteres com três tipos de complexidade. O <code>10</code> define a política de senha para também permitir senhas de pelo menos dez caracteres, se a senha contiver caracteres com quatro tipos de complexidade.</p></div><div class=paragraph><p>A configuração <code>similar</code> nega senhas semelhantes à senha anterior do usuário. A configuração <code>retry</code> fornece ao usuário três oportunidades para inserir uma nova senha.</p></div><div class=paragraph><p>Depois que este arquivo for salvo, um usuário que alterar sua senha verá uma mensagem semelhante a seguinte:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% passwd
Changing <span class=nb>local </span>password <span class=k>for </span>trhodes
Old Password:

You can now choose the new password.
A valid password should be a mix of upper and lower <span class=k>case</span> letters,
digits and other characters.  You can use a 12 character long
password with characters from at least 3 of these 4 classes, or
a 10 character long password containing characters from all the
classes.  Characters that form a common pattern are discarded by
the check.
Alternatively, <span class=k>if </span>no one <span class=k>else </span>can see your terminal now, you can
pick this as your password: <span class=s2>&#34;trait-useful&amp;knob&#34;</span><span class=nb>.</span>
Enter new password:</code></pre></div></div><div class=paragraph><p>Se uma senha que não corresponde à política for inserida, ela será rejeitada com um aviso e o usuário terá a oportunidade de tentar novamente, até o número configurado de novas tentativas.</p></div><div class=paragraph><p>A maioria das políticas de senha exige que as senhas expirem depois de tantos dias. Para definir um tempo de expiração da senha no FreeBSD, defina <code>passwordtime</code> para a classe de login do usuário em <span class=filename>/etc/login.conf</span>. A classe de login <code>default</code> contém um exemplo:</p></div><div class="literalblock programlisting"><div class=content><pre>#       :passwordtime=90d:\</pre></div></div><div class=paragraph><p>Portanto, para definir uma expiração de 90 dias para esta classe de login, remova o símbolo de comentário (<code>#</code>), salve a edição e execute o <code>cap_mkdb /etc/login.conf</code>.</p></div><div class=paragraph><p>Para definir a expiração em usuários individuais, passe uma data de expiração ou o número de dias para expirar e um nome de usuário para o comando <code>pw</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pw usermod -p 30-apr-2015 -n trhodes</span></code></pre></div></div><div class=paragraph><p>Como visto aqui, uma data de expiração é definida na forma de dia, mês e ano. Para obter maiores informações, consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=pw&amp;sektion=8&amp;format=html">pw(8)</a>.</p></div></div><div class=sect3><h4 id=security-rkhunter>13.2.5. Detectando Rootkits<a class=anchor href=#security-rkhunter></a></h4><div class=paragraph><p>Um <em>rootkit</em> é qualquer software não autorizado que tente obter acesso como <code>root</code> a um sistema. Uma vez instalado, esse software mal-intencionado normalmente abrirá outro caminho de entrada para um invasor. Realisticamente, uma vez que um sistema foi comprometido por um rootkit e uma investigação foi realizada, o sistema deve ser reinstalado do zero. Existe um tremendo risco de que mesmo o engenheiro de sistemas ou segurança mais prudente perca algo que um invasor deixou para trás.</p></div><div class=paragraph><p>Um rootkit faz uma coisa útil para administradores: uma vez detectado, é um sinal de que um comprometimento aconteceu em algum momento. Mas, esses tipos de aplicativos tendem a ser muito bem ocultos. Esta seção demonstra uma ferramenta que pode ser usada para detectar rootkits, <a class=package href=https://cgit.freebsd.org/ports/tree/security/rkhunter/>security/rkhunter</a>.</p></div><div class=paragraph><p>Após a instalação deste pacote ou port, o sistema pode ser verificado usando o seguinte comando. Ele produzirá muitas informações e exigirá uma entrada manual da tecla <kbd>ENTER</kbd>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># rkhunter -c</span></code></pre></div></div><div class=paragraph><p>Depois que o processo for concluído, uma mensagem de status será impressa na tela. Esta mensagem incluirá a quantidade de arquivos verificados, arquivos suspeitos, possíveis rootkits e mais. Durante a verificação, alguns avisos de segurança genéricos podem ser produzidos sobre arquivos ocultos, a seleção do protocolo OpenSSH e versões vulneráveis conhecidas do software instalado. Estes podem ser tratados agora ou após uma análise mais detalhada ter sido realizada.</p></div><div class=paragraph><p>Todo administrador deve saber o que está sendo executado nos sistemas pelos quais é responsável. Ferramentas de terceiros como o rkhunter e o <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/lsof/>sysutils/lsof</a> e comandos nativos como o <code>netstat</code> e o <code>ps</code>, podem mostrar uma grande quantidade de informações sobre o sistema. Faça anotações sobre o que é normal, faça perguntas quando algo parecer fora do lugar e seja paranoico. Embora evitar um comprometimento seja ideal, detectar um comprometimento é imprescindível.</p></div></div><div class=sect3><h4 id=security-ids>13.2.6. Verificação Binária<a class=anchor href=#security-ids></a></h4><div class=paragraph><p>A verificação de arquivos e binários do sistema é importante porque fornece às equipes de administração e segurança do sistema informações sobre alterações no sistema. Uma aplicação de software que monitora o sistema para alterações é chamado de Sistema de Detecção de Intrusão (IDS).</p></div><div class=paragraph><p>O FreeBSD fornece suporte nativo para um sistema de IDS básico. Embora os emails de segurança noturnos notifiquem o administrador sobre alterações, as informações são armazenadas localmente e há uma chance de que um usuário mal-intencionado modifique essas informações para ocultar suas alterações no sistema. Como tal, recomenda-se criar um conjunto separado de assinaturas binárias e armazená-las em um diretório de read-only, propriedade do root ou, de preferência, em um disco USB removível ou servidor rsync remoto.</p></div><div class=paragraph><p>O utilitário <code>mtree</code> embutido pode ser usado para gerar uma especificação do conteúdo de um diretório. Um seed, ou uma constante numérica, é usada para gerar a especificação e é necessária para verificar se a especificação não foi alterada. Isso possibilita determinar se um arquivo ou binário foi modificado. Como o valor inicial do seed é desconhecido por um invasor, disfarçar ou impossibilitar a verificação dos valores de checksum dos arquivos será difícil ou impossível. O exemplo a seguir gera um conjunto de hashes SHA256, um para cada sistema binário no diretório <span class=filename>/bin</span> e salva esses valores em um arquivo oculto no diretório inicial do <code>root</code>, <span class=filename>/root/.bin_chksum_mtree</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mtree -s 3483151339707503 -c -K cksum,sha256digest -p /bin &gt; /root/.bin_chksum_mtree</span>
<span class=c># mtree: /bin checksum: 3427012225</span></code></pre></div></div><div class=paragraph><p>O <em>3483151339707503</em> representa o seed. Este valor deve ser lembrado, mas não compartilhado.</p></div><div class=paragraph><p>Visualizar o arquivo <span class=filename>/root/.bin_cksum_mtree</span> deve produzir uma saída semelhante à seguinte:</p></div><div class="literalblock programlisting"><div class=content><pre>#          user: root
#       machine: dreadnaught
#          tree: /bin
#          date: Mon Feb  3 10:19:53 2014

# .
/set type=file uid=0 gid=0 mode=0555 nlink=1 flags=none
.               type=dir mode=0755 nlink=2 size=1024 \
                time=1380277977.000000000
    \133        nlink=2 size=11704 time=1380277977.000000000 \
                cksum=484492447 \
                sha256digest=6207490fbdb5ed1904441fbfa941279055c3e24d3a4049aeb45094596400662a
    cat         size=12096 time=1380277975.000000000 cksum=3909216944 \
                sha256digest=65ea347b9418760b247ab10244f47a7ca2a569c9836d77f074e7a306900c1e69
    chflags     size=8168 time=1380277975.000000000 cksum=3949425175 \
                sha256digest=c99eb6fc1c92cac335c08be004a0a5b4c24a0c0ef3712017b12c89a978b2dac3
    chio        size=18520 time=1380277975.000000000 cksum=2208263309 \
                sha256digest=ddf7c8cb92a58750a675328345560d8cc7fe14fb3ccd3690c34954cbe69fc964
    chmod       size=8640 time=1380277975.000000000 cksum=2214429708 \
                sha256digest=a435972263bf814ad8df082c0752aa2a7bdd8b74ff01431ccbd52ed1e490bbe7</pre></div></div><div class=paragraph><p>O nome do host da máquina, a data e a hora em que a especificação foi criada e o nome do usuário que criou a especificação são incluídos neste relatório. Há um checksum, tamanho, hora e um digest SHA256 para cada binário no diretório.</p></div><div class=paragraph><p>Para verificar se as assinaturas binárias não foram alteradas, compare o conteúdo atual do diretório com a especificação gerada anteriormente e salve os resultados em um arquivo. Este comando requer o seed que foi usado para gerar a especificação original:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mtree -s 3483151339707503 -p /bin &lt; /root/.bin_chksum_mtree &gt;&gt; /root/.bin_chksum_output</span>
<span class=c># mtree: /bin checksum: 3427012225</span></code></pre></div></div><div class=paragraph><p>Isso deve produzir o mesmo checksum para <span class=filename>/bin</span> que foi produzido quando a especificação foi criada. Se nenhuma alteração tiver ocorrido nos binários nesse diretório, o arquivo de saída <span class=filename>/root/.bin_chksum_output</span> estará vazio. Para simular uma alteração, altere a data no arquivo <span class=filename>/bin/cat</span> usando o <code>touch</code> e execute o comando de verificação novamente:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># touch /bin/cat</span>
<span class=c># mtree -s 3483151339707503 -p /bin &lt; /root/.bin_chksum_mtree &gt;&gt; /root/.bin_chksum_output</span>
<span class=c># more /root/.bin_chksum_output</span>
<span class=nb>cat </span>changed
	modification <span class=nb>time </span>expected Fri Sep 27 06:32:55 2013 found Mon Feb  3 10:28:43 2014</code></pre></div></div><div class=paragraph><p>Recomenda-se criar especificações para os diretórios que contêm binários e arquivos de configuração, bem como quaisquer diretórios que contenham dados sensíveis. Normalmente, as especificações são criadas para <span class=filename>/bin</span>, <span class=filename>/sbin</span>, <span class=filename>/usr/bin</span>, <span class=filename>/usr/sbin</span>, <span class=filename>/usr/local/bin</span>, <span class=filename>/etc</span> e <span class=filename>/usr/local/etc</span>.</p></div><div class=paragraph><p>Existem sistemas de IDS mais avançados, como o <a class=package href=https://cgit.freebsd.org/ports/tree/security/aide/>security/aide</a>. Na maioria dos casos, o <code>mtree</code> fornece a funcionalidade que os administradores precisam. É importante manter o valor inicial e a saída do checksum oculta de usuários mal-intencionados. Maiores informações sobre o <code>mtree</code> podem ser encontradas em <a href="https://man.freebsd.org/cgi/man.cgi?query=mtree&amp;sektion=8&amp;format=html">mtree(8)</a>.</p></div></div><div class=sect3><h4 id=security-tuning>13.2.7. Otimizando o Sistema para Segurança<a class=anchor href=#security-tuning></a></h4><div class=paragraph><p>No FreeBSD, muitos recursos do sistema podem ser ajustados usando o <code>sysctl</code>. Alguns dos recursos de segurança que podem ser ajustados para impedir ataques de negação de serviço (DoS) serão abordados nesta seção. Mais informações sobre o uso do <code>sysctl</code>, incluindo como alterar temporariamente os valores e como tornar as alterações permanentes após o teste, podem ser encontradas em <a href=./#configtuning-sysctl>Efetuando ajustes com o sysctl(8)</a>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Sempre que uma configuração é alterada com o <code>sysctl</code>, a chance de causar danos indesejados é aumentada, afetando a disponibilidade do sistema. Todas as alterações devem ser monitoradas e, se possível, testadas em um sistema de teste antes de serem usadas em um sistema de produção.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Por padrão, o kernel do FreeBSD é inicializado com um nível de segurança <code>-1</code>. Isso é chamado de "modo inseguro" porque as flags de arquivos imutáveis podem ser desativadas e todos os dispositivos podem ser lidos ou gravados. O nível de segurança permanecerá em <code>-1</code>, a menos que seja alterado através do <code>sysctl</code> ou por uma configuração nos scripts de inicialização. O nível de segurança pode ser aumentado durante a inicialização do sistema, definindo <code>kern_securelevel_enable</code> para <code>YES</code> no arquivo <span class=filename>/etc/rc.conf</span>, e o valor de <code>kern_securelevel</code> para o nível de segurança desejado. Veja <a href="https://man.freebsd.org/cgi/man.cgi?query=security&amp;sektion=7&amp;format=html">security(7)</a> e <a href="https://man.freebsd.org/cgi/man.cgi?query=init&amp;sektion=8&amp;format=html">init(8)</a> para maiores informações sobre essas configurações e os níveis de segurança disponíveis.</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Aumentar o valor da variável <code>securelevel</code> pode quebrar o Xorg e causar outros problemas. Esteja preparado para fazer alguma depuração.</p></div></td></tr></tbody></table></div><div class=paragraph><p>As configurações da variável <code>net.inet.tcp.blackhole</code> e <code>net.inet.udp.blackhole</code> podem ser usadas para descartar pacotes SYN de entrada em portas fechadas sem enviar uma resposta RST. O comportamento padrão é retornar um RST para mostrar que uma porta está fechada. A alteração do padrão fornece algum nível de proteção contra varreduras de portas, que são usadas para determinar quais aplicativos estão sendo executados em um sistema. Defina <code>net.inet.tcp.blackhole</code> para <code>2</code> e <code>net.inet.udp.blackhole</code> para <code>1</code>. Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=blackhole&amp;sektion=4&amp;format=html">blackhole(4)</a> para obter maiores informações sobre essas configurações.</p></div><div class=paragraph><p>As configurações das variáveis <code>net.inet.icmp.drop_redirect</code> e <code>net.inet.ip.redirect</code> ajudam a evitar <em>ataques de redirecionamento</em>. Um ataque de redirecionamento é um tipo de DoS que envia um grande número de pacotes ICMP tipo 5. Como esses pacotes não são necessários, configure <code>net.inet.icmp.drop_redirect</code> para <code>1</code> e configure <code>net.inet.ip.redirect</code> para <code>0</code>.</p></div><div class=paragraph><p>O roteamento de origem é um método para detectar e acessar endereços não roteáveis na rede interna. Isso deve ser desativado, pois endereços não roteáveis normalmente não são roteáveis de propósito. Para desativar este recurso, defina <code>net.inet.ip.sourceroute</code> e <code>net.inet.ip.accept_sourceroute</code> como <code>0</code>.</p></div><div class=paragraph><p>Quando uma máquina na rede precisa enviar mensagens para todos os hosts em uma sub-rede, uma mensagem de solicitação echo do ICMP é enviada para o endereço de broadcast. No entanto, não há motivo para um host externo executar essa ação. Para rejeitar todas as solicitações externas de transmissão, defina <code>net.inet.icmp.bmcastecho</code> como <code>0</code>.</p></div><div class=paragraph><p>Algumas configurações adicionais estão documentadas em <a href="https://man.freebsd.org/cgi/man.cgi?query=security&amp;sektion=7&amp;format=html">security(7)</a>.</p></div></div></div><div class=sect2><h3 id=one-time-passwords>13.3. Senhas de Uso Unico<a class=anchor href=#one-time-passwords></a></h3><div class=paragraph><p>Por padrão, o FreeBSD inclui suporte para senhas de uso único em tudo (OPIE). O OPIE é projetado para evitar ataques repetidos, nos quais um atacante descobre a senha de um usuário e a usa para acessar um sistema. Como uma senha é usada apenas uma vez em OPIE, uma senha descoberta é de pouca utilidade para um invasor. O OPIE usa um hash seguro e um sistema de desafio/resposta para gerenciar senhas. A implementação do FreeBSD usa o hash MD5 por padrão.</p></div><div class=paragraph><p>O OPIE usa três tipos diferentes de senhas. A primeira é a senha usual UNIX™ ou Kerberos. A segunda é a senha única que é gerada pelo <code>opiekey</code>. O terceiro tipo de senha é a "senha secreta" que é usada para gerar senhas de uso único. A senha secreta não tem nada a fazer com ela e deve ser diferente da senha UNIX™.</p></div><div class=paragraph><p>Existem duas outras partes de dados importantes para o OPIE. Uma é o "seed" ou "chave", composta por duas letras e cinco dígitos. A outra é a "contagem de iteração", um número entre 1 e 100. O OPIE cria a senha única concatenando o seed e a senha secreta, aplicando o hash MD5 quantas vezes forem especificadas pela contagem de iterações e transformando o resultado em seis palavras inglesas curtas que representam a senha de uso único. O sistema de autenticação controla a última senha descartável usada e o usuário é autenticado se o hash da senha fornecida pelo usuário for igual à senha anterior. Como um hash unidirecional é usado, é impossível gerar futuras senhas de uso único se uma senha usada com êxito for capturada. A contagem de iteração é diminuída após cada login bem-sucedido para manter o usuário e o programa de login em sincronia. Quando a contagem de iterações descer para <code>1</code>, o OPIE deve ser reinicializado.</p></div><div class=paragraph><p>Existem alguns programas envolvidos neste processo. Uma senha de uso único, ou uma lista consecutiva de senhas de uso único, é gerada passando uma contagem de iteração, um seed e uma senha secreta para o <a href="https://man.freebsd.org/cgi/man.cgi?query=opiekey&amp;sektion=1&amp;format=html">opiekey(1)</a>. Além de inicializar o OPIE, o <a href="https://man.freebsd.org/cgi/man.cgi?query=opiepasswd&amp;sektion=1&amp;format=html">opiepasswd(1)</a> é usado para alterar senhas, contagens de iteração ou seeds. Os arquivos de credenciais relevantes em <span class=filename>/etc/opiekeys</span> são examinados pelo <a href="https://man.freebsd.org/cgi/man.cgi?query=opieinfo&amp;sektion=1&amp;format=html">opieinfo(1)</a> o qual imprime a iteração atual e o seed do usuário solicitante atual.</p></div><div class=paragraph><p>Esta seção descreve quatro tipos diferentes de operações. A primeira é como configurar senhas de uso único pela primeira vez em uma conexão segura. A segunda é como usar o <code>opiepasswd</code> em uma conexão insegura. A terceira é como efetuar login em uma conexão insegura. A quarta é como gerar um número de chaves que podem ser escritas ou impressas para uso em locais inseguros.</p></div><div class=sect3><h4 id=_inicializando_o_opie>13.3.1. Inicializando o OPIE<a class=anchor href=#_inicializando_o_opie></a></h4><div class=paragraph><p>Para inicializar o OPIE pela primeira vez, execute este comando a partir de um local seguro:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% opiepasswd <span class=nt>-c</span>
Adding unfurl:
Only use this method from the console<span class=p>;</span> NEVER from remote. If you are using
telnet, xterm, or a dial-in, <span class=nb>type</span> ^C now or <span class=nb>exit </span>with no password.
Then run opiepasswd without the <span class=nt>-c</span> parameter.
Using MD5 to compute responses.
Enter new secret pass phrase:
Again new secret pass phrase:

ID unfurl OTP key is 499 to4268
MOS MALL GOAT ARM AVID COED</code></pre></div></div><div class=paragraph><p>A opção <code>-c</code> define o modo de console que assume que o comando está sendo executado de um local seguro, como um computador sob o controle do usuário ou uma sessão SSH para um computador sob o controle do usuário.</p></div><div class=paragraph><p>Quando solicitado, insira a senha secreta que será usada para gerar as chaves de login de uso único. Essa senha deve ser difícil de adivinhar e deve ser diferente da senha associada à conta de login do usuário. Deve ter entre 10 e 127 caracteres. Lembre-se desta senha.</p></div><div class=paragraph><p>A linha <code>ID</code> lista o nome de login (<code>unfurl</code>), a contagem de iterações padrão (<code>499</code>) e o seed padrão (<code>to4268</code>). Ao efetuar o login, o sistema lembrará esses parâmetros e os exibirá, o que significa que eles não precisam ser memorizados. A última linha lista a senha única gerada que corresponde a esses parâmetros e a senha secreta. No próximo login, use essa senha única.</p></div></div><div class=sect3><h4 id=_inicialização_de_uma_conexão_insegura>13.3.2. Inicialização de uma Conexão Insegura<a class=anchor href=#_inicialização_de_uma_conexão_insegura></a></h4><div class=paragraph><p>Para inicializar ou alterar a senha secreta em um sistema inseguro, é necessária uma conexão segura em algum lugar onde o <code>opiekey</code> possa ser executado. Isso pode ser um prompt de shell em uma máquina confiável. Uma contagem de iteração é necessária, em que 100 é provavelmente um bom valor, e o seed pode ser especificado ou a gerado aleatoriamente. Na conexão insegura, a máquina sendo inicializada, use <a href="https://man.freebsd.org/cgi/man.cgi?query=opiepasswd&amp;sektion=1&amp;format=html">opiepasswd(1)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% opiepasswd

Updating unfurl:
You need the response from an OTP generator.
Old secret pass phrase:
	otp-md5 498 to4268 ext
	Response: GAME GAG WELT OUT DOWN CHAT
New secret pass phrase:
	otp-md5 499 to4269
	Response: LINE PAP MILK NELL BUOY TROY

ID mark OTP key is 499 gr4269
LINE PAP MILK NELL BUOY TROY</code></pre></div></div><div class=paragraph><p>Para aceitar o seed padrão, pressione <kbd>Return</kbd>. Antes de inserir uma senha de acesso, passe para a conexão segura e forneça os mesmos parâmetros:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% opiekey 498 to4268
Using the MD5 algorithm to compute response.
Reminder: Do not use opiekey from telnet or dial-in sessions.
Enter secret pass phrase:
GAME GAG WELT OUT DOWN CHAT</code></pre></div></div><div class=paragraph><p>Volte para a conexão insegura e copie a senha única gerada para o programa relevante.</p></div></div><div class=sect3><h4 id=_gerando_uma_senha_de_uso_único>13.3.3. Gerando uma Senha de Uso Único<a class=anchor href=#_gerando_uma_senha_de_uso_único></a></h4><div class=paragraph><p>Depois de inicializar o OPIE e efetuar login, um prompt como este será exibido:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% telnet example.com
Trying 10.0.0.1...
Connected to example.com
Escape character is <span class=s1>&#39;^]&#39;</span><span class=nb>.</span>

FreeBSD/i386 <span class=o>(</span>example.com<span class=o>)</span> <span class=o>(</span>ttypa<span class=o>)</span>

login: &lt;username&gt;
otp-md5 498 gr4269 ext
Password:</code></pre></div></div><div class=paragraph><p>Os prompts do OPIE fornecem um recurso útil. Se o <kbd>Enter</kbd> for pressionado no prompt de senha, o prompt ativará o echo e exibirá o que foi digitado. Isso pode ser útil ao tentar digitar uma senha manualmente a partir de uma impressão.</p></div><div class=paragraph><p>Neste ponto, gere a senha de uso único para responder a este aviso de login. Isso deve ser feito em um sistema confiável em que seja seguro executar o <a href="https://man.freebsd.org/cgi/man.cgi?query=opiekey&amp;sektion=1&amp;format=html">opiekey(1)</a>. Existem versões deste comando para Windows™, Mac OS™ e FreeBSD. Esse comando precisa da contagem de iteração e do seed como opções da linha de comandos. Use recortar e colar no prompt de login da máquina que está sendo conectada.</p></div><div class=paragraph><p>No sistema confiável:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% opiekey 498 to4268
Using the MD5 algorithm to compute response.
Reminder: Do not use opiekey from telnet or dial-in sessions.
Enter secret pass phrase:
GAME GAG WELT OUT DOWN CHAT</code></pre></div></div><div class=paragraph><p>Depois que a senha descartável for gerada, continue a logar.</p></div></div><div class=sect3><h4 id=_gerando_múltiplas_senhas_de_uso_único>13.3.4. Gerando Múltiplas Senhas de Uso Único<a class=anchor href=#_gerando_múltiplas_senhas_de_uso_único></a></h4><div class=paragraph><p>Às vezes, não há acesso a uma máquina confiável ou conexão segura. Neste caso, é possível usar o <a href="https://man.freebsd.org/cgi/man.cgi?query=opiekey&amp;sektion=1&amp;format=html">opiekey(1)</a> para gerar algumas de senhas de uso único antecipadamente. Por exemplo:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% opiekey <span class=nt>-n</span> 5 30 zz99999
Using the MD5 algorithm to compute response.
Reminder: Do not use opiekey from telnet or dial-in sessions.
Enter secret pass phrase: &lt;secret password&gt;
26: JOAN BORE FOSS DES NAY QUIT
27: LATE BIAS SLAY FOLK MUCH TRIG
28: SALT TIN ANTI LOON NEAL USE
29: RIO ODIN GO BYE FURY TIC
30: GREW JIVE SAN GIRD BOIL PHI</code></pre></div></div><div class=paragraph><p>A opção <code>-n 5</code> solicita cinco chaves em seqüência e <code>30</code> especifica qual deve ser o último número de iteração. Note que estes são impressos na ordem <em>reversa</em> de uso. O usuário realmente paranóico pode querer escrever os resultados manualmente; caso contrário, imprima a lista. Cada linha mostra a contagem de iteração e a senha de uso único. Risque as senhas conforme elas forem usadas.</p></div></div><div class=sect3><h4 id=_restringindo_o_uso_de_senhas_unix>13.3.5. Restringindo o Uso de Senhas UNIX™<a class=anchor href=#_restringindo_o_uso_de_senhas_unix></a></h4><div class=paragraph><p>O OPIE pode restringir o uso de senhas UNIX™ com base no endereço IP de uma sessão de login. O arquivo relevante é o <span class=filename>/etc/opieaccess</span>, que está presente por padrão. Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=opieaccess&amp;sektion=5&amp;format=html">opieaccess(5)</a> para obter maiores informações sobre esse arquivo e sobre quais considerações de segurança você deve estar ciente ao usá-lo.</p></div><div class=paragraph><p>Aqui está um exemplo do arquivo <span class=filename>opieaccess</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>permit 192.168.0.0 255.255.0.0</pre></div></div><div class=paragraph><p>Esta linha permite que os usuários cujo endereço de origem IP (que é vulnerável a spoofing) corresponda ao valor e à máscara especificados, para usar as senhas UNIX™ a qualquer momento.</p></div><div class=paragraph><p>Se nenhuma regra do arquivo <span class=filename>opieaccess</span> for correspondida, o padrão é negar logins que não sejam OPIE.</p></div></div></div><div class=sect2><h3 id=tcpwrappers>13.4. TCP Wrapper<a class=anchor href=#tcpwrappers></a></h3><div class=paragraph><p>O TCP Wrapper é um sistema de controle de acesso baseado em host que estende as habilidades do <a href=./#network-inetd>O super-servidor inetd</a>. Ele pode ser configurado para fornecer suporte de registro, mensagens de retorno e restrições de conexão para os daemons do servidor sob o controle do inetd. Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=tcpd&amp;sektion=8&amp;format=html">tcpd(8)</a> para obter maiores informações sobre o TCP Wrapper e seus recursos.</p></div><div class=paragraph><p>O TCP Wrapper não deve ser considerado um substituto para um firewall configurado adequadamente. Em vez disso, TCP Wrapper deve ser usado em conjunto com um firewall e outros aprimoramentos de segurança para fornecer outra camada de proteção na implementação de uma política de segurança.</p></div><div class=sect3><h4 id=_configuração_inicial>13.4.1. Configuração Inicial<a class=anchor href=#_configuração_inicial></a></h4><div class=paragraph><p>Para ativar o TCP Wrapper no FreeBSD, adicione as seguintes linhas ao arquivo <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>inetd_enable=&#34;YES&#34;
inetd_flags=&#34;-Ww&#34;</pre></div></div><div class=paragraph><p>Então, configure corretamente o arquivo <span class=filename>/etc/hosts.allow</span>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Ao contrário de outras implementações do TCP Wrapper, o uso do arquivo <span class=filename>hosts.deny</span> foi preterido no FreeBSD. Todas as opções de configuração devem ser colocadas no arquivo <span class=filename>/etc/hosts.allow</span>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Na configuração mais simples, as políticas de conexão do daemon são configuradas para permitir ou bloquear, dependendo das opções no arquivo <span class=filename>/etc/hosts.allow</span>. A configuração padrão no FreeBSD é permitir todas as conexões para os daemons iniciados com o inetd.</p></div><div class=paragraph><p>A configuração básica geralmente assume a forma de <code>daemon : address : action</code>, onde <code>daemon</code> é o daemon que o inetd iniciou, <code>address</code> é um nome de host válido ou um endereço IP ou um endereço IPv6 entre colchetes ([]) e <code>action</code> é <code>allow</code> ou <code>deny</code>. O TCP Wrapper usa uma semântica de correspondência de primeira regra, o que significa que o arquivo de configuração é varrido desde o início para uma regra correspondente. Quando uma correspondência é encontrada, a regra é aplicada e o processo de pesquisa é interrompido.</p></div><div class=paragraph><p>Por exemplo, para permitir conexões POP3 através do daemon <a class=package href=https://cgit.freebsd.org/ports/tree/mail/qpopper/>mail/qpopper</a>, as seguintes linhas devem ser anexadas ao arquivo <span class=filename>hosts.allow</span>:</p></div><div class="literalblock programlisting"><div class=content><pre># This line is required for POP3 connections:
qpopper : ALL : allow</pre></div></div><div class=paragraph><p>Sempre que este arquivo for editado, reinicie o inetd:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service inetd restart</span></code></pre></div></div></div><div class=sect3><h4 id=_configuração_avançada>13.4.2. Configuração Avançada<a class=anchor href=#_configuração_avançada></a></h4><div class=paragraph><p>O TCP Wrapper fornece opções avançadas para permitir mais controle sobre o modo como as conexões são tratadas. Em alguns casos, pode ser apropriado retornar um comentário para determinados hosts ou conexões de daemon. Em outros casos, uma entrada de log deve ser registrada ou um email enviado ao administrador. Outras situações podem exigir o uso de um serviço apenas para conexões locais. Isso tudo é possível através do uso de opções de configuração conhecidas como wildcards, caracteres de expansão e execução de comandos externos.</p></div><div class=paragraph><p>Suponha que uma situação ocorra onde uma conexão deva ser negada, mas uma razão deve ser enviada ao host que tentou estabelecer essa conexão. Essa ação é possível com a opção <code>twist</code>. Quando uma tentativa de conexão é feita, o <code>twist</code> executa um comando ou script shell. Existe um exemplo no arquivo <span class=filename>hosts.allow</span>:</p></div><div class="literalblock programlisting"><div class=content><pre># The rest of the daemons are protected.
ALL : ALL \
	: severity auth.info \
	: twist /bin/echo &#34;You are not welcome to use %d from %h.&#34;</pre></div></div><div class=paragraph><p>Neste exemplo, a mensagem "You are not allowed to use <em>daemon name</em> from <em>hostname</em>." será retornada para qualquer daemon não configurado no <span class=filename>hosts.allow</span>. Isso é útil para enviar uma resposta de volta ao inicializador de conexão logo após a conexão estabelecida ser descartada. Qualquer mensagem a ser retornada <em>deve</em> ser delimitada por caracteres de aspas duplas (<code>"</code>).</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Pode ser possível iniciar um ataque de negação de serviço no servidor se um invasor inunda esses daemons com solicitações de conexão.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Outra possibilidade é usar a opção <code>spawn</code>. Como a opção <code>twist</code>, a opção <code>spawn</code> implicitamente nega a conexão e pode ser usado para executar comandos ou scripts externos do shell. Ao contrário da <code>twist</code>, a <code>spawn</code> não enviará uma resposta ao host que estabeleceu a conexão. Por exemplo, considere a seguinte configuração:</p></div><div class="literalblock programlisting"><div class=content><pre># We do not allow connections from example.com:
ALL : .example.com \
	: spawn (/bin/echo %a from %h attempted to access %d &gt;&gt; \
	  /var/log/connections.log) \
	: deny</pre></div></div><div class=paragraph><p>Isso negará todas as tentativas de conexão de <code>*.example.com</code> e registrará o nome do host, endereço IP e o daemon ao qual o acesso foi tentado no arquivo <span class=filename>/var/log/connections.log</span>. Este exemplo usa os caracteres de substituição <code>%a</code> e <code>%h</code>. Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=hosts_access&amp;sektion=5&amp;format=html">hosts_access(5)</a> para a lista completa.</p></div><div class=paragraph><p>Para corresponder a cada instância de um daemon, domínio ou endereço IP, use <code>ALL</code>. Outro wildcard é o <code>PARANOID</code>, que pode ser usado para corresponder a qualquer host que forneça um endereço IP que possa ser forjado, porque o endereço IP difere do nome resolvido para o host. Neste exemplo, todas as solicitações de conexão para o Sendmail que possuem um endereço IP que varia de seu nome de host serão negadas:</p></div><div class="literalblock programlisting"><div class=content><pre># Block possibly spoofed requests to sendmail:
sendmail : PARANOID : deny</pre></div></div><div class="admonitionblock caution"><table><tbody><tr><td class=icon><i class="fa icon-caution" title=Caution></i></td><td class=content><div class=paragraph><p>Usar o wildcard <code>PARANOID</code> resultará em conexões negadas se o cliente ou servidor tiver uma configuração de DNS incorreta.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Para saber mais sobre wildcards e sua funcionalidade associada, consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=hosts_access&amp;sektion=5&amp;format=html">hosts_access(5)</a>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Ao adicionar novas linhas de configuração, certifique-se de que quaisquer entradas desnecessárias para esse daemon sejam comentadas no arquivo <span class=filename>hosts.allow</span>.</p></div></td></tr></tbody></table></div></div></div><div class=sect2><h3 id=kerberos5>13.5. Kerberos<a class=anchor href=#kerberos5></a></h3><div class=paragraph><p>O Kerberos é um protocolo de autenticação de rede que foi originalmente criado pelo Instituto de Tecnologia de Massachusetts (MIT) como uma maneira segura de fornecer autenticação em uma rede potencialmente hostil. O protocolo Kerberos usa criptografia robusta para que tanto um cliente quanto um servidor possam provar sua identidade sem enviar nenhum segredo não criptografado pela rede. O Kerberos pode ser descrito como um sistema proxy de verificação de identidade e como um sistema confiável de autenticação de terceiros. Depois que um usuário autentica com Kerberos, suas comunicações podem ser criptografadas para garantir privacidade e integridade dos dados.</p></div><div class=paragraph><p>A única função do Kerberos é fornecer a autenticação segura de usuários e servidores na rede. Ele não fornece funções de autorização ou auditoria. Recomenda-se que o Kerberos seja usado com outros métodos de segurança que forneçam serviços de autorização e auditoria.</p></div><div class=paragraph><p>A versão atual do protocolo é a versão 5, descrita na RFC 4120. Várias implementações gratuitas deste protocolo estão disponíveis, abrangendo uma ampla gama de sistemas operacionais. O MIT continua desenvolvendo o pacote Kerberos. É comumente usado no US como um produto de criptografia e, historicamente, está sujeito aos regulamentos de exportação dos US. No FreeBSD, o MITKerberos está disponível como o pacote ou port <a class=package href=https://cgit.freebsd.org/ports/tree/security/krb5/>security/krb5</a>. A implementação do Kerberos do Heimdal foi explicitamente desenvolvida fora do US para evitar regulamentações de exportação. A distribuição Kerberos do Heimdal está incluída na instalação base do FreeBSD, e outra distribuição com opções mais configuráveis está disponível como <a class=package href=https://cgit.freebsd.org/ports/tree/security/heimdal/>security/heimdal</a> na Coleção de Ports.</p></div><div class=paragraph><p>No Kerberos, os usuários e serviços são identificados como "principals", que estão contidos em um agrupamento administrativo chamado de "realm". Um usuário principal típico teria o formato <code><em>user</em>@<em>REALM</em></code> (os realms são tradicionalmente em caracteres maiúsculos).</p></div><div class=paragraph><p>Esta seção fornece um guia sobre como configurar o Kerberos usando a distribuição Heimdal incluída no FreeBSD.</p></div><div class=paragraph><p>Para fins de demonstração de uma instalação do Kerberos , os namespaces serão os seguintes:</p></div><div class=ulist><ul><li><p>O domínio (zona) de domínio DNS será <code>example.org</code>.</p></li><li><p>O realm Kerberos será <code>EXAMPLE.ORG</code>.</p></li></ul></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Use nomes de domínio reais ao configurar o Kerberos, mesmo que ele seja executado internamente. Isso evita problemas de DNS e garante a interoperabilidade com outros realms do Kerberos.</p></div></td></tr></tbody></table></div><div class=sect3><h4 id=_configurando_um_kdc_do_heimdal>13.5.1. Configurando um KDC do Heimdal<a class=anchor href=#_configurando_um_kdc_do_heimdal></a></h4><div class=paragraph><p>O Centro de Distribuição de Chaves (KDC) é o serviço de autenticação centralizada que o Kerberos fornece, a "a parte de terceiros confiáveis" do sistema. É o computador que emite os tíquetes Kerberos, que são usados para autenticação dos clientes nos servidores. Como o KDC é considerado confiável por todos os outros computadores no realm do Kerberos, isso aumenta as preocupações com a segurança. O acesso direto ao KDC deve ser limitado.</p></div><div class=paragraph><p>Embora a execução de um KDC exija poucos recursos de computação, uma máquina dedicada que atua apenas como um KDC é recomendada por motivos de segurança.</p></div><div class=paragraph><p>Para começar, instale o pacote <a class=package href=https://cgit.freebsd.org/ports/tree/security/heimdal/>security/heimdal</a> assim:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install heimdal</span></code></pre></div></div><div class=paragraph><p>Em seguida, edite o <span class=filename>/etc/rc.conf</span> como a seguir:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysrc kdc_enable=yes</span>
<span class=c># sysrc kadmind_enable=yes</span></code></pre></div></div><div class=paragraph><p>Em seguida, edite o arquivo <span class=filename>/etc/krb5.conf</span> como a seguir:</p></div><div class="literalblock programlisting"><div class=content><pre>[libdefaults]
    default_realm = EXAMPLE.ORG
[realms]
    EXAMPLE.ORG = {
	kdc = kerberos.example.org
	admin_server = kerberos.example.org
    }
[domain_realm]
    .example.org = EXAMPLE.ORG</pre></div></div><div class=paragraph><p>Neste exemplo, o KDC usará o nome completo do host <code>kerberos.example.org</code>. O nome do host do KDC precisa ser resolvido no DNS.</p></div><div class=paragraph><p>O Kerberos também pode usar o DNS para localizar os KDCs, em vez de uma seção <code>[realms]</code> no arquivo <span class=filename>/etc/krb5.conf</span>. Para grandes organizações que possuem seus próprios servidores DNS, o exemplo acima pode ser reduzido para:</p></div><div class="literalblock programlisting"><div class=content><pre>[libdefaults]
      default_realm = EXAMPLE.ORG
[domain_realm]
    .example.org = EXAMPLE.ORG</pre></div></div><div class=paragraph><p>Com as seguintes linhas sendo incluídas no arquivo de zona do domínio <code>example.org</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>_kerberos._udp      IN  SRV     01 00 88 kerberos.example.org.
_kerberos._tcp      IN  SRV     01 00 88 kerberos.example.org.
_kpasswd._udp       IN  SRV     01 00 464 kerberos.example.org.
_kerberos-adm._tcp  IN  SRV     01 00 749 kerberos.example.org.
_kerberos           IN  TXT     EXAMPLE.ORG</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Para que os clientes possam encontrar os serviços Kerberos, eles <em>devem</em> ter um <span class=filename>/etc/krb5.conf</span> totalmente configurado ou um <span class=filename>/etc/krb5.conf</span> minimamente configurado <em>e</em> um servidor DNS corretamente configurado.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Em seguida, crie o banco de dados do Kerberos que contém as chaves de todos os principals (usuários e hosts) criptografados com uma senha master. Não é necessário lembrar essa senha, pois ela será armazenada no arquivo <span class=filename>/var/heimdal/m-key</span>; Seria razoável usar uma senha aleatória de 45 caracteres para essa finalidade. Para criar a chave master, execute <code>kstash</code> e digite uma senha:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kstash</span>
Master key: xxxxxxxxxxxxxxxxxxxxxxx
Verifying password - Master key: xxxxxxxxxxxxxxxxxxxxxxx</code></pre></div></div><div class=paragraph><p>Depois que a chave master é criada, o banco de dados deve ser inicializado. A ferramenta administrativa do Kerberos<a href="https://man.freebsd.org/cgi/man.cgi?query=kadmin&amp;sektion=8&amp;format=html">kadmin(8)</a> pode ser usada no KDC em um modo que opera diretamente no banco de dados, sem usar o serviço de rede <a href="https://man.freebsd.org/cgi/man.cgi?query=kadmind&amp;sektion=8&amp;format=html">kadmind(8)</a>, como <code>kadmin -l</code>. Isso resolve o problema do ovo e da galinha de tentar se conectar ao banco de dados antes de criá-lo. No prompt do <code>kadmin</code>, use o <code>init</code> para criar o banco de dados inicial do realm:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kadmin -l</span>
kadmin&gt; init EXAMPLE.ORG
Realm max ticket life <span class=o>[</span>unlimited]:</code></pre></div></div><div class=paragraph><p>Por fim, enquanto ainda estiver no <code>kadmin</code>, crie o primeiro principal usando <code>add</code>. Atenha-se às opções padrão para o principal por enquanto, pois elas podem ser alteradas posteriormente com <code>modify</code>. Digite <code>?</code> no prompt para ver as opções disponíveis.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>kadmin&gt; add tillman
Max ticket life <span class=o>[</span>unlimited]:
Max renewable life <span class=o>[</span>unlimited]:
Principal expiration <span class=nb>time</span> <span class=o>[</span>never]:
Password expiration <span class=nb>time</span> <span class=o>[</span>never]:
Attributes <span class=o>[]</span>:
Password: xxxxxxxx
Verifying password - Password: xxxxxxxx</code></pre></div></div><div class=paragraph><p>Em seguida, inicie o serviço KDC executando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service kdc start</span>
<span class=c># service kadmind start</span></code></pre></div></div><div class=paragraph><p>Embora não tenha nenhum daemon do kerberos em execução neste ponto, é possível confirmar que o KDC está funcionando obtendo um ticket para o principal que acabou de ser criado:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% kinit tillman
tillman@EXAMPLE.ORG<span class=s1>&#39;s Password:</span></code></pre></div></div><div class=paragraph><p>Confirme se um ticket foi obtido com sucesso usando <code>klist</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% klist
Credentials cache: FILE:/tmp/krb5cc_1001
	Principal: tillman@EXAMPLE.ORG

  Issued                Expires               Principal
Aug 27 15:37:58 2013  Aug 28 01:37:58 2013  krbtgt/EXAMPLE.ORG@EXAMPLE.ORG</code></pre></div></div><div class=paragraph><p>O ticket temporário pode ser destruído quando o teste terminar:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% kdestroy</code></pre></div></div></div><div class=sect3><h4 id=_configurando_um_servidor_para_usar_o_kerberos>13.5.2. Configurando um Servidor para Usar o Kerberos<a class=anchor href=#_configurando_um_servidor_para_usar_o_kerberos></a></h4><div class=paragraph><p>A primeira etapa na configuração de um servidor para usar a autenticação Kerberos é garantir que ele tenha a configuração correta no arquivo <span class=filename>/etc/krb5.conf</span>. A versão do KDC pode ser usada como está, ou pode ser regenerada no novo sistema.</p></div><div class=paragraph><p>Em seguida, crie o arquivo <span class=filename>/etc/krb5.keytab</span> no servidor. Esta é a parte principal de "Kerberizar" um serviço - ele corresponde a gerar uma chave secreta compartilhada entre o serviço e o KDC. O segredo é uma chave criptográfica, armazenada em um "keytab". O keytab contém a chave do host do servidor, que permite que ele e o KDC verifiquem a identidade um do outro. Ele deve ser transmitido para o servidor de maneira segura, pois a segurança do servidor pode ser quebrada se a chave for tornada pública. Normalmente, o <span class=filename>keytab</span> é gerado na máquina confiável de um administrador usando o <code>kadmin</code>, e então transferido com segurança para o servidor, por exemplo, com <a href="https://man.freebsd.org/cgi/man.cgi?query=scp&amp;sektion=1&amp;format=html">scp(1)</a>; Ele também pode ser criado diretamente no servidor, se isso for consistente com a política de segurança desejada. É muito importante que o keytab seja transmitido para o servidor de forma segura: se a chave for conhecida por outra parte, essa parte pode representar qualquer usuário para o servidor! Usar o <code>kadmin</code> diretamente no servidor é conveniente, porque a entrada para o principal do host no banco de dados do KDC também é criada usando o <code>kadmin</code>.</p></div><div class=paragraph><p>Naturalmente, o <code>kadmin</code> é um serviço kerberizado; um tíquete Kerberos é necessário para autenticar-se no serviço de rede, mas para garantir que o usuário que está executando o <code>kadmin</code> esteja presente (e sua sessão não tenha sido invadida), o <code>kadmin</code> solicitará a senha para obter um novo ticket. O principal autenticando no serviço kadmin deve ter permissão para usar a interface <code>kadmin</code>, conforme especificado no arquivo <span class=filename>/var/heimdal/kadmind.acl</span>. Veja a seção intitulada "Administração Remota" em <code>info heimdal</code> para detalhes sobre a criação de listas de controle de acesso. Em vez de ativar o acesso remoto ao <code>kadmin</code>, o administrador pode conectar-se com segurança ao KDC através do console local ou por <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh&amp;sektion=&amp;format=html">ssh()</a> e executar a administração localmente usando o <code>kadmin -l</code>.</p></div><div class=paragraph><p>Depois de instalar o arquivo <span class=filename>/etc/krb5.conf</span>, use o <code>add --random-key</code> no <code>kadmin</code>. Isso adiciona o principal do host do servidor ao banco de dados, mas não extrai uma cópia da chave principal do host para um keytab. Para gerar o keytab, use <code>ext</code> para extrair a chave principal do host do servidor para seu próprio keytab:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kadmin</span>
kadmin&gt; add <span class=nt>--random-key</span> host/myserver.example.org
Max ticket life <span class=o>[</span>unlimited]:
Max renewable life <span class=o>[</span>unlimited]:
Principal expiration <span class=nb>time</span> <span class=o>[</span>never]:
Password expiration <span class=nb>time</span> <span class=o>[</span>never]:
Attributes <span class=o>[]</span>:
kadmin&gt; ext_keytab host/myserver.example.org
kadmin&gt; <span class=nb>exit</span></code></pre></div></div><div class=paragraph><p>Note que o <code>ext_keytab</code> por padrão armazena a chave extraída no arquivo <span class=filename>/etc/krb5.keytab</span>. Isso é bom quando executado no servidor que está sendo kerberizado, mas o argumento <code>--keytab <em>path/to/file</em></code> deve ser usado quando o keytab estiver sendo extraído em outro lugar:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kadmin</span>
kadmin&gt; ext_keytab <span class=nt>--keytab</span><span class=o>=</span>/tmp/example.keytab host/myserver.example.org
kadmin&gt; <span class=nb>exit</span></code></pre></div></div><div class=paragraph><p>O keytab pode então ser copiado com segurança para o servidor usando o <a href="https://man.freebsd.org/cgi/man.cgi?query=scp&amp;sektion=1&amp;format=html">scp(1)</a> ou uma mídia removível. Certifique-se de especificar um nome de keytab não padrão para evitar a inserção de chaves desnecessárias na keytab do sistema.</p></div><div class=paragraph><p>Neste ponto, o servidor pode ler mensagens criptografadas do KDC usando sua chave compartilhada, armazenada no arquivo <span class=filename>krb5.keytab</span>. Agora ele está pronto para ativar os serviços de uso do Kerberos. Um dos serviços mais comuns é o <a href="https://man.freebsd.org/cgi/man.cgi?query=sshd&amp;sektion=8&amp;format=html">sshd(8)</a>, que suporta o Kerberos através do GSS-API. No arquivo <span class=filename>/etc/ssh/sshd_config</span>, adicione a linha:</p></div><div class="literalblock programlisting"><div class=content><pre>GSSAPIAuthentication yes</pre></div></div><div class=paragraph><p>Depois de fazer essa alteração, o <a href="https://man.freebsd.org/cgi/man.cgi?query=sshd&amp;sektion=8&amp;format=html">sshd(8)</a> deve ser reiniciado para que a nova configuração tenha efeito: <code>service sshd restart</code>.</p></div></div><div class=sect3><h4 id=_configurando_um_cliente_para_usar_o_kerberos>13.5.3. Configurando um cliente para usar o Kerberos<a class=anchor href=#_configurando_um_cliente_para_usar_o_kerberos></a></h4><div class=paragraph><p>Assim como foi no servidor, o cliente requer configuração no arquivo <span class=filename>/etc/krb5.conf</span>. Copie o arquivo no local (com segurança) ou insira-o novamente conforme necessário.</p></div><div class=paragraph><p>Teste o cliente usando o <code>kinit</code>, <code>klist</code> e <code>kdestroy</code> a partir do cliente para obter, mostrar e excluir um ticket para um principal existente. Os aplicativos Kerberos também devem poder se conectar a servidores habilitados pelo Kerberos. Se isso não funcionar, mas a obtenção de um ticket ocorrer, provavelmente o problema está no servidor e não no cliente ou no KDC. No caso do <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh&amp;sektion=1&amp;format=html">ssh(1)</a> kerberizado, o GSS-API está desabilitado por padrão, portanto teste usando <code>ssh -o GSSAPIAuthentication=yes <em>hostname</em></code>.</p></div><div class=paragraph><p>Ao testar um aplicativo Kerberizado, tente usar um sniffer de pacote, como o <code>tcpdump</code>, para confirmar que nenhuma informação confidencial é enviada sem proteção.</p></div><div class=paragraph><p>Várias aplicações Kerberos cliente estão disponíveis. Com o advento de uma ponte para que aplicações usando SASL para autenticação possam usar mecanismos GSS-API, grandes classes de aplicativos clientes podem usar o Kerberos para autenticação, de clientes Jabber a clientes IMAP.</p></div><div class=paragraph><p>Os usuários em um realm geralmente têm seu principal Kerberos mapeado para uma conta de usuário local. Ocasionalmente, é necessário conceder acesso a uma conta de usuário local a alguém que não tenha um principal Kerberos correspondente. Por exemplo, <code>tillman@EXAMPLE.ORG</code> pode precisar de acesso à conta de usuário local <code>webdevelopers</code>. Outros diretores também podem precisar de acesso a essa conta local.</p></div><div class=paragraph><p>Os arquivos <span class=filename>.k5login</span> e <span class=filename>.k5users</span>, colocados no diretório home de um usuário, podem ser usados para resolver este problema. Por exemplo, se o seguinte <span class=filename>.k5login</span> for colocado no diretório inicial de <code>webdevelopers</code>, os dois principals listados terão acesso a essa conta sem exigir uma senha compartilhada:</p></div><div class="literalblock programlisting"><div class=content><pre>tillman@example.org
jdoe@example.org</pre></div></div><div class=paragraph><p>Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=ksu&amp;sektion=1&amp;format=html">ksu(1)</a> para obter maiores informações sobre o <span class=filename>.k5users</span>.</p></div></div><div class=sect3><h4 id=_diferenças_com_a_implementação_do_mit>13.5.4. Diferenças com a implementação do MIT<a class=anchor href=#_diferenças_com_a_implementação_do_mit></a></h4><div class=paragraph><p>A principal diferença entre as implementações do MIT e a Heimdal é que o <code>kadmin</code> tem um conjunto de comandos diferente, mas equivalente, e usa um protocolo diferente. Se o KDC for MIT, a versão Heimdal do <code>kadmin</code> não poderá ser usada para administrar o KDC remotamente, e vice versa.</p></div><div class=paragraph><p>Aplicações cliente também podem usar opções de linha de comando ligeiramente diferentes para realizar as mesmas tarefas. Seguir as instruções em <a href=http://web.mit.edu/Kerberos/www/>http://web.mit.edu/Kerberos/www/</a> é recomendado. Cuidado com os problemas de caminho: o port MIT é instalado em <span class=filename>/usr/local/</span> por padrão, e os aplicativos do sistema FreeBSD serão executados em vez das versões do MIT se o <code>PATH</code> listar os diretórios do sistema primeiro.</p></div><div class=paragraph><p>Ao usar o MIT Kerberos como um KDC no FreeBSD, as seguintes edições também devem ser feitas no <span class=filename>rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>kdc_program=&#34;/usr/local/sbin/kdc&#34;
kadmind_program=&#34;/usr/local/sbin/kadmind&#34;
kdc_flags=&#34;&#34;
kdc_enable=&#34;YES&#34;
kadmind_enable=&#34;YES&#34;</pre></div></div></div><div class=sect3><h4 id=_dicas_truques_e_solução_de_problemas_do_kerberos>13.5.5. Dicas, Truques e Solução de Problemas do Kerberos<a class=anchor href=#_dicas_truques_e_solução_de_problemas_do_kerberos></a></h4><div class=paragraph><p>Ao configurar e solucionar problemas do Kerberos, tenha em mente os seguintes pontos:</p></div><div class=ulist><ul><li><p>Ao usar o Heimdal ou MITKerberos do ports, certifique-se de que o <code>PATH</code> liste as versões do port dos aplicativos clientes antes das versões do sistema.</p></li><li><p>Se todos os computadores no realm não tiverem configurações de horário sincronizadas, a autenticação poderá falhar. <a href=./#network-ntp>Sincronização de Relógio com NTP</a> descreve como sincronizar os relógios usando o NTP.</p></li><li><p>Se o nome do host for alterado, o <code>host/</code> principal deve ser alterado e o keytab atualizado. Isso também se aplica a entradas de keytab especiais como o <code>HTTP/</code> principal usado para o <a class=package href=https://cgit.freebsd.org/ports/tree/www/mod_auth_kerb/>www/mod_auth_kerb</a> do Apache.</p></li><li><p>Todos os hosts no realm devem ser resolvidos tanto de forma direta quanto reversa no DNS ou, no mínimo, no arquivo <span class=filename>/etc/hosts</span>. Os CNAMEs funcionarão, mas os registros A e PTR devem estar corretos e no lugar. A mensagem de erro para hosts não resolvidos não é intuitiva: <code>Kerberos5 refuses authentication because Read req failed: Key table entry not found</code>.</p></li><li><p>Alguns sistemas operacionais que agem como clientes para o KDC não definem as permissões para o <code>ksu</code> para serem setuid <code>root</code>. Isso significa que o <code>ksu</code> não funciona. Este é um problema de permissões, não um erro do KDC.</p></li><li><p>Com o MITKerberos, para permitir que um principal tenha uma duração de ticket maior que a duração padrão de dez horas, use <code>modify_principal</code> no <a href="https://man.freebsd.org/cgi/man.cgi?query=kadmin&amp;sektion=8&amp;format=html">kadmin(8)</a> para alterar o <code>maxlife</code> do principal em questão e do <code>krbtgt</code> principal. O principal pode então usar o <code>kinit -l</code> para solicitar um ticket com uma vida útil mais longa.</p></li><li><p>Ao executar um sniffer de pacotes no KDC para auxiliar na solução de problemas enquanto executa <code>kinit</code> de uma estação de trabalho, o Ticket de Concessão de Tickets (TGT) é enviado imediatamente, mesmo antes da digitação da senha. Isso ocorre porque o servidor Kerberos transmite livremente um TGT para qualquer solicitação não autorizada. No entanto, cada TGT é criptografado em uma chave derivada da senha do usuário. Quando um usuário digita sua senha, ela não é enviada para o KDC, ela é usada para descriptografar o TGT que o <code>kinit</code> já obteve. Se o processo de descriptografia resultar em um tíquete válido com um registro de data e hora válido, o usuário terá credenciais do Kerberos válidas. Essas credenciais incluem uma chave de sessão para estabelecer comunicações seguras com o servidor Kerberos no futuro, bem como o TGT, que é criptografado com a chave do próprio servidor Kerberos. Essa segunda camada de criptografia permite que o servidor Kerberos verifique a autenticidade de cada TGT.</p></li><li><p>Os principals do host podem ter uma vida útil maior do ticket. Se o usuário do principal tiver uma vida útil de uma semana, mas o host ao qual está conectado tiver uma vida útil de nove horas, o cache do usuário terá um host principal expirado e o cache do ticket não funcionará como esperado.</p></li><li><p>Ao configurar o arquivo <span class=filename>krb5.dict</span> para evitar que senhas incorretas específicas sejam usadas, conforme descrito em <a href="https://man.freebsd.org/cgi/man.cgi?query=kadmind&amp;sektion=8&amp;format=html">kadmind(8)</a>, lembre-que só se aplica a entidades que tenham uma política de senha atribuída a elas. O formato usado em <span class=filename>krb5.dict</span> é uma string por linha. Criar um link simbólico para <span class=filename>/usr/shared/dict/words</span> pode ser útil.</p></li></ul></div></div><div class=sect3><h4 id=_atenuando_as_limitações_do_kerberos>13.5.6. Atenuando as Limitações do Kerberos<a class=anchor href=#_atenuando_as_limitações_do_kerberos></a></h4><div class=paragraph><p>Uma vez que com o Kerberos a abordagem é tudo ou nada, cada serviço habilitado na rede deve ser modificado para funcionar com o Kerberos ou ser protegido contra ataques de rede. Isso impede que as credenciais do usuário sejam roubadas e reutilizadas. Um exemplo é quando o Kerberos está habilitado em todos os shells remotos, mas o servidor de email POP3 não-Kerberizado envia senhas em texto simples.</p></div><div class=paragraph><p>O KDC é um ponto único de falha. Por design, o KDC deve ser tão seguro quanto seu banco de dados de senhas master. O KDC não deve ter absolutamente nenhum outro serviço sendo executado e deve estar fisicamente seguro. O perigo é alto porque o Kerberos armazena todas as senhas criptografadas com a mesma chave mestra que é armazenada como um arquivo no KDC.</p></div><div class=paragraph><p>Uma chave mestra comprometida não é tão ruim quanto se pode temer. A chave mestra é usada apenas para criptografar o banco de dados do Kerberos e como um seed para o gerador de números aleatórios. Desde que o acesso ao KDC seja seguro, um invasor não poderá fazer muito com a chave mestra.</p></div><div class=paragraph><p>Se o KDC não estiver disponível, os serviços de rede não poderão ser utilizados, pois a autenticação não poderá ser executada. Isso pode ser mitigado com um único KDC master e um ou mais slaves, e com a implementação cuidadosa da autenticação secundária ou de fallback usando PAM.</p></div><div class=paragraph><p>O Kerberos permite que usuários, hosts e serviços se autentiquem entre si. Ele não possui um mecanismo para autenticar o KDC para os usuários, hosts ou serviços. Isso significa que um <code>kinit</code> infectado por um trojan pode registrar todos os nomes de usuário e senhas. As ferramentas de verificação de integridade do sistema de arquivos, como <a class=package href=https://cgit.freebsd.org/ports/tree/security/tripwire/>security/tripwire</a>, podem mitigar isso.</p></div></div><div class=sect3><h4 id=_recursos_e_outras_informações>13.5.7. Recursos e Outras Informações<a class=anchor href=#_recursos_e_outras_informações></a></h4><div class=ulist><ul><li><p><a href=http://www.faqs.org/faqs/Kerberos-faq/general/preamble.html>A FAQ do Kerberos</a></p></li><li><p><a href=http://web.mit.edu/Kerberos/www/dialogue.html>Criando um Sistema de Autenticação: um Diálogo em Quatro Cenas</a></p></li><li><p><a href=https://www.ietf.org/rfc/rfc4120.txt>RFC 4120, O Serviço de Autenticação em Rede (V5) do Kerberos</a></p></li><li><p><a href=http://web.mit.edu/Kerberos/www/>Página Web do Kerberos MIT</a></p></li><li><p><a href=https://github.com/heimdal/heimdal/wiki>Página web do Heimdal Kerberos</a></p></li></ul></div></div></div><div class=sect2><h3 id=openssl>13.6. OpenSSL<a class=anchor href=#openssl></a></h3><div class=paragraph><p>O OpenSSL é uma implementação de software livre dos protocolos SSL e TLS. Ele fornece uma camada de transporte de criptografia sobre a camada de comunicação normal, permitindo que ela seja entrelaçada com muitos aplicativos e serviços de rede.</p></div><div class=paragraph><p>A versão do OpenSSL incluída no FreeBSD suporta os protocolos de segurança de redes Secure Sockets Layer 3.0 (SSLv3) e Transport Layer Security 1.0/1.1/1.2 (TLSv1/TLSv1.1/TLSv1.2) e pode ser usado como uma biblioteca de criptografia geral. No FreeBSD 12.0-RELEASE e posterior, OpenSSL também suporta Transport Layer Security 1.3 (TLSv1.3).</p></div><div class=paragraph><p>O OpenSSL é muitas vezes usado para encriptar a autenticação de clientes de email e proteger transações baseadas na web como pagamentos com cartões de crédito. Alguns ports, como o <a class=package href=https://cgit.freebsd.org/ports/tree/www/apache24/>www/apache24</a> e <a class=package href=https://cgit.freebsd.org/ports/tree/databases/postgresql11-server/>databases/postgresql11-server</a>, incluem uma opção de compilação para inserir o OpenSSL. Se selecionado, o port vai adicionar suporte ao OpenSSL da base do sistema. Para ter o port compilado com o suporte do OpenSSL do port <a class=package href=https://cgit.freebsd.org/ports/tree/security/openssl/>security/openssl</a>, adicione o seguinte ao arquivo <span class=filename>/etc/make.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>DEFAULT_VERSIONS+= ssl=openssl</pre></div></div><div class=paragraph><p>Outro uso comum do OpenSSL é fornecer certificados para uso com aplicaçõe de software. Os certificados podem ser usados para verificar as credenciais de uma empresa ou indivíduo. Se um certificado não tiver sido assinado por uma <em>Autoridade de Certificação</em> externa ( CA ), como <a href=http://www.verisign.com>http://www.verisign.com</a>, o aplicativo que usa o certificado produzirá um aviso. Há um custo associado à obtenção de um certificado assinado e o uso de um certificado assinado não é obrigatório, pois os certificados podem ser auto-assinados. No entanto, o uso de uma autoridade externa evitará avisos e poderá deixar os usuários mais à vontade.</p></div><div class=paragraph><p>Esta seção demonstra como criar e usar certificados em um sistema FreeBSD. Consulte <a href=./#ldap-config>Configurando um servidor LDAP</a> para um exemplo de como criar uma CA para assinar seus próprios certificados.</p></div><div class=paragraph><p>Para obter maiores informações sobre o SSL, leia o <a href=https://www.feistyduck.com/books/openssl-cookbook/>OpenSSL Cookbook </a>gratuito.</p></div><div class=sect3><h4 id=_gerando_certificados>13.6.1. Gerando Certificados<a class=anchor href=#_gerando_certificados></a></h4><div class=paragraph><p>Para gerar um certificado que será assinado por uma CA externa, emita o seguinte comando e insira as informações solicitadas nos prompts. Esta informação de entrada será gravada no certificado. No prompt <code>Common Name</code>, insira o nome completo para o sistema que usará o certificado. Se esse nome não corresponder ao servidor, a aplicação que estiver verificando o certificado emitirá um aviso para o usuário, tornando a verificação provida pelo certificado inútil.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># openssl req -new -nodes -out req.pem -keyout cert.key -sha256 -newkey rsa:2048</span>
Generating a 2048 bit RSA private key
..................+++
.............................................................+++
writing new private key to <span class=s1>&#39;cert.key&#39;</span>
<span class=nt>-----</span>
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter <span class=s1>&#39;.&#39;</span>, the field will be left blank.
<span class=nt>-----</span>
Country Name <span class=o>(</span>2 letter code<span class=o>)</span> <span class=o>[</span>AU]:US
State or Province Name <span class=o>(</span>full name<span class=o>)</span> <span class=o>[</span>Some-State]:PA
Locality Name <span class=o>(</span>eg, city<span class=o>)</span> <span class=o>[]</span>:Pittsburgh
Organization Name <span class=o>(</span>eg, company<span class=o>)</span> <span class=o>[</span>Internet Widgits Pty Ltd]:My Company
Organizational Unit Name <span class=o>(</span>eg, section<span class=o>)</span> <span class=o>[]</span>:Systems Administrator
Common Name <span class=o>(</span>eg, YOUR name<span class=o>)</span> <span class=o>[]</span>:localhost.example.org
Email Address <span class=o>[]</span>:trhodes@FreeBSD.org

Please enter the following <span class=s1>&#39;extra&#39;</span> attributes
to be sent with your certificate request
A challenge password <span class=o>[]</span>:
An optional company name <span class=o>[]</span>:Another Name</code></pre></div></div><div class=paragraph><p>Outras opções, como o tempo de expiração e algoritmos de criptografia alternativos, estão disponíveis ao criar um certificado. Uma lista completa de opções é descrita em <a href="https://man.freebsd.org/cgi/man.cgi?query=openssl&amp;sektion=1&amp;format=html">openssl(1)</a>.</p></div><div class=paragraph><p>Este comando irá criar dois arquivos no diretório atual. A solicitação de certificado, <span class=filename>req.pem</span>, pode ser enviada para uma CA que validará as credenciais inseridas, assinará a solicitação e retornará o certificado assinado. O segundo arquivo, <span class=filename>cert.key</span>, é a chave privada do certificado e deve ser armazenado em um local seguro. Se ele cair nas mãos de outros, ele pode ser usado para representar o usuário ou o servidor.</p></div><div class=paragraph><p>Como alternativa, se uma assinatura de uma CA não for necessária, um certificado auto-assinado poderá ser criado. Primeiro, gere a chave RSA:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># openssl genrsa -rand -genkey -out cert.key 2048</span>
0 semi-random bytes loaded
Generating RSA private key, 2048 bit long modulus
.............................................+++
.................................................................................................................+++
e is 65537 <span class=o>(</span>0x10001<span class=o>)</span></code></pre></div></div><div class=paragraph><p>Use essa chave para criar um certificado auto-assinado. Siga os prompts usuais para criar um certificado:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># openssl req -new -x509 -days 365 -key cert.key -out cert.crt -sha256</span>
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter <span class=s1>&#39;.&#39;</span>, the field will be left blank.
<span class=nt>-----</span>
Country Name <span class=o>(</span>2 letter code<span class=o>)</span> <span class=o>[</span>AU]:US
State or Province Name <span class=o>(</span>full name<span class=o>)</span> <span class=o>[</span>Some-State]:PA
Locality Name <span class=o>(</span>eg, city<span class=o>)</span> <span class=o>[]</span>:Pittsburgh
Organization Name <span class=o>(</span>eg, company<span class=o>)</span> <span class=o>[</span>Internet Widgits Pty Ltd]:My Company
Organizational Unit Name <span class=o>(</span>eg, section<span class=o>)</span> <span class=o>[]</span>:Systems Administrator
Common Name <span class=o>(</span>e.g. server FQDN or YOUR name<span class=o>)</span> <span class=o>[]</span>:localhost.example.org
Email Address <span class=o>[]</span>:trhodes@FreeBSD.org</code></pre></div></div><div class=paragraph><p>Isso criará dois novos arquivos no diretório atual: um arquivo de chave privada <span class=filename>cert.key</span> e o próprio certificado, <span class=filename>cert.crt</span>. Estes devem ser colocados em um diretório, preferencialmente sob <span class=filename>/etc/ssl/</span>, que é legível somente pelo <code>root</code>. As permissões de <code>0700</code> são apropriadas para esses arquivos e podem ser definidas usando o <code>chmod</code>.</p></div></div><div class=sect3><h4 id=_usando_certificados>13.6.2. Usando Certificados<a class=anchor href=#_usando_certificados></a></h4><div class=paragraph><p>Um uso para um certificado é criptografar conexões do servidor de email Sendmail para evitar o trafego de informações de autenticação em texto não criptografado.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Alguns clientes de email exibirão um erro se o usuário não tiver instalado uma cópia local do certificado. Consulte a documentação incluída com o software para obter maiores informações sobre a instalação do certificado.</p></div></td></tr></tbody></table></div><div class=paragraph><p>No FreeBSD 10.0-RELEASE e posterior, é possível criar um certificado auto-assinado para o Sendmail automaticamente. Para habilitar isso, adicione as seguintes linhas ao arquivo <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>sendmail_enable=&#34;YES&#34;
sendmail_cert_create=&#34;YES&#34;
sendmail_cert_cn=&#34;localhost.example.org&#34;</pre></div></div><div class=paragraph><p>Isso criará automaticamente um certificado auto-assinado, <span class=filename>/etc/mail/certs/host.cert</span>, uma chave de assinatura, <span class=filename>/etc/mail/certs/host.key</span>, e um certificado CA, <span class=filename>/etc/mail/certs/cacert.pem</span>. O certificado usará o <code>Common Name</code> especificado em <code>sendmail_cert_cn</code>. Depois de salvar as edições, reinicie o Sendmail:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service sendmail restart</span></code></pre></div></div><div class=paragraph><p>Se tudo correr bem, não haverá mensagens de erro no arquivo <span class=filename>/var/log/maillog</span>. Para um teste simples, conecte-se à porta de escuta do servidor de correio usando o <code>telnet</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># telnet example.com 25</span>
Trying 192.0.34.166...
Connected to example.com.
Escape character is <span class=s1>&#39;^]&#39;</span><span class=nb>.</span>
220 example.com ESMTP Sendmail 8.14.7/8.14.7<span class=p>;</span> Fri, 18 Apr 2014 11:50:32 <span class=nt>-0400</span> <span class=o>(</span>EDT<span class=o>)</span>
ehlo example.com
250-example.com Hello example.com <span class=o>[</span>192.0.34.166], pleased to meet you
250-ENHANCEDSTATUSCODES
250-PIPELINING
250-8BITMIME
250-SIZE
250-DSN
250-ETRN
250-AUTH LOGIN PLAIN
250-STARTTLS
250-DELIVERBY
250 HELP
quit
221 2.0.0 example.com closing connection
Connection closed by foreign host.</code></pre></div></div><div class=paragraph><p>Se a linha <code>STARTTLS</code> aparecer na saída, tudo está funcionando corretamente.</p></div></div></div><div class=sect2><h3 id=ipsec>13.7. VPN Sobre IPsec<a class=anchor href=#ipsec></a></h3><div class=paragraph><p>O Protocolo de Segurança da Internet (IPsec) é um conjunto de protocolos que se situam no topo da camada do Protocolo da Internet (IP). Ele permite que dois ou mais hosts se comuniquem de maneira segura, autenticando e criptografando cada pacote IP de uma sessão de comunicação. A pilha de rede IPsec do FreeBSD é baseada na implementação do <a href=http://www.kame.net/>http://www.kame.net/</a> e suporta as sessões IPv4 e IPv6.</p></div><div class=paragraph><p>O IPsec é composto pelos seguintes sub-protocolos:</p></div><div class=ulist><ul><li><p><em>Encapsulated Securtity Payload (ESP)</em>: este protocolo protege os dados do pacote IP da interferência de terceiros, criptografando o conteúdo usando algoritmos de criptografia simétricos, como Blowfish e 3DES.</p></li><li><p>_Authentication Header (AH) _: este protocolo protege o cabeçalho do pacote IP da interferência e spoofing de terceiros calculando um checksum criptográfico e gerando o hash dos campos de cabeçalho do pacote IP com uma função de hash segura. Isso é seguido por um cabeçalho adicional que contém o hash, para permitir que as informações no pacote sejam autenticadas.</p></li><li><p><em>IP Payload Compression Protocol (IPComp):</em> este protocolo tenta aumentar o desempenho da comunicação comprimindo o payload IP para reduzir a quantidade de dados enviados .</p></li></ul></div><div class=paragraph><p>Esses protocolos podem ser usados juntos ou separadamente, dependendo do ambiente.</p></div><div class=paragraph><p>O IPsec suporta dois modos de operação. O primeiro modo, <em>Modo de Transporte</em>, protege as comunicações entre dois hosts. O segundo modo, <em>Modo de túnel</em>, é usado para construir túneis virtuais, comumente conhecidos como redes privadas virtuais (VPNs). Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=ipsec&amp;sektion=4&amp;format=html">ipsec(4)</a> para obter informações detalhadas sobre o subsistema IPsec no FreeBSD.</p></div><div class=paragraph><p>O suporte a IPsec é ativado por padrão no FreeBSD 11 e posteriores. Para versões anteriores do FreeBSD, adicione estas opções a um arquivo de configuração de kernel personalizado e recompile o kernel usando as instruções em <a href=./#kernelconfig>Configurando o kernel do FreeBSD</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>options   IPSEC        IP security
device    crypto</code></pre></div></div><div class=paragraph><p>Se o suporte a depuração do IPsec for desejado, a seguinte opção de kernel também deve ser adicionada:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>options   IPSEC_DEBUG  debug <span class=k>for </span>IP security</code></pre></div></div><div class=paragraph><p>Este restante deste capítulo demonstra o processo de configuração de uma VPNIPsec entre uma rede doméstica e uma rede corporativa. No cenário de exemplo:</p></div><div class=ulist><ul><li><p>Ambos os sites estão conectados à Internet através de um gateway que está executando o FreeBSD.</p></li><li><p>O gateway em cada rede tem pelo menos um endereço IP externo. Neste exemplo, o endereço IP externo da LAN corporativa é <code>172.16.5.4</code> e o IP externo da LAN doméstica é <code>192.168.1.12</code>.</p></li><li><p>Os endereços internos das duas redes podem ser endereços IP públicos ou privados. No entanto, o espaço de endereço não deve colidir. Por exemplo, ambas as redes não podem usar <code>192.168.1.x</code>. Neste exemplo, o endereço IP interno da LAN corporativa é <code>10.246.38.1</code> e o endereço do IP interno da LAN doméstica é <code>10.0.0.5</code>.</p></li></ul></div><div class=sect3><h4 id=_configurando_uma_vpn_no_freebsd>13.7.1. Configurando uma VPN no FreeBSD<a class=anchor href=#_configurando_uma_vpn_no_freebsd></a></h4><div class=paragraph><p>Para começar, o <a class=package href=https://cgit.freebsd.org/ports/tree/security/ipsec-tools/>security/ipsec-tools</a> deve ser instalado a partir da Coleção de Ports. Este software fornece várias aplicações que suportam a configuração.</p></div><div class=paragraph><p>O próximo requisito é criar dois pseudo-dispositivos <a href="https://man.freebsd.org/cgi/man.cgi?query=gif&amp;sektion=4&amp;format=html">gif(4)</a> que serão usados para encapsular pacotes e permitir que ambas as redes se comuniquem adequadamente. Como <code>root</code>, execute os seguintes comandos, substituindo <em>internal</em> e <em>external</em> pelos endereços IP reais das interfaces internas e externas dos dois gateways:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig gif0 create</span>
<span class=c># ifconfig gif0 internal1 internal2</span>
<span class=c># ifconfig gif0 tunnel external1 external2</span></code></pre></div></div><div class=paragraph><p>Verifique a configuração em cada gateway, usando o <code>ifconfig</code>. Aqui está a saída do Gateway 1:</p></div><div class="literalblock programlisting"><div class=content><pre>gif0: flags=8051 mtu 1280
tunnel inet 172.16.5.4 --&gt; 192.168.1.12
inet6 fe80::2e0:81ff:fe02:5881%gif0 prefixlen 64 scopeid 0x6
inet 10.246.38.1 --&gt; 10.0.0.5 netmask 0xffffff00</pre></div></div><div class=paragraph><p>Aqui está a saída do Gateway 2:</p></div><div class="literalblock programlisting"><div class=content><pre>gif0: flags=8051 mtu 1280
tunnel inet 192.168.1.12 --&gt; 172.16.5.4
inet 10.0.0.5 --&gt; 10.246.38.1 netmask 0xffffff00
inet6 fe80::250:bfff:fe3a:c1f%gif0 prefixlen 64 scopeid 0x4</pre></div></div><div class=paragraph><p>Depois de concluídos, os dois endereços de IP internos devem ser acessados usando <a href="https://man.freebsd.org/cgi/man.cgi?query=ping&amp;sektion=8&amp;format=html">ping(8)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>priv-net# ping 10.0.0.5
PING 10.0.0.5 <span class=o>(</span>10.0.0.5<span class=o>)</span>: 56 data bytes
64 bytes from 10.0.0.5: <span class=nv>icmp_seq</span><span class=o>=</span>0 <span class=nv>ttl</span><span class=o>=</span>64 <span class=nb>time</span><span class=o>=</span>42.786 ms
64 bytes from 10.0.0.5: <span class=nv>icmp_seq</span><span class=o>=</span>1 <span class=nv>ttl</span><span class=o>=</span>64 <span class=nb>time</span><span class=o>=</span>19.255 ms
64 bytes from 10.0.0.5: <span class=nv>icmp_seq</span><span class=o>=</span>2 <span class=nv>ttl</span><span class=o>=</span>64 <span class=nb>time</span><span class=o>=</span>20.440 ms
64 bytes from 10.0.0.5: <span class=nv>icmp_seq</span><span class=o>=</span>3 <span class=nv>ttl</span><span class=o>=</span>64 <span class=nb>time</span><span class=o>=</span>21.036 ms
<span class=nt>---</span> 10.0.0.5 ping statistics <span class=nt>---</span>
4 packets transmitted, 4 packets received, 0% packet loss
round-trip min/avg/max/stddev <span class=o>=</span> 19.255/25.879/42.786/9.782 ms</code></pre></div></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>corp-net# ping 10.246.38.1
PING 10.246.38.1 <span class=o>(</span>10.246.38.1<span class=o>)</span>: 56 data bytes
64 bytes from 10.246.38.1: <span class=nv>icmp_seq</span><span class=o>=</span>0 <span class=nv>ttl</span><span class=o>=</span>64 <span class=nb>time</span><span class=o>=</span>28.106 ms
64 bytes from 10.246.38.1: <span class=nv>icmp_seq</span><span class=o>=</span>1 <span class=nv>ttl</span><span class=o>=</span>64 <span class=nb>time</span><span class=o>=</span>42.917 ms
64 bytes from 10.246.38.1: <span class=nv>icmp_seq</span><span class=o>=</span>2 <span class=nv>ttl</span><span class=o>=</span>64 <span class=nb>time</span><span class=o>=</span>127.525 ms
64 bytes from 10.246.38.1: <span class=nv>icmp_seq</span><span class=o>=</span>3 <span class=nv>ttl</span><span class=o>=</span>64 <span class=nb>time</span><span class=o>=</span>119.896 ms
64 bytes from 10.246.38.1: <span class=nv>icmp_seq</span><span class=o>=</span>4 <span class=nv>ttl</span><span class=o>=</span>64 <span class=nb>time</span><span class=o>=</span>154.524 ms
<span class=nt>---</span> 10.246.38.1 ping statistics <span class=nt>---</span>
5 packets transmitted, 5 packets received, 0% packet loss
round-trip min/avg/max/stddev <span class=o>=</span> 28.106/94.594/154.524/49.814 ms</code></pre></div></div><div class=paragraph><p>Como esperado, ambos os lados têm a capacidade de enviar e receber pacotes ICMP dos endereços configurados de forma privada. Em seguida, os dois gateways devem ser informados sobre como rotear pacotes para enviar corretamente o tráfego de qualquer rede. Os seguintes comandos atingirão esse objetivo:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>corp-net# route add 10.0.0.0 10.0.0.5 255.255.255.0
corp-net# route add net 10.0.0.0: gateway 10.0.0.5
priv-net# route add 10.246.38.0 10.246.38.1 255.255.255.0
priv-net# route add host 10.246.38.0: gateway 10.246.38.1</code></pre></div></div><div class=paragraph><p>Neste ponto, as máquinas internas devem ser alcançadas de cada gateway, bem como das máquinas atrás dos gateways. Novamente, use o <a href="https://man.freebsd.org/cgi/man.cgi?query=ping&amp;sektion=8&amp;format=html">ping(8)</a> para confirmar:</p></div><div class="literalblock programlisting"><div class=content><pre>corp-net# ping 10.0.0.8
PING 10.0.0.8 (10.0.0.8): 56 data bytes
64 bytes from 10.0.0.8: icmp_seq=0 ttl=63 time=92.391 ms
64 bytes from 10.0.0.8: icmp_seq=1 ttl=63 time=21.870 ms
64 bytes from 10.0.0.8: icmp_seq=2 ttl=63 time=198.022 ms
64 bytes from 10.0.0.8: icmp_seq=3 ttl=63 time=22.241 ms
64 bytes from 10.0.0.8: icmp_seq=4 ttl=63 time=174.705 ms
--- 10.0.0.8 ping statistics ---
5 packets transmitted, 5 packets received, 0% packet loss
round-trip min/avg/max/stddev = 21.870/101.846/198.022/74.001 ms

priv-net# ping 10.246.38.107
PING 10.246.38.1 (10.246.38.107): 56 data bytes
64 bytes from 10.246.38.107: icmp_seq=0 ttl=64 time=53.491 ms
64 bytes from 10.246.38.107: icmp_seq=1 ttl=64 time=23.395 ms
64 bytes from 10.246.38.107: icmp_seq=2 ttl=64 time=23.865 ms
64 bytes from 10.246.38.107: icmp_seq=3 ttl=64 time=21.145 ms
64 bytes from 10.246.38.107: icmp_seq=4 ttl=64 time=36.708 ms
--- 10.246.38.107 ping statistics ---
5 packets transmitted, 5 packets received, 0% packet loss
round-trip min/avg/max/stddev = 21.145/31.721/53.491/12.179 ms</pre></div></div><div class=paragraph><p>Configurar os túneis é a parte fácil. Configurar um link seguro é um processo mais aprofundado. A seguinte configuração usa chaves RSA pré-compartilhadas (PSK). Além dos endereços IP, o arquivo <span class=filename>/usr/local/etc/racoon/racoon.conf</span> em ambos os gateways será idêntico e será semelhante a:</p></div><div class="literalblock programlisting"><div class=content><pre>path    pre_shared_key  &#34;/usr/local/etc/racoon/psk.txt&#34;; #location of pre-shared key file
log     debug;	#log verbosity setting: set to &#39;notify&#39; when testing and debugging is complete

padding	# options are not to be changed
{
        maximum_length  20;
        randomize       off;
        strict_check    off;
        exclusive_tail  off;
}

timer	# timing options. change as needed
{
        counter         5;
        interval        20 sec;
        persend         1;
#       natt_keepalive  15 sec;
        phase1          30 sec;
        phase2          15 sec;
}

listen	# address [port] that racoon will listen on
{
        isakmp          172.16.5.4 [500];
        isakmp_natt     172.16.5.4 [4500];
}

remote  192.168.1.12 [500]
{
        exchange_mode   main,aggressive;
        doi             ipsec_doi;
        situation       identity_only;
        my_identifier   address 172.16.5.4;
        peers_identifier        address 192.168.1.12;
        lifetime        time 8 hour;
        passive         off;
        proposal_check  obey;
#       nat_traversal   off;
        generate_policy off;

                        proposal {
                                encryption_algorithm    blowfish;
                                hash_algorithm          md5;
                                authentication_method   pre_shared_key;
                                lifetime time           30 sec;
                                dh_group                1;
                        }
}

sainfo  (address 10.246.38.0/24 any address 10.0.0.0/24 any)	# address $network/$netmask $type address $network/$netmask $type ( $type being any or esp)
{								# $network must be the two internal networks you are joining.
        pfs_group       1;
        lifetime        time    36000 sec;
        encryption_algorithm    blowfish,3des;
        authentication_algorithm        hmac_md5,hmac_sha1;
        compression_algorithm   deflate;
}</pre></div></div><div class=paragraph><p>Para descrições de cada opção disponível, consulte a página de manual do <span class=filename>racoon.conf</span>.</p></div><div class=paragraph><p>O Banco de Dados da Política de Segurança (SPD) precisa ser configurado para que o FreeBSD e o racoon consigam criptografar e descriptografar o tráfego de rede entre os hosts.</p></div><div class=paragraph><p>Isso pode ser obtido com um shell script, semelhante ao seguinte, no gateway corporativo. Este arquivo será usado durante a inicialização do sistema e deve ser salvo como <span class=filename>/usr/local/etc/racoon/setkey.conf</span>.</p></div><div class="literalblock programlisting"><div class=content><pre>flush;
spdflush;
# To the home network
spdadd 10.246.38.0/24 10.0.0.0/24 any -P out ipsec esp/tunnel/172.16.5.4-192.168.1.12/use;
spdadd 10.0.0.0/24 10.246.38.0/24 any -P in ipsec esp/tunnel/192.168.1.12-172.16.5.4/use;</pre></div></div><div class=paragraph><p>Uma vez que o arquivo estiver no seu lugar, o racoon pode ser iniciado em ambos os gateways usando o seguinte comando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /usr/local/sbin/racoon -F -f /usr/local/etc/racoon/racoon.conf -l /var/log/racoon.log</span></code></pre></div></div><div class=paragraph><p>A saída deve ser semelhante à seguinte:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>corp-net# /usr/local/sbin/racoon <span class=nt>-F</span> <span class=nt>-f</span> /usr/local/etc/racoon/racoon.conf
Foreground mode.
2006-01-30 01:35:47: INFO: begin Identity Protection mode.
2006-01-30 01:35:48: INFO: received Vendor ID: KAME/racoon
2006-01-30 01:35:55: INFO: received Vendor ID: KAME/racoon
2006-01-30 01:36:04: INFO: ISAKMP-SA established 172.16.5.4[500]-192.168.1.12[500] spi:623b9b3bd2492452:7deab82d54ff704a
2006-01-30 01:36:05: INFO: initiate new phase 2 negotiation: 172.16.5.4[0]192.168.1.12[0]
2006-01-30 01:36:09: INFO: IPsec-SA established: ESP/Tunnel 192.168.1.12[0]-&gt;172.16.5.4[0] <span class=nv>spi</span><span class=o>=</span>28496098<span class=o>(</span>0x1b2d0e2<span class=o>)</span>
2006-01-30 01:36:09: INFO: IPsec-SA established: ESP/Tunnel 172.16.5.4[0]-&gt;192.168.1.12[0] <span class=nv>spi</span><span class=o>=</span>47784998<span class=o>(</span>0x2d92426<span class=o>)</span>
2006-01-30 01:36:13: INFO: respond new phase 2 negotiation: 172.16.5.4[0]192.168.1.12[0]
2006-01-30 01:36:18: INFO: IPsec-SA established: ESP/Tunnel 192.168.1.12[0]-&gt;172.16.5.4[0] <span class=nv>spi</span><span class=o>=</span>124397467<span class=o>(</span>0x76a279b<span class=o>)</span>
2006-01-30 01:36:18: INFO: IPsec-SA established: ESP/Tunnel 172.16.5.4[0]-&gt;192.168.1.12[0] <span class=nv>spi</span><span class=o>=</span>175852902<span class=o>(</span>0xa7b4d66<span class=o>)</span></code></pre></div></div><div class=paragraph><p>Para garantir que o túnel esteja funcionando corretamente, mude para outro console e use o <a href="https://man.freebsd.org/cgi/man.cgi?query=tcpdump&amp;sektion=1&amp;format=html">tcpdump(1)</a> para exibir o tráfego de rede usando o comando a seguir. Substitua <code>em0</code> pela placa de interface de rede conforme necessário:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># tcpdump -i em0 host 172.16.5.4 and dst 192.168.1.12</span></code></pre></div></div><div class=paragraph><p>Dados semelhantes aos seguintes devem aparecer no console. Caso contrário, há um problema e a depuração dos dados retornados será necessária.</p></div><div class="literalblock programlisting"><div class=content><pre>01:47:32.021683 IP corporatenetwork.com &gt; 192.168.1.12.privatenetwork.com: ESP(spi=0x02acbf9f,seq=0xa)
01:47:33.022442 IP corporatenetwork.com &gt; 192.168.1.12.privatenetwork.com: ESP(spi=0x02acbf9f,seq=0xb)
01:47:34.024218 IP corporatenetwork.com &gt; 192.168.1.12.privatenetwork.com: ESP(spi=0x02acbf9f,seq=0xc)</pre></div></div><div class=paragraph><p>Neste ponto, as duas redes devem estar disponíveis e parecem fazer parte da mesma rede. Muito provavelmente ambas as redes estão protegidas por um firewall. Para permitir que o tráfego flua entre elas, regras precisam ser adicionadas para liberar a passagem dos pacotes. Para o firewall <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfw&amp;sektion=8&amp;format=html">ipfw(8)</a>, adicione as seguintes linhas ao arquivo de configuração do firewall:</p></div><div class="literalblock programlisting"><div class=content><pre>ipfw add 00201 allow log esp from any to any
ipfw add 00202 allow log ah from any to any
ipfw add 00203 allow log ipencap from any to any
ipfw add 00204 allow log udp from any 500 to any</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Os números das regras podem precisar ser alterados dependendo da configuração atual do host.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Para usuários do <a href="https://man.freebsd.org/cgi/man.cgi?query=pf&amp;sektion=4&amp;format=html">pf(4)</a> ou do <a href="https://man.freebsd.org/cgi/man.cgi?query=ipf&amp;sektion=8&amp;format=html">ipf(8)</a> , as seguintes regras devem fazer o truque:</p></div><div class="literalblock programlisting"><div class=content><pre>pass in quick proto esp from any to any
pass in quick proto ah from any to any
pass in quick proto ipencap from any to any
pass in quick proto udp from any port = 500 to any port = 500
pass in quick on gif0 from any to any
pass out quick proto esp from any to any
pass out quick proto ah from any to any
pass out quick proto ipencap from any to any
pass out quick proto udp from any port = 500 to any port = 500
pass out quick on gif0 from any to any</pre></div></div><div class=paragraph><p>Finalmente, para permitir que a máquina inicie o suporte para a VPN durante a inicialização do sistema, adicione as seguintes linhas ao arquivo <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>ipsec_enable=&#34;YES&#34;
ipsec_program=&#34;/usr/local/sbin/setkey&#34;
ipsec_file=&#34;/usr/local/etc/racoon/setkey.conf&#34; # allows setting up spd policies on boot
racoon_enable=&#34;yes&#34;</pre></div></div></div></div><div class=sect2><h3 id=openssh>13.8. OpenSSH<a class=anchor href=#openssh></a></h3><div class=paragraph><p>O OpenSSH é um conjunto de ferramentas de conectividade de rede usadas para fornecer acesso seguro a máquinas remotas. Além disso, as conexões TCP/IP podem ser encapsuladas ou encaminhadas com segurança através de conexões SSH. O OpenSSH criptografa todo o tráfego para eliminar efetivamente a interceptação, o sequestro de conexão e outros ataques no nível da rede.</p></div><div class=paragraph><p>O OpenSSH é mantido pelo projeto OpenBSD e é instalado por padrão no FreeBSD. É compatível com os protocolos de versão 1 e 2 do SSH.</p></div><div class=paragraph><p>Quando os dados são enviados pela rede em um formato não criptografado, sniffers de rede posicionados em qualquer lugar entre o cliente e o servidor podem roubar as informações do usuário/senha ou os dados transferidos durante a sessão. O OpenSSH oferece uma variedade de métodos de autenticação e criptografia para evitar que isso aconteça. Mais informações sobre o OpenSSH estão disponíveis em <a href=http://www.openssh.com/>http://www.openssh.com/</a>.</p></div><div class=paragraph><p>Esta seção fornece uma visão geral dos utilitários embutidos de cliente para acessar com segurança outros sistemas e transferir arquivos com segurança de um sistema FreeBSD. Em seguida, descreve como configurar um servidor SSH em um sistema FreeBSD. Maiores informações estão disponíveis nas páginas man mencionadas neste capítulo.</p></div><div class=sect3><h4 id=_usando_os_utilitários_de_cliente_ssh>13.8.1. Usando os Utilitários de Cliente SSH<a class=anchor href=#_usando_os_utilitários_de_cliente_ssh></a></h4><div class=paragraph><p>Para logar em um servidor SSH, use <code>ssh</code> e especifique um nome de usuário que exista naquele servidor e o endereço IP ou nome de host do servidor. Se esta for a primeira vez que uma conexão foi feita ao servidor especificado, o usuário será solicitado a primeiro verificar a impressão digital do servidor:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ssh user@example.com</span>
The authenticity of host <span class=s1>&#39;example.com (10.0.0.1)&#39;</span> can<span class=s1>&#39;t be established.
ECDSA key fingerprint is 25:cc:73:b5:b3:96:75:3d:56:19:49:d2:5c:1f:91:3b.
Are you sure you want to continue connecting (yes/no)? yes
Permanently added &#39;</span>example.com<span class=s1>&#39; (ECDSA) to the list of known hosts.
Password for user@example.com: user_password</span></code></pre></div></div><div class=paragraph><p>O SSH utiliza um sistema de impressão digital de chaves para verificar a autenticidade do servidor quando o cliente se conecta. Quando o usuário aceita a impressão digital da chave digitando <code>yes</code> ao conectar-se pela primeira vez, uma cópia da chave é salva em <span class=filename>.ssh/known_hosts</span> no diretório pessoal do usuário. Futuras tentativas de login são verificadas em relação à chave salva e o <code>ssh</code> exibirá um alerta se a chave do servidor não corresponder à chave salva. Se isso ocorrer, o usuário deve primeiro verificar por que a chave foi alterada antes de continuar com a conexão.</p></div><div class=paragraph><p>Por padrão, versões recentes do OpenSSH aceitam apenas conexões SSH v2. Por padrão, o cliente usará a versão 2 se possível e voltará para a versão 1 se o servidor não suportar a versão 2. Para forçar o <code>ssh</code> a usar somente o protocolo especificado, inclua <code>-1</code> ou <code>-2</code>. Opções adicionais são descritas em <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh&amp;sektion=1&amp;format=html">ssh(1)</a>.</p></div><div class=paragraph><p>Use o <a href="https://man.freebsd.org/cgi/man.cgi?query=scp&amp;sektion=1&amp;format=html">scp(1)</a> para copiar com segurança um arquivo para ou de uma máquina remota. Este exemplo copia o arquivo <span class=filename>COPYRIGHT</span> do sistema remoto para um arquivo com o mesmo nome no diretório atual do sistema local:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># scp user@example.com:/COPYRIGHT COPYRIGHT</span>
Password <span class=k>for </span>user@example.com: <span class=k>*******</span>
COPYRIGHT            100% |<span class=k>*****************************</span>|  4735
00:00
<span class=c>#</span></code></pre></div></div><div class=paragraph><p>Como a impressão digital já foi verificada para esse host, a chave do servidor é verificada automaticamente antes de solicitar a senha do usuário.</p></div><div class=paragraph><p>Os argumentos passados para o <code>scp</code> são semelhantes ao comando <code>cp</code>. O arquivo ou arquivos para copiar é o primeiro argumento e o destino para copiar é o segundo. Como o arquivo é buscado pela rede, um ou mais dos argumentos do arquivo assumem o formato <code>user@host:&lt;path_to_remote_file></code>. Esteja ciente ao copiar recursivamente diretórios que o <code>scp</code> usa a opção <code>-r</code>, enquanto <code>cp</code> usa a <code>-R</code>.</p></div><div class=paragraph><p>Para abrir uma sessão interativa para copiar arquivos, use o <code>sftp</code>. Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=sftp&amp;sektion=1&amp;format=html">sftp(1)</a> para obter uma lista de comandos disponíveis enquanto estiver em uma sessão <code>sftp</code>.</p></div><div class=sect4><h5 id=security-ssh-keygen>13.8.1.1. Autenticação Baseada em Chave<a class=anchor href=#security-ssh-keygen></a></h5><div class=paragraph><p>Em vez de usar senhas, um cliente pode ser configurado para se conectar à máquina remota usando chaves. Para gerar chaves de autenticação RSA, use o <code>ssh-keygen</code>. Para gerar um par de chaves pública e privada, especifique o tipo de chave e siga os prompts. Recomenda-se proteger as chaves com uma senha memorável, mas difícil de se adivinhar.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ssh-keygen <span class=nt>-t</span> rsa
Generating public/private rsa key pair.
Enter file <span class=k>in </span>which to save the key <span class=o>(</span>/home/user/.ssh/id_rsa<span class=o>)</span>:
Enter passphrase <span class=o>(</span>empty <span class=k>for </span>no passphrase<span class=o>)</span>:  <i class=conum data-value=1></i><b>(1)</b>
Enter same passphrase again:                 <i class=conum data-value=2></i><b>(2)</b>
Your identification has been saved <span class=k>in</span> /home/user/.ssh/id_rsa.
Your public key has been saved <span class=k>in</span> /home/user/.ssh/id_rsa.pub.
The key fingerprint is:
SHA256:54Xm9Uvtv6H4NOo6yjP/YCfODryvUU7yWHzMqeXwhq8 user@host.example.com
The key<span class=s1>&#39;s randomart image is:
+---[RSA 2048]----+
|                 |
|                 |
|                 |
|        . o..    |
|       .S*+*o    |
|      . O=Oo . . |
|       = Oo= oo..|
|      .oB.* +.oo.|
|       =OE**.o..=|
+----[SHA256]-----+</span></code></pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>Digite uma senha aqui. Pode conter espaços e símbolos.</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td>Digite novamente a senha para verificá-la.</td></tr></tbody></table></div><div class=paragraph><p>A chave privada é armazenada no arquivo <span class=filename>~/.ssh/id_rsa</span> e a chave pública é armazenada no arquivo <span class=filename>~/.ssh/id_rsa.pub</span>. A chave <em>publica</em> deve ser copiada para <span class=filename>~/.ssh/ authorized_keys</span> na máquina remota para que a autenticação baseada em chave funcione.</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Muitos usuários acreditam que as chaves são seguras por design e usarão uma chave sem uma senha. Este é um comportamento <em>perigoso</em>. Um administrador pode verificar se um par de chaves está protegido por uma senha, visualizando a chave privada manualmente. Se o arquivo de chave privada contiver a palavra <code>ENCRYPTED</code>, o dono da chave está usando uma senha. Além disso, para proteger melhor os usuários finais, o termo <code>from</code> pode ser colocado no arquivo de chave pública. Por exemplo, adicionar <code>from "192.168.10.5"</code> na frente do prefixo <code>ssh-rsa</code> só permitirá que esse usuário específico efetue login a partir desse endereço IP.</p></div></td></tr></tbody></table></div><div class=paragraph><p>As opções e arquivos variam de acordo com as diferentes versões do OpenSSH. Para evitar problemas, consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-keygen&amp;sektion=1&amp;format=html">ssh-keygen(1)</a>.</p></div><div class=paragraph><p>Se uma senha for usada, o usuário será solicitado a inserir a senha toda vez que uma conexão for feita ao servidor. Para carregar as chaves de SSH na memória e remover a necessidade de digitar a senha toda vez, use o <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-agent&amp;sektion=1&amp;format=html">ssh-agent(1)</a> e o <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-add&amp;sektion=1&amp;format=html">ssh-add(1)</a>.</p></div><div class=paragraph><p>A autenticação é feita pelo <code>ssh-agent</code>, usando as chaves privadas que estão carregadas nele. O <code>ssh-agent</code> pode ser usado para iniciar outro aplicativo como um shell ou um gerenciador de janelas.</p></div><div class=paragraph><p>Para usar o <code>ssh-agent</code> em um shell, inicie-o com um shell como um argumento. Adicione a identidade executando <code>ssh-add</code> e inserindo a senha para a chave privada. O usuário então poderá executar o <code>ssh</code> para se conectar em qualquer host que tenha a chave pública correspondente instalada. Por exemplo:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ssh-agent csh
% ssh-add
Enter passphrase <span class=k>for </span>key <span class=s1>&#39;/usr/home/user/.ssh/id_rsa&#39;</span>:  <i class=conum data-value=1></i><b>(1)</b>
Identity added: /usr/home/user/.ssh/id_rsa <span class=o>(</span>/usr/home/user/.ssh/id_rsa<span class=o>)</span>
%</code></pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>Digite a senha para a chave.</td></tr></tbody></table></div><div class=paragraph><p>Para usar o <code>ssh-agent</code> no Xorg, adicione uma entrada para ele em <span class=filename>~/.xinitrc</span>. Isso fornece os serviços do <code>ssh-agent</code> para todos os programas iniciados no Xorg. Um exemplo do arquivo <span class=filename>~/.xinitrc</span> pode ter esta aparência:</p></div><div class="literalblock programlisting"><div class=content><pre>exec ssh-agent startxfce4</pre></div></div><div class=paragraph><p>Isso inicia o <code>ssh-agent</code>, que, por sua vez, ativa o XFCE, sempre que o Xorg é iniciado. Uma vez que o Xorg tenha sido reiniciado para que as mudanças entrem em vigor, execute <code>ssh-add</code> para carregar todas as chaves SSH.</p></div></div><div class=sect4><h5 id=security-ssh-tunneling>13.8.1.2. Tunelamento SSH<a class=anchor href=#security-ssh-tunneling></a></h5><div class=paragraph><p>O OpenSSH tem a capacidade de criar um tunel para encapsular outro protocolo em uma sessão criptografada.</p></div><div class=paragraph><p>O comando a seguir informa ao <code>ssh</code> para criar um túnel para o telnet:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ssh <span class=nt>-2</span> <span class=nt>-N</span> <span class=nt>-f</span> <span class=nt>-L</span> 5023:localhost:23 user@foo.example.com
%</code></pre></div></div><div class=paragraph><p>Este exemplo usa as seguintes opções:</p></div><div class=dlist><dl><dt class=hdlist1><code>-2</code></dt><dd><p>Força o comando <code>ssh</code> a usar a versão 2 para conectar-se ao servidor.</p></dd><dt class=hdlist1><code>-N</code></dt><dd><p>Indica nenhum comando ou apenas túnel. Se omitido, o <code>ssh</code> inicia uma sessão normal.</p></dd><dt class=hdlist1><code>-f</code></dt><dd><p>Força o comando <code>ssh</code> a ser executado em segundo plano.</p></dd><dt class=hdlist1><code>-L</code></dt><dd><p>Indica um túnel local no formato <em>localport:remotehost:remoteport</em>.</p></dd><dt class=hdlist1><code>user@foo.example.com</code></dt><dd><p>O nome de login para usar no servidor SSH remoto especificado.</p></dd></dl></div><div class=paragraph><p>Um túnel SSH funciona criando um socket de escuta em <code>localhost</code> na <code>localport</code> especificada. Em seguida, ele encaminha quaisquer conexões recebidas em <code>localport</code> por meio da conexão SSH com o <code>remotehost:remoteport</code> especificado. No exemplo, a porta <code>5023</code> no cliente é encaminhada para a porta <code>23</code> na máquina remota. Como a porta 23 é usada pelo telnet, isso cria uma sessão telnet criptografada através de um túnel SSH.</p></div><div class=paragraph><p>Esse método pode ser usado para agrupar qualquer número de protocolos TCP inseguros, como SMTP, POP3 e FTP, como visto nos exemplos a seguir.</p></div><div class=exampleblock><div class=title>Exemplo 30. Criar um Túnel Seguro para SMTP</div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ssh <span class=nt>-2</span> <span class=nt>-N</span> <span class=nt>-f</span> <span class=nt>-L</span> 5025:localhost:25 user@mailserver.example.com
user@mailserver.example.com<span class=s1>&#39;s password: *****
% telnet localhost 5025
Trying 127.0.0.1...
Connected to localhost.
Escape character is &#39;</span>^]<span class=s1>&#39;.
220 mailserver.example.com ESMTP</span></code></pre></div></div><div class=paragraph><p>Isso pode ser usado em conjunto com <code>ssh-keygen</code> e contas de usuário adicionais para criar um ambiente de encapsulamento SSH mais uniforme. As chaves podem ser usadas no lugar de digitar uma senha e os túneis podem ser executados como um usuário separado.</p></div></div></div><div class=exampleblock><div class=title>Exemplo 31. Acesso Seguro de um Servidor POP3</div><div class=content><div class=paragraph><p>Neste exemplo, há um servidor SSH que aceita conexões de fora. Na mesma rede, existe um servidor de email que executa um servidor POP3. Para verificar o e-mail de maneira segura, crie uma conexão SSH com o servidor SSH e encaminhe para o servidor de e-mail:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ssh <span class=nt>-2</span> <span class=nt>-N</span> <span class=nt>-f</span> <span class=nt>-L</span> 2110:mail.example.com:110 user@ssh-server.example.com
user@ssh-server.example.com<span class=s1>&#39;s password: ******</span></code></pre></div></div><div class=paragraph><p>Quando o túnel estiver ativo e em execução, aponte o cliente de e-mail para enviar solicitações POP3 para <code>localhost</code> na porta 2110. Essa conexão será encaminhada com segurança pelo encapsulamento para <code>mail.example.com</code>.</p></div></div></div><div class=exampleblock><div class=title>Exemplo 32. Ignorando um Firewall</div><div class=content><div class=paragraph><p>Alguns firewalls filtram as conexões de entrada e saída. Por exemplo, um firewall pode limitar o acesso de máquinas remotas às portas 22 e 80 para permitir apenas o SSH e navegação na web. Isso impede o acesso a qualquer outro serviço que use uma porta diferente de 22 ou 80.</p></div><div class=paragraph><p>A solução é criar uma conexão SSH com uma máquina fora do firewall da rede e usá-la para encapsular o serviço desejado:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ssh <span class=nt>-2</span> <span class=nt>-N</span> <span class=nt>-f</span> <span class=nt>-L</span> 8888:music.example.com:8000 user@unfirewalled-system.example.org
user@unfirewalled-system.example.org<span class=s1>&#39;s password: *******</span></code></pre></div></div><div class=paragraph><p>Neste exemplo, um cliente Ogg Vorbis de streaming pode agora ser apontado para <code>localhost</code> na porta 8888, que será encaminhado para <code>music.example.com</code> na porta 8000, ignorando com êxito o firewall.</p></div></div></div></div></div><div class=sect3><h4 id=_ativando_o_servidor_ssh>13.8.2. Ativando o Servidor SSH<a class=anchor href=#_ativando_o_servidor_ssh></a></h4><div class=paragraph><p>Além de fornecer utilitários de cliente SSH embutidos, um sistema FreeBSD pode ser configurado como um servidor SSH, aceitando conexões de outros clientes SSH.</p></div><div class=paragraph><p>Para ver se o sshd está operando, use o comando <a href="https://man.freebsd.org/cgi/man.cgi?query=service&amp;sektion=8&amp;format=html">service(8)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service sshd status</span></code></pre></div></div><div class=paragraph><p>Se o serviço não estiver em execução, adicione a seguinte linha ao arquivo <span class=filename>/etc/rc.conf</span>.</p></div><div class="literalblock programlisting"><div class=content><pre>sshd_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Isso iniciará o sshd, o programa daemon para o OpenSSH, na próxima vez que o sistema for inicializado. Para iniciá-lo agora:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service sshd start</span></code></pre></div></div><div class=paragraph><p>A primeira vez que o sshd inicia em um sistema FreeBSD, as chaves de host do sistema serão criadas automaticamente e a impressão digital será exibida no console. Forneça aos usuários a impressão digital para que eles possam verificá-la na primeira vez que se conectarem ao servidor.</p></div><div class=paragraph><p>Consulte o <a href="https://man.freebsd.org/cgi/man.cgi?query=sshd&amp;sektion=8&amp;format=html">sshd(8)</a> para obter a lista de opções disponíveis ao iniciar o sshd e uma discussão mais completa sobre autenticação, processo de login e os vários arquivos de configuração.</p></div><div class=paragraph><p>Neste ponto, o sshd deve estar disponível para todos os usuários com um nome de usuário e senha no sistema.</p></div></div><div class=sect3><h4 id=_segurança_do_servidor_ssh>13.8.3. Segurança do Servidor SSH<a class=anchor href=#_segurança_do_servidor_ssh></a></h4><div class=paragraph><p>Enquanto o sshd é o recurso de administração remota mais usado para o FreeBSD, a força bruta e o drive por ataques são comuns a qualquer sistema exposto a redes públicas. Vários parâmetros adicionais estão disponíveis para evitar o sucesso desses ataques e serão descritos nesta seção.</p></div><div class=paragraph><p>É uma boa ideia limitar quais usuários podem efetuar login no servidor SSH e de onde usar a palavra-chave <code>AllowUsers</code> no arquivo de configuração do servidor OpenSSH. Por exemplo, para permitir que somente o <code>root</code> efetue login de <code>192.168.1.32</code>, inclua esta linha no arquivo <span class=filename>/etc/ssh/sshd_config</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>AllowUsers root@192.168.1.32</pre></div></div><div class=paragraph><p>Para permitir que o usuário <code>admin</code> efetue login de qualquer lugar, liste esse usuário sem especificar um endereço IP:</p></div><div class="literalblock programlisting"><div class=content><pre>AllowUsers admin</pre></div></div><div class=paragraph><p>Multiplos usuários devem ser listados na mesma linha, assim:</p></div><div class="literalblock programlisting"><div class=content><pre>AllowUsers root@192.168.1.32 admin</pre></div></div><div class=paragraph><p>Depois de fazer alterações no arquivo <span class=filename>/etc/ssh/sshd_config</span>, informe o sshd para recarregar seu arquivo de configuração executando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service sshd reload</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Quando essa palavra-chave é usada, é importante listar cada usuário que precisa efetuar login nesta máquina. Qualquer usuário que não esteja especificado nessa linha será bloqueado. Além disso, as palavras-chave usadas no arquivo de configuração do servidor OpenSSH fazem distinção entre maiúsculas e minúsculas. Se a palavra-chave não estiver escrita corretamente, incluindo esse detalhe, ela será ignorada. Sempre teste as alterações neste arquivo para garantir que as edições estejam funcionando conforme o esperado. Consulte o <a href="https://man.freebsd.org/cgi/man.cgi?query=sshd_config&amp;sektion=5&amp;format=html">sshd_config(5)</a> para verificar a ortografia e o uso das palavras-chave disponíveis.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Além disso, os usuários podem ser forçados a usar a autenticação de dois fatores por meio do uso de uma chave pública e privada. Quando necessário, o usuário pode gerar um par de chaves usando o <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-keygen&amp;sektion=1&amp;format=html">ssh-keygen(1)</a> e enviar ao administrador a chave pública. Este arquivo de chave será colocado no arquivo <span class=filename>authorized_keys</span> como descrito acima na seção cliente. Para forçar os usuários a usar apenas as chaves, a seguinte opção pode ser configurada:</p></div><div class="literalblock programlisting"><div class=content><pre>AuthenticationMethods publickey</pre></div></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Não confunda o arquivo <span class=filename>/etc/ssh/sshd_config</span> com <span class=filename>/etc/ssh/ssh_config</span> (observe o <code>d</code> extra no primeiro nome do arquivo). O primeiro arquivo configura o servidor e o segundo arquivo configura o cliente. Consulte o <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh_config&amp;sektion=5&amp;format=html">ssh_config(5)</a> para obter uma listagem das configurações do cliente disponíveis.</p></div></td></tr></tbody></table></div></div></div><div class=sect2><h3 id=fs-acl>13.9. Listas de Controle de Acesso<a class=anchor href=#fs-acl></a></h3><div class=paragraph><p>As Listas de Controle de Acesso (ACLs) estendem o modelo de permissão padrão do UNIX™ em um compatível com o modo POSIX™.1e. Isso permite que um administrador aproveite um modelo de permissões mais refinado.</p></div><div class=paragraph><p>O kernel FreeBSD <span class=filename>GENERIC</span> fornece suporte a ACL para sistemas de arquivos UFS. Usuários que preferem compilar um kernel personalizado devem incluir a seguinte opção em seu arquivo de configuração do kernel personalizado:</p></div><div class="literalblock programlisting"><div class=content><pre>options UFS_ACL</pre></div></div><div class=paragraph><p>Se esta opção não for ativada na compilação, uma mensagem de aviso será exibida ao tentar montar um sistema de arquivos com o suporte a ACL. As ACLs dependem de atributos estendidos que são suportados nativamente pelo UFS2.</p></div><div class=paragraph><p>Este capítulo descreve como ativar o suporte a ACL e fornece alguns exemplos de uso.</p></div><div class=sect3><h4 id=_ativando_o_suporte_a_acl>13.9.1. Ativando o Suporte a ACL<a class=anchor href=#_ativando_o_suporte_a_acl></a></h4><div class=paragraph><p>As ACLs são habilitadas pela flag administrativa de tempo de montagem, <code>acls</code>, que podem ser adicionadas ao arquivo <span class=filename>/etc/fstab</span>. As flags de tempo de montagem também podem ser configuradas automaticamente de forma persistente usando-se o <a href="https://man.freebsd.org/cgi/man.cgi?query=tunefs&amp;sektion=8&amp;format=html">tunefs(8)</a> para modificar um superbloco de flags ACLs no cabeçalho do sistema de arquivos. Em geral, é preferível usar flags de superbloco por vários motivos:</p></div><div class=ulist><ul><li><p>A flag de superbloco não pode ser alterada por um remount usando <code>mount -u</code>, pois requer um <code>umount</code> completo e um <code>mount</code> completo. Isso significa que as ACLs não podem ser ativadas no sistema de arquivos raiz após a inicialização. Isso também significa que o suporte a ACL em um sistema de arquivos não pode ser alterado enquanto o sistema estiver em uso.</p></li><li><p>Definir a flag de superbloco faz com que o sistema de arquivos seja sempre montado com a ACL ativada, mesmo que não haja uma entrada no <span class=filename>fstab</span> ou se os dispositivos forem reordenados. Isso evita a montagem acidental do sistema de arquivos sem o suporte a ACL.</p></li></ul></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>É desejável desencorajar a montagem acidental sem que a ACL esteja habilitada porque coisas desagradáveis podem acontecer se ACLs estiverem habilitadas, e então desabilitadas e então reativadas sem limpar os atributos estendidos. Em geral, uma vez que as ACLs forem habilitadas em um sistema de arquivos, elas não devem ser desabilitadas, pois as proteções de arquivos resultantes podem não ser compatíveis com aquelas pretendidas pelos usuários do sistema e ACLs reativadas podem reconectar as ACLs anteriores aos arquivos que tiveram suas permissões alteradas, resultando em um comportamento imprevisível.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Os sistemas de arquivos com a ACL ativada exibirão um sinal de mais (<code>+</code>) nas configurações de permissão:</p></div><div class="literalblock programlisting"><div class=content><pre>drwx------  2 robert  robert  512 Dec 27 11:54 private
drwxrwx---+ 2 robert  robert  512 Dec 23 10:57 directory1
drwxrwx---+ 2 robert  robert  512 Dec 22 10:20 directory2
drwxrwx---+ 2 robert  robert  512 Dec 27 11:57 directory3
drwxr-xr-x  2 robert  robert  512 Nov 10 11:54 public_html</pre></div></div><div class=paragraph><p>Neste exemplo, o <span class=filename>directory1</span>, <span class=filename>directory2</span> e <span class=filename>directory3</span> estão todos fazendo uso de ACLs, enquanto <span class=filename>public_html</span> não está.</p></div></div><div class=sect3><h4 id=_usando_acls>13.9.2. Usando ACLs<a class=anchor href=#_usando_acls></a></h4><div class=paragraph><p>As ACLs de um sistema de arquivos podem ser visualizadas usando <code>getfacl</code>. Por exemplo, para visualizar as configurações de ACL no arquivo <span class=filename>test</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% getfacl <span class=nb>test</span>
	<span class=c>#file:test</span>
	<span class=c>#owner:1001</span>
	<span class=c>#group:1001</span>
	user::rw-
	group::r--
	other::r--</code></pre></div></div><div class=paragraph><p>Para alterar as configurações de ACL neste arquivo, use <code>setfacl</code>. Para remover todos os ACLs atualmente definidos de um arquivo ou sistema de arquivos, inclua <code>-k</code>. No entanto, o método preferido é usar <code>-b</code>, pois ela deixa os campos básicos necessários para que as ACLs funcionem.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% setfacl <span class=nt>-k</span> <span class=nb>test</span></code></pre></div></div><div class=paragraph><p>Para modificar as entradas padrões das ACLs, use <code>-m</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% setfacl <span class=nt>-m</span> u:trhodes:rwx,group:web:r--,o::--- <span class=nb>test</span></code></pre></div></div><div class=paragraph><p>Neste exemplo, não havia entradas predefinidas, pois elas foram removidas pelo comando anterior. Este comando restaura as opções padrões e atribui as opções listadas. Se um usuário ou grupo for adicionado e não existir no sistema, um erro de <code>Invalid argument</code> será exibido.</p></div><div class=paragraph><p>Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=getfacl&amp;sektion=1&amp;format=html">getfacl(1)</a> e <a href="https://man.freebsd.org/cgi/man.cgi?query=setfacl&amp;sektion=1&amp;format=html">setfacl(1)</a> para maiores informações sobre as opções disponíveis para esses comandos.</p></div></div></div><div class=sect2><h3 id=security-pkg>13.10. Monitorando Problemas de Segurança de Terceiros<a class=anchor href=#security-pkg></a></h3><div class=paragraph><p>Nos últimos anos, o mundo da segurança fez muitas melhorias em como a avaliação de vulnerabilidades é tratada. A ameaça de invasão do sistema aumenta à medida que utilitários de terceiros são instalados e configurados para praticamente qualquer sistema operacional disponível atualmente.</p></div><div class=paragraph><p>A avaliação de vulnerabilidade é um fator importante na segurança. Enquanto o FreeBSD libera avisos para o sistema base, fazê-lo para cada utilitário de terceiros está além da capacidade do Projeto FreeBSD. Existe uma maneira de mitigar vulnerabilidades de terceiros e avisar os administradores sobre problemas de segurança conhecidos. Um utilitário do FreeBSD conhecido como pkg inclui opções explicitamente para este propósito.</p></div><div class=paragraph><p>O pkg pesquisa um banco de dados em busca de problemas de segurança. O banco de dados é atualizado e mantido pela equipe de segurança do FreeBSD e pelos desenvolvedores de ports.</p></div><div class=paragraph><p>Por favor, consulte as <a href=./#pkgng-intro>instruções</a> para instalar o pkg.</p></div><div class=paragraph><p>A instalação fornece arquivos de configuração do <a href="https://man.freebsd.org/cgi/man.cgi?query=periodic&amp;sektion=8&amp;format=html">periodic(8)</a> para manter o banco de dados de auditoria do pkg e fornece um método programático para mantê-lo atualizado . Esta funcionalidade é ativada se <code>daily_status_security_pkgaudit_enable</code> estiver definido como <code>YES</code> em <a href="https://man.freebsd.org/cgi/man.cgi?query=periodic.conf&amp;sektion=5&amp;format=html">periodic.conf(5)</a> . Certifique-se de que os e-mails de execução de segurança diários, que são enviados para a conta de e-mail do <code>root</code>, estejam sendo lidos.</p></div><div class=paragraph><p>Após a instalação e para auditar utilitários de terceiros como parte da Coleção de Ports a qualquer momento, um administrador pode optar por atualizar o banco de dados e visualizar as vulnerabilidades conhecidas dos pacotes instalados, invocando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg audit -F</span></code></pre></div></div><div class=paragraph><p>O pkg exibe as vulnerabilidades publicadas dos pacotes instalados:</p></div><div class="literalblock programlisting"><div class=content><pre>Affected package: cups-base-1.1.22.0_1
Type of problem: cups-base -- HPGL buffer overflow vulnerability.
Reference: &lt;https://www.FreeBSD.org/ports/portaudit/40a3bca2-6809-11d9-a9e7-0001020eed82.html&gt;

1 problem(s) in your installed packages found.

You are advised to update or deinstall the affected package(s) immediately.</pre></div></div><div class=paragraph><p>Ao apontar um navegador da web para a URL exibida, um administrador pode obter mais informações sobre a vulnerabilidade. Isto incluirá as versões afetadas, pela versão do port do FreeBSD, juntamente com outros sites que podem conter avisos de segurança.</p></div><div class=paragraph><p>O pkg é um poderoso utilitário e é extremamente útil quando acoplado com o <a class=package href=https://cgit.freebsd.org/ports/tree/ports-mgmt/portmaster/>ports-mgmt/portmaster</a>.</p></div></div><div class=sect2><h3 id=security-advisories>13.11. Avisos de Segurança do FreeBSD<a class=anchor href=#security-advisories></a></h3><div class=paragraph><p>Como muitos produtores de sistemas operacionais de qualidade, o Projeto FreeBSD tem uma equipe de segurança responsável por determinar a data de fim de vida (EoL) para cada versão do FreeBSD e para fornecer atualizações de segurança para versões suportadas que ainda não atingiram sua EoL. Mais informações sobre a equipe de segurança do FreeBSD e as versões suportadas estão disponíveis na <a href=https://www.FreeBSD.org/security>página de segurança do FreeBSD</a>.</p></div><div class=paragraph><p>Uma tarefa da equipe de segurança é responder às vulnerabilidades de segurança reportadas no sistema operacional FreeBSD. Quando uma vulnerabilidade é confirmada, a equipe de segurança verifica as etapas necessárias para corrigir a vulnerabilidade e atualiza o código-fonte com a correção. Em seguida, publica os detalhes como um "Aviso de Segurança". Os avisos de segurança são publicados no <a href=https://www.FreeBSD.org/security/advisories/>site do FreeBSD</a> e enviados para as listas de discussão <a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-security-notifications>freebsd-security-notifications</a>, <a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-security>freebsd-security</a>, e <a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-announce>freebsd-announce</a>.</p></div><div class=paragraph><p>Esta seção descreve o formato de um alerta de segurança do FreeBSD.</p></div><div class=sect3><h4 id=_formato_de_um_comunicado_de_segurança>13.11.1. Formato de um Comunicado de Segurança<a class=anchor href=#_formato_de_um_comunicado_de_segurança></a></h4><div class=paragraph><p>Aqui está um exemplo de um aviso de segurança do FreeBSD:</p></div><div class="literalblock programlisting"><div class=content><pre>=============================================================================
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA512

=============================================================================
FreeBSD-SA-14:04.bind                                       Security Advisory
                                                          The FreeBSD Project

Topic:          BIND remote denial of service vulnerability

Category:       contrib
Module:         bind
Announced:      2014-01-14
Credits:        ISC
Affects:        FreeBSD 8.x and FreeBSD 9.x
Corrected:      2014-01-14 19:38:37 UTC (stable/9, 9.2-STABLE)
                2014-01-14 19:42:28 UTC (releng/9.2, 9.2-RELEASE-p3)
                2014-01-14 19:42:28 UTC (releng/9.1, 9.1-RELEASE-p10)
                2014-01-14 19:38:37 UTC (stable/8, 8.4-STABLE)
                2014-01-14 19:42:28 UTC (releng/8.4, 8.4-RELEASE-p7)
                2014-01-14 19:42:28 UTC (releng/8.3, 8.3-RELEASE-p14)
CVE Name:       CVE-2014-0591

For general information regarding FreeBSD Security Advisories,
including descriptions of the fields above, security branches, and the
following sections, please visit &lt;URL:http://security.FreeBSD.org/&gt;.

I.   Background

BIND 9 is an implementation of the Domain Name System (DNS) protocols.
The named(8) daemon is an Internet Domain Name Server.

II.  Problem Description

Because of a defect in handling queries for NSEC3-signed zones, BIND can
crash with an &#34;INSIST&#34; failure in name.c when processing queries possessing
certain properties.  This issue only affects authoritative nameservers with
at least one NSEC3-signed zone.  Recursive-only servers are not at risk.

III. Impact

An attacker who can send a specially crafted query could cause named(8)
to crash, resulting in a denial of service.

IV.  Workaround

No workaround is available, but systems not running authoritative DNS service
with at least one NSEC3-signed zone using named(8) are not vulnerable.

V.   Solution

Perform one of the following:

1) Upgrade your vulnerable system to a supported FreeBSD stable or
release / security branch (releng) dated after the correction date.

2) To update your vulnerable system via a source code patch:

The following patches have been verified to apply to the applicable
FreeBSD release branches.

a) Download the relevant patch from the location below, and verify the
detached PGP signature using your PGP utility.

[FreeBSD 8.3, 8.4, 9.1, 9.2-RELEASE and 8.4-STABLE]
# fetch http://security.FreeBSD.org/patches/SA-14:04/bind-release.patch
# fetch http://security.FreeBSD.org/patches/SA-14:04/bind-release.patch.asc
# gpg --verify bind-release.patch.asc

[FreeBSD 9.2-STABLE]
# fetch http://security.FreeBSD.org/patches/SA-14:04/bind-stable-9.patch
# fetch http://security.FreeBSD.org/patches/SA-14:04/bind-stable-9.patch.asc
# gpg --verify bind-stable-9.patch.asc

b) Execute the following commands as root:

# cd /usr/src
# patch &lt; /path/to/patch

Recompile the operating system using buildworld and installworld as
described in &lt;URL:https://www.FreeBSD.org/handbook/makeworld.html&gt;.

Restart the applicable daemons, or reboot the system.

3) To update your vulnerable system via a binary patch:

Systems running a RELEASE version of FreeBSD on the i386 or amd64
platforms can be updated via the freebsd-update(8) utility:

# freebsd-update fetch
# freebsd-update install

VI.  Correction details

The following list contains the correction revision numbers for each
affected branch.

Branch/path                                                      Revision
- -------------------------------------------------------------------------
stable/8/                                                         r260646
releng/8.3/                                                       r260647
releng/8.4/                                                       r260647
stable/9/                                                         r260646
releng/9.1/                                                       r260647
releng/9.2/                                                       r260647
- -------------------------------------------------------------------------

To see which files were modified by a particular revision, run the
following command, replacing NNNNNN with the revision number, on a
machine with Subversion installed:

# svn diff -cNNNNNN --summarize svn://svn.freebsd.org/base

Or visit the following URL, replacing NNNNNN with the revision number:

&lt;URL:https://svnweb.freebsd.org/base?view=revision&amp;revision=NNNNNN&gt;

VII. References

&lt;URL:https://kb.isc.org/article/AA-01078&gt;

&lt;URL:http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-0591&gt;

The latest revision of this advisory is available at
&lt;URL:http://security.FreeBSD.org/advisories/FreeBSD-SA-14:04.bind.asc&gt;
-----BEGIN PGP SIGNATURE-----

iQIcBAEBCgAGBQJS1ZTYAAoJEO1n7NZdz2rnOvQP/2/68/s9Cu35PmqNtSZVVxVG
ZSQP5EGWx/lramNf9566iKxOrLRMq/h3XWcC4goVd+gZFrvITJSVOWSa7ntDQ7TO
XcinfRZ/iyiJbs/Rg2wLHc/t5oVSyeouyccqODYFbOwOlk35JjOTMUG1YcX+Zasg
ax8RV+7Zt1QSBkMlOz/myBLXUjlTZ3Xg2FXVsfFQW5/g2CjuHpRSFx1bVNX6ysoG
9DT58EQcYxIS8WfkHRbbXKh9I1nSfZ7/Hky/kTafRdRMrjAgbqFgHkYTYsBZeav5
fYWKGQRJulYfeZQ90yMTvlpF42DjCC3uJYamJnwDIu8OhS1WRBI8fQfr9DRzmRua
OK3BK9hUiScDZOJB6OqeVzUTfe7MAA4/UwrDtTYQ+PqAenv1PK8DZqwXyxA9ThHb
zKO3OwuKOVHJnKvpOcr+eNwo7jbnHlis0oBksj/mrq2P9m2ueF9gzCiq5Ri5Syag
Wssb1HUoMGwqU0roS8+pRpNC8YgsWpsttvUWSZ8u6Vj/FLeHpiV3mYXPVMaKRhVm
067BA2uj4Th1JKtGleox+Em0R7OFbCc/9aWC67wiqI6KRyit9pYiF3npph+7D5Eq
7zPsUdDd+qc+UTiLp3liCRp5w6484wWdhZO6wRtmUgxGjNkxFoNnX8CitzF8AaqO
UWWemqWuz3lAZuORQ9KX
=OQzQ
-----END PGP SIGNATURE-----</pre></div></div><div class=paragraph><p>Todo comunicado de segurança usa o seguinte formato:</p></div><div class=ulist><ul><li><p>Cada aviso de segurança é assinado pela chave PGP do Oficial de Segurança. A chave pública para o Oficial de Segurança pode ser verificada em <a href=./#pgpkeys>Chaves OpenPGP</a>.</p></li><li><p>O nome do alerta de segurança sempre começa com <code>FreeBSD-SA-</code> (para o FreeBSD Security Advisory), seguido pelo ano em formato de dois dígitos (<code>14:</code>), seguido pelo número de aviso para aquele ano (<code>04.</code>), seguido pelo nome do aplicativo ou subsistema afetado (<code>bind</code>). O comunicado mostrado aqui é o quarto comunicado de 2014 e afeta o BIND.</p></li><li><p>O campo <code>Topic</code> resume a vulnerabilidade.</p></li><li><p>O campo <code>Category</code> refere-se à parte afetada do sistema, que pode ser uma de <code>core</code>, <code>contrib</code>, ou <code>ports</code>. A categoria <code>core</code> significa que a vulnerabilidade afeta um componente principal do sistema operacional FreeBSD. A categoria <code>contrib</code> significa que a vulnerabilidade afeta um software incluído no FreeBSD, como o BIND. A categoria <code>ports</code> indica que a vulnerabilidade afeta um software disponível através da coleção de ports.</p></li><li><p>O campo <code>Module</code> refere-se ao local do componente. Neste exemplo, o módulo <code>bind</code> é afetado; Portanto, essa vulnerabilidade afeta um aplicativo instalado com o sistema operacional.</p></li><li><p>O campo <code>Announced</code> reflete a data em que o comunicado de segurança foi publicado. Isto significa que a equipe de segurança verificou que o problema existe e que um patch foi disponibilizado no repositório do código fonte do FreeBSD.</p></li><li><p>O campo <code>Credits</code> dá crédito ao indivíduo ou organização que encontrou a vulnerabilidade e a relatou.</p></li><li><p>O campo <code>Affects</code> explica quais versões do FreeBSD são afetadas por esta vulnerabilidade.</p></li><li><p>O campo <code>Corrected</code> indica a data, a hora, o deslocamento do horário e as releases que foram corrigidas. A seção entre parênteses mostra cada branch para a qual a correção foi mesclada e o número de versão da liberação correspondente dessa branch. O próprio identificador de release inclui o número da versão e, se apropriado, o nível do patch. O nível de correção é a letra <code>p</code> seguida de um número, indicando o número de seqüência do patch, permitindo que os usuários controlem quais patches já foram aplicados ao sistema.</p></li><li><p>O campo <code>CVE Name</code> lista o número de aviso, se existir, no banco de dados público <a href=http://cve.mitre.org>cve.mitre.org</a> de vulnerabilidades de segurança.</p></li><li><p>O campo <code>Background</code> fornece uma descrição do módulo afetado.</p></li><li><p>O campo <code>Problem Description</code> explica a vulnerabilidade. Isso pode incluir informações sobre o código defeituoso e como o utilitário pode ser usado de maneira mal-intencionada.</p></li><li><p>O campo <code>Impact</code> descreve o tipo de impacto que o problema pode ter em um sistema.</p></li><li><p>O campo <code>Workaround</code> indica se uma solução alternativa está disponível para os administradores do sistema que não podem corrigir imediatamente o sistema.</p></li><li><p>O campo <code>Solution</code> fornece as instruções para corrigir o sistema afetado. Este é um método testado e verificado passo a passo para obter um sistema corrigido e funcionando com segurança.</p></li><li><p>O campo <code>Correction Details</code> exibe cada branch do Subversion afetada com o número de revisão que contém o código corrigido.</p></li><li><p>O campo <code>References</code> oferece fontes de informações adicionais sobre a vulnerabilidade.</p></li></ul></div></div></div><div class=sect2><h3 id=security-accounting>13.12. Auditoria de Processo<a class=anchor href=#security-accounting></a></h3><div class=paragraph><p>A auditoria de processos é um método de segurança no qual um administrador pode controlar os recursos do sistema utilizados e sua alocação entre os usuários, fornecer monitoramento do sistema e controlar minimamente os comandos de um usuário.</p></div><div class=paragraph><p>A auditoria de processos tem pontos positivos e negativos. Um dos pontos positivos é que uma intrusão pode ser rastreada ao ponto de entrada. Um valor negativo é a quantidade de logs gerados pela contabilidade do processo e o espaço em disco necessário. Esta seção conduz um administrador pelos fundamentos da contabilidade de processo.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Se uma auditoria mais detalhada for necessária, consulte <a href=./#audit>Auditoria de Evento de Segurança</a>.</p></div></td></tr></tbody></table></div><div class=sect3><h4 id=_ativando_e_utilizando_a_auditoria_de_processos>13.12.1. Ativando e Utilizando a Auditoria de Processos<a class=anchor href=#_ativando_e_utilizando_a_auditoria_de_processos></a></h4><div class=paragraph><p>Antes de usar a auditoria de processos, ela deve ser ativada usando os seguintes comandos:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysrc accounting_enable=yes</span>
<span class=c># service accounting start</span></code></pre></div></div><div class=paragraph><p>As informações de auditoria são armazenadas em arquivos localizados em <span class=filename>/var/account</span>, que são criados automaticamente, se necessário, na primeira vez em que o serviço de auditoria é iniciado. Esses arquivos contêm informações confidenciais, incluindo todos os comandos executados por todos os usuários. O acesso de escrita aos arquivos é limitado ao <code>root</code> e o acesso de leitura é limitado ao <code>root</code> e aos membros do grupo <code>wheel</code>. Para também impedir que membros do grupo <code>wheel</code> leiam os arquivos, altere a permissão do diretório <span class=filename>/var/account</span> para permitir acesso apenas de <code>root</code>.</p></div><div class=paragraph><p>Uma vez ativada, a auditoria começará a rastrear informações, como estatísticas de CPU e comandos executados. Todos os logs auditados estão em um formato não legível que pode ser visualizado usando <code>sa</code>. Se executado sem nenhuma opção, o <code>sa</code> imprime informações relacionadas ao número de chamadas por usuário, o tempo total decorrido em minutos, o total de CPU e o tempo do usuário em minutos, e o número médio de operações de I/O. Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=sa&amp;sektion=8&amp;format=html">sa(8)</a> para obter a lista de opções disponíveis que controlam a saída.</p></div><div class=paragraph><p>Para exibir os comandos emitidos pelos usuários, use o <code>lastcomm</code>. Por exemplo, este comando imprime todo o uso do comando <code>ls</code> pelo usuário <code>trhodes</code> no terminal <code>ttyp1</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># lastcomm ls trhodes ttyp1</span></code></pre></div></div><div class=paragraph><p>Muitas outras opções úteis existem e são explicadas em <a href="https://man.freebsd.org/cgi/man.cgi?query=lastcomm&amp;sektion=1&amp;format=html">lastcomm(1)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=acct&amp;sektion=5&amp;format=html">acct(5)</a> e <a href="https://man.freebsd.org/cgi/man.cgi?query=sa&amp;sektion=8&amp;format=html">sa(8)</a>.</p></div></div></div><div class=sect2><h3 id=security-resourcelimits>13.13. Limites de Recursos<a class=anchor href=#security-resourcelimits></a></h3><div class=paragraph><p>O FreeBSD fornece vários métodos para um administrador limitar a quantidade de recursos do sistema que um indivíduo pode usar. As cotas de disco limitam a quantidade de espaço em disco disponível para os usuários. As cotas são discutidas em <a href=./#quotas>Cotas de Disco</a>.</p></div><div class=paragraph><p>Limites para outros recursos, como CPU e memória, podem ser definidos usando um arquivo simples ou um comando para configurar um banco de dados de limites de recursos. O método tradicional define classes de login editando o arquivo <span class=filename>/etc/login.conf</span>. Embora esse método ainda seja suportado, qualquer alteração requer um processo de várias etapas para editar esse arquivo, reconstruir o banco de dados de recursos, fazer as alterações necessárias no arquivo <span class=filename>/etc/master.passwd</span> e reconstruir o banco de dados de senhas. Isso pode se tornar demorado, dependendo do número de usuários a serem configurados.</p></div><div class=paragraph><p>O comando <code>rctl</code> pode ser usado para fornecer um método mais refinado para controlar limites de recursos. Esse comando suporta mais que limites de usuário, já que também pode ser usado para definir restrições de recursos em processos e jails.</p></div><div class=paragraph><p>Esta seção demonstra os dois métodos para controlar recursos, começando com o método tradicional.</p></div><div class=sect3><h4 id=users-limiting>13.13.1. Configurando Classes de Login<a class=anchor href=#users-limiting></a></h4><div class=paragraph><p>No método tradicional, as classes de login e os limites de recursos a serem aplicados a uma classe de login são definidos no arquivo <span class=filename>/etc/login.conf</span>. Cada conta de usuário pode ser atribuída a uma classe de login, onde <code>default</code> é a classe de login padrão. Cada classe de login possui um conjunto de recursos de login associados a ele. Um recurso de login é um par <code><em>name</em>=<em>value</em></code>, em que <em>name</em> é um identificador conhecido e <em>value</em> é uma string arbitrária que é processada de acordo, dependendo do <em>name</em>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Sempre que o arquivo <span class=filename>/etc/login.conf</span> for editado, o <span class=filename>/etc/login.conf.db</span> deve ser atualizado executando o seguinte comando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cap_mkdb /etc/login.conf</span></code></pre></div></div></td></tr></tbody></table></div><div class=paragraph><p>Os limites de recursos diferem dos recursos de login padrão de duas maneiras. Primeiro, para cada limite, existe um limite <em>soft</em> e um <em>hard</em>. Um limite soft pode ser ajustado pelo usuário ou aplicativo, mas não pode ser definido como superior ao limite hard. O limite hard pode ser baixado pelo usuário, mas só pode ser aumentado pelo root. Segundo, a maioria dos limites de recursos se aplica por processo a um usuário específico.</p></div><div class=paragraph><p><a href=#resource-limits>Limites de Recursos de Classe de Login</a> lista os limites de recursos mais usados. Todos os limites de recursos disponíveis e capabilities são descritos em detalhes em <a href="https://man.freebsd.org/cgi/man.cgi?query=login.conf&amp;sektion=5&amp;format=html">login.conf(5)</a>.</p></div><table id=resource-limits class="tableblock frame-none grid-all stretch"><caption class=title>Tabela 11. Limites de Recursos de Classe de Login</caption><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Limite de Recurso</th><th class="tableblock halign-left valign-top">Descrição</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>coredumpsize</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>O limite do tamanho de um arquivo core gerado por um programa é subordinado a outros limites de uso do disco, como <code>filesize</code> ou cotas de disco. Esse limite é frequentemente usado como um método menos severo de controle do consumo de espaço em disco. Como os usuários não geram arquivos core e geralmente não os excluem, essa configuração pode evitar que eles fiquem sem espaço em disco caso ocorra um grande travamento de programa.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>cputime</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>A quantidade máxima de tempo de CPU que o processo de um usuário pode consumir. Os processos ofensivos serão eliminados pelo kernel. Este é um limite no <em>tempo</em> de CPU consumido, não a porcentagem do CPU como exibido em alguns dos campos gerados pelo <code>top</code> e <code>ps</code>.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>filesize</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>O tamanho máximo de um arquivo que o usuário pode possuir. Ao contrário das cotas de disco (<a href=./#quotas>Cotas de Disco</a>), esse limite é imposto em arquivos individuais, não no conjunto de todos os arquivos que um usuário possui.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>maxproc</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>O número máximo de processos de primeiro plano e de plano de fundo que um usuário pode executar. Esse limite pode não ser maior que o limite do sistema especificado pela variável <code>kern.maxproc</code>. Definir um limite muito pequeno pode prejudicar a produtividade de um usuário, pois algumas tarefas, como compilar um programa grande, iniciam muitos processos.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>memorylocked</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>A quantidade máxima de memória que um processo pode solicitar para ser bloqueado na memória principal usando o <a href="https://man.freebsd.org/cgi/man.cgi?query=mlock&amp;sektion=2&amp;format=html">mlock(2)</a>. Alguns programas críticos do sistema, como <a href="https://man.freebsd.org/cgi/man.cgi?query=amd&amp;sektion=8&amp;format=html">amd(8)</a>, se bloqueiam na memória principal para que, se o sistema começar a fazer swap, eles não contribuam para surrar o disco.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>memoryuse</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>A quantidade máxima de memória que um processo pode consumir a qualquer momento. Inclui tanto a memória principal quanto o uso de swap. Este não é um limite geral para restringir o consumo de memória, mas é um bom começo.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>openfiles</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>O número máximo de arquivos que um processo pode ter aberto. No FreeBSD, os arquivos são usados para representar sockets e canais IPC, então tome cuidado para não definir isso muito baixo. O limite de todo o sistema para isso é definido por pela variável <code>kern.maxfiles</code>.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>sbsize</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>O limite na quantidade de memória de rede que um usuário pode consumir. Isso geralmente pode ser usado para limitar as comunicações da rede.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>stacksize</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>O tamanho máximo de uma pilha de processos. Isso por si só não é suficiente para limitar a quantidade de memória que um programa pode usar, por isso deve ser usado em conjunto com outros limites.</p></td></tr></tbody></table><div class=paragraph><p>Existem algumas outras coisas para se lembrar ao definir limites de recursos:</p></div><div class=ulist><ul><li><p>Os processos iniciados na inicialização do sistema pelo <span class=filename>/etc/rc</span> são atribuídos à classe <code>daemon</code> de login.</p></li><li><p>Embora o arquivo <span class=filename>/etc/login.conf</span> padrão seja uma boa fonte de valores razoáveis para a maioria dos limites, eles podem não ser apropriados para todos os sistemas. Definir um limite muito alto pode abrir o sistema para uso abusivo, enquanto que defini-lo como muito baixo pode prejudicar a produtividade.</p></li><li><p>O Xorg utiliza muitos recursos e incentiva os usuários a executarem mais programas simultaneamente.</p></li><li><p>Muitos limites se aplicam a processos individuais, não ao usuário como um todo. Por exemplo, definir a variável <code>openfiles</code> como <code>50</code> significa que cada processo que o usuário executa pode abrir até <code>50</code> arquivos. A quantidade total de arquivos que um usuário pode abrir é o valor de <code>openfiles</code> multiplicado pelo valor de <code>maxproc</code>. Isso também se aplica ao consumo de memória.</p></li></ul></div><div class=paragraph><p>Para mais informações sobre limites de recursos e classes de login e capacidades em geral, consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=cap_mkdb&amp;sektion=1&amp;format=html">cap_mkdb(1)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=getrlimit&amp;sektion=2&amp;format=html">getrlimit(2)</a> e <a href="https://man.freebsd.org/cgi/man.cgi?query=login.conf&amp;sektion=5&amp;format=html">login.conf(5)</a>.</p></div></div><div class=sect3><h4 id=_ativando_e_configurando_limites_de_recursos>13.13.2. Ativando e Configurando Limites de Recursos<a class=anchor href=#_ativando_e_configurando_limites_de_recursos></a></h4><div class=paragraph><p>A variável configurável <code>kern.racct.enable</code> deve ser configurada para um valor diferente de zero. Kernels personalizados requerem configuração específica:</p></div><div class="literalblock programlisting"><div class=content><pre>options         RACCT
options         RCTL</pre></div></div><div class=paragraph><p>Depois que o sistema for reinicializado no novo kernel, o <code>rctl</code> poderá ser usado para definir regras para o sistema.</p></div><div class=paragraph><p>A sintaxe da regra é controlada por meio do uso de um subject, subject-id, resource e action, conforme visto nesta regra de exemplo:</p></div><div class="literalblock programlisting"><div class=content><pre>user:trhodes:maxproc:deny=10/user</pre></div></div><div class=paragraph><p>Nesta regra, o subject é <code>user</code>, o subject-id é <code>trhodes</code>, o resource, <code>maxproc</code>, é o número máximo de processos, e a action é <code>deny</code>, que bloqueia a criação de novos processos. Isso significa que o usuário, <code>trhodes</code>, será restrito a execução de no máximo <code>10</code> processos. Outras ações possíveis incluem o registro no console, passando uma notificação para o <a href="https://man.freebsd.org/cgi/man.cgi?query=devd&amp;sektion=8&amp;format=html">devd(8)</a> ou enviando um sigterm para o processo.</p></div><div class=paragraph><p>Algum cuidado deve ser tomado ao adicionar regras. Como esse usuário está restrito a <code>10</code> processos, este exemplo impedirá que o usuário execute outras tarefas depois de efetuar login e executar uma sessão <code>screen</code>. Quando um limite de recurso for atingido, um erro será impresso, como neste exemplo:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% man <span class=nb>test</span>
    /usr/bin/man: Cannot fork: Resource temporarily unavailable
<span class=nb>eval</span>: Cannot fork: Resource temporarily unavailable</code></pre></div></div><div class=paragraph><p>Como outro exemplo, uma jail pode ser impedida de exceder um limite de memória. Esta regra pode ser escrita como:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># rctl -a jail:httpd:memoryuse:deny=2G/jail</span></code></pre></div></div><div class=paragraph><p>As regras persistirão durante as reinicializações se tiverem sido adicionadas ao arquivo <span class=filename>/etc/rctl.conf</span>. O formato é uma regra, sem o comando anterior. Por exemplo, a regra anterior pode ser adicionada como:</p></div><div class="literalblock programlisting"><div class=content><pre># Block jail from using more than 2G memory:
jail:httpd:memoryuse:deny=2G/jail</pre></div></div><div class=paragraph><p>Para remover uma regra, use o <code>rctl</code> para removê-la da lista:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># rctl -r user:trhodes:maxproc:deny=10/user</span></code></pre></div></div><div class=paragraph><p>Um método para remover todas as regras é documentado em <a href="https://man.freebsd.org/cgi/man.cgi?query=rctl&amp;sektion=8&amp;format=html">rctl(8)</a>. No entanto, se for necessário remover todas as regras para um único usuário, esse comando poderá ser emitido:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># rctl -r user:trhodes</span></code></pre></div></div><div class=paragraph><p>Existem muitos outros recursos que podem ser usados para exercer controle adicional sobre vários <code>subjects</code>. Veja <a href="https://man.freebsd.org/cgi/man.cgi?query=rctl&amp;sektion=8&amp;format=html">rctl(8)</a> para aprender sobre eles.</p></div></div></div><div class=sect2><h3 id=security-sudo>13.14. Administração Compartilhada com Sudo<a class=anchor href=#security-sudo></a></h3><div class=paragraph><p>Os administradores do sistema geralmente precisam conceder permissões avançadas aos usuários para que eles possam executar tarefas privilegiadas. A ideia de que os membros da equipe tenham acesso a um sistema FreeBSD para executar suas tarefas específicas abre desafios únicos para cada administrador. Esses membros da equipe precisam apenas de um subconjunto de acesso além dos níveis normais de usuário final; no entanto, eles quase sempre dizem ao gerenciadores que eles são incapazes de executar suas tarefas sem acesso de superusuário. Felizmente, não há motivo para fornecer tal acesso aos usuários finais porque existem ferramentas para gerenciar esse exato requisito.</p></div><div class=paragraph><p>Até este ponto, o capítulo de segurança cobriu o acesso a usuários autorizados e a tentativa de impedir o acesso não autorizado. Outro problema surge quando os usuários autorizados têm acesso aos recursos do sistema. Em muitos casos, alguns usuários podem precisar acessar os scripts de inicialização do aplicativo ou uma equipe de administradores precisa manter o sistema. Tradicionalmente, os usuários e grupos padrão, as permissões de arquivo e até mesmo o comando <a href="https://man.freebsd.org/cgi/man.cgi?query=su&amp;sektion=&amp;format=html">su()</a> gerenciariam esse acesso. E como os aplicativos exigiam mais acesso, à medida que mais usuários precisavam usar recursos do sistema, era necessária uma solução melhor. A aplicação mais usada atualmente é o Sudo.</p></div><div class=paragraph><p>O Sudo permite que os administradores configurem um acesso mais rígido aos comandos do sistema e forneçam alguns recursos avançados de log. Como uma ferramenta, ele está disponível na coleção de ports como <a class=package href=https://cgit.freebsd.org/ports/tree/security/sudo/>security/sudo</a> ou usando o utilitário <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg&amp;sektion=8&amp;format=html">pkg(8)</a>. Para usar a ferramenta <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg&amp;sektion=8&amp;format=html">pkg(8)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install sudo</span></code></pre></div></div><div class=paragraph><p>Após a conclusão da instalação, o <code>visudo</code> instalado abrirá o arquivo de configuração com um editor de texto. O uso do <code>visudo</code> é altamente recomendado, pois vem com um verificador de sintaxe incorporado para verificar se não há erros antes que o arquivo seja salvo.</p></div><div class=paragraph><p>O arquivo de configuração é composto de várias seções pequenas que permitem uma configuração extensiva. No exemplo a seguir, o mantenedor do aplicativo da web, user1, precisa iniciar, parar e reiniciar o aplicativo da web conhecido como <em>webservice</em>. Para conceder a este usuário permissão para executar estas tarefas, adicione esta linha ao final do arquivo <span class=filename>/usr/local/etc/sudoers</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>user1   ALL=(ALL)       /usr/sbin/service webservice *</pre></div></div><div class=paragraph><p>O usuário pode agora iniciar o <em>webservice</em> usando este comando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>sudo</span> /usr/sbin/service webservice start</code></pre></div></div><div class=paragraph><p>Embora essa configuração permita que um único usuário acesse o serviço webservice; No entanto, na maioria das organizações, existe uma equipe inteira da Web encarregada de gerenciar o serviço. Uma única linha também pode dar acesso a um grupo inteiro. Essas etapas criarão um grupo da Web, adicionarão um usuário a esse grupo e permitirão que todos os membros do grupo gerenciem o serviço:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pw groupadd -g 6001 -n webteam</span></code></pre></div></div><div class=paragraph><p>Usando o mesmo comando <a href="https://man.freebsd.org/cgi/man.cgi?query=pw&amp;sektion=8&amp;format=html">pw(8)</a>, o usuário é adicionado ao grupo webteam:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pw groupmod -m user1 -n webteam</span></code></pre></div></div><div class=paragraph><p>Finalmente, esta linha no arquivo <span class=filename>/usr/local/etc/sudoers</span> permite que qualquer membro do grupo webteam gerencie o <em>webservice</em>:</p></div><div class="literalblock programlisting"><div class=content><pre>%webteam   ALL=(ALL)       /usr/sbin/service webservice *</pre></div></div><div class=paragraph><p>Ao contrário do <a href="https://man.freebsd.org/cgi/man.cgi?query=su&amp;sektion=1&amp;format=html">su(1)</a>, o Sudo requer apenas a senha do usuário final. Isso adiciona uma vantagem em que os usuários não precisarão de senhas compartilhadas, uma descoberta na maioria das auditorias de segurança e o que por si só já ruins em todos os aspectos.</p></div><div class=paragraph><p>Os usuários autorizados a executar aplicativos com o Sudo só inserem suas próprias senhas. Isso é mais seguro e oferece melhor controle do que o <a href="https://man.freebsd.org/cgi/man.cgi?query=su&amp;sektion=1&amp;format=html">su(1)</a>, onde a senha de <code>root</code> é inserida e o usuário adquire todas as permissões de <code>root</code>.</p></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>A maioria das organizações está se movendo ou migrou para um modelo de autenticação de dois fatores. Nestes casos, o usuário pode não ter uma senha para entrar. O Sudo resolve estes casos com a variável <code>NOPASSWD</code>. Adicioná-lo à configuração acima permitirá que todos os membros do grupo <em>webteam</em> gerenciem o serviço sem o requisito de senha:</p></div><div class="literalblock programlisting"><div class=content><pre>%webteam   ALL=(ALL)       NOPASSWD: /usr/sbin/service webservice *</pre></div></div></td></tr></tbody></table></div><div class=sect3><h4 id=security-sudo-loggin>13.14.1. Logando a Saída<a class=anchor href=#security-sudo-loggin></a></h4><div class=paragraph><p>Uma vantagem para implementar o Sudo é a capacidade de ativar o log de sessão. Usando os mecanismos de log integrados e o comando sudoreplay incluído, todos os comandos iniciados por meio de Sudo são registrados para verificação posterior. Para ativar esse recurso, adicione uma entrada de diretório de log padrão, este exemplo usa uma variável de usuário. Existem várias outras convenções de nome de arquivo de log, consulte a página de manual do sudoreplay para obter informações adicionais.</p></div><div class="literalblock programlisting"><div class=content><pre>Defaults iolog_dir=/var/log/sudo-io/%{user}</pre></div></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Este diretório será criado automaticamente após o logging ser configurado. É melhor deixar o sistema criar o diretório com permissões padrão apenas para estar seguro. Além disso, essa entrada também registra os administradores que usam o comando sudoreplay. Para alterar esse comportamento, leia e descomente as opções de log dentro do arquivo <span class=filename>sudoers</span>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Uma vez que esta diretiva tenha sido adicionada ao arquivo <span class=filename>sudoers</span>, qualquer configuração de usuário pode ser atualizada com a solicitação para acessar o log. No exemplo mostrado, a entrada <em>webteam</em> atualizada teria as seguintes alterações adicionais:</p></div><div class="literalblock programlisting"><div class=content><pre>%webteam ALL=(ALL) NOPASSWD: LOG_INPUT: LOG_OUTPUT: /usr/sbin/service webservice *</pre></div></div><div class=paragraph><p>Deste ponto em diante, todos os membros do grupo <em>webteam</em> que alteram o status do aplicativo <em>webservice</em> serão registrados. A lista de sessões anteriores e atuais pode ser exibida com:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sudoreplay -l</span></code></pre></div></div><div class=paragraph><p>Na saída, para reproduzir uma sessão específica, procure a entrada <code>TSID=</code> e passe-a para o sudoreplay sem outras opções para reproduzir a sessão na velocidade normal. Por exemplo:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sudoreplay user1/00/00/02</span></code></pre></div></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Enquanto as sessões são registradas, qualquer administrador pode remover as sessões e deixar apenas uma questão de por que elas fizeram isso. Vale a pena adicionar uma verificação diária por meio de um sistema de detecção de intrusão (IDS) ou software semelhante para que outros administradores sejam alertados sobre alterações manuais.</p></div></td></tr></tbody></table></div><div class=paragraph><p>O <code>sudoreplay</code> é extremamente extensível. Consulte a documentação para mais informações.</p></div></div></div></div></div><div class=sect1><h2 id=jails>Capítulo 14. Jails<a class=anchor href=#jails></a></h2><div class=sectionbody><div class=sect2><h3 id=jails-synopsis>14.1. Sinopse<a class=anchor href=#jails-synopsis></a></h3><div class=paragraph><p>Como a administração de sistemas é uma tarefa difícil, muitas ferramentas foram desenvolvidas para facilitar a vida do administrador. Essas ferramentas geralmente aprimoram a maneira como os sistemas são instalados, configurados e mantidos. Uma das ferramentas que podem ser usadas para melhorar a segurança de um sistema FreeBSD é <em>jails</em>. Jails estão disponíveis desde o FreeBSD 4.X e continuam sendo aprimoradas em sua utilidade, desempenho, confiabilidade e segurança.</p></div><div class=paragraph><p>Jails são construídas em cima do conceito de <a href="https://man.freebsd.org/cgi/man.cgi?query=chroot&amp;sektion=2&amp;format=html">chroot(2)</a>, que é usado para mudar o diretório raiz de um conjunto de processos. Isso cria um ambiente seguro, separado do resto do sistema. Os processos criados no ambiente chroot não podem acessar arquivos ou recursos fora dele. E por esse motivo, comprometer um serviço em execução em um ambiente chroot não deve permitir que o invasor comprometa todo o sistema. No entanto, um chroot tem várias limitações. É adequado para tarefas fáceis que não exigem muita flexibilidade ou recursos complexos e avançados. Ao longo do tempo, foram descobertas muitas maneiras de escapar de um ambiente chroot, tornando essa solução como não sendo a melhor para proteger os serviços.</p></div><div class=paragraph><p>As jails aprimoram o conceito do ambiente chroot tradicional de várias maneiras. Em um ambiente chroot tradicional, os processos são limitados apenas na parte do sistema de arquivos que eles podem acessar. O restante dos recursos do sistema, os usuários, os processos em execução e o subsistema de rede são compartilhados pelos processos chroot e pelos processos do sistema host. As jails expandem esse modelo virtualizando o acesso ao sistema de arquivos, ao conjunto de usuários e ao subsistema de rede. Controles mais refinados estão disponíveis para ajustar o acesso de um ambiente em jail. As jails podem ser consideradas como um tipo de virtualização no nível do sistema operacional.</p></div><div class=paragraph><p>Uma jail é caracterizada por quatro elementos:</p></div><div class=ulist><ul><li><p>Uma subárvore de diretórios: o ponto de partida a partir do qual uma jail é inserida. Uma vez dentro da jail, não é permitido que um processo escape fora dessa subárvore.</p></li><li><p>Um nome de host: que será usado pela jail.</p></li><li><p>Um endereço IP: atribuído à jail. O endereço IP de uma jail é geralmente um endereço de alias de uma interface de rede existente.</p></li><li><p>Um comando: o nome do caminho de um executável para ser executado dentro da jail. O caminho é relativo ao diretório raiz do ambiente da jail.</p></li></ul></div><div class=paragraph><p>As Jails possuem seu próprio conjunto de usuários e sua própria conta de <code>root</code> que são limitados ao ambiente da jail. A conta <code>root</code> de uma jail não tem permissão para executar operações no sistema fora do ambiente da jail associada.</p></div><div class=paragraph><p>Este capítulo fornece uma visão geral da terminologia e dos comandos para gerenciar as jail do FreeBSD. As jails são uma ferramenta poderosa para administradores de sistemas e usuários avançados.</p></div><div class=paragraph><p>Depois de ler este capítulo, você saberá:</p></div><div class=ulist><ul><li><p>O que é uma jail e qual finalidade ela pode servir nas instalações do FreeBSD.</p></li><li><p>Como compilar, iniciar e parar uma jail.</p></li><li><p>Os fundamentos da administração de jails, tanto de dentro como fora da jail.</p></li></ul></div><div class="admonitionblock important"><table><tbody><tr><td class=icon><i class="fa icon-important" title=Important></i></td><td class=content><div class=paragraph><p>As jails são uma ferramenta poderosa, mas não são uma panaceia de segurança. Embora não seja possível que um processo rodando em jail burle a segurança por conta própria, existem várias maneiras pelas quais um usuário não privilegiado fora da jail pode cooperar com um usuário privilegiado dentro da jail para obter privilégios elevados no ambiente host.</p></div><div class=paragraph><p>A maioria desses ataques podem ser mitigados apenas garantindo que o root da jail não seja acessível a usuários não privilegiados no ambiente host. Como regra geral, usuários não confiáveis com acesso privilegiado a uma jail não devem ter acesso ao ambiente do host.</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=jails-terms>14.2. Termos Relacionados à Jails<a class=anchor href=#jails-terms></a></h3><div class=paragraph><p>Para facilitar a compreensão de partes do sistema FreeBSD relacionadas a jails, seus componentes internos e a maneira como eles interagem com o resto do FreeBSD, os seguintes termos são usados mais adiante neste capítulo:</p></div><div class=dlist><dl><dt class=hdlist1><a href="https://man.freebsd.org/cgi/man.cgi?query=chroot&amp;sektion=8&amp;format=html">chroot(8)</a> (comando)</dt><dd><p>Utilitário, que usa a chamada de sistema <a href="https://man.freebsd.org/cgi/man.cgi?query=chroot&amp;sektion=2&amp;format=html">chroot(2)</a> do FreeBSD para alterar o diretório raiz de um processo e todos os seus descendentes.</p></dd><dt class=hdlist1><a href="https://man.freebsd.org/cgi/man.cgi?query=chroot&amp;sektion=2&amp;format=html">chroot(2)</a> (ambiente)</dt><dd><p>O ambiente dos processos em execução em um "chroot". Isso inclui recursos como a parte do sistema de arquivos que é visível, IDs de usuário e grupo que estão disponíveis, interfaces de rede e outros mecanismos de IPC, etc.</p></dd><dt class=hdlist1><a href="https://man.freebsd.org/cgi/man.cgi?query=jail&amp;sektion=8&amp;format=html">jail(8)</a> (comando)</dt><dd><p>O utilitário de administração do sistema que permite o lançamento de processos dentro de um ambiente jail.</p></dd><dt class=hdlist1>host (sistema, processo, usuário, etc.)</dt><dd><p>O sistema de controle de um ambiente jail. O sistema host tem acesso a todos os recursos de hardware disponíveis e pode controlar processos fora e dentro de um ambiente jail. Uma das diferenças importantes do sistema host de uma jail é que as limitações que se aplicam aos processos de super-usuário dentro de uma jail não são aplicadas aos processos do sistema host.</p></dd><dt class=hdlist1>hosted (sistema, processo, usuário, etc.)</dt><dd><p>Um processo, usuário ou outra entidade, cujo acesso a recursos é restrito por uma jail do FreeBSD.</p></dd></dl></div></div><div class=sect2><h3 id=jails-build>14.3. Criando e Controlando Jails<a class=anchor href=#jails-build></a></h3><div class=paragraph><p>Alguns administradores dividem as jails nos dois seguintes tipos: jails "completa", que se assemelham a um sistema real do FreeBSD, e jails de "serviço", dedicados a um aplicativo ou serviço, possivelmente executando com privilégios. Esta é apenas uma divisão conceitual e o processo de criação de uma jail não é afetado por ela. Ao criar uma jail "completa", há duas opções para a origem do userland: usar binários pré-compilados (como aqueles fornecidos em uma mídia de instalação) ou compila-los a partir do código fonte.</p></div><div class=sect3><h4 id=_instalando_uma_jail>14.3.1. Instalando uma Jail<a class=anchor href=#_instalando_uma_jail></a></h4><div class=sect4><h5 id=jails-install-internet>14.3.1.1. Para instalar uma Jail pela Internet<a class=anchor href=#jails-install-internet></a></h5><div class=paragraph><p>A ferramenta <a href="https://man.freebsd.org/cgi/man.cgi?query=bsdinstall&amp;sektion=8&amp;format=html">bsdinstall(8)</a> pode ser usada para baixar e instalar os binários necessários para uma Jail. Será apresentando a seleção de um mirror, quais distribuições serão instaladas no diretório de destino e algumas configurações básicas da Jail:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># bsdinstall jail /here/is/the/jail</span></code></pre></div></div><div class=paragraph><p>Uma vez que o comando finalize, o próximo passo é configurar o host para rodar a jail.</p></div></div><div class=sect4><h5 id=jails-install-iso>14.3.1.2. Instalar uma Jail por uma imagem ISO<a class=anchor href=#jails-install-iso></a></h5><div class=paragraph><p>Para instalar o userland da mídia de instalação, primeiro crie o diretório raiz da jail. Isso pode ser feito definindo a variável <code>DESTDIR</code> para o local adequado.</p></div><div class=paragraph><p>Inicie um shell e defina a variável <code>DESTDIR</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sh</span>
<span class=c># export DESTDIR=/here/is/the/jail</span></code></pre></div></div><div class=paragraph><p>Monte a mídia de instalação como abordado em <a href="https://man.freebsd.org/cgi/man.cgi?query=mdconfig&amp;sektion=8&amp;format=html">mdconfig(8)</a> ao usar a ISO de instalação:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount -t cd9660 /dev/`mdconfig -f cdimage.iso` /mnt</span>
<span class=c># cd /mnt/usr/freebsd-dist/</span></code></pre></div></div><div class=paragraph><p>Extraia os binários dos tarballs na mídia de instalação dentro do destino declarado. Minimamente, apenas o conjunto base precisa ser extraído, mas uma instalação completa pode ser executada quando preferida.</p></div><div class=paragraph><p>Para instalar apenas o sistema básico:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># tar -xf /mnt/usr/freebsd-dist/base.txz -C $DESTDIR</span></code></pre></div></div><div class=paragraph><p>Para instalar tudo, exceto o kernel:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># for set in base ports; do tar -xf /mnt/usr/freebsd-dist/$set.txz -C $DESTDIR ; done</span></code></pre></div></div></div><div class=sect4><h5 id=jails-install-source>14.3.1.3. Para compilar e instalar uma Jail a partir do código fonte<a class=anchor href=#jails-install-source></a></h5><div class=paragraph><p>A página de manual <a href="https://man.freebsd.org/cgi/man.cgi?query=jail&amp;sektion=8&amp;format=html">jail(8)</a> explica o procedimento para compilar uma jail:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># setenv D /here/is/the/jail</span>
<span class=c># mkdir -p $D      </span><i class=conum data-value=1></i><b>(1)</b>
<span class=c># cd /usr/src</span>
<span class=c># make buildworld  </span><i class=conum data-value=2></i><b>(2)</b>
<span class=c># make installworld DESTDIR=$D  </span><i class=conum data-value=3></i><b>(3)</b>
<span class=c># make distribution DESTDIR=$D  </span><i class=conum data-value=4></i><b>(4)</b>
<span class=c># mount -t devfs devfs $D/dev   </span><i class=conum data-value=5></i><b>(5)</b></code></pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>Selecionar um local para uma jail é o melhor ponto de partida. É aqui que a jail residirá fisicamente no sistema de arquivos do host da jail. Uma boa opção pode ser <span class=filename>/usr/jail/jailname</span>, onde <em>jailname</em> é o nome do host que identifica a jail. Normalmente, <span class=filename>/usr/</span> tem espaço suficiente para o sistema de arquivos da jail, onde para jails "completa" é, essencialmente, uma replicação de todos os arquivos presentes em uma instalação padrão do sistema básico do FreeBSD.</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td>Se você já tiver recompilado seu userland usando <code>make world</code> ou <code>make buildworld</code>, você pode pular esta etapa e instalar seu userland existente na nova jail.</td></tr><tr><td><i class=conum data-value=3></i><b>3</b></td><td>Esse comando preencherá a sub-árvore de diretórios escolhida como o local físico da jail no sistema de arquivos com os binários, bibliotecas, páginas de manual e assim por diante.</td></tr><tr><td><i class=conum data-value=4></i><b>4</b></td><td>O target <code>distribuição</code> do make instala todos os arquivos de configuração necessários. Em palavras simples, ele instala cada arquivo instalável de <span class=filename>/usr/src/etc/</span> no diretório <span class=filename>/etc</span> do ambiente jail: <span class=filename>$D/etc/</span>.</td></tr><tr><td><i class=conum data-value=5></i><b>5</b></td><td>A montagem do sistema de arquivos <a href="https://man.freebsd.org/cgi/man.cgi?query=devfs&amp;sektion=8&amp;format=html">devfs(8)</a> dentro de uma jail não é necessária. Por outro lado, qualquer, ou quase qualquer aplicativo requer acesso a pelo menos um dispositivo, dependendo da finalidade do aplicativo fornecido. É muito importante controlar o acesso a dispositivos de dentro de uma jail, pois configurações inadequadas podem permitir que um invasor faça coisas desagradáveis na jail. O controle sobre <a href="https://man.freebsd.org/cgi/man.cgi?query=devfs&amp;sektion=8&amp;format=html">devfs(8)</a> é gerenciado por meio de conjuntos de regras que são descritos nas páginas de manual <a href="https://man.freebsd.org/cgi/man.cgi?query=devfs&amp;sektion=8&amp;format=html">devfs(8)</a> e <a href="https://man.freebsd.org/cgi/man.cgi?query=devfs.conf&amp;sektion=5&amp;format=html">devfs.conf(5)</a>.</td></tr></tbody></table></div></div></div><div class=sect3><h4 id=_configurando_o_host>14.3.2. Configurando o Host<a class=anchor href=#_configurando_o_host></a></h4><div class=paragraph><p>Uma vez que a jail é instalada, ela pode ser iniciada usando o utilitário <a href="https://man.freebsd.org/cgi/man.cgi?query=jail&amp;sektion=8&amp;format=html">jail(8)</a>. O utilitário <a href="https://man.freebsd.org/cgi/man.cgi?query=jail&amp;sektion=8&amp;format=html">jail(8)</a> possui quatro argumentos obrigatórios que são descritos em <a href=#jails-synopsis>Sinopse</a>. Outros argumentos podem ser especificados também, por exemplo, para executar o processo em jail com as credenciais de um usuário específico. O argumento de <code><em>command</em></code> depende do tipo de jail; para um <em>sistema virtual</em>, <span class=filename>/etc/rc</span> é uma boa escolha, já que ele irá replicar a sequência de inicialização de um sistema real do FreeBSD. Para uma jail de <em>serviço</em>, depende do serviço ou aplicativo que será executado dentro da jail.</p></div><div class=paragraph><p>As jails geralmente são iniciadas no boot e o mecanismo <span class=filename>rc</span> do FreeBSD fornece uma maneira fácil de fazer isso.</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Configure os parâmetros da jail no arquivo <span class=filename>jail.conf</span>:</p><div class="literalblock programlisting"><div class=content><pre>www {
    host.hostname = www.example.org;           # Hostname
    ip4.addr = 192.168.0.10;                   # IP address of the jail
    path =&#34;/usr/jail/www&#34;;                     # Path to the jail
    devfs_ruleset = &#34;www_ruleset&#34;;             # devfs ruleset
    mount.devfs;                               # Mount devfs inside the jail
    exec.start = &#34;/bin/sh /etc/rc&#34;;            # Start command
    exec.stop = &#34;/bin/sh /etc/rc.shutdown&#34;;    # Stop command
}</pre></div></div><div class=paragraph><p>Configure as jails para iniciar no boot no arquivo <span class=filename>rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>jail_enable=&#34;YES&#34;   # Set to NO to disable starting of any jails</pre></div></div><div class=paragraph><p>A inicialização padrão das jails configuradas no arquivo <a href="https://man.freebsd.org/cgi/man.cgi?query=jail.conf&amp;sektion=5&amp;format=html">jail.conf(5)</a>, executará o script <span class=filename>/etc/rc</span> da jail, que assume que a jail é um sistema virtual completo. Para jails de serviço, o comando de inicialização padrão da jail deve ser alterado, definindo a opção <code>exec.start</code> apropriadamente.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Para obter uma lista completa das opções disponíveis, consulte a página de manual <a href="https://man.freebsd.org/cgi/man.cgi?query=jail.conf&amp;sektion=5&amp;format=html">jail.conf(5)</a>.</p></div></td></tr></tbody></table></div></li></ol></div></div></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=service&amp;sektion=8&amp;format=html">service(8)</a> pode ser usado para iniciar ou parar uma jail manualmente, se uma entrada para ela existir no arquivo <span class=filename>jail.conf</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service jail start www</span>
<span class=c># service jail stop www</span></code></pre></div></div><div class=paragraph><p>As jails podem ser desligadas com o <a href="https://man.freebsd.org/cgi/man.cgi?query=jexec&amp;sektion=8&amp;format=html">jexec(8)</a>. Use <a href="https://man.freebsd.org/cgi/man.cgi?query=jls&amp;sektion=8&amp;format=html">jls(8)</a> para identificar o <code>JID</code> da jail e, em seguida, use <a href="https://man.freebsd.org/cgi/man.cgi?query=jexec&amp;sektion=8&amp;format=html">jexec(8)</a> para executar o script de desligamento nessa jail.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># jls</span>
   JID  IP Address      Hostname                      Path
     3  192.168.0.10    www                           /usr/jail/www
<span class=c># jexec 3 /etc/rc.shutdown</span></code></pre></div></div><div class=paragraph><p>Mais informações sobre isso podem ser encontradas na página de manual <a href="https://man.freebsd.org/cgi/man.cgi?query=jail&amp;sektion=8&amp;format=html">jail(8)</a>.</p></div></div></div><div class=sect2><h3 id=jails-tuning>14.4. Tuning e Administração<a class=anchor href=#jails-tuning></a></h3><div class=paragraph><p>Existem várias opções que podem ser configuradas para qualquer jail, e várias maneiras de combinar um sistema host FreeBSD com jails, para produzir aplicações de alto nível. Esta seção apresenta:</p></div><div class=ulist><ul><li><p>Algumas das opções disponíveis para ajustar as restrições de comportamento e segurança implementadas pela instalação de uma jail.</p></li><li><p>Alguns das aplicações de alto nível para gerenciamento de jail, que estão disponíveis através da Coleção de Ports do FreeBSD, e que podem ser usados para implementar soluções globais baseadas em jails.</p></li></ul></div><div class=sect3><h4 id=jails-tuning-utilities>14.4.1. Ferramentas de Sistema para Tuning de Jail no FreeBSD<a class=anchor href=#jails-tuning-utilities></a></h4><div class=paragraph><p>O tuning da configuração de uma jail é feito principalmente configurando variáveis <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a>. Uma sub-árvore especial do sysctl existe como base para organizar todas as opções relevantes: a hierarquia <code>security.jail.*</code> das opções do kernel do FreeBSD. Aqui está uma lista dos principais sysctls relacionados à jail, completas com seu valor padrão. Os nomes devem ser autoexplicativos, mas para obter mais informações sobre eles, consulte as páginas de manual <a href="https://man.freebsd.org/cgi/man.cgi?query=jail&amp;sektion=8&amp;format=html">jail(8)</a> e <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a>.</p></div><div class=ulist><ul><li><p><code>security.jail.set_hostname_allowed: 1</code></p></li><li><p><code>security.jail.socket_unixiproute_only: 1</code></p></li><li><p><code>security.jail.sysvipc_allowed: 0</code></p></li><li><p><code>security.jail.enforce_statfs: 2</code></p></li><li><p><code>security.jail.allow_raw_sockets: 0</code></p></li><li><p><code>security.jail.chflags_allowed: 0</code></p></li><li><p><code>security.jail.jailed: 0</code></p></li></ul></div><div class=paragraph><p>Estas variáveis podem ser usadas pelo administrador de sistemas do <em>sistema host</em> para adicionar ou remover algumas das limitações impostas por padrão no usuário <code>root</code>. Note que existem algumas limitações que não podem ser removidas. O usuário <code>root</code> não tem permissão para montar ou desmontar sistemas de arquivos de dentro de uma <a href="https://man.freebsd.org/cgi/man.cgi?query=jail&amp;sektion=8&amp;format=html">jail(8)</a>. O <code>root</code> dentro de uma jail não pode carregar ou descarregar conjuntos de regras <a href="https://man.freebsd.org/cgi/man.cgi?query=devfs&amp;sektion=8&amp;format=html">devfs(8)</a>, definir regras de firewall, ou fazer muitas outras tarefas administrativas que requerem modificações de dados no kernel, como a configuração do <code>securelevel</code> do kernel.</p></div><div class=paragraph><p>O sistema base do FreeBSD contém um conjunto básico de ferramentas para visualizar informações sobre as jails ativas e para se conectar a uma jail para executar comandos administrativos. Os comandos <a href="https://man.freebsd.org/cgi/man.cgi?query=jls&amp;sektion=8&amp;format=html">jls(8)</a> e <a href="https://man.freebsd.org/cgi/man.cgi?query=jexec&amp;sektion=8&amp;format=html">jexec(8)</a> são parte do sistema base do FreeBSD, e podem ser usados para realizar as seguintes tarefas simples:</p></div><div class=ulist><ul><li><p>Apresentar uma lista de jails ativas e seu identificador de jail correspondente (JID), endereço IP, hostname e path.</p></li><li><p>Se conectar a uma jail em execução, a partir de seu sistema host, e executar um comando dentro da jaijl ou executar tarefas administrativas dentro da própria jail. Isso é especialmente útil quando o usuário <code>root</code> deseja desligar de maneira limpa uma jail. O utilitário <a href="https://man.freebsd.org/cgi/man.cgi?query=jexec&amp;sektion=8&amp;format=html">jexec(8)</a> também pode ser usado para iniciar um shell em uma jail para administração; por exemplo:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># jexec 1 tcsh</span></code></pre></div></div></li></ul></div></div><div class=sect3><h4 id=jails-tuning-admintools>14.4.2. Ferramentas Administrativas de Alto Nível na Coleção de Ports do FreeBSD<a class=anchor href=#jails-tuning-admintools></a></h4><div class=paragraph><p>Entre os muitos utilitários de terceiros para administração de jail, um dos mais completos e úteis é o <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/ezjail/>sysutils/ezjail</a>. É um conjunto de scripts que contribuem para o gerenciamento de <a href="https://man.freebsd.org/cgi/man.cgi?query=jail&amp;sektion=8&amp;format=html">jail(8)</a>. Consulte a <a href=#jails-ezjail>seção ezjail do handbook</a> para mais informações.</p></div></div><div class=sect3><h4 id=jails-updating>14.4.3. Mantendo as Jails com Alterações e Atualizadas<a class=anchor href=#jails-updating></a></h4><div class=paragraph><p>As jails devem ser atualizadas a partir do sistema operacional do host, pois a tentativa de aplicar patchs no userland de dentro da jail pode falhar, já que o comportamento padrão no FreeBSD é não permitir o uso de <a href="https://man.freebsd.org/cgi/man.cgi?query=chflags&amp;sektion=1&amp;format=html">chflags(1)</a> em uma jail, o que impede a substituição de alguns arquivos. É possível alterar esse comportamento, mas é recomendado usar o <a href="https://man.freebsd.org/cgi/man.cgi?query=freebsd-update&amp;sektion=8&amp;format=html">freebsd-update(8)</a> para atualizar as jails. Use <code>-b</code> para especificar o caminho da jail a ser atualizada.</p></div><div class=paragraph><p>Para atualizar a Jail para o último release patch da versão do FreeBSD que já está em execução, execute os seguintes comandos no host:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># freebsd-update -b /here/is/the/jail fetch</span>
<span class=c># freebsd-update -b /here/is/the/jail install</span></code></pre></div></div><div class=paragraph><p>Para atualizar a jail para uma versão maior ou menor, primeiro atualize o sistema hospedeiro com descrito em <a href=./#freebsdupdate-upgrade>Realizando Upgrades de Versão Principais e Menores</a>. Uma vez que o hospedeiro esteja atualizado e reiniciado, a jail pode então ser atualizada. Por exemplo, para atualizar de 12.0-RELEASE para 12.1-RELEASE, rode no hospedeiro:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># freebsd-update -b /here/is/the/jail --currently-running 12.0-RELEASE -r 12.1-RELEASE upgrade</span>
<span class=c># freebsd-update -b /here/is/the/jail install</span>
<span class=c># service jail restart myjail</span>
<span class=c># freebsd-update -b /here/is/the/jail install</span></code></pre></div></div><div class=paragraph><p>Então, se foi uma atualização de versão principal, reinstale todos os pacotes instalados e reinicie a jail novamente. Isso é necessário porque a versão ABI muda ao atualizar entre as versões principais do FreeBSD. Pelo host:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg -j myjail upgrade -f</span>
<span class=c># service jail restart myjail</span></code></pre></div></div></div></div><div class=sect2><h3 id=jails-application>14.5. Atualizando Múltiplas Jails<a class=anchor href=#jails-application></a></h3><div class=paragraph><p>O gerenciamento de várias jails pode se tornar problemático porque toda jail tem que ser recompilada a partir do zero sempre que for atualizada. Isso pode ser demorado e entediante se muitas jails forem criadas e atualizadas manualmente.</p></div><div class=paragraph><p>Esta seção demonstra um método para resolver esse problema compartilhando com segurança o máximo possível entre jails usando montagens somente leitura <a href="https://man.freebsd.org/cgi/man.cgi?query=mount_nullfs&amp;sektion=8&amp;format=html">mount_nullfs(8)</a>, para que a atualização seja mais simples. Isso torna mais atraente colocar serviços únicos, como HTTP, DNS e SMTP, em jails individuais. Além disso, fornece uma maneira simples de adicionar, remover e atualizar jails.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Existem soluções mais simples, como o ezjail, que fornece um método mais fácil de administrar as jails do FreeBSD, mas é menos versátil que essa configuração. O ezjail é coberto com mais detalhes em <a href=#jails-ezjail>Gerenciando Jails com o ezjail</a>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Os objetivos da configuração descrita nesta seção são:</p></div><div class=ulist><ul><li><p>Criar uma estrutura de jail simples e fácil de entender que não exija a execução de um installworld completo em todas as jails.</p></li><li><p>Facilitar a adição de novas jails ou remoção das já existentes.</p></li><li><p>Facilitar a atualização ou upgrade de jails existentes.</p></li><li><p>Tornar possível a utilização de uma branch customizada do FreeBSD.</p></li><li><p>Seja paranoico com a segurança, reduzindo ao máximo a possibilidade de comprometimento.</p></li><li><p>Economize espaço e inodes, tanto quanto possível.</p></li></ul></div><div class=paragraph><p>Esse design depende de um template master único, read-only, que é montado em cada jail e em um dispositivo read-write por jail. Um dispositivo pode ser um disco físico separado, uma partição ou um dispositivo de memória com suporte a vnode. Este exemplo usa montagens nullfs read-write.</p></div><div class=paragraph><p>O layout do sistema de arquivos é o seguinte:</p></div><div class=ulist><ul><li><p>As jails são hospedadas na partição <span class=filename>/home</span>.</p></li><li><p>Cada jail será montada no diretório <span class=filename>/home/j</span>.</p></li><li><p>O template para cada jail e a partição read-only para todos as jails é <span class=filename>/home/j/mroot</span>.</p></li><li><p>Um diretório em branco será criado para cada jail no diretório <span class=filename>/home/j</span>.</p></li><li><p>Cada jail terá um diretório <span class=filename>/s</span> que será vinculado à parte de read-write do sistema.</p></li><li><p>Cada jail terá seu próprio sistema de read-write baseado em <span class=filename>/home/j/skel</span>.</p></li><li><p>A parte de read-write de cada jail será criada em <span class=filename>/home/js</span>.</p></li></ul></div><div class=sect3><h4 id=jails-service-jails-template>14.5.1. Criando o Template<a class=anchor href=#jails-service-jails-template></a></h4><div class=paragraph><p>Esta seção descreve as etapas necessárias para criar o template master.</p></div><div class=paragraph><p>É recomendado primeiramente atualizar o sistema host FreeBSD para a branch -RELEASE mais recente usando as instruções em <a href=./#makeworld>Atualizando o FreeBSD a partir do código fonte</a>. Adicionalmente, este template usa o pacote ou port <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/cpdup/>sysutils/cpdup</a> e o portsnap será utilizado para baixar a Coleção de Ports do FreeBSD.</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Primeiro, crie uma estrutura de diretório para o sistema de arquivo read-only que conterá os binários do FreeBSD para as jails. Em seguida, altere para o diretório de código-fonte do FreeBSD e instale o sistema de arquivos read-only no template das jails:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mkdir /home/j /home/j/mroot</span>
<span class=c># cd /usr/src</span>
<span class=c># make installworld DESTDIR=/home/j/mroot</span></code></pre></div></div></li><li><p>Em seguida, prepare uma Coleção de Ports do FreeBSD para as jails, assim como uma árvore de código fonte do FreeBSD, que são necessários para o mergemaster:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /home/j/mroot</span>
<span class=c># mkdir usr/ports</span>
<span class=c># portsnap -p /home/j/mroot/usr/ports fetch extract</span>
<span class=c># cpdup /usr/src /home/j/mroot/usr/src</span></code></pre></div></div></li><li><p>Crie um esqueleto para a parte de read-write do sistema:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mkdir /home/j/skel /home/j/skel/home /home/j/skel/usr-X11R6 /home/j/skel/distfiles</span>
<span class=c># mv etc /home/j/skel</span>
<span class=c># mv usr/local /home/j/skel/usr-local</span>
<span class=c># mv tmp /home/j/skel</span>
<span class=c># mv var /home/j/skel</span>
<span class=c># mv root /home/j/skel</span></code></pre></div></div></li><li><p>Use o mergemaster para instalar os arquivos de configuração ausentes. Em seguida, remova os diretórios extras criados pelo mergemaster:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mergemaster -t /home/j/skel/var/tmp/temproot -D /home/j/skel -i</span>
<span class=c># cd /home/j/skel</span>
<span class=c># rm -R bin boot lib libexec mnt proc rescue sbin sys usr dev</span></code></pre></div></div></li><li><p>Agora, faça os links dos sistema de arquivos read-write ao sistema de arquivos read-only. Certifique-se de que os links simbólicos sejam criados nos locais corretos de <span class=filename>s/</span>, pois a criação de diretórios nos locais errados fará com que a instalação falhe.</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /home/j/mroot</span>
<span class=c># mkdir s</span>
<span class=c># ln -s s/etc etc</span>
<span class=c># ln -s s/home home</span>
<span class=c># ln -s s/root root</span>
<span class=c># ln -s ../s/usr-local usr/local</span>
<span class=c># ln -s ../s/usr-X11R6 usr/X11R6</span>
<span class=c># ln -s ../../s/distfiles usr/ports/distfiles</span>
<span class=c># ln -s s/tmp tmp</span>
<span class=c># ln -s s/var var</span></code></pre></div></div></li><li><p>Como último passo, crie um arquivo <span class=filename>/home/j/skel/etc/make.conf</span> genérico contendo esta linha:</p><div class="literalblock programlisting"><div class=content><pre>WRKDIRPREFIX?=  /s/portbuild</pre></div></div><div class=paragraph><p>Isto torna possível compilar ports do FreeBSD dentro de cada jail. Lembre-se de que o diretório do ports faz parte do sistema somente leitura. O caminho customizado para o <code>WRKDIRPREFIX</code> permite que compilações sejam feitas na parte read-write de cada jail.</p></div></li></ol></div></div></div></div><div class=sect3><h4 id=jails-service-jails-creating>14.5.2. Criando Jails<a class=anchor href=#jails-service-jails-creating></a></h4><div class=paragraph><p>O template jail agora pode ser usado para preparar e configurar as jails no arquivo <span class=filename>/etc/rc.conf</span>. Este exemplo demonstra a criação de 3 jails: <code>NS</code>, <code>MAIL</code> e <code>WWW</code>.</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Adicione as seguintes linhas ao arquivo <span class=filename>/etc/fstab</span>, para que o template read-only e o espaço read-write das jails estejam disponível nas respectivas jails:</p><div class="literalblock programlisting"><div class=content><pre>/home/j/mroot   /home/j/ns     nullfs  ro  0   0
/home/j/mroot   /home/j/mail   nullfs  ro  0   0
/home/j/mroot   /home/j/www    nullfs  ro  0   0
/home/js/ns     /home/j/ns/s   nullfs  rw  0   0
/home/js/mail   /home/j/mail/s nullfs  rw  0   0
/home/js/www    /home/j/www/s  nullfs  rw  0   0</pre></div></div><div class=paragraph><p>Para evitar que o fsck verifique as montagens nullfs durante a inicialização e o dump faça backup das montagens nullfs read-only das jails, as duas últimas colunas são ambos definidos para <code>0</code>.</p></div></li><li><p>Configure as jails no arquivo <span class=filename>/etc/rc.conf</span>:</p><div class="literalblock programlisting"><div class=content><pre>jail_enable=&#34;YES&#34;
jail_set_hostname_allow=&#34;NO&#34;
jail_list=&#34;ns mail www&#34;
jail_ns_hostname=&#34;ns.example.org&#34;
jail_ns_ip=&#34;192.168.3.17&#34;
jail_ns_rootdir=&#34;/usr/home/j/ns&#34;
jail_ns_devfs_enable=&#34;YES&#34;
jail_mail_hostname=&#34;mail.example.org&#34;
jail_mail_ip=&#34;192.168.3.18&#34;
jail_mail_rootdir=&#34;/usr/home/j/mail&#34;
jail_mail_devfs_enable=&#34;YES&#34;
jail_www_hostname=&#34;www.example.org&#34;
jail_www_ip=&#34;62.123.43.14&#34;
jail_www_rootdir=&#34;/usr/home/j/www&#34;
jail_www_devfs_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>A variável <code>jail_name_rootdir</code> é configurada como <span class=filename>/usr/home</span> em vez de <span class=filename>/home</span> porque o caminho físico de <span class=filename>/home</span> em uma instalação padrão do FreeBSD é <span class=filename>/usr/home</span>. A variável <code>jail_name_rootdir</code> <em>não</em> deve ser configurada para um caminho que inclua um link simbólico, caso contrário as jails não serão iniciadas.</p></div></li><li><p>Crie os pontos de montagem necessários para o sistema de arquivos read-only de cada jail:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mkdir /home/j/ns /home/j/mail /home/j/www</span></code></pre></div></div></li><li><p>Instale o template read-write em cada jail usando <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/cpdup/>sysutils/cpdup</a>:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mkdir /home/js</span>
<span class=c># cpdup /home/j/skel /home/js/ns</span>
<span class=c># cpdup /home/j/skel /home/js/mail</span>
<span class=c># cpdup /home/j/skel /home/js/www</span></code></pre></div></div></li><li><p>Nesta fase, as jails estão compiladas e preparadas para execução. Primeiro, monte os sistemas de arquivos necessários para cada jail e, em seguida, inicie-as:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount -a</span>
<span class=c># service jail start</span></code></pre></div></div></li></ol></div></div></div><div class=paragraph><p>As jails devem estar funcionando agora. Para verificar se eles foram iniciadas corretamente, use <code>jls</code>. Sua saída deve ser semelhante ao seguinte:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># jls</span>
   JID  IP Address      Hostname                      Path
     3  192.168.3.17    ns.example.org                /home/j/ns
     2  192.168.3.18    mail.example.org              /home/j/mail
     1  62.123.43.14    www.example.org               /home/j/www</code></pre></div></div><div class=paragraph><p>Neste ponto, deve ser possível entrar em cada jail, adicionar novos usuários ou configurar daemons. A coluna <code>JID</code> indica o número de identificação da jail de cada jail em execução. Use o seguinte comando para executar tarefas administrativas na jail cujo JID é <code>3</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># jexec 3 tcsh</span></code></pre></div></div></div><div class=sect3><h4 id=jails-service-jails-upgrading>14.5.3. Fazendo Upgrade<a class=anchor href=#jails-service-jails-upgrading></a></h4><div class=paragraph><p>O design dessa configuração fornece uma maneira fácil de atualizar as jails existentes, minimizando o tempo de downtime. Além disso, fornece uma maneira de reverter para a versão mais antiga, caso ocorra algum problema.</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>O primeiro passo é atualizar o sistema host. Em seguida, crie um novo template temporário read-only em <span class=filename>/home/j/mroot2</span>.</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mkdir /home/j/mroot2</span>
<span class=c># cd /usr/src</span>
<span class=c># make installworld DESTDIR=/home/j/mroot2</span>
<span class=c># cd /home/j/mroot2</span>
<span class=c># cpdup /usr/src usr/src</span>
<span class=c># mkdir s</span></code></pre></div></div><div class=paragraph><p>O <code>installworld</code> cria alguns diretórios desnecessários, que devem ser removidos:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># chflags -R 0 var</span>
<span class=c># rm -R etc var root usr/local tmp</span></code></pre></div></div></li><li><p>Recrie os links simbólicos read-write para o sistema de arquivos master:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ln -s s/etc etc</span>
<span class=c># ln -s s/root root</span>
<span class=c># ln -s s/home home</span>
<span class=c># ln -s ../s/usr-local usr/local</span>
<span class=c># ln -s ../s/usr-X11R6 usr/X11R6</span>
<span class=c># ln -s s/tmp tmp</span>
<span class=c># ln -s s/var var</span></code></pre></div></div></li><li><p>Em seguida, pare as jails:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service jail stop</span></code></pre></div></div></li><li><p>Desmonte os sistemas de arquivos originais, pois os sistemas read-write estão conectados ao sistema read-only (<span class=filename>/s</span>):</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># umount /home/j/ns/s</span>
<span class=c># umount /home/j/ns</span>
<span class=c># umount /home/j/mail/s</span>
<span class=c># umount /home/j/mail</span>
<span class=c># umount /home/j/www/s</span>
<span class=c># umount /home/j/www</span></code></pre></div></div></li><li><p>Mova o antigo sistema de arquivos read-only e substitua-o pelo novo. Isso servirá como backup e arquivamento do antigo sistema de arquivos read-only se algo der errado. A convenção de nomenclatura usada aqui corresponde a quando um novo sistema de arquivos read-only foi criado. Mova a Coleção de Ports do FreeBSD original para o novo sistema de arquivos para economizar espaço e inodes:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /home/j</span>
<span class=c># mv mroot mroot.20060601</span>
<span class=c># mv mroot2 mroot</span>
<span class=c># mv mroot.20060601/usr/ports mroot/usr</span></code></pre></div></div></li><li><p>Neste ponto, o novo template read-only está pronto, então a única tarefa restante é remontar os sistemas de arquivos e iniciar as jails:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount -a</span>
<span class=c># service jail start</span></code></pre></div></div></li></ol></div></div></div><div class=paragraph><p>Use <code>jls</code> para verificar se as jails foram iniciadas corretamente. Execute <code>mergemaster</code> em cada jail para atualizar os arquivos de configuração.</p></div></div></div><div class=sect2><h3 id=jails-ezjail>14.6. Gerenciando Jails com o ezjail<a class=anchor href=#jails-ezjail></a></h3><div class=paragraph><p>Criar e gerenciar múltiplas jails pode se tornar um trabalho tedioso e propenso a erros. O ezjail de Dirk Engling automatiza e simplifica muito as tarefas de jails. Uma <em>basejail</em> é criada como um template. Jails adicionais usam <a href="https://man.freebsd.org/cgi/man.cgi?query=mount_nullfs&amp;sektion=8&amp;format=html">mount_nullfs(8)</a> para compartilhar muitos dos diretórios da basejail sem usar espaço em disco adicional. Cada jail adicional leva apenas alguns megabytes de espaço em disco antes que os aplicativos sejam instalados. A atualização da cópia do userland na basejail atualiza automaticamente todas as outras jails.</p></div><div class=paragraph><p>Benefícios e recursos adicionais são descritos em detalhes no site do ezjail, <a href=https://erdgeist.org/arts/software/ezjail/ class=bare>https://erdgeist.org/arts/software/ezjail/</a>.</p></div><div class=sect3><h4 id=jails-ezjail-install>14.6.1. Instalando o ezjail<a class=anchor href=#jails-ezjail-install></a></h4><div class=paragraph><p>A instalação do ezjail consiste na inclusão de uma interface de loopback para uso nas jails, instalação do port ou pacote e ativação do serviço.</p></div><div id=jails-ezjail-install-procedure class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Para manter o tráfego de loopback da jail fora da interface de rede de loopback do host <code>lo0</code>, uma segunda interface de loopback é criada adicionando uma entrada no arquivo <span class=filename>/etc/rc.conf</span>:</p><div class="literalblock programlisting"><div class=content><pre>cloned_interfaces=&#34;lo1&#34;</pre></div></div><div class=paragraph><p>A segunda interface de loopback <code>lo1</code> será criada quando o sistema for iniciado. Também pode ser criado manualmente sem reiniciar:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service netif cloneup</span>
Created clone interfaces: lo1.</code></pre></div></div><div class=paragraph><p>Jails podem ter permissão para usar aliases dessa interface de loopback secundária sem interferir no host.</p></div><div class=paragraph><p>Dentro de uma jail, o acesso ao endereço de loopback <code>127.0.0.1</code> é redirecionado para o primeiro endereço de IP atribuído à jail. Para fazer com que o loopback da jail corresponda à nova interface <code>lo1</code>, essa interface deve ser especificada primeiro na lista de interfaces e endereços IP fornecidos ao criar uma nova jail.</p></div><div class=paragraph><p>Dê a cada jail um endereço de loopback exclusivo no bloco de rede <code>127.0.0.0/8</code>.</p></div></li><li><p>Instale o <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/ezjail/>sysutils/ezjail</a>:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/sysutils/ezjail</span>
<span class=c># make install clean</span></code></pre></div></div></li><li><p>Ative o ezjail adicionando esta linha ao arquivo <span class=filename>/etc/rc.conf</span>:</p><div class="literalblock programlisting"><div class=content><pre>ezjail_enable=&#34;YES&#34;</pre></div></div></li><li><p>O serviço será iniciado automaticamente na inicialização do sistema. Ele pode ser iniciado imediatamente na sessão atual:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service ezjail start</span></code></pre></div></div></li></ol></div></div></div></div><div class=sect3><h4 id=jails-ezjail-initialsetup>14.6.2. Configuração inicial<a class=anchor href=#jails-ezjail-initialsetup></a></h4><div class=paragraph><p>Com o ezjail instalado, a estrutura do diretório basejail pode ser criada e preenchida. Esta etapa é necessária apenas uma vez no computador host da jail.</p></div><div class=paragraph><p>Em ambos os exemplos, <code>-p</code> faz com que a árvore de ports seja baixada com o <a href="https://man.freebsd.org/cgi/man.cgi?query=portsnap&amp;sektion=8&amp;format=html">portsnap(8)</a> para a basejail. Essa cópia única do diretório de ports será compartilhada por todas as jails. Usar uma cópia separada do diretório de ports para jails isola-os do host. O ezjail é explicado com mais detalhes no FAQ: <a href=http://erdgeist.org/arts/software/ezjail/#FAQ class=bare>http://erdgeist.org/arts/software/ezjail/#FAQ</a>.</p></div><div id=jails-ezjail-initialsetup-procedure class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Preencher a Jail com o FreeBSD-RELEASE</p><div class=paragraph><p>Para uma basejail baseada na mesma versão FreeBSD RELEASE do computador host, use o comando <code>install</code>. Por exemplo, em um computador host executando o FreeBSD 10-STABLE, a versão mais recente do FreeBSD -10 será instalada na jail:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ezjail-admin install -p</span></code></pre></div></div></li><li><p>Preencher a Jail com o comando <code>installworld</code></p><div class=paragraph><p>A basejail pode ser instalada a partir de binários criados pelo <code>buildworld</code> no host com <code>ezjail-admin update</code>.</p></div><div class=paragraph><p>Neste exemplo, o FreeBSD 10-STABLE foi compilado a partir do código fonte. Os diretórios da jail são criados. E então <code>installworld</code> é executado, instalando o <span class=filename>/usr/obj</span> do host na basejail.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ezjail-admin update -i -p</span></code></pre></div></div><div class=paragraph><p>O <span class=filename>/usr/src</span> do host é usado por padrão. Um diretório de código fonte diferente no host pode ser especificado com <code>-s</code> e um caminho ou com <code>ezjail_sourcetree</code> em <span class=filename>/usr/local/etc/ezjail.conf</span>.</p></div></li></ol></div></div></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>A árvore de ports da basejail é compartilhada por outras jails. No entanto, os distfiles baixados são armazenados na jail que os baixou. Por padrão, esses arquivos são armazenados em <span class=filename>/var/ports/distfiles</span> dentro de cada jail. <span class=filename>/var/ports</span> dentro de cada jail também é usado como um diretório de trabalho ao compilar ports.</p></div></td></tr></tbody></table></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>O protocolo FTP é usado por padrão para baixar pacotes para a instalação da basejail. Configurações de firewall ou proxy podem impedir ou interferir nas transferências de FTP. O protocolo HTTP funciona de maneira diferente e evita esses problemas. Ele pode ser escolhido especificando uma URL completa para um espelho de download específico no arquivo <span class=filename>/usr/local/etc/ezjail.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>ezjail_ftphost=http://ftp.FreeBSD.org</pre></div></div><div class=paragraph><p>Veja <a href=./#mirrors-ftp>Sites de FTP</a> para uma lista de sites.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=jails-ezjail-create>14.6.3. Criando e Iniciando uma Nova Jail<a class=anchor href=#jails-ezjail-create></a></h4><div class=paragraph><p>Novas jails são criadas com o comando <code>ezjail-admin create</code>. Nestes exemplos, a interface de loopback <code>lo1</code> é usada conforme descrito acima.</p></div><div id=jails-ezjail-create-steps class="exampleblock procedure"><div class=content><div class=paragraph><p><strong>Procedure: Crie e Inicie uma Nova Jail</strong></p></div><div class="olist arabic"><ol class=arabic><li><p>Crie a jail, especificando um nome e as interfaces de loopback e de rede a serem usadas, junto com seus endereços IP. Neste exemplo, a jail é denominada <code>dnsjail</code>.</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> ezjail-admin create dnsjail <span class=s1>&#39;lo1|127.0.1.1,em0|192.168.1.50&#39;</span></code></pre></div></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>A maioria dos serviços de rede são executados em jails sem problemas. Alguns serviços de rede, como <a href="https://man.freebsd.org/cgi/man.cgi?query=ping&amp;sektion=8&amp;format=html">ping(8)</a>, usam <em>raw network sockets</em>. Nas jails, raw network sockets são desativados por padrão para segurança. Serviços que exigem eles não irão funcionar.</p></div><div class=paragraph><p>Ocasionalmente, uma jail pode realmente precisar de raw sockets. Por exemplo, os aplicativos de monitoramento de rede geralmente usam <a href="https://man.freebsd.org/cgi/man.cgi?query=ping&amp;sektion=8&amp;format=html">ping(8)</a> para verificar a disponibilidade de outros computadores. Quando raw network sockets são realmente necessários em uma jail, eles podem ser ativados editando o arquivo de configuração do ezjail para uma jail individual, <span class=filename>/usr/local/etc/ezjail/jailname</span>. Modifique a entrada <code>parameters</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>export jail_jailname_parameters=&#34;allow.raw_sockets=1&#34;</pre></div></div><div class=paragraph><p>Não habilite raw network sockets, a menos que os serviços na jail realmente precisem deles.</p></div></td></tr></tbody></table></div></li><li><p>Inicie a jail:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ezjail-admin start dnsjail</span></code></pre></div></div></li><li><p>Use um console na jail:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ezjail-admin console dnsjail</span></code></pre></div></div></li></ol></div></div></div><div class=paragraph><p>A jail está funcionando e configurações adicionais podem ser realizadas. Configurações típicas adicionadas neste momento incluem:</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Defina a Senha de <code>root</code></p><div class=paragraph><p>Conecte-se à jail e configure a senha do usuário <code>root</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ezjail-admin console dnsjail</span>
<span class=c># passwd</span>
Changing <span class=nb>local </span>password <span class=k>for </span>root
New Password:
Retype New Password:</code></pre></div></div></li><li><p>Configuração de Fuso Horário</p><div class=paragraph><p>O fuso horário da jail pode ser definido com <a href="https://man.freebsd.org/cgi/man.cgi?query=tzsetup&amp;sektion=8&amp;format=html">tzsetup(8)</a>. Para evitar mensagens de erro espúrias, a entrada <a href="https://man.freebsd.org/cgi/man.cgi?query=adjkerntz&amp;sektion=8&amp;format=html">adjkerntz(8)</a> em <span class=filename>/etc/crontab</span> pode ser comentada ou removida. Este comando tenta atualizar o relógio de hardware do computador com alterações de fuso horário, mas as jails não têm permissão para acessar esse hardware.</p></div></li><li><p>Servidores DNS</p><div class=paragraph><p>Insira as linhas com o servidor de nomes de domínio no arquivo <span class=filename>/etc/resolv.conf</span> para que o DNS funcione na jail.</p></div></li><li><p>Edite o arquivo <span class=filename>/etc/hosts</span></p><div class=paragraph><p>Altere o endereço e adicione o nome da jail para as entradas <code>localhost</code> no <span class=filename>/etc/hosts</span>.</p></div></li><li><p>Configure o arquivo <span class=filename>/etc/rc.conf</span></p><div class=paragraph><p>Digite as definições de configuração no arquivo <span class=filename>/etc/rc.conf</span>. Isso é muito parecido com a configuração de um computador completo. O nome do host e o endereço IP não estão definidos aqui. Esses valores já são fornecidos pela configuração da jail.</p></div></li></ol></div></div></div><div class=paragraph><p>Com a jail configurada, os aplicativos para os quais a jail foi criada podem ser instalados.</p></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Alguns ports devem ser compilados com opções especiais para serem usados em uma jail. Por exemplo, os dois pacotes de plugin de monitoramento de rede <a class=package href=https://cgit.freebsd.org/ports/tree/net-mgmt/nagios-plugins/>net-mgmt/nagios-plugins</a> e <a class=package href=https://cgit.freebsd.org/ports/tree/net-mgmt/monitoring-plugins/>net-mgmt/monitoring-plugins</a> possuem uma opção <code>JAIL</code> que deve ser ativada para que funcionem corretamente dentro de uma jail.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=jails-ezjail-update>14.6.4. Atualizando as Jails<a class=anchor href=#jails-ezjail-update></a></h4><div class=sect4><h5 id=jails-ezjail-update-os>14.6.4.1. Atualizando o Sistema Operacional<a class=anchor href=#jails-ezjail-update-os></a></h5><div class=paragraph><p>Como a cópia do userland da basejail é compartilhada pelas outras jails, a atualização da basejail atualiza automaticamente todas as outras jails. Atualizações binárias ou por código fonte podem ser usadas.</p></div><div class=paragraph><p>Para compilar o world a partir do código fonte no host, e depois instala-lo na basejail, use:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ezjail-admin update -b</span></code></pre></div></div><div class=paragraph><p>Se o world já estiver sido compilado no host, instale-o no basejail com:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ezjail-admin update -i</span></code></pre></div></div><div class=paragraph><p>Atualizações binárias usam o <a href="https://man.freebsd.org/cgi/man.cgi?query=freebsd-update&amp;sektion=8&amp;format=html">freebsd-update(8)</a>. Essas atualizações têm as mesmas limitações como se o <a href="https://man.freebsd.org/cgi/man.cgi?query=freebsd-update&amp;sektion=8&amp;format=html">freebsd-update(8)</a> estivesse sendo executado diretamente. O mais importante é que apenas as versões -RELEASE do FreeBSD estão disponíveis com este método.</p></div><div class=paragraph><p>Atualize a basejail para a última versão de patchs da versão do FreeBSD no host. Por exemplo, atualizando de RELEASE-p1 para RELEASE-p2.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ezjail-admin update -u</span></code></pre></div></div><div class=paragraph><p>Para atualizar a basejail para uma nova versão, primeiro atualize o sistema host como descrito em <a href=./#freebsdupdate-upgrade>Realizando Upgrades de Versão Principais e Menores</a>. Depois que o host tiver sido atualizado e reinicializado, a basejail poderá ser atualizada. O <a href="https://man.freebsd.org/cgi/man.cgi?query=freebsd-update&amp;sektion=8&amp;format=html">freebsd-update(8)</a> não tem como determinar qual versão está atualmente instalada na basejail, então a versão original deve ser especificada. Use o <a href="https://man.freebsd.org/cgi/man.cgi?query=file&amp;sektion=1&amp;format=html">file(1)</a> para determinar a versão original na basejail:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># file /usr/jails/basejail/bin/sh</span>
/usr/jails/basejail/bin/sh: ELF 64-bit LSB executable, x86-64, version 1 <span class=o>(</span>FreeBSD<span class=o>)</span>, dynamically linked <span class=o>(</span>uses shared libs<span class=o>)</span>, <span class=k>for </span>FreeBSD 9.3, stripped</code></pre></div></div><div class=paragraph><p>Agora use essas informações para executar a atualização de <code>9.3-RELEASE</code> para a versão atual do sistema host:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ezjail-admin update -U -s 9.3-RELEASE</span></code></pre></div></div><div class=paragraph><p>Depois de atualizar a basejail, o <a href="https://man.freebsd.org/cgi/man.cgi?query=mergemaster&amp;sektion=8&amp;format=html">mergemaster(8)</a> deve ser executado para atualizar os arquivos de configuração de cada jail.</p></div><div class=paragraph><p>Como usar o <a href="https://man.freebsd.org/cgi/man.cgi?query=mergemaster&amp;sektion=8&amp;format=html">mergemaster(8)</a> depende do propósito e da confiabilidade de uma jail. Se os serviços ou usuários de uma jail não são confiáveis, então o <a href="https://man.freebsd.org/cgi/man.cgi?query=mergemaster&amp;sektion=8&amp;format=html">mergemaster(8)</a> deve ser executado somente dentro dessa jail:</p></div><div id=jails-ezjail-update-mergemaster-untrusted class=exampleblock><div class=title>Exemplo 33. <a href="https://man.freebsd.org/cgi/man.cgi?query=mergemaster&amp;sektion=8&amp;format=html">mergemaster(8)</a> em Jail Não Confiável</div><div class=content><div class=paragraph><p>Exclua o link do <span class=filename>/usr/src</span> da jail para a basejail e crie um novo <span class=filename>/usr/src</span> na jail como um ponto de montagem. Monte o <span class=filename>/usr/src</span> do computador host como read-only no novo ponto de montagem <span class=filename>/usr/src</span> da jail:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># rm /usr/jails/jailname/usr/src</span>
<span class=c># mkdir /usr/jails/jailname/usr/src</span>
<span class=c># mount -t nullfs -o ro /usr/src /usr/jails/jailname/usr/src</span></code></pre></div></div><div class=paragraph><p>Execute um console na jail:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ezjail-admin console jailname</span></code></pre></div></div><div class=paragraph><p>Dentro da jail, execute <code>mergemaster</code>. Em seguida, saia do console da jail:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/src</span>
<span class=c># mergemaster -U</span>
<span class=c># exit</span></code></pre></div></div><div class=paragraph><p>Finalmente, desmonte o <span class=filename>/usr/src</span> da jail:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># umount /usr/jails/jailname/usr/src</span></code></pre></div></div></div></div><div id=jails-ezjail-update-mergemaster-trusted class=exampleblock><div class=title>Exemplo 34. <a href="https://man.freebsd.org/cgi/man.cgi?query=mergemaster&amp;sektion=8&amp;format=html">mergemaster(8)</a> em Jail Confiável</div><div class=content><div class=paragraph><p>Se os usuários e serviços em uma jail forem confiáveis, o <a href="https://man.freebsd.org/cgi/man.cgi?query=mergemaster&amp;sektion=8&amp;format=html">mergemaster(8)</a> pode ser executado a partir do host:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mergemaster -U -D /usr/jails/jailname</span></code></pre></div></div></div></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Após uma atualização de versão principal, é recomendado pelo <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/ezjail/>sysutils/ezjail</a> garantir que o <code>pkg</code> seja da versão correta. Portanto, digite:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg-static upgrade -f pkg</span></code></pre></div></div><div class=paragraph><p>para atualizar ou fazer o downgrade para a versão apropriada.</p></div></td></tr></tbody></table></div></div><div class=sect4><h5 id=jails-ezjail-update-ports>14.6.4.2. Atualizando o Ports<a class=anchor href=#jails-ezjail-update-ports></a></h5><div class=paragraph><p>A árvore de ports na basejail é compartilhada pelas outras jails. A atualização dessa cópia da árvore de ports fornece às outras jails a versão atualizada também.</p></div><div class=paragraph><p>A árvore de ports da basejail é atualizada com o <a href="https://man.freebsd.org/cgi/man.cgi?query=portsnap&amp;sektion=8&amp;format=html">portsnap(8)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ezjail-admin update -P</span></code></pre></div></div></div></div><div class=sect3><h4 id=jails-ezjail-control>14.6.5. Controlando as Jails<a class=anchor href=#jails-ezjail-control></a></h4><div class=sect4><h5 id=jails-ezjail-control-stop-start>14.6.5.1. Parando e Iniciando Jails<a class=anchor href=#jails-ezjail-control-stop-start></a></h5><div class=paragraph><p>O ezjail inicia automaticamente as jails quando o computador é iniciado. As jails podem ser manualmente paradas e reiniciadas com <code>stop</code> e <code>start</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ezjail-admin stop sambajail</span>
Stopping jails: sambajail.</code></pre></div></div><div class=paragraph><p>Por padrão, as jails são iniciadas automaticamente quando o computador host é iniciado. A inicialização automática pode ser desativada com <code>config</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ezjail-admin config -r norun seldomjail</span></code></pre></div></div><div class=paragraph><p>Isso entrará em vigor na próxima vez em que o computador host for iniciado. Uma jail que já está em execução não será interrompida.</p></div><div class=paragraph><p>A ativação do início automático é muito semelhante:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ezjail-admin config -r run oftenjail</span></code></pre></div></div></div><div class=sect4><h5 id=jails-ezjail-control-backup>14.6.5.2. Arquivando e Restaurando Jails<a class=anchor href=#jails-ezjail-control-backup></a></h5><div class=paragraph><p>Use <code>archive</code> para criar um arquivo <span class=filename>.tar.gz</span> de uma jail. O nome do arquivo é composto pelo nome da jail e pela data atual. Os archives são gravados no diretório de archive, <span class=filename>/usr/jails/ezjail_archives</span>. Um diretório de archive diferente pode ser escolhido configurando <code>ezjail_archivedir</code> no arquivo de configuração.</p></div><div class=paragraph><p>O archive pode ser copiado em outro lugar como um backup, ou uma jail existente pode ser restaurada a partir dele com o <code>restore</code>. Uma nova jail pode ser criada a partir de um archive, fornecendo uma maneira conveniente de clonar as jails existentes.</p></div><div class=paragraph><p>Pare e arquive uma jail chamada <code>wwwserver</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ezjail-admin stop wwwserver</span>
Stopping jails: wwwserver.
<span class=c># ezjail-admin archive wwwserver</span>
<span class=c># ls /usr/jails/ezjail-archives/</span>
wwwserver-201407271153.13.tar.gz</code></pre></div></div><div class=paragraph><p>Crie uma nova jail chamada <code>wwwserver-clone</code> do archive criado na etapa anterior. Use a interface <span class=filename>em1</span> e atribua um novo endereço IP para evitar conflito com a original:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ezjail-admin create -a /usr/jails/ezjail_archives/wwwserver-201407271153.13.tar.gz wwwserver-clone &#39;lo1|127.0.3.1,em1|192.168.1.51&#39;</span></code></pre></div></div></div></div><div class=sect3><h4 id=jails-ezjail-example-bind>14.6.6. Exemplo Completo: BIND em uma Jail<a class=anchor href=#jails-ezjail-example-bind></a></h4><div class=paragraph><p>Colocar o servidor DNSBIND em uma jail melhora a segurança ao isolá-lo. Este exemplo cria um servidor de nomes de cache simples.</p></div><div class=ulist><ul><li><p>A jail será chamada de <code>dns1</code>.</p></li><li><p>A jail usará o endereço IP <code>192.168.1.240</code> na interface <code>re0</code> do host.</p></li><li><p>Os servidores DNS de upstream do ISP são <code>10.0.0.62</code> e <code>10.0.0.61</code>.</p></li><li><p>A basejail já foi criada e uma árvore de ports instalada como mostrado em <a href=#jails-ezjail-initialsetup>Configuração inicial</a>.</p></li></ul></div><div id=jails-ezjail-example-bind-steps class=exampleblock><div class=title>Exemplo 35. Executando o BIND em uma Jail</div><div class=content><div class=paragraph><p>Crie uma interface de loopback clonada adicionando uma linha ao arquivo <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>cloned_interfaces=&#34;lo1&#34;</pre></div></div><div class=paragraph><p>Imediatamente crie a nova interface de loopback:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service netif cloneup</span>
Created clone interfaces: lo1.</code></pre></div></div><div class=paragraph><p>Crie a jail:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ezjail-admin create dns1 &#39;lo1|127.0.2.1,re0|192.168.1.240&#39;</span></code></pre></div></div><div class=paragraph><p>Inicie a jail, conecte-se a ao seu console e realize algumas configurações básicas:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ezjail-admin start dns1</span>
<span class=c># ezjail-admin console dns1</span>
<span class=c># passwd</span>
Changing <span class=nb>local </span>password <span class=k>for </span>root
New Password:
Retype New Password:
<span class=c># tzsetup</span>
<span class=c># sed -i .bak -e &#39;/adjkerntz/ s/^/#/&#39; /etc/crontab</span>
<span class=c># sed -i .bak -e &#39;s/127.0.0.1/127.0.2.1/g; s/localhost.my.domain/dns1.my.domain dns1/&#39; /etc/hosts</span></code></pre></div></div><div class=paragraph><p>Configure temporariamente os servidores upstream de DNS no arquivo <span class=filename>/etc/resolv.conf</span> para que os ports possam ser baixados:</p></div><div class="literalblock programlisting"><div class=content><pre>nameserver 10.0.0.62
nameserver 10.0.0.61</pre></div></div><div class=paragraph><p>Ainda usando o console da jail, instale o <a class=package href=https://cgit.freebsd.org/ports/tree/dns/bind99/>dns/bind99</a>.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># make -C /usr/ports/dns/bind99 install clean</span></code></pre></div></div><div class=paragraph><p>Configure o servidor de nomes editando o arquivo <span class=filename>/usr/local/etc/namedb/named.conf</span>.</p></div><div class=paragraph><p>Crie uma Access Control List (ACL) de endereços e redes que têm permissão para enviar consultas DNS para este servidor de nomes. Esta seção é adicionada logo antes da seção <code>options</code> no arquivo:</p></div><div class="literalblock programlisting"><div class=content><pre>...
// or cause huge amounts of useless Internet traffic.

acl &#34;trusted&#34; {
	192.168.1.0/24;
	localhost;
	localnets;
};

options {
...</pre></div></div><div class=paragraph><p>Use o endereço IP da jail na configuração <code>listen-on</code> para aceitar consultas DNS de outros computadores na rede:</p></div><div class="literalblock programlisting"><div class=content><pre>	listen-on	{ 192.168.1.240; };</pre></div></div><div class=paragraph><p>Um servidor DNS de nomes para cache simples é criado alterando a seção <code>forwarders</code>. O arquivo original contém:</p></div><div class="literalblock programlisting"><div class=content><pre>/*
	forwarders {
		127.0.0.1;
	};
*/</pre></div></div><div class=paragraph><p>Descomente a seção removendo as linhas <code>/<strong></strong></code><strong> e <code></code></strong><code>/</code>. Digite os endereços IP dos servidores DNS upstream. Logo após a seção <code>forwarders</code>, adicione referências à <code>trusted</code> ACL definida anteriormente:</p></div><div class="literalblock programlisting"><div class=content><pre>	forwarders {
		10.0.0.62;
		10.0.0.61;
	};

	allow-query       { any; };
	allow-recursion   { trusted; };
	allow-query-cache { trusted; };</pre></div></div><div class=paragraph><p>Ative o serviço no arquivo <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>named_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Inicie e teste o servidor de nomes:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service named start</span>
wrote key file <span class=s2>&#34;/usr/local/etc/namedb/rndc.key&#34;</span>
Starting named.
<span class=c># /usr/local/bin/dig @192.168.1.240 freebsd.org</span></code></pre></div></div><div class=paragraph><p>Uma resposta que inclui</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=p>;;</span> Got answer<span class=p>;</span></code></pre></div></div><div class=paragraph><p>mostra que o novo servidor DNS está funcionando. Um longo delay seguido por uma resposta incluindo</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=p>;;</span> connection timed out<span class=p>;</span> no servers could be reached</code></pre></div></div><div class=paragraph><p>mostra um problema. Verifique as definições de configuração e certifique-se de que quaisquer firewalls locais permitam que o novo DNS acesse os servidores upstream de DNS.</p></div><div class=paragraph><p>O novo servidor DNS pode usar pra resolução de nomes seu próprio serviço, assim como outros computadores locais. Defina o endereço do servidor DNS no arquivo <span class=filename>/etc/resolv.conf</span> do computador-cliente:</p></div><div class="literalblock programlisting"><div class=content><pre>nameserver 192.168.1.240</pre></div></div><div class=paragraph><p>Um servidor DHCP local pode ser configurado para fornecer este endereço como servidor de DNS local, fornecendo configuração automática em clientes DHCP.</p></div></div></div></div></div></div></div><div class=sect1><h2 id=mac>Capítulo 15. Controle de acesso obrigatório<a class=anchor href=#mac></a></h2><div class=sectionbody><div class=sect2><h3 id=mac-synopsis>15.1. Sinopse<a class=anchor href=#mac-synopsis></a></h3><div class=paragraph><p>O FreeBSD suporta extensões de segurança baseadas no projeto POSIX™.1e. Esses mecanismos de segurança incluem as Listas de Controle de Acesso do sistema de arquivos (<a href=./#fs-acl>Listas de Controle de Acesso</a>) e o Controle de Acesso Obrigatório, (Mandatory Access Control - MAC). O MAC permite que os módulos de controle de acesso sejam carregados para implementar políticas de segurança. Alguns módulos fornecem proteções para um subconjunto restrito do sistema, fortalecendo um serviço específico. Outros fornecem segurança rotulada abrangente em todos os assuntos e objetos. A parte obrigatória da definição indica que a imposição de controles é executada pelos administradores e pelo sistema operacional. Isso está em contraste com o mecanismo de segurança padrão do Controle de Acesso Discricionário (Discretionary Access Control - DAC), onde a imposição é deixada a critério dos usuários.</p></div><div class=paragraph><p>Este capítulo enfoca o framework MAC e o conjunto de módulos de política de segurança plugáveis que o FreeBSD fornece para habilitar vários mecanismos de segurança.</p></div><div class=paragraph><p>Depois de ler este capítulo, você saberá:</p></div><div class=ulist><ul><li><p>A terminologia associada ao framework MAC.</p></li><li><p>Os recursos dos módulos de política de segurança MAC, bem como a diferença entre uma política rotulada e não rotulada.</p></li><li><p>As considerações a se levar em conta antes de configurar um sistema para usar o framework MAC.</p></li><li><p>Quais módulos de política de segurança MAC estão incluídos no FreeBSD e como configurá-los.</p></li><li><p>Como implementar um ambiente mais seguro usando o framework MAC.</p></li><li><p>Como testar a configuração para garantir que o framework MAC foi implementado corretamente.</p></li></ul></div><div class=paragraph><p>Antes de ler este capítulo, você deve:</p></div><div class=ulist><ul><li><p>Entender os fundamentos do UNIX™ e do FreeBSD (<a href=./#basics>Fundamentos do FreeBSD</a>).</p></li><li><p>Ter alguma familiaridade com segurança e como ela está presente no FreeBSD (<a href=./#security>Segurança</a>).</p></li></ul></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>A configuração incorreta do MAC pode causar perda de acesso ao sistema, agravamento de usuários, ou incapacidade de acessar os recursos fornecidos pelo Xorg. Mais importante, o MAC não deve ser usado para proteger completamente um sistema. O framework MAC apenas aumenta uma política de segurança existente. Sem práticas de segurança sólidas e verificações regulares de segurança, o sistema nunca estará completamente seguro.</p></div><div class=paragraph><p>Os exemplos contidos neste capítulo são para fins de demonstração e os exemplos de configurações <em>não</em> devem ser implementadas em um sistema de produção. A implementação de qualquer política de segurança requer um bom entendimento, design adequado e testes completos.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Embora este capítulo abranja uma ampla gama de questões de segurança relacionadas à estrututa MAC, o desenvolvimento de novos módulos de políticas de segurança MAC não serão abrangidos. Vários módulos de política de segurança incluídos com o framework MAC possuem características específicas que são fornecidas tanto para o teste quanto para o desenvolvimento de novos módulos. Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_test&amp;sektion=4&amp;format=html">mac_test(4)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_stub&amp;sektion=4&amp;format=html">mac_stub(4)</a> e <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_none&amp;sektion=4&amp;format=html">mac_none(4)</a> para obter mais informações sobre esses módulos de política de segurança e os diversos mecanismos que eles fornecem.</p></div></div><div class=sect2><h3 id=mac-inline-glossary>15.2. Termos chave<a class=anchor href=#mac-inline-glossary></a></h3><div class=paragraph><p>Os seguintes termos chave são usados ao se referir ao framework MAC:</p></div><div class=ulist><ul><li><p><em>compartment</em>: um conjunto de programas e dados a serem particionados ou separados, onde os usuários recebem acesso explícito ao componente específico de um sistema. Um compartimento (compartment) representa um agrupamento, como um grupo de trabalho, departamento, projeto ou tópico. Os compartimentos possibilitam a implementação de uma política de segurança baseada na necessidade de conhecimento.</p></li><li><p><em>integrity</em>: o nível de confiança que pode ser colocado nos dados. Como a integridade (integrity) dos dados é elevada, também aumenta a capacidade de confiar nesses dados.</p></li><li><p><em>level</em>: a configuração aumentada ou diminuída de um atributo de segurança. À medida que o nível (level) aumenta, sua segurança também é considerada alta.</p></li><li><p><em>label</em>: um atributo de segurança que pode ser aplicado a arquivos, diretórios ou outros itens no sistema. Pode ser considerado um selo de confidencialidade. Quando um rótulo (label) é colocado em um arquivo, ele descreve as propriedades de segurança desse arquivo e só permitirá acesso por arquivos, usuários e recursos com uma configuração de segurança semelhante. O significado e a interpretação dos valores do rótulo dependem da configuração da política. Algumas políticas tratam um rótulo como representando a integridade ou o sigilo de um objeto, enquanto outras políticas podem usar rótulos para manter regras de acesso.</p></li><li><p><em>multilabel</em>: esta propriedade é uma opção de sistema de arquivos que pode ser configurada no modo usuário único (single-user) usando o <a href="https://man.freebsd.org/cgi/man.cgi?query=tunefs&amp;sektion=8&amp;format=html">tunefs(8)</a>, durante a inicialização usando o <a href="https://man.freebsd.org/cgi/man.cgi?query=fstab&amp;sektion=5&amp;format=html">fstab(5)</a>, ou durante a criação de um novo sistema de arquivos. Essa opção permite que um administrador aplique rótulos MAC diferentes em objetos diferentes. Essa opção aplica-se somente aos módulos de política de segurança que suportam rotulagem.</p></li><li><p><em>single label</em>: uma política em que o sistema de arquivos inteiro usa um rótulo para impor o controle de acesso sobre o fluxo de dados. Sempre que <code>multilabel</code> não estiver definido, todos os arquivos estarão em conformidade com a mesma configuração de rótulo.</p></li><li><p><em>object</em>: uma entidade através da qual a informação flui sob a direção de um <em>sujeito</em>. Isso inclui diretórios, arquivos, campos, telas, teclados, memória, armazenamento magnético, impressoras ou qualquer outro dispositivo de armazenamento ou movimentação de dados. Um objeto (object) é um contêiner de dados ou um recurso do sistema. O acesso a um objeto significa efetivamente acesso aos seus dados.</p></li><li><p><em>subject</em>: qualquer entidade ativa que faz com que as informações fluam entre <em>objetos</em>, como um usuário, processo do usuário ou processo do sistema. No FreeBSD, isso é quase sempre um segmento agindo em um processo em nome de um usuário.</p></li><li><p><em>policy</em>: uma coleção de regras que define como os objetivos devem ser alcançados. Uma política (policy) geralmente documenta como determinados itens devem ser manipulados. Este capítulo considera uma política como uma coleção de regras que controla o fluxo de dados e informações e define quem tem acesso a esses dados e informações.</p></li><li><p><em>high-watermark</em>: esse tipo de política permite o aumento dos níveis de segurança com o objetivo de acessar informações de nível superior. Na maioria dos casos, o nível original é restaurado depois que o processo é concluído. Atualmente, o framework MAC do FreeBSD não inclui este tipo de política.</p></li><li><p><em>low-watermark</em>: esse tipo de política permite reduzir os níveis de segurança com o objetivo de acessar informações menos seguras. Na maioria dos casos, o nível de segurança original do usuário é restaurado após a conclusão do processo. O único módulo de política de segurança no FreeBSD para usar isto é o <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_lomac&amp;sektion=4&amp;format=html">mac_lomac(4)</a>.</p></li><li><p><em>sensitivity</em>: normalmente usado quando se discute Segurança Multinível (Multilevel Security - MLS). Um nível de sensibilidade (sensitivity) descreve o quão importante ou secreto os dados devem ser. À medida que o nível de sensibilidade aumenta, também aumenta a importância do sigilo ou confidencialidade dos dados.</p></li></ul></div></div><div class=sect2><h3 id=mac-understandlabel>15.3. Entendendo os rótulos MAC<a class=anchor href=#mac-understandlabel></a></h3><div class=paragraph><p>Um rótulo MAC é um atributo de segurança que pode ser aplicado a sujeitos e objetos em todo o sistema. Ao definir um rótulo, o administrador deve entender suas implicações para evitar o comportamento inesperado ou indesejado do sistema. Os atributos disponíveis em um objeto dependem do módulo de política carregado, pois os módulos de política interpretam seus atributos de maneiras diferentes.</p></div><div class=paragraph><p>O rótulo de segurança em um objeto é usado como parte de uma decisão de controle de acesso de segurança por uma política. Com algumas políticas, o rótulo contém todas as informações necessárias para tomar uma decisão. Em outras políticas, os rótulos podem ser processados como parte de um conjunto de regras maior.</p></div><div class=paragraph><p>Existem dois tipos de políticas de rótulos: rótulo único e rótulo múltiplo. Por padrão, o sistema usará rótulo único. O administrador deve estar ciente dos prós e contras de cada um para implementar políticas que atendam aos requisitos do modelo de segurança do sistema.</p></div><div class=paragraph><p>Uma diretiva de segurança de rótulo único permite que apenas um rótulo seja usado para cada sujeito ou objeto. Como uma política de rótulo único impõe um conjunto de permissões de acesso em todo o sistema, ela fornece menor sobrecarga de administração, mas diminui a flexibilidade das políticas que suportam rotulagem. No entanto, em muitos ambientes, uma única diretiva de rótulo pode ser tudo o que é necessário.</p></div><div class=paragraph><p>Uma diretiva de segurança de rótulo único é um pouco semelhante ao DAC pois o <code>root</code> configura as políticas para que os usuários sejam colocados nas categorias e níveis de acesso apropriados. Uma diferença notável é que muitos módulos de política também podem restringir o <code>root</code>. O controle básico sobre os objetos será então liberado para o grupo, mas o <code>root</code> poderá revogar ou modificar as configurações a qualquer momento.</p></div><div class=paragraph><p>Quando apropriado, uma política de rótulos múltiplos pode ser configurada em um sistema de arquivos UFS passando <code>multilabel</code> para o <a href="https://man.freebsd.org/cgi/man.cgi?query=tunefs&amp;sektion=8&amp;format=html">tunefs(8)</a>. Uma política de rótulos múltiplos permite que cada sujeito ou objeto tenha seu próprio rótulo MAC independente. A decisão de usar uma política de rótulos múltiplos ou rótulo único é necessária apenas para políticas que implementam o recurso de rotulagem, como <code>biba</code>, <code>lomac</code> e <code>mls</code>. Algumas políticas, como <code>seeotheruids</code>, <code>portacl</code> e <code>partition</code>, não usam rótulos.</p></div><div class=paragraph><p>Usar uma política de rótulos múltiplos em uma partição e estabelecer um modelo de segurança de rótulos múltiplos pode aumentar a sobrecarga administrativa, já que tudo nesse sistema de arquivos tem um rótulo. Isso inclui diretórios, arquivos e até mesmo nós de dispositivos.</p></div><div class=paragraph><p>O comando a seguir definirá a flag <code>multilabel</code> no sistema de arquivos UFS especificado . Isso só pode ser feito no modo de usuário único e não é um requisito para o sistema de arquivos de swap:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># tunefs -l enable /</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Alguns usuários tiveram problemas com a configuração de flag <code>multilabel</code> na partição raiz. Se este for o caso, por favor consulte <a href=#mac-troubleshoot>Solução de problemas do framework MAC</a>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Como a política de rótulos múltiplos é definida por sistema de arquivos, ela pode não ser necessária se o layout do sistema de arquivos for bem projetado. Considere um exemplo de modelo de segurança MAC para um servidor Web do FreeBSD. Esta máquina usa o rótulo único, <code>biba/high</code>, para tudo nos sistemas de arquivos padrão. Se o servidor Web precisar ser executado em <code>biba/low</code> para evitar recursos de gravação, ele poderá ser instalado em um sistema de arquivos UFS separado, <span class=filename>/usr/local</span>, definido com <code>biba/low</code>.</p></div><div class=sect3><h4 id=_configuração_de_rótulo>15.3.1. Configuração de rótulo<a class=anchor href=#_configuração_de_rótulo></a></h4><div class=paragraph><p>Praticamente todos os aspectos da configuração do módulo de política de rótulo serão executados usando os utilitários do sistema base. Esses comandos fornecem uma interface simples para a configuração de objeto ou sujeito ou a manipulação e verificação da configuração.</p></div><div class=paragraph><p>Toda a configuração pode ser feita usando <code>setfmac</code>, que é usado para definir rótulos MAC em objetos do sistema, e <code>setpmac</code>, que é usado para definir os rótulos em sujeitos do sistema. Por exemplo, para definir o rótulo MAC`biba` como <code>high</code> em <span class=filename>test</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># setfmac biba/high test</span></code></pre></div></div><div class=paragraph><p>Se a configuração for bem sucedida, o prompt será retornado sem erro. Um erro comum é <code>Permission denied</code>, que geralmente ocorre quando o rótulo está sendo definido ou modificado em um objeto restrito. Outras condições podem produzir falhas diferentes. Por exemplo, o arquivo pode não ser de propriedade do usuário que está tentando re-rotular o objeto, o objeto pode não existir ou o objeto pode ser somente de leitura. Uma política obrigatória não permitirá que o processo renomeie o arquivo, talvez devido a uma propriedade do arquivo, uma propriedade do processo ou uma propriedade do novo valor de rótulo proposto. Por exemplo, se um usuário que estiver executando com baixa integridade tentar alterar o rótulo de um arquivo de alta integridade, ou um usuário executando com baixa integridade tentar alterar o rótulo de um arquivo de baixa integridade para um rótulo de alta integridade, essas operações falharão.</p></div><div class=paragraph><p>O administrador do sistema pode usar <code>setpmac</code> para substituir as configurações do módulo de política, atribuindo um rótulo diferente a chamada do processo:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># setfmac biba/high test</span>
Permission denied
<span class=c># setpmac biba/low setfmac biba/high test</span>
<span class=c># getfmac test</span>
<span class=nb>test</span>: biba/high</code></pre></div></div><div class=paragraph><p>Para processos atualmente em execução, como o sendmail, o <code>getpmac</code> é normalmente usado. Esse comando usa uma ID de processo (PID) no lugar de um nome de comando. Se os usuários tentarem manipular um arquivo que não esteja em seu acesso, sujeito às regras dos módulos de política carregados, o erro <code>Operation not permitted</code> será exibido.</p></div></div><div class=sect3><h4 id=_rótulos_pré_definidos>15.3.2. Rótulos pré-definidos<a class=anchor href=#_rótulos_pré_definidos></a></h4><div class=paragraph><p>Alguns módulos de política do FreeBSD que suportam o recurso de rotulagem oferecem três rótulos predefinidos: <code>low</code>, <code>equal</code> e <code>high</code>, onde:</p></div><div class=ulist><ul><li><p><code>low</code> é considerada a configuração de rótulo mais baixa que um objeto ou assunto pode ter. Definir isso em sujeitos ou objetos bloqueia o acesso a objetos ou sujeitos marcados como alto (high).</p></li><li><p><code>equal</code> define o sujeito ou objeto a ser desabilitado ou não afetado e deve ser colocado apenas em objetos considerados como isentos da política.</p></li><li><p><code>high</code> concede a um objeto ou sujeito a configuração mais alta disponível nos módulos de política Biba e MLS.</p></li></ul></div><div class=paragraph><p>Esses módulos de política incluem <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_biba&amp;sektion=4&amp;format=html">mac_biba(4)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_mls&amp;sektion=4&amp;format=html">mac_mls(4)</a> e <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_lomac&amp;sektion=4&amp;format=html">mac_lomac(4)</a>. Cada um dos rótulos predefinidos estabelece uma diretiva de fluxo de informações diferentes. Consulte a página de manual do módulo para determinar as características das configurações genéricas de rótulos.</p></div></div><div class=sect3><h4 id=_rótulos_numéricos>15.3.3. Rótulos numéricos<a class=anchor href=#_rótulos_numéricos></a></h4><div class=paragraph><p>Os módulos de políticas Biba e MLS suportam um rótulo numérico que pode ser configurado para indicar o nível exato de controle hierárquico. Esse nível numérico é usado para particionar ou classificar informações em diferentes grupos de classificação, permitindo apenas o acesso a esse grupo ou a um nível de grupo mais alto. Por exemplo:</p></div><div class="literalblock programlisting"><div class=content><pre>biba/10:2+3+6(5:2+3-20:2+3+4+5+6)</pre></div></div><div class=paragraph><p>pode ser interpretado como "Rótulo de Política Biba/Grau 10:Compartimentos 2, 3 e 6: (grau 5 …​")</p></div><div class=paragraph><p>Neste exemplo, o primeiro grau seria considerado o grau efetivo com compartimentos efetivos, o segundo grau é o grau baixo e o último é o grau alto. Na maioria das configurações, essas definições refinadas não são necessárias, pois são consideradas configurações avançadas.</p></div><div class=paragraph><p>Objetos do sistema possuem apenas um grau e compartimento atuais. Os sujeitos do sistema refletem o intervalo de direitos disponíveis no sistema e as interfaces de rede, onde são usados para controle de acesso.</p></div><div class=paragraph><p>O grau e os compartimentos em um par de sujeito e objeto são usados para construir um relacionamento conhecido como <em>dominance</em>, em que um sujeito domina um objeto, o objeto domina o sujeito, nenhum domina o outro, ou ambos dominam cada um. O caso em que "ambos dominam" ocorre quando dois rótulos são iguais. Devido à natureza do fluxo de informações do Biba, um usuário tem direitos sobre um conjunto de compartimentos que podem corresponder aos projetos, mas os objetos também têm um conjunto de compartimentos. Os usuários podem ter que subconjuntar seus direitos usando <code>su</code> ou <code>setpmac</code> para acessar objetos em um compartimento a partir do qual eles não estão restritos.</p></div></div><div class=sect3><h4 id=_rótulos_de_usuários>15.3.4. Rótulos de usuários<a class=anchor href=#_rótulos_de_usuários></a></h4><div class=paragraph><p>Os usuários precisam ter rótulos para que seus arquivos e processos interajam adequadamente com a política de segurança definida no sistema. Isso é configurado no <span class=filename>/etc/login.conf</span> usando classes de login. Todo módulo de política que usa rótulos implementará a configuração da classe de usuário.</p></div><div class=paragraph><p>Para definir o rótulo padrão da classe de usuário que será imposto pelo MAC, adicione uma entrada <code>label</code>. Um exemplo de entrada <code>label</code> contendo todos os módulos de política é exibida abaixo. Observe que, em uma configuração real, o administrador nunca habilitaria todos os módulos de política. Recomenda-se que o restante deste capítulo seja revisado antes que qualquer configuração seja implementada.</p></div><div class="literalblock programlisting"><div class=content><pre>default:\
	:copyright=/etc/COPYRIGHT:\
	:welcome=/etc/motd:\
	:setenv=MAIL=/var/mail/$,BLOCKSIZE=K:\
	:path=~/bin:/sbin:/bin:/usr/sbin:/usr/bin:/usr/local/sbin:/usr/local/bin:\
	:manpath=/usr/shared/man /usr/local/man:\
	:nologin=/usr/sbin/nologin:\
	:cputime=1h30m:\
	:datasize=8M:\
	:vmemoryuse=100M:\
	:stacksize=2M:\
	:memorylocked=4M:\
	:memoryuse=8M:\
	:filesize=8M:\
	:coredumpsize=8M:\
	:openfiles=24:\
	:maxproc=32:\
	:priority=0:\
	:requirehome:\
	:passwordtime=91d:\
	:umask=022:\
	:ignoretime@:\
	:label=partition/13,mls/5,biba/10(5-15),lomac/10[2]:</pre></div></div><div class=paragraph><p>Embora os usuários não possam modificar o valor padrão, eles podem alterar seu rótulo após o login, sujeito às restrições da política. O exemplo acima diz à política do Biba que a integridade mínima de um processo é <code>5</code>, seu máximo é <code>15</code> e o rótulo efetivo padrão é <code>10</code>. O processo será executado em <code>10</code> até que ele escolha alterar o rótulo, talvez devido ao usuário usar <code>setpmac</code>, que será restringido pelo Biba ao intervalo configurado.</p></div><div class=paragraph><p>Após qualquer alteração no <span class=filename>login.conf</span>, o banco de dados de recursos da classe de login deve ser reconstruído usando o <code>cap_mkdb</code>.</p></div><div class=paragraph><p>Muitos sites têm um grande número de usuários que exigem várias classes de usuário diferentes. Um planejamento detalhado é necessário, pois isso pode dificultar o gerenciamento.</p></div></div><div class=sect3><h4 id=_rótulos_de_interface_de_rede>15.3.5. Rótulos de interface de rede<a class=anchor href=#_rótulos_de_interface_de_rede></a></h4><div class=paragraph><p>Os rótulos podem ser definidos em interfaces de rede para ajudar a controlar o fluxo de dados através da rede. Políticas que usam rótulos de interface de rede funcionam da mesma maneira que as políticas funcionam em relação aos objetos. Usuários com configurações altas no Biba, por exemplo, não terão permissão para acessar interfaces de rede com um rótulo <code>low</code>.</p></div><div class=paragraph><p>Ao definir o rótulo MAC em interfaces de rede, <code>maclabel</code> pode ser passado para o <code>ifconfig</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig bge0 maclabel biba/equal</span></code></pre></div></div><div class=paragraph><p>Este exemplo irá definir o rótulo MAC de <code>biba/equal</code> na interface <code>bge0</code>. Ao usar uma configuração semelhante a <code>biba/high(low-high)</code>, o rótulo inteiro deve ser citado para evitar que um erro seja retornado.</p></div><div class=paragraph><p>Cada módulo de política que suporta rotulagem tem um ajuste que pode ser usado para desativar o rótulo MAC em interfaces de rede. Configurar o rótulo para <code>equal</code> terá um efeito semelhante. Reveja a saída do <code>sysctl</code>, as páginas do manual de políticas e as informações no restante deste capítulo para obter mais informações sobre esses ajustes.</p></div></div></div><div class=sect2><h3 id=mac-planning>15.4. Planejando a configuração de segurança<a class=anchor href=#mac-planning></a></h3><div class=paragraph><p>Antes de implementar qualquer política de MAC, recomenda-se uma fase de planejamento. Durante as etapas de planejamento, um administrador deve considerar os requisitos e metas de implementação, como:</p></div><div class=ulist><ul><li><p>Como classificar informações e recursos disponíveis nos sistemas de destino.</p></li><li><p>Quais informações ou recursos para restringir o acesso, juntamente com o tipo de restrições que devem ser aplicadas.</p></li><li><p>Quais módulos MAC serão necessários para atingir esse objetivo.</p></li></ul></div><div class=paragraph><p>Um teste de sistema confiável e sua configuração deve ocorrer <em>antes</em> de uma implementação MAC ser usada em sistemas de produção. Como diferentes ambientes têm diferentes necessidades e requisitos, estabelecer um perfil de segurança completo diminuirá a necessidade de alterações quando o sistema entrar em operação.</p></div><div class=paragraph><p>Considere como o framework MAC aumenta a segurança do sistema como um todo. Os vários módulos de política de segurança fornecidos pelo framework MAC podem ser usados para proteger a rede e os sistemas de arquivos ou para impedir que usuários acessem determinadas portas e soquetes. Talvez o melhor uso dos módulos de política seja carregar vários módulos de política de segurança por vez para fornecer um ambiente MLS. Essa abordagem difere de uma política rígida, que tipicamente endurece elementos de um sistema que são usados apenas para propósitos específicos. A desvantagem de MLS é o aumento da sobrecarga administrativa.</p></div><div class=paragraph><p>A sobrecarga é mínima quando comparada ao efeito duradouro de uma estrutura que fornece a capacidade de escolher quais políticas são necessárias para uma configuração específica e que reduzem a sobrecarga de desempenho. A redução do suporte a políticas desnecessárias pode aumentar o desempenho geral do sistema, além de oferecer flexibilidade de escolha. Uma boa implementação consideraria os requisitos gerais de segurança e implementaria efetivamente os vários módulos de política de segurança oferecidos pelo framework.</p></div><div class=paragraph><p>Um sistema que utiliza MAC garante que um usuário não terá permissão para alterar atributos de segurança à vontade. Todos os utilitários, programas e scripts de usuário devem funcionar dentro das restrições das regras de acesso fornecidas pelos módulos de política de segurança selecionados e o controle das regras de acesso do MAC está nas mãos do administrador do sistema.</p></div><div class=paragraph><p>É dever do administrador do sistema selecionar cuidadosamente os módulos de política de segurança corretos. Para um ambiente que precisa limitar o controle de acesso na rede, o <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_portacl&amp;sektion=4&amp;format=html">mac_portacl(4)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_ifoff&amp;sektion=4&amp;format=html">mac_ifoff(4)</a>, e os módulos de políticas <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_biba&amp;sektion=4&amp;format=html">mac_biba(4)</a> são bons pontos de partida. Para um ambiente em que a confidencialidade rigorosa dos objetos do sistema de arquivos é necessária, considere <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_bsdextended&amp;sektion=4&amp;format=html">mac_bsdextended(4)</a> e os módulos de política <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_mls&amp;sektion=4&amp;format=html">mac_mls(4)</a>.</p></div><div class=paragraph><p>Decisões de políticas podem ser tomadas com base na configuração da rede. Se apenas determinados usuários tiverem permissão para acessar o <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh&amp;sektion=1&amp;format=html">ssh(1)</a>, o módulo de política <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_portacl&amp;sektion=4&amp;format=html">mac_portacl(4)</a> é uma boa escolha. No caso de sistemas de arquivos, o acesso a objetos pode ser considerado confidencial para alguns usuários, mas não para outros. Como um exemplo, uma grande equipe de desenvolvimento pode ser dividida em projetos menores, onde os desenvolvedores do projeto A podem não ter permissão para acessar objetos escritos por desenvolvedores do projeto B. No entanto, ambos os projetos podem precisar acessar objetos criados por desenvolvedores do projeto C. Usando os diferentes módulos de política de segurança fornecidos pelo framework MAC, os usuários poderiam ser divididos nesses grupos e então receber acesso aos objetos apropriados.</p></div><div class=paragraph><p>Cada módulo de política de segurança tem uma maneira exclusiva de lidar com a segurança geral de um sistema. A seleção de módulos deve se basear em uma política de segurança bem pensada, que pode exigir revisão e reimplementação. Entender os diferentes módulos da política de segurança oferecidos pelo framework MAC ajudará os administradores a escolher as melhores políticas para suas situações.</p></div><div class=paragraph><p>O restante deste capítulo aborda os módulos disponíveis, descreve seu uso e configuração e, em alguns casos, fornece informações sobre as situações aplicáveis.</p></div><div class="admonitionblock caution"><table><tbody><tr><td class=icon><i class="fa icon-caution" title=Caution></i></td><td class=content><div class=paragraph><p>A implementação do MAC é muito parecida com a implementação de um firewall, já que é preciso tomar cuidado para evitar que o sistema seja completamente bloqueado. A capacidade de reverter para uma configuração anterior deve ser considerada e a implementação do MAC em uma conexão remota deve ser feita com extrema cautela.</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=mac-policies>15.5. Políticas MAC Disponíveis<a class=anchor href=#mac-policies></a></h3><div class=paragraph><p>O kernel padrão do FreeBSD inclui a diretiva <code>options MAC</code>. Isso significa que todos os módulos incluídos no framework MAC podem ser carregados com o comando <code>kldload</code> como um módulo do kernel em tempo de execução. Depois de testar o módulo, adicione o nome do módulo ao arquivo <span class=filename>/boot/loader.conf</span> para que ele seja carregado durante a inicialização. Cada módulo também fornece uma opção de kernel para os administradores que escolhem compilar seu próprio kernel personalizado.</p></div><div class=paragraph><p>O FreeBSD inclui um grupo de políticas que cobrirá a maioria dos requisitos de segurança. Cada política é resumida abaixo. As três últimas políticas suportam configurações inteiras no lugar dos três rótulos padrão.</p></div><div class=sect3><h4 id=mac-seeotheruids>15.5.1. O MAC vê a Política de Outros UIDs<a class=anchor href=#mac-seeotheruids></a></h4><div class=paragraph><p>Nome do módulo: <span class=filename>mac_seeotheruids.ko</span></p></div><div class=paragraph><p>Linha de configuração do kernel: <code>options MAC_SEEOTHERUIDS</code></p></div><div class=paragraph><p>Opção de inicialização: <code>mac_seeotheruids_load="YES"</code></p></div><div class=paragraph><p>O módulo <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_seeotheruids&amp;sektion=4&amp;format=html">mac_seeotheruids(4)</a> amplia os ajustes <code>security.bsd.see_other_uids</code> e <code>security.bsd.see_other_gids</code> do <code>sysctl</code>. Esta opção não requer que nenhum rótulo seja definido antes da configuração e pode operar de forma transparente com outros módulos.</p></div><div class=paragraph><p>Depois de carregar o módulo, os seguintes ajustes <code>sysctl</code> podem ser usados para controlar seus recursos:</p></div><div class=ulist><ul><li><p>O <code>security.mac.seeotheruids.enabled</code> ativa o módulo e implementa as configurações padrões que impedem que os usuários visualizem processos e soquetes pertencentes a outros usuários.</p></li><li><p><code>security.mac.seeotheruids.specificgid_enabled</code> permite que grupos especificados sejam isentos desta política. Para isentar grupos específicos, use a variável <code>security.mac.seeotheruids.specificgid=<em>XXX</em></code> do <code>sysctl</code>, substituindo <em>XXX</em> pelo ID numérico do grupo a ser isento.</p></li><li><p><code>security.mac.seeotheruids.primarygroup_enabled</code> é usado para isentar grupos primários específicos desta política. Ao usar este ajuste, o <code>security.mac.seeotheruids.specificgid_enabled</code> não pode estar definido.</p></li></ul></div></div><div class=sect3><h4 id=mac-bsdextended>15.5.2. A Política Estendida do BSD MAC<a class=anchor href=#mac-bsdextended></a></h4><div class=paragraph><p>Nome do módulo: <span class=filename>mac_bsdextended.ko</span></p></div><div class=paragraph><p>Linha de configuração do kernel: <code>options MAC_BSDEXTENDED</code></p></div><div class=paragraph><p>Opção de inicialização: <code>mac_bsdextended_load="YES"</code></p></div><div class=paragraph><p>O módulo <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_bsdextended&amp;sektion=4&amp;format=html">mac_bsdextended(4)</a> aplica um firewall no sistema de arquivos. Ele fornece uma extensão para o modelo de permissões do sistema de arquivos padrão, permitindo que um administrador crie um conjunto de regras semelhante a um firewall para proteger arquivos, utilitários e diretórios na hierarquia do sistema de arquivos. Quando se tenta acessar um objeto do sistema de arquivos, a lista de regras é iterada até que uma regra correspondente seja localizada ou o final seja atingido. Esse comportamento pode ser alterado usando <code>security.mac.bsdextended.firstmatch_enabled</code>. Semelhante a outros módulos de firewall no FreeBSD, um arquivo contendo as regras de controle de acesso pode ser criado e lido pelo sistema no momento da inicialização usando uma variável do <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a>.</p></div><div class=paragraph><p>A lista de regras pode ser inserida usando o <a href="https://man.freebsd.org/cgi/man.cgi?query=ugidfw&amp;sektion=8&amp;format=html">ugidfw(8)</a> que possui uma sintaxe similar ao <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfw&amp;sektion=8&amp;format=html">ipfw(8)</a>. Mais ferramentas podem ser escritas usando as funções da biblioteca <a href="https://man.freebsd.org/cgi/man.cgi?query=libugidfw&amp;sektion=3&amp;format=html">libugidfw(3)</a>.</p></div><div class=paragraph><p>Depois que o módulo <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_bsdextended&amp;sektion=4&amp;format=html">mac_bsdextended(4)</a> tiver sido carregado, o seguinte comando poderá ser usado para listar a configuração atual da regra:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ugidfw list</span>
0 slots, 0 rules</code></pre></div></div><div class=paragraph><p>Por padrão, nenhuma regra é definida e tudo está completamente acessível. Para criar uma regra que bloqueia todo o acesso dos usuários, mas que não afeta o ` root `:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ugidfw add subject not uid root new object not uid root mode n</span></code></pre></div></div><div class=paragraph><p>Embora essa regra seja simples de implementar, é uma idéia muito ruim, pois impede que todos os usuários emitam comandos. Um exemplo mais realista bloqueia todo o acesso do <code>user1</code>, incluindo listagens de diretórios, ao diretório inicial do usuário <code><em>user2</em></code> :</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ugidfw set 2 subject uid user1 object uid user2 mode n</span>
<span class=c># ugidfw set 3 subject uid user1 object gid user2 mode n</span></code></pre></div></div><div class=paragraph><p>Em vez de <code>user1</code>, <code>not uid_user2</code> poderia ser usado para impor as mesmas restrições de acesso para todos os usuários. No entanto, o usuário <code>root</code> não é afetado por essas regras.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Deve-se ter extremo cuidado ao trabalhar com este módulo, pois o uso incorreto pode bloquear o acesso a certas partes do sistema de arquivos.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=mac-ifoff>15.5.3. A política de silenciamento da interface MAC<a class=anchor href=#mac-ifoff></a></h4><div class=paragraph><p>Nome do módulo: <span class=filename>mac_ifoff.ko</span></p></div><div class=paragraph><p>Linha de configuração do kernel: <code>options MAC_IFOFF</code></p></div><div class=paragraph><p>Opção de inicialização: <code>mac_ifoff_load="YES"</code></p></div><div class=paragraph><p>O módulo <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_ifoff&amp;sektion=4&amp;format=html">mac_ifoff(4)</a> é usado para desabilitar as interfaces de rede e evitar que as interfaces de rede sejam ativadas durante a inicialização do sistema. Ele não usa rótulos e não depende de nenhum outro módulo MAC.</p></div><div class=paragraph><p>A maior parte do controle deste módulo é realizada através destes ajustes <code>sysctl</code>:</p></div><div class=ulist><ul><li><p><code>security.mac.ifoff.lo_enabled</code> ativa ou desativa todo o tráfego na interface de loopback, <a href="https://man.freebsd.org/cgi/man.cgi?query=lo&amp;sektion=4&amp;format=html">lo(4)</a>.</p></li><li><p><code>security.mac.ifoff.bpfrecv_enabled</code> ativa ou desativa todo o tráfego na interface do Filtro de Pacotes Berkeley, <a href="https://man.freebsd.org/cgi/man.cgi?query=bpf&amp;sektion=4&amp;format=html">bpf(4)</a>.</p></li><li><p><code>security.mac.ifoff.other_enabled</code> ativa ou desativa o tráfego em todas as outras interfaces.</p></li></ul></div><div class=paragraph><p>Um dos usos mais comuns do <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_ifoff&amp;sektion=4&amp;format=html">mac_ifoff(4)</a> é o monitoramento de rede em um ambiente onde o tráfego de rede não deve ser permitido durante a sequência de inicialização. Outro uso seria escrever um script que usa um aplicativo como o <a class=package href=https://cgit.freebsd.org/ports/tree/security/aide/>security/aide</a> para bloquear automaticamente o tráfego da rede se encontrar arquivos novos ou alterados em diretórios protegidos.</p></div></div><div class=sect3><h4 id=mac-portacl>15.5.4. A política de lista de controle de acesso da porta MAC<a class=anchor href=#mac-portacl></a></h4><div class=paragraph><p>Nome do módulo: <span class=filename>mac_portacl.ko</span></p></div><div class=paragraph><p>Linha de configuração do kernel: <code>MAC_PORTACL</code></p></div><div class=paragraph><p>Opção de inicialização: <code>mac_portacl_load="YES"</code></p></div><div class=paragraph><p>O módulo <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_portacl&amp;sektion=4&amp;format=html">mac_portacl(4)</a> é usado para limitar a ligação a portas TCP e UDP locais , tornando possível permitir que usuários non-<code>root</code> sejam vinculados a portas privilegiadas especificadas abaixo de 1024.</p></div><div class=paragraph><p>Uma vez carregado, este módulo habilita a política MAC em todos os sockets. Os seguintes ajustes estão disponíveis:</p></div><div class=ulist><ul><li><p><code>security.mac.portacl.enabled</code> ativa ou desativa a política completamente.</p></li><li><p>A <code>security.mac.portacl.port_high</code> configura o número de porta mais alto que o <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_portacl&amp;sektion=4&amp;format=html">mac_portacl(4)</a> protege.</p></li><li><p>A <code>security.mac.portacl.suser_exempt</code>, quando configurada para um valor diferente de zero, isenta o usuário <code>root</code> desta política.</p></li><li><p>A <code>security.mac.portacl.rules</code> especifica a política como uma cadeia de texto no formato <code>rule [, rule, …​]</code>, com tantas regras quantas forem necessárias, e onde cada regra esta na forma <code>idtype:id:protocol:port</code>. O <span class=parameter>idtype</span> é <code>uid</code> ou <code>gid</code>. O parâmetro <span class=parameter>protocol</span> pode ser <code>tcp</code> ou <code>udp</code>. O parâmetro <span class=parameter>port</span> é o número da porta para permitir que o usuário ou grupo especificado se vincule. Somente valores numéricos podem ser usados para os parâmetros ID do usuário, ID do grupo e porta.</p></li></ul></div><div class=paragraph><p>Por padrão, as portas abaixo de 1024 só podem ser usadas por processos privilegiados que são executados como <code>root</code>. Para que o <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_portacl&amp;sektion=4&amp;format=html">mac_portacl(4)</a> permita que processos não privilegiados se vinculem a portas abaixo de 1024, defina os seguintes ajustes da seguinte forma:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl security.mac.portacl.port_high=1023</span>
<span class=c># sysctl net.inet.ip.portrange.reservedlow=0</span>
<span class=c># sysctl net.inet.ip.portrange.reservedhigh=0</span></code></pre></div></div><div class=paragraph><p>Para evitar que o usuário <code>root</code> seja afetado por esta política, configure <code>security.mac.portacl.suser_exempt</code> para um valor diferente de zero.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl security.mac.portacl.suser_exempt=1</span></code></pre></div></div><div class=paragraph><p>Para permitir que o usuário <code>www</code> com UID 80 seja vinculado à porta 80 sem precisar do privilégio <code>root</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl security.mac.portacl.rules=uid:80:tcp:80</span></code></pre></div></div><div class=paragraph><p>Este próximo exemplo permite que o usuário com o UID de 1001 se vincule às portas TCP 110 (POP3) e 995 (POP3):</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl security.mac.portacl.rules=uid:1001:tcp:110,uid:1001:tcp:995</span></code></pre></div></div></div><div class=sect3><h4 id=mac-partition>15.5.5. A Política de Partição MAC<a class=anchor href=#mac-partition></a></h4><div class=paragraph><p>Nome do módulo: <span class=filename>mac_partition.ko</span></p></div><div class=paragraph><p>Linha de configuração do kernel: <code>options MAC_PARTITION</code></p></div><div class=paragraph><p>Opção de inicialização: <code>mac_partition_load="YES"</code></p></div><div class=paragraph><p>A política <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_partition&amp;sektion=4&amp;format=html">mac_partition(4)</a> coloca os processos em "partições" específicas com base no rótulo MAC. A maioria das configurações para esta política é feita usando <a href="https://man.freebsd.org/cgi/man.cgi?query=setpmac&amp;sektion=8&amp;format=html">setpmac(8)</a>. Uma vari[avek <code>sysctl</code> está disponível para esta política:</p></div><div class=ulist><ul><li><p>A <code>security.mac.partition.enabled</code> permite a aplicação de partições de processo MAC.</p></li></ul></div><div class=paragraph><p>Quando essa política esta ativada, os usuários só poderão ver seus processos e quaisquer outros em sua partição, mas não terão permissão para trabalhar com utilitários fora do escopo dessa partição. Por exemplo, um usuário na classe <code>insecure</code> não terá permissão para acessar <code>top</code>, bem como muitos outros comandos que devem fazer spawn de um processo.</p></div><div class=paragraph><p>Este exemplo adiciona o <code>top</code> ao conjunto de rótulos dos usuários na classe <code>insecure</code>. Todos os processos gerados por usuários na classe <code>insecure</code> permanecerão no rótulo <code>partition/13</code>.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># setpmac partition/13 top</span></code></pre></div></div><div class=paragraph><p>Este comando exibe o rótulo da partição e a lista de processos:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ps Zax</span></code></pre></div></div><div class=paragraph><p>Esse comando exibe o rótulo da partição de processo de outro usuário e os processos atualmente em execução desse usuário:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ps -ZU trhodes</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Os usuários podem ver processos no rótulo <code>root</code>, a menos que a política <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_seeotheruids&amp;sektion=4&amp;format=html">mac_seeotheruids(4)</a> esteja carregada.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=mac-mls>15.5.6. O módulo de segurança multinível MAC<a class=anchor href=#mac-mls></a></h4><div class=paragraph><p>Nome do módulo: <span class=filename>mac_mls.ko</span></p></div><div class=paragraph><p>Linha de configuração do kernel: <code>options MAC_MLS</code></p></div><div class=paragraph><p>Opção de inicialização: <code>mac_mls_load="YES"</code></p></div><div class=paragraph><p>A política <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_mls&amp;sektion=4&amp;format=html">mac_mls(4)</a> controla o acesso entre sujeitos e objetos no sistema, aplicando uma diretiva de fluxo de informações restrita.</p></div><div class=paragraph><p>Em ambientes MLS, um nível de "clearance" é definido no rótulo de cada sujeito ou objeto, juntamente com os compartimentos. Como esses níveis de liberação podem atingir números maiores que vários milhares, seria uma tarefa difícil configurar completamente cada sujeito ou objeto. Para facilitar essa sobrecarga administrativa, três rótulos são incluídos nesta política: <code>mls/low</code>, <code>mls/equal</code> e <code>mls/high</code>, onde:</p></div><div class=ulist><ul><li><p>Qualquer coisa rotulada com <code>mls/low</code> terá um nível de folga baixo e não será permitido acessar informações de um nível superior. Esse rótulo também evita que objetos de nível de liberação mais alto gravem ou transmitam informações para um nível inferior.</p></li><li><p><code>mls/equal</code> deve ser colocado em objetos que devem ser isentos da política.</p></li><li><p><code>mls/high</code> é o nível mais alto de permissão possível. Objetos atribuídos a esse rótulo terão domínio sobre todos os outros objetos no sistema; no entanto, eles não permitirão o vazamento de informações para objetos de classe baixa.</p></li></ul></div><div class=paragraph><p>O MLS fornece:</p></div><div class=ulist><ul><li><p>Um nível de segurança hierárquico com um conjunto de categorias não hierárquicas.</p></li><li><p>Regras fixas de <code>no read up, no write down</code>. Isso significa que um sujeito pode ter acesso de leitura a objetos em seu próprio nível ou abaixo, mas não acima. Da mesma forma, um sujeito pode ter acesso de gravação a objetos em seu próprio nível ou acima, mas não abaixo dele.</p></li><li><p>Sigilo, ou a prevenção de divulgação inadequada de dados.</p></li><li><p>Uma base para o projeto de sistemas que lidam simultaneamente com dados em múltiplos níveis de sensibilidade sem vazar informações entre secretas e confidenciais.</p></li></ul></div><div class=paragraph><p>Os seguintes ajustes <code>sysctl</code> estão disponíveis:</p></div><div class=ulist><ul><li><p><code>security.mac.mls.enabled</code> é usado para habilitar ou desabilitar a política MLS.</p></li><li><p><code>security.mac.mls.ptys_equal</code> todos os dispositivos <a href="https://man.freebsd.org/cgi/man.cgi?query=pty&amp;sektion=4&amp;format=html">pty(4)</a> como <code>mls/equal</code> durante a criação.</p></li><li><p><code>security.mac.mls.revocation_enabled</code> revoga o acesso a objetos depois que seu rótulo é alterado para um rótulo de nível inferior.</p></li><li><p><code>security.mac.mls.max_compartments</code> define o número máximo de níveis de compartimentos permitidos em um sistema.</p></li></ul></div><div class=paragraph><p>Para manipular os rótulos MLS, use <a href="https://man.freebsd.org/cgi/man.cgi?query=setfmac&amp;sektion=8&amp;format=html">setfmac(8)</a>. Para atribuir um rótulo a um objeto:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># setfmac mls/5 test</span></code></pre></div></div><div class=paragraph><p>Para obter o rótulo MLS para o arquivo <span class=filename>test</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># getfmac test</span></code></pre></div></div><div class=paragraph><p>Outra abordagem é criar um arquivo de política mestre em <span class=filename>/etc/</span>, que especifica as informações de política de MLS e alimentar o <code>setfmac</code> com esse arquivo.</p></div><div class=paragraph><p>Ao usar o módulo de política do MLS, um administrador planeja controlar o fluxo de informações confidenciais. O padrão <code>block read up block write down</code> define tudo para um estado baixo. Tudo é acessível e um administrador aumenta lentamente a confidencialidade das informações.</p></div><div class=paragraph><p>Além das três opções básicas de rótulo, um administrador pode agrupar usuários e grupos conforme necessário para bloquear o fluxo de informações entre eles. Pode ser mais fácil olhar as informações em níveis de clearance usando palavras descritivas, como classificações de <code>Confidential</code>, <code>Secret</code> e <code>Top Secret</code>. Alguns administradores criam grupos diferentes com base nos níveis do projeto. Independentemente do método de classificação, um plano bem pensado deve existir antes de implementar uma política restritiva.</p></div><div class=paragraph><p>Alguns exemplos de situações para o módulo de política MLS incluem um servidor Web de e-commerce, um servidor de arquivos com informações críticas sobre a empresa e ambientes de instituições financeiras.</p></div></div><div class=sect3><h4 id=mac-biba>15.5.7. O Módulo MAC Biba<a class=anchor href=#mac-biba></a></h4><div class=paragraph><p>Nome do módulo: <span class=filename>mac_biba.ko</span></p></div><div class=paragraph><p>Linha de configuração do kernel: <code>options MAC_BIBA</code></p></div><div class=paragraph><p>Opção de inicialização: <code>mac_biba_load="YES"</code></p></div><div class=paragraph><p>O módulo <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_biba&amp;sektion=4&amp;format=html">mac_biba(4)</a> carrega a política MAC Biba. Essa política é semelhante à política MLS, com a exceção de que as regras para o fluxo de informações são levemente revertidas. Isso evita o fluxo descendente de informações confidenciais, enquanto a política MLS impede o fluxo ascendente de informações confidenciais.</p></div><div class=paragraph><p>Nos ambientes do Biba, um rótulo "integrity" é definido em cada sujeito ou objeto. Esses rótulos são compostos de classes hierárquicas e componentes não hierárquicos. Como um grau ascende, o mesmo acontece com a sua integridade.</p></div><div class=paragraph><p>Rótulos suportados são <code>biba/low</code>, <code>biba/equal</code> e <code>biba/high</code>, onde:</p></div><div class=ulist><ul><li><p><code>biba/low</code> é considerado a integridade mais baixa que um sujeito ou objeto pode ter. Definir isso em sujeitos ou objetos bloqueia o acesso de gravação a objetos ou sujeitos marcados como <code>biba/high</code>, mas não impede o acesso de leitura.</p></li><li><p><code>biba/equal</code> só deve ser colocado em objetos considerados como isentos da política.</p></li><li><p><code>biba/high</code> permite gravar objetos em um rótulo inferior, mas não permite a leitura desse objeto. Recomenda-se que esse rótulo seja colocado em objetos que afetam a integridade de todo o sistema.</p></li></ul></div><div class=paragraph><p>O Biba fornece:</p></div><div class=ulist><ul><li><p>Níveis de integridade hierárquica com um conjunto de categorias de integridade não hierárquicas.</p></li><li><p>As regras fixas são <code>no write up, no read down</code>, o oposto do MLS. Um sujeito pode ter acesso de gravação a objetos em seu próprio nível ou abaixo, mas não acima. Da mesma forma, um sujeito pode ter acesso de leitura a objetos em seu próprio nível ou acima, mas não abaixo.</p></li><li><p>Integridade, impedindo a modificação inadequada de dados.</p></li><li><p>Níveis de integridade em vez dos níveis de sensibilidade do MLS.</p></li></ul></div><div class=paragraph><p>Os seguintes ajustes podem ser usados para manipular a política Biba:</p></div><div class=ulist><ul><li><p><code>security.mac.biba.enabled</code> é usado para ativar ou desativar a imposição da política Biba na máquina de destino.</p></li><li><p>O <code>security.mac.biba.ptys_equal</code> é usado para desabilitar a política Biba em dispositivos <a href="https://man.freebsd.org/cgi/man.cgi?query=pty&amp;sektion=4&amp;format=html">pty(4)</a>.</p></li><li><p><code>security.mac.biba.revocation_enabled</code> força a revogação do acesso a objetos se o rótulo for alterado para dominar o sujeito.</p></li></ul></div><div class=paragraph><p>Para acessar a configuração de política Biba em objetos do sistema, use <code>setfmac</code> e <code>getfmac</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># setfmac biba/low test</span>
<span class=c># getfmac test</span>
<span class=nb>test</span>: biba/low</code></pre></div></div><div class=paragraph><p>Integridade, que é diferente de sensibilidade, é usada para garantir que a informação não seja manipulada por partes não confiáveis. Isso inclui informações passadas entre sujeitos e objetos. Ele garante que os usuários só poderão modificar ou acessar as informações para as quais receberam acesso explícito. O módulo de política de segurança <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_biba&amp;sektion=4&amp;format=html">mac_biba(4)</a> permite que um administrador configure quais arquivos e programas um usuário pode ver e invocar enquanto assegura que os programas e arquivos sejam confiáveis pelo sistema para esse usuário.</p></div><div class=paragraph><p>Durante a fase de planejamento inicial, um administrador deve estar preparado para particionar os usuários em graus, níveis e áreas. O sistema terá como padrão um rótulo alto assim que esse módulo de política for ativado e cabe ao administrador configurar as diferentes classificações e níveis para os usuários. Em vez de usar níveis de liberação, um bom método de planejamento pode incluir tópicos. Por exemplo, permita apenas que os desenvolvedores modifiquem o acesso ao repositório do código-fonte, ao compilador do código-fonte e a outros utilitários de desenvolvimento. Outros usuários seriam agrupados em outras categorias, como testadores, designers ou usuários finais, e somente o acesso de leitura seria permitido.</p></div><div class=paragraph><p>Um sujeito de integridade inferior é incapaz de escrever para um sujeito de integridade superior e um sujeito de integridade superior não pode listar ou ler um objeto de integridade inferior. Definir um rótulo com o grau mais baixo possível pode torná-lo inacessível aos sujeitos. Alguns ambientes em potencial para esse módulo de política de segurança incluiriam um servidor Web restrito, uma máquina de desenvolvimento e teste e um repositório de código-fonte. Uma implementação menos útil seria uma estação de trabalho pessoal, uma máquina usada como roteador ou um firewall de rede.</p></div></div><div class=sect3><h4 id=mac-lomac>15.5.8. O módulo MAC de marca d’água baixa<a class=anchor href=#mac-lomac></a></h4><div class=paragraph><p>Nome do módulo: <span class=filename>mac_lomac.ko</span></p></div><div class=paragraph><p>Linha de configuração do kernel: <code>options MAC_LOMAC</code></p></div><div class=paragraph><p>Opção de inicialização: <code>mac_lomac_load="YES"</code></p></div><div class=paragraph><p>Diferentemente da política do MAC Biba, a política <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_lomac&amp;sektion=4&amp;format=html">mac_lomac(4)</a> permite acesso a objetos de baixa integridade somente após diminuir o nível de integridade para não interromper nenhuma regra de integridade.</p></div><div class=paragraph><p>A política de integridade de marca d’água baixa funciona de forma quase idêntica ao Biba, com a exceção do uso de rótulos flutuantes para suportar o rebaixamento do sujeito por meio de um compartimento auxiliar de classificação. Este compartimento secundário assume o formato <code>[auxgrade]</code>. Ao atribuir uma política com um grau auxiliar, use a sintaxe <code>lomac/10[2]</code>, onde <code>2</code> é o grau auxiliar.</p></div><div class=paragraph><p>Essa política se baseia na rotulagem onipresente de todos os objetos do sistema com rótulos de integridade, permitindo que os sujeitos leiam objetos de baixa integridade e fazendo o downgrade do rótulo no sujeito para evitar gravações futuras em objetos de alta integridade usando <code>[auxgrade]</code> . A política pode fornecer maior compatibilidade e exigir menos configuração inicial do que o Biba.</p></div><div class=paragraph><p>Como as políticas Biba e MLS, <code>setfmac</code> e <code>setpmac</code> são usadas para colocar rótulos nos objetos do sistema:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># setfmac /usr/home/trhodes lomac/high[low]</span>
<span class=c># getfmac /usr/home/trhodes lomac/high[low]</span></code></pre></div></div><div class=paragraph><p>Um grau auxiliar <code>low</code> é uma funcionalidade fornecida apenas pela política MACLOMAC.</p></div></div></div><div class=sect2><h3 id=mac-userlocked>15.6. Bloqueio do Usuário<a class=anchor href=#mac-userlocked></a></h3><div class=paragraph><p>Este exemplo considera um sistema de armazenamento relativamente pequeno com menos de cinquenta usuários. Os usuários terão recursos de login e terão permissão para armazenar dados e acessar recursos.</p></div><div class=paragraph><p>Para este cenário, os módulos de política <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_bsdextended&amp;sektion=4&amp;format=html">mac_bsdextended(4)</a> e <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_seeotheruids&amp;sektion=4&amp;format=html">mac_seeotheruids(4)</a> podem coexistir e bloquear o acesso a objetos do sistema enquanto ocultam processos do usuário.</p></div><div class=paragraph><p>Comece adicionando a seguinte linha ao <span class=filename>/boot/loader.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>mac_seeotheruids_load=&#34;YES&#34;</pre></div></div><div class=paragraph><p>O módulo de política de segurança <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_bsdextended&amp;sektion=4&amp;format=html">mac_bsdextended(4)</a> pode ser ativado adicionando esta linha ao arquivo <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>ugidfw_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>As regras padrões armazenadas em <span class=filename>/etc/rc.bsdextended</span> serão carregadas na inicialização do sistema. No entanto, as entradas padrões podem precisar de modificação. Como esta máquina é destinada apenas para servir os usuários, tudo pode ser deixado comentado, exceto as duas últimas linhas, a fim de forçar o carregamento de objetos do sistema de propriedade do usuário por padrão.</p></div><div class=paragraph><p>Adicione os usuários necessários a esta máquina e reinicie. Para fins de teste, tente efetuar login como um usuário diferente em dois consoles. Execute <code>ps aux</code> para ver se os processos de outros usuários estão visíveis. Verifique se a execução do <a href="https://man.freebsd.org/cgi/man.cgi?query=ls&amp;sektion=1&amp;format=html">ls(1)</a> no diretório inicial de outro usuário falha.</p></div><div class=paragraph><p>Não tente testar com o usuário <code>root</code>, a menos que o <code>sysctl</code> específico tenha sido modificado para bloquear o acesso do superusuário.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Quando um novo usuário é adicionado, sua regra <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_bsdextended&amp;sektion=4&amp;format=html">mac_bsdextended(4)</a> não estará na lista de conjuntos de regras. Para atualizar o conjunto de regras rapidamente, descarregue o módulo de política de segurança e recarregue-o novamente usando <a href="https://man.freebsd.org/cgi/man.cgi?query=kldunload&amp;sektion=8&amp;format=html">kldunload(8)</a> e <a href="https://man.freebsd.org/cgi/man.cgi?query=kldload&amp;sektion=8&amp;format=html">kldload(8)</a>.</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=mac-implementing>15.7. Nagios em Jail MAC<a class=anchor href=#mac-implementing></a></h3><div class=paragraph><p>Esta seção demonstra as etapas necessárias para implementar o sistema de monitoramento de rede Nagios em um ambiente MAC. Isso é um exemplo que ainda exige que o administrador teste se a política implementada atende aos requisitos de segurança da rede antes de usar em um ambiente de produção.</p></div><div class=paragraph><p>Este exemplo requer que o <code>multilabel</code> seja definido em cada sistema de arquivos. Ele também assume que o <a class=package href=https://cgit.freebsd.org/ports/tree/net-mgmt/nagios-plugins/>net-mgmt/nagios-plugins</a>, <a class=package href=https://cgit.freebsd.org/ports/tree/net-mgmt/nagios/>net-mgmt/nagios</a> e <a class=package href=https://cgit.freebsd.org/ports/tree/www/apache22/>www/apache22</a> estão todos instalados, configurados e funcionando corretamente antes de tentar a integração na estrutura MAC.</p></div><div class=sect3><h4 id=_criar_uma_classe_de_usuário_insegura>15.7.1. Criar uma Classe de Usuário Insegura<a class=anchor href=#_criar_uma_classe_de_usuário_insegura></a></h4><div class=paragraph><p>Comece o procedimento adicionando a seguinte classe de usuário ao <span class=filename>/etc/login.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>insecure:\
:copyright=/etc/COPYRIGHT:\
:welcome=/etc/motd:\
:setenv=MAIL=/var/mail/$,BLOCKSIZE=K:\
:path=~/bin:/sbin:/bin:/usr/sbin:/usr/bin:/usr/local/sbin:/usr/local/bin
:manpath=/usr/shared/man /usr/local/man:\
:nologin=/usr/sbin/nologin:\
:cputime=1h30m:\
:datasize=8M:\
:vmemoryuse=100M:\
:stacksize=2M:\
:memorylocked=4M:\
:memoryuse=8M:\
:filesize=8M:\
:coredumpsize=8M:\
:openfiles=24:\
:maxproc=32:\
:priority=0:\
:requirehome:\
:passwordtime=91d:\
:umask=022:\
:ignoretime@:\
:label=biba/10(10-10):</pre></div></div><div class=paragraph><p>Em seguida, adicione a seguinte linha a seção de classe de usuário padrão:</p></div><div class="literalblock programlisting"><div class=content><pre>:label=biba/high:</pre></div></div><div class=paragraph><p>Salve as edições e rode o seguinte comando para reconstruir o banco de dados:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cap_mkdb /etc/login.conf</span></code></pre></div></div></div><div class=sect3><h4 id=_configurar_usuários>15.7.2. Configurar usuários<a class=anchor href=#_configurar_usuários></a></h4><div class=paragraph><p>Configure o usuário <code>root</code> para a classe padrão usando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pw usermod root -L default</span></code></pre></div></div><div class=paragraph><p>Todas as contas de usuário que não são <code>root</code> agora exigirão uma classe de login. A classe de login é necessária, caso contrário, os usuários terão acesso recusado aos comandos comuns. O seguinte script <code>sh</code> deve resolver:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># for x in `awk -F: &#39;($3 &gt;= 1001) &amp;&amp; ($3 != 65534) { print $1 }&#39; \</span>
	/etc/passwd<span class=sb>`</span><span class=p>;</span> <span class=k>do </span>pw usermod <span class=nv>$x</span> <span class=nt>-L</span> default<span class=p>;</span> <span class=k>done</span><span class=p>;</span></code></pre></div></div><div class=paragraph><p>Em seguida, altere as contas <code>nagios</code> e <code>www</code> para a classe insegura:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pw usermod nagios -L insecure</span>
<span class=c># pw usermod www -L insecure</span></code></pre></div></div></div><div class=sect3><h4 id=_crie_o_arquivo_de_contextos>15.7.3. Crie o arquivo de contextos<a class=anchor href=#_crie_o_arquivo_de_contextos></a></h4><div class=paragraph><p>Um arquivo de contexto deve agora ser criado como <span class=filename>/etc/policy.contexts</span>:</p></div><div class="literalblock programlisting"><div class=content><pre># This is the default BIBA policy for this system.

# System:
/var/run(/.*)?			biba/equal

/dev/(/.*)?			biba/equal

/var				biba/equal
/var/spool(/.*)?		biba/equal

/var/log(/.*)?			biba/equal

/tmp(/.*)?			biba/equal
/var/tmp(/.*)?			biba/equal

/var/spool/mqueue		biba/equal
/var/spool/clientmqueue		biba/equal

# For Nagios:
/usr/local/etc/nagios(/.*)?	biba/10

/var/spool/nagios(/.*)?		biba/10

# For apache
/usr/local/etc/apache(/.*)?	biba/10</pre></div></div><div class=paragraph><p>Essa política impõe segurança ao definir restrições no fluxo de informações. Nesta configuração específica, os usuários, incluindo O <code>root</code>, nunca devem ter permissão para acessar o Nagios. Arquivos de configuração e processos que fazem parte do Nagios serão completamente auto-contidos ou presos.</p></div><div class=paragraph><p>Este arquivo será lido depois da execução do <code>setfsmac</code> em cada sistema de arquivos. Este exemplo define a política no sistema de arquivos raiz:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># setfsmac -ef /etc/policy.contexts /</span></code></pre></div></div><div class=paragraph><p>Em seguida, adicione estas edições a seção principal do <span class=filename>/etc/mac.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>default_labels file ?biba
default_labels ifnet ?biba
default_labels process ?biba
default_labels socket ?biba</pre></div></div></div><div class=sect3><h4 id=_configuração_do_inicializador>15.7.4. Configuração do Inicializador<a class=anchor href=#_configuração_do_inicializador></a></h4><div class=paragraph><p>Para finalizar a configuração, adicione as seguintes linhas ao <span class=filename>/boot/loader.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>mac_biba_load=&#34;YES&#34;
mac_seeotheruids_load=&#34;YES&#34;
security.mac.biba.trust_all_interfaces=1</pre></div></div><div class=paragraph><p>E a seguinte linha para a configuração da placa de rede armazenada em <span class=filename>/etc/rc.conf</span>. Se a configuração de rede principal for feita via DHCP, talvez seja necessário configurá-la manualmente após cada inicialização do sistema:</p></div><div class="literalblock programlisting"><div class=content><pre>maclabel biba/equal</pre></div></div></div><div class=sect3><h4 id=_testando_a_configuração>15.7.5. Testando a Configuração<a class=anchor href=#_testando_a_configuração></a></h4><div class=paragraph><p>Primeiro, certifique-se de que o servidor Web e o Nagios não iniciarão na inicialização e reinicialização do sistema. Assegure-se de que o <code>root</code> não possa acessar nenhum dos arquivos no diretório de configuração do Nagios. Se o <code>root</code> puder listar o conteúdo de <span class=filename>/var/spool/nagios</span>, algo está errado. Em vez disso, um erro "permission denied" deve ser retornado.</p></div><div class=paragraph><p>Se tudo parecer bem, o Nagios, o Apache e o Sendmail agora poderão ser iniciados:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /etc/mail &amp;&amp; make stop &amp;&amp; \</span>
setpmac biba/equal make start <span class=o>&amp;&amp;</span> setpmac biba/10<span class=se>\(</span>10-10<span class=se>\)</span> apachectl start <span class=o>&amp;&amp;</span> <span class=se>\</span>
setpmac biba/10<span class=se>\(</span>10-10<span class=se>\)</span> /usr/local/etc/rc.d/nagios.sh forcestart</code></pre></div></div><div class=paragraph><p>Verifique novamente para garantir que tudo esteja funcionando corretamente. Caso contrário, verifique os arquivos de log em busca de mensagens de erro. Se necessário, use o <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> para desativar o módulo de política de segurança <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_biba&amp;sektion=4&amp;format=html">mac_biba(4)</a> e tente iniciar tudo novamente.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>O usuário <code>root</code> ainda pode alterar a aplicação de segurança e editar seus arquivos de configuração. O comando a seguir permitirá a degradação da política de segurança para um nível inferior para um shell recém executado:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># setpmac biba/10 csh</span></code></pre></div></div><div class=paragraph><p>Para impedir que isso aconteça, force o usuário a um intervalo usando <a href="https://man.freebsd.org/cgi/man.cgi?query=login.conf&amp;sektion=5&amp;format=html">login.conf(5)</a>. Se o <a href="https://man.freebsd.org/cgi/man.cgi?query=setpmac&amp;sektion=8&amp;format=html">setpmac(8)</a> tentar executar um comando fora do intervalo do compartimento, um erro será retornado e o comando não será executado. Nesse caso, defina root como <code>biba/high(high-high)</code>.</p></div></td></tr></tbody></table></div></div></div><div class=sect2><h3 id=mac-troubleshoot>15.8. Solução de problemas do framework MAC<a class=anchor href=#mac-troubleshoot></a></h3><div class=paragraph><p>Esta seção discute erros de configuração comuns e como resolvê-los.</p></div><div class=dlist><dl><dt class=hdlist1>O sinalizador <code>multilabel</code> não fica habilitado na partição raiz (<span class=filename>/</span>)</dt><dd><p>As etapas a seguir podem resolver este erro transitório:</p></dd></dl></div><div class="exampleblock procedure"><div class=content><div class="olist loweralpha"><ol class=loweralpha type=a><li><p>Edite <span class=filename>/etc/fstab</span> e defina a partição raiz como somente leitura <code>ro</code>.</p></li><li><p>Reinicie no modo single user.</p></li><li><p>Execute <code>tunefs -l enable</code> no <span class=filename>/</span>.</p></li><li><p>Reinicie o sistema.</p></li><li><p>Execute <code>mount -urw</code><span class=filename>/</span> e mude a opção <code>ro</code> de volta para <code>rw</code> no <span class=filename>/etc/fstab</span> e reinicie o sistema novamente.</p></li><li><p>Verifique novamente a saída do <code>mount</code> para garantir que o <code>multilabel</code> tenha sido configurado corretamente no sistema de arquivos raiz.</p></li></ol></div></div></div><div class=dlist><dl><dt class=hdlist1>Depois de estabelecer um ambiente seguro com o MAC, o Xorg não inicia mais</dt><dd><p>Isso pode ser causado pela política MAC <code>partition</code> ou por uma rotulagem incorreta em uma das políticas de rotulagem do MAC. Para depurar, tente o seguinte:</p></dd></dl></div><div class="exampleblock procedure"><div class=content><div class="olist loweralpha"><ol class=loweralpha type=a><li><p>Verifique a mensagem de erro. Se o usuário estiver na classe <code>insecure</code>, a política <code>partition</code> pode ser a culpada. Tente definir a classe do usuário de volta para a classe <code>default</code> e reconstrua o banco de dados com o <code>cap_mkdb</code>. Se isso não mitigar o problema, vá para a etapa dois.</p></li><li><p>Verifique duas vezes se as políticas de rótulo estão definidas corretamente para o usuário, para o Xorg e para as entradas no <span class=filename>/dev</span>.</p></li><li><p>Se nenhum destes resolver o problema, envie a mensagem de erro e uma descrição do ambiente para a lista de discussão <a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-questions>de perguntas gerais sobre o FreeBSD</a>.</p></li></ol></div></div></div><div class=dlist><dl><dt class=hdlist1>O erro <code>_secure_path: unable to stat .login_conf</code> aparece</dt><dd><p>Esse erro pode aparecer quando um usuário tenta alternar do usuário <code>root</code> para outro usuário no sistema. Essa mensagem geralmente ocorre quando o usuário possui uma qualificação mais alta do que a do usuário que ele está tentando se tornar. Por exemplo, se <code>joe</code> tiver uma classificação padrão de <code>biba/low</code> e o <code>root</code> tiver uma classificação de <code>biba/high</code>, o <code>root</code> não poderá visualizar o diretório inicial de <code>joe</code>. Isso acontecerá independente se o <code>root</code> usou ou não o <code>su</code> para se tornar o <code>joe</code>, pois o modelo de integridade do Biba não permitirá que o <code>root</code> exiba objetos definidos em um nível de integridade mais baixo.</p></dd><dt class=hdlist1>O sistema não reconhece mais o <code>root</code></dt><dd><p>Quando isso ocorre, o <code>whoami</code> retorna <code>0</code> e <code>su</code> retorna <code>who are you?</code>.</p><div class=paragraph><p>Isso pode acontecer se uma política de rotulagem foi desativada por <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> ou o módulo de política foi descarregado. Se a política estiver desativada, o banco de dados de recursos de login precisará ser reconfigurado. Verifique duas vezes o <span class=filename>/etc/login.conf</span> para garantir que todas as opções de <code>label</code> tenham sido removidas e reconstrua o banco de dados com <code>cap_mkdb</code>.</p></div><div class=paragraph><p>Isso também pode acontecer se uma política restringir o acesso ao <span class=filename>master.passwd</span>. Isso geralmente é causado por um administrador que altera o arquivo sob um rótulo que entra em conflito com a política geral que está sendo usada pelo sistema. Nesses casos, as informações do usuário seriam lidas pelo sistema e o acesso seria bloqueado, pois o arquivo herdaria o novo rótulo. Desative a política usando o <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> e tudo deve retornar ao normal.</p></div></dd></dl></div></div></div></div><div class=sect1><h2 id=audit>Capítulo 16. Auditoria de Evento de Segurança<a class=anchor href=#audit></a></h2><div class=sectionbody><div class=sect2><h3 id=audit-synopsis>16.1. Sinopse<a class=anchor href=#audit-synopsis></a></h3><div class=paragraph><p>O sistema operacional FreeBSD inclui suporte para auditoria de eventos de segurança. A auditoria de eventos oferece suporte a registros confiáveis, detalhados e configuráveis de diversos eventos do sistema relevantes para a segurança, incluindo logins, alterações de configuração e acesso a arquivos e rede. Esses registros de log podem ser inestimáveis para monitoramento de sistema em tempo real, detecção de intrusão e análise "post mortem". O FreeBSD implementa a Application Programming Interface (API) Basic Security Module (BSM) publicada pela Sun™ e o formato de arquivo, e é interoperável com as implementações de auditoria do Solaris™ e do Mac OS™ X.</p></div><div class=paragraph><p>Este capítulo se concentra na instalação e configuração da auditoria de eventos. Ele explica as políticas de auditoria e fornece um exemplo de configuração de auditoria.</p></div><div class=paragraph><p>Depois de ler este capítulo, você saberá:</p></div><div class=ulist><ul><li><p>O que é auditoria de eventos e como funciona.</p></li><li><p>Como configurar a auditoria de eventos no FreeBSD para usuários e processos.</p></li><li><p>Como revisar o caminho da auditoria usando as ferramentas de auditoria para redução e revisão.</p></li></ul></div><div class=paragraph><p>Antes de ler este capítulo, você deve:</p></div><div class=ulist><ul><li><p>Entender os fundamentos do UNIX™ e do FreeBSD (<a href=./#basics>Fundamentos do FreeBSD</a>).</p></li><li><p>Familiarize-se com os conceitos básicos de configuração/compilação do kernel (<a href=./#kernelconfig>Configurando o kernel do FreeBSD</a>).</p></li><li><p>Ter alguma familiaridade com segurança e como ela está presente no FreeBSD (<a href=./#security>Segurança</a>).</p></li></ul></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>O recurso de auditoria possui algumas limitações conhecidas. Nem todos os eventos do sistema que são relevantes para a segurança são auditáveis, e também alguns mecanismos de login, como gerenciadores de exibição baseados em Xorg e daemons de terceiros, não configuram adequadamente a auditoria para sessões de login do usuário.</p></div><div class=paragraph><p>O recurso de auditoria de eventos de segurança é capaz de gerar logs muito detalhados da atividade do sistema. Em um sistema muito utilizado, os dados do arquivo de rastreamento podem ser muito grandes quando configurados para grandes detalhes, excedendo gigabytes por semana em algumas configurações. Os administradores devem levar em consideração os requisitos de espaço em disco associados a configurações de auditoria de alto volume. Por exemplo, pode ser desejável dedicar um sistema de arquivos ao <span class=filename>/var/audit</span> para que outros sistemas de arquivos não sejam afetados se o sistema de arquivos de auditoria ficar cheio.</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=audit-inline-glossary>16.2. Termos chave<a class=anchor href=#audit-inline-glossary></a></h3><div class=paragraph><p>Os termos a seguir estão relacionados a auditoria de eventos de segurança:</p></div><div class=ulist><ul><li><p><em>event</em>: um evento auditável é qualquer evento que pode ser registrado usando o subsistema de auditoria. Exemplos de eventos relevantes para a segurança incluem a criação de um arquivo, a construção de uma conexão de rede ou o logon de um usuário. Os eventos são "atribuíveis", o que significa que podem ser rastreados para um usuário autenticado, ou "não atribuível". Exemplos de eventos não atribuíveis são eventos que ocorrem antes da autenticação no processo de login, como tentativas de senha incorreta.</p></li><li><p><em>class</em>: um conjunto nomeado de eventos relacionados que são usados em expressões de seleção. As classes de eventos comumente usadas incluem "file creation" (fc), "exec" (ex), e "login_logout" (lo).</p></li><li><p><em>record</em>: uma entrada de log de auditoria que descreve um evento de segurança. Os registros contêm um tipo de evento de registro, informações sobre o assunto (usuário) executando a ação, informações de data e hora, informações sobre quaisquer objetos ou argumentos e uma condição de sucesso ou falha.</p></li><li><p><em>trail</em>: um arquivo de log que consiste em uma série de registros de auditoria que descrevem eventos de segurança. As trilhas estão em ordem cronológica aproximada com relação aos eventos concluídos. Apenas processos autorizados podem enviar registros para a trilha de auditoria.</p></li><li><p><em>selection expression</em>: uma string contendo uma lista de prefixos e nomes de classes de eventos de auditoria usados para combinar eventos.</p></li><li><p><em>preselection</em>: o processo pelo qual o sistema identifica quais eventos são de interesse do administrador. A configuração de pré-seleção usa uma série de expressões de seleção para identificar quais classes de eventos auditar quais usuários, bem como configurações globais que se aplicam a processos autenticados e não autenticados.</p></li><li><p><em>reduction</em>: o processo pelo qual os registros das trilhas de auditoria existentes são selecionados para preservação, impressão ou análise. Da mesma forma, o processo pelo qual os registros de auditoria indesejados são removidos da trilha de auditoria. Usando a redução, os administradores podem implementar políticas para a preservação de dados de auditoria. Por exemplo, trilhas de auditoria detalhadas podem ser mantidas por um mês, mas depois disso, as trilhas podem ser reduzidas para preservar apenas as informações de login para fins de arquivamento.</p></li></ul></div></div><div class=sect2><h3 id=audit-config>16.3. Configuração de Auditoria<a class=anchor href=#audit-config></a></h3><div class=paragraph><p>O suporte para auditoria de eventos no espaço do usuário é instalado como parte do sistema operacional básico do FreeBSD. O suporte a kernel está disponível no kernel <span class=filename>GENERIC</span> por padrão, e <a href="https://man.freebsd.org/cgi/man.cgi?query=auditd&amp;sektion=8&amp;format=html">auditd(8)</a> pode ser ativado adicionando a seguinte linha no <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>auditd_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Em seguida, inicie o daemon de auditoria:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service auditd start</span></code></pre></div></div><div class=paragraph><p>Usuários que preferem compilar um kernel personalizado devem incluir a seguinte linha em seu arquivo de configuração de kernel personalizado:</p></div><div class="literalblock programlisting"><div class=content><pre>options	AUDIT</pre></div></div><div class=sect3><h4 id=_expressões_de_seleção_de_eventos>16.3.1. Expressões de Seleção de Eventos<a class=anchor href=#_expressões_de_seleção_de_eventos></a></h4><div class=paragraph><p>Expressões de seleção são usadas em vários lugares na configuração de auditoria para determinar quais eventos devem ser auditados. Expressões contêm uma lista de classes de eventos para correspondência. As expressões de seleção são avaliadas da esquerda para a direita e duas expressões são combinadas, acrescentando uma à outra.</p></div><div class=paragraph><p><a href=#event-selection>Classes de Eventos de Auditoria Padrão</a> resume as classes de eventos de auditoria padrão:</p></div><table id=event-selection class="tableblock frame-none grid-all stretch"><caption class=title>Tabela 12. Classes de Eventos de Auditoria Padrão</caption><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Nome da classe</th><th class="tableblock halign-left valign-top">Descrição</th><th class="tableblock halign-left valign-top">Ação</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>all</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>all</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Corresponde todas as classes de eventos.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>aa</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>autenticação e autorização</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>ad</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>administrativo</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Ações administrativas executadas no sistema como um todo.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>ap</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>aplicação</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Ação definida pela aplicação.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>cl</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>file close</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Auditar chamadas para a chamada de sistema <code>close</code>.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>ex</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>exec</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Execução do programa de auditoria. Auditoria de argumentos de linha de comando e variáveis de ambiente são controladas via <a href="https://man.freebsd.org/cgi/man.cgi?query=audit_control&amp;sektion=5&amp;format=html">audit_control(5)</a> usando os parâmetros <code>argv</code> e <code>envv</code> para a configuração da <code>política</code>.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>fa</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>acesso ao atributo de arquivo</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Audite o acesso de atributos de objetos como <a href="https://man.freebsd.org/cgi/man.cgi?query=stat&amp;sektion=1&amp;format=html">stat(1)</a> e <a href="https://man.freebsd.org/cgi/man.cgi?query=pathconf&amp;sektion=2&amp;format=html">pathconf(2)</a>.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>fc</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>file create</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Eventos de auditoria em que um arquivo é criado.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>fd</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>file delete</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Eventos de auditoria onde ocorre a exclusão de arquivos.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>fm</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>file attribute modify</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Eventos de auditoria onde ocorre a modificação do atributo do arquivo, como <a href="https://man.freebsd.org/cgi/man.cgi?query=chown&amp;sektion=8&amp;format=html">chown(8)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=chflags&amp;sektion=1&amp;format=html">chflags(1)</a>, e <a href="https://man.freebsd.org/cgi/man.cgi?query=flock&amp;sektion=2&amp;format=html">flock(2)</a>.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>fr</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>file read</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Eventos de auditoria nos quais dados são lidos ou arquivos são abertos para leitura.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>fw</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>file write</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Eventos de auditoria nos quais os dados são gravados ou os arquivos são gravados ou modificados.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>io</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>ioctl</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Auditar o uso da chamada de sistema <code>ioctl</code>.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>ip</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>ipc</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Auditar várias formas de comunicação entre processos, incluindo pipes POSIX e operações IPC do System V.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>lo</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>login_logout</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Audite os eventos <a href="https://man.freebsd.org/cgi/man.cgi?query=login&amp;sektion=1&amp;format=html">login(1)</a> e <a href="https://man.freebsd.org/cgi/man.cgi?query=logout&amp;sektion=1&amp;format=html">logout(1)</a>.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>na</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>não atribuível</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Auditar eventos não atribuíveis.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>no</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>classe inválida</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Não coincidir com eventos de auditoria.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>nt</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>rede (network)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Eventos de auditoria relacionados a ações de rede, como <a href="https://man.freebsd.org/cgi/man.cgi?query=connect&amp;sektion=2&amp;format=html">connect(2)</a> e <a href="https://man.freebsd.org/cgi/man.cgi?query=accept&amp;sektion=2&amp;format=html">accept(2)</a>.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>ot</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>outros</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Auditoria de eventos diversos.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>pc</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>processo</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Auditar operações de processos, como <a href="https://man.freebsd.org/cgi/man.cgi?query=exec&amp;sektion=3&amp;format=html">exec(3)</a> e <a href="https://man.freebsd.org/cgi/man.cgi?query=exit&amp;sektion=3&amp;format=html">exit(3)</a>.</p></td></tr></tbody></table><div class=paragraph><p>Essas classes de eventos de auditoria podem ser personalizadas modificando os arquivos de configuração <span class=filename>audit_class</span> e <span class=filename>audit_event</span>.</p></div><div class=paragraph><p>Cada classe de eventos de auditoria pode ser combinada com um prefixo indicando se as operações com êxito/falha são correspondidas e se a entrada está adicionando ou removendo a correspondência para a classe e o tipo. <a href=#event-prefixes>Prefixos para Classes de Eventos de Auditoria</a> resume os prefixos disponíveis:</p></div><table id=event-prefixes class="tableblock frame-none grid-all stretch"><caption class=title>Tabela 13. Prefixos para Classes de Eventos de Auditoria</caption><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Prefixo</th><th class="tableblock halign-left valign-top">Ação</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>+</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Auditoria de eventos bem sucedidos nesta classe.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>-</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Auditoria de eventos com falha nesta classe.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>^</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Auditoria de eventos nem com sucesso e nem com falha nesta classe.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>^+</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Não faça auditoria de eventos bem-sucedidos nesta classe.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>^-</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Não audite eventos com falha nesta classe.</p></td></tr></tbody></table><div class=paragraph><p>Se nenhum prefixo estiver presente, as instâncias com êxito e com falha do evento serão auditadas.</p></div><div class=paragraph><p>O seguinte exemplo de sequência de seleção seleciona eventos de login/logout bem-sucedidos e com falha, mas apenas eventos de execução bem-sucedidos:</p></div><div class="literalblock programlisting"><div class=content><pre>lo,+ex</pre></div></div></div><div class=sect3><h4 id=_arquivos_de_configuração>16.3.2. Arquivos de Configuração<a class=anchor href=#_arquivos_de_configuração></a></h4><div class=paragraph><p>Os seguintes arquivos de configuração para auditoria de eventos de segurança são encontrados em <span class=filename>/etc/security</span>:</p></div><div class=ulist><ul><li><p><span class=filename>audit_class</span>: contém as definições das classes de auditoria.</p></li><li><p><span class=filename>audit_control</span>: controla os aspectos do subsistema de auditoria, como as classes de auditoria padrão, o espaço em disco mínimo a ser deixado no volume do log de auditoria e o tamanho máximo da trilha de auditoria.</p></li><li><p><span class=filename>audit_event</span>: nomes e descrições textuais de eventos de auditoria do sistema e uma lista de quais classes cada evento está.</p></li><li><p><span class=filename>audit_user</span>: requisitos de auditoria específicos do usuário a serem combinados com os padrões globais no login.</p></li><li><p><span class=filename>audit_warn</span>: um script de shell personalizável usado pelo <a href="https://man.freebsd.org/cgi/man.cgi?query=auditd&amp;sektion=8&amp;format=html">auditd(8)</a> para gerar mensagens de aviso em situações excepcionais, como quando o espaço para registros de auditoria está baixo ou quando o arquivo de trilha de auditoria foi rotacionado.</p></li></ul></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Os arquivos de configuração de auditoria devem ser editados e mantidos com cuidado, pois erros na configuração podem resultar no registro inadequado de eventos.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Na maioria dos casos, os administradores precisarão modificar apenas <span class=filename>audit_control</span> e <span class=filename>audit_user</span>. O primeiro arquivo controla as políticas e as propriedades de auditoria de todo o sistema, e o segundo arquivo pode ser usado para ajustar a auditoria pelo usuário.</p></div><div class=sect4><h5 id=audit-auditcontrol>16.3.2.1. O arquivo <span class=filename>audit_control</span><a class=anchor href=#audit-auditcontrol></a></h5><div class=paragraph><p>Vários padrões para o subsistema de auditoria são especificados em <span class=filename>audit_control</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>dir:/var/audit
dist:off
flags:lo,aa
minfree:5
naflags:lo,aa
policy:cnt,argv
filesz:2M
expire-after:10M</pre></div></div><div class=paragraph><p>A entrada <code>dir</code> é usada para definir um ou mais diretórios onde os logs de auditoria serão armazenados. Se mais de uma entrada de diretório aparecer, elas serão usadas em ordem à medida que forem preenchidas. É comum configurar a auditoria para que os logs de auditoria sejam armazenados em um sistema de arquivos dedicado, para evitar a interferência entre o subsistema de auditoria e outros subsistemas, se o sistema de arquivos encher.</p></div><div class=paragraph><p>Se o campo <code>dist</code> estiver definido como <code>on</code> ou <code>yes</code>, os links físicos serão criados para todos os arquivos de rastreio em <span class=filename>/var/audit/dist</span>.</p></div><div class=paragraph><p>O campo <code>flags</code> define a máscara de pré-seleção padrão para todo o sistema para eventos atribuíveis. No exemplo acima, eventos de login/logout bem-sucedidos e com falha, bem como autenticação e autorização, são auditados para todos os usuários.</p></div><div class=paragraph><p>A entrada <code>minfree</code> define a porcentagem mínima de espaço livre para o sistema de arquivos no qual a trilha de auditoria está armazenada.</p></div><div class=paragraph><p>A entrada <code>naflags</code> especifica as classes de auditoria a serem auditadas para eventos não atribuídos, como o processo de login/logout e autenticação e autorização.</p></div><div class=paragraph><p>A entrada <code>policy</code> especifica uma lista separada por vírgula de sinalizadores de política que controla vários aspectos do comportamento de auditoria. O <code>cnt</code> indica que o sistema deve continuar em execução apesar de uma falha de auditoria (este sinalizador é altamente recomendado). O outro sinalizador, <code>argv</code>, faz com que os argumentos da linha de comando para a chamada de sistema <a href="https://man.freebsd.org/cgi/man.cgi?query=execve&amp;sektion=2&amp;format=html">execve(2)</a> sejam auditados como parte de execução de comando.</p></div><div class=paragraph><p>A entrada <code>filesz</code> especifica o tamanho máximo para uma trilha de auditoria antes de finalizar e rotacionar automaticamente o arquivo de trilha. Um valor de <code>0</code> desabilita a rotação automática de log. Se o tamanho do arquivo solicitado estiver abaixo do mínimo de 512k, ele será ignorado e uma mensagem de log será gerada.</p></div><div class=paragraph><p>O campo <code>expire-after</code> especifica quando os arquivos de log de auditoria expirarão e serão removidos.</p></div></div><div class=sect4><h5 id=audit-audituser>16.3.2.2. O Arquivo <span class=filename>audit_user</span><a class=anchor href=#audit-audituser></a></h5><div class=paragraph><p>O administrador pode especificar requisitos adicionais de auditoria para usuários específicos em <span class=filename>audit_user</span>. Cada linha configura a auditoria para um usuário através de dois campos: o campo <code>alwaysaudit</code> especifica um conjunto de eventos que devem sempre ser auditados para o usuário, e o campo <code>neveraudit</code> especifica um conjunto de eventos que nunca devem ser auditados para o usuário.</p></div><div class=paragraph><p>As entradas de exemplo a seguir auditam os eventos de login/logout e a execução bem-sucedida do comando para <code>root</code> e criação de arquivos e execução de comando bem-sucedida para <code>www</code>. Se usado com o <span class=filename>audit_control</span>, a entrada <code>lo</code> para <code>root</code> é redundante, e os eventos login/logout também serão auditados para <code>www</code>.</p></div><div class="literalblock programlisting"><div class=content><pre>root:lo,+ex:no
www:fc,+ex:no</pre></div></div></div></div></div><div class=sect2><h3 id=audit-administration>16.4. Trabalhando com Trilhas de Auditoria<a class=anchor href=#audit-administration></a></h3><div class=paragraph><p>Como as trilhas de auditoria são armazenadas no formato binário BSM, várias ferramentas internas estão disponíveis para modificar ou converter essas trilhas em texto. Para converter arquivos de trilha em um formato de texto simples, use o <code>praudit</code>. Para reduzir o arquivo de trilha de auditoria para fins de análise, arquivamento ou impressão, use o <code>auditreduce</code>. Esse utilitário suporta vários parâmetros de seleção, incluindo tipo de evento, classe de evento, usuário, data ou hora do evento e o caminho ou objeto do arquivo em questão.</p></div><div class=paragraph><p>Por exemplo, para baixar todo o conteúdo de um log de auditoria especificado em texto simples:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># praudit /var/audit/AUDITFILE</span></code></pre></div></div><div class=paragraph><p>Onde <em>AUDITFILE</em> é o log de auditoria a ser descarregado.</p></div><div class=paragraph><p>As trilhas de auditoria consistem em uma série de registros de auditoria compostos por tokens, em que o <code>praudit</code> imprime sequencialmente, um por linha. Cada token é de um tipo específico, como <code>header</code> (um cabeçalho de registro de auditoria) ou <code>path</code> (um caminho de arquivo de uma pesquisa de nome). O seguinte é um exemplo de um evento <code>execve</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>header,133,10,execve(2),0,Mon Sep 25 15:58:03 2006, + 384 msec
exec arg,finger,doug
path,/usr/bin/finger
attribute,555,root,wheel,90,24918,104944
subject,robert,root,wheel,root,wheel,38439,38032,42086,128.232.9.100
return,success,0
trailer,133</pre></div></div><div class=paragraph><p>Esta auditoria representa uma chamada <code>execve</code> bem-sucedida, na qual o comando <code>finger doug</code> foi executado. O token <code>exec arg</code> contém a linha de comando processada apresentada pelo shell ao kernel. O token <code>path</code> contém o caminho para o executável conforme procurado pelo kernel. O token <code>attribute</code> descreve o binário e inclui o modo de arquivo. O token <code>subject</code> armazena o ID do usuário de auditoria, ID do usuário e ID do grupo, ID do usuário real e ID do grupo, ID do processo, ID da sessão, ID da porta e endereço de login. Observe que o ID do usuário de auditoria e o ID do usuário real são diferentes quando o usuário <code>robert</code> mudou para a conta <code>root</code> antes de executar este comando, mas é auditado usando o usuário original autenticado. O token <code>return</code> indica a execução bem-sucedida e o <code>trailer</code> conclui o registro.</p></div><div class=paragraph><p>O formato de saída XML também é suportado e pode ser selecionado incluindo <code>-x</code>.</p></div><div class=paragraph><p>Como os logs de auditoria podem ser muito grandes, um subconjunto de registros pode ser selecionado usando <code>auditreduce</code>. Este exemplo seleciona todos os registros de auditoria produzidos para o usuário <code>trhodes</code> armazenados em <span class=filename>AUDITFILE</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># auditreduce -u trhodes /var/audit/AUDITFILE | praudit</span></code></pre></div></div><div class=paragraph><p>Os membros do grupo <code>audit</code> têm permissão para ler trilhas de auditoria em <span class=filename>/var/audit</span>. Por padrão, esse grupo está vazio, portanto, apenas o usuário <code>root</code> pode ler trilhas de auditoria. Os usuários podem ser adicionados ao grupo <code>auditoria</code> para delegar direitos de revisão de auditoria. Como a capacidade de rastrear o conteúdo do log de auditoria fornece informações significativas sobre o comportamento dos usuários e processos, recomenda-se que a delegação dos direitos de revisão de auditoria seja executada com cautela.</p></div><div class=sect3><h4 id=_monitoramento_em_tempo_real_usando_pipes_de_auditoria>16.4.1. Monitoramento em Tempo Real Usando Pipes de Auditoria<a class=anchor href=#_monitoramento_em_tempo_real_usando_pipes_de_auditoria></a></h4><div class=paragraph><p>Pipes de auditoria são pseudo-dispositivos clones que permitem que os aplicativos acessem o fluxo de registro de auditoria em tempo real. Isto é principalmente de interesse para os autores de aplicações de detecção de intrusão e monitoramento de sistemas. No entanto, o dispositivo de canal de auditoria é uma maneira conveniente para o administrador permitir o monitoramento ao vivo sem incorrer em problemas com a propriedade do arquivo de trilha de auditoria ou a rotação de log interrompendo o fluxo de eventos. Para acompanhar o fluxo de eventos de auditoria em tempo real:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># praudit /dev/auditpipe</span></code></pre></div></div><div class=paragraph><p>Por padrão, os nós de dispositivo dos pipes de auditoria são acessíveis apenas para o usuário <code>root</code>. Para torná-los acessíveis aos membros do grupo <code>audit</code>, adicione uma regra <code>devfs</code> para <span class=filename>/etc/devfs.rules</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>add path &#39;auditpipe*&#39; mode 0440 group audit</pre></div></div><div class=paragraph><p>Veja <a href="https://man.freebsd.org/cgi/man.cgi?query=devfs.rules&amp;sektion=5&amp;format=html">devfs.rules(5)</a> para mais informações sobre como configurar o sistema de arquivos devfs.</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>É fácil produzir ciclos de feedback de evento de auditoria, nos quais a visualização de cada evento de auditoria resulta na geração de mais eventos de auditoria. Por exemplo, se toda a rede I/O for auditada e <code>praudit</code> for executada a partir de uma sessão SSH, um fluxo contínuo de eventos de auditoria será gerada em uma taxa alta, pois cada evento sendo impresso gerará outro evento. Por esse motivo, é aconselhável executar <code>praudit</code> em um dispositivo de pipe de auditoria a partir de sessões sem auditoria de I/O de baixa granularidade.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=_rotação_e_compactação_de_arquivos_de_trilha_de_auditoria>16.4.2. Rotação e Compactação de Arquivos de Trilha de Auditoria<a class=anchor href=#_rotação_e_compactação_de_arquivos_de_trilha_de_auditoria></a></h4><div class=paragraph><p>As trilhas de auditoria são gravadas pelo kernel e gerenciadas pelo daemon de auditoria, <a href="https://man.freebsd.org/cgi/man.cgi?query=auditd&amp;sektion=8&amp;format=html">auditd(8)</a>. Os administradores não devem tentar usar o <a href="https://man.freebsd.org/cgi/man.cgi?query=newsyslog.conf&amp;sektion=5&amp;format=html">newsyslog.conf(5)</a> ou outras ferramentas para rotacionar diretamente os logs de auditoria. Em vez disso, o <code>audit</code> deve ser usado para encerrar a auditoria, reconfigurar o sistema de auditoria e executar a rotação de log. O comando a seguir faz com que o daemon de auditoria crie um novo log de auditoria e sinalize ao kernel para alternar para o novo log. O log antigo será finalizado e renomeado, podendo então ser manipulado pelo administrador:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># audit -n</span></code></pre></div></div><div class=paragraph><p>Se <a href="https://man.freebsd.org/cgi/man.cgi?query=auditd&amp;sektion=8&amp;format=html">auditd(8)</a> não estiver em execução no momento, este comando falhará e uma mensagem de erro será apresentada.</p></div><div class=paragraph><p>Adicionar a seguinte linha ao <span class=filename>/etc/crontab</span> agendará essa rotação a cada doze horas:</p></div><div class="literalblock programlisting"><div class=content><pre>0     */12       *       *       *       root    /usr/sbin/audit -n</pre></div></div><div class=paragraph><p>A alteração terá efeito quando o <span class=filename>/etc/crontab</span> for salvo.</p></div><div class=paragraph><p>A rotação automática do arquivo de trilha de auditoria com base no tamanho do arquivo é possível usando <code>filesz</code> em <span class=filename>audit_control</span>, conforme descrito em <a href=#audit-auditcontrol>O arquivo <span class=filename>audit_control</span></a>.</p></div><div class=paragraph><p>Como os arquivos de trilha de auditoria podem se tornar muito grandes, geralmente é desejável compactar ou arquivar rastros depois que eles forem fechados pelo daemon de auditoria. O script <span class=filename>audit_warn</span> pode ser usado para executar operações personalizadas para uma variedade de eventos relacionados à auditoria, incluindo a terminação limpa de trilhas de auditoria quando elas são rotacionadas. Por exemplo, o seguinte pode ser adicionado ao <span class=filename>/etc/security/audit_warn</span> para compactar as trilhas de auditoria ao serem fechados:</p></div><div class="literalblock programlisting"><div class=content><pre>#
# Compress audit trail files on close.
#
if [ &#34;$1&#34; = closefile ]; then
        gzip -9 $2
fi</pre></div></div><div class=paragraph><p>Outras atividades de arquivamento podem incluir a cópia de arquivos de trilha para um servidor centralizado, a exclusão de arquivos de trilha antigos ou a redução da trilha de auditoria para remover registros desnecessários. Este script será executado somente quando os arquivos da trilha de auditoria forem finalizados de forma limpa, portanto, não serão executados em trilhas deixadas sem serem eliminadas após um desligamento incorreto.</p></div></div></div></div></div><div class=sect1><h2 id=disks>Capítulo 17. Armazenamento<a class=anchor href=#disks></a></h2><div class=sectionbody><div class=sect2><h3 id=disks-synopsis>17.1. Sinopse<a class=anchor href=#disks-synopsis></a></h3><div class=paragraph><p>Este capítulo aborda o uso de discos e mídia de armazenamento no FreeBSD. Isso inclui discos SCSI e IDE, mídias de CD e DVD, discos com suporte de memória e dispositivos de armazenamento USB.</p></div><div class=paragraph><p>Depois de ler este capítulo, você saberá:</p></div><div class=ulist><ul><li><p>Como adicionar discos rígidos adicionais a um sistema FreeBSD.</p></li><li><p>Como aumentar o tamanho da partição de um disco no FreeBSD.</p></li><li><p>Como configurar o FreeBSD para usar dispositivos de armazenamento USB.</p></li><li><p>Como usar mídias de CD e DVD em um sistema FreeBSD.</p></li><li><p>Como usar os programas de backup disponíveis no FreeBSD.</p></li><li><p>Como configurar discos de memória.</p></li><li><p>O que são snapshots de sistema de arquivos e como usá-los com eficiência.</p></li><li><p>Como usar cotas para limitar o uso de espaço em disco.</p></li><li><p>Como criptografar discos e swap para protegê-los contra invasores.</p></li><li><p>Como configurar uma rede de armazenamento altamente disponível.</p></li></ul></div><div class=paragraph><p>Antes de ler este capítulo, você deve:</p></div><div class=ulist><ul><li><p>Saiba como <a href=./#kernelconfig>configurar e instalar um novo kernel do FreeBSD</a>.</p></li></ul></div></div><div class=sect2><h3 id=disks-adding>17.2. Adicionando Discos<a class=anchor href=#disks-adding></a></h3><div class=paragraph><p>Esta seção descreve como adicionar um novo disco SATA a uma máquina que atualmente possui apenas uma única unidade. Primeiro, desligue o computador e instale a unidade no computador seguindo as instruções do fabricante do computador, controladora e unidade. Reinicialize o sistema e torne-se <code>root</code>.</p></div><div class=paragraph><p>Inspecione o arquivo <span class=filename>/var/run/dmesg.boot</span> para garantir que o novo disco foi encontrado. Neste exemplo, a unidade SATA recém-adicionada aparecerá como <span class=filename>ada1</span>.</p></div><div class=paragraph><p>Para este exemplo, uma única partição grande será criada no novo disco. O esquema de particionamento <a href=http://en.wikipedia.org/wiki/GUID_Partition_Table>GPT</a> será usado ao invés do esquema MBR, mais antigo e menos versátil.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Se o disco a ser adicionado não estiver em branco, as informações antigas da partição podem ser removidas com <code>gpart delete</code>. Veja <a href="https://man.freebsd.org/cgi/man.cgi?query=gpart&amp;sektion=8&amp;format=html">gpart(8)</a> para detalhes.</p></div></td></tr></tbody></table></div><div class=paragraph><p>O esquema de partição é criado e, em seguida, uma única partição é adicionada. Para melhorar o desempenho em discos mais recentes com tamanhos maiores de blocos de hardware, a partição está alinhada a divisões de um megabyte:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gpart create -s GPT ada1</span>
<span class=c># gpart add -t freebsd-ufs -a 1M ada1</span></code></pre></div></div><div class=paragraph><p>Dependendo do uso, várias partições menores podem ser desejadas. Veja <a href="https://man.freebsd.org/cgi/man.cgi?query=gpart&amp;sektion=8&amp;format=html">gpart(8)</a> para opções para criar partições menores que um disco inteiro.</p></div><div class=paragraph><p>As informações da partição de disco podem ser visualizadas com <code>gpart show</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% gpart show ada1
<span class=o>=&gt;</span>        34  1465146988  ada1  GPT  <span class=o>(</span>699G<span class=o>)</span>
          34        2014        - free -  <span class=o>(</span>1.0M<span class=o>)</span>
        2048  1465143296     1  freebsd-ufs  <span class=o>(</span>699G<span class=o>)</span>
  1465145344        1678        - free -  <span class=o>(</span>839K<span class=o>)</span></code></pre></div></div><div class=paragraph><p>Um sistema de arquivos é criado em uma nova partição no novo disco:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># newfs -U /dev/ada1p1</span></code></pre></div></div><div class=paragraph><p>Um diretório vazio é criado como um <em>ponto de montagem</em>, um local para montar o novo disco no sistema de arquivos do disco original:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mkdir /newdisk</span></code></pre></div></div><div class=paragraph><p>Finalmente, uma entrada é adicionada ao arquivo <span class=filename>/etc/fstab</span> para que o novo disco seja montado automaticamente na inicialização:</p></div><div class="literalblock programlisting"><div class=content><pre>/dev/ada1p1	/newdisk	ufs	rw	2	2</pre></div></div><div class=paragraph><p>O novo disco pode ser montado manualmente, sem reiniciar o sistema:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount /newdisk</span></code></pre></div></div></div><div class=sect2><h3 id=disks-growing>17.3. Redimensionando e Ampliando Discos<a class=anchor href=#disks-growing></a></h3><div class=paragraph><p>A capacidade de um disco pode aumentar sem alterações nos dados já presentes. Isso acontece normalmente com máquinas virtuais, quando o disco virtual torna-se muito pequeno e é ampliado. Às vezes, uma imagem de disco é gravada em um cartão de memória USB, mas não usa toda a capacidade. Aqui nós descrevemos como redimensionar ou <em>ampliar</em> o conteúdo do disco para aproveitar a capacidade aumentada.</p></div><div class=paragraph><p>Determine o nome do dispositivo do disco a ser redimensionado inspecionando o arquivo <span class=filename>/var/run/dmesg.boot</span>. Neste exemplo, há apenas um disco SATA no sistema, portanto a unidade aparecerá como <span class=filename>ada0</span>.</p></div><div class=paragraph><p>Liste as partições no disco para ver a configuração atual:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gpart show ada0</span>
<span class=o>=&gt;</span>      34  83886013  ada0  GPT  <span class=o>(</span>48G<span class=o>)</span> <span class=o>[</span>CORRUPT]
        34       128     1  freebsd-boot  <span class=o>(</span>64k<span class=o>)</span>
       162  79691648     2  freebsd-ufs  <span class=o>(</span>38G<span class=o>)</span>
  79691810   4194236     3  freebsd-swap  <span class=o>(</span>2G<span class=o>)</span>
  83886046         1        - free -  <span class=o>(</span>512B<span class=o>)</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Se o disco foi formatado com o esquema de particionamento <a href=http://en.wikipedia.org/wiki/GUID_Partition_Table>GPT</a>, ele pode ser exibido como "corrompido" porque a tabela de partições de backup GPT não está mais no final da unidade. Corrija a tabela de partições de backup com o <code>gpart</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gpart recover ada0</span>
ada0 recovered</code></pre></div></div></td></tr></tbody></table></div><div class=paragraph><p>Agora, o espaço adicional no disco está disponível para uso por uma nova partição ou uma partição existente pode ser expandida:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gpart show ada0</span>
<span class=o>=&gt;</span>       34  102399933  ada0  GPT  <span class=o>(</span>48G<span class=o>)</span>
         34        128     1  freebsd-boot  <span class=o>(</span>64k<span class=o>)</span>
        162   79691648     2  freebsd-ufs  <span class=o>(</span>38G<span class=o>)</span>
   79691810    4194236     3  freebsd-swap  <span class=o>(</span>2G<span class=o>)</span>
   83886046   18513921        - free -  <span class=o>(</span>8.8G<span class=o>)</span></code></pre></div></div><div class=paragraph><p>As partições só podem ser redimensionadas para um espaço livre contíguo. Aqui, a última partição no disco é a partição swap, mas a segunda partição é aquela que precisa ser redimensionada. As partições de Swap contêm apenas dados temporários, portanto, podem ser desmontadas, excluídas e, em seguida, recriadas a terceira partição após redimensionar a segunda partição.</p></div><div class=paragraph><p>Desative a partição de swap:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># swapoff /dev/ada0p3</span></code></pre></div></div><div class=paragraph><p>Exclua a terceira partição, especificada pela flag <code>-i</code>, do disco <em>ada0</em>.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gpart delete -i 3 ada0</span>
ada0p3 deleted
<span class=c># gpart show ada0</span>
<span class=o>=&gt;</span>       34  102399933  ada0  GPT  <span class=o>(</span>48G<span class=o>)</span>
         34        128     1  freebsd-boot  <span class=o>(</span>64k<span class=o>)</span>
        162   79691648     2  freebsd-ufs  <span class=o>(</span>38G<span class=o>)</span>
   79691810   22708157        - free -  <span class=o>(</span>10G<span class=o>)</span></code></pre></div></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Existe o risco de perda de dados ao modificar a tabela de partições de um sistema de arquivos montado. É melhor executar as etapas a seguir em um sistema de arquivos desmontado durante a execução de um dispositivo CD-ROM ou USB live. No entanto, se for absolutamente necessário, um sistema de arquivos montado pode ser redimensionado depois de desativar os recursos de segurança do GEOM:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl kern.geom.debugflags=16</span></code></pre></div></div></td></tr></tbody></table></div><div class=paragraph><p>Redimensione a partição, deixando espaço para recriar uma partição swap do tamanho desejado. A partição a ser redimensionada é especificada com <code>-i</code> e o novo tamanho desejado com <code>-s</code>. Opcionalmente, o alinhamento da partição é controlado com <code>-a</code>. Isso só modifica o tamanho da partição. O sistema de arquivos na partição será expandido em uma etapa separada.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gpart resize -i 2 -s 47G -a 4k ada0</span>
ada0p2 resized
<span class=c># gpart show ada0</span>
<span class=o>=&gt;</span>       34  102399933  ada0  GPT  <span class=o>(</span>48G<span class=o>)</span>
         34        128     1  freebsd-boot  <span class=o>(</span>64k<span class=o>)</span>
        162   98566144     2  freebsd-ufs  <span class=o>(</span>47G<span class=o>)</span>
   98566306    3833661        - free -  <span class=o>(</span>1.8G<span class=o>)</span></code></pre></div></div><div class=paragraph><p>Recrie a partição swap e ative-a. Se nenhum tamanho for especificado com <code>-s</code>, todo o espaço restante será usado:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gpart add -t freebsd-swap -a 4k ada0</span>
ada0p3 added
<span class=c># gpart show ada0</span>
<span class=o>=&gt;</span>       34  102399933  ada0  GPT  <span class=o>(</span>48G<span class=o>)</span>
         34        128     1  freebsd-boot  <span class=o>(</span>64k<span class=o>)</span>
        162   98566144     2  freebsd-ufs  <span class=o>(</span>47G<span class=o>)</span>
   98566306    3833661     3  freebsd-swap  <span class=o>(</span>1.8G<span class=o>)</span>
<span class=c># swapon /dev/ada0p3</span></code></pre></div></div><div class=paragraph><p>Aumente o sistema de arquivos UFS para usar a nova capacidade da partição redimensionada:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># growfs /dev/ada0p2</span>
Device is mounted read-write<span class=p>;</span> resizing will result <span class=k>in </span>temporary write suspension <span class=k>for</span> /.
It<span class=s1>&#39;s strongly recommended to make a backup before growing the file system.
OK to grow file system on /dev/ada0p2, mounted on /, from 38GB to 47GB? [Yes/No] Yes
super-block backups (for fsck -b #) at:
 80781312, 82063552, 83345792, 84628032, 85910272, 87192512, 88474752,
 89756992, 91039232, 92321472, 93603712, 94885952, 96168192, 97450432</span></code></pre></div></div><div class=paragraph><p>Se o sistema de arquivos for ZFS, o redimensionamento será acionado pela execução do subcomando <code>online</code> com <code>-e</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zpool online -e zroot /dev/ada0p2</span></code></pre></div></div><div class=paragraph><p>Tanto a partição quanto o sistema de arquivos foram redimensionados para usar o espaço em disco recém-disponível.</p></div></div><div class=sect2><h3 id=usb-disks>17.4. Dispositivos de Armazenamento USB<a class=anchor href=#usb-disks></a></h3><div class=paragraph><p>Muitas soluções de armazenamento externo, como discos rígidos, thumbdrives USB e gravadores de CD e DVD, usam o Universal Serial Bus ( USB ). O FreeBSD fornece suporte para dispositivos USB 1.x, 2.0 e 3.0.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>O suporte a USB 3.0 não é compatível com alguns hardwares, incluindo os chipsets Haswell (Lynx Point). Se o FreeBSD inicializar com uma mensagem <code>falhou com erro 19</code>, desative xHCI/USB3 na BIOS.</p></div></td></tr></tbody></table></div><div class=paragraph><p>O suporte para dispositivos de armazenamento USB é embutido no kernel <span class=filename>GENERIC</span>. Para um kernel personalizado, certifique-se de que as seguintes linhas estejam presentes no arquivo de configuração do kernel:</p></div><div class="literalblock programlisting"><div class=content><pre>device scbus	# SCSI bus (required for ATA/SCSI)
device da	# Direct Access (disks)
device pass	# Passthrough device (direct ATA/SCSI access)
device uhci	# provides USB 1.x support
device ohci	# provides USB 1.x support
device ehci	# provides USB 2.0 support
device xhci	# provides USB 3.0 support
device usb	# USB Bus (required)
device umass	# Disks/Mass storage - Requires scbus and da
device cd	# needed for CD and DVD burners</pre></div></div><div class=paragraph><p>O FreeBSD usa o driver <a href="https://man.freebsd.org/cgi/man.cgi?query=umass&amp;sektion=4&amp;format=html">umass(4)</a> que usa o subsistema SCSI para acessar o armazenamento de dispositivos USB. Como qualquer dispositivo USB será visto como um dispositivo SCSI pelo sistema, se o dispositivo USB for um gravador de CD ou DVD, <em>não</em> inclua <code>device atapicam</code> em um arquivo de configuração do kernel personalizado.</p></div><div class=paragraph><p>O restante desta seção demonstra como verificar se um dispositivo de armazenamento USB é reconhecido pelo FreeBSD e como configurar o dispositivo para que ele possa ser usado.</p></div><div class=sect3><h4 id=_configuração_de_dispositivo>17.4.1. Configuração de Dispositivo<a class=anchor href=#_configuração_de_dispositivo></a></h4><div class=paragraph><p>Para testar a configuração USB, conecte o dispositivo USB. Use <code>dmesg</code> para confirmar que a unidade aparece no buffer de mensagens do sistema. Deve parecer algo como isto:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>umass0: &lt;STECH Simple Drive, class 0/0, rev 2.00/1.04, addr 3&gt; on usbus0
umass0:  SCSI over Bulk-Only<span class=p>;</span> quirks <span class=o>=</span> 0x0100
umass0:4:0:-1: Attached to scbus4
da0 at umass-sim0 bus 0 scbus4 target 0 lun 0
da0: &lt;STECH Simple Drive 1.04&gt; Fixed Direct Access SCSI-4 device
da0: Serial Number WD-WXE508CAN263
da0: 40.000MB/s transfers
da0: 152627MB <span class=o>(</span>312581808 512 byte sectors: 255H 63S/T 19457C<span class=o>)</span>
da0: <span class=nv>quirks</span><span class=o>=</span>0x2&lt;NO_6_BYTE&gt;</code></pre></div></div><div class=paragraph><p>A marca, o nó de dispositivo (<span class=filename>da0</span>), a velocidade e o tamanho serão diferentes de acordo com o dispositivo.</p></div><div class=paragraph><p>Como o dispositivo USB é visto como um SCSI, o <code>camcontrol</code> pode ser usado para listar os dispositivos de armazenamento USB conectados ao sistema:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># camcontrol devlist</span>
&lt;STECH Simple Drive 1.04&gt;          at scbus4 target 0 lun 0 <span class=o>(</span>pass3,da0<span class=o>)</span></code></pre></div></div><div class=paragraph><p>Alternativamente, o <code>usbconfig</code> pode ser usado para listar o dispositivo. Consulte o <a href="https://man.freebsd.org/cgi/man.cgi?query=usbconfig&amp;sektion=8&amp;format=html">usbconfig(8)</a> para obter mais informações sobre este comando.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># usbconfig</span>
ugen0.3: &lt;Simple Drive STECH&gt; at usbus0, <span class=nv>cfg</span><span class=o>=</span>0 <span class=nv>md</span><span class=o>=</span>HOST <span class=nv>spd</span><span class=o>=</span>HIGH <span class=o>(</span>480Mbps<span class=o>)</span> <span class=nv>pwr</span><span class=o>=</span>ON <span class=o>(</span>2mA<span class=o>)</span></code></pre></div></div><div class=paragraph><p>Se o dispositivo não tiver sido formatado, consulte <a href=#disks-adding>Adicionando Discos</a> para obter instruções sobre como formatar e criar partições na unidade USB. Se a unidade vier com um sistema de arquivos, ela pode ser montada pelo <code>root</code> usando as instruções em <a href=./#mount-unmount>Montando e Desmontando Sistemas de Arquivos</a>.</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Permitir que usuários não confiáveis montem mídia arbitrária, ativando <code>vfs.usermount</code> como descrito abaixo, não deve ser considerado seguro do ponto de vista da segurança. A maioria dos sistemas de arquivos não foi criada para proteger contra dispositivos maliciosos.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Para tornar o dispositivo montável como um usuário normal, uma solução é tornar todos os usuários do dispositivo membros do grupo <code>operator</code> usando <a href="https://man.freebsd.org/cgi/man.cgi?query=pw&amp;sektion=8&amp;format=html">pw(8)</a>. Em seguida, certifique-se de que <code>operator</code> possa ler e gravar o dispositivo adicionando estas linhas ao <span class=filename>/etc/devfs.rules</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>[localrules=5]
add path &#39;da*&#39; mode 0660 group operator</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Se discos internos SCSI também estiverem instalados no sistema, altere a segunda linha da seguinte maneira:</p></div><div class="literalblock programlisting"><div class=content><pre>add path &#39;da[3-9]*&#39; mode 0660 group operator</pre></div></div><div class=paragraph><p>Isso excluirá os três primeiros discos SCSI (<span class=filename>da0</span> para <span class=filename>da2</span>) pertencentes ao grupo <code>operator</code>. Substitua <em>3</em> pelo número de discos SCSI internos. Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=devfs.rules&amp;sektion=5&amp;format=html">devfs.rules(5)</a> para obter mais informações sobre esse arquivo.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Em seguida, ative o conjunto de regras no arquivo <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>devfs_system_ruleset=&#34;localrules&#34;</pre></div></div><div class=paragraph><p>Em seguida, instrua o sistema para permitir que usuários comuns montem sistemas de arquivos incluindo a seguinte linha no arquivo <span class=filename>/etc/sysctl.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>vfs.usermount=1</pre></div></div><div class=paragraph><p>Como isso só entra em vigor após a próxima reinicialização, use <code>sysctl</code> para definir essa variável agora:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl vfs.usermount=1</span>
vfs.usermount: 0 -&gt; 1</code></pre></div></div><div class=paragraph><p>A etapa final é criar um diretório no qual o sistema de arquivos deve ser montado. Esse diretório precisa pertencer ao usuário que deve montar o sistema de arquivos. Uma maneira de fazer isso é para o <code>root</code> criar um subdiretório de propriedade daquele usuário como <span class=filename>/mnt/username</span>. No exemplo a seguir, substitua <em>username</em> pelo nome de login do usuário e <em>usergroup</em> pelo grupo principal do usuário:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mkdir /mnt/username</span>
<span class=c># chown username:usergroup /mnt/username</span></code></pre></div></div><div class=paragraph><p>Suponha que um thumbdrive USB esteja conectado e um dispositivo <span class=filename>/dev/da0s1</span> apareça. Se o dispositivo estiver formatado com um sistema de arquivos FAT, o usuário poderá montá-lo usando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% mount <span class=nt>-t</span> msdosfs <span class=nt>-o</span> <span class=nt>-m</span><span class=o>=</span>644,-M<span class=o>=</span>755 /dev/da0s1 /mnt/username</code></pre></div></div><div class=paragraph><p>Antes que o dispositivo possa ser desconectado, ele <em>deve</em> ser desmontado primeiro:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% umount /mnt/username</code></pre></div></div><div class=paragraph><p>Após a remoção do dispositivo, o buffer de mensagens do sistema mostrará mensagens semelhantes às seguintes:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>umass0: at uhub3, port 2, addr 3 <span class=o>(</span>disconnected<span class=o>)</span>
da0 at umass-sim0 bus 0 scbus4 target 0 lun 0
da0: &lt;STECH Simple Drive 1.04&gt; s/n WD-WXE508CAN263          detached
<span class=o>(</span>da0:umass-sim0:0:0:0<span class=o>)</span>: Periph destroyed</code></pre></div></div></div><div class=sect3><h4 id=_montando_automaticamente_uma_mídia_removível>17.4.2. Montando Automaticamente Uma Mídia Removível<a class=anchor href=#_montando_automaticamente_uma_mídia_removível></a></h4><div class=paragraph><p>Dispositivos USB podem ser montados automaticamente removendo o comentário desta linha no arquivo <span class=filename>/etc/auto_master</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>/media		<span class=nt>-media</span>		<span class=nt>-nosuid</span></code></pre></div></div><div class=paragraph><p>Então adicione estas linhas ao arquivo <span class=filename>/etc/devd.conf</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>notify 100 <span class=o>{</span>
	match <span class=s2>&#34;system&#34;</span> <span class=s2>&#34;GEOM&#34;</span><span class=p>;</span>
	match <span class=s2>&#34;subsystem&#34;</span> <span class=s2>&#34;DEV&#34;</span><span class=p>;</span>
	action <span class=s2>&#34;/usr/sbin/automount -c&#34;</span><span class=p>;</span>
<span class=o>}</span><span class=p>;</span></code></pre></div></div><div class=paragraph><p>Recarregue a configuração se <a href="https://man.freebsd.org/cgi/man.cgi?query=autofs&amp;sektion=5&amp;format=html">autofs(5)</a> e <a href="https://man.freebsd.org/cgi/man.cgi?query=devd&amp;sektion=8&amp;format=html">devd(8)</a> já estiverem em execução:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service automount restart</span>
<span class=c># service devd restart</span></code></pre></div></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=autofs&amp;sektion=5&amp;format=html">autofs(5)</a> pode ser configurado para iniciar no boot, adicionando esta linha ao arquivo <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>autofs_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=autofs&amp;sektion=5&amp;format=html">autofs(5)</a> requer que o <a href="https://man.freebsd.org/cgi/man.cgi?query=devd&amp;sektion=8&amp;format=html">devd(8)</a> esteja ativado, como é por padrão.</p></div><div class=paragraph><p>Inicie os serviços imediatamente com:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service automount start</span>
<span class=c># service automountd start</span>
<span class=c># service autounmountd start</span>
<span class=c># service devd start</span></code></pre></div></div><div class=paragraph><p>Cada sistema de arquivos que pode ser montado automaticamente aparece como um diretório em <span class=filename>/media/</span>. O diretório é nomeado após o rótulo do sistema de arquivos. Se o rótulo estiver ausente, o diretório será nomeado após o nó do dispositivo.</p></div><div class=paragraph><p>O sistema de arquivos é montado de forma transparente no primeiro acesso e desmontado após um período de inatividade. Unidades montadas automaticamente também podem ser desmontadas manualmente:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># automount -fu</span></code></pre></div></div><div class=paragraph><p>Este mecanismo é normalmente usado para cartões de memória e cartões de memória USB. Pode ser usado com qualquer dispositivo de bloco, incluindo unidades ópticas ou iSCSILUNs.</p></div></div></div><div class=sect2><h3 id=creating-cds>17.5. Criando e Usando Mídia em CD<a class=anchor href=#creating-cds></a></h3><div class=paragraph><p>A mídia em disco compacto (CD) fornece vários recursos que os diferenciam dos discos convencionais. Eles são projetados para que possam ser lidos continuamente sem atrasos para mover a cabeça entre as trilhas. Embora a mídia CD tenha faixas, elas se referem a uma seção de dados a ser lida continuamente e não a uma propriedade física do disco. O sistema de arquivos ISO 9660 foi projetado para lidar com essas diferenças.</p></div><div class=paragraph><p>A Coleção de Ports do FreeBSD fornece vários utilitários para gravar e duplicar áudio e dados de CDs. Este capítulo demonstra o uso de vários utilitários de linha de comando. Para o software de gravação de CD com um utilitário gráfico, considere instalar os pacotes ou ports <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/xcdroast/>sysutils/xcdroast</a> ou <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/k3b/>sysutils/k3b</a>.</p></div><div class=sect3><h4 id=atapicam>17.5.1. Dispositivos Suportados<a class=anchor href=#atapicam></a></h4><div class=paragraph><p>O kernel <span class=filename>GENERIC</span> fornece suporte para SCSI, USB, e leitores e gravadores de CDATAPI. Se um kernel personalizado for usado, as opções que precisam estar presentes no arquivo de configuração do kernel variam de acordo com o tipo de dispositivo.</p></div><div class=paragraph><p>Para um gravador SCSI, verifique se essas opções estão presentes:</p></div><div class="literalblock programlisting"><div class=content><pre>device scbus	# SCSI bus (required for ATA/SCSI)
device da	# Direct Access (disks)
device pass	# Passthrough device (direct ATA/SCSI access)
device cd	# needed for CD and DVD burners</pre></div></div><div class=paragraph><p>Para um gravador de USB, verifique se essas opções estão presentes:</p></div><div class="literalblock programlisting"><div class=content><pre>device scbus	# SCSI bus (required for ATA/SCSI)
device da	# Direct Access (disks)
device pass	# Passthrough device (direct ATA/SCSI access)
device cd	# needed for CD and DVD burners
device uhci	# provides USB 1.x support
device ohci	# provides USB 1.x support
device ehci	# provides USB 2.0 support
device xhci	# provides USB 3.0 support
device usb	# USB Bus (required)
device umass	# Disks/Mass storage - Requires scbus and da</pre></div></div><div class=paragraph><p>Para um gravador ATAPI, verifique se essas opções estão presentes:</p></div><div class="literalblock programlisting"><div class=content><pre>device ata	# Legacy ATA/SATA controllers
device scbus	# SCSI bus (required for ATA/SCSI)
device pass	# Passthrough device (direct ATA/SCSI access)
device cd	# needed for CD and DVD burners</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Nas versões do FreeBSD anteriores a 10.x, esta linha também é necessária no arquivo de configuração do kernel se o gravador for um dispositivo ATAPI:</p></div><div class="literalblock programlisting"><div class=content><pre>device atapicam</pre></div></div><div class=paragraph><p>Como alternativa, esse driver pode ser carregado no momento da inicialização adicionando a seguinte linha ao arquivo <span class=filename>/boot/loader.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>atapicam_load=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Isso exigirá uma reinicialização do sistema, pois esse driver só pode ser carregado no momento da inicialização.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Para verificar se o FreeBSD reconhece o dispositivo, execute o <code>dmesg</code> e procure por uma entrada para o dispositivo. Nos sistemas anteriores a 10.x, o nome do dispositivo na primeira linha da saída será <span class=filename>acd0</span> em vez de <span class=filename>cd0</span>.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% dmesg | <span class=nb>grep cd
</span>cd0 at ahcich1 bus 0 scbus1 target 0 lun 0
cd0: &lt;HL-DT-ST DVDRAM GU70N LT20&gt; Removable CD-ROM SCSI-0 device
cd0: Serial Number M3OD3S34152
cd0: 150.000MB/s transfers <span class=o>(</span>SATA 1.x, UDMA6, ATAPI 12bytes, PIO 8192bytes<span class=o>)</span>
cd0: Attempt to query device size failed: NOT READY, Medium not present - tray closed</code></pre></div></div></div><div class=sect3><h4 id=cdrecord>17.5.2. Gravando um CD<a class=anchor href=#cdrecord></a></h4><div class=paragraph><p>No FreeBSD, <code>cdrecord</code> pode ser usado para gravar CDs. Este comando é instalado com o pacote ou port <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/cdrtools/>sysutils/cdrtools</a>.</p></div><div class=paragraph><p>Enquanto o <code>cdrecord</code> tem muitas opções, o uso básico é simples. Especifique o nome do arquivo ISO para gravar e, se o sistema tiver vários dispositivos de gravação, especifique o nome do dispositivo a ser usado:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cdrecord dev=device imagefile.iso</span></code></pre></div></div><div class=paragraph><p>Para determinar o nome do dispositivo do gravador, use <code>-scanbus</code>, que pode produzir resultados como este:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cdrecord -scanbus</span>
ProDVD-ProBD-Clone 3.00 <span class=o>(</span>amd64-unknown-freebsd10.0<span class=o>)</span> Copyright <span class=o>(</span>C<span class=o>)</span> 1995-2010 Jörg Schilling
Using libscg version <span class=s1>&#39;schily-0.9&#39;</span>
scsibus0:
        0,0,0     0<span class=o>)</span> <span class=s1>&#39;SEAGATE &#39;</span> <span class=s1>&#39;ST39236LW       &#39;</span> <span class=s1>&#39;0004&#39;</span> Disk
        0,1,0     1<span class=o>)</span> <span class=s1>&#39;SEAGATE &#39;</span> <span class=s1>&#39;ST39173W        &#39;</span> <span class=s1>&#39;5958&#39;</span> Disk
        0,2,0     2<span class=o>)</span> <span class=k>*</span>
        0,3,0     3<span class=o>)</span> <span class=s1>&#39;iomega  &#39;</span> <span class=s1>&#39;jaz 1GB         &#39;</span> <span class=s1>&#39;J.86&#39;</span> Removable Disk
        0,4,0     4<span class=o>)</span> <span class=s1>&#39;NEC     &#39;</span> <span class=s1>&#39;CD-ROM DRIVE:466&#39;</span> <span class=s1>&#39;1.26&#39;</span> Removable CD-ROM
        0,5,0     5<span class=o>)</span> <span class=k>*</span>
        0,6,0     6<span class=o>)</span> <span class=k>*</span>
        0,7,0     7<span class=o>)</span> <span class=k>*</span>
scsibus1:
        1,0,0   100<span class=o>)</span> <span class=k>*</span>
        1,1,0   101<span class=o>)</span> <span class=k>*</span>
        1,2,0   102<span class=o>)</span> <span class=k>*</span>
        1,3,0   103<span class=o>)</span> <span class=k>*</span>
        1,4,0   104<span class=o>)</span> <span class=k>*</span>
        1,5,0   105<span class=o>)</span> <span class=s1>&#39;YAMAHA  &#39;</span> <span class=s1>&#39;CRW4260         &#39;</span> <span class=s1>&#39;1.0q&#39;</span> Removable CD-ROM
        1,6,0   106<span class=o>)</span> <span class=s1>&#39;ARTEC   &#39;</span> <span class=s1>&#39;AM12S           &#39;</span> <span class=s1>&#39;1.06&#39;</span> Scanner
        1,7,0   107<span class=o>)</span> <span class=k>*</span></code></pre></div></div><div class=paragraph><p>Localize a entrada para o gravador de CD e use os três números separados por vírgulas como o valor para <code>dev</code>. Nesse caso, o dispositivo gravador Yamaha é <code>1,5,0</code>, portanto, a entrada apropriada para especificar esse dispositivo é <code>dev=1,5,0</code>. Consulte a página de manual do <code>cdrecord</code> para outras formas de especificar este valor e informações sobre como gravar faixas de áudio e controlar a velocidade de gravação.</p></div><div class=paragraph><p>Como alternativa, execute o seguinte comando para obter o endereço do dispositivo do gravador:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># camcontrol devlist</span>
&lt;MATSHITA CDRW/DVD UJDA740 1.00&gt;   at scbus1 target 0 lun 0 <span class=o>(</span>cd0,pass0<span class=o>)</span></code></pre></div></div><div class=paragraph><p>Use os valores numéricos para <code>scbus</code>, <code>target</code> e <code>lun</code>. Para este exemplo, <code>1,0,0</code> é o nome do dispositivo a ser usado.</p></div></div><div class=sect3><h4 id=mkisofs>17.5.3. Escrevendo Dados em um Sistema de Arquivos ISO<a class=anchor href=#mkisofs></a></h4><div class=paragraph><p>Para produzir um CD de dados, os arquivos de dados que compõem as faixas no CD devem ser preparados antes que possam ser gravados no CD. No FreeBSD, <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/cdrtools/>sysutils/cdrtools</a> instala o <code>mkisofs</code>, que pode ser usado para produzir um sistema de arquivos ISO 9660 que é uma imagem de uma árvore de diretórios dentro um sistema de arquivos UNIX™. O uso mais simples é especificar o nome do arquivo ISO para criar e o caminho para os arquivos a serem colocados no sistema de arquivos ISO 9660:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mkisofs -o imagefile.iso /path/to/tree</span></code></pre></div></div><div class=paragraph><p>Este comando mapeia os nomes dos arquivos no caminho especificado para os nomes que se ajustam às limitações do sistema de arquivos padrão ISO 9660 e excluirá arquivos que não atendem ao padrão para o sistemas de arquivos ISO.</p></div><div class=paragraph><p>Várias opções estão disponíveis para superar as restrições impostas pelo padrão. Em particular, <code>-R</code> permite que as extensões Rock Ridge comuns aos sistemas UNIX™ e <code>-J</code> ativem as extensões Joliet usadas por sistemas Microsoft™.</p></div><div class=paragraph><p>Para CDs que serão usados apenas em sistemas FreeBSD, <code>-U</code> pode ser usado para desabilitar todas as restrições de nome de arquivo. Quando usado com <code>-R</code>, ele produz uma imagem do sistema de arquivos que é idêntica à árvore FreeBSD especificada, mesmo se violar o padrão ISO 9660.</p></div><div class=paragraph><p>A última opção de uso geral é <code>-b</code>. Isso é usado para especificar a localização de uma imagem de inicialização para uso na produção de um CD inicializável "El Torito". Essa opção usa um argumento que é o caminho para uma imagem de inicialização a partir do topo da árvore que está sendo gravada no CD. Por padrão, o <code>mkisofs</code> cria uma imagem ISO no modo de "emulação de disquete" e, portanto, espera que a imagem de inicialização tenha exatamente 1200, 1440 ou 2880 KB de tamanho. Alguns gerenciadores de inicialização, como o usado pela mídia de distribuição do FreeBSD, não utilizam o modo de emulação. Nesse caso, <code>-no-emul-boot</code> deve ser usado. Então, se <span class=filename>/tmp/myboot</span> possuir um sistema FreeBSD inicializável com a imagem de inicialização em <span class=filename>/tmp/myboot/boot/cdboot</span>, este comando produziria <span class=filename>/tmp/bootable.iso</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mkisofs -R -no-emul-boot -b boot/cdboot -o /tmp/bootable.iso /tmp/myboot</span></code></pre></div></div><div class=paragraph><p>A imagem ISO resultante pode ser montada como um disco de memória com:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mdconfig -a -t vnode -f /tmp/bootable.iso -u 0</span>
<span class=c># mount -t cd9660 /dev/md0 /mnt</span></code></pre></div></div><div class=paragraph><p>Pode-se então verificar se <span class=filename>/mnt</span> e <span class=filename>/tmp/myboot</span> são idênticos.</p></div><div class=paragraph><p>Existem muitas outras opções disponíveis para <code>mkisofs</code> para ajustar seu comportamento. Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=mkisofs&amp;sektion=8&amp;format=html">mkisofs(8)</a> para obter detalhes.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>É possível copiar um CD de dados para um arquivo de imagem que seja funcionalmente equivalente ao arquivo de imagem criado com <code>mkisofs</code>. Para fazer isso, use <span class=filename>dd</span> com o nome do dispositivo como o arquivo de entrada e o nome do ISO para criar como o arquivo de saída:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dd if=/dev/cd0 of=file.iso bs=2048</span></code></pre></div></div><div class=paragraph><p>O arquivo de imagem resultante pode ser gravado em CD, conforme descrito em <a href=#cdrecord>Gravando um CD</a>.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=mounting-cd>17.5.4. Usando CDs de Dados<a class=anchor href=#mounting-cd></a></h4><div class=paragraph><p>Uma vez que uma ISO tenha sido gravada em um CD, ela pode ser montada especificando o tipo de sistema de arquivos, o nome do dispositivo que contém o CD e um ponto de montagem existente:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount -t cd9660 /dev/cd0 /mnt</span></code></pre></div></div><div class=paragraph><p>Como <code>mount</code> assume que um sistema de arquivos é do tipo <code>ufs</code>, um erro <code>Incorrect super block</code> ocorrerá se <code>-t cd9660</code> não está incluído ao montar um arquivo de dados CD.</p></div><div class=paragraph><p>Embora qualquer CD de dados possa ser montado dessa forma, discos com determinadas extensões ISO 9660 podem se comportar de maneira estranha. Por exemplo, os discos Joliet armazenam todos os nomes de arquivos em caracteres Unicode de dois bytes. Se alguns caracteres não ingleses aparecerem como pontos de interrogação, especifique o conjunto de caracteres local com <code>-C</code>. Para mais informações, consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=mount_cd9660&amp;sektion=8&amp;format=html">mount_cd9660(8)</a>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Para fazer esta conversão de caracteres com a ajuda de <code>-C</code>, o kernel requer que o módulo <span class=filename>cd9660_iconv.ko</span> seja carregado. Isto pode ser feito adicionando esta linha ao arquivo <span class=filename>loader.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>cd9660_iconv_load=&#34;YES&#34;</pre></div></div><div class=paragraph><p>e reinicializando a máquina, ou carregando diretamente o módulo com <code>kldload</code>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Ocasionalmente, <code>Device not configured</code> será exibido ao tentar montar um CD de dados. Isso geralmente significa que a unidade de CD não detectou um disco na bandeja ou que a unidade não está visível no barramento. Pode levar alguns segundos para que uma unidade de CD detecte a mídia, por isso, seja paciente.</p></div><div class=paragraph><p>Às vezes, uma unidade de CDSCSI pode ser perdida porque não teve tempo suficiente para responder à reinicialização do barramento. Para resolver isso, um kernel personalizado pode ser criado, o que aumenta o delay SCSI padrão. Adicione a seguinte opção ao arquivo de configuração do kernel personalizado e reconstrua o kernel usando as instruções em <a href=./#kernelconfig-building>Criando e Instalando um Kernel Customizado</a>:</p></div><div class="literalblock programlisting"><div class=content><pre>options SCSI_DELAY=15000</pre></div></div><div class=paragraph><p>Isso faz com que o barramento SCSI faça uma pausa de 15 segundos durante a inicialização, para dar à unidade de CD todas as chances possíveis de responder à reinicialização do barramento.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>É possível gravar um arquivo diretamente no CD, sem criar um sistema de arquivos ISO 9660. Isso é conhecido como gravação de dados brutos em CD e algumas pessoas fazem isso para fins de backup.</p></div><div class=paragraph><p>Este tipo de disco não pode ser montado como um CD de dados normal. Para recuperar os dados gravados em um CD, os dados devem ser lidos no nó do dispositivo bruto. Por exemplo, este comando irá extrair um arquivo tar compactado localizado no segundo dispositivo de CD para o diretório de trabalho atual:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># tar xzvf /dev/cd1</span></code></pre></div></div><div class=paragraph><p>Para montar um CD de dados, os dados devem ser escritos usando <code>mkisofs</code>.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=duplicating-audiocds>17.5.5. Duplicando CDs de Áudio<a class=anchor href=#duplicating-audiocds></a></h4><div class=paragraph><p>Para duplicar um CD de áudio, extraia os dados de áudio do CD para uma série de arquivos e, em seguida, grave esses arquivos em um CD em branco.</p></div><div class=paragraph><p><a href=#using-cdrecord>Duplicando um CD de Áudio</a> descreve como duplicar e gravar um CD de áudio. Se a versão do FreeBSD for menor que 10.0 e o dispositivo for ATAPI, o módulo <code>atapicam</code> deve ser carregado primeiro usando as instruções em <a href=#atapicam>Dispositivos Suportados</a>.</p></div><div id=using-cdrecord class="exampleblock procedure"><div class=content><div class=paragraph><p><strong>Procedure: Duplicando um CD de Áudio</strong></p></div><div class="olist arabic"><ol class=arabic><li><p>O pacote ou port <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/cdrtools/>sysutils/cdrtools</a> instala o <code>cdda2wav</code>. Este comando pode ser usado para extrair todas as faixas de áudio, com cada faixa gravada em um arquivo WAV separado no diretório de trabalho atual:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% cdda2wav <span class=nt>-vall</span> <span class=nt>-B</span> <span class=nt>-Owav</span></code></pre></div></div><div class=paragraph><p>Um nome de dispositivo não precisa ser especificado se houver apenas um dispositivo de CD no sistema. Consulte a página de manual <code>cdda2wav</code> para obter instruções sobre como especificar um dispositivo e aprender mais sobre as outras opções disponíveis para este comando.</p></div></li><li><p>Use o <code>cdrecord</code> para escrever os arquivos <span class=filename>.wav</span>:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% cdrecord <span class=nt>-v</span> <span class=nv>dev</span><span class=o>=</span>2,0 <span class=nt>-dao</span> <span class=nt>-useinfo</span>  <span class=k>*</span>.wav</code></pre></div></div><div class=paragraph><p>Certifique-se de que <em>2,0</em> esteja configurado adequadamente, conforme descrito em <a href=#cdrecord>Gravando um CD</a>.</p></div></li></ol></div></div></div></div></div><div class=sect2><h3 id=creating-dvds>17.6. Criando e Usando Mídia de DVD<a class=anchor href=#creating-dvds></a></h3><div class=paragraph><p>Comparado ao CD, o DVD é a próxima geração de tecnologia de armazenamento de mídia ótica. O DVD pode conter mais dados do que qualquer CD e é o padrão para publicação de vídeos.</p></div><div class=paragraph><p>Cinco formatos graváveis físicos podem ser definidos para um DVD gravável:</p></div><div class=ulist><ul><li><p>DVD-R: Este foi o primeiro formato gravável disponível em DVD. O padrão DVD-R é definido pelo <a href=http://www.dvdforum.org/forum.shtml>DVD Forum</a>. Este formato é escrito uma vez.</p></li><li><p>DVD-RW: Esta é a versão regravável do padrão DVD-R. Um DVD-RW pode ser reescrito cerca de 1000 vezes.</p></li><li><p>DVD-RAM: Este é um formato regravável que pode ser visto como um disco rígido removível. No entanto, esta mídia não é compatível com a maioria das unidades e reprodutores de DVD-Video DVD-ROM, pois apenas alguns gravadores de DVD suportam o formato DVD-RAM. Consulte <a href=#creating-dvd-ram>Usando um DVD-RAM</a> para mais informações sobre o uso de DVD-RAM.</p></li><li><p>DVD+RW: Este é um formato regravável definido pelo <a href=https://en.wikipedia.org/wiki/DVD%2BRW_Alliance>DVD+RW Alliance</a>. Um DVD+RW pode ser reescrito cerca de 1000 vezes.</p></li><li><p>DVD+R: Este formato é a variação de gravação do formato DVD+RW.</p></li></ul></div><div class=paragraph><p>Um DVD gravável de camada única pode armazenar até 4,700,000,000 bytes, o que é, na verdade, 4.38 GB ou 4485 MB, pois 1 kilobyte é 1024 bytes.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Uma distinção deve ser feita entre a mídia física e a aplicação. Por exemplo, um DVD-Vídeo é um layout de arquivo específico que pode ser gravado em qualquer mídia física DVD gravável, como DVD-R, DVD+R ou DVD-RW. Antes de escolher o tipo de mídia, verifique se o gravador e o reprodutor de DVD-Video são compatíveis com a mídia em questão.</p></div></td></tr></tbody></table></div><div class=sect3><h4 id=_configuração>17.6.1. Configuração<a class=anchor href=#_configuração></a></h4><div class=paragraph><p>Para executar a gravação de um DVD, use <a href="https://man.freebsd.org/cgi/man.cgi?query=growisofs&amp;sektion=1&amp;format=html">growisofs(1)</a>. Este comando é parte dos utilitários <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/dvd+rw-tools/>sysutils/dvd+rw-tools</a> que suportam todos os tipos de mídia DVD.</p></div><div class=paragraph><p>Estas ferramentas usam o subsistema SCSI para acessar os dispositivos, portanto <a href=#atapicam>suporte a ATAPI/CAM</a> deve ser carregado ou estaticamente compilado no kernel. Este suporte não é necessário se o gravador usar a interface USB. Consulte <a href=#usb-disks>Dispositivos de Armazenamento USB</a> para mais detalhes sobre a configuração do dispositivo USB.</p></div><div class=paragraph><p>O acesso DMA também deve estar ativado para dispositivos ATAPI, adicionando a seguinte linha ao arquivo <span class=filename>/boot/loader.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>hw.ata.atapi_dma=&#34;1&#34;</pre></div></div><div class=paragraph><p>Antes de tentar usar dvd+rw-tools, consulte o <a href=http://fy.chalmers.se/~appro/linux/DVD+RW/hcn.html>Notas de compatibilidade de hardware</a>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Para uma interface gráfica de usuário, considere o uso de <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/k3b/>sysutils/k3b</a> que fornece uma interface amigável para <a href="https://man.freebsd.org/cgi/man.cgi?query=growisofs&amp;sektion=1&amp;format=html">growisofs(1)</a> e muitas outras ferramentas de gravação.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=_gravando_dvds_de_dados>17.6.2. Gravando DVDs de Dados<a class=anchor href=#_gravando_dvds_de_dados></a></h4><div class=paragraph><p>Já que <a href="https://man.freebsd.org/cgi/man.cgi?query=growisofs&amp;sektion=1&amp;format=html">growisofs(1)</a> é um front-end para <a href=#mkisofs>mkisofs</a>, ele invocará <a href="https://man.freebsd.org/cgi/man.cgi?query=mkisofs&amp;sektion=8&amp;format=html">mkisofs(8)</a> para criar o layout do sistema de arquivos e executar a gravação no DVD . Isso significa que uma imagem dos dados não precisa ser criada antes do processo de gravação.</p></div><div class=paragraph><p>Para gravar em um DVD+R ou DVD-R os dados em <span class=filename>/path/to/data</span>, use o seguinte comando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># growisofs -dvd-compat -Z /dev/cd0 -J -R /path/to/data</span></code></pre></div></div><div class=paragraph><p>Neste exemplo, <code>-J -R</code> é passado para <a href="https://man.freebsd.org/cgi/man.cgi?query=mkisofs&amp;sektion=8&amp;format=html">mkisofs(8)</a> para criar um sistemas de arquivos ISO 9660 com extensões Joliet e Rock Ridge. Consulte o <a href="https://man.freebsd.org/cgi/man.cgi?query=mkisofs&amp;sektion=8&amp;format=html">mkisofs(8)</a> para obter mais detalhes.</p></div><div class=paragraph><p>Para a gravação inicial da sessão, <code>-Z</code> é usado para sessões únicas e múltiplas. Substitua <em>/dev/cd0</em>, com o nome do dispositivo de DVD. O uso de <code>-dvd-compat</code> indica que o disco será fechado e que a gravação será inaplicável. Isso também deve fornecer melhor compatibilidade de mídia com unidades DVD-ROM.</p></div><div class=paragraph><p>Para gravar uma imagem pré-masterizada, como <em>imagefile.iso</em>, use:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># growisofs -dvd-compat -Z /dev/cd0=imagefile.iso</span></code></pre></div></div><div class=paragraph><p>A velocidade de gravação deve ser detectada e configurada automaticamente de acordo com a mídia e a unidade que está sendo usada. Para forçar a velocidade de gravação, use <code>-speed=</code>. Consulte o <a href="https://man.freebsd.org/cgi/man.cgi?query=growisofs&amp;sektion=1&amp;format=html">growisofs(1)</a> para exemplos de uso.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Para suportar arquivos de trabalho maiores que 4.38GB, um sistema de arquivos híbrido UDF/ISO-9660 deve ser criado passando <code>-udf -iso-level 3</code> para <a href="https://man.freebsd.org/cgi/man.cgi?query=mkisofs&amp;sektion=8&amp;format=html">mkisofs(8)</a> e todos os programas relacionados, como <a href="https://man.freebsd.org/cgi/man.cgi?query=growisofs&amp;sektion=1&amp;format=html">growisofs(1)</a>. Isso é necessário apenas ao criar um arquivo de imagem ISO ou ao gravar arquivos diretamente em um disco. Como um disco criado dessa maneira deve ser montado como um sistema de arquivos UDF com <a href="https://man.freebsd.org/cgi/man.cgi?query=mount_udf&amp;sektion=8&amp;format=html">mount_udf(8)</a>, ele será utilizável apenas em um sistema operacional com suporte a UDF. Caso contrário, parecerá que contém arquivos corrompidos.</p></div><div class=paragraph><p>Para criar este tipo de arquivo ISO:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% mkisofs <span class=nt>-R</span> <span class=nt>-J</span> <span class=nt>-udf</span> <span class=nt>-iso-level</span> 3 <span class=nt>-o</span> imagefile.iso /path/to/data</code></pre></div></div><div class=paragraph><p>Para gravar arquivos diretamente em um disco:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># growisofs -dvd-compat -udf -iso-level 3 -Z /dev/cd0 -J -R /path/to/data</span></code></pre></div></div><div class=paragraph><p>Quando uma imagem ISO já contém arquivos grandes, nenhuma opção adicional é necessária para o <a href="https://man.freebsd.org/cgi/man.cgi?query=growisofs&amp;sektion=1&amp;format=html">growisofs(1)</a> gravar a imagem em um disco.</p></div><div class=paragraph><p>Certifique-se de usar uma versão atualizada do port <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/cdrtools/>sysutils/cdrtools</a>, que contenha o <a href="https://man.freebsd.org/cgi/man.cgi?query=mkisofs&amp;sektion=8&amp;format=html">mkisofs(8)</a>, como uma versão mais antiga pode não conter suporte a arquivos grandes. Se a versão mais recente não funcionar, instale o <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/cdrtools-devel/>sysutils/cdrtools-devel</a> e leia o <a href="https://man.freebsd.org/cgi/man.cgi?query=mkisofs&amp;sektion=8&amp;format=html">mkisofs(8)</a>.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=_gravando_um_dvd_video>17.6.3. Gravando um DVD -Video<a class=anchor href=#_gravando_um_dvd_video></a></h4><div class=paragraph><p>Um DVD-Video é um layout de arquivo específico baseado nas especificações ISO 9660 e micro-UDF (M-UDF). Como o DVD-Video apresenta uma hierarquia de estrutura de dados específica, um programa específico como <a class=package href=https://cgit.freebsd.org/ports/tree/multimedia/dvdauthor/>multimedia/dvdauthor</a> é necessário para criar o DVD.</p></div><div class=paragraph><p>Se uma imagem do sistema de arquivos DVD-Video já existir, ela poderá ser gravada da mesma maneira que qualquer outra imagem. Se o <code>dvdauthor</code> foi usado para criar o DVD e o resultado está em <span class=filename>/path/to/video</span>, o seguinte comando deve ser usado para gravar o DVD-Vídeo:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># growisofs -Z /dev/cd0 -dvd-video /path/to/video</span></code></pre></div></div><div class=paragraph><p><code>-dvd-video</code> é passado para o <a href="https://man.freebsd.org/cgi/man.cgi?query=mkisofs&amp;sektion=8&amp;format=html">mkisofs(8)</a> para instruí-lo a criar um sistemas de arquivos com layout DVD-Video. Esta opção implica na opção <code>-dvd-compat</code> do <a href="https://man.freebsd.org/cgi/man.cgi?query=growisofs&amp;sektion=1&amp;format=html">growisofs(1)</a>.</p></div></div><div class=sect3><h4 id=_usando_um_dvdrw>17.6.4. Usando um DVD+RW<a class=anchor href=#_usando_um_dvdrw></a></h4><div class=paragraph><p>Ao contrário do CD-RW, um DVD+RW virgem precisa ser formatado antes do primeiro uso. É <em>recomendado</em> para permitir que <a href="https://man.freebsd.org/cgi/man.cgi?query=growisofs&amp;sektion=1&amp;format=html">growisofs(1)</a> cuide disso automaticamente sempre que apropriado. No entanto, é possível usar <code>dvd+rw-format</code> para formatar o DVD+RW:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dvd+rw-format /dev/cd0</span></code></pre></div></div><div class=paragraph><p>Somente execute esta operação uma vez e tenha em mente que apenas mídias DVD+RW virgens precisam ser formatadas. Uma vez formatado, o DVD+RW pode ser gravado como de costume.</p></div><div class=paragraph><p>Para gravar um sistema de arquivos totalmente novo e não apenas acrescentar alguns dados em um DVD+RW, a mídia não precisa ser apagada primeiro. Em vez disso, escreva sobre a gravação anterior assim:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># growisofs -Z /dev/cd0 -J -R /path/to/newdata</span></code></pre></div></div><div class=paragraph><p>O formato DVD+RW suporta anexar dados a uma gravação anterior. Essa operação consiste em mesclar uma nova sessão à existente, pois ela não é considerada como gravação de várias sessões. <a href="https://man.freebsd.org/cgi/man.cgi?query=growisofs&amp;sektion=1&amp;format=html">growisofs(1)</a> vai <em>ampliar</em> o sistema de arquivos ISO 9660 presente na mídia.</p></div><div class=paragraph><p>Por exemplo, para anexar dados a um DVD+RW, use o seguinte:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># growisofs -M /dev/cd0 -J -R /path/to/nextdata</span></code></pre></div></div><div class=paragraph><p>As mesmas opções do <a href="https://man.freebsd.org/cgi/man.cgi?query=mkisofs&amp;sektion=8&amp;format=html">mkisofs(8)</a> usadas para gravar a sessão inicial devem ser usadas durante as próximas gravações.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Use <code>-dvd-compat</code> para melhor compatibilidade de mídia com as unidades de DVD-ROM. Ao usar DVD+RW, essa opção não impedirá a adição de dados.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Para apagar a mídia, use:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># growisofs -Z /dev/cd0=/dev/zero</span></code></pre></div></div></div><div class=sect3><h4 id=_usando_um_dvd_rw>17.6.5. Usando um DVD-RW<a class=anchor href=#_usando_um_dvd_rw></a></h4><div class=paragraph><p>Um DVD-RW aceita dois formatos de disco: sequencial incremental e substituição restrita. Por padrão, os discos DVD-RW estão em formato sequencial.</p></div><div class=paragraph><p>Um DVD-RW virgem pode ser escrito diretamente sem ser formatado. No entanto, um DVD-RW não-virgem em formato sequencial precisa ser apagado antes de escrever uma nova sessão inicial.</p></div><div class=paragraph><p>Para apagar um DVD-RW em modo sequencial:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dvd+rw-format -blank=full /dev/cd0</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Um preenchimento completo usando <code>-blank=full</code> levará cerca de uma hora em uma mídia 1x. Um limpeza rápida pode ser executada usando <code>-blank</code>, se o DVD-RW for gravado no modo Disk-At-Once (DAO). Para gravar o DVD-RW no modo DAO, use o comando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># growisofs -use-the-force-luke=dao -Z /dev/cd0=imagefile.iso</span></code></pre></div></div><div class=paragraph><p>Como o <a href="https://man.freebsd.org/cgi/man.cgi?query=growisofs&amp;sektion=1&amp;format=html">growisofs(1)</a> tenta automaticamente detectar a mídia rapidamente em branco e ativar a gravação do DAO, <code>-use-the-force -luke=dao</code> não deve ser requerido.</p></div><div class=paragraph><p>Em vez disso, deve-se usar o modo de sobrescrita restrita com qualquer DVD-RW, pois esse formato é mais flexível do que o padrão de sequencial incremental.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Para escrever dados em um DVD-RW seqüencial, use as mesmas instruções que para os outros formatos de DVD:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># growisofs -Z /dev/cd0 -J -R /path/to/data</span></code></pre></div></div><div class=paragraph><p>Para acrescentar alguns dados a uma gravação anterior, use <code>-M</code> com o <a href="https://man.freebsd.org/cgi/man.cgi?query=growisofs&amp;sektion=1&amp;format=html">growisofs(1)</a>. No entanto, se os dados forem anexados em um DVD-RW no modo sequencial incremental, uma nova sessão será criada no disco e o resultado será um disco multi-sessão.</p></div><div class=paragraph><p>Um DVD-RW no formato de sobrescrita restrita não precisa ser em apagado antes de uma nova sessão inicial. Em vez disso, sobrescreva o disco com <code>-Z</code>. Também é possível aumentar um sistema de arquivos ISO 9660 existente escrito no disco com <code>-M</code>. O resultado será um DVD de uma sessão.</p></div><div class=paragraph><p>Para colocar um DVD-RW no formato de sobrescrita restrita, o seguinte comando deve ser usado:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dvd+rw-format /dev/cd0</span></code></pre></div></div><div class=paragraph><p>Para voltar ao formato sequencial, use:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dvd+rw-format -blank=full /dev/cd0</span></code></pre></div></div></div><div class=sect3><h4 id=_multi_sessão>17.6.6. Multi-Sessão<a class=anchor href=#_multi_sessão></a></h4><div class=paragraph><p>Poucas unidades de DVD-ROM suportam DVDs multi-sessão e na maioria das vezes apenas lêem a primeira sessão. DVD+R, DVD-R e DVD-RW em formato sequencial podem aceitar várias sessões. A noção de várias sessões não existe para os formatos de sobrescrita restrita DVD+RW e DVD-RW.</p></div><div class=paragraph><p>Usando o seguinte comando após uma sessão inicial não fechada em um DVD+R, DVD-R ou DVD-RW em formato sequencial, será adicionada uma nova sessão ao disco:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># growisofs -M /dev/cd0 -J -R /path/to/nextdata</span></code></pre></div></div><div class=paragraph><p>Usando este comando com um DVD+RW ou um DVD-RW no modo de sobrescrita restrita adicionará dados ao mesclar a nova sessão à existente. O resultado será um disco de sessão única. Use este método para adicionar dados após uma gravação inicial nesses tipos de mídia.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Como algum espaço na mídia é usado entre cada sessão para marcar o final e o início das sessões, deve-se adicionar sessões com uma grande quantidade de dados para otimizar o espaço da mídia. O número de sessões é limitado a 154 para um DVD+R, cerca de 2000 para um DVD-R e 127 para um DVD+R Double Layer.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=_para_maiores_informações>17.6.7. Para Maiores Informações<a class=anchor href=#_para_maiores_informações></a></h4><div class=paragraph><p>Para obter mais informações sobre um DVD, use o <code>dvd+rw-mediainfo <em>/dev/cd0</em></code> enquanto o disco estiver na unidade especificada.</p></div><div class=paragraph><p>Mais informações sobre dvd+rw-tools podem ser encontradas em <a href="https://man.freebsd.org/cgi/man.cgi?query=growisofs&amp;sektion=1&amp;format=html">growisofs(1)</a>, no <a href=http://fy.chalmers.se/~appro/linux/DVD+RW/>site de dvd+rw-tools</a>, e nos arquivos do <a href=http://lists.debian.org/cdwrite/>cdwrite mailing list</a>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Ao criar um relatório de problemas relacionado ao uso de dvd+rw-tools, inclua sempre a saída de <code>dvd+rw-mediainfo</code>.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=creating-dvd-ram>17.6.8. Usando um DVD-RAM<a class=anchor href=#creating-dvd-ram></a></h4><div class=paragraph><p>Os gravadores de DVD-RAM podem usar uma interface SCSI ou ATAPI. Para dispositivos ATAPI, o acesso DMA deve ser ativado adicionando a seguinte linha ao arquivo <span class=filename>/boot/loader.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>hw.ata.atapi_dma=&#34;1&#34;</pre></div></div><div class=paragraph><p>Um DVD-RAM pode ser visto como um disco rígido removível. Como qualquer outro disco rígido, o DVD-RAM deve ser formatado antes de poder ser usado. Neste exemplo, todo o espaço em disco será formatado com um sistema de arquivos UFS2 padrão:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dd if=/dev/zero of=/dev/acd0 bs=2k count=1</span>
<span class=c># bsdlabel -Bw acd0</span>
<span class=c># newfs /dev/acd0</span></code></pre></div></div><div class=paragraph><p>O dispositivo DVD, <span class=filename>acd0</span>, deve ser alterado de acordo com a configuração.</p></div><div class=paragraph><p>Uma vez que o DVD-RAM tenha sido formatado, ele pode ser montado como um disco rígido normal:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount /dev/acd0 /mnt</span></code></pre></div></div><div class=paragraph><p>Uma vez montado, o DVD-RAM será legível e gravável.</p></div></div></div><div class=sect2><h3 id=floppies>17.7. Criando e Usando Disquetes<a class=anchor href=#floppies></a></h3><div class=paragraph><p>Esta seção explica como formatar um disquete de 3.5 polegadas no FreeBSD.</p></div><div class="exampleblock procedure"><div class=content><div class=paragraph><p><strong>Procedure: Etapas para Formatar um Disquete</strong></p></div><div class=paragraph><p>Um disquete precisa ser formatado em baixo nível antes de poder ser usado. Isso geralmente é feito pelo fornecedor, mas a formatação é uma boa maneira de verificar a integridade da mídia. Para o formato de baixo nível do disquete no FreeBSD, use <a href="https://man.freebsd.org/cgi/man.cgi?query=fdformat&amp;sektion=1&amp;format=html">fdformat(1)</a>. Ao usar esse utilitário, anote todas as mensagens de erro, pois elas podem ajudar a determinar se o disco está bom ou ruim.</p></div><div class="olist arabic"><ol class=arabic><li><p>Para formatar o disquete, insira um novo disquete de 3.5 polegadas na primeira unidade de disquete e digite:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /usr/sbin/fdformat -f 1440 /dev/fd0</span></code></pre></div></div></li><li><p>Após a formatação de baixo nível do disco, crie um rótulo de disco conforme requerido pelo sistema para determinar o tamanho do disco e sua geometria. Os valores de geometria suportados estão listados no arquivo <span class=filename>/etc/disktab</span>.</p><div class=paragraph><p>Para escrever o rótulo do disco, use <a href="https://man.freebsd.org/cgi/man.cgi?query=bsdlabel&amp;sektion=8&amp;format=html">bsdlabel(8)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /sbin/bsdlabel -B -w /dev/fd0 fd1440</span></code></pre></div></div></li><li><p>O disquete agora está pronto para ser formatado em alto nível com um sistema de arquivos. O sistema de arquivos do disquete pode ser UFS ou FAT, onde o FAT geralmente é uma opção melhor para disquetes.</p><div class=paragraph><p>Para formatar o disquete com o FAT, digite:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /sbin/newfs_msdos /dev/fd0</span></code></pre></div></div></li></ol></div></div></div><div class=paragraph><p>O disco está agora pronto para uso. Para usar o disquete, monte-o com <a href="https://man.freebsd.org/cgi/man.cgi?query=mount_msdosfs&amp;sektion=8&amp;format=html">mount_msdosfs(8)</a>. Também é possível instalar e usar <a class=package href=https://cgit.freebsd.org/ports/tree/emulators/mtools/>emulators/mtools</a> da coleção de ports.</p></div></div><div class=sect2><h3 id=backup-basics>17.8. Noções Básicas de Backup<a class=anchor href=#backup-basics></a></h3><div class=paragraph><p>A implementação de um plano de backup é essencial para que seja possível recuperar de uma falha de disco, exclusão acidental de arquivos, corrupção aleatória de arquivos ou destruição completa da máquina, incluindo a destruição de backups no local.</p></div><div class=paragraph><p>O tipo e a programação do backup variam, dependendo da importância dos dados, da granularidade necessária para as restaurações de arquivos e da quantidade de tempo de inatividade aceitável. Algumas técnicas de backup possíveis incluem:</p></div><div class=ulist><ul><li><p>Arquivos de todo o sistema, protegidos por meio de backups em mídias permanentes, armazenados off-site. Isso fornece proteção contra todos os problemas listados acima, mas é lento e inconveniente para restaurar, especialmente para usuários sem privilégios.</p></li><li><p>Snapshots do sistema de arquivos, que são úteis para restaurar arquivos excluídos ou versões anteriores de arquivos.</p></li><li><p>Cópias de sistemas de arquivos inteiros ou discos que são sincronizados com outro sistema na rede usando um <a class=package href=https://cgit.freebsd.org/ports/tree/net/rsync/>net/rsync</a> agendado.</p></li><li><p>RAID por hardware ou software, que minimiza ou evita paralisações quando um disco falha.</p></li></ul></div><div class=paragraph><p>Normalmente, uma mistura de técnicas de backup é usada. Por exemplo, pode-se criar um agendamento semanal para automatizar um backup completo do sistema e armazená-lo off-site e para suplementá-lo, snapshots do ZFS tirados a cada hora. Além disso, é possível fazer um backup manual de diretórios ou arquivos individuais antes de fazer edições ou exclusões de arquivos.</p></div><div class=paragraph><p>Esta seção descreve alguns dos utilitários que podem ser usados para criar e gerenciar backups em um sistema FreeBSD.</p></div><div class=sect3><h4 id=_backups_do_sistema_de_arquivos>17.8.1. Backups do Sistema de Arquivos<a class=anchor href=#_backups_do_sistema_de_arquivos></a></h4><div class=paragraph><p>Os programas tradicionais UNIX™ para fazer backup de um sistema de arquivos são <a href="https://man.freebsd.org/cgi/man.cgi?query=dump&amp;sektion=8&amp;format=html">dump(8)</a>, que cria o backup, e <a href="https://man.freebsd.org/cgi/man.cgi?query=restore&amp;sektion=8&amp;format=html">restore(8)</a>, que restaura o backup. Esses utilitários funcionam no nível do bloco do disco, abaixo das abstrações dos arquivos, links e diretórios criados pelos sistemas de arquivos. Ao contrário de outros softwares de backup, <code>dump</code> faz backup de todo um sistema de arquivos e não é capaz de fazer backup de apenas parte de um sistema de arquivos ou de uma árvore de diretórios que abrange vários sistemas de arquivos. Em vez de gravar arquivos e diretórios, <code>dump</code> grava os blocos de dados brutos que compreendem arquivos e diretórios.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Se o <code>dump</code> for usado no diretório raiz, ele não fará o backup de <span class=filename>/home</span>, <span class=filename>/usr</span> ou de muitos outros diretórios, pois eles são tipicamente pontos de montagem para outros sistemas de arquivos ou links simbólicos nesses sistemas de arquivos.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Quando usado para restaurar dados, <code>restore</code> armazena arquivos temporários em <span class=filename>/tmp/</span> por padrão. Ao usar um disco de recuperação com um pequeno <span class=filename>/tmp</span>, configure <code>TMPDIR</code> para um diretório com mais espaço livre para que a restauração seja bem-sucedida.</p></div><div class=paragraph><p>Ao usar <code>dump</code>, esteja ciente de que algumas peculiaridades permanecem desde seus primeiros dias na versão 6 do AT&amp;T UNIX™, por volta de 1975. Os parâmetros padrão assumem um backup para uma fita de 9 faixas, em vez de para outro tipo de mídia ou para as fitas de alta densidade disponíveis atualmente. Esses padrões devem ser substituídos na linha de comando.</p></div><div class=paragraph><p>É possível fazer backup de um sistema de arquivos pela rede para outro sistema ou para uma unidade de fita conectada a outro computador. Enquanto os utilitários <a href="https://man.freebsd.org/cgi/man.cgi?query=rdump&amp;sektion=8&amp;format=html">rdump(8)</a> e <a href="https://man.freebsd.org/cgi/man.cgi?query=rrestore&amp;sektion=8&amp;format=html">rrestore(8)</a> possam ser usado para este propósito, eles não são considerados seguros.</p></div><div class=paragraph><p>Em vez disso, pode-se usar <code>dump</code> e <code>restore</code> de uma maneira mais segura em uma conexão SSH. Este exemplo cria um backup completo e compactado de <span class=filename>/usr</span> e envia o arquivo de backup para o host especificado em uma conexão SSH.</p></div><div class=exampleblock><div class=title>Exemplo 36. Usando <code>dump</code> sobre ssh</div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /sbin/dump -0uan -f - /usr | gzip -2 | ssh -c blowfish \</span>
          targetuser@targetmachine.example.com <span class=nb>dd </span><span class=nv>of</span><span class=o>=</span>/mybigfiles/dump-usr-l0.gz</code></pre></div></div></div></div><div class=paragraph><p>Este exemplo configura <code>RSH</code> para gravar o backup em uma unidade de fita em um sistema remoto através de uma conexão SSH:</p></div><div class=exampleblock><div class=title>Exemplo 37. Usando o <code>dump</code> sobre ssh com o <code>RSH</code> configurado</div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># env RSH=/usr/bin/ssh /sbin/dump -0uan -f targetuser@targetmachine.example.com:/dev/sa0 /usr</span></code></pre></div></div></div></div></div><div class=sect3><h4 id=_backups_de_diretório>17.8.2. Backups de Diretório<a class=anchor href=#_backups_de_diretório></a></h4><div class=paragraph><p>Vários utilitários integrados estão disponíveis para backup e restauração de arquivos e diretórios especificados, conforme necessário.</p></div><div class=paragraph><p>Uma boa alternativa para fazer backup de todos os arquivos em um diretório é o <a href="https://man.freebsd.org/cgi/man.cgi?query=tar&amp;sektion=1&amp;format=html">tar(1)</a>. Este utilitário remonta à versão 6 do AT&amp;T UNIX™ e, por padrão, assume um backup recursivo para um dispositivo de fita local. Redirecionadores podem ser utilizados para especificar o nome de um arquivo de backup.</p></div><div class=paragraph><p>Este exemplo cria um backup compactado do diretório atual e o salva no arquivo <span class=filename>/tmp/mybackup.tgz</span>. Ao criar um arquivo de backup, verifique se o backup não está salvo no mesmo diretório em que está sendo feito backup.</p></div><div class=exampleblock><div class=title>Exemplo 38. Fazendo Backup do Diretório Atual com o <code>tar</code></div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># tar czvf /tmp/mybackup.tgz .</span></code></pre></div></div></div></div><div class=paragraph><p>Para restaurar o backup inteiro, <code>cd</code> no diretório para restaurar e especificar o nome do backup. Observe que isso sobrescreverá qualquer versão mais nova de arquivos no diretório de restauração. Em caso de dúvida, restaure para um diretório temporário ou especifique o nome do arquivo dentro do backup a ser restaurado.</p></div><div class=exampleblock><div class=title>Exemplo 39. Restaurando o Diretório Atual com o <code>tar</code></div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># tar xzvf /tmp/mybackup.tgz</span></code></pre></div></div></div></div><div class=paragraph><p>Existem dezenas de opções disponíveis, descritas em <a href="https://man.freebsd.org/cgi/man.cgi?query=tar&amp;sektion=1&amp;format=html">tar(1)</a>. Esse utilitário também suporta o uso de padrões de exclusão para especificar quais arquivos não devem ser incluídos ao fazer backup do diretório especificado ou restaurar arquivos de um backup.</p></div><div class=paragraph><p>Para criar um backup usando uma lista especificada de arquivos e diretórios, <a href="https://man.freebsd.org/cgi/man.cgi?query=cpio&amp;sektion=1&amp;format=html">cpio(1)</a> é uma boa escolha. Ao contrário do <code>tar</code>, o <code>cpio</code> não sabe como percorrer a árvore de diretórios e deve fornecer a lista de arquivos para backup.</p></div><div class=paragraph><p>Por exemplo, uma lista de arquivos pode ser criada usando <code>ls</code> ou <code>find</code>. Este exemplo cria uma listagem recursiva do diretório atual que é então canalizado para o <code>cpio</code> para criar um arquivo de backup de saída chamado <span class=filename>/tmp/mybackup.cpio</span>.</p></div><div class=exampleblock><div class=title>Exemplo 40. Usando <code>ls</code> e <code>cpio</code> para Criar um Backup Recursivo do Diretório Atual</div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ls -R | cpio -ovF /tmp/mybackup.cpio</span></code></pre></div></div></div></div><div class=paragraph><p>Um utilitário de backup que tenta conectar os recursos fornecidos pelo <code>tar</code> e <code>cpio</code> é <a href="https://man.freebsd.org/cgi/man.cgi?query=pax&amp;sektion=1&amp;format=html">pax(1)</a>. Ao longo dos anos, as várias versões do <code>tar</code> e do <code>cpio</code> tornaram-se ligeiramente incompatíveis. POSIX™ criou <code>pax</code> que tenta ler e escrever muitos dos vários formatos <code>cpio</code> e <code>tar</code>, além de novos formatos próprios.</p></div><div class=paragraph><p>O <code>pax</code> equivalente aos exemplos anteriores seria:</p></div><div class=exampleblock><div class=title>Exemplo 41. Fazendo Backup do Diretório Atual com <code>pax</code></div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pax -wf /tmp/mybackup.pax .</span></code></pre></div></div></div></div></div><div class=sect3><h4 id=backups-tapebackups>17.8.3. Usando Fitas de Dados para Backups<a class=anchor href=#backups-tapebackups></a></h4><div class=paragraph><p>Embora a tecnologia de fitas tenha continuado a evoluir, os sistemas de backup modernos tendem a combinar backups externos com mídias removíveis locais. O FreeBSD suporta qualquer unidade de fita que use SCSI, como LTO ou DAT. Há suporte limitado para as unidades de fita SATA e USB.</p></div><div class=paragraph><p>Para dispositivos de fita SCSI, o FreeBSD usa o driver <a href="https://man.freebsd.org/cgi/man.cgi?query=sa&amp;sektion=4&amp;format=html">sa(4)</a> e os dispositivos <span class=filename>/dev/sa0</span>, <span class=filename>/dev/nsa0</span> e <span class=filename>/dev/esa0</span>. O nome do dispositivo físico é <span class=filename>/dev/sa0</span>. Quando <span class=filename>/dev/nsa0</span> é usado, o aplicativo de backup não rebobina a fita depois de gravar um arquivo, o que permite gravar mais de um arquivo em uma fita. O uso de <span class=filename>/dev/esa0</span> ejeta a fita após o dispositivo ser fechado.</p></div><div class=paragraph><p>No FreeBSD, o <code>mt</code> é usado para controlar as operações da unidade de fita, como procurar arquivos em uma fita ou gravar marcas de controle na fita. Por exemplo, os três primeiros arquivos em uma fita podem ser preservados, ignorando-os antes de gravar um novo arquivo:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mt -f /dev/nsa0 fsf 3</span></code></pre></div></div><div class=paragraph><p>Este utilitário suporta muitas operações. Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=mt&amp;sektion=1&amp;format=html">mt(1)</a> para detalhes.</p></div><div class=paragraph><p>Para gravar um único arquivo em fita usando <code>tar</code>, especifique o nome do dispositivo de fita e o arquivo para backup:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># tar cvf /dev/sa0 file</span></code></pre></div></div><div class=paragraph><p>Para recuperar arquivos de um arquivo <code>tar</code> em fita no diretório atual:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># tar xvf /dev/sa0</span></code></pre></div></div><div class=paragraph><p>Para fazer backup de um sistema de arquivos UFS, use <code>dump</code>. Este exemplo faz o backup de <span class=filename>/usr</span> sem rebobinar a fita quando terminar:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dump -0aL -b64 -f /dev/nsa0 /usr</span></code></pre></div></div><div class=paragraph><p>Para restaurar arquivos interativamente de um arquivo <code>dump</code> em fita no diretório atual:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># restore -i -f /dev/nsa0</span></code></pre></div></div></div><div class=sect3><h4 id=backups-programs-amanda>17.8.4. Utilitários de Backup de Terceiros<a class=anchor href=#backups-programs-amanda></a></h4><div class=paragraph><p>A Coleção de Ports do FreeBSD fornece muitos utilitários de terceiros que podem ser usados para agendar a criação de backups, simplificar o backup em fita e tornar os backups mais fáceis e convenientes. Muitos desses aplicativos são baseados em cliente/servidor e podem ser usados para automatizar os backups de um único sistema ou de todos os computadores em uma rede.</p></div><div class=paragraph><p>Os utilitários populares incluem Amanda, Bacula, rsync e duplicity.</p></div></div><div class=sect3><h4 id=_recuperação_de_emergência>17.8.5. Recuperação de Emergência<a class=anchor href=#_recuperação_de_emergência></a></h4><div class=paragraph><p>Além dos backups regulares, é recomendável executar as etapas a seguir como parte de um plano de preparação para emergências.</p></div><div class=paragraph><p>Crie uma cópia impressa da saída dos seguintes comandos:</p></div><div class=ulist><ul><li><p><code>gpart show</code></p></li><li><p><code>more /etc/fstab</code></p></li><li><p><code>dmesg</code></p></li></ul></div><div class=paragraph><p>Armazene esta saída e uma cópia da mídia de instalação em um local seguro. Se uma restauração de emergência for necessária, inicialize na mídia de instalação e selecione <code>Live CD</code> para acessar um shell de recuperação. Esse modo de recuperação pode ser usado para exibir o estado atual do sistema e, se necessário, reformatar discos e restaurar dados de backups.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>A mídia de instalação do FreeBSD/i386 11.2-RELEASE não inclui um shell de recuperação. Para esta versão, baixe e grave uma imagem do Livefs CD de <a href=ftp://ftp.FreeBSD.org/pub/FreeBSD/releases/i386/ISO-IMAGES/11.2/FreeBSD-11.2-RELEASE-i386-livefs.iso>ftp://ftp.FreeBSD.org/pub/FreeBSD/releases/i386/ISO-IMAGES/11.2/FreeBSD-11.2-RELEASE-i386-livefs.iso</a>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Em seguida, teste o shell de recuperação e os backups. Faça anotações do procedimento. Armazene estas notas com a mídia, as impressões e os backups. Estas notas podem impedir a destruição inadvertida dos backups, enquanto sob o estresse de realizar uma recuperação de emergência.</p></div><div class=paragraph><p>Para uma medida adicional de segurança, armazene o backup mais recente em um local remoto, fisicamente separado dos computadores e das unidades de disco por uma distância significativa.</p></div></div></div><div class=sect2><h3 id=disks-virtual>17.9. Discos de Memória<a class=anchor href=#disks-virtual></a></h3><div class=paragraph><p>Além de discos físicos, o FreeBSD também suporta a criação e uso de discos de memória. Um uso possível para um disco de memória é acessar o conteúdo de um sistema de arquivos ISO sem a sobrecarga de primeiro gravá-lo em um CD ou DVD e, em seguida, montar a mídia CD/DVD .</p></div><div class=paragraph><p>No FreeBSD, o driver <a href="https://man.freebsd.org/cgi/man.cgi?query=md&amp;sektion=4&amp;format=html">md(4)</a> é usado para fornecer suporte para discos de memória. O kernel <span class=filename>GENERIC</span> inclui este driver. Ao usar um arquivo de configuração de kernel personalizado, certifique-se de incluir esta linha:</p></div><div class="literalblock programlisting"><div class=content><pre>device md</pre></div></div><div class=sect3><h4 id=disks-mdconfig>17.9.1. Anexando e Desanexando Imagens Existentes<a class=anchor href=#disks-mdconfig></a></h4><div class=paragraph><p>Para montar uma imagem do sistema de arquivos existente, use o <code>mdconfig</code> para especificar o nome do arquivo ISO e um número de unidade livre. Em seguida, consulte esse número de unidade para montá-lo em um ponto de montagem existente. Uma vez montado, os arquivos na imagem ISO aparecerão no ponto de montagem. Este exemplo anexa o arquivo <em>diskimage.iso</em> ao dispositivo de memória <span class=filename>/dev/md0</span> e monta o dispositivo de memória em <span class=filename>/mnt</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mdconfig -f diskimage.iso -u 0</span>
<span class=c># mount -t cd9660 /dev/md0 /mnt</span></code></pre></div></div><div class=paragraph><p>Note que <code>-t cd9660</code> foi usado para montar uma imagem ISO. Se um número de unidade não for especificado com <code>-u</code>, o <code>mdconfig</code> alocará automaticamente um dispositivo de memória não utilizado e exibirá o nome da unidade alocada, como <span class=filename>md4</span>. Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=mdconfig&amp;sektion=8&amp;format=html">mdconfig(8)</a> para mais detalhes sobre este comando e suas opções.</p></div><div class=paragraph><p>Quando um disco de memória não está mais em uso, seus recursos devem ser liberados de volta ao sistema. Primeiro, desmonte o sistema de arquivos e use o <code>mdconfig</code> para desanexar o disco do sistema e liberar seus recursos. Para continuar este exemplo:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># umount /mnt</span>
<span class=c># mdconfig -d -u 0</span></code></pre></div></div><div class=paragraph><p>Para determinar se algum disco de memória ainda está conectado ao sistema, digite <code>mdconfig -l</code>.</p></div></div><div class=sect3><h4 id=disks-md-freebsd5>17.9.2. Criando um Disco Virtual Baseado em Arquivo ou Memória<a class=anchor href=#disks-md-freebsd5></a></h4><div class=paragraph><p>O FreeBSD também suporta discos virtuais onde o armazenamento a ser utilizado é alocado a partir de um disco rígido ou de uma área de memória. O primeiro método é comumente referido como um disco virtual baseado em arquivo e o segundo como um disco virtual baseado em memória. Ambos os tipos podem ser criados usando o <code>mdconfig</code>.</p></div><div class=paragraph><p>Para criar um novo disco virtual baseado em memória, especifique um tipo de <code>swap</code> e o tamanho do disco de memória a ser criado. Em seguida, formate o disco de memória com um sistema de arquivos e monte como de costume. Este exemplo cria um disco de memória de 5M na unidade <code>1</code>. Esse disco de memória é formatado com o sistema de arquivos UFS antes de ser montado:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mdconfig -a -t swap -s 5m -u 1</span>
<span class=c># newfs -U md1</span>
/dev/md1: 5.0MB <span class=o>(</span>10240 sectors<span class=o>)</span> block size 16384, fragment size 2048
        using 4 cylinder <span class=nb>groups </span>of 1.27MB, 81 blks, 192 inodes.
        with soft updates
super-block backups <span class=o>(</span><span class=k>for </span>fsck <span class=nt>-b</span> <span class=c>#) at:</span>
 160, 2752, 5344, 7936
<span class=c># mount /dev/md1 /mnt</span>
<span class=c># df /mnt</span>
Filesystem 1K-blocks Used Avail Capacity  Mounted on
/dev/md1        4718    4  4338     0%    /mnt</code></pre></div></div><div class=paragraph><p>Para criar um novo disco virtual baseado em arquivo, primeiro aloque a área que será usada para o disco. Esse exemplo cria um arquivo vázio de 5MB chamado <span class=filename>newimage</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dd if=/dev/zero of=newimage bs=1k count=5k</span>
5120+0 records <span class=k>in
</span>5120+0 records out</code></pre></div></div><div class=paragraph><p>Em seguida, anexe esse arquivo a um disco de memória, rotule o disco de memória e formate-o com o sistema de arquivos UFS, monte o disco de memória e verifique o tamanho do disco com backup de arquivo:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mdconfig -f newimage -u 0</span>
<span class=c># bsdlabel -w md0 auto</span>
<span class=c># newfs -U md0a</span>
/dev/md0a: 5.0MB <span class=o>(</span>10224 sectors<span class=o>)</span> block size 16384, fragment size 2048
        using 4 cylinder <span class=nb>groups </span>of 1.25MB, 80 blks, 192 inodes.
super-block backups <span class=o>(</span><span class=k>for </span>fsck <span class=nt>-b</span> <span class=c>#) at:</span>
 160, 2720, 5280, 7840
<span class=c># mount /dev/md0a /mnt</span>
<span class=c># df /mnt</span>
Filesystem 1K-blocks Used Avail Capacity  Mounted on
/dev/md0a       4710    4  4330     0%    /mnt</code></pre></div></div><div class=paragraph><p>São necessários vários comandos para criar um disco virtual baseado em arquivo ou memória usando <code>mdconfig</code>. O FreeBSD também vem com o <code>mdmfs</code> que configura automaticamente um disco de memória, formata-o com o sistema de arquivos UFS e o monta. Por exemplo, depois de criar <em>newimage</em> com <code>dd</code>, esse comando é equivalente a executar os comandos <code>bsdlabel</code>, <code>newfs</code> e <code>mount</code> mostrados acima:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mdmfs -F newimage -s 5m md0 /mnt</span></code></pre></div></div><div class=paragraph><p>Para criar um novo disco virtual baseado em memória com o <code>mdmfs</code>, use este comando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mdmfs -s 5m md1 /mnt</span></code></pre></div></div><div class=paragraph><p>Se o número da unidade não for especificado, o <code>mdmfs</code> selecionará automaticamente um dispositivo de memória não utilizado. Para mais detalhes sobre <code>mdmfs</code>, consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=mdmfs&amp;sektion=8&amp;format=html">mdmfs(8)</a>.</p></div></div></div><div class=sect2><h3 id=snapshots>17.10. Snapshots de Sistemas de Arquivos<a class=anchor href=#snapshots></a></h3><div class=paragraph><p>O FreeBSD oferece um recurso em conjunto com <a href=./#soft-updates>Atualizações Soft</a>: snapshots do sistema de arquivos.</p></div><div class=paragraph><p>Os Snapshots de UFS permitem que um usuário crie imagens de sistemas de arquivos especificados e as trate como um arquivo. Os arquivos de snapshot devem ser criados no sistema de arquivos no qual a ação é executada e um usuário pode criar no máximo 20 snapshots por sistema de arquivos. Os snapshots ativos são registradas no superbloco, de modo que são persistentes nas operações de desmontagem e remontagem, juntamente com reinicializações do sistema. Quando um snapshot não é mais necessário, ele pode ser removido usando <a href="https://man.freebsd.org/cgi/man.cgi?query=rm&amp;sektion=1&amp;format=html">rm(1)</a>. Embora os snapshots possam ser removidos em qualquer ordem, todo o espaço usado pode não ser adquirido porque outro snapshot possivelmente reivindicará alguns dos blocos liberados.</p></div><div class=paragraph><p>A flag de arquivo <code>snapshot</code> não alterável é definida por <a href="https://man.freebsd.org/cgi/man.cgi?query=mksnap_ffs&amp;sektion=8&amp;format=html">mksnap_ffs(8)</a> após a criação inicial de um arquivo de snapshot. O <a href="https://man.freebsd.org/cgi/man.cgi?query=unlink&amp;sektion=1&amp;format=html">unlink(1)</a> cria uma exceção para arquivos de snapshots, pois permite que sejam removidos.</p></div><div class=paragraph><p>Os snapshots são criados usando <a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a>. Para colocar um snapshot de <span class=filename>/var</span> no arquivo <span class=filename>/var/snapshot/snap</span>, use o seguinte comando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount -u -o snapshot /var/snapshot/snap /var</span></code></pre></div></div><div class=paragraph><p>Como alternativa, use <a href="https://man.freebsd.org/cgi/man.cgi?query=mksnap_ffs&amp;sektion=8&amp;format=html">mksnap_ffs(8)</a> para criar o snapshot:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mksnap_ffs /var /var/snapshot/snap</span></code></pre></div></div><div class=paragraph><p>É possível encontrar arquivos de snapshots em um sistema de arquivos, como <span class=filename>/var</span>, usando <a href="https://man.freebsd.org/cgi/man.cgi?query=find&amp;sektion=1&amp;format=html">find(1)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># find /var -flags snapshot</span></code></pre></div></div><div class=paragraph><p>Depois que um snapshot foi criado, ele tem vários usos:</p></div><div class=ulist><ul><li><p>Alguns administradores usarão um arquivo de snapshot para fins de backup, porque o snapshot pode ser transferido para um CDs ou fita.</p></li><li><p>O verificador de integridade do sistema de arquivos, <a href="https://man.freebsd.org/cgi/man.cgi?query=fsck&amp;sektion=8&amp;format=html">fsck(8)</a>, pode ser executado em um snapshot. Supondo que o sistema de arquivos estava limpo quando foi montado, isso deve sempre fornecer um resultado limpo e imutável.</p></li><li><p>Executando <a href="https://man.freebsd.org/cgi/man.cgi?query=dump&amp;sektion=8&amp;format=html">dump(8)</a> em um snapshot produzirá um arquivo de dump que seja consistente com o sistema de arquivos e o registro de data e hora do snapshot. <a href="https://man.freebsd.org/cgi/man.cgi?query=dump&amp;sektion=8&amp;format=html">dump(8)</a> também pode criar um snapshot, criar uma imagem de dump e remover o snapshot em um comando usando <code>-L</code>.</p></li><li><p>O snapshot pode ser montado como uma imagem congelada do sistema de arquivos. Para montar o snapshot use <a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a> passando o nome do snapshot <span class=filename>/var/snapshot/snap</span>:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mdconfig -a -t vnode -o readonly -f /var/snapshot/snap -u 4</span>
<span class=c># mount -r /dev/md4 /mnt</span></code></pre></div></div></li></ul></div><div class=paragraph><p>O <span class=filename>/var</span> congelado agora está disponível através de <span class=filename>/mnt</span>. Tudo estará inicialmente no mesmo estado que estava quando o snapshot foi criado. A única exceção é que os snapshots anteriores aparecerão como arquivos com comprimento zero. Para desmontar o snapshot, use:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># umount /mnt</span>
<span class=c># mdconfig -d -u 4</span></code></pre></div></div><div class=paragraph><p>Para obter mais informações sobre <code>softupdates</code> e snapshots do sistema de arquivos, incluindo documentos técnicos, visite o site do Marshall Kirk McKusick em <a href=http://www.mckusick.com/>http://www.mckusick.com/</a>.</p></div></div><div class=sect2><h3 id=quotas>17.11. Cotas de Disco<a class=anchor href=#quotas></a></h3><div class=paragraph><p>As cotas de disco podem ser usadas para limitar a quantidade de espaço em disco ou o número de arquivos que um usuário ou membros de um grupo podem alocar em uma base por sistema de arquivos. Isso impede que um usuário ou grupo de usuários consuma todo o espaço em disco disponível.</p></div><div class=paragraph><p>Esta seção descreve como configurar cotas de disco para o sistema de arquivos UFS. Para configurar cotas no sistema de arquivos ZFS, consulte <a href=./#zfs-zfs-quota>Cotas para Datasets</a></p></div><div class=sect3><h4 id=_habilitando_cotas_de_disco>17.11.1. Habilitando Cotas de Disco<a class=anchor href=#_habilitando_cotas_de_disco></a></h4><div class=paragraph><p>Para determinar se o kernel do FreeBSD fornece suporte para cotas de disco:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% sysctl kern.features.ufs_quota
kern.features.ufs_quota: 1</code></pre></div></div><div class=paragraph><p>Neste exemplo, o <code>1</code> indica suporte à cota. Se o valor for <code>0</code>, adicione a seguinte linha a um arquivo de configuração de kernel personalizado e reconstrua o kernel usando as instruções em <a href=./#kernelconfig>Configurando o kernel do FreeBSD</a>:</p></div><div class="literalblock programlisting"><div class=content><pre>options QUOTA</pre></div></div><div class=paragraph><p>Em seguida, habilite as cotas de disco no arquivo <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>quota_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Normalmente, na inicialização, a integridade da cota de cada sistema de arquivos é verificada por <a href="https://man.freebsd.org/cgi/man.cgi?query=quotacheck&amp;sektion=8&amp;format=html">quotacheck(8)</a>. Esse programa garante que os dados no banco de dados de cotas reflitam adequadamente os dados no sistema de arquivos. Este é um processo demorado que afetará significativamente o tempo que o sistema leva para inicializar. Para pular este passo, adicione esta variável ao arquivo <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>check_quotas=&#34;NO&#34;</pre></div></div><div class=paragraph><p>Por fim, edite o arquivo <span class=filename>/etc/fstab</span> para habilitar as cotas de disco por sistema de arquivos. Para habilitar cotas por usuário em um sistema de arquivos, adicione <code>userquota</code> ao campo de opções na entrada <span class=filename>/etc/fstab</span> para o sistema de arquivos ativar as cotas. Por exemplo:</p></div><div class="literalblock programlisting"><div class=content><pre>/dev/da1s2g   /home    ufs rw,userquota 1 2</pre></div></div><div class=paragraph><p>Para ativar cotas de grupo, use <code>groupquota</code>. Para ativar cotas de usuários e grupos, separe as opções com uma vírgula:</p></div><div class="literalblock programlisting"><div class=content><pre>/dev/da1s2g    /home    ufs rw,userquota,groupquota 1 2</pre></div></div><div class=paragraph><p>Por padrão, os arquivos de cota são armazenados no diretório raiz do sistema de arquivos como <span class=filename>quota.user</span> e <span class=filename>quota.group</span>. Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=fstab&amp;sektion=5&amp;format=html">fstab(5)</a> para obter mais informações. Especificar um local alternativo para os arquivos de cotas não é recomendado.</p></div><div class=paragraph><p>Quando a configuração estiver concluída, reinicialize o sistema e o <span class=filename>/etc/rc</span> executará automaticamente os comandos apropriados para criar os arquivos de cotas iniciais para todas as cotas ativadas em <span class=filename>/etc/fstab</span>.</p></div><div class=paragraph><p>No curso normal das operações, não deve haver necessidade de executar manualmente o <a href="https://man.freebsd.org/cgi/man.cgi?query=quotacheck&amp;sektion=8&amp;format=html">quotacheck(8)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=quotaon&amp;sektion=8&amp;format=html">quotaon(8)</a>, ou <a href="https://man.freebsd.org/cgi/man.cgi?query=quotaoff&amp;sektion=8&amp;format=html">quotaoff(8)</a>. No entanto, deve-se ler estas páginas de manual para se familiarizar com sua operação.</p></div></div><div class=sect3><h4 id=_definindo_limites_de_cota>17.11.2. Definindo Limites de Cota<a class=anchor href=#_definindo_limites_de_cota></a></h4><div class=paragraph><p>Para verificar se as cotas estão ativadas, execute:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># quota -v</span></code></pre></div></div><div class=paragraph><p>Deve haver um resumo de uma linha sobre o uso de disco e limites de cota atuais para cada sistema de arquivos em que as cotas estão ativadas.</p></div><div class=paragraph><p>O sistema agora está pronto para receber limites de cota com <code>edquota</code>.</p></div><div class=paragraph><p>Várias opções estão disponíveis para impor limites à quantidade de espaço em disco que um usuário ou grupo pode alocar e quantos arquivos eles podem criar. As alocações podem ser limitadas com base no espaço em disco (cotas de bloco), no número de arquivos (cotas de inode) ou em uma combinação de ambos. Cada limite é subdividido em duas categorias: limites rígidos e flexíveis.</p></div><div class=paragraph><p>Um limite rígido não pode ser excedido. Quando um usuário atinge um limite rígido, nenhuma outra alocação pode ser feita nesse sistema de arquivos por esse usuário. Por exemplo, se o usuário tiver um limite rígido de 500 kbytes em um sistema de arquivos e estiver usando atualmente 490 kbytes, o usuário poderá alocar apenas 10 kbytes adicionais. A tentativa de alocar 11 kbytes adicionais falhará.</p></div><div class=paragraph><p>Os limites flexíveis podem ser excedidos por um período de tempo limitado, conhecido como período de tolerância, que é uma semana por padrão. Se um usuário permanecer acima do limite por mais tempo do que o período de carência, o limite flexível se tornará um limite rígido e nenhuma outra alocação será permitida. Quando o usuário cai abaixo do limite flexível, o período de carência é zerado.</p></div><div class=paragraph><p>No exemplo a seguir, a cota da conta <code>test</code> está sendo editada. Quando <code>edquota</code> é invocado, o editor especificado por <code>EDITOR</code> é aberto para editar os limites de cota. O editor padrão é configurado para vi.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># edquota -u test</span>
Quotas <span class=k>for </span>user <span class=nb>test</span>:
/usr: kbytes <span class=k>in </span>use: 65, limits <span class=o>(</span>soft <span class=o>=</span> 50, hard <span class=o>=</span> 75<span class=o>)</span>
        inodes <span class=k>in </span>use: 7, limits <span class=o>(</span>soft <span class=o>=</span> 50, hard <span class=o>=</span> 60<span class=o>)</span>
/usr/var: kbytes <span class=k>in </span>use: 0, limits <span class=o>(</span>soft <span class=o>=</span> 50, hard <span class=o>=</span> 75<span class=o>)</span>
        inodes <span class=k>in </span>use: 0, limits <span class=o>(</span>soft <span class=o>=</span> 50, hard <span class=o>=</span> 60<span class=o>)</span></code></pre></div></div><div class=paragraph><p>Normalmente, há duas linhas para cada sistema de arquivos com cotas ativadas. Uma linha representa os limites do bloco e a outra representa os limites do inode. Altere o valor para modificar o limite de cota. Por exemplo, para aumentar o limite de blocos em <span class=filename>/usr</span> para um limite flexível de <code>500</code> e um limite rígido de <code>600</code>, altere os valores nesse campo. linha da seguinte forma:</p></div><div class="literalblock programlisting"><div class=content><pre>/usr: kbytes in use: 65, limits (soft = 500, hard = 600)</pre></div></div><div class=paragraph><p>Os novos limites de cotas entram em vigor ao sair do editor.</p></div><div class=paragraph><p>Às vezes, é desejável definir limites de cota em vários usuários. Isso pode ser feito primeiro atribuindo o limite de cota desejado a um usuário. Em seguida, use <code>-p</code> para duplicar essa cota para um intervalo especificado de IDs de usuário (UIDs). O comando a seguir duplicará esses limites de cota para UIDs de <code>10.000</code> até <code>19.999</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># edquota -p test 10000-19999</span></code></pre></div></div><div class=paragraph><p>Para mais informações, consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=edquota&amp;sektion=8&amp;format=html">edquota(8)</a>.</p></div></div><div class=sect3><h4 id=_verificando_limites_de_cota_e_uso_de_disco>17.11.3. Verificando Limites de Cota e Uso de Disco<a class=anchor href=#_verificando_limites_de_cota_e_uso_de_disco></a></h4><div class=paragraph><p>Para verificar cotas individuais de usuários ou de grupos e uso de disco, use <a href="https://man.freebsd.org/cgi/man.cgi?query=quota&amp;sektion=1&amp;format=html">quota(1)</a>. Um usuário só pode examinar sua própria cota e a cota de um grupo do qual é membro. Somente o superusuário pode visualizar todas as cotas de usuários e grupos. Para obter um resumo de todas as cotas e uso de disco para sistemas de arquivos com cotas ativadas, use <a href="https://man.freebsd.org/cgi/man.cgi?query=repquota&amp;sektion=8&amp;format=html">repquota(8)</a>.</p></div><div class=paragraph><p>Normalmente, os sistemas de arquivos nos quais o usuário não está usando nenhum espaço em disco não serão exibidos na saída de <code>quota</code>, mesmo que o usuário tenha um limite de cota atribuído a esse sistema de arquivos. Use <code>-v</code> para exibir esses sistemas de arquivos. A seguir está a saída de amostra de <code>quota -v</code> para um usuário que possui limites de cota em dois sistemas de arquivos.</p></div><div class="literalblock programlisting"><div class=content><pre>Disk quotas for user test (uid 1002):
     Filesystem  usage    quota   limit   grace   files   quota   limit   grace
           /usr      65*     50      75   5days       7      50      60
       /usr/var       0      50      75               0      50      60</pre></div></div><div class=paragraph><p>Neste exemplo, o usuário está atualmente 15 kbytes sobre o limite flexível de 50 kbytes em <span class=filename>/usr</span> e tem 5 dias de período de carência restante. O asterisco <code>*</code> indica que o usuário está atualmente acima do limite de cota.</p></div></div><div class=sect3><h4 id=_quotas_sobre_o_nfs>17.11.4. Quotas sobre o NFS<a class=anchor href=#_quotas_sobre_o_nfs></a></h4><div class=paragraph><p>As cotas são impostas pelo subsistema de cotas no servidor NFS. O daemon <a href="https://man.freebsd.org/cgi/man.cgi?query=rpc.rquotad&amp;sektion=8&amp;format=html">rpc.rquotad(8)</a> disponibiliza informações de quota para <code>quota</code> em clientes NFS, permitindo que os usuários nessas máquinas visualizem suas estatísticas de cota.</p></div><div class=paragraph><p>No servidor NFS, ative o <code>rpc.rquotad</code> removendo o <code>#</code> desta linha em <span class=filename>/etc/inetd.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>rquotad/1      dgram rpc/udp wait root /usr/libexec/rpc.rquotad rpc.rquotad</pre></div></div><div class=paragraph><p>Em seguida, reinicie o <code>inetd</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service inetd restart</span></code></pre></div></div></div></div><div class=sect2><h3 id=disks-encrypting>17.12. Criptografando Partições de Disco<a class=anchor href=#disks-encrypting></a></h3><div class=paragraph><p>O FreeBSD oferece excelentes proteções on-line contra acesso não autorizado a dados. As permissões de arquivo e o <a href=./#mac>Mandatory Access Control</a> (MAC) ajudam a impedir que usuários não autorizados acessem dados enquanto o sistema operacional está ativo e o computador está ligado. No entanto, as permissões impostas pelo sistema operacional são irrelevantes se um invasor tiver acesso físico a um computador e puder mover o disco rígido do computador para outro sistema para copiar e analisar os dados.</p></div><div class=paragraph><p>Independentemente de como um invasor pode ter acesso a um disco rígido ou um computador desligado, os subsistemas criptográficos baseados em GEOM incorporados ao FreeBSD são capazes de proteger os dados nos sistemas de arquivos do computador contra atacantes super motivados com recursos significativos. Ao contrário dos métodos de criptografia que criptografam arquivos individuais, os utilitários incorporados <code>gbde</code> e <code>geli</code> podem ser usados para criptografar de forma transparente sistemas de arquivos inteiros. Nenhum dado aberto sequer toca na bandeja do disco rígido.</p></div><div class=paragraph><p>Este capítulo demonstra como criar um sistema de arquivos criptografado no FreeBSD. Primeiro ele demonstra o processo usando o <code>gbde</code> e depois demonstra o mesmo exemplo usando <code>geli</code>.</p></div><div class=sect3><h4 id=_criptografia_de_disco_com_gbde>17.12.1. Criptografia de Disco com gbde<a class=anchor href=#_criptografia_de_disco_com_gbde></a></h4><div class=paragraph><p>O objetivo do utilitário <a href="https://man.freebsd.org/cgi/man.cgi?query=gbde&amp;sektion=4&amp;format=html">gbde(4)</a> é fornecer um desafio formidável para que um invasor que tenha acesso ao conteúdo de um dispositivo de armazenamento <em>frio</em>. No entanto, se o computador for comprometido enquanto estiver em funcionamento e o dispositivo de armazenamento estiver ativamente conectado, ou se o invasor tiver acesso a uma frase secreta válida, ele não oferecerá proteção ao conteúdo do dispositivo de armazenamento. Portanto, é importante fornecer segurança física enquanto o sistema está em execução e proteger a frase secreta usada pelo mecanismo de criptografia.</p></div><div class=paragraph><p>Este recurso oferece várias barreiras para proteger os dados armazenados em cada setor de disco. Ele criptografa o conteúdo de um setor de disco usando o AES de 128 bits no modo CBC. Cada setor no disco é criptografado com uma chave AES diferente. Para obter mais informações sobre o design criptográfico, incluindo como as chaves do setor são derivadas da frase secreta fornecida pelo usuário, consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=gbde&amp;sektion=4&amp;format=html">gbde(4)</a>.</p></div><div class=paragraph><p>O FreeBSD fornece um módulo do kernel para gbde, que pode ser carregado com este comando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload geom_bde</span></code></pre></div></div><div class=paragraph><p>Se estiver usando um arquivo de configuração de kernel personalizado, certifique-se de que ele contenha esta linha:</p></div><div class=paragraph><p><code>options GEOM_BDE</code></p></div><div class=paragraph><p>O exemplo a seguir demonstra a adição de um novo disco rígido a um sistema que conterá uma única partição criptografada que será montada como <span class=filename>/private</span>.</p></div><div class="exampleblock procedure"><div class=content><div class=paragraph><p><strong>Procedure: Criptografando uma Partição com gbde</strong></p></div><div class="olist arabic"><ol class=arabic><li><p>Adicione o Novo Disco Rígido</p><div class=paragraph><p>Instale a nova unidade no sistema, conforme explicado em <a href=#disks-adding>Adicionando Discos</a>. Para propósitos deste exemplo, uma nova partição de disco rígido foi adicionada como <span class=filename>/dev/ad4s1c</span> e <span class=filename>/dev/ad0s1*</span> representa o existente partições padrão do FreeBSD.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ls /dev/ad*</span>
/dev/ad0        /dev/ad0s1b     /dev/ad0s1e     /dev/ad4s1
/dev/ad0s1      /dev/ad0s1c     /dev/ad0s1f     /dev/ad4s1c
/dev/ad0s1a     /dev/ad0s1d     /dev/ad4</code></pre></div></div></li><li><p>Criar um diretório para conter os arquivos de lock do <code>gbde</code></p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mkdir /etc/gbde</span></code></pre></div></div><div class=paragraph><p>O arquivo de lock gbde contém informações que o gbde requer para acessar partições criptografadas. Sem acesso ao arquivo de lock, o gbde não poderá descriptografar os dados contidos na partição criptografada sem intervenção manual significativa que não seja suportada pelo software. Cada partição criptografada usa um arquivo de lock separado.</p></div></li><li><p>Inicialize a Partição <code>gbde</code></p><div class=paragraph><p>Uma partição gbde deve ser inicializada antes de poder ser usada. Essa inicialização precisa ser executada apenas uma vez. Esse comando abrirá o editor padrão, para definir várias opções de configuração em um modelo. Para uso com o sistema de arquivos UFS, defina o sector_size como 2048:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gbde init /dev/ad4s1c -i -L /etc/gbde/ad4s1c.lock</span>
<span class=c># $FreeBSD: head/pt_BR.ISO8859-1/books/handbook/book.xml 53984 2020-03-15 16:03:31Z dbaio $</span>
<span class=c>#</span>
<span class=c># Sector size is the smallest unit of data which can be read or written.</span>
<span class=c># Making it too small decreases performance and decreases available space.</span>
<span class=c># Making it too large may prevent filesystems from working.  512 is the</span>
<span class=c># minimum and always safe.  For UFS, use the fragment size</span>
<span class=c>#</span>
sector_size	<span class=o>=</span>	2048
<span class=o>[</span>...]</code></pre></div></div><div class=paragraph><p>Depois que a edição for salva, o usuário será solicitado a digitar duas vezes a frase secreta usada para proteger os dados. A frase secreta deve ser a mesma em ambas as vezes. A capacidade de gbde de proteger os dados depende inteiramente da qualidade da frase secreta. Para obter dicas sobre como selecionar uma frase secreta que seja fácil de lembrar, consulte <a href=http://world.std.com/~reinhold/diceware.html>http://world.std.com/~reinhold/diceware.htm</a>.</p></div><div class=paragraph><p>Essa inicialização cria um arquivo de lock para a partição do gbde. Neste exemplo, ele é armazenado como <span class=filename>/etc/gbde/ad4s1c.lock</span>. Os arquivos de lock devem terminar em ".lock" para serem corretamente detectados pelo script de inicialização do <span class=filename>/etc/rc.d/gbde</span>.</p></div><div class="admonitionblock caution"><table><tbody><tr><td class=icon><i class="fa icon-caution" title=Caution></i></td><td class=content><div class=paragraph><p>Arquivos de lock <em>devem</em> ter backups junto com o conteúdo de qualquer partição criptografada. Sem o arquivo de lock, o proprietário legítimo não poderá acessar os dados na partição criptografada.</p></div></td></tr></tbody></table></div></li><li><p>Anexando a Partição Criptografada ao Kernel</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gbde attach /dev/ad4s1c -l /etc/gbde/ad4s1c.lock</span></code></pre></div></div><div class=paragraph><p>Este comando solicitará a entrada da senha que foi selecionada durante a inicialização da partição criptografada. O novo dispositivo criptografado aparecerá em <span class=filename>/dev</span> como <span class=filename>/dev/device_name.bde</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ls /dev/ad*</span>
/dev/ad0        /dev/ad0s1b     /dev/ad0s1e     /dev/ad4s1
/dev/ad0s1      /dev/ad0s1c     /dev/ad0s1f     /dev/ad4s1c
/dev/ad0s1a     /dev/ad0s1d     /dev/ad4        /dev/ad4s1c.bde</code></pre></div></div></li><li><p>Criando um Sistema de Arquivos no Dispositivo Criptografado</p><div class=paragraph><p>Uma vez que o dispositivo criptografado tenha sido anexado ao kernel, um sistema de arquivos pode ser criado no dispositivo. Este exemplo cria um sistema de arquivos UFS com atualizações soft ativadas. Certifique-se de especificar a partição que possui uma extensão <span class=filename>*.bde</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># newfs -U /dev/ad4s1c.bde</span></code></pre></div></div></li><li><p>Montando a Partição Criptografada</p><div class=paragraph><p>Crie um ponto de montagem e monte o sistema de arquivos criptografados:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mkdir /private</span>
<span class=c># mount /dev/ad4s1c.bde /private</span></code></pre></div></div></li><li><p>Verificar se o sistema de arquivos criptografados está disponível</p><div class=paragraph><p>O sistema de arquivos criptografados agora deve estar visível e disponível para uso:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>df</span> <span class=nt>-H</span>
Filesystem        Size   Used  Avail Capacity  Mounted on
/dev/ad0s1a      1037M    72M   883M     8%    /
/devfs            1.0K   1.0K     0B   100%    /dev
/dev/ad0s1f       8.1G    55K   7.5G     0%    /home
/dev/ad0s1e      1037M   1.1M   953M     0%    /tmp
/dev/ad0s1d       6.1G   1.9G   3.7G    35%    /usr
/dev/ad4s1c.bde   150G   4.1K   138G     0%    /private</code></pre></div></div></li></ol></div></div></div><div class=paragraph><p>Após cada inicialização, todos os sistemas de arquivos criptografados devem ser reconectados manualmente ao kernel, verificados quanto a erros e montados antes que os sistemas de arquivos possam ser usados. Para configurar estas etapas, adicione as seguintes linhas ao arquivo <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>gbde_autoattach_all=&#34;YES&#34;
gbde_devices=&#34;ad4s1c&#34;
gbde_lockdir=&#34;/etc/gbde&#34;</pre></div></div><div class=paragraph><p>Isso requer que a frase secreta seja inserida no console no momento da inicialização. Depois de digitar a senha correta, a partição criptografada será montada automaticamente. Opções adicionais de inicialização do gbde estão disponíveis e listadas em <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>O sysinstall é incompatível com os dispositivos criptografados com gbde. Todos os dispositivos <span class=filename>*.bde</span> devem ser desanexado do kernel antes de iniciar o sysinstall ou ele irá travar durante a análise inicial dos dispositivos. Para desanexar o dispositivo criptografado usado no exemplo, use o seguinte comando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gbde detach /dev/ad4s1c</span></code></pre></div></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=disks-encrypting-geli>17.12.2. Criptografia de Disco com <code>geli</code><a class=anchor href=#disks-encrypting-geli></a></h4><div class=paragraph><p>Uma classe criptográfica alternativa GEOM está disponível usando <code>geli</code>. Este utilitário de controle adiciona alguns recursos e usa um esquema diferente para fazer trabalho criptográfico. Ele fornece os seguintes recursos:</p></div><div class=ulist><ul><li><p>Utiliza o framework <a href="https://man.freebsd.org/cgi/man.cgi?query=crypto&amp;sektion=9&amp;format=html">crypto(9)</a> e usa automaticamente o hardware criptográfico quando ele está disponível.</p></li><li><p>Suporta vários algoritmos criptográficos, como AES, Blowfish e 3DES.</p></li><li><p>Permite que a partição raiz seja criptografada. A frase secreta usada para acessar a partição root criptografada será solicitada durante a inicialização do sistema.</p></li><li><p>Permite o uso de duas chaves independentes.</p></li><li><p>É rápido, pois executa criptografia simples de setor a setor.</p></li><li><p>Permite backup e restauração de chaves mestras. Se um usuário destruir suas chaves, ainda é possível obter acesso aos dados restaurando as chaves do backup.</p></li><li><p>Permite que um disco seja anexado com uma chave única aleatória que é útil para partições swap e sistemas de arquivos temporários.</p></li></ul></div><div class=paragraph><p>Mais recursos e exemplos de uso podem ser encontrados em <a href="https://man.freebsd.org/cgi/man.cgi?query=geli&amp;sektion=8&amp;format=html">geli(8)</a>.</p></div><div class=paragraph><p>O exemplo a seguir descreve como gerar um arquivo de chave que será usado como parte da chave mestra para o provedor criptografado montado em <span class=filename>/private</span>. O arquivo chave fornecerá alguns dados aleatórios usados para criptografar a chave mestra. A chave mestra também será protegida por uma frase secreta. O tamanho do setor do provedor será de 4kB. O exemplo descreve como se conectar ao provedor <code>geli</code>, criar um sistema de arquivos, montá-lo, trabalhar com ele e, finalmente, como desanexá-lo.</p></div><div class="exampleblock procedure"><div class=content><div class=paragraph><p><strong>Procedure: Criptografando uma Partição com <code>geli</code></strong></p></div><div class="olist arabic"><ol class=arabic><li><p>Carregando o suporte ao <code>geli</code></p><div class=paragraph><p>O suporte para <code>geli</code> está disponível como um módulo de kernel carregável. Para configurar o sistema para carregar automaticamente o módulo no momento da inicialização, adicione a seguinte linha ao arquivo <span class=filename>/boot/loader.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>geom_eli_load=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Para carregar o módulo do kernel agora:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload geom_eli</span></code></pre></div></div><div class=paragraph><p>Para um kernel customizado, assegure-se de que o arquivo de configuração do kernel contenha estas linhas:</p></div><div class="literalblock programlisting"><div class=content><pre>options GEOM_ELI
device crypto</pre></div></div></li><li><p>Gerando a Chave Mestra</p><div class=paragraph><p>Os comandos a seguir geram uma chave mestra com a qual todos os dados serão criptografados. Esta chave nunca pode ser alterada. Em vez de usá-lo diretamente, ele é criptografado com uma ou mais chaves de usuário. As chaves do usuário são compostas por uma combinação opcional de bytes aleatórios de um arquivo, <span class=filename>/root/da2.key</span> e/ou uma senha. Neste caso, a fonte de dados do arquivo de chave é <span class=filename>/dev/random</span>. Este comando também configura o tamanho do setor do provedor (<span class=filename>/dev/da2.eli</span>) como 4kB, para melhor desempenho:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dd if=/dev/random of=/root/da2.key bs=64 count=1</span>
<span class=c># geli init -K /root/da2.key -s 4096 /dev/da2</span>
Enter new passphrase:
Reenter new passphrase:</code></pre></div></div><div class=paragraph><p>Não é obrigatório o uso de uma frase secreta e de um arquivo de chave, pois cada método de proteger a chave mestra pode ser usado isoladamente.</p></div><div class=paragraph><p>Se o arquivo de chave é dado como "-", a entrada padrão será usada. Por exemplo, este comando gera três arquivos principais:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cat keyfile1 keyfile2 keyfile3 | geli init -K - /dev/da2</span></code></pre></div></div></li><li><p>Anexando o Provedor com a Chave Gerada</p><div class=paragraph><p>Para anexar o provedor, especifique o arquivo de chave, o nome do disco e a frase secreta:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># geli attach -k /root/da2.key /dev/da2</span>
Enter passphrase:</code></pre></div></div><div class=paragraph><p>Isso cria um novo dispositivo com uma extensão <span class=filename>.eli</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ls /dev/da2*</span>
/dev/da2  /dev/da2.eli</code></pre></div></div></li><li><p>Criando o Novo Sistema de Arquivos</p><div class=paragraph><p>Em seguida, formate o dispositivo com o sistema de arquivos UFS e monte-o em um ponto de montagem existente:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dd if=/dev/random of=/dev/da2.eli bs=1m</span>
<span class=c># newfs /dev/da2.eli</span>
<span class=c># mount /dev/da2.eli /private</span></code></pre></div></div><div class=paragraph><p>O sistema de arquivos criptografado agora deve estar disponível para uso:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># df -H</span>
Filesystem     Size   Used  Avail Capacity  Mounted on
/dev/ad0s1a    248M    89M   139M    38%    /
/devfs         1.0K   1.0K     0B   100%    /dev
/dev/ad0s1f    7.7G   2.3G   4.9G    32%    /usr
/dev/ad0s1d    989M   1.5M   909M     0%    /tmp
/dev/ad0s1e    3.9G   1.3G   2.3G    35%    /var
/dev/da2.eli   150G   4.1K   138G     0%    /private</code></pre></div></div></li></ol></div></div></div><div class=paragraph><p>Uma vez que o trabalho na partição criptografada é feito, e a partição <span class=filename>/private</span> não é mais necessária, é prudente colocar o dispositivo no armazenamento frio desmontando e desanexando a partição <code>geli</code> criptografada do kernel:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># umount /private</span>
<span class=c># geli detach da2.eli</span></code></pre></div></div><div class=paragraph><p>Um script <span class=filename>rc.d</span> é fornecido para simplificar a montagem de dispositivos criptografados <code>geli</code> no momento da inicialização. Para este exemplo, adicione estas linhas ao arquivo <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>geli_devices=&#34;da2&#34;
geli_da2_flags=&#34;-k /root/da2.key&#34;</pre></div></div><div class=paragraph><p>Isto configura o <span class=filename>/dev/da2</span> como um provedor <code>geli</code> com uma chave mestra de <span class=filename>/root/da2.key</span>. O sistema irá desanexando automaticamente o provedor do kernel antes que o sistema seja desligado. Durante o processo de inicialização, o script solicitará a frase secreta antes de conectar o provedor. Outras mensagens do kernel podem ser mostradas antes e depois do prompt da frase secreta. Se o processo de inicialização parecer travar, procure cuidadosamente o prompt de senha entre as outras mensagens. Depois que a frase secreta correta é inserida, o provedor é anexado. O sistema de arquivos é então montado, normalmente por uma entrada em <span class=filename>/etc/fstab</span>. Consulte <a href=./#mount-unmount>Montando e Desmontando Sistemas de Arquivos</a> para obter instruções sobre como configurar um sistema de arquivos para montar no momento da inicialização.</p></div></div></div><div class=sect2><h3 id=swap-encrypting>17.13. Criptografando Swap<a class=anchor href=#swap-encrypting></a></h3><div class=paragraph><p>Como a criptografia de partições de disco, a criptografia do espaço swap é usada para proteger informações confidenciais. Considere um aplicativo que lida com senhas. Contanto que essas senhas permaneçam na memória física, elas não serão gravadas no disco e serão apagadas após a reinicialização. No entanto, se o FreeBSD iniciar a troca de páginas de memória para liberar espaço, as senhas podem ser gravadas no disco não criptografadas. O espaço de troca de criptografia pode ser uma solução para esse cenário.</p></div><div class=paragraph><p>Esta seção demonstra como configurar uma partição swap criptografada usando criptografia <a href="https://man.freebsd.org/cgi/man.cgi?query=gbde&amp;sektion=8&amp;format=html">gbde(8)</a> ou <a href="https://man.freebsd.org/cgi/man.cgi?query=geli&amp;sektion=8&amp;format=html">geli(8)</a>. Ele assume que <span class=filename>/dev/ada0s1b</span> é a partição swap.</p></div><div class=sect3><h4 id=_configurando_swap_criptografada>17.13.1. Configurando Swap Criptografada<a class=anchor href=#_configurando_swap_criptografada></a></h4><div class=paragraph><p>As partições de swap não são criptografadas por padrão e devem ser limpas de quaisquer dados confidenciais antes de continuar. Para sobrescrever a partição swap atual com lixo aleatório, execute o seguinte comando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dd if=/dev/random of=/dev/ada0s1b bs=1m</span></code></pre></div></div><div class=paragraph><p>Para criptografar a partição swap usando <a href="https://man.freebsd.org/cgi/man.cgi?query=gbde&amp;sektion=8&amp;format=html">gbde(8)</a>, adicione o sufixo <code>.bde</code> à linha de swap no <span class=filename>/etc/fstab</span>:</p></div><div class="literalblock programlisting"><div class=content><pre># Device		Mountpoint	FStype	Options		Dump	Pass#
/dev/ada0s1b.bde	none		swap	sw		0	0</pre></div></div><div class=paragraph><p>Para criptografar a partição swap usando <a href="https://man.freebsd.org/cgi/man.cgi?query=geli&amp;sektion=8&amp;format=html">geli(8)</a>, use o sufixo <code>.eli</code>:</p></div><div class="literalblock programlisting"><div class=content><pre># Device		Mountpoint	FStype	Options		Dump	Pass#
/dev/ada0s1b.eli	none		swap	sw		0	0</pre></div></div><div class=paragraph><p>Por padrão, <a href="https://man.freebsd.org/cgi/man.cgi?query=geli&amp;sektion=8&amp;format=html">geli(8)</a> usa o algoritmo AES com um comprimento de chave de 128 bits. Normalmente, as configurações padrão serão suficientes. Se desejado, estes padrões podem ser alterados no campo de opções no arquivo <span class=filename>/etc/fstab</span>. As possíveis flags são:</p></div><div class=dlist><dl><dt class=hdlist1>aalgo</dt><dd><p>Algoritmo de verificação de integridade de dados usado para garantir que os dados criptografados não tenham sido adulterados. Veja <a href="https://man.freebsd.org/cgi/man.cgi?query=geli&amp;sektion=8&amp;format=html">geli(8)</a> para obter uma lista dos algoritmos suportados.</p></dd><dt class=hdlist1>ealgo</dt><dd><p>Algoritmo de criptografia usado para proteger os dados. Veja <a href="https://man.freebsd.org/cgi/man.cgi?query=geli&amp;sektion=8&amp;format=html">geli(8)</a> para obter uma lista dos algoritmos suportados.</p></dd><dt class=hdlist1>keylen</dt><dd><p>O comprimento da chave usada para o algoritmo de criptografia. Veja <a href="https://man.freebsd.org/cgi/man.cgi?query=geli&amp;sektion=8&amp;format=html">geli(8)</a> para os comprimentos de chave que são suportados por cada algoritmo de criptografia.</p></dd><dt class=hdlist1>sectorsize</dt><dd><p>O tamanho em que o blocos de dados é dividido antes de ser criptografado. Tamanhos de setor maiores aumentam o desempenho ao custo de maior sobrecarga de armazenamento. O tamanho recomendado é de 4096 bytes.</p></dd></dl></div><div class=paragraph><p>Este exemplo configura uma partição swap criptografada usando o algoritmo Blowfish com um comprimento de chave de 128 bits e um setor de tamanho de 4 kilobytes:</p></div><div class="literalblock programlisting"><div class=content><pre># Device		Mountpoint	FStype	Options				Dump	Pass#
/dev/ada0s1b.eli	none		swap	sw,ealgo=blowfish,keylen=128,sectorsize=4096	0	0</pre></div></div></div><div class=sect3><h4 id=_verificação_de_swap_criptografada>17.13.2. Verificação de Swap Criptografada<a class=anchor href=#_verificação_de_swap_criptografada></a></h4><div class=paragraph><p>Depois que o sistema for reinicializado, a operação adequada da swap criptografada poderá ser verificada usando <code>swapinfo</code>.</p></div><div class=paragraph><p>Se <a href="https://man.freebsd.org/cgi/man.cgi?query=gbde&amp;sektion=8&amp;format=html">gbde(8)</a> estiver sendo usado:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% swapinfo
Device          1K-blocks     Used    Avail Capacity
/dev/ada0s1b.bde   542720        0   542720     0%</code></pre></div></div><div class=paragraph><p>Se <a href="https://man.freebsd.org/cgi/man.cgi?query=geli&amp;sektion=8&amp;format=html">geli(8)</a> estiver sendo usado:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% swapinfo
Device          1K-blocks     Used    Avail Capacity
/dev/ada0s1b.eli   542720        0   542720     0%</code></pre></div></div></div></div><div class=sect2><h3 id=disks-hast>17.14. Alta Disponibilidade de Armazenamento (HAST)<a class=anchor href=#disks-hast></a></h3><div class=paragraph><p>A alta disponibilidade é um dos principais requisitos em aplicativos de negócios sérios e o armazenamento altamente disponível é um componente-chave nesses ambientes. No FreeBSD, o framework Alta Disponiblidade de Armazenamento (HAST) permite o armazenamento transparente dos mesmos dados em várias máquinas fisicamente separadas conectadas por uma rede TCP/IP. HAST pode ser entendido como um RAID1 (mirror) baseado em rede, e é similar ao sistema de armazenamento DRBD® usado na plataforma GNU/Linux™. Em combinação com outros recursos de alta disponibilidade do FreeBSD, como o CARP, o HAST possibilita a criação de um cluster de armazenamento altamente disponível, resistente a falhas de hardware.</p></div><div class=paragraph><p>A seguir estão as principais características do HAST:</p></div><div class=ulist><ul><li><p>Pode ser usado para mascarar erros de I/O em discos rígidos locais.</p></li><li><p>Agnóstico a sistema de arquivos, pois funciona com qualquer sistema de arquivos suportado pelo FreeBSD.</p></li><li><p>Ressincronização eficiente e rápida, pois somente os blocos que foram modificados durante o tempo de inatividade de um nó são sincronizados.</p></li><li><p>Pode ser usado em um ambiente já implantado para adicionar redundância adicional.</p></li><li><p>Juntamente com o CARP, Heartbeat, ou outras ferramentas, ele pode ser usado para construir um sistema de armazenamento robusto e durável.</p></li></ul></div><div class=paragraph><p>Depois de ler esta seção, você saberá:</p></div><div class=ulist><ul><li><p>O que é HAST, como ele funciona e quais recursos ele fornece.</p></li><li><p>Como configurar e usar o HAST no FreeBSD.</p></li><li><p>Como integrar CARP e <a href="https://man.freebsd.org/cgi/man.cgi?query=devd&amp;sektion=8&amp;format=html">devd(8)</a> para criar um sistema de armazenamento robusto.</p></li></ul></div><div class=paragraph><p>Antes de ler esta seção, você deve:</p></div><div class=ulist><ul><li><p>Entender os fundamentos do UNIX™ e do FreeBSD (<a href=./#basics>Fundamentos do FreeBSD</a>).</p></li><li><p>Saber como configurar interfaces de rede e outros subsistemas principais do FreeBSD (<a href=./#config-tuning>Configuração e Ajuste</a>).</p></li><li><p>Ter uma boa compreensão da rede do FreeBSD (<a href=./#network-communication>Comunicação de rede</a>).</p></li></ul></div><div class=paragraph><p>O projeto HAST foi patrocinado pela Fundação FreeBSD com o apoio de <a href=http://www.omc.net/>http://www.omc.net/</a> e <a href=http://www.transip.nl/>http://www.transip.nl/</a>.</p></div><div class=sect3><h4 id=_operação_hast>17.14.1. Operação HAST<a class=anchor href=#_operação_hast></a></h4><div class=paragraph><p>O HAST fornece replicação síncrona em nível de bloco entre duas máquinas físicas: o <em>primário</em>, também conhecido como o nó <em>master</em>, e o <em>secundário</em>, ou nó <em>slave</em>. Essas duas máquinas juntas são chamadas de cluster.</p></div><div class=paragraph><p>Como o HAST funciona em uma configuração primária-secundária, ele permite que apenas um dos nós do cluster esteja ativo a qualquer momento. O nó primário, também chamado de <em>active</em>, é aquele que irá lidar com todas as solicitações de I/O para dispositivos gerenciados por HAST. O nó secundário é automaticamente sincronizado a partir do nó primário.</p></div><div class=paragraph><p>Os componentes físicos do sistema HAST são o disco local no nó primário e o disco no nó secundário remoto.</p></div><div class=paragraph><p>O HAST opera de forma síncrona em um nível de bloco, tornando-o transparente para sistemas de arquivos e aplicativos. O HAST fornece provedores GEOM regulares em <span class=filename>/dev/hast/</span> para uso por outras ferramentas ou aplicativos. Não há diferença entre o uso de dispositivos HAST e discos ou partições brutas.</p></div><div class=paragraph><p>Cada operação de gravação, exclusão ou liberação é enviada para o disco local e para o disco remoto sobre TCP/IP . Cada operação de leitura é fornecida a partir do disco local, a menos que o disco local não esteja atualizado ou ocorra um erro de I/O. Nesses casos, a operação de leitura é enviada para o nó secundário.</p></div><div class=paragraph><p>HAST tenta fornecer recuperação rápida de falhas. Por esse motivo, é importante reduzir o tempo de sincronização após a interrupção de um nó. Para fornecer sincronização rápida, o HAST gerencia um bitmap no disco de extensões sujas e sincroniza apenas aquelas durante uma sincronização regular, com exceção da sincronização inicial.</p></div><div class=paragraph><p>Existem muitas maneiras de lidar com a sincronização. O HAST implementa vários modos de replicação para lidar com diferentes métodos de sincronização:</p></div><div class=ulist><ul><li><p><em>memsync</em>: Este modo reporta uma operação de gravação como concluída quando a operação de gravação local é finalizada e quando o nó remoto reconhece a chegada dos dados, mas antes de realmente armazenar os dados. Os dados no nó remoto serão armazenados diretamente após o envio da confirmação. Este modo destina-se a reduzir a latência, mas ainda fornece boa confiabilidade. Este modo é o padrão.</p></li><li><p><em>fullsync</em>: Este modo relata uma operação de gravação como concluída quando a gravação local e a gravação remota são concluídas. Este é o modo de replicação mais seguro e mais lento.</p></li><li><p><em>async</em>: Este modo relata uma operação de gravação como concluída quando a gravação local é concluída. Este é o modo de replicação mais rápido e mais perigoso. Ele deve ser usado somente ao replicar para um nó distante, onde a latência é muito alta para outros modos.</p></li></ul></div></div><div class=sect3><h4 id=_configuração_do_hast>17.14.2. Configuração do HAST<a class=anchor href=#_configuração_do_hast></a></h4><div class=paragraph><p>O framework HAST consiste em vários componentes:</p></div><div class=ulist><ul><li><p>O daemon <a href="https://man.freebsd.org/cgi/man.cgi?query=hastd&amp;sektion=8&amp;format=html">hastd(8)</a> que fornece sincronização de dados. Quando este daemon é iniciado, ele carregará automaticamente <code>geom_gate.ko</code>.</p></li><li><p>O utilitário de gerenciamento de usuário, <a href="https://man.freebsd.org/cgi/man.cgi?query=hastctl&amp;sektion=8&amp;format=html">hastctl(8)</a>.</p></li><li><p>O arquivo de configuração <a href="https://man.freebsd.org/cgi/man.cgi?query=hast.conf&amp;sektion=5&amp;format=html">hast.conf(5)</a>. Este arquivo deve existir antes de iniciar o hastd.</p></li></ul></div><div class=paragraph><p>Usuários que preferem construir estaticamente o suporte a <code>GEOM_GATE</code> no kernel devem adicionar esta linha ao arquivo de configuração do kernel personalizado e reconstruir o kernel usando as instruções em <a href=./#kernelconfig>Configurando o kernel do FreeBSD</a>:</p></div><div class="literalblock programlisting"><div class=content><pre>options	GEOM_GATE</pre></div></div><div class=paragraph><p>O exemplo a seguir descreve como configurar dois nós na operação mestre-escravo/primário-secundário usando HAST para replicar os dados entre os dois. Os nós serão chamados <code>hasta</code>, com um endereço IP <code>172.16.0.1</code>, e <code>hastb</code>, com um endereço IP <code>172.16.0.2</code>. Ambos os nós terão um disco rígido dedicado <span class=filename>/dev/ad6</span> do mesmo tamanho para a operação HAST. O conjunto HAST, por vezes referido como um recurso ou o provedor GEOM em <span class=filename>/dev/hast/</span>, será chamado <code>test</code>.</p></div><div class=paragraph><p>A configuração do HAST é feita usando o arquivo <span class=filename>/etc/hast.conf</span>. Este arquivo deve ser idêntico nos dois nós. A configuração mais simples é:</p></div><div class="literalblock programlisting"><div class=content><pre>resource test {
	on hasta {
		local /dev/ad6
		remote 172.16.0.2
	}
	on hastb {
		local /dev/ad6
		remote 172.16.0.1
	}
}</pre></div></div><div class=paragraph><p>Para uma configuração mais avançada, consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=hast.conf&amp;sektion=5&amp;format=html">hast.conf(5)</a>.</p></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Também é possível usar nomes de host nas instruções <code>remote</code> se os hosts forem resolvidos e definidos no arquivo <span class=filename>/etc/hosts</span> ou no DNS local.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Uma vez que a configuração exista em ambos os nós, o conjunto HAST pode ser criado. Execute esses comandos nos dois nós para colocar os metadados iniciais no disco local e para iniciar <a href="https://man.freebsd.org/cgi/man.cgi?query=hastd&amp;sektion=8&amp;format=html">hastd(8)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># hastctl create test</span>
<span class=c># service hastd onestart</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p><em>Não</em> é possível usar os provedores GEOM com um sistema de arquivos existente ou converter um armazenamento existente em um pool gerenciado por HAST. Esse procedimento precisa armazenar alguns metadados no provedor e não haverá espaço suficiente disponível em um provedor existente.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Um nó HAST <code>primário</code> ou <code>secundário</code> é selecionado por um administrador, ou software como Heartbeat, usando <a href="https://man.freebsd.org/cgi/man.cgi?query=hastctl&amp;sektion=8&amp;format=html">hastctl(8)</a>. No nó primário, <code>hasta</code>, execute este comando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># hastctl role primary test</span></code></pre></div></div><div class=paragraph><p>Execute este comando no nó secundário, <code>hastb</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># hastctl role secondary test</span></code></pre></div></div><div class=paragraph><p>Verifique o resultado executando <code>hastctl</code> em cada nó:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># hastctl status test</span></code></pre></div></div><div class=paragraph><p>Verifique a linha <code>status</code> na saída. Se disser <code>degraded</code>, algo está errado com o arquivo de configuração. Ele deve dizer <code>complete</code> em cada nó, o que significa que a sincronização entre os nós foi iniciada. A sincronização é concluída quando <code>hastctl status</code> relata 0 bytes de extensões <code>sujas</code>.</p></div><div class=paragraph><p>O próximo passo é criar um sistema de arquivos no provedor GEOM e montá-lo. Isso deve ser feito no nó <code>primário</code>. A criação do sistema de arquivos pode levar alguns minutos, dependendo do tamanho do disco rígido. Este exemplo cria um sistema de arquivos UFS em <span class=filename>/dev/hast/test</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># newfs -U /dev/hast/test</span>
<span class=c># mkdir /hast/test</span>
<span class=c># mount /dev/hast/test /hast/test</span></code></pre></div></div><div class=paragraph><p>Uma vez que o framework HAST esteja configurado corretamente, o passo final é garantir que o HAST seja iniciado automaticamente durante a inicialização do sistema. Adicione esta linha ao <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>hastd_enable=&#34;YES&#34;</pre></div></div><div class=sect4><h5 id=_configuração_de_failover>17.14.2.1. Configuração de Failover<a class=anchor href=#_configuração_de_failover></a></h5><div class=paragraph><p>O objetivo deste exemplo é construir um sistema de armazenamento robusto que seja resistente à falha de qualquer nó. Se o nó primário falhar, o nó secundário estará lá para assumir o controle, verificar e montar o sistema de arquivos e continuar a trabalhar sem perder um único bit de dados.</p></div><div class=paragraph><p>Para realizar essa tarefa, o Protocolo de Redundância de Endereços Comuns (CARP) é usado para fornecer failover automático na camada IP. O CARP permite que vários hosts no mesmo segmento de rede compartilhem um endereço IP. Configure o CARP em ambos os nós do cluster de acordo com a documentação disponível em <a href=./#carp>Protocolo Comum de Redundância de Endereços (CARP)</a>. Neste exemplo, cada nó terá seu próprio endereço de gerenciamento IP e um endereço IP compartilhado de <em>172.16.0.254</em>. O nó principal HAST do cluster deve ser o nó mestre CARP.</p></div><div class=paragraph><p>O pool HAST criado na seção anterior está agora pronto para ser exportado para os outros hosts da rede. Isso pode ser feito exportando-o através do NFS ou Samba, usando o endereço IP_172.16.0.254_ compartilhado. O único problema que permanece não resolvido é um failover automático caso o nó primário falhe.</p></div><div class=paragraph><p>Caso as interfaces do CARP subam ou desçam, o sistema operacional FreeBSD gera um evento <a href="https://man.freebsd.org/cgi/man.cgi?query=devd&amp;sektion=8&amp;format=html">devd(8)</a>, tornando possível observar mudanças de estado nas interfaces do CARP. Uma alteração de estado na interface CARP é uma indicação de que um dos nós falhou ou voltou a ficar online. Esses eventos de mudança de estado tornam possível executar um script que manipulará automaticamente o failover HAST.</p></div><div class=paragraph><p>Para capturar mudanças de estado nas interfaces do CARP, adicione esta configuração ao <span class=filename>/etc/devd.conf</span> em cada nó:</p></div><div class="literalblock programlisting"><div class=content><pre>notify 30 {
	match &#34;system&#34; &#34;IFNET&#34;;
	match &#34;subsystem&#34; &#34;carp0&#34;;
	match &#34;type&#34; &#34;LINK_UP&#34;;
	action &#34;/usr/local/sbin/carp-hast-switch master&#34;;
};

notify 30 {
	match &#34;system&#34; &#34;IFNET&#34;;
	match &#34;subsystem&#34; &#34;carp0&#34;;
	match &#34;type&#34; &#34;LINK_DOWN&#34;;
	action &#34;/usr/local/sbin/carp-hast-switch slave&#34;;
};</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Se os sistemas estiverem executando o FreeBSD 10 ou superior, substitua <span class=filename>carp0</span> pelo nome da interface configurada CARP.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Reinicie o <a href="https://man.freebsd.org/cgi/man.cgi?query=devd&amp;sektion=8&amp;format=html">devd(8)</a> em ambos os nós para colocar a nova configuração em vigor:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service devd restart</span></code></pre></div></div><div class=paragraph><p>Quando o estado da interface especificada é alterado subindo ou descendo, o sistema gera uma notificação, permitindo que o subsistema <a href="https://man.freebsd.org/cgi/man.cgi?query=devd&amp;sektion=8&amp;format=html">devd(8)</a> execute o script de failover automático especificado, <span class=filename>/usr/local/sbin/carp-hast-switch</span>. Para maiores esclarecimentos sobre esta configuração, consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=devd.conf&amp;sektion=5&amp;format=html">devd.conf(5)</a>.</p></div><div class=paragraph><p>Aqui está um exemplo de um script de failover automatizado:</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh

# Original script by Freddie Cash &lt;fjwcash@gmail.com&gt;
# Modified by Michael W. Lucas &lt;mwlucas@BlackHelicopters.org&gt;
# and Viktor Petersson &lt;vpetersson@wireload.net&gt;

# The names of the HAST resources, as listed in /etc/hast.conf
resources=&#34;test&#34;

# delay in mounting HAST resource after becoming master
# make your best guess
delay=3

# logging
log=&#34;local0.debug&#34;
name=&#34;carp-hast&#34;

# end of user configurable stuff

case &#34;$1&#34; in
	master)
		logger -p $log -t $name &#34;Switching to primary provider for ${resources}.&#34;
		sleep ${delay}

		# Wait for any &#34;hastd secondary&#34; processes to stop
		for disk in ${resources}; do
			while $( pgrep -lf &#34;hastd: ${disk} \(secondary\)&#34; &gt; /dev/null 2&gt;&amp;1 ); do
				sleep 1
			done

			# Switch role for each disk
			hastctl role primary ${disk}
			if [ $? -ne 0 ]; then
				logger -p $log -t $name &#34;Unable to change role to primary for resource ${disk}.&#34;
				exit 1
			fi
		done

		# Wait for the /dev/hast/* devices to appear
		for disk in ${resources}; do
			for I in $( jot 60 ); do
				[ -c &#34;/dev/hast/${disk}&#34; ] &amp;&amp; break
				sleep 0.5
			done

			if [ ! -c &#34;/dev/hast/${disk}&#34; ]; then
				logger -p $log -t $name &#34;GEOM provider /dev/hast/${disk} did not appear.&#34;
				exit 1
			fi
		done

		logger -p $log -t $name &#34;Role for HAST resources ${resources} switched to primary.&#34;

		logger -p $log -t $name &#34;Mounting disks.&#34;
		for disk in ${resources}; do
			mkdir -p /hast/${disk}
			fsck -p -y -t ufs /dev/hast/${disk}
			mount /dev/hast/${disk} /hast/${disk}
		done

	;;

	slave)
		logger -p $log -t $name &#34;Switching to secondary provider for ${resources}.&#34;

		# Switch roles for the HAST resources
		for disk in ${resources}; do
			if ! mount | grep -q &#34;^/dev/hast/${disk} on &#34;
			then
			else
				umount -f /hast/${disk}
			fi
			sleep $delay
			hastctl role secondary ${disk} 2&gt;&amp;1
			if [ $? -ne 0 ]; then
				logger -p $log -t $name &#34;Unable to switch role to secondary for resource ${disk}.&#34;
				exit 1
			fi
			logger -p $log -t $name &#34;Role switched to secondary for resource ${disk}.&#34;
		done
	;;
esac</pre></div></div><div class=paragraph><p>Em poucas palavras, o script executa essas ações quando um nó se torna mestre:</p></div><div class=ulist><ul><li><p>Promove o pool de HAST para primário no outro nó.</p></li><li><p>Verifica o sistema de arquivos no pool HAST.</p></li><li><p>Monta o pool.</p></li></ul></div><div class=paragraph><p>Quando um nó se torna secundário:</p></div><div class=ulist><ul><li><p>Desmonta o conjunto HAST.</p></li><li><p>Degrada o pool HAST para secundário.</p></li></ul></div><div class="admonitionblock caution"><table><tbody><tr><td class=icon><i class="fa icon-caution" title=Caution></i></td><td class=content><div class=paragraph><p>Este é apenas um script de exemplo que serve como prova de conceito. Ele não manipula todos os cenários possíveis e pode ser estendido ou alterado de qualquer forma, por exemplo, para iniciar ou interromper os serviços necessários.</p></div></td></tr></tbody></table></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Para este exemplo, foi utilizado um sistema de arquivos padrão UFS. Para reduzir o tempo necessário para a recuperação, é possível usar um sistema de arquivos UFS ou ZFS com journal ativado.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Informações mais detalhadas com exemplos adicionais podem ser encontradas em <a href=http://wiki.FreeBSD.org/HAST>http://wiki.FreeBSD.org/HAST</a>.</p></div></div></div><div class=sect3><h4 id=_solução_de_problemas_3>17.14.3. Solução de problemas<a class=anchor href=#_solução_de_problemas_3></a></h4><div class=paragraph><p>O HAST geralmente deve funcionar sem problemas. No entanto, como acontece com qualquer outro produto de software, pode haver momentos em que ele não funciona como deveria. As origens dos problemas podem ser diferentes, mas a regra geral é garantir que o horário esteja sincronizado entre os nós do cluster.</p></div><div class=paragraph><p>Quando estiver fazendo troubleshooting no HAST, o nível de depuração de <a href="https://man.freebsd.org/cgi/man.cgi?query=hastd&amp;sektion=8&amp;format=html">hastd(8)</a> deve ser aumentado iniciando <code>hastd</code> com <code>-d</code>. Esse argumento pode ser especificado várias vezes para aumentar ainda mais o nível de depuração. Considere também usar <code>-F</code>, que inicia o <code>hastd</code> em primeiro plano.</p></div><div class=sect4><h5 id=disks-hast-sb>17.14.3.1. Recuperando-se da Condição de Split-brain<a class=anchor href=#disks-hast-sb></a></h5><div class=paragraph><p><em>Split-brain</em> ocorre quando os nós do cluster não conseguem se comunicar entre si e ambos são configurados como primários. Esta é uma condição perigosa porque permite que ambos os nós façam alterações incompatíveis nos dados. Esse problema deve ser corrigido manualmente pelo administrador do sistema.</p></div><div class=paragraph><p>O administrador deve decidir qual nó tem alterações mais importantes ou executar a mesclagem manualmente. Então, deixe o HAST executar a sincronização completa do nó que possui os dados quebrados. Para fazer isso, emita esses comandos no nó que precisa ser ressincronizado:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># hastctl role init test</span>
<span class=c># hastctl create test</span>
<span class=c># hastctl role secondary test</span></code></pre></div></div></div></div></div></div></div><div class=sect1><h2 id=geom>Capítulo 18. GEOM: Framework de Transformação de Disco Modular<a class=anchor href=#geom></a></h2><div class=sectionbody><div class=sect2><h3 id=geom-synopsis>18.1. Sinopse<a class=anchor href=#geom-synopsis></a></h3><div class=paragraph><p>No FreeBSD, o framework GEOM permite acesso e controle à classes, tais como Master Boot Records e labels BSD, através do uso de provedores, ou dos dispositivos de disco em <span class=filename>/dev</span>. Ao suportar várias configurações de RAID via software, o GEOM fornece, de forma transparente, acesso ao sistema operacional e aos utilitários do sistema operacional.</p></div><div class=paragraph><p>Este capítulo aborda o uso de discos sob o framework do GEOM no FreeBSD. Isso inclui os principais utilitários de controle RAID os quais usam o framework para configuração. Este capítulo não é um guia definitivo para as configurações de RAID e somente as classificações de RAID suportadas pelo GEOM são discutidas.</p></div><div class=paragraph><p>Depois de ler este capítulo, você saberá:</p></div><div class=ulist><ul><li><p>Que tipo de suporte a RAID está disponível através do GEOM.</p></li><li><p>Como usar os utilitários da base para configurar, manter e manipular os vários níveis de RAID.</p></li><li><p>Como espelhar, distribuir, criptografar e conectar remotamente dispositivos de disco por meio do GEOM.</p></li><li><p>Como solucionar problemas de discos conectados ao framework do GEOM.</p></li></ul></div><div class=paragraph><p>Antes de ler este capítulo, você deve:</p></div><div class=ulist><ul><li><p>Entender como o FreeBSD trata os dispositivos de disco (<a href=./#disks>Armazenamento</a>).</p></li><li><p>Saber como configurar e instalar um novo kernel (<a href=./#kernelconfig>Configurando o kernel do FreeBSD</a>).</p></li></ul></div></div><div class=sect2><h3 id=geom-striping>18.2. RAID0 - Striping<a class=anchor href=#geom-striping></a></h3><div class=paragraph><p>O striping combina várias unidades de disco em um único volume. O striping pode ser realizado através do uso de hardwares controladores de RAID. O subsistema de disco GEOM fornece suporte de software para striping de disco, também conhecido como RAID0, sem a necessidade de um controlador RAID de disco.</p></div><div class=paragraph><p>No RAID0, os dados são divididos em blocos que são gravados em todas as unidades do array. Como pode ser visto na ilustração a seguir, em vez de esperar no sistema para gravar 256k em um disco, o RAID0 pode gravar 64k simultaneamente em cada um dos quatro discos do array, oferecendo um desempenho de I/O superior. Esse desempenho pode ser aprimorado ainda mais usando vários controladores de disco.</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/geom/striping.png alt="Disk Striping Illustration"></div></div><div class=paragraph><p>Cada disco em um stripe RAID0 deve ser do mesmo tamanho, pois as solicitações de I/O são intercaladas para ler ou gravar em vários discos em paralelo.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>O RAID0 <em>não</em> fornece qualquer redundância. Isso significa que, se um disco no array falhar, todos os dados nos discos serão perdidos. Se os dados forem importantes, implemente uma estratégia de backup que salva regularmente os backups em um sistema ou dispositivo remoto.</p></div></td></tr></tbody></table></div><div class=paragraph><p>O processo para criar um RAID0 por software, baseado no GEOM, em um sistema FreeBSD usando discos comuns é o seguinte. Uma vez que o stripe tiver sido criado, consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=gstripe&amp;sektion=8&amp;format=html">gstripe(8)</a> para obter maioress informações sobre como controlar uma stripe existente.</p></div><div class="exampleblock procedure"><div class=content><div class=paragraph><p><strong>Procedure: Criando um Stripe de Discos ATA Não Formatados</strong></p></div><div class="olist arabic"><ol class=arabic><li><p>Carregue o módulo <span class=filename>geom_stripe.ko</span>:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload geom_stripe</span></code></pre></div></div></li><li><p>Assegure-se de que exista um ponto de montagem adequado. Se esse volume se tornar uma partição root, use temporariamente outro ponto de montagem, como <span class=filename>/mnt</span>.</p></li><li><p>Determine os nomes dos dispositivos para os discos que serão striped e crie o novo dispositivo de stripe. Por exemplo, para distribuir dois discos ATA não utilizados e não particionados com nomes de dispositivos <span class=filename>/dev/ad2</span> e <span class=filename>/dev/ad3</span>:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gstripe label -v st0 /dev/ad2 /dev/ad3</span>
Metadata value stored on /dev/ad2.
Metadata value stored on /dev/ad3.
Done.</code></pre></div></div></li><li><p>Escreva um label padrão, também conhecido como tabela de partição, no novo volume e instale o código do bootstrap padrão:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># bsdlabel -wB /dev/stripe/st0</span></code></pre></div></div></li><li><p>Este processo deve criar dois outros dispositivos em <span class=filename>/dev/stripe</span> além de <span class=filename>st0</span>. Esses incluem o <span class=filename>st0a</span> e o <span class=filename>st0c</span>. Neste ponto, um sistema de arquivos UFS pode ser criado no <span class=filename>st0a</span> usando o <code>newfs</code>:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># newfs -U /dev/stripe/st0a</span></code></pre></div></div><div class=paragraph><p>Muitos números irão deslizar pela tela e, após alguns segundos, o processo será concluído. O volume foi criado e está pronto para ser montado.</p></div></li><li><p>Para montar manualmente o stripe de disco criado:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount /dev/stripe/st0a /mnt</span></code></pre></div></div></li><li><p>Para montar este sistema de arquivos distribuído automaticamente durante o processo de inicialização, coloque as informações do volume no arquivo <span class=filename>/etc/fstab</span>. Neste exemplo, um ponto de montagem permanente, chamado <span class=filename>stripe</span>, é criado:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mkdir /stripe</span>
<span class=c># echo &#34;/dev/stripe/st0a /stripe ufs rw 2 2&#34; \</span>
<span class=o>&gt;&gt;</span> /etc/fstab</code></pre></div></div></li><li><p>O módulo <span class=filename>geom_stripe.ko</span> também deve ser carregado automaticamente durante a inicialização do sistema, adicionando uma linha ao arquivo <span class=filename>/boot/loader.conf</span>:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># echo &#39;geom_stripe_load=&#34;YES&#34;&#39; &gt;&gt; /boot/loader.conf</span></code></pre></div></div></li></ol></div></div></div></div><div class=sect2><h3 id=geom-mirror>18.3. RAID1 - Espelhamento<a class=anchor href=#geom-mirror></a></h3><div class=paragraph><p>O RAID1, ou <em>espelhamento</em>, é a técnica de gravar os mesmos dados em mais de uma unidade de disco. Os espelhos são geralmente usados para proteger contra perda de dados devido a falhas na unidade. Cada unidade espelhada contém uma cópia idêntica dos dados. Quando uma unidade individual falha, o espelhamento continua a funcionar, fornecendo dados a partir das unidades que ainda estão funcionando. O computador continua funcionando e o administrador tem tempo para substituir a unidade com falha sem impactar o usuário.</p></div><div class=paragraph><p>Duas situações comuns são ilustradas nesses exemplos. O primeiro cria um espelhamento de dois novos discos e usa-o como um substituto para um único disco existente. O segundo exemplo cria um espelho em um único disco novo, copia os dados do disco antigo para ele e insere o disco antigo no espelho. Embora esse procedimento seja um pouco mais complicado, ele requer apenas um novo disco.</p></div><div class=paragraph><p>Tradicionalmente, os dois discos em um espelhamento são idênticos em modelo e capacidade, mas o <a href="https://man.freebsd.org/cgi/man.cgi?query=gmirror&amp;sektion=8&amp;format=html">gmirror(8)</a> não requer isso. Os espelhamentos criados com discos diferentes terão uma capacidade igual à da menor unidade no espelhamento. O espaço extra em discos maiores não será usado. Os discos inseridos posteriormente no espelhamento devem ter pelo menos a mesma capacidade que o menor disco já existente no espelhamento.</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Os procedimentos de espelhamento mostrados aqui são não-destrutivos, mas como em qualquer grande operação de disco, faça um backup completo primeiro.</p></div></td></tr></tbody></table></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Embora o <a href="https://man.freebsd.org/cgi/man.cgi?query=dump&amp;sektion=8&amp;format=html">dump(8)</a> seja usado nesses procedimentos para copiar sistemas de arquivos, ele não funciona em sistemas de arquivos com Soft Updates Journaling. Consulte o <a href="https://man.freebsd.org/cgi/man.cgi?query=tunefs&amp;sektion=8&amp;format=html">tunefs(8)</a> para obter informações sobre como detectar e desativar o Soft Updates Journaling.</p></div></td></tr></tbody></table></div><div class=sect3><h4 id=geom-mirror-metadata>18.3.1. Problemas de Metadados<a class=anchor href=#geom-mirror-metadata></a></h4><div class=paragraph><p>Muitos sistemas de disco armazenam metadados no final de cada disco. Metadados antigos devem ser apagados antes de reutilizar o disco em um espelhamento. A maioria dos problemas é causada por dois tipos particulares de metadados residuais: tabelas de partição GPT e metadados antigos de um espelhamento anterior.</p></div><div class=paragraph><p>Os metadados GPT podem ser apagados com <a href="https://man.freebsd.org/cgi/man.cgi?query=gpart&amp;sektion=8&amp;format=html">gpart(8)</a>. Este exemplo apaga as tabelas de partições primárias e de backup do GPT do disco <span class=filename>ada8</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gpart destroy -F ada8</span></code></pre></div></div><div class=paragraph><p>Um disco pode ser removido de um espelhamento ativo e os metadados apagados em uma etapa usando <a href="https://man.freebsd.org/cgi/man.cgi?query=gmirror&amp;sektion=8&amp;format=html">gmirror(8)</a>. Aqui, o disco de exemplo <span class=filename>ada8</span> é removido do espelhamento ativo <span class=filename>gm4</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gmirror remove gm4 ada8</span></code></pre></div></div><div class=paragraph><p>Se o espelhamento não estiver em execução, mas os metadados do espelhamento antigo ainda estiverem no disco, use o comando <code>gmirror clear</code> para removê-lo:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gmirror clear ada8</span></code></pre></div></div><div class=paragraph><p>O <a href="https://man.freebsd.org/cgi/man.cgi?query=gmirror&amp;sektion=8&amp;format=html">gmirror(8)</a> armazena um bloco de metadados no final do disco. Como os esquemas de partição GPT também armazenam metadados no final do disco, espelhar discos GPT inteiros com <a href="https://man.freebsd.org/cgi/man.cgi?query=gmirror&amp;sektion=8&amp;format=html">gmirror(8)</a> não é recomendado. O particionamento MBR é usado aqui porque armazena apenas uma tabela de partição no início do disco e não entra em conflito com os metadados espelhados.</p></div></div><div class=sect3><h4 id=geom-mirror-two-new-disks>18.3.2. Criando um Espelhamento com Dois Discos Novos<a class=anchor href=#geom-mirror-two-new-disks></a></h4><div class=paragraph><p>Neste exemplo, o FreeBSD já foi instalado em um único disco, <span class=filename>ada0</span>. Dois novos discos, <span class=filename>ada1</span> e <span class=filename>ada2</span>, foram conectados ao sistema. Um novo espelhamento será criado nesses dois discos e usado para substituir o antigo disco único.</p></div><div class=paragraph><p>O módulo do kernel <span class=filename>geom_mirror.ko</span> deve ser compilado no kernel ou carregado no boot ou em tempo de execução. Carregue manualmente o módulo do kernel agora:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gmirror load</span></code></pre></div></div><div class=paragraph><p>Crie o espelho com as duas novas unidades:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gmirror label -v gm0 /dev/ada1 /dev/ada2</span></code></pre></div></div><div class=paragraph><p>O <span class=filename>gm0</span> é um nome de dispositivo escolhido pelo usuário atribuído ao novo espelhamento. Depois que o espelhamento for iniciado, o nome desse dispositivo aparecerá em <span class=filename>/dev/mirror/</span>.</p></div><div class=paragraph><p>As tabelas de partição MBR e bsdlabel agora podem ser criadas no mirror com o <a href="https://man.freebsd.org/cgi/man.cgi?query=gpart&amp;sektion=8&amp;format=html">gpart(8)</a>. Este exemplo usa um layout de sistema de arquivos tradicional, com partições para <span class=filename>/</span>, swap, <span class=filename>/var</span>, <span class=filename>/tmp</span> e <span class=filename>/usr</span>. Um único <span class=filename>/</span> e uma partição swap também funcionarão.</p></div><div class=paragraph><p>As partições no espelho não precisam ser do mesmo tamanho que as do disco existente, mas devem ser grandes o suficiente para conter todos os dados já presentes no disco <span class=filename>ada0</span>.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gpart create -s MBR mirror/gm0</span>
<span class=c># gpart add -t freebsd -a 4k mirror/gm0</span>
<span class=c># gpart show mirror/gm0</span>
<span class=o>=&gt;</span>       63  156301423  mirror/gm0  MBR  <span class=o>(</span>74G<span class=o>)</span>
         63         63                    - free -  <span class=o>(</span>31k<span class=o>)</span>
        126  156301299                 1  freebsd  <span class=o>(</span>74G<span class=o>)</span>
  156301425         61                    - free -  <span class=o>(</span>30k<span class=o>)</span></code></pre></div></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gpart create -s BSD mirror/gm0s1</span>
<span class=c># gpart add -t freebsd-ufs  -a 4k -s 2g mirror/gm0s1</span>
<span class=c># gpart add -t freebsd-swap -a 4k -s 4g mirror/gm0s1</span>
<span class=c># gpart add -t freebsd-ufs  -a 4k -s 2g mirror/gm0s1</span>
<span class=c># gpart add -t freebsd-ufs  -a 4k -s 1g mirror/gm0s1</span>
<span class=c># gpart add -t freebsd-ufs  -a 4k       mirror/gm0s1</span>
<span class=c># gpart show mirror/gm0s1</span>
<span class=o>=&gt;</span>        0  156301299  mirror/gm0s1  BSD  <span class=o>(</span>74G<span class=o>)</span>
          0          2                      - free -  <span class=o>(</span>1.0k<span class=o>)</span>
          2    4194304                   1  freebsd-ufs  <span class=o>(</span>2.0G<span class=o>)</span>
    4194306    8388608                   2  freebsd-swap  <span class=o>(</span>4.0G<span class=o>)</span>
   12582914    4194304                   4  freebsd-ufs  <span class=o>(</span>2.0G<span class=o>)</span>
   16777218    2097152                   5  freebsd-ufs  <span class=o>(</span>1.0G<span class=o>)</span>
   18874370  137426928                   6  freebsd-ufs  <span class=o>(</span>65G<span class=o>)</span>
  156301298          1                      - free -  <span class=o>(</span>512B<span class=o>)</span></code></pre></div></div><div class=paragraph><p>Torne o espelhamento inicializável instalando o bootcode no MBR e no bsdlabel e definindo a slice ativa:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gpart bootcode -b /boot/mbr mirror/gm0</span>
<span class=c># gpart set -a active -i 1 mirror/gm0</span>
<span class=c># gpart bootcode -b /boot/boot mirror/gm0s1</span></code></pre></div></div><div class=paragraph><p>Formate os sistemas de arquivos no novo espelhamento, habilitando as atualizações simples.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># newfs -U /dev/mirror/gm0s1a</span>
<span class=c># newfs -U /dev/mirror/gm0s1d</span>
<span class=c># newfs -U /dev/mirror/gm0s1e</span>
<span class=c># newfs -U /dev/mirror/gm0s1f</span></code></pre></div></div><div class=paragraph><p>Os sistemas de arquivos do disco original <span class=filename>ada0</span> agora podem ser copiados para o espelho com o <a href="https://man.freebsd.org/cgi/man.cgi?query=dump&amp;sektion=8&amp;format=html">dump(8)</a> e o <a href="https://man.freebsd.org/cgi/man.cgi?query=restore&amp;sektion=8&amp;format=html">restore(8)</a>.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount /dev/mirror/gm0s1a /mnt</span>
<span class=c># dump -C16 -b64 -0aL -f - / | (cd /mnt &amp;&amp; restore -rf -)</span>
<span class=c># mount /dev/mirror/gm0s1d /mnt/var</span>
<span class=c># mount /dev/mirror/gm0s1e /mnt/tmp</span>
<span class=c># mount /dev/mirror/gm0s1f /mnt/usr</span>
<span class=c># dump -C16 -b64 -0aL -f - /var | (cd /mnt/var &amp;&amp; restore -rf -)</span>
<span class=c># dump -C16 -b64 -0aL -f - /tmp | (cd /mnt/tmp &amp;&amp; restore -rf -)</span>
<span class=c># dump -C16 -b64 -0aL -f - /usr | (cd /mnt/usr &amp;&amp; restore -rf -)</span></code></pre></div></div><div class=paragraph><p>Edite o arquivo <span class=filename>/mnt/etc/fstab</span> para apontar para os novos sistemas de arquivos espelhados:</p></div><div class="literalblock programlisting"><div class=content><pre># Device		Mountpoint	FStype	Options	Dump	Pass#
/dev/mirror/gm0s1a	/		ufs	rw	1	1
/dev/mirror/gm0s1b	none		swap	sw	0	0
/dev/mirror/gm0s1d	/var		ufs	rw	2	2
/dev/mirror/gm0s1e	/tmp		ufs	rw	2	2
/dev/mirror/gm0s1f	/usr		ufs	rw	2	2</pre></div></div><div class=paragraph><p>Se o módulo do kernel <span class=filename>geom_mirror.ko</span> não foi compilado no kernel, o <span class=filename>/mnt/boot/loader.conf</span> é editado para carregar o módulo na inicialização:</p></div><div class="literalblock programlisting"><div class=content><pre>geom_mirror_load=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Reinicialize o sistema para testar o novo espelhamento e verifique se todos os dados foram copiados. A BIOS verá o espelhamento como duas unidades individuais em vez de um espelhamento. Como as unidades são idênticas, não importa qual seja selecionado para inicializar.</p></div><div class=paragraph><p>Veja <a href=#gmirror-troubleshooting>Solução de problemas</a> se houver problemas ao inicializar. Desligar e desconectar o disco original <span class=filename>ada0</span> permitirá que ele seja mantido como um backup offline.</p></div><div class=paragraph><p>Em uso, o espelhamento se comportará exatamente como a unidade original.</p></div></div><div class=sect3><h4 id=geom-mirror-existing-drive>18.3.3. Criando um Espelhamento com Uma Unidade Existente<a class=anchor href=#geom-mirror-existing-drive></a></h4><div class=paragraph><p>Neste exemplo, o FreeBSD já foi instalado em um único disco, <span class=filename>ada0</span>. Um novo disco, <span class=filename>ada1</span>, foi conectado ao sistema. Um espelhamento de um disco será criado no novo disco, o sistema existente será copiado para ele e, em seguida, o disco antigo será inserido no espelho. Esse procedimento um pouco complexo é necessário porque o <code>gmirror</code> precisa colocar um bloco de metadados de 512 bytes no final de cada disco, e o <span class=filename>ada0</span> geralmente possui todo o seu espaço já alocado.</p></div><div class=paragraph><p>Carregue o módulo do kernel <span class=filename>geom_mirror.ko</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gmirror load</span></code></pre></div></div><div class=paragraph><p>Verifique o tamanho da mídia do disco original com <code>diskinfo</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># diskinfo -v ada0 | head -n3</span>
/dev/ada0
	512             <span class=c># sectorsize</span>
	1000204821504   <span class=c># mediasize in bytes (931G)</span></code></pre></div></div><div class=paragraph><p>Crie um espelhamento no novo disco. Para garantir que a capacidade do espelhamento não seja maior do que a unidade <span class=filename>ada0</span> original, <a href="https://man.freebsd.org/cgi/man.cgi?query=gnop&amp;sektion=8&amp;format=html">gnop(8)</a> é usado para criar uma unidade falsa exatamente do mesmo tamanho. Esta unidade não armazena dados, mas é usada apenas para limitar o tamanho do espelhamento. Quando o <a href="https://man.freebsd.org/cgi/man.cgi?query=gmirror&amp;sektion=8&amp;format=html">gmirror(8)</a> cria o espelhamento, ele irá restringir a capacidade ao tamanho de <span class=filename>gzero.nop</span>, mesmo se a nova unidade <span class=filename>ada1</span> tiver mais espaço. Note que o <em>1000204821504</em> na segunda linha é igual ao tamanho de mídia do <span class=filename>ada0</span> como mostrado pelo comando <code>diskinfo</code> acima.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># geom zero load</span>
<span class=c># gnop create -s 1000204821504 gzero</span>
<span class=c># gmirror label -v gm0 gzero.nop ada1</span>
<span class=c># gmirror forget gm0</span></code></pre></div></div><div class=paragraph><p>Como o <span class=filename>gzero.nop</span> não armazena nenhum dado, o espelhamento não o vê como conectado. É dito para o espelhamento "esquecer" os componentes desconectados, removendo referências para <span class=filename>gzero.nop</span>. O resultado é um dispositivo espelhado contendo apenas um único disco, <span class=filename>ada1</span>.</p></div><div class=paragraph><p>Depois de criar o <span class=filename>gm0</span>, veja a tabela de partições em <span class=filename>ada0</span>. Esta saída é de uma unidade de 1 TB. Se houver algum espaço não alocado no final da unidade, o conteúdo pode ser copiado diretamente de <span class=filename>ada0</span> para o novo espelho.</p></div><div class=paragraph><p>No entanto, se a saída mostrar que todo o espaço no disco está alocado, como na listagem a seguir, não há espaço disponível para os 512-bytes de metadados de espelhamento no final do disco.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gpart show ada0</span>
<span class=o>=&gt;</span>        63  1953525105        ada0  MBR  <span class=o>(</span>931G<span class=o>)</span>
          63  1953525105           1  freebsd  <span class=o>[</span>active]  <span class=o>(</span>931G<span class=o>)</span></code></pre></div></div><div class=paragraph><p>Neste caso, a tabela de partição deve ser editada para reduzir a capacidade de um setor em <span class=filename>mirror/gm0</span>. O procedimento será explicado mais tarde.</p></div><div class=paragraph><p>Em qualquer um dos casos, as tabelas de partição no disco principal devem ser primeiro copiadas usando <code>gpart backup</code> e <code>gpart restore</code>.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gpart backup ada0 &gt; table.ada0</span>
<span class=c># gpart backup ada0s1 &gt; table.ada0s1</span></code></pre></div></div><div class=paragraph><p>Esses comandos criam dois arquivos, <span class=filename>table.ada0</span> e <span class=filename>table.ada0s1</span>. Este exemplo é de uma unidade de 1 TB:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cat table.ada0</span>
MBR 4
1 freebsd         63 1953525105   <span class=o>[</span>active]</code></pre></div></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cat table.ada0s1</span>
BSD 8
1  freebsd-ufs          0    4194304
2 freebsd-swap    4194304   33554432
4  freebsd-ufs   37748736   50331648
5  freebsd-ufs   88080384   41943040
6  freebsd-ufs  130023424  838860800
7  freebsd-ufs  968884224  984640881</code></pre></div></div><div class=paragraph><p>Se nenhum espaço livre for exibido no final do disco, o tamanho da slice e da última partição deve ser reduzido por um setor. Edite os dois arquivos, reduzindo o tamanho da fatia e da última partição em um. Estes são os últimos números em cada listagem.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cat table.ada0</span>
MBR 4
1 freebsd         63 1953525104   <span class=o>[</span>active]</code></pre></div></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cat table.ada0s1</span>
BSD 8
1  freebsd-ufs          0    4194304
2 freebsd-swap    4194304   33554432
4  freebsd-ufs   37748736   50331648
5  freebsd-ufs   88080384   41943040
6  freebsd-ufs  130023424  838860800
7  freebsd-ufs  968884224  984640880</code></pre></div></div><div class=paragraph><p>Se pelo menos um setor não foi alocado no final do disco, esses dois arquivos podem ser usados sem modificação.</p></div><div class=paragraph><p>Agora restaure a tabela de partições em <span class=filename>mirror/gm0</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gpart restore mirror/gm0 &lt; table.ada0</span>
<span class=c># gpart restore mirror/gm0s1 &lt; table.ada0s1</span></code></pre></div></div><div class=paragraph><p>Verifique a tabela de partições com o comando <code>gpart show</code>. Este exemplo tem <span class=filename>gm0s1a</span> para <span class=filename>/</span>, <span class=filename>gm0s1d</span> para <span class=filename>/var</span>, <span class=filename>gm0s1e</span> para <span class=filename>/usr</span>, <span class=filename>gm0s1f</span> para <span class=filename>/data1</span> e <span class=filename>gm0s1g</span> para <span class=filename>/data2</span>.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gpart show mirror/gm0</span>
<span class=o>=&gt;</span>        63  1953525104  mirror/gm0  MBR  <span class=o>(</span>931G<span class=o>)</span>
          63  1953525042           1  freebsd  <span class=o>[</span>active]  <span class=o>(</span>931G<span class=o>)</span>
  1953525105          62              - free -  <span class=o>(</span>31k<span class=o>)</span>

<span class=c># gpart show mirror/gm0s1</span>
<span class=o>=&gt;</span>         0  1953525042  mirror/gm0s1  BSD  <span class=o>(</span>931G<span class=o>)</span>
           0     2097152             1  freebsd-ufs  <span class=o>(</span>1.0G<span class=o>)</span>
     2097152    16777216             2  freebsd-swap  <span class=o>(</span>8.0G<span class=o>)</span>
    18874368    41943040             4  freebsd-ufs  <span class=o>(</span>20G<span class=o>)</span>
    60817408    20971520             5  freebsd-ufs  <span class=o>(</span>10G<span class=o>)</span>
    81788928   629145600             6  freebsd-ufs  <span class=o>(</span>300G<span class=o>)</span>
   710934528  1242590514             7  freebsd-ufs  <span class=o>(</span>592G<span class=o>)</span>
  1953525042          63                - free -  <span class=o>(</span>31k<span class=o>)</span></code></pre></div></div><div class=paragraph><p>Tanto a fatia quanto a última partição devem ter pelo menos um bloco livre no final do disco.</p></div><div class=paragraph><p>Crie sistemas de arquivos nessas novas partições. O número de partições varia de acordo com o disco original, <span class=filename>ada0</span>.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># newfs -U /dev/mirror/gm0s1a</span>
<span class=c># newfs -U /dev/mirror/gm0s1d</span>
<span class=c># newfs -U /dev/mirror/gm0s1e</span>
<span class=c># newfs -U /dev/mirror/gm0s1f</span>
<span class=c># newfs -U /dev/mirror/gm0s1g</span></code></pre></div></div><div class=paragraph><p>Torne o espelhamento inicializável instalando o bootcode no MBR e no bsdlabel e definindo a slice ativa:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gpart bootcode -b /boot/mbr mirror/gm0</span>
<span class=c># gpart set -a active -i 1 mirror/gm0</span>
<span class=c># gpart bootcode -b /boot/boot mirror/gm0s1</span></code></pre></div></div><div class=paragraph><p>Ajuste o arquivo <span class=filename>/etc/fstab</span> para usar as novas partições no espelhamento.Primeiro faça o backup deste arquivo copiando ele para <span class=filename>/etc/fstab.orig</span>.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cp /etc/fstab /etc/fstab.orig</span></code></pre></div></div><div class=paragraph><p>Edite o arquivo <span class=filename>/etc/fstab</span>, substituindo <span class=filename>/dev/ada0</span> por <span class=filename>mirror/gm0</span>.</p></div><div class="literalblock programlisting"><div class=content><pre># Device		Mountpoint	FStype	Options	Dump	Pass#
/dev/mirror/gm0s1a	/		ufs	rw	1	1
/dev/mirror/gm0s1b	none		swap	sw	0	0
/dev/mirror/gm0s1d	/var		ufs	rw	2	2
/dev/mirror/gm0s1e	/usr		ufs	rw	2	2
/dev/mirror/gm0s1f	/data1		ufs	rw	2	2
/dev/mirror/gm0s1g	/data2		ufs	rw	2	2</pre></div></div><div class=paragraph><p>Se o módulo do kernel <span class=filename>geom_mirror.ko</span> não foi carregado no kernel, edite o arquivo <span class=filename>/boot/loader.conf</span> para carregá-lo no boot:</p></div><div class="literalblock programlisting"><div class=content><pre>geom_mirror_load=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Os sistemas de arquivos do disco original agora podem ser copiados para o espelhamento com o <a href="https://man.freebsd.org/cgi/man.cgi?query=dump&amp;sektion=8&amp;format=html">dump(8)</a> e o <a href="https://man.freebsd.org/cgi/man.cgi?query=restore&amp;sektion=8&amp;format=html">restore(8)</a>. Cada sistema de arquivos copiados com o <code>dump -L</code> irá primeiro criar um snapshot, o que pode levar algum tempo.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount /dev/mirror/gm0s1a /mnt</span>
<span class=c># dump -C16 -b64 -0aL -f - /    | (cd /mnt &amp;&amp; restore -rf -)</span>
<span class=c># mount /dev/mirror/gm0s1d /mnt/var</span>
<span class=c># mount /dev/mirror/gm0s1e /mnt/usr</span>
<span class=c># mount /dev/mirror/gm0s1f /mnt/data1</span>
<span class=c># mount /dev/mirror/gm0s1g /mnt/data2</span>
<span class=c># dump -C16 -b64 -0aL -f - /usr | (cd /mnt/usr &amp;&amp; restore -rf -)</span>
<span class=c># dump -C16 -b64 -0aL -f - /var | (cd /mnt/var &amp;&amp; restore -rf -)</span>
<span class=c># dump -C16 -b64 -0aL -f - /data1 | (cd /mnt/data1 &amp;&amp; restore -rf -)</span>
<span class=c># dump -C16 -b64 -0aL -f - /data2 | (cd /mnt/data2 &amp;&amp; restore -rf -)</span></code></pre></div></div><div class=paragraph><p>Reinicie o sistema, inicializando a partir do <span class=filename>ada1</span>. Se tudo estiver funcionando, o sistema irá inicializar a partir de <span class=filename>mirror/gm0</span>, que agora contém os mesmos dados que o <span class=filename>ada0</span> tinha anteriormente. Veja <a href=#gmirror-troubleshooting>Solução de problemas</a> se houver problemas ao inicializar.</p></div><div class=paragraph><p>Neste ponto, o espelhamento ainda consiste apenas no único disco <span class=filename>ada1</span>.</p></div><div class=paragraph><p>Após inicializar a partir de <span class=filename>mirror/gm0</span> com sucesso, a etapa final é inserir <span class=filename>ada0</span> no espelhamento.</p></div><div class="admonitionblock important"><table><tbody><tr><td class=icon><i class="fa icon-important" title=Important></i></td><td class=content><div class=paragraph><p>Quando o <span class=filename>ada0</span> for inserido no espelhamento, seu conteúdo anterior será substituído pelos dados do espelhamento. Certifique-se de que <span class=filename>mirror/gm0</span> tenha o mesmo conteúdo do <span class=filename>ada0</span> antes de adicionar o <span class=filename>ada0</span> ao espelhamento. Se o conteúdo anteriormente copiado pelo <a href="https://man.freebsd.org/cgi/man.cgi?query=dump&amp;sektion=8&amp;format=html">dump(8)</a> e <a href="https://man.freebsd.org/cgi/man.cgi?query=restore&amp;sektion=8&amp;format=html">restore(8)</a> não forem idênticos ao que estava em <span class=filename>ada0</span>, reverta o arquivo <span class=filename>/etc/fstab</span> para montar os sistemas de arquivos em <span class=filename>ada0</span>, e reinicie todo o procedimento novamente.</p></div></td></tr></tbody></table></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gmirror insert gm0 ada0</span>
GEOM_MIRROR: Device gm0: rebuilding provider ada0</code></pre></div></div><div class=paragraph><p>A sincronização entre os dois discos será iniciada imediatamente. Use <code>gmirror status</code> para visualizar o progresso.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gmirror status</span>
      Name    Status  Components
mirror/gm0  DEGRADED  ada1 <span class=o>(</span>ACTIVE<span class=o>)</span>
                      ada0 <span class=o>(</span>SYNCHRONIZING, 64%<span class=o>)</span></code></pre></div></div><div class=paragraph><p>Depois de um tempo, a sincronização será concluída.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>GEOM_MIRROR: Device gm0: rebuilding provider ada0 finished.
<span class=c># gmirror status</span>
      Name    Status  Components
mirror/gm0  COMPLETE  ada1 <span class=o>(</span>ACTIVE<span class=o>)</span>
                      ada0 <span class=o>(</span>ACTIVE<span class=o>)</span></code></pre></div></div><div class=paragraph><p>O <span class=filename>mirror/gm0</span> agora consiste de dois discos <span class=filename>ada0</span> e <span class=filename>ada1</span>, e o conteúdo é automaticamente sincronizado entre eles. Em uso, o <span class=filename>mirror/gm0</span> irá se comportar como a única unidade original.</p></div></div><div class=sect3><h4 id=gmirror-troubleshooting>18.3.4. Solução de problemas<a class=anchor href=#gmirror-troubleshooting></a></h4><div class=paragraph><p>Se o sistema não inicializar mais, as configurações da BIOS podem ter que ser alteradas para inicializar a partir de uma das novas unidades espelhadas. Qualquer uma das unidades espelhadas pode ser usada para inicializar, pois elas contêm dados idênticos.</p></div><div class=paragraph><p>Se a inicialização parar com esta mensagem, algo está errado com o dispositivo espelhado:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Mounting from ufs:/dev/mirror/gm0s1a failed with error 19.

Loader variables:
  vfs.root.mountfrom<span class=o>=</span>ufs:/dev/mirror/gm0s1a
  vfs.root.mountfrom.options<span class=o>=</span>rw

Manual root filesystem specification:
  &lt;fstype&gt;:&lt;device&gt; <span class=o>[</span>options]
      Mount &lt;device&gt; using filesystem &lt;fstype&gt;
      and with the specified <span class=o>(</span>optional<span class=o>)</span> option list.

    eg. ufs:/dev/da0s1a
        zfs:tank
        cd9660:/dev/acd0 ro
          <span class=o>(</span>which is equivalent to: mount <span class=nt>-t</span> cd9660 <span class=nt>-o</span> ro /dev/acd0 /<span class=o>)</span>

  ?               List valid disk boot devices
  <span class=nb>.</span>               Yield 1 second <span class=o>(</span><span class=k>for </span>background tasks<span class=o>)</span>
  &lt;empty line&gt;    Abort manual input

mountroot&gt;</code></pre></div></div><div class=paragraph><p>Esquecer de carregar o módulo <span class=filename>geom_mirror.ko</span> no arquivo <span class=filename>/boot/loader.conf</span> pode causar este problema. Para consertá-lo, inicialize a partir de uma mídia de instalação do FreeBSD e escolha <code>Shell</code> no primeiro prompt. Em seguida, carregue o módulo de espelhamento e monte o dispositivo espelhado:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gmirror load</span>
<span class=c># mount /dev/mirror/gm0s1a /mnt</span></code></pre></div></div><div class=paragraph><p>Edite o arquivo <span class=filename>/mnt/boot/loader.conf</span>, adicionando uma linha para carregar o módulo de espelhamento:</p></div><div class="literalblock programlisting"><div class=content><pre>geom_mirror_load=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Salve o arquivo e reinicie.</p></div><div class=paragraph><p>Outros problemas que causam o <code>error 19</code> requerem mais esforço para serem corrigidos. Embora o sistema deva inicializar a partir de <span class=filename>ada0</span>, outro prompt para selecionar um shell aparecerá se o arquivo <span class=filename>/etc/fstab</span> estiver incorreto. Digite <code>ufs:/dev/ada0s1a</code> no prompt do carregador de boot e pressione <kbd>Enter</kbd>. Desfaça as edições no arquivo <span class=filename>/etc/fstab</span> e monte os sistemas de arquivos a partir do disco original (<span class=filename>ada0</span>) em vez do espelhado. Reinicialize o sistema e tente o procedimento novamente.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Enter full pathname of shell or RETURN <span class=k>for</span> /bin/sh:
<span class=c># cp /etc/fstab.orig /etc/fstab</span>
<span class=c># reboot</span></code></pre></div></div></div><div class=sect3><h4 id=_recuperando_de_uma_falha_de_disco>18.3.5. Recuperando de Uma Falha de Disco<a class=anchor href=#_recuperando_de_uma_falha_de_disco></a></h4><div class=paragraph><p>O benefício do espelhamento de disco é que um disco individual pode falhar sem fazer com que o espelho perca qualquer dado. No exemplo acima, se <span class=filename>ada0</span> falhar, o espelho continuará funcionando, fornecendo dados a partir do disco que continua operacional, <span class=filename>ada1</span>.</p></div><div class=paragraph><p>Para substituir a unidade com falha, desligue o sistema e substitua fisicamente a unidade com falha por uma nova unidade com capacidade igual ou maior. Os fabricantes usam valores um tanto arbitrários ao classificar drives em gigabytes, e a única maneira de realmente ter certeza é comparar a contagem total de setores mostrados por <code>diskinfo -v</code>. Uma unidade com maior capacidade que o espelho funcionará, embora o espaço extra na nova unidade não seja usado.</p></div><div class=paragraph><p>Depois que o computador for ligado novamente, o espelho será executado em um modo "degradado" com apenas uma unidade. O espelho é avisado para esquecer as unidades que não estão conectadas no momento:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gmirror forget gm0</span></code></pre></div></div><div class=paragraph><p>Quaisquer metadados antigos devem ser apagados do disco de substituição usando as instruções em <a href=#geom-mirror-metadata>Problemas de Metadados</a>. Em seguida, o disco de substituição, <span class=filename>ada4</span> para este exemplo, é inserido no espelho:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gmirror insert gm0 /dev/ada4</span></code></pre></div></div><div class=paragraph><p>A ressincronização começa quando a nova unidade é inserida no espelho. Esse processo de copiar dados espelhados para uma nova unidade pode demorar um pouco. O desempenho do espelho será bastante reduzido durante a cópia, portanto, a inserção de novos discos é deve ser executada quando houver pouca demanda no computador.</p></div><div class=paragraph><p>O progresso pode ser monitorado com o comando <code>gmirror status</code>, que mostra as unidades que estão sendo sincronizadas e a porcentagem de conclusão. Durante a ressincronização, o status será <code>DEGRADED</code>, mudando para <code>COMPLETE</code> quando o processo for concluído.</p></div></div></div><div class=sect2><h3 id=geom-raid3>18.4. RAID3 - Distribuição em Nível de Byte com Paridade Dedicada<a class=anchor href=#geom-raid3></a></h3><div class=paragraph><p>O RAID3 é um método usado para combinar várias unidades de disco em um único volume com um disco de paridade dedicado. Em um sistema RAID3, os dados são divididos em vários bytes que são escritos em todas as unidades da matriz, exceto por um disco que atua como um disco de paridade dedicado. Isso significa que as leituras de disco de uma implementação de RAID3 acessam todos os discos na matriz. O desempenho pode ser aprimorado usando vários controladores de disco. O array RAID3 fornece uma tolerância a falhas de 1 unidade, enquanto fornece uma capacidade de 1 - 1/n vezes a capacidade total de todas as unidades no array, onde n é o número de unidades de disco rígido no array. Essa configuração é adequada principalmente para armazenar dados de tamanhos maiores, como arquivos multimídia.</p></div><div class=paragraph><p>Pelo menos 3 discos rígidos físicos são necessários para criar um array RAID3. Cada disco deve ter o mesmo tamanho, pois as solicitações de I/O são intercaladas para ler ou gravar em vários discos em paralelo. Além disso, devido à natureza do RAID3, o número de unidades deve ser igual a 3, 5, 9, 17 e assim por diante, ou 2^n + 1.</p></div><div class=paragraph><p>Esta seção demonstra como criar um RAID3 via software em um sistema FreeBSD.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Embora seja teoricamente possível inicializar a partir de um array RAID3 no FreeBSD, essa configuração é incomum e não é recomendada.</p></div></td></tr></tbody></table></div><div class=sect3><h4 id=_criando_uma_matriz_raid3_dedicada>18.4.1. Criando uma Matriz RAID3 Dedicada<a class=anchor href=#_criando_uma_matriz_raid3_dedicada></a></h4><div class=paragraph><p>No FreeBSD, o suporte para RAID3 é implementado pela classe GEOM<a href="https://man.freebsd.org/cgi/man.cgi?query=graid3&amp;sektion=8&amp;format=html">graid3(8)</a>. Criar um array dedicado de RAID3 no FreeBSD requer os seguintes passos.</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Primeiro, carregue o módulo do kernel <span class=filename>geom_raid3.ko</span> emitindo um dos seguintes comandos:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># graid3 load</span></code></pre></div></div><div class=paragraph><p>ou:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload geom_raid3</span></code></pre></div></div></li><li><p>Assegure-se de que exista um ponto de montagem adequado. Este comando cria um novo diretório para usar como ponto de montagem:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mkdir /multimedia</span></code></pre></div></div></li><li><p>Determine os nomes dos dispositivos para os discos que serão adicionados à matriz e crie o novo dispositivo RAID3. O dispositivo final listado atuará como o disco de paridade dedicado. Este exemplo usa três unidades ATA não-particionadas: <span class=filename>ada1</span> e <span class=filename>ada2</span> para dados e <span class=filename>ada3</span> para paridade.</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># graid3 label -v gr0 /dev/ada1 /dev/ada2 /dev/ada3</span>
Metadata value stored on /dev/ada1.
Metadata value stored on /dev/ada2.
Metadata value stored on /dev/ada3.
Done.</code></pre></div></div></li><li><p>Particione o dispositivo <span class=filename>gr0</span> recém-criado e coloque um sistema de arquivos UFS:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gpart create -s GPT /dev/raid3/gr0</span>
<span class=c># gpart add -t freebsd-ufs /dev/raid3/gr0</span>
<span class=c># newfs -j /dev/raid3/gr0p1</span></code></pre></div></div><div class=paragraph><p>Muitos números irão ser exibios na tela e, após algum tempo, o processo será concluído. O volume foi criado e está pronto para ser montado:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount /dev/raid3/gr0p1 /multimedia/</span></code></pre></div></div><div class=paragraph><p>A matriz RAID3 está agora pronta para uso.</p></div></li></ol></div></div></div><div class=paragraph><p>Uma configuração adicional é necessária para manter essa configuração nas reinicializações do sistema.</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>O módulo <span class=filename>geom_raid3.ko</span> deve ser carregado antes que o array possa ser montado. Para carregar automaticamente o módulo do kernel durante a inicialização do sistema, adicione a seguinte linha ao arquivo <span class=filename>/boot/loader.conf</span>:</p><div class="literalblock programlisting"><div class=content><pre>geom_raid3_load=&#34;YES&#34;</pre></div></div></li><li><p>As seguintes informações de volume devem ser adicionadas ao arquivo <span class=filename>/etc/fstab</span> para montar automaticamente o sistema de arquivos do array durante o processo de inicialização do sistema:</p><div class="literalblock programlisting"><div class=content><pre>/dev/raid3/gr0p1	/multimedia	ufs	rw	2	2</pre></div></div></li></ol></div></div></div></div></div><div class=sect2><h3 id=geom-graid>18.5. Dispositivos RAID por Software<a class=anchor href=#geom-graid></a></h3><div class=paragraph><p>Algumas placas-mãe e placas de expansão adicionam um hardware simples, geralmente apenas uma ROM, que permite que o computador inicialize a partir de um array RAID. Após a inicialização, o acesso ao array RAID é feito pelo software em execução no processador principal do computador. Este "RAID via software assistido por hardware" fornece arrays RAID que não dependem de nenhum sistema operacional em particular, e que são funcionais antes mesmo de um sistema operacional ser carregado.</p></div><div class=paragraph><p>Vários níveis de RAID são suportados, dependendo do hardware em uso. Veja <a href="https://man.freebsd.org/cgi/man.cgi?query=graid&amp;sektion=8&amp;format=html">graid(8)</a> para uma lista completa.</p></div><div class=paragraph><p>O <a href="https://man.freebsd.org/cgi/man.cgi?query=graid&amp;sektion=8&amp;format=html">graid(8)</a> requer o módulo do kernel <span class=filename>geom_raid.ko</span>, que está incluído no kernel <span class=filename>GENERIC</span> a partir do FreeBSD 9.1. Se necessário, ele pode ser carregado manualmente com o comando <code>graid load</code>.</p></div><div class=sect3><h4 id=geom-graid-creating>18.5.1. Criando um Array<a class=anchor href=#geom-graid-creating></a></h4><div class=paragraph><p>Os dispositivos de RAID via software geralmente têm um menu que pode ser acessado pressionando teclas especiais quando o computador está inicializando. O menu pode ser usado para criar e excluir arrays RAID. O <a href="https://man.freebsd.org/cgi/man.cgi?query=graid&amp;sektion=8&amp;format=html">graid(8)</a> também pode criar arrays diretamente a partir da linha de comando.</p></div><div class=paragraph><p>O <code>graid label</code> é usado para criar um novo array. A placa-mãe usada neste exemplo tem um chipset RAID da Intel, portanto, o formato de metadados da Intel é especificado. A nova matriz recebe um rótulo de <span class=filename>gm0</span>, é um espelhamento (RAID1) e usa as unidades <span class=filename>ada0</span> e <span class=filename>ada1</span>.</p></div><div class="admonitionblock caution"><table><tbody><tr><td class=icon><i class="fa icon-caution" title=Caution></i></td><td class=content><div class=paragraph><p>Algum espaço nas unidades será sobrescrito quando elas forem transformadas em um novo array. Faça o backup dos dados existentes primeiro!</p></div></td></tr></tbody></table></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># graid label Intel gm0 RAID1 ada0 ada1</span>
GEOM_RAID: Intel-a29ea104: Array Intel-a29ea104 created.
GEOM_RAID: Intel-a29ea104: Disk ada0 state changed from NONE to ACTIVE.
GEOM_RAID: Intel-a29ea104: Subdisk gm0:0-ada0 state changed from NONE to ACTIVE.
GEOM_RAID: Intel-a29ea104: Disk ada1 state changed from NONE to ACTIVE.
GEOM_RAID: Intel-a29ea104: Subdisk gm0:1-ada1 state changed from NONE to ACTIVE.
GEOM_RAID: Intel-a29ea104: Array started.
GEOM_RAID: Intel-a29ea104: Volume gm0 state changed from STARTING to OPTIMAL.
Intel-a29ea104 created
GEOM_RAID: Intel-a29ea104: Provider raid/r0 <span class=k>for </span>volume gm0 created.</code></pre></div></div><div class=paragraph><p>Uma verificação de status mostra que o novo espelhamento está pronto para uso:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># graid status</span>
   Name   Status  Components
raid/r0  OPTIMAL  ada0 <span class=o>(</span>ACTIVE <span class=o>(</span>ACTIVE<span class=o>))</span>
                  ada1 <span class=o>(</span>ACTIVE <span class=o>(</span>ACTIVE<span class=o>))</span></code></pre></div></div><div class=paragraph><p>O dispositivo de array aparece em <span class=filename>/dev/raid/</span>. O primeiro array é chamado de <span class=filename>r0</span>. Arrays adicionais, se presentes, serão <span class=filename>r1</span>, <span class=filename>r2</span> e assim por diante.</p></div><div class=paragraph><p>O menu da BIOS em alguns desses dispositivos pode criar arrays com caracteres especiais em seus nomes. Para evitar problemas com esses caracteres especiais, os arrays recebem nomes numerados simples como <span class=filename>r0</span>. Para mostrar os rótulos reais, como <span class=filename>gm0</span> no exemplo acima, use o <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl kern.geom.raid.name_format=1</span></code></pre></div></div></div><div class=sect3><h4 id=geom-graid-volumes>18.5.2. Múltiplos Volumes<a class=anchor href=#geom-graid-volumes></a></h4><div class=paragraph><p>Alguns dispositivos de RAID via software suportam mais de um <em>volume</em> em um array. Os volumes funcionam como partições, permitindo que o espaço nas unidades físicas seja dividido e usado de diferentes maneiras. Por exemplo, os dispositivos RAID via software Intel suportam dois volumes. Este exemplo cria um espelho de 40 G para armazenar com segurança o sistema operacional, seguido por um volume de 20 G RAID0 (stripe) para armazenamento temporário rápido:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># graid label -S 40G Intel gm0 RAID1 ada0 ada1</span>
<span class=c># graid add -S 20G gm0 RAID0</span></code></pre></div></div><div class=paragraph><p>Os volumes aparecem como entradas adicionais <span class=filename>rX</span> em <span class=filename>/dev/raid/</span>. Um array com dois volumes mostrará <span class=filename>r0</span> e <span class=filename>r1</span>.</p></div><div class=paragraph><p>Veja <a href="https://man.freebsd.org/cgi/man.cgi?query=graid&amp;sektion=8&amp;format=html">graid(8)</a> para o número de volumes suportados por diferentes dispositivos RAID via software.</p></div></div><div class=sect3><h4 id=geom-graid-converting>18.5.3. Convertendo uma Única Unidade em um Espelho<a class=anchor href=#geom-graid-converting></a></h4><div class=paragraph><p>Sob certas condições específicas, é possível converter uma única unidade existente em um array <a href="https://man.freebsd.org/cgi/man.cgi?query=graid&amp;sektion=8&amp;format=html">graid(8)</a> sem reformatar. Para evitar a perda de dados durante a conversão, a unidade existente deve atender a esses requisitos mínimos:</p></div><div class=ulist><ul><li><p>A unidade deve ser particionada com o esquema de particionamento MBR. O GPT ou outros esquemas de particionamento com metadados no final da unidade serão sobrescritos e corrompidos pelos metadados do <a href="https://man.freebsd.org/cgi/man.cgi?query=graid&amp;sektion=8&amp;format=html">graid(8)</a>.</p></li><li><p>Deve haver espaço não particionado e não utilizado o suficiente no final da unidade para conter os metadados do <a href="https://man.freebsd.org/cgi/man.cgi?query=graid&amp;sektion=8&amp;format=html">graid(8)</a>. Esses metadados variam em tamanho, mas o maior ocupa 64 M, então pelo menos este espaço livre é recomendado.</p></li></ul></div><div class=paragraph><p>Se a unidade atender a esses requisitos, comece fazendo um backup completo. Em seguida, crie um espelhamento de unidade única com essa unidade:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># graid label Intel gm0 RAID1 ada0 NONE</span></code></pre></div></div><div class=paragraph><p>Os metadados do <a href="https://man.freebsd.org/cgi/man.cgi?query=graid&amp;sektion=8&amp;format=html">graid(8)</a> foram gravados no final da unidade no espaço não utilizado. Uma segunda unidade pode agora ser inserida no espelhamento:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># graid insert raid/r0 ada1</span></code></pre></div></div><div class=paragraph><p>Os dados da unidade original começarão imediatamente a ser copiados para a segunda unidade. O espelhamento operará em status degradado até que a cópia seja concluída.</p></div></div><div class=sect3><h4 id=geom-graid-inserting>18.5.4. Inserindo Novos Discos no Array<a class=anchor href=#geom-graid-inserting></a></h4><div class=paragraph><p>As unidades podem ser inseridas em uma matriz como substitutos de unidades que falharam ou estão faltando. Se não houver unidades com falha ou ausentes, a nova unidade se tornará uma reserva. Por exemplo, inserir uma nova unidade em um espelhamento de duas unidades de trabalho resulta em um espelhamento de duas unidades com uma unidade sobressalente, não em um espelhamento de três unidades.</p></div><div class=paragraph><p>No array de espelho do exemplo, os dados começam a ser copiados imediatamente para a unidade recém-inserida. Qualquer informação existente na nova unidade será substituída.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># graid insert raid/r0 ada1</span>
GEOM_RAID: Intel-a29ea104: Disk ada1 state changed from NONE to ACTIVE.
GEOM_RAID: Intel-a29ea104: Subdisk gm0:1-ada1 state changed from NONE to NEW.
GEOM_RAID: Intel-a29ea104: Subdisk gm0:1-ada1 state changed from NEW to REBUILD.
GEOM_RAID: Intel-a29ea104: Subdisk gm0:1-ada1 rebuild start at 0.</code></pre></div></div></div><div class=sect3><h4 id=geom-graid-removing>18.5.5. Removendo Discos do Array<a class=anchor href=#geom-graid-removing></a></h4><div class=paragraph><p>Discos individuais podem ser permanentemente removidos de um array e seus metadados apagados:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># graid remove raid/r0 ada1</span>
GEOM_RAID: Intel-a29ea104: Disk ada1 state changed from ACTIVE to OFFLINE.
GEOM_RAID: Intel-a29ea104: Subdisk gm0:1-[unknown] state changed from ACTIVE to NONE.
GEOM_RAID: Intel-a29ea104: Volume gm0 state changed from OPTIMAL to DEGRADED.</code></pre></div></div></div><div class=sect3><h4 id=geom-graid-stopping>18.5.6. Parando o Array<a class=anchor href=#geom-graid-stopping></a></h4><div class=paragraph><p>Um array pode ser interrompido sem remover os metadados das unidades. O array será reiniciado quando o sistema for inicializado.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># graid stop raid/r0</span></code></pre></div></div></div><div class=sect3><h4 id=geom-graid-status>18.5.7. Verificando o Status do Array<a class=anchor href=#geom-graid-status></a></h4><div class=paragraph><p>O status do array pode ser verificado a qualquer momento. Depois que um disco foi adicionado ao espelho no exemplo acima, os dados estarão sendo copiados do disco original para o novo disco:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># graid status</span>
   Name    Status  Components
raid/r0  DEGRADED  ada0 <span class=o>(</span>ACTIVE <span class=o>(</span>ACTIVE<span class=o>))</span>
                   ada1 <span class=o>(</span>ACTIVE <span class=o>(</span>REBUILD 28%<span class=o>))</span></code></pre></div></div><div class=paragraph><p>Alguns tipos de arrays, como <code>RAID0</code> ou <code>CONCAT</code>, podem não ser mostrados no relatório de status se os discos falharem. Para ver esses arrays com falhas parciais, adicione <code>-ga</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># graid status -ga</span>
          Name  Status  Components
Intel-e2d07d9a  BROKEN  ada6 <span class=o>(</span>ACTIVE <span class=o>(</span>ACTIVE<span class=o>))</span></code></pre></div></div></div><div class=sect3><h4 id=geom-graid-deleting>18.5.8. Excluindo Arrays<a class=anchor href=#geom-graid-deleting></a></h4><div class=paragraph><p>Arrays são destruídos, excluindo todos os volumes deles. Quando o último volume presente é excluído, o array é interrompido e os metadados são removidos dos discos:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># graid delete raid/r0</span></code></pre></div></div></div><div class=sect3><h4 id=geom-graid-unexpected>18.5.9. Excluindo Arrays Inesperados<a class=anchor href=#geom-graid-unexpected></a></h4><div class=paragraph><p>Os discos podem conter metadados <a href="https://man.freebsd.org/cgi/man.cgi?query=graid&amp;sektion=8&amp;format=html">graid(8)</a> inesperados, originados no seu uso anterior ou em testes do fabricante. O <a href="https://man.freebsd.org/cgi/man.cgi?query=graid&amp;sektion=8&amp;format=html">graid(8)</a> detectará estes discos e criará um array, interferindo no acesso ao disco individual. Para remover os metadados indesejados:</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Inicialize o sistema. No menu de inicialização, selecione <code>2</code> para o prompt do utilitário de boot. Entre:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>OK <span class=nb>set </span>kern.geom.raid.enable<span class=o>=</span>0
OK boot</code></pre></div></div><div class=paragraph><p>O sistema inicializará com o <a href="https://man.freebsd.org/cgi/man.cgi?query=graid&amp;sektion=8&amp;format=html">graid(8)</a> desativado.</p></div></li><li><p>Fazer backup de todos os dados na unidade afetada.</p></li><li><p>Como solução alternativa, a detecção de arrays <a href="https://man.freebsd.org/cgi/man.cgi?query=graid&amp;sektion=8&amp;format=html">graid(8)</a> pode ser desativada incluindo se a variável</p><div class="literalblock programlisting"><div class=content><pre>kern.geom.raid.enable=0</pre></div></div><div class=paragraph><p>no arquivo <span class=filename>/boot/loader.conf</span>.</p></div><div class=paragraph><p>Para remover permanentemente os metadados <a href="https://man.freebsd.org/cgi/man.cgi?query=graid&amp;sektion=8&amp;format=html">graid(8)</a> do disco afetado, inicialize uma instalação do FreeBSD usando um CD-ROM ou um memory stick e selecione a opção <code>Shell</code>. Use o comando <code>status</code> para encontrar o nome do array, normalmente <code>raid/r0</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># graid status</span>
   Name   Status  Components
raid/r0  OPTIMAL  ada0 <span class=o>(</span>ACTIVE <span class=o>(</span>ACTIVE<span class=o>))</span>
                  ada1 <span class=o>(</span>ACTIVE <span class=o>(</span>ACTIVE<span class=o>))</span></code></pre></div></div><div class=paragraph><p>Exclua o volume pelo nome:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># graid delete raid/r0</span></code></pre></div></div><div class=paragraph><p>Se houver mais de um volume exibido, repita o processo para cada volume. Após o último array ter sido excluído, o volume será destruído.</p></div><div class=paragraph><p>Reinicialize e verifique os dados, restaurando a partir do backup, se necessário. Depois que os metadados forem removidos, a entrada <code>kern.geom.raid.enable=0</code> no arquivo <span class=filename>/boot/loader.conf</span> também pode ser removida.</p></div></li></ol></div></div></div></div></div><div class=sect2><h3 id=geom-ggate>18.6. GEOM Network Gate<a class=anchor href=#geom-ggate></a></h3><div class=paragraph><p>O GEOM fornece um mecanismo simples para fornecer acesso remoto a dispositivos como discos, CDs e sistemas de arquivos através do uso do daemon GEOM Network Gate, ggated. O sistema com o dispositivo executa o daemon do servidor que manipula solicitações feitas por clientes usando o ggatec. Os dispositivos não devem conter dados confidenciais, pois a conexão entre o cliente e o servidor não é criptografada.</p></div><div class=paragraph><p>Semelhante ao NFS, que é discutido em <a href=./#network-nfs>Network File System (NFS)</a>, o ggated é configurado usando um arquivo de exportação. Este arquivo especifica quais sistemas têm permissão para acessar os recursos exportados e em qual nível de acesso eles são oferecidos. Por exemplo, para fornecer ao cliente <code>192.168.1.5</code> acesso de leitura e gravação à quarta slice do primeiro disco SCSI, crie o arquivo <span class=filename>/etc/gg.exports</span> com esta linha:</p></div><div class="literalblock programlisting"><div class=content><pre>192.168.1.5 RW /dev/da0s4d</pre></div></div><div class=paragraph><p>Antes de exportar o dispositivo, verifique se ele não está montado no momento. Em seguida, inicie o ggated:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ggated</span></code></pre></div></div><div class=paragraph><p>Várias opções estão disponíveis para especificar uma porta de escuta alternativa ou para alterar o local padrão do arquivo de exportação. Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=ggated&amp;sektion=8&amp;format=html">ggated(8)</a> para maiores detalhes.</p></div><div class=paragraph><p>Para acessar o dispositivo exportado na máquina cliente, primeiro use o comando <code>ggatec</code> para especificar o endereço IP do servidor e o nome do dispositivo exportado. Se bem sucedido, este comando irá exibir um nome de dispositivo <code>ggate</code> para montar. Monte esse nome de dispositivo especificado em um ponto de montagem livre. Este exemplo conecta-se à partição <span class=filename>/dev/da0s4d</span> no <code>192.168.1.1</code>, em seguida, monta o <span class=filename>/dev/ggate0</span> em <span class=filename>/mnt</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ggatec create -o rw 192.168.1.1 /dev/da0s4d</span>
ggate0
<span class=c># mount /dev/ggate0 /mnt</span></code></pre></div></div><div class=paragraph><p>O dispositivo no servidor pode agora ser acessado por meio do <span class=filename>/mnt</span> no cliente. Para maiores detalhes sobre o <code>ggatec</code> e alguns exemplos de uso, consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=ggatec&amp;sektion=8&amp;format=html">ggatec(8)</a>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>A montagem falhará se o dispositivo estiver atualmente montado no servidor ou em qualquer outro cliente na rede. Se for necessário acesso simultâneo aos recursos de rede, use o NFS.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Quando o dispositivo não for mais necessário, desmonte-o com o <code>umount</code> para que o recurso fique disponível para outros clientes.</p></div></div><div class=sect2><h3 id=geom-glabel>18.7. Rotulando Dispositivos de Disco<a class=anchor href=#geom-glabel></a></h3><div class=paragraph><p>Durante a inicialização do sistema, o kernel do FreeBSD cria nós de dispositivos conforme os dispositivos são encontrados. Esse método de detectar dispositivos gera alguns problemas. Por exemplo, e se um novo dispositivo de disco for adicionado via USB? É provável que um dispositivo flash receba o nome do dispositivo <span class=filename>da0</span> e o <span class=filename>da0</span> original alterado para <span class=filename>da1</span>. Isso causará problemas ao montar sistemas de arquivos se eles estiverem listados no <span class=filename>/etc/fstab</span>, o que também pode impedir que o sistema seja inicializado.</p></div><div class=paragraph><p>Uma solução é encadear os dispositivos SCSI para que um novo dispositivo adicionado à placa SCSI receba números de dispositivo não utilizados. Mas e os dispositivos USB que podem substituir o disco principal SCSI? Isso acontece porque os dispositivos USB geralmente são examinados antes da placa SCSI. Uma solução é inserir esses dispositivos apenas após o sistema ter sido inicializado. Outro método é usar apenas uma única unidade ATA e nunca listar os dispositivos SCSI no arquivo <span class=filename>/etc/fstab</span>.</p></div><div class=paragraph><p>Uma solução melhor é usar o <code>glabel</code> para rotular os dispositivos de disco e usar os rótulos no arquivo <span class=filename>/etc/fstab</span>. Como o <code>glabel</code> armazena o rótulo no último setor de um determinado provedor, o rótulo permanecerá persistente nas reinicializações. Ao usar esse rótulo como um dispositivo, o sistema de arquivos pode sempre ser montado independentemente do nó do dispositivo pelo qual ele é acessado.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>O <code>glabel</code> pode criar rótulos transitórios e permanentes. Somente rótulos permanentes são consistentes nas reinicializações. Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=glabel&amp;sektion=8&amp;format=html">glabel(8)</a> para obter mais informações sobre as diferenças entre os rótulos.</p></div></td></tr></tbody></table></div><div class=sect3><h4 id=_tipos_de_rótulos_e_exemplos>18.7.1. Tipos de Rótulos e Exemplos<a class=anchor href=#_tipos_de_rótulos_e_exemplos></a></h4><div class=paragraph><p>Os rótulos permanentes podem ser um rótulo genérico ou de um sistema de arquivos. Rótulos de sistema de arquivos permanentes podem ser criados com <a href="https://man.freebsd.org/cgi/man.cgi?query=tunefs&amp;sektion=8&amp;format=html">tunefs(8)</a> ou <a href="https://man.freebsd.org/cgi/man.cgi?query=newfs&amp;sektion=8&amp;format=html">newfs(8)</a>. Esses tipos de rótulos são criados em um subdiretório <span class=filename>/dev</span> e serão nomeados de acordo com o tipo de sistema de arquivos. Por exemplo, os rótulos do sistema de arquivos UFS2 serão criados em <span class=filename>/dev/ufs</span>. Rótulos permanentes genéricos podem ser criados com o <code>glabel label</code>. Estes não são específicos do sistema de arquivos e serão criados em <span class=filename>/dev/label</span>.</p></div><div class=paragraph><p>Os rótulos temporários são destruídos na próxima reinicialização. Esses rótulos são criados em <span class=filename>/dev/label</span> e são adequados para experimentação. Um rótulo temporário pode ser criado usando <code>glabel create</code>.</p></div><div class=paragraph><p>Para criar um rótulo permanente para um sistema de arquivos UFS2 sem destruir nenhum dado, emita o seguinte comando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># tunefs -L home /dev/da3</span></code></pre></div></div><div class=paragraph><p>Um rótulo deve agora existir em <span class=filename>/dev/ufs</span> que pode ser adicionado ao arquivo <span class=filename>/etc/fstab</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>/dev/ufs/home		/home            ufs     rw              2      2</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>O sistema de arquivos não deve ser montado durante a tentativa de executar o <code>tunefs</code>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Agora o sistema de arquivos pode ser montado:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount /home</span></code></pre></div></div><div class=paragraph><p>A partir deste ponto, desde que o módulo do kernel <span class=filename>geom_label.ko</span> seja carregado na inicialização com o <span class=filename>/boot/loader.conf</span> ou com a opção do kernel <code>GEOM_LABEL</code> estando presente, o nó do dispositivo pode mudar sem qualquer efeito negativo no sistema.</p></div><div class=paragraph><p>Os sistemas de arquivos também podem ser criados com um rótulo padrão usando a flag <code>-L</code> com o comando <code>newfs</code>. Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=newfs&amp;sektion=8&amp;format=html">newfs(8)</a> para obter maiores informações.</p></div><div class=paragraph><p>O seguinte comando pode ser usado para destruir o rótulo:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># glabel destroy home</span></code></pre></div></div><div class=paragraph><p>O exemplo a seguir mostra como rotular as partições de um disco de inicialização.</p></div><div class=exampleblock><div class=title>Exemplo 42. Rotulando Partições no Disco de Inicialização</div><div class=content><div class=paragraph><p>Ao marcar permanentemente as partições no disco de inicialização, o sistema deve poder continuar a inicializar normalmente, mesmo se o disco for movido para outro controlador ou transferido para um sistema diferente. Para este exemplo, presume-se que um único disco ATA é usado, que é atualmente reconhecido pelo sistema como <span class=filename>ad0</span>. Também é assumido que o esquema de partição padrão do FreeBSD é usado, com <span class=filename>/</span>, <span class=filename>/var</span>, <span class=filename>/usr</span> e <span class=filename>/tmp</span>, bem como uma partição de swap.</p></div><div class=paragraph><p>Reinicialize o sistema e, no prompt do <a href="https://man.freebsd.org/cgi/man.cgi?query=loader&amp;sektion=8&amp;format=html">loader(8)</a>, pressione <kbd>4</kbd> para inicializar no modo de usuário único. Em seguida, insira os seguintes comandos:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># glabel label rootfs /dev/ad0s1a</span>
GEOM_LABEL: Label <span class=k>for </span>provider /dev/ad0s1a is label/rootfs
<span class=c># glabel label var /dev/ad0s1d</span>
GEOM_LABEL: Label <span class=k>for </span>provider /dev/ad0s1d is label/var
<span class=c># glabel label usr /dev/ad0s1f</span>
GEOM_LABEL: Label <span class=k>for </span>provider /dev/ad0s1f is label/usr
<span class=c># glabel label tmp /dev/ad0s1e</span>
GEOM_LABEL: Label <span class=k>for </span>provider /dev/ad0s1e is label/tmp
<span class=c># glabel label swap /dev/ad0s1b</span>
GEOM_LABEL: Label <span class=k>for </span>provider /dev/ad0s1b is label/swap
<span class=c># exit</span></code></pre></div></div><div class=paragraph><p>O sistema continuará com a inicialização multiusuário. Depois que a inicialização terminar, edite o arquivo <span class=filename>/etc/fstab</span> e substitua os nomes de dispositivos convencionais por seus respectivos rótulos. No final o <span class=filename>/etc/fstab</span> ficará assim:</p></div><div class="literalblock programlisting"><div class=content><pre># Device                Mountpoint      FStype  Options         Dump    Pass#
/dev/label/swap         none            swap    sw              0       0
/dev/label/rootfs       /               ufs     rw              1       1
/dev/label/tmp          /tmp            ufs     rw              2       2
/dev/label/usr          /usr            ufs     rw              2       2
/dev/label/var          /var            ufs     rw              2       2</pre></div></div><div class=paragraph><p>O sistema agora pode ser reinicializado. Se tudo correr bem, ele aparecerá normalmente e o comando <code>mount</code> mostrará:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount</span>
/dev/label/rootfs on / <span class=o>(</span>ufs, <span class=nb>local</span><span class=o>)</span>
devfs on /dev <span class=o>(</span>devfs, <span class=nb>local</span><span class=o>)</span>
/dev/label/tmp on /tmp <span class=o>(</span>ufs, <span class=nb>local</span>, soft-updates<span class=o>)</span>
/dev/label/usr on /usr <span class=o>(</span>ufs, <span class=nb>local</span>, soft-updates<span class=o>)</span>
/dev/label/var on /var <span class=o>(</span>ufs, <span class=nb>local</span>, soft-updates<span class=o>)</span></code></pre></div></div></div></div><div class=paragraph><p>A classe <a href="https://man.freebsd.org/cgi/man.cgi?query=glabel&amp;sektion=8&amp;format=html">glabel(8)</a> suporta um tipo de rótulo para sistemas de arquivos UFS, com base no ID do sistema de arquivos exclusivo <code>ufsid</code>. Esses rótulos podem ser encontrados em <span class=filename>/dev/ufsid</span> e são criados automaticamente durante a inicialização do sistema. É possível usar rótulos <code>ufsid</code> para montar partições usando o <span class=filename>/etc/fstab</span>. Use o <code>glabel status</code> para receber uma lista de sistemas de arquivos e seus rótulos <code>ufsid</code> correspondentes:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% glabel status
                  Name  Status  Components
ufsid/486b6fc38d330916     N/A  ad4s1d
ufsid/486b6fc16926168e     N/A  ad4s1f</code></pre></div></div><div class=paragraph><p>No exemplo acima, <span class=filename>ad4s1d</span> representa <span class=filename>/var</span>, enquanto <span class=filename>ad4s1f</span> representa <span class=filename>/usr</span>. Usando os valores <code>ufsid</code> mostrados, essas partições podem agora ser montadas com as seguintes entradas em <span class=filename>/etc/fstab</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>/dev/ufsid/486b6fc38d330916        /var        ufs        rw        2      2
/dev/ufsid/486b6fc16926168e        /usr        ufs        rw        2      2</pre></div></div><div class=paragraph><p>Quaisquer partições com rótulos <code>ufsid</code> podem ser montadas dessa forma, eliminando a necessidade de criar manualmente rótulos permanentes, enquanto ainda desfruta dos benefícios da montagem independente do nome do dispositivo.</p></div></div></div><div class=sect2><h3 id=geom-gjournal>18.8. Journaling UFS através do GEOM<a class=anchor href=#geom-gjournal></a></h3><div class=paragraph><p>Suporte para journaling em sistemas de arquivos UFS está disponível no FreeBSD. A implementação é fornecida através do subsistema GEOM e é configurada usando o comando <code>gjournal</code>. Ao contrário de outras implementações de journaling de sistemas de arquivos, o método <code>gjournal</code> é baseado em blocos e não é implementado como parte do sistema de arquivos. É uma extensão do GEOM.</p></div><div class=paragraph><p>O jornaling armazena um log de transações do sistema de arquivos, como alterações que compõem uma operação de gravação em disco completa, antes que os metadados e as gravações de arquivos sejam confirmados no disco. Esse log de transação pode ser repetido posteriormente para refazer as transações do sistema de arquivos, evitando inconsistências no sistema de arquivos.</p></div><div class=paragraph><p>Esse método fornece outro mecanismo para proteger contra perda de dados e inconsistências do sistema de arquivos. Ao contrário das Soft Updates, que rastreiam e impõem atualizações de metadados e snapshots, que criam uma imagem do sistema de arquivos, um log é armazenado no espaço em disco especificamente para essa tarefa. Para melhor desempenho, o journal pode ser armazenado em outro disco. Nessa configuração, o provedor do journal ou o dispositivo de armazenamento deve ser listado após o dispositivo para ativar o journaling.</p></div><div class=paragraph><p>O kernel <span class=filename>GENERIC</span> fornece suporte para o <code>gjournal</code>. Para carregar automaticamente o módulo do kernel <span class=filename>geom_journal.ko</span> no momento da inicialização, adicione a seguinte linha ao arquivo <span class=filename>/boot/loader.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>geom_journal_load=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Se um kernel personalizado for usado, certifique-se de que a linha a seguir esteja no arquivo de configuração do kernel:</p></div><div class="literalblock programlisting"><div class=content><pre>options	GEOM_JOURNAL</pre></div></div><div class=paragraph><p>Depois que o módulo é carregado, um journal pode ser criado em um novo sistema de arquivos usando as etapas a seguir. Neste exemplo, <span class=filename>da4</span> é um novo disco SCSI:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gjournal load</span>
<span class=c># gjournal label /dev/da4</span></code></pre></div></div><div class=paragraph><p>Isto irá carregar o módulo e criar um nó de dispositivo <span class=filename>/dev/da4.journal</span> em <span class=filename>/dev/da4</span>.</p></div><div class=paragraph><p>Um sistema de arquivos UFS pode agora ser criado no dispositivo journaled e depois montado em um ponto de montagem existente:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># newfs -O 2 -J /dev/da4.journal</span>
<span class=c># mount /dev/da4.journal /mnt</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>No caso de várias slices, será criado um journal para cada slice individual. Por exemplo, se <span class=filename>ad4s1</span> e <span class=filename>ad4s2</span> forem slices, o <code>gjournal</code> criará <span class=filename>ad4s1.journal</span> e <span class=filename>ad4s2.journal</span>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>O journaling também pode ser ativado nos sistemas de arquivos atuais usando o <code>tunefs</code>. No entanto, <em>sempre</em> faça um backup antes de tentar alterar um sistema de arquivos existente. Na maioria dos casos, o <code>gjournal</code> falhará se não for possível criar o registro de log, mas isso não protege contra a perda de dados incorrida como resultado do uso indevido do <code>tunefs</code>. Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=gjournal&amp;sektion=8&amp;format=html">gjournal(8)</a> e <a href="https://man.freebsd.org/cgi/man.cgi?query=tunefs&amp;sektion=8&amp;format=html">tunefs(8)</a> para maiores informações sobre esses comandos.</p></div><div class=paragraph><p>É possível fazer o journaling do disco de inicialização de um sistema FreeBSD. Consulte o artigo <a href=https://docs.freebsd.org/pt-br/articles/gjournal-desktop/>Implementando o journaling do UFS em um PC de mesa</a> para obter instruções detalhadas.</p></div></div></div></div><div class=sect1><h2 id=zfs>Capítulo 19. O sistema de arquivos Z (ZFS)<a class=anchor href=#zfs></a></h2><div class=sectionbody><div class=paragraph><p>O <em>Sistema de Arquivos Z</em>, ou ZFS, é um sistema de arquivos avançado projetado para superar muitos dos principais problemas encontrados em projetos anteriores.</p></div><div class=paragraph><p>Originalmente desenvolvido pela Sun™, o desenvolvimento contínuo do ZFS em código aberto foi movido para o <a href=http://open-zfs.org>Projeto OpenZFS</a>.</p></div><div class=paragraph><p>O ZFS tem três metas principais de design:</p></div><div class=ulist><ul><li><p>Integridade de dados: Todos os dados incluem um <a href=#zfs-term-checksum>checksum</a> dos dados. Quando os dados são gravados, o checksum é calculado e gravado junto com eles. Quando esses dados são lidos posteriormente, o checksum é calculado novamente. Se os checksum’s não corresponderem, um erro de dados foi detectado. O ZFS tentará corrigir automaticamente os erros quando houver redundância de dados disponível.</p></li><li><p>Armazenamento em pool: os dispositivos de armazenamento físico são adicionados em um pool e o espaço de armazenamento é alocado a partir desse pool compartilhado. O espaço está disponível para todos os sistemas de arquivos e pode ser aumentado pela adição de novos dispositivos de armazenamento ao pool.</p></li><li><p>Performance: vários mecanismos de cache fornecem uma maior performance. O <a href=#zfs-term-arc>ARC</a> é um avançado cache de leitura baseado em memória. Um segundo nível de cache de leitura baseado em disco pode ser adicionado com o <a href=#zfs-term-l2arc>L2ARC</a>, e o cache síncrono de escrita baseado em disco está disponível com <a href=#zfs-term-zil>ZIL</a>.</p></li></ul></div><div class=paragraph><p>Uma lista completa de features e terminologias é mostrada em <a href=#zfs-term>Recursos e terminologia do ZFS</a>.</p></div><div class=sect2><h3 id=zfs-differences>19.1. O que torna o ZFS diferente<a class=anchor href=#zfs-differences></a></h3><div class=paragraph><p>O ZFS é significativamente diferente de qualquer outro sistema de arquivos existente, porque ele é mais do que apenas um simples sistema de arquivos. A combinação das funções tradicionalmente separadas de gerenciamento de volume e de sistema de arquivos, fornece ao ZFS vantagens exclusivas. O sistema de arquivos agora conhece a estrutura abaixo dos discos. Os sistemas de arquivos tradicionais só podem ser criados em um único disco por vez. Se houvesse dois discos, dois sistemas de arquivos separados teriam que ser criados. Em uma configuração de hardware tradicional RAID, esse problema foi contornado apresentando ao sistema operacional um único disco lógico composto pelo espaço fornecido por vários discos físicos, sobre o qual o sistema operacional colocava um sistema de arquivos. Mesmo no caso de soluções de software RAID como as fornecidas pelo GEOM, o sistema de arquivos UFS, que está no topo da transformação RAID, acreditava que estava lidando com um único dispositivo físico. A combinação feita pelo ZFS do gerenciador de volumes e do sistema de arquivos resolve isso e permite a criação de vários sistemas de arquivos, todos compartilhando um pool de armazenamento disponível. Uma das maiores vantagens do reconhecimento do layout físico dos discos pelo ZFS é que os sistemas de arquivos existentes podem ser expandidos automaticamente quando novos discos são adicionados ao pool. Esse novo espaço é disponibilizado para todos os sistemas de arquivos. O ZFS também possui várias propriedades diferentes que podem ser aplicadas a cada sistema de arquivos, oferecendo muitas vantagens para a criação de vários sistemas de arquivos e datasets diferentes, em vez de um único sistema de arquivos monolítico.</p></div></div><div class=sect2><h3 id=zfs-quickstart>19.2. Guia de Início Rápido<a class=anchor href=#zfs-quickstart></a></h3><div class=paragraph><p>Existe um mecanismo de inicialização que permite ao FreeBSD montar pools do ZFS durante a inicialização do sistema. Para habilitá-lo, adicione esta linha ao <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>zfs_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Então inicie o serviço:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service zfs start</span></code></pre></div></div><div class=paragraph><p>Os exemplos nesta seção assumem três discos SCSI com os seguintes nomes de dispositivo <span class=filename>da0</span>, <span class=filename>da1</span> e <span class=filename>da2</span>. Usuários de hardware do tipo SATA devem usar nomes de dispositivo <span class=filename>ada</span>.</p></div><div class=sect3><h4 id=zfs-quickstart-single-disk-pool>19.2.1. Pool de Disco Único<a class=anchor href=#zfs-quickstart-single-disk-pool></a></h4><div class=paragraph><p>Para criar um pool simples e não-redundante usando um único disco:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zpool create example /dev/da0</span></code></pre></div></div><div class=paragraph><p>Para visualizar o novo pool, verifique a saída do comando <code>df</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># df</span>
Filesystem  1K-blocks    Used    Avail Capacity  Mounted on
/dev/ad0s1a   2026030  235230  1628718    13%    /
devfs               1       1        0   100%    /dev
/dev/ad0s1d  54098308 1032846 48737598     2%    /usr
example      17547136       0 17547136     0%    /example</code></pre></div></div><div class=paragraph><p>Esta saída mostra que o pool <code>example</code> foi criado e montado e agora está acessível como um sistema de arquivos. Arquivos podem ser criados nele e os usuários podem navegar nele:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /example</span>
<span class=c># ls</span>
<span class=c># touch testfile</span>
<span class=c># ls -al</span>
total 4
drwxr-xr-x   2 root  wheel    3 Aug 29 23:15 <span class=nb>.</span>
drwxr-xr-x  21 root  wheel  512 Aug 29 23:12 ..
<span class=nt>-rw-r--r--</span>   1 root  wheel    0 Aug 29 23:15 testfile</code></pre></div></div><div class=paragraph><p>No entanto, esse pool não está aproveitando nenhuma feature do ZFS. Para criar um dataset neste pool com a compressão ativada:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs create example/compressed</span>
<span class=c># zfs set compression=gzip example/compressed</span></code></pre></div></div><div class=paragraph><p>O dataset <code>example/compressed</code> é agora um sistema de arquivos ZFS compactado. Tente copiar alguns arquivos grandes para <span class=filename>/example/compressed</span>.</p></div><div class=paragraph><p>A compactação pode ser desativada com:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs set compression=off example/compressed</span></code></pre></div></div><div class=paragraph><p>Para desmontar um sistema de arquivos, use <code>zfs umount</code> e, em seguida, verifique com <code>df</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs umount example/compressed</span>
<span class=c># df</span>
Filesystem  1K-blocks    Used    Avail Capacity  Mounted on
/dev/ad0s1a   2026030  235232  1628716    13%    /
devfs               1       1        0   100%    /dev
/dev/ad0s1d  54098308 1032864 48737580     2%    /usr
example      17547008       0 17547008     0%    /example</code></pre></div></div><div class=paragraph><p>Para remontar o sistema de arquivos para torná-lo acessível novamente, use <code>zfs mount</code> e verifique com o <code>df</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs mount example/compressed</span>
<span class=c># df</span>
Filesystem         1K-blocks    Used    Avail Capacity  Mounted on
/dev/ad0s1a          2026030  235234  1628714    13%    /
devfs                      1       1        0   100%    /dev
/dev/ad0s1d         54098308 1032864 48737580     2%    /usr
example             17547008       0 17547008     0%    /example
example/compressed  17547008       0 17547008     0%    /example/compressed</code></pre></div></div><div class=paragraph><p>O pool e o sistema de arquivos também podem ser observados visualizando a saída do comando <code>mount</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount</span>
/dev/ad0s1a on / <span class=o>(</span>ufs, <span class=nb>local</span><span class=o>)</span>
devfs on /dev <span class=o>(</span>devfs, <span class=nb>local</span><span class=o>)</span>
/dev/ad0s1d on /usr <span class=o>(</span>ufs, <span class=nb>local</span>, soft-updates<span class=o>)</span>
example on /example <span class=o>(</span>zfs, <span class=nb>local</span><span class=o>)</span>
example/compressed on /example/compressed <span class=o>(</span>zfs, <span class=nb>local</span><span class=o>)</span></code></pre></div></div><div class=paragraph><p>Após a criação, os datasets do ZFS podem ser usados como qualquer sistema de arquivos. No entanto, muitos outros recursos estão disponíveis, e podem ser definidos por conjunto de dados. No exemplo abaixo, um novo sistema de arquivos chamado <code>data</code> é criado. Arquivos importantes serão armazenados nele, portanto, ele é configurado para manter duas cópias de cada bloco de dados:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs create example/data</span>
<span class=c># zfs set copies=2 example/data</span></code></pre></div></div><div class=paragraph><p>Agora é possível ver o sistema de arquivos <code>data</code> e o espaço utilizado através do comando <code>df</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># df</span>
Filesystem         1K-blocks    Used    Avail Capacity  Mounted on
/dev/ad0s1a          2026030  235234  1628714    13%    /
devfs                      1       1        0   100%    /dev
/dev/ad0s1d         54098308 1032864 48737580     2%    /usr
example             17547008       0 17547008     0%    /example
example/compressed  17547008       0 17547008     0%    /example/compressed
example/data        17547008       0 17547008     0%    /example/data</code></pre></div></div><div class=paragraph><p>Observe que cada sistema de arquivos no pool tem a mesma quantidade de espaço disponível. Esta é a razão para usar o <code>df</code> nestes exemplos, para mostrar que os sistemas de arquivos usam apenas a quantidade de espaço de que precisam e todos utilizam o mesmo pool. O ZFS elimina conceitos como volumes e partições e permite que vários sistemas de arquivos ocupem o mesmo pool.</p></div><div class=paragraph><p>Para destruir os sistemas de arquivos e, em seguida, destruir o pool, se ele não for mais necessário:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs destroy example/compressed</span>
<span class=c># zfs destroy example/data</span>
<span class=c># zpool destroy example</span></code></pre></div></div></div><div class=sect3><h4 id=zfs-quickstart-raid-z>19.2.2. RAID-Z<a class=anchor href=#zfs-quickstart-raid-z></a></h4><div class=paragraph><p>Discos falham. Um método para evitar perda de dados devido a falhas no disco é implementar RAID. O ZFS suporta esse recurso em seu design de pool. Os pools RAID-Z exigem três ou mais discos, mas fornecem mais espaço utilizável do que os pools espelhados.</p></div><div class=paragraph><p>Este exemplo cria um pool RAID-Z, especificando os discos a serem adicionados ao pool:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zpool create storage raidz da0 da1 da2</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>A Sun™ recomenda que o número de dispositivos usados em uma configuração RAID-Z seja entre três e nove. Para ambientes que exigem um único conjunto de 10 discos ou mais, considere dividi-lo em grupos menores de RAID-Z. Se apenas dois discos estiverem disponíveis e a redundância for um requisito, considere usar o ZFS mirror. Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=zpool&amp;sektion=8&amp;format=html">zpool(8)</a> para obter maiores detalhes.</p></div></td></tr></tbody></table></div><div class=paragraph><p>O exemplo anterior criou o zpool <code>storage</code>. Este exemplo cria um novo sistema de arquivos chamado <code>home</code> neste pool:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs create storage/home</span></code></pre></div></div><div class=paragraph><p>A compressão e a criação de cópias extras de diretórios e arquivos podem ser ativadas:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs set copies=2 storage/home</span>
<span class=c># zfs set compression=gzip storage/home</span></code></pre></div></div><div class=paragraph><p>Para tornar este o novo diretório home para usuários, copie os dados de usuários para este diretório e crie os links simbólicos apropriados:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cp -rp /home/* /storage/home</span>
<span class=c># rm -rf /home /usr/home</span>
<span class=c># ln -s /storage/home /home</span>
<span class=c># ln -s /storage/home /usr/home</span></code></pre></div></div><div class=paragraph><p>Os dados dos usuários agora são armazenados no recém-criado diretório <span class=filename>/storage/home</span>. Teste adicionando um novo usuário e efetuando login como este usuário.</p></div><div class=paragraph><p>Tente criar um snapshot do sistema de arquivos que possa ser revertido posteriormente:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs snapshot storage/home@08-30-08</span></code></pre></div></div><div class=paragraph><p>Os snapshots só podem ser realizados de um sistema de arquivos completo, não de um único diretório ou arquivo.</p></div><div class=paragraph><p>O caractere <code>@</code> é um delimitador entre o nome do sistema de arquivos ou o nome do volume. Se um diretório importante tiver sido excluído acidentalmente, o backup do sistema de arquivos poderá ser feito e, em seguida, revertido para um snapshot anterior, quando o diretório ainda existia:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs rollback storage/home@08-30-08</span></code></pre></div></div><div class=paragraph><p>Para listar todos os snapshots disponíveis, execute <code>ls</code> no diretório <span class=filename>.zfs/snapshot</span> no sistema de arquivos. Por exemplo, para ver o snapshot obtido anteriormente:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ls /storage/home/.zfs/snapshot</span></code></pre></div></div><div class=paragraph><p>É possível escrever um script para criar snapshots frequentes dos dados do usuário. No entanto, com o tempo, os snapshots podem consumir muito espaço em disco. O snapshot anterior pode ser removido usando o comando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs destroy storage/home@08-30-08</span></code></pre></div></div><div class=paragraph><p>Após o teste, <span class=filename>/storage/home</span> pode ser o verdadeiro <span class=filename>/home</span> usando este comando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs set mountpoint=/home storage/home</span></code></pre></div></div><div class=paragraph><p>Execute o <code>df</code> e o <code>mount</code> para confirmar que o sistema agora trata o sistema de arquivos como o real <span class=filename>/home</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount</span>
/dev/ad0s1a on / <span class=o>(</span>ufs, <span class=nb>local</span><span class=o>)</span>
devfs on /dev <span class=o>(</span>devfs, <span class=nb>local</span><span class=o>)</span>
/dev/ad0s1d on /usr <span class=o>(</span>ufs, <span class=nb>local</span>, soft-updates<span class=o>)</span>
storage on /storage <span class=o>(</span>zfs, <span class=nb>local</span><span class=o>)</span>
storage/home on /home <span class=o>(</span>zfs, <span class=nb>local</span><span class=o>)</span>
<span class=c># df</span>
Filesystem   1K-blocks    Used    Avail Capacity  Mounted on
/dev/ad0s1a    2026030  235240  1628708    13%    /
devfs                1       1        0   100%    /dev
/dev/ad0s1d   54098308 1032826 48737618     2%    /usr
storage       26320512       0 26320512     0%    /storage
storage/home  26320512       0 26320512     0%    /home</code></pre></div></div><div class=paragraph><p>Isso conclui a configuração do RAID-Z. Atualizações de status diárias sobre os sistemas de arquivos criados podem ser geradas como parte das execuções noturnas do<a href="https://man.freebsd.org/cgi/man.cgi?query=periodic&amp;sektion=8&amp;format=html">periodic(8)</a>. Adicione esta linha ao <span class=filename>/etc/periodic.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>daily_status_zfs_enable=&#34;YES&#34;</pre></div></div></div><div class=sect3><h4 id=zfs-quickstart-recovering-raid-z>19.2.3. Recuperando o RAID-Z<a class=anchor href=#zfs-quickstart-recovering-raid-z></a></h4><div class=paragraph><p>Todo software RAID tem um método de monitorar seu <code>status</code>. O status dos dispositivos RAID-Z pode ser visualizado com este comando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zpool status -x</span></code></pre></div></div><div class=paragraph><p>Se todos os pools estiverem <a href=#zfs-term-online>Online</a> e tudo estiver normal, a mensagem mostrará:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>all pools are healthy</code></pre></div></div><div class=paragraph><p>Se houver um problema, talvez um disco que esteja no estado <a href=#zfs-term-offline>Offline</a>, o status do pool será semelhante a:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>  pool: storage
 state: DEGRADED
status: One or more devices has been taken offline by the administrator.
	Sufficient replicas exist <span class=k>for </span>the pool to <span class=k>continue </span>functioning <span class=k>in </span>a
	degraded state.
action: Online the device using <span class=s1>&#39;zpool online&#39;</span> or replace the device with
	<span class=s1>&#39;zpool replace&#39;</span><span class=nb>.</span>
 scrub: none requested
config:

	NAME        STATE     READ WRITE CKSUM
	storage     DEGRADED     0     0     0
	  raidz1    DEGRADED     0     0     0
	    da0     ONLINE       0     0     0
	    da1     OFFLINE      0     0     0
	    da2     ONLINE       0     0     0

errors: No known data errors</code></pre></div></div><div class=paragraph><p>Isso indica que o dispositivo foi colocado off-line anteriormente pelo administrador com este comando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zpool offline storage da1</span></code></pre></div></div><div class=paragraph><p>Agora o sistema pode ser desligado para substituir o <span class=filename>da1</span>. Quando o sistema estiver novamente online, o disco com falha poderá ser substituído no pool:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zpool replace storage da1</span></code></pre></div></div><div class=paragraph><p>Agora, o status pode ser verificado novamente, desta vez sem <code>-x</code>, para que todos os pools sejam mostrados:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zpool status storage</span>
 pool: storage
 state: ONLINE
 scrub: resilver completed with 0 errors on Sat Aug 30 19:44:11 2008
config:

	NAME        STATE     READ WRITE CKSUM
	storage     ONLINE       0     0     0
	  raidz1    ONLINE       0     0     0
	    da0     ONLINE       0     0     0
	    da1     ONLINE       0     0     0
	    da2     ONLINE       0     0     0

errors: No known data errors</code></pre></div></div><div class=paragraph><p>Neste exemplo, tudo está normal.</p></div></div><div class=sect3><h4 id=zfs-quickstart-data-verification>19.2.4. Verificação de dados<a class=anchor href=#zfs-quickstart-data-verification></a></h4><div class=paragraph><p>O ZFS utiliza checksums para verificar a integridade dos dados armazenados. Estes são ativados automaticamente na criação dos sistemas de arquivos.</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Os checksums podem ser desabilitados, mas isto <em>não</em> é recomendado! Os checksums ocupam muito pouco espaço de armazenamento e fornecem integridade dos dados. Muitos recursos do ZFS não funcionarão adequadamente com os checksums desabilitados. Não há nenhum ganho perceptível de desempenho ao desativar os checksums.</p></div></td></tr></tbody></table></div><div class=paragraph><p>A verificação de checksum é conhecida como <em>scrubbing</em>. Verifique a integridade dos dados do pool <code>storage</code> com este comando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zpool scrub storage</span></code></pre></div></div><div class=paragraph><p>A duração de um scrub depende da quantidade de dados armazenados. Quantidades maiores de dados levarão proporcionalmente mais tempo para serem verificadas. Scrubs utilizam muito I/O, e apenas um scrub tem permissão para ser executado por vez. Após a conclusão do scrub, o status pode ser visualizado com <code>status</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zpool status storage</span>
 pool: storage
 state: ONLINE
 scrub: scrub completed with 0 errors on Sat Jan 26 19:57:37 2013
config:

	NAME        STATE     READ WRITE CKSUM
	storage     ONLINE       0     0     0
	  raidz1    ONLINE       0     0     0
	    da0     ONLINE       0     0     0
	    da1     ONLINE       0     0     0
	    da2     ONLINE       0     0     0

errors: No known data errors</code></pre></div></div><div class=paragraph><p>A data de conclusão da última operação de scrub é exibida para ajudar a rastrear quando outro scrub é necessário. Uma rotina recorrente de scrubs ajuda a proteger os dados contra corrupção silenciosa e garante a integridade do pool.</p></div><div class=paragraph><p>Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=zfs&amp;sektion=8&amp;format=html">zfs(8)</a> e <a href="https://man.freebsd.org/cgi/man.cgi?query=zpool&amp;sektion=8&amp;format=html">zpool(8)</a> para outras opções do ZFS.</p></div></div></div><div class=sect2><h3 id=zfs-zpool>19.3. Administração <code>zpool</code><a class=anchor href=#zfs-zpool></a></h3><div class=paragraph><p>A administração do ZFS é dividida entre dois utilitários principais. O utilitário <code>zpool</code> controla a operação do pool e trata da adição, remoção, substituição e gerenciamento de discos. O utilitário <a href=#zfs-zfs><code>zfs</code></a> lida com a criação, destruição e gerenciamento de datasets, tanto para <a href=#zfs-term-filesystem>sistemas de arquivos</a> quanto para <a href=#zfs-term-volume>volumes</a>.</p></div><div class=sect3><h4 id=zfs-zpool-create>19.3.1. Criando e destruindo pools de armazenamento<a class=anchor href=#zfs-zpool-create></a></h4><div class=paragraph><p>A criação de um pool de armazenamento do ZFS (<em>zpool</em>) envolve a tomada de várias decisões que são relativamente permanentes porque a estrutura do pool não pode ser alterada depois que o pool é criado. A decisão mais importante é quais tipos de vdevs usar para agrupar os discos físicos. Consulte a lista de <a href=#zfs-term-vdev>tipos vdev</a> para obter detalhes sobre as opções possíveis. Após o pool ter sido criado, a maioria dos tipos de vdev não permite que discos adicionais sejam adicionados ao vdev. As exceções são os mirrors, que permitem que discos adicionais sejam adicionados ao vdev, e stripes, que podem ser atualizados para mirrors ao anexar um disco adicional ao vdev. Embora vdevs adicionais possam ser adicionados para expandir um pool, o layout do pool não pode ser alterado após a criação do pool. Em vez disso, os dados devem ser salvos em um backup e o pool destruído e recriado.</p></div><div class=paragraph><p>Crie um pool do tipo mirror simples:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zpool create mypool mirror /dev/ada1 /dev/ada2</span>
<span class=c># zpool status</span>
  pool: mypool
 state: ONLINE
  scan: none requested
config:

        NAME        STATE     READ WRITE CKSUM
        mypool      ONLINE       0     0     0
          mirror-0  ONLINE       0     0     0
            ada1    ONLINE       0     0     0
            ada2    ONLINE       0     0     0

errors: No known data errors</code></pre></div></div><div class=paragraph><p>Vários vdevs podem ser criados de uma só vez. Especifique vários grupos de discos separados pela palavra-chave do tipo vdev, <code>mirror</code> neste exemplo:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zpool create mypool mirror /dev/ada1 /dev/ada2 mirror /dev/ada3 /dev/ada4</span>
<span class=c># zpool status</span>
  pool: mypool
 state: ONLINE
  scan: none requested
config:

        NAME        STATE     READ WRITE CKSUM
        mypool      ONLINE       0     0     0
          mirror-0  ONLINE       0     0     0
            ada1    ONLINE       0     0     0
            ada2    ONLINE       0     0     0
          mirror-1  ONLINE       0     0     0
            ada3    ONLINE       0     0     0
            ada4    ONLINE       0     0     0

errors: No known data errors</code></pre></div></div><div class=paragraph><p>Os pools também podem ser construídos usando partições em vez de discos inteiros. Colocar o ZFS em uma partição separada permite que o mesmo disco tenha outras partições para outras finalidades. Em particular, partições com bootcode e sistemas de arquivos necessários para a inicialização podem ser adicionadas. Isso permite inicializar a partir de discos que também são membros de um pool. Não há penalidade de desempenho no FreeBSD ao usar uma partição em vez de um disco inteiro. O uso de partições também permite ao administrador <em>sub-provisionar</em> os discos, usando menos que a capacidade total. Se um disco de substituição futuro com o mesmo tamanho nominal do original tiver uma capacidade ligeiramente menor, a partição menor ainda se ajustará e o disco de substituição ainda poderá ser usado.</p></div><div class=paragraph><p>Crie um pool <a href=#zfs-term-vdev-raidz>RAID-Z2</a> usando partições:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zpool create mypool raidz2 /dev/ada0p3 /dev/ada1p3 /dev/ada2p3 /dev/ada3p3 /dev/ada4p3 /dev/ada5p3</span>
<span class=c># zpool status</span>
  pool: mypool
 state: ONLINE
  scan: none requested
config:

        NAME        STATE     READ WRITE CKSUM
        mypool      ONLINE       0     0     0
          raidz2-0  ONLINE       0     0     0
            ada0p3  ONLINE       0     0     0
            ada1p3  ONLINE       0     0     0
            ada2p3  ONLINE       0     0     0
            ada3p3  ONLINE       0     0     0
            ada4p3  ONLINE       0     0     0
            ada5p3  ONLINE       0     0     0

errors: No known data errors</code></pre></div></div><div class=paragraph><p>Um pool que não é mais necessário pode ser destruído para que os discos possam ser reutilizados. Destruir um pool envolve primeiro desmontar todos os datasets nesse pool. Se os datasets estiverem em uso, a operação de desmontagem falhará e o pool não será destruído. A destruição do pool pode ser forçada com <code>-f</code>, mas isso pode causar um comportamento indefinido em aplicações que tiverem arquivos abertos nesses datasets.</p></div></div><div class=sect3><h4 id=zfs-zpool-attach>19.3.2. Adicionando e Removendo Dispositivos<a class=anchor href=#zfs-zpool-attach></a></h4><div class=paragraph><p>Existem dois casos para adicionar discos a um zpool: anexar um disco a um vdev existente com <code>zpool attach</code> ou incluir vdevs ao pool com <code>zpool add</code>. Apenas alguns <a href=#zfs-term-vdev>vdev types</a> permitem que discos sejam adicionados ao vdev após a criação.</p></div><div class=paragraph><p>Um pool criado com um único disco não tem redundância. Dados corrompidos podem ser detectados, mas não reparados, porque não há outra cópia dos dados. A propriedade <a href=#zfs-term-copies>copies</a> pode ser capaz de se recuperar de uma pequena falha, como um setor defeituoso, mas não fornece o mesmo nível de proteção que o mirror ou o RAID-Z. Começando com um pool de um único disco vdev, o <code>zpool attach</code> pode ser usado para adicionar um disco adicional ao vdev, criando um mirror. O <code>zpool attach</code> também pode ser usado para adicionar discos adicionais a um mirror group, aumentando a redundância e o desempenho de leitura. Se os discos usados para o pool forem particionados, replicar o layout do primeiro disco para o segundo, <code>gpart backup</code> e <code>gpart restore</code> pode ser usado para facilitar esse processo .</p></div><div class=paragraph><p>Atualize o disco único (stripe) vdev <em>ada0p3</em> para um mirror anexando <em>ada1p3</em>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zpool status</span>
  pool: mypool
 state: ONLINE
  scan: none requested
config:

        NAME        STATE     READ WRITE CKSUM
        mypool      ONLINE       0     0     0
          ada0p3    ONLINE       0     0     0

errors: No known data errors
<span class=c># zpool attach mypool ada0p3 ada1p3</span>
Make sure to <span class=nb>wait </span><span class=k>until </span>resilver is <span class=k>done </span>before rebooting.

If you boot from pool <span class=s1>&#39;mypool&#39;</span>, you may need to update
boot code on newly attached disk <span class=s1>&#39;ada1p3&#39;</span><span class=nb>.</span>

Assuming you use GPT partitioning and <span class=s1>&#39;da0&#39;</span> is your new boot disk
you may use the following <span class=nb>command</span>:

        gpart bootcode <span class=nt>-b</span> /boot/pmbr <span class=nt>-p</span> /boot/gptzfsboot <span class=nt>-i</span> 1 da0
<span class=c># gpart bootcode -b /boot/pmbr -p /boot/gptzfsboot -i 1 ada1</span>
bootcode written to ada1
<span class=c># zpool status</span>
  pool: mypool
 state: ONLINE
status: One or more devices is currently being resilvered.  The pool will
        <span class=k>continue </span>to <span class=k>function</span>, possibly <span class=k>in </span>a degraded state.
action: Wait <span class=k>for </span>the resilver to complete.
  scan: resilver <span class=k>in </span>progress since Fri May 30 08:19:19 2014
        527M scanned out of 781M at 47.9M/s, 0h0m to go
        527M resilvered, 67.53% <span class=k>done
</span>config:

        NAME        STATE     READ WRITE CKSUM
        mypool      ONLINE       0     0     0
          mirror-0  ONLINE       0     0     0
            ada0p3  ONLINE       0     0     0
            ada1p3  ONLINE       0     0     0  <span class=o>(</span>resilvering<span class=o>)</span>

errors: No known data errors
<span class=c># zpool status</span>
  pool: mypool
 state: ONLINE
  scan: resilvered 781M <span class=k>in </span>0h0m with 0 errors on Fri May 30 08:15:58 2014
config:

        NAME        STATE     READ WRITE CKSUM
        mypool      ONLINE       0     0     0
          mirror-0  ONLINE       0     0     0
            ada0p3  ONLINE       0     0     0
            ada1p3  ONLINE       0     0     0

errors: No known data errors</code></pre></div></div><div class=paragraph><p>Quando adicionar discos ao vdev existente não é uma opção, como para RAID-Z, um método alternativo é adicionar outro vdev ao pool. Vdevs adicionais fornecem desempenho mais alto, distribuindo as operações de escrita nos vdevs. Cada vdev é responsável por fornecer a sua própria redundância. É possível, mas desencorajado, misturar tipos de vdev, como <code>mirror</code> e <code>RAID-Z</code>. Adicionar um vdev não-redundante a um pool que contenha um vdev mirror ou o RAID-Z arrisca os dados em todo o pool. As gravações são distribuídas, portanto, a falha do disco não-redundante resultará na perda de uma fração de cada bloco que foi gravado no pool.</p></div><div class=paragraph><p>Os dados são distribuídos em cada um dos vdevs. Por exemplo, com dois vdevs mirror, esse é efetivamente um RAID 10 que escreve em dois conjuntos de mirrors. O espaço é alocado de forma que cada vdev chegue a 100% de uso ao mesmo tempo. Há uma penalidade de desempenho se os vdevs tiverem quantidades diferentes de espaço livre, pois uma quantidade desproporcional dos dados é gravada no vdev menos cheio.</p></div><div class=paragraph><p>Ao anexar dispositivos adicionais a um pool de inicialização, lembre-se de atualizar o bootcode.</p></div><div class=paragraph><p>Anexe um segundo grupo de mirror’s (<span class=filename>ada2p3</span> and <span class=filename>ada3p3</span>) ao mirror existente:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zpool status</span>
  pool: mypool
 state: ONLINE
  scan: resilvered 781M <span class=k>in </span>0h0m with 0 errors on Fri May 30 08:19:35 2014
config:

        NAME        STATE     READ WRITE CKSUM
        mypool      ONLINE       0     0     0
          mirror-0  ONLINE       0     0     0
            ada0p3  ONLINE       0     0     0
            ada1p3  ONLINE       0     0     0

errors: No known data errors
<span class=c># zpool add mypool mirror ada2p3 ada3p3</span>
<span class=c># gpart bootcode -b /boot/pmbr -p /boot/gptzfsboot -i 1 ada2</span>
bootcode written to ada2
<span class=c># gpart bootcode -b /boot/pmbr -p /boot/gptzfsboot -i 1 ada3</span>
bootcode written to ada3
<span class=c># zpool status</span>
  pool: mypool
 state: ONLINE
  scan: scrub repaired 0 <span class=k>in </span>0h0m with 0 errors on Fri May 30 08:29:51 2014
config:

        NAME        STATE     READ WRITE CKSUM
        mypool      ONLINE       0     0     0
          mirror-0  ONLINE       0     0     0
            ada0p3  ONLINE       0     0     0
            ada1p3  ONLINE       0     0     0
          mirror-1  ONLINE       0     0     0
            ada2p3  ONLINE       0     0     0
            ada3p3  ONLINE       0     0     0

errors: No known data errors</code></pre></div></div><div class=paragraph><p>Atualmente, os vdevs não podem ser removidos de um pool e os discos só podem ser removidos de um mirror se houver redundância restante suficiente. Se apenas um disco em um grupo de mirror’s permanecer, ele deixará de ser um mirror e voltará a ser um srtipe, arriscando todo o pool se o disco restante falhar.</p></div><div class=paragraph><p>Remova um disco de um grupo de mirror’s triplo:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zpool status</span>
  pool: mypool
 state: ONLINE
  scan: scrub repaired 0 <span class=k>in </span>0h0m with 0 errors on Fri May 30 08:29:51 2014
config:

        NAME        STATE     READ WRITE CKSUM
        mypool      ONLINE       0     0     0
          mirror-0  ONLINE       0     0     0
            ada0p3  ONLINE       0     0     0
            ada1p3  ONLINE       0     0     0
            ada2p3  ONLINE       0     0     0

errors: No known data errors
<span class=c># zpool detach mypool ada2p3</span>
<span class=c># zpool status</span>
  pool: mypool
 state: ONLINE
  scan: scrub repaired 0 <span class=k>in </span>0h0m with 0 errors on Fri May 30 08:29:51 2014
config:

        NAME        STATE     READ WRITE CKSUM
        mypool      ONLINE       0     0     0
          mirror-0  ONLINE       0     0     0
            ada0p3  ONLINE       0     0     0
            ada1p3  ONLINE       0     0     0

errors: No known data errors</code></pre></div></div></div><div class=sect3><h4 id=zfs-zpool-status>19.3.3. Verificando o status de um pool<a class=anchor href=#zfs-zpool-status></a></h4><div class=paragraph><p>O status do pool é importante. Se uma unidade ficar off-line ou for detectado um erro de leitura, gravação ou de checksum, a contagem de erros correspondente aumentará. A saída <code>status</code> mostra a configuração e o status de cada dispositivo no pool e o status de todo o pool. Ações que precisam ser tomadas e detalhes sobre o último <a href=#zfs-zpool-scrub><code>scrub</code></a> também são mostrados.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zpool status</span>
  pool: mypool
 state: ONLINE
  scan: scrub repaired 0 <span class=k>in </span>2h25m with 0 errors on Sat Sep 14 04:25:50 2013
config:

        NAME        STATE     READ WRITE CKSUM
        mypool      ONLINE       0     0     0
          raidz2-0  ONLINE       0     0     0
            ada0p3  ONLINE       0     0     0
            ada1p3  ONLINE       0     0     0
            ada2p3  ONLINE       0     0     0
            ada3p3  ONLINE       0     0     0
            ada4p3  ONLINE       0     0     0
            ada5p3  ONLINE       0     0     0

errors: No known data errors</code></pre></div></div></div><div class=sect3><h4 id=zfs-zpool-clear>19.3.4. Limpando Erros<a class=anchor href=#zfs-zpool-clear></a></h4><div class=paragraph><p>Quando um erro é detectado, os contadores de leitura, escrita ou checksum são incrementados. A mensagem de erro pode ser apagada e os contadores resetados com <code>zpool clear <em>mypool</em></code>. Limpar o estado de erro pode ser importante para scripts automatizados que alertam o administrador quando o pool encontra um erro. Erros adicionais podem não ser relatados se os erros antigos não forem apagados.</p></div></div><div class=sect3><h4 id=zfs-zpool-replace>19.3.5. Substituindo um dispositivo em funcionamento<a class=anchor href=#zfs-zpool-replace></a></h4><div class=paragraph><p>Há várias situações em que pode ser desejável substituir um disco por um disco diferente. Ao substituir um disco em funcionamento, o processo mantém o disco antigo online durante a substituição. O pool nunca entra no estado <a href=#zfs-term-degraded>degradado </a>, reduzindo o risco de perda de dados. <code>zpool replace</code> copia todos os dados do disco antigo para o novo. Após a conclusão da operação, o disco antigo é desconectado do vdev. Se o novo disco for maior que o disco antigo, pode ser possível aumentar o zpool usando o novo espaço. Veja <a href=#zfs-zpool-online>Aumentando um Pool </a>.</p></div><div class=paragraph><p>Substitua um dispositivo em funcionamento no pool:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zpool status</span>
  pool: mypool
 state: ONLINE
  scan: none requested
config:

        NAME        STATE     READ WRITE CKSUM
        mypool      ONLINE       0     0     0
          mirror-0  ONLINE       0     0     0
            ada0p3  ONLINE       0     0     0
            ada1p3  ONLINE       0     0     0

errors: No known data errors
<span class=c># zpool replace mypool ada1p3 ada2p3</span>
Make sure to <span class=nb>wait </span><span class=k>until </span>resilver is <span class=k>done </span>before rebooting.

If you boot from pool <span class=s1>&#39;zroot&#39;</span>, you may need to update
boot code on newly attached disk <span class=s1>&#39;ada2p3&#39;</span><span class=nb>.</span>

Assuming you use GPT partitioning and <span class=s1>&#39;da0&#39;</span> is your new boot disk
you may use the following <span class=nb>command</span>:

        gpart bootcode <span class=nt>-b</span> /boot/pmbr <span class=nt>-p</span> /boot/gptzfsboot <span class=nt>-i</span> 1 da0
<span class=c># gpart bootcode -b /boot/pmbr -p /boot/gptzfsboot -i 1 ada2</span>
<span class=c># zpool status</span>
  pool: mypool
 state: ONLINE
status: One or more devices is currently being resilvered.  The pool will
        <span class=k>continue </span>to <span class=k>function</span>, possibly <span class=k>in </span>a degraded state.
action: Wait <span class=k>for </span>the resilver to complete.
  scan: resilver <span class=k>in </span>progress since Mon Jun  2 14:21:35 2014
        604M scanned out of 781M at 46.5M/s, 0h0m to go
        604M resilvered, 77.39% <span class=k>done
</span>config:

        NAME             STATE     READ WRITE CKSUM
        mypool           ONLINE       0     0     0
          mirror-0       ONLINE       0     0     0
            ada0p3       ONLINE       0     0     0
            replacing-1  ONLINE       0     0     0
              ada1p3     ONLINE       0     0     0
              ada2p3     ONLINE       0     0     0  <span class=o>(</span>resilvering<span class=o>)</span>

errors: No known data errors
<span class=c># zpool status</span>
  pool: mypool
 state: ONLINE
  scan: resilvered 781M <span class=k>in </span>0h0m with 0 errors on Mon Jun  2 14:21:52 2014
config:

        NAME        STATE     READ WRITE CKSUM
        mypool      ONLINE       0     0     0
          mirror-0  ONLINE       0     0     0
            ada0p3  ONLINE       0     0     0
            ada2p3  ONLINE       0     0     0

errors: No known data errors</code></pre></div></div></div><div class=sect3><h4 id=zfs-zpool-resilver>19.3.6. Lidando com dispositivos com falha<a class=anchor href=#zfs-zpool-resilver></a></h4><div class=paragraph><p>Quando um disco em um pool falha, o vdev ao qual o disco pertence entra no estado <a href=#zfs-term-degraded>degradado</a>. Todos os dados ainda estão disponíveis, mas o desempenho pode ser reduzido porque os dados ausentes devem ser calculados a partir da redundância disponível. Para restaurar o vdev para um estado totalmente funcional, o dispositivo físico com falha deve ser substituído. O ZFS é então instruído a iniciar a operação <a href=#zfs-term-resilver>resilver</a>. Os dados que estavam no dispositivo com falha são recalculados da redundância disponível e gravados no dispositivo de substituição. Após a conclusão, o vdev retorna ao status <a href=#zfs-term-online>online</a>.</p></div><div class=paragraph><p>Se o vdev não tiver redundância, ou se vários dispositivos falharem e não houver redundância suficiente para compensar, o pool entrará no estado <a href=#zfs-term-faulted>failed</a>. Se um número suficiente de dispositivos não puder ser reconectado ao pool, o pool se tornará inoperante e os dados deverão ser restaurados dos backups.</p></div><div class=paragraph><p>Ao substituir um disco com falha, o nome do disco com falha é substituído pelo GUID do dispositivo. Um novo parâmetro de nome de dispositivo para o <code>zpool replace</code> não é necessário se o dispositivo de substituição tiver o mesmo nome de dispositivo.</p></div><div class=paragraph><p>Substitua um disco com falha usando o <code>zpool replace</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zpool status</span>
  pool: mypool
 state: DEGRADED
status: One or more devices could not be opened.  Sufficient replicas exist <span class=k>for
        </span>the pool to <span class=k>continue </span>functioning <span class=k>in </span>a degraded state.
action: Attach the missing device and online it using <span class=s1>&#39;zpool online&#39;</span><span class=nb>.</span>
   see: http://illumos.org/msg/ZFS-8000-2Q
  scan: none requested
config:

        NAME                    STATE     READ WRITE CKSUM
        mypool                  DEGRADED     0     0     0
          mirror-0              DEGRADED     0     0     0
            ada0p3              ONLINE       0     0     0
            316502962686821739  UNAVAIL      0     0     0  was /dev/ada1p3

errors: No known data errors
<span class=c># zpool replace mypool 316502962686821739 ada2p3</span>
<span class=c># zpool status</span>
  pool: mypool
 state: DEGRADED
status: One or more devices is currently being resilvered.  The pool will
        <span class=k>continue </span>to <span class=k>function</span>, possibly <span class=k>in </span>a degraded state.
action: Wait <span class=k>for </span>the resilver to complete.
  scan: resilver <span class=k>in </span>progress since Mon Jun  2 14:52:21 2014
        641M scanned out of 781M at 49.3M/s, 0h0m to go
        640M resilvered, 82.04% <span class=k>done
</span>config:

        NAME                        STATE     READ WRITE CKSUM
        mypool                      DEGRADED     0     0     0
          mirror-0                  DEGRADED     0     0     0
            ada0p3                  ONLINE       0     0     0
            replacing-1             UNAVAIL      0     0     0
              15732067398082357289  UNAVAIL      0     0     0  was /dev/ada1p3/old
              ada2p3                ONLINE       0     0     0  <span class=o>(</span>resilvering<span class=o>)</span>

errors: No known data errors
<span class=c># zpool status</span>
  pool: mypool
 state: ONLINE
  scan: resilvered 781M <span class=k>in </span>0h0m with 0 errors on Mon Jun  2 14:52:38 2014
config:

        NAME        STATE     READ WRITE CKSUM
        mypool      ONLINE       0     0     0
          mirror-0  ONLINE       0     0     0
            ada0p3  ONLINE       0     0     0
            ada2p3  ONLINE       0     0     0

errors: No known data errors</code></pre></div></div></div><div class=sect3><h4 id=zfs-zpool-scrub>19.3.7. Limpeza do Pool<a class=anchor href=#zfs-zpool-scrub></a></h4><div class=paragraph><p>Recomenda-se que os pools sejam regularmente <a href=#zfs-term-scrub>scrubbed</a>, idealmente pelo menos uma vez por mês. A operação <code>scrub</code> requer muito disco e reduzirá o desempenho durante a execução. Evite períodos de alta demanda ao agendar o <code>scrub</code> ou use <a href=#zfs-advanced-tuning-scrub_delay><code>vfs.zfs.scrub_delay</code></a> para ajustar a prioridade relativa do <code>scrub</code> para evitar que ele interfira com outras cargas de trabalho.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zpool scrub mypool</span>
<span class=c># zpool status</span>
  pool: mypool
 state: ONLINE
  scan: scrub <span class=k>in </span>progress since Wed Feb 19 20:52:54 2014
        116G scanned out of 8.60T at 649M/s, 3h48m to go
        0 repaired, 1.32% <span class=k>done
</span>config:

        NAME        STATE     READ WRITE CKSUM
        mypool      ONLINE       0     0     0
          raidz2-0  ONLINE       0     0     0
            ada0p3  ONLINE       0     0     0
            ada1p3  ONLINE       0     0     0
            ada2p3  ONLINE       0     0     0
            ada3p3  ONLINE       0     0     0
            ada4p3  ONLINE       0     0     0
            ada5p3  ONLINE       0     0     0

errors: No known data errors</code></pre></div></div><div class=paragraph><p>No caso de uma operação de limpeza precisar ser cancelada, emita <code>zpool scrub -s <em>mypool</em></code>.</p></div></div><div class=sect3><h4 id=zfs-zpool-selfheal>19.3.8. Auto Cura (Self-Healing)<a class=anchor href=#zfs-zpool-selfheal></a></h4><div class=paragraph><p>Os checksums armazenados com os blocos de dados habilitam o sistema de arquivos a se <em>autocorrigirem</em>. Esse recurso reparará automaticamente os dados cujo checksum não corresponde à registrada em outro dispositivo que faz parte do pool de armazenamento. Por exemplo, um espelho com dois discos em que uma unidade está começando a funcionar incorretamente e não pode armazenar os dados adequadamente. Isso é ainda pior quando os dados não são acessados há muito tempo, como no armazenamento de arquivos de longo prazo. Os sistemas de arquivos tradicionais precisam executar algoritmos que verificam e reparam os dados como o <a href="https://man.freebsd.org/cgi/man.cgi?query=fsck&amp;sektion=8&amp;format=html">fsck(8)</a>. Esses comandos levam tempo e, em casos graves, um administrador precisa decidir manualmente qual operação de reparo deve ser executada. Quando o ZFS detecta um bloco de dados com um checksum que não corresponde, ele tenta ler os dados do disco de espelhamento. Se esse disco puder fornecer os dados corretos, ele não apenas fornecerá esses dados ao aplicativo que os está solicitando, mas também corrigirá os dados errados no disco que continha o checksum incorreto. Isso acontece sem qualquer interação de um administrador do sistema durante a operação normal do pool.</p></div><div class=paragraph><p>O próximo exemplo demonstra esse comportamento de autocura. Um conjunto espelhado de discos <span class=filename>/dev/ada0</span> e <span class=filename>/dev/ada1</span> é criado.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zpool create healer mirror /dev/ada0 /dev/ada1</span>
<span class=c># zpool status healer</span>
  pool: healer
 state: ONLINE
  scan: none requested
config:

    NAME        STATE     READ WRITE CKSUM
    healer      ONLINE       0     0     0
      mirror-0  ONLINE       0     0     0
       ada0     ONLINE       0     0     0
       ada1     ONLINE       0     0     0

errors: No known data errors
<span class=c># zpool list</span>
NAME     SIZE  ALLOC   FREE   CKPOINT  EXPANDSZ   FRAG   CAP  DEDUP  HEALTH  ALTROOT
healer   960M  92.5K   960M         -         -     0%    0%  1.00x  ONLINE  -</code></pre></div></div><div class=paragraph><p>Alguns dados importantes que devem ser protegidos de erros de dados usando o recurso de correção automática são copiados para o pool. É criado um checksum do pool para comparação posterior.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cp /some/important/data /healer</span>
<span class=c># zfs list</span>
NAME     SIZE  ALLOC   FREE    CAP  DEDUP  HEALTH  ALTROOT
healer   960M  67.7M   892M     7%  1.00x  ONLINE  -
<span class=c># sha1 /healer &gt; checksum.txt</span>
<span class=c># cat checksum.txt</span>
SHA1 <span class=o>(</span>/healer<span class=o>)</span> <span class=o>=</span> 2753eff56d77d9a536ece6694bf0a82740344d1f</code></pre></div></div><div class=paragraph><p>A corrupção de dados é simulada escrevendo dados aleatórios no início de um dos discos no espelho. Para evitar que o ZFS cure os dados assim que forem detectados, o pool é exportado antes da corrupção e importado novamente depois.</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Esta é uma operação perigosa que pode destruir dados vitais. Ele é mostrado aqui apenas para fins demonstrativos e não deve ser tentado durante a operação normal de um pool de armazenamento. Nem este exemplo de corrupção intencional deve ser executado em qualquer disco com um sistema de arquivos diferente. Não use outros nomes de dispositivos de disco diferentes daqueles que fazem parte do pool. Certifique-se de que os backups apropriados do pool sejam criados antes de executar o comando!</p></div></td></tr></tbody></table></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zpool export healer</span>
<span class=c># dd if=/dev/random of=/dev/ada1 bs=1m count=200</span>
200+0 records <span class=k>in
</span>200+0 records out
209715200 bytes transferred <span class=k>in </span>62.992162 secs <span class=o>(</span>3329227 bytes/sec<span class=o>)</span>
<span class=c># zpool import healer</span></code></pre></div></div><div class=paragraph><p>O status do pool mostra que um dispositivo teve um erro. Observe que os aplicativos que leem dados do pool não receberam dados incorretos. O ZFS forneceu dados do dispositivo <span class=filename>ada0</span> com os checksums corretos. O dispositivo com o checksum incorreto pode ser encontrado facilmente, pois a coluna <code>CKSUM</code> contém um valor diferente de zero.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zpool status healer</span>
    pool: healer
   state: ONLINE
  status: One or more devices has experienced an unrecoverable error.  An
          attempt was made to correct the error.  Applications are unaffected.
  action: Determine <span class=k>if </span>the device needs to be replaced, and clear the errors
          using <span class=s1>&#39;zpool clear&#39;</span> or replace the device with <span class=s1>&#39;zpool replace&#39;</span><span class=nb>.</span>
     see: http://illumos.org/msg/ZFS-8000-4J
    scan: none requested
  config:

      NAME        STATE     READ WRITE CKSUM
      healer      ONLINE       0     0     0
        mirror-0  ONLINE       0     0     0
         ada0     ONLINE       0     0     0
         ada1     ONLINE       0     0     1

errors: No known data errors</code></pre></div></div><div class=paragraph><p>O erro foi detectado e tratado usando a redundância presente no disco de espelhamento <span class=filename>ada0</span> não afetado. Uma comparação de checksum com o original irá revelar se o pool está consistente novamente.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sha1 /healer &gt;&gt; checksum.txt</span>
<span class=c># cat checksum.txt</span>
SHA1 <span class=o>(</span>/healer<span class=o>)</span> <span class=o>=</span> 2753eff56d77d9a536ece6694bf0a82740344d1f
SHA1 <span class=o>(</span>/healer<span class=o>)</span> <span class=o>=</span> 2753eff56d77d9a536ece6694bf0a82740344d1f</code></pre></div></div><div class=paragraph><p>Os dois checksums que foram gerados antes e depois da adulteração intencional dos dados do conjunto ainda correspondem. Isso mostra como o ZFS é capaz de detectar e corrigir erros automaticamente quando os checksums são diferentes. Observe que isso só é possível quando há redundância suficiente presente no pool. Um pool que consiste em um único dispositivo não possui recursos de autocorreção. Essa também é a razão pela qual os cheksuma são tão importantes no ZFS e não devem ser desabilitados por nenhum motivo. Nenhum <a href="https://man.freebsd.org/cgi/man.cgi?query=fsck&amp;sektion=8&amp;format=html">fsck(8)</a> ou programa semelhante de verificação de consistência do sistema de arquivos é necessário para detectar e corrigir isso e o pool ainda estava disponível durante o problema. Uma operação de scrub agora é necessária para sobrescrever os dados corrompidos em <span class=filename>ada1</span>.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zpool scrub healer</span>
<span class=c># zpool status healer</span>
  pool: healer
 state: ONLINE
status: One or more devices has experienced an unrecoverable error.  An
            attempt was made to correct the error.  Applications are unaffected.
action: Determine <span class=k>if </span>the device needs to be replaced, and clear the errors
            using <span class=s1>&#39;zpool clear&#39;</span> or replace the device with <span class=s1>&#39;zpool replace&#39;</span><span class=nb>.</span>
   see: http://illumos.org/msg/ZFS-8000-4J
  scan: scrub <span class=k>in </span>progress since Mon Dec 10 12:23:30 2012
        10.4M scanned out of 67.0M at 267K/s, 0h3m to go
        9.63M repaired, 15.56% <span class=k>done
</span>config:

    NAME        STATE     READ WRITE CKSUM
    healer      ONLINE       0     0     0
      mirror-0  ONLINE       0     0     0
       ada0     ONLINE       0     0     0
       ada1     ONLINE       0     0   627  <span class=o>(</span>repairing<span class=o>)</span>

errors: No known data errors</code></pre></div></div><div class=paragraph><p>A operação scrub lê os dados do <span class=filename>ada0</span> e reescreve todos os dados com um checksum incorreto no <span class=filename>ada1</span>. Isso é indicado pela saída <code>(repairing)</code> do <code>zpool status</code>. Após a conclusão da operação, o status do conjunto é alterado para:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zpool status healer</span>
  pool: healer
 state: ONLINE
status: One or more devices has experienced an unrecoverable error.  An
        attempt was made to correct the error.  Applications are unaffected.
action: Determine <span class=k>if </span>the device needs to be replaced, and clear the errors
             using <span class=s1>&#39;zpool clear&#39;</span> or replace the device with <span class=s1>&#39;zpool replace&#39;</span><span class=nb>.</span>
   see: http://illumos.org/msg/ZFS-8000-4J
  scan: scrub repaired 66.5M <span class=k>in </span>0h2m with 0 errors on Mon Dec 10 12:26:25 2012
config:

    NAME        STATE     READ WRITE CKSUM
    healer      ONLINE       0     0     0
      mirror-0  ONLINE       0     0     0
       ada0     ONLINE       0     0     0
       ada1     ONLINE       0     0 2.72K

errors: No known data errors</code></pre></div></div><div class=paragraph><p>Após a conclusão da operação scrub e todos os dados terem sido sincronizados de <span class=filename>ada0</span> para <span class=filename>ada1</span>, as mensagens de erro podem ser <a href=#zfs-zpool-clear>Limpando Erros</a> do status do pool executando <code>zpool clear</code>.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zpool clear healer</span>
<span class=c># zpool status healer</span>
  pool: healer
 state: ONLINE
  scan: scrub repaired 66.5M <span class=k>in </span>0h2m with 0 errors on Mon Dec 10 12:26:25 2012
config:

    NAME        STATE     READ WRITE CKSUM
    healer      ONLINE       0     0     0
      mirror-0  ONLINE       0     0     0
       ada0     ONLINE       0     0     0
       ada1     ONLINE       0     0     0

errors: No known data errors</code></pre></div></div><div class=paragraph><p>O pool está agora de volta a um estado totalmente funcional e todos os erros foram apagados.</p></div></div><div class=sect3><h4 id=zfs-zpool-online>19.3.9. Crescendo um Pool<a class=anchor href=#zfs-zpool-online></a></h4><div class=paragraph><p>O tamanho utilizável de um pool redundante é limitado pela capacidade do menor dispositivo em cada vdev. O menor dispositivo pode ser substituído por um dispositivo maior. Depois de concluir uma operação <a href=#zfs-zpool-replace>replace</a> ou <a href=#zfs-term-resilver>resilver</a>, o pool pode crescer para usar a capacidade do Novo dispositivo. Por exemplo, considere um espelho de uma unidade de 1 TB e uma unidade de 2 TB. O espaço utilizável é de 1 TB. Quando a unidade de 1 TB é substituída por outra unidade de 2 TB, o processo de resilverização copia os dados existentes para a nova unidade. Como os dois dispositivos agora têm capacidade para 2 TB, o espaço disponível do espelho pode ser aumentado para 2 TB.</p></div><div class=paragraph><p>A expansão é acionada usando o <code>zpool online -e</code> em cada dispositivo. Após a expansão de todos os dispositivos, o espaço adicional fica disponível para o pool.</p></div></div><div class=sect3><h4 id=zfs-zpool-import>19.3.10. Importando e exportando pools<a class=anchor href=#zfs-zpool-import></a></h4><div class=paragraph><p>Os pools são <em>exportados</em> antes de serem movidos para outro sistema. Todos os conjuntos de dados são desmontados e cada dispositivo é marcado como exportado, mas ainda estarão bloqueados, para que não possam ser usados por outros subsistemas de disco. Isso permite que pools sejam <em>importados</em> em outras máquinas, outros sistemas operacionais que suportem ZFS , e até mesmo arquiteturas de hardware diferentes (com algumas advertências, veja <a href="https://man.freebsd.org/cgi/man.cgi?query=zpool&amp;sektion=8&amp;format=html">zpool(8)</a>). Quando um conjunto de dados tem arquivos abertos, o <code>zpool export -f</code> pode ser usado para forçar a exportação de um pool. Use isso com cautela. Os conjuntos de dados são forçosamente desmontados, resultando potencialmente em um comportamento inesperado dos aplicativos que tinham arquivos abertos nesses conjuntos de dados.</p></div><div class=paragraph><p>Exportar um pool que não está em uso:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zpool export mypool</span></code></pre></div></div><div class=paragraph><p>Importar um pool automaticamente monta os conjuntos de dados. Este pode não ser o comportamento desejado e pode ser evitado com <code>zpool import -N</code>. O <code>zpool import -o</code> define propriedades temporárias apenas para esta importação. O <code>zpool import altroot=</code> permite importar um pool com um ponto base de montagem em vez da raiz do sistema de arquivos. Se o pool foi usado pela última vez em um sistema diferente e não foi exportado corretamente, uma importação pode ter que ser forçada com <code>zpool import -f</code>. O <code>zpool import -a</code> importa todos os pools que não parecem estar em uso por outro sistema.</p></div><div class=paragraph><p>Listar todos os pools disponíveis para importação:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zpool import</span>
   pool: mypool
     <span class=nb>id</span>: 9930174748043525076
  state: ONLINE
 action: The pool can be imported using its name or numeric identifier.
 config:

        mypool      ONLINE
          ada2p3    ONLINE</code></pre></div></div><div class=paragraph><p>Importe o pool com um diretório raiz alternativo:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zpool import -o altroot=/mnt mypool</span>
<span class=c># zfs list</span>
zfs list
NAME                 USED  AVAIL  REFER  MOUNTPOINT
mypool               110K  47.0G    31K  /mnt/mypool</code></pre></div></div></div><div class=sect3><h4 id=zfs-zpool-upgrade>19.3.11. Atualizando um pool de armazenamento<a class=anchor href=#zfs-zpool-upgrade></a></h4><div class=paragraph><p>Após a atualização do FreeBSD, ou se um pool foi importado de um sistema usando uma versão mais antiga do ZFS, o pool pode ser atualizado manualmente para a versão mais recente do ZFS para suportar as funcionalidades mais recentes. Considere se o pool pode precisar ser importado em um sistema antigo antes de atualizar. A atualização é um processo unidirecional. Os pools mais antigos podem ser atualizados, mas os pools com funcionalidades mais recentes não podem ser desatualizados.</p></div><div class=paragraph><p>Atualize um pool v28 para suportar <code>Feature Flags</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zpool status</span>
  pool: mypool
 state: ONLINE
status: The pool is formatted using a legacy on-disk format.  The pool can
        still be used, but some features are unavailable.
action: Upgrade the pool using <span class=s1>&#39;zpool upgrade&#39;</span><span class=nb>.</span>  Once this is <span class=k>done</span>, the
        pool will no longer be accessible on software that does not support feat
        flags.
  scan: none requested
config:

        NAME        STATE     READ WRITE CKSUM
        mypool      ONLINE       0     0     0
          mirror-0  ONLINE       0     0     0
	    ada0    ONLINE       0     0     0
	    ada1    ONLINE       0     0     0

errors: No known data errors
<span class=c># zpool upgrade</span>
This system supports ZFS pool feature flags.

The following pools are formatted with legacy version numbers and can
be upgraded to use feature flags.  After being upgraded, these pools
will no longer be accessible by software that does not support feature
flags.

VER  POOL
<span class=nt>---</span>  <span class=nt>------------</span>
28   mypool

Use <span class=s1>&#39;zpool upgrade -v&#39;</span> <span class=k>for </span>a list of available legacy versions.
Every feature flags pool has all supported features enabled.
<span class=c># zpool upgrade mypool</span>
This system supports ZFS pool feature flags.

Successfully upgraded <span class=s1>&#39;mypool&#39;</span> from version 28 to feature flags.
Enabled the following features on <span class=s1>&#39;mypool&#39;</span>:
  async_destroy
  empty_bpobj
  lz4_compress
  multi_vdev_crash_dump</code></pre></div></div><div class=paragraph><p>Os recursos mais recentes do ZFS não estarão disponíveis até que o <code>zpool upgrade</code> seja concluído. O <code>zpool upgrade -v</code> pode ser usado para ver quais os novos recursos que serão fornecidos pela atualização, bem como quais recursos já são suportados.</p></div><div class=paragraph><p>Atualize um pool para suportar feature flags adicionais:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zpool status</span>
  pool: mypool
 state: ONLINE
status: Some supported features are not enabled on the pool. The pool can
        still be used, but some features are unavailable.
action: Enable all features using <span class=s1>&#39;zpool upgrade&#39;</span><span class=nb>.</span> Once this is <span class=k>done</span>,
        the pool may no longer be accessible by software that does not support
        the features. See zpool-features<span class=o>(</span>7<span class=o>)</span> <span class=k>for </span>details.
  scan: none requested
config:

        NAME        STATE     READ WRITE CKSUM
        mypool      ONLINE       0     0     0
          mirror-0  ONLINE       0     0     0
	    ada0    ONLINE       0     0     0
	    ada1    ONLINE       0     0     0

errors: No known data errors
<span class=c># zpool upgrade</span>
This system supports ZFS pool feature flags.

All pools are formatted using feature flags.

Some supported features are not enabled on the following pools. Once a
feature is enabled the pool may become incompatible with software
that does not support the feature. See zpool-features<span class=o>(</span>7<span class=o>)</span> <span class=k>for </span>details.

POOL  FEATURE
<span class=nt>---------------</span>
zstore
      multi_vdev_crash_dump
      spacemap_histogram
      enabled_txg
      hole_birth
      extensible_dataset
      bookmarks
      filesystem_limits
<span class=c># zpool upgrade mypool</span>
This system supports ZFS pool feature flags.

Enabled the following features on <span class=s1>&#39;mypool&#39;</span>:
  spacemap_histogram
  enabled_txg
  hole_birth
  extensible_dataset
  bookmarks
  filesystem_limits</code></pre></div></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>O boot code em sistemas que inicializam a partir de um pool deve ser atualizado para suportar a nova versão do pool. Use <code>gpart bootcode</code> na partição que contém o boot code. Existem dois tipos de bootcode disponíveis, dependendo da forma como o sistema inicializa: GPT (a opção mais comum) e EFI (para sistemas mais modernos).</p></div><div class=paragraph><p>Para inicialização legada usando o GPT, use o seguinte comando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gpart bootcode -b /boot/pmbr -p /boot/gptzfsboot -i 1 ada1</span></code></pre></div></div><div class=paragraph><p>Para sistemas que usam o EFI para inicializar, execute o seguinte comando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gpart bootcode -p /boot/boot1.efifat -i 1 ada1</span></code></pre></div></div><div class=paragraph><p>Aplique o bootcode a todos os discos inicializáveis no pool. Veja <a href="https://man.freebsd.org/cgi/man.cgi?query=gpart&amp;sektion=8&amp;format=html">gpart(8)</a> para obter maiores informações.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=zfs-zpool-history>19.3.12. Exibindo o histórico gravado do pool<a class=anchor href=#zfs-zpool-history></a></h4><div class=paragraph><p>Comandos que modificam o pool são registrados. As ações registradas incluem a criação de conjuntos de dados, a alteração de propriedades ou a substituição de um disco. Esse histórico é útil para revisar como um pool foi criado e qual usuário executou uma ação específica e quando. O histórico não é mantido em um arquivo de log, mas faz parte do próprio pool. O comando para revisar este histórico é apropriadamente chamado de <code>zpool history</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zpool history</span>
History <span class=k>for</span> <span class=s1>&#39;tank&#39;</span>:
2013-02-26.23:02:35 zpool create tank mirror /dev/ada0 /dev/ada1
2013-02-27.18:50:58 zfs <span class=nb>set </span><span class=nv>atime</span><span class=o>=</span>off tank
2013-02-27.18:51:09 zfs <span class=nb>set </span><span class=nv>checksum</span><span class=o>=</span>fletcher4 tank
2013-02-27.18:51:18 zfs create tank/backup</code></pre></div></div><div class=paragraph><p>A saída mostra os comandos <code>zpool</code> e <code>zfs</code> que foram executados no pool juntamente com um registro de data e hora. Somente comandos que alteram o pool de alguma forma são registrados. Comandos como <code>zfs list</code> não estão incluídos. Quando nenhum nome de pool é especificado, é exibido o histórico de todos os pools.</p></div><div class=paragraph><p>O <code>zpool history</code> pode mostrar ainda mais informações quando as opções <code>-i</code> ou <code>-l</code> são fornecidas. A opção <code>-i</code> exibe eventos iniciados pelo usuário, bem como eventos do ZFS registrados internamente.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zpool history -i</span>
History <span class=k>for</span> <span class=s1>&#39;tank&#39;</span>:
2013-02-26.23:02:35 <span class=o>[</span>internal pool create txg:5] pool spa 28<span class=p>;</span> zfs spa 28<span class=p>;</span> zpl 5<span class=p>;</span>uts  9.1-RELEASE 901000 amd64
2013-02-27.18:50:53 <span class=o>[</span>internal property <span class=nb>set </span>txg:50] <span class=nv>atime</span><span class=o>=</span>0 dataset <span class=o>=</span> 21
2013-02-27.18:50:58 zfs <span class=nb>set </span><span class=nv>atime</span><span class=o>=</span>off tank
2013-02-27.18:51:04 <span class=o>[</span>internal property <span class=nb>set </span>txg:53] <span class=nv>checksum</span><span class=o>=</span>7 dataset <span class=o>=</span> 21
2013-02-27.18:51:09 zfs <span class=nb>set </span><span class=nv>checksum</span><span class=o>=</span>fletcher4 tank
2013-02-27.18:51:13 <span class=o>[</span>internal create txg:55] dataset <span class=o>=</span> 39
2013-02-27.18:51:18 zfs create tank/backup</code></pre></div></div><div class=paragraph><p>Mais detalhes podem ser mostrados adicionando a opção <code>-l</code>. Os registros de histórico são mostrados em um formato longo, incluindo informações como o nome do usuário que emitiu o comando e o nome do host no qual a alteração foi feita.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zpool history -l</span>
History <span class=k>for</span> <span class=s1>&#39;tank&#39;</span>:
2013-02-26.23:02:35 zpool create tank mirror /dev/ada0 /dev/ada1 <span class=o>[</span>user 0 <span class=o>(</span>root<span class=o>)</span> on :global]
2013-02-27.18:50:58 zfs <span class=nb>set </span><span class=nv>atime</span><span class=o>=</span>off tank <span class=o>[</span>user 0 <span class=o>(</span>root<span class=o>)</span> on myzfsbox:global]
2013-02-27.18:51:09 zfs <span class=nb>set </span><span class=nv>checksum</span><span class=o>=</span>fletcher4 tank <span class=o>[</span>user 0 <span class=o>(</span>root<span class=o>)</span> on myzfsbox:global]
2013-02-27.18:51:18 zfs create tank/backup <span class=o>[</span>user 0 <span class=o>(</span>root<span class=o>)</span> on myzfsbox:global]</code></pre></div></div><div class=paragraph><p>A saída mostra que o usuário <code>root</code> criou o pool espelhado com os discos <span class=filename>/dev/ada0</span> e <span class=filename>/dev/ada1</span>. O nome do host <code>myzfsbox</code> também é mostrado nos comandos após a criação do pool. A exibição do nome do host se torna importante quando o pool é exportado de um sistema e importado para outro. Os comandos que são emitidos no outro sistema podem claramente ser distinguidos pelo nome do host que é registrado para cada comando.</p></div><div class=paragraph><p>Ambas as opções para o <code>zpool history</code> podem ser combinadas para fornecer as informações mais detalhadas possíveis para qualquer pool. O histórico do pool fornece informações valiosas ao rastrear as ações que foram executadas ou quando é necessária uma saída mais detalhada para a depuração.</p></div></div><div class=sect3><h4 id=zfs-zpool-iostat>19.3.13. Monitoramento de Desempenho<a class=anchor href=#zfs-zpool-iostat></a></h4><div class=paragraph><p>Um sistema de monitoramento integrado pode exibir estatísticas de I/O do pool em tempo real. Ele mostra a quantidade de espaço livre e usado no pool, quantas operações de leitura e gravação estão sendo executadas por segundo e quanto de largura de banda de I/O está sendo utilizada no momento. Por padrão, todos os pools no sistema são monitorados e exibidos. Um nome de pool pode ser fornecido para limitar o monitoramento apenas a esse pool. Um exemplo básico:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zpool iostat</span>
               capacity     operations    bandwidth
pool        alloc   free   <span class=nb>read  </span>write   <span class=nb>read  </span>write
<span class=nt>----------</span>  <span class=nt>-----</span>  <span class=nt>-----</span>  <span class=nt>-----</span>  <span class=nt>-----</span>  <span class=nt>-----</span>  <span class=nt>-----</span>
data         288G  1.53T      2     11  11.3K  57.1K</code></pre></div></div><div class=paragraph><p>Para monitorar continuamente a atividade de I/O, um número pode ser especificado como o último parâmetro, indicando um intervalo em segundos para aguardar entre as atualizações. A próxima linha de estatística é impressa após cada intervalo. Pressione <span class=keyseq><kbd>Ctrl</kbd>+<kbd>C</kbd></span> para interromper este monitoramento contínuo. Como alternativa, forneça um segundo número na linha de comando após o intervalo para especificar o número total de estatísticas a serem exibidas.</p></div><div class=paragraph><p>Estatísticas mais detalhadas de I/O podem ser exibidas com a opção <code>-v</code>. Cada dispositivo no pool é mostrado com uma linha de estatísticas. Isso é útil para ver quantas operações de leitura e gravação estão sendo executadas em cada dispositivo e pode ajudar a determinar se algum dispositivo individual está reduzindo a velocidade do pool. Este exemplo mostra um pool espelhado com dois dispositivos:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zpool iostat -v</span>
                            capacity     operations    bandwidth
pool                     alloc   free   <span class=nb>read  </span>write   <span class=nb>read  </span>write
<span class=nt>-----------------------</span>  <span class=nt>-----</span>  <span class=nt>-----</span>  <span class=nt>-----</span>  <span class=nt>-----</span>  <span class=nt>-----</span>  <span class=nt>-----</span>
data                      288G  1.53T      2     12  9.23K  61.5K
  mirror                  288G  1.53T      2     12  9.23K  61.5K
    ada1                     -      -      0      4  5.61K  61.7K
    ada2                     -      -      1      4  5.04K  61.7K
<span class=nt>-----------------------</span>  <span class=nt>-----</span>  <span class=nt>-----</span>  <span class=nt>-----</span>  <span class=nt>-----</span>  <span class=nt>-----</span>  <span class=nt>-----</span></code></pre></div></div></div><div class=sect3><h4 id=zfs-zpool-split>19.3.14. Dividindo um pool de armazenamento<a class=anchor href=#zfs-zpool-split></a></h4><div class=paragraph><p>Um pool que consiste em um ou mais vdevs espelhados pode ser dividido em dois conjuntos. A menos que seja especificado de outra forma, o último membro de cada espelho é desanexado e usado para criar um novo pool contendo os mesmos dados. A operação deve primeiro ser tentada com <code>-n</code>. Os detalhes da operação proposta são exibidos sem que sejam realmente executados. Isso ajuda a confirmar que a operação fará o que o usuário pretende.</p></div></div></div><div class=sect2><h3 id=zfs-zfs>19.4. Administração do <code>zfs</code><a class=anchor href=#zfs-zfs></a></h3><div class=paragraph><p>O utilitário <code>zfs</code> é responsável por criar, destruir e gerenciar todos os conjuntos de dados ZFS existentes em um pool. O pool é gerenciado usando o <a href=#zfs-zpool><code>zpool</code></a>.</p></div><div class=sect3><h4 id=zfs-zfs-create>19.4.1. Criando e destruindo conjuntos de dados<a class=anchor href=#zfs-zfs-create></a></h4><div class=paragraph><p>Ao contrário dos discos tradicionais e gerenciadores de volume, o espaço no ZFS_não_ é pré-alocado. Nos sistemas de arquivos tradicionais, depois que todo o espaço é particionado e atribuído, não há como adicionar um sistema de arquivos adicional sem adicionar um novo disco. Com o ZFS, novos sistemas de arquivos podem ser criados a qualquer momento. Cada <a href=#zfs-term-dataset><em>conjunto de dados</em></a> tem propriedades incluindo recursos como compactação, deduplicação, armazenamento em cache e cotas, bem como outras propriedades úteis como somente leitura, diferenciação de maiúsculas e minúsculas , compartilhamento de arquivos de rede e um ponto de montagem. Os conjuntos de dados podem ser aninhados uns dentro dos outros e os conjuntos de dados filhos herdarão propriedades de seus pais. Cada conjunto de dados pode ser administrado, <a href=#zfs-zfs-allow>delegado</a>, <a href=#zfs-zfs-send>replicado</a>, preservado por um <a href=#zfs-zfs-snapshot>snapshot</a>, <a href=#zfs-zfs-jail>preso</a>, e destruído como uma unidade. Há muitas vantagens em criar um conjunto de dados separado para cada tipo ou conjunto de arquivos diferente. A única desvantagem de ter um número extremamente grande de conjuntos de dados é que alguns comandos como <code>zfs list</code> serão mais lentos, e a montagem de centenas ou mesmo milhares de conjuntos de dados pode retardar o processo de inicialização do FreeBSD.</p></div><div class=paragraph><p>Crie um novo conjunto de dados e ative a <a href=#zfs-term-compression-lz4>compactação LZ4</a> nele:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs list</span>
NAME                  USED  AVAIL  REFER  MOUNTPOINT
mypool                781M  93.2G   144K  none
mypool/ROOT           777M  93.2G   144K  none
mypool/ROOT/default   777M  93.2G   777M  /
mypool/tmp            176K  93.2G   176K  /tmp
mypool/usr            616K  93.2G   144K  /usr
mypool/usr/home       184K  93.2G   184K  /usr/home
mypool/usr/ports      144K  93.2G   144K  /usr/ports
mypool/usr/src        144K  93.2G   144K  /usr/src
mypool/var           1.20M  93.2G   608K  /var
mypool/var/crash      148K  93.2G   148K  /var/crash
mypool/var/log        178K  93.2G   178K  /var/log
mypool/var/mail       144K  93.2G   144K  /var/mail
mypool/var/tmp        152K  93.2G   152K  /var/tmp
<span class=c># zfs create -o compress=lz4 mypool/usr/mydataset</span>
<span class=c># zfs list</span>
NAME                   USED  AVAIL  REFER  MOUNTPOINT
mypool                 781M  93.2G   144K  none
mypool/ROOT            777M  93.2G   144K  none
mypool/ROOT/default    777M  93.2G   777M  /
mypool/tmp             176K  93.2G   176K  /tmp
mypool/usr             704K  93.2G   144K  /usr
mypool/usr/home        184K  93.2G   184K  /usr/home
mypool/usr/mydataset  87.5K  93.2G  87.5K  /usr/mydataset
mypool/usr/ports       144K  93.2G   144K  /usr/ports
mypool/usr/src         144K  93.2G   144K  /usr/src
mypool/var            1.20M  93.2G   610K  /var
mypool/var/crash       148K  93.2G   148K  /var/crash
mypool/var/log         178K  93.2G   178K  /var/log
mypool/var/mail        144K  93.2G   144K  /var/mail
mypool/var/tmp         152K  93.2G   152K  /var/tmp</code></pre></div></div><div class=paragraph><p>A destruição de um conjunto de dados é muito mais rápida que a exclusão de todos os arquivos que residem no conjunto de dados, pois não envolve a verificação de todos os arquivos e a atualização de todos os metadados correspondentes.</p></div><div class=paragraph><p>Destrua o conjunto de dados criado anteriormente:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs list</span>
NAME                   USED  AVAIL  REFER  MOUNTPOINT
mypool                 880M  93.1G   144K  none
mypool/ROOT            777M  93.1G   144K  none
mypool/ROOT/default    777M  93.1G   777M  /
mypool/tmp             176K  93.1G   176K  /tmp
mypool/usr             101M  93.1G   144K  /usr
mypool/usr/home        184K  93.1G   184K  /usr/home
mypool/usr/mydataset   100M  93.1G   100M  /usr/mydataset
mypool/usr/ports       144K  93.1G   144K  /usr/ports
mypool/usr/src         144K  93.1G   144K  /usr/src
mypool/var            1.20M  93.1G   610K  /var
mypool/var/crash       148K  93.1G   148K  /var/crash
mypool/var/log         178K  93.1G   178K  /var/log
mypool/var/mail        144K  93.1G   144K  /var/mail
mypool/var/tmp         152K  93.1G   152K  /var/tmp
<span class=c># zfs destroy mypool/usr/mydataset</span>
<span class=c># zfs list</span>
NAME                  USED  AVAIL  REFER  MOUNTPOINT
mypool                781M  93.2G   144K  none
mypool/ROOT           777M  93.2G   144K  none
mypool/ROOT/default   777M  93.2G   777M  /
mypool/tmp            176K  93.2G   176K  /tmp
mypool/usr            616K  93.2G   144K  /usr
mypool/usr/home       184K  93.2G   184K  /usr/home
mypool/usr/ports      144K  93.2G   144K  /usr/ports
mypool/usr/src        144K  93.2G   144K  /usr/src
mypool/var           1.21M  93.2G   612K  /var
mypool/var/crash      148K  93.2G   148K  /var/crash
mypool/var/log        178K  93.2G   178K  /var/log
mypool/var/mail       144K  93.2G   144K  /var/mail
mypool/var/tmp        152K  93.2G   152K  /var/tmp</code></pre></div></div><div class=paragraph><p>Nas versões modernas do ZFS, o <code>zfs destroy</code> é assíncrono, e o espaço livre pode levar vários minutos para aparecer no pool. Use o <code>zpool get freeing <em>poolname</em></code> para ver a propriedade <code>freeing</code>, indicando quantos conjuntos de dados estão tendo seus blocos liberados em segundo plano. Se houver conjuntos de dados filhos, como <a href=#zfs-term-snapshot>snapshots</a> ou outros conjuntos de dados, o pai não poderá ser destruído. Para destruir um conjunto de dados e todos os seus filhos, use <code>-r</code> para destruir recursivamente o conjunto de dados e todos os seus filhos. Use <code>-n -v</code> para listar os conjuntos de dados e snapshots que seriam destruídos por esta operação, mas na verdade não destruirão nada. O espaço que seria recuperado pela destruição dos snapshots também é mostrado.</p></div></div><div class=sect3><h4 id=zfs-zfs-volume>19.4.2. Criando e Destruindo Volumes<a class=anchor href=#zfs-zfs-volume></a></h4><div class=paragraph><p>Um volume é um tipo especial de conjunto de dados. Em vez de ser montado como um sistema de arquivos, ele é exposto como um dispositivo de bloco em <span class=filename>/dev/zvol/poolname/dataset</span>. Isso permite que o volume seja usado para outros sistemas de arquivos, para fazer backup dos discos de uma máquina virtual ou para ser exportado usando protocolos como iSCSI ou HAST.</p></div><div class=paragraph><p>Um volume pode ser formatado com qualquer sistema de arquivos ou usado sem um sistema de arquivos para armazenar dados brutos. Para o usuário, um volume parece ser um disco normal. Colocar sistemas de arquivos comuns nesses <em>zvols</em> fornece recursos que os discos comuns ou sistemas de arquivos normalmente não possuem. Por exemplo, o uso da propriedade de compactação em um volume de 250 MB permite a criação de um sistema de arquivos FAT compactado.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs create -V 250m -o compression=on tank/fat32</span>
<span class=c># zfs list tank</span>
NAME USED AVAIL REFER MOUNTPOINT
tank 258M  670M   31K /tank
<span class=c># newfs_msdos -F32 /dev/zvol/tank/fat32</span>
<span class=c># mount -t msdosfs /dev/zvol/tank/fat32 /mnt</span>
<span class=c># df -h /mnt | grep fat32</span>
Filesystem           Size Used Avail Capacity Mounted on
/dev/zvol/tank/fat32 249M  24k  249M     0%   /mnt
<span class=c># mount | grep fat32</span>
/dev/zvol/tank/fat32 on /mnt <span class=o>(</span>msdosfs, <span class=nb>local</span><span class=o>)</span></code></pre></div></div><div class=paragraph><p>Destruir um volume é o mesmo que destruir um conjunto de dados regular do sistema de arquivos. A operação é quase instantânea, mas pode levar vários minutos para que o espaço livre seja recuperado em segundo plano.</p></div></div><div class=sect3><h4 id=zfs-zfs-rename>19.4.3. Renomeando um Conjunto de Dados<a class=anchor href=#zfs-zfs-rename></a></h4><div class=paragraph><p>O nome de um conjunto de dados pode ser alterado com <code>zfs rename</code>. O pai de um conjunto de dados também pode ser alterado com esse comando. A renomeação de um conjunto de dados para um conjunto de dados pai diferente alterará o valor das propriedades herdadas do conjunto de dados pai. Quando um conjunto de dados é renomeado, ele é desmontado e, em seguida, remontado no novo local (que é herdado do novo conjunto de dados pai). Esse comportamento pode ser evitado com <code>-u</code>.</p></div><div class=paragraph><p>Renomeie um conjunto de dados e mova-o para um conjunto de dados pai diferente:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs list</span>
NAME                   USED  AVAIL  REFER  MOUNTPOINT
mypool                 780M  93.2G   144K  none
mypool/ROOT            777M  93.2G   144K  none
mypool/ROOT/default    777M  93.2G   777M  /
mypool/tmp             176K  93.2G   176K  /tmp
mypool/usr             704K  93.2G   144K  /usr
mypool/usr/home        184K  93.2G   184K  /usr/home
mypool/usr/mydataset  87.5K  93.2G  87.5K  /usr/mydataset
mypool/usr/ports       144K  93.2G   144K  /usr/ports
mypool/usr/src         144K  93.2G   144K  /usr/src
mypool/var            1.21M  93.2G   614K  /var
mypool/var/crash       148K  93.2G   148K  /var/crash
mypool/var/log         178K  93.2G   178K  /var/log
mypool/var/mail        144K  93.2G   144K  /var/mail
mypool/var/tmp         152K  93.2G   152K  /var/tmp
<span class=c># zfs rename mypool/usr/mydataset mypool/var/newname</span>
<span class=c># zfs list</span>
NAME                  USED  AVAIL  REFER  MOUNTPOINT
mypool                780M  93.2G   144K  none
mypool/ROOT           777M  93.2G   144K  none
mypool/ROOT/default   777M  93.2G   777M  /
mypool/tmp            176K  93.2G   176K  /tmp
mypool/usr            616K  93.2G   144K  /usr
mypool/usr/home       184K  93.2G   184K  /usr/home
mypool/usr/ports      144K  93.2G   144K  /usr/ports
mypool/usr/src        144K  93.2G   144K  /usr/src
mypool/var           1.29M  93.2G   614K  /var
mypool/var/crash      148K  93.2G   148K  /var/crash
mypool/var/log        178K  93.2G   178K  /var/log
mypool/var/mail       144K  93.2G   144K  /var/mail
mypool/var/newname   87.5K  93.2G  87.5K  /var/newname
mypool/var/tmp        152K  93.2G   152K  /var/tmp</code></pre></div></div><div class=paragraph><p>Os snapshots também podem ser renomeados dessa maneira. Devido à natureza dos snapshots, eles não podem ser renomeados para um conjunto de dados pai diferente. Para renomear um snapshot recursivo, especifique <code>-r</code> e todos os snapshots com o mesmo nome nos conjuntos de dados filho também serão renomeados.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs list -t snapshot</span>
NAME                                USED  AVAIL  REFER  MOUNTPOINT
mypool/var/newname@first_snapshot      0      -  87.5K  -
<span class=c># zfs rename mypool/var/newname@first_snapshot new_snapshot_name</span>
<span class=c># zfs list -t snapshot</span>
NAME                                   USED  AVAIL  REFER  MOUNTPOINT
mypool/var/newname@new_snapshot_name      0      -  87.5K  -</code></pre></div></div></div><div class=sect3><h4 id=zfs-zfs-set>19.4.4. Configurando Propriedades do Conjunto de Dados<a class=anchor href=#zfs-zfs-set></a></h4><div class=paragraph><p>Cada conjunto de dados do ZFS possui várias propriedades que controlam seu comportamento. A maioria das propriedades é herdada automaticamente do conjunto de dados pai, mas pode ser substituída localmente. Defina uma propriedade em um conjunto de dados com <code>zfs set <em>property</em>=<em>value__dataset</em></code>. A maioria das propriedades tem um conjunto limitado de valores válidos, o <code>zfs get</code> exibirá cada propriedade e valor válido possível. A maioria das propriedades pode ser revertida para seus valores herdados usando <code>zfs inherit</code>.</p></div><div class=paragraph><p>Propriedades definidas pelo usuário também podem ser definidas. Eles se tornam parte da configuração do conjunto de dados e podem ser usados para fornecer informações adicionais sobre o conjunto de dados ou seu conteúdo. Para distinguir essas propriedades personalizadas daquelas fornecidas como parte do ZFS, dois pontos (<code>:</code>) são usados para criar um namespace personalizado para a propriedade.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs set custom:costcenter=1234 tank</span>
<span class=c># zfs get custom:costcenter tank</span>
NAME PROPERTY           VALUE SOURCE
tank custom:costcenter  1234  <span class=nb>local</span></code></pre></div></div><div class=paragraph><p>Para remover uma propriedade customizada, use o <code>zfs inherit</code> com <code>-r</code>. Se a propriedade personalizada não estiver definida em nenhum dos conjuntos de dados pai, ela será removida completamente (embora as alterações ainda sejam registradas no histórico do pool).</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> <span class=c>#   zfs inherit -r  customizado :  costcenter   tanque</span>
 <span class=c>#   zfs  customizado :  costcenter   tank</span>
NAME PROPERTY VALUE SOURCE
tanque personalizado: costcenter - -
 <span class=c>#   zfs obtém todos  tank  | grep  personalizado :  costcenter</span>
 <span class=c>#</span></code></pre></div></div><div class=sect4><h5 id=zfs-zfs-set-share>19.4.4.1. Obtendo e definindo propriedades de compartilhamento<a class=anchor href=#zfs-zfs-set-share></a></h5><div class=paragraph><p>Duas propriedades de conjunto de dados comumente usadas e úteis são as opções de compartilhamento NFS e SMB. Configurar estas define se e como os conjuntos de dados do ZFS podem ser compartilhados na rede. Atualmente, apenas o compartilhamento de configurações via NFS é suportado no FreeBSD. Para obter o status atual de um compartilhamento, insira:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs get sharenfs mypool/usr/home</span>
NAME             PROPERTY  VALUE    SOURCE
mypool/usr/home  sharenfs  on       <span class=nb>local</span>
<span class=c># zfs get sharesmb mypool/usr/home</span>
NAME             PROPERTY  VALUE    SOURCE
mypool/usr/home  sharesmb  off      <span class=nb>local</span></code></pre></div></div><div class=paragraph><p>Para ativar o compartilhamento de um conjunto de dados, insira:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs set sharenfs=on mypool/usr/home</span></code></pre></div></div><div class=paragraph><p>Também é possível definir opções adicionais para compartilhar conjuntos de dados por meio do NFS, como <code>-alldirs</code>, <code>-maproot</code> e <code>-network</code>. Para definir opções adicionais para um conjunto de dados compartilhado por meio do NFS, insira:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs set sharenfs=&#34;-alldirs,-maproot=root,-network=192.168.1.0/24&#34; mypool/usr/home</span></code></pre></div></div></div></div><div class=sect3><h4 id=zfs-zfs-snapshot>19.4.5. Gerenciando Snapshots<a class=anchor href=#zfs-zfs-snapshot></a></h4><div class=paragraph><p>Os <a href=#zfs-term-snapshot>snapshots</a> são um dos recursos mais poderosos do ZFS. Um snapshot fornece uma cópia point-in-time somente leitura do conjunto de dados. Com Copy-On-Write (COW), os snapshots podem ser criados rapidamente, preservando a versão mais antiga dos dados no disco. Se não houver snapshots, o espaço será recuperado para uso futuro quando os dados forem reconfigurados ou excluídos. Os snapshots preservam o espaço em disco gravando apenas as diferenças entre o conjunto de dados atual e uma versão anterior. Os snapshots são permitidos apenas em conjuntos de dados completos, não em arquivos ou diretórios individuais. Quando um snapshot é criado a partir de um conjunto de dados, tudo contido nele é duplicado. Isso inclui as propriedades do sistema de arquivos, arquivos, diretórios, permissões e assim por diante. Os snapshots não usam espaço adicional quando são criados pela primeira vez, consumindo espaço apenas quando os blocos de referência são alterados. Snapshots recursivos obtidos com <code>-r</code> criam um instantâneo com o mesmo nome no conjunto de dados e em todos os seus filhos, fornecendo um snapshot moment-in-time de todos os sistemas de arquivos no momento. Isso pode ser importante quando um aplicativo possui arquivos em vários conjuntos de dados relacionados ou dependentes um do outro. Sem snapshots, um backup teria cópias dos arquivos de diferentes pontos no tempo.</p></div><div class=paragraph><p>Os snapshots no ZFS fornecem uma variedade de recursos que até mesmo outros sistemas de arquivos com a funcionalidade de snapshots não têm. Um exemplo típico de uso de snapshots é ter uma maneira rápida de fazer backup do estado atual do sistema de arquivos quando uma ação arriscada, como uma instalação de software ou uma atualização do sistema, é executada. Se a ação falhar, o snapshot poderá ser revertido e o sistema terá o mesmo estado de quando o snapshot foi criado. Se a atualização foi bem sucedida, o instantâneo pode ser excluído para liberar espaço. Sem snapshots, uma atualização com falha geralmente requer uma restauração de backup, o que é tedioso, consome tempo e pode exigir tempo de inatividade durante o qual o sistema não pode ser usado. Os snapshots podem ser revertidos rapidamente, mesmo enquanto o sistema está sendo executado em operação normal, com pouco ou nenhum tempo de inatividade. A economia de tempo é enorme com sistemas de armazenamento de vários terabytes e o tempo necessário para copiar os dados a partir do backup. Os snapshots não substituem um backup completo de um pool, mas podem ser usados de maneira rápida e fácil para armazenar uma cópia do conjunto de dados em um momento específico.</p></div><div class=sect4><h5 id=zfs-zfs-snapshot-creation>19.4.5.1. Criando Snapshots<a class=anchor href=#zfs-zfs-snapshot-creation></a></h5><div class=paragraph><p>Os snapshots são criados com <code>zfs snapshot <em>dataset</em>@<em>snapshotname</em></code>. Adicionar a opção <code>-r</code> cria um snapshot recursivamente, com o mesmo nome em todos os conjuntos de dados filho.</p></div><div class=paragraph><p>Crie um Snapshot recursivo de todo o pool:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs list -t all</span>
NAME                                   USED  AVAIL  REFER  MOUNTPOINT
mypool                                 780M  93.2G   144K  none
mypool/ROOT                            777M  93.2G   144K  none
mypool/ROOT/default                    777M  93.2G   777M  /
mypool/tmp                             176K  93.2G   176K  /tmp
mypool/usr                             616K  93.2G   144K  /usr
mypool/usr/home                        184K  93.2G   184K  /usr/home
mypool/usr/ports                       144K  93.2G   144K  /usr/ports
mypool/usr/src                         144K  93.2G   144K  /usr/src
mypool/var                            1.29M  93.2G   616K  /var
mypool/var/crash                       148K  93.2G   148K  /var/crash
mypool/var/log                         178K  93.2G   178K  /var/log
mypool/var/mail                        144K  93.2G   144K  /var/mail
mypool/var/newname                    87.5K  93.2G  87.5K  /var/newname
mypool/var/newname@new_snapshot_name      0      -  87.5K  -
mypool/var/tmp                         152K  93.2G   152K  /var/tmp
<span class=c># zfs snapshot -r mypool@my_recursive_snapshot</span>
<span class=c># zfs list -t snapshot</span>
NAME                                        USED  AVAIL  REFER  MOUNTPOINT
mypool@my_recursive_snapshot                   0      -   144K  -
mypool/ROOT@my_recursive_snapshot              0      -   144K  -
mypool/ROOT/default@my_recursive_snapshot      0      -   777M  -
mypool/tmp@my_recursive_snapshot               0      -   176K  -
mypool/usr@my_recursive_snapshot               0      -   144K  -
mypool/usr/home@my_recursive_snapshot          0      -   184K  -
mypool/usr/ports@my_recursive_snapshot         0      -   144K  -
mypool/usr/src@my_recursive_snapshot           0      -   144K  -
mypool/var@my_recursive_snapshot               0      -   616K  -
mypool/var/crash@my_recursive_snapshot         0      -   148K  -
mypool/var/log@my_recursive_snapshot           0      -   178K  -
mypool/var/mail@my_recursive_snapshot          0      -   144K  -
mypool/var/newname@new_snapshot_name           0      -  87.5K  -
mypool/var/newname@my_recursive_snapshot       0      -  87.5K  -
mypool/var/tmp@my_recursive_snapshot           0      -   152K  -</code></pre></div></div><div class=paragraph><p>Os snapshots não são mostrados por uma operação normal do <code>zfs list</code>. Para listar snapshots , a opção <code>-t snapshot</code> é anexado ao <code>zfs list</code>. A opção <code>-t all</code> exibe os sistemas de arquivos e snapshots.</p></div><div class=paragraph><p>Os snapshots não são montados diretamente, portanto, nenhum caminho é mostrado na coluna <code>MOUNTPOINT</code>. Não há menção ao espaço disponível em disco na coluna <code>AVAIL</code>, já que os snapshots não podem ser gravados após serem criados. Compare o snapshot com o conjunto de dados original a partir do qual foi criado:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs list -rt all mypool/usr/home</span>
NAME                                    USED  AVAIL  REFER  MOUNTPOINT
mypool/usr/home                         184K  93.2G   184K  /usr/home
mypool/usr/home@my_recursive_snapshot      0      -   184K  -</code></pre></div></div><div class=paragraph><p>A exibição do conjunto de dados e dos snapshots juntos revela como os snapshots funcionam no modo <a href=#zfs-term-cow>COW</a>. Eles salvam apenas as alterações (<em>deltas</em>) que foram feitas e não o conteúdo completo do sistema de arquivos novamente. Isso significa que os snapshots ocupam pouco espaço quando poucas alterações são feitas. O uso do espaço pode se tornar ainda mais aparente copiando um arquivo para o conjunto de dados e fazendo um segundo snapshots:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cp /etc/passwd /var/tmp</span>
<span class=c># zfs snapshot mypool/var/tmp@after_cp</span>
<span class=c># zfs list -rt all mypool/var/tmp</span>
NAME                                   USED  AVAIL  REFER  MOUNTPOINT
mypool/var/tmp                         206K  93.2G   118K  /var/tmp
mypool/var/tmp@my_recursive_snapshot    88K      -   152K  -
mypool/var/tmp@after_cp                   0      -   118K  -</code></pre></div></div><div class=paragraph><p>O segundo snapshot contém apenas as alterações feitas no conjunto de dados após a operação de cópia. Isso resulta numa enorme economia de espaço. Observe que o tamanho do snapshot <em>mypool/var/tmp@my_recursive_snapshot</em> também foi alterado na coluna <code>USED</code> para indicar as alterações entre ela mesma e o snapshot obtido posteriormente.</p></div></div><div class=sect4><h5 id=zfs-zfs-snapshot-diff>19.4.5.2. Comparando Snapshots<a class=anchor href=#zfs-zfs-snapshot-diff></a></h5><div class=paragraph><p>O ZFS fornece um comando interno para comparar as diferenças de conteúdo entre dois snapshots. Isso é útil quando muitos snapshots foram gerados com o passar do tempo e o usuário deseja ver como o sistema de arquivos mudou ao longo do tempo. Por exemplo, o <code>zfs diff</code> permite que um usuário localize o ultimo snapshot que ainda contém um arquivo que foi acidentalmente excluído. Fazer isso para os dois snapshots criados na seção anterior produz essa saída:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs list -rt all mypool/var/tmp</span>
NAME                                   USED  AVAIL  REFER  MOUNTPOINT
mypool/var/tmp                         206K  93.2G   118K  /var/tmp
mypool/var/tmp@my_recursive_snapshot    88K      -   152K  -
mypool/var/tmp@after_cp                   0      -   118K  -
<span class=c># zfs diff mypool/var/tmp@my_recursive_snapshot</span>
M       /var/tmp/
+       /var/tmp/passwd</code></pre></div></div><div class=paragraph><p>O comando lista as alterações entre o snapshot especificado (neste caso <code><em>mypool/var/tmp@my_recursive_snapshot</em></code>) e o sistema de arquivos ativo. A primeira coluna mostra o tipo de mudança:</p></div><table class="tableblock frame-all grid-all stretch informaltable"><col style=width:50%><col style=width:50%><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>+</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>O caminho ou arquivo foi adicionado.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>-</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>O caminho ou arquivo foi excluído.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>M</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>O caminho ou arquivo foi modificado.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>R</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>O caminho ou arquivo foi renomeado.</p></td></tr></tbody></table><div class=paragraph><p>Comparando a saída com a tabela, fica claro que o <span class=filename>passwd</span> foi adicionado após o snapshot <code><em>mypool/var/tmp@my_recursive_snapshot</em></code> ter sido criado. Isso também resultou em uma modificação no diretório pai montado em <code><em>/var/tmp</em></code>.</p></div><div class=paragraph><p>A comparação de dois snapshots é útil ao usar o recurso de replicação do ZFS para transferir um conjunto de dados para um host diferente para fins de backup.</p></div><div class=paragraph><p>Compare dois snapshots fornecendo o nome completo do conjunto de dados e o nome do snapshot de ambos os conjuntos de dados:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cp /var/tmp/passwd /var/tmp/passwd.copy</span>
<span class=c># zfs snapshot mypool/var/tmp@diff_snapshot</span>
<span class=c># zfs diff mypool/var/tmp@my_recursive_snapshot mypool/var/tmp@diff_snapshot</span>
M       /var/tmp/
+       /var/tmp/passwd
+       /var/tmp/passwd.copy
<span class=c># zfs diff mypool/var/tmp@my_recursive_snapshot mypool/var/tmp@after_cp</span>
M       /var/tmp/
+       /var/tmp/passwd</code></pre></div></div><div class=paragraph><p>Um administrador de backup pode comparar dois snapshots recebidos do host de envio e determinar as alterações reais no conjunto de dados. Consulte a seção <a href=#zfs-zfs-send>Replicação</a> para obter maiores informações.</p></div></div><div class=sect4><h5 id=zfs-zfs-snapshot-rollback>19.4.5.3. Reversão de um Snapshot<a class=anchor href=#zfs-zfs-snapshot-rollback></a></h5><div class=paragraph><p>Quando pelo menos um snapshot estiver disponível, ele poderá ser revertido a qualquer momento. Na maioria das vezes, esse é o caso quando o estado atual do conjunto de dados não é mais necessário e uma versão mais antiga é preferida. Cenários em que testes de desenvolvimento local deram errado, atualizações de sistemas com falhas que dificultam o funcionamento geral do sistema ou a necessidade de restaurar arquivos ou diretórios excluídos acidentalmente são ocorrências muito comuns. Felizmente, reverter um snapshot é tão fácil quanto digitar <code>zfs rollback <em>snapshotname</em></code>. Dependendo de quantas alterações estão envolvidas, a operação será concluída em um determinado período de tempo. Durante esse período, o conjunto de dados permanece sempre em um estado consistente, da mesma forma que um banco de dados em conformidade com os princípios do ACID ao realizar uma reversão. Isso está acontecendo enquanto o conjunto de dados está ativo e acessível, sem exigir um tempo de inatividade. Depois que o snapshot for revertido, o conjunto de dados terá o mesmo estado de quando o snapshot foi originalmente criado. Todos os outros dados nesse conjunto de dados que não faziam parte do snapshot são descartados. Criar um snapshot do estado atual do conjunto de dados antes de reverter para um anterior é uma boa ideia quando alguns dos dados são necessários mais tarde. Desta forma, o usuário pode alternar entre os snapshots sem perder dados que ainda são valiosos.</p></div><div class=paragraph><p>No primeiro exemplo, um snapshot é revertido por causa de uma operação descuidada com o comando <code>rm</code> que removeu muito mais dados do que o pretendido.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs list -rt all mypool/var/tmp</span>
NAME                                   USED  AVAIL  REFER  MOUNTPOINT
mypool/var/tmp                         262K  93.2G   120K  /var/tmp
mypool/var/tmp@my_recursive_snapshot    88K      -   152K  -
mypool/var/tmp@after_cp               53.5K      -   118K  -
mypool/var/tmp@diff_snapshot              0      -   120K  -
<span class=c># ls /var/tmp</span>
passwd          passwd.copy     vi.recover
<span class=c># rm /var/tmp/passwd*</span>
<span class=c># ls /var/tmp</span>
vi.recover</code></pre></div></div><div class=paragraph><p>Neste ponto, o usuário percebeu que muitos arquivos foram excluídos e os quer de volta. O ZFS fornece uma maneira fácil de recuperá-los usando reversões, mas somente quando os snapshots de dados importantes são executados regularmente. Para recuperar os arquivos e recomeçar a partir do último snapshot, emita o comando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs rollback mypool/var/tmp@diff_snapshot</span>
<span class=c># ls /var/tmp</span>
passwd          passwd.copy     vi.recover</code></pre></div></div><div class=paragraph><p>A operação de reversão restaurou o conjunto de dados para o estado do último snapshot. Também é possível reverter para um snapshot que foi gerado muito antes e que possui outros snapshots criados após ele. Ao tentar fazer isso, o ZFS irá emitir este aviso:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs list -rt snapshot mypool/var/tmp</span>
AME                                   USED  AVAIL  REFER  MOUNTPOINT
mypool/var/tmp@my_recursive_snapshot    88K      -   152K  -
mypool/var/tmp@after_cp               53.5K      -   118K  -
mypool/var/tmp@diff_snapshot              0      -   120K  -
<span class=c># zfs rollback mypool/var/tmp@my_recursive_snapshot</span>
cannot rollback to <span class=s1>&#39;mypool/var/tmp@my_recursive_snapshot&#39;</span>: more recent snapshots exist
use <span class=s1>&#39;-r&#39;</span> to force deletion of the following snapshots:
mypool/var/tmp@after_cp
mypool/var/tmp@diff_snapshot</code></pre></div></div><div class=paragraph><p>Esse aviso significa que existem snapshots entre o estado atual do conjunto de dados e o snapshot para o qual o usuário deseja retroceder. Para concluir a reversão, esses snapshots devem ser excluídos. O ZFS não pode rastrear todas as alterações entre estados diferentes do conjunto de dados, porque os snapshots são somente de leitura. O ZFS não excluirá os snapshots afetados, a menos que o usuário especifique a opção <code>-r</code> para indicar que essa é a ação desejada. Se essa for a intenção e as consequências da perda de todos os snapshots intermediários forem compreendidas, o comando poderá ser emitido:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs rollback -r mypool/var/tmp@my_recursive_snapshot</span>
<span class=c># zfs list -rt snapshot mypool/var/tmp</span>
NAME                                   USED  AVAIL  REFER  MOUNTPOINT
mypool/var/tmp@my_recursive_snapshot     8K      -   152K  -
<span class=c># ls /var/tmp</span>
vi.recover</code></pre></div></div><div class=paragraph><p>A saída de <code>zfs list -t snapshot</code> confirma que os snapshots intermediários foram removidos como resultado do <code>zfs rollback -r</code>.</p></div></div><div class=sect4><h5 id=zfs-zfs-snapshot-snapdir>19.4.5.4. Restaurando arquivos individuais a partir de Snapshots<a class=anchor href=#zfs-zfs-snapshot-snapdir></a></h5><div class=paragraph><p>Os snapshots são montados em um diretório oculto no conjunto de dados pai: <span class=filename>.zfs/snapshots/snapshotname</span>. Por padrão, esses diretórios não serão exibidos mesmo quando um <code>ls -a</code> padrão for executado. Embora o diretório não seja exibido, ele está lá e pode ser acessado como qualquer diretório normal. A propriedade denominada <code>snapdir</code> controla se esses diretórios ocultos aparecem em uma listagem de diretórios. Definir a propriedade como <code>visible</code> permite que eles apareçam na saída do <code>ls</code> e de outros comandos que lidam com o conteúdo do diretório.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs get snapdir mypool/var/tmp</span>
NAME            PROPERTY  VALUE    SOURCE
mypool/var/tmp  snapdir   hidden   default
<span class=c># ls -a /var/tmp</span>
<span class=nb>.</span>               ..              passwd          vi.recover
<span class=c># zfs set snapdir=visible mypool/var/tmp</span>
<span class=c># ls -a /var/tmp</span>
<span class=nb>.</span>               ..              .zfs            passwd          vi.recover</code></pre></div></div><div class=paragraph><p>Arquivos individuais podem ser facilmente restaurados para um estado anterior, copiando-os do snapshot de volta para o conjunto de dados pai. A estrutura de diretórios abaixo de <span class=filename>.zfs/snapshot</span> tem um diretório nomeado exatamente como os instantâneos criados anteriormente para facilitar sua identificação. No próximo exemplo, presume-se que um arquivo deve ser restaurado a partir do diretório <span class=filename>.zfs</span> oculto, copiando-o do snapshot que continha a versão mais recente do arquivo:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># rm /var/tmp/passwd</span>
<span class=c># ls -a /var/tmp</span>
<span class=nb>.</span>               ..              .zfs            vi.recover
<span class=c># ls /var/tmp/.zfs/snapshot</span>
after_cp                my_recursive_snapshot
<span class=c># ls /var/tmp/.zfs/snapshot/after_cp</span>
passwd          vi.recover
<span class=c># cp /var/tmp/.zfs/snapshot/after_cp/passwd /var/tmp</span></code></pre></div></div><div class=paragraph><p>Quando o comando <code>ls .zfs/snapshot</code> foi emitido, a propriedade <code>snapdir</code> pode ter sido definida como oculta, mas ainda seria possível listar o conteúdo desse diretório. Cabe ao administrador decidir se esses diretórios serão exibidos. É possível exibi-los para determinados conjuntos de dados e impedi-los para outros. Copiar arquivos ou diretórios deste diretório <span class=filename>.zfs/snapshot</span> oculto é bastante simples. Tentar o contrário, resulta neste erro:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cp /etc/rc.conf /var/tmp/.zfs/snapshot/after_cp/</span>
<span class=nb>cp</span>: /var/tmp/.zfs/snapshot/after_cp/rc.conf: Read-only file system</code></pre></div></div><div class=paragraph><p>O erro lembra ao usuário que os snapshots são somente de leitura e não podem ser alterados após a criação. Os arquivos não podem ser copiados para ou removidos dos diretórios de snapshot porque isso alteraria o estado do conjunto de dados que eles representam.</p></div><div class=paragraph><p>Os snapshots consomem espaço com base em quanto o sistema de arquivos pai foi alterado desde o momento da criação do snapshot. A propriedade <code>written</code> de um snapshot rastreia quanto espaço está sendo usado pelo snapshot.</p></div><div class=paragraph><p>Snapshots são destruídos e o espaço recuperado com o <code>zfs destroy <em>dataset</em>@<em>snapshot</em></code>. Adicionar <code>-r</code> remove recursivamente todos os snapshots com o mesmo nome sob o conjunto de dados pai. Adicionar <code>-n -v</code> ao comando exibe uma lista dos snapshots que seriam excluídos e uma estimativa de quanto espaço seria recuperado sem executar a operação de destruição real.</p></div></div></div><div class=sect3><h4 id=zfs-zfs-clones>19.4.6. Gerenciando Clones<a class=anchor href=#zfs-zfs-clones></a></h4><div class=paragraph><p>Um clone é uma cópia de um snapshot que é tratado mais como um conjunto de dados regular. Ao contrário de um snapshot, um clone não é somente de leitura, ele pode ser montado e pode ter suas próprias propriedades. Uma vez que um clone tenha sido criado usando <code>zfs clone</code>, o snapshot do qual ele foi criado não pode ser destruído. O relacionamento filho/pai entre o clone e o snapshot pode ser revertido usando <code>zfs promote</code>. Depois que um clone é promovido, o snapshot se torna um filho do clone, em vez de filho do conjunto de dados pai original. Isso mudará a maneira como o espaço é contabilizado, mas não mudará a quantidade de espaço consumida. O clone pode ser montado em qualquer ponto dentro da hierarquia do sistema de arquivos ZFS, não apenas abaixo do local original do snapshot.</p></div><div class=paragraph><p>Para demonstrar o recurso de clonagem, este conjunto de dados de exemplo é usado:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs list -rt all camino/home/joe</span>
NAME                    USED  AVAIL  REFER  MOUNTPOINT
camino/home/joe         108K   1.3G    87K  /usr/home/joe
camino/home/joe@plans    21K      -  85.5K  -
camino/home/joe@backup    0K      -    87K  -</code></pre></div></div><div class=paragraph><p>Um uso típico de clones é experimentar um conjunto de dados específico, mantendo o snapshot em volta, para o caso de algo dar errado. Como os snapshots não podem ser alterados, um clone de leitura/gravação de um snapshot é criado. Depois que o resultado desejado é alcançado no clone, o clone pode ser promovido para se tornar um conjunto de dados e o sistema de arquivos antigo é removido. Isso não é estritamente necessário, pois o clone e o conjunto de dados podem coexistir sem problemas.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs clone camino/home/joe@backup camino/home/joenew</span>
<span class=c># ls /usr/home/joe*</span>
/usr/home/joe:
backup.txz     plans.txt

/usr/home/joenew:
backup.txz     plans.txt
<span class=c># df -h /usr/home</span>
Filesystem          Size    Used   Avail Capacity  Mounted on
usr/home/joe        1.3G     31k    1.3G     0%    /usr/home/joe
usr/home/joenew     1.3G     31k    1.3G     0%    /usr/home/joenew</code></pre></div></div><div class=paragraph><p>Depois que um clone é criado, ele é uma cópia exata do estado em que o conjunto de dados estava quando o snapshot foi criado. O clone agora pode ser alterado independentemente de seu conjunto de dados de origem. A única conexão entre os dois é o snapshot. O ZFS registra essa conexão na propriedade <code>origin</code>. Uma vez que a dependência entre o snapshot e o clone foi removida promovendo-se o clone usando <code>zfs promote</code>, a <code>origem</code> do clone é removida, pois agora ele é um conjunto de dados independente. Este exemplo demonstra isso:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs get origin camino/home/joenew</span>
NAME                  PROPERTY  VALUE                     SOURCE
camino/home/joenew    origin    camino/home/joe@backup    -
<span class=c># zfs promote camino/home/joenew</span>
<span class=c># zfs get origin camino/home/joenew</span>
NAME                  PROPERTY  VALUE   SOURCE
camino/home/joenew    origin    -       -</code></pre></div></div><div class=paragraph><p>Depois de fazer algumas alterações, como copiar o <span class=filename>loader.conf</span> para o clone promovido, por exemplo, o diretório antigo torna-se obsoleto nesse caso. Em vez disso, o clone promovido pode substituí-lo. Isso pode ser conseguido por dois comandos consecutivos: <code>zfs destroy</code> no dataset antigo e <code>zfs rename</code> no clone para nomeá-lo como o conjunto de dados antigo (ele também poderia ter um nome totalmente diferente).</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cp /boot/defaults/loader.conf /usr/home/joenew</span>
<span class=c># zfs destroy -f camino/home/joe</span>
<span class=c># zfs rename camino/home/joenew camino/home/joe</span>
<span class=c># ls /usr/home/joe</span>
backup.txz     loader.conf     plans.txt
<span class=c># df -h /usr/home</span>
Filesystem          Size    Used   Avail Capacity  Mounted on
usr/home/joe        1.3G    128k    1.3G     0%    /usr/home/joe</code></pre></div></div><div class=paragraph><p>O snapshot clonado agora é tratado como um conjunto de dados comum. Ele contém todos os dados do snapshot original mais os arquivos que foram adicionados a ele como o <span class=filename>loader.conf</span>. Os clones podem ser usados em diferentes cenários para fornecer recursos úteis aos usuários do ZFS. Por exemplo, os jails podem ser disponibilizados como snapshots contendo diferentes conjuntos de aplicativos instalados. Os usuários podem clonar esses snapshots e adicionar seus próprios aplicativos como acharem melhor. Uma vez satisfeitos com as alterações, os clones podem ser promovidos a conjuntos de dados completos e fornecidos aos usuários finais para que trabalhem como se estivessem com um conjunto de dados real. Fornecer estes jails economiza tempo e sobrecarga administrativa.</p></div></div><div class=sect3><h4 id=zfs-zfs-send>19.4.7. Replicação<a class=anchor href=#zfs-zfs-send></a></h4><div class=paragraph><p>Manter os dados em um único pool e em um único local o expõe a riscos como roubo e desastres naturais ou humanos. Fazer backups regulares de todo o pool é vital. O ZFS fornece um recurso de serialização integrado que pode enviar uma representação de fluxo dos dados para a saída padrão. Usando essa técnica, é possível não apenas armazenar os dados em outro pool conectado ao sistema local, mas também enviá-los por uma rede para outro sistema. Os snapshots são a base para essa replicação (consulte a seção sobre <a href=#zfs-zfs-snapshot>snapshots ZFS</a>). Os comandos usados para replicar dados são <code>zfs send</code> e <code>zfs receive</code>.</p></div><div class=paragraph><p>Estes exemplos demonstram a replicação do ZFS com estes dois pools:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zpool list</span>
NAME    SIZE  ALLOC   FREE   CKPOINT  EXPANDSZ   FRAG   CAP  DEDUP  HEALTH  ALTROOT
backup  960M    77K   896M         -         -     0%    0%  1.00x  ONLINE  -
mypool  984M  43.7M   940M         -         -     0%    4%  1.00x  ONLINE  -</code></pre></div></div><div class=paragraph><p>O pool chamado <em>mypool</em> é o pool principal no qual os dados são gravados e lidos regularmente. Um segundo pool, <em>backup</em> é usado como standby, caso o pool principal fique indisponível. Observe que esse failover não é feito automaticamente pelo ZFS, mas deve ser feito manualmente por um administrador do sistema, quando necessário. Um snapshot é usado para fornecer uma versão consistente do sistema de arquivos a ser replicado. Depois que um snapshot de <em>mypool</em> tiver sido criado, ele poderá ser copiado para o pool <em>backup</em>. Apenas snapshots podem ser replicados. As alterações feitas desde o snapshot mais recente não serão incluídas.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs snapshot mypool@backup1</span>
<span class=c># zfs list -t snapshot</span>
NAME                    USED  AVAIL  REFER  MOUNTPOINT
mypool@backup1             0      -  43.6M  -</code></pre></div></div><div class=paragraph><p>Agora que existe um snapshot, o <code>zfs send</code> pode ser usado para criar um fluxo representando o conteúdo do snapshot. Esse fluxo pode ser armazenado como um arquivo ou recebido por outro pool. O fluxo é gravado na saída padrão, mas deve ser redirecionado para um arquivo ou canal ou um erro será produzido:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs send mypool@backup1</span>
Error: Stream can not be written to a terminal.
You must redirect standard output.</code></pre></div></div><div class=paragraph><p>Para fazer backup de um conjunto de dados com o <code>zfs send</code>, redirecione para um arquivo localizado no pool de backup montado. Assegure-se de que o pool tenha espaço livre suficiente para acomodar o tamanho do snapshot que está sendo enviado, o que significa todos os dados contidos no snapshot, não apenas as mudanças do snapshot anterior.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs send mypool@backup1 &gt; /backup/backup1</span>
<span class=c># zpool list</span>
NAME    SIZE  ALLOC   FREE   CKPOINT  EXPANDSZ   FRAG    CAP  DEDUP  HEALTH  ALTROOT
backup  960M  63.7M   896M         -         -     0%     6%  1.00x  ONLINE  -
mypool  984M  43.7M   940M         -         -     0%     4%  1.00x  ONLINE  -</code></pre></div></div><div class=paragraph><p>O <code>zfs send</code> transferiu todos os dados do snapshot chamado <em>backup1</em> para o pool chamado <em>backup</em>. Criar e enviar esses snapshots pode ser feito automaticamente com uma tarefa agendada do <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a>.</p></div><div class=paragraph><p>Em vez de armazenar os backups como arquivos compactados, o ZFS pode recebê-los como um sistema de arquivos ativo, permitindo que os dados de backup sejam acessados diretamente. Para obter os dados reais contidos nesses fluxos, o <code>zfs receive</code> é usado para transformar os fluxos novamente em arquivos e diretórios. O exemplo a seguir combina o <code>zfs send</code> e o <code>zfs receive</code> usando um canal para copiar os dados de um pool para outro. Os dados podem ser usados diretamente no pool de recebimento após a conclusão da transferência. Um conjunto de dados só pode ser replicado para um conjunto de dados vazio.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs snapshot mypool@replica1</span>
<span class=c># zfs send -v mypool@replica1 | zfs receive backup/mypool</span>
send from @ to mypool@replica1 estimated size is 50.1M
total estimated size is 50.1M
TIME        SENT   SNAPSHOT

<span class=c># zpool list</span>
NAME    SIZE  ALLOC   FREE   CKPOINT  EXPANDSZ   FRAG    CAP  DEDUP  HEALTH  ALTROOT
backup  960M  63.7M   896M         -         -     0%     6%  1.00x  ONLINE  -
mypool  984M  43.7M   940M         -         -     0%     4%  1.00x  ONLINE  -</code></pre></div></div><div class=sect4><h5 id=zfs-send-incremental>19.4.7.1. Backups Incrementais<a class=anchor href=#zfs-send-incremental></a></h5><div class=paragraph><p>O <code>zfs send</code> também pode determinar a diferença entre dois snapshots e enviar apenas as diferenças entre os dois. Isso economiza espaço em disco e tempo de transferência. Por exemplo:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs snapshot mypool@replica2</span>
<span class=c># zfs list -t snapshot</span>
NAME                    USED  AVAIL  REFER  MOUNTPOINT
mypool@replica1         5.72M      -  43.6M  -
mypool@replica2             0      -  44.1M  -
<span class=c># zpool list</span>
NAME    SIZE  ALLOC   FREE   CKPOINT  EXPANDSZ   FRAG   CAP  DEDUP  HEALTH  ALTROOT
backup  960M  61.7M   898M         -         -     0%    6%  1.00x  ONLINE  -
mypool  960M  50.2M   910M         -         -     0%    5%  1.00x  ONLINE  -</code></pre></div></div><div class=paragraph><p>Um segundo snapshot chamado <em>replica2</em> foi criado. Este segundo snapshot contém apenas as alterações feitas no sistema de arquivos entre o snapshot atual e o anterior, <em>replica1</em>. O uso do <code>zfs send -i</code> e a indicação do par de snapshots gera um fluxo de réplica incremental contendo apenas os dados que foram alterados. Isso só será bem-sucedido se o snapshot inicial já existir no lado do recebimento.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs send -v -i mypool@replica1 mypool@replica2 | zfs receive /backup/mypool</span>
send from @replica1 to mypool@replica2 estimated size is 5.02M
total estimated size is 5.02M
TIME        SENT   SNAPSHOT

<span class=c># zpool list</span>
NAME    SIZE  ALLOC   FREE   CKPOINT  EXPANDSZ   FRAG  CAP  DEDUP  HEALTH  ALTROOT
backup  960M  80.8M   879M         -         -     0%   8%  1.00x  ONLINE  -
mypool  960M  50.2M   910M         -         -     0%   5%  1.00x  ONLINE  -

<span class=c># zfs list</span>
NAME                         USED  AVAIL  REFER  MOUNTPOINT
backup                      55.4M   240G   152K  /backup
backup/mypool               55.3M   240G  55.2M  /backup/mypool
mypool                      55.6M  11.6G  55.0M  /mypool

<span class=c># zfs list -t snapshot</span>
NAME                                         USED  AVAIL  REFER  MOUNTPOINT
backup/mypool@replica1                       104K      -  50.2M  -
backup/mypool@replica2                          0      -  55.2M  -
mypool@replica1                             29.9K      -  50.0M  -
mypool@replica2                                 0      -  55.0M  -</code></pre></div></div><div class=paragraph><p>O fluxo incremental foi transferido com sucesso. Apenas os dados que foram alterados foram replicados, em vez da totalidade da <em>replica1</em>. Somente as diferenças foram enviadas, o que levou muito menos tempo para transferir e economizou espaço em disco por não copiar o pool completo novamente. Isso é útil quando se precisa confiar em redes lentas ou quando os custos por byte transferido devem ser considerados.</p></div><div class=paragraph><p>Um novo sistema de arquivos, <em>backup/mypool</em>, está disponível com todos os arquivos e dados do pool <em>mypool</em>. Se <code>-P</code> for especificado, as propriedades do dataset serão copiadas, incluindo configurações de compactação, cotas e pontos de montagem. Quando <code>-R</code> é especificado, todos os conjuntos de dados filho do dataset indicado serão copiados, juntamente com todas as suas propriedades. O envio e o recebimento podem ser automatizados para que backups regulares sejam criados no segundo pool.</p></div></div><div class=sect4><h5 id=zfs-send-ssh>19.4.7.2. Envio de backups criptografados pelo SSH<a class=anchor href=#zfs-send-ssh></a></h5><div class=paragraph><p>O envio de fluxos pela rede é uma boa maneira de manter um backup remoto, mas apresenta uma desvantagem. Os dados enviados pelo link de rede não são criptografados, permitindo que qualquer pessoa intercepte e transforme os fluxos de volta em dados sem o conhecimento do usuário remetente. Isso é indesejável, especialmente ao enviar os fluxos pela Internet para um host remoto. O SSH pode ser usado para criptografar com segurança os dados enviados por uma conexão de rede. Como o ZFS requer apenas que o fluxo seja redirecionado da saída padrão, é relativamente fácil transmiti-lo através do SSH. Para manter o conteúdo do sistema de arquivos criptografado em trânsito e no sistema remoto, considere o uso do <a href=https://wiki.freebsd.org/PEFS>PEFS</a>.</p></div><div class=paragraph><p>Algumas configurações e precauções de segurança devem ser concluídas primeiro. Apenas as etapas necessárias para a operação do <code>zfs send</code> são mostradas aqui. Para mais informações sobre o SSH, consulte <a href=./#openssh>OpenSSH</a>.</p></div><div class=paragraph><p>Essa configuração é necessária:</p></div><div class=ulist><ul><li><p>Acesso SSH sem senha entre o host de envio e recebimento usando chaves SSH</p></li><li><p>Normalmente, os privilégios do usuário <code>root</code> são necessários para enviar e receber fluxos. Isso requer o login no sistema de recebimento como <code>root</code>. No entanto, o login como <code>root</code> vem desabilitado por padrão por motivos de segurança. O sistema <a href=#zfs-zfs-allow>ZFS Delegation</a> pode ser usado para permitir que um usuário não <code>root</code> em cada sistema execute as respectivas operações de envio e recebimento.</p></li><li><p>No sistema de envio:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs allow -u someuser send,snapshot mypool</span></code></pre></div></div></li><li><p>Para montar o pool, o usuário não privilegiado deve ser o dono do diretório e os usuários regulares devem poder montar sistemas de arquivos. No sistema de recebimento:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl vfs.usermount=1</span>
vfs.usermount: 0 -&gt; 1
<span class=c># echo vfs.usermount=1 &gt;&gt; /etc/sysctl.conf</span>
<span class=c># zfs create recvpool/backup</span>
<span class=c># zfs allow -u someuser create,mount,receive recvpool/backup</span>
<span class=c># chown someuser /recvpool/backup</span></code></pre></div></div></li></ul></div><div class=paragraph><p>O usuário sem privilégios agora tem a capacidade de receber e montar conjuntos de dados, e o conjunto de dados <em>home</em> pode ser replicado para o sistema remoto:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% zfs snapshot <span class=nt>-r</span> mypool/home@monday
% zfs send <span class=nt>-R</span> mypool/home@monday | ssh someuser@backuphost zfs recv <span class=nt>-dvu</span> recvpool/backup</code></pre></div></div><div class=paragraph><p>Um snapshot recursivo chamado <em>monday</em> é composto do conjunto de dados do sistema de arquivos <em>home</em> que reside no pool <em>mypool</em>. Em seguida, ele é enviado com o <code>zfs send -R</code> para incluir o conjunto de dados, todos os conjuntos de dados filho, snapshots, clones e configurações no fluxo. A saída é canalizada para o <code>zfs receive</code> em espera no host remoto <em>backuphost</em> através do SSH. Recomenda-se a utilização de um nome de domínio totalmente qualificado ou do endereço IP. A máquina receptora grava os dados no conjunto de dados <em>backup</em> no pool <em>recvpool</em>. Adicionar <code>-d</code> ao <code>zfs recv</code> sobrescreve o nome do pool no lado de recebimento com o nome do snapshot. A opção <code>-u</code> faz com que os sistemas de arquivos não sejam montados no lado do recebimento. Quando <code>-v</code> é incluído, mais detalhes sobre a transferência são mostrados, incluindo o tempo decorrido e a quantidade de dados transferidos.</p></div></div></div><div class=sect3><h4 id=zfs-zfs-quota>19.4.8. Cotas para Datasets, Usuários e Grupos<a class=anchor href=#zfs-zfs-quota></a></h4><div class=paragraph><p><a href=#zfs-term-quota>As cotas para dataset</a> são usadas para restringir a quantidade de espaço que pode ser consumida por um determinado conjunto de dados. As <a href=#zfs-term-refquota>cotas de referência</a> funcionam basicamente da mesma maneira, mas contam apenas o espaço usado pelo próprio conjunto de dados, excluindo snapshots e conjuntos de dados filho. Da mesma forma, as cotas para <a href=#zfs-term-userquota>usuário</a> e para <a href=#zfs-term-groupquota>grupo</a> podem ser usadas para impedir que usuários ou grupos usem todo o espaço do pool ou do conjunto de dados.</p></div><div class=paragraph><p>Os exemplos a seguir pressupõem que os usuários já existam no sistema. Antes de adicionar um usuário ao sistema, certifique-se de criar seu dataset antes e defina o seu <code>mountpoint</code> para <code>/home/<em>bob</em></code>. Em seguida, crie o usuário e faça com que o diretório inicial aponte para a localização do <code>mountpoint</code> do dataset. Isso definirá corretamente as permissões de proprietário e grupo sem obscurecer nenhum caminho de diretório inicial pré-existente que possa existir.</p></div><div class=paragraph><p>Para impor uma cota de dataser de 10 GB para o <span class=filename>storage/home/bob</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs set quota=10G storage/home/bob</span></code></pre></div></div><div class=paragraph><p>Para impor uma cota de referência de 10 GB para <span class=filename>storage/home/bob</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs set refquota=10G storage/home/bob</span></code></pre></div></div><div class=paragraph><p>Para remover uma cota de 10 GB do <span class=filename>storage/home/bob</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs set quota=none storage/home/bob</span></code></pre></div></div><div class=paragraph><p>O formato geral é <code>userquota@<em>user</em>=<em>size</em></code> e o nome do usuário deve estar em um destes formatos:</p></div><div class=ulist><ul><li><p>nome compatível com o POSIX, como <em>joe</em>.</p></li><li><p>ID numérico POSIX, como <em>789</em>.</p></li><li><p>nome SID, como <em>joe.bloggs@example.com</em>.</p></li><li><p>ID numérico SID , como <em>S-1-123-456-789</em>.</p></li></ul></div><div class=paragraph><p>Por exemplo, para impor uma cota de usuário de 50 GB para o usuário chamado <em>joe</em>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs set userquota@joe=50G</span></code></pre></div></div><div class=paragraph><p>Para remover qualquer cota:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs set userquota@joe=none</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>As propriedades da cota do usuário não são exibidas pelo <code>zfs get all</code>. Os usuários que não são o <code>root</code> só podem ver suas próprias cotas, a menos que tenham recebido o privilégio <code>userquota</code>. Os usuários com esse privilégio podem visualizar e definir a cota de todos.</p></div></td></tr></tbody></table></div><div class=paragraph><p>O formato geral para definir uma cota de grupo é: <code>groupquota@<em>group</em>=<em>size</em></code>.</p></div><div class=paragraph><p>Para definir a cota do grupo <em>firstgroup</em> para 50 GB, use:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs set groupquota@firstgroup=50G</span></code></pre></div></div><div class=paragraph><p>Para remover a cota do grupo <em>firstgroup</em> ou para certificar-se de que uma não está definida, use:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs set groupquota@firstgroup=none</span></code></pre></div></div><div class=paragraph><p>Assim como a propriedade de cota do usuário, os usuários que não são <code>root</code> só podem ver as cotas associadas aos grupos aos quais eles pertencem. No entanto, o <code>root</code> ou um usuário com o privilégio <code>groupquota</code> pode visualizar e definir todas as cotas para todos os grupos.</p></div><div class=paragraph><p>Para exibir a quantidade de espaço utilizada por cada usuário em um sistema de arquivos ou snapshot junto com quaisquer cotas, use <code>zfs userspace</code>. Para informações de grupo, use <code>zfs groupspace</code>. Para obter maiores informações sobre opções suportadas ou sobre como exibir apenas opções específicas, consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=zfs&amp;sektion=1&amp;format=html">zfs(1)</a>.</p></div><div class=paragraph><p>Usuários com privilégios suficientes, e o <code>root</code>, podem listar a cota para <span class=filename>storage/home/bob</span> usando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs get quota storage/home/bob</span></code></pre></div></div></div><div class=sect3><h4 id=zfs-zfs-reservation>19.4.9. Reservas<a class=anchor href=#zfs-zfs-reservation></a></h4><div class=paragraph><p>As <a href=#zfs-term-reservation>reservas</a> garantem uma quantidade mínima de espaço sempre disponível em um conjunto de dados. O espaço reservado não estará disponível para nenhum outro conjunto de dados. Esse recurso pode ser especialmente útil para garantir que haja espaço livre disponível para um conjunto de dados ou arquivos de log importantes.</p></div><div class=paragraph><p>O formato geral da propriedade <code>reservation</code> é <code>reservation=<em>size</em></code>, portanto, para definir uma reserva de 10 GB em <span class=filename>storage/home/bob</span>, use:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs set reservation=10G storage/home/bob</span></code></pre></div></div><div class=paragraph><p>Para cancelar qualquer reserva:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs set reservation=none storage/home/bob</span></code></pre></div></div><div class=paragraph><p>O mesmo princípio pode ser aplicado à propriedade <code>refreservation</code> para definir uma <a href=#zfs-term-refreservation>Reserva de Referência</a>, com o formato geral <code>refreservation=<em>size</em></code>.</p></div><div class=paragraph><p>Este comando mostra todas as reservas ou atualizações existentes no <span class=filename>storage/home/bob</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs get reservation storage/home/bob</span>
<span class=c># zfs get refreservation storage/home/bob</span></code></pre></div></div></div><div class=sect3><h4 id=zfs-zfs-compression>19.4.10. Compressão<a class=anchor href=#zfs-zfs-compression></a></h4><div class=paragraph><p>O ZFS fornece compactação transparente. A compactação de dados no nível do bloco a medida que ele é escrito, não apenas economiza espaço, mas também pode aumentar a performance do disco. Se os dados forem compactados em 25%, mas os dados compactados forem gravados no disco na mesma taxa da versão descompactada, resulta em uma velocidade efetiva de gravação de 125%. A compactação também pode ser uma ótima alternativa para <a href=#zfs-zfs-deduplication>Deduplicação</a> porque não requer memória adicional.</p></div><div class=paragraph><p>O ZFS oferece vários algoritmos de compactação diferentes, cada um com diferentes compensações. Com a introdução da compactação LZ4 no ZFS v5000, é possível ativar a compactação para todo o pool sem o trade-off de desempenho de outros algoritmos. A maior vantagem do LZ4 é o recurso <em>early abort</em>. Se o LZ4 não atingir pelo menos 12,5% de compactação na primeira parte dos dados, o bloco será gravado descompactado para evitar o desperdício de ciclos da CPU que tentam compactar dados já compactados ou não compactáveis. Para obter detalhes sobre os diferentes algoritmos de compactação disponíveis no ZFS, consulte a entrada <a href=#zfs-term-compression>Compactação</a> na seção de terminologia.</p></div><div class=paragraph><p>O administrador pode monitorar a eficácia da compactação usando várias propriedades do conjunto de dados.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs get used,compressratio,compression,logicalused mypool/compressed_dataset</span>
NAME        PROPERTY          VALUE     SOURCE
mypool/compressed_dataset  used              449G      -
mypool/compressed_dataset  compressratio     1.11x     -
mypool/compressed_dataset  compression       lz4       <span class=nb>local
</span>mypool/compressed_dataset  logicalused       496G      -</code></pre></div></div><div class=paragraph><p>O conjunto de dados está usando atualmente 449 GB de espaço (a propriedade used). Sem compressão, seriam necessários 496 GB de espaço (a propriedade <code>logicalused</code>). Isso resulta na taxa de compactação de 1,11: 1.</p></div><div class=paragraph><p>A compactação pode ter um efeito colateral inesperado quando combinada com <a href=#zfs-term-userquota>cotas de usuário</a>. As cotas de usuários restringem a quantidade de espaço que um usuário pode consumir em um conjunto de dados, mas as medidas são baseadas em quanto espaço é usado <em>após a compactação</em>. Portanto, se um usuário tiver uma cota de 10 GB e gravar 10 GB de dados compactáveis, eles ainda poderão armazenar dados adicionais. Se, posteriormente, atualizarem um arquivo, digamos um banco de dados, com dados mais ou menos compactáveis, a quantidade de espaço disponível para eles será alterada. Isso pode resultar na situação ímpar em que um usuário não aumentou a quantidade real de dados (a propriedade <code>logicalused</code>), mas a alteração na compactação fez com que eles atingissem seu limite de cota.</p></div><div class=paragraph><p>A compactação pode ter uma interação inesperada semelhante com backups. Muitas vezes, as cotas são usadas para limitar a quantidade de dados que podem ser armazenados para garantir que haja espaço de backup suficiente disponível. No entanto, uma vez que as cotas não consideram a compactação, mais dados podem ser gravados do que caberia com os backups descompactados.</p></div></div><div class=sect3><h4 id=zfs-zfs-deduplication>19.4.11. Desduplicação<a class=anchor href=#zfs-zfs-deduplication></a></h4><div class=paragraph><p>Quando ativado, a <a href=#zfs-term-deduplication>deduplicação</a> usa o checksum de cada bloco para detectar blocos duplicados. Quando um novo bloco é uma duplicata de um bloco existente, o ZFS grava uma referência adicional aos dados existentes, em vez de todo o bloco duplicado. Uma enorme economia de espaço é possível se os dados contiverem muitos arquivos duplicados ou informações repetidas. Esteja avisado: a desduplicação requer uma quantidade extremamente grande de memória, e a maior parte da economia de espaço pode ser obtida sem o custo extra, permitindo a compactação.</p></div><div class=paragraph><p>Para ativar a deduplicação, defina a propriedade <code>dedup</code> no pool de destino:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs set dedup=on pool</span></code></pre></div></div><div class=paragraph><p>Somente novos dados sendo gravados no pool serão desduplicados. Os dados que já foram gravados no pool não serão desduplicados simplesmente ativando essa opção. Um pool com uma propriedade de desduplicação ativada recentemente será semelhante a este exemplo:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zpool list</span>
NAME  SIZE ALLOC  FREE   CKPOINT  EXPANDSZ   FRAG   CAP   DEDUP   HEALTH   ALTROOT
pool 2.84G 2.19M 2.83G         -         -     0%    0%   1.00x   ONLINE   -</code></pre></div></div><div class=paragraph><p>A coluna <code>DEDUP</code> mostra a taxa real de deduplicação para o pool. Um valor de <code>1.00x</code> mostra que os dados ainda não foram desduplicados. No próximo exemplo, a árvore de ports é copiada três vezes em diretórios diferentes no pool desduplicado criado acima.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># for d in dir1 dir2 dir3; do</span>
<span class=o>&gt;</span> <span class=nb>mkdir</span> <span class=nv>$d</span> <span class=o>&amp;&amp;</span> <span class=nb>cp</span> <span class=nt>-R</span> /usr/ports <span class=nv>$d</span> &amp;
<span class=o>&gt;</span> <span class=k>done</span></code></pre></div></div><div class=paragraph><p>Dados redundantes são detectados e desduplicados:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zpool list</span>
NAME SIZE  ALLOC  FREE   CKPOINT  EXPANDSZ   FRAG  CAP   DEDUP   HEALTH   ALTROOT
pool 2.84G 20.9M 2.82G         -         -     0%   0%   3.00x   ONLINE   -</code></pre></div></div><div class=paragraph><p>A coluna <code>DEDUP</code> mostra um fator de <code>3.00x</code>. Várias cópias dos dados da árvore de ports foram detectadas e desduplicadas, usando apenas um terço do espaço. O potencial de economia de espaço pode ser enorme, mas com o custo de ter memória suficiente para rastrear os blocos desduplicados.</p></div><div class=paragraph><p>A desduplicação nem sempre é benéfica, especialmente quando os dados em um pool não são redundantes. O ZFS pode mostrar uma possível economia de espaço ao simular a desduplicação em um pool existente:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zdb -S pool</span>
Simulated DDT histogram:

bucket              allocated                       referenced
______   ______________________________   ______________________________
refcnt   blocks   LSIZE   PSIZE   DSIZE   blocks   LSIZE   PSIZE   DSIZE
<span class=nt>------</span>   <span class=nt>------</span>   <span class=nt>-----</span>   <span class=nt>-----</span>   <span class=nt>-----</span>   <span class=nt>------</span>   <span class=nt>-----</span>   <span class=nt>-----</span>   <span class=nt>-----</span>
     1    2.58M    289G    264G    264G    2.58M    289G    264G    264G
     2     206K   12.6G   10.4G   10.4G     430K   26.4G   21.6G   21.6G
     4    37.6K    692M    276M    276M     170K   3.04G   1.26G   1.26G
     8    2.18K   45.2M   19.4M   19.4M    20.0K    425M    176M    176M
    16      174   2.83M   1.20M   1.20M    3.33K   48.4M   20.4M   20.4M
    32       40   2.17M    222K    222K    1.70K   97.2M   9.91M   9.91M
    64        9     56K   10.5K   10.5K      865   4.96M    948K    948K
   128        2   9.50K      2K      2K      419   2.11M    438K    438K
   256        5   61.5K     12K     12K    1.90K   23.0M   4.47M   4.47M
    1K        2      1K      1K      1K    2.98K   1.49M   1.49M   1.49M
 Total    2.82M    303G    275G    275G    3.20M    319G    287G    287G

dedup <span class=o>=</span> 1.05, compress <span class=o>=</span> 1.11, copies <span class=o>=</span> 1.00, dedup <span class=k>*</span> compress / copies <span class=o>=</span> 1.16</code></pre></div></div><div class=paragraph><p>Depois que o <code>zdb -S</code> termina de analisar o pool, ele mostra a taxa de redução de espaço que seria obtida ativando a deduplicação. Nesse caso, <code>1.16</code> é uma taxa de economia de espaço muito baixa e que poderia ser obtida apenas com a compactação. A ativação da deduplicação neste pool não salvaria uma quantidade significativa de espaço e não vale a quantidade de memória necessária para ativar a deduplicação. Usando a fórmula <em>ratio = dedup * compress / copies</em>, os administradores do sistema podem planejar a alocação de armazenamento, decidindo se a carga de trabalho conterá blocos duplicados suficientes para justificar os requisitos de memória. Se os dados forem razoavelmente compactáveis, a economia de espaço poderá ser muito boa. Recomenda-se ativar a compactação primeiro pois ela também pode aumentar significativamente a performance do sistema. Ative a deduplicação somente nos casos em que a economia adicional será considerável e se houver memória suficiente para o <a href=#zfs-term-deduplication>DDT</a>.</p></div></div><div class=sect3><h4 id=zfs-zfs-jail>19.4.12. ZFS e Jails<a class=anchor href=#zfs-zfs-jail></a></h4><div class=paragraph><p>O <code>zfs jail</code> e a propriedade <code>jailed</code> correspondente são usadas para delegar um conjunto de dados ZFS para uma <a href=./#jails>Jail</a>. O <code>zfs jail <em>jailid</em></code> anexa um dataset à jail especificada, e o <code>zfs unjail</code> o desanexa. Para que o conjunto de dados seja controlado de dentro de um jail, a propriedade <code>jailed</code> deve ser configurada. Depois que um conjunto de dados é anexado a um jail, ele não pode mais ser montado no host porque ele poderá ter pontos de montagem que comprometam a segurança do host.</p></div></div></div><div class=sect2><h3 id=zfs-zfs-allow>19.5. Administração Delegada<a class=anchor href=#zfs-zfs-allow></a></h3><div class=paragraph><p>Um sistema abrangente de delegação de permissão permite que usuários sem privilégios realizem funções de administração do ZFS. Por exemplo, se o diretório pessoal de cada usuário for um conjunto de dados, os usuários poderão receber permissão para criar e destruir snapshots de seus diretórios pessoais. Um usuário de backup pode receber permissão para usar recursos de replicação. Um script de estatísticas de uso pode ter permissão para ser executado com acesso apenas aos dados de utilização de espaço para todos os usuários. É ainda possível delegar a capacidade de delegar permissões. A delegação de permissão é possível para cada subcomando e para a maioria das propriedades.</p></div><div class=sect3><h4 id=zfs-zfs-allow-create>19.5.1. Delegando a criação de conjunto de dados<a class=anchor href=#zfs-zfs-allow-create></a></h4><div class=paragraph><p>O <code>zfs allow <em>someuser</em> create <em>mydataset</em></code> concede ao usuário especificado permissão para criar conjuntos de dados filho sob o conjunto de dados pai selecionado. Há uma ressalva: criar um novo conjunto de dados envolve montá-lo. Isso requer configurar o <code>vfs.usermount</code> <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> do FreeBSD para <code>1</code> para permitir que usuários não-root montem um sistema de arquivos. Existe outra restrição que visa impedir o abuso: os usuários que não são <code>root</code> devem ser donos do ponto de montagem onde o sistema de arquivos deve ser montado.</p></div></div><div class=sect3><h4 id=zfs-zfs-allow-allow>19.5.2. Delegando a delegação de permissão<a class=anchor href=#zfs-zfs-allow-allow></a></h4><div class=paragraph><p>O <code>zfs allow <em>someuser</em> allow <em>mydataset</em></code> permite ao usuário especificado atribuir qualquer permissão que tenha no conjunto de dados de destino, ou nos seus filhos, para outros usuários . Se um usuário tiver a permissão <code>snapshot</code> e a permissão <code>allow</code>, esse usuário poderá conceder a permissão <code>snapshot</code> para outros usuários.</p></div></div></div><div class=sect2><h3 id=zfs-advanced>19.6. Tópicos Avançados<a class=anchor href=#zfs-advanced></a></h3><div class=sect3><h4 id=zfs-advanced-tuning>19.6.1. Otimizações<a class=anchor href=#zfs-advanced-tuning></a></h4><div class=paragraph><p>Existem vários parametros que podem ser ajustados para tornar o ZFS melhor para diferentes cargas de trabalho.</p></div><div class=ulist><ul><li><p><a id=zfs-advanced-tuning-arc_max></a><code><em>vfs.zfs.arc_max</em></code> - Tamanho máximo do <a href=#zfs-term-arc>ARC</a>. O padrão é toda a memória RAM menos 1 GB, ou metade da RAM, o que for maior. No entanto, um valor menor deve ser usado se o sistema estiver executando quaisquer outros daemons ou processos que possam requerer memória. Este valor pode ser ajustado em tempo de execução com <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> e pode ser configurado no <span class=filename>/boot/loader.conf</span> ou <span class=filename>/etc/sysctl.conf</span>.</p></li><li><p><a id=zfs-advanced-tuning-arc_meta_limit></a><code><em>vfs.zfs.arc_meta_limit</em></code> - Limita a parte do <a href=#zfs-term-arc>ARC</a> que pode ser usado para armazenar metadados. O padrão é um quarto de <code>vfs.zfs.arc_max</code>. Aumentar esse valor melhorará o desempenho se a carga de trabalho envolver operações em um grande número de arquivos e diretórios ou operações de metadados frequentes, ao custo de caber menos dados de arquivo no <a href=#zfs-term-arc>ARC</a>. Este valor pode ser ajustado em tempo de execução com <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> e pode ser configurado em <span class=filename>/boot/loader.conf</span> ou <span class=filename>/etc/sysctl.conf</span>.</p></li><li><p><a id=zfs-advanced-tuning-arc_min></a><code><em>vfs.zfs.arc_min</em></code> - Tamanho mínimo do <a href=#zfs-term-arc>ARC</a>. O padrão é metade de <code>vfs.zfs.arc_meta_limit</code>. Ajuste esse valor para evitar que outros aplicativos pressionem o <a href=#zfs-term-arc>ARC</a> inteiro. Este valor pode ser ajustado em tempo de execução com <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> e pode ser configurado em <span class=filename>/boot/loader.conf</span> ou <span class=filename>/etc/sysctl.conf</span>.</p></li><li><p><a id=zfs-advanced-tuning-vdev-cache-size></a><code><em>vfs.zfs.vdev.cache.size</em></code> - Uma quantidade pré-alocada de memória reservada como um cache para cada dispositivo no pool. A quantidade total de memória usada será esse valor multiplicado pelo número de dispositivos. Este valor só pode ser ajustado no momento da inicialização e é definido em <span class=filename>/boot/loader.conf</span>.</p></li><li><p><a id=zfs-advanced-tuning-min-auto-ashift></a><code><em>vfs.zfs.min_auto_ashift</em></code> - Mínimo <code>ashift</code> (tamanho do setor) que será usado automaticamente no momento da criação do pool. O valor é uma potência de dois. O valor padrão de <code>9</code> representa <code>2^9 = 512</code>, um tamanho de setor de 512 bytes. Para evitar <em>amplificação de escrita</em> e para obter o melhor desempenho, defina esse valor para o maior tamanho de setor usado por um dispositivo no pool.</p><div class=paragraph><p>Muitas unidades possuem setores de 4 KB. Usar o <code>ashift</code> padrão <code>9</code> com esses drives resulta em amplificação de gravação nesses dispositivos. Os dados que podem estar contidos em uma única gravação de 4 KB devem, em vez disso, ser gravados em oito gravações de 512 bytes. O ZFS tenta ler o tamanho do setor nativo de todos os dispositivos ao criar um pool, mas muitas unidades com setores de 4 KB relatam que seus setores têm 512 bytes para compatibilidade. Configure o <code>vfs.zfs.min_auto_ashift</code> para <code>12</code> (<code>2^12=4096</code>) antes de criar um pool irá forçar o ZFS a usar blocos de 4 KB para melhor desempenho nessas unidades.</p></div><div class=paragraph><p>Forçar blocos de 4 KB também é útil em pools em que as atualizações de disco são planejadas. Os discos futuros provavelmente usarão setores de 4 KB, e os valores de <code>ashift</code> não poderão ser alterados depois que um pool for criado.</p></div><div class=paragraph><p>Em alguns casos específicos, o menor tamanho de bloco de 512 bytes pode ser preferível. Quando usado com discos de 512 bytes para bancos de dados, ou como armazenamento para máquinas virtuais, menos dados são transferidos durante pequenas leituras aleatórias. Isso pode fornecer melhor desempenho, especialmente ao usar um tamanho de registro ZFS menor.</p></div></li><li><p><a id=zfs-advanced-tuning-prefetch_disable></a><code><em>vfs.zfs.prefetch_disable</em></code> - Desabilita a pré-busca. Um valor de <code>0</code> está ativado e <code>1</code> está desativado. O padrão é <code>0</code>, a menos que o sistema tenha menos de 4 GB de RAM. A pré-busca funciona lendo blocos maiores do que os que foram solicitados no <a href=#zfs-term-arc>ARC</a> na esperança de que os dados sejam necessários em breve. Se a carga de trabalho tiver um grande número de leituras aleatórias, a desativação da pré-busca poderá melhorar o desempenho reduzindo leituras desnecessárias. Este valor pode ser ajustado a qualquer momento com <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a>.</p></li><li><p><a id=zfs-advanced-tuning-vdev-trim_on_init></a><code><em>vfs.zfs.vdev.trim_on_init</em></code> - Controla se os novos dispositivos adicionados ao pool têm o comando <code>TRIM</code> executado neles. Isso garante o melhor desempenho e a longevidade dos SSDs, mas leva um tempo extra. Se o dispositivo já tiver sido apagado de forma segura, a desativação dessa configuração tornará o acréscimo do novo dispositivo mais rápido. Este valor pode ser ajustado a qualquer momento com <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a>.</p></li><li><p><a id=zfs-advanced-tuning-vdev-max_pending></a><code><em>vfs.zfs.vdev.max_pending</em></code> - Limita o número de solicitações de I/O pendentes por dispositivo. Um valor mais alto manterá a fila de comandos do dispositivo cheia e poderá resultar em maior rendimento. Um valor menor reduzirá a latência. Este valor pode ser ajustado a qualquer momento com o <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a>.</p></li><li><p><a id=zfs-advanced-tuning-top_maxinflight></a><code><em>vfs.zfs.top_maxinflight</em></code> - Número máximo de I/Os pendentes por <a href=#zfs-term-vdev>vdev</a> de nível superior. Limita a profundidade da fila de comandos para evitar alta latência. O limite é por vdev de nível superior, o que significa que o limite se aplica a cada <a href=#zfs-term-vdev-mirror>Mirror</a>, <a href=#zfs-term-vdev-raidz>RAID-Z</a>, ou outro vdev independentemente. Este valor pode ser ajustado a qualquer momento com <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a>.</p></li><li><p><a id=zfs-advanced-tuning-l2arc_write_max></a><code><em>vfs.zfs.l2arc_write_max</em></code> - Limita a quantidade de dados gravados no <a href=#zfs-term-l2arc>L2ARC</a> por segundo. Este ajuste foi projetado para estender a longevidade de SSDs limitando a quantidade de dados gravados no dispositivo. Este valor pode ser ajustado a qualquer momento com <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a>.</p></li><li><p><a id=zfs-advanced-tuning-l2arc_write_boost></a><code><em>vfs.zfs.l2arc_write_boost</em></code> - O valor deste ajuste é adicionado ao <a href=#zfs-advanced-tuning-l2arc_write_max><code>vfs.zfs.l2arc_write_max</code></a> e aumenta a velocidade de gravação para o SSD até que o primeiro bloco seja removido do <a href=#zfs-term-l2arc>L2ARC</a>. Esta "Turbo Warmup Phase" é projetada para reduzir a perda de desempenho de um <a href=#zfs-term-l2arc>L2ARC</a> vazio após uma reinicialização. Este valor pode ser ajustado a qualquer momento com <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a>.</p></li><li><p><a id=zfs-advanced-tuning-scrub_delay></a><code><em>vfs.zfs.scrub_delay</em></code> - Número de ticks a serem atrasados entre cada operação de I/O durante um <a href=#zfs-term-scrub><code>scrub</code></a>. Para garantir que um <code>scrub</code> não interfira com a operação normal do pool, se qualquer outra I/O estiver acontecendo, o <code>scrub</code> será atrasado entre cada comando. Esse valor controla o limite no total de IOPS (I/Os por segundo) gerados pelo <code>scrub</code>. A granularidade da configuração é determinada pelo valor de <code>kern.hz</code>, cujo padrão é de 1.000 ticks por segundo. Essa configuração pode ser alterada, resultando em um limite efetivo de IOPS diferente. O valor padrão é <code>4</code>, resultando em um limite de: 1000 ticks/seg/4 = 250 IOPS. Usar um valor de <em>20</em> daria um limite de: 1000 ticks/seg/20 = 50 IOPS. A velocidade de <code>scrub</code> é limitada apenas quando houver atividade recente no pool, conforme determinado por <a href=#zfs-advanced-tuning-scan_idle><code>vfs.zfs.scan_idle</code></a>. Esse valor pode ser ajustado a qualquer momento com <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a>.</p></li><li><p><a id=zfs-advanced-tuning-resilver_delay></a><code><em>vfs.zfs.resilver_delay</em></code> - Número de milissegundos de atraso inserido entre cada I/O durante um <a href=#zfs-term-resilver>resilver</a> . Para garantir que um resilver não interfira com a operação normal do pool, se qualquer outro I/O estiver acontecendo, o resilver irá atrasar entre cada comando. Esse valor controla o limite de total de IOPS (I/Os por segundo) gerados pelo resilver. A granularidade da configuração é determinada pelo valor de <code>kern.hz</code>, cujo padrão é de 1.000 marcações por segundo. Essa configuração pode ser alterada, resultando em um limite efetivo de IOPS diferente. O valor padrão é 2, resultando em um limite de: 1000 ticks / seg / 2 = 500 IOPS. Retornar o pool a um estado <a href=#zfs-term-online>Online</a> pode ser mais importante se a falha outro dispositivo levar o pool ao estado de <a href=#zfs-term-faulted>Fault</a>, causando perda de dados. Um valor de 0 dará à operação de resilver a mesma prioridade que outras operações, acelerando o processo de recuperação. A velocidade do resilver é limitada apenas quando houver outra atividade recente no pool, conforme determinado por <a href=#zfs-advanced-tuning-scan_idle><code>vfs.zfs.scan_idle</code></a>. Este valor pode ser ajustado a qualquer momento com <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a>.</p></li><li><p><a id=zfs-advanced-tuning-scan_idle></a><code><em>vfs.zfs.scan_idle</em></code> - Número de milissegundos desde a última operação antes do pool ser considerado ocioso. Quando o pool estiver ocioso, a taxa limite para <a href=#zfs-term-scrub><code>scrub</code></a> e <a href=#zfs-term-resilver>resilver</a> fica desativada. Este valor pode ser ajustado a qualquer momento com <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a>.</p></li><li><p><a id=zfs-advanced-tuning-txg-timeout></a><code><em>vfs.zfs.txg.timeout</em></code> - Número máximo de segundos entre os <a href=#zfs-term-txg>grupos de transações</a>. O grupo de transações atual será gravado no pool e um novo grupo de transações será iniciado se esse período de tempo tiver decorrido desde o grupo de transações anterior. Um grupo de transações pode ser acionado antes se dados suficientes forem gravados. O valor padrão é de 5 segundos. Um valor maior pode melhorar o desempenho de leitura atrasando gravações assíncronas, mas isso pode causar um desempenho irregular quando o grupo de transações é gravado. Este valor pode ser ajustado a qualquer momento com <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a>.</p></li></ul></div></div><div class=sect3><h4 id=zfs-advanced-i386>19.6.2. ZFS em i386<a class=anchor href=#zfs-advanced-i386></a></h4><div class=paragraph><p>Alguns dos recursos fornecidos pelo ZFS consomem muita memória, e podem exigir ajuste para máxima eficiência em sistemas com RAM limitada.</p></div><div class=sect4><h5 id=_memória>19.6.2.1. Memória<a class=anchor href=#_memória></a></h5><div class=paragraph><p>Como mínimo, a memória total do sistema deve ter pelo menos um gigabyte. A quantidade de RAM recomendada depende do tamanho do pool e dos recursos do ZFS usados. Uma regra geral é 1 GB de RAM para cada 1 TB de armazenamento. Se o recurso de deduplicação for usado, uma regra geral é 5 GB de RAM por TB de armazenamento para ser desduplicado. Enquanto alguns usuários usam com sucesso o ZFS com menos RAM, os sistemas sob carga pesada podem entrar em panic devido ao esgotamento da memória. Outros ajustes podem ser necessários para sistemas com uma quantia de memória RAM inferior ao recomendado.</p></div></div><div class=sect4><h5 id=_configuração_do_kernel>19.6.2.2. Configuração do Kernel<a class=anchor href=#_configuração_do_kernel></a></h5><div class=paragraph><p>Devido às limitações de espaço de endereço da plataforma i386™, os usuários do ZFS na arquitetura i386™ devem adicionar essa opção a um arquivo de configuração de kernel personalizado, reconstruir o kernel e reiniciar:</p></div><div class="literalblock programlisting"><div class=content><pre>options        KVA_PAGES=512</pre></div></div><div class=paragraph><p>Isso expande o espaço de endereço do kernel, permitindo que o parametro <code>vm.kvm_size</code> seja ajustado além do limite imposto atualmente de 1 GB ou o limite de 2 GB para PAE. Para encontrar o valor mais adequado para essa opção, divida o espaço de endereço desejado em megabytes por quatro. Neste exemplo, é <code>512</code> para 2 GB.</p></div></div><div class=sect4><h5 id=_ajustes_do_carregador>19.6.2.3. Ajustes do Carregador<a class=anchor href=#_ajustes_do_carregador></a></h5><div class=paragraph><p>O espaço de endereçamento <span class=filename>kmem</span> pode ser aumentado em todas as arquiteturas do FreeBSD. Em um sistema de teste com 1 GB de memória física, o sucesso foi alcançado com essas opções abaixo adicionadas ao <span class=filename>/boot/loader.conf</span>, e o sistema reiniciado:</p></div><div class="literalblock programlisting"><div class=content><pre>vm.kmem_size=&#34;330M&#34;
vm.kmem_size_max=&#34;330M&#34;
vfs.zfs.arc_max=&#34;40M&#34;
vfs.zfs.vdev.cache.size=&#34;5M&#34;</pre></div></div><div class=paragraph><p>Para obter uma lista mais detalhada de recomendações para otimizações relacionadas ao ZFS, consulte <a href=https://wiki.freebsd.org/ZFSTuningGuide class=bare>https://wiki.freebsd.org/ZFSTuningGuide</a>.</p></div></div></div></div><div class=sect2><h3 id=zfs-links>19.7. Recursos adicionais<a class=anchor href=#zfs-links></a></h3><div class=ulist><ul><li><p><a href=http://open-zfs.org>OpenZFS</a></p></li><li><p><a href=https://wiki.freebsd.org/ZFSTuningGuide>FreeBSD Wiki - ZFS Tuning</a></p></li><li><p><a href=http://docs.oracle.com/cd/E19253-01/819-5461/index.html>Oracle Solaris ZFS Administration Guide</a></p></li><li><p><a href=https://calomel.org/zfs_raid_speed_capacity.html>Calomel Blog - ZFS Raidz Performance, Capacity and Integrity</a></p></li></ul></div></div><div class=sect2><h3 id=zfs-term>19.8. Recursos e terminologia do ZFS<a class=anchor href=#zfs-term></a></h3><div class=paragraph><p>O ZFS é um sistema de arquivos fundamentalmente diferente, porque é mais do que apenas um sistema de arquivos. O ZFS combina as funções do sistema de arquivos e do gerenciador de volume, permitindo que dispositivos de armazenamento adicionais sejam adicionados a um sistema ativo e torne o novo espaço disponível em todos os sistemas de arquivos existentes nesse pool imediatamente. Combinando os papéis tradicionalmente separados, o ZFS é capaz de superar limitações anteriores que impediam o crescimento de grupos RAID. Cada dispositivo de nível superior em um pool é chamado de <em>vdev</em>, que pode ser um disco simples ou uma transformação RAID como um espelho ou array RAID-Z. Os sistemas de arquivos ZFS (chamados <em>datasets</em>) têm acesso ao espaço livre combinado de todo o pool. À medida que os blocos são alocados do pool, o espaço disponível para cada sistema de arquivos diminui. Essa abordagem evita a armadilha comum com o particionamento extensivo onde o espaço livre se torna fragmentado nas partições.</p></div><table class="tableblock frame-all grid-all stretch informaltable"><col style=width:20%><col style=width:80%><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a id=zfs-term-pool></a>pool</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Um <em>pool</em> de armazenamento é o bloco de construção mais básico do ZFS. Um pool é composto de um ou mais vdevs, os dispositivos subjacentes que armazenam os dados. Um pool é então usado para criar um ou mais sistemas de arquivos (datasets) ou dispositivos de bloco (volumes). Esses conjuntos de dados e volumes compartilham o espaço livre restante do pool. Cada pool é identificado exclusivamente por um nome e um GUID. Os recursos disponíveis são determinados pelo número da versão do ZFS no pool.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a id=zfs-term-vdev></a>vdev Types</p></td><td class="tableblock halign-left valign-top"><div class=content><div class=paragraph><p>Um pool é composto de um ou mais vdevs, que podem ser um único disco ou um grupo de discos, no caso de uma transformação RAID. Quando vários vdevs são usados, o ZFS propaga dados entre os vdevs para aumentar o desempenho e maximizar o espaço utilizável.</p></div><div class=ulist><ul><li><p><a id=zfs-term-vdev-disk></a><em>Disk</em> - O tipo mais básico de vdev é um dispositivo de bloco padrão. Isso pode ser um disco inteiro (como <span class=filename>/dev/ada0</span> ou <span class=filename>/dev/da0</span>) ou uma partição (<span class=filename>/dev/ada0p3</span>). No FreeBSD, não há penalidade de desempenho por usar uma partição em vez de todo o disco. Isso difere das recomendações feitas pela documentação do Solaris.</p><div class="admonitionblock caution"><table><tbody><tr><td class=icon><i class="fa icon-caution" title=Caution></i></td><td class=content><div class=paragraph><p>Usar um disco inteiro como parte de um pool inicializável é altamente desencorajado, pois isso pode tornar o pool não inicializável. Da mesma forma, você não deve usar um disco inteiro como parte de um mirror ou um RAID-Z vdev. Isso ocorre porque é impossível determinar com segurança o tamanho de um disco não particionado no momento da inicialização e porque não há lugar para inserir código de inicialização.</p></div></td></tr></tbody></table></div></li><li><p><a id=zfs-term-vdev-file></a><em>File</em>- Além dos discos, os pools do ZFS podem ser suportados por arquivos regulares, o que é especialmente útil para testes e experimentação. Use o caminho completo para o arquivo como o caminho do dispositivo no <code>zpool create</code>. Todos os vdevs devem ter pelo menos 128 MB de tamanho.</p></li><li><p><a id=zfs-term-vdev-mirror></a><em>Mirror</em> - Ao criar um espelho, especifique a palavra-chave <code>mirror</code> seguida pela lista de dispositivos membros para o espelho. Um espelho consiste em dois ou mais dispositivos, todos os dados serão gravados em todos os dispositivos membros. Um espelho vdev só armazenará tantos dados quanto seu menor membro. Um espelho vdev pode suportar a falha de todos, exceto um de seus membros, sem perder nenhum dado.</p><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Um vdev de disco único regular pode ser atualizado para um vdev de espelho a qualquer momento com <code>zpool <a href=#zfs-zpool-attach>attach</a></code>.</p></div></td></tr></tbody></table></div></li><li><p><a id=zfs-term-vdev-raidz></a><em>RAID-Z</em> - O ZFS implementa o RAID-Z, uma variação do padrão RAID-5 que oferece uma melhor distribuição de paridade e elimina o furo de escrita do "RAID-5" no qual os dados e informações de paridade tornam-se inconsistentes após um reinício inesperado. O ZFS suporta três níveis de RAID-Z, que fornecem vários níveis de redundância em troca de níveis decrescentes de armazenamento utilizável. Os tipos são nomeados de RAID-Z1 até RAID-Z3 com base no número de dispositivos de paridade na matriz e no número de discos que podem falhar enquanto o pool permanece operacional.</p><div class=paragraph><p>Em uma configuração de RAID-Z1 com quatro discos, cada um com 1 TB, resultará em um volume com armazenamento utilizável de 3 TB e o pool ainda poderá operar em modo degradado com um disco com falha. Se um disco adicional ficar off-line antes que o disco com falha seja substituído e que o resilver tenha sido executado, todos os dados no pool poderão ser perdidos.</p></div><div class=paragraph><p>Em uma configuração de RAID-Z3 com oito discos de 1 TB, o volume fornecerá 5 TB de espaço utilizável e ainda poderá operar com três discos com falha. A Sun™ recomenda no máximo nove discos em um único vdev. Se a configuração tiver mais discos, é recomendável dividi-los em vdevs separados e os dados do conjunto serão divididos entre eles.</p></div><div class=paragraph><p>Uma configuração de dois vdevs RAID-Z2 consistindo de 8 discos cada criaria algo similar a um array RAID-60. A capacidade de armazenamento do grupo RAID-Z é aproximadamente o tamanho do menor disco multiplicado pelo número de discos sem paridade. Quatro discos de 1 TB em RAID-Z1 têm um tamanho efetivo de aproximadamente 3 TB, e uma matriz de oito discos de 1 TB em RAID-Z3 produzirá 5 TB de espaço utilizável .</p></div></li><li><p><a id=zfs-term-vdev-spare></a><em>Spare</em>- O ZFS tem um tipo especial de pseudo-vdev para controlar os discos hot spares disponíveis. Observe que as peças de reposição instaladas não são implantadas automaticamente; eles devem ser configurados manualmente para substituir o dispositivo com falha usando o comando <code>zfs replace</code>.</p></li><li><p><a id=zfs-term-vdev-log></a><em>Log</em> - ZFS Dispositivos de log, também conhecidos como ZFS Intent Log (<a href=#zfs-term-zil>ZIL</a>) move o log de intenção dos dispositivos comuns do pool para um dispositivo dedicado, normalmente um SSD. Ter um dispositivo de log dedicado pode melhorar significativamente o desempenho de aplicativos com um alto volume de gravações síncronas, especialmente bancos de dados. Os dispositivos de log podem ser espelhados, mas o RAID-Z não é suportado. Se vários dispositivos de log forem usados, as gravações serão balanceadas entre eles.</p></li><li><p><a id=zfs-term-vdev-cache></a><em>Cache</em> - Adicionar um cache vdev a um pool adicionará o armazenamento do cache ao <a href=#zfs-term-l2arc>L2ARC</a>. Dispositivos de cache não podem ser espelhados. Como um dispositivo de cache armazena apenas cópias adicionais de dados existentes, não há risco de perda de dados.</p></li></ul></div></div></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a id=zfs-term-txg></a>Transaction Group (TXG)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Grupos de transações são a forma como os blocos alterados são agrupados e eventualmente gravados no pool. Grupos de transação são a unidade atômica que o ZFS usa para garantir a consistência. Cada grupo de transações recebe um identificador consecutivo exclusivo de 64 bits. Pode haver até três grupos de transações ativos por vez, um em cada um desses três estados:</p><p class=tableblock>* <em>Open</em> - Quando um novo grupo de transações é criado, ele está no estado aberto e aceita novas gravações. Há sempre um grupo de transações no estado aberto, no entanto, o grupo de transações pode recusar novas gravações se tiver atingido um limite. Quando o grupo de transações abertas tiver atingido um limite ou o <a href=#zfs-advanced-tuning-txg-timeout><code>vfs.zfs.txg.timeout</code></a> tiver sido alcançado, o grupo de transações avança para o próximo estado.
* <em>Quiescing</em> - Um estado curto que permite que qualquer operação pendente termine sem bloquear a criação de um novo grupo de transações abertas. Depois que todas as transações no grupo forem concluídas, o grupo de transações avançará para o estado final.
* <em>Syncing</em> - Todos os dados no grupo de transações são gravados no armazenamento estável. Esse processo, por sua vez, modificará outros dados, como metadados e mapas de espaço, que também precisarão ser gravados no armazenamento estável. O processo de sincronização envolve vários passos. O primeiro é o maior, e trata de todos os blocos de dados alterados, seguido pelos metadados, que podem levar vários passos para serem concluídos. Como a alocação de espaço para os blocos de dados gera novos metadados, o estado de sincronização não pode ser concluído até que um passo seja concluído e não aloque espaço adicional. O estado de sincronização também é onde as <em>synctasks</em> são concluídas. As operações de sincronização são operações administrativas, como criar ou destruir snapshots e datasets, que modificam o uberblock. Quando o estado de sincronização estiver concluído, o grupo de transações no estado de quiesce é avançado para o estado de sincronização.
Todas as funções administrativas, tal como <a href=#zfs-term-snapshot><code>snapshot</code></a> são gravados como parte do grupo de transações. Quando uma tarefa de sincronização é criada, ela é adicionada ao grupo de transações atualmente aberto e esse grupo é avançado o mais rápido possível para o estado de sincronização para reduzir a latência de comandos administrativos.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a id=zfs-term-arc></a>Adaptive Replacement Cache (ARC)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>O ZFS usa um Cache Adaptativo de Substituição (ARC), em vez de um mais tradicional como o Least Recently Used (LRU). Um cache LRU é uma lista simples de itens no cache, classificados por quando cada objeto foi usado mais recentemente. Novos itens são adicionados ao topo da lista. Quando o cache está cheio, os itens da parte inferior da lista são despejados para liberar espaço para mais objetos ativos. Um ARC consiste em quatro listas; os objetos Mais Recentes Utilizados (MRU) e Mais Frequentemente Usados (MFU), além de uma lista fantasma para cada um. Essas listas fantasmas rastreiam objetos recentemente despejados para evitar que sejam adicionados de volta ao cache. Isso aumenta a taxa de acertos do cache evitando objetos que têm um histórico de serem usados apenas ocasionalmente. Outra vantagem de usar um MRU e um MFU é que a verificação de um sistema de arquivos inteiro normalmente despejaria todos os dados de um MRU ou LRU do cache em favor deste conteúdo recém-acessado. Com o ZFS, há também um MFU que rastreia apenas os objetos usados com mais freqüência, e o cache dos blocos acessados com mais frequência permanece.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a id=zfs-term-l2arc></a>L2ARC</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>O L2ARC é o segundo nível do sistema de armazenamento em cache do ZFS. O ARC principal é armazenado em RAM. Como a quantidade de RAM disponível é limitada, o ZFS também pode usar <a href=#zfs-term-vdev-cache>cache vdevs</a>. Discos de estado sólido (SSDs) geralmente são usados como esses dispositivos de cache devido à sua maior velocidade e menor latência em comparação aos discos mecânicos tradicionais. O L2ARC é totalmente opcional, mas um deles aumentará significativamente a velocidade de leitura dos arquivos armazenados em cache no SSD em vez de precisar ser lido nos discos normais. O L2ARC também pode acelerar a <a href=#zfs-term-deduplication>desduplicação</a> porque um DDT que não cabe na RAM mas cabe no L2ARC será muito mais rápido que um DDT que deve ser lido do disco. A taxa na qual os dados são adicionados aos dispositivos de cache é limitada para evitar o desgaste prematuro dos SSDs com muitas gravações. Até que o cache esteja cheio (o primeiro bloco foi removido para liberar espaço), a gravação no L2ARC é limitada à soma do limite de gravação e do limite de aumento e depois limitada ao limite de gravação. Um par de valores <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> controla esses limites de taxa. A <a href=#zfs-advanced-tuning-l2arc_write_max><code>vfs.zfs.l2arc_write_max</code></a> controla quantos bytes são gravados no cache por segundo, enquanto <a href=#zfs-advanced-tuning-l2arc_write_boost><code>vfs.zfs.l2arc_write_boost</code></a> adiciona a este limite durante a "Turbo Warmup Phase " (aumento de gravação).</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a id=zfs-term-zil></a>ZIL</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>O ZIL acelera as transações síncronas usando dispositivos de armazenamento como SSDs mais rápidos do que os usados no pool de armazenamento principal. Quando um aplicativo solicita uma gravação síncrona (uma garantia de que os dados foram armazenados com segurança no disco, em vez de simplesmente serem gravados posteriormente), os dados são gravados no armazenamento mais rápido de ZIL e, depois, liberados aos discos regulares. Isso reduz enormemente a latência e melhora o desempenho. Apenas cargas de trabalho síncronas, como bancos de dados, serão beneficiadas com um ZIL. Gravações assíncronas regulares, como copiar arquivos, não usarão o ZIL.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a id=zfs-term-cow></a>Copy-On-Write</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Ao contrário de um sistema de arquivos tradicional, quando os dados são sobrescritos no ZFS, os novos dados são gravados em um bloco diferente, em vez de sobrescrever os dados antigos no lugar. Somente quando essa gravação for concluída, os metadados serão atualizados para apontar para o novo local. No caso de uma gravação simplificada (uma falha do sistema ou perda de energia no meio da gravação de um arquivo), todo o conteúdo original do arquivo ainda estará disponível e a gravação incompleta será descartada. Isso também significa que o ZFS não requer um <a href="https://man.freebsd.org/cgi/man.cgi?query=fsck&amp;sektion=8&amp;format=html">fsck(8)</a> após um desligamento inesperado.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a id=zfs-term-dataset></a>Dataset</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><em>Dataset</em> é o termo genérico para um sistema de arquivos ZFS, volume, snapshot ou clone. Cada dataset tem um nome exclusivo no formato <em>poolname/path@snapshot</em>. A raiz do pool é tecnicamente um dataset também. Dataset filhos são nomeados hierarquicamente como diretórios. Por exemplo, <em>mypool/home</em>, o dataset inicial, é um filho de <em>mypool</em> e herda propriedades dele. Isso pode ser expandido ainda mais criando o <em>mypool/home/user</em>. Este dataset neto herdará propriedades do pai e do avô. As propriedades de um filho podem ser definidas para substituir os padrões herdados dos pais e avós. A administração de datasets e seus filhos pode ser <a href=#zfs-zfs-allow>delegada</a>.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a id=zfs-term-filesystem></a>File system</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Um dataset ZFS é mais frequentemente usado como um sistema de arquivos. Como a maioria dos outros sistemas de arquivos, um sistema de arquivos ZFS é montado em algum lugar na hierarquia de diretórios do sistema e contém arquivos e diretórios próprios com permissões, sinalizadores e outros metadados.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a id=zfs-term-volume></a>Volume</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Além dos datasets regulares do sistema de arquivos, o ZFS também pode criar volumes, que são dispositivos de bloco. Os volumes têm muitos dos mesmos recursos, incluindo copy-on-write, snapshots, clones e checksum. Os volumes podem ser úteis para executar outros formatos de sistema de arquivos sobre o ZFS, tal como a virtualização do UFS ou a exportação de extensões iSCSI.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a id=zfs-term-snapshot></a>Snapshot</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>O design <a href=#zfs-term-cow>copy-on-write</a> (COW) do ZFS permite snapshots quase instantâneos e consistentes com nomes arbitrários. Depois de obter um snapshot de um dataset ou um snapshot recursivo de um dataset pai que incluirá todos os datasets filho, novos dados serão gravados em novos blocos, mas os blocos antigos não serão recuperados como espaço livre. O snapshot contém a versão original do sistema de arquivos e o sistema de arquivos em tempo real contém as alterações feitas desde que o snapshot foi feito. Nenhum espaço adicional é usado. Conforme novos dados são gravados no sistema de arquivos ao vivo, novos blocos são alocados para armazenar esses dados. O tamanho aparente do snapshot aumentará à medida que os blocos não forem mais usados no sistema de arquivos ativo, mas apenas no snapshot. Estes snapshots podem ser montados somente como leitura para permitir a recuperação de versões anteriores de arquivos. Também é possível <a href=#zfs-zfs-snapshot>reverter</a> um sistema de arquivos ativo para um snapshot específico, desfazendo quaisquer alterações que ocorreram depois que o snapshot foi tirado. Cada bloco no pool tem um contador de referência que registra quantos snapshots, clones, datasets ou volumes fazem uso desse bloco. À medida que arquivos e snapshots são excluídos, a contagem de referência é diminuída. Quando um bloco não é mais referenciado, ele é recuperado como espaço livre. Os snapshots também podem ser marcados com um <a href=#zfs-zfs-snapshot>hold</a>. Quando um snapshot é mantido, qualquer tentativa de destruí-lo retornará um erro <code>EBUSY</code>. Cada snapshot pode ter várias retenções, cada uma com um nome exclusivo. O comando <a href=#zfs-zfs-snapshot>release</a> remove a retenção para que o snapshot possa ser excluído. Snapshots podem ser obtidos de volumes, mas eles só podem ser clonados ou revertidos, não montados independentemente.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a id=zfs-term-clone></a>Clone</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Os snapshots também podem ser clonados. Um clone é uma versão gravável de um snapshot, permitindo que o sistema de arquivos seja bifurcado como um novo dataset. Como com um snapshot, um clone inicialmente não consome espaço adicional. Conforme novos dados são gravados em um clone e novos blocos são alocados, o tamanho aparente do clone aumenta. Quando os blocos são sobrescritos no sistema de arquivos ou no volume clonado, a contagem de referência no bloco anterior é diminuída. O snapshot no qual um clone é baseado não pode ser excluído porque o clone depende dele. O snapshot é o pai e o clone é o filho. Os clones podem ser <em>promovidos</em>, invertendo essa dependência e tornando o clone o pai e o pai anterior, o filho. Esta operação não requer espaço adicional. Como a quantidade de espaço usada pelo pai e pelo filho é revertida, as cotas e reservas existentes podem ser afetadas.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a id=zfs-term-checksum></a>Checksum</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Cada bloco alocado também é verificado. O algoritmo de checksum usado é uma propriedade por dataset, consulte <a href=#zfs-zfs-set><code>set</code></a>. O checksum de cada bloco é validado de forma transparente à medida que é lido, permitindo que o ZFS detecte a corrupção silenciosa. Se os dados lidos não corresponderem à checksum esperada, o ZFS tentará recuperar os dados de qualquer redundância disponível, como espelhos ou RAID-Z). A validação de todos os checksums pode ser acionada com o <a href=#zfs-term-scrub><code>scrub</code></a>. Os algoritmos de checksum incluem:</p><p class=tableblock>* <code>fletcher2</code>
* <code>fletcher4</code>
* <code>sha256</code>
Os algoritmos <code>fletcher</code> são mais rápidos, mas o <code>sha256</code> é um hash criptográfico forte e tem uma chance muito menor de colisões ao custo de algum desempenho. Checksums podem ser desativados, mas isso não é recomendado.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a id=zfs-term-compression></a>Compression</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Cada dataset tem uma propriedade de compactação, cujo padrão é off. Essa propriedade pode ser definida como um dos vários algoritmos de compactação. Isso fará com que todos os novos dados gravados no dataset sejam compactados. Além de uma redução no espaço usado, a taxa de leitura e gravação geralmente aumenta porque menos blocos são lidos ou gravados.</p><p class=tableblock><a id=zfs-term-compression-lz4></a>* <em>LZ4</em> - Adicionado na versão 5000 do pool do ZFS (feature flags), o LZ4 é agora o algoritmo de compressão recomendado. O LZ4 compacta aproximadamente 50% mais rápido do que o LZJB ao operar em dados compactáveis e é três vezes mais rápido ao operar em dados não compactáveis. O LZ4 também descompacta aproximadamente 80% mais rápido que o LZJB. Nas CPUs modernas, o LZ4 pode frequentemente comprimir a mais de 500 MB/s e descompactar a mais de 1,5 GB/s (por núcleo de CPU).
<a id=zfs-term-compression-lzjb></a>* <em>LZJB</em> - O algoritmo de compressão padrão. Criado por Jeff Bonwick (um dos criadores originais do ZFS). O LZJB oferece boa compactação com menos sobrecarga de CPU em comparação com o GZIP. No futuro, o algoritmo de compactação padrão provavelmente será alterado para LZ4.
<a id=zfs-term-compression-gzip></a>* <em>GZIP</em> - Um algoritmo popular de compressão de fluxo disponível no ZFS. Uma das principais vantagens de usar o GZIP é seu nível configurável de compactação. Ao definir a propriedade <code>compress</code>, o administrador pode escolher o nível de compactação, desde <code>gzip1</code>, o nível mais baixo de compactação, até <code>gzip9</code>, o maior nível de compressão. Isso dá ao administrador o controle sobre quanto tempo CPU será dedicado para economizar espaço em disco.
<a id=zfs-term-compression-zle></a>* <em>ZLE</em> - A codificação de comprimento zero é um algoritmo de compressão especial que apenas comprime sequencias contínuas de zeros. Esse algoritmo de compactação é útil apenas quando o dataset contém grandes blocos de zeros.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a id=zfs-term-copies></a>Copies</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Quando configurada para um valor maior que 1, a propriedade <code>copies</code> instrui o ZFS a manter várias cópias de cada bloco no <a href=#zfs-term-filesystem>sistema de arquivos </a>ou <a href=#zfs-term-volume>volume</a>. Definir essa propriedade em datasets importantes fornece redundância adicional a partir da qual recuperar um bloco que não corresponde ao seu checksum. Em pools sem redundância, o recurso de cópias é a única forma de redundância. O recurso de cópias pode se recuperar de um único setor defeituoso ou de outras formas de corrupção menor, mas não protege o pool da perda de um disco inteiro.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a id=zfs-term-deduplication></a>Deduplication</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Os checksums permitem detectar blocos duplicados de dados à medida que são escritos. Com a deduplicação, a contagem de referência de um bloco existente e idêntico é aumentada, economizando espaço de armazenamento. Para detectar blocos duplicados, uma tabela de deduplicação (DDT) é mantida na memória. A tabela contém uma lista de checksums exclusivas, a localização desses blocos e uma contagem de referência. Quando novos dados são gravados, o checksum é calculado e comparado à lista. Se uma correspondência for encontrada, o bloco existente será usado. O algoritmo de checksum SHA256 é usado com deduplicação para fornecer um hash criptográfico seguro. A desduplicação é configurável. Se <code>dedup</code> for <code>on</code>, um checksum correspondente será considerado como significando que os dados são idênticos. Se <code>dedup</code> for definido como <code>verify</code>, os dados nos dois blocos serão verificados byte por byte para garantir que sejam realmente idênticos. Se os dados não forem idênticos, a colisão de hash será anotada e os dois blocos serão armazenados separadamente. Como o DDT deve armazenar o hash de cada bloco único, ele consome uma quantidade muito grande de memória. Uma regra geral é 5-6 GB de RAM por 1 TB de dados desduplicados). Em situações em que não é prático ter RAM suficiente para manter todo o DDT na memória, o desempenho sofrerá muito, pois o DDT deve ser lido do disco antes que cada novo bloco seja gravado. A desduplicação pode usar o L2ARC para armazenar o DDT, fornecendo um meio termo entre a memória rápida do sistema e os discos mais lentos. Considere a possibilidade de usar a compactação, que geralmente oferece quase a mesma economia de espaço sem o requisito de memória adicional.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a id=zfs-term-scrub></a>Scrub</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Em vez de uma verificação de consistência como o <a href="https://man.freebsd.org/cgi/man.cgi?query=fsck&amp;sektion=8&amp;format=html">fsck(8)</a>, o ZFS tem o <code>scrub</code>. O <code>scrub</code> lê todos os blocos de dados armazenados no pool e verifica seus checksums em relação checksums bons conhecidos armazenados nos metadados. Uma verificação periódica de todos os dados armazenados no pool garante a recuperação de quaisquer blocos corrompidos antes que eles sejam necessários. Um scrub não é necessário após um desligamento inadequado do sistema, mas é recomendado pelo menos uma vez a cada três meses. O checksum de cada bloco é verificado à medida que os blocos são lidos durante o uso normal, mas um scrub garante que mesmo os blocos usados com pouca freqüência sejam verificados quanto a sua corrupção silenciosa. A segurança dos dados é aprimorada, especialmente em situações de armazenamento de arquivos. A prioridade relativa do <code>scrub</code> pode ser ajustada por meio da variável <a href=#zfs-advanced-tuning-scrub_delay><code>vfs.zfs.scrub_delay</code></a> para evitar que o scrub degrade o desempenho de outras cargas de trabalho no pool.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a id=zfs-term-quota></a>Dataset Quota</p></td><td class="tableblock halign-left valign-top"><div class=content><div class=paragraph><p>O ZFS fornece datasets rápidos e precisos, contabilidade de espaço de usuários e grupos, além de cotas e reservas de espaço. Isso dá ao administrador um controle refinado sobre como o espaço é alocado e permite que o espaço seja reservado para sistemas de arquivos críticos.</p></div><div class=paragraph><p>ZFS supports different types of quotas: the dataset quota, the <a href=#zfs-term-refquota>reference quota (refquota)</a>, the <a href=#zfs-term-userquota>user quota</a>, and the <a href=#zfs-term-groupquota>group quota</a>.</p></div><div class=paragraph><p>As cotas limitam a quantidade de espaço que um dataset e todos os seus descendentes, incluindo snapshots do dataset, datasets filhos e snapshots desses datasets, podem consumir.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Cotas não podem ser definidas em volumes, pois a propriedade <code>volsize</code> atua como uma cota implícita.</p></div></td></tr></tbody></table></div></div></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a id=zfs-term-refquota></a>Reference Quota</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Uma cota de referência limita a quantidade de espaço que um dataset pode consumir impondo um limite rígido. No entanto, esse limite rígido inclui apenas o espaço ao qual o dataset faz referência e não inclui o espaço usado pelos descendentes, como sistemas de arquivos ou snapshots.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a id=zfs-term-userquota></a>User Quota</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Cotas de usuários são úteis para limitar a quantidade de espaço que pode ser usada pelo usuário especificado.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a id=zfs-term-groupquota></a>Group Quota</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>A cota de grupo limita a quantidade de espaço que um grupo especificado pode consumir.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a id=zfs-term-reservation></a>Dataset Reservation</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>A propriedade <code>reservation</code> torna possível garantir uma quantidade mínima de espaço para um dataset específico e seus descendentes. Se uma reserva de 10 GB estiver definida em <span class=filename>storage/home/bob</span>, e outro dataset tentar usar todo o espaço livre, pelo menos 10 GB de espaço serão reservados para este dataset. Se um snapshot for criado de <span class=filename>storage/home/bob</span>, o espaço usado por esse snapshot será contabilizado contra a reserva. A propriedade <a href=#zfs-term-refreservation><code>refreservation</code></a> funciona de maneira semelhante, mas <em>exclui</em> os descendentes como os snapshots.</p><p class=tableblock>Reservas de qualquer tipo são úteis em muitas situações, como planejar e testar a adequação da alocação de espaço em disco em um novo sistema ou garantindo espaço suficiente nos sistemas de arquivos para logs de áudio ou procedimentos e arquivos de recuperação do sistema.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a id=zfs-term-refreservation></a>Reference Reservation</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>A propriedade <code>refreservation</code> torna possível garantir uma quantidade mínima de espaço para o uso de dataset específico <em>excluindo</em> seus descendentes. Isso significa que, se uma reserva de 10 GB estiver definida em <span class=filename>storage/home/bob</span>, e outro dataset tentar usar todo o espaço livre, pelo menos 10 GB de espaço serão reservados para este dataset. Em contraste com uma <a href=#zfs-term-reservation>reserva</a> regular, o espaço usado por snapshots e datasets descendentes não é contado contra a reserva. Por exemplo, se um snapshot for criado do <span class=filename>storage/home/bob</span>, deve haver espaço em disco suficiente fora da quantia de <code>refreservation</code> para que a operação seja bem-sucedida. Descendentes do dataset principal não são contados na quantia de <code>refreservation</code> e, portanto, não invadem o espaço definido.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a id=zfs-term-resilver></a>Resilver</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Quando um disco falha e é substituído, o novo disco deve ser preenchido com os dados perdidos. O processo de usar as informações de paridade distribuídas entre as unidades restantes para calcular e gravar os dados ausentes na nova unidade é chamado de <em>resilvering</em>.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a id=zfs-term-online></a>Online</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Um pool ou vdev no estado <code>Online</code> tem todos os seus dispositivos membros conectados e totalmente operacionais. Dispositivos individuais no estado <code>Online</code> estão funcionando normalmente.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a id=zfs-term-offline></a>Offline</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Dispositivos individuais podem ser colocados em um estado <code>Offline</code> pelo administrador se houver redundância suficiente para evitar colocar o pool ou vdev em um estado <a href=#zfs-term-faulted>Faulted</a>. Um administrador pode optar por colocar um disco off-line como preparação para substituí-lo ou para facilitar sua identificação.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a id=zfs-term-degraded></a>Degraded</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Um pool ou vdev no estado <code>Degraded</code> possui um ou mais discos que foram desconectados ou falharam. O pool ainda é utilizável, mas se dispositivos adicionais falharem, o pool poderá se tornar irrecuperável. Reconectar os dispositivos ausentes ou substituir os discos com falha retornará o pool a um estado <a href=#zfs-term-online>Online</a> depois que o dispositivo reconectado ou novo tiver concluído o processo de <a href=#zfs-term-resilver>Resilver</a>.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a id=zfs-term-faulted></a>Faulted</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Um pool ou vdev no estado <code>Faulted</code> não está mais operacional. Os dados nele não podem mais ser acessados. Um pool ou vdev entra no estado <code>Faulted</code> quando o número de dispositivos ausentes ou com falha excede o nível de redundância no vdev. Se os dispositivos ausentes puderem ser reconectados, o pool retornará ao estado <a href=#zfs-term-online>Online</a>. Se houver redundância insuficiente para compensar o número de discos com falha, o conteúdo do pool será perdido e deverá ser restaurado a partir de um backup.</p></td></tr></tbody></table></div></div></div><div class=sect1><h2 id=filesystems>Capítulo 20. Outros Sistemas de Arquivos<a class=anchor href=#filesystems></a></h2><div class=sectionbody><div class=sect2><h3 id=filesystems-synopsis>20.1. Sinopse<a class=anchor href=#filesystems-synopsis></a></h3><div class=paragraph><p>Os sistemas de arquivos são parte integrante de qualquer sistema operacional. Eles permitem que os usuários carreguem e armazenem arquivos, forneçem acesso a dados e tornam os discos rígidos úteis. Diferentes sistemas operacionais diferem em seu sistema de arquivos nativo. Tradicionalmente, o sistema de arquivo nativo do FreeBSD tem sido o Sistema de Arquivos Unix (Unix File System) UFS o qual foi modernizado como UFS2. Desde o FreeBSD 7.0, o Sistema de Arquivos Z (ZFS) também está disponível como um sistema de arquivos nativo. Veja <a href=./#zfs>O sistema de arquivos Z (ZFS)</a> para maiores informações.</p></div><div class=paragraph><p>Além dos seus sistemas de arquivos nativos, o FreeBSD suporta uma infinidade de outros sistemas de arquivos para que dados de outros sistemas operacionais possam ser acessados localmente, tais como dados armazenados em dispositivos de armazenamento USB conectados localmente, drives flash e discos rígidos. Isto inclui suporte para o sistema de arquivos estendidos do Linux™ (EXT).</p></div><div class=paragraph><p>Existem diferentes níveis de suporte do FreeBSD para os vários sistemas de arquivos. Alguns exigem que um módulo do kernel seja carregado e outros podem requerer que um conjunto de ferramentas seja instalado. O suporte a alguns dos sistemas de arquivos não nativos é completo, suportando leitura/gravação, enquanto o suporte a outros é somente de leitura.</p></div><div class=paragraph><p>Depois de ler este capítulo, você saberá:</p></div><div class=ulist><ul><li><p>A diferença entre sistemas de arquivos nativos e suportados.</p></li><li><p>Quais sistemas de arquivos são suportados pelo FreeBSD.</p></li><li><p>Como ativar, configurar, acessar e usar sistemas de arquivos não nativos.</p></li></ul></div><div class=paragraph><p>Antes de ler este capítulo, você deve:</p></div><div class=ulist><ul><li><p>Compreender o UNIX™ e ter <a href=./#basics>noções básicas de FreeBSD</a>.</p></li><li><p>Estar familiarizado com o básico da <a href=./#kernelconfig>configuração e compilação do kernel</a>.</p></li><li><p>Sinta-se confortável <a href=./#ports>instalando software</a> no FreeBSD.</p></li><li><p>Tenha alguma familiaridade com <a href=./#disks>discos</a>, armazenamento e nomes de dispositivos no FreeBSD.</p></li></ul></div></div><div class=sect2><h3 id=filesystems-linux>20.2. Sistemas de arquivos do Linux™<a class=anchor href=#filesystems-linux></a></h3><div class=paragraph><p>O FreeBSD fornece suporte built-in para vários sistemas de arquivos do Linux™. Esta seção demonstra como carregar o suporte e como montar os sistemas de arquivos suportados do Linux™.</p></div><div class=sect3><h4 id=_ext2>20.2.1. ext2<a class=anchor href=#_ext2></a></h4><div class=paragraph><p>O suporte no kernel para sistemas de arquivos ext2 está disponível desde o FreeBSD 2.2. No FreeBSD 8.x e anterior, o código está licenciado sob a GPL. Desde o FreeBSD 9.0, o código foi reescrito e agora é licenciado sob a licença BSD.</p></div><div class=paragraph><p>O driver <a href="https://man.freebsd.org/cgi/man.cgi?query=ext2fs&amp;sektion=5&amp;format=html">ext2fs(5)</a> permite que o kernel do FreeBSD leia e grave em sistemas de arquivos ext2.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Esse driver também pode ser usado para acessar os sistemas de arquivos ext3 e ext4. O sistema de arquivos <a href="https://man.freebsd.org/cgi/man.cgi?query=ext2fs&amp;sektion=5&amp;format=html">ext2fs(5)</a> possui suporte completo para leitura e gravação para o ext4 a partir do FreeBSD 12.0-RELEASE. Além disso, os atributos estendidos e as ACLs também são suportados, enquanto o journalling e a criptografia não são. Começando com o FreeBSD 12.1-RELEASE, um provedor do DTrace também estará disponível. Versões anteriores do FreeBSD podem acessar o ext4 no modo de leitura e gravação usando <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/fusefs-ext2/>sysutils/fusefs-ext2</a>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Para acessar um sistema de arquivos ext, primeiro carregue o módulo correspondente do kernel:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload ext2fs</span></code></pre></div></div><div class=paragraph><p>Em seguida, monte o volume ext especificando seu nome de partição no FreeBSD e um ponto de montagem existente. Este exemplo monta <span class=filename>/dev/ad1s1</span> em <span class=filename>/mnt</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount -t ext2fs /dev/ad1s1 /mnt</span></code></pre></div></div></div></div></div></div><div class=sect1><h2 id=virtualization>Capítulo 21. Virtualização<a class=anchor href=#virtualization></a></h2><div class=sectionbody><div class=sect2><h3 id=virtualization-synopsis>21.1. Sinopse<a class=anchor href=#virtualization-synopsis></a></h3><div class=paragraph><p>O software de virtualização permite que vários sistemas operacionais sejam executados simultaneamente no mesmo computador. Tais sistemas de software para PCs geralmente envolvem um sistema operacional host que executa o software de virtualização e suporta qualquer número de sistemas operacionais convidados.</p></div><div class=paragraph><p>Depois de ler este capítulo, você saberá:</p></div><div class=ulist><ul><li><p>A diferença entre um sistema operacional host e um sistema operacional convidado.</p></li><li><p>Como instalar o FreeBSD em um computador baseado em um Intel™Apple™Mac™.</p></li><li><p>Como instalar o FreeBSD no Microsoft™Windows™ com Virtual PC.</p></li><li><p>Como instalar o FreeBSD como um host convidado no bhyve.</p></li><li><p>Como ajustar um sistema FreeBSD para melhor desempenho sob virtualização.</p></li></ul></div><div class=paragraph><p>Antes de ler este capítulo, você deve:</p></div><div class=ulist><ul><li><p>Entender o <a href=./#basics>básico sobre sistemas UNIX™ e sobre o FreeBSD</a>.</p></li><li><p>Saber como <a href=./#bsdinstall>instalar o FreeBSD</a>.</p></li><li><p>Saber como <a href=./#advanced-networking>configurar uma conexão de rede</a>.</p></li><li><p>Saber como <a href=./#ports>instalar software adicional de terceiros</a>.</p></li></ul></div></div><div class=sect2><h3 id=virtualization-guest-parallels>21.2. FreeBSD como Sistema Operacional Convidado no Parallels para Mac OS™ X<a class=anchor href=#virtualization-guest-parallels></a></h3><div class=paragraph><p>O Parallels Desktop para Mac™ é um produto de software comercial disponível para computadores baseados em Intel™Apple™Mac™ rodando Mac OS™ 10.4.6 ou superior. O FreeBSD é um sistema operacional convidado completamente suportado. Uma vez que o Parallels tiver sido instalado no Mac OS™ X, o usuário deve configurar uma maquina virtual e então instalar o sistema operacional convidado desejado.</p></div><div class=sect3><h4 id=virtualization-guest-parallels-install>21.2.1. Instalando o FreeBSD no Parallels/Mac OS™ X<a class=anchor href=#virtualization-guest-parallels-install></a></h4><div class=paragraph><p>O primeiro passo para instalar o FreeBSD no Parallels é criar uma nova máquina virtual para instalar o FreeBSD. Selecione <span class=guimenuitem>FreeBSD</span> como o <b class=menuref>Guest OS Type</b> quando solicitado:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/parallels-freebsd1.png alt="parallels freebsd1"></div></div><div class=paragraph><p>Escolha uma quantidade razoável de disco e memória, dependendo dos planos para esta instância virtual do FreeBSD. 4GB de espaço em disco e 512MB de RAM funcionam bem para a maioria dos usos do FreeBSD executando sob o Parallels:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/parallels-freebsd2.png alt="parallels freebsd2"></div></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/parallels-freebsd3.png alt="parallels freebsd3"></div></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/parallels-freebsd4.png alt="parallels freebsd4"></div></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/parallels-freebsd5.png alt="parallels freebsd5"></div></div><div class=paragraph><p>Selecione o tipo de rede e uma interface de rede:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/parallels-freebsd6.png alt="parallels freebsd6"></div></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/parallels-freebsd7.png alt="parallels freebsd7"></div></div><div class=paragraph><p>Salve e finalize a configuração:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/parallels-freebsd8.png alt="parallels freebsd8"></div></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/parallels-freebsd9.png alt="parallels freebsd9"></div></div><div class=paragraph><p>Após a criação da máquina virtual do FreeBSD, o FreeBSD pode ser instalado nela. Isto é feito melhor com um CD/DVD oficial do FreeBSD ou com uma imagem ISO baixada de um site FTP oficial. Copie a imagem ISO apropriada para o sistema de arquivos local do Mac™ ou insira um CD/DVD na unidade de CD-ROM do Mac™. Clique no ícone do disco no canto inferior direito da janela do FreeBSD no Parallels. Isso abrirá uma janela a qual pode ser usada para associar a unidade de CD-ROM na máquina virtual com o arquivo ISO no disco ou com drive CD.</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/parallels-freebsd11.png alt="parallels freebsd11"></div></div><div class=paragraph><p>Uma vez que esta associação com a fonte do CD-ROM estiver feita, reinicialize a máquina virtual do FreeBSD clicando no ícone de reinicialização. O Parallels irá reiniciar com um BIOS especial o qual primeiro irá verificar se existe um CD-ROM.</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/parallels-freebsd10.png alt="parallels freebsd10"></div></div><div class=paragraph><p>Neste caso, ele encontrará a mídia de instalação do FreeBSD e iniciará uma instalação normal do FreeBSD. Execute a instalação, mas não tente configurar o Xorg neste momento.</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/parallels-freebsd12.png alt="parallels freebsd12"></div></div><div class=paragraph><p>Quando a instalação estiver concluída, reinicie a máquina virtual FreeBSD recém-instalada.</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/parallels-freebsd13.png alt="parallels freebsd13"></div></div></div><div class=sect3><h4 id=virtualization-guest-parallels-configure>21.2.2. Configurando o FreeBSD no Parallels<a class=anchor href=#virtualization-guest-parallels-configure></a></h4><div class=paragraph><p>Depois que o FreeBSD foi instalado com sucesso no Mac OS™ X com o Parallels , existem várias etapas de configuração que podem ser executadas para otimizar o sistema para operar virtualizado.</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Definir variáveis do Boot Loader</p><div class=paragraph><p>O passo mais importante é reduzir o <code>kern.hz</code> ajustável para reduzir a utilização de CPU no FreeBSD sob ambiente Parallels. Isso é feito adicionando a seguinte linha ao <span class=filename>/boot/loader.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>kern.hz=100</pre></div></div><div class=paragraph><p>Sem essa configuração, um sistema convidado inativo do FreeBSD no Parallels usará aproximadamente 15% da CPU de um único processador iMac™. Após essa alteração, o uso ficará mais próximo de 5%.</p></div></li><li><p>Criar um novo arquivo de configuração do kernel</p><div class=paragraph><p>Todos os drivers de dispositivos SCSI, FireWire e USB podem ser removidos de um arquivo de configuração de kernel personalizado. O Parallels fornece um adaptador de rede virtual usado pelo driver <a href="https://man.freebsd.org/cgi/man.cgi?query=ed&amp;sektion=4&amp;format=html">ed(4)</a>, portanto, todos os dispositivos de rede, exceto o <a href="https://man.freebsd.org/cgi/man.cgi?query=ed&amp;sektion=4&amp;format=html">ed(4)</a> e o <a href="https://man.freebsd.org/cgi/man.cgi?query=miibus&amp;sektion=4&amp;format=html">miibus(4)</a> podem ser removidos do kernel .</p></div></li><li><p>Configure a rede</p><div class=paragraph><p>A configuração de rede mais básica usa o DHCP para conectar a máquina virtual à mesma rede local que o host Mac™. Isso pode ser feito adicionando <code>ifconfig_ed0="DHCP"</code> ao <span class=filename>/etc/rc.conf</span>. Configurações de rede mais avançadas são descritas em <a href=./#advanced-networking>Rede Avançada</a>.</p></div></li></ol></div></div></div></div></div><div class=sect2><h3 id=virtualization-guest-virtualpc>21.3. FreeBSD como sistema convidado no Virtual PC para Windows™<a class=anchor href=#virtualization-guest-virtualpc></a></h3><div class=paragraph><p>O Virtual PC para Windows™ é um software da Microsoft™ disponível para download gratuito. Consulte este site para os <a href=http://www.microsoft.com/windows/downloads/virtualpc/sysreq.mspx>requisitos do sistema</a>. Depois que o Virtual PC tiver sido instalado no Microsoft™Windows™, o usuário poderá configurar uma máquina virtual e depois instalar o sistema operacional convidado desejado.</p></div><div class=sect3><h4 id=virtualization-guest-virtualpc-install>21.3.1. Instalando o FreeBSD no Virtual PC<a class=anchor href=#virtualization-guest-virtualpc-install></a></h4><div class=paragraph><p>O primeiro passo para instalar o FreeBSD no Virtual PC é criar uma nova máquina virtual para instalar o FreeBSD. Selecione <span class=guimenuitem>Criar uma máquina virtual</span> quando solicitado:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/virtualpc-freebsd1.png alt="virtualpc freebsd1"></div></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/virtualpc-freebsd2.png alt="virtualpc freebsd2"></div></div><div class=paragraph><p>Selecione a opção <span class=guimenuitem>Outro</span> para o <span class=guimenuitem>Sistema operacional</span> quando solicitado:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/virtualpc-freebsd3.png alt="virtualpc freebsd3"></div></div><div class=paragraph><p>Em seguida, escolha uma quantidade razoável de disco e de memória, dependendo dos planos para esta instância virtual do FreeBSD. 4GB de espaço em disco e 512MB de RAM funcionam bem para a maioria dos usos do FreeBSD sob o Virtual PC:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/virtualpc-freebsd4.png alt="virtualpc freebsd4"></div></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/virtualpc-freebsd5.png alt="virtualpc freebsd5"></div></div><div class=paragraph><p>Salve e finalize a configuração:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/virtualpc-freebsd6.png alt="virtualpc freebsd6"></div></div><div class=paragraph><p>Selecione a máquina virtual do FreeBSD e clique em <b class=menuref>Configurações</b>, em seguida, defina o tipo de rede e uma interface de rede:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/virtualpc-freebsd7.png alt="virtualpc freebsd7"></div></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/virtualpc-freebsd8.png alt="virtualpc freebsd8"></div></div><div class=paragraph><p>Após a criação da máquina virtual do FreeBSD, o FreeBSD pode ser instalado nela. Isso é feito da melhor maneira com um CD/DVD oficial ou com uma imagem ISO baixada de um site FTP oficial. Copie a imagem ISO apropriada para o sistema de arquivos local do Windows™ ou insira um CD/DVD na unidade de CD-ROM, então clique duas vezes na máquina virtual FreeBSD para inicializar. Em seguida, clique em <b class=menuref>CD</b> e escolha <b class=menuref>Capturar imagem ISO…​</b> na janela do Virtual PC. Isso abrirá uma janela na qual a unidade de CD-ROM na máquina virtual poderá ser associada a um arquivo ISO no disco ou com o drive de CD-ROM real.</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/virtualpc-freebsd9.png alt="virtualpc freebsd9"></div></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/virtualpc-freebsd10.png alt="virtualpc freebsd10"></div></div><div class=paragraph><p>Uma vez que a associação com a fonte do CD-ROM estiver feita, reinicie a máquina virtual do FreeBSD clicando em <b class=menuref>Action</b> e depois em <b class=menuref>Reset</b>. O Virtual PC será reiniciado com um BIOS especial que irá procurar por um CD-ROM para inicializar.</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/virtualpc-freebsd11.png alt="virtualpc freebsd11"></div></div><div class=paragraph><p>Neste caso, ele encontrará a mídia de instalação do FreeBSD e iniciará uma instalação normal do FreeBSD. Continue com a instalação, mas não tente configurar o Xorg neste momento.</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/virtualpc-freebsd12.png alt="virtualpc freebsd12"></div></div><div class=paragraph><p>Quando a instalação estiver concluída, lembre-se de ejetar o CD/DVD ou de liberar a imagem ISO. Finalmente, reinicie a máquina virtual FreeBSD recém-instalada.</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/virtualpc-freebsd13.png alt="virtualpc freebsd13"></div></div></div><div class=sect3><h4 id=virtualization-guest-virtualpc-configure>21.3.2. Configuring FreeBSD on Virtual PC<a class=anchor href=#virtualization-guest-virtualpc-configure></a></h4><div class=paragraph><p>Depois que o FreeBSD tiver sido instalado com sucesso no Microsoft™Windows™ com o Virtual PC, existem várias etapas de configurações que podem ser executadas para otimizar o sistema para operação virtualizada.</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Definir variáveis do Boot Loader</p><div class=paragraph><p>O passo mais importante é reduzir o valor do parâmetro <code>kern.hz</code> para reduzir a utilização da CPU do FreeBSD sob o ambiente do Virtual PC. Isso é feito adicionando a seguinte linha ao <span class=filename>/boot/loader.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>kern.hz=100</pre></div></div><div class=paragraph><p>Sem esta configuração, uma VM idle do FreeBSD rodando sob o Virtual PC utilizará aproximadamente 40% da CPU de um computador com um único processador. Após essa mudança, o uso ficará mais próximo de 3%.</p></div></li><li><p>Criar um novo arquivo de configuração do kernel</p><div class=paragraph><p>Todos os drivers de dispositivos SCSI, FireWire e USB podem ser removidos do arquivo de configuração do kernel personalizado. O Virtual PC fornece um adaptador de rede virtual usado pelo driver <a href="https://man.freebsd.org/cgi/man.cgi?query=de&amp;sektion=4&amp;format=html">de(4)</a>, portanto, todos os dispositivos de rede, exceto o <a href="https://man.freebsd.org/cgi/man.cgi?query=de&amp;sektion=4&amp;format=html">de(4)</a> e o <a href="https://man.freebsd.org/cgi/man.cgi?query=miibus&amp;sektion=4&amp;format=html">miibus(4)</a> podem ser removidos do kernel.</p></div></li><li><p>Configure a rede</p><div class=paragraph><p>A configuração de rede mais básica usa o DHCP para conectar a máquina virtual à mesma rede local que o host Microsoft™Windows™. Isso pode ser feito adicionando <code>ifconfig_de0="DHCP"</code> ao <span class=filename>/etc/rc.conf</span>. Configurações de rede mais avançadas são descritas em <a href=./#advanced-networking>Rede Avançada</a>.</p></div></li></ol></div></div></div></div></div><div class=sect2><h3 id=virtualization-guest-vmware>21.4. FreeBSD como Sistema Operacional Convidado no VMware Fusion para Mac OS™<a class=anchor href=#virtualization-guest-vmware></a></h3><div class=paragraph><p>O VMware Fusion para Mac™ é um software comercial disponível para computadores Apple™Mac™ baseados em processadores Intel™ e que rodam o Mac OS™ 10.4.9 ou superior. O FreeBSD é um sistema operacional convidado totalmente suportado. Depois que o VMware Fusion for instalado no Mac OS™ X, o usuário poderá configurar uma máquina virtual e, em seguida, instalar o sistema operacional convidado desejado.</p></div><div class=sect3><h4 id=virtualization-guest-vmware-install>21.4.1. Instalando o FreeBSD no VMware Fusion<a class=anchor href=#virtualization-guest-vmware-install></a></h4><div class=paragraph><p>A primeira etapa é iniciar o VMware Fusion, que irá carregar a biblioteca de máquinas virtuais. Clique em <span class=guimenuitem>Novo</span> para criar a máquina virtual:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/vmware-freebsd01.png alt="vmware freebsd01"></div></div><div class=paragraph><p>Isto irá carregar o Assistente de Nova Máquina Virtual. Clique em <span class=guimenuitem>Continuar</span> para prosseguir:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/vmware-freebsd02.png alt="vmware freebsd02"></div></div><div class=paragraph><p>Selecione <span class=guimenuitem>Outro</span> como o <span class=guimenuitem>Sistema Operacional</span> e <span class=guimenuitem>FreeBSD</span> ou <span class=guimenuitem>FreeBSD 64-bit</span>, como <b class=menuref>Versão</b> quando solicitado:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/vmware-freebsd03.png alt="vmware freebsd03"></div></div><div class=paragraph><p>Escolha o nome da máquina virtual e o diretório onde ela deve ser salva:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/vmware-freebsd04.png alt="vmware freebsd04"></div></div><div class=paragraph><p>Escolha o tamanho do disco rígido virtual para a máquina virtual:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/vmware-freebsd05.png alt="vmware freebsd05"></div></div><div class=paragraph><p>Escolha o método para instalar a máquina virtual, a partir de uma imagem ISO ou de um CD/DVD:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/vmware-freebsd06.png alt="vmware freebsd06"></div></div><div class=paragraph><p>Clique em <span class=guimenuitem>Concluir</span> e a máquina virtual inicializará:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/vmware-freebsd07.png alt="vmware freebsd07"></div></div><div class=paragraph><p>Instale o FreeBSD como de costume:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/vmware-freebsd08.png alt="vmware freebsd08"></div></div><div class=paragraph><p>Quando a instalação estiver concluída, as configurações da máquina virtual poderão ser modificadas, como o uso de memória:</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>As configurações de hardware do sistema da máquina virtual não podem ser modificadas enquanto a máquina virtual estiver em execução.</p></div></td></tr></tbody></table></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/vmware-freebsd09.png alt="vmware freebsd09"></div></div><div class=paragraph><p>O número de CPUs a que a máquina virtual terá acesso:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/vmware-freebsd10.png alt="vmware freebsd10"></div></div><div class=paragraph><p>O status do dispositivo CD-ROM. Normalmente, o CD/DVD/ISO é desconectado da máquina virtual quando não é mais necessário.</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/vmware-freebsd11.png alt="vmware freebsd11"></div></div><div class=paragraph><p>A última coisa a mudar é como a máquina virtual se conectará à rede. Para permitir conexões à máquina virtual de outras máquinas além do host, escolha <span class=guimenuitem>Conectar diretamente à rede física (Bridged)</span>. Caso contrário, <span class=guimenuitem>Compartilhar a conexão de internet do host (NAT)</span> é preferível para que a máquina virtual possa ter acesso à Internet, porém sem que as demais maquinas da rede possam acessá-la.</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/virtualization/vmware-freebsd12.png alt="vmware freebsd12"></div></div><div class=paragraph><p>Depois de modificar as configurações, inicialize a máquina virtual FreeBSD recém-instalada.</p></div></div><div class=sect3><h4 id=virtualization-guest-vmware-configure>21.4.2. Configurando o FreeBSD no VMware Fusion<a class=anchor href=#virtualization-guest-vmware-configure></a></h4><div class=paragraph><p>Depois que o FreeBSD for instalado com sucesso no Mac OS™ X rodando o VMware Fusion, existem várias etapas de configuração que podem ser executadas para otimizar o sistema para operar virtualizado.</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Definir variáveis do Boot Loader</p><div class=paragraph><p>O passo mais importante é reduzir o valor do parâmetro <code>kern.hz</code> para reduzir a utilização da CPU do FreeBSD sob o ambiente do VMware Fusion. Isso é feito adicionando a seguinte linha ao <span class=filename>/boot/loader.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>kern.hz=100</pre></div></div><div class=paragraph><p>Sem esta configuração, uma VM idle do FreeBSD rodando sob o VMware Fusion usará aproximadamente 15% da CPU de um único processador iMac™. Após esta mudança, o uso ficará próximo de 5%.</p></div></li><li><p>Criar um novo arquivo de configuração do kernel</p><div class=paragraph><p>Todos os drivers de dispositivos FireWire e USB podem ser removidos do arquivo de configuração do kernel personalizado. O VMware Fusion fornece um adaptador de rede virtual usado pelo driver <a href="https://man.freebsd.org/cgi/man.cgi?query=em&amp;sektion=4&amp;format=html">em(4)</a>, portanto, todos os dispositivos de rede, exceto o <a href="https://man.freebsd.org/cgi/man.cgi?query=em&amp;sektion=4&amp;format=html">em(4)</a> podem ser removidos do kernel.</p></div></li><li><p>Configure a rede</p><div class=paragraph><p>A configuração de rede mais básica usa o DHCP para conectar a máquina virtual à mesma rede local que o host Mac™. Isso pode ser feito adicionando <code>ifconfig_em0="DHCP"</code> ao <span class=filename>/etc/rc.conf</span>. Configurações de rede mais avançadas estão descritas em <a href=./#advanced-networking>Rede Avançada</a>.</p></div></li></ol></div></div></div></div></div><div class=sect2><h3 id=virtualization-guest-virtualbox>21.5. FreeBSD como Sistema Operacional Convidado no VirtualBox™<a class=anchor href=#virtualization-guest-virtualbox></a></h3><div class=paragraph><p>O FreeBSD funciona bem como um sistema operacional convidado no VirtualBox™. O software de virtualização está disponível para a maioria dos sistemas operacionais comuns, incluindo o próprio FreeBSD.</p></div><div class=paragraph><p>Os complementos de sistema operacional convidado do VirtualBox™ fornecem suporte para:</p></div><div class=ulist><ul><li><p>Compartilhamento de área de transferência.</p></li><li><p>Integração do ponteiro do mouse.</p></li><li><p>Sincronização de hora com o host.</p></li><li><p>Redimensionamento de janela.</p></li><li><p>Modo Seamless.</p></li></ul></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Estes comandos são executados na instancia virtualizada do FreeBSD.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Primeiro, instale o pacote ou o port <a class=package href=https://cgit.freebsd.org/ports/tree/emulators/virtualbox-ose-additions/>emulators/virtualbox-ose-additions</a> na instancia virtualizada do FreeBSD. Isso irá instalar o port:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/emulators/virtualbox-ose-additions &amp;&amp; make install clean</span></code></pre></div></div><div class=paragraph><p>Adicione estas linhas ao <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>vboxguest_enable=&#34;YES&#34;
vboxservice_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Se o <a href="https://man.freebsd.org/cgi/man.cgi?query=ntpd&amp;sektion=8&amp;format=html">ntpd(8)</a> ou o <a href="https://man.freebsd.org/cgi/man.cgi?query=ntpdate&amp;sektion=8&amp;format=html">ntpdate(8)</a> estiver sendo utilizado, desabilite a sincronização de horário com o host:</p></div><div class="literalblock programlisting"><div class=content><pre>vboxservice_flags=&#34;--disable-timesync&#34;</pre></div></div><div class=paragraph><p>O Xorg reconhecerá automaticamente o driver <code>vboxvideo</code>. Ele também pode ser inserido manualmente no <span class=filename>/etc/X11/xorg.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>Section &#34;Device&#34;
	Identifier &#34;Card0&#34;
	Driver &#34;vboxvideo&#34;
	VendorName &#34;InnoTek Systemberatung GmbH&#34;
	BoardName &#34;VirtualBox Graphics Adapter&#34;
EndSection</pre></div></div><div class=paragraph><p>Para usar o driver <code>vboxmouse</code>, ajuste a seção do mouse no <span class=filename>/etc/X11/xorg.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>Section &#34;InputDevice&#34;
	Identifier &#34;Mouse0&#34;
	Driver &#34;vboxmouse&#34;
EndSection</pre></div></div><div class=paragraph><p>Usuários do HAL devem criar o arquivo <span class=filename>/usr/local/etc/hal/fdi/policy/90-vboxguest.fdi</span> com o conteúdo abaixo ou copiá-lo de <span class=filename>/usr/local/shared/hal/fdi/policy/10osvendor/90-vboxguest.fdi</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>&lt;?xml version=&#34;1.0&#34; encoding=&#34;utf-8&#34;?&gt;
&lt;!--
# Sun VirtualBox
# Hal driver description for the vboxmouse driver
# $Id: chapter.xml,v 1.33 2012-03-17 04:53:52 eadler Exp $

	Copyright (C) 2008-2009 Sun Microsystems, Inc.

	This file is part of VirtualBox Open Source Edition (OSE, as
	available from http://www.virtualbox.org. This file is free software;
	you can redistribute it and/or modify it under the terms of the GNU
	General Public License (GPL) as published by the Free Software
	Foundation, in version 2 as it comes in the &#34;COPYING&#34; file of the
	VirtualBox OSE distribution. VirtualBox OSE is distributed in the
	hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.

	Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa
	Clara, CA 95054 USA or visit http://www.sun.com if you need
	additional information or have any questions.
--&gt;
&lt;deviceinfo version=&#34;0.2&#34;&gt;
  &lt;device&gt;
    &lt;match key=&#34;info.subsystem&#34; string=&#34;pci&#34;&gt;
      &lt;match key=&#34;info.product&#34; string=&#34;VirtualBox guest Service&#34;&gt;
        &lt;append key=&#34;info.capabilities&#34; type=&#34;strlist&#34;&gt;input&lt;/append&gt;
	&lt;append key=&#34;info.capabilities&#34; type=&#34;strlist&#34;&gt;input.mouse&lt;/append&gt;
        &lt;merge key=&#34;input.x11_driver&#34; type=&#34;string&#34;&gt;vboxmouse&lt;/merge&gt;
	&lt;merge key=&#34;input.device&#34; type=&#34;string&#34;&gt;/dev/vboxguest&lt;/merge&gt;
      &lt;/match&gt;
    &lt;/match&gt;
  &lt;/device&gt;
&lt;/deviceinfo&gt;</pre></div></div><div class=paragraph><p>Pastas compartilhadas para transferências de arquivos entre o host e a VM são acessíveis montando-as usando <code>mount_vboxvfs</code>. Uma pasta compartilhada pode ser criada no host usando a GUI do VirtualBox ou via <code>vboxmanage</code>. Por exemplo, para criar uma pasta compartilhada chamada <em>myshare</em> em <span class=filename>/mnt/bsdboxshare</span> para a VM denominada <em>BSDBox</em>, execute :</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># vboxmanage sharedfolder add &#39;BSDBox&#39; --name myshare --hostpath /mnt/bsdboxshare</span></code></pre></div></div><div class=paragraph><p>Observe que o nome da pasta compartilhada não deve conter espaços. Monte a pasta compartilhada de dentro do sistema convidado desta forma:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount_vboxvfs -w myshare /mnt</span></code></pre></div></div></div><div class=sect2><h3 id=virtualization-host-virtualbox>21.6. FreeBSD como Host com VirtualBox™<a class=anchor href=#virtualization-host-virtualbox></a></h3><div class=paragraph><p>O VirtualBox™ é um pacote de virtualização completo e ativamente desenvolvido, disponível para a maioria dos sistemas operacionais, incluindo Windows™, Mac OS™, Linux™ e FreeBSD. Ele é igualmente capaz de executar sistemas operacionais convidados como o Windows™ ou UNIX™-like. Ele é distribuído como um software de código aberto, mas com componentes de código fechado disponíveis em um pacote de extensão separado. Esses componentes incluem suporte para dispositivos USB 2.0. Maiores informações podem ser encontradas na página wiki sobre <a href=http://www.virtualbox.org/wiki/Downloads>Downloads do VirtualBox</a>. Atualmente, essas extensões não estão disponíveis para o FreeBSD.</p></div><div class=sect3><h4 id=virtualization-virtualbox-install>21.6.1. Instalando o VirtualBox™<a class=anchor href=#virtualization-virtualbox-install></a></h4><div class=paragraph><p>O VirtualBox™ está disponível como um pacote ou port do FreeBSD em <a class=package href=https://cgit.freebsd.org/ports/tree/emulators/virtualbox-ose/>emulators/virtualbox-ose</a>. O port pode ser instalado usando estes comandos:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/emulators/virtualbox-ose</span>
<span class=c># make install clean</span></code></pre></div></div><div class=paragraph><p>Uma opção útil no menu de configuração do port é o conjunto de programas <code>GuestAdditions</code>. Eles fornecem vários recursos úteis em sistemas operacionais convidados, como integração de ponteiro de mouse (permitindo que o mouse seja compartilhado entre host e o sistema convidado sem a necessidade de pressionar um atalho de teclado especial para alternar) e renderização de vídeo mais rápida, especialmente em sistemas convidados Windows™. Os complementos para os sistemas convidados estão disponíveis no menu <b class=menuref>Dispositivos</b>, após a conclusão da instalação do sistema convidado.</p></div><div class=paragraph><p>Algumas alterações de configuração são necessárias antes do VirtualBox™ ser iniciado pela primeira vez. O port instala um módulo de kernel em <span class=filename>/boot/modules</span> o qual deve ser carregado no kernel em execução:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload vboxdrv</span></code></pre></div></div><div class=paragraph><p>Para garantir que o módulo seja sempre carregado após uma reinicialização, adicione esta linha ao <span class=filename>/boot/loader.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>vboxdrv_load=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Para usar os módulos do kernel que permitem conexões de rede bridged ou host-only, adicione esta linha ao <span class=filename>/etc/rc.conf</span> e reinicie o computador:</p></div><div class="literalblock programlisting"><div class=content><pre>vboxnet_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>O grupo <code>vboxusers</code> é criado durante a instalação do VirtualBox™. Todos os usuários que precisam acessar o VirtualBox™ deverão ser adicionados como membros desse grupo. O comando <code>pw</code> pode ser usado para adicionar novos membros:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pw groupmod vboxusers -m yourusername</span></code></pre></div></div><div class=paragraph><p>As permissões padrão para o <span class=filename>/dev/vboxnetctl</span> são restritivas e precisam ser alteradas para redes em modo Bridged:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># chown root:vboxusers /dev/vboxnetctl</span>
<span class=c># chmod 0660 /dev/vboxnetctl</span></code></pre></div></div><div class=paragraph><p>Para tornar esta permissão permanente, adicione estas linhas ao <span class=filename>/etc/devfs.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>own     vboxnetctl root:vboxusers
perm    vboxnetctl 0660</pre></div></div><div class=paragraph><p>Para iniciar o VirtualBox™, digite a partir de uma sessão Xorg:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% VirtualBox</code></pre></div></div><div class=paragraph><p>Para mais informações sobre como configurar e usar o VirtualBox™, consulte o <a href=http://www.virtualbox.org>site oficial</a>. Para obter informações específicas sobre o FreeBSD e instruções para a solução de problemas, consulte a <a href=http://wiki.FreeBSD.org/VirtualBox>página relevante no wiki do FreeBSD</a>.</p></div></div><div class=sect3><h4 id=virtualization-virtualbox-usb-support>21.6.2. Suporte USB no VirtualBox™<a class=anchor href=#virtualization-virtualbox-usb-support></a></h4><div class=paragraph><p>O VirtualBox™ pode ser configurado para passar dispositivos USB para o sistema operacional convidado. O controlador host da versão do OSE está limitado a emular dispositivos USB 1.1 até que o pacote de extensão que suporta dispositivos USB 2.0 e 3.0 esteja disponível no FreeBSD.</p></div><div class=paragraph><p>Para que o VirtualBox™ esteja ciente dos dispositivos USB conectados à máquina, o usuário precisa ser um membro do grupo <code>operator</code>.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pw groupmod operator -m yourusername</span></code></pre></div></div><div class=paragraph><p>Em seguida, adicione as seguintes linhas em <span class=filename>/etc/devfs.rules</span> ou crie o arquivo se ele ainda não existir:</p></div><div class="literalblock programlisting"><div class=content><pre>[system=10]
add path &#39;usb/*&#39; mode 0660 group operator</pre></div></div><div class=paragraph><p>Em seguida, adicione as seguintes linhas ao <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>devfs_system_ruleset=&#34;system&#34;</pre></div></div><div class=paragraph><p>Então reinicie o devfs:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service devfs restart</span></code></pre></div></div><div class=paragraph><p>Reinicie a sessão de login e o VirtualBox™ para que essas alterações entrem em vigor e crie os filtros USB conforme necessário.</p></div></div><div class=sect3><h4 id=virtualization-virtualbox-host-dvd-cd-access>21.6.3. Acesso ao drive de DVD/CD no Host VirtualBox™<a class=anchor href=#virtualization-virtualbox-host-dvd-cd-access></a></h4><div class=paragraph><p>O acesso às unidades de DVD/CD do Host a partir dos convidados é obtido através do compartilhamento das unidades físicas. Dentro do VirtualBox™, isso é configurado a partir da janela Armazenamento nas Configurações da máquina virtual. Se necessário, crie primeiro um dispositivo vazio IDECD/DVD. Em seguida, escolha a unidade do host no menu pop-up para a seleção de unidade virtual de CD/DVD. Uma caixa de seleção rotulada como <code>Passthrough</code> será exibida. Isso permitirá que a máquina virtual use o hardware diretamente. Por exemplo, CDs de áudio ou o gravador só funcionará se esta opção estiver selecionada.</p></div><div class=paragraph><p>O HAL precisa ser executado para que as funções de DVD/CD do VirtualBox™ funcionem, então habilite-o no <span class=filename>/etc/rc.conf</span> e inicie-o se ele ainda não estiver em execução:</p></div><div class="literalblock programlisting"><div class=content><pre>hald_enable=&#34;YES&#34;</pre></div></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service hald start</span></code></pre></div></div><div class=paragraph><p>Para que os usuários possam usar as funções de DVD/CD do VirtualBox™, eles precisam acessar <span class=filename>/dev/xpt0</span>, <span class=filename>/dev/cdN</span>, e <span class=filename>/dev/passN</span>. Isso geralmente é obtido tornando o usuário um membro do grupo <code>operator</code>. As permissões para esses dispositivos devem ser corrigidas adicionando estas linhas ao <span class=filename>/etc/devfs.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>perm cd* 0660
perm xpt0 0660
perm pass* 0660</pre></div></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service devfs restart</span></code></pre></div></div></div></div><div class=sect2><h3 id=virtualization-host-bhyve>21.7. FreeBSD como um Host bhyve<a class=anchor href=#virtualization-host-bhyve></a></h3><div class=paragraph><p>O hypervisor bhyveBSD-licensed tornou-se parte do sistema base com o FreeBSD 10.0-RELEASE. Este hypervisor suporta uma grande variedade de sistemas operacionais convidados, incluindo FreeBSD, OpenBSD e muitas distribuições Linux™. Por padrão, o bhyve fornece acesso ao console serial e não emula um console gráfico. Os recursos de offload de virtualização das CPUs mais recentes são usados para evitar os métodos legados de tradução de instruções e de gerenciamento manual de mapeamentos de memória.</p></div><div class=paragraph><p>O design do bhyve requer um processador que suporte tabelas de páginas estendidas da Intel™ (EPT) ou a Indexação Rápida de Virtualização da AMD™ (RVI) ou Tabelas de Páginas Aninhadas (NPT). Hospedar sistemas operacionais convidados Linux™ ou convidados FreeBSD com mais de uma vCPU requer suporte a modo irrestrito de VMX (UG). A maioria dos processadores mais recentes, especificamente o Intel™Core™ i3/i5/i7 e o Intel™Xeon™ E3/E5/E7, suportam esses recursos. O suporte UG foi introduzido com a microarquitetura Westmere da Intel. Para obter uma lista completa dos processadores Intel™ que suportam EPT, consulte <a href="https://ark.intel.com/content/www/us/en/ark/search/featurefilter.html?productType=873&amp;0_ExtendedPageTables=True" class=bare>https://ark.intel.com/content/www/us/en/ark/search/featurefilter.html?productType=873&amp;0_ExtendedPageTables=True</a>. O RVI é encontrado na terceira geração e depois nos processadores AMD Opteron™ (Barcelona). A maneira mais fácil de saber se um processador suporta o bhyve é executar o <code>dmesg</code> ou procurar no <span class=filename>/var/run/dmesg.boot</span> pelo o Sinalizador de recurso do processador <code>POPCNT</code> na linha <code>Features2</code> para processadores AMD™ ou <code>EPT</code> e <code>UG</code> na linha <code>VT-x</code> para os processadores Intel™.</p></div><div class=sect3><h4 id=virtualization-bhyve-prep>21.7.1. Preparando o host<a class=anchor href=#virtualization-bhyve-prep></a></h4><div class=paragraph><p>O primeiro passo para criar uma máquina virtual no bhyve é configurar o sistema host. Primeiro, carregue o módulo do kernel bhyve:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload vmm</span></code></pre></div></div><div class=paragraph><p>Em seguida, crie uma interface <span class=filename>tap</span> para o dispositivo de rede na máquina virtual para anexar. Para que o dispositivo de rede participe da rede, crie também uma interface de bridge contendo a interface <span class=filename>tap</span> e a interface física como membros. Neste exemplo, a interface física é <em>igb0</em>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig tap0 create</span>
<span class=c># sysctl net.link.tap.up_on_open=1</span>
net.link.tap.up_on_open: 0 -&gt; 1
<span class=c># ifconfig bridge0 create</span>
<span class=c># ifconfig bridge0 addm igb0 addm tap0</span>
<span class=c># ifconfig bridge0 up</span></code></pre></div></div></div><div class=sect3><h4 id=virtualization-bhyve-freebsd>21.7.2. Criando um Sistema Operacional Convidado do FreeBSD<a class=anchor href=#virtualization-bhyve-freebsd></a></h4><div class=paragraph><p>Crie um arquivo para usar como o disco virtual da máquina convidada. Especifique o tamanho e o nome do disco virtual:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># truncate -s 16G guest.img</span></code></pre></div></div><div class=paragraph><p>Baixe uma imagem de instalação do FreeBSD para instalar:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># fetch ftp://ftp.freebsd.org/pub/FreeBSD/releases/ISO-IMAGES/10.3/FreeBSD-10.3-RELEASE-amd64-bootonly.iso</span>
FreeBSD-10.3-RELEASE-amd64-bootonly.iso       100% of  230 MB  570 kBps 06m17s</code></pre></div></div><div class=paragraph><p>O FreeBSD vem com um script de exemplo para executar uma máquina virtual com o bhyve. O script iniciará a máquina virtual e a executará em um loop, para que ela seja reiniciada automaticamente se houver falha. O script usa várias opções para controlar a configuração da máquina: <code>-c</code> controla o número de CPUs virtuais, <code>-m</code> limita a quantidade de memória disponível para o sistema operacional convidado, <code>-t</code> define qual dispositivo <span class=filename>tap</span> usar, <code>-d</code> indica qual imagem de disco usar, <code>-i</code> indica ao bhyve para inicializar a partir da imagem CD em vez do disco, e <code>-I</code> define qual imagem de CD deve ser usada. O último parâmetro é o nome da máquina virtual, usada para rastrear as máquinas em execução. Este exemplo inicia a máquina virtual no modo de instalação:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sh /usr/shared/examples/bhyve/vmrun.sh -c 1 -m 1024M -t tap0 -d guest.img -i -I FreeBSD-10.3-RELEASE-amd64-bootonly.iso guestname</span></code></pre></div></div><div class=paragraph><p>A máquina virtual inicializará e iniciará o instalador. Depois de instalar um sistema na máquina virtual, quando o sistema perguntar sobre a inserção em um shell no final da instalação, escolha <b class=button>Yes</b>.</p></div><div class=paragraph><p>Reinicialize a máquina virtual. Enquanto a reinicialização da máquina virtual fará o bhyve finalizar, o script <span class=filename>vmrun.sh</span> executa o <code>bhyve</code> em um loop e o reiniciará automaticamente. Quando isso acontecer, escolha a opção de reinicialização no menu do carregador de inicialização para escapar do loop. Agora o convidado pode ser iniciado a partir do disco virtual:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sh /usr/shared/examples/bhyve/vmrun.sh -c 4 -m 1024M -t tap0 -d guest.img guestname</span></code></pre></div></div></div><div class=sect3><h4 id=virtualization-bhyve-linux>21.7.3. Criando um Sistema Operacional convidado Linux™<a class=anchor href=#virtualization-bhyve-linux></a></h4><div class=paragraph><p>Para inicializar sistemas operacionais diferentes do FreeBSD, o port <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/grub2-bhyve/>sysutils/grub2-bhyve</a> deve ser instalada primeiro.</p></div><div class=paragraph><p>Em seguida, crie um arquivo para usar como o disco virtual da máquina convidada:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># truncate -s 16G linux.img</span></code></pre></div></div><div class=paragraph><p>Iniciar uma máquina virtual com o bhyve é um processo de duas etapas. Primeiro um kernel deve ser carregado, então o sistema operacional convidado pode ser iniciado. O kernel Linux™ é carregado com o <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/grub2-bhyve/>sysutils/grub2-bhyve</a>. Crie um <span class=filename>device.map</span> que o grub usará para mapear os dispositivos virtuais para os arquivos no sistema host:</p></div><div class="literalblock programlisting"><div class=content><pre>(hd0) ./linux.img
(cd0) ./somelinux.iso</pre></div></div><div class=paragraph><p>Use o <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/grub2-bhyve/>sysutils/grub2-bhyve</a> para carregar o kernel Linux™ de uma imagem ISO:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># grub-bhyve -m device.map -r cd0 -M 1024M linuxguest</span></code></pre></div></div><div class=paragraph><p>Isto irá iniciar o grub. Se o CD de instalação contiver um <span class=filename>grub.cfg</span>, um menu será exibido. Caso contrário, os arquivos <code>vmlinuz</code> e <code>initrd</code> devem ser localizados e carregados manualmente:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>grub&gt; <span class=nb>ls</span>
<span class=o>(</span>hd0<span class=o>)</span> <span class=o>(</span>cd0<span class=o>)</span> <span class=o>(</span>cd0,msdos1<span class=o>)</span> <span class=o>(</span>host<span class=o>)</span>
grub&gt; <span class=nb>ls</span> <span class=o>(</span>cd0<span class=o>)</span>/isolinux
boot.cat boot.msg grub.conf initrd.img isolinux.bin isolinux.cfg memtest
splash.jpg TRANS.TBL vesamenu.c32 vmlinuz
grub&gt; linux <span class=o>(</span>cd0<span class=o>)</span>/isolinux/vmlinuz
grub&gt; initrd <span class=o>(</span>cd0<span class=o>)</span>/isolinux/initrd.img
grub&gt; boot</code></pre></div></div><div class=paragraph><p>Agora que o kernel Linux™ está carregado, o sistema convidado pode ser iniciado:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># bhyve -A -H -P -s 0:0,hostbridge -s 1:0,lpc -s 2:0,virtio-net,tap0 -s 3:0,virtio-blk,./linux.img \</span>
    <span class=nt>-s</span> 4:0,ahci-cd,./somelinux.iso <span class=nt>-l</span> com1,stdio <span class=nt>-c</span> 4 <span class=nt>-m</span> 1024M linuxguest</code></pre></div></div><div class=paragraph><p>O sistema inicializará e iniciará o instalador. Depois de instalar um sistema na máquina virtual, reinicialize a máquina virtual. Isso fará com que o bhyve seja encerrado. A instância da máquina virtual precisa ser destruída antes de poder ser iniciada novamente:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># bhyvectl --destroy --vm=linuxguest</span></code></pre></div></div><div class=paragraph><p>Agora, o sistema convidado pode ser iniciado diretamente do disco virtual. Carregue o kernel:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># grub-bhyve -m device.map -r hd0,msdos1 -M 1024M linuxguest</span>
grub&gt; <span class=nb>ls</span>
<span class=o>(</span>hd0<span class=o>)</span> <span class=o>(</span>hd0,msdos2<span class=o>)</span> <span class=o>(</span>hd0,msdos1<span class=o>)</span> <span class=o>(</span>cd0<span class=o>)</span> <span class=o>(</span>cd0,msdos1<span class=o>)</span> <span class=o>(</span>host<span class=o>)</span>
<span class=o>(</span>lvm/VolGroup-lv_swap<span class=o>)</span> <span class=o>(</span>lvm/VolGroup-lv_root<span class=o>)</span>
grub&gt; <span class=nb>ls</span> <span class=o>(</span>hd0,msdos1<span class=o>)</span>/
lost+found/ grub/ efi/ System.map-2.6.32-431.el6.x86_64 config-2.6.32-431.el6.x
86_64 symvers-2.6.32-431.el6.x86_64.gz vmlinuz-2.6.32-431.el6.x86_64
initramfs-2.6.32-431.el6.x86_64.img
grub&gt; linux <span class=o>(</span>hd0,msdos1<span class=o>)</span>/vmlinuz-2.6.32-431.el6.x86_64 <span class=nv>root</span><span class=o>=</span>/dev/mapper/VolGroup-lv_root
grub&gt; initrd <span class=o>(</span>hd0,msdos1<span class=o>)</span>/initramfs-2.6.32-431.el6.x86_64.img
grub&gt; boot</code></pre></div></div><div class=paragraph><p>Inicialize a máquina virtual:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># bhyve -A -H -P -s 0:0,hostbridge -s 1:0,lpc -s 2:0,virtio-net,tap0 \</span>
    <span class=nt>-s</span> 3:0,virtio-blk,./linux.img <span class=nt>-l</span> com1,stdio <span class=nt>-c</span> 4 <span class=nt>-m</span> 1024M linuxguest</code></pre></div></div><div class=paragraph><p>O Linux™ iniciará agora na máquina virtual e, eventualmente, apresentará o prompt de login. Faça o login e use a máquina virtual. Quando terminar, reinicialize a máquina virtual para sair do bhyve. Destrua a instância da máquina virtual:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># bhyvectl --destroy --vm=linuxguest</span></code></pre></div></div></div><div class=sect3><h4 id=virtualization-bhyve-uefi>21.7.4. Inicializando máquinas virtuais bhyve com Firmware UEFI<a class=anchor href=#virtualization-bhyve-uefi></a></h4><div class=paragraph><p>Além do bhyveload e do grub-bhyve, o hypervisor bhyve também pode inicializar máquinas virtuais usando o firmware do espaço de usuário UEFI . Esta opção pode suportar sistemas operacionais convidados que não são suportados pelos outros carregadores.</p></div><div class=paragraph><p>Para utilizar o suporte ao UEFI no bhyve, primeiro obtenha as imagens de firmware UEFI. Isto pode ser feito instalando o port ou pacote <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/bhyve-firmware/>sysutils/bhyve-firmware</a>.</p></div><div class=paragraph><p>Com o firmware no lugar, adicione os sinalizadores <code>-l bootrom,<em>/path/to/firmware</em></code> à linha de comando do bhyve. A sintaxe real do bhyve pode se parecer com a seguinte:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># bhyve -AHP -s 0:0,hostbridge -s 1:0,lpc \</span>
<span class=nt>-s</span> 2:0,virtio-net,tap1 <span class=nt>-s</span> 3:0,virtio-blk,./disk.img <span class=se>\</span>
<span class=nt>-s</span> 4:0,ahci-cd,./install.iso <span class=nt>-c</span> 4 <span class=nt>-m</span> 1024M <span class=se>\</span>
<span class=nt>-l</span> bootrom,/usr/local/shared/uefi-firmware/BHYVE_UEFI.fd <span class=se>\</span>
guest</code></pre></div></div><div class=paragraph><p>O <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/bhyve-firmware/>sysutils/bhyve-firmware</a> também contém um firmware habilitado para CSM, para inicializar sistemas operacionais hóspedes sem suporte à UEFI no modo de BIOS legado:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># bhyve -AHP -s 0:0,hostbridge -s 1:0,lpc \</span>
<span class=nt>-s</span> 2:0,virtio-net,tap1 <span class=nt>-s</span> 3:0,virtio-blk,./disk.img <span class=se>\</span>
<span class=nt>-s</span> 4:0,ahci-cd,./install.iso <span class=nt>-c</span> 4 <span class=nt>-m</span> 1024M <span class=se>\</span>
<span class=nt>-l</span> bootrom,/usr/local/shared/uefi-firmware/BHYVE_UEFI_CSM.fd <span class=se>\</span>
guest</code></pre></div></div></div><div class=sect3><h4 id=virtualization-bhyve-framebuffer>21.7.5. Framebuffer UEFI Gráfico para bhyve<a class=anchor href=#virtualization-bhyve-framebuffer></a></h4><div class=paragraph><p>O suporte ao firmware UEFI é particularmente útil em sistemas operacionais convidados predominantemente gráficos, como o Microsoft Windows™.</p></div><div class=paragraph><p>O suporte para o framebuffer UEFI-GOP também pode ser ativado com os sinalizadores <code>-s 29,fbuf,tcp=<em>0.0.0.0:5900</em></code>. A resolução do framebuffer pode ser configurada com <code>w=<em>800</em></code> e <code>h=<em>600</em></code> e o bhyve pode ser instruído para aguardar uma conexão VNC antes de inicializar o sistema operacional convidado adicionando <code>wait</code>. O framebuffer pode ser acessado pelo host ou pela rede através do protocolo VNC. Além disso, <code>-s 30,xhci,tablet</code> pode ser adicionado para obter a sincronização precisa do cursor do mouse com o host.</p></div><div class=paragraph><p>O comando bhyve resultante ficaria assim:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># bhyve -AHP -s 0:0,hostbridge -s 31:0,lpc \</span>
<span class=nt>-s</span> 2:0,virtio-net,tap1 <span class=nt>-s</span> 3:0,virtio-blk,./disk.img <span class=se>\</span>
<span class=nt>-s</span> 4:0,ahci-cd,./install.iso <span class=nt>-c</span> 4 <span class=nt>-m</span> 1024M <span class=se>\</span>
<span class=nt>-s</span> 29,fbuf,tcp<span class=o>=</span>0.0.0.0:5900,w<span class=o>=</span>800,h<span class=o>=</span>600,wait <span class=se>\</span>
<span class=nt>-s</span> 30,xhci,tablet <span class=se>\</span>
<span class=nt>-l</span> bootrom,/usr/local/share/uefi-firmware/BHYVE_UEFI.fd <span class=se>\</span>
guest</code></pre></div></div><div class=paragraph><p>Observe que, no modo de emulação do BIOS, o framebuffer deixará de receber atualizações quando o controle for passado do firmware para o sistema operacional convidado.</p></div></div><div class=sect3><h4 id=virtualization-bhyve-zfs>21.7.6. Usando o ZFS com os sistemas operacionais convidados no bhyve<a class=anchor href=#virtualization-bhyve-zfs></a></h4><div class=paragraph><p>Se o ZFS estiver disponível na máquina host, o uso de volumes ZFS em vez de arquivos de imagem de disco pode fornecer benefícios significativos de desempenho para as VMs convidadas. Um volume ZFS pode ser criado por:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs create -V16G -o volmode=dev zroot/linuxdisk0</span></code></pre></div></div><div class=paragraph><p>Ao iniciar a VM, especifique o volume ZFS como a unidade de disco:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># bhyve -A -H -P -s 0:0,hostbridge -s 1:0,lpc -s 2:0,virtio-net,tap0 -s3:0,virtio-blk,/dev/zvol/zroot/linuxdisk0 \</span>
    <span class=nt>-l</span> com1,stdio <span class=nt>-c</span> 4 <span class=nt>-m</span> 1024M linuxguest</code></pre></div></div></div><div class=sect3><h4 id=virtualization-bhyve-nmdm>21.7.7. Consoles de máquinas virtuais<a class=anchor href=#virtualization-bhyve-nmdm></a></h4><div class=paragraph><p>É vantajoso executar o console do bhyve em uma ferramenta de gerenciamento de sessão, como o <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/tmux/>sysutils/tmux</a> ou <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/screen/>sysutils/screen</a>, para que possa desanexar e reanexar o console. Também é possível ter o console do bhyve como um dispositivo de modem nulo o qual pode ser acessado com o comando <code>cu</code>. Para fazer isso, carregue o módulo do kernel <span class=filename>nmdm</span> e substitua <code>-l com1,stdio</code> with <code>-l com1,/dev/nmdm0A</code>. Os dispositivos <span class=filename>/dev/nmdm</span> são criados automaticamente conforme necessário, onde cada um é um par, correspondente às duas extremidades do cabo de modem nulo (<span class=filename>/dev/nmdm0A</span> e <span class=filename>/dev/nmdm0B</span>). Veja <a href="https://man.freebsd.org/cgi/man.cgi?query=nmdm&amp;sektion=4&amp;format=html">nmdm(4)</a> para maiores informações.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload nmdm</span>
<span class=c># bhyve -A -H -P -s 0:0,hostbridge -s 1:0,lpc -s 2:0,virtio-net,tap0 -s 3:0,virtio-blk,./linux.img \</span>
    <span class=nt>-l</span> com1,/dev/nmdm0A <span class=nt>-c</span> 4 <span class=nt>-m</span> 1024M linuxguest
<span class=c># cu -l /dev/nmdm0B</span>
Connected

Ubuntu 13.10 handbook ttyS0

handbook login:</code></pre></div></div></div><div class=sect3><h4 id=virtualization-bhyve-managing>21.7.8. Gerenciando Máquinas Virtuais<a class=anchor href=#virtualization-bhyve-managing></a></h4><div class=paragraph><p>Um nó de dispositivo é criado em <span class=filename>/dev/vmm</span> para cada máquina virtual. Isso permite que o administrador veja facilmente uma lista das máquinas virtuais em execução:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ls -al /dev/vmm</span>
total 1
dr-xr-xr-x   2 root  wheel    512 Mar 17 12:19 ./
dr-xr-xr-x  14 root  wheel    512 Mar 17 06:38 ../
crw-------   1 root  wheel  0x1a2 Mar 17 12:20 guestname
crw-------   1 root  wheel  0x19f Mar 17 12:19 linuxguest
crw-------   1 root  wheel  0x1a1 Mar 17 12:19 otherguest</code></pre></div></div><div class=paragraph><p>Uma máquina virtual especificada pode ser destruída usando <code>bhyvectl</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># bhyvectl --destroy --vm=guestname</span></code></pre></div></div></div><div class=sect3><h4 id=virtualization-bhyve-onboot>21.7.9. Configuração Persistente<a class=anchor href=#virtualization-bhyve-onboot></a></h4><div class=paragraph><p>Para configurar o sistema para iniciar os sistemas operacionais convidados do bhyve no momento da inicialização, as seguintes configurações devem ser feitas nos arquivos especificados:</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p><span class=filename>/etc/sysctl.conf</span></p><div class="literalblock programlisting"><div class=content><pre>net.link.tap.up_on_open=1</pre></div></div></li><li><p><span class=filename>/etc/rc.conf</span></p><div class="literalblock programlisting"><div class=content><pre>cloned_interfaces=&#34;bridge0 tap0&#34;
ifconfig_bridge0=&#34;addm igb0 addm tap0&#34;
kld_list=&#34;nmdm vmm&#34;</pre></div></div></li></ol></div></div></div></div></div><div class=sect2><h3 id=virtualization-host-xen>21.8. FreeBSD como Host Xen™<a class=anchor href=#virtualization-host-xen></a></h3><div class=paragraph><p>O Xen é um <a href=https://en.wikipedia.org/wiki/Hypervisor#Classification>hypervisor tipo 1</a> licenciado sob a GPLv2 para arquiteturas Intel™ e ARM™. O FreeBSD suporta domínios não privilegiados (máquina virtual) nas plataformas i386™ e AMD™ 64-Bit <a href=https://wiki.xenproject.org/wiki/DomU>DomU</a> e <a href=https://en.wikipedia.org/wiki/Amazon_Elastic_Compute_Cloud>Amazon EC2</a> desde o FreeBSD 8.0 e incluiu o suporte ao domínio de controle Dom0 (host) no FreeBSD 11.0. O suporte para domínios para-virtualizados (PV) foi removido do FreeBSD 11 em favor de domínios virtualizados de hardware (HVM), o que proporciona melhor desempenho.</p></div><div class=paragraph><p>O Xen™ é um hypervisor bare-metal, o que significa que é o primeiro programa carregado após o BIOS. Um convidado especial privilegiado chamado Domain-0 (<code>Dom0</code> para abreviar) é então iniciado. O Dom0 usa seus privilégios especiais para acessar diretamente o hardware físico subjacente, tornando-o uma solução de alto desempenho. Ele é capaz de acessar os controladores de disco e adaptadores de rede diretamente. As ferramentas de gerenciamento do Xen™ para gerenciar e controlar o hypervisor Xen™ também são usadas pelo Dom0 para criar, listar e destruir VMs. Dom0 fornece discos virtuais e recursos de rede para domínios sem privilégios, geralmente chamados de <code>DomU</code>. O Xen™ Dom0 pode ser comparado ao console de serviço de outras soluções de hypervisor , enquanto o DomU é onde as VMs convidadas são executadas.</p></div><div class=paragraph><p>O Xen™ pode migrar VMs entre diferentes servidores Xen™. Quando os dois hosts xen compartilham o mesmo armazenamento subjacente, a migração pode ser feita sem a necessidade de primeiro desligar a VM. Em vez disso, a migração é executada ao vivo enquanto o DomU está em execução e não há necessidade de reiniciá-lo ou planejar um tempo de inatividade. Isso é útil em cenários de manutenção ou em janelas de atualização para garantir que os serviços fornecidos pelo DomU continuem disponiveis. Muitos outros recursos do Xen™ estão listados na <a href=https://wiki.xenproject.org/wiki/Category:Overview>página wiki com a visão global sobre o Xen</a>. Note que ainda nem todos os recursos são suportados no FreeBSD.</p></div><div class=sect3><h4 id=virtualization-host-xen-requirements>21.8.1. Requisitos de hardware para o Xen™ Dom0<a class=anchor href=#virtualization-host-xen-requirements></a></h4><div class=paragraph><p>Para executar o hypervisor Xen™ em um host, são necessárias certas funcionalidades de hardware. Os domínios virtualizados de hardware requerem o suporte à Tabela de Páginas Estendidas (<a href=http://en.wikipedia.org/wiki/Extended_Page_Table>EPT</a>) e à Unidade de Gerenciamento de Memória de Entrada / Saída (<a href=http://en.wikipedia.org/wiki/List_of_IOMMU-supporting_hardware>IOMMU</a>) no processador do host.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Para executar um Xen™ Dom0 no FreeBSD, a maquina deve ser inicializada usando o boot legado (BIOS).</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=virtualization-host-xen-dom0-setup>21.8.2. Configuração do Xen™ Dom0 Domínio de Controle<a class=anchor href=#virtualization-host-xen-dom0-setup></a></h4><div class=paragraph><p>Os usuários do FreeBSD 11 devem instalar os pacotes <a class=package href=https://cgit.freebsd.org/ports/tree/emulators/xen-kernel47/>emulators/xen-kernel47</a> e <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/xen-tools47/>sysutils/xen-tools47</a> que são baseados no Xen versão 4.7. Sistemas rodando o FreeBSD-12.0 ou mais novo podem usar o Xen 4.11 fornecido por <a class=package href=https://cgit.freebsd.org/ports/tree/emulators/xen-kernel411/>emulators/xen-kernel411</a> e <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/xen-tools411/>sysutils/xen-tools411</a>, respectivamente.</p></div><div class=paragraph><p>Os arquivos de configuração devem ser editados para preparar o host para a integração do Dom0 após a instalação dos pacotes do Xen. Uma entrada para <span class=filename>/etc/sysctl.conf</span> desabilita o limite de quantas páginas de memória podem ser conectadas. Caso contrário, as VMs do DomU com requisitos de memória mais altos não serão executadas.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># echo &#39;vm.max_wired=-1&#39; &gt;&gt; /etc/sysctl.conf</span></code></pre></div></div><div class=paragraph><p>Outra configuração relacionada à memória envolve a alteração do <span class=filename>/etc/login.conf</span>, configurando a opção <code>memorylocked</code> para <code>unlimited</code>. Caso contrário, a criação de domínios DomU poderá falhar com erros <code>Cannot allocate memory</code>. Depois de fazer a mudança no <span class=filename>/etc/login.conf</span>, execute o comando <code>cap_mkdb</code> para atualizar o banco de dados de recursos. Veja <a href=./#security-resourcelimits>Limites de Recursos</a> para detalhes.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sed -i &#39;&#39; -e &#39;s/memorylocked=64K/memorylocked=unlimited/&#39; /etc/login.conf</span>
<span class=c># cap_mkdb /etc/login.conf</span></code></pre></div></div><div class=paragraph><p>Adicione uma entrada para o console do Xen™ ao <span class=filename>/etc/ttys</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># echo &#39;xc0     &#34;/usr/libexec/getty Pc&#34;         xterm   onifconsole  secure&#39; &gt;&gt; /etc/ttys</span></code></pre></div></div><div class=paragraph><p>A seleção de um kernel Xen™ no <span class=filename>/boot/loader.conf</span> ativa o Dom0. O Xen™ também requer recursos como CPU e memória da máquina host para ele mesmo e para outros domínios DomU. Quanto de CPU e memória depende dos requisitos individuais e das capacidades de hardware. Neste exemplo, 8 GB de memória e 4 CPUs virtuais são disponibilizados para o Dom0. O console serial também é ativado e as opções de log são definidas.</p></div><div class=paragraph><p>O seguinte comando é usado para pacotes Xen 4.7:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysrc -f /boot/loader.conf hw.pci.mcfg=0</span>
<span class=c># sysrc -f /boot/loader.conf if_tap_load=&#34;YES&#34;</span>
<span class=c># sysrc -f /boot/loader.conf xen_kernel=&#34;/boot/xen&#34;</span>
<span class=c># sysrc -f /boot/loader.conf xen_cmdline=&#34;dom0_mem=8192M dom0_max_vcpus=4 dom0pvh=1 console=com1,vga com1=115200,8n1 guest_loglvl=all loglvl=all&#34;</span></code></pre></div></div><div class=paragraph><p>Para as versões Xen 4.11 e superiores, o seguinte comando deve ser usado:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysrc -f /boot/loader.conf if_tap_load=&#34;YES&#34;</span>
<span class=c># sysrc -f /boot/loader.conf xen_kernel=&#34;/boot/xen&#34;</span>
<span class=c># sysrc -f /boot/loader.conf xen_cmdline=&#34;dom0_mem=8192M dom0_max_vcpus=4 dom0=pvh console=com1,vga com1=115200,8n1 guest_loglvl=all loglvl=all&#34;</span></code></pre></div></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Os arquivos de log criados pelo Xen™ para as VMs do DomU são armazenados em <span class=filename>/var/log/xen</span>. Por favor, certifique-se de verificar o conteúdo do diretório em caso de problemas.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Ative o serviço xencommons durante a inicialização do sistema:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysrc xencommons_enable=yes</span></code></pre></div></div><div class=paragraph><p>Essas configurações são suficientes para iniciar um sistema habilitado para Dom0. No entanto, falta a funcionalidade de rede para as máquinas DomU. Para corrigir isso, defina uma interface em bridge com a NIC principal do sistema que as VMs DomU poderão usar para se conectar à rede. Substitua <em>em0</em> pelo nome da interface de rede do host.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysrc cloned_interfaces=&#34;bridge0&#34;</span>
<span class=c># sysrc ifconfig_bridge0=&#34;addm em0 SYNCDHCP&#34;</span>
<span class=c># sysrc ifconfig_em0=&#34;up&#34;</span></code></pre></div></div><div class=paragraph><p>Reinicie o host para carregar o kernel Xen™ e inicie o Dom0.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># reboot</span></code></pre></div></div><div class=paragraph><p>Após inicializar com sucesso o kernel Xen™ e efetuar login no sistema novamente, a ferramenta de gerenciamento do Xen™, <code>xl</code> é usada para mostrar informações sobre os domínios.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># xl list</span>
Name                                        ID   Mem VCPUs      State   Time<span class=o>(</span>s<span class=o>)</span>
Domain-0                                     0  8192     4     r-----     962.0</code></pre></div></div><div class=paragraph><p>A saída confirma que o Dom0 (chamado <code>Domain-0</code>) tem o ID <code>0</code> e está em execução. Ele também possui a memória e as CPUs virtuais que foram definidas anteriormente no <span class=filename>/boot/loader.conf</span>. Mais informações podem ser encontradas na <a href=https://www.xenproject.org/help/documentation.html>Documentação do Xen</a>. Agora as VMs convidadas do DomU podem ser criadas.</p></div></div><div class=sect3><h4 id=virtualization-host-xen-domu-setup>21.8.3. Configuração da VM Convidada Xen™ DomU<a class=anchor href=#virtualization-host-xen-domu-setup></a></h4><div class=paragraph><p>Domínios desprivilegiados consistem em um arquivo de configuração e discos rígidos virtuais ou físicos. Os discos virtuais para armazenamento do DomU podem ser arquivos criados pelo <a href="https://man.freebsd.org/cgi/man.cgi?query=truncate&amp;sektion=1&amp;format=html">truncate(1)</a> ou volumes ZFS, conforme descrito em <a href=./#zfs-zfs-volume>Criando e Destruindo Volumes</a>. Neste exemplo, um volume de 20 GB é usado. Uma VM é criada com o volume ZFS, uma imagem ISO do FreeBSD, 1 GB de RAM e duas CPUs virtuais. O arquivo ISO de instalação é obtido com o <a href="https://man.freebsd.org/cgi/man.cgi?query=fetch&amp;sektion=1&amp;format=html">fetch(1)</a> e salvo localmente em um arquivo chamado <span class=filename>freebsd.iso</span>.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># fetch ftp://ftp.freebsd.org/pub/FreeBSD/releases/ISO-IMAGES/12.0/FreeBSD-12.0-RELEASE-amd64-bootonly.iso -o freebsd.iso</span></code></pre></div></div><div class=paragraph><p>Um volume de 20 GB do ZFS chamado <span class=filename>xendisk0</span> é criado para servir como espaço em disco para a VM.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zfs create -V20G -o volmode=dev zroot/xendisk0</span></code></pre></div></div><div class=paragraph><p>A nova VM DomU convidada é definida em um arquivo. Algumas definições específicas, como nome, mapa de teclado e detalhes da conexão VNC, também são definidas. O seguinte <span class=filename>freebsd.cfg</span> contém uma configuração mínima de DomU para este exemplo:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cat freebsd.cfg</span>
builder <span class=o>=</span> <span class=s2>&#34;hvm&#34;</span> <i class=conum data-value=1></i><b>(1)</b>
name <span class=o>=</span> <span class=s2>&#34;freebsd&#34;</span> <i class=conum data-value=2></i><b>(2)</b>
memory <span class=o>=</span> 1024 <i class=conum data-value=3></i><b>(3)</b>
vcpus <span class=o>=</span> 2 <i class=conum data-value=4></i><b>(4)</b>
vif <span class=o>=</span> <span class=o>[</span> <span class=s1>&#39;mac=00:16:3E:74:34:32,bridge=bridge0&#39;</span> <span class=o>]</span> <i class=conum data-value=5></i><b>(5)</b>
disk <span class=o>=</span> <span class=o>[</span>
<span class=s1>&#39;/dev/zvol/tank/xendisk0,raw,hda,rw&#39;</span>, <i class=conum data-value=6></i><b>(6)</b>
<span class=s1>&#39;/root/freebsd.iso,raw,hdc:cdrom,r&#39;</span> <i class=conum data-value=7></i><b>(7)</b>
  <span class=o>]</span>
vnc <span class=o>=</span> 1 <i class=conum data-value=8></i><b>(8)</b>
vnclisten <span class=o>=</span> <span class=s2>&#34;0.0.0.0&#34;</span>
serial <span class=o>=</span> <span class=s2>&#34;pty&#34;</span>
usbdevice <span class=o>=</span> <span class=s2>&#34;tablet&#34;</span></code></pre></div></div><div class=paragraph><p>Estas linhas são explicadas com mais detalhes:</p></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>Isso define que tipo de virtualização usar. <code>hvm</code> refere-se à virtualização assistida por hardware ou à máquina virtual de hardware. Os sistemas operacionais convidados podem ser executados sem modificação em CPUs com extensões de virtualização, fornecendo quase o mesmo desempenho que a execução em hardware físico. <code>generic</code> é o valor padrão e cria um domínio PV.</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td>Nome desta máquina virtual para distingui-la de outras executadas no mesmo Dom0. Requerido.</td></tr><tr><td><i class=conum data-value=3></i><b>3</b></td><td>Quantidade de RAM em megabytes para disponibilizar para a VM. Esse valor é subtraído da memória total disponível do hypervisor, não da memória do Dom0.</td></tr><tr><td><i class=conum data-value=4></i><b>4</b></td><td>Número de CPUs virtuais disponíveis para a VM convidada. Para um melhor desempenho, não crie convidados com mais CPUs virtuais do que o número de CPUs físicas no host.</td></tr><tr><td><i class=conum data-value=5></i><b>5</b></td><td>Adaptador de rede virtual. Esta é a bridge conectada à interface de rede do host. O parâmetro <code>mac</code> é o endereço MAC definido na interface de rede virtual. Este parâmetro é opcional, se nenhum MAC for fornecido, o Xen™ irá gerar um aleatório.</td></tr><tr><td><i class=conum data-value=6></i><b>6</b></td><td>Caminho completo para o disco, arquivo ou volume ZFS do armazenamento em disco para essa VM. As opções e as várias definições de disco são separadas por vírgulas.</td></tr><tr><td><i class=conum data-value=7></i><b>7</b></td><td>Define o meio de inicialização a partir do qual o sistema operacional inicial é instalado. Neste exemplo, é a imagem ISO baixada anteriormente. Consulte a documentação do Xen™ para outros tipos de dispositivos e outras opções para configurar.</td></tr><tr><td><i class=conum data-value=8></i><b>8</b></td><td>Opções que controlam a conectividade do VNC para o console serial do DomU. Em ordem, estes são: ativa suporte ao VNC, define o endereço IP no qual escutar, device node para o console serial e o método de entrada para posicionamento preciso do mouse e outros métodos de entrada. <code>keymap</code> define qual mapa de teclas usar, sendo <code>english</code> por padrão.</td></tr></tbody></table></div><div class=paragraph><p>Após o arquivo ter sido criado com todas as opções necessárias, o DomU é criado passando-o como um parâmetro para o comando <code>xl create</code>.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># xl create freebsd.cfg</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Cada vez que o Dom0 é reiniciado, o arquivo de configuração deve ser passado para <code>xl create</code> novamente para recriar o DomU. Por padrão, somente o Dom0 é criado após uma reinicialização, não as VMs individuais. As VMs podem continuar de onde pararam, pois armazenaram o sistema operacional no disco virtual. A configuração da máquina virtual pode mudar com o tempo (por exemplo, ao adicionar mais memória). Os arquivos de configuração da máquina virtual devem ter um backup e manter-se disponíveis para poder recriar a VM convidada quando necessário.</p></div></td></tr></tbody></table></div><div class=paragraph><p>A saída de <code>xl list</code> confirma que o DomU foi criado.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># xl list</span>
Name                                        ID   Mem VCPUs      State   Time<span class=o>(</span>s<span class=o>)</span>
Domain-0                                     0  8192     4     r-----  1653.4
freebsd                                      1  1024     1     <span class=nt>-b----</span>   663.9</code></pre></div></div><div class=paragraph><p>Para iniciar a instalação do sistema operacional base, inicie o cliente VNC, direcionando-o para o endereço de rede principal do host ou para o endereço IP definido na linha <code>vnclisten</code> do <span class=filename>freebsd.cfg</span>. Depois que o sistema operacional tiver sido instalado, desligue o DomU e desconecte o visualizador VNC. Edite o <span class=filename>freebsd.cfg</span>, removendo a linha com a definição <code>cdrom</code> ou comentando-a inserindo um caractere <code>#</code> no início da linha. Para carregar esta nova configuração, é necessário remover o DomU antigo com <code>xl destroy</code>, passando o nome ou o id como parâmetro. Depois, recrie-o usando o <span class=filename>freebsd.cfg</span> modificado.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># xl destroy freebsd</span>
<span class=c># xl create freebsd.cfg</span></code></pre></div></div><div class=paragraph><p>A máquina pode então ser acessada novamente usando o visualizador VNC. Desta vez, ele será inicializado a partir do disco virtual em que o sistema operacional foi instalado e pode ser usado como uma máquina virtual.</p></div></div><div class=sect3><h4 id=virtualization-host-xen-troubleshooting>21.8.4. Solução de problemas<a class=anchor href=#virtualization-host-xen-troubleshooting></a></h4><div class=paragraph><p>Esta seção contém informações básicas para ajudar a solucionar problemas encontrados ao usar o FreeBSD como host ou convidado do Xen™.</p></div><div class=sect4><h5 id=virtualization-host-xen-troubleshooting-host>21.8.4.1. Solução de problemas de inicialização do host<a class=anchor href=#virtualization-host-xen-troubleshooting-host></a></h5><div class=paragraph><p>Observe que as dicas de solução de problemas a seguir são destinadas ao Xen™ 4.11 ou mais recente. Se você ainda estiver usando o Xen™ 4.7 e tendo problemas, considere migrar para uma versão mais recente do Xen™.</p></div><div class=paragraph><p>Para solucionar problemas de inicialização do host, você provavelmente precisará de um cabo serial ou de um cabo USB de depuração. Uma saída de boot verbosa do Xen™ pode ser obtida adicionando-se parametros à opção <code>xen_cmdline</code> encontrada no <span class=filename>loader.conf</span>. Alguns parametros de depuração relevantes são:</p></div><div class=ulist><ul><li><p><code>iommu=debug</code>: pode ser usado para imprimir informações de diagnóstico adicionais sobre o iommu.</p></li><li><p><code>dom0=verbose</code>: pode ser usado para imprimir informações de diagnóstico adicionais sobre o processo de compilação dom0.</p></li><li><p><code>sync_console</code>: flag para forçar a saída síncrona do console. Útil para depuração para evitar a perda de mensagens devido à limitação de taxa. Nunca use essa opção em ambientes de produção, pois ela pode permitir que convidados mal-intencionados realizem ataques DoS contra o Xen™ usando o console.</p></li></ul></div><div class=paragraph><p>O FreeBSD também deve ser inicializado no modo verbose para identificar quaisquer problemas. Para ativar a inicialização detalhada, execute este comando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysrc -f /boot/loader.conf boot_verbose=&#34;YES&#34;</span></code></pre></div></div><div class=paragraph><p>Se nenhuma dessas opções ajudar a resolver o problema, envie o registro de inicialização serial para <a href=mailto:freebsd-xen@FreeBSD.org>freebsd-xen@FreeBSD.org</a> e <a href=mailto:xen-devel@lists.xenproject.org>xen-devel@lists.xenproject.org</a> para uma análise mais aprofundada.</p></div></div><div class=sect4><h5 id=virtualization-host-xen-troubleshooting-guest>21.8.4.2. Solução de problemas na criação de VMs convidadas<a class=anchor href=#virtualization-host-xen-troubleshooting-guest></a></h5><div class=paragraph><p>Problemas também podem surgir ao criar convidados, as informações a seguir tentam fornecer alguma ajuda para aqueles que precisarem diagnosticar problemas de criação de convidados.</p></div><div class=paragraph><p>A causa mais comum de falhas na criação de convidados é o comando <code>xl</code> cuspindo algum erro e saindo com um código de retorno diferente de 0. Se o erro fornecido não for suficiente para ajudar a identificar o problema, uma saída mais detalhada pode ser obtida do comando <code>xl</code> usando-se a opção <code>v</code> repetidamente.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># xl -vvv create freebsd.cfg</span>
Parsing config from freebsd.cfg
libxl: debug: libxl_create.c:1693:do_domain_create: Domain 0:ao 0x800d750a0: create: <span class=nv>how</span><span class=o>=</span>0x0 <span class=nv>callback</span><span class=o>=</span>0x0 <span class=nv>poller</span><span class=o>=</span>0x800d6f0f0
libxl: debug: libxl_device.c:397:libxl__device_disk_set_backend: Disk <span class=nv>vdev</span><span class=o>=</span>xvda spec.backend<span class=o>=</span>unknown
libxl: debug: libxl_device.c:432:libxl__device_disk_set_backend: Disk <span class=nv>vdev</span><span class=o>=</span>xvda, using backend phy
libxl: debug: libxl_create.c:1018:initiate_domain_create: Domain 1:running bootloader
libxl: debug: libxl_bootloader.c:328:libxl__bootloader_run: Domain 1:not a PV/PVH domain, skipping bootloader
libxl: debug: libxl_event.c:689:libxl__ev_xswatch_deregister: watch <span class=nv>w</span><span class=o>=</span>0x800d96b98: deregister unregistered
domainbuilder: detail: xc_dom_allocate: <span class=nv>cmdline</span><span class=o>=</span><span class=s2>&#34;&#34;</span>, <span class=nv>features</span><span class=o>=</span><span class=s2>&#34;&#34;</span>
domainbuilder: detail: xc_dom_kernel_file: <span class=nv>filename</span><span class=o>=</span><span class=s2>&#34;/usr/local/lib/xen/boot/hvmloader&#34;</span>
domainbuilder: detail: xc_dom_malloc_filemap    : 326 kB
libxl: debug: libxl_dom.c:988:libxl__load_hvm_firmware_module: Loading BIOS: /usr/local/shared/seabios/bios.bin
...</code></pre></div></div><div class=paragraph><p>Se a saída detalhada não ajudar a diagnosticar o problema, verifique também os logs do toolstack QEMU e do Xen™ em <span class=filename>/var/log/xen</span>. Observe que o nome do domínio é anexado ao nome do registro, portanto, se o domínio tiver o nome <code>freebsd</code>, você deverá encontrar um <span class=filename>/var/log/xen/xl-freebsd.log</span> e provavelmente um <span class=filename>/var/log/xen/qemu-dm-freebsd.log</span>. Ambos os arquivos de log podem conter informações úteis para a depuração. Se nada disso ajudar a resolver o problema, envie a descrição do problema que você está enfrentando e o máximo de informações possíveis para <a href=mailto:freebsd-xen@FreeBSD.org>freebsd-xen@FreeBSD.org</a> e <a href=mailto:xen-devel@lists.xenproject.org>xen-devel@lists.xenproject.org</a> para obter ajuda.</p></div></div></div></div></div></div><div class=sect1><h2 id=l10n>Capítulo 22. Localização - Uso e Configuração do i18n/L10n<a class=anchor href=#l10n></a></h2><div class=sectionbody><div class=sect2><h3 id=l10n-synopsis>22.1. Sinopse<a class=anchor href=#l10n-synopsis></a></h3><div class=paragraph><p>O FreeBSD é um projeto distribuído com usuários e colaboradores localizados em todo o mundo. Como tal, o FreeBSD suporta a localização em muitos idiomas, permitindo aos usuários visualizar, inserir ou processar dados em idiomas diferentes do inglês. Pode-se escolher entre a maioria dos principais idiomas, incluindo, mas não se limitando a: Chinês, Alemão, Japonês, Coreano, Francês, Russo e Vietnamita.</p></div><div class=paragraph><p>O termo internacionalização foi encurtado para i18n, que representa o número de letras entre a primeira e a última letra da <code>internacionalização</code>. L10n usa o mesmo esquema de nomes, mas a partir da <code>localização</code>. Os métodos, protocolos e aplicativos i18n/L10n permitem que os usuários usem os idiomas de sua escolha.</p></div><div class=paragraph><p>Este capítulo discute os recursos de internacionalização e localização do FreeBSD. Depois de ler este capítulo, você saberá:</p></div><div class=ulist><ul><li><p>Como os nomes de localidade são construídos.</p></li><li><p>Como definir a localidade para um login shell.</p></li><li><p>Como configurar o console para idiomas diferentes do inglês.</p></li><li><p>Como configurar o Xorg para diferentes idiomas.</p></li><li><p>Como encontrar aplicativos compatíveis com i18n.</p></li><li><p>Onde encontrar mais informações para configurar idiomas específicos.</p></li></ul></div><div class=paragraph><p>Antes de ler este capítulo, você deve:</p></div><div class=ulist><ul><li><p>Saber como <a href=./#ports>instalar aplicativos adicionais de terceiros</a>.</p></li></ul></div></div><div class=sect2><h3 id=using-localization>22.2. Usando Localização<a class=anchor href=#using-localization></a></h3><div class=paragraph><p>As configurações de localização são baseadas em três componentes: o código do idioma, o código do país e a codificação. Nomes de localidade são construídos a partir dessas partes da seguinte maneira:</p></div><div class="literalblock programlisting"><div class=content><pre>LanguageCode_CountryCode.Encoding</pre></div></div><div class=paragraph><p>O <em>LanguageCode</em> e o <em>CountryCode</em> são usados para determinar o país e a variação de linguagem específica. A <a href=#locale-lang-country>Idiomas Comum e Códigos de País</a> apresenta alguns exemplos de <em>LanguageCode___CountryCode</em>:</p></div><table id=locale-lang-country class="tableblock frame-none grid-all stretch"><caption class=title>Tabela 14. Idiomas Comum e Códigos de País</caption><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">LanguageCode_Country Code</th><th class="tableblock halign-left valign-top">Descrição</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>en_US</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Inglês, Estados Unidos</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>ru_RU</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Russo, Rússia</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>zh_TW</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Chinês Tradicional, Taiwan</p></td></tr></tbody></table><div class=paragraph><p>Uma lista completa de localidades disponíveis pode ser encontrada digitando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% locale <span class=nt>-a</span> | more</code></pre></div></div><div class=paragraph><p>Para determinar a configuração atual de localidade:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% locale</code></pre></div></div><div class=paragraph><p>Conjuntos de caracteres específicos de idioma, como ISO8859-1, ISO8859-15, KOI8-R e CP437, são descritos em <a href="https://man.freebsd.org/cgi/man.cgi?query=multibyte&amp;sektion=3&amp;format=html">multibyte(3)</a>. A lista ativa de conjuntos de caracteres pode ser encontrada no <a href=http://www.iana.org/assignments/character-sets>IANA Registry</a>.</p></div><div class=paragraph><p>Alguns idiomas, como Chinês ou Japonês, não podem ser representados usando caracteres ASCII e requerem uma codificação de idioma estendida usando caracteres wide ou multibyte. Exemplos de codificações de wide ou multibyte incluem EUC e Big5. Aplicativos mais antigos podem confundir essas codificações com caracteres de controle, enquanto aplicativos mais novos geralmente reconhecem esses caracteres. Dependendo da implementação, os usuários podem ser obrigados a compilar um aplicativo com suporte a caracteres wide ou multibyte, ou configurá-lo corretamente.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>O FreeBSD usa codificações de locale compatíveis com o Xorg.</p></div></td></tr></tbody></table></div><div class=paragraph><p>O restante desta seção descreve os vários métodos para configurar a localidade em um sistema FreeBSD. A próxima seção discutirá as considerações para encontrar e compilar aplicativos com suporte a i18n.</p></div><div class=sect3><h4 id=setting-locale>22.2.1. Definindo a Localidade para o Login Shell<a class=anchor href=#setting-locale></a></h4><div class=paragraph><p>As configurações de localidade são configuradas no <span class=filename>~/.login_conf</span> do usuário ou no arquivo de inicialização do shell do usuário: <span class=filename>~/.profile</span>, <span class=filename>~/.bashrc</span>, or <span class=filename>~/.cshrc</span>.</p></div><div class=paragraph><p>Duas variáveis de ambiente devem ser definidas:</p></div><div class=ulist><ul><li><p><code>LANG</code>, que define o idioma
*</p><div class=paragraph><p><code>MM_CHARSET</code>, que define o conjunto de caracteres MIME usado pelos aplicativos</p></div></li></ul></div><div class=paragraph><p>Além da configuração do shell do usuário, essas variáveis também devem ser definidas para configurações específicas de aplicativos e configurações do Xorg.</p></div><div class=paragraph><p>Dois métodos estão disponíveis para fazer as atribuições de variáveis necessárias: o método <a href=#login-class>classes de login</a>, que é o método recomendado, e o método <a href=#startup-file>arquivo de inicialização</a>. As próximas duas seções demonstram como usar os dois métodos.</p></div><div class=sect4><h5 id=login-class>22.2.1.1. Método de Classes de Login<a class=anchor href=#login-class></a></h5><div class=paragraph><p>Este primeiro método é o método recomendado, pois atribui as variáveis de ambiente necessárias para o nome da localidade e os conjuntos de caracteres MIME para todos os shell possíveis. Essa configuração pode ser executada para cada usuário ou pode ser configurada para todos os usuários pelo superusuário.</p></div><div class=paragraph><p>Esse exemplo mínimo define as duas variáveis para a codificação Latin-1 no <span class=filename>.login_conf</span> do diretório inicial de um usuário individual:</p></div><div class="literalblock programlisting"><div class=content><pre>me:\
	:charset=ISO-8859-1:\
	:lang=de_DE.ISO8859-1:</pre></div></div><div class=paragraph><p>Aqui está um exemplo de <span class=filename>~/.login_conf</span> de um usuário que define as variáveis para o Chinês Tradicional na codificação BIG-5. Mais variáveis são necessárias porque alguns aplicativos não respeitam corretamente variáveis de idioma para o Chinês, Japonês e Coreano:</p></div><div class="literalblock programlisting"><div class=content><pre>#Users who do not wish to use monetary units or time formats
#of Taiwan can manually change each variable
me:\
	:lang=zh_TW.Big5:\
	:setenv=LC_ALL=zh_TW.Big5,LC_COLLATE=zh_TW.Big5,LC_CTYPE=zh_TW.Big5,LC_MESSAGES=zh_TW.Big5,LC_MONETARY=zh_TW.Big5,LC_NUMERIC=zh_TW.Big5,LC_TIME=zh_TW.Big5:\
	:charset=big5:\
	:xmodifiers=&#34;@im=gcin&#34;: #Set gcin as the XIM Input Server</pre></div></div><div class=paragraph><p>Como alternativa, o superusuário pode configurar a localização para todos os usuários do sistema. As seguintes variáveis no <span class=filename>/etc/login.conf</span> são usadas para definir a localidade e o conjunto de caracteres MIME:</p></div><div class="literalblock programlisting"><div class=content><pre>language_name|Account Type Description:\
	:charset=MIME_charset:\
	:lang=locale_name:\
	:tc=default:</pre></div></div><div class=paragraph><p>Então, o exemplo anterior do Latin-1 ficaria assim:</p></div><div class="literalblock programlisting"><div class=content><pre>german|German Users Accounts:\
	:charset=ISO-8859-1:\
	:lang=de_DE.ISO8859-1:\
	:tc=default:</pre></div></div><div class=paragraph><p>Veja o <a href="https://man.freebsd.org/cgi/man.cgi?query=login.conf&amp;sektion=5&amp;format=html">login.conf(5)</a> para mais detalhes sobre estas variáveis. Observe que ele já contém a classe <em>russian</em> predefinida.</p></div><div class=paragraph><p>Sempre que <span class=filename>/etc/login.conf</span> for editado, lembre-se de executar o seguinte comando para atualizar o banco de dados de recursos:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cap_mkdb /etc/login.conf</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Para um usuário final, o comando <code>cap_mkdb</code> vai precisar rodar no seu <span class=filename>~/.login_conf</span> para que qualquer mudança tenha efeito.</p></div></td></tr></tbody></table></div><div class=sect5><h6 id=_utilitários_que_alteram_as_classes_de_login>22.2.1.1.1. Utilitários que Alteram as Classes de Login<a class=anchor href=#_utilitários_que_alteram_as_classes_de_login></a></h6><div class=paragraph><p>Além de editar manualmente o <span class=filename>/etc/login.conf</span>, vários utilitários estão disponíveis para definir a localidade de usuários recém-criados.</p></div><div class=paragraph><p>Ao usar o <code>vipw</code> para adicionar novos usuários, especifique o <em>idioma</em> para definir a localidade:</p></div><div class="literalblock programlisting"><div class=content><pre>user:password:1111:11:language:0:0:User Name:/home/user:/bin/sh</pre></div></div><div class=paragraph><p>Ao usar o <code>adduser</code> para adicionar novos usuários, o idioma padrão pode ser pré-configurado para todos os novos usuários ou especificado para um usuário individual.</p></div><div class=paragraph><p>Se todos os novos usuários usarem o mesmo idioma, configure <code>defaultclass=<em>language</em></code> em <span class=filename>/etc/adduser.conf</span>.</p></div><div class=paragraph><p>Para substituir essa configuração ao criar um usuário, insira a localidade necessária neste prompt:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Enter login class: default <span class=o>[]</span>:</code></pre></div></div><div class=paragraph><p>ou especifique a localidade ao executar o <code>adduser</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># adduser -class language</span></code></pre></div></div><div class=paragraph><p>Se o <code>pw</code> for usado para adicionar novos usuários, especifique a localidade da seguinte forma:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pw useradd user_name -L language</span></code></pre></div></div><div class=paragraph><p>Para alterar a classe de login de um usuário existente, <code>chpass</code> pode ser usado. Execute-o como superusuário e forneça o nome do usuário para edição como argumento.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># chpass user_name</span></code></pre></div></div></div></div><div class=sect4><h5 id=startup-file>22.2.1.2. Método de Arquivo de Inicialização do Shell<a class=anchor href=#startup-file></a></h5><div class=paragraph><p>Esse segundo método não é recomendado, pois cada shell usado requer configuração manual, e cada shell tem um arquivo de configuração diferente e uma sintaxe diferente. Como exemplo, para definir o idioma Alemão para o shell <code>sh</code>, essas linhas podem ser adicionadas ao <span class=filename>~/.profile</span> para definir o shell apenas para esse usuário. Essas linhas também podem ser adicionadas ao <span class=filename>/etc/profile</span> ou <span class=filename>/usr/shared/skel/dot.profile</span> para definir esse shell para todos os usuários:</p></div><div class="literalblock programlisting"><div class=content><pre>LANG=de_DE.ISO8859-1; export LANG
MM_CHARSET=ISO-8859-1; export MM_CHARSET</pre></div></div><div class=paragraph><p>No entanto, o nome do arquivo de configuração e a sintaxe usada são diferentes para o shell <code>csh</code>. Estas são as configurações equivalentes para o <span class=filename>~/.csh.login</span>, <span class=filename>/etc/csh.login</span>, ou <span class=filename>/usr/shared/skel/dot.login</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>setenv LANG de_DE.ISO8859-1
setenv MM_CHARSET ISO-8859-1</pre></div></div><div class=paragraph><p>Para complicar, a sintaxe necessária para configurar o Xorg no <span class=filename>~/.xinitrc</span> também depende do shell. O primeiro exemplo é para o shell <code>sh</code> e o segundo é para o shell <code>csh</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>LANG=de_DE.ISO8859-1; export LANG</pre></div></div><div class="literalblock programlisting"><div class=content><pre>setenv LANG de_DE.ISO8859-1</pre></div></div></div></div><div class=sect3><h4 id=setting-console>22.2.2. Configuração do Console<a class=anchor href=#setting-console></a></h4><div class=paragraph><p>Várias fontes de localização estão disponíveis para o console. Para ver uma lista de fontes disponíveis, digite <code>ls /usr/shared/syscons/fonts</code>. Para configurar a fonte do console, especifique o <em>font_name</em>, sem o sufixo <span class=filename>.fnt</span>, em <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>font8x16=font_name
font8x14=font_name
font8x8=font_name</pre></div></div><div class=paragraph><p>O keymap e o screenmap podem ser definidos adicionando o seguinte ao <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>scrnmap=screenmap_name
keymap=keymap_name
keychange=&#34;fkey_number sequence&#34;</pre></div></div><div class=paragraph><p>Para ver a lista de screenmaps disponíveis, digite <code>ls /usr/shared/syscons/scrnmaps</code>. Não inclua o sufixo <span class=filename>.scm</span> ao especificar <em>screenmap_name</em>. Um screenmap com uma fonte mapeada correspondente geralmente é necessário como uma solução alternativa para expandir o bit 8 para o 9 na matriz de caracteres de fonte de um adaptador VGA para que as letras sejam movidas para fora da área de pseudo-grafia se a fonte da tela usar uma coluna de 8 bits.</p></div><div class=paragraph><p>Para ver a lista de mapas de teclado disponíveis, digite <code>ls /usr/shared/syscons/keymaps</code>. Ao especificar o <em>keymap_name</em>, não inclua o sufixo <span class=filename>.kbd</span>. Para testar os mapas de teclado sem reinicializar o sistema, use <a href="https://man.freebsd.org/cgi/man.cgi?query=kbdmap&amp;sektion=1&amp;format=html">kbdmap(1)</a>.</p></div><div class=paragraph><p>A entrada <code>keychange</code> geralmente é necessária para programar as teclas de função para corresponder ao tipo de terminal selecionado, porque as sequências de teclas de função não podem ser definidas no mapa de teclas.</p></div><div class=paragraph><p>Em seguida, defina o tipo de terminal do console correto em <span class=filename>/etc/ttys</span> para todas as entradas do terminal virtual. <a href=#locale-charset>Tipos de Terminal Definidos para Conjuntos de Caracteres</a> resume os tipos de terminais disponíveis:</p></div><table id=locale-charset class="tableblock frame-none grid-all stretch"><caption class=title>Tabela 15. Tipos de Terminal Definidos para Conjuntos de Caracteres</caption><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Conjunto de Caracteres</th><th class="tableblock halign-left valign-top">Tipo de Terminal</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>ISO8859-1 ou ISO8859-15</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>cons25l1</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>ISO8859-2</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>cons25l2</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>ISO8859-7</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>cons25l7</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>KOI8-R</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>cons25r</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>KOI8-U</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>cons25u</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>CP437 (VGA padrão)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>cons25</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>US-ASCII</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>cons25w</code></p></td></tr></tbody></table><div class=paragraph><p>Para idiomas com caracteres wide ou multibyte, instale um console para esse idioma a partir da Coleção de Ports do FreeBSD. Os ports disponíveis estão resumidos em <a href=#locale-console>Consoles Disponíveis pela Coleção de Ports</a>. Uma vez instalado, consulte o <span class=filename>pkg-message</span> dos ports ou as páginas de manual para instruções de configuração e uso.</p></div><table id=locale-console class="tableblock frame-none grid-all stretch"><caption class=title>Tabela 16. Consoles Disponíveis pela Coleção de Ports</caption><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Idioma</th><th class="tableblock halign-left valign-top">Localização do Port</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Chinês Tradicional (BIG-5)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/chinese/big5con/>chinese/big5con</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Chinês/Japonês/Coreano</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/chinese/cce/>chinese/cce</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Chinês/Japonês/Coreano</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/chinese/zhcon/>chinese/zhcon</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Japonês</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/chinese/kon2/>chinese/kon2</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Japonês</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/japanese/kon2-14dot/>japanese/kon2-14dot</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Japonês</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/japanese/kon2-16dot/>japanese/kon2-16dot</a></p></td></tr></tbody></table><div class=paragraph><p>Se o moused estiver ativado no <span class=filename>/etc/rc.conf</span>, uma configuração adicional pode ser necessária. Por padrão, o cursor do mouse do driver <a href="https://man.freebsd.org/cgi/man.cgi?query=syscons&amp;sektion=4&amp;format=html">syscons(4)</a> ocupa o intervalo <code>0xd0</code>-<code>0xd3</code> no conjunto de caracteres. Se o idioma usar esse intervalo, mova o intervalo do cursor adicionando a seguinte linha ao <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>mousechar_start=3</pre></div></div></div><div class=sect3><h4 id=_configuração_do_xorg>22.2.3. Configuração do Xorg<a class=anchor href=#_configuração_do_xorg></a></h4><div class=paragraph><p>O <a href=./#x11>O sistema X Window</a> descreve como instalar e configurar o Xorg. Ao configurar localizações no Xorg, fontes adicionais e métodos de entrada estão disponíveis na Coleção de Ports do FreeBSD. Configurações específicas de i18n para aplicações como fontes e menus podem ser tunadas em <span class=filename>~/.Xresources</span> e devem permitir que os usuários visualizem o idioma selecionado nos menus das aplicações gráficas.</p></div><div class=paragraph><p>O protocolo X Input Method (XIM) é um padrão Xorg para inserir caracteres não Ingleses. <a href=#locale-xim>Métodos de Entrada Disponíveis</a> resume os métodos de entrada de aplicações que estão disponíveis na Coleção de Ports do FreeBSD. Aplicativos adicionais Fcitx e Uim também estão disponíveis.</p></div><table id=locale-xim class="tableblock frame-none grid-all stretch"><caption class=title>Tabela 17. Métodos de Entrada Disponíveis</caption><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Idioma</th><th class="tableblock halign-left valign-top">Método de Entrada</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Chinês</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/chinese/gcin/>chinese/gcin</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Chinês</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/chinese/ibus-chewing/>chinese/ibus-chewing</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Chinês</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/chinese/ibus-pinyin/>chinese/ibus-pinyin</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Chinês</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/chinese/oxim/>chinese/oxim</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Chinês</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/chinese/scim-fcitx/>chinese/scim-fcitx</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Chinês</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/chinese/scim-pinyin/>chinese/scim-pinyin</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Chinês</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/chinese/scim-tables/>chinese/scim-tables</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Japonês</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/japanese/ibus-anthy/>japanese/ibus-anthy</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Japonês</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/japanese/ibus-mozc/>japanese/ibus-mozc</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Japonês</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/japanese/ibus-skk/>japanese/ibus-skk</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Japonês</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/japanese/im-ja/>japanese/im-ja</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Japonês</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/japanese/kinput2/>japanese/kinput2</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Japonês</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/japanese/scim-anthy/>japanese/scim-anthy</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Japonês</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/japanese/scim-canna/>japanese/scim-canna</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Japonês</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/japanese/scim-honoka/>japanese/scim-honoka</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Japonês</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/japanese/scim-honoka-plugin-romkan/>japanese/scim-honoka-plugin-romkan</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Japonês</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/japanese/scim-honoka-plugin-wnn/>japanese/scim-honoka-plugin-wnn</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Japonês</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/japanese/scim-prime/>japanese/scim-prime</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Japonês</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/japanese/scim-skk/>japanese/scim-skk</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Japonês</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/japanese/scim-tables/>japanese/scim-tables</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Japonês</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/japanese/scim-tomoe/>japanese/scim-tomoe</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Japonês</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/japanese/scim-uim/>japanese/scim-uim</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Japonês</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/japanese/skkinput/>japanese/skkinput</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Japonês</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/japanese/skkinput3/>japanese/skkinput3</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Japonês</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/japanese/uim-anthy/>japanese/uim-anthy</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Coreano</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/korean/ibus-hangul/>korean/ibus-hangul</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Coreano</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/korean/imhangul/>korean/imhangul</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Coreano</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/korean/nabi/>korean/nabi</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Coreano</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/korean/scim-hangul/>korean/scim-hangul</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Coreano</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/korean/scim-tables/>korean/scim-tables</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Vietnamita</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/vietnamese/xvnkb/>vietnamese/xvnkb</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Vietnamita</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/vietnamese/x-unikey/>vietnamese/x-unikey</a></p></td></tr></tbody></table></div></div><div class=sect2><h3 id=l10n-compiling>22.3. Encontrando Aplicações i18n<a class=anchor href=#l10n-compiling></a></h3><div class=paragraph><p>Aplicações i18n são programadas usando kits i18n em bibliotecas. Isso permite que os desenvolvedores escrevam um arquivo simples e traduzam menus e textos exibidos para cada idioma.</p></div><div class=paragraph><p>A <a href=https://www.FreeBSD.org/ports/index.html>Coleção de Ports do FreeBSD</a> contém muitos aplicativos com suporte embutido para caracteres wide ou multibyte para vários idiomas. Tais aplicativos incluem <code>i18n</code> em seus nomes para fácil identificação. No entanto, eles nem sempre suportam o idioma necessário.</p></div><div class=paragraph><p>Alguns aplicativos podem ser compilados com o conjunto de caracteres específico. Isso geralmente é feito no <span class=filename>Makefile</span> do port ou passando um parâmetro para o configure. Consulte a documentação i18n no código fonte do respectivo port do FreeBSD para obter mais informações sobre como determinar o parâmetro do configure necessário ou o <span class=filename>Makefile</span> do port para determinar quais opções de compilação para usar ao compilar o port.</p></div></div><div class=sect2><h3 id=lang-setup>22.4. Configuração de Localização para Idiomas Específicos<a class=anchor href=#lang-setup></a></h3><div class=paragraph><p>Esta seção fornece exemplos de configuração para definir a localização de um sistema FreeBSD para o idioma Russo. Em seguida, ele fornece alguns recursos adicionais para definir a localização com outros idiomas.</p></div><div class=sect3><h4 id=ru-localize>22.4.1. Idioma Russo (Codificação KOI8-R)<a class=anchor href=#ru-localize></a></h4><div class=paragraph><p>Esta seção mostra as configurações específicas necessárias para definir a localização de um sistema FreeBSD para o idioma Russo. Consulte <a href=#using-localization>Usando Localização</a> para obter uma descrição mais completa de cada tipo de configuração.</p></div><div class=paragraph><p>Para definir esta localidade para o login shell, adicione as seguintes linhas ao <span class=filename>~/.login_conf</span> de cada usuário:</p></div><div class="literalblock programlisting"><div class=content><pre>me:My Account:\
	:charset=KOI8-R:\
	:lang=ru_RU.KOI8-R:</pre></div></div><div class=paragraph><p>Para configurar o console, adicione as seguintes linhas ao <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>keymap=&#34;ru.utf-8&#34;
scrnmap=&#34;utf-82cp866&#34;
font8x16=&#34;cp866b-8x16&#34;
font8x14=&#34;cp866-8x14&#34;
font8x8=&#34;cp866-8x8&#34;
mousechar_start=3</pre></div></div><div class=paragraph><p>Para cada entrada <code>ttyv</code> em <span class=filename>/etc/ttys</span>, use <code>cons25r</code> como o tipo de terminal.</p></div><div class=paragraph><p>Para configurar a impressão, é necessário um filtro de saída especial para converter de KOI8-R para CP866, pois a maioria das impressoras com caracteres Russos vem com a página de código de hardware CP866. O FreeBSD inclui um filtro padrão para este propósito, <span class=filename>/usr/libexec/lpr/ru/koi2alt</span>. Para usar este filtro, adicione esta entrada ao <span class=filename>/etc/printcap</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>lp|Russian local line printer:\
	:sh:of=/usr/libexec/lpr/ru/koi2alt:\
	:lp=/dev/lpt0:sd=/var/spool/output/lpd:lf=/var/log/lpd-errs:</pre></div></div><div class=paragraph><p>Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=printcap&amp;sektion=5&amp;format=html">printcap(5)</a> para obter uma explicação mais detalhada.</p></div><div class=paragraph><p>Para configurar o suporte a nomes de arquivos Russos em sistemas de arquivos montados do MS-DOS™, inclua <code>-L</code> e o nome da localidade ao adicionar uma entrada ao <span class=filename>/etc/fstab</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>/dev/ad0s2      /dos/c  msdos   rw,-Lru_RU.KOI8-R 0 0</pre></div></div><div class=paragraph><p>Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=mount_msdosfs&amp;sektion=8&amp;format=html">mount_msdosfs(8)</a> para mais detalhes.</p></div><div class=paragraph><p>Para configurar fontes Russas no Xorg, instale o pacote <a class=package href=https://cgit.freebsd.org/ports/tree/x11-fonts/xorg-fonts-cyrillic/>x11-fonts/xorg-fonts-cyrillic</a>. Em seguida, verifique a seção <code>"Files"</code> em <span class=filename>/etc/X11/xorg.conf</span>. A seguinte linha deve ser adicionada <em>antes</em> de qualquer outra entrada <code>FontPath</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>FontPath   &#34;/usr/local/lib/X11/fonts/cyrillic&#34;</pre></div></div><div class=paragraph><p>Fontes Cirílicos adicionais estão disponíveis na Coleção de Ports.</p></div><div class=paragraph><p>Para ativar um teclado Russo, adicione o seguinte à seção <code>"Keyboard"</code> do <span class=filename>/etc/xorg.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>Option &#34;XkbLayout&#34;   &#34;us,ru&#34;
Option &#34;XkbOptions&#34;  &#34;grp:toggle&#34;</pre></div></div><div class=paragraph><p>Certifique-se de que <code>XkbDisable</code> esteja comentado nesse arquivo.</p></div><div class=paragraph><p>Para <code>grp:toggle</code> use <kbd>Right Alt</kbd>, para <code>grp:ctrl_shift_toggle</code> use <span class=keyseq><kbd>Ctrl</kbd>+<kbd>Shift</kbd></span>. Para <code>grp:caps_toggle</code> use <kbd>CapsLock</kbd>. A antiga função <kbd>CapsLock</kbd> ainda está disponível no modo LAT apenas usando <span class=keyseq><kbd>Shift</kbd>+<kbd>CapsLock</kbd></span>. <code>grp:caps_toggle</code> não funciona no Xorg por alguma razão desconhecida.</p></div><div class=paragraph><p>Se o teclado tiver as teclas "Windows™" e algumas teclas não alfabéticas mapeadas incorretamente, adicione a seguinte linha ao <span class=filename>/etc/xorg.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>Option &#34;XkbVariant&#34; &#34;,winkeys&#34;</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>O teclado Russo XKB pode não funcionar com aplicativos não localizados. Aplicativos minimamente localizados devem chamar uma função <code>XtSetLanguageProc (NULL, NULL, NULL);</code> no início do programa.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Veja <a href=http://koi8.pp.ru/xwin.html>http://koi8.pp.ru/xwin.html</a> para mais instruções sobre como definir a localização em aplicações Xorg. Para mais informações gerais sobre a codificação KOI8-R, consulte <a href=http://koi8.pp.ru/>http://koi8.pp.ru/</a>.</p></div></div><div class=sect3><h4 id=_recursos_específicos_de_idioma_adicionais>22.4.2. Recursos Específicos de Idioma Adicionais<a class=anchor href=#_recursos_específicos_de_idioma_adicionais></a></h4><div class=paragraph><p>Esta seção lista alguns recursos adicionais para a configuração de outras localidades.</p></div><div class=dlist><dl><dt class=hdlist1>Chinês Tradicional para Taiwan</dt><dd><p>O projeto FreeBSD-Taiwan tem um HOWTO em Chinês para o FreeBSD em <a href=http://netlab.cse.yzu.edu.tw/~statue/freebsd/zh-tut/>http://netlab.cse.yzu.edu.tw/~statue/freebsd/zh-tut/</a>.</p></dd><dt class=hdlist1>Localização do Idioma Grego</dt><dd><p>Um artigo completo sobre o suporte Grego no FreeBSD está disponível <a href=https://www.FreeBSD.org/doc/el/articles/greek-language-support/>aqui</a>, somente em Grego, como parte da documentação oficial do FreeBSD em Grego.</p></dd><dt class=hdlist1>Localização do Idioma Japonês e Coreano</dt><dd><p>Para Japonês, consulte <a href=http://www.jp.FreeBSD.org/>http://www.jp.FreeBSD.org/</a> e, para Coreano, consulte <a href=http://www.kr.FreeBSD.org/>http://www.kr.FreeBSD.org/</a>.</p></dd><dt class=hdlist1>Documentação do FreeBSD em Outros Idiomas</dt><dd><p>Alguns colaboradores do FreeBSD traduziram partes da documentação do FreeBSD para outros idiomas. Elas estão disponíveis através de links no <a href=https://www.FreeBSD.org/>site do FreeBSD</a> ou em <span class=filename>/usr/shared/doc</span>.</p></dd></dl></div></div></div></div></div><div class=sect1><h2 id=updating-upgrading>Capítulo 23. Atualização e Upgrade do FreeBSD<a class=anchor href=#updating-upgrading></a></h2><div class=sectionbody><div class=sect2><h3 id=updating-upgrading-synopsis>23.1. Sinopse<a class=anchor href=#updating-upgrading-synopsis></a></h3><div class=paragraph><p>O FreeBSD está em constante desenvolvimento entre os releases. Algumas pessoas preferem usar as versões lançadas oficialmente, enquanto outras preferem se manter em sincronia com os últimos desenvolvimentos. No entanto, até mesmo versões oficiais são atualizadas com patches de segurança e outras correções críticas. Independentemente da versão usada, o FreeBSD fornece todas as ferramentas necessárias para manter o sistema atualizado e permite atualizações fáceis entre as versões. Este capítulo descreve como acompanhar o sistema de desenvolvimento e o uso das ferramentas básicas para manter um sistema FreeBSD atualizado.</p></div><div class=paragraph><p>Depois de ler este capítulo, você saberá:</p></div><div class=ulist><ul><li><p>Como manter um sistema FreeBSD atualizado com o freebsd-update ou com o Subversion.</p></li><li><p>Como comparar o estado de um sistema instalado com uma cópia original.</p></li><li><p>Como manter a documentação instalada atualizada com o Subversion ou com o port da documentação.</p></li><li><p>A diferença entre os dois ramos de desenvolvimento: FreeBSD-STABLE e FreeBSD-CURRENT.</p></li><li><p>Como recompilar e reinstalar todo o sistema básico.</p></li></ul></div><div class=paragraph><p>Antes de ler este capítulo, você deve:</p></div><div class=ulist><ul><li><p>Configurar corretamente a conexão de rede (<a href=./#advanced-networking>Rede Avançada</a>).</p></li><li><p>Saber como instalar software adicional de terceiros (<a href=./#ports>Instalando Aplicativos. Pacotes e Ports</a>).</p></li></ul></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Ao longo deste capítulo, o <code>svnlite</code> é usado para obter e atualizar o código fonte do FreeBSD. Opcionalmente, o port ou pacote <a class=package href=https://cgit.freebsd.org/ports/tree/devel/subversion/>devel/subversion</a> pode ser usado.</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=updating-upgrading-freebsdupdate>23.2. Atualização do FreeBSD<a class=anchor href=#updating-upgrading-freebsdupdate></a></h3><div class=paragraph><p>A aplicação de patches de segurança em tempo hábil e a atualização para uma versão mais recente de um sistema operacional são aspectos importantes da administração contínua do sistema. O FreeBSD inclui um utilitário chamado <code>freebsd-update</code> o qual pode ser usado para executar ambas as tarefas.</p></div><div class=paragraph><p>Este utilitário suporta atualizações binárias de segurança e de erratas para o FreeBSD, sem a necessidade de compilar e instalar manualmente o patch ou um novo kernel. Atualizações binárias estão disponíveis para todas as arquiteturas e versões atualmente suportadas pela equipe de segurança. A lista de versões suportadas e suas datas estimadas de fim de vida estão listadas em <a href=https://www.FreeBSD.org/security/>https://www.FreeBSD.org/security/</a>.</p></div><div class=paragraph><p>Este utilitário também suporta upgrades do sistema operacional para releases menores (ponto x), bem como atualizações para outro ramo de release. Antes de atualizar para uma nova versão, revise o seu anúncio de lançamento, pois ele contém informações importantes pertinentes ao release. Os anúncios de lançamento estão disponíveis em <a href=https://www.FreeBSD.org/releases/>https://www.FreeBSD.org/releases/</a>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Se um <code>crontab</code> utilizando os recursos do <a href="https://man.freebsd.org/cgi/man.cgi?query=freebsd-update&amp;sektion=8&amp;format=html">freebsd-update(8)</a> existir, ele deve ser desativado antes de atualizar o sistema operacional .</p></div></td></tr></tbody></table></div><div class=paragraph><p>Esta seção descreve o arquivo de configuração usado pelo <code>freebsd-update</code>, demonstra como aplicar um patch de segurança e como atualizar para um release menor ou principal do sistema operacional e discute algumas das considerações ao atualizar o sistema operacional .</p></div><div class=sect3><h4 id=freebsdupdate-config-file>23.2.1. O Arquivo de Configuração<a class=anchor href=#freebsdupdate-config-file></a></h4><div class=paragraph><p>O arquivo de configuração padrão do <code>freebsd-update</code> funciona como está. Alguns usuários podem querer ajustar a configuração padrão no <span class=filename>/etc/freebsd-update.conf</span>, permitindo um melhor controle do processo. Os comentários neste arquivo explicam as opções disponíveis, mas os seguintes podem exigir um pouco mais de explicação:</p></div><div class="literalblock programlisting"><div class=content><pre># Componentes do sistema base que devem ser mantidos atualizados.
Components world kernel</pre></div></div><div class=paragraph><p>Este parâmetro controla quais partes do FreeBSD serão mantidas atualizadas. O padrão é atualizar todo o sistema básico e o kernel. Componentes individuais podem ser especificados, como <code>src/base</code> ou <code>src/sys</code>. No entanto, a melhor opção é deixar isso no padrão, pois alterá-lo para incluir itens específicos requer que todos os itens necessários sejam listados. Com o tempo, isso pode ter consequências desastrosas, pois o código-fonte e os binários podem ficar fora de sincronia.</p></div><div class="literalblock programlisting"><div class=content><pre># Caminhos que começam com qualquer coisa que corresponda a uma entrada em uma
# declaração IgnorePaths será ignorada.
IgnorePaths /boot/kernel/linker.hints</pre></div></div><div class=paragraph><p>Para deixar diretórios especificados, como <span class=filename>/bin</span> ou <span class=filename>/sbin</span>, intocados durante o processo de atualização, adicione seus caminhos a esta instrução. Esta opção pode ser usada para evitar que o <code>freebsd-update</code> substitua as modificações locais.</p></div><div class="literalblock programlisting"><div class=content><pre># Caminhos que começam com qualquer coisa que corresponda a uma entrada em uma declaração
# UpdateIfUnmodified só será atualizada se o conteúdo do arquivo não tiver sido
# modificado pelo usuário (a menos que as alterações sejam mescladas; veja abaixo).
UpdateIfUnmodified /etc/ /var/ /root/ /.cshrc /.profile</pre></div></div><div class=paragraph><p>Esta opção atualizará apenas os arquivos de configuração não modificados nos diretórios especificados. Quaisquer alterações feitas pelo usuário impedirão a atualização automática desses arquivos. Existe outra opção, <code>KeepModifiedMetadata</code>, que instruirá o <code>freebsd-update</code> para salvar as alterações durante a mesclagem.</p></div><div class="literalblock programlisting"><div class=content><pre># Ao fazer o upgrade para uma nova versão do FreeBSD, os arquivos que forem especificados no MergeChanges
# terão quaisquer alterações locais mescladas na versão da nova release.
MergeChanges /etc/ /var/named/etc/ /boot/device.hints</pre></div></div><div class=paragraph><p>Lista de diretórios com arquivos de configuração que o <code>freebsd-update</code> deve tentar mesclar. O processo de mesclagem de arquivos é uma série de patches <a href="https://man.freebsd.org/cgi/man.cgi?query=diff&amp;sektion=1&amp;format=html">diff(1)</a> semelhantes a <a href="https://man.freebsd.org/cgi/man.cgi?query=mergemaster&amp;sektion=8&amp;format=html">mergemaster(8)</a>, mas com menos opções. As mesclagens são aceitas, abrem um editor ou fazem com que o <code>freebsd-update</code> aborte. Em caso de dúvida, faça backup do <span class=filename>/etc</span> e apenas aceite as mesclagens. Veja <a href="https://man.freebsd.org/cgi/man.cgi?query=mergemaster&amp;sektion=8&amp;format=html">mergemaster(8)</a> para maiores informações sobre o <code>mergemaster</code>.</p></div><div class="literalblock programlisting"><div class=content><pre># Diretório no qual armazenar atualizações baixadas e arquivos
# temporários usados pelo FreeBSD Update.
# WorkDir /var/db/freebsd-update</pre></div></div><div class=paragraph><p>Este diretório é onde todos os patches e arquivos temporários são colocados. Nos casos em que o usuário estiver fazendo uma atualização de versão, esse local deverá ter pelo menos um gigabyte de espaço em disco disponível.</p></div><div class="literalblock programlisting"><div class=content><pre># Ao atualizar entre releases, a lista de Componentes deve ser lida de forma estrita (StrictComponents yes)
# ou meramente como uma lista de componentes que *podem* ser instalados de quais atualizações do
# FreeBSD devem ser instaladas e atualizadas (StrictComponents no)?
# StrictComponents no</pre></div></div><div class=paragraph><p>Quando esta opção estiver definida como <code>yes</code>, o <code>freebsd-update</code> assumirá que a lista <code>Componentes</code> está completa e não tentará fazer alterações fora da lista. Efetivamente, o <code>freebsd-update</code> tentará atualizar todos os arquivos que pertencem à lista <code>Componentes</code>.</p></div></div><div class=sect3><h4 id=freebsdupdate-security-patches>23.2.2. Aplicando Patches de Segurança<a class=anchor href=#freebsdupdate-security-patches></a></h4><div class=paragraph><p>O processo de aplicação de patches de segurança do FreeBSD foi simplificado, permitindo que um administrador mantenha um sistema totalmente corrigido usando o <code>freebsd-update</code>. Maiores informações sobre os avisos de segurança do FreeBSD podem ser encontradas em <a href=./#security-advisories>Avisos de Segurança do FreeBSD</a>.</p></div><div class=paragraph><p>Patches de segurança do FreeBSD podem ser baixados e instalados usando os seguintes comandos. O primeiro comando determinará se algum patch pendente está disponível e, em caso afirmativo, listará os arquivos que serão modificados se os patches forem aplicados. O segundo comando aplicará os patches.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># freebsd-update fetch</span>
<span class=c># freebsd-update install</span></code></pre></div></div><div class=paragraph><p>Se a atualização aplicar alguma correção de kernel, o sistema precisará de uma reinicialização para inicializar no kernel corrigido. Se o patch for aplicado a qualquer binário em execução, os aplicativos afetados devem ser reiniciados para que a versão corrigida do binário seja usada.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Normalmente, o usuário precisa estar preparado para reiniciar o sistema. Para saber se uma reinicialização é necessária por uma atualização do kernel, execute os comandos <code>freebsd-version -k</code> e <code>uname -r</code> e se eles forem diferentes, é necessário reiniciar.</p></div></td></tr></tbody></table></div><div class=paragraph><p>O sistema pode ser configurado para verificar automaticamente as atualizações uma vez por dia, adicionando esta entrada ao <span class=filename>/etc/crontab</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>@daily                                  root    freebsd-update cron</pre></div></div><div class=paragraph><p>Se houver patches, eles serão automaticamente baixados, mas não serão aplicados. O usuário <code>root</code> receberá um email para que os patches possam ser revisados e instalados manualmente com o <code>freebsd-update install</code>.</p></div><div class=paragraph><p>Se algo der errado, o <code>freebsd-update</code> terá a capacidade de reverter o último conjunto de alterações com o seguinte comando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># freebsd-update rollback</span>
Uninstalling updates... <span class=k>done</span>.</code></pre></div></div><div class=paragraph><p>Novamente, o sistema deve ser reiniciado se o kernel ou qualquer módulo do kernel for modificado e quaisquer binários afetados devem ser reiniciados.</p></div><div class=paragraph><p>Apenas o kernel <span class=filename>GENERIC</span> pode ser atualizado automaticamente pelo <code>freebsd-update</code>. Se um kernel personalizado estiver instalado, ele terá que ser recompilado e reinstalado depois que o <code>freebsd-update</code> terminar de instalar as atualizações. No entanto, o <code>freebsd-update</code> detectará e atualizará o kernel <em>GENERIC</em> se <span class=filename>/boot/GENERIC</span> existir, mesmo que não seja o kernel atual em execução no sistema. Para verificar detalhes desta instalação utilize o comando <a href="https://man.freebsd.org/cgi/man.cgi?query=uname&amp;sektion=1&amp;format=html">uname(1)</a>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Sempre mantenha uma cópia do kernel <span class=filename>GENERIC</span> em <span class=filename>/boot/GENERIC</span>. Será útil no diagnóstico de vários problemas e na execução de atualizações de versão. Consulte <a href=#freebsd-update-custom-kernel-9x>Kernels personalizados com o FreeBSD 9.X e posteriores</a> para obter instruções sobre como obter uma cópia do kernel <span class=filename>GENERIC</span>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>A menos que a configuração padrão em <span class=filename>/etc/freebsd-update.conf</span> tenha sido alterada, o <code>freebsd-update</code> instalará o código fonte atualizado do kernel juntamente com o restante das atualizações. O processo de recompilação e reinstalação de um novo kernel personalizado poderá ser executado da maneira usual.</p></div><div class=paragraph><p>As atualizações distribuídas pelo <code>freebsd-update</code> nem sempre envolvem o kernel. Não é necessário recompilar um kernel personalizado se o código fonte do kernel não tiverem sido modificado pelo <code>freebsd-update install</code>. No entanto, o <code>freebsd-update</code> sempre atualizará o <span class=filename>/usr/src/sys/conf/newvers.sh</span>. O nível de patch atual, conforme indicado pelo número <code>-p</code> relatado pelo <code>uname -r</code>, é obtido desse arquivo. Recompilar um kernel personalizado, mesmo que nada mais tenha sido alterado, permite que o <code>uname</code> relate com precisão o nível de patch atual do sistema. Isso é particularmente útil ao manter vários sistemas, pois permite uma avaliação rápida das atualizações instaladas em cada um deles.</p></div></div><div class=sect3><h4 id=freebsdupdate-upgrade>23.2.3. Realizando Upgrades de Versão Principais e Menores<a class=anchor href=#freebsdupdate-upgrade></a></h4><div class=paragraph><p>Atualizações de uma versão menor do FreeBSD para outra, como do FreeBSD 9.0 para o FreeBSD 9.1, são chamadas de upgrades de <em>versão menor</em>. Atualizações de <em>versões principais</em> ocorrem quando o FreeBSD é atualizado de uma versão principal para outra, como do FreeBSD 9.X para o FreeBSD 10.X. Ambos os tipos de atualizações podem ser executados fornecendo um target de versão de release para o <code>freebsd-update</code>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Se o sistema estiver executando um kernel personalizado, certifique-se de que uma cópia do kernel <span class=filename>GENERIC</span> exista em <span class=filename>/boot/GENERIC</span> antes de iniciar o upgrade. Consulte <a href=#freebsd-update-custom-kernel-9x>Kernels personalizados com o FreeBSD 9.X e posteriores</a> para obter instruções sobre como obter uma cópia do kernel <span class=filename>GENERIC</span>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>O seguinte comando, quando executado em um sistema FreeBSD 9.0, irá atualizá-lo para o FreeBSD 9.1:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># freebsd-update -r 9.1-RELEASE upgrade</span></code></pre></div></div><div class=paragraph><p>Depois que o comando for recebido, o <code>freebsd-update</code> avaliará o arquivo de configuração e o sistema atual na tentativa de reunir as informações necessárias para executar a atualização. Uma listagem de tela exibirá quais componentes foram e quais não foram detectados. Por exemplo:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Looking up update.FreeBSD.org mirrors... 1 mirrors found.
Fetching metadata signature <span class=k>for </span>9.0-RELEASE from update1.FreeBSD.org... <span class=k>done</span><span class=nb>.</span>
Fetching metadata index... <span class=k>done</span><span class=nb>.</span>
Inspecting system... <span class=k>done</span><span class=nb>.</span>

The following components of FreeBSD seem to be installed:
kernel/smp src/base src/bin src/contrib src/crypto src/etc src/games
src/gnu src/include src/krb5 src/lib src/libexec src/release src/rescue
src/sbin src/secure src/share src/sys src/tools src/ubin src/usbin
world/base world/info world/lib32 world/manpages

The following components of FreeBSD <span class=k>do </span>not seem to be installed:
kernel/generic world/catpages world/dict world/doc world/games
world/proflibs

Does this look reasonable <span class=o>(</span>y/n<span class=o>)</span>? y</code></pre></div></div><div class=paragraph><p>Neste ponto, o <code>freebsd-update</code> tentará baixar todos os arquivos necessários para a atualização. Em alguns casos, o usuário pode ser questionado sobre o que instalar ou como proceder.</p></div><div class=paragraph><p>Ao usar um kernel personalizado, a etapa acima produzirá um aviso semelhante ao seguinte:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>WARNING: This system is running a <span class=s2>&#34;MYKERNEL&#34;</span> kernel, which is not a
kernel configuration distributed as part of FreeBSD 9.0-RELEASE.
This kernel will not be updated: you MUST update the kernel manually
before running <span class=s2>&#34;/usr/sbin/freebsd-update install&#34;</span></code></pre></div></div><div class=paragraph><p>Este aviso pode ser ignorado com segurança neste momento. O kernel <span class=filename>GENERIC</span> atualizado será usado como uma etapa intermediária no processo de atualização.</p></div><div class=paragraph><p>Depois que todos os patches tiverem sido baixados para o sistema local, eles serão aplicados. Esse processo pode demorar um pouco, dependendo da velocidade e da carga de trabalho da máquina. Os arquivos de configuração serão então mesclados. O processo de mesclagem requer alguma intervenção do usuário, pois um arquivo pode ser mesclado ou um editor pode aparecer na tela para uma mesclagem manual. Os resultados de cada mesclagem bem-sucedida serão mostrados para o usuário enquanto o processo continua. Um merge falho ou ignorado fará com que o processo seja abortado. Os usuários podem desejar fazer um backup de <span class=filename>/etc</span> e mesclar manualmente os arquivos importantes, como o <span class=filename>master.passwd</span> ou o <span class=filename>group</span> posteriormente.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>O sistema não está sendo alterado, já que todos os patches e merges estão acontecendo em outro diretório. Uma vez que todas as correções tenham sido aplicadas com sucesso, e todos os arquivos de configuração foram mesclados e tudo indicar que o processo ocorrerá sem problemas, as alterações poderão ser confirmadas pelo usuário usando o seguinte comando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># freebsd-update install</span></code></pre></div></div></td></tr></tbody></table></div><div class=paragraph><p>O kernel e os módulos do kernel serão atualizados primeiro. Se o sistema estiver sendo executado com um kernel personalizado, use o <a href="https://man.freebsd.org/cgi/man.cgi?query=nextboot&amp;sektion=8&amp;format=html">nextboot(8)</a> para definir que o kernel para a próxima inicialização será o <span class=filename>/boot/GENERIC</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># nextboot -k GENERIC</span></code></pre></div></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Antes de reinicializar com o kernel <span class=filename>GENERIC</span>, verifique se ele contém todos os drivers necessários para o sistema inicializar corretamente e se conectar à rede, se a máquina que está sendo atualizada for acessada remotamente. Em particular, se o kernel customizado em execução contiver funcionalidades internas normalmente fornecidas pelos módulos do kernel, certifique-se de carregar temporariamente estes módulos no kernel <span class=filename>GENERIC</span> usando o <span class=filename>/boot/loader.conf</span>. Recomenda-se desabilitar os serviços não essenciais, bem como todas as montagens de disco e de rede, até que o processo de atualização seja concluído.</p></div></td></tr></tbody></table></div><div class=paragraph><p>A máquina agora deve ser reiniciada com o kernel atualizado:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># shutdown -r now</span></code></pre></div></div><div class=paragraph><p>Quando o sistema estiver on-line, reinicie o <code>freebsd-update</code> usando o comando a seguir. Como o estado do processo foi salvo, o <code>freebsd-update</code> não será iniciado desde o início, mas passará para a próxima fase e removerá todas as bibliotecas compartilhadas e os arquivos de objetos antigos.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># freebsd-update install</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Dependendo se os números de versão de uma biblioteca foram incrementados ou não, pode haver apenas duas fases de instalação em vez de três.</p></div></td></tr></tbody></table></div><div class=paragraph><p>A atualização está completa agora. Se esta for uma atualização de versão principal, reinstale todas os ports e pacotes conforme descrito em <a href=#freebsdupdate-portsrebuild>Atualizando pacotes após atualizar para uma versão principal (Major Release)</a>.</p></div><div class=sect4><h5 id=freebsd-update-custom-kernel-9x>23.2.3.1. Kernels personalizados com o FreeBSD 9.X e posteriores<a class=anchor href=#freebsd-update-custom-kernel-9x></a></h5><div class=paragraph><p>Antes de usar o <code>freebsd-update</code>, assegure-se de que uma cópia do kernel <span class=filename>GENERIC</span> exista em <span class=filename>/boot/GENERIC</span>. Se um kernel personalizado foi compilado apenas uma vez, o kernel em <span class=filename>/boot/kernel.old</span> é o kernel <code>GENERIC</code>. Simplesmente renomeie este diretório para <span class=filename>/boot/GENERIC</span>.</p></div><div class=paragraph><p>Se um kernel personalizado foi compilado mais de uma vez ou se é desconhecido quantas vezes o kernel personalizado foi compilado, obtenha uma cópia do kernel <code>GENERIC</code> que corresponda à versão atual do sistema operacional. Se o acesso físico ao sistema estiver disponível, uma cópia do kernel <code>GENERIC</code> pode ser instalada a partir da mídia de instalação:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount /cdrom</span>
<span class=c># cd /cdrom/usr/freebsd-dist</span>
<span class=c># tar -C/ -xvf kernel.txz boot/kernel/kernel</span></code></pre></div></div><div class=paragraph><p>Como alternativa, o kernel <code>GENERIC</code> pode ser recriado e instalado a partir da do código fonte:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/src</span>
<span class=c># make kernel __MAKE_CONF=/dev/null SRCCONF=/dev/null</span></code></pre></div></div><div class=paragraph><p>Para que este kernel seja identificado como o kernel <code>GENERIC</code> pelo <code>freebsd-update</code>, o arquivo de configuração <span class=filename>GENERIC</span> não deve ter sido modificado de forma alguma. Também é sugerido que o kernel seja compilado sem outras opções especiais.</p></div><div class=paragraph><p>A reinicialização no kernel <span class=filename>GENERIC</span> não é necessária, pois o <code>freebsd-update</code> só precisa que o <span class=filename>/boot/GENERIC</span> exista.</p></div></div><div class=sect4><h5 id=freebsdupdate-portsrebuild>23.2.3.2. Atualizando pacotes após atualizar para uma versão principal (Major Release)<a class=anchor href=#freebsdupdate-portsrebuild></a></h5><div class=paragraph><p>Geralmente, os aplicativos instalados continuarão funcionando sem problemas após atualizações de versões menores. As versões principais usam diferentes interfaces binárias de aplicativos (ABIs), que quebram a maioria dos aplicativos de terceiros. Após uma atualização de versão principal, todos os pacotes e ports instalados precisam ser atualizados. Pacotes podem ser atualizados usando <code>pkg upgrade</code>. Para atualizar os ports instalados, use um utilitário como o <a class=package href=https://cgit.freebsd.org/ports/tree/ports-mgmt/portmaster/>ports-mgmt/portmaster</a>.</p></div><div class=paragraph><p>Uma atualização forçada de todos os pacotes instalados substituirá os pacotes por novas versões a partir do repositório, mesmo que o número da versão não tenha aumentado. Isso é necessário por causa da alteração da versão do ABI que ocorre ao atualizar entre versões principais do FreeBSD. A atualização forçada pode ser realizada executando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg-static upgrade -f</span></code></pre></div></div><div class=paragraph><p>Uma recompilação de todos os aplicativos instalados pode ser realizada com este comando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portmaster -af</span></code></pre></div></div><div class=paragraph><p>Este comando exibirá as telas de configuração de cada aplicativo que possui opções configuráveis e aguardará que o usuário interaja com estas telas. Para evitar esse comportamento e usar apenas as opções padrões, inclua <code>-G</code> no comando acima.</p></div><div class=paragraph><p>Quando as atualizações de software estiverem concluídas, conclua o processo de atualização com uma chamada final para o <code>freebsd-update</code> para amarrar todas as pontas soltas no processo de atualização:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># freebsd-update install</span></code></pre></div></div><div class=paragraph><p>Se o kernel <span class=filename>GENERIC</span> foi usado temporariamente, este é o momento de construir e instalar um novo kernel personalizado usando as instruções do <a href=./#kernelconfig>Configurando o kernel do FreeBSD</a>.</p></div><div class=paragraph><p>Reinicialize a máquina na nova versão do FreeBSD. O processo de atualização está concluído agora.</p></div></div></div><div class=sect3><h4 id=freebsdupdate-system-comparison>23.2.4. Comparação do estado do sistema<a class=anchor href=#freebsdupdate-system-comparison></a></h4><div class=paragraph><p>O estado da versão instalada do FreeBSD em relação a uma boa cópia conhecida pode ser testado usando o <code>freebsd-update IDS</code>. Este comando avalia a versão atual dos utilitários do sistema, bibliotecas e arquivos de configuração e pode ser usado como um Sistema de Detecção de Intrusão embutido (IDS).</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Este comando não é um substituto para um IDS real como o <a class=package href=https://cgit.freebsd.org/ports/tree/security/snort/>security/snort</a>. Como o <code>freebsd-update</code> armazena dados no disco, a possibilidade de adulteração é evidente. Embora esta possibilidade possa ser reduzida usando o <code>kern.securelevel</code> e armazenando os dados do <code>freebsd-update</code> em um sistema de arquivos read-only quando não estiver em uso, uma solução melhor seria comparar o sistema com um disco seguro, como um DVD ou dispositivo de disco externo USB armazenado em segurança. Um método alternativo para fornecer a funcionalidade de IDS usando um utilitário interno é descrito em <a href=./#security-ids>Verificação Binária</a></p></div></td></tr></tbody></table></div><div class=paragraph><p>Para começar a comparação, especifique um arquivo de saída para salvar os resultados:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># freebsd-update IDS &gt;&gt; outfile.ids</span></code></pre></div></div><div class=paragraph><p>O sistema agora será inspecionado e uma longa lista de arquivos, junto com os valores de hash SHA256 tanto para o valor conhecido na release e como na instalação atual, será enviada para o arquivo de saída especificado.</p></div><div class=paragraph><p>As entradas na listagem são extremamente longas, mas o formato de saída pode ser facilmente analisado. Por exemplo, para obter uma lista de todos os arquivos que diferem daqueles na release, execute o seguinte comando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cat outfile.ids | awk &#39;{ print $1 }&#39; | more</span>
/etc/master.passwd
/etc/motd
/etc/passwd
/etc/pf.conf</code></pre></div></div><div class=paragraph><p>Este exemplo de saída foi truncado, pois existem muito mais arquivos. Alguns arquivos possuem modificações naturais. Por exemplo, o <span class=filename>/etc/passwd</span> será modificado se usuários tiverem sido adicionados ao sistema. Módulos de kernel podem diferir pois o <code>freebsd-update</code> pode tê-los atualizado. Para excluir arquivos ou diretórios específicos, adicione-os à opção <code>IDSIgnorePaths</code> em <span class=filename>/etc/freebsd-update.conf</span>.</p></div></div></div><div class=sect2><h3 id=updating-upgrading-documentation>23.3. Atualizando o Conjunto de Documentação<a class=anchor href=#updating-upgrading-documentation></a></h3><div class=paragraph><p>A documentação é parte integrante do sistema operacional FreeBSD. Enquanto uma versão atualizada da documentação do FreeBSD está sempre disponível no site do FreeBSD (<a href=https://www.FreeBSD.org/doc/>https://www.freebsd.org/doc/</a>), pode ser útil ter uma cópia local atualizada do site do FreeBSD, manuais, FAQ e artigos.</p></div><div class=paragraph><p>Esta seção descreve como usar os fontes ou a Coleção de Ports do FreeBSD para manter uma cópia local da documentação do FreeBSD atualizada.</p></div><div class=paragraph><p>Para obter informações sobre como editar e enviar correções para a documentação, consulte o Primer do Projeto de Documentação do FreeBSD para Novos Colaboradores (<a href=https://docs.freebsd.org/pt-br/books/fdp-primer/>Primer do Projeto de Documentação do FreeBSD</a>).</p></div><div class=sect3><h4 id=updating-installed-documentation>23.3.1. Atualizando a documentação a partir do código-fonte<a class=anchor href=#updating-installed-documentation></a></h4><div class=paragraph><p>Recompilar a documentação do FreeBSD a partir do código-fonte requer uma coleção de ferramentas que não fazem parte do sistema básico do FreeBSD. As ferramentas necessárias podem ser instaladas a partir do pacote <a class=package href=https://cgit.freebsd.org/ports/tree/textproc/docproj/>textproc/docproj</a> ou do port desenvolvido pelo Projeto de Documentação do FreeBSD.</p></div><div class=paragraph><p>Uma vez instalado, use o svnlite para buscar uma cópia limpa dos fontes da documentação:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># svnlite checkout https://svn.FreeBSD.org/doc/head /usr/doc</span></code></pre></div></div><div class=paragraph><p>O download inicial dos fontes da documentação pode demorar um pouco. Deixe executar até completar.</p></div><div class=paragraph><p>Futuras atualizações dos fontes da documentação podem ser obtidas executando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># svnlite update /usr/doc</span></code></pre></div></div><div class=paragraph><p>Depois que um snapshot atualizado dos fontes da documentação for obtido e disponibilizado em <span class=filename>/usr/doc</span>, tudo estará pronto para uma atualização da documentação instalada.</p></div><div class=paragraph><p>Uma atualização completa de todos os idiomas disponíveis pode ser realizada digitando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/doc</span>
<span class=c># make install clean</span></code></pre></div></div><div class=paragraph><p>Se uma atualização de apenas um idioma específico for desejada, o <code>make</code> pode ser executado em um subdiretório específico de idioma do <span class=filename>/usr/doc</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/doc/en_US.ISO8859-1</span>
<span class=c># make install clean</span></code></pre></div></div><div class=paragraph><p>Uma maneira alternativa de atualizar a documentação é executar este comando a partir do <span class=filename>/usr/doc</span> ou do subdiretório específico do idioma desejado:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># make update</span></code></pre></div></div><div class=paragraph><p>Os formatos de saída que serão instalados podem ser especificados definindo o parâmetro <code>FORMATS</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/doc</span>
<span class=c># make FORMATS=&#39;html html-split&#39; install clean</span></code></pre></div></div><div class=paragraph><p>Várias opções estão disponíveis para facilitar o processo de atualização de apenas partes da documentação ou a construção de traduções específicas. Estas opções podem ser configuradas como opções de todo o sistema no <span class=filename>/etc/make.conf</span>, ou como opções de linha de comando passadas para o <code>make</code>.</p></div><div class=paragraph><p>As opções incluem:</p></div><div class=dlist><dl><dt class=hdlist1><code>DOC_LANG</code></dt><dd><p>A lista de idiomas e codificações para compilar e instalar, como <code>en_US.ISO8859-1</code> para documentação em inglês.</p></dd><dt class=hdlist1><code>FORMATS</code></dt><dd><p>Um formato único ou uma lista de formatos de saída a serem criados. Atualmente os formatos suportados são, <code>html</code>, <code>html-split</code>, <code>txt</code>, <code>ps</code>, e <code>pdf</code>.</p></dd><dt class=hdlist1><code>DOCDIR</code></dt><dd><p>Onde instalar a documentação. O padrão é <span class=filename>/usr/shared/doc</span>.</p></dd></dl></div><div class=paragraph><p>Para mais variáveis do <code>make</code> suportadas como opções system-wide no FreeBSD, consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=make.conf&amp;sektion=5&amp;format=html">make.conf(5)</a>.</p></div></div><div class=sect3><h4 id=doc-ports-install-package>23.3.2. Atualizando a documentação a partir do ports<a class=anchor href=#doc-ports-install-package></a></h4><div class=paragraph><p>A seção anterior apresentou um método para atualizar a documentação do FreeBSD a partir do código fonte. Esta seção descreve um método alternativo que usa a Coleção de Ports e possibilita:</p></div><div class=ulist><ul><li><p>Instalar pacotes pré-compilados da documentação, sem precisar compilar nada localmente ou instalar o conjunto de ferramentas de documentação.</p></li><li><p>Compilar o código fonte da documentação por meio do framework de ports, facilitando o check-out e as etapas de compilação.</p></li></ul></div><div class=paragraph><p>Este método de atualização da documentação do FreeBSD é suportado por um conjunto de ports e pacotes de documentação que são atualizados mensalmente pela Equipe de Engenharia da Documentação <a href=mailto:doceng@FreeBSD.org>doceng@FreeBSD.org</a>. Eles estão listados na Coleção de Ports do FreeBSD, na categoria docs (<a href=http://www.freshports.org/docs/>http://www.freshports.org/docs/</a>).</p></div><div class=paragraph><p>A organização dos ports de documentação é a seguinte:</p></div><div class=ulist><ul><li><p>O pacote ou port <a class=package href=https://cgit.freebsd.org/ports/tree/misc/freebsd-doc-en/>misc/freebsd-doc-en</a> instala toda a documentação em inglês.</p></li><li><p>O meta-pacote ou port do pacote <a class=package href=https://cgit.freebsd.org/ports/tree/misc/freebsd-doc-all/>misc/freebsd-doc-all</a> instala toda a documentação em todos os idiomas disponíveis.</p></li><li><p>Existe um pacote e um port para cada tradução, como <a class=package href=https://cgit.freebsd.org/ports/tree/misc/freebsd-doc-hu/>misc/freebsd-doc-hu</a> para a documentação húngara.</p></li></ul></div><div class=paragraph><p>Quando pacotes binários são usados, a documentação do FreeBSD será instalada em todos os formatos disponíveis para o idioma especificado. Por exemplo, o comando a seguir instalará o pacote mais recente da documentação em húngaro:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install hu-freebsd-doc</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Os pacotes usam um formato que difere do nome do port correspondente: <code><em>lang</em>-freebsd-doc</code>, onde <em>lang</em> é o formato abreviado do código de idioma, como <code>hu</code> para húngaro, ou <code>zh_cn</code> para chinês simplificado.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Para especificar o formato da documentação, compile o port em vez de instalar o pacote. Por exemplo, para compilar e instalar a documentação em inglês:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/misc/freebsd-doc-en</span>
<span class=c># make install clean</span></code></pre></div></div><div class=paragraph><p>O port fornece um menu de configuração no qual o formato para compilar e instalar pode ser especificado. Por padrão, o HTML dividido, semelhante ao formato usado em <a href=http://www.FreeBSD.org>http://www.FreeBSD.org</a> e o PDF estão selecionados.</p></div><div class=paragraph><p>Alternativamente, várias opções <code>make</code> podem ser especificadas ao compilar um port de documentação, incluindo:</p></div><div class=dlist><dl><dt class=hdlist1><code>WITH_HTML</code></dt><dd><p>Cria o formato HTML com um único arquivo HTML por documento. A documentação formatada é salva em um arquivo chamado <span class=filename>article.html</span> ou <span class=filename>book.html</span>.</p></dd><dt class=hdlist1><code>WITH_PDF</code></dt><dd><p>A documentação formatada é salva em um arquivo chamado <span class=filename>article.pd</span> ou <span class=filename>book.pdf</span>.</p></dd><dt class=hdlist1><code>DOCBASE</code></dt><dd><p>Especifica onde instalar a documentação. O padrão é <span class=filename>/usr/local/shared/doc/freebsd</span>.</p></dd></dl></div><div class=paragraph><p>Este exemplo usa variáveis para instalar a documentação húngara como um arquivo PDF no diretório especificado:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/misc/freebsd-doc-hu</span>
<span class=c># make -DWITH_PDF DOCBASE=share/doc/freebsd/hu install clean</span></code></pre></div></div><div class=paragraph><p>Pacotes ou ports de documentação podem ser atualizados usando as instruções em <a href=./#ports>Instalando Aplicativos. Pacotes e Ports</a>. Por exemplo, o seguinte comando atualiza a documentação húngara instalada usando <a class=package href=https://cgit.freebsd.org/ports/tree/ports-mgmt/portmaster/>ports-mgmt/portmaster</a> através do uso apenas de pacotes:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portmaster -PP hu-freebsd-doc</span></code></pre></div></div></div></div><div class=sect2><h3 id=current-stable>23.4. Acompanhando um ramo de desenvolvimento<a class=anchor href=#current-stable></a></h3><div class=paragraph><p>O FreeBSD possui duas ramificações de desenvolvimento: FreeBSD-CURRENT e FreeBSD-STABLE.</p></div><div class=paragraph><p>Esta seção fornece uma explicação sobre cada ramo e seu público-alvo, bem como manter um sistema atualizado com cada ramo respectivo.</p></div><div class=sect3><h4 id=current>23.4.1. Usando o FreeBSD-CURRENT<a class=anchor href=#current></a></h4><div class=paragraph><p>O FreeBSD-CURRENT é o desenvolvimento "bleeding edge" do FreeBSD e espera-se que os usuários do FreeBSD-CURRENT tenham um alto grau de habilidade técnica. Usuários menos técnicos que desejam acompanhar um ramo de desenvolvimento devem acompanhar o FreeBSD-STABLE.</p></div><div class=paragraph><p>O FreeBSD-CURRENT é o código-fonte mais recente do FreeBSD e inclui trabalhos em andamento, mudanças experimentais e mecanismos de transição que podem ou não estar presentes na próxima versão oficial. Enquanto muitos desenvolvedores do FreeBSD compilam o código-fonte do FreeBSD-CURRENT diariamente, há curtos períodos de tempo em que o código fonte pode não ser compilável. Esses problemas são resolvidos o mais rápidamente possível, mas se o FreeBSD-CURRENT traz ou não uma nova funcionalidade pode ser uma questão de quando o código-fonte foi sincronizado.</p></div><div class=paragraph><p>O FreeBSD-CURRENT é disponibilizado para três grupos de interesse principais:</p></div><div class="olist arabic"><ol class=arabic><li><p>Membros da comunidade do FreeBSD que estão trabalhando ativamente em alguma parte da árvore de códigos fontes.</p></li><li><p>Membros da comunidade FreeBSD que são testadores ativos. Eles estão dispostos a gastar tempo resolvendo problemas, fazendo sugestões sobre mudanças e sobre a direção geral do FreeBSD, e enviando correções.</p></li><li><p>Usuários que desejam ficar de olho nas coisas, usam o código fonte atual para fins de referência ou fazem comentários ocasionais ou contribuições de código.</p></li></ol></div><div class=paragraph><p>O FreeBSD-CURRENT <em>não</em> deve ser considerado um fast-track para obter novos recursos antes do próximo release, já que os recursos de pré-release ainda não foram totalmente testados e provavelmente contêm bugs. Não é uma maneira rápida de obter correções de bugs, pois qualquer commit é tão provável de introduzir novos bugs quanto consertar os existentes. O FreeBSD-CURRENT não é de nenhuma maneira "oficialmente suportado".</p></div><div class=paragraph><p>Para acompanhar o FreeBSD-CURRENT:</p></div><div class="olist arabic"><ol class=arabic><li><p>Junte-se as listas <a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-current>freebsd-current</a> e <a href=http://lists.FreeBSD.org/mailman/listinfo/svn-src-head>svn-src-head</a>. Isto é <em>essencial</em> para ver os comentários que as pessoas estão fazendo sobre o estado atual do sistema e para receber importantes boletins sobre o estado atual do FreeBSD-CURRENT.</p><div class=paragraph><p>A lista <a href=http://lists.FreeBSD.org/mailman/listinfo/svn-src-head>svn-src-head</a> registra a entrada de log de commit para cada alteração assim que ela é feita, juntamente com qualquer informação pertinente sobre possíveis efeitos colaterais.</p></div><div class=paragraph><p>Para juntar-se a estas listas, vá para <a href=http://lists.FreeBSD.org/mailman/listinfo>http://lists.FreeBSD.org/mailman/listinfo</a>, clique na lista para se inscrever e siga as instruções. A fim de rastrear mudanças em toda a árvore de código-fonte, não apenas as mudanças no FreeBSD-CURRENT, inscreva-se na lista <a href=http://lists.FreeBSD.org/mailman/listinfo/svn-src-all>svn-src-all</a>.</p></div></li><li><p>Sincronize com o código-fonte do FreeBSD-CURRENT. Normalmente, o <a href=./#svn>svnlite</a> é usado para obter o código -CURRENT da ramificação <code>head</code> de um dos sites espelhos do Subversion listados em <a href=./#svn-mirrors>Sites Espelho do Subversion</a>.</p></li><li><p>Devido ao tamanho do repositório, alguns usuários escolhem sincronizar apenas as seções do código-fonte que lhes interessam ou para as quais estão contribuindo com correções. No entanto, os usuários que planejam compilar o sistema operacional a partir do código-fonte devem baixar <em>tudo</em> do FreeBSD-CURRENT, não apenas as partes selecionadas.</p><div class=paragraph><p>Antes de compilar o FreeBSD-CURRENT , leia o <span class=filename>/usr/src/Makefile</span> com muito cuidado e siga as instruções em <a href=#makeworld>Atualizando o FreeBSD a partir do código fonte</a>. Leia a <a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-current>lista de discussão do FreeBSD-CURRENT</a> e o <span class=filename>/usr/src/UPDATING</span> para manter-se atualizado sobre outros procedimentos de bootstrapping que algumas vezes se tornam necessários no caminho para a próxima versão.</p></div></li><li><p>Ser ativo! Usuários do FreeBSD-CURRENT são encorajados a enviar suas sugestões para melhorias ou correções de bugs. Sugestões acompanhadas de código são sempre bem vindas.</p></li></ol></div></div><div class=sect3><h4 id=stable>23.4.2. Usando o FreeBSD-STABLE<a class=anchor href=#stable></a></h4><div class=paragraph><p>O FreeBSD-STABLE é o ramo de desenvolvimento a partir do qual as releases principais são feitas. Mudanças entram neste ramo em um ritmo mais lento e com a suposição geral de que elas foram testadas primeiro no FreeBSD-CURRENT. Ele <em>ainda</em> é um ramo de desenvolvimento e, a qualquer momento, as fontes para o FreeBSD-STABLE podem ou não ser adequadas para uso geral. É simplesmente outra trilha de desenvolvimento de engenharia, não um recurso para usuários finais. Usuários que não possuem recursos para realizar testes devem, ao invés disso, executar a release mais recente do FreeBSD.</p></div><div class=paragraph><p>Os interessados em acompanhar ou contribuir para o processo de desenvolvimento do FreeBSD, especialmente no que se refere à próxima versão do FreeBSD, devem considerar seguir o FreeBSD-STABLE.</p></div><div class=paragraph><p>Embora seja esperado que o ramo FreeBSD-STABLE compile e execute o tempo todo, isso não pode ser garantido. Uma vez que mais pessoas executam o FreeBSD-STABLE do que o FreeBSD-CURRENT, é inevitável que bugs e problemas mais raros às vezes sejam encontrados no FreeBSD-STABLE os quais não foram detectados no FreeBSD-CURRENT. Por esta razão, não se deve seguir cegamente o FreeBSD-STABLE. É particularmente importante <em>não</em> atualizar quaisquer servidores de produção para o FreeBSD-STABLE sem testar completamente o código em um ambiente de desenvolvimento ou de teste.</p></div><div class=paragraph><p>Para acompanhar o FreeBSD-STABLE:</p></div><div class="olist arabic"><ol class=arabic><li><p>Junte-se à lista <a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-stable>freebsd-stable</a> para se manter informado sobre as dependências de compilação que podem aparecer no FreeBSD-STABLE ou qualquer outro problema que requeira atenção especial. Os desenvolvedores também farão anúncios nesta lista de e-mails quando estiverem contemplando alguma correção ou atualização controversa, dando aos usuários uma chance de responder se tiverem alguma questão a ser levantada sobre a alteração proposta.</p><div class=paragraph><p>Junte-se à lista svn relevante para o ramo que está sendo acompanhado. Por exemplo, os usuários que acompanham o ramo 9-STABLE devem se juntar a lista <a href=http://lists.FreeBSD.org/mailman/listinfo/svn-src-stable-9>svn-src-stable-9</a>. Esta lista registra a entrada do log de commit para cada alteração à medida que ela é feita, junto com qualquer informação pertinente sobre os possíveis efeitos colaterais.</p></div><div class=paragraph><p>Para se juntar a estas listas, vá para <a href=http://lists.FreeBSD.org/mailman/listinfo>http://lists.FreeBSD.org/mailman/listinfo</a>, clique na lista para se inscrever e siga as instruções. Se desejar acompanhar as mudanças para toda a árvore de código-fonte, inscreva-se na <a href=http://lists.FreeBSD.org/mailman/listinfo/svn-src-all>svn-src-all</a> .</p></div></li><li><p>Para instalar um novo sistema FreeBSD-STABLE, instale a versão mais recente do FreeBSD-STABLE a partir de um dos <a href=./#mirrors>sites espelho do FreeBSD</a> ou use um snapshot mensal criado a partir do FreeBSD-STABLE. Consulte <a href=https://www.FreeBSD.org/snapshots/>www.freebsd.org/snapshots</a> para maiores informações sobre snapshots.</p><div class=paragraph><p>Para compilar ou atualizar um sistema FreeBSD existente para o FreeBSD-STABLE, use o <a href=./#svn>svnlite</a> para obter o código-fonte da ramificação desejada. Os nomes das ramificações, como <code>stable/9</code>, estão listados em <a href=https://www.FreeBSD.org/releng/>www.freebsd.org/releng</a>.</p></div></li><li><p>Antes de compilar ou atualizar para o FreeBSD-STABLE , leia o <span class=filename>/usr/src/Makefile</span> cuidadosamente e siga as instruções em <a href=#makeworld>Atualizando o FreeBSD a partir do código fonte</a>. Leia a <a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-stable>lista de discussão FreeBSD-STABLE</a> e o <span class=filename>/usr/src/UPDATING</span> para manter-se atualizado sobre outros procedimentos de bootstrapping que às vezes se tornam necessários no caminho para o próximo release.</p></li></ol></div></div></div><div class=sect2><h3 id=makeworld>23.5. Atualizando o FreeBSD a partir do código fonte<a class=anchor href=#makeworld></a></h3><div class=paragraph><p>A atualização do FreeBSD através da compilação a partir do código-fonte oferece várias vantagens sobre as atualizações binárias. O código pode ser compilado com opções para aproveitar o hardware específico. Partes do sistema base podem ser compiladas com configurações não padrões, ou deixadas de fora somente onde não são necessárias ou desejadas. O processo de compilação leva mais tempo para atualizar um sistema do que apenas instalar atualizações binárias, mas permite customização completa para produzir uma versão do FreeBSD adaptada as suas necessidades.</p></div><div class=sect3><h4 id=updating-src-quick-start>23.5.1. Inicio Rápido<a class=anchor href=#updating-src-quick-start></a></h4><div class=paragraph><p>Esta é uma referência rápida para as etapas típicas usadas para atualizar o FreeBSD compilando-o a partir do código fonte. As seções posteriores descrevem o processo com mais detalhes.</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Atualizar e Compilar</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># svnlite update /usr/src  </span><i class=conum data-value=1></i><b>(1)</b>
check /usr/src/UPDATING  <i class=conum data-value=2></i><b>(2)</b>
<span class=c># cd /usr/src          </span><i class=conum data-value=3></i><b>(3)</b>
<span class=c># make -j4 buildworld  </span><i class=conum data-value=4></i><b>(4)</b>
<span class=c># make -j4 kernel      </span><i class=conum data-value=5></i><b>(5)</b>
<span class=c># shutdown -r now      </span><i class=conum data-value=6></i><b>(6)</b>
<span class=c># cd /usr/src          </span><i class=conum data-value=7></i><b>(7)</b>
<span class=c># make installworld    </span><i class=conum data-value=8></i><b>(8)</b>
<span class=c># mergemaster -Ui      </span><i class=conum data-value=9></i><b>(9)</b>
<span class=c># shutdown -r now      </span><i class=conum data-value=10></i><b>(10)</b></code></pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>Obtenha a versão mais recente do código fonte. Veja <a href=#updating-src-obtaining-src>Atualizando o código fonte</a> para maiores informações sobre como obter e atualizar o código fonte.</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td>Verifique o <span class=filename>/usr/src/UPDATING</span> para quaisquer etapas manuais necessárias antes ou depois de compilar a partir do código fonte.</td></tr><tr><td><i class=conum data-value=3></i><b>3</b></td><td>Vá para o diretório de origem.</td></tr><tr><td><i class=conum data-value=4></i><b>4</b></td><td>Compile o mundo, tudo exceto o kernel.</td></tr><tr><td><i class=conum data-value=5></i><b>5</b></td><td>Compile e instale o kernel. Isso é equivalente a <code>make installkernel installkernel</code>.</td></tr><tr><td><i class=conum data-value=6></i><b>6</b></td><td>Reinicialize o sistema com o novo kernel.</td></tr><tr><td><i class=conum data-value=7></i><b>7</b></td><td>Vá para o diretório de origem.</td></tr><tr><td><i class=conum data-value=8></i><b>8</b></td><td>Instale o mundo.</td></tr><tr><td><i class=conum data-value=9></i><b>9</b></td><td>Atualize e mescle os arquivos de configuração em <span class=filename>/etc/</span>.</td></tr><tr><td><i class=conum data-value=10></i><b>10</b></td><td>Reinicie o sistema para usar o mundo e o kernel recém-compilados.</td></tr></tbody></table></div></li></ol></div></div></div></div><div class=sect3><h4 id=updating-src-preparing>23.5.2. Preparando-se para uma atualização a partir do código fonte<a class=anchor href=#updating-src-preparing></a></h4><div class=paragraph><p>Leia o <span class=filename>/usr/src/UPDATING</span>. Quaisquer etapas manuais que devem ser executadas antes ou depois de uma atualização são descritas neste arquivo.</p></div></div><div class=sect3><h4 id=updating-src-obtaining-src>23.5.3. Atualizando o código fonte<a class=anchor href=#updating-src-obtaining-src></a></h4><div class=paragraph><p>O código fonte do FreeBSD está localizado em <span class=filename>/usr/src/</span>. O método preferido para atualizar os fontes é através do sistema de controle de versão do Subversion. Verifique se o código-fonte está sob controle de versão:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># svnlite info /usr/src</span>
Path: /usr/src
Working Copy Root Path: /usr/src
...</code></pre></div></div><div class=paragraph><p>Isto indica que o <span class=filename>/usr/src/</span> está sob controle de versão e pode ser atualizado com o <a href="https://man.freebsd.org/cgi/man.cgi?query=svnlite&amp;sektion=1&amp;format=html">svnlite(1)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># svnlite update /usr/src</span></code></pre></div></div><div class=paragraph><p>O processo de atualização pode levar algum tempo se o diretório não tiver sido atualizado recentemente. Após a conclusão, o código-fonte estará atualizado e o processo de compilação descrito na próxima seção poderá começar.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=title>Obtendo o código fonte</div><div class=paragraph><p>Se a saída disser que <code>'/usr/src' is not a working copy</code>, estão faltando arquivos no diretório ou eles foram instalados com um método diferente. Um novo checkout da fonte é necessário.</p></div><table id=updating-src-obtaining-src-repopath class="tableblock frame-all grid-all stretch"><caption class=title>Tabela 18. Versões do FreeBSD e Caminhos do Repositório</caption><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Saída do uname -r</th><th class="tableblock halign-left valign-top">Caminho do Repositório</th><th class="tableblock halign-left valign-top">Descrição</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code><em>X.Y</em>-RELEASE</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>base/releng/</code><em>X.Y</em></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>A versão do release mais apenas correções críticas de segurança e correção de erros. Este ramo é recomendado para a maioria dos usuários.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code><em>X.Y</em>-STABLE</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>base/stable/</code><em>X</em></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>A versão de Release mais todos os desenvolvimentos adicionais nesse ramo. O <em>STABLE</em> refere-se à interface binária de aplicativos (ABI) não sendo alterada, portanto, o software compilado para versões anteriores ainda é executado. Por exemplo, o software compilado para rodar no FreeBSD 10.1 ainda rodará no FreeBSD 10-STABLE compilado posteriormente.</p><p class=tableblock>Os ramos STABLE ocasionalmente possuem bugs ou incompatibilidades que podem afetar os usuários, embora sejam normalmente corrigidos rapidamente.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code><em>X</em>-CURRENT</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>base/head/</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>A mais recente versão de desenvolvimento do FreeBSD. A ramificação CURRENT pode ter grandes erros ou incompatibilidades e é recomendada apenas para usuários avançados.</p></td></tr></tbody></table><div class=paragraph><p>Determine qual versão do FreeBSD está sendo usada com <a href="https://man.freebsd.org/cgi/man.cgi?query=uname&amp;sektion=1&amp;format=html">uname(1)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># uname -r</span>
10.3-RELEASE</code></pre></div></div><div class=paragraph><p>Baseado em <a href=#updating-src-obtaining-src-repopath>Versões do FreeBSD e Caminhos do Repositório</a>, a fonte usada para atualizar <code>10.3-RELEASE</code> tem como caminho de repositório <code>base/releng/10.3</code>. Este caminho é usado ao verificar a fonte:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mv /usr/src /usr/src.bak </span><i class=conum data-value=1></i><b>(1)</b>
<span class=c># svnlite checkout https://svn.freebsd.org/base/releng/10.3 /usr/src </span><i class=conum data-value=2></i><b>(2)</b></code></pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>Mova o diretório antigo para fora do caminho. Se não houver modificações locais nesse diretório, ele poderá ser excluído.</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td>O caminho da <a href=#updating-src-obtaining-src-repopath>Versões do FreeBSD e Caminhos do Repositório</a> é adicionado a URL repositório . O terceiro parâmetro é o diretório de destino do código-fonte no sistema local.</td></tr></tbody></table></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=updating-src-building>23.5.4. Compilando a partir do código-fonte<a class=anchor href=#updating-src-building></a></h4><div class=paragraph><p>O <em>world</em>, ou todo o sistema operacional, exceto o kernel, é compilado. Isso é feito primeiro para fornecer ferramentas atualizadas para construir o kernel. Então o próprio kernel é construído:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/src</span>
<span class=c># make buildworld</span>
<span class=c># make buildkernel</span></code></pre></div></div><div class=paragraph><p>O código compilado é escrito em <span class=filename>/usr/obj</span>.</p></div><div class=paragraph><p>Estes são os passos básicos. Opções adicionais para controlar a compilação são descritas abaixo.</p></div><div class=sect4><h5 id=updating-src-building-clean-build>23.5.4.1. Executando uma compilação limpa<a class=anchor href=#updating-src-building-clean-build></a></h5><div class=paragraph><p>Algumas versões do sistema de compilação do FreeBSD deixam o código previamente compilado no diretório de objetos temporários, <span class=filename>/usr/obj</span>. Isso pode acelerar as compilações posteriores, evitando recompilar o código que não foi alterado. Para forçar uma reconstrução limpa de tudo, use <code>cleanworld</code> antes de iniciar uma construção:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># make cleanworld</span></code></pre></div></div></div><div class=sect4><h5 id=updating-src-building-jobs>23.5.4.2. Definindo o Número de Jobs<a class=anchor href=#updating-src-building-jobs></a></h5><div class=paragraph><p>Aumentar o número de jobs de compilação em processadores com vários núcleos pode melhorar a velocidade de construção. Determine o número de núcleos com <code>sysctl hw.ncpu</code>. Os processadores variam, assim como os sistemas de compilação usados com diferentes versões do FreeBSD, portanto, o teste é o único método seguro para determinar como um número diferente de tarefas afeta a velocidade de compilação. Como ponto de partida, considere valores entre metade e o dobro do número de núcleos. O número de jobs é especificado com a opção <code>-j</code>.</p></div><div id=updating-src-building-jobs-example class=exampleblock><div class=title>Exemplo 43. Aumentando o número de jobs de compilação</div><div class=content><div class=paragraph><p>Compilando o mundo e o kernel com quatro jobs:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># make -j4 buildworld buildkernel</span></code></pre></div></div></div></div></div><div class=sect4><h5 id=updating-src-building-only-kernel>23.5.4.3. Compilando Apenas o Kernel<a class=anchor href=#updating-src-building-only-kernel></a></h5><div class=paragraph><p>Um <code>buildworld</code> deve ser completado se o código-fonte for alterado. Depois disso, um <code>buildkernel</code> para compilar um kernel pode ser executado a qualquer momento. Para compilar apenas o kernel:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/src</span>
<span class=c># make buildkernel</span></code></pre></div></div></div><div class=sect4><h5 id=updating-src-building-custom-kernel>23.5.4.4. Compilando um Kernel Customizado<a class=anchor href=#updating-src-building-custom-kernel></a></h5><div class=paragraph><p>O kernel padrão do FreeBSD é baseado em um <em>arquivo de configuração do kernel</em> chamado <span class=filename>GENERIC</span>. O kernel <span class=filename>GENERIC</span> inclui os drivers e opções de dispositivos mais comumente necessários. Às vezes, é útil ou necessário criar um kernel personalizado, adicionando ou removendo drivers de dispositivo ou opções para atender a uma necessidade específica.</p></div><div class=paragraph><p>Por exemplo, alguém que desenvolve um pequeno computador embarcado com RAM severamente limitada pode remover drivers de dispositivo desnecessários ou opções para tornar o kernel um pouco menor.</p></div><div class=paragraph><p>Os arquivos de configuração do Kernel estão localizados em <span class=filename>/usr/src/sys/arch/conf/</span>, onde <em>arch</em> é a saída do <code>uname - m</code>. Na maioria dos computadores, a saida será <code>amd64</code>, resultando no diretório de arquivos de configuração <span class=filename>/usr/src/sys/amd64/conf/</span>.</p></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>O <span class=filename>/usr/src</span> pode ser deletado ou recriado, então é preferível manter os arquivos de configuração do kernel em um diretório separado, como por exemplo em <span class=filename>/root</span>. Vincule o arquivo de configuração do kernel ao diretório <span class=filename>conf</span>. Se esse diretório for excluído ou sobrescrito, a configuração do kernel pode ser vinculada novamente ao novo.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Um arquivo de configuração personalizado pode ser criado copiando o arquivo de configuração <span class=filename>GENERIC</span>. Neste exemplo, o novo kernel personalizado é para um servidor de armazenamento, portanto, é denominado <span class=filename>STORAGESERVER</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cp /usr/src/sys/amd64/conf/GENERIC /root/STORAGESERVER</span>
<span class=c># cd /usr/src/sys/amd64/conf</span>
<span class=c># ln -s /root/STORAGESERVER .</span></code></pre></div></div><div class=paragraph><p>O <span class=filename>/root/STORAGESERVER</span> é então editado, adicionando ou removendo dispositivos ou opções como mostrado em <a href="https://man.freebsd.org/cgi/man.cgi?query=config&amp;sektion=5&amp;format=html">config(5)</a>.</p></div><div class=paragraph><p>O kernel personalizado é compilado pela configuração <code>KERNCONF</code> no arquivo de configuração do kernel na linha de comando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># make buildkernel KERNCONF=STORAGESERVER</span></code></pre></div></div></div></div><div class=sect3><h4 id=updating-src-installing>23.5.5. Instalando o código compilado<a class=anchor href=#updating-src-installing></a></h4><div class=paragraph><p>Depois que as etapas <code>buildworld</code> e <code>buildkernel</code> forem concluídas, o novo kernel e o restante do sistema base serão instalados:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/src</span>
<span class=c># make installkernel</span>
<span class=c># shutdown -r now</span>
<span class=c># cd /usr/src</span>
<span class=c># make installworld</span>
<span class=c># shutdown -r now</span></code></pre></div></div><div class=paragraph><p>Se um kernel customizado foi compilado, <code>KERNCONF</code> também deve ser configurado para usar o novo kernel customizado:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/src</span>
<span class=c># make installkernel KERNCONF=STORAGESERVER</span>
<span class=c># shutdown -r now</span>
<span class=c># cd /usr/src</span>
<span class=c># make installworld</span>
<span class=c># shutdown -r now</span></code></pre></div></div></div><div class=sect3><h4 id=updating-src-completing>23.5.6. Concluindo a atualização<a class=anchor href=#updating-src-completing></a></h4><div class=paragraph><p>Algumas tarefas finais completam a atualização. Quaisquer arquivos de configuração que tenham sido modificados serão mesclado com as novas versões, as bibliotecas desatualizadas são localizadas e removidas e, em seguida, o sistema é reiniciado.</p></div><div class=sect4><h5 id=updating-src-completing-merge-mergemaster>23.5.6.1. Mesclando arquivos de configuração com o <a href="https://man.freebsd.org/cgi/man.cgi?query=mergemaster&amp;sektion=8&amp;format=html">mergemaster(8)</a><a class=anchor href=#updating-src-completing-merge-mergemaster></a></h5><div class=paragraph><p>O <a href="https://man.freebsd.org/cgi/man.cgi?query=mergemaster&amp;sektion=8&amp;format=html">mergemaster(8)</a> fornece uma maneira fácil de mesclar as alterações feitas nos arquivos de configuração do sistema com novas versões desses arquivos.</p></div><div class=paragraph><p>Com a opção <code>-Ui</code>, o <a href="https://man.freebsd.org/cgi/man.cgi?query=mergemaster&amp;sektion=8&amp;format=html">mergemaster(8)</a> atualizará automaticamente os arquivos que não foram modificados pelo usuário e instalará os novos arquivos que ainda não estiverem presentes:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mergemaster -Ui</span></code></pre></div></div><div class=paragraph><p>Se um arquivo precisar ser mesclado manualmente, uma exibição interativa permitirá que o usuário escolha quais partes dos arquivos serão mantidas. Veja <a href="https://man.freebsd.org/cgi/man.cgi?query=mergemaster&amp;sektion=8&amp;format=html">mergemaster(8)</a> para maiores informações.</p></div></div><div class=sect4><h5 id=updating-src-completing-check-old>23.5.6.2. Verificando Arquivos e Bibliotecas Desatualizados<a class=anchor href=#updating-src-completing-check-old></a></h5><div class=paragraph><p>Alguns arquivos ou diretórios obsoletos podem permanecer após uma atualização. Esses arquivos podem ser localizados:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># make check-old</span></code></pre></div></div><div class=paragraph><p>e excluído:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># make delete-old</span></code></pre></div></div><div class=paragraph><p>Algumas bibliotecas obsoletas também podem permanecer. Estes podem ser detectados com:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># make check-old-libs</span></code></pre></div></div><div class=paragraph><p>e deletado com</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># make delete-old-libs</span></code></pre></div></div><div class=paragraph><p>Os programas que ainda estavam usando estas bibliotecas antigas deixarão de funcionar quando a biblioteca for excluída. Estes programas devem ser recompilados ou substituídos após a exclusão das bibliotecas antigas.</p></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Quando todos os arquivos ou diretórios antigos forem considerados seguros para serem excluídos, a ação de pressionar <kbd>y</kbd> e <kbd>Enter</kbd> para excluir cada arquivo poderá ser evitada configurando a variável <code>BATCH_DELETE_OLD_FILES</code> no comando. Por exemplo:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># make BATCH_DELETE_OLD_FILES=yes delete-old-libs</span></code></pre></div></div></td></tr></tbody></table></div></div><div class=sect4><h5 id=updating-src-completing-restart>23.5.6.3. Reiniciando após a atualização<a class=anchor href=#updating-src-completing-restart></a></h5><div class=paragraph><p>A última etapa após a atualização é reiniciar o computador para que todas as alterações entrem em vigor:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># shutdown -r now</span></code></pre></div></div></div></div></div><div class=sect2><h3 id=small-lan>23.6. Atualização de várias máquinas<a class=anchor href=#small-lan></a></h3><div class=paragraph><p>Quando várias máquinas precisam rastrear a mesma árvore de código-fonte, é um desperdício de espaço em disco, largura de banda de rede e ciclos de CPU se cada sistema tiver que baixar o código-fonte e recompilar tudo. A solução é ter uma máquina fazendo a maior parte do trabalho, enquanto o resto das máquinas montam esse trabalho via NFS. Esta seção descreve um método para fazer isso. Para maiores informações sobre o uso de NFS, consulte <a href=./#network-nfs>Network File System (NFS)</a>.</p></div><div class=paragraph><p>Primeiro, identifique um conjunto de máquinas que executará o mesmo conjunto de binários, conhecido como <em>conjunto de compilação</em>. Cada máquina pode ter um kernel customizado, mas executará os mesmos binários do userland. A partir desse conjunto, escolha uma máquina para ser a <em>máquina de compilação</em> em que o sistema base e o kernel serão compilados. Idealmente, esta deverá ser uma máquina rápida que tenha CPU suficiente disponível para executar o <code>make buildworld</code> e o <code>make buildkernel</code>.</p></div><div class=paragraph><p>Selecione uma máquina para ser a <em>máquina de teste</em>, que testará as atualizações de software antes de serem colocadas em produção. Esta <em>deve</em> ser uma máquina que você possa se dar ao luxo de ficar inativa por um longo período de tempo. Pode ser a máquina de compilação, mas não precisa ser.</p></div><div class=paragraph><p>Todas as máquinas neste conjunto de compilação precisam montar o <span class=filename>/usr/obj</span> e o <span class=filename>/usr/src</span> da máquina de compilação através do NFS. Para vários conjuntos de compilação, o <span class=filename>/usr/src</span> deve ser um sistema de arquivos local na máquina de compilação e um sistema montado por NFS nas demais.</p></div><div class=paragraph><p>Certifique-se de que o <span class=filename>/etc/make.conf</span> e o <span class=filename>/etc/src.conf</span> em todas as máquinas no conjunto de compilação concordem com a máquina de compilação. Isso significa que a máquina de compilação deve compilar todas as partes do sistema base que qualquer máquina no conjunto de compilação irá instalar. Além disso, cada máquina de compilação deve ter seu nome de kernel definido com <code>KERNCONF</code> em <span class=filename>/etc/make.conf</span>, e a máquina de compilação deve listá-los todos em seu <code>KERNCONF</code>, listando seu próprio kernel primeiro. A máquina de compilação deve ter os arquivos de configuração do kernel para cada máquina em seu <span class=filename>/usr/src/sys/arch/conf</span>.</p></div><div class=paragraph><p>Na máquina de compilação, compile o kernel e o mundo conforme descrito em <a href=#makeworld>Atualizando o FreeBSD a partir do código fonte</a>, mas não instale nada na máquina de compilação. Em vez disso, instale o kernel compilado na máquina de teste. Na máquina de teste, monte <span class=filename>/usr/src</span> e o <span class=filename>/usr/obj</span> via NFS. Em seguida, execute <code>shutdown now</code> para ir para o modo de usuário único para instalar o novo kernel e o restante do sistema base e execute o <code>mergemaster</code> como de costume. Quando terminar, reinicialize para retornar às operações multiusuário normais.</p></div><div class=paragraph><p>Depois de verificar se tudo na máquina de teste está funcionando corretamente, use o mesmo procedimento para instalar o novo software em cada uma das outras máquinas no conjunto de compilação.</p></div><div class=paragraph><p>A mesma metodologia pode ser usada para a árvore de ports. O primeiro passo é compartilhar o <span class=filename>/usr/ports</span> via NFS para todas as máquinas no conjunto de compilação. Para configurar o <span class=filename>/etc/make.conf</span> para compartilhar os distfiles, configure o <code>DISTDIR</code> para um diretório compartilhado que possa ser escrito por qualquer usuário <code>root</code> mapeado pela montagem NFS. Cada máquina deve definir o <code>WRKDIRPREFIX</code> para um diretório de compilação local, se os ports precisarem ser compilados localmente. Como alternativa, se o sistema de compilação tiver que compilar e distribuir pacotes para as máquinas no conjunto de compilação, configure o <code>PACKAGES</code> no sistema de compilação para um diretório semelhante ao <code>DISTDIR</code>.</p></div></div></div></div><div class=sect1><h2 id=dtrace>Capítulo 24. DTrace<a class=anchor href=#dtrace></a></h2><div class=sectionbody><div class=sect2><h3 id=dtrace-synopsis>24.1. Sinopse<a class=anchor href=#dtrace-synopsis></a></h3><div class=paragraph><p>O DTrace, também conhecido como Dynamic Tracing, foi desenvolvido pela Sun™ como uma ferramenta para localizar gargalos de desempenho em sistemas de produção e pré-produção. Além de diagnosticar problemas de desempenho, o DTrace pode ser usado para ajudar a investigar e depurar comportamentos inesperados no kernel do FreeBSD e em programas da userland.</p></div><div class=paragraph><p>O DTrace é uma ferramenta de criação de perfil notável, com uma impressionante variedade de recursos para diagnosticar problemas do sistema. Ele também pode ser usado para executar scripts pré-escritos para aproveitar seus recursos. Os usuários podem criar seus próprios utilitários usando a DTrace D Language, permitindo que eles personalizem seus perfis com base em necessidades específicas.</p></div><div class=paragraph><p>A implementação do FreeBSD fornece suporte completo para o DTrace do kernel e suporte experimental para o DTrace da userland. O Userland DTrace permite que os usuários executem o rastreio de limite de função para programas de área de trabalho usando o provedor <code>pid</code> e insiram investigações estáticas em programas da userland para rastreamento posterior. Alguns ports, como <a class=package href=https://cgit.freebsd.org/ports/tree/databases/postgresql12-server/>databases/postgresql12-server</a> e <a class=package href=https://cgit.freebsd.org/ports/tree/lang/php74/>lang/php74</a>, possuem uma opção do DTrace para ativar testes estáticos.</p></div><div class=paragraph><p>O guia oficial do DTrace é mantido pelo projeto Illumos no <a href=http://dtrace.org/guide>Guia do DTrace</a>.</p></div><div class=paragraph><p>Depois de ler este capítulo, você saberá:</p></div><div class=ulist><ul><li><p>O que é o DTrace e quais recursos ele fornece.</p></li><li><p>Diferenças entre a implementação do DTrace Solaris™ e a fornecida pelo FreeBSD.</p></li><li><p>Como ativar e usar o DTrace no FreeBSD.</p></li></ul></div><div class=paragraph><p>Antes de ler este capítulo, você deve:</p></div><div class=ulist><ul><li><p>Entender os fundamentos do UNIX™ e do FreeBSD (<a href=./#basics>Fundamentos do FreeBSD</a>).</p></li><li><p>Ter alguma familiaridade com segurança e como ela está presente no FreeBSD (<a href=./#security>Segurança</a>).</p></li></ul></div></div><div class=sect2><h3 id=dtrace-implementation>24.2. Diferenças de Implementação<a class=anchor href=#dtrace-implementation></a></h3><div class=paragraph><p>Embora o DTrace no FreeBSD seja semelhante ao encontrado no Solaris™, existem diferenças. A principal diferença é que no FreeBSD, o DTrace é implementado como um conjunto de módulos do kernel e o DTrace não pode ser usado até que os módulos sejam carregados. Para carregar todos os módulos necessários:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload dtraceall</span></code></pre></div></div><div class=paragraph><p>Começando com o FreeBSD 10.0-RELEASE, os módulos são carregados automaticamente quando o <code>dtrace</code> é executado.</p></div><div class=paragraph><p>O FreeBSD usa a opção do kernel <code>DDB_CTF</code> para ativar o suporte para carregar dados CTF dos módulos do kernel e do próprio kernel. O CTF é o Solaris™ Compact C Type Format, que encapsula uma forma reduzida de informações de depuração semelhantes ao DWARF e aos veneráveis stabs. Os dados do CTF são adicionados aos binários pelas ferramentas de compilação <code>ctfconvert</code> e <code>ctfmerge</code>. O utilitário <code>ctfconvert</code> analisa as seções de depuração do DWARFELF criadas pelo compilador e o <code>ctfmerge</code> mescla as seções do ELF do CTF dos objetos em executáveis ou bibliotecas compartilhadas.</p></div><div class=paragraph><p>Alguns provedores diferentes existem para o FreeBSD não para o Solaris™. O mais notável é o provedor <code>dtmalloc</code>, que permite rastrear <code>malloc()</code> por tipo no kernel do FreeBSD. Alguns dos provedores encontrados no Solaris™, como <code>cpc</code> e <code>mib</code>, não estão presentes no FreeBSD. Estes podem aparecer em futuras versões do FreeBSD. Além disso, alguns dos provedores disponíveis em ambos os sistemas operacionais não são compatíveis, no sentido de que suas sondas têm tipos de argumentos diferentes. Assim, os scripts D escritos em Solaris™ podem ou não funcionar sem modificações no FreeBSD, e vice-versa.</p></div><div class=paragraph><p>Devido as diferenças de segurança, somente o <code>root</code> pode usar o DTrace no FreeBSD. O Solaris™ possui algumas verificações de segurança de baixo nível que ainda não existem no FreeBSD. Como tal, o <span class=filename>/dev/dtrace/dtrace</span> é estritamente limitado ao <code>root</code>.</p></div><div class=paragraph><p>O DTrace se enquadra na licença Common Development and Distribution License (CDDL). Para ver esta licença no FreeBSD, consulte <span class=filename>/usr/src/cddl/contrib/opensolaris/OPENSOLARIS.LICENSE</span> ou acesse on-line em <a href=http://opensource.org/licenses/CDDL-1.0>http://opensource.org/licenses/CDDL-1.0</a>. Enquanto um kernel do FreeBSD com suporte a DTrace é licenciado sob BSD, o CDDL é usado quando os módulos são distribuídos em formato binário ou quando os binários são carregados.</p></div></div><div class=sect2><h3 id=dtrace-enable>24.3. Ativando o Suporte do DTrace<a class=anchor href=#dtrace-enable></a></h3><div class=paragraph><p>No FreeBSD 9.2 e 10.0, o suporte do DTrace está embutido no kernel <span class=filename>GENERIC</span>. Usuários de versões anteriores do FreeBSD ou que preferem compilar estaticamente o suporte do DTrace devem adicionar as seguintes linhas a um arquivo de configuração de kernel personalizado e recompilar o kernel usando as instruções em <a href=./#kernelconfig>Configurando o kernel do FreeBSD</a>:</p></div><div class="literalblock programlisting"><div class=content><pre>options         KDTRACE_HOOKS
options         DDB_CTF
makeoptions	DEBUG=-g
makeoptions	WITH_CTF=1</pre></div></div><div class=paragraph><p>Os usuários da arquitetura AMD64 também devem adicionar esta linha:</p></div><div class="literalblock programlisting"><div class=content><pre>options         KDTRACE_FRAME</pre></div></div><div class=paragraph><p>Esta opção fornece suporte para FBT. Embora o DTrace funcione sem essa opção, haverá suporte limitado para o rastreamento de limite de função.</p></div><div class=paragraph><p>Uma vez que o sistema FreeBSD foi reinicializado no novo kernel, ou os módulos de kernel do DTrace foram carregados usando <code>kldload dtraceall</code>, o sistema precisará de suporte para o shell Korn, pois o DTrace Toolkit possui vários utilitários escritos em <code>ksh</code>. Certifique-se de que o pacote ou port <a class=package href=https://cgit.freebsd.org/ports/tree/shells/ksh93/>shells/ksh93</a> esteja instalado. Também é possível rodar estas ferramentas com <a class=package href=https://cgit.freebsd.org/ports/tree/shells/pdksh/>shells/pdksh</a> ou <a class=package href=https://cgit.freebsd.org/ports/tree/shells/mksh/>shells/mksh</a>.</p></div><div class=paragraph><p>Por fim, instale o DTrace Toolkit atual, uma coleção de scripts prontos para coletar informações do sistema. Existem scripts para verificar arquivos abertos, memória, uso de CPU e muito mais. O FreeBSD 10 instala alguns desses scripts em <span class=filename>/usr/shared/dtrace</span>. Em outras versões do FreeBSD, ou para instalar o DTrace Toolkit completo, use o pacote ou port <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/dtrace-toolkit/>sysutils/dtrace-toolkit</a>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Os scripts encontrados em <span class=filename>/usr/shared/dtrace</span> foram especificamente portados para o FreeBSD. Nem todos os scripts encontrados no DTrace Toolkit funcionarão no FreeBSD e alguns scripts podem exigir algum esforço para que funcionem no FreeBSD.</p></div></td></tr></tbody></table></div><div class=paragraph><p>O DTrace Toolkit inclui muitos scripts no idioma especial do DTrace. Esta linguagem é chamada de linguagem D e é muito semelhante ao C++. Uma discussão aprofundada da linguagem está além do escopo deste documento. Ele é abordado extensivamente no <a href=http://www.dtrace.org/guide>Illumos Dynamic Tracing Guide</a>.</p></div></div><div class=sect2><h3 id=dtrace-using>24.4. Usando o DTrace<a class=anchor href=#dtrace-using></a></h3><div class=paragraph><p>Os scripts do DTrace consistem em uma lista de um ou mais testes <em>probes</em>, ou pontos de instrumentação, em que cada teste é associado a uma ação. Sempre que a condição de uma sonda é atendida, a ação associada é executada. Por exemplo, uma ação pode ocorrer quando um arquivo é aberto, um processo é iniciado ou uma linha de código é executada. A ação pode ser registrar algumas informações ou modificar variáveis de contexto. A leitura e a escrita de variáveis de contexto permitem que os probes compartilhem informações e analisem cooperativa-mente a correlação de diferentes eventos.</p></div><div class=paragraph><p>Para ver todos os probes, o administrador pode executar o seguinte comando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dtrace -l | more</span></code></pre></div></div><div class=paragraph><p>Cada probe possui um <code>ID</code>, um <code>PROVIDER</code> (dtrace ou fbt), um <code>MODULE</code> e um <code>FUNCTION NAME</code>. Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=dtrace&amp;sektion=1&amp;format=html">dtrace(1)</a> para obter maiores informações sobre este comando.</p></div><div class=paragraph><p>Os exemplos nesta seção fornecem uma visão geral de como usar dois dos scripts totalmente suportados dos scripts do DTrace Toolkit: o <span class=filename>hotkernel</span> e <span class=filename>procsystime</span>.</p></div><div class=paragraph><p>O script <span class=filename>hotkernel</span> é projetado para identificar qual função está usando a maior parte do tempo do kernel. Ele produzirá uma saída semelhante à seguinte:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/local/share/dtrace-toolkit</span>
<span class=c># ./hotkernel</span>
Sampling... Hit Ctrl-C to end.</code></pre></div></div><div class=paragraph><p>Conforme instruído, use a combinação de teclas <span class=keyseq><kbd>Ctrl</kbd>+<kbd>C</kbd></span> para interromper o processo. Após o término, o script exibirá uma lista de funções do kernel e informações de tempo, classificando a saída em ordem crescente de tempo:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>kernel<span class=sb>`</span>_thread_lock_flags                                   2   0.0%
0xc1097063                                                  2   0.0%
kernel<span class=sb>`</span>sched_userret                                        2   0.0%
kernel<span class=sb>`</span>kern_select                                          2   0.0%
kernel<span class=sb>`</span>generic_copyin                                       3   0.0%
kernel<span class=sb>`</span>_mtx_assert                                          3   0.0%
kernel<span class=sb>`</span>vm_fault                                             3   0.0%
kernel<span class=sb>`</span>sopoll_generic                                       3   0.0%
kernel<span class=sb>`</span>fixup_filename                                       4   0.0%
kernel<span class=sb>`</span>_isitmyx                                             4   0.0%
kernel<span class=sb>`</span>find_instance                                        4   0.0%
kernel<span class=sb>`</span>_mtx_unlock_flags                                    5   0.0%
kernel<span class=sb>`</span>syscall                                              5   0.0%
kernel<span class=sb>`</span>DELAY                                                5   0.0%
0xc108a253                                                  6   0.0%
kernel<span class=sb>`</span>witness_lock                                         7   0.0%
kernel<span class=sb>`</span>read_aux_data_no_wait                                7   0.0%
kernel<span class=sb>`</span>Xint0x80_syscall                                     7   0.0%
kernel<span class=sb>`</span>witness_checkorder                                   7   0.0%
kernel<span class=sb>`</span>sse2_pagezero                                        8   0.0%
kernel<span class=sb>`</span>strncmp                                              9   0.0%
kernel<span class=sb>`</span>spinlock_exit                                       10   0.0%
kernel<span class=sb>`</span>_mtx_lock_flags                                     11   0.0%
kernel<span class=sb>`</span>witness_unlock                                      15   0.0%
kernel<span class=sb>`</span>sched_idletd                                       137   0.3%
0xc10981a5                                              42139  99.3%</code></pre></div></div><div class=paragraph><p>Este script também funcionará com módulos do kernel. Para usar este recurso, execute o script com <code>-m</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ./hotkernel -m</span>
Sampling... Hit Ctrl-C to end.
^C
MODULE                                                  COUNT   PCNT
0xc107882e                                                  1   0.0%
0xc10e6aa4                                                  1   0.0%
0xc1076983                                                  1   0.0%
0xc109708a                                                  1   0.0%
0xc1075a5d                                                  1   0.0%
0xc1077325                                                  1   0.0%
0xc108a245                                                  1   0.0%
0xc107730d                                                  1   0.0%
0xc1097063                                                  2   0.0%
0xc108a253                                                 73   0.0%
kernel                                                    874   0.4%
0xc10981a5                                             213781  99.6%</code></pre></div></div><div class=paragraph><p>O script <span class=filename>procsystime</span> captura e imprime o uso do tempo de chamada do sistema para um determinado processo ID (PID) ou nome do processo. No exemplo a seguir, uma nova instância de <span class=filename>/bin/csh</span> foi gerada. Então, <span class=filename>procsystime</span> foi executado e permaneceu aguardando enquanto alguns comandos foram digitados na outra instância do <code>csh</code>. Estes são os resultados deste teste:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ./procsystime -n csh</span>
Tracing... Hit Ctrl-C to end...
^C

Elapsed Times <span class=k>for </span>processes csh,

         SYSCALL          TIME <span class=o>(</span>ns<span class=o>)</span>
          getpid               6131
       sigreturn               8121
           close              19127
           fcntl              19959
             dup              26955
         setpgid              28070
            <span class=nb>stat              </span>31899
       setitimer              40938
           wait4              62717
       sigaction              67372
     sigprocmask             119091
    gettimeofday             183710
           write             263242
          execve             492547
           ioctl             770073
           vfork            3258923
      sigsuspend            6985124
            <span class=nb>read         </span>3988049784</code></pre></div></div><div class=paragraph><p>Como mostrado, a chamada de sistema <code>read()</code> usou a maior parte do tempo em nanossegundos enquanto a chamada de sistema <code>getpid()</code> usou a menor quantidade de tempo.</p></div></div></div></div><div class=sect1><h2 id=usb-device-mode>Capítulo 25. Modo de dispositivo USB/USB OTG<a class=anchor href=#usb-device-mode></a></h2><div class=sectionbody><div class=sect2><h3 id=usb-device-mode-synopsis>25.1. Sinopse<a class=anchor href=#usb-device-mode-synopsis></a></h3><div class=paragraph><p>Este capítulo aborda o uso do Modo de Dispositivo USB e USB On The Go (USB OTG) no FreeBSD. Isso inclui consoles seriais virtuais, interfaces de rede virtual e drives USB virtuais.</p></div><div class=paragraph><p>Quando rodando em hardware que suporta o modo de dispositivo USB ou USB OTG, como aquele embutido em muitas placas embarcadas, a stack USB do FreeBSD pode ser executada em <em>modo de dispositivo</em>. O modo de dispositivo possibilita que o computador apresente-se como diferentes tipos de classes de dispositivos USB, incluindo portas seriais, adaptadores de rede e armazenamento em massa, ou uma combinação dos mesmos. Um host USB como um laptop ou computador desktop pode acessá-los assim como faria com dispositivos USB físicos. O modo de dispositivo é algumas vezes chamado de "modo USB gadget".</p></div><div class=paragraph><p>Existem duas maneiras básicas pelas quais o hardware pode fornecer a funcionalidade do modo de dispositivo: com uma "porta de cliente" separada, que suporta apenas o modo de dispositivo, e com uma porta USB OTG, que pode fornecer o modo de dispositivo e o modo de host. Para portas USB OTG, a stack USB alterna automaticamente entre o lado do host e o lado do dispositivo, dependendo do que estiver conectado à porta. Conectar um dispositivo USB como um cartão de memória à porta faz com que o FreeBSD mude para o modo de host. Conectar um host USB como um computador faz com que o FreeBSD mude para o modo de dispositivo. As "portas do cliente" de finalidade única sempre funcionam no modo de dispositivo.</p></div><div class=paragraph><p>O que o FreeBSD apresenta para o host USB depende do sysctl <code>hw.usb.template</code>. Alguns modelos fornecem um único dispositivo, como um terminal serial; outros fornecem vários, que podem ser todos usados ao mesmo tempo. Um exemplo é o template 10, que fornece um dispositivo de armazenamento em massa, um console serial e uma interface de rede. Veja o <a href="https://man.freebsd.org/cgi/man.cgi?query=usb_template&amp;sektion=4&amp;format=html">usb_template(4)</a> para obter a lista de valores disponíveis.</p></div><div class=paragraph><p>Observe que, em alguns casos, dependendo do hardware e do sistema operacional do host, para o host notar a alteração da configuração, ele deve ser fisicamente desconectado e reconectado ou forçado a verificar novamente o barramento USB de uma maneira específica do sistema. Quando o FreeBSD é executado no host, o <a href="https://man.freebsd.org/cgi/man.cgi?query=usbconfig&amp;sektion=8&amp;format=html">usbconfig(8)</a><code>reset</code> pode ser usado. Isto também deve ser feito após carregar o <span class=filename>usb_template.ko</span> se o host USB já estiver conectado ao soquete USB OTG .</p></div><div class=paragraph><p>Depois de ler este capítulo, você saberá:</p></div><div class=ulist><ul><li><p>Como configurar a funcionalidade do modo de dispositivo USB no FreeBSD.</p></li><li><p>Como configurar a porta serial virtual no FreeBSD.</p></li><li><p>Como se conectar à porta serial virtual de vários sistemas operacionais.</p></li><li><p>Como configurar o FreeBSD para fornecer uma interface de rede virtual USB.</p></li><li><p>Como configurar o FreeBSD para fornecer um dispositivo virtual de armazenamento USB.</p></li></ul></div></div><div class=sect2><h3 id=usb-device-mode-terminals>25.2. Portas Seriais Virtuais USB<a class=anchor href=#usb-device-mode-terminals></a></h3><div class=sect3><h4 id=_configurando_portas_seriais_do_modo_de_dispositivo_usb>25.2.1. Configurando Portas Seriais do Modo de Dispositivo USB<a class=anchor href=#_configurando_portas_seriais_do_modo_de_dispositivo_usb></a></h4><div class=paragraph><p>O suporte para porta serial virtual é fornecido pelos templates número 3, 8 e 10. Observe que o template 3 funciona com o Microsoft Windows 10 sem a necessidade de drivers especiais e de arquivos INF. Outros sistemas operacionais host funcionam com todos os três modelos. Os módulos do kernel <a href="https://man.freebsd.org/cgi/man.cgi?query=usb_template&amp;sektion=4&amp;format=html">usb_template(4)</a> e <a href="https://man.freebsd.org/cgi/man.cgi?query=umodem&amp;sektion=4&amp;format=html">umodem(4)</a> devem ser carregados.</p></div><div class=paragraph><p>Para ativar as portas seriais do modo de dispositivo USB, adicione essas linhas ao <span class=filename>/etc/ttys</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>ttyU0	&#34;/usr/libexec/getty 3wire&#34;	vt100	onifconsole secure
ttyU1	&#34;/usr/libexec/getty 3wire&#34;	vt100	onifconsole secure</pre></div></div><div class=paragraph><p>Então adicione estas linhas ao arquivo <span class=filename>/etc/devd.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>notify 100 {
	match &#34;system&#34;		&#34;DEVFS&#34;;
	match &#34;subsystem&#34;	&#34;CDEV&#34;;
	match &#34;type&#34;		&#34;CREATE&#34;;
	match &#34;cdev&#34;		&#34;ttyU[0-9]+&#34;;
	action &#34;/sbin/init q&#34;;
};</pre></div></div><div class=paragraph><p>Recarregue a configuração se o <a href="https://man.freebsd.org/cgi/man.cgi?query=devd&amp;sektion=8&amp;format=html">devd(8)</a> já estiver em execução:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service devd restart</span></code></pre></div></div><div class=paragraph><p>Certifique-se de que os módulos necessários estejam carregados e que o template correto esteja configurado na inicialização, adicionando estas linhas ao <span class=filename>/boot/loader.conf</span>, criando-o se ele ainda não existir:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=nv>umodem_load</span><span class=o>=</span><span class=s2>&#34;YES&#34;</span>
hw.usb.template<span class=o>=</span>3</code></pre></div></div><div class=paragraph><p>Para carregar o módulo e definir o modelo sem reiniciar, use:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload umodem</span>
<span class=c># sysctl hw.usb.template=3</span></code></pre></div></div></div><div class=sect3><h4 id=_conectando_se_às_portas_seriais_do_modo_de_dispositivo_usb_a_partir_do_freebsd>25.2.2. Conectando-se às portas seriais do modo de dispositivo USB a partir do FreeBSD<a class=anchor href=#_conectando_se_às_portas_seriais_do_modo_de_dispositivo_usb_a_partir_do_freebsd></a></h4><div class=paragraph><p>Para conectar-se a uma placa configurada para fornecer portas seriais de um dispositivo USB, conecte o host USB, como um laptop, às placas USB OTG ou porta de cliente USB. Use <code>pstat -t</code> no host para listar as linhas de terminal. Perto do final da lista, você deve ver uma porta serial USB, por exemplo, "ttyU0". Para abrir a conexão, use:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cu -l /dev/ttyU0</span></code></pre></div></div><div class=paragraph><p>Depois de pressionar a tecla <kbd>Enter</kbd> algumas vezes, você verá um prompt de login.</p></div></div><div class=sect3><h4 id=_conectando_se_às_portas_seriais_do_modo_de_dispositivo_usb_a_partir_do_mac_os>25.2.3. Conectando-se às Portas Seriais do Modo de Dispositivo USB a partir do Mac OS®<a class=anchor href=#_conectando_se_às_portas_seriais_do_modo_de_dispositivo_usb_a_partir_do_mac_os></a></h4><div class=paragraph><p>Para conectar-se a uma placa configurada para fornecer portas seriais de modo de dispositivo USB, conecte o host USB, como um laptop, às placas USB OTG ou porta de cliente USB. Para abrir a conexão, use:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cu -l /dev/cu.usbmodemFreeBSD1</span></code></pre></div></div></div><div class=sect3><h4 id=_conectando_se_às_portas_seriais_do_modo_de_dispositivo_usb_a_partir_do_linux>25.2.4. Conectando-se às portas seriais do modo de dispositivo USB a partir do Linux<a class=anchor href=#_conectando_se_às_portas_seriais_do_modo_de_dispositivo_usb_a_partir_do_linux></a></h4><div class=paragraph><p>Para conectar-se a uma placa configurada para fornecer portas seriais de modo de dispositivo USB, conecte o host USB, como um laptop, às placas USB OTG ou porta de cliente USB. Para abrir a conexão, use:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># minicom -D /dev/ttyACM0</span></code></pre></div></div></div><div class=sect3><h4 id=_conectando_se_às_portas_seriais_do_modo_de_dispositivo_usb_a_partir_do_microsoft_windows_10>25.2.5. Conectando-se às portas seriais do modo de dispositivo USB a partir do Microsoft Windows 10<a class=anchor href=#_conectando_se_às_portas_seriais_do_modo_de_dispositivo_usb_a_partir_do_microsoft_windows_10></a></h4><div class=paragraph><p>Para conectar-se a uma placa configurada para fornecer portas seriais de modo de dispositivo USB, conecte o host USB, como um laptop, às placas USB OTG ou porta de cliente USB. Para abrir uma conexão, você precisará de um programa de terminal serial, como PuTTY. Para verificar o nome da porta COM usada pelo Windows, execute o Gerenciador de dispositivos, expanda. "Ports (COM & LPT)".Você verá um nome semelhante a "USB Serial Device (COM4)". Execute o programa do terminal serial de sua escolha, por exemplo, PuTTY. Na caixa de diálogo PuTTY defina "Connection type" como "Serial", digite o COMx obtido no Gerenciador de Dispositivos na caixa de diálogo "Serial line" e clique em Abrir.</p></div></div></div><div class=sect2><h3 id=usb-device-mode-network>25.3. Interfaces de rede do modo de dispositivo USB<a class=anchor href=#usb-device-mode-network></a></h3><div class=paragraph><p>O suporte a interfaces de rede virtuais é fornecido pelos templates número 1, 8 e 10. Observe que nenhum deles funciona com o Microsoft Windows. Outros sistemas operacionais host funcionam com todos os três modelos. Os módulos de kernel <a href="https://man.freebsd.org/cgi/man.cgi?query=usb_template&amp;sektion=4&amp;format=html">usb_template(4)</a> e <a href="https://man.freebsd.org/cgi/man.cgi?query=if_cdce&amp;sektion=4&amp;format=html">if_cdce(4)</a> devem ser carregados.</p></div><div class=paragraph><p>Certifique-se de que os módulos necessários estejam carregados e que o template correto esteja configurado na inicialização, adicionando estas linhas ao <span class=filename>/boot/loader.conf</span>, criando-o se ele ainda não existir:</p></div><div class="literalblock programlisting"><div class=content><pre>if_cdce_load=&#34;YES&#34;
hw.usb.template=1</pre></div></div><div class=paragraph><p>Para carregar o módulo e definir o modelo sem reiniciar, use:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload if_cdce</span>
<span class=c># sysctl hw.usb.template=1</span></code></pre></div></div></div><div class=sect2><h3 id=usb-device-mode-storage>25.4. Dispositivo de armazenamento virtual USB<a class=anchor href=#usb-device-mode-storage></a></h3><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>O driver <a href="https://man.freebsd.org/cgi/man.cgi?query=cfumass&amp;sektion=4&amp;format=html">cfumass(4)</a> é um driver de modo de dispositivo USB disponibilizado pela primeira vez no FreeBSD 12.0.</p></div></td></tr></tbody></table></div><div class=paragraph><p>O target de armazenamento em massa é fornecido pelos templates 0 e 10. Os módulos de kernel <a href="https://man.freebsd.org/cgi/man.cgi?query=usb_template&amp;sektion=4&amp;format=html">usb_template(4)</a> e <a href="https://man.freebsd.org/cgi/man.cgi?query=cfumass&amp;sektion=4&amp;format=html">cfumass(4)</a> devem ser carregados. O <a href="https://man.freebsd.org/cgi/man.cgi?query=cfumass&amp;sektion=4&amp;format=html">cfumass(4)</a> faz interface com o subsistema CTL, o mesmo usado para os targets iSCSI ou Fibre Channel. No lado do host, os inicializadores do armazenamento em massa USB só podem acessar um único LUN, o LUN 0.</p></div><div class=sect3><h4 id=_configurando_o_target_de_armazenamento_em_massa_usb_usando_o_script_de_inicialização_cfumass>25.4.1. Configurando o target de armazenamento em massa USB usando o script de inicialização cfumass<a class=anchor href=#_configurando_o_target_de_armazenamento_em_massa_usb_usando_o_script_de_inicialização_cfumass></a></h4><div class=paragraph><p>A maneira mais simples de configurar um target de armazenamento USB somente de leitura é usar o script rc <span class=filename>cfumass</span>. Para configurá-lo dessa maneira, copie os arquivos a serem apresentados para a máquina host USB no diretório <code>/var/cfumass</code> e inclua esta linha no <span class=filename>/etc/rc.conf</span> :</p></div><div class="literalblock programlisting"><div class=content><pre>cfumass_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Para fazer valer a configuração sem reiniciar, execute este comando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service cfumass start</span></code></pre></div></div><div class=paragraph><p>Diferentemente da funcionalidade serial e de rede, o modelo não deve ser definido como 0 ou 10 no <span class=filename>/boot/loader.conf</span>. Isso ocorre porque o LUN deve ser configurado antes de definir o template. O script de inicialização cfumass define o número do modelo correto automaticamente quando iniciado.</p></div></div><div class=sect3><h4 id=_configurando_o_armazenamento_em_massa_usb_usando_outros_meios>25.4.2. Configurando o armazenamento em massa USB usando outros meios<a class=anchor href=#_configurando_o_armazenamento_em_massa_usb_usando_outros_meios></a></h4><div class=paragraph><p>O restante deste capítulo fornece uma descrição detalhada da configuração do target sem usar o arquivo rc cfumass. Isso é necessário se, por exemplo, alguém quiser fornecer um LUN gravável.</p></div><div class=paragraph><p>O armazenamento em massaUSB não exige que o daemon <a href="https://man.freebsd.org/cgi/man.cgi?query=ctld&amp;sektion=8&amp;format=html">ctld(8)</a> esteja em execução, embora ele possa ser usado se desejado. Isso é diferente do iSCSI. Portanto, existem duas maneiras de configurar o target: o <a href="https://man.freebsd.org/cgi/man.cgi?query=ctladm&amp;sektion=8&amp;format=html">ctladm(8)</a> ou o <a href="https://man.freebsd.org/cgi/man.cgi?query=ctld&amp;sektion=8&amp;format=html">ctld(8)</a>. Ambos exigem que o módulo do kernel <span class=filename>cfumass.ko</span> seja carregado. O módulo pode ser carregado manualmente:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload cfumass</span></code></pre></div></div><div class=paragraph><p>Se o <span class=filename>cfumass.ko</span> não foi compilado estaticamente no kernel, o <span class=filename>/boot/loader.conf</span> pode ser configurado para carregar o módulo na inicialização:</p></div><div class="literalblock programlisting"><div class=content><pre>cfumass_load=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Um LUN pode ser criado sem o daemon <a href="https://man.freebsd.org/cgi/man.cgi?query=ctld&amp;sektion=8&amp;format=html">ctld(8)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ctladm create -b block -o file=/data/target0</span></code></pre></div></div><div class=paragraph><p>Isto apresenta o conteúdo do arquivo de imagem <span class=filename>/data/target0</span> como um LUN para o host USB. O arquivo deve existir antes de executar o comando. Para configurar o LUN na inicialização do sistema, adicione o comando ao <span class=filename>/etc/rc.local</span>.</p></div><div class=paragraph><p>O <a href="https://man.freebsd.org/cgi/man.cgi?query=ctld&amp;sektion=8&amp;format=html">ctld(8)</a> também pode ser usado para gerenciar LUNs. Crie <span class=filename>/etc/ctl.conf</span>, adicione uma linha ao <span class=filename>/etc/rc.conf</span> para certificar-se <a href="https://man.freebsd.org/cgi/man.cgi?query=ctld&amp;sektion=8&amp;format=html">ctld(8)</a> é iniciado automaticamente na inicialização e, em seguida, inicie o daemon.</p></div><div class=paragraph><p>Este é um exemplo de um arquivo de configuração <span class=filename>/etc/ctl.conf</span> simple. Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=ctl.conf&amp;sektion=5&amp;format=html">ctl.conf(5)</a> para obter uma descrição mais completa das opções.</p></div><div class="literalblock programlisting"><div class=content><pre>target naa.50015178f369f092 {
	lun 0 {
		path /data/target0
		size 4G
	}
}</pre></div></div><div class=paragraph><p>O exemplo cria um único target com um único LUN. O <code>naa.50015178f369f092</code> é um identificador de dispositivo composto por 32 dígitos hexadecimais aleatórios. A linha <code>path</code> define o caminho completo para o arquivo ou zvol que suporta o LUN. Esse arquivo deve existir antes do <a href="https://man.freebsd.org/cgi/man.cgi?query=ctld&amp;sektion=8&amp;format=html">ctld(8)</a> ser iniciado. A segunda linha é opcional e especifica o tamanho do LUN.</p></div><div class=paragraph><p>Para ter certeza que o daemon <a href="https://man.freebsd.org/cgi/man.cgi?query=ctld&amp;sektion=8&amp;format=html">ctld(8)</a> foi iniciado na inicialização, adicione esta linha ao <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>ctld_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Para iniciar o <a href="https://man.freebsd.org/cgi/man.cgi?query=ctld&amp;sektion=8&amp;format=html">ctld(8)</a> agora, execute este comando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service ctld start</span></code></pre></div></div><div class=paragraph><p>Quando o daemon <a href="https://man.freebsd.org/cgi/man.cgi?query=ctld&amp;sektion=8&amp;format=html">ctld(8)</a> é iniciado, ele lê o <span class=filename>/etc/ctl.conf</span>. Se esse arquivo for editado depois que o daemon iniciar, recarregue as alterações para que elas entrem em vigor imediatamente:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service ctld reload</span></code></pre></div></div></div></div></div></div><h1 id=network-communication class=sect0>Parte IV: Comunicação de rede<a class=anchor href=#network-communication></a></h1><div class="openblock partintro"><div class=content><div class=paragraph><p>O FreeBSD é um dos sistemas operacionais mais amplamente implantados para servidores de rede de alto desempenho. Os capítulos desta parte cobrem:</p></div><div class=ulist><ul><li><p>Comunicação Serial</p></li><li><p>PPP e PPP sobre Ethernet</p></li><li><p>Correio Eletrônico</p></li><li><p>Executando Servidores de Rede</p></li><li><p>Firewalls</p></li><li><p>Outros tópicos avançados de rede</p></li></ul></div><div class=paragraph><p>Esses capítulos são projetados para serem lidos quando a informação for necessária. Eles não precisam ser lidos em qualquer ordem específica, nem é necessário ler todos eles antes de usar o FreeBSD em um ambiente de rede.</p></div></div></div><div class=sect1><h2 id=serialcomms>Capítulo 26. Comunicações Seriais<a class=anchor href=#serialcomms></a></h2><div class=sectionbody><div class=sect2><h3 id=serial-synopsis>26.1. Sinopse<a class=anchor href=#serial-synopsis></a></h3><div class=paragraph><p>O UNIX™ sempre teve suporte para comunicação serial, pois as primeiras máquinas UNIX™ dependiam de linhas seriais para entrada e saída do usuário. As coisas mudaram muito desde os dias em que o terminal médio consistia de uma impressora serial de 10 caracteres por segundo e um teclado. Este capítulo aborda algumas das maneiras pelas quais as comunicações seriais podem ser usadas no FreeBSD.</p></div><div class=paragraph><p>Depois de ler este capítulo, você saberá:</p></div><div class=ulist><ul><li><p>Como conectar terminais a um sistema FreeBSD.</p></li><li><p>Como usar um modem para discar para hosts remotos.</p></li><li><p>Como permitir que usuários remotos efetuem login em um sistema FreeBSD com um modem.</p></li><li><p>Como inicializar um sistema FreeBSD a partir de uma console serial.</p></li></ul></div><div class=paragraph><p>Antes de ler este capítulo, você deve:</p></div><div class=ulist><ul><li><p>Saiba como <a href=./#kernelconfig>configurar e instalar um kernel personalizado</a>.</p></li><li><p>Entenda <a href=./#basics>permissões e processos do FreeBSD</a>.</p></li><li><p>Tenha acesso ao manual técnico para o hardware serial a ser usado com o FreeBSD.</p></li></ul></div></div><div class=sect2><h3 id=serial>26.2. Terminologia serial e hardware<a class=anchor href=#serial></a></h3><div class=paragraph><p>Os termos a seguir são frequentemente usados em comunicações seriais:</p></div><div class=dlist><dl><dt class=hdlist1>bps</dt><dd><p>Bits por Segundo (bps) é a taxa na qual os dados são transmitidos.</p></dd><dt class=hdlist1>DTE</dt><dd><p>Equipamento Terminal de Dados (DTE) é um dos dois terminais em uma comunicação serial. Um exemplo seria um computador.</p></dd><dt class=hdlist1>DCE</dt><dd><p>Equipamento de Comunicações de Dados (DTE) é o outro terminal em uma comunicação serial. Normalmente, é um modem ou terminal serial.</p></dd><dt class=hdlist1>RS-232</dt><dd><p>O padrão original que definiu as comunicações seriais de hardware. Desde então, foi renomeado para TIA-232.</p></dd></dl></div><div class=paragraph><p>Ao se referir a taxas de dados de comunicação, esta seção não usa o termo <em>baud</em>. Baud refere-se ao número de transições de estado elétrico feitas em um período de tempo, enquanto bps é o termo correto a ser usado.</p></div><div class=paragraph><p>Para conectar um terminal serial a um sistema FreeBSD, são necessárias uma porta serial no computador e o cabo adequado para conectar ao dispositivo serial. Os usuários que já estão familiarizados com hardware serial e cabeamento podem pular esta seção com segurança.</p></div><div class=sect3><h4 id=term-cables-null>26.2.1. Cabos Serial e Portas<a class=anchor href=#term-cables-null></a></h4><div class=paragraph><p>Existem vários tipos diferentes de cabos seriais. Os dois tipos mais comuns são cabo null-modem e cabo padrão RS-232. A documentação do hardware deve descrever o tipo de cabo necessário.</p></div><div class=paragraph><p>Estes dois tipos de cabos diferem em como os fios são conectados ao conector. Cada fio representa um sinal, com os sinais definidos resumidos em <a href=#serialcomms-signal-names>RS-232C Nomes dos Sinais</a>. Um cabo serial padrão passa todos os sinais RS-232C diretamente. Por exemplo, o pino "Transmitted Data" em uma extremidade do cabo vai para o pino "Transmitted Data" na outra extremidade. Este é o tipo de cabo usado para conectar um modem ao sistema FreeBSD e também é apropriado para alguns terminais.</p></div><div class=paragraph><p>Um cabo de modem nulo alterna o pino "Transmitted Data" do conector em uma extremidade com o pino "Received Data" na outra extremidade. O conector pode ser um DB-25 ou um DB-9.</p></div><div class=paragraph><p>Um cabo de modem nulo pode ser construído usando as conexões de pinos resumidas em <a href=#nullmodem-db25>Cabo Null-Modem DB-25 para DB-25</a>, <a href=#nullmodem-db9>Cabo DB-9 para DB-9 Null-Modem</a> e <a href=#nullmodem-db9-25>Cabo DB-9 para DB-25 Null-Modem</a>. Enquanto o padrão exige um pino direto 1 para fixar uma linha "Protective Ground", ele é freqüentemente omitido. Alguns terminais funcionam usando apenas os pinos 2, 3 e 7, enquanto outros exigem configurações diferentes. Em caso de dúvida, consulte a documentação do hardware.</p></div><table id=serialcomms-signal-names class="tableblock frame-none grid-all stretch"><caption class=title>Tabela 19. RS-232C Nomes dos Sinais</caption><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Siglas</th><th class="tableblock halign-left valign-top">Nomes</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>RD</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Received Data</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>TD</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Transmitted Data</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>DTR</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Data Terminal Ready</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>DSR</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Data Set Ready</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>DCD</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Data Carrier Detect</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>SG</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Signal Ground</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>RTS</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Request to Send</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>CTS</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Clear to Send</p></td></tr></tbody></table><table id=nullmodem-db25 class="tableblock frame-none grid-all stretch"><caption class=title>Tabela 20. Cabo Null-Modem DB-25 para DB-25</caption><col style=width:20%><col style=width:20%><col style=width:20%><col style=width:20%><col style=width:20%><thead><tr><th class="tableblock halign-left valign-top">Sinal</th><th class="tableblock halign-left valign-top">Pin #</th><th class="tableblock halign-left valign-top"></th><th class="tableblock halign-left valign-top">Pin #</th><th class="tableblock halign-left valign-top">Sinal</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>SG</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>7</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>conecta-se a</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>7</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>SG</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>TD</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>2</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>conecta-se a</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>3</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>RD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>RD</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>3</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>conecta-se a</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>2</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>TD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>RTS</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>4</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>conecta-se a</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>5</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>CTS</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>CTS</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>5</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>conecta-se a</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>4</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>RTS</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>DTR</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>20</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>conecta-se a</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>6</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>DSR</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>DTR</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>20</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>conecta-se a</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>8</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>DCD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>DSR</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>6</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>conecta-se a</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>20</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>DTR</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>DCD</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>8</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>conecta-se a</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>20</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>DTR</p></td></tr></tbody></table><table id=nullmodem-db9 class="tableblock frame-none grid-all stretch"><caption class=title>Tabela 21. Cabo DB-9 para DB-9 Null-Modem</caption><col style=width:20%><col style=width:20%><col style=width:20%><col style=width:20%><col style=width:20%><thead><tr><th class="tableblock halign-left valign-top">Sinal</th><th class="tableblock halign-left valign-top">Pin #</th><th class="tableblock halign-left valign-top"></th><th class="tableblock halign-left valign-top">Pin #</th><th class="tableblock halign-left valign-top">Sinal</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>RD</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>2</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>conecta-se a</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>3</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>TD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>TD</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>3</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>conecta-se a</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>2</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>RD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>DTR</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>4</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>conecta-se a</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>6</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>DSR</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>DTR</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>4</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>conecta-se a</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>1</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>DCD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>SG</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>5</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>conecta-se a</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>5</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>SG</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>DSR</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>6</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>conecta-se a</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>4</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>DTR</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>DCD</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>1</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>conecta-se a</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>4</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>DTR</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>RTS</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>7</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>conecta-se a</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>8</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>CTS</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>CTS</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>8</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>conecta-se a</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>7</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>RTS</p></td></tr></tbody></table><table id=nullmodem-db9-25 class="tableblock frame-none grid-all stretch"><caption class=title>Tabela 22. Cabo DB-9 para DB-25 Null-Modem</caption><col style=width:20%><col style=width:20%><col style=width:20%><col style=width:20%><col style=width:20%><thead><tr><th class="tableblock halign-left valign-top">Sinal</th><th class="tableblock halign-left valign-top">Pin #</th><th class="tableblock halign-left valign-top"></th><th class="tableblock halign-left valign-top">Pin #</th><th class="tableblock halign-left valign-top">Sinal</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>RD</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>2</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>conecta-se a</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>2</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>TD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>TD</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>3</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>conecta-se a</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>3</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>RD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>DTR</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>4</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>conecta-se a</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>6</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>DSR</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>DTR</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>4</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>conecta-se a</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>8</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>DCD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>SG</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>5</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>conecta-se a</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>7</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>SG</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>DSR</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>6</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>conecta-se a</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>20</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>DTR</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>DCD</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>1</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>conecta-se a</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>20</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>DTR</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>RTS</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>7</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>conecta-se a</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>5</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>CTS</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>CTS</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>8</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>conecta-se a</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>4</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>RTS</p></td></tr></tbody></table><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Quando um pino em uma extremidade se conecta a um par de pinos na outra extremidade, geralmente é implementado com um fio curto entre o par de pinos em seu conector e um fio longo no outro pino único.</p></div></td></tr></tbody></table></div><div class=paragraph><p>As portas seriais são os dispositivos através dos quais os dados são transferidos entre o computador host do FreeBSD e o terminal. Vários tipos de portas seriais existem. Antes de comprar ou construir um cabo, verifique se ele irá se encaixar nas portas do terminal e no sistema FreeBSD.</p></div><div class=paragraph><p>A maioria dos terminais tem portas DB-25. Os computadores pessoais podem ter portas DB-25 ou DB-9. Um cartão serial multiportas pode ter portas RJ-12 ou RJ-45/. Consulte a documentação que acompanha o hardware para especificações sobre o tipo de porta ou verifique visualmente o tipo de porta.</p></div><div class=paragraph><p>No FreeBSD, cada porta serial é acessada através de uma entrada em <span class=filename>/dev</span>. Existem dois tipos diferentes de entradas:</p></div><div class=ulist><ul><li><p>As portas de chamada são nomeadas <span class=filename>/dev/ttyuN</span> onde <em>N</em> é o número da porta, começando do zero. Se um terminal estiver conectado a primeira porta serial (<span class=filename>COM1</span>), use <span class=filename>/dev/ttyu0</span> para se referir ao terminal. Se o terminal estiver na segunda porta serial (<span class=filename>COM2</span>), use <span class=filename>/dev/ttyu1</span> e assim por diante. Geralmente, a porta de chamada é usada para terminais. As portas de chamada requerem que a linha serial declare o sinal "Data Carrier Detect" para funcionar corretamente.</p></li><li><p>As portas de chamadas de saida são nomeadas <span class=filename>/dev/cuauN</span> nas versões 8.X e superiores do FreeBSD e <span class=filename>/dev/cuadN</span> nas versões 7.X e inferiores do FreeBSD. As portas de chamada de saida geralmente não são usadas para terminais, mas são usadas para modems. A porta de evocação pode ser usada se o cabo serial ou o terminal não suportar o sinal "Data Carrier Detect".</p></li></ul></div><div class=paragraph><p>O FreeBSD também fornece dispositivos de inicialização (<span class=filename>/dev/ttyuN.init</span> e <span class=filename>/dev/cuauN.init</span> ou <span class=filename>/dev/cuadN.init</span>) e dispositivos de bloqueio (<span class=filename>/dev/ttyuN.lock</span> e <span class=filename>/dev/cuauN.lock</span> ou <span class=filename>/dev/cuadN.lock</span>). Os dispositivos de inicialização são utilizados para inicializar os parâmetros da porta de comunicações de cada vez que uma porta é aberta, tal como o <code>crtscts</code> para modems que usam <code>RTS/CTS</code> sinalização para controle de fluxo. Os dispositivos de bloqueio são usados para bloquear sinalizadores nas portas para impedir que usuários ou programas alterem determinados parâmetros. Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=termios&amp;sektion=4&amp;format=html">termios(4)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=sio&amp;sektion=4&amp;format=html">sio(4)</a>, e <a href="https://man.freebsd.org/cgi/man.cgi?query=stty&amp;sektion=1&amp;format=html">stty(1)</a> para obter informações sobre configurações de terminal, bloqueio e inicialização de dispositivos e configuração de opções de terminal, respectivamente.</p></div></div><div class=sect3><h4 id=serial-hw-config>26.2.2. Configuração de Porta Serial<a class=anchor href=#serial-hw-config></a></h4><div class=paragraph><p>Por padrão, o FreeBSD suporta quatro portas seriais que são comumente conhecidas como <span class=filename>COM1</span>, <span class=filename>COM2</span>, <span class=filename>COM3</span> e <span class=filename>COM4</span>. O FreeBSD também suporta placas de interfaces seriais multi-port, como o BocaBoard 1008 e 2016, bem como placas multi-port mais inteligentes, como as feitas pela Digiboard. No entanto, o kernel padrão procura apenas as portas padrão <span class=filename>COM</span>.</p></div><div class=paragraph><p>Para ver se o sistema reconhece as portas seriais, procure por mensagens de inicialização do sistema que começam com <code>uart</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># grep uart /var/run/dmesg.boot</span></code></pre></div></div><div class=paragraph><p>Se o sistema não reconhecer todas as portas seriais necessárias, entradas adicionais podem ser adicionadas ao <span class=filename>/boot/device.hints</span>. Este arquivo já contém entradas <code>hint.uart.0.*</code> para entradas <span class=filename>COM1</span> e <code>hint.uart.1.*</code> para <span class=filename>COM2</span>. Ao adicionar uma entrada de porta para <span class=filename>COM3</span> use <code>0x3E8</code> e para <span class=filename>COM4</span> use <code>0x2E8</code>. Endereços comuns de IRQ são <code>5</code> para <span class=filename>COM3</span> e <code>9</code> para <span class=filename>COM4</span>.</p></div><div class=paragraph><p>Para determinar o conjunto padrão de configurações de terminal E/S usadas pela porta, especifique o nome do dispositivo. Este exemplo determina as configurações para a porta de chamada em <span class=filename>COM2</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># stty -a -f /dev/ttyu1</span></code></pre></div></div><div class=paragraph><p>A inicialização de dispositivos seriais em todo o sistema é controlada por <span class=filename>/etc/rc.d/serial</span>. Este arquivo afeta as configurações padrão dos dispositivos seriais. Para alterar as configurações de um dispositivo, use <code>stty</code>. Por padrão, as configurações alteradas estão em vigor até que o dispositivo seja fechado e, quando o dispositivo for reaberto, volte para o conjunto padrão. Para alterar permanentemente o conjunto padrão, abra e ajuste as configurações do dispositivo de inicialização. Por exemplo, para ativar o modo <code>CLOCAL</code>, comunicação de 8 bits e controle de fluxo <code>XON/XOFF</code> para <span class=filename>ttyu5</span>, digite:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># stty -f /dev/ttyu5.init clocal cs8 ixon ixoff</span></code></pre></div></div><div class=paragraph><p>Para impedir que determinadas configurações sejam alteradas por um aplicativo, faça ajustes no dispositivo de bloqueio. Por exemplo, para bloquear a velocidade de <span class=filename>ttyu5</span> para 57600 bps, digite:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># stty -f /dev/ttyu5.lock 57600</span></code></pre></div></div><div class=paragraph><p>Agora, qualquer aplicativo que abra <span class=filename>ttyu5</span> e tente alterar a velocidade da porta será bloqueado com 57600 bps.</p></div></div></div><div class=sect2><h3 id=term>26.3. Terminais<a class=anchor href=#term></a></h3><div class=paragraph><p>Os terminais fornecem uma maneira conveniente e barata de acessar um sistema FreeBSD quando não estão no console do computador ou em uma rede conectada. Esta seção descreve como usar terminais com o FreeBSD.</p></div><div class=paragraph><p>Os sistemas originais UNIX™ não tinham consoles. Em vez disso, os usuários efetuaram login e executaram programas por meio de terminais conectados as portas seriais do computador.</p></div><div class=paragraph><p>A capacidade de estabelecer uma sessão de login em uma porta serial ainda existe em quase todos os sistemas operacionais do tipo UNIX™ hoje, incluindo o FreeBSD. Usando um terminal conectado a uma porta serial não usada, um usuário pode efetuar login e executar qualquer programa de texto que possa ser executado normalmente no console ou em uma janela <code>xterm</code>.</p></div><div class=paragraph><p>Muitos terminais podem ser conectados a um sistema FreeBSD. Um computador sobressalente mais antigo pode ser usado como um terminal conectado a um computador mais potente executando o FreeBSD. Isso pode transformar o que poderia ser um computador de usuário único em um poderoso sistema de múltiplos usuários.</p></div><div class=paragraph><p>O FreeBSD suporta três tipos de terminais:</p></div><div class=dlist><dl><dt class=hdlist1>Terminais Burros</dt><dd><p>Terminais burro são um hardware especializado que se conecta a computadores através de linhas seriais. Eles são chamados de "dumb" porque eles possuem apenas poder computacional suficiente para exibir, enviar e receber texto. Nenhum programa pode ser executado nesses dispositivos. Em vez disso, os terminais burros se conectam a um computador que executa os programas necessários.</p><div class=paragraph><p>Existem centenas de tipos de terminais burro feitos por muitos fabricantes, e praticamente qualquer tipo funciona com o FreeBSD. Alguns terminais high-end podem até exibir gráficos, mas apenas determinados pacotes de software podem aproveitar esses recursos avançados.</p></div><div class=paragraph><p>Terminais burro são populares em ambientes de trabalho onde os trabalhadores não precisam de acesso a aplicativos gráficos.</p></div></dd><dt class=hdlist1>Computadores Atuando como Terminais</dt><dd><p>Como um terminal burro tem capacidade suficiente para exibir, enviar e receber texto, qualquer computador de reserva pode ser um terminal burro. Tudo o que é necessário é o cabo adequado e algum software de <em>terminal emulation</em> para ser executado no computador.</p><div class=paragraph><p>Esta configuração pode ser útil. Por exemplo, se um usuário está ocupado trabalhando no console do sistema FreeBSD, outro usuário pode fazer algum trabalho somente de texto ao mesmo tempo de um computador pessoal menos potente ligado como um terminal ao sistema FreeBSD.</p></div><div class=paragraph><p>Existem pelo menos dois utilitários no sistema base do FreeBSD que podem ser usados para trabalhar através de uma conexão serial: <a href="https://man.freebsd.org/cgi/man.cgi?query=cu&amp;sektion=1&amp;format=html">cu(1)</a> e <a href="https://man.freebsd.org/cgi/man.cgi?query=tip&amp;sektion=1&amp;format=html">tip(1)</a>.</p></div><div class=paragraph><p>Por exemplo, para conectar-se de um sistema cliente que executa o FreeBSD para a conexão serial de outro sistema:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cu -l /dev/cuauN</span></code></pre></div></div><div class=paragraph><p>Portas são numeradas a partir de zero. Isso significa que <span class=filename>COM1</span> é <span class=filename>/dev/cuau0</span>.</p></div><div class=paragraph><p>Programas adicionais estão disponíveis através da coleção de ports, como <a class=package href=https://cgit.freebsd.org/ports/tree/comms/minicom/>comms/minicom</a>.</p></div></dd><dt class=hdlist1>Terminais X</dt><dd><p>Os terminais X são o tipo de terminal mais sofisticado disponível. Em vez de se conectar a uma porta serial, eles geralmente se conectam a uma rede como a Ethernet. Em vez de serem relegados a aplicativos somente de texto, eles podem exibir qualquer aplicativo Xorg.</p><div class=paragraph><p>Este capítulo não cobre a configuração ou uso de terminais X.</p></div></dd></dl></div><div class=sect3><h4 id=term-config>26.3.1. Configuração do Terminal<a class=anchor href=#term-config></a></h4><div class=paragraph><p>Esta seção descreve como configurar um sistema FreeBSD para ativar uma sessão de login em um terminal serial. Assume-se que o sistema reconhece a porta serial a qual o terminal está conectado e que o terminal está conectado com o cabo correto.</p></div><div class=paragraph><p>No FreeBSD, o <code>init</code> lê o <span class=filename>/etc/ttys</span> e inicia um processo <code>getty</code> nos terminais disponíveis. O processo <code>getty</code> é responsável por ler um nome de login e iniciar o programa <code>login</code>. As portas no sistema FreeBSD que permitem logins estão listadas em <span class=filename>/etc/ttys</span>. Por exemplo, o primeiro console virtual, <span class=filename>ttyv0</span>, possui uma entrada nesse arquivo, permitindo logins no console. Este arquivo também contém entradas para os outros consoles virtuais, portas seriais e pseudo-ttys. Para um terminal com fio, a entrada <span class=filename>/dev</span> da porta serial é listada sem a parte <code>/dev</code>. Por exemplo, <span class=filename>/dev/ttyv0</span> está listado como <code>ttyv0</code>.</p></div><div class=paragraph><p>Por padrão o <span class=filename>/etc/ttys</span> configura o suporte para as quatro primeiras portas seriais, <span class=filename>ttyu0</span> até <span class=filename>ttyu3</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>ttyu0   &#34;/usr/libexec/getty std.9600&#34;   dialup  off secure
ttyu1   &#34;/usr/libexec/getty std.9600&#34;   dialup  off secure
ttyu2   &#34;/usr/libexec/getty std.9600&#34;   dialup  off secure
ttyu3   &#34;/usr/libexec/getty std.9600&#34;   dialup  off secure</pre></div></div><div class=paragraph><p>Ao conectar um terminal a uma destas portas, modifique a entrada padrão para definir a velocidade e o tipo de terminal necessários, para ligar o dispositivo <code>on</code> e, se necessário, para alterar o <code>secure</code> da porta. Se o terminal estiver conectado a outra porta, adicione uma entrada para a porta.</p></div><div class=paragraph><p><a href=#ex-etc-ttys>Configurando Entradas de Terminal</a> configura dois terminais em <span class=filename>/etc/ttys</span>. A primeira entrada configura um Wyse-50 conectado ao <span class=filename>COM2</span>. A segunda entrada configura um computador antigo executando o software do terminal Procomm emulando um terminal VT-100. O computador está conectado à sexta porta serial em uma placa serial com várias portas.</p></div><div id=ex-etc-ttys class=exampleblock><div class=title>Exemplo 44. Configurando Entradas de Terminal</div><div class=content><div class="literalblock programlisting"><div class=content><pre>ttyu1  &#34;/usr/libexec/getty std.38400&#34;  wy50  on  insecure
ttyu5   &#34;/usr/libexec/getty std.19200&#34;  vt100  on insecure</pre></div></div><div class=ulist><ul><li><p>O primeiro campo especifica o nome do dispositivo do terminal serial.</p></li><li><p>O segundo campo informa ao <code>getty</code> para inicializar e abrir a linha, definir a velocidade da linha, solicitar um nome de usuário e, em seguida, executar o programa <code>login</code>. O tipo de <em>getty type</em> configura características na linha do terminal, como taxa e paridade bps. Os tipos de getty disponíveis estão listados em <span class=filename>/etc/gettytab</span>. Em quase todos os casos, os tipos de getty que começam com <code>std</code> funcionarão para terminais conectados, já que essas entradas ignoram a paridade. Há uma entrada <code>std</code> para cada taxa de bps de 110 a 115200. Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=gettytab&amp;sektion=5&amp;format=html">gettytab(5)</a> para mais informações.Ao definir o tipo de getty, certifique-se de coincidir com as configurações de comunicação usadas pelo terminal. Para este exemplo, o Wyse-50 não usa paridade e se conecta a 38400 bps. O computador não usa paridade e se conecta a 19200 bps.</p></li><li><p>O terceiro campo é o tipo de terminal. Para portas dial-up, <code>unknown</code> ou <code>dialup</code> é normalmente usado, pois os usuários podem discar praticamente com qualquer tipo de terminal ou software. Como o tipo de terminal não muda para terminais com fio, um tipo de terminal real de <span class=filename>/etc/termcap</span> pode ser especificado. Para este exemplo, o Wyse-50 usa o tipo de terminal real enquanto o computador executando o Procomm está configurado para emular um VT-100.</p></li><li><p>O quarto campo especifica se a porta deve estar ativada. Para ativar logins nessa porta, este campo deve ser definido como <code>on</code>.</p></li><li><p>O campo final é usado para especificar se a porta é segura. Marcar uma porta como <code>secure</code> significa que ela é confiável o suficiente para permitir que <code>root</code> faça login a partir dessa porta. As portas inseguras não permitem logins <code>root</code>. Em uma porta insegura, os usuários devem efetuar login de contas não privilegiadas e, em seguida, usar o <code>su</code> ou um mecanismo semelhante para obter privilégios de superusuário, conforme descrito em <a href=./#users-superuser>A conta de superusuário</a>. Por razões de segurança, recomenda-se alterar esta configuração para <code>insecure</code>.</p></li></ul></div></div></div><div class=paragraph><p>Depois de fazer qualquer alteração em <span class=filename>/etc/ttys</span>, envie um sinal SIGHUP (hangup) para o processo <code>init</code> para forçá-lo a reler seu arquivo de configuração:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kill -HUP 1</span></code></pre></div></div><div class=paragraph><p>Como o <code>init</code> é sempre o primeiro processo executado em um sistema, ele sempre tem um processo ID de <code>1</code>.</p></div><div class=paragraph><p>Se tudo estiver configurado corretamente, todos os cabos estiverem no lugar e os terminais ligados, um processo <code>getty</code> deverá estar em execução em cada terminal e as solicitações de login deverão estar disponíveis em cada terminal.</p></div></div><div class=sect3><h4 id=term-debug>26.3.2. Solução de Problemas da Conexão<a class=anchor href=#term-debug></a></h4><div class=paragraph><p>Mesmo com a mais meticulosa atenção aos detalhes, algo poderia dar errado ao configurar um terminal. Aqui está uma lista de sintomas comuns e algumas correções sugeridas.</p></div><div class=paragraph><p>Se nenhum prompt de login aparecer, verifique se o terminal está conectado e ligado. Se for um computador pessoal atuando como um terminal, verifique se ele está executando o software de emulação de terminal na porta serial correta.</p></div><div class=paragraph><p>Certifique-se de que o cabo esteja conectado firmemente ao terminal e ao computador do FreeBSD. Certifique-se de que é o tipo certo de cabo.</p></div><div class=paragraph><p>Certifique-se de que o terminal e o FreeBSD concordem com as configurações de taxa e paridade de bps. Para um terminal de exibição de vídeo, verifique se os controles de contraste e brilho estão ativados. Se for um terminal de impressão, verifique se o papel e a tinta estão em bom estado.</p></div><div class=paragraph><p>Use <code>ps</code> para certificar-se de que um processo <code>getty</code> esteja em execução e atendendo ao terminal. Por exemplo, a listagem a seguir mostra que um <code>getty</code> está sendo executado na segunda porta serial, <span class=filename>ttyu1</span>, e está usando a entrada <code>std.38400</code> em <span class=filename>/etc/gettytab</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ps -axww|grep ttyu</span>
22189  d1  Is+    0:00.03 /usr/libexec/getty std.38400 ttyu1</code></pre></div></div><div class=paragraph><p>Se nenhum processo <code>getty</code> estiver em execução, certifique-se de que a porta esteja ativada em <span class=filename>/etc/ttys</span>. Lembre-se de executar <code>kill -HUP 1</code> após modificar <span class=filename>/etc/ttys</span>.</p></div><div class=paragraph><p>Se o processo <code>getty</code> estiver em execução, mas o terminal ainda não exibir um prompt de login ou se exibir um prompt, mas não aceitar entrada digitada, o terminal ou cabo poderá não suportar handshaking de hardware. Tente alterar a entrada em <span class=filename>/etc/ttys</span> de <code>std.38400</code> para <code>3wire.38400</code> e, em seguida, execute <code>kill -HUP 1</code> depois de modificar o <span class=filename>/etc/ttys</span>. A entrada <code>3wire</code> é semelhante a <code>std</code>, mas ignora handshaking de hardware. Pode ser necessário reduzir a taxa de transmissão ou ativar o controle de fluxo de software ao usar <code>3wire</code> para evitar buffer overflows.</p></div><div class=paragraph><p>Se aparecer lixo em vez de um prompt de login, certifique-se de que o terminal e o FreeBSD concordem com as configurações de taxa e paridade de bps. Verifique os processos <code>getty</code> para certificar-se de que o tipo correto <em>getty</em> esteja em uso. Se não, edite <span class=filename>/etc/ttys</span> e execute <code>kill -HUP 1</code>.</p></div><div class=paragraph><p>Se os caracteres aparecerem duplicados e a senha aparecer quando digitada, alterne o terminal ou o software de emulação de terminal de "half duplex" ou "local echo" para "full duplex."</p></div></div></div><div class=sect2><h3 id=dialup>26.4. Serviço Dial-in<a class=anchor href=#dialup></a></h3><div class=paragraph><p>Configurar um sistema FreeBSD para serviço de discagem é semelhante a configurar terminais, exceto que os modens são usados em vez de dispositivos terminais. O FreeBSD suporta modens externos e internos.</p></div><div class=paragraph><p>Os modems externos são mais convenientes, pois geralmente podem ser configurados por meio de parâmetros armazenados em RAM não voláteis e geralmente fornecem indicadores luminosos que exibem o estado dos sinais RS-232 importantes, indicando se o modem está funcionando corretamente.</p></div><div class=paragraph><p>Normalmente, os modems internos não possuem RAM não volátil, portanto, sua configuração pode ser limitada à configuração de switches DIP. Se o modem interno tiver luzes indicadoras de sinal, elas serão difíceis de visualizar quando a tampa do sistema estiver no lugar.</p></div><div class=paragraph><p>Ao usar um modem externo, é necessário um cabo adequado. Um cabo serial padrão de RS-232C deve ser suficiente.</p></div><div class=paragraph><p>O FreeBSD precisa dos sinais RTS e CTS para controle de fluxo em velocidades acima de 2400 bps, o sinal CD para detectar quando uma chamada foi atendida ou a linha foi desligada e o sinal DTR para redefinir o modem após a conclusão de uma sessão. Alguns cabos são conectados sem todos os sinais necessários, portanto, se uma sessão de login não desaparecer quando a linha for desligada, pode haver um problema com o cabo. Consulte <a href=#term-cables-null>Cabos Serial e Portas</a> para mais informações sobre esses sinais.</p></div><div class=paragraph><p>Como outros sistemas operacionais similares ao UNIX™-like, o FreeBSD usa os sinais de hardware para descobrir quando uma chamada foi atendida ou uma linha foi desconectada e para desligar e reinicializar o modem após uma chamada. O FreeBSD evita enviar comandos para o modem ou observar relatórios de status do modem.</p></div><div class=paragraph><p>O FreeBSD suporta interfaces de comunicação NS8250, NS16450, NS16550 e NS16550A baseado em RS-232C (CCITT V.24). Os dispositivos 8250 e 16450 possuem buffers de caractere único. O dispositivo 16550 fornece um buffer de 16 caracteres, o que permite um melhor desempenho do sistema. Bugs em dispositivos simples 16550 impedem o uso do buffer de 16 caracteres, portanto, use dispositivos 16550A, se possível. Como os dispositivos de buffer de caractere único requerem mais trabalho pelo sistema operacional do que os dispositivos de buffer de 16 caracteres, as placas de interface serial baseadas no 16550A são preferidas. Se o sistema tiver muitas portas seriais ativas ou tiver uma carga pesada, as placas baseadas em 16550A são melhores para comunicações com baixa taxa de erro.</p></div><div class=paragraph><p>O restante desta seção demonstra como configurar um modem para receber conexões de entrada, como se comunicar com o modem e oferece algumas dicas de solução de problemas.</p></div><div class=sect3><h4 id=dialup-ttys>26.4.1. Configuração de Modem<a class=anchor href=#dialup-ttys></a></h4><div class=paragraph><p>Como nos terminais, o <code>init</code> gera um processo <code>getty</code> para cada porta serial configurada usada para conexões de dial-in. Quando um usuário disca a linha do modem e os modems se conectam, o sinal "Carrier Detect" é informado pelo modem. O kernel percebe que a portadora foi detectada e instrui o <code>getty</code> a abrir a porta e exibir um prompt <code>login:</code> na velocidade da linha inicial especificada. Em uma configuração típica, se caracteres de lixo forem recebidos, geralmente devido à velocidade de conexão do modem ser diferente da velocidade configurada, o <code>getty</code> tenta ajustar as velocidades de linha até receber caracteres razoáveis. Depois que o usuário digita seu nome de login, o <code>getty</code> executa o <code>login</code>, que conclui o processo de login solicitando a senha do usuário e iniciando o shell do usuário.</p></div><div class=paragraph><p>Existem duas escolas de pensamento sobre modems dial-up. Um método de configuração é definir os modems e sistemas de modo que, independentemente da velocidade em que um usuário remoto disca, a interface de discagem RS-232 seja executada em uma velocidade travada. O benefício dessa configuração é que o usuário remoto sempre vê um prompt de login do sistema imediatamente. A desvantagem é que o sistema não sabe qual é a verdadeira taxa de dados do usuário, portanto, programas em tela cheia como o Emacs não ajustam seus métodos de tela para melhorar a resposta para conexões mais lentas.</p></div><div class=paragraph><p>O segundo método é configurar a interface RS-232 para variar sua velocidade com base na velocidade de conexão do usuário remoto. Como o <code>getty</code> não compreende o relatório de velocidade de conexão de nenhum modem em particular, ele fornece uma mensagem <code>login:</code> em uma velocidade inicial e observa os caracteres que retornam em resposta. Se o usuário vê lixo, eles devem pressionar <kbd>Enter</kbd> até que um prompt reconhecível seja exibido. Se as taxas de dados não corresponderem, <code>getty</code> verá qualquer coisa que o usuário digita como lixo, e tentará a próxima velocidade e informará novamente o prompt <code>login:</code>. Esse procedimento normalmente leva apenas um pressionamento de tecla ou dois antes que o usuário veja um bom prompt. Essa seqüência de login não parece tão limpa quanto o método de velocidade travada, mas um usuário em uma conexão de baixa velocidade deve receber uma melhor resposta interativa de programas em tela cheia.</p></div><div class=paragraph><p>Ao travar a taxa de comunicação de dados de um modem a uma velocidade específica, nenhuma alteração em <span class=filename>/etc/gettytab</span> deve ser necessária. No entanto, para uma configuração de velocidade compatível, entradas adicionais podem ser necessárias para definir as velocidades a serem usadas para o modem. Este exemplo configura um modem de 14,4 Kbps com uma velocidade de interface superior de 19,2 Kbps usando conexões de 8 bits sem paridade. Ele configura o <code>getty</code> para iniciar a taxa de comunicação para uma conexão V.32bis a 19,2 Kbps, passando por 9600 bps, 2400 bps, 1200 bps, 300 bps e de volta para 19,2 Kbps. O ciclo de taxa de comunicação é implementado com o recurso <code>nx=</code> (proxima tabela). Cada linha usa uma entrada <code>tc=</code> (continuação de tabela) para selecionar o restante das configurações para uma taxa de dados específica.</p></div><div class="literalblock programlisting"><div class=content><pre>#
# Additions for a V.32bis Modem
#
um|V300|High Speed Modem at 300,8-bit:\
        :nx=V19200:tc=std.300:
un|V1200|High Speed Modem at 1200,8-bit:\
        :nx=V300:tc=std.1200:
uo|V2400|High Speed Modem at 2400,8-bit:\
        :nx=V1200:tc=std.2400:
up|V9600|High Speed Modem at 9600,8-bit:\
        :nx=V2400:tc=std.9600:
uq|V19200|High Speed Modem at 19200,8-bit:\
        :nx=V9600:tc=std.19200:</pre></div></div><div class=paragraph><p>Para um modem de 28,8 Kbps ou para aproveitar a compactação em um modem de 14,4 Kbps, use uma taxa de comunicação mais alta, conforme mostrado neste exemplo:</p></div><div class="literalblock programlisting"><div class=content><pre>#
# Additions for a V.32bis or V.34 Modem
# Starting at 57.6 Kbps
#
vm|VH300|Very High Speed Modem at 300,8-bit:\
        :nx=VH57600:tc=std.300:
vn|VH1200|Very High Speed Modem at 1200,8-bit:\
        :nx=VH300:tc=std.1200:
vo|VH2400|Very High Speed Modem at 2400,8-bit:\
        :nx=VH1200:tc=std.2400:
vp|VH9600|Very High Speed Modem at 9600,8-bit:\
        :nx=VH2400:tc=std.9600:
vq|VH57600|Very High Speed Modem at 57600,8-bit:\
        :nx=VH9600:tc=std.57600:</pre></div></div><div class=paragraph><p>Para uma CPU lenta ou um sistema altamente carregado sem portas seriais baseadas no 16550A, esta configuração pode produzir erros <code>sio</code> "silo" a 57,6 Kbps.</p></div><div class=paragraph><p>A configuração do <span class=filename>/etc/ttys</span> é similar a <a href=#ex-etc-ttys>Configurando Entradas de Terminal</a>, mas um argumento diferente é passado para o <code>getty</code> e <code>dialup</code> é usado para o tipo de terminal. Substitua <em>xxx</em> pelo processo <code>init</code> que será executado no dispositivo:</p></div><div class="literalblock programlisting"><div class=content><pre>ttyu0   &#34;/usr/libexec/getty xxx&#34;   dialup on</pre></div></div><div class=paragraph><p>O tipo de terminal <code>dialup</code> pode ser alterado. Por exemplo, definir <code>vt102</code> como o tipo de terminal padrão permite que os usuários usem a emulação VT102 em seus sistemas remotos.</p></div><div class=paragraph><p>Para uma configuração de velocidade travada, especifique a velocidade com um tipo válido listado em <span class=filename>/etc/gettytab</span>. Este exemplo é para um modem cuja velocidade de porta está travada em 19,2 Kbps:</p></div><div class="literalblock programlisting"><div class=content><pre>ttyu0   &#34;/usr/libexec/getty std.19200&#34;   dialup on</pre></div></div><div class=paragraph><p>Em uma configuração de velocidade correspondente, a entrada precisa referenciar a entrada inicial apropriada "auto-baud" em <span class=filename>/etc/gettytab</span>. Para continuar o exemplo de um modem com velocidade correspondente que começa em 19,2 Kbps, use esta entrada:</p></div><div class="literalblock programlisting"><div class=content><pre>ttyu0   &#34;/usr/libexec/getty V19200&#34;   dialup on</pre></div></div><div class=paragraph><p>Depois de editar o <span class=filename>/etc/ttys</span>, espere até que o modem esteja devidamente configurado e conectado antes de sinalizar o <code>init</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kill -HUP 1</span></code></pre></div></div><div class=paragraph><p>Modems de alta velocidade, como os modems V.32, V.32bis e V.34, usam hardware (<code>RTS/CTS</code>) para controle de fluxo. Use o <code>stty</code> para definir a flag de controle de fluxo de hardware para a porta do modem. Este exemplo define a flag <code>crtscts</code> na inicialização dos dispositivos <span class=filename>COM2</span> de dial-in e de dial-out:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># stty -f /dev/ttyu1.init crtscts</span>
<span class=c># stty -f /dev/cuau1.init crtscts</span></code></pre></div></div></div><div class=sect3><h4 id=_solução_de_problemas_4>26.4.2. Solução de problemas<a class=anchor href=#_solução_de_problemas_4></a></h4><div class=paragraph><p>Esta seção fornece algumas dicas para solucionar problemas de um modem dial-up que não se conecta há um sistema FreeBSD.</p></div><div class=paragraph><p>Conecte o modem ao sistema FreeBSD e inicialize o sistema. Se o modem tiver luzes de indicação de status, observe se o indicador DTR do modem acende quando o prompt <code>login:</code> é exibido no console do sistema. Se acender, isso deve significar que o FreeBSD iniciou um processo <code>getty</code> na porta de comunicação apropriada e está aguardando o modem aceitar uma chamada.</p></div><div class=paragraph><p>Se o indicador DTR não acender, faça o login no sistema FreeBSD através do console e digite <code>ps ax</code> para ver se o FreeBSD está executando um processo <code>getty</code> na porta correta:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>114 ??  I      0:00.10 /usr/libexec/getty V19200<span class=sb>`</span>ttyu0<span class=sb>`</span></code></pre></div></div><div class=paragraph><p>Se a segunda coluna contiver um <code>d0</code> em vez de um <code>??</code> e o modem ainda não aceitou uma chamada, isso significa que o <code>getty</code> completou sua chamada na porta de comunicações. Isso pode indicar um problema com o cabeamento ou com um modem configurado incorretamente porque o <code>getty</code> não deve conseguir abrir a porta de comunicação até que o sinal de detecção da portadora tenha sido declarado pelo modem.</p></div><div class=paragraph><p>Se nenhum processo <code>getty</code> estiver aguardando para abrir a porta, verifique se a entrada da porta está correta no <span class=filename>/etc/ttys</span>. Além disso, verifique o <span class=filename>/var/log/messages</span> para ver se há alguma mensagem de log do <code>init</code> ou do <code>getty</code>.</p></div><div class=paragraph><p>Em seguida, tente discar para o sistema. Certifique-se de usar 8 bits, sem paridade e 1 bit de stop no sistema remoto. Se um prompt não aparecer imediatamente ou o prompt mostrar lixo, tente pressionar <kbd>Enter</kbd> uma vez por segundo durante alguns segundos. Se ainda não houver nenhum prompt de <code>login:</code>, tente enviar um <code>BREAK</code>. Ao usar um modem de alta velocidade, tente discar novamente após travar a velocidade da interface do modem de discagem.</p></div><div class=paragraph><p>Se ainda não houver o prompt <code>login:</code>, verifique novamente o <span class=filename>/etc/gettytab</span> e faça um double-check:</p></div><div class=ulist><ul><li><p>O nome do recurso inicial especificado na entrada em <span class=filename>/etc/ttys</span> corresponde ao nome de um recurso em <span class=filename>/etc/gettytab</span>.</p></li><li><p>Cada entrada <code>nx=</code> corresponde a outro nome de recurso <span class=filename>gettytab</span>.</p></li><li><p>Cada entrada <code>tc=</code> corresponde a outro nome de recurso <span class=filename>gettytab</span>.</p></li></ul></div><div class=paragraph><p>Se o modem no sistema FreeBSD não responder, verifique se o modem está configurado para atender o telefone quando o DTR é ativado. Se o modem parece estar configurado corretamente, verifique se a linha DTR é ativada, verificando as luzes indicadoras do modem.</p></div><div class=paragraph><p>Se ainda assim não funcionar, tente enviar um e-mail para a <a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-questions>lista de discussão de perguntas gerais do FreeBSD</a> descrevendo o modem e o problema.</p></div></div></div><div class=sect2><h3 id=dialout>26.5. Serviço de Dial-in<a class=anchor href=#dialout></a></h3><div class=paragraph><p>A seguir, dicas para fazer com que o host conecte-se através do modem a outro computador. Isto é apropriado para estabelecer uma sessão de terminal com um host remoto.</p></div><div class=paragraph><p>Esse tipo de conexão pode ser útil para obter um arquivo na Internet, caso haja problemas no uso do PPP. Se o PPP não estiver funcionando, use a sessão do terminal para enviar por FTP o arquivo necessário. Em seguida, use o zmodem para transferi-lo para a máquina.</p></div><div class=sect3><h4 id=hayes-unsupported>26.5.1. Usando um Modem Stock Hayes<a class=anchor href=#hayes-unsupported></a></h4><div class=paragraph><p>Um dialer Hayes genérico está incorporado no <code>tip</code>. Use <code>at=hayes</code> em <span class=filename>/etc/remote</span>.</p></div><div class=paragraph><p>O driver Hayes não é inteligente o suficiente para reconhecer alguns dos recursos avançados de mensagens de modems mais recentes como <code>BUSY</code>, <code>NO DIALTONE</code> ou <code>CONNECT 115200</code>. Desative essas mensagens ao usar o <code>tip</code> com o <code>ATX0&amp;W</code>.</p></div><div class=paragraph><p>O tempo limite de discagem para o <code>tip</code> é de 60 segundos. O modem deve usar algo menor, ou então o <code>tip</code> irá achar que existe um problema de comunicação. Tente usar <code>ATS7=45&amp;W</code>.</p></div></div><div class=sect3><h4 id=direct-at>26.5.2. Usando comandos <code>AT</code><a class=anchor href=#direct-at></a></h4><div class=paragraph><p>Crie uma entrada "direct" em <span class=filename>/etc/remote</span>. Por exemplo, se o modem estiver conectado à primeira porta serial, <span class=filename>/dev/cuau0</span>, use a seguinte linha:</p></div><div class="literalblock programlisting"><div class=content><pre>cuau0:dv=/dev/cuau0:br#19200:pa=none</pre></div></div><div class=paragraph><p>Use a taxa mais alta de bps que o modem suporta no recurso <code>br</code>. Em seguida, digite <code>tip cuau0</code> para conectar-se ao modem.</p></div><div class=paragraph><p>Ou use <code>cu</code> como <code>root</code> com o seguinte comando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cu -lline -sspeed</span></code></pre></div></div><div class=paragraph><p><em>line</em> é a porta serial, tal como <span class=filename>/dev/cuau0</span>, e <em>speed</em> é a velocidade, tal como <code>57600</code> . Quando terminar de digitar os comandos AT, digite <code>~.</code> para sair.</p></div></div><div class=sect3><h4 id=gt-failure>26.5.3. O Sinal <code>@</code> Não Funciona<a class=anchor href=#gt-failure></a></h4><div class=paragraph><p>O <code>@</code> na capability do número de telefone diz ao <code>tip</code> para procurar em <span class=filename>/etc/phones</span> um número de telefone. Mas, o sinal. <code>@</code> também é um caractere especial em arquivos de capablity como o <span class=filename>/etc/remote</span>, então ele precisa ser escapado com uma barra invertida:</p></div><div class="literalblock programlisting"><div class=content><pre>pn=\@</pre></div></div></div><div class=sect3><h4 id=dial-command-line>26.5.4. Discando a Partir da Linha de Comando<a class=anchor href=#dial-command-line></a></h4><div class=paragraph><p>Coloque uma entrada "genérica" em <span class=filename>/etc/remote</span>. Por exemplo:</p></div><div class="literalblock programlisting"><div class=content><pre>tip115200|Dial any phone number at 115200 bps:\
        :dv=/dev/cuau0:br#115200:at=hayes:pa=none:du:
tip57600|Dial any phone number at 57600 bps:\
        :dv=/dev/cuau0:br#57600:at=hayes:pa=none:du:</pre></div></div><div class=paragraph><p>Isto deve funcionar agora:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># tip -115200 5551234</span></code></pre></div></div><div class=paragraph><p>Usuários que preferem comando <code>cu</code> ao <code>tip</code>, podem usar uma entrada <code>cu</code> genérica:</p></div><div class="literalblock programlisting"><div class=content><pre>cu115200|Use cu to dial any number at 115200bps:\
        :dv=/dev/cuau1:br#57600:at=hayes:pa=none:du:</pre></div></div><div class=paragraph><p>e digite:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cu 5551234 -s 115200</span></code></pre></div></div></div><div class=sect3><h4 id=set-bps>26.5.5. Definindo a Taxa de bps<a class=anchor href=#set-bps></a></h4><div class=paragraph><p>Coloque uma entrada para <code>tip1200</code> ou <code>cu1200</code>, mas vá em frente e use qualquer taxa bps apropriada com o capability <code>br</code>. O <code>tip</code> acha que um bom padrão é de 1200 bps, e é por isso que ele procura por uma entrada <code>tip1200</code>. No entanto, 1200 bps não precisa ser usado.</p></div></div><div class=sect3><h4 id=terminal-server>26.5.6. Acessando um Conjunto de Hosts por Meio de um Servidor de Terminal<a class=anchor href=#terminal-server></a></h4><div class=paragraph><p>Em vez de esperar até conectar-se e digitar <code>CONNECT_host_</code> a cada vez, use o recurso <code>cm</code> do <code>tip</code>. Por exemplo, estas entradas no <span class=filename>/etc/remote</span> permitirão que você digite <code>tip pain</code> ou <code>tip muffin</code> para conectar-se aos hosts <code>pain</code> ou <code>muffin</code> e <code>tip deep13</code> para conectar ao servidor de terminal.</p></div><div class="literalblock programlisting"><div class=content><pre>pain|pain.deep13.com|Forrester&#39;s machine:\
        :cm=CONNECT pain\n:tc=deep13:
muffin|muffin.deep13.com|Frank&#39;s machine:\
        :cm=CONNECT muffin\n:tc=deep13:
deep13:Gizmonics Institute terminal server:\
        :dv=/dev/cuau2:br#38400:at=hayes:du:pa=none:pn=5551234:</pre></div></div></div><div class=sect3><h4 id=tip-multiline>26.5.7. Usando Mais de Uma Linha com <code>tip</code><a class=anchor href=#tip-multiline></a></h4><div class=paragraph><p>Isto geralmente é um problema em que uma universidade tem várias linhas de modems e vários milhares de estudantes tentando usá-las.</p></div><div class=paragraph><p>Faça uma entrada em <span class=filename>/etc/remote</span> e use <code>@</code> para o recurso <code>pn</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>big-university:\
        :pn=\@:tc=dialout
dialout:\
        :dv=/dev/cuau3:br#9600:at=courier:du:pa=none:</pre></div></div><div class=paragraph><p>Em seguida, liste os números de telefone em <span class=filename>/etc/phones</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>big-university 5551111
big-university 5551112
big-university 5551113
big-university 5551114</pre></div></div><div class=paragraph><p>O <code>tip</code> tentará cada número na ordem listada, depois desistirá. Para continuar tentando, execute o <code>tip</code> em um loop <code>while</code>.</p></div></div><div class=sect3><h4 id=multi-controlp>26.5.8. Usando o Caractere de Force<a class=anchor href=#multi-controlp></a></h4><div class=paragraph><p>O <span class=keyseq><kbd>Ctrl</kbd>+<kbd>P</kbd></span> é o caracter "force" padrão, usado para dizer ao <code>tip</code> que o próximo caractere é um dado literal. O caractere force pode ser definido para qualquer outro caractere com o escape <code>~s</code>, o que significa "definir uma variável."</p></div><div class=paragraph><p>Digite <code>~sforce=<em>single-char</em></code> seguido por uma nova linha. Onde <em>single-char</em> é qualquer caractere único. Se o <em>single-char</em> for omitido, o caractere force será o caractere nulo, que é acessado digitando-se <span class=keyseq><kbd>Ctrl</kbd>+<kbd>2</kbd></span> ou <span class=keyseq><kbd>Ctrl</kbd>+<kbd>Espace</kbd></span>. Um valor muito bom para <em>single-char</em> é o <span class=keyseq><kbd>Shift</kbd>+<kbd>Ctrl</kbd>+<kbd>6</kbd></span>, que é usado apenas em alguns servidores de terminal.</p></div><div class=paragraph><p>Para alterar o caractere force, especifique o seguinte em <span class=filename>~/.tiprc</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>force=single-char</pre></div></div></div><div class=sect3><h4 id=uppercase>26.5.9. Caracteres Maiúsculos<a class=anchor href=#uppercase></a></h4><div class=paragraph><p>Isso acontece quando o <span class=keyseq><kbd>Ctrl</kbd>+<kbd>A</kbd></span> é pressionado, o qual corresponde ao <code>tip</code> "raise character", especialmente concebido para pessoas coma tecla de caps-lock quebrada. Use <code>~s</code> para definir <code>raisechar</code> para algo razoável. Ele pode ser configurado para ser o mesmo que o caractere de force, se nenhum recurso for usado.</p></div><div class=paragraph><p>Aqui está um exemplo do <span class=filename>~/.tiprc</span> para os usuários do Emacs que precisam digitar <span class=keyseq><kbd>Ctrl</kbd>+<kbd>2</kbd></span> e <span class=keyseq><kbd>Ctrl</kbd>+<kbd>A</kbd></span>:</p></div><div class="literalblock programlisting"><div class=content><pre>force=^^
raisechar=^^</pre></div></div><div class=paragraph><p>O <code>^^</code> é <span class=keyseq><kbd>Shift</kbd>+<kbd>Ctrl</kbd>+<kbd>6</kbd></span>.</p></div></div><div class=sect3><h4 id=tip-filetransfer>26.5.10. Transferências de Arquivos com <code>tip</code><a class=anchor href=#tip-filetransfer></a></h4><div class=paragraph><p>Ao falar com outro sistema operacional semelhante ao UNIX™, os arquivos podem ser enviados e recebidos usando <code>~p</code> (put) e <code>~t</code> (take). Esses comandos executam <code>cat</code> e <code>echo</code> no sistema remoto para aceitar e enviar arquivos. A sintaxe é:</p></div><div class=paragraph><p><code>~p</code> local-file [ remote-file ]</p></div><div class=paragraph><p><code>~t</code> remote-file [ local-file ]</p></div><div class=paragraph><p>Não há verificação de erros, então outro protocolo, como zmodem, provavelmente deveria ser usado.</p></div></div><div class=sect3><h4 id=zmodem-tip>26.5.11. Usando o zmodem com o <code>tip</code>?<a class=anchor href=#zmodem-tip></a></h4><div class=paragraph><p>Para receber arquivos, inicie o programa de envio no terminal remoto. Em seguida, digite <code>~C rz</code> para começar a recebê-los localmente.</p></div><div class=paragraph><p>Para enviar arquivos, inicie o programa de recebimento no terminal remoto. Em seguida, digite <code>~C sz <em>files</em></code> para enviá-los ao sistema remoto.</p></div></div></div><div class=sect2><h3 id=serialconsole-setup>26.6. Configurando o Console Serial<a class=anchor href=#serialconsole-setup></a></h3><div class=paragraph><p>O FreeBSD tem a capacidade de inicializar um sistema com um terminal burro em uma porta serial como um console. Esta configuração é útil para administradores de sistemas que desejam instalar o FreeBSD em máquinas que não possuem teclado ou monitor conectados, e desenvolvedores que desejam depurar o kernel ou drivers de dispositivos.</p></div><div class=paragraph><p>Como descrito em <a href=./#boot>O processo de inicialização do FreeBSD</a>, o FreeBSD emprega um bootstrap de três estágios. Os dois primeiros estágios estão no código do bloco de inicialização que é armazenado no início da slice do FreeBSD no disco de inicialização. O bloco de inicialização, em seguida, carrega e executa o carregador de boot como o código do terceiro estágio.</p></div><div class=paragraph><p>Para configurar a inicialização a partir de um console serial, o código do bloco de inicialização, o código do carregador de inicialização e o kernel precisam ser configurados.</p></div><div class=sect3><h4 id=serialconsole-howto-fast>26.6.1. Configuração Rápida do Console Serial<a class=anchor href=#serialconsole-howto-fast></a></h4><div class=paragraph><p>Esta seção fornece uma visão geral rápida da configuração do console serial. Este procedimento pode ser usado quando o terminal burro é conectado ao <span class=filename>COM1</span>.</p></div><div class="exampleblock procedure"><div class=content><div class=paragraph><p><strong>Procedure: Configurando um Console Serial no <span class=filename>COM1</span></strong></p></div><div class="olist arabic"><ol class=arabic><li><p>Conecte o cabo serial ao <span class=filename>COM1</span> e ao terminal de controle.</p></li><li><p>Para configurar mensagens de inicialização para exibição no console serial, emita o seguinte comando como o superusuário:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># echo &#39;console=&#34;comconsole&#34;&#39; &gt;&gt; /boot/loader.conf</span></code></pre></div></div></li><li><p>Edite <span class=filename>/etc/ttys</span> e mude <code>off</code> para <code>on</code> e <code>dialup</code> para <code>vt100</code> para a entrada <span class=filename>ttyu0</span>. Caso contrário, uma senha não será necessária para conectar-se através do console serial, resultando em uma potencial brecha de segurança.</p></li><li><p>Reinicialize o sistema para ver se as alterações entraram em vigor.</p></li></ol></div></div></div><div class=paragraph><p>Se uma configuração diferente for necessária, consulte a próxima seção para obter uma explicação de configuração mais detalhada.</p></div></div><div class=sect3><h4 id=serialconsole-howto>26.6.2. Configuração do console serial em profundidade<a class=anchor href=#serialconsole-howto></a></h4><div class=paragraph><p>Esta seção fornece uma explicação mais detalhada das etapas necessárias para configurar um console serial no FreeBSD.</p></div><div class="exampleblock procedure"><div class=content><div class=paragraph><p><strong>Procedure: Configurando um Console Serial</strong></p></div><div class="olist arabic"><ol class=arabic><li><p>Prepare um cabo serial.</p><div class=paragraph><p>Use um cabo de null-modem ou um cabo serial padrão e um adaptador de null-modem. Veja <a href=#term-cables-null>Cabos Serial e Portas</a> para uma discussão sobre cabos seriais.</p></div></li><li><p>Desconecte o teclado.</p><div class=paragraph><p>Muitos sistemas detectam o teclado durante o Power-On Self-Test (POST) e geram um erro se o teclado não for detectado. Algumas máquinas recusarão a inicialização até que o teclado esteja conectado.</p></div><div class=paragraph><p>Se o computador reclamar do erro, mas inicializar de qualquer maneira, nenhuma outra configuração será necessária.</p></div><div class=paragraph><p>Se o computador se recusar a inicializar sem um teclado conectado, configure o BIOS para que ele ignore este erro. Consulte o manual da placa-mãe para obter detalhes sobre como fazer isso.</p></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Tente configurar o teclado para "Not installed" no BIOS. Esta configuração diz ao BIOS para não detectar um teclado ao ligar, então ele não deve reclamar se o teclado estiver ausente. Se essa opção não estiver presente no BIOS, procure uma opção "Halt on Error". Configurando isto para "All but Keyboard" ou para "No Errors" terá o mesmo efeito.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Se o sistema tiver um mouse PS/2™, desconecte-o também. Os mouses PS/2™ compartilham algum hardware com o teclado e, deixar o mouse conectado, pode enganar o sistema e faze-lo pensar que o teclado ainda está lá.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Embora a maioria dos sistemas inicialize sem um teclado, alguns não inicializarão sem um adaptador gráfico. Alguns sistemas podem ser configurados para inicializar sem nenhum adaptador gráfico alterando a configuração do "graphics adapter" na configuração BIOS para "Not installed". Outros sistemas não suportam esta opção e recusarão a inicialização se não houver hardware de exibição no sistema. Com estas máquinas, deixe algum tipo de placa gráfica ligada, mesmo que seja apenas uma placa mono lixo. Um monitor não precisa ser conectado.</p></div></td></tr></tbody></table></div></li><li><p>Conecte um terminal burro, um computador antigo com um programa de modem ou a porta serial de outra máquina UNIX™ na porta serial da máquina freebsd.</p></li><li><p>Adicione as entradas <code>hint.sio.*</code> apropriadas para o <span class=filename>/boot/device.hints</span> para a porta serial. Algumas placas com várias portas também exigem opções de configuração do kernel. Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=sio&amp;sektion=4&amp;format=html">sio(4)</a> para obter as opções necessárias e os device hints para cada porta serial suportada.</p></li><li><p>Crie o <span class=filename>boot.config</span> no diretório raiz da partição <code>a</code> na unidade de inicialização.</p><div class=paragraph><p>Este arquivo instrui o código do bloco de inicialização como inicializar o sistema. Para ativar o console serial, uma ou mais das seguintes opções são necessárias. Ao usar várias opções, inclua todas elas na mesma linha:</p></div><div class=dlist><dl><dt class=hdlist1><code>-h</code></dt><dd><p>Alterna entre os consoles interno e serial. Use isso para alternar dispositivos do console. Por exemplo, para inicializar a partir do console (vídeo) interno, use <code>-h</code> para direcionar o carregador de boot e o kernel para usar a porta serial como seu dispositivo de console. Alternativamente, para inicializar a partir da porta serial, use <code>-h</code> para dizer ao gerenciador de inicialização e ao kernel para usar a exibição de vídeo como o console.</p></dd><dt class=hdlist1><code>-D</code></dt><dd><p>Alterna entre as configurações de console única e dupla. Na configuração única, o console será o console interno (exibição de vídeo) ou a porta serial, dependendo do estado de <code>-h</code>. Na configuração do console duplo, a exibição de vídeo e a porta serial se tornarão o console ao mesmo tempo, independentemente do estado de <code>-h</code>. No entanto, a configuração do console duplo entrará em vigor somente enquanto o bloco de inicialização estiver em execução. Depois que o gerenciador de boot obtiver controle, o console especificado por <code>-h</code> se tornará o único console.</p></dd><dt class=hdlist1><code>-P</code></dt><dd><p>Faz com que o bloco de inicialização avalie o teclado. Se nenhum teclado for encontrado, as opções <code>-D</code> e <code>-h</code> serão automaticamente definidas.</p><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Devido a restrições de espaço na versão atual dos blocos de inicialização, <code>-P</code> é capaz de detectar somente teclados estendidos. Teclados com menos de 101 teclas e sem as teclas F11 e F12 podem não ser detectados. Teclados em alguns laptops podem não ser encontrados corretamente devido a essa limitação. Se este for o caso, não use <code>-P</code>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Use <code>-P</code> para selecionar o console automaticamente ou <code>-h</code> para ativar o console serial. Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=boot&amp;sektion=8&amp;format=html">boot(8)</a> e <a href="https://man.freebsd.org/cgi/man.cgi?query=boot.config&amp;sektion=5&amp;format=html">boot.config(5)</a> para maiores detalhes.</p></div><div class=paragraph><p>As opções, exceto para <code>-P</code>, são passadas para o carregador de boot. O gerenciador de boot determinará se o vídeo interno ou a porta serial deve se tornar o console examinando o estado de <code>-h</code>. Isto significa que se <code>-D</code> for especificado mas <code>-h</code> não estiver especificado no <span class=filename>/boot.config</span>, a porta serial pode ser usada como console somente durante o bloco de inicialização, pois o gerenciador de inicialização usará a exibição de vídeo interna como o console.</p></div></dd></dl></div></li><li><p>Inicialize a máquina.</p><div class=paragraph><p>Quando o FreeBSD inicia, os blocos de inicialização mostram o conteúdo do <span class=filename>/boot.config</span> para o console. Por exemplo:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>/boot.config: <span class=nt>-P</span>
Keyboard: no</code></pre></div></div><div class=paragraph><p>A segunda linha aparece somente se <code>-P</code> aparecer no <span class=filename>/boot.config</span> e indica a presença ou ausência do teclado. Estas mensagens vão para o console serial ou interno, ou ambos, dependendo da opção em <span class=filename>/boot.config</span>:</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Opções</th><th class="tableblock halign-left valign-top">Mensagem vai para</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>nenhum</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>console interno</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>-h</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>console serial</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>-D</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>consoles seriais e internos</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>-Dh</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>consoles seriais e internos</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>-P</code>, teclado presente</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>console interno</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>-P</code>, teclado ausente</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>console serial</p></td></tr></tbody></table><div class=paragraph><p>Após a mensagem, haverá uma pequena pausa antes que os blocos de inicialização continuem carregando o carregador de boot e antes que qualquer outra mensagem seja impressa no console. Em circunstâncias normais, não há necessidade de interromper os blocos de inicialização, mas pode-se fazê-lo para garantir que as coisas sejam configuradas corretamente.</p></div><div class=paragraph><p>Pressione qualquer tecla, exceto <kbd>Enter</kbd>, no console para interromper o processo de inicialização. Os blocos de inicialização então solicitarão mais ações:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=o>&gt;&gt;</span> FreeBSD/i386 BOOT
Default: 0:ad<span class=o>(</span>0,a<span class=o>)</span>/boot/loader
boot:</code></pre></div></div><div class=paragraph><p>Verifique se a mensagem acima aparece no console serial ou interno, ou em <span class=filename>/boot.config</span>. Se a mensagem aparecer no console correto, pressione <kbd>Enter</kbd> para continuar o processo de inicialização.</p></div><div class=paragraph><p>Se não houver nenhum prompt no terminal serial, algo está errado com as configurações. Digite <code>-h</code> e depois <kbd>Enter</kbd> ou <kbd>Return</kbd> para informar o bloco de inicialização (e depois o carregador de inicialização e o kernel) para escolher a porta serial para o console. Quando o sistema estiver ativo, volte e verifique o que deu errado.</p></div></li></ol></div></div></div><div class=paragraph><p>Durante o terceiro estágio do processo de inicialização, ainda é possível alternar entre o console interno e o console serial definindo as variáveis de ambiente apropriadas no carregador de inicialização. Veja <a href="https://man.freebsd.org/cgi/man.cgi?query=loader&amp;sektion=8&amp;format=html">loader(8)</a> para obter maiores informações.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Esta linha no <span class=filename>/boot/loader.conf</span> ou <span class=filename>/boot/loader.conf.local</span> configura o carregador de inicialização e o kernel para enviar suas mensagens de inicialização para o console serial, independentemente das opções no <span class=filename>/boot.config</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>console=&#34;comconsole&#34;</pre></div></div><div class=paragraph><p>Esta linha deve ser a primeira linha do <span class=filename>/boot/loader.conf</span> para que as mensagens de boot sejam exibidas no console serial o mais cedo possível.</p></div><div class=paragraph><p>Se essa linha não existir, ou se estiver definida como <code>console="vidconsole"</code>, o carregador de inicialização e o kernel usarão qualquer console indicado por <code>-h</code> no bloco de inicialização. Veja <a href="https://man.freebsd.org/cgi/man.cgi?query=loader.conf&amp;sektion=5&amp;format=html">loader.conf(5)</a> para maiores informações.</p></div><div class=paragraph><p>No momento, o carregador de boot não tem nenhuma opção equivalente a <code>-P</code> no bloco de inicialização, e não há provisão para selecionar automaticamente o console interno e o console serial com base na presença do teclado.</p></div></td></tr></tbody></table></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Embora não seja obrigatório, é possível fornecer um prompt <code>login</code> na linha serial. Para configurar isto, edite a entrada para a porta serial em <span class=filename>/etc/ttys</span> usando as instruções em <a href=#term-config>Configuração do Terminal</a>. Se a velocidade da porta serial tiver sido alterada, altere <code>std.9600</code> para corresponder à nova configuração.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=_defina_uma_velocidade_de_porta_serial_mais_rápida>26.6.3. Defina uma velocidade de porta serial mais rápida<a class=anchor href=#_defina_uma_velocidade_de_porta_serial_mais_rápida></a></h4><div class=paragraph><p>Por padrão, as configurações da porta serial são 9600 baud, 8 bits, sem paridade e 1 bit de parada. Para alterar a velocidade do console padrão, use uma das seguintes opções:</p></div><div class=ulist><ul><li><p>Edite o <span class=filename>/etc/make.conf</span> e configure o <code>BOOT_COMCONSOLE_SPEED</code> para a nova velocidade do console. Em seguida, recompile e instale os blocos de inicialização e o carregador de boot:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /sys/boot</span>
<span class=c># make clean</span>
<span class=c># make</span>
<span class=c># make install</span></code></pre></div></div><div class=paragraph><p>Se o console serial estiver configurado de alguma outra maneira que não seja inicializando com <code>-h</code>, ou se o console serial usado pelo kernel for diferente daquele usado pelos blocos de inicialização, adicione a seguinte opção, com a velocidade desejada, em um arquivo de configuração de kernel personalizado e compile um novo kernel:</p></div><div class="literalblock programlisting"><div class=content><pre>options CONSPEED=19200</pre></div></div></li><li><p>Acrescente a opção de inicialização <code>-S_19200_</code> ao <span class=filename>/boot.config</span>, substituindo <em>19200</em> pela velocidade a ser utilizada.</p></li><li><p>Adicione as seguintes opções ao <span class=filename>/boot/loader.conf</span>. Substitua <em>115200</em> pela velocidade de uso.</p><div class="literalblock programlisting"><div class=content><pre>boot_multicons=&#34;YES&#34;
boot_serial=&#34;YES&#34;
comconsole_speed=&#34;115200&#34;
console=&#34;comconsole,vidconsole&#34;</pre></div></div></li></ul></div></div><div class=sect3><h4 id=serialconsole-ddb>26.6.4. Entrando no Depurador DDB da Linha Serial<a class=anchor href=#serialconsole-ddb></a></h4><div class=paragraph><p>Para configurar a capacidade de inserir o depurador de kernel no console serial, inclua as seguintes opções em um arquivo de configuração de kernel personalizado e compile o kernel usando as instruções em <a href=./#kernelconfig>Configurando o kernel do FreeBSD</a>. Observe que, embora isso seja útil para diagnósticos remotos, também é perigoso se um BREAK espúrio for gerado na porta serial. Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=ddb&amp;sektion=4&amp;format=html">ddb(4)</a> e <a href="https://man.freebsd.org/cgi/man.cgi?query=ddb&amp;sektion=8&amp;format=html">ddb(8)</a> para mais informações sobre o depurador do kernel.</p></div><div class="literalblock programlisting"><div class=content><pre>options BREAK_TO_DEBUGGER
options DDB</pre></div></div></div></div></div></div><div class=sect1><h2 id=ppp-and-slip>Capítulo 27. PPP<a class=anchor href=#ppp-and-slip></a></h2><div class=sectionbody><div class=sect2><h3 id=ppp-and-slip-synopsis>27.1. Sinopse<a class=anchor href=#ppp-and-slip-synopsis></a></h3><div class=paragraph><p>O FreeBSD suporta o protocolo Point-to-Point (PPP) que pode ser usado para estabelecer uma conexão de rede ou Internet usando um modem dial-up. Este capítulo descreve como configurar serviços de comunicação baseados em modem no FreeBSD.</p></div><div class=paragraph><p>Depois de ler este capítulo, você saberá:</p></div><div class=ulist><ul><li><p>Como configurar, usar e solucionar problemas de uma conexão PPP.</p></li><li><p>Como configurar o PPP sobre Ethernet (PPPoE).</p></li><li><p>Como configurar o PPP sobre ATM (PPPoA).</p></li></ul></div><div class=paragraph><p>Antes de ler este capítulo, você deve:</p></div><div class=ulist><ul><li><p>Estar familiarizado com a terminologia básica de rede.</p></li><li><p>Entender os conceitos básicos e o propósito de uma conexão dial-up e PPP.</p></li></ul></div></div><div class=sect2><h3 id=userppp>27.2. Configurando o PPP<a class=anchor href=#userppp></a></h3><div class=paragraph><p>O FreeBSD fornece suporte nativo para gerenciamento conexões dial-up PPP usando <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a>. O kernel padrão do FreeBSD fornece suporte para o <span class=filename>tun</span>, que é usado para interagir com um hardware de modem. A configuração é executada editando pelo menos um arquivo de configuração, e exemplos destes arquivos de configuração são fornecidos com o sistema. Finalmente, o <code>ppp</code> é usado para iniciar e gerenciar conexões.</p></div><div class=paragraph><p>Para usar uma conexão PPP, os seguintes itens são necessários:</p></div><div class=ulist><ul><li><p>Uma conta dial-up com um provedor de serviços de Internet (ISP).</p></li><li><p>Um modem dial-up.</p></li><li><p>O número de discagem para o ISP.</p></li><li><p>O nome de usuário e a senha atribuídos pelo ISP.</p></li><li><p>O endereço IP de um ou mais servidores de DNS. Normalmente, o ISP fornece estes endereços. Caso contrário, o FreeBSD pode ser configurado para usar a negociação de DNS.</p></li></ul></div><div class=paragraph><p>Se alguma das informações necessárias estiver faltando, entre em contato com o ISP.</p></div><div class=paragraph><p>As seguintes informações podem ser fornecidas pelo ISP, mas não são necessárias:</p></div><div class=ulist><ul><li><p>O endereço IP do gateway padrão. Se esta informação for desconhecida, o ISP fornecerá automaticamente o valor correto durante a configuração da conexão. Ao configurar o PPP no FreeBSD, este endereço é chamado de <code>HISADDR</code>.</p></li><li><p>A máscara de sub-rede. Se o ISP não tiver fornecido um, <code>255.255.255.255</code> será usado no arquivo de configuração do <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a>.
*</p><div class=paragraph><p>Se o ISP tiver atribuído um endereço IP estático e um nome de host, ele deverá ser inserido no arquivo de configuração. Caso contrário, essas informações serão fornecidas automaticamente durante a configuração da conexão.</p></div></li></ul></div><div class=paragraph><p>O restante desta seção demonstra como configurar o FreeBSD para cenários de conexão PPP comuns. O arquivo de configuração requerido é o <span class=filename>/etc/ppp/ppp.conf</span> e arquivos de exemplos adicionais estão disponíveis em <span class=filename>/usr/shared/examples/ppp/</span>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Ao longo desta seção, muitos dos exemplos de arquivos exibem números de linha. Esses números de linha foram adicionados para facilitar o acompanhamento da discussão e não devem ser colocados no arquivo real.</p></div><div class=paragraph><p>Ao editar um arquivo de configuração, o recuo adequado é importante. Linhas que terminam em um <code>:</code> iniciam na primeira coluna (início da linha) enquanto todas as outras linhas devem ser recuadas como mostrado usando espaços ou tabulações.</p></div></td></tr></tbody></table></div><div class=sect3><h4 id=userppp-staticIP>27.2.1. Configuração básica<a class=anchor href=#userppp-staticIP></a></h4><div class=paragraph><p>Para configurar uma conexão PPP, primeiro edite o <span class=filename>/etc/ppp/ppp.conf</span> com as informações de discagem do ISP. Este arquivo é descrito da seguinte maneira:</p></div><div class="literalblock programlisting"><div class=content><pre>1     default:
2       set log Phase Chat LCP IPCP CCP tun command
3       ident user-ppp VERSION
4       set device /dev/cuau0
5       set speed 115200
6       set dial &#34;ABORT BUSY ABORT NO\\sCARRIER TIMEOUT 5 \
7                 \&#34;\&#34; AT OK-AT-OK ATE1Q0 OK \\dATDT\\T TIMEOUT 40 CONNECT&#34;
8       set timeout 180
9       enable dns
10
11    provider:
12      set phone &#34;(123) 456 7890&#34;
13      set authname foo
14      set authkey bar
15      set timeout 300
16      set ifaddr x.x.x.x/0 y.y.y.y/0 255.255.255.255 0.0.0.0
17      add default HISADDR</pre></div></div><div class=dlist><dl><dt class=hdlist1>Linha 1</dt><dd><p>Identifica a entrada <code>default</code>. Os comandos nesta entrada (linhas 2 a 9) são executados automaticamente quando o <code>ppp</code> é executado.</p></dd><dt class=hdlist1>Linha 2</dt><dd><p>Ativa os parâmetros de log detalhado para testar a conexão. Uma vez que a configuração esteja funcionando satisfatoriamente, esta linha deve ser reduzida para:</p><div class="literalblock programlisting"><div class=content><pre>set log phase tun</pre></div></div></dd><dt class=hdlist1>Linha 3</dt><dd><p>Exibe a versão do <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> para o software PPP em execução no outro lado da conexão.</p></dd><dt class=hdlist1>Linha 4</dt><dd><p>Identifica o dispositivo ao qual o modem está conectado, onde <span class=filename>COM1</span> é <span class=filename>/dev/cuau0</span> e <span class=filename>COM2</span> é <span class=filename>/dev/cuau1</span>.</p></dd><dt class=hdlist1>Linha 5</dt><dd><p>Define a velocidade de conexão. Se <code>115200</code> não funcionar em um modem mais antigo, tente <code>38400</code> em seu lugar.</p></dd><dt class=hdlist1>Linhas 6 & 7</dt><dd><p>A string de discagem escrita como na sintaxe de envio e espera. Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=chat&amp;sektion=8&amp;format=html">chat(8)</a> para obter maiores informações.</p><div class=paragraph><p>Observe que esse comando continua na próxima linha para facilitar a leitura. Qualquer comando no <span class=filename>ppp.conf</span> pode fazer isso se o último caractere na linha for <code>\</code>.</p></div></dd><dt class=hdlist1>Linha 8</dt><dd><p>Define o tempo ocioso limite do link em segundos.</p></dd><dt class=hdlist1>Linha 9</dt><dd><p>Instrui o peer para confirmar as configurações de DNS. Se a rede local estiver executando seu próprio servidor DNS, essa linha deve ser comentada, adicionando um <code>#</code> no início da linha ou removendo-a.</p></dd><dt class=hdlist1>Linha 10</dt><dd><p>Uma linha em branco para facilitar a leitura. Linhas em branco são ignoradas pelo <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a>.</p></dd><dt class=hdlist1>Linha 11</dt><dd><p>Identifica uma entrada chamada <code>provider</code>. Isto pode ser alterado para o nome do ISP, para que <code>load <em>ISP</em></code> possa ser usado para iniciar a conexão.</p></dd><dt class=hdlist1>Linha 12</dt><dd><p>Use o número de telefone para o ISP. Vários números de telefone podem ser especificados usando os dois-pontos (<code>:</code>) ou o caractere pipe (<code>|</code>) como um separador. Para rotacionar entre os números, use dois pontos. Para sempre tentar discar o primeiro número primeiro e usar os outros números apenas se o primeiro número falhar, use o caractere pipe. Sempre coloque todo o conjunto de números de telefone entre aspas (<code>"</code>) para evitar falhas de discagem.</p></dd><dt class=hdlist1>Linhas 13 & 14</dt><dd><p>Use o nome de usuário e senha para o ISP.</p></dd><dt class=hdlist1>Linha 15</dt><dd><p>Define o tempo ocioso limite padrão em segundos para a conexão. Neste exemplo, a conexão será fechada automaticamente após 300 segundos de inatividade. Para evitar um tempo limite, defina esse valor como zero.</p></dd><dt class=hdlist1>Linha 16</dt><dd><p>Define os endereços da interface. Os valores usados dependem de se um endereço IP estático foi obtido do ISP ou se ele negocia um endereço IP dinâmico durante a conexão.</p><div class=paragraph><p>Se o ISP tiver alocado um endereço IP estático e um gateway padrão, substitua <em>xxxx</em> pelo endereço IP estático e substitua <em>yyyy</em> com o endereço IP do gateway padrão. Se o ISP tiver fornecido apenas um endereço IP estático sem um endereço de gateway, substitua <em>yyyy</em> por <code>10.0.0.2/0</code>.</p></div><div class=paragraph><p>Se o endereço IP mudar sempre que uma conexão for feita, altere essa linha para o seguinte valor. Isso diz ao <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a>para usar o IP Configuration Protocol (IPCP) para negociar um endereço IP dinâmico:</p></div><div class="literalblock programlisting"><div class=content><pre>set ifaddr 10.0.0.1/0 10.0.0.2/0 255.255.255.255 0.0.0.0</pre></div></div></dd><dt class=hdlist1>Linha 17</dt><dd><p>Mantenha esta linha como está, pois ela adiciona uma rota padrão ao gateway. O <code>HISADDR</code> será automaticamente substituído pelo endereço do gateway especificado na linha 16. É importante que esta linha apareça depois da linha 16.</p></dd></dl></div><div class=paragraph><p>Dependendo se o <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> for iniciado manualmente ou automaticamente, um arquivo <span class=filename>/etc/ppp/ppp.linkup</span> também pode precisar ser criado, contendo as seguintes linhas. Este arquivo é requerido ao executar o <code>ppp</code> no modo <code>-auto</code>. Este arquivo é usado após a conexão ter sido estabelecida. Neste ponto, o endereço IP será atribuído e agora será possível adicionar as entradas da tabela de roteamento. Ao criar este arquivo, certifique-se de que o <em>provider</em> corresponda ao valor demonstrado na linha 11 do <span class=filename>ppp.conf</span>.</p></div><div class="literalblock programlisting"><div class=content><pre>provider:
      add default HISADDR</pre></div></div><div class=paragraph><p>Este arquivo também é necessário quando o endereço do gateway padrão é "adivinhado" em uma configuração de endereço IP estático. Neste caso, remova a linha 17 do <span class=filename>ppp.conf</span> e crie o <span class=filename>/etc/ppp/ppp.linkup</span> com as duas linhas acima. Outros exemplos para este arquivo podem ser encontrados em <span class=filename>/usr/shared/examples/ppp/</span>.</p></div><div class=paragraph><p>Por padrão, o <code>ppp</code> deve ser executado como <code>root</code>. Para alterar esse padrão, adicione a conta do usuário que deve executar o <code>ppp</code> ao grupo <code>network</code> em <span class=filename>/etc/group</span> .</p></div><div class=paragraph><p>Em seguida, conceda ao usuário acesso a uma ou mais entradas em <span class=filename>/etc/ppp/ppp.conf</span> com <code>allow</code>. Por exemplo, para dar a permissão para os usuários <code>fred</code> e <code>mary</code> somente à entrada <code>provider:</code>, inclua esta linha para a seção <code>provider:</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>allow users fred mary</pre></div></div><div class=paragraph><p>Para fornecer aos usuários especificados acesso a todas as entradas, coloque essa linha na seção <code>default</code>.</p></div></div><div class=sect3><h4 id=_configuração_avançada_2>27.2.2. Configuração Avançada<a class=anchor href=#_configuração_avançada_2></a></h4><div class=paragraph><p>É possível configurar o PPP para fornecer endereços de servidores DNS e NetBIOS sob demanda.</p></div><div class=paragraph><p>Para habilitar estas extensões com o PPP versão 1.x, as seguintes linhas podem ser adicionadas à seção relevante do <span class=filename>/etc/ppp/ppp.conf</span>.</p></div><div class="literalblock programlisting"><div class=content><pre>enable msext
set ns 203.14.100.1 203.14.100.2
set nbns 203.14.100.5</pre></div></div><div class=paragraph><p>E para o PPP versão 2 e acima:</p></div><div class="literalblock programlisting"><div class=content><pre>accept dns
set dns 203.14.100.1 203.14.100.2
set nbns 203.14.100.5</pre></div></div><div class=paragraph><p>Isso informará aos clientes os endereços do servidor de nomes primário e secundário e um host do servidor de nomes NetBIOS.</p></div><div class=paragraph><p>Na versão 2 e acima, se a linha <code>set dns</code> for omitida, o PPP usará os valores encontrados em <span class=filename>/etc/resolv.conf</span>.</p></div><div class=sect4><h5 id=userppp-PAPnCHAP>27.2.2.1. Autenticação PAP e CHAP<a class=anchor href=#userppp-PAPnCHAP></a></h5><div class=paragraph><p>Alguns ISPs configuram seu sistema para que a parte de autenticação da conexão seja feita usando um dos mecanismos de autenticação PAP ou CHAP. Se este for o caso, o ISP não exibirá um prompt <code>login:</code> na conexão, mas começará a falar PPP imediatamente.</p></div><div class=paragraph><p>O PAP é menos seguro que o CHAP, mas a segurança normalmente não é um problema aqui, pois as senhas, embora sejam enviadas como texto simples com o PAP, estão sendo transmitidas apenas por uma linha serial. Não há muito espaço para crackers "escutarem".</p></div><div class=paragraph><p>As seguintes alterações devem ser feitas:</p></div><div class="literalblock programlisting"><div class=content><pre>13      set authname MyUserName
14      set authkey MyPassword
15      set login</pre></div></div><div class=dlist><dl><dt class=hdlist1>Linha 13</dt><dd><p>Esta linha especifica o nome de usuário do PAP/CHAP. Insira o valor correto para <em>MyUserName</em>.</p></dd><dt class=hdlist1>Linha 14</dt><dd><p>Esta linha especifica a senha PAP/CHAP . Insira o valor correto para <em>MyPassword</em>. Você pode querer adicionar uma linha adicional, como:</p><div class="literalblock programlisting"><div class=content><pre>16      accept PAP</pre></div></div><div class=paragraph><p>ou</p></div><div class="literalblock programlisting"><div class=content><pre>16      accept CHAP</pre></div></div><div class=paragraph><p>para tornar óbvio que essa é a intenção, mas o PAP e o CHAP são aceitos por padrão.</p></div></dd><dt class=hdlist1>Linha 15</dt><dd><p>O ISP normalmente não exigirá um login no servidor ao usar o PAP ou o CHAP. Portanto, desabilite a string "set login".</p></dd></dl></div></div><div class=sect4><h5 id=userppp-nat>27.2.2.2. Usando a funcionalidade de conversão de endereços de rede (NAT) do PPP<a class=anchor href=#userppp-nat></a></h5><div class=paragraph><p>O PPP tem a capacidade de usar o NAT interno sem recursos de diverting do kernel. Esta funcionalidade pode ser ativada pela seguinte linha no <span class=filename>/etc/ppp/ppp.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>nat enable yes</pre></div></div><div class=paragraph><p>Como alternativa, o NAT pode ser ativado pela opção de linha de comando <code>-nat</code>. Há também uma opção no <span class=filename>/etc/rc.conf</span> chamada <code>ppp_nat</code>, que é ativada por padrão.</p></div><div class=paragraph><p>Ao usar este recurso, pode ser útil incluir as seguintes opções no <span class=filename>/etc/ppp/ppp.conf</span> para habilitar o encaminhamento de conexões de entrada:</p></div><div class="literalblock programlisting"><div class=content><pre>nat port tcp 10.0.0.2:ftp ftp
nat port tcp 10.0.0.2:http http</pre></div></div><div class=paragraph><p>ou para não confiar em nenhuma conexão de entrada</p></div><div class="literalblock programlisting"><div class=content><pre>nat deny_incoming yes</pre></div></div></div></div><div class=sect3><h4 id=userppp-final>27.2.3. Configuração final do sistema<a class=anchor href=#userppp-final></a></h4><div class=paragraph><p>Embora o <code>ppp</code> agora esteja configurado, algumas edições ainda precisam ser feitas no <span class=filename>/etc/rc.conf</span>.</p></div><div class=paragraph><p>Trabalhando de cima para baixo neste arquivo, certifique-se de que a linha <code>hostname=</code> esteja configurada:</p></div><div class="literalblock programlisting"><div class=content><pre>hostname=&#34;foo.example.com&#34;</pre></div></div><div class=paragraph><p>Se o ISP tiver fornecido um nome de host e um endereço IP estático, use este nome como o nome do host.</p></div><div class=paragraph><p>Procure pela variável <code>network_interfaces</code>. Para configurar o sistema para discar para o ISP sob demanda, certifique-se de que o dispositivo <span class=filename>tun0</span> esteja adicionado à lista, caso contrário, remova-o.</p></div><div class="literalblock programlisting"><div class=content><pre>network_interfaces=&#34;lo0 tun0&#34;
ifconfig_tun0=</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>A variável <code>ifconfig_tun0</code> deve estar vazia, e um arquivo chamado <span class=filename>/etc/start_if.tun0</span> deve ser criado. Este arquivo deve conter a linha:</p></div><div class="literalblock programlisting"><div class=content><pre>ppp -auto mysystem</pre></div></div><div class=paragraph><p>Este script é executado no momento da configuração da rede, iniciando o daemon do ppp no modo automático. Se esta máquina funcionar como um gateway, considere incluir a opção <code>-alias</code>. Consulte a página de manual para maiores detalhes.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Certifique-se de que o programa roteador está configurado para <code>NO</code> com a seguinte linha em <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>router_enable=&#34;NO&#34;</pre></div></div><div class=paragraph><p>É importante que o daemon <code>routed</code> não seja iniciado, pois o <code>routed</code> tende a excluir as entradas da tabela de roteamento padrão criadas pelo <code>ppp</code>.</p></div><div class=paragraph><p>É provavelmente uma boa idéia garantir que a linha <code>sendmail_flags</code> não inclua a opção <code>-q</code>, caso contrário o <code>sendmail</code> tentará fazer uma pesquisa de rede de vez em quando, possivelmente fazendo com que sua máquina disque. Você pode tentar:</p></div><div class="literalblock programlisting"><div class=content><pre>sendmail_flags=&#34;-bd&#34;</pre></div></div><div class=paragraph><p>A desvantagem é que o <code>sendmail</code> é forçado a reexaminar a fila de mensagens sempre que o link ppp subir. Para automatizar isso, inclua <code>!Bg</code> no <span class=filename>ppp.linkup</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>1     provider:
2       delete ALL
3       add 0 0 HISADDR
4       !bg sendmail -bd -q30m</pre></div></div><div class=paragraph><p>Uma alternativa é configurar um "dfilter" para bloquear o tráfego SMTP. Consulte os arquivos de exemplo para maiores detalhes.</p></div></div><div class=sect3><h4 id=_usando_o_ppp>27.2.4. Usando o <code>ppp</code><a class=anchor href=#_usando_o_ppp></a></h4><div class=paragraph><p>Tudo o que resta é reiniciar a máquina. Após a reinicialização, digite:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ppp</span></code></pre></div></div><div class=paragraph><p>e, em seguida, o <code>dial provider</code> para iniciar a sessão PPP ou para configurar o <code>ppp</code> para estabelecer sessões automaticamente quando houver tráfego de saída e o <span class=filename>start_if .tun0</span> não existir, digite:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ppp -auto provider</span></code></pre></div></div><div class=paragraph><p>É possível falar com o programa <code>ppp</code> enquanto ele está sendo executado em segundo plano, mas somente se uma porta de diagnóstico adequada tiver sido configurada. Para fazer isso, adicione a seguinte linha à configuração:</p></div><div class="literalblock programlisting"><div class=content><pre>set server /var/run/ppp-tun%d DiagnosticPassword 0177</pre></div></div><div class=paragraph><p>Isso fará com que o PPP escute no soquete de domínio UNIX™ especificado, solicitando aos clientes a senha especificada antes de permitir o acesso. O <code>%d</code> no nome é substituído pelo número do dispositivo <span class=filename>tun</span> que está em uso.</p></div><div class=paragraph><p>Uma vez que um socket tenha sido configurado, o programa <a href="https://man.freebsd.org/cgi/man.cgi?query=pppctl&amp;sektion=8&amp;format=html">pppctl(8)</a> pode ser usado em scripts que desejam manipular o programa em execução.</p></div></div><div class=sect3><h4 id=userppp-mgetty>27.2.5. Configurando serviços de discagem<a class=anchor href=#userppp-mgetty></a></h4><div class=paragraph><p>A <a href=./#dialup>Serviço Dial-in</a> fornece uma boa descrição sobre como ativar serviços dial-up usando o <a href="https://man.freebsd.org/cgi/man.cgi?query=getty&amp;sektion=8&amp;format=html">getty(8)</a>.</p></div><div class=paragraph><p>Uma alternativa para o <code>getty</code> é o port <a class=package href=https://cgit.freebsd.org/ports/tree/comms/mgetty+sendfax/>comms/mgetty+sendfax</a>), uma versão mais inteligente do <code>getty</code> projetada com as linhas dial-up em mente.</p></div><div class=paragraph><p>As vantagens de usar o <code>mgetty</code> é que ele <em>fala</em> ativamente com os modems, o que significa que se a porta estiver desligada no <span class=filename>/etc/ttys</span> então o modem não irá atender o telefone.</p></div><div class=paragraph><p>Versões posteriores do <code>mgetty</code> (da 0.99beta em diante) também suportam a detecção automática de fluxos PPP, permitindo acesso ao servidor de clientes sem script.</p></div><div class=paragraph><p>Consulte a URL <a href=http://mgetty.greenie.net/doc/mgetty_toc.html>http://mgetty.greenie.net/doc/mgetty_toc.html</a> para maiores informações sobre o <code>mgetty</code>.</p></div><div class=paragraph><p>Por padrão, o port <a class=package href=https://cgit.freebsd.org/ports/tree/comms/mgetty+sendfax/>comms/mgetty+sendfax</a> vem com a opção <code>AUTO_PPP</code> ativada permitindo que o <code>mgetty</code> detecte a fase LCP das conexões PPP e crie automaticamente um shell ppp. No entanto, como a sequência de login/senha padrão não ocorre, é necessário autenticar os usuários usando o PAP ou o CHAP.</p></div><div class=paragraph><p>Esta seção assume que o usuário compilou com sucesso e instalou o port <a class=package href=https://cgit.freebsd.org/ports/tree/comms/mgetty+sendfax/>comms/mgetty+sendfax</a> em seu sistema.</p></div><div class=paragraph><p>Assegure-se de que o <span class=filename>/usr/local/etc/mgetty+sendfax/login.config</span> tenha o seguinte:</p></div><div class="literalblock programlisting"><div class=content><pre>/AutoPPP/ -     - /etc/ppp/ppp-pap-dialup</pre></div></div><div class=paragraph><p>Isto diz ao <code>mgetty</code> para executar o <span class=filename>ppp-pap-dialup</span> para conexões PPP detectadas.</p></div><div class=paragraph><p>Crie um arquivo executável chamado <span class=filename>/etc/ppp/ppp-pap-dialup</span> contendo o seguinte:</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
exec /usr/sbin/ppp -direct pap$IDENT</pre></div></div><div class=paragraph><p>Para cada linha dial-up ativada em <span class=filename>/etc/ttys</span>, crie uma entrada correspondente em <span class=filename>/etc/ppp/ppp.conf</span>. Isso irá coexistir com as definições que criamos acima.</p></div><div class="literalblock programlisting"><div class=content><pre>pap:
  enable pap
  set ifaddr 203.14.100.1 203.14.100.20-203.14.100.40
  enable proxy</pre></div></div><div class=paragraph><p>Cada usuário que fizer login com este método precisará ter um nome de usuário/senha em <span class=filename>/etc/ppp/ppp.secret</span> ou, como alternativa, adicione a seguinte opção para autenticar os usuários via PAP a partir de <span class=filename>/etc/passwd</span>.</p></div><div class="literalblock programlisting"><div class=content><pre>enable passwdauth</pre></div></div><div class=paragraph><p>Para atribuir à alguns usuários um endereço de IP estático , especifique o endereço como o terceiro argumento em <span class=filename>/etc/ppp/ppp.secret</span>. Consulte o <span class=filename>/usr/shared/examples/ppp/ppp.secret.sample</span> para exemplos.</p></div></div></div><div class=sect2><h3 id=ppp-troubleshoot>27.3. Solução de problemas de conexões PPP<a class=anchor href=#ppp-troubleshoot></a></h3><div class=paragraph><p>Esta seção aborda alguns problemas que podem surgir ao usar PPP em uma conexão de modem. Alguns ISPs apresentam o prompt <code>ssword</code> enquanto outros apresentam <code>password</code>. Se o script <code>ppp</code> não for escrito de acordo, a tentativa de login falhará. A maneira mais comum de depurar as conexões <code>ppp</code> é conectando manualmente conforme descrito nesta seção.</p></div><div class=sect3><h4 id=_verifique_os_device_nodes>27.3.1. Verifique os Device Nodes<a class=anchor href=#_verifique_os_device_nodes></a></h4><div class=paragraph><p>Ao usar um kernel personalizado, certifique-se de incluir a seguinte linha no arquivo de configuração do kernel:</p></div><div class="literalblock programlisting"><div class=content><pre>device   uart</pre></div></div><div class=paragraph><p>O dispositivo <span class=filename>uart</span> já está incluído no kernel <code>GENERIC</code>, portanto, nenhuma etapa adicional é necessária neste caso. Basta verificar a saída do <code>dmesg</code> para o dispositivo do modem com:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dmesg | grep uart</span></code></pre></div></div><div class=paragraph><p>Isso deve exibir alguma saída pertinente sobre os dispositivos <span class=filename>uart</span>. Estas são as portas COM que precisamos. Se o modem funcionar como uma porta serial padrão, ele deve estar listado em <span class=filename>uart1</span> ou <span class=filename>COM2</span>. Nesse caso, uma recompilação do kernel não é necessária. Ao fazer a verificação, se o modem estiver em <span class=filename>uart1</span>, o dispositivo do modem será <span class=filename>/dev/cuau1</span>.</p></div></div><div class=sect3><h4 id=_conectando_manualmente>27.3.2. Conectando Manualmente<a class=anchor href=#_conectando_manualmente></a></h4><div class=paragraph><p>Conectar-se à Internet controlando manualmente o <code>ppp</code> é rápido, fácil e uma ótima maneira de depurar uma conexão ou simplesmente obter informações sobre como o ISP trata as conexões <code>ppp</code> do cliente. Vamos iniciar o PPP na linha de comando. Note que em todos os nossos exemplos nós usaremos <em>example</em> como o nome do host da máquina rodando o PPP. Para iniciar o <code>ppp</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ppp</span></code></pre></div></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>ppp ON example&gt; <span class=nb>set </span>device /dev/cuau1</code></pre></div></div><div class=paragraph><p>Este segundo comando define o dispositivo do modem como <span class=filename>cuau1</span>.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>ppp ON example&gt; <span class=nb>set </span>speed 115200</code></pre></div></div><div class=paragraph><p>Isso define a velocidade de conexão para 115.200 kbps.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>ppp ON example&gt; <span class=nb>enable </span>dns</code></pre></div></div><div class=paragraph><p>Isto diz ao <code>ppp</code> para configurar o resolver e adicionar as linhas do servidor de nomes ao <span class=filename>/etc/resolv.conf</span>. Se o <code>ppp</code> não puder determinar o nome do host, ele poderá ser configurado manualmente mais tarde.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>ppp ON example&gt; term</code></pre></div></div><div class=paragraph><p>Isso alterna para o modo de "terminal" para controlar manualmente o modem.</p></div><div class="literalblock programlisting"><div class=content><pre>deflink: Entering terminal mode on /dev/cuau1
type &#39;~h&#39; for help</pre></div></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> at
OK
 atdt123456789</code></pre></div></div><div class=paragraph><p>Use o comando <code>at</code> para inicializar o modem, então use o comando <code>atdt</code> e o número o ISP para iniciar o processo de discagem.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>CONNECT</code></pre></div></div><div class=paragraph><p>Confirmação da conexão, se tivermos problemas de conexão, não relacionados ao hardware, aqui é onde tentaremos resolvê-los.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>ISP Login:myusername</code></pre></div></div><div class=paragraph><p>Nesse prompt, responda com o nome de usuário fornecido pelo ISP.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>ISP Pass:mypassword</code></pre></div></div><div class=paragraph><p>Nesse prompt, responda com a senha fornecida pelo ISP. Assim como ocorre ao se logar no FreeBSD, a senha não será exibida quando você a digitar.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Shell or PPP:ppp</code></pre></div></div><div class=paragraph><p>Dependendo do ISP, este aviso pode não aparecer. Em caso afirmativo, ele está perguntando se deve usar um shell no provedor ou iniciar o <code>ppp</code>. Neste exemplo, o <code>ppp</code> foi selecionado para estabelecer uma conexão com a Internet.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Ppp ON example&gt;</code></pre></div></div><div class=paragraph><p>Observe que neste exemplo o primeiro <code>p</code> foi capitalizado. Isso mostra que nós nos conectamos com sucesso ao ISP.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>PPp ON example&gt;</code></pre></div></div><div class=paragraph><p>Nós nos autenticamos com sucesso com nosso ISP e estamos aguardando que o endereço IP seja atribuído.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>PPP ON example&gt;</code></pre></div></div><div class=paragraph><p>Fizemos a negociação de um endereço IP e concluímos nossa conexão com êxito.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>PPP ON example&gt;add default HISADDR</code></pre></div></div><div class=paragraph><p>Aqui nós adicionamos nossa rota padrão, precisamos fazer isso antes de podermos conversar com o mundo externo, já que atualmente a única conexão estabelecida é com o peer. Se isso falhar devido a rotas existentes, coloque o caractere <code>!</code> na frente do <code>add</code>. Alternativamente, defina isso antes de fazer a conexão real e ele negociará uma nova rota de acordo.</p></div><div class=paragraph><p>Se tudo correu bem, agora deveríamos ter uma conexão ativa com a Internet, que poderia ser colocada em segundo plano usando <span class=keyseq><kbd>CTRL</kbd>+<kbd>z</kbd></span> Se o <code>PPP</code> retornar para <code>ppp</code>, a conexão será perdida. É bom saber isso porque mostra o status da conexão. Os P maiúsculos representam uma conexão com o ISP e os p minúsculos mostram que a conexão foi perdida.</p></div></div><div class=sect3><h4 id=_depuração>27.3.3. Depuração<a class=anchor href=#_depuração></a></h4><div class=paragraph><p>Se uma conexão não puder ser estabelecida, desligue o fluxo de hardware CTS/RTS usando <code>set ctsrts off</code>. Normalmente este é o problema quando nos conectamos há alguns servidores de terminal com PPP, onde o PPP trava quando tenta gravar dados no link de comunicação e aguarda um Clear To Send (CTS), sinal que pode nunca vir. Ao usar esta opção, inclua <code>set accmap</code>, pois isso pode ser necessário para evitar que o hardware dependa de passar certos caracteres de ponta a ponta, na maioria das vezes XON/XOFF. Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> para obter maiores informações sobre essa opção e como ela é usada.</p></div><div class=paragraph><p>Um modem mais antigo pode precisar de <code>set parity even</code>. A paridade é definida como none por padrão, mas é usada para verificação de erros com um grande aumento no tráfego, em modems mais antigos.</p></div><div class=paragraph><p>O PPP pode não retornar ao modo de comando, que geralmente é um erro de negociação em que o ISP está aguardando a negociação começar. Neste ponto, usando <code>~p</code> forçará o ppp a começar a enviar as informações de configuração.</p></div><div class=paragraph><p>Se um prompt de login nunca aparecer, a autenticação PAP ou CHAP provavelmente será necessária. Para usar PAP ou CHAP, adicione as seguintes opções ao PPP antes de entrar no modo terminal:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>ppp ON example&gt; <span class=nb>set </span>authname myusername</code></pre></div></div><div class=paragraph><p>Onde <em>myusername</em> deve ser substituído pelo nome de usuário que foi atribuído pelo ISP.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>ppp ON example&gt; <span class=nb>set </span>authkey mypassword</code></pre></div></div><div class=paragraph><p>Onde <em>mypassword</em> deve ser substituído pela senha que foi atribuída pelo ISP.</p></div><div class=paragraph><p>Se uma conexão for estabelecida, mas não conseguir encontrar nenhum nome de domínio, tente utilizar o <a href="https://man.freebsd.org/cgi/man.cgi?query=ping&amp;sektion=8&amp;format=html">ping(8)</a> em um endereço IP. Se houver 100 por cento (100%) de perda de pacotes, é provável que uma rota padrão não tenha sido atribuída. Verifique novamente se <code>add default HISADDR</code> foi definido durante a conexão. Se uma conexão puder ser feita para um endereço IP remoto, é possível que um endereço de resolvedor não tenha sido adicionado ao <span class=filename>/etc/resolv.conf</span>. Este arquivo deve se parecer com:</p></div><div class="literalblock programlisting"><div class=content><pre>domain example.com
nameserver x.x.x.x
nameserver y.y.y.y</pre></div></div><div class=paragraph><p>Onde <em>x.x.x.x</em> e <em>y.y.y.y</em> deve ser substituído pelo endereço IP dos servidores DNS do ISP.</p></div><div class=paragraph><p>Para configurar <a href="https://man.freebsd.org/cgi/man.cgi?query=syslog&amp;sektion=3&amp;format=html">syslog(3)</a> para fornecer o registro para a conexão PPP, verifique se essa linha existe no <span class=filename>/etc/syslog.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>!ppp
*.*     /var/log/ppp.log</pre></div></div></div></div><div class=sect2><h3 id=pppoe>27.4. Usando o PPP sobre Ethernet (PPPoE)<a class=anchor href=#pppoe></a></h3><div class=paragraph><p>Esta seção descreve como configurar o PPP sobre Ethernet (PPPoE).</p></div><div class=paragraph><p>Aqui está um exemplo de <span class=filename>ppp.conf</span> funcional:</p></div><div class="literalblock programlisting"><div class=content><pre>default:
  set log Phase tun command # you can add more detailed logging if you wish
  set ifaddr 10.0.0.1/0 10.0.0.2/0

name_of_service_provider:
  set device PPPoE:xl1 # replace xl1 with your Ethernet device
  set authname YOURLOGINNAME
  set authkey YOURPASSWORD
  set dial
  set login
  add default HISADDR</pre></div></div><div class=paragraph><p>Como <code>root</code>, execute:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ppp -ddial name_of_service_provider</span></code></pre></div></div><div class=paragraph><p>Adicione o seguinte ao <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>ppp_enable=&#34;YES&#34;
ppp_mode=&#34;ddial&#34;
ppp_nat=&#34;YES&#34;	# if you want to enable nat for your local network, otherwise NO
ppp_profile=&#34;name_of_service_provider&#34;</pre></div></div><div class=sect3><h4 id=_usando_um_nome_de_perfil_pppoe>27.4.1. Usando um nome de perfil PPPoE<a class=anchor href=#_usando_um_nome_de_perfil_pppoe></a></h4><div class=paragraph><p>Às vezes, será necessário usar nome de perfil para estabelecer a conexão. Nomes de perfil são usados para distinguir entre diferentes servidores PPPoE conectados a uma determinada rede.</p></div><div class=paragraph><p>Qualquer informação do nome do perfil necessário deve estar na documentação fornecida pelo ISP.</p></div><div class=paragraph><p>Como último recurso, pode-se tentar instalar o pacote ou port <a class=package href=https://cgit.freebsd.org/ports/tree/net/rr-pppoe/>net/rr-pppoe</a>. Lembre-se, no entanto, que isso pode desprogramar o seu modem e torná-lo inútil, então pense duas vezes antes de fazê-lo. Basta instalar o programa enviado com o modem. Em seguida, acesse o menu <b class=menuref>System</b> do programa. O nome do perfil deve estar listado lá. Geralmente é <em>ISP</em>.</p></div><div class=paragraph><p>O nome do perfil (service tag) será usado na entrada de configuração PPPoE em <span class=filename>ppp.conf</span> como a parte do provedor para o <code>set device</code>. Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> para detalhes completos. Deve ficar assim:</p></div><div class="literalblock programlisting"><div class=content><pre>set device PPPoE:xl1:ISP</pre></div></div><div class=paragraph><p>Não se esqueça de alterar o <em>xl1</em> para o dispositivo adequado para a placa Ethernet.</p></div><div class=paragraph><p>Não se esqueça de alterar o <em>ISP</em> para o nome de perfil.</p></div><div class=paragraph><p>Para informações adicionais, consulte <a href=http://web.archive.org/web/20130907043447/http://renaud.waldura.com:80/doc/freebsd/pppoe/>Banda larga mais barata com o FreeBSD em DSL</a> por Renaud Waldura.</p></div></div><div class=sect3><h4 id=ppp-3com>27.4.2. PPPoE com um 3Com™HomeConnect™ ADSL Modem Dual Link<a class=anchor href=#ppp-3com></a></h4><div class=paragraph><p>Este modem não segue a especificação PPPoE definida em <a href=http://www.faqs.org/rfcs/rfc2516.html>RFC 2516</a>.</p></div><div class=paragraph><p>Para tornar o FreeBSD capaz de se comunicar com este dispositivo, um sysctl deve ser configurado. Isso pode ser feito automaticamente no momento da inicialização, atualizando o <span class=filename>/etc/sysctl.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>net.graph.nonstandard_pppoe=1</pre></div></div><div class=paragraph><p>ou pode ser feito imediatamente com o comando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl net.graph.nonstandard_pppoe=1</span></code></pre></div></div><div class=paragraph><p>Infelizmente, como essa é uma configuração valida para todo o sistema, não é possível falar com um cliente ou servidor PPPoE normal e um 3Com™HomeConnect™ Modem ADSL ao mesmo tempo.</p></div></div></div><div class=sect2><h3 id=pppoa>27.5. Usando PPP sobre ATM (PPPoA)<a class=anchor href=#pppoa></a></h3><div class=paragraph><p>Esta sessão descreve como configurar o PPP sobre ATM (PPPoA). O PPPoA é uma escolha popular entre os provedores europeus de DSL.</p></div><div class=sect3><h4 id=_usando_o_mpd>27.5.1. Usando o mpd<a class=anchor href=#_usando_o_mpd></a></h4><div class=paragraph><p>O aplicativo mpd pode ser usado para conectar-se a uma variedade de serviços, em particular serviços PPTP. Ele pode ser instalado usando o pacote ou port <a class=package href=https://cgit.freebsd.org/ports/tree/net/mpd5/>net/mpd5</a>. Muitos modems ADSL exigem que um túnel PPTP seja criado entre o modem e o computador.</p></div><div class=paragraph><p>Uma vez instalado, configure o mpd para adequar-se às configurações do provedor. O port coloca um conjunto de arquivos de configuração de exemplos os quais são bem documentados em <span class=filename>/usr/local/etc/mpd/</span>. Um guia completo para configurar o mpd está disponível no formato HTML em <span class=filename>/usr/ports/shared/doc/mpd/</span>. Aqui está uma configuração de exemplo para conectar-se a um serviço ADSL com o mpd. A configuração está espalhada em dois arquivos, primeiro o <span class=filename>mpd.conf</span>:</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Este exemplo de <span class=filename>mpd.conf</span> só funciona com o mpd 4.x.</p></div></td></tr></tbody></table></div><div class="literalblock programlisting"><div class=content><pre>default:
    load adsl

adsl:
    new -i ng0 adsl adsl
    set bundle authname username <i class=conum data-value=1></i><b>(1)</b>
    set bundle password password <i class=conum data-value=2></i><b>(2)</b>
    set bundle disable multilink

    set link no pap acfcomp protocomp
    set link disable chap
    set link accept chap
    set link keep-alive 30 10

    set ipcp no vjcomp
    set ipcp ranges 0.0.0.0/0 0.0.0.0/0

    set iface route default
    set iface disable on-demand
    set iface enable proxy-arp
    set iface idle 0

    open</pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>O nome de usuário usado para autenticar com seu ISP.</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td>A senha usada para autenticar com seu ISP.</td></tr></tbody></table></div><div class=paragraph><p>Informações sobre o link, ou links, a estabelecer são encontradas em <span class=filename>mpd.links</span>. Um exemplo do <span class=filename>mpd.links</span> para acompanhar o exemplo acima é dado abaixo:</p></div><div class="literalblock programlisting"><div class=content><pre>adsl:
    set link type pptp
    set pptp mode active
    set pptp enable originate outcall
    set pptp self 10.0.0.1 <i class=conum data-value=1></i><b>(1)</b>
    set pptp peer 10.0.0.138 <i class=conum data-value=2></i><b>(2)</b></pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>O endereço IP do computador FreeBSD executando o mpd.</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td>O endereço IP do modem ADSL. O padrão do Alcatel SpeedTouch™ padrão é <code>10.0.0.138</code>.</td></tr></tbody></table></div><div class=paragraph><p>É possível inicializar a conexão facilmente, emitindo o seguinte comando como <code>root</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mpd -b adsl</span></code></pre></div></div><div class=paragraph><p>Para ver o status da conexão:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ifconfig ng0
ng0: <span class=nv>flags</span><span class=o>=</span>88d1&lt;UP,POINTOPOINT,RUNNING,NOARP,SIMPLEX,MULTICAST&gt; mtu 1500
     inet 216.136.204.117 <span class=nt>--</span><span class=o>&gt;</span> 204.152.186.171 netmask 0xffffffff</code></pre></div></div><div class=paragraph><p>Usar o mpd é a maneira recomendada de se conectar a um serviço ADSL com o FreeBSD.</p></div></div><div class=sect3><h4 id=_usando_o_pptpclient>27.5.2. Usando o pptpclient<a class=anchor href=#_usando_o_pptpclient></a></h4><div class=paragraph><p>Também é possível usar o FreeBSD para conectar-se a outros serviços PPPoA usando o <a class=package href=https://cgit.freebsd.org/ports/tree/net/pptpclient/>net/pptpclient</a>.</p></div><div class=paragraph><p>Para usar o <a class=package href=https://cgit.freebsd.org/ports/tree/net/pptpclient/>net/pptpclient</a> para conectar-se a um serviço DSL, instale o port ou o pacote e edite o <span class=filename>/etc/ppp/ppp.conf</span>. Uma seção de exemplo do <span class=filename>ppp.conf</span> é dada abaixo. Para maiores informações sobre as opções do <span class=filename>ppp.conf</span> consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a>.</p></div><div class="literalblock programlisting"><div class=content><pre>adsl:
 set log phase chat lcp ipcp ccp tun command
 set timeout 0
 enable dns
 set authname username <i class=conum data-value=1></i><b>(1)</b>
 set authkey password <i class=conum data-value=2></i><b>(2)</b>
 set ifaddr 0 0
 add default HISADDR</pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>O nome de usuário no provedor de DSL.</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td>A senha da sua conta.</td></tr></tbody></table></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Como a senha da conta é adicionada ao <span class=filename>ppp.conf</span> em forma de texto simples, certifique-se de que ninguém possa ler o conteúdo deste arquivo:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># chown root:wheel /etc/ppp/ppp.conf</span>
<span class=c># chmod 600 /etc/ppp/ppp.conf</span></code></pre></div></div></td></tr></tbody></table></div><div class=paragraph><p>Isso abrirá um túnel para uma sessão PPP para o roteador DSL. Os modems Ethernet DSL têm um endereço IP LAN pré-configurado para conexão. No caso do Alcatel SpeedTouch™ Home, este endereço é <code>10.0.0.138</code>. A documentação do roteador deve listar o endereço que o dispositivo usa. Para abrir o túnel e iniciar uma sessão PPP:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pptp address adsl</span></code></pre></div></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Se um E comercial ("&") for adicionado ao final desse comando, o pptp retornará ao prompt.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Um dispositivo de túnel virtual <span class=filename>tun</span> será criado para interação entre os processos do pptp e do ppp. Quando o prompt for retornado ou o processo do pptp confirmar uma conexão, examine o túnel:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ifconfig tun0
tun0: <span class=nv>flags</span><span class=o>=</span>8051&lt;UP,POINTOPOINT,RUNNING,MULTICAST&gt; mtu 1500
        inet 216.136.204.21 <span class=nt>--</span><span class=o>&gt;</span> 204.152.186.171 netmask 0xffffff00
	Opened by PID 918</code></pre></div></div><div class=paragraph><p>Se a conexão falhar, verifique a configuração do roteador, que geralmente é acessível usando um navegador da web. Além disso, examine a saída do <code>pptp</code> e o conteúdo do arquivo de log <span class=filename>/var/log/ppp.log</span> para pistas.</p></div></div></div></div></div><div class=sect1><h2 id=mail>Capítulo 28. Correio Eletrônico<a class=anchor href=#mail></a></h2><div class=sectionbody><div class=sect2><h3 id=mail-synopsis>28.1. Sinopse<a class=anchor href=#mail-synopsis></a></h3><div class=paragraph><p>O "Electronic Mail", mais conhecido como email, é uma das formas de comunicação mais utilizadas atualmente. Este capítulo fornece uma introdução básica à execução de um servidor de email no FreeBSD, bem como uma introdução ao envio e recebimento de email usando o FreeBSD. Para uma cobertura mais completa deste assunto, consulte os livros listados em <a href=./#bibliography>Bibliografia</a>.</p></div><div class=paragraph><p>Depois de ler este capítulo, você saberá:</p></div><div class=ulist><ul><li><p>Quais softwares estão envolvidos no envio e recebimento de mensagens de email.</p></li><li><p>Onde os arquivos básicos de configuração do Sendmail estão localizados no FreeBSD.</p></li><li><p>A diferença entre caixas de correio remotas e locais.</p></li><li><p>Como bloquear spammers de utilizar ilegalmente um servidor de email como relay.</p></li><li><p>Como instalar e configurar um Mail Transfer Agent, substituindo o Sendmail.</p></li><li><p>Como solucionar problemas comuns de servidor de email.</p></li><li><p>Como configurar o sistema para apenas enviar email.</p></li><li><p>Como usar email com uma conexão discada.</p></li><li><p>Como configurar a autenticação SMTP para segurança adicional.</p></li><li><p>Como instalar e usar um Mail User Agent, como o mutt, para enviar e receber email.</p></li><li><p>Como baixar emails de um servidor remoto utilizando POP ou IMAP.</p></li><li><p>Como aplicar automaticamente filtros e regras ao email recebido.</p></li></ul></div><div class=paragraph><p>Antes de ler este capítulo, você deve:</p></div><div class=ulist><ul><li><p>Configurar corretamente uma conexão de rede (<a href=./#advanced-networking>Rede Avançada</a>).</p></li><li><p>Configure corretamente as informações de DNS para um host de email (<a href=./#network-servers>Servidores de Rede</a>).</p></li><li><p>Saber como instalar software adicional de terceiros (<a href=./#ports>Instalando Aplicativos. Pacotes e Ports</a>).</p></li></ul></div></div><div class=sect2><h3 id=mail-using>28.2. Componentes de Email<a class=anchor href=#mail-using></a></h3><div class=paragraph><p>Há cinco partes principais envolvidas em uma troca de email: o Mail User Agent (MUA), o Mail Transfer Agent (MTA), um host de email, uma caixa de correio remota ou local e DNS. Esta seção fornece uma visão geral desses componentes.</p></div><div class=dlist><dl><dt class=hdlist1>Mail User Agent (MUA)</dt><dd><p>O Mail User Agent (MUA) é um aplicativo que é usado para redigir, enviar e receber emails. Este aplicativo pode ser um programa de linha de comando, como o utilitário <code>mail</code> interno ou um aplicativo de terceiros da Coleção de Ports, como mutt, alpine ou elm. Dezenas de programas gráficos também estão disponíveis na Coleção de Ports, incluindo o Claws Mail, Evolution e Thunderbird. Algumas organizações fornecem um programa web de email que pode ser acessado por meio de um navegador. Mais informações sobre como instalar e usar um MUA no FreeBSD podem ser encontradas em <a href=#mail-agents>Mail User Agents</a>.</p></dd><dt class=hdlist1>Mail Transfer Agent (MTA)</dt><dd><p>O Mail Transfer Agent (MTA) é responsável por receber emails de entrada e entregar emails de saída. O FreeBSD vem com o Sendmail como o MTA padrão, mas também suporta vários outros daemons de servidor de email, incluindo Exim, Postfix e qmail. A configuração do Sendmail é descrita em <a href=#sendmail>Arquivos de Configuração do Sendmail</a>. Se outro MTA estiver instalado usando a Coleção de Ports, consulte sua mensagem de pós-instalação para detalhes de configuração específicos do FreeBSD e o site do aplicativo para obter instruções de configuração mais completas.</p></dd><dt class=hdlist1>Servidor de Email e Caixas de Correio</dt><dd><p>O servidor de email é um servidor responsável por entregar e receber emails para um host ou uma rede. O servidor de email coleta todas as mensagens enviadas para o domínio e as armazena no <span class=filename>mbox</span> padrão ou no formato alternativo Maildir, dependendo da configuração. Uma vez que o email foi armazenado, ele pode ser lido localmente usando um MUA ou acessado e coletado remotamente usando protocolos como POP ou IMAP. Se o email for lido localmente, não é necessário instalar um servidor POP ou IMAP.</p><div class=paragraph><p>Para acessar as caixas de email remotamente, é necessário um servidor POP ou IMAP, pois esses protocolos permitem que os usuários se conectem a suas caixas de correio de locais remotos. O IMAP oferece várias vantagens sobre o POP. Isso inclui a capacidade de armazenar uma cópia de mensagens em um servidor remoto após o download e atualizações simultâneas. O IMAP pode ser útil em links de baixa velocidade, pois permite aos usuários buscar a estrutura das mensagens sem baixá-las. Ele também pode executar tarefas como pesquisas no servidor para minimizar a transferência de dados entre clientes e servidores.</p></div><div class=paragraph><p>Vários servidores POP e IMAP estão disponíveis na Coleção de Ports. Estes incluem o <a class=package href=https://cgit.freebsd.org/ports/tree/mail/qpopper/>mail/qpopper</a>, <a class=package href=https://cgit.freebsd.org/ports/tree/mail/imap-uw/>mail/imap-uw</a>, <a class=package href=https://cgit.freebsd.org/ports/tree/mail/courier-imap/>mail/courier-imap</a> e <a class=package href=https://cgit.freebsd.org/ports/tree/mail/dovecot2/>mail/dovecot2</a> .</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Deve-se notar que o POP e o IMAP transmitem informações, incluindo nome de usuário e senha, em texto não criptografado. Para garantir a segurança na transmissão de informações entre esses protocolos, considere a utilização de túneis seguros com <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh&amp;sektion=1&amp;format=html">ssh(1)</a> (<a href=./#security-ssh-tunneling>Tunelamento SSH</a>) ou utilize SSL (<a href=./#openssl>OpenSSL</a>).</p></div></td></tr></tbody></table></div></dd><dt class=hdlist1>Sistema de Nomes de Domínio (DNS)</dt><dd><p>O Sistema de Nomes de Domínio (DNS) e seu daemon <code>named</code> desempenham um grande papel na entrega de email. Para enviar emails de um site para outro, o MTA procurará o site remoto por DNS para determinar qual host receberá os emails para o destino. Esse processo também ocorre quando o email é enviado de um host remoto para o MTA.</p><div class=paragraph><p>Além de mapear nomes de hosts para endereços de IP, o DNS é responsável por armazenar informações específicas da entrega de emails, conhecidas como Mail eXchanger MX. O registro MX especifica quais hosts receberão mensagens de um domínio em particular.</p></div><div class=paragraph><p>Para visualizar os registros MX de um domínio, especifique o tipo de registro. Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=host&amp;sektion=1&amp;format=html">host(1)</a>, para mais detalhes sobre este comando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% host <span class=nt>-t</span> mx FreeBSD.org
FreeBSD.org mail is handled by 10 mx1.FreeBSD.org</code></pre></div></div><div class=paragraph><p>Consulte <a href=./#network-dns>Sistema de Nomes de Domínio (DNS)</a> para mais informações sobre DNS e sua configuração.</p></div></dd></dl></div></div><div class=sect2><h3 id=sendmail>28.3. Arquivos de Configuração do Sendmail<a class=anchor href=#sendmail></a></h3><div class=paragraph><p>Sendmail é o MTA padrão instalado com o FreeBSD. Ele aceita emails de MUAs e os entrega ao host de email apropriado, conforme definido por sua configuração. O Sendmail também pode aceitar conexões de rede e enviar mensagens para caixas de correio locais ou para outro programa.</p></div><div class=paragraph><p>Os arquivos de configuração do Sendmail estão localizados em <span class=filename>/etc/mail</span>. Esta seção descreve esses arquivos em mais detalhes.</p></div><div class=dlist><dl><dt class=hdlist1><span class=filename>/etc/mail/access</span></dt><dd><p>Este arquivo de acesso define quais hosts ou endereços de IP têm acesso ao servidor de email local e que tipo de acesso eles possuem. Os hosts listados como <code>OK</code>, que é a opção padrão, têm permissão para enviar emails para esse host, desde que o destino final do email seja a máquina local. Os hosts listados como <code>REJECT</code> são rejeitados para todas as conexões de email. Os hosts listados como <code>RELAY</code> têm permissão para enviar emails para qualquer destino usando este servidor de email. Os hosts listados como <code>ERROR</code> terão seus emails retornados com o erro de email especificado. Se um host estiver listado como <code>SKIP</code>, o Sendmail interromperá a pesquisa atual por esta entrada sem aceitar ou rejeitar o email. Os hosts listados como <code>QUARANTINE</code> terão suas mensagens retidas e receberão o texto especificado como o motivo da retenção.</p><div class=paragraph><p>Exemplos de uso destas opções para endereços IPv4 e IPv6 podem ser encontrados na configuração de exemplo do FreeBSD, <span class=filename>/etc/mail/access.sample</span>:</p></div><div class="literalblock programlisting"><div class=content><pre># $FreeBSD: head/pt_BR.ISO8859-1/books/handbook/book.xml 53984 2020-03-15 16:03:31Z dbaio $
#
# Mail relay access control list.  Default is to reject mail unless the
# destination is local, or listed in /etc/mail/local-host-names
#
## Examples (commented out for safety)
#From:cyberspammer.com          ERROR:&#34;550 We don&#39;t accept mail from spammers&#34;
#From:okay.cyberspammer.com     OK
#Connect:sendmail.org           RELAY
#To:sendmail.org                RELAY
#Connect:128.32                 RELAY
#Connect:128.32.2               SKIP
#Connect:IPv6:1:2:3:4:5:6:7     RELAY
#Connect:suspicious.example.com QUARANTINE:Mail from suspicious host
#Connect:[127.0.0.3]            OK
#Connect:[IPv6:1:2:3:4:5:6:7:8] OK</pre></div></div><div class=paragraph><p>Para configurar o arquivo de acesso, use o formato mostrado no exemplo para adicionar entradas em <span class=filename>/etc/mail/access</span>, mas não coloque um símbolo de comentário (<code>#</code>) na frente das entradas. Crie uma entrada para cada host ou rede cujo acesso deve ser configurado. Os remetentes de email que correspondem ao lado esquerdo da tabela são afetados pela ação no lado direito da tabela.</p></div><div class=paragraph><p>Sempre que este arquivo for atualizado, atualize seu banco de dados e reinicie o Sendmail:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># makemap hash /etc/mail/access &lt; /etc/mail/access</span>
<span class=c># service sendmail restart</span></code></pre></div></div></dd><dt class=hdlist1><span class=filename>/etc/mail/aliases</span></dt><dd><p>Este arquivo aliases contém uma lista de caixas de correio virtuais que são expandidas para usuários, arquivos, programas ou outros aliases. Aqui estão algumas entradas para ilustrar o formato do arquivo:</p><div class="literalblock programlisting"><div class=content><pre>root: localuser
ftp-bugs: joe,eric,paul
bit.bucket:  /dev/null
procmail: &#34;|/usr/local/bin/procmail&#34;</pre></div></div><div class=paragraph><p>O nome da caixa de correio no lado esquerdo dos dois pontos é expandido para o(s) alvo(s) à direita. A primeira entrada expande a caixa de correio <code>root</code> para a caixa de correio <code>localuser</code>, que é então pesquisada no <span class=filename>/etc/mail/aliases</span>. Se nenhuma correspondência for encontrada, a mensagem será entregue para <code>localuser</code>. A segunda entrada mostra uma lista de email. Um email para <code>ftp-bugs</code> é expandido para as três caixas de correio locais <code>joe</code>, <code>eric</code> e <code>paul</code>. Uma caixa de correio remota pode ser especificada como <em>user@example.com</em>. A terceira entrada mostra como escrever mensagens em um arquivo, neste caso, <span class=filename>/dev/null</span>. A última entrada demonstra como enviar email para um programa, <span class=filename>/usr/local/bin/procmail</span>, através de um pipe UNIX™. Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=aliases&amp;sektion=5&amp;format=html">aliases(5)</a> para obter mais informações sobre o formato desse arquivo.</p></div><div class=paragraph><p>Sempre que este arquivo for atualizado, execute <code>newaliases</code> para atualizar e inicializar o banco de dados de aliases.</p></div></dd><dt class=hdlist1><span class=filename>/etc/mail/sendmail.cf</span></dt><dd><p>Este é o arquivo de configuração principal do Sendmail. Ele controla o comportamento geral do Sendmail, incluindo tudo desde a tradução de endereços de email até a impressão de mensagens de rejeição para servidores de email remotos. Assim, este arquivo de configuração é bastante complexo. Felizmente, esse arquivo raramente precisa ser alterado para servidores de email padrão.</p><div class=paragraph><p>O arquivo de configuração master do Sendmail pode ser criado a partir de macros <a href="https://man.freebsd.org/cgi/man.cgi?query=m4&amp;sektion=1&amp;format=html">m4(1)</a> que definem os recursos e o comportamento do Sendmail. Consulte <span class=filename>/usr/src/contrib/sendmail/cf/README</span> para mais detalhes.</p></div><div class=paragraph><p>Sempre que alterações nesse arquivo são feitas, o Sendmail precisa ser reiniciado para que as alterações entrem em vigor.</p></div></dd><dt class=hdlist1><span class=filename>/etc/mail/virtusertable</span></dt><dd><p>Esse arquivo mapeia endereços de email de domínios virtuais para caixas de correio usuários reais. Essas caixas de correio podem ser locais, remotas, aliases definidas em <span class=filename>/etc/mail/aliases</span> ou arquivos. Isso permite que vários domínios virtuais sejam hospedados em uma máquina.</p><div class=paragraph><p>O FreeBSD fornece um exemplo de arquivo de configuração em <span class=filename>/etc/mail/virtusertable.sample</span> para demonstrar ainda mais seu formato. O exemplo a seguir demonstra como criar entradas personalizadas usando esse formato:</p></div><div class="literalblock programlisting"><div class=content><pre>root@example.com                root
postmaster@example.com          postmaster@noc.example.net
@example.com                    joe</pre></div></div><div class=paragraph><p>Este arquivo é processado pela primeira entrada que for correspondida. Quando um endereço de email corresponde ao endereço à esquerda, ele é mapeado para a caixa de correio local listada à direita. O formato da primeira entrada neste exemplo mapeia um endereço de email específico para uma caixa de correio local, enquanto o formato da segunda entrada mapeia um endereço de email específico para uma caixa de correio remota. Por fim, qualquer endereço de email de <code>example.com</code> que não correspondeu a nenhuma das entradas anteriores corresponderá ao último mapeamento e será enviado para a caixa de correio local <code>joe</code>. Ao criar entradas personalizadas, use este formato e adicione-as ao <span class=filename>/etc/mail/virtusertable</span>. Sempre que este arquivo for editado, atualize seu banco de dados e reinicie o Sendmail:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># makemap hash /etc/mail/virtusertable &lt; /etc/mail/virtusertable</span>
<span class=c># service sendmail restart</span></code></pre></div></div></dd><dt class=hdlist1><span class=filename>/etc/mail/relay-domains</span></dt><dd><p>Em uma instalação padrão do FreeBSD, o Sendmail é configurado para enviar apenas mensagens provenientes do host em que está sendo executado. Por exemplo, se um servidor POP estiver disponível, os usuários poderão verificar os emails de locais remotos, mas não poderão enviar emails de domínios externos. Normalmente, após alguns momentos da tentativa, um email será enviado de <code>MAILER-DAEMON</code> com uma mensagem <code>5.7 Relaying Denied</code>.</p><div class=paragraph><p>A solução mais simples é adicionar o FQDN do ISP ao <span class=filename>/etc/mail/relay-domains</span>. Se vários endereços forem necessários, adicione-os um por linha:</p></div><div class="literalblock programlisting"><div class=content><pre>your.isp.example.com
other.isp.example.net
users-isp.example.org
www.example.org</pre></div></div><div class=paragraph><p>Depois de criar ou editar este arquivo, reinicie o Sendmail com <code>service sendmail restart</code>.</p></div><div class=paragraph><p>Agora, qualquer mensagem enviada pelo sistema por qualquer domínio dessa lista, desde que o usuário tenha uma conta no sistema, será aceita. Isso permite que os usuários enviem emails de domínios remotos do sistema sem precisar liberar acesso externo ao sistema, evitando SPAM da Internet.</p></div></dd></dl></div></div><div class=sect2><h3 id=mail-changingmta>28.4. Alterando o Mail Transfer Agent<a class=anchor href=#mail-changingmta></a></h3><div class=paragraph><p>O FreeBSD vem com o Sendmail já instalado como MTA, que é responsável pelos emails enviados e recebidos. No entanto, o administrador do sistema pode alterar o MTA do sistema. Uma ampla lista de alternativas de MTAs está disponível na categoria <code>mail</code> da Coleção de Ports do FreeBSD.</p></div><div class=paragraph><p>Uma vez que um novo MTA esteja instalado, configure e teste o novo software antes de substituir o Sendmail. Consulte a documentação do novo MTA para obter informações sobre como configurar o software.</p></div><div class=paragraph><p>Uma vez que o novo MTA estiver funcionando, use as instruções nesta seção para desativar o Sendmail e configurar o FreeBSD para usar o MTA substituto.</p></div><div class=sect3><h4 id=mail-disable-sendmail>28.4.1. Desativar o Sendmail<a class=anchor href=#mail-disable-sendmail></a></h4><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Se o serviço de email de saída do Sendmail estiver desabilitado, é importante que ele seja substituído por um sistema de entrega de email alternativo. Caso contrário, as funções do sistema, como <a href="https://man.freebsd.org/cgi/man.cgi?query=periodic&amp;sektion=8&amp;format=html">periodic(8)</a>, não poderão entregar seus resultados por email. Muitas partes do sistema esperam um MTA funcional. Se os aplicativos continuarem a usar os binários do Sendmail para tentar enviar emails depois que eles forem desativados, o email poderá entrar em uma fila inativa do Sendmail e nunca será entregue.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Para desabilitar completamente o Sendmail, adicione ou edite as seguintes linhas no <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>sendmail_enable=&#34;NO&#34;
sendmail_submit_enable=&#34;NO&#34;
sendmail_outbound_enable=&#34;NO&#34;
sendmail_msp_queue_enable=&#34;NO&#34;</pre></div></div><div class=paragraph><p>Para desabilitar somente o serviço de email de entrada do Sendmail, use apenas esta entrada no <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>sendmail_enable=&#34;NO&#34;</pre></div></div><div class=paragraph><p>Mais informações sobre as opções de inicialização do Sendmail estão disponíveis em <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.sendmail&amp;sektion=8&amp;format=html">rc.sendmail(8)</a>.</p></div></div><div class=sect3><h4 id=_substitua_o_mta_padrão>28.4.2. Substitua o MTA Padrão<a class=anchor href=#_substitua_o_mta_padrão></a></h4><div class=paragraph><p>Quando um novo MTA é instalado usando a Coleção de Ports, seu script de inicialização também é instalado e as instruções de inicialização são mencionadas em sua mensagem de pacote. Antes de iniciar o novo MTA, pare os processos do Sendmail em execução. Este exemplo interrompe todos esses serviços e em seguida, inicia o serviço Postfix:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service sendmail stop</span>
<span class=c># service postfix start</span></code></pre></div></div><div class=paragraph><p>Para configurar a substituição MTA na inicialização do sistema, adicione sua linha de configuração ao <span class=filename>/etc/rc.conf</span>. Esta entrada habilita o MTA Postfix:</p></div><div class="literalblock programlisting"><div class=content><pre>postfix_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Algumas configurações adicionais são necessárias, pois o Sendmail é tão onipresente que alguns softwares assumem que ele já está instalado e configurado. Verifique o <span class=filename>/etc/periodic.conf</span> e certifique-se de que esses valores estejam configurados como <code>NO</code>. Se este arquivo não existir, crie-o com estas entradas:</p></div><div class="literalblock programlisting"><div class=content><pre>daily_clean_hoststat_enable=&#34;NO&#34;
daily_status_mail_rejects_enable=&#34;NO&#34;
daily_status_include_submit_mailq=&#34;NO&#34;
daily_submit_queuerun=&#34;NO&#34;</pre></div></div><div class=paragraph><p>Alguns MTAs alternativos fornecem suas próprias implementações compatíveis de linha de comando do Sendmail para facilitar o uso delas como substitutos para o Sendmail. No entanto, alguns MUAs podem tentar executar binários padrão do Sendmail em vez dos binários do novo MTA. O FreeBSD usa o <span class=filename>/etc/mail/mailer.conf</span> para mapear os binários esperados do Sendmail para o local dos novos binários. Mais informações sobre esse mapeamento podem ser encontradas em <a href="https://man.freebsd.org/cgi/man.cgi?query=mailwrapper&amp;sektion=8&amp;format=html">mailwrapper(8)</a>.</p></div><div class=paragraph><p>O <span class=filename>/etc/mail/mailer.conf</span> padrão se parece com isto:</p></div><div class="literalblock programlisting"><div class=content><pre># $FreeBSD: head/pt_BR.ISO8859-1/books/handbook/book.xml 53984 2020-03-15 16:03:31Z dbaio $
#
# Execute the &#34;real&#34; sendmail program, named /usr/libexec/sendmail/sendmail
#
sendmail        /usr/libexec/sendmail/sendmail
send-mail       /usr/libexec/sendmail/sendmail
mailq           /usr/libexec/sendmail/sendmail
newaliases      /usr/libexec/sendmail/sendmail
hoststat        /usr/libexec/sendmail/sendmail
purgestat       /usr/libexec/sendmail/sendmail</pre></div></div><div class=paragraph><p>Quando qualquer um dos comandos listados à esquerda é executado, o sistema na verdade executa o comando associado mostrado à direita. Esse sistema facilita a alteração de quais binários são executados quando esses binários padrões são chamados.</p></div><div class=paragraph><p>Alguns MTAs, quando instalados usando a Coleção de Ports, solicitarão a atualização deste arquivo para os novos binários. Por exemplo, o Postfix atualizará o arquivo da seguinte forma:</p></div><div class="literalblock programlisting"><div class=content><pre>#
# Execute the Postfix sendmail program, named /usr/local/sbin/sendmail
#
sendmail        /usr/local/sbin/sendmail
send-mail       /usr/local/sbin/sendmail
mailq           /usr/local/sbin/sendmail
newaliases      /usr/local/sbin/sendmail</pre></div></div><div class=paragraph><p>Se a instalação do MTA não atualizar automaticamente o <span class=filename>/etc/mail/mailer.conf</span>, edite esse arquivo em um editor de texto para que ele aponte para os novos binários. Este exemplo aponta para os binários instalados pelo <a class=package href=https://cgit.freebsd.org/ports/tree/mail/ssmtp/>mail/ssmtp</a>:</p></div><div class="literalblock programlisting"><div class=content><pre>sendmail        /usr/local/sbin/ssmtp
send-mail       /usr/local/sbin/ssmtp
mailq           /usr/local/sbin/ssmtp
newaliases      /usr/local/sbin/ssmtp
hoststat        /usr/bin/true
purgestat       /usr/bin/true</pre></div></div><div class=paragraph><p>Depois que tudo estiver configurado, é recomendável reinicializar o sistema. A reinicialização oferece a oportunidade de garantir que o sistema esteja configurado corretamente para iniciar o novo MTA automaticamente no boot.</p></div></div></div><div class=sect2><h3 id=mail-trouble>28.5. Solução de problemas<a class=anchor href=#mail-trouble></a></h3><div class=sect3><h4 id=_por_que_preciso_usar_o_fqdn_para_hosts_no_meu_site>28.5.1. Por que preciso usar o FQDN para hosts no meu site?<a class=anchor href=#_por_que_preciso_usar_o_fqdn_para_hosts_no_meu_site></a></h4><div class=paragraph><p>O host pode, na verdade, estar em um domínio diferente. Por exemplo, para um host em <code>foo.bar.edu</code> se conectar a um host chamado <code>mumble</code> no domínio <code>bar.edu</code>, faça a referência pelo Nome de Domínio Totalmente Qualificado (Fully-Qualified Domain Name) FQDN, <code>mumble.bar.edu</code>, em vez de apenas <code>mumble</code>.</p></div><div class=paragraph><p>Isso ocorre porque a versão do BIND que vem com o FreeBSD não fornece mais abreviações padrão para não-FQDNs que não sejam o domínio local. Um host não qualificado como <code>mumble</code> deve ser encontrado como <code>mumble.foo.bar.edu</code>, ou ele será procurado no domínio raiz.</p></div><div class=paragraph><p>Nas versões mais antigas do BIND, a pesquisa continuava em <code>mumble.bar.edu</code> e <code>mumble.edu</code>. A RFC 1535 detalha por que isso é considerado uma má prática ou até mesmo uma falha de segurança.</p></div><div class=paragraph><p>Como uma boa solução, coloque a linha:</p></div><div class="literalblock programlisting"><div class=content><pre>search foo.bar.edu bar.edu</pre></div></div><div class=paragraph><p>em vez do anterior:</p></div><div class="literalblock programlisting"><div class=content><pre>domain foo.bar.edu</pre></div></div><div class=paragraph><p>no <span class=filename>/etc/resolv.conf</span>. No entanto, certifique-se de que a ordem de pesquisa não ultrapasse o limite "entre administração local e pública", como a RFC 1535 a chama.</p></div></div><div class=sect3><h4 id=_como_posso_executar_um_servidor_de_email_em_um_host_ppp_dial_up>28.5.2. Como posso executar um servidor de email em um host PPP dial-up?<a class=anchor href=#_como_posso_executar_um_servidor_de_email_em_um_host_ppp_dial_up></a></h4><div class=paragraph><p>Conecte-se a um gateway de email FreeBSD na LAN. A conexão PPP não é dedicada.</p></div><div class=paragraph><p>Uma maneira de fazer isso é obter um servidor de Internet em tempo integral para fornecer serviços MX secundários para o domínio. Neste exemplo, o domínio é <code>example.com</code> e o ISP configurou <code>example.net</code> para fornecer o serviço de MX secundário para o domínio:</p></div><div class="literalblock programlisting"><div class=content><pre>example.com.          MX        10      example.com.
                      MX        20      example.net.</pre></div></div><div class=paragraph><p>Apenas um host deve ser especificado como o destinatário final. Para Sendmail, adicione <code>Cw example.com</code> em <span class=filename>/etc/mail/sendmail.cf</span> em <code>example.com</code>.</p></div><div class=paragraph><p>Quando o MTA de envio tentar entregar o email, ele tentará conectar ao sistema, <code>example.com</code>, através do link PPP. Isso expirará se o destino estiver offline. O MTA irá entregá-lo automaticamente ao site MX secundário no Provedor de Serviços de Internet (ISP), <code>example.net</code>. O site secundário de MX tentará conectar-se periodicamente ao host primário MX, <code>example.com</code>.</p></div><div class=paragraph><p>Use algo assim como um script de login:</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
# Put me in /usr/local/bin/pppmyisp
( sleep 60 ; /usr/sbin/sendmail -q ) &amp;
/usr/sbin/ppp -direct pppmyisp</pre></div></div><div class=paragraph><p>Ao criar um script de login separado para usuários, use <code>sendmail -qRexample.com</code> no script acima. Isso forçará todos os emails na fila para que <code>example.com</code> sejam processados imediatamente.</p></div><div class=paragraph><p>Um refinamento adicional da situação pode ser visto neste exemplo na lista de discussão <a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-isp>Lista de discussão de provedor de serviços de Internet do FreeBSD</a>:</p></div><div class="literalblock programlisting"><div class=content><pre>&gt; we provide the secondary MX for a customer. The customer connects to
&gt; our services several times a day automatically to get the mails to
&gt; his primary MX (We do not call his site when a mail for his domains
&gt; arrived). Our sendmail sends the mailqueue every 30 minutes. At the
&gt; moment he has to stay 30 minutes online to be sure that all mail is
&gt; gone to the primary MX.
&gt;
&gt; Is there a command that would initiate sendmail to send all the mails
&gt; now? The user has not root-privileges on our machine of course.

In the privacy flags section of sendmail.cf, there is a
definition Opgoaway,restrictqrun

Remove restrictqrun to allow non-root users to start the queue processing.
You might also like to rearrange the MXs. We are the 1st MX for our
customers like this, and we have defined:

# If we are the best MX for a host, try directly instead of generating
# local config error.
OwTrue

That way a remote site will deliver straight to you, without trying
the customer connection.  You then send to your customer.  Only works for
hosts, so you need to get your customer to name their mail
machine customer.com as well as
hostname.customer.com in the DNS.  Just put an A record in
the DNS for customer.com.</pre></div></div></div></div><div class=sect2><h3 id=mail-advanced>28.6. Tópicos Avançados<a class=anchor href=#mail-advanced></a></h3><div class=paragraph><p>Esta seção aborda tópicos mais envolvidos, como configuração de email e configuração de email para um domínio inteiro.</p></div><div class=sect3><h4 id=mail-config>28.6.1. Configuração básica<a class=anchor href=#mail-config></a></h4><div class=paragraph><p>Fora da caixa, pode-se enviar email para hosts externos desde que <span class=filename>/etc/resolv.conf</span> esteja configurado ou a rede tenha acesso a um servidor DNS. Para ter um email entregue ao MTA em um host FreeBSD, siga um destes procedimentos:</p></div><div class=ulist><ul><li><p>Execute um servidor DNS para o domínio.</p></li><li><p>Tenha o email entregue diretamente para o FQDN para a máquina.</p></li></ul></div><div class=paragraph><p>Para que o email seja entregue diretamente a um host, ele deve ter um endereço IP estático permanente, não um endereço IP dinâmico. Se o sistema estiver protegido por um firewall, ele deverá ser configurado para permitir o tráfego SMTP. Para receber mensagens diretamente em um host, um desses dois deve ser configurado:</p></div><div class=ulist><ul><li><p>Certifique-se de que o registro MX de menor numeração no DNS aponte para o endereço IP estático do host.</p></li><li><p>Certifique-se de que não exista nenhuma entrada MX no DNS para o host.</p></li></ul></div><div class=paragraph><p>Qualquer um dos itens acima permitirá que o correio seja recebido diretamente no host.</p></div><div class=paragraph><p>Tente isto:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># hostname</span>
example.FreeBSD.org
<span class=c># host example.FreeBSD.org</span>
example.FreeBSD.org has address 204.216.27.XX</code></pre></div></div><div class=paragraph><p>Neste exemplo, as mensagens enviadas diretamente para <a href=mailto:yourlogin@exemplo.FreeBSD.org>yourlogin@exemplo.FreeBSD.org</a> devem funcionar sem problemas, supondo que o Sendmail esteja sendo executado corretamente em <code>example.FreeBSD.org</code>.</p></div><div class=paragraph><p>Para este exemplo:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># host example.FreeBSD.org</span>
example.FreeBSD.org has address 204.216.27.XX
example.FreeBSD.org mail is handled <span class=o>(</span><span class=nv>pri</span><span class=o>=</span>10<span class=o>)</span> by nevdull.FreeBSD.org</code></pre></div></div><div class=paragraph><p>Todas as mensagens enviadas para <code>exemple.FreeBSD.org</code> serão coletadas no <code>hub</code> sob o mesmo nome de usuário, em vez de serem enviadas diretamente para o seu host.</p></div><div class=paragraph><p>As informações acima são tratadas pelo servidor DNS. O registro DNS que possui as informações de roteamento de email é a entrada MX. Se não existir nenhum registro MX, os emails serão entregues diretamente ao host por meio de seu endereço IP.</p></div><div class=paragraph><p>A entrada MX de <code>freefall.FreeBSD.org</code> uma vez foi assim:</p></div><div class="literalblock programlisting"><div class=content><pre>freefall		MX	30	mail.crl.net
freefall		MX	40	agora.rdrop.com
freefall		MX	10	freefall.FreeBSD.org
freefall		MX	20	who.cdrom.com</pre></div></div><div class=paragraph><p><code>freefall</code> teve muitas entradas MX. O menor número MX é o host que recebe email diretamente, se disponível. Se não for acessível por algum motivo, o próximo host de número mais baixo aceitará as mensagens temporariamente e as transmitirá quando um host de número inferior for disponibilizado.</p></div><div class=paragraph><p>Sites alternativos de MX devem ter conexões de Internet separadas para serem mais úteis. Seu ISP pode fornecer este serviço.</p></div></div><div class=sect3><h4 id=mail-domain>28.6.2. Email para um Domínio<a class=anchor href=#mail-domain></a></h4><div class=paragraph><p>Ao configurar um MTA para uma rede, qualquer mensagem enviada para hosts em seu domínio deve ser desviada para o MTA para que os usuários possam receber seus emails no servidor de email principal.</p></div><div class=paragraph><p>Para tornar a vida mais fácil, uma conta de usuário com o mesmo <em>username</em> deve existir tanto no MTA como no sistema com o MUA. Use <a href="https://man.freebsd.org/cgi/man.cgi?query=adduser&amp;sektion=8&amp;format=html">adduser(8)</a> para criar as contas de usuário.</p></div><div class=paragraph><p>O MTA deve ser o servidor de mensagens designado para cada estação de trabalho na rede. Isso é feito na configuração DNS com um registro MX:</p></div><div class="literalblock programlisting"><div class=content><pre>example.FreeBSD.org	A	204.216.27.XX		; Workstation
			MX	10 nevdull.FreeBSD.org	; Mailhost</pre></div></div><div class=paragraph><p>Isso redirecionará o email para a estação de trabalho para o MTA, não importa onde o registro A aponta. O email é enviado para o host MX.</p></div><div class=paragraph><p>Isso deve ser configurado em um servidor DNS. Se a rede não executar seu próprio servidor DNS, fale com o ISP ou provedor DNS.</p></div><div class=paragraph><p>A seguir, um exemplo de hospedagem de email virtual. Considere um cliente com o domínio <code>customer1.org</code>, onde todas as mensagens para <code>customer1.org</code> devem ser enviadas para <code>mail.myhost.com</code>. A entrada DNS deve ficar assim:</p></div><div class="literalblock programlisting"><div class=content><pre>customer1.org		MX	10	mail.myhost.com</pre></div></div><div class=paragraph><p>Um registro <code>A</code>> <em>não</em> é necessário em <code>customer1.org</code> para que seja enviado emails para esse domínio. No entanto, um <code>ping</code> em <code>customer1.org</code> não funcionará, a menos que exista um registro <code>A</code> para ele.</p></div><div class=paragraph><p>Diga ao MTA quais domínios e/ou nomes de host que ele deve aceitar emails. Qualquer um dos itens a seguir funcionará para o Sendmail:</p></div><div class=ulist><ul><li><p>Adicione os hosts ao <span class=filename>/etc/mail/local-host-names</span> ao usar <code>FEATURE (use_cw_file)</code>.</p></li><li><p>Adicione uma linha <code>Cwyour.host.com</code> em <span class=filename>/etc/sendmail.cf</span>.</p></li></ul></div></div></div><div class=sect2><h3 id=outgoing-only>28.7. Configurando Apenas Envio<a class=anchor href=#outgoing-only></a></h3><div class=paragraph><p>Há muitos casos em que muitas instâncias podem querer enviar email através de um relay. Alguns exemplos são:</p></div><div class=ulist><ul><li><p>O computador é uma máquina desktop que precisa usar programas como <a href="https://man.freebsd.org/cgi/man.cgi?query=mail&amp;sektion=1&amp;format=html">mail(1)</a>, usando o relay de email do ISP.</p></li><li><p>O computador é um servidor que não manipula emails localmente, mas precisa passar todos os emails para um relay para processamento.</p></li></ul></div><div class=paragraph><p>Embora qualquer MTA seja capaz de preencher esse nicho específico, pode ser difícil configurar adequadamente um MTA com todos os recursos apenas para lidar com o descarregamento de email. Programas como Sendmail e Postfix são um exagero para esse uso.</p></div><div class=paragraph><p>Além disso, um acordo típico de serviço de acesso à Internet pode proibir a execução de um "servidor de email".</p></div><div class=paragraph><p>A maneira mais fácil de atender a essas necessidades é instalar o port <a class=package href=https://cgit.freebsd.org/ports/tree/mail/ssmtp/>mail/ssmtp</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/mail/ssmtp</span>
<span class=c># make install replace clean</span></code></pre></div></div><div class=paragraph><p>Uma vez instalado, o <a class=package href=https://cgit.freebsd.org/ports/tree/mail/ssmtp/>mail/ssmtp</a> pode ser configurado em <span class=filename>/usr/local/etc/ssmtp/ssmtp.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>root=yourrealemail@example.com
mailhub=mail.example.com
rewriteDomain=example.com
hostname=_HOSTNAME_</pre></div></div><div class=paragraph><p>Use o endereço de email real para <code>root</code>. Insira a retransmissão de mensagens de saída do ISP no lugar de <code>mail.example.com</code>. Alguns ISPs chamam isso de "servidor de email de saída" ou "servidor SMTP".</p></div><div class=paragraph><p>Certifique-se de desativar o Sendmail, incluindo o serviço de envio de mensagens. Veja <a href=#mail-disable-sendmail>Desativar o Sendmail</a> para detalhes.</p></div><div class=paragraph><p><a class=package href=https://cgit.freebsd.org/ports/tree/mail/ssmtp/>mail/ssmtp</a> tem algumas outras opções disponíveis. Consulte os exemplos em <span class=filename>/usr/local/etc/ssmtp</span> ou na página de manual do ssmtp para obter mais informações.</p></div><div class=paragraph><p>A configuração do ssmtp dessa maneira permite que qualquer software no computador que precise enviar mensagens funcione corretamente, sem violar a política de uso dos ISPs ou permitindo que o computador seja sequestrado para envio de spam.</p></div></div><div class=sect2><h3 id=SMTP-dialup>28.8. Usando Email com uma Conexão Dialup<a class=anchor href=#SMTP-dialup></a></h3><div class=paragraph><p>Ao usar um endereço IP estático, não é necessário ajustar a configuração padrão. Configure o nome do host para o nome da Internet designado e o Sendmail fará o resto.</p></div><div class=paragraph><p>Ao usar um endereço IP atribuído dinamicamente e uma conexão PPP de discagem à Internet, geralmente há uma caixa de correio no servidor de email do ISP. Neste exemplo, o domínio do ISP é <code>example.net</code>, o nome de usuário é <code>user</code>, o nome do host é <code>bsd.home</code>, e o ISP permitiu <code>relay.example.net</code> como um relay de email.</p></div><div class=paragraph><p>Para baixar emails da caixa de correio do ISP, instale um agente pela coleção de ports. O <a class=package href=https://cgit.freebsd.org/ports/tree/mail/fetchmail/>mail/fetchmail</a> é uma boa escolha, pois suporta muitos protocolos diferentes. Normalmente, o ISP fornecerá POP. Ao usar o usuário PPP, o email pode ser baixado automaticamente quando uma conexão com a Internet é estabelecida com a seguinte entrada em <span class=filename>/etc/ppp/ppp.linkup</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>MYADDR:
!bg su user -c fetchmail</pre></div></div><div class=paragraph><p>Ao usar o Sendmail para entregar emails em contas não locais, configure o Sendmail para processar a fila de mensagens assim que a conexão com a Internet for estabelecida. Para fazer isso, adicione esta linha após a entrada <code>fetchmail</code> acima em <span class=filename>/etc/ppp/ppp.linkup</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>  !bg su user -c &#34;sendmail -q&#34;</pre></div></div><div class=paragraph><p>Neste exemplo, há uma conta para <code>user</code> em <code>bsd.home</code>. No diretório home de <code>user</code> em <code>bsd.home</code>, crie um <span class=filename>.fetchmailrc</span> que contenha esta linha :</p></div><div class="literalblock programlisting"><div class=content><pre>poll example.net protocol pop3 fetchall pass MySecret</pre></div></div><div class=paragraph><p>Este arquivo não deve ter permissão de leitura para ninguém, exceto pelo <code>user</code>, pois contém a senha <code>MySecret</code>.</p></div><div class=paragraph><p>Para enviar emails com o cabeçalho correto <code>from:</code>, configure o Sendmail para usar <a href=mailto:user@example.net>user@example.net</a> em vez de <a href=mailto:user@bsd.home>user@bsd.home</a> e para enviar todos os emails através de <code>relay.example.net</code>, permitindo uma transmissão de email mais rápida.</p></div><div class=paragraph><p>O seguinte <span class=filename>.mc</span> deve ser suficiente:</p></div><div class="literalblock programlisting"><div class=content><pre>VERSIONID(`bsd.home.mc version 1.0&#39;)
OSTYPE(bsd4.4)dnl
FEATURE(nouucp)dnl
MAILER(local)dnl
MAILER(smtp)dnl
Cwlocalhost
Cwbsd.home
MASQUERADE_AS(`example.net&#39;)dnl
FEATURE(allmasquerade)dnl
FEATURE(masquerade_envelope)dnl
FEATURE(nocanonify)dnl
FEATURE(nodns)dnl
define(`SMART_HOST&#39;, `relay.example.net&#39;)
Dmbsd.home
define(`confDOMAIN_NAME&#39;,`bsd.home&#39;)dnl
define(`confDELIVERY_MODE&#39;,`deferred&#39;)dnl</pre></div></div><div class=paragraph><p>Consulte a seção anterior para obter detalhes sobre como converter esse arquivo no formato <span class=filename>sendmail.cf</span>. Não esqueça de reiniciar o Sendmail após atualizar o <span class=filename>sendmail.cf</span>.</p></div></div><div class=sect2><h3 id=SMTP-Auth>28.9. Autenticação SMTP<a class=anchor href=#SMTP-Auth></a></h3><div class=paragraph><p>Configurar a autenticação SMTP no MTA oferece vários benefícios. A autenticação SMTP adiciona uma camada de segurança ao Sendmail e fornece aos usuários móveis que alternam os hosts a capacidade de usar o mesmo MTA sem a necessidade de reconfigurar as configurações de seus clientes de email a cada vez.</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Instale o <a class=package href=https://cgit.freebsd.org/ports/tree/security/cyrus-sasl2/>security/cyrus-sasl2</a> da Coleção de Ports. Este port suporta várias opções de tempo de compilação. Para o método de autenticação SMTP demonstrado neste exemplo, certifique-se de que <code>LOGIN</code> não esteja desabilitado.</p></li><li><p>Depois de instalar o <a class=package href=https://cgit.freebsd.org/ports/tree/security/cyrus-sasl2/>security/cyrus-sasl2</a>, edite o <span class=filename>/usr/local/lib/sasl2/Sendmail.conf</span>, ou crie-o se ele não existir, e adicione a seguinte linha :</p><div class="literalblock programlisting"><div class=content><pre>pwcheck_method: saslauthd</pre></div></div></li><li><p>Em seguida, instale o <a class=package href=https://cgit.freebsd.org/ports/tree/security/cyrus-sasl2-saslauthd/>security/cyrus-sasl2-saslauthd</a> e adicione a seguinte linha ao <span class=filename>/etc/rc.conf</span>:</p><div class="literalblock programlisting"><div class=content><pre>saslauthd_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Finalmente, inicie o daemon saslauthd:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service saslauthd start</span></code></pre></div></div><div class=paragraph><p>Este daemon serve como um intermediário para o Sendmail autenticar no banco de dados do FreeBSD o <a href="https://man.freebsd.org/cgi/man.cgi?query=passwd&amp;sektion=5&amp;format=html">passwd(5)</a>. Isso evita o trabalho de criar um novo conjunto de nomes de usuário e senhas para cada usuário que precise usar a autenticação SMTP e mantém a senha de login e email igual.</p></div></li><li><p>Em seguida, edite o <span class=filename>/etc/make.conf</span> e adicione as seguintes linhas:</p><div class="literalblock programlisting"><div class=content><pre>SENDMAIL_CFLAGS=-I/usr/local/include/sasl -DSASL
SENDMAIL_LDADD=/usr/local/lib/libsasl2.so</pre></div></div><div class=paragraph><p>Essas linhas fornecem ao Sendmail as opções de configuração apropriadas para vincular ao <a class=package href=https://cgit.freebsd.org/ports/tree/cyrus-sasl2/>cyrus-sasl2</a> em tempo de compilação. Certifique-se de que o <a class=package href=https://cgit.freebsd.org/ports/tree/cyrus-sasl2/>cyrus-sasl2</a> tenha sido instalado antes de recompilar o Sendmail.</p></div></li><li><p>Recompile o Sendmail executando os seguintes comandos:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/src/lib/libsmutil</span>
<span class=c># make cleandir &amp;&amp; make obj &amp;&amp; make</span>
<span class=c># cd /usr/src/lib/libsm</span>
<span class=c># make cleandir &amp;&amp; make obj &amp;&amp; make</span>
<span class=c># cd /usr/src/usr.sbin/sendmail</span>
<span class=c># make cleandir &amp;&amp; make obj &amp;&amp; make &amp;&amp; make install</span></code></pre></div></div><div class=paragraph><p>Esta compilação não deve ter nenhum problema se o <span class=filename>/usr/src</span> não foi alterado extensivamente e as bibliotecas compartilhadas necessárias estiverem disponíveis.</p></div></li><li><p>Depois que o Sendmail tenha sido compilado e reinstalado, edite o <span class=filename>/etc/mail/freebsd.mc</span> ou o arquivo local <span class=filename>.mc</span>. Muitos administradores optam por usar a saída de <a href="https://man.freebsd.org/cgi/man.cgi?query=hostname&amp;sektion=1&amp;format=html">hostname(1)</a> como o nome de <span class=filename>.mc</span> para exclusividade. Adicione estas linhas:</p><div class="literalblock programlisting"><div class=content><pre>dnl set SASL options
TRUST_AUTH_MECH(`GSSAPI DIGEST-MD5 CRAM-MD5 LOGIN&#39;)dnl
define(`confAUTH_MECHANISMS&#39;, `GSSAPI DIGEST-MD5 CRAM-MD5 LOGIN&#39;)dnl</pre></div></div><div class=paragraph><p>Essas opções configuram os diferentes métodos disponíveis para que o Sendmail autentique usuários. Para usar um método diferente de pwcheck, consulte a documentação do Sendmail.</p></div></li><li><p>Finalmente, execute <a href="https://man.freebsd.org/cgi/man.cgi?query=make&amp;sektion=1&amp;format=html">make(1)</a> enquanto estiver em <span class=filename>/etc/mail</span>. Isso executará o novo <span class=filename>.mc</span> e criará um <span class=filename>.cf</span> chamado <span class=filename>freebsd.cf</span> ou o nome usado para o arquivo local <span class=filename>.mc</span>. Em seguida, execute <code>make install restart</code>, que copiará o arquivo para o <span class=filename>sendmail.cf</span>, e reinicie corretamente o Sendmail. Para mais informações sobre este processo, consulte <span class=filename>/etc/mail/Makefile</span>.</p></li></ol></div></div></div><div class=paragraph><p>Para testar a configuração, use um MUA para enviar uma mensagem de teste. Para investigações posteriores, defina o <code>LogLevel</code> do Sendmail como <code>13</code> e verifique o <span class=filename>/var/log/maillog</span> para quaisquer erros.</p></div><div class=paragraph><p>Para mais informações, consulte <a href=http://www.sendmail.org/~ca/email/auth.html>autenticação SMTP</a>.</p></div></div><div class=sect2><h3 id=mail-agents>28.10. Mail User Agents<a class=anchor href=#mail-agents></a></h3><div class=paragraph><p>Um MUA é um aplicativo usado para enviar e receber emails. À medida que o email "evolui" e se torna mais complexo, os MUAs estão se tornando cada vez mais poderosos e fornecem aos usuários maior funcionalidade e flexibilidade. A categoria <code>mail</code> da Coleção de Ports do FreeBSD contém numerosos MUAs. Eles incluem clientes de email gráficos como Evolution ou Balsa e clientes baseados em console, como mutt ou alpine.</p></div><div class=sect3><h4 id=mail-command>28.10.1. <code>mail</code><a class=anchor href=#mail-command></a></h4><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=mail&amp;sektion=1&amp;format=html">mail(1)</a> é o MUA padrão instalado com o FreeBSD. É um MUA baseado em console que oferece a funcionalidade básica necessária para enviar e receber email em texto. Ele fornece suporte limitado a anexos e só pode acessar caixas de correio locais.</p></div><div class=paragraph><p>Embora o <code>mail</code> não suporte nativamente a interação com os servidores POP ou IMAP, essas caixas de correio podem ser baixadas para um arquivo <span class=filename>mbox</span> local usando um aplicativo como fetchmail.</p></div><div class=paragraph><p>Para enviar e receber email, execute <code>mail</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% mail</code></pre></div></div><div class=paragraph><p>O conteúdo da caixa de correio do usuário em <span class=filename>/var/mail</span> é lido automaticamente pelo <code>mail</code>. Se a caixa de correio estiver vazia, o utilitário sairá com uma mensagem indicando que nenhum email foi encontrado. Se o email existir, a interface do aplicativo será iniciada e uma lista de mensagens será exibida. As mensagens são numeradas automaticamente, como pode ser visto no exemplo a seguir:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Mail version 8.1 6/6/93.  Type ? <span class=k>for </span>help.
<span class=s2>&#34;/var/mail/marcs&#34;</span>: 3 messages 3 new
<span class=o>&gt;</span>N  1 root@localhost        Mon Mar  8 14:05  14/510   <span class=s2>&#34;test&#34;</span>
 N  2 root@localhost        Mon Mar  8 14:05  14/509   <span class=s2>&#34;user account&#34;</span>
 N  3 root@localhost        Mon Mar  8 14:05  14/509   <span class=s2>&#34;sample&#34;</span></code></pre></div></div><div class=paragraph><p>Agora as mensagens podem ser lidas digitando <kbd>t</kbd> seguido pelo número da mensagem. Este exemplo lê o primeiro email:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>&amp; t 1
Message 1:
From root@localhost  Mon Mar  8 14:05:52 2004
X-Original-To: marcs@localhost
Delivered-To: marcs@localhost
To: marcs@localhost
Subject: <span class=nb>test
</span>Date: Mon,  8 Mar 2004 14:05:52 +0200 <span class=o>(</span>SAST<span class=o>)</span>
From: root@localhost <span class=o>(</span>Charlie Root<span class=o>)</span>

This is a <span class=nb>test </span>message, please reply <span class=k>if </span>you receive it.</code></pre></div></div><div class=paragraph><p>Como visto neste exemplo, a mensagem será exibida com cabeçalhos completos. Para exibir novamente a lista de mensagens, pressione <kbd>h</kbd>.</p></div><div class=paragraph><p>Se o email exigir uma resposta, pressione as teclas <kbd>R</kbd> ou <kbd>r</kbd> no <code>mail</code>. <kbd>R</kbd> instrui o <code>mail</code> a responder apenas ao remetente do email, enquanto <kbd>r</kbd> responde a todos os outros destinatários da mensagem. Esses comandos podem ser sufixados com o número do email. Depois de digitar a resposta, o final da mensagem deve ser marcado por um único <kbd>.</kbd> em sua própria linha. Um exemplo pode ser visto abaixo:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>&amp; R 1
To: root@localhost
Subject: Re: <span class=nb>test

</span>Thank you, I did get your email.
<span class=nb>.</span>
EOT</code></pre></div></div><div class=paragraph><p>Para enviar um novo email, pressione <kbd>m</kbd>, seguido pelo endereço de email do destinatário. Vários destinatários podem ser especificados separando cada endereço com o delimitador <kbd>,</kbd>. O assunto da mensagem pode então ser inserido, seguido pelo conteúdo da mensagem. O final da mensagem deve ser especificado colocando um único <kbd>.</kbd> em sua própria linha.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>&amp; mail root@localhost
Subject: I mastered mail

Now I can send and receive email using mail ... :<span class=o>)</span>
<span class=nb>.</span>
EOT</code></pre></div></div><div class=paragraph><p>Enquanto estiver usando o <code>mail</code>, pressione <kbd>?</kbd> para exibir a ajuda a qualquer momento. Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=mail&amp;sektion=1&amp;format=html">mail(1)</a> para obter mais detalhes sobre como usar o <code>mail</code>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>O <a href="https://man.freebsd.org/cgi/man.cgi?query=mail&amp;sektion=1&amp;format=html">mail(1)</a> não foi projetado para manipular anexos e, portanto, lida mal com eles. Novos MUAs lidam com anexos de uma maneira mais inteligente. Usuários que preferem usar <code>mail</code> podem preferir o port <a class=package href=https://cgit.freebsd.org/ports/tree/converters/mpack/>converters/mpack</a>.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=mutt-command>28.10.2. mutt<a class=anchor href=#mutt-command></a></h4><div class=paragraph><p>O mutt é um poderoso MUA, com muitos recursos, incluindo:</p></div><div class=ulist><ul><li><p>A capacidade de enviar mensagens.</p></li><li><p>Suporte PGP para assinatura digital e criptografia de email.</p></li><li><p>Suporte MIME.</p></li><li><p>Suporte Maildir.</p></li><li><p>Altamente personalizável.</p></li></ul></div><div class=paragraph><p>Consulte <a href=http://www.mutt.org>http://www.mutt.org</a> para mais informações sobre o mutt.</p></div><div class=paragraph><p>O mutt pode ser instalado usando o port <a class=package href=https://cgit.freebsd.org/ports/tree/mail/mutt/>mail/mutt</a>. Após o port ter sido instalado, o mutt pode ser iniciado com o seguinte comando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% mutt</code></pre></div></div><div class=paragraph><p>O mutt irá automaticamente ler o conteúdo da caixa de correio do usuário em <span class=filename>/var/mail</span>. Se nenhum email for encontrado, o mutt aguardará os comandos do usuário. O exemplo abaixo mostra o mutt exibindo uma lista de mensagens:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/mail/mutt1.png alt=mutt1></div></div><div class=paragraph><p>Para ler um email, selecione-o usando as teclas de cursor e pressione <kbd>Enter</kbd>. Um exemplo de email exibido pelo mutt pode ser visto abaixo:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/mail/mutt2.png alt=mutt2></div></div><div class=paragraph><p>Semelhante ao <a href="https://man.freebsd.org/cgi/man.cgi?query=mail&amp;sektion=1&amp;format=html">mail(1)</a>, o mutt pode ser usado para responder apenas ao remetente da mensagem, bem como para todos os destinatários. Para responder apenas ao remetente do email, pressione <kbd>r</kbd>. Para enviar uma resposta de grupo ao remetente original e a todos os destinatários da mensagem, pressione <kbd>g</kbd>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Por padrão, o mutt usa o editor <a href="https://man.freebsd.org/cgi/man.cgi?query=vi&amp;sektion=1&amp;format=html">vi(1)</a> para criar e responder emails. Cada usuário pode personalizar isso criando ou editando o <span class=filename>.muttrc</span> em seu diretório home e configurando a variável <code>editor</code> ou definindo a variável de ambiente <code>EDITOR</code>. Consulte <a href=http://www.mutt.org/>http://www.mutt.org/</a> para obter mais informações sobre como configurar o mutt.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Para escrever uma nova mensagem de email, pressione <kbd>m</kbd>. Depois que um assunto válido foi dado, mutt iniciará o <a href="https://man.freebsd.org/cgi/man.cgi?query=vi&amp;sektion=1&amp;format=html">vi(1)</a> para que o email possa ser escrito. Quando o conteúdo do email estiver completo, salve e saia do <code>vi</code>. O mutt será retomado, exibindo uma tela de resumo do email que será enviado. Para enviar o email, pressione <kbd>y</kbd>. Um exemplo da tela de resumo pode ser visto abaixo:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/mail/mutt3.png alt=mutt3></div></div><div class=paragraph><p>O mutt contém manuais extensos que podem ser acessados pela maioria dos menus pressionando <kbd>?</kbd>. A linha superior também exibe os atalhos de teclado, quando apropriado.</p></div></div><div class=sect3><h4 id=alpine-command>28.10.3. alpine<a class=anchor href=#alpine-command></a></h4><div class=paragraph><p>O alpine é destinado a um usuário iniciante, mas também inclui alguns recursos avançados.</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>O alpine teve várias vulnerabilidades remotas descobertas no passado, que permitiam que atacantes remotos executassem código arbitrário como usuários no sistema local, pela ação de enviar um email especialmente preparado. Enquanto problemas <em>conhecidos</em> foram corrigidos, o código alpine foi escrito em um estilo inseguro e o FreeBSD Security Officer acredita que provavelmente há outras vulnerabilidades não descobertas. Os usuários instalam o alpine por sua conta e risco.</p></div></td></tr></tbody></table></div><div class=paragraph><p>A versão atual do alpine pode ser instalada usando o port <a class=package href=https://cgit.freebsd.org/ports/tree/mail/alpine/>mail/alpine</a>. Após a instalação do port, o alpine pode ser iniciado executando o seguinte comando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% alpine</code></pre></div></div><div class=paragraph><p>A primeira vez que o alpine é executado, ele exibe uma página de saudação com uma breve introdução, bem como uma solicitação da equipe de desenvolvimento do alpine para enviar uma mensagem de email anônima para que eles saibam quantos usuários estão usando o seu cliente. Para enviar esta mensagem anônima, pressione <kbd>Enter</kbd>. Como alternativa, pressione <kbd>E</kbd> para sair da saudação sem enviar uma mensagem anônima. Um exemplo da página de saudação é mostrado abaixo:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/mail/pine1.png alt=pine1></div></div><div class=paragraph><p>O menu principal é então apresentado, o qual pode ser navegado usando as teclas de cursor. Esse menu principal fornece atalhos para a composição de novos emails, navegação em diretórios de email e administração de entradas do catálogo de endereços. Abaixo do menu principal, são mostrados os atalhos de teclado relevantes para executar funções específicas da tarefa em questão.</p></div><div class=paragraph><p>O diretório padrão aberto pelo alpine é o <span class=filename>inbox</span>. Para visualizar o índice da mensagem, pressione <kbd>I</kbd> ou selecione a opção <span class=guimenuitem>MESSAGE INDEX</span> mostrada abaixo:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/mail/pine2.png alt=pine2></div></div><div class=paragraph><p>O índice de mensagens mostra mensagens no diretório atual e pode ser navegado usando as teclas de cursor. As mensagens destacadas podem ser lidas pressionando <kbd>Enter</kbd>.</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/mail/pine3.png alt=pine3></div></div><div class=paragraph><p>Na captura de tela abaixo, uma mensagem de exemplo é exibida pelo alpine. Atalhos de teclado contextuais são exibidos na parte inferior da tela. Um exemplo de um atalho é <kbd>r</kbd>, que diz ao MUA para responder à mensagem atual sendo exibida.</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/mail/pine4.png alt=pine4></div></div><div class=paragraph><p>A resposta de um email pelo alpine é feita usando o editor pico, que é instalado por padrão com o alpine. O pico facilita a navegação na mensagem e é mais fácil de ser usado por usuários iniciantes do que o <a href="https://man.freebsd.org/cgi/man.cgi?query=vi&amp;sektion=1&amp;format=html">vi(1)</a> ou <a href="https://man.freebsd.org/cgi/man.cgi?query=mail&amp;sektion=1&amp;format=html">mail(1)</a>. Quando a resposta estiver completa, a mensagem pode ser enviada pressionando <span class=keyseq><kbd>Ctrl</kbd>+<kbd>X</kbd></span>. O alpine solicitará confirmação antes de enviar a mensagem.</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/mail/pine5.png alt=pine5></div></div><div class=paragraph><p>O alpine pode ser personalizado usando a opção <span class=guimenuitem>SETUP</span> no menu principal. Consulte <a href=http://www.washington.edu/alpine/>http://www.washington.edu/alpine/</a> para mais informações.</p></div></div></div><div class=sect2><h3 id=mail-fetchmail>28.11. Usando o fetchmail<a class=anchor href=#mail-fetchmail></a></h3><div class=paragraph><p>O fetchmail é um cliente IMAP e POP completo. Ele permite que os usuários baixem automaticamente emails de servidores IMAP e POP remotos e os salvem em caixas de correio locais, onde podem ser acessados mais facilmente. O fetchmail pode ser instalado usando o port <a class=package href=https://cgit.freebsd.org/ports/tree/mail/fetchmail/>mail/fetchmail</a> e oferece vários recursos, incluindo:</p></div><div class=ulist><ul><li><p>Suporte para os protocolos POP3, o APOP, o KPOP, o IMAP, o ETRN e o ODMR.</p></li><li><p>Capacidade de encaminhar emails usando SMTP, que permite que a filtragem, o encaminhamento e aliases funcionem normalmente.</p></li><li><p>Pode ser executado no modo daemon para verificar periodicamente novas mensagens.</p></li><li><p>Pode buscar várias caixas de correio e encaminhá-las, com base na configuração, para diferentes usuários locais.</p></li></ul></div><div class=paragraph><p>Esta seção explica alguns dos recursos básicos do fetchmail. Este utilitário requer uma configuração <span class=filename>.fetchmailrc</span> no diretório pessoal do usuário para que seja executado corretamente. Este arquivo inclui informações do servidor, bem como credenciais de login. Devido à natureza sensível do conteúdo deste arquivo, é aconselhável torná-lo legível apenas pelo usuário, com o seguinte comando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>chmod </span>600 .fetchmailrc</code></pre></div></div><div class=paragraph><p>O seguinte <span class=filename>.fetchmailrc</span> serve como um exemplo para fazer o download de uma única caixa de correio de usuário usando POP. Ele diz ao fetchmail para se conectar ao <code>example.com</code> usando um nome de usuário <code>joesoap</code> e uma senha de <code>XXX</code>. Este exemplo pressupõe que o usuário <code>joesoap</code> exista no sistema local.</p></div><div class="literalblock programlisting"><div class=content><pre>poll example.com protocol pop3 username &#34;joesoap&#34; password &#34;XXX&#34;</pre></div></div><div class=paragraph><p>O próximo exemplo conecta-se a vários servidores POP e IMAP e redireciona para diferentes nomes de usuários locais quando aplicável:</p></div><div class="literalblock programlisting"><div class=content><pre>poll example.com proto pop3:
user &#34;joesoap&#34;, with password &#34;XXX&#34;, is &#34;jsoap&#34; here;
user &#34;andrea&#34;, with password &#34;XXXX&#34;;
poll example2.net proto imap:
user &#34;john&#34;, with password &#34;XXXXX&#34;, is &#34;myth&#34; here;</pre></div></div><div class=paragraph><p>fetchmail pode ser executado no modo daemon executando-o com <code>-d</code>, seguido pelo intervalo (em segundos) que o fetchmail deve pesquisar servidores listados em <span class=filename>.fetchmailrc</span>. O exemplo a seguir configura o fetchmail para pesquisar a cada 600 segundos:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% fetchmail <span class=nt>-d</span> 600</code></pre></div></div><div class=paragraph><p>Mais informações sobre o fetchmail podem ser encontradas em <a href=http://www.fetchmail.info/>http://www.fetchmail.info/</a>.</p></div></div><div class=sect2><h3 id=mail-procmail>28.12. Usando o procmail<a class=anchor href=#mail-procmail></a></h3><div class=paragraph><p>O procmail é um poderoso aplicativo usado para filtrar mensagens recebidas. Ele permite que os usuários definam "regras" que podem ser correspondidas aos emails recebidos para executar funções específicas ou para redirecionar o email para caixas de correio alternativas ou endereços de email. O procmail pode ser instalado usando o port <a class=package href=https://cgit.freebsd.org/ports/tree/mail/procmail/>mail/procmail</a>. Uma vez instalado, ele pode ser diretamente integrado na maioria dos MTAs. Consulte a documentação do MTA para mais informações. Alternativamente, procmail pode ser integrado adicionando a seguinte linha a um <span class=filename>.forward</span> no diretório pessoal do usuário:</p></div><div class="literalblock programlisting"><div class=content><pre>&#34;|exec /usr/local/bin/procmail || exit 75&#34;</pre></div></div><div class=paragraph><p>A seção a seguir exibe algumas regras básicas do procmail, além de breves descrições do que elas fazem. As regras devem ser inseridas em um <span class=filename>.procmailrc</span>, que deve residir no diretório pessoal do usuário.</p></div><div class=paragraph><p>A maioria dessas regras pode ser encontrada em <a href="https://man.freebsd.org/cgi/man.cgi?query=procmailex&amp;sektion=5&amp;format=html">procmailex(5)</a>.</p></div><div class=paragraph><p>Para encaminhar todos os emails de <a href=mailto:user@example.com>user@example.com</a> para um endereço externo de <a href=mailto:goodmail@example2.com>goodmail@example2.com</a>:</p></div><div class="literalblock programlisting"><div class=content><pre>:0
* ^From.*user@example.com
! goodmail@example2.com</pre></div></div><div class=paragraph><p>Para encaminhar todos os emails com menos de 1000 bytes para um endereço externo de <a href=mailto:goodmail@example2.com>goodmail@example2.com</a>:</p></div><div class="literalblock programlisting"><div class=content><pre>:0
* &lt; 1000
! goodmail@example2.com</pre></div></div><div class=paragraph><p>Para enviar todas as mensagens enviadas para <a href=mailto:alternate@example.com>alternate@example.com</a> para uma caixa de correio chamada <span class=filename>alternate</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>:0
* ^TOalternate@example.com
alternate</pre></div></div><div class=paragraph><p>Para enviar todas as mensagens com um assunto de "Spam" para <span class=filename>/dev/null</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>:0
^Subject:.*Spam
/dev/null</pre></div></div><div class=paragraph><p>Uma receita útil que analisa listas de discussão <code>do FreeBSD.org</code> e coloca cada lista em sua própria caixa de correio:</p></div><div class="literalblock programlisting"><div class=content><pre>:0
* ^Sender:.owner-freebsd-\/[^@]+@FreeBSD.ORG
{
	LISTNAME=${MATCH}
	:0
	* LISTNAME??^\/[^@]+
	FreeBSD-${MATCH}
}</pre></div></div></div></div></div><div class=sect1><h2 id=network-servers>Capítulo 29. Servidores de Rede<a class=anchor href=#network-servers></a></h2><div class=sectionbody><div class=sect2><h3 id=network-servers-synopsis>29.1. Sinopse<a class=anchor href=#network-servers-synopsis></a></h3><div class=paragraph><p>Este capítulo aborda alguns dos serviços de rede usados com mais frequência em sistemas UNIX™. Isso inclui instalar, configurar, testar e manter muitos tipos diferentes de serviços de rede. Exemplos de arquivos de configuração estão incluídos neste capítulo para referência.</p></div><div class=paragraph><p>No final deste capítulo, os leitores saberão:</p></div><div class=ulist><ul><li><p>Como gerenciar o daemon inetd.</p></li><li><p>Como configurar o Network File System (NFS).</p></li><li><p>Como configurar o Network Information Server (NIS) para centralizar e compartilhar contas de usuários.</p></li><li><p>Como configurar o FreeBSD para funcionar como um servidor ou cliente LDAP</p></li><li><p>Como configurar configurações de rede automáticas usando o DHCP.</p></li><li><p>Como configurar um Domain Name Server (DNS).</p></li><li><p>Como configurar o servidor ApacheHTTP.</p></li><li><p>Como Configurar um Servidor de File Transfer Protocol (FTP).</p></li><li><p>Como configurar um servidor de arquivo e de impressão para clientes Windows™ usando o Samba.</p></li><li><p>Como sincronizar a hora e a data e configurar um servidor de horário usando o Network Time Protocol (NTP).</p></li><li><p>Como configurar o iSCSI.</p></li></ul></div><div class=paragraph><p>Este capítulo pressupõe um conhecimento básico de:</p></div><div class=ulist><ul><li><p>scripts <span class=filename>/etc/rc</span>.</p></li><li><p>Terminologia de rede.</p></li><li><p>Instalação de software adicional de terceiros (<a href=./#ports>Instalando Aplicativos. Pacotes e Ports</a>).</p></li></ul></div></div><div class=sect2><h3 id=network-inetd>29.2. O super-servidor inetd<a class=anchor href=#network-inetd></a></h3><div class=paragraph><p>O daemon <a href="https://man.freebsd.org/cgi/man.cgi?query=inetd&amp;sektion=8&amp;format=html">inetd(8)</a> é algumas vezes chamado de Super-Servidor porque gerencia conexões para muitos serviços. Em vez de iniciar vários aplicativos, apenas o serviço inetd precisa ser iniciado. Quando uma conexão é recebida para um serviço gerenciado pelo inetd, ele determina para qual programa a conexão está destinada, gera um processo para esse programa e delega ao programa um socket. O uso de inetd para serviços que não são muito usados pode reduzir a carga do sistema, quando comparado à execução de cada daemon individualmente no modo independente.</p></div><div class=paragraph><p>Primeiramente, inetd é usado para gerar outros daemons, mas vários protocolos triviais são tratados internamente, como chargen, auth, time, echo, discard e daytime.</p></div><div class=paragraph><p>Esta seção aborda os conceitos básicos da configuração do inetd.</p></div><div class=sect3><h4 id=network-inetd-conf>29.2.1. Arquivo de Configuração<a class=anchor href=#network-inetd-conf></a></h4><div class=paragraph><p>A configuração do inetd é feita editando o <span class=filename>/etc/inetd.conf</span>. Cada linha deste arquivo de configuração representa um aplicativo que pode ser iniciado pelo inetd. Por padrão, cada linha começa com um comentário (<code><mark></mark></code>), o que significa que inetd não está atendendo a nenhum aplicativo. Para configurar o inetd para escutar as conexões de um aplicativo, remova o <code></code> no início da linha desse aplicativo.</p></div><div class=paragraph><p>Depois de salvar suas edições, configure o inetd para iniciar na inicialização do sistema editando o arquivo <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>inetd_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Para iniciar o inetd agora, para que ele ouça o serviço que você configurou, digite:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service inetd start</span></code></pre></div></div><div class=paragraph><p>Uma vez iniciado o inetd, ele precisa ser notificado sempre que uma modificação for feita no arquivo <span class=filename>/etc/inetd.conf</span>:</p></div><div id=network-inetd-reread class=exampleblock><div class=title>Exemplo 45. Recarregando o Arquivo de Configuração do inetd</div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service inetd reload</span></code></pre></div></div></div></div><div class=paragraph><p>Normalmente, a entrada padrão de um aplicativo não precisa ser editada além da remoção do <code>#</code>. Em algumas situações, pode ser apropriado editar a entrada padrão.</p></div><div class=paragraph><p>Como exemplo, esta é a entrada padrão para <a href="https://man.freebsd.org/cgi/man.cgi?query=ftpd&amp;sektion=8&amp;format=html">ftpd(8)</a> sobre o IPv4:</p></div><div class="literalblock programlisting"><div class=content><pre>ftp     stream  tcp     nowait  root    /usr/libexec/ftpd       ftpd -l</pre></div></div><div class=paragraph><p>As sete colunas em uma entrada são as seguintes:</p></div><div class="literalblock programlisting"><div class=content><pre>service-name
socket-type
protocol
{wait|nowait}[/max-child[/max-connections-per-ip-per-minute[/max-child-per-ip]]]
user[:group][/login-class]
server-program
server-program-arguments</pre></div></div><div class=paragraph><p>Onde:</p></div><div class=dlist><dl><dt class=hdlist1>service-name</dt><dd><p>O nome do serviço do daemon para iniciar. Deve corresponder a um serviço listado no arquivo <span class=filename>/etc/services</span>. Isso determina qual porta inetd atende para conexões de entrada para esse serviço. Ao usar um serviço personalizado, ele deve primeiro ser adicionado ao arquivo <span class=filename>/etc/services</span>.</p></dd><dt class=hdlist1>socket-type</dt><dd><p>Ou <code>stream</code>, <code>dgram</code>, <code>raw</code>, ou <code>seqpacket</code>. Use <code>stream</code> para conexões TCP e <code>dgram</code> para serviços UDP.</p></dd><dt class=hdlist1>protocol</dt><dd><p>Use um dos seguintes nomes de protocolo:</p><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Protocol Name</th><th class="tableblock halign-left valign-top">Explicação</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>tcp ou tcp4</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>TCP IPv4</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>udp ou udp4</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>UDP IPv4</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>tcp6</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>TCP IPv6</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>udp6</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>UDP IPv6</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>tcp46</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Ambos TCP IPv4 e IPv6</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>udp46</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Ambos UDP IPv4 e IPv6</p></td></tr></tbody></table></dd><dt class=hdlist1>{wait|nowait}[/max-child[/max-connections-per-ip-per-minute[/max-child-per-ip]]]</dt><dd><p>Neste campo, <code>wait</code> ou <code>nowait</code> deve ser especificado. <code>max-child</code>, <code>max-connections-per-ip-por-minute</code> e <code>max-child-per-ip</code> são opcionais.</p><div class=paragraph><p><code>wait|nowait</code> indica se o serviço pode ou não manipular seu próprio socket. Os tipos de socket <code>dgram</code> devem usar <code>wait</code> enquanto os daemons <code>stream</code>, que geralmente são multi-threaded, devem usar <code>nowait</code>. <code>wait</code> geralmente passa vários sockets para um único daemon, enquanto <code>nowait</code> gera um daemon filho para cada novo socket.</p></div><div class=paragraph><p>O número máximo de daemons inetd que podem aparecer é definido por <code>max-child</code>. Por exemplo, para limitar dez instâncias do daemon, coloque um <code>/10</code> após o <code>nowait</code>. Especificar <code>/0</code> permite um número ilimitado de filhos.</p></div><div class=paragraph><p><code>max-connections-per-ip-per-minute</code> limita o número de conexões de qualquer endereço específico de IP por minuto. Quando o limite for atingido, outras conexões desse endereço IP serão descartadas até o final do minuto. Por exemplo, um valor de <code>/10</code> limitaria qualquer endereço IP específico a dez tentativas de conexão por minuto. <code>max-child-per-ip</code> limita o número de processos-filhos que podem ser iniciados em nome de um único endereço IP a qualquer momento. Essas opções podem limitar o consumo excessivo de recursos e ajudar a impedir ataques de negação de serviço (DoS (Denial Of Service)).</p></div><div class=paragraph><p>Um exemplo pode ser visto nas configurações padrão para <a href="https://man.freebsd.org/cgi/man.cgi?query=fingerd&amp;sektion=8&amp;format=html">fingerd(8)</a>:</p></div><div class="literalblock programlisting"><div class=content><pre>finger stream  tcp     nowait/3/10 nobody /usr/libexec/fingerd fingerd -k -s</pre></div></div></dd><dt class=hdlist1>usuário</dt><dd><p>O nome de usuário que o daemon será executado como. Daemons geralmente são executados como <code>root</code>, <code>daemon</code>, ou <code>nobody</code>.</p></dd><dt class=hdlist1>programa servidor</dt><dd><p>O caminho completo para o daemon. Se o daemon for um serviço fornecido pelo inetd internamente, use <code>internal</code>.</p></dd><dt class=hdlist1>argumentos do programa servidor</dt><dd><p>Usado para especificar qualquer argumento de comando a ser transmitido ao daemon na chamada. Se o daemon for um serviço interno, use <code>internal</code>.</p></dd></dl></div></div><div class=sect3><h4 id=network-inetd-cmdline>29.2.2. Opções de linha de comando<a class=anchor href=#network-inetd-cmdline></a></h4><div class=paragraph><p>Como a maioria dos daemons de servidor, o inetd tem várias opções que podem ser usadas para modificar seu comportamento. Por padrão, inetd é iniciado com <code>-wW -C 60</code>. Essas opções ativam TCP wrappers para todos os serviços, incluindo serviços internos, e impedem que qualquer endereço de IP solicite qualquer serviço mais de 60 vezes por minuto.</p></div><div class=paragraph><p>Para alterar as opções padrão que são passadas para inetd, adicione uma entrada para <code>inetd_flags</code> no arquivo <span class=filename>/etc/rc.conf</span>. Se o inetd já estiver em execução, reinicie-o com <code>service inetd restart</code>.</p></div><div class=paragraph><p>As opções disponíveis de limitação de taxa são:</p></div><div class=dlist><dl><dt class=hdlist1>-c máximo</dt><dd><p>Especifique o número máximo padrão de chamadas simultâneas de cada serviço, em que o padrão é ilimitado. Pode ser sobrescrito com base no serviço usando <code>max-child</code> em <span class=filename>/etc/inetd.conf</span>.</p></dd><dt class=hdlist1>-C taxa</dt><dd><p>Especifique o número máximo padrão de vezes por minuto que um serviço pode ser chamado a partir de um único endereço de IP. Pode ser substituído com base no serviço usando <code>max-connections-per-ip-por-minute</code> em <span class=filename>/etc/inetd.conf</span>.</p></dd><dt class=hdlist1>-R taxa</dt><dd><p>Especifique o número máximo de vezes que um serviço pode ser chamado em um minuto, em que o padrão é <code>256</code>. Uma taxa de <code>0</code> permite um número ilimitado.</p></dd><dt class=hdlist1>-s máximo</dt><dd><p>Especifique o número máximo de vezes que um serviço pode ser chamado a partir de um único endereço IP a qualquer momento, em que o padrão é ilimitado. Pode ser sobrescrito com base no serviço usando <code>max-child-per-ip</code> no arquivo <span class=filename>/etc/inetd.conf</span>.</p></dd></dl></div><div class=paragraph><p>Opções adicionais estão disponíveis. Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=inetd&amp;sektion=8&amp;format=html">inetd(8)</a> para a lista completa de opções.</p></div></div><div class=sect3><h4 id=network-inetd-security>29.2.3. Considerações de segurança<a class=anchor href=#network-inetd-security></a></h4><div class=paragraph><p>Muitos dos daemons que podem ser gerenciados pelo inetd não são conscientes da segurança. Alguns daemons, como fingerd, podem fornecer informações que podem ser úteis para um invasor. Ative apenas os serviços necessários e monitore o sistema para tentativas excessivas de conexão. <code>max-connections-per-ip-por-minute</code>, <code>max-child</code> e <code>max-child-per-ip</code> podem ser usados para limitar tais ataques.</p></div><div class=paragraph><p>Por padrão, TCP wrappers estão ativados. Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=hosts_access&amp;sektion=5&amp;format=html">hosts_access(5)</a> para obter mais informações sobre como colocar restrições TCP em vários daemons chamados pelo inetd.</p></div></div></div><div class=sect2><h3 id=network-nfs>29.3. Network File System (NFS)<a class=anchor href=#network-nfs></a></h3><div class=paragraph><p>O FreeBSD suporta o Network File System (NFS), que permite que um servidor compartilhe diretórios e arquivos com clientes através de uma rede. Com o NFS, os usuários e programas podem acessar arquivos em sistemas remotos como se estivessem armazenados localmente.</p></div><div class=paragraph><p>NFS tem muitos usos práticos. Alguns dos usos mais comuns incluem:</p></div><div class=ulist><ul><li><p>Os dados que seriam duplicados em cada cliente podem ser mantidos em um único local e acessados por clientes na rede.</p></li><li><p>Vários clientes podem precisar de acesso ao diretório <span class=filename>/usr/ports/distfiles</span>. Compartilhar esse diretório permite acesso rápido aos arquivos fonte sem precisar baixá-los para cada cliente.</p></li><li><p>Em grandes redes, geralmente é mais conveniente configurar um servidor central NFS no qual todos os diretórios home dos usuários são armazenados. Os usuários podem logar em um cliente em qualquer lugar da rede e ter acesso aos seus diretórios home.</p></li><li><p>A administração de exports do NFS é simplificada. Por exemplo, há apenas um sistema de arquivos no qual as políticas de segurança ou de backup devem ser definidas.</p></li><li><p>Dispositivos removíveis de armazenamento de mídia podem ser usados por outras máquinas na rede. Isso reduz o número de dispositivos em toda a rede e fornece um local centralizado para gerenciar sua segurança. Geralmente, é mais conveniente instalar software em várias máquinas a partir de uma mídia de instalação centralizada.</p></li></ul></div><div class=paragraph><p>O NFS consiste em um servidor e um ou mais clientes. O cliente acessa remotamente os dados armazenados na máquina do servidor. Para que isso funcione corretamente, alguns processos precisam ser configurados e executados.</p></div><div class=paragraph><p>Esses daemons devem estar em execução no servidor:</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Daemon</th><th class="tableblock halign-left valign-top">Descrição</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>nfsd</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>O daemon NFS que atende a solicitações de clientes NFS.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>mountd</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>O daemon de montagem do NFS que realiza solicitações recebidas do nfsd.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>rpcbind</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Este daemon permite que clientes NF descubram qual porta o servidor NFS está usando.</p></td></tr></tbody></table><div class=paragraph><p>A execução de <a href="https://man.freebsd.org/cgi/man.cgi?query=nfsiod&amp;sektion=8&amp;format=html">nfsiod(8)</a> no cliente pode melhorar o desempenho, mas não é necessária.</p></div><div class=sect3><h4 id=network-configuring-nfs>29.3.1. Configurando o Servidor<a class=anchor href=#network-configuring-nfs></a></h4><div class=paragraph><p>Os sistemas de arquivos que o servidor NFS irá compartilhar são especificados no arquivo <span class=filename>/etc/exports</span>. Cada linha neste arquivo especifica um sistema de arquivos a ser exportado, quais clientes têm acesso a esse sistema de arquivos e quaisquer opções de acesso. Ao adicionar entradas a este arquivo, cada sistema de arquivos exportado, suas propriedades e hosts permitidos devem ocorrer em uma única linha. Se nenhum cliente estiver listado na entrada, qualquer cliente na rede poderá montar esse sistema de arquivos.</p></div><div class=paragraph><p>As seguintes entradas no arquivo <span class=filename>/etc/exports</span> demonstram como exportar sistemas de arquivos. Os exemplos podem ser modificados para corresponder aos sistemas de arquivos e nomes de clientes na rede do leitor. Existem muitas opções que podem ser usadas neste arquivo, mas apenas algumas serão mencionadas aqui. Veja <a href="https://man.freebsd.org/cgi/man.cgi?query=exports&amp;sektion=5&amp;format=html">exports(5)</a> para a lista completa de opções.</p></div><div class=paragraph><p>Este exemplo mostra como exportar <span class=filename>/cdrom</span> para três hosts chamados <em>alpha</em>, <em>bravo</em> e <em>charlie</em>:</p></div><div class="literalblock programlisting"><div class=content><pre>/cdrom -ro alpha bravo charlie</pre></div></div><div class=paragraph><p>A flag <code>-ro</code> torna o sistema de arquivos somente leitura, impedindo que os clientes façam alterações no sistema de arquivos exportado. Este exemplo assume que os nomes de host estão no DNS ou no arquivo <span class=filename>/etc/hosts</span>. Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=hosts&amp;sektion=5&amp;format=html">hosts(5)</a> se a rede não tiver um servidor de DNS.</p></div><div class=paragraph><p>O próximo exemplo exporta <span class=filename>/home</span> para três clientes pelo endereço IP. Isso pode ser útil para redes sem DNS ou <span class=filename>/etc/hosts</span>. A flag <code>-alldirs</code> permite que os subdiretórios sejam pontos de montagem. Em outras palavras, ele não montará automaticamente os subdiretórios, mas permitirá que o cliente monte os diretórios necessários conforme necessário.</p></div><div class="literalblock programlisting"><div class=content><pre>/usr/home  -alldirs  10.0.0.2 10.0.0.3 10.0.0.4</pre></div></div><div class=paragraph><p>Este próximo exemplo exporta <span class=filename>/a</span> para que dois clientes de domínios diferentes possam acessar esse sistema de arquivos. <code>-maproot=root</code> permite que o usuário <code>root</code> no sistema remoto grave os dados no sistema de arquivos exportado como <code>root</code>. Se <code>-maproot=root</code> não for especificado, o usuário <code>root</code> do cliente será mapeado para a conta <code>nobody</code> do servidor e estará sujeito às limitações de acesso definidas para <code>nobody</code>.</p></div><div class="literalblock programlisting"><div class=content><pre>/a  -maproot=root  host.example.com box.example.org</pre></div></div><div class=paragraph><p>Um cliente só pode ser especificado uma vez por sistema de arquivos. Por exemplo, se <span class=filename>/usr</span> for um único sistema de arquivos, essas entradas serão inválidas, já que ambas as entradas especificam o mesmo host:</p></div><div class="literalblock programlisting"><div class=content><pre># Invalid when /usr is one file system
/usr/src   client
/usr/ports client</pre></div></div><div class=paragraph><p>O formato correto para essa situação é usar uma entrada:</p></div><div class="literalblock programlisting"><div class=content><pre>/usr/src /usr/ports  client</pre></div></div><div class=paragraph><p>A seguir, um exemplo de uma lista de exportação válida, em que <span class=filename>/usr</span> e <span class=filename>/exports</span> são sistemas de arquivos locais:</p></div><div class="literalblock programlisting"><div class=content><pre># Export src and ports to client01 and client02, but only
# client01 has root privileges on it
/usr/src /usr/ports -maproot=root    client01
/usr/src /usr/ports               client02
# The client machines have root and can mount anywhere
# on /exports. Anyone in the world can mount /exports/obj read-only
/exports -alldirs -maproot=root      client01 client02
/exports/obj -ro</pre></div></div><div class=paragraph><p>Para habilitar os processos requeridos pelo servidor NFS no momento da inicialização, adicione estas opções ao arquivo <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>rpcbind_enable=&#34;YES&#34;
nfs_server_enable=&#34;YES&#34;
mountd_enable=&#34;YES</pre></div></div><div class=paragraph><p>O servidor pode ser iniciado agora executando este comando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service nfsd start</span></code></pre></div></div><div class=paragraph><p>Sempre que o servidor NFS for iniciado, o mountd também é iniciado automaticamente. No entanto, mountd lê apenas <span class=filename>/etc/exports</span> quando é iniciado. Para fazer as edições subsequentes de <span class=filename>/etc/exports</span> entrarem em vigor imediatamente, force mountd para ler novamente:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service mountd reload</span></code></pre></div></div></div><div class=sect3><h4 id=_configurando_o_cliente>29.3.2. Configurando o Cliente<a class=anchor href=#_configurando_o_cliente></a></h4><div class=paragraph><p>Para ativar clientes NFS, defina essa opção no arquivo <span class=filename>/etc/rc.conf</span> de cada cliente:</p></div><div class="literalblock programlisting"><div class=content><pre>nfs_client_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Em seguida, execute este comando em cada cliente NFS:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service nfsclient start</span></code></pre></div></div><div class=paragraph><p>O cliente agora tem tudo de que precisa para montar um sistema de arquivos remoto. Nestes exemplos, o nome do servidor é <code>server</code> e o nome do cliente é <code>client</code>. Para montar <span class=filename>/home</span> no <code>server</code> para o ponto de montagem <span class=filename>/mnt</span> no <code>client</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount server:/home /mnt</span></code></pre></div></div><div class=paragraph><p>Os arquivos e diretórios em <span class=filename>/home</span> agora estarão disponíveis no <code>client</code>, no diretório <span class=filename>/mnt</span>.</p></div><div class=paragraph><p>Para montar um sistema de arquivos remoto toda vez que o cliente for inicializado, adicione-o ao arquivo <span class=filename>/etc/fstab</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>server:/home	/mnt	nfs	rw	0	0</pre></div></div><div class=paragraph><p>Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=fstab&amp;sektion=5&amp;format=html">fstab(5)</a> para obter uma descrição de todas as opções disponíveis.</p></div></div><div class=sect3><h4 id=_bloqueando>29.3.3. Bloqueando<a class=anchor href=#_bloqueando></a></h4><div class=paragraph><p>Alguns aplicativos exigem o bloqueio de arquivos para funcionar corretamente. Para ativar o bloqueio, adicione estas linhas ao arquivo <span class=filename>/etc/rc.conf</span> no cliente e no servidor:</p></div><div class="literalblock programlisting"><div class=content><pre>rpc_lockd_enable=&#34;YES&#34;
rpc_statd_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Então inicie as aplicações:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service lockd start</span>
<span class=c># service statd start</span></code></pre></div></div><div class=paragraph><p>Se o bloqueio não for necessário no servidor, o cliente NFS pode ser configurado para bloquear localmente incluindo <code>-L</code> ao executar o mount. Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=mount_nfs&amp;sektion=8&amp;format=html">mount_nfs(8)</a> para mais detalhes.</p></div></div><div class=sect3><h4 id=network-autofs>29.3.4. Automatizando Montagens com <a href="https://man.freebsd.org/cgi/man.cgi?query=autofs&amp;sektion=5&amp;format=html">autofs(5)</a><a class=anchor href=#network-autofs></a></h4><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>O recurso de montagem automática <a href="https://man.freebsd.org/cgi/man.cgi?query=autofs&amp;sektion=5&amp;format=html">autofs(5)</a> é suportado a partir do FreeBSD 10.1-RELEASE. Para usar a funcionalidade automounter em versões mais antigas do FreeBSD, use <a href="https://man.freebsd.org/cgi/man.cgi?query=amd&amp;sektion=8&amp;format=html">amd(8)</a>. Este capítulo descreve apenas o montador automático <a href="https://man.freebsd.org/cgi/man.cgi?query=autofs&amp;sektion=5&amp;format=html">autofs(5)</a>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>O recurso <a href="https://man.freebsd.org/cgi/man.cgi?query=autofs&amp;sektion=5&amp;format=html">autofs(5)</a> é um nome comum para vários componentes que, juntos, permitem a montagem automática de sistemas de arquivos locais e remotos sempre que um arquivo ou diretório dentro desse sistema de arquivos é acessado. Ele consiste no componente do kernel, <a href="https://man.freebsd.org/cgi/man.cgi?query=autofs&amp;sektion=5&amp;format=html">autofs(5)</a> e vários aplicativos no espaço do usuário: <a href="https://man.freebsd.org/cgi/man.cgi?query=automount&amp;sektion=8&amp;format=html">automount(8)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=automountd&amp;sektion=8&amp;format=html">automountd(8)</a> e <a href="https://man.freebsd.org/cgi/man.cgi?query=autounmountd&amp;sektion=8&amp;format=html">autounmountd(8)</a>. Ele serve como uma alternativa para <a href="https://man.freebsd.org/cgi/man.cgi?query=amd&amp;sektion=8&amp;format=html">amd(8)</a> de versões anteriores do FreeBSD. Amd ainda é fornecido para fins de compatibilidade com versões anteriores, já que os dois usam formato de mapeamento diferentes; o usado pelo autofs é o mesmo que com outros automontadores do SVR4, como os do Solaris, MacOS X e Linux.</p></div><div class=paragraph><p>O sistema de arquivos virtual <a href="https://man.freebsd.org/cgi/man.cgi?query=autofs&amp;sektion=5&amp;format=html">autofs(5)</a> é montado em pontos de montagem especificados por <a href="https://man.freebsd.org/cgi/man.cgi?query=automount&amp;sektion=8&amp;format=html">automount(8)</a>, geralmente chamado durante a inicialização.</p></div><div class=paragraph><p>Sempre que um processo tentar acessar o arquivo dentro do ponto de montagem <a href="https://man.freebsd.org/cgi/man.cgi?query=autofs&amp;sektion=&amp;format=html">autofs()</a>, o kernel notificará o daemon <a href="https://man.freebsd.org/cgi/man.cgi?query=automountd&amp;sektion=8&amp;format=html">automountd(8)</a> e irá pausar o processo de disparo. O daemon <a href="https://man.freebsd.org/cgi/man.cgi?query=automountd&amp;sektion=8&amp;format=html">automountd(8)</a> processará as solicitações do kernel localizando o mapeamento apropriado e irá montar o sistema de arquivos de acordo com ele, então sinaliza ao kernel para liberar o processo bloqueado . O daemon <a href="https://man.freebsd.org/cgi/man.cgi?query=autounmountd&amp;sektion=8&amp;format=html">autounmountd(8)</a> desmonta automaticamente os sistemas de arquivos montados automaticamente após algum tempo, a menos que eles ainda estejam sendo usados.</p></div><div class=paragraph><p>O arquivo de configuração principal do autofs é o <span class=filename>/etc/auto_master</span>. Atribui mapeamentos individuais a montagens de nível superior. Para uma explicação do <span class=filename>auto_master</span> e da sintaxe do mapeamento, consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=auto_master&amp;sektion=5&amp;format=html">auto_master(5)</a>.</p></div><div class=paragraph><p>Existe um mapeamento especial montado automaticamente em <span class=filename>/net</span>. Quando um arquivo é acessado dentro desse diretório, o <a href="https://man.freebsd.org/cgi/man.cgi?query=autofs&amp;sektion=5&amp;format=html">autofs(5)</a> procura a montagem remota correspondente e monta-a automaticamente. Por exemplo, uma tentativa de acessar um arquivo dentro de <span class=filename>/net/foobar/usr</span> informaria <a href="https://man.freebsd.org/cgi/man.cgi?query=automountd&amp;sektion=8&amp;format=html">automountd(8)</a> para montar a exportação <span class=filename>/usr</span> do host <code>foobar</code>.</p></div><div class=exampleblock><div class=title>Exemplo 46. Montando uma Exportação com <a href="https://man.freebsd.org/cgi/man.cgi?query=autofs&amp;sektion=5&amp;format=html">autofs(5)</a></div><div class=content><div class=paragraph><p>Neste exemplo, <code>showmount -e</code> mostra os sistemas de arquivos exportados que podem ser montados a partir do servidor NFS, <code>foobar</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% showmount <span class=nt>-e</span> foobar
Exports list on foobar:
/usr                               10.10.10.0
/a                                 10.10.10.0
% <span class=nb>cd</span> /net/foobar/usr</code></pre></div></div></div></div><div class=paragraph><p>A saída de <code>showmount</code> mostra <span class=filename>/usr</span> como uma exportação. Ao alterar os diretórios para <span class=filename>/host/foobar/usr</span>, o <a href="https://man.freebsd.org/cgi/man.cgi?query=automountd&amp;sektion=8&amp;format=html">automountd(8)</a> intercepta o pedido e tenta resolver o nome do host <code>foobar</code>. Se for bem-sucedido, <a href="https://man.freebsd.org/cgi/man.cgi?query=automountd&amp;sektion=8&amp;format=html">automountd(8)</a> montará automaticamente a exportação de origem.</p></div><div class=paragraph><p>Para habilitar <a href="https://man.freebsd.org/cgi/man.cgi?query=autofs&amp;sektion=5&amp;format=html">autofs(5)</a> no momento da inicialização, adicione esta linha ao arquivo <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>autofs_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Em seguida, <a href="https://man.freebsd.org/cgi/man.cgi?query=autofs&amp;sektion=5&amp;format=html">autofs(5)</a> pode ser iniciado executando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service automount start</span>
<span class=c># service automountd start</span>
<span class=c># service autounmountd start</span></code></pre></div></div><div class=paragraph><p>O formato de mapeamento de <a href="https://man.freebsd.org/cgi/man.cgi?query=autofs&amp;sektion=5&amp;format=html">autofs(5)</a> é o mesmo que em outros sistemas operacionais. Informações sobre este formato de outras fontes podem ser úteis, como o <a href=http://web.archive.org/web/20160813071113/http://images.apple.com/business/docs/Autofs.pdf>documento do Mac OS X</a>.</p></div><div class=paragraph><p>Consulte as páginas de manuais <a href="https://man.freebsd.org/cgi/man.cgi?query=automount&amp;sektion=8&amp;format=html">automount(8)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=automountd&amp;sektion=8&amp;format=html">automountd(8)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=autounmountd&amp;sektion=8&amp;format=html">autounmountd(8)</a> e <a href="https://man.freebsd.org/cgi/man.cgi?query=auto_master&amp;sektion=5&amp;format=html">auto_master(5)</a> para maiores informações.</p></div></div></div><div class=sect2><h3 id=network-nis>29.4. Sistema de Informação de Rede (NIS)<a class=anchor href=#network-nis></a></h3><div class=paragraph><p>O Network Information System (NIS) foi projetado para centralizar a administração de sistemas UNIX™ como Solaris™, HP-UX, AIX™, Linux, NetBSD, OpenBSD e FreeBSD. O NIS era originalmente conhecido como Yellow Pages, mas o nome foi alterado devido a problemas de marca registrada. Esta é a razão pela qual os comandos do NIS começam com <code>yp</code>.</p></div><div class=paragraph><p>O NIS é um sistema cliente/servidor baseado em Remote Procedure Call (RPC) que permite que um grupo de máquinas dentro de um domínio NIS compartilhe um conjunto de arquivos de configuração. Isso permite que um administrador do sistema configure sistemas clientes NIS com apenas dados mínimos de configuração e adicione, remova ou modifique dados de configuração de um único local.</p></div><div class=paragraph><p>O FreeBSD usa a versão 2 do protocolo NIS.</p></div><div class=sect3><h4 id=_termos_do_nis_e_processos>29.4.1. Termos do NIS e Processos<a class=anchor href=#_termos_do_nis_e_processos></a></h4><div class=paragraph><p>A Tabela 28.1 resume os termos e processos importantes usados pelo NIS:</p></div><table class="tableblock frame-none grid-all stretch"><caption class=title>Tabela 23. Terminologia do NIS</caption><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Termo</th><th class="tableblock halign-left valign-top">Descrição</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>nome de domínio NIS</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Os servidores e clientes do NIS compartilham um nome de domínio NIS. Normalmente, esse nome não tem nada a ver com DNS.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href="https://man.freebsd.org/cgi/man.cgi?query=rpcbind&amp;sektion=8&amp;format=html">rpcbind(8)</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Este serviço habilita o RPC e deve estar rodando para rodar um servidor NIS ou atuar como um cliente NIS.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href="https://man.freebsd.org/cgi/man.cgi?query=ypbind&amp;sektion=8&amp;format=html">ypbind(8)</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Este serviço liga um cliente NIS ao seu servidor NIS. Ele levará o nome de domínio NIS e usará RPC para se conectar ao servidor. É o núcleo da comunicação cliente/servidor em um ambiente NIS. Se este serviço não estiver sendo executado em uma máquina cliente, ele não poderá acessar o servidor NIS.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href="https://man.freebsd.org/cgi/man.cgi?query=ypserv&amp;sektion=8&amp;format=html">ypserv(8)</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Este é o processo para o servidor NIS. Se este serviço parar de funcionar, o servidor não poderá mais responder aos pedidos do NIS, portanto, esperamos que exista um servidor slave para assumir o controle. Alguns clientes não-FreeBSD não tentarão se reconectar usando um servidor slave e o processo ypbind pode precisar ser reiniciado nesses clientes.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href="https://man.freebsd.org/cgi/man.cgi?query=rpc.yppasswdd&amp;sektion=8&amp;format=html">rpc.yppasswdd(8)</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Este processo só é executado em servidores principais de NIS. Este daemon permite que clientes NIS alterem suas senhas do NIS. Se este daemon não estiver rodando, os usuários terão que acessar o servidor principal do NIS e alterar suas senhas lá.</p></td></tr></tbody></table></div><div class=sect3><h4 id=_tipos_de_máquinas>29.4.2. Tipos de Máquinas<a class=anchor href=#_tipos_de_máquinas></a></h4><div class=paragraph><p>Existem três tipos de hosts em um ambiente NIS:</p></div><div class=ulist><ul><li><p>Servidor NIS master</p><div class=paragraph><p>Esse servidor atua como um repositório central para as informações de configuração do host e mantém a cópia autoritativa dos arquivos usados por todos os clientes do NIS. O <span class=filename>passwd</span>, o <span class=filename>group</span> e outros arquivos usados pelos clientes do NIS são armazenados no servidor master. Embora seja possível que uma máquina seja um servidor NIS master para mais de um domínio NIS, esse tipo de configuração não será abordado neste capítulo, pois pressupõe ambiente NIS de pequena escala.</p></div></li><li><p>Servidores NIS slave</p><div class=paragraph><p>Os servidores slaves do NIS mantêm cópias dos arquivos de dados do master do NIS para fornecer redundância. Os servidores slaves também ajudam a balancear a carga do servidor master, pois os clientes do NIS sempre se conectam ao servidor do NIS que responde primeiro.</p></div></li><li><p>Clientes NIS</p><div class=paragraph><p>Os clientes do NIS autenticam-se contra o servidor NIS durante o logon.</p></div></li></ul></div><div class=paragraph><p>Informações em muitos arquivos podem ser compartilhadas usando o NIS . Os arquivos <span class=filename>master.passwd</span>, <span class=filename>group</span> e <span class=filename>hosts</span> são comumente compartilhados via NIS. Sempre que um processo em um cliente precisa de informações que normalmente seriam encontradas nesses arquivos localmente, ele faz uma consulta ao servidor NIS ao qual está vinculado.</p></div></div><div class=sect3><h4 id=_considerações_de_planejamento>29.4.3. Considerações de Planejamento<a class=anchor href=#_considerações_de_planejamento></a></h4><div class=paragraph><p>Esta seção descreve um ambiente NIS de exemplo que consiste em 15 máquinas FreeBSD sem ponto de administração centralizado. Cada máquina tem seu próprio <span class=filename>/etc/passwd</span> e <span class=filename>/etc/master.passwd</span>. Esses arquivos são mantidos em sincronia entre si somente por meio de intervenção manual. Atualmente, quando um usuário é adicionado ao laboratório, o processo deve ser repetido em todas as 15 máquinas.</p></div><div class=paragraph><p>A configuração do laboratório será a seguinte:</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Nome da maquina</th><th class="tableblock halign-left valign-top">Endereço IP</th><th class="tableblock halign-left valign-top">Role da máquina</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>ellington</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>10.0.0.2</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>NIS master</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>coltrane</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>10.0.0.3</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>NIS slave</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>basie</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>10.0.0.4</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Estação de Trabalho da Facultativa</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>bird</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>10.0.0.5</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Máquina Cliente</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>cli[1-11]</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>10.0.0.[6-17]</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Outras Máquinas Clientes</p></td></tr></tbody></table><div class=paragraph><p>Se esta é a primeira vez que um esquema de NIS está sendo desenvolvido, ele deve ser cuidadosamente planejado através do tempo. Independentemente do tamanho da rede, várias decisões precisam ser tomadas como parte do processo de planejamento.</p></div><div class=sect4><h5 id=_escolhendo_um_nome_de_domínio_nis>29.4.3.1. Escolhendo um Nome de Domínio NIS<a class=anchor href=#_escolhendo_um_nome_de_domínio_nis></a></h5><div class=paragraph><p>Quando um cliente transmite suas solicitações de informações, ele inclui o nome do domínio NIS do qual faz parte. É assim que vários servidores em uma rede podem informar qual servidor deve responder a qual solicitação. Pense no nome de domínio NIS como o nome de um grupo de hosts.</p></div><div class=paragraph><p>Algumas organizações optam por usar o nome de domínio da Internet para o nome de domínio NIS. Isso não é recomendado, pois pode causar confusão ao tentar depurar problemas de rede. O nome de domínio NIS deve ser único dentro da rede e é útil se ele descrever o grupo de máquinas que representa. Por exemplo, o departamento de Arte da Acme Inc. pode estar no domínio NIS"acme-art". Este exemplo usará o nome de domínio <code>test-domain</code>.</p></div><div class=paragraph><p>No entanto, alguns sistemas operacionais não-FreeBSD exigem que o nome de domínio NIS seja o mesmo que o nome de domínio da Internet. Se uma ou mais máquinas na rede tiverem essa restrição, o nome de domínio da Internet <em>deve</em> ser usado como o nome de domínio NIS.</p></div></div><div class=sect4><h5 id=_requisitos_físicos_do_servidor>29.4.3.2. Requisitos Físicos do Servidor<a class=anchor href=#_requisitos_físicos_do_servidor></a></h5><div class=paragraph><p>Há várias coisas que você deve ter em mente ao escolher uma máquina para usar como um servidor NIS. Como os clientes do NIS dependem da disponibilidade do servidor, escolha uma máquina que não seja reinicializada com freqüência. O servidor do NIS deve idealmente ser uma máquina autônoma cujo único propósito seja ser um servidor NIS. Se a rede não for muito usada, é aceitável colocar o servidor NIS em uma máquina que executa outros serviços. No entanto, se o servidor NIS ficar indisponível, isso afetará negativamente todos os clientes NIS.</p></div></div></div><div class=sect3><h4 id=_configurando_o_servidor_nis_master>29.4.4. Configurando o Servidor NIS Master<a class=anchor href=#_configurando_o_servidor_nis_master></a></h4><div class=paragraph><p>As cópias canônicas de todos os arquivos NIS são armazenadas no servidor master. Os bancos de dados usados para armazenar as informações são chamados de mapas de NIS. No FreeBSD, estes mapas são armazenados em <span class=filename>/var/yp/[nome_do_domínio]</span> onde <span class=filename>[nome_do_dominio]</span> é o nome do domínio NIS. Como vários domínios são suportados, é possível ter vários diretórios, um para cada domínio. Cada domínio terá seu próprio conjunto independente de mapas.</p></div><div class=paragraph><p>Os servidores master e slave do NIS lidam com todas as requisições NIS através do <a href="https://man.freebsd.org/cgi/man.cgi?query=ypserv&amp;sektion=8&amp;format=html">ypserv(8)</a>. Esse daemon é responsável por receber solicitações de entrada de clientes NIS, traduzindo o domínio e o nome do mapa solicitados para um caminho para o arquivo de banco de dados correspondente e transmitindo dados do banco de dados de volta ao cliente.</p></div><div class=paragraph><p>Configurar um servidor NIS master pode ser relativamente simples, dependendo das necessidades ambientais. Como o FreeBSD oferece suporte a NIS embutido, ele só precisa ser ativado adicionando as seguintes linhas ao arquivo <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>nisdomainname=&#34;test-domain&#34;	<i class=conum data-value=1></i><b>(1)</b>
nis_server_enable=&#34;YES&#34;		<i class=conum data-value=2></i><b>(2)</b>
nis_yppasswdd_enable=&#34;YES&#34;	<i class=conum data-value=3></i><b>(3)</b></pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>Esta linha define o nome de domínio NIS para <code>test-domain</code>.</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td>Isto automatiza o início dos processos do servidor NIS quando o sistema é inicializado.</td></tr><tr><td><i class=conum data-value=3></i><b>3</b></td><td>Isso habilita o daemon <a href="https://man.freebsd.org/cgi/man.cgi?query=rpc.yppasswdd&amp;sektion=8&amp;format=html">rpc.yppasswdd(8)</a> para que os usuários possam alterar sua senha NIS de uma máquina cliente.</td></tr></tbody></table></div><div class=paragraph><p>É preciso ter cuidado em um domínio com vários servidores, no qual as máquinas do servidor também são clientes NIS. Geralmente, é uma boa ideia forçar os servidores a fazerem bind em si mesmos, em vez de permitir que eles transmitam solicitações de bind e, possivelmente, fiquem vinculados um ao outro. Modos de falha estranhos podem ocorrer se um servidor cair e outros dependerem dele. Eventualmente, todos os clientes terão tempo limite e tentarão fazer bind em outros servidores, mas o atraso envolvido poderá ser considerável e o modo de falha ainda estará presente, uma vez que os servidores podem ligar-se entre si novamente.</p></div><div class=paragraph><p>Um servidor que também é um cliente pode ser forçado fazer bind em um servidor em particular adicionando estas linhas adicionais ao arquivo <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>nis_client_enable=&#34;YES&#34;				<i class=conum data-value=1></i><b>(1)</b>
nis_client_flags=&#34;-S test-domain,server&#34;	<i class=conum data-value=2></i><b>(2)</b></pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>Isso permite rodar coisas do cliente também.</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td>Esta linha define o nome de domínio NIS para test-domain e vincula para si mesmo.</td></tr></tbody></table></div><div class=paragraph><p>Depois de salvar as edições, digite <code>/etc/netstart</code> para reiniciar a rede e aplicar os valores definidos no arquivo <span class=filename>/etc/rc.conf</span>. Antes de inicializar os mapas de NIS, inicie <a href="https://man.freebsd.org/cgi/man.cgi?query=ypserv&amp;sektion=8&amp;format=html">ypserv(8)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service ypserv start</span></code></pre></div></div><div class=sect4><h5 id=_inicializando_os_mapas_do_nis>29.4.4.1. Inicializando os mapas do NIS<a class=anchor href=#_inicializando_os_mapas_do_nis></a></h5><div class=paragraph><p>Os mapeamentos NIS são gerados a partir dos arquivos de configuração no diretório <span class=filename>/etc</span> no NIS master, com uma exceção: <span class=filename>/etc/master.passwd</span>. Isso evita a propagação de senhas para todos os servidores no domínio NIS. Portanto, antes de inicializar os mapas do NIS, configure os arquivos de senha primários:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cp /etc/master.passwd /var/yp/master.passwd</span>
<span class=c># cd /var/yp</span>
<span class=c># vi master.passwd</span></code></pre></div></div><div class=paragraph><p>É aconselhável remover todas as entradas de contas do sistema, bem como quaisquer contas de usuário que não precisem ser propagadas para os clientes do NIS, como o <code>root</code> e quaisquer outras contas administrativas.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Assegure-se de que o arquivo <span class=filename>/var/yp/master.passwd</span> não seja de grupo nem de mundo legível, definindo suas permissões para <code>600</code>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Depois de concluir esta tarefa, inicialize os mapas do NIS. O FreeBSD inclui o script <a href="https://man.freebsd.org/cgi/man.cgi?query=ypinit&amp;sektion=8&amp;format=html">ypinit(8)</a> para fazer isso. Ao gerar mapas para o servidor master, inclua <code>-m</code> e especifique o nome de domínio NIS:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>ellington# ypinit <span class=nt>-m</span> test-domain
Server Type: MASTER Domain: test-domain
Creating an YP server will require that you answer a few questions.
Questions will all be asked at the beginning of the procedure.
Do you want this procedure to quit on non-fatal errors? <span class=o>[</span>y/n: n] n
Ok, please remember to go back and redo manually whatever fails.
If not, something might not work.
At this point, we have to construct a list of this domains YP servers.
rod.darktech.org is already known as master server.
Please <span class=k>continue </span>to add any slave servers, one per line. When you are
<span class=k>done </span>with the list, <span class=nb>type </span>a &lt;control D&gt;.
master server   :  ellington
next host to add:  coltrane
next host to add:  ^D
The current list of NIS servers looks like this:
ellington
coltrane
Is this correct?  <span class=o>[</span>y/n: y] y

<span class=o>[</span>..output from map generation..]

NIS Map update completed.
ellington has been setup as an YP master server without any errors.</code></pre></div></div><div class=paragraph><p>Isto irá criar <span class=filename>/var/yp/Makefile</span> a partir de <span class=filename>/var/yp/Makefile.dist</span>. Por padrão, este arquivo assume que o ambiente tem um único servidor NIS com apenas clientes FreeBSD. Como <code>test-domain</code> tem um servidor slave, edite esta linha no arquivo <span class=filename>/var/yp/Makefile</span> para que comece com um comentário (<code>#</code>) :</p></div><div class="literalblock programlisting"><div class=content><pre>NOPUSH = &#34;True&#34;</pre></div></div></div><div class=sect4><h5 id=_adicionando_novos_usuários>29.4.4.2. Adicionando novos usuários<a class=anchor href=#_adicionando_novos_usuários></a></h5><div class=paragraph><p>Toda vez que um novo usuário é criado, a conta de usuário deve ser adicionada ao servidor mestre NIS e aos mapeamentos do NIS reconstruídos. Até que isso ocorra, o novo usuário não poderá efetuar login em nenhum lugar, exceto no NIS master. Por exemplo, para adicionar o novo usuário <code>jsmith</code> ao domínio <code>test-domain</code>, execute estes comandos no servidor master:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pw useradd jsmith</span>
<span class=c># cd /var/yp</span>
<span class=c># make test-domain</span></code></pre></div></div><div class=paragraph><p>O usuário também pode ser adicionado usando <code>adduser jsmith</code> em vez de <code>pw useradd smith</code>.</p></div></div></div><div class=sect3><h4 id=_configurando_um_servidor_nis_slave>29.4.5. Configurando um Servidor NIS Slave<a class=anchor href=#_configurando_um_servidor_nis_slave></a></h4><div class=paragraph><p>Para configurar um servidor NIS slave, faça o logon no servidor slave e edite o arquivo <span class=filename>/etc/rc.conf</span> assim como para o servidor master. Não gere nenhum mapa de NIS, pois estes já existem no servidor master. Ao executar <code>ypinit</code> no servidor slave, use <code>-s</code> (para slave) ao invés de <code>-m</code> (para master). Esta opção requer o nome do NIS master, além do nome do domínio, como visto neste exemplo:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>coltrane# ypinit <span class=nt>-s</span> ellington test-domain

Server Type: SLAVE Domain: test-domain Master: ellington

Creating an YP server will require that you answer a few questions.
Questions will all be asked at the beginning of the procedure.

Do you want this procedure to quit on non-fatal errors? <span class=o>[</span>y/n: n]  n

Ok, please remember to go back and redo manually whatever fails.
If not, something might not work.
There will be no further questions. The remainder of the procedure
should take a few minutes, to copy the databases from ellington.
Transferring netgroup...
ypxfr: Exiting: Map successfully transferred
Transferring netgroup.byuser...
ypxfr: Exiting: Map successfully transferred
Transferring netgroup.byhost...
ypxfr: Exiting: Map successfully transferred
Transferring master.passwd.byuid...
ypxfr: Exiting: Map successfully transferred
Transferring passwd.byuid...
ypxfr: Exiting: Map successfully transferred
Transferring passwd.byname...
ypxfr: Exiting: Map successfully transferred
Transferring group.bygid...
ypxfr: Exiting: Map successfully transferred
Transferring group.byname...
ypxfr: Exiting: Map successfully transferred
Transferring services.byname...
ypxfr: Exiting: Map successfully transferred
Transferring rpc.bynumber...
ypxfr: Exiting: Map successfully transferred
Transferring rpc.byname...
ypxfr: Exiting: Map successfully transferred
Transferring protocols.byname...
ypxfr: Exiting: Map successfully transferred
Transferring master.passwd.byname...
ypxfr: Exiting: Map successfully transferred
Transferring networks.byname...
ypxfr: Exiting: Map successfully transferred
Transferring networks.byaddr...
ypxfr: Exiting: Map successfully transferred
Transferring netid.byname...
ypxfr: Exiting: Map successfully transferred
Transferring hosts.byaddr...
ypxfr: Exiting: Map successfully transferred
Transferring protocols.bynumber...
ypxfr: Exiting: Map successfully transferred
Transferring ypservers...
ypxfr: Exiting: Map successfully transferred
Transferring hosts.byname...
ypxfr: Exiting: Map successfully transferred

coltrane has been setup as an YP slave server without any errors.
Remember to update map ypservers on ellington.</code></pre></div></div><div class=paragraph><p>Isto irá gerar um diretório no servidor slave chamado <span class=filename>/var/yp/test-domain</span> que contém cópias dos mapas do servidor principal do NIS. Adicionar estas entradas ao arquivo <span class=filename>/etc/crontab</span> em cada servidor slave forçará os slaves a sincronizar seus mapas com os mapas no servidor master:</p></div><div class="literalblock programlisting"><div class=content><pre>20      *       *       *       *       root   /usr/libexec/ypxfr passwd.byname
21      *       *       *       *       root   /usr/libexec/ypxfr passwd.byuid</pre></div></div><div class=paragraph><p>Essas entradas não são obrigatórias porque o servidor master tenta enviar automaticamente quaisquer alterações no mapa para seus escravos. No entanto, como os clientes podem depender do servidor escravo para fornecer informações corretas de senha, recomenda-se forçar atualizações frequentes de mapas de senha. Isso é especialmente importante em redes ocupadas nas quais as atualizações de mapas nem sempre são concluídas.</p></div><div class=paragraph><p>Para finalizar a configuração, execute <code>/etc/netstart</code> no servidor slave para iniciar os serviços do NIS.</p></div></div><div class=sect3><h4 id=_configurando_um_cliente_nis>29.4.6. Configurando um cliente NIS<a class=anchor href=#_configurando_um_cliente_nis></a></h4><div class=paragraph><p>Um cliente NIS é vinculado a um servidor NIS usando <a href="https://man.freebsd.org/cgi/man.cgi?query=ypbind&amp;sektion=8&amp;format=html">ypbind(8)</a>. Esse daemon transmite solicitações de RPC na rede local. Essas solicitações especificam o nome do domínio configurado no cliente. Se um servidor NIS no mesmo domínio receber uma das transmissões, ele responderá a ypbind, que registrará o endereço do servidor. Se houver vários servidores disponíveis, o cliente usará o endereço do primeiro servidor para responder e direcionará todas as suas solicitações de NIS para esse servidor. O cliente irá automaticamente pingar o servidor regularmente para garantir que ainda esteja disponível. Se ele não receber uma resposta dentro de um período de tempo razoável, o ypbind marcará o domínio como não acoplado e começará a transmitir novamente na esperança de localizar outro servidor.</p></div><div class=paragraph><p>Para configurar uma máquina FreeBSD para ser um cliente NIS:</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Edite o <span class=filename>/etc/rc.conf</span> e adicione as seguintes linhas para definir o nome de domínio NIS e inicie <a href="https://man.freebsd.org/cgi/man.cgi?query=ypbind&amp;sektion=8&amp;format=html">ypbind(8)</a> durante a inicialização da rede:</p><div class="literalblock programlisting"><div class=content><pre>nisdomainname=&#34;test-domain&#34;
nis_client_enable=&#34;YES&#34;</pre></div></div></li><li><p>Para importar todas as possíveis entradas de senha do servidor NIS, use <code>vipw</code> para remover todas as contas de usuário, exceto uma do arquivo <span class=filename>/etc/master.passwd</span>. Ao remover as contas, lembre-se de que pelo menos uma conta local deve permanecer e essa conta deve ser membro do grupo <code>wheel</code>. Se houver um problema com o NIS, essa conta local poderá ser usada para efetuar login remotamente, tornar-se o superusuário e corrigir o problema. Antes de salvar as edições, adicione a seguinte linha ao final do arquivo:</p><div class="literalblock programlisting"><div class=content><pre>+:::::::::</pre></div></div><div class=paragraph><p>Esta linha configura o cliente para fornecer qualquer pessoa com uma conta válida na senha do servidor do NIS mapeia uma conta no cliente. Existem várias maneiras de configurar o cliente NIS modificando essa linha. Um método é descrito em <a href=#network-netgroups>Usando Netgroups</a>. Para uma leitura mais detalhada, consulte o livro <code>Managing NFS and NIS</code>, publicado pela O’Reilly Media.</p></div></li><li><p>Para importar todas as entradas de grupo possíveis do servidor NIS, adicione esta linha ao <span class=filename>/etc/group</span>:</p><div class="literalblock programlisting"><div class=content><pre>+:*::</pre></div></div></li></ol></div></div></div><div class=paragraph><p>Para iniciar imediatamente o cliente NIS, execute os seguintes comandos como superusuário:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /etc/netstart</span>
<span class=c># service ypbind start</span></code></pre></div></div><div class=paragraph><p>Depois de concluir estas etapas, a execução do <code>ypcat passwd</code> no cliente deve mostrar o mapa <span class=filename>passwd</span> do servidor.</p></div></div><div class=sect3><h4 id=_segurança_nis>29.4.7. Segurança NIS<a class=anchor href=#_segurança_nis></a></h4><div class=paragraph><p>Como o RPC é um serviço baseado em broadcast, qualquer sistema executando o ypbind dentro do mesmo domínio pode recuperar o conteúdo dos mapas do NIS. Para evitar transações não autorizadas, <a href="https://man.freebsd.org/cgi/man.cgi?query=ypserv&amp;sektion=8&amp;format=html">ypserv(8)</a> suporta um recurso chamado "securenets" que pode ser usado para restringir o acesso a um dado conjunto de hosts. Por padrão, essas informações são armazenadas no arquivo <span class=filename>/var/yp/securenets</span>, a menos que <a href="https://man.freebsd.org/cgi/man.cgi?query=ypserv&amp;sektion=8&amp;format=html">ypserv(8)</a> seja iniciado com <code>-p</code> e um caminho alternativo. Este arquivo contém entradas que consistem em uma especificação de rede e uma máscara de rede separadas por espaço em branco. Linhas iniciando com <code>#</code> são consideradas comentários. Um exemplo de <span class=filename>securenets</span> pode ser assim:</p></div><div class="literalblock programlisting"><div class=content><pre># allow connections from local host -- mandatory
127.0.0.1     255.255.255.255
# allow connections from any host
# on the 192.168.128.0 network
192.168.128.0 255.255.255.0
# allow connections from any host
# between 10.0.0.0 to 10.0.15.255
# this includes the machines in the testlab
10.0.0.0      255.255.240.0</pre></div></div><div class=paragraph><p>Se <a href="https://man.freebsd.org/cgi/man.cgi?query=ypserv&amp;sektion=8&amp;format=html">ypserv(8)</a> receber uma solicitação de um endereço que corresponda a uma dessas regras, ela processará a solicitação normalmente. Se o endereço não corresponder a uma regra, a solicitação será ignorada e uma mensagem de aviso será registrada. Se o <span class=filename>securenets</span> não existir, o <code>ypserv</code> permitirá conexões de qualquer host.</p></div><div class=paragraph><p><a href=./#tcpwrappers>TCP Wrapper</a> é um mecanismo alternativo para fornecer controle de acesso em vez de <span class=filename>securenets</span>. Embora o mecanismo de controle de acesso acrescente alguma segurança, ambos são vulneráveis a ataques como "IP spoofing". Todo o tráfego relacionado a NIS deve ser bloqueado no firewall.</p></div><div class=paragraph><p>Servidores que usam <span class=filename>securenets</span> podem não servir clientes legítimos de NIS com implementações arcaicas de TCP/IP. Algumas dessas implementações definem todos os bits do host como zero ao fazer transmissões ou não observam a máscara de sub-rede ao calcular o endereço de transmissão. Embora alguns desses problemas possam ser corrigidos alterando a configuração do cliente, outros problemas podem forçar a desativação desses sistemas clientes ou o abandono do <span class=filename>securenets</span>.</p></div><div class=paragraph><p>O uso de TCP Wrapper aumenta a latência do servidor NIS. O atraso adicional pode ser longo o suficiente para causar timeouts em programas clientes, especialmente em redes ocupadas com servidores NIS lentos. Se um ou mais clientes sofrerem de latência, converta esses clientes em servidores de NIS slaves e force-os a se ligarem a eles mesmos.</p></div><div class=sect4><h5 id=_barrando_alguns_usuários>29.4.7.1. Barrando alguns usuários<a class=anchor href=#_barrando_alguns_usuários></a></h5><div class=paragraph><p>Neste exemplo, o sistema <code>basie</code> é uma estação de trabalho da dentro do domínio NIS facultativo. O mapa <span class=filename>passwd</span> no servidor NIS master contém contas para professores e alunos. Esta seção demonstra como permitir o login do corpo docente neste sistema e, ao mesmo tempo, recusar logins de alunos.</p></div><div class=paragraph><p>Para previnir usuários específicos de logar em um sistema, desde que eles estejam presentes no banco de dados do NIS, use <code>vipw</code> para adicionar <code>-<em>username</em></code> com o numero correto de virgulas em direção ao fim do arquivo <span class=filename>/etc/master.passwd</span> no cliente, onde <em>username</em> é o nome de usuário a impedir de logar. A linha com o usuário bloqueado deve estar antes da linha <code>+</code> que permite usuários do NIS. Neste exemplo, <code>bill</code> está impedido de logar no <code>basie</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>basie# <span class=nb>cat</span> /etc/master.passwd
root:[password]:0:0::0:0:The super-user:/root:/bin/csh
toor:[password]:0:0::0:0:The other super-user:/root:/bin/sh
daemon:<span class=k>*</span>:1:1::0:0:Owner of many system processes:/root:/usr/sbin/nologin
operator:<span class=k>*</span>:2:5::0:0:System &amp;:/:/usr/sbin/nologin
bin:<span class=k>*</span>:3:7::0:0:Binaries Commands and Source,,,:/:/usr/sbin/nologin
<span class=nb>tty</span>:<span class=k>*</span>:4:65533::0:0:Tty Sandbox:/:/usr/sbin/nologin
kmem:<span class=k>*</span>:5:65533::0:0:KMem Sandbox:/:/usr/sbin/nologin
games:<span class=k>*</span>:7:13::0:0:Games pseudo-user:/usr/games:/usr/sbin/nologin
news:<span class=k>*</span>:8:8::0:0:News Subsystem:/:/usr/sbin/nologin
man:<span class=k>*</span>:9:9::0:0:Mister Man Pages:/usr/shared/man:/usr/sbin/nologin
<span class=nb>bind</span>:<span class=k>*</span>:53:53::0:0:Bind Sandbox:/:/usr/sbin/nologin
uucp:<span class=k>*</span>:66:66::0:0:UUCP pseudo-user:/var/spool/uucppublic:/usr/libexec/uucp/uucico
xten:<span class=k>*</span>:67:67::0:0:X-10 daemon:/usr/local/xten:/usr/sbin/nologin
pop:<span class=k>*</span>:68:6::0:0:Post Office Owner:/nonexistent:/usr/sbin/nologin
nobody:<span class=k>*</span>:65534:65534::0:0:Unprivileged user:/nonexistent:/usr/sbin/nologin
<span class=nt>-bill</span>:::::::::
+:::::::::

basie#</code></pre></div></div></div></div><div class=sect3><h4 id=network-netgroups>29.4.8. Usando Netgroups<a class=anchor href=#network-netgroups></a></h4><div class=paragraph><p>A exclusão de usuários especificados do logon em sistemas individuais torna-se imprestável em redes maiores e perde rapidamente o principal benefício do NIS: administração <em>centralizada</em>.</p></div><div class=paragraph><p>Os netgroups foram desenvolvidos para lidar com redes grandes e complexas com centenas de usuários e máquinas. Seu uso é comparável aos grupos UNIX™, onde a principal diferença é a falta de um ID numérico e a capacidade de definir um netgroup incluindo contas de usuário e outros netgroups.</p></div><div class=paragraph><p>Para expandir o exemplo usado neste capítulo, o domínio NIS será estendido para adicionar os usuários e sistemas mostrados nas Tabelas 28.2 e 28.3:</p></div><table class="tableblock frame-none grid-all stretch"><caption class=title>Tabela 24. Usuários Adicionais</caption><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Nome(s) de usuário</th><th class="tableblock halign-left valign-top">Descrição</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>alpha</code>, <code>beta</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Funcionários do departamento de TI</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>charlie</code>, <code>delta</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Aprendizes do departamento de TI</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>echo</code>, <code>foxtrott</code>, <code>golf</code>, …​</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>funcionários</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>able</code>, <code>baker</code>, …​</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>estagiários</p></td></tr></tbody></table><table class="tableblock frame-none grid-all stretch"><caption class=title>Tabela 25. Sistemas Adicionais</caption><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Nome(s) de máquina</th><th class="tableblock halign-left valign-top">Descrição</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>war</code>, <code>death</code>, <code>famine</code>, <code>pollution</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Somente funcionários de TI podem fazer logon nesses servidores.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>pride</code>, <code>greed</code>, <code>envy</code>, <code>wrath</code>, <code>lust</code>, <code>sloth</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Todos os membros do departamento de TI podem fazer login nesses servidores.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>one</code>, <code>two</code>, <code>three</code>, <code>four</code>, …​</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Estações de trabalho comuns usadas pelos funcionários.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>trashcan</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Uma máquina muito antiga sem dados críticos. Até os estagiários podem usar este sistema.</p></td></tr></tbody></table><div class=paragraph><p>Ao usar netgroups para configurar esse cenário, cada usuário é atribuído a um ou mais netgroups e os logins são permitidos ou proibidos para todos os membros do netgroup. Ao adicionar uma nova máquina, as restrições de login devem ser definidas para todos os netgroups. Quando um novo usuário é adicionado, a conta deve ser adicionada a um ou mais netgroups. Se a configuração do NIS for planejada com cuidado, somente um arquivo de configuração central precisará ser modificado para conceder ou negar acesso a máquinas.</p></div><div class=paragraph><p>O primeiro passo é a inicialização do mapa do NIS <code>netgroup</code>. No FreeBSD, este mapa não é criado por padrão. No servidor NIS master, use um editor para criar um mapa chamado <span class=filename>/var/yp/netgroup</span>.</p></div><div class=paragraph><p>Este exemplo cria quatro grupos de rede para representar funcionários de TI, aprendizes de TI, funcionários e estagiários:</p></div><div class="literalblock programlisting"><div class=content><pre>IT_EMP  (,alpha,test-domain)    (,beta,test-domain)
IT_APP  (,charlie,test-domain)  (,delta,test-domain)
USERS   (,echo,test-domain)     (,foxtrott,test-domain) \
        (,golf,test-domain)
INTERNS (,able,test-domain)     (,baker,test-domain)</pre></div></div><div class=paragraph><p>Cada entrada configura um netgroup. A primeira coluna em uma entrada é o nome do netgroup. Cada conjunto de colchetes representa um grupo de um ou mais usuários ou o nome de outro grupo de rede. Ao especificar um usuário, os três campos delimitados por vírgula dentro de cada grupo representam:</p></div><div class="olist arabic"><ol class=arabic><li><p>O nome do(s) host(s) onde os outros campos que representam o usuário são válidos. Se um nome de host não for especificado, a entrada será válida em todos os hosts.</p></li><li><p>O nome da conta que pertence a este netgroup.</p></li><li><p>O domínio NIS da conta. As contas podem ser importadas de outros domínios do NIS para um netgroup.</p></li></ol></div><div class=paragraph><p>Se um grupo contiver vários usuários, separe cada usuário com espaço em branco. Além disso, cada campo pode conter curingas. Veja <a href="https://man.freebsd.org/cgi/man.cgi?query=netgroup&amp;sektion=5&amp;format=html">netgroup(5)</a> para detalhes.</p></div><div class=paragraph><p>Nomes de grupos maiores que 8 caracteres não devem ser usados. Os nomes diferenciam maiúsculas de minúsculas e usar letras maiúsculas para nomes de grupos de rede é uma maneira fácil de distinguir entre nomes de usuários, máquinas e grupos de rede.</p></div><div class=paragraph><p>Alguns clientes não-FreeBSD NIS não podem lidar com netgroups contendo mais de 15 entradas. Esse limite pode ser contornado criando vários grupos de sub-redes com 15 usuários ou menos e um grupo de rede real consistindo dos grupos de sub-redes, como visto neste exemplo:</p></div><div class="literalblock programlisting"><div class=content><pre>BIGGRP1  (,joe1,domain)  (,joe2,domain)  (,joe3,domain) [...]
BIGGRP2  (,joe16,domain)  (,joe17,domain) [...]
BIGGRP3  (,joe31,domain)  (,joe32,domain)
BIGGROUP  BIGGRP1 BIGGRP2 BIGGRP3</pre></div></div><div class=paragraph><p>Repita este processo se mais de 225 (15 vezes 15) usuários existirem dentro de um único netgroup.</p></div><div class=paragraph><p>Para ativar e distribuir o novo mapa do NIS:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>ellington# <span class=nb>cd</span> /var/yp
ellington# make</code></pre></div></div><div class=paragraph><p>Isso gerará os três mapas NIS, <span class=filename>netgroup</span>, <span class=filename>netgroup.byhost</span> e <span class=filename>netgroup.byuser</span>. Use a opção de chave de mapa <a href="https://man.freebsd.org/cgi/man.cgi?query=ypcat&amp;sektion=1&amp;format=html">ypcat(1)</a> para verificar se os novos mapas de NIS estão disponíveis:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>ellington% ypcat <span class=nt>-k</span> netgroup
ellington% ypcat <span class=nt>-k</span> netgroup.byhost
ellington% ypcat <span class=nt>-k</span> netgroup.byuser</code></pre></div></div><div class=paragraph><p>A saída do primeiro comando deve lembrar o conteúdo de <span class=filename>/var/yp/netgroup</span>. O segundo comando só produz saída se os netgroups específicos do host foram criados. O terceiro comando é usado para obter a lista de netgroups de um usuário.</p></div><div class=paragraph><p>Para configurar um cliente, use <a href="https://man.freebsd.org/cgi/man.cgi?query=vipw&amp;sektion=8&amp;format=html">vipw(8)</a> para especificar o nome do netgroup. Por exemplo, no servidor chamado <code>war</code>, substitua esta linha:</p></div><div class="literalblock programlisting"><div class=content><pre>+:::::::::</pre></div></div><div class=paragraph><p>com</p></div><div class="literalblock programlisting"><div class=content><pre>+@IT_EMP:::::::::</pre></div></div><div class=paragraph><p>Isso especifica que apenas os usuários definidos no netgroup <code>IT_EMP</code> serão importados para o banco de dados de senhas deste sistema e somente esses usuários terão permissão para efetuar login nesse sistema.</p></div><div class=paragraph><p>Essa configuração também se aplica à função <code>~</code> do shell e a todas as rotinas que convertem entre nomes de usuário e IDs de usuário numérico. Em outras palavras, <code>cd ~<em>user</em></code> não funcionará, <code>ls -l</code> mostrará o ID numérico em vez do nome de usuário e <code>find . -user joe -print</code> falhará com a mensagem <code>No such user</code>. Para corrigir isso, importe todas as entradas do usuário sem permitir que elas efetuem login nos servidores. Isto pode ser conseguido adicionando uma linha extra:</p></div><div class="literalblock programlisting"><div class=content><pre>+:::::::::/usr/sbin/nologin</pre></div></div><div class=paragraph><p>Esta linha configura o cliente para importar todas as entradas, mas para substituir o shell nessas entradas com <span class=filename>/usr/sbin/nologin</span>.</p></div><div class=paragraph><p>Certifique-se que a linha extra é colocada <em>após</em> <code>+@IT_EMP:::::::::</code>. Caso contrário, todas as contas de usuário importadas do NIS terão <span class=filename>/usr/sbin/nologin</span> como seu shell de login e ninguém poderá efetuar o login no sistema.</p></div><div class=paragraph><p>Para configurar os servidores menos importantes, substitua o antigo <code>+:::::::::</code> nos servidores com estas linhas:</p></div><div class="literalblock programlisting"><div class=content><pre>+@IT_EMP:::::::::
+@IT_APP:::::::::
+:::::::::/usr/sbin/nologin</pre></div></div><div class=paragraph><p>As linhas correspondentes para as estações de trabalho seriam:</p></div><div class="literalblock programlisting"><div class=content><pre>+@IT_EMP:::::::::
+@USERS:::::::::
+:::::::::/usr/sbin/nologin</pre></div></div><div class=paragraph><p>O NIS suporta a criação de grupos de rede de outros grupos de rede, o que pode ser útil se a política relacionada ao acesso do usuário for alterada. Uma possibilidade é a criação de netgroups baseados em funções. Por exemplo, pode-se criar um netgroup chamado <code>BIGSRV</code> para definir as restrições de login para os servidores importantes, outro grupo de rede chamado <code>SMALLSRV</code> para os servidores menos importantes e um terceiro netgroup chamado <code>USERBOX</code> para as estações de trabalho. Cada um desses netgroups contém os netgroups com permissão para efetuar login nessas máquinas. As novas entradas para o mapa do NIS <code>netgroup</code> seriam assim:</p></div><div class="literalblock programlisting"><div class=content><pre>BIGSRV    IT_EMP  IT_APP
SMALLSRV  IT_EMP  IT_APP  ITINTERN
USERBOX   IT_EMP  ITINTERN USERS</pre></div></div><div class=paragraph><p>Esse método de definir restrições de login funciona razoavelmente bem quando é possível definir grupos de máquinas com restrições idênticas. Infelizmente, esta é a exceção e não a regra. Na maioria das vezes, é necessária a capacidade de definir restrições de login por máquina.</p></div><div class=paragraph><p>As definições de netgroup específicas da máquina são outra possibilidade para lidar com as mudanças na política. Neste cenário, o <span class=filename>/etc/master.passwd</span> de cada sistema contém duas linhas que começam com "+". A primeira linha adiciona um netgroup com as contas permitidas para entrar nesta máquina e a segunda linha adiciona todas as outras contas com <span class=filename>/usr/sbin/nologin</span> como shell. Recomenda-se usar a versão "ALL-CAPS" do nome do host como o nome do netgroup:</p></div><div class="literalblock programlisting"><div class=content><pre>+@BOXNAME:::::::::
+:::::::::/usr/sbin/nologin</pre></div></div><div class=paragraph><p>Quando esta tarefa estiver completa em todas as máquinas, não haverá mais a necessidade de modificar as versões locais de <span class=filename>/etc/master.passwd</span> novamente. Todas as alterações posteriores podem ser manipuladas, modificando o mapa do NIS. Aqui está um exemplo de um possível mapa <code>netgroup</code> para este cenário:</p></div><div class="literalblock programlisting"><div class=content><pre># Define groups of users first
IT_EMP    (,alpha,test-domain)    (,beta,test-domain)
IT_APP    (,charlie,test-domain)  (,delta,test-domain)
DEPT1     (,echo,test-domain)     (,foxtrott,test-domain)
DEPT2     (,golf,test-domain)     (,hotel,test-domain)
DEPT3     (,india,test-domain)    (,juliet,test-domain)
ITINTERN  (,kilo,test-domain)     (,lima,test-domain)
D_INTERNS (,able,test-domain)     (,baker,test-domain)
#
# Now, define some groups based on roles
USERS     DEPT1   DEPT2     DEPT3
BIGSRV    IT_EMP  IT_APP
SMALLSRV  IT_EMP  IT_APP    ITINTERN
USERBOX   IT_EMP  ITINTERN  USERS
#
# And a groups for a special tasks
# Allow echo and golf to access our anti-virus-machine
SECURITY  IT_EMP  (,echo,test-domain)  (,golf,test-domain)
#
# machine-based netgroups
# Our main servers
WAR       BIGSRV
FAMINE    BIGSRV
# User india needs access to this server
POLLUTION  BIGSRV  (,india,test-domain)
#
# This one is really important and needs more access restrictions
DEATH     IT_EMP
#
# The anti-virus-machine mentioned above
ONE       SECURITY
#
# Restrict a machine to a single user
TWO       (,hotel,test-domain)
# [...more groups to follow]</pre></div></div><div class=paragraph><p>Pode não ser sempre aconselhável usar netgroups baseados em máquina. Ao implantar algumas dúzias ou centenas de sistemas, grupos de rede baseados em funções em vez de grupos de rede baseados em máquina podem ser usados para manter o tamanho do mapa do NIS dentro de limites razoáveis.</p></div></div><div class=sect3><h4 id=_formatos_de_senha>29.4.9. Formatos de Senha<a class=anchor href=#_formatos_de_senha></a></h4><div class=paragraph><p>O NIS requer que todos os hosts em um domínio NIS usem o mesmo formato para criptografar senhas. Se os usuários tiverem problemas para autenticar em um cliente NIS, pode ser devido a um formato de senha diferente. Em uma rede heterogênea, o formato deve ser suportado por todos os sistemas operacionais, onde DES é o padrão comum mais baixo.</p></div><div class=paragraph><p>Para verificar qual formato um servidor ou cliente está usando, veja esta seção do <span class=filename>/etc/login.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>default:\
	:passwd_format=des:\
	:copyright=/etc/COPYRIGHT:\
	[Further entries elided]</pre></div></div><div class=paragraph><p>Neste exemplo, o sistema está usando o formato DES. Outros valores possíveis são <code>blf</code> para Blowfish e <code>md5</code> para senhas criptografadas com MD5.</p></div><div class=paragraph><p>Se o formato em um host precisar ser editado para corresponder ao que está sendo usado no domínio NIS, o banco de dados de recursos de login deve ser reconstruído após salvar a alteração:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cap_mkdb /etc/login.conf</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>O formato das senhas das contas de usuários existentes não será atualizado até que cada usuário mude sua senha <em>após</em> o banco de dados de recursos de login ser reconstruído.</p></div></td></tr></tbody></table></div></div></div><div class=sect2><h3 id=network-ldap>29.5. Protocolo leve de acesso de diretório ( LDAP )<a class=anchor href=#network-ldap></a></h3><div class=paragraph><p>O protocolo LDAP (LDAP) é um protocolo da camada de aplicação usado para acessar, modificar e autenticar objetos usando um serviço de informações de diretório distribuído. Pense nisso como um telefone ou livro de registro que armazena vários níveis de informações hierárquicas e homogêneas. Ele é usado nas redes do Active Directory e do OpenLDAP e permite que os usuários acessem vários níveis de informações internas utilizando uma única conta. Por exemplo, a autenticação de email, a obtenção de informações de contato dos funcionários e a autenticação interna de sites podem usar uma única conta de usuário na base de registros do servidor LDAP.</p></div><div class=paragraph><p>Esta seção fornece um guia de início rápido para configurar um servidor LDAP em um sistema FreeBSD. Ele pressupõe que o administrador já tenha um plano de design que inclua o tipo de informação a ser armazenada, para que essas informações sejam usadas, quais usuários devem ter acesso a essas informações e como proteger essas informações contra acesso não autorizado.</p></div><div class=sect3><h4 id=_terminologia_e_estrutura_do_ldap>29.5.1. Terminologia e Estrutura do LDAP<a class=anchor href=#_terminologia_e_estrutura_do_ldap></a></h4><div class=paragraph><p>O LDAP usa vários termos que devem ser entendidos antes de iniciar a configuração. Todas as entradas de diretório consistem em um grupo de <em>attributes</em>. Cada um desses conjuntos de atributos contém um identificador exclusivo conhecido como <em>Distinguished Name</em> (DN) que é normalmente criado a partir de vários outros atributos, como Common ou <em>Relative Distinguished Name</em> (RDN). Semelhante a como os diretórios têm caminhos absolutos e relativos, considere um DN como um caminho absoluto e o RDN como o caminho relativo.</p></div><div class=paragraph><p>Um exemplo de entrada LDAP é semelhante ao seguinte. Este exemplo procura a entrada para a conta de usuário especificada (<code>uid</code>), unidade organizacional (<code>ou</code>) e organização (<code>o</code>):</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ldapsearch <span class=nt>-xb</span> <span class=s2>&#34;uid=trhodes,ou=users,o=example.com&#34;</span>
<span class=c># extended LDIF</span>
<span class=c>#</span>
<span class=c># LDAPv3</span>
<span class=c># base &lt;uid=trhodes,ou=users,o=example.com&gt; with scope subtree</span>
<span class=c># filter: (objectclass=*)</span>
<span class=c># requesting: ALL</span>
<span class=c>#</span>

<span class=c># trhodes, users, example.com</span>
dn: <span class=nv>uid</span><span class=o>=</span>trhodes,ou<span class=o>=</span><span class=nb>users</span>,o<span class=o>=</span>example.com
mail: trhodes@example.com
cn: Tom Rhodes
uid: trhodes
telephoneNumber: <span class=o>(</span>123<span class=o>)</span> 456-7890

<span class=c># search result</span>
search: 2
result: 0 Success

<span class=c># numResponses: 2</span>
<span class=c># numEntries: 1</span></code></pre></div></div><div class=paragraph><p>Esta entrada de exemplo mostra os valores para os atributos <code>dn</code>, <code>mail</code>, <code>cn</code>, <code>uid</code> e <code>telephoneNumber</code>. O atributo do cn é o RDN.</p></div><div class=paragraph><p>Maiores informações sobre o LDAP e sua terminologia podem ser encontradas em <a href=http://www.openldap.org/doc/admin24/intro.html>http://www.openldap.org/doc/admin24/intro.html</a>.</p></div></div><div class=sect3><h4 id=ldap-config>29.5.2. Configurando um servidor LDAP<a class=anchor href=#ldap-config></a></h4><div class=paragraph><p>O FreeBSD não provê um servidor LDAP embutido. Comece a configuração instalando o pacote ou port <a class=package href=https://cgit.freebsd.org/ports/tree/net/openldap-server/>net/openldap-server</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install openldap-server</span></code></pre></div></div><div class=paragraph><p>Aqui está um largo conjunto de opções habilitadas no <a href=https://docs.freebsd.org/pt-br/articles/linux-users/#software>pacote</a>. Reveja-os rodando o comando <code>pkg info openldap-server</code>. Se não for suficiente (por exemplo se o suporte a SQL for necessário), por favor considere recompilar o port usando o framework <a href=./#ports-using>apropriado</a>.</p></div><div class=paragraph><p>A instalação cria o diretório <span class=filename>/var/db/openldap-data</span> para conter os dados. O diretório para armazenar os certificados deve ser criado:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mkdir /usr/local/etc/openldap/private</span></code></pre></div></div><div class=paragraph><p>A próxima fase é configurar a autoridade de certificação. Os seguintes comandos devem ser executados em <span class=filename>/usr/local/etc/openldap/private</span>. Isso é importante, pois as permissões de arquivo precisam ser restritivas e os usuários não devem ter acesso a esses arquivos. Informações mais detalhadas sobre certificados e seus parâmetros podem ser encontradas em <a href=./#openssl>OpenSSL</a>. Para criar a Autoridade de Certificação, comece com este comando e siga os prompts:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># openssl req -days 365 -nodes -new -x509 -keyout ca.key -out ../ca.crt</span></code></pre></div></div><div class=paragraph><p>As entradas para os prompts podem ser genéricas <em>exceto</em> para o <code>Common Name</code>. Esta entrada deve ser <em>diferente</em> do nome do host do sistema. Se este será um certificado auto-assinado, prefixe o nome do host com <code>CA</code> para a Autoridade de Certificação.</p></div><div class=paragraph><p>A próxima tarefa é criar uma solicitação de assinatura de certificado e uma chave privada. Insira este comando e siga os prompts:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># openssl req -days 365 -nodes -new -keyout server.key -out server.csr</span></code></pre></div></div><div class=paragraph><p>Durante o processo de geração de certificados, certifique-se de configurar corretamente o atributo <code>Common Name</code>. A Solicitação de Assinatura de Certificado deve ser assinada com a Autoridade de Certificação para ser usada como um certificado válido:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># openssl x509 -req -days 365 -in server.csr -out ../server.crt -CA ../ca.crt -CAkey ca.key -CAcreateserial</span></code></pre></div></div><div class=paragraph><p>A parte final do processo de geração de certificados é gerar e assinar os certificados do cliente:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># openssl req -days 365 -nodes -new -keyout client.key -out client.csr</span>
<span class=c># openssl x509 -req -days 3650 -in client.csr -out ../client.crt -CA ../ca.crt -CAkey ca.key</span></code></pre></div></div><div class=paragraph><p>Lembre-se de usar o mesmo atributo <code>Common Name</code> quando solicitado. Quando terminar, assegure-se de que um total de oito (8) novos arquivos tenham sido gerado através dos comandos procedentes.</p></div><div class=paragraph><p>O daemon que executa o servidor OpenLDAP é o <span class=filename>slapd</span>. Sua configuração é executada através do <span class=filename>slapd.ldif</span>: o antigo <span class=filename>slapd.conf</span> foi descontinuado pelo OpenLDAP.</p></div><div class=paragraph><p><a href=http://www.openldap.org/doc/admin24/slapdconf2.html>Exemplos de configuração</a> para o <span class=filename>slapd.ldif</span> estão disponíveis e também podem ser encontrados em <span class=filename>/usr/local/etc/openldap/slapd.ldif.sample</span>. As opções estão documentadas em slapd-config(5). Cada seção do <span class=filename>slapd.ldif</span>, como todos os outros conjuntos de atributos LDAP, é identificada exclusivamente por meio de um DN. Certifique-se de que nenhuma linha em branco seja deixada entre a instrução <code>dn:</code> e o final desejado da seção. No exemplo a seguir, o TLS será usado para implementar um canal seguro. A primeira seção representa a configuração global:</p></div><div class="literalblock programlisting"><div class=content><pre>#
# See slapd-config(5) for details on configuration options.
# This file should NOT be world readable.
#
dn: cn=config
objectClass: olcGlobal
cn: config
#
#
# Define global ACLs to disable default read access.
#
olcArgsFile: /var/run/openldap/slapd.args
olcPidFile: /var/run/openldap/slapd.pid
olcTLSCertificateFile: /usr/local/etc/openldap/server.crt
olcTLSCertificateKeyFile: /usr/local/etc/openldap/private/server.key
olcTLSCACertificateFile: /usr/local/etc/openldap/ca.crt
#olcTLSCipherSuite: HIGH
olcTLSProtocolMin: 3.1
olcTLSVerifyClient: never</pre></div></div><div class=paragraph><p>A Autoridade de Certificação, o certificado do servidor e os arquivos de chave privada do servidor devem ser especificados aqui. Recomenda-se que os clientes escolham a opção de criptografia de segurança e omitam <code>olcTLSCipherSuite</code> (incompatível com clientes TLS diferentes de <span class=filename>openssl</span>). A opção <code>olcTLSProtocolMin</code> permite que o servidor exija um nível mínimo de segurança: é recomendado. Enquanto a verificação é obrigatória para o servidor, não é para o cliente: <code>olcTLSVerifyClient: never</code>.</p></div><div class=paragraph><p>A segunda seção é sobre os módulos de backend e pode ser configurada da seguinte maneira:</p></div><div class="literalblock programlisting"><div class=content><pre>#
# Load dynamic backend modules:
#
dn: cn=module,cn=config
objectClass: olcModuleList
cn: module
olcModulepath:	/usr/local/libexec/openldap
olcModuleload:	back_mdb.la
#olcModuleload:	back_bdb.la
#olcModuleload:	back_hdb.la
#olcModuleload:	back_ldap.la
#olcModuleload:	back_passwd.la
#olcModuleload:	back_shell.la</pre></div></div><div class=paragraph><p>A terceira seção é dedicada a carregar os esquemas <code>ldif</code> necessários para serem usados pelos bancos de dados: eles são essenciais.</p></div><div class="literalblock programlisting"><div class=content><pre>dn: cn=schema,cn=config
objectClass: olcSchemaConfig
cn: schema

include: file:///usr/local/etc/openldap/schema/core.ldif
include: file:///usr/local/etc/openldap/schema/cosine.ldif
include: file:///usr/local/etc/openldap/schema/inetorgperson.ldif
include: file:///usr/local/etc/openldap/schema/nis.ldif</pre></div></div><div class=paragraph><p>Em seguida, a seção de configuração do frontend:</p></div><div class="literalblock programlisting"><div class=content><pre># Frontend settings
#
dn: olcDatabase={-1}frontend,cn=config
objectClass: olcDatabaseConfig
objectClass: olcFrontendConfig
olcDatabase: {-1}frontend
olcAccess: to * by * read
#
# Sample global access control policy:
#	Root DSE: allow anyone to read it
#	Subschema (sub)entry DSE: allow anyone to read it
#	Other DSEs:
#		Allow self write access
#		Allow authenticated users read access
#		Allow anonymous users to authenticate
#
#olcAccess: to dn.base=&#34;&#34; by * read
#olcAccess: to dn.base=&#34;cn=Subschema&#34; by * read
#olcAccess: to *
#	by self write
#	by users read
#	by anonymous auth
#
# if no access controls are present, the default policy
# allows anyone and everyone to read anything but restricts
# updates to rootdn.  (e.g., &#34;access to * by * read&#34;)
#
# rootdn can always read and write EVERYTHING!
#
olcPasswordHash: {SSHA}
# {SSHA} is already the default for olcPasswordHash</pre></div></div><div class=paragraph><p>Outra seção é dedicada ao <em>backend de configuração</em>, a única maneira de acessar posteriormente a configuração do servidor OpenLDAP é como um superusuário global.</p></div><div class="literalblock programlisting"><div class=content><pre>dn: olcDatabase={0}config,cn=config
objectClass: olcDatabaseConfig
olcDatabase: {0}config
olcAccess: to * by * none
olcRootPW: {SSHA}iae+lrQZILpiUdf16Z9KmDmSwT77Dj4U</pre></div></div><div class=paragraph><p>O nome de usuário administrador padrão é <code>cn=config</code>. Digite <span class=filename>slappasswd</span> em um shell, escolha a senha e use sua hash <code>olcRootPW</code>. Se essa opção não for especificada agora, antes do arquivo <span class=filename>slapd.ldif</span> ser importado, ninguém poderá modificar a seção de <em>configuração global</em>.</p></div><div class=paragraph><p>A última seção é sobre o back-end do banco de dados:</p></div><div class="literalblock programlisting"><div class=content><pre>#######################################################################
# LMDB database definitions
#######################################################################
#
dn: olcDatabase=mdb,cn=config
objectClass: olcDatabaseConfig
objectClass: olcMdbConfig
olcDatabase: mdb
olcDbMaxSize: 1073741824
olcSuffix: dc=domain,dc=example
olcRootDN: cn=mdbadmin,dc=domain,dc=example
# Cleartext passwords, especially for the rootdn, should
# be avoided.  See slappasswd(8) and slapd-config(5) for details.
# Use of strong authentication encouraged.
olcRootPW: {SSHA}X2wHvIWDk6G76CQyCMS1vDCvtICWgn0+
# The database directory MUST exist prior to running slapd AND
# should only be accessible by the slapd and slap tools.
# Mode 700 recommended.
olcDbDirectory:	/var/db/openldap-data
# Indices to maintain
olcDbIndex: objectClass eq</pre></div></div><div class=paragraph><p>Esse banco de dados hospeda os <em>conteudos atuais</em> do diretório LDAP. Outros tipos diferentes de <code>mdb</code> estão disponiveis. Esse é super-usuário, não confundir com um global, é configurado aqui: um usuário (possivelmente customizado) em <code>olcRootDN</code> e a hash da senha em <code>olcRootPW</code>; <span class=filename>slappasswd</span> pode ser usado como antes.</p></div><div class=paragraph><p>Esse <a href="http://www.openldap.org/devel/gitweb.cgi?p=openldap.git;a=tree;f=tests/data/regressions/its8444;h=8a5e808e63b0de3d2bdaf2cf34fecca8577ca7fd;hb=HEAD">repositorio</a> contém quatro exemplos do arquivo <span class=filename>slapd.ldif</span>. Para converter um arquivo <span class=filename>slapd.conf</span> existente dentro de <span class=filename>slapd.ldif</span>, referencie a <a href=http://www.openldap.org/doc/admin24/slapdconf2.html>essa página</a> (por favor, note que isso pode introduzir algumas opções inuteis).</p></div><div class=paragraph><p>Quando a configuração estiver concluída, o <span class=filename>slapd.ldif</span> deve ser colocado em um diretório vazio. Recomenda-se criá-lo como:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mkdir /usr/local/etc/openldap/slapd.d/</span></code></pre></div></div><div class=paragraph><p>Importe o banco de dados de configuração:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /usr/local/sbin/slapadd -n0 -F /usr/local/etc/openldap/slapd.d/ -l /usr/local/etc/openldap/slapd.ldif</span></code></pre></div></div><div class=paragraph><p>Inicie o daemon <span class=filename>slapd</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /usr/local/libexec/slapd -F /usr/local/etc/openldap/slapd.d/</span></code></pre></div></div><div class=paragraph><p>A opção <code>-d</code> pode ser usada para depuração, conforme especificado em slapd(8). Para verificar se o servidor está em execução e funcionando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ldapsearch -x -b &#39;&#39; -s base &#39;(objectclass=*)&#39; namingContexts</span>
<span class=c># extended LDIF</span>
<span class=c>#</span>
<span class=c># LDAPv3</span>
<span class=c># base &lt;&gt; with scope baseObject</span>
<span class=c># filter: (objectclass=*)</span>
<span class=c># requesting: namingContexts</span>
<span class=c>#</span>

<span class=c>#</span>
dn:
namingContexts: <span class=nv>dc</span><span class=o>=</span>domain,dc<span class=o>=</span>example

<span class=c># search result</span>
search: 2
result: 0 Success

<span class=c># numResponses: 2</span>
<span class=c># numEntries: 1</span></code></pre></div></div><div class=paragraph><p>O servidor ainda deve ser confiável. Se isso nunca foi feito antes, siga estas instruções. Instale o pacote ou o port OpenSSL:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install openssl</span></code></pre></div></div><div class=paragraph><p>No diretório onde o <span class=filename>ca.crt</span> está armazenado (neste exemplo, <span class=filename>/usr/local/etc/openldap</span>), execute:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># c_rehash .</span></code></pre></div></div><div class=paragraph><p>Tanto a CA quanto o certificado do servidor agora são reconhecidos corretamente em suas respectivas funções. Para verificar isso, execute este comando no diretório <span class=filename>server.crt</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># openssl verify -verbose -CApath . server.crt</span></code></pre></div></div><div class=paragraph><p>Se o <span class=filename>slapd</span> estiver em execução, reinicie-o. Como declarado em <span class=filename>/usr/local/etc/rc.d/slapd</span>, para executar corretamente o <span class=filename>slapd</span> na inicialização, as seguintes linhas devem ser adicionadas ao <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>lapd_enable=&#34;YES&#34;
slapd_flags=&#39;-h &#34;ldapi://%2fvar%2frun%2fopenldap%2fldapi/
ldap://0.0.0.0/&#34;&#39;
slapd_sockets=&#34;/var/run/openldap/ldapi&#34;
slapd_cn_config=&#34;YES&#34;</pre></div></div><div class=paragraph><p>O <span class=filename>slapd</span> não fornece depuração na inicialização. Verifique o <span class=filename>/var/log/debug.log</span>, o <span class=filename>dmesg -a</span> e o <span class=filename>/var/log/messages</span> para este propósito.</p></div><div class=paragraph><p>O exemplo a seguir adiciona o grupo <code>team</code> e o usuário <code>john</code> ao banco de dados LDAP de <code>domain.example</code>, que ainda está vazio. Primeiro, crie o arquivo <span class=filename>domain.ldif</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cat domain.ldif</span>
dn: <span class=nv>dc</span><span class=o>=</span>domain,dc<span class=o>=</span>example
objectClass: dcObject
objectClass: organization
o: domain.example
dc: domain

dn: <span class=nv>ou</span><span class=o>=</span><span class=nb>groups</span>,dc<span class=o>=</span>domain,dc<span class=o>=</span>example
objectClass: top
objectClass: organizationalunit
ou: <span class=nb>groups

</span>dn: <span class=nv>ou</span><span class=o>=</span><span class=nb>users</span>,dc<span class=o>=</span>domain,dc<span class=o>=</span>example
objectClass: top
objectClass: organizationalunit
ou: <span class=nb>users

</span>dn: <span class=nv>cn</span><span class=o>=</span>team,ou<span class=o>=</span><span class=nb>groups</span>,dc<span class=o>=</span>domain,dc<span class=o>=</span>example
objectClass: top
objectClass: posixGroup
cn: team
gidNumber: 10001

dn: <span class=nv>uid</span><span class=o>=</span>john,ou<span class=o>=</span><span class=nb>users</span>,dc<span class=o>=</span>domain,dc<span class=o>=</span>example
objectClass: top
objectClass: account
objectClass: posixAccount
objectClass: shadowAccount
cn: John McUser
uid: john
uidNumber: 10001
gidNumber: 10001
homeDirectory: /home/john/
loginShell: /usr/bin/bash
userPassword: secret</code></pre></div></div><div class=paragraph><p>Veja a documentação do OpenLDAP para mais detalhes. Use <span class=filename>slappasswd</span> para substituir a senha <code>secret</code> em texto puro com um hash no <code>userPassword</code>. O caminho especificado como <code>loginShell</code> deve existir em todos sistemas onde <code>john</code> pode se logar. Finalmente, use o administrador <code>mdb</code> para modificar o banco de dados:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ldapadd -W -D &#34;cn=mdbadmin,dc=domain,dc=example&#34; -f domain.ldif</span></code></pre></div></div><div class=paragraph><p>Modificações para a seção <em>configurações globais</em> podem ser feitas apenas pelo super-usuário global. Por exemplo, assume que a opção <code>olcTLSCipherSuite: HIGH:MEDIUM:SSLv3</code> foi inicialmente especificada e deve agora ser deletada. Primeiro, crie um arquivo que contenha o seguinte:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cat global_mod</span>
dn: <span class=nv>cn</span><span class=o>=</span>config
changetype: modify
delete: olcTLSCipherSuite</code></pre></div></div><div class=paragraph><p>Em seguida, aplique as modificações:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ldapmodify -f global_mod -x -D &#34;cn=config&#34; -W</span></code></pre></div></div><div class=paragraph><p>Quando solicitado, forneça a senha escolhida na seção <em>configuração backend</em>. O nome de usuário não é necessário: aqui, <code>cn=config</code> representa o DN da seção do banco de dados a ser modificada. Como alternativa, use <code>ldapmodify</code> para excluir uma única linha do banco de dados, <code>ldapdelete</code> para excluir uma entrada inteira.</p></div><div class=paragraph><p>Se algo der errado ou se o superusuário global não puder acessar o backend de configuração, é possível excluir e reescrever toda a configuração:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># rm -rf /usr/local/etc/openldap/slapd.d/</span></code></pre></div></div><div class=paragraph><p>O <span class=filename>slapd.ldif</span> pode então ser editado e importado novamente. Por favor, siga este procedimento somente quando nenhuma outra solução estiver disponível.</p></div><div class=paragraph><p>Esta é a configuração do servidor apenas. A mesma máquina também pode hospedar um cliente LDAP, com sua própria configuração separada.</p></div></div></div><div class=sect2><h3 id=network-dhcp>29.6. Protocolo de configuração dinâmica de hosts (DHCP)<a class=anchor href=#network-dhcp></a></h3><div class=paragraph><p>O protocolo de configuração dinâmica de hosts (DHCP) permite que um sistema se conecte a uma rede para receber as informações de endereçamento necessárias para a comunicação nessa rede. O FreeBSD inclui a versão do <code>dhclient</code> do OpenBSD que é usada pelo cliente para obter as informações de endereçamento. O FreeBSD não instala um servidor DHCP, mas vários servidores estão disponíveis na coleção de Ports do FreeBSD. O protocolo DHCP é totalmente descrito em <a href=http://www.freesoft.org/CIE/RFC/2131/>RFC 2131</a>. Recursos informativos também estão disponíveis em <a href=http://www.isc.org/downloads/dhcp/>isc.org/downloads/dhcp/</a>.</p></div><div class=paragraph><p>Esta seção descreve como usar o cliente DHCP integrado. Em seguida, descreve como instalar e configurar um servidor DHCP.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>No FreeBSD, o dispositivo <a href="https://man.freebsd.org/cgi/man.cgi?query=bpf&amp;sektion=4&amp;format=html">bpf(4)</a> é necessário tanto pelo servidor DHCP como pelo DHCP > cliente. Este dispositivo está incluído no kernel <span class=filename>GENERIC</span> que é instalado com o FreeBSD. Usuários que preferem criar um kernel personalizado precisam manter este dispositivo se o DHCP for usado.</p></div><div class=paragraph><p>Deve-se notar que o <span class=filename>bpf</span> também permite que usuários privilegiados executem sniffers de pacotes de rede naquele sistema.</p></div></td></tr></tbody></table></div><div class=sect3><h4 id=_configurando_um_cliente_dhcp>29.6.1. Configurando um cliente DHCP<a class=anchor href=#_configurando_um_cliente_dhcp></a></h4><div class=paragraph><p>O suporte ao cliente DHCP está incluído no instalador do FreeBSD, facilitando a configuração de um sistema recém-instalado para receber automaticamente as informações de endereçamento de rede de um servidor DHCP existente. Consulte <a href=./#bsdinstall-post>Pós-instalação</a> para exemplos de configuração de rede.</p></div><div class=paragraph><p>Quando o <code>dhclient</code> é executado na máquina cliente, ele inicia as solicitações de transmissão das informações de configuração. Por padrão, esses pedidos usam a porta UDP 68. O servidor responde na porta UDP 67 , fornecendo ao cliente um endereço IP e outras informações de rede relevantes como uma máscara de sub-rede, gateway padrão e endereços de servidor DNS. Esta informação está na forma de uma "concessão" de DHCP e é válida por um tempo configurável. Isso permite que endereços IP obsoletos para clientes que não estejam mais conectados à rede sejam reutilizados automaticamente. Clientes DHCP podem obter uma grande quantidade de informações do servidor. Uma lista exaustiva pode ser encontrada em <a href="https://man.freebsd.org/cgi/man.cgi?query=dhcp-options&amp;sektion=5&amp;format=html">dhcp-options(5)</a>.</p></div><div class=paragraph><p>Por padrão, quando um sistema FreeBSD inicializa, seu cliente DHCP é executado em segundo plano, ou <em>asynchronously</em>. Outros scripts de inicialização continuam sendo executados enquanto o processo DHCP é concluído, o que acelera a inicialização do sistema.</p></div><div class=paragraph><p>O DHCP em segundo plano funciona bem quando o servidor DHCP responde rapidamente às solicitações do cliente. No entanto, o DHCP pode levar muito tempo para ser concluído em alguns sistemas. Se os serviços de rede tentarem executar antes que o DHCP tenha atribuído as informações de endereçamento de rede, eles falharão. O uso do DHCP no modo <em>synchronous</em> impede esse problema, pois ele pausa a inicialização até que a configuração DHCP seja concluída.</p></div><div class=paragraph><p>Esta linha no <span class=filename>/etc/rc.conf</span> é usada para configurar o modo background ou assíncrono:</p></div><div class="literalblock programlisting"><div class=content><pre>ifconfig_fxp0=&#34;DHCP&#34;</pre></div></div><div class=paragraph><p>Esta linha pode já existir se o sistema foi configurado para usar o DHCP durante a instalação. Substitua o <em>fxp0</em> mostrado nesses exemplos pelo nome da interface a ser configurada dinamicamente, conforme descrito em <a href=./#config-network-setup>Configurando Placas de Interface de Rede</a>.</p></div><div class=paragraph><p>Para configurar o sistema para usar o modo síncrono e pausar durante a inicialização enquanto o DHCP é concluído, use “SYNCDHCP”:</p></div><div class="literalblock programlisting"><div class=content><pre>ifconfig_fxp0=&#34;SYNCDHCP&#34;</pre></div></div><div class=paragraph><p>Opções adicionais do cliente estão disponíveis. Procure por <code>dhclient</code> in <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a> para detalhes.</p></div><div class=paragraph><p>O cliente DHCP usa os seguintes arquivos:</p></div><div class=ulist><ul><li><p><span class=filename>/etc/dhclient.conf</span></p><div class=paragraph><p>O arquivo de configuração usado pelo <code>dhclient</code>. Normalmente, esse arquivo contém apenas comentários, pois os padrões são adequados para a maioria dos clientes. Este arquivo de configuração é descrito em <a href="https://man.freebsd.org/cgi/man.cgi?query=dhclient.conf&amp;sektion=5&amp;format=html">dhclient.conf(5)</a>.</p></div></li><li><p><span class=filename>/sbin/dhclient</span></p><div class=paragraph><p>Maiores informações sobre o comando em si podem ser encontradas em <a href="https://man.freebsd.org/cgi/man.cgi?query=dhclient&amp;sektion=8&amp;format=html">dhclient(8)</a>.</p></div></li><li><p><span class=filename>/sbin/dhclient-script</span></p><div class=paragraph><p>O script de configuração do cliente DHCP específico do FreeBSD. Ele é descrito em <a href="https://man.freebsd.org/cgi/man.cgi?query=dhclient-script&amp;sektion=8&amp;format=html">dhclient-script(8)</a>, mas não deve precisar de nenhuma modificação do usuário para funcionar corretamente.</p></div></li><li><p><span class=filename>/var/db/dhclient.leases.interface</span></p><div class=paragraph><p>O cliente DHCP mantém um banco de dados de concessões válidas neste arquivo, que é escrito como um log e é descrito em <a href="https://man.freebsd.org/cgi/man.cgi?query=dhclient.leases&amp;sektion=5&amp;format=html">dhclient.leases(5)</a>.</p></div></li></ul></div></div><div class=sect3><h4 id=network-dhcp-server>29.6.2. Instalando e configurando um servidor DHCP<a class=anchor href=#network-dhcp-server></a></h4><div class=paragraph><p>Esta seção demonstra como configurar um sistema FreeBSD para atuar como um servidor DHCP usando a implementação do servidor DHCP do Internet Systems Consortium (ISC). Esta implementação e a sua documentação podem ser instaladas usando o pacote ou port <a class=package href=https://cgit.freebsd.org/ports/tree/net/isc-dhcp44-server/>net/isc-dhcp44-server</a>.</p></div><div class=paragraph><p>A instalação do <a class=package href=https://cgit.freebsd.org/ports/tree/net/isc-dhcp44-server/>net/isc-dhcp44-server</a> instala um arquivo de configuração de exemplo. Copie o <span class=filename>/usr/local/etc/dhcpd.conf.example</span> para <span class=filename>/usr/local/etc/dhcpd.conf</span> e faça as alterações neste novo arquivo.</p></div><div class=paragraph><p>O arquivo de configuração é composto de declarações para sub-redes e hosts que definem as informações que são fornecidas aos clientes DHCP. Por exemplo, essas linhas configuram o seguinte:</p></div><div class="literalblock programlisting"><div class=content><pre>option domain-name &#34;example.org&#34;;<i class=conum data-value=1></i><b>(1)</b>
option domain-name-servers ns1.example.org;<i class=conum data-value=2></i><b>(2)</b>
option subnet-mask 255.255.255.0;<i class=conum data-value=3></i><b>(3)</b>

default-lease-time 600;<i class=conum data-value=4></i><b>(4)</b>
max-lease-time 72400;<i class=conum data-value=5></i><b>(5)</b>
ddns-update-style none;<i class=conum data-value=6></i><b>(6)</b>

subnet 10.254.239.0 netmask 255.255.255.224 {
  range 10.254.239.10 10.254.239.20;<i class=conum data-value=7></i><b>(7)</b>
  option routers rtr-239-0-1.example.org, rtr-239-0-2.example.org;<i class=conum data-value=8></i><b>(8)</b>
}

host fantasia {
  hardware ethernet 08:00:07:26:c0:a5;<i class=conum data-value=9></i><b>(9)</b>
  fixed-address fantasia.fugue.com;<i class=conum data-value=10></i><b>(10)</b>
}</pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>Esta opção especifica o domínio de pesquisa padrão que será fornecido aos clientes. Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=resolv.conf&amp;sektion=5&amp;format=html">resolv.conf(5)</a> para obter maiores informações.</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td>Esta opção especifica uma lista separada por vírgula de servidores DNS que o cliente deve usar. Eles podem ser listados por seus nomes de domínio totalmente qualificados (FQDN), como visto no exemplo, ou por seus endereços de IP.</td></tr><tr><td><i class=conum data-value=3></i><b>3</b></td><td>A máscara de sub-rede que será fornecida aos clientes.</td></tr><tr><td><i class=conum data-value=4></i><b>4</b></td><td>O tempo de expiração da concessão padrão em segundos. Um cliente pode ser configurado para substituir esse valor.</td></tr><tr><td><i class=conum data-value=5></i><b>5</b></td><td>O período máximo permitido de tempo, em segundos, para uma concessão. Se um cliente solicitar uma concessão mais longa, uma concessão ainda será emitida, mas será válida apenas para o tempo especificado em <code>max-lease-time</code>.</td></tr><tr><td><i class=conum data-value=6></i><b>6</b></td><td>O padrão <code>none</code> desabilita as atualizações de DNS dinâmicas. Alterar isso para <code>interim</code> configura o servidor DHCP para atualizar um servidor DNS sempre que for concedido um contrato para que o servidor de DNS saiba quais endereços de IP estão associados a quais computadores na rede. Não altere a configuração padrão, a menos que o servidor de DNS tenha sido configurado para suportar DNS dinâmico.</td></tr><tr><td><i class=conum data-value=7></i><b>7</b></td><td>Esta linha cria um conjunto de endereços IP disponíveis que são reservados para alocação a clientes DHCP. O intervalo de endereços deve ser válido para a rede ou sub-rede especificada na linha anterior.</td></tr><tr><td><i class=conum data-value=8></i><b>8</b></td><td>Declara o gateway padrão que é válido para a rede ou sub-rede especificada antes do colchete de abertura <code>{</code>.</td></tr><tr><td><i class=conum data-value=9></i><b>9</b></td><td>Especifica o endereço de hardware MAC de um cliente para que o servidor DHCP possa reconhecer o cliente quando ele fizer uma solicitação.</td></tr><tr><td><i class=conum data-value=10></i><b>10</b></td><td>Especifica que este host deve sempre receber o mesmo endereço IP. A utilização do nome do host está correta, pois o servidor DHCP resolverá o nome do host antes de retornar as informações de concessão.</td></tr></tbody></table></div><div class=paragraph><p>Este arquivo de configuração suporta muito mais opções. Consulte o <a href="https://man.freebsd.org/cgi/man.cgi?query=dhcpd.conf&amp;sektion=5&amp;format=html">dhcpd.conf(5)</a>, instalado com o servidor, para obter detalhes e exemplos.</p></div><div class=paragraph><p>Uma vez que a configuração do <span class=filename>dhcpd.conf</span> estiver completa, habilite o servidor DHCP em <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>dhcpd_enable=&#34;YES&#34;
dhcpd_ifaces=&#34;dc0&#34;</pre></div></div><div class=paragraph><p>Substitua o <code>dc0</code> pela interface (ou interfaces, separadas por espaço em branco) que o servidor DHCP deverá escutar por solicitações de clientes DHCP.</p></div><div class=paragraph><p>Inicie o servidor executando o seguinte comando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service isc-dhcpd start</span></code></pre></div></div><div class=paragraph><p>Quaisquer mudanças futuras na configuração do servidor exigirão que o serviço dhcpd seja interrompido e, em seguida, iniciado usando <a href="https://man.freebsd.org/cgi/man.cgi?query=service&amp;sektion=8&amp;format=html">service(8)</a>.</p></div><div class=paragraph><p>O servidor DHCP usa os seguintes arquivos. Observe que as páginas de manual são instaladas com o software do servidor.</p></div><div class=ulist><ul><li><p><span class=filename>/usr/local/sbin/dhcpd</span></p><div class=paragraph><p>Maiores informações sobre o servidor dhcpd podem ser encontradas em <a href="https://man.freebsd.org/cgi/man.cgi?query=dhcpd&amp;sektion=8&amp;format=html">dhcpd(8)</a>.</p></div></li><li><p><span class=filename>/usr/local/etc/dhcpd.conf</span></p><div class=paragraph><p>O arquivo de configuração do servidor precisa conter todas as informações que devem ser fornecidas aos clientes, juntamente com informações sobre a operação do servidor. Este arquivo de configuração é descrito no <a href="https://man.freebsd.org/cgi/man.cgi?query=dhcpd.conf&amp;sektion=5&amp;format=html">dhcpd.conf(5)</a>.</p></div></li><li><p><span class=filename>/var/db/dhcpd.leases</span></p><div class=paragraph><p>O servidor DHCP mantém um banco de dados das concessões que ele emitiu neste arquivo, que é gravado como um log. Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=dhcpd.leases&amp;sektion=5&amp;format=html">dhcpd.leases(5)</a>, o qual fornece uma descrição um pouco mais longa.</p></div></li><li><p><span class=filename>/usr/local/sbin/dhcrelay</span></p><div class=paragraph><p>Esse daemon é usado em ambientes avançados, onde um servidor DHCP encaminha uma solicitação de um cliente para outro servidor DHCP em uma rede separada. Se esta funcionalidade for necessária, instale o pacote ou port <a class=package href=https://cgit.freebsd.org/ports/tree/net/isc-dhcp44-relay/>net/isc-dhcp44-relay</a>. A instalação inclui o <a href="https://man.freebsd.org/cgi/man.cgi?query=dhcrelay&amp;sektion=8&amp;format=html">dhcrelay(8)</a>, que fornece maiores detalhes.</p></div></li></ul></div></div></div><div class=sect2><h3 id=network-dns>29.7. Sistema de Nomes de Domínio (DNS)<a class=anchor href=#network-dns></a></h3><div class=paragraph><p>O Sistema de Nomes de Domínio (DNS) é o protocolo através do qual os nomes de domínio são mapeados para endereços de IP e vice-versa. O DNS é coordenado pela Internet através de um sistema complexo de raiz de autoridade, Top Level Domain (TLD) e outros servidores de nomes de menor escala, que hospedam e armazenam em cache domínios individuais. Não é necessário executar um servidor de nomes para executar pesquisas de DNS em um sistema.</p></div><div class=paragraph><p>A tabela a seguir descreve alguns dos termos associados ao DNS:</p></div><table class="tableblock frame-none grid-all stretch"><caption class=title>Tabela 26. Terminologia DNS</caption><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Termo</th><th class="tableblock halign-left valign-top">Definição</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Encaminhamento de DNS</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Mapeamento de nomes de hosts para endereços de IP.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Origem</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Refere-se ao domínio coberto em um arquivo de zona específico.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Resolver</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Um processo do sistema através do qual uma máquina consulta um servidor de nomes para informações de zona.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>DNS Reverso</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Mapeamento de endereços IP para hostnames.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Root zone</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>O início da hierarquia da zona da Internet. Todas as zonas se enquadram na zona de raiz, semelhante a como todos os arquivos em um sistema de arquivos se enquadram no diretório raiz.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Zona</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Um domínio individual, subdomínio ou parte do DNS administrado pela mesma autoridade.</p></td></tr></tbody></table><div class=paragraph><p>Exemplos de zonas:</p></div><div class=ulist><ul><li><p><code>.</code> é como a zona root é geralmente referida na documentação.</p></li><li><p><code>org.</code> é um domínio de nível superior (TLD) sob a zona raiz.</p></li><li><p><code>example.org.</code> é uma zona sob o TLD <code>org.</code>.</p></li><li><p><code>1.168.192.in-addr.arpa</code> é uma zona que faz referência a todos os endereços IP que se enquadram no espaço de endereçamento IP <code>192.168.1.*</code> .</p></li></ul></div><div class=paragraph><p>Como se pode ver, a parte mais específica de um nome de host aparece à esquerda. Por exemplo, <code>example.org.</code> é mais específico que <code>org.</code>, como <code>org.</code> é mais específico que a zona raiz . O layout de cada parte de um nome de host é muito parecido com um sistema de arquivos: o diretório <span class=filename>/dev</span> está dentro da raiz e assim por diante.</p></div><div class=sect3><h4 id=_razões_para_executar_um_servidor_de_nomes>29.7.1. Razões para executar um servidor de nomes<a class=anchor href=#_razões_para_executar_um_servidor_de_nomes></a></h4><div class=paragraph><p>Os servidores de nomes geralmente vêm em duas formas: servidores de nomes autoritativos e servidores de nomes de armazenamento em cache (também conhecidos como servidores de resolução).</p></div><div class=paragraph><p>Um servidor de nomes autoritativo é necessário quando:</p></div><div class=ulist><ul><li><p>Alguém quer servir ao mundo informações de DNS, respondendo autoritariamente a consultas.</p></li><li><p>Um domínio, como <code>example.org</code>, está registrado e os endereços IP precisam ser atribuídos a nomes de host sob ele.</p></li><li><p>Um bloco de endereços IP requer entradas reversas de DNS (IP para hostname).</p></li><li><p>Um servidor de nomes de backup ou secundário, chamado de escravo, responderá às consultas.</p></li></ul></div><div class=paragraph><p>Um servidor de nomes em cache é necessário quando:</p></div><div class=ulist><ul><li><p>Um servidor DNS local pode armazenar em cache e responder mais rapidamente do que consultar um servidor de nomes externo.</p></li></ul></div><div class=paragraph><p>Quando alguém pergunta por <code>www.FreeBSD.org</code>, o resolvedor geralmente consulta o servidor de nomes do ISP e recupera a resposta. Com um servidor local, de cache DNS, a consulta só precisa ser feita uma vez para o mundo externo pelo servidor de Cache DNS. Consultas adicionais não precisarão sair da rede local, pois as informações estão armazenadas em um cache local.</p></div></div><div class=sect3><h4 id=_configuração_do_servidor_de_dns>29.7.2. Configuração do servidor de DNS<a class=anchor href=#_configuração_do_servidor_de_dns></a></h4><div class=paragraph><p>O Unbound é fornecido no sistema básico do FreeBSD. Por padrão, ele fornecerá a resolução de DNS apenas para a máquina local. Embora o pacote básico do sistema possa ser configurado para fornecer serviços de resolução além da máquina local, é recomendável que esses requisitos sejam resolvidos instalando o Unbound da coleção de ports do FreeBSD.</p></div><div class=paragraph><p>Para ativar o Unbound, adicione o seguinte ao <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>local_unbound_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Quaisquer servidores de nomes existentes em <span class=filename>/etc/resolv.conf</span> serão configurados como forwarders na nova configuração do Unbound.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Se algum dos servidores de nomes listados não suportar o DNSSEC, a resolução local DNS falhará. Certifique-se de testar cada servidor de nomes e remover qualquer um que falhe no teste. O seguinte comando mostrará a árvore de confiança ou uma falha para um servidor de nomes em execução em <code>192.168.1.1</code>:</p></div></td></tr></tbody></table></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% drill <span class=nt>-S</span> FreeBSD.org @192.168.1.1</code></pre></div></div><div class=paragraph><p>Quando cada servidor de nomes for confirmado para suportar DNSSEC, inicie o Unbound:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service local_unbound onestart</span></code></pre></div></div><div class=paragraph><p>Isso cuidará da atualização do arquivo <span class=filename>/etc/resolv.conf</span> para que as consultas para domínios seguros DNSSEC funcionem agora. Por exemplo, execute o seguinte DNSSEC para validar a árvore confiável do FreeBSD.org :</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% drill <span class=nt>-S</span> FreeBSD.org
<span class=p>;;</span> Number of trusted keys: 1
<span class=p>;;</span> Chasing: freebsd.org. A

DNSSEC Trust tree:
freebsd.org. <span class=o>(</span>A<span class=o>)</span>
|---freebsd.org. <span class=o>(</span>DNSKEY keytag: 36786 alg: 8 flags: 256<span class=o>)</span>
    |---freebsd.org. <span class=o>(</span>DNSKEY keytag: 32659 alg: 8 flags: 257<span class=o>)</span>
    |---freebsd.org. <span class=o>(</span>DS keytag: 32659 digest <span class=nb>type</span>: 2<span class=o>)</span>
        |---org. <span class=o>(</span>DNSKEY keytag: 49587 alg: 7 flags: 256<span class=o>)</span>
            |---org. <span class=o>(</span>DNSKEY keytag: 9795 alg: 7 flags: 257<span class=o>)</span>
            |---org. <span class=o>(</span>DNSKEY keytag: 21366 alg: 7 flags: 257<span class=o>)</span>
            |---org. <span class=o>(</span>DS keytag: 21366 digest <span class=nb>type</span>: 1<span class=o>)</span>
            |   |---. <span class=o>(</span>DNSKEY keytag: 40926 alg: 8 flags: 256<span class=o>)</span>
            |       |---. <span class=o>(</span>DNSKEY keytag: 19036 alg: 8 flags: 257<span class=o>)</span>
            |---org. <span class=o>(</span>DS keytag: 21366 digest <span class=nb>type</span>: 2<span class=o>)</span>
                |---. <span class=o>(</span>DNSKEY keytag: 40926 alg: 8 flags: 256<span class=o>)</span>
                    |---. <span class=o>(</span>DNSKEY keytag: 19036 alg: 8 flags: 257<span class=o>)</span>
<span class=p>;;</span> Chase successful</code></pre></div></div></div></div><div class=sect2><h3 id=network-apache>29.8. Servidor HTTP Apache<a class=anchor href=#network-apache></a></h3><div class=paragraph><p>O open source Apache HTTP Server é o servidor Web mais utilizado. O FreeBSD não instala este servidor web por padrão, mas ele pode ser instalado a partir do pacote ou Port <a class=package href=https://cgit.freebsd.org/ports/tree/www/apache24/>www/apache24</a>.</p></div><div class=paragraph><p>Esta seção resume como configurar e iniciar a versão 2.<em>x</em> do Servidor HTTP Apache no FreeBSD. Para informações mais detalhadas sobre o Apache2.X e suas diretivas de configuração, consulte <a href=http://httpd.apache.org/>httpd.apache.org</a>.</p></div><div class=sect3><h4 id=_configurando_e_iniciando_o_apache>29.8.1. Configurando e Iniciando o Apache<a class=anchor href=#_configurando_e_iniciando_o_apache></a></h4><div class=paragraph><p>No FreeBSD, o arquivo de configuração principal do Apache HTTP Server é instalado como <span class=filename>/usr/local/etc/apache2x/httpd.conf</span>, onde <em>x</em> representa o número da versão. Este arquivo ASCII de texto inicia as linhas de comentário com um <code>#</code>. As diretivas modificadas com mais freqüência são:</p></div><div class=dlist><dl><dt class=hdlist1><code>ServerRoot "/usr/local"</code></dt><dd><p>Especifica a hierarquia de diretório padrão para a instalação do Apache. Os binários são armazenados nos subdiretórios <span class=filename>bin</span> e <span class=filename>sbin</span> da raiz do servidor e os arquivos de configuração são armazenados no subdiretório <span class=filename>etc/apache2x</span>.</p></dd><dt class=hdlist1><code>ServerAdmin <a href=mailto:you@example.com>you@example.com</a></code></dt><dd><p>Altere isso para seu endereço de e-mail para receber problemas com o servidor. Esse endereço também aparece em algumas páginas geradas pelo servidor, como documentos de erro.</p></dd><dt class=hdlist1><code>ServerName www.example.com:80</code></dt><dd><p>Permite que um administrador defina um nome de host que é enviado de volta aos clientes pelo servidor. Por exemplo, <code>www</code> pode ser usado em vez do nome do host real. Se o sistema não tiver um nome registrado no DNS, insira seu endereço IP. Se o servidor irá escutar em um relatório alternativo, altere a porta <code>80</code> para o número de porta alternativa.</p></dd><dt class=hdlist1><code>DocumentRoot "/usr/local/www/apache2<em>x</em>/data"</code></dt><dd><p>O diretório no qual os documentos serão exibidos. Por padrão, todas as solicitações são obtidas desse diretório, mas os links e aliases simbólicos podem ser usados para apontar para outros locais.</p></dd></dl></div><div class=paragraph><p>É sempre uma boa ideia fazer uma cópia de backup do arquivo de configuração do Apache padrão antes de fazer alterações. Quando a configuração do Apache estiver concluída, salve o arquivo e verifique a configuração usando o <code>apachectl</code>. A execução do <code>apachectl configtest</code> deve retornar <code>Syntax OK</code>.</p></div><div class=paragraph><p>Para iniciar o Apache na inicialização do sistema, adicione a seguinte linha ao <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>apache24_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Se o Apache deve ser iniciado com opções não-padrão, a seguinte linha pode ser adicionada ao <span class=filename>/etc/rc.conf</span> para especificar os flags necessários:</p></div><div class="literalblock programlisting"><div class=content><pre>apache24_flags=&#34;&#34;</pre></div></div><div class=paragraph><p>Se o apachectl não relatar erros de configuração, inicie o <code>httpd</code> agora:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service apache24 start</span></code></pre></div></div><div class=paragraph><p>O serviço <code>httpd</code> pode ser testado inserindo <code>http://<em>localhost</em></code> em um navegador da Web, substituindo <em>localhost</em> pelo nome de domínio totalmente qualificado da máquina que está executando o <code>httpd</code>. A página padrão da Web exibida é <span class=filename>/usr/local/www/apache24/data/index.html</span>.</p></div><div class=paragraph><p>A configuração do Apache pode ser testada quanto a erros depois de fazer alterações subsequentes de configuração enquanto o <code>httpd</code> está em execução usando o seguinte comando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service apache24 configtest</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>É importante notar que o <code>configtest</code> não é um padrão <a href="https://man.freebsd.org/cgi/man.cgi?query=rc&amp;sektion=8&amp;format=html">rc(8)</a> e não se espera que funcione para todos os scripts de inicialização.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=_hospedagem_virtual>29.8.2. Hospedagem Virtual<a class=anchor href=#_hospedagem_virtual></a></h4><div class=paragraph><p>A hospedagem virtual permite que vários sites sejam executados em um servidor Apache. Os hosts virtuais podem ser <em>baseados em IP</em> ou <em>baseados em nome</em>. A hospedagem virtual baseada em IP usa um endereço IP diferente para cada site. A hospedagem virtual baseada em nome usa os cabeçalhos HTTP/1.1 do cliente para descobrir o nome do host, o que permite que os sites compartilhem o mesmo endereço de IP.</p></div><div class=paragraph><p>Para configurar o Apache para usar hospedagem virtual baseada em nome, adicione um bloco <code>VirtualHost</code> para cada site. Por exemplo, para o servidor Web denominado <code>www.domain.tld</code> com um domínio virtual de <code>www.someotherdomain.tld</code>, adicione as seguintes entradas ao arquivo <span class=filename>httpd.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>&lt;VirtualHost *&gt;
    ServerName www.domain.tld
    DocumentRoot /www/domain.tld
&lt;/VirtualHost&gt;

&lt;VirtualHost *&gt;
    ServerName www.someotherdomain.tld
    DocumentRoot /www/someotherdomain.tld
&lt;/VirtualHost&gt;</pre></div></div><div class=paragraph><p>Para cada host virtual, substitua os valores de <code>ServerName</code> e <code>DocumentRoot</code> pelos valores a serem usados.</p></div><div class=paragraph><p>Para obter mais informações sobre como configurar hosts virtuais, consulte a documentação oficial do Apache em: <a href=http://httpd.apache.org/docs/vhosts/>http://httpd.apache.org/docs/vhosts/</a>.</p></div></div><div class=sect3><h4 id=_módulos_apache>29.8.3. Módulos Apache<a class=anchor href=#_módulos_apache></a></h4><div class=paragraph><p>O Apache usa módulos para aumentar a funcionalidade fornecida pelo servidor básico. Consulte o <a href=http://httpd.apache.org/docs/current/mod/>http://httpd.apache.org/docs/current/mod/</a> para uma lista completa e detalhes de configuração para os módulos disponíveis.</p></div><div class=paragraph><p>No FreeBSD, alguns módulos podem ser compilados com o port <a class=package href=https://cgit.freebsd.org/ports/tree/www/apache24/>www/apache24</a>. Digite <code>make config</code> dentro do diretório <span class=filename>/usr/ports/www/apache24</span> para ver quais módulos estão disponíveis e quais estão ativados por padrão. Se o módulo não é compilado com o port, a Coleção de Ports do FreeBSD fornece uma maneira fácil de instalar vários módulos. Esta seção descreve três dos módulos mais usados.</p></div><div class=sect4><h5 id=_suporte_ssl>29.8.3.1. Suporte SSL<a class=anchor href=#_suporte_ssl></a></h5><div class=paragraph><p>Em algum momento, o suporte para o SSL dentro do Apache requer um modulo secundário chamado <span class=filename>mod_ssl</span>. Esse não é mais o casoe a instalação padrão do Apache vem com SSL embutido no servidor web. Um exemplo de como habilitar o suporte para paginas com SSL está disponível no arquivo <span class=filename>http-ssl.conf</span> instalado dentro do diretório <span class=filename>/usr/local/etc/apache24/extra</span>. Dentro desse diretório também esta um exemplo do arquivo chamado <span class=filename>ssl.conf-sample</span>. É recomendado que ambos arquivos sejam avaliados para configurar apropriadamente páginas seguras no servidor web Apache.</p></div><div class=paragraph><p>Depois da configuração do SSL estiver completa, deve ser removido o comentário da linha seguinte no arquivo <span class=filename>http.conf</span> principal para ativar as mudanças no próximo restart ou reload do Apache:</p></div><div class="literalblock programlisting"><div class=content><pre>#Include etc/apache24/extra/httpd-ssl.conf</pre></div></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Versão dois do SSL e a versão três tem problemas de vulnerabilidades conhecidas. É altamente recomendado a versão 1.2 do TLS e 1.3 deve ser habilitada no lugar das velhas opções do SSL. Isso pode ser realizado configurando as seguintes opções no arquivo <span class=filename>ssl.conf</span>:</p></div></td></tr></tbody></table></div><div class="literalblock programlisting"><div class=content><pre>SSLProtocol all -SSLv3 -SSLv2 +TLSv1.2 +TLSv1.3
SSLProxyProtocol all -SSLv2 -SSLv3 -TLSv1 -TLSv1.1</pre></div></div><div class=paragraph><p>Para completar a configuração do SSL no servidor web, remova os comentários da seguinte linha para garantir que a configuração irá ser enviada para dentro do Apache durante o restart ou reload:</p></div><div class="literalblock programlisting"><div class=content><pre># Secure (SSL/TLS) connections
Include etc/apache24/extra/httpd-ssl.conf</pre></div></div><div class=paragraph><p>As linhas a seguir também devem ser descomentadas no <span class=filename>httpd.conf</span> para suportar totalmente o SSL no Apache:</p></div><div class="literalblock programlisting"><div class=content><pre>LoadModule authn_socache_module libexec/apache24/mod_authn_socache.so
LoadModule socache_shmcb_module libexec/apache24/mod_socache_shmcb.so
LoadModule ssl_module libexec/apache24/mod_ssl.so</pre></div></div><div class=paragraph><p>O próximo passo é trabalhar com uma autoridade certificadora para ter certificados apropriados instalados no sistema. Isso vai configurar um cadeia de confiança para a pagina e prever alguns avisos de certificados auto assinados.</p></div></div><div class=sect4><h5 id=_mod_perl>29.8.3.2. <span class=filename>mod_perl</span><a class=anchor href=#_mod_perl></a></h5><div class=paragraph><p>O módulo <span class=filename>mod_perl</span> torna possível escrever módulos Apache em Perl. Além disso, o intérprete persistente embutido no servidor evita a sobrecarga de iniciar um intérprete externo e a penalidade do tempo de inicialização do Perl.</p></div><div class=paragraph><p>O <span class=filename>mod_perl</span> pode ser instalado usando o pacote ou port <a class=package href=https://cgit.freebsd.org/ports/tree/www/mod_perl2/>www/mod_perl2</a>. A documentação para usar este módulo pode ser encontrada em <a href=http://perl.apache.org/docs/2.0/index.html>http://perl.apache.org/docs/2.0/index .html</a>.</p></div></div><div class=sect4><h5 id=_mod_php>29.8.3.3. <span class=filename>mod_php</span><a class=anchor href=#_mod_php></a></h5><div class=paragraph><p><em>PHP: Pré-processador de hipertexto</em> ( PHP ) é uma linguagem de script de propósito geral que é especialmente adequada para desenvolvimento web. Capaz de ser incorporada em HTML, sua sintaxe se baseia em C, Java™ e Perl com a intenção de permitir desenvolvedores web para escrever rapidamente páginas da web geradas dinamicamente.</p></div><div class=paragraph><p>Suporte para PHP para o Apache e alguma outra parte escrita na linguagem, pode ser adicionada instalando o port apropriado.</p></div><div class=paragraph><p>Para todas versões suportadas, procure os dados do pacote usando o comando <code>pkg</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg search php</span></code></pre></div></div><div class=paragraph><p>Uma lista vai ser disponibilizada incluindo as versões e partes adicionais que elas proverem. Os componentes são completamente modulares, significando que as partes especificas são habilitadas instalando o port apropriado. Para instalar o PHP na versão 7.4 para o Apache, use o seguinte comando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install mod_php74</span></code></pre></div></div><div class=paragraph><p>Se algum pacote dependente precisar ser instalado, ele irá ser instalado também.</p></div><div class=paragraph><p>Por padrão, o PHP não estará habilitado. As seguintes linhas precisam ser adicionadas no arquivo de configuração do Apache localizado em <span class=filename>/usr/local/etc/apache24</span> para ativa-lo:</p></div><div class="literalblock programlisting"><div class=content><pre>&lt;FilesMatch &#34;\.php$&#34;&gt;
    SetHandler application/x-httpd-php
&lt;/FilesMatch&gt;
&lt;FilesMatch &#34;\.phps$&#34;&gt;
    SetHandler application/x-httpd-php-source
&lt;/FilesMatch&gt;</pre></div></div><div class=paragraph><p>Em adição, a opção <code>DirectoryIndex</code> no arquivo de configuração irá precisar ser atualizada também e o Apache irá precisar ser reiniciado ou feito um relaoad também para as mudanças surtirem efeito.</p></div><div class=paragraph><p>Suporte para muitas partes do PHP podem ser instalado também usando o comando <code>pkg</code>. Por exemplo, para instalar suporte para o XML ou para SSL, instale os seguintes ports:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install php74-xml php74-openssl</span></code></pre></div></div><div class=paragraph><p>Como antes, a configuração do Apache irá precisar ser recarregada para as mudanças surtirem efeito, mesmo em casos onde foi feita apenas a instalação de um modulo.</p></div><div class=paragraph><p>Para realizar uma reinicialização normal para recarregar a configuração, digite o seguinte comando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># apachectl graceful</span></code></pre></div></div><div class=paragraph><p>Uma vez que a instalação esteja completa, há dois métodos para obter o suporte para os modulos do PHP e a informação do ambiente dessa instalação. A primeira é instalar o binário completo do PHP e rodar o seguinte comando para obter a informação:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install php74</span></code></pre></div></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># php -i |less</span></code></pre></div></div><div class=paragraph><p>Isso é necessário para passar a saída paga um paginador, como o comando <code>more</code> ou <code>less</code> para visualizar melhor a saída.</p></div><div class=paragraph><p>Finalmente, para fazer alguma mudança na configuração global do PHP há um arquivo bem documentado instalado dentro de <span class=filename>/usr/local/etc/php.ini</span>. No momento da instalação, esse arquivo não irá existir porque há duas versões para escolher, uma é o arquivo <span class=filename>php.ini-development</span> e outra o <span class=filename>php.ini-production</span>. Esses são pontos iniciais para ajudar os administradores na implementação.</p></div></div><div class=sect4><h5 id=_suporte_a_http2>29.8.3.4. Suporte a HTTP2<a class=anchor href=#_suporte_a_http2></a></h5><div class=paragraph><p>Suporte do Apache para o protocolo HTTP está incluido por padrão quando instala o port com o comando <code>pkg</code>. A nova versão do HTTP inclui muitas melhorias em relação a versão anterior, incluindo utilizar uma conexão singular para uma página, reduzindo as idas e vindas de conexões TCP. Também, os dados no cabeçalho do pacote é comprimido e o HTTP2 requer encriptação por padrão.</p></div><div class=paragraph><p>Quando o Apache estiver configurado para usar HTTP2 apenas, os navegadores web irão requisitar conexões seguras, encriptadas com HTTPS. Quando o Apache estiver configurado para usar ambas versões, o HTTP1.1 irá ser considerado uma opção substituta se algum problema surgir durante a conexão.</p></div><div class=paragraph><p>Embora essa mudança exija que os administradores façam alterações, elas são positivas e equivalem a uma Internet mais segura para todos. As mudanças são requeridas apenas para paginas não implementada corretamente com SSL e TLS.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Essa configuração depende das seções anteriores, incluindo suporte a TLS. É recomendado que essas instruções seja seguidas antes de continuar com essa configuração.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Comece o processo habilitando o modulo http2 removendo o comentário da linha no arquivo <span class=filename>/usr/local/etc/apache24/httpd.conf</span> e trocando o modulo mpm_prefork pelo mpm_event pois o anterior não suporta o http2.</p></div><div class="literalblock programlisting"><div class=content><pre>LoadModule http2_module libexec/apache24/mod_http2.so
LoadModule mpm_event_module libexec/apache24/mod_mpm_event.so</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Aqui há um port <span class=filename>mod_http1</span> distinto que está disponível. Ele existe pra entregar segurança e correção de bugs mais rápido que o modulo instalado por padrão com o port <span class=filename>apache24</span>. Ele não é requisitado para o suporte do HTTP2 mas está disponível. Quando instalado, o <span class=filename>mod_h2.so</span> deve ser usado no lugar do <span class=filename>mod_http2.so</span> na configuração do Apache.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Aqui há dois métodos para implementar o HTTP2 no Apache; um caminho é de forma global para todos os sites e cada VirtualHost rodando no sistema. Para habilitar o HTTP2 globalmente, adicione a seguinte linha abaixo da diretiva ServerName:</p></div><div class="literalblock programlisting"><div class=content><pre>Protocolos h2 http/1.1</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Para habilitar HTTP2 sobre texto simples, use h2h2chttp/1.1 no arquivo <span class=filename>httpd.conf</span>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Tendo o h2c aqui irá permitir que o dado em texto simples do HTTP2 passar pelo sistema mas isso não é recomendado. Em adição a isso, usando o http/1.1 aqui irá permitir retornar para a versão do protocolo HTTP1.1 caso sejá necessário pelo sistema.</p></div><div class=paragraph><p>Para habilitar HTTP2 para VirtualHosts individuais, adicione a mesma linha com a diretiva VirtualHost no arquivo <span class=filename>httpd.conf</span> ou <span class=filename>httpd-ssl.conf</span>.</p></div><div class=paragraph><p>Recarregue a configuração usando o comando <code>apachectl</code> reload e teste a configuração seguindo um dos métodos após visitar uma das paginas hosteadas:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># grep &#34;HTTP/2.0&#34; /var/log/httpd-access.log</span></code></pre></div></div><div class=paragraph><p>A saída deve ser semelhante à seguinte:</p></div><div class="literalblock programlisting"><div class=content><pre>192.168.1.205 - - [18/Oct/2020:18:34:36 -0400] &#34;GET / HTTP/2.0&#34; 304 -
192.0.2.205 - - [18/Oct/2020:19:19:57 -0400] &#34;GET / HTTP/2.0&#34; 304 -
192.0.0.205 - - [18/Oct/2020:19:20:52 -0400] &#34;GET / HTTP/2.0&#34; 304 -
192.0.2.205 - - [18/Oct/2020:19:23:10 -0400] &#34;GET / HTTP/2.0&#34; 304 -</pre></div></div><div class=paragraph><p>O outro metodo é usar o navegador web padrão no debugger do site ou o comando <code>tcpdump</code>; contanto, o uso de qualquer método está além do escopo desse documento.</p></div><div class=paragraph><p>Suporte para conexões do proxy reverso HTTP2 usando o modulo <span class=filename>mod_proxy_http2.so</span>. Quando declarado na configuração o ProxyPass ou RewriteRules [P], eles devem usar h2:// para a conexão.</p></div></div></div><div class=sect3><h4 id=_websites_dinâmicos>29.8.4. Websites Dinâmicos<a class=anchor href=#_websites_dinâmicos></a></h4><div class=paragraph><p>Além do mod_perl e do mod_php, outras linguagens estão disponíveis para a criação de conteúdo dinâmico da web. Estes incluem o Django e o Ruby on Rails.</p></div><div class=sect4><h5 id=_django>29.8.4.1. Django<a class=anchor href=#_django></a></h5><div class=paragraph><p>O Django é um framework de licença BSD projetado para permitir que desenvolvedores escrevam aplicações web elegantes e de alto desempenho rapidamente. Ele fornece um mapeador relacional de objeto para que os tipos de dados sejam desenvolvidos como objetos Python. Uma API rica e dinâmica de acesso ao banco de dados é fornecida para os objetos sem que o desenvolvedor tenha que escrever SQL. Ele também fornece um sistema de template extensível para que a lógica do aplicativo seja separada da apresentação HTML.</p></div><div class=paragraph><p>Django depende de <span class=filename>mod_python</span>, e um mecanismo de banco de dados SQL. No FreeBSD, o port <a class=package href=https://cgit.freebsd.org/ports/tree/www/py-django/>www/py-django</a> instala automaticamente o <span class=filename>mod_python</span> e suporta os banco de dados PostgreSQL, MySQL, ou SQLite, com o padrão sendo o SQLite. Para trocar o mecanismo de banco de dados, digite <code>make config</code> dentro do diretório <span class=filename>/usr/ports/www/py-django</span>, então instale o port.</p></div><div class=paragraph><p>Uma vez instalado o Django, a aplicação precisará de um diretório de projeto junto com a configuração Apache para usar o interpretador Python incorporado. Este intérprete é usado para chamar o aplicativo para URLs específicas no site.</p></div><div class=paragraph><p>Para configurar o Apache para que passe a fazer solicitações para determinadas URLs para a aplicação Web, adicione o seguinte ao <span class=filename>httpd.conf</span>, especificando o caminho completo para o diretório do projeto:</p></div><div class="literalblock programlisting"><div class=content><pre>&lt;Location &#34;/&#34;&gt;
    SetHandler python-program
    PythonPath &#34;[&#39;/dir/to/the/django/packages/&#39;] + sys.path&#34;
    PythonHandler django.core.handlers.modpython
    SetEnv DJANGO_SETTINGS_MODULE mysite.settings
    PythonAutoReload On
    PythonDebug On
&lt;/Location&gt;</pre></div></div><div class=paragraph><p>Consulte <a href=https://docs.djangoproject.com>https://docs.djangoproject.com</a> para maiores informações sobre como usar o Django.</p></div></div><div class=sect4><h5 id=_ruby_on_rails>29.8.4.2. Ruby on Rails<a class=anchor href=#_ruby_on_rails></a></h5><div class=paragraph><p>O Ruby on Rails é outro framework de software livre da Web que fornece uma stack de desenvolvimento completa. Ele é otimizado para tornar os desenvolvedores da Web mais produtivos e capazes de criar rapidamente aplicativos poderosos. No FreeBSD, ele pode ser instalado usando o pacote ou port <a class=package href=https://cgit.freebsd.org/ports/tree/www/rubygem-rails/>www/rubygem-rails</a>.</p></div><div class=paragraph><p>Consulte <a href=http://guides.rubyonrails.org>http://guides.rubyonrails.org</a> para maiores informações sobre como usar o Ruby on Rails .</p></div></div></div></div><div class=sect2><h3 id=network-ftp>29.9. Protocolo de Transferência de Arquivos (FTP)<a class=anchor href=#network-ftp></a></h3><div class=paragraph><p>O Protocolo de Transferência de Arquivos (FTP) fornece aos usuários uma maneira simples de transferir arquivos para um servidor FTP. O FreeBSD inclui o software do servidor FTP, ftpd, no sistema base.</p></div><div class=paragraph><p>O FreeBSD fornece vários arquivos de configuração para controlar o acesso ao servidor FTP. Esta seção resume esses arquivos. Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=ftpd&amp;sektion=8&amp;format=html">ftpd(8)</a> para obter mais detalhes sobre o servidor FTP incorporado.</p></div><div class=sect3><h4 id=_configuração_2>29.9.1. Configuração<a class=anchor href=#_configuração_2></a></h4><div class=paragraph><p>A etapa de configuração mais importante é decidir quais contas terão permissão para acessar o servidor FTP. Um sistema FreeBSD possui várias contas do sistema que não devem ter acesso ao FTP. A lista de usuários que não permitem acesso FTP pode ser encontrada em <span class=filename>/etc/ftpusers</span>. Por padrão, inclui contas do sistema. Usuários adicionais que não devem ter acesso a FTP podem ser adicionados.</p></div><div class=paragraph><p>Em alguns casos, pode ser desejável restringir o acesso de alguns usuários sem impedi-los completamente de usar o FTP. Isso pode ser feito criando <span class=filename>/etc/ftpchroot</span> como descrito em <a href="https://man.freebsd.org/cgi/man.cgi?query=ftpchroot&amp;sektion=5&amp;format=html">ftpchroot(5)</a>. Este arquivo lista usuários e grupos sujeitos a restrições de acesso a FTP.</p></div><div class=paragraph><p>Para permitir acesso anônimo ao servidor FTP, crie um usuário chamado <code>ftp</code> no sistema FreeBSD. Os usuários poderão então fazer logon no servidor FTP com um nome de usuário <code>ftp</code> ou <code>anonymous</code> . Quando for solicitada a senha, qualquer entrada será aceita, mas por convenção, um endereço de e-mail deverá ser usado como a senha. O servidor FTP chamará <a href="https://man.freebsd.org/cgi/man.cgi?query=chroot&amp;sektion=2&amp;format=html">chroot(2)</a> quando um usuário anônimo efetuar login para restringir o acesso somente ao diretório home do usuário <code>ftp</code>.</p></div><div class=paragraph><p>Existem dois arquivos de texto que podem ser criados para especificar mensagens de boas-vindas a serem exibidas para clientes FTP. O conteúdo de <span class=filename>/etc/ftpwelcome</span> será exibido aos usuários antes que eles atinjam o prompt de login. Após um login bem sucedido, o conteúdo de <span class=filename>/etc/ftpmotd</span> será exibido. Observe que o caminho para esse arquivo é relativo ao ambiente de login, portanto, o conteúdo de <span class=filename>~ftp/etc/ftpmotd</span> seria exibido para usuários anônimos.</p></div><div class=paragraph><p>Uma vez configurado o servidor FTP, defina a variável apropriada em <span class=filename>/etc/rc.conf</span> para iniciar o serviço durante a inicialização:</p></div><div class="literalblock programlisting"><div class=content><pre>ftpd_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Para iniciar o serviço agora:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service ftpd start</span></code></pre></div></div><div class=paragraph><p>Teste a conexão com o servidor FTP digitando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ftp localhost</code></pre></div></div><div class=paragraph><p>O daemon ftpd usa o <a href="https://man.freebsd.org/cgi/man.cgi?query=syslog&amp;sektion=3&amp;format=html">syslog(3)</a> para registrar mensagens. Por padrão, o daemon de log do sistema gravará mensagens relacionadas a FTP em <span class=filename>/var/log/xferlog</span>. A localização do log do FTP pode ser modificada alterando a seguinte linha no <span class=filename>/etc/syslog.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>ftp.info      /var/log/xferlog</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Esteja ciente dos possíveis problemas envolvidos na execução de um servidor FTP anônimo. Em particular, pense duas vezes antes de permitir que usuários anônimos façam upload de arquivos. Pode acontecer que o site FTP se torne um fórum para o comércio de software comercial não licenciado ou pior. Se uploads anônimos de FTP forem necessários, verifique as permissões para que esses arquivos não possam ser lidos por outros usuários anônimos até que sejam revisados por um administrador.</p></div></td></tr></tbody></table></div></div></div><div class=sect2><h3 id=network-samba>29.10. Serviços de arquivos e impressão para clientes Microsoft™Windows™ Clients (Samba)<a class=anchor href=#network-samba></a></h3><div class=paragraph><p>Samba é um popular pacote de software de código aberto que fornece serviços de arquivo e impressão usando o protocolo SMB/CIFS. Este protocolo está incorporado nos sistemas Microsoft™Windows™. Ele pode ser adicionado a sistemas não Microsoft™Windows™ instalando as bibliotecas-cliente Samba. O protocolo permite que os clientes acessem dados e impressoras compartilhadas. Esses compartilhamentos podem ser mapeados como uma unidade de disco local e as impressoras compartilhadas podem ser usadas como se fossem impressoras locais.</p></div><div class=paragraph><p>No FreeBSD, as bibliotecas cliente do Samba podem ser instaladas usando o port ou pacote <a class=package href=https://cgit.freebsd.org/ports/tree/net/samba410/>net/samba410</a>. O cliente fornece a capacidade de um sistema FreeBSD acessar compartilhamentos de SMB/CIFS em uma rede Microsoft™Windows™.</p></div><div class=paragraph><p>Um sistema FreeBSD também pode ser configurado para atuar como um servidor Samba instalando o port ou pacote <a class=package href=https://cgit.freebsd.org/ports/tree/net/samba410/>net/samba410</a>. Isso permite que o administrador crie compartilhamentos de SMB/CIFS no sistema FreeBSD que podem ser acessados por clientes executando Microsoft™Windows™ ou as bibliotecas do cliente Samba.</p></div><div class=sect3><h4 id=_configuração_do_servidor>29.10.1. Configuração do Servidor<a class=anchor href=#_configuração_do_servidor></a></h4><div class=paragraph><p>O Samba é configurado em <span class=filename>/usr/local/etc/smb4.conf</span>. Este arquivo deve ser criado antes que o Samba possa ser usado.</p></div><div class=paragraph><p>Um simples <span class=filename>smb4.conf</span> para compartilhar diretórios e impressoras com clientes Windows™ em um grupo de trabalho é mostrado aqui. Para configurações mais complexas envolvendo LDAP ou Active Directory, é mais fácil usar o <a href="https://man.freebsd.org/cgi/man.cgi?query=samba-tool&amp;sektion=8&amp;format=html">samba-tool(8)</a> para criar o <span class=filename>smb4.conf</span>.</p></div><div class="literalblock programlisting"><div class=content><pre>[global]
workgroup = WORKGROUP
server string = Samba Server Version %v
netbios name = ExampleMachine
wins support = Yes
security = user
passdb backend = tdbsam

# Example: share /usr/src accessible only to &#39;developer&#39; user
[src]
path = /usr/src
valid users = developer
writable  = yes
browsable = yes
read only = no
guest ok = no
public = no
create mask = 0666
directory mask = 0755</pre></div></div><div class=sect4><h5 id=_configurações_globais>29.10.1.1. Configurações Globais<a class=anchor href=#_configurações_globais></a></h5><div class=paragraph><p>As configurações que descrevem a rede são adicionadas em <span class=filename>/usr/local/etc/smb4.conf</span>:</p></div><div class=dlist><dl><dt class=hdlist1><code>workgroup</code></dt><dd><p>O nome do grupo de trabalho a ser servido.</p></dd><dt class=hdlist1><code>netbios name</code></dt><dd><p>O nome NetBIOS pelo qual um servidor Samba é conhecido. Por padrão, é o mesmo que o primeiro componente do nome do DNS do host.</p></dd><dt class=hdlist1><code>server string</code></dt><dd><p>A string que será exibida na saída de <code>net view</code> e algumas outras ferramentas de rede que buscam exibir texto descritivo sobre o servidor.</p></dd><dt class=hdlist1><code>wins support</code></dt><dd><p>Se o Samba funcionará como um servidor WINS. Não habilite o suporte para WINS em mais de um servidor na rede.</p></dd></dl></div></div><div class=sect4><h5 id=_configurações_de_segurança>29.10.1.2. Configurações de Segurança<a class=anchor href=#_configurações_de_segurança></a></h5><div class=paragraph><p>As configurações mais importantes em <span class=filename>/usr/local/etc/smb4.conf</span> são o modelo de segurança e o formato de senha de backend. Essas diretivas controlam as opções:</p></div><div class=dlist><dl><dt class=hdlist1><code>security</code></dt><dd><p>As configurações mais comuns são <code>security=share</code> e <code>security=user</code>. Se os clientes usarem nomes de usuários que sejam os mesmos nomes de usuários na máquina do FreeBSD, a segurança no nível do usuário deve ser usada. Essa é a política de segurança padrão e exige que os clientes façam logon pela primeira vez antes de poderem acessar recursos compartilhados.</p><div class=paragraph><p>Na segurança em nível de compartilhamento, os clientes não precisam efetuar logon no servidor com um nome de usuário e senha válidos antes de tentar se conectar a um recurso compartilhado. Este era o modelo de segurança padrão para versões mais antigas do Samba.</p></div></dd><dt class=hdlist1><code>passdb backend</code></dt><dd><p>O Samba possui vários modelos de autenticação de backend diferentes. Os clientes podem ser autenticados com LDAP, NIS+, um banco de dados SQL ou um arquivo de senha modificado. O método de autenticação recomendado, <code>tdbsam</code>, é ideal para redes simples e é abordado aqui. Para redes maiores ou mais complexas, o <code>ldapsam</code> é recomendado. <code>smbpasswd</code> foi o padrão anterior e agora está obsoleto.</p></dd></dl></div></div><div class=sect4><h5 id=_usuários_do_samba>29.10.1.3. Usuários do Samba<a class=anchor href=#_usuários_do_samba></a></h5><div class=paragraph><p>As contas de usuário do FreeBSD devem ser mapeadas para o banco de dados <code>SambaSAMAccount</code> para que os clientes Windows™ acessem o compartilhamento. Mapear contas de usuários existentes do FreeBSD usando <a href="https://man.freebsd.org/cgi/man.cgi?query=pdbedit&amp;sektion=8&amp;format=html">pdbedit(8)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pdbedit -a username</span></code></pre></div></div><div class=paragraph><p>Esta seção mencionou apenas as configurações mais usadas. Consulte a <a href=https://wiki.samba.org>Wiki Oficial do Samba</a> para obter informações adicionais sobre as opções de configuração disponíveis.</p></div></div></div><div class=sect3><h4 id=_iniciando_o_samba>29.10.2. Iniciando o Samba<a class=anchor href=#_iniciando_o_samba></a></h4><div class=paragraph><p>Para habilitar o Samba no momento da inicialização, adicione a seguinte linha ao <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>samba_server_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Para iniciar o Samba agora:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service samba_server start</span>
Performing sanity check on Samba configuration: OK
Starting nmbd.
Starting smbd.</code></pre></div></div><div class=paragraph><p>O Samba consiste em três daemons separados. Os daemons nmbd e smbd são iniciados por <code>samba_enable</code>. Se resolução de nomes winbind também é necessária, defina:</p></div><div class="literalblock programlisting"><div class=content><pre>winbindd_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>O Samba pode ser interrompido a qualquer momento digitando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service samba_server stop</span></code></pre></div></div><div class=paragraph><p>O Samba é um conjunto de software complexo com funcionalidade que permite ampla integração com as redes Microsoft™Windows™. Para mais informações sobre a funcionalidade além da configuração básica descrita aqui, consulte <a href=https://www.samba.org>https://www.samba.org</a>.</p></div></div></div><div class=sect2><h3 id=network-ntp>29.11. Sincronização de Relógio com NTP<a class=anchor href=#network-ntp></a></h3><div class=paragraph><p>Com o tempo, o relógio de um computador está propenso a se desviar. Isso é problemático, pois muitos serviços de rede exigem que os computadores em uma rede compartilhem o mesmo tempo exato. Tempo preciso também é necessário para garantir que os registros de data e hora dos arquivos permaneçam consistentes. O protocolo de horário da rede (NTP) é uma maneira de fornecer precisão de relógio em uma rede.</p></div><div class=paragraph><p>O FreeBSD inclui o <a href="https://man.freebsd.org/cgi/man.cgi?query=ntpd&amp;sektion=8&amp;format=html">ntpd(8)</a> o qual pode ser configurado para consultar outros servidores NTP para sincronizar o relógio nessa máquina ou para fornecer serviços de horário para outros computadores na rede.</p></div><div class=paragraph><p>Esta seção descreve como configurar o ntpd no FreeBSD. Mais documentação pode ser encontrada em <span class=filename>/usr/shared/doc/ntp/</span> no formato HTML.</p></div><div class=sect3><h4 id=_configuração_de_ntp>29.11.1. Configuração de NTP<a class=anchor href=#_configuração_de_ntp></a></h4><div class=paragraph><p>No FreeBSD, o ntpd nativo pode ser usado para sincronizar o relógio do sistema. O Ntpd é configurado usando variáveis no <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a> e no <span class=filename>/etc/ntp.conf</span>, conforme detalhado nas seções a seguir.</p></div><div class=paragraph><p>O Ntpd se comunica com seus network peers usando pacotes UDP. Quaisquer firewalls entre sua máquina e seus NTP peers devem ser configurados para permitir a entrada e saída de pacotes UDP na porta 123.</p></div><div class=sect4><h5 id=_o_arquivo_etcntp_conf>29.11.1.1. O arquivo <span class=filename>/etc/ntp.conf</span><a class=anchor href=#_o_arquivo_etcntp_conf></a></h5><div class=paragraph><p>O Ntpd faz a leitura do <span class=filename>/etc/ntp.conf</span> para determinar quais servidores NTP que ele deve consultar. É recomendável escolher vários servidores NTP, caso um dos servidores se torne inacessível ou seu relógio torne-se não confiável. Como o ntpd recebe respostas, ele favorece servidores confiáveis em vez dos menos confiáveis. Os servidores consultados podem ser locais na rede, fornecidos por um ISP ou selecionados a partir de uma <a href=http://support.ntp.org/bin/view/Servers/WebHome>lista online de servidores NTP publicamente acessíveis</a>. Ao escolher um servidor NTP público, selecione um servidor geograficamente próximo e revise sua política de uso. A palavra-chave <code>pool</code> de configuração seleciona um ou mais servidores de um pool de servidores. Está disponível uma <a href=http://support.ntp.org/bin/view/Servers/NTPPoolServers>lista online de pools NTP publicamente acessíveis</a>, organizada por área geográfica. Além disso, o FreeBSD fornece um pool patrocinado pelo projeto, <code>0.freebsd.pool.ntp.org</code>.</p></div><div class=exampleblock><div class=title>Exemplo 47. Exemplo de <span class=filename>/etc/ntp.conf</span></div><div class=content><div class=paragraph><p>Este é um exemplo simples de um arquivo <span class=filename>ntp.conf</span>. Ele pode ser usado com segurança como está; ele contém as opções <code>restrict</code> recomendadas para operação em uma conexão de rede pública.</p></div><div class="literalblock programlisting"><div class=content><pre># Disallow ntpq control/query access.  Allow peers to be added only
# based on pool and server statements in this file.
restrict default limited kod nomodify notrap noquery nopeer
restrict source  limited kod nomodify notrap noquery

# Allow unrestricted access from localhost for queries and control.
restrict 127.0.0.1
restrict ::1

# Add a specific server.
server ntplocal.example.com iburst

# Add FreeBSD pool servers until 3-6 good servers are available.
tos minclock 3 maxclock 6
pool 0.freebsd.pool.ntp.org iburst

# Use a local leap-seconds file.
leapfile &#34;/var/db/ntpd.leap-seconds.list&#34;</pre></div></div></div></div><div class=paragraph><p>O formato deste arquivo é descrito em <a href="https://man.freebsd.org/cgi/man.cgi?query=ntp.conf&amp;sektion=5&amp;format=html">ntp.conf(5)</a>. As descrições abaixo fornecem uma visão geral rápida apenas das palavras-chave usadas no arquivo de exemplo acima.</p></div><div class=paragraph><p>Por padrão, um servidor NTP pode ser acessado de qualquer host da rede. A palavra-chave <code>restrict</code> controla quais sistemas podem acessar o servidor. Múltiplas entradas <code>restrict</code> são suportadas, cada uma refinando as restrições fornecidas nas instruções anteriores. Os valores mostrados no exemplo concedem ao sistema local o acesso completo à consulta e controle, enquanto permitem aos sistemas remotos apenas a capacidade de consultar o horário. Para obter mais detalhes, consulte a subseção <code>Access Control Support</code> de <a href="https://man.freebsd.org/cgi/man.cgi?query=ntp.conf&amp;sektion=5&amp;format=html">ntp.conf(5)</a>.</p></div><div class=paragraph><p>A palavra-chave <code>server</code> especifica um único servidor para consulta. O arquivo pode conter várias palavras-chave server, com um servidor listado em cada linha. A palavra-chave <code>pool</code> especifica um pool de servidores. O Ntpd adicionará um ou mais servidores desse pool, conforme necessário, para atingir o número de peers especificado usando o valor <code>tos minclock</code>. A palavra-chave <code>iburst</code> direciona o ntpd para executar um burst de oito trocas rápidas de pacotes com um servidor quando o contato é estabelecido pela primeira vez, para ajudar a sincronizar rapidamente a hora do sistema.</p></div><div class=paragraph><p>A palavra-chave <code>leapfile</code> especifica o local de um arquivo que contém informações sobre segundos bissextos. O arquivo é atualizado automaticamente pelo <a href="https://man.freebsd.org/cgi/man.cgi?query=periodic&amp;sektion=8&amp;format=html">periodic(8)</a>. O local do arquivo especificado por esta palavra-chave deve corresponder ao local definido na variável <code>ntp_db_leapfile</code> em <span class=filename>/etc/rc.conf</span>.</p></div></div><div class=sect4><h5 id=_entradas_ntp_no_etcrc_conf>29.11.1.2. Entradas NTP no <span class=filename>/etc/rc.conf</span><a class=anchor href=#_entradas_ntp_no_etcrc_conf></a></h5><div class=paragraph><p>Defina <code>ntpd_enable=YES</code> para iniciar o ntpd no momento do boot do sistema. Depois que o <code>ntpd_enable=YES</code> for adicionado ao <span class=filename>/etc/rc.conf</span>, o ntpd poderá ser iniciado imediatamente sem reiniciar o sistema, digitando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service ntpd start</span></code></pre></div></div><div class=paragraph><p>Somente <code>ntpd_enable</code> deve ser configurado para usar o ntpd. As variáveis <span class=filename>rc.conf</span> listadas abaixo também podem ser definidas conforme necessário.</p></div><div class=paragraph><p>Defina <code>ntpd_sync_on_start=YES</code> para permitir que o ntpd adiante o relógio, uma vez na inicialização. Normalmente, o ntpd registra uma mensagem de erro e se finaliza se o relógio estiver dessincronizado por mais de 1000 segundos. Essa opção é especialmente útil em sistemas sem um relógio em tempo real com bateria.</p></div><div class=paragraph><p>Defina <code>ntpd_oomprotect=YES</code> para proteger o serviço ntpd de ser finalizado pelo sistema quando ele tentar se recuperar de uma condição de Falta de Nemória (OOM).</p></div><div class=paragraph><p>Defina <code>ntpd_config=</code> para o local de um arquivo <span class=filename>ntp.conf</span> alternativo.</p></div><div class=paragraph><p>Defina <code>ntpd_flags=</code> para conter outras flags ntpd conforme necessário, mas evite usar as flags gerenciadas internamente pelo <span class=filename>/etc/rc.d/ntpd</span>:</p></div><div class=ulist><ul><li><p><code>-p</code> (local do arquivo pid)</p></li><li><p><code>-c</code> (configure <code>ntpd_config=</code> como alternativa)</p></li></ul></div></div><div class=sect4><h5 id=_o_ntpd_e_o_usuário_não_privilegiado_ntpd>29.11.1.3. O Ntpd e o usuário não privilegiado <code>ntpd</code><a class=anchor href=#_o_ntpd_e_o_usuário_não_privilegiado_ntpd></a></h5><div class=paragraph><p>O Ntpd no FreeBSD pode ser iniciado e executado como um usuário não privilegiado. Para isso, é necessário o módulo de política <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_ntpd&amp;sektion=4&amp;format=html">mac_ntpd(4)</a>. O script de inicialização <span class=filename>/etc/rc.d/ntpd</span> examina primeiro a configuração do NTP. Se possível, ele carrega o módulo <code>mac_ntpd</code> e inicia o ntpd como um usuário não vinculado <code>ntpd</code> (user id 123). Para evitar problemas com o acesso a arquivos e diretórios, o script de inicialização não iniciará automaticamente o ntpd como <code>ntpd</code> quando a configuração contiver quaisquer opções relacionadas a arquivos.</p></div><div class=paragraph><p>A presença de qualquer um dos itens a seguir em <code>ntpd_flags</code> requer configuração manual, conforme descrito abaixo, para ser executada como o usuário <code>ntpd</code> user:</p></div><div class=ulist><ul><li><p>-f or --driftfile</p></li><li><p>-i or --jaildir</p></li><li><p>-k or --keyfile</p></li><li><p>-l or --logfile</p></li><li><p>-s or --statsdir</p></li></ul></div><div class=paragraph><p>A presença de qualquer uma das seguintes palavras-chave no <span class=filename>ntp.conf</span> requer configuração manual, conforme descrito abaixo, para ser executado como usuário <code>ntpd</code>:</p></div><div class=ulist><ul><li><p>crypto</p></li><li><p>driftfile</p></li><li><p>key</p></li><li><p>logdir</p></li><li><p>statsdir</p></li></ul></div><div class=paragraph><p>Para configurar manualmente o ntpd para ser executado como usuário <code>ntpd</code>, você deve:</p></div><div class=ulist><ul><li><p>Certifique-se de que o usuário <code>ntpd</code> tenha acesso a todos os arquivos e diretórios especificados na configuração.</p></li><li><p>Se certifique para que o módulo <code>mac_ntpd</code> seja carregado ou compilado no kernel. Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_ntpd&amp;sektion=4&amp;format=html">mac_ntpd(4)</a> para obter detalhes.</p></li><li><p>Defina <code>ntpd_user="ntpd"</code> no <span class=filename>/etc/rc.conf</span></p></li></ul></div></div></div><div class=sect3><h4 id=_usando_ntp_com_uma_conexão_ppp>29.11.2. Usando NTP com uma Conexão PPP<a class=anchor href=#_usando_ntp_com_uma_conexão_ppp></a></h4><div class=paragraph><p>O ntpd não precisa de uma conexão permanente com a Internet para funcionar corretamente. No entanto, se uma conexão PPP estiver configurada para discar sob demanda, o tráfego de NTP deverá ser impedido de disparar uma discagem ou manter a conexão ativa. Isso pode ser configurado com as diretivas <code>filter</code> em <span class=filename>/etc/ppp/ppp.conf</span>. Por exemplo:</p></div><div class="literalblock programlisting"><div class=content><pre>set filter dial 0 deny udp src eq 123
# Prevent NTP traffic from initiating dial out
set filter dial 1 permit 0 0
set filter alive 0 deny udp src eq 123
# Prevent incoming NTP traffic from keeping the connection open
set filter alive 1 deny udp dst eq 123
# Prevent outgoing NTP traffic from keeping the connection open
set filter alive 2 permit 0/0 0/0</pre></div></div><div class=paragraph><p>Para mais detalhes, consulte a seção <code>PACKET FILTERING</code> em <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> e os exemplos em <span class=filename>/usr/shared/examples/ppp/</span>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Alguns provedores de acesso à Internet bloqueiam portas de números baixos, impedindo o funcionamento do NTP, pois as respostas nunca chegam à máquina.</p></div></td></tr></tbody></table></div></div></div><div class=sect2><h3 id=network-iscsi>29.12. Inicializador iSCSI e Configuração Alvo<a class=anchor href=#network-iscsi></a></h3><div class=paragraph><p>iSCSI é uma maneira de compartilhar o armazenamento em uma rede. Ao contrário do NFS, que funciona no nível do sistema de arquivos, o iSCSI funciona no nível do dispositivo de bloco.</p></div><div class=paragraph><p>Na terminologia iSCSI, o sistema que compartilha o armazenamento é conhecido como <em>alvo</em>. O armazenamento pode ser um disco físico ou uma área representando vários discos ou uma parte de um disco físico. Por exemplo, se os discos estiverem formatados com ZFS, um zvol poderá ser criado para ser usado como armazenamento iSCSI.</p></div><div class=paragraph><p>Os clientes que acessam o armazenamento do iSCSI são chamados de <em>iniciadores</em>. Para os iniciadores, o armazenamento disponível por meio do iSCSI aparece como um disco bruto, não formatado, conhecido como LUN. Nós de dispositivo para o disco aparecem em <span class=filename>/dev/</span> e o dispositivo deve ser formatado e montado separadamente.</p></div><div class=paragraph><p>O FreeBSD fornece um alvo e iniciador nativo, baseado em kernel iSCSI. Esta seção descreve como configurar um sistema FreeBSD como um alvo ou um iniciador.</p></div><div class=sect3><h4 id=network-iscsi-target>29.12.1. Configurando um Alvo iSCSI<a class=anchor href=#network-iscsi-target></a></h4><div class=paragraph><p>Para configurar um alvo iSCSI, crie o arquivo de configuração <span class=filename>/etc/ctl.conf</span>, adicione uma linha ao arquivo <span class=filename>/etc/rc.conf</span> para certificar-se de que o daemon <a href="https://man.freebsd.org/cgi/man.cgi?query=ctld&amp;sektion=8&amp;format=html">ctld(8)</a> seja iniciado automaticamente na inicialização e, em seguida, inicie-o.</p></div><div class=paragraph><p>A seguir, um exemplo de um arquivo de configuração simples <span class=filename>/etc/ctl.conf</span>. Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=ctl.conf&amp;sektion=5&amp;format=html">ctl.conf(5)</a> para obter uma descrição mais completa das opções disponíveis deste arquivo.</p></div><div class="literalblock programlisting"><div class=content><pre>portal-group pg0 {
	discovery-auth-group no-authentication
	listen 0.0.0.0
	listen [::]
}

target iqn.2012-06.com.example:target0 {
	auth-group no-authentication
	portal-group pg0

	lun 0 {
		path /data/target0-0
		size 4G
	}
}</pre></div></div><div class=paragraph><p>A primeira entrada define o grupo de portais <code>pg0</code>. Grupos de portal definem quais endereços de rede o daemon <a href="https://man.freebsd.org/cgi/man.cgi?query=ctld&amp;sektion=8&amp;format=html">ctld(8)</a> irá escutar. A entrada <code>discovery-auth-group no-authentication</code> indica que qualquer iniciador tem permissão para executar descoberta de alvo iSCSI sem autenticação. As linhas três e quatro configuram <a href="https://man.freebsd.org/cgi/man.cgi?query=ctld&amp;sektion=8&amp;format=html">ctld(8)</a> para escutar em todos os endereços IPv4 (<code>listen 0.0.0.0</code>) e IPv6 (<code>listen [::]</code>) na porta padrão 3260.</p></div><div class=paragraph><p>Não é necessário definir um grupo de portais, pois há um grupo de portais interno chamado <code>default</code>. Nesse caso, a diferença entre <code>default</code> e <code>pg0</code> é que com <code>default</code>, a descoberta de alvo é sempre negada, enquanto com <code>pg0</code>, é sempre permitido.</p></div><div class=paragraph><p>A segunda entrada define um único alvo. O alvo tem dois significados possíveis: uma máquina que atende iSCSI ou um grupo nomeado de LUNs. Este exemplo usa o último significado, onde <code>iqn.2012-06.com.example:target0</code> é o nome do alvo. Este nome de alvo é adequado para fins de teste. Para uso real, altere <code>com.example</code> para o nome de domínio real, invertido. O <code>2012-06</code> representa o ano e o mês de aquisição do controle desse nome de domínio, e <code>target0</code> pode ser qualquer valor. Qualquer número de alvos pode ser definido neste arquivo de configuração.</p></div><div class=paragraph><p>A linha <code>auth-group no-authentication</code> permite que todos os iniciadores se conectem ao alvo especificado e <code>portal-group pg0</code> torna o alvo acessível através do grupo do portal <code>pg0</code>.</p></div><div class=paragraph><p>A próxima seção define o LUN. Para o iniciador, cada LUN será visível como um dispositivo de disco separado. Múltiplos LUNs podem ser definidos para cada destino. Cada LUN é identificado por um número, onde LUN 0 é obrigatório. A linha <code>path/data/target0-0</code> define o caminho completo para um arquivo ou zvol que suporta o LUN. Esse caminho deve existir antes de iniciar <a href="https://man.freebsd.org/cgi/man.cgi?query=ctld&amp;sektion=8&amp;format=html">ctld(8)</a>. A segunda linha é opcional e especifica o tamanho do LUN.</p></div><div class=paragraph><p>Em seguida, para ter certeza que o daemon <a href="https://man.freebsd.org/cgi/man.cgi?query=ctld&amp;sektion=8&amp;format=html">ctld(8)</a> foi iniciado no boot, adicione esta linha ao arquivo <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>ctld_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Para iniciar o <a href="https://man.freebsd.org/cgi/man.cgi?query=ctld&amp;sektion=8&amp;format=html">ctld(8)</a> agora, execute este comando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service ctld start</span></code></pre></div></div><div class=paragraph><p>Quando o daemon <a href="https://man.freebsd.org/cgi/man.cgi?query=ctld&amp;sektion=8&amp;format=html">ctld(8)</a> é iniciado, ele lê o arquivo <span class=filename>/etc/ctl.conf</span>. Se este arquivo for editado depois que o daemon iniciar, use este comando para que as mudanças entrem em vigor imediatamente:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service ctld reload</span></code></pre></div></div><div class=sect4><h5 id=_autenticação>29.12.1.1. Autenticação<a class=anchor href=#_autenticação></a></h5><div class=paragraph><p>O exemplo anterior é inerentemente inseguro, pois não usa autenticação, concedendo a qualquer um acesso total a todos os alvos. Para exigir um nome de usuário e senha para acessar os alvos, modifique a configuração da seguinte maneira:</p></div><div class="literalblock programlisting"><div class=content><pre>auth-group ag0 {
	chap username1 secretsecret
	chap username2 anothersecret
}

portal-group pg0 {
	discovery-auth-group no-authentication
	listen 0.0.0.0
	listen [::]
}

target iqn.2012-06.com.example:target0 {
	auth-group ag0
	portal-group pg0
	lun 0 {
		path /data/target0-0
		size 4G
	}
}</pre></div></div><div class=paragraph><p>A seção <code>auth-group</code> define os pares de nome de usuário e senha. Um inicializador tentando se conectar a <code>iqn.2012-06.com.example:target0</code> deve primeiro especificar um nome de usuário e senha definidos. No entanto, a descoberta do alvo ainda é permitida sem autenticação. Para exigir autenticação de descoberta de alvo, defina <code>discovery-auth-group</code> como um nome <code>auth-group</code> definido em vez de <code>no-authentication</code>.</p></div><div class=paragraph><p>É comum definir um único alvo exportado para cada inicializador. Como um atalho para a sintaxe acima, o nome de usuário e a senha podem ser especificados diretamente na entrada do alvo:</p></div><div class="literalblock programlisting"><div class=content><pre>target iqn.2012-06.com.example:target0 {
	portal-group pg0
	chap username1 secretsecret

	lun 0 {
		path /data/target0-0
		size 4G
	}
}</pre></div></div></div></div><div class=sect3><h4 id=network-iscsi-initiator>29.12.2. Configurando um Inicializador iSCSI<a class=anchor href=#network-iscsi-initiator></a></h4><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>O inicializador iSCSI descrito nesta seção é suportado a partir do FreeBSD 10.0-RELEASE. Para usar o inicializador iSCSI disponível em versões mais antigas, consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=iscontrol&amp;sektion=8&amp;format=html">iscontrol(8)</a>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>O inicializador iSCSI requer que o daemon <a href="https://man.freebsd.org/cgi/man.cgi?query=iscsid&amp;sektion=8&amp;format=html">iscsid(8)</a> esteja em execução. Este daemon não usa um arquivo de configuração. Para iniciá-lo automaticamente na inicialização, adicione esta linha ao arquivo <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>iscsid_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Para iniciar <a href="https://man.freebsd.org/cgi/man.cgi?query=iscsid&amp;sektion=8&amp;format=html">iscsid(8)</a> agora, execute este comando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service iscsid start</span></code></pre></div></div><div class=paragraph><p>Conectar-se a um alvo pode ser feito com ou sem um arquivo <span class=filename>/etc/iscsi.conf</span> de configuração. Esta seção demonstra os dois tipos de conexões.</p></div><div class=sect4><h5 id=_conectando_se_a_um_alvo_sem_um_arquivo_de_configuração>29.12.2.1. Conectando-se a um Alvo sem um Arquivo de Configuração<a class=anchor href=#_conectando_se_a_um_alvo_sem_um_arquivo_de_configuração></a></h5><div class=paragraph><p>Para conectar um inicializador a um único alvo, especifique o endereço IP do portal e o nome do alvo:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># iscsictl -A -p 10.10.10.10 -t iqn.2012-06.com.example:target0</span></code></pre></div></div><div class=paragraph><p>Para verificar se a conexão foi bem sucedida, execute <code>iscsictl</code> sem nenhum argumento. A saída deve ser semelhante a esta:</p></div><div class="literalblock programlisting"><div class=content><pre>Target name                                     Target portal   State
iqn.2012-06.com.example:target0                 10.10.10.10     Connected: da0</pre></div></div><div class=paragraph><p>Neste exemplo, a sessão iSCSI foi estabelecida com sucesso, com <span class=filename>/dev/da0</span> representando o LUN anexado. Se o destino <code>iqn.2012-06.com.example:target0</code> exportar mais de um LUN, vários nós de dispositivos serão mostrados nessa seção da saída:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Connected: da0 da1 da2.</code></pre></div></div><div class=paragraph><p>Quaisquer erros serão relatados na saída, assim como os logs do sistema. Por exemplo, esta mensagem normalmente significa que o daemon <a href="https://man.freebsd.org/cgi/man.cgi?query=iscsid&amp;sektion=8&amp;format=html">iscsid(8)</a> não está em execução:</p></div><div class="literalblock programlisting"><div class=content><pre>Target name                                     Target portal   State
iqn.2012-06.com.example:target0                 10.10.10.10     Waiting for iscsid(8)</pre></div></div><div class=paragraph><p>A mensagem a seguir sugere um problema de rede, como uma porta ou endereço IP incorreto:</p></div><div class="literalblock programlisting"><div class=content><pre>Target name                                     Target portal   State
iqn.2012-06.com.example:target0                 10.10.10.11     Connection refused</pre></div></div><div class=paragraph><p>Esta mensagem significa que o nome do alvo especificado está errado:</p></div><div class="literalblock programlisting"><div class=content><pre>Target name                                     Target portal   State
iqn.2012-06.com.example:target0                 10.10.10.10     Not found</pre></div></div><div class=paragraph><p>Esta mensagem significa que o alvo requer autenticação:</p></div><div class="literalblock programlisting"><div class=content><pre>Target name                                     Target portal   State
iqn.2012-06.com.example:target0                 10.10.10.10     Authentication failed</pre></div></div><div class=paragraph><p>Para especificar um nome de usuário e uma senha de CHAP, use esta sintaxe:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># iscsictl -A -p 10.10.10.10 -t iqn.2012-06.com.example:target0 -u user -s secretsecret</span></code></pre></div></div></div><div class=sect4><h5 id=_conectando_se_a_um_alvo_com_um_arquivo_de_configuração>29.12.2.2. Conectando-se a um Alvo com um Arquivo de Configuração<a class=anchor href=#_conectando_se_a_um_alvo_com_um_arquivo_de_configuração></a></h5><div class=paragraph><p>Para se conectar usando um arquivo de configuração, crie o <span class=filename>/etc/iscsi.conf</span> com o seguinte conteúdo:</p></div><div class="literalblock programlisting"><div class=content><pre>t0 {
	TargetAddress   = 10.10.10.10
	TargetName      = iqn.2012-06.com.example:target0
	AuthMethod      = CHAP
	chapIName       = user
	chapSecret      = secretsecret
}</pre></div></div><div class=paragraph><p>O <code>t0</code> especifica um nickname para a seção do arquivo de configuração. Ele será usado pelo iniciador para especificar qual configuração usar. As outras linhas especificam os parâmetros a serem usados durante a conexão. O <code>TargetAddress</code> e <code>TargetName</code> são obrigatórios, enquanto as outras opções são opcionais. Neste exemplo, o nome de usuário e a senha do CHAP são mostrados.</p></div><div class=paragraph><p>Para se conectar ao alvo definido, especifique o apelido:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># iscsictl -An t0</span></code></pre></div></div><div class=paragraph><p>Como alternativa, para conectar-se a todos os alvos definidos no arquivo de configuração, use:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># iscsictl -Aa</span></code></pre></div></div><div class=paragraph><p>Para fazer com que o inicializador se conecte automaticamente a todos os alvos no arquivo <span class=filename>/etc/iscsi.conf</span>, adicione o seguinte ao arquivo <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>iscsictl_enable=&#34;YES&#34;
iscsictl_flags=&#34;-Aa&#34;</pre></div></div></div></div></div></div></div><div class=sect1><h2 id=firewalls>Capítulo 30. Firewalls<a class=anchor href=#firewalls></a></h2><div class=sectionbody><div class=sect2><h3 id=firewalls-intro>30.1. Sinopse<a class=anchor href=#firewalls-intro></a></h3><div class=paragraph><p>Os firewalls permitem filtrar o tráfego de entrada e saída que flui através de um sistema. Um firewall pode usar um ou mais conjuntos de "regras" para inspecionar os pacotes de rede à medida que eles entram ou saem das conexões de rede e assim permitir ou bloquear o tráfego. As regras de um firewall podem inspecionar uma ou mais características dos pacotes, como o tipo de protocolo, o endereço do host de origem ou de destino e a porta de origem ou de destino.</p></div><div class=paragraph><p>Os firewalls podem melhorar a segurança de um host ou de uma rede. Eles podem ser usados para fazer um ou mais dos seguintes procedimentos:</p></div><div class=ulist><ul><li><p>Proteger e isolar as aplicações, serviços e máquinas de uma rede interna contra tráfego indesejado da Internet pública.</p></li><li><p>Limitar ou desabilitar o acesso de hosts da rede interna para serviços da Internet pública.</p></li><li><p>Suportar a tradução de endereços de rede (NAT), que possibilita que uma rede interna use endereços IP privados e compartilhe uma única conexão com a Internet pública usando um único endereço IP ou um pool compartilhado de endereços públicos atribuídos automaticamente.</p></li></ul></div><div class=paragraph><p>O FreeBSD possui três firewalls embutidos no sistema base: PF, IPFW e IPFILTER, também conhecido como IPF. O FreeBSD também fornece dois traffic shapers para controlar o uso da largura de banda: <a href="https://man.freebsd.org/cgi/man.cgi?query=altq&amp;sektion=4&amp;format=html">altq(4)</a> e <a href="https://man.freebsd.org/cgi/man.cgi?query=dummynet&amp;sektion=4&amp;format=html">dummynet(4)</a>. O ALTQ tem sido tradicionalmente vinculado ao PF e o dummynet ao IPFW. Cada firewall usa regras para controlar o acesso de pacotes provenientes e com destino a um sistema FreeBSD, embora eles façam isso de maneiras diferentes e cada um com uma sintaxe de regra diferente.</p></div><div class=paragraph><p>O FreeBSD fornece vários firewalls para atender aos diferentes requisitos e preferências para uma ampla variedade de usuários. Cada usuário deve avaliar qual firewall atende melhor às suas necessidades.</p></div><div class=paragraph><p>Depois de ler este capítulo, você saberá:</p></div><div class=ulist><ul><li><p>Como definir regras de filtragem de pacotes.</p></li><li><p>As diferenças entre os firewalls embutidos no FreeBSD.</p></li><li><p>Como usar e configurar o firewall PF.</p></li><li><p>Como usar e configurar o firewall IPFW.</p></li><li><p>Como usar e configurar o firewall IPFILTER.</p></li></ul></div><div class=paragraph><p>Antes de ler este capítulo, você deve:</p></div><div class=ulist><ul><li><p>Entender os conceitos básicos do FreeBSD e de Internet.</p></li></ul></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Como todos os firewalls são baseados em inspecionar os valores dos campos de controle de pacotes selecionados, o criador do conjunto de regras do firewall deve ter uma compreensão de como funciona o TCP/IP, quais são os diferentes valores nos campos de controle de pacotes e como esses valores são usados em uma conversa de sessão normal. Para uma boa introdução, consulte <a href=http://www.ipprimer.com>Daryl’s TCP/IP Primer</a>.</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=firewalls-concepts>30.2. Conceitos de Firewall<a class=anchor href=#firewalls-concepts></a></h3><div class=paragraph><p>Um conjunto de regras contém um grupo de regras que liberam ou bloqueiam pacotes com base nos valores contidos no pacote. A troca bidirecional de pacotes entre hosts compreende uma conversa de sessão. O conjunto de regras do firewall processa os pacotes que chegam da Internet pública, bem como os pacotes produzidos pelo sistema como uma resposta aos que chegaram. Cada serviço TCP/IP é pré-definido pelo seu protocolo e porta de escuta. Os pacotes destinados a um serviço específico são originados do endereço de origem usando uma porta não privilegiada e têm como destino a porta do serviço específica no endereço de destino. Todos os parâmetros acima podem ser usados como critérios de seleção para criar regras que irão liberar ou bloquear serviços.</p></div><div class=paragraph><p>Para procurar números de porta desconhecidos, consulte o arquivo <span class=filename>/etc/services</span>. Alternativamente, visite <a href=http://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers>http://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers</a> e faça uma pesquisa de número de porta para encontrar a finalidade de um determinado número de porta.</p></div><div class=paragraph><p>Confira este link para ver os <a href=http://web.archive.org/web/20150803024617/http://www.sans.org/security-resources/idfaq/oddports.php>números de porta usados por Trojans</a>.</p></div><div class=paragraph><p>O FTP possui dois modos: modo ativo e modo passivo. A diferença está em como o canal de dados é adquirido. O modo passivo é mais seguro, pois o canal de dados é adquirido pelo solicitante de sessão ftp. Para obter uma boa explicação sobre o FTP e seus diferentes modos, consulte <a href=http://www.slacksite.com/other/ftp.html>http://www.slacksite.com/other/ftp.html</a>.</p></div><div class=paragraph><p>Um conjunto de regras de firewall pode ser "exclusivo" ou "inclusivo". Um firewall exclusivo libera todo o tráfego, exceto o tráfego correspondente ao conjunto de regras. Um firewall inclusivo faz o inverso, liberando o tráfego que corresponde as regras e bloqueia todo o resto.</p></div><div class=paragraph><p>Um firewall inclusivo oferece melhor controle do tráfego de saída, tornando-o uma melhor escolha para sistemas que oferecem serviços à Internet pública. Também controla o tipo de tráfego originado da Internet pública que pode obter acesso a uma rede privada. Todo o tráfego que não corresponde às regras é bloqueado e registrado. Os firewalls inclusivos são geralmente mais seguros do que os firewalls exclusivos, pois reduzem significativamente o risco de permitir tráfego indesejado.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Salvo indicação contrária, todos os conjuntos de regras de configuração e exemplo neste capítulo criam conjuntos de regras de firewall inclusivos.</p></div></td></tr></tbody></table></div><div class=paragraph><p>A segurança pode ser reforçada usando um "firewall stateful". Esse tipo de firewall registra e acompanha as conexões abertas e libera apenas o tráfego que corresponde a uma conexão existente ou libera e abre uma nova conexão.</p></div><div class=paragraph><p>A filtragem stateful trata o tráfego como uma troca bidirecional de pacotes compondo uma sessão. Quando um estado é especificado em uma regra de correspondência, o firewall gera dinamicamente regras internas para cada pacote antecipado sendo trocado durante a sessão. Ele possui recursos de correspondência suficientes para determinar se um pacote é válido para uma sessão. Quaisquer pacotes que não se encaixem corretamente no modelo de sessão serão automaticamente rejeitados.</p></div><div class=paragraph><p>Quando a sessão é concluída, ela é removida da tabela de estados dinâmicos.</p></div><div class=paragraph><p>A filtragem stateful permite dar foco no bloqueio/liberação de novas sessões. Se a nova sessão for passada, todos os seus pacotes subsequentes serão permitidos automaticamente e todos os pacotes de um impostor serão automaticamente rejeitados. Se uma nova sessão for bloqueada, nenhum dos seus pacotes subsequentes serão permitidos. A filtragem stateful fornece habilidades de correspondência avançadas capazes de se defender contra o flood de diferentes métodos de ataque empregados pelos invasores.</p></div><div class=paragraph><p>NAT significa <em>Tradução de Endereços de Rede</em>. A função NAT permite que a LAN privada por trás do firewall compartilhe um único endereço IP atribuído pelo ISP, mesmo que esse endereço seja atribuído dinamicamente. O NAT permite que cada computador na LAN tenha acesso à Internet, sem ter que pagar ao ISP por várias contas de Internet ou endereços IP.</p></div><div class=paragraph><p>O NAT traduzirá automaticamente o endereço IP da LAN privada de cada sistema na LAN para o único endereço IP público, à medida que os pacotes saem do firewall vinculado à Internet pública. Também executa a conversão inversa para devolver os pacotes.</p></div><div class=paragraph><p>De acordo com a RFC 1918, os seguintes intervalos de endereços IP são reservados para redes privadas que nunca serão roteadas diretamente para a Internet pública e, portanto, estão disponíveis para uso com o NAT:</p></div><div class=ulist><ul><li><p><code>10.0.0.0/8</code>.</p></li><li><p><code>172.16.0.0/12</code>.</p></li><li><p><code>192.168.0.0/16</code>.</p></li></ul></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Ao trabalhar com regras de firewall, seja <em>muito cuidadoso</em>. Algumas configurações <em>podem bloquear o administrador</em> do servidor. Para estar seguro, considere executar a configuração inicial do firewall a partir do console local, em vez de fazê-lo remotamente por ssh.</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=firewalls-pf>30.3. PF<a class=anchor href=#firewalls-pf></a></h3><div class=paragraph><p>Desde o FreeBSD 5.3, uma versão portada do firewall PF do OpenBSD foi incluída como uma parte integrada do sistema base. O PF é um firewall completo, cheio de recursos que possui suporte opcional para ALTQ (Alternate Queuing), que fornece Qualidade de Serviço (QoS).</p></div><div class=paragraph><p>O Projeto OpenBSD mantém a referência definitiva para PF no <a href=http://www.openbsd.org/faq/pf/>FAQ do PF</a>. Peter Hansteen mantém um tutorial completo do PF em <a href=http://home.nuug.no/~peter/pf/>http://home.nuug.no/~peter/pf/</a>.</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Ao ler o <a href=http://www.openbsd.org/faq/pf/>FAQ do PF</a>, tenha em mente que a versão do PF do FreeBSD divergiu substancialmente da versão inicial do OpenBSD ao longo dos anos. Nem todos os recursos funcionam da mesma maneira no FreeBSD como no OpenBSD e vice-versa.</p></div></td></tr></tbody></table></div><div class=paragraph><p>A <a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-pf>lista de emails do packet filter do FreeBSD</a> é um bom lugar para perguntar questões relacionadas a configuração e execução do firewall PF. Verifique os arquivos da lista de email antes de perguntar alguma questão, pois ela já pode ter sido respondida.</p></div><div class=paragraph><p>Esta seção do Handbook foca no PF no que se refere ao FreeBSD. Ele demonstra como ativar o PF e ALTQ. Em seguida, ele fornece vários exemplos para criar conjuntos de regras em um sistema FreeBSD.</p></div><div class=sect3><h4 id=_ativando_o_pf>30.3.1. Ativando o PF<a class=anchor href=#_ativando_o_pf></a></h4><div class=paragraph><p>Para usar o PF, seu módulo do kernel deve ser carregado primeiro. Esta seção descreve as entradas que podem ser adicionadas ao <span class=filename>/etc/rc.conf</span> para habilitar o PF.</p></div><div class=paragraph><p>Comece adicionando a seguinte linha <code>pf_enable=yes</code> ao arquivo <span class=filename>/etc/rc.conf</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysrc pf_enable=yes</span></code></pre></div></div><div class=paragraph><p>Opções adicionais, descritas em <a href="https://man.freebsd.org/cgi/man.cgi?query=pfctl&amp;sektion=8&amp;format=html">pfctl(8)</a>, podem ser passadas para o PF quando ele é iniciado. Adicione esta entrada ao arquivo <span class=filename>/etc/rc.conf</span> e especifique quaisquer flags necessárias entre duas aspas (<code>""</code>):</p></div><div class="literalblock programlisting"><div class=content><pre>pf_flags=&#34;&#34;                     # additional flags for pfctl startup</pre></div></div><div class=paragraph><p>O PF não será iniciado se não puder localizar o arquivo de configuração do conjunto de regras. Por padrão, o FreeBSD não vem com um conjunto de regras e não há um <span class=filename>/etc/pf.conf</span>. Exemplos de regras podem ser encontrados em <span class=filename>/usr/shared/examples/pf/</span>. Se um conjunto de regras personalizado foi salvo em algum outro lugar, adicione uma linha ao arquivo <span class=filename>/etc/rc.conf</span> que especifica o caminho completo para o arquivo:</p></div><div class="literalblock programlisting"><div class=content><pre>pf_rules=&#34;/path/to/pf.conf&#34;</pre></div></div><div class=paragraph><p>O suporte de log para o PF é fornecido pelo <a href="https://man.freebsd.org/cgi/man.cgi?query=pflog&amp;sektion=4&amp;format=html">pflog(4)</a>. Para ativar o suporte aos logs, adicione esta linha ao <span class=filename>/etc/rc.conf</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysrc pflog_enable=yes</span></code></pre></div></div><div class=paragraph><p>As seguintes linhas também podem ser adicionadas para alterar a localização padrão do arquivo de log ou para especificar quaisquer flags adicionais na inicialização do <a href="https://man.freebsd.org/cgi/man.cgi?query=pflog&amp;sektion=4&amp;format=html">pflog(4)</a>:</p></div><div class="literalblock programlisting"><div class=content><pre>pflog_logfile=&#34;/var/log/pflog&#34;  # where pflogd should store the logfile
pflog_flags=&#34;&#34;                  # additional flags for pflogd startup</pre></div></div><div class=paragraph><p>Finalmente, se houver uma LAN atrás do firewall e os pacotes precisarem ser encaminhados para os computadores na LAN, ou se NAT for necessário, adicione a seguinte opção:</p></div><div class="literalblock programlisting"><div class=content><pre>gateway_enable=&#34;YES&#34;            # Enable as LAN gateway</pre></div></div><div class=paragraph><p>Depois de salvar as edições necessárias, o PF pode ser iniciado com o suporte de log, digitando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service pf start</span>
<span class=c># service pflog start</span></code></pre></div></div><div class=paragraph><p>Por padrão, o PF lê suas regras de configuração do arquivo <span class=filename>/etc/pf.conf</span> e modifica, descarta ou libera pacotes de acordo com as regras ou definições especificadas neste arquivo. A instalação do FreeBSD inclui vários arquivos de exemplo localizados em <span class=filename>/usr/shared/examples/pf/</span>. Consulte o <a href=http://www.openbsd.org/faq/pf/>FAQ do PF</a> para obter uma cobertura completa dos conjuntos de regras do PF.</p></div><div class=paragraph><p>Para controlar o PF, use o <code>pfctl</code>. <a href=#pfctl>Opções Úteis do <code>pfctl</code></a> resume algumas opções úteis para este comando. Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=pfctl&amp;sektion=8&amp;format=html">pfctl(8)</a> para obter uma descrição de todas as opções disponíveis:</p></div><table id=pfctl class="tableblock frame-none grid-all stretch"><caption class=title>Tabela 27. Opções Úteis do <code>pfctl</code></caption><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Comando</th><th class="tableblock halign-left valign-top">Propósito</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>pfctl -e</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Ativa o PF.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>pfctl -d</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Desabilita o PF.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>pfctl -F all -f /etc/pf.conf</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Limpa todas as regras de NAT, filtro, estado e tabela e recarrega o <span class=filename>/etc/pf.conf</span>.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>pfctl -s [ rules | nat | states ]</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Informa as regras de filtragem, de NAT ou a tabela de estados.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>pfctl -vnf /etc/pf.conf</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Verifica se tem erros no arquivo <span class=filename>/etc/pf.conf</span>, mas não carrega o conjunto de regras.</p></td></tr></tbody></table><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p><a class=package href=https://cgit.freebsd.org/ports/tree/security/sudo/>security/sudo</a> é útil para executar comandos como <code>pfctl</code> que exigem privilégios elevados. Ele pode ser instalado a partir da Coleção de Ports.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Para ficar de olho no tráfego que passa pelo firewall PF, considere instalar o pacote ou port <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/pftop/>sysutils/pftop</a>. Uma vez instalado, o pftop pode ser executado para exibir um snapshot do estado atual do tráfego em um formato semelhante ao <a href="https://man.freebsd.org/cgi/man.cgi?query=top&amp;sektion=1&amp;format=html">top(1)</a>.</p></div></div><div class=sect3><h4 id=pf-tutorial>30.3.2. Conjuntos de Regras do PF<a class=anchor href=#pf-tutorial></a></h4><div class=paragraph><p>Esta seção demonstra como criar um conjunto de regras personalizado. Ele começa com o mais simples dos conjuntos de regras e baseia-se em seus conceitos usando vários exemplos para demonstrar o uso real dos diversos recursos do PF.</p></div><div class=paragraph><p>O conjunto de regras mais simples possível é para uma única máquina que não executa nenhum serviço e que precisa de acesso a uma rede, que pode ser a Internet. Para criar este conjunto de regras mínimo, edite o arquivo <span class=filename>/etc/pf.conf</span> para que fique assim:</p></div><div class="literalblock programlisting"><div class=content><pre>block in all
pass out all keep state</pre></div></div><div class=paragraph><p>A primeira regra nega todo o tráfego de entrada por padrão. A segunda regra permite que as conexões originadas por este sistema sejam liberadas, mantendo as informações de estado nessas conexões. Essas informações de estado permitem que o tráfego de retorno para essas conexões seja liberado e só deve ser usado em máquinas confiáveis. O conjunto de regras pode ser carregado com:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pfctl -e ; pfctl -f /etc/pf.conf</span></code></pre></div></div><div class=paragraph><p>Além de manter estados, o PF fornece <em>listas</em> e <em>macros</em> que podem ser definidas para uso ao criar regras. As macros podem incluir listas e precisam ser definidas antes de serem usadas. Como exemplo, insira essas linhas no topo do conjunto de regras:</p></div><div class="literalblock programlisting"><div class=content><pre>tcp_services = &#34;{ ssh, smtp, domain, www, pop3, auth, pop3s }&#34;
udp_services = &#34;{ domain }&#34;</pre></div></div><div class=paragraph><p>O PF entende os nomes das portas, assim como os números das portas, desde que os nomes estejam listados em <span class=filename>/etc/services</span>. Este exemplo cria duas macros. A primeira é uma lista de sete nomes de portas TCP e a segunda é um nome de porta UDP. Uma vez definidas, as macros podem ser usadas em regras. Neste exemplo, todo o tráfego é bloqueado, exceto pelas conexões originadas por este sistema para os sete serviços TCP especificados e para o serviço UDP especificado:</p></div><div class="literalblock programlisting"><div class=content><pre>tcp_services = &#34;{ ssh, smtp, domain, www, pop3, auth, pop3s }&#34;
udp_services = &#34;{ domain }&#34;
block all
pass out proto tcp to any port $tcp_services keep state
pass proto udp to any port $udp_services keep state</pre></div></div><div class=paragraph><p>Embora o UDP seja considerado um protocolo sem estado, o PF é capaz de rastrear algumas informações de estado. Por exemplo, quando uma solicitação UDP é liberada perguntando a um servidor de nomes sobre um nome de domínio, o PF irá procurar pela resposta para libera-la.</p></div><div class=paragraph><p>Sempre que uma edição é feita em um conjunto de regras, as novas regras devem ser carregadas para que possam ser usadas:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pfctl -f /etc/pf.conf</span></code></pre></div></div><div class=paragraph><p>Se não houver erros de sintaxe, o <code>pfctl</code> não exibirá nenhuma mensagem durante o carregamento da regra. As regras também podem ser testadas antes de tentar carregá-las:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pfctl -nf /etc/pf.conf</span></code></pre></div></div><div class=paragraph><p>A inclusão de <code>-n</code> faz com que as regras sejam interpretadas apenas, mas não carregadas. Isso fornece uma oportunidade para corrigir quaisquer erros. Em todos os momentos, o último conjunto de regras válido carregado será imposto até que o PF seja desativado ou um novo conjunto de regras seja carregado.</p></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Adicionando <code>-v</code> ao comando <code>pfctl</code> no carregamento ou checagem de conjuntos de regras, será exibido as regras exatamente da maneira como elas serão carregadas. Isso é extremamente útil ao depurar regras.</p></div></td></tr></tbody></table></div><div class=sect4><h5 id=pftut-gateway>30.3.2.1. Um Gateway Simples com NAT<a class=anchor href=#pftut-gateway></a></h5><div class=paragraph><p>Esta seção demonstra como configurar um sistema FreeBSD executando PF para atuar como um gateway para pelo menos uma outra máquina. O gateway precisa de pelo menos duas interfaces de rede, cada uma conectada a uma rede separada. Neste exemplo, <span class=filename>xl1</span> está conectada à Internet e a <span class=filename>xl0</span> está conectada à rede interna.</p></div><div class=paragraph><p>Primeiro, ative o gateway para permitir que a máquina encaminhe o tráfego de rede que recebe em uma interface para outra interface. Esta configuração do sysctl encaminhará pacotes IPv4:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl net.inet.ip.forwarding=1</span></code></pre></div></div><div class=paragraph><p>Para encaminhar tráfego IPv6, use:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl net.inet6.ip6.forwarding=1</span></code></pre></div></div><div class=paragraph><p>Para ativar essas configurações na inicialização do sistema, use o <a href="https://man.freebsd.org/cgi/man.cgi?query=sysrc&amp;sektion=8&amp;format=html">sysrc(8)</a> para adicioná-las ao <span class=filename>/etc/rc.conf</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysrc gateway_enable=yes</span>
<span class=c># sysrc ipv6_gateway_enable=yes</span></code></pre></div></div><div class=paragraph><p>Verifique com o <code>ifconfig</code> se ambas as interfaces estão ativadas e em execução.</p></div><div class=paragraph><p>Em seguida, crie as regras PF para permitir que o gateway transmita tráfego. Embora a regra a seguir permita que o tráfego stateful de hosts da rede interna passe para o gateway, a palavra-chave <code>to</code> não garante a passagem da origem até o destino:</p></div><div class="literalblock programlisting"><div class=content><pre>pass in on xl1 from xl1:network to xl0:network port $ports keep state</pre></div></div><div class=paragraph><p>Essa regra só permite que o tráfego passe para o gateway na interface interna. Para deixar os pacotes irem mais longe, é necessária uma regra de correspondência:</p></div><div class="literalblock programlisting"><div class=content><pre>pass out on xl0 from xl1:network to xl0:network port $ports keep state</pre></div></div><div class=paragraph><p>Embora essas duas regras funcionem, regras especificadas dessa forma raramente são necessárias. Para um administrador de rede ocupado, um conjunto de regras legível é um conjunto de regras mais seguro. O restante desta seção demonstra como manter as regras o mais simples possível para facilitar a leitura. Por exemplo, essas duas regras podem ser substituídas por uma regra:</p></div><div class="literalblock programlisting"><div class=content><pre>pass from xl1:network to any port $ports keep state</pre></div></div><div class=paragraph><p>A notação <code>interface:network</code> pode ser substituída por uma macro para tornar o conjunto de regras ainda mais legível. Por exemplo, uma macro <code>$localnet</code> pode ser definida como a rede diretamente conectada à interface interna (<code>$xl1:network</code>). Alternativamente, a definição de <code>$localnet</code> poderia ser alterada para uma notação <em>IP address/netmask</em> para denotar uma rede, como <code>192.168.100.1/24</code> para uma sub-rede de endereços privados.</p></div><div class=paragraph><p>Se necessário, <code>$localnet</code> pode ser definido como uma lista de redes. Quaisquer que sejam as necessidades específicas, uma definição sensata de <code>$localnet</code> poderia ser usada em uma regra típica de liberação da seguinte maneira:</p></div><div class="literalblock programlisting"><div class=content><pre>pass from $localnet to any port $ports keep state</pre></div></div><div class=paragraph><p>O conjunto de regras de exemplo a seguir libera todo o tráfego originado por máquinas na rede interna. Primeiro define duas macros para representar as interfaces externas e internas 3COM do gateway.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Para usuários dial-up, a interface externa será <span class=filename>tun0</span>. Para uma conexão ADSL, especificamente aquelas que usam PPP over Ethernet (PPPoE), a interface externa correta é <span class=filename>tun0</span>, não a interface física Ethernet.</p></div></td></tr></tbody></table></div><div class="literalblock programlisting"><div class=content><pre>ext_if = &#34;xl0&#34;	# macro for external interface - use tun0 for PPPoE
int_if = &#34;xl1&#34;	# macro for internal interface
localnet = $int_if:network
# ext_if IP address could be dynamic, hence ($ext_if)
nat on $ext_if from $localnet to any -&gt; ($ext_if)
block all
pass from { lo0, $localnet } to any keep state</pre></div></div><div class=paragraph><p>Este conjunto de regras introduz a regra <code>nat</code> que é usada para tratar a tradução de endereços de rede dos endereços não roteáveis dentro da rede interna para o endereço IP atribuído à interface externa. Os parênteses em torno da última parte da regra nat <code>($ext_if)</code> são incluídos quando o endereço IP da interface externa é atribuído dinamicamente. Ele garante que o tráfego de rede seja executado sem interrupções graves, mesmo se o endereço IP externo for alterado.</p></div><div class=paragraph><p>Observe que esse conjunto de regras provavelmente permite que mais tráfego seja transmitido para fora da rede do que o necessário. Uma configuração razoável poderia criar essa macro:</p></div><div class="literalblock programlisting"><div class=content><pre>client_out = &#34;{ ftp-data, ftp, ssh, domain, pop3, auth, nntp, http, \
    https, cvspserver, 2628, 5999, 8000, 8080 }&#34;</pre></div></div><div class=paragraph><p>para usar na regra principal de liberação:</p></div><div class="literalblock programlisting"><div class=content><pre>pass inet proto tcp from $localnet to any port $client_out \
    flags S/SA keep state</pre></div></div><div class=paragraph><p>Algumas outras regras de aprovação podem ser necessárias. Esta permite ativar o SSH na interface externa:</p></div><div class="literalblock programlisting"><div class=content><pre>pass in inet proto tcp to $ext_if port ssh</pre></div></div><div class=paragraph><p>Esta definição de macro e regra permite DNS e NTP para clientes internos:</p></div><div class="literalblock programlisting"><div class=content><pre>udp_services = &#34;{ domain, ntp }&#34;
pass quick inet proto { tcp, udp } to any port $udp_services keep state</pre></div></div><div class=paragraph><p>Observe a palavra-chave <code>quick</code> nesta regra. Como o conjunto de regras consiste em várias regras, é importante entender as relações entre as regras em um conjunto de regras. As regras são avaliadas de cima para baixo, na sequência em que são escritas. Para cada pacote ou conexão avaliado pelo PF, <em>a última regra correspondente</em> no conjunto de regras é aquela que é aplicada. No entanto, quando um pacote corresponde a uma regra que contém a palavra-chave <code>quick</code>, o processamento da regra é interrompido e o pacote é tratado de acordo com essa regra. Isso é muito útil quando é necessária uma exceção às regras gerais.</p></div></div><div class=sect4><h5 id=pftut-ftp>30.3.2.2. Criando um Proxy FTP<a class=anchor href=#pftut-ftp></a></h5><div class=paragraph><p>Configurar regras funcionais de FTP pode ser problemático devido à natureza do protocolo FTP. O FTP pré-data os firewalls por várias décadas e é inseguro em seu design. Os pontos mais comuns contra o uso do FTP incluem:</p></div><div class=ulist><ul><li><p>As senhas são transferidas em texto puro.</p></li><li><p>O protocolo exige o uso de pelo menos duas conexões TCP (controle e dados) em portas separadas.</p></li><li><p>Quando uma sessão é estabelecida, os dados são transmitidos usando portas selecionadas aleatoriamente.</p></li></ul></div><div class=paragraph><p>Todos esses pontos apresentam desafios de segurança, mesmo antes de considerar possíveis pontos fracos de segurança no software cliente ou servidor. Há alternativas mais seguras para a transferência de arquivos, como <a href="https://man.freebsd.org/cgi/man.cgi?query=sftp&amp;sektion=1&amp;format=html">sftp(1)</a> ou <a href="https://man.freebsd.org/cgi/man.cgi?query=scp&amp;sektion=1&amp;format=html">scp(1)</a>, que apresentam autenticação e transferência de dados através de conexões criptografadas.</p></div><div class=paragraph><p>Para as situações em que o FTP é necessário, o PF fornece o redirecionamento do tráfego FTP para um pequeno programa proxy chamado <a href="https://man.freebsd.org/cgi/man.cgi?query=ftp-proxy&amp;sektion=8&amp;format=html">ftp-proxy(8)</a>, que está incluído no sistema base do FreeBSD. O papel do proxy é inserir dinamicamente e excluir regras no conjunto de regras, usando um conjunto de âncoras, para lidar corretamente com o tráfego de FTP.</p></div><div class=paragraph><p>Para habilitar o proxy FTP, adicione esta linha ao <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>ftpproxy_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Em seguida, inicie o proxy executando <code>service ftp-proxy start</code>.</p></div><div class=paragraph><p>Para uma configuração básica, três elementos precisam ser adicionados ao arquivo <span class=filename>/etc/pf.conf</span>. Primeiro, as âncoras que o proxy usará para inserir as regras que ele gera para as sessões de FTP:</p></div><div class="literalblock programlisting"><div class=content><pre>nat-anchor &#34;ftp-proxy/*&#34;
rdr-anchor &#34;ftp-proxy/*&#34;</pre></div></div><div class=paragraph><p>Em segundo, é necessária uma regra de liberação para permitir o tráfego de FTP para o proxy.</p></div><div class=paragraph><p>Terceiro, as regras de redirecionamento e NAT precisam ser definidas antes das regras de filtragem. Insira esta regra <code>rdr</code> imediatamente após a regra <code>nat</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>rdr pass on $int_if proto tcp from any to any port ftp -&gt; 127.0.0.1 port 8021</pre></div></div><div class=paragraph><p>Finalmente, permita que o tráfego redirecionado passe:</p></div><div class="literalblock programlisting"><div class=content><pre>pass out proto tcp from $proxy to any port ftp</pre></div></div><div class=paragraph><p>onde <code>$proxy</code> se expande para o endereço ao qual o daemon proxy está vinculado.</p></div><div class=paragraph><p>Salve o arquivo <span class=filename>/etc/pf.conf</span>, carregue as novas regras e verifique a partir de um cliente se as conexões FTP estão funcionando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pfctl -f /etc/pf.conf</span></code></pre></div></div><div class=paragraph><p>Este exemplo cobre uma configuração básica em que os clientes na rede local precisam entrar em contato com servidores FTP em outro lugar. Essa configuração básica deve funcionar bem com a maioria das combinações de clientes e servidores FTP. Como mostrado em <a href="https://man.freebsd.org/cgi/man.cgi?query=ftp-proxy&amp;sektion=8&amp;format=html">ftp-proxy(8)</a>, o comportamento do proxy pode ser alterado de várias maneiras adicionando opções na linha <code>ftpproxy_flags=</code>. Alguns clientes ou servidores podem ter peculiaridades específicas que devem ser compensadas na configuração ou pode ser necessário integrar o proxy de maneiras específicas, como atribuir tráfego FTP a uma fila específica.</p></div><div class=paragraph><p>Para formas de executar um servidor FTP protegido por PF e <a href="https://man.freebsd.org/cgi/man.cgi?query=ftp-proxy&amp;sektion=8&amp;format=html">ftp-proxy(8)</a>, configure um <code>ftp-proxy</code> separado em modo reverso, usando <code>-R</code>, em uma porta separada com sua própria regra de redirecionamento de passagem.</p></div></div><div class=sect4><h5 id=pftut-icmp>30.3.2.3. Gerenciando ICMP<a class=anchor href=#pftut-icmp></a></h5><div class=paragraph><p>Muitas das ferramentas usadas para depurar ou solucionar problemas de uma rede TCP/IP dependem do Internet Control Message Protocol (ICMP), o qual foi projetado especificamente para depuração.</p></div><div class=paragraph><p>O protocolo ICMP envia e recebe <em>mensagens de controle</em> entre hosts e gateways, principalmente para fornecer feedback a um remetente sobre quaisquer condições incomuns ou difíceis na rota para o host de destino. Os roteadores usam ICMP para negociar tamanhos de pacote e outros parâmetros de transmissão em um processo geralmente chamado de descoberta de <em>path MTU</em>.</p></div><div class=paragraph><p>Do ponto de vista do firewall, algumas mensagens de controle ICMP são vulneráveis a vetores de ataque conhecidos. Além disso, deixar todo o tráfego de diagnóstico passar incondicionalmente torna a depuração mais fácil, mas também torna mais fácil para os outros extraírem informações sobre a rede. Por esses motivos, a regra a seguir pode não ser a ideal:</p></div><div class="literalblock programlisting"><div class=content><pre>pass inet proto icmp from any to any</pre></div></div><div class=paragraph><p>Uma solução é permitir todo o tráfego de ICMP originado na rede local e bloquear as chamadas provenientes de fora da rede:</p></div><div class="literalblock programlisting"><div class=content><pre>pass inet proto icmp from $localnet to any keep state
pass inet proto icmp from any to $ext_if keep state</pre></div></div><div class=paragraph><p>Opções adicionais estão disponíveis, o que demonstra algumas das flexibilidades do PF. Por exemplo, em vez de liberar todas as mensagens ICMP, pode-se especificar as mensagens usadas pelo <a href="https://man.freebsd.org/cgi/man.cgi?query=ping&amp;sektion=8&amp;format=html">ping(8)</a> e <a href="https://man.freebsd.org/cgi/man.cgi?query=traceroute&amp;sektion=8&amp;format=html">traceroute(8)</a>. Comece definindo uma macro para esse tipo de mensagem:</p></div><div class="literalblock programlisting"><div class=content><pre>icmp_types = &#34;echoreq&#34;</pre></div></div><div class=paragraph><p>e uma regra que usa a macro:</p></div><div class="literalblock programlisting"><div class=content><pre>pass inet proto icmp all icmp-type $icmp_types keep state</pre></div></div><div class=paragraph><p>Se outros tipos de pacotes ICMP forem necessários, expanda <code>icmp_types</code> para uma lista desses tipos de pacotes. Digite <code>more /usr/src/sbin/pfctl/pfctl_parser.c</code> para ver a lista de tipos de mensagem ICMP suportados pelo PF. Consulte <a href=http://www.iana.org/assignments/icmp-parameters/icmp-parameters.xhtml>http://www.iana.org/assignments/icmp-parameters/icmp-parameters.xhtml</a> para uma explicação de cada tipo de mensagem.</p></div><div class=paragraph><p>Como o Unix <code>traceroute</code> usa UDP por padrão, outra regra é necessária para permitir o comando <code>traceroute</code> do Unix:</p></div><div class="literalblock programlisting"><div class=content><pre># allow out the default range for traceroute(8):
pass out on $ext_if inet proto udp from any to any port 33433 &gt;&lt; 33626 keep state</pre></div></div><div class=paragraph><p>Como o <code>TRACERT.EXE</code> em sistemas Microsoft Windows usa ICMP echo request messages, somente a primeira regra é necessária para permitir rastreamentos de rede desses sistemas. O Unix <code>traceroute</code> também pode ser instruído a usar outros protocolos e usará ICMP echo request messages se <code>-I</code> for usado. Verifique a página de manual <a href="https://man.freebsd.org/cgi/man.cgi?query=traceroute&amp;sektion=8&amp;format=html">traceroute(8)</a> para detalhes.</p></div><div class=sect5><h6 id=pftut-pathmtudisc>30.3.2.3.1. Descoberta de Path MTU<a class=anchor href=#pftut-pathmtudisc></a></h6><div class=paragraph><p>Os protocolos de Internet são projetados para serem independentes do dispositivo, e uma consequência da independência do dispositivo é que o tamanho ideal do pacote para uma determinada conexão nem sempre pode ser previsto com segurança. A principal restrição no tamanho do pacote é a <em>Maximum Transmission Unit</em> (MTU), que define o limite superior do tamanho do pacote para uma interface. Digite <code>ifconfig</code> para exibir os MTUs para as interfaces de rede do sistema.</p></div><div class=paragraph><p>O TCP/IP usa um processo conhecido como descoberta de path MTU para determinar o tamanho correto do pacote para uma conexão. Este processo envia pacotes de tamanhos variados com o conjunto de flag "Não fragmentar", esperando um pacote de retorno ICMP de "tipo 3, código 4" quando o limite for alcançado. O tipo 3 significa "destino inacessível", e o código 4 é uma abreviação para "fragmentação necessária, mas a flag para não fragmentar está definida". Para permitir que a descoberta de path MTU suporte conexões com outros MTUs, adicione o tipo <code>destination unreachable</code> à macro <code>icmp_types</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>icmp_types = &#34;{ echoreq, unreach }&#34;</pre></div></div><div class=paragraph><p>Como a regra de liberação já usa essa macro, ela não precisa ser modificada para suportar o novo tipo de ICMP:</p></div><div class="literalblock programlisting"><div class=content><pre>pass inet proto icmp all icmp-type $icmp_types keep state</pre></div></div><div class=paragraph><p>O PF permite filtrar todas as variações dos tipos e códigos de ICMP. A lista de tipos e códigos possíveis está documentada em <a href="https://man.freebsd.org/cgi/man.cgi?query=icmp&amp;sektion=4&amp;format=html">icmp(4)</a> and <a href="https://man.freebsd.org/cgi/man.cgi?query=icmp6&amp;sektion=4&amp;format=html">icmp6(4)</a>.</p></div></div></div><div class=sect4><h5 id=pftut-tables>30.3.2.4. Usando Tabelas<a class=anchor href=#pftut-tables></a></h5><div class=paragraph><p>Alguns tipos de dados são relevantes para filtragem e redirecionamento em um determinado momento, mas sua definição é muito longa para ser incluída no arquivo do conjunto de regras. O PF suporta o uso de tabelas, que são listas definidas que podem ser manipuladas sem a necessidade de recarregar todo o conjunto de regras e que podem fornecer pesquisas rápidas. Nomes de tabelas são sempre colocados dentro de <code>&lt; ></code>, assim:</p></div><div class="literalblock programlisting"><div class=content><pre>table &lt;clients&gt; { 192.168.2.0/24, !192.168.2.5 }</pre></div></div><div class=paragraph><p>Neste exemplo, a rede <code>192.168.2.0/24</code> faz parte da tabela, exceto pelo endereço <code>192.168.2.5</code>, que é excluído pelo operador <code>!</code>. Também é possível carregar tabelas de arquivos onde cada entrada está em uma linha separada. como neste exemplo <span class=filename>/etc/clients</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>192.168.2.0/24
!192.168.2.5</pre></div></div><div class=paragraph><p>Para se referir ao arquivo, defina a tabela da seguinte forma:</p></div><div class="literalblock programlisting"><div class=content><pre>table &lt;clients&gt; persist file &#34;/etc/clients&#34;</pre></div></div><div class=paragraph><p>Depois que a tabela é definida, ela pode ser referenciada por uma regra:</p></div><div class="literalblock programlisting"><div class=content><pre>pass inet proto tcp from &lt;clients&gt; to any port $client_out flags S/SA keep state</pre></div></div><div class=paragraph><p>O conteúdo de uma tabela pode ser manipulado ao vivo, usando <code>pfctl</code>. Este exemplo adiciona outra rede a tabela:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pfctl -t clients -T add 192.168.1.0/16</span></code></pre></div></div><div class=paragraph><p>Observe que quaisquer alterações feitas dessa maneira terão efeito imediato, tornando-as ideais para testes, mas não sobreviverão a uma falha de energia ou reinicialização. Para tornar as alterações permanentes, modifique a definição da tabela no conjunto de regras ou edite o arquivo a que a tabela se refere. É possível manter a cópia em disco da tabela usando uma tarefa <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a> que copia o conteúdo da tabela para o disco em intervalos de tempo, usando um comando como <code>pfctl -t clients -T show >/etc/clients</code>. Alternativamente, o <span class=filename>/etc/clients</span> pode ser atualizado com o conteúdo da tabela na memória:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pfctl -t clients -T replace -f /etc/clients</span></code></pre></div></div></div><div class=sect4><h5 id=pftut-overload>30.3.2.5. Usando Tabelas de Sobrecarga para Proteger o SSH<a class=anchor href=#pftut-overload></a></h5><div class=paragraph><p>Aqueles que executam o SSH em uma interface externa provavelmente já viram algo assim nos logs de autenticação:</p></div><div class="literalblock programlisting"><div class=content><pre>Sep 26 03:12:34 skapet sshd[25771]: Failed password for root from 200.72.41.31 port 40992 ssh2
Sep 26 03:12:34 skapet sshd[5279]: Failed password for root from 200.72.41.31 port 40992 ssh2
Sep 26 03:12:35 skapet sshd[5279]: Received disconnect from 200.72.41.31: 11: Bye Bye
Sep 26 03:12:44 skapet sshd[29635]: Invalid user admin from 200.72.41.31
Sep 26 03:12:44 skapet sshd[24703]: input_userauth_request: invalid user admin
Sep 26 03:12:44 skapet sshd[24703]: Failed password for invalid user admin from 200.72.41.31 port 41484 ssh2</pre></div></div><div class=paragraph><p>Isso indica um ataque de força bruta em que alguém ou algum programa está tentando descobrir o nome de usuário e senha que os permitirá entrar no sistema.</p></div><div class=paragraph><p>Se o acesso externo ao SSH for necessário para usuários legítimos, a alteração da porta padrão usada pelo SSH pode oferecer alguma proteção. No entanto, o PF fornece uma solução mais elegante. As regras de liberação podem conter limites sobre o que os hosts de conexão podem fazer e os violadores podem ser banidos para uma tabela de endereços aos quais é negado algum ou todo o acesso. É até possível descartar todas as conexões existentes de máquinas que excedem os limites.</p></div><div class=paragraph><p>Para configurar isso, crie esta tabela na seção de tabelas do conjunto de regras:</p></div><div class="literalblock programlisting"><div class=content><pre>table &lt;bruteforce&gt; persist</pre></div></div><div class=paragraph><p>Então, em algum lugar no início do conjunto de regras, adicione regras para bloquear o acesso bruto, permitindo acesso legítimo:</p></div><div class="literalblock programlisting"><div class=content><pre>block quick from &lt;bruteforce&gt;
pass inet proto tcp from any to $localnet port $tcp_services \
    flags S/SA keep state \
    (max-src-conn 100, max-src-conn-rate 15/5, \
    overload &lt;bruteforce&gt; flush global)</pre></div></div><div class=paragraph><p>A parte entre parênteses define os limites e os valores devem ser alterados para atender aos requisitos locais. Isso pode ser lido da \seguinte forma:</p></div><div class=paragraph><p><code>max-src-conn</code> é o número de conexões simultâneas permitidas de um host.</p></div><div class=paragraph><p><code>max-src-conn-rate</code> é a taxa de novas conexões permitidas de qualquer host único (<em>15</em>) por número de segundos (<em>5</em>).</p></div><div class=paragraph><p><code>overload &lt;bruteforce></code> significa que qualquer host que excede esses limites obtém seu endereço adicionado à tabela <code>bruteforce</code>. O conjunto de regras bloqueia todo o tráfego de endereços na tabela <code>bruteforce</code>.</p></div><div class=paragraph><p>Finalmente, <code>flush global</code> diz que quando um host atinge o limite, todo (<code>global</code>) das conexões desse host será finalizado (<code>flush</code>).</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Estas regras <em>não</em> irão bloquear bruteforcers lentos, como descrito em <a href=http://home.nuug.no/~peter/hailmary2013/>http://home.nuug.no/~peter/hailmary2013/</a>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Este conjunto de regras de exemplo é projetado principalmente como uma ilustração. Por exemplo, se um número grande de conexões em geral é desejado, mas o desejo é ser mais restritivo quando se trata de ssh, complemente a regra acima com algo como o abaixo, no início do conjunto de regras:</p></div><div class="literalblock programlisting"><div class=content><pre>pass quick proto { tcp, udp } from any to any port ssh \
    flags S/SA keep state \
    (max-src-conn 15, max-src-conn-rate 5/3, \
    overload &lt;bruteforce&gt; flush global)</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=title>Pode Não ser Necessário Bloquear Todos os Overloaders</div><div class=paragraph><p>É importante notar que o mecanismo de sobrecarga é uma técnica geral que não se aplica exclusivamente ao SSH, e nem sempre é ideal bloquear totalmente todo o tráfego dos infratores.</p></div><div class=paragraph><p>Por exemplo, uma regra de sobrecarga pode ser usada para proteger um serviço de email ou um serviço Web e a tabela de sobrecarga pode ser usada em uma regra para atribuir infratores a uma fila com uma alocação de largura de banda mínima ou redirecionar para uma página Web específica.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Com o tempo, as tabelas serão preenchidas por regras de sobrecarga e seu tamanho crescerá incrementalmente, ocupando mais memória. Às vezes, um endereço de IP que é bloqueado é atribuído dinamicamente, que já foi atribuído a um host que tem um motivo legítimo para se comunicar com hosts na rede local.</p></div><div class=paragraph><p>Para situações como essas, o pfctl fornece a capacidade de expirar as entradas da tabela. Por exemplo, este comando removerá entradas de tabela <code>&lt;bruteforce></code> que não foram referenciadas por <code>86400</code> segundos:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pfctl -t bruteforce -T expire 86400</span></code></pre></div></div><div class=paragraph><p>Funcionalidade semelhante é fornecida por <a class=package href=https://cgit.freebsd.org/ports/tree/security/expiretable/>security/expiretable</a>, que remove entradas de tabela que não foram acessadas por um período de tempo especificado.</p></div><div class=paragraph><p>Uma vez instalado, o expiretable pode ser executado para remover entradas de tabela <code>&lt;bruteforce></code> mais antigas que uma tempo especifico. Este exemplo remove todas as entradas com mais de 24 horas:</p></div><div class="literalblock programlisting"><div class=content><pre>/usr/local/sbin/expiretable -v -d -t 24h bruteforce</pre></div></div></div><div class=sect4><h5 id=pftut-spamd>30.3.2.6. Protegendo Contra SPAM<a class=anchor href=#pftut-spamd></a></h5><div class=paragraph><p>Não deve ser confundido com o daemon spamd que vem junto com spamassassin, <a class=package href=https://cgit.freebsd.org/ports/tree/mail/spamd/>mail/spamd</a> pode ser configurado com o PF para fornecer uma defesa externa contra SPAM. Esse spamd conecta-se à configuração do PF usando um conjunto de redirecionamentos.</p></div><div class=paragraph><p>Os spammers tendem a enviar um grande número de mensagens, e o SPAM é enviado principalmente de algumas redes amigáveis de spammers e um grande número de máquinas sequestradas, sendo que ambas são reportadas a <em>blacklists</em> bem rápido.</p></div><div class=paragraph><p>Quando uma conexão SMTP de um endereço que está em uma blacklist é recebido, o spamd apresenta seu banner e imediatamente muda para um modo em que ele responde o trágefo SMTP um byte de cada vez. Esta técnica, que pretende desperdiçar tanto tempo quanto possível do spammer, é chamada de <em>tarpitting</em>. A implementação específica que usa respostas de um byte SMTP é muitas vezes referenciada como <em>stuttering</em>.</p></div><div class=paragraph><p>Este exemplo demonstra o procedimento básico para configurar o spamd com blacklists atualizadas automaticamente. Consulte as páginas de manual que são instaladas com o <a class=package href=https://cgit.freebsd.org/ports/tree/mail/spamd/>mail/spamd</a> para mais informações.</p></div><div class="exampleblock procedure"><div class=content><div class=paragraph><p><strong>Procedure: Configurando o spamd</strong></p></div><div class="olist arabic"><ol class=arabic><li><p>Instale o pacote ou port <a class=package href=https://cgit.freebsd.org/ports/tree/mail/spamd/>mail/spamd</a>. Para usar os recursos de greylist do spamd, <a href="https://man.freebsd.org/cgi/man.cgi?query=fdescfs&amp;sektion=5&amp;format=html">fdescfs(5)</a> deve ser montado em <span class=filename>/dev/fd</span>. Adicione a seguinte linha ao arquivo <span class=filename>/etc/fstab</span>:</p><div class="literalblock programlisting"><div class=content><pre> fdescfs /dev/fd fdescfs rw 0 0</pre></div></div><div class=paragraph><p>Em seguida, monte o sistema de arquivos:</p></div><div class="literalblock programlisting"><div class=content><pre># mount fdescfs</pre></div></div></li><li><p>Em seguida, edite o conjunto de regras do PF para incluir:</p><div class="literalblock programlisting"><div class=content><pre>table &lt;spamd&gt; persist
table &lt;spamd-white&gt; persist
rdr pass on $ext_if inet proto tcp from &lt;spamd&gt; to \
    { $ext_if, $localnet } port smtp -&gt; 127.0.0.1 port 8025
rdr pass on $ext_if inet proto tcp from !&lt;spamd-white&gt; to \
    { $ext_if, $localnet } port smtp -&gt; 127.0.0.1 port 8025</pre></div></div><div class=paragraph><p>As duas tabelas <code>&lt;spamd></code> e <code>&lt;spamd-white></code> são essenciais. O trafego SMTP de um endereço listado em <code>&lt;spamd></code> mas não em <code>&lt;spamd-white></code> é redirecionado para o daemon spamd ouvindo a porta 8025.</p></div></li><li><p>O próximo passo é configurar o spamd no arquivo <span class=filename>/usr/local/etc/spamd.conf</span> e adicionar alguns parâmetros no arquivo <span class=filename>rc.conf</span>.</p><div class=paragraph><p>A instalação do <a class=package href=https://cgit.freebsd.org/ports/tree/mail/spamd/>mail/spamd</a> inclui um arquivo de configuração de exemplo (<span class=filename>/usr/local/etc/spamd.conf.sample</span>) e uma página de manual para o <span class=filename>spamd.conf</span>. Refira-se a estes para opções adicionais de configuração além daquelas mostradas neste exemplo.</p></div><div class=paragraph><p>Uma das primeiras linhas no arquivo de configuração que não começa com um sinal de comentário <code>#</code> contém o bloco que define a lista <code>all</code>, que especifica as listas a serem usadas:</p></div><div class="literalblock programlisting"><div class=content><pre>all:\
    :traplist:whitelist:</pre></div></div><div class=paragraph><p>Esta entrada adiciona as blacklists desejadas, separadas por dois pontos (<code>:</code>). Para usar uma whitelist para subtrair endereços de uma blacklist, adicione o nome da whitelist <em>imediatamente</em> após o nome dessa blacklist. Por exemplo: <code>:blacklist:whitelist:</code>.</p></div><div class=paragraph><p>Isto é seguido pela definição da blacklist especificada:</p></div><div class="literalblock programlisting"><div class=content><pre>traplist:\
    :black:\
    :msg=&#34;SPAM. Your address %A has sent spam within the last 24 hours&#34;:\
    :method=http:\
    :file=www.openbsd.org/spamd/traplist.gz</pre></div></div><div class=paragraph><p>onde a primeira linha é o nome da blacklist e a segunda linha especifica o tipo da lista. O campo <code>msg</code> contém a mensagem a ser exibida aos remetentes da blacklist durante a comunicação SMTP. O campo <code>method</code> especifica como o spamd-setup busca os dados da lista; os métodos suportados são <code>http</code>, <code>ftp</code>, de um <code>arquivo</code> em um sistema de arquivos montado e via <code>exec</code> de um programa externo. Finalmente, o campo <code>file</code> especifica o nome do arquivo que o spamd espera receber.</p></div><div class=paragraph><p>A definição da whitelist especificada é semelhante, mas omite o campo <code>msg</code> porque uma mensagem não é necessária:</p></div><div class="literalblock programlisting"><div class=content><pre>whitelist:\
    :white:\
    :method=file:\
    :file=/var/mail/whitelist.txt</pre></div></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=title>Escolha Fontes de Dados com Cuidado</div><div class=paragraph><p>Usar todas as blacklists do arquivo de exemplo <span class=filename>spamd.conf</span> irá colocar na blacklist grandes blocos da Internet. Os administradores precisam editar o arquivo para criar uma configuração ideal que use fontes de dados aplicáveis e, quando necessário, use listas personalizadas.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Em seguida, adicione esta entrada ao arquivo <span class=filename>/etc/rc.conf</span>. Flags adicionais são descritas na página de manual especificada pelo comentário:</p></div><div class="literalblock programlisting"><div class=content><pre>spamd_flags=&#34;-v&#34; # use &#34;&#34; and see spamd-setup(8) for flags</pre></div></div><div class=paragraph><p>Quando terminar, recarregue o conjunto de regras, inicio o spamd digitando <code>service obspamd start</code>, e complete a configuração usando <code>spamd-setup</code>. Finalemente, crie uma tarefa <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a> que chame <code>spamd-setup</code> para atualizar as tabelas razoáveis.</p></div></li></ol></div></div></div><div class=paragraph><p>Em um gateway típico na frente de um servidor de email, os hosts logo começam a ficar presos dentro de segundos ou alguns minutos.</p></div><div class=paragraph><p>PF também suporta <em>greylist</em>, que rejeita temporariamente mensagens de hosts desconhecidos com códigos <em>45n</em>. Conexões de hosts que estão na greylist e que tentam novamente dentro de um tempo razoável de tempo são liberados. O tráfego de remetentes que estão configurados para se comportarem dentro dos limites estabelecidos pela RFC 1123 e pela RFC 2821 é imediatamente permitido.</p></div><div class=paragraph><p>Mais informações sobre técnicas de greylist podem ser encontradas no site <a href=http://www.greylisting.org/>greylisting.org</a>. A coisa mais surpreendente sobre greylist, além de sua simplicidade, é que ainda funciona. Os spammers e os criadores de malware têm sido muito lentos para se adaptar, a fim de contornar essa técnica.</p></div><div class=paragraph><p>O procedimento básico para configurar o greylist é o seguinte:</p></div><div class="exampleblock procedure"><div class=content><div class=paragraph><p><strong>Procedure: Configurando Greylist</strong></p></div><div class="olist arabic"><ol class=arabic><li><p>Certifique-se de que <a href="https://man.freebsd.org/cgi/man.cgi?query=fdescfs&amp;sektion=5&amp;format=html">fdescfs(5)</a> esteja montado conforme descrito na Etapa 1 do Procedimento anterior.</p></li><li><p>Para executar spamd no modo greylist, adicione esta linha ao <span class=filename>/etc/rc.conf</span>:</p><div class="literalblock programlisting"><div class=content><pre>spamd_grey=&#34;YES&#34;  # use spamd greylisting if YES</pre></div></div><div class=paragraph><p>Consulte a página de manual do spamd para obter descrições de parâmetros relacionados adicionais.</p></div></li><li><p>Para concluir a configuração da greylist:</p><div class="literalblock programlisting"><div class=content><pre># service obspamd restart
# service obspamlogd start</pre></div></div></li></ol></div></div></div><div class=paragraph><p>Nos bastidores, a ferramenta de banco de dados spamdb e o atualizador de whitelist spamlogd executam funções essenciais para o recurso de greylist. O spamdb é a interface principal do administrador para gerenciar as greylists, blacklists e whitelists por meio do conteúdo do banco de dados <span class=filename>/var/db/spamdb</span>.</p></div></div><div class=sect4><h5 id=pftut-hygiene>30.3.2.7. Higiene de Rede<a class=anchor href=#pftut-hygiene></a></h5><div class=paragraph><p>Esta seção descreve como o <code>block-policy</code>, <code>scrub</code>, e <code>antispoof</code> pode ser usado para fazer o conjunto de regras se comportar corretamente.</p></div><div class=paragraph><p>O <code>block-policy</code> é uma opção que pode ser definida na parte de <code>opções</code> do conjunto de regras, que precede as regras de redirecionamento e filtragem. Essa opção determina qual feedback, se houver, que o PF envia para hosts que são bloqueados por uma regra. A opção tem dois valores possíveis: <code>drop</code> descarta pacotes bloqueados sem feedback, e <code>return</code> retorna um código de status como <code>Connection refused</code>.</p></div><div class=paragraph><p>Se não definido, a política padrão é <code>drop</code>. Para alterar o <code>block-policy</code>, especifique o valor desejado:</p></div><div class="literalblock programlisting"><div class=content><pre>set block-policy return</pre></div></div><div class=paragraph><p>No PF, <code>scrub</code> é uma palavra-chave que permite a normalização do pacote de rede. Esse processo remonta pacotes fragmentados e descarta pacotes TCP que possuem combinações de sinalizadores inválidos. Ativar <code>scrub</code> fornece uma medida de proteção contra certos tipos de ataques com base no manuseio incorreto de fragmentos de pacotes. Várias opções estão disponíveis, mas a forma mais simples é adequada para a maioria das configurações:</p></div><div class="literalblock programlisting"><div class=content><pre>scrub in all</pre></div></div><div class=paragraph><p>Alguns serviços, como o NFS, exigem opções específicas de manipulação de fragmentos. Consulte <a href=https://home.nuug.no/~peter/pf/en/scrub.html>https://home.nuug.no/~peter/pf/en/scrub.html</a> para mais informações.</p></div><div class=paragraph><p>Este exemplo remonta fragmentos, limpa o bit "não fragmentar" e define o tamanho máximo do segmento para 1440 bytes:</p></div><div class="literalblock programlisting"><div class=content><pre>scrub in all fragment reassemble no-df max-mss 1440</pre></div></div><div class=paragraph><p>O mecanismo <code>antispoof</code> protege contra a atividade de endereços IP falsos ou forjados, principalmente bloqueando pacotes que aparecem em interfaces e em direções que logicamente não são possíveis.</p></div><div class=paragraph><p>Essas regras eliminam tráfego falsificado do resto do mundo, bem como qualquer pacote falsificado originado na rede local:</p></div><div class="literalblock programlisting"><div class=content><pre>antispoof for $ext_if
antispoof for $int_if</pre></div></div></div><div class=sect4><h5 id=pftut-unrouteables>30.3.2.8. Manipulando Endereços Não-Roteados<a class=anchor href=#pftut-unrouteables></a></h5><div class=paragraph><p>Mesmo com um gateway configurado adequadamente para lidar com a tradução de endereços de rede, pode ser necessário compensar as configurações incorretas de outras pessoas. Uma configuração incorreta comum é permitir o tráfego com endereços não roteáveis para a Internet. Como o tráfego de endereços não roteados pode desempenhar um papel em várias técnicas de ataque de DoS, considere bloquear explicitamente o tráfego de endereços não roteáveis de entrar na rede por meio da interface externa.</p></div><div class=paragraph><p>Neste exemplo, uma macro contendo endereços não roteáveis é definida e usada em regras de bloqueio. O tráfego de origem e destino para esses endereços é silenciosamente descartado na interface externa do gateway.</p></div><div class="literalblock programlisting"><div class=content><pre>martians = &#34;{ 127.0.0.0/8, 192.168.0.0/16, 172.16.0.0/12, \
	      10.0.0.0/8, 169.254.0.0/16, 192.0.2.0/24, \
	      0.0.0.0/8, 240.0.0.0/4 }&#34;

block drop in quick on $ext_if from $martians to any
block drop out quick on $ext_if from any to $martians</pre></div></div></div></div><div class=sect3><h4 id=_ativando_o_altq>30.3.3. Ativando o ALTQ<a class=anchor href=#_ativando_o_altq></a></h4><div class=paragraph><p>No FreeBSD, o ALTQ pode ser usado com PF para fornecer Qualidade de Serviço (QOS). Depois que o ALTQ é ativado, as filas podem ser definidas no conjunto de regras que determina a prioridade de processamento dos pacotes de saída.</p></div><div class=paragraph><p>Antes de ativar o ALTQ, consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=altq&amp;sektion=4&amp;format=html">altq(4)</a> para determinar se os drivers das placas de rede instaladas no sistema suportam isto.</p></div><div class=paragraph><p>ALTQ não está disponível como um módulo de kernel carregável. Se as interfaces do sistema suportarem ALTQ, crie um kernel personalizado usando as instruções em <a href=./#kernelconfig>Configurando o kernel do FreeBSD</a>. As seguintes opções do kernel estão disponíveis. O primeira é necessária para ativar o ALTQ. Pelo menos uma das outras opções é necessária para especificar o algoritmo do scheduler de enfileiramento:</p></div><div class="literalblock programlisting"><div class=content><pre>options         ALTQ
options         ALTQ_CBQ        # Class Based Queuing (CBQ)
options         ALTQ_RED        # Random Early Detection (RED)
options         ALTQ_RIO        # RED In/Out
options         ALTQ_HFSC       # Hierarchical Packet Scheduler (HFSC)
options         ALTQ_PRIQ       # Priority Queuing (PRIQ)</pre></div></div><div class=paragraph><p>Os seguintes algoritmos de agendamento estão disponíveis:</p></div><div class=dlist><dl><dt class=hdlist1>CBQ</dt><dd><p>Class Based Queuing (CBQ) é usado para dividir a largura de banda de uma conexão em diferentes classes ou filas para priorizar o tráfego com base nas regras de filtragem.</p></dd><dt class=hdlist1>RED</dt><dd><p>Random Early Detection (RED) é usado para evitar o congestionamento da rede, medindo o comprimento da fila e comparando-a com os limites mínimo e máximo da fila. Quando a fila está acima do máximo, todos os novos pacotes são descartados aleatoriamente.</p></dd><dt class=hdlist1>RIO</dt><dd><p>No modo Random Early Detection In and Out (RIO), RED mantém vários comprimentos médios de fila e vários valores limite, um para cada nível QOS.</p></dd><dt class=hdlist1>HFSC</dt><dd><p>Hierarchical Fair Service Curve Packet Scheduler (HFSC) é descrito em <a href=http://www-2.cs.cmu.edu/~hzhang/HFSC/main.html>http://www-2.cs.cmu.edu/~hzhang/HFSC/main.html</a>.</p></dd><dt class=hdlist1>PRIQ</dt><dd><p>Priority Queuing (PRIQ) sempre passa primeiro o tráfego que está em uma fila mais alta.</p></dd></dl></div><div class=paragraph><p>Maiores informações sobre os algoritmos de agendamento e os conjuntos de regras de exemplo estão disponíveis no <a href=https://web.archive.org/web/20151109213426/http://www.openbsd.org/faq/pf/queueing.html>arquivo web do OpenBSD</a>.</p></div></div></div><div class=sect2><h3 id=firewalls-ipfw>30.4. IPFW<a class=anchor href=#firewalls-ipfw></a></h3><div class=paragraph><p>O IPFW é um firewall stateful para o FreeBSD, que suporta tanto o IPv4 como o IPv6. Ele é composto de vários componentes: o processador de regras de filtro de firewall do kernel e seu recurso integrado de contabilidade de pacotes, o recurso de registro em log, NAT, o <a href="https://man.freebsd.org/cgi/man.cgi?query=dummynet&amp;sektion=4&amp;format=html">dummynet(4)</a> traffic shaper, um recurso de forward, um recurso de bridge e uma habilidade ipstealth.</p></div><div class=paragraph><p>O FreeBSD fornece um conjunto de regras de exemplo em <span class=filename>/etc/rc.firewall</span> que define vários tipos de firewall para cenários comuns para ajudar usuários iniciantes a gerar um conjunto de regras apropriado. O IPFW fornece uma poderosa sintaxe que os usuários avançados podem usar para criar conjuntos de regras personalizados que atendam aos requisitos de segurança de um determinado ambiente.</p></div><div class=paragraph><p>Esta seção descreve como ativar o IPFW, fornece uma visão geral de sua sintaxe de regra e demonstra vários conjuntos de regras para cenários comuns de configuração.</p></div><div class=sect3><h4 id=firewalls-ipfw-enable>30.4.1. Ativando o IPFW<a class=anchor href=#firewalls-ipfw-enable></a></h4><div class=paragraph><p>O IPFW está incluído na instalação base do FreeBSD como um módulo carregável do kernel, o que significa que um kernel customizado não é necessário para ativar o IPFW.</p></div><div class=paragraph><p>Para aqueles usuários que desejam compilar estaticamente o suporte ao IPFW em um kernel personalizado, veja <a href=#firewalls-ipfw-kernelconfig>Opções do Kerne para o IPFW</a>.</p></div><div class=paragraph><p>Para configurar o sistema para ativar o IPFW no momento da inicialização, adicione <code>firewall_enable="YES"</code> ao <span class=filename>/etc/rc.conf</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysrc firewall_enable=&#34;YES&#34;</span></code></pre></div></div><div class=paragraph><p>Para usar um dos tipos de firewall padrão fornecidos pelo FreeBSD, adicione outra linha que especifique o tipo:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysrc firewall_type=&#34;open&#34;</span></code></pre></div></div><div class=paragraph><p>Os tipos disponíveis são:</p></div><div class=ulist><ul><li><p><code>open</code>: passa todo o tráfego.</p></li><li><p><code>client</code>: protege apenas esta máquina.</p></li><li><p><code>simple</code>: protege toda a rede.</p></li><li><p><code>closed</code>: desativa completamente o tráfego IP, exceto na interface de loopback.</p></li><li><p><code>workstation</code>: protege apenas esta máquina usando regras stateful.</p></li><li><p><code>UNKNOWN</code>: desativa o carregamento de regras de firewall.</p></li><li><p><span class=filename>filename</span>: caminho completo do arquivo que contém o conjunto de regras do firewall.</p></li></ul></div><div class=paragraph><p>Se <code>firewall_type</code> estiver definido como <code>client</code> ou <code>simple</code>, modifique as regras padrão encontradas em <span class=filename>/etc/rc.firewall</span> para se adequar a configuração do sistema.</p></div><div class=paragraph><p>Observe que o tipo <code>filename</code> é usado para carregar um conjunto de regras customizado.</p></div><div class=paragraph><p>Uma maneira alternativa de carregar um conjunto de regras personalizado é definir a variável <code>firewall_script</code> para o caminho absoluto de um <em>script executável</em> que inclui comandos IPFW. Os exemplos usados nesta seção assumem que o <code>firewall_script</code> está definido como <span class=filename>/etc/ipfw.rules</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysrc firewall_script=&#34;/etc/ipfw.rules&#34;</span></code></pre></div></div><div class=paragraph><p>Para habilitar o registro em log por meio do <a href="https://man.freebsd.org/cgi/man.cgi?query=syslogd&amp;sektion=8&amp;format=html">syslogd(8)</a>, inclua esta linha:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysrc firewall_logging=&#34;YES&#34;</span></code></pre></div></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Somente regras de firewall com opção de <code>log</code> vão ser registradas. As regras padrão não contém essa opção e deve ser adicionada manualmente. Por isso é avisado que o conjunto de regras padrão é editado para logar. Em adição a isso, rotacionamento de log é desejado se os logs estiverem em um arquivo separado.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Não existe uma variável em <span class=filename>/etc/rc.conf</span> para definir os limites de log. Para limitar o número de vezes que uma regra é registrada por tentativa de conexão, especifique o número usando esta linha no <span class=filename>/etc/sysctl.conf</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># echo &#34;net.inet.ip.fw.verbose_limit=5&#34; &gt;&gt; /etc/sysctl.conf</span></code></pre></div></div><div class=paragraph><p>Para habilitar o registro através de uma interface dedicada chamada <code>ipfw0</code>, adicione esta linha ao <span class=filename>/etc/rc.conf</span> em vez disso:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysrc firewall_logif=&#34;YES&#34;</span></code></pre></div></div><div class=paragraph><p>Em seguida, use o tcpdump para ver o que está sendo registrado:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># tcpdump -t -n -i ipfw0</span></code></pre></div></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Não há sobrecarga devido ao log, a menos que o tcpdump esteja anexado.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Depois de salvar as edições necessárias, inicie o firewall. Para ativar os limites de log agora, defina também o valor <code>sysctl</code> especificado acima:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service ipfw start</span>
<span class=c># sysctl net.inet.ip.fw.verbose_limit=5</span></code></pre></div></div></div><div class=sect3><h4 id=firewalls-ipfw-rules>30.4.2. Sintaxe de Regras IPFW<a class=anchor href=#firewalls-ipfw-rules></a></h4><div class=paragraph><p>Quando um pacote entra no firewall IPFW, ele é comparado com a primeira regra no conjunto de regras e avança uma regra por vez, movendo-se de cima para baixo em sequência. Quando o pacote corresponde aos parâmetros de seleção de uma regra, a ação da regra é executada e a pesquisa do conjunto de regras termina para esse pacote. Isto é conhecido como "primeira combinação vence". Se o pacote não corresponder a nenhuma das regras, ele será pego pela regra padrão obrigatória IPFW de número 65535, que bloqueia todos os pacotes e os descarta silenciosamente. No entanto, se o pacote corresponder a uma regra que contenha as palavras-chave <code>count</code>, <code>skipto</code> ou <code>tee</code>, a pesquisa continuará. Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfw&amp;sektion=8&amp;format=html">ipfw(8)</a> para obter detalhes sobre como essas palavras-chave afetam o processamento de regras.</p></div><div class=paragraph><p>Ao criar uma regra IPFW, as palavras-chave devem ser escritas na seguinte ordem. Algumas palavras-chave são obrigatórias, enquanto outras são opcionais. As palavras mostradas em maiúsculas representam uma variável e as palavras mostradas em minúsculas devem preceder a variável que a segue. O símbolo <code>#</code> é usado para marcar o início de um comentário e pode aparecer no final de uma regra ou em sua própria linha. Linhas em branco são ignoradas.</p></div><div class=paragraph><p><em>CMD RULE_NUMBER set SET_NUMBER ACTION log LOG_AMOUNT PROTO from SRC SRC_PORT to DST DST_PORT OPTIONS</em></p></div><div class=paragraph><p>Esta seção fornece uma visão geral dessas palavras-chave e suas opções. Não é uma lista exaustiva de todas as opções possíveis. Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfw&amp;sektion=8&amp;format=html">ipfw(8)</a> para obter uma descrição completa da sintaxe de regra que pode ser usada ao criar regras IPFW.</p></div><div class=dlist><dl><dt class=hdlist1>CMD</dt><dd><p>Toda regra deve começar com <span class=parameter>ipfw add</span>.</p></dd><dt class=hdlist1>RULE_NUMBER</dt><dd><p>Cada regra é associada a um número de <code>1</code> até <code>65534</code>. O número é usado para indicar a ordem do processamento da regra. Várias regras podem ter o mesmo número e, nesse caso, elas são aplicadas de acordo com a ordem em que foram adicionadas.</p></dd><dt class=hdlist1>SET_NUMBER</dt><dd><p>Cada regra é associada a um número definido de <code>0</code> até <code>31</code>. Os conjuntos podem ser desativados ou ativados individualmente, possibilitando adicionar ou excluir rapidamente um conjunto de regras. Se um SET_NUMBER não for especificado, a regra será adicionada no conjunto <code>0</code>.</p></dd><dt class=hdlist1>ACTION</dt><dd><p>Uma regra pode ser associada a uma das ações a seguir. A ação especificada será executada quando o pacote corresponder ao critério de seleção da regra.</p><div class=paragraph><p><span class=parameter>allow | accept | pass | permit</span>: essas palavras-chave são equivalentes e permitem pacotes que correspondem à regra.</p></div><div class=paragraph><p><span class=parameter>check-state</span>: verifica o pacote em relação à tabela de estados dinâmicos. Se uma correspondência for encontrada, execute a ação associada à regra que gerou essa regra dinâmica, caso contrário, vá para a próxima regra. Uma regra <code>check-state</code> não possui critério de seleção. Se nenhuma regra <code>check-state</code> estiver presente no conjunto de regras, a tabela de regras dinâmicas será verificada na primeira regra <code>keep-state</code> ou <code>limit</code>.</p></div><div class=paragraph><p><span class=parameter>count</span>: atualiza os contadores de todos os pacotes que correspondem à regra. A pesquisa continua com a próxima regra.</p></div><div class=paragraph><p><span class=parameter>deny | drop</span>: qualquer das duas palavras descarta silenciosamente os pacotes que correspondem a essa regra.</p></div><div class=paragraph><p>Ações adicionais estão disponíveis. Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfw&amp;sektion=8&amp;format=html">ipfw(8)</a> para detalhes.</p></div></dd><dt class=hdlist1>LOG_AMOUNT</dt><dd><p>Quando um pacote corresponde a uma regra com a palavra-chave <code>log</code>, uma mensagem será registrada no <a href="https://man.freebsd.org/cgi/man.cgi?query=syslogd&amp;sektion=8&amp;format=html">syslogd(8)</a> com nome <code>SECURITY</code>. O registro somente ocorre se o número de pacotes registrados para essa regra específica não exceder um LOG_AMOUNT especificado. Se nenhum LOG_AMOUNT for especificado, o limite será retirado do valor de <code>net.inet.ip.fw.verbose_limit</code>. Um valor de zero remove o limite de registro. Quando o limite for atingido, o registro em log poderá ser reativado, limpando o contador de registro ou o contador de pacotes para essa regra, usando <code>ipfw resetlog</code>.</p><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>O registro é feito depois que todas as outras condições de correspondência de pacote foram atendidas e antes de executar a ação final no pacote. O administrador decide quais regras habilitar o log.</p></div></td></tr></tbody></table></div></dd><dt class=hdlist1>PROTO</dt><dd><p>Este valor opcional pode ser usado para especificar qualquer nome ou número de protocolo encontrado no arquivo <span class=filename>/etc/protocols</span>.</p></dd><dt class=hdlist1>SRC</dt><dd><p>A palavra-chave <code>from</code> deve ser seguida pelo endereço de origem ou por uma palavra-chave que represente o endereço de origem. Um endereço pode ser representado por <code>any</code>, <code>me</code> (qualquer endereço configurado em uma interface neste sistema), <code>me6</code>, (qualquer endereço IPv6 configurado em uma interface neste sistema), ou <code>table</code> seguido pelo número de uma tabela de consulta que contém uma lista de endereços. Ao especificar um endereço IP, ele pode ser seguido opcionalmente pela máscara ou pela máscara de sub-rede do CIDR. Por exemplo, <code>1.2.3.4/25</code> ou <code>1.2.3.4:255.255.255.128</code>.</p></dd><dt class=hdlist1>SRC_PORT</dt><dd><p>Uma porta de origem opcional pode ser especificada usando o número da porta ou um nome de <span class=filename>/etc/services</span>.</p></dd><dt class=hdlist1>DST</dt><dd><p>A palavra-chave <code>to</code> deve ser seguida pelo endereço de destino ou por uma palavra-chave que represente o endereço de destino. As mesmas palavras-chave e endereços descritos na seção SRC podem ser usados para descrever o destino.</p></dd><dt class=hdlist1>DST_PORT</dt><dd><p>Uma porta de destino opcional pode ser especificada usando o número da porta ou um nome de <span class=filename>/etc/services</span>.</p></dd><dt class=hdlist1>OPTIONS</dt><dd><p>Várias palavras-chave podem seguir a origem e o destino. Como o nome sugere, OPTIONS são opcionais. As opções comumente usadas incluem <code>in</code> ou <code>out</code>, que especificam a direção do fluxo de pacotes, <code>icmptypes</code> seguido pelo tipo de mensagem ICMP e <code>keep-state</code>.</p><div class=paragraph><p>Quando uma regra <span class=parameter>keep-state</span> é correspondida, o firewall criará uma regra dinâmica que corresponda ao tráfego bidirecional entre os endereços e portas de origem e destino usando o mesmo protocolo.</p></div><div class=paragraph><p>O recurso de regras dinâmicas é vulnerável ao esgotamento de recursos de um ataque SYN-flood, o que abriria um grande número de regras dinâmicas. Para combater esse tipo de ataque com IPFW, use <code>limit</code>. Esta opção limita o número de sessões simultâneas verificando as regras dinâmicas abertas, contando o número de vezes que esta regra e a combinação de endereços IP ocorreram. Se essa contagem for maior que o valor especificado por <code>limit</code>, o pacote será descartado.</p></div><div class=paragraph><p>Dezenas de OPTIONS estão disponíveis. Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfw&amp;sektion=8&amp;format=html">ipfw(8)</a> para obter uma descrição de cada opção disponível.</p></div></dd></dl></div></div><div class=sect3><h4 id=_exemplo_de_conjunto_de_regras>30.4.3. Exemplo de Conjunto de Regras<a class=anchor href=#_exemplo_de_conjunto_de_regras></a></h4><div class=paragraph><p>Esta seção demonstra como criar um exemplo de script de conjunto de regras de firewall stateful chamado <span class=filename>/etc/ipfw.rules</span>. Neste exemplo, todas as regras de conexão usam <code>in</code> ou <code>out</code> para esclarecer a direção. Eles também usam <code>via</code> <em>nome-da-interface</em> para especificar a interface que o pacote está percorrendo.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Ao criar ou testar um conjunto de regras de firewall, considere esta configuração temporária:</p></div><div class="literalblock programlisting"><div class=content><pre>net.inet.ip.fw.default_to_accept=&#34;1&#34;</pre></div></div><div class=paragraph><p>Isso define a política padrão do <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfw&amp;sektion=8&amp;format=html">ipfw(8)</a> para ser mais permissiva do que o padrão <code>deny ip from any to any</code>, tornando um pouco mais difícil ficar bloqueado fora do sistema logo após a reinicialização.</p></div></td></tr></tbody></table></div><div class=paragraph><p>O script de firewall começa indicando que é um script Bourne shell e limpa quaisquer regras existentes. Em seguida, ele cria a variável <code>cmd</code> para que <code>ipfw add</code> não precise ser digitado no início de cada regra. Ele também define a variável <code>pif</code> que representa o nome da interface que está conectada à Internet.</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
# Flush out the list before we begin.
ipfw -q -f flush

# Set rules command prefix
cmd=&#34;ipfw -q add&#34;
pif=&#34;dc0&#34;     # interface name of NIC attached to Internet</pre></div></div><div class=paragraph><p>As duas primeiras regras permitem todo o tráfego na interface interna e na interface de loopback:</p></div><div class="literalblock programlisting"><div class=content><pre># Change xl0 to LAN NIC interface name
$cmd 00005 allow all from any to any via xl0

# No restrictions on Loopback Interface
$cmd 00010 allow all from any to any via lo0</pre></div></div><div class=paragraph><p>A próxima regra permite que o pacote passe se corresponder a uma entrada existente na tabela de regras dinâmicas:</p></div><div class="literalblock programlisting"><div class=content><pre>$cmd 00101 check-state</pre></div></div><div class=paragraph><p>O próximo conjunto de regras define quais conexões stateful os sistemas internos podem criar para hosts na Internet:</p></div><div class="literalblock programlisting"><div class=content><pre># Allow access to public DNS
# Replace x.x.x.x with the IP address of a public DNS server
# and repeat for each DNS server in /etc/resolv.conf
$cmd 00110 allow tcp from any to x.x.x.x 53 out via $pif setup keep-state
$cmd 00111 allow udp from any to x.x.x.x 53 out via $pif keep-state

# Allow access to ISP&#39;s DHCP server for cable/DSL configurations.
# Use the first rule and check log for IP address.
# Then, uncomment the second rule, input the IP address, and delete the first rule
$cmd 00120 allow log udp from any to any 67 out via $pif keep-state
#$cmd 00120 allow udp from any to x.x.x.x 67 out via $pif keep-state

# Allow outbound HTTP and HTTPS connections
$cmd 00200 allow tcp from any to any 80 out via $pif setup keep-state
$cmd 00220 allow tcp from any to any 443 out via $pif setup keep-state

# Allow outbound email connections
$cmd 00230 allow tcp from any to any 25 out via $pif setup keep-state
$cmd 00231 allow tcp from any to any 110 out via $pif setup keep-state

# Allow outbound ping
$cmd 00250 allow icmp from any to any out via $pif keep-state

# Allow outbound NTP
$cmd 00260 allow udp from any to any 123 out via $pif keep-state

# Allow outbound SSH
$cmd 00280 allow tcp from any to any 22 out via $pif setup keep-state

# deny and log all other outbound connections
$cmd 00299 deny log all from any to any out via $pif</pre></div></div><div class=paragraph><p>O próximo conjunto de regras controla conexões de hosts da Internet para a rede interna. Ele começa negando pacotes tipicamente associados a ataques e, em seguida, permite explicitamente tipos específicos de conexões. Todos os serviços autorizados originados da Internet usam <code>limit</code> para evitar ataques de flood.</p></div><div class="literalblock programlisting"><div class=content><pre># Deny all inbound traffic from non-routable reserved address spaces
$cmd 00300 deny all from 192.168.0.0/16 to any in via $pif     #RFC 1918 private IP
$cmd 00301 deny all from 172.16.0.0/12 to any in via $pif      #RFC 1918 private IP
$cmd 00302 deny all from 10.0.0.0/8 to any in via $pif         #RFC 1918 private IP
$cmd 00303 deny all from 127.0.0.0/8 to any in via $pif        #loopback
$cmd 00304 deny all from 0.0.0.0/8 to any in via $pif          #loopback
$cmd 00305 deny all from 169.254.0.0/16 to any in via $pif     #DHCP auto-config
$cmd 00306 deny all from 192.0.2.0/24 to any in via $pif       #reserved for docs
$cmd 00307 deny all from 204.152.64.0/23 to any in via $pif    #Sun cluster interconnect
$cmd 00308 deny all from 224.0.0.0/3 to any in via $pif        #Class D &amp; E multicast

# Deny public pings
$cmd 00310 deny icmp from any to any in via $pif

# Deny ident
$cmd 00315 deny tcp from any to any 113 in via $pif

# Deny all Netbios services.
$cmd 00320 deny tcp from any to any 137 in via $pif
$cmd 00321 deny tcp from any to any 138 in via $pif
$cmd 00322 deny tcp from any to any 139 in via $pif
$cmd 00323 deny tcp from any to any 81 in via $pif

# Deny fragments
$cmd 00330 deny all from any to any frag in via $pif

# Deny ACK packets that did not match the dynamic rule table
$cmd 00332 deny tcp from any to any established in via $pif

# Allow traffic from ISP&#39;s DHCP server.
# Replace x.x.x.x with the same IP address used in rule 00120.
#$cmd 00360 allow udp from any to x.x.x.x 67 in via $pif keep-state

# Allow HTTP connections to internal web server
$cmd 00400 allow tcp from any to me 80 in via $pif setup limit src-addr 2

# Allow inbound SSH connections
$cmd 00410 allow tcp from any to me 22 in via $pif setup limit src-addr 2

# Reject and log all other incoming connections
$cmd 00499 deny log all from any to any in via $pif</pre></div></div><div class=paragraph><p>A última regra registra todos os pacotes que não correspondem a nenhuma das regras do conjunto de regras:</p></div><div class="literalblock programlisting"><div class=content><pre># Everything else is denied and logged
$cmd 00999 deny log all from any to any</pre></div></div></div><div class=sect3><h4 id=in-kernel-nat>30.4.4. NAT no Kernel<a class=anchor href=#in-kernel-nat></a></h4><div class=paragraph><p>O firewall IPFW do FreeBSD possui duas implementações de NAT: a implementação do sistema base <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> e a implementação de NAT interno do IPFW. Ambos trabalham em conjunto com o IPFW para fornecer tradução de endereço de rede. Isso pode ser usado para fornecer uma solução de compartilhamento de conexão com a Internet, para que vários computadores internos possam se conectar à Internet usando um único endereço IP público.</p></div><div class=paragraph><p>Para isso, a maquina FreeBSD conectada na internet deve atuar como um gateway. Esse sistema deve ter duas NICs, onde uma é conectada a internet e a outra conectada a LAN interna. Cada maquina conectada com a LAN deve estar associada a um endereço IP no espaço de rede privado, como definido pela <a href=https://www.ietf.org/rfc/rfc1918.txt>RFC 1918</a>.</p></div><div class=paragraph><p>Algumas configuração adicionais são necessárias para ativar a funcionalidade in-kernel NAT do IPFW. Para ativar o suporte ao in-kernel NAT no momento da inicialização do sistema, o seguinte deve ser definido em <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>gateway_enable=&#34;YES&#34;
firewall_enable=&#34;YES&#34;
firewall_nat_enable=&#34;YES&#34;</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Quando <code>firewall_nat_enable</code> estiver definido, mas <code>firewall_enable</code> não estiver, ele não terá efeito e não fará nada. Isso ocorre porque a implementação do in-kernel NAT é compatível apenas com o IPFW.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Quando o conjunto de regras contém regras stateful, o posicionamento da regra NAT é crítico e a ação <code>skipto</code> é usada. A ação <code>skipto</code> requer um número de regra para que ele saiba para qual regra saltar. O exemplo abaixo se baseia no conjunto de regras do firewall mostrado na seção anterior. Ele adiciona algumas entradas adicionais e modifica algumas regras existentes para configurar o firewall com in-kernel NAT. Ele começa adicionando algumas variáveis adicionais que representam o número da regra para pular para, a opção <code>keep-state</code> e uma lista de portas TCP que serão usadas para reduzir o número de regras.</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
ipfw -q -f flush
cmd=&#34;ipfw -q add&#34;
skip=&#34;skipto 1000&#34;
pif=dc0
ks=&#34;keep-state&#34;
good_tcpo=&#34;22,25,37,53,80,443,110&#34;</pre></div></div><div class=paragraph><p>Com o in-kernel NAT é necessário desativar o descarregamento da segmentação TCP (TSO) devido à arquitetura do <a href="https://man.freebsd.org/cgi/man.cgi?query=libalias&amp;sektion=3&amp;format=html">libalias(3)</a>, uma biblioteca implementada como um módulo do kernel para fornecer o in-kernel NAT do IPFW. O TSO pode ser desativado em uma interface de rede usando <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a> ou em todo o sistema usando <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a>. Para desativar o TSO em todo o sistema, deve-se definir o seguinte em <span class=filename>/etc/sysctl.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>net.inet.tcp.tso=&#34;0&#34;</pre></div></div><div class=paragraph><p>Uma instância NAT também será configurada. É possível ter várias instâncias de NAT, cada uma com sua própria configuração. Para este exemplo, apenas uma instância NAT é necessária; Instância NAT número 1. A configuração pode receber algumas opções, como: <code>if</code>, que indica a interface pública, <code>same_ports</code>, que cuida para que as portas mapeadas e o números das portas locais sejam mapeados da mesma maneira, <code>unreg_only</code> resultará em apenas espaços de endereço não registrados (privados) a serem processados pela instância NAT e <code>reset</code>, que ajudará a manter uma instância NAT em funcionamento, mesmo quando o endereço de IP público da máquina IPFW for alterado. Para todas as opções possíveis que podem ser passadas para uma única configuração de instância NAT, consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfw&amp;sektion=8&amp;format=html">ipfw(8)</a>. Ao configurar um firewall NAT stateful, é necessário permitir que pacotes traduzidos sejam reinjetados no firewall para processamento subsequente. Isso pode ser obtido desativando o comportamento <code>one_pass</code> no início do script do firewall.</p></div><div class="literalblock programlisting"><div class=content><pre>ipfw disable one_pass
ipfw -q nat 1 config if $pif same_ports unreg_only reset</pre></div></div><div class=paragraph><p>A regra NAT de entrada é inserida <em>após</em> as duas regras que permitem todo o tráfego nas interfaces interna e de loopback e após a regra de remontagem, mas <em>antes</em> da regra <code>check-state</code> . É importante que o número da regra selecionada para esta regra NAT, neste exemplo <code>100</code>, seja maior que as três primeiras regras e menor que a regra <code>check-state</code>. Além disso, devido ao comportamento do in-kernel NAT, é recomendável colocar uma regra de remontagem pouco antes da primeira regra NAT e depois das regras que permitem tráfego nas interfaces. Normalmente, a fragmentação IP não deve ocorrer, mas ao lidar com o tráfego de tunelamento com IPSEC/ESP/GRE, isso pode ocorrer e a recomposição de fragmentos é necessária antes de entregar o pacote completo para o mecanismo de in-kernel NAT.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>A regra de remontagem não era necessária com o <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> do sistema base porque o recurso interno de <code>divert</code> no IPFW já cuida disso, remontando os pacotes antes da entrega no socket, também informado em <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfw&amp;sektion=8&amp;format=html">ipfw(8)</a>.</p></div><div class=paragraph><p>A instância NAT e o número da regra usados neste exemplo não coincidem com a instância NAT e o número da regra padrão criados por <span class=filename>rc.firewall</span>. <span class=filename>rc.firewall</span> é um script que configura as regras de firewall padrão presentes no FreeBSD.</p></div></td></tr></tbody></table></div><div class="literalblock programlisting"><div class=content><pre>$cmd 005 allow all from any to any via xl0  # exclude LAN traffic
$cmd 010 allow all from any to any via lo0  # exclude loopback traffic
$cmd 099 reass all from any to any in       # reassemble inbound packets
$cmd 100 nat 1 ip from any to any in via $pif # NAT any inbound packets
# Allow the packet through if it has an existing entry in the dynamic rules table
$cmd 101 check-state</pre></div></div><div class=paragraph><p>As regras de saída são modificadas para substituir a ação <code>allow</code> com a variável <code>$skip</code>, indicando que o processamento da regra continuará na regra <code>1000</code>. As sete regras <code>tcp</code> foram substituídas pela regra <code>125</code> porque a variável <code>$good_tcpo</code> contém as sete portas de saída permitidas.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Lembre-se de que o desempenho do IPFW é amplamente determinado pelo número de regras presentes no conjunto de regras.</p></div></td></tr></tbody></table></div><div class="literalblock programlisting"><div class=content><pre># Authorized outbound packets
$cmd 120 $skip udp from any to x.x.x.x 53 out via $pif $ks
$cmd 121 $skip udp from any to x.x.x.x 67 out via $pif $ks
$cmd 125 $skip tcp from any to any $good_tcpo out via $pif setup $ks
$cmd 130 $skip icmp from any to any out via $pif $ks</pre></div></div><div class=paragraph><p>As regras de entrada permanecem as mesmas, exceto a ultima regra que remove <code>via $pif</code> com intenção de casar com ambas regras de entrada e saida. A regra de NAT deve seguir essa ultima regra de saida, deve ter um numero maior que a ultima regra, e o numero da regra deve referenciar a ação <code>skipto</code>. Nesse conjunto de regras, o numero de regra <code>1000</code> lida com a passagem de todos os pacotes para nossa instância configurada para processamento NAT. A próxima regra permite que qualquer pacote submetido ao processamento NAT seja liberado.</p></div><div class="literalblock programlisting"><div class=content><pre>$cmd 999 deny log all from any to any
$cmd 1000 nat 1 ip from any to any out via $pif # skipto location for outbound stateful rules
$cmd 1001 allow ip from any to any</pre></div></div><div class=paragraph><p>Neste exemplo, as regras <code>100</code>, <code>101</code>, <code>125</code>, <code>1000</code> e <code>1001</code> controlam a tradução de endereços dos pacotes de saída e de entrada para que as entradas na tabela de estado dinâmico sempre registrem o endereço de IP privado da LAN .</p></div><div class=paragraph><p>Considere um navegador Web interno que inicialize uma nova sessão HTTP pela porta 80. Quando o primeiro pacote de saída entra no firewall, ele não corresponde à regra <code>100</code> porque ele está saindo e não entrando. Ele pula a regra <code>101</code> porque este é o primeiro pacote e ainda não foi inserido na tabela de estados dinâmicos. O pacote finalmente corresponde à regra <code>125</code> pois é uma conexão de saída em uma porta permitida e tem um endereço IP de origem da LAN interna. Ao combinar essa regra, duas ações ocorrem. Primeiro, a ação <code>keep-state</code> adiciona uma entrada à tabela de estados dinâmicos e a ação especificada, <code>skipto rule 1000</code>, é executada. Em seguida, o pacote passa pelo NAT e é enviado para a Internet. Este pacote faz o seu caminho para o servidor web de destino, onde um pacote de resposta é gerado e enviado de volta. Este novo pacote entra no topo do conjunto de regras. Ele corresponde à regra <code>100</code> e tem seu endereço de destino IP mapeado de volta para o endereço interno original. Em seguida, ele é processado pela regra <code>check-state</code>, é encontrado na tabela como uma sessão existente e é liberado para a LAN.</p></div><div class=paragraph><p>No lado da entrada, o conjunto de regras deve negar pacotes inválidos e permitir apenas serviços autorizados. Um pacote que corresponde a uma regra de entrada é postado na tabela de estados dinâmicos e o pacote é liberado para a LAN. O pacote gerado como resposta é reconhecido pela regra <code>check-state</code> como pertencente a uma sessão existente. Em seguida, ele é enviado para a regra <code>1000</code> para passar pelo NAT antes de ser liberado para a interface de saída.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>A transição do <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> do sistema base para o in-kernel NAT pode parecer fácil no início, mas há algumas particularidades. Ao usar o kernel GENERIC, o IPFW carregará o módulo <span class=filename>libalias.ko</span> do kernel, quando o <code>firewall_nat_enable</code> estiver ativado no <span class=filename>rc.conf</span>. O módulo do kernel <span class=filename>libalias.ko</span> fornece apenas a funcionalidade básica de NAT, enquanto a implementação do <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> do sistema base possui todas as funcionalidades de NAT disponível na userland sem nenhuma configuração extra. Toda funcionalidade refere-se aos seguintes módulos do kernel que podem ser carregados adicionalmente quando necessário, além do módulo do kernel padrão <span class=filename>libalias.ko</span>: <span class=filename>alias_cuseeme.ko</span>, <span class=filename>alias_ftp.ko</span>, <span class=filename>alias_bbt.ko</span>, <span class=filename>skinny.ko</span>, <span class=filename>irc.ko</span>, <span class=filename>alias_pptp.ko</span> and <span class=filename>alias_smedia.ko</span> usando a diretiva <code>kld_list</code> em <span class=filename>rc.conf</span>. Se um kernel personalizado for usado, a funcionalidade completa do sistema base poderá ser compilada no kernel, usando a opção <code>options LIBALIAS</code>.</p></div></td></tr></tbody></table></div><div class=sect4><h5 id=_redirecionamento_de_portas>30.4.4.1. Redirecionamento de Portas<a class=anchor href=#_redirecionamento_de_portas></a></h5><div class=paragraph><p>A desvantagem com NAT em geral é que os clientes da LAN não estão acessíveis na Internet. Os clientes na LAN podem fazer conexões de saída para o mundo, mas não podem receber conexões diretas. Isso é um problema ao tentar executar serviços de Internet em uma das máquinas clientes da LAN. Uma forma simples de contornar isso é redirecionar as portas selecionadas da Internet na máquina NAT para um cliente da LAN.</p></div><div class=paragraph><p>Por exemplo, um servidor IRC é executado no cliente <code>A</code> e um servidor Web é executado no cliente <code>B</code>. Para que isso funcione corretamente, as conexões recebidas nas portas 6667 (IRC) e 80 (HTTP) devem ser redirecionadas para as respectivas máquinas.</p></div><div class=paragraph><p>Com o in-kernel NAT, toda a configuração é feita na configuração da instância NAT. Para obter uma lista completa de opções que uma instância in-kernel NAT pode usar, consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfw&amp;sektion=8&amp;format=html">ipfw(8)</a>. A sintaxe IPFW segue a sintaxe do natd. A sintaxe para <code>redirect_port</code> é a seguinte:</p></div><div class="literalblock programlisting"><div class=content><pre>redirect_port proto targetIP:targetPORT[-targetPORT]
  [aliasIP:]aliasPORT[-aliasPORT]
  [remoteIP[:remotePORT[-remotePORT]]]</pre></div></div><div class=paragraph><p>Para configurar o exemplo de instalação acima, os argumentos devem ser:</p></div><div class="literalblock programlisting"><div class=content><pre>redirect_port tcp 192.168.0.2:6667 6667
redirect_port tcp 192.168.0.3:80 80</pre></div></div><div class=paragraph><p>Depois de adicionar esses argumentos à configuração da instância 1 de NAT no conjunto de regras acima, as portas TCP serão encaminhadas para as máquinas clientes da LAN que rodam os serviços IRC e HTTP.</p></div><div class="literalblock programlisting"><div class=content><pre>ipfw -q nat 1 config if $pif same_ports unreg_only reset \
  redirect_port tcp 192.168.0.2:6667 6667 \
  redirect_port tcp 192.168.0.3:80 80</pre></div></div><div class=paragraph><p>Intervalos de portas podem ser indicados com <code>redirect_port</code>. Por exemplo, <em>tcp 192.168.0.2:2000-3000 2000-3000</em> redirecionaria todas as conexões recebidas entre as portas 2000 e 3000 para as portas 2000 a 3000 no cliente <code>A</code>.</p></div></div><div class=sect4><h5 id=_redirecionamento_de_endereços>30.4.4.2. Redirecionamento de Endereços<a class=anchor href=#_redirecionamento_de_endereços></a></h5><div class=paragraph><p>Redirecionamento de endereços é útil se mais de um endereço IP estiver disponível. Cada cliente da LAN pode receber seu próprio endereço IP externo pelo <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfw&amp;sektion=8&amp;format=html">ipfw(8)</a>, que reescreverá os pacotes de saída dos clientes da LAN com o endereço IP externo apropriado e redirecionará todo o tráfego recebido naquele endereço IP específico de volta para o cliente da LAN específico. Isso também é conhecido como NAT estático. Por exemplo, se o endereço IP <code>128.1.1.1</code>, <code>128.1.1.2</code>, e <code>128.1.1.3</code> estiverem disponíveis, <code>128.1.1.1</code> pode ser usado pelo <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfw&amp;sektion=8&amp;format=html">ipfw(8)</a> como o endereço IP de saída externa, enquanto <code>128.1.1.2</code> e <code>128.1.1.3</code> são encaminhados de volta para os clientes da LAN <code>A</code> e <code>B</code>.</p></div><div class=paragraph><p>A sintaxe <code>redirect_address</code> é a seguinte, onde <code>localIP</code> é o endereço IP interno do cliente da LAN e <code>publicIP</code> é o endereço IP externo que corresponde ao cliente da LAN .</p></div><div class="literalblock programlisting"><div class=content><pre>redirect_address localIP publicIP</pre></div></div><div class=paragraph><p>No exemplo, os argumentos seriam:</p></div><div class="literalblock programlisting"><div class=content><pre>redirect_address 192.168.0.2 128.1.1.2
redirect_address 192.168.0.3 128.1.1.3</pre></div></div><div class=paragraph><p>Como o <code>redirect_port</code>, esses argumentos são inseridos na configuração da instância NAT. Com o redirecionamento de endereço, não há necessidade de redirecionamento de porta, pois todos os dados recebidos em um determinado endereço IP são redirecionados.</p></div><div class=paragraph><p>Os endereços IP externos na máquina <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfw&amp;sektion=8&amp;format=html">ipfw(8)</a> devem estar ativos e com alias na interface externa. Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a> para mais informações.</p></div></div><div class=sect4><h5 id=_nat_do_espaço_do_usuário>30.4.4.3. NAT do espaço do usuário<a class=anchor href=#_nat_do_espaço_do_usuário></a></h5><div class=paragraph><p>Vamos começar com uma declaração: a implementação de NAT do sistema base: <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a>, tem mais sobrecarga do que no in-kernel NAT. Para que o <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> traduza pacotes, os pacotes precisam ser copiados do kernel para o espaço do usuário e vice-versa, o que gera uma sobrecarga extra que não está presente com o in-kernel NAT.</p></div><div class=paragraph><p>Para ativar o daemon de NAT do sistema base , <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a>, no momento da inicialização do sistema, é necessário a seguinte configuração mínima em <span class=filename>/etc/rc.conf</span>. Onde <code>natd_interface</code> é definido com o nome da interface NIC conectada à Internet. O script <a href="https://man.freebsd.org/cgi/man.cgi?query=rc&amp;sektion=8&amp;format=html">rc(8)</a> do <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> verifica automaticamente se um endereço IP dinâmico é usado e configura-se para lidar com isso.</p></div><div class="literalblock programlisting"><div class=content><pre>gateway_enable=&#34;YES&#34;
natd_enable=&#34;YES&#34;
natd_interface=&#34;rl0&#34;</pre></div></div><div class=paragraph><p>Em geral, o conjunto de regras acima, conforme explicado para o in-kernel NAT, também pode ser usado junto com <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a>. As exceções são a configuração da instância in-kernel NAT <code>(ipfw -q nat 1 config …​)</code> que não é necessária junto com a regra de remontagem 99 porque sua funcionalidade é incluída na ação <code>divert</code>. As regras número 100 e 1000 terão que mudar ligeiramente, como mostrado abaixo.</p></div><div class="literalblock programlisting"><div class=content><pre>$cmd 100 divert natd ip from any to any in via $pif
$cmd 1000 divert natd ip from any to any out via $pif</pre></div></div><div class=paragraph><p>Para configurar o redirecionamento de porta ou endereço, é usada uma sintaxe semelhante à do in-kernel NAT. Embora agora, em vez de especificar a configuração em nosso script de conjunto de regras, como no in-kernel NAT, a configuração do <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> é melhor realizada em um arquivo de configuração. Para fazer isso, uma flag extra deve ser passado através do <span class=filename>/etc/rc.conf</span>, que especifica o caminho do arquivo de configuração.</p></div><div class="literalblock programlisting"><div class=content><pre>natd_flags=&#34;-f /etc/natd.conf&#34;</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>O arquivo especificado deve conter uma lista de opções de configuração, uma por linha. Para obter mais informações sobre esse arquivo de configuração e possíveis variáveis, consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a>. Abaixo estão dois exemplos de valores, um por linha:</p></div><div class="literalblock programlisting"><div class=content><pre>redirect_port tcp 192.168.0.2:6667 6667
redirect_address 192.168.0.3 128.1.1.3</pre></div></div></td></tr></tbody></table></div></div></div><div class=sect3><h4 id=firewalls-ipfw-cmd>30.4.5. O Comando IPFW<a class=anchor href=#firewalls-ipfw-cmd></a></h4><div class=paragraph><p>O <code>ipfw</code> pode ser usado para adicionar ou excluir regras únicas e manuais ao firewall ativo enquanto ele estiver em execução. O problema com o uso desse método é que todas as alterações são perdidas quando o sistema é reinicializado. Recomenda-se, em vez disso, gravar todas as regras em um arquivo e usar esse arquivo para carregar as regras no momento da inicialização e substituir as regras de firewall em execução no momento em que o arquivo for alterado.</p></div><div class=paragraph><p>O <code>ipfw</code> é uma maneira útil para se exibir as regras de firewall em execução na tela do console. O recurso de contabilidade IPFW cria dinamicamente um contador para cada regra que case com cada pacote que corresponde à regra. Durante o processo de teste de uma regra, listar a regra com seu contador é uma maneira de determinar se a regra está funcionando conforme o esperado.</p></div><div class=paragraph><p>Para listar todas as regras em execução em sequência:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ipfw list</span></code></pre></div></div><div class=paragraph><p>Para listar todas as regras em execução com um registro de data e hora de quando a última vez em que a regra foi utilizada:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ipfw -t list</span></code></pre></div></div><div class=paragraph><p>O próximo exemplo lista as informações contábeis e a contagem de pacotes das regras correspondentes, junto com as próprias regras. A primeira coluna é o número da regra, seguido pelo número de pacotes e bytes correspondidos, seguidos pela própria regra.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ipfw -a list</span></code></pre></div></div><div class=paragraph><p>Para listar regras dinâmicas além das regras estáticas:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ipfw -d list</span></code></pre></div></div><div class=paragraph><p>Para mostrar também as regras dinâmicas expiradas:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ipfw -d -e list</span></code></pre></div></div><div class=paragraph><p>Para zerar os contadores:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ipfw zero</span></code></pre></div></div><div class=paragraph><p>Para zerar os contadores apenas para a regra com o número <em>NUM</em>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ipfw zero NUM</span></code></pre></div></div><div class=sect4><h5 id=_mensagens_de_log_do_firewall>30.4.5.1. Mensagens de Log do Firewall<a class=anchor href=#_mensagens_de_log_do_firewall></a></h5><div class=paragraph><p>Mesmo com o recurso de geração de log ativado, o IPFW não irá gerar nenhum log de regras por conta própria. O administrador do firewall decide quais regras no conjunto de regras serão logadas e adiciona a palavra-chave <code>log</code> a essas regras. Normalmente, apenas as regras de bloqueio são logadas. É costume duplicar a regra "ipfw default deny everything" com a palavra-chave <code>log</code> incluída como a última regra no conjunto de regras. Dessa forma, é possível ver todos os pacotes que não correspondem a nenhuma das regras do conjunto de regras.</p></div><div class=paragraph><p>O log é uma espada de dois gumes. Se não houver cuidado, uma abundância de dados de log ou um ataque DoS pode encher o disco com arquivos de log. As mensagens de log não são gravadas apenas no syslogd, mas também são exibidas na tela do console do root e logo se tornam irritantes.</p></div><div class=paragraph><p>A opção do kernel <code>IPFIREWALL_VERBOSE_LIMIT=5</code> limita o número de mensagens consecutivas enviadas para o <a href="https://man.freebsd.org/cgi/man.cgi?query=syslogd&amp;sektion=8&amp;format=html">syslogd(8)</a>, referente à correspondência de pacotes de uma regra dada. Quando esta opção está ativada no kernel, o número de mensagens consecutivas relativas a uma regra específica é limitado ao número especificado. Não há nada a ganhar com 200 mensagens de log idênticas. Com essa opção definida como cinco, cinco mensagens consecutivas referentes a uma regra específica seriam registradas no syslogd e as mensagens consecutivas idênticas restantes seriam contadas e postadas no syslogd com uma frase assim:</p></div><div class="literalblock programlisting"><div class=content><pre>last message repeated 45 times</pre></div></div><div class=paragraph><p>Todas os pacotes logados são escritos por padrão no arquivo <span class=filename>/var/log/security</span>, que é definido no <span class=filename>/etc/syslog.conf</span>.</p></div></div><div class=sect4><h5 id=firewalls-ipfw-rules-script>30.4.5.2. Criando um Script de Regras<a class=anchor href=#firewalls-ipfw-rules-script></a></h5><div class=paragraph><p>Os usuários mais experientes do IPFW criam um arquivo contendo as regras e as codificam de maneira compatível com sua execução como um script. A principal vantagem de fazer isso é que as regras de firewall podem ser atualizadas em massa sem a necessidade de reinicializar o sistema para ativá-las. Este método é conveniente para testar novas regras, pois o procedimento pode ser executado quantas vezes forem necessárias. Sendo um script, a substituição simbólica pode ser usada para valores usados frequentemente para serem substituídos em várias regras.</p></div><div class=paragraph><p>Este script de exemplo tem a sintaxe compatível com shells <a href="https://man.freebsd.org/cgi/man.cgi?query=sh&amp;sektion=1&amp;format=html">sh(1)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=csh&amp;sektion=1&amp;format=html">csh(1)</a>, e <a href="https://man.freebsd.org/cgi/man.cgi?query=tcsh&amp;sektion=1&amp;format=html">tcsh(1)</a>. Campos de substituição simbólicos são prefixados com um sinal de dólar ($). Campos simbólicos não possuem o prefixo $. O valor para preencher o campo simbólico deve ser colocado entre aspas duplas ("").</p></div><div class=paragraph><p>Inicie o arquivo de regras assim:</p></div><div class="literalblock programlisting"><div class=content><pre>############### start of example ipfw rules script #############
#
ipfw -q -f flush       # Delete all rules
# Set defaults
oif=&#34;tun0&#34;             # out interface
odns=&#34;192.0.2.11&#34;      # ISP&#39;s DNS server IP address
cmd=&#34;ipfw -q add &#34;     # build rule prefix
ks=&#34;keep-state&#34;        # just too lazy to key this each time
$cmd 00500 check-state
$cmd 00502 deny all from any to any frag
$cmd 00501 deny tcp from any to any established
$cmd 00600 allow tcp from any to any 80 out via $oif setup $ks
$cmd 00610 allow tcp from any to $odns 53 out via $oif setup $ks
$cmd 00611 allow udp from any to $odns 53 out via $oif $ks
################### End of example ipfw rules script ############</pre></div></div><div class=paragraph><p>As regras não são importantes, pois o foco deste exemplo é como os campos de substituição simbólica são preenchidos.</p></div><div class=paragraph><p>Se o exemplo acima estiver no arquivo <span class=filename>/etc/ipfw.rules</span>, as regras podem ser recarregadas pelo seguinte comando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sh /etc/ipfw.rules</span></code></pre></div></div><div class=paragraph><p><span class=filename>/etc/ipfw.rules</span> pode estar localizado em qualquer lugar e o arquivo pode ter qualquer nome.</p></div><div class=paragraph><p>A mesma coisa pode ser realizada executando esses comandos manualmente:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ipfw -q -f flush</span>
<span class=c># ipfw -q add check-state</span>
<span class=c># ipfw -q add deny all from any to any frag</span>
<span class=c># ipfw -q add deny tcp from any to any established</span>
<span class=c># ipfw -q add allow tcp from any to any 80 out via tun0 setup keep-state</span>
<span class=c># ipfw -q add allow tcp from any to 192.0.2.11 53 out via tun0 setup keep-state</span>
<span class=c># ipfw -q add 00611 allow udp from any to 192.0.2.11 53 out via tun0 keep-state</span></code></pre></div></div></div></div><div class=sect3><h4 id=firewalls-ipfw-kernelconfig>30.4.6. Opções do Kerne para o IPFW<a class=anchor href=#firewalls-ipfw-kernelconfig></a></h4><div class=paragraph><p>Para compilar estaticamente o suporte ao IPFW em um kernel personalizado, consulte as instruções em <a href=./#kernelconfig>Configurando o kernel do FreeBSD</a>. As seguintes opções estão disponíveis para o arquivo de configuração do kernel personalizado:</p></div><div class="literalblock programlisting"><div class=content><pre>options    IPFIREWALL			# enables IPFW
options    IPFIREWALL_VERBOSE		# enables logging for rules with log keyword to syslogd(8)
options    IPFIREWALL_VERBOSE_LIMIT=5	# limits number of logged packets per-entry
options    IPFIREWALL_DEFAULT_TO_ACCEPT # sets default policy to pass what is not explicitly denied
options    IPFIREWALL_NAT		# enables basic in-kernel NAT support
options    LIBALIAS			# enables full in-kernel NAT support
options    IPFIREWALL_NAT64		# enables in-kernel NAT64 support
options    IPFIREWALL_NPTV6		# enables in-kernel IPv6 NPT support
options    IPFIREWALL_PMOD		# enables protocols modification module support
options    IPDIVERT			# enables NAT through natd(8)</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>O IPFW pode ser carregado como um módulo do kernel: as opções acima são compiladas por padrão como módulos ou podem ser configuradas em tempo de execução usando parâmetros configuráveis.</p></div></td></tr></tbody></table></div></div></div><div class=sect2><h3 id=firewalls-ipf>30.5. IPFILTER (IPF)<a class=anchor href=#firewalls-ipf></a></h3><div class=paragraph><p>O IPFILTER, também conhecido como IPF, é um firewall cross-platform de código aberto que foi portado para vários sistemas operacionais, incluindo FreeBSD, NetBSD, OpenBSD e Solaris™.</p></div><div class=paragraph><p>O IPFILTER é um firewall kernel-side e um mecanismo NAT que pode ser controlado e monitorado por programas da área de usuário. As regras de firewall podem ser definidas ou excluídas usando ipf, as regras NAT podem ser definidas ou excluídas usando ipnat, estatísticas em tempo de execução para as partes do kernel IPFILTER podem ser informadas usando ipfstat, e ipmon pode ser usado para logar ações do IPFILTER nos arquivos de log do sistema.</p></div><div class=paragraph><p>O IPF foi originalmente escrito usando uma lógica de processamento de regra de que "a última regra que corresponder, ganha" e era utilizado apenas regras stateless. Desde então, IPF foi aprimorado para incluir as opções <code>quick</code> e <code>keep state</code>.</p></div><div class=paragraph><p>O FAQ IPF está em <a href=http://www.phildev.net/ipf/index.html>http://www.phildev.net/ipf/index.html</a>. Um arquivo liberado para buscas da lista de discussão IPFilter está disponível em <a href="http://marc.info/?l=ipfilter">http://marc.info/?l=ipfilter</a>.</p></div><div class=paragraph><p>Esta seção do Handbook foca no IPF no que se refere ao FreeBSD. Ele fornece exemplos de regras que contêm as opções <code>quick</code> e <code>keep state</code>.</p></div><div class=sect3><h4 id=_ativando_o_ipf>30.5.1. Ativando o IPF<a class=anchor href=#_ativando_o_ipf></a></h4><div class=paragraph><p>O IPF está incluído na instalação base do FreeBSD como um módulo carregável do kernel, o que significa que um kernel personalizado não é necessário para habilitar o IPF.</p></div><div class=paragraph><p>Para usuários que preferem compilar estaticamente o suporte ao IPF em um kernel personalizado, consulte as instruções em <a href=./#kernelconfig>Configurando o kernel do FreeBSD</a>. As seguintes opções do kernel estão disponíveis:</p></div><div class="literalblock programlisting"><div class=content><pre>options IPFILTER
options IPFILTER_LOG
options IPFILTER_LOOKUP
options IPFILTER_DEFAULT_BLOCK</pre></div></div><div class=paragraph><p>onde <code>options IPFILTER</code> ativa o suporte para o IPFILTER, <code>options IPFILTER_LOG</code> ativa o log do IPF usando o pseudo-dispositivo de log <span class=filename>ipl</span> para cada regra que tenha a palavra-chave <code>log</code>, <code>IPFILTER_LOOKUP</code> ativa as pools IP para acelerar IP lookups, e <code>options IPFILTER_DEFAULT_BLOCK</code> altera o comportamento padrão para que qualquer pacote que não corresponda a uma regra <code>pass</code> do firewall seja bloqueado.</p></div><div class=paragraph><p>Para configurar o sistema para ativar o IPF no momento da inicialização, adicione as seguintes entradas ao <span class=filename>/etc/rc.conf</span>. Essas entradas também ativarão o log e o <code>default pass all</code>. Para alterar a política padrão para <code>block all</code> sem compilar um kernel personalizado, lembre-se de adicionar uma regra <code>block all</code> no final do conjunto de regras.</p></div><div class="literalblock programlisting"><div class=content><pre>ipfilter_enable=&#34;YES&#34;             # Start ipf firewall
ipfilter_rules=&#34;/etc/ipf.rules&#34;   # loads rules definition text file
ipv6_ipfilter_rules=&#34;/etc/ipf6.rules&#34; # loads rules definition text file for IPv6
ipmon_enable=&#34;YES&#34;                # Start IP monitor log
ipmon_flags=&#34;-Ds&#34;                 # D = start as daemon
                                  # s = log to syslog
                                  # v = log tcp window, ack, seq
                                  # n = map IP &amp; port to names</pre></div></div><div class=paragraph><p>Se a funcionalidade NAT for necessária, adicione também estas linhas:</p></div><div class="literalblock programlisting"><div class=content><pre>gateway_enable=&#34;YES&#34;              # Enable as LAN gateway
ipnat_enable=&#34;YES&#34;                # Start ipnat function
ipnat_rules=&#34;/etc/ipnat.rules&#34;    # rules definition file for ipnat</pre></div></div><div class=paragraph><p>Então, inicie o IPF:</p></div><div class="literalblock programlisting"><div class=content><pre># service ipfilter start</pre></div></div><div class=paragraph><p>Para carregar as regras de firewall, especifique o nome do arquivo do conjunto de regras usando <code>ipf</code>. O comando a seguir pode ser usado para substituir as regras de firewall que está em execução:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ipf -Fa -f /etc/ipf.rules</span></code></pre></div></div><div class=paragraph><p>onde <code>-Fa</code> limpa todas as tabelas de regras internas e <code>-f</code> especifica o arquivo que contém as regras a serem carregadas.</p></div><div class=paragraph><p>Isso fornece a capacidade de fazer alterações em um conjunto de regras personalizado e atualizar o firewall em execução com uma nova cópia das regras sem precisar reinicializar o sistema. Esse método é conveniente para testar novas regras, pois o procedimento pode ser executado quantas vezes forem necessárias.</p></div><div class=paragraph><p>Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=ipf&amp;sektion=8&amp;format=html">ipf(8)</a> para detalhes sobre as outras flags disponíveis com este comando.</p></div></div><div class=sect3><h4 id=_sintaxe_de_regras_ipf>30.5.2. Sintaxe de Regras IPF<a class=anchor href=#_sintaxe_de_regras_ipf></a></h4><div class=paragraph><p>Esta seção descreve a sintaxe de regras IPF usada para criar regras stateful. Ao criar regras, lembre-se de que, a menos que a palavra-chave <code>quick</code> apareça em uma regra, todas as regras são lidas em ordem, com a <em>última regra correspondente</em> sendo a aplicada. Isso significa que, mesmo que a primeira regra que corresponder a um pacote seja <code>pass</code>, se houver uma regra de correspondência posterior que seja <code>block</code>, o pacote será descartado. Os conjuntos de regras de exemplo podem ser encontrados em <span class=filename>/usr/shared/examples/ipfilter</span>.</p></div><div class=paragraph><p>Ao criar regras, um caractere <code>#</code> é usado para marcar o início de um comentário e pode aparecer no final de uma regra, para explicar a função dessa regra ou em sua própria linha. Todas as linhas em branco são ignoradas.</p></div><div class=paragraph><p>As palavras-chave usadas nas regras devem ser escritas em uma ordem específica, da esquerda para a direita. Algumas palavras-chave são obrigatórias, enquanto outras são opcionais. Algumas palavras-chave têm sub-opções que podem ser palavras-chave e também incluem mais sub-opções. A ordem das palavras-chave é a seguinte, em que as palavras mostradas em maiúsculas representam uma variável e as palavras mostradas em minúsculas devem preceder a variável que a segue:</p></div><div class=paragraph><p><em>ACTION DIRECTION OPTIONS proto PROTO_TYPE from SRC_ADDR SRC_PORT to DST_ADDR DST_PORT TCP_FLAG|ICMP_TYPE keep state STATE</em></p></div><div class=paragraph><p>Esta seção descreve cada uma dessas palavras-chave e suas opções. Não é uma lista exaustiva de todas as opções possíveis. Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=ipf&amp;sektion=5&amp;format=html">ipf(5)</a> para obter uma descrição completa da sintaxe de regra que pode ser usada ao criar regras IPF e exemplos para usar de cada palavra-chave.</p></div><div class=dlist><dl><dt class=hdlist1>ACTION</dt><dd><p>A palavra-chave action indica o que fazer com o pacote se corresponder a essa regra. Toda regra <em>deve</em> ter uma ação. As seguintes ações são reconhecidas:</p><div class=paragraph><p><code>block</code>: descarta o pacote.</p></div><div class=paragraph><p><code>pass</code>: permite o pacote.</p></div><div class=paragraph><p><code>log</code>: gera um registro de log.</p></div><div class=paragraph><p><code>count</code>: conta o número de pacotes e bytes que podem fornecer uma indicação da frequência com que uma regra é usada.</p></div><div class=paragraph><p><code>auth</code>: enfileira o pacote para processamento adicional por outro programa.</p></div><div class=paragraph><p><code>call</code>: fornece acesso a funções embutidas no IPF que permitem ações mais complexas.</p></div><div class=paragraph><p><code>decapsulate</code>: remove quaisquer cabeçalhos para processar o conteúdo do pacote.</p></div></dd><dt class=hdlist1>DIRECTION</dt><dd><p>Em seguida, cada regra deve indicar explicitamente a direção do tráfego usando uma dessas palavras-chave:</p><div class=paragraph><p><code>in</code>: a regra é aplicada em um pacote de entrada.</p></div><div class=paragraph><p><code>out</code>: a regra é aplicada em um pacote de saída.</p></div><div class=paragraph><p><code>all</code>: a regra se aplica em qualquer direção.</p></div><div class=paragraph><p>Se o sistema tiver várias interfaces, a interface pode ser especificada junto com a direção. Um exemplo seria <code>in on fxp0</code>.</p></div></dd><dt class=hdlist1>OPTIONS</dt><dd><p>Opções são opcionais. No entanto, se várias opções forem especificadas, elas deverão ser usadas na ordem apresentada aqui.</p><div class=paragraph><p><code>log</code>: ao executar a ACTION especificada, o conteúdo dos cabeçalhos do pacote será gravado no pseudo-dispositivo de log <a href="https://man.freebsd.org/cgi/man.cgi?query=ipl&amp;sektion=4&amp;format=html">ipl(4)</a>.</p></div><div class=paragraph><p><code>quick</code>: se um pacote corresponder a essa regra, a ACTION especificada pela regra ocorrerá e nenhum processamento adicional das regras a seguir ocorrerá para este pacote.</p></div><div class=paragraph><p><code>on</code>: deve ser seguido pelo nome da interface conforme exibido pelo <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a>. A regra corresponderá somente se o pacote estiver passando pela interface especificada na direção especificada.</p></div><div class=paragraph><p>Ao usar a palavra-chave <code>log</code>, os seguintes qualificadores podem ser usados nesta ordem:</p></div><div class=paragraph><p><code>body</code>: indica que os primeiros 128 bytes do conteúdo do pacote serão registrados após os cabeçalhos.</p></div><div class=paragraph><p><code>first</code>: se a palavra-chave <code>log</code> estiver sendo usada em conjunto com uma opção <code>keep state</code>, esta opção é recomendada para que somente o pacote acionador seja logado e não todos os pacotes que corresponde à conexão stateful.</p></div><div class=paragraph><p>Opções adicionais estão disponíveis para especificar mensagens de retorno de erro. Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=ipf&amp;sektion=5&amp;format=html">ipf(5)</a> para mais detalhes.</p></div></dd><dt class=hdlist1>PROTO_TYPE</dt><dd><p>O tipo de protocolo é opcional. No entanto, é obrigatório se a regra precisar especificar um SRC_PORT ou um DST_PORT, uma vez que isso requer o tipo de protocolo. Ao especificar o tipo de protocolo, use a palavra-chave <code>proto</code> seguida de um número de protocolo ou nome de <span class=filename>/etc/protocols</span>. Exemplos de nomes de protocolos incluem <code>tcp</code>, <code>udp</code> ou <code>icmp</code>. Se PROTO_TYPE for especificado, mas nenhum SRC_PORT ou DST_PORT for especificado, todos os números de porta desse protocolo corresponderão a essa regra.</p></dd><dt class=hdlist1>SRC_ADDR</dt><dd><p>A palavra-chave <code>from</code> é obrigatória e é seguida por uma palavra-chave que representa a origem do pacote. A origem pode ser um nome de host, um endereço IP seguido pela máscara CIDR, um pool de endereços ou a palavra-chave <code>all</code>. Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=ipf&amp;sektion=5&amp;format=html">ipf(5)</a> para exemplos.</p><div class=paragraph><p>Não há como definir intervalos de endereços de IP que não se expressam facilmente usando a notação de formato numérico com ponto / máscara. O pacote ou port <a class=package href=https://cgit.freebsd.org/ports/tree/net-mgmt/ipcalc/>net-mgmt/ipcalc</a> pode ser usado para facilitar o cálculo da máscara CIDR. Informações adicionais estão disponíveis na página web da ferramenta: <a href=http://jodies.de/ipcalc>http://jodies.de/ipcalc</a>.</p></div></dd><dt class=hdlist1>SRC_PORT</dt><dd><p>O número da porta da origem é opcional. No entanto, se for usado, ela exige que o PROTO_TYPE seja definido primeiramente na regra. O número da porta também deve ser precedido pela palavra-chave <code>proto</code>.</p><div class=paragraph><p>Diferentes operadores de comparação são suportados: <code>=</code> (igual a), <code>!=</code> (diferente de), <code>&lt;</code> (menor que), <code>></code> (maior que), <code>⇐</code> (menor ou igual a) e <code>>=</code> (maior que ou igual a).</p></div><div class=paragraph><p>Para especificar intervalos de porta, coloque os dois números de porta entre <code>&lt;></code> (menor que e maior que), <code>>&lt;</code> (maior que e menor que) ou <code>:</code> (maior que ou igual a e menor que ou igual a).</p></div></dd><dt class=hdlist1>DST_ADDR</dt><dd><p>A palavra-chave <code>to</code> é obrigatória e é seguida por uma palavra-chave que representa o destino do pacote. Semelhante ao SRC_ADDR, ela pode ser um nome de host, um endereço IP seguido pela máscara CIDR, um pool de endereços ou a palavra-chave <code>all</code>.</p></dd><dt class=hdlist1>DST_PORT</dt><dd><p>Semelhante ao SRC_PORT, o número da porta do destino é opcional. No entanto, se for usada, ela exige que o PROTO_TYPE seja definido primeiramente na regra. O número da porta também deve ser precedido pela palavra-chave <code>proto</code>.</p></dd><dt class=hdlist1>TCP_FLAG|ICMP_TYPE</dt><dd><p>Se <code>tcp</code> for especificado como o PROTO_TYPE, flags poderão ser especificadas como letras, onde cada letra representa uma das possíveis flags TCP utilizadas para determinar o estado de uma conexão. Os valores possíveis são: <code>S</code> (SYN), <code>A</code> (ACK), <code>P</code> (PSH), <code>F</code> (FIN), <code>U</code> (URG), <code>R</code> (RST), <code>C</code> (CWN), e <code>E</code> (ECN).</p><div class=paragraph><p>Se o <code>icmp</code> for especificado como o PROTO_TYPE, o tipo ICMP para correspondência pode ser especificado. Consulte o <a href="https://man.freebsd.org/cgi/man.cgi?query=ipf&amp;sektion=5&amp;format=html">ipf(5)</a> para os tipos permitidos.</p></div></dd><dt class=hdlist1>STATE</dt><dd><p>Se uma regra <code>pass</code> contiver <code>keep state</code>, o IPF incluirá uma entrada em sua tabela de estados dinâmicos e permitirá o tráfego os pacotes subsequentes que correspondam à conexão. O IPF pode rastrear o estado das sessões TCP, UDP e ICMP. Qualquer pacote que o IPF tenha certeza de que faz parte de uma sessão ativa, mesmo que seja um protocolo diferente, será liberado.</p><div class=paragraph><p>No IPF, os pacotes destinados a sair pela interface conectada à Internet pública são verificados primeiro na tabela de estados dinâmicos. Se o pacote corresponder ao próximo pacote esperado, compreendendo uma sessão ativa, ele sairá do firewall e o estado do fluxo da sessão será atualizado na tabela de estados dinâmicos. Os pacotes que não pertencem a uma sessão já ativa são verificados no conjunto de regras de saída. Os pacotes vindos da interface conectada à Internet pública são verificados primeiro na tabela de estados dinâmicos. Se o pacote corresponder ao próximo pacote esperado que compreende uma sessão ativa, ele sairá do firewall e o estado do fluxo da sessão será atualizado na tabela de estados dinâmicos. Os pacotes que não pertencem a uma sessão já ativa são verificados no conjunto de regras de entrada.</p></div><div class=paragraph><p>Várias palavras-chave podem ser adicionadas depois de <code>keep state</code>. Se usadas, essas palavras-chave definem várias opções que controlam a filtragem stateful, como a configuração de limites de conexão ou o tempo de vida da conexão. Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=ipf&amp;sektion=5&amp;format=html">ipf(5)</a> para obter a lista de opções disponíveis e suas descrições.</p></div></dd></dl></div></div><div class=sect3><h4 id=_exemplo_de_conjunto_de_regras_2>30.5.3. Exemplo de Conjunto de Regras<a class=anchor href=#_exemplo_de_conjunto_de_regras_2></a></h4><div class=paragraph><p>Esta seção demonstra como criar um conjunto de regras de exemplo que permite apenas serviços que correspondam às regras <code>pass</code> e bloqueie todo o resto.</p></div><div class=paragraph><p>O FreeBSD usa a interface de loopback (<span class=filename>lo0</span>) e o endereço IP <code>127.0.0.1</code> para comunicação interna. O conjunto de regras do firewall deve conter regras para permitir o livre movimento desses pacotes usados internamente:</p></div><div class="literalblock programlisting"><div class=content><pre># no restrictions on loopback interface
pass in quick on lo0 all
pass out quick on lo0 all</pre></div></div><div class=paragraph><p>A interface pública conectada à Internet é usada para autorizar e controlar o acesso de todas as conexões de entrada e saída. Se uma ou mais interfaces forem cabeadas para redes privadas, essas interfaces internas poderão exigir regras para permitir que os pacotes originados da LAN fluam entre as redes internas ou para a interface conectada à Internet. O conjunto de regras deve ser organizado em três seções principais: quaisquer interfaces internas confiáveis, conexões de saída por meio da interface pública e conexões de entrada por meio da interface pública.</p></div><div class=paragraph><p>Essas duas regras permitem que todo o tráfego passe por uma interface confiável LAN chamada <span class=filename>xl0</span>:</p></div><div class="literalblock programlisting"><div class=content><pre># no restrictions on inside LAN interface for private network
pass out quick on xl0 all
pass in quick on xl0 all</pre></div></div><div class=paragraph><p>As regras para as seções de saída e entrada da interface pública devem ter as regras correspondidas com mais frequência antes das regras menos comuns, com a última regra na seção bloqueando e registrando todos os pacotes para essa interface e direção.</p></div><div class=paragraph><p>Este conjunto de regras define a seção de saída da interface pública denominada <span class=filename>dc0</span>. Essas regras mantêm o estado e identificam os serviços específicos que os sistemas internos estão autorizados para acesso público à Internet. Todas as regras usam <code>quick</code> e especificam os números de porta apropriados e, quando aplicável, os endereços de destino.</p></div><div class="literalblock programlisting"><div class=content><pre># interface facing Internet (outbound)
# Matches session start requests originating from or behind the
# firewall, destined for the Internet.

# Allow outbound access to public DNS servers.
# Replace x.x.x. with address listed in /etc/resolv.conf.
# Repeat for each DNS server.
pass out quick on dc0 proto tcp from any to x.x.x. port = 53 flags S keep state
pass out quick on dc0 proto udp from any to xxx port = 53 keep state

# Allow access to ISP&#39;s specified DHCP server for cable or DSL networks.
# Use the first rule, then check log for the IP address of DHCP server.
# Then, uncomment the second rule, replace z.z.z.z with the IP address,
# and comment out the first rule
pass out log quick on dc0 proto udp from any to any port = 67 keep state
#pass out quick on dc0 proto udp from any to z.z.z.z port = 67 keep state

# Allow HTTP and HTTPS
pass out quick on dc0 proto tcp from any to any port = 80 flags S keep state
pass out quick on dc0 proto tcp from any to any port = 443 flags S keep state

# Allow email
pass out quick on dc0 proto tcp from any to any port = 110 flags S keep state
pass out quick on dc0 proto tcp from any to any port = 25 flags S keep state

# Allow NTP
pass out quick on dc0 proto tcp from any to any port = 37 flags S keep state

# Allow FTP
pass out quick on dc0 proto tcp from any to any port = 21 flags S keep state

# Allow SSH
pass out quick on dc0 proto tcp from any to any port = 22 flags S keep state

# Allow ping
pass out quick on dc0 proto icmp from any to any icmp-type 8 keep state

# Block and log everything else
block out log first quick on dc0 all</pre></div></div><div class=paragraph><p>Neste exemplo de regras na seção de entrada da interface pública todos os pacotes indesejáveis são bloqueados primeiro. Isso reduz o número de pacotes registrados pela última regra.</p></div><div class="literalblock programlisting"><div class=content><pre># interface facing Internet (inbound)
# Block all inbound traffic from non-routable or reserved address spaces
block in quick on dc0 from 192.168.0.0/16 to any    #RFC 1918 private IP
block in quick on dc0 from 172.16.0.0/12 to any     #RFC 1918 private IP
block in quick on dc0 from 10.0.0.0/8 to any        #RFC 1918 private IP
block in quick on dc0 from 127.0.0.0/8 to any       #loopback
block in quick on dc0 from 0.0.0.0/8 to any         #loopback
block in quick on dc0 from 169.254.0.0/16 to any    #DHCP auto-config
block in quick on dc0 from 192.0.2.0/24 to any      #reserved for docs
block in quick on dc0 from 204.152.64.0/23 to any   #Sun cluster interconnect
block in quick on dc0 from 224.0.0.0/3 to any       #Class D &amp; E multicast

# Block fragments and too short tcp packets
block in quick on dc0 all with frags
block in quick on dc0 proto tcp all with short

# block source routed packets
block in quick on dc0 all with opt lsrr
block in quick on dc0 all with opt ssrr

# Block OS fingerprint attempts and log first occurrence
block in log first quick on dc0 proto tcp from any to any flags FUP

# Block anything with special options
block in quick on dc0 all with ipopts

# Block public pings and ident
block in quick on dc0 proto icmp all icmp-type 8
block in quick on dc0 proto tcp from any to any port = 113

# Block incoming Netbios services
block in log first quick on dc0 proto tcp/udp from any to any port = 137
block in log first quick on dc0 proto tcp/udp from any to any port = 138
block in log first quick on dc0 proto tcp/udp from any to any port = 139
block in log first quick on dc0 proto tcp/udp from any to any port = 81</pre></div></div><div class=paragraph><p>Sempre que houver mensagens de log em uma regra com a opção <code>log first</code>, execute <code>ipfstat -hio</code> para saber quantas vezes a regra foi correspondida. Um grande número de correspondências pode indicar que o sistema está sob ataque.</p></div><div class=paragraph><p>O restante das regras na seção de entrada define quais conexões podem ser iniciadas a partir da Internet. A última regra nega todas as conexões que não foram explicitamente permitidas pelas regras anteriores desta seção.</p></div><div class="literalblock programlisting"><div class=content><pre># Allow traffic in from ISP&#39;s DHCP server. Replace z.z.z.z with
# the same IP address used in the outbound section.
pass in quick on dc0 proto udp from z.z.z.z to any port = 68 keep state

# Allow public connections to specified internal web server
pass in quick on dc0 proto tcp from any to x.x.x.x port = 80 flags S keep state

# Block and log only first occurrence of all remaining traffic.
block in log first quick on dc0 all</pre></div></div></div><div class=sect3><h4 id=_configurando_o_nat>30.5.4. Configurando o NAT<a class=anchor href=#_configurando_o_nat></a></h4><div class=paragraph><p>Para ativar o NAT, adicione estas instruções ao arquivo <span class=filename>/etc/rc.conf</span> e especifique o nome do arquivo que contém as regras de NAT:</p></div><div class="literalblock programlisting"><div class=content><pre>gateway_enable=&#34;YES&#34;
ipnat_enable=&#34;YES&#34;
ipnat_rules=&#34;/etc/ipnat.rules&#34;</pre></div></div><div class=paragraph><p>As regras de NAT são flexíveis e podem realizar muitas coisas diferentes para atender às necessidades dos usuários comerciais e domésticos. A sintaxe da regra apresentada aqui foi simplificada para demonstrar um uso comum. Para obter uma descrição completa da sintaxe da regra, consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=ipnat&amp;sektion=5&amp;format=html">ipnat(5)</a>.</p></div><div class=paragraph><p>A sintaxe básica para uma regra NAT é a seguinte, onde <code>map</code> inicia a regra e <em>IF</em> deve ser substituído pelo nome da interface externa:</p></div><div class="literalblock programlisting"><div class=content><pre>map IF LAN_IP_RANGE -&gt; PUBLIC_ADDRESS</pre></div></div><div class=paragraph><p>O <em>LAN_IP_RANGE</em> é o intervalo de endereços IP usados pelos clientes internos. Geralmente, é um intervalo de endereços privados, como <code>192.168.1.0/24</code>. O <em>PUBLIC_ADDRESS</em> pode ser o endereço IP externo estático ou a palavra-chave <code>0/32</code> que representa o endereço IP atribuído para <em>IF</em>.</p></div><div class=paragraph><p>No IPF, quando um pacote chega ao firewall a partir da LAN com um destino público, ele primeiro passa pelas regras de saída do conjunto de regras do firewall. Em seguida, o pacote é passado para o conjunto de regras NAT, o qual é lido de cima para baixo, onde a primeira regra correspondente ganha. O IPF testa cada regra de NAT em relação ao nome da interface e ao endereço IP de origem do pacote. Quando o nome da interface de um pacote corresponde a uma regra NAT, o endereço IP de origem do pacote na LAN privada é verificado para ver se ele está dentro do intervalo de endereços IP especificado em <em>LAN_IP_RANGE</em>. Se corresponder, o pacote tem seu endereço IP de origem reescrito com o endereço IP público especificado por <em>PUBLIC_ADDRESS</em>. O IPF adiciona uma entrada em sua tabela NAT interna para que, quando o pacote retornar da Internet, possa ser mapeado de volta para seu endereço IP privado original antes de ser passado para as regras de firewall para processamento adicional.</p></div><div class=paragraph><p>Para redes que possuem um grande número de sistemas internos ou várias sub-redes, o processo de afunilar todo endereço IP em um único endereço IP público se torna um problema de recursos. Dois métodos estão disponíveis para aliviar esse problema.</p></div><div class=paragraph><p>O primeiro método é atribuir um intervalo de portas para usar como portas de origem. Adicionando a palavra-chave <code>portmap</code>, o NAT pode ser direcionado para usar apenas portas de origem no intervalo especificado:</p></div><div class="literalblock programlisting"><div class=content><pre>map dc0 192.168.1.0/24 -&gt; 0/32 portmap tcp/udp 20000:60000</pre></div></div><div class=paragraph><p>Como alternativa, use a palavra-chave <code>auto</code> que informa ao NAT para determinar as portas que estão disponíveis para uso:</p></div><div class="literalblock programlisting"><div class=content><pre>map dc0 192.168.1.0/24 -&gt; 0/32 portmap tcp/udp auto</pre></div></div><div class=paragraph><p>O segundo método é usar um pool de endereços públicos. Isso é útil quando existem muitos clientes na LAN para para usar um único endereço público e um bloco de endereços públicos de IP está disponível. Esses endereços públicos podem ser usados como um pool do qual o NAT seleciona um endereço IP à medida que o endereço de um pacote é mapeado ao sair.</p></div><div class=paragraph><p>O intervalo de endereços IP públicos pode ser especificado usando uma notação de netmask ou CIDR. Essas duas regras são equivalentes:</p></div><div class="literalblock programlisting"><div class=content><pre>map dc0 192.168.1.0/24 -&gt; 204.134.75.0/255.255.255.0
map dc0 192.168.1.0/24 -&gt; 204.134.75.0/24</pre></div></div><div class=paragraph><p>Uma prática comum é ter um servidor web ou servidor de email publicamente acessível isolado a um segmento de rede interno. O tráfego desses servidores ainda precisa passar por NAT, mas o redirecionamento de porta é necessário para direcionar o tráfego de entrada para o servidor correto. Por exemplo, para mapear um servidor web usando o endereço interno <code>10.0.10.25</code> para seu endereço IP público <code>20.20.20.5</code>, use esta regra:</p></div><div class="literalblock programlisting"><div class=content><pre>rdr dc0 20.20.20.5/32 port 80 -&gt; 10.0.10.25 port 80</pre></div></div><div class=paragraph><p>Se for o único servidor web, essa regra também funcionará, pois redirecionará todas as solicitações HTTP externas para <code>10.0.10.25</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>rdr dc0 0.0.0.0/0 port 80 -&gt; 10.0.10.25 port 80</pre></div></div><div class=paragraph><p>O IPF possui um proxy FTP embutido que pode ser usado com o NAT. Ele monitora todo o tráfego de saída de conexões ativa ou passiva de FTP e cria dinamicamente regras de filtro temporário contendo o número de porta usado pelo canal de dados FTP. Isso elimina a necessidade de abrir grandes intervalos de portas altas para conexões de FTP.</p></div><div class=paragraph><p>Neste exemplo, a primeira regra chama o proxy no tráfego de saída FTP da LAN interna. A segunda regra passa o tráfego de FTP do firewall para a Internet, e a terceira regra lida com todo o tráfego não FTP da LAN interna:</p></div><div class="literalblock programlisting"><div class=content><pre>map dc0 10.0.10.0/29 -&gt; 0/32 proxy port 21 ftp/tcp
map dc0 0.0.0.0/0 -&gt; 0/32 proxy port 21 ftp/tcp
map dc0 10.0.10.0/29 -&gt; 0/32</pre></div></div><div class=paragraph><p>As regras <code>map</code> de FTP vem antes da regra NAT, de modo que quando um pacote corresponder a uma regra FTP, o proxy FTP crie regras temporárias de filtragem para permitir que os pacotes da sessão FTP sejam liberados e que passem pelo NAT. Todos os pacotes de rede local que não sejam FTP não corresponderão às regras de FTP, mas serão liberados pelo NAT se corresponderem à terceira regra.</p></div><div class=paragraph><p>Sem o proxy FTPem, as seguintes regras de firewall seriam necessárias. Note que sem o proxy, todas as portas acima de <code>1024</code> precisam ser permitidas:</p></div><div class="literalblock programlisting"><div class=content><pre># Allow out LAN PC client FTP to public Internet
# Active and passive modes
pass out quick on rl0 proto tcp from any to any port = 21 flags S keep state

# Allow out passive mode data channel high order port numbers
pass out quick on rl0 proto tcp from any to any port &gt; 1024 flags S keep state

# Active mode let data channel in from FTP server
pass in quick on rl0 proto tcp from any to any port = 20 flags S keep state</pre></div></div><div class=paragraph><p>Sempre que o arquivo contendo as regras de NAT for editado, execute <code>ipnat</code> com <code>-CF</code> para excluir as regras atuais de NAT e liberar o conteúdo da tabela de tradução dinâmica. Inclua <code>-f</code> e especifique o nome do conjunto de regras NAT para carregar:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ipnat -CF -f /etc/ipnat.rules</span></code></pre></div></div><div class=paragraph><p>Para exibir as estatísticas de NAT:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ipnat -s</span></code></pre></div></div><div class=paragraph><p>Para listar os mapeamentos atuais da tabela NAT:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ipnat -l</span></code></pre></div></div><div class=paragraph><p>Para ativar o modo verbose e exibir informações relacionadas ao processamento de regras, regras ativas e registros nas tabelas:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ipnat -v</span></code></pre></div></div></div><div class=sect3><h4 id=_visualizando_estatísticas_do_ipf>30.5.5. Visualizando Estatísticas do IPF<a class=anchor href=#_visualizando_estatísticas_do_ipf></a></h4><div class=paragraph><p>O IPF inclui o <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfstat&amp;sektion=8&amp;format=html">ipfstat(8)</a> que pode ser usado para recuperar e exibir estatísticas das regras sendo utilizadas enquanto os pacotes passam pelo firewall. As estatísticas são acumuladas desde que o firewall foi iniciado pela última vez ou desde a última vez que foram redefinidas para zero usando <code>ipf -Z</code>.</p></div><div class=paragraph><p>A saída padrão do <code>ipfstat</code> é semelhante a esta:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>input packets: blocked 99286 passed 1255609 nomatch 14686 counted 0
 output packets: blocked 4200 passed 1284345 nomatch 14687 counted 0
 input packets logged: blocked 99286 passed 0
 output packets logged: blocked 0 passed 0
 packets logged: input 0 output 0
 log failures: input 3898 output 0
 fragment state<span class=o>(</span><span class=k>in</span><span class=o>)</span>: kept 0 lost 0
 fragment state<span class=o>(</span>out<span class=o>)</span>: kept 0 lost 0
 packet state<span class=o>(</span><span class=k>in</span><span class=o>)</span>: kept 169364 lost 0
 packet state<span class=o>(</span>out<span class=o>)</span>: kept 431395 lost 0
 ICMP replies: 0 TCP RSTs sent: 0
 Result cache hits<span class=o>(</span><span class=k>in</span><span class=o>)</span>: 1215208 <span class=o>(</span>out<span class=o>)</span>: 1098963
 IN Pullups succeeded: 2 failed: 0
 OUT Pullups succeeded: 0 failed: 0
 Fastroute successes: 0 failures: 0
 TCP <span class=nb>cksum </span>fails<span class=o>(</span><span class=k>in</span><span class=o>)</span>: 0 <span class=o>(</span>out<span class=o>)</span>: 0
 Packet log flags <span class=nb>set</span>: <span class=o>(</span>0<span class=o>)</span></code></pre></div></div><div class=paragraph><p>Várias opções estão disponíveis. Quando executado com <code>-i</code> para entrada ou <code>-o</code> para saída, o comando recuperará e exibirá a lista apropriada de regras de filtro atualmente instaladas e em uso pelo kernel. Para também ver os números das regras, inclua <code>-n</code>. Por exemplo, <code>ipfstat -on</code> exibe a tabela de regras de saída com os números de regra:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>@1 pass out on xl0 from any to any
@2 block out on dc0 from any to any
@3 pass out quick on dc0 proto tcp/udp from any to any keep state</code></pre></div></div><div class=paragraph><p>Inclua <code>-h</code> para prefixar cada regra com uma contagem de quantas vezes a regra foi utilizada. Por exemplo, <code>ipfstat -oh</code> exibe a tabela de regras internas de saída, prefixando cada regra com sua contagem de uso:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>2451423 pass out on xl0 from any to any
354727 block out on dc0 from any to any
430918 pass out quick on dc0 proto tcp/udp from any to any keep state</code></pre></div></div><div class=paragraph><p>Para exibir a tabela de estados em um formato similar ao <a href="https://man.freebsd.org/cgi/man.cgi?query=top&amp;sektion=1&amp;format=html">top(1)</a>, use <code>ipfstat -t</code>. Quando o firewall está sob ataque, essa opção fornece a capacidade de identificar e ver os pacotes de ataque. As sub-flags opcionais dão a possibilidade de selecionar o IP destino ou origem, porta ou protocolo a ser monitorado em tempo real. Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfstat&amp;sektion=8&amp;format=html">ipfstat(8)</a> para detalhes.</p></div></div><div class=sect3><h4 id=_log_do_ipf>30.5.6. Log do IPF<a class=anchor href=#_log_do_ipf></a></h4><div class=paragraph><p>O IPF fornece o <code>ipmon</code>, que pode ser usado para gravar as informações de log do firewall em um formato legível por humanos. Isso requer que as opções <code>IPFILTER_LOG</code> sejam primeiramente adicionadas a um kernel personalizado usando as instruções em <a href=./#kernelconfig>Configurando o kernel do FreeBSD</a>.</p></div><div class=paragraph><p>Esse comando geralmente é executado no modo daemon para fornecer um arquivo de log contínuo do sistema para que o registro de eventos passados possa ser revisado. Como o FreeBSD possui um recurso <a href="https://man.freebsd.org/cgi/man.cgi?query=syslogd&amp;sektion=8&amp;format=html">syslogd(8)</a> integrado para rotacionar automaticamente os logs do sistema, a instrução <code>ipmon_flags</code> no arquivo <span class=filename>rc.conf</span> por padrão utiliza <code>-Ds</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>ipmon_flags=&#34;-Ds&#34; # D = start as daemon
                  # s = log to syslog
                  # v = log tcp window, ack, seq
                  # n = map IP &amp; port to names</pre></div></div><div class=paragraph><p>O registro em log fornece a capacidade de revisar, após o fato, informações como quais pacotes foram descartados, de que endereços eles vieram e para onde estavam indo. Esta informação é útil para rastrear invasores.</p></div><div class=paragraph><p>Uma vez que o recurso de criação de log esteja ativado no arquivo <span class=filename>rc.conf</span> e iniciado com o serviço <code>ipmon start</code>, o IPF irá registrar apenas as regras que contêm a palavra-chave <code>log</code>. O administrador do firewall decide quais regras no conjunto de regras devem ser logadas e normalmente apenas as regras de negação são registradas. É costume incluir a palavra-chave <code>log</code> na última regra do conjunto de regras. Isso possibilita ver todos os pacotes que não correspondem a nenhuma das regras do conjunto de regras.</p></div><div class=paragraph><p>Por padrão, o modo <code>ipmon -Ds</code> usa <code>local0</code> como o recurso de log. Os níveis de registro a seguir podem ser usados para separar ainda mais os dados logados:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>LOG_INFO - pacotes logados usando a palavra-chave <span class=s2>&#34;log&#34;</span> ao invés da ação  pass ou block.
LOG_NOTICE - pacotes logados que também são liberados
LOG_WARNING - pacotes logados que também são bloqueados
LOG_ERR - pacotes que foram logados e que podem ser considerados insuficientes devido a um cabeçalho incompleto</code></pre></div></div><div class=paragraph><p>Para configurar o IPF para logar todos os dados em <span class=filename>/var/log/ipfilter.log</span>, primeiro crie o arquivo vazio:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># touch /var/log/ipfilter.log</span></code></pre></div></div><div class=paragraph><p>Em seguida, para gravar todas as mensagens de log no arquivo especificado, inclua a seguinte instrução no arquivo <span class=filename>/etc/syslog.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>local0.* /var/log/ipfilter.log</pre></div></div><div class=paragraph><p>Para ativar as alterações e instruir o <a href="https://man.freebsd.org/cgi/man.cgi?query=syslogd&amp;sektion=8&amp;format=html">syslogd(8)</a> para ler o arquivo modificado <span class=filename>/etc/syslog.conf</span>, execute <code>service syslogd reload</code>.</p></div><div class=paragraph><p>Não se esqueça de editar o <span class=filename>/etc/newsyslog.conf</span> para rotacionar o novo arquivo de log.</p></div><div class=paragraph><p>As mensagens geradas pelo <code>ipmon</code> consistem em campos de dados separados por espaços em branco. Campos comuns a todas as mensagens são:</p></div><div class="olist arabic"><ol class=arabic><li><p>A data do recebimento do pacote.</p></li><li><p>O horário do recebimento do pacote. Isto está no formato HH:MM:SS.F, para horas, minutos, segundos e frações de segundo.</p></li><li><p>O nome da interface que processou o pacote.</p></li><li><p>O grupo e o número da regra no formato <code>@0:17</code>.</p></li><li><p>A ação: <code>p</code> para liberado (pass), <code>b</code> para bloqueado, <code>S</code> para um pacote com problema (short), <code>n</code> não corresponde a nenhuma regra e <code>L</code> para uma regra de log.</p></li><li><p>Os endereços escritos em três campos: o endereço de origem e porta separados por uma vírgula, o símbolo → , e o endereço e porta de destino. Por exemplo: <code>209.53.17.22,80 → 198.73.220.17,1722</code>.</p></li><li><p><code>PR</code> seguido pelo nome ou número do protocolo: por exemplo, <code>PR tcp</code>.</p></li><li><p><code>len</code> seguido pelo tamanho do cabeçalho e comprimento total do pacote: por exemplo, <code>len 20 40</code>.</p></li></ol></div><div class=paragraph><p>Se o pacote for um pacote TCP, haverá um campo adicional começando com um hífen seguido por letras correspondentes a quaisquer flags que foram configuradas. Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=ipf&amp;sektion=5&amp;format=html">ipf(5)</a> para obter uma lista de letras e suas flags.</p></div><div class=paragraph><p>Se o pacote for um pacote ICMP, haverá dois campos no final: o primeiro sempre sendo "icmp" e o próximo sendo a mensagem ICMP e sub-tipo de mensagem, separados por uma barra. Por exemplo: <code>icmp 3/3</code> para uma mensagem port unreachable.</p></div></div></div><div class=sect2><h3 id=firewalls-blacklistd>30.6. Blacklistd<a class=anchor href=#firewalls-blacklistd></a></h3><div class=paragraph><p>O Blacklistd é um daemon que escuta sockets para receber notificações de outros daemons sobre tentativas de conexão que falharam ou foram bem-sucedidas. É mais amplamente utilizado no bloqueio de muitas tentativas de conexão em portas abertas. Um exemplo excelente é o SSH, executado na Internet, recebendo muitas solicitações de conexão de bots ou scripts tentando adivinhar senhas e obter acesso. Utilizando blacklistd, o daemon pode notificar o firewall para criar uma regra de filtro para bloquear tentativas excessivas de conexão de uma única origem após várias tentativas. O Blacklistd foi desenvolvido pela primeira vez no NetBSD e apareceu na versão 7. O FreeBSD 11 importou o blacklistd do NetBSD.</p></div><div class=paragraph><p>Este capítulo descreve como instalar o blacklistd, configurá-lo e fornece exemplos de como usá-la. Os leitores devem estar familiarizados com os conceitos básicos de firewall, como regras. Para detalhes, consulte o capítulo sobre firewall. O PF é usado nos exemplos, mas outros firewalls disponíveis no FreeBSD também devem funcionar com o blacklistd.</p></div><div class=sect3><h4 id=_habilitando_a_blacklistd>30.6.1. Habilitando a Blacklistd<a class=anchor href=#_habilitando_a_blacklistd></a></h4><div class=paragraph><p>A configuração principal do blacklistd é armazenada em <a href="https://man.freebsd.org/cgi/man.cgi?query=blacklistd.conf&amp;sektion=5&amp;format=html">blacklistd.conf(5)</a>. Várias opções de linha de comando também estão disponíveis para alterar o comportamento em tempo de execução do blacklistd. Para persistir as configurações em uma reinicialização do sistema, deve se armazenar as opções em <span class=filename>/etc/blacklistd.conf</span>. Para ativar o daemon durante a inicialização do sistema, adicione a linha <code>blacklistd_enable</code> no <span class=filename>/etc/rc.conf</span> assim:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysrc blacklistd_enable=yes</span></code></pre></div></div><div class=paragraph><p>Para iniciar o serviço manualmente, execute este comando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service blacklistd start</span></code></pre></div></div></div><div class=sect3><h4 id=_criando_um_conjunto_de_regras_no_blacklistd>30.6.2. Criando um conjunto de regras no Blacklistd<a class=anchor href=#_criando_um_conjunto_de_regras_no_blacklistd></a></h4><div class=paragraph><p>As regras do blacklistd são configuradas em <a href="https://man.freebsd.org/cgi/man.cgi?query=blacklistd.conf&amp;sektion=5&amp;format=html">blacklistd.conf(5)</a> com uma opção por linha. Cada regra contém uma tupla separada por espaços ou tabulações. As regras pertencem a um <code>local</code> ou a um <code>remote</code>, que se aplica à máquina em que o blacklistd está sendo executado ou a uma origem externa, respectivamente.</p></div><div class=sect4><h5 id=_regras_locais>30.6.2.1. Regras Locais<a class=anchor href=#_regras_locais></a></h5><div class=paragraph><p>Um exemplo de entrada blacklistd.conf para uma regra local se parece com isso:</p></div><div class="literalblock programlisting"><div class=content><pre>[local]
ssh             stream  *       *               *       3       24h</pre></div></div><div class=paragraph><p>Todas as regras que seguem a seção <code>[local]</code> são tratadas como regras locais (que é o padrão), aplicadas à máquina local. Quando uma seção <code>[remote]</code> é encontrada, todas as regras a seguir são tratadas como regras de máquina remota.</p></div><div class=paragraph><p>Sete campos definem uma regra separada por tabulações ou espaços. Os quatro primeiros campos identificam o tráfego que deve estar na lista negra. Os três campos a seguir definem o comportamento do backlistd. Os curingas são indicados como asteriscos (<code>*</code>), correspondendo a qualquer coisa nesse campo. O primeiro campo define a localização. Nas regras locais, essas são as portas de rede. A sintaxe para o campo local é a seguinte:</p></div><div class="literalblock programlisting"><div class=content><pre>[address|interface][/mask][:port]</pre></div></div><div class=paragraph><p>Os endereços podem ser especificados como IPv4 no formato numérico ou IPv6 entre colchetes. Um nome de interface como <code><em>em0</em></code> também pode ser usado.</p></div><div class=paragraph><p>O tipo de socket é definido pelo segundo campo. Os socket TCP são do tipo <code>stream</code>, enquanto UDP é indicado como <code>dgram</code>. O exemplo acima usa TCP, pois o SSH está usando esse protocolo.</p></div><div class=paragraph><p>Um protocolo pode ser usado no terceiro campo de uma regra de lista negra. Os seguintes protocolos podem ser usados: <code>tcp</code>, <code>udp</code>, <code>tcp6</code>, <code>udp6</code> ou numérico. Um curinga, como no exemplo, geralmente é usado para corresponder a todos os protocolos, a menos que haja um motivo para distinguir o tráfego por um determinado protocolo.</p></div><div class=paragraph><p>No quarto campo, o usuário ou proprietário efetivo do processo daemon que está reportando o evento é definido. O nome de usuário ou o UID pode ser usado aqui, bem como um curinga (veja a regra de exemplo acima).</p></div><div class=paragraph><p>O nome da regra do packet filter é declarado pelo quinto campo, que inicia a parte de comportamento da regra. Por padrão, blacklistd coloca todos os blocos sob uma âncora pf chamada <code>blacklistd</code> em <span class=filename>pf.conf</span> assim:</p></div><div class="literalblock programlisting"><div class=content><pre>anchor &#34;blacklistd/*&#34; in on $ext_if
block in
pass out</pre></div></div><div class=paragraph><p>Para blacklists separadas, um nome de âncora pode ser usado neste campo. Em outros casos, o curinga será suficiente. Quando um nome começa com um hífen (<code>-</code>), significa que uma âncora com o nome de regra padrão precedido deve ser usada. Uma modificação do exemplo acima usando o hífen ficaria assim:</p></div><div class="literalblock programlisting"><div class=content><pre>ssh             stream  *       *               -ssh       3       24h</pre></div></div><div class=paragraph><p>Com essa regra, quaisquer novas regras de blacklist são adicionadas a uma âncora chamada <code>blacklistd-ssh</code>.</p></div><div class=paragraph><p>Para bloquear sub-redes inteiras para uma única violação de regra, um <code>/</code> no nome da regra pode ser usado. Isso faz com que a parte restante do nome seja interpretada como a máscara a ser aplicada ao endereço especificado na regra. Por exemplo, esta regra bloquearia todos os endereços adjacentes a <code>/24</code>.</p></div><div class="literalblock programlisting"><div class=content><pre>22              stream  tcp       *               */24    3       24h</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>É importante especificar o protocolo apropriado aqui. O IPv4 e o IPv6 tratam o /24 de maneira diferente, é por isso que <code>*</code> não pode ser usado no terceiro campo para esta regra.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Esta regra define que, se qualquer host dessa rede estiver se comportando mal, todo o resto da rede também será bloqueado.</p></div><div class=paragraph><p>O sexto campo, chamado <code>nfail</code>, define o número de falhas de login necessárias para colocar na blacklist o IP remoto em questão. Quando um curinga é usado nessa posição, isso significa que o bloqueio nunca irá acontecer. Na regra de exemplo acima, um limite de três é definido, o que significa que, após três tentativas de logon no SSH em uma conexão, o IP é bloqueado.</p></div><div class=paragraph><p>O último campo em uma definição de regra do blacklistd especifica por quanto tempo um host ficará na lista negra. A unidade padrão é segundos, mas sufixos como <code>m</code>, <code>h</code> e <code>d</code> também podem ser especificados por minutos, horas e dias, respectivamente.</p></div><div class=paragraph><p>A regra de exemplo na íntegra significa que, após três vezes a autenticação no SSH, resultará em uma nova regra de bloqueio de PF para esse host. As correspondências de regras são realizadas verificando primeiro as regras locais, uma após a outra, da mais específica à menos específica. Quando ocorre uma correspondência, as regras <code>remote</code> são aplicadas e o nome <code>nfail</code> e os campos de desativação são alterados pela regra <code>remote</code> correspondente.</p></div></div><div class=sect4><h5 id=_regras_remotas>30.6.2.2. Regras Remotas<a class=anchor href=#_regras_remotas></a></h5><div class=paragraph><p>As regras remotas são usadas para especificar como o blacklistd muda seu comportamento, dependendo do host remoto que está sendo avaliado no momento. Cada campo em uma regra remota é o mesmo que em uma regra local. A única diferença está na maneira como o blacklistd os usa. Para explicar, esta regra de exemplo é usada:</p></div><div class="literalblock programlisting"><div class=content><pre>[remote]
203.0.113.128/25 *      *       *               =/25    =       48h</pre></div></div><div class=paragraph><p>O campo de endereço pode ser um endereço IP (v4 ou v6), uma porta ou ambas. Isso permite definir regras especiais para um intervalo de endereços remotos específico, como neste exemplo. Os campos para tipo, protocolo e proprietário são identicamente interpretados como na regra local.</p></div><div class=paragraph><p>Porém, os campos de nome são diferentes: o sinal de igual (<code>=</code>) em uma regra remota diz ao blacklistd para usar o valor da regra local correspondente. Isso significa que a entrada da regra de firewall é obtida e o prefixo <code>/25</code> (uma máscara de rede <code>255.255.255.128</code>) é adicionada. Quando uma conexão desse intervalo de endereços é colocada na lista negra, toda a sub-rede é afetada. Um nome de âncora PF também pode ser usado aqui; nesse caso, o blacklisted adicionará regras para esse bloco de endereços à âncora desse nome. A tabela padrão é usada quando um curinga é especificado.</p></div><div class=paragraph><p>Um número personalizado de falhas na coluna <code>nfail</code> pode ser definido para um endereço. Isso é útil para exceções a uma regra específica, talvez para permitir a alguém uma aplicação menos rigorosa de regras ou um pouco mais de clemência nas tentativas de login. O bloqueio é desativado quando um asterisco é usado neste sexto campo.</p></div><div class=paragraph><p>As regras remotas permitem uma aplicação mais rigorosa dos limites das tentativas de logon, em comparação com as tentativas provenientes de uma rede local como um escritório.</p></div></div></div><div class=sect3><h4 id=_configuração_do_cliente_no_blacklistd>30.6.3. Configuração do cliente no Blacklistd<a class=anchor href=#_configuração_do_cliente_no_blacklistd></a></h4><div class=paragraph><p>Existem alguns pacotes de software no FreeBSD que podem utilizar a funcionalidade do blacklistd. Os dois mais proeminentes são <a href="https://man.freebsd.org/cgi/man.cgi?query=ftpd&amp;sektion=8&amp;format=html">ftpd(8)</a> e <a href="https://man.freebsd.org/cgi/man.cgi?query=sshd&amp;sektion=8&amp;format=html">sshd(8)</a> para bloquear tentativas excessivas de conexão. Para ativar o blacklistd no daemon SSH, adicione a seguinte linha ao <span class=filename>/etc/ssh/sshd_config</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>UseBlacklist yes</pre></div></div><div class=paragraph><p>Reinicie o sshd posteriormente para que essas alterações entrem em vigor.</p></div><div class=paragraph><p>A lista negra do <a href="https://man.freebsd.org/cgi/man.cgi?query=ftpd&amp;sektion=8&amp;format=html">ftpd(8)</a> é ativada usando <code>-B</code>, em <span class=filename>/etc/inetd.conf</span> ou como uma flag no <span class=filename>/etc/rc.conf</span> assim:</p></div><div class="literalblock programlisting"><div class=content><pre>ftpd_flags=&#34;-B&#34;</pre></div></div><div class=paragraph><p>Isso é tudo o que é necessário para que esses programas conversem com o blacklistd.</p></div></div><div class=sect3><h4 id=_gerenciamento_do_blacklistd>30.6.4. Gerenciamento do Blacklistd<a class=anchor href=#_gerenciamento_do_blacklistd></a></h4><div class=paragraph><p>O Blacklistd fornece ao usuário um utilitário de gerenciamento chamado <a href="https://man.freebsd.org/cgi/man.cgi?query=blacklistctl&amp;sektion=8&amp;format=html">blacklistctl(8)</a>. Ele exibe endereços e redes bloqueados que estão na lista negra pelas regras definidas em <a href="https://man.freebsd.org/cgi/man.cgi?query=blacklistd.conf&amp;sektion=5&amp;format=html">blacklistd.conf(5)</a>. Para ver a lista de hosts atualmente bloqueados, use <code>dump</code> combinado com <code>-b</code> assim.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># blacklistctl dump -b</span>
      address/ma:port <span class=nb>id      </span>nfail   last access
213.0.123.128/25:22   OK      6/3     2019/06/08 14:30:19</code></pre></div></div><div class=paragraph><p>Este exemplo mostra que houve 6 de três tentativas permitidas na porta 22 provenientes do intervalo de endereços <code>213.0.123.128/25</code>. Há mais tentativas listadas do que são permitidas porque o SSH permite que um cliente tente vários logins em uma única conexão TCP. Uma conexão que está em andamento no momento não é interrompida pelo blacklistd. A última tentativa de conexão está listada na coluna <code>last access</code> da saída.</p></div><div class=paragraph><p>Para ver o tempo restante em que esse host estará na lista negra, adicione <code>-r</code> ao comando anterior.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># blacklistctl dump -br</span>
      address/ma:port <span class=nb>id      </span>nfail   remaining <span class=nb>time
</span>213.0.123.128/25:22   OK      6/3     36s</code></pre></div></div><div class=paragraph><p>Neste exemplo, restam 36 segundos para que este host não seja mais bloqueado.</p></div></div><div class=sect3><h4 id=_removendo_hosts_da_lista_de_bloqueios>30.6.5. Removendo hosts da lista de bloqueios<a class=anchor href=#_removendo_hosts_da_lista_de_bloqueios></a></h4><div class=paragraph><p>Às vezes, é necessário remover um host da lista de bloqueios antes que o tempo restante expire. Infelizmente, não há funcionalidade no blacklistd para fazer isso. No entanto, é possível remover o endereço da tabela PF usando pfctl. Para cada porta bloqueada, existe uma âncora filha dentro da âncora do blacklistd definida em <span class=filename>/etc/pf.conf</span>. Por exemplo, se houver uma âncora filha para bloquear a porta 22, ela será chamada <code>blacklistd/22</code>. Há uma tabela dentro dessa âncora filha que contém os endereços bloqueados. Essa tabela é chamada de port seguida pelo número da porta. Neste exemplo, ele seria chamada de <code>port22</code>. Com essas informações em mãos, agora é possível usar o <a href="https://man.freebsd.org/cgi/man.cgi?query=pfctl&amp;sektion=8&amp;format=html">pfctl(8)</a> para exibir todos os endereços listados desta maneira:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pfctl -a blacklistd/22 -t port22 -T show</span>
...
213.0.123.128/25
...</code></pre></div></div><div class=paragraph><p>Depois de identificar o endereço a ser desbloqueado da lista, o seguinte comando o remove da lista:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pfctl -a blacklistd/22 -t port22 -T delete 213.0.123.128/25</span></code></pre></div></div><div class=paragraph><p>O endereço agora foi removido do PF, mas ainda será exibido no blacklistctl, pois ele não conhece nenhuma alteração feita no PF. A entrada no banco de dados do blacklistd expirará e será removida de sua saída eventualmente. A entrada será adicionada novamente se o host estiver correspondendo a uma das regras de bloqueio no blacklistd novamente.</p></div></div></div></div></div><div class=sect1><h2 id=advanced-networking>Capítulo 31. Rede Avançada<a class=anchor href=#advanced-networking></a></h2><div class=sectionbody><div class=sect2><h3 id=advanced-networking-synopsis>31.1. Sinopse<a class=anchor href=#advanced-networking-synopsis></a></h3><div class=paragraph><p>Este capítulo aborda vários tópicos avançados de rede.</p></div><div class=paragraph><p>Depois de ler este capítulo, você saberá:</p></div><div class=ulist><ul><li><p>O básico de gateways e rotas.</p></li><li><p>Como configurar o USB tethering.</p></li><li><p>Como configurar os dispositivos IEEE™ 802.11 e Bluetooth™.</p></li><li><p>Como fazer o FreeBSD atuar como uma Bridge.</p></li><li><p>Como configurar a inicialização via PXE na rede.</p></li><li><p>Como configurar o IPv6 em uma máquina FreeBSD.</p></li><li><p>Como habilitar e utilizar os recursos do Protocolo CARP (Common Address Redundancy Protocol) no FreeBSD.</p></li><li><p>Como configurar múltiplas VLANs no FreeBSD.</p></li><li><p>Como configurar um fone de ouvido bluetooth.</p></li></ul></div><div class=paragraph><p>Antes de ler este capítulo, você deve:</p></div><div class=ulist><ul><li><p>Entender os fundamentos dos scripts <span class=filename>/etc/rc</span>.</p></li><li><p>Estar familiarizado com a terminologia básica de rede.</p></li><li><p>Saber como configurar e instalar um novo kernel do FreeBSD (<a href=./#kernelconfig>Configurando o kernel do FreeBSD</a>).</p></li><li><p>Saber como instalar software adicional de terceiros (<a href=./#ports>Instalando Aplicativos. Pacotes e Ports</a>).</p></li></ul></div></div><div class=sect2><h3 id=network-routing>31.2. Gateways e Rotas<a class=anchor href=#network-routing></a></h3><div class=paragraph><p>O <em>roteamento</em> é o mecanismo que permite que um sistema encontre o caminho da rede para outro sistema. Uma <em>rota</em> é um par definido de endereços que representam o "destino" e um "gateway". A rota indica que, ao tentar chegar ao destino especificado, você deverá enviar os pacotes pelo gateway especificado. Existem três tipos de destinos: hosts individuais, sub-redes e "padrão". A "rota padrão" é usada se nenhuma outra rota for aplicada. Existem também três tipos de gateways: hosts individuais, interfaces, também chamados de links, e endereços de hardware Ethernet (MAC). Rotas conhecidas são armazenadas em uma tabela de roteamento.</p></div><div class=paragraph><p>Esta seção fornece uma visão geral dos fundamentos de roteamento. Em seguida, ele demonstra como configurar um sistema FreeBSD como um roteador e oferece algumas dicas de solução de problemas.</p></div><div class=sect3><h4 id=network-routing-default>31.2.1. Fundamentos de roteamento<a class=anchor href=#network-routing-default></a></h4><div class=paragraph><p>Para ver a tabela de roteamento de um sistema FreeBSD, use <a href="https://man.freebsd.org/cgi/man.cgi?query=netstat&amp;sektion=1&amp;format=html">netstat(1)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% netstat <span class=nt>-r</span>
Routing tables

Internet:
Destination      Gateway            Flags     Refs     Use     Netif Expire
default          outside-gw         UGS        37      418       em0
localhost        localhost          UH          0      181       lo0
test0            0:e0:b5:36:cf:4f   UHLW        5    63288       re0     77
10.20.30.255     <span class=nb>link</span><span class=c>#1             UHLW        1     2421</span>
example.com      <span class=nb>link</span><span class=c>#1             UC          0        0</span>
host1            0:e0:a8:37:8:1e    UHLW        3     4601       lo0
host2            0:e0:a8:37:8:1e    UHLW        0        5       lo0 <span class=o>=&gt;</span>
host2.example.com <span class=nb>link</span><span class=c>#1            UC          0        0</span>
224              <span class=nb>link</span><span class=c>#1             UC          0        0</span></code></pre></div></div><div class=paragraph><p>As entradas neste exemplo são as seguintes:</p></div><div class=dlist><dl><dt class=hdlist1>padrão</dt><dd><p>A primeira rota nesta tabela especifica a rota <code>padrão</code>. Quando o sistema local precisa estabelecer uma conexão com um host remoto, ele verifica a tabela de roteamento para determinar se existe um caminho conhecido. Se o host remoto corresponder a uma entrada na tabela, o sistema verificará se pode se conectar usando a interface especificada nessa entrada.</p><div class=paragraph><p>Se o destino não corresponder a uma entrada ou se todos os caminhos conhecidos falharem, o sistema usará a entrada para a rota padrão. Para hosts em uma rede local, o campo <code>Gateway</code> na rota padrão é definido para o sistema que possui uma conexão direta com a internet. Ao ler esta entrada, verifique se a coluna <code>Flags</code> indica que o gateway é utilizável (<code>UG</code>).</p></div><div class=paragraph><p>A rota padrão para uma máquina que está funcionando como gateway para o mundo externo será a máquina de gateway no provedor de serviços de Internet (ISP).</p></div></dd><dt class=hdlist1>localhost</dt><dd><p>A segunda rota é a <code>localhost</code>. A interface especificada na coluna <code>Netif</code> para <code>localhost</code> é <span class=filename>lo0</span>, também conhecido como o dispositivo de loopback. Isso indica que todo o tráfego para esse destino deve ser interno, em vez de enviá-lo pela rede.</p></dd><dt class=hdlist1>Endereço MAC</dt><dd><p>Os endereços que começam com <code>0:e0:</code> são endereços de MAC. O FreeBSD irá identificar automaticamente quaisquer hosts, <code>test0</code> no exemplo, na Ethernet local e adicionará uma rota para aquele host através da interface Ethernet, <span class=filename>re0</span>. Esse tipo de rota tem um tempo limite, visto na coluna <code>Expire</code>, que é usada se o host não responder em um período de tempo específico. Quando isso acontecer, a rota para esse host será automaticamente excluída. Esses hosts são identificados usando o protocolo de informações de roteamento (RIP), que calcula rotas para hosts locais com base em uma determinação de caminho mais curto.</p></dd><dt class=hdlist1>sub-rede</dt><dd><p>O FreeBSD irá adicionar automaticamente rotas de sub-rede para a sub-rede local. Neste exemplo, <code>10.20.30.255</code> é o endereço de broadcast da sub-rede <code>10.20.30</code> e <code>example.com</code> é o nome de domínio associado a essa sub-rede. A designação <code>link#1</code> refere-se à primeira placa Ethernet na máquina.</p><div class=paragraph><p>Hosts de rede local e sub-redes locais têm suas rotas configuradas automaticamente por um daemon chamado <a href="https://man.freebsd.org/cgi/man.cgi?query=routed&amp;sektion=8&amp;format=html">routed(8)</a>. Se ele não estiver em execução, somente as rotas definidas estaticamente pelo administrador existirão.</p></div></dd><dt class=hdlist1>host</dt><dd><p>A linha <code>host1</code> refere-se ao host pelo seu endereço Ethernet. Como é o host de envio, o FreeBSD sabe usar a interface de loopback (<span class=filename>lo0</span>) em vez da interface Ethernet.</p><div class=paragraph><p>As duas linhas <code>host2</code> representam os aliases que foram criados usando <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a>. O símbolo <code>⇒</code> após a interface <span class=filename>lo0</span> diz que um alias foi definido além do endereço de loopback. Tais rotas só aparecem no host que suporta o alias e todos os outros hosts na rede local terão uma linha <code>link#1</code> para tais rotas.</p></div></dd><dt class=hdlist1>224</dt><dd><p>A linha final (destino subnet <code>224</code>) lida com multicasting.</p></dd></dl></div><div class=paragraph><p>Vários atributos de cada rota podem ser vistos na coluna <code>Flags</code>. A <a href=#routeflags>Flags da Tabela de Roteamento Frequentemente Observados</a> resume algumas destas flags e seus significados:</p></div><table id=routeflags class="tableblock frame-none grid-all stretch"><caption class=title>Tabela 28. Flags da Tabela de Roteamento Frequentemente Observados</caption><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Comando</th><th class="tableblock halign-left valign-top">Propósito</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>U</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>A rota está ativa (up).</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>H</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>O destino da rota é um único host.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>G</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Envie qualquer coisa para este destino por este gateway, que ele irá descobrir a partir daí para onde enviá-lo.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>S</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Esta rota foi configurada estaticamente.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>C</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Clona uma nova rota baseada nessa rota para as máquinas se conectarem. Esse tipo de rota é normalmente usado para redes locais.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>W</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>A rota foi configurada automaticamente com base em uma rota de rede local (clone).</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>L</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>A rota envolve referências a um hardware Ethernet (link).</p></td></tr></tbody></table><div class=paragraph><p>Em um sistema FreeBSD, a rota padrão pode ser definida no <span class=filename>/etc/rc.conf</span> especificando o endereço IP do gateway padrão:</p></div><div class="literalblock programlisting"><div class=content><pre>defaultrouter=&#34;10.20.30.1&#34;</pre></div></div><div class=paragraph><p>Também é possível adicionar manualmente a rota usando o comando <code>route</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># route add default 10.20.30.1</span></code></pre></div></div><div class=paragraph><p>Observe que as rotas adicionadas manualmente não sobreviverão a uma reinicialização. Para obter mais informações sobre a manipulação manual das tabelas de roteamento de rede, consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=route&amp;sektion=8&amp;format=html">route(8)</a>.</p></div></div><div class=sect3><h4 id=network-static-routes>31.2.2. Configurando um roteador com rotas estáticas<a class=anchor href=#network-static-routes></a></h4><div class=paragraph><p>Um sistema FreeBSD pode ser configurado como o gateway padrão, ou roteador, para uma rede se for um sistema dual-homed. Um sistema dual-homed é um host que reside em pelo menos duas redes diferentes. Normalmente, cada rede é conectada a uma interface de rede separada, embora o aliasing IP possa ser usado para vincular vários endereços, cada um em uma sub-rede diferente, a uma interface física.</p></div><div class=paragraph><p>Para que o sistema encaminhe os pacotes entre as interfaces, o FreeBSD deve ser configurado como um roteador. Padrões da Internet e boas práticas de engenharia impedem o Projeto FreeBSD de habilitar esse recurso por padrão, mas ele pode ser configurado para iniciar na inicialização adicionando esta linha ao <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>gateway_enable=&#34;YES&#34;          # Set to YES if this host will be a gateway</pre></div></div><div class=paragraph><p>Para habilitar o roteamento agora, defina a variável <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a><code>net.inet.ip.forwarding</code> para <code>1</code>. Para parar o roteamento, redefina essa variável para <code>0</code>.</p></div><div class=paragraph><p>A tabela de roteamento de um roteador precisa de rotas adicionais para saber como acessar outras redes. Rotas podem ser adicionadas manualmente usando rotas estáticas ou rotas podem ser aprendidas automaticamente usando um protocolo de roteamento. As rotas estáticas são apropriadas para redes pequenas e esta seção descreve como adicionar uma entrada de roteamento estático para uma rede pequena.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Para grandes redes, as rotas estáticas se tornam não escaláveis rapidamente. O FreeBSD vem com o daemon de roteamento BSD padrão <a href="https://man.freebsd.org/cgi/man.cgi?query=routed&amp;sektion=8&amp;format=html">routed(8)</a>, que fornece os protocolos de roteamento RIP, versões 1 e 2 e IRDP. O suporte para os protocolos de roteamento BGP e OSPF pode ser instalado usando o pacote ou port <a class=package href=https://cgit.freebsd.org/ports/tree/net/zebra/>net/zebra</a>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Considere a seguinte rede:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/advanced-networking/static-routes.png alt="static routes"></div></div><div class=paragraph><p>Neste cenário, o <code>RouterA</code> é uma máquina FreeBSD que está agindo como um roteador para o resto da Internet. Ele tem uma rota padrão definida como <code>10.0.0.1</code>, que permite a conexão com o mundo externo. O <code>RouterB</code> já está configurado para usar <code>192.168.1.1</code> como seu gateway padrão.</p></div><div class=paragraph><p>Antes de adicionar rotas estáticas, a tabela de roteamento no <code>RouterA</code> se parece com:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% netstat <span class=nt>-nr</span>
Routing tables

Internet:
Destination        Gateway            Flags    Refs      Use  Netif  Expire
default            10.0.0.1           UGS         0    49378    xl0
127.0.0.1          127.0.0.1          UH          0        6    lo0
10.0.0.0/24        <span class=nb>link</span><span class=c>#1             UC          0        0    xl0</span>
192.168.1.0/24     <span class=nb>link</span><span class=c>#2             UC          0        0    xl1</span></code></pre></div></div><div class=paragraph><p>Com a tabela de roteamento atual, o <code>RouterA</code> não tem uma rota para a rede <code>192.168.2.0/24</code>. O comando a seguir adiciona a rede <code>Internal Net 2</code> à tabela de roteamento do <code>RouterA</code> usando <code>192.168.1.2</code> como o próximo salto:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># route add -net 192.168.2.0/24 192.168.1.2</span></code></pre></div></div><div class=paragraph><p>Agora, o <code>RouterA</code> pode alcançar qualquer host na rede <code>192.168.2.0/24</code>. No entanto, as informações de roteamento não persistirão se o sistema FreeBSD for reinicializado. Se uma rota estática precisar ser persistente, adicione-a ao <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre># Add Internal Net 2 as a persistent static route
static_routes=&#34;internalnet2&#34;
route_internalnet2=&#34;-net 192.168.2.0/24 192.168.1.2&#34;</pre></div></div><div class=paragraph><p>A variável de configuração <code>static_routes</code> é uma lista de strings separadas por um espaço, onde cada string faz referência a um nome de rota. A variável <code>route_internalnet2</code> contém a rota estática para esse nome de rota.</p></div><div class=paragraph><p>Usar mais de uma string em <code>static_routes</code> cria várias rotas estáticas. A seguir, é mostrado um exemplo de adição de rotas estáticas para as redes <code>192.168.0.0/24</code> e <code>192.168.1.0/24</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>static_routes=&#34;net1 net2&#34;
route_net1=&#34;-net 192.168.0.0/24 192.168.0.1&#34;
route_net2=&#34;-net 192.168.1.0/24 192.168.1.1&#34;</pre></div></div></div><div class=sect3><h4 id=network-routing-troubleshooting>31.2.3. Solução de problemas<a class=anchor href=#network-routing-troubleshooting></a></h4><div class=paragraph><p>Quando um espaço de endereçamento é atribuído a uma rede, o provedor de serviços configura suas tabelas de roteamento para que todo o tráfego da rede seja enviado para o link do site. Mas como os sites externos sabem enviar seus pacotes para a rede do ISP?</p></div><div class=paragraph><p>Existe um sistema que rastreia todos os espaços de endereçamento e define seu ponto de conexão com o backbone da Internet, ou as principais linhas que transportam o tráfego da Internet pelo país e pelo mundo. Cada máquina de backbone possui uma cópia de um conjunto mestre de tabelas, que direciona o tráfego de uma rede específica para uma portadora de backbone específica e, a partir daí, desce a cadeia de provedores de serviços até alcançar uma determinada rede.</p></div><div class=paragraph><p>É tarefa do provedor de serviços anunciar aos sites de backbone que eles são o ponto de conexão e, assim, o caminho para dentro de um site. Isso é conhecido como propagação de rota.</p></div><div class=paragraph><p>Às vezes, há um problema com a propagação de rotas e alguns sites não conseguem se conectar. Talvez o comando mais útil para tentar descobrir onde o roteamento está quebrando seja o <code>traceroute</code>. Ele é útil quando o <code>ping</code> falha.</p></div><div class=paragraph><p>Ao usar o <code>traceroute</code>, inclua o endereço do host remoto para se conectar. A saída mostrará os gateway ao longo do caminho da tentativa, eventualmente atingindo o host de destino ou encerrando devido à falta de conexão. Para mais informações, consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=traceroute&amp;sektion=8&amp;format=html">traceroute(8)</a>.</p></div></div><div class=sect3><h4 id=network-routing-multicast>31.2.4. Considerações sobre Multicast<a class=anchor href=#network-routing-multicast></a></h4><div class=paragraph><p>O FreeBSD suporta nativamente tanto aplicativos multicast e quanto roteamento multicast. Os aplicativos multicast não exigem nenhuma configuração especial para serem executados no FreeBSD. O suporte ao roteamento multicast requer que a seguinte opção seja compilada em um kernel personalizado:</p></div><div class="literalblock programlisting"><div class=content><pre>options MROUTING</pre></div></div><div class=paragraph><p>O daemon de roteamento multicast, mrouted, pode ser instalado usando o pacote ou port <a class=package href=https://cgit.freebsd.org/ports/tree/net/mrouted/>net/mrouted</a>. Este daemon implementa o protocolo de roteamento multicast DVMRP e é configurado editando o <span class=filename>/usr/local/etc/mrouted.conf</span> para configurar os túneis e o DVMRP. A instalação do mrouted também instala o map-mbone e o mrinfo, bem como suas páginas de manual associadas. Consulte estes documentos para exemplos de configuração.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>O DVMRP foi amplamente substituído pelo protocolo PIM em muitas instalações multicast. Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=pim&amp;sektion=4&amp;format=html">pim(4)</a> para obter maiores informações.</p></div></td></tr></tbody></table></div></div></div><div class=sect2><h3 id=network-wireless>31.3. Rede sem fio<a class=anchor href=#network-wireless></a></h3><div class=sect3><h4 id=_noções_básicas_sobre_redes_sem_fio>31.3.1. Noções básicas sobre redes sem fio<a class=anchor href=#_noções_básicas_sobre_redes_sem_fio></a></h4><div class=paragraph><p>A maioria das redes sem fio é baseada nos padrões IEEE™802.11. Uma rede sem fio básica consiste em várias estações que se comunicam com rádios que transmitem na banda de 2,4 GHz ou 5 GHz, embora isso varie de acordo com a localidade e também esteja mudando para permitir a comunicação nas faixas de 2,3 GHz e 4,9 GHz.</p></div><div class=paragraph><p>As redes 802.11 são organizadas de duas maneiras. No <em>modo de infra-estrutura</em>, uma estação atua como mestre para todas as outras estações que se associam a ela, a rede é conhecida como BSS e a estação mestre é denominada ponto de acesso. (AP). Em um BSS, toda a comunicação passa pelo AP; mesmo quando uma estação deseja se comunicar com outra estação sem fio, as mensagens devem passar pelo AP. Na segunda forma de rede, não há mestre e as estações se comunicam diretamente. Esta forma de rede é denominada IBSS e é comumente conhecida como uma <em>rede ad-hoc</em>.</p></div><div class=paragraph><p>As redes 802.11 foram implantadas pela primeira vez na banda de 2,4 GHz usando protocolos definidos pelo padrão 802.11 e 802.11b da IEEE™. Essas especificações incluem as frequências operacionais e as características da camada MAC, incluindo as taxas de enquadramento e transmissão, pois a comunicação pode ocorrer em várias taxas. Posteriormente, o padrão 802.11a definiu a operação na faixa de 5GHz, incluindo diferentes mecanismos de sinalização e taxas de transmissão mais altas. Mais tarde, o padrão 802.11g definiu o uso de mecanismos de sinalização e transmissão 802.11a na banda de 2,4 GHz de modo a ser compatível com redes 802.11b.</p></div><div class=paragraph><p>Separadas das técnicas de transmissão básicas, as redes 802.11 possuem uma variedade de mecanismos de segurança. As especificações originais do 802.11 definiam um protocolo de segurança simples chamado WEP. Este protocolo usa uma chave pré-compartilhada fixa e a criptografia criptográfica RC4 para codificar dados transmitidos em uma rede. Todas as estações devem concordar com a chave fixa para se comunicar. Esse esquema mostrou-se de fácil quebra e agora raramente é usado, exceto para desencorajar usuários transitórios a se juntarem a uma rede. A prática atual de segurança é dada pela especificação 802.11i do IEEE™ que define novas cifras criptográficas e um protocolo adicional para autenticar estações para um ponto de acesso e para trocar chaves para comunicação de dados. As chaves criptográficas são atualizadas periodicamente e existem mecanismos para detectar e combater tentativas de invasão. Outra especificação de protocolo de segurança comumente usada em redes sem fio é denominada WPA, que foi um precursor do 802.11i. O WPA especifica um subconjunto dos requisitos encontrados no 802.11i e foi projetado para implementação em hardware legado. Especificamente, o WPA requer apenas a codificação TKIP derivada da codificação original WEP. O 802.11i permite o uso do TKIP, mas também requer suporte para uma criptografia mais forte, o AES-CCM, para criptografar os dados. A codificação AES não era exigida no WPA porque foi considerada demasiadamente cara computacionalmente para ser executada em hardware legado.</p></div><div class=paragraph><p>Um outro padrão a se ter em conta é o 802.11e. Ele define protocolos para a implantação de aplicativos multimídia, como streaming de vídeo e voz sobre IP (VoIP), em uma rede 802.11. Como o 802.11i, o 802.11e também tem uma especificação de precursor denominada WME (posteriormente renomeada como WMM) que foi definida por um grupo industrial como um subconjunto do 802.11e que pode ser implantado agora para habilitar aplicativos multimídia enquanto aguarda a ratificação final do 802.11e. O mais importante a saber sobre o 802.11e e o WME/WMM é que ele permite o tráfego prioritário através de uma rede sem fio através de protocolos de Qualidade de Serviço (QoS) e protocolos de acesso de mídia aprimorados. A implementação adequada desses protocolos permite o aumento rápido de dados e o fluxo de tráfego priorizado.</p></div><div class=paragraph><p>O FreeBSD suporta redes que operam usando 802.11a, 802.11b e 802.11g. Os protocolos de segurança WPA e 802.11i também são suportados (em conjunto com qualquer um dos 11a, 11b e 11g) e o QoS e priorização de tráfego exigidos pelo protocolo WME/WMM são suportados por um conjunto limitado de dispositivos sem fio.</p></div></div><div class=sect3><h4 id=network-wireless-quick-start>31.3.2. Inicio Rápido<a class=anchor href=#network-wireless-quick-start></a></h4><div class=paragraph><p>Conectar um computador a uma rede sem fio existente é uma situação muito comum. Este procedimento mostra as etapas necessárias.</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Obtenha o SSID (identificador de conjunto de serviços) e PSK (chave pré-compartilhada) para a rede sem fio do administrador da rede.</p></li><li><p>Identifique o adaptador sem fio. O kernel <span class=filename>GENERIC</span> do FreeBSD inclui drivers para muitos adaptadores sem fio comuns. Se o adaptador sem fio for um desses modelos, ele será mostrado na saída do <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a>:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ifconfig | <span class=nb>grep</span> <span class=nt>-B3</span> <span class=nt>-i</span> wireless</code></pre></div></div><div class=paragraph><p>No FreeBSD 11 ou superior, use este comando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% sysctl net.wlan.devices</code></pre></div></div><div class=paragraph><p>Se um adaptador sem fio não estiver listado, um módulo adicional do kernel pode ser necessário, ou pode ser um modelo não suportado pelo FreeBSD.</p></div><div class=paragraph><p>Este exemplo mostra o adaptador wireless Atheros <code>ath0</code>.</p></div></li><li><p>Adicione uma entrada para esta rede ao <span class=filename>/etc/wpa_supplicant.conf</span>. Se o arquivo não existir, crie-o. Substitua <em>myssid</em> e <em>mypsk</em> pelo SSID e PSK fornecidos pelo administrador da rede.</p><div class="literalblock programlisting"><div class=content><pre>network={
	ssid=&#34;myssid&#34;
	psk=&#34;mypsk&#34;
}</pre></div></div></li><li><p>Adicione entradas ao <span class=filename>/etc/rc.conf</span> para configurar a rede na inicialização:</p><div class="literalblock programlisting"><div class=content><pre>wlans_ath0=&#34;wlan0&#34;
ifconfig_wlan0=&#34;WPA SYNCDHCP&#34;</pre></div></div></li><li><p>Reinicie o computador ou reinicie o serviço de rede para conectar-se à rede:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service netif restart</span></code></pre></div></div></li></ol></div></div></div></div><div class=sect3><h4 id=network-wireless-basic>31.3.3. Configuração básica<a class=anchor href=#network-wireless-basic></a></h4><div class=sect4><h5 id=_configuração_do_kernel_2>31.3.3.1. Configuração do Kernel<a class=anchor href=#_configuração_do_kernel_2></a></h5><div class=paragraph><p>Para usar a rede sem fio, uma placa de rede sem fio é necessária e o kernel precisa ser configurado com o suporte de rede sem fio apropriado. O kernel é separado em vários módulos para que apenas o suporte necessário precise ser configurado.</p></div><div class=paragraph><p>Os dispositivos sem fio mais comumente usados são aqueles que usam peças fabricadas pela Atheros. Estes dispositivos são suportados pelo <a href="https://man.freebsd.org/cgi/man.cgi?query=ath&amp;sektion=4&amp;format=html">ath(4)</a> e requerem que a seguinte linha seja adicionada ao <span class=filename>/boot/loader.conf</span> :</p></div><div class="literalblock programlisting"><div class=content><pre>if_ath_load=&#34;YES&#34;</pre></div></div><div class=paragraph><p>O driver Atheros é dividido em três partes separadas: o driver (<a href="https://man.freebsd.org/cgi/man.cgi?query=ath&amp;sektion=4&amp;format=html">ath(4)</a>), a camada de suporte de hardware que lida com funções específicas do chip (<a href="https://man.freebsd.org/cgi/man.cgi?query=ath_hal&amp;sektion=4&amp;format=html">ath_hal(4)</a>) e um algoritmo para selecionar a taxa de transmissão de quadros. Quando este suporte é carregado como módulo do kernel, quaisquer dependências são tratadas automaticamente. Para carregar o suporte para um tipo diferente de dispositivo sem fio, especifique o módulo para esse dispositivo. Este exemplo é para dispositivos baseados no driver Intersil Prism parts (<a href="https://man.freebsd.org/cgi/man.cgi?query=wi&amp;sektion=4&amp;format=html">wi(4)</a>):</p></div><div class="literalblock programlisting"><div class=content><pre>if_wi_load=&#34;YES&#34;</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Os exemplos nesta seção usam um dispositivo<a href="https://man.freebsd.org/cgi/man.cgi?query=ath&amp;sektion=4&amp;format=html">ath(4)</a> e o nome do dispositivo nos exemplos deve ser alterado de acordo com a configuração. Uma lista de drivers sem fio disponíveis e adaptadores suportados pode ser encontrada nas Notas de Hardware do FreeBSD, disponíveis nas <a href=https://www.FreeBSD.org/releases/>Informações de Release</a> da página do site do FreeBSD. Se um driver nativo do FreeBSD para o dispositivo sem fio não existir, pode ser possível usar o driver Windows™ com a ajuda do wrapper de driver <a href=./#config-network-ndis>NDIS</a>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Além disso, os módulos que implementam o suporte criptográfico para os protocolos de segurança devem ser carregados. Estes destinam-se a ser dinamicamente carregados sob demanda pelo módulo <a href="https://man.freebsd.org/cgi/man.cgi?query=wlan&amp;sektion=4&amp;format=html">wlan(4)</a>, mas por enquanto eles devem ser configurados manualmente. Os seguintes módulos estão disponíveis: <a href="https://man.freebsd.org/cgi/man.cgi?query=wlan_wep&amp;sektion=4&amp;format=html">wlan_wep(4)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=wlan_ccmp&amp;sektion=4&amp;format=html">wlan_ccmp(4)</a>, e <a href="https://man.freebsd.org/cgi/man.cgi?query=wlan_tkip&amp;sektion=4&amp;format=html">wlan_tkip(4)</a>. Os drivers <a href="https://man.freebsd.org/cgi/man.cgi?query=wlan_ccmp&amp;sektion=4&amp;format=html">wlan_ccmp(4)</a> e <a href="https://man.freebsd.org/cgi/man.cgi?query=wlan_tkip&amp;sektion=4&amp;format=html">wlan_tkip(4)</a> são necessário apenas ao usar os protocolos de segurança WPA ou 802.11i. Se a rede não usar criptografia, o suporte a <a href="https://man.freebsd.org/cgi/man.cgi?query=wlan_wep&amp;sektion=4&amp;format=html">wlan_wep(4)</a> não será necessário. Para carregar estes módulos no momento da inicialização, adicione as seguintes linhas ao <span class=filename>/boot/loader.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>wlan_wep_load=&#34;YES&#34;
wlan_ccmp_load=&#34;YES&#34;
wlan_tkip_load=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Uma vez que esta informação tenha sido adicionada ao <span class=filename>/boot/loader.conf</span>, reinicie a caixa FreeBSD. Como alternativa, carregue os módulos manualmente usando <a href="https://man.freebsd.org/cgi/man.cgi?query=kldload&amp;sektion=8&amp;format=html">kldload(8)</a>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Para usuários que não querem usar módulos, é possível compilar esses drivers no kernel adicionando as seguintes linhas a um arquivo de configuração de kernel personalizado:</p></div><div class="literalblock programlisting"><div class=content><pre>device wlan              # 802.11 support
device wlan_wep          # 802.11 WEP support
device wlan_ccmp         # 802.11 CCMP support
device wlan_tkip         # 802.11 TKIP support
device wlan_amrr         # AMRR transmit rate control algorithm
device ath               # Atheros pci/cardbus NIC&#39;s
device ath_hal           # pci/cardbus chip support
options AH_SUPPORT_AR5416 # enable AR5416 tx/rx descriptors
device ath_rate_sample   # SampleRate tx rate control for ath</pre></div></div><div class=paragraph><p>Com esta informação no arquivo de configuração do kernel, recompile o kernel e reinicie a máquina do FreeBSD.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Informações sobre o dispositivo sem fio devem aparecer nas mensagens de inicialização, assim:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>ath0: &lt;Atheros 5212&gt; mem 0x88000000-0x8800ffff irq 11 at device 0.0 on cardbus1
ath0: <span class=o>[</span>ITHREAD]
ath0: AR2413 mac 7.9 RF2413 phy 4.5</code></pre></div></div></div><div class=sect4><h5 id=_definindo_a_região_correta>31.3.3.2. Definindo a Região Correta<a class=anchor href=#_definindo_a_região_correta></a></h5><div class=paragraph><p>Como a situação regulatória é diferente em várias partes do mundo, é necessário definir corretamente os domínios que se aplicam à sua localização para obter as informações corretas sobre quais canais podem ser usados.</p></div><div class=paragraph><p>As definições de região disponíveis podem ser encontradas em <span class=filename>/etc/regdomain.xml</span>. Para definir os dados em tempo de execução, use o <code>ifconfig</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0 regdomain ETSI country AT</span></code></pre></div></div><div class=paragraph><p>Para persistir as configurações, adicione-o ao <span class=filename>/etc/rc.conf</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysrc create_args_wlan0=&#34;country AT regdomain ETSI&#34;</span></code></pre></div></div></div></div><div class=sect3><h4 id=_modo_de_infraestrutura>31.3.4. Modo de Infraestrutura<a class=anchor href=#_modo_de_infraestrutura></a></h4><div class=paragraph><p>O modo de infra-estrutura (BSS) é o modo normalmente usado. Neste modo, vários pontos de acesso sem fio são conectados a uma rede com fio. Cada rede sem fio tem seu próprio nome, chamado de SSID. Os clientes sem fio se conectam aos pontos de acesso sem fio.</p></div><div class=sect4><h5 id=_clientes_do_freebsd>31.3.4.1. Clientes do FreeBSD<a class=anchor href=#_clientes_do_freebsd></a></h5><div class=sect5><h6 id=_como_encontrar_pontos_de_acesso>31.3.4.1.1. Como encontrar pontos de acesso<a class=anchor href=#_como_encontrar_pontos_de_acesso></a></h6><div class=paragraph><p>Para procurar redes disponíveis, use <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a>. Essa solicitação pode demorar alguns instantes para ser concluída, pois exige que o sistema alterne para cada frequência sem fio disponível e sonde os pontos de acesso disponíveis. Apenas o superusuário pode iniciar uma varredura:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0 create wlandev ath0</span>
<span class=c># ifconfig wlan0 up scan</span>
SSID/MESH ID    BSSID              CHAN RATE   S:N     INT CAPS
dlinkap         00:13:46:49:41:76   11   54M <span class=nt>-90</span>:96   100 EPS  WPA WME
freebsdap       00:11:95:c3:0d:ac    1   54M <span class=nt>-83</span>:96   100 EPS  WPA</code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>A interface deve estar <code>up</code> antes de poder efetuar a busca. Pedidos de varredura subsequentes não exigem que a interface seja marcada como up novamente.</p></div></td></tr></tbody></table></div><div class=paragraph><p>A saída de uma solicitação de varredura lista cada rede BSS/IBSS encontrada. Além de listar o nome da rede, o <code>SSID</code>, a saída também mostra o <code>BSSID</code>, que é o endereço MAC do ponto de acesso. O campo <code>CAPS</code> identifica o tipo de cada rede e os recursos das estações que operam lá:</p></div><table class="tableblock frame-none grid-all stretch"><caption class=title>Tabela 29. Códigos de capacidade da estação</caption><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Código de capacidade</th><th class="tableblock halign-left valign-top">Significado</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>E</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Conjunto de serviços estendidos (ESS). Indica que a estação faz parte de uma rede de infraestrutura em vez de uma rede IBSS/ad-hoc.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>I</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Rede IBSS/ad-hoc. Indica que a estação faz parte de uma rede ad-hoc em vez de uma rede ESS.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>P</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Privacidade. A criptografia é necessária para todos os quadros de dados trocados dentro do BSS usando meios criptográficos como o WEP, o TKIP ou o AES-CCMP.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>S</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Preâmbulo Curto. Indica que a rede está usando preâmbulos curtos, definidos em 802.11b de Alta Taxa/DSSS PHYS, e utiliza um campo de sincronização de 56 bits em vez do campo de 128 bits usado no modo de preâmbulo longo.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>s</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Tempo de slot curto. Indica que a rede 802.11g está usando um tempo de slot curto porque não há estações legadas (802.11b) presentes.</p></td></tr></tbody></table><div class=paragraph><p>Pode-se também exibir a lista atual de redes conhecidas com:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0 list scan</span></code></pre></div></div><div class=paragraph><p>Essas informações podem ser atualizadas automaticamente pelo adaptador ou manualmente com uma solicitação de <code>scan</code>. Dados antigos são automaticamente removidos do cache, então com o tempo essa lista pode diminuir a menos que mais varreduras sejam feitas.</p></div></div><div class=sect5><h6 id=_configurações_básicas>31.3.4.1.2. Configurações básicas<a class=anchor href=#_configurações_básicas></a></h6><div class=paragraph><p>Esta seção fornece um exemplo simples de como fazer com que o adaptador de rede sem fio funcione no FreeBSD sem criptografia. Uma vez familiarizado com esses conceitos, é altamente recomendável usar o <a href=#network-wireless-wpa>WPA</a> para configurar a rede sem fio.</p></div><div class=paragraph><p>Existem três etapas básicas para configurar uma rede sem fio: selecionar um ponto de acesso, autenticar a estação e configurar um endereço IP. As seções a seguir discutem cada etapa.</p></div><div class=sect6><h7 id=_selecionando_um_ponto_de_acesso>31.3.4.1.2.1. Selecionando um ponto de acesso<a class=anchor href=#_selecionando_um_ponto_de_acesso></a></h7><div class=paragraph><p>Na maioria das vezes, é suficiente deixar o sistema escolher um ponto de acesso usando a heurística integrada. Este é o comportamento padrão quando uma interface é marcada como up ou está listada em <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>wlans_ath0=&#34;wlan0&#34;
ifconfig_wlan0=&#34;DHCP&#34;</pre></div></div><div class=paragraph><p>Se houver vários pontos de acesso, um específico pode ser selecionado pelo seu SSID:</p></div><div class="literalblock programlisting"><div class=content><pre>wlans_ath0=&#34;wlan0&#34;
ifconfig_wlan0=&#34;ssid your_ssid_here DHCP&#34;</pre></div></div><div class=paragraph><p>Em um ambiente em que há vários pontos de acesso com o mesmo SSID, o que geralmente é feito para simplificar o roaming, talvez seja necessário associá-lo a um dispositivo específico. Neste caso, o BSSID do ponto de acesso pode ser especificado, com ou sem o SSID:</p></div><div class="literalblock programlisting"><div class=content><pre>wlans_ath0=&#34;wlan0&#34;
ifconfig_wlan0=&#34;ssid your_ssid_here bssid xx:xx:xx:xx:xx:xx DHCP&#34;</pre></div></div><div class=paragraph><p>Existem outras maneiras de restringir a escolha de um ponto de acesso, como limitar o conjunto de freqüências que o sistema fará a varredura. Isso pode ser útil para uma placa sem fio de banda múltipla, pois a varredura de todos os canais possíveis pode consumir muito tempo. Para limitar a operação a uma banda específica, use o parâmetro <code>mode</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>wlans_ath0=&#34;wlan0&#34;
ifconfig_wlan0=&#34;mode 11g ssid your_ssid_here DHCP&#34;</pre></div></div><div class=paragraph><p>Este exemplo forçará a placa a operar em 802.11g, que é definido apenas para freqüências de 2.4GHz, portanto, qualquer canal de 5GHz não será considerado. Isso também pode ser obtido com o parâmetro <code>channel</code>, que bloqueia a operação para uma frequência específica, e o parâmetro <code>chanlist</code>, para especificar uma lista de canais para varredura. Maiores informações sobre esses parâmetros podem ser encontradas em <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a>.</p></div></div><div class=sect6><h7 id=_autenticação_2>31.3.4.1.2.2. Autenticação<a class=anchor href=#_autenticação_2></a></h7><div class=paragraph><p>Quando um ponto de acesso é selecionado, a estação precisa se autenticar antes de poder transmitir dados. A autenticação pode acontecer de várias maneiras. O esquema mais comum, autenticação aberta, permite que qualquer estação entre na rede e se comunique. Essa é a autenticação a ser usada para fins de teste na primeira vez em que uma rede sem fio é configurada. Outros esquemas exigem que os handshakes criptográficos sejam concluídos antes que o tráfego de dados possa fluir, usando chaves ou segredos pré-compartilhados ou esquemas mais complexos que envolvam serviços de back-end, como o RADIUS. Autenticação aberta é a configuração padrão. A próxima configuração mais comum é o WPA-PSK, também conhecido como WPA Pessoal, que é descrito em <a href=#network-wireless-wpa-wpa-psk>WPA-PSK</a>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Se estiver usando uma estação base Extreme AirPort™ da Apple™ para um ponto de acesso, a autenticação de chave compartilhada juntamente com um WEP chave precisa ser configurada. Isto pode ser configurado em <span class=filename>/etc/rc.conf</span> ou usando <a href="https://man.freebsd.org/cgi/man.cgi?query=wpa_supplicant&amp;sektion=8&amp;format=html">wpa_supplicant(8)</a>. Para uma única estação base AirPort™, o acesso pode ser configurado com:</p></div><div class="literalblock programlisting"><div class=content><pre>wlans_ath0=&#34;wlan0&#34;
ifconfig_wlan0=&#34;authmode shared wepmode on weptxkey 1 wepkey 01234567 DHCP&#34;</pre></div></div><div class=paragraph><p>Em geral, a autenticação de chave compartilhada deve ser evitada porque ela usa o material de chave WEP de uma maneira altamente restrita, facilitando ainda mais a quebra da chave. Se o WEP deve ser usado para compatibilidade com dispositivos legados, é melhor usar o WEP com a autenticação <code>open</code>. Mais informações sobre o WEP podem ser encontradas em <a href=#network-wireless-wep>WEP</a>.</p></div></td></tr></tbody></table></div></div><div class=sect6><h7 id=_obtendo_um_endereço_ip_com_dhcp>31.3.4.1.2.3. Obtendo um endereço IP com DHCP<a class=anchor href=#_obtendo_um_endereço_ip_com_dhcp></a></h7><div class=paragraph><p>Quando um ponto de acesso é selecionado e os parâmetros de autenticação são definidos, um endereço IP deve ser obtido para se comunicar. Na maioria das vezes, o endereço IP é obtido através do DHCP. Para isso, edite o <span class=filename>/etc/rc.conf</span> e adicione o <code>DHCP</code> à configuração do dispositivo:</p></div><div class="literalblock programlisting"><div class=content><pre>wlans_ath0=&#34;wlan0&#34;
ifconfig_wlan0=&#34;DHCP&#34;</pre></div></div><div class=paragraph><p>A interface sem fio está agora pronta para subir:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service netif start</span></code></pre></div></div><div class=paragraph><p>Quando a interface estiver rodando, use o <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a> para ver o status da interface <span class=filename>ath0</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0</span>
wlan0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
        ether 00:11:95:d5:43:62
        inet 192.168.1.100 netmask 0xffffff00 broadcast 192.168.1.255
        media: IEEE 802.11 Wireless Ethernet OFDM/54Mbps mode 11g
        status: associated
        ssid dlinkap channel 11 <span class=o>(</span>2462 Mhz 11g<span class=o>)</span> bssid 00:13:46:49:41:76
        country US ecm authmode OPEN privacy OFF txpower 21.5 bmiss 7
        scanvalid 60 bgscan bgscanintvl 300 bgscanidle 250 roam:rssi 7
        roam:rate 5 protmode CTS wme burst</code></pre></div></div><div class=paragraph><p>A linha <code>status: associated</code> significa que está conectada à rede sem fio. O <code>bssid 00:13:46:49:41:76</code> é o endereço MAC do ponto de acesso e o <code>authmode OPEN</code> indica que a comunicação é não criptografada.</p></div></div><div class=sect6><h7 id=_endereço_ip_estático>31.3.4.1.2.4. Endereço IP estático<a class=anchor href=#_endereço_ip_estático></a></h7><div class=paragraph><p>Se um endereço IP não puder ser obtido de um servidor DHCP, defina um endereço de IP fixo. Substitua a palavra-chave <code>DHCP</code> mostrada acima pelas informações do endereço. Certifique-se de reter quaisquer outros parâmetros para selecionar o ponto de acesso:</p></div><div class="literalblock programlisting"><div class=content><pre>wlans_ath0=&#34;wlan0&#34;
ifconfig_wlan0=&#34;inet 192.168.1.100 netmask 255.255.255.0 ssid your_ssid_here&#34;</pre></div></div></div></div><div class=sect5><h6 id=network-wireless-wpa>31.3.4.1.3. WPA<a class=anchor href=#network-wireless-wpa></a></h6><div class=paragraph><p>O Wi-Fi Protected Access (WPA) é um protocolo de segurança usado em conjunto com redes 802.11 para resolver a falta de autenticação adequada e a fraqueza do WEP. O WPA utiliza o protocolo de autenticação 802.1X e usa uma das várias codificações disponíveis em vez do WEP para integridade de dados. A única codificação exigida pelo WPA é o protocolo de integridade de chave temporária (TKIP). O TKIP é uma codificação que estende a codificação básica RC4 usada pelo WEP, adicionando verificação de integridade, detecção de adulteração e medidas para responder a intrusões detectadas. O TKIP foi projetado para funcionar em hardware legado apenas com uma modificação de software. Ele representa um compromisso que melhora a segurança, mas ainda não é totalmente imune a ataques. O WPA também especifica a codificação AES-CCMP como uma alternativa para o TKIP, e é preferível quando possível. Para esta especificação, o termo WPA2 ou RSN é comumente usado.</p></div><div class=paragraph><p>O WPA define protocolos de autenticação e criptografia. A autenticação é mais comumente feita usando uma de duas técnicas: por 802.1X e um serviço de autenticação backend, como o RADIUS, ou por um handshake mínimo entre a estação e o ponto de acesso usando um segredo pré-compartilhado. O primeiro é comumente chamado de WPA Enterprise e o último é conhecido como WPA Pessoal. Como a maioria das pessoas não configurará um servidor backend RADIUS para sua rede sem fio, o WPA-PSK é de longe a configuração mais comumente encontrada para o WPA .</p></div><div class=paragraph><p>O controle da conexão sem fio e a negociação ou autenticação de chave com um servidor é feito usando o <a href="https://man.freebsd.org/cgi/man.cgi?query=wpa_supplicant&amp;sektion=8&amp;format=html">wpa_supplicant(8)</a>. Este programa requer um arquivo de configuração, o <span class=filename>/etc/wpa_supplicant.conf</span>, para ser executado. Maiores informações sobre este arquivo podem ser encontradas em <a href="https://man.freebsd.org/cgi/man.cgi?query=wpa_supplicant.conf&amp;sektion=5&amp;format=html">wpa_supplicant.conf(5)</a>.</p></div><div class=sect6><h7 id=network-wireless-wpa-wpa-psk>31.3.4.1.3.1. WPA-PSK<a class=anchor href=#network-wireless-wpa-wpa-psk></a></h7><div class=paragraph><p>O WPA-PSK, também conhecido como WPA Pessoal, é baseado em uma chave pré-compartilhada (PSK) que é gerada a partir de uma determinada senha e usado como chave mestra na rede sem fio. Isso significa que todos os usuários sem fio compartilharão a mesma chave. O WPA-PSK destina-se a redes pequenas em que o uso de um servidor de autenticação não é possível ou desejado.</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Sempre use senhas fortes que sejam suficientemente longas e feitas de um alfabeto rico para que elas não sejam facilmente adivinhadas ou atacadas.</p></div></td></tr></tbody></table></div><div class=paragraph><p>O primeiro passo é a configuração do <span class=filename>/etc/wpa_supplicant.conf</span> com o SSID e a chave pré-compartilhada da rede:</p></div><div class="literalblock programlisting"><div class=content><pre>network={
  ssid=&#34;freebsdap&#34;
  psk=&#34;freebsdmall&#34;
}</pre></div></div><div class=paragraph><p>Então, em <span class=filename>/etc/rc.conf</span>, indique que a configuração do dispositivo sem fio será feita com o WPA e o endereço IP será obtido com o DHCP:</p></div><div class="literalblock programlisting"><div class=content><pre>wlans_ath0=&#34;wlan0&#34;
ifconfig_wlan0=&#34;WPA DHCP&#34;</pre></div></div><div class=paragraph><p>Então, suba a interface:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service netif start</span>
Starting wpa_supplicant.
DHCPDISCOVER on wlan0 to 255.255.255.255 port 67 interval 5
DHCPDISCOVER on wlan0 to 255.255.255.255 port 67 interval 6
DHCPOFFER from 192.168.0.1
DHCPREQUEST on wlan0 to 255.255.255.255 port 67
DHCPACK from 192.168.0.1
bound to 192.168.0.254 <span class=nt>--</span> renewal <span class=k>in </span>300 seconds.
wlan0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
      ether 00:11:95:d5:43:62
      inet 192.168.0.254 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet OFDM/36Mbps mode 11g
      status: associated
      ssid freebsdap channel 1 <span class=o>(</span>2412 Mhz 11g<span class=o>)</span> bssid 00:11:95:c3:0d:ac
      country US ecm authmode WPA2/802.11i privacy ON deftxkey UNDEF
      AES-CCM 3:128-bit txpower 21.5 bmiss 7 scanvalid 450 bgscan
      bgscanintvl 300 bgscanidle 250 roam:rssi 7 roam:rate 5 protmode CTS
      wme burst roaming MANUAL</code></pre></div></div><div class=paragraph><p>Ou, tente configurar a interface manualmente usando as informações em <span class=filename>/etc/wpa_supplicant.conf</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># wpa_supplicant -i wlan0 -c /etc/wpa_supplicant.conf</span>
Trying to associate with 00:11:95:c3:0d:ac <span class=o>(</span><span class=nv>SSID</span><span class=o>=</span><span class=s1>&#39;freebsdap&#39;</span> <span class=nv>freq</span><span class=o>=</span>2412 MHz<span class=o>)</span>
Associated with 00:11:95:c3:0d:ac
WPA: Key negotiation completed with 00:11:95:c3:0d:ac <span class=o>[</span><span class=nv>PTK</span><span class=o>=</span>CCMP <span class=nv>GTK</span><span class=o>=</span>CCMP]
CTRL-EVENT-CONNECTED - Connection to 00:11:95:c3:0d:ac completed <span class=o>(</span>auth<span class=o>)</span> <span class=o>[</span><span class=nb>id</span><span class=o>=</span>0 <span class=nv>id_str</span><span class=o>=]</span></code></pre></div></div><div class=paragraph><p>A próxima operação é iniciar o <a href="https://man.freebsd.org/cgi/man.cgi?query=dhclient&amp;sektion=8&amp;format=html">dhclient(8)</a> para obter o endereço IP do servidor DHCP:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dhclient wlan0</span>
DHCPREQUEST on wlan0 to 255.255.255.255 port 67
DHCPACK from 192.168.0.1
bound to 192.168.0.254 <span class=nt>--</span> renewal <span class=k>in </span>300 seconds.
<span class=c># ifconfig wlan0</span>
wlan0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
      ether 00:11:95:d5:43:62
      inet 192.168.0.254 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet OFDM/36Mbps mode 11g
      status: associated
      ssid freebsdap channel 1 <span class=o>(</span>2412 Mhz 11g<span class=o>)</span> bssid 00:11:95:c3:0d:ac
      country US ecm authmode WPA2/802.11i privacy ON deftxkey UNDEF
      AES-CCM 3:128-bit txpower 21.5 bmiss 7 scanvalid 450 bgscan
      bgscanintvl 300 bgscanidle 250 roam:rssi 7 roam:rate 5 protmode CTS
      wme burst roaming MANUAL</code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Se o <span class=filename>/etc/rc.conf</span> tiver uma entrada <code>ifconfig_wlan0="DHCP"</code>, <a href="https://man.freebsd.org/cgi/man.cgi?query=dhclient&amp;sektion=8&amp;format=html">dhclient(8)</a> será iniciado automaticamente após o <a href="https://man.freebsd.org/cgi/man.cgi?query=wpa_supplicant&amp;sektion=8&amp;format=html">wpa_supplicant(8)</a> associar-se ao ponto de acesso.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Se o DHCP não for possível ou desejado, defina um endereço IP estático após o <a href="https://man.freebsd.org/cgi/man.cgi?query=wpa_supplicant&amp;sektion=8&amp;format=html">wpa_supplicant(8)</a> autenticar a estação:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0 inet 192.168.0.100 netmask 255.255.255.0</span>
<span class=c># ifconfig wlan0</span>
wlan0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
      ether 00:11:95:d5:43:62
      inet 192.168.0.100 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet OFDM/36Mbps mode 11g
      status: associated
      ssid freebsdap channel 1 <span class=o>(</span>2412 Mhz 11g<span class=o>)</span> bssid 00:11:95:c3:0d:ac
      country US ecm authmode WPA2/802.11i privacy ON deftxkey UNDEF
      AES-CCM 3:128-bit txpower 21.5 bmiss 7 scanvalid 450 bgscan
      bgscanintvl 300 bgscanidle 250 roam:rssi 7 roam:rate 5 protmode CTS
      wme burst roaming MANUAL</code></pre></div></div><div class=paragraph><p>Quando o DHCP não é usado, o gateway padrão e o servidor de nomes também precisam ser definidos manualmente:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># route add default your_default_router</span>
<span class=c># echo &#34;nameserver your_DNS_server&#34; &gt;&gt; /etc/resolv.conf</span></code></pre></div></div></div><div class=sect6><h7 id=network-wireless-wpa-eap-tls>31.3.4.1.3.2. WPA com EAP-TLS<a class=anchor href=#network-wireless-wpa-eap-tls></a></h7><div class=paragraph><p>A segunda maneira de usar o WPA é com um servidor de autenticação de backend 802.1X. Neste caso, o WPA é chamado de WPA Enterprise para diferenciá-lo do WPA Pessoal menos seguro. A autenticação no WPA Enterprise é baseada no protocolo de autenticação extensível (EAP).</p></div><div class=paragraph><p>O EAP não vem com um método de criptografia. Em vez disso, o EAP é incorporado dentro de um túnel criptografado. Existem muitos métodos de autenticação EAP, mas o EAP-TLS, o EAP-TTLS e o EAP-PEAP são os mais comum.</p></div><div class=paragraph><p>O EAP com Segurança da Camada de Transporte (EAP-TLS) é um protocolo de autenticação sem fio bem suportado, já que foi o primeiro método EAP a ser certificado pela <a href=http://www.wi-fi.org/>WiFi Alliance</a>. O EAP-TLS requer três certificados para executar: o certificado da Autoridade de Certificação (CA) instalado em todas as máquinas, o certificado do servidor para o servidor de autenticação e um certificado de cliente para cada cliente sem fio. Nesse método EAP, o servidor de autenticação e o cliente sem fio autenticam um ao outro apresentando seus respectivos certificados e, em seguida, verificam se esses certificados foram assinados pela CA da organização.</p></div><div class=paragraph><p>Como anteriormente, a configuração é feita através do <span class=filename>/etc/wpa_supplicant.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>network={
  ssid=&#34;freebsdap&#34; <i class=conum data-value=1></i><b>(1)</b>
  proto=RSN  <i class=conum data-value=2></i><b>(2)</b>
  key_mgmt=WPA-EAP <i class=conum data-value=3></i><b>(3)</b>
  eap=TLS <i class=conum data-value=4></i><b>(4)</b>
  identity=&#34;loader&#34; <i class=conum data-value=5></i><b>(5)</b>
  ca_cert=&#34;/etc/certs/cacert.pem&#34; <i class=conum data-value=6></i><b>(6)</b>
  client_cert=&#34;/etc/certs/clientcert.pem&#34; <i class=conum data-value=7></i><b>(7)</b>
  private_key=&#34;/etc/certs/clientkey.pem&#34; <i class=conum data-value=8></i><b>(8)</b>
  private_key_passwd=&#34;freebsdmallclient&#34; <i class=conum data-value=9></i><b>(9)</b>
}</pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>Este campo indica o nome da rede (SSID).</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td>Este exemplo usa o protocolo 802.11i RSN IEEE™, também conhecido como WPA2.</td></tr><tr><td><i class=conum data-value=3></i><b>3</b></td><td>A linha <code>key_mgmt</code> refere-se ao protocolo de gerenciamento de chaves a ser usado. Neste exemplo, é o WPA usando a autenticação EAP.</td></tr><tr><td><i class=conum data-value=4></i><b>4</b></td><td>Este campo indica o método EAP para a conexão.</td></tr><tr><td><i class=conum data-value=5></i><b>5</b></td><td>O campo <code>identity</code> contém a sequência de identidade para EAP.</td></tr><tr><td><i class=conum data-value=6></i><b>6</b></td><td>O campo <code>ca_cert</code> indica o nome do caminho do arquivo de certificado CA. Este arquivo é necessário para verificar o certificado do servidor.</td></tr><tr><td><i class=conum data-value=7></i><b>7</b></td><td>A linha <code>client_cert</code> fornece o nome do caminho para o arquivo de certificado do cliente. Este certificado é exclusivo para cada cliente sem fio da rede.</td></tr><tr><td><i class=conum data-value=8></i><b>8</b></td><td>O campo <code>private_key</code> é o nome do caminho para o arquivo de chave privada do certificado do cliente.</td></tr><tr><td><i class=conum data-value=9></i><b>9</b></td><td>O campo <code>private_key_passwd</code> contém a frase secreta para a chave privada.</td></tr></tbody></table></div><div class=paragraph><p>Em seguida, adicione as seguintes linhas ao <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>wlans_ath0=&#34;wlan0&#34;
ifconfig_wlan0=&#34;WPA DHCP&#34;</pre></div></div><div class=paragraph><p>O próximo passo é subir a interface:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service netif start</span>
Starting wpa_supplicant.
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 7
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 15
DHCPACK from 192.168.0.20
bound to 192.168.0.254 <span class=nt>--</span> renewal <span class=k>in </span>300 seconds.
wlan0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
      ether 00:11:95:d5:43:62
      inet 192.168.0.254 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet DS/11Mbps mode 11g
      status: associated
      ssid freebsdap channel 1 <span class=o>(</span>2412 Mhz 11g<span class=o>)</span> bssid 00:11:95:c3:0d:ac
      country US ecm authmode WPA2/802.11i privacy ON deftxkey UNDEF
      AES-CCM 3:128-bit txpower 21.5 bmiss 7 scanvalid 450 bgscan
      bgscanintvl 300 bgscanidle 250 roam:rssi 7 roam:rate 5 protmode CTS
      wme burst roaming MANUAL</code></pre></div></div><div class=paragraph><p>Também é possível subir a interface manualmente usando <a href="https://man.freebsd.org/cgi/man.cgi?query=wpa_supplicant&amp;sektion=8&amp;format=html">wpa_supplicant(8)</a> e <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a>.</p></div></div><div class=sect6><h7 id=network-wireless-wpa-eap-ttls>31.3.4.1.3.3. WPA com EAP-TTLS<a class=anchor href=#network-wireless-wpa-eap-ttls></a></h7><div class=paragraph><p>Com o EAP-TLS, o servidor de autenticação e o cliente precisam de um certificado. Com o EAP-TTLS, um certificado de cliente é opcional. Esse método é semelhante a um servidor da Web que cria um túnel seguro SSL, mesmo se os visitantes não tiverem certificados do lado do cliente. O EAP-TTLS usa um túnel TLS criptografado para o transporte seguro dos dados de autenticação.</p></div><div class=paragraph><p>A configuração necessária pode ser adicionada ao <span class=filename>/etc/wpa_supplicant.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>network={
  ssid=&#34;freebsdap&#34;
  proto=RSN
  key_mgmt=WPA-EAP
  eap=TTLS <i class=conum data-value=1></i><b>(1)</b>
  identity=&#34;test&#34; <i class=conum data-value=2></i><b>(2)</b>
  password=&#34;test&#34; <i class=conum data-value=3></i><b>(3)</b>
  ca_cert=&#34;/etc/certs/cacert.pem&#34; <i class=conum data-value=4></i><b>(4)</b>
  phase2=&#34;auth=MD5&#34; <i class=conum data-value=5></i><b>(5)</b>
}</pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>Este campo especifica o método EAP para a conexão.</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td>O campo <code>identity</code> contém a sequência de identidade para a autenticação EAP dentro do túnel TLS criptografado.</td></tr><tr><td><i class=conum data-value=3></i><b>3</b></td><td>O campo <code>password</code> contém a senha para a autenticação EAP.</td></tr><tr><td><i class=conum data-value=4></i><b>4</b></td><td>O campo <code>ca_cert</code> indica o nome do caminho do arquivo de certificado CA. Este arquivo é necessário para verificar o certificado do servidor.</td></tr><tr><td><i class=conum data-value=5></i><b>5</b></td><td>Este campo especifica o método de autenticação usado no túnel TLS criptografado. Neste exemplo, o EAP com desafio MD5 é usado. A fase de "inner authentication" é freqüentemente chamada de "phase2".</td></tr></tbody></table></div><div class=paragraph><p>Em seguida, adicione as seguintes linhas ao <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>wlans_ath0=&#34;wlan0&#34;
ifconfig_wlan0=&#34;WPA DHCP&#34;</pre></div></div><div class=paragraph><p>O próximo passo é subir a interface:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service netif start</span>
Starting wpa_supplicant.
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 7
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 15
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 21
DHCPACK from 192.168.0.20
bound to 192.168.0.254 <span class=nt>--</span> renewal <span class=k>in </span>300 seconds.
wlan0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
      ether 00:11:95:d5:43:62
      inet 192.168.0.254 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet DS/11Mbps mode 11g
      status: associated
      ssid freebsdap channel 1 <span class=o>(</span>2412 Mhz 11g<span class=o>)</span> bssid 00:11:95:c3:0d:ac
      country US ecm authmode WPA2/802.11i privacy ON deftxkey UNDEF
      AES-CCM 3:128-bit txpower 21.5 bmiss 7 scanvalid 450 bgscan
      bgscanintvl 300 bgscanidle 250 roam:rssi 7 roam:rate 5 protmode CTS
      wme burst roaming MANUAL</code></pre></div></div></div><div class=sect6><h7 id=network-wireless-wpa-eap-peap>31.3.4.1.3.4. WPA com EAP-PEAP<a class=anchor href=#network-wireless-wpa-eap-peap></a></h7><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>O PEAPv0/EAP-MSCHAPv2 é o método PEAP mais comum. Neste capítulo, o termo PEAP é usado para se referir a esse método.</p></div></td></tr></tbody></table></div><div class=paragraph><p>O EAP protegido (PEAP) foi criado como uma alternativa ao EAP-TTLS e é o padrão mais usado do EAP após o EAP-TLS. Em uma rede com sistemas operacionais mistos, o PEAP deve ser o padrão mais suportado após o EAP-TLS.</p></div><div class=paragraph><p>O PEAP é semelhante ao EAP-TTLS, pois usa um certificado do lado do servidor para autenticar clientes criando um túnel TLS criptografado entre o cliente e o servidor de autenticação, que protege a troca subsequente das informações de autenticação. A autenticação PEAP difere do EAP-TTLS, pois transmite o nome de usuário em texto aberto e somente a senha é enviada no túnel TLS criptografado. O EAP-TTLS usará o túnel TLS para o nome de usuário e para a senha.</p></div><div class=paragraph><p>Adicione as seguintes linhas ao <span class=filename>/etc/wpa_supplicant.conf</span> para ajustar as configurações relacionadas ao EAP-PEAP:</p></div><div class="literalblock programlisting"><div class=content><pre>network={
  ssid=&#34;freebsdap&#34;
  proto=RSN
  key_mgmt=WPA-EAP
  eap=PEAP <i class=conum data-value=1></i><b>(1)</b>
  identity=&#34;test&#34; <i class=conum data-value=2></i><b>(2)</b>
  password=&#34;test&#34; <i class=conum data-value=3></i><b>(3)</b>
  ca_cert=&#34;/etc/certs/cacert.pem&#34; <i class=conum data-value=4></i><b>(4)</b>
  phase1=&#34;peaplabel=0&#34; <i class=conum data-value=5></i><b>(5)</b>
  phase2=&#34;auth=MSCHAPV2&#34; <i class=conum data-value=6></i><b>(6)</b>
}</pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>Este campo especifica o método EAP para a conexão.</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td>O campo <code>identity</code> contém a sequência de identidade para a autenticação EAP dentro do túnel TLS criptografado.</td></tr><tr><td><i class=conum data-value=3></i><b>3</b></td><td>O campo <code>password</code> contém a senha para a autenticação EAP.</td></tr><tr><td><i class=conum data-value=4></i><b>4</b></td><td>O campo <code>ca_cert</code> indica o nome do caminho do arquivo de certificado CA. Este arquivo é necessário para verificar o certificado do servidor.</td></tr><tr><td><i class=conum data-value=5></i><b>5</b></td><td>Este campo contém os parâmetros para a primeira fase de autenticação, o túnel TLS. De acordo com o servidor de autenticação usado, especifique um label específico para autenticação. Na maioria das vezes, o label será "client EAP encryption" que é definido usando <code>peaplabel=0</code>. Maiores informações podem ser encontradas em <a href="https://man.freebsd.org/cgi/man.cgi?query=wpa_supplicant.conf&amp;sektion=5&amp;format=html">wpa_supplicant.conf(5)</a>.</td></tr><tr><td><i class=conum data-value=6></i><b>6</b></td><td>Este campo especifica o protocolo de autenticação usado no túnel TLS criptografado. No caso do PEAP, é <code>auth=MSCHAPV2</code>.</td></tr></tbody></table></div><div class=paragraph><p>Adicione o seguinte ao <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>wlans_ath0=&#34;wlan0&#34;
ifconfig_wlan0=&#34;WPA DHCP&#34;</pre></div></div><div class=paragraph><p>Então, suba a interface:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service netif start</span>
Starting wpa_supplicant.
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 7
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 15
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 21
DHCPACK from 192.168.0.20
bound to 192.168.0.254 <span class=nt>--</span> renewal <span class=k>in </span>300 seconds.
wlan0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
      ether 00:11:95:d5:43:62
      inet 192.168.0.254 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet DS/11Mbps mode 11g
      status: associated
      ssid freebsdap channel 1 <span class=o>(</span>2412 Mhz 11g<span class=o>)</span> bssid 00:11:95:c3:0d:ac
      country US ecm authmode WPA2/802.11i privacy ON deftxkey UNDEF
      AES-CCM 3:128-bit txpower 21.5 bmiss 7 scanvalid 450 bgscan
      bgscanintvl 300 bgscanidle 250 roam:rssi 7 roam:rate 5 protmode CTS
      wme burst roaming MANUAL</code></pre></div></div></div></div><div class=sect5><h6 id=network-wireless-wep>31.3.4.1.4. WEP<a class=anchor href=#network-wireless-wep></a></h6><div class=paragraph><p>A privacidade equivalente com fio (WEP) faz parte do padrão 802.11 original. Não há mecanismo de autenticação, apenas uma forma fraca de controle de acesso que é facilmente quebrada.</p></div><div class=paragraph><p>O WEP pode ser configurado usando o <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0 create wlandev ath0</span>
<span class=c># ifconfig wlan0 inet 192.168.1.100 netmask 255.255.255.0 \</span>
	    ssid my_net wepmode on weptxkey 3 wepkey 3:0x3456789012</code></pre></div></div><div class=ulist><ul><li><p>O <code>weptxkey</code> especifica qual chave WEP será usada na transmissão. Este exemplo usa a terceira chave. Isso deve corresponder à configuração no ponto de acesso. Quando não tiver certeza de qual chave é usada pelo ponto de acesso, tente <code>1</code> (a primeira chave) para esse valor.</p></li><li><p>O <code>wepkey</code> seleciona uma das chaves WEP. Deve estar no formato <em>index:key</em>. A chave <code>1</code> é usada por padrão; o índice só precisa ser definido ao usar uma chave diferente da primeira.</p><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Substitua o <code>0x3456789012</code> com a chave configurada para uso no ponto de acesso.</p></div></td></tr></tbody></table></div></li></ul></div><div class=paragraph><p>Consulte o <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a> para obter maiores informações.</p></div><div class=paragraph><p>O recurso <a href="https://man.freebsd.org/cgi/man.cgi?query=wpa_supplicant&amp;sektion=8&amp;format=html">wpa_supplicant(8)</a> pode ser usado para configurar uma interface sem fio com o WEP. O exemplo acima pode ser configurado adicionando as seguintes linhas ao <span class=filename>/etc/wpa_supplicant.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>network={
  ssid=&#34;my_net&#34;
  key_mgmt=NONE
  wep_key3=3456789012
  wep_tx_keyidx=3
}</pre></div></div><div class=paragraph><p>Então:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># wpa_supplicant -i wlan0 -c /etc/wpa_supplicant.conf</span>
Trying to associate with 00:13:46:49:41:76 <span class=o>(</span><span class=nv>SSID</span><span class=o>=</span><span class=s1>&#39;dlinkap&#39;</span> <span class=nv>freq</span><span class=o>=</span>2437 MHz<span class=o>)</span>
Associated with 00:13:46:49:41:76</code></pre></div></div></div></div></div><div class=sect3><h4 id=_modo_ad_hoc>31.3.5. Modo Ad-hoc<a class=anchor href=#_modo_ad_hoc></a></h4><div class=paragraph><p>O modo IBSS, também chamado de modo ad-hoc, é projetado para conexões ponto a ponto. Por exemplo, para estabelecer uma rede ad-hoc entre as máquinas <code>A</code> e <code>B</code>, escolha dois endereços IP e um SSID.</p></div><div class=paragraph><p>Em <code>A</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0 create wlandev ath0 wlanmode adhoc</span>
<span class=c># ifconfig wlan0 inet 192.168.0.1 netmask 255.255.255.0 ssid freebsdap</span>
<span class=c># ifconfig wlan0</span>
  wlan0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
	  ether 00:11:95:c3:0d:ac
	  inet 192.168.0.1 netmask 0xffffff00 broadcast 192.168.0.255
	  media: IEEE 802.11 Wireless Ethernet autoselect mode 11g &lt;adhoc&gt;
	  status: running
	  ssid freebsdap channel 2 <span class=o>(</span>2417 Mhz 11g<span class=o>)</span> bssid 02:11:95:c3:0d:ac
	  country US ecm authmode OPEN privacy OFF txpower 21.5 scanvalid 60
	  protmode CTS wme burst</code></pre></div></div><div class=paragraph><p>O parâmetro <code>adhoc</code> indica que a interface está sendo executada no modo IBSS.</p></div><div class=paragraph><p><code>B</code> deve ser capaz de detectar <code>A</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0 create wlandev ath0 wlanmode adhoc</span>
<span class=c># ifconfig wlan0 up scan</span>
  SSID/MESH ID    BSSID              CHAN RATE   S:N     INT CAPS
  freebsdap       02:11:95:c3:0d:ac    2   54M <span class=nt>-64</span>:-96  100 IS   WME</code></pre></div></div><div class=paragraph><p>O <code>I</code> na saída confirma que <code>A</code> está no modo ad-hoc. Agora, configure <code>B</code> com um endereço IP diferente:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0 inet 192.168.0.2 netmask 255.255.255.0 ssid freebsdap</span>
<span class=c># ifconfig wlan0</span>
  wlan0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
	  ether 00:11:95:d5:43:62
	  inet 192.168.0.2 netmask 0xffffff00 broadcast 192.168.0.255
	  media: IEEE 802.11 Wireless Ethernet autoselect mode 11g &lt;adhoc&gt;
	  status: running
	  ssid freebsdap channel 2 <span class=o>(</span>2417 Mhz 11g<span class=o>)</span> bssid 02:11:95:c3:0d:ac
	  country US ecm authmode OPEN privacy OFF txpower 21.5 scanvalid 60
	  protmode CTS wme burst</code></pre></div></div><div class=paragraph><p>Ambos <code>A</code> e <code>B</code> agora estão prontos para trocar informações.</p></div></div><div class=sect3><h4 id=network-wireless-ap>31.3.6. Pontos de Acesso com um host FreeBSD<a class=anchor href=#network-wireless-ap></a></h4><div class=paragraph><p>O FreeBSD pode atuar como um Access Point (AP), o que elimina a necessidade de comprar um hardware AP ou executar uma rede ad-hoc. Isso pode ser particularmente útil quando uma máquina FreeBSD está atuando como um gateway para outra rede, como a Internet.</p></div><div class=sect4><h5 id=network-wireless-ap-basic>31.3.6.1. Configurações básicas<a class=anchor href=#network-wireless-ap-basic></a></h5><div class=paragraph><p>Antes de configurar uma máquina FreeBSD como um AP, o kernel deve ser configurado com o suporte de rede apropriado para a placa wireless assim como os protocolos de segurança que estão sendo usados. Para maiores detalhes, veja <a href=#network-wireless-basic>Configuração básica</a>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>O wrapper do driver NDIS para os drivers Windows™ não suporta atualmente a operação AP. Somente os drivers nativos de rede sem fio do FreeBSD suportam o modo AP.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Quando o suporte à rede sem fio estiver carregado, verifique se o dispositivo sem fio oferece suporte ao modo de ponto de acesso baseado em host, também conhecido como modo hostap:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0 create wlandev ath0</span>
<span class=c># ifconfig wlan0 list caps</span>
<span class=nv>drivercaps</span><span class=o>=</span>6f85edc1&lt;STA,FF,TURBOP,IBSS,HOSTAP,AHDEMO,TXPMGT,SHSLOT,SHPREAMBLE,MONITOR,MBSS,WPA1,WPA2,BURST,WME,WDS,BGSCAN,TXFRAG&gt;
<span class=nv>cryptocaps</span><span class=o>=</span>1f&lt;WEP,TKIP,AES,AES_CCM,TKIPMIC&gt;</code></pre></div></div><div class=paragraph><p>Esta saída exibe os recursos da placa. A palavra <code>HOSTAP</code> confirma que esta placa sem fio pode atuar como um AP. Diversas cifras suportadas também são listadas: WEP, TKIP e AES. Esta informação indica quais protocolos de segurança podem ser usados no AP.</p></div><div class=paragraph><p>O dispositivo sem fio só pode ser colocado no modo hostap durante a criação do pseudo-dispositivo de rede, portanto, um dispositivo criado anteriormente deve ser destruído primeiro:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0 destroy</span></code></pre></div></div><div class=paragraph><p>e então regenerado com a opção correta antes de configurar os outros parâmetros:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0 create wlandev ath0 wlanmode hostap</span>
<span class=c># ifconfig wlan0 inet 192.168.0.1 netmask 255.255.255.0 ssid freebsdap mode 11g channel 1</span></code></pre></div></div><div class=paragraph><p>Use o <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a> novamente para ver o status da interface <span class=filename>wlan0</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0</span>
  wlan0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
	  ether 00:11:95:c3:0d:ac
	  inet 192.168.0.1 netmask 0xffffff00 broadcast 192.168.0.255
	  media: IEEE 802.11 Wireless Ethernet autoselect mode 11g &lt;hostap&gt;
	  status: running
	  ssid freebsdap channel 1 <span class=o>(</span>2412 Mhz 11g<span class=o>)</span> bssid 00:11:95:c3:0d:ac
	  country US ecm authmode OPEN privacy OFF txpower 21.5 scanvalid 60
	  protmode CTS wme burst dtimperiod 1 <span class=nt>-dfs</span></code></pre></div></div><div class=paragraph><p>O parâmetro <code>hostap</code> indica que a interface está sendo executada no modo de ponto de acesso baseado em host.</p></div><div class=paragraph><p>A configuração da interface pode ser feita automaticamente no momento da inicialização, adicionando as seguintes linhas ao <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>wlans_ath0=&#34;wlan0&#34;
create_args_wlan0=&#34;wlanmode hostap&#34;
ifconfig_wlan0=&#34;inet 192.168.0.1 netmask 255.255.255.0 ssid freebsdap mode 11g channel 1&#34;</pre></div></div></div><div class=sect4><h5 id=_ponto_de_acesso_baseado_em_host_sem_autenticação_ou_criptografia>31.3.6.2. Ponto de acesso baseado em host sem autenticação ou criptografia<a class=anchor href=#_ponto_de_acesso_baseado_em_host_sem_autenticação_ou_criptografia></a></h5><div class=paragraph><p>Embora não seja recomendado executar um AP sem nenhuma autenticação ou criptografia, esta é uma maneira simples de verificar se o AP está funcionando. Essa configuração também é importante para depurar problemas do cliente.</p></div><div class=paragraph><p>Quando o AP estiver configurado, inicie uma verificação de outra máquina sem fio para encontrar o AP:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0 create wlandev ath0</span>
<span class=c># ifconfig wlan0 up scan</span>
SSID/MESH ID    BSSID              CHAN RATE   S:N     INT CAPS
freebsdap       00:11:95:c3:0d:ac    1   54M <span class=nt>-66</span>:-96  100 ES   WME</code></pre></div></div><div class=paragraph><p>A máquina cliente encontrou o AP e pode ser associado a ele:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0 inet 192.168.0.2 netmask 255.255.255.0 ssid freebsdap</span>
<span class=c># ifconfig wlan0</span>
  wlan0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
	  ether 00:11:95:d5:43:62
	  inet 192.168.0.2 netmask 0xffffff00 broadcast 192.168.0.255
	  media: IEEE 802.11 Wireless Ethernet OFDM/54Mbps mode 11g
	  status: associated
	  ssid freebsdap channel 1 <span class=o>(</span>2412 Mhz 11g<span class=o>)</span> bssid 00:11:95:c3:0d:ac
	  country US ecm authmode OPEN privacy OFF txpower 21.5 bmiss 7
	  scanvalid 60 bgscan bgscanintvl 300 bgscanidle 250 roam:rssi 7
	  roam:rate 5 protmode CTS wme burst</code></pre></div></div></div><div class=sect4><h5 id=network-wireless-ap-wpa>31.3.6.3. Ponto de acesso baseado em host com WPA2<a class=anchor href=#network-wireless-ap-wpa></a></h5><div class=paragraph><p>Esta seção se concentra na configuração de um ponto de acesso do FreeBSD usando o protocolo de segurança WPA2. Maiores detalhes sobre WPA e a configuração de clientes sem fio baseados em WPA podem ser encontrados em <a href=#network-wireless-wpa>WPA</a>.</p></div><div class=paragraph><p>O daemon <a href="https://man.freebsd.org/cgi/man.cgi?query=hostapd&amp;sektion=8&amp;format=html">hostapd(8)</a> é usado para lidar com a autenticação de clientes e o gerenciamento de chaves no AP com WPA2 habilitado.</p></div><div class=paragraph><p>As seguintes operações de configuração são executadas na máquina FreeBSD atuando como o AP. Uma vez que o AP esteja funcionando corretamente, o <a href="https://man.freebsd.org/cgi/man.cgi?query=hostapd&amp;sektion=8&amp;format=html">hostapd(8)</a> pode ser iniciado automaticamente na inicialização com essa linha em <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>hostapd_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Antes de tentar configurar o <a href="https://man.freebsd.org/cgi/man.cgi?query=hostapd&amp;sektion=8&amp;format=html">hostapd(8)</a>, primeiro defina as configurações básicas introduzidas em <a href=#network-wireless-ap-basic>Configurações básicas</a> .</p></div><div class=sect5><h6 id=_wpa2_psk>31.3.6.3.1. WPA2-PSK<a class=anchor href=#_wpa2_psk></a></h6><div class=paragraph><p>O WPA2-PSK destina-se a redes pequenas em que o uso de um servidor de autenticação backend não é possível ou desejado.</p></div><div class=paragraph><p>A configuração é feita em <span class=filename>/etc/hostapd.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>interface=wlan0                  <i class=conum data-value=1></i><b>(1)</b>
debug=1                          <i class=conum data-value=2></i><b>(2)</b>
ctrl_interface=/var/run/hostapd  <i class=conum data-value=3></i><b>(3)</b>
ctrl_interface_group=wheel       <i class=conum data-value=4></i><b>(4)</b>
ssid=freebsdap                   <i class=conum data-value=5></i><b>(5)</b>
wpa=2                            <i class=conum data-value=6></i><b>(6)</b>
wpa_passphrase=freebsdmall       <i class=conum data-value=7></i><b>(7)</b>
wpa_key_mgmt=WPA-PSK             <i class=conum data-value=8></i><b>(8)</b>
wpa_pairwise=CCMP                <i class=conum data-value=9></i><b>(9)</b></pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>Interface sem fio usada para o ponto de acesso.</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td>Nível de detalhamento usado durante a execução de <a href="https://man.freebsd.org/cgi/man.cgi?query=hostapd&amp;sektion=8&amp;format=html">hostapd(8)</a>. Um valor de <code>1</code> representa o nível mínimo.</td></tr><tr><td><i class=conum data-value=3></i><b>3</b></td><td>Nome do caminho de diretório usado pelo <a href="https://man.freebsd.org/cgi/man.cgi?query=hostapd&amp;sektion=8&amp;format=html">hostapd(8)</a> para armazenar arquivos de soquete de domínio para comunicação com programas externos, como <a href="https://man.freebsd.org/cgi/man.cgi?query=hostapd_cli&amp;sektion=8&amp;format=html">hostapd_cli(8)</a>. O valor padrão é usado neste exemplo.</td></tr><tr><td><i class=conum data-value=4></i><b>4</b></td><td>O grupo permitiu acessar os arquivos da interface de controle.</td></tr><tr><td><i class=conum data-value=5></i><b>5</b></td><td>O nome da rede sem fio, ou SSID, que aparecerá nas varreduras sem fio.</td></tr><tr><td><i class=conum data-value=6></i><b>6</b></td><td>Ative o WPA e especifique qual protocolo de autenticação WPA será necessário. Um valor de <code>2</code> configura o AP para WPA2 e é recomendado. Defina como <code>1</code> apenas se o WPA obsoleto for necessário.</td></tr><tr><td><i class=conum data-value=7></i><b>7</b></td><td>Senha ASCII para autenticação WPA.</td></tr><tr><td><i class=conum data-value=8></i><b>8</b></td><td>O protocolo de gerenciamento de chaves a ser usado. Este exemplo define o WPA-PSK.
Algoritmos de criptografia aceitos pelo ponto de acesso. Neste exemplo, apenas a codificação CCMP (AES) é aceita. O CCMP é uma alternativa ao TKIP e é fortemente preferido quando possível. O TKIP só deve ser permitido quando houver estações incapazes de usar o CCMP.</td></tr></tbody></table></div><div class=paragraph><p>O próximo passo é iniciar <a href="https://man.freebsd.org/cgi/man.cgi?query=hostapd&amp;sektion=8&amp;format=html">hostapd(8)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service hostapd forcestart</span></code></pre></div></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0</span>
wlan0: <span class=nv>flags</span><span class=o>=</span>8943&lt;UP,BROADCAST,RUNNING,PROMISC,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
	ether 04:f0:21:16:8e:10
	inet6 fe80::6f0:21ff:fe16:8e10%wlan0 prefixlen 64 scopeid 0x9
	nd6 <span class=nv>options</span><span class=o>=</span>21&lt;PERFORMNUD,AUTO_LINKLOCAL&gt;
	media: IEEE 802.11 Wireless Ethernet autoselect mode 11na &lt;hostap&gt;
	status: running
	ssid No5ignal channel 36 <span class=o>(</span>5180 MHz 11a ht/40+<span class=o>)</span> bssid 04:f0:21:16:8e:10
	country US ecm authmode WPA2/802.11i privacy MIXED deftxkey 2
	AES-CCM 2:128-bit AES-CCM 3:128-bit txpower 17 mcastrate 6 mgmtrate 6
	scanvalid 60 ampdulimit 64k ampdudensity 8 shortgi wme burst
	dtimperiod 1 <span class=nt>-dfs</span>
	<span class=nb>groups</span>: wlan</code></pre></div></div><div class=paragraph><p>Quando o AP está em execução, os clientes podem associar-se a ele. Veja <a href=#network-wireless-wpa>WPA</a> para maiores detalhes. É possível ver as estações associadas ao AP usando o <code>ifconfig <em>wlan0</em> list sta</code>.</p></div></div></div><div class=sect4><h5 id=_ponto_de_acesso_baseado_em_host_wep>31.3.6.4. Ponto de acesso baseado em host WEP<a class=anchor href=#_ponto_de_acesso_baseado_em_host_wep></a></h5><div class=paragraph><p>Não é recomendado o uso do WEP para configurar um AP, já que não há mecanismo de autenticação e a criptografia é facilmente quebrada. Algumas placas sem fio legadas suportam apenas o WEP e essas placas suportarão apenas um AP sem autenticação ou criptografia.</p></div><div class=paragraph><p>O dispositivo sem fio agora pode ser colocado no modo hostap e configurado com o endereço SSID e IP corretos:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0 create wlandev ath0 wlanmode hostap</span>
<span class=c># ifconfig wlan0 inet 192.168.0.1 netmask 255.255.255.0 \</span>
	ssid freebsdap wepmode on weptxkey 3 wepkey 3:0x3456789012 mode 11g</code></pre></div></div><div class=ulist><ul><li><p>O <code>weptxkey</code> indica qual a chave WEP será usada na transmissão. Este exemplo usa a terceira chave, pois a numeração de chaves começa com <code>1</code>. Esse parâmetro deve ser especificado para criptografar os dados.</p></li><li><p>O <code>wepkey</code> define a chave WEP selecionada. Ela deve estar no formato <em>index:key</em>. Se o índice não for fornecido, a chave <code>1</code> será configurada. O índice precisa ser definido ao usar chaves diferentes da primeira chave.</p></li></ul></div><div class=paragraph><p>Use o <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a> para ver o status da interface <span class=filename>wlan0</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0</span>
  wlan0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
	  ether 00:11:95:c3:0d:ac
	  inet 192.168.0.1 netmask 0xffffff00 broadcast 192.168.0.255
	  media: IEEE 802.11 Wireless Ethernet autoselect mode 11g &lt;hostap&gt;
	  status: running
	  ssid freebsdap channel 4 <span class=o>(</span>2427 Mhz 11g<span class=o>)</span> bssid 00:11:95:c3:0d:ac
	  country US ecm authmode OPEN privacy ON deftxkey 3 wepkey 3:40-bit
	  txpower 21.5 scanvalid 60 protmode CTS wme burst dtimperiod 1 <span class=nt>-dfs</span></code></pre></div></div><div class=paragraph><p>De uma outra máquina sem fio, agora é possível iniciar uma varredura para encontrar o AP:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0 create wlandev ath0</span>
<span class=c># ifconfig wlan0 up scan</span>
SSID            BSSID              CHAN RATE  S:N   INT CAPS
freebsdap       00:11:95:c3:0d:ac    1   54M 22:1   100 EPS</code></pre></div></div><div class=paragraph><p>Neste exemplo, a máquina cliente encontrou o AP e pode associá-lo usando os parâmetros corretos. Veja <a href=#network-wireless-wep>WEP</a> para maiores detalhes.</p></div></div></div><div class=sect3><h4 id=_usando_conexões_com_fio_e_sem_fio>31.3.7. Usando conexões com fio e sem fio<a class=anchor href=#_usando_conexões_com_fio_e_sem_fio></a></h4><div class=paragraph><p>Uma conexão com fio oferece melhor desempenho e confiabilidade, enquanto uma conexão sem fio fornece flexibilidade e mobilidade. Os usuários de laptop normalmente querem se movimentar perfeitamente entre os dois tipos de conexão.</p></div><div class=paragraph><p>No FreeBSD, é possível combinar duas ou mais interfaces de rede em um "failover". Esse tipo de configuração usa a conexão mais prioritária e disponível de um grupo de interfaces de rede, e o sistema operacional alterna automaticamente quando o estado do link é alterado.</p></div><div class=paragraph><p>A agregação de links e o failover são cobertos em <a href=#network-aggregation>Agregação de links e failover</a> e um exemplo para usar conexões com e sem fio é fornecido em <a href=#networking-lagg-wired-and-wireless>Modo de failover entre interfaces Ethernet e sem fio</a>.</p></div></div><div class=sect3><h4 id=_solução_de_problemas_5>31.3.8. Solução de problemas<a class=anchor href=#_solução_de_problemas_5></a></h4><div class=paragraph><p>Esta seção descreve várias etapas para ajudar a solucionar problemas comuns de rede sem fio.</p></div><div class=ulist><ul><li><p>Se o ponto de acesso não estiver listado durante a verificação, verifique se a configuração não limitou o dispositivo sem fio a um conjunto limitado de canais.</p></li><li><p>Se o dispositivo não puder se associar a um ponto de acesso, verifique se a configuração corresponde às configurações no ponto de acesso. Isso inclui o esquema de autenticação e qualquer protocolo de segurança. Simplifique a configuração tanto quanto possível. Se estiver usando um protocolo de segurança, como o WPA ou o WEP, configure o ponto de acesso para autenticação aberta e nenhuma segurança para ver se o tráfego irá passar.</p><div class=paragraph><p>O suporte a depuração é fornecido pelo <a href="https://man.freebsd.org/cgi/man.cgi?query=wpa_supplicant&amp;sektion=8&amp;format=html">wpa_supplicant(8)</a>. Tente executar este utilitário manualmente com a opção <code>-dd</code> e examine os logs do sistema.</p></div></li><li><p>Uma vez que o sistema possa se associar com o ponto de acesso, diagnostique a configuração da rede usando ferramentas como o <a href="https://man.freebsd.org/cgi/man.cgi?query=ping&amp;sektion=8&amp;format=html">ping(8)</a>.</p></li><li><p>Existem muitas ferramentas de depuração de nível inferior. As mensagens de depuração podem ser ativadas na camada de suporte do protocolo 802.11 usando o <a href="https://man.freebsd.org/cgi/man.cgi?query=wlandebug&amp;sektion=8&amp;format=html">wlandebug(8)</a>. Por exemplo, para habilitar mensagens do console relacionadas à varredura de pontos de acesso e aos handshakes do protocolo 802.11 necessários para organizar a comunicação:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># wlandebug -i wlan0 +scan+auth+debug+assoc</span>
  net.wlan.0.debug: 0 <span class=o>=&gt;</span> 0xc80000&lt;assoc,auth,scan&gt;</code></pre></div></div><div class=paragraph><p>Muitas estatísticas úteis são mantidas pela camada 802.11 e o <code>wlanstats</code>, encontrado em <span class=filename>/usr/src/tools/tools/net80211</span>, vai despejar esta informação. Essas estatísticas devem exibir todos os erros identificados pela camada 802.11. No entanto, alguns erros são identificados nos drivers de dispositivo que estão abaixo da camada 802.11, portanto eles podem não aparecer. Para diagnosticar problemas específicos do dispositivo, consulte a documentação do driver.</p></div></li></ul></div><div class=paragraph><p>Se as informações acima não ajudarem a esclarecer o problema, envie um relatório de problemas e inclua a saída das ferramentas acima.</p></div></div></div><div class=sect2><h3 id=network-usb-tethering>31.4. USB Tethering<a class=anchor href=#network-usb-tethering></a></h3><div class=paragraph><p>Muitos telefones celulares oferecem a opção de compartilhar sua conexão de dados sobre o USB (muitas vezes chamado de "tethering"). Este recurso usa o RNDIS, CDC ou um protocolo personalizado Apple™iPhone™/iPad™.</p></div><div class=ulist><ul><li><p>Os dispositivos Android™ geralmente utilizam o driver <a href="https://man.freebsd.org/cgi/man.cgi?query=urndis&amp;sektion=4&amp;format=html">urndis(4)</a>.</p></li><li><p>Os dispositivos Apple™ utilizam o driver <a href="https://man.freebsd.org/cgi/man.cgi?query=ipheth&amp;sektion=4&amp;format=html">ipheth(4)</a>.</p></li><li><p>Dispositivos mais antigos geralmente utilizam o driver <a href="https://man.freebsd.org/cgi/man.cgi?query=cdce&amp;sektion=4&amp;format=html">cdce(4)</a>.</p></li></ul></div><div class=paragraph><p>Antes de conectar um dispositivo, carregue o driver apropriado no kernel:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload if_urndis</span>
<span class=c># kldload if_cdce</span>
<span class=c># kldload if_ipheth</span></code></pre></div></div><div class=paragraph><p>Uma vez que o dispositivo esteja conectado, <code>ue</code><em>0</em> estará disponível para uso como um dispositivo de rede normal. Certifique-se de que a opção "USB Tethering" esteja ativada no dispositivo.</p></div><div class=paragraph><p>Para tornar essa alteração permanente e carregar o driver como um módulo no momento da inicialização, coloque a linha apropriada abaixo em <span class=filename>/boot/loader.conf</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> <span class=nv>if_urndis_load</span><span class=o>=</span><span class=s2>&#34;YES&#34;</span>
<span class=nv>if_cdce_load</span><span class=o>=</span><span class=s2>&#34;YES&#34;</span>
<span class=nv>if_ipheth_load</span><span class=o>=</span><span class=s2>&#34;YES&#34;</span></code></pre></div></div></div><div class=sect2><h3 id=network-bluetooth>31.5. Bluetooth<a class=anchor href=#network-bluetooth></a></h3><div class=paragraph><p>O bluetooth é uma tecnologia sem fio para a criação de redes pessoais que operam na faixa não licenciada de 2,4 GHz, com um alcance de 10 metros. As redes geralmente são formadas em modo ad-hoc a partir de dispositivos portáteis, como telefones celulares, computadores de mão e laptops. Ao contrário da tecnologia sem fio Wi-Fi, o Bluetooth oferece perfis de serviços de nível superior, como servidores de arquivos semelhantes ao FTP, envio de arquivos, transporte de voz, emulação de linha serial e muito mais.</p></div><div class=paragraph><p>Esta seção descreve o uso de um dongle Bluetooth USB em um sistema FreeBSD. Em seguida, descreve os vários protocolos e utilitários Bluetooth.</p></div><div class=sect3><h4 id=_carregando_o_suporte_bluetooth>31.5.1. Carregando o Suporte Bluetooth<a class=anchor href=#_carregando_o_suporte_bluetooth></a></h4><div class=paragraph><p>A pilha Bluetooth no FreeBSD é implementada usando o framework <a href="https://man.freebsd.org/cgi/man.cgi?query=netgraph&amp;sektion=4&amp;format=html">netgraph(4)</a>. Uma ampla variedade de dongles Bluetooth USB é suportada pelo <a href="https://man.freebsd.org/cgi/man.cgi?query=ng_ubt&amp;sektion=4&amp;format=html">ng_ubt(4)</a>. Os dispositivos Bluetooth baseados no Broadcom BCM2033 são suportados pelos drivers <a href="https://man.freebsd.org/cgi/man.cgi?query=ubtbcmfw&amp;sektion=4&amp;format=html">ubtbcmfw(4)</a> e <a href="https://man.freebsd.org/cgi/man.cgi?query=ng_ubt&amp;sektion=4&amp;format=html">ng_ubt(4)</a>. A placa 3Com Bluetooth PC Card 3CRWB60-A é suportada pelo driver <a href="https://man.freebsd.org/cgi/man.cgi?query=ng_bt3c&amp;sektion=4&amp;format=html">ng_bt3c(4)</a>. Dispositivos Bluetooth baseados em Portas Seriais e UART são suportados por <a href="https://man.freebsd.org/cgi/man.cgi?query=sio&amp;sektion=4&amp;format=html">sio(4)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=ng_h4&amp;sektion=4&amp;format=html">ng_h4(4)</a>, e <a href="https://man.freebsd.org/cgi/man.cgi?query=hcseriald&amp;sektion=8&amp;format=html">hcseriald(8)</a>.</p></div><div class=paragraph><p>Antes de conectar um dispositivo, determine qual dos drivers acima ele usa e, em seguida, carregue o driver. Por exemplo, se o dispositivo usar o driver <a href="https://man.freebsd.org/cgi/man.cgi?query=ng_ubt&amp;sektion=4&amp;format=html">ng_ubt(4)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload ng_ubt</span></code></pre></div></div><div class=paragraph><p>Se o dispositivo Bluetooth for conectado ao sistema durante a inicialização do sistema, o sistema pode ser configurado para carregar o módulo no momento da inicialização, adicionando o driver ao <span class=filename>/boot/loader.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>ng_ubt_load=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Quando o driver estiver carregado, conecte o dongle USB. Se a carga do driver tiver sido bem-sucedida, uma saída semelhante à seguinte deve aparecer no console e em <span class=filename>/var/log/messages</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>ubt0: vendor 0x0a12 product 0x0001, rev 1.10/5.25, addr 2
ubt0: Interface 0 endpoints: <span class=nv>interrupt</span><span class=o>=</span>0x81, bulk-in<span class=o>=</span>0x82, bulk-out<span class=o>=</span>0x2
ubt0: Interface 1 <span class=o>(</span>alt.config 5<span class=o>)</span> endpoints: isoc-in<span class=o>=</span>0x83, isoc-out<span class=o>=</span>0x3,
      <span class=nv>wMaxPacketSize</span><span class=o>=</span>49, <span class=nv>nframes</span><span class=o>=</span>6, buffer <span class=nv>size</span><span class=o>=</span>294</code></pre></div></div><div class=paragraph><p>Para iniciar e parar a stack Bluetooth, use seu script de inicialização. É uma boa ideia parar a stack antes de desconectar o dispositivo. Iniciar a stack bluetooth pode exigir que o <a href="https://man.freebsd.org/cgi/man.cgi?query=hcsecd&amp;sektion=8&amp;format=html">hcsecd(8)</a> seja iniciado. Ao iniciar a stack, a saída deve ser semelhante à seguinte:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service bluetooth start ubt0</span>
BD_ADDR: 00:02:72:00:d4:1a
Features: 0xff 0xff 0xf 00 00 00 00 00
&lt;3-Slot&gt; &lt;5-Slot&gt; &lt;Encryption&gt; &lt;Slot offset&gt;
&lt;Timing accuracy&gt; &lt;Switch&gt; &lt;Hold mode&gt; &lt;Sniff mode&gt;
&lt;Park mode&gt; &lt;RSSI&gt; &lt;Channel quality&gt; &lt;SCO <span class=nb>link</span><span class=o>&gt;</span>
&lt;HV2 packets&gt; &lt;HV3 packets&gt; &lt;u-law log&gt; &lt;A-law log&gt; &lt;CVSD&gt;
&lt;Paging scheme&gt; &lt;Power control&gt; &lt;Transparent SCO data&gt;
Max. ACL packet size: 192 bytes
Number of ACL packets: 8
Max. SCO packet size: 64 bytes
Number of SCO packets: 8</code></pre></div></div></div><div class=sect3><h4 id=_encontrando_outros_dispositivos_bluetooth>31.5.2. Encontrando outros dispositivos Bluetooth<a class=anchor href=#_encontrando_outros_dispositivos_bluetooth></a></h4><div class=paragraph><p>A Interface do Controlador do Host (HCI) fornece um método uniforme para acessar os recursos de banda básica do Bluetooth. No FreeBSD, um nó netgraph HCI é criado para cada dispositivo Bluetooth. Para mais detalhes, consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=ng_hci&amp;sektion=4&amp;format=html">ng_hci(4)</a>.</p></div><div class=paragraph><p>Uma das tarefas mais comuns é a descoberta de dispositivos Bluetooth dentro da proximidade RF. Esta operação é chamada <em>inquiry</em>. Investigação e outras operações relacionadas a HCI são feitas usando <a href="https://man.freebsd.org/cgi/man.cgi?query=hccontrol&amp;sektion=8&amp;format=html">hccontrol(8)</a>. O exemplo abaixo mostra como descobrir quais dispositivos Bluetooth estão ao alcance. A lista de dispositivos deve ser exibida em alguns segundos. Note que um dispositivo remoto só irá responder a pergunta se estiver configurado para o modo <em>detectável</em>.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% hccontrol <span class=nt>-n</span> ubt0hci inquiry
Inquiry result, <span class=nv>num_responses</span><span class=o>=</span>1
Inquiry result <span class=c>#0</span>
       BD_ADDR: 00:80:37:29:19:a4
       Page Scan Rep. Mode: 0x1
       Page Scan Period Mode: 00
       Page Scan Mode: 00
       Class: 52:02:04
       Clock offset: 0x78ef
Inquiry complete. Status: No error <span class=o>[</span>00]</code></pre></div></div><div class=paragraph><p>O <code>BD_ADDR</code> é o endereço exclusivo de um dispositivo Bluetooth, semelhante ao endereço MAC de uma placa de rede. Este endereço é necessário para uma comunicação posterior com um dispositivo e é possível atribuir um nome legível a um <code>BD_ADDR</code>. Informações sobre os hosts Bluetooth conhecidos estão contidas em <span class=filename>/etc/bluetooth/hosts</span>. O exemplo a seguir mostra como obter o nome legível que foi atribuído ao dispositivo remoto:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% hccontrol <span class=nt>-n</span> ubt0hci remote_name_request 00:80:37:29:19:a4
BD_ADDR: 00:80:37:29:19:a4
Name: Pav<span class=s1>&#39;s T39</span></code></pre></div></div><div class=paragraph><p>Se uma consulta for realizada em um dispositivo Bluetooth remoto, ele encontrará o computador como "your.host.name (ubt0)". O nome atribuído ao dispositivo local pode ser alterado a qualquer momento.</p></div><div class=paragraph><p>Dispositivos remotos podem receber aliases em <span class=filename>/etc/bluetooth/hosts</span>. Maiores informações sobre o arquivo <span class=filename>/etc/bluetooth/hosts</span> podem ser encontradas em <a href="https://man.freebsd.org/cgi/man.cgi?query=bluetooth.hosts&amp;sektion=5&amp;format=html">bluetooth.hosts(5)</a>.</p></div><div class=paragraph><p>O sistema Bluetooth fornece uma conexão ponta-a-ponto entre duas unidades Bluetooth ou uma conexão ponto-a-multiponto que é compartilhada entre vários dispositivos Bluetooth. O exemplo a seguir mostra como criar uma conexão a um dispositivo remoto:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% hccontrol <span class=nt>-n</span> ubt0hci create_connection BT_ADDR</code></pre></div></div><div class=paragraph><p>O <code>create_connection</code> aceita <code>BT_ADDR</code>, bem como aliases de host em <span class=filename>/etc/bluetooth/hosts</span>.</p></div><div class=paragraph><p>O exemplo a seguir mostra como obter a lista de conexões de banda base ativas para o dispositivo local:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% hccontrol <span class=nt>-n</span> ubt0hci read_connection_list
Remote BD_ADDR    Handle Type Mode Role Encrypt Pending Queue State
00:80:37:29:19:a4     41  ACL    0 MAST    NONE       0     0 OPEN</code></pre></div></div><div class=paragraph><p>Um <em>identificador de conexão</em> é útil quando a finalização da conexão de banda base é necessária, embora normalmente não seja necessário fazer isso manualmente. A stack terminará automaticamente as conexões de banda básica inativas.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># hccontrol -n ubt0hci disconnect 41</span>
Connection handle: 41
Reason: Connection terminated by <span class=nb>local </span>host <span class=o>[</span>0x16]</code></pre></div></div><div class=paragraph><p>Digite <code>hccontrol help</code> para obter uma lista completa dos comandos HCI disponíveis. A maioria dos comandos HCI não requer privilégios de superusuário.</p></div></div><div class=sect3><h4 id=_emparelhamento_de_dispositivos>31.5.3. Emparelhamento de dispositivos<a class=anchor href=#_emparelhamento_de_dispositivos></a></h4><div class=paragraph><p>Por padrão, a comunicação Bluetooth não é autenticada e qualquer dispositivo pode conversar com qualquer outro dispositivo. Um dispositivo Bluetooth, como um telefone celular, pode optar por exigir autenticação para fornecer um serviço específico. A autenticação Bluetooth é normalmente feita com um <em>PIN code</em>, uma string ASCII com até 16 caracteres de comprimento. O usuário é obrigado a digitar o mesmo código de PIN em ambos os dispositivos. Depois que o usuário inserir o código de PIN, ambos os dispositivos gerarão uma <em>chave de link</em>. Depois disso, a chave de link pode ser armazenada nos dispositivos ou em um armazenamento persistente. Na próxima vez, os dois dispositivos usarão a chave de link gerada anteriormente. Este procedimento é chamado de <em>emparelhamento</em>. Observe que, se a chave de link for perdida por um dos dispositivos, o emparelhamento deverá ser repetido.</p></div><div class=paragraph><p>O daemon <a href="https://man.freebsd.org/cgi/man.cgi?query=hcsecd&amp;sektion=8&amp;format=html">hcsecd(8)</a> é responsável por tratar os pedidos de autenticação Bluetooth. O arquivo de configuração padrão é o <span class=filename>/etc/bluetooth/hcsecd.conf</span>. Uma seção de exemplo para um telefone celular com o código PIN definido como <code>1234</code> é mostrada abaixo:</p></div><div class="literalblock programlisting"><div class=content><pre>device {
        bdaddr  00:80:37:29:19:a4;
        name    &#34;Pav&#39;s T39&#34;;
        key     nokey;
        pin     &#34;1234&#34;;
      }</pre></div></div><div class=paragraph><p>A única limitação nos códigos de PIN é o comprimento. Alguns dispositivos, como fones de ouvido Bluetooth, podem ter um código PIN integrado fixo. A opção <code>-d</code> força o <a href="https://man.freebsd.org/cgi/man.cgi?query=hcsecd&amp;sektion=8&amp;format=html">hcsecd(8)</a> a ficar em primeiro plano, então é fácil ver o que está acontecendo. Configure o dispositivo remoto para receber o emparelhamento e inicie a conexão Bluetooth ao dispositivo remoto. O dispositivo remoto deve indicar que o pareamento foi aceito e solicitar o código de PIN. Digite o mesmo código de PIN listado em <span class=filename>hcsecd.conf</span>. Agora o computador e o dispositivo remoto estão emparelhados. Alternativamente, o emparelhamento pode ser iniciado no dispositivo remoto.</p></div><div class=paragraph><p>A seguinte linha pode ser adicionada ao <span class=filename>/etc/rc.conf</span> para configurar o <a href="https://man.freebsd.org/cgi/man.cgi?query=hcsecd&amp;sektion=8&amp;format=html">hcsecd(8)</a> para iniciar automaticamente quando o sistema inicializar:</p></div><div class="literalblock programlisting"><div class=content><pre>hcsecd_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>A seguir, um exemplo da saída do daemon <a href="https://man.freebsd.org/cgi/man.cgi?query=hcsecd&amp;sektion=8&amp;format=html">hcsecd(8)</a>:</p></div><div class="literalblock programlisting"><div class=content><pre>hcsecd[16484]: Got Link_Key_Request event from &#39;ubt0hci&#39;, remote bdaddr 0:80:37:29:19:a4
hcsecd[16484]: Found matching entry, remote bdaddr 0:80:37:29:19:a4, name &#39;Pav&#39;s T39&#39;, link key doesn&#39;t exist
hcsecd[16484]: Sending Link_Key_Negative_Reply to &#39;ubt0hci&#39; for remote bdaddr 0:80:37:29:19:a4
hcsecd[16484]: Got PIN_Code_Request event from &#39;ubt0hci&#39;, remote bdaddr 0:80:37:29:19:a4
hcsecd[16484]: Found matching entry, remote bdaddr 0:80:37:29:19:a4, name &#39;Pav&#39;s T39&#39;, PIN code exists
hcsecd[16484]: Sending PIN_Code_Reply to &#39;ubt0hci&#39; for remote bdaddr 0:80:37:29:19:a4</pre></div></div></div><div class=sect3><h4 id=_acesso_à_rede_com_perfis_ppp>31.5.4. Acesso à rede com perfis PPP<a class=anchor href=#_acesso_à_rede_com_perfis_ppp></a></h4><div class=paragraph><p>Um perfil de rede dial-up (DUN) pode ser usado para configurar um telefone celular como um modem sem fio para a conexão a um servidor de acesso à Internet dial-up. Também pode ser usado para configurar um computador para receber chamadas de dados de um telefone celular.</p></div><div class=paragraph><p>O acesso à rede com um perfil PPP pode ser usado para fornecer acesso LAN a um único dispositivo Bluetooth ou a vários dispositivos Bluetooth. Ele também pode fornecer uma conexão PC para PC usando uma rede PPP sobre uma emulação de cabo serial.</p></div><div class=paragraph><p>No FreeBSD, esses perfis são implementados com o <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> e o wrapper <a href="https://man.freebsd.org/cgi/man.cgi?query=rfcomm_pppd&amp;sektion=8&amp;format=html">rfcomm_pppd(8)</a> que converte uma conexão Bluetooth em algo que o PPP pode usar. Antes que um perfil possa ser usado, um novo label PPP deve ser criado em <span class=filename>/etc/ppp/ppp.conf</span>. Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=rfcomm_pppd&amp;sektion=8&amp;format=html">rfcomm_pppd(8)</a> para exemplos.</p></div><div class=paragraph><p>Neste exemplo, o <a href="https://man.freebsd.org/cgi/man.cgi?query=rfcomm_pppd&amp;sektion=8&amp;format=html">rfcomm_pppd(8)</a> é usado para abrir uma conexão com um dispositivo remoto com um <code>BD_ADDR</code> de <code>00:80:37:29:19:a4</code> em um canal DUNRFCOMM:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># rfcomm_pppd -a 00:80:37:29:19:a4 -c -C dun -l rfcomm-dialup</span></code></pre></div></div><div class=paragraph><p>O número real do canal será obtido a partir do dispositivo remoto usando o protocolo SDP. É possível especificar manualmente o canal RFCOMM e, nesse caso, o <a href="https://man.freebsd.org/cgi/man.cgi?query=rfcomm_pppd&amp;sektion=8&amp;format=html">rfcomm_pppd(8)</a> não executará a consulta SDP. Use o <a href="https://man.freebsd.org/cgi/man.cgi?query=sdpcontrol&amp;sektion=8&amp;format=html">sdpcontrol(8)</a> para descobrir o canal RFCOMM no dispositivo remoto.</p></div><div class=paragraph><p>Para fornecer acesso à rede com o serviço PPPLAN, o <a href="https://man.freebsd.org/cgi/man.cgi?query=sdpd&amp;sektion=8&amp;format=html">sdpd(8)</a> precisa estar sendo executado e uma nova entrada para clientes LAN deve ser criada em <span class=filename>/etc/ppp/ppp.conf</span>. Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=rfcomm_pppd&amp;sektion=8&amp;format=html">rfcomm_pppd(8)</a> para exemplos. Por fim, inicie o servidor RFCOMMPPP em um número de canal RFCOMM válido. O servidor RFCOMMPPP registrará automaticamente o serviço Bluetooth LAN com o daemon local SDP. O exemplo abaixo mostra como iniciar o servidor RFCOMMPPP.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># rfcomm_pppd -s -C 7 -l rfcomm-server</span></code></pre></div></div></div><div class=sect3><h4 id=_protocolos_bluetooth>31.5.5. Protocolos Bluetooth<a class=anchor href=#_protocolos_bluetooth></a></h4><div class=paragraph><p>Esta seção fornece uma visão geral dos vários protocolos Bluetooth, suas funções e utilitários associados.</p></div><div class=sect4><h5 id=_controle_de_link_lógico_e_protocolo_de_adaptação_l2cap>31.5.5.1. Controle de Link Lógico e Protocolo de Adaptação (L2CAP)<a class=anchor href=#_controle_de_link_lógico_e_protocolo_de_adaptação_l2cap></a></h5><div class=paragraph><p>O Protocolo de Adaptação e Controle de Link Lógico (L2CAP) fornece serviços de dados orientados a conexão e sem conexão para protocolos de camada superior. O L2CAP permite que protocolos e aplicativos de alto nível transmitam e recebam pacotes de dados L2CAP de até 64 kilobytes de comprimento.</p></div><div class=paragraph><p>O L2CAP é baseado no conceito de <em>canais</em>. Um canal é uma conexão lógica em cima de uma conexão de banda base, na qual cada canal é vinculado a um único protocolo de maneira many-to-one. Vários canais podem ser vinculados ao mesmo protocolo, mas um canal não pode ser vinculado a vários protocolos. Cada pacote L2CAP recebido em um canal é direcionado para o protocolo apropriado de nível superior. Vários canais podem compartilhar a mesma conexão de banda base.</p></div><div class=paragraph><p>No FreeBSD, um nó netgraph L2CAP é criado para cada dispositivo Bluetooth. Esse nó é normalmente conectado ao nó Bluetooth HCI downstream e aos nós de soquete Bluetooth upstream. O nome padrão para o nó L2CAP é "devicel2cap". Para mais detalhes, consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=ng_l2cap&amp;sektion=4&amp;format=html">ng_l2cap(4)</a>.</p></div><div class=paragraph><p>Um comando útil é o <a href="https://man.freebsd.org/cgi/man.cgi?query=l2ping&amp;sektion=8&amp;format=html">l2ping(8)</a>, que pode ser usado para executar ping em outros dispositivos. Algumas implementações Bluetooth podem não retornar todos os dados enviados para elas, portanto, a saída <code>0 bytes</code> no exemplo a seguir é normal.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># l2ping -a 00:80:37:29:19:a4</span>
0 bytes from 0:80:37:29:19:a4 <span class=nv>seq_no</span><span class=o>=</span>0 <span class=nb>time</span><span class=o>=</span>48.633 ms <span class=nv>result</span><span class=o>=</span>0
0 bytes from 0:80:37:29:19:a4 <span class=nv>seq_no</span><span class=o>=</span>1 <span class=nb>time</span><span class=o>=</span>37.551 ms <span class=nv>result</span><span class=o>=</span>0
0 bytes from 0:80:37:29:19:a4 <span class=nv>seq_no</span><span class=o>=</span>2 <span class=nb>time</span><span class=o>=</span>28.324 ms <span class=nv>result</span><span class=o>=</span>0
0 bytes from 0:80:37:29:19:a4 <span class=nv>seq_no</span><span class=o>=</span>3 <span class=nb>time</span><span class=o>=</span>46.150 ms <span class=nv>result</span><span class=o>=</span>0</code></pre></div></div><div class=paragraph><p>O utilitário <a href="https://man.freebsd.org/cgi/man.cgi?query=l2control&amp;sektion=8&amp;format=html">l2control(8)</a> é usado para executar várias operações em nós L2CAP. Este exemplo mostra como obter a lista de conexões lógicas (canais) e a lista de conexões de banda base para o dispositivo local:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% l2control <span class=nt>-a</span> 00:02:72:00:d4:1a read_channel_list
L2CAP channels:
Remote BD_ADDR     SCID/ DCID   PSM  IMTU/ OMTU State
00:07:e0:00:0b:ca    66/   64     3   132/  672 OPEN
% l2control <span class=nt>-a</span> 00:02:72:00:d4:1a read_connection_list
L2CAP connections:
Remote BD_ADDR    Handle Flags Pending State
00:07:e0:00:0b:ca     41 O           0 OPEN</code></pre></div></div><div class=paragraph><p>Outra ferramenta de diagnóstico é o <a href="https://man.freebsd.org/cgi/man.cgi?query=btsockstat&amp;sektion=1&amp;format=html">btsockstat(1)</a>. Ele é semelhante ao <a href="https://man.freebsd.org/cgi/man.cgi?query=netstat&amp;sektion=1&amp;format=html">netstat(1)</a>, mas para estruturas de dados relacionadas à rede Bluetooth. O exemplo abaixo mostra a mesma conexão lógica que <a href="https://man.freebsd.org/cgi/man.cgi?query=l2control&amp;sektion=8&amp;format=html">l2control(8)</a> acima.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% btsockstat
Active L2CAP sockets
PCB      Recv-Q Send-Q Local address/PSM       Foreign address   CID   State
c2afe900      0      0 00:02:72:00:d4:1a/3     00:07:e0:00:0b:ca 66    OPEN
Active RFCOMM sessions
L2PCB    PCB      Flag MTU   Out-Q DLCs State
c2afe900 c2b53380 1    127   0     Yes  OPEN
Active RFCOMM sockets
PCB      Recv-Q Send-Q Local address     Foreign address   Chan DLCI State
c2e8bc80      0    250 00:02:72:00:d4:1a 00:07:e0:00:0b:ca 3    6    OPEN</code></pre></div></div></div><div class=sect4><h5 id=_comunicação_por_radiofrequência_rfcomm>31.5.5.2. Comunicação por radiofrequência (RFCOMM)<a class=anchor href=#_comunicação_por_radiofrequência_rfcomm></a></h5><div class=paragraph><p>O protocolo RFCOMM fornece emulação de portas seriais sobre o protocolo L2CAP. O RFCOMM é um protocolo de transporte simples, com disposições adicionais para emular os 9 circuitos das portas seriais RS-232 (EIATIA-232-E). Suporta até 60 conexões simultâneas (canais RFCOMM) entre dois dispositivos Bluetooth.</p></div><div class=paragraph><p>Para fins do RFCOMM, um caminho de comunicação completo envolve dois aplicativos em execução nos terminais de comunicação com um segmento de comunicação entre eles. O RFCOMM destina-se a abranger aplicativos que fazem uso das portas seriais dos dispositivos em que residem. O segmento de comunicação é um link Bluetooth de conexão direta de um dispositivo para outro.</p></div><div class=paragraph><p>O RFCOMM está relacionado apenas com a conexão entre os dispositivos no caso de conexão direta ou entre o dispositivo e um modem no caso de rede. O RFCOMM pode suportar outras configurações, como módulos que se comunicam via tecnologia sem fio Bluetooth de um lado e fornecem uma interface com fio no outro lado.</p></div><div class=paragraph><p>No FreeBSD, o RFCOMM é implementado na camada de sockets do Bluetooth.</p></div></div><div class=sect4><h5 id=_protocolo_de_descoberta_de_serviços_sdp>31.5.5.3. Protocolo de Descoberta de Serviços (SDP)<a class=anchor href=#_protocolo_de_descoberta_de_serviços_sdp></a></h5><div class=paragraph><p>O Protocolo de Descoberta de Serviços (SDP) fornece os meios para os aplicativos clientes descobrirem a existência de serviços fornecidos por aplicativos de servidor, bem como os atributos desses serviços. Os atributos de um serviço incluem o tipo ou classe de serviço oferecido e as informações de mecanismo ou protocolo necessárias para utilizar o serviço.</p></div><div class=paragraph><p>O SDP envolve a comunicação entre um servidor SDP e um cliente SDP. O servidor mantém uma lista de registros de serviço que descrevem as características dos serviços associados ao servidor. Cada registro de serviço contém informações sobre um único serviço. Um cliente pode recuperar informações de um registro de serviço mantido pelo servidor SDP emitindo uma solicitação SDP. Se o cliente, ou um aplicativo associado ao cliente, decidir usar um serviço, ele deverá abrir uma conexão separada com o provedor de serviços para utilizar o serviço. O SDP fornece um mecanismo para descobrir serviços e seus atributos, mas não fornece um mecanismo para utilizar esses serviços.</p></div><div class=paragraph><p>Normalmente, um cliente SDP procura serviços baseados em algumas características desejadas dos serviços. No entanto, há momentos em que é desejável descobrir quais tipos de serviços são descritos pelos registros de serviço de um servidor SDP, sem qualquer informação prévia sobre os serviços. Este processo de procurar por qualquer serviço oferecido é chamado de <em>navegação</em>.</p></div><div class=paragraph><p>O servidor Bluetooth SDP, <a href="https://man.freebsd.org/cgi/man.cgi?query=sdpd&amp;sektion=8&amp;format=html">sdpd(8)</a> e o cliente de linha de comandos, <a href="https://man.freebsd.org/cgi/man.cgi?query=sdpcontrol&amp;sektion=8&amp;format=html">sdpcontrol(8)</a>, estão incluídos na instalação padrão do FreeBSD. O exemplo a seguir mostra como executar uma consulta de navegação SDP.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% sdpcontrol <span class=nt>-a</span> 00:01:03:fc:6e:ec browse
Record Handle: 00000000
Service Class ID List:
        Service Discovery Server <span class=o>(</span>0x1000<span class=o>)</span>
Protocol Descriptor List:
        L2CAP <span class=o>(</span>0x0100<span class=o>)</span>
                Protocol specific parameter <span class=c>#1: u/int/uuid16 1</span>
                Protocol specific parameter <span class=c>#2: u/int/uuid16 1</span>

Record Handle: 0x00000001
Service Class ID List:
        Browse Group Descriptor <span class=o>(</span>0x1001<span class=o>)</span>

Record Handle: 0x00000002
Service Class ID List:
        LAN Access Using PPP <span class=o>(</span>0x1102<span class=o>)</span>
Protocol Descriptor List:
        L2CAP <span class=o>(</span>0x0100<span class=o>)</span>
        RFCOMM <span class=o>(</span>0x0003<span class=o>)</span>
                Protocol specific parameter <span class=c>#1: u/int8/bool 1</span>
Bluetooth Profile Descriptor List:
        LAN Access Using PPP <span class=o>(</span>0x1102<span class=o>)</span> ver. 1.0</code></pre></div></div><div class=paragraph><p>Observe que cada serviço tem uma lista de atributos, como o canal RFCOMM. Dependendo do serviço, o usuário pode precisar anotar alguns dos atributos. Algumas implementações Bluetooth não suportam a navegação de serviço e podem retornar uma lista vazia. Nesse caso, é possível procurar pelo serviço específico. O exemplo abaixo mostra como pesquisar o serviço OBEX Object Push (OPUSH) :</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% sdpcontrol <span class=nt>-a</span> 00:01:03:fc:6e:ec search OPUSH</code></pre></div></div><div class=paragraph><p>A oferta de serviços no FreeBSD para clientes Bluetooth é feita com o servidor <a href="https://man.freebsd.org/cgi/man.cgi?query=sdpd&amp;sektion=8&amp;format=html">sdpd(8)</a>. A seguinte linha pode ser adicionada ao <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>sdpd_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Então o daemon <a href="https://man.freebsd.org/cgi/man.cgi?query=sdpd&amp;sektion=8&amp;format=html">sdpd(8)</a> pode ser iniciado com:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service sdpd start</span></code></pre></div></div><div class=paragraph><p>O aplicativo de servidor local que deseja fornecer um serviço Bluetooth a clientes remotos registrará o serviço com o daemon SDP local . Um exemplo de tal aplicativo é o <a href="https://man.freebsd.org/cgi/man.cgi?query=rfcomm_pppd&amp;sektion=8&amp;format=html">rfcomm_pppd(8)</a>. Uma vez iniciado, ele registrará o serviço LAN Bluetooth com o daemon local SDP.</p></div><div class=paragraph><p>A lista de serviços registrados no servidor SDPlocal pode ser obtida através da emissão de uma consulta de navegação SDP através do canal de controle local:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sdpcontrol -l browse</span></code></pre></div></div></div><div class=sect4><h5 id=_obex_object_push_opush>31.5.5.4. OBEX Object Push (OPUSH)<a class=anchor href=#_obex_object_push_opush></a></h5><div class=paragraph><p>Object Exchange (OBEX) é um protocolo amplamente utilizado para transferências de arquivos simples entre dispositivos móveis. Seu principal uso é na comunicação por infravermelho, onde é usado para transferências de arquivos genéricos entre notebooks ou PDAs, e para enviar cartões de visita ou entradas de calendário entre telefones celulares e outros dispositivos com Personal Information Manager (PIM).</p></div><div class=paragraph><p>O servidor e o cliente OBEX são implementados pelo obexapp, que pode ser instalado usando o pacote ou port <a class=package href=https://cgit.freebsd.org/ports/tree/comms/obexapp/>comms/obexapp</a>.</p></div><div class=paragraph><p>O cliente OBEX é usado para empurrar e/ou puxar objetos do servidor OBEX. Um exemplo de objeto é um cartão de visita ou um compromisso. O cliente OBEX pode obter o número do canal RFCOMM do dispositivo remoto via SDP. Isso pode ser feito especificando o nome do serviço em vez do número do canal RFCOMM. Os nomes de serviços suportados são: <code>IrMC</code>, <code>FTRN</code> e <code>OPUSH</code>. Também é possível especificar o canal RFCOMM como um número. Abaixo está um exemplo de uma sessão OBEX em que o objeto de informações do dispositivo é extraído do telefone celular e um novo objeto, o cartão de visita, é inserido no diretório do telefone.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% obexapp <span class=nt>-a</span> 00:80:37:29:19:a4 <span class=nt>-C</span> IrMC
obex&gt; get telecom/devinfo.txt devinfo-t39.txt
Success, response: OK, Success <span class=o>(</span>0x20<span class=o>)</span>
obex&gt; put new.vcf
Success, response: OK, Success <span class=o>(</span>0x20<span class=o>)</span>
obex&gt; di
Success, response: OK, Success <span class=o>(</span>0x20<span class=o>)</span></code></pre></div></div><div class=paragraph><p>Para fornecer o serviço OPUSH, o <a href="https://man.freebsd.org/cgi/man.cgi?query=sdpd&amp;sektion=8&amp;format=html">sdpd(8)</a> deve estar em execução e uma pasta raiz, onde todos os objetos recebidos serão armazenados, deve ser criado. O caminho padrão para a pasta raiz é <span class=filename>/var/spool/obex</span>. Por fim, inicie o servidor OBEX em um número de canal RFCOMM válido. O servidor OBEX registrará automaticamente o serviço OPUSH com o daemon SDP local. O exemplo abaixo mostra como iniciar o servidor OBEX.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># obexapp -s -C 10</span></code></pre></div></div></div><div class=sect4><h5 id=_perfil_de_porta_serial_spp>31.5.5.5. Perfil de porta serial (SPP)<a class=anchor href=#_perfil_de_porta_serial_spp></a></h5><div class=paragraph><p>O perfil de porta serial (SPP) permite que dispositivos Bluetooth executem emulação de cabo serial. Este perfil permite que aplicativos legados usem o Bluetooth como um substituto de cabos, através de uma abstração de porta serial virtual.</p></div><div class=paragraph><p>No FreeBSD, o <a href="https://man.freebsd.org/cgi/man.cgi?query=rfcomm_sppd&amp;sektion=1&amp;format=html">rfcomm_sppd(1)</a> implementa o SPP e uma pseudo tty é usada como uma abstração de porta serial virtual. O exemplo abaixo mostra como se conectar ao serviço de porta serial de um dispositivo remoto. Um canal RFCOMM não precisa ser especificado uma vez que o <a href="https://man.freebsd.org/cgi/man.cgi?query=rfcomm_sppd&amp;sektion=1&amp;format=html">rfcomm_sppd(1)</a> pode obtê-lo a partir do dispositivo remoto via SDP. Para sobrescrever isso, especifique um canal RFCOMM na linha de comando.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># rfcomm_sppd -a 00:07:E0:00:0B:CA -t</span>
rfcomm_sppd[94692]: Starting on /dev/pts/6...
/dev/pts/6</code></pre></div></div><div class=paragraph><p>Uma vez conectado, o pseudo-tty pode ser usado como porta serial:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cu -l /dev/pts/6</span></code></pre></div></div><div class=paragraph><p>A pseudo-tty é impressa no stdout e pode ser lida por scripts de wrapper:</p></div><div class="literalblock programlisting"><div class=content><pre>PTS=`rfcomm_sppd -a 00:07:E0:00:0B:CA -t`
cu -l $PTS</pre></div></div></div></div><div class=sect3><h4 id=_solução_de_problemas_6>31.5.6. Solução de problemas<a class=anchor href=#_solução_de_problemas_6></a></h4><div class=paragraph><p>Por padrão, quando o FreeBSD está aceitando uma nova conexão, ele tenta executar uma troca de função e se tornar o mestre. Alguns dispositivos Bluetooth mais antigos que não suportam a troca de função não poderão se conectar. Como a troca de função é executada quando uma nova conexão está sendo estabelecida, não é possível perguntar ao dispositivo remoto se ele suporta a troca de função. No entanto, há uma opção HCI para desativar a alternância de funções no lado local:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># hccontrol -n ubt0hci write_node_role_switch 0</span></code></pre></div></div><div class=paragraph><p>Para exibir pacotes Bluetooth, use o pacote de terceiros hcidump, que pode ser instalado usando o pacote ou port <a class=package href=https://cgit.freebsd.org/ports/tree/comms/hcidump/>comms/hcidump</a>. Este utilitário é semelhante ao <a href="https://man.freebsd.org/cgi/man.cgi?query=tcpdump&amp;sektion=1&amp;format=html">tcpdump(1)</a> e pode ser usado para exibir o conteúdo dos pacotes Bluetooth no terminal e para descarregar os pacotes Bluetooth para um arquivo.</p></div></div></div><div class=sect2><h3 id=network-bridging>31.6. Bridging<a class=anchor href=#network-bridging></a></h3><div class=paragraph><p>Às vezes, é útil dividir uma rede, como um segmento Ethernet, em segmentos de rede sem precisar criar subnets IP e usar um roteador para conectar os segmentos. Um dispositivo que conecta duas redes dessa maneira é chamado de "bridge".</p></div><div class=paragraph><p>Uma bridge funciona aprendendo os endereços MAC dos dispositivos em cada uma das suas interfaces de rede. Ele encaminha o tráfego entre as redes somente quando os endereços de origem e destino MAC estão em redes diferentes. Em muitos aspectos, uma brifge é como um switch Ethernet com poucas portas. Um sistema FreeBSD com múltiplas interfaces de rede pode ser configurado para atuar como uma bridge.</p></div><div class=paragraph><p>Construir uma bridge pode ser útil nas seguintes situações:</p></div><div class=dlist><dl><dt class=hdlist1>Conectar Redes</dt><dd><p>A operação básica de uma bridge é unir dois ou mais segmentos de rede. Existem muitas razões para usar uma bridge baseada em host em vez de equipamentos de rede, tais como restrições de cabeamento ou firewall. Uma bridge também pode conectar uma interface sem fio em execução no modo hostap a uma rede com fio e atuar como um ponto de acesso.</p></dd><dt class=hdlist1>Firewall de Filtragem / Limitação de Trafego</dt><dd><p>Uma bridge pode ser usada quando a funcionalidade de firewall é necessária sem a realização de roteamento ou conversão de endereços de rede (NAT).</p><div class=paragraph><p>Um exemplo é uma pequena empresa conectada via DSL ou ISDN a um ISP. Existem treze endereços IP públicos do ISP e dez computadores na rede. Nessa situação, é difícil usar um firewall baseado em roteador devido a problemas de sub-rede. Um firewall baseado em bridge pode ser configurado sem qualquer problema de endereçamento IP.</p></div></dd><dt class=hdlist1>Inspeção de Rede</dt><dd><p>Uma bridge pode unir dois segmentos de rede para inspecionar todos os pacotes Ethernet que passam entre elas usando <a href="https://man.freebsd.org/cgi/man.cgi?query=bpf&amp;sektion=4&amp;format=html">bpf(4)</a> e <a href="https://man.freebsd.org/cgi/man.cgi?query=tcpdump&amp;sektion=1&amp;format=html">tcpdump(1)</a> na interface de bridge ou enviando uma cópia de todos os frames para uma interface adicional conhecida como span port.</p></dd><dt class=hdlist1>VPN de Camada 2</dt><dd><p>Duas redes Ethernet podem ser unidas através de um link IP ligando as redes a um túnel EtherIP ou a uma solução baseada no <a href="https://man.freebsd.org/cgi/man.cgi?query=tap&amp;sektion=4&amp;format=html">tap(4)</a> tal como o OpenVPN.</p></dd><dt class=hdlist1>Redundância de Camada 2</dt><dd><p>Uma rede pode ser conectada com vários links e usar o protocolo Spanning Tree (STP) para bloquear caminhos redundantes.</p></dd></dl></div><div class=paragraph><p>Esta seção descreve como configurar um sistema FreeBSD como uma bridge usando o <a href="https://man.freebsd.org/cgi/man.cgi?query=if_bridge&amp;sektion=4&amp;format=html">if_bridge(4)</a>. Um driver de bridge netgraph também está disponível e é descrito em <a href="https://man.freebsd.org/cgi/man.cgi?query=ng_bridge&amp;sektion=4&amp;format=html">ng_bridge(4)</a>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>A filtragem de pacotes pode ser usada com qualquer pacote de firewall que se conecte ao framework <a href="https://man.freebsd.org/cgi/man.cgi?query=pfil&amp;sektion=9&amp;format=html">pfil(9)</a>. A bridge pode ser usada como um modelador de tráfego com o <a href="https://man.freebsd.org/cgi/man.cgi?query=altq&amp;sektion=4&amp;format=html">altq(4)</a> ou <a href="https://man.freebsd.org/cgi/man.cgi?query=dummynet&amp;sektion=4&amp;format=html">dummynet(4)</a>.</p></div></td></tr></tbody></table></div><div class=sect3><h4 id=_habilitando_a_bridge>31.6.1. Habilitando a Bridge<a class=anchor href=#_habilitando_a_bridge></a></h4><div class=paragraph><p>No FreeBSD, o <a href="https://man.freebsd.org/cgi/man.cgi?query=if_bridge&amp;sektion=4&amp;format=html">if_bridge(4)</a> é um módulo do kernel que é carregado automaticamente pelo <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a> ao criar uma interface de bridge. Também é possível compilar o suporte de bridge em um kernel customizado adicionando <code>device if_bridge</code> ao arquivo de configuração do kernel personalizado.</p></div><div class=paragraph><p>A bridge é criada usando clonagem de interface. Para criar a interface da bridge:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig bridge create</span>
bridge0
<span class=c># ifconfig bridge0</span>
bridge0: <span class=nv>flags</span><span class=o>=</span>8802&lt;BROADCAST,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        ether 96:3d:4b:f1:79:7a
        <span class=nb>id </span>00:00:00:00:00:00 priority 32768 hellotime 2 fwddelay 15
        maxage 20 holdcnt 6 proto rstp maxaddr 100 <span class=nb>timeout </span>1200
        root <span class=nb>id </span>00:00:00:00:00:00 priority 0 ifcost 0 port 0</code></pre></div></div><div class=paragraph><p>Quando uma interface de bridge é criada, ela recebe automaticamente um endereço Ethernet gerado aleatoriamente. Os parâmetros <code>maxaddr</code> e <code>timeout</code> controlam quantos endereços MAC a bridge manterá em sua tabela de encaminhamento e quantos segundos o sistema irá esperar antes de cada entrada ser removida após um endereço MAC ser visto pela última vez. Os outros parâmetros controlam como o STP opera.</p></div><div class=paragraph><p>Em seguida, especifique quais interfaces de rede adicionar como membros da bridge. Para a bridge encaminhar pacotes, todas as interfaces de membros e a bridge precisam estar ativas:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig bridge0 addm fxp0 addm fxp1 up</span>
<span class=c># ifconfig fxp0 up</span>
<span class=c># ifconfig fxp1 up</span></code></pre></div></div><div class=paragraph><p>A bridge agora pode encaminhar quadros Ethernet entre <span class=filename>fxp0</span> e <span class=filename>fxp1</span>. Adicione as seguintes linhas ao <span class=filename>/etc/rc.conf</span> para que a bridge seja criada na inicialização:</p></div><div class="literalblock programlisting"><div class=content><pre>cloned_interfaces=&#34;bridge0&#34;
ifconfig_bridge0=&#34;addm fxp0 addm fxp1 up&#34;
ifconfig_fxp0=&#34;up&#34;
ifconfig_fxp1=&#34;up&#34;</pre></div></div><div class=paragraph><p>Se o host de ponte precisar de um endereço IP, defina-o na interface de bridge, não nas interfaces de membro. O endereço pode ser definido estaticamente ou via DHCP. Este exemplo define um endereço IP estático:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig bridge0 inet 192.168.0.1/24</span></code></pre></div></div><div class=paragraph><p>Também é possível atribuir um endereço IPv6 a uma interface de bridge. Para tornar as mudanças permanentes, adicione as informações de endereçamento ao <span class=filename>/etc/rc.conf</span>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Quando a filtragem de pacotes está habilitada, os pacotes passarão pela entrada do filtro na interface de origem na interface da bridge e na saída nas interfaces apropriadas. Qualquer estágio pode ser desativado. Quando a direção do fluxo de pacotes é importante, é melhor usar o firewall nas interfaces de membros, em vez da própria bridge.</p></div><div class=paragraph><p>A bridge tem várias opções configuráveis para o trafego de pacotes IP e não-IP, e a filtragem de pacotes layer2 com o <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfw&amp;sektion=8&amp;format=html">ipfw(8)</a>. Veja <a href="https://man.freebsd.org/cgi/man.cgi?query=if_bridge&amp;sektion=4&amp;format=html">if_bridge(4)</a> para maiores informações.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=_ativando_o_spanning_tree>31.6.2. Ativando o Spanning Tree<a class=anchor href=#_ativando_o_spanning_tree></a></h4><div class=paragraph><p>Para que uma rede Ethernet funcione corretamente, somente um caminho ativo pode existir entre dois dispositivos. O protocolo STP detecta loops e coloca links redundantes em um estado bloqueado. Se um dos links ativos falhar, o STP calcula uma árvore diferente e habilita um dos caminhos bloqueados para restaurar a conectividade a todos os pontos da rede.</p></div><div class=paragraph><p>O protocolo Rapid Spanning Tree (RSTP ou 802.1w) fornece compatibilidade retroativa com o STP legado. O RSTP fornece uma convergência mais rápida e troca informações com os switches vizinhos para fazer a transição rápida para o modo de encaminhamento sem criar loops. O FreeBSD suporta o RSTP e o STP como modos de operação, com o RSTP sendo o modo padrão.</p></div><div class=paragraph><p>O STP pode ser ativado nas interfaces de membro usando o <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a>. Para uma bridge com <span class=filename>fxp0</span> e <span class=filename>fxp1</span> como as interfaces atuais, ative o STP com:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig bridge0 stp fxp0 stp fxp1</span>
bridge0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        ether d6:cf:d5:a0:94:6d
        <span class=nb>id </span>00:01:02:4b:d4:50 priority 32768 hellotime 2 fwddelay 15
        maxage 20 holdcnt 6 proto rstp maxaddr 100 <span class=nb>timeout </span>1200
        root <span class=nb>id </span>00:01:02:4b:d4:50 priority 32768 ifcost 0 port 0
        member: fxp0 <span class=nv>flags</span><span class=o>=</span>1c7&lt;LEARNING,DISCOVER,STP,AUTOEDGE,PTP,AUTOPTP&gt;
                port 3 priority 128 path cost 200000 proto rstp
                role designated state forwarding
        member: fxp1 <span class=nv>flags</span><span class=o>=</span>1c7&lt;LEARNING,DISCOVER,STP,AUTOEDGE,PTP,AUTOPTP&gt;
                port 4 priority 128 path cost 200000 proto rstp
                role designated state forwarding</code></pre></div></div><div class=paragraph><p>Essa ponte possui um spanning tree ID de <code>00:01:02:4b:d4:50</code> e uma prioridade de <code>32768</code>. Como o <code>root id</code> é o mesmo, indica que esta é a bridge raiz para a árvore.</p></div><div class=paragraph><p>Outra bridge na rede também tem o STP ativado:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>bridge0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        ether 96:3d:4b:f1:79:7a
        <span class=nb>id </span>00:13:d4:9a:06:7a priority 32768 hellotime 2 fwddelay 15
        maxage 20 holdcnt 6 proto rstp maxaddr 100 <span class=nb>timeout </span>1200
        root <span class=nb>id </span>00:01:02:4b:d4:50 priority 32768 ifcost 400000 port 4
        member: fxp0 <span class=nv>flags</span><span class=o>=</span>1c7&lt;LEARNING,DISCOVER,STP,AUTOEDGE,PTP,AUTOPTP&gt;
                port 4 priority 128 path cost 200000 proto rstp
                role root state forwarding
        member: fxp1 <span class=nv>flags</span><span class=o>=</span>1c7&lt;LEARNING,DISCOVER,STP,AUTOEDGE,PTP,AUTOPTP&gt;
                port 5 priority 128 path cost 200000 proto rstp
                role designated state forwarding</code></pre></div></div><div class=paragraph><p>A linha <code>root id 00:01:02:4b:d4:50 priority 32768 ifcost 400000 port 4</code> mostra que a bridge raiz é <code>00:01:02:4b:d4:50</code> e tem um custo de caminho de <code>400000</code> desta bridge. O caminho para a bridge raiz é via <code>port 4</code>, que é <span class=filename>fxp0</span>.</p></div></div><div class=sect3><h4 id=_parâmetros_da_interface_de_bridge>31.6.3. Parâmetros da Interface de Bridge<a class=anchor href=#_parâmetros_da_interface_de_bridge></a></h4><div class=paragraph><p>Vários parâmetros do <code>ifconfig</code> são exclusivos para interligar interfaces. Esta seção resume alguns usos comuns para esses parâmetros. A lista completa de parâmetros disponíveis é descrita em <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a>.</p></div><div class=dlist><dl><dt class=hdlist1>privado</dt><dd><p>Uma interface privada não encaminha qualquer tráfego para qualquer outra porta que também seja designada como uma interface privada. O tráfego é bloqueado incondicionalmente para que nenhum quadro Ethernet seja encaminhado, incluindo pacotes ARP. Se o tráfego precisar ser bloqueado seletivamente, um firewall deve ser usado no lugar.</p></dd><dt class=hdlist1>span</dt><dd><p>Uma porta span transmite uma cópia de cada quadro Ethernet recebido pela bridge. O número de portas de span configuradas em uma bridge é ilimitado, mas se uma interface for designada como uma porta de span, ela também não poderá ser usada como uma porta de bridge comum. Isso é mais útil para espionar passivamente uma rede em bridge a partir de outro host conectado a uma das portas da bridge. Por exemplo, para enviar uma cópia de todos os quadros para fora da interface denominada <span class=filename>fxp4</span>:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig bridge0 span fxp4</span></code></pre></div></div></dd><dt class=hdlist1>sticky</dt><dd><p>Se uma interface de membro de uma bridge estiver marcada como fixa, as entradas de endereço aprendidas dinamicamente serão tratadas como entradas estáticas no cache de encaminhamento. Entradas fixas nunca são eliminadas do cache ou substituídas, mesmo que o endereço seja visto em uma interface diferente. Isso oferece o benefício de entradas de endereço estático sem a necessidade de preencher previamente a tabela de encaminhamento. Os clientes aprendidos em um segmento específico da bridge não podem se deslocar para outro segmento.</p><div class=paragraph><p>Um exemplo do uso de endereços fixos é combinar a bridge com VLANs para isolar redes de clientes sem desperdiçar espaço de endereço IP. Considere que <code>CustomerA</code> está em <code>vlan100</code>, <code>CustomerB</code> está em <code>vlan101</code>, e a bridge tem o endereço <code>192.168.0.1</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig bridge0 addm vlan100 sticky vlan100 addm vlan101 sticky vlan101</span>
<span class=c># ifconfig bridge0 inet 192.168.0.1/24</span></code></pre></div></div><div class=paragraph><p>Neste exemplo, os dois clientes vêem <code>192.168.0.1</code> como seu gateway padrão. Como o cache da bridge é fixo, um host não pode falsificar o endereço MAC do outro cliente para interceptar o tráfego.</p></div><div class=paragraph><p>Qualquer comunicação entre as VLANs pode ser bloqueada usando um firewall ou, como visto neste exemplo, interfaces privadas:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig bridge0 private vlan100 private vlan101</span></code></pre></div></div><div class=paragraph><p>Os clientes são completamente isolados uns dos outros e o intervalo completo de endereços <code>/24</code> pode ser alocado sem criação de sub-redes.</p></div><div class=paragraph><p>O número de endereços MAC de origem exclusivos por trás de uma interface pode ser limitado. Quando o limite é atingido, os pacotes com endereços de origem desconhecidos são descartados até que uma entrada de cache do host existente expire ou seja removida.</p></div><div class=paragraph><p>O exemplo a seguir define o número máximo de dispositivos Ethernet para <code>CustomerA</code> em <code>vlan100</code> para 10:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig bridge0 ifmaxaddr vlan100 10</span></code></pre></div></div></dd></dl></div><div class=paragraph><p>As interfaces de bridge também suportam o modo monitor, onde os pacotes são descartados após processamento do <a href="https://man.freebsd.org/cgi/man.cgi?query=bpf&amp;sektion=4&amp;format=html">bpf(4)</a> e não são processados ou encaminhados. Isso pode ser usado para multiplexar a entrada de duas ou mais interfaces em um único fluxo <a href="https://man.freebsd.org/cgi/man.cgi?query=bpf&amp;sektion=4&amp;format=html">bpf(4)</a>. Isso é útil para reconstruir o tráfego de taps de rede que transmitem os sinais RX/TX através de duas interfaces separadas. Por exemplo, para ler a entrada de quatro interfaces de rede como um fluxo:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig bridge0 addm fxp0 addm fxp1 addm fxp2 addm fxp3 monitor up</span>
<span class=c># tcpdump -i bridge0</span></code></pre></div></div></div><div class=sect3><h4 id=_monitoramento_snmp>31.6.4. Monitoramento SNMP<a class=anchor href=#_monitoramento_snmp></a></h4><div class=paragraph><p>A interface de bridge e os parâmetros de STP podem ser monitorados via o <a href="https://man.freebsd.org/cgi/man.cgi?query=bsnmpd&amp;sektion=1&amp;format=html">bsnmpd(1)</a> o qual está incluído no sistema básico do FreeBSD. A MIB exportada da bridge está em conformidade com os padrões IETF, portanto, qualquer cliente ou pacote de monitoramento SNMP pode ser usado para recuperar os dados.</p></div><div class=paragraph><p>Para ativar o monitoramento na bridge, descomente esta linha em <span class=filename>/etc/snmpd.config</span> removendo o símbolo inicial <code>#</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>begemotSnmpdModulePath.&#34;bridge&#34; = &#34;/usr/lib/snmp_bridge.so&#34;</pre></div></div><div class=paragraph><p>Outras configurações, como nomes de comunidades e listas de acesso, podem precisar ser modificadas nesse arquivo. Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=bsnmpd&amp;sektion=1&amp;format=html">bsnmpd(1)</a> e <a href="https://man.freebsd.org/cgi/man.cgi?query=snmp_bridge&amp;sektion=3&amp;format=html">snmp_bridge(3)</a> para maiores informações. Depois que essas edições forem salvas, adicione esta linha ao <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>bsnmpd_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Em seguida, inicie o <a href="https://man.freebsd.org/cgi/man.cgi?query=bsnmpd&amp;sektion=1&amp;format=html">bsnmpd(1)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service bsnmpd start</span></code></pre></div></div><div class=paragraph><p>Os exemplos a seguir usam o software Net-SNMP (<a class=package href=https://cgit.freebsd.org/ports/tree/net-mgmt/net-snmp/>net-mgmt/net-snmp</a>) para consultar uma bridge a partir de um sistema cliente. O port <a class=package href=https://cgit.freebsd.org/ports/tree/net-mgmt/bsnmptools/>net-mgmt/bsnmptools</a> também pode ser usado. Do cliente SNMP que está executando o Net-SNMP, adicione as seguintes linhas ao <span class=filename>$HOME/.snmp/snmp.conf</span> para importar as definições da bridge MIB:</p></div><div class="literalblock programlisting"><div class=content><pre>mibdirs +/usr/shared/snmp/mibs
mibs +BRIDGE-MIB:RSTP-MIB:BEGEMOT-MIB:BEGEMOT-BRIDGE-MIB</pre></div></div><div class=paragraph><p>Para monitorar uma única bridge usando o IETF BRIDGE-MIB (RFC4188):</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% snmpwalk <span class=nt>-v</span> 2c <span class=nt>-c</span> public bridge1.example.com mib-2.dot1dBridge
BRIDGE-MIB::dot1dBaseBridgeAddress.0 <span class=o>=</span> STRING: 66:fb:9b:6e:5c:44
BRIDGE-MIB::dot1dBaseNumPorts.0 <span class=o>=</span> INTEGER: 1 ports
BRIDGE-MIB::dot1dStpTimeSinceTopologyChange.0 <span class=o>=</span> Timeticks: <span class=o>(</span>189959<span class=o>)</span> 0:31:39.59 centi-seconds
BRIDGE-MIB::dot1dStpTopChanges.0 <span class=o>=</span> Counter32: 2
BRIDGE-MIB::dot1dStpDesignatedRoot.0 <span class=o>=</span> Hex-STRING: 80 00 00 01 02 4B D4 50
...
BRIDGE-MIB::dot1dStpPortState.3 <span class=o>=</span> INTEGER: forwarding<span class=o>(</span>5<span class=o>)</span>
BRIDGE-MIB::dot1dStpPortEnable.3 <span class=o>=</span> INTEGER: enabled<span class=o>(</span>1<span class=o>)</span>
BRIDGE-MIB::dot1dStpPortPathCost.3 <span class=o>=</span> INTEGER: 200000
BRIDGE-MIB::dot1dStpPortDesignatedRoot.3 <span class=o>=</span> Hex-STRING: 80 00 00 01 02 4B D4 50
BRIDGE-MIB::dot1dStpPortDesignatedCost.3 <span class=o>=</span> INTEGER: 0
BRIDGE-MIB::dot1dStpPortDesignatedBridge.3 <span class=o>=</span> Hex-STRING: 80 00 00 01 02 4B D4 50
BRIDGE-MIB::dot1dStpPortDesignatedPort.3 <span class=o>=</span> Hex-STRING: 03 80
BRIDGE-MIB::dot1dStpPortForwardTransitions.3 <span class=o>=</span> Counter32: 1
RSTP-MIB::dot1dStpVersion.0 <span class=o>=</span> INTEGER: rstp<span class=o>(</span>2<span class=o>)</span></code></pre></div></div><div class=paragraph><p>O valor <code>dot1dStpTopChanges.0</code> é dois, indicando que a topologia da bridge STP foi alterada duas vezes. Uma alteração de topologia significa que um ou mais links na rede foram alterados ou falharam e uma nova árvore foi calculada. O valor de <code>dot1dStpTimeSinceTopologyChange.0</code> será exibido quando isso acontecer.</p></div><div class=paragraph><p>Para monitorar várias interfaces de bridge, o BEGEMOT-BRIDGE-MIB privado pode ser usado:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% snmpwalk <span class=nt>-v</span> 2c <span class=nt>-c</span> public bridge1.example.com
enterprises.fokus.begemot.begemotBridge
BEGEMOT-BRIDGE-MIB::begemotBridgeBaseName.<span class=s2>&#34;bridge0&#34;</span> <span class=o>=</span> STRING: bridge0
BEGEMOT-BRIDGE-MIB::begemotBridgeBaseName.<span class=s2>&#34;bridge2&#34;</span> <span class=o>=</span> STRING: bridge2
BEGEMOT-BRIDGE-MIB::begemotBridgeBaseAddress.<span class=s2>&#34;bridge0&#34;</span> <span class=o>=</span> STRING: e:ce:3b:5a:9e:13
BEGEMOT-BRIDGE-MIB::begemotBridgeBaseAddress.<span class=s2>&#34;bridge2&#34;</span> <span class=o>=</span> STRING: 12:5e:4d:74:d:fc
BEGEMOT-BRIDGE-MIB::begemotBridgeBaseNumPorts.<span class=s2>&#34;bridge0&#34;</span> <span class=o>=</span> INTEGER: 1
BEGEMOT-BRIDGE-MIB::begemotBridgeBaseNumPorts.<span class=s2>&#34;bridge2&#34;</span> <span class=o>=</span> INTEGER: 1
...
BEGEMOT-BRIDGE-MIB::begemotBridgeStpTimeSinceTopologyChange.<span class=s2>&#34;bridge0&#34;</span> <span class=o>=</span> Timeticks: <span class=o>(</span>116927<span class=o>)</span> 0:19:29.27 centi-seconds
BEGEMOT-BRIDGE-MIB::begemotBridgeStpTimeSinceTopologyChange.<span class=s2>&#34;bridge2&#34;</span> <span class=o>=</span> Timeticks: <span class=o>(</span>82773<span class=o>)</span> 0:13:47.73 centi-seconds
BEGEMOT-BRIDGE-MIB::begemotBridgeStpTopChanges.<span class=s2>&#34;bridge0&#34;</span> <span class=o>=</span> Counter32: 1
BEGEMOT-BRIDGE-MIB::begemotBridgeStpTopChanges.<span class=s2>&#34;bridge2&#34;</span> <span class=o>=</span> Counter32: 1
BEGEMOT-BRIDGE-MIB::begemotBridgeStpDesignatedRoot.<span class=s2>&#34;bridge0&#34;</span> <span class=o>=</span> Hex-STRING: 80 00 00 40 95 30 5E 31
BEGEMOT-BRIDGE-MIB::begemotBridgeStpDesignatedRoot.<span class=s2>&#34;bridge2&#34;</span> <span class=o>=</span> Hex-STRING: 80 00 00 50 8B B8 C6 A9</code></pre></div></div><div class=paragraph><p>Para alterar a interface da bridge que está sendo monitorada através da subárvore <code>mib-2.dot1dBridge</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% snmpset <span class=nt>-v</span> 2c <span class=nt>-c</span> private bridge1.example.com
BEGEMOT-BRIDGE-MIB::begemotBridgeDefaultBridgeIf.0 s bridge2</code></pre></div></div></div></div><div class=sect2><h3 id=network-aggregation>31.7. Agregação de links e failover<a class=anchor href=#network-aggregation></a></h3><div class=paragraph><p>O FreeBSD fornece a interface <a href="https://man.freebsd.org/cgi/man.cgi?query=lagg&amp;sektion=4&amp;format=html">lagg(4)</a> que pode ser usada para agregar várias interfaces de rede em uma interface virtual para fornecer failover e agregação de links. O failover permite que o tráfego continue a fluir, desde que pelo menos uma interface de rede agregada tenha um link estabelecido. A agregação de links funciona melhor em switches compatíveis com LACP, pois esse protocolo distribui o tráfego bidirecionalmente ao responder à falha de links individuais.</p></div><div class=paragraph><p>Os protocolos de agregação suportados pela interface lagg determinam quais portas são usadas para o tráfego de saída e se uma porta específica aceita tráfego de entrada. Os seguintes protocolos são suportados pelo <a href="https://man.freebsd.org/cgi/man.cgi?query=lagg&amp;sektion=4&amp;format=html">lagg(4)</a>:</p></div><div class=dlist><dl><dt class=hdlist1>failover</dt><dd><p>Este modo envia e recebe tráfego somente através da porta principal. Se a porta principal ficar indisponível, a próxima porta ativa será usada. A primeira interface adicionada à interface virtual é a porta principal e todas as interfaces adicionadas posteriormente são usadas como dispositivos de failover. Se ocorrer um failover em uma porta não mestre, a porta original se tornará a principal quando estiver disponível novamente.</p></dd><dt class=hdlist1>fec / loadbalance</dt><dd><p>Cisco™ Fast EtherChannel™ (FEC) é encontrado em versões anteriores de switches Cisco ™. Ele fornece uma configuração estática e não negocia a agregação com o par ou troca quadros para monitorar o link. Se o switch suportar LACP, isso deve ser usado em seu lugar.</p></dd><dt class=hdlist1>lacp</dt><dd><p>O protocolo de controle de agregação de links IEEE™ 802.3ad (LACP) negocia um conjunto de links agregáveis com o peer em um ou mais grupos agregados de links (LAGs). Cada LAG é composto de portas da mesma velocidade, configuradas para operação full-duplex e o tráfego é balanceado entre as portas no LAG com a maior velocidade total. Normalmente, há apenas um LAG que contém todas as portas. No caso de alterações na conectividade física, o LACP convergirá rapidamente para uma nova configuração.</p><div class=paragraph><p>O LACP equilibra o tráfego de saída nas portas ativas com base nas informações de hash do cabeçalho do protocolo e aceita tráfego de entrada de qualquer porta ativa. O hash inclui o endereço Ethernet de origem e destino e, se disponível, a tag VLAN e o endereço de origem e destino IPv4 ou IPv6.</p></div></dd><dt class=hdlist1>roundrobin</dt><dd><p>Esse modo distribui o tráfego de saída usando um agendador round-robin por meio de todas as portas ativas e aceita tráfego de entrada de qualquer porta ativa. Como esse modo viola a ordenação de quadros Ethernet, ele deve ser usado com cautela.</p></dd></dl></div><div class=sect3><h4 id=_exemplos_de_configuração>31.7.1. Exemplos de configuração<a class=anchor href=#_exemplos_de_configuração></a></h4><div class=paragraph><p>Esta seção demonstra como configurar um switch Cisco™ e um sistema FreeBSD para balanceamento de carga LACP. Em seguida, ele mostra como configurar duas interfaces Ethernet no modo de failover, além de como configurar o modo de failover entre uma Ethernet e uma interface sem fio.</p></div><div id=networking-lacp-aggregation-cisco class=exampleblock><div class=title>Exemplo 48. Agregação LACP com um switch Cisco™</div><div class=content><div class=paragraph><p>Este exemplo conecta duas interfaces Ethernet <a href="https://man.freebsd.org/cgi/man.cgi?query=fxp&amp;sektion=4&amp;format=html">fxp(4)</a> em uma máquina FreeBSD às duas primeiras portas Ethernet em um switch Cisco™ como um link de carga única balanceada e tolerante a falhas. Mais interfaces podem ser adicionadas para aumentar o rendimento e a tolerância a falhas. Substitua os nomes das portas Cisco™, dos dispositivos Ethernet, do número do grupo de canais e do endereço IP mostrado no exemplo para corresponder à configuração local.</p></div><div class=paragraph><p>A ordenação de quadros é obrigatória em links Ethernet e qualquer tráfego entre duas estações sempre flui pelo mesmo link físico, limitando a velocidade máxima àquela de uma interface. O algoritmo de transmissão tenta usar o máximo de informações possível para distinguir diferentes fluxos de tráfego e equilibrar os fluxos entre as interfaces disponíveis.</p></div><div class=paragraph><p>No switch Cisco™, adicione as interfaces <em>FastEthernet0/1</em> e <em>FastEthernet0/2</em> ao grupo de canais <em>1</em>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> interface FastEthernet0/1
 channel-group 1 mode active
 channel-protocol lacp
<span class=o>!</span>
interface FastEthernet0/2
 channel-group 1 mode active
 channel-protocol lacp</code></pre></div></div><div class=paragraph><p>No sistema FreeBSD, crie a interface <a href="https://man.freebsd.org/cgi/man.cgi?query=lagg&amp;sektion=4&amp;format=html">lagg(4)</a> usando as interfaces físicas <em>fxp0</em> e <em>fxp1</em> e suba as interfaces com o endereço IP de <em>10.0.0.3/24</em>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig fxp0 up</span>
<span class=c># ifconfig fxp1 up</span>
<span class=c># ifconfig lagg0 create</span>
<span class=c># ifconfig lagg0 up laggproto lacp laggport fxp0 laggport fxp1 10.0.0.3/24</span></code></pre></div></div><div class=paragraph><p>Em seguida, verifique o status da interface virtual:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig lagg0</span>
lagg0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        <span class=nv>options</span><span class=o>=</span>8&lt;VLAN_MTU&gt;
        ether 00:05:5d:71:8d:b8
        inet 10.0.0.3 netmask 0xffffff00 broadcast 10.0.0.255
        media: Ethernet autoselect
        status: active
        laggproto lacp
        laggport: fxp1 <span class=nv>flags</span><span class=o>=</span>1c&lt;ACTIVE,COLLECTING,DISTRIBUTING&gt;
        laggport: fxp0 <span class=nv>flags</span><span class=o>=</span>1c&lt;ACTIVE,COLLECTING,DISTRIBUTING&gt;</code></pre></div></div><div class=paragraph><p>Portas marcadas como <code>ACTIVE</code> fazem parte do LAG que foi negociado com o switch remoto. O tráfego será transmitido e recebido através dessas portas ativas. Adicione <code>-v</code> ao comando acima para ver os identificadores LAG.</p></div><div class=paragraph><p>Para ver o status da porta no switch Cisco™:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>switch# show lacp neighbor
Flags:  S - Device is requesting Slow LACPDUs
        F - Device is requesting Fast LACPDUs
        A - Device is <span class=k>in </span>Active mode       P - Device is <span class=k>in </span>Passive mode

Channel group 1 neighbors

Partner<span class=s1>&#39;s information:

                  LACP port                        Oper    Port     Port
Port      Flags   Priority  Dev ID         Age     Key     Number   State
Fa0/1     SA      32768     0005.5d71.8db8  29s    0x146   0x3      0x3D
Fa0/2     SA      32768     0005.5d71.8db8  29s    0x146   0x4      0x3D</span></code></pre></div></div><div class=paragraph><p>Para mais detalhes, digite <code>show lacp neighbor detail</code>.</p></div><div class=paragraph><p>Para manter esta configuração através de reinicializações, adicione as seguintes entradas ao <span class=filename>/etc/rc.conf</span> no sistema FreeBSD:</p></div><div class="literalblock programlisting"><div class=content><pre>ifconfig_fxp0=&#34;up&#34;
ifconfig_fxp1=&#34;up&#34;
cloned_interfaces=&#34;lagg0&#34;
ifconfig_lagg0=&#34;laggproto lacp laggport fxp0 laggport fxp1 10.0.0.3/24&#34;</pre></div></div></div></div><div id=networking-lagg-failover class=exampleblock><div class=title>Exemplo 49. Modo de Failover</div><div class=content><div class=paragraph><p>O modo de failover pode ser usado para alternar para uma interface secundária se o link for perdido na interface principal. Para configurar o failover, certifique-se de que as interfaces físicas subjacentes estejam ativadas e crie a interface <a href="https://man.freebsd.org/cgi/man.cgi?query=lagg&amp;sektion=4&amp;format=html">lagg(4)</a>. Neste exemplo, <em>fxp0</em> é a interface principal, <em>fxp1</em> é a interface secundária e a interface virtual recebeu um endereço IP de <em>10.0.0.15/24</em>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig fxp0 up</span>
<span class=c># ifconfig fxp1 up</span>
<span class=c># ifconfig lagg0 create</span>
<span class=c># ifconfig lagg0 up laggproto failover laggport fxp0 laggport fxp1 10.0.0.15/24</span></code></pre></div></div><div class=paragraph><p>A interface virtual deve ser algo como isto:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig lagg0</span>
lagg0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        <span class=nv>options</span><span class=o>=</span>8&lt;VLAN_MTU&gt;
        ether 00:05:5d:71:8d:b8
        inet 10.0.0.15 netmask 0xffffff00 broadcast 10.0.0.255
        media: Ethernet autoselect
        status: active
        laggproto failover
        laggport: fxp1 <span class=nv>flags</span><span class=o>=</span>0&lt;<span class=o>&gt;</span>
        laggport: fxp0 <span class=nv>flags</span><span class=o>=</span>5&lt;MASTER,ACTIVE&gt;</code></pre></div></div><div class=paragraph><p>O tráfego será transmitido e recebido em <em>fxp0</em>. Se o link for perdido em <em>fxp0</em>, <em>fxp1</em> se tornará o link ativo. Se o link for restaurado na interface principal, ele se tornará novamente o link ativo.</p></div><div class=paragraph><p>Para manter essa configuração através de reinicializações, adicione as seguintes entradas ao <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>ifconfig_fxp0=&#34;up&#34;
ifconfig_fxp1=&#34;up&#34;
cloned_interfaces=&#34;lagg0&#34;
ifconfig_lagg0=&#34;laggproto failover laggport fxp0 laggport fxp1 10.0.0.15/24&#34;</pre></div></div></div></div><div id=networking-lagg-wired-and-wireless class=exampleblock><div class=title>Exemplo 50. Modo de failover entre interfaces Ethernet e sem fio</div><div class=content><div class=paragraph><p>Para usuários de laptop, geralmente é desejável configurar o dispositivo sem fio como secundário, que é usado somente quando a conexão Ethernet não está disponível. Com <a href="https://man.freebsd.org/cgi/man.cgi?query=lagg&amp;sektion=4&amp;format=html">lagg(4)</a>, é possível configurar um failover que preferia a conexão Ethernet por motivos de desempenho e de segurança, mantendo a capacidade de transferência dados através da conexão sem fio.</p></div><div class=paragraph><p>Isso é obtido substituindo o endereço MAC da interface Ethernet com o da interface wireless.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Em teoria, o endereço MAC da Ethernet ou da wireless pode ser alterado para corresponder ao outro. No entanto, algumas interfaces wireless populares não têm suporte para substituir o endereço MAC. Portanto, recomendamos substituir o endereço MAC da Ethernet para esse fim.</p></div></td></tr></tbody></table></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Se o driver para a interface wireless não estiver carregado no kernel <code>GENERIC</code> ou customizado, e o computador estiver rodando o FreeBSD 12.1, carregue o <span class=filename>.ko</span> correspondente no arquivo <span class=filename>/boot/loader.conf</span> adicionando <code>_driver__load="YES"</code> e reiniciando a maquina. Outra forma melhor, é carregar o driver no arquivo <span class=filename>/etc/rc.conf</span> adicionando a variável <code>kld_list</code> (veja <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a> para maiores detalhes) nesse arquivo e reiniciar. Isso é necessário porque de outra forma o driver não estará carregado no tempo em que a interface <a href="https://man.freebsd.org/cgi/man.cgi?query=lagg&amp;sektion=4&amp;format=html">lagg(4)</a> for configurada.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Neste exemplo, a interface Ethernet, <em>re0</em>, é a interface principal e a interface sem fio, <em>wlan0</em>, é o failover. A interface <em>wlan0</em> foi criada a partir da interface wireless <em>ath0</em>, e a interface Ethernet será configurada com o endereço MAC da interface wireless. Primeiro, determine o endereço MAC da interface wireless:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0</span>
wlan0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
	ether b8:ee:65:5b:32:59
	<span class=nb>groups</span>: wlan
	ssid Bbox-A3BD2403 channel 6 <span class=o>(</span>2437 MHz 11g ht/20<span class=o>)</span> bssid 00:37:b7:56:4b:60
	regdomain ETSI country FR indoor ecm authmode WPA2/802.11i privacy ON
	deftxkey UNDEF AES-CCM 2:128-bit txpower 30 bmiss 7 scanvalid 60
	protmode CTS ampdulimit 64k ampdudensity 8 shortgi <span class=nt>-stbctx</span> stbcrx
	<span class=nt>-ldpc</span> wme burst roaming MANUAL
	media: IEEE 802.11 Wireless Ethernet MCS mode 11ng
	status: associated
	nd6 <span class=nv>options</span><span class=o>=</span>29&lt;PERFORMNUD,IFDISABLED,AUTO_LINKLOCAL&gt;</code></pre></div></div><div class=paragraph><p>Substitua <em>wlan0</em> para corresponder ao nome da interface wireless do sistema. A linha <code>ether</code> conterá o endereço MAC da interface especificada. Agora, altere o endereço MAC da interface Ethernet subjacente:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig re0 ether b8:ee:65:5b:32:59</span></code></pre></div></div><div class=paragraph><p>Suba a interface sem fio (substituindo <em>FR</em> pelo seu próprio código de país com duas letras), mas não defina um endereço IP:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0 create wlandev ath0 country FR ssid my_router up</span></code></pre></div></div><div class=paragraph><p>Certifique-se de que a interface <em>re0</em> esteja ativa, então crie a interface <a href="https://man.freebsd.org/cgi/man.cgi?query=lagg&amp;sektion=4&amp;format=html">lagg(4)</a> com a <em>re0</em> como master com failover para a_wlan0_:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig re0 up</span>
<span class=c># ifconfig lagg0 create</span>
<span class=c># ifconfig lagg0 up laggproto failover laggport re0 laggport wlan0</span></code></pre></div></div><div class=paragraph><p>A interface virtual deve ser algo como isto:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig lagg0</span>
lagg0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        <span class=nv>options</span><span class=o>=</span>8&lt;VLAN_MTU&gt;
        ether b8:ee:65:5b:32:59
        laggproto failover lagghash l2,l3,l4
        laggport: re0 <span class=nv>flags</span><span class=o>=</span>5&lt;MASTER,ACTIVE&gt;
        laggport: wlan0 <span class=nv>flags</span><span class=o>=</span>0&lt;<span class=o>&gt;</span>
        <span class=nb>groups</span>: lagg
        media: Ethernet autoselect
        status: active</code></pre></div></div><div class=paragraph><p>Em seguida, inicie o cliente DHCP para obter um endereço IP:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dhclient lagg0</span></code></pre></div></div><div class=paragraph><p>Para manter essa configuração através de reinicializações, adicione as seguintes entradas ao <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>ifconfig_re0=&#34;ether b8:ee:65:5b:32:59&#34;
wlans_ath0=&#34;wlan0&#34;
ifconfig_wlan0=&#34;WPA&#34;
create_args_wlan0=&#34;country FR&#34;
cloned_interfaces=&#34;lagg0&#34;
ifconfig_lagg0=&#34;up laggproto failover laggport re0 laggport wlan0 DHCP&#34;</pre></div></div></div></div></div></div><div class=sect2><h3 id=network-diskless>31.8. Operação Diskless com PXE<a class=anchor href=#network-diskless></a></h3><div class=paragraph><p>O Ambiente de execução de pré-inicialização da Intel™ (PXE) permite que um sistema operacional inicialize pela rede. Por exemplo, um sistema FreeBSD pode inicializar através da rede e operar sem um disco local, usando sistemas de arquivos montados a partir de um servidor NFS. O suporte para PXE geralmente está disponível no BIOS. Para usar o PXE quando a máquina iniciar, selecione a opção <code>Inicialização da rede</code> na configuração do BIOS ou digite uma tecla de função durante a inicialização do sistema.</p></div><div class=paragraph><p>Para fornecer os arquivos necessários para um sistema operacional inicializar pela rede, uma configuração do PXE também requer o DHCP, TFTP configurado corretamente e Servidores NFS, onde:</p></div><div class=ulist><ul><li><p>Parâmetros iniciais, como endereço de IP, nome e localização do arquivo de inicialização executável, nome do servidor e caminho do root são obtidos do servidor DHCP.</p></li><li><p>O arquivo do carregador do sistema operacional é inicializado usando TFTP.</p></li><li><p>Os sistemas de arquivos são carregados usando o NFS.</p></li></ul></div><div class=paragraph><p>Quando um computador PXE inicializa, ele recebe informações por meio do DHCP sobre onde obter o arquivo inicial do carregador de boot. Depois que o computador host recebe essa informação, ele faz o download do carregador de boot via TFTP e, em seguida, executa o carregador de boot. No FreeBSD, o arquivo do gerenciador de boot é o <span class=filename>/boot/pxeboot</span>. Depois que o <span class=filename>/boot/pxeboot</span> é executado, o kernel do FreeBSD é carregado e o resto da seqüência de inicialização do FreeBSD continua, como descrito em <a href=./#boot>O processo de inicialização do FreeBSD</a>.</p></div><div class=paragraph><p>Esta seção descreve como configurar estes serviços em um sistema FreeBSD para que outros sistemas possam inicializar o PXE a partir do FreeBSD. Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=diskless&amp;sektion=8&amp;format=html">diskless(8)</a> para obter maiores informações.</p></div><div class="admonitionblock caution"><table><tbody><tr><td class=icon><i class="fa icon-caution" title=Caution></i></td><td class=content><div class=paragraph><p>Conforme descrito, o sistema que fornece esses serviços é inseguro. Ele deve ficar em uma área protegida de uma rede e não deve ser considerado confiável por outros hosts.</p></div></td></tr></tbody></table></div><div class=sect3><h4 id=network-pxe-nfs>31.8.1. Configurando o ambiente PXE<a class=anchor href=#network-pxe-nfs></a></h4><div class=paragraph><p>As etapas mostradas nesta seção configuram os servidores internos de NFS e TFTP. A próxima seção demonstra como instalar e configurar o servidor DHCP. Neste exemplo, o diretório que conterá os arquivos usados pelos usuários do PXE é o <span class=filename>/b/tftpboot/FreeBSD/install</span>. É importante que este diretório exista e que o mesmo nome de diretório seja configurado no <span class=filename>/etc/inetd.conf</span> e no <span class=filename>/usr/local/etc/dhcpd.conf</span>.</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Crie o diretório raiz que irá conter uma instalação do FreeBSD para ser montado por NFS:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># export NFSROOTDIR=/b/tftpboot/FreeBSD/install</span>
<span class=c># mkdir -p ${NFSROOTDIR}</span></code></pre></div></div></li><li><p>Ative o servidor NFS adicionando esta linha ao <span class=filename>/etc/rc.conf</span>:</p><div class="literalblock programlisting"><div class=content><pre>nfs_server_enable=&#34;YES&#34;</pre></div></div></li><li><p>Exporte o diretório raiz sem disco via NFS adicionando o seguinte ao <span class=filename>/etc/exports</span>:</p><div class="literalblock programlisting"><div class=content><pre>/b -ro -alldirs -maproot=root</pre></div></div></li><li><p>Inicie o servidor NFS:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service nfsd start</span></code></pre></div></div></li><li><p>Ative o <a href="https://man.freebsd.org/cgi/man.cgi?query=inetd&amp;sektion=8&amp;format=html">inetd(8)</a> adicionando a seguinte linha ao <span class=filename>/etc/rc.conf</span>:</p><div class="literalblock programlisting"><div class=content><pre>inetd_enable=&#34;YES&#34;</pre></div></div></li><li><p>Descomente a seguinte linha no <span class=filename>/etc/inetd.conf</span> certificando-se de que ela não comece com um símbolo <code>#</code>:</p><div class="literalblock programlisting"><div class=content><pre>tftp dgram udp wait root /usr/libexec/tftpd tftpd -l -s /b/tftpboot</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Algumas versões do PXE exigem a versão TCP do TFTP. Neste caso, remova o comentário da segunda linha <code>tftp</code> que contém <code>stream tcp</code>.</p></div></td></tr></tbody></table></div></li><li><p>Inicie o <a href="https://man.freebsd.org/cgi/man.cgi?query=inetd&amp;sektion=8&amp;format=html">inetd(8)</a>:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service inetd start</span></code></pre></div></div></li><li><p>Instale o sistema básico em <span class=filename>${NFSROOTDIR}</span>, seja descompactando os arquivos oficiais ou recompilando o kernel do FreeBSD e o userland (consulte <a href=./#makeworld>Atualizando o FreeBSD a partir do código fonte</a> para instruções mais detalhadas, mas não esqueça de adicionar <code>DESTDIR=<em>${NFSROOTDIR}</em></code> ao executar os comandos <code>make installkernel</code> e <code>make installworld</code>.</p></li><li><p>Teste que o servidor TFTP funciona e que pode baixar o gerenciador de boot que será obtido via PXE:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># tftp localhost</span>
tftp&gt; get FreeBSD/install/boot/pxeboot
Received 264951 bytes <span class=k>in </span>0.1 seconds</code></pre></div></div></li><li><p>Edite o <span class=filename>${NFSROOTDIR}/etc/fstab</span> e crie uma entrada para montar o sistema de arquivos raiz por meio do NFS:</p><div class="literalblock programlisting"><div class=content><pre># Device                                         Mountpoint    FSType   Options  Dump Pass
myhost.example.com:/b/tftpboot/FreeBSD/install       /         nfs      ro        0    0</pre></div></div><div class=paragraph><p>Substitua <em>myhost.example.com</em> pelo nome do host ou pelo endereço IP do servidor NFS. Neste exemplo, o sistema de arquivos raiz é montado como somente leitura para evitar que os clientes do NFS excluam potencialmente o conteúdo do sistema de arquivos raiz.</p></div></li><li><p>Defina a senha de root no ambiente PXE para as máquinas clientes que serão inicializadas por PXE:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># chroot ${NFSROOTDIR}</span>
<span class=c># passwd</span></code></pre></div></div></li><li><p>Se necessário, ative o login do root via <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh&amp;sektion=1&amp;format=html">ssh(1)</a> para as máquinas clientes que estão inicializando por PXE editando o <span class=filename>${NFSROOTDIR}/etc/ssh/sshd_config</span> e habilitando o <code>PermitRootLogin</code>. Esta opção está documentada em <a href="https://man.freebsd.org/cgi/man.cgi?query=sshd_config&amp;sektion=5&amp;format=html">sshd_config(5)</a>.</p></li><li><p>Execute qualquer outra customização necessária do ambiente PXE no <span class=filename>${NFSROOTDIR}</span>. Estas customizações podem incluir coisas como instalar pacotes ou editar o arquivo de senha com o <a href="https://man.freebsd.org/cgi/man.cgi?query=vipw&amp;sektion=8&amp;format=html">vipw(8)</a>.</p></li></ol></div></div></div><div class=paragraph><p>Ao inicializar de um volume raiz NFS, o <span class=filename>/etc/rc</span> detecta a inicialização do NFS e executa o <span class=filename>/etc/rc.initdiskless</span>. Neste caso, o <span class=filename>/etc</span> e <span class=filename>/var</span> precisam ser sistemas de arquivos montados em memória para que estes diretórios sejam graváveis mas o diretório raiz NFS seja apenas de leitura:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># chroot ${NFSROOTDIR}</span>
<span class=c># mkdir -p conf/base</span>
<span class=c># tar -c -v -f conf/base/etc.cpio.gz --format cpio --gzip etc</span>
<span class=c># tar -c -v -f conf/base/var.cpio.gz --format cpio --gzip var</span></code></pre></div></div><div class=paragraph><p>Quando o sistema inicializar, os sistemas de arquivos em memória para o <span class=filename>/etc</span> e o <span class=filename>/var</span> serão criados e montados e o conteúdo dos arquivos <span class=filename>cpio.gz</span> será copiado para eles. Por padrão, esses sistemas de arquivos têm uma capacidade máxima de 5 megabytes. Se seus arquivos não couberem, o que geralmente é o caso do <span class=filename>/var</span> quando pacotes binários foram instalados, solicite um tamanho maior colocando o número de setores de 512 bytes necessários (por exemplo, 5 megabytes é 10240 setores) nos arquivos <span class=filename>${NFSROOTDIR}/conf/base/etc/md_size</span> e <span class=filename>${NFSROOTDIR}/conf/base/var/md_size</span> para os sistemas de arquivos <span class=filename>/etc</span> e o <span class=filename>/var</span> respectivamente.</p></div></div><div class=sect3><h4 id=network-pxe-setting-up-dhcp>31.8.2. Configurando o servidor DHCP<a class=anchor href=#network-pxe-setting-up-dhcp></a></h4><div class=paragraph><p>O servidor DHCP não precisa ser a mesma máquina que o servidor TFTP e NFS, mas ele precisa estar acessível na rede.</p></div><div class=paragraph><p>O DHCP não faz parte do sistema básico do FreeBSD, mas pode ser instalado usando o port ou pacote <a class=package href=https://cgit.freebsd.org/ports/tree/net/isc-dhcp44-server/>net/isc-dhcp44-server</a>.</p></div><div class=paragraph><p>Uma vez instalado, edite o arquivo de configuração, <span class=filename>/usr/local/etc/dhcpd.conf</span>. Configure as diretivas <code>next-server</code>, <code>filename</code> e <code>root-path</code> conforme mostrado neste exemplo:</p></div><div class="literalblock programlisting"><div class=content><pre>subnet 192.168.0.0 netmask 255.255.255.0 {
   range 192.168.0.2 192.168.0.3 ;
   option subnet-mask 255.255.255.0 ;
   option routers 192.168.0.1 ;
   option broadcast-address 192.168.0.255 ;
   option domain-name-servers 192.168.35.35, 192.168.35.36 ;
   option domain-name &#34;example.com&#34;;

   # IP address of TFTP server
   next-server 192.168.0.1 ;

   # path of boot loader obtained via tftp
   filename &#34;FreeBSD/install/boot/pxeboot&#34; ;

   # pxeboot boot loader will try to NFS mount this directory for root FS
   option root-path &#34;192.168.0.1:/b/tftpboot/FreeBSD/install/&#34; ;

}</pre></div></div><div class=paragraph><p>A diretiva <code>next-server</code> é usada para especificar o endereço IP do servidor TFTP.</p></div><div class=paragraph><p>A diretiva <code>filename</code> define o caminho para o <span class=filename>/boot/pxeboot</span>. Um nome de arquivo relativo é usado, significando que <span class=filename>/b/tftpboot</span> não está incluído no caminho.</p></div><div class=paragraph><p>A diretiva <code>root-path</code> define o caminho para o sistema de arquivos raiz a ser montado por NFS.</p></div><div class=paragraph><p>Depois que as edições forem salvas, ative o DHCP no momento da inicialização adicionando a seguinte linha ao <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>dhcpd_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Então inicie o serviço DHCP:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service isc-dhcpd start</span></code></pre></div></div></div><div class=sect3><h4 id=_depurando_problemas_de_pxe>31.8.3. Depurando problemas de PXE<a class=anchor href=#_depurando_problemas_de_pxe></a></h4><div class=paragraph><p>Uma vez que todos os serviços estejam configurados e iniciados, os clientes de PXE devem poder carregar automaticamente o FreeBSD pela rede. Se um determinado cliente não conseguir se conectar, quando a máquina cliente inicializar, entre no menu de configuração da BIOS e confirme se ela está configurada para inicializar a partir da rede.</p></div><div class=paragraph><p>Esta seção descreve algumas dicas de solução de problemas para isolar a origem do problema de configuração, caso nenhum cliente seja capaz de inicializar o PXE.</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Use o pacote ou port <a class=package href=https://cgit.freebsd.org/ports/tree/net/wireshark/>net/wireshark</a> para depurar o tráfego de rede envolvido durante o processo de inicialização do PXE, que está ilustrado no diagrama abaixo.</p><div class=imageblock><div class=content><img src=../../../../images/books/handbook/advanced-networking/pxe-nfs.png alt="pxe nfs"></div><div class=title>Figura 61. Processo de inicialização PXE com o sistema de arquivos raiz montado por NFS</div></div></li><li><p>No servidor TFTP, leia o <span class=filename>/var/log/xferlog</span> para garantir que o <span class=filename>pxeboot</span> esteja sendo recuperado do local correto. Para testar esta configuração de exemplo:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># tftp 192.168.0.1</span>
tftp&gt; get FreeBSD/install/boot/pxeboot
Received 264951 bytes <span class=k>in </span>0.1 seconds</code></pre></div></div><div class=paragraph><p>As seções de <code>BUGS</code> do <a href="https://man.freebsd.org/cgi/man.cgi?query=tftpd&amp;sektion=8&amp;format=html">tftpd(8)</a> e <a href="https://man.freebsd.org/cgi/man.cgi?query=tftp&amp;sektion=1&amp;format=html">tftp(1)</a> documenta algumas limitações com o TFTP.</p></div></li><li><p>Certifique-se de que o sistema de arquivos raiz possa ser montado via NFS. Para testar esta configuração de exemplo:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount -t nfs 192.168.0.1:/b/tftpboot/FreeBSD/install /mnt</span></code></pre></div></div></li></ol></div></div></div></div></div><div class=sect2><h3 id=network-ipv6>31.9. IPv6<a class=anchor href=#network-ipv6></a></h3><div class=paragraph><p>O IPv6 é a nova versão do conhecido protocolo IP, também conhecido como IPv4. O IPv6 oferece várias vantagens sobre o IPv4, além de muitos recursos novos:</p></div><div class=ulist><ul><li><p>Seu espaço de endereços de 128 bits permite 340.282.366.920.938.463.463.374.607.431.768.211.456 endereços. Isso corrige a falta de endereços do IPv4 e o eventual esgotamento do endereço de IPv4.</p></li><li><p>Os roteadores armazenam apenas endereços de agregação de rede em suas tabelas de roteamento, reduzindo assim o espaço médio de uma tabela de roteamento para 8192 entradas. Isso resolve os problemas de escalabilidade associados ao IPv4, que exigia que cada bloco alocado de endereços IPv4 fossem trocados entre roteadores da Internet, fazendo com que suas tabelas de roteamento ficassem muito grandes para permitir um roteamento eficiente .</p></li><li><p>Autoconfiguração de endereço (<a href=http://www.ietf.org/rfc/rfc2462.txt>RFC2462</a>).</p></li><li><p>Endereços multicast obrigatórios.</p></li><li><p>IPsec Embutido (Segurança IP).</p></li><li><p>Estrutura simplificada do cabeçalho.</p></li><li><p>Suporte para mobile IP.</p></li><li><p>Mecanismos de transição IPv6-to-IPv4.</p></li></ul></div><div class=paragraph><p>O FreeBSD inclui a implementação de referência do <a href=http://www.kame.net/>http://www.kame.net/</a>IPv6 e vem com tudo necessário usar o IPv6. Esta seção se concentra em configurar e executar o IPv6.</p></div><div class=sect3><h4 id=_informações_sobre_endereços_de_ipv6>31.9.1. Informações sobre endereços de IPv6<a class=anchor href=#_informações_sobre_endereços_de_ipv6></a></h4><div class=paragraph><p>Existem três tipos diferentes de endereços de IPv6:</p></div><div class=dlist><dl><dt class=hdlist1>Unicast</dt><dd><p>Um pacote enviado para um endereço unicast chega à interface pertencente ao endereço.</p></dd><dt class=hdlist1>Anycast</dt><dd><p>Esses endereços são sintaticamente indistinguíveis dos endereços unicast, mas eles tratam de um grupo de interfaces. O pacote destinado a um endereço anycast chegará à interface do roteador mais próxima. Endereços anycast são usados apenas por roteadores.</p></dd><dt class=hdlist1>Multicast</dt><dd><p>Esses endereços identificam um grupo de interfaces. Um pacote destinado a um endereço multicast chegará a todas as interfaces pertencentes ao grupo multicast. O endereço de broadcast IPv4 , geralmente <code>xxx.xxx.xxx.255</code>, é expresso por endereços multicast em IPv6.</p></dd></dl></div><div class=paragraph><p>Ao ler um endereço IPv6, a forma canônica é representada como <code>x:x:x:x:x:x:x:x</code>, onde cada <code>x</code> representa um valor hexadecimal de 16 bits. Um exemplo é <code>FEBC:A574:382B:23C1:AA49:4592:4EFE:9982</code>.</p></div><div class=paragraph><p>Muitas vezes, um endereço terá substrings longas apenas com zeros. Um <code>::</code> (dois-pontos duplos) pode ser usado para substituir uma subcadeia por endereço. Além disso, até três valores <code>0</code>s iniciais por valor hexadecimal podem ser omitidos. Por exemplo, <code>fe80::1</code> corresponde à forma canônica <code>fe80:0000:0000:0000:0000:0000:0000:0001</code>.</p></div><div class=paragraph><p>Uma terceira forma é escrever os últimos 32 bits usando a conhecida notação IPv4. Por exemplo, <code>2002::10.0.0.1</code> corresponde à representação canônica hexadecimal <code>2002:0000:0000:0000:0000:0000:0a00:0001</code>, que por sua vez é equivalente a <code>2002::a00:1</code>.</p></div><div class=paragraph><p>Para visualizar o endereço IPv6 do sistema FreeBSD, use <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig</span></code></pre></div></div><div class="literalblock programlisting"><div class=content><pre>rl0: flags=8943&lt;UP,BROADCAST,RUNNING,PROMISC,SIMPLEX,MULTICAST&gt; mtu 1500
         inet 10.0.0.10 netmask 0xffffff00 broadcast 10.0.0.255
         inet6 fe80::200:21ff:fe03:8e1%rl0 prefixlen 64 scopeid 0x1
         ether 00:00:21:03:08:e1
         media: Ethernet autoselect (100baseTX )
         status: active</pre></div></div><div class=paragraph><p>Neste exemplo, a interface <span class=filename>rl0</span> está usando <code>fe80::200:21ff:fe03:8e1%rl0</code>, um endereço local de link auto-configurado que foi gerado automaticamente a partir do endereço MAC.</p></div><div class=paragraph><p>Alguns endereços do IPv6 são reservados. Um resumo destes endereços reservados é visto em <a href=#reservedip6>Endereços IPv6 reservados</a>:</p></div><table id=reservedip6 class="tableblock frame-none grid-all stretch"><caption class=title>Tabela 30. Endereços IPv6 reservados</caption><col style=width:25%><col style=width:25%><col style=width:25%><col style=width:25%><thead><tr><th class="tableblock halign-left valign-top">endereço IPv6</th><th class="tableblock halign-left valign-top">Prefixlength (Bits)</th><th class="tableblock halign-left valign-top">Descrição</th><th class="tableblock halign-left valign-top">Notas</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>::</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>128 bits</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>não especificado</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Equivalente a <code>0.0.0.0</code> em IPv4.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>::1</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>128 bits</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>endereço de loopback</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Equivalente ao <code>127.0.0.1</code> no IPv4.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>::00:xx:xx:xx:xx</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>96 bits</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>IPv4 Embarcado</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Os 32 bits inferiores são o endereço IPv4 compatível.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>::ff:xx:xx:xx:xx</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>96 bits</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>O endereço IPv4 mapeado do endereço IPv6</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Os 32 bits mais baixos são o endereço IPv4 para hosts que não suportam o IPv6.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>fe80::/10</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>10 bits</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>link-local</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Equivalente a 169.254.0.0/16 em IPv4.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>fc00::/7</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>7 bits</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>unique-local</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Endereços locais exclusivos são destinados à comunicação local e só podem ser roteados dentro de um conjunto de sites cooperantes.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>ff00::</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>8 bits</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>multicast</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>2000::-3fff::</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>3 bits</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>unicast global</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Todos os endereços unicast globais são atribuídos a partir desse pool. Os primeiros 3 bits são <code>001</code>.</p></td></tr></tbody></table><div class=paragraph><p>Para maiores informações sobre a estrutura dos endereços do IPv6, consulte a <a href=http://www.ietf.org/rfc/rfc3513.txt>RFC3513</a>.</p></div></div><div class=sect3><h4 id=_configurando_o_ipv6>31.9.2. Configurando o IPv6<a class=anchor href=#_configurando_o_ipv6></a></h4><div class=paragraph><p>Para configurar um sistema FreeBSD como um cliente IPv6, adicione estas duas linhas ao <span class=filename>rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>ifconfig_rl0_ipv6=&#34;inet6 accept_rtadv&#34;
rtsold_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>A primeira linha permite que a interface especificada receba mensagens de solicitação do roteador. A segunda linha ativa o daemon de solicitação do roteador, <a href="https://man.freebsd.org/cgi/man.cgi?query=rtsol&amp;sektion=8&amp;format=html">rtsol(8)</a>.</p></div><div class=paragraph><p>Se a interface precisar de um endereço IPv6 atribuído estaticamente, adicione uma entrada para especificar o endereço estático e o comprimento do prefixo associado:</p></div><div class="literalblock programlisting"><div class=content><pre>ifconfig_rl0_ipv6=&#34;inet6 2001:db8:4672:6565:2026:5043:2d42:5344 prefixlen 64&#34;</pre></div></div><div class=paragraph><p>Para atribuir um roteador padrão, especifique seu endereço:</p></div><div class="literalblock programlisting"><div class=content><pre>ipv6_defaultrouter=&#34;2001:db8:4672:6565::1&#34;</pre></div></div></div><div class=sect3><h4 id=_conectando_se_a_um_provedor>31.9.3. Conectando-se a um provedor<a class=anchor href=#_conectando_se_a_um_provedor></a></h4><div class=paragraph><p>Para se conectar a outras redes IPv6, é necessário ter um provedor ou um túnel que suporte IPv6:</p></div><div class=ulist><ul><li><p>Entre em contato com um provedor de serviços de Internet para saber se eles oferecem IPv6.</p></li><li><p>O <a href=http://www.tunnelbroker.net>Hurricane Electric</a> oferece túneis com endpoints em todo o mundo.</p></li></ul></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Instale o pacote ou port <a class=package href=https://cgit.freebsd.org/ports/tree/net/freenet6/>net/freenet6</a> para uma conexão dial-up.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Esta seção demonstra como obter as direções de um provedor de túneis e convertê-las em configurações do <span class=filename>/etc/rc.conf</span> que persistirão durante as reinicializações.</p></div><div class=paragraph><p>A primeira entrada <span class=filename>/etc/rc.conf</span> cria a interface de encapsulamento genérica <span class=filename>gif0</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>cloned_interfaces=&#34;gif0&#34;</pre></div></div><div class=paragraph><p>Em seguida, configure essa interface com os endereços IPv4 dos pontos de extremidade locais e remotos. Substitua <em>MY_IPv4_ADDR</em> e <em>REMOTE_IPv4_ADDR</em> pelos endereços atuais de IPv4:</p></div><div class="literalblock programlisting"><div class=content><pre>create_args_gif0=&#34;tunnel MY_IPv4_ADDR REMOTE_IPv4_ADDR&#34;</pre></div></div><div class=paragraph><p>Para aplicar o endereço IPv6 que foi atribuído para uso como o ponto final do túnel IPv6, adicione esta linha, substituindo <em>MY_ASSIGNED_IPv6_TUNNEL_ENDPOINT_ADDR</em> pelo endereço atribuído:</p></div><div class="literalblock programlisting"><div class=content><pre>ifconfig_gif0_ipv6=&#34;inet6 MY_ASSIGNED_IPv6_TUNNEL_ENDPOINT_ADDR&#34;</pre></div></div><div class=paragraph><p>Em seguida, defina a rota padrão para o outro lado do túnel IPv6. Substitua <em>MY_IPv6_REMOTE_TUNNEL_ENDPOINT_ADDR</em> pelo endereço do gateway padrão atribuído pelo provedor:</p></div><div class="literalblock programlisting"><div class=content><pre>ipv6_defaultrouter=&#34;MY_IPv6_REMOTE_TUNNEL_ENDPOINT_ADDR&#34;</pre></div></div><div class=paragraph><p>Se o sistema FreeBSD irá rotear pacotes IPv6 entre o resto da rede e o mundo, habilite o gateway usando esta linha:</p></div><div class="literalblock programlisting"><div class=content><pre>ipv6_gateway_enable=&#34;YES&#34;</pre></div></div></div><div class=sect3><h4 id=_anúncio_do_roteador_e_configuração_automática_do_host>31.9.4. Anúncio do roteador e configuração automática do host<a class=anchor href=#_anúncio_do_roteador_e_configuração_automática_do_host></a></h4><div class=paragraph><p>Esta seção demonstra como configurar o <a href="https://man.freebsd.org/cgi/man.cgi?query=rtadvd&amp;sektion=8&amp;format=html">rtadvd(8)</a> para anunciar a rota padrão de IPv6.</p></div><div class=paragraph><p>Para ativar <a href="https://man.freebsd.org/cgi/man.cgi?query=rtadvd&amp;sektion=8&amp;format=html">rtadvd(8)</a>, inclua o seguinte no <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>rtadvd_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>É importante especificar a interface na qual fazer a solicitação do roteador IPv6. Por exemplo, para informar o <a href="https://man.freebsd.org/cgi/man.cgi?query=rtadvd&amp;sektion=8&amp;format=html">rtadvd(8)</a> para usar <span class=filename>rl0</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>rtadvd_interfaces=&#34;rl0&#34;</pre></div></div><div class=paragraph><p>Em seguida, crie o arquivo de configuração, <span class=filename>/etc/rtadvd.conf</span> como visto neste exemplo:</p></div><div class="literalblock programlisting"><div class=content><pre>rl0:\
	:addrs#1:addr=&#34;2001:db8:1f11:246::&#34;:prefixlen#64:tc=ether:</pre></div></div><div class=paragraph><p>Substitua <span class=filename>rl0</span> com a interface a ser usada e <code>2001:db8:1f11:246::</code> com o prefixo da alocação.</p></div><div class=paragraph><p>Para uma sub-rede <code>/64</code> dedicada, nada mais precisa ser alterado. Caso contrário, altere o <code>prefixlen#</code> para o valor correto.</p></div></div><div class=sect3><h4 id=_ipv6_e_o_mapeamento_de_endereços_ipv6>31.9.5. IPv6 e o mapeamento de endereços IPv6<a class=anchor href=#_ipv6_e_o_mapeamento_de_endereços_ipv6></a></h4><div class=paragraph><p>Quando o IPv6 está habilitado em um servidor, pode ser necessário ativar a comunicação de endereços IPv4 mapeados para IPv6. Esta opção de compatibilidade permite que endereços IPv4 sejam representados como endereços de IPv6. Permitir que aplicativos IPv6 se comuniquem com IPv4 e vice-versa pode ser um problema de segurança.</p></div><div class=paragraph><p>Essa opção pode não ser necessária na maioria dos casos e está disponível apenas para compatibilidade. Esta opção permitirá que os aplicativos que suportam apenas o IPv6 funcionem com IPv4 em um ambiente de pilha dupla. Isso é mais útil para aplicativos de terceiros que podem não suportar um ambiente somente de IPv6. Para habilitar esse recurso, adicione o seguinte ao <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>ipv6_ipv4mapping=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Revisar as informações da RFC 3493, seção 3.6 e 3.7, bem como da RFC 4038 seção 4.2, pode ser útil para alguns administradores.</p></div></div></div><div class=sect2><h3 id=carp>31.10. Protocolo Comum de Redundância de Endereços (CARP)<a class=anchor href=#carp></a></h3><div class=paragraph><p>O Protocolo Comum de Redundância de Endereços (CARP) permite que vários hosts compartilhem o mesmo endereço IP e ID de Host Virtual (VHID) para fornecer <em>alta disponibilidade</em> para um ou mais serviços. Isso significa que um ou mais hosts podem falhar e os outros hosts assumem o controle de modo transparente, de modo que os usuários não percebam uma falha de serviço.</p></div><div class=paragraph><p>Além do endereço IP compartilhado, cada host tem seu próprio endereço IP para gerenciamento e configuração. Todas as máquinas que compartilham um endereço IP têm o mesmo VHID. O VHID para cada endereço virtual de IP deve ser exclusivo no domínio de broadcast da interface de rede.</p></div><div class=paragraph><p>A alta disponibilidade usando o CARP é nativa no FreeBSD, embora os passos para configurá-lo variem um pouco dependendo da versão do FreeBSD. Esta seção fornece a mesma configuração de exemplo para versões anteriores, iguais ou posteriores ao FreeBSD 10.</p></div><div class=paragraph><p>Este exemplo configura o suporte a failover com três hosts, todos com endereços exclusivos de IP, mas que fornecem o mesmo conteúdo da web. Ele tem dois mestres diferentes chamados <code>hosta.example.org</code> e <code>hostb.example.org</code>, com um backup compartilhado chamado <code>hostc.example.org</code>.</p></div><div class=paragraph><p>O balanceamento de carga destas máquinas é feito por meio de uma configuração de DNS Round Robin. As máquinas principais e de backup são configuradas de forma idêntica, exceto por seus nomes de host e endereços de gerenciamento IP. Esses servidores devem ter a mesma configuração e executar os mesmos serviços. Quando o failover ocorre, as solicitações para o serviço no endereço IP compartilhado só podem ser respondidas corretamente se o servidor de backup tiver acesso ao mesmo conteúdo. A máquina de backup tem duas interfaces CARP adicionais, uma para cada endereço IP do servidor de conteúdo mestre. Quando ocorre uma falha, o servidor de backup selecionará o endereço IP da máquina mestre com falha.</p></div><div class=sect3><h4 id=carp-10x>31.10.1. Usando CARP no FreeBSD 10 e Posteriores<a class=anchor href=#carp-10x></a></h4><div class=paragraph><p>Ative o suporte para CARP na inicialização do sistema, adicionando uma entrada para o módulo do kernel <span class=filename>carp.ko</span> em <span class=filename>/boot/loader.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>carp_load=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Para carregar o módulo agora sem reiniciar:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload carp</span></code></pre></div></div><div class=paragraph><p>Para usuários que preferem usar um kernel personalizado, inclua a seguinte linha no arquivo de configuração do kernel personalizado e compile o kernel como descrito em <a href=./#kernelconfig>Configurando o kernel do FreeBSD</a>:</p></div><div class="literalblock programlisting"><div class=content><pre>device	carp</pre></div></div><div class=paragraph><p>O nome do host, o endereço IP de gerenciamento e a máscara de sub-rede, o endereço IP compartilhado e o VHID são definidos adicionando entradas ao <span class=filename>/etc/rc.conf</span>. Este exemplo é para o <code>hosta.example.org</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>hostname=&#34;hosta.example.org&#34;
ifconfig_em0=&#34;inet 192.168.1.3 netmask 255.255.255.0&#34;
ifconfig_em0_alias0=&#34;inet vhid 1 pass testpass alias 192.168.1.50/32&#34;</pre></div></div><div class=paragraph><p>O próximo conjunto de entradas é para o <code>hostb.example.org</code>. Como ele representa um segundo mestre, ele usa um endereço IP compartilhado diferente e VHID. No entanto, as senhas especificadas com <code>pass</code> devem ser idênticas, pois o CARP somente ouvirá e aceitará anúncios de máquinas com a senha correta.</p></div><div class="literalblock programlisting"><div class=content><pre>hostname=&#34;hostb.example.org&#34;
ifconfig_em0=&#34;inet 192.168.1.4 netmask 255.255.255.0&#34;
ifconfig_em0_alias0=&#34;inet vhid 2 pass testpass alias 192.168.1.51/32&#34;</pre></div></div><div class=paragraph><p>A terceira máquina, <code>hostc.example.org</code>, é configurada para lidar com o failover de um dos mestres. Esta máquina é configurada com dois CARPVHIDs, um para manipular o endereço IP virtual para cada um dos hosts principais. O desvio de publicidade CARP, <code>advskew</code>, é definida para garantir que o host de backup seja anunciado depois do mestre, pois <code>advskew</code> controla a ordem de precedência quando existem vários servidores de backup.</p></div><div class="literalblock programlisting"><div class=content><pre>hostname=&#34;hostc.example.org&#34;
ifconfig_em0=&#34;inet 192.168.1.5 netmask 255.255.255.0&#34;
ifconfig_em0_alias0=&#34;inet vhid 1 advskew 100 pass testpass alias 192.168.1.50/32&#34;
ifconfig_em0_alias1=&#34;inet vhid 2 advskew 100 pass testpass alias 192.168.1.51/32&#34;</pre></div></div><div class=paragraph><p>Ter dois CARPVHIDs configurados significa que o <code>hostc.example.org</code> notará se um dos servidores principais ficar indisponível. Se um mestre falhar em anunciar antes do servidor de backup, o servidor de backup selecionará o endereço IP compartilhado até que o mestre se torne disponível novamente.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Se o servidor mestre original se tornar disponível novamente, o <code>hostc.example.org</code> não liberará o endereço virtual IP de volta a ele automaticamente. Para que isso aconteça, a preempção deve ser ativada. O recurso está desabilitado por padrão, ele é controlado por meio da variável <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a><code>net.inet.carp.preempt</code>. O administrador pode forçar o servidor de backup a retornar o endereço IP para o mestre:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig em0 vhid 1 state backup</span></code></pre></div></div></td></tr></tbody></table></div><div class=paragraph><p>Quando a configuração estiver concluída, reinicie a rede ou reinicie cada um dos sistemas. A alta disponibilidade está agora ativada.</p></div><div class=paragraph><p>A funcionalidade CARP pode ser controlada através de diversas variáveis <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> documentadas nas páginas de manual do <a href="https://man.freebsd.org/cgi/man.cgi?query=carp&amp;sektion=4&amp;format=html">carp(4)</a>. Outras ações podem ser acionadas a partir de eventos CARP usando <a href="https://man.freebsd.org/cgi/man.cgi?query=devd&amp;sektion=8&amp;format=html">devd(8)</a>.</p></div></div><div class=sect3><h4 id=carp-9x>31.10.2. Usando CARP no FreeBSD 9 e Anteriores<a class=anchor href=#carp-9x></a></h4><div class=paragraph><p>A configuração para estas versões do FreeBSD é similar àquela descrita na seção anterior, exceto que o dispositivo CARP deve ser criado primeiro e referenciado na configuração.</p></div><div class=paragraph><p>Ative o suporte de tempo de inicialização para o CARP carregando o módulo do kernel <span class=filename>if_carp.ko</span> no <span class=filename>/boot/loader.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>if_carp_load=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Para carregar o módulo agora sem reiniciar:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload carp</span></code></pre></div></div><div class=paragraph><p>Para usuários que preferem usar um kernel personalizado, inclua a seguinte linha no arquivo de configuração do kernel personalizado e compile o kernel como descrito em <a href=./#kernelconfig>Configurando o kernel do FreeBSD</a>:</p></div><div class="literalblock programlisting"><div class=content><pre>device	carp</pre></div></div><div class=paragraph><p>Em seguida, em cada host, crie um dispositivo CARP:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig carp0 create</span></code></pre></div></div><div class=paragraph><p>Defina o nome do host, o endereço IP de gerenciamento, o endereço IP compartilhado e o VHID adicionando as linhas necessárias ao <span class=filename>/etc/rc.conf</span>. Como um dispositivo virtual CARP é usado em vez de um alias, uma máscara de subrede real <code>/24</code> é usada em vez de uma <code>/32</code>. Aqui estão as entradas para o <code>hosta.example.org</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>hostname=&#34;hosta.example.org&#34;
ifconfig_fxp0=&#34;inet 192.168.1.3 netmask 255.255.255.0&#34;
cloned_interfaces=&#34;carp0&#34;
ifconfig_carp0=&#34;vhid 1 pass testpass 192.168.1.50/24&#34;</pre></div></div><div class=paragraph><p>Em <code>hostb.example.org</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>hostname=&#34;hostb.example.org&#34;
ifconfig_fxp0=&#34;inet 192.168.1.4 netmask 255.255.255.0&#34;
cloned_interfaces=&#34;carp0&#34;
ifconfig_carp0=&#34;vhid 2 pass testpass 192.168.1.51/24&#34;</pre></div></div><div class=paragraph><p>A terceira máquina, <code>hostc.example.org</code>, está configurada para lidar com o failover de qualquer um dos hosts principais:</p></div><div class="literalblock programlisting"><div class=content><pre>hostname=&#34;hostc.example.org&#34;
ifconfig_fxp0=&#34;inet 192.168.1.5 netmask 255.255.255.0&#34;
cloned_interfaces=&#34;carp0 carp1&#34;
ifconfig_carp0=&#34;vhid 1 advskew 100 pass testpass 192.168.1.50/24&#34;
ifconfig_carp1=&#34;vhid 2 advskew 100 pass testpass 192.168.1.51/24&#34;</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>A preempção está desabilitada no kernel <span class=filename>GENERIC</span> do FreeBSD. Se a preempção tiver sido ativada com um kernel personalizado, o <code>hostc.example.org</code> poderá não liberar o endereço IP de volta ao servidor de conteúdo original. O administrador pode forçar o servidor de backup a retornar o endereço IP para o mestre com o comando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig carp0 down &amp;&amp; ifconfig carp0 up</span></code></pre></div></div><div class=paragraph><p>Isso deve ser feito na interface <span class=filename>carp</span>, que corresponde ao host correto.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Quando a configuração estiver concluída, reinicie a rede ou reinicie cada um dos sistemas. A alta disponibilidade está agora ativada.</p></div></div></div><div class=sect2><h3 id=network-vlan>31.11. VLANs<a class=anchor href=#network-vlan></a></h3><div class=paragraph><p>As VLANs são uma forma de dividir virtualmente uma rede em várias sub-redes diferentes, também conhecida como segmentação. Cada segmento terá seu próprio domínio de broadcast e será isolado de outras VLANs.</p></div><div class=paragraph><p>No FreeBSD, as VLANs devem ser suportadas pelo driver da placa de rede. Para ver quais drivers suportam vlans, consulte a página de manual <a href="https://man.freebsd.org/cgi/man.cgi?query=vlan&amp;sektion=4&amp;format=html">vlan(4)</a>.</p></div><div class=paragraph><p>Ao configurar uma VLAN, algumas informações devem ser conhecidas. Primeiro, qual a interface de rede? Segundo, qual é a tag da VLAN?</p></div><div class=paragraph><p>Para configurar uma VLANs em tempo de execução, com uma NIC <code>em0</code> e uma tag VLAN de <code>5</code> o comando ficaria assim:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig em0.5 create vlan 5 vlandev em0 inet 192.168.20.20/24</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Viu como o nome da interface inclui o nome do driver da NIC e a tag VLAN, separados por um ponto final? Essa é uma prática recomendada para facilitar a manutenção da configuração de VLAN quando muitas VLANs estiverem presentes em uma máquina.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Para configurar uma VLANs no momento da inicialização, o <span class=filename>/etc/rc.conf</span> deve ser atualizado. Para duplicar a configuração acima, será necessário adicionar o seguinte:</p></div><div class="literalblock programlisting"><div class=content><pre>vlans_em0=&#34;5&#34;
ifconfig_em0_5=&#34;inet 192.168.20.20/24&#34;</pre></div></div><div class=paragraph><p>VLANs adicionais podem ser inseridas, simplesmente adicionando a tag ao campo <code>vlans_em0</code> e incrementando uma linha de configuração da rede nessa interface da tag VLAN.</p></div><div class=paragraph><p>É útil atribuir um nome simbólico a uma interface para que, quando o hardware associado for alterado, apenas algumas variáveis de configuração precisem ser atualizadas. Por exemplo, câmeras de segurança precisam ser executadas pela VLAN 1 em <code>em0</code>. Posteriormente, se a placa <code>em0</code> for substituída por uma placa que use o driver <a href="https://man.freebsd.org/cgi/man.cgi?query=ixgb&amp;sektion=4&amp;format=html">ixgb(4)</a>, todas as referências a <code>em0.1</code> não precisarão ser alterado para <code>ixgb0.1</code>.</p></div><div class=paragraph><p>Para configurar a VLAN <code>5</code>, na NIC <code>em0</code>, atribua o nome de interface <code>cameras</code>, e atribua à interface um endereço IP de <code><em>192.168.20.20</em></code> com um prefixo <code>24</code>-bit, use este comando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig em0.5 create vlan 5 vlandev em0 name cameras inet 192.168.20.20/24</span></code></pre></div></div><div class=paragraph><p>Para uma interface denominada <code>video</code>, use o seguinte:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig video.5 create vlan 5 vlandev video name cameras inet 192.168.20.20/24</span></code></pre></div></div><div class=paragraph><p>Para aplicar as mudanças no momento da inicialização, adicione as seguintes linhas ao <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>vlans_video=&#34;cameras&#34;
create_args_cameras=&#34;vlan 5&#34;
ifconfig_cameras=&#34;inet 192.168.20.20/24&#34;</pre></div></div></div></div></div><h1 id=appendices class=sect0>Parte V: Apêndices<a class=anchor href=#appendices></a></h1><div class=sect1><h2 id=mirrors>Apêndice A: Obtendo o FreeBSD<a class=anchor href=#mirrors></a></h2><div class=sectionbody><div class=sect2><h3 id=mirrors-cdrom>A.1. CD and DVD Sets<a class=anchor href=#mirrors-cdrom></a></h3><div class=paragraph><p>Os conjuntos de CD and DVD do FreeBSD estão disponíveis em vários varejistas on-line:</p></div><div class=ulist><ul><li><p>FreeBSD Mall, Inc.<br>2420 Sand Creek Rd C-1 #347<br>Brentwood, CA<br>94513<br>USA<br>Phone: +1 925 240-6652<br>Fax: +1 925 674-0821<br>Email: &lt;<a href=mailto:info@freebsdmall.com>info@freebsdmall.com</a>><br>WWW: <a href=https://www.freebsdmall.com class=bare>https://www.freebsdmall.com</a></p></li><li><p>Getlinux<br>78 Rue de la Croix Rochopt<br>Épinay-sous-Sénart<br>91860<br>France<br>Email: &lt;<a href=mailto:contact@getlinux.fr>contact@getlinux.fr</a>><br>WWW: <a href=http://www.getlinux.fr/ class=bare>http://www.getlinux.fr/</a></p></li><li><p>Dr. Hinner EDV<br>Kochelseestr. 11<br>D-81371 München<br>Germany<br>Phone: (0177) 428 419 0<br>Email: &lt;<a href=mailto:infow@hinner.de>infow@hinner.de</a>><br>WWW: <a href=http://www.hinner.de/linux/freebsd.html class=bare>http://www.hinner.de/linux/freebsd.html</a></p></li><li><p>Linux Center<br>Galernaya Street, 55<br>Saint-Petersburg<br>190000<br>Russia<br>Phone: +7-812-309-06-86<br>Email: &lt;<a href=mailto:info@linuxcenter.ru>info@linuxcenter.ru</a>><br>WWW: <a href=http://linuxcenter.ru/shop/freebsd class=bare>http://linuxcenter.ru/shop/freebsd</a></p></li></ul></div></div><div class=sect2><h3 id=mirrors-ftp>A.2. Sites de FTP<a class=anchor href=#mirrors-ftp></a></h3><div class=paragraph><p>As fontes oficiais do FreeBSD estão disponíveis no FTP anônimo de um conjunto mundial de sites espelho. O site <a href=ftp://ftp.FreeBSD.org/pub/FreeBSD/>ftp://ftp.FreeBSD.org/pub/FreeBSD/</a> está disponível via HTTP e FTP. Ele é composto de muitas máquinas operadas pelos administradores de cluster do projeto e fica atrás de uma estrutura de GeoDNS que direciona os usuários para o espelho disponível mais próximo.</p></div><div class=paragraph><p>Adicionalmente, o FreeBSD está disponível via FTP anônimo a partir dos seguintes sites espelho. Ao obter o FreeBSD via FTP anônimo, por favor tente usar um site próximo. Os sites espelhos listados como "Sites Espelhos Primários" geralmente possuem o arquivo completo do FreeBSD (todas as versões atualmente disponíveis para cada uma das arquiteturas), mas velocidades de download mais rápidas provavelmente estão disponíveis em um site que esteja em seu país ou região. Os sites regionais carregam as versões mais recentes para a(s) arquitetura(s) mais populare(s), mas podem não carregar o arquivo completo do FreeBSD. Todos os sites fornecem acesso via FTP anônimo, mas alguns sites também fornecem acesso por meio de outros métodos. Os métodos de acesso disponíveis para cada site são fornecidos entre parênteses após o nome do host.</p></div><div class=paragraph><p><a href=#central>Central Servers</a>, <a href=#primary>Primary Mirror Sites</a>, <a href=#armenia>Armenia</a>, <a href=#australia>Australia</a>, <a href=#austria>Austria</a>, <a href=#brazil>Brazil</a>, <a href=#czech-republic>Czech Republic</a>, <a href=#denmark>Denmark</a>, <a href=#estonia>Estonia</a>, <a href=#finland>Finland</a>, <a href=#france>France</a>, <a href=#germany>Germany</a>, <a href=#greece>Greece</a>, <a href=#hong-kong>Hong Kong</a>, <a href=#ireland>Ireland</a>, <a href=#japan>Japan</a>, <a href=#korea>Korea</a>, <a href=#latvia>Latvia</a>, <a href=#lithuania>Lithuania</a>, <a href=#netherlands>Netherlands</a>, <a href=#new-zealand>New Zealand</a>, <a href=#norway>Norway</a>, <a href=#poland>Poland</a>, <a href=#russia>Russia</a>, <a href=#saudi-arabia>Saudi Arabia</a>, <a href=#slovenia>Slovenia</a>, <a href=#south-africa>South Africa</a>, <a href=#spain>Spain</a>, <a href=#sweden>Sweden</a>, <a href=#switzerland>Switzerland</a>, <a href=#taiwan>Taiwan</a>, <a href=#ukraine>Ukraine</a>, <a href=#uk>United Kingdom</a>, <a href=#usa>United States of America</a>.</p></div><div class=paragraph><p>(as of UTC)</p></div><div id=central class=paragraph><p><strong>Central Servers</strong></p></div><div class=paragraph><p><a href=ftp://ftp.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.FreeBSD.org/pub/FreeBSD/</a> (ftp / ftpv6 / <a href=http://ftp.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp.FreeBSD.org/pub/FreeBSD/</a> / <a href=http://ftp.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp.FreeBSD.org/pub/FreeBSD/</a>)</p></div><div id=primary class=paragraph><p><strong>Primary Mirror Sites</strong></p></div><div class=paragraph><p>In case of problems, please contact the hostmaster <code>&lt;<a href=mailto:mirror-admin@FreeBSD.org>mirror-admin@FreeBSD.org</a>></code> for this domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp1.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp1.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp2.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp2.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp3.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp3.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp4.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp4.FreeBSD.org/pub/FreeBSD/</a> (ftp / ftpv6 / <a href=http://ftp4.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp4.FreeBSD.org/pub/FreeBSD/</a> / <a href=http://ftp4.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp4.FreeBSD.org/pub/FreeBSD/</a>)</p></li><li><p><a href=ftp://ftp5.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp5.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp6.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp6.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp7.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp7.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp10.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp10.FreeBSD.org/pub/FreeBSD/</a> (ftp / ftpv6 / <a href=http://ftp10.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp10.FreeBSD.org/pub/FreeBSD/</a> / <a href=http://ftp10.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp10.FreeBSD.org/pub/FreeBSD/</a>)</p></li><li><p><a href=ftp://ftp11.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp11.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp13.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp13.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp14.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp14.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=http://ftp14.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp14.FreeBSD.org/pub/FreeBSD/</a>)</p></li></ul></div><div id=armenia class=paragraph><p><strong>Armenia</strong></p></div><div class=paragraph><p>In case of problems, please contact the hostmaster <code>&lt;<a href=mailto:hostmaster@am.FreeBSD.org>hostmaster@am.FreeBSD.org</a>></code> for this domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp1.am.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp1.am.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=http://ftp1.am.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp1.am.FreeBSD.org/pub/FreeBSD/</a> / rsync)</p></li></ul></div><div id=australia class=paragraph><p><strong>Australia</strong></p></div><div class=paragraph><p>In case of problems, please contact the hostmaster <code>&lt;<a href=mailto:hostmaster@au.FreeBSD.org>hostmaster@au.FreeBSD.org</a>></code> for this domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp.au.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.au.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp2.au.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp2.au.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp3.au.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp3.au.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li></ul></div><div id=austria class=paragraph><p><strong>Austria</strong></p></div><div class=paragraph><p>In case of problems, please contact the hostmaster <code>&lt;<a href=mailto:hostmaster@at.FreeBSD.org>hostmaster@at.FreeBSD.org</a>></code> for this domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp.at.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.at.FreeBSD.org/pub/FreeBSD/</a> (ftp / ftpv6 / <a href=http://ftp.at.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp.at.FreeBSD.org/pub/FreeBSD/</a> / <a href=http://ftp.at.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp.at.FreeBSD.org/pub/FreeBSD/</a>)</p></li></ul></div><div id=brazil class=paragraph><p><strong>Brazil</strong></p></div><div class=paragraph><p>In case of problems, please contact the hostmaster <code>&lt;<a href=mailto:hostmaster@br.FreeBSD.org>hostmaster@br.FreeBSD.org</a>></code> for this domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp2.br.FreeBSD.org/FreeBSD/ class=bare>ftp://ftp2.br.FreeBSD.org/FreeBSD/</a> (ftp / <a href=http://ftp2.br.FreeBSD.org/ class=bare>http://ftp2.br.FreeBSD.org/</a>)</p></li><li><p><a href=ftp://ftp3.br.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp3.br.FreeBSD.org/pub/FreeBSD/</a> (ftp / rsync)</p></li><li><p><a href=ftp://ftp4.br.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp4.br.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li></ul></div><div id=czech-republic class=paragraph><p><strong>Czech Republic</strong></p></div><div class=paragraph><p>In case of problems, please contact the hostmaster <code>&lt;<a href=mailto:hostmaster@cz.FreeBSD.org>hostmaster@cz.FreeBSD.org</a>></code> for this domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp.cz.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.cz.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=ftp://ftp.cz.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.cz.FreeBSD.org/pub/FreeBSD/</a> / <a href=http://ftp.cz.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp.cz.FreeBSD.org/pub/FreeBSD/</a> / <a href=http://ftp.cz.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp.cz.FreeBSD.org/pub/FreeBSD/</a> / rsync / rsyncv6)</p></li><li><p><a href=ftp://ftp2.cz.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp2.cz.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=http://ftp2.cz.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp2.cz.FreeBSD.org/pub/FreeBSD/</a>)</p></li></ul></div><div id=denmark class=paragraph><p><strong>Denmark</strong></p></div><div class=paragraph><p>In case of problems, please contact the hostmaster <code>&lt;<a href=mailto:staff@dotsrc.org>staff@dotsrc.org</a>></code> for this domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp.dk.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.dk.FreeBSD.org/pub/FreeBSD/</a> (ftp / ftpv6 / <a href=http://ftp.dk.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp.dk.FreeBSD.org/pub/FreeBSD/</a> / <a href=http://ftp.dk.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp.dk.FreeBSD.org/pub/FreeBSD/</a>)</p></li></ul></div><div id=estonia class=paragraph><p><strong>Estonia</strong></p></div><div class=paragraph><p>In case of problems, please contact the hostmaster <code>&lt;<a href=mailto:hostmaster@ee.FreeBSD.org>hostmaster@ee.FreeBSD.org</a>></code> for this domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp.ee.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.ee.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li></ul></div><div id=finland class=paragraph><p><strong>Finland</strong></p></div><div class=paragraph><p>In case of problems, please contact the hostmaster <code>&lt;<a href=mailto:hostmaster@fi.FreeBSD.org>hostmaster@fi.FreeBSD.org</a>></code> for this domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp.fi.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.fi.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li></ul></div><div id=france class=paragraph><p><strong>France</strong></p></div><div class=paragraph><p>In case of problems, please contact the hostmaster <code>&lt;<a href=mailto:hostmaster@fr.FreeBSD.org>hostmaster@fr.FreeBSD.org</a>></code> for this domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp.fr.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.fr.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp1.fr.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp1.fr.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=http://ftp1.fr.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp1.fr.FreeBSD.org/pub/FreeBSD/</a> / rsync)</p></li><li><p><a href=ftp://ftp3.fr.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp3.fr.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp6.fr.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp6.fr.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp6.fr.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp6.fr.FreeBSD.org/pub/FreeBSD/</a> (ftp / rsync)</p></li><li><p><a href=ftp://ftp7.fr.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp7.fr.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp8.fr.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp8.fr.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li></ul></div><div id=germany class=paragraph><p><strong>Germany</strong></p></div><div class=paragraph><p>In case of problems, please contact the hostmaster <code>&lt;<a href=mailto:de-bsd-hubs@de.FreeBSD.org>de-bsd-hubs@de.FreeBSD.org</a>></code> for this domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp.de.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.de.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp1.de.FreeBSD.org/freebsd/ class=bare>ftp://ftp1.de.FreeBSD.org/freebsd/</a> (ftp / <a href=http://www1.de.FreeBSD.org/freebsd/ class=bare>http://www1.de.FreeBSD.org/freebsd/</a> / rsync://rsync3.de.FreeBSD.org/freebsd/)</p></li><li><p><a href=ftp://ftp2.de.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp2.de.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=http://ftp2.de.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp2.de.FreeBSD.org/pub/FreeBSD/</a> / rsync)</p></li><li><p><a href=ftp://ftp4.de.FreeBSD.org/FreeBSD/ class=bare>ftp://ftp4.de.FreeBSD.org/FreeBSD/</a> (ftp / <a href=http://ftp4.de.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp4.de.FreeBSD.org/pub/FreeBSD/</a>)</p></li><li><p><a href=ftp://ftp5.de.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp5.de.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp7.de.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp7.de.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=http://ftp7.de.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp7.de.FreeBSD.org/pub/FreeBSD/</a>)</p></li></ul></div><div id=greece class=paragraph><p><strong>Greece</strong></p></div><div class=paragraph><p>In case of problems, please contact the hostmaster <code>&lt;<a href=mailto:hostmaster@gr.FreeBSD.org>hostmaster@gr.FreeBSD.org</a>></code> for this domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp.gr.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.gr.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp2.gr.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp2.gr.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li></ul></div><div id=hong-kong class=paragraph><p><strong>Hong Kong</strong></p></div><div class=paragraph><p><a href=ftp://ftp.hk.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.hk.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></div><div id=ireland class=paragraph><p><strong>Ireland</strong></p></div><div class=paragraph><p>In case of problems, please contact the hostmaster <code>&lt;<a href=mailto:hostmaster@ie.FreeBSD.org>hostmaster@ie.FreeBSD.org</a>></code> for this domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp3.ie.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp3.ie.FreeBSD.org/pub/FreeBSD/</a> (ftp / rsync)</p></li></ul></div><div id=japan class=paragraph><p><strong>Japan</strong></p></div><div class=paragraph><p>In case of problems, please contact the hostmaster <code>&lt;<a href=mailto:hostmaster@jp.FreeBSD.org>hostmaster@jp.FreeBSD.org</a>></code> for this domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp.jp.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.jp.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp2.jp.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp2.jp.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp3.jp.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp3.jp.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp4.jp.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp4.jp.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp5.jp.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp5.jp.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp6.jp.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp6.jp.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp7.jp.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp7.jp.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp8.jp.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp8.jp.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp9.jp.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp9.jp.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li></ul></div><div id=korea class=paragraph><p><strong>Korea</strong></p></div><div class=paragraph><p>In case of problems, please contact the hostmaster <code>&lt;<a href=mailto:hostmaster@kr.FreeBSD.org>hostmaster@kr.FreeBSD.org</a>></code> for this domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp.kr.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.kr.FreeBSD.org/pub/FreeBSD/</a> (ftp / rsync)</p></li><li><p><a href=ftp://ftp2.kr.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp2.kr.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=http://ftp2.kr.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp2.kr.FreeBSD.org/pub/FreeBSD/</a>)</p></li></ul></div><div id=latvia class=paragraph><p><strong>Latvia</strong></p></div><div class=paragraph><p>In case of problems, please contact the hostmaster <code>&lt;<a href=mailto:hostmaster@lv.FreeBSD.org>hostmaster@lv.FreeBSD.org</a>></code> for this domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp.lv.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.lv.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=http://ftp.lv.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp.lv.FreeBSD.org/pub/FreeBSD/</a>)</p></li></ul></div><div id=lithuania class=paragraph><p><strong>Lithuania</strong></p></div><div class=paragraph><p>In case of problems, please contact the hostmaster <code>&lt;<a href=mailto:hostmaster@lt.FreeBSD.org>hostmaster@lt.FreeBSD.org</a>></code> for this domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp.lt.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.lt.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=http://ftp.lt.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp.lt.FreeBSD.org/pub/FreeBSD/</a>)</p></li></ul></div><div id=netherlands class=paragraph><p><strong>Netherlands</strong></p></div><div class=paragraph><p>In case of problems, please contact the hostmaster <code>&lt;<a href=mailto:hostmaster@nl.FreeBSD.org>hostmaster@nl.FreeBSD.org</a>></code> for this domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp.nl.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.nl.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=http://ftp.nl.FreeBSD.org/os/FreeBSD/ class=bare>http://ftp.nl.FreeBSD.org/os/FreeBSD/</a> / rsync)</p></li><li><p><a href=ftp://ftp2.nl.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp2.nl.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li></ul></div><div id=new-zealand class=paragraph><p><strong>New Zealand</strong></p></div><div class=ulist><ul><li><p><a href=ftp://ftp.nz.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.nz.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=http://ftp.nz.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp.nz.FreeBSD.org/pub/FreeBSD/</a>)</p></li></ul></div><div id=norway class=paragraph><p><strong>Norway</strong></p></div><div class=paragraph><p>In case of problems, please contact the hostmaster <code>&lt;<a href=mailto:hostmaster@no.FreeBSD.org>hostmaster@no.FreeBSD.org</a>></code> for this domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp.no.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.no.FreeBSD.org/pub/FreeBSD/</a> (ftp / rsync)</p></li></ul></div><div id=poland class=paragraph><p><strong>Poland</strong></p></div><div class=paragraph><p>In case of problems, please contact the hostmaster <code>&lt;<a href=mailto:hostmaster@pl.FreeBSD.org>hostmaster@pl.FreeBSD.org</a>></code> for this domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp.pl.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.pl.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li></ul></div><div id=russia class=paragraph><p><strong>Russia</strong></p></div><div class=paragraph><p>In case of problems, please contact the hostmaster <code>&lt;<a href=mailto:hostmaster@ru.FreeBSD.org>hostmaster@ru.FreeBSD.org</a>></code> for this domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp.ru.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.ru.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=http://ftp.ru.FreeBSD.org/FreeBSD/ class=bare>http://ftp.ru.FreeBSD.org/FreeBSD/</a> / rsync)</p></li><li><p><a href=ftp://ftp2.ru.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp2.ru.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=http://ftp2.ru.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp2.ru.FreeBSD.org/pub/FreeBSD/</a> / rsync)</p></li><li><p><a href=ftp://ftp5.ru.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp5.ru.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=http://ftp5.ru.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp5.ru.FreeBSD.org/pub/FreeBSD/</a> / rsync)</p></li><li><p><a href=ftp://ftp6.ru.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp6.ru.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li></ul></div><div id=saudi-arabia class=paragraph><p><strong>Saudi Arabia</strong></p></div><div class=paragraph><p>In case of problems, please contact the hostmaster <code>&lt;<a href=mailto:ftpadmin@isu.net.sa>ftpadmin@isu.net.sa</a>></code> for this domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp.isu.net.sa/pub/ftp.freebsd.org class=bare>ftp://ftp.isu.net.sa/pub/ftp.freebsd.org</a> (ftp)</p></li></ul></div><div id=slovenia class=paragraph><p><strong>Slovenia</strong></p></div><div class=paragraph><p>In case of problems, please contact the hostmaster <code>&lt;<a href=mailto:hostmaster@si.FreeBSD.org>hostmaster@si.FreeBSD.org</a>></code> for this domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp.si.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.si.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li></ul></div><div id=south-africa class=paragraph><p><strong>South Africa</strong></p></div><div class=paragraph><p>In case of problems, please contact the hostmaster <code>&lt;<a href=mailto:hostmaster@za.FreeBSD.org>hostmaster@za.FreeBSD.org</a>></code> for this domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp.za.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.za.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp2.za.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp2.za.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp4.za.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp4.za.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li></ul></div><div id=spain class=paragraph><p><strong>Spain</strong></p></div><div class=paragraph><p>In case of problems, please contact the hostmaster <code>&lt;<a href=mailto:hostmaster@es.FreeBSD.org>hostmaster@es.FreeBSD.org</a>></code> for this domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp.es.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.es.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=http://ftp.es.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp.es.FreeBSD.org/pub/FreeBSD/</a>)</p></li><li><p><a href=ftp://ftp3.es.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp3.es.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li></ul></div><div id=sweden class=paragraph><p><strong>Sweden</strong></p></div><div class=paragraph><p>In case of problems, please contact the hostmaster <code>&lt;<a href=mailto:hostmaster@se.FreeBSD.org>hostmaster@se.FreeBSD.org</a>></code> for this domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp.se.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.se.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp2.se.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp2.se.FreeBSD.org/pub/FreeBSD/</a> (ftp / rsync://ftp2.se.FreeBSD.org/)</p></li><li><p><a href=ftp://ftp3.se.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp3.se.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp4.se.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp4.se.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=ftp://ftp4.se.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp4.se.FreeBSD.org/pub/FreeBSD/</a> / <a href=http://ftp4.se.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp4.se.FreeBSD.org/pub/FreeBSD/</a> / <a href=http://ftp4.se.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp4.se.FreeBSD.org/pub/FreeBSD/</a> / rsync://ftp4.se.FreeBSD.org/pub/FreeBSD/ / rsync://ftp4.se.FreeBSD.org/pub/FreeBSD/)</p></li><li><p><a href=ftp://ftp6.se.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp6.se.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=http://ftp6.se.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp6.se.FreeBSD.org/pub/FreeBSD/</a>)</p></li></ul></div><div id=switzerland class=paragraph><p><strong>Switzerland</strong></p></div><div class=paragraph><p>In case of problems, please contact the hostmaster <code>&lt;<a href=mailto:hostmaster@ch.FreeBSD.org>hostmaster@ch.FreeBSD.org</a>></code> for this domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp.ch.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.ch.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=http://ftp.ch.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp.ch.FreeBSD.org/pub/FreeBSD/</a>)</p></li></ul></div><div id=taiwan class=paragraph><p><strong>Taiwan</strong></p></div><div class=paragraph><p>In case of problems, please contact the hostmaster <code>&lt;<a href=mailto:hostmaster@tw.FreeBSD.org>hostmaster@tw.FreeBSD.org</a>></code> for this domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp.ch.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.ch.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=ftp://ftp.tw.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.tw.FreeBSD.org/pub/FreeBSD/</a> / rsync / rsyncv6)</p></li><li><p><a href=ftp://ftp2.tw.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp2.tw.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=ftp://ftp2.tw.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp2.tw.FreeBSD.org/pub/FreeBSD/</a> / <a href=http://ftp2.tw.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp2.tw.FreeBSD.org/pub/FreeBSD/</a> / <a href=http://ftp2.tw.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp2.tw.FreeBSD.org/pub/FreeBSD/</a> / rsync / rsyncv6)</p></li><li><p><a href=ftp://ftp4.tw.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp4.tw.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp5.tw.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp5.tw.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp6.tw.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp6.tw.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=http://ftp6.tw.FreeBSD.org/ class=bare>http://ftp6.tw.FreeBSD.org/</a> / rsync)</p></li><li><p><a href=ftp://ftp7.tw.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp7.tw.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp8.tw.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp8.tw.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp11.tw.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp11.tw.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=http://ftp11.tw.FreeBSD.org/FreeBSD/ class=bare>http://ftp11.tw.FreeBSD.org/FreeBSD/</a>)</p></li><li><p><a href=ftp://ftp12.tw.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp12.tw.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp13.tw.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp13.tw.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp14.tw.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp14.tw.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp15.tw.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp15.tw.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li></ul></div><div id=ukraine class=paragraph><p><strong>Ukraine</strong></p></div><div class=ulist><ul><li><p><a href=ftp://ftp.ua.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.ua.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=http://ftp.ua.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp.ua.FreeBSD.org/pub/FreeBSD/</a>)</p></li><li><p><a href=ftp://ftp6.ua.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp6.ua.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=http://ftp6.ua.FreeBSD.org/pub/FreeBSD class=bare>http://ftp6.ua.FreeBSD.org/pub/FreeBSD</a> / rsync://ftp6.ua.FreeBSD.org/FreeBSD/)</p></li><li><p><a href=ftp://ftp7.ua.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp7.ua.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li></ul></div><div id=uk class=paragraph><p><strong>United Kingdom</strong></p></div><div class=paragraph><p>In case of problems, please contact the hostmaster <code>&lt;<a href=mailto:hostmaster@uk.FreeBSD.org>hostmaster@uk.FreeBSD.org</a>></code> for this domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp.uk.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp.uk.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp2.uk.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp2.uk.FreeBSD.org/pub/FreeBSD/</a> (ftp / rsync://ftp2.uk.FreeBSD.org/ftp.freebsd.org/pub/FreeBSD/)</p></li><li><p><a href=ftp://ftp3.uk.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp3.uk.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp4.uk.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp4.uk.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp5.uk.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp5.uk.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li></ul></div><div id=usa class=paragraph><p><strong>United States of America</strong></p></div><div class=paragraph><p>In case of problems, please contact the hostmaster <code>&lt;<a href=mailto:hostmaster@us.FreeBSD.org>hostmaster@us.FreeBSD.org</a>></code> for this domain.</p></div><div class=ulist><ul><li><p><a href=ftp://ftp1.us.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp1.us.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp2.us.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp2.us.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp3.us.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp3.us.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp4.us.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp4.us.FreeBSD.org/pub/FreeBSD/</a> (ftp / ftpv6 / <a href=http://ftp4.us.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp4.us.FreeBSD.org/pub/FreeBSD/</a> / <a href=http://ftp4.us.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp4.us.FreeBSD.org/pub/FreeBSD/</a>)</p></li><li><p><a href=ftp://ftp5.us.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp5.us.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp6.us.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp6.us.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp8.us.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp8.us.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp10.us.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp10.us.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp11.us.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp11.us.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li><li><p><a href=ftp://ftp13.us.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp13.us.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=http://ftp13.us.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp13.us.FreeBSD.org/pub/FreeBSD/</a> / rsync)</p></li><li><p><a href=ftp://ftp14.us.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp14.us.FreeBSD.org/pub/FreeBSD/</a> (ftp / <a href=http://ftp14.us.FreeBSD.org/pub/FreeBSD/ class=bare>http://ftp14.us.FreeBSD.org/pub/FreeBSD/</a>)</p></li><li><p><a href=ftp://ftp15.us.FreeBSD.org/pub/FreeBSD/ class=bare>ftp://ftp15.us.FreeBSD.org/pub/FreeBSD/</a> (ftp)</p></li></ul></div></div><div class=sect2><h3 id=svn>A.3. Usando o Subversion<a class=anchor href=#svn></a></h3><div class=sect3><h4 id=svn-intro>A.3.1. Introdução<a class=anchor href=#svn-intro></a></h4><div class=paragraph><p>Desde de julho de 2012, o FreeBSD usa o Subversion como o único sistema de controle de versão para armazenar todo o código-fonte do FreeBSD, a documentação e a coleção de ports.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>O Subversion é geralmente uma ferramenta de desenvolvimento. Os usuários podem preferir usar o <code>freebsd-update</code> (<a href=./#updating-upgrading-freebsdupdate>Atualização do FreeBSD</a>) para atualizar o sistema básico do FreeBSD, e o <code>portsnap</code> (<a href=./#ports-using>Usando a Coleção de Ports</a>) para atualizar a coleção de ports do FreeBSD.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Esta seção demonstra como instalar o Subversion em um sistema FreeBSD e usá-lo para criar uma cópia local de um repositório do FreeBSD. Informações adicionais sobre o uso de Subversion estão incluídas.</p></div></div><div class=sect3><h4 id=svn-ssl-certificates>A.3.2. Certificados Raiz SSL<a class=anchor href=#svn-ssl-certificates></a></h4><div class=paragraph><p>A instalação do <a class=package href=https://cgit.freebsd.org/ports/tree/security/ca_root_nss/>security/ca_root_nss</a> permite que o Subversion verifique a identidade dos servidores de repositório HTTPS. Os certificados raiz SSL podem ser instalados a partir de um port:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/security/ca_root_nss</span>
<span class=c># make install clean</span></code></pre></div></div><div class=paragraph><p>ou como um pacote:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install ca_root_nss</span></code></pre></div></div></div><div class=sect3><h4 id=svn-svnlite>A.3.3. Svnlite<a class=anchor href=#svn-svnlite></a></h4><div class=paragraph><p>Uma versão leve do Subversion já está instalada no FreeBSD como <code>svnlite</code>. A versão do port ou pacote do Subversion é necessária apenas se a API do Python ou do Perl for necessária, ou se uma versão posterior do Subversion for desejada.</p></div><div class=paragraph><p>A única diferença do uso normal do Subversion é que o nome do comando é <code>svnlite</code>.</p></div></div><div class=sect3><h4 id=svn-install>A.3.4. Instalação<a class=anchor href=#svn-install></a></h4><div class=paragraph><p>Se o <code>svnlite</code> não estiver disponível ou a versão completa do Subversion for necessária, ele deverá ser instalado.</p></div><div class=paragraph><p>O Subversion pode ser instalado a partir da coleção de ports:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/devel/subversion</span>
<span class=c># make install clean</span></code></pre></div></div><div class=paragraph><p>O Subversion também pode ser instalado como um pacote:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg install subversion</span></code></pre></div></div></div><div class=sect3><h4 id=svn-usage>A.3.5. Executando o Subversion<a class=anchor href=#svn-usage></a></h4><div class=paragraph><p>Para obter uma cópia limpa do código-fonte em um diretório local, use <code>svn</code>. Os arquivos neste diretório são chamados de <em>cópia de trabalho local</em>.</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Mova ou exclua o diretório de destino existente antes de usar o <code>checkout</code> pela primeira vez.</p></div><div class=paragraph><p>O checkout em cima de um diretório não-<code>svn</code> existente pode causar conflitos entre os arquivos existentes e aqueles trazidos do repositório.</p></div></td></tr></tbody></table></div><div class=paragraph><p>O Subversion usa URLs para designar um repositório, sob a forma de <em>protocol://hostname/path</em>. O primeiro componente do caminho é o repositório do FreeBSD para acessar. Existem três repositórios diferentes, <code>base</code> para o código-fonte do sistema básico do FreeBSD, <code>ports</code> para a coleção de ports, e <code>doc</code> para a documentação. Por exemplo, o URL <code><a href=https://svn.FreeBSD.org/ports/head/ class=bare>https://svn.FreeBSD.org/ports/head/</a></code> especifica a ramificação principal do repositório de ports, usando o protocolo <code>https</code>.</p></div><div class=paragraph><p>Um checkout de um determinado repositório é executado com um comando como este:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># svn checkout https://svn.FreeBSD.org/repository/branch lwcdir</span></code></pre></div></div><div class=paragraph><p>Onde:</p></div><div class=ulist><ul><li><p>O <em>repository</em> é um dos repositórios do Projecto: <code>base</code>, <code>ports</code>, ou <code>doc</code>.</p></li><li><p>A <em>branch</em> depende do repositório usado. O <code>ports</code> e o <code>doc</code> são normalmente atualizados na ramificação <code>head</code>, enquanto <code>base</code> mantém a última versão de -CURRENT em <code>head</code> e as respectivas versões mais recentes das ramificações -STABLE em <code>stable/9</code> (9.<em>x</em>) e <code>stable/10</code> (10.<em>x</em>).</p></li><li><p>O <em>lwcdir</em> é o diretório de destino onde o conteúdo do ramo especificado deve ser colocado. Isso geralmente é <span class=filename>/usr/ports</span> para o <code>ports</code>, <span class=filename>/usr/src</span> para a <code>base</code>, e <span class=filename>/usr/doc</span> para o <code>doc</code>.</p></li></ul></div><div class=paragraph><p>Este exemplo obtém a coleção de ports do repositório do FreeBSD usando o protocolo HTTPS, colocando a cópia de trabalho local em <span class=filename>/usr/ports</span>. Se o <span class=filename>/usr/ports</span> já estiver presente, mas não tiver sido criado pelo <code>svn</code>, lembre-se de renomeá-lo ou excluí-lo antes do checkout.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># svn checkout https://svn.FreeBSD.org/ports/head /usr/ports</span></code></pre></div></div><div class=paragraph><p>Como o checkout inicial deve fazer o download da ramificação completa do repositório remoto, isso pode demorar um pouco. Por favor, seja paciente.</p></div><div class=paragraph><p>Após o checkout inicial, a cópia de trabalho local pode ser atualizada executando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># svn update lwcdir</span></code></pre></div></div><div class=paragraph><p>Para atualizar o <span class=filename>/usr/ports</span> criado no exemplo acima, use:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># svn update /usr/ports</span></code></pre></div></div><div class=paragraph><p>O update é muito mais rápido do que um checkout, transferindo apenas os arquivos que foram alterados.</p></div><div class=paragraph><p>Uma maneira alternativa de atualizar a cópia de trabalho local após o checkout é fornecida pelo <span class=filename>Makefile</span> existente em <span class=filename>/usr/ports</span>, <span class=filename>/usr/src</span>, e <span class=filename>/usr/doc</span>. Configure o <code>SVN_UPDATE</code> e use o destino <code>atualizar</code>. Por exemplo, para atualizar <span class=filename>/usr/src</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/src</span>
<span class=c># make update SVN_UPDATE=yes</span></code></pre></div></div></div><div class=sect3><h4 id=svn-mirrors>A.3.6. Sites Espelho do Subversion<a class=anchor href=#svn-mirrors></a></h4><div class=paragraph><p>O repositório Subversion do FreeBSD é:</p></div><div class="literalblock programlisting"><div class=content><pre>svn.FreeBSD.org</pre></div></div><div class=paragraph><p>Essa é uma rede de espelhos acessível publicamente a qual usa o GeoDNS para selecionar um servidor de backend apropriado. Para visualizar os repositórios Subversion do FreeBSD através de um navegador, use <a href=https://svnweb.FreeBSD.org/>https://svnweb.FreeBSD.org/</a>.</p></div><div class=paragraph><p>O HTTPS é o protocolo preferido, mas o pacote <span class=filename>security/ca_root_nss</span> precisará ser instalado para validar os certificados automaticamente.</p></div></div><div class=sect3><h4 id=_para_maiores_informações_2>A.3.7. Para Maiores Informações<a class=anchor href=#_para_maiores_informações_2></a></h4><div class=paragraph><p>Para outras informações sobre o uso do Subversion, por favor veja o "Subversion Book", intitulado <a href=http://svnbook.red-bean.com/>Version Controle com Subversion</a>, ou o <a href=http://subversion.apache.org/docs/>Documentação do Subversion</a>.</p></div></div></div><div class=sect2><h3 id=mirrors-rsync>A.4. Usando o rsync<a class=anchor href=#mirrors-rsync></a></h3><div class=paragraph><p>Estes sites disponibilizam o FreeBSD através do protocolo rsync. O utilitário rsync transfere apenas as diferenças entre dois conjuntos de arquivos. Isto é útil para sites espelho do servidor de FTP do FreeBSD . O pacote rsync está disponível para muitos sistemas operacionais, no FreeBSD, veja o port <a class=package href=https://cgit.freebsd.org/ports/tree/net/rsync/>net/rsync</a> ou use o pacote.</p></div><div class=dlist><dl><dt class=hdlist1>República Checa</dt><dd><p>rsync://ftp.cz.FreeBSD.org/</p><div class=paragraph><p>Coleções disponíveis:</p></div><div class=ulist><ul><li><p>ftp: Um espelho parcial do servidor de FTP do FreeBSD.</p></li><li><p>FreeBSD: Um espelho completo do servidor de FTP do FreeBSD.</p></li></ul></div></dd><dt class=hdlist1>Países Baixos</dt><dd><p>rsync://ftp.nl.FreeBSD.org/</p><div class=paragraph><p>Coleções disponíveis:</p></div><div class=ulist><ul><li><p>FreeBSD: Um espelho completo do servidor de FTP do FreeBSD.</p></li></ul></div></dd><dt class=hdlist1>Rússia</dt><dd><p>rsync://ftp.mtu.ru/</p><div class=paragraph><p>Coleções disponíveis:</p></div><div class=ulist><ul><li><p>FreeBSD: Um espelho completo do servidor de FTP do FreeBSD.</p></li><li><p>FreeBSD-Archive: Um espelho do servidor de FTP do FreeBSD Archive.</p></li></ul></div></dd><dt class=hdlist1>Suécia</dt><dd><p>rsync://ftp4.se.freebsd.org/</p><div class=paragraph><p>Coleções disponíveis:</p></div><div class=ulist><ul><li><p>FreeBSD: Um espelho completo do servidor de FTP do FreeBSD.</p></li></ul></div></dd><dt class=hdlist1>Taiwan</dt><dd><p>rsync://ftp.tw.FreeBSD.org/</p><div class=paragraph><p>rsync://ftp2.tw.FreeBSD.org/</p></div><div class=paragraph><p>rsync://ftp6.tw.FreeBSD.org/</p></div><div class=paragraph><p>Coleções disponíveis:</p></div><div class=ulist><ul><li><p>FreeBSD: Um espelho completo do servidor de FTP do FreeBSD.</p></li></ul></div></dd><dt class=hdlist1>Reino Unido</dt><dd><p>rsync://rsync.mirrorservice.org/</p><div class=paragraph><p>Coleções disponíveis:</p></div><div class=ulist><ul><li><p>ftp.freebsd.org: Um espelho completo do servidor de FTP do FreeBSD.</p></li></ul></div></dd><dt class=hdlist1>Estados Unidos da America</dt><dd><p>rsync://ftp-master.FreeBSD.org/</p><div class=paragraph><p>Este servidor só pode ser usado por sites espelhos primários do FreeBSD.</p></div><div class=paragraph><p>Coleções disponíveis:</p></div><div class=ulist><ul><li><p>FreeBSD: O arquivo master do servidor de FTP do FreeBSD.</p></li><li><p>acl: A lista do ACL mestre do FreeBSD.</p><div class=paragraph><p>rsync://ftp13.FreeBSD.org/</p></div><div class=paragraph><p>Coleções disponíveis:</p></div></li><li><p>FreeBSD: Um espelho completo do servidor de FTP do FreeBSD.</p></li></ul></div></dd></dl></div></div></div></div><div class=sect1><h2 id=bibliography>Apêndice B: Bibliografia<a class=anchor href=#bibliography></a></h2><div class=sectionbody><div class=paragraph><p>Enquanto páginas manuais fornecem uma referência definitiva para partes individuais do sistema operacional FreeBSD, elas raramente ilustram como juntar as peças para fazer todo o sistema operacional rodar sem problemas. Para isso, não há substituto para um bom livro ou manual do usuário na administração do sistema UNIX™.</p></div><div class=sect2><h3 id=bibliography-freebsd>B.1. Livros específicos para o FreeBSD<a class=anchor href=#bibliography-freebsd></a></h3><div class=paragraph><p>Livros internacionais:</p></div><div class=ulist><ul><li><p><a href=http://jdli.tw.FreeBSD.org/publication/book/freebsd2/index.htm>Using FreeBSD</a> (in Traditional Chinese), published by <a href=http://www.drmaster.com.tw/>Drmaster</a>, 1997. ISBN 9-578-39435-7.</p></li><li><p>FreeBSD Unleashed (Simplified Chinese translation), published by <a href=http://www.hzbook.com/>China Machine Press</a>. ISBN 7-111-10201-0.</p></li><li><p>FreeBSD From Scratch Second Edition (in Simplified Chinese), published by China Machine Press. ISBN 7-111-10286-X.</p></li><li><p>FreeBSD Handbook Second Edition (Simplified Chinese translation), published by <a href=http://www.ptpress.com.cn/>Posts & Telecom Press</a>. ISBN 7-115-10541-3.</p></li><li><p>FreeBSD & Windows (in Simplified Chinese), published by <a href=http://www.tdpress.com/>China Railway Publishing House</a>. ISBN 7-113-03845-X</p></li><li><p>FreeBSD Internet Services HOWTO (in Simplified Chinese), published by China Railway Publishing House. ISBN 7-113-03423-3</p></li><li><p>FreeBSD (in Japanese), published by CUTT. ISBN 4-906391-22-2 C3055 P2400E.</p></li><li><p><a href="http://www.shoeisha.com/book/Detail.asp?bid=650">Complete Introduction to FreeBSD</a> (in Japanese), published by <a href=http://www.shoeisha.co.jp/>Shoeisha Co., Ltd</a>. ISBN 4-88135-473-6 P3600E.</p></li><li><p><a href=http://www.ascii.co.jp/pb/book1/shinkan/detail/1322785.html>Personal UNIX Starter Kit FreeBSD</a> (in Japanese), published by <a href=http://www.ascii.co.jp/>ASCII</a>. ISBN 4-7561-1733-3 P3000E.</p></li><li><p>FreeBSD Handbook (Japanese translation), published by <a href=http://www.ascii.co.jp/>ASCII</a>. ISBN 4-7561-1580-2 P3800E.</p></li><li><p>FreeBSD mit Methode (in German), published by <a href=http://www.cul.de>Computer und Literatur Verlag</a>/Vertrieb Hanser, 1998. ISBN 3-932311-31-0.</p></li><li><p><a href=http://www.mitp.de/vmi/mitp/detail/pWert/1343/>FreeBSD de Luxe</a> (in German), published by <a href=http://www.mitp.de>Verlag Modere Industrie</a>, 2003. ISBN 3-8266-1343-0.</p></li><li><p><a href=http://www.pc.mycom.co.jp/FreeBSD/install-manual.html>FreeBSD Install and Utilization Manual</a> (in Japanese), published by <a href=http://www.pc.mycom.co.jp/>Mainichi Communications Inc.</a>, 1998. ISBN 4-8399-0112-0.</p></li><li><p>Onno W Purbo, Dodi Maryanto, Syahrial Hubbany, Widjil Widodo <em><a href=http://maxwell.itb.ac.id/>Building Internet Server with FreeBSD</a></em> (in Indonesia Language), published by <a href=http://www.elexmedia.co.id/>Elex Media Komputindo</a>.</p></li><li><p>Absolute BSD: The Ultimate Guide to FreeBSD (Traditional Chinese translation), published by <a href=http://www.grandtech.com.tw/>GrandTech Press</a>, 2003. ISBN 986-7944-92-5.</p></li><li><p><a href=http://www.twbsd.org/cht/book/>The FreeBSD 6.0 Book</a> (in Traditional Chinese), published by Drmaster, 2006. ISBN 9-575-27878-X.</p></li></ul></div><div class=paragraph><p>Livros de língua inglesa:</p></div><div class=ulist><ul><li><p><a href=http://www.absoluteFreeBSD.com/>Absolute FreeBSD, 2nd Edition: The Complete Guide to FreeBSD</a>, published by <a href=http://www.nostarch.com/>No Starch Press</a>, 2007. ISBN: 978-1-59327-151-0</p></li><li><p><a href=http://www.freebsdmall.com/cgi-bin/fm/bsdcomp>The Complete FreeBSD</a>, published by <a href=http://www.oreilly.com/>O’Reilly</a>, 2003. ISBN: 0596005164</p></li><li><p><a href=http://www.freebsd-corp-net-guide.com/>The FreeBSD Corporate Networker’s Guide</a>, published by <a href=http://www.awl.com/aw/>Addison-Wesley</a>, 2000. ISBN: 0201704811</p></li><li><p><a href=http://andrsn.stanford.edu/FreeBSD/introbook/>FreeBSD: An Open-Source Operating System for Your Personal Computer</a>, published by The Bit Tree Press, 2001. ISBN: 0971204500</p></li><li><p>Teach Yourself FreeBSD in 24 Hours, published by <a href=http://www.samspublishing.com/>Sams</a>, 2002. ISBN: 0672324245</p></li><li><p>FreeBSD 6 Unleashed, published by <a href=http://www.samspublishing.com/>Sams</a>, 2006. ISBN: 0672328755</p></li><li><p>FreeBSD: The Complete Reference, published by <a href=http://books.mcgraw-hill.com>McGrawHill</a>, 2003. ISBN: 0072224096</p></li></ul></div></div><div class=sect2><h3 id=bibliography-userguides>B.2. Guias de usuários<a class=anchor href=#bibliography-userguides></a></h3><div class=ulist><ul><li><p>Ohio State University has written a <a href=http://www.cs.duke.edu/csl/docs/unix_course/>UNIX Introductory Course</a> which is available online in HTML and PostScript format.</p><div class=paragraph><p>An Italian <a href=https://www.FreeBSD.org/doc/it_IT.ISO8859-15/books/unix-introduction/index.html>translation</a> of this document is available as part of the FreeBSD Italian Documentation Project.</p></div></li><li><p><a href=http://www.jp.FreeBSD.org/>Jpman Project, Japan FreeBSD Users Group</a>. FreeBSD User’s Reference Manual (Japanese translation). <a href=http://www.pc.mycom.co.jp/>Mainichi Communications Inc.</a>, 1998. ISBN4-8399-0088-4 P3800E.</p></li><li><p><a href=http://www.ed.ac.uk/>Edinburgh University</a> has written an <a href=http://www.ed.ac.uk/information-services/help-consultancy/is-skills/catalogue/program-op-sys-catalogue/unix1>Online Guide</a> for newcomers to the UNIX environment.</p></li></ul></div></div><div class=sect2><h3 id=bibliography-adminguides>B.3. Guias de Administradores<a class=anchor href=#bibliography-adminguides></a></h3><div class=ulist><ul><li><p><a href=http://www.jp.FreeBSD.org/>Jpman Project, Japan FreeBSD Users Group</a>. FreeBSD System Administrator’s Manual (Japanese translation). <a href=http://www.pc.mycom.co.jp/>Mainichi Communications Inc.</a>, 1998. ISBN4-8399-0109-0 P3300E.</p></li><li><p>Dreyfus, Emmanuel. <a href=http://www.eyrolles.com/Informatique/Livre/9782212114638/>Cahiers de l’Admin: BSD</a> 2nd Ed. (in French), Eyrolles, 2004. ISBN 2-212-11463-X</p></li></ul></div></div><div class=sect2><h3 id=bibliography-programmers>B.4. Guias de programadores<a class=anchor href=#bibliography-programmers></a></h3><div class=ulist><ul><li><p>Computer Systems Research Group, UC Berkeley. <em>4.4BSD Programmer’s Reference Manual</em>. O’Reilly & Associates, Inc., 1994. ISBN 1-56592-078-3</p></li><li><p>Computer Systems Research Group, UC Berkeley. <em>4.4BSD Programmer’s Supplementary Documents</em>. O’Reilly & Associates, Inc., 1994. ISBN 1-56592-079-1</p></li><li><p>Harbison, Samuel P. and Steele, Guy L. Jr. <em>C: A Reference Manual</em>. 4th Ed. Prentice Hall, 1995. ISBN 0-13-326224-3</p></li><li><p>Kernighan, Brian and Dennis M. Ritchie. <em>The C Programming Language</em>. 2nd Ed. PTR Prentice Hall, 1988. ISBN 0-13-110362-8</p></li><li><p>Lehey, Greg. <em>Porting UNIX Software</em>. O’Reilly & Associates, Inc., 1995. ISBN 1-56592-126-7</p></li><li><p>Plauger, P. J. <em>The Standard C Library</em>. Prentice Hall, 1992. ISBN 0-13-131509-9</p></li><li><p>Spinellis, Diomidis. <a href=http://www.spinellis.gr/codereading/>Code Reading: The Open Source Perspective</a>. Addison-Wesley, 2003. ISBN 0-201-79940-5</p></li><li><p>Spinellis, Diomidis. <a href=http://www.spinellis.gr/codequality/>Code Quality: The Open Source Perspective</a>. Addison-Wesley, 2006. ISBN 0-321-16607-8</p></li><li><p>Stevens, W. Richard and Stephen A. Rago. <em>Advanced Programming in the UNIX Environment</em>. 2nd Ed. Reading, Mass. : Addison-Wesley, 2005. ISBN 0-201-43307-9</p></li><li><p>Stevens, W. Richard. <em>UNIX Network Programming</em>. 2nd Ed, PTR Prentice Hall, 1998. ISBN 0-13-490012-X</p></li></ul></div></div><div class=sect2><h3 id=bibliography-osinternals>B.5. Internals do sistema operacional<a class=anchor href=#bibliography-osinternals></a></h3><div class=ulist><ul><li><p>Andleigh, Prabhat K. <em>UNIX System Architecture</em>. Prentice-Hall, Inc., 1990. ISBN 0-13-949843-5</p></li><li><p>Jolitz, William. "Porting UNIX to the 386". <em>Dr. Dobb’s Journal</em>. January 1991-July 1992.</p></li><li><p>Leffler, Samuel J., Marshall Kirk McKusick, Michael J Karels and John Quarterman <em>The Design and Implementation of the 4.3BSD UNIX Operating System</em>. Reading, Mass. : Addison-Wesley, 1989. ISBN 0-201-06196-1</p></li><li><p>Leffler, Samuel J., Marshall Kirk McKusick, <em>The Design and Implementation of the 4.3BSD UNIX Operating System: Answer Book</em>. Reading, Mass. : Addison-Wesley, 1991. ISBN 0-201-54629-9</p></li><li><p>McKusick, Marshall Kirk, Keith Bostic, Michael J Karels, and John Quarterman. <em>The Design and Implementation of the 4.4BSD Operating System</em>. Reading, Mass. : Addison-Wesley, 1996. ISBN 0-201-54979-4</p><div class=paragraph><p>(Chapter 2 of this book is available <a href=https://www.FreeBSD.org/doc/en_US.ISO8859-1/books/design-44bsd/book.html>online</a> as part of the FreeBSD Documentation Project.)</p></div></li><li><p>Marshall Kirk McKusick, George V. Neville-Neil <em>The Design and Implementation of the FreeBSD Operating System</em>. Boston, Mass. : Addison-Wesley, 2004. ISBN 0-201-70245-2</p></li><li><p>Marshall Kirk McKusick, George V. Neville-Neil, Robert N. M. Watson <em>The Design and Implementation of the FreeBSD Operating System, 2nd Ed.</em>. Westford, Mass. : Pearson Education, Inc., 2014. ISBN 0-321-96897-2</p></li><li><p>Stevens, W. Richard. <em>TCP/IP Illustrated, Volume 1: The Protocols</em>. Reading, Mass. : Addison-Wesley, 1996. ISBN 0-201-63346-9</p></li><li><p>Schimmel, Curt. <em>Unix Systems for Modern Architectures</em>. Reading, Mass. : Addison-Wesley, 1994. ISBN 0-201-63338-8</p></li><li><p>Stevens, W. Richard. <em>TCP/IP Illustrated, Volume 3: TCP for Transactions, HTTP, NNTP and the UNIX Domain Protocols</em>. Reading, Mass. : Addison-Wesley, 1996. ISBN 0-201-63495-3</p></li><li><p>Vahalia, Uresh. <em>UNIX Internals — The New Frontiers</em>. Prentice Hall, 1996. ISBN 0-13-101908-2</p></li><li><p>Wright, Gary R. and W. Richard Stevens. <em>TCP/IP Illustrated, Volume 2: The Implementation</em>. Reading, Mass. : Addison-Wesley, 1995. ISBN 0-201-63354-X</p></li></ul></div></div><div class=sect2><h3 id=bibliography-security>B.6. Referências de segurança<a class=anchor href=#bibliography-security></a></h3><div class=ulist><ul><li><p>Cheswick, William R. and Steven M. Bellovin. <em>Firewalls and Internet Security: Repelling the Wily Hacker</em>. Reading, Mass. : Addison-Wesley, 1995. ISBN 0-201-63357-4</p></li><li><p>Garfinkel, Simson. <em>PGP Pretty Good Privacy</em> O’Reilly & Associates, Inc., 1995. ISBN 1-56592-098-8</p></li></ul></div></div><div class=sect2><h3 id=bibliography-hardware>B.7. Referências de Hardware<a class=anchor href=#bibliography-hardware></a></h3><div class=ulist><ul><li><p>Anderson, Don and Tom Shanley. <em>Pentium Processor System Architecture</em>. 2nd Ed. Reading, Mass. : Addison-Wesley, 1995. ISBN 0-201-40992-5</p></li><li><p>Ferraro, Richard F. <em>Programmer’s Guide to the EGA, VGA, and Super VGA Cards</em>. 3rd ed. Reading, Mass. : Addison-Wesley, 1995. ISBN 0-201-62490-7</p></li><li><p>Intel Corporation publishes documentation on their CPUs, chipsets and standards on their <a href=http://developer.intel.com/>developer web site</a>, usually as PDF files.</p></li><li><p>Shanley, Tom. <em>80486 System Architecture</em>. 3rd Ed. Reading, Mass. : Addison-Wesley, 1995. ISBN 0-201-40994-1</p></li><li><p>Shanley, Tom. <em>ISA System Architecture</em>. 3rd Ed. Reading, Mass. : Addison-Wesley, 1995. ISBN 0-201-40996-8</p></li><li><p>Shanley, Tom. <em>PCI System Architecture</em>. 4th Ed. Reading, Mass. : Addison-Wesley, 1999. ISBN 0-201-30974-2</p></li><li><p>Van Gilluwe, Frank. <em>The Undocumented PC</em>, 2nd Ed. Reading, Mass: Addison-Wesley Pub. Co., 1996. ISBN 0-201-47950-8</p></li><li><p>Messmer, Hans-Peter. <em>The Indispensable PC Hardware Book</em>, 4th Ed. Reading, Mass : Addison-Wesley Pub. Co., 2002. ISBN 0-201-59616-4</p></li></ul></div></div><div class=sect2><h3 id=bibliography-history>B.8. História do UNIX™<a class=anchor href=#bibliography-history></a></h3><div class=ulist><ul><li><p>Lion, John <em>Lion’s Commentary on UNIX, 6th Ed. With Source Code</em>. ITP Media Group, 1996. ISBN 1573980137</p></li><li><p>Raymond, Eric S. <em>The New Hacker’s Dictionary, 3rd edition</em>. MIT Press, 1996. ISBN 0-262-68092-0. Also known as the <a href=http://www.catb.org/~esr/jargon/html/index.html>Jargon File</a></p></li><li><p>Salus, Peter H. <em>A quarter century of UNIX</em>. Addison-Wesley Publishing Company, Inc., 1994. ISBN 0-201-54777-5</p></li><li><p>Simon Garfinkel, Daniel Weise, Steven Strassmann. <em>The UNIX-HATERS Handbook</em>. IDG Books Worldwide, Inc., 1994. ISBN 1-56884-203-1. Out of print, but available <a href=http://www.simson.net/ref/ugh.pdf>online</a>.</p></li><li><p>Don Libes, Sandy Ressler <em>Life with UNIX</em> — special edition. Prentice-Hall, Inc., 1989. ISBN 0-13-536657-7</p></li><li><p><em>The BSD family tree</em>. <a href="https://svnweb.freebsd.org/base/head/shared/misc/bsd-family-tree?view=co">https://svnweb.freebsd.org/base/head/shared/misc/bsd-family-tree?view=co</a> or <a href=file://localhost/usr/shared/misc/bsd-family-tree>/usr/shared/misc/bsd-family-tree</a> on a FreeBSD machine.</p></li><li><p><em>Networked Computer Science Technical Reports Library</em>.</p></li><li><p><em>Old BSD releases from the Computer Systems Research group (CSRG)</em>. <a href=http://www.mckusick.com/csrg/>http://www.mckusick.com/csrg/</a>: The 4CD set covers all BSD versions from 1BSD to 4.4BSD and 4.4BSD-Lite2 (but not 2.11BSD, unfortunately). The last disk also holds the final sources plus the SCCS files.</p></li><li><p>Kernighan, Brian <em>Unix: A History and a Memoir</em>. Kindle Direct Publishing, 2020. ISBN 978-169597855-3</p></li></ul></div></div><div class=sect2><h3 id=bibliography-journals>B.9. Periódicos, Jornais e Revistas<a class=anchor href=#bibliography-journals></a></h3><div class=ulist><ul><li><p><a href=http://www.admin-magazin.de/>Admin Magazin</a> (in German), published by Medialinx AG. ISSN: 2190-1066</p></li><li><p><a href=http://www.bsdmag.org/>BSD Magazine</a>, published by Software Press Sp. z o.o. SK. ISSN: 1898-9144</p></li><li><p><a href=http://www.bsdnow.tv/>BSD Now — Video Podcast</a>, published by Jupiter Broadcasting LLC</p></li><li><p><a href=http://bsdtalk.blogspot.com/>BSD Talk Podcast</a>, by Will Backman</p></li><li><p><a href=http://freebsdjournal.com/>FreeBSD Journal</a>, published by S&amp;W Publishing, sponsored by The FreeBSD Foundation. ISBN: 978-0-615-88479-0</p></li></ul></div></div></div></div><div class=sect1><h2 id=eresources>Apêndice C: Recursos na Internet<a class=anchor href=#eresources></a></h2><div class=sectionbody><div class=paragraph><p>O ritmo acelerado do progresso do FreeBSD torna a mídia impressa impraticável como um meio de acompanhar os desenvolvimentos mais recentes. Os recursos eletrônicos são a melhor maneira, se não a única, de se manter informado sobre os últimos avanços. Como o FreeBSD é um esforço voluntário, a própria comunidade de usuários geralmente serve como um "departamento de suporte técnico", com o correio eletrônico, fóruns na web e notícias da USENET sendo a maneira mais eficaz de alcançar essa comunidade.</p></div><div class=paragraph><p>Os pontos mais importantes de contato com a comunidade de usuários do FreeBSD são descritos abaixo. Por favor, envie outros recursos não mencionados aqui para a <a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-doc>lista de discussão do projeto de documentação do FreeBSD</a> para que eles também possam ser incluídos.</p></div><div class=sect2><h3 id=eresources-www>C.1. Websites<a class=anchor href=#eresources-www></a></h3><div class=ulist><ul><li><p><a href=https://forums.FreeBSD.org/>The FreeBSD Forums</a> fornecem um fórum de discussão baseado na web para questões sobre o FreeBSD e para discussão técnica.</p></li><li><p>O <a href=http://www.youtube.com/bsdconferences>Canal do YouTube BSDConferences</a> oferece uma coleção de vídeos de alta qualidade de conferências sobre o BSD em todo o mundo. Esta é uma ótima maneira de assistir desenvolvedores-chave fazerem apresentações sobre novos trabalhos no FreeBSD.</p></li></ul></div></div><div class=sect2><h3 id=eresources-mail>C.2. Listas de Discussão<a class=anchor href=#eresources-mail></a></h3><div class=paragraph><p>As listas de discussão são a maneira mais direta de abordar questões ou abrir uma discussão técnica para um público concentrado do FreeBSD. Há uma grande variedade de listas em vários tópicos diferentes do FreeBSD. Enviar perguntas para a lista de discussão mais adequada invariavelmente garantirá uma resposta mais rápida e precisa.</p></div><div class=paragraph><p>Os charters das várias listas são dadas na parte inferior deste documento. <em>Por favor, leia o regulamento antes de se cadastrar ou enviar e-mails para qualquer lista</em>. A maioria dos assinantes de listas recebe muitas centenas de mensagens relacionadas ao FreeBSD todos os dias, e os charters e regras de uso visam manter a relação sinal-ruído das listas altas. Para fazer menos, as listas de discussão acabarão por falhar como um meio de comunicação eficaz para o Projeto.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p><em>Para testar a capacidade de enviar email para as listas do FreeBSD, envie uma mensagem de teste para <a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-test>freebsd-test</a>.</em> Por favor, não envie mensagens de teste para qualquer outra lista.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Em caso de dúvida sobre a lista para colocar uma pergunta, consulte <a href=https://docs.freebsd.org/pt-br/articles/freebsd-questions/>Como obter os melhores resultados da lista de discussão FreeBSD-questions</a>.</p></div><div class=paragraph><p>Antes de postar em qualquer lista, aprenda sobre a melhor forma de usar as listas de discussão, por exemplo, como ajudar a evitar discussões repetidas com frequência, lendo o documento de <a href=https://docs.freebsd.org/pt-br/articles/mailing-list-faq/>Perguntas Frequentes das Mailing Lists</a> (FAQ).</p></div><div class=paragraph><p>Os arquivos são mantidos para todas as listas de discussão e podem ser pesquisados usando o <a href=https://www.FreeBSD.org/search/>servidor da World Wide Web do FreeBSD</a>. A busca por palavras-chaves no arquivo oferece uma excelente maneira de encontrar respostas para perguntas freqüentes e deve ser consultada antes de postar uma pergunta. Note que isso também significa que as mensagens enviadas para as listas de discussão do FreeBSD são arquivadas perpetuamente. Se a proteção da sua privacidade é uma preocupação, considere usar um endereço de e-mail secundário descartável e postar apenas informações públicas.</p></div><div class=sect3><h4 id=eresources-summary>C.2.1. Sumário<a class=anchor href=#eresources-summary></a></h4><div class=paragraph><p><em>Listas gerais:</em> A seguir, listas gerais das quais qualquer pessoa é livre (e incentivada) a participar:</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Lista</th><th class="tableblock halign-left valign-top">Propósito</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-advocacy>freebsd-advocacy</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Evangelismo do FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-announce>freebsd-announce</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Eventos importantes e marcos do projeto (moderado)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-arch>freebsd-arch</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Discussões de arquitetura e design</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-bugbusters>freebsd-bugbusters</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Discussões relativas à manutenção do banco de dados de relatórios de problemas do FreeBSD e ferramentas relacionadas</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-bugs>freebsd-bugs</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Relatório de erros</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-chat>freebsd-chat</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Itens não técnicos relacionados à comunidade FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-chromium>freebsd-chromium</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Problemas do Chromium específicos do FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-current>freebsd-current</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Discussão sobre o uso do FreeBSD-CURRENT</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-isp>freebsd-isp</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Problemas para provedores de serviços de Internet usando o FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-jobs>freebsd-jobs</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Vagas de empregos para trabalhar com FreeBSD e oportunidades de consultoria</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-quarterly-calls>freebsd-quarterly-calls</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Chamadas para relatórios de status trimestrais (moderado)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-questions>freebsd-questions</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Perguntas de usuários e suporte técnico</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-security-notifications>freebsd-security-notifications</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Notificações de segurança (moderadas)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-stable>freebsd-stable</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Discussão sobre o uso do FreeBSD-STABLE</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-test>freebsd-test</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Lista para qual enviar mensagens de teste em vez de para uma das listas reais</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-women>freebsd-women</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Defesa do FreeBSD para mulheres</p></td></tr></tbody></table><div class=paragraph><p><em>Listas técnicas:</em> As listas a seguir são para discussão técnica. Leia atentamente o regulamento de cada lista antes de aderir ou enviar e-mails para uma, pois há diretrizes firmes para seu uso e conteúdo.</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Lista</th><th class="tableblock halign-left valign-top">Propósito</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-acpi>freebsd-acpi</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>ACPI e desenvolvimento de gerenciamento de energia</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-amd64>freebsd-amd64</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Portando FreeBSD para sistemas AMD64 (moderado)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-apache>freebsd-apache</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Discussão sobre ports relacionados ao Apache</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-arm>freebsd-arm</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Portando o FreeBS para processadores ARM ™</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-atm>freebsd-atm</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Usando a rede ATM com o FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-bluetooth>freebsd-bluetooth</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Usando a tecnologia Bluetooth ™ no FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-cloud>freebsd-cloud</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>FreeBSD em plataformas em nuvem (EC2, GCE, Azure, etc.)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-cluster>freebsd-cluster</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Usando o FreeBSD em um ambiente clusterizado</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-database>freebsd-database</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Discutindo o uso e desenvolvimento do banco de dados no FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-desktop>freebsd-desktop</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Usando e melhorando o FreeBSD na área de trabalho</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/dev-ci>dev-ci</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Construa e teste relatórios dos servidores de integração contínua</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/dev-reviews>dev-reviews</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Notificações do sistema de revisão do FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-doc>freebsd-doc</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Criando documentos relacionados ao FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-drivers>freebsd-drivers</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Escrevendo drivers de dispositivos para o FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-dtrace>freebsd-dtrace</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Usando e trabalhando no DTrace no FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-eclipse>freebsd-eclipse</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Usuários FreeBSD do Eclipse IDE, ferramentas, aplicativos rich client e ports.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-elastic>freebsd-elastic</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Discussões específicas sobre ElasticSearch no FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-embedded>freebsd-embedded</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Usando o FreeBSD em aplicativos embarcados</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-eol>freebsd-eol</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Peer suporte a softwares relacionados ao FreeBSD que não são mais suportado pelo Projeto FreeBSD.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-emulation>freebsd-emulation</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Emulação de outros sistemas como o Linux/MS-DOS™/Windows™</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-enlightenment>freebsd-enlightenment</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Portando o Enlightenment e aplicativos Enlightenment</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-erlang>freebsd-erlang</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Discussões específicas sobre Erlang no FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-firewire>freebsd-firewire</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Discussão técnica do FreeBSD FireWire™ (iLink, IEEE 1394)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-fortran>freebsd-fortran</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Fortran no FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-fs>freebsd-fs</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Sistemas de arquivos</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-games>freebsd-games</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Suporte para jogos no FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-gecko>freebsd-gecko</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Problemas do Gecko Rendering Engine</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-geom>freebsd-geom</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Discussões e implementações específicas do GEOM</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-git>freebsd-git</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Discussão sobre o uso do git no projeto FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-gnome>freebsd-gnome</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Portando aplicativos GNOME e o GNOME</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-hackers>freebsd-hackers</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Discussão técnica geral</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-haskell>freebsd-haskell</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Questões e discussões sobre o Haskell específicas do FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-hardware>freebsd-hardware</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Discussão geral de hardware para executar o FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-i18n>freebsd-i18n</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Internacionalização do FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-infiniband>freebsd-infiniband</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Infiniband no FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-ipfw>freebsd-ipfw</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Discussão técnica sobre o redesenho do código de firewall de IP</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-isdn>freebsd-isdn</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Desenvolvedores ISDN</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-jail>freebsd-jail</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Discussões sobre <a href="https://man.freebsd.org/cgi/man.cgi?query=jail&amp;sektion=8&amp;format=html">jail(8)</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-java>freebsd-java</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Desenvolvedores Java™ e pessoas trabalhando no port dos JDK™s para o FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=https://mail.kde.org/mailman/listinfo/kde-freebsd>freebsd-kde</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Portando aplicativos KDE e o KDE</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-lfs>freebsd-lfs</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Portando o LFS para o FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-mips>freebsd-mips</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Portando o FreeBS para MIPS ™</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-mono>freebsd-mono</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Aplicativos Mono e C # no FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-multimedia>freebsd-multimedia</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Aplicações multimídia</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-new-bus>freebsd-new-bus</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Discussões técnicas sobre arquitetura de barramento</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-net>freebsd-net</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Discussão de rede e código-fonte TCP/IP</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-numerics>freebsd-numerics</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Discussões sobre a implementação de alta qualidade de funções libm</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-ocaml>freebsd-ocaml</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Discussões específicas sobre OCaml no FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-office>freebsd-office</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Aplicativos do Office no FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-performance>freebsd-performance</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Perguntas de ajuste de desempenho para instalações de alto desempenho/carga</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-perl>freebsd-perl</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Manutenção de vária\os ports relacionados ao Perl</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-pf>freebsd-pf</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Discussão e perguntas sobre o sistema de firewall de filtro de pacotes</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-pkg>freebsd-pkg</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Gerenciamento de pacotes binários e discussão de ferramentas de pacote</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-pkg-fallout>freebsd-pkg-fallout</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Registros de fallout da construção de pacotes</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-pkgbase>freebsd-pkgbase</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Empacotando o sistema básico do FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-platforms>freebsd-platforms</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>No que diz respeito ao port para plataformas de arquitetura não Intel™</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-ports>freebsd-ports</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Discussão da Coleção de Ports</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-ports-announce>freebsd-ports-announce</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Notícias e instruções importantes sobre a coleção de ports (moderada)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-ports-bugs>freebsd-ports-bugs</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Discussão dos bugs/PRs dos ports</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-ppc>freebsd-ppc</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Portando o FreeBSD para o PowerPC ™</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-proliant>freebsd-proliant</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Discussão técnica do FreeBSD em plataformas de servidores HP ProLiant</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-python>freebsd-python</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Problemas específicos do Python para FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-rc>freebsd-rc</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Discussão relacionada ao sistema <span class=filename>rc.d</span> e seu desenvolvimento</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-realtime>freebsd-realtime</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Desenvolvimento de extensões em tempo real para o FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-riscv>freebsd-riscv</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Portando o FreeBSD para sistemas RISC-V™</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-ruby>freebsd-ruby</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Discussões específicas sobre o Ruby no FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-scsi>freebsd-scsi</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>O subsistema SCSI</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-security>freebsd-security</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Problemas de segurança que afetam o FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-snapshots>freebsd-snapshots</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Anúncios de Snapshots dos ramos de Desenvolvimento do FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-sparc64>freebsd-sparc64</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Portando o FreeBSD para sistemas baseados em SPARC ™</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-standards>freebsd-standards</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Conformidade do FreeBSD com os padrões C99 e POSIX ™</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-sysinstall>freebsd-sysinstall</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Desenvolvimento do <a href="https://man.freebsd.org/cgi/man.cgi?query=sysinstall&amp;sektion=8&amp;format=html">sysinstall(8)</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-tcltk>freebsd-tcltk</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Discussões Tcl / Tk específicas do FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-testing>freebsd-testing</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Testando no FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-tex>freebsd-tex</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Portando o TeX e seus aplicativos para o FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-threads>freebsd-threads</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Threads no FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-tilera>freebsd-tilera</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Portando o FreeBSD para a família Tilera de CPUs</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-tokenring>freebsd-tokenring</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Suporte Token Ring no FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-toolchain>freebsd-toolchain</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Manutenção do toolchain integrado do FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-translators>freebsd-translators</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Traduzindo documentos e programas do FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-transport>freebsd-transport</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Discussões de protocolos de rede em nível de transporte no FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-usb>freebsd-usb</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Discutindo o suporte do FreeBSD para USB</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-virtualization>freebsd-virtualization</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Discussão de várias técnicas de virtualização suportadas pelo FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-vuxml>freebsd-vuxml</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Discussão sobre a infraestrutura VuXML</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-x11>freebsd-x11</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Manutenção e suporte do X11 no FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-xen>freebsd-xen</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Discussão do port do FreeBSD para o Xen™ - implementação e uso</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-xfce>freebsd-xfce</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>XFCE para o FreeBSD - portando e mantendo</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-zope>freebsd-zope</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Zope para o FreeBSD - portando e mantendo</p></td></tr></tbody></table><div class=paragraph><p><em>Listas limitadas:</em> As listas a seguir são para públicos mais especializados (e exigentes) e provavelmente não são de interesse para o público em geral. Também é uma boa ideia estabelecer uma presença nas listas técnicas antes de entrar em uma dessas listas limitadas para entender a etiqueta de comunicação envolvida.</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Lista</th><th class="tableblock halign-left valign-top">Propósito</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-hubs>freebsd-hubs</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Pessoas executando sites espelho (suporte infraestrutural)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-user-groups>freebsd-user-groups</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Coordenação de grupo de usuários</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-wip-status>freebsd-wip-status</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>FreeBSD Work-In-Progress Status</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-wireless>freebsd-wireless</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Discussões da pilha 802.11, ferramentas, desenvolvimento de drivers de dispositivos</p></td></tr></tbody></table><div class=paragraph><p><em>Listas de resumo:</em> Todas as listas acima estão disponíveis em formato resumido. Uma vez inscrito em uma lista, as opções de resumo podem ser alteradas na seção de opções da conta.</p></div><div class=paragraph><p><em>Listas de SVN:</em> As listas a seguir são para pessoas interessadas em ver as mensagens de log para alterações em várias áreas da árvore de código-fonte. Elas são listas de <em>somente leitura</em> e não devem ter correio enviado para elas.</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Lista</th><th class="tableblock halign-left valign-top">Área do Fonte</th><th class="tableblock halign-left valign-top">Descrição da área (fonte para)</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/svn-doc-all>svn-doc-all</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/doc</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Todas as alterações no repositório Subversion do doc (exceto para <span class=filename>user</span>, <span class=filename>projects</span> e <span class=filename>translations</span>)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/svn-doc-head>svn-doc-head</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/doc</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Todas as alterações na ramificação "head" do repositório do Subversion do doc</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/svn-doc-projects>svn-doc-projects</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/doc/projects</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Todas as alterações na área <span class=filename>projects</span> do repositório Subversion do doc</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/svn-doc-svnadmin>svn-doc-svnadmin</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/doc</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Todas as mudanças nos scripts administrativos, hooks e outros dados de configuração do repositório do Subversion do doc</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/svn-ports-all>svn-ports-all</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/ports</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Todas as mudanças no repositório do Subversion do ports</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/svn-ports-head>svn-ports-head</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/ports</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Todas as mudanças na ramificação " head " do repositório do Subversion do ports</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/svn-ports-svnadmin>svn-ports-svnadmin</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/ports</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Todas as mudanças nos scripts administrativos, hooks e outros dados de configuração do repositório Subversion das portas</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/svn-src-all>svn-src-all</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/src</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Todas as mudanças no repositório src Subversion (exceto para <span class=filename>user</span> e <span class=filename>projects</span>)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/svn-src-head>svn-src-head</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/src</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Todas as mudanças na ramificação " head " do repositório src Subversion (a ramificação FreeBSD-CURRENT)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/svn-src-projects>svn-src-projects</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/projects</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Todas as mudanças na área <span class=filename>projects</span> do repositório src do Subversion</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/svn-src-release>svn-src-release</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/src</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Todas as mudanças na área <span class=filename>releases</span> do repositório src do Subversion</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/svn-src-releng>svn-src-releng</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/src</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Todas as mudanças nas ramificações <span class=filename>releng</span> do repositório src Subversion (as ramificações de engenharia de segurança/release)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/svn-src-stable>svn-src-stable</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/src</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Todas as mudanças para todos os ramos estáveis do repositório src Subversion</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/svn-src-stable-6>svn-src-stable-6</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/src</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Todas as alterações na ramificação <span class=filename>stable/6</span> do repositório src Subversion</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/svn-src-stable-7>svn-src-stable-7</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/src</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Todas as alterações na ramificação <span class=filename>stable/7</span> do repositório src Subversion</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/svn-src-stable-8>svn-src-stable-8</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/src</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Todas as mudanças na ramificação <span class=filename>stable/8</span> do repositório src Subversion</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/svn-src-stable-9>svn-src-stable-9</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/src</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Todas as alterações na ramificação <span class=filename>stable/9</span> do repositório src Subversion</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/svn-src-stable-10>svn-src-stable-10</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/src</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Todas as mudanças na ramificação <span class=filename>stable/10</span> do repositório src do Subversion</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/svn-src-stable-11>svn-src-stable-11</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/src</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Todas as alterações na ramificação <span class=filename>stable/11</span> do repositório src Subversion</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/svn-src-stable-12>svn-src-stable-12</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/src</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Todas as mudanças na ramificação <span class=filename>stable/12</span> do repositório src do Subversion</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/svn-src-stable-other>svn-src-stable-other</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/src</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Todas as mudanças para os ramos mais antigos <span class=filename>stable</span> do repositório src Subversion</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/svn-src-svnadmin>svn-src-svnadmin</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/src</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Todas as mudanças nos scripts administrativos, hooks e outros dados de configuração do repositório src do Subversion</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/svn-src-user>svn-src-user</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/src</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Todas as mudanças na área experimental <span class=filename>user</span> do repositório src do Subversion</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><a href=http://lists.FreeBSD.org/mailman/listinfo/svn-src-vendor>svn-src-vendor</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/src</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Todas as mudanças na área de trabalho do fornecedor do repositório src Subversion</p></td></tr></tbody></table></div><div class=sect3><h4 id=eresources-subscribe>C.2.2. Como se inscrever<a class=anchor href=#eresources-subscribe></a></h4><div class=paragraph><p>Para se inscrever em uma lista, clique no nome da lista em <a href=http://lists.FreeBSD.org/mailman/listinfo>http://lists.FreeBSD.org/mailman/listinfo</a> . A página exibida deve conter todas as instruções de inscrição necessárias para essa lista.</p></div><div class=paragraph><p>Para realmente postar em uma determinada lista, envie um email para <a href=mailto:listname@FreeBSD.org>listname@FreeBSD.org</a>. Ele será então redistribuído para membros da lista de discussão em todo o mundo.</p></div><div class=paragraph><p>Para cancelar a inscrição em uma lista, clique no URL encontrado na parte inferior de todos os e-mails recebidos da lista. Também é possível enviar um email para <a href=mailto:listname-unsubscribe@FreeBSD.org>listname-unsubscribe@FreeBSD.org</a> para cancelar a inscrição.</p></div><div class=paragraph><p>É importante manter a discussão nas listas de discussão técnicas em uma trilha técnica. Para receber apenas os anúncios importantes, junte-se à <a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-announce>lista de discussão de anúncios do FreeBSD</a>, que é destinada a tráfego pouco frequente .</p></div></div><div class=sect3><h4 id=eresources-charters>C.2.3. Estatutos das Listas<a class=anchor href=#eresources-charters></a></h4><div class=paragraph><p><em>Todas</em> as listas de discussão do FreeBSD possuem certas regras básicas que devem ser seguidas por qualquer pessoa que as utilize. O não cumprimento destas diretrizes resultará em dois (2) avisos escritos do Postmaster do FreeBSD <a href=mailto:postmaster@FreeBSD.org>postmaster@FreeBSD.org</a>, após o que, em uma terceira ofensa, o usuário será removido de todas as listas de discussão do FreeBSD e filtrados de postagem posterior para elas. Lamentamos que tais regras e medidas sejam absolutamente necessárias, mas a Internet de hoje é um ambiente bastante hostil, ao que parece, e muitos não conseguem perceber o quão frágeis são alguns de seus mecanismos.</p></div><div class=paragraph><p>Regras Básicas:</p></div><div class=ulist><ul><li><p>O tópico de qualquer postagem deve estar de acordo com o regulamento básico da lista para a qual ele é postado. Se a lista for sobre questões técnicas, a mensagem deve conter discussão técnica. Conversa irrelevante em curso ou provocações apenas prejudicam o valor da lista de discussão para todos e não será tolerado. Para discussões de forma livre sobre um tópico em particular, a <a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-chat>lista de discussão do chat do FreeBSD</a> está disponível gratuitamente e deve ser usada para isso.</p></li><li><p>Nenhuma postagem deve ser feita para mais de 2 listas de discussão, e apenas para 2 quando houver necessidade clara e óbvia de postar nas duas listas. Para a maioria das listas, já existe uma grande quantidade de sobreposições de assinantes e, exceto pelas mixagens mais esotéricas (digamos " -stable & -scsi "), não há motivo para postar em mais de uma lista ao mesmo tempo. Se uma mensagem for recebida com várias listas de discussão na linha <code>Cc</code>, ajuste a linha <code>Cc</code> antes de responder. <em>A pessoa que responde ainda é responsável por postagens cruzadas, independentemente de quem tenha sido o remetente.</em></p></li><li><p>Ataques pessoais e palavrões (no contexto de um argumento) não são permitidos, e isso inclui usuários e desenvolvedores. Violações brutais da netiqueta, como a extração ou repostagem de correspondência privada quando a permissão para fazer isso não existe, são desaprovadas, mas não especificamente forçadas. <em>No entanto</em>, também existem muito poucos casos em que tal conteúdo se encaixaria no estatuto de uma lista e, portanto, provavelmente ele geraria uma advertência (ou proibição).</p></li><li><p>A publicidade de produtos ou serviços não relacionados ao FreeBSD é estritamente proibida e resultará em uma proibição imediata se for claro que o ofensor está anunciando por spam.</p></li></ul></div><div class=paragraph><p><em>Estatutos individuais das listas:</em></p></div><div class=dlist><dl><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-acpi>freebsd-acpi</a></dt><dd><p><em>ACPI e desenvolvimento de gestão de energia</em></p></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-announce>freebsd-announce</a></dt><dd><p><em>Eventos / marcos importantes</em></p><div class=paragraph><p>Esta é a lista de discussão para pessoas interessadas apenas em anúncios ocasionais de eventos significativos do FreeBSD. Isso inclui anúncios sobre snapshots e outros releases. Ela contém anúncios de novos recursos do FreeBSD. Pode conter chamadas para voluntários, etc. Esta é uma lista de discussão de baixo volume, estritamente moderada.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-arch>freebsd-arch</a></dt><dd><p><em>Discussão sobre arquitetura e design</em></p><div class=paragraph><p>Esta lista é para discussão da arquitetura do FreeBSD. As mensagens serão principalmente mantidas estritamente de natureza técnica. Exemplos de tópicos adequados são:</p></div><div class=ulist><ul><li><p>Como fazer um re-vamp do sistema de compilação para ter várias compilações personalizadas em execução ao mesmo tempo.</p></li><li><p>O que precisa ser corrigido com o VFS para fazer com que as camadas Heidemann funcionem.</p></li><li><p>Como podemos mudar a interface do driver de dispositivo para poder usar os mesmos drivers de forma limpa em muitos barramentos e arquiteturas.</p></li><li><p>Como escrever um driver de rede.</p></li></ul></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-bluetooth>freebsd-bluetooth</a></dt><dd><p><em>Bluetooth ™ no FreeBSD</em></p><div class=paragraph><p>Este é o fórum onde os usuários de Bluetooth™ no FreeBSD se reúnem. Problemas de design, detalhes de implementação, patches, relatórios de bugs, relatórios de status, solicitações de recursos e todos os assuntos relacionados a Bluetooth ™ são bem vindos.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-bugbusters>freebsd-bugbusters</a></dt><dd><p><em>Coordenação sobre o esforço de manuseio dos Relatórios de Problemas</em></p><div class=paragraph><p>O objetivo desta lista é servir como um fórum de coordenação e discussão para o Bugmeister, seus Bugbusters e quaisquer outras partes que tenham interesse genuíno no banco de dados de RP. Esta lista não é para discussões sobre bugs específicos, patches ou PRs.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-bugs>freebsd-bugs</a></dt><dd><p><em>Relatórios de bugs</em></p><div class=paragraph><p>Esta é a lista de discussão para reportar bugs no FreeBSD. Sempre que possível, os bugs devem ser submetidos usando a <a href=https://bugs.freebsd.org/bugzilla/enter_bug.cgi>interface web</a>.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-chat>freebsd-chat</a></dt><dd><p><em>Itens não técnicos relacionados à comunidade FreeBSD</em></p><div class=paragraph><p>Esta lista contém o overflow de outras listas sobre informações sociais não técnicas. Ela inclui discussões sobre se Jordan se parece com um furão ou não, se deve ou não digitar em maiúsculas, quem está tomando muito café, onde a melhor cerveja é preparada, quem está fazendo cerveja no porão, e assim por diante. Anúncios ocasionais de eventos importantes (como festas, casamentos, nascimentos, novos empregos, etc) podem ser feitos para as listas técnicas, mas os acompanhamentos devem ser direcionados para esta lista de bate-papo.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-chromium>freebsd-chromium</a></dt><dd><p><em>Questões específicas sobre o Chromium no FreeBSD</em></p><div class=paragraph><p>Esta é uma lista para a discussão do suporte ao Chromium no FreeBSD. Esta é uma lista técnica para discutir o desenvolvimento e a instalação do Chromium.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-cloud>freebsd-cloud</a></dt><dd><p><em>Executando o FreeBSD em várias plataformas de nuvem</em></p><div class=paragraph><p>Esta lista discute a execução do FreeBSD no Amazon EC2, no Google Compute Engine, no Microsoft Azure e em outras plataformas de computação em nuvem.</p></div></dd><dt class=hdlist1>freebsd-core</dt><dd><p><em>FreeBSD core team</em></p><div class=paragraph><p>Esta é uma lista de discussão interna para uso pelos membros do core team. Mensagens podem ser enviadas quando um assunto sério relacionado ao FreeBSD requer arbitragem ou escrutínio de alto nível.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-current>freebsd-current</a></dt><dd><p><em>Discussões sobre o uso do FreeBSD-CURRENT</em></p><div class=paragraph><p>Esta é a lista de discussão para usuários do FreeBSD-CURRENT. Ela inclui avisos sobre novos recursos que estão sendo lançados no -CURRENT que afetarão os usuários e instruções sobre as etapas que devem ser seguidas para permanecer no -CURRENT. Qualquer um que esteja executando o "CURRENT" deve se inscrever nesta lista. Esta é uma lista de discussão técnica para a qual é esperado conteúdo estritamente técnico.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-desktop>freebsd-desktop</a></dt><dd><p><em>Usando e melhorando o FreeBSD no desktop</em></p><div class=paragraph><p>Este é um fórum para discussão do FreeBSD no desktop. É principalmente um lugar para portadores de desktop e usuários discutirem problemas e melhorarem o suporte do FreeBSD para desktops.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/dev-ci>dev-ci</a></dt><dd><p><em>Coordenação do Relatório de Problemas sobre o esforço de manuseio</em></p><div class=paragraph><p>Todos os relatórios de integração contínua, resultados de compilação e testes</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/dev-reviews>dev-reviews</a></dt><dd><p><em>Notificações do trabalho em andamento na ferramenta de revisão do FreeBSD</em></p><div class=paragraph><p>Notificações automatizadas de trabalhos em andamento para revisão nas ferramentas de revisão do FreeBSD, incluindo patches.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-doc>freebsd-doc</a></dt><dd><p><em>Projeto de Documentação</em></p><div class=paragraph><p>Esta lista de discussão é para a discussão de questões e projetos relacionados à criação de documentação para o FreeBSD. Os membros desta lista são coletivamente referidos como "The FreeBSD Documentation Project". É uma lista aberta; sinta-se à vontade para participar e contribuir!</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-drivers>freebsd-drivers</a></dt><dd><p><em>Escrevendo drivers de dispositivos para o FreeBSD</em></p><div class=paragraph><p>Este é um fórum para discussões técnicas relacionadas a drivers de dispositivos no FreeBSD. É principalmente um lugar para os criadores de drivers de dispositivo fazerem perguntas sobre como escreverem drivers de dispositivo usando as APIs no kernel do FreeBSD.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-dtrace>freebsd-dtrace</a></dt><dd><p><em>Usando e trabalhando no DTrace no FreeBSD</em></p><div class=paragraph><p>O DTrace é um componente integrado do FreeBSD que fornece uma estrutura para entender o kernel, bem como programas de espaço do usuário em tempo de execução. A lista de discussão é uma discussão arquivada para desenvolvedores do código, bem como aqueles que a usam.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-eclipse>freebsd-eclipse</a></dt><dd><p><em>Usuários FreeBSD do IDE Eclipse, ferramentas, aplicativos e ports rich clients.</em></p><div class=paragraph><p>A intenção desta lista é fornecer suporte mútuo para tudo relacionado com a escolha, instalação, uso, desenvolvimento e manutenção do IDE Eclipse, ferramentas, aplicativos rich client na plataforma FreeBSD e para assistência na portabilidade do IDE Eclipse e seus plugins para o ambiente FreeBSD.</p></div><div class=paragraph><p>A intenção é também facilitar a troca de informações entre a comunidade Eclipse e a comunidade FreeBSD para benefício mútuo de ambas.</p></div><div class=paragraph><p>Embora essa lista esteja focada principalmente nas necessidades dos usuários do Eclipse, ela também fornecerá um fórum para aqueles que gostariam de desenvolver aplicativos específicos para o FreeBSD usando o Framework do Eclipse.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-embedded>freebsd-embedded</a></dt><dd><p><em>Usando o FreeBSD em aplicações embarcadas</em></p><div class=paragraph><p>Esta lista discute tópicos relacionados ao uso do FreeBSD em sistemas embarcados. Esta é uma lista de discussão técnica para a qual é esperado conteúdo estritamente técnico. Para o propósito desta lista, os sistemas embarcados são aqueles dispositivos de computação que não são desktops e que geralmente servem a um único propósito, ao invés de serem ambientes de computação geral. Os exemplos incluem, mas não estão limitados a, todos os tipos de aparelhos telefônicos, equipamentos de rede, como roteadores, switches e PBXs, equipamentos de medição remota, PDAs, sistemas Point Of Sale e assim por diante.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-emulation>freebsd-emulation</a></dt><dd><p><em>Emulação de outros sistemas como o Linux/MS-DOS™/Windows™</em></p><div class=paragraph><p>Este é um fórum para discussões técnicas relacionadas à execução no FreeBSD de programas escritos para outros sistemas operacionais.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-enlightenment>freebsd-enlightenment</a></dt><dd><p><em>Enlightenment</em></p><div class=paragraph><p>Discussões sobre o Ambiente de Desktop Enlightenment para sistemas FreeBSD. Esta é uma lista de discussão técnica para a qual é esperado conteúdo estritamente técnico.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-eol>freebsd-eol</a></dt><dd><p><em>Suporte de pares para softwares relacionados ao FreeBSD que não são mais suportados pelo Projeto FreeBSD.</em></p><div class=paragraph><p>Esta lista é para aqueles interessados em fornecer ou fazer uso de suporte de software relacionado ao FreeBSD para o qual o Projeto FreeBSD não fornece mais suporte oficial na forma de avisos e patches de segurança.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-firewire>freebsd-firewire</a></dt><dd><p><em>FireWire™ (iLink, IEEE 1394)</em></p><div class=paragraph><p>Esta é uma lista para discussão do design e implementação de um subsistema FireWire™ (também conhecido como IEEE 1394 aka iLink) para o FreeBSD. Tópicos relevantes incluem especificamente os padrões, dispositivos de barramento e seus protocolos, placas adaptadoras / placas / chips sets e a arquitetura e implementação de código para seu suporte adequado.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-fortran>freebsd-fortran</a></dt><dd><p><em>Fortran no FreeBSD</em></p><div class=paragraph><p>Esta é a lista para discussão de ports relacionados ao Fortran no FreeBSD: compiladores, bibliotecas, aplicativos científicos e de engenharia, de laptops a clusters de HPC.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-fs>freebsd-fs</a></dt><dd><p><em>Sistemas de arquivos</em></p><div class=paragraph><p>Discussões sobre os sistemas de arquivos do FreeBSD. Esta é uma lista de discussão técnica para a qual é esperado conteúdo estritamente técnico.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-games>freebsd-games</a></dt><dd><p><em>Jogos no FreeBSD</em></p><div class=paragraph><p>Esta é uma lista técnica para discussões relacionadas a trazer jogos para o FreeBSD. É para indivíduos trabalhando ativamente em portar jogos para o FreeBSD, para trazer problemas ou discutir soluções alternativas. Indivíduos interessados em acompanhar a discussão técnica também são bem vindos.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-gecko>freebsd-gecko</a></dt><dd><p><em>Motor Gecko de Renderização</em></p><div class=paragraph><p>Este é um fórum sobre aplicativos Gecko usando o FreeBSD.</p></div><div class=paragraph><p>Discussão em torno dos Ports dos aplicativos Gecko, sua instalação, seu desenvolvimento e seu suporte dentro do FreeBSD.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-geom>freebsd-geom</a></dt><dd><p><em>GEOM</em></p><div class=paragraph><p>Discussões específicas sobre o GEOM e implementações relacionadas. Esta é uma lista de discussão técnica para a qual é esperado conteúdo estritamente técnico.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-git>freebsd-git</a></dt><dd><p><em>Uso do git no projeto FreeBSD</em></p><div class=paragraph><p>Discussões sobre como usar o git na infra-estrutura do FreeBSD, incluindo o espelho do github e outros usos do git para colaboração no projeto. Área de discussão para pessoas usando o git no espelho do FreeBSD no github. Pessoas que querem começar com o espelho ou o git em geral no FreeBSD podem fazer perguntas aqui.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-gnome>freebsd-gnome</a></dt><dd><p><em>GNOME</em></p><div class=paragraph><p>Discussões relativas ao ambiente de trabalho GNOME para sistemas FreeBSD. Esta é uma lista de discussão técnica para a qual é esperado conteúdo estritamente técnico.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-infiniband>freebsd-infiniband</a></dt><dd><p><em>Infiniband no FreeBSD</em></p><div class=paragraph><p>Lista técnica para discutir Infiniband, OFED e OpenSM no FreeBSD.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-ipfw>freebsd-ipfw</a></dt><dd><p><em>Firewall IP</em></p><div class=paragraph><p>Este é o fórum para discussões técnicas sobre o redesenho do código de firewall IP no FreeBSD. Esta é uma lista de discussão técnica para a qual é esperado conteúdo estritamente técnico.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-isdn>freebsd-isdn</a></dt><dd><p><em>Comunicações ISDN</em></p><div class=paragraph><p>Esta é a lista de discussão para pessoas discutindo o desenvolvimento do suporte a ISDN para o FreeBSD.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-java>freebsd-java</a></dt><dd><p><em>Desenvolvimento Java™</em></p><div class=paragraph><p>Esta é a lista de discussão para as pessoas que discutem o desenvolvimento de aplicações Java™ para o FreeBSD e a portabilidade e manutenção de JDK™s.</p></div></dd></dl></div><div id=eresources-charters-jobs class=dlist><dl><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-jobs>freebsd-jobs</a></dt><dd><p><em>Ofertas e Procura de Emprego</em></p><div class=paragraph><p>Este é um fórum para postar avisos de emprego especificamente relacionados ao FreeBSD e currículos daqueles que buscam emprego relacionado ao FreeBSD. Esta <em>não</em> é uma lista de discussão para questões gerais de emprego, já que fóruns adequados para isso já existem em outros lugares.</p></div><div class=paragraph><p>Note que esta lista, como as demais listas de discussão do <code>FreeBSD.org</code>, é distribuída em todo o mundo. Seja claro sobre a localização geográfica e até que ponto o trabalho remoto ou a assistência à realocação estão disponíveis.</p></div><div class=paragraph><p>O email deve usar somente formatos abertos - preferencialmente texto puro, mas o formato básico de documento portátil (PDF), HTML e alguns outros são aceitáveis para muitos leitores. Formatos fechados como Microsoft™ Word (<span class=filename>.doc</span>) serão rejeitados pelo servidor da lista de discussão.</p></div></dd><dt class=hdlist1><a href=https://mail.kde.org/mailman/listinfo/kde-freebsd>freebsd-kde</a></dt><dd><p><em>KDE</em></p><div class=paragraph><p>Discussões sobre o KDE em sistemas FreeBSD. Esta é uma lista de discussão técnica para a qual é esperado conteúdo estritamente técnico.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-hackers>freebsd-hackers</a></dt><dd><p><em>Discussões técnicas</em></p><div class=paragraph><p>Este é um fórum para discussões técnicas relacionadas ao FreeBSD. Esta é a principal lista de discussão técnica. É para indivíduos trabalhando ativamente no FreeBSD, para trazer problemas ou discutir soluções alternativas. Indivíduos interessados em acompanhar a discussão técnica também são bem vindos. Esta é uma lista de discussão técnica para a qual é esperado conteúdo estritamente técnico.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-hardware>freebsd-hardware</a></dt><dd><p><em>Discussão geral sobre hardware no FreeBSD</em></p><div class=paragraph><p>Discussão geral sobre os tipos de hardware em que o FreeBSD executa, vários problemas e sugestões sobre o que comprar ou evitar.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-hubs>freebsd-hubs</a></dt><dd><p><em>Sites Espelhos</em></p><div class=paragraph><p>Anúncios e discussões para pessoas que executam sites espelho do FreeBSD.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-isp>freebsd-isp</a></dt><dd><p><em>Problemas para provedores de serviços de Internet</em></p><div class=paragraph><p>Esta lista de discussão é para discutir tópicos relevantes para provedores de serviços de Internet (ISPs) usando o FreeBSD. Esta é uma lista de discussão técnica para a qual é esperado conteúdo estritamente técnico.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-mono>freebsd-mono</a></dt><dd><p><em>Aplicações Mono e C# no FreeBSD</em></p><div class=paragraph><p>Esta é uma lista de discussões relacionadas ao framework de desenvolvimento Mono no FreeBSD. Esta é uma lista de discussão técnica. É para indivíduos trabalhando ativamente na portabilidade de aplicativos Mono ou C# para o FreeBSD, para trazer problemas ou discutir soluções alternativas. Indivíduos interessados em acompanhar a discussão técnica também são bem vindos.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-ocaml>freebsd-ocaml</a></dt><dd><p><em>Discussões específicas sobre OCaml no FreeBSD</em></p><div class=paragraph><p>Esta é uma lista para discussões relacionadas ao suporte OCaml no FreeBSD. Esta é uma lista de discussão técnica. É para pessoas que trabalham com ports OCaml, bibliotecas de terceiros e frameworks. Indivíduos interessados na discussão técnica também são bem vindos.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-office>freebsd-office</a></dt><dd><p><em>Aplicativos de Escritório no FreeBSD</em></p><div class=paragraph><p>Discussão em torno de aplicativos de escritório, sua instalação, seu desenvolvimento e seu suporte dentro do FreeBSD.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-ops-announce>freebsd-ops-announce</a></dt><dd><p><em>Anúncios de infra-estrutura do projeto</em></p><div class=paragraph><p>Esta é a lista de discussão para pessoas interessadas em mudanças e questões relacionadas à infra-estrutura do Projeto FreeBSD.org.</p></div><div class=paragraph><p>Esta lista moderada é estritamente para anúncios: sem respostas, pedidos, discussões ou opiniões.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-performance>freebsd-performance</a></dt><dd><p><em>Discussões sobre o tunning ou aceleração do FreeBSD</em></p><div class=paragraph><p>Esta lista de discussão existe para fornecer um local para hackers, administradores e/ou partes interessadas discutirem tópicos relacionados ao desempenho do FreeBSD. Temas aceitáveis incluem falar sobre instalações do FreeBSD que estão sob alta carga, que estão tendo problemas de desempenho ou que estão forçando os limites do FreeBSD. Partes interessadas que estejam dispostas a trabalhar para melhorar o desempenho do FreeBSD são altamente encorajadas a assinar esta lista. Esta é uma lista altamente técnica destinada para usuários experientes do FreeBSD, hackers ou administradores interessados em manter o FreeBSD rápido, robusto e escalável. Essa lista não é uma lista de perguntas e respostas que substitui a leitura da documentação, mas é um local para fazer contribuições ou perguntar sobre tópicos não respondidos relacionados ao desempenho.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-pf>freebsd-pf</a></dt><dd><p><em>Discussão sobre o sistema de firewall de filtro de pacotes</em></p><div class=paragraph><p>Discussão sobre o sistema de firewall de filtro de pacotes (pf) no FreeBSD. A discussão técnica e as perguntas dos usuários são bem-vindas. Esta lista também é um lugar para discutir o framework ALTQ QoS.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-pkg>freebsd-pkg</a></dt><dd><p><em>Discussão sobre o gerenciamento de pacotes binários e as ferramentas de pacotes</em></p><div class=paragraph><p>Discussão de todos os aspectos de gerenciamento de sistemas FreeBSD usando pacotes binários para instalar software, incluindo toolkits e formatos de pacotes binários, seu desenvolvimento e suporte dentro do FreeBSD, gerenciamento de repositórios de pacotes e pacotes de terceiros.</p></div><div class=paragraph><p>Observe que a discussão de ports que não conseguem gerar pacotes corretamente geralmente deve ser considerada como um problema do port e, portanto, é inadequada para essa lista.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-pkg-fallout>freebsd-pkg-fallout</a></dt><dd><p><em>Registros de fallout da construção de pacotes</em></p><div class=paragraph><p>Todos os logs de falha na compilação de pacotes nos clusters de compilação de pacotes</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-pkgbase>freebsd-pkgbase</a></dt><dd><p><em>Empacotando do sistema básico do FreeBSD.</em></p><div class=paragraph><p>Discussões sobre a implementação e questões relacionadas ao empacotamento do sistema base do FreeBSD.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-platforms>freebsd-platforms</a></dt><dd><p><em>Portando para plataformas não Intel™</em></p><div class=paragraph><p>Problemas de plataforma cruzada do FreeBSD, discussão geral e propostas para ports do FreeBSD para plataformas não Intel™. Esta é uma lista de discussão técnica para a qual é esperado conteúdo estritamente técnico.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-ports>freebsd-ports</a></dt><dd><p><em>Discussão dos "ports"</em></p><div class=paragraph><p>Discussões relativas à coleção de "ports" (<span class=filename>/usr/ports</span>) do FreeBSD, infra-estrutura de ports e esforços gerais de coordenação de ports. Esta é uma lista de discussão técnica para a qual é esperado conteúdo estritamente técnico.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-ports-announce>freebsd-ports-announce</a></dt><dd><p><em>Notícias e instruções importantes sobre a "Coleção de Ports" do FreeBSD</em></p><div class=paragraph><p>Notícias importantes para desenvolvedores, porters e usuários da "Coleção de Ports" (<span class=filename>/usr/ports</span>), incluindo alterações de arquitetura / infraestrutura, novos recursos, instruções críticas de upgrade e informações sobre a engenharia de releases. Esta é uma lista de discussão de baixo volume, destinada a anúncios.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-ports-bugs>freebsd-ports-bugs</a></dt><dd><p><em>Discussão de bugs dos "ports"</em></p><div class=paragraph><p>Discussões sobre relatórios de problemas para a "coleção de ports" do FreeBSD (<span class=filename>/usr/ports</span>), ports propostos ou modificações nos ports. Esta é uma lista de discussão técnica para a qual é esperado conteúdo estritamente técnico.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-proliant>freebsd-proliant</a></dt><dd><p><em>Discussão técnica do FreeBSD nas plataformas de servidores HP ProLiant</em></p><div class=paragraph><p>Esta lista de discussão deve ser usada para a discussão técnica do uso do FreeBSD em servidores HP ProLiant, incluindo a discussão de drivers específicos do ProLiant, software de gerenciamento, ferramentas de configuração e atualizações do BIOS. Como tal, este é o principal local para discutir os módulos hpasmd, hpasmcli e hpacucli.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-python>freebsd-python</a></dt><dd><p><em>Python no FreeBSD</em></p><div class=paragraph><p>Esta é uma lista de discussões relacionadas à melhoria do suporte ao Python no FreeBSD. Esta é uma lista de discussão técnica. É para indivíduos que estão trabalhando na portabilidade do Python, seus módulos de terceiros e coisas do Zope para o FreeBSD. Indivíduos interessados em acompanhar a discussão técnica também são bem vindos.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-questions>freebsd-questions</a></dt><dd><p><em>Questões do usuário</em></p><div class=paragraph><p>Esta é a lista de discussão para questões sobre o FreeBSD. Não envie perguntas do tipo "how to" para as listas técnicas, a menos que a questão seja bastante técnica.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-ruby>freebsd-ruby</a></dt><dd><p><em>Discussões sobre Ruby específicas para o FreeBSD</em></p><div class=paragraph><p>Esta é uma lista para discussões relacionadas ao suporte Ruby no FreeBSD. Esta é uma lista de discussão técnica. É para pessoas que trabalham com ports Ruby, bibliotecas de terceiros e frameworks.</p></div><div class=paragraph><p>Indivíduos interessados na discussão técnica também são bem vindos.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-scsi>freebsd-scsi</a></dt><dd><p><em>Subsistema SCSI</em></p><div class=paragraph><p>Esta é a lista de discussão para pessoas que trabalham no subsistema SCSI do FreeBSD. Esta é uma lista de discussão técnica para a qual é esperado conteúdo estritamente técnico.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-security>freebsd-security</a></dt><dd><p><em>Questões de segurança</em></p><div class=paragraph><p>Problemas de segurança do FreeBSD (DES, Kerberos, falhas de segurança conhecidas e correções, etc). Esta é uma lista de discussão técnica para a qual se espera uma discussão estritamente técnica. Note que esta não é uma lista de perguntas e respostas, mas as contribuições (ambas as perguntas e respostas) para o FAQ são bem-vindas.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-security-notifications>freebsd-security-notifications</a></dt><dd><p><em>Notificações de segurança</em></p><div class=paragraph><p>Notificações de problemas de segurança e correções do FreeBSD. Esta não é uma lista de discussão. A lista de discussão é a FreeBSD-security.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-snapshots>freebsd-snapshots</a></dt><dd><p><em>Anúncios de Snapshots de Desenvolvimento do FreeBSD</em></p><div class=paragraph><p>Esta lista fornece notificações sobre a disponibilidade de novos snapshots de desenvolvimento do FreeBSD para head/ e stable/ branches.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-stable>freebsd-stable</a></dt><dd><p><em>Discussões sobre o uso do FreeBSD-STABLE</em></p><div class=paragraph><p>Esta é a lista de discussão para usuários do FreeBSD-STABLE. O "STABLE" é o ramo onde o desenvolvimento continua depois de um RELEASE, incluindo correções de bugs e novos recursos. O ABI é mantido estável para compatibilidade binária. Ela inclui avisos sobre novos recursos que estarão sendo incorporados no -STABLE e que afetarão os usuários e instruções sobre as etapas que devem ser seguidas para permanecer -STABLE. Qualquer um que esteja executando o "STABLE" deve assinar esta lista. Esta é uma lista de discussão técnica para a qual é esperado conteúdo estritamente técnico.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-standards>freebsd-standards</a></dt><dd><p><em>Conformidade C99 & POSIX</em></p><div class=paragraph><p>Este é um fórum para discussões técnicas relacionadas à Conformidade do FreeBSD com os padrões C99 e POSIX.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-teaching>freebsd-teaching</a></dt><dd><p><em>Ensinando com o FreeBSD</em></p><div class=paragraph><p>Lista de discussão não técnica para discutir o ensino com o FreeBSD.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-testing>freebsd-testing</a></dt><dd><p><em>Testando no FreeBSD</em></p><div class=paragraph><p>Lista de discussão técnica discutindo testes no FreeBSD, incluindo ATF/Kyua, infraestrutura de testes, testes de port para o FreeBSD de outros sistemas operacionais (NetBSD, …​), etc.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-tex>freebsd-tex</a></dt><dd><p><em>Portando o TeX e seus aplicativos para o FreeBSD</em></p><div class=paragraph><p>Esta é uma lista de discussão técnica para discussões relacionadas ao TeX e suas aplicações no FreeBSD. É destinada aos indivíduos que estão trabalhando ativamente na portabilidade do TeX para o FreeBSD, para trazer problemas ou discutir soluções alternativas. Indivíduos interessados em acompanhar a discussão técnica também são bem vindos.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-toolchain>freebsd-toolchain</a></dt><dd><p><em>Manutenção do toolchain integrado do FreeBSD</em></p><div class=paragraph><p>Esta é a lista para discussões relacionadas à manutenção do conjunto de ferramentas fornecido com o FreeBSD. Isso pode incluir o estado do Clang e do GCC, mas também partes de software, como assemblers, vinculadores e depuradores.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-transport>freebsd-transport</a></dt><dd><p><em>Discussões de protocolos de rede em nível de transporte no FreeBSD</em></p><div class=paragraph><p>A lista de discussão de transporte existe para a discussão de problemas e projetos em torno dos protocolos de nível de transporte na pilha de rede do FreeBSD, incluindo TCP, SCTP e UDP. Outros tópicos de rede, incluindo questões específicas de driver e protocolos de rede, devem ser discutidos na <a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-net>lista de discussão FreeBSD networking</a> .</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-translators>freebsd-translators</a></dt><dd><p><em>Traduzindo documentos e programas do FreeBSD</em></p><div class=paragraph><p>Uma lista de discussão em que tradutores de documentos do FreeBSD do inglês para outros idiomas podem falar sobre métodos e ferramentas de tradução. Novos membros são convidados a se apresentar e mencionar os idiomas em que estão interessados em traduzir.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-usb>freebsd-usb</a></dt><dd><p><em>Discutindo o suporte do FreeBSD para USB</em></p><div class=paragraph><p>Esta é uma lista de discussão para discussões técnicas relacionadas ao suporte do FreeBSD para USB.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-user-groups>freebsd-user-groups</a></dt><dd><p><em>Lista de Coordenação do Grupo de Usuários</em></p><div class=paragraph><p>Esta é a lista de discussão dos coordenadores de cada um dos Grupos de Usuários da área local para discutir assuntos entre si e um indivíduo designado do Core Team. Essa lista de e-mail deve se limitar a atender a sinopse e a coordenação de projetos que abranjam Grupos de usuários.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-virtualization>freebsd-virtualization</a></dt><dd><p><em>Discussão de várias técnicas de virtualização suportadas pelo FreeBSD</em></p><div class=paragraph><p>Uma lista para discutir as várias técnicas de virtualização suportadas pelo FreeBSD. Por um lado, o foco estará na implementação da funcionalidade básica, bem como na adição de novos recursos. Por outro lado, os usuários terão um fórum para pedir ajuda em caso de problemas ou para discutir seus casos de uso.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-wip-status>freebsd-wip-status</a></dt><dd><p><em>Status do andamento do trabalho no FreeBSD</em></p><div class=paragraph><p>Esta lista de discussão pode ser usada pelos desenvolvedores para anunciar a criação e o progresso do trabalho relacionado ao FreeBSD. As mensagens serão moderadas. Sugere-se enviar a mensagem "Para:" uma lista mais atual do FreeBSD e apenas "BCC:" esta lista. Dessa forma, o WIP também pode ser discutido na lista de tópicos, já que nenhuma discussão é permitida nesta lista.</p></div><div class=paragraph><p>Olhe dentro dos arquivos para exemplos de mensagens adequadas.</p></div><div class=paragraph><p>Um resumo editorial das mensagens para esta lista pode ser postado no site do FreeBSD todos os meses como parte dos Relatórios de Status . Relatórios anteriores são arquivados.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-wireless>freebsd-wireless</a></dt><dd><p><em>Discussões da pilha 802.11, desenvolvimento de driver de dispositivo de ferramentas</em></p><div class=paragraph><p>A lista FreeBSD-wireless se concentra na pilha 802.11 (sys/net80211), no driver do dispositivo e no desenvolvimento de ferramentas. Isso inclui bugs, novos recursos e manutenção.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-xen>freebsd-xen</a></dt><dd><p><em>Discussão do port do FreeBSD para Xen ™ - implementação e uso</em></p><div class=paragraph><p>Uma lista focada no port do Xen™ para o FreeBSD. O nível de tráfego previsto é pequeno o suficiente para servir como um fórum para discussões técnicas sobre os detalhes de implementação e design, bem como problemas administrativos de implantação.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-xfce>freebsd-xfce</a></dt><dd><p><em>XFCE</em></p><div class=paragraph><p>Este é um fórum para discussões relacionadas a trazer o ambiente XFCE para o FreeBSD. Esta é uma lista de discussão técnica. É para indivíduos que trabalham ativamente portando o XFCE para o FreeBSD, para trazer problemas ou discutir soluções alternativas. Indivíduos interessados em acompanhar a discussão técnica também são bem vindos.</p></div></dd><dt class=hdlist1><a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-zope>freebsd-zope</a></dt><dd><p><em>Zope</em></p><div class=paragraph><p>Este é um fórum para discussões relacionadas a trazer o ambiente Zope para o FreeBSD. Esta é uma lista de discussão técnica. É para indivíduos que trabalham ativamente portando o Zope para o FreeBSD, para trazer problemas ou discutir soluções alternativas. Indivíduos interessados em acompanhar a discussão técnica também são bem vindos.</p></div></dd></dl></div></div><div class=sect3><h4 id=eresources-mailfiltering>C.2.4. Filtros nas Listas de Discussão<a class=anchor href=#eresources-mailfiltering></a></h4><div class=paragraph><p>As listas de discussão do FreeBSD são filtradas de várias maneiras para evitar a distribuição de spam, vírus e outros e-mails indesejados. As ações de filtragem descritas nesta seção não incluem todas aquelas usadas para proteger as listas de discussão.</p></div><div class=paragraph><p>Apenas determinados tipos de anexos são permitidos nas listas de discussão. Todos os anexos com um tipo de conteúdo MIME não encontrado na lista abaixo serão removidos antes que um email seja distribuído nas listas de discussão.</p></div><div class=ulist><ul><li><p>application/octet-stream</p></li><li><p>application/pdf</p></li><li><p>application/pgp-signature</p></li><li><p>application/x-pkcs7-signature</p></li><li><p>message/rfc822</p></li><li><p>multipart/alternative</p></li><li><p>multipart/related</p></li><li><p>multipart/signed</p></li><li><p>text/html</p></li><li><p>text/plain</p></li><li><p>text/x-diff</p></li><li><p>text/x-patch</p></li></ul></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Algumas das listas de discussão podem permitir anexos de outros tipos de conteúdo MIME, mas a lista acima deve ser aplicável para a maioria das listas de discussão.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Se um email contiver uma versão em HTML e uma em texto simples, a versão em HTML será removida. Se um email contiver somente uma versão em HTML, ele será convertido em texto simples.</p></div></div></div><div class=sect2><h3 id=eresources-news>C.3. Grupos de Notícias Usenet<a class=anchor href=#eresources-news></a></h3><div class=paragraph><p>Além de dois grupos de noticias específicos sobre FreeBSD, existem muitos outros em que o FreeBSD é discutido ou que são relevantes para usuários do FreeBSD.</p></div><div class=sect3><h4 id=_grupos_de_notícias_específicos_do_bsd>C.3.1. Grupos de notícias específicos do BSD<a class=anchor href=#_grupos_de_notícias_específicos_do_bsd></a></h4><div class=ulist><ul><li><p><a href=news:comp.unix.bsd.freebsd.announce>comp.unix.bsd.freebsd.announce</a></p></li><li><p><a href=news:comp.unix.bsd.freebsd.misc>comp.unix.bsd.freebsd.misc</a></p></li><li><p><a href=news:de.comp.os.unix.bsd>de.comp.os.unix.bsd</a> (German)</p></li><li><p><a href=news:fr.comp.os.bsd>fr.comp.os.bsd</a> (French)</p></li></ul></div></div><div class=sect3><h4 id=_outros_newsgroups_de_interesse_sobre_unix>C.3.2. Outros Newsgroups de interesse sobre UNIX™<a class=anchor href=#_outros_newsgroups_de_interesse_sobre_unix></a></h4><div class=ulist><ul><li><p><a href=news:comp.unix>comp.unix</a></p></li><li><p><a href=news:comp.unix.questions>comp.unix.questions</a></p></li><li><p><a href=news:comp.unix.admin>comp.unix.admin</a></p></li><li><p><a href=news:comp.unix.programmer>comp.unix.programmer</a></p></li><li><p><a href=news:comp.unix.shell>comp.unix.shell</a></p></li><li><p><a href=news:comp.unix.misc>comp.unix.misc</a></p></li><li><p><a href=news:comp.unix.bsd>comp.unix.bsd</a></p></li></ul></div></div><div class=sect3><h4 id=_x_window_system>C.3.3. X Window System<a class=anchor href=#_x_window_system></a></h4><div class=ulist><ul><li><p><a href=news:comp.windows.x>comp.windows.x</a></p></li></ul></div></div></div><div class=sect2><h3 id=eresources-web>C.4. Espelhos Oficiais<a class=anchor href=#eresources-web></a></h3><div class=paragraph><p><a href=#central-mirrors>Central Servers</a>, <a href=#armenia-mirrors>Armenia</a>, <a href=#australia-mirrors>Australia</a>, <a href=#austria-mirrors>Austria</a>, <a href=#czech-republic-mirrors>Czech Republic</a>, <a href=#denmark-mirrors>Denmark</a>, <a href=#finland-mirrors>Finland</a>, <a href=#france-mirrors>France</a>, <a href=#germany-mirrors>Germany</a>, <a href=#hong-kong-mirrors>Hong Kong</a>, <a href=#ireland-mirrors>Ireland</a>, <a href=#japan-mirrors>Japan</a>, <a href=#latvia-mirrors>Latvia</a>, <a href=#lithuania-mirrors>Lithuania</a>, <a href=#netherlands-mirrors>Netherlands</a>, <a href=#norway-mirrors>Norway</a>, <a href=#russia-mirrors>Russia</a>, <a href=#slovenia-mirrors>Slovenia</a>, <a href=#south-africa-mirrors>South Africa</a>, <a href=#spain-mirrors>Spain</a>, <a href=#sweden-mirrors>Sweden</a>, <a href=#switzerland-mirrors>Switzerland</a>, <a href=#taiwan-mirrors>Taiwan</a>, <a href=#uk-mirrors>United Kingdom</a>, <a href=#usa-mirrors>United States of America</a>.</p></div><div class=paragraph><p>(as of UTC)</p></div><div id=central-mirrors class=paragraph><p><strong>Central Servers</strong></p></div><div class=ulist><ul><li><p><a href=https://www.FreeBSD.org/ class=bare>https://www.FreeBSD.org/</a></p></li></ul></div><div id=armenia-mirrors class=paragraph><p><strong>Armenia</strong></p></div><div class=ulist><ul><li><p><a href=http://www.at.FreeBSD.org/ class=bare>http://www.at.FreeBSD.org/</a> (IPv6)</p></li></ul></div><div id=australia-mirrors class=paragraph><p><strong>Australia</strong></p></div><div class=ulist><ul><li><p><a href=http://www.au.FreeBSD.org/ class=bare>http://www.au.FreeBSD.org/</a></p></li><li><p><a href=http://www2.au.FreeBSD.org/ class=bare>http://www2.au.FreeBSD.org/</a></p></li></ul></div><div id=austria-mirrors class=paragraph><p><strong>Austria</strong></p></div><div class=ulist><ul><li><p><a href=http://www.at.FreeBSD.org/ class=bare>http://www.at.FreeBSD.org/</a> (IPv6)</p></li></ul></div><div id=czech-republic-mirrors class=paragraph><p><strong>Czech Republic</strong></p></div><div class=ulist><ul><li><p><a href=http://www.cz.FreeBSD.org/ class=bare>http://www.cz.FreeBSD.org/</a> (IPv6)</p></li></ul></div><div id=denmark-mirrors class=paragraph><p><strong>Denmark</strong></p></div><div class=ulist><ul><li><p><a href=http://www.dk.FreeBSD.org/ class=bare>http://www.dk.FreeBSD.org/</a> (IPv6)</p></li></ul></div><div id=finland-mirrors class=paragraph><p><strong>Finland</strong></p></div><div class=ulist><ul><li><p><a href=http://www.fi.FreeBSD.org/ class=bare>http://www.fi.FreeBSD.org/</a></p></li></ul></div><div id=france-mirrors class=paragraph><p><strong>France</strong></p></div><div class=ulist><ul><li><p><a href=http://www1.fr.FreeBSD.org/ class=bare>http://www1.fr.FreeBSD.org/</a></p></li></ul></div><div id=germany-mirrors class=paragraph><p><strong>Germany</strong></p></div><div class=ulist><ul><li><p><a href=http://www.de.FreeBSD.org/ class=bare>http://www.de.FreeBSD.org/</a></p></li></ul></div><div id=hong-kong-mirrors class=paragraph><p><strong>Hong Kong</strong></p></div><div class=ulist><ul><li><p><a href=http://www.hk.FreeBSD.org/ class=bare>http://www.hk.FreeBSD.org/</a></p></li></ul></div><div id=ireland-mirrors class=paragraph><p><strong>Ireland</strong></p></div><div class=ulist><ul><li><p><a href=http://www.ie.FreeBSD.org/ class=bare>http://www.ie.FreeBSD.org/</a></p></li></ul></div><div id=japan-mirrors class=paragraph><p><strong>Japan</strong></p></div><div class=ulist><ul><li><p><a href=http://www.jp.FreeBSD.org/www.FreeBSD.org/ class=bare>http://www.jp.FreeBSD.org/www.FreeBSD.org/</a> (IPv6)</p></li></ul></div><div id=latvia-mirrors class=paragraph><p><strong>Latvia</strong></p></div><div class=ulist><ul><li><p><a href=http://www.lv.FreeBSD.org/ class=bare>http://www.lv.FreeBSD.org/</a></p></li></ul></div><div id=lithuania-mirrors class=paragraph><p><strong>Lithuania</strong></p></div><div class=ulist><ul><li><p><a href=http://www.lt.FreeBSD.org/ class=bare>http://www.lt.FreeBSD.org/</a></p></li></ul></div><div id=netherlands-mirrors class=paragraph><p><strong>Netherlands</strong></p></div><div class=ulist><ul><li><p><a href=http://www.nl.FreeBSD.org/ class=bare>http://www.nl.FreeBSD.org/</a></p></li></ul></div><div id=norway-mirrors class=paragraph><p><strong>Norway</strong></p></div><div class=ulist><ul><li><p><a href=http://www.no.FreeBSD.org/ class=bare>http://www.no.FreeBSD.org/</a></p></li></ul></div><div id=russia-mirrors class=paragraph><p><strong>Russia</strong></p></div><div class=ulist><ul><li><p><a href=http://www.ru.FreeBSD.org/ class=bare>http://www.ru.FreeBSD.org/</a> (IPv6)</p></li></ul></div><div id=slovenia-mirrors class=paragraph><p><strong>Slovenia</strong></p></div><div class=ulist><ul><li><p><a href=http://www.si.FreeBSD.org/ class=bare>http://www.si.FreeBSD.org/</a></p></li></ul></div><div id=south-africa-mirrors class=paragraph><p><strong>South Africa</strong></p></div><div class=ulist><ul><li><p><a href=http://www.za.FreeBSD.org/ class=bare>http://www.za.FreeBSD.org/</a></p></li></ul></div><div id=spain-mirrors class=paragraph><p><strong>Spain</strong></p></div><div class=ulist><ul><li><p><a href=http://www.es.FreeBSD.org/ class=bare>http://www.es.FreeBSD.org/</a></p></li><li><p><a href=http://www2.es.FreeBSD.org/ class=bare>http://www2.es.FreeBSD.org/</a></p></li></ul></div><div id=sweden-mirrors class=paragraph><p><strong>Sweden</strong></p></div><div class=ulist><ul><li><p><a href=http://www.se.FreeBSD.org/ class=bare>http://www.se.FreeBSD.org/</a></p></li></ul></div><div id=switzerland-mirrors class=paragraph><p><strong>Switzerland</strong></p></div><div class=ulist><ul><li><p><a href=http://www.ch.FreeBSD.org/ class=bare>http://www.ch.FreeBSD.org/</a> (IPv6)</p></li><li><p><a href=http://www2.ch.FreeBSD.org/ class=bare>http://www2.ch.FreeBSD.org/</a> (IPv6)</p></li></ul></div><div id=taiwan-mirrors class=paragraph><p><strong>Taiwan</strong></p></div><div class=ulist><ul><li><p><a href=http://www.tw.FreeBSD.org/ class=bare>http://www.tw.FreeBSD.org/</a></p></li><li><p><a href=http://www2.tw.FreeBSD.org/ class=bare>http://www2.tw.FreeBSD.org/</a></p></li><li><p><a href=http://www4.tw.FreeBSD.org/ class=bare>http://www4.tw.FreeBSD.org/</a></p></li><li><p><a href=http://www5.tw.FreeBSD.org/ class=bare>http://www5.tw.FreeBSD.org/</a> (IPv6)</p></li></ul></div><div id=uk-mirrors class=paragraph><p><strong>United Kingdom</strong></p></div><div class=ulist><ul><li><p><a href=http://www1.uk.FreeBSD.org class=bare>http://www1.uk.FreeBSD.org</a></p></li><li><p><a href=http://www3.uk.FreeBSD.org/ class=bare>http://www3.uk.FreeBSD.org/</a></p></li></ul></div><div id=usa-mirrors class=paragraph><p><strong>United States of America</strong></p></div><div class=ulist><ul><li><p><a href=http://www5.us.FreeBSD.org/ class=bare>http://www5.us.FreeBSD.org/</a> (IPv6)</p></li></ul></div></div></div></div><div class=sect1><h2 id=pgpkeys>Apêndice D: Chaves OpenPGP<a class=anchor href=#pgpkeys></a></h2><div class=sectionbody><div class=paragraph><p>As chaves OpenPGP dos Administradores do <code>FreeBSD.org</code> são mostradas aqui. Essas chaves podem ser usadas para verificar uma assinatura ou para enviar um email criptografado para um dos administradores. A lista completa das chaves OpenPGP do FreeBSD está disponível no artigo <a href=https://docs.freebsd.org/pt-br/articles/pgpkeys/>PGP Keys</a>. O keyring completo pode ser baixado em <a href=https://www.FreeBSD.org/doc/pgpkeyring.txt>https://www.FreeBSD.org/doc/pgpkeyring.txt</a> .</p></div><div class=sect2><h3 id=pgpkeys-officers>D.1. Administradores<a class=anchor href=#pgpkeys-officers></a></h3><div class=sect3><h4 id=_equipe_de_oficiais_de_segurança_security_officerfreebsd_org>D.1.1. Equipe de Oficiais de Segurança <code>&lt;<a href=mailto:security-officer@FreeBSD.org>security-officer@FreeBSD.org</a>></code><a class=anchor href=#_equipe_de_oficiais_de_segurança_security_officerfreebsd_org></a></h4><div class="literalblock literal-block-margin"><div class=content><pre>pub   rsa4096/D9AD2A18057474CB 2022-12-11 [C] [expires: 2026-01-24]
      Key fingerprint = 0BE3 3275 D74C 953C 79F8  1107 D9AD 2A18 0574 74CB
uid                            FreeBSD Security Officer &lt;security-officer@freebsd.org&gt;
sub   rsa4096/6E58DE901F001AEF 2022-12-11 [S] [expires: 2025-01-15]
sub   rsa4096/46DB26D62F6039B7 2022-12-11 [E] [expires: 2025-01-15]</pre></div></div><div class="literalblock literal-block-margin"><div class=content><pre>-----BEGIN PGP PUBLIC KEY BLOCK-----

mQINBGOVdeUBEADHF5VGg1iPbACB+7lomX6aDytUf0k2k2Yc/Kp6lfYv7JKU+1nr
TcNF7Gt1YkajPSeWRKNZw/X94g4w5TEOHbJ6QQWx9g+N7RjEq75actQ/r2N5zY4S
ujfFTepbvgR55mLTxlxGKFBmNrfNbpHRyh4GwFRgPlxf5Jy9SB+0m54yFS4QlSd0
pIzO0CLkjHUFy/8S93oSK2zUkgok5gLWruBXom+8VC3OtBElkWswPkE1pKZvMQCv
VyM+7BS+MCFXSdZczDZZoEzpQJGhUYFsdg0KqlLv6z1rP+HsgUYKTkRpcrumDQV0
MMuCE4ECU6nFDDTnbR8Wn3LF5oTt0GtwS0nWf+nZ1SFTDURcSPR4Lp/PKjuDAkOS
P8BaruCNx1ItHSwcnXw0gS4+h8FjtWNZpsawtzjjgApcl+m9KP6dkBcbN+i1DHm6
NG6YQVtVWyN8aOKmoC/FEm1CWh1bv+ri9XOkF2EqT/ktbjbT1hFoFGBkS9/35y1G
3KKyWtwKcyF4OXcArl6sQwGgiYnZEG3sUMaGrwQovRtMf7le3cAYsMkXyiAnEufa
deuabYLD8qp9L/eNo+9aZmhJqQg4EQb+ePH7bGPNDZ+M5oGUwReX857FoWaPhs4L
dAKQ1YwASxdKKh8wnaamjIeZSGP5TCjurH7pADAIaB3/D+ZNl2a7od+C1wARAQAB
tDdGcmVlQlNEIFNlY3VyaXR5IE9mZmljZXIgPHNlY3VyaXR5LW9mZmljZXJAZnJl
ZWJzZC5vcmc+iQJSBBMBCgA8AhsBBAsJCAcEFQoJCAUWAgMBAAIeBQIXgBYhBAvj
MnXXTJU8efgRB9mtKhgFdHTLBQJjlXeQBQkF3u+rAAoJENmtKhgFdHTLOVoQALS3
cj7rqYkHiV4zDYrgPEp9O1kAyGI8VdfGAMkDVTqr+wP4v/o7LIUrgwZl5qxesVFB
VknFr0Wp5g9h0iAjasoI5sDd6tH2SmumhBHXFVdftzDQhrugxH6fWRhHs0SaFYCk
Qt5nFbcpUfWgtQ35XTbsL8iENdYpjKXsSFQrJneGSwxIjWYTFn6ps/AI3gwR8+Bn
OffEFdYugJ049O6Vu6YBFJHrnMO7NbF4v95dVYuLtpMIaXWM+V9KITmhaBzFz5fM
Q7UOzcLlbxOYKNIWcp8QQk429mayKW5VUeUExUD1ZzBHn+P6ZG7QTMDu/RmBqiHo
ewCMVz4n9uXT5BiOngE4CvS0WQwHzK+k9MLpG2u/Bo9+LT0Ceh9Ou1rfU5+0tRwl
GyOFFjf3INS7I7gkcAwxQ7dzDItN/UQPZpg8y9mABU2x4enz0AvTnb61d/1dnTEr
tdNgU433he0ZnD1HurZCjBEWC656wv6iMdWcD8gjhMbmEpPmjvXcYlTO6zhEygSM
DiwdQCWK2W4++YJerA6ULBi3niNWBpofOFH8XylV56ruhjtHCo7+/3carcMoPOJv
lVZ1zCKxLro3TRBT15JTFBGqblRyTopFK3PuxW//GTnZOtpQEOV6yL4RAXcWeC1d
1hb5k/YxUmRF6XsDNEH4b08T8ZO8dV3dAV43Wh1oiQEzBBABCAAdFiEEuyjUCzYO
7pNq7RVv5fe8y6O93fgFAmObXVYACgkQ5fe8y6O93fiBlwf/W8y1XXJIx1ZA3n6u
f7aS70rbP9KFPr4U0dixwKE/gbtIQ9ckeNXrDDWz0v0NCz4qS+33IPiJg1WcY3vR
W90e7QgAueCo5TdZPImPbCs42vadpa5byMXS4Pw+xyT+d/yp2oLKYbj3En4bg1GM
w71DezIjvV+e01UR++u1t9yZ8LOWM5Kumz1zyQLZDZ8qIKt1bBfpa+E0cEqtNQWu
iGhQE3AHI8eWV+jBkg5y2zHRIevbWb1UPsj43lgkFtAGHk9rrM8Rmgr4AXr531iD
srBwauKZ/MElcF3MINuLH+gkPPaFHw/YIpLRLaZXZVsw3Xi1RNXI2n2ea29dvs/C
Lcf1vYkCMwQQAQgAHRYhBPwOh4rlr+eIAo1jVdOXkvSep+XCBQJjm14FAAoJENOX
kvSep+XC0DcP/1ZB7k9p1T+9QbbZZE1PJiHby3815ccH3XKexbNmmakHIn3L6Cet
F891Kqt9ssbhFRMNtyZ/k/8y8Hv5bKxVep5/HMyK+8aqfDFN0WMrqZh0/CiR6DJh
gnAmPNw/hAVHMHaYGII9kCrFfPFJ02FKoc81g9F08odb7TV+UlvRjkErhRxF+dGS
wQoO0RCbf0Z1cs7nd0Vb2z4IJh4XMxBjWc/uQ2Q9dH/0uRzwpAnR4YX+MG5YrX7Z
zBvDyR0r76iQwRSDKgioNgkr6R3rq1NZGdaj+8b0LzdOqtzKJ/eupDe3+H67e/EN
qymtreGjrubpiU9bKvYArisUqhE5KtguryvR6Qz9bj87nPg33DT3WWGVrwFRxBox
dbWzjQFv0wug8m4GAwVF7fPR5/eW7IHw8zvgn0vSPcZz7MZ4e6Y5jN4kA5/xWJYZ
Sps54qQWB+FA30unIXN68KqdIzONIbtaY3W4/JjJUCm4T+wEjKaH+wJX8w1DMjlg
mkTmGh/UrTyC1vXbPgk9Sy3cRTICR1T9z7W8UlmTtnKrUklrjlFR7SXzrEXzLGOX
Fm+NEHpHNXqzcm6c3QfzY/yQ9HSAQ/t7SUQ9caRePbDz3/msyPxtGFor9roQv6VN
wRXCyRgkH4Y5tPhJAQ8G/FxX+VXFb93QL0lfelb23/BBu6cUwW63SRn5uQINBGOV
dskBEADqo8z6TFAhrvHhJV5wHdj67guoYvpXP8gvdCqos8SLluqi0AWgJEwlqu7L
mKQ6qMoJ+2DN6y+dEtvOVgBAgF63LLf3FQKq9FB/3uqeIiQlCIl3H43f8KttEZzf
/lbry4Y6QhS2OXM31Ut9Q+1IfTGwvs1E8/J1U4jQrAGqNKknXyQyMweJ0jvvcSLJ
nv3S7COUJVOT3cTgVeh3RIQlFzqK2rSQmygDpS8bT8MjCsZr+KGezKpbddKXio4a
QW/e6nCMyYR8bo0GQ9DpsyAOsaENnkghncQhA7GdPZK9xLMNQMCp0OdcZlqRVjRZ
OutuzNW6PPoczs/NQq02YWK4BPtSV7+ldS9gPZTLIpnRNQRzcnA0vnQTqSAfasVw
sAGm+MpH7zcaMf2Tw1K08u7+5gyObgzUzQmGLCgo9VIncnDis0s4gfTmtrr5jCeV
7LYDQX+2fApMtXbVXeKJem1PS+Z6LPbW2HklxYuG5nFgewCYlQjKujfiwW1Clhi4
JQeE1Naobbaar99V/VeoHrOYAEWP0bkUyrFcocLJ+0g3KpjSkctIptgGGpMBKe4U
9O7pWoTki8Yz/uYQn/p0iZcG8SfKM8I4283jdsi5SUiNNJJZCBQTVA7d8MxUVv5+
qpX/v5XqYM3pHza2DLXzwfAE9O2dgN1OMZYIld+OnWcpm2PxIwARAQABiQRyBBgB
CgAmFiEEC+MydddMlTx5+BEH2a0qGAV0dMsFAmOVdskCGwIFCQICKQACQAkQ2a0q
GAV0dMvBdCAEGQEKAB0WIQS2FSd+gQh991yBgztuWN6QHwAa7wUCY5V2yQAKCRBu
WN6QHwAa77gbEADpUBT14cesITuMsOWYsyEtNmB4UlTFWCktk/YzyCotasZxIhMP
Xih9G1tDo9ExIWT8jNjSSA+w0Viua/PirDLvI8JtX1JiK3nwMenwlXwlkRAk9TJW
y944YegHF/5ytntwZ/L4BMYc3MztyZbw+sDwnNBZKYmO8gwfYobtfoGxOR4Onb37
bbUVw62xHQIn2zafSmMQ4oMXZTm9EteIYwgcrC1h+Urv5IXCJZHrqmXCPE5g5XZ1
G9jqkwlaRYWjcLD0qxwc5m9LNrF6OBS9N6S7DncIYt9VupI5OCr1uRSqzqaBMFDC
lTTH+dAx3b6J1KFB0UiHP3FeTalFh8L3NE+dN9apNAgkUWv/v4oo/6dkRu3NZse2
RAo/o2X5r40qk/lhydQRZTSTFsiuH3VUWVsgmqAHnHW7pMMw8FAlKhyRSFnhbW7r
e0jj8XMIO7G5yjQKQCnYuPdXbx++bP1PzsEWDv9j/sph5arcosdo6tEXklWHED17
MEPIton1+NRfsU0peEVggQXlwdTcZN/h7FeCZ56dcwCWdCpSlv6CcWzRXSNUyJpK
a9qfIqBX/monjy7w5IHmhvLwAYI6IoT11h1QDEfGfhrwWPwOjnXsaYm5E7wv8w69
PxMbOJbMpWSg8L7xW3LXKR1VwXggUC1+b3y67E5Ggi1hf0lfTnTMpL2ClO2QD/oC
hMIafhzxbjh2WzgYahVHZH3gpHc1/0Bnc07s9+Pa6EYYM9r0XzezLW7bswOjVloR
FreQ3FIF/2OSN0OGdm7dyYl0OliTIDDDlwK/l8bcckUcpHNR1dw0P3KvDlmLmzZy
G4HmzzSBa9jiFirEfcg2rnGc6Zi382jGVALuYVplPXyMOUiChp0AAQZzTIYpXw/g
pBE6em2k740yuK6WqG4yXXgk67FoH10TQvMd4Q73K4zw+9DMpThlUHcfBmAoViZw
il7C0xl+ysHX8ZI3JU8s1r3XAnpqdHi4Wpixm/ctXbVnTSA3FQr2SctJYqR1VHRW
GMW+Ii2SQDS+t9bZTzOgAPLDtfy+JqhBpwCB1a1EHftkJEojpfZipaYGkf3yc+vN
wUeUHp/csF9CT7Qbqaj1t7fVWzv7jcVKpRwngIT4vTSzqbo6WC34FuUAH0t7tJ5K
eZ625AqEFLmtqtDo+ydJhZrVrXBNXPfkx5hSVW/I9hvckMNwA3t0KfQC2sz+Z1Q1
a4vDWQYRytfyrgZkWGbXMn6l1JyqIolgJZuax2kYs7Vu3t8KptqCbv0ZBAGoMm7r
RLgVodhI9voA8YxCirSChrueJYn+JKk8MIyk3DdXpBoocMIAjFJAUgXjV5NQpZMy
xR8BEiQnBcHRIKVWEEyhbLtHpmCEsnKNyKVGoxs31IkEcgQYAQoAJgIbAhYhBAvj
MnXXTJU8efgRB9mtKhgFdHTLBQJlhctvBQkD8n2mAkDBdCAEGQEKAB0WIQS2FSd+
gQh991yBgztuWN6QHwAa7wUCY5V2yQAKCRBuWN6QHwAa77gbEADpUBT14cesITuM
sOWYsyEtNmB4UlTFWCktk/YzyCotasZxIhMPXih9G1tDo9ExIWT8jNjSSA+w0Viu
a/PirDLvI8JtX1JiK3nwMenwlXwlkRAk9TJWy944YegHF/5ytntwZ/L4BMYc3Mzt
yZbw+sDwnNBZKYmO8gwfYobtfoGxOR4Onb37bbUVw62xHQIn2zafSmMQ4oMXZTm9
EteIYwgcrC1h+Urv5IXCJZHrqmXCPE5g5XZ1G9jqkwlaRYWjcLD0qxwc5m9LNrF6
OBS9N6S7DncIYt9VupI5OCr1uRSqzqaBMFDClTTH+dAx3b6J1KFB0UiHP3FeTalF
h8L3NE+dN9apNAgkUWv/v4oo/6dkRu3NZse2RAo/o2X5r40qk/lhydQRZTSTFsiu
H3VUWVsgmqAHnHW7pMMw8FAlKhyRSFnhbW7re0jj8XMIO7G5yjQKQCnYuPdXbx++
bP1PzsEWDv9j/sph5arcosdo6tEXklWHED17MEPIton1+NRfsU0peEVggQXlwdTc
ZN/h7FeCZ56dcwCWdCpSlv6CcWzRXSNUyJpKa9qfIqBX/monjy7w5IHmhvLwAYI6
IoT11h1QDEfGfhrwWPwOjnXsaYm5E7wv8w69PxMbOJbMpWSg8L7xW3LXKR1VwXgg
UC1+b3y67E5Ggi1hf0lfTnTMpL2ClAkQ2a0qGAV0dMsjqhAAorQ725G342raJ+os
6+E/EFNsr4SR5H+AeinlQ2ymNSeO/ODsV6dmyYD3hed0mAXvIJt2B46fFC4eAP9f
VOIbMMhPMpnJuZyLPDi8gXcZLgWSRhJ88R98KIsmKlh+/fdZM4RI1JLjICi7kyNR
4jtKCzLj0DYVBzp1mn0lTwtFzv7SC9djpqFLnO5YoGPWfQHHhY02Trh2posRwAHO
oacXSFvsoQv6k6XNlStJ4lnrkH6t+Od4kU3/TJ0eQXs7Zd2WEVnMe1IhbihsGcAY
mzZzZlLOhskHCeVE2taHiXC6h4tC3/69I16N8ICauxGY41clPhiNmVaAzmkunOPz
ry5utl6HkpZ5/3UMVHI1JIvsfJW+vSMUhdcQILAv6DbRWWHeax3ZZ6iAVGCtJS7U
glwZM1Xor0okGtIS+aJ/Cw7tZ8Nm18lutcrf2MVW+BWpzMQKnWFQYTn1NEWjzYnx
9Na22+E8AvW02TdS0NSiP0sG/0q7lBNEck9vH4WEbbEXktj51Dg4ISUhQyW8BWwW
X+kSiNeqtcaikUb8SFj5vpTDotTSzikfT/jisvR5goTMNFCVHFZdXCdsbUZd8Iub
egAOh6Db/06y3mFYDEfcGJipab400OY03a2xw9Vz+YxrKfELCTBo2tZv+3K8kXgq
XFcbyJnkXmjnYM/sw5kKqtzuc7i5Ag0EY5V3BwEQAMpFVczZo9ZPNsgW791UW5o6
wnrnd1nIO+S4rc37q2TEz8KGHCuxo5NwffZ2t6Ln04BI54pbapg17b7a0hPka37H
FkL28n4VyMdx0CsAm3QEfUsdK6xwKV2SucYeVcrV1upcN4PdXD7su1I7/A4CWXFJ
G047zJ0Z89lJZiQEiAq7ghvEoinC0sm+0a6ao/ocqCgWCKM1yCPOyzJXleRrv29S
RnYziMR+q2U0x9xg9Xl6GMwUmFwbJc9nORVvLH7fbU6/du8EgoAYrglFOFZG/TSo
lSGWRSMiavz0JSD/i+rEN4aIT4WfBe+L9Wy1AmrNxiAO+zKmzHQu3JSxDncr+y+h
cd+W0gqw10FoI9jWLcL7kR+6a0iOjuJSXSopq2l3DafiPxtCFmr4CGQhzBHM6e4/
v/NNd3F0XpVbJ6RQph7lkfvfz8q2lvUlHhezJ0p1xXmhff9CHjdVMhmAmz5+imBA
Xk2mottNfKb0pFEen1xY3K/UPA4g+oPsSj495MsvIg9eIMCcC3/z0SEUMWH/styy
JzPqfpyfGwZeTcIj9vg2o+RnGvmcLVYA/EGToPk905kv/cK73oy8bZyOB0zMg7T9
PaWgLUO0sqjqo0Mw3knFySg3oRXlcilPQvfPdX0JvwLpc9DWlr1+1GkCXJ08lWug
Jc96CJQupKRb1IbC0oUXABEBAAGJAjwEGAEKACYWIQQL4zJ110yVPHn4EQfZrSoY
BXR0ywUCY5V3BwIbDAUJAgIpAAAKCRDZrSoYBXR0ywwtD/wIDmEcHdFlyFRTomUB
jbeK2uzcZIhkkgL58lc63UPle5iJ2FBvmYS+0rQS53sVEsccn5KfkOwTryKllvWb
l0IzuiqfawxALcfWpfZJHzTMSnDHfgXvOOyFMQruqRDAHAr7PNC0CnbT0sEF2ZFz
ad8M9fLqtkXUx4mgECNGJ4CVqg75KY8uUzv/BmRwEf587FT5/iAIed5MjFB2VFDX
9GABcvTTbHxCZIxnxl3cs15SxT0lAofZ2ueU6kWYWZSXFeaEM/4ymPJws2mmV0Ak
bJghLXCn9Mx3nX6NTZZ9Harbru+RzW3/Hg3DZd0J9vko8PafP0l1NWtgyX74CqvT
gjzTxXTnqrRXzcczK7fhcC2u4i0prPtXXcyyi7SwpoLikaZCLFFhUmOx+mS5Tjtg
FyFZBNxnO7iAwkzfcTcC9sPoWaFmiQf6q5EIYzG+WQpncj80mxl3HWOP6oFj/hZJ
RYseKeMkvJzLTo87rFdM6CsMrLwETR6e+aWM0btPFil1rXVACNOjsy0bxTV8OJEf
yxnYmyjvnBvB0kdiaVEDdVhxgSqzLAX4mgXa49/V6M/uzMr+n3/A1Jdk4V6fVm8S
5cFIXxoUat3cB4xGaT9OWD3o1NPr6eS9Vo0EsJlRl81SG68fS+Qtk2fX27T68YG4
Aa3zMfZxUsVuFLtTuQbRC+fJpIkCPAQYAQoAJgIbDBYhBAvjMnXXTJU8efgRB9mt
KhgFdHTLBQJlhcuqBQkD8n1oAAoJENmtKhgFdHTLoO0QAJsTE9fkleb7YzPEuP9G
J3jx8PGdWm7n+8UNdr24kS6gOXVUfPZrWa5So21hcIwZb4PZDqHSVSQnRciKhSnG
7gplYPNGZ4+FWbLr/mBRYarjkVFLUuCPexSIjxV1KSGJnWs9YTVAKZAz75GpCML6
jD6biCOQCQ86wqOdWvZIZR8YvurrxR64ABB0rjbsaG8cNOUX1cwAfdLwthf64dS+
2m3lqNGDHkP5eNL0RIxC5gXYEp0lvmlMH3ZuO5WrfH73PTDg89bxXeuhrFmSEwf4
xWm603oi8/2qQvR9/7jb0o+t71NQuWrWIFONZWWgZBUGso+uyT3XgY4YqKGR3z2Q
zKHYnJ6M7SvSYpqS7RtcxcCXF0HGNfES8cAgtKVpFtbtSwXXp8O8oLyjmVIO/NjU
pbLOGdFIsarsezLFV9f2fqZ63J34hyUSg8LrYVV1fA5DJUpebbX4hLpdk0MMtgG4
3BwKIGlJTpL5RkQ/uQU3YW2kairy7o+1imDD0TRzQxtdjVOI5vnlTNcfJZIIfLx4
drABA12OvpX3dfPV62R+8BAlJFT430CG6AISJIBqJRFvuikmnZGUvEHmOUs/FLbb
aXTPkKc7tR2WIwljRvMV+Qk84cWcX6YchMslMuiDM1mtlQZig34WHGSE+zCWnXAs
lIHlSwox7qfdO0Kz2XncSbIA
=QvUh
-----END PGP PUBLIC KEY BLOCK-----</pre></div></div></div><div class=sect3><h4 id=_secretário_do_core_team_core_secretaryfreebsd_org>D.1.2. Secretário do Core Team <code>&lt;<a href=mailto:core-secretary@FreeBSD.org>core-secretary@FreeBSD.org</a>></code><a class=anchor href=#_secretário_do_core_team_core_secretaryfreebsd_org></a></h4><div class="literalblock literal-block-margin"><div class=content><pre>pub   rsa4096/4D632518C3546B05 2024-02-17 [SC] [expires: 2025-02-16]
      Key fingerprint = 1A23 6A92 528D 00DD 7965  76FE 4D63 2518 C354 6B05
uid                            FreeBSD Core Team Secretary &lt;core-secretary@FreeBSD.org&gt;
sub   rsa4096/CABFDE12CA516ED2 2024-02-17 [E] [expires: 2025-02-16]</pre></div></div><div class="literalblock literal-block-margin"><div class=content><pre>-----BEGIN PGP PUBLIC KEY BLOCK-----

mQINBGXQ1o8BEAC+Rcg8cmVxuP17Vu+q5KgCx/XiulQuqKXAqqBlYCH2jqk6DINP
yFrREGBhzd/qNmlAYEahQ4Zgl0bUZNTrZVDyzicOvPP0jH+KSTQwRs7NOawEdlVO
cyHrwDCPEqf5ZzD4NhfTriEOw+j0pEH/onitUGvoQRtx15xWyaJQxDEBMTYMLewE
86D1bltwnTNczE3UZb7oQLJXkAX5hcLtou70XJGgZITvJkK+kp/xot2eFjnqRz/u
WeXnKhYAmC07EKwZ1uw047eHKwMMRBYqzApLwoQtfE430Kxf2q8de64x8zDbi6YM
1J4r8OAxOtHVyfJ0j7Q23DEZz0VVb4b1Tx5OG2Re/KSNvqI0awJO4TcRmOR88OyY
dzyXgnX6Sa7GVQY1FXvn7vtFuDAt7egZOzeomSHL9bdX07LTQ4UtM88EV9wm3q4q
smoatV9jsvPQ1zxCU3aQD/5eWTJH2/kz1LIuBL/Qi5XQpJn91lBtUWJrCgkHWPGu
f//rnnXmsG7DAChW+yZ7cFO8lfNa8sFhPqSxCYphWmJTrvadyQtDngB8JakWdnmK
pfGS6y5lel+181vw38ZZKt04AKM+nDY8051lBM7Q9Q6kTLI33UZeImndx5xYukVD
kV6aQ31HYfEark15c7iEz+OAcwFnM2ntXMt7kKGd40CqzusiPcQkPqPbAQARAQAB
tDhGcmVlQlNEIENvcmUgVGVhbSBTZWNyZXRhcnkgPGNvcmUtc2VjcmV0YXJ5QEZy
ZWVCU0Qub3JnPokCVwQTAQoAQRYhBBojapJSjQDdeWV2/k1jJRjDVGsFBQJl0NaP
AhsDBQkB4TOACAsJDQgMBwsDBRUKCQgLBRYDAgEAAh4FAheAAAoJEE1jJRjDVGsF
nacP/3PSg8JPmWoBfWrgT287NZ7OAU16/uGpDxlBUoVeEtkEDqZVW8yBFzrMhbwj
bJs3CZ+L85HMUDLZoxSwVnPM8PLVRzHTybYV7agYYzMox5C/jp2aeAgy9KYVd0Tk
07GMTYrSh4fhHWpxXz7IBOxk0RXvQxTHlg1u0DASkibYb2UTDcUNG5Q9kP/8jaIZ
kVDX8a5LDdOCgWaYdKPg4blv/UMjkegJz+Ayp7gXTcux6koW5F6ysSw9sgLBWb2D
b/KNIi4MBMe46xyXB/dqGAR4ibrUXTcQ4OAZNq1L6uWG1A49XuSgykdIwr00MzQw
wfVpKT31ww4ayVHLgj7NuqPlab9S5/fPfJ4MAvGE4GqWQFgsPKgKImUMgnnxTGpv
l7Dqk2MnWqn+wEi0bRES0PVBG96G+sZJQeaxBhoB+HwUSFqoZQg166AJIl//4t2w
bx0a1aWQSS0DZt3wsQW3NW9AE6L+FnFfIc2pQVoLjmvcGalDuvnemRmEOgotiZmt
32bi2aWxg0/Qio2rjLS2LpV+fhwDSN3Agvtnu53yUdD1TFFjTSMloM4SKhiXoPbI
XgfCLiBLNMsZL0AvO7wQfSePzPYxDLyEcwsfPJ8be+eGG1L62RUyad+MdfyXMH/S
m0sgqW/MW6Nv10RyPQOq3Jbgmp2laRMzKTOvQt5WwQf2FEl9uQINBGXQ1o8BEAC9
1cBYn6Z0QmM0OFWdXQI6fMOeNokaa6ngPgt7bzW5NjryqTdwyHOPZdm4DWf1SO/0
+fJRCqxbICyuMAFrb9fDle8bodALjm5ZquTL3D61HpZD4+RwOzOjYP6wLm7h38HT
/yIyK882Ovlw4Xz/TeSiL/VUSWE9twW7yz3oreCeLUBAfzacS9y+syO+aquEd0/x
JBz+mPQbrqfS64rCZXMZEivgsjkQoE6RM+n1rF4kw4Eu3E2kPevVwsoAaY+MEUM8
JAXaJMaNcLIhbeMy7dO/z6z2I3h5bUw5KxfVwzYSzSeRpYh53dNaB4NY+f5/vTrL
4dZmqBcLgcV0zZ02dj/u0SiwWlUFUpFGuSiW16DN7+2zG1zOWi7Nl44JawM62Tlf
mO8zruVGEHaV3e8fFwBLRKM0Sc7e3aLECISsfYeC5ZbRRbpQ1KX+VQr3FBKAMzG4
l9Go7vZ+UcLKpQx2rVPTJt1vDnRV49X6CF2Q/lV9iafQ4MTy6ACdAloT1yfH/lhU
iWQo1qDyRCSlmNBDsYl8gLrwMp4gGQAv3imZHxnJF5ru3nUYGG0U08D5mf2sWv5P
Wh7By8Jm8bmaP8cUF86lO9BJXh2d9QN5jqrAtXqYzenZ+ABSoL1XrD/yv3270rH7
H4gAUtgP+vJ3uMyRu9055OC+ie/b613NojCW5nYN2QARAQABiQI8BBgBCgAmFiEE
GiNqklKNAN15ZXb+TWMlGMNUawUFAmXQ1o8CGwwFCQHhM4AACgkQTWMlGMNUawXh
7w/+KjbEWTwAhjm2HJ3w4tXtPC5URg+A+BzYYVH/q0+956c1QeD0LYafHBw4LEMI
lhRvHQnmzwjtY8v/DgmLOVDMiMWVHo0Q2iQyMvOT1WyEPcgOTJLhvyVzDqRZx7AS
B4G8uNVkKAdBZ7OSXAP27lR/2SEoG05esw8b7Y39pVtucC3aeiua+19PLJWadBjj
XuvXuSCho0km+nk4IgadYmxIDyiMeyKZ8wCl7CJkzECm83q2OtNsMe3k8lgEXybt
KlQxnYApZmhqLMV5ob8WOk3AgAVsif1m332CiEIb1Sfx6wt3nXy/410CXdDDucuj
ndJVfJ6Un33tn0irZ5scPA2HmzK1PGMfgOGtkM8B3LE/x8kEKeWKb3l9boB32Unm
iTfKgEna+JISEab3bzOPWdCQFB8LyGXuWlhtvqmRoX8GtiMRy/F4mzh+l3lYHjj3
4EvPVyippO5zwU+S9HElJ2G37K6zrOmd5cGBrw4aBDoO70QVrMN4O86uvC9kChDb
qyFF5UgXg29QxJjiSCv98ksDMqpJ5AFYrmrsBtwU64OANrxxJ4AZLQ1apYmG9RWD
VHZgfeI60FNBLfKwix9UffFT7piQ/MLrjSde8gPH5S6ezBMrYpfGEopaI9A5qXe3
LnHz88gfdmaBM77YDZM/p23nmCrUxlE3kkbgjTY8NRjYyF8=
=MkAH
-----END PGP PUBLIC KEY BLOCK-----</pre></div></div></div><div class=sect3><h4 id=_secretário_da_equipe_de_gerenciamento_do_ports_portmgr_secretaryfreebsd_org>D.1.3. Secretário da equipe de gerenciamento do Ports <code>&lt;<a href=mailto:portmgr-secretary@FreeBSD.org>portmgr-secretary@FreeBSD.org</a>></code><a class=anchor href=#_secretário_da_equipe_de_gerenciamento_do_ports_portmgr_secretaryfreebsd_org></a></h4><div class="literalblock literal-block-margin"><div class=content><pre>pub   ed25519/E3C401F60D709D59 2023-03-06 [SC] [expires: 2027-03-05]
      Key fingerprint = BED4 A1D3 6555 B681 2E9F  ABDA E3C4 01F6 0D70 9D59
uid                            FreeBSD Ports Management Team Secretary &lt;portmgr-secretary@FreeBSD.org&gt;
sub   cv25519/2C92B55E27A641C3 2023-03-06 [E] [expires: 2027-03-05]</pre></div></div><div class="literalblock literal-block-margin"><div class=content><pre>-----BEGIN PGP PUBLIC KEY BLOCK-----

mDMEZAXJvxYJKwYBBAHaRw8BAQdASFAC20WL3R1T6uNyGMZbfJCxDkcP4C5vi3Op
tcZ2fbq0R0ZyZWVCU0QgUG9ydHMgTWFuYWdlbWVudCBUZWFtIFNlY3JldGFyeSA8
cG9ydG1nci1zZWNyZXRhcnlARnJlZUJTRC5vcmc+iJYEExYKAD4WIQS+1KHTZVW2
gS6fq9rjxAH2DXCdWQUCZAXJvwIbAwUJB4TOAAULCQgHAwUVCgkICwUWAwIBAAIe
BQIXgAAKCRDjxAH2DXCdWYN1AP43TjyfZtZ3DLYT++g0+SuPsoO/3yWVybA+UmFL
zb8MngEA+LLNUfvEwCuXS/soh+ww5bpfmi3UUmeGiQEAXug3iA+JATMEEAEKAB0W
IQT7N0XIbxXo7ayBMvzYKU7Du8TX1QUCZAXLkwAKCRDYKU7Du8TX1XHMB/9R1MX4
6zMgpKqPPt76GOI+eGEdBK6bY8aJZjQGdqTh9f6VtXVoTGIG7cvhc9X8tDBoB0PT
2KZWheF51AV1+NHU4HwLAQ1BMebrFvWSfkw4xg4fBGwDhz9/GN85No+Js772V5ey
8lRiL6meRVWxMlLyWcxGd8JjcC5yX/iAUQ3SBGCLqW7unWjjg7CTd+AMBwcqPGrv
ax8q6eFVguJcHJAjMnKf6HAy4cpK3s+uMoUBCGnszSN12B3ysKfyC4pNO/pix5tA
Q5v8aRqTeFPh5zmNhWo0KGPzplTPqRQSHDl7GDQC8Ru3MhzFkeWzHsexjZVwS6W2
DPcYpuuAsA0XOZIZiQIzBBABCgAdFiEEEBpxaxYrAOVb7eoFrbv4YQo3ibcFAmQF
0u0ACgkQrbv4YQo3ibccwg/9F2Xuic3nhKxRbB3mJeDo6SYQETa/Gh1qQ34+8zlt
8UMazOx67gnYQfy+pXjro6eQ2up0a4eUYezcNOudqAQD21nRz3HA6EQVNcE/TzEA
xl5CJntTaLOt7S+EDXFW5BuQIvhhoMGgm8+WNVgA0EJ7tfL0OcYBSvr19fqwChEn
9c14cSk6mgHSsleP5NvskYN053pxHwy0LTSb8YBBv52th37t/CRFC1363rS5q+D7
JixFopd1O5pKpA5ipvE4gGgRjPtwjx0SjjepwK/3fuhEJQQyKzTIKlMfu2Dj/iR2
Li1Sfccau5LQXOj9fUITU3u1YG7yrm8VGzT7ao4d+KRwgMLjd2pLqiGIbbJwGBiP
FRmtilWQoeIlmSlFX4obAA517DOK0pW1mH8+eEn4EJd3SekT3yzFyKTASv0J48Z8
3F928xg+eZvHxVC0t1J+J5IG0gt3EEncuWKIPQGR7PiQbti6R3FQVTz6WfMWOebP
Qi0E9F/Aqakr6Vj2sKGrDq+ebpaF5G8Yw1YrUl2IDiPzkCegp3ZbI0wh11Xvzhi8
LXPQGK4jBQas4G8cegfitzmtdGRHYrbMv0R9I4mvaL+WlOuD2AvyVG28lguqVhnN
AZP+ohdquYyX2CNCVvbKWAtXo6Ur0vWG8BL8m6defAtEkIwVBALaOHQOSI3aNUz4
lwy4OARkBcm/EgorBgEEAZdVAQUBAQdAsefmSfxEOdOr02+K/6noYCuJ1FeAWVz6
jFYQ+9w6jggDAQgHiH4EGBYKACYWIQS+1KHTZVW2gS6fq9rjxAH2DXCdWQUCZAXJ
vwIbDAUJB4TOAAAKCRDjxAH2DXCdWRl4AP9h5ot212BK29S6ZcMBhHvmtF5PG1oD
c7LnZycSRmbFiwEAndCMpAGOhDW8iVgDd0wLQq/ZMPe+xccfG1b3zFH2EgE=
=iiAT
-----END PGP PUBLIC KEY BLOCK-----</pre></div></div></div><div class=sect3><h4 id=_doceng_secretaryfreebsd_org>D.1.4. <code>&lt;<a href=mailto:doceng-secretary@FreeBSD.org>doceng-secretary@FreeBSD.org</a>></code><a class=anchor href=#_doceng_secretaryfreebsd_org></a></h4><div class="literalblock literal-block-margin"><div class=content><pre>pub   rsa2048/E1C03580AEB45E58 2019-10-31 [SC] [expires: 2022-10-30]
      Key fingerprint = F24D 7B32 B864 625E 5541  A0E4 E1C0 3580 AEB4 5E58
uid                            FreeBSD Doceng Team Secretary &lt;doceng-secretary@freebsd.org&gt;
sub   rsa2048/9EA8D713509472FC 2019-10-31 [E] [expires: 2022-10-30]</pre></div></div><div class="literalblock literal-block-margin"><div class=content><pre>-----BEGIN PGP PUBLIC KEY BLOCK-----

mQENBF27FFcBCADeoSsIgyQUY8vREwkTikwFFlNg31MVy5s/Nq1cNK1PRfRMnprS
yfB62KqbYuz16bmQKaA9zHN4FGfiTvR6tl66LVHm1s/5HPiLv8sP14GsruLro9zN
v72dO7a9i68bMw+jarPOnu9dGiDFEI0dACOkdCGEYKEUapQeNpmWRrQ46BeXyFwF
JcNx76bJJUkwk6fWC0W63D762e6lCEX6ndoaPjjLBnFvtx13heNGUc8RukBwe2mA
U5pSGHj47J05bdWiRSwZaXa8PcW+20zTWaP755w7zWe4h60GANY7OsT9nuOqsioJ
QonxTrJuZweKRV8fNQ1EfDws3HZr7/7iXvO3ABEBAAG0PEZyZWVCU0QgRG9jZW5n
IFRlYW0gU2VjcmV0YXJ5IDxkb2Nlbmctc2VjcmV0YXJ5QGZyZWVic2Qub3JnPokB
VAQTAQoAPhYhBPJNezK4ZGJeVUGg5OHANYCutF5YBQJduxRXAhsDBQkFo5qABQsJ
CAcDBRUKCQgLBRYDAgEAAh4BAheAAAoJEOHANYCutF5YB2IIALw+EPYmOz9qlqIn
oTFmk/5MrcdzC5iLEfxubbF6TopDWsWPiOh5mAuvfEmROSGf6ctvdYe9UtQV3VNY
KeeyskeFrIBOFo2KG/dFqKPAWef6IfhbW3HWDWo5uOBg01jHzQ/pB1n6SMKiXfsM
idL9wN+UQKxF3Y7S/bVrZTV0isRUolO9+8kQeSYT/NMojVM0H2fWrTP/TaNEW4fY
JBDAl5hsktzdl8sdbNqdC0GiX3xb4GvgVzGGQELagsxjfuXk6PfOyn6Wx2d+yRcI
FrKojmhihBp5VGFQkntBIXQkaW0xhW+WBGxwXdaAl0drQlZ3W+edgdOl705x73kf
Uw3Fh2a5AQ0EXbsUVwEIANEPAsltM4vFj2pi5xEuHEcZIrIX/ZJhoaBtZkqvkB+H
4pu3/eQHK5hg0Dw12ugffPMz8mi57iGNI9TXd8ZYMJxAdvEZSDHCKZTX9G+FcxWa
/AzKNiG25uSISzz7rMB/lV1gofCdGtpHFRFTiNxFcoacugTdlYDiscgJZMJSg/hC
GXBdEKXR5WRAgAGandcL8llCToOt1lZEOkd5vJM861w6evgDhAZ2HGhRuG8/NDxG
r4UtlnYGUCFof/Q4oPNbDJzmZXF+8OQyTNcEpVD3leEOWG1Uv5XWS2XKVHcHZZ++
ISo/B5Q6Oi3SJFCVV9f+g09YF+PgfP/mVMBgif2fT20AEQEAAYkBPAQYAQoAJhYh
BPJNezK4ZGJeVUGg5OHANYCutF5YBQJduxRXAhsMBQkFo5qAAAoJEOHANYCutF5Y
kecIAMTh2VHQqjXHTszQMsy3NjiTVVITI3z+pzY0u2EYmLytXQ2pZMzLHMcklmub
5po0X4EvL6bZiJcLMI2mSrOs0Gp8P3hyMI40IkqoLMp7VA2LFlPgIJ7K5W4oVwf8
khY6lw7qg2l69APm/MM3xAyiL4p6MU8tpvWg5AncZ6lxyy27rxVflzEtCrKQuG/a
oVaOlMjH3uxvOK6IIxlhvWD0nKs/e2h2HIAZ+ILE6ytS5ZEg2GXuigoQZdEnv71L
xyvE9JANwGZLkDxnS5pgN2ikfkQYlFpJEkrNTQleCOHIIIp8vgJngEaP51xOIbQM
CiG/y3cmKQ/ZfH7BBvlZVtZKQsI=
=MQKT
-----END PGP PUBLIC KEY BLOCK-----</pre></div></div></div></div></div></div></div><hr><div class=last-modified><p><strong>Última alteração em</strong>: 14 de janeiro de 2022 por <a href="https://cgit.freebsd.org/doc/commit/?id=0c272255af" target=_blank>Li-Wen Hsu</a></p></div><div class=buttons><div class=home><i class="fa fa-home" aria-hidden=true title=Início></i><div class=container><a href=../ class=direction>Início</a></div></div></div><label class="hidden book-menu-overlay" for=menu-control></label></div><aside class=toc><div class=toc-content><h3>Índice</h3><nav id=TableOfContents><ul><li><a href=#book-preface>Prefácio</a><ul><li><a href=#preface-audience>Audiência Pretendida</a></li><li><a href=#preface-changes-from3>Mudanças desde a Terceira Edição</a></li><li><a href=#preface-changes-from2>Mudanças desde a Segunda Edição (2004)</a></li><li><a href=#preface-changes>Mudanças desde a Primeira Edição (2001)</a></li><li><a href=#preface-overview>Organização deste Livro</a></li><li><a href=#preface-conv>Convenções utilizadas neste livro</a></li><li><a href=#preface-acknowledgements>Agradecimentos</a></li></ul></li><li><a href=#getting-started>Parte I: Primeiros Passos</a><ul><li><a href=#introduction>Capítulo 1. Introdução</a></li><li><a href=#bsdinstall>Capítulo 2. Instalando o FreeBSD</a></li><li><a href=#basics>Capítulo 3. Fundamentos do FreeBSD</a></li><li><a href=#ports>Capítulo 4. Instalando Aplicativos: Pacotes e Ports</a></li><li><a href=#x11>Capítulo 5. O sistema X Window</a></li></ul></li><li><a href=#common-tasks>Parte II: Tarefas comuns</a><ul><li><a href=#desktop>Capítulo 6. Aplicações de Desktop</a></li><li><a href=#multimedia>Capítulo 7. Multimídia</a></li><li><a href=#kernelconfig>Capítulo 8. Configurando o kernel do FreeBSD</a></li><li><a href=#printing>Capítulo 9. Impressão</a></li><li><a href=#linuxemu>Capítulo 10. Compatibilidade binária com o Linux®</a></li></ul></li><li><a href=#system-administration>Parte III: Administração do Sistema</a><ul><li><a href=#config-tuning>Capítulo 11. Configuração e Ajuste</a></li><li><a href=#boot>Capítulo 12. O processo de inicialização do FreeBSD</a></li><li><a href=#security>Capítulo 13. Segurança</a></li><li><a href=#jails>Capítulo 14. Jails</a></li><li><a href=#mac>Capítulo 15. Controle de acesso obrigatório</a></li><li><a href=#audit>Capítulo 16. Auditoria de Evento de Segurança</a></li><li><a href=#disks>Capítulo 17. Armazenamento</a></li><li><a href=#geom>Capítulo 18. GEOM: Framework de Transformação de Disco Modular</a></li><li><a href=#zfs>Capítulo 19. O sistema de arquivos Z (ZFS)</a></li><li><a href=#filesystems>Capítulo 20. Outros Sistemas de Arquivos</a></li><li><a href=#virtualization>Capítulo 21. Virtualização</a></li><li><a href=#l10n>Capítulo 22. Localização - Uso e Configuração do i18n/L10n</a></li><li><a href=#updating-upgrading>Capítulo 23. Atualização e Upgrade do FreeBSD</a></li><li><a href=#dtrace>Capítulo 24. DTrace</a></li><li><a href=#usb-device-mode>Capítulo 25. Modo de dispositivo USB/USB OTG</a></li></ul></li><li><a href=#network-communication>Parte IV: Comunicação de rede</a><ul><li><a href=#serialcomms>Capítulo 26. Comunicações Seriais</a></li><li><a href=#ppp-and-slip>Capítulo 27. PPP</a></li><li><a href=#mail>Capítulo 28. Correio Eletrônico</a></li><li><a href=#network-servers>Capítulo 29. Servidores de Rede</a></li><li><a href=#firewalls>Capítulo 30. Firewalls</a></li><li><a href=#advanced-networking>Capítulo 31. Rede Avançada</a></li></ul></li><li><a href=#appendices>Parte V: Apêndices</a><ul><li><a href=#mirrors>Apêndice A: Obtendo o FreeBSD</a></li><li><a href=#bibliography>Apêndice B: Bibliografia</a></li><li><a href=#eresources>Apêndice C: Recursos na Internet</a></li><li><a href=#pgpkeys>Apêndice D: Chaves OpenPGP</a></li></ul></li></ul></nav><hr><div class=resources><h3>Recursos</h3><ul class=contents><li><i class="fa fa-file-pdf-o" aria-hidden=true title="Download PDF"></i><a href=https://download.freebsd.org/doc/pt-br/books/handbook/handbook_pt-br.pdf>Download PDF</a></li><li><i class="fa fa-pencil-square-o" aria-hidden=true title="Edite essa página"></i><a href=https://github.com/freebsd/freebsd-doc/blob/main/documentation/content/pt-br/book target=_blank>Edite essa página</a></li></ul></div></div></aside><a class=to-top href=#top><i class="fa fa-arrow-circle-up" aria-hidden=true></i></a></main><footer><div class=footer-container><section class=logo-column><img src=https://docs.freebsd.org/images/FreeBSD-colors.svg width=160 height=50 alt="FreeBSD logo"><div class=options-container><div class=language-container><a id=languages href=https://docs.freebsd.org/pt-br/languages><img src=https://docs.freebsd.org/images/language.png class=language-image alt="Escolha o idioma">
<span>Brazilian Portuguese</span></a></div><div class=theme-container><select id=theme-chooser><option value=theme-system>System</option><option value=theme-light>Light</option><option value=theme-dark>Dark</option><option value=theme-high-contrast>Alto contraste</option></select></div></div></section><section class=about-column><h3 class=column-title>About</h3><ul class=column-elements-container><li><a href=https://www.freebsd.org/about/ target=_blank class=column-element>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/ target=_blank class=column-element>FreeBSD Foundation</a></li><li><a href=https://www.freebsd.org/where/ target=_blank class=column-element>Get FreeBSD</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct target=_blank class=column-element>Code of Conduct</a></li><li><a href=https://www.freebsd.org/security/ target=_blank class=column-element>Security Advisories</a></li></ul></section><section class=documentation-column><h3 class=column-title>Documentation</h3><ul class=column-elements-container><li><a href=/pt-br class=column-element>Documentation portal</a></li><li><a href=https://man.FreeBSD.org target=_blank class=column-element>Manual pages</a></li><li><a href=https://papers.FreeBSD.org target=_blank class=column-element>Presentations and papers</a></li><li><a href=https://docs-archive.freebsd.org/doc/ target=_blank class=column-element>Previous versions</a></li><li><a href=https://docs-archive.freebsd.org/44doc/ target=_blank class=column-element>4.4BSD Documents</a></li><li><a href=https://wiki.freebsd.org/ target=_blank class=column-element>Wiki</a></li></ul></section><section class=community-column><h3 class=column-title>Community</h3><ul class=column-elements-container><li><a href=https://docs.freebsd.org/pt-br/articles/contributing class=column-element>Get involved</a></li><li><a href=https://forums.freebsd.org/ target=_blank class=column-element>Community forum</a></li><li><a href=https://lists.freebsd.org/ target=_blank class=column-element>Mailing lists</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank class=column-element>IRC Channels</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank class=column-element>Bug Tracker</a></li></ul></section><section class=legal-column><h3 class=column-title>Legal</h3><ul class=column-elements-container><li><a href=https://freebsdfoundation.org/donate/ target=_blank class=column-element>Donations</a></li><li><a href=https://www.freebsd.org/copyright/freebsd-license/ target=_blank class=column-element>Licensing</a></li><li><a href=https://www.freebsd.org/privacy/ target=_blank class=column-element>Privacy Policy</a></li><li><a href=https://www.freebsd.org/copyright/ target=_blank class=column-element>Legal notices</a></li></ul></section><section class=copyright-column><p>&copy; 1994-2024 The FreeBSD Project. All rights reserved</p><span>Made with <span class=heart>♥</span> by the FreeBSD Community</span></section></div></footer></body></html>