<!doctype html><html class=theme-light lang=pt-br><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content><meta name=keywords content><meta name=copyright content="1995-2024 The FreeBSD Foundation"><link rel=canonical href=https://docs.freebsd.org/pt-br/books/handbook/disks/><title>Capítulo 17. Armazenamento | FreeBSD Documentation Portal</title>
<meta name=theme-color content="#790000"><meta name=color-scheme content="system light dark high-contrast"><link rel="shortcut icon" href=https://docs.freebsd.org/favicon.ico><link rel=stylesheet href=https://docs.freebsd.org/styles/main.min.css><link rel=stylesheet href=https://docs.freebsd.org/css/font-awesome-min.css><script defer src=/js/theme-chooser.min.js></script><script defer src=/js/copy-clipboard.min.js></script><script defer src=/js/search.min.js></script><meta name=twitter:card content="summary"><meta name=twitter:domain content="docs.FreeBSD.org"><meta name=twitter:site content="@freebsd"><meta name=twitter:url content="https://twitter.com/freebsd"><meta property="og:title" content="Capítulo 17. Armazenamento"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:image" content="https://docs.freebsd.org/favicon.ico"><meta property="og:image:alt" content="FreeBSD Logo"><meta property="og:locale" content="pt-br"><meta property="og:url" content="https://docs.freebsd.org/pt-br/books/handbook/disks/"><meta property="og:site_name" content="FreeBSD Documentation Portal"><script type=application/ld+json>{"@context":"http://schema.org","@type":"Article","url":"https:\/\/docs.freebsd.org\/pt-br\/books\/handbook\/disks\/","name":"FreeBSD Documentation Portal","headline":"FreeBSD Documentation Portal","description":"FreeBSD Documentation Portal"}</script></head><body><header><div class=header-container><div class=logo-menu-bars-container><a href=https://www.FreeBSD.org class=logo><img src=https://docs.freebsd.org/images/FreeBSD-monochromatic.svg width=160 height=50 alt="FreeBSD logo">
</a><label class=menu-bars for=menu-bars><i class="fa fa-bars" aria-hidden=true></i></label></div><input id=menu-bars type=checkbox><nav><ul class=menu><li class=menu-item><input id=about type=checkbox>
<a href=# aria-label="Navigate to About section"><label class=menu-item-description for=about>About
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/about/ target=_blank>About</a></li><li><a href=https://www.freebsd.org/about/ target=_blank>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/about-us/about-the-foundation/ target=_blank>FreeBSD Foundation</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct/ target=_blank>Code of Conduct</a></li></ul></li><li class=menu-item><input id=download type=checkbox>
<a href=# aria-label="Navigate to get FreeBSD section"><label class=menu-item-description for=download>Get FreeBSD
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/where/ target=_blank>Get FreeBSD</a></li><li><a href=https://www.freebsd.org/releases/ target=_blank>Release Information</a></li><li><a href=https://www.freebsd.org/releng/ target=_blank>Release Engineering</a></li><li><a href=https://www.freebsd.org/security/ target=_blank>Security Advisories</a></li></ul></li><li class=menu-item><input id=documentation type=checkbox>
<a href=# aria-label="Navigate to get Documentation section"><label class=menu-item-description for=documentation>Documentation
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=/pt-br>Documentation portal</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook>FreeBSD Handbook</a></li><li><a href=https://docs.freebsd.org/pt-br/books/porters-handbook>Porter's Handbook</a></li><li><a href=https://docs.FreeBSD.org/en/books/fdp-primer>Documentation Project Handbook</a></li><li><a href=https://man.FreeBSD.org target=_blank>Manual pages</a></li><li><a href=https://papers.FreeBSD.org target=_blank>Presentations and papers</a></li><li><a href=https://wiki.FreeBSD.org target=_blank>Wiki</a></li><li><a href=https://docs.freebsd.org/pt-br/books>Books</a></li><li><a href=https://docs.freebsd.org/pt-br/articles>Articles</a></li></ul></li><li class=menu-item><input id=community type=checkbox>
<a href=# aria-label="Navigate to get Community section"><label class=menu-item-description for=community>Community
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/community/>Community</a></li><li><a href=https://docs.freebsd.org/pt-br/articles/contributing>Get involved</a></li><li><a href=https://forums.freebsd.org/ target=_blank>Forum</a></li><li><a href=https://lists.freebsd.org/ target=_blank>Mailing lists</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank>IRC Channels</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank>Bug Tracker</a></li><li><a href=https://www.freebsd.org/support/ target=_blank>Support</a></li></ul></li></ul></nav><div class=search-donate-container><form class=search method=get id=search-header-form action=https://docs.freebsd.org/search name=search-header-form><input type=hidden name=DB value=pt-br>
<input id=words name=P type=text size=20 maxlength=255>
<button>
<i class="fa fa-search" aria-hidden=true></i></button></form><div class=donate><a href=https://freebsdfoundation.org/donate/ target=_blank><span class=heart>♥</span>
Donate</a></div></div></div></header><input type=checkbox class="hidden toggle" id=menu-control><main class=main-wrapper-book><a id=top></a><aside class=book-menu><div class=book-menu-content><input id=search-book type=text placeholder=Pesquisar aria-label=Pesquisar maxlength=128><nav id=MenuContents><ul><li><input type=checkbox id=chapter-eb2a98ce203d8afd517726e6d8776be3 class=toggle>
<label class="icon cursor" for=chapter-eb2a98ce203d8afd517726e6d8776be3><a role=button></a></label><a href=https://docs.freebsd.org/pt-br/books/handbook/preface/>Prefácio</a><ul><li><a href=https://docs.freebsd.org/pt-br/books/handbook/preface/#preface-audience>Audiência Pretendida</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/preface/#preface-changes-from3>Mudanças desde a Terceira Edição</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/preface/#preface-changes-from2>Mudanças desde a Segunda Edição (2004)</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/preface/#preface-changes>Mudanças desde a Primeira Edição (2001)</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/preface/#preface-overview>Organização deste Livro</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/preface/#preface-conv>Convenções utilizadas neste livro</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/preface/#preface-acknowledgements>Agradecimentos</a></li></ul></li><li><input type=checkbox id=chapter-14a525fce014b90b8a458a894818255a class=toggle>
<label for=chapter-14a525fce014b90b8a458a894818255a><a role=button></a></label><a href=https://docs.freebsd.org/pt-br/books/handbook/parti/>Parte I. Primeiros Passos</a></li><li><input type=checkbox id=chapter-f9c9f3451644df30d224350da97d5da6 class=toggle>
<label class="icon cursor" for=chapter-f9c9f3451644df30d224350da97d5da6><a role=button></a></label><a href=https://docs.freebsd.org/pt-br/books/handbook/introduction/>Capítulo 1. Introdução</a><ul><li><a href=https://docs.freebsd.org/pt-br/books/handbook/introduction/#introduction-synopsis>1.1. Sinopse</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/introduction/#nutshell>1.2. Bem vindo ao FreeBSD!</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/introduction/#history>1.3. Sobre o Projeto FreeBSD</a></li></ul></li><li><input type=checkbox id=chapter-f693a3fa687a72d63ec8129ee302d664 class=toggle>
<label class="icon cursor" for=chapter-f693a3fa687a72d63ec8129ee302d664><a role=button></a></label><a href=https://docs.freebsd.org/pt-br/books/handbook/bsdinstall/>Capítulo 2. Instalando o FreeBSD</a><ul><li><a href=https://docs.freebsd.org/pt-br/books/handbook/bsdinstall/#bsdinstall-synopsis>2.1. Sinopse</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/bsdinstall/#bsdinstall-hardware>2.2. Requisitos mínimos de hardware</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/bsdinstall/#bsdinstall-pre>2.3. Tarefas de Pré-instalação</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/bsdinstall/#bsdinstall-start>2.4. Iniciando a instalação</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/bsdinstall/#using-bsdinstall>2.5. Usando o bsdinstall</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/bsdinstall/#bsdinstall-partitioning>2.6. Alocando o espaço em disco</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/bsdinstall/#bsdinstall-fetching-distribution>2.7. Fazendo o download dos arquivos de distribuição</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/bsdinstall/#bsdinstall-post>2.8. Contas, Time Zone, Serviços e Hardening</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/bsdinstall/#bsdinstall-network>2.9. Interfaces de Rede</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/bsdinstall/#bsdinstall-install-trouble>2.10. Solução de problemas</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/bsdinstall/#using-live-cd>2.11. Usando o Live CD</a></li></ul></li><li><input type=checkbox id=chapter-9f6db261075f578742036fcc6000eecd class=toggle>
<label class="icon cursor" for=chapter-9f6db261075f578742036fcc6000eecd><a role=button></a></label><a href=https://docs.freebsd.org/pt-br/books/handbook/basics/>Capítulo 3. Fundamentos do FreeBSD</a><ul><li><a href=https://docs.freebsd.org/pt-br/books/handbook/basics/#basics-synopsis>3.1. Sinopse</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/basics/#consoles>3.2. Consoles e Terminais Virtuais</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/basics/#users-synopsis>3.3. Usuários e Gerenciamento Básico de Contas</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/basics/#permissions>3.4. Permissões</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/basics/#dirstructure>3.5. Estrutura de Diretórios</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/basics/#disk-organization>3.6. Organização dos Discos</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/basics/#mount-unmount>3.7. Montando e Desmontando Sistemas de Arquivos</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/basics/#basics-processes>3.8. Processos e Daemons</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/basics/#shells>3.9. Shells</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/basics/#editors>3.10. Editores de Texto</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/basics/#basics-devices>3.11. Dispositivos e nós de dispositivos</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/basics/#basics-more-information>3.12. Páginas de Manual</a></li></ul></li><li><input type=checkbox id=chapter-01c5707e95d14c0ff84bf62600c958d1 class=toggle>
<label class="icon cursor" for=chapter-01c5707e95d14c0ff84bf62600c958d1><a role=button></a></label><a href=https://docs.freebsd.org/pt-br/books/handbook/ports/>Capítulo 4. Instalando Aplicativos: Pacotes e Ports</a><ul><li><a href=https://docs.freebsd.org/pt-br/books/handbook/ports/#ports-synopsis>4.1. Sinopse</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/ports/#ports-overview>4.2. Visão geral sobre a Instalação de Software</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/ports/#ports-finding-applications>4.3. Encontrando Software</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/ports/#pkgng-intro>4.4. Usando o pkg para o gerenciamento de pacotes binários</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/ports/#ports-using>4.5. Usando a Coleção de Ports</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/ports/#ports-poudriere>4.6. Compilando Pacotes com o Poudriere</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/ports/#ports-nextsteps>4.7. Considerações pós-instalação</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/ports/#ports-broken>4.8. Lidando com ports quebrados</a></li></ul></li><li><input type=checkbox id=chapter-3405c00581365a8b5d16af70fe4d1b72 class=toggle>
<label class="icon cursor" for=chapter-3405c00581365a8b5d16af70fe4d1b72><a role=button></a></label><a href=https://docs.freebsd.org/pt-br/books/handbook/x11/>Capítulo 5. O sistema X Window</a><ul><li><a href=https://docs.freebsd.org/pt-br/books/handbook/x11/#x11-synopsis>5.1. Sinopse</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/x11/#x-understanding>5.2. Terminologia</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/x11/#x-install>5.3. Instalando o Xorg</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/x11/#x-config>5.4. Configuração do Xorg</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/x11/#x-fonts>5.5. Usando fontes no Xorg</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/x11/#x-xdm>5.6. O Gerenciador de Display X</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/x11/#x11-wm>5.7. Ambientes de desktop</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/x11/#x-compiz-fusion>5.8. Instalando o Compiz Fusion</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/x11/#x11-troubleshooting>5.9. Solução de problemas</a></li></ul></li><li><input type=checkbox id=chapter-0eab3565e8f59f5a8a896dfba7eb3680 class=toggle>
<label for=chapter-0eab3565e8f59f5a8a896dfba7eb3680><a role=button></a></label><a href=https://docs.freebsd.org/pt-br/books/handbook/partii/>Parte II. Tarefas comuns</a></li><li><input type=checkbox id=chapter-b33cf28993f3f7bf5baf036e79da0f39 class=toggle>
<label class="icon cursor" for=chapter-b33cf28993f3f7bf5baf036e79da0f39><a role=button></a></label><a href=https://docs.freebsd.org/pt-br/books/handbook/desktop/>Capítulo 6. Aplicações de Desktop</a><ul><li><a href=https://docs.freebsd.org/pt-br/books/handbook/desktop/#desktop-synopsis>6.1. Sinopse</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/desktop/#desktop-browsers>6.2. Navegadores</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/desktop/#desktop-productivity>6.3. Produtividade</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/desktop/#desktop-viewers>6.4. Visualizadores de Documentos</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/desktop/#desktop-finance>6.5. Finanças</a></li></ul></li><li><input type=checkbox id=chapter-152f694a19312ad72ec7bb4e1c3c33b2 class=toggle>
<label class="icon cursor" for=chapter-152f694a19312ad72ec7bb4e1c3c33b2><a role=button></a></label><a href=https://docs.freebsd.org/pt-br/books/handbook/multimedia/>Capítulo 7. Multimídia</a><ul><li><a href=https://docs.freebsd.org/pt-br/books/handbook/multimedia/#multimedia-synopsis>7.1. Sinopse</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/multimedia/#sound-setup>7.2. Configurando a Placa de Som</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/multimedia/#sound-mp3>7.3. Áudio MP3</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/multimedia/#video-playback>7.4. Reprodução de Vídeo</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/multimedia/#tvcard>7.5. Placas de TV</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/multimedia/#mythtv>7.6. MythTV</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/multimedia/#scanners>7.7. Scanners de Imagem</a></li></ul></li><li><input type=checkbox id=chapter-80888b4ee02e3e409e5f71cf97a36450 class=toggle>
<label class="icon cursor" for=chapter-80888b4ee02e3e409e5f71cf97a36450><a role=button></a></label><a href=https://docs.freebsd.org/pt-br/books/handbook/kernelconfig/>Capítulo 8. Configurando o kernel do FreeBSD</a><ul><li><a href=https://docs.freebsd.org/pt-br/books/handbook/kernelconfig/#kernelconfig-synopsis>8.1. Sinopse</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/kernelconfig/#kernelconfig-custom-kernel>8.2. Por que compilar um kernel personalizado?</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/kernelconfig/#kernelconfig-devices>8.3. Encontrando o hardware do sistema</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/kernelconfig/#kernelconfig-config>8.4. O Arquivo de Configuração</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/kernelconfig/#kernelconfig-building>8.5. Criando e Instalando um Kernel Customizado</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/kernelconfig/#kernelconfig-trouble>8.6. Se algo der errado</a></li></ul></li><li><input type=checkbox id=chapter-cb174c55879b17ab955f2f16989a79e0 class=toggle>
<label class="icon cursor" for=chapter-cb174c55879b17ab955f2f16989a79e0><a role=button></a></label><a href=https://docs.freebsd.org/pt-br/books/handbook/printing/>Capítulo 9. Impressão</a><ul><li><a href=https://docs.freebsd.org/pt-br/books/handbook/printing/#printing-quick-start>9.1. Inicio Rápido</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/printing/#printing-connections>9.2. Conexões de Impressora</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/printing/#printing-pdls>9.3. Linguagens de Descrição de Página Comuns</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/printing/#printing-direct>9.4. Impressão Direta</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/printing/#printing-lpd>9.5. LPD (Daemon de impressora de linha)</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/printing/#printing-other>9.6. Outros sistemas de impressão</a></li></ul></li><li><input type=checkbox id=chapter-c12b8c3f2a8fcefce87087241f695c83 class=toggle>
<label class="icon cursor" for=chapter-c12b8c3f2a8fcefce87087241f695c83><a role=button></a></label><a href=https://docs.freebsd.org/pt-br/books/handbook/linuxemu/>Capítulo 10. Compatibilidade binária com o Linux®</a><ul><li><a href=https://docs.freebsd.org/pt-br/books/handbook/linuxemu/#linuxemu-synopsis>10.1. Sinopse</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/linuxemu/#linuxemu-lbc-install>10.2. Configurando a compatibilidade binária com o Linux™</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/linuxemu/#linuxemu-advanced>10.3. Tópicos Avançados</a></li></ul></li><li><input type=checkbox id=chapter-03b11ba627b9a0c85b247f5641bde272 class=toggle>
<label for=chapter-03b11ba627b9a0c85b247f5641bde272><a role=button></a></label><a href=https://docs.freebsd.org/pt-br/books/handbook/partiii/>Parte III. Administração do Sistema</a></li><li><input type=checkbox id=chapter-6c31587f8d736319f099cd4dc1961301 class=toggle>
<label class="icon cursor" for=chapter-6c31587f8d736319f099cd4dc1961301><a role=button></a></label><a href=https://docs.freebsd.org/pt-br/books/handbook/config/>Capítulo 11. Configuração e Ajuste</a><ul><li><a href=https://docs.freebsd.org/pt-br/books/handbook/config/#config-synopsis>11.1. Sinopse</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/config/#configtuning-starting-services>11.2. Inicialização de Serviços</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/config/#configtuning-cron>11.3. Configurando o cron(8)</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/config/#configtuning-rcd>11.4. Gerenciando Serviços no FreeBSD</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/config/#config-network-setup>11.5. Configurando Placas de Interface de Rede</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/config/#configtuning-virtual-hosts>11.6. Hosts Virtuais</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/config/#configtuning-syslog>11.7. Configurando o log do sistema</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/config/#configtuning-configfiles>11.8. Arquivos de Configuração</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/config/#configtuning-sysctl>11.9. Efetuando ajustes com o sysctl(8)</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/config/#configtuning-disk>11.10. Otimização de Discos</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/config/#configtuning-kernel-limits>11.11. Ajustando os Limites do Kernel</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/config/#adding-swap-space>11.12. Adicionando Espaço de Swap</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/config/#acpi-overview>11.13. Gerenciamento de energia e recursos</a></li></ul></li><li><input type=checkbox id=chapter-459f0012b3b4f0b6b123010f029da5e4 class=toggle>
<label class="icon cursor" for=chapter-459f0012b3b4f0b6b123010f029da5e4><a role=button></a></label><a href=https://docs.freebsd.org/pt-br/books/handbook/boot/>Capítulo 12. O processo de inicialização do FreeBSD</a><ul><li><a href=https://docs.freebsd.org/pt-br/books/handbook/boot/#boot-synopsis>12.1. Sinopse</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/boot/#boot-introduction>12.2. Processo de Inicialização do FreeBSD</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/boot/#boot-splash>12.3. Configurando telas iniciais de inicialização</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/boot/#device-hints>12.4. Sugestões de dispositivos</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/boot/#boot-shutdown>12.5. Sequência de Desligamento</a></li></ul></li><li><input type=checkbox id=chapter-917c75fcffbb14d48ed6d0a48e7028f2 class=toggle>
<label class="icon cursor" for=chapter-917c75fcffbb14d48ed6d0a48e7028f2><a role=button></a></label><a href=https://docs.freebsd.org/pt-br/books/handbook/security/>Capítulo 13. Segurança</a><ul><li><a href=https://docs.freebsd.org/pt-br/books/handbook/security/#security-synopsis>13.1. Sinopse</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/security/#security-intro>13.2. Introdução</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/security/#one-time-passwords>13.3. Senhas de Uso Unico</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/security/#tcpwrappers>13.4. TCP Wrapper</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/security/#kerberos5>13.5. Kerberos</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/security/#openssl>13.6. OpenSSL</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/security/#ipsec>13.7. VPN Sobre IPsec</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/security/#openssh>13.8. OpenSSH</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/security/#fs-acl>13.9. Listas de Controle de Acesso</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/security/#security-pkg>13.10. Monitorando Problemas de Segurança de Terceiros</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/security/#security-advisories>13.11. Avisos de Segurança do FreeBSD</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/security/#security-accounting>13.12. Auditoria de Processo</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/security/#security-resourcelimits>13.13. Limites de Recursos</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/security/#security-sudo>13.14. Administração Compartilhada com Sudo</a></li></ul></li><li><input type=checkbox id=chapter-1a2a8e719703649c2c66d99aa7a25fd4 class=toggle>
<label class="icon cursor" for=chapter-1a2a8e719703649c2c66d99aa7a25fd4><a role=button></a></label><a href=https://docs.freebsd.org/pt-br/books/handbook/jails/>Capítulo 14. Jails</a><ul><li><a href=https://docs.freebsd.org/pt-br/books/handbook/jails/#jails-synopsis>14.1. Sinopse</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/jails/#jails-terms>14.2. Termos Relacionados à Jails</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/jails/#jails-build>14.3. Criando e Controlando Jails</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/jails/#jails-tuning>14.4. Tuning e Administração</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/jails/#jails-application>14.5. Atualizando Múltiplas Jails</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/jails/#jails-ezjail>14.6. Gerenciando Jails com o ezjail</a></li></ul></li><li><input type=checkbox id=chapter-8f4620c77e572cbb58917911a33c73cf class=toggle>
<label class="icon cursor" for=chapter-8f4620c77e572cbb58917911a33c73cf><a role=button></a></label><a href=https://docs.freebsd.org/pt-br/books/handbook/mac/>Capítulo 15. Controle de acesso obrigatório</a><ul><li><a href=https://docs.freebsd.org/pt-br/books/handbook/mac/#mac-synopsis>15.1. Sinopse</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/mac/#mac-inline-glossary>15.2. Termos chave</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/mac/#mac-understandlabel>15.3. Entendendo os rótulos MAC</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/mac/#mac-planning>15.4. Planejando a configuração de segurança</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/mac/#mac-policies>15.5. Políticas MAC Disponíveis</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/mac/#mac-userlocked>15.6. Bloqueio do Usuário</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/mac/#mac-implementing>15.7. Nagios em Jail MAC</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/mac/#mac-troubleshoot>15.8. Solução de problemas do framework MAC</a></li></ul></li><li><input type=checkbox id=chapter-9598d66a76cb3182057b6bcd775149a0 class=toggle>
<label class="icon cursor" for=chapter-9598d66a76cb3182057b6bcd775149a0><a role=button></a></label><a href=https://docs.freebsd.org/pt-br/books/handbook/audit/>Capítulo 16. Auditoria de Evento de Segurança</a><ul><li><a href=https://docs.freebsd.org/pt-br/books/handbook/audit/#audit-synopsis>16.1. Sinopse</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/audit/#audit-inline-glossary>16.2. Termos chave</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/audit/#audit-config>16.3. Configuração de Auditoria</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/audit/#audit-administration>16.4. Trabalhando com Trilhas de Auditoria</a></li></ul></li><li><input type=checkbox id=chapter-e1edcad13d9db6e8e4cb645d378ecfaf class=toggle checked>
<label class="icon cursor" for=chapter-e1edcad13d9db6e8e4cb645d378ecfaf><a role=button></a></label><a href=https://docs.freebsd.org/pt-br/books/handbook/disks/>Capítulo 17. Armazenamento</a><ul><li><a href=https://docs.freebsd.org/pt-br/books/handbook/disks/#disks-synopsis>17.1. Sinopse</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/disks/#disks-adding>17.2. Adicionando Discos</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/disks/#disks-growing>17.3. Redimensionando e Ampliando Discos</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/disks/#usb-disks>17.4. Dispositivos de Armazenamento USB</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/disks/#creating-cds>17.5. Criando e Usando Mídia em CD</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/disks/#creating-dvds>17.6. Criando e Usando Mídia de DVD</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/disks/#floppies>17.7. Criando e Usando Disquetes</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/disks/#backup-basics>17.8. Noções Básicas de Backup</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/disks/#disks-virtual>17.9. Discos de Memória</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/disks/#snapshots>17.10. Snapshots de Sistemas de Arquivos</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/disks/#quotas>17.11. Cotas de Disco</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/disks/#disks-encrypting>17.12. Criptografando Partições de Disco</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/disks/#swap-encrypting>17.13. Criptografando Swap</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/disks/#disks-hast>17.14. Alta Disponibilidade de Armazenamento (HAST)</a></li></ul></li><li><input type=checkbox id=chapter-dde37901a0e0ea32745b67607854900f class=toggle>
<label class="icon cursor" for=chapter-dde37901a0e0ea32745b67607854900f><a role=button></a></label><a href=https://docs.freebsd.org/pt-br/books/handbook/geom/>Capítulo 18. GEOM: Framework de Transformação de Disco Modular</a><ul><li><a href=https://docs.freebsd.org/pt-br/books/handbook/geom/#geom-synopsis>18.1. Sinopse</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/geom/#geom-striping>18.2. RAID0 - Striping</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/geom/#geom-mirror>18.3. RAID1 - Espelhamento</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/geom/#geom-raid3>18.4. RAID3 - Distribuição em Nível de Byte com Paridade Dedicada</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/geom/#geom-graid>18.5. Dispositivos RAID por Software</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/geom/#geom-ggate>18.6. GEOM Network Gate</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/geom/#geom-glabel>18.7. Rotulando Dispositivos de Disco</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/geom/#geom-gjournal>18.8. Journaling UFS através do GEOM</a></li></ul></li><li><input type=checkbox id=chapter-73e82560fcb7145b7c0e2ec47af8fc04 class=toggle>
<label class="icon cursor" for=chapter-73e82560fcb7145b7c0e2ec47af8fc04><a role=button></a></label><a href=https://docs.freebsd.org/pt-br/books/handbook/zfs/>Capítulo 19. O sistema de arquivos Z (ZFS)</a><ul><li><a href=https://docs.freebsd.org/pt-br/books/handbook/zfs/#zfs-differences>19.1. O que torna o ZFS diferente</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/zfs/#zfs-quickstart>19.2. Guia de Início Rápido</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/zfs/#zfs-zpool>19.3. Administração <code>zpool</code></a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/zfs/#zfs-zfs>19.4. Administração do <code>zfs</code></a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/zfs/#zfs-zfs-allow>19.5. Administração Delegada</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/zfs/#zfs-advanced>19.6. Tópicos Avançados</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/zfs/#zfs-links>19.7. Recursos adicionais</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/zfs/#zfs-term>19.8. Recursos e terminologia do ZFS</a></li></ul></li><li><input type=checkbox id=chapter-7af71270807eb7b70cd3eedc6577b254 class=toggle>
<label class="icon cursor" for=chapter-7af71270807eb7b70cd3eedc6577b254><a role=button></a></label><a href=https://docs.freebsd.org/pt-br/books/handbook/filesystems/>Capítulo 20. Outros Sistemas de Arquivos</a><ul><li><a href=https://docs.freebsd.org/pt-br/books/handbook/filesystems/#filesystems-synopsis>20.1. Sinopse</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/filesystems/#filesystems-linux>20.2. Sistemas de arquivos do Linux™</a></li></ul></li><li><input type=checkbox id=chapter-375257268d95faaf87faf4f7a2e6aa67 class=toggle>
<label class="icon cursor" for=chapter-375257268d95faaf87faf4f7a2e6aa67><a role=button></a></label><a href=https://docs.freebsd.org/pt-br/books/handbook/virtualization/>Capítulo 21. Virtualização</a><ul><li><a href=https://docs.freebsd.org/pt-br/books/handbook/virtualization/#virtualization-synopsis>21.1. Sinopse</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/virtualization/#virtualization-guest-parallels>21.2. FreeBSD como Sistema Operacional Convidado no Parallels para Mac OS™ X</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/virtualization/#virtualization-guest-virtualpc>21.3. FreeBSD como sistema convidado no Virtual PC para Windows™</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/virtualization/#virtualization-guest-vmware>21.4. FreeBSD como Sistema Operacional Convidado no VMware Fusion para Mac OS™</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/virtualization/#virtualization-guest-virtualbox>21.5. FreeBSD como Sistema Operacional Convidado no VirtualBox™</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/virtualization/#virtualization-host-virtualbox>21.6. FreeBSD como Host com VirtualBox™</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/virtualization/#virtualization-host-bhyve>21.7. FreeBSD como um Host bhyve</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/virtualization/#virtualization-host-xen>21.8. FreeBSD como Host Xen™</a></li></ul></li><li><input type=checkbox id=chapter-49f1e96591c090304ea532012257f4ef class=toggle>
<label class="icon cursor" for=chapter-49f1e96591c090304ea532012257f4ef><a role=button></a></label><a href=https://docs.freebsd.org/pt-br/books/handbook/l10n/>Capítulo 22. Localização - Uso e Configuração do i18n/L10n</a><ul><li><a href=https://docs.freebsd.org/pt-br/books/handbook/l10n/#l10n-synopsis>22.1. Sinopse</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/l10n/#using-localization>22.2. Usando Localização</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/l10n/#l10n-compiling>22.3. Encontrando Aplicações i18n</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/l10n/#lang-setup>22.4. Configuração de Localização para Idiomas Específicos</a></li></ul></li><li><input type=checkbox id=chapter-dead2b4c5ea325dd390a9b0dccd8f763 class=toggle>
<label class="icon cursor" for=chapter-dead2b4c5ea325dd390a9b0dccd8f763><a role=button></a></label><a href=https://docs.freebsd.org/pt-br/books/handbook/cutting-edge/>Capítulo 23. Atualização e Upgrade do FreeBSD</a><ul><li><a href=https://docs.freebsd.org/pt-br/books/handbook/cutting-edge/#updating-upgrading-synopsis>23.1. Sinopse</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/cutting-edge/#updating-upgrading-freebsdupdate>23.2. Atualização do FreeBSD</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/cutting-edge/#updating-upgrading-documentation>23.3. Atualizando o Conjunto de Documentação</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/cutting-edge/#current-stable>23.4. Acompanhando um ramo de desenvolvimento</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/cutting-edge/#makeworld>23.5. Atualizando o FreeBSD a partir do código fonte</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/cutting-edge/#small-lan>23.6. Atualização de várias máquinas</a></li></ul></li><li><input type=checkbox id=chapter-29c1eeb0e9dedc487a98399e2737ee8a class=toggle>
<label class="icon cursor" for=chapter-29c1eeb0e9dedc487a98399e2737ee8a><a role=button></a></label><a href=https://docs.freebsd.org/pt-br/books/handbook/dtrace/>Chapter 24. DTrace</a><ul><li><a href=https://docs.freebsd.org/pt-br/books/handbook/dtrace/#dtrace-synopsis>24.1. Sinopse</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/dtrace/#dtrace-implementation>24.2. Diferenças de Implementação</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/dtrace/#dtrace-enable>24.3. Ativando o Suporte do DTrace</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/dtrace/#dtrace-using>24.4. Usando o DTrace</a></li></ul></li><li><input type=checkbox id=chapter-913e72bfb3d6947b2869d3e9447a6eaa class=toggle>
<label class="icon cursor" for=chapter-913e72bfb3d6947b2869d3e9447a6eaa><a role=button></a></label><a href=https://docs.freebsd.org/pt-br/books/handbook/usb-device-mode/>Capítulo 25. Modo de dispositivo USB/USB OTG</a><ul><li><a href=https://docs.freebsd.org/pt-br/books/handbook/usb-device-mode/#usb-device-mode-synopsis>25.1. Sinopse</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/usb-device-mode/#usb-device-mode-terminals>25.2. Portas Seriais Virtuais USB</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/usb-device-mode/#usb-device-mode-network>25.3. Interfaces de rede do modo de dispositivo USB</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/usb-device-mode/#usb-device-mode-storage>25.4. Dispositivo de armazenamento virtual USB</a></li></ul></li><li><input type=checkbox id=chapter-bbd25f9a194f9c39ca2d658c75767db5 class=toggle>
<label for=chapter-bbd25f9a194f9c39ca2d658c75767db5><a role=button></a></label><a href=https://docs.freebsd.org/pt-br/books/handbook/partiv/>Parte IV. Comunicação de rede</a></li><li><input type=checkbox id=chapter-499dab596afd7ddac77e80295314e0dd class=toggle>
<label class="icon cursor" for=chapter-499dab596afd7ddac77e80295314e0dd><a role=button></a></label><a href=https://docs.freebsd.org/pt-br/books/handbook/serialcomms/>Capítulo 26. Comunicações Seriais</a><ul><li><a href=https://docs.freebsd.org/pt-br/books/handbook/serialcomms/#serial-synopsis>26.1. Sinopse</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/serialcomms/#serial>26.2. Terminologia serial e hardware</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/serialcomms/#term>26.3. Terminais</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/serialcomms/#dialup>26.4. Serviço Dial-in</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/serialcomms/#dialout>26.5. Serviço de Dial-in</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/serialcomms/#serialconsole-setup>26.6. Configurando o Console Serial</a></li></ul></li><li><input type=checkbox id=chapter-95e4571c48bee1cced5e84a538d302e3 class=toggle>
<label class="icon cursor" for=chapter-95e4571c48bee1cced5e84a538d302e3><a role=button></a></label><a href=https://docs.freebsd.org/pt-br/books/handbook/ppp-and-slip/>Capítulo 27. PPP</a><ul><li><a href=https://docs.freebsd.org/pt-br/books/handbook/ppp-and-slip/#ppp-and-slip-synopsis>27.1. Sinopse</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/ppp-and-slip/#userppp>27.2. Configurando o PPP</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/ppp-and-slip/#ppp-troubleshoot>27.3. Solução de problemas de conexões PPP</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/ppp-and-slip/#pppoe>27.4. Usando o PPP sobre Ethernet (PPPoE)</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/ppp-and-slip/#pppoa>27.5. Usando PPP sobre ATM (PPPoA)</a></li></ul></li><li><input type=checkbox id=chapter-f089ac726c401c9b4bd5c34a295e11bb class=toggle>
<label class="icon cursor" for=chapter-f089ac726c401c9b4bd5c34a295e11bb><a role=button></a></label><a href=https://docs.freebsd.org/pt-br/books/handbook/mail/>Capítulo 28. Correio Eletrônico</a><ul><li><a href=https://docs.freebsd.org/pt-br/books/handbook/mail/#mail-synopsis>28.1. Sinopse</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/mail/#mail-using>28.2. Componentes de Email</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/mail/#sendmail>28.3. Arquivos de Configuração do Sendmail</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/mail/#mail-changingmta>28.4. Alterando o Mail Transfer Agent</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/mail/#mail-trouble>28.5. Solução de problemas</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/mail/#mail-advanced>28.6. Tópicos Avançados</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/mail/#outgoing-only>28.7. Configurando Apenas Envio</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/mail/#SMTP-dialup>28.8. Usando Email com uma Conexão Dialup</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/mail/#SMTP-Auth>28.9. Autenticação SMTP</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/mail/#mail-agents>28.10. Mail User Agents</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/mail/#mail-fetchmail>28.11. Usando o fetchmail</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/mail/#mail-procmail>28.12. Usando o procmail</a></li></ul></li><li><input type=checkbox id=chapter-6de4de3fe925639d4175ce4b6f8c1829 class=toggle>
<label class="icon cursor" for=chapter-6de4de3fe925639d4175ce4b6f8c1829><a role=button></a></label><a href=https://docs.freebsd.org/pt-br/books/handbook/network-servers/>Capítulo 29. Servidores de Rede</a><ul><li><a href=https://docs.freebsd.org/pt-br/books/handbook/network-servers/#network-servers-synopsis>29.1. Sinopse</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/network-servers/#network-inetd>29.2. O super-servidor inetd</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/network-servers/#network-nfs>29.3. Network File System (NFS)</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/network-servers/#network-nis>29.4. Sistema de Informação de Rede (NIS)</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/network-servers/#network-ldap>29.5. Protocolo leve de acesso de diretório ( LDAP )</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/network-servers/#network-dhcp>29.6. Protocolo de configuração dinâmica de hosts (DHCP)</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/network-servers/#network-dns>29.7. Sistema de Nomes de Domínio (DNS)</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/network-servers/#network-apache>29.8. Servidor HTTP Apache</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/network-servers/#network-ftp>29.9. Protocolo de Transferência de Arquivos (FTP)</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/network-servers/#network-samba>29.10. Serviços de arquivos e impressão para clientes Microsoft™Windows™ Clients (Samba)</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/network-servers/#network-ntp>29.11. Sincronização de Relógio com NTP</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/network-servers/#network-iscsi>29.12. Inicializador iSCSI e Configuração Alvo</a></li></ul></li><li><input type=checkbox id=chapter-776d855c7b75e048f90b5c2c9b35ffe0 class=toggle>
<label class="icon cursor" for=chapter-776d855c7b75e048f90b5c2c9b35ffe0><a role=button></a></label><a href=https://docs.freebsd.org/pt-br/books/handbook/firewalls/>Capítulo 30. Firewalls</a><ul><li><a href=https://docs.freebsd.org/pt-br/books/handbook/firewalls/#firewalls-intro>30.1. Sinopse</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/firewalls/#firewalls-concepts>30.2. Conceitos de Firewall</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/firewalls/#firewalls-pf>30.3. PF</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/firewalls/#firewalls-ipfw>30.4. IPFW</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/firewalls/#firewalls-ipf>30.5. IPFILTER (IPF)</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/firewalls/#firewalls-blacklistd>30.6. Blacklistd</a></li></ul></li><li><input type=checkbox id=chapter-5b07f776a0e6155c1c89aa0d15610380 class=toggle>
<label class="icon cursor" for=chapter-5b07f776a0e6155c1c89aa0d15610380><a role=button></a></label><a href=https://docs.freebsd.org/pt-br/books/handbook/advanced-networking/>Capítulo 31. Rede Avançada</a><ul><li><a href=https://docs.freebsd.org/pt-br/books/handbook/advanced-networking/#advanced-networking-synopsis>31.1. Sinopse</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/advanced-networking/#network-routing>31.2. Gateways e Rotas</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/advanced-networking/#network-wireless>31.3. Rede sem fio</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/advanced-networking/#network-usb-tethering>31.4. USB Tethering</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/advanced-networking/#network-bluetooth>31.5. Bluetooth</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/advanced-networking/#network-bridging>31.6. Bridging</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/advanced-networking/#network-aggregation>31.7. Agregação de links e failover</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/advanced-networking/#network-diskless>31.8. Operação Diskless com PXE</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/advanced-networking/#network-ipv6>31.9. IPv6</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/advanced-networking/#carp>31.10. Protocolo Comum de Redundância de Endereços (CARP)</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/advanced-networking/#network-vlan>31.11. VLANs</a></li></ul></li><li><input type=checkbox id=chapter-171a77aa9d067a1024f849470e1f33e8 class=toggle>
<label for=chapter-171a77aa9d067a1024f849470e1f33e8><a role=button></a></label><a href=https://docs.freebsd.org/pt-br/books/handbook/partv/>Parte V. Apêndices</a></li><li><input type=checkbox id=chapter-8050f436a0a7986a4aaded93d8e49469 class=toggle>
<label class="icon cursor" for=chapter-8050f436a0a7986a4aaded93d8e49469><a role=button></a></label><a href=https://docs.freebsd.org/pt-br/books/handbook/mirrors/>Apêndice A. Obtendo o FreeBSD</a><ul><li><a href=https://docs.freebsd.org/pt-br/books/handbook/mirrors/#mirrors-cdrom>A.1. CD and DVD Sets</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/mirrors/#mirrors-ftp>A.2. Sites de FTP</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/mirrors/#svn>A.3. Usando o Subversion</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/mirrors/#mirrors-rsync>A.4. Usando o rsync</a></li></ul></li><li><input type=checkbox id=chapter-128b630a8f88f158e7027fe6c2184d21 class=toggle>
<label class="icon cursor" for=chapter-128b630a8f88f158e7027fe6c2184d21><a role=button></a></label><a href=https://docs.freebsd.org/pt-br/books/handbook/bibliography/>Apêndice B. Bibliografia</a><ul><li><a href=https://docs.freebsd.org/pt-br/books/handbook/bibliography/#bibliography-freebsd>B.1. Livros específicos para o FreeBSD</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/bibliography/#bibliography-userguides>B.2. Guias de usuários</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/bibliography/#bibliography-adminguides>B.3. Guias de Administradores</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/bibliography/#bibliography-programmers>B.4. Guias de programadores</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/bibliography/#bibliography-osinternals>B.5. Internals do sistema operacional</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/bibliography/#bibliography-security>B.6. Referências de segurança</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/bibliography/#bibliography-hardware>B.7. Referências de Hardware</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/bibliography/#bibliography-history>B.8. História do UNIX™</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/bibliography/#bibliography-journals>B.9. Periódicos, Jornais e Revistas</a></li></ul></li><li><input type=checkbox id=chapter-8bbb8867c46dac315e2253945d8c18a8 class=toggle>
<label class="icon cursor" for=chapter-8bbb8867c46dac315e2253945d8c18a8><a role=button></a></label><a href=https://docs.freebsd.org/pt-br/books/handbook/eresources/>Apêndice C. Recursos na Internet</a><ul><li><a href=https://docs.freebsd.org/pt-br/books/handbook/eresources/#eresources-www>C.1. Websites</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/eresources/#eresources-mail>C.2. Listas de Discussão</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/eresources/#eresources-news>C.3. Grupos de Notícias Usenet</a></li><li><a href=https://docs.freebsd.org/pt-br/books/handbook/eresources/#eresources-web>C.4. Espelhos Oficiais</a></li></ul></li><li><input type=checkbox id=chapter-a80ea4f5a4480b8725422710f954ef36 class=toggle>
<label class="icon cursor" for=chapter-a80ea4f5a4480b8725422710f954ef36><a role=button></a></label><a href=https://docs.freebsd.org/pt-br/books/handbook/pgpkeys/>Apêndice D. Chaves OpenPGP</a><ul><li><a href=https://docs.freebsd.org/pt-br/books/handbook/pgpkeys/#pgpkeys-officers>D.1. Administradores</a></li></ul></li><li></li></ul></nav></div></aside><div class=book><div class=book-menu-mobile><label for=menu-control><span class=menu-control-button><i class="fa fa-list" aria-hidden=true title=Menu></i>
Menu</span></label></div><h1 class=title>Capítulo 17. Armazenamento</h1><div class="admonitionblock note"><p><i class="fa fa-exclamation-circle" aria-hidden=true></i>
Esta tradução pode estar desatualizada. Para ajudar com as traduções, acesse a <a href=https://translate-dev.freebsd.org/ target=_blank>ferramenta de traduções do FreeBSD</a>.</p></div><div class=toc-mobile><h3>Índice</h3><nav id=TableOfContents><ul><li><a href=#disks-synopsis>17.1. Sinopse</a></li><li><a href=#disks-adding>17.2. Adicionando Discos</a></li><li><a href=#disks-growing>17.3. Redimensionando e Ampliando Discos</a></li><li><a href=#usb-disks>17.4. Dispositivos de Armazenamento USB</a></li><li><a href=#creating-cds>17.5. Criando e Usando Mídia em CD</a></li><li><a href=#creating-dvds>17.6. Criando e Usando Mídia de DVD</a></li><li><a href=#floppies>17.7. Criando e Usando Disquetes</a></li><li><a href=#backup-basics>17.8. Noções Básicas de Backup</a></li><li><a href=#disks-virtual>17.9. Discos de Memória</a></li><li><a href=#snapshots>17.10. Snapshots de Sistemas de Arquivos</a></li><li><a href=#quotas>17.11. Cotas de Disco</a></li><li><a href=#disks-encrypting>17.12. Criptografando Partições de Disco</a></li><li><a href=#swap-encrypting>17.13. Criptografando Swap</a></li><li><a href=#disks-hast>17.14. Alta Disponibilidade de Armazenamento (HAST)</a></li></ul></nav></div><div class=book-content><div id=preamble><div class=sectionbody></div></div><div class=sect1><h2 id=disks-synopsis>17.1. Sinopse<a class=anchor href=#disks-synopsis></a></h2><div class=sectionbody><div class=paragraph><p>Este capítulo aborda o uso de discos e mídia de armazenamento no FreeBSD. Isso inclui discos SCSI e IDE, mídias de CD e DVD, discos com suporte de memória e dispositivos de armazenamento USB.</p></div><div class=paragraph><p>Depois de ler este capítulo, você saberá:</p></div><div class=ulist><ul><li><p>Como adicionar discos rígidos adicionais a um sistema FreeBSD.</p></li><li><p>Como aumentar o tamanho da partição de um disco no FreeBSD.</p></li><li><p>Como configurar o FreeBSD para usar dispositivos de armazenamento USB.</p></li><li><p>Como usar mídias de CD e DVD em um sistema FreeBSD.</p></li><li><p>Como usar os programas de backup disponíveis no FreeBSD.</p></li><li><p>Como configurar discos de memória.</p></li><li><p>O que são snapshots de sistema de arquivos e como usá-los com eficiência.</p></li><li><p>Como usar cotas para limitar o uso de espaço em disco.</p></li><li><p>Como criptografar discos e swap para protegê-los contra invasores.</p></li><li><p>Como configurar uma rede de armazenamento altamente disponível.</p></li></ul></div><div class=paragraph><p>Antes de ler este capítulo, você deve:</p></div><div class=ulist><ul><li><p>Saiba como <a href=../kernelconfig/#kernelconfig>configurar e instalar um novo kernel do FreeBSD</a>.</p></li></ul></div></div></div><div class=sect1><h2 id=disks-adding>17.2. Adicionando Discos<a class=anchor href=#disks-adding></a></h2><div class=sectionbody><div class=paragraph><p>Esta seção descreve como adicionar um novo disco SATA a uma máquina que atualmente possui apenas uma única unidade. Primeiro, desligue o computador e instale a unidade no computador seguindo as instruções do fabricante do computador, controladora e unidade. Reinicialize o sistema e torne-se <code>root</code>.</p></div><div class=paragraph><p>Inspecione o arquivo <span class=filename>/var/run/dmesg.boot</span> para garantir que o novo disco foi encontrado. Neste exemplo, a unidade SATA recém-adicionada aparecerá como <span class=filename>ada1</span>.</p></div><div class=paragraph><p>Para este exemplo, uma única partição grande será criada no novo disco. O esquema de particionamento <a href=http://en.wikipedia.org/wiki/GUID_Partition_Table>GPT</a> será usado ao invés do esquema MBR, mais antigo e menos versátil.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Se o disco a ser adicionado não estiver em branco, as informações antigas da partição podem ser removidas com <code>gpart delete</code>. Veja <a href="https://man.freebsd.org/cgi/man.cgi?query=gpart&amp;sektion=8&amp;format=html">gpart(8)</a> para detalhes.</p></div></td></tr></tbody></table></div><div class=paragraph><p>O esquema de partição é criado e, em seguida, uma única partição é adicionada. Para melhorar o desempenho em discos mais recentes com tamanhos maiores de blocos de hardware, a partição está alinhada a divisões de um megabyte:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gpart create -s GPT ada1</span>
<span class=c># gpart add -t freebsd-ufs -a 1M ada1</span></code></pre></div></div><div class=paragraph><p>Dependendo do uso, várias partições menores podem ser desejadas. Veja <a href="https://man.freebsd.org/cgi/man.cgi?query=gpart&amp;sektion=8&amp;format=html">gpart(8)</a> para opções para criar partições menores que um disco inteiro.</p></div><div class=paragraph><p>As informações da partição de disco podem ser visualizadas com <code>gpart show</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% gpart show ada1
<span class=o>=&gt;</span>        34  1465146988  ada1  GPT  <span class=o>(</span>699G<span class=o>)</span>
          34        2014        - free -  <span class=o>(</span>1.0M<span class=o>)</span>
        2048  1465143296     1  freebsd-ufs  <span class=o>(</span>699G<span class=o>)</span>
  1465145344        1678        - free -  <span class=o>(</span>839K<span class=o>)</span></code></pre></div></div><div class=paragraph><p>Um sistema de arquivos é criado em uma nova partição no novo disco:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># newfs -U /dev/ada1p1</span></code></pre></div></div><div class=paragraph><p>Um diretório vazio é criado como um <em>ponto de montagem</em>, um local para montar o novo disco no sistema de arquivos do disco original:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mkdir /newdisk</span></code></pre></div></div><div class=paragraph><p>Finalmente, uma entrada é adicionada ao arquivo <span class=filename>/etc/fstab</span> para que o novo disco seja montado automaticamente na inicialização:</p></div><div class="literalblock programlisting"><div class=content><pre>/dev/ada1p1	/newdisk	ufs	rw	2	2</pre></div></div><div class=paragraph><p>O novo disco pode ser montado manualmente, sem reiniciar o sistema:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount /newdisk</span></code></pre></div></div></div></div><div class=sect1><h2 id=disks-growing>17.3. Redimensionando e Ampliando Discos<a class=anchor href=#disks-growing></a></h2><div class=sectionbody><div class=paragraph><p>A capacidade de um disco pode aumentar sem alterações nos dados já presentes. Isso acontece normalmente com máquinas virtuais, quando o disco virtual torna-se muito pequeno e é ampliado. Às vezes, uma imagem de disco é gravada em um cartão de memória USB, mas não usa toda a capacidade. Aqui nós descrevemos como redimensionar ou <em>ampliar</em> o conteúdo do disco para aproveitar a capacidade aumentada.</p></div><div class=paragraph><p>Determine o nome do dispositivo do disco a ser redimensionado inspecionando o arquivo <span class=filename>/var/run/dmesg.boot</span>. Neste exemplo, há apenas um disco SATA no sistema, portanto a unidade aparecerá como <span class=filename>ada0</span>.</p></div><div class=paragraph><p>Liste as partições no disco para ver a configuração atual:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gpart show ada0</span>
<span class=o>=&gt;</span>      34  83886013  ada0  GPT  <span class=o>(</span>48G<span class=o>)</span> <span class=o>[</span>CORRUPT]
        34       128     1  freebsd-boot  <span class=o>(</span>64k<span class=o>)</span>
       162  79691648     2  freebsd-ufs  <span class=o>(</span>38G<span class=o>)</span>
  79691810   4194236     3  freebsd-swap  <span class=o>(</span>2G<span class=o>)</span>
  83886046         1        - free -  <span class=o>(</span>512B<span class=o>)</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Se o disco foi formatado com o esquema de particionamento <a href=http://en.wikipedia.org/wiki/GUID_Partition_Table>GPT</a>, ele pode ser exibido como "corrompido" porque a tabela de partições de backup GPT não está mais no final da unidade. Corrija a tabela de partições de backup com o <code>gpart</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gpart recover ada0</span>
ada0 recovered</code></pre></div></div></td></tr></tbody></table></div><div class=paragraph><p>Agora, o espaço adicional no disco está disponível para uso por uma nova partição ou uma partição existente pode ser expandida:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gpart show ada0</span>
<span class=o>=&gt;</span>       34  102399933  ada0  GPT  <span class=o>(</span>48G<span class=o>)</span>
         34        128     1  freebsd-boot  <span class=o>(</span>64k<span class=o>)</span>
        162   79691648     2  freebsd-ufs  <span class=o>(</span>38G<span class=o>)</span>
   79691810    4194236     3  freebsd-swap  <span class=o>(</span>2G<span class=o>)</span>
   83886046   18513921        - free -  <span class=o>(</span>8.8G<span class=o>)</span></code></pre></div></div><div class=paragraph><p>As partições só podem ser redimensionadas para um espaço livre contíguo. Aqui, a última partição no disco é a partição swap, mas a segunda partição é aquela que precisa ser redimensionada. As partições de Swap contêm apenas dados temporários, portanto, podem ser desmontadas, excluídas e, em seguida, recriadas a terceira partição após redimensionar a segunda partição.</p></div><div class=paragraph><p>Desative a partição de swap:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># swapoff /dev/ada0p3</span></code></pre></div></div><div class=paragraph><p>Exclua a terceira partição, especificada pela flag <code>-i</code>, do disco <em>ada0</em>.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gpart delete -i 3 ada0</span>
ada0p3 deleted
<span class=c># gpart show ada0</span>
<span class=o>=&gt;</span>       34  102399933  ada0  GPT  <span class=o>(</span>48G<span class=o>)</span>
         34        128     1  freebsd-boot  <span class=o>(</span>64k<span class=o>)</span>
        162   79691648     2  freebsd-ufs  <span class=o>(</span>38G<span class=o>)</span>
   79691810   22708157        - free -  <span class=o>(</span>10G<span class=o>)</span></code></pre></div></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Existe o risco de perda de dados ao modificar a tabela de partições de um sistema de arquivos montado. É melhor executar as etapas a seguir em um sistema de arquivos desmontado durante a execução de um dispositivo CD-ROM ou USB live. No entanto, se for absolutamente necessário, um sistema de arquivos montado pode ser redimensionado depois de desativar os recursos de segurança do GEOM:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl kern.geom.debugflags=16</span></code></pre></div></div></td></tr></tbody></table></div><div class=paragraph><p>Redimensione a partição, deixando espaço para recriar uma partição swap do tamanho desejado. A partição a ser redimensionada é especificada com <code>-i</code> e o novo tamanho desejado com <code>-s</code>. Opcionalmente, o alinhamento da partição é controlado com <code>-a</code>. Isso só modifica o tamanho da partição. O sistema de arquivos na partição será expandido em uma etapa separada.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gpart resize -i 2 -s 47G -a 4k ada0</span>
ada0p2 resized
<span class=c># gpart show ada0</span>
<span class=o>=&gt;</span>       34  102399933  ada0  GPT  <span class=o>(</span>48G<span class=o>)</span>
         34        128     1  freebsd-boot  <span class=o>(</span>64k<span class=o>)</span>
        162   98566144     2  freebsd-ufs  <span class=o>(</span>47G<span class=o>)</span>
   98566306    3833661        - free -  <span class=o>(</span>1.8G<span class=o>)</span></code></pre></div></div><div class=paragraph><p>Recrie a partição swap e ative-a. Se nenhum tamanho for especificado com <code>-s</code>, todo o espaço restante será usado:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gpart add -t freebsd-swap -a 4k ada0</span>
ada0p3 added
<span class=c># gpart show ada0</span>
<span class=o>=&gt;</span>       34  102399933  ada0  GPT  <span class=o>(</span>48G<span class=o>)</span>
         34        128     1  freebsd-boot  <span class=o>(</span>64k<span class=o>)</span>
        162   98566144     2  freebsd-ufs  <span class=o>(</span>47G<span class=o>)</span>
   98566306    3833661     3  freebsd-swap  <span class=o>(</span>1.8G<span class=o>)</span>
<span class=c># swapon /dev/ada0p3</span></code></pre></div></div><div class=paragraph><p>Aumente o sistema de arquivos UFS para usar a nova capacidade da partição redimensionada:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># growfs /dev/ada0p2</span>
Device is mounted read-write<span class=p>;</span> resizing will result <span class=k>in </span>temporary write suspension <span class=k>for</span> /.
It<span class=s1>&#39;s strongly recommended to make a backup before growing the file system.
OK to grow file system on /dev/ada0p2, mounted on /, from 38GB to 47GB? [Yes/No] Yes
super-block backups (for fsck -b #) at:
 80781312, 82063552, 83345792, 84628032, 85910272, 87192512, 88474752,
 89756992, 91039232, 92321472, 93603712, 94885952, 96168192, 97450432</span></code></pre></div></div><div class=paragraph><p>Se o sistema de arquivos for ZFS, o redimensionamento será acionado pela execução do subcomando <code>online</code> com <code>-e</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># zpool online -e zroot /dev/ada0p2</span></code></pre></div></div><div class=paragraph><p>Tanto a partição quanto o sistema de arquivos foram redimensionados para usar o espaço em disco recém-disponível.</p></div></div></div><div class=sect1><h2 id=usb-disks>17.4. Dispositivos de Armazenamento USB<a class=anchor href=#usb-disks></a></h2><div class=sectionbody><div class=paragraph><p>Muitas soluções de armazenamento externo, como discos rígidos, thumbdrives USB e gravadores de CD e DVD, usam o Universal Serial Bus ( USB ). O FreeBSD fornece suporte para dispositivos USB 1.x, 2.0 e 3.0.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>O suporte a USB 3.0 não é compatível com alguns hardwares, incluindo os chipsets Haswell (Lynx Point). Se o FreeBSD inicializar com uma mensagem <code>falhou com erro 19</code>, desative xHCI/USB3 na BIOS.</p></div></td></tr></tbody></table></div><div class=paragraph><p>O suporte para dispositivos de armazenamento USB é embutido no kernel <span class=filename>GENERIC</span>. Para um kernel personalizado, certifique-se de que as seguintes linhas estejam presentes no arquivo de configuração do kernel:</p></div><div class="literalblock programlisting"><div class=content><pre>device scbus	# SCSI bus (required for ATA/SCSI)
device da	# Direct Access (disks)
device pass	# Passthrough device (direct ATA/SCSI access)
device uhci	# provides USB 1.x support
device ohci	# provides USB 1.x support
device ehci	# provides USB 2.0 support
device xhci	# provides USB 3.0 support
device usb	# USB Bus (required)
device umass	# Disks/Mass storage - Requires scbus and da
device cd	# needed for CD and DVD burners</pre></div></div><div class=paragraph><p>O FreeBSD usa o driver <a href="https://man.freebsd.org/cgi/man.cgi?query=umass&amp;sektion=4&amp;format=html">umass(4)</a> que usa o subsistema SCSI para acessar o armazenamento de dispositivos USB. Como qualquer dispositivo USB será visto como um dispositivo SCSI pelo sistema, se o dispositivo USB for um gravador de CD ou DVD, <em>não</em> inclua <code>device atapicam</code> em um arquivo de configuração do kernel personalizado.</p></div><div class=paragraph><p>O restante desta seção demonstra como verificar se um dispositivo de armazenamento USB é reconhecido pelo FreeBSD e como configurar o dispositivo para que ele possa ser usado.</p></div><div class=sect2><h3 id=_configuração_de_dispositivo>17.4.1. Configuração de Dispositivo<a class=anchor href=#_configuração_de_dispositivo></a></h3><div class=paragraph><p>Para testar a configuração USB, conecte o dispositivo USB. Use <code>dmesg</code> para confirmar que a unidade aparece no buffer de mensagens do sistema. Deve parecer algo como isto:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>umass0: &lt;STECH Simple Drive, class 0/0, rev 2.00/1.04, addr 3&gt; on usbus0
umass0:  SCSI over Bulk-Only<span class=p>;</span> quirks <span class=o>=</span> 0x0100
umass0:4:0:-1: Attached to scbus4
da0 at umass-sim0 bus 0 scbus4 target 0 lun 0
da0: &lt;STECH Simple Drive 1.04&gt; Fixed Direct Access SCSI-4 device
da0: Serial Number WD-WXE508CAN263
da0: 40.000MB/s transfers
da0: 152627MB <span class=o>(</span>312581808 512 byte sectors: 255H 63S/T 19457C<span class=o>)</span>
da0: <span class=nv>quirks</span><span class=o>=</span>0x2&lt;NO_6_BYTE&gt;</code></pre></div></div><div class=paragraph><p>A marca, o nó de dispositivo (<span class=filename>da0</span>), a velocidade e o tamanho serão diferentes de acordo com o dispositivo.</p></div><div class=paragraph><p>Como o dispositivo USB é visto como um SCSI, o <code>camcontrol</code> pode ser usado para listar os dispositivos de armazenamento USB conectados ao sistema:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># camcontrol devlist</span>
&lt;STECH Simple Drive 1.04&gt;          at scbus4 target 0 lun 0 <span class=o>(</span>pass3,da0<span class=o>)</span></code></pre></div></div><div class=paragraph><p>Alternativamente, o <code>usbconfig</code> pode ser usado para listar o dispositivo. Consulte o <a href="https://man.freebsd.org/cgi/man.cgi?query=usbconfig&amp;sektion=8&amp;format=html">usbconfig(8)</a> para obter mais informações sobre este comando.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># usbconfig</span>
ugen0.3: &lt;Simple Drive STECH&gt; at usbus0, <span class=nv>cfg</span><span class=o>=</span>0 <span class=nv>md</span><span class=o>=</span>HOST <span class=nv>spd</span><span class=o>=</span>HIGH <span class=o>(</span>480Mbps<span class=o>)</span> <span class=nv>pwr</span><span class=o>=</span>ON <span class=o>(</span>2mA<span class=o>)</span></code></pre></div></div><div class=paragraph><p>Se o dispositivo não tiver sido formatado, consulte <a href=#disks-adding>Adicionando Discos</a> para obter instruções sobre como formatar e criar partições na unidade USB. Se a unidade vier com um sistema de arquivos, ela pode ser montada pelo <code>root</code> usando as instruções em <a href=../basics/#mount-unmount>Montando e Desmontando Sistemas de Arquivos</a>.</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Permitir que usuários não confiáveis montem mídia arbitrária, ativando <code>vfs.usermount</code> como descrito abaixo, não deve ser considerado seguro do ponto de vista da segurança. A maioria dos sistemas de arquivos não foi criada para proteger contra dispositivos maliciosos.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Para tornar o dispositivo montável como um usuário normal, uma solução é tornar todos os usuários do dispositivo membros do grupo <code>operator</code> usando <a href="https://man.freebsd.org/cgi/man.cgi?query=pw&amp;sektion=8&amp;format=html">pw(8)</a>. Em seguida, certifique-se de que <code>operator</code> possa ler e gravar o dispositivo adicionando estas linhas ao <span class=filename>/etc/devfs.rules</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>[localrules=5]
add path &#39;da*&#39; mode 0660 group operator</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Se discos internos SCSI também estiverem instalados no sistema, altere a segunda linha da seguinte maneira:</p></div><div class="literalblock programlisting"><div class=content><pre>add path &#39;da[3-9]*&#39; mode 0660 group operator</pre></div></div><div class=paragraph><p>Isso excluirá os três primeiros discos SCSI (<span class=filename>da0</span> para <span class=filename>da2</span>) pertencentes ao grupo <code>operator</code>. Substitua <em>3</em> pelo número de discos SCSI internos. Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=devfs.rules&amp;sektion=5&amp;format=html">devfs.rules(5)</a> para obter mais informações sobre esse arquivo.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Em seguida, ative o conjunto de regras no arquivo <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>devfs_system_ruleset=&#34;localrules&#34;</pre></div></div><div class=paragraph><p>Em seguida, instrua o sistema para permitir que usuários comuns montem sistemas de arquivos incluindo a seguinte linha no arquivo <span class=filename>/etc/sysctl.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>vfs.usermount=1</pre></div></div><div class=paragraph><p>Como isso só entra em vigor após a próxima reinicialização, use <code>sysctl</code> para definir essa variável agora:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl vfs.usermount=1</span>
vfs.usermount: 0 -&gt; 1</code></pre></div></div><div class=paragraph><p>A etapa final é criar um diretório no qual o sistema de arquivos deve ser montado. Esse diretório precisa pertencer ao usuário que deve montar o sistema de arquivos. Uma maneira de fazer isso é para o <code>root</code> criar um subdiretório de propriedade daquele usuário como <span class=filename>/mnt/username</span>. No exemplo a seguir, substitua <em>username</em> pelo nome de login do usuário e <em>usergroup</em> pelo grupo principal do usuário:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mkdir /mnt/username</span>
<span class=c># chown username:usergroup /mnt/username</span></code></pre></div></div><div class=paragraph><p>Suponha que um thumbdrive USB esteja conectado e um dispositivo <span class=filename>/dev/da0s1</span> apareça. Se o dispositivo estiver formatado com um sistema de arquivos FAT, o usuário poderá montá-lo usando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% mount <span class=nt>-t</span> msdosfs <span class=nt>-o</span> <span class=nt>-m</span><span class=o>=</span>644,-M<span class=o>=</span>755 /dev/da0s1 /mnt/username</code></pre></div></div><div class=paragraph><p>Antes que o dispositivo possa ser desconectado, ele <em>deve</em> ser desmontado primeiro:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% umount /mnt/username</code></pre></div></div><div class=paragraph><p>Após a remoção do dispositivo, o buffer de mensagens do sistema mostrará mensagens semelhantes às seguintes:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>umass0: at uhub3, port 2, addr 3 <span class=o>(</span>disconnected<span class=o>)</span>
da0 at umass-sim0 bus 0 scbus4 target 0 lun 0
da0: &lt;STECH Simple Drive 1.04&gt; s/n WD-WXE508CAN263          detached
<span class=o>(</span>da0:umass-sim0:0:0:0<span class=o>)</span>: Periph destroyed</code></pre></div></div></div><div class=sect2><h3 id=_montando_automaticamente_uma_mídia_removível>17.4.2. Montando Automaticamente Uma Mídia Removível<a class=anchor href=#_montando_automaticamente_uma_mídia_removível></a></h3><div class=paragraph><p>Dispositivos USB podem ser montados automaticamente removendo o comentário desta linha no arquivo <span class=filename>/etc/auto_master</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>/media		<span class=nt>-media</span>		<span class=nt>-nosuid</span></code></pre></div></div><div class=paragraph><p>Então adicione estas linhas ao arquivo <span class=filename>/etc/devd.conf</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>notify 100 <span class=o>{</span>
	match <span class=s2>&#34;system&#34;</span> <span class=s2>&#34;GEOM&#34;</span><span class=p>;</span>
	match <span class=s2>&#34;subsystem&#34;</span> <span class=s2>&#34;DEV&#34;</span><span class=p>;</span>
	action <span class=s2>&#34;/usr/sbin/automount -c&#34;</span><span class=p>;</span>
<span class=o>}</span><span class=p>;</span></code></pre></div></div><div class=paragraph><p>Recarregue a configuração se <a href="https://man.freebsd.org/cgi/man.cgi?query=autofs&amp;sektion=5&amp;format=html">autofs(5)</a> e <a href="https://man.freebsd.org/cgi/man.cgi?query=devd&amp;sektion=8&amp;format=html">devd(8)</a> já estiverem em execução:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service automount restart</span>
<span class=c># service devd restart</span></code></pre></div></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=autofs&amp;sektion=5&amp;format=html">autofs(5)</a> pode ser configurado para iniciar no boot, adicionando esta linha ao arquivo <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>autofs_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=autofs&amp;sektion=5&amp;format=html">autofs(5)</a> requer que o <a href="https://man.freebsd.org/cgi/man.cgi?query=devd&amp;sektion=8&amp;format=html">devd(8)</a> esteja ativado, como é por padrão.</p></div><div class=paragraph><p>Inicie os serviços imediatamente com:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service automount start</span>
<span class=c># service automountd start</span>
<span class=c># service autounmountd start</span>
<span class=c># service devd start</span></code></pre></div></div><div class=paragraph><p>Cada sistema de arquivos que pode ser montado automaticamente aparece como um diretório em <span class=filename>/media/</span>. O diretório é nomeado após o rótulo do sistema de arquivos. Se o rótulo estiver ausente, o diretório será nomeado após o nó do dispositivo.</p></div><div class=paragraph><p>O sistema de arquivos é montado de forma transparente no primeiro acesso e desmontado após um período de inatividade. Unidades montadas automaticamente também podem ser desmontadas manualmente:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># automount -fu</span></code></pre></div></div><div class=paragraph><p>Este mecanismo é normalmente usado para cartões de memória e cartões de memória USB. Pode ser usado com qualquer dispositivo de bloco, incluindo unidades ópticas ou iSCSILUNs.</p></div></div></div></div><div class=sect1><h2 id=creating-cds>17.5. Criando e Usando Mídia em CD<a class=anchor href=#creating-cds></a></h2><div class=sectionbody><div class=paragraph><p>A mídia em disco compacto (CD) fornece vários recursos que os diferenciam dos discos convencionais. Eles são projetados para que possam ser lidos continuamente sem atrasos para mover a cabeça entre as trilhas. Embora a mídia CD tenha faixas, elas se referem a uma seção de dados a ser lida continuamente e não a uma propriedade física do disco. O sistema de arquivos ISO 9660 foi projetado para lidar com essas diferenças.</p></div><div class=paragraph><p>A Coleção de Ports do FreeBSD fornece vários utilitários para gravar e duplicar áudio e dados de CDs. Este capítulo demonstra o uso de vários utilitários de linha de comando. Para o software de gravação de CD com um utilitário gráfico, considere instalar os pacotes ou ports <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/xcdroast/>sysutils/xcdroast</a> ou <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/k3b/>sysutils/k3b</a>.</p></div><div class=sect2><h3 id=atapicam>17.5.1. Dispositivos Suportados<a class=anchor href=#atapicam></a></h3><div class=paragraph><p>O kernel <span class=filename>GENERIC</span> fornece suporte para SCSI, USB, e leitores e gravadores de CDATAPI. Se um kernel personalizado for usado, as opções que precisam estar presentes no arquivo de configuração do kernel variam de acordo com o tipo de dispositivo.</p></div><div class=paragraph><p>Para um gravador SCSI, verifique se essas opções estão presentes:</p></div><div class="literalblock programlisting"><div class=content><pre>device scbus	# SCSI bus (required for ATA/SCSI)
device da	# Direct Access (disks)
device pass	# Passthrough device (direct ATA/SCSI access)
device cd	# needed for CD and DVD burners</pre></div></div><div class=paragraph><p>Para um gravador de USB, verifique se essas opções estão presentes:</p></div><div class="literalblock programlisting"><div class=content><pre>device scbus	# SCSI bus (required for ATA/SCSI)
device da	# Direct Access (disks)
device pass	# Passthrough device (direct ATA/SCSI access)
device cd	# needed for CD and DVD burners
device uhci	# provides USB 1.x support
device ohci	# provides USB 1.x support
device ehci	# provides USB 2.0 support
device xhci	# provides USB 3.0 support
device usb	# USB Bus (required)
device umass	# Disks/Mass storage - Requires scbus and da</pre></div></div><div class=paragraph><p>Para um gravador ATAPI, verifique se essas opções estão presentes:</p></div><div class="literalblock programlisting"><div class=content><pre>device ata	# Legacy ATA/SATA controllers
device scbus	# SCSI bus (required for ATA/SCSI)
device pass	# Passthrough device (direct ATA/SCSI access)
device cd	# needed for CD and DVD burners</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Nas versões do FreeBSD anteriores a 10.x, esta linha também é necessária no arquivo de configuração do kernel se o gravador for um dispositivo ATAPI:</p></div><div class="literalblock programlisting"><div class=content><pre>device atapicam</pre></div></div><div class=paragraph><p>Como alternativa, esse driver pode ser carregado no momento da inicialização adicionando a seguinte linha ao arquivo <span class=filename>/boot/loader.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>atapicam_load=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Isso exigirá uma reinicialização do sistema, pois esse driver só pode ser carregado no momento da inicialização.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Para verificar se o FreeBSD reconhece o dispositivo, execute o <code>dmesg</code> e procure por uma entrada para o dispositivo. Nos sistemas anteriores a 10.x, o nome do dispositivo na primeira linha da saída será <span class=filename>acd0</span> em vez de <span class=filename>cd0</span>.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% dmesg | <span class=nb>grep cd
</span>cd0 at ahcich1 bus 0 scbus1 target 0 lun 0
cd0: &lt;HL-DT-ST DVDRAM GU70N LT20&gt; Removable CD-ROM SCSI-0 device
cd0: Serial Number M3OD3S34152
cd0: 150.000MB/s transfers <span class=o>(</span>SATA 1.x, UDMA6, ATAPI 12bytes, PIO 8192bytes<span class=o>)</span>
cd0: Attempt to query device size failed: NOT READY, Medium not present - tray closed</code></pre></div></div></div><div class=sect2><h3 id=cdrecord>17.5.2. Gravando um CD<a class=anchor href=#cdrecord></a></h3><div class=paragraph><p>No FreeBSD, <code>cdrecord</code> pode ser usado para gravar CDs. Este comando é instalado com o pacote ou port <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/cdrtools/>sysutils/cdrtools</a>.</p></div><div class=paragraph><p>Enquanto o <code>cdrecord</code> tem muitas opções, o uso básico é simples. Especifique o nome do arquivo ISO para gravar e, se o sistema tiver vários dispositivos de gravação, especifique o nome do dispositivo a ser usado:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cdrecord dev=device imagefile.iso</span></code></pre></div></div><div class=paragraph><p>Para determinar o nome do dispositivo do gravador, use <code>-scanbus</code>, que pode produzir resultados como este:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cdrecord -scanbus</span>
ProDVD-ProBD-Clone 3.00 <span class=o>(</span>amd64-unknown-freebsd10.0<span class=o>)</span> Copyright <span class=o>(</span>C<span class=o>)</span> 1995-2010 Jörg Schilling
Using libscg version <span class=s1>&#39;schily-0.9&#39;</span>
scsibus0:
        0,0,0     0<span class=o>)</span> <span class=s1>&#39;SEAGATE &#39;</span> <span class=s1>&#39;ST39236LW       &#39;</span> <span class=s1>&#39;0004&#39;</span> Disk
        0,1,0     1<span class=o>)</span> <span class=s1>&#39;SEAGATE &#39;</span> <span class=s1>&#39;ST39173W        &#39;</span> <span class=s1>&#39;5958&#39;</span> Disk
        0,2,0     2<span class=o>)</span> <span class=k>*</span>
        0,3,0     3<span class=o>)</span> <span class=s1>&#39;iomega  &#39;</span> <span class=s1>&#39;jaz 1GB         &#39;</span> <span class=s1>&#39;J.86&#39;</span> Removable Disk
        0,4,0     4<span class=o>)</span> <span class=s1>&#39;NEC     &#39;</span> <span class=s1>&#39;CD-ROM DRIVE:466&#39;</span> <span class=s1>&#39;1.26&#39;</span> Removable CD-ROM
        0,5,0     5<span class=o>)</span> <span class=k>*</span>
        0,6,0     6<span class=o>)</span> <span class=k>*</span>
        0,7,0     7<span class=o>)</span> <span class=k>*</span>
scsibus1:
        1,0,0   100<span class=o>)</span> <span class=k>*</span>
        1,1,0   101<span class=o>)</span> <span class=k>*</span>
        1,2,0   102<span class=o>)</span> <span class=k>*</span>
        1,3,0   103<span class=o>)</span> <span class=k>*</span>
        1,4,0   104<span class=o>)</span> <span class=k>*</span>
        1,5,0   105<span class=o>)</span> <span class=s1>&#39;YAMAHA  &#39;</span> <span class=s1>&#39;CRW4260         &#39;</span> <span class=s1>&#39;1.0q&#39;</span> Removable CD-ROM
        1,6,0   106<span class=o>)</span> <span class=s1>&#39;ARTEC   &#39;</span> <span class=s1>&#39;AM12S           &#39;</span> <span class=s1>&#39;1.06&#39;</span> Scanner
        1,7,0   107<span class=o>)</span> <span class=k>*</span></code></pre></div></div><div class=paragraph><p>Localize a entrada para o gravador de CD e use os três números separados por vírgulas como o valor para <code>dev</code>. Nesse caso, o dispositivo gravador Yamaha é <code>1,5,0</code>, portanto, a entrada apropriada para especificar esse dispositivo é <code>dev=1,5,0</code>. Consulte a página de manual do <code>cdrecord</code> para outras formas de especificar este valor e informações sobre como gravar faixas de áudio e controlar a velocidade de gravação.</p></div><div class=paragraph><p>Como alternativa, execute o seguinte comando para obter o endereço do dispositivo do gravador:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># camcontrol devlist</span>
&lt;MATSHITA CDRW/DVD UJDA740 1.00&gt;   at scbus1 target 0 lun 0 <span class=o>(</span>cd0,pass0<span class=o>)</span></code></pre></div></div><div class=paragraph><p>Use os valores numéricos para <code>scbus</code>, <code>target</code> e <code>lun</code>. Para este exemplo, <code>1,0,0</code> é o nome do dispositivo a ser usado.</p></div></div><div class=sect2><h3 id=mkisofs>17.5.3. Escrevendo Dados em um Sistema de Arquivos ISO<a class=anchor href=#mkisofs></a></h3><div class=paragraph><p>Para produzir um CD de dados, os arquivos de dados que compõem as faixas no CD devem ser preparados antes que possam ser gravados no CD. No FreeBSD, <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/cdrtools/>sysutils/cdrtools</a> instala o <code>mkisofs</code>, que pode ser usado para produzir um sistema de arquivos ISO 9660 que é uma imagem de uma árvore de diretórios dentro um sistema de arquivos UNIX™. O uso mais simples é especificar o nome do arquivo ISO para criar e o caminho para os arquivos a serem colocados no sistema de arquivos ISO 9660:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mkisofs -o imagefile.iso /path/to/tree</span></code></pre></div></div><div class=paragraph><p>Este comando mapeia os nomes dos arquivos no caminho especificado para os nomes que se ajustam às limitações do sistema de arquivos padrão ISO 9660 e excluirá arquivos que não atendem ao padrão para o sistemas de arquivos ISO.</p></div><div class=paragraph><p>Várias opções estão disponíveis para superar as restrições impostas pelo padrão. Em particular, <code>-R</code> permite que as extensões Rock Ridge comuns aos sistemas UNIX™ e <code>-J</code> ativem as extensões Joliet usadas por sistemas Microsoft™.</p></div><div class=paragraph><p>Para CDs que serão usados apenas em sistemas FreeBSD, <code>-U</code> pode ser usado para desabilitar todas as restrições de nome de arquivo. Quando usado com <code>-R</code>, ele produz uma imagem do sistema de arquivos que é idêntica à árvore FreeBSD especificada, mesmo se violar o padrão ISO 9660.</p></div><div class=paragraph><p>A última opção de uso geral é <code>-b</code>. Isso é usado para especificar a localização de uma imagem de inicialização para uso na produção de um CD inicializável "El Torito". Essa opção usa um argumento que é o caminho para uma imagem de inicialização a partir do topo da árvore que está sendo gravada no CD. Por padrão, o <code>mkisofs</code> cria uma imagem ISO no modo de "emulação de disquete" e, portanto, espera que a imagem de inicialização tenha exatamente 1200, 1440 ou 2880 KB de tamanho. Alguns gerenciadores de inicialização, como o usado pela mídia de distribuição do FreeBSD, não utilizam o modo de emulação. Nesse caso, <code>-no-emul-boot</code> deve ser usado. Então, se <span class=filename>/tmp/myboot</span> possuir um sistema FreeBSD inicializável com a imagem de inicialização em <span class=filename>/tmp/myboot/boot/cdboot</span>, este comando produziria <span class=filename>/tmp/bootable.iso</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mkisofs -R -no-emul-boot -b boot/cdboot -o /tmp/bootable.iso /tmp/myboot</span></code></pre></div></div><div class=paragraph><p>A imagem ISO resultante pode ser montada como um disco de memória com:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mdconfig -a -t vnode -f /tmp/bootable.iso -u 0</span>
<span class=c># mount -t cd9660 /dev/md0 /mnt</span></code></pre></div></div><div class=paragraph><p>Pode-se então verificar se <span class=filename>/mnt</span> e <span class=filename>/tmp/myboot</span> são idênticos.</p></div><div class=paragraph><p>Existem muitas outras opções disponíveis para <code>mkisofs</code> para ajustar seu comportamento. Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=mkisofs&amp;sektion=8&amp;format=html">mkisofs(8)</a> para obter detalhes.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>É possível copiar um CD de dados para um arquivo de imagem que seja funcionalmente equivalente ao arquivo de imagem criado com <code>mkisofs</code>. Para fazer isso, use <span class=filename>dd</span> com o nome do dispositivo como o arquivo de entrada e o nome do ISO para criar como o arquivo de saída:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dd if=/dev/cd0 of=file.iso bs=2048</span></code></pre></div></div><div class=paragraph><p>O arquivo de imagem resultante pode ser gravado em CD, conforme descrito em <a href=#cdrecord>Gravando um CD</a>.</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=mounting-cd>17.5.4. Usando CDs de Dados<a class=anchor href=#mounting-cd></a></h3><div class=paragraph><p>Uma vez que uma ISO tenha sido gravada em um CD, ela pode ser montada especificando o tipo de sistema de arquivos, o nome do dispositivo que contém o CD e um ponto de montagem existente:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount -t cd9660 /dev/cd0 /mnt</span></code></pre></div></div><div class=paragraph><p>Como <code>mount</code> assume que um sistema de arquivos é do tipo <code>ufs</code>, um erro <code>Incorrect super block</code> ocorrerá se <code>-t cd9660</code> não está incluído ao montar um arquivo de dados CD.</p></div><div class=paragraph><p>Embora qualquer CD de dados possa ser montado dessa forma, discos com determinadas extensões ISO 9660 podem se comportar de maneira estranha. Por exemplo, os discos Joliet armazenam todos os nomes de arquivos em caracteres Unicode de dois bytes. Se alguns caracteres não ingleses aparecerem como pontos de interrogação, especifique o conjunto de caracteres local com <code>-C</code>. Para mais informações, consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=mount_cd9660&amp;sektion=8&amp;format=html">mount_cd9660(8)</a>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Para fazer esta conversão de caracteres com a ajuda de <code>-C</code>, o kernel requer que o módulo <span class=filename>cd9660_iconv.ko</span> seja carregado. Isto pode ser feito adicionando esta linha ao arquivo <span class=filename>loader.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>cd9660_iconv_load=&#34;YES&#34;</pre></div></div><div class=paragraph><p>e reinicializando a máquina, ou carregando diretamente o módulo com <code>kldload</code>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Ocasionalmente, <code>Device not configured</code> será exibido ao tentar montar um CD de dados. Isso geralmente significa que a unidade de CD não detectou um disco na bandeja ou que a unidade não está visível no barramento. Pode levar alguns segundos para que uma unidade de CD detecte a mídia, por isso, seja paciente.</p></div><div class=paragraph><p>Às vezes, uma unidade de CDSCSI pode ser perdida porque não teve tempo suficiente para responder à reinicialização do barramento. Para resolver isso, um kernel personalizado pode ser criado, o que aumenta o delay SCSI padrão. Adicione a seguinte opção ao arquivo de configuração do kernel personalizado e reconstrua o kernel usando as instruções em <a href=../kernelconfig/#kernelconfig-building>Criando e Instalando um Kernel Customizado</a>:</p></div><div class="literalblock programlisting"><div class=content><pre>options SCSI_DELAY=15000</pre></div></div><div class=paragraph><p>Isso faz com que o barramento SCSI faça uma pausa de 15 segundos durante a inicialização, para dar à unidade de CD todas as chances possíveis de responder à reinicialização do barramento.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>É possível gravar um arquivo diretamente no CD, sem criar um sistema de arquivos ISO 9660. Isso é conhecido como gravação de dados brutos em CD e algumas pessoas fazem isso para fins de backup.</p></div><div class=paragraph><p>Este tipo de disco não pode ser montado como um CD de dados normal. Para recuperar os dados gravados em um CD, os dados devem ser lidos no nó do dispositivo bruto. Por exemplo, este comando irá extrair um arquivo tar compactado localizado no segundo dispositivo de CD para o diretório de trabalho atual:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># tar xzvf /dev/cd1</span></code></pre></div></div><div class=paragraph><p>Para montar um CD de dados, os dados devem ser escritos usando <code>mkisofs</code>.</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=duplicating-audiocds>17.5.5. Duplicando CDs de Áudio<a class=anchor href=#duplicating-audiocds></a></h3><div class=paragraph><p>Para duplicar um CD de áudio, extraia os dados de áudio do CD para uma série de arquivos e, em seguida, grave esses arquivos em um CD em branco.</p></div><div class=paragraph><p><a href=#using-cdrecord>Duplicando um CD de Áudio</a> descreve como duplicar e gravar um CD de áudio. Se a versão do FreeBSD for menor que 10.0 e o dispositivo for ATAPI, o módulo <code>atapicam</code> deve ser carregado primeiro usando as instruções em <a href=#atapicam>Dispositivos Suportados</a>.</p></div><div id=using-cdrecord class="exampleblock procedure"><div class=content><div class=paragraph><p><strong>Procedure: Duplicando um CD de Áudio</strong></p></div><div class="olist arabic"><ol class=arabic><li><p>O pacote ou port <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/cdrtools/>sysutils/cdrtools</a> instala o <code>cdda2wav</code>. Este comando pode ser usado para extrair todas as faixas de áudio, com cada faixa gravada em um arquivo WAV separado no diretório de trabalho atual:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% cdda2wav <span class=nt>-vall</span> <span class=nt>-B</span> <span class=nt>-Owav</span></code></pre></div></div><div class=paragraph><p>Um nome de dispositivo não precisa ser especificado se houver apenas um dispositivo de CD no sistema. Consulte a página de manual <code>cdda2wav</code> para obter instruções sobre como especificar um dispositivo e aprender mais sobre as outras opções disponíveis para este comando.</p></div></li><li><p>Use o <code>cdrecord</code> para escrever os arquivos <span class=filename>.wav</span>:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% cdrecord <span class=nt>-v</span> <span class=nv>dev</span><span class=o>=</span>2,0 <span class=nt>-dao</span> <span class=nt>-useinfo</span>  <span class=k>*</span>.wav</code></pre></div></div><div class=paragraph><p>Certifique-se de que <em>2,0</em> esteja configurado adequadamente, conforme descrito em <a href=#cdrecord>Gravando um CD</a>.</p></div></li></ol></div></div></div></div></div></div><div class=sect1><h2 id=creating-dvds>17.6. Criando e Usando Mídia de DVD<a class=anchor href=#creating-dvds></a></h2><div class=sectionbody><div class=paragraph><p>Comparado ao CD, o DVD é a próxima geração de tecnologia de armazenamento de mídia ótica. O DVD pode conter mais dados do que qualquer CD e é o padrão para publicação de vídeos.</p></div><div class=paragraph><p>Cinco formatos graváveis físicos podem ser definidos para um DVD gravável:</p></div><div class=ulist><ul><li><p>DVD-R: Este foi o primeiro formato gravável disponível em DVD. O padrão DVD-R é definido pelo <a href=http://www.dvdforum.org/forum.shtml>DVD Forum</a>. Este formato é escrito uma vez.</p></li><li><p>DVD-RW: Esta é a versão regravável do padrão DVD-R. Um DVD-RW pode ser reescrito cerca de 1000 vezes.</p></li><li><p>DVD-RAM: Este é um formato regravável que pode ser visto como um disco rígido removível. No entanto, esta mídia não é compatível com a maioria das unidades e reprodutores de DVD-Video DVD-ROM, pois apenas alguns gravadores de DVD suportam o formato DVD-RAM. Consulte <a href=#creating-dvd-ram>Usando um DVD-RAM</a> para mais informações sobre o uso de DVD-RAM.</p></li><li><p>DVD+RW: Este é um formato regravável definido pelo <a href=https://en.wikipedia.org/wiki/DVD%2BRW_Alliance>DVD+RW Alliance</a>. Um DVD+RW pode ser reescrito cerca de 1000 vezes.</p></li><li><p>DVD+R: Este formato é a variação de gravação do formato DVD+RW.</p></li></ul></div><div class=paragraph><p>Um DVD gravável de camada única pode armazenar até 4,700,000,000 bytes, o que é, na verdade, 4.38 GB ou 4485 MB, pois 1 kilobyte é 1024 bytes.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Uma distinção deve ser feita entre a mídia física e a aplicação. Por exemplo, um DVD-Vídeo é um layout de arquivo específico que pode ser gravado em qualquer mídia física DVD gravável, como DVD-R, DVD+R ou DVD-RW. Antes de escolher o tipo de mídia, verifique se o gravador e o reprodutor de DVD-Video são compatíveis com a mídia em questão.</p></div></td></tr></tbody></table></div><div class=sect2><h3 id=_configuração>17.6.1. Configuração<a class=anchor href=#_configuração></a></h3><div class=paragraph><p>Para executar a gravação de um DVD, use <a href="https://man.freebsd.org/cgi/man.cgi?query=growisofs&amp;sektion=1&amp;format=html">growisofs(1)</a>. Este comando é parte dos utilitários <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/dvd+rw-tools/>sysutils/dvd+rw-tools</a> que suportam todos os tipos de mídia DVD.</p></div><div class=paragraph><p>Estas ferramentas usam o subsistema SCSI para acessar os dispositivos, portanto <a href=#atapicam>suporte a ATAPI/CAM</a> deve ser carregado ou estaticamente compilado no kernel. Este suporte não é necessário se o gravador usar a interface USB. Consulte <a href=#usb-disks>Dispositivos de Armazenamento USB</a> para mais detalhes sobre a configuração do dispositivo USB.</p></div><div class=paragraph><p>O acesso DMA também deve estar ativado para dispositivos ATAPI, adicionando a seguinte linha ao arquivo <span class=filename>/boot/loader.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>hw.ata.atapi_dma=&#34;1&#34;</pre></div></div><div class=paragraph><p>Antes de tentar usar dvd+rw-tools, consulte o <a href=http://fy.chalmers.se/~appro/linux/DVD+RW/hcn.html>Notas de compatibilidade de hardware</a>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Para uma interface gráfica de usuário, considere o uso de <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/k3b/>sysutils/k3b</a> que fornece uma interface amigável para <a href="https://man.freebsd.org/cgi/man.cgi?query=growisofs&amp;sektion=1&amp;format=html">growisofs(1)</a> e muitas outras ferramentas de gravação.</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=_gravando_dvds_de_dados>17.6.2. Gravando DVDs de Dados<a class=anchor href=#_gravando_dvds_de_dados></a></h3><div class=paragraph><p>Já que <a href="https://man.freebsd.org/cgi/man.cgi?query=growisofs&amp;sektion=1&amp;format=html">growisofs(1)</a> é um front-end para <a href=#mkisofs>mkisofs</a>, ele invocará <a href="https://man.freebsd.org/cgi/man.cgi?query=mkisofs&amp;sektion=8&amp;format=html">mkisofs(8)</a> para criar o layout do sistema de arquivos e executar a gravação no DVD . Isso significa que uma imagem dos dados não precisa ser criada antes do processo de gravação.</p></div><div class=paragraph><p>Para gravar em um DVD+R ou DVD-R os dados em <span class=filename>/path/to/data</span>, use o seguinte comando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># growisofs -dvd-compat -Z /dev/cd0 -J -R /path/to/data</span></code></pre></div></div><div class=paragraph><p>Neste exemplo, <code>-J -R</code> é passado para <a href="https://man.freebsd.org/cgi/man.cgi?query=mkisofs&amp;sektion=8&amp;format=html">mkisofs(8)</a> para criar um sistemas de arquivos ISO 9660 com extensões Joliet e Rock Ridge. Consulte o <a href="https://man.freebsd.org/cgi/man.cgi?query=mkisofs&amp;sektion=8&amp;format=html">mkisofs(8)</a> para obter mais detalhes.</p></div><div class=paragraph><p>Para a gravação inicial da sessão, <code>-Z</code> é usado para sessões únicas e múltiplas. Substitua <em>/dev/cd0</em>, com o nome do dispositivo de DVD. O uso de <code>-dvd-compat</code> indica que o disco será fechado e que a gravação será inaplicável. Isso também deve fornecer melhor compatibilidade de mídia com unidades DVD-ROM.</p></div><div class=paragraph><p>Para gravar uma imagem pré-masterizada, como <em>imagefile.iso</em>, use:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># growisofs -dvd-compat -Z /dev/cd0=imagefile.iso</span></code></pre></div></div><div class=paragraph><p>A velocidade de gravação deve ser detectada e configurada automaticamente de acordo com a mídia e a unidade que está sendo usada. Para forçar a velocidade de gravação, use <code>-speed=</code>. Consulte o <a href="https://man.freebsd.org/cgi/man.cgi?query=growisofs&amp;sektion=1&amp;format=html">growisofs(1)</a> para exemplos de uso.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Para suportar arquivos de trabalho maiores que 4.38GB, um sistema de arquivos híbrido UDF/ISO-9660 deve ser criado passando <code>-udf -iso-level 3</code> para <a href="https://man.freebsd.org/cgi/man.cgi?query=mkisofs&amp;sektion=8&amp;format=html">mkisofs(8)</a> e todos os programas relacionados, como <a href="https://man.freebsd.org/cgi/man.cgi?query=growisofs&amp;sektion=1&amp;format=html">growisofs(1)</a>. Isso é necessário apenas ao criar um arquivo de imagem ISO ou ao gravar arquivos diretamente em um disco. Como um disco criado dessa maneira deve ser montado como um sistema de arquivos UDF com <a href="https://man.freebsd.org/cgi/man.cgi?query=mount_udf&amp;sektion=8&amp;format=html">mount_udf(8)</a>, ele será utilizável apenas em um sistema operacional com suporte a UDF. Caso contrário, parecerá que contém arquivos corrompidos.</p></div><div class=paragraph><p>Para criar este tipo de arquivo ISO:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% mkisofs <span class=nt>-R</span> <span class=nt>-J</span> <span class=nt>-udf</span> <span class=nt>-iso-level</span> 3 <span class=nt>-o</span> imagefile.iso /path/to/data</code></pre></div></div><div class=paragraph><p>Para gravar arquivos diretamente em um disco:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># growisofs -dvd-compat -udf -iso-level 3 -Z /dev/cd0 -J -R /path/to/data</span></code></pre></div></div><div class=paragraph><p>Quando uma imagem ISO já contém arquivos grandes, nenhuma opção adicional é necessária para o <a href="https://man.freebsd.org/cgi/man.cgi?query=growisofs&amp;sektion=1&amp;format=html">growisofs(1)</a> gravar a imagem em um disco.</p></div><div class=paragraph><p>Certifique-se de usar uma versão atualizada do port <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/cdrtools/>sysutils/cdrtools</a>, que contenha o <a href="https://man.freebsd.org/cgi/man.cgi?query=mkisofs&amp;sektion=8&amp;format=html">mkisofs(8)</a>, como uma versão mais antiga pode não conter suporte a arquivos grandes. Se a versão mais recente não funcionar, instale o <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/cdrtools-devel/>sysutils/cdrtools-devel</a> e leia o <a href="https://man.freebsd.org/cgi/man.cgi?query=mkisofs&amp;sektion=8&amp;format=html">mkisofs(8)</a>.</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=_gravando_um_dvd_video>17.6.3. Gravando um DVD -Video<a class=anchor href=#_gravando_um_dvd_video></a></h3><div class=paragraph><p>Um DVD-Video é um layout de arquivo específico baseado nas especificações ISO 9660 e micro-UDF (M-UDF). Como o DVD-Video apresenta uma hierarquia de estrutura de dados específica, um programa específico como <a class=package href=https://cgit.freebsd.org/ports/tree/multimedia/dvdauthor/>multimedia/dvdauthor</a> é necessário para criar o DVD.</p></div><div class=paragraph><p>Se uma imagem do sistema de arquivos DVD-Video já existir, ela poderá ser gravada da mesma maneira que qualquer outra imagem. Se o <code>dvdauthor</code> foi usado para criar o DVD e o resultado está em <span class=filename>/path/to/video</span>, o seguinte comando deve ser usado para gravar o DVD-Vídeo:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># growisofs -Z /dev/cd0 -dvd-video /path/to/video</span></code></pre></div></div><div class=paragraph><p><code>-dvd-video</code> é passado para o <a href="https://man.freebsd.org/cgi/man.cgi?query=mkisofs&amp;sektion=8&amp;format=html">mkisofs(8)</a> para instruí-lo a criar um sistemas de arquivos com layout DVD-Video. Esta opção implica na opção <code>-dvd-compat</code> do <a href="https://man.freebsd.org/cgi/man.cgi?query=growisofs&amp;sektion=1&amp;format=html">growisofs(1)</a>.</p></div></div><div class=sect2><h3 id=_usando_um_dvdrw>17.6.4. Usando um DVD+RW<a class=anchor href=#_usando_um_dvdrw></a></h3><div class=paragraph><p>Ao contrário do CD-RW, um DVD+RW virgem precisa ser formatado antes do primeiro uso. É <em>recomendado</em> para permitir que <a href="https://man.freebsd.org/cgi/man.cgi?query=growisofs&amp;sektion=1&amp;format=html">growisofs(1)</a> cuide disso automaticamente sempre que apropriado. No entanto, é possível usar <code>dvd+rw-format</code> para formatar o DVD+RW:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dvd+rw-format /dev/cd0</span></code></pre></div></div><div class=paragraph><p>Somente execute esta operação uma vez e tenha em mente que apenas mídias DVD+RW virgens precisam ser formatadas. Uma vez formatado, o DVD+RW pode ser gravado como de costume.</p></div><div class=paragraph><p>Para gravar um sistema de arquivos totalmente novo e não apenas acrescentar alguns dados em um DVD+RW, a mídia não precisa ser apagada primeiro. Em vez disso, escreva sobre a gravação anterior assim:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># growisofs -Z /dev/cd0 -J -R /path/to/newdata</span></code></pre></div></div><div class=paragraph><p>O formato DVD+RW suporta anexar dados a uma gravação anterior. Essa operação consiste em mesclar uma nova sessão à existente, pois ela não é considerada como gravação de várias sessões. <a href="https://man.freebsd.org/cgi/man.cgi?query=growisofs&amp;sektion=1&amp;format=html">growisofs(1)</a> vai <em>ampliar</em> o sistema de arquivos ISO 9660 presente na mídia.</p></div><div class=paragraph><p>Por exemplo, para anexar dados a um DVD+RW, use o seguinte:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># growisofs -M /dev/cd0 -J -R /path/to/nextdata</span></code></pre></div></div><div class=paragraph><p>As mesmas opções do <a href="https://man.freebsd.org/cgi/man.cgi?query=mkisofs&amp;sektion=8&amp;format=html">mkisofs(8)</a> usadas para gravar a sessão inicial devem ser usadas durante as próximas gravações.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Use <code>-dvd-compat</code> para melhor compatibilidade de mídia com as unidades de DVD-ROM. Ao usar DVD+RW, essa opção não impedirá a adição de dados.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Para apagar a mídia, use:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># growisofs -Z /dev/cd0=/dev/zero</span></code></pre></div></div></div><div class=sect2><h3 id=_usando_um_dvd_rw>17.6.5. Usando um DVD-RW<a class=anchor href=#_usando_um_dvd_rw></a></h3><div class=paragraph><p>Um DVD-RW aceita dois formatos de disco: sequencial incremental e substituição restrita. Por padrão, os discos DVD-RW estão em formato sequencial.</p></div><div class=paragraph><p>Um DVD-RW virgem pode ser escrito diretamente sem ser formatado. No entanto, um DVD-RW não-virgem em formato sequencial precisa ser apagado antes de escrever uma nova sessão inicial.</p></div><div class=paragraph><p>Para apagar um DVD-RW em modo sequencial:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dvd+rw-format -blank=full /dev/cd0</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Um preenchimento completo usando <code>-blank=full</code> levará cerca de uma hora em uma mídia 1x. Um limpeza rápida pode ser executada usando <code>-blank</code>, se o DVD-RW for gravado no modo Disk-At-Once (DAO). Para gravar o DVD-RW no modo DAO, use o comando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># growisofs -use-the-force-luke=dao -Z /dev/cd0=imagefile.iso</span></code></pre></div></div><div class=paragraph><p>Como o <a href="https://man.freebsd.org/cgi/man.cgi?query=growisofs&amp;sektion=1&amp;format=html">growisofs(1)</a> tenta automaticamente detectar a mídia rapidamente em branco e ativar a gravação do DAO, <code>-use-the-force -luke=dao</code> não deve ser requerido.</p></div><div class=paragraph><p>Em vez disso, deve-se usar o modo de sobrescrita restrita com qualquer DVD-RW, pois esse formato é mais flexível do que o padrão de sequencial incremental.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Para escrever dados em um DVD-RW seqüencial, use as mesmas instruções que para os outros formatos de DVD:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># growisofs -Z /dev/cd0 -J -R /path/to/data</span></code></pre></div></div><div class=paragraph><p>Para acrescentar alguns dados a uma gravação anterior, use <code>-M</code> com o <a href="https://man.freebsd.org/cgi/man.cgi?query=growisofs&amp;sektion=1&amp;format=html">growisofs(1)</a>. No entanto, se os dados forem anexados em um DVD-RW no modo sequencial incremental, uma nova sessão será criada no disco e o resultado será um disco multi-sessão.</p></div><div class=paragraph><p>Um DVD-RW no formato de sobrescrita restrita não precisa ser em apagado antes de uma nova sessão inicial. Em vez disso, sobrescreva o disco com <code>-Z</code>. Também é possível aumentar um sistema de arquivos ISO 9660 existente escrito no disco com <code>-M</code>. O resultado será um DVD de uma sessão.</p></div><div class=paragraph><p>Para colocar um DVD-RW no formato de sobrescrita restrita, o seguinte comando deve ser usado:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dvd+rw-format /dev/cd0</span></code></pre></div></div><div class=paragraph><p>Para voltar ao formato sequencial, use:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dvd+rw-format -blank=full /dev/cd0</span></code></pre></div></div></div><div class=sect2><h3 id=_multi_sessão>17.6.6. Multi-Sessão<a class=anchor href=#_multi_sessão></a></h3><div class=paragraph><p>Poucas unidades de DVD-ROM suportam DVDs multi-sessão e na maioria das vezes apenas lêem a primeira sessão. DVD+R, DVD-R e DVD-RW em formato sequencial podem aceitar várias sessões. A noção de várias sessões não existe para os formatos de sobrescrita restrita DVD+RW e DVD-RW.</p></div><div class=paragraph><p>Usando o seguinte comando após uma sessão inicial não fechada em um DVD+R, DVD-R ou DVD-RW em formato sequencial, será adicionada uma nova sessão ao disco:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># growisofs -M /dev/cd0 -J -R /path/to/nextdata</span></code></pre></div></div><div class=paragraph><p>Usando este comando com um DVD+RW ou um DVD-RW no modo de sobrescrita restrita adicionará dados ao mesclar a nova sessão à existente. O resultado será um disco de sessão única. Use este método para adicionar dados após uma gravação inicial nesses tipos de mídia.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Como algum espaço na mídia é usado entre cada sessão para marcar o final e o início das sessões, deve-se adicionar sessões com uma grande quantidade de dados para otimizar o espaço da mídia. O número de sessões é limitado a 154 para um DVD+R, cerca de 2000 para um DVD-R e 127 para um DVD+R Double Layer.</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=_para_maiores_informações>17.6.7. Para Maiores Informações<a class=anchor href=#_para_maiores_informações></a></h3><div class=paragraph><p>Para obter mais informações sobre um DVD, use o <code>dvd+rw-mediainfo <em>/dev/cd0</em></code> enquanto o disco estiver na unidade especificada.</p></div><div class=paragraph><p>Mais informações sobre dvd+rw-tools podem ser encontradas em <a href="https://man.freebsd.org/cgi/man.cgi?query=growisofs&amp;sektion=1&amp;format=html">growisofs(1)</a>, no <a href=http://fy.chalmers.se/~appro/linux/DVD+RW/>site de dvd+rw-tools</a>, e nos arquivos do <a href=http://lists.debian.org/cdwrite/>cdwrite mailing list</a>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Ao criar um relatório de problemas relacionado ao uso de dvd+rw-tools, inclua sempre a saída de <code>dvd+rw-mediainfo</code>.</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=creating-dvd-ram>17.6.8. Usando um DVD-RAM<a class=anchor href=#creating-dvd-ram></a></h3><div class=paragraph><p>Os gravadores de DVD-RAM podem usar uma interface SCSI ou ATAPI. Para dispositivos ATAPI, o acesso DMA deve ser ativado adicionando a seguinte linha ao arquivo <span class=filename>/boot/loader.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>hw.ata.atapi_dma=&#34;1&#34;</pre></div></div><div class=paragraph><p>Um DVD-RAM pode ser visto como um disco rígido removível. Como qualquer outro disco rígido, o DVD-RAM deve ser formatado antes de poder ser usado. Neste exemplo, todo o espaço em disco será formatado com um sistema de arquivos UFS2 padrão:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dd if=/dev/zero of=/dev/acd0 bs=2k count=1</span>
<span class=c># bsdlabel -Bw acd0</span>
<span class=c># newfs /dev/acd0</span></code></pre></div></div><div class=paragraph><p>O dispositivo DVD, <span class=filename>acd0</span>, deve ser alterado de acordo com a configuração.</p></div><div class=paragraph><p>Uma vez que o DVD-RAM tenha sido formatado, ele pode ser montado como um disco rígido normal:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount /dev/acd0 /mnt</span></code></pre></div></div><div class=paragraph><p>Uma vez montado, o DVD-RAM será legível e gravável.</p></div></div></div></div><div class=sect1><h2 id=floppies>17.7. Criando e Usando Disquetes<a class=anchor href=#floppies></a></h2><div class=sectionbody><div class=paragraph><p>Esta seção explica como formatar um disquete de 3.5 polegadas no FreeBSD.</p></div><div class="exampleblock procedure"><div class=content><div class=paragraph><p><strong>Procedure: Etapas para Formatar um Disquete</strong></p></div><div class=paragraph><p>Um disquete precisa ser formatado em baixo nível antes de poder ser usado. Isso geralmente é feito pelo fornecedor, mas a formatação é uma boa maneira de verificar a integridade da mídia. Para o formato de baixo nível do disquete no FreeBSD, use <a href="https://man.freebsd.org/cgi/man.cgi?query=fdformat&amp;sektion=1&amp;format=html">fdformat(1)</a>. Ao usar esse utilitário, anote todas as mensagens de erro, pois elas podem ajudar a determinar se o disco está bom ou ruim.</p></div><div class="olist arabic"><ol class=arabic><li><p>Para formatar o disquete, insira um novo disquete de 3.5 polegadas na primeira unidade de disquete e digite:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /usr/sbin/fdformat -f 1440 /dev/fd0</span></code></pre></div></div></li><li><p>Após a formatação de baixo nível do disco, crie um rótulo de disco conforme requerido pelo sistema para determinar o tamanho do disco e sua geometria. Os valores de geometria suportados estão listados no arquivo <span class=filename>/etc/disktab</span>.</p><div class=paragraph><p>Para escrever o rótulo do disco, use <a href="https://man.freebsd.org/cgi/man.cgi?query=bsdlabel&amp;sektion=8&amp;format=html">bsdlabel(8)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /sbin/bsdlabel -B -w /dev/fd0 fd1440</span></code></pre></div></div></li><li><p>O disquete agora está pronto para ser formatado em alto nível com um sistema de arquivos. O sistema de arquivos do disquete pode ser UFS ou FAT, onde o FAT geralmente é uma opção melhor para disquetes.</p><div class=paragraph><p>Para formatar o disquete com o FAT, digite:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /sbin/newfs_msdos /dev/fd0</span></code></pre></div></div></li></ol></div></div></div><div class=paragraph><p>O disco está agora pronto para uso. Para usar o disquete, monte-o com <a href="https://man.freebsd.org/cgi/man.cgi?query=mount_msdosfs&amp;sektion=8&amp;format=html">mount_msdosfs(8)</a>. Também é possível instalar e usar <a class=package href=https://cgit.freebsd.org/ports/tree/emulators/mtools/>emulators/mtools</a> da coleção de ports.</p></div></div></div><div class=sect1><h2 id=backup-basics>17.8. Noções Básicas de Backup<a class=anchor href=#backup-basics></a></h2><div class=sectionbody><div class=paragraph><p>A implementação de um plano de backup é essencial para que seja possível recuperar de uma falha de disco, exclusão acidental de arquivos, corrupção aleatória de arquivos ou destruição completa da máquina, incluindo a destruição de backups no local.</p></div><div class=paragraph><p>O tipo e a programação do backup variam, dependendo da importância dos dados, da granularidade necessária para as restaurações de arquivos e da quantidade de tempo de inatividade aceitável. Algumas técnicas de backup possíveis incluem:</p></div><div class=ulist><ul><li><p>Arquivos de todo o sistema, protegidos por meio de backups em mídias permanentes, armazenados off-site. Isso fornece proteção contra todos os problemas listados acima, mas é lento e inconveniente para restaurar, especialmente para usuários sem privilégios.</p></li><li><p>Snapshots do sistema de arquivos, que são úteis para restaurar arquivos excluídos ou versões anteriores de arquivos.</p></li><li><p>Cópias de sistemas de arquivos inteiros ou discos que são sincronizados com outro sistema na rede usando um <a class=package href=https://cgit.freebsd.org/ports/tree/net/rsync/>net/rsync</a> agendado.</p></li><li><p>RAID por hardware ou software, que minimiza ou evita paralisações quando um disco falha.</p></li></ul></div><div class=paragraph><p>Normalmente, uma mistura de técnicas de backup é usada. Por exemplo, pode-se criar um agendamento semanal para automatizar um backup completo do sistema e armazená-lo off-site e para suplementá-lo, snapshots do ZFS tirados a cada hora. Além disso, é possível fazer um backup manual de diretórios ou arquivos individuais antes de fazer edições ou exclusões de arquivos.</p></div><div class=paragraph><p>Esta seção descreve alguns dos utilitários que podem ser usados para criar e gerenciar backups em um sistema FreeBSD.</p></div><div class=sect2><h3 id=_backups_do_sistema_de_arquivos>17.8.1. Backups do Sistema de Arquivos<a class=anchor href=#_backups_do_sistema_de_arquivos></a></h3><div class=paragraph><p>Os programas tradicionais UNIX™ para fazer backup de um sistema de arquivos são <a href="https://man.freebsd.org/cgi/man.cgi?query=dump&amp;sektion=8&amp;format=html">dump(8)</a>, que cria o backup, e <a href="https://man.freebsd.org/cgi/man.cgi?query=restore&amp;sektion=8&amp;format=html">restore(8)</a>, que restaura o backup. Esses utilitários funcionam no nível do bloco do disco, abaixo das abstrações dos arquivos, links e diretórios criados pelos sistemas de arquivos. Ao contrário de outros softwares de backup, <code>dump</code> faz backup de todo um sistema de arquivos e não é capaz de fazer backup de apenas parte de um sistema de arquivos ou de uma árvore de diretórios que abrange vários sistemas de arquivos. Em vez de gravar arquivos e diretórios, <code>dump</code> grava os blocos de dados brutos que compreendem arquivos e diretórios.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Se o <code>dump</code> for usado no diretório raiz, ele não fará o backup de <span class=filename>/home</span>, <span class=filename>/usr</span> ou de muitos outros diretórios, pois eles são tipicamente pontos de montagem para outros sistemas de arquivos ou links simbólicos nesses sistemas de arquivos.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Quando usado para restaurar dados, <code>restore</code> armazena arquivos temporários em <span class=filename>/tmp/</span> por padrão. Ao usar um disco de recuperação com um pequeno <span class=filename>/tmp</span>, configure <code>TMPDIR</code> para um diretório com mais espaço livre para que a restauração seja bem-sucedida.</p></div><div class=paragraph><p>Ao usar <code>dump</code>, esteja ciente de que algumas peculiaridades permanecem desde seus primeiros dias na versão 6 do AT&amp;T UNIX™, por volta de 1975. Os parâmetros padrão assumem um backup para uma fita de 9 faixas, em vez de para outro tipo de mídia ou para as fitas de alta densidade disponíveis atualmente. Esses padrões devem ser substituídos na linha de comando.</p></div><div class=paragraph><p>É possível fazer backup de um sistema de arquivos pela rede para outro sistema ou para uma unidade de fita conectada a outro computador. Enquanto os utilitários <a href="https://man.freebsd.org/cgi/man.cgi?query=rdump&amp;sektion=8&amp;format=html">rdump(8)</a> e <a href="https://man.freebsd.org/cgi/man.cgi?query=rrestore&amp;sektion=8&amp;format=html">rrestore(8)</a> possam ser usado para este propósito, eles não são considerados seguros.</p></div><div class=paragraph><p>Em vez disso, pode-se usar <code>dump</code> e <code>restore</code> de uma maneira mais segura em uma conexão SSH. Este exemplo cria um backup completo e compactado de <span class=filename>/usr</span> e envia o arquivo de backup para o host especificado em uma conexão SSH.</p></div><div class=exampleblock><div class=title>Exemplo 1. Usando <code>dump</code> sobre ssh</div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /sbin/dump -0uan -f - /usr | gzip -2 | ssh -c blowfish \</span>
          targetuser@targetmachine.example.com <span class=nb>dd </span><span class=nv>of</span><span class=o>=</span>/mybigfiles/dump-usr-l0.gz</code></pre></div></div></div></div><div class=paragraph><p>Este exemplo configura <code>RSH</code> para gravar o backup em uma unidade de fita em um sistema remoto através de uma conexão SSH:</p></div><div class=exampleblock><div class=title>Exemplo 2. Usando o <code>dump</code> sobre ssh com o <code>RSH</code> configurado</div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># env RSH=/usr/bin/ssh /sbin/dump -0uan -f targetuser@targetmachine.example.com:/dev/sa0 /usr</span></code></pre></div></div></div></div></div><div class=sect2><h3 id=_backups_de_diretório>17.8.2. Backups de Diretório<a class=anchor href=#_backups_de_diretório></a></h3><div class=paragraph><p>Vários utilitários integrados estão disponíveis para backup e restauração de arquivos e diretórios especificados, conforme necessário.</p></div><div class=paragraph><p>Uma boa alternativa para fazer backup de todos os arquivos em um diretório é o <a href="https://man.freebsd.org/cgi/man.cgi?query=tar&amp;sektion=1&amp;format=html">tar(1)</a>. Este utilitário remonta à versão 6 do AT&amp;T UNIX™ e, por padrão, assume um backup recursivo para um dispositivo de fita local. Redirecionadores podem ser utilizados para especificar o nome de um arquivo de backup.</p></div><div class=paragraph><p>Este exemplo cria um backup compactado do diretório atual e o salva no arquivo <span class=filename>/tmp/mybackup.tgz</span>. Ao criar um arquivo de backup, verifique se o backup não está salvo no mesmo diretório em que está sendo feito backup.</p></div><div class=exampleblock><div class=title>Exemplo 3. Fazendo Backup do Diretório Atual com o <code>tar</code></div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># tar czvf /tmp/mybackup.tgz .</span></code></pre></div></div></div></div><div class=paragraph><p>Para restaurar o backup inteiro, <code>cd</code> no diretório para restaurar e especificar o nome do backup. Observe que isso sobrescreverá qualquer versão mais nova de arquivos no diretório de restauração. Em caso de dúvida, restaure para um diretório temporário ou especifique o nome do arquivo dentro do backup a ser restaurado.</p></div><div class=exampleblock><div class=title>Exemplo 4. Restaurando o Diretório Atual com o <code>tar</code></div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># tar xzvf /tmp/mybackup.tgz</span></code></pre></div></div></div></div><div class=paragraph><p>Existem dezenas de opções disponíveis, descritas em <a href="https://man.freebsd.org/cgi/man.cgi?query=tar&amp;sektion=1&amp;format=html">tar(1)</a>. Esse utilitário também suporta o uso de padrões de exclusão para especificar quais arquivos não devem ser incluídos ao fazer backup do diretório especificado ou restaurar arquivos de um backup.</p></div><div class=paragraph><p>Para criar um backup usando uma lista especificada de arquivos e diretórios, <a href="https://man.freebsd.org/cgi/man.cgi?query=cpio&amp;sektion=1&amp;format=html">cpio(1)</a> é uma boa escolha. Ao contrário do <code>tar</code>, o <code>cpio</code> não sabe como percorrer a árvore de diretórios e deve fornecer a lista de arquivos para backup.</p></div><div class=paragraph><p>Por exemplo, uma lista de arquivos pode ser criada usando <code>ls</code> ou <code>find</code>. Este exemplo cria uma listagem recursiva do diretório atual que é então canalizado para o <code>cpio</code> para criar um arquivo de backup de saída chamado <span class=filename>/tmp/mybackup.cpio</span>.</p></div><div class=exampleblock><div class=title>Exemplo 5. Usando <code>ls</code> e <code>cpio</code> para Criar um Backup Recursivo do Diretório Atual</div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ls -R | cpio -ovF /tmp/mybackup.cpio</span></code></pre></div></div></div></div><div class=paragraph><p>Um utilitário de backup que tenta conectar os recursos fornecidos pelo <code>tar</code> e <code>cpio</code> é <a href="https://man.freebsd.org/cgi/man.cgi?query=pax&amp;sektion=1&amp;format=html">pax(1)</a>. Ao longo dos anos, as várias versões do <code>tar</code> e do <code>cpio</code> tornaram-se ligeiramente incompatíveis. POSIX™ criou <code>pax</code> que tenta ler e escrever muitos dos vários formatos <code>cpio</code> e <code>tar</code>, além de novos formatos próprios.</p></div><div class=paragraph><p>O <code>pax</code> equivalente aos exemplos anteriores seria:</p></div><div class=exampleblock><div class=title>Exemplo 6. Fazendo Backup do Diretório Atual com <code>pax</code></div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pax -wf /tmp/mybackup.pax .</span></code></pre></div></div></div></div></div><div class=sect2><h3 id=backups-tapebackups>17.8.3. Usando Fitas de Dados para Backups<a class=anchor href=#backups-tapebackups></a></h3><div class=paragraph><p>Embora a tecnologia de fitas tenha continuado a evoluir, os sistemas de backup modernos tendem a combinar backups externos com mídias removíveis locais. O FreeBSD suporta qualquer unidade de fita que use SCSI, como LTO ou DAT. Há suporte limitado para as unidades de fita SATA e USB.</p></div><div class=paragraph><p>Para dispositivos de fita SCSI, o FreeBSD usa o driver <a href="https://man.freebsd.org/cgi/man.cgi?query=sa&amp;sektion=4&amp;format=html">sa(4)</a> e os dispositivos <span class=filename>/dev/sa0</span>, <span class=filename>/dev/nsa0</span> e <span class=filename>/dev/esa0</span>. O nome do dispositivo físico é <span class=filename>/dev/sa0</span>. Quando <span class=filename>/dev/nsa0</span> é usado, o aplicativo de backup não rebobina a fita depois de gravar um arquivo, o que permite gravar mais de um arquivo em uma fita. O uso de <span class=filename>/dev/esa0</span> ejeta a fita após o dispositivo ser fechado.</p></div><div class=paragraph><p>No FreeBSD, o <code>mt</code> é usado para controlar as operações da unidade de fita, como procurar arquivos em uma fita ou gravar marcas de controle na fita. Por exemplo, os três primeiros arquivos em uma fita podem ser preservados, ignorando-os antes de gravar um novo arquivo:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mt -f /dev/nsa0 fsf 3</span></code></pre></div></div><div class=paragraph><p>Este utilitário suporta muitas operações. Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=mt&amp;sektion=1&amp;format=html">mt(1)</a> para detalhes.</p></div><div class=paragraph><p>Para gravar um único arquivo em fita usando <code>tar</code>, especifique o nome do dispositivo de fita e o arquivo para backup:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># tar cvf /dev/sa0 file</span></code></pre></div></div><div class=paragraph><p>Para recuperar arquivos de um arquivo <code>tar</code> em fita no diretório atual:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># tar xvf /dev/sa0</span></code></pre></div></div><div class=paragraph><p>Para fazer backup de um sistema de arquivos UFS, use <code>dump</code>. Este exemplo faz o backup de <span class=filename>/usr</span> sem rebobinar a fita quando terminar:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dump -0aL -b64 -f /dev/nsa0 /usr</span></code></pre></div></div><div class=paragraph><p>Para restaurar arquivos interativamente de um arquivo <code>dump</code> em fita no diretório atual:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># restore -i -f /dev/nsa0</span></code></pre></div></div></div><div class=sect2><h3 id=backups-programs-amanda>17.8.4. Utilitários de Backup de Terceiros<a class=anchor href=#backups-programs-amanda></a></h3><div class=paragraph><p>A Coleção de Ports do FreeBSD fornece muitos utilitários de terceiros que podem ser usados para agendar a criação de backups, simplificar o backup em fita e tornar os backups mais fáceis e convenientes. Muitos desses aplicativos são baseados em cliente/servidor e podem ser usados para automatizar os backups de um único sistema ou de todos os computadores em uma rede.</p></div><div class=paragraph><p>Os utilitários populares incluem Amanda, Bacula, rsync e duplicity.</p></div></div><div class=sect2><h3 id=_recuperação_de_emergência>17.8.5. Recuperação de Emergência<a class=anchor href=#_recuperação_de_emergência></a></h3><div class=paragraph><p>Além dos backups regulares, é recomendável executar as etapas a seguir como parte de um plano de preparação para emergências.</p></div><div class=paragraph><p>Crie uma cópia impressa da saída dos seguintes comandos:</p></div><div class=ulist><ul><li><p><code>gpart show</code></p></li><li><p><code>more /etc/fstab</code></p></li><li><p><code>dmesg</code></p></li></ul></div><div class=paragraph><p>Armazene esta saída e uma cópia da mídia de instalação em um local seguro. Se uma restauração de emergência for necessária, inicialize na mídia de instalação e selecione <code>Live CD</code> para acessar um shell de recuperação. Esse modo de recuperação pode ser usado para exibir o estado atual do sistema e, se necessário, reformatar discos e restaurar dados de backups.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>A mídia de instalação do FreeBSD/i386 11.2-RELEASE não inclui um shell de recuperação. Para esta versão, baixe e grave uma imagem do Livefs CD de <a href=ftp://ftp.FreeBSD.org/pub/FreeBSD/releases/i386/ISO-IMAGES/11.2/FreeBSD-11.2-RELEASE-i386-livefs.iso>ftp://ftp.FreeBSD.org/pub/FreeBSD/releases/i386/ISO-IMAGES/11.2/FreeBSD-11.2-RELEASE-i386-livefs.iso</a>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Em seguida, teste o shell de recuperação e os backups. Faça anotações do procedimento. Armazene estas notas com a mídia, as impressões e os backups. Estas notas podem impedir a destruição inadvertida dos backups, enquanto sob o estresse de realizar uma recuperação de emergência.</p></div><div class=paragraph><p>Para uma medida adicional de segurança, armazene o backup mais recente em um local remoto, fisicamente separado dos computadores e das unidades de disco por uma distância significativa.</p></div></div></div></div><div class=sect1><h2 id=disks-virtual>17.9. Discos de Memória<a class=anchor href=#disks-virtual></a></h2><div class=sectionbody><div class=paragraph><p>Além de discos físicos, o FreeBSD também suporta a criação e uso de discos de memória. Um uso possível para um disco de memória é acessar o conteúdo de um sistema de arquivos ISO sem a sobrecarga de primeiro gravá-lo em um CD ou DVD e, em seguida, montar a mídia CD/DVD .</p></div><div class=paragraph><p>No FreeBSD, o driver <a href="https://man.freebsd.org/cgi/man.cgi?query=md&amp;sektion=4&amp;format=html">md(4)</a> é usado para fornecer suporte para discos de memória. O kernel <span class=filename>GENERIC</span> inclui este driver. Ao usar um arquivo de configuração de kernel personalizado, certifique-se de incluir esta linha:</p></div><div class="literalblock programlisting"><div class=content><pre>device md</pre></div></div><div class=sect2><h3 id=disks-mdconfig>17.9.1. Anexando e Desanexando Imagens Existentes<a class=anchor href=#disks-mdconfig></a></h3><div class=paragraph><p>Para montar uma imagem do sistema de arquivos existente, use o <code>mdconfig</code> para especificar o nome do arquivo ISO e um número de unidade livre. Em seguida, consulte esse número de unidade para montá-lo em um ponto de montagem existente. Uma vez montado, os arquivos na imagem ISO aparecerão no ponto de montagem. Este exemplo anexa o arquivo <em>diskimage.iso</em> ao dispositivo de memória <span class=filename>/dev/md0</span> e monta o dispositivo de memória em <span class=filename>/mnt</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mdconfig -f diskimage.iso -u 0</span>
<span class=c># mount -t cd9660 /dev/md0 /mnt</span></code></pre></div></div><div class=paragraph><p>Note que <code>-t cd9660</code> foi usado para montar uma imagem ISO. Se um número de unidade não for especificado com <code>-u</code>, o <code>mdconfig</code> alocará automaticamente um dispositivo de memória não utilizado e exibirá o nome da unidade alocada, como <span class=filename>md4</span>. Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=mdconfig&amp;sektion=8&amp;format=html">mdconfig(8)</a> para mais detalhes sobre este comando e suas opções.</p></div><div class=paragraph><p>Quando um disco de memória não está mais em uso, seus recursos devem ser liberados de volta ao sistema. Primeiro, desmonte o sistema de arquivos e use o <code>mdconfig</code> para desanexar o disco do sistema e liberar seus recursos. Para continuar este exemplo:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># umount /mnt</span>
<span class=c># mdconfig -d -u 0</span></code></pre></div></div><div class=paragraph><p>Para determinar se algum disco de memória ainda está conectado ao sistema, digite <code>mdconfig -l</code>.</p></div></div><div class=sect2><h3 id=disks-md-freebsd5>17.9.2. Criando um Disco Virtual Baseado em Arquivo ou Memória<a class=anchor href=#disks-md-freebsd5></a></h3><div class=paragraph><p>O FreeBSD também suporta discos virtuais onde o armazenamento a ser utilizado é alocado a partir de um disco rígido ou de uma área de memória. O primeiro método é comumente referido como um disco virtual baseado em arquivo e o segundo como um disco virtual baseado em memória. Ambos os tipos podem ser criados usando o <code>mdconfig</code>.</p></div><div class=paragraph><p>Para criar um novo disco virtual baseado em memória, especifique um tipo de <code>swap</code> e o tamanho do disco de memória a ser criado. Em seguida, formate o disco de memória com um sistema de arquivos e monte como de costume. Este exemplo cria um disco de memória de 5M na unidade <code>1</code>. Esse disco de memória é formatado com o sistema de arquivos UFS antes de ser montado:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mdconfig -a -t swap -s 5m -u 1</span>
<span class=c># newfs -U md1</span>
/dev/md1: 5.0MB <span class=o>(</span>10240 sectors<span class=o>)</span> block size 16384, fragment size 2048
        using 4 cylinder <span class=nb>groups </span>of 1.27MB, 81 blks, 192 inodes.
        with soft updates
super-block backups <span class=o>(</span><span class=k>for </span>fsck <span class=nt>-b</span> <span class=c>#) at:</span>
 160, 2752, 5344, 7936
<span class=c># mount /dev/md1 /mnt</span>
<span class=c># df /mnt</span>
Filesystem 1K-blocks Used Avail Capacity  Mounted on
/dev/md1        4718    4  4338     0%    /mnt</code></pre></div></div><div class=paragraph><p>Para criar um novo disco virtual baseado em arquivo, primeiro aloque a área que será usada para o disco. Esse exemplo cria um arquivo vázio de 5MB chamado <span class=filename>newimage</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dd if=/dev/zero of=newimage bs=1k count=5k</span>
5120+0 records <span class=k>in
</span>5120+0 records out</code></pre></div></div><div class=paragraph><p>Em seguida, anexe esse arquivo a um disco de memória, rotule o disco de memória e formate-o com o sistema de arquivos UFS, monte o disco de memória e verifique o tamanho do disco com backup de arquivo:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mdconfig -f newimage -u 0</span>
<span class=c># bsdlabel -w md0 auto</span>
<span class=c># newfs -U md0a</span>
/dev/md0a: 5.0MB <span class=o>(</span>10224 sectors<span class=o>)</span> block size 16384, fragment size 2048
        using 4 cylinder <span class=nb>groups </span>of 1.25MB, 80 blks, 192 inodes.
super-block backups <span class=o>(</span><span class=k>for </span>fsck <span class=nt>-b</span> <span class=c>#) at:</span>
 160, 2720, 5280, 7840
<span class=c># mount /dev/md0a /mnt</span>
<span class=c># df /mnt</span>
Filesystem 1K-blocks Used Avail Capacity  Mounted on
/dev/md0a       4710    4  4330     0%    /mnt</code></pre></div></div><div class=paragraph><p>São necessários vários comandos para criar um disco virtual baseado em arquivo ou memória usando <code>mdconfig</code>. O FreeBSD também vem com o <code>mdmfs</code> que configura automaticamente um disco de memória, formata-o com o sistema de arquivos UFS e o monta. Por exemplo, depois de criar <em>newimage</em> com <code>dd</code>, esse comando é equivalente a executar os comandos <code>bsdlabel</code>, <code>newfs</code> e <code>mount</code> mostrados acima:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mdmfs -F newimage -s 5m md0 /mnt</span></code></pre></div></div><div class=paragraph><p>Para criar um novo disco virtual baseado em memória com o <code>mdmfs</code>, use este comando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mdmfs -s 5m md1 /mnt</span></code></pre></div></div><div class=paragraph><p>Se o número da unidade não for especificado, o <code>mdmfs</code> selecionará automaticamente um dispositivo de memória não utilizado. Para mais detalhes sobre <code>mdmfs</code>, consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=mdmfs&amp;sektion=8&amp;format=html">mdmfs(8)</a>.</p></div></div></div></div><div class=sect1><h2 id=snapshots>17.10. Snapshots de Sistemas de Arquivos<a class=anchor href=#snapshots></a></h2><div class=sectionbody><div class=paragraph><p>O FreeBSD oferece um recurso em conjunto com <a href=../cutting-edge/#soft-updates>Atualizações Soft</a>: snapshots do sistema de arquivos.</p></div><div class=paragraph><p>Os Snapshots de UFS permitem que um usuário crie imagens de sistemas de arquivos especificados e as trate como um arquivo. Os arquivos de snapshot devem ser criados no sistema de arquivos no qual a ação é executada e um usuário pode criar no máximo 20 snapshots por sistema de arquivos. Os snapshots ativos são registradas no superbloco, de modo que são persistentes nas operações de desmontagem e remontagem, juntamente com reinicializações do sistema. Quando um snapshot não é mais necessário, ele pode ser removido usando <a href="https://man.freebsd.org/cgi/man.cgi?query=rm&amp;sektion=1&amp;format=html">rm(1)</a>. Embora os snapshots possam ser removidos em qualquer ordem, todo o espaço usado pode não ser adquirido porque outro snapshot possivelmente reivindicará alguns dos blocos liberados.</p></div><div class=paragraph><p>A flag de arquivo <code>snapshot</code> não alterável é definida por <a href="https://man.freebsd.org/cgi/man.cgi?query=mksnap_ffs&amp;sektion=8&amp;format=html">mksnap_ffs(8)</a> após a criação inicial de um arquivo de snapshot. O <a href="https://man.freebsd.org/cgi/man.cgi?query=unlink&amp;sektion=1&amp;format=html">unlink(1)</a> cria uma exceção para arquivos de snapshots, pois permite que sejam removidos.</p></div><div class=paragraph><p>Os snapshots são criados usando <a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a>. Para colocar um snapshot de <span class=filename>/var</span> no arquivo <span class=filename>/var/snapshot/snap</span>, use o seguinte comando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount -u -o snapshot /var/snapshot/snap /var</span></code></pre></div></div><div class=paragraph><p>Como alternativa, use <a href="https://man.freebsd.org/cgi/man.cgi?query=mksnap_ffs&amp;sektion=8&amp;format=html">mksnap_ffs(8)</a> para criar o snapshot:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mksnap_ffs /var /var/snapshot/snap</span></code></pre></div></div><div class=paragraph><p>É possível encontrar arquivos de snapshots em um sistema de arquivos, como <span class=filename>/var</span>, usando <a href="https://man.freebsd.org/cgi/man.cgi?query=find&amp;sektion=1&amp;format=html">find(1)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># find /var -flags snapshot</span></code></pre></div></div><div class=paragraph><p>Depois que um snapshot foi criado, ele tem vários usos:</p></div><div class=ulist><ul><li><p>Alguns administradores usarão um arquivo de snapshot para fins de backup, porque o snapshot pode ser transferido para um CDs ou fita.</p></li><li><p>O verificador de integridade do sistema de arquivos, <a href="https://man.freebsd.org/cgi/man.cgi?query=fsck&amp;sektion=8&amp;format=html">fsck(8)</a>, pode ser executado em um snapshot. Supondo que o sistema de arquivos estava limpo quando foi montado, isso deve sempre fornecer um resultado limpo e imutável.</p></li><li><p>Executando <a href="https://man.freebsd.org/cgi/man.cgi?query=dump&amp;sektion=8&amp;format=html">dump(8)</a> em um snapshot produzirá um arquivo de dump que seja consistente com o sistema de arquivos e o registro de data e hora do snapshot. <a href="https://man.freebsd.org/cgi/man.cgi?query=dump&amp;sektion=8&amp;format=html">dump(8)</a> também pode criar um snapshot, criar uma imagem de dump e remover o snapshot em um comando usando <code>-L</code>.</p></li><li><p>O snapshot pode ser montado como uma imagem congelada do sistema de arquivos. Para montar o snapshot use <a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a> passando o nome do snapshot <span class=filename>/var/snapshot/snap</span>:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mdconfig -a -t vnode -o readonly -f /var/snapshot/snap -u 4</span>
<span class=c># mount -r /dev/md4 /mnt</span></code></pre></div></div></li></ul></div><div class=paragraph><p>O <span class=filename>/var</span> congelado agora está disponível através de <span class=filename>/mnt</span>. Tudo estará inicialmente no mesmo estado que estava quando o snapshot foi criado. A única exceção é que os snapshots anteriores aparecerão como arquivos com comprimento zero. Para desmontar o snapshot, use:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># umount /mnt</span>
<span class=c># mdconfig -d -u 4</span></code></pre></div></div><div class=paragraph><p>Para obter mais informações sobre <code>softupdates</code> e snapshots do sistema de arquivos, incluindo documentos técnicos, visite o site do Marshall Kirk McKusick em <a href=http://www.mckusick.com/>http://www.mckusick.com/</a>.</p></div></div></div><div class=sect1><h2 id=quotas>17.11. Cotas de Disco<a class=anchor href=#quotas></a></h2><div class=sectionbody><div class=paragraph><p>As cotas de disco podem ser usadas para limitar a quantidade de espaço em disco ou o número de arquivos que um usuário ou membros de um grupo podem alocar em uma base por sistema de arquivos. Isso impede que um usuário ou grupo de usuários consuma todo o espaço em disco disponível.</p></div><div class=paragraph><p>Esta seção descreve como configurar cotas de disco para o sistema de arquivos UFS. Para configurar cotas no sistema de arquivos ZFS, consulte <a href=../zfs/#zfs-zfs-quota>Cotas para Datasets</a></p></div><div class=sect2><h3 id=_habilitando_cotas_de_disco>17.11.1. Habilitando Cotas de Disco<a class=anchor href=#_habilitando_cotas_de_disco></a></h3><div class=paragraph><p>Para determinar se o kernel do FreeBSD fornece suporte para cotas de disco:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% sysctl kern.features.ufs_quota
kern.features.ufs_quota: 1</code></pre></div></div><div class=paragraph><p>Neste exemplo, o <code>1</code> indica suporte à cota. Se o valor for <code>0</code>, adicione a seguinte linha a um arquivo de configuração de kernel personalizado e reconstrua o kernel usando as instruções em <a href=../kernelconfig/#kernelconfig>Configurando o kernel do FreeBSD</a>:</p></div><div class="literalblock programlisting"><div class=content><pre>options QUOTA</pre></div></div><div class=paragraph><p>Em seguida, habilite as cotas de disco no arquivo <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>quota_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Normalmente, na inicialização, a integridade da cota de cada sistema de arquivos é verificada por <a href="https://man.freebsd.org/cgi/man.cgi?query=quotacheck&amp;sektion=8&amp;format=html">quotacheck(8)</a>. Esse programa garante que os dados no banco de dados de cotas reflitam adequadamente os dados no sistema de arquivos. Este é um processo demorado que afetará significativamente o tempo que o sistema leva para inicializar. Para pular este passo, adicione esta variável ao arquivo <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>check_quotas=&#34;NO&#34;</pre></div></div><div class=paragraph><p>Por fim, edite o arquivo <span class=filename>/etc/fstab</span> para habilitar as cotas de disco por sistema de arquivos. Para habilitar cotas por usuário em um sistema de arquivos, adicione <code>userquota</code> ao campo de opções na entrada <span class=filename>/etc/fstab</span> para o sistema de arquivos ativar as cotas. Por exemplo:</p></div><div class="literalblock programlisting"><div class=content><pre>/dev/da1s2g   /home    ufs rw,userquota 1 2</pre></div></div><div class=paragraph><p>Para ativar cotas de grupo, use <code>groupquota</code>. Para ativar cotas de usuários e grupos, separe as opções com uma vírgula:</p></div><div class="literalblock programlisting"><div class=content><pre>/dev/da1s2g    /home    ufs rw,userquota,groupquota 1 2</pre></div></div><div class=paragraph><p>Por padrão, os arquivos de cota são armazenados no diretório raiz do sistema de arquivos como <span class=filename>quota.user</span> e <span class=filename>quota.group</span>. Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=fstab&amp;sektion=5&amp;format=html">fstab(5)</a> para obter mais informações. Especificar um local alternativo para os arquivos de cotas não é recomendado.</p></div><div class=paragraph><p>Quando a configuração estiver concluída, reinicialize o sistema e o <span class=filename>/etc/rc</span> executará automaticamente os comandos apropriados para criar os arquivos de cotas iniciais para todas as cotas ativadas em <span class=filename>/etc/fstab</span>.</p></div><div class=paragraph><p>No curso normal das operações, não deve haver necessidade de executar manualmente o <a href="https://man.freebsd.org/cgi/man.cgi?query=quotacheck&amp;sektion=8&amp;format=html">quotacheck(8)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=quotaon&amp;sektion=8&amp;format=html">quotaon(8)</a>, ou <a href="https://man.freebsd.org/cgi/man.cgi?query=quotaoff&amp;sektion=8&amp;format=html">quotaoff(8)</a>. No entanto, deve-se ler estas páginas de manual para se familiarizar com sua operação.</p></div></div><div class=sect2><h3 id=_definindo_limites_de_cota>17.11.2. Definindo Limites de Cota<a class=anchor href=#_definindo_limites_de_cota></a></h3><div class=paragraph><p>Para verificar se as cotas estão ativadas, execute:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># quota -v</span></code></pre></div></div><div class=paragraph><p>Deve haver um resumo de uma linha sobre o uso de disco e limites de cota atuais para cada sistema de arquivos em que as cotas estão ativadas.</p></div><div class=paragraph><p>O sistema agora está pronto para receber limites de cota com <code>edquota</code>.</p></div><div class=paragraph><p>Várias opções estão disponíveis para impor limites à quantidade de espaço em disco que um usuário ou grupo pode alocar e quantos arquivos eles podem criar. As alocações podem ser limitadas com base no espaço em disco (cotas de bloco), no número de arquivos (cotas de inode) ou em uma combinação de ambos. Cada limite é subdividido em duas categorias: limites rígidos e flexíveis.</p></div><div class=paragraph><p>Um limite rígido não pode ser excedido. Quando um usuário atinge um limite rígido, nenhuma outra alocação pode ser feita nesse sistema de arquivos por esse usuário. Por exemplo, se o usuário tiver um limite rígido de 500 kbytes em um sistema de arquivos e estiver usando atualmente 490 kbytes, o usuário poderá alocar apenas 10 kbytes adicionais. A tentativa de alocar 11 kbytes adicionais falhará.</p></div><div class=paragraph><p>Os limites flexíveis podem ser excedidos por um período de tempo limitado, conhecido como período de tolerância, que é uma semana por padrão. Se um usuário permanecer acima do limite por mais tempo do que o período de carência, o limite flexível se tornará um limite rígido e nenhuma outra alocação será permitida. Quando o usuário cai abaixo do limite flexível, o período de carência é zerado.</p></div><div class=paragraph><p>No exemplo a seguir, a cota da conta <code>test</code> está sendo editada. Quando <code>edquota</code> é invocado, o editor especificado por <code>EDITOR</code> é aberto para editar os limites de cota. O editor padrão é configurado para vi.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># edquota -u test</span>
Quotas <span class=k>for </span>user <span class=nb>test</span>:
/usr: kbytes <span class=k>in </span>use: 65, limits <span class=o>(</span>soft <span class=o>=</span> 50, hard <span class=o>=</span> 75<span class=o>)</span>
        inodes <span class=k>in </span>use: 7, limits <span class=o>(</span>soft <span class=o>=</span> 50, hard <span class=o>=</span> 60<span class=o>)</span>
/usr/var: kbytes <span class=k>in </span>use: 0, limits <span class=o>(</span>soft <span class=o>=</span> 50, hard <span class=o>=</span> 75<span class=o>)</span>
        inodes <span class=k>in </span>use: 0, limits <span class=o>(</span>soft <span class=o>=</span> 50, hard <span class=o>=</span> 60<span class=o>)</span></code></pre></div></div><div class=paragraph><p>Normalmente, há duas linhas para cada sistema de arquivos com cotas ativadas. Uma linha representa os limites do bloco e a outra representa os limites do inode. Altere o valor para modificar o limite de cota. Por exemplo, para aumentar o limite de blocos em <span class=filename>/usr</span> para um limite flexível de <code>500</code> e um limite rígido de <code>600</code>, altere os valores nesse campo. linha da seguinte forma:</p></div><div class="literalblock programlisting"><div class=content><pre>/usr: kbytes in use: 65, limits (soft = 500, hard = 600)</pre></div></div><div class=paragraph><p>Os novos limites de cotas entram em vigor ao sair do editor.</p></div><div class=paragraph><p>Às vezes, é desejável definir limites de cota em vários usuários. Isso pode ser feito primeiro atribuindo o limite de cota desejado a um usuário. Em seguida, use <code>-p</code> para duplicar essa cota para um intervalo especificado de IDs de usuário (UIDs). O comando a seguir duplicará esses limites de cota para UIDs de <code>10.000</code> até <code>19.999</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># edquota -p test 10000-19999</span></code></pre></div></div><div class=paragraph><p>Para mais informações, consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=edquota&amp;sektion=8&amp;format=html">edquota(8)</a>.</p></div></div><div class=sect2><h3 id=_verificando_limites_de_cota_e_uso_de_disco>17.11.3. Verificando Limites de Cota e Uso de Disco<a class=anchor href=#_verificando_limites_de_cota_e_uso_de_disco></a></h3><div class=paragraph><p>Para verificar cotas individuais de usuários ou de grupos e uso de disco, use <a href="https://man.freebsd.org/cgi/man.cgi?query=quota&amp;sektion=1&amp;format=html">quota(1)</a>. Um usuário só pode examinar sua própria cota e a cota de um grupo do qual é membro. Somente o superusuário pode visualizar todas as cotas de usuários e grupos. Para obter um resumo de todas as cotas e uso de disco para sistemas de arquivos com cotas ativadas, use <a href="https://man.freebsd.org/cgi/man.cgi?query=repquota&amp;sektion=8&amp;format=html">repquota(8)</a>.</p></div><div class=paragraph><p>Normalmente, os sistemas de arquivos nos quais o usuário não está usando nenhum espaço em disco não serão exibidos na saída de <code>quota</code>, mesmo que o usuário tenha um limite de cota atribuído a esse sistema de arquivos. Use <code>-v</code> para exibir esses sistemas de arquivos. A seguir está a saída de amostra de <code>quota -v</code> para um usuário que possui limites de cota em dois sistemas de arquivos.</p></div><div class="literalblock programlisting"><div class=content><pre>Disk quotas for user test (uid 1002):
     Filesystem  usage    quota   limit   grace   files   quota   limit   grace
           /usr      65*     50      75   5days       7      50      60
       /usr/var       0      50      75               0      50      60</pre></div></div><div class=paragraph><p>Neste exemplo, o usuário está atualmente 15 kbytes sobre o limite flexível de 50 kbytes em <span class=filename>/usr</span> e tem 5 dias de período de carência restante. O asterisco <code>*</code> indica que o usuário está atualmente acima do limite de cota.</p></div></div><div class=sect2><h3 id=_quotas_sobre_o_nfs>17.11.4. Quotas sobre o NFS<a class=anchor href=#_quotas_sobre_o_nfs></a></h3><div class=paragraph><p>As cotas são impostas pelo subsistema de cotas no servidor NFS. O daemon <a href="https://man.freebsd.org/cgi/man.cgi?query=rpc.rquotad&amp;sektion=8&amp;format=html">rpc.rquotad(8)</a> disponibiliza informações de quota para <code>quota</code> em clientes NFS, permitindo que os usuários nessas máquinas visualizem suas estatísticas de cota.</p></div><div class=paragraph><p>No servidor NFS, ative o <code>rpc.rquotad</code> removendo o <code>#</code> desta linha em <span class=filename>/etc/inetd.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>rquotad/1      dgram rpc/udp wait root /usr/libexec/rpc.rquotad rpc.rquotad</pre></div></div><div class=paragraph><p>Em seguida, reinicie o <code>inetd</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service inetd restart</span></code></pre></div></div></div></div></div><div class=sect1><h2 id=disks-encrypting>17.12. Criptografando Partições de Disco<a class=anchor href=#disks-encrypting></a></h2><div class=sectionbody><div class=paragraph><p>O FreeBSD oferece excelentes proteções on-line contra acesso não autorizado a dados. As permissões de arquivo e o <a href=../mac/#mac>Mandatory Access Control</a> (MAC) ajudam a impedir que usuários não autorizados acessem dados enquanto o sistema operacional está ativo e o computador está ligado. No entanto, as permissões impostas pelo sistema operacional são irrelevantes se um invasor tiver acesso físico a um computador e puder mover o disco rígido do computador para outro sistema para copiar e analisar os dados.</p></div><div class=paragraph><p>Independentemente de como um invasor pode ter acesso a um disco rígido ou um computador desligado, os subsistemas criptográficos baseados em GEOM incorporados ao FreeBSD são capazes de proteger os dados nos sistemas de arquivos do computador contra atacantes super motivados com recursos significativos. Ao contrário dos métodos de criptografia que criptografam arquivos individuais, os utilitários incorporados <code>gbde</code> e <code>geli</code> podem ser usados para criptografar de forma transparente sistemas de arquivos inteiros. Nenhum dado aberto sequer toca na bandeja do disco rígido.</p></div><div class=paragraph><p>Este capítulo demonstra como criar um sistema de arquivos criptografado no FreeBSD. Primeiro ele demonstra o processo usando o <code>gbde</code> e depois demonstra o mesmo exemplo usando <code>geli</code>.</p></div><div class=sect2><h3 id=_criptografia_de_disco_com_gbde>17.12.1. Criptografia de Disco com gbde<a class=anchor href=#_criptografia_de_disco_com_gbde></a></h3><div class=paragraph><p>O objetivo do utilitário <a href="https://man.freebsd.org/cgi/man.cgi?query=gbde&amp;sektion=4&amp;format=html">gbde(4)</a> é fornecer um desafio formidável para que um invasor que tenha acesso ao conteúdo de um dispositivo de armazenamento <em>frio</em>. No entanto, se o computador for comprometido enquanto estiver em funcionamento e o dispositivo de armazenamento estiver ativamente conectado, ou se o invasor tiver acesso a uma frase secreta válida, ele não oferecerá proteção ao conteúdo do dispositivo de armazenamento. Portanto, é importante fornecer segurança física enquanto o sistema está em execução e proteger a frase secreta usada pelo mecanismo de criptografia.</p></div><div class=paragraph><p>Este recurso oferece várias barreiras para proteger os dados armazenados em cada setor de disco. Ele criptografa o conteúdo de um setor de disco usando o AES de 128 bits no modo CBC. Cada setor no disco é criptografado com uma chave AES diferente. Para obter mais informações sobre o design criptográfico, incluindo como as chaves do setor são derivadas da frase secreta fornecida pelo usuário, consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=gbde&amp;sektion=4&amp;format=html">gbde(4)</a>.</p></div><div class=paragraph><p>O FreeBSD fornece um módulo do kernel para gbde, que pode ser carregado com este comando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload geom_bde</span></code></pre></div></div><div class=paragraph><p>Se estiver usando um arquivo de configuração de kernel personalizado, certifique-se de que ele contenha esta linha:</p></div><div class=paragraph><p><code>options GEOM_BDE</code></p></div><div class=paragraph><p>O exemplo a seguir demonstra a adição de um novo disco rígido a um sistema que conterá uma única partição criptografada que será montada como <span class=filename>/private</span>.</p></div><div class="exampleblock procedure"><div class=content><div class=paragraph><p><strong>Procedure: Criptografando uma Partição com gbde</strong></p></div><div class="olist arabic"><ol class=arabic><li><p>Adicione o Novo Disco Rígido</p><div class=paragraph><p>Instale a nova unidade no sistema, conforme explicado em <a href=#disks-adding>Adicionando Discos</a>. Para propósitos deste exemplo, uma nova partição de disco rígido foi adicionada como <span class=filename>/dev/ad4s1c</span> e <span class=filename>/dev/ad0s1*</span> representa o existente partições padrão do FreeBSD.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ls /dev/ad*</span>
/dev/ad0        /dev/ad0s1b     /dev/ad0s1e     /dev/ad4s1
/dev/ad0s1      /dev/ad0s1c     /dev/ad0s1f     /dev/ad4s1c
/dev/ad0s1a     /dev/ad0s1d     /dev/ad4</code></pre></div></div></li><li><p>Criar um diretório para conter os arquivos de lock do <code>gbde</code></p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mkdir /etc/gbde</span></code></pre></div></div><div class=paragraph><p>O arquivo de lock gbde contém informações que o gbde requer para acessar partições criptografadas. Sem acesso ao arquivo de lock, o gbde não poderá descriptografar os dados contidos na partição criptografada sem intervenção manual significativa que não seja suportada pelo software. Cada partição criptografada usa um arquivo de lock separado.</p></div></li><li><p>Inicialize a Partição <code>gbde</code></p><div class=paragraph><p>Uma partição gbde deve ser inicializada antes de poder ser usada. Essa inicialização precisa ser executada apenas uma vez. Esse comando abrirá o editor padrão, para definir várias opções de configuração em um modelo. Para uso com o sistema de arquivos UFS, defina o sector_size como 2048:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gbde init /dev/ad4s1c -i -L /etc/gbde/ad4s1c.lock</span>
<span class=c># $FreeBSD: head/pt_BR.ISO8859-1/books/handbook/book.xml 53984 2020-03-15 16:03:31Z dbaio $</span>
<span class=c>#</span>
<span class=c># Sector size is the smallest unit of data which can be read or written.</span>
<span class=c># Making it too small decreases performance and decreases available space.</span>
<span class=c># Making it too large may prevent filesystems from working.  512 is the</span>
<span class=c># minimum and always safe.  For UFS, use the fragment size</span>
<span class=c>#</span>
sector_size	<span class=o>=</span>	2048
<span class=o>[</span>...]</code></pre></div></div><div class=paragraph><p>Depois que a edição for salva, o usuário será solicitado a digitar duas vezes a frase secreta usada para proteger os dados. A frase secreta deve ser a mesma em ambas as vezes. A capacidade de gbde de proteger os dados depende inteiramente da qualidade da frase secreta. Para obter dicas sobre como selecionar uma frase secreta que seja fácil de lembrar, consulte <a href=http://world.std.com/~reinhold/diceware.html>http://world.std.com/~reinhold/diceware.htm</a>.</p></div><div class=paragraph><p>Essa inicialização cria um arquivo de lock para a partição do gbde. Neste exemplo, ele é armazenado como <span class=filename>/etc/gbde/ad4s1c.lock</span>. Os arquivos de lock devem terminar em ".lock" para serem corretamente detectados pelo script de inicialização do <span class=filename>/etc/rc.d/gbde</span>.</p></div><div class="admonitionblock caution"><table><tbody><tr><td class=icon><i class="fa icon-caution" title=Caution></i></td><td class=content><div class=paragraph><p>Arquivos de lock <em>devem</em> ter backups junto com o conteúdo de qualquer partição criptografada. Sem o arquivo de lock, o proprietário legítimo não poderá acessar os dados na partição criptografada.</p></div></td></tr></tbody></table></div></li><li><p>Anexando a Partição Criptografada ao Kernel</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gbde attach /dev/ad4s1c -l /etc/gbde/ad4s1c.lock</span></code></pre></div></div><div class=paragraph><p>Este comando solicitará a entrada da senha que foi selecionada durante a inicialização da partição criptografada. O novo dispositivo criptografado aparecerá em <span class=filename>/dev</span> como <span class=filename>/dev/device_name.bde</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ls /dev/ad*</span>
/dev/ad0        /dev/ad0s1b     /dev/ad0s1e     /dev/ad4s1
/dev/ad0s1      /dev/ad0s1c     /dev/ad0s1f     /dev/ad4s1c
/dev/ad0s1a     /dev/ad0s1d     /dev/ad4        /dev/ad4s1c.bde</code></pre></div></div></li><li><p>Criando um Sistema de Arquivos no Dispositivo Criptografado</p><div class=paragraph><p>Uma vez que o dispositivo criptografado tenha sido anexado ao kernel, um sistema de arquivos pode ser criado no dispositivo. Este exemplo cria um sistema de arquivos UFS com atualizações soft ativadas. Certifique-se de especificar a partição que possui uma extensão <span class=filename>*.bde</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># newfs -U /dev/ad4s1c.bde</span></code></pre></div></div></li><li><p>Montando a Partição Criptografada</p><div class=paragraph><p>Crie um ponto de montagem e monte o sistema de arquivos criptografados:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mkdir /private</span>
<span class=c># mount /dev/ad4s1c.bde /private</span></code></pre></div></div></li><li><p>Verificar se o sistema de arquivos criptografados está disponível</p><div class=paragraph><p>O sistema de arquivos criptografados agora deve estar visível e disponível para uso:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>df</span> <span class=nt>-H</span>
Filesystem        Size   Used  Avail Capacity  Mounted on
/dev/ad0s1a      1037M    72M   883M     8%    /
/devfs            1.0K   1.0K     0B   100%    /dev
/dev/ad0s1f       8.1G    55K   7.5G     0%    /home
/dev/ad0s1e      1037M   1.1M   953M     0%    /tmp
/dev/ad0s1d       6.1G   1.9G   3.7G    35%    /usr
/dev/ad4s1c.bde   150G   4.1K   138G     0%    /private</code></pre></div></div></li></ol></div></div></div><div class=paragraph><p>Após cada inicialização, todos os sistemas de arquivos criptografados devem ser reconectados manualmente ao kernel, verificados quanto a erros e montados antes que os sistemas de arquivos possam ser usados. Para configurar estas etapas, adicione as seguintes linhas ao arquivo <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>gbde_autoattach_all=&#34;YES&#34;
gbde_devices=&#34;ad4s1c&#34;
gbde_lockdir=&#34;/etc/gbde&#34;</pre></div></div><div class=paragraph><p>Isso requer que a frase secreta seja inserida no console no momento da inicialização. Depois de digitar a senha correta, a partição criptografada será montada automaticamente. Opções adicionais de inicialização do gbde estão disponíveis e listadas em <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>O sysinstall é incompatível com os dispositivos criptografados com gbde. Todos os dispositivos <span class=filename>*.bde</span> devem ser desanexado do kernel antes de iniciar o sysinstall ou ele irá travar durante a análise inicial dos dispositivos. Para desanexar o dispositivo criptografado usado no exemplo, use o seguinte comando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gbde detach /dev/ad4s1c</span></code></pre></div></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=disks-encrypting-geli>17.12.2. Criptografia de Disco com <code>geli</code><a class=anchor href=#disks-encrypting-geli></a></h3><div class=paragraph><p>Uma classe criptográfica alternativa GEOM está disponível usando <code>geli</code>. Este utilitário de controle adiciona alguns recursos e usa um esquema diferente para fazer trabalho criptográfico. Ele fornece os seguintes recursos:</p></div><div class=ulist><ul><li><p>Utiliza o framework <a href="https://man.freebsd.org/cgi/man.cgi?query=crypto&amp;sektion=9&amp;format=html">crypto(9)</a> e usa automaticamente o hardware criptográfico quando ele está disponível.</p></li><li><p>Suporta vários algoritmos criptográficos, como AES, Blowfish e 3DES.</p></li><li><p>Permite que a partição raiz seja criptografada. A frase secreta usada para acessar a partição root criptografada será solicitada durante a inicialização do sistema.</p></li><li><p>Permite o uso de duas chaves independentes.</p></li><li><p>É rápido, pois executa criptografia simples de setor a setor.</p></li><li><p>Permite backup e restauração de chaves mestras. Se um usuário destruir suas chaves, ainda é possível obter acesso aos dados restaurando as chaves do backup.</p></li><li><p>Permite que um disco seja anexado com uma chave única aleatória que é útil para partições swap e sistemas de arquivos temporários.</p></li></ul></div><div class=paragraph><p>Mais recursos e exemplos de uso podem ser encontrados em <a href="https://man.freebsd.org/cgi/man.cgi?query=geli&amp;sektion=8&amp;format=html">geli(8)</a>.</p></div><div class=paragraph><p>O exemplo a seguir descreve como gerar um arquivo de chave que será usado como parte da chave mestra para o provedor criptografado montado em <span class=filename>/private</span>. O arquivo chave fornecerá alguns dados aleatórios usados para criptografar a chave mestra. A chave mestra também será protegida por uma frase secreta. O tamanho do setor do provedor será de 4kB. O exemplo descreve como se conectar ao provedor <code>geli</code>, criar um sistema de arquivos, montá-lo, trabalhar com ele e, finalmente, como desanexá-lo.</p></div><div class="exampleblock procedure"><div class=content><div class=paragraph><p><strong>Procedure: Criptografando uma Partição com <code>geli</code></strong></p></div><div class="olist arabic"><ol class=arabic><li><p>Carregando o suporte ao <code>geli</code></p><div class=paragraph><p>O suporte para <code>geli</code> está disponível como um módulo de kernel carregável. Para configurar o sistema para carregar automaticamente o módulo no momento da inicialização, adicione a seguinte linha ao arquivo <span class=filename>/boot/loader.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>geom_eli_load=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Para carregar o módulo do kernel agora:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload geom_eli</span></code></pre></div></div><div class=paragraph><p>Para um kernel customizado, assegure-se de que o arquivo de configuração do kernel contenha estas linhas:</p></div><div class="literalblock programlisting"><div class=content><pre>options GEOM_ELI
device crypto</pre></div></div></li><li><p>Gerando a Chave Mestra</p><div class=paragraph><p>Os comandos a seguir geram uma chave mestra com a qual todos os dados serão criptografados. Esta chave nunca pode ser alterada. Em vez de usá-lo diretamente, ele é criptografado com uma ou mais chaves de usuário. As chaves do usuário são compostas por uma combinação opcional de bytes aleatórios de um arquivo, <span class=filename>/root/da2.key</span> e/ou uma senha. Neste caso, a fonte de dados do arquivo de chave é <span class=filename>/dev/random</span>. Este comando também configura o tamanho do setor do provedor (<span class=filename>/dev/da2.eli</span>) como 4kB, para melhor desempenho:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dd if=/dev/random of=/root/da2.key bs=64 count=1</span>
<span class=c># geli init -K /root/da2.key -s 4096 /dev/da2</span>
Enter new passphrase:
Reenter new passphrase:</code></pre></div></div><div class=paragraph><p>Não é obrigatório o uso de uma frase secreta e de um arquivo de chave, pois cada método de proteger a chave mestra pode ser usado isoladamente.</p></div><div class=paragraph><p>Se o arquivo de chave é dado como "-", a entrada padrão será usada. Por exemplo, este comando gera três arquivos principais:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cat keyfile1 keyfile2 keyfile3 | geli init -K - /dev/da2</span></code></pre></div></div></li><li><p>Anexando o Provedor com a Chave Gerada</p><div class=paragraph><p>Para anexar o provedor, especifique o arquivo de chave, o nome do disco e a frase secreta:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># geli attach -k /root/da2.key /dev/da2</span>
Enter passphrase:</code></pre></div></div><div class=paragraph><p>Isso cria um novo dispositivo com uma extensão <span class=filename>.eli</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ls /dev/da2*</span>
/dev/da2  /dev/da2.eli</code></pre></div></div></li><li><p>Criando o Novo Sistema de Arquivos</p><div class=paragraph><p>Em seguida, formate o dispositivo com o sistema de arquivos UFS e monte-o em um ponto de montagem existente:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dd if=/dev/random of=/dev/da2.eli bs=1m</span>
<span class=c># newfs /dev/da2.eli</span>
<span class=c># mount /dev/da2.eli /private</span></code></pre></div></div><div class=paragraph><p>O sistema de arquivos criptografado agora deve estar disponível para uso:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># df -H</span>
Filesystem     Size   Used  Avail Capacity  Mounted on
/dev/ad0s1a    248M    89M   139M    38%    /
/devfs         1.0K   1.0K     0B   100%    /dev
/dev/ad0s1f    7.7G   2.3G   4.9G    32%    /usr
/dev/ad0s1d    989M   1.5M   909M     0%    /tmp
/dev/ad0s1e    3.9G   1.3G   2.3G    35%    /var
/dev/da2.eli   150G   4.1K   138G     0%    /private</code></pre></div></div></li></ol></div></div></div><div class=paragraph><p>Uma vez que o trabalho na partição criptografada é feito, e a partição <span class=filename>/private</span> não é mais necessária, é prudente colocar o dispositivo no armazenamento frio desmontando e desanexando a partição <code>geli</code> criptografada do kernel:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># umount /private</span>
<span class=c># geli detach da2.eli</span></code></pre></div></div><div class=paragraph><p>Um script <span class=filename>rc.d</span> é fornecido para simplificar a montagem de dispositivos criptografados <code>geli</code> no momento da inicialização. Para este exemplo, adicione estas linhas ao arquivo <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>geli_devices=&#34;da2&#34;
geli_da2_flags=&#34;-k /root/da2.key&#34;</pre></div></div><div class=paragraph><p>Isto configura o <span class=filename>/dev/da2</span> como um provedor <code>geli</code> com uma chave mestra de <span class=filename>/root/da2.key</span>. O sistema irá desanexando automaticamente o provedor do kernel antes que o sistema seja desligado. Durante o processo de inicialização, o script solicitará a frase secreta antes de conectar o provedor. Outras mensagens do kernel podem ser mostradas antes e depois do prompt da frase secreta. Se o processo de inicialização parecer travar, procure cuidadosamente o prompt de senha entre as outras mensagens. Depois que a frase secreta correta é inserida, o provedor é anexado. O sistema de arquivos é então montado, normalmente por uma entrada em <span class=filename>/etc/fstab</span>. Consulte <a href=../basics/#mount-unmount>Montando e Desmontando Sistemas de Arquivos</a> para obter instruções sobre como configurar um sistema de arquivos para montar no momento da inicialização.</p></div></div></div></div><div class=sect1><h2 id=swap-encrypting>17.13. Criptografando Swap<a class=anchor href=#swap-encrypting></a></h2><div class=sectionbody><div class=paragraph><p>Como a criptografia de partições de disco, a criptografia do espaço swap é usada para proteger informações confidenciais. Considere um aplicativo que lida com senhas. Contanto que essas senhas permaneçam na memória física, elas não serão gravadas no disco e serão apagadas após a reinicialização. No entanto, se o FreeBSD iniciar a troca de páginas de memória para liberar espaço, as senhas podem ser gravadas no disco não criptografadas. O espaço de troca de criptografia pode ser uma solução para esse cenário.</p></div><div class=paragraph><p>Esta seção demonstra como configurar uma partição swap criptografada usando criptografia <a href="https://man.freebsd.org/cgi/man.cgi?query=gbde&amp;sektion=8&amp;format=html">gbde(8)</a> ou <a href="https://man.freebsd.org/cgi/man.cgi?query=geli&amp;sektion=8&amp;format=html">geli(8)</a>. Ele assume que <span class=filename>/dev/ada0s1b</span> é a partição swap.</p></div><div class=sect2><h3 id=_configurando_swap_criptografada>17.13.1. Configurando Swap Criptografada<a class=anchor href=#_configurando_swap_criptografada></a></h3><div class=paragraph><p>As partições de swap não são criptografadas por padrão e devem ser limpas de quaisquer dados confidenciais antes de continuar. Para sobrescrever a partição swap atual com lixo aleatório, execute o seguinte comando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dd if=/dev/random of=/dev/ada0s1b bs=1m</span></code></pre></div></div><div class=paragraph><p>Para criptografar a partição swap usando <a href="https://man.freebsd.org/cgi/man.cgi?query=gbde&amp;sektion=8&amp;format=html">gbde(8)</a>, adicione o sufixo <code>.bde</code> à linha de swap no <span class=filename>/etc/fstab</span>:</p></div><div class="literalblock programlisting"><div class=content><pre># Device		Mountpoint	FStype	Options		Dump	Pass#
/dev/ada0s1b.bde	none		swap	sw		0	0</pre></div></div><div class=paragraph><p>Para criptografar a partição swap usando <a href="https://man.freebsd.org/cgi/man.cgi?query=geli&amp;sektion=8&amp;format=html">geli(8)</a>, use o sufixo <code>.eli</code>:</p></div><div class="literalblock programlisting"><div class=content><pre># Device		Mountpoint	FStype	Options		Dump	Pass#
/dev/ada0s1b.eli	none		swap	sw		0	0</pre></div></div><div class=paragraph><p>Por padrão, <a href="https://man.freebsd.org/cgi/man.cgi?query=geli&amp;sektion=8&amp;format=html">geli(8)</a> usa o algoritmo AES com um comprimento de chave de 128 bits. Normalmente, as configurações padrão serão suficientes. Se desejado, estes padrões podem ser alterados no campo de opções no arquivo <span class=filename>/etc/fstab</span>. As possíveis flags são:</p></div><div class=dlist><dl><dt class=hdlist1>aalgo</dt><dd><p>Algoritmo de verificação de integridade de dados usado para garantir que os dados criptografados não tenham sido adulterados. Veja <a href="https://man.freebsd.org/cgi/man.cgi?query=geli&amp;sektion=8&amp;format=html">geli(8)</a> para obter uma lista dos algoritmos suportados.</p></dd><dt class=hdlist1>ealgo</dt><dd><p>Algoritmo de criptografia usado para proteger os dados. Veja <a href="https://man.freebsd.org/cgi/man.cgi?query=geli&amp;sektion=8&amp;format=html">geli(8)</a> para obter uma lista dos algoritmos suportados.</p></dd><dt class=hdlist1>keylen</dt><dd><p>O comprimento da chave usada para o algoritmo de criptografia. Veja <a href="https://man.freebsd.org/cgi/man.cgi?query=geli&amp;sektion=8&amp;format=html">geli(8)</a> para os comprimentos de chave que são suportados por cada algoritmo de criptografia.</p></dd><dt class=hdlist1>sectorsize</dt><dd><p>O tamanho em que o blocos de dados é dividido antes de ser criptografado. Tamanhos de setor maiores aumentam o desempenho ao custo de maior sobrecarga de armazenamento. O tamanho recomendado é de 4096 bytes.</p></dd></dl></div><div class=paragraph><p>Este exemplo configura uma partição swap criptografada usando o algoritmo Blowfish com um comprimento de chave de 128 bits e um setor de tamanho de 4 kilobytes:</p></div><div class="literalblock programlisting"><div class=content><pre># Device		Mountpoint	FStype	Options				Dump	Pass#
/dev/ada0s1b.eli	none		swap	sw,ealgo=blowfish,keylen=128,sectorsize=4096	0	0</pre></div></div></div><div class=sect2><h3 id=_verificação_de_swap_criptografada>17.13.2. Verificação de Swap Criptografada<a class=anchor href=#_verificação_de_swap_criptografada></a></h3><div class=paragraph><p>Depois que o sistema for reinicializado, a operação adequada da swap criptografada poderá ser verificada usando <code>swapinfo</code>.</p></div><div class=paragraph><p>Se <a href="https://man.freebsd.org/cgi/man.cgi?query=gbde&amp;sektion=8&amp;format=html">gbde(8)</a> estiver sendo usado:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% swapinfo
Device          1K-blocks     Used    Avail Capacity
/dev/ada0s1b.bde   542720        0   542720     0%</code></pre></div></div><div class=paragraph><p>Se <a href="https://man.freebsd.org/cgi/man.cgi?query=geli&amp;sektion=8&amp;format=html">geli(8)</a> estiver sendo usado:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% swapinfo
Device          1K-blocks     Used    Avail Capacity
/dev/ada0s1b.eli   542720        0   542720     0%</code></pre></div></div></div></div></div><div class=sect1><h2 id=disks-hast>17.14. Alta Disponibilidade de Armazenamento (HAST)<a class=anchor href=#disks-hast></a></h2><div class=sectionbody><div class=paragraph><p>A alta disponibilidade é um dos principais requisitos em aplicativos de negócios sérios e o armazenamento altamente disponível é um componente-chave nesses ambientes. No FreeBSD, o framework Alta Disponiblidade de Armazenamento (HAST) permite o armazenamento transparente dos mesmos dados em várias máquinas fisicamente separadas conectadas por uma rede TCP/IP. HAST pode ser entendido como um RAID1 (mirror) baseado em rede, e é similar ao sistema de armazenamento DRBD® usado na plataforma GNU/Linux™. Em combinação com outros recursos de alta disponibilidade do FreeBSD, como o CARP, o HAST possibilita a criação de um cluster de armazenamento altamente disponível, resistente a falhas de hardware.</p></div><div class=paragraph><p>A seguir estão as principais características do HAST:</p></div><div class=ulist><ul><li><p>Pode ser usado para mascarar erros de I/O em discos rígidos locais.</p></li><li><p>Agnóstico a sistema de arquivos, pois funciona com qualquer sistema de arquivos suportado pelo FreeBSD.</p></li><li><p>Ressincronização eficiente e rápida, pois somente os blocos que foram modificados durante o tempo de inatividade de um nó são sincronizados.</p></li><li><p>Pode ser usado em um ambiente já implantado para adicionar redundância adicional.</p></li><li><p>Juntamente com o CARP, Heartbeat, ou outras ferramentas, ele pode ser usado para construir um sistema de armazenamento robusto e durável.</p></li></ul></div><div class=paragraph><p>Depois de ler esta seção, você saberá:</p></div><div class=ulist><ul><li><p>O que é HAST, como ele funciona e quais recursos ele fornece.</p></li><li><p>Como configurar e usar o HAST no FreeBSD.</p></li><li><p>Como integrar CARP e <a href="https://man.freebsd.org/cgi/man.cgi?query=devd&amp;sektion=8&amp;format=html">devd(8)</a> para criar um sistema de armazenamento robusto.</p></li></ul></div><div class=paragraph><p>Antes de ler esta seção, você deve:</p></div><div class=ulist><ul><li><p>Entender os fundamentos do UNIX™ e do FreeBSD (<a href=../basics/#basics>Fundamentos do FreeBSD</a>).</p></li><li><p>Saber como configurar interfaces de rede e outros subsistemas principais do FreeBSD (<a href=../config/#config-tuning>Configuração e Ajuste</a>).</p></li><li><p>Ter uma boa compreensão da rede do FreeBSD (<a href=../partiv/#network-communication>Comunicação de rede</a>).</p></li></ul></div><div class=paragraph><p>O projeto HAST foi patrocinado pela Fundação FreeBSD com o apoio de <a href=http://www.omc.net/>http://www.omc.net/</a> e <a href=http://www.transip.nl/>http://www.transip.nl/</a>.</p></div><div class=sect2><h3 id=_operação_hast>17.14.1. Operação HAST<a class=anchor href=#_operação_hast></a></h3><div class=paragraph><p>O HAST fornece replicação síncrona em nível de bloco entre duas máquinas físicas: o <em>primário</em>, também conhecido como o nó <em>master</em>, e o <em>secundário</em>, ou nó <em>slave</em>. Essas duas máquinas juntas são chamadas de cluster.</p></div><div class=paragraph><p>Como o HAST funciona em uma configuração primária-secundária, ele permite que apenas um dos nós do cluster esteja ativo a qualquer momento. O nó primário, também chamado de <em>active</em>, é aquele que irá lidar com todas as solicitações de I/O para dispositivos gerenciados por HAST. O nó secundário é automaticamente sincronizado a partir do nó primário.</p></div><div class=paragraph><p>Os componentes físicos do sistema HAST são o disco local no nó primário e o disco no nó secundário remoto.</p></div><div class=paragraph><p>O HAST opera de forma síncrona em um nível de bloco, tornando-o transparente para sistemas de arquivos e aplicativos. O HAST fornece provedores GEOM regulares em <span class=filename>/dev/hast/</span> para uso por outras ferramentas ou aplicativos. Não há diferença entre o uso de dispositivos HAST e discos ou partições brutas.</p></div><div class=paragraph><p>Cada operação de gravação, exclusão ou liberação é enviada para o disco local e para o disco remoto sobre TCP/IP . Cada operação de leitura é fornecida a partir do disco local, a menos que o disco local não esteja atualizado ou ocorra um erro de I/O. Nesses casos, a operação de leitura é enviada para o nó secundário.</p></div><div class=paragraph><p>HAST tenta fornecer recuperação rápida de falhas. Por esse motivo, é importante reduzir o tempo de sincronização após a interrupção de um nó. Para fornecer sincronização rápida, o HAST gerencia um bitmap no disco de extensões sujas e sincroniza apenas aquelas durante uma sincronização regular, com exceção da sincronização inicial.</p></div><div class=paragraph><p>Existem muitas maneiras de lidar com a sincronização. O HAST implementa vários modos de replicação para lidar com diferentes métodos de sincronização:</p></div><div class=ulist><ul><li><p><em>memsync</em>: Este modo reporta uma operação de gravação como concluída quando a operação de gravação local é finalizada e quando o nó remoto reconhece a chegada dos dados, mas antes de realmente armazenar os dados. Os dados no nó remoto serão armazenados diretamente após o envio da confirmação. Este modo destina-se a reduzir a latência, mas ainda fornece boa confiabilidade. Este modo é o padrão.</p></li><li><p><em>fullsync</em>: Este modo relata uma operação de gravação como concluída quando a gravação local e a gravação remota são concluídas. Este é o modo de replicação mais seguro e mais lento.</p></li><li><p><em>async</em>: Este modo relata uma operação de gravação como concluída quando a gravação local é concluída. Este é o modo de replicação mais rápido e mais perigoso. Ele deve ser usado somente ao replicar para um nó distante, onde a latência é muito alta para outros modos.</p></li></ul></div></div><div class=sect2><h3 id=_configuração_do_hast>17.14.2. Configuração do HAST<a class=anchor href=#_configuração_do_hast></a></h3><div class=paragraph><p>O framework HAST consiste em vários componentes:</p></div><div class=ulist><ul><li><p>O daemon <a href="https://man.freebsd.org/cgi/man.cgi?query=hastd&amp;sektion=8&amp;format=html">hastd(8)</a> que fornece sincronização de dados. Quando este daemon é iniciado, ele carregará automaticamente <code>geom_gate.ko</code>.</p></li><li><p>O utilitário de gerenciamento de usuário, <a href="https://man.freebsd.org/cgi/man.cgi?query=hastctl&amp;sektion=8&amp;format=html">hastctl(8)</a>.</p></li><li><p>O arquivo de configuração <a href="https://man.freebsd.org/cgi/man.cgi?query=hast.conf&amp;sektion=5&amp;format=html">hast.conf(5)</a>. Este arquivo deve existir antes de iniciar o hastd.</p></li></ul></div><div class=paragraph><p>Usuários que preferem construir estaticamente o suporte a <code>GEOM_GATE</code> no kernel devem adicionar esta linha ao arquivo de configuração do kernel personalizado e reconstruir o kernel usando as instruções em <a href=../kernelconfig/#kernelconfig>Configurando o kernel do FreeBSD</a>:</p></div><div class="literalblock programlisting"><div class=content><pre>options	GEOM_GATE</pre></div></div><div class=paragraph><p>O exemplo a seguir descreve como configurar dois nós na operação mestre-escravo/primário-secundário usando HAST para replicar os dados entre os dois. Os nós serão chamados <code>hasta</code>, com um endereço IP <code>172.16.0.1</code>, e <code>hastb</code>, com um endereço IP <code>172.16.0.2</code>. Ambos os nós terão um disco rígido dedicado <span class=filename>/dev/ad6</span> do mesmo tamanho para a operação HAST. O conjunto HAST, por vezes referido como um recurso ou o provedor GEOM em <span class=filename>/dev/hast/</span>, será chamado <code>test</code>.</p></div><div class=paragraph><p>A configuração do HAST é feita usando o arquivo <span class=filename>/etc/hast.conf</span>. Este arquivo deve ser idêntico nos dois nós. A configuração mais simples é:</p></div><div class="literalblock programlisting"><div class=content><pre>resource test {
	on hasta {
		local /dev/ad6
		remote 172.16.0.2
	}
	on hastb {
		local /dev/ad6
		remote 172.16.0.1
	}
}</pre></div></div><div class=paragraph><p>Para uma configuração mais avançada, consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=hast.conf&amp;sektion=5&amp;format=html">hast.conf(5)</a>.</p></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Também é possível usar nomes de host nas instruções <code>remote</code> se os hosts forem resolvidos e definidos no arquivo <span class=filename>/etc/hosts</span> ou no DNS local.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Uma vez que a configuração exista em ambos os nós, o conjunto HAST pode ser criado. Execute esses comandos nos dois nós para colocar os metadados iniciais no disco local e para iniciar <a href="https://man.freebsd.org/cgi/man.cgi?query=hastd&amp;sektion=8&amp;format=html">hastd(8)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># hastctl create test</span>
<span class=c># service hastd onestart</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p><em>Não</em> é possível usar os provedores GEOM com um sistema de arquivos existente ou converter um armazenamento existente em um pool gerenciado por HAST. Esse procedimento precisa armazenar alguns metadados no provedor e não haverá espaço suficiente disponível em um provedor existente.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Um nó HAST <code>primário</code> ou <code>secundário</code> é selecionado por um administrador, ou software como Heartbeat, usando <a href="https://man.freebsd.org/cgi/man.cgi?query=hastctl&amp;sektion=8&amp;format=html">hastctl(8)</a>. No nó primário, <code>hasta</code>, execute este comando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># hastctl role primary test</span></code></pre></div></div><div class=paragraph><p>Execute este comando no nó secundário, <code>hastb</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># hastctl role secondary test</span></code></pre></div></div><div class=paragraph><p>Verifique o resultado executando <code>hastctl</code> em cada nó:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># hastctl status test</span></code></pre></div></div><div class=paragraph><p>Verifique a linha <code>status</code> na saída. Se disser <code>degraded</code>, algo está errado com o arquivo de configuração. Ele deve dizer <code>complete</code> em cada nó, o que significa que a sincronização entre os nós foi iniciada. A sincronização é concluída quando <code>hastctl status</code> relata 0 bytes de extensões <code>sujas</code>.</p></div><div class=paragraph><p>O próximo passo é criar um sistema de arquivos no provedor GEOM e montá-lo. Isso deve ser feito no nó <code>primário</code>. A criação do sistema de arquivos pode levar alguns minutos, dependendo do tamanho do disco rígido. Este exemplo cria um sistema de arquivos UFS em <span class=filename>/dev/hast/test</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># newfs -U /dev/hast/test</span>
<span class=c># mkdir /hast/test</span>
<span class=c># mount /dev/hast/test /hast/test</span></code></pre></div></div><div class=paragraph><p>Uma vez que o framework HAST esteja configurado corretamente, o passo final é garantir que o HAST seja iniciado automaticamente durante a inicialização do sistema. Adicione esta linha ao <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>hastd_enable=&#34;YES&#34;</pre></div></div><div class=sect3><h4 id=_configuração_de_failover>17.14.2.1. Configuração de Failover<a class=anchor href=#_configuração_de_failover></a></h4><div class=paragraph><p>O objetivo deste exemplo é construir um sistema de armazenamento robusto que seja resistente à falha de qualquer nó. Se o nó primário falhar, o nó secundário estará lá para assumir o controle, verificar e montar o sistema de arquivos e continuar a trabalhar sem perder um único bit de dados.</p></div><div class=paragraph><p>Para realizar essa tarefa, o Protocolo de Redundância de Endereços Comuns (CARP) é usado para fornecer failover automático na camada IP. O CARP permite que vários hosts no mesmo segmento de rede compartilhem um endereço IP. Configure o CARP em ambos os nós do cluster de acordo com a documentação disponível em <a href=../advanced-networking/#carp>Protocolo Comum de Redundância de Endereços (CARP)</a>. Neste exemplo, cada nó terá seu próprio endereço de gerenciamento IP e um endereço IP compartilhado de <em>172.16.0.254</em>. O nó principal HAST do cluster deve ser o nó mestre CARP.</p></div><div class=paragraph><p>O pool HAST criado na seção anterior está agora pronto para ser exportado para os outros hosts da rede. Isso pode ser feito exportando-o através do NFS ou Samba, usando o endereço IP_172.16.0.254_ compartilhado. O único problema que permanece não resolvido é um failover automático caso o nó primário falhe.</p></div><div class=paragraph><p>Caso as interfaces do CARP subam ou desçam, o sistema operacional FreeBSD gera um evento <a href="https://man.freebsd.org/cgi/man.cgi?query=devd&amp;sektion=8&amp;format=html">devd(8)</a>, tornando possível observar mudanças de estado nas interfaces do CARP. Uma alteração de estado na interface CARP é uma indicação de que um dos nós falhou ou voltou a ficar online. Esses eventos de mudança de estado tornam possível executar um script que manipulará automaticamente o failover HAST.</p></div><div class=paragraph><p>Para capturar mudanças de estado nas interfaces do CARP, adicione esta configuração ao <span class=filename>/etc/devd.conf</span> em cada nó:</p></div><div class="literalblock programlisting"><div class=content><pre>notify 30 {
	match &#34;system&#34; &#34;IFNET&#34;;
	match &#34;subsystem&#34; &#34;carp0&#34;;
	match &#34;type&#34; &#34;LINK_UP&#34;;
	action &#34;/usr/local/sbin/carp-hast-switch master&#34;;
};

notify 30 {
	match &#34;system&#34; &#34;IFNET&#34;;
	match &#34;subsystem&#34; &#34;carp0&#34;;
	match &#34;type&#34; &#34;LINK_DOWN&#34;;
	action &#34;/usr/local/sbin/carp-hast-switch slave&#34;;
};</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Se os sistemas estiverem executando o FreeBSD 10 ou superior, substitua <span class=filename>carp0</span> pelo nome da interface configurada CARP.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Reinicie o <a href="https://man.freebsd.org/cgi/man.cgi?query=devd&amp;sektion=8&amp;format=html">devd(8)</a> em ambos os nós para colocar a nova configuração em vigor:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service devd restart</span></code></pre></div></div><div class=paragraph><p>Quando o estado da interface especificada é alterado subindo ou descendo, o sistema gera uma notificação, permitindo que o subsistema <a href="https://man.freebsd.org/cgi/man.cgi?query=devd&amp;sektion=8&amp;format=html">devd(8)</a> execute o script de failover automático especificado, <span class=filename>/usr/local/sbin/carp-hast-switch</span>. Para maiores esclarecimentos sobre esta configuração, consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=devd.conf&amp;sektion=5&amp;format=html">devd.conf(5)</a>.</p></div><div class=paragraph><p>Aqui está um exemplo de um script de failover automatizado:</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh

# Original script by Freddie Cash &lt;fjwcash@gmail.com&gt;
# Modified by Michael W. Lucas &lt;mwlucas@BlackHelicopters.org&gt;
# and Viktor Petersson &lt;vpetersson@wireload.net&gt;

# The names of the HAST resources, as listed in /etc/hast.conf
resources=&#34;test&#34;

# delay in mounting HAST resource after becoming master
# make your best guess
delay=3

# logging
log=&#34;local0.debug&#34;
name=&#34;carp-hast&#34;

# end of user configurable stuff

case &#34;$1&#34; in
	master)
		logger -p $log -t $name &#34;Switching to primary provider for ${resources}.&#34;
		sleep ${delay}

		# Wait for any &#34;hastd secondary&#34; processes to stop
		for disk in ${resources}; do
			while $( pgrep -lf &#34;hastd: ${disk} \(secondary\)&#34; &gt; /dev/null 2&gt;&amp;1 ); do
				sleep 1
			done

			# Switch role for each disk
			hastctl role primary ${disk}
			if [ $? -ne 0 ]; then
				logger -p $log -t $name &#34;Unable to change role to primary for resource ${disk}.&#34;
				exit 1
			fi
		done

		# Wait for the /dev/hast/* devices to appear
		for disk in ${resources}; do
			for I in $( jot 60 ); do
				[ -c &#34;/dev/hast/${disk}&#34; ] &amp;&amp; break
				sleep 0.5
			done

			if [ ! -c &#34;/dev/hast/${disk}&#34; ]; then
				logger -p $log -t $name &#34;GEOM provider /dev/hast/${disk} did not appear.&#34;
				exit 1
			fi
		done

		logger -p $log -t $name &#34;Role for HAST resources ${resources} switched to primary.&#34;

		logger -p $log -t $name &#34;Mounting disks.&#34;
		for disk in ${resources}; do
			mkdir -p /hast/${disk}
			fsck -p -y -t ufs /dev/hast/${disk}
			mount /dev/hast/${disk} /hast/${disk}
		done

	;;

	slave)
		logger -p $log -t $name &#34;Switching to secondary provider for ${resources}.&#34;

		# Switch roles for the HAST resources
		for disk in ${resources}; do
			if ! mount | grep -q &#34;^/dev/hast/${disk} on &#34;
			then
			else
				umount -f /hast/${disk}
			fi
			sleep $delay
			hastctl role secondary ${disk} 2&gt;&amp;1
			if [ $? -ne 0 ]; then
				logger -p $log -t $name &#34;Unable to switch role to secondary for resource ${disk}.&#34;
				exit 1
			fi
			logger -p $log -t $name &#34;Role switched to secondary for resource ${disk}.&#34;
		done
	;;
esac</pre></div></div><div class=paragraph><p>Em poucas palavras, o script executa essas ações quando um nó se torna mestre:</p></div><div class=ulist><ul><li><p>Promove o pool de HAST para primário no outro nó.</p></li><li><p>Verifica o sistema de arquivos no pool HAST.</p></li><li><p>Monta o pool.</p></li></ul></div><div class=paragraph><p>Quando um nó se torna secundário:</p></div><div class=ulist><ul><li><p>Desmonta o conjunto HAST.</p></li><li><p>Degrada o pool HAST para secundário.</p></li></ul></div><div class="admonitionblock caution"><table><tbody><tr><td class=icon><i class="fa icon-caution" title=Caution></i></td><td class=content><div class=paragraph><p>Este é apenas um script de exemplo que serve como prova de conceito. Ele não manipula todos os cenários possíveis e pode ser estendido ou alterado de qualquer forma, por exemplo, para iniciar ou interromper os serviços necessários.</p></div></td></tr></tbody></table></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Para este exemplo, foi utilizado um sistema de arquivos padrão UFS. Para reduzir o tempo necessário para a recuperação, é possível usar um sistema de arquivos UFS ou ZFS com journal ativado.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Informações mais detalhadas com exemplos adicionais podem ser encontradas em <a href=http://wiki.FreeBSD.org/HAST>http://wiki.FreeBSD.org/HAST</a>.</p></div></div></div><div class=sect2><h3 id=_solução_de_problemas>17.14.3. Solução de problemas<a class=anchor href=#_solução_de_problemas></a></h3><div class=paragraph><p>O HAST geralmente deve funcionar sem problemas. No entanto, como acontece com qualquer outro produto de software, pode haver momentos em que ele não funciona como deveria. As origens dos problemas podem ser diferentes, mas a regra geral é garantir que o horário esteja sincronizado entre os nós do cluster.</p></div><div class=paragraph><p>Quando estiver fazendo troubleshooting no HAST, o nível de depuração de <a href="https://man.freebsd.org/cgi/man.cgi?query=hastd&amp;sektion=8&amp;format=html">hastd(8)</a> deve ser aumentado iniciando <code>hastd</code> com <code>-d</code>. Esse argumento pode ser especificado várias vezes para aumentar ainda mais o nível de depuração. Considere também usar <code>-F</code>, que inicia o <code>hastd</code> em primeiro plano.</p></div><div class=sect3><h4 id=disks-hast-sb>17.14.3.1. Recuperando-se da Condição de Split-brain<a class=anchor href=#disks-hast-sb></a></h4><div class=paragraph><p><em>Split-brain</em> ocorre quando os nós do cluster não conseguem se comunicar entre si e ambos são configurados como primários. Esta é uma condição perigosa porque permite que ambos os nós façam alterações incompatíveis nos dados. Esse problema deve ser corrigido manualmente pelo administrador do sistema.</p></div><div class=paragraph><p>O administrador deve decidir qual nó tem alterações mais importantes ou executar a mesclagem manualmente. Então, deixe o HAST executar a sincronização completa do nó que possui os dados quebrados. Para fazer isso, emita esses comandos no nó que precisa ser ressincronizado:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># hastctl role init test</span>
<span class=c># hastctl create test</span>
<span class=c># hastctl role secondary test</span></code></pre></div></div></div></div></div></div></div><hr><div class=last-modified><p><strong>Última alteração em</strong>: 9 de março de 2024 por <a href="https://cgit.freebsd.org/doc/commit/?id=6199af92e7" target=_blank>Danilo G. Baio</a></p></div><div class=buttons><div class=prev><i class="fa fa-angle-left" aria-hidden=true title=Anterior></i><div class=container><a href=https://docs.freebsd.org/pt-br/books/handbook/audit class=direction>Anterior</a></div></div><div class=home><i class="fa fa-home" aria-hidden=true title=Início></i><div class=container><a href=../ class=direction>Início</a></div></div><div class=next><div class=container><a href=https://docs.freebsd.org/pt-br/books/handbook/geom class=direction>Próximo</a></div><i class="fa fa-angle-right" aria-hidden=true title=Próximo></i></div></div><label class="hidden book-menu-overlay" for=menu-control></label></div><aside class=toc><div class=toc-content><h3>Índice</h3><nav id=TableOfContents><ul><li><a href=#disks-synopsis>17.1. Sinopse</a></li><li><a href=#disks-adding>17.2. Adicionando Discos</a></li><li><a href=#disks-growing>17.3. Redimensionando e Ampliando Discos</a></li><li><a href=#usb-disks>17.4. Dispositivos de Armazenamento USB</a></li><li><a href=#creating-cds>17.5. Criando e Usando Mídia em CD</a></li><li><a href=#creating-dvds>17.6. Criando e Usando Mídia de DVD</a></li><li><a href=#floppies>17.7. Criando e Usando Disquetes</a></li><li><a href=#backup-basics>17.8. Noções Básicas de Backup</a></li><li><a href=#disks-virtual>17.9. Discos de Memória</a></li><li><a href=#snapshots>17.10. Snapshots de Sistemas de Arquivos</a></li><li><a href=#quotas>17.11. Cotas de Disco</a></li><li><a href=#disks-encrypting>17.12. Criptografando Partições de Disco</a></li><li><a href=#swap-encrypting>17.13. Criptografando Swap</a></li><li><a href=#disks-hast>17.14. Alta Disponibilidade de Armazenamento (HAST)</a></li></ul></nav><hr><div class=resources><h3>Recursos</h3><ul class=contents><li><i class="fa fa-file-pdf-o" aria-hidden=true title="Download PDF"></i><a href=https://download.freebsd.org/doc/pt-br/books/handbook/handbook_pt-br.pdf>Download PDF</a></li><li><i class="fa fa-pencil-square-o" aria-hidden=true title="Edite essa página"></i><a href=https://github.com/freebsd/freebsd-doc/blob/main/documentation/content/pt-br/_index target=_blank>Edite essa página</a></li></ul></div></div></aside><a class=to-top href=#top><i class="fa fa-arrow-circle-up" aria-hidden=true></i></a></main><footer><div class=footer-container><section class=logo-column><img src=https://docs.freebsd.org/images/FreeBSD-colors.svg width=160 height=50 alt="FreeBSD logo"><div class=options-container><div class=language-container><a id=languages href=https://docs.freebsd.org/pt-br/languages><img src=https://docs.freebsd.org/images/language.png class=language-image alt="Escolha o idioma">
<span>Brazilian Portuguese</span></a></div><div class=theme-container><select id=theme-chooser><option value=theme-system>System</option><option value=theme-light>Light</option><option value=theme-dark>Dark</option><option value=theme-high-contrast>Alto contraste</option></select></div></div></section><section class=about-column><h3 class=column-title>About</h3><ul class=column-elements-container><li><a href=https://www.freebsd.org/about/ target=_blank class=column-element>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/ target=_blank class=column-element>FreeBSD Foundation</a></li><li><a href=https://www.freebsd.org/where/ target=_blank class=column-element>Get FreeBSD</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct target=_blank class=column-element>Code of Conduct</a></li><li><a href=https://www.freebsd.org/security/ target=_blank class=column-element>Security Advisories</a></li></ul></section><section class=documentation-column><h3 class=column-title>Documentation</h3><ul class=column-elements-container><li><a href=/pt-br class=column-element>Documentation portal</a></li><li><a href=https://man.FreeBSD.org target=_blank class=column-element>Manual pages</a></li><li><a href=https://papers.FreeBSD.org target=_blank class=column-element>Presentations and papers</a></li><li><a href=https://docs-archive.freebsd.org/doc/ target=_blank class=column-element>Previous versions</a></li><li><a href=https://docs-archive.freebsd.org/44doc/ target=_blank class=column-element>4.4BSD Documents</a></li><li><a href=https://wiki.freebsd.org/ target=_blank class=column-element>Wiki</a></li></ul></section><section class=community-column><h3 class=column-title>Community</h3><ul class=column-elements-container><li><a href=https://docs.freebsd.org/pt-br/articles/contributing class=column-element>Get involved</a></li><li><a href=https://forums.freebsd.org/ target=_blank class=column-element>Community forum</a></li><li><a href=https://lists.freebsd.org/ target=_blank class=column-element>Mailing lists</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank class=column-element>IRC Channels</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank class=column-element>Bug Tracker</a></li></ul></section><section class=legal-column><h3 class=column-title>Legal</h3><ul class=column-elements-container><li><a href=https://freebsdfoundation.org/donate/ target=_blank class=column-element>Donations</a></li><li><a href=https://www.freebsd.org/copyright/freebsd-license/ target=_blank class=column-element>Licensing</a></li><li><a href=https://www.freebsd.org/privacy/ target=_blank class=column-element>Privacy Policy</a></li><li><a href=https://www.freebsd.org/copyright/ target=_blank class=column-element>Legal notices</a></li></ul></section><section class=copyright-column><p>&copy; 1994-2024 The FreeBSD Project. All rights reserved</p><span>Made with <span class=heart>♥</span> by the FreeBSD Community</span></section></div></footer></body></html>