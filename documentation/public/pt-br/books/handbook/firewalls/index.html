<!doctype html><html class=theme-light lang=pt-br><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content><meta name=keywords content><meta name=copyright content="1995-2024 The FreeBSD Foundation"><link rel=canonical href=http://172.16.201.134:1313/pt-br/books/handbook/firewalls/><title>Capítulo 30. Firewalls | FreeBSD Documentation Portal</title>
<meta name=theme-color content="#790000"><meta name=color-scheme content="system light dark high-contrast"><link rel="shortcut icon" href=http://172.16.201.134:1313/favicon.ico><link rel=stylesheet href=http://172.16.201.134:1313/styles/main.min.css><link rel=stylesheet href=http://172.16.201.134:1313/css/font-awesome-min.css><script defer src=/js/theme-chooser.min.js></script><script defer src=/js/copy-clipboard.min.js></script><script defer src=/js/search.min.js></script><meta name=twitter:card content="summary"><meta name=twitter:domain content="docs.FreeBSD.org"><meta name=twitter:site content="@freebsd"><meta name=twitter:url content="https://twitter.com/freebsd"><meta property="og:title" content="Capítulo 30. Firewalls"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:image" content="http://172.16.201.134:1313/favicon.ico"><meta property="og:image:alt" content="FreeBSD Logo"><meta property="og:locale" content="pt-br"><meta property="og:url" content="http://172.16.201.134:1313/pt-br/books/handbook/firewalls/"><meta property="og:site_name" content="FreeBSD Documentation Portal"><script type=application/ld+json>{"@context":"http://schema.org","@type":"Article","url":"http:\/\/172.16.201.134:1313\/pt-br\/books\/handbook\/firewalls\/","name":"FreeBSD Documentation Portal","headline":"FreeBSD Documentation Portal","description":"FreeBSD Documentation Portal"}</script></head><body><header><div class=header-container><div class=logo-menu-bars-container><a href=https://www.FreeBSD.org class=logo><img src=http://172.16.201.134:1313/images/FreeBSD-monochromatic.svg width=160 height=50 alt="FreeBSD logo">
</a><label class=menu-bars for=menu-bars><i class="fa fa-bars" aria-hidden=true></i></label></div><input id=menu-bars type=checkbox><nav><ul class=menu><li class=menu-item><input id=about type=checkbox>
<a href=# aria-label="Navigate to About section"><label class=menu-item-description for=about>About
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/about/ target=_blank>About</a></li><li><a href=https://www.freebsd.org/about/ target=_blank>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/about-us/about-the-foundation/ target=_blank>FreeBSD Foundation</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct/ target=_blank>Code of Conduct</a></li></ul></li><li class=menu-item><input id=download type=checkbox>
<a href=# aria-label="Navigate to get FreeBSD section"><label class=menu-item-description for=download>Get FreeBSD
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/where/ target=_blank>Get FreeBSD</a></li><li><a href=https://www.freebsd.org/releases/ target=_blank>Release Information</a></li><li><a href=https://www.freebsd.org/releng/ target=_blank>Release Engineering</a></li><li><a href=https://www.freebsd.org/security/ target=_blank>Security Advisories</a></li></ul></li><li class=menu-item><input id=documentation type=checkbox>
<a href=# aria-label="Navigate to get Documentation section"><label class=menu-item-description for=documentation>Documentation
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=/pt-br>Documentation portal</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook>FreeBSD Handbook</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/porters-handbook>Porter's Handbook</a></li><li><a href=https://docs.FreeBSD.org/en/books/fdp-primer>Documentation Project Handbook</a></li><li><a href=https://man.FreeBSD.org target=_blank>Manual pages</a></li><li><a href=https://papers.FreeBSD.org target=_blank>Presentations and papers</a></li><li><a href=https://wiki.FreeBSD.org target=_blank>Wiki</a></li><li><a href=http://172.16.201.134:1313/pt-br/books>Books</a></li><li><a href=http://172.16.201.134:1313/pt-br/articles>Articles</a></li></ul></li><li class=menu-item><input id=community type=checkbox>
<a href=# aria-label="Navigate to get Community section"><label class=menu-item-description for=community>Community
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/community/>Community</a></li><li><a href=http://172.16.201.134:1313/pt-br/articles/contributing>Get involved</a></li><li><a href=https://forums.freebsd.org/ target=_blank>Forum</a></li><li><a href=https://lists.freebsd.org/ target=_blank>Mailing lists</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank>IRC Channels</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank>Bug Tracker</a></li><li><a href=https://www.freebsd.org/support/ target=_blank>Support</a></li></ul></li></ul></nav><div class=search-donate-container><form class=search method=get id=search-header-form action=https://docs.freebsd.org/search name=search-header-form><input type=hidden name=DB value=pt-br>
<input id=words name=P type=text size=20 maxlength=255>
<button>
<i class="fa fa-search" aria-hidden=true></i></button></form><div class=donate><a href=https://freebsdfoundation.org/donate/ target=_blank><span class=heart>♥</span>
Donate</a></div></div></div></header><input type=checkbox class="hidden toggle" id=menu-control><main class=main-wrapper-book><a id=top></a><aside class=book-menu><div class=book-menu-content><input id=search-book type=text placeholder=Pesquisar aria-label=Pesquisar maxlength=128><nav id=MenuContents><ul><li><input type=checkbox id=chapter-eb2a98ce203d8afd517726e6d8776be3 class=toggle>
<label class="icon cursor" for=chapter-eb2a98ce203d8afd517726e6d8776be3><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/preface/>Prefácio</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/preface/#preface-audience>Audiência Pretendida</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/preface/#preface-changes-from3>Mudanças desde a Terceira Edição</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/preface/#preface-changes-from2>Mudanças desde a Segunda Edição (2004)</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/preface/#preface-changes>Mudanças desde a Primeira Edição (2001)</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/preface/#preface-overview>Organização deste Livro</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/preface/#preface-conv>Convenções utilizadas neste livro</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/preface/#preface-acknowledgements>Agradecimentos</a></li></ul></li><li><input type=checkbox id=chapter-14a525fce014b90b8a458a894818255a class=toggle>
<label for=chapter-14a525fce014b90b8a458a894818255a><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/parti/>Parte I. Primeiros Passos</a></li><li><input type=checkbox id=chapter-f9c9f3451644df30d224350da97d5da6 class=toggle>
<label class="icon cursor" for=chapter-f9c9f3451644df30d224350da97d5da6><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/introduction/>Capítulo 1. Introdução</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/introduction/#introduction-synopsis>1.1. Sinopse</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/introduction/#nutshell>1.2. Bem vindo ao FreeBSD!</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/introduction/#history>1.3. Sobre o Projeto FreeBSD</a></li></ul></li><li><input type=checkbox id=chapter-f693a3fa687a72d63ec8129ee302d664 class=toggle>
<label class="icon cursor" for=chapter-f693a3fa687a72d63ec8129ee302d664><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/bsdinstall/>Capítulo 2. Instalando o FreeBSD</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/bsdinstall/#bsdinstall-synopsis>2.1. Sinopse</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/bsdinstall/#bsdinstall-hardware>2.2. Requisitos mínimos de hardware</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/bsdinstall/#bsdinstall-pre>2.3. Tarefas de Pré-instalação</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/bsdinstall/#bsdinstall-start>2.4. Iniciando a instalação</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/bsdinstall/#using-bsdinstall>2.5. Usando o bsdinstall</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/bsdinstall/#bsdinstall-partitioning>2.6. Alocando o espaço em disco</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/bsdinstall/#bsdinstall-fetching-distribution>2.7. Fazendo o download dos arquivos de distribuição</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/bsdinstall/#bsdinstall-post>2.8. Contas, Time Zone, Serviços e Hardening</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/bsdinstall/#bsdinstall-network>2.9. Interfaces de Rede</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/bsdinstall/#bsdinstall-install-trouble>2.10. Solução de problemas</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/bsdinstall/#using-live-cd>2.11. Usando o Live CD</a></li></ul></li><li><input type=checkbox id=chapter-9f6db261075f578742036fcc6000eecd class=toggle>
<label class="icon cursor" for=chapter-9f6db261075f578742036fcc6000eecd><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/basics/>Capítulo 3. Fundamentos do FreeBSD</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/basics/#basics-synopsis>3.1. Sinopse</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/basics/#consoles>3.2. Consoles e Terminais Virtuais</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/basics/#users-synopsis>3.3. Usuários e Gerenciamento Básico de Contas</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/basics/#permissions>3.4. Permissões</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/basics/#dirstructure>3.5. Estrutura de Diretórios</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/basics/#disk-organization>3.6. Organização dos Discos</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/basics/#mount-unmount>3.7. Montando e Desmontando Sistemas de Arquivos</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/basics/#basics-processes>3.8. Processos e Daemons</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/basics/#shells>3.9. Shells</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/basics/#editors>3.10. Editores de Texto</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/basics/#basics-devices>3.11. Dispositivos e nós de dispositivos</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/basics/#basics-more-information>3.12. Páginas de Manual</a></li></ul></li><li><input type=checkbox id=chapter-01c5707e95d14c0ff84bf62600c958d1 class=toggle>
<label class="icon cursor" for=chapter-01c5707e95d14c0ff84bf62600c958d1><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/ports/>Capítulo 4. Instalando Aplicativos: Pacotes e Ports</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/ports/#ports-synopsis>4.1. Sinopse</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/ports/#ports-overview>4.2. Visão geral sobre a Instalação de Software</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/ports/#ports-finding-applications>4.3. Encontrando Software</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/ports/#pkgng-intro>4.4. Usando o pkg para o gerenciamento de pacotes binários</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/ports/#ports-using>4.5. Usando a Coleção de Ports</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/ports/#ports-poudriere>4.6. Compilando Pacotes com o Poudriere</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/ports/#ports-nextsteps>4.7. Considerações pós-instalação</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/ports/#ports-broken>4.8. Lidando com ports quebrados</a></li></ul></li><li><input type=checkbox id=chapter-3405c00581365a8b5d16af70fe4d1b72 class=toggle>
<label class="icon cursor" for=chapter-3405c00581365a8b5d16af70fe4d1b72><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/x11/>Capítulo 5. O sistema X Window</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/x11/#x11-synopsis>5.1. Sinopse</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/x11/#x-understanding>5.2. Terminologia</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/x11/#x-install>5.3. Instalando o Xorg</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/x11/#x-config>5.4. Configuração do Xorg</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/x11/#x-fonts>5.5. Usando fontes no Xorg</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/x11/#x-xdm>5.6. O Gerenciador de Display X</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/x11/#x11-wm>5.7. Ambientes de desktop</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/x11/#x-compiz-fusion>5.8. Instalando o Compiz Fusion</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/x11/#x11-troubleshooting>5.9. Solução de problemas</a></li></ul></li><li><input type=checkbox id=chapter-0eab3565e8f59f5a8a896dfba7eb3680 class=toggle>
<label for=chapter-0eab3565e8f59f5a8a896dfba7eb3680><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/partii/>Parte II. Tarefas comuns</a></li><li><input type=checkbox id=chapter-b33cf28993f3f7bf5baf036e79da0f39 class=toggle>
<label class="icon cursor" for=chapter-b33cf28993f3f7bf5baf036e79da0f39><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/desktop/>Capítulo 6. Aplicações de Desktop</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/desktop/#desktop-synopsis>6.1. Sinopse</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/desktop/#desktop-browsers>6.2. Navegadores</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/desktop/#desktop-productivity>6.3. Produtividade</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/desktop/#desktop-viewers>6.4. Visualizadores de Documentos</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/desktop/#desktop-finance>6.5. Finanças</a></li></ul></li><li><input type=checkbox id=chapter-152f694a19312ad72ec7bb4e1c3c33b2 class=toggle>
<label class="icon cursor" for=chapter-152f694a19312ad72ec7bb4e1c3c33b2><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/multimedia/>Capítulo 7. Multimídia</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/multimedia/#multimedia-synopsis>7.1. Sinopse</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/multimedia/#sound-setup>7.2. Configurando a Placa de Som</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/multimedia/#sound-mp3>7.3. Áudio MP3</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/multimedia/#video-playback>7.4. Reprodução de Vídeo</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/multimedia/#tvcard>7.5. Placas de TV</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/multimedia/#mythtv>7.6. MythTV</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/multimedia/#scanners>7.7. Scanners de Imagem</a></li></ul></li><li><input type=checkbox id=chapter-80888b4ee02e3e409e5f71cf97a36450 class=toggle>
<label class="icon cursor" for=chapter-80888b4ee02e3e409e5f71cf97a36450><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/kernelconfig/>Capítulo 8. Configurando o kernel do FreeBSD</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/kernelconfig/#kernelconfig-synopsis>8.1. Sinopse</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/kernelconfig/#kernelconfig-custom-kernel>8.2. Por que compilar um kernel personalizado?</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/kernelconfig/#kernelconfig-devices>8.3. Encontrando o hardware do sistema</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/kernelconfig/#kernelconfig-config>8.4. O Arquivo de Configuração</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/kernelconfig/#kernelconfig-building>8.5. Criando e Instalando um Kernel Customizado</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/kernelconfig/#kernelconfig-trouble>8.6. Se algo der errado</a></li></ul></li><li><input type=checkbox id=chapter-cb174c55879b17ab955f2f16989a79e0 class=toggle>
<label class="icon cursor" for=chapter-cb174c55879b17ab955f2f16989a79e0><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/printing/>Capítulo 9. Impressão</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/printing/#printing-quick-start>9.1. Inicio Rápido</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/printing/#printing-connections>9.2. Conexões de Impressora</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/printing/#printing-pdls>9.3. Linguagens de Descrição de Página Comuns</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/printing/#printing-direct>9.4. Impressão Direta</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/printing/#printing-lpd>9.5. LPD (Daemon de impressora de linha)</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/printing/#printing-other>9.6. Outros sistemas de impressão</a></li></ul></li><li><input type=checkbox id=chapter-c12b8c3f2a8fcefce87087241f695c83 class=toggle>
<label class="icon cursor" for=chapter-c12b8c3f2a8fcefce87087241f695c83><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/linuxemu/>Capítulo 10. Compatibilidade binária com o Linux®</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/linuxemu/#linuxemu-synopsis>10.1. Sinopse</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/linuxemu/#linuxemu-lbc-install>10.2. Configurando a compatibilidade binária com o Linux™</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/linuxemu/#linuxemu-advanced>10.3. Tópicos Avançados</a></li></ul></li><li><input type=checkbox id=chapter-03b11ba627b9a0c85b247f5641bde272 class=toggle>
<label for=chapter-03b11ba627b9a0c85b247f5641bde272><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/partiii/>Parte III. Administração do Sistema</a></li><li><input type=checkbox id=chapter-6c31587f8d736319f099cd4dc1961301 class=toggle>
<label class="icon cursor" for=chapter-6c31587f8d736319f099cd4dc1961301><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/config/>Capítulo 11. Configuração e Ajuste</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/config/#config-synopsis>11.1. Sinopse</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/config/#configtuning-starting-services>11.2. Inicialização de Serviços</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/config/#configtuning-cron>11.3. Configurando o cron(8)</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/config/#configtuning-rcd>11.4. Gerenciando Serviços no FreeBSD</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/config/#config-network-setup>11.5. Configurando Placas de Interface de Rede</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/config/#configtuning-virtual-hosts>11.6. Hosts Virtuais</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/config/#configtuning-syslog>11.7. Configurando o log do sistema</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/config/#configtuning-configfiles>11.8. Arquivos de Configuração</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/config/#configtuning-sysctl>11.9. Efetuando ajustes com o sysctl(8)</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/config/#configtuning-disk>11.10. Otimização de Discos</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/config/#configtuning-kernel-limits>11.11. Ajustando os Limites do Kernel</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/config/#adding-swap-space>11.12. Adicionando Espaço de Swap</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/config/#acpi-overview>11.13. Gerenciamento de energia e recursos</a></li></ul></li><li><input type=checkbox id=chapter-459f0012b3b4f0b6b123010f029da5e4 class=toggle>
<label class="icon cursor" for=chapter-459f0012b3b4f0b6b123010f029da5e4><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/boot/>Capítulo 12. O processo de inicialização do FreeBSD</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/boot/#boot-synopsis>12.1. Sinopse</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/boot/#boot-introduction>12.2. Processo de Inicialização do FreeBSD</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/boot/#boot-splash>12.3. Configurando telas iniciais de inicialização</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/boot/#device-hints>12.4. Sugestões de dispositivos</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/boot/#boot-shutdown>12.5. Sequência de Desligamento</a></li></ul></li><li><input type=checkbox id=chapter-917c75fcffbb14d48ed6d0a48e7028f2 class=toggle>
<label class="icon cursor" for=chapter-917c75fcffbb14d48ed6d0a48e7028f2><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/security/>Capítulo 13. Segurança</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/security/#security-synopsis>13.1. Sinopse</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/security/#security-intro>13.2. Introdução</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/security/#one-time-passwords>13.3. Senhas de Uso Unico</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/security/#tcpwrappers>13.4. TCP Wrapper</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/security/#kerberos5>13.5. Kerberos</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/security/#openssl>13.6. OpenSSL</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/security/#ipsec>13.7. VPN Sobre IPsec</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/security/#openssh>13.8. OpenSSH</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/security/#fs-acl>13.9. Listas de Controle de Acesso</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/security/#security-pkg>13.10. Monitorando Problemas de Segurança de Terceiros</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/security/#security-advisories>13.11. Avisos de Segurança do FreeBSD</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/security/#security-accounting>13.12. Auditoria de Processo</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/security/#security-resourcelimits>13.13. Limites de Recursos</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/security/#security-sudo>13.14. Administração Compartilhada com Sudo</a></li></ul></li><li><input type=checkbox id=chapter-1a2a8e719703649c2c66d99aa7a25fd4 class=toggle>
<label class="icon cursor" for=chapter-1a2a8e719703649c2c66d99aa7a25fd4><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/jails/>Capítulo 14. Jails</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/jails/#jails-synopsis>14.1. Sinopse</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/jails/#jails-terms>14.2. Termos Relacionados à Jails</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/jails/#jails-build>14.3. Criando e Controlando Jails</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/jails/#jails-tuning>14.4. Tuning e Administração</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/jails/#jails-application>14.5. Atualizando Múltiplas Jails</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/jails/#jails-ezjail>14.6. Gerenciando Jails com o ezjail</a></li></ul></li><li><input type=checkbox id=chapter-8f4620c77e572cbb58917911a33c73cf class=toggle>
<label class="icon cursor" for=chapter-8f4620c77e572cbb58917911a33c73cf><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/mac/>Capítulo 15. Controle de acesso obrigatório</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/mac/#mac-synopsis>15.1. Sinopse</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/mac/#mac-inline-glossary>15.2. Termos chave</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/mac/#mac-understandlabel>15.3. Entendendo os rótulos MAC</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/mac/#mac-planning>15.4. Planejando a configuração de segurança</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/mac/#mac-policies>15.5. Políticas MAC Disponíveis</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/mac/#mac-userlocked>15.6. Bloqueio do Usuário</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/mac/#mac-implementing>15.7. Nagios em Jail MAC</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/mac/#mac-troubleshoot>15.8. Solução de problemas do framework MAC</a></li></ul></li><li><input type=checkbox id=chapter-9598d66a76cb3182057b6bcd775149a0 class=toggle>
<label class="icon cursor" for=chapter-9598d66a76cb3182057b6bcd775149a0><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/audit/>Capítulo 16. Auditoria de Evento de Segurança</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/audit/#audit-synopsis>16.1. Sinopse</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/audit/#audit-inline-glossary>16.2. Termos chave</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/audit/#audit-config>16.3. Configuração de Auditoria</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/audit/#audit-administration>16.4. Trabalhando com Trilhas de Auditoria</a></li></ul></li><li><input type=checkbox id=chapter-e1edcad13d9db6e8e4cb645d378ecfaf class=toggle>
<label class="icon cursor" for=chapter-e1edcad13d9db6e8e4cb645d378ecfaf><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/disks/>Capítulo 17. Armazenamento</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/disks/#disks-synopsis>17.1. Sinopse</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/disks/#disks-adding>17.2. Adicionando Discos</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/disks/#disks-growing>17.3. Redimensionando e Ampliando Discos</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/disks/#usb-disks>17.4. Dispositivos de Armazenamento USB</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/disks/#creating-cds>17.5. Criando e Usando Mídia em CD</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/disks/#creating-dvds>17.6. Criando e Usando Mídia de DVD</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/disks/#floppies>17.7. Criando e Usando Disquetes</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/disks/#backup-basics>17.8. Noções Básicas de Backup</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/disks/#disks-virtual>17.9. Discos de Memória</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/disks/#snapshots>17.10. Snapshots de Sistemas de Arquivos</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/disks/#quotas>17.11. Cotas de Disco</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/disks/#disks-encrypting>17.12. Criptografando Partições de Disco</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/disks/#swap-encrypting>17.13. Criptografando Swap</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/disks/#disks-hast>17.14. Alta Disponibilidade de Armazenamento (HAST)</a></li></ul></li><li><input type=checkbox id=chapter-dde37901a0e0ea32745b67607854900f class=toggle>
<label class="icon cursor" for=chapter-dde37901a0e0ea32745b67607854900f><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/geom/>Capítulo 18. GEOM: Framework de Transformação de Disco Modular</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/geom/#geom-synopsis>18.1. Sinopse</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/geom/#geom-striping>18.2. RAID0 - Striping</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/geom/#geom-mirror>18.3. RAID1 - Espelhamento</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/geom/#geom-raid3>18.4. RAID3 - Distribuição em Nível de Byte com Paridade Dedicada</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/geom/#geom-graid>18.5. Dispositivos RAID por Software</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/geom/#geom-ggate>18.6. GEOM Network Gate</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/geom/#geom-glabel>18.7. Rotulando Dispositivos de Disco</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/geom/#geom-gjournal>18.8. Journaling UFS através do GEOM</a></li></ul></li><li><input type=checkbox id=chapter-73e82560fcb7145b7c0e2ec47af8fc04 class=toggle>
<label class="icon cursor" for=chapter-73e82560fcb7145b7c0e2ec47af8fc04><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/zfs/>Capítulo 19. O sistema de arquivos Z (ZFS)</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/zfs/#zfs-differences>19.1. O que torna o ZFS diferente</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/zfs/#zfs-quickstart>19.2. Guia de Início Rápido</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/zfs/#zfs-zpool>19.3. Administração <code>zpool</code></a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/zfs/#zfs-zfs>19.4. Administração do <code>zfs</code></a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/zfs/#zfs-zfs-allow>19.5. Administração Delegada</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/zfs/#zfs-advanced>19.6. Tópicos Avançados</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/zfs/#zfs-links>19.7. Recursos adicionais</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/zfs/#zfs-term>19.8. Recursos e terminologia do ZFS</a></li></ul></li><li><input type=checkbox id=chapter-7af71270807eb7b70cd3eedc6577b254 class=toggle>
<label class="icon cursor" for=chapter-7af71270807eb7b70cd3eedc6577b254><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/filesystems/>Capítulo 20. Outros Sistemas de Arquivos</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/filesystems/#filesystems-synopsis>20.1. Sinopse</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/filesystems/#filesystems-linux>20.2. Sistemas de arquivos do Linux™</a></li></ul></li><li><input type=checkbox id=chapter-375257268d95faaf87faf4f7a2e6aa67 class=toggle>
<label class="icon cursor" for=chapter-375257268d95faaf87faf4f7a2e6aa67><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/virtualization/>Capítulo 21. Virtualização</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/virtualization/#virtualization-synopsis>21.1. Sinopse</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/virtualization/#virtualization-guest-parallels>21.2. FreeBSD como Sistema Operacional Convidado no Parallels para Mac OS™ X</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/virtualization/#virtualization-guest-virtualpc>21.3. FreeBSD como sistema convidado no Virtual PC para Windows™</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/virtualization/#virtualization-guest-vmware>21.4. FreeBSD como Sistema Operacional Convidado no VMware Fusion para Mac OS™</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/virtualization/#virtualization-guest-virtualbox>21.5. FreeBSD como Sistema Operacional Convidado no VirtualBox™</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/virtualization/#virtualization-host-virtualbox>21.6. FreeBSD como Host com VirtualBox™</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/virtualization/#virtualization-host-bhyve>21.7. FreeBSD como um Host bhyve</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/virtualization/#virtualization-host-xen>21.8. FreeBSD como Host Xen™</a></li></ul></li><li><input type=checkbox id=chapter-49f1e96591c090304ea532012257f4ef class=toggle>
<label class="icon cursor" for=chapter-49f1e96591c090304ea532012257f4ef><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/l10n/>Capítulo 22. Localização - Uso e Configuração do i18n/L10n</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/l10n/#l10n-synopsis>22.1. Sinopse</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/l10n/#using-localization>22.2. Usando Localização</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/l10n/#l10n-compiling>22.3. Encontrando Aplicações i18n</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/l10n/#lang-setup>22.4. Configuração de Localização para Idiomas Específicos</a></li></ul></li><li><input type=checkbox id=chapter-dead2b4c5ea325dd390a9b0dccd8f763 class=toggle>
<label class="icon cursor" for=chapter-dead2b4c5ea325dd390a9b0dccd8f763><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/cutting-edge/>Capítulo 23. Atualização e Upgrade do FreeBSD</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/cutting-edge/#updating-upgrading-synopsis>23.1. Sinopse</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/cutting-edge/#updating-upgrading-freebsdupdate>23.2. Atualização do FreeBSD</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/cutting-edge/#updating-upgrading-documentation>23.3. Atualizando o Conjunto de Documentação</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/cutting-edge/#current-stable>23.4. Acompanhando um ramo de desenvolvimento</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/cutting-edge/#makeworld>23.5. Atualizando o FreeBSD a partir do código fonte</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/cutting-edge/#small-lan>23.6. Atualização de várias máquinas</a></li></ul></li><li><input type=checkbox id=chapter-29c1eeb0e9dedc487a98399e2737ee8a class=toggle>
<label class="icon cursor" for=chapter-29c1eeb0e9dedc487a98399e2737ee8a><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/dtrace/>Chapter 24. DTrace</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/dtrace/#dtrace-synopsis>24.1. Sinopse</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/dtrace/#dtrace-implementation>24.2. Diferenças de Implementação</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/dtrace/#dtrace-enable>24.3. Ativando o Suporte do DTrace</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/dtrace/#dtrace-using>24.4. Usando o DTrace</a></li></ul></li><li><input type=checkbox id=chapter-913e72bfb3d6947b2869d3e9447a6eaa class=toggle>
<label class="icon cursor" for=chapter-913e72bfb3d6947b2869d3e9447a6eaa><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/usb-device-mode/>Capítulo 25. Modo de dispositivo USB/USB OTG</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/usb-device-mode/#usb-device-mode-synopsis>25.1. Sinopse</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/usb-device-mode/#usb-device-mode-terminals>25.2. Portas Seriais Virtuais USB</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/usb-device-mode/#usb-device-mode-network>25.3. Interfaces de rede do modo de dispositivo USB</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/usb-device-mode/#usb-device-mode-storage>25.4. Dispositivo de armazenamento virtual USB</a></li></ul></li><li><input type=checkbox id=chapter-bbd25f9a194f9c39ca2d658c75767db5 class=toggle>
<label for=chapter-bbd25f9a194f9c39ca2d658c75767db5><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/partiv/>Parte IV. Comunicação de rede</a></li><li><input type=checkbox id=chapter-499dab596afd7ddac77e80295314e0dd class=toggle>
<label class="icon cursor" for=chapter-499dab596afd7ddac77e80295314e0dd><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/serialcomms/>Capítulo 26. Comunicações Seriais</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/serialcomms/#serial-synopsis>26.1. Sinopse</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/serialcomms/#serial>26.2. Terminologia serial e hardware</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/serialcomms/#term>26.3. Terminais</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/serialcomms/#dialup>26.4. Serviço Dial-in</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/serialcomms/#dialout>26.5. Serviço de Dial-in</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/serialcomms/#serialconsole-setup>26.6. Configurando o Console Serial</a></li></ul></li><li><input type=checkbox id=chapter-95e4571c48bee1cced5e84a538d302e3 class=toggle>
<label class="icon cursor" for=chapter-95e4571c48bee1cced5e84a538d302e3><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/ppp-and-slip/>Capítulo 27. PPP</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/ppp-and-slip/#ppp-and-slip-synopsis>27.1. Sinopse</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/ppp-and-slip/#userppp>27.2. Configurando o PPP</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/ppp-and-slip/#ppp-troubleshoot>27.3. Solução de problemas de conexões PPP</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/ppp-and-slip/#pppoe>27.4. Usando o PPP sobre Ethernet (PPPoE)</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/ppp-and-slip/#pppoa>27.5. Usando PPP sobre ATM (PPPoA)</a></li></ul></li><li><input type=checkbox id=chapter-f089ac726c401c9b4bd5c34a295e11bb class=toggle>
<label class="icon cursor" for=chapter-f089ac726c401c9b4bd5c34a295e11bb><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/mail/>Capítulo 28. Correio Eletrônico</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/mail/#mail-synopsis>28.1. Sinopse</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/mail/#mail-using>28.2. Componentes de Email</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/mail/#sendmail>28.3. Arquivos de Configuração do Sendmail</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/mail/#mail-changingmta>28.4. Alterando o Mail Transfer Agent</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/mail/#mail-trouble>28.5. Solução de problemas</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/mail/#mail-advanced>28.6. Tópicos Avançados</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/mail/#outgoing-only>28.7. Configurando Apenas Envio</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/mail/#SMTP-dialup>28.8. Usando Email com uma Conexão Dialup</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/mail/#SMTP-Auth>28.9. Autenticação SMTP</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/mail/#mail-agents>28.10. Mail User Agents</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/mail/#mail-fetchmail>28.11. Usando o fetchmail</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/mail/#mail-procmail>28.12. Usando o procmail</a></li></ul></li><li><input type=checkbox id=chapter-6de4de3fe925639d4175ce4b6f8c1829 class=toggle>
<label class="icon cursor" for=chapter-6de4de3fe925639d4175ce4b6f8c1829><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/network-servers/>Capítulo 29. Servidores de Rede</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/network-servers/#network-servers-synopsis>29.1. Sinopse</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/network-servers/#network-inetd>29.2. O super-servidor inetd</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/network-servers/#network-nfs>29.3. Network File System (NFS)</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/network-servers/#network-nis>29.4. Sistema de Informação de Rede (NIS)</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/network-servers/#network-ldap>29.5. Protocolo leve de acesso de diretório ( LDAP )</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/network-servers/#network-dhcp>29.6. Protocolo de configuração dinâmica de hosts (DHCP)</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/network-servers/#network-dns>29.7. Sistema de Nomes de Domínio (DNS)</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/network-servers/#network-apache>29.8. Servidor HTTP Apache</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/network-servers/#network-ftp>29.9. Protocolo de Transferência de Arquivos (FTP)</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/network-servers/#network-samba>29.10. Serviços de arquivos e impressão para clientes Microsoft™Windows™ Clients (Samba)</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/network-servers/#network-ntp>29.11. Sincronização de Relógio com NTP</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/network-servers/#network-iscsi>29.12. Inicializador iSCSI e Configuração Alvo</a></li></ul></li><li><input type=checkbox id=chapter-776d855c7b75e048f90b5c2c9b35ffe0 class=toggle checked>
<label class="icon cursor" for=chapter-776d855c7b75e048f90b5c2c9b35ffe0><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/firewalls/>Capítulo 30. Firewalls</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/firewalls/#firewalls-intro>30.1. Sinopse</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/firewalls/#firewalls-concepts>30.2. Conceitos de Firewall</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/firewalls/#firewalls-pf>30.3. PF</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/firewalls/#firewalls-ipfw>30.4. IPFW</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/firewalls/#firewalls-ipf>30.5. IPFILTER (IPF)</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/firewalls/#firewalls-blacklistd>30.6. Blacklistd</a></li></ul></li><li><input type=checkbox id=chapter-5b07f776a0e6155c1c89aa0d15610380 class=toggle>
<label class="icon cursor" for=chapter-5b07f776a0e6155c1c89aa0d15610380><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/advanced-networking/>Capítulo 31. Rede Avançada</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/advanced-networking/#advanced-networking-synopsis>31.1. Sinopse</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/advanced-networking/#network-routing>31.2. Gateways e Rotas</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/advanced-networking/#network-wireless>31.3. Rede sem fio</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/advanced-networking/#network-usb-tethering>31.4. USB Tethering</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/advanced-networking/#network-bluetooth>31.5. Bluetooth</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/advanced-networking/#network-bridging>31.6. Bridging</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/advanced-networking/#network-aggregation>31.7. Agregação de links e failover</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/advanced-networking/#network-diskless>31.8. Operação Diskless com PXE</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/advanced-networking/#network-ipv6>31.9. IPv6</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/advanced-networking/#carp>31.10. Protocolo Comum de Redundância de Endereços (CARP)</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/advanced-networking/#network-vlan>31.11. VLANs</a></li></ul></li><li><input type=checkbox id=chapter-171a77aa9d067a1024f849470e1f33e8 class=toggle>
<label for=chapter-171a77aa9d067a1024f849470e1f33e8><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/partv/>Parte V. Apêndices</a></li><li><input type=checkbox id=chapter-8050f436a0a7986a4aaded93d8e49469 class=toggle>
<label class="icon cursor" for=chapter-8050f436a0a7986a4aaded93d8e49469><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/mirrors/>Apêndice A. Obtendo o FreeBSD</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/mirrors/#mirrors-cdrom>A.1. CD and DVD Sets</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/mirrors/#mirrors-ftp>A.2. Sites de FTP</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/mirrors/#svn>A.3. Usando o Subversion</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/mirrors/#mirrors-rsync>A.4. Usando o rsync</a></li></ul></li><li><input type=checkbox id=chapter-128b630a8f88f158e7027fe6c2184d21 class=toggle>
<label class="icon cursor" for=chapter-128b630a8f88f158e7027fe6c2184d21><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/bibliography/>Apêndice B. Bibliografia</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/bibliography/#bibliography-freebsd>B.1. Livros específicos para o FreeBSD</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/bibliography/#bibliography-userguides>B.2. Guias de usuários</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/bibliography/#bibliography-adminguides>B.3. Guias de Administradores</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/bibliography/#bibliography-programmers>B.4. Guias de programadores</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/bibliography/#bibliography-osinternals>B.5. Internals do sistema operacional</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/bibliography/#bibliography-security>B.6. Referências de segurança</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/bibliography/#bibliography-hardware>B.7. Referências de Hardware</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/bibliography/#bibliography-history>B.8. História do UNIX™</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/bibliography/#bibliography-journals>B.9. Periódicos, Jornais e Revistas</a></li></ul></li><li><input type=checkbox id=chapter-8bbb8867c46dac315e2253945d8c18a8 class=toggle>
<label class="icon cursor" for=chapter-8bbb8867c46dac315e2253945d8c18a8><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/eresources/>Apêndice C. Recursos na Internet</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/eresources/#eresources-www>C.1. Websites</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/eresources/#eresources-mail>C.2. Listas de Discussão</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/eresources/#eresources-news>C.3. Grupos de Notícias Usenet</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/eresources/#eresources-web>C.4. Espelhos Oficiais</a></li></ul></li><li><input type=checkbox id=chapter-a80ea4f5a4480b8725422710f954ef36 class=toggle>
<label class="icon cursor" for=chapter-a80ea4f5a4480b8725422710f954ef36><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/pgpkeys/>Apêndice D. Chaves OpenPGP</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/pgpkeys/#pgpkeys-officers>D.1. Administradores</a></li></ul></li><li></li></ul></nav></div></aside><div class=book><div class=book-menu-mobile><label for=menu-control><span class=menu-control-button><i class="fa fa-list" aria-hidden=true title=Menu></i>
Menu</span></label></div><h1 class=title>Capítulo 30. Firewalls</h1><div class="admonitionblock note"><p><i class="fa fa-exclamation-circle" aria-hidden=true></i>
Esta tradução pode estar desatualizada. Para ajudar com as traduções, acesse a <a href=https://translate-dev.freebsd.org/ target=_blank>ferramenta de traduções do FreeBSD</a>.</p></div><div class=toc-mobile><h3>Índice</h3><nav id=TableOfContents><ul><li><a href=#firewalls-intro>30.1. Sinopse</a></li><li><a href=#firewalls-concepts>30.2. Conceitos de Firewall</a></li><li><a href=#firewalls-pf>30.3. PF</a></li><li><a href=#firewalls-ipfw>30.4. IPFW</a></li><li><a href=#firewalls-ipf>30.5. IPFILTER (IPF)</a></li><li><a href=#firewalls-blacklistd>30.6. Blacklistd</a></li></ul></nav></div><div class=book-content><div id=preamble><div class=sectionbody></div></div><div class=sect1><h2 id=firewalls-intro>30.1. Sinopse<a class=anchor href=#firewalls-intro></a></h2><div class=sectionbody><div class=paragraph><p>Os firewalls permitem filtrar o tráfego de entrada e saída que flui através de um sistema. Um firewall pode usar um ou mais conjuntos de "regras" para inspecionar os pacotes de rede à medida que eles entram ou saem das conexões de rede e assim permitir ou bloquear o tráfego. As regras de um firewall podem inspecionar uma ou mais características dos pacotes, como o tipo de protocolo, o endereço do host de origem ou de destino e a porta de origem ou de destino.</p></div><div class=paragraph><p>Os firewalls podem melhorar a segurança de um host ou de uma rede. Eles podem ser usados para fazer um ou mais dos seguintes procedimentos:</p></div><div class=ulist><ul><li><p>Proteger e isolar as aplicações, serviços e máquinas de uma rede interna contra tráfego indesejado da Internet pública.</p></li><li><p>Limitar ou desabilitar o acesso de hosts da rede interna para serviços da Internet pública.</p></li><li><p>Suportar a tradução de endereços de rede (NAT), que possibilita que uma rede interna use endereços IP privados e compartilhe uma única conexão com a Internet pública usando um único endereço IP ou um pool compartilhado de endereços públicos atribuídos automaticamente.</p></li></ul></div><div class=paragraph><p>O FreeBSD possui três firewalls embutidos no sistema base: PF, IPFW e IPFILTER, também conhecido como IPF. O FreeBSD também fornece dois traffic shapers para controlar o uso da largura de banda: <a href="https://man.freebsd.org/cgi/man.cgi?query=altq&amp;sektion=4&amp;format=html">altq(4)</a> e <a href="https://man.freebsd.org/cgi/man.cgi?query=dummynet&amp;sektion=4&amp;format=html">dummynet(4)</a>. O ALTQ tem sido tradicionalmente vinculado ao PF e o dummynet ao IPFW. Cada firewall usa regras para controlar o acesso de pacotes provenientes e com destino a um sistema FreeBSD, embora eles façam isso de maneiras diferentes e cada um com uma sintaxe de regra diferente.</p></div><div class=paragraph><p>O FreeBSD fornece vários firewalls para atender aos diferentes requisitos e preferências para uma ampla variedade de usuários. Cada usuário deve avaliar qual firewall atende melhor às suas necessidades.</p></div><div class=paragraph><p>Depois de ler este capítulo, você saberá:</p></div><div class=ulist><ul><li><p>Como definir regras de filtragem de pacotes.</p></li><li><p>As diferenças entre os firewalls embutidos no FreeBSD.</p></li><li><p>Como usar e configurar o firewall PF.</p></li><li><p>Como usar e configurar o firewall IPFW.</p></li><li><p>Como usar e configurar o firewall IPFILTER.</p></li></ul></div><div class=paragraph><p>Antes de ler este capítulo, você deve:</p></div><div class=ulist><ul><li><p>Entender os conceitos básicos do FreeBSD e de Internet.</p></li></ul></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Como todos os firewalls são baseados em inspecionar os valores dos campos de controle de pacotes selecionados, o criador do conjunto de regras do firewall deve ter uma compreensão de como funciona o TCP/IP, quais são os diferentes valores nos campos de controle de pacotes e como esses valores são usados em uma conversa de sessão normal. Para uma boa introdução, consulte <a href=http://www.ipprimer.com>Daryl’s TCP/IP Primer</a>.</p></div></td></tr></tbody></table></div></div></div><div class=sect1><h2 id=firewalls-concepts>30.2. Conceitos de Firewall<a class=anchor href=#firewalls-concepts></a></h2><div class=sectionbody><div class=paragraph><p>Um conjunto de regras contém um grupo de regras que liberam ou bloqueiam pacotes com base nos valores contidos no pacote. A troca bidirecional de pacotes entre hosts compreende uma conversa de sessão. O conjunto de regras do firewall processa os pacotes que chegam da Internet pública, bem como os pacotes produzidos pelo sistema como uma resposta aos que chegaram. Cada serviço TCP/IP é pré-definido pelo seu protocolo e porta de escuta. Os pacotes destinados a um serviço específico são originados do endereço de origem usando uma porta não privilegiada e têm como destino a porta do serviço específica no endereço de destino. Todos os parâmetros acima podem ser usados como critérios de seleção para criar regras que irão liberar ou bloquear serviços.</p></div><div class=paragraph><p>Para procurar números de porta desconhecidos, consulte o arquivo <span class=filename>/etc/services</span>. Alternativamente, visite <a href=http://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers>http://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers</a> e faça uma pesquisa de número de porta para encontrar a finalidade de um determinado número de porta.</p></div><div class=paragraph><p>Confira este link para ver os <a href=http://web.archive.org/web/20150803024617/http://www.sans.org/security-resources/idfaq/oddports.php>números de porta usados por Trojans</a>.</p></div><div class=paragraph><p>O FTP possui dois modos: modo ativo e modo passivo. A diferença está em como o canal de dados é adquirido. O modo passivo é mais seguro, pois o canal de dados é adquirido pelo solicitante de sessão ftp. Para obter uma boa explicação sobre o FTP e seus diferentes modos, consulte <a href=http://www.slacksite.com/other/ftp.html>http://www.slacksite.com/other/ftp.html</a>.</p></div><div class=paragraph><p>Um conjunto de regras de firewall pode ser "exclusivo" ou "inclusivo". Um firewall exclusivo libera todo o tráfego, exceto o tráfego correspondente ao conjunto de regras. Um firewall inclusivo faz o inverso, liberando o tráfego que corresponde as regras e bloqueia todo o resto.</p></div><div class=paragraph><p>Um firewall inclusivo oferece melhor controle do tráfego de saída, tornando-o uma melhor escolha para sistemas que oferecem serviços à Internet pública. Também controla o tipo de tráfego originado da Internet pública que pode obter acesso a uma rede privada. Todo o tráfego que não corresponde às regras é bloqueado e registrado. Os firewalls inclusivos são geralmente mais seguros do que os firewalls exclusivos, pois reduzem significativamente o risco de permitir tráfego indesejado.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Salvo indicação contrária, todos os conjuntos de regras de configuração e exemplo neste capítulo criam conjuntos de regras de firewall inclusivos.</p></div></td></tr></tbody></table></div><div class=paragraph><p>A segurança pode ser reforçada usando um "firewall stateful". Esse tipo de firewall registra e acompanha as conexões abertas e libera apenas o tráfego que corresponde a uma conexão existente ou libera e abre uma nova conexão.</p></div><div class=paragraph><p>A filtragem stateful trata o tráfego como uma troca bidirecional de pacotes compondo uma sessão. Quando um estado é especificado em uma regra de correspondência, o firewall gera dinamicamente regras internas para cada pacote antecipado sendo trocado durante a sessão. Ele possui recursos de correspondência suficientes para determinar se um pacote é válido para uma sessão. Quaisquer pacotes que não se encaixem corretamente no modelo de sessão serão automaticamente rejeitados.</p></div><div class=paragraph><p>Quando a sessão é concluída, ela é removida da tabela de estados dinâmicos.</p></div><div class=paragraph><p>A filtragem stateful permite dar foco no bloqueio/liberação de novas sessões. Se a nova sessão for passada, todos os seus pacotes subsequentes serão permitidos automaticamente e todos os pacotes de um impostor serão automaticamente rejeitados. Se uma nova sessão for bloqueada, nenhum dos seus pacotes subsequentes serão permitidos. A filtragem stateful fornece habilidades de correspondência avançadas capazes de se defender contra o flood de diferentes métodos de ataque empregados pelos invasores.</p></div><div class=paragraph><p>NAT significa <em>Tradução de Endereços de Rede</em>. A função NAT permite que a LAN privada por trás do firewall compartilhe um único endereço IP atribuído pelo ISP, mesmo que esse endereço seja atribuído dinamicamente. O NAT permite que cada computador na LAN tenha acesso à Internet, sem ter que pagar ao ISP por várias contas de Internet ou endereços IP.</p></div><div class=paragraph><p>O NAT traduzirá automaticamente o endereço IP da LAN privada de cada sistema na LAN para o único endereço IP público, à medida que os pacotes saem do firewall vinculado à Internet pública. Também executa a conversão inversa para devolver os pacotes.</p></div><div class=paragraph><p>De acordo com a RFC 1918, os seguintes intervalos de endereços IP são reservados para redes privadas que nunca serão roteadas diretamente para a Internet pública e, portanto, estão disponíveis para uso com o NAT:</p></div><div class=ulist><ul><li><p><code>10.0.0.0/8</code>.</p></li><li><p><code>172.16.0.0/12</code>.</p></li><li><p><code>192.168.0.0/16</code>.</p></li></ul></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Ao trabalhar com regras de firewall, seja <em>muito cuidadoso</em>. Algumas configurações <em>podem bloquear o administrador</em> do servidor. Para estar seguro, considere executar a configuração inicial do firewall a partir do console local, em vez de fazê-lo remotamente por ssh.</p></div></td></tr></tbody></table></div></div></div><div class=sect1><h2 id=firewalls-pf>30.3. PF<a class=anchor href=#firewalls-pf></a></h2><div class=sectionbody><div class=paragraph><p>Desde o FreeBSD 5.3, uma versão portada do firewall PF do OpenBSD foi incluída como uma parte integrada do sistema base. O PF é um firewall completo, cheio de recursos que possui suporte opcional para ALTQ (Alternate Queuing), que fornece Qualidade de Serviço (QoS).</p></div><div class=paragraph><p>O Projeto OpenBSD mantém a referência definitiva para PF no <a href=http://www.openbsd.org/faq/pf/>FAQ do PF</a>. Peter Hansteen mantém um tutorial completo do PF em <a href=http://home.nuug.no/~peter/pf/>http://home.nuug.no/~peter/pf/</a>.</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Ao ler o <a href=http://www.openbsd.org/faq/pf/>FAQ do PF</a>, tenha em mente que a versão do PF do FreeBSD divergiu substancialmente da versão inicial do OpenBSD ao longo dos anos. Nem todos os recursos funcionam da mesma maneira no FreeBSD como no OpenBSD e vice-versa.</p></div></td></tr></tbody></table></div><div class=paragraph><p>A <a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-pf>lista de emails do packet filter do FreeBSD</a> é um bom lugar para perguntar questões relacionadas a configuração e execução do firewall PF. Verifique os arquivos da lista de email antes de perguntar alguma questão, pois ela já pode ter sido respondida.</p></div><div class=paragraph><p>Esta seção do Handbook foca no PF no que se refere ao FreeBSD. Ele demonstra como ativar o PF e ALTQ. Em seguida, ele fornece vários exemplos para criar conjuntos de regras em um sistema FreeBSD.</p></div><div class=sect2><h3 id=_ativando_o_pf>30.3.1. Ativando o PF<a class=anchor href=#_ativando_o_pf></a></h3><div class=paragraph><p>Para usar o PF, seu módulo do kernel deve ser carregado primeiro. Esta seção descreve as entradas que podem ser adicionadas ao <span class=filename>/etc/rc.conf</span> para habilitar o PF.</p></div><div class=paragraph><p>Comece adicionando a seguinte linha <code>pf_enable=yes</code> ao arquivo <span class=filename>/etc/rc.conf</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysrc pf_enable=yes</span></code></pre></div></div><div class=paragraph><p>Opções adicionais, descritas em <a href="https://man.freebsd.org/cgi/man.cgi?query=pfctl&amp;sektion=8&amp;format=html">pfctl(8)</a>, podem ser passadas para o PF quando ele é iniciado. Adicione esta entrada ao arquivo <span class=filename>/etc/rc.conf</span> e especifique quaisquer flags necessárias entre duas aspas (<code>""</code>):</p></div><div class="literalblock programlisting"><div class=content><pre>pf_flags=&#34;&#34;                     # additional flags for pfctl startup</pre></div></div><div class=paragraph><p>O PF não será iniciado se não puder localizar o arquivo de configuração do conjunto de regras. Por padrão, o FreeBSD não vem com um conjunto de regras e não há um <span class=filename>/etc/pf.conf</span>. Exemplos de regras podem ser encontrados em <span class=filename>/usr/shared/examples/pf/</span>. Se um conjunto de regras personalizado foi salvo em algum outro lugar, adicione uma linha ao arquivo <span class=filename>/etc/rc.conf</span> que especifica o caminho completo para o arquivo:</p></div><div class="literalblock programlisting"><div class=content><pre>pf_rules=&#34;/path/to/pf.conf&#34;</pre></div></div><div class=paragraph><p>O suporte de log para o PF é fornecido pelo <a href="https://man.freebsd.org/cgi/man.cgi?query=pflog&amp;sektion=4&amp;format=html">pflog(4)</a>. Para ativar o suporte aos logs, adicione esta linha ao <span class=filename>/etc/rc.conf</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysrc pflog_enable=yes</span></code></pre></div></div><div class=paragraph><p>As seguintes linhas também podem ser adicionadas para alterar a localização padrão do arquivo de log ou para especificar quaisquer flags adicionais na inicialização do <a href="https://man.freebsd.org/cgi/man.cgi?query=pflog&amp;sektion=4&amp;format=html">pflog(4)</a>:</p></div><div class="literalblock programlisting"><div class=content><pre>pflog_logfile=&#34;/var/log/pflog&#34;  # where pflogd should store the logfile
pflog_flags=&#34;&#34;                  # additional flags for pflogd startup</pre></div></div><div class=paragraph><p>Finalmente, se houver uma LAN atrás do firewall e os pacotes precisarem ser encaminhados para os computadores na LAN, ou se NAT for necessário, adicione a seguinte opção:</p></div><div class="literalblock programlisting"><div class=content><pre>gateway_enable=&#34;YES&#34;            # Enable as LAN gateway</pre></div></div><div class=paragraph><p>Depois de salvar as edições necessárias, o PF pode ser iniciado com o suporte de log, digitando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service pf start</span>
<span class=c># service pflog start</span></code></pre></div></div><div class=paragraph><p>Por padrão, o PF lê suas regras de configuração do arquivo <span class=filename>/etc/pf.conf</span> e modifica, descarta ou libera pacotes de acordo com as regras ou definições especificadas neste arquivo. A instalação do FreeBSD inclui vários arquivos de exemplo localizados em <span class=filename>/usr/shared/examples/pf/</span>. Consulte o <a href=http://www.openbsd.org/faq/pf/>FAQ do PF</a> para obter uma cobertura completa dos conjuntos de regras do PF.</p></div><div class=paragraph><p>Para controlar o PF, use o <code>pfctl</code>. <a href=#pfctl>Opções Úteis do <code>pfctl</code></a> resume algumas opções úteis para este comando. Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=pfctl&amp;sektion=8&amp;format=html">pfctl(8)</a> para obter uma descrição de todas as opções disponíveis:</p></div><table id=pfctl class="tableblock frame-none grid-all stretch"><caption class=title>Tabela 1. Opções Úteis do <code>pfctl</code></caption><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Comando</th><th class="tableblock halign-left valign-top">Propósito</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>pfctl -e</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Ativa o PF.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>pfctl -d</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Desabilita o PF.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>pfctl -F all -f /etc/pf.conf</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Limpa todas as regras de NAT, filtro, estado e tabela e recarrega o <span class=filename>/etc/pf.conf</span>.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>pfctl -s [ rules | nat | states ]</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Informa as regras de filtragem, de NAT ou a tabela de estados.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>pfctl -vnf /etc/pf.conf</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Verifica se tem erros no arquivo <span class=filename>/etc/pf.conf</span>, mas não carrega o conjunto de regras.</p></td></tr></tbody></table><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p><a class=package href=https://cgit.freebsd.org/ports/tree/security/sudo/>security/sudo</a> é útil para executar comandos como <code>pfctl</code> que exigem privilégios elevados. Ele pode ser instalado a partir da Coleção de Ports.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Para ficar de olho no tráfego que passa pelo firewall PF, considere instalar o pacote ou port <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/pftop/>sysutils/pftop</a>. Uma vez instalado, o pftop pode ser executado para exibir um snapshot do estado atual do tráfego em um formato semelhante ao <a href="https://man.freebsd.org/cgi/man.cgi?query=top&amp;sektion=1&amp;format=html">top(1)</a>.</p></div></div><div class=sect2><h3 id=pf-tutorial>30.3.2. Conjuntos de Regras do PF<a class=anchor href=#pf-tutorial></a></h3><div class=paragraph><p>Esta seção demonstra como criar um conjunto de regras personalizado. Ele começa com o mais simples dos conjuntos de regras e baseia-se em seus conceitos usando vários exemplos para demonstrar o uso real dos diversos recursos do PF.</p></div><div class=paragraph><p>O conjunto de regras mais simples possível é para uma única máquina que não executa nenhum serviço e que precisa de acesso a uma rede, que pode ser a Internet. Para criar este conjunto de regras mínimo, edite o arquivo <span class=filename>/etc/pf.conf</span> para que fique assim:</p></div><div class="literalblock programlisting"><div class=content><pre>block in all
pass out all keep state</pre></div></div><div class=paragraph><p>A primeira regra nega todo o tráfego de entrada por padrão. A segunda regra permite que as conexões originadas por este sistema sejam liberadas, mantendo as informações de estado nessas conexões. Essas informações de estado permitem que o tráfego de retorno para essas conexões seja liberado e só deve ser usado em máquinas confiáveis. O conjunto de regras pode ser carregado com:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pfctl -e ; pfctl -f /etc/pf.conf</span></code></pre></div></div><div class=paragraph><p>Além de manter estados, o PF fornece <em>listas</em> e <em>macros</em> que podem ser definidas para uso ao criar regras. As macros podem incluir listas e precisam ser definidas antes de serem usadas. Como exemplo, insira essas linhas no topo do conjunto de regras:</p></div><div class="literalblock programlisting"><div class=content><pre>tcp_services = &#34;{ ssh, smtp, domain, www, pop3, auth, pop3s }&#34;
udp_services = &#34;{ domain }&#34;</pre></div></div><div class=paragraph><p>O PF entende os nomes das portas, assim como os números das portas, desde que os nomes estejam listados em <span class=filename>/etc/services</span>. Este exemplo cria duas macros. A primeira é uma lista de sete nomes de portas TCP e a segunda é um nome de porta UDP. Uma vez definidas, as macros podem ser usadas em regras. Neste exemplo, todo o tráfego é bloqueado, exceto pelas conexões originadas por este sistema para os sete serviços TCP especificados e para o serviço UDP especificado:</p></div><div class="literalblock programlisting"><div class=content><pre>tcp_services = &#34;{ ssh, smtp, domain, www, pop3, auth, pop3s }&#34;
udp_services = &#34;{ domain }&#34;
block all
pass out proto tcp to any port $tcp_services keep state
pass proto udp to any port $udp_services keep state</pre></div></div><div class=paragraph><p>Embora o UDP seja considerado um protocolo sem estado, o PF é capaz de rastrear algumas informações de estado. Por exemplo, quando uma solicitação UDP é liberada perguntando a um servidor de nomes sobre um nome de domínio, o PF irá procurar pela resposta para libera-la.</p></div><div class=paragraph><p>Sempre que uma edição é feita em um conjunto de regras, as novas regras devem ser carregadas para que possam ser usadas:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pfctl -f /etc/pf.conf</span></code></pre></div></div><div class=paragraph><p>Se não houver erros de sintaxe, o <code>pfctl</code> não exibirá nenhuma mensagem durante o carregamento da regra. As regras também podem ser testadas antes de tentar carregá-las:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pfctl -nf /etc/pf.conf</span></code></pre></div></div><div class=paragraph><p>A inclusão de <code>-n</code> faz com que as regras sejam interpretadas apenas, mas não carregadas. Isso fornece uma oportunidade para corrigir quaisquer erros. Em todos os momentos, o último conjunto de regras válido carregado será imposto até que o PF seja desativado ou um novo conjunto de regras seja carregado.</p></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Adicionando <code>-v</code> ao comando <code>pfctl</code> no carregamento ou checagem de conjuntos de regras, será exibido as regras exatamente da maneira como elas serão carregadas. Isso é extremamente útil ao depurar regras.</p></div></td></tr></tbody></table></div><div class=sect3><h4 id=pftut-gateway>30.3.2.1. Um Gateway Simples com NAT<a class=anchor href=#pftut-gateway></a></h4><div class=paragraph><p>Esta seção demonstra como configurar um sistema FreeBSD executando PF para atuar como um gateway para pelo menos uma outra máquina. O gateway precisa de pelo menos duas interfaces de rede, cada uma conectada a uma rede separada. Neste exemplo, <span class=filename>xl1</span> está conectada à Internet e a <span class=filename>xl0</span> está conectada à rede interna.</p></div><div class=paragraph><p>Primeiro, ative o gateway para permitir que a máquina encaminhe o tráfego de rede que recebe em uma interface para outra interface. Esta configuração do sysctl encaminhará pacotes IPv4:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl net.inet.ip.forwarding=1</span></code></pre></div></div><div class=paragraph><p>Para encaminhar tráfego IPv6, use:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl net.inet6.ip6.forwarding=1</span></code></pre></div></div><div class=paragraph><p>Para ativar essas configurações na inicialização do sistema, use o <a href="https://man.freebsd.org/cgi/man.cgi?query=sysrc&amp;sektion=8&amp;format=html">sysrc(8)</a> para adicioná-las ao <span class=filename>/etc/rc.conf</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysrc gateway_enable=yes</span>
<span class=c># sysrc ipv6_gateway_enable=yes</span></code></pre></div></div><div class=paragraph><p>Verifique com o <code>ifconfig</code> se ambas as interfaces estão ativadas e em execução.</p></div><div class=paragraph><p>Em seguida, crie as regras PF para permitir que o gateway transmita tráfego. Embora a regra a seguir permita que o tráfego stateful de hosts da rede interna passe para o gateway, a palavra-chave <code>to</code> não garante a passagem da origem até o destino:</p></div><div class="literalblock programlisting"><div class=content><pre>pass in on xl1 from xl1:network to xl0:network port $ports keep state</pre></div></div><div class=paragraph><p>Essa regra só permite que o tráfego passe para o gateway na interface interna. Para deixar os pacotes irem mais longe, é necessária uma regra de correspondência:</p></div><div class="literalblock programlisting"><div class=content><pre>pass out on xl0 from xl1:network to xl0:network port $ports keep state</pre></div></div><div class=paragraph><p>Embora essas duas regras funcionem, regras especificadas dessa forma raramente são necessárias. Para um administrador de rede ocupado, um conjunto de regras legível é um conjunto de regras mais seguro. O restante desta seção demonstra como manter as regras o mais simples possível para facilitar a leitura. Por exemplo, essas duas regras podem ser substituídas por uma regra:</p></div><div class="literalblock programlisting"><div class=content><pre>pass from xl1:network to any port $ports keep state</pre></div></div><div class=paragraph><p>A notação <code>interface:network</code> pode ser substituída por uma macro para tornar o conjunto de regras ainda mais legível. Por exemplo, uma macro <code>$localnet</code> pode ser definida como a rede diretamente conectada à interface interna (<code>$xl1:network</code>). Alternativamente, a definição de <code>$localnet</code> poderia ser alterada para uma notação <em>IP address/netmask</em> para denotar uma rede, como <code>192.168.100.1/24</code> para uma sub-rede de endereços privados.</p></div><div class=paragraph><p>Se necessário, <code>$localnet</code> pode ser definido como uma lista de redes. Quaisquer que sejam as necessidades específicas, uma definição sensata de <code>$localnet</code> poderia ser usada em uma regra típica de liberação da seguinte maneira:</p></div><div class="literalblock programlisting"><div class=content><pre>pass from $localnet to any port $ports keep state</pre></div></div><div class=paragraph><p>O conjunto de regras de exemplo a seguir libera todo o tráfego originado por máquinas na rede interna. Primeiro define duas macros para representar as interfaces externas e internas 3COM do gateway.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Para usuários dial-up, a interface externa será <span class=filename>tun0</span>. Para uma conexão ADSL, especificamente aquelas que usam PPP over Ethernet (PPPoE), a interface externa correta é <span class=filename>tun0</span>, não a interface física Ethernet.</p></div></td></tr></tbody></table></div><div class="literalblock programlisting"><div class=content><pre>ext_if = &#34;xl0&#34;	# macro for external interface - use tun0 for PPPoE
int_if = &#34;xl1&#34;	# macro for internal interface
localnet = $int_if:network
# ext_if IP address could be dynamic, hence ($ext_if)
nat on $ext_if from $localnet to any -&gt; ($ext_if)
block all
pass from { lo0, $localnet } to any keep state</pre></div></div><div class=paragraph><p>Este conjunto de regras introduz a regra <code>nat</code> que é usada para tratar a tradução de endereços de rede dos endereços não roteáveis dentro da rede interna para o endereço IP atribuído à interface externa. Os parênteses em torno da última parte da regra nat <code>($ext_if)</code> são incluídos quando o endereço IP da interface externa é atribuído dinamicamente. Ele garante que o tráfego de rede seja executado sem interrupções graves, mesmo se o endereço IP externo for alterado.</p></div><div class=paragraph><p>Observe que esse conjunto de regras provavelmente permite que mais tráfego seja transmitido para fora da rede do que o necessário. Uma configuração razoável poderia criar essa macro:</p></div><div class="literalblock programlisting"><div class=content><pre>client_out = &#34;{ ftp-data, ftp, ssh, domain, pop3, auth, nntp, http, \
    https, cvspserver, 2628, 5999, 8000, 8080 }&#34;</pre></div></div><div class=paragraph><p>para usar na regra principal de liberação:</p></div><div class="literalblock programlisting"><div class=content><pre>pass inet proto tcp from $localnet to any port $client_out \
    flags S/SA keep state</pre></div></div><div class=paragraph><p>Algumas outras regras de aprovação podem ser necessárias. Esta permite ativar o SSH na interface externa:</p></div><div class="literalblock programlisting"><div class=content><pre>pass in inet proto tcp to $ext_if port ssh</pre></div></div><div class=paragraph><p>Esta definição de macro e regra permite DNS e NTP para clientes internos:</p></div><div class="literalblock programlisting"><div class=content><pre>udp_services = &#34;{ domain, ntp }&#34;
pass quick inet proto { tcp, udp } to any port $udp_services keep state</pre></div></div><div class=paragraph><p>Observe a palavra-chave <code>quick</code> nesta regra. Como o conjunto de regras consiste em várias regras, é importante entender as relações entre as regras em um conjunto de regras. As regras são avaliadas de cima para baixo, na sequência em que são escritas. Para cada pacote ou conexão avaliado pelo PF, <em>a última regra correspondente</em> no conjunto de regras é aquela que é aplicada. No entanto, quando um pacote corresponde a uma regra que contém a palavra-chave <code>quick</code>, o processamento da regra é interrompido e o pacote é tratado de acordo com essa regra. Isso é muito útil quando é necessária uma exceção às regras gerais.</p></div></div><div class=sect3><h4 id=pftut-ftp>30.3.2.2. Criando um Proxy FTP<a class=anchor href=#pftut-ftp></a></h4><div class=paragraph><p>Configurar regras funcionais de FTP pode ser problemático devido à natureza do protocolo FTP. O FTP pré-data os firewalls por várias décadas e é inseguro em seu design. Os pontos mais comuns contra o uso do FTP incluem:</p></div><div class=ulist><ul><li><p>As senhas são transferidas em texto puro.</p></li><li><p>O protocolo exige o uso de pelo menos duas conexões TCP (controle e dados) em portas separadas.</p></li><li><p>Quando uma sessão é estabelecida, os dados são transmitidos usando portas selecionadas aleatoriamente.</p></li></ul></div><div class=paragraph><p>Todos esses pontos apresentam desafios de segurança, mesmo antes de considerar possíveis pontos fracos de segurança no software cliente ou servidor. Há alternativas mais seguras para a transferência de arquivos, como <a href="https://man.freebsd.org/cgi/man.cgi?query=sftp&amp;sektion=1&amp;format=html">sftp(1)</a> ou <a href="https://man.freebsd.org/cgi/man.cgi?query=scp&amp;sektion=1&amp;format=html">scp(1)</a>, que apresentam autenticação e transferência de dados através de conexões criptografadas.</p></div><div class=paragraph><p>Para as situações em que o FTP é necessário, o PF fornece o redirecionamento do tráfego FTP para um pequeno programa proxy chamado <a href="https://man.freebsd.org/cgi/man.cgi?query=ftp-proxy&amp;sektion=8&amp;format=html">ftp-proxy(8)</a>, que está incluído no sistema base do FreeBSD. O papel do proxy é inserir dinamicamente e excluir regras no conjunto de regras, usando um conjunto de âncoras, para lidar corretamente com o tráfego de FTP.</p></div><div class=paragraph><p>Para habilitar o proxy FTP, adicione esta linha ao <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>ftpproxy_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Em seguida, inicie o proxy executando <code>service ftp-proxy start</code>.</p></div><div class=paragraph><p>Para uma configuração básica, três elementos precisam ser adicionados ao arquivo <span class=filename>/etc/pf.conf</span>. Primeiro, as âncoras que o proxy usará para inserir as regras que ele gera para as sessões de FTP:</p></div><div class="literalblock programlisting"><div class=content><pre>nat-anchor &#34;ftp-proxy/*&#34;
rdr-anchor &#34;ftp-proxy/*&#34;</pre></div></div><div class=paragraph><p>Em segundo, é necessária uma regra de liberação para permitir o tráfego de FTP para o proxy.</p></div><div class=paragraph><p>Terceiro, as regras de redirecionamento e NAT precisam ser definidas antes das regras de filtragem. Insira esta regra <code>rdr</code> imediatamente após a regra <code>nat</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>rdr pass on $int_if proto tcp from any to any port ftp -&gt; 127.0.0.1 port 8021</pre></div></div><div class=paragraph><p>Finalmente, permita que o tráfego redirecionado passe:</p></div><div class="literalblock programlisting"><div class=content><pre>pass out proto tcp from $proxy to any port ftp</pre></div></div><div class=paragraph><p>onde <code>$proxy</code> se expande para o endereço ao qual o daemon proxy está vinculado.</p></div><div class=paragraph><p>Salve o arquivo <span class=filename>/etc/pf.conf</span>, carregue as novas regras e verifique a partir de um cliente se as conexões FTP estão funcionando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pfctl -f /etc/pf.conf</span></code></pre></div></div><div class=paragraph><p>Este exemplo cobre uma configuração básica em que os clientes na rede local precisam entrar em contato com servidores FTP em outro lugar. Essa configuração básica deve funcionar bem com a maioria das combinações de clientes e servidores FTP. Como mostrado em <a href="https://man.freebsd.org/cgi/man.cgi?query=ftp-proxy&amp;sektion=8&amp;format=html">ftp-proxy(8)</a>, o comportamento do proxy pode ser alterado de várias maneiras adicionando opções na linha <code>ftpproxy_flags=</code>. Alguns clientes ou servidores podem ter peculiaridades específicas que devem ser compensadas na configuração ou pode ser necessário integrar o proxy de maneiras específicas, como atribuir tráfego FTP a uma fila específica.</p></div><div class=paragraph><p>Para formas de executar um servidor FTP protegido por PF e <a href="https://man.freebsd.org/cgi/man.cgi?query=ftp-proxy&amp;sektion=8&amp;format=html">ftp-proxy(8)</a>, configure um <code>ftp-proxy</code> separado em modo reverso, usando <code>-R</code>, em uma porta separada com sua própria regra de redirecionamento de passagem.</p></div></div><div class=sect3><h4 id=pftut-icmp>30.3.2.3. Gerenciando ICMP<a class=anchor href=#pftut-icmp></a></h4><div class=paragraph><p>Muitas das ferramentas usadas para depurar ou solucionar problemas de uma rede TCP/IP dependem do Internet Control Message Protocol (ICMP), o qual foi projetado especificamente para depuração.</p></div><div class=paragraph><p>O protocolo ICMP envia e recebe <em>mensagens de controle</em> entre hosts e gateways, principalmente para fornecer feedback a um remetente sobre quaisquer condições incomuns ou difíceis na rota para o host de destino. Os roteadores usam ICMP para negociar tamanhos de pacote e outros parâmetros de transmissão em um processo geralmente chamado de descoberta de <em>path MTU</em>.</p></div><div class=paragraph><p>Do ponto de vista do firewall, algumas mensagens de controle ICMP são vulneráveis a vetores de ataque conhecidos. Além disso, deixar todo o tráfego de diagnóstico passar incondicionalmente torna a depuração mais fácil, mas também torna mais fácil para os outros extraírem informações sobre a rede. Por esses motivos, a regra a seguir pode não ser a ideal:</p></div><div class="literalblock programlisting"><div class=content><pre>pass inet proto icmp from any to any</pre></div></div><div class=paragraph><p>Uma solução é permitir todo o tráfego de ICMP originado na rede local e bloquear as chamadas provenientes de fora da rede:</p></div><div class="literalblock programlisting"><div class=content><pre>pass inet proto icmp from $localnet to any keep state
pass inet proto icmp from any to $ext_if keep state</pre></div></div><div class=paragraph><p>Opções adicionais estão disponíveis, o que demonstra algumas das flexibilidades do PF. Por exemplo, em vez de liberar todas as mensagens ICMP, pode-se especificar as mensagens usadas pelo <a href="https://man.freebsd.org/cgi/man.cgi?query=ping&amp;sektion=8&amp;format=html">ping(8)</a> e <a href="https://man.freebsd.org/cgi/man.cgi?query=traceroute&amp;sektion=8&amp;format=html">traceroute(8)</a>. Comece definindo uma macro para esse tipo de mensagem:</p></div><div class="literalblock programlisting"><div class=content><pre>icmp_types = &#34;echoreq&#34;</pre></div></div><div class=paragraph><p>e uma regra que usa a macro:</p></div><div class="literalblock programlisting"><div class=content><pre>pass inet proto icmp all icmp-type $icmp_types keep state</pre></div></div><div class=paragraph><p>Se outros tipos de pacotes ICMP forem necessários, expanda <code>icmp_types</code> para uma lista desses tipos de pacotes. Digite <code>more /usr/src/sbin/pfctl/pfctl_parser.c</code> para ver a lista de tipos de mensagem ICMP suportados pelo PF. Consulte <a href=http://www.iana.org/assignments/icmp-parameters/icmp-parameters.xhtml>http://www.iana.org/assignments/icmp-parameters/icmp-parameters.xhtml</a> para uma explicação de cada tipo de mensagem.</p></div><div class=paragraph><p>Como o Unix <code>traceroute</code> usa UDP por padrão, outra regra é necessária para permitir o comando <code>traceroute</code> do Unix:</p></div><div class="literalblock programlisting"><div class=content><pre># allow out the default range for traceroute(8):
pass out on $ext_if inet proto udp from any to any port 33433 &gt;&lt; 33626 keep state</pre></div></div><div class=paragraph><p>Como o <code>TRACERT.EXE</code> em sistemas Microsoft Windows usa ICMP echo request messages, somente a primeira regra é necessária para permitir rastreamentos de rede desses sistemas. O Unix <code>traceroute</code> também pode ser instruído a usar outros protocolos e usará ICMP echo request messages se <code>-I</code> for usado. Verifique a página de manual <a href="https://man.freebsd.org/cgi/man.cgi?query=traceroute&amp;sektion=8&amp;format=html">traceroute(8)</a> para detalhes.</p></div><div class=sect4><h5 id=pftut-pathmtudisc>30.3.2.3.1. Descoberta de Path MTU<a class=anchor href=#pftut-pathmtudisc></a></h5><div class=paragraph><p>Os protocolos de Internet são projetados para serem independentes do dispositivo, e uma consequência da independência do dispositivo é que o tamanho ideal do pacote para uma determinada conexão nem sempre pode ser previsto com segurança. A principal restrição no tamanho do pacote é a <em>Maximum Transmission Unit</em> (MTU), que define o limite superior do tamanho do pacote para uma interface. Digite <code>ifconfig</code> para exibir os MTUs para as interfaces de rede do sistema.</p></div><div class=paragraph><p>O TCP/IP usa um processo conhecido como descoberta de path MTU para determinar o tamanho correto do pacote para uma conexão. Este processo envia pacotes de tamanhos variados com o conjunto de flag "Não fragmentar", esperando um pacote de retorno ICMP de "tipo 3, código 4" quando o limite for alcançado. O tipo 3 significa "destino inacessível", e o código 4 é uma abreviação para "fragmentação necessária, mas a flag para não fragmentar está definida". Para permitir que a descoberta de path MTU suporte conexões com outros MTUs, adicione o tipo <code>destination unreachable</code> à macro <code>icmp_types</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>icmp_types = &#34;{ echoreq, unreach }&#34;</pre></div></div><div class=paragraph><p>Como a regra de liberação já usa essa macro, ela não precisa ser modificada para suportar o novo tipo de ICMP:</p></div><div class="literalblock programlisting"><div class=content><pre>pass inet proto icmp all icmp-type $icmp_types keep state</pre></div></div><div class=paragraph><p>O PF permite filtrar todas as variações dos tipos e códigos de ICMP. A lista de tipos e códigos possíveis está documentada em <a href="https://man.freebsd.org/cgi/man.cgi?query=icmp&amp;sektion=4&amp;format=html">icmp(4)</a> and <a href="https://man.freebsd.org/cgi/man.cgi?query=icmp6&amp;sektion=4&amp;format=html">icmp6(4)</a>.</p></div></div></div><div class=sect3><h4 id=pftut-tables>30.3.2.4. Usando Tabelas<a class=anchor href=#pftut-tables></a></h4><div class=paragraph><p>Alguns tipos de dados são relevantes para filtragem e redirecionamento em um determinado momento, mas sua definição é muito longa para ser incluída no arquivo do conjunto de regras. O PF suporta o uso de tabelas, que são listas definidas que podem ser manipuladas sem a necessidade de recarregar todo o conjunto de regras e que podem fornecer pesquisas rápidas. Nomes de tabelas são sempre colocados dentro de <code>&lt; ></code>, assim:</p></div><div class="literalblock programlisting"><div class=content><pre>table &lt;clients&gt; { 192.168.2.0/24, !192.168.2.5 }</pre></div></div><div class=paragraph><p>Neste exemplo, a rede <code>192.168.2.0/24</code> faz parte da tabela, exceto pelo endereço <code>192.168.2.5</code>, que é excluído pelo operador <code>!</code>. Também é possível carregar tabelas de arquivos onde cada entrada está em uma linha separada. como neste exemplo <span class=filename>/etc/clients</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>192.168.2.0/24
!192.168.2.5</pre></div></div><div class=paragraph><p>Para se referir ao arquivo, defina a tabela da seguinte forma:</p></div><div class="literalblock programlisting"><div class=content><pre>table &lt;clients&gt; persist file &#34;/etc/clients&#34;</pre></div></div><div class=paragraph><p>Depois que a tabela é definida, ela pode ser referenciada por uma regra:</p></div><div class="literalblock programlisting"><div class=content><pre>pass inet proto tcp from &lt;clients&gt; to any port $client_out flags S/SA keep state</pre></div></div><div class=paragraph><p>O conteúdo de uma tabela pode ser manipulado ao vivo, usando <code>pfctl</code>. Este exemplo adiciona outra rede a tabela:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pfctl -t clients -T add 192.168.1.0/16</span></code></pre></div></div><div class=paragraph><p>Observe que quaisquer alterações feitas dessa maneira terão efeito imediato, tornando-as ideais para testes, mas não sobreviverão a uma falha de energia ou reinicialização. Para tornar as alterações permanentes, modifique a definição da tabela no conjunto de regras ou edite o arquivo a que a tabela se refere. É possível manter a cópia em disco da tabela usando uma tarefa <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a> que copia o conteúdo da tabela para o disco em intervalos de tempo, usando um comando como <code>pfctl -t clients -T show >/etc/clients</code>. Alternativamente, o <span class=filename>/etc/clients</span> pode ser atualizado com o conteúdo da tabela na memória:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pfctl -t clients -T replace -f /etc/clients</span></code></pre></div></div></div><div class=sect3><h4 id=pftut-overload>30.3.2.5. Usando Tabelas de Sobrecarga para Proteger o SSH<a class=anchor href=#pftut-overload></a></h4><div class=paragraph><p>Aqueles que executam o SSH em uma interface externa provavelmente já viram algo assim nos logs de autenticação:</p></div><div class="literalblock programlisting"><div class=content><pre>Sep 26 03:12:34 skapet sshd[25771]: Failed password for root from 200.72.41.31 port 40992 ssh2
Sep 26 03:12:34 skapet sshd[5279]: Failed password for root from 200.72.41.31 port 40992 ssh2
Sep 26 03:12:35 skapet sshd[5279]: Received disconnect from 200.72.41.31: 11: Bye Bye
Sep 26 03:12:44 skapet sshd[29635]: Invalid user admin from 200.72.41.31
Sep 26 03:12:44 skapet sshd[24703]: input_userauth_request: invalid user admin
Sep 26 03:12:44 skapet sshd[24703]: Failed password for invalid user admin from 200.72.41.31 port 41484 ssh2</pre></div></div><div class=paragraph><p>Isso indica um ataque de força bruta em que alguém ou algum programa está tentando descobrir o nome de usuário e senha que os permitirá entrar no sistema.</p></div><div class=paragraph><p>Se o acesso externo ao SSH for necessário para usuários legítimos, a alteração da porta padrão usada pelo SSH pode oferecer alguma proteção. No entanto, o PF fornece uma solução mais elegante. As regras de liberação podem conter limites sobre o que os hosts de conexão podem fazer e os violadores podem ser banidos para uma tabela de endereços aos quais é negado algum ou todo o acesso. É até possível descartar todas as conexões existentes de máquinas que excedem os limites.</p></div><div class=paragraph><p>Para configurar isso, crie esta tabela na seção de tabelas do conjunto de regras:</p></div><div class="literalblock programlisting"><div class=content><pre>table &lt;bruteforce&gt; persist</pre></div></div><div class=paragraph><p>Então, em algum lugar no início do conjunto de regras, adicione regras para bloquear o acesso bruto, permitindo acesso legítimo:</p></div><div class="literalblock programlisting"><div class=content><pre>block quick from &lt;bruteforce&gt;
pass inet proto tcp from any to $localnet port $tcp_services \
    flags S/SA keep state \
    (max-src-conn 100, max-src-conn-rate 15/5, \
    overload &lt;bruteforce&gt; flush global)</pre></div></div><div class=paragraph><p>A parte entre parênteses define os limites e os valores devem ser alterados para atender aos requisitos locais. Isso pode ser lido da \seguinte forma:</p></div><div class=paragraph><p><code>max-src-conn</code> é o número de conexões simultâneas permitidas de um host.</p></div><div class=paragraph><p><code>max-src-conn-rate</code> é a taxa de novas conexões permitidas de qualquer host único (<em>15</em>) por número de segundos (<em>5</em>).</p></div><div class=paragraph><p><code>overload &lt;bruteforce></code> significa que qualquer host que excede esses limites obtém seu endereço adicionado à tabela <code>bruteforce</code>. O conjunto de regras bloqueia todo o tráfego de endereços na tabela <code>bruteforce</code>.</p></div><div class=paragraph><p>Finalmente, <code>flush global</code> diz que quando um host atinge o limite, todo (<code>global</code>) das conexões desse host será finalizado (<code>flush</code>).</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Estas regras <em>não</em> irão bloquear bruteforcers lentos, como descrito em <a href=http://home.nuug.no/~peter/hailmary2013/>http://home.nuug.no/~peter/hailmary2013/</a>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Este conjunto de regras de exemplo é projetado principalmente como uma ilustração. Por exemplo, se um número grande de conexões em geral é desejado, mas o desejo é ser mais restritivo quando se trata de ssh, complemente a regra acima com algo como o abaixo, no início do conjunto de regras:</p></div><div class="literalblock programlisting"><div class=content><pre>pass quick proto { tcp, udp } from any to any port ssh \
    flags S/SA keep state \
    (max-src-conn 15, max-src-conn-rate 5/3, \
    overload &lt;bruteforce&gt; flush global)</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=title>Pode Não ser Necessário Bloquear Todos os Overloaders</div><div class=paragraph><p>É importante notar que o mecanismo de sobrecarga é uma técnica geral que não se aplica exclusivamente ao SSH, e nem sempre é ideal bloquear totalmente todo o tráfego dos infratores.</p></div><div class=paragraph><p>Por exemplo, uma regra de sobrecarga pode ser usada para proteger um serviço de email ou um serviço Web e a tabela de sobrecarga pode ser usada em uma regra para atribuir infratores a uma fila com uma alocação de largura de banda mínima ou redirecionar para uma página Web específica.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Com o tempo, as tabelas serão preenchidas por regras de sobrecarga e seu tamanho crescerá incrementalmente, ocupando mais memória. Às vezes, um endereço de IP que é bloqueado é atribuído dinamicamente, que já foi atribuído a um host que tem um motivo legítimo para se comunicar com hosts na rede local.</p></div><div class=paragraph><p>Para situações como essas, o pfctl fornece a capacidade de expirar as entradas da tabela. Por exemplo, este comando removerá entradas de tabela <code>&lt;bruteforce></code> que não foram referenciadas por <code>86400</code> segundos:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pfctl -t bruteforce -T expire 86400</span></code></pre></div></div><div class=paragraph><p>Funcionalidade semelhante é fornecida por <a class=package href=https://cgit.freebsd.org/ports/tree/security/expiretable/>security/expiretable</a>, que remove entradas de tabela que não foram acessadas por um período de tempo especificado.</p></div><div class=paragraph><p>Uma vez instalado, o expiretable pode ser executado para remover entradas de tabela <code>&lt;bruteforce></code> mais antigas que uma tempo especifico. Este exemplo remove todas as entradas com mais de 24 horas:</p></div><div class="literalblock programlisting"><div class=content><pre>/usr/local/sbin/expiretable -v -d -t 24h bruteforce</pre></div></div></div><div class=sect3><h4 id=pftut-spamd>30.3.2.6. Protegendo Contra SPAM<a class=anchor href=#pftut-spamd></a></h4><div class=paragraph><p>Não deve ser confundido com o daemon spamd que vem junto com spamassassin, <a class=package href=https://cgit.freebsd.org/ports/tree/mail/spamd/>mail/spamd</a> pode ser configurado com o PF para fornecer uma defesa externa contra SPAM. Esse spamd conecta-se à configuração do PF usando um conjunto de redirecionamentos.</p></div><div class=paragraph><p>Os spammers tendem a enviar um grande número de mensagens, e o SPAM é enviado principalmente de algumas redes amigáveis de spammers e um grande número de máquinas sequestradas, sendo que ambas são reportadas a <em>blacklists</em> bem rápido.</p></div><div class=paragraph><p>Quando uma conexão SMTP de um endereço que está em uma blacklist é recebido, o spamd apresenta seu banner e imediatamente muda para um modo em que ele responde o trágefo SMTP um byte de cada vez. Esta técnica, que pretende desperdiçar tanto tempo quanto possível do spammer, é chamada de <em>tarpitting</em>. A implementação específica que usa respostas de um byte SMTP é muitas vezes referenciada como <em>stuttering</em>.</p></div><div class=paragraph><p>Este exemplo demonstra o procedimento básico para configurar o spamd com blacklists atualizadas automaticamente. Consulte as páginas de manual que são instaladas com o <a class=package href=https://cgit.freebsd.org/ports/tree/mail/spamd/>mail/spamd</a> para mais informações.</p></div><div class="exampleblock procedure"><div class=content><div class=paragraph><p><strong>Procedure: Configurando o spamd</strong></p></div><div class="olist arabic"><ol class=arabic><li><p>Instale o pacote ou port <a class=package href=https://cgit.freebsd.org/ports/tree/mail/spamd/>mail/spamd</a>. Para usar os recursos de greylist do spamd, <a href="https://man.freebsd.org/cgi/man.cgi?query=fdescfs&amp;sektion=5&amp;format=html">fdescfs(5)</a> deve ser montado em <span class=filename>/dev/fd</span>. Adicione a seguinte linha ao arquivo <span class=filename>/etc/fstab</span>:</p><div class="literalblock programlisting"><div class=content><pre> fdescfs /dev/fd fdescfs rw 0 0</pre></div></div><div class=paragraph><p>Em seguida, monte o sistema de arquivos:</p></div><div class="literalblock programlisting"><div class=content><pre># mount fdescfs</pre></div></div></li><li><p>Em seguida, edite o conjunto de regras do PF para incluir:</p><div class="literalblock programlisting"><div class=content><pre>table &lt;spamd&gt; persist
table &lt;spamd-white&gt; persist
rdr pass on $ext_if inet proto tcp from &lt;spamd&gt; to \
    { $ext_if, $localnet } port smtp -&gt; 127.0.0.1 port 8025
rdr pass on $ext_if inet proto tcp from !&lt;spamd-white&gt; to \
    { $ext_if, $localnet } port smtp -&gt; 127.0.0.1 port 8025</pre></div></div><div class=paragraph><p>As duas tabelas <code>&lt;spamd></code> e <code>&lt;spamd-white></code> são essenciais. O trafego SMTP de um endereço listado em <code>&lt;spamd></code> mas não em <code>&lt;spamd-white></code> é redirecionado para o daemon spamd ouvindo a porta 8025.</p></div></li><li><p>O próximo passo é configurar o spamd no arquivo <span class=filename>/usr/local/etc/spamd.conf</span> e adicionar alguns parâmetros no arquivo <span class=filename>rc.conf</span>.</p><div class=paragraph><p>A instalação do <a class=package href=https://cgit.freebsd.org/ports/tree/mail/spamd/>mail/spamd</a> inclui um arquivo de configuração de exemplo (<span class=filename>/usr/local/etc/spamd.conf.sample</span>) e uma página de manual para o <span class=filename>spamd.conf</span>. Refira-se a estes para opções adicionais de configuração além daquelas mostradas neste exemplo.</p></div><div class=paragraph><p>Uma das primeiras linhas no arquivo de configuração que não começa com um sinal de comentário <code>#</code> contém o bloco que define a lista <code>all</code>, que especifica as listas a serem usadas:</p></div><div class="literalblock programlisting"><div class=content><pre>all:\
    :traplist:whitelist:</pre></div></div><div class=paragraph><p>Esta entrada adiciona as blacklists desejadas, separadas por dois pontos (<code>:</code>). Para usar uma whitelist para subtrair endereços de uma blacklist, adicione o nome da whitelist <em>imediatamente</em> após o nome dessa blacklist. Por exemplo: <code>:blacklist:whitelist:</code>.</p></div><div class=paragraph><p>Isto é seguido pela definição da blacklist especificada:</p></div><div class="literalblock programlisting"><div class=content><pre>traplist:\
    :black:\
    :msg=&#34;SPAM. Your address %A has sent spam within the last 24 hours&#34;:\
    :method=http:\
    :file=www.openbsd.org/spamd/traplist.gz</pre></div></div><div class=paragraph><p>onde a primeira linha é o nome da blacklist e a segunda linha especifica o tipo da lista. O campo <code>msg</code> contém a mensagem a ser exibida aos remetentes da blacklist durante a comunicação SMTP. O campo <code>method</code> especifica como o spamd-setup busca os dados da lista; os métodos suportados são <code>http</code>, <code>ftp</code>, de um <code>arquivo</code> em um sistema de arquivos montado e via <code>exec</code> de um programa externo. Finalmente, o campo <code>file</code> especifica o nome do arquivo que o spamd espera receber.</p></div><div class=paragraph><p>A definição da whitelist especificada é semelhante, mas omite o campo <code>msg</code> porque uma mensagem não é necessária:</p></div><div class="literalblock programlisting"><div class=content><pre>whitelist:\
    :white:\
    :method=file:\
    :file=/var/mail/whitelist.txt</pre></div></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=title>Escolha Fontes de Dados com Cuidado</div><div class=paragraph><p>Usar todas as blacklists do arquivo de exemplo <span class=filename>spamd.conf</span> irá colocar na blacklist grandes blocos da Internet. Os administradores precisam editar o arquivo para criar uma configuração ideal que use fontes de dados aplicáveis e, quando necessário, use listas personalizadas.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Em seguida, adicione esta entrada ao arquivo <span class=filename>/etc/rc.conf</span>. Flags adicionais são descritas na página de manual especificada pelo comentário:</p></div><div class="literalblock programlisting"><div class=content><pre>spamd_flags=&#34;-v&#34; # use &#34;&#34; and see spamd-setup(8) for flags</pre></div></div><div class=paragraph><p>Quando terminar, recarregue o conjunto de regras, inicio o spamd digitando <code>service obspamd start</code>, e complete a configuração usando <code>spamd-setup</code>. Finalemente, crie uma tarefa <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a> que chame <code>spamd-setup</code> para atualizar as tabelas razoáveis.</p></div></li></ol></div></div></div><div class=paragraph><p>Em um gateway típico na frente de um servidor de email, os hosts logo começam a ficar presos dentro de segundos ou alguns minutos.</p></div><div class=paragraph><p>PF também suporta <em>greylist</em>, que rejeita temporariamente mensagens de hosts desconhecidos com códigos <em>45n</em>. Conexões de hosts que estão na greylist e que tentam novamente dentro de um tempo razoável de tempo são liberados. O tráfego de remetentes que estão configurados para se comportarem dentro dos limites estabelecidos pela RFC 1123 e pela RFC 2821 é imediatamente permitido.</p></div><div class=paragraph><p>Mais informações sobre técnicas de greylist podem ser encontradas no site <a href=http://www.greylisting.org/>greylisting.org</a>. A coisa mais surpreendente sobre greylist, além de sua simplicidade, é que ainda funciona. Os spammers e os criadores de malware têm sido muito lentos para se adaptar, a fim de contornar essa técnica.</p></div><div class=paragraph><p>O procedimento básico para configurar o greylist é o seguinte:</p></div><div class="exampleblock procedure"><div class=content><div class=paragraph><p><strong>Procedure: Configurando Greylist</strong></p></div><div class="olist arabic"><ol class=arabic><li><p>Certifique-se de que <a href="https://man.freebsd.org/cgi/man.cgi?query=fdescfs&amp;sektion=5&amp;format=html">fdescfs(5)</a> esteja montado conforme descrito na Etapa 1 do Procedimento anterior.</p></li><li><p>Para executar spamd no modo greylist, adicione esta linha ao <span class=filename>/etc/rc.conf</span>:</p><div class="literalblock programlisting"><div class=content><pre>spamd_grey=&#34;YES&#34;  # use spamd greylisting if YES</pre></div></div><div class=paragraph><p>Consulte a página de manual do spamd para obter descrições de parâmetros relacionados adicionais.</p></div></li><li><p>Para concluir a configuração da greylist:</p><div class="literalblock programlisting"><div class=content><pre># service obspamd restart
# service obspamlogd start</pre></div></div></li></ol></div></div></div><div class=paragraph><p>Nos bastidores, a ferramenta de banco de dados spamdb e o atualizador de whitelist spamlogd executam funções essenciais para o recurso de greylist. O spamdb é a interface principal do administrador para gerenciar as greylists, blacklists e whitelists por meio do conteúdo do banco de dados <span class=filename>/var/db/spamdb</span>.</p></div></div><div class=sect3><h4 id=pftut-hygiene>30.3.2.7. Higiene de Rede<a class=anchor href=#pftut-hygiene></a></h4><div class=paragraph><p>Esta seção descreve como o <code>block-policy</code>, <code>scrub</code>, e <code>antispoof</code> pode ser usado para fazer o conjunto de regras se comportar corretamente.</p></div><div class=paragraph><p>O <code>block-policy</code> é uma opção que pode ser definida na parte de <code>opções</code> do conjunto de regras, que precede as regras de redirecionamento e filtragem. Essa opção determina qual feedback, se houver, que o PF envia para hosts que são bloqueados por uma regra. A opção tem dois valores possíveis: <code>drop</code> descarta pacotes bloqueados sem feedback, e <code>return</code> retorna um código de status como <code>Connection refused</code>.</p></div><div class=paragraph><p>Se não definido, a política padrão é <code>drop</code>. Para alterar o <code>block-policy</code>, especifique o valor desejado:</p></div><div class="literalblock programlisting"><div class=content><pre>set block-policy return</pre></div></div><div class=paragraph><p>No PF, <code>scrub</code> é uma palavra-chave que permite a normalização do pacote de rede. Esse processo remonta pacotes fragmentados e descarta pacotes TCP que possuem combinações de sinalizadores inválidos. Ativar <code>scrub</code> fornece uma medida de proteção contra certos tipos de ataques com base no manuseio incorreto de fragmentos de pacotes. Várias opções estão disponíveis, mas a forma mais simples é adequada para a maioria das configurações:</p></div><div class="literalblock programlisting"><div class=content><pre>scrub in all</pre></div></div><div class=paragraph><p>Alguns serviços, como o NFS, exigem opções específicas de manipulação de fragmentos. Consulte <a href=https://home.nuug.no/~peter/pf/en/scrub.html>https://home.nuug.no/~peter/pf/en/scrub.html</a> para mais informações.</p></div><div class=paragraph><p>Este exemplo remonta fragmentos, limpa o bit "não fragmentar" e define o tamanho máximo do segmento para 1440 bytes:</p></div><div class="literalblock programlisting"><div class=content><pre>scrub in all fragment reassemble no-df max-mss 1440</pre></div></div><div class=paragraph><p>O mecanismo <code>antispoof</code> protege contra a atividade de endereços IP falsos ou forjados, principalmente bloqueando pacotes que aparecem em interfaces e em direções que logicamente não são possíveis.</p></div><div class=paragraph><p>Essas regras eliminam tráfego falsificado do resto do mundo, bem como qualquer pacote falsificado originado na rede local:</p></div><div class="literalblock programlisting"><div class=content><pre>antispoof for $ext_if
antispoof for $int_if</pre></div></div></div><div class=sect3><h4 id=pftut-unrouteables>30.3.2.8. Manipulando Endereços Não-Roteados<a class=anchor href=#pftut-unrouteables></a></h4><div class=paragraph><p>Mesmo com um gateway configurado adequadamente para lidar com a tradução de endereços de rede, pode ser necessário compensar as configurações incorretas de outras pessoas. Uma configuração incorreta comum é permitir o tráfego com endereços não roteáveis para a Internet. Como o tráfego de endereços não roteados pode desempenhar um papel em várias técnicas de ataque de DoS, considere bloquear explicitamente o tráfego de endereços não roteáveis de entrar na rede por meio da interface externa.</p></div><div class=paragraph><p>Neste exemplo, uma macro contendo endereços não roteáveis é definida e usada em regras de bloqueio. O tráfego de origem e destino para esses endereços é silenciosamente descartado na interface externa do gateway.</p></div><div class="literalblock programlisting"><div class=content><pre>martians = &#34;{ 127.0.0.0/8, 192.168.0.0/16, 172.16.0.0/12, \
	      10.0.0.0/8, 169.254.0.0/16, 192.0.2.0/24, \
	      0.0.0.0/8, 240.0.0.0/4 }&#34;

block drop in quick on $ext_if from $martians to any
block drop out quick on $ext_if from any to $martians</pre></div></div></div></div><div class=sect2><h3 id=_ativando_o_altq>30.3.3. Ativando o ALTQ<a class=anchor href=#_ativando_o_altq></a></h3><div class=paragraph><p>No FreeBSD, o ALTQ pode ser usado com PF para fornecer Qualidade de Serviço (QOS). Depois que o ALTQ é ativado, as filas podem ser definidas no conjunto de regras que determina a prioridade de processamento dos pacotes de saída.</p></div><div class=paragraph><p>Antes de ativar o ALTQ, consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=altq&amp;sektion=4&amp;format=html">altq(4)</a> para determinar se os drivers das placas de rede instaladas no sistema suportam isto.</p></div><div class=paragraph><p>ALTQ não está disponível como um módulo de kernel carregável. Se as interfaces do sistema suportarem ALTQ, crie um kernel personalizado usando as instruções em <a href=../kernelconfig/#kernelconfig>Configurando o kernel do FreeBSD</a>. As seguintes opções do kernel estão disponíveis. O primeira é necessária para ativar o ALTQ. Pelo menos uma das outras opções é necessária para especificar o algoritmo do scheduler de enfileiramento:</p></div><div class="literalblock programlisting"><div class=content><pre>options         ALTQ
options         ALTQ_CBQ        # Class Based Queuing (CBQ)
options         ALTQ_RED        # Random Early Detection (RED)
options         ALTQ_RIO        # RED In/Out
options         ALTQ_HFSC       # Hierarchical Packet Scheduler (HFSC)
options         ALTQ_PRIQ       # Priority Queuing (PRIQ)</pre></div></div><div class=paragraph><p>Os seguintes algoritmos de agendamento estão disponíveis:</p></div><div class=dlist><dl><dt class=hdlist1>CBQ</dt><dd><p>Class Based Queuing (CBQ) é usado para dividir a largura de banda de uma conexão em diferentes classes ou filas para priorizar o tráfego com base nas regras de filtragem.</p></dd><dt class=hdlist1>RED</dt><dd><p>Random Early Detection (RED) é usado para evitar o congestionamento da rede, medindo o comprimento da fila e comparando-a com os limites mínimo e máximo da fila. Quando a fila está acima do máximo, todos os novos pacotes são descartados aleatoriamente.</p></dd><dt class=hdlist1>RIO</dt><dd><p>No modo Random Early Detection In and Out (RIO), RED mantém vários comprimentos médios de fila e vários valores limite, um para cada nível QOS.</p></dd><dt class=hdlist1>HFSC</dt><dd><p>Hierarchical Fair Service Curve Packet Scheduler (HFSC) é descrito em <a href=http://www-2.cs.cmu.edu/~hzhang/HFSC/main.html>http://www-2.cs.cmu.edu/~hzhang/HFSC/main.html</a>.</p></dd><dt class=hdlist1>PRIQ</dt><dd><p>Priority Queuing (PRIQ) sempre passa primeiro o tráfego que está em uma fila mais alta.</p></dd></dl></div><div class=paragraph><p>Maiores informações sobre os algoritmos de agendamento e os conjuntos de regras de exemplo estão disponíveis no <a href=https://web.archive.org/web/20151109213426/http://www.openbsd.org/faq/pf/queueing.html>arquivo web do OpenBSD</a>.</p></div></div></div></div><div class=sect1><h2 id=firewalls-ipfw>30.4. IPFW<a class=anchor href=#firewalls-ipfw></a></h2><div class=sectionbody><div class=paragraph><p>O IPFW é um firewall stateful para o FreeBSD, que suporta tanto o IPv4 como o IPv6. Ele é composto de vários componentes: o processador de regras de filtro de firewall do kernel e seu recurso integrado de contabilidade de pacotes, o recurso de registro em log, NAT, o <a href="https://man.freebsd.org/cgi/man.cgi?query=dummynet&amp;sektion=4&amp;format=html">dummynet(4)</a> traffic shaper, um recurso de forward, um recurso de bridge e uma habilidade ipstealth.</p></div><div class=paragraph><p>O FreeBSD fornece um conjunto de regras de exemplo em <span class=filename>/etc/rc.firewall</span> que define vários tipos de firewall para cenários comuns para ajudar usuários iniciantes a gerar um conjunto de regras apropriado. O IPFW fornece uma poderosa sintaxe que os usuários avançados podem usar para criar conjuntos de regras personalizados que atendam aos requisitos de segurança de um determinado ambiente.</p></div><div class=paragraph><p>Esta seção descreve como ativar o IPFW, fornece uma visão geral de sua sintaxe de regra e demonstra vários conjuntos de regras para cenários comuns de configuração.</p></div><div class=sect2><h3 id=firewalls-ipfw-enable>30.4.1. Ativando o IPFW<a class=anchor href=#firewalls-ipfw-enable></a></h3><div class=paragraph><p>O IPFW está incluído na instalação base do FreeBSD como um módulo carregável do kernel, o que significa que um kernel customizado não é necessário para ativar o IPFW.</p></div><div class=paragraph><p>Para aqueles usuários que desejam compilar estaticamente o suporte ao IPFW em um kernel personalizado, veja <a href=#firewalls-ipfw-kernelconfig>Opções do Kerne para o IPFW</a>.</p></div><div class=paragraph><p>Para configurar o sistema para ativar o IPFW no momento da inicialização, adicione <code>firewall_enable="YES"</code> ao <span class=filename>/etc/rc.conf</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysrc firewall_enable=&#34;YES&#34;</span></code></pre></div></div><div class=paragraph><p>Para usar um dos tipos de firewall padrão fornecidos pelo FreeBSD, adicione outra linha que especifique o tipo:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysrc firewall_type=&#34;open&#34;</span></code></pre></div></div><div class=paragraph><p>Os tipos disponíveis são:</p></div><div class=ulist><ul><li><p><code>open</code>: passa todo o tráfego.</p></li><li><p><code>client</code>: protege apenas esta máquina.</p></li><li><p><code>simple</code>: protege toda a rede.</p></li><li><p><code>closed</code>: desativa completamente o tráfego IP, exceto na interface de loopback.</p></li><li><p><code>workstation</code>: protege apenas esta máquina usando regras stateful.</p></li><li><p><code>UNKNOWN</code>: desativa o carregamento de regras de firewall.</p></li><li><p><span class=filename>filename</span>: caminho completo do arquivo que contém o conjunto de regras do firewall.</p></li></ul></div><div class=paragraph><p>Se <code>firewall_type</code> estiver definido como <code>client</code> ou <code>simple</code>, modifique as regras padrão encontradas em <span class=filename>/etc/rc.firewall</span> para se adequar a configuração do sistema.</p></div><div class=paragraph><p>Observe que o tipo <code>filename</code> é usado para carregar um conjunto de regras customizado.</p></div><div class=paragraph><p>Uma maneira alternativa de carregar um conjunto de regras personalizado é definir a variável <code>firewall_script</code> para o caminho absoluto de um <em>script executável</em> que inclui comandos IPFW. Os exemplos usados nesta seção assumem que o <code>firewall_script</code> está definido como <span class=filename>/etc/ipfw.rules</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysrc firewall_script=&#34;/etc/ipfw.rules&#34;</span></code></pre></div></div><div class=paragraph><p>Para habilitar o registro em log por meio do <a href="https://man.freebsd.org/cgi/man.cgi?query=syslogd&amp;sektion=8&amp;format=html">syslogd(8)</a>, inclua esta linha:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysrc firewall_logging=&#34;YES&#34;</span></code></pre></div></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Somente regras de firewall com opção de <code>log</code> vão ser registradas. As regras padrão não contém essa opção e deve ser adicionada manualmente. Por isso é avisado que o conjunto de regras padrão é editado para logar. Em adição a isso, rotacionamento de log é desejado se os logs estiverem em um arquivo separado.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Não existe uma variável em <span class=filename>/etc/rc.conf</span> para definir os limites de log. Para limitar o número de vezes que uma regra é registrada por tentativa de conexão, especifique o número usando esta linha no <span class=filename>/etc/sysctl.conf</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># echo &#34;net.inet.ip.fw.verbose_limit=5&#34; &gt;&gt; /etc/sysctl.conf</span></code></pre></div></div><div class=paragraph><p>Para habilitar o registro através de uma interface dedicada chamada <code>ipfw0</code>, adicione esta linha ao <span class=filename>/etc/rc.conf</span> em vez disso:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysrc firewall_logif=&#34;YES&#34;</span></code></pre></div></div><div class=paragraph><p>Em seguida, use o tcpdump para ver o que está sendo registrado:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># tcpdump -t -n -i ipfw0</span></code></pre></div></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Não há sobrecarga devido ao log, a menos que o tcpdump esteja anexado.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Depois de salvar as edições necessárias, inicie o firewall. Para ativar os limites de log agora, defina também o valor <code>sysctl</code> especificado acima:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service ipfw start</span>
<span class=c># sysctl net.inet.ip.fw.verbose_limit=5</span></code></pre></div></div></div><div class=sect2><h3 id=firewalls-ipfw-rules>30.4.2. Sintaxe de Regras IPFW<a class=anchor href=#firewalls-ipfw-rules></a></h3><div class=paragraph><p>Quando um pacote entra no firewall IPFW, ele é comparado com a primeira regra no conjunto de regras e avança uma regra por vez, movendo-se de cima para baixo em sequência. Quando o pacote corresponde aos parâmetros de seleção de uma regra, a ação da regra é executada e a pesquisa do conjunto de regras termina para esse pacote. Isto é conhecido como "primeira combinação vence". Se o pacote não corresponder a nenhuma das regras, ele será pego pela regra padrão obrigatória IPFW de número 65535, que bloqueia todos os pacotes e os descarta silenciosamente. No entanto, se o pacote corresponder a uma regra que contenha as palavras-chave <code>count</code>, <code>skipto</code> ou <code>tee</code>, a pesquisa continuará. Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfw&amp;sektion=8&amp;format=html">ipfw(8)</a> para obter detalhes sobre como essas palavras-chave afetam o processamento de regras.</p></div><div class=paragraph><p>Ao criar uma regra IPFW, as palavras-chave devem ser escritas na seguinte ordem. Algumas palavras-chave são obrigatórias, enquanto outras são opcionais. As palavras mostradas em maiúsculas representam uma variável e as palavras mostradas em minúsculas devem preceder a variável que a segue. O símbolo <code>#</code> é usado para marcar o início de um comentário e pode aparecer no final de uma regra ou em sua própria linha. Linhas em branco são ignoradas.</p></div><div class=paragraph><p><em>CMD RULE_NUMBER set SET_NUMBER ACTION log LOG_AMOUNT PROTO from SRC SRC_PORT to DST DST_PORT OPTIONS</em></p></div><div class=paragraph><p>Esta seção fornece uma visão geral dessas palavras-chave e suas opções. Não é uma lista exaustiva de todas as opções possíveis. Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfw&amp;sektion=8&amp;format=html">ipfw(8)</a> para obter uma descrição completa da sintaxe de regra que pode ser usada ao criar regras IPFW.</p></div><div class=dlist><dl><dt class=hdlist1>CMD</dt><dd><p>Toda regra deve começar com <span class=parameter>ipfw add</span>.</p></dd><dt class=hdlist1>RULE_NUMBER</dt><dd><p>Cada regra é associada a um número de <code>1</code> até <code>65534</code>. O número é usado para indicar a ordem do processamento da regra. Várias regras podem ter o mesmo número e, nesse caso, elas são aplicadas de acordo com a ordem em que foram adicionadas.</p></dd><dt class=hdlist1>SET_NUMBER</dt><dd><p>Cada regra é associada a um número definido de <code>0</code> até <code>31</code>. Os conjuntos podem ser desativados ou ativados individualmente, possibilitando adicionar ou excluir rapidamente um conjunto de regras. Se um SET_NUMBER não for especificado, a regra será adicionada no conjunto <code>0</code>.</p></dd><dt class=hdlist1>ACTION</dt><dd><p>Uma regra pode ser associada a uma das ações a seguir. A ação especificada será executada quando o pacote corresponder ao critério de seleção da regra.</p><div class=paragraph><p><span class=parameter>allow | accept | pass | permit</span>: essas palavras-chave são equivalentes e permitem pacotes que correspondem à regra.</p></div><div class=paragraph><p><span class=parameter>check-state</span>: verifica o pacote em relação à tabela de estados dinâmicos. Se uma correspondência for encontrada, execute a ação associada à regra que gerou essa regra dinâmica, caso contrário, vá para a próxima regra. Uma regra <code>check-state</code> não possui critério de seleção. Se nenhuma regra <code>check-state</code> estiver presente no conjunto de regras, a tabela de regras dinâmicas será verificada na primeira regra <code>keep-state</code> ou <code>limit</code>.</p></div><div class=paragraph><p><span class=parameter>count</span>: atualiza os contadores de todos os pacotes que correspondem à regra. A pesquisa continua com a próxima regra.</p></div><div class=paragraph><p><span class=parameter>deny | drop</span>: qualquer das duas palavras descarta silenciosamente os pacotes que correspondem a essa regra.</p></div><div class=paragraph><p>Ações adicionais estão disponíveis. Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfw&amp;sektion=8&amp;format=html">ipfw(8)</a> para detalhes.</p></div></dd><dt class=hdlist1>LOG_AMOUNT</dt><dd><p>Quando um pacote corresponde a uma regra com a palavra-chave <code>log</code>, uma mensagem será registrada no <a href="https://man.freebsd.org/cgi/man.cgi?query=syslogd&amp;sektion=8&amp;format=html">syslogd(8)</a> com nome <code>SECURITY</code>. O registro somente ocorre se o número de pacotes registrados para essa regra específica não exceder um LOG_AMOUNT especificado. Se nenhum LOG_AMOUNT for especificado, o limite será retirado do valor de <code>net.inet.ip.fw.verbose_limit</code>. Um valor de zero remove o limite de registro. Quando o limite for atingido, o registro em log poderá ser reativado, limpando o contador de registro ou o contador de pacotes para essa regra, usando <code>ipfw resetlog</code>.</p><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>O registro é feito depois que todas as outras condições de correspondência de pacote foram atendidas e antes de executar a ação final no pacote. O administrador decide quais regras habilitar o log.</p></div></td></tr></tbody></table></div></dd><dt class=hdlist1>PROTO</dt><dd><p>Este valor opcional pode ser usado para especificar qualquer nome ou número de protocolo encontrado no arquivo <span class=filename>/etc/protocols</span>.</p></dd><dt class=hdlist1>SRC</dt><dd><p>A palavra-chave <code>from</code> deve ser seguida pelo endereço de origem ou por uma palavra-chave que represente o endereço de origem. Um endereço pode ser representado por <code>any</code>, <code>me</code> (qualquer endereço configurado em uma interface neste sistema), <code>me6</code>, (qualquer endereço IPv6 configurado em uma interface neste sistema), ou <code>table</code> seguido pelo número de uma tabela de consulta que contém uma lista de endereços. Ao especificar um endereço IP, ele pode ser seguido opcionalmente pela máscara ou pela máscara de sub-rede do CIDR. Por exemplo, <code>1.2.3.4/25</code> ou <code>1.2.3.4:255.255.255.128</code>.</p></dd><dt class=hdlist1>SRC_PORT</dt><dd><p>Uma porta de origem opcional pode ser especificada usando o número da porta ou um nome de <span class=filename>/etc/services</span>.</p></dd><dt class=hdlist1>DST</dt><dd><p>A palavra-chave <code>to</code> deve ser seguida pelo endereço de destino ou por uma palavra-chave que represente o endereço de destino. As mesmas palavras-chave e endereços descritos na seção SRC podem ser usados para descrever o destino.</p></dd><dt class=hdlist1>DST_PORT</dt><dd><p>Uma porta de destino opcional pode ser especificada usando o número da porta ou um nome de <span class=filename>/etc/services</span>.</p></dd><dt class=hdlist1>OPTIONS</dt><dd><p>Várias palavras-chave podem seguir a origem e o destino. Como o nome sugere, OPTIONS são opcionais. As opções comumente usadas incluem <code>in</code> ou <code>out</code>, que especificam a direção do fluxo de pacotes, <code>icmptypes</code> seguido pelo tipo de mensagem ICMP e <code>keep-state</code>.</p><div class=paragraph><p>Quando uma regra <span class=parameter>keep-state</span> é correspondida, o firewall criará uma regra dinâmica que corresponda ao tráfego bidirecional entre os endereços e portas de origem e destino usando o mesmo protocolo.</p></div><div class=paragraph><p>O recurso de regras dinâmicas é vulnerável ao esgotamento de recursos de um ataque SYN-flood, o que abriria um grande número de regras dinâmicas. Para combater esse tipo de ataque com IPFW, use <code>limit</code>. Esta opção limita o número de sessões simultâneas verificando as regras dinâmicas abertas, contando o número de vezes que esta regra e a combinação de endereços IP ocorreram. Se essa contagem for maior que o valor especificado por <code>limit</code>, o pacote será descartado.</p></div><div class=paragraph><p>Dezenas de OPTIONS estão disponíveis. Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfw&amp;sektion=8&amp;format=html">ipfw(8)</a> para obter uma descrição de cada opção disponível.</p></div></dd></dl></div></div><div class=sect2><h3 id=_exemplo_de_conjunto_de_regras>30.4.3. Exemplo de Conjunto de Regras<a class=anchor href=#_exemplo_de_conjunto_de_regras></a></h3><div class=paragraph><p>Esta seção demonstra como criar um exemplo de script de conjunto de regras de firewall stateful chamado <span class=filename>/etc/ipfw.rules</span>. Neste exemplo, todas as regras de conexão usam <code>in</code> ou <code>out</code> para esclarecer a direção. Eles também usam <code>via</code> <em>nome-da-interface</em> para especificar a interface que o pacote está percorrendo.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Ao criar ou testar um conjunto de regras de firewall, considere esta configuração temporária:</p></div><div class="literalblock programlisting"><div class=content><pre>net.inet.ip.fw.default_to_accept=&#34;1&#34;</pre></div></div><div class=paragraph><p>Isso define a política padrão do <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfw&amp;sektion=8&amp;format=html">ipfw(8)</a> para ser mais permissiva do que o padrão <code>deny ip from any to any</code>, tornando um pouco mais difícil ficar bloqueado fora do sistema logo após a reinicialização.</p></div></td></tr></tbody></table></div><div class=paragraph><p>O script de firewall começa indicando que é um script Bourne shell e limpa quaisquer regras existentes. Em seguida, ele cria a variável <code>cmd</code> para que <code>ipfw add</code> não precise ser digitado no início de cada regra. Ele também define a variável <code>pif</code> que representa o nome da interface que está conectada à Internet.</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
# Flush out the list before we begin.
ipfw -q -f flush

# Set rules command prefix
cmd=&#34;ipfw -q add&#34;
pif=&#34;dc0&#34;     # interface name of NIC attached to Internet</pre></div></div><div class=paragraph><p>As duas primeiras regras permitem todo o tráfego na interface interna e na interface de loopback:</p></div><div class="literalblock programlisting"><div class=content><pre># Change xl0 to LAN NIC interface name
$cmd 00005 allow all from any to any via xl0

# No restrictions on Loopback Interface
$cmd 00010 allow all from any to any via lo0</pre></div></div><div class=paragraph><p>A próxima regra permite que o pacote passe se corresponder a uma entrada existente na tabela de regras dinâmicas:</p></div><div class="literalblock programlisting"><div class=content><pre>$cmd 00101 check-state</pre></div></div><div class=paragraph><p>O próximo conjunto de regras define quais conexões stateful os sistemas internos podem criar para hosts na Internet:</p></div><div class="literalblock programlisting"><div class=content><pre># Allow access to public DNS
# Replace x.x.x.x with the IP address of a public DNS server
# and repeat for each DNS server in /etc/resolv.conf
$cmd 00110 allow tcp from any to x.x.x.x 53 out via $pif setup keep-state
$cmd 00111 allow udp from any to x.x.x.x 53 out via $pif keep-state

# Allow access to ISP&#39;s DHCP server for cable/DSL configurations.
# Use the first rule and check log for IP address.
# Then, uncomment the second rule, input the IP address, and delete the first rule
$cmd 00120 allow log udp from any to any 67 out via $pif keep-state
#$cmd 00120 allow udp from any to x.x.x.x 67 out via $pif keep-state

# Allow outbound HTTP and HTTPS connections
$cmd 00200 allow tcp from any to any 80 out via $pif setup keep-state
$cmd 00220 allow tcp from any to any 443 out via $pif setup keep-state

# Allow outbound email connections
$cmd 00230 allow tcp from any to any 25 out via $pif setup keep-state
$cmd 00231 allow tcp from any to any 110 out via $pif setup keep-state

# Allow outbound ping
$cmd 00250 allow icmp from any to any out via $pif keep-state

# Allow outbound NTP
$cmd 00260 allow udp from any to any 123 out via $pif keep-state

# Allow outbound SSH
$cmd 00280 allow tcp from any to any 22 out via $pif setup keep-state

# deny and log all other outbound connections
$cmd 00299 deny log all from any to any out via $pif</pre></div></div><div class=paragraph><p>O próximo conjunto de regras controla conexões de hosts da Internet para a rede interna. Ele começa negando pacotes tipicamente associados a ataques e, em seguida, permite explicitamente tipos específicos de conexões. Todos os serviços autorizados originados da Internet usam <code>limit</code> para evitar ataques de flood.</p></div><div class="literalblock programlisting"><div class=content><pre># Deny all inbound traffic from non-routable reserved address spaces
$cmd 00300 deny all from 192.168.0.0/16 to any in via $pif     #RFC 1918 private IP
$cmd 00301 deny all from 172.16.0.0/12 to any in via $pif      #RFC 1918 private IP
$cmd 00302 deny all from 10.0.0.0/8 to any in via $pif         #RFC 1918 private IP
$cmd 00303 deny all from 127.0.0.0/8 to any in via $pif        #loopback
$cmd 00304 deny all from 0.0.0.0/8 to any in via $pif          #loopback
$cmd 00305 deny all from 169.254.0.0/16 to any in via $pif     #DHCP auto-config
$cmd 00306 deny all from 192.0.2.0/24 to any in via $pif       #reserved for docs
$cmd 00307 deny all from 204.152.64.0/23 to any in via $pif    #Sun cluster interconnect
$cmd 00308 deny all from 224.0.0.0/3 to any in via $pif        #Class D &amp; E multicast

# Deny public pings
$cmd 00310 deny icmp from any to any in via $pif

# Deny ident
$cmd 00315 deny tcp from any to any 113 in via $pif

# Deny all Netbios services.
$cmd 00320 deny tcp from any to any 137 in via $pif
$cmd 00321 deny tcp from any to any 138 in via $pif
$cmd 00322 deny tcp from any to any 139 in via $pif
$cmd 00323 deny tcp from any to any 81 in via $pif

# Deny fragments
$cmd 00330 deny all from any to any frag in via $pif

# Deny ACK packets that did not match the dynamic rule table
$cmd 00332 deny tcp from any to any established in via $pif

# Allow traffic from ISP&#39;s DHCP server.
# Replace x.x.x.x with the same IP address used in rule 00120.
#$cmd 00360 allow udp from any to x.x.x.x 67 in via $pif keep-state

# Allow HTTP connections to internal web server
$cmd 00400 allow tcp from any to me 80 in via $pif setup limit src-addr 2

# Allow inbound SSH connections
$cmd 00410 allow tcp from any to me 22 in via $pif setup limit src-addr 2

# Reject and log all other incoming connections
$cmd 00499 deny log all from any to any in via $pif</pre></div></div><div class=paragraph><p>A última regra registra todos os pacotes que não correspondem a nenhuma das regras do conjunto de regras:</p></div><div class="literalblock programlisting"><div class=content><pre># Everything else is denied and logged
$cmd 00999 deny log all from any to any</pre></div></div></div><div class=sect2><h3 id=in-kernel-nat>30.4.4. NAT no Kernel<a class=anchor href=#in-kernel-nat></a></h3><div class=paragraph><p>O firewall IPFW do FreeBSD possui duas implementações de NAT: a implementação do sistema base <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> e a implementação de NAT interno do IPFW. Ambos trabalham em conjunto com o IPFW para fornecer tradução de endereço de rede. Isso pode ser usado para fornecer uma solução de compartilhamento de conexão com a Internet, para que vários computadores internos possam se conectar à Internet usando um único endereço IP público.</p></div><div class=paragraph><p>Para isso, a maquina FreeBSD conectada na internet deve atuar como um gateway. Esse sistema deve ter duas NICs, onde uma é conectada a internet e a outra conectada a LAN interna. Cada maquina conectada com a LAN deve estar associada a um endereço IP no espaço de rede privado, como definido pela <a href=https://www.ietf.org/rfc/rfc1918.txt>RFC 1918</a>.</p></div><div class=paragraph><p>Algumas configuração adicionais são necessárias para ativar a funcionalidade in-kernel NAT do IPFW. Para ativar o suporte ao in-kernel NAT no momento da inicialização do sistema, o seguinte deve ser definido em <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>gateway_enable=&#34;YES&#34;
firewall_enable=&#34;YES&#34;
firewall_nat_enable=&#34;YES&#34;</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Quando <code>firewall_nat_enable</code> estiver definido, mas <code>firewall_enable</code> não estiver, ele não terá efeito e não fará nada. Isso ocorre porque a implementação do in-kernel NAT é compatível apenas com o IPFW.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Quando o conjunto de regras contém regras stateful, o posicionamento da regra NAT é crítico e a ação <code>skipto</code> é usada. A ação <code>skipto</code> requer um número de regra para que ele saiba para qual regra saltar. O exemplo abaixo se baseia no conjunto de regras do firewall mostrado na seção anterior. Ele adiciona algumas entradas adicionais e modifica algumas regras existentes para configurar o firewall com in-kernel NAT. Ele começa adicionando algumas variáveis adicionais que representam o número da regra para pular para, a opção <code>keep-state</code> e uma lista de portas TCP que serão usadas para reduzir o número de regras.</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
ipfw -q -f flush
cmd=&#34;ipfw -q add&#34;
skip=&#34;skipto 1000&#34;
pif=dc0
ks=&#34;keep-state&#34;
good_tcpo=&#34;22,25,37,53,80,443,110&#34;</pre></div></div><div class=paragraph><p>Com o in-kernel NAT é necessário desativar o descarregamento da segmentação TCP (TSO) devido à arquitetura do <a href="https://man.freebsd.org/cgi/man.cgi?query=libalias&amp;sektion=3&amp;format=html">libalias(3)</a>, uma biblioteca implementada como um módulo do kernel para fornecer o in-kernel NAT do IPFW. O TSO pode ser desativado em uma interface de rede usando <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a> ou em todo o sistema usando <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a>. Para desativar o TSO em todo o sistema, deve-se definir o seguinte em <span class=filename>/etc/sysctl.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>net.inet.tcp.tso=&#34;0&#34;</pre></div></div><div class=paragraph><p>Uma instância NAT também será configurada. É possível ter várias instâncias de NAT, cada uma com sua própria configuração. Para este exemplo, apenas uma instância NAT é necessária; Instância NAT número 1. A configuração pode receber algumas opções, como: <code>if</code>, que indica a interface pública, <code>same_ports</code>, que cuida para que as portas mapeadas e o números das portas locais sejam mapeados da mesma maneira, <code>unreg_only</code> resultará em apenas espaços de endereço não registrados (privados) a serem processados pela instância NAT e <code>reset</code>, que ajudará a manter uma instância NAT em funcionamento, mesmo quando o endereço de IP público da máquina IPFW for alterado. Para todas as opções possíveis que podem ser passadas para uma única configuração de instância NAT, consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfw&amp;sektion=8&amp;format=html">ipfw(8)</a>. Ao configurar um firewall NAT stateful, é necessário permitir que pacotes traduzidos sejam reinjetados no firewall para processamento subsequente. Isso pode ser obtido desativando o comportamento <code>one_pass</code> no início do script do firewall.</p></div><div class="literalblock programlisting"><div class=content><pre>ipfw disable one_pass
ipfw -q nat 1 config if $pif same_ports unreg_only reset</pre></div></div><div class=paragraph><p>A regra NAT de entrada é inserida <em>após</em> as duas regras que permitem todo o tráfego nas interfaces interna e de loopback e após a regra de remontagem, mas <em>antes</em> da regra <code>check-state</code> . É importante que o número da regra selecionada para esta regra NAT, neste exemplo <code>100</code>, seja maior que as três primeiras regras e menor que a regra <code>check-state</code>. Além disso, devido ao comportamento do in-kernel NAT, é recomendável colocar uma regra de remontagem pouco antes da primeira regra NAT e depois das regras que permitem tráfego nas interfaces. Normalmente, a fragmentação IP não deve ocorrer, mas ao lidar com o tráfego de tunelamento com IPSEC/ESP/GRE, isso pode ocorrer e a recomposição de fragmentos é necessária antes de entregar o pacote completo para o mecanismo de in-kernel NAT.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>A regra de remontagem não era necessária com o <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> do sistema base porque o recurso interno de <code>divert</code> no IPFW já cuida disso, remontando os pacotes antes da entrega no socket, também informado em <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfw&amp;sektion=8&amp;format=html">ipfw(8)</a>.</p></div><div class=paragraph><p>A instância NAT e o número da regra usados neste exemplo não coincidem com a instância NAT e o número da regra padrão criados por <span class=filename>rc.firewall</span>. <span class=filename>rc.firewall</span> é um script que configura as regras de firewall padrão presentes no FreeBSD.</p></div></td></tr></tbody></table></div><div class="literalblock programlisting"><div class=content><pre>$cmd 005 allow all from any to any via xl0  # exclude LAN traffic
$cmd 010 allow all from any to any via lo0  # exclude loopback traffic
$cmd 099 reass all from any to any in       # reassemble inbound packets
$cmd 100 nat 1 ip from any to any in via $pif # NAT any inbound packets
# Allow the packet through if it has an existing entry in the dynamic rules table
$cmd 101 check-state</pre></div></div><div class=paragraph><p>As regras de saída são modificadas para substituir a ação <code>allow</code> com a variável <code>$skip</code>, indicando que o processamento da regra continuará na regra <code>1000</code>. As sete regras <code>tcp</code> foram substituídas pela regra <code>125</code> porque a variável <code>$good_tcpo</code> contém as sete portas de saída permitidas.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Lembre-se de que o desempenho do IPFW é amplamente determinado pelo número de regras presentes no conjunto de regras.</p></div></td></tr></tbody></table></div><div class="literalblock programlisting"><div class=content><pre># Authorized outbound packets
$cmd 120 $skip udp from any to x.x.x.x 53 out via $pif $ks
$cmd 121 $skip udp from any to x.x.x.x 67 out via $pif $ks
$cmd 125 $skip tcp from any to any $good_tcpo out via $pif setup $ks
$cmd 130 $skip icmp from any to any out via $pif $ks</pre></div></div><div class=paragraph><p>As regras de entrada permanecem as mesmas, exceto a ultima regra que remove <code>via $pif</code> com intenção de casar com ambas regras de entrada e saida. A regra de NAT deve seguir essa ultima regra de saida, deve ter um numero maior que a ultima regra, e o numero da regra deve referenciar a ação <code>skipto</code>. Nesse conjunto de regras, o numero de regra <code>1000</code> lida com a passagem de todos os pacotes para nossa instância configurada para processamento NAT. A próxima regra permite que qualquer pacote submetido ao processamento NAT seja liberado.</p></div><div class="literalblock programlisting"><div class=content><pre>$cmd 999 deny log all from any to any
$cmd 1000 nat 1 ip from any to any out via $pif # skipto location for outbound stateful rules
$cmd 1001 allow ip from any to any</pre></div></div><div class=paragraph><p>Neste exemplo, as regras <code>100</code>, <code>101</code>, <code>125</code>, <code>1000</code> e <code>1001</code> controlam a tradução de endereços dos pacotes de saída e de entrada para que as entradas na tabela de estado dinâmico sempre registrem o endereço de IP privado da LAN .</p></div><div class=paragraph><p>Considere um navegador Web interno que inicialize uma nova sessão HTTP pela porta 80. Quando o primeiro pacote de saída entra no firewall, ele não corresponde à regra <code>100</code> porque ele está saindo e não entrando. Ele pula a regra <code>101</code> porque este é o primeiro pacote e ainda não foi inserido na tabela de estados dinâmicos. O pacote finalmente corresponde à regra <code>125</code> pois é uma conexão de saída em uma porta permitida e tem um endereço IP de origem da LAN interna. Ao combinar essa regra, duas ações ocorrem. Primeiro, a ação <code>keep-state</code> adiciona uma entrada à tabela de estados dinâmicos e a ação especificada, <code>skipto rule 1000</code>, é executada. Em seguida, o pacote passa pelo NAT e é enviado para a Internet. Este pacote faz o seu caminho para o servidor web de destino, onde um pacote de resposta é gerado e enviado de volta. Este novo pacote entra no topo do conjunto de regras. Ele corresponde à regra <code>100</code> e tem seu endereço de destino IP mapeado de volta para o endereço interno original. Em seguida, ele é processado pela regra <code>check-state</code>, é encontrado na tabela como uma sessão existente e é liberado para a LAN.</p></div><div class=paragraph><p>No lado da entrada, o conjunto de regras deve negar pacotes inválidos e permitir apenas serviços autorizados. Um pacote que corresponde a uma regra de entrada é postado na tabela de estados dinâmicos e o pacote é liberado para a LAN. O pacote gerado como resposta é reconhecido pela regra <code>check-state</code> como pertencente a uma sessão existente. Em seguida, ele é enviado para a regra <code>1000</code> para passar pelo NAT antes de ser liberado para a interface de saída.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>A transição do <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> do sistema base para o in-kernel NAT pode parecer fácil no início, mas há algumas particularidades. Ao usar o kernel GENERIC, o IPFW carregará o módulo <span class=filename>libalias.ko</span> do kernel, quando o <code>firewall_nat_enable</code> estiver ativado no <span class=filename>rc.conf</span>. O módulo do kernel <span class=filename>libalias.ko</span> fornece apenas a funcionalidade básica de NAT, enquanto a implementação do <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> do sistema base possui todas as funcionalidades de NAT disponível na userland sem nenhuma configuração extra. Toda funcionalidade refere-se aos seguintes módulos do kernel que podem ser carregados adicionalmente quando necessário, além do módulo do kernel padrão <span class=filename>libalias.ko</span>: <span class=filename>alias_cuseeme.ko</span>, <span class=filename>alias_ftp.ko</span>, <span class=filename>alias_bbt.ko</span>, <span class=filename>skinny.ko</span>, <span class=filename>irc.ko</span>, <span class=filename>alias_pptp.ko</span> and <span class=filename>alias_smedia.ko</span> usando a diretiva <code>kld_list</code> em <span class=filename>rc.conf</span>. Se um kernel personalizado for usado, a funcionalidade completa do sistema base poderá ser compilada no kernel, usando a opção <code>options LIBALIAS</code>.</p></div></td></tr></tbody></table></div><div class=sect3><h4 id=_redirecionamento_de_portas>30.4.4.1. Redirecionamento de Portas<a class=anchor href=#_redirecionamento_de_portas></a></h4><div class=paragraph><p>A desvantagem com NAT em geral é que os clientes da LAN não estão acessíveis na Internet. Os clientes na LAN podem fazer conexões de saída para o mundo, mas não podem receber conexões diretas. Isso é um problema ao tentar executar serviços de Internet em uma das máquinas clientes da LAN. Uma forma simples de contornar isso é redirecionar as portas selecionadas da Internet na máquina NAT para um cliente da LAN.</p></div><div class=paragraph><p>Por exemplo, um servidor IRC é executado no cliente <code>A</code> e um servidor Web é executado no cliente <code>B</code>. Para que isso funcione corretamente, as conexões recebidas nas portas 6667 (IRC) e 80 (HTTP) devem ser redirecionadas para as respectivas máquinas.</p></div><div class=paragraph><p>Com o in-kernel NAT, toda a configuração é feita na configuração da instância NAT. Para obter uma lista completa de opções que uma instância in-kernel NAT pode usar, consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfw&amp;sektion=8&amp;format=html">ipfw(8)</a>. A sintaxe IPFW segue a sintaxe do natd. A sintaxe para <code>redirect_port</code> é a seguinte:</p></div><div class="literalblock programlisting"><div class=content><pre>redirect_port proto targetIP:targetPORT[-targetPORT]
  [aliasIP:]aliasPORT[-aliasPORT]
  [remoteIP[:remotePORT[-remotePORT]]]</pre></div></div><div class=paragraph><p>Para configurar o exemplo de instalação acima, os argumentos devem ser:</p></div><div class="literalblock programlisting"><div class=content><pre>redirect_port tcp 192.168.0.2:6667 6667
redirect_port tcp 192.168.0.3:80 80</pre></div></div><div class=paragraph><p>Depois de adicionar esses argumentos à configuração da instância 1 de NAT no conjunto de regras acima, as portas TCP serão encaminhadas para as máquinas clientes da LAN que rodam os serviços IRC e HTTP.</p></div><div class="literalblock programlisting"><div class=content><pre>ipfw -q nat 1 config if $pif same_ports unreg_only reset \
  redirect_port tcp 192.168.0.2:6667 6667 \
  redirect_port tcp 192.168.0.3:80 80</pre></div></div><div class=paragraph><p>Intervalos de portas podem ser indicados com <code>redirect_port</code>. Por exemplo, <em>tcp 192.168.0.2:2000-3000 2000-3000</em> redirecionaria todas as conexões recebidas entre as portas 2000 e 3000 para as portas 2000 a 3000 no cliente <code>A</code>.</p></div></div><div class=sect3><h4 id=_redirecionamento_de_endereços>30.4.4.2. Redirecionamento de Endereços<a class=anchor href=#_redirecionamento_de_endereços></a></h4><div class=paragraph><p>Redirecionamento de endereços é útil se mais de um endereço IP estiver disponível. Cada cliente da LAN pode receber seu próprio endereço IP externo pelo <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfw&amp;sektion=8&amp;format=html">ipfw(8)</a>, que reescreverá os pacotes de saída dos clientes da LAN com o endereço IP externo apropriado e redirecionará todo o tráfego recebido naquele endereço IP específico de volta para o cliente da LAN específico. Isso também é conhecido como NAT estático. Por exemplo, se o endereço IP <code>128.1.1.1</code>, <code>128.1.1.2</code>, e <code>128.1.1.3</code> estiverem disponíveis, <code>128.1.1.1</code> pode ser usado pelo <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfw&amp;sektion=8&amp;format=html">ipfw(8)</a> como o endereço IP de saída externa, enquanto <code>128.1.1.2</code> e <code>128.1.1.3</code> são encaminhados de volta para os clientes da LAN <code>A</code> e <code>B</code>.</p></div><div class=paragraph><p>A sintaxe <code>redirect_address</code> é a seguinte, onde <code>localIP</code> é o endereço IP interno do cliente da LAN e <code>publicIP</code> é o endereço IP externo que corresponde ao cliente da LAN .</p></div><div class="literalblock programlisting"><div class=content><pre>redirect_address localIP publicIP</pre></div></div><div class=paragraph><p>No exemplo, os argumentos seriam:</p></div><div class="literalblock programlisting"><div class=content><pre>redirect_address 192.168.0.2 128.1.1.2
redirect_address 192.168.0.3 128.1.1.3</pre></div></div><div class=paragraph><p>Como o <code>redirect_port</code>, esses argumentos são inseridos na configuração da instância NAT. Com o redirecionamento de endereço, não há necessidade de redirecionamento de porta, pois todos os dados recebidos em um determinado endereço IP são redirecionados.</p></div><div class=paragraph><p>Os endereços IP externos na máquina <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfw&amp;sektion=8&amp;format=html">ipfw(8)</a> devem estar ativos e com alias na interface externa. Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a> para mais informações.</p></div></div><div class=sect3><h4 id=_nat_do_espaço_do_usuário>30.4.4.3. NAT do espaço do usuário<a class=anchor href=#_nat_do_espaço_do_usuário></a></h4><div class=paragraph><p>Vamos começar com uma declaração: a implementação de NAT do sistema base: <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a>, tem mais sobrecarga do que no in-kernel NAT. Para que o <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> traduza pacotes, os pacotes precisam ser copiados do kernel para o espaço do usuário e vice-versa, o que gera uma sobrecarga extra que não está presente com o in-kernel NAT.</p></div><div class=paragraph><p>Para ativar o daemon de NAT do sistema base , <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a>, no momento da inicialização do sistema, é necessário a seguinte configuração mínima em <span class=filename>/etc/rc.conf</span>. Onde <code>natd_interface</code> é definido com o nome da interface NIC conectada à Internet. O script <a href="https://man.freebsd.org/cgi/man.cgi?query=rc&amp;sektion=8&amp;format=html">rc(8)</a> do <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> verifica automaticamente se um endereço IP dinâmico é usado e configura-se para lidar com isso.</p></div><div class="literalblock programlisting"><div class=content><pre>gateway_enable=&#34;YES&#34;
natd_enable=&#34;YES&#34;
natd_interface=&#34;rl0&#34;</pre></div></div><div class=paragraph><p>Em geral, o conjunto de regras acima, conforme explicado para o in-kernel NAT, também pode ser usado junto com <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a>. As exceções são a configuração da instância in-kernel NAT <code>(ipfw -q nat 1 config …​)</code> que não é necessária junto com a regra de remontagem 99 porque sua funcionalidade é incluída na ação <code>divert</code>. As regras número 100 e 1000 terão que mudar ligeiramente, como mostrado abaixo.</p></div><div class="literalblock programlisting"><div class=content><pre>$cmd 100 divert natd ip from any to any in via $pif
$cmd 1000 divert natd ip from any to any out via $pif</pre></div></div><div class=paragraph><p>Para configurar o redirecionamento de porta ou endereço, é usada uma sintaxe semelhante à do in-kernel NAT. Embora agora, em vez de especificar a configuração em nosso script de conjunto de regras, como no in-kernel NAT, a configuração do <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> é melhor realizada em um arquivo de configuração. Para fazer isso, uma flag extra deve ser passado através do <span class=filename>/etc/rc.conf</span>, que especifica o caminho do arquivo de configuração.</p></div><div class="literalblock programlisting"><div class=content><pre>natd_flags=&#34;-f /etc/natd.conf&#34;</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>O arquivo especificado deve conter uma lista de opções de configuração, uma por linha. Para obter mais informações sobre esse arquivo de configuração e possíveis variáveis, consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a>. Abaixo estão dois exemplos de valores, um por linha:</p></div><div class="literalblock programlisting"><div class=content><pre>redirect_port tcp 192.168.0.2:6667 6667
redirect_address 192.168.0.3 128.1.1.3</pre></div></div></td></tr></tbody></table></div></div></div><div class=sect2><h3 id=firewalls-ipfw-cmd>30.4.5. O Comando IPFW<a class=anchor href=#firewalls-ipfw-cmd></a></h3><div class=paragraph><p>O <code>ipfw</code> pode ser usado para adicionar ou excluir regras únicas e manuais ao firewall ativo enquanto ele estiver em execução. O problema com o uso desse método é que todas as alterações são perdidas quando o sistema é reinicializado. Recomenda-se, em vez disso, gravar todas as regras em um arquivo e usar esse arquivo para carregar as regras no momento da inicialização e substituir as regras de firewall em execução no momento em que o arquivo for alterado.</p></div><div class=paragraph><p>O <code>ipfw</code> é uma maneira útil para se exibir as regras de firewall em execução na tela do console. O recurso de contabilidade IPFW cria dinamicamente um contador para cada regra que case com cada pacote que corresponde à regra. Durante o processo de teste de uma regra, listar a regra com seu contador é uma maneira de determinar se a regra está funcionando conforme o esperado.</p></div><div class=paragraph><p>Para listar todas as regras em execução em sequência:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ipfw list</span></code></pre></div></div><div class=paragraph><p>Para listar todas as regras em execução com um registro de data e hora de quando a última vez em que a regra foi utilizada:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ipfw -t list</span></code></pre></div></div><div class=paragraph><p>O próximo exemplo lista as informações contábeis e a contagem de pacotes das regras correspondentes, junto com as próprias regras. A primeira coluna é o número da regra, seguido pelo número de pacotes e bytes correspondidos, seguidos pela própria regra.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ipfw -a list</span></code></pre></div></div><div class=paragraph><p>Para listar regras dinâmicas além das regras estáticas:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ipfw -d list</span></code></pre></div></div><div class=paragraph><p>Para mostrar também as regras dinâmicas expiradas:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ipfw -d -e list</span></code></pre></div></div><div class=paragraph><p>Para zerar os contadores:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ipfw zero</span></code></pre></div></div><div class=paragraph><p>Para zerar os contadores apenas para a regra com o número <em>NUM</em>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ipfw zero NUM</span></code></pre></div></div><div class=sect3><h4 id=_mensagens_de_log_do_firewall>30.4.5.1. Mensagens de Log do Firewall<a class=anchor href=#_mensagens_de_log_do_firewall></a></h4><div class=paragraph><p>Mesmo com o recurso de geração de log ativado, o IPFW não irá gerar nenhum log de regras por conta própria. O administrador do firewall decide quais regras no conjunto de regras serão logadas e adiciona a palavra-chave <code>log</code> a essas regras. Normalmente, apenas as regras de bloqueio são logadas. É costume duplicar a regra "ipfw default deny everything" com a palavra-chave <code>log</code> incluída como a última regra no conjunto de regras. Dessa forma, é possível ver todos os pacotes que não correspondem a nenhuma das regras do conjunto de regras.</p></div><div class=paragraph><p>O log é uma espada de dois gumes. Se não houver cuidado, uma abundância de dados de log ou um ataque DoS pode encher o disco com arquivos de log. As mensagens de log não são gravadas apenas no syslogd, mas também são exibidas na tela do console do root e logo se tornam irritantes.</p></div><div class=paragraph><p>A opção do kernel <code>IPFIREWALL_VERBOSE_LIMIT=5</code> limita o número de mensagens consecutivas enviadas para o <a href="https://man.freebsd.org/cgi/man.cgi?query=syslogd&amp;sektion=8&amp;format=html">syslogd(8)</a>, referente à correspondência de pacotes de uma regra dada. Quando esta opção está ativada no kernel, o número de mensagens consecutivas relativas a uma regra específica é limitado ao número especificado. Não há nada a ganhar com 200 mensagens de log idênticas. Com essa opção definida como cinco, cinco mensagens consecutivas referentes a uma regra específica seriam registradas no syslogd e as mensagens consecutivas idênticas restantes seriam contadas e postadas no syslogd com uma frase assim:</p></div><div class="literalblock programlisting"><div class=content><pre>last message repeated 45 times</pre></div></div><div class=paragraph><p>Todas os pacotes logados são escritos por padrão no arquivo <span class=filename>/var/log/security</span>, que é definido no <span class=filename>/etc/syslog.conf</span>.</p></div></div><div class=sect3><h4 id=firewalls-ipfw-rules-script>30.4.5.2. Criando um Script de Regras<a class=anchor href=#firewalls-ipfw-rules-script></a></h4><div class=paragraph><p>Os usuários mais experientes do IPFW criam um arquivo contendo as regras e as codificam de maneira compatível com sua execução como um script. A principal vantagem de fazer isso é que as regras de firewall podem ser atualizadas em massa sem a necessidade de reinicializar o sistema para ativá-las. Este método é conveniente para testar novas regras, pois o procedimento pode ser executado quantas vezes forem necessárias. Sendo um script, a substituição simbólica pode ser usada para valores usados frequentemente para serem substituídos em várias regras.</p></div><div class=paragraph><p>Este script de exemplo tem a sintaxe compatível com shells <a href="https://man.freebsd.org/cgi/man.cgi?query=sh&amp;sektion=1&amp;format=html">sh(1)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=csh&amp;sektion=1&amp;format=html">csh(1)</a>, e <a href="https://man.freebsd.org/cgi/man.cgi?query=tcsh&amp;sektion=1&amp;format=html">tcsh(1)</a>. Campos de substituição simbólicos são prefixados com um sinal de dólar ($). Campos simbólicos não possuem o prefixo $. O valor para preencher o campo simbólico deve ser colocado entre aspas duplas ("").</p></div><div class=paragraph><p>Inicie o arquivo de regras assim:</p></div><div class="literalblock programlisting"><div class=content><pre>############### start of example ipfw rules script #############
#
ipfw -q -f flush       # Delete all rules
# Set defaults
oif=&#34;tun0&#34;             # out interface
odns=&#34;192.0.2.11&#34;      # ISP&#39;s DNS server IP address
cmd=&#34;ipfw -q add &#34;     # build rule prefix
ks=&#34;keep-state&#34;        # just too lazy to key this each time
$cmd 00500 check-state
$cmd 00502 deny all from any to any frag
$cmd 00501 deny tcp from any to any established
$cmd 00600 allow tcp from any to any 80 out via $oif setup $ks
$cmd 00610 allow tcp from any to $odns 53 out via $oif setup $ks
$cmd 00611 allow udp from any to $odns 53 out via $oif $ks
################### End of example ipfw rules script ############</pre></div></div><div class=paragraph><p>As regras não são importantes, pois o foco deste exemplo é como os campos de substituição simbólica são preenchidos.</p></div><div class=paragraph><p>Se o exemplo acima estiver no arquivo <span class=filename>/etc/ipfw.rules</span>, as regras podem ser recarregadas pelo seguinte comando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sh /etc/ipfw.rules</span></code></pre></div></div><div class=paragraph><p><span class=filename>/etc/ipfw.rules</span> pode estar localizado em qualquer lugar e o arquivo pode ter qualquer nome.</p></div><div class=paragraph><p>A mesma coisa pode ser realizada executando esses comandos manualmente:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ipfw -q -f flush</span>
<span class=c># ipfw -q add check-state</span>
<span class=c># ipfw -q add deny all from any to any frag</span>
<span class=c># ipfw -q add deny tcp from any to any established</span>
<span class=c># ipfw -q add allow tcp from any to any 80 out via tun0 setup keep-state</span>
<span class=c># ipfw -q add allow tcp from any to 192.0.2.11 53 out via tun0 setup keep-state</span>
<span class=c># ipfw -q add 00611 allow udp from any to 192.0.2.11 53 out via tun0 keep-state</span></code></pre></div></div></div></div><div class=sect2><h3 id=firewalls-ipfw-kernelconfig>30.4.6. Opções do Kerne para o IPFW<a class=anchor href=#firewalls-ipfw-kernelconfig></a></h3><div class=paragraph><p>Para compilar estaticamente o suporte ao IPFW em um kernel personalizado, consulte as instruções em <a href=../kernelconfig/#kernelconfig>Configurando o kernel do FreeBSD</a>. As seguintes opções estão disponíveis para o arquivo de configuração do kernel personalizado:</p></div><div class="literalblock programlisting"><div class=content><pre>options    IPFIREWALL			# enables IPFW
options    IPFIREWALL_VERBOSE		# enables logging for rules with log keyword to syslogd(8)
options    IPFIREWALL_VERBOSE_LIMIT=5	# limits number of logged packets per-entry
options    IPFIREWALL_DEFAULT_TO_ACCEPT # sets default policy to pass what is not explicitly denied
options    IPFIREWALL_NAT		# enables basic in-kernel NAT support
options    LIBALIAS			# enables full in-kernel NAT support
options    IPFIREWALL_NAT64		# enables in-kernel NAT64 support
options    IPFIREWALL_NPTV6		# enables in-kernel IPv6 NPT support
options    IPFIREWALL_PMOD		# enables protocols modification module support
options    IPDIVERT			# enables NAT through natd(8)</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>O IPFW pode ser carregado como um módulo do kernel: as opções acima são compiladas por padrão como módulos ou podem ser configuradas em tempo de execução usando parâmetros configuráveis.</p></div></td></tr></tbody></table></div></div></div></div><div class=sect1><h2 id=firewalls-ipf>30.5. IPFILTER (IPF)<a class=anchor href=#firewalls-ipf></a></h2><div class=sectionbody><div class=paragraph><p>O IPFILTER, também conhecido como IPF, é um firewall cross-platform de código aberto que foi portado para vários sistemas operacionais, incluindo FreeBSD, NetBSD, OpenBSD e Solaris™.</p></div><div class=paragraph><p>O IPFILTER é um firewall kernel-side e um mecanismo NAT que pode ser controlado e monitorado por programas da área de usuário. As regras de firewall podem ser definidas ou excluídas usando ipf, as regras NAT podem ser definidas ou excluídas usando ipnat, estatísticas em tempo de execução para as partes do kernel IPFILTER podem ser informadas usando ipfstat, e ipmon pode ser usado para logar ações do IPFILTER nos arquivos de log do sistema.</p></div><div class=paragraph><p>O IPF foi originalmente escrito usando uma lógica de processamento de regra de que "a última regra que corresponder, ganha" e era utilizado apenas regras stateless. Desde então, IPF foi aprimorado para incluir as opções <code>quick</code> e <code>keep state</code>.</p></div><div class=paragraph><p>O FAQ IPF está em <a href=http://www.phildev.net/ipf/index.html>http://www.phildev.net/ipf/index.html</a>. Um arquivo liberado para buscas da lista de discussão IPFilter está disponível em <a href="http://marc.info/?l=ipfilter">http://marc.info/?l=ipfilter</a>.</p></div><div class=paragraph><p>Esta seção do Handbook foca no IPF no que se refere ao FreeBSD. Ele fornece exemplos de regras que contêm as opções <code>quick</code> e <code>keep state</code>.</p></div><div class=sect2><h3 id=_ativando_o_ipf>30.5.1. Ativando o IPF<a class=anchor href=#_ativando_o_ipf></a></h3><div class=paragraph><p>O IPF está incluído na instalação base do FreeBSD como um módulo carregável do kernel, o que significa que um kernel personalizado não é necessário para habilitar o IPF.</p></div><div class=paragraph><p>Para usuários que preferem compilar estaticamente o suporte ao IPF em um kernel personalizado, consulte as instruções em <a href=../kernelconfig/#kernelconfig>Configurando o kernel do FreeBSD</a>. As seguintes opções do kernel estão disponíveis:</p></div><div class="literalblock programlisting"><div class=content><pre>options IPFILTER
options IPFILTER_LOG
options IPFILTER_LOOKUP
options IPFILTER_DEFAULT_BLOCK</pre></div></div><div class=paragraph><p>onde <code>options IPFILTER</code> ativa o suporte para o IPFILTER, <code>options IPFILTER_LOG</code> ativa o log do IPF usando o pseudo-dispositivo de log <span class=filename>ipl</span> para cada regra que tenha a palavra-chave <code>log</code>, <code>IPFILTER_LOOKUP</code> ativa as pools IP para acelerar IP lookups, e <code>options IPFILTER_DEFAULT_BLOCK</code> altera o comportamento padrão para que qualquer pacote que não corresponda a uma regra <code>pass</code> do firewall seja bloqueado.</p></div><div class=paragraph><p>Para configurar o sistema para ativar o IPF no momento da inicialização, adicione as seguintes entradas ao <span class=filename>/etc/rc.conf</span>. Essas entradas também ativarão o log e o <code>default pass all</code>. Para alterar a política padrão para <code>block all</code> sem compilar um kernel personalizado, lembre-se de adicionar uma regra <code>block all</code> no final do conjunto de regras.</p></div><div class="literalblock programlisting"><div class=content><pre>ipfilter_enable=&#34;YES&#34;             # Start ipf firewall
ipfilter_rules=&#34;/etc/ipf.rules&#34;   # loads rules definition text file
ipv6_ipfilter_rules=&#34;/etc/ipf6.rules&#34; # loads rules definition text file for IPv6
ipmon_enable=&#34;YES&#34;                # Start IP monitor log
ipmon_flags=&#34;-Ds&#34;                 # D = start as daemon
                                  # s = log to syslog
                                  # v = log tcp window, ack, seq
                                  # n = map IP &amp; port to names</pre></div></div><div class=paragraph><p>Se a funcionalidade NAT for necessária, adicione também estas linhas:</p></div><div class="literalblock programlisting"><div class=content><pre>gateway_enable=&#34;YES&#34;              # Enable as LAN gateway
ipnat_enable=&#34;YES&#34;                # Start ipnat function
ipnat_rules=&#34;/etc/ipnat.rules&#34;    # rules definition file for ipnat</pre></div></div><div class=paragraph><p>Então, inicie o IPF:</p></div><div class="literalblock programlisting"><div class=content><pre># service ipfilter start</pre></div></div><div class=paragraph><p>Para carregar as regras de firewall, especifique o nome do arquivo do conjunto de regras usando <code>ipf</code>. O comando a seguir pode ser usado para substituir as regras de firewall que está em execução:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ipf -Fa -f /etc/ipf.rules</span></code></pre></div></div><div class=paragraph><p>onde <code>-Fa</code> limpa todas as tabelas de regras internas e <code>-f</code> especifica o arquivo que contém as regras a serem carregadas.</p></div><div class=paragraph><p>Isso fornece a capacidade de fazer alterações em um conjunto de regras personalizado e atualizar o firewall em execução com uma nova cópia das regras sem precisar reinicializar o sistema. Esse método é conveniente para testar novas regras, pois o procedimento pode ser executado quantas vezes forem necessárias.</p></div><div class=paragraph><p>Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=ipf&amp;sektion=8&amp;format=html">ipf(8)</a> para detalhes sobre as outras flags disponíveis com este comando.</p></div></div><div class=sect2><h3 id=_sintaxe_de_regras_ipf>30.5.2. Sintaxe de Regras IPF<a class=anchor href=#_sintaxe_de_regras_ipf></a></h3><div class=paragraph><p>Esta seção descreve a sintaxe de regras IPF usada para criar regras stateful. Ao criar regras, lembre-se de que, a menos que a palavra-chave <code>quick</code> apareça em uma regra, todas as regras são lidas em ordem, com a <em>última regra correspondente</em> sendo a aplicada. Isso significa que, mesmo que a primeira regra que corresponder a um pacote seja <code>pass</code>, se houver uma regra de correspondência posterior que seja <code>block</code>, o pacote será descartado. Os conjuntos de regras de exemplo podem ser encontrados em <span class=filename>/usr/shared/examples/ipfilter</span>.</p></div><div class=paragraph><p>Ao criar regras, um caractere <code>#</code> é usado para marcar o início de um comentário e pode aparecer no final de uma regra, para explicar a função dessa regra ou em sua própria linha. Todas as linhas em branco são ignoradas.</p></div><div class=paragraph><p>As palavras-chave usadas nas regras devem ser escritas em uma ordem específica, da esquerda para a direita. Algumas palavras-chave são obrigatórias, enquanto outras são opcionais. Algumas palavras-chave têm sub-opções que podem ser palavras-chave e também incluem mais sub-opções. A ordem das palavras-chave é a seguinte, em que as palavras mostradas em maiúsculas representam uma variável e as palavras mostradas em minúsculas devem preceder a variável que a segue:</p></div><div class=paragraph><p><em>ACTION DIRECTION OPTIONS proto PROTO_TYPE from SRC_ADDR SRC_PORT to DST_ADDR DST_PORT TCP_FLAG|ICMP_TYPE keep state STATE</em></p></div><div class=paragraph><p>Esta seção descreve cada uma dessas palavras-chave e suas opções. Não é uma lista exaustiva de todas as opções possíveis. Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=ipf&amp;sektion=5&amp;format=html">ipf(5)</a> para obter uma descrição completa da sintaxe de regra que pode ser usada ao criar regras IPF e exemplos para usar de cada palavra-chave.</p></div><div class=dlist><dl><dt class=hdlist1>ACTION</dt><dd><p>A palavra-chave action indica o que fazer com o pacote se corresponder a essa regra. Toda regra <em>deve</em> ter uma ação. As seguintes ações são reconhecidas:</p><div class=paragraph><p><code>block</code>: descarta o pacote.</p></div><div class=paragraph><p><code>pass</code>: permite o pacote.</p></div><div class=paragraph><p><code>log</code>: gera um registro de log.</p></div><div class=paragraph><p><code>count</code>: conta o número de pacotes e bytes que podem fornecer uma indicação da frequência com que uma regra é usada.</p></div><div class=paragraph><p><code>auth</code>: enfileira o pacote para processamento adicional por outro programa.</p></div><div class=paragraph><p><code>call</code>: fornece acesso a funções embutidas no IPF que permitem ações mais complexas.</p></div><div class=paragraph><p><code>decapsulate</code>: remove quaisquer cabeçalhos para processar o conteúdo do pacote.</p></div></dd><dt class=hdlist1>DIRECTION</dt><dd><p>Em seguida, cada regra deve indicar explicitamente a direção do tráfego usando uma dessas palavras-chave:</p><div class=paragraph><p><code>in</code>: a regra é aplicada em um pacote de entrada.</p></div><div class=paragraph><p><code>out</code>: a regra é aplicada em um pacote de saída.</p></div><div class=paragraph><p><code>all</code>: a regra se aplica em qualquer direção.</p></div><div class=paragraph><p>Se o sistema tiver várias interfaces, a interface pode ser especificada junto com a direção. Um exemplo seria <code>in on fxp0</code>.</p></div></dd><dt class=hdlist1>OPTIONS</dt><dd><p>Opções são opcionais. No entanto, se várias opções forem especificadas, elas deverão ser usadas na ordem apresentada aqui.</p><div class=paragraph><p><code>log</code>: ao executar a ACTION especificada, o conteúdo dos cabeçalhos do pacote será gravado no pseudo-dispositivo de log <a href="https://man.freebsd.org/cgi/man.cgi?query=ipl&amp;sektion=4&amp;format=html">ipl(4)</a>.</p></div><div class=paragraph><p><code>quick</code>: se um pacote corresponder a essa regra, a ACTION especificada pela regra ocorrerá e nenhum processamento adicional das regras a seguir ocorrerá para este pacote.</p></div><div class=paragraph><p><code>on</code>: deve ser seguido pelo nome da interface conforme exibido pelo <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a>. A regra corresponderá somente se o pacote estiver passando pela interface especificada na direção especificada.</p></div><div class=paragraph><p>Ao usar a palavra-chave <code>log</code>, os seguintes qualificadores podem ser usados nesta ordem:</p></div><div class=paragraph><p><code>body</code>: indica que os primeiros 128 bytes do conteúdo do pacote serão registrados após os cabeçalhos.</p></div><div class=paragraph><p><code>first</code>: se a palavra-chave <code>log</code> estiver sendo usada em conjunto com uma opção <code>keep state</code>, esta opção é recomendada para que somente o pacote acionador seja logado e não todos os pacotes que corresponde à conexão stateful.</p></div><div class=paragraph><p>Opções adicionais estão disponíveis para especificar mensagens de retorno de erro. Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=ipf&amp;sektion=5&amp;format=html">ipf(5)</a> para mais detalhes.</p></div></dd><dt class=hdlist1>PROTO_TYPE</dt><dd><p>O tipo de protocolo é opcional. No entanto, é obrigatório se a regra precisar especificar um SRC_PORT ou um DST_PORT, uma vez que isso requer o tipo de protocolo. Ao especificar o tipo de protocolo, use a palavra-chave <code>proto</code> seguida de um número de protocolo ou nome de <span class=filename>/etc/protocols</span>. Exemplos de nomes de protocolos incluem <code>tcp</code>, <code>udp</code> ou <code>icmp</code>. Se PROTO_TYPE for especificado, mas nenhum SRC_PORT ou DST_PORT for especificado, todos os números de porta desse protocolo corresponderão a essa regra.</p></dd><dt class=hdlist1>SRC_ADDR</dt><dd><p>A palavra-chave <code>from</code> é obrigatória e é seguida por uma palavra-chave que representa a origem do pacote. A origem pode ser um nome de host, um endereço IP seguido pela máscara CIDR, um pool de endereços ou a palavra-chave <code>all</code>. Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=ipf&amp;sektion=5&amp;format=html">ipf(5)</a> para exemplos.</p><div class=paragraph><p>Não há como definir intervalos de endereços de IP que não se expressam facilmente usando a notação de formato numérico com ponto / máscara. O pacote ou port <a class=package href=https://cgit.freebsd.org/ports/tree/net-mgmt/ipcalc/>net-mgmt/ipcalc</a> pode ser usado para facilitar o cálculo da máscara CIDR. Informações adicionais estão disponíveis na página web da ferramenta: <a href=http://jodies.de/ipcalc>http://jodies.de/ipcalc</a>.</p></div></dd><dt class=hdlist1>SRC_PORT</dt><dd><p>O número da porta da origem é opcional. No entanto, se for usado, ela exige que o PROTO_TYPE seja definido primeiramente na regra. O número da porta também deve ser precedido pela palavra-chave <code>proto</code>.</p><div class=paragraph><p>Diferentes operadores de comparação são suportados: <code>=</code> (igual a), <code>!=</code> (diferente de), <code>&lt;</code> (menor que), <code>></code> (maior que), <code>⇐</code> (menor ou igual a) e <code>>=</code> (maior que ou igual a).</p></div><div class=paragraph><p>Para especificar intervalos de porta, coloque os dois números de porta entre <code>&lt;></code> (menor que e maior que), <code>>&lt;</code> (maior que e menor que) ou <code>:</code> (maior que ou igual a e menor que ou igual a).</p></div></dd><dt class=hdlist1>DST_ADDR</dt><dd><p>A palavra-chave <code>to</code> é obrigatória e é seguida por uma palavra-chave que representa o destino do pacote. Semelhante ao SRC_ADDR, ela pode ser um nome de host, um endereço IP seguido pela máscara CIDR, um pool de endereços ou a palavra-chave <code>all</code>.</p></dd><dt class=hdlist1>DST_PORT</dt><dd><p>Semelhante ao SRC_PORT, o número da porta do destino é opcional. No entanto, se for usada, ela exige que o PROTO_TYPE seja definido primeiramente na regra. O número da porta também deve ser precedido pela palavra-chave <code>proto</code>.</p></dd><dt class=hdlist1>TCP_FLAG|ICMP_TYPE</dt><dd><p>Se <code>tcp</code> for especificado como o PROTO_TYPE, flags poderão ser especificadas como letras, onde cada letra representa uma das possíveis flags TCP utilizadas para determinar o estado de uma conexão. Os valores possíveis são: <code>S</code> (SYN), <code>A</code> (ACK), <code>P</code> (PSH), <code>F</code> (FIN), <code>U</code> (URG), <code>R</code> (RST), <code>C</code> (CWN), e <code>E</code> (ECN).</p><div class=paragraph><p>Se o <code>icmp</code> for especificado como o PROTO_TYPE, o tipo ICMP para correspondência pode ser especificado. Consulte o <a href="https://man.freebsd.org/cgi/man.cgi?query=ipf&amp;sektion=5&amp;format=html">ipf(5)</a> para os tipos permitidos.</p></div></dd><dt class=hdlist1>STATE</dt><dd><p>Se uma regra <code>pass</code> contiver <code>keep state</code>, o IPF incluirá uma entrada em sua tabela de estados dinâmicos e permitirá o tráfego os pacotes subsequentes que correspondam à conexão. O IPF pode rastrear o estado das sessões TCP, UDP e ICMP. Qualquer pacote que o IPF tenha certeza de que faz parte de uma sessão ativa, mesmo que seja um protocolo diferente, será liberado.</p><div class=paragraph><p>No IPF, os pacotes destinados a sair pela interface conectada à Internet pública são verificados primeiro na tabela de estados dinâmicos. Se o pacote corresponder ao próximo pacote esperado, compreendendo uma sessão ativa, ele sairá do firewall e o estado do fluxo da sessão será atualizado na tabela de estados dinâmicos. Os pacotes que não pertencem a uma sessão já ativa são verificados no conjunto de regras de saída. Os pacotes vindos da interface conectada à Internet pública são verificados primeiro na tabela de estados dinâmicos. Se o pacote corresponder ao próximo pacote esperado que compreende uma sessão ativa, ele sairá do firewall e o estado do fluxo da sessão será atualizado na tabela de estados dinâmicos. Os pacotes que não pertencem a uma sessão já ativa são verificados no conjunto de regras de entrada.</p></div><div class=paragraph><p>Várias palavras-chave podem ser adicionadas depois de <code>keep state</code>. Se usadas, essas palavras-chave definem várias opções que controlam a filtragem stateful, como a configuração de limites de conexão ou o tempo de vida da conexão. Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=ipf&amp;sektion=5&amp;format=html">ipf(5)</a> para obter a lista de opções disponíveis e suas descrições.</p></div></dd></dl></div></div><div class=sect2><h3 id=_exemplo_de_conjunto_de_regras_2>30.5.3. Exemplo de Conjunto de Regras<a class=anchor href=#_exemplo_de_conjunto_de_regras_2></a></h3><div class=paragraph><p>Esta seção demonstra como criar um conjunto de regras de exemplo que permite apenas serviços que correspondam às regras <code>pass</code> e bloqueie todo o resto.</p></div><div class=paragraph><p>O FreeBSD usa a interface de loopback (<span class=filename>lo0</span>) e o endereço IP <code>127.0.0.1</code> para comunicação interna. O conjunto de regras do firewall deve conter regras para permitir o livre movimento desses pacotes usados internamente:</p></div><div class="literalblock programlisting"><div class=content><pre># no restrictions on loopback interface
pass in quick on lo0 all
pass out quick on lo0 all</pre></div></div><div class=paragraph><p>A interface pública conectada à Internet é usada para autorizar e controlar o acesso de todas as conexões de entrada e saída. Se uma ou mais interfaces forem cabeadas para redes privadas, essas interfaces internas poderão exigir regras para permitir que os pacotes originados da LAN fluam entre as redes internas ou para a interface conectada à Internet. O conjunto de regras deve ser organizado em três seções principais: quaisquer interfaces internas confiáveis, conexões de saída por meio da interface pública e conexões de entrada por meio da interface pública.</p></div><div class=paragraph><p>Essas duas regras permitem que todo o tráfego passe por uma interface confiável LAN chamada <span class=filename>xl0</span>:</p></div><div class="literalblock programlisting"><div class=content><pre># no restrictions on inside LAN interface for private network
pass out quick on xl0 all
pass in quick on xl0 all</pre></div></div><div class=paragraph><p>As regras para as seções de saída e entrada da interface pública devem ter as regras correspondidas com mais frequência antes das regras menos comuns, com a última regra na seção bloqueando e registrando todos os pacotes para essa interface e direção.</p></div><div class=paragraph><p>Este conjunto de regras define a seção de saída da interface pública denominada <span class=filename>dc0</span>. Essas regras mantêm o estado e identificam os serviços específicos que os sistemas internos estão autorizados para acesso público à Internet. Todas as regras usam <code>quick</code> e especificam os números de porta apropriados e, quando aplicável, os endereços de destino.</p></div><div class="literalblock programlisting"><div class=content><pre># interface facing Internet (outbound)
# Matches session start requests originating from or behind the
# firewall, destined for the Internet.

# Allow outbound access to public DNS servers.
# Replace x.x.x. with address listed in /etc/resolv.conf.
# Repeat for each DNS server.
pass out quick on dc0 proto tcp from any to x.x.x. port = 53 flags S keep state
pass out quick on dc0 proto udp from any to xxx port = 53 keep state

# Allow access to ISP&#39;s specified DHCP server for cable or DSL networks.
# Use the first rule, then check log for the IP address of DHCP server.
# Then, uncomment the second rule, replace z.z.z.z with the IP address,
# and comment out the first rule
pass out log quick on dc0 proto udp from any to any port = 67 keep state
#pass out quick on dc0 proto udp from any to z.z.z.z port = 67 keep state

# Allow HTTP and HTTPS
pass out quick on dc0 proto tcp from any to any port = 80 flags S keep state
pass out quick on dc0 proto tcp from any to any port = 443 flags S keep state

# Allow email
pass out quick on dc0 proto tcp from any to any port = 110 flags S keep state
pass out quick on dc0 proto tcp from any to any port = 25 flags S keep state

# Allow NTP
pass out quick on dc0 proto tcp from any to any port = 37 flags S keep state

# Allow FTP
pass out quick on dc0 proto tcp from any to any port = 21 flags S keep state

# Allow SSH
pass out quick on dc0 proto tcp from any to any port = 22 flags S keep state

# Allow ping
pass out quick on dc0 proto icmp from any to any icmp-type 8 keep state

# Block and log everything else
block out log first quick on dc0 all</pre></div></div><div class=paragraph><p>Neste exemplo de regras na seção de entrada da interface pública todos os pacotes indesejáveis são bloqueados primeiro. Isso reduz o número de pacotes registrados pela última regra.</p></div><div class="literalblock programlisting"><div class=content><pre># interface facing Internet (inbound)
# Block all inbound traffic from non-routable or reserved address spaces
block in quick on dc0 from 192.168.0.0/16 to any    #RFC 1918 private IP
block in quick on dc0 from 172.16.0.0/12 to any     #RFC 1918 private IP
block in quick on dc0 from 10.0.0.0/8 to any        #RFC 1918 private IP
block in quick on dc0 from 127.0.0.0/8 to any       #loopback
block in quick on dc0 from 0.0.0.0/8 to any         #loopback
block in quick on dc0 from 169.254.0.0/16 to any    #DHCP auto-config
block in quick on dc0 from 192.0.2.0/24 to any      #reserved for docs
block in quick on dc0 from 204.152.64.0/23 to any   #Sun cluster interconnect
block in quick on dc0 from 224.0.0.0/3 to any       #Class D &amp; E multicast

# Block fragments and too short tcp packets
block in quick on dc0 all with frags
block in quick on dc0 proto tcp all with short

# block source routed packets
block in quick on dc0 all with opt lsrr
block in quick on dc0 all with opt ssrr

# Block OS fingerprint attempts and log first occurrence
block in log first quick on dc0 proto tcp from any to any flags FUP

# Block anything with special options
block in quick on dc0 all with ipopts

# Block public pings and ident
block in quick on dc0 proto icmp all icmp-type 8
block in quick on dc0 proto tcp from any to any port = 113

# Block incoming Netbios services
block in log first quick on dc0 proto tcp/udp from any to any port = 137
block in log first quick on dc0 proto tcp/udp from any to any port = 138
block in log first quick on dc0 proto tcp/udp from any to any port = 139
block in log first quick on dc0 proto tcp/udp from any to any port = 81</pre></div></div><div class=paragraph><p>Sempre que houver mensagens de log em uma regra com a opção <code>log first</code>, execute <code>ipfstat -hio</code> para saber quantas vezes a regra foi correspondida. Um grande número de correspondências pode indicar que o sistema está sob ataque.</p></div><div class=paragraph><p>O restante das regras na seção de entrada define quais conexões podem ser iniciadas a partir da Internet. A última regra nega todas as conexões que não foram explicitamente permitidas pelas regras anteriores desta seção.</p></div><div class="literalblock programlisting"><div class=content><pre># Allow traffic in from ISP&#39;s DHCP server. Replace z.z.z.z with
# the same IP address used in the outbound section.
pass in quick on dc0 proto udp from z.z.z.z to any port = 68 keep state

# Allow public connections to specified internal web server
pass in quick on dc0 proto tcp from any to x.x.x.x port = 80 flags S keep state

# Block and log only first occurrence of all remaining traffic.
block in log first quick on dc0 all</pre></div></div></div><div class=sect2><h3 id=_configurando_o_nat>30.5.4. Configurando o NAT<a class=anchor href=#_configurando_o_nat></a></h3><div class=paragraph><p>Para ativar o NAT, adicione estas instruções ao arquivo <span class=filename>/etc/rc.conf</span> e especifique o nome do arquivo que contém as regras de NAT:</p></div><div class="literalblock programlisting"><div class=content><pre>gateway_enable=&#34;YES&#34;
ipnat_enable=&#34;YES&#34;
ipnat_rules=&#34;/etc/ipnat.rules&#34;</pre></div></div><div class=paragraph><p>As regras de NAT são flexíveis e podem realizar muitas coisas diferentes para atender às necessidades dos usuários comerciais e domésticos. A sintaxe da regra apresentada aqui foi simplificada para demonstrar um uso comum. Para obter uma descrição completa da sintaxe da regra, consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=ipnat&amp;sektion=5&amp;format=html">ipnat(5)</a>.</p></div><div class=paragraph><p>A sintaxe básica para uma regra NAT é a seguinte, onde <code>map</code> inicia a regra e <em>IF</em> deve ser substituído pelo nome da interface externa:</p></div><div class="literalblock programlisting"><div class=content><pre>map IF LAN_IP_RANGE -&gt; PUBLIC_ADDRESS</pre></div></div><div class=paragraph><p>O <em>LAN_IP_RANGE</em> é o intervalo de endereços IP usados pelos clientes internos. Geralmente, é um intervalo de endereços privados, como <code>192.168.1.0/24</code>. O <em>PUBLIC_ADDRESS</em> pode ser o endereço IP externo estático ou a palavra-chave <code>0/32</code> que representa o endereço IP atribuído para <em>IF</em>.</p></div><div class=paragraph><p>No IPF, quando um pacote chega ao firewall a partir da LAN com um destino público, ele primeiro passa pelas regras de saída do conjunto de regras do firewall. Em seguida, o pacote é passado para o conjunto de regras NAT, o qual é lido de cima para baixo, onde a primeira regra correspondente ganha. O IPF testa cada regra de NAT em relação ao nome da interface e ao endereço IP de origem do pacote. Quando o nome da interface de um pacote corresponde a uma regra NAT, o endereço IP de origem do pacote na LAN privada é verificado para ver se ele está dentro do intervalo de endereços IP especificado em <em>LAN_IP_RANGE</em>. Se corresponder, o pacote tem seu endereço IP de origem reescrito com o endereço IP público especificado por <em>PUBLIC_ADDRESS</em>. O IPF adiciona uma entrada em sua tabela NAT interna para que, quando o pacote retornar da Internet, possa ser mapeado de volta para seu endereço IP privado original antes de ser passado para as regras de firewall para processamento adicional.</p></div><div class=paragraph><p>Para redes que possuem um grande número de sistemas internos ou várias sub-redes, o processo de afunilar todo endereço IP em um único endereço IP público se torna um problema de recursos. Dois métodos estão disponíveis para aliviar esse problema.</p></div><div class=paragraph><p>O primeiro método é atribuir um intervalo de portas para usar como portas de origem. Adicionando a palavra-chave <code>portmap</code>, o NAT pode ser direcionado para usar apenas portas de origem no intervalo especificado:</p></div><div class="literalblock programlisting"><div class=content><pre>map dc0 192.168.1.0/24 -&gt; 0/32 portmap tcp/udp 20000:60000</pre></div></div><div class=paragraph><p>Como alternativa, use a palavra-chave <code>auto</code> que informa ao NAT para determinar as portas que estão disponíveis para uso:</p></div><div class="literalblock programlisting"><div class=content><pre>map dc0 192.168.1.0/24 -&gt; 0/32 portmap tcp/udp auto</pre></div></div><div class=paragraph><p>O segundo método é usar um pool de endereços públicos. Isso é útil quando existem muitos clientes na LAN para para usar um único endereço público e um bloco de endereços públicos de IP está disponível. Esses endereços públicos podem ser usados como um pool do qual o NAT seleciona um endereço IP à medida que o endereço de um pacote é mapeado ao sair.</p></div><div class=paragraph><p>O intervalo de endereços IP públicos pode ser especificado usando uma notação de netmask ou CIDR. Essas duas regras são equivalentes:</p></div><div class="literalblock programlisting"><div class=content><pre>map dc0 192.168.1.0/24 -&gt; 204.134.75.0/255.255.255.0
map dc0 192.168.1.0/24 -&gt; 204.134.75.0/24</pre></div></div><div class=paragraph><p>Uma prática comum é ter um servidor web ou servidor de email publicamente acessível isolado a um segmento de rede interno. O tráfego desses servidores ainda precisa passar por NAT, mas o redirecionamento de porta é necessário para direcionar o tráfego de entrada para o servidor correto. Por exemplo, para mapear um servidor web usando o endereço interno <code>10.0.10.25</code> para seu endereço IP público <code>20.20.20.5</code>, use esta regra:</p></div><div class="literalblock programlisting"><div class=content><pre>rdr dc0 20.20.20.5/32 port 80 -&gt; 10.0.10.25 port 80</pre></div></div><div class=paragraph><p>Se for o único servidor web, essa regra também funcionará, pois redirecionará todas as solicitações HTTP externas para <code>10.0.10.25</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>rdr dc0 0.0.0.0/0 port 80 -&gt; 10.0.10.25 port 80</pre></div></div><div class=paragraph><p>O IPF possui um proxy FTP embutido que pode ser usado com o NAT. Ele monitora todo o tráfego de saída de conexões ativa ou passiva de FTP e cria dinamicamente regras de filtro temporário contendo o número de porta usado pelo canal de dados FTP. Isso elimina a necessidade de abrir grandes intervalos de portas altas para conexões de FTP.</p></div><div class=paragraph><p>Neste exemplo, a primeira regra chama o proxy no tráfego de saída FTP da LAN interna. A segunda regra passa o tráfego de FTP do firewall para a Internet, e a terceira regra lida com todo o tráfego não FTP da LAN interna:</p></div><div class="literalblock programlisting"><div class=content><pre>map dc0 10.0.10.0/29 -&gt; 0/32 proxy port 21 ftp/tcp
map dc0 0.0.0.0/0 -&gt; 0/32 proxy port 21 ftp/tcp
map dc0 10.0.10.0/29 -&gt; 0/32</pre></div></div><div class=paragraph><p>As regras <code>map</code> de FTP vem antes da regra NAT, de modo que quando um pacote corresponder a uma regra FTP, o proxy FTP crie regras temporárias de filtragem para permitir que os pacotes da sessão FTP sejam liberados e que passem pelo NAT. Todos os pacotes de rede local que não sejam FTP não corresponderão às regras de FTP, mas serão liberados pelo NAT se corresponderem à terceira regra.</p></div><div class=paragraph><p>Sem o proxy FTPem, as seguintes regras de firewall seriam necessárias. Note que sem o proxy, todas as portas acima de <code>1024</code> precisam ser permitidas:</p></div><div class="literalblock programlisting"><div class=content><pre># Allow out LAN PC client FTP to public Internet
# Active and passive modes
pass out quick on rl0 proto tcp from any to any port = 21 flags S keep state

# Allow out passive mode data channel high order port numbers
pass out quick on rl0 proto tcp from any to any port &gt; 1024 flags S keep state

# Active mode let data channel in from FTP server
pass in quick on rl0 proto tcp from any to any port = 20 flags S keep state</pre></div></div><div class=paragraph><p>Sempre que o arquivo contendo as regras de NAT for editado, execute <code>ipnat</code> com <code>-CF</code> para excluir as regras atuais de NAT e liberar o conteúdo da tabela de tradução dinâmica. Inclua <code>-f</code> e especifique o nome do conjunto de regras NAT para carregar:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ipnat -CF -f /etc/ipnat.rules</span></code></pre></div></div><div class=paragraph><p>Para exibir as estatísticas de NAT:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ipnat -s</span></code></pre></div></div><div class=paragraph><p>Para listar os mapeamentos atuais da tabela NAT:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ipnat -l</span></code></pre></div></div><div class=paragraph><p>Para ativar o modo verbose e exibir informações relacionadas ao processamento de regras, regras ativas e registros nas tabelas:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ipnat -v</span></code></pre></div></div></div><div class=sect2><h3 id=_visualizando_estatísticas_do_ipf>30.5.5. Visualizando Estatísticas do IPF<a class=anchor href=#_visualizando_estatísticas_do_ipf></a></h3><div class=paragraph><p>O IPF inclui o <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfstat&amp;sektion=8&amp;format=html">ipfstat(8)</a> que pode ser usado para recuperar e exibir estatísticas das regras sendo utilizadas enquanto os pacotes passam pelo firewall. As estatísticas são acumuladas desde que o firewall foi iniciado pela última vez ou desde a última vez que foram redefinidas para zero usando <code>ipf -Z</code>.</p></div><div class=paragraph><p>A saída padrão do <code>ipfstat</code> é semelhante a esta:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>input packets: blocked 99286 passed 1255609 nomatch 14686 counted 0
 output packets: blocked 4200 passed 1284345 nomatch 14687 counted 0
 input packets logged: blocked 99286 passed 0
 output packets logged: blocked 0 passed 0
 packets logged: input 0 output 0
 log failures: input 3898 output 0
 fragment state<span class=o>(</span><span class=k>in</span><span class=o>)</span>: kept 0 lost 0
 fragment state<span class=o>(</span>out<span class=o>)</span>: kept 0 lost 0
 packet state<span class=o>(</span><span class=k>in</span><span class=o>)</span>: kept 169364 lost 0
 packet state<span class=o>(</span>out<span class=o>)</span>: kept 431395 lost 0
 ICMP replies: 0 TCP RSTs sent: 0
 Result cache hits<span class=o>(</span><span class=k>in</span><span class=o>)</span>: 1215208 <span class=o>(</span>out<span class=o>)</span>: 1098963
 IN Pullups succeeded: 2 failed: 0
 OUT Pullups succeeded: 0 failed: 0
 Fastroute successes: 0 failures: 0
 TCP <span class=nb>cksum </span>fails<span class=o>(</span><span class=k>in</span><span class=o>)</span>: 0 <span class=o>(</span>out<span class=o>)</span>: 0
 Packet log flags <span class=nb>set</span>: <span class=o>(</span>0<span class=o>)</span></code></pre></div></div><div class=paragraph><p>Várias opções estão disponíveis. Quando executado com <code>-i</code> para entrada ou <code>-o</code> para saída, o comando recuperará e exibirá a lista apropriada de regras de filtro atualmente instaladas e em uso pelo kernel. Para também ver os números das regras, inclua <code>-n</code>. Por exemplo, <code>ipfstat -on</code> exibe a tabela de regras de saída com os números de regra:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>@1 pass out on xl0 from any to any
@2 block out on dc0 from any to any
@3 pass out quick on dc0 proto tcp/udp from any to any keep state</code></pre></div></div><div class=paragraph><p>Inclua <code>-h</code> para prefixar cada regra com uma contagem de quantas vezes a regra foi utilizada. Por exemplo, <code>ipfstat -oh</code> exibe a tabela de regras internas de saída, prefixando cada regra com sua contagem de uso:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>2451423 pass out on xl0 from any to any
354727 block out on dc0 from any to any
430918 pass out quick on dc0 proto tcp/udp from any to any keep state</code></pre></div></div><div class=paragraph><p>Para exibir a tabela de estados em um formato similar ao <a href="https://man.freebsd.org/cgi/man.cgi?query=top&amp;sektion=1&amp;format=html">top(1)</a>, use <code>ipfstat -t</code>. Quando o firewall está sob ataque, essa opção fornece a capacidade de identificar e ver os pacotes de ataque. As sub-flags opcionais dão a possibilidade de selecionar o IP destino ou origem, porta ou protocolo a ser monitorado em tempo real. Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfstat&amp;sektion=8&amp;format=html">ipfstat(8)</a> para detalhes.</p></div></div><div class=sect2><h3 id=_log_do_ipf>30.5.6. Log do IPF<a class=anchor href=#_log_do_ipf></a></h3><div class=paragraph><p>O IPF fornece o <code>ipmon</code>, que pode ser usado para gravar as informações de log do firewall em um formato legível por humanos. Isso requer que as opções <code>IPFILTER_LOG</code> sejam primeiramente adicionadas a um kernel personalizado usando as instruções em <a href=../kernelconfig/#kernelconfig>Configurando o kernel do FreeBSD</a>.</p></div><div class=paragraph><p>Esse comando geralmente é executado no modo daemon para fornecer um arquivo de log contínuo do sistema para que o registro de eventos passados possa ser revisado. Como o FreeBSD possui um recurso <a href="https://man.freebsd.org/cgi/man.cgi?query=syslogd&amp;sektion=8&amp;format=html">syslogd(8)</a> integrado para rotacionar automaticamente os logs do sistema, a instrução <code>ipmon_flags</code> no arquivo <span class=filename>rc.conf</span> por padrão utiliza <code>-Ds</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>ipmon_flags=&#34;-Ds&#34; # D = start as daemon
                  # s = log to syslog
                  # v = log tcp window, ack, seq
                  # n = map IP &amp; port to names</pre></div></div><div class=paragraph><p>O registro em log fornece a capacidade de revisar, após o fato, informações como quais pacotes foram descartados, de que endereços eles vieram e para onde estavam indo. Esta informação é útil para rastrear invasores.</p></div><div class=paragraph><p>Uma vez que o recurso de criação de log esteja ativado no arquivo <span class=filename>rc.conf</span> e iniciado com o serviço <code>ipmon start</code>, o IPF irá registrar apenas as regras que contêm a palavra-chave <code>log</code>. O administrador do firewall decide quais regras no conjunto de regras devem ser logadas e normalmente apenas as regras de negação são registradas. É costume incluir a palavra-chave <code>log</code> na última regra do conjunto de regras. Isso possibilita ver todos os pacotes que não correspondem a nenhuma das regras do conjunto de regras.</p></div><div class=paragraph><p>Por padrão, o modo <code>ipmon -Ds</code> usa <code>local0</code> como o recurso de log. Os níveis de registro a seguir podem ser usados para separar ainda mais os dados logados:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>LOG_INFO - pacotes logados usando a palavra-chave <span class=s2>&#34;log&#34;</span> ao invés da ação  pass ou block.
LOG_NOTICE - pacotes logados que também são liberados
LOG_WARNING - pacotes logados que também são bloqueados
LOG_ERR - pacotes que foram logados e que podem ser considerados insuficientes devido a um cabeçalho incompleto</code></pre></div></div><div class=paragraph><p>Para configurar o IPF para logar todos os dados em <span class=filename>/var/log/ipfilter.log</span>, primeiro crie o arquivo vazio:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># touch /var/log/ipfilter.log</span></code></pre></div></div><div class=paragraph><p>Em seguida, para gravar todas as mensagens de log no arquivo especificado, inclua a seguinte instrução no arquivo <span class=filename>/etc/syslog.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>local0.* /var/log/ipfilter.log</pre></div></div><div class=paragraph><p>Para ativar as alterações e instruir o <a href="https://man.freebsd.org/cgi/man.cgi?query=syslogd&amp;sektion=8&amp;format=html">syslogd(8)</a> para ler o arquivo modificado <span class=filename>/etc/syslog.conf</span>, execute <code>service syslogd reload</code>.</p></div><div class=paragraph><p>Não se esqueça de editar o <span class=filename>/etc/newsyslog.conf</span> para rotacionar o novo arquivo de log.</p></div><div class=paragraph><p>As mensagens geradas pelo <code>ipmon</code> consistem em campos de dados separados por espaços em branco. Campos comuns a todas as mensagens são:</p></div><div class="olist arabic"><ol class=arabic><li><p>A data do recebimento do pacote.</p></li><li><p>O horário do recebimento do pacote. Isto está no formato HH:MM:SS.F, para horas, minutos, segundos e frações de segundo.</p></li><li><p>O nome da interface que processou o pacote.</p></li><li><p>O grupo e o número da regra no formato <code>@0:17</code>.</p></li><li><p>A ação: <code>p</code> para liberado (pass), <code>b</code> para bloqueado, <code>S</code> para um pacote com problema (short), <code>n</code> não corresponde a nenhuma regra e <code>L</code> para uma regra de log.</p></li><li><p>Os endereços escritos em três campos: o endereço de origem e porta separados por uma vírgula, o símbolo → , e o endereço e porta de destino. Por exemplo: <code>209.53.17.22,80 → 198.73.220.17,1722</code>.</p></li><li><p><code>PR</code> seguido pelo nome ou número do protocolo: por exemplo, <code>PR tcp</code>.</p></li><li><p><code>len</code> seguido pelo tamanho do cabeçalho e comprimento total do pacote: por exemplo, <code>len 20 40</code>.</p></li></ol></div><div class=paragraph><p>Se o pacote for um pacote TCP, haverá um campo adicional começando com um hífen seguido por letras correspondentes a quaisquer flags que foram configuradas. Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=ipf&amp;sektion=5&amp;format=html">ipf(5)</a> para obter uma lista de letras e suas flags.</p></div><div class=paragraph><p>Se o pacote for um pacote ICMP, haverá dois campos no final: o primeiro sempre sendo "icmp" e o próximo sendo a mensagem ICMP e sub-tipo de mensagem, separados por uma barra. Por exemplo: <code>icmp 3/3</code> para uma mensagem port unreachable.</p></div></div></div></div><div class=sect1><h2 id=firewalls-blacklistd>30.6. Blacklistd<a class=anchor href=#firewalls-blacklistd></a></h2><div class=sectionbody><div class=paragraph><p>O Blacklistd é um daemon que escuta sockets para receber notificações de outros daemons sobre tentativas de conexão que falharam ou foram bem-sucedidas. É mais amplamente utilizado no bloqueio de muitas tentativas de conexão em portas abertas. Um exemplo excelente é o SSH, executado na Internet, recebendo muitas solicitações de conexão de bots ou scripts tentando adivinhar senhas e obter acesso. Utilizando blacklistd, o daemon pode notificar o firewall para criar uma regra de filtro para bloquear tentativas excessivas de conexão de uma única origem após várias tentativas. O Blacklistd foi desenvolvido pela primeira vez no NetBSD e apareceu na versão 7. O FreeBSD 11 importou o blacklistd do NetBSD.</p></div><div class=paragraph><p>Este capítulo descreve como instalar o blacklistd, configurá-lo e fornece exemplos de como usá-la. Os leitores devem estar familiarizados com os conceitos básicos de firewall, como regras. Para detalhes, consulte o capítulo sobre firewall. O PF é usado nos exemplos, mas outros firewalls disponíveis no FreeBSD também devem funcionar com o blacklistd.</p></div><div class=sect2><h3 id=_habilitando_a_blacklistd>30.6.1. Habilitando a Blacklistd<a class=anchor href=#_habilitando_a_blacklistd></a></h3><div class=paragraph><p>A configuração principal do blacklistd é armazenada em <a href="https://man.freebsd.org/cgi/man.cgi?query=blacklistd.conf&amp;sektion=5&amp;format=html">blacklistd.conf(5)</a>. Várias opções de linha de comando também estão disponíveis para alterar o comportamento em tempo de execução do blacklistd. Para persistir as configurações em uma reinicialização do sistema, deve se armazenar as opções em <span class=filename>/etc/blacklistd.conf</span>. Para ativar o daemon durante a inicialização do sistema, adicione a linha <code>blacklistd_enable</code> no <span class=filename>/etc/rc.conf</span> assim:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysrc blacklistd_enable=yes</span></code></pre></div></div><div class=paragraph><p>Para iniciar o serviço manualmente, execute este comando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service blacklistd start</span></code></pre></div></div></div><div class=sect2><h3 id=_criando_um_conjunto_de_regras_no_blacklistd>30.6.2. Criando um conjunto de regras no Blacklistd<a class=anchor href=#_criando_um_conjunto_de_regras_no_blacklistd></a></h3><div class=paragraph><p>As regras do blacklistd são configuradas em <a href="https://man.freebsd.org/cgi/man.cgi?query=blacklistd.conf&amp;sektion=5&amp;format=html">blacklistd.conf(5)</a> com uma opção por linha. Cada regra contém uma tupla separada por espaços ou tabulações. As regras pertencem a um <code>local</code> ou a um <code>remote</code>, que se aplica à máquina em que o blacklistd está sendo executado ou a uma origem externa, respectivamente.</p></div><div class=sect3><h4 id=_regras_locais>30.6.2.1. Regras Locais<a class=anchor href=#_regras_locais></a></h4><div class=paragraph><p>Um exemplo de entrada blacklistd.conf para uma regra local se parece com isso:</p></div><div class="literalblock programlisting"><div class=content><pre>[local]
ssh             stream  *       *               *       3       24h</pre></div></div><div class=paragraph><p>Todas as regras que seguem a seção <code>[local]</code> são tratadas como regras locais (que é o padrão), aplicadas à máquina local. Quando uma seção <code>[remote]</code> é encontrada, todas as regras a seguir são tratadas como regras de máquina remota.</p></div><div class=paragraph><p>Sete campos definem uma regra separada por tabulações ou espaços. Os quatro primeiros campos identificam o tráfego que deve estar na lista negra. Os três campos a seguir definem o comportamento do backlistd. Os curingas são indicados como asteriscos (<code>*</code>), correspondendo a qualquer coisa nesse campo. O primeiro campo define a localização. Nas regras locais, essas são as portas de rede. A sintaxe para o campo local é a seguinte:</p></div><div class="literalblock programlisting"><div class=content><pre>[address|interface][/mask][:port]</pre></div></div><div class=paragraph><p>Os endereços podem ser especificados como IPv4 no formato numérico ou IPv6 entre colchetes. Um nome de interface como <code><em>em0</em></code> também pode ser usado.</p></div><div class=paragraph><p>O tipo de socket é definido pelo segundo campo. Os socket TCP são do tipo <code>stream</code>, enquanto UDP é indicado como <code>dgram</code>. O exemplo acima usa TCP, pois o SSH está usando esse protocolo.</p></div><div class=paragraph><p>Um protocolo pode ser usado no terceiro campo de uma regra de lista negra. Os seguintes protocolos podem ser usados: <code>tcp</code>, <code>udp</code>, <code>tcp6</code>, <code>udp6</code> ou numérico. Um curinga, como no exemplo, geralmente é usado para corresponder a todos os protocolos, a menos que haja um motivo para distinguir o tráfego por um determinado protocolo.</p></div><div class=paragraph><p>No quarto campo, o usuário ou proprietário efetivo do processo daemon que está reportando o evento é definido. O nome de usuário ou o UID pode ser usado aqui, bem como um curinga (veja a regra de exemplo acima).</p></div><div class=paragraph><p>O nome da regra do packet filter é declarado pelo quinto campo, que inicia a parte de comportamento da regra. Por padrão, blacklistd coloca todos os blocos sob uma âncora pf chamada <code>blacklistd</code> em <span class=filename>pf.conf</span> assim:</p></div><div class="literalblock programlisting"><div class=content><pre>anchor &#34;blacklistd/*&#34; in on $ext_if
block in
pass out</pre></div></div><div class=paragraph><p>Para blacklists separadas, um nome de âncora pode ser usado neste campo. Em outros casos, o curinga será suficiente. Quando um nome começa com um hífen (<code>-</code>), significa que uma âncora com o nome de regra padrão precedido deve ser usada. Uma modificação do exemplo acima usando o hífen ficaria assim:</p></div><div class="literalblock programlisting"><div class=content><pre>ssh             stream  *       *               -ssh       3       24h</pre></div></div><div class=paragraph><p>Com essa regra, quaisquer novas regras de blacklist são adicionadas a uma âncora chamada <code>blacklistd-ssh</code>.</p></div><div class=paragraph><p>Para bloquear sub-redes inteiras para uma única violação de regra, um <code>/</code> no nome da regra pode ser usado. Isso faz com que a parte restante do nome seja interpretada como a máscara a ser aplicada ao endereço especificado na regra. Por exemplo, esta regra bloquearia todos os endereços adjacentes a <code>/24</code>.</p></div><div class="literalblock programlisting"><div class=content><pre>22              stream  tcp       *               */24    3       24h</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>É importante especificar o protocolo apropriado aqui. O IPv4 e o IPv6 tratam o /24 de maneira diferente, é por isso que <code>*</code> não pode ser usado no terceiro campo para esta regra.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Esta regra define que, se qualquer host dessa rede estiver se comportando mal, todo o resto da rede também será bloqueado.</p></div><div class=paragraph><p>O sexto campo, chamado <code>nfail</code>, define o número de falhas de login necessárias para colocar na blacklist o IP remoto em questão. Quando um curinga é usado nessa posição, isso significa que o bloqueio nunca irá acontecer. Na regra de exemplo acima, um limite de três é definido, o que significa que, após três tentativas de logon no SSH em uma conexão, o IP é bloqueado.</p></div><div class=paragraph><p>O último campo em uma definição de regra do blacklistd especifica por quanto tempo um host ficará na lista negra. A unidade padrão é segundos, mas sufixos como <code>m</code>, <code>h</code> e <code>d</code> também podem ser especificados por minutos, horas e dias, respectivamente.</p></div><div class=paragraph><p>A regra de exemplo na íntegra significa que, após três vezes a autenticação no SSH, resultará em uma nova regra de bloqueio de PF para esse host. As correspondências de regras são realizadas verificando primeiro as regras locais, uma após a outra, da mais específica à menos específica. Quando ocorre uma correspondência, as regras <code>remote</code> são aplicadas e o nome <code>nfail</code> e os campos de desativação são alterados pela regra <code>remote</code> correspondente.</p></div></div><div class=sect3><h4 id=_regras_remotas>30.6.2.2. Regras Remotas<a class=anchor href=#_regras_remotas></a></h4><div class=paragraph><p>As regras remotas são usadas para especificar como o blacklistd muda seu comportamento, dependendo do host remoto que está sendo avaliado no momento. Cada campo em uma regra remota é o mesmo que em uma regra local. A única diferença está na maneira como o blacklistd os usa. Para explicar, esta regra de exemplo é usada:</p></div><div class="literalblock programlisting"><div class=content><pre>[remote]
203.0.113.128/25 *      *       *               =/25    =       48h</pre></div></div><div class=paragraph><p>O campo de endereço pode ser um endereço IP (v4 ou v6), uma porta ou ambas. Isso permite definir regras especiais para um intervalo de endereços remotos específico, como neste exemplo. Os campos para tipo, protocolo e proprietário são identicamente interpretados como na regra local.</p></div><div class=paragraph><p>Porém, os campos de nome são diferentes: o sinal de igual (<code>=</code>) em uma regra remota diz ao blacklistd para usar o valor da regra local correspondente. Isso significa que a entrada da regra de firewall é obtida e o prefixo <code>/25</code> (uma máscara de rede <code>255.255.255.128</code>) é adicionada. Quando uma conexão desse intervalo de endereços é colocada na lista negra, toda a sub-rede é afetada. Um nome de âncora PF também pode ser usado aqui; nesse caso, o blacklisted adicionará regras para esse bloco de endereços à âncora desse nome. A tabela padrão é usada quando um curinga é especificado.</p></div><div class=paragraph><p>Um número personalizado de falhas na coluna <code>nfail</code> pode ser definido para um endereço. Isso é útil para exceções a uma regra específica, talvez para permitir a alguém uma aplicação menos rigorosa de regras ou um pouco mais de clemência nas tentativas de login. O bloqueio é desativado quando um asterisco é usado neste sexto campo.</p></div><div class=paragraph><p>As regras remotas permitem uma aplicação mais rigorosa dos limites das tentativas de logon, em comparação com as tentativas provenientes de uma rede local como um escritório.</p></div></div></div><div class=sect2><h3 id=_configuração_do_cliente_no_blacklistd>30.6.3. Configuração do cliente no Blacklistd<a class=anchor href=#_configuração_do_cliente_no_blacklistd></a></h3><div class=paragraph><p>Existem alguns pacotes de software no FreeBSD que podem utilizar a funcionalidade do blacklistd. Os dois mais proeminentes são <a href="https://man.freebsd.org/cgi/man.cgi?query=ftpd&amp;sektion=8&amp;format=html">ftpd(8)</a> e <a href="https://man.freebsd.org/cgi/man.cgi?query=sshd&amp;sektion=8&amp;format=html">sshd(8)</a> para bloquear tentativas excessivas de conexão. Para ativar o blacklistd no daemon SSH, adicione a seguinte linha ao <span class=filename>/etc/ssh/sshd_config</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>UseBlacklist yes</pre></div></div><div class=paragraph><p>Reinicie o sshd posteriormente para que essas alterações entrem em vigor.</p></div><div class=paragraph><p>A lista negra do <a href="https://man.freebsd.org/cgi/man.cgi?query=ftpd&amp;sektion=8&amp;format=html">ftpd(8)</a> é ativada usando <code>-B</code>, em <span class=filename>/etc/inetd.conf</span> ou como uma flag no <span class=filename>/etc/rc.conf</span> assim:</p></div><div class="literalblock programlisting"><div class=content><pre>ftpd_flags=&#34;-B&#34;</pre></div></div><div class=paragraph><p>Isso é tudo o que é necessário para que esses programas conversem com o blacklistd.</p></div></div><div class=sect2><h3 id=_gerenciamento_do_blacklistd>30.6.4. Gerenciamento do Blacklistd<a class=anchor href=#_gerenciamento_do_blacklistd></a></h3><div class=paragraph><p>O Blacklistd fornece ao usuário um utilitário de gerenciamento chamado <a href="https://man.freebsd.org/cgi/man.cgi?query=blacklistctl&amp;sektion=8&amp;format=html">blacklistctl(8)</a>. Ele exibe endereços e redes bloqueados que estão na lista negra pelas regras definidas em <a href="https://man.freebsd.org/cgi/man.cgi?query=blacklistd.conf&amp;sektion=5&amp;format=html">blacklistd.conf(5)</a>. Para ver a lista de hosts atualmente bloqueados, use <code>dump</code> combinado com <code>-b</code> assim.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># blacklistctl dump -b</span>
      address/ma:port <span class=nb>id      </span>nfail   last access
213.0.123.128/25:22   OK      6/3     2019/06/08 14:30:19</code></pre></div></div><div class=paragraph><p>Este exemplo mostra que houve 6 de três tentativas permitidas na porta 22 provenientes do intervalo de endereços <code>213.0.123.128/25</code>. Há mais tentativas listadas do que são permitidas porque o SSH permite que um cliente tente vários logins em uma única conexão TCP. Uma conexão que está em andamento no momento não é interrompida pelo blacklistd. A última tentativa de conexão está listada na coluna <code>last access</code> da saída.</p></div><div class=paragraph><p>Para ver o tempo restante em que esse host estará na lista negra, adicione <code>-r</code> ao comando anterior.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># blacklistctl dump -br</span>
      address/ma:port <span class=nb>id      </span>nfail   remaining <span class=nb>time
</span>213.0.123.128/25:22   OK      6/3     36s</code></pre></div></div><div class=paragraph><p>Neste exemplo, restam 36 segundos para que este host não seja mais bloqueado.</p></div></div><div class=sect2><h3 id=_removendo_hosts_da_lista_de_bloqueios>30.6.5. Removendo hosts da lista de bloqueios<a class=anchor href=#_removendo_hosts_da_lista_de_bloqueios></a></h3><div class=paragraph><p>Às vezes, é necessário remover um host da lista de bloqueios antes que o tempo restante expire. Infelizmente, não há funcionalidade no blacklistd para fazer isso. No entanto, é possível remover o endereço da tabela PF usando pfctl. Para cada porta bloqueada, existe uma âncora filha dentro da âncora do blacklistd definida em <span class=filename>/etc/pf.conf</span>. Por exemplo, se houver uma âncora filha para bloquear a porta 22, ela será chamada <code>blacklistd/22</code>. Há uma tabela dentro dessa âncora filha que contém os endereços bloqueados. Essa tabela é chamada de port seguida pelo número da porta. Neste exemplo, ele seria chamada de <code>port22</code>. Com essas informações em mãos, agora é possível usar o <a href="https://man.freebsd.org/cgi/man.cgi?query=pfctl&amp;sektion=8&amp;format=html">pfctl(8)</a> para exibir todos os endereços listados desta maneira:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pfctl -a blacklistd/22 -t port22 -T show</span>
...
213.0.123.128/25
...</code></pre></div></div><div class=paragraph><p>Depois de identificar o endereço a ser desbloqueado da lista, o seguinte comando o remove da lista:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pfctl -a blacklistd/22 -t port22 -T delete 213.0.123.128/25</span></code></pre></div></div><div class=paragraph><p>O endereço agora foi removido do PF, mas ainda será exibido no blacklistctl, pois ele não conhece nenhuma alteração feita no PF. A entrada no banco de dados do blacklistd expirará e será removida de sua saída eventualmente. A entrada será adicionada novamente se o host estiver correspondendo a uma das regras de bloqueio no blacklistd novamente.</p></div></div></div></div></div><hr><div class=last-modified><p><strong>Última alteração em</strong>: 9 de março de 2024 por <a href="https://cgit.freebsd.org/doc/commit/?id=6199af92e7" target=_blank>Danilo G. Baio</a></p></div><div class=buttons><div class=prev><i class="fa fa-angle-left" aria-hidden=true title=Anterior></i><div class=container><a href=http://172.16.201.134:1313/pt-br/books/handbook/network-servers class=direction>Anterior</a></div></div><div class=home><i class="fa fa-home" aria-hidden=true title=Início></i><div class=container><a href=../ class=direction>Início</a></div></div><div class=next><div class=container><a href=http://172.16.201.134:1313/pt-br/books/handbook/advanced-networking class=direction>Próximo</a></div><i class="fa fa-angle-right" aria-hidden=true title=Próximo></i></div></div><label class="hidden book-menu-overlay" for=menu-control></label></div><aside class=toc><div class=toc-content><h3>Índice</h3><nav id=TableOfContents><ul><li><a href=#firewalls-intro>30.1. Sinopse</a></li><li><a href=#firewalls-concepts>30.2. Conceitos de Firewall</a></li><li><a href=#firewalls-pf>30.3. PF</a></li><li><a href=#firewalls-ipfw>30.4. IPFW</a></li><li><a href=#firewalls-ipf>30.5. IPFILTER (IPF)</a></li><li><a href=#firewalls-blacklistd>30.6. Blacklistd</a></li></ul></nav><hr><div class=resources><h3>Recursos</h3><ul class=contents><li><i class="fa fa-file-pdf-o" aria-hidden=true title="Download PDF"></i><a href=https://download.freebsd.org/doc/pt-br/books/handbook/handbook_pt-br.pdf>Download PDF</a></li><li><i class="fa fa-pencil-square-o" aria-hidden=true title="Edite essa página"></i><a href=https://github.com/freebsd/freebsd-doc/blob/main/documentation/content/pt-br/_index target=_blank>Edite essa página</a></li></ul></div></div></aside><a class=to-top href=#top><i class="fa fa-arrow-circle-up" aria-hidden=true></i></a></main><footer><div class=footer-container><section class=logo-column><img src=http://172.16.201.134:1313/images/FreeBSD-colors.svg width=160 height=50 alt="FreeBSD logo"><div class=options-container><div class=language-container><a id=languages href=http://172.16.201.134:1313/pt-br/languages><img src=http://172.16.201.134:1313/images/language.png class=language-image alt="Escolha o idioma">
<span>Brazilian Portuguese</span></a></div><div class=theme-container><select id=theme-chooser><option value=theme-system>System</option><option value=theme-light>Light</option><option value=theme-dark>Dark</option><option value=theme-high-contrast>Alto contraste</option></select></div></div></section><section class=about-column><h3 class=column-title>About</h3><ul class=column-elements-container><li><a href=https://www.freebsd.org/about/ target=_blank class=column-element>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/ target=_blank class=column-element>FreeBSD Foundation</a></li><li><a href=https://www.freebsd.org/where/ target=_blank class=column-element>Get FreeBSD</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct target=_blank class=column-element>Code of Conduct</a></li><li><a href=https://www.freebsd.org/security/ target=_blank class=column-element>Security Advisories</a></li></ul></section><section class=documentation-column><h3 class=column-title>Documentation</h3><ul class=column-elements-container><li><a href=/pt-br class=column-element>Documentation portal</a></li><li><a href=https://man.FreeBSD.org target=_blank class=column-element>Manual pages</a></li><li><a href=https://papers.FreeBSD.org target=_blank class=column-element>Presentations and papers</a></li><li><a href=https://docs-archive.freebsd.org/doc/ target=_blank class=column-element>Previous versions</a></li><li><a href=https://docs-archive.freebsd.org/44doc/ target=_blank class=column-element>4.4BSD Documents</a></li><li><a href=https://wiki.freebsd.org/ target=_blank class=column-element>Wiki</a></li></ul></section><section class=community-column><h3 class=column-title>Community</h3><ul class=column-elements-container><li><a href=http://172.16.201.134:1313/pt-br/articles/contributing class=column-element>Get involved</a></li><li><a href=https://forums.freebsd.org/ target=_blank class=column-element>Community forum</a></li><li><a href=https://lists.freebsd.org/ target=_blank class=column-element>Mailing lists</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank class=column-element>IRC Channels</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank class=column-element>Bug Tracker</a></li></ul></section><section class=legal-column><h3 class=column-title>Legal</h3><ul class=column-elements-container><li><a href=https://freebsdfoundation.org/donate/ target=_blank class=column-element>Donations</a></li><li><a href=https://www.freebsd.org/copyright/freebsd-license/ target=_blank class=column-element>Licensing</a></li><li><a href=https://www.freebsd.org/privacy/ target=_blank class=column-element>Privacy Policy</a></li><li><a href=https://www.freebsd.org/copyright/ target=_blank class=column-element>Legal notices</a></li></ul></section><section class=copyright-column><p>&copy; 1994-2024 The FreeBSD Project. All rights reserved</p><span>Made with <span class=heart>♥</span> by the FreeBSD Community</span></section></div></footer></body></html>