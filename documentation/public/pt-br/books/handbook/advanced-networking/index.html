<!doctype html><html class=theme-light lang=pt-br><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content><meta name=keywords content><meta name=copyright content="1995-2024 The FreeBSD Foundation"><link rel=canonical href=http://172.16.201.134:1313/pt-br/books/handbook/advanced-networking/><title>Capítulo 31. Rede Avançada | FreeBSD Documentation Portal</title>
<meta name=theme-color content="#790000"><meta name=color-scheme content="system light dark high-contrast"><link rel="shortcut icon" href=http://172.16.201.134:1313/favicon.ico><link rel=stylesheet href=http://172.16.201.134:1313/styles/main.min.css><link rel=stylesheet href=http://172.16.201.134:1313/css/font-awesome-min.css><script defer src=/js/theme-chooser.min.js></script><script defer src=/js/copy-clipboard.min.js></script><script defer src=/js/search.min.js></script><meta name=twitter:card content="summary"><meta name=twitter:domain content="docs.FreeBSD.org"><meta name=twitter:site content="@freebsd"><meta name=twitter:url content="https://twitter.com/freebsd"><meta property="og:title" content="Capítulo 31. Rede Avançada"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:image" content="http://172.16.201.134:1313/favicon.ico"><meta property="og:image:alt" content="FreeBSD Logo"><meta property="og:locale" content="pt-br"><meta property="og:url" content="http://172.16.201.134:1313/pt-br/books/handbook/advanced-networking/"><meta property="og:site_name" content="FreeBSD Documentation Portal"><script type=application/ld+json>{"@context":"http://schema.org","@type":"Article","url":"http:\/\/172.16.201.134:1313\/pt-br\/books\/handbook\/advanced-networking\/","name":"FreeBSD Documentation Portal","headline":"FreeBSD Documentation Portal","description":"FreeBSD Documentation Portal"}</script></head><body><header><div class=header-container><div class=logo-menu-bars-container><a href=https://www.FreeBSD.org class=logo><img src=http://172.16.201.134:1313/images/FreeBSD-monochromatic.svg width=160 height=50 alt="FreeBSD logo">
</a><label class=menu-bars for=menu-bars><i class="fa fa-bars" aria-hidden=true></i></label></div><input id=menu-bars type=checkbox><nav><ul class=menu><li class=menu-item><input id=about type=checkbox>
<a href=# aria-label="Navigate to About section"><label class=menu-item-description for=about>About
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/about/ target=_blank>About</a></li><li><a href=https://www.freebsd.org/about/ target=_blank>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/about-us/about-the-foundation/ target=_blank>FreeBSD Foundation</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct/ target=_blank>Code of Conduct</a></li></ul></li><li class=menu-item><input id=download type=checkbox>
<a href=# aria-label="Navigate to get FreeBSD section"><label class=menu-item-description for=download>Get FreeBSD
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/where/ target=_blank>Get FreeBSD</a></li><li><a href=https://www.freebsd.org/releases/ target=_blank>Release Information</a></li><li><a href=https://www.freebsd.org/releng/ target=_blank>Release Engineering</a></li><li><a href=https://www.freebsd.org/security/ target=_blank>Security Advisories</a></li></ul></li><li class=menu-item><input id=documentation type=checkbox>
<a href=# aria-label="Navigate to get Documentation section"><label class=menu-item-description for=documentation>Documentation
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=/pt-br>Documentation portal</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook>FreeBSD Handbook</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/porters-handbook>Porter's Handbook</a></li><li><a href=https://docs.FreeBSD.org/en/books/fdp-primer>Documentation Project Handbook</a></li><li><a href=https://man.FreeBSD.org target=_blank>Manual pages</a></li><li><a href=https://papers.FreeBSD.org target=_blank>Presentations and papers</a></li><li><a href=https://wiki.FreeBSD.org target=_blank>Wiki</a></li><li><a href=http://172.16.201.134:1313/pt-br/books>Books</a></li><li><a href=http://172.16.201.134:1313/pt-br/articles>Articles</a></li></ul></li><li class=menu-item><input id=community type=checkbox>
<a href=# aria-label="Navigate to get Community section"><label class=menu-item-description for=community>Community
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/community/>Community</a></li><li><a href=http://172.16.201.134:1313/pt-br/articles/contributing>Get involved</a></li><li><a href=https://forums.freebsd.org/ target=_blank>Forum</a></li><li><a href=https://lists.freebsd.org/ target=_blank>Mailing lists</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank>IRC Channels</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank>Bug Tracker</a></li><li><a href=https://www.freebsd.org/support/ target=_blank>Support</a></li></ul></li></ul></nav><div class=search-donate-container><form class=search method=get id=search-header-form action=https://docs.freebsd.org/search name=search-header-form><input type=hidden name=DB value=pt-br>
<input id=words name=P type=text size=20 maxlength=255>
<button>
<i class="fa fa-search" aria-hidden=true></i></button></form><div class=donate><a href=https://freebsdfoundation.org/donate/ target=_blank><span class=heart>♥</span>
Donate</a></div></div></div></header><input type=checkbox class="hidden toggle" id=menu-control><main class=main-wrapper-book><a id=top></a><aside class=book-menu><div class=book-menu-content><input id=search-book type=text placeholder=Pesquisar aria-label=Pesquisar maxlength=128><nav id=MenuContents><ul><li><input type=checkbox id=chapter-eb2a98ce203d8afd517726e6d8776be3 class=toggle>
<label class="icon cursor" for=chapter-eb2a98ce203d8afd517726e6d8776be3><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/preface/>Prefácio</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/preface/#preface-audience>Audiência Pretendida</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/preface/#preface-changes-from3>Mudanças desde a Terceira Edição</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/preface/#preface-changes-from2>Mudanças desde a Segunda Edição (2004)</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/preface/#preface-changes>Mudanças desde a Primeira Edição (2001)</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/preface/#preface-overview>Organização deste Livro</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/preface/#preface-conv>Convenções utilizadas neste livro</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/preface/#preface-acknowledgements>Agradecimentos</a></li></ul></li><li><input type=checkbox id=chapter-14a525fce014b90b8a458a894818255a class=toggle>
<label for=chapter-14a525fce014b90b8a458a894818255a><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/parti/>Parte I. Primeiros Passos</a></li><li><input type=checkbox id=chapter-f9c9f3451644df30d224350da97d5da6 class=toggle>
<label class="icon cursor" for=chapter-f9c9f3451644df30d224350da97d5da6><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/introduction/>Capítulo 1. Introdução</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/introduction/#introduction-synopsis>1.1. Sinopse</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/introduction/#nutshell>1.2. Bem vindo ao FreeBSD!</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/introduction/#history>1.3. Sobre o Projeto FreeBSD</a></li></ul></li><li><input type=checkbox id=chapter-f693a3fa687a72d63ec8129ee302d664 class=toggle>
<label class="icon cursor" for=chapter-f693a3fa687a72d63ec8129ee302d664><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/bsdinstall/>Capítulo 2. Instalando o FreeBSD</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/bsdinstall/#bsdinstall-synopsis>2.1. Sinopse</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/bsdinstall/#bsdinstall-hardware>2.2. Requisitos mínimos de hardware</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/bsdinstall/#bsdinstall-pre>2.3. Tarefas de Pré-instalação</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/bsdinstall/#bsdinstall-start>2.4. Iniciando a instalação</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/bsdinstall/#using-bsdinstall>2.5. Usando o bsdinstall</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/bsdinstall/#bsdinstall-partitioning>2.6. Alocando o espaço em disco</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/bsdinstall/#bsdinstall-fetching-distribution>2.7. Fazendo o download dos arquivos de distribuição</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/bsdinstall/#bsdinstall-post>2.8. Contas, Time Zone, Serviços e Hardening</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/bsdinstall/#bsdinstall-network>2.9. Interfaces de Rede</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/bsdinstall/#bsdinstall-install-trouble>2.10. Solução de problemas</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/bsdinstall/#using-live-cd>2.11. Usando o Live CD</a></li></ul></li><li><input type=checkbox id=chapter-9f6db261075f578742036fcc6000eecd class=toggle>
<label class="icon cursor" for=chapter-9f6db261075f578742036fcc6000eecd><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/basics/>Capítulo 3. Fundamentos do FreeBSD</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/basics/#basics-synopsis>3.1. Sinopse</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/basics/#consoles>3.2. Consoles e Terminais Virtuais</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/basics/#users-synopsis>3.3. Usuários e Gerenciamento Básico de Contas</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/basics/#permissions>3.4. Permissões</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/basics/#dirstructure>3.5. Estrutura de Diretórios</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/basics/#disk-organization>3.6. Organização dos Discos</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/basics/#mount-unmount>3.7. Montando e Desmontando Sistemas de Arquivos</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/basics/#basics-processes>3.8. Processos e Daemons</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/basics/#shells>3.9. Shells</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/basics/#editors>3.10. Editores de Texto</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/basics/#basics-devices>3.11. Dispositivos e nós de dispositivos</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/basics/#basics-more-information>3.12. Páginas de Manual</a></li></ul></li><li><input type=checkbox id=chapter-01c5707e95d14c0ff84bf62600c958d1 class=toggle>
<label class="icon cursor" for=chapter-01c5707e95d14c0ff84bf62600c958d1><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/ports/>Capítulo 4. Instalando Aplicativos: Pacotes e Ports</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/ports/#ports-synopsis>4.1. Sinopse</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/ports/#ports-overview>4.2. Visão geral sobre a Instalação de Software</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/ports/#ports-finding-applications>4.3. Encontrando Software</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/ports/#pkgng-intro>4.4. Usando o pkg para o gerenciamento de pacotes binários</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/ports/#ports-using>4.5. Usando a Coleção de Ports</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/ports/#ports-poudriere>4.6. Compilando Pacotes com o Poudriere</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/ports/#ports-nextsteps>4.7. Considerações pós-instalação</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/ports/#ports-broken>4.8. Lidando com ports quebrados</a></li></ul></li><li><input type=checkbox id=chapter-3405c00581365a8b5d16af70fe4d1b72 class=toggle>
<label class="icon cursor" for=chapter-3405c00581365a8b5d16af70fe4d1b72><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/x11/>Capítulo 5. O sistema X Window</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/x11/#x11-synopsis>5.1. Sinopse</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/x11/#x-understanding>5.2. Terminologia</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/x11/#x-install>5.3. Instalando o Xorg</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/x11/#x-config>5.4. Configuração do Xorg</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/x11/#x-fonts>5.5. Usando fontes no Xorg</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/x11/#x-xdm>5.6. O Gerenciador de Display X</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/x11/#x11-wm>5.7. Ambientes de desktop</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/x11/#x-compiz-fusion>5.8. Instalando o Compiz Fusion</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/x11/#x11-troubleshooting>5.9. Solução de problemas</a></li></ul></li><li><input type=checkbox id=chapter-0eab3565e8f59f5a8a896dfba7eb3680 class=toggle>
<label for=chapter-0eab3565e8f59f5a8a896dfba7eb3680><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/partii/>Parte II. Tarefas comuns</a></li><li><input type=checkbox id=chapter-b33cf28993f3f7bf5baf036e79da0f39 class=toggle>
<label class="icon cursor" for=chapter-b33cf28993f3f7bf5baf036e79da0f39><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/desktop/>Capítulo 6. Aplicações de Desktop</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/desktop/#desktop-synopsis>6.1. Sinopse</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/desktop/#desktop-browsers>6.2. Navegadores</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/desktop/#desktop-productivity>6.3. Produtividade</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/desktop/#desktop-viewers>6.4. Visualizadores de Documentos</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/desktop/#desktop-finance>6.5. Finanças</a></li></ul></li><li><input type=checkbox id=chapter-152f694a19312ad72ec7bb4e1c3c33b2 class=toggle>
<label class="icon cursor" for=chapter-152f694a19312ad72ec7bb4e1c3c33b2><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/multimedia/>Capítulo 7. Multimídia</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/multimedia/#multimedia-synopsis>7.1. Sinopse</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/multimedia/#sound-setup>7.2. Configurando a Placa de Som</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/multimedia/#sound-mp3>7.3. Áudio MP3</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/multimedia/#video-playback>7.4. Reprodução de Vídeo</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/multimedia/#tvcard>7.5. Placas de TV</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/multimedia/#mythtv>7.6. MythTV</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/multimedia/#scanners>7.7. Scanners de Imagem</a></li></ul></li><li><input type=checkbox id=chapter-80888b4ee02e3e409e5f71cf97a36450 class=toggle>
<label class="icon cursor" for=chapter-80888b4ee02e3e409e5f71cf97a36450><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/kernelconfig/>Capítulo 8. Configurando o kernel do FreeBSD</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/kernelconfig/#kernelconfig-synopsis>8.1. Sinopse</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/kernelconfig/#kernelconfig-custom-kernel>8.2. Por que compilar um kernel personalizado?</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/kernelconfig/#kernelconfig-devices>8.3. Encontrando o hardware do sistema</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/kernelconfig/#kernelconfig-config>8.4. O Arquivo de Configuração</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/kernelconfig/#kernelconfig-building>8.5. Criando e Instalando um Kernel Customizado</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/kernelconfig/#kernelconfig-trouble>8.6. Se algo der errado</a></li></ul></li><li><input type=checkbox id=chapter-cb174c55879b17ab955f2f16989a79e0 class=toggle>
<label class="icon cursor" for=chapter-cb174c55879b17ab955f2f16989a79e0><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/printing/>Capítulo 9. Impressão</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/printing/#printing-quick-start>9.1. Inicio Rápido</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/printing/#printing-connections>9.2. Conexões de Impressora</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/printing/#printing-pdls>9.3. Linguagens de Descrição de Página Comuns</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/printing/#printing-direct>9.4. Impressão Direta</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/printing/#printing-lpd>9.5. LPD (Daemon de impressora de linha)</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/printing/#printing-other>9.6. Outros sistemas de impressão</a></li></ul></li><li><input type=checkbox id=chapter-c12b8c3f2a8fcefce87087241f695c83 class=toggle>
<label class="icon cursor" for=chapter-c12b8c3f2a8fcefce87087241f695c83><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/linuxemu/>Capítulo 10. Compatibilidade binária com o Linux®</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/linuxemu/#linuxemu-synopsis>10.1. Sinopse</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/linuxemu/#linuxemu-lbc-install>10.2. Configurando a compatibilidade binária com o Linux™</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/linuxemu/#linuxemu-advanced>10.3. Tópicos Avançados</a></li></ul></li><li><input type=checkbox id=chapter-03b11ba627b9a0c85b247f5641bde272 class=toggle>
<label for=chapter-03b11ba627b9a0c85b247f5641bde272><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/partiii/>Parte III. Administração do Sistema</a></li><li><input type=checkbox id=chapter-6c31587f8d736319f099cd4dc1961301 class=toggle>
<label class="icon cursor" for=chapter-6c31587f8d736319f099cd4dc1961301><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/config/>Capítulo 11. Configuração e Ajuste</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/config/#config-synopsis>11.1. Sinopse</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/config/#configtuning-starting-services>11.2. Inicialização de Serviços</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/config/#configtuning-cron>11.3. Configurando o cron(8)</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/config/#configtuning-rcd>11.4. Gerenciando Serviços no FreeBSD</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/config/#config-network-setup>11.5. Configurando Placas de Interface de Rede</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/config/#configtuning-virtual-hosts>11.6. Hosts Virtuais</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/config/#configtuning-syslog>11.7. Configurando o log do sistema</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/config/#configtuning-configfiles>11.8. Arquivos de Configuração</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/config/#configtuning-sysctl>11.9. Efetuando ajustes com o sysctl(8)</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/config/#configtuning-disk>11.10. Otimização de Discos</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/config/#configtuning-kernel-limits>11.11. Ajustando os Limites do Kernel</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/config/#adding-swap-space>11.12. Adicionando Espaço de Swap</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/config/#acpi-overview>11.13. Gerenciamento de energia e recursos</a></li></ul></li><li><input type=checkbox id=chapter-459f0012b3b4f0b6b123010f029da5e4 class=toggle>
<label class="icon cursor" for=chapter-459f0012b3b4f0b6b123010f029da5e4><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/boot/>Capítulo 12. O processo de inicialização do FreeBSD</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/boot/#boot-synopsis>12.1. Sinopse</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/boot/#boot-introduction>12.2. Processo de Inicialização do FreeBSD</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/boot/#boot-splash>12.3. Configurando telas iniciais de inicialização</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/boot/#device-hints>12.4. Sugestões de dispositivos</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/boot/#boot-shutdown>12.5. Sequência de Desligamento</a></li></ul></li><li><input type=checkbox id=chapter-917c75fcffbb14d48ed6d0a48e7028f2 class=toggle>
<label class="icon cursor" for=chapter-917c75fcffbb14d48ed6d0a48e7028f2><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/security/>Capítulo 13. Segurança</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/security/#security-synopsis>13.1. Sinopse</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/security/#security-intro>13.2. Introdução</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/security/#one-time-passwords>13.3. Senhas de Uso Unico</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/security/#tcpwrappers>13.4. TCP Wrapper</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/security/#kerberos5>13.5. Kerberos</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/security/#openssl>13.6. OpenSSL</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/security/#ipsec>13.7. VPN Sobre IPsec</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/security/#openssh>13.8. OpenSSH</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/security/#fs-acl>13.9. Listas de Controle de Acesso</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/security/#security-pkg>13.10. Monitorando Problemas de Segurança de Terceiros</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/security/#security-advisories>13.11. Avisos de Segurança do FreeBSD</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/security/#security-accounting>13.12. Auditoria de Processo</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/security/#security-resourcelimits>13.13. Limites de Recursos</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/security/#security-sudo>13.14. Administração Compartilhada com Sudo</a></li></ul></li><li><input type=checkbox id=chapter-1a2a8e719703649c2c66d99aa7a25fd4 class=toggle>
<label class="icon cursor" for=chapter-1a2a8e719703649c2c66d99aa7a25fd4><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/jails/>Capítulo 14. Jails</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/jails/#jails-synopsis>14.1. Sinopse</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/jails/#jails-terms>14.2. Termos Relacionados à Jails</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/jails/#jails-build>14.3. Criando e Controlando Jails</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/jails/#jails-tuning>14.4. Tuning e Administração</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/jails/#jails-application>14.5. Atualizando Múltiplas Jails</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/jails/#jails-ezjail>14.6. Gerenciando Jails com o ezjail</a></li></ul></li><li><input type=checkbox id=chapter-8f4620c77e572cbb58917911a33c73cf class=toggle>
<label class="icon cursor" for=chapter-8f4620c77e572cbb58917911a33c73cf><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/mac/>Capítulo 15. Controle de acesso obrigatório</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/mac/#mac-synopsis>15.1. Sinopse</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/mac/#mac-inline-glossary>15.2. Termos chave</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/mac/#mac-understandlabel>15.3. Entendendo os rótulos MAC</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/mac/#mac-planning>15.4. Planejando a configuração de segurança</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/mac/#mac-policies>15.5. Políticas MAC Disponíveis</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/mac/#mac-userlocked>15.6. Bloqueio do Usuário</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/mac/#mac-implementing>15.7. Nagios em Jail MAC</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/mac/#mac-troubleshoot>15.8. Solução de problemas do framework MAC</a></li></ul></li><li><input type=checkbox id=chapter-9598d66a76cb3182057b6bcd775149a0 class=toggle>
<label class="icon cursor" for=chapter-9598d66a76cb3182057b6bcd775149a0><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/audit/>Capítulo 16. Auditoria de Evento de Segurança</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/audit/#audit-synopsis>16.1. Sinopse</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/audit/#audit-inline-glossary>16.2. Termos chave</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/audit/#audit-config>16.3. Configuração de Auditoria</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/audit/#audit-administration>16.4. Trabalhando com Trilhas de Auditoria</a></li></ul></li><li><input type=checkbox id=chapter-e1edcad13d9db6e8e4cb645d378ecfaf class=toggle>
<label class="icon cursor" for=chapter-e1edcad13d9db6e8e4cb645d378ecfaf><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/disks/>Capítulo 17. Armazenamento</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/disks/#disks-synopsis>17.1. Sinopse</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/disks/#disks-adding>17.2. Adicionando Discos</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/disks/#disks-growing>17.3. Redimensionando e Ampliando Discos</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/disks/#usb-disks>17.4. Dispositivos de Armazenamento USB</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/disks/#creating-cds>17.5. Criando e Usando Mídia em CD</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/disks/#creating-dvds>17.6. Criando e Usando Mídia de DVD</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/disks/#floppies>17.7. Criando e Usando Disquetes</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/disks/#backup-basics>17.8. Noções Básicas de Backup</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/disks/#disks-virtual>17.9. Discos de Memória</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/disks/#snapshots>17.10. Snapshots de Sistemas de Arquivos</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/disks/#quotas>17.11. Cotas de Disco</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/disks/#disks-encrypting>17.12. Criptografando Partições de Disco</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/disks/#swap-encrypting>17.13. Criptografando Swap</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/disks/#disks-hast>17.14. Alta Disponibilidade de Armazenamento (HAST)</a></li></ul></li><li><input type=checkbox id=chapter-dde37901a0e0ea32745b67607854900f class=toggle>
<label class="icon cursor" for=chapter-dde37901a0e0ea32745b67607854900f><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/geom/>Capítulo 18. GEOM: Framework de Transformação de Disco Modular</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/geom/#geom-synopsis>18.1. Sinopse</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/geom/#geom-striping>18.2. RAID0 - Striping</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/geom/#geom-mirror>18.3. RAID1 - Espelhamento</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/geom/#geom-raid3>18.4. RAID3 - Distribuição em Nível de Byte com Paridade Dedicada</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/geom/#geom-graid>18.5. Dispositivos RAID por Software</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/geom/#geom-ggate>18.6. GEOM Network Gate</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/geom/#geom-glabel>18.7. Rotulando Dispositivos de Disco</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/geom/#geom-gjournal>18.8. Journaling UFS através do GEOM</a></li></ul></li><li><input type=checkbox id=chapter-73e82560fcb7145b7c0e2ec47af8fc04 class=toggle>
<label class="icon cursor" for=chapter-73e82560fcb7145b7c0e2ec47af8fc04><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/zfs/>Capítulo 19. O sistema de arquivos Z (ZFS)</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/zfs/#zfs-differences>19.1. O que torna o ZFS diferente</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/zfs/#zfs-quickstart>19.2. Guia de Início Rápido</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/zfs/#zfs-zpool>19.3. Administração <code>zpool</code></a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/zfs/#zfs-zfs>19.4. Administração do <code>zfs</code></a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/zfs/#zfs-zfs-allow>19.5. Administração Delegada</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/zfs/#zfs-advanced>19.6. Tópicos Avançados</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/zfs/#zfs-links>19.7. Recursos adicionais</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/zfs/#zfs-term>19.8. Recursos e terminologia do ZFS</a></li></ul></li><li><input type=checkbox id=chapter-7af71270807eb7b70cd3eedc6577b254 class=toggle>
<label class="icon cursor" for=chapter-7af71270807eb7b70cd3eedc6577b254><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/filesystems/>Capítulo 20. Outros Sistemas de Arquivos</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/filesystems/#filesystems-synopsis>20.1. Sinopse</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/filesystems/#filesystems-linux>20.2. Sistemas de arquivos do Linux™</a></li></ul></li><li><input type=checkbox id=chapter-375257268d95faaf87faf4f7a2e6aa67 class=toggle>
<label class="icon cursor" for=chapter-375257268d95faaf87faf4f7a2e6aa67><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/virtualization/>Capítulo 21. Virtualização</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/virtualization/#virtualization-synopsis>21.1. Sinopse</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/virtualization/#virtualization-guest-parallels>21.2. FreeBSD como Sistema Operacional Convidado no Parallels para Mac OS™ X</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/virtualization/#virtualization-guest-virtualpc>21.3. FreeBSD como sistema convidado no Virtual PC para Windows™</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/virtualization/#virtualization-guest-vmware>21.4. FreeBSD como Sistema Operacional Convidado no VMware Fusion para Mac OS™</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/virtualization/#virtualization-guest-virtualbox>21.5. FreeBSD como Sistema Operacional Convidado no VirtualBox™</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/virtualization/#virtualization-host-virtualbox>21.6. FreeBSD como Host com VirtualBox™</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/virtualization/#virtualization-host-bhyve>21.7. FreeBSD como um Host bhyve</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/virtualization/#virtualization-host-xen>21.8. FreeBSD como Host Xen™</a></li></ul></li><li><input type=checkbox id=chapter-49f1e96591c090304ea532012257f4ef class=toggle>
<label class="icon cursor" for=chapter-49f1e96591c090304ea532012257f4ef><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/l10n/>Capítulo 22. Localização - Uso e Configuração do i18n/L10n</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/l10n/#l10n-synopsis>22.1. Sinopse</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/l10n/#using-localization>22.2. Usando Localização</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/l10n/#l10n-compiling>22.3. Encontrando Aplicações i18n</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/l10n/#lang-setup>22.4. Configuração de Localização para Idiomas Específicos</a></li></ul></li><li><input type=checkbox id=chapter-dead2b4c5ea325dd390a9b0dccd8f763 class=toggle>
<label class="icon cursor" for=chapter-dead2b4c5ea325dd390a9b0dccd8f763><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/cutting-edge/>Capítulo 23. Atualização e Upgrade do FreeBSD</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/cutting-edge/#updating-upgrading-synopsis>23.1. Sinopse</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/cutting-edge/#updating-upgrading-freebsdupdate>23.2. Atualização do FreeBSD</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/cutting-edge/#updating-upgrading-documentation>23.3. Atualizando o Conjunto de Documentação</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/cutting-edge/#current-stable>23.4. Acompanhando um ramo de desenvolvimento</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/cutting-edge/#makeworld>23.5. Atualizando o FreeBSD a partir do código fonte</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/cutting-edge/#small-lan>23.6. Atualização de várias máquinas</a></li></ul></li><li><input type=checkbox id=chapter-29c1eeb0e9dedc487a98399e2737ee8a class=toggle>
<label class="icon cursor" for=chapter-29c1eeb0e9dedc487a98399e2737ee8a><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/dtrace/>Chapter 24. DTrace</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/dtrace/#dtrace-synopsis>24.1. Sinopse</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/dtrace/#dtrace-implementation>24.2. Diferenças de Implementação</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/dtrace/#dtrace-enable>24.3. Ativando o Suporte do DTrace</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/dtrace/#dtrace-using>24.4. Usando o DTrace</a></li></ul></li><li><input type=checkbox id=chapter-913e72bfb3d6947b2869d3e9447a6eaa class=toggle>
<label class="icon cursor" for=chapter-913e72bfb3d6947b2869d3e9447a6eaa><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/usb-device-mode/>Capítulo 25. Modo de dispositivo USB/USB OTG</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/usb-device-mode/#usb-device-mode-synopsis>25.1. Sinopse</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/usb-device-mode/#usb-device-mode-terminals>25.2. Portas Seriais Virtuais USB</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/usb-device-mode/#usb-device-mode-network>25.3. Interfaces de rede do modo de dispositivo USB</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/usb-device-mode/#usb-device-mode-storage>25.4. Dispositivo de armazenamento virtual USB</a></li></ul></li><li><input type=checkbox id=chapter-bbd25f9a194f9c39ca2d658c75767db5 class=toggle>
<label for=chapter-bbd25f9a194f9c39ca2d658c75767db5><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/partiv/>Parte IV. Comunicação de rede</a></li><li><input type=checkbox id=chapter-499dab596afd7ddac77e80295314e0dd class=toggle>
<label class="icon cursor" for=chapter-499dab596afd7ddac77e80295314e0dd><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/serialcomms/>Capítulo 26. Comunicações Seriais</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/serialcomms/#serial-synopsis>26.1. Sinopse</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/serialcomms/#serial>26.2. Terminologia serial e hardware</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/serialcomms/#term>26.3. Terminais</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/serialcomms/#dialup>26.4. Serviço Dial-in</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/serialcomms/#dialout>26.5. Serviço de Dial-in</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/serialcomms/#serialconsole-setup>26.6. Configurando o Console Serial</a></li></ul></li><li><input type=checkbox id=chapter-95e4571c48bee1cced5e84a538d302e3 class=toggle>
<label class="icon cursor" for=chapter-95e4571c48bee1cced5e84a538d302e3><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/ppp-and-slip/>Capítulo 27. PPP</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/ppp-and-slip/#ppp-and-slip-synopsis>27.1. Sinopse</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/ppp-and-slip/#userppp>27.2. Configurando o PPP</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/ppp-and-slip/#ppp-troubleshoot>27.3. Solução de problemas de conexões PPP</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/ppp-and-slip/#pppoe>27.4. Usando o PPP sobre Ethernet (PPPoE)</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/ppp-and-slip/#pppoa>27.5. Usando PPP sobre ATM (PPPoA)</a></li></ul></li><li><input type=checkbox id=chapter-f089ac726c401c9b4bd5c34a295e11bb class=toggle>
<label class="icon cursor" for=chapter-f089ac726c401c9b4bd5c34a295e11bb><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/mail/>Capítulo 28. Correio Eletrônico</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/mail/#mail-synopsis>28.1. Sinopse</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/mail/#mail-using>28.2. Componentes de Email</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/mail/#sendmail>28.3. Arquivos de Configuração do Sendmail</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/mail/#mail-changingmta>28.4. Alterando o Mail Transfer Agent</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/mail/#mail-trouble>28.5. Solução de problemas</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/mail/#mail-advanced>28.6. Tópicos Avançados</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/mail/#outgoing-only>28.7. Configurando Apenas Envio</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/mail/#SMTP-dialup>28.8. Usando Email com uma Conexão Dialup</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/mail/#SMTP-Auth>28.9. Autenticação SMTP</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/mail/#mail-agents>28.10. Mail User Agents</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/mail/#mail-fetchmail>28.11. Usando o fetchmail</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/mail/#mail-procmail>28.12. Usando o procmail</a></li></ul></li><li><input type=checkbox id=chapter-6de4de3fe925639d4175ce4b6f8c1829 class=toggle>
<label class="icon cursor" for=chapter-6de4de3fe925639d4175ce4b6f8c1829><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/network-servers/>Capítulo 29. Servidores de Rede</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/network-servers/#network-servers-synopsis>29.1. Sinopse</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/network-servers/#network-inetd>29.2. O super-servidor inetd</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/network-servers/#network-nfs>29.3. Network File System (NFS)</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/network-servers/#network-nis>29.4. Sistema de Informação de Rede (NIS)</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/network-servers/#network-ldap>29.5. Protocolo leve de acesso de diretório ( LDAP )</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/network-servers/#network-dhcp>29.6. Protocolo de configuração dinâmica de hosts (DHCP)</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/network-servers/#network-dns>29.7. Sistema de Nomes de Domínio (DNS)</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/network-servers/#network-apache>29.8. Servidor HTTP Apache</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/network-servers/#network-ftp>29.9. Protocolo de Transferência de Arquivos (FTP)</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/network-servers/#network-samba>29.10. Serviços de arquivos e impressão para clientes Microsoft™Windows™ Clients (Samba)</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/network-servers/#network-ntp>29.11. Sincronização de Relógio com NTP</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/network-servers/#network-iscsi>29.12. Inicializador iSCSI e Configuração Alvo</a></li></ul></li><li><input type=checkbox id=chapter-776d855c7b75e048f90b5c2c9b35ffe0 class=toggle>
<label class="icon cursor" for=chapter-776d855c7b75e048f90b5c2c9b35ffe0><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/firewalls/>Capítulo 30. Firewalls</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/firewalls/#firewalls-intro>30.1. Sinopse</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/firewalls/#firewalls-concepts>30.2. Conceitos de Firewall</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/firewalls/#firewalls-pf>30.3. PF</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/firewalls/#firewalls-ipfw>30.4. IPFW</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/firewalls/#firewalls-ipf>30.5. IPFILTER (IPF)</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/firewalls/#firewalls-blacklistd>30.6. Blacklistd</a></li></ul></li><li><input type=checkbox id=chapter-5b07f776a0e6155c1c89aa0d15610380 class=toggle checked>
<label class="icon cursor" for=chapter-5b07f776a0e6155c1c89aa0d15610380><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/advanced-networking/>Capítulo 31. Rede Avançada</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/advanced-networking/#advanced-networking-synopsis>31.1. Sinopse</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/advanced-networking/#network-routing>31.2. Gateways e Rotas</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/advanced-networking/#network-wireless>31.3. Rede sem fio</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/advanced-networking/#network-usb-tethering>31.4. USB Tethering</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/advanced-networking/#network-bluetooth>31.5. Bluetooth</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/advanced-networking/#network-bridging>31.6. Bridging</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/advanced-networking/#network-aggregation>31.7. Agregação de links e failover</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/advanced-networking/#network-diskless>31.8. Operação Diskless com PXE</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/advanced-networking/#network-ipv6>31.9. IPv6</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/advanced-networking/#carp>31.10. Protocolo Comum de Redundância de Endereços (CARP)</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/advanced-networking/#network-vlan>31.11. VLANs</a></li></ul></li><li><input type=checkbox id=chapter-171a77aa9d067a1024f849470e1f33e8 class=toggle>
<label for=chapter-171a77aa9d067a1024f849470e1f33e8><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/partv/>Parte V. Apêndices</a></li><li><input type=checkbox id=chapter-8050f436a0a7986a4aaded93d8e49469 class=toggle>
<label class="icon cursor" for=chapter-8050f436a0a7986a4aaded93d8e49469><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/mirrors/>Apêndice A. Obtendo o FreeBSD</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/mirrors/#mirrors-cdrom>A.1. CD and DVD Sets</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/mirrors/#mirrors-ftp>A.2. Sites de FTP</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/mirrors/#svn>A.3. Usando o Subversion</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/mirrors/#mirrors-rsync>A.4. Usando o rsync</a></li></ul></li><li><input type=checkbox id=chapter-128b630a8f88f158e7027fe6c2184d21 class=toggle>
<label class="icon cursor" for=chapter-128b630a8f88f158e7027fe6c2184d21><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/bibliography/>Apêndice B. Bibliografia</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/bibliography/#bibliography-freebsd>B.1. Livros específicos para o FreeBSD</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/bibliography/#bibliography-userguides>B.2. Guias de usuários</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/bibliography/#bibliography-adminguides>B.3. Guias de Administradores</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/bibliography/#bibliography-programmers>B.4. Guias de programadores</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/bibliography/#bibliography-osinternals>B.5. Internals do sistema operacional</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/bibliography/#bibliography-security>B.6. Referências de segurança</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/bibliography/#bibliography-hardware>B.7. Referências de Hardware</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/bibliography/#bibliography-history>B.8. História do UNIX™</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/bibliography/#bibliography-journals>B.9. Periódicos, Jornais e Revistas</a></li></ul></li><li><input type=checkbox id=chapter-8bbb8867c46dac315e2253945d8c18a8 class=toggle>
<label class="icon cursor" for=chapter-8bbb8867c46dac315e2253945d8c18a8><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/eresources/>Apêndice C. Recursos na Internet</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/eresources/#eresources-www>C.1. Websites</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/eresources/#eresources-mail>C.2. Listas de Discussão</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/eresources/#eresources-news>C.3. Grupos de Notícias Usenet</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/eresources/#eresources-web>C.4. Espelhos Oficiais</a></li></ul></li><li><input type=checkbox id=chapter-a80ea4f5a4480b8725422710f954ef36 class=toggle>
<label class="icon cursor" for=chapter-a80ea4f5a4480b8725422710f954ef36><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/pgpkeys/>Apêndice D. Chaves OpenPGP</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/pgpkeys/#pgpkeys-officers>D.1. Administradores</a></li></ul></li><li></li></ul></nav></div></aside><div class=book><div class=book-menu-mobile><label for=menu-control><span class=menu-control-button><i class="fa fa-list" aria-hidden=true title=Menu></i>
Menu</span></label></div><h1 class=title>Capítulo 31. Rede Avançada</h1><div class="admonitionblock note"><p><i class="fa fa-exclamation-circle" aria-hidden=true></i>
Esta tradução pode estar desatualizada. Para ajudar com as traduções, acesse a <a href=https://translate-dev.freebsd.org/ target=_blank>ferramenta de traduções do FreeBSD</a>.</p></div><div class=toc-mobile><h3>Índice</h3><nav id=TableOfContents><ul><li><a href=#advanced-networking-synopsis>31.1. Sinopse</a></li><li><a href=#network-routing>31.2. Gateways e Rotas</a></li><li><a href=#network-wireless>31.3. Rede sem fio</a></li><li><a href=#network-usb-tethering>31.4. USB Tethering</a></li><li><a href=#network-bluetooth>31.5. Bluetooth</a></li><li><a href=#network-bridging>31.6. Bridging</a></li><li><a href=#network-aggregation>31.7. Agregação de links e failover</a></li><li><a href=#network-diskless>31.8. Operação Diskless com PXE</a></li><li><a href=#network-ipv6>31.9. IPv6</a></li><li><a href=#carp>31.10. Protocolo Comum de Redundância de Endereços (CARP)</a></li><li><a href=#network-vlan>31.11. VLANs</a></li></ul></nav></div><div class=book-content><div id=preamble><div class=sectionbody></div></div><div class=sect1><h2 id=advanced-networking-synopsis>31.1. Sinopse<a class=anchor href=#advanced-networking-synopsis></a></h2><div class=sectionbody><div class=paragraph><p>Este capítulo aborda vários tópicos avançados de rede.</p></div><div class=paragraph><p>Depois de ler este capítulo, você saberá:</p></div><div class=ulist><ul><li><p>O básico de gateways e rotas.</p></li><li><p>Como configurar o USB tethering.</p></li><li><p>Como configurar os dispositivos IEEE™ 802.11 e Bluetooth™.</p></li><li><p>Como fazer o FreeBSD atuar como uma Bridge.</p></li><li><p>Como configurar a inicialização via PXE na rede.</p></li><li><p>Como configurar o IPv6 em uma máquina FreeBSD.</p></li><li><p>Como habilitar e utilizar os recursos do Protocolo CARP (Common Address Redundancy Protocol) no FreeBSD.</p></li><li><p>Como configurar múltiplas VLANs no FreeBSD.</p></li><li><p>Como configurar um fone de ouvido bluetooth.</p></li></ul></div><div class=paragraph><p>Antes de ler este capítulo, você deve:</p></div><div class=ulist><ul><li><p>Entender os fundamentos dos scripts <span class=filename>/etc/rc</span>.</p></li><li><p>Estar familiarizado com a terminologia básica de rede.</p></li><li><p>Saber como configurar e instalar um novo kernel do FreeBSD (<a href=../kernelconfig/#kernelconfig>Configurando o kernel do FreeBSD</a>).</p></li><li><p>Saber como instalar software adicional de terceiros (<a href=../ports/#ports>Instalando Aplicativos. Pacotes e Ports</a>).</p></li></ul></div></div></div><div class=sect1><h2 id=network-routing>31.2. Gateways e Rotas<a class=anchor href=#network-routing></a></h2><div class=sectionbody><div class=paragraph><p>O <em>roteamento</em> é o mecanismo que permite que um sistema encontre o caminho da rede para outro sistema. Uma <em>rota</em> é um par definido de endereços que representam o "destino" e um "gateway". A rota indica que, ao tentar chegar ao destino especificado, você deverá enviar os pacotes pelo gateway especificado. Existem três tipos de destinos: hosts individuais, sub-redes e "padrão". A "rota padrão" é usada se nenhuma outra rota for aplicada. Existem também três tipos de gateways: hosts individuais, interfaces, também chamados de links, e endereços de hardware Ethernet (MAC). Rotas conhecidas são armazenadas em uma tabela de roteamento.</p></div><div class=paragraph><p>Esta seção fornece uma visão geral dos fundamentos de roteamento. Em seguida, ele demonstra como configurar um sistema FreeBSD como um roteador e oferece algumas dicas de solução de problemas.</p></div><div class=sect2><h3 id=network-routing-default>31.2.1. Fundamentos de roteamento<a class=anchor href=#network-routing-default></a></h3><div class=paragraph><p>Para ver a tabela de roteamento de um sistema FreeBSD, use <a href="https://man.freebsd.org/cgi/man.cgi?query=netstat&amp;sektion=1&amp;format=html">netstat(1)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% netstat <span class=nt>-r</span>
Routing tables

Internet:
Destination      Gateway            Flags     Refs     Use     Netif Expire
default          outside-gw         UGS        37      418       em0
localhost        localhost          UH          0      181       lo0
test0            0:e0:b5:36:cf:4f   UHLW        5    63288       re0     77
10.20.30.255     <span class=nb>link</span><span class=c>#1             UHLW        1     2421</span>
example.com      <span class=nb>link</span><span class=c>#1             UC          0        0</span>
host1            0:e0:a8:37:8:1e    UHLW        3     4601       lo0
host2            0:e0:a8:37:8:1e    UHLW        0        5       lo0 <span class=o>=&gt;</span>
host2.example.com <span class=nb>link</span><span class=c>#1            UC          0        0</span>
224              <span class=nb>link</span><span class=c>#1             UC          0        0</span></code></pre></div></div><div class=paragraph><p>As entradas neste exemplo são as seguintes:</p></div><div class=dlist><dl><dt class=hdlist1>padrão</dt><dd><p>A primeira rota nesta tabela especifica a rota <code>padrão</code>. Quando o sistema local precisa estabelecer uma conexão com um host remoto, ele verifica a tabela de roteamento para determinar se existe um caminho conhecido. Se o host remoto corresponder a uma entrada na tabela, o sistema verificará se pode se conectar usando a interface especificada nessa entrada.</p><div class=paragraph><p>Se o destino não corresponder a uma entrada ou se todos os caminhos conhecidos falharem, o sistema usará a entrada para a rota padrão. Para hosts em uma rede local, o campo <code>Gateway</code> na rota padrão é definido para o sistema que possui uma conexão direta com a internet. Ao ler esta entrada, verifique se a coluna <code>Flags</code> indica que o gateway é utilizável (<code>UG</code>).</p></div><div class=paragraph><p>A rota padrão para uma máquina que está funcionando como gateway para o mundo externo será a máquina de gateway no provedor de serviços de Internet (ISP).</p></div></dd><dt class=hdlist1>localhost</dt><dd><p>A segunda rota é a <code>localhost</code>. A interface especificada na coluna <code>Netif</code> para <code>localhost</code> é <span class=filename>lo0</span>, também conhecido como o dispositivo de loopback. Isso indica que todo o tráfego para esse destino deve ser interno, em vez de enviá-lo pela rede.</p></dd><dt class=hdlist1>Endereço MAC</dt><dd><p>Os endereços que começam com <code>0:e0:</code> são endereços de MAC. O FreeBSD irá identificar automaticamente quaisquer hosts, <code>test0</code> no exemplo, na Ethernet local e adicionará uma rota para aquele host através da interface Ethernet, <span class=filename>re0</span>. Esse tipo de rota tem um tempo limite, visto na coluna <code>Expire</code>, que é usada se o host não responder em um período de tempo específico. Quando isso acontecer, a rota para esse host será automaticamente excluída. Esses hosts são identificados usando o protocolo de informações de roteamento (RIP), que calcula rotas para hosts locais com base em uma determinação de caminho mais curto.</p></dd><dt class=hdlist1>sub-rede</dt><dd><p>O FreeBSD irá adicionar automaticamente rotas de sub-rede para a sub-rede local. Neste exemplo, <code>10.20.30.255</code> é o endereço de broadcast da sub-rede <code>10.20.30</code> e <code>example.com</code> é o nome de domínio associado a essa sub-rede. A designação <code>link#1</code> refere-se à primeira placa Ethernet na máquina.</p><div class=paragraph><p>Hosts de rede local e sub-redes locais têm suas rotas configuradas automaticamente por um daemon chamado <a href="https://man.freebsd.org/cgi/man.cgi?query=routed&amp;sektion=8&amp;format=html">routed(8)</a>. Se ele não estiver em execução, somente as rotas definidas estaticamente pelo administrador existirão.</p></div></dd><dt class=hdlist1>host</dt><dd><p>A linha <code>host1</code> refere-se ao host pelo seu endereço Ethernet. Como é o host de envio, o FreeBSD sabe usar a interface de loopback (<span class=filename>lo0</span>) em vez da interface Ethernet.</p><div class=paragraph><p>As duas linhas <code>host2</code> representam os aliases que foram criados usando <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a>. O símbolo <code>⇒</code> após a interface <span class=filename>lo0</span> diz que um alias foi definido além do endereço de loopback. Tais rotas só aparecem no host que suporta o alias e todos os outros hosts na rede local terão uma linha <code>link#1</code> para tais rotas.</p></div></dd><dt class=hdlist1>224</dt><dd><p>A linha final (destino subnet <code>224</code>) lida com multicasting.</p></dd></dl></div><div class=paragraph><p>Vários atributos de cada rota podem ser vistos na coluna <code>Flags</code>. A <a href=#routeflags>Flags da Tabela de Roteamento Frequentemente Observados</a> resume algumas destas flags e seus significados:</p></div><table id=routeflags class="tableblock frame-none grid-all stretch"><caption class=title>Tabela 1. Flags da Tabela de Roteamento Frequentemente Observados</caption><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Comando</th><th class="tableblock halign-left valign-top">Propósito</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>U</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>A rota está ativa (up).</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>H</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>O destino da rota é um único host.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>G</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Envie qualquer coisa para este destino por este gateway, que ele irá descobrir a partir daí para onde enviá-lo.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>S</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Esta rota foi configurada estaticamente.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>C</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Clona uma nova rota baseada nessa rota para as máquinas se conectarem. Esse tipo de rota é normalmente usado para redes locais.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>W</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>A rota foi configurada automaticamente com base em uma rota de rede local (clone).</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>L</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>A rota envolve referências a um hardware Ethernet (link).</p></td></tr></tbody></table><div class=paragraph><p>Em um sistema FreeBSD, a rota padrão pode ser definida no <span class=filename>/etc/rc.conf</span> especificando o endereço IP do gateway padrão:</p></div><div class="literalblock programlisting"><div class=content><pre>defaultrouter=&#34;10.20.30.1&#34;</pre></div></div><div class=paragraph><p>Também é possível adicionar manualmente a rota usando o comando <code>route</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># route add default 10.20.30.1</span></code></pre></div></div><div class=paragraph><p>Observe que as rotas adicionadas manualmente não sobreviverão a uma reinicialização. Para obter mais informações sobre a manipulação manual das tabelas de roteamento de rede, consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=route&amp;sektion=8&amp;format=html">route(8)</a>.</p></div></div><div class=sect2><h3 id=network-static-routes>31.2.2. Configurando um roteador com rotas estáticas<a class=anchor href=#network-static-routes></a></h3><div class=paragraph><p>Um sistema FreeBSD pode ser configurado como o gateway padrão, ou roteador, para uma rede se for um sistema dual-homed. Um sistema dual-homed é um host que reside em pelo menos duas redes diferentes. Normalmente, cada rede é conectada a uma interface de rede separada, embora o aliasing IP possa ser usado para vincular vários endereços, cada um em uma sub-rede diferente, a uma interface física.</p></div><div class=paragraph><p>Para que o sistema encaminhe os pacotes entre as interfaces, o FreeBSD deve ser configurado como um roteador. Padrões da Internet e boas práticas de engenharia impedem o Projeto FreeBSD de habilitar esse recurso por padrão, mas ele pode ser configurado para iniciar na inicialização adicionando esta linha ao <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>gateway_enable=&#34;YES&#34;          # Set to YES if this host will be a gateway</pre></div></div><div class=paragraph><p>Para habilitar o roteamento agora, defina a variável <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a><code>net.inet.ip.forwarding</code> para <code>1</code>. Para parar o roteamento, redefina essa variável para <code>0</code>.</p></div><div class=paragraph><p>A tabela de roteamento de um roteador precisa de rotas adicionais para saber como acessar outras redes. Rotas podem ser adicionadas manualmente usando rotas estáticas ou rotas podem ser aprendidas automaticamente usando um protocolo de roteamento. As rotas estáticas são apropriadas para redes pequenas e esta seção descreve como adicionar uma entrada de roteamento estático para uma rede pequena.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Para grandes redes, as rotas estáticas se tornam não escaláveis rapidamente. O FreeBSD vem com o daemon de roteamento BSD padrão <a href="https://man.freebsd.org/cgi/man.cgi?query=routed&amp;sektion=8&amp;format=html">routed(8)</a>, que fornece os protocolos de roteamento RIP, versões 1 e 2 e IRDP. O suporte para os protocolos de roteamento BGP e OSPF pode ser instalado usando o pacote ou port <a class=package href=https://cgit.freebsd.org/ports/tree/net/zebra/>net/zebra</a>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Considere a seguinte rede:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/advanced-networking/static-routes.png alt="static routes"></div></div><div class=paragraph><p>Neste cenário, o <code>RouterA</code> é uma máquina FreeBSD que está agindo como um roteador para o resto da Internet. Ele tem uma rota padrão definida como <code>10.0.0.1</code>, que permite a conexão com o mundo externo. O <code>RouterB</code> já está configurado para usar <code>192.168.1.1</code> como seu gateway padrão.</p></div><div class=paragraph><p>Antes de adicionar rotas estáticas, a tabela de roteamento no <code>RouterA</code> se parece com:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% netstat <span class=nt>-nr</span>
Routing tables

Internet:
Destination        Gateway            Flags    Refs      Use  Netif  Expire
default            10.0.0.1           UGS         0    49378    xl0
127.0.0.1          127.0.0.1          UH          0        6    lo0
10.0.0.0/24        <span class=nb>link</span><span class=c>#1             UC          0        0    xl0</span>
192.168.1.0/24     <span class=nb>link</span><span class=c>#2             UC          0        0    xl1</span></code></pre></div></div><div class=paragraph><p>Com a tabela de roteamento atual, o <code>RouterA</code> não tem uma rota para a rede <code>192.168.2.0/24</code>. O comando a seguir adiciona a rede <code>Internal Net 2</code> à tabela de roteamento do <code>RouterA</code> usando <code>192.168.1.2</code> como o próximo salto:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># route add -net 192.168.2.0/24 192.168.1.2</span></code></pre></div></div><div class=paragraph><p>Agora, o <code>RouterA</code> pode alcançar qualquer host na rede <code>192.168.2.0/24</code>. No entanto, as informações de roteamento não persistirão se o sistema FreeBSD for reinicializado. Se uma rota estática precisar ser persistente, adicione-a ao <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre># Add Internal Net 2 as a persistent static route
static_routes=&#34;internalnet2&#34;
route_internalnet2=&#34;-net 192.168.2.0/24 192.168.1.2&#34;</pre></div></div><div class=paragraph><p>A variável de configuração <code>static_routes</code> é uma lista de strings separadas por um espaço, onde cada string faz referência a um nome de rota. A variável <code>route_internalnet2</code> contém a rota estática para esse nome de rota.</p></div><div class=paragraph><p>Usar mais de uma string em <code>static_routes</code> cria várias rotas estáticas. A seguir, é mostrado um exemplo de adição de rotas estáticas para as redes <code>192.168.0.0/24</code> e <code>192.168.1.0/24</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>static_routes=&#34;net1 net2&#34;
route_net1=&#34;-net 192.168.0.0/24 192.168.0.1&#34;
route_net2=&#34;-net 192.168.1.0/24 192.168.1.1&#34;</pre></div></div></div><div class=sect2><h3 id=network-routing-troubleshooting>31.2.3. Solução de problemas<a class=anchor href=#network-routing-troubleshooting></a></h3><div class=paragraph><p>Quando um espaço de endereçamento é atribuído a uma rede, o provedor de serviços configura suas tabelas de roteamento para que todo o tráfego da rede seja enviado para o link do site. Mas como os sites externos sabem enviar seus pacotes para a rede do ISP?</p></div><div class=paragraph><p>Existe um sistema que rastreia todos os espaços de endereçamento e define seu ponto de conexão com o backbone da Internet, ou as principais linhas que transportam o tráfego da Internet pelo país e pelo mundo. Cada máquina de backbone possui uma cópia de um conjunto mestre de tabelas, que direciona o tráfego de uma rede específica para uma portadora de backbone específica e, a partir daí, desce a cadeia de provedores de serviços até alcançar uma determinada rede.</p></div><div class=paragraph><p>É tarefa do provedor de serviços anunciar aos sites de backbone que eles são o ponto de conexão e, assim, o caminho para dentro de um site. Isso é conhecido como propagação de rota.</p></div><div class=paragraph><p>Às vezes, há um problema com a propagação de rotas e alguns sites não conseguem se conectar. Talvez o comando mais útil para tentar descobrir onde o roteamento está quebrando seja o <code>traceroute</code>. Ele é útil quando o <code>ping</code> falha.</p></div><div class=paragraph><p>Ao usar o <code>traceroute</code>, inclua o endereço do host remoto para se conectar. A saída mostrará os gateway ao longo do caminho da tentativa, eventualmente atingindo o host de destino ou encerrando devido à falta de conexão. Para mais informações, consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=traceroute&amp;sektion=8&amp;format=html">traceroute(8)</a>.</p></div></div><div class=sect2><h3 id=network-routing-multicast>31.2.4. Considerações sobre Multicast<a class=anchor href=#network-routing-multicast></a></h3><div class=paragraph><p>O FreeBSD suporta nativamente tanto aplicativos multicast e quanto roteamento multicast. Os aplicativos multicast não exigem nenhuma configuração especial para serem executados no FreeBSD. O suporte ao roteamento multicast requer que a seguinte opção seja compilada em um kernel personalizado:</p></div><div class="literalblock programlisting"><div class=content><pre>options MROUTING</pre></div></div><div class=paragraph><p>O daemon de roteamento multicast, mrouted, pode ser instalado usando o pacote ou port <a class=package href=https://cgit.freebsd.org/ports/tree/net/mrouted/>net/mrouted</a>. Este daemon implementa o protocolo de roteamento multicast DVMRP e é configurado editando o <span class=filename>/usr/local/etc/mrouted.conf</span> para configurar os túneis e o DVMRP. A instalação do mrouted também instala o map-mbone e o mrinfo, bem como suas páginas de manual associadas. Consulte estes documentos para exemplos de configuração.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>O DVMRP foi amplamente substituído pelo protocolo PIM em muitas instalações multicast. Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=pim&amp;sektion=4&amp;format=html">pim(4)</a> para obter maiores informações.</p></div></td></tr></tbody></table></div></div></div></div><div class=sect1><h2 id=network-wireless>31.3. Rede sem fio<a class=anchor href=#network-wireless></a></h2><div class=sectionbody><div class=sect2><h3 id=_noções_básicas_sobre_redes_sem_fio>31.3.1. Noções básicas sobre redes sem fio<a class=anchor href=#_noções_básicas_sobre_redes_sem_fio></a></h3><div class=paragraph><p>A maioria das redes sem fio é baseada nos padrões IEEE™802.11. Uma rede sem fio básica consiste em várias estações que se comunicam com rádios que transmitem na banda de 2,4 GHz ou 5 GHz, embora isso varie de acordo com a localidade e também esteja mudando para permitir a comunicação nas faixas de 2,3 GHz e 4,9 GHz.</p></div><div class=paragraph><p>As redes 802.11 são organizadas de duas maneiras. No <em>modo de infra-estrutura</em>, uma estação atua como mestre para todas as outras estações que se associam a ela, a rede é conhecida como BSS e a estação mestre é denominada ponto de acesso. (AP). Em um BSS, toda a comunicação passa pelo AP; mesmo quando uma estação deseja se comunicar com outra estação sem fio, as mensagens devem passar pelo AP. Na segunda forma de rede, não há mestre e as estações se comunicam diretamente. Esta forma de rede é denominada IBSS e é comumente conhecida como uma <em>rede ad-hoc</em>.</p></div><div class=paragraph><p>As redes 802.11 foram implantadas pela primeira vez na banda de 2,4 GHz usando protocolos definidos pelo padrão 802.11 e 802.11b da IEEE™. Essas especificações incluem as frequências operacionais e as características da camada MAC, incluindo as taxas de enquadramento e transmissão, pois a comunicação pode ocorrer em várias taxas. Posteriormente, o padrão 802.11a definiu a operação na faixa de 5GHz, incluindo diferentes mecanismos de sinalização e taxas de transmissão mais altas. Mais tarde, o padrão 802.11g definiu o uso de mecanismos de sinalização e transmissão 802.11a na banda de 2,4 GHz de modo a ser compatível com redes 802.11b.</p></div><div class=paragraph><p>Separadas das técnicas de transmissão básicas, as redes 802.11 possuem uma variedade de mecanismos de segurança. As especificações originais do 802.11 definiam um protocolo de segurança simples chamado WEP. Este protocolo usa uma chave pré-compartilhada fixa e a criptografia criptográfica RC4 para codificar dados transmitidos em uma rede. Todas as estações devem concordar com a chave fixa para se comunicar. Esse esquema mostrou-se de fácil quebra e agora raramente é usado, exceto para desencorajar usuários transitórios a se juntarem a uma rede. A prática atual de segurança é dada pela especificação 802.11i do IEEE™ que define novas cifras criptográficas e um protocolo adicional para autenticar estações para um ponto de acesso e para trocar chaves para comunicação de dados. As chaves criptográficas são atualizadas periodicamente e existem mecanismos para detectar e combater tentativas de invasão. Outra especificação de protocolo de segurança comumente usada em redes sem fio é denominada WPA, que foi um precursor do 802.11i. O WPA especifica um subconjunto dos requisitos encontrados no 802.11i e foi projetado para implementação em hardware legado. Especificamente, o WPA requer apenas a codificação TKIP derivada da codificação original WEP. O 802.11i permite o uso do TKIP, mas também requer suporte para uma criptografia mais forte, o AES-CCM, para criptografar os dados. A codificação AES não era exigida no WPA porque foi considerada demasiadamente cara computacionalmente para ser executada em hardware legado.</p></div><div class=paragraph><p>Um outro padrão a se ter em conta é o 802.11e. Ele define protocolos para a implantação de aplicativos multimídia, como streaming de vídeo e voz sobre IP (VoIP), em uma rede 802.11. Como o 802.11i, o 802.11e também tem uma especificação de precursor denominada WME (posteriormente renomeada como WMM) que foi definida por um grupo industrial como um subconjunto do 802.11e que pode ser implantado agora para habilitar aplicativos multimídia enquanto aguarda a ratificação final do 802.11e. O mais importante a saber sobre o 802.11e e o WME/WMM é que ele permite o tráfego prioritário através de uma rede sem fio através de protocolos de Qualidade de Serviço (QoS) e protocolos de acesso de mídia aprimorados. A implementação adequada desses protocolos permite o aumento rápido de dados e o fluxo de tráfego priorizado.</p></div><div class=paragraph><p>O FreeBSD suporta redes que operam usando 802.11a, 802.11b e 802.11g. Os protocolos de segurança WPA e 802.11i também são suportados (em conjunto com qualquer um dos 11a, 11b e 11g) e o QoS e priorização de tráfego exigidos pelo protocolo WME/WMM são suportados por um conjunto limitado de dispositivos sem fio.</p></div></div><div class=sect2><h3 id=network-wireless-quick-start>31.3.2. Inicio Rápido<a class=anchor href=#network-wireless-quick-start></a></h3><div class=paragraph><p>Conectar um computador a uma rede sem fio existente é uma situação muito comum. Este procedimento mostra as etapas necessárias.</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Obtenha o SSID (identificador de conjunto de serviços) e PSK (chave pré-compartilhada) para a rede sem fio do administrador da rede.</p></li><li><p>Identifique o adaptador sem fio. O kernel <span class=filename>GENERIC</span> do FreeBSD inclui drivers para muitos adaptadores sem fio comuns. Se o adaptador sem fio for um desses modelos, ele será mostrado na saída do <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a>:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ifconfig | <span class=nb>grep</span> <span class=nt>-B3</span> <span class=nt>-i</span> wireless</code></pre></div></div><div class=paragraph><p>No FreeBSD 11 ou superior, use este comando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% sysctl net.wlan.devices</code></pre></div></div><div class=paragraph><p>Se um adaptador sem fio não estiver listado, um módulo adicional do kernel pode ser necessário, ou pode ser um modelo não suportado pelo FreeBSD.</p></div><div class=paragraph><p>Este exemplo mostra o adaptador wireless Atheros <code>ath0</code>.</p></div></li><li><p>Adicione uma entrada para esta rede ao <span class=filename>/etc/wpa_supplicant.conf</span>. Se o arquivo não existir, crie-o. Substitua <em>myssid</em> e <em>mypsk</em> pelo SSID e PSK fornecidos pelo administrador da rede.</p><div class="literalblock programlisting"><div class=content><pre>network={
	ssid=&#34;myssid&#34;
	psk=&#34;mypsk&#34;
}</pre></div></div></li><li><p>Adicione entradas ao <span class=filename>/etc/rc.conf</span> para configurar a rede na inicialização:</p><div class="literalblock programlisting"><div class=content><pre>wlans_ath0=&#34;wlan0&#34;
ifconfig_wlan0=&#34;WPA SYNCDHCP&#34;</pre></div></div></li><li><p>Reinicie o computador ou reinicie o serviço de rede para conectar-se à rede:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service netif restart</span></code></pre></div></div></li></ol></div></div></div></div><div class=sect2><h3 id=network-wireless-basic>31.3.3. Configuração básica<a class=anchor href=#network-wireless-basic></a></h3><div class=sect3><h4 id=_configuração_do_kernel>31.3.3.1. Configuração do Kernel<a class=anchor href=#_configuração_do_kernel></a></h4><div class=paragraph><p>Para usar a rede sem fio, uma placa de rede sem fio é necessária e o kernel precisa ser configurado com o suporte de rede sem fio apropriado. O kernel é separado em vários módulos para que apenas o suporte necessário precise ser configurado.</p></div><div class=paragraph><p>Os dispositivos sem fio mais comumente usados são aqueles que usam peças fabricadas pela Atheros. Estes dispositivos são suportados pelo <a href="https://man.freebsd.org/cgi/man.cgi?query=ath&amp;sektion=4&amp;format=html">ath(4)</a> e requerem que a seguinte linha seja adicionada ao <span class=filename>/boot/loader.conf</span> :</p></div><div class="literalblock programlisting"><div class=content><pre>if_ath_load=&#34;YES&#34;</pre></div></div><div class=paragraph><p>O driver Atheros é dividido em três partes separadas: o driver (<a href="https://man.freebsd.org/cgi/man.cgi?query=ath&amp;sektion=4&amp;format=html">ath(4)</a>), a camada de suporte de hardware que lida com funções específicas do chip (<a href="https://man.freebsd.org/cgi/man.cgi?query=ath_hal&amp;sektion=4&amp;format=html">ath_hal(4)</a>) e um algoritmo para selecionar a taxa de transmissão de quadros. Quando este suporte é carregado como módulo do kernel, quaisquer dependências são tratadas automaticamente. Para carregar o suporte para um tipo diferente de dispositivo sem fio, especifique o módulo para esse dispositivo. Este exemplo é para dispositivos baseados no driver Intersil Prism parts (<a href="https://man.freebsd.org/cgi/man.cgi?query=wi&amp;sektion=4&amp;format=html">wi(4)</a>):</p></div><div class="literalblock programlisting"><div class=content><pre>if_wi_load=&#34;YES&#34;</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Os exemplos nesta seção usam um dispositivo<a href="https://man.freebsd.org/cgi/man.cgi?query=ath&amp;sektion=4&amp;format=html">ath(4)</a> e o nome do dispositivo nos exemplos deve ser alterado de acordo com a configuração. Uma lista de drivers sem fio disponíveis e adaptadores suportados pode ser encontrada nas Notas de Hardware do FreeBSD, disponíveis nas <a href=https://www.FreeBSD.org/releases/>Informações de Release</a> da página do site do FreeBSD. Se um driver nativo do FreeBSD para o dispositivo sem fio não existir, pode ser possível usar o driver Windows™ com a ajuda do wrapper de driver <a href=../config/#config-network-ndis>NDIS</a>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Além disso, os módulos que implementam o suporte criptográfico para os protocolos de segurança devem ser carregados. Estes destinam-se a ser dinamicamente carregados sob demanda pelo módulo <a href="https://man.freebsd.org/cgi/man.cgi?query=wlan&amp;sektion=4&amp;format=html">wlan(4)</a>, mas por enquanto eles devem ser configurados manualmente. Os seguintes módulos estão disponíveis: <a href="https://man.freebsd.org/cgi/man.cgi?query=wlan_wep&amp;sektion=4&amp;format=html">wlan_wep(4)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=wlan_ccmp&amp;sektion=4&amp;format=html">wlan_ccmp(4)</a>, e <a href="https://man.freebsd.org/cgi/man.cgi?query=wlan_tkip&amp;sektion=4&amp;format=html">wlan_tkip(4)</a>. Os drivers <a href="https://man.freebsd.org/cgi/man.cgi?query=wlan_ccmp&amp;sektion=4&amp;format=html">wlan_ccmp(4)</a> e <a href="https://man.freebsd.org/cgi/man.cgi?query=wlan_tkip&amp;sektion=4&amp;format=html">wlan_tkip(4)</a> são necessário apenas ao usar os protocolos de segurança WPA ou 802.11i. Se a rede não usar criptografia, o suporte a <a href="https://man.freebsd.org/cgi/man.cgi?query=wlan_wep&amp;sektion=4&amp;format=html">wlan_wep(4)</a> não será necessário. Para carregar estes módulos no momento da inicialização, adicione as seguintes linhas ao <span class=filename>/boot/loader.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>wlan_wep_load=&#34;YES&#34;
wlan_ccmp_load=&#34;YES&#34;
wlan_tkip_load=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Uma vez que esta informação tenha sido adicionada ao <span class=filename>/boot/loader.conf</span>, reinicie a caixa FreeBSD. Como alternativa, carregue os módulos manualmente usando <a href="https://man.freebsd.org/cgi/man.cgi?query=kldload&amp;sektion=8&amp;format=html">kldload(8)</a>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Para usuários que não querem usar módulos, é possível compilar esses drivers no kernel adicionando as seguintes linhas a um arquivo de configuração de kernel personalizado:</p></div><div class="literalblock programlisting"><div class=content><pre>device wlan              # 802.11 support
device wlan_wep          # 802.11 WEP support
device wlan_ccmp         # 802.11 CCMP support
device wlan_tkip         # 802.11 TKIP support
device wlan_amrr         # AMRR transmit rate control algorithm
device ath               # Atheros pci/cardbus NIC&#39;s
device ath_hal           # pci/cardbus chip support
options AH_SUPPORT_AR5416 # enable AR5416 tx/rx descriptors
device ath_rate_sample   # SampleRate tx rate control for ath</pre></div></div><div class=paragraph><p>Com esta informação no arquivo de configuração do kernel, recompile o kernel e reinicie a máquina do FreeBSD.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Informações sobre o dispositivo sem fio devem aparecer nas mensagens de inicialização, assim:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>ath0: &lt;Atheros 5212&gt; mem 0x88000000-0x8800ffff irq 11 at device 0.0 on cardbus1
ath0: <span class=o>[</span>ITHREAD]
ath0: AR2413 mac 7.9 RF2413 phy 4.5</code></pre></div></div></div><div class=sect3><h4 id=_definindo_a_região_correta>31.3.3.2. Definindo a Região Correta<a class=anchor href=#_definindo_a_região_correta></a></h4><div class=paragraph><p>Como a situação regulatória é diferente em várias partes do mundo, é necessário definir corretamente os domínios que se aplicam à sua localização para obter as informações corretas sobre quais canais podem ser usados.</p></div><div class=paragraph><p>As definições de região disponíveis podem ser encontradas em <span class=filename>/etc/regdomain.xml</span>. Para definir os dados em tempo de execução, use o <code>ifconfig</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0 regdomain ETSI country AT</span></code></pre></div></div><div class=paragraph><p>Para persistir as configurações, adicione-o ao <span class=filename>/etc/rc.conf</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysrc create_args_wlan0=&#34;country AT regdomain ETSI&#34;</span></code></pre></div></div></div></div><div class=sect2><h3 id=_modo_de_infraestrutura>31.3.4. Modo de Infraestrutura<a class=anchor href=#_modo_de_infraestrutura></a></h3><div class=paragraph><p>O modo de infra-estrutura (BSS) é o modo normalmente usado. Neste modo, vários pontos de acesso sem fio são conectados a uma rede com fio. Cada rede sem fio tem seu próprio nome, chamado de SSID. Os clientes sem fio se conectam aos pontos de acesso sem fio.</p></div><div class=sect3><h4 id=_clientes_do_freebsd>31.3.4.1. Clientes do FreeBSD<a class=anchor href=#_clientes_do_freebsd></a></h4><div class=sect4><h5 id=_como_encontrar_pontos_de_acesso>31.3.4.1.1. Como encontrar pontos de acesso<a class=anchor href=#_como_encontrar_pontos_de_acesso></a></h5><div class=paragraph><p>Para procurar redes disponíveis, use <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a>. Essa solicitação pode demorar alguns instantes para ser concluída, pois exige que o sistema alterne para cada frequência sem fio disponível e sonde os pontos de acesso disponíveis. Apenas o superusuário pode iniciar uma varredura:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0 create wlandev ath0</span>
<span class=c># ifconfig wlan0 up scan</span>
SSID/MESH ID    BSSID              CHAN RATE   S:N     INT CAPS
dlinkap         00:13:46:49:41:76   11   54M <span class=nt>-90</span>:96   100 EPS  WPA WME
freebsdap       00:11:95:c3:0d:ac    1   54M <span class=nt>-83</span>:96   100 EPS  WPA</code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>A interface deve estar <code>up</code> antes de poder efetuar a busca. Pedidos de varredura subsequentes não exigem que a interface seja marcada como up novamente.</p></div></td></tr></tbody></table></div><div class=paragraph><p>A saída de uma solicitação de varredura lista cada rede BSS/IBSS encontrada. Além de listar o nome da rede, o <code>SSID</code>, a saída também mostra o <code>BSSID</code>, que é o endereço MAC do ponto de acesso. O campo <code>CAPS</code> identifica o tipo de cada rede e os recursos das estações que operam lá:</p></div><table class="tableblock frame-none grid-all stretch"><caption class=title>Tabela 2. Códigos de capacidade da estação</caption><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Código de capacidade</th><th class="tableblock halign-left valign-top">Significado</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>E</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Conjunto de serviços estendidos (ESS). Indica que a estação faz parte de uma rede de infraestrutura em vez de uma rede IBSS/ad-hoc.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>I</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Rede IBSS/ad-hoc. Indica que a estação faz parte de uma rede ad-hoc em vez de uma rede ESS.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>P</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Privacidade. A criptografia é necessária para todos os quadros de dados trocados dentro do BSS usando meios criptográficos como o WEP, o TKIP ou o AES-CCMP.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>S</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Preâmbulo Curto. Indica que a rede está usando preâmbulos curtos, definidos em 802.11b de Alta Taxa/DSSS PHYS, e utiliza um campo de sincronização de 56 bits em vez do campo de 128 bits usado no modo de preâmbulo longo.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>s</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Tempo de slot curto. Indica que a rede 802.11g está usando um tempo de slot curto porque não há estações legadas (802.11b) presentes.</p></td></tr></tbody></table><div class=paragraph><p>Pode-se também exibir a lista atual de redes conhecidas com:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0 list scan</span></code></pre></div></div><div class=paragraph><p>Essas informações podem ser atualizadas automaticamente pelo adaptador ou manualmente com uma solicitação de <code>scan</code>. Dados antigos são automaticamente removidos do cache, então com o tempo essa lista pode diminuir a menos que mais varreduras sejam feitas.</p></div></div><div class=sect4><h5 id=_configurações_básicas>31.3.4.1.2. Configurações básicas<a class=anchor href=#_configurações_básicas></a></h5><div class=paragraph><p>Esta seção fornece um exemplo simples de como fazer com que o adaptador de rede sem fio funcione no FreeBSD sem criptografia. Uma vez familiarizado com esses conceitos, é altamente recomendável usar o <a href=#network-wireless-wpa>WPA</a> para configurar a rede sem fio.</p></div><div class=paragraph><p>Existem três etapas básicas para configurar uma rede sem fio: selecionar um ponto de acesso, autenticar a estação e configurar um endereço IP. As seções a seguir discutem cada etapa.</p></div><div class=sect5><h6 id=_selecionando_um_ponto_de_acesso>31.3.4.1.2.1. Selecionando um ponto de acesso<a class=anchor href=#_selecionando_um_ponto_de_acesso></a></h6><div class=paragraph><p>Na maioria das vezes, é suficiente deixar o sistema escolher um ponto de acesso usando a heurística integrada. Este é o comportamento padrão quando uma interface é marcada como up ou está listada em <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>wlans_ath0=&#34;wlan0&#34;
ifconfig_wlan0=&#34;DHCP&#34;</pre></div></div><div class=paragraph><p>Se houver vários pontos de acesso, um específico pode ser selecionado pelo seu SSID:</p></div><div class="literalblock programlisting"><div class=content><pre>wlans_ath0=&#34;wlan0&#34;
ifconfig_wlan0=&#34;ssid your_ssid_here DHCP&#34;</pre></div></div><div class=paragraph><p>Em um ambiente em que há vários pontos de acesso com o mesmo SSID, o que geralmente é feito para simplificar o roaming, talvez seja necessário associá-lo a um dispositivo específico. Neste caso, o BSSID do ponto de acesso pode ser especificado, com ou sem o SSID:</p></div><div class="literalblock programlisting"><div class=content><pre>wlans_ath0=&#34;wlan0&#34;
ifconfig_wlan0=&#34;ssid your_ssid_here bssid xx:xx:xx:xx:xx:xx DHCP&#34;</pre></div></div><div class=paragraph><p>Existem outras maneiras de restringir a escolha de um ponto de acesso, como limitar o conjunto de freqüências que o sistema fará a varredura. Isso pode ser útil para uma placa sem fio de banda múltipla, pois a varredura de todos os canais possíveis pode consumir muito tempo. Para limitar a operação a uma banda específica, use o parâmetro <code>mode</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>wlans_ath0=&#34;wlan0&#34;
ifconfig_wlan0=&#34;mode 11g ssid your_ssid_here DHCP&#34;</pre></div></div><div class=paragraph><p>Este exemplo forçará a placa a operar em 802.11g, que é definido apenas para freqüências de 2.4GHz, portanto, qualquer canal de 5GHz não será considerado. Isso também pode ser obtido com o parâmetro <code>channel</code>, que bloqueia a operação para uma frequência específica, e o parâmetro <code>chanlist</code>, para especificar uma lista de canais para varredura. Maiores informações sobre esses parâmetros podem ser encontradas em <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a>.</p></div></div><div class=sect5><h6 id=_autenticação>31.3.4.1.2.2. Autenticação<a class=anchor href=#_autenticação></a></h6><div class=paragraph><p>Quando um ponto de acesso é selecionado, a estação precisa se autenticar antes de poder transmitir dados. A autenticação pode acontecer de várias maneiras. O esquema mais comum, autenticação aberta, permite que qualquer estação entre na rede e se comunique. Essa é a autenticação a ser usada para fins de teste na primeira vez em que uma rede sem fio é configurada. Outros esquemas exigem que os handshakes criptográficos sejam concluídos antes que o tráfego de dados possa fluir, usando chaves ou segredos pré-compartilhados ou esquemas mais complexos que envolvam serviços de back-end, como o RADIUS. Autenticação aberta é a configuração padrão. A próxima configuração mais comum é o WPA-PSK, também conhecido como WPA Pessoal, que é descrito em <a href=#network-wireless-wpa-wpa-psk>WPA-PSK</a>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Se estiver usando uma estação base Extreme AirPort™ da Apple™ para um ponto de acesso, a autenticação de chave compartilhada juntamente com um WEP chave precisa ser configurada. Isto pode ser configurado em <span class=filename>/etc/rc.conf</span> ou usando <a href="https://man.freebsd.org/cgi/man.cgi?query=wpa_supplicant&amp;sektion=8&amp;format=html">wpa_supplicant(8)</a>. Para uma única estação base AirPort™, o acesso pode ser configurado com:</p></div><div class="literalblock programlisting"><div class=content><pre>wlans_ath0=&#34;wlan0&#34;
ifconfig_wlan0=&#34;authmode shared wepmode on weptxkey 1 wepkey 01234567 DHCP&#34;</pre></div></div><div class=paragraph><p>Em geral, a autenticação de chave compartilhada deve ser evitada porque ela usa o material de chave WEP de uma maneira altamente restrita, facilitando ainda mais a quebra da chave. Se o WEP deve ser usado para compatibilidade com dispositivos legados, é melhor usar o WEP com a autenticação <code>open</code>. Mais informações sobre o WEP podem ser encontradas em <a href=#network-wireless-wep>WEP</a>.</p></div></td></tr></tbody></table></div></div><div class=sect5><h6 id=_obtendo_um_endereço_ip_com_dhcp>31.3.4.1.2.3. Obtendo um endereço IP com DHCP<a class=anchor href=#_obtendo_um_endereço_ip_com_dhcp></a></h6><div class=paragraph><p>Quando um ponto de acesso é selecionado e os parâmetros de autenticação são definidos, um endereço IP deve ser obtido para se comunicar. Na maioria das vezes, o endereço IP é obtido através do DHCP. Para isso, edite o <span class=filename>/etc/rc.conf</span> e adicione o <code>DHCP</code> à configuração do dispositivo:</p></div><div class="literalblock programlisting"><div class=content><pre>wlans_ath0=&#34;wlan0&#34;
ifconfig_wlan0=&#34;DHCP&#34;</pre></div></div><div class=paragraph><p>A interface sem fio está agora pronta para subir:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service netif start</span></code></pre></div></div><div class=paragraph><p>Quando a interface estiver rodando, use o <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a> para ver o status da interface <span class=filename>ath0</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0</span>
wlan0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
        ether 00:11:95:d5:43:62
        inet 192.168.1.100 netmask 0xffffff00 broadcast 192.168.1.255
        media: IEEE 802.11 Wireless Ethernet OFDM/54Mbps mode 11g
        status: associated
        ssid dlinkap channel 11 <span class=o>(</span>2462 Mhz 11g<span class=o>)</span> bssid 00:13:46:49:41:76
        country US ecm authmode OPEN privacy OFF txpower 21.5 bmiss 7
        scanvalid 60 bgscan bgscanintvl 300 bgscanidle 250 roam:rssi 7
        roam:rate 5 protmode CTS wme burst</code></pre></div></div><div class=paragraph><p>A linha <code>status: associated</code> significa que está conectada à rede sem fio. O <code>bssid 00:13:46:49:41:76</code> é o endereço MAC do ponto de acesso e o <code>authmode OPEN</code> indica que a comunicação é não criptografada.</p></div></div><div class=sect5><h6 id=_endereço_ip_estático>31.3.4.1.2.4. Endereço IP estático<a class=anchor href=#_endereço_ip_estático></a></h6><div class=paragraph><p>Se um endereço IP não puder ser obtido de um servidor DHCP, defina um endereço de IP fixo. Substitua a palavra-chave <code>DHCP</code> mostrada acima pelas informações do endereço. Certifique-se de reter quaisquer outros parâmetros para selecionar o ponto de acesso:</p></div><div class="literalblock programlisting"><div class=content><pre>wlans_ath0=&#34;wlan0&#34;
ifconfig_wlan0=&#34;inet 192.168.1.100 netmask 255.255.255.0 ssid your_ssid_here&#34;</pre></div></div></div></div><div class=sect4><h5 id=network-wireless-wpa>31.3.4.1.3. WPA<a class=anchor href=#network-wireless-wpa></a></h5><div class=paragraph><p>O Wi-Fi Protected Access (WPA) é um protocolo de segurança usado em conjunto com redes 802.11 para resolver a falta de autenticação adequada e a fraqueza do WEP. O WPA utiliza o protocolo de autenticação 802.1X e usa uma das várias codificações disponíveis em vez do WEP para integridade de dados. A única codificação exigida pelo WPA é o protocolo de integridade de chave temporária (TKIP). O TKIP é uma codificação que estende a codificação básica RC4 usada pelo WEP, adicionando verificação de integridade, detecção de adulteração e medidas para responder a intrusões detectadas. O TKIP foi projetado para funcionar em hardware legado apenas com uma modificação de software. Ele representa um compromisso que melhora a segurança, mas ainda não é totalmente imune a ataques. O WPA também especifica a codificação AES-CCMP como uma alternativa para o TKIP, e é preferível quando possível. Para esta especificação, o termo WPA2 ou RSN é comumente usado.</p></div><div class=paragraph><p>O WPA define protocolos de autenticação e criptografia. A autenticação é mais comumente feita usando uma de duas técnicas: por 802.1X e um serviço de autenticação backend, como o RADIUS, ou por um handshake mínimo entre a estação e o ponto de acesso usando um segredo pré-compartilhado. O primeiro é comumente chamado de WPA Enterprise e o último é conhecido como WPA Pessoal. Como a maioria das pessoas não configurará um servidor backend RADIUS para sua rede sem fio, o WPA-PSK é de longe a configuração mais comumente encontrada para o WPA .</p></div><div class=paragraph><p>O controle da conexão sem fio e a negociação ou autenticação de chave com um servidor é feito usando o <a href="https://man.freebsd.org/cgi/man.cgi?query=wpa_supplicant&amp;sektion=8&amp;format=html">wpa_supplicant(8)</a>. Este programa requer um arquivo de configuração, o <span class=filename>/etc/wpa_supplicant.conf</span>, para ser executado. Maiores informações sobre este arquivo podem ser encontradas em <a href="https://man.freebsd.org/cgi/man.cgi?query=wpa_supplicant.conf&amp;sektion=5&amp;format=html">wpa_supplicant.conf(5)</a>.</p></div><div class=sect5><h6 id=network-wireless-wpa-wpa-psk>31.3.4.1.3.1. WPA-PSK<a class=anchor href=#network-wireless-wpa-wpa-psk></a></h6><div class=paragraph><p>O WPA-PSK, também conhecido como WPA Pessoal, é baseado em uma chave pré-compartilhada (PSK) que é gerada a partir de uma determinada senha e usado como chave mestra na rede sem fio. Isso significa que todos os usuários sem fio compartilharão a mesma chave. O WPA-PSK destina-se a redes pequenas em que o uso de um servidor de autenticação não é possível ou desejado.</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Sempre use senhas fortes que sejam suficientemente longas e feitas de um alfabeto rico para que elas não sejam facilmente adivinhadas ou atacadas.</p></div></td></tr></tbody></table></div><div class=paragraph><p>O primeiro passo é a configuração do <span class=filename>/etc/wpa_supplicant.conf</span> com o SSID e a chave pré-compartilhada da rede:</p></div><div class="literalblock programlisting"><div class=content><pre>network={
  ssid=&#34;freebsdap&#34;
  psk=&#34;freebsdmall&#34;
}</pre></div></div><div class=paragraph><p>Então, em <span class=filename>/etc/rc.conf</span>, indique que a configuração do dispositivo sem fio será feita com o WPA e o endereço IP será obtido com o DHCP:</p></div><div class="literalblock programlisting"><div class=content><pre>wlans_ath0=&#34;wlan0&#34;
ifconfig_wlan0=&#34;WPA DHCP&#34;</pre></div></div><div class=paragraph><p>Então, suba a interface:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service netif start</span>
Starting wpa_supplicant.
DHCPDISCOVER on wlan0 to 255.255.255.255 port 67 interval 5
DHCPDISCOVER on wlan0 to 255.255.255.255 port 67 interval 6
DHCPOFFER from 192.168.0.1
DHCPREQUEST on wlan0 to 255.255.255.255 port 67
DHCPACK from 192.168.0.1
bound to 192.168.0.254 <span class=nt>--</span> renewal <span class=k>in </span>300 seconds.
wlan0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
      ether 00:11:95:d5:43:62
      inet 192.168.0.254 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet OFDM/36Mbps mode 11g
      status: associated
      ssid freebsdap channel 1 <span class=o>(</span>2412 Mhz 11g<span class=o>)</span> bssid 00:11:95:c3:0d:ac
      country US ecm authmode WPA2/802.11i privacy ON deftxkey UNDEF
      AES-CCM 3:128-bit txpower 21.5 bmiss 7 scanvalid 450 bgscan
      bgscanintvl 300 bgscanidle 250 roam:rssi 7 roam:rate 5 protmode CTS
      wme burst roaming MANUAL</code></pre></div></div><div class=paragraph><p>Ou, tente configurar a interface manualmente usando as informações em <span class=filename>/etc/wpa_supplicant.conf</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># wpa_supplicant -i wlan0 -c /etc/wpa_supplicant.conf</span>
Trying to associate with 00:11:95:c3:0d:ac <span class=o>(</span><span class=nv>SSID</span><span class=o>=</span><span class=s1>&#39;freebsdap&#39;</span> <span class=nv>freq</span><span class=o>=</span>2412 MHz<span class=o>)</span>
Associated with 00:11:95:c3:0d:ac
WPA: Key negotiation completed with 00:11:95:c3:0d:ac <span class=o>[</span><span class=nv>PTK</span><span class=o>=</span>CCMP <span class=nv>GTK</span><span class=o>=</span>CCMP]
CTRL-EVENT-CONNECTED - Connection to 00:11:95:c3:0d:ac completed <span class=o>(</span>auth<span class=o>)</span> <span class=o>[</span><span class=nb>id</span><span class=o>=</span>0 <span class=nv>id_str</span><span class=o>=]</span></code></pre></div></div><div class=paragraph><p>A próxima operação é iniciar o <a href="https://man.freebsd.org/cgi/man.cgi?query=dhclient&amp;sektion=8&amp;format=html">dhclient(8)</a> para obter o endereço IP do servidor DHCP:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dhclient wlan0</span>
DHCPREQUEST on wlan0 to 255.255.255.255 port 67
DHCPACK from 192.168.0.1
bound to 192.168.0.254 <span class=nt>--</span> renewal <span class=k>in </span>300 seconds.
<span class=c># ifconfig wlan0</span>
wlan0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
      ether 00:11:95:d5:43:62
      inet 192.168.0.254 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet OFDM/36Mbps mode 11g
      status: associated
      ssid freebsdap channel 1 <span class=o>(</span>2412 Mhz 11g<span class=o>)</span> bssid 00:11:95:c3:0d:ac
      country US ecm authmode WPA2/802.11i privacy ON deftxkey UNDEF
      AES-CCM 3:128-bit txpower 21.5 bmiss 7 scanvalid 450 bgscan
      bgscanintvl 300 bgscanidle 250 roam:rssi 7 roam:rate 5 protmode CTS
      wme burst roaming MANUAL</code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Se o <span class=filename>/etc/rc.conf</span> tiver uma entrada <code>ifconfig_wlan0="DHCP"</code>, <a href="https://man.freebsd.org/cgi/man.cgi?query=dhclient&amp;sektion=8&amp;format=html">dhclient(8)</a> será iniciado automaticamente após o <a href="https://man.freebsd.org/cgi/man.cgi?query=wpa_supplicant&amp;sektion=8&amp;format=html">wpa_supplicant(8)</a> associar-se ao ponto de acesso.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Se o DHCP não for possível ou desejado, defina um endereço IP estático após o <a href="https://man.freebsd.org/cgi/man.cgi?query=wpa_supplicant&amp;sektion=8&amp;format=html">wpa_supplicant(8)</a> autenticar a estação:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0 inet 192.168.0.100 netmask 255.255.255.0</span>
<span class=c># ifconfig wlan0</span>
wlan0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
      ether 00:11:95:d5:43:62
      inet 192.168.0.100 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet OFDM/36Mbps mode 11g
      status: associated
      ssid freebsdap channel 1 <span class=o>(</span>2412 Mhz 11g<span class=o>)</span> bssid 00:11:95:c3:0d:ac
      country US ecm authmode WPA2/802.11i privacy ON deftxkey UNDEF
      AES-CCM 3:128-bit txpower 21.5 bmiss 7 scanvalid 450 bgscan
      bgscanintvl 300 bgscanidle 250 roam:rssi 7 roam:rate 5 protmode CTS
      wme burst roaming MANUAL</code></pre></div></div><div class=paragraph><p>Quando o DHCP não é usado, o gateway padrão e o servidor de nomes também precisam ser definidos manualmente:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># route add default your_default_router</span>
<span class=c># echo &#34;nameserver your_DNS_server&#34; &gt;&gt; /etc/resolv.conf</span></code></pre></div></div></div><div class=sect5><h6 id=network-wireless-wpa-eap-tls>31.3.4.1.3.2. WPA com EAP-TLS<a class=anchor href=#network-wireless-wpa-eap-tls></a></h6><div class=paragraph><p>A segunda maneira de usar o WPA é com um servidor de autenticação de backend 802.1X. Neste caso, o WPA é chamado de WPA Enterprise para diferenciá-lo do WPA Pessoal menos seguro. A autenticação no WPA Enterprise é baseada no protocolo de autenticação extensível (EAP).</p></div><div class=paragraph><p>O EAP não vem com um método de criptografia. Em vez disso, o EAP é incorporado dentro de um túnel criptografado. Existem muitos métodos de autenticação EAP, mas o EAP-TLS, o EAP-TTLS e o EAP-PEAP são os mais comum.</p></div><div class=paragraph><p>O EAP com Segurança da Camada de Transporte (EAP-TLS) é um protocolo de autenticação sem fio bem suportado, já que foi o primeiro método EAP a ser certificado pela <a href=http://www.wi-fi.org/>WiFi Alliance</a>. O EAP-TLS requer três certificados para executar: o certificado da Autoridade de Certificação (CA) instalado em todas as máquinas, o certificado do servidor para o servidor de autenticação e um certificado de cliente para cada cliente sem fio. Nesse método EAP, o servidor de autenticação e o cliente sem fio autenticam um ao outro apresentando seus respectivos certificados e, em seguida, verificam se esses certificados foram assinados pela CA da organização.</p></div><div class=paragraph><p>Como anteriormente, a configuração é feita através do <span class=filename>/etc/wpa_supplicant.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>network={
  ssid=&#34;freebsdap&#34; <i class=conum data-value=1></i><b>(1)</b>
  proto=RSN  <i class=conum data-value=2></i><b>(2)</b>
  key_mgmt=WPA-EAP <i class=conum data-value=3></i><b>(3)</b>
  eap=TLS <i class=conum data-value=4></i><b>(4)</b>
  identity=&#34;loader&#34; <i class=conum data-value=5></i><b>(5)</b>
  ca_cert=&#34;/etc/certs/cacert.pem&#34; <i class=conum data-value=6></i><b>(6)</b>
  client_cert=&#34;/etc/certs/clientcert.pem&#34; <i class=conum data-value=7></i><b>(7)</b>
  private_key=&#34;/etc/certs/clientkey.pem&#34; <i class=conum data-value=8></i><b>(8)</b>
  private_key_passwd=&#34;freebsdmallclient&#34; <i class=conum data-value=9></i><b>(9)</b>
}</pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>Este campo indica o nome da rede (SSID).</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td>Este exemplo usa o protocolo 802.11i RSN IEEE™, também conhecido como WPA2.</td></tr><tr><td><i class=conum data-value=3></i><b>3</b></td><td>A linha <code>key_mgmt</code> refere-se ao protocolo de gerenciamento de chaves a ser usado. Neste exemplo, é o WPA usando a autenticação EAP.</td></tr><tr><td><i class=conum data-value=4></i><b>4</b></td><td>Este campo indica o método EAP para a conexão.</td></tr><tr><td><i class=conum data-value=5></i><b>5</b></td><td>O campo <code>identity</code> contém a sequência de identidade para EAP.</td></tr><tr><td><i class=conum data-value=6></i><b>6</b></td><td>O campo <code>ca_cert</code> indica o nome do caminho do arquivo de certificado CA. Este arquivo é necessário para verificar o certificado do servidor.</td></tr><tr><td><i class=conum data-value=7></i><b>7</b></td><td>A linha <code>client_cert</code> fornece o nome do caminho para o arquivo de certificado do cliente. Este certificado é exclusivo para cada cliente sem fio da rede.</td></tr><tr><td><i class=conum data-value=8></i><b>8</b></td><td>O campo <code>private_key</code> é o nome do caminho para o arquivo de chave privada do certificado do cliente.</td></tr><tr><td><i class=conum data-value=9></i><b>9</b></td><td>O campo <code>private_key_passwd</code> contém a frase secreta para a chave privada.</td></tr></tbody></table></div><div class=paragraph><p>Em seguida, adicione as seguintes linhas ao <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>wlans_ath0=&#34;wlan0&#34;
ifconfig_wlan0=&#34;WPA DHCP&#34;</pre></div></div><div class=paragraph><p>O próximo passo é subir a interface:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service netif start</span>
Starting wpa_supplicant.
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 7
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 15
DHCPACK from 192.168.0.20
bound to 192.168.0.254 <span class=nt>--</span> renewal <span class=k>in </span>300 seconds.
wlan0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
      ether 00:11:95:d5:43:62
      inet 192.168.0.254 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet DS/11Mbps mode 11g
      status: associated
      ssid freebsdap channel 1 <span class=o>(</span>2412 Mhz 11g<span class=o>)</span> bssid 00:11:95:c3:0d:ac
      country US ecm authmode WPA2/802.11i privacy ON deftxkey UNDEF
      AES-CCM 3:128-bit txpower 21.5 bmiss 7 scanvalid 450 bgscan
      bgscanintvl 300 bgscanidle 250 roam:rssi 7 roam:rate 5 protmode CTS
      wme burst roaming MANUAL</code></pre></div></div><div class=paragraph><p>Também é possível subir a interface manualmente usando <a href="https://man.freebsd.org/cgi/man.cgi?query=wpa_supplicant&amp;sektion=8&amp;format=html">wpa_supplicant(8)</a> e <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a>.</p></div></div><div class=sect5><h6 id=network-wireless-wpa-eap-ttls>31.3.4.1.3.3. WPA com EAP-TTLS<a class=anchor href=#network-wireless-wpa-eap-ttls></a></h6><div class=paragraph><p>Com o EAP-TLS, o servidor de autenticação e o cliente precisam de um certificado. Com o EAP-TTLS, um certificado de cliente é opcional. Esse método é semelhante a um servidor da Web que cria um túnel seguro SSL, mesmo se os visitantes não tiverem certificados do lado do cliente. O EAP-TTLS usa um túnel TLS criptografado para o transporte seguro dos dados de autenticação.</p></div><div class=paragraph><p>A configuração necessária pode ser adicionada ao <span class=filename>/etc/wpa_supplicant.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>network={
  ssid=&#34;freebsdap&#34;
  proto=RSN
  key_mgmt=WPA-EAP
  eap=TTLS <i class=conum data-value=1></i><b>(1)</b>
  identity=&#34;test&#34; <i class=conum data-value=2></i><b>(2)</b>
  password=&#34;test&#34; <i class=conum data-value=3></i><b>(3)</b>
  ca_cert=&#34;/etc/certs/cacert.pem&#34; <i class=conum data-value=4></i><b>(4)</b>
  phase2=&#34;auth=MD5&#34; <i class=conum data-value=5></i><b>(5)</b>
}</pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>Este campo especifica o método EAP para a conexão.</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td>O campo <code>identity</code> contém a sequência de identidade para a autenticação EAP dentro do túnel TLS criptografado.</td></tr><tr><td><i class=conum data-value=3></i><b>3</b></td><td>O campo <code>password</code> contém a senha para a autenticação EAP.</td></tr><tr><td><i class=conum data-value=4></i><b>4</b></td><td>O campo <code>ca_cert</code> indica o nome do caminho do arquivo de certificado CA. Este arquivo é necessário para verificar o certificado do servidor.</td></tr><tr><td><i class=conum data-value=5></i><b>5</b></td><td>Este campo especifica o método de autenticação usado no túnel TLS criptografado. Neste exemplo, o EAP com desafio MD5 é usado. A fase de "inner authentication" é freqüentemente chamada de "phase2".</td></tr></tbody></table></div><div class=paragraph><p>Em seguida, adicione as seguintes linhas ao <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>wlans_ath0=&#34;wlan0&#34;
ifconfig_wlan0=&#34;WPA DHCP&#34;</pre></div></div><div class=paragraph><p>O próximo passo é subir a interface:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service netif start</span>
Starting wpa_supplicant.
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 7
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 15
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 21
DHCPACK from 192.168.0.20
bound to 192.168.0.254 <span class=nt>--</span> renewal <span class=k>in </span>300 seconds.
wlan0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
      ether 00:11:95:d5:43:62
      inet 192.168.0.254 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet DS/11Mbps mode 11g
      status: associated
      ssid freebsdap channel 1 <span class=o>(</span>2412 Mhz 11g<span class=o>)</span> bssid 00:11:95:c3:0d:ac
      country US ecm authmode WPA2/802.11i privacy ON deftxkey UNDEF
      AES-CCM 3:128-bit txpower 21.5 bmiss 7 scanvalid 450 bgscan
      bgscanintvl 300 bgscanidle 250 roam:rssi 7 roam:rate 5 protmode CTS
      wme burst roaming MANUAL</code></pre></div></div></div><div class=sect5><h6 id=network-wireless-wpa-eap-peap>31.3.4.1.3.4. WPA com EAP-PEAP<a class=anchor href=#network-wireless-wpa-eap-peap></a></h6><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>O PEAPv0/EAP-MSCHAPv2 é o método PEAP mais comum. Neste capítulo, o termo PEAP é usado para se referir a esse método.</p></div></td></tr></tbody></table></div><div class=paragraph><p>O EAP protegido (PEAP) foi criado como uma alternativa ao EAP-TTLS e é o padrão mais usado do EAP após o EAP-TLS. Em uma rede com sistemas operacionais mistos, o PEAP deve ser o padrão mais suportado após o EAP-TLS.</p></div><div class=paragraph><p>O PEAP é semelhante ao EAP-TTLS, pois usa um certificado do lado do servidor para autenticar clientes criando um túnel TLS criptografado entre o cliente e o servidor de autenticação, que protege a troca subsequente das informações de autenticação. A autenticação PEAP difere do EAP-TTLS, pois transmite o nome de usuário em texto aberto e somente a senha é enviada no túnel TLS criptografado. O EAP-TTLS usará o túnel TLS para o nome de usuário e para a senha.</p></div><div class=paragraph><p>Adicione as seguintes linhas ao <span class=filename>/etc/wpa_supplicant.conf</span> para ajustar as configurações relacionadas ao EAP-PEAP:</p></div><div class="literalblock programlisting"><div class=content><pre>network={
  ssid=&#34;freebsdap&#34;
  proto=RSN
  key_mgmt=WPA-EAP
  eap=PEAP <i class=conum data-value=1></i><b>(1)</b>
  identity=&#34;test&#34; <i class=conum data-value=2></i><b>(2)</b>
  password=&#34;test&#34; <i class=conum data-value=3></i><b>(3)</b>
  ca_cert=&#34;/etc/certs/cacert.pem&#34; <i class=conum data-value=4></i><b>(4)</b>
  phase1=&#34;peaplabel=0&#34; <i class=conum data-value=5></i><b>(5)</b>
  phase2=&#34;auth=MSCHAPV2&#34; <i class=conum data-value=6></i><b>(6)</b>
}</pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>Este campo especifica o método EAP para a conexão.</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td>O campo <code>identity</code> contém a sequência de identidade para a autenticação EAP dentro do túnel TLS criptografado.</td></tr><tr><td><i class=conum data-value=3></i><b>3</b></td><td>O campo <code>password</code> contém a senha para a autenticação EAP.</td></tr><tr><td><i class=conum data-value=4></i><b>4</b></td><td>O campo <code>ca_cert</code> indica o nome do caminho do arquivo de certificado CA. Este arquivo é necessário para verificar o certificado do servidor.</td></tr><tr><td><i class=conum data-value=5></i><b>5</b></td><td>Este campo contém os parâmetros para a primeira fase de autenticação, o túnel TLS. De acordo com o servidor de autenticação usado, especifique um label específico para autenticação. Na maioria das vezes, o label será "client EAP encryption" que é definido usando <code>peaplabel=0</code>. Maiores informações podem ser encontradas em <a href="https://man.freebsd.org/cgi/man.cgi?query=wpa_supplicant.conf&amp;sektion=5&amp;format=html">wpa_supplicant.conf(5)</a>.</td></tr><tr><td><i class=conum data-value=6></i><b>6</b></td><td>Este campo especifica o protocolo de autenticação usado no túnel TLS criptografado. No caso do PEAP, é <code>auth=MSCHAPV2</code>.</td></tr></tbody></table></div><div class=paragraph><p>Adicione o seguinte ao <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>wlans_ath0=&#34;wlan0&#34;
ifconfig_wlan0=&#34;WPA DHCP&#34;</pre></div></div><div class=paragraph><p>Então, suba a interface:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service netif start</span>
Starting wpa_supplicant.
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 7
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 15
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 21
DHCPACK from 192.168.0.20
bound to 192.168.0.254 <span class=nt>--</span> renewal <span class=k>in </span>300 seconds.
wlan0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
      ether 00:11:95:d5:43:62
      inet 192.168.0.254 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet DS/11Mbps mode 11g
      status: associated
      ssid freebsdap channel 1 <span class=o>(</span>2412 Mhz 11g<span class=o>)</span> bssid 00:11:95:c3:0d:ac
      country US ecm authmode WPA2/802.11i privacy ON deftxkey UNDEF
      AES-CCM 3:128-bit txpower 21.5 bmiss 7 scanvalid 450 bgscan
      bgscanintvl 300 bgscanidle 250 roam:rssi 7 roam:rate 5 protmode CTS
      wme burst roaming MANUAL</code></pre></div></div></div></div><div class=sect4><h5 id=network-wireless-wep>31.3.4.1.4. WEP<a class=anchor href=#network-wireless-wep></a></h5><div class=paragraph><p>A privacidade equivalente com fio (WEP) faz parte do padrão 802.11 original. Não há mecanismo de autenticação, apenas uma forma fraca de controle de acesso que é facilmente quebrada.</p></div><div class=paragraph><p>O WEP pode ser configurado usando o <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0 create wlandev ath0</span>
<span class=c># ifconfig wlan0 inet 192.168.1.100 netmask 255.255.255.0 \</span>
	    ssid my_net wepmode on weptxkey 3 wepkey 3:0x3456789012</code></pre></div></div><div class=ulist><ul><li><p>O <code>weptxkey</code> especifica qual chave WEP será usada na transmissão. Este exemplo usa a terceira chave. Isso deve corresponder à configuração no ponto de acesso. Quando não tiver certeza de qual chave é usada pelo ponto de acesso, tente <code>1</code> (a primeira chave) para esse valor.</p></li><li><p>O <code>wepkey</code> seleciona uma das chaves WEP. Deve estar no formato <em>index:key</em>. A chave <code>1</code> é usada por padrão; o índice só precisa ser definido ao usar uma chave diferente da primeira.</p><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Substitua o <code>0x3456789012</code> com a chave configurada para uso no ponto de acesso.</p></div></td></tr></tbody></table></div></li></ul></div><div class=paragraph><p>Consulte o <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a> para obter maiores informações.</p></div><div class=paragraph><p>O recurso <a href="https://man.freebsd.org/cgi/man.cgi?query=wpa_supplicant&amp;sektion=8&amp;format=html">wpa_supplicant(8)</a> pode ser usado para configurar uma interface sem fio com o WEP. O exemplo acima pode ser configurado adicionando as seguintes linhas ao <span class=filename>/etc/wpa_supplicant.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>network={
  ssid=&#34;my_net&#34;
  key_mgmt=NONE
  wep_key3=3456789012
  wep_tx_keyidx=3
}</pre></div></div><div class=paragraph><p>Então:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># wpa_supplicant -i wlan0 -c /etc/wpa_supplicant.conf</span>
Trying to associate with 00:13:46:49:41:76 <span class=o>(</span><span class=nv>SSID</span><span class=o>=</span><span class=s1>&#39;dlinkap&#39;</span> <span class=nv>freq</span><span class=o>=</span>2437 MHz<span class=o>)</span>
Associated with 00:13:46:49:41:76</code></pre></div></div></div></div></div><div class=sect2><h3 id=_modo_ad_hoc>31.3.5. Modo Ad-hoc<a class=anchor href=#_modo_ad_hoc></a></h3><div class=paragraph><p>O modo IBSS, também chamado de modo ad-hoc, é projetado para conexões ponto a ponto. Por exemplo, para estabelecer uma rede ad-hoc entre as máquinas <code>A</code> e <code>B</code>, escolha dois endereços IP e um SSID.</p></div><div class=paragraph><p>Em <code>A</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0 create wlandev ath0 wlanmode adhoc</span>
<span class=c># ifconfig wlan0 inet 192.168.0.1 netmask 255.255.255.0 ssid freebsdap</span>
<span class=c># ifconfig wlan0</span>
  wlan0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
	  ether 00:11:95:c3:0d:ac
	  inet 192.168.0.1 netmask 0xffffff00 broadcast 192.168.0.255
	  media: IEEE 802.11 Wireless Ethernet autoselect mode 11g &lt;adhoc&gt;
	  status: running
	  ssid freebsdap channel 2 <span class=o>(</span>2417 Mhz 11g<span class=o>)</span> bssid 02:11:95:c3:0d:ac
	  country US ecm authmode OPEN privacy OFF txpower 21.5 scanvalid 60
	  protmode CTS wme burst</code></pre></div></div><div class=paragraph><p>O parâmetro <code>adhoc</code> indica que a interface está sendo executada no modo IBSS.</p></div><div class=paragraph><p><code>B</code> deve ser capaz de detectar <code>A</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0 create wlandev ath0 wlanmode adhoc</span>
<span class=c># ifconfig wlan0 up scan</span>
  SSID/MESH ID    BSSID              CHAN RATE   S:N     INT CAPS
  freebsdap       02:11:95:c3:0d:ac    2   54M <span class=nt>-64</span>:-96  100 IS   WME</code></pre></div></div><div class=paragraph><p>O <code>I</code> na saída confirma que <code>A</code> está no modo ad-hoc. Agora, configure <code>B</code> com um endereço IP diferente:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0 inet 192.168.0.2 netmask 255.255.255.0 ssid freebsdap</span>
<span class=c># ifconfig wlan0</span>
  wlan0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
	  ether 00:11:95:d5:43:62
	  inet 192.168.0.2 netmask 0xffffff00 broadcast 192.168.0.255
	  media: IEEE 802.11 Wireless Ethernet autoselect mode 11g &lt;adhoc&gt;
	  status: running
	  ssid freebsdap channel 2 <span class=o>(</span>2417 Mhz 11g<span class=o>)</span> bssid 02:11:95:c3:0d:ac
	  country US ecm authmode OPEN privacy OFF txpower 21.5 scanvalid 60
	  protmode CTS wme burst</code></pre></div></div><div class=paragraph><p>Ambos <code>A</code> e <code>B</code> agora estão prontos para trocar informações.</p></div></div><div class=sect2><h3 id=network-wireless-ap>31.3.6. Pontos de Acesso com um host FreeBSD<a class=anchor href=#network-wireless-ap></a></h3><div class=paragraph><p>O FreeBSD pode atuar como um Access Point (AP), o que elimina a necessidade de comprar um hardware AP ou executar uma rede ad-hoc. Isso pode ser particularmente útil quando uma máquina FreeBSD está atuando como um gateway para outra rede, como a Internet.</p></div><div class=sect3><h4 id=network-wireless-ap-basic>31.3.6.1. Configurações básicas<a class=anchor href=#network-wireless-ap-basic></a></h4><div class=paragraph><p>Antes de configurar uma máquina FreeBSD como um AP, o kernel deve ser configurado com o suporte de rede apropriado para a placa wireless assim como os protocolos de segurança que estão sendo usados. Para maiores detalhes, veja <a href=#network-wireless-basic>Configuração básica</a>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>O wrapper do driver NDIS para os drivers Windows™ não suporta atualmente a operação AP. Somente os drivers nativos de rede sem fio do FreeBSD suportam o modo AP.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Quando o suporte à rede sem fio estiver carregado, verifique se o dispositivo sem fio oferece suporte ao modo de ponto de acesso baseado em host, também conhecido como modo hostap:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0 create wlandev ath0</span>
<span class=c># ifconfig wlan0 list caps</span>
<span class=nv>drivercaps</span><span class=o>=</span>6f85edc1&lt;STA,FF,TURBOP,IBSS,HOSTAP,AHDEMO,TXPMGT,SHSLOT,SHPREAMBLE,MONITOR,MBSS,WPA1,WPA2,BURST,WME,WDS,BGSCAN,TXFRAG&gt;
<span class=nv>cryptocaps</span><span class=o>=</span>1f&lt;WEP,TKIP,AES,AES_CCM,TKIPMIC&gt;</code></pre></div></div><div class=paragraph><p>Esta saída exibe os recursos da placa. A palavra <code>HOSTAP</code> confirma que esta placa sem fio pode atuar como um AP. Diversas cifras suportadas também são listadas: WEP, TKIP e AES. Esta informação indica quais protocolos de segurança podem ser usados no AP.</p></div><div class=paragraph><p>O dispositivo sem fio só pode ser colocado no modo hostap durante a criação do pseudo-dispositivo de rede, portanto, um dispositivo criado anteriormente deve ser destruído primeiro:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0 destroy</span></code></pre></div></div><div class=paragraph><p>e então regenerado com a opção correta antes de configurar os outros parâmetros:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0 create wlandev ath0 wlanmode hostap</span>
<span class=c># ifconfig wlan0 inet 192.168.0.1 netmask 255.255.255.0 ssid freebsdap mode 11g channel 1</span></code></pre></div></div><div class=paragraph><p>Use o <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a> novamente para ver o status da interface <span class=filename>wlan0</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0</span>
  wlan0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
	  ether 00:11:95:c3:0d:ac
	  inet 192.168.0.1 netmask 0xffffff00 broadcast 192.168.0.255
	  media: IEEE 802.11 Wireless Ethernet autoselect mode 11g &lt;hostap&gt;
	  status: running
	  ssid freebsdap channel 1 <span class=o>(</span>2412 Mhz 11g<span class=o>)</span> bssid 00:11:95:c3:0d:ac
	  country US ecm authmode OPEN privacy OFF txpower 21.5 scanvalid 60
	  protmode CTS wme burst dtimperiod 1 <span class=nt>-dfs</span></code></pre></div></div><div class=paragraph><p>O parâmetro <code>hostap</code> indica que a interface está sendo executada no modo de ponto de acesso baseado em host.</p></div><div class=paragraph><p>A configuração da interface pode ser feita automaticamente no momento da inicialização, adicionando as seguintes linhas ao <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>wlans_ath0=&#34;wlan0&#34;
create_args_wlan0=&#34;wlanmode hostap&#34;
ifconfig_wlan0=&#34;inet 192.168.0.1 netmask 255.255.255.0 ssid freebsdap mode 11g channel 1&#34;</pre></div></div></div><div class=sect3><h4 id=_ponto_de_acesso_baseado_em_host_sem_autenticação_ou_criptografia>31.3.6.2. Ponto de acesso baseado em host sem autenticação ou criptografia<a class=anchor href=#_ponto_de_acesso_baseado_em_host_sem_autenticação_ou_criptografia></a></h4><div class=paragraph><p>Embora não seja recomendado executar um AP sem nenhuma autenticação ou criptografia, esta é uma maneira simples de verificar se o AP está funcionando. Essa configuração também é importante para depurar problemas do cliente.</p></div><div class=paragraph><p>Quando o AP estiver configurado, inicie uma verificação de outra máquina sem fio para encontrar o AP:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0 create wlandev ath0</span>
<span class=c># ifconfig wlan0 up scan</span>
SSID/MESH ID    BSSID              CHAN RATE   S:N     INT CAPS
freebsdap       00:11:95:c3:0d:ac    1   54M <span class=nt>-66</span>:-96  100 ES   WME</code></pre></div></div><div class=paragraph><p>A máquina cliente encontrou o AP e pode ser associado a ele:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0 inet 192.168.0.2 netmask 255.255.255.0 ssid freebsdap</span>
<span class=c># ifconfig wlan0</span>
  wlan0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
	  ether 00:11:95:d5:43:62
	  inet 192.168.0.2 netmask 0xffffff00 broadcast 192.168.0.255
	  media: IEEE 802.11 Wireless Ethernet OFDM/54Mbps mode 11g
	  status: associated
	  ssid freebsdap channel 1 <span class=o>(</span>2412 Mhz 11g<span class=o>)</span> bssid 00:11:95:c3:0d:ac
	  country US ecm authmode OPEN privacy OFF txpower 21.5 bmiss 7
	  scanvalid 60 bgscan bgscanintvl 300 bgscanidle 250 roam:rssi 7
	  roam:rate 5 protmode CTS wme burst</code></pre></div></div></div><div class=sect3><h4 id=network-wireless-ap-wpa>31.3.6.3. Ponto de acesso baseado em host com WPA2<a class=anchor href=#network-wireless-ap-wpa></a></h4><div class=paragraph><p>Esta seção se concentra na configuração de um ponto de acesso do FreeBSD usando o protocolo de segurança WPA2. Maiores detalhes sobre WPA e a configuração de clientes sem fio baseados em WPA podem ser encontrados em <a href=#network-wireless-wpa>WPA</a>.</p></div><div class=paragraph><p>O daemon <a href="https://man.freebsd.org/cgi/man.cgi?query=hostapd&amp;sektion=8&amp;format=html">hostapd(8)</a> é usado para lidar com a autenticação de clientes e o gerenciamento de chaves no AP com WPA2 habilitado.</p></div><div class=paragraph><p>As seguintes operações de configuração são executadas na máquina FreeBSD atuando como o AP. Uma vez que o AP esteja funcionando corretamente, o <a href="https://man.freebsd.org/cgi/man.cgi?query=hostapd&amp;sektion=8&amp;format=html">hostapd(8)</a> pode ser iniciado automaticamente na inicialização com essa linha em <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>hostapd_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Antes de tentar configurar o <a href="https://man.freebsd.org/cgi/man.cgi?query=hostapd&amp;sektion=8&amp;format=html">hostapd(8)</a>, primeiro defina as configurações básicas introduzidas em <a href=#network-wireless-ap-basic>Configurações básicas</a> .</p></div><div class=sect4><h5 id=_wpa2_psk>31.3.6.3.1. WPA2-PSK<a class=anchor href=#_wpa2_psk></a></h5><div class=paragraph><p>O WPA2-PSK destina-se a redes pequenas em que o uso de um servidor de autenticação backend não é possível ou desejado.</p></div><div class=paragraph><p>A configuração é feita em <span class=filename>/etc/hostapd.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>interface=wlan0                  <i class=conum data-value=1></i><b>(1)</b>
debug=1                          <i class=conum data-value=2></i><b>(2)</b>
ctrl_interface=/var/run/hostapd  <i class=conum data-value=3></i><b>(3)</b>
ctrl_interface_group=wheel       <i class=conum data-value=4></i><b>(4)</b>
ssid=freebsdap                   <i class=conum data-value=5></i><b>(5)</b>
wpa=2                            <i class=conum data-value=6></i><b>(6)</b>
wpa_passphrase=freebsdmall       <i class=conum data-value=7></i><b>(7)</b>
wpa_key_mgmt=WPA-PSK             <i class=conum data-value=8></i><b>(8)</b>
wpa_pairwise=CCMP                <i class=conum data-value=9></i><b>(9)</b></pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>Interface sem fio usada para o ponto de acesso.</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td>Nível de detalhamento usado durante a execução de <a href="https://man.freebsd.org/cgi/man.cgi?query=hostapd&amp;sektion=8&amp;format=html">hostapd(8)</a>. Um valor de <code>1</code> representa o nível mínimo.</td></tr><tr><td><i class=conum data-value=3></i><b>3</b></td><td>Nome do caminho de diretório usado pelo <a href="https://man.freebsd.org/cgi/man.cgi?query=hostapd&amp;sektion=8&amp;format=html">hostapd(8)</a> para armazenar arquivos de soquete de domínio para comunicação com programas externos, como <a href="https://man.freebsd.org/cgi/man.cgi?query=hostapd_cli&amp;sektion=8&amp;format=html">hostapd_cli(8)</a>. O valor padrão é usado neste exemplo.</td></tr><tr><td><i class=conum data-value=4></i><b>4</b></td><td>O grupo permitiu acessar os arquivos da interface de controle.</td></tr><tr><td><i class=conum data-value=5></i><b>5</b></td><td>O nome da rede sem fio, ou SSID, que aparecerá nas varreduras sem fio.</td></tr><tr><td><i class=conum data-value=6></i><b>6</b></td><td>Ative o WPA e especifique qual protocolo de autenticação WPA será necessário. Um valor de <code>2</code> configura o AP para WPA2 e é recomendado. Defina como <code>1</code> apenas se o WPA obsoleto for necessário.</td></tr><tr><td><i class=conum data-value=7></i><b>7</b></td><td>Senha ASCII para autenticação WPA.</td></tr><tr><td><i class=conum data-value=8></i><b>8</b></td><td>O protocolo de gerenciamento de chaves a ser usado. Este exemplo define o WPA-PSK.
Algoritmos de criptografia aceitos pelo ponto de acesso. Neste exemplo, apenas a codificação CCMP (AES) é aceita. O CCMP é uma alternativa ao TKIP e é fortemente preferido quando possível. O TKIP só deve ser permitido quando houver estações incapazes de usar o CCMP.</td></tr></tbody></table></div><div class=paragraph><p>O próximo passo é iniciar <a href="https://man.freebsd.org/cgi/man.cgi?query=hostapd&amp;sektion=8&amp;format=html">hostapd(8)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service hostapd forcestart</span></code></pre></div></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0</span>
wlan0: <span class=nv>flags</span><span class=o>=</span>8943&lt;UP,BROADCAST,RUNNING,PROMISC,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
	ether 04:f0:21:16:8e:10
	inet6 fe80::6f0:21ff:fe16:8e10%wlan0 prefixlen 64 scopeid 0x9
	nd6 <span class=nv>options</span><span class=o>=</span>21&lt;PERFORMNUD,AUTO_LINKLOCAL&gt;
	media: IEEE 802.11 Wireless Ethernet autoselect mode 11na &lt;hostap&gt;
	status: running
	ssid No5ignal channel 36 <span class=o>(</span>5180 MHz 11a ht/40+<span class=o>)</span> bssid 04:f0:21:16:8e:10
	country US ecm authmode WPA2/802.11i privacy MIXED deftxkey 2
	AES-CCM 2:128-bit AES-CCM 3:128-bit txpower 17 mcastrate 6 mgmtrate 6
	scanvalid 60 ampdulimit 64k ampdudensity 8 shortgi wme burst
	dtimperiod 1 <span class=nt>-dfs</span>
	<span class=nb>groups</span>: wlan</code></pre></div></div><div class=paragraph><p>Quando o AP está em execução, os clientes podem associar-se a ele. Veja <a href=#network-wireless-wpa>WPA</a> para maiores detalhes. É possível ver as estações associadas ao AP usando o <code>ifconfig <em>wlan0</em> list sta</code>.</p></div></div></div><div class=sect3><h4 id=_ponto_de_acesso_baseado_em_host_wep>31.3.6.4. Ponto de acesso baseado em host WEP<a class=anchor href=#_ponto_de_acesso_baseado_em_host_wep></a></h4><div class=paragraph><p>Não é recomendado o uso do WEP para configurar um AP, já que não há mecanismo de autenticação e a criptografia é facilmente quebrada. Algumas placas sem fio legadas suportam apenas o WEP e essas placas suportarão apenas um AP sem autenticação ou criptografia.</p></div><div class=paragraph><p>O dispositivo sem fio agora pode ser colocado no modo hostap e configurado com o endereço SSID e IP corretos:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0 create wlandev ath0 wlanmode hostap</span>
<span class=c># ifconfig wlan0 inet 192.168.0.1 netmask 255.255.255.0 \</span>
	ssid freebsdap wepmode on weptxkey 3 wepkey 3:0x3456789012 mode 11g</code></pre></div></div><div class=ulist><ul><li><p>O <code>weptxkey</code> indica qual a chave WEP será usada na transmissão. Este exemplo usa a terceira chave, pois a numeração de chaves começa com <code>1</code>. Esse parâmetro deve ser especificado para criptografar os dados.</p></li><li><p>O <code>wepkey</code> define a chave WEP selecionada. Ela deve estar no formato <em>index:key</em>. Se o índice não for fornecido, a chave <code>1</code> será configurada. O índice precisa ser definido ao usar chaves diferentes da primeira chave.</p></li></ul></div><div class=paragraph><p>Use o <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a> para ver o status da interface <span class=filename>wlan0</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0</span>
  wlan0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
	  ether 00:11:95:c3:0d:ac
	  inet 192.168.0.1 netmask 0xffffff00 broadcast 192.168.0.255
	  media: IEEE 802.11 Wireless Ethernet autoselect mode 11g &lt;hostap&gt;
	  status: running
	  ssid freebsdap channel 4 <span class=o>(</span>2427 Mhz 11g<span class=o>)</span> bssid 00:11:95:c3:0d:ac
	  country US ecm authmode OPEN privacy ON deftxkey 3 wepkey 3:40-bit
	  txpower 21.5 scanvalid 60 protmode CTS wme burst dtimperiod 1 <span class=nt>-dfs</span></code></pre></div></div><div class=paragraph><p>De uma outra máquina sem fio, agora é possível iniciar uma varredura para encontrar o AP:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0 create wlandev ath0</span>
<span class=c># ifconfig wlan0 up scan</span>
SSID            BSSID              CHAN RATE  S:N   INT CAPS
freebsdap       00:11:95:c3:0d:ac    1   54M 22:1   100 EPS</code></pre></div></div><div class=paragraph><p>Neste exemplo, a máquina cliente encontrou o AP e pode associá-lo usando os parâmetros corretos. Veja <a href=#network-wireless-wep>WEP</a> para maiores detalhes.</p></div></div></div><div class=sect2><h3 id=_usando_conexões_com_fio_e_sem_fio>31.3.7. Usando conexões com fio e sem fio<a class=anchor href=#_usando_conexões_com_fio_e_sem_fio></a></h3><div class=paragraph><p>Uma conexão com fio oferece melhor desempenho e confiabilidade, enquanto uma conexão sem fio fornece flexibilidade e mobilidade. Os usuários de laptop normalmente querem se movimentar perfeitamente entre os dois tipos de conexão.</p></div><div class=paragraph><p>No FreeBSD, é possível combinar duas ou mais interfaces de rede em um "failover". Esse tipo de configuração usa a conexão mais prioritária e disponível de um grupo de interfaces de rede, e o sistema operacional alterna automaticamente quando o estado do link é alterado.</p></div><div class=paragraph><p>A agregação de links e o failover são cobertos em <a href=#network-aggregation>Agregação de links e failover</a> e um exemplo para usar conexões com e sem fio é fornecido em <a href=#networking-lagg-wired-and-wireless>Modo de failover entre interfaces Ethernet e sem fio</a>.</p></div></div><div class=sect2><h3 id=_solução_de_problemas>31.3.8. Solução de problemas<a class=anchor href=#_solução_de_problemas></a></h3><div class=paragraph><p>Esta seção descreve várias etapas para ajudar a solucionar problemas comuns de rede sem fio.</p></div><div class=ulist><ul><li><p>Se o ponto de acesso não estiver listado durante a verificação, verifique se a configuração não limitou o dispositivo sem fio a um conjunto limitado de canais.</p></li><li><p>Se o dispositivo não puder se associar a um ponto de acesso, verifique se a configuração corresponde às configurações no ponto de acesso. Isso inclui o esquema de autenticação e qualquer protocolo de segurança. Simplifique a configuração tanto quanto possível. Se estiver usando um protocolo de segurança, como o WPA ou o WEP, configure o ponto de acesso para autenticação aberta e nenhuma segurança para ver se o tráfego irá passar.</p><div class=paragraph><p>O suporte a depuração é fornecido pelo <a href="https://man.freebsd.org/cgi/man.cgi?query=wpa_supplicant&amp;sektion=8&amp;format=html">wpa_supplicant(8)</a>. Tente executar este utilitário manualmente com a opção <code>-dd</code> e examine os logs do sistema.</p></div></li><li><p>Uma vez que o sistema possa se associar com o ponto de acesso, diagnostique a configuração da rede usando ferramentas como o <a href="https://man.freebsd.org/cgi/man.cgi?query=ping&amp;sektion=8&amp;format=html">ping(8)</a>.</p></li><li><p>Existem muitas ferramentas de depuração de nível inferior. As mensagens de depuração podem ser ativadas na camada de suporte do protocolo 802.11 usando o <a href="https://man.freebsd.org/cgi/man.cgi?query=wlandebug&amp;sektion=8&amp;format=html">wlandebug(8)</a>. Por exemplo, para habilitar mensagens do console relacionadas à varredura de pontos de acesso e aos handshakes do protocolo 802.11 necessários para organizar a comunicação:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># wlandebug -i wlan0 +scan+auth+debug+assoc</span>
  net.wlan.0.debug: 0 <span class=o>=&gt;</span> 0xc80000&lt;assoc,auth,scan&gt;</code></pre></div></div><div class=paragraph><p>Muitas estatísticas úteis são mantidas pela camada 802.11 e o <code>wlanstats</code>, encontrado em <span class=filename>/usr/src/tools/tools/net80211</span>, vai despejar esta informação. Essas estatísticas devem exibir todos os erros identificados pela camada 802.11. No entanto, alguns erros são identificados nos drivers de dispositivo que estão abaixo da camada 802.11, portanto eles podem não aparecer. Para diagnosticar problemas específicos do dispositivo, consulte a documentação do driver.</p></div></li></ul></div><div class=paragraph><p>Se as informações acima não ajudarem a esclarecer o problema, envie um relatório de problemas e inclua a saída das ferramentas acima.</p></div></div></div></div><div class=sect1><h2 id=network-usb-tethering>31.4. USB Tethering<a class=anchor href=#network-usb-tethering></a></h2><div class=sectionbody><div class=paragraph><p>Muitos telefones celulares oferecem a opção de compartilhar sua conexão de dados sobre o USB (muitas vezes chamado de "tethering"). Este recurso usa o RNDIS, CDC ou um protocolo personalizado Apple™iPhone™/iPad™.</p></div><div class=ulist><ul><li><p>Os dispositivos Android™ geralmente utilizam o driver <a href="https://man.freebsd.org/cgi/man.cgi?query=urndis&amp;sektion=4&amp;format=html">urndis(4)</a>.</p></li><li><p>Os dispositivos Apple™ utilizam o driver <a href="https://man.freebsd.org/cgi/man.cgi?query=ipheth&amp;sektion=4&amp;format=html">ipheth(4)</a>.</p></li><li><p>Dispositivos mais antigos geralmente utilizam o driver <a href="https://man.freebsd.org/cgi/man.cgi?query=cdce&amp;sektion=4&amp;format=html">cdce(4)</a>.</p></li></ul></div><div class=paragraph><p>Antes de conectar um dispositivo, carregue o driver apropriado no kernel:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload if_urndis</span>
<span class=c># kldload if_cdce</span>
<span class=c># kldload if_ipheth</span></code></pre></div></div><div class=paragraph><p>Uma vez que o dispositivo esteja conectado, <code>ue</code><em>0</em> estará disponível para uso como um dispositivo de rede normal. Certifique-se de que a opção "USB Tethering" esteja ativada no dispositivo.</p></div><div class=paragraph><p>Para tornar essa alteração permanente e carregar o driver como um módulo no momento da inicialização, coloque a linha apropriada abaixo em <span class=filename>/boot/loader.conf</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> <span class=nv>if_urndis_load</span><span class=o>=</span><span class=s2>&#34;YES&#34;</span>
<span class=nv>if_cdce_load</span><span class=o>=</span><span class=s2>&#34;YES&#34;</span>
<span class=nv>if_ipheth_load</span><span class=o>=</span><span class=s2>&#34;YES&#34;</span></code></pre></div></div></div></div><div class=sect1><h2 id=network-bluetooth>31.5. Bluetooth<a class=anchor href=#network-bluetooth></a></h2><div class=sectionbody><div class=paragraph><p>O bluetooth é uma tecnologia sem fio para a criação de redes pessoais que operam na faixa não licenciada de 2,4 GHz, com um alcance de 10 metros. As redes geralmente são formadas em modo ad-hoc a partir de dispositivos portáteis, como telefones celulares, computadores de mão e laptops. Ao contrário da tecnologia sem fio Wi-Fi, o Bluetooth oferece perfis de serviços de nível superior, como servidores de arquivos semelhantes ao FTP, envio de arquivos, transporte de voz, emulação de linha serial e muito mais.</p></div><div class=paragraph><p>Esta seção descreve o uso de um dongle Bluetooth USB em um sistema FreeBSD. Em seguida, descreve os vários protocolos e utilitários Bluetooth.</p></div><div class=sect2><h3 id=_carregando_o_suporte_bluetooth>31.5.1. Carregando o Suporte Bluetooth<a class=anchor href=#_carregando_o_suporte_bluetooth></a></h3><div class=paragraph><p>A pilha Bluetooth no FreeBSD é implementada usando o framework <a href="https://man.freebsd.org/cgi/man.cgi?query=netgraph&amp;sektion=4&amp;format=html">netgraph(4)</a>. Uma ampla variedade de dongles Bluetooth USB é suportada pelo <a href="https://man.freebsd.org/cgi/man.cgi?query=ng_ubt&amp;sektion=4&amp;format=html">ng_ubt(4)</a>. Os dispositivos Bluetooth baseados no Broadcom BCM2033 são suportados pelos drivers <a href="https://man.freebsd.org/cgi/man.cgi?query=ubtbcmfw&amp;sektion=4&amp;format=html">ubtbcmfw(4)</a> e <a href="https://man.freebsd.org/cgi/man.cgi?query=ng_ubt&amp;sektion=4&amp;format=html">ng_ubt(4)</a>. A placa 3Com Bluetooth PC Card 3CRWB60-A é suportada pelo driver <a href="https://man.freebsd.org/cgi/man.cgi?query=ng_bt3c&amp;sektion=4&amp;format=html">ng_bt3c(4)</a>. Dispositivos Bluetooth baseados em Portas Seriais e UART são suportados por <a href="https://man.freebsd.org/cgi/man.cgi?query=sio&amp;sektion=4&amp;format=html">sio(4)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=ng_h4&amp;sektion=4&amp;format=html">ng_h4(4)</a>, e <a href="https://man.freebsd.org/cgi/man.cgi?query=hcseriald&amp;sektion=8&amp;format=html">hcseriald(8)</a>.</p></div><div class=paragraph><p>Antes de conectar um dispositivo, determine qual dos drivers acima ele usa e, em seguida, carregue o driver. Por exemplo, se o dispositivo usar o driver <a href="https://man.freebsd.org/cgi/man.cgi?query=ng_ubt&amp;sektion=4&amp;format=html">ng_ubt(4)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload ng_ubt</span></code></pre></div></div><div class=paragraph><p>Se o dispositivo Bluetooth for conectado ao sistema durante a inicialização do sistema, o sistema pode ser configurado para carregar o módulo no momento da inicialização, adicionando o driver ao <span class=filename>/boot/loader.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>ng_ubt_load=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Quando o driver estiver carregado, conecte o dongle USB. Se a carga do driver tiver sido bem-sucedida, uma saída semelhante à seguinte deve aparecer no console e em <span class=filename>/var/log/messages</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>ubt0: vendor 0x0a12 product 0x0001, rev 1.10/5.25, addr 2
ubt0: Interface 0 endpoints: <span class=nv>interrupt</span><span class=o>=</span>0x81, bulk-in<span class=o>=</span>0x82, bulk-out<span class=o>=</span>0x2
ubt0: Interface 1 <span class=o>(</span>alt.config 5<span class=o>)</span> endpoints: isoc-in<span class=o>=</span>0x83, isoc-out<span class=o>=</span>0x3,
      <span class=nv>wMaxPacketSize</span><span class=o>=</span>49, <span class=nv>nframes</span><span class=o>=</span>6, buffer <span class=nv>size</span><span class=o>=</span>294</code></pre></div></div><div class=paragraph><p>Para iniciar e parar a stack Bluetooth, use seu script de inicialização. É uma boa ideia parar a stack antes de desconectar o dispositivo. Iniciar a stack bluetooth pode exigir que o <a href="https://man.freebsd.org/cgi/man.cgi?query=hcsecd&amp;sektion=8&amp;format=html">hcsecd(8)</a> seja iniciado. Ao iniciar a stack, a saída deve ser semelhante à seguinte:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service bluetooth start ubt0</span>
BD_ADDR: 00:02:72:00:d4:1a
Features: 0xff 0xff 0xf 00 00 00 00 00
&lt;3-Slot&gt; &lt;5-Slot&gt; &lt;Encryption&gt; &lt;Slot offset&gt;
&lt;Timing accuracy&gt; &lt;Switch&gt; &lt;Hold mode&gt; &lt;Sniff mode&gt;
&lt;Park mode&gt; &lt;RSSI&gt; &lt;Channel quality&gt; &lt;SCO <span class=nb>link</span><span class=o>&gt;</span>
&lt;HV2 packets&gt; &lt;HV3 packets&gt; &lt;u-law log&gt; &lt;A-law log&gt; &lt;CVSD&gt;
&lt;Paging scheme&gt; &lt;Power control&gt; &lt;Transparent SCO data&gt;
Max. ACL packet size: 192 bytes
Number of ACL packets: 8
Max. SCO packet size: 64 bytes
Number of SCO packets: 8</code></pre></div></div></div><div class=sect2><h3 id=_encontrando_outros_dispositivos_bluetooth>31.5.2. Encontrando outros dispositivos Bluetooth<a class=anchor href=#_encontrando_outros_dispositivos_bluetooth></a></h3><div class=paragraph><p>A Interface do Controlador do Host (HCI) fornece um método uniforme para acessar os recursos de banda básica do Bluetooth. No FreeBSD, um nó netgraph HCI é criado para cada dispositivo Bluetooth. Para mais detalhes, consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=ng_hci&amp;sektion=4&amp;format=html">ng_hci(4)</a>.</p></div><div class=paragraph><p>Uma das tarefas mais comuns é a descoberta de dispositivos Bluetooth dentro da proximidade RF. Esta operação é chamada <em>inquiry</em>. Investigação e outras operações relacionadas a HCI são feitas usando <a href="https://man.freebsd.org/cgi/man.cgi?query=hccontrol&amp;sektion=8&amp;format=html">hccontrol(8)</a>. O exemplo abaixo mostra como descobrir quais dispositivos Bluetooth estão ao alcance. A lista de dispositivos deve ser exibida em alguns segundos. Note que um dispositivo remoto só irá responder a pergunta se estiver configurado para o modo <em>detectável</em>.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% hccontrol <span class=nt>-n</span> ubt0hci inquiry
Inquiry result, <span class=nv>num_responses</span><span class=o>=</span>1
Inquiry result <span class=c>#0</span>
       BD_ADDR: 00:80:37:29:19:a4
       Page Scan Rep. Mode: 0x1
       Page Scan Period Mode: 00
       Page Scan Mode: 00
       Class: 52:02:04
       Clock offset: 0x78ef
Inquiry complete. Status: No error <span class=o>[</span>00]</code></pre></div></div><div class=paragraph><p>O <code>BD_ADDR</code> é o endereço exclusivo de um dispositivo Bluetooth, semelhante ao endereço MAC de uma placa de rede. Este endereço é necessário para uma comunicação posterior com um dispositivo e é possível atribuir um nome legível a um <code>BD_ADDR</code>. Informações sobre os hosts Bluetooth conhecidos estão contidas em <span class=filename>/etc/bluetooth/hosts</span>. O exemplo a seguir mostra como obter o nome legível que foi atribuído ao dispositivo remoto:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% hccontrol <span class=nt>-n</span> ubt0hci remote_name_request 00:80:37:29:19:a4
BD_ADDR: 00:80:37:29:19:a4
Name: Pav<span class=s1>&#39;s T39</span></code></pre></div></div><div class=paragraph><p>Se uma consulta for realizada em um dispositivo Bluetooth remoto, ele encontrará o computador como "your.host.name (ubt0)". O nome atribuído ao dispositivo local pode ser alterado a qualquer momento.</p></div><div class=paragraph><p>Dispositivos remotos podem receber aliases em <span class=filename>/etc/bluetooth/hosts</span>. Maiores informações sobre o arquivo <span class=filename>/etc/bluetooth/hosts</span> podem ser encontradas em <a href="https://man.freebsd.org/cgi/man.cgi?query=bluetooth.hosts&amp;sektion=5&amp;format=html">bluetooth.hosts(5)</a>.</p></div><div class=paragraph><p>O sistema Bluetooth fornece uma conexão ponta-a-ponto entre duas unidades Bluetooth ou uma conexão ponto-a-multiponto que é compartilhada entre vários dispositivos Bluetooth. O exemplo a seguir mostra como criar uma conexão a um dispositivo remoto:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% hccontrol <span class=nt>-n</span> ubt0hci create_connection BT_ADDR</code></pre></div></div><div class=paragraph><p>O <code>create_connection</code> aceita <code>BT_ADDR</code>, bem como aliases de host em <span class=filename>/etc/bluetooth/hosts</span>.</p></div><div class=paragraph><p>O exemplo a seguir mostra como obter a lista de conexões de banda base ativas para o dispositivo local:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% hccontrol <span class=nt>-n</span> ubt0hci read_connection_list
Remote BD_ADDR    Handle Type Mode Role Encrypt Pending Queue State
00:80:37:29:19:a4     41  ACL    0 MAST    NONE       0     0 OPEN</code></pre></div></div><div class=paragraph><p>Um <em>identificador de conexão</em> é útil quando a finalização da conexão de banda base é necessária, embora normalmente não seja necessário fazer isso manualmente. A stack terminará automaticamente as conexões de banda básica inativas.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># hccontrol -n ubt0hci disconnect 41</span>
Connection handle: 41
Reason: Connection terminated by <span class=nb>local </span>host <span class=o>[</span>0x16]</code></pre></div></div><div class=paragraph><p>Digite <code>hccontrol help</code> para obter uma lista completa dos comandos HCI disponíveis. A maioria dos comandos HCI não requer privilégios de superusuário.</p></div></div><div class=sect2><h3 id=_emparelhamento_de_dispositivos>31.5.3. Emparelhamento de dispositivos<a class=anchor href=#_emparelhamento_de_dispositivos></a></h3><div class=paragraph><p>Por padrão, a comunicação Bluetooth não é autenticada e qualquer dispositivo pode conversar com qualquer outro dispositivo. Um dispositivo Bluetooth, como um telefone celular, pode optar por exigir autenticação para fornecer um serviço específico. A autenticação Bluetooth é normalmente feita com um <em>PIN code</em>, uma string ASCII com até 16 caracteres de comprimento. O usuário é obrigado a digitar o mesmo código de PIN em ambos os dispositivos. Depois que o usuário inserir o código de PIN, ambos os dispositivos gerarão uma <em>chave de link</em>. Depois disso, a chave de link pode ser armazenada nos dispositivos ou em um armazenamento persistente. Na próxima vez, os dois dispositivos usarão a chave de link gerada anteriormente. Este procedimento é chamado de <em>emparelhamento</em>. Observe que, se a chave de link for perdida por um dos dispositivos, o emparelhamento deverá ser repetido.</p></div><div class=paragraph><p>O daemon <a href="https://man.freebsd.org/cgi/man.cgi?query=hcsecd&amp;sektion=8&amp;format=html">hcsecd(8)</a> é responsável por tratar os pedidos de autenticação Bluetooth. O arquivo de configuração padrão é o <span class=filename>/etc/bluetooth/hcsecd.conf</span>. Uma seção de exemplo para um telefone celular com o código PIN definido como <code>1234</code> é mostrada abaixo:</p></div><div class="literalblock programlisting"><div class=content><pre>device {
        bdaddr  00:80:37:29:19:a4;
        name    &#34;Pav&#39;s T39&#34;;
        key     nokey;
        pin     &#34;1234&#34;;
      }</pre></div></div><div class=paragraph><p>A única limitação nos códigos de PIN é o comprimento. Alguns dispositivos, como fones de ouvido Bluetooth, podem ter um código PIN integrado fixo. A opção <code>-d</code> força o <a href="https://man.freebsd.org/cgi/man.cgi?query=hcsecd&amp;sektion=8&amp;format=html">hcsecd(8)</a> a ficar em primeiro plano, então é fácil ver o que está acontecendo. Configure o dispositivo remoto para receber o emparelhamento e inicie a conexão Bluetooth ao dispositivo remoto. O dispositivo remoto deve indicar que o pareamento foi aceito e solicitar o código de PIN. Digite o mesmo código de PIN listado em <span class=filename>hcsecd.conf</span>. Agora o computador e o dispositivo remoto estão emparelhados. Alternativamente, o emparelhamento pode ser iniciado no dispositivo remoto.</p></div><div class=paragraph><p>A seguinte linha pode ser adicionada ao <span class=filename>/etc/rc.conf</span> para configurar o <a href="https://man.freebsd.org/cgi/man.cgi?query=hcsecd&amp;sektion=8&amp;format=html">hcsecd(8)</a> para iniciar automaticamente quando o sistema inicializar:</p></div><div class="literalblock programlisting"><div class=content><pre>hcsecd_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>A seguir, um exemplo da saída do daemon <a href="https://man.freebsd.org/cgi/man.cgi?query=hcsecd&amp;sektion=8&amp;format=html">hcsecd(8)</a>:</p></div><div class="literalblock programlisting"><div class=content><pre>hcsecd[16484]: Got Link_Key_Request event from &#39;ubt0hci&#39;, remote bdaddr 0:80:37:29:19:a4
hcsecd[16484]: Found matching entry, remote bdaddr 0:80:37:29:19:a4, name &#39;Pav&#39;s T39&#39;, link key doesn&#39;t exist
hcsecd[16484]: Sending Link_Key_Negative_Reply to &#39;ubt0hci&#39; for remote bdaddr 0:80:37:29:19:a4
hcsecd[16484]: Got PIN_Code_Request event from &#39;ubt0hci&#39;, remote bdaddr 0:80:37:29:19:a4
hcsecd[16484]: Found matching entry, remote bdaddr 0:80:37:29:19:a4, name &#39;Pav&#39;s T39&#39;, PIN code exists
hcsecd[16484]: Sending PIN_Code_Reply to &#39;ubt0hci&#39; for remote bdaddr 0:80:37:29:19:a4</pre></div></div></div><div class=sect2><h3 id=_acesso_à_rede_com_perfis_ppp>31.5.4. Acesso à rede com perfis PPP<a class=anchor href=#_acesso_à_rede_com_perfis_ppp></a></h3><div class=paragraph><p>Um perfil de rede dial-up (DUN) pode ser usado para configurar um telefone celular como um modem sem fio para a conexão a um servidor de acesso à Internet dial-up. Também pode ser usado para configurar um computador para receber chamadas de dados de um telefone celular.</p></div><div class=paragraph><p>O acesso à rede com um perfil PPP pode ser usado para fornecer acesso LAN a um único dispositivo Bluetooth ou a vários dispositivos Bluetooth. Ele também pode fornecer uma conexão PC para PC usando uma rede PPP sobre uma emulação de cabo serial.</p></div><div class=paragraph><p>No FreeBSD, esses perfis são implementados com o <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> e o wrapper <a href="https://man.freebsd.org/cgi/man.cgi?query=rfcomm_pppd&amp;sektion=8&amp;format=html">rfcomm_pppd(8)</a> que converte uma conexão Bluetooth em algo que o PPP pode usar. Antes que um perfil possa ser usado, um novo label PPP deve ser criado em <span class=filename>/etc/ppp/ppp.conf</span>. Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=rfcomm_pppd&amp;sektion=8&amp;format=html">rfcomm_pppd(8)</a> para exemplos.</p></div><div class=paragraph><p>Neste exemplo, o <a href="https://man.freebsd.org/cgi/man.cgi?query=rfcomm_pppd&amp;sektion=8&amp;format=html">rfcomm_pppd(8)</a> é usado para abrir uma conexão com um dispositivo remoto com um <code>BD_ADDR</code> de <code>00:80:37:29:19:a4</code> em um canal DUNRFCOMM:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># rfcomm_pppd -a 00:80:37:29:19:a4 -c -C dun -l rfcomm-dialup</span></code></pre></div></div><div class=paragraph><p>O número real do canal será obtido a partir do dispositivo remoto usando o protocolo SDP. É possível especificar manualmente o canal RFCOMM e, nesse caso, o <a href="https://man.freebsd.org/cgi/man.cgi?query=rfcomm_pppd&amp;sektion=8&amp;format=html">rfcomm_pppd(8)</a> não executará a consulta SDP. Use o <a href="https://man.freebsd.org/cgi/man.cgi?query=sdpcontrol&amp;sektion=8&amp;format=html">sdpcontrol(8)</a> para descobrir o canal RFCOMM no dispositivo remoto.</p></div><div class=paragraph><p>Para fornecer acesso à rede com o serviço PPPLAN, o <a href="https://man.freebsd.org/cgi/man.cgi?query=sdpd&amp;sektion=8&amp;format=html">sdpd(8)</a> precisa estar sendo executado e uma nova entrada para clientes LAN deve ser criada em <span class=filename>/etc/ppp/ppp.conf</span>. Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=rfcomm_pppd&amp;sektion=8&amp;format=html">rfcomm_pppd(8)</a> para exemplos. Por fim, inicie o servidor RFCOMMPPP em um número de canal RFCOMM válido. O servidor RFCOMMPPP registrará automaticamente o serviço Bluetooth LAN com o daemon local SDP. O exemplo abaixo mostra como iniciar o servidor RFCOMMPPP.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># rfcomm_pppd -s -C 7 -l rfcomm-server</span></code></pre></div></div></div><div class=sect2><h3 id=_protocolos_bluetooth>31.5.5. Protocolos Bluetooth<a class=anchor href=#_protocolos_bluetooth></a></h3><div class=paragraph><p>Esta seção fornece uma visão geral dos vários protocolos Bluetooth, suas funções e utilitários associados.</p></div><div class=sect3><h4 id=_controle_de_link_lógico_e_protocolo_de_adaptação_l2cap>31.5.5.1. Controle de Link Lógico e Protocolo de Adaptação (L2CAP)<a class=anchor href=#_controle_de_link_lógico_e_protocolo_de_adaptação_l2cap></a></h4><div class=paragraph><p>O Protocolo de Adaptação e Controle de Link Lógico (L2CAP) fornece serviços de dados orientados a conexão e sem conexão para protocolos de camada superior. O L2CAP permite que protocolos e aplicativos de alto nível transmitam e recebam pacotes de dados L2CAP de até 64 kilobytes de comprimento.</p></div><div class=paragraph><p>O L2CAP é baseado no conceito de <em>canais</em>. Um canal é uma conexão lógica em cima de uma conexão de banda base, na qual cada canal é vinculado a um único protocolo de maneira many-to-one. Vários canais podem ser vinculados ao mesmo protocolo, mas um canal não pode ser vinculado a vários protocolos. Cada pacote L2CAP recebido em um canal é direcionado para o protocolo apropriado de nível superior. Vários canais podem compartilhar a mesma conexão de banda base.</p></div><div class=paragraph><p>No FreeBSD, um nó netgraph L2CAP é criado para cada dispositivo Bluetooth. Esse nó é normalmente conectado ao nó Bluetooth HCI downstream e aos nós de soquete Bluetooth upstream. O nome padrão para o nó L2CAP é "devicel2cap". Para mais detalhes, consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=ng_l2cap&amp;sektion=4&amp;format=html">ng_l2cap(4)</a>.</p></div><div class=paragraph><p>Um comando útil é o <a href="https://man.freebsd.org/cgi/man.cgi?query=l2ping&amp;sektion=8&amp;format=html">l2ping(8)</a>, que pode ser usado para executar ping em outros dispositivos. Algumas implementações Bluetooth podem não retornar todos os dados enviados para elas, portanto, a saída <code>0 bytes</code> no exemplo a seguir é normal.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># l2ping -a 00:80:37:29:19:a4</span>
0 bytes from 0:80:37:29:19:a4 <span class=nv>seq_no</span><span class=o>=</span>0 <span class=nb>time</span><span class=o>=</span>48.633 ms <span class=nv>result</span><span class=o>=</span>0
0 bytes from 0:80:37:29:19:a4 <span class=nv>seq_no</span><span class=o>=</span>1 <span class=nb>time</span><span class=o>=</span>37.551 ms <span class=nv>result</span><span class=o>=</span>0
0 bytes from 0:80:37:29:19:a4 <span class=nv>seq_no</span><span class=o>=</span>2 <span class=nb>time</span><span class=o>=</span>28.324 ms <span class=nv>result</span><span class=o>=</span>0
0 bytes from 0:80:37:29:19:a4 <span class=nv>seq_no</span><span class=o>=</span>3 <span class=nb>time</span><span class=o>=</span>46.150 ms <span class=nv>result</span><span class=o>=</span>0</code></pre></div></div><div class=paragraph><p>O utilitário <a href="https://man.freebsd.org/cgi/man.cgi?query=l2control&amp;sektion=8&amp;format=html">l2control(8)</a> é usado para executar várias operações em nós L2CAP. Este exemplo mostra como obter a lista de conexões lógicas (canais) e a lista de conexões de banda base para o dispositivo local:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% l2control <span class=nt>-a</span> 00:02:72:00:d4:1a read_channel_list
L2CAP channels:
Remote BD_ADDR     SCID/ DCID   PSM  IMTU/ OMTU State
00:07:e0:00:0b:ca    66/   64     3   132/  672 OPEN
% l2control <span class=nt>-a</span> 00:02:72:00:d4:1a read_connection_list
L2CAP connections:
Remote BD_ADDR    Handle Flags Pending State
00:07:e0:00:0b:ca     41 O           0 OPEN</code></pre></div></div><div class=paragraph><p>Outra ferramenta de diagnóstico é o <a href="https://man.freebsd.org/cgi/man.cgi?query=btsockstat&amp;sektion=1&amp;format=html">btsockstat(1)</a>. Ele é semelhante ao <a href="https://man.freebsd.org/cgi/man.cgi?query=netstat&amp;sektion=1&amp;format=html">netstat(1)</a>, mas para estruturas de dados relacionadas à rede Bluetooth. O exemplo abaixo mostra a mesma conexão lógica que <a href="https://man.freebsd.org/cgi/man.cgi?query=l2control&amp;sektion=8&amp;format=html">l2control(8)</a> acima.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% btsockstat
Active L2CAP sockets
PCB      Recv-Q Send-Q Local address/PSM       Foreign address   CID   State
c2afe900      0      0 00:02:72:00:d4:1a/3     00:07:e0:00:0b:ca 66    OPEN
Active RFCOMM sessions
L2PCB    PCB      Flag MTU   Out-Q DLCs State
c2afe900 c2b53380 1    127   0     Yes  OPEN
Active RFCOMM sockets
PCB      Recv-Q Send-Q Local address     Foreign address   Chan DLCI State
c2e8bc80      0    250 00:02:72:00:d4:1a 00:07:e0:00:0b:ca 3    6    OPEN</code></pre></div></div></div><div class=sect3><h4 id=_comunicação_por_radiofrequência_rfcomm>31.5.5.2. Comunicação por radiofrequência (RFCOMM)<a class=anchor href=#_comunicação_por_radiofrequência_rfcomm></a></h4><div class=paragraph><p>O protocolo RFCOMM fornece emulação de portas seriais sobre o protocolo L2CAP. O RFCOMM é um protocolo de transporte simples, com disposições adicionais para emular os 9 circuitos das portas seriais RS-232 (EIATIA-232-E). Suporta até 60 conexões simultâneas (canais RFCOMM) entre dois dispositivos Bluetooth.</p></div><div class=paragraph><p>Para fins do RFCOMM, um caminho de comunicação completo envolve dois aplicativos em execução nos terminais de comunicação com um segmento de comunicação entre eles. O RFCOMM destina-se a abranger aplicativos que fazem uso das portas seriais dos dispositivos em que residem. O segmento de comunicação é um link Bluetooth de conexão direta de um dispositivo para outro.</p></div><div class=paragraph><p>O RFCOMM está relacionado apenas com a conexão entre os dispositivos no caso de conexão direta ou entre o dispositivo e um modem no caso de rede. O RFCOMM pode suportar outras configurações, como módulos que se comunicam via tecnologia sem fio Bluetooth de um lado e fornecem uma interface com fio no outro lado.</p></div><div class=paragraph><p>No FreeBSD, o RFCOMM é implementado na camada de sockets do Bluetooth.</p></div></div><div class=sect3><h4 id=_protocolo_de_descoberta_de_serviços_sdp>31.5.5.3. Protocolo de Descoberta de Serviços (SDP)<a class=anchor href=#_protocolo_de_descoberta_de_serviços_sdp></a></h4><div class=paragraph><p>O Protocolo de Descoberta de Serviços (SDP) fornece os meios para os aplicativos clientes descobrirem a existência de serviços fornecidos por aplicativos de servidor, bem como os atributos desses serviços. Os atributos de um serviço incluem o tipo ou classe de serviço oferecido e as informações de mecanismo ou protocolo necessárias para utilizar o serviço.</p></div><div class=paragraph><p>O SDP envolve a comunicação entre um servidor SDP e um cliente SDP. O servidor mantém uma lista de registros de serviço que descrevem as características dos serviços associados ao servidor. Cada registro de serviço contém informações sobre um único serviço. Um cliente pode recuperar informações de um registro de serviço mantido pelo servidor SDP emitindo uma solicitação SDP. Se o cliente, ou um aplicativo associado ao cliente, decidir usar um serviço, ele deverá abrir uma conexão separada com o provedor de serviços para utilizar o serviço. O SDP fornece um mecanismo para descobrir serviços e seus atributos, mas não fornece um mecanismo para utilizar esses serviços.</p></div><div class=paragraph><p>Normalmente, um cliente SDP procura serviços baseados em algumas características desejadas dos serviços. No entanto, há momentos em que é desejável descobrir quais tipos de serviços são descritos pelos registros de serviço de um servidor SDP, sem qualquer informação prévia sobre os serviços. Este processo de procurar por qualquer serviço oferecido é chamado de <em>navegação</em>.</p></div><div class=paragraph><p>O servidor Bluetooth SDP, <a href="https://man.freebsd.org/cgi/man.cgi?query=sdpd&amp;sektion=8&amp;format=html">sdpd(8)</a> e o cliente de linha de comandos, <a href="https://man.freebsd.org/cgi/man.cgi?query=sdpcontrol&amp;sektion=8&amp;format=html">sdpcontrol(8)</a>, estão incluídos na instalação padrão do FreeBSD. O exemplo a seguir mostra como executar uma consulta de navegação SDP.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% sdpcontrol <span class=nt>-a</span> 00:01:03:fc:6e:ec browse
Record Handle: 00000000
Service Class ID List:
        Service Discovery Server <span class=o>(</span>0x1000<span class=o>)</span>
Protocol Descriptor List:
        L2CAP <span class=o>(</span>0x0100<span class=o>)</span>
                Protocol specific parameter <span class=c>#1: u/int/uuid16 1</span>
                Protocol specific parameter <span class=c>#2: u/int/uuid16 1</span>

Record Handle: 0x00000001
Service Class ID List:
        Browse Group Descriptor <span class=o>(</span>0x1001<span class=o>)</span>

Record Handle: 0x00000002
Service Class ID List:
        LAN Access Using PPP <span class=o>(</span>0x1102<span class=o>)</span>
Protocol Descriptor List:
        L2CAP <span class=o>(</span>0x0100<span class=o>)</span>
        RFCOMM <span class=o>(</span>0x0003<span class=o>)</span>
                Protocol specific parameter <span class=c>#1: u/int8/bool 1</span>
Bluetooth Profile Descriptor List:
        LAN Access Using PPP <span class=o>(</span>0x1102<span class=o>)</span> ver. 1.0</code></pre></div></div><div class=paragraph><p>Observe que cada serviço tem uma lista de atributos, como o canal RFCOMM. Dependendo do serviço, o usuário pode precisar anotar alguns dos atributos. Algumas implementações Bluetooth não suportam a navegação de serviço e podem retornar uma lista vazia. Nesse caso, é possível procurar pelo serviço específico. O exemplo abaixo mostra como pesquisar o serviço OBEX Object Push (OPUSH) :</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% sdpcontrol <span class=nt>-a</span> 00:01:03:fc:6e:ec search OPUSH</code></pre></div></div><div class=paragraph><p>A oferta de serviços no FreeBSD para clientes Bluetooth é feita com o servidor <a href="https://man.freebsd.org/cgi/man.cgi?query=sdpd&amp;sektion=8&amp;format=html">sdpd(8)</a>. A seguinte linha pode ser adicionada ao <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>sdpd_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Então o daemon <a href="https://man.freebsd.org/cgi/man.cgi?query=sdpd&amp;sektion=8&amp;format=html">sdpd(8)</a> pode ser iniciado com:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service sdpd start</span></code></pre></div></div><div class=paragraph><p>O aplicativo de servidor local que deseja fornecer um serviço Bluetooth a clientes remotos registrará o serviço com o daemon SDP local . Um exemplo de tal aplicativo é o <a href="https://man.freebsd.org/cgi/man.cgi?query=rfcomm_pppd&amp;sektion=8&amp;format=html">rfcomm_pppd(8)</a>. Uma vez iniciado, ele registrará o serviço LAN Bluetooth com o daemon local SDP.</p></div><div class=paragraph><p>A lista de serviços registrados no servidor SDPlocal pode ser obtida através da emissão de uma consulta de navegação SDP através do canal de controle local:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sdpcontrol -l browse</span></code></pre></div></div></div><div class=sect3><h4 id=_obex_object_push_opush>31.5.5.4. OBEX Object Push (OPUSH)<a class=anchor href=#_obex_object_push_opush></a></h4><div class=paragraph><p>Object Exchange (OBEX) é um protocolo amplamente utilizado para transferências de arquivos simples entre dispositivos móveis. Seu principal uso é na comunicação por infravermelho, onde é usado para transferências de arquivos genéricos entre notebooks ou PDAs, e para enviar cartões de visita ou entradas de calendário entre telefones celulares e outros dispositivos com Personal Information Manager (PIM).</p></div><div class=paragraph><p>O servidor e o cliente OBEX são implementados pelo obexapp, que pode ser instalado usando o pacote ou port <a class=package href=https://cgit.freebsd.org/ports/tree/comms/obexapp/>comms/obexapp</a>.</p></div><div class=paragraph><p>O cliente OBEX é usado para empurrar e/ou puxar objetos do servidor OBEX. Um exemplo de objeto é um cartão de visita ou um compromisso. O cliente OBEX pode obter o número do canal RFCOMM do dispositivo remoto via SDP. Isso pode ser feito especificando o nome do serviço em vez do número do canal RFCOMM. Os nomes de serviços suportados são: <code>IrMC</code>, <code>FTRN</code> e <code>OPUSH</code>. Também é possível especificar o canal RFCOMM como um número. Abaixo está um exemplo de uma sessão OBEX em que o objeto de informações do dispositivo é extraído do telefone celular e um novo objeto, o cartão de visita, é inserido no diretório do telefone.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% obexapp <span class=nt>-a</span> 00:80:37:29:19:a4 <span class=nt>-C</span> IrMC
obex&gt; get telecom/devinfo.txt devinfo-t39.txt
Success, response: OK, Success <span class=o>(</span>0x20<span class=o>)</span>
obex&gt; put new.vcf
Success, response: OK, Success <span class=o>(</span>0x20<span class=o>)</span>
obex&gt; di
Success, response: OK, Success <span class=o>(</span>0x20<span class=o>)</span></code></pre></div></div><div class=paragraph><p>Para fornecer o serviço OPUSH, o <a href="https://man.freebsd.org/cgi/man.cgi?query=sdpd&amp;sektion=8&amp;format=html">sdpd(8)</a> deve estar em execução e uma pasta raiz, onde todos os objetos recebidos serão armazenados, deve ser criado. O caminho padrão para a pasta raiz é <span class=filename>/var/spool/obex</span>. Por fim, inicie o servidor OBEX em um número de canal RFCOMM válido. O servidor OBEX registrará automaticamente o serviço OPUSH com o daemon SDP local. O exemplo abaixo mostra como iniciar o servidor OBEX.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># obexapp -s -C 10</span></code></pre></div></div></div><div class=sect3><h4 id=_perfil_de_porta_serial_spp>31.5.5.5. Perfil de porta serial (SPP)<a class=anchor href=#_perfil_de_porta_serial_spp></a></h4><div class=paragraph><p>O perfil de porta serial (SPP) permite que dispositivos Bluetooth executem emulação de cabo serial. Este perfil permite que aplicativos legados usem o Bluetooth como um substituto de cabos, através de uma abstração de porta serial virtual.</p></div><div class=paragraph><p>No FreeBSD, o <a href="https://man.freebsd.org/cgi/man.cgi?query=rfcomm_sppd&amp;sektion=1&amp;format=html">rfcomm_sppd(1)</a> implementa o SPP e uma pseudo tty é usada como uma abstração de porta serial virtual. O exemplo abaixo mostra como se conectar ao serviço de porta serial de um dispositivo remoto. Um canal RFCOMM não precisa ser especificado uma vez que o <a href="https://man.freebsd.org/cgi/man.cgi?query=rfcomm_sppd&amp;sektion=1&amp;format=html">rfcomm_sppd(1)</a> pode obtê-lo a partir do dispositivo remoto via SDP. Para sobrescrever isso, especifique um canal RFCOMM na linha de comando.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># rfcomm_sppd -a 00:07:E0:00:0B:CA -t</span>
rfcomm_sppd[94692]: Starting on /dev/pts/6...
/dev/pts/6</code></pre></div></div><div class=paragraph><p>Uma vez conectado, o pseudo-tty pode ser usado como porta serial:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cu -l /dev/pts/6</span></code></pre></div></div><div class=paragraph><p>A pseudo-tty é impressa no stdout e pode ser lida por scripts de wrapper:</p></div><div class="literalblock programlisting"><div class=content><pre>PTS=`rfcomm_sppd -a 00:07:E0:00:0B:CA -t`
cu -l $PTS</pre></div></div></div></div><div class=sect2><h3 id=_solução_de_problemas_2>31.5.6. Solução de problemas<a class=anchor href=#_solução_de_problemas_2></a></h3><div class=paragraph><p>Por padrão, quando o FreeBSD está aceitando uma nova conexão, ele tenta executar uma troca de função e se tornar o mestre. Alguns dispositivos Bluetooth mais antigos que não suportam a troca de função não poderão se conectar. Como a troca de função é executada quando uma nova conexão está sendo estabelecida, não é possível perguntar ao dispositivo remoto se ele suporta a troca de função. No entanto, há uma opção HCI para desativar a alternância de funções no lado local:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># hccontrol -n ubt0hci write_node_role_switch 0</span></code></pre></div></div><div class=paragraph><p>Para exibir pacotes Bluetooth, use o pacote de terceiros hcidump, que pode ser instalado usando o pacote ou port <a class=package href=https://cgit.freebsd.org/ports/tree/comms/hcidump/>comms/hcidump</a>. Este utilitário é semelhante ao <a href="https://man.freebsd.org/cgi/man.cgi?query=tcpdump&amp;sektion=1&amp;format=html">tcpdump(1)</a> e pode ser usado para exibir o conteúdo dos pacotes Bluetooth no terminal e para descarregar os pacotes Bluetooth para um arquivo.</p></div></div></div></div><div class=sect1><h2 id=network-bridging>31.6. Bridging<a class=anchor href=#network-bridging></a></h2><div class=sectionbody><div class=paragraph><p>Às vezes, é útil dividir uma rede, como um segmento Ethernet, em segmentos de rede sem precisar criar subnets IP e usar um roteador para conectar os segmentos. Um dispositivo que conecta duas redes dessa maneira é chamado de "bridge".</p></div><div class=paragraph><p>Uma bridge funciona aprendendo os endereços MAC dos dispositivos em cada uma das suas interfaces de rede. Ele encaminha o tráfego entre as redes somente quando os endereços de origem e destino MAC estão em redes diferentes. Em muitos aspectos, uma brifge é como um switch Ethernet com poucas portas. Um sistema FreeBSD com múltiplas interfaces de rede pode ser configurado para atuar como uma bridge.</p></div><div class=paragraph><p>Construir uma bridge pode ser útil nas seguintes situações:</p></div><div class=dlist><dl><dt class=hdlist1>Conectar Redes</dt><dd><p>A operação básica de uma bridge é unir dois ou mais segmentos de rede. Existem muitas razões para usar uma bridge baseada em host em vez de equipamentos de rede, tais como restrições de cabeamento ou firewall. Uma bridge também pode conectar uma interface sem fio em execução no modo hostap a uma rede com fio e atuar como um ponto de acesso.</p></dd><dt class=hdlist1>Firewall de Filtragem / Limitação de Trafego</dt><dd><p>Uma bridge pode ser usada quando a funcionalidade de firewall é necessária sem a realização de roteamento ou conversão de endereços de rede (NAT).</p><div class=paragraph><p>Um exemplo é uma pequena empresa conectada via DSL ou ISDN a um ISP. Existem treze endereços IP públicos do ISP e dez computadores na rede. Nessa situação, é difícil usar um firewall baseado em roteador devido a problemas de sub-rede. Um firewall baseado em bridge pode ser configurado sem qualquer problema de endereçamento IP.</p></div></dd><dt class=hdlist1>Inspeção de Rede</dt><dd><p>Uma bridge pode unir dois segmentos de rede para inspecionar todos os pacotes Ethernet que passam entre elas usando <a href="https://man.freebsd.org/cgi/man.cgi?query=bpf&amp;sektion=4&amp;format=html">bpf(4)</a> e <a href="https://man.freebsd.org/cgi/man.cgi?query=tcpdump&amp;sektion=1&amp;format=html">tcpdump(1)</a> na interface de bridge ou enviando uma cópia de todos os frames para uma interface adicional conhecida como span port.</p></dd><dt class=hdlist1>VPN de Camada 2</dt><dd><p>Duas redes Ethernet podem ser unidas através de um link IP ligando as redes a um túnel EtherIP ou a uma solução baseada no <a href="https://man.freebsd.org/cgi/man.cgi?query=tap&amp;sektion=4&amp;format=html">tap(4)</a> tal como o OpenVPN.</p></dd><dt class=hdlist1>Redundância de Camada 2</dt><dd><p>Uma rede pode ser conectada com vários links e usar o protocolo Spanning Tree (STP) para bloquear caminhos redundantes.</p></dd></dl></div><div class=paragraph><p>Esta seção descreve como configurar um sistema FreeBSD como uma bridge usando o <a href="https://man.freebsd.org/cgi/man.cgi?query=if_bridge&amp;sektion=4&amp;format=html">if_bridge(4)</a>. Um driver de bridge netgraph também está disponível e é descrito em <a href="https://man.freebsd.org/cgi/man.cgi?query=ng_bridge&amp;sektion=4&amp;format=html">ng_bridge(4)</a>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>A filtragem de pacotes pode ser usada com qualquer pacote de firewall que se conecte ao framework <a href="https://man.freebsd.org/cgi/man.cgi?query=pfil&amp;sektion=9&amp;format=html">pfil(9)</a>. A bridge pode ser usada como um modelador de tráfego com o <a href="https://man.freebsd.org/cgi/man.cgi?query=altq&amp;sektion=4&amp;format=html">altq(4)</a> ou <a href="https://man.freebsd.org/cgi/man.cgi?query=dummynet&amp;sektion=4&amp;format=html">dummynet(4)</a>.</p></div></td></tr></tbody></table></div><div class=sect2><h3 id=_habilitando_a_bridge>31.6.1. Habilitando a Bridge<a class=anchor href=#_habilitando_a_bridge></a></h3><div class=paragraph><p>No FreeBSD, o <a href="https://man.freebsd.org/cgi/man.cgi?query=if_bridge&amp;sektion=4&amp;format=html">if_bridge(4)</a> é um módulo do kernel que é carregado automaticamente pelo <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a> ao criar uma interface de bridge. Também é possível compilar o suporte de bridge em um kernel customizado adicionando <code>device if_bridge</code> ao arquivo de configuração do kernel personalizado.</p></div><div class=paragraph><p>A bridge é criada usando clonagem de interface. Para criar a interface da bridge:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig bridge create</span>
bridge0
<span class=c># ifconfig bridge0</span>
bridge0: <span class=nv>flags</span><span class=o>=</span>8802&lt;BROADCAST,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        ether 96:3d:4b:f1:79:7a
        <span class=nb>id </span>00:00:00:00:00:00 priority 32768 hellotime 2 fwddelay 15
        maxage 20 holdcnt 6 proto rstp maxaddr 100 <span class=nb>timeout </span>1200
        root <span class=nb>id </span>00:00:00:00:00:00 priority 0 ifcost 0 port 0</code></pre></div></div><div class=paragraph><p>Quando uma interface de bridge é criada, ela recebe automaticamente um endereço Ethernet gerado aleatoriamente. Os parâmetros <code>maxaddr</code> e <code>timeout</code> controlam quantos endereços MAC a bridge manterá em sua tabela de encaminhamento e quantos segundos o sistema irá esperar antes de cada entrada ser removida após um endereço MAC ser visto pela última vez. Os outros parâmetros controlam como o STP opera.</p></div><div class=paragraph><p>Em seguida, especifique quais interfaces de rede adicionar como membros da bridge. Para a bridge encaminhar pacotes, todas as interfaces de membros e a bridge precisam estar ativas:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig bridge0 addm fxp0 addm fxp1 up</span>
<span class=c># ifconfig fxp0 up</span>
<span class=c># ifconfig fxp1 up</span></code></pre></div></div><div class=paragraph><p>A bridge agora pode encaminhar quadros Ethernet entre <span class=filename>fxp0</span> e <span class=filename>fxp1</span>. Adicione as seguintes linhas ao <span class=filename>/etc/rc.conf</span> para que a bridge seja criada na inicialização:</p></div><div class="literalblock programlisting"><div class=content><pre>cloned_interfaces=&#34;bridge0&#34;
ifconfig_bridge0=&#34;addm fxp0 addm fxp1 up&#34;
ifconfig_fxp0=&#34;up&#34;
ifconfig_fxp1=&#34;up&#34;</pre></div></div><div class=paragraph><p>Se o host de ponte precisar de um endereço IP, defina-o na interface de bridge, não nas interfaces de membro. O endereço pode ser definido estaticamente ou via DHCP. Este exemplo define um endereço IP estático:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig bridge0 inet 192.168.0.1/24</span></code></pre></div></div><div class=paragraph><p>Também é possível atribuir um endereço IPv6 a uma interface de bridge. Para tornar as mudanças permanentes, adicione as informações de endereçamento ao <span class=filename>/etc/rc.conf</span>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Quando a filtragem de pacotes está habilitada, os pacotes passarão pela entrada do filtro na interface de origem na interface da bridge e na saída nas interfaces apropriadas. Qualquer estágio pode ser desativado. Quando a direção do fluxo de pacotes é importante, é melhor usar o firewall nas interfaces de membros, em vez da própria bridge.</p></div><div class=paragraph><p>A bridge tem várias opções configuráveis para o trafego de pacotes IP e não-IP, e a filtragem de pacotes layer2 com o <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfw&amp;sektion=8&amp;format=html">ipfw(8)</a>. Veja <a href="https://man.freebsd.org/cgi/man.cgi?query=if_bridge&amp;sektion=4&amp;format=html">if_bridge(4)</a> para maiores informações.</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=_ativando_o_spanning_tree>31.6.2. Ativando o Spanning Tree<a class=anchor href=#_ativando_o_spanning_tree></a></h3><div class=paragraph><p>Para que uma rede Ethernet funcione corretamente, somente um caminho ativo pode existir entre dois dispositivos. O protocolo STP detecta loops e coloca links redundantes em um estado bloqueado. Se um dos links ativos falhar, o STP calcula uma árvore diferente e habilita um dos caminhos bloqueados para restaurar a conectividade a todos os pontos da rede.</p></div><div class=paragraph><p>O protocolo Rapid Spanning Tree (RSTP ou 802.1w) fornece compatibilidade retroativa com o STP legado. O RSTP fornece uma convergência mais rápida e troca informações com os switches vizinhos para fazer a transição rápida para o modo de encaminhamento sem criar loops. O FreeBSD suporta o RSTP e o STP como modos de operação, com o RSTP sendo o modo padrão.</p></div><div class=paragraph><p>O STP pode ser ativado nas interfaces de membro usando o <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a>. Para uma bridge com <span class=filename>fxp0</span> e <span class=filename>fxp1</span> como as interfaces atuais, ative o STP com:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig bridge0 stp fxp0 stp fxp1</span>
bridge0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        ether d6:cf:d5:a0:94:6d
        <span class=nb>id </span>00:01:02:4b:d4:50 priority 32768 hellotime 2 fwddelay 15
        maxage 20 holdcnt 6 proto rstp maxaddr 100 <span class=nb>timeout </span>1200
        root <span class=nb>id </span>00:01:02:4b:d4:50 priority 32768 ifcost 0 port 0
        member: fxp0 <span class=nv>flags</span><span class=o>=</span>1c7&lt;LEARNING,DISCOVER,STP,AUTOEDGE,PTP,AUTOPTP&gt;
                port 3 priority 128 path cost 200000 proto rstp
                role designated state forwarding
        member: fxp1 <span class=nv>flags</span><span class=o>=</span>1c7&lt;LEARNING,DISCOVER,STP,AUTOEDGE,PTP,AUTOPTP&gt;
                port 4 priority 128 path cost 200000 proto rstp
                role designated state forwarding</code></pre></div></div><div class=paragraph><p>Essa ponte possui um spanning tree ID de <code>00:01:02:4b:d4:50</code> e uma prioridade de <code>32768</code>. Como o <code>root id</code> é o mesmo, indica que esta é a bridge raiz para a árvore.</p></div><div class=paragraph><p>Outra bridge na rede também tem o STP ativado:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>bridge0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        ether 96:3d:4b:f1:79:7a
        <span class=nb>id </span>00:13:d4:9a:06:7a priority 32768 hellotime 2 fwddelay 15
        maxage 20 holdcnt 6 proto rstp maxaddr 100 <span class=nb>timeout </span>1200
        root <span class=nb>id </span>00:01:02:4b:d4:50 priority 32768 ifcost 400000 port 4
        member: fxp0 <span class=nv>flags</span><span class=o>=</span>1c7&lt;LEARNING,DISCOVER,STP,AUTOEDGE,PTP,AUTOPTP&gt;
                port 4 priority 128 path cost 200000 proto rstp
                role root state forwarding
        member: fxp1 <span class=nv>flags</span><span class=o>=</span>1c7&lt;LEARNING,DISCOVER,STP,AUTOEDGE,PTP,AUTOPTP&gt;
                port 5 priority 128 path cost 200000 proto rstp
                role designated state forwarding</code></pre></div></div><div class=paragraph><p>A linha <code>root id 00:01:02:4b:d4:50 priority 32768 ifcost 400000 port 4</code> mostra que a bridge raiz é <code>00:01:02:4b:d4:50</code> e tem um custo de caminho de <code>400000</code> desta bridge. O caminho para a bridge raiz é via <code>port 4</code>, que é <span class=filename>fxp0</span>.</p></div></div><div class=sect2><h3 id=_parâmetros_da_interface_de_bridge>31.6.3. Parâmetros da Interface de Bridge<a class=anchor href=#_parâmetros_da_interface_de_bridge></a></h3><div class=paragraph><p>Vários parâmetros do <code>ifconfig</code> são exclusivos para interligar interfaces. Esta seção resume alguns usos comuns para esses parâmetros. A lista completa de parâmetros disponíveis é descrita em <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a>.</p></div><div class=dlist><dl><dt class=hdlist1>privado</dt><dd><p>Uma interface privada não encaminha qualquer tráfego para qualquer outra porta que também seja designada como uma interface privada. O tráfego é bloqueado incondicionalmente para que nenhum quadro Ethernet seja encaminhado, incluindo pacotes ARP. Se o tráfego precisar ser bloqueado seletivamente, um firewall deve ser usado no lugar.</p></dd><dt class=hdlist1>span</dt><dd><p>Uma porta span transmite uma cópia de cada quadro Ethernet recebido pela bridge. O número de portas de span configuradas em uma bridge é ilimitado, mas se uma interface for designada como uma porta de span, ela também não poderá ser usada como uma porta de bridge comum. Isso é mais útil para espionar passivamente uma rede em bridge a partir de outro host conectado a uma das portas da bridge. Por exemplo, para enviar uma cópia de todos os quadros para fora da interface denominada <span class=filename>fxp4</span>:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig bridge0 span fxp4</span></code></pre></div></div></dd><dt class=hdlist1>sticky</dt><dd><p>Se uma interface de membro de uma bridge estiver marcada como fixa, as entradas de endereço aprendidas dinamicamente serão tratadas como entradas estáticas no cache de encaminhamento. Entradas fixas nunca são eliminadas do cache ou substituídas, mesmo que o endereço seja visto em uma interface diferente. Isso oferece o benefício de entradas de endereço estático sem a necessidade de preencher previamente a tabela de encaminhamento. Os clientes aprendidos em um segmento específico da bridge não podem se deslocar para outro segmento.</p><div class=paragraph><p>Um exemplo do uso de endereços fixos é combinar a bridge com VLANs para isolar redes de clientes sem desperdiçar espaço de endereço IP. Considere que <code>CustomerA</code> está em <code>vlan100</code>, <code>CustomerB</code> está em <code>vlan101</code>, e a bridge tem o endereço <code>192.168.0.1</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig bridge0 addm vlan100 sticky vlan100 addm vlan101 sticky vlan101</span>
<span class=c># ifconfig bridge0 inet 192.168.0.1/24</span></code></pre></div></div><div class=paragraph><p>Neste exemplo, os dois clientes vêem <code>192.168.0.1</code> como seu gateway padrão. Como o cache da bridge é fixo, um host não pode falsificar o endereço MAC do outro cliente para interceptar o tráfego.</p></div><div class=paragraph><p>Qualquer comunicação entre as VLANs pode ser bloqueada usando um firewall ou, como visto neste exemplo, interfaces privadas:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig bridge0 private vlan100 private vlan101</span></code></pre></div></div><div class=paragraph><p>Os clientes são completamente isolados uns dos outros e o intervalo completo de endereços <code>/24</code> pode ser alocado sem criação de sub-redes.</p></div><div class=paragraph><p>O número de endereços MAC de origem exclusivos por trás de uma interface pode ser limitado. Quando o limite é atingido, os pacotes com endereços de origem desconhecidos são descartados até que uma entrada de cache do host existente expire ou seja removida.</p></div><div class=paragraph><p>O exemplo a seguir define o número máximo de dispositivos Ethernet para <code>CustomerA</code> em <code>vlan100</code> para 10:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig bridge0 ifmaxaddr vlan100 10</span></code></pre></div></div></dd></dl></div><div class=paragraph><p>As interfaces de bridge também suportam o modo monitor, onde os pacotes são descartados após processamento do <a href="https://man.freebsd.org/cgi/man.cgi?query=bpf&amp;sektion=4&amp;format=html">bpf(4)</a> e não são processados ou encaminhados. Isso pode ser usado para multiplexar a entrada de duas ou mais interfaces em um único fluxo <a href="https://man.freebsd.org/cgi/man.cgi?query=bpf&amp;sektion=4&amp;format=html">bpf(4)</a>. Isso é útil para reconstruir o tráfego de taps de rede que transmitem os sinais RX/TX através de duas interfaces separadas. Por exemplo, para ler a entrada de quatro interfaces de rede como um fluxo:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig bridge0 addm fxp0 addm fxp1 addm fxp2 addm fxp3 monitor up</span>
<span class=c># tcpdump -i bridge0</span></code></pre></div></div></div><div class=sect2><h3 id=_monitoramento_snmp>31.6.4. Monitoramento SNMP<a class=anchor href=#_monitoramento_snmp></a></h3><div class=paragraph><p>A interface de bridge e os parâmetros de STP podem ser monitorados via o <a href="https://man.freebsd.org/cgi/man.cgi?query=bsnmpd&amp;sektion=1&amp;format=html">bsnmpd(1)</a> o qual está incluído no sistema básico do FreeBSD. A MIB exportada da bridge está em conformidade com os padrões IETF, portanto, qualquer cliente ou pacote de monitoramento SNMP pode ser usado para recuperar os dados.</p></div><div class=paragraph><p>Para ativar o monitoramento na bridge, descomente esta linha em <span class=filename>/etc/snmpd.config</span> removendo o símbolo inicial <code>#</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>begemotSnmpdModulePath.&#34;bridge&#34; = &#34;/usr/lib/snmp_bridge.so&#34;</pre></div></div><div class=paragraph><p>Outras configurações, como nomes de comunidades e listas de acesso, podem precisar ser modificadas nesse arquivo. Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=bsnmpd&amp;sektion=1&amp;format=html">bsnmpd(1)</a> e <a href="https://man.freebsd.org/cgi/man.cgi?query=snmp_bridge&amp;sektion=3&amp;format=html">snmp_bridge(3)</a> para maiores informações. Depois que essas edições forem salvas, adicione esta linha ao <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>bsnmpd_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Em seguida, inicie o <a href="https://man.freebsd.org/cgi/man.cgi?query=bsnmpd&amp;sektion=1&amp;format=html">bsnmpd(1)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service bsnmpd start</span></code></pre></div></div><div class=paragraph><p>Os exemplos a seguir usam o software Net-SNMP (<a class=package href=https://cgit.freebsd.org/ports/tree/net-mgmt/net-snmp/>net-mgmt/net-snmp</a>) para consultar uma bridge a partir de um sistema cliente. O port <a class=package href=https://cgit.freebsd.org/ports/tree/net-mgmt/bsnmptools/>net-mgmt/bsnmptools</a> também pode ser usado. Do cliente SNMP que está executando o Net-SNMP, adicione as seguintes linhas ao <span class=filename>$HOME/.snmp/snmp.conf</span> para importar as definições da bridge MIB:</p></div><div class="literalblock programlisting"><div class=content><pre>mibdirs +/usr/shared/snmp/mibs
mibs +BRIDGE-MIB:RSTP-MIB:BEGEMOT-MIB:BEGEMOT-BRIDGE-MIB</pre></div></div><div class=paragraph><p>Para monitorar uma única bridge usando o IETF BRIDGE-MIB (RFC4188):</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% snmpwalk <span class=nt>-v</span> 2c <span class=nt>-c</span> public bridge1.example.com mib-2.dot1dBridge
BRIDGE-MIB::dot1dBaseBridgeAddress.0 <span class=o>=</span> STRING: 66:fb:9b:6e:5c:44
BRIDGE-MIB::dot1dBaseNumPorts.0 <span class=o>=</span> INTEGER: 1 ports
BRIDGE-MIB::dot1dStpTimeSinceTopologyChange.0 <span class=o>=</span> Timeticks: <span class=o>(</span>189959<span class=o>)</span> 0:31:39.59 centi-seconds
BRIDGE-MIB::dot1dStpTopChanges.0 <span class=o>=</span> Counter32: 2
BRIDGE-MIB::dot1dStpDesignatedRoot.0 <span class=o>=</span> Hex-STRING: 80 00 00 01 02 4B D4 50
...
BRIDGE-MIB::dot1dStpPortState.3 <span class=o>=</span> INTEGER: forwarding<span class=o>(</span>5<span class=o>)</span>
BRIDGE-MIB::dot1dStpPortEnable.3 <span class=o>=</span> INTEGER: enabled<span class=o>(</span>1<span class=o>)</span>
BRIDGE-MIB::dot1dStpPortPathCost.3 <span class=o>=</span> INTEGER: 200000
BRIDGE-MIB::dot1dStpPortDesignatedRoot.3 <span class=o>=</span> Hex-STRING: 80 00 00 01 02 4B D4 50
BRIDGE-MIB::dot1dStpPortDesignatedCost.3 <span class=o>=</span> INTEGER: 0
BRIDGE-MIB::dot1dStpPortDesignatedBridge.3 <span class=o>=</span> Hex-STRING: 80 00 00 01 02 4B D4 50
BRIDGE-MIB::dot1dStpPortDesignatedPort.3 <span class=o>=</span> Hex-STRING: 03 80
BRIDGE-MIB::dot1dStpPortForwardTransitions.3 <span class=o>=</span> Counter32: 1
RSTP-MIB::dot1dStpVersion.0 <span class=o>=</span> INTEGER: rstp<span class=o>(</span>2<span class=o>)</span></code></pre></div></div><div class=paragraph><p>O valor <code>dot1dStpTopChanges.0</code> é dois, indicando que a topologia da bridge STP foi alterada duas vezes. Uma alteração de topologia significa que um ou mais links na rede foram alterados ou falharam e uma nova árvore foi calculada. O valor de <code>dot1dStpTimeSinceTopologyChange.0</code> será exibido quando isso acontecer.</p></div><div class=paragraph><p>Para monitorar várias interfaces de bridge, o BEGEMOT-BRIDGE-MIB privado pode ser usado:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% snmpwalk <span class=nt>-v</span> 2c <span class=nt>-c</span> public bridge1.example.com
enterprises.fokus.begemot.begemotBridge
BEGEMOT-BRIDGE-MIB::begemotBridgeBaseName.<span class=s2>&#34;bridge0&#34;</span> <span class=o>=</span> STRING: bridge0
BEGEMOT-BRIDGE-MIB::begemotBridgeBaseName.<span class=s2>&#34;bridge2&#34;</span> <span class=o>=</span> STRING: bridge2
BEGEMOT-BRIDGE-MIB::begemotBridgeBaseAddress.<span class=s2>&#34;bridge0&#34;</span> <span class=o>=</span> STRING: e:ce:3b:5a:9e:13
BEGEMOT-BRIDGE-MIB::begemotBridgeBaseAddress.<span class=s2>&#34;bridge2&#34;</span> <span class=o>=</span> STRING: 12:5e:4d:74:d:fc
BEGEMOT-BRIDGE-MIB::begemotBridgeBaseNumPorts.<span class=s2>&#34;bridge0&#34;</span> <span class=o>=</span> INTEGER: 1
BEGEMOT-BRIDGE-MIB::begemotBridgeBaseNumPorts.<span class=s2>&#34;bridge2&#34;</span> <span class=o>=</span> INTEGER: 1
...
BEGEMOT-BRIDGE-MIB::begemotBridgeStpTimeSinceTopologyChange.<span class=s2>&#34;bridge0&#34;</span> <span class=o>=</span> Timeticks: <span class=o>(</span>116927<span class=o>)</span> 0:19:29.27 centi-seconds
BEGEMOT-BRIDGE-MIB::begemotBridgeStpTimeSinceTopologyChange.<span class=s2>&#34;bridge2&#34;</span> <span class=o>=</span> Timeticks: <span class=o>(</span>82773<span class=o>)</span> 0:13:47.73 centi-seconds
BEGEMOT-BRIDGE-MIB::begemotBridgeStpTopChanges.<span class=s2>&#34;bridge0&#34;</span> <span class=o>=</span> Counter32: 1
BEGEMOT-BRIDGE-MIB::begemotBridgeStpTopChanges.<span class=s2>&#34;bridge2&#34;</span> <span class=o>=</span> Counter32: 1
BEGEMOT-BRIDGE-MIB::begemotBridgeStpDesignatedRoot.<span class=s2>&#34;bridge0&#34;</span> <span class=o>=</span> Hex-STRING: 80 00 00 40 95 30 5E 31
BEGEMOT-BRIDGE-MIB::begemotBridgeStpDesignatedRoot.<span class=s2>&#34;bridge2&#34;</span> <span class=o>=</span> Hex-STRING: 80 00 00 50 8B B8 C6 A9</code></pre></div></div><div class=paragraph><p>Para alterar a interface da bridge que está sendo monitorada através da subárvore <code>mib-2.dot1dBridge</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% snmpset <span class=nt>-v</span> 2c <span class=nt>-c</span> private bridge1.example.com
BEGEMOT-BRIDGE-MIB::begemotBridgeDefaultBridgeIf.0 s bridge2</code></pre></div></div></div></div></div><div class=sect1><h2 id=network-aggregation>31.7. Agregação de links e failover<a class=anchor href=#network-aggregation></a></h2><div class=sectionbody><div class=paragraph><p>O FreeBSD fornece a interface <a href="https://man.freebsd.org/cgi/man.cgi?query=lagg&amp;sektion=4&amp;format=html">lagg(4)</a> que pode ser usada para agregar várias interfaces de rede em uma interface virtual para fornecer failover e agregação de links. O failover permite que o tráfego continue a fluir, desde que pelo menos uma interface de rede agregada tenha um link estabelecido. A agregação de links funciona melhor em switches compatíveis com LACP, pois esse protocolo distribui o tráfego bidirecionalmente ao responder à falha de links individuais.</p></div><div class=paragraph><p>Os protocolos de agregação suportados pela interface lagg determinam quais portas são usadas para o tráfego de saída e se uma porta específica aceita tráfego de entrada. Os seguintes protocolos são suportados pelo <a href="https://man.freebsd.org/cgi/man.cgi?query=lagg&amp;sektion=4&amp;format=html">lagg(4)</a>:</p></div><div class=dlist><dl><dt class=hdlist1>failover</dt><dd><p>Este modo envia e recebe tráfego somente através da porta principal. Se a porta principal ficar indisponível, a próxima porta ativa será usada. A primeira interface adicionada à interface virtual é a porta principal e todas as interfaces adicionadas posteriormente são usadas como dispositivos de failover. Se ocorrer um failover em uma porta não mestre, a porta original se tornará a principal quando estiver disponível novamente.</p></dd><dt class=hdlist1>fec / loadbalance</dt><dd><p>Cisco™ Fast EtherChannel™ (FEC) é encontrado em versões anteriores de switches Cisco ™. Ele fornece uma configuração estática e não negocia a agregação com o par ou troca quadros para monitorar o link. Se o switch suportar LACP, isso deve ser usado em seu lugar.</p></dd><dt class=hdlist1>lacp</dt><dd><p>O protocolo de controle de agregação de links IEEE™ 802.3ad (LACP) negocia um conjunto de links agregáveis com o peer em um ou mais grupos agregados de links (LAGs). Cada LAG é composto de portas da mesma velocidade, configuradas para operação full-duplex e o tráfego é balanceado entre as portas no LAG com a maior velocidade total. Normalmente, há apenas um LAG que contém todas as portas. No caso de alterações na conectividade física, o LACP convergirá rapidamente para uma nova configuração.</p><div class=paragraph><p>O LACP equilibra o tráfego de saída nas portas ativas com base nas informações de hash do cabeçalho do protocolo e aceita tráfego de entrada de qualquer porta ativa. O hash inclui o endereço Ethernet de origem e destino e, se disponível, a tag VLAN e o endereço de origem e destino IPv4 ou IPv6.</p></div></dd><dt class=hdlist1>roundrobin</dt><dd><p>Esse modo distribui o tráfego de saída usando um agendador round-robin por meio de todas as portas ativas e aceita tráfego de entrada de qualquer porta ativa. Como esse modo viola a ordenação de quadros Ethernet, ele deve ser usado com cautela.</p></dd></dl></div><div class=sect2><h3 id=_exemplos_de_configuração>31.7.1. Exemplos de configuração<a class=anchor href=#_exemplos_de_configuração></a></h3><div class=paragraph><p>Esta seção demonstra como configurar um switch Cisco™ e um sistema FreeBSD para balanceamento de carga LACP. Em seguida, ele mostra como configurar duas interfaces Ethernet no modo de failover, além de como configurar o modo de failover entre uma Ethernet e uma interface sem fio.</p></div><div id=networking-lacp-aggregation-cisco class=exampleblock><div class=title>Exemplo 1. Agregação LACP com um switch Cisco™</div><div class=content><div class=paragraph><p>Este exemplo conecta duas interfaces Ethernet <a href="https://man.freebsd.org/cgi/man.cgi?query=fxp&amp;sektion=4&amp;format=html">fxp(4)</a> em uma máquina FreeBSD às duas primeiras portas Ethernet em um switch Cisco™ como um link de carga única balanceada e tolerante a falhas. Mais interfaces podem ser adicionadas para aumentar o rendimento e a tolerância a falhas. Substitua os nomes das portas Cisco™, dos dispositivos Ethernet, do número do grupo de canais e do endereço IP mostrado no exemplo para corresponder à configuração local.</p></div><div class=paragraph><p>A ordenação de quadros é obrigatória em links Ethernet e qualquer tráfego entre duas estações sempre flui pelo mesmo link físico, limitando a velocidade máxima àquela de uma interface. O algoritmo de transmissão tenta usar o máximo de informações possível para distinguir diferentes fluxos de tráfego e equilibrar os fluxos entre as interfaces disponíveis.</p></div><div class=paragraph><p>No switch Cisco™, adicione as interfaces <em>FastEthernet0/1</em> e <em>FastEthernet0/2</em> ao grupo de canais <em>1</em>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> interface FastEthernet0/1
 channel-group 1 mode active
 channel-protocol lacp
<span class=o>!</span>
interface FastEthernet0/2
 channel-group 1 mode active
 channel-protocol lacp</code></pre></div></div><div class=paragraph><p>No sistema FreeBSD, crie a interface <a href="https://man.freebsd.org/cgi/man.cgi?query=lagg&amp;sektion=4&amp;format=html">lagg(4)</a> usando as interfaces físicas <em>fxp0</em> e <em>fxp1</em> e suba as interfaces com o endereço IP de <em>10.0.0.3/24</em>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig fxp0 up</span>
<span class=c># ifconfig fxp1 up</span>
<span class=c># ifconfig lagg0 create</span>
<span class=c># ifconfig lagg0 up laggproto lacp laggport fxp0 laggport fxp1 10.0.0.3/24</span></code></pre></div></div><div class=paragraph><p>Em seguida, verifique o status da interface virtual:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig lagg0</span>
lagg0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        <span class=nv>options</span><span class=o>=</span>8&lt;VLAN_MTU&gt;
        ether 00:05:5d:71:8d:b8
        inet 10.0.0.3 netmask 0xffffff00 broadcast 10.0.0.255
        media: Ethernet autoselect
        status: active
        laggproto lacp
        laggport: fxp1 <span class=nv>flags</span><span class=o>=</span>1c&lt;ACTIVE,COLLECTING,DISTRIBUTING&gt;
        laggport: fxp0 <span class=nv>flags</span><span class=o>=</span>1c&lt;ACTIVE,COLLECTING,DISTRIBUTING&gt;</code></pre></div></div><div class=paragraph><p>Portas marcadas como <code>ACTIVE</code> fazem parte do LAG que foi negociado com o switch remoto. O tráfego será transmitido e recebido através dessas portas ativas. Adicione <code>-v</code> ao comando acima para ver os identificadores LAG.</p></div><div class=paragraph><p>Para ver o status da porta no switch Cisco™:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>switch# show lacp neighbor
Flags:  S - Device is requesting Slow LACPDUs
        F - Device is requesting Fast LACPDUs
        A - Device is <span class=k>in </span>Active mode       P - Device is <span class=k>in </span>Passive mode

Channel group 1 neighbors

Partner<span class=s1>&#39;s information:

                  LACP port                        Oper    Port     Port
Port      Flags   Priority  Dev ID         Age     Key     Number   State
Fa0/1     SA      32768     0005.5d71.8db8  29s    0x146   0x3      0x3D
Fa0/2     SA      32768     0005.5d71.8db8  29s    0x146   0x4      0x3D</span></code></pre></div></div><div class=paragraph><p>Para mais detalhes, digite <code>show lacp neighbor detail</code>.</p></div><div class=paragraph><p>Para manter esta configuração através de reinicializações, adicione as seguintes entradas ao <span class=filename>/etc/rc.conf</span> no sistema FreeBSD:</p></div><div class="literalblock programlisting"><div class=content><pre>ifconfig_fxp0=&#34;up&#34;
ifconfig_fxp1=&#34;up&#34;
cloned_interfaces=&#34;lagg0&#34;
ifconfig_lagg0=&#34;laggproto lacp laggport fxp0 laggport fxp1 10.0.0.3/24&#34;</pre></div></div></div></div><div id=networking-lagg-failover class=exampleblock><div class=title>Exemplo 2. Modo de Failover</div><div class=content><div class=paragraph><p>O modo de failover pode ser usado para alternar para uma interface secundária se o link for perdido na interface principal. Para configurar o failover, certifique-se de que as interfaces físicas subjacentes estejam ativadas e crie a interface <a href="https://man.freebsd.org/cgi/man.cgi?query=lagg&amp;sektion=4&amp;format=html">lagg(4)</a>. Neste exemplo, <em>fxp0</em> é a interface principal, <em>fxp1</em> é a interface secundária e a interface virtual recebeu um endereço IP de <em>10.0.0.15/24</em>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig fxp0 up</span>
<span class=c># ifconfig fxp1 up</span>
<span class=c># ifconfig lagg0 create</span>
<span class=c># ifconfig lagg0 up laggproto failover laggport fxp0 laggport fxp1 10.0.0.15/24</span></code></pre></div></div><div class=paragraph><p>A interface virtual deve ser algo como isto:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig lagg0</span>
lagg0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        <span class=nv>options</span><span class=o>=</span>8&lt;VLAN_MTU&gt;
        ether 00:05:5d:71:8d:b8
        inet 10.0.0.15 netmask 0xffffff00 broadcast 10.0.0.255
        media: Ethernet autoselect
        status: active
        laggproto failover
        laggport: fxp1 <span class=nv>flags</span><span class=o>=</span>0&lt;<span class=o>&gt;</span>
        laggport: fxp0 <span class=nv>flags</span><span class=o>=</span>5&lt;MASTER,ACTIVE&gt;</code></pre></div></div><div class=paragraph><p>O tráfego será transmitido e recebido em <em>fxp0</em>. Se o link for perdido em <em>fxp0</em>, <em>fxp1</em> se tornará o link ativo. Se o link for restaurado na interface principal, ele se tornará novamente o link ativo.</p></div><div class=paragraph><p>Para manter essa configuração através de reinicializações, adicione as seguintes entradas ao <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>ifconfig_fxp0=&#34;up&#34;
ifconfig_fxp1=&#34;up&#34;
cloned_interfaces=&#34;lagg0&#34;
ifconfig_lagg0=&#34;laggproto failover laggport fxp0 laggport fxp1 10.0.0.15/24&#34;</pre></div></div></div></div><div id=networking-lagg-wired-and-wireless class=exampleblock><div class=title>Exemplo 3. Modo de failover entre interfaces Ethernet e sem fio</div><div class=content><div class=paragraph><p>Para usuários de laptop, geralmente é desejável configurar o dispositivo sem fio como secundário, que é usado somente quando a conexão Ethernet não está disponível. Com <a href="https://man.freebsd.org/cgi/man.cgi?query=lagg&amp;sektion=4&amp;format=html">lagg(4)</a>, é possível configurar um failover que preferia a conexão Ethernet por motivos de desempenho e de segurança, mantendo a capacidade de transferência dados através da conexão sem fio.</p></div><div class=paragraph><p>Isso é obtido substituindo o endereço MAC da interface Ethernet com o da interface wireless.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Em teoria, o endereço MAC da Ethernet ou da wireless pode ser alterado para corresponder ao outro. No entanto, algumas interfaces wireless populares não têm suporte para substituir o endereço MAC. Portanto, recomendamos substituir o endereço MAC da Ethernet para esse fim.</p></div></td></tr></tbody></table></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Se o driver para a interface wireless não estiver carregado no kernel <code>GENERIC</code> ou customizado, e o computador estiver rodando o FreeBSD 12.1, carregue o <span class=filename>.ko</span> correspondente no arquivo <span class=filename>/boot/loader.conf</span> adicionando <code>_driver__load="YES"</code> e reiniciando a maquina. Outra forma melhor, é carregar o driver no arquivo <span class=filename>/etc/rc.conf</span> adicionando a variável <code>kld_list</code> (veja <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a> para maiores detalhes) nesse arquivo e reiniciar. Isso é necessário porque de outra forma o driver não estará carregado no tempo em que a interface <a href="https://man.freebsd.org/cgi/man.cgi?query=lagg&amp;sektion=4&amp;format=html">lagg(4)</a> for configurada.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Neste exemplo, a interface Ethernet, <em>re0</em>, é a interface principal e a interface sem fio, <em>wlan0</em>, é o failover. A interface <em>wlan0</em> foi criada a partir da interface wireless <em>ath0</em>, e a interface Ethernet será configurada com o endereço MAC da interface wireless. Primeiro, determine o endereço MAC da interface wireless:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0</span>
wlan0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
	ether b8:ee:65:5b:32:59
	<span class=nb>groups</span>: wlan
	ssid Bbox-A3BD2403 channel 6 <span class=o>(</span>2437 MHz 11g ht/20<span class=o>)</span> bssid 00:37:b7:56:4b:60
	regdomain ETSI country FR indoor ecm authmode WPA2/802.11i privacy ON
	deftxkey UNDEF AES-CCM 2:128-bit txpower 30 bmiss 7 scanvalid 60
	protmode CTS ampdulimit 64k ampdudensity 8 shortgi <span class=nt>-stbctx</span> stbcrx
	<span class=nt>-ldpc</span> wme burst roaming MANUAL
	media: IEEE 802.11 Wireless Ethernet MCS mode 11ng
	status: associated
	nd6 <span class=nv>options</span><span class=o>=</span>29&lt;PERFORMNUD,IFDISABLED,AUTO_LINKLOCAL&gt;</code></pre></div></div><div class=paragraph><p>Substitua <em>wlan0</em> para corresponder ao nome da interface wireless do sistema. A linha <code>ether</code> conterá o endereço MAC da interface especificada. Agora, altere o endereço MAC da interface Ethernet subjacente:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig re0 ether b8:ee:65:5b:32:59</span></code></pre></div></div><div class=paragraph><p>Suba a interface sem fio (substituindo <em>FR</em> pelo seu próprio código de país com duas letras), mas não defina um endereço IP:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0 create wlandev ath0 country FR ssid my_router up</span></code></pre></div></div><div class=paragraph><p>Certifique-se de que a interface <em>re0</em> esteja ativa, então crie a interface <a href="https://man.freebsd.org/cgi/man.cgi?query=lagg&amp;sektion=4&amp;format=html">lagg(4)</a> com a <em>re0</em> como master com failover para a_wlan0_:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig re0 up</span>
<span class=c># ifconfig lagg0 create</span>
<span class=c># ifconfig lagg0 up laggproto failover laggport re0 laggport wlan0</span></code></pre></div></div><div class=paragraph><p>A interface virtual deve ser algo como isto:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig lagg0</span>
lagg0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        <span class=nv>options</span><span class=o>=</span>8&lt;VLAN_MTU&gt;
        ether b8:ee:65:5b:32:59
        laggproto failover lagghash l2,l3,l4
        laggport: re0 <span class=nv>flags</span><span class=o>=</span>5&lt;MASTER,ACTIVE&gt;
        laggport: wlan0 <span class=nv>flags</span><span class=o>=</span>0&lt;<span class=o>&gt;</span>
        <span class=nb>groups</span>: lagg
        media: Ethernet autoselect
        status: active</code></pre></div></div><div class=paragraph><p>Em seguida, inicie o cliente DHCP para obter um endereço IP:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dhclient lagg0</span></code></pre></div></div><div class=paragraph><p>Para manter essa configuração através de reinicializações, adicione as seguintes entradas ao <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>ifconfig_re0=&#34;ether b8:ee:65:5b:32:59&#34;
wlans_ath0=&#34;wlan0&#34;
ifconfig_wlan0=&#34;WPA&#34;
create_args_wlan0=&#34;country FR&#34;
cloned_interfaces=&#34;lagg0&#34;
ifconfig_lagg0=&#34;up laggproto failover laggport re0 laggport wlan0 DHCP&#34;</pre></div></div></div></div></div></div></div><div class=sect1><h2 id=network-diskless>31.8. Operação Diskless com PXE<a class=anchor href=#network-diskless></a></h2><div class=sectionbody><div class=paragraph><p>O Ambiente de execução de pré-inicialização da Intel™ (PXE) permite que um sistema operacional inicialize pela rede. Por exemplo, um sistema FreeBSD pode inicializar através da rede e operar sem um disco local, usando sistemas de arquivos montados a partir de um servidor NFS. O suporte para PXE geralmente está disponível no BIOS. Para usar o PXE quando a máquina iniciar, selecione a opção <code>Inicialização da rede</code> na configuração do BIOS ou digite uma tecla de função durante a inicialização do sistema.</p></div><div class=paragraph><p>Para fornecer os arquivos necessários para um sistema operacional inicializar pela rede, uma configuração do PXE também requer o DHCP, TFTP configurado corretamente e Servidores NFS, onde:</p></div><div class=ulist><ul><li><p>Parâmetros iniciais, como endereço de IP, nome e localização do arquivo de inicialização executável, nome do servidor e caminho do root são obtidos do servidor DHCP.</p></li><li><p>O arquivo do carregador do sistema operacional é inicializado usando TFTP.</p></li><li><p>Os sistemas de arquivos são carregados usando o NFS.</p></li></ul></div><div class=paragraph><p>Quando um computador PXE inicializa, ele recebe informações por meio do DHCP sobre onde obter o arquivo inicial do carregador de boot. Depois que o computador host recebe essa informação, ele faz o download do carregador de boot via TFTP e, em seguida, executa o carregador de boot. No FreeBSD, o arquivo do gerenciador de boot é o <span class=filename>/boot/pxeboot</span>. Depois que o <span class=filename>/boot/pxeboot</span> é executado, o kernel do FreeBSD é carregado e o resto da seqüência de inicialização do FreeBSD continua, como descrito em <a href=../boot/#boot>O processo de inicialização do FreeBSD</a>.</p></div><div class=paragraph><p>Esta seção descreve como configurar estes serviços em um sistema FreeBSD para que outros sistemas possam inicializar o PXE a partir do FreeBSD. Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=diskless&amp;sektion=8&amp;format=html">diskless(8)</a> para obter maiores informações.</p></div><div class="admonitionblock caution"><table><tbody><tr><td class=icon><i class="fa icon-caution" title=Caution></i></td><td class=content><div class=paragraph><p>Conforme descrito, o sistema que fornece esses serviços é inseguro. Ele deve ficar em uma área protegida de uma rede e não deve ser considerado confiável por outros hosts.</p></div></td></tr></tbody></table></div><div class=sect2><h3 id=network-pxe-nfs>31.8.1. Configurando o ambiente PXE<a class=anchor href=#network-pxe-nfs></a></h3><div class=paragraph><p>As etapas mostradas nesta seção configuram os servidores internos de NFS e TFTP. A próxima seção demonstra como instalar e configurar o servidor DHCP. Neste exemplo, o diretório que conterá os arquivos usados pelos usuários do PXE é o <span class=filename>/b/tftpboot/FreeBSD/install</span>. É importante que este diretório exista e que o mesmo nome de diretório seja configurado no <span class=filename>/etc/inetd.conf</span> e no <span class=filename>/usr/local/etc/dhcpd.conf</span>.</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Crie o diretório raiz que irá conter uma instalação do FreeBSD para ser montado por NFS:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># export NFSROOTDIR=/b/tftpboot/FreeBSD/install</span>
<span class=c># mkdir -p ${NFSROOTDIR}</span></code></pre></div></div></li><li><p>Ative o servidor NFS adicionando esta linha ao <span class=filename>/etc/rc.conf</span>:</p><div class="literalblock programlisting"><div class=content><pre>nfs_server_enable=&#34;YES&#34;</pre></div></div></li><li><p>Exporte o diretório raiz sem disco via NFS adicionando o seguinte ao <span class=filename>/etc/exports</span>:</p><div class="literalblock programlisting"><div class=content><pre>/b -ro -alldirs -maproot=root</pre></div></div></li><li><p>Inicie o servidor NFS:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service nfsd start</span></code></pre></div></div></li><li><p>Ative o <a href="https://man.freebsd.org/cgi/man.cgi?query=inetd&amp;sektion=8&amp;format=html">inetd(8)</a> adicionando a seguinte linha ao <span class=filename>/etc/rc.conf</span>:</p><div class="literalblock programlisting"><div class=content><pre>inetd_enable=&#34;YES&#34;</pre></div></div></li><li><p>Descomente a seguinte linha no <span class=filename>/etc/inetd.conf</span> certificando-se de que ela não comece com um símbolo <code>#</code>:</p><div class="literalblock programlisting"><div class=content><pre>tftp dgram udp wait root /usr/libexec/tftpd tftpd -l -s /b/tftpboot</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Algumas versões do PXE exigem a versão TCP do TFTP. Neste caso, remova o comentário da segunda linha <code>tftp</code> que contém <code>stream tcp</code>.</p></div></td></tr></tbody></table></div></li><li><p>Inicie o <a href="https://man.freebsd.org/cgi/man.cgi?query=inetd&amp;sektion=8&amp;format=html">inetd(8)</a>:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service inetd start</span></code></pre></div></div></li><li><p>Instale o sistema básico em <span class=filename>${NFSROOTDIR}</span>, seja descompactando os arquivos oficiais ou recompilando o kernel do FreeBSD e o userland (consulte <a href=../cutting-edge/#makeworld>Atualizando o FreeBSD a partir do código fonte</a> para instruções mais detalhadas, mas não esqueça de adicionar <code>DESTDIR=<em>${NFSROOTDIR}</em></code> ao executar os comandos <code>make installkernel</code> e <code>make installworld</code>.</p></li><li><p>Teste que o servidor TFTP funciona e que pode baixar o gerenciador de boot que será obtido via PXE:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># tftp localhost</span>
tftp&gt; get FreeBSD/install/boot/pxeboot
Received 264951 bytes <span class=k>in </span>0.1 seconds</code></pre></div></div></li><li><p>Edite o <span class=filename>${NFSROOTDIR}/etc/fstab</span> e crie uma entrada para montar o sistema de arquivos raiz por meio do NFS:</p><div class="literalblock programlisting"><div class=content><pre># Device                                         Mountpoint    FSType   Options  Dump Pass
myhost.example.com:/b/tftpboot/FreeBSD/install       /         nfs      ro        0    0</pre></div></div><div class=paragraph><p>Substitua <em>myhost.example.com</em> pelo nome do host ou pelo endereço IP do servidor NFS. Neste exemplo, o sistema de arquivos raiz é montado como somente leitura para evitar que os clientes do NFS excluam potencialmente o conteúdo do sistema de arquivos raiz.</p></div></li><li><p>Defina a senha de root no ambiente PXE para as máquinas clientes que serão inicializadas por PXE:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># chroot ${NFSROOTDIR}</span>
<span class=c># passwd</span></code></pre></div></div></li><li><p>Se necessário, ative o login do root via <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh&amp;sektion=1&amp;format=html">ssh(1)</a> para as máquinas clientes que estão inicializando por PXE editando o <span class=filename>${NFSROOTDIR}/etc/ssh/sshd_config</span> e habilitando o <code>PermitRootLogin</code>. Esta opção está documentada em <a href="https://man.freebsd.org/cgi/man.cgi?query=sshd_config&amp;sektion=5&amp;format=html">sshd_config(5)</a>.</p></li><li><p>Execute qualquer outra customização necessária do ambiente PXE no <span class=filename>${NFSROOTDIR}</span>. Estas customizações podem incluir coisas como instalar pacotes ou editar o arquivo de senha com o <a href="https://man.freebsd.org/cgi/man.cgi?query=vipw&amp;sektion=8&amp;format=html">vipw(8)</a>.</p></li></ol></div></div></div><div class=paragraph><p>Ao inicializar de um volume raiz NFS, o <span class=filename>/etc/rc</span> detecta a inicialização do NFS e executa o <span class=filename>/etc/rc.initdiskless</span>. Neste caso, o <span class=filename>/etc</span> e <span class=filename>/var</span> precisam ser sistemas de arquivos montados em memória para que estes diretórios sejam graváveis mas o diretório raiz NFS seja apenas de leitura:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># chroot ${NFSROOTDIR}</span>
<span class=c># mkdir -p conf/base</span>
<span class=c># tar -c -v -f conf/base/etc.cpio.gz --format cpio --gzip etc</span>
<span class=c># tar -c -v -f conf/base/var.cpio.gz --format cpio --gzip var</span></code></pre></div></div><div class=paragraph><p>Quando o sistema inicializar, os sistemas de arquivos em memória para o <span class=filename>/etc</span> e o <span class=filename>/var</span> serão criados e montados e o conteúdo dos arquivos <span class=filename>cpio.gz</span> será copiado para eles. Por padrão, esses sistemas de arquivos têm uma capacidade máxima de 5 megabytes. Se seus arquivos não couberem, o que geralmente é o caso do <span class=filename>/var</span> quando pacotes binários foram instalados, solicite um tamanho maior colocando o número de setores de 512 bytes necessários (por exemplo, 5 megabytes é 10240 setores) nos arquivos <span class=filename>${NFSROOTDIR}/conf/base/etc/md_size</span> e <span class=filename>${NFSROOTDIR}/conf/base/var/md_size</span> para os sistemas de arquivos <span class=filename>/etc</span> e o <span class=filename>/var</span> respectivamente.</p></div></div><div class=sect2><h3 id=network-pxe-setting-up-dhcp>31.8.2. Configurando o servidor DHCP<a class=anchor href=#network-pxe-setting-up-dhcp></a></h3><div class=paragraph><p>O servidor DHCP não precisa ser a mesma máquina que o servidor TFTP e NFS, mas ele precisa estar acessível na rede.</p></div><div class=paragraph><p>O DHCP não faz parte do sistema básico do FreeBSD, mas pode ser instalado usando o port ou pacote <a class=package href=https://cgit.freebsd.org/ports/tree/net/isc-dhcp44-server/>net/isc-dhcp44-server</a>.</p></div><div class=paragraph><p>Uma vez instalado, edite o arquivo de configuração, <span class=filename>/usr/local/etc/dhcpd.conf</span>. Configure as diretivas <code>next-server</code>, <code>filename</code> e <code>root-path</code> conforme mostrado neste exemplo:</p></div><div class="literalblock programlisting"><div class=content><pre>subnet 192.168.0.0 netmask 255.255.255.0 {
   range 192.168.0.2 192.168.0.3 ;
   option subnet-mask 255.255.255.0 ;
   option routers 192.168.0.1 ;
   option broadcast-address 192.168.0.255 ;
   option domain-name-servers 192.168.35.35, 192.168.35.36 ;
   option domain-name &#34;example.com&#34;;

   # IP address of TFTP server
   next-server 192.168.0.1 ;

   # path of boot loader obtained via tftp
   filename &#34;FreeBSD/install/boot/pxeboot&#34; ;

   # pxeboot boot loader will try to NFS mount this directory for root FS
   option root-path &#34;192.168.0.1:/b/tftpboot/FreeBSD/install/&#34; ;

}</pre></div></div><div class=paragraph><p>A diretiva <code>next-server</code> é usada para especificar o endereço IP do servidor TFTP.</p></div><div class=paragraph><p>A diretiva <code>filename</code> define o caminho para o <span class=filename>/boot/pxeboot</span>. Um nome de arquivo relativo é usado, significando que <span class=filename>/b/tftpboot</span> não está incluído no caminho.</p></div><div class=paragraph><p>A diretiva <code>root-path</code> define o caminho para o sistema de arquivos raiz a ser montado por NFS.</p></div><div class=paragraph><p>Depois que as edições forem salvas, ative o DHCP no momento da inicialização adicionando a seguinte linha ao <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>dhcpd_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Então inicie o serviço DHCP:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service isc-dhcpd start</span></code></pre></div></div></div><div class=sect2><h3 id=_depurando_problemas_de_pxe>31.8.3. Depurando problemas de PXE<a class=anchor href=#_depurando_problemas_de_pxe></a></h3><div class=paragraph><p>Uma vez que todos os serviços estejam configurados e iniciados, os clientes de PXE devem poder carregar automaticamente o FreeBSD pela rede. Se um determinado cliente não conseguir se conectar, quando a máquina cliente inicializar, entre no menu de configuração da BIOS e confirme se ela está configurada para inicializar a partir da rede.</p></div><div class=paragraph><p>Esta seção descreve algumas dicas de solução de problemas para isolar a origem do problema de configuração, caso nenhum cliente seja capaz de inicializar o PXE.</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Use o pacote ou port <a class=package href=https://cgit.freebsd.org/ports/tree/net/wireshark/>net/wireshark</a> para depurar o tráfego de rede envolvido durante o processo de inicialização do PXE, que está ilustrado no diagrama abaixo.</p><div class=imageblock><div class=content><img src=../../../../images/books/handbook/advanced-networking/pxe-nfs.png alt="pxe nfs"></div><div class=title>Figura 1. Processo de inicialização PXE com o sistema de arquivos raiz montado por NFS</div></div></li><li><p>No servidor TFTP, leia o <span class=filename>/var/log/xferlog</span> para garantir que o <span class=filename>pxeboot</span> esteja sendo recuperado do local correto. Para testar esta configuração de exemplo:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># tftp 192.168.0.1</span>
tftp&gt; get FreeBSD/install/boot/pxeboot
Received 264951 bytes <span class=k>in </span>0.1 seconds</code></pre></div></div><div class=paragraph><p>As seções de <code>BUGS</code> do <a href="https://man.freebsd.org/cgi/man.cgi?query=tftpd&amp;sektion=8&amp;format=html">tftpd(8)</a> e <a href="https://man.freebsd.org/cgi/man.cgi?query=tftp&amp;sektion=1&amp;format=html">tftp(1)</a> documenta algumas limitações com o TFTP.</p></div></li><li><p>Certifique-se de que o sistema de arquivos raiz possa ser montado via NFS. Para testar esta configuração de exemplo:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount -t nfs 192.168.0.1:/b/tftpboot/FreeBSD/install /mnt</span></code></pre></div></div></li></ol></div></div></div></div></div></div><div class=sect1><h2 id=network-ipv6>31.9. IPv6<a class=anchor href=#network-ipv6></a></h2><div class=sectionbody><div class=paragraph><p>O IPv6 é a nova versão do conhecido protocolo IP, também conhecido como IPv4. O IPv6 oferece várias vantagens sobre o IPv4, além de muitos recursos novos:</p></div><div class=ulist><ul><li><p>Seu espaço de endereços de 128 bits permite 340.282.366.920.938.463.463.374.607.431.768.211.456 endereços. Isso corrige a falta de endereços do IPv4 e o eventual esgotamento do endereço de IPv4.</p></li><li><p>Os roteadores armazenam apenas endereços de agregação de rede em suas tabelas de roteamento, reduzindo assim o espaço médio de uma tabela de roteamento para 8192 entradas. Isso resolve os problemas de escalabilidade associados ao IPv4, que exigia que cada bloco alocado de endereços IPv4 fossem trocados entre roteadores da Internet, fazendo com que suas tabelas de roteamento ficassem muito grandes para permitir um roteamento eficiente .</p></li><li><p>Autoconfiguração de endereço (<a href=http://www.ietf.org/rfc/rfc2462.txt>RFC2462</a>).</p></li><li><p>Endereços multicast obrigatórios.</p></li><li><p>IPsec Embutido (Segurança IP).</p></li><li><p>Estrutura simplificada do cabeçalho.</p></li><li><p>Suporte para mobile IP.</p></li><li><p>Mecanismos de transição IPv6-to-IPv4.</p></li></ul></div><div class=paragraph><p>O FreeBSD inclui a implementação de referência do <a href=http://www.kame.net/>http://www.kame.net/</a>IPv6 e vem com tudo necessário usar o IPv6. Esta seção se concentra em configurar e executar o IPv6.</p></div><div class=sect2><h3 id=_informações_sobre_endereços_de_ipv6>31.9.1. Informações sobre endereços de IPv6<a class=anchor href=#_informações_sobre_endereços_de_ipv6></a></h3><div class=paragraph><p>Existem três tipos diferentes de endereços de IPv6:</p></div><div class=dlist><dl><dt class=hdlist1>Unicast</dt><dd><p>Um pacote enviado para um endereço unicast chega à interface pertencente ao endereço.</p></dd><dt class=hdlist1>Anycast</dt><dd><p>Esses endereços são sintaticamente indistinguíveis dos endereços unicast, mas eles tratam de um grupo de interfaces. O pacote destinado a um endereço anycast chegará à interface do roteador mais próxima. Endereços anycast são usados apenas por roteadores.</p></dd><dt class=hdlist1>Multicast</dt><dd><p>Esses endereços identificam um grupo de interfaces. Um pacote destinado a um endereço multicast chegará a todas as interfaces pertencentes ao grupo multicast. O endereço de broadcast IPv4 , geralmente <code>xxx.xxx.xxx.255</code>, é expresso por endereços multicast em IPv6.</p></dd></dl></div><div class=paragraph><p>Ao ler um endereço IPv6, a forma canônica é representada como <code>x:x:x:x:x:x:x:x</code>, onde cada <code>x</code> representa um valor hexadecimal de 16 bits. Um exemplo é <code>FEBC:A574:382B:23C1:AA49:4592:4EFE:9982</code>.</p></div><div class=paragraph><p>Muitas vezes, um endereço terá substrings longas apenas com zeros. Um <code>::</code> (dois-pontos duplos) pode ser usado para substituir uma subcadeia por endereço. Além disso, até três valores <code>0</code>s iniciais por valor hexadecimal podem ser omitidos. Por exemplo, <code>fe80::1</code> corresponde à forma canônica <code>fe80:0000:0000:0000:0000:0000:0000:0001</code>.</p></div><div class=paragraph><p>Uma terceira forma é escrever os últimos 32 bits usando a conhecida notação IPv4. Por exemplo, <code>2002::10.0.0.1</code> corresponde à representação canônica hexadecimal <code>2002:0000:0000:0000:0000:0000:0a00:0001</code>, que por sua vez é equivalente a <code>2002::a00:1</code>.</p></div><div class=paragraph><p>Para visualizar o endereço IPv6 do sistema FreeBSD, use <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig</span></code></pre></div></div><div class="literalblock programlisting"><div class=content><pre>rl0: flags=8943&lt;UP,BROADCAST,RUNNING,PROMISC,SIMPLEX,MULTICAST&gt; mtu 1500
         inet 10.0.0.10 netmask 0xffffff00 broadcast 10.0.0.255
         inet6 fe80::200:21ff:fe03:8e1%rl0 prefixlen 64 scopeid 0x1
         ether 00:00:21:03:08:e1
         media: Ethernet autoselect (100baseTX )
         status: active</pre></div></div><div class=paragraph><p>Neste exemplo, a interface <span class=filename>rl0</span> está usando <code>fe80::200:21ff:fe03:8e1%rl0</code>, um endereço local de link auto-configurado que foi gerado automaticamente a partir do endereço MAC.</p></div><div class=paragraph><p>Alguns endereços do IPv6 são reservados. Um resumo destes endereços reservados é visto em <a href=#reservedip6>Endereços IPv6 reservados</a>:</p></div><table id=reservedip6 class="tableblock frame-none grid-all stretch"><caption class=title>Tabela 3. Endereços IPv6 reservados</caption><col style=width:25%><col style=width:25%><col style=width:25%><col style=width:25%><thead><tr><th class="tableblock halign-left valign-top">endereço IPv6</th><th class="tableblock halign-left valign-top">Prefixlength (Bits)</th><th class="tableblock halign-left valign-top">Descrição</th><th class="tableblock halign-left valign-top">Notas</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>::</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>128 bits</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>não especificado</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Equivalente a <code>0.0.0.0</code> em IPv4.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>::1</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>128 bits</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>endereço de loopback</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Equivalente ao <code>127.0.0.1</code> no IPv4.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>::00:xx:xx:xx:xx</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>96 bits</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>IPv4 Embarcado</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Os 32 bits inferiores são o endereço IPv4 compatível.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>::ff:xx:xx:xx:xx</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>96 bits</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>O endereço IPv4 mapeado do endereço IPv6</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Os 32 bits mais baixos são o endereço IPv4 para hosts que não suportam o IPv6.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>fe80::/10</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>10 bits</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>link-local</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Equivalente a 169.254.0.0/16 em IPv4.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>fc00::/7</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>7 bits</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>unique-local</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Endereços locais exclusivos são destinados à comunicação local e só podem ser roteados dentro de um conjunto de sites cooperantes.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>ff00::</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>8 bits</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>multicast</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>2000::-3fff::</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>3 bits</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>unicast global</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Todos os endereços unicast globais são atribuídos a partir desse pool. Os primeiros 3 bits são <code>001</code>.</p></td></tr></tbody></table><div class=paragraph><p>Para maiores informações sobre a estrutura dos endereços do IPv6, consulte a <a href=http://www.ietf.org/rfc/rfc3513.txt>RFC3513</a>.</p></div></div><div class=sect2><h3 id=_configurando_o_ipv6>31.9.2. Configurando o IPv6<a class=anchor href=#_configurando_o_ipv6></a></h3><div class=paragraph><p>Para configurar um sistema FreeBSD como um cliente IPv6, adicione estas duas linhas ao <span class=filename>rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>ifconfig_rl0_ipv6=&#34;inet6 accept_rtadv&#34;
rtsold_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>A primeira linha permite que a interface especificada receba mensagens de solicitação do roteador. A segunda linha ativa o daemon de solicitação do roteador, <a href="https://man.freebsd.org/cgi/man.cgi?query=rtsol&amp;sektion=8&amp;format=html">rtsol(8)</a>.</p></div><div class=paragraph><p>Se a interface precisar de um endereço IPv6 atribuído estaticamente, adicione uma entrada para especificar o endereço estático e o comprimento do prefixo associado:</p></div><div class="literalblock programlisting"><div class=content><pre>ifconfig_rl0_ipv6=&#34;inet6 2001:db8:4672:6565:2026:5043:2d42:5344 prefixlen 64&#34;</pre></div></div><div class=paragraph><p>Para atribuir um roteador padrão, especifique seu endereço:</p></div><div class="literalblock programlisting"><div class=content><pre>ipv6_defaultrouter=&#34;2001:db8:4672:6565::1&#34;</pre></div></div></div><div class=sect2><h3 id=_conectando_se_a_um_provedor>31.9.3. Conectando-se a um provedor<a class=anchor href=#_conectando_se_a_um_provedor></a></h3><div class=paragraph><p>Para se conectar a outras redes IPv6, é necessário ter um provedor ou um túnel que suporte IPv6:</p></div><div class=ulist><ul><li><p>Entre em contato com um provedor de serviços de Internet para saber se eles oferecem IPv6.</p></li><li><p>O <a href=http://www.tunnelbroker.net>Hurricane Electric</a> oferece túneis com endpoints em todo o mundo.</p></li></ul></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Instale o pacote ou port <a class=package href=https://cgit.freebsd.org/ports/tree/net/freenet6/>net/freenet6</a> para uma conexão dial-up.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Esta seção demonstra como obter as direções de um provedor de túneis e convertê-las em configurações do <span class=filename>/etc/rc.conf</span> que persistirão durante as reinicializações.</p></div><div class=paragraph><p>A primeira entrada <span class=filename>/etc/rc.conf</span> cria a interface de encapsulamento genérica <span class=filename>gif0</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>cloned_interfaces=&#34;gif0&#34;</pre></div></div><div class=paragraph><p>Em seguida, configure essa interface com os endereços IPv4 dos pontos de extremidade locais e remotos. Substitua <em>MY_IPv4_ADDR</em> e <em>REMOTE_IPv4_ADDR</em> pelos endereços atuais de IPv4:</p></div><div class="literalblock programlisting"><div class=content><pre>create_args_gif0=&#34;tunnel MY_IPv4_ADDR REMOTE_IPv4_ADDR&#34;</pre></div></div><div class=paragraph><p>Para aplicar o endereço IPv6 que foi atribuído para uso como o ponto final do túnel IPv6, adicione esta linha, substituindo <em>MY_ASSIGNED_IPv6_TUNNEL_ENDPOINT_ADDR</em> pelo endereço atribuído:</p></div><div class="literalblock programlisting"><div class=content><pre>ifconfig_gif0_ipv6=&#34;inet6 MY_ASSIGNED_IPv6_TUNNEL_ENDPOINT_ADDR&#34;</pre></div></div><div class=paragraph><p>Em seguida, defina a rota padrão para o outro lado do túnel IPv6. Substitua <em>MY_IPv6_REMOTE_TUNNEL_ENDPOINT_ADDR</em> pelo endereço do gateway padrão atribuído pelo provedor:</p></div><div class="literalblock programlisting"><div class=content><pre>ipv6_defaultrouter=&#34;MY_IPv6_REMOTE_TUNNEL_ENDPOINT_ADDR&#34;</pre></div></div><div class=paragraph><p>Se o sistema FreeBSD irá rotear pacotes IPv6 entre o resto da rede e o mundo, habilite o gateway usando esta linha:</p></div><div class="literalblock programlisting"><div class=content><pre>ipv6_gateway_enable=&#34;YES&#34;</pre></div></div></div><div class=sect2><h3 id=_anúncio_do_roteador_e_configuração_automática_do_host>31.9.4. Anúncio do roteador e configuração automática do host<a class=anchor href=#_anúncio_do_roteador_e_configuração_automática_do_host></a></h3><div class=paragraph><p>Esta seção demonstra como configurar o <a href="https://man.freebsd.org/cgi/man.cgi?query=rtadvd&amp;sektion=8&amp;format=html">rtadvd(8)</a> para anunciar a rota padrão de IPv6.</p></div><div class=paragraph><p>Para ativar <a href="https://man.freebsd.org/cgi/man.cgi?query=rtadvd&amp;sektion=8&amp;format=html">rtadvd(8)</a>, inclua o seguinte no <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>rtadvd_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>É importante especificar a interface na qual fazer a solicitação do roteador IPv6. Por exemplo, para informar o <a href="https://man.freebsd.org/cgi/man.cgi?query=rtadvd&amp;sektion=8&amp;format=html">rtadvd(8)</a> para usar <span class=filename>rl0</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>rtadvd_interfaces=&#34;rl0&#34;</pre></div></div><div class=paragraph><p>Em seguida, crie o arquivo de configuração, <span class=filename>/etc/rtadvd.conf</span> como visto neste exemplo:</p></div><div class="literalblock programlisting"><div class=content><pre>rl0:\
	:addrs#1:addr=&#34;2001:db8:1f11:246::&#34;:prefixlen#64:tc=ether:</pre></div></div><div class=paragraph><p>Substitua <span class=filename>rl0</span> com a interface a ser usada e <code>2001:db8:1f11:246::</code> com o prefixo da alocação.</p></div><div class=paragraph><p>Para uma sub-rede <code>/64</code> dedicada, nada mais precisa ser alterado. Caso contrário, altere o <code>prefixlen#</code> para o valor correto.</p></div></div><div class=sect2><h3 id=_ipv6_e_o_mapeamento_de_endereços_ipv6>31.9.5. IPv6 e o mapeamento de endereços IPv6<a class=anchor href=#_ipv6_e_o_mapeamento_de_endereços_ipv6></a></h3><div class=paragraph><p>Quando o IPv6 está habilitado em um servidor, pode ser necessário ativar a comunicação de endereços IPv4 mapeados para IPv6. Esta opção de compatibilidade permite que endereços IPv4 sejam representados como endereços de IPv6. Permitir que aplicativos IPv6 se comuniquem com IPv4 e vice-versa pode ser um problema de segurança.</p></div><div class=paragraph><p>Essa opção pode não ser necessária na maioria dos casos e está disponível apenas para compatibilidade. Esta opção permitirá que os aplicativos que suportam apenas o IPv6 funcionem com IPv4 em um ambiente de pilha dupla. Isso é mais útil para aplicativos de terceiros que podem não suportar um ambiente somente de IPv6. Para habilitar esse recurso, adicione o seguinte ao <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>ipv6_ipv4mapping=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Revisar as informações da RFC 3493, seção 3.6 e 3.7, bem como da RFC 4038 seção 4.2, pode ser útil para alguns administradores.</p></div></div></div></div><div class=sect1><h2 id=carp>31.10. Protocolo Comum de Redundância de Endereços (CARP)<a class=anchor href=#carp></a></h2><div class=sectionbody><div class=paragraph><p>O Protocolo Comum de Redundância de Endereços (CARP) permite que vários hosts compartilhem o mesmo endereço IP e ID de Host Virtual (VHID) para fornecer <em>alta disponibilidade</em> para um ou mais serviços. Isso significa que um ou mais hosts podem falhar e os outros hosts assumem o controle de modo transparente, de modo que os usuários não percebam uma falha de serviço.</p></div><div class=paragraph><p>Além do endereço IP compartilhado, cada host tem seu próprio endereço IP para gerenciamento e configuração. Todas as máquinas que compartilham um endereço IP têm o mesmo VHID. O VHID para cada endereço virtual de IP deve ser exclusivo no domínio de broadcast da interface de rede.</p></div><div class=paragraph><p>A alta disponibilidade usando o CARP é nativa no FreeBSD, embora os passos para configurá-lo variem um pouco dependendo da versão do FreeBSD. Esta seção fornece a mesma configuração de exemplo para versões anteriores, iguais ou posteriores ao FreeBSD 10.</p></div><div class=paragraph><p>Este exemplo configura o suporte a failover com três hosts, todos com endereços exclusivos de IP, mas que fornecem o mesmo conteúdo da web. Ele tem dois mestres diferentes chamados <code>hosta.example.org</code> e <code>hostb.example.org</code>, com um backup compartilhado chamado <code>hostc.example.org</code>.</p></div><div class=paragraph><p>O balanceamento de carga destas máquinas é feito por meio de uma configuração de DNS Round Robin. As máquinas principais e de backup são configuradas de forma idêntica, exceto por seus nomes de host e endereços de gerenciamento IP. Esses servidores devem ter a mesma configuração e executar os mesmos serviços. Quando o failover ocorre, as solicitações para o serviço no endereço IP compartilhado só podem ser respondidas corretamente se o servidor de backup tiver acesso ao mesmo conteúdo. A máquina de backup tem duas interfaces CARP adicionais, uma para cada endereço IP do servidor de conteúdo mestre. Quando ocorre uma falha, o servidor de backup selecionará o endereço IP da máquina mestre com falha.</p></div><div class=sect2><h3 id=carp-10x>31.10.1. Usando CARP no FreeBSD 10 e Posteriores<a class=anchor href=#carp-10x></a></h3><div class=paragraph><p>Ative o suporte para CARP na inicialização do sistema, adicionando uma entrada para o módulo do kernel <span class=filename>carp.ko</span> em <span class=filename>/boot/loader.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>carp_load=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Para carregar o módulo agora sem reiniciar:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload carp</span></code></pre></div></div><div class=paragraph><p>Para usuários que preferem usar um kernel personalizado, inclua a seguinte linha no arquivo de configuração do kernel personalizado e compile o kernel como descrito em <a href=../kernelconfig/#kernelconfig>Configurando o kernel do FreeBSD</a>:</p></div><div class="literalblock programlisting"><div class=content><pre>device	carp</pre></div></div><div class=paragraph><p>O nome do host, o endereço IP de gerenciamento e a máscara de sub-rede, o endereço IP compartilhado e o VHID são definidos adicionando entradas ao <span class=filename>/etc/rc.conf</span>. Este exemplo é para o <code>hosta.example.org</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>hostname=&#34;hosta.example.org&#34;
ifconfig_em0=&#34;inet 192.168.1.3 netmask 255.255.255.0&#34;
ifconfig_em0_alias0=&#34;inet vhid 1 pass testpass alias 192.168.1.50/32&#34;</pre></div></div><div class=paragraph><p>O próximo conjunto de entradas é para o <code>hostb.example.org</code>. Como ele representa um segundo mestre, ele usa um endereço IP compartilhado diferente e VHID. No entanto, as senhas especificadas com <code>pass</code> devem ser idênticas, pois o CARP somente ouvirá e aceitará anúncios de máquinas com a senha correta.</p></div><div class="literalblock programlisting"><div class=content><pre>hostname=&#34;hostb.example.org&#34;
ifconfig_em0=&#34;inet 192.168.1.4 netmask 255.255.255.0&#34;
ifconfig_em0_alias0=&#34;inet vhid 2 pass testpass alias 192.168.1.51/32&#34;</pre></div></div><div class=paragraph><p>A terceira máquina, <code>hostc.example.org</code>, é configurada para lidar com o failover de um dos mestres. Esta máquina é configurada com dois CARPVHIDs, um para manipular o endereço IP virtual para cada um dos hosts principais. O desvio de publicidade CARP, <code>advskew</code>, é definida para garantir que o host de backup seja anunciado depois do mestre, pois <code>advskew</code> controla a ordem de precedência quando existem vários servidores de backup.</p></div><div class="literalblock programlisting"><div class=content><pre>hostname=&#34;hostc.example.org&#34;
ifconfig_em0=&#34;inet 192.168.1.5 netmask 255.255.255.0&#34;
ifconfig_em0_alias0=&#34;inet vhid 1 advskew 100 pass testpass alias 192.168.1.50/32&#34;
ifconfig_em0_alias1=&#34;inet vhid 2 advskew 100 pass testpass alias 192.168.1.51/32&#34;</pre></div></div><div class=paragraph><p>Ter dois CARPVHIDs configurados significa que o <code>hostc.example.org</code> notará se um dos servidores principais ficar indisponível. Se um mestre falhar em anunciar antes do servidor de backup, o servidor de backup selecionará o endereço IP compartilhado até que o mestre se torne disponível novamente.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Se o servidor mestre original se tornar disponível novamente, o <code>hostc.example.org</code> não liberará o endereço virtual IP de volta a ele automaticamente. Para que isso aconteça, a preempção deve ser ativada. O recurso está desabilitado por padrão, ele é controlado por meio da variável <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a><code>net.inet.carp.preempt</code>. O administrador pode forçar o servidor de backup a retornar o endereço IP para o mestre:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig em0 vhid 1 state backup</span></code></pre></div></div></td></tr></tbody></table></div><div class=paragraph><p>Quando a configuração estiver concluída, reinicie a rede ou reinicie cada um dos sistemas. A alta disponibilidade está agora ativada.</p></div><div class=paragraph><p>A funcionalidade CARP pode ser controlada através de diversas variáveis <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> documentadas nas páginas de manual do <a href="https://man.freebsd.org/cgi/man.cgi?query=carp&amp;sektion=4&amp;format=html">carp(4)</a>. Outras ações podem ser acionadas a partir de eventos CARP usando <a href="https://man.freebsd.org/cgi/man.cgi?query=devd&amp;sektion=8&amp;format=html">devd(8)</a>.</p></div></div><div class=sect2><h3 id=carp-9x>31.10.2. Usando CARP no FreeBSD 9 e Anteriores<a class=anchor href=#carp-9x></a></h3><div class=paragraph><p>A configuração para estas versões do FreeBSD é similar àquela descrita na seção anterior, exceto que o dispositivo CARP deve ser criado primeiro e referenciado na configuração.</p></div><div class=paragraph><p>Ative o suporte de tempo de inicialização para o CARP carregando o módulo do kernel <span class=filename>if_carp.ko</span> no <span class=filename>/boot/loader.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>if_carp_load=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Para carregar o módulo agora sem reiniciar:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload carp</span></code></pre></div></div><div class=paragraph><p>Para usuários que preferem usar um kernel personalizado, inclua a seguinte linha no arquivo de configuração do kernel personalizado e compile o kernel como descrito em <a href=../kernelconfig/#kernelconfig>Configurando o kernel do FreeBSD</a>:</p></div><div class="literalblock programlisting"><div class=content><pre>device	carp</pre></div></div><div class=paragraph><p>Em seguida, em cada host, crie um dispositivo CARP:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig carp0 create</span></code></pre></div></div><div class=paragraph><p>Defina o nome do host, o endereço IP de gerenciamento, o endereço IP compartilhado e o VHID adicionando as linhas necessárias ao <span class=filename>/etc/rc.conf</span>. Como um dispositivo virtual CARP é usado em vez de um alias, uma máscara de subrede real <code>/24</code> é usada em vez de uma <code>/32</code>. Aqui estão as entradas para o <code>hosta.example.org</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>hostname=&#34;hosta.example.org&#34;
ifconfig_fxp0=&#34;inet 192.168.1.3 netmask 255.255.255.0&#34;
cloned_interfaces=&#34;carp0&#34;
ifconfig_carp0=&#34;vhid 1 pass testpass 192.168.1.50/24&#34;</pre></div></div><div class=paragraph><p>Em <code>hostb.example.org</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>hostname=&#34;hostb.example.org&#34;
ifconfig_fxp0=&#34;inet 192.168.1.4 netmask 255.255.255.0&#34;
cloned_interfaces=&#34;carp0&#34;
ifconfig_carp0=&#34;vhid 2 pass testpass 192.168.1.51/24&#34;</pre></div></div><div class=paragraph><p>A terceira máquina, <code>hostc.example.org</code>, está configurada para lidar com o failover de qualquer um dos hosts principais:</p></div><div class="literalblock programlisting"><div class=content><pre>hostname=&#34;hostc.example.org&#34;
ifconfig_fxp0=&#34;inet 192.168.1.5 netmask 255.255.255.0&#34;
cloned_interfaces=&#34;carp0 carp1&#34;
ifconfig_carp0=&#34;vhid 1 advskew 100 pass testpass 192.168.1.50/24&#34;
ifconfig_carp1=&#34;vhid 2 advskew 100 pass testpass 192.168.1.51/24&#34;</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>A preempção está desabilitada no kernel <span class=filename>GENERIC</span> do FreeBSD. Se a preempção tiver sido ativada com um kernel personalizado, o <code>hostc.example.org</code> poderá não liberar o endereço IP de volta ao servidor de conteúdo original. O administrador pode forçar o servidor de backup a retornar o endereço IP para o mestre com o comando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig carp0 down &amp;&amp; ifconfig carp0 up</span></code></pre></div></div><div class=paragraph><p>Isso deve ser feito na interface <span class=filename>carp</span>, que corresponde ao host correto.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Quando a configuração estiver concluída, reinicie a rede ou reinicie cada um dos sistemas. A alta disponibilidade está agora ativada.</p></div></div></div></div><div class=sect1><h2 id=network-vlan>31.11. VLANs<a class=anchor href=#network-vlan></a></h2><div class=sectionbody><div class=paragraph><p>As VLANs são uma forma de dividir virtualmente uma rede em várias sub-redes diferentes, também conhecida como segmentação. Cada segmento terá seu próprio domínio de broadcast e será isolado de outras VLANs.</p></div><div class=paragraph><p>No FreeBSD, as VLANs devem ser suportadas pelo driver da placa de rede. Para ver quais drivers suportam vlans, consulte a página de manual <a href="https://man.freebsd.org/cgi/man.cgi?query=vlan&amp;sektion=4&amp;format=html">vlan(4)</a>.</p></div><div class=paragraph><p>Ao configurar uma VLAN, algumas informações devem ser conhecidas. Primeiro, qual a interface de rede? Segundo, qual é a tag da VLAN?</p></div><div class=paragraph><p>Para configurar uma VLANs em tempo de execução, com uma NIC <code>em0</code> e uma tag VLAN de <code>5</code> o comando ficaria assim:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig em0.5 create vlan 5 vlandev em0 inet 192.168.20.20/24</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Viu como o nome da interface inclui o nome do driver da NIC e a tag VLAN, separados por um ponto final? Essa é uma prática recomendada para facilitar a manutenção da configuração de VLAN quando muitas VLANs estiverem presentes em uma máquina.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Para configurar uma VLANs no momento da inicialização, o <span class=filename>/etc/rc.conf</span> deve ser atualizado. Para duplicar a configuração acima, será necessário adicionar o seguinte:</p></div><div class="literalblock programlisting"><div class=content><pre>vlans_em0=&#34;5&#34;
ifconfig_em0_5=&#34;inet 192.168.20.20/24&#34;</pre></div></div><div class=paragraph><p>VLANs adicionais podem ser inseridas, simplesmente adicionando a tag ao campo <code>vlans_em0</code> e incrementando uma linha de configuração da rede nessa interface da tag VLAN.</p></div><div class=paragraph><p>É útil atribuir um nome simbólico a uma interface para que, quando o hardware associado for alterado, apenas algumas variáveis de configuração precisem ser atualizadas. Por exemplo, câmeras de segurança precisam ser executadas pela VLAN 1 em <code>em0</code>. Posteriormente, se a placa <code>em0</code> for substituída por uma placa que use o driver <a href="https://man.freebsd.org/cgi/man.cgi?query=ixgb&amp;sektion=4&amp;format=html">ixgb(4)</a>, todas as referências a <code>em0.1</code> não precisarão ser alterado para <code>ixgb0.1</code>.</p></div><div class=paragraph><p>Para configurar a VLAN <code>5</code>, na NIC <code>em0</code>, atribua o nome de interface <code>cameras</code>, e atribua à interface um endereço IP de <code><em>192.168.20.20</em></code> com um prefixo <code>24</code>-bit, use este comando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig em0.5 create vlan 5 vlandev em0 name cameras inet 192.168.20.20/24</span></code></pre></div></div><div class=paragraph><p>Para uma interface denominada <code>video</code>, use o seguinte:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig video.5 create vlan 5 vlandev video name cameras inet 192.168.20.20/24</span></code></pre></div></div><div class=paragraph><p>Para aplicar as mudanças no momento da inicialização, adicione as seguintes linhas ao <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>vlans_video=&#34;cameras&#34;
create_args_cameras=&#34;vlan 5&#34;
ifconfig_cameras=&#34;inet 192.168.20.20/24&#34;</pre></div></div></div></div></div><hr><div class=last-modified><p><strong>Última alteração em</strong>: 9 de março de 2024 por <a href="https://cgit.freebsd.org/doc/commit/?id=6199af92e7" target=_blank>Danilo G. Baio</a></p></div><div class=buttons><div class=prev><i class="fa fa-angle-left" aria-hidden=true title=Anterior></i><div class=container><a href=http://172.16.201.134:1313/pt-br/books/handbook/firewalls class=direction>Anterior</a></div></div><div class=home><i class="fa fa-home" aria-hidden=true title=Início></i><div class=container><a href=../ class=direction>Início</a></div></div><div class=next><div class=container><a href=http://172.16.201.134:1313/pt-br/books/handbook/partv class=direction>Próximo</a></div><i class="fa fa-angle-right" aria-hidden=true title=Próximo></i></div></div><label class="hidden book-menu-overlay" for=menu-control></label></div><aside class=toc><div class=toc-content><h3>Índice</h3><nav id=TableOfContents><ul><li><a href=#advanced-networking-synopsis>31.1. Sinopse</a></li><li><a href=#network-routing>31.2. Gateways e Rotas</a></li><li><a href=#network-wireless>31.3. Rede sem fio</a></li><li><a href=#network-usb-tethering>31.4. USB Tethering</a></li><li><a href=#network-bluetooth>31.5. Bluetooth</a></li><li><a href=#network-bridging>31.6. Bridging</a></li><li><a href=#network-aggregation>31.7. Agregação de links e failover</a></li><li><a href=#network-diskless>31.8. Operação Diskless com PXE</a></li><li><a href=#network-ipv6>31.9. IPv6</a></li><li><a href=#carp>31.10. Protocolo Comum de Redundância de Endereços (CARP)</a></li><li><a href=#network-vlan>31.11. VLANs</a></li></ul></nav><hr><div class=resources><h3>Recursos</h3><ul class=contents><li><i class="fa fa-file-pdf-o" aria-hidden=true title="Download PDF"></i><a href=https://download.freebsd.org/doc/pt-br/books/handbook/handbook_pt-br.pdf>Download PDF</a></li><li><i class="fa fa-pencil-square-o" aria-hidden=true title="Edite essa página"></i><a href=https://github.com/freebsd/freebsd-doc/blob/main/documentation/content/pt-br/_index target=_blank>Edite essa página</a></li></ul></div></div></aside><a class=to-top href=#top><i class="fa fa-arrow-circle-up" aria-hidden=true></i></a></main><footer><div class=footer-container><section class=logo-column><img src=http://172.16.201.134:1313/images/FreeBSD-colors.svg width=160 height=50 alt="FreeBSD logo"><div class=options-container><div class=language-container><a id=languages href=http://172.16.201.134:1313/pt-br/languages><img src=http://172.16.201.134:1313/images/language.png class=language-image alt="Escolha o idioma">
<span>Brazilian Portuguese</span></a></div><div class=theme-container><select id=theme-chooser><option value=theme-system>System</option><option value=theme-light>Light</option><option value=theme-dark>Dark</option><option value=theme-high-contrast>Alto contraste</option></select></div></div></section><section class=about-column><h3 class=column-title>About</h3><ul class=column-elements-container><li><a href=https://www.freebsd.org/about/ target=_blank class=column-element>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/ target=_blank class=column-element>FreeBSD Foundation</a></li><li><a href=https://www.freebsd.org/where/ target=_blank class=column-element>Get FreeBSD</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct target=_blank class=column-element>Code of Conduct</a></li><li><a href=https://www.freebsd.org/security/ target=_blank class=column-element>Security Advisories</a></li></ul></section><section class=documentation-column><h3 class=column-title>Documentation</h3><ul class=column-elements-container><li><a href=/pt-br class=column-element>Documentation portal</a></li><li><a href=https://man.FreeBSD.org target=_blank class=column-element>Manual pages</a></li><li><a href=https://papers.FreeBSD.org target=_blank class=column-element>Presentations and papers</a></li><li><a href=https://docs-archive.freebsd.org/doc/ target=_blank class=column-element>Previous versions</a></li><li><a href=https://docs-archive.freebsd.org/44doc/ target=_blank class=column-element>4.4BSD Documents</a></li><li><a href=https://wiki.freebsd.org/ target=_blank class=column-element>Wiki</a></li></ul></section><section class=community-column><h3 class=column-title>Community</h3><ul class=column-elements-container><li><a href=http://172.16.201.134:1313/pt-br/articles/contributing class=column-element>Get involved</a></li><li><a href=https://forums.freebsd.org/ target=_blank class=column-element>Community forum</a></li><li><a href=https://lists.freebsd.org/ target=_blank class=column-element>Mailing lists</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank class=column-element>IRC Channels</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank class=column-element>Bug Tracker</a></li></ul></section><section class=legal-column><h3 class=column-title>Legal</h3><ul class=column-elements-container><li><a href=https://freebsdfoundation.org/donate/ target=_blank class=column-element>Donations</a></li><li><a href=https://www.freebsd.org/copyright/freebsd-license/ target=_blank class=column-element>Licensing</a></li><li><a href=https://www.freebsd.org/privacy/ target=_blank class=column-element>Privacy Policy</a></li><li><a href=https://www.freebsd.org/copyright/ target=_blank class=column-element>Legal notices</a></li></ul></section><section class=copyright-column><p>&copy; 1994-2024 The FreeBSD Project. All rights reserved</p><span>Made with <span class=heart>♥</span> by the FreeBSD Community</span></section></div></footer></body></html>