<!doctype html><html class=theme-light lang=pt-br><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content><meta name=keywords content><meta name=copyright content="1995-2024 The FreeBSD Foundation"><link rel=canonical href=http://172.16.201.134:1313/pt-br/books/handbook/config/><title>Capítulo 11. Configuração e Ajuste | FreeBSD Documentation Portal</title>
<meta name=theme-color content="#790000"><meta name=color-scheme content="system light dark high-contrast"><link rel="shortcut icon" href=http://172.16.201.134:1313/favicon.ico><link rel=stylesheet href=http://172.16.201.134:1313/styles/main.min.css><link rel=stylesheet href=http://172.16.201.134:1313/css/font-awesome-min.css><script defer src=/js/theme-chooser.min.js></script><script defer src=/js/copy-clipboard.min.js></script><script defer src=/js/search.min.js></script><meta name=twitter:card content="summary"><meta name=twitter:domain content="docs.FreeBSD.org"><meta name=twitter:site content="@freebsd"><meta name=twitter:url content="https://twitter.com/freebsd"><meta property="og:title" content="Capítulo 11. Configuração e Ajuste"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:image" content="http://172.16.201.134:1313/favicon.ico"><meta property="og:image:alt" content="FreeBSD Logo"><meta property="og:locale" content="pt-br"><meta property="og:url" content="http://172.16.201.134:1313/pt-br/books/handbook/config/"><meta property="og:site_name" content="FreeBSD Documentation Portal"><script type=application/ld+json>{"@context":"http://schema.org","@type":"Article","url":"http:\/\/172.16.201.134:1313\/pt-br\/books\/handbook\/config\/","name":"FreeBSD Documentation Portal","headline":"FreeBSD Documentation Portal","description":"FreeBSD Documentation Portal"}</script></head><body><header><div class=header-container><div class=logo-menu-bars-container><a href=https://www.FreeBSD.org class=logo><img src=http://172.16.201.134:1313/images/FreeBSD-monochromatic.svg width=160 height=50 alt="FreeBSD logo">
</a><label class=menu-bars for=menu-bars><i class="fa fa-bars" aria-hidden=true></i></label></div><input id=menu-bars type=checkbox><nav><ul class=menu><li class=menu-item><input id=about type=checkbox>
<a href=# aria-label="Navigate to About section"><label class=menu-item-description for=about>About
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/about/ target=_blank>About</a></li><li><a href=https://www.freebsd.org/about/ target=_blank>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/about-us/about-the-foundation/ target=_blank>FreeBSD Foundation</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct/ target=_blank>Code of Conduct</a></li></ul></li><li class=menu-item><input id=download type=checkbox>
<a href=# aria-label="Navigate to get FreeBSD section"><label class=menu-item-description for=download>Get FreeBSD
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/where/ target=_blank>Get FreeBSD</a></li><li><a href=https://www.freebsd.org/releases/ target=_blank>Release Information</a></li><li><a href=https://www.freebsd.org/releng/ target=_blank>Release Engineering</a></li><li><a href=https://www.freebsd.org/security/ target=_blank>Security Advisories</a></li></ul></li><li class=menu-item><input id=documentation type=checkbox>
<a href=# aria-label="Navigate to get Documentation section"><label class=menu-item-description for=documentation>Documentation
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=/pt-br>Documentation portal</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook>FreeBSD Handbook</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/porters-handbook>Porter's Handbook</a></li><li><a href=https://docs.FreeBSD.org/en/books/fdp-primer>Documentation Project Handbook</a></li><li><a href=https://man.FreeBSD.org target=_blank>Manual pages</a></li><li><a href=https://papers.FreeBSD.org target=_blank>Presentations and papers</a></li><li><a href=https://wiki.FreeBSD.org target=_blank>Wiki</a></li><li><a href=http://172.16.201.134:1313/pt-br/books>Books</a></li><li><a href=http://172.16.201.134:1313/pt-br/articles>Articles</a></li></ul></li><li class=menu-item><input id=community type=checkbox>
<a href=# aria-label="Navigate to get Community section"><label class=menu-item-description for=community>Community
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/community/>Community</a></li><li><a href=http://172.16.201.134:1313/pt-br/articles/contributing>Get involved</a></li><li><a href=https://forums.freebsd.org/ target=_blank>Forum</a></li><li><a href=https://lists.freebsd.org/ target=_blank>Mailing lists</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank>IRC Channels</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank>Bug Tracker</a></li><li><a href=https://www.freebsd.org/support/ target=_blank>Support</a></li></ul></li></ul></nav><div class=search-donate-container><form class=search method=get id=search-header-form action=https://docs.freebsd.org/search name=search-header-form><input type=hidden name=DB value=pt-br>
<input id=words name=P type=text size=20 maxlength=255>
<button>
<i class="fa fa-search" aria-hidden=true></i></button></form><div class=donate><a href=https://freebsdfoundation.org/donate/ target=_blank><span class=heart>♥</span>
Donate</a></div></div></div></header><input type=checkbox class="hidden toggle" id=menu-control><main class=main-wrapper-book><a id=top></a><aside class=book-menu><div class=book-menu-content><input id=search-book type=text placeholder=Pesquisar aria-label=Pesquisar maxlength=128><nav id=MenuContents><ul><li><input type=checkbox id=chapter-eb2a98ce203d8afd517726e6d8776be3 class=toggle>
<label class="icon cursor" for=chapter-eb2a98ce203d8afd517726e6d8776be3><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/preface/>Prefácio</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/preface/#preface-audience>Audiência Pretendida</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/preface/#preface-changes-from3>Mudanças desde a Terceira Edição</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/preface/#preface-changes-from2>Mudanças desde a Segunda Edição (2004)</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/preface/#preface-changes>Mudanças desde a Primeira Edição (2001)</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/preface/#preface-overview>Organização deste Livro</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/preface/#preface-conv>Convenções utilizadas neste livro</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/preface/#preface-acknowledgements>Agradecimentos</a></li></ul></li><li><input type=checkbox id=chapter-14a525fce014b90b8a458a894818255a class=toggle>
<label for=chapter-14a525fce014b90b8a458a894818255a><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/parti/>Parte I. Primeiros Passos</a></li><li><input type=checkbox id=chapter-f9c9f3451644df30d224350da97d5da6 class=toggle>
<label class="icon cursor" for=chapter-f9c9f3451644df30d224350da97d5da6><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/introduction/>Capítulo 1. Introdução</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/introduction/#introduction-synopsis>1.1. Sinopse</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/introduction/#nutshell>1.2. Bem vindo ao FreeBSD!</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/introduction/#history>1.3. Sobre o Projeto FreeBSD</a></li></ul></li><li><input type=checkbox id=chapter-f693a3fa687a72d63ec8129ee302d664 class=toggle>
<label class="icon cursor" for=chapter-f693a3fa687a72d63ec8129ee302d664><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/bsdinstall/>Capítulo 2. Instalando o FreeBSD</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/bsdinstall/#bsdinstall-synopsis>2.1. Sinopse</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/bsdinstall/#bsdinstall-hardware>2.2. Requisitos mínimos de hardware</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/bsdinstall/#bsdinstall-pre>2.3. Tarefas de Pré-instalação</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/bsdinstall/#bsdinstall-start>2.4. Iniciando a instalação</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/bsdinstall/#using-bsdinstall>2.5. Usando o bsdinstall</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/bsdinstall/#bsdinstall-partitioning>2.6. Alocando o espaço em disco</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/bsdinstall/#bsdinstall-fetching-distribution>2.7. Fazendo o download dos arquivos de distribuição</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/bsdinstall/#bsdinstall-post>2.8. Contas, Time Zone, Serviços e Hardening</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/bsdinstall/#bsdinstall-network>2.9. Interfaces de Rede</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/bsdinstall/#bsdinstall-install-trouble>2.10. Solução de problemas</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/bsdinstall/#using-live-cd>2.11. Usando o Live CD</a></li></ul></li><li><input type=checkbox id=chapter-9f6db261075f578742036fcc6000eecd class=toggle>
<label class="icon cursor" for=chapter-9f6db261075f578742036fcc6000eecd><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/basics/>Capítulo 3. Fundamentos do FreeBSD</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/basics/#basics-synopsis>3.1. Sinopse</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/basics/#consoles>3.2. Consoles e Terminais Virtuais</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/basics/#users-synopsis>3.3. Usuários e Gerenciamento Básico de Contas</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/basics/#permissions>3.4. Permissões</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/basics/#dirstructure>3.5. Estrutura de Diretórios</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/basics/#disk-organization>3.6. Organização dos Discos</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/basics/#mount-unmount>3.7. Montando e Desmontando Sistemas de Arquivos</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/basics/#basics-processes>3.8. Processos e Daemons</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/basics/#shells>3.9. Shells</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/basics/#editors>3.10. Editores de Texto</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/basics/#basics-devices>3.11. Dispositivos e nós de dispositivos</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/basics/#basics-more-information>3.12. Páginas de Manual</a></li></ul></li><li><input type=checkbox id=chapter-01c5707e95d14c0ff84bf62600c958d1 class=toggle>
<label class="icon cursor" for=chapter-01c5707e95d14c0ff84bf62600c958d1><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/ports/>Capítulo 4. Instalando Aplicativos: Pacotes e Ports</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/ports/#ports-synopsis>4.1. Sinopse</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/ports/#ports-overview>4.2. Visão geral sobre a Instalação de Software</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/ports/#ports-finding-applications>4.3. Encontrando Software</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/ports/#pkgng-intro>4.4. Usando o pkg para o gerenciamento de pacotes binários</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/ports/#ports-using>4.5. Usando a Coleção de Ports</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/ports/#ports-poudriere>4.6. Compilando Pacotes com o Poudriere</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/ports/#ports-nextsteps>4.7. Considerações pós-instalação</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/ports/#ports-broken>4.8. Lidando com ports quebrados</a></li></ul></li><li><input type=checkbox id=chapter-3405c00581365a8b5d16af70fe4d1b72 class=toggle>
<label class="icon cursor" for=chapter-3405c00581365a8b5d16af70fe4d1b72><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/x11/>Capítulo 5. O sistema X Window</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/x11/#x11-synopsis>5.1. Sinopse</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/x11/#x-understanding>5.2. Terminologia</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/x11/#x-install>5.3. Instalando o Xorg</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/x11/#x-config>5.4. Configuração do Xorg</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/x11/#x-fonts>5.5. Usando fontes no Xorg</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/x11/#x-xdm>5.6. O Gerenciador de Display X</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/x11/#x11-wm>5.7. Ambientes de desktop</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/x11/#x-compiz-fusion>5.8. Instalando o Compiz Fusion</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/x11/#x11-troubleshooting>5.9. Solução de problemas</a></li></ul></li><li><input type=checkbox id=chapter-0eab3565e8f59f5a8a896dfba7eb3680 class=toggle>
<label for=chapter-0eab3565e8f59f5a8a896dfba7eb3680><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/partii/>Parte II. Tarefas comuns</a></li><li><input type=checkbox id=chapter-b33cf28993f3f7bf5baf036e79da0f39 class=toggle>
<label class="icon cursor" for=chapter-b33cf28993f3f7bf5baf036e79da0f39><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/desktop/>Capítulo 6. Aplicações de Desktop</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/desktop/#desktop-synopsis>6.1. Sinopse</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/desktop/#desktop-browsers>6.2. Navegadores</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/desktop/#desktop-productivity>6.3. Produtividade</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/desktop/#desktop-viewers>6.4. Visualizadores de Documentos</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/desktop/#desktop-finance>6.5. Finanças</a></li></ul></li><li><input type=checkbox id=chapter-152f694a19312ad72ec7bb4e1c3c33b2 class=toggle>
<label class="icon cursor" for=chapter-152f694a19312ad72ec7bb4e1c3c33b2><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/multimedia/>Capítulo 7. Multimídia</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/multimedia/#multimedia-synopsis>7.1. Sinopse</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/multimedia/#sound-setup>7.2. Configurando a Placa de Som</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/multimedia/#sound-mp3>7.3. Áudio MP3</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/multimedia/#video-playback>7.4. Reprodução de Vídeo</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/multimedia/#tvcard>7.5. Placas de TV</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/multimedia/#mythtv>7.6. MythTV</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/multimedia/#scanners>7.7. Scanners de Imagem</a></li></ul></li><li><input type=checkbox id=chapter-80888b4ee02e3e409e5f71cf97a36450 class=toggle>
<label class="icon cursor" for=chapter-80888b4ee02e3e409e5f71cf97a36450><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/kernelconfig/>Capítulo 8. Configurando o kernel do FreeBSD</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/kernelconfig/#kernelconfig-synopsis>8.1. Sinopse</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/kernelconfig/#kernelconfig-custom-kernel>8.2. Por que compilar um kernel personalizado?</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/kernelconfig/#kernelconfig-devices>8.3. Encontrando o hardware do sistema</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/kernelconfig/#kernelconfig-config>8.4. O Arquivo de Configuração</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/kernelconfig/#kernelconfig-building>8.5. Criando e Instalando um Kernel Customizado</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/kernelconfig/#kernelconfig-trouble>8.6. Se algo der errado</a></li></ul></li><li><input type=checkbox id=chapter-cb174c55879b17ab955f2f16989a79e0 class=toggle>
<label class="icon cursor" for=chapter-cb174c55879b17ab955f2f16989a79e0><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/printing/>Capítulo 9. Impressão</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/printing/#printing-quick-start>9.1. Inicio Rápido</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/printing/#printing-connections>9.2. Conexões de Impressora</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/printing/#printing-pdls>9.3. Linguagens de Descrição de Página Comuns</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/printing/#printing-direct>9.4. Impressão Direta</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/printing/#printing-lpd>9.5. LPD (Daemon de impressora de linha)</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/printing/#printing-other>9.6. Outros sistemas de impressão</a></li></ul></li><li><input type=checkbox id=chapter-c12b8c3f2a8fcefce87087241f695c83 class=toggle>
<label class="icon cursor" for=chapter-c12b8c3f2a8fcefce87087241f695c83><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/linuxemu/>Capítulo 10. Compatibilidade binária com o Linux®</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/linuxemu/#linuxemu-synopsis>10.1. Sinopse</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/linuxemu/#linuxemu-lbc-install>10.2. Configurando a compatibilidade binária com o Linux™</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/linuxemu/#linuxemu-advanced>10.3. Tópicos Avançados</a></li></ul></li><li><input type=checkbox id=chapter-03b11ba627b9a0c85b247f5641bde272 class=toggle>
<label for=chapter-03b11ba627b9a0c85b247f5641bde272><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/partiii/>Parte III. Administração do Sistema</a></li><li><input type=checkbox id=chapter-6c31587f8d736319f099cd4dc1961301 class=toggle checked>
<label class="icon cursor" for=chapter-6c31587f8d736319f099cd4dc1961301><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/config/>Capítulo 11. Configuração e Ajuste</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/config/#config-synopsis>11.1. Sinopse</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/config/#configtuning-starting-services>11.2. Inicialização de Serviços</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/config/#configtuning-cron>11.3. Configurando o cron(8)</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/config/#configtuning-rcd>11.4. Gerenciando Serviços no FreeBSD</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/config/#config-network-setup>11.5. Configurando Placas de Interface de Rede</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/config/#configtuning-virtual-hosts>11.6. Hosts Virtuais</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/config/#configtuning-syslog>11.7. Configurando o log do sistema</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/config/#configtuning-configfiles>11.8. Arquivos de Configuração</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/config/#configtuning-sysctl>11.9. Efetuando ajustes com o sysctl(8)</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/config/#configtuning-disk>11.10. Otimização de Discos</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/config/#configtuning-kernel-limits>11.11. Ajustando os Limites do Kernel</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/config/#adding-swap-space>11.12. Adicionando Espaço de Swap</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/config/#acpi-overview>11.13. Gerenciamento de energia e recursos</a></li></ul></li><li><input type=checkbox id=chapter-459f0012b3b4f0b6b123010f029da5e4 class=toggle>
<label class="icon cursor" for=chapter-459f0012b3b4f0b6b123010f029da5e4><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/boot/>Capítulo 12. O processo de inicialização do FreeBSD</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/boot/#boot-synopsis>12.1. Sinopse</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/boot/#boot-introduction>12.2. Processo de Inicialização do FreeBSD</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/boot/#boot-splash>12.3. Configurando telas iniciais de inicialização</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/boot/#device-hints>12.4. Sugestões de dispositivos</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/boot/#boot-shutdown>12.5. Sequência de Desligamento</a></li></ul></li><li><input type=checkbox id=chapter-917c75fcffbb14d48ed6d0a48e7028f2 class=toggle>
<label class="icon cursor" for=chapter-917c75fcffbb14d48ed6d0a48e7028f2><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/security/>Capítulo 13. Segurança</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/security/#security-synopsis>13.1. Sinopse</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/security/#security-intro>13.2. Introdução</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/security/#one-time-passwords>13.3. Senhas de Uso Unico</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/security/#tcpwrappers>13.4. TCP Wrapper</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/security/#kerberos5>13.5. Kerberos</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/security/#openssl>13.6. OpenSSL</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/security/#ipsec>13.7. VPN Sobre IPsec</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/security/#openssh>13.8. OpenSSH</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/security/#fs-acl>13.9. Listas de Controle de Acesso</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/security/#security-pkg>13.10. Monitorando Problemas de Segurança de Terceiros</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/security/#security-advisories>13.11. Avisos de Segurança do FreeBSD</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/security/#security-accounting>13.12. Auditoria de Processo</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/security/#security-resourcelimits>13.13. Limites de Recursos</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/security/#security-sudo>13.14. Administração Compartilhada com Sudo</a></li></ul></li><li><input type=checkbox id=chapter-1a2a8e719703649c2c66d99aa7a25fd4 class=toggle>
<label class="icon cursor" for=chapter-1a2a8e719703649c2c66d99aa7a25fd4><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/jails/>Capítulo 14. Jails</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/jails/#jails-synopsis>14.1. Sinopse</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/jails/#jails-terms>14.2. Termos Relacionados à Jails</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/jails/#jails-build>14.3. Criando e Controlando Jails</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/jails/#jails-tuning>14.4. Tuning e Administração</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/jails/#jails-application>14.5. Atualizando Múltiplas Jails</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/jails/#jails-ezjail>14.6. Gerenciando Jails com o ezjail</a></li></ul></li><li><input type=checkbox id=chapter-8f4620c77e572cbb58917911a33c73cf class=toggle>
<label class="icon cursor" for=chapter-8f4620c77e572cbb58917911a33c73cf><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/mac/>Capítulo 15. Controle de acesso obrigatório</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/mac/#mac-synopsis>15.1. Sinopse</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/mac/#mac-inline-glossary>15.2. Termos chave</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/mac/#mac-understandlabel>15.3. Entendendo os rótulos MAC</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/mac/#mac-planning>15.4. Planejando a configuração de segurança</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/mac/#mac-policies>15.5. Políticas MAC Disponíveis</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/mac/#mac-userlocked>15.6. Bloqueio do Usuário</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/mac/#mac-implementing>15.7. Nagios em Jail MAC</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/mac/#mac-troubleshoot>15.8. Solução de problemas do framework MAC</a></li></ul></li><li><input type=checkbox id=chapter-9598d66a76cb3182057b6bcd775149a0 class=toggle>
<label class="icon cursor" for=chapter-9598d66a76cb3182057b6bcd775149a0><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/audit/>Capítulo 16. Auditoria de Evento de Segurança</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/audit/#audit-synopsis>16.1. Sinopse</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/audit/#audit-inline-glossary>16.2. Termos chave</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/audit/#audit-config>16.3. Configuração de Auditoria</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/audit/#audit-administration>16.4. Trabalhando com Trilhas de Auditoria</a></li></ul></li><li><input type=checkbox id=chapter-e1edcad13d9db6e8e4cb645d378ecfaf class=toggle>
<label class="icon cursor" for=chapter-e1edcad13d9db6e8e4cb645d378ecfaf><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/disks/>Capítulo 17. Armazenamento</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/disks/#disks-synopsis>17.1. Sinopse</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/disks/#disks-adding>17.2. Adicionando Discos</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/disks/#disks-growing>17.3. Redimensionando e Ampliando Discos</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/disks/#usb-disks>17.4. Dispositivos de Armazenamento USB</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/disks/#creating-cds>17.5. Criando e Usando Mídia em CD</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/disks/#creating-dvds>17.6. Criando e Usando Mídia de DVD</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/disks/#floppies>17.7. Criando e Usando Disquetes</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/disks/#backup-basics>17.8. Noções Básicas de Backup</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/disks/#disks-virtual>17.9. Discos de Memória</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/disks/#snapshots>17.10. Snapshots de Sistemas de Arquivos</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/disks/#quotas>17.11. Cotas de Disco</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/disks/#disks-encrypting>17.12. Criptografando Partições de Disco</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/disks/#swap-encrypting>17.13. Criptografando Swap</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/disks/#disks-hast>17.14. Alta Disponibilidade de Armazenamento (HAST)</a></li></ul></li><li><input type=checkbox id=chapter-dde37901a0e0ea32745b67607854900f class=toggle>
<label class="icon cursor" for=chapter-dde37901a0e0ea32745b67607854900f><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/geom/>Capítulo 18. GEOM: Framework de Transformação de Disco Modular</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/geom/#geom-synopsis>18.1. Sinopse</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/geom/#geom-striping>18.2. RAID0 - Striping</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/geom/#geom-mirror>18.3. RAID1 - Espelhamento</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/geom/#geom-raid3>18.4. RAID3 - Distribuição em Nível de Byte com Paridade Dedicada</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/geom/#geom-graid>18.5. Dispositivos RAID por Software</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/geom/#geom-ggate>18.6. GEOM Network Gate</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/geom/#geom-glabel>18.7. Rotulando Dispositivos de Disco</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/geom/#geom-gjournal>18.8. Journaling UFS através do GEOM</a></li></ul></li><li><input type=checkbox id=chapter-73e82560fcb7145b7c0e2ec47af8fc04 class=toggle>
<label class="icon cursor" for=chapter-73e82560fcb7145b7c0e2ec47af8fc04><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/zfs/>Capítulo 19. O sistema de arquivos Z (ZFS)</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/zfs/#zfs-differences>19.1. O que torna o ZFS diferente</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/zfs/#zfs-quickstart>19.2. Guia de Início Rápido</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/zfs/#zfs-zpool>19.3. Administração <code>zpool</code></a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/zfs/#zfs-zfs>19.4. Administração do <code>zfs</code></a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/zfs/#zfs-zfs-allow>19.5. Administração Delegada</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/zfs/#zfs-advanced>19.6. Tópicos Avançados</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/zfs/#zfs-links>19.7. Recursos adicionais</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/zfs/#zfs-term>19.8. Recursos e terminologia do ZFS</a></li></ul></li><li><input type=checkbox id=chapter-7af71270807eb7b70cd3eedc6577b254 class=toggle>
<label class="icon cursor" for=chapter-7af71270807eb7b70cd3eedc6577b254><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/filesystems/>Capítulo 20. Outros Sistemas de Arquivos</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/filesystems/#filesystems-synopsis>20.1. Sinopse</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/filesystems/#filesystems-linux>20.2. Sistemas de arquivos do Linux™</a></li></ul></li><li><input type=checkbox id=chapter-375257268d95faaf87faf4f7a2e6aa67 class=toggle>
<label class="icon cursor" for=chapter-375257268d95faaf87faf4f7a2e6aa67><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/virtualization/>Capítulo 21. Virtualização</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/virtualization/#virtualization-synopsis>21.1. Sinopse</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/virtualization/#virtualization-guest-parallels>21.2. FreeBSD como Sistema Operacional Convidado no Parallels para Mac OS™ X</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/virtualization/#virtualization-guest-virtualpc>21.3. FreeBSD como sistema convidado no Virtual PC para Windows™</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/virtualization/#virtualization-guest-vmware>21.4. FreeBSD como Sistema Operacional Convidado no VMware Fusion para Mac OS™</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/virtualization/#virtualization-guest-virtualbox>21.5. FreeBSD como Sistema Operacional Convidado no VirtualBox™</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/virtualization/#virtualization-host-virtualbox>21.6. FreeBSD como Host com VirtualBox™</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/virtualization/#virtualization-host-bhyve>21.7. FreeBSD como um Host bhyve</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/virtualization/#virtualization-host-xen>21.8. FreeBSD como Host Xen™</a></li></ul></li><li><input type=checkbox id=chapter-49f1e96591c090304ea532012257f4ef class=toggle>
<label class="icon cursor" for=chapter-49f1e96591c090304ea532012257f4ef><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/l10n/>Capítulo 22. Localização - Uso e Configuração do i18n/L10n</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/l10n/#l10n-synopsis>22.1. Sinopse</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/l10n/#using-localization>22.2. Usando Localização</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/l10n/#l10n-compiling>22.3. Encontrando Aplicações i18n</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/l10n/#lang-setup>22.4. Configuração de Localização para Idiomas Específicos</a></li></ul></li><li><input type=checkbox id=chapter-dead2b4c5ea325dd390a9b0dccd8f763 class=toggle>
<label class="icon cursor" for=chapter-dead2b4c5ea325dd390a9b0dccd8f763><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/cutting-edge/>Capítulo 23. Atualização e Upgrade do FreeBSD</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/cutting-edge/#updating-upgrading-synopsis>23.1. Sinopse</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/cutting-edge/#updating-upgrading-freebsdupdate>23.2. Atualização do FreeBSD</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/cutting-edge/#updating-upgrading-documentation>23.3. Atualizando o Conjunto de Documentação</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/cutting-edge/#current-stable>23.4. Acompanhando um ramo de desenvolvimento</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/cutting-edge/#makeworld>23.5. Atualizando o FreeBSD a partir do código fonte</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/cutting-edge/#small-lan>23.6. Atualização de várias máquinas</a></li></ul></li><li><input type=checkbox id=chapter-29c1eeb0e9dedc487a98399e2737ee8a class=toggle>
<label class="icon cursor" for=chapter-29c1eeb0e9dedc487a98399e2737ee8a><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/dtrace/>Chapter 24. DTrace</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/dtrace/#dtrace-synopsis>24.1. Sinopse</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/dtrace/#dtrace-implementation>24.2. Diferenças de Implementação</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/dtrace/#dtrace-enable>24.3. Ativando o Suporte do DTrace</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/dtrace/#dtrace-using>24.4. Usando o DTrace</a></li></ul></li><li><input type=checkbox id=chapter-913e72bfb3d6947b2869d3e9447a6eaa class=toggle>
<label class="icon cursor" for=chapter-913e72bfb3d6947b2869d3e9447a6eaa><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/usb-device-mode/>Capítulo 25. Modo de dispositivo USB/USB OTG</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/usb-device-mode/#usb-device-mode-synopsis>25.1. Sinopse</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/usb-device-mode/#usb-device-mode-terminals>25.2. Portas Seriais Virtuais USB</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/usb-device-mode/#usb-device-mode-network>25.3. Interfaces de rede do modo de dispositivo USB</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/usb-device-mode/#usb-device-mode-storage>25.4. Dispositivo de armazenamento virtual USB</a></li></ul></li><li><input type=checkbox id=chapter-bbd25f9a194f9c39ca2d658c75767db5 class=toggle>
<label for=chapter-bbd25f9a194f9c39ca2d658c75767db5><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/partiv/>Parte IV. Comunicação de rede</a></li><li><input type=checkbox id=chapter-499dab596afd7ddac77e80295314e0dd class=toggle>
<label class="icon cursor" for=chapter-499dab596afd7ddac77e80295314e0dd><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/serialcomms/>Capítulo 26. Comunicações Seriais</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/serialcomms/#serial-synopsis>26.1. Sinopse</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/serialcomms/#serial>26.2. Terminologia serial e hardware</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/serialcomms/#term>26.3. Terminais</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/serialcomms/#dialup>26.4. Serviço Dial-in</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/serialcomms/#dialout>26.5. Serviço de Dial-in</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/serialcomms/#serialconsole-setup>26.6. Configurando o Console Serial</a></li></ul></li><li><input type=checkbox id=chapter-95e4571c48bee1cced5e84a538d302e3 class=toggle>
<label class="icon cursor" for=chapter-95e4571c48bee1cced5e84a538d302e3><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/ppp-and-slip/>Capítulo 27. PPP</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/ppp-and-slip/#ppp-and-slip-synopsis>27.1. Sinopse</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/ppp-and-slip/#userppp>27.2. Configurando o PPP</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/ppp-and-slip/#ppp-troubleshoot>27.3. Solução de problemas de conexões PPP</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/ppp-and-slip/#pppoe>27.4. Usando o PPP sobre Ethernet (PPPoE)</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/ppp-and-slip/#pppoa>27.5. Usando PPP sobre ATM (PPPoA)</a></li></ul></li><li><input type=checkbox id=chapter-f089ac726c401c9b4bd5c34a295e11bb class=toggle>
<label class="icon cursor" for=chapter-f089ac726c401c9b4bd5c34a295e11bb><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/mail/>Capítulo 28. Correio Eletrônico</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/mail/#mail-synopsis>28.1. Sinopse</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/mail/#mail-using>28.2. Componentes de Email</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/mail/#sendmail>28.3. Arquivos de Configuração do Sendmail</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/mail/#mail-changingmta>28.4. Alterando o Mail Transfer Agent</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/mail/#mail-trouble>28.5. Solução de problemas</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/mail/#mail-advanced>28.6. Tópicos Avançados</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/mail/#outgoing-only>28.7. Configurando Apenas Envio</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/mail/#SMTP-dialup>28.8. Usando Email com uma Conexão Dialup</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/mail/#SMTP-Auth>28.9. Autenticação SMTP</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/mail/#mail-agents>28.10. Mail User Agents</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/mail/#mail-fetchmail>28.11. Usando o fetchmail</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/mail/#mail-procmail>28.12. Usando o procmail</a></li></ul></li><li><input type=checkbox id=chapter-6de4de3fe925639d4175ce4b6f8c1829 class=toggle>
<label class="icon cursor" for=chapter-6de4de3fe925639d4175ce4b6f8c1829><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/network-servers/>Capítulo 29. Servidores de Rede</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/network-servers/#network-servers-synopsis>29.1. Sinopse</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/network-servers/#network-inetd>29.2. O super-servidor inetd</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/network-servers/#network-nfs>29.3. Network File System (NFS)</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/network-servers/#network-nis>29.4. Sistema de Informação de Rede (NIS)</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/network-servers/#network-ldap>29.5. Protocolo leve de acesso de diretório ( LDAP )</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/network-servers/#network-dhcp>29.6. Protocolo de configuração dinâmica de hosts (DHCP)</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/network-servers/#network-dns>29.7. Sistema de Nomes de Domínio (DNS)</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/network-servers/#network-apache>29.8. Servidor HTTP Apache</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/network-servers/#network-ftp>29.9. Protocolo de Transferência de Arquivos (FTP)</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/network-servers/#network-samba>29.10. Serviços de arquivos e impressão para clientes Microsoft™Windows™ Clients (Samba)</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/network-servers/#network-ntp>29.11. Sincronização de Relógio com NTP</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/network-servers/#network-iscsi>29.12. Inicializador iSCSI e Configuração Alvo</a></li></ul></li><li><input type=checkbox id=chapter-776d855c7b75e048f90b5c2c9b35ffe0 class=toggle>
<label class="icon cursor" for=chapter-776d855c7b75e048f90b5c2c9b35ffe0><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/firewalls/>Capítulo 30. Firewalls</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/firewalls/#firewalls-intro>30.1. Sinopse</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/firewalls/#firewalls-concepts>30.2. Conceitos de Firewall</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/firewalls/#firewalls-pf>30.3. PF</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/firewalls/#firewalls-ipfw>30.4. IPFW</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/firewalls/#firewalls-ipf>30.5. IPFILTER (IPF)</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/firewalls/#firewalls-blacklistd>30.6. Blacklistd</a></li></ul></li><li><input type=checkbox id=chapter-5b07f776a0e6155c1c89aa0d15610380 class=toggle>
<label class="icon cursor" for=chapter-5b07f776a0e6155c1c89aa0d15610380><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/advanced-networking/>Capítulo 31. Rede Avançada</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/advanced-networking/#advanced-networking-synopsis>31.1. Sinopse</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/advanced-networking/#network-routing>31.2. Gateways e Rotas</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/advanced-networking/#network-wireless>31.3. Rede sem fio</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/advanced-networking/#network-usb-tethering>31.4. USB Tethering</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/advanced-networking/#network-bluetooth>31.5. Bluetooth</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/advanced-networking/#network-bridging>31.6. Bridging</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/advanced-networking/#network-aggregation>31.7. Agregação de links e failover</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/advanced-networking/#network-diskless>31.8. Operação Diskless com PXE</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/advanced-networking/#network-ipv6>31.9. IPv6</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/advanced-networking/#carp>31.10. Protocolo Comum de Redundância de Endereços (CARP)</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/advanced-networking/#network-vlan>31.11. VLANs</a></li></ul></li><li><input type=checkbox id=chapter-171a77aa9d067a1024f849470e1f33e8 class=toggle>
<label for=chapter-171a77aa9d067a1024f849470e1f33e8><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/partv/>Parte V. Apêndices</a></li><li><input type=checkbox id=chapter-8050f436a0a7986a4aaded93d8e49469 class=toggle>
<label class="icon cursor" for=chapter-8050f436a0a7986a4aaded93d8e49469><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/mirrors/>Apêndice A. Obtendo o FreeBSD</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/mirrors/#mirrors-cdrom>A.1. CD and DVD Sets</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/mirrors/#mirrors-ftp>A.2. Sites de FTP</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/mirrors/#svn>A.3. Usando o Subversion</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/mirrors/#mirrors-rsync>A.4. Usando o rsync</a></li></ul></li><li><input type=checkbox id=chapter-128b630a8f88f158e7027fe6c2184d21 class=toggle>
<label class="icon cursor" for=chapter-128b630a8f88f158e7027fe6c2184d21><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/bibliography/>Apêndice B. Bibliografia</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/bibliography/#bibliography-freebsd>B.1. Livros específicos para o FreeBSD</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/bibliography/#bibliography-userguides>B.2. Guias de usuários</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/bibliography/#bibliography-adminguides>B.3. Guias de Administradores</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/bibliography/#bibliography-programmers>B.4. Guias de programadores</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/bibliography/#bibliography-osinternals>B.5. Internals do sistema operacional</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/bibliography/#bibliography-security>B.6. Referências de segurança</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/bibliography/#bibliography-hardware>B.7. Referências de Hardware</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/bibliography/#bibliography-history>B.8. História do UNIX™</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/bibliography/#bibliography-journals>B.9. Periódicos, Jornais e Revistas</a></li></ul></li><li><input type=checkbox id=chapter-8bbb8867c46dac315e2253945d8c18a8 class=toggle>
<label class="icon cursor" for=chapter-8bbb8867c46dac315e2253945d8c18a8><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/eresources/>Apêndice C. Recursos na Internet</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/eresources/#eresources-www>C.1. Websites</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/eresources/#eresources-mail>C.2. Listas de Discussão</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/eresources/#eresources-news>C.3. Grupos de Notícias Usenet</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/eresources/#eresources-web>C.4. Espelhos Oficiais</a></li></ul></li><li><input type=checkbox id=chapter-a80ea4f5a4480b8725422710f954ef36 class=toggle>
<label class="icon cursor" for=chapter-a80ea4f5a4480b8725422710f954ef36><a role=button></a></label><a href=http://172.16.201.134:1313/pt-br/books/handbook/pgpkeys/>Apêndice D. Chaves OpenPGP</a><ul><li><a href=http://172.16.201.134:1313/pt-br/books/handbook/pgpkeys/#pgpkeys-officers>D.1. Administradores</a></li></ul></li><li></li></ul></nav></div></aside><div class=book><div class=book-menu-mobile><label for=menu-control><span class=menu-control-button><i class="fa fa-list" aria-hidden=true title=Menu></i>
Menu</span></label></div><h1 class=title>Capítulo 11. Configuração e Ajuste</h1><div class="admonitionblock note"><p><i class="fa fa-exclamation-circle" aria-hidden=true></i>
Esta tradução pode estar desatualizada. Para ajudar com as traduções, acesse a <a href=https://translate-dev.freebsd.org/ target=_blank>ferramenta de traduções do FreeBSD</a>.</p></div><div class=toc-mobile><h3>Índice</h3><nav id=TableOfContents><ul><li><a href=#config-synopsis>11.1. Sinopse</a></li><li><a href=#configtuning-starting-services>11.2. Inicialização de Serviços</a></li><li><a href=#configtuning-cron>11.3. Configurando o cron(8)</a></li><li><a href=#configtuning-rcd>11.4. Gerenciando Serviços no FreeBSD</a></li><li><a href=#config-network-setup>11.5. Configurando Placas de Interface de Rede</a></li><li><a href=#configtuning-virtual-hosts>11.6. Hosts Virtuais</a></li><li><a href=#configtuning-syslog>11.7. Configurando o log do sistema</a></li><li><a href=#configtuning-configfiles>11.8. Arquivos de Configuração</a></li><li><a href=#configtuning-sysctl>11.9. Efetuando ajustes com o sysctl(8)</a></li><li><a href=#configtuning-disk>11.10. Otimização de Discos</a></li><li><a href=#configtuning-kernel-limits>11.11. Ajustando os Limites do Kernel</a></li><li><a href=#adding-swap-space>11.12. Adicionando Espaço de Swap</a></li><li><a href=#acpi-overview>11.13. Gerenciamento de energia e recursos</a></li></ul></nav></div><div class=book-content><div id=preamble><div class=sectionbody></div></div><div class=sect1><h2 id=config-synopsis>11.1. Sinopse<a class=anchor href=#config-synopsis></a></h2><div class=sectionbody><div class=paragraph><p>Um dos aspectos importantes do FreeBSD é a configuração adequada do sistema. Este capítulo explica muito do processo de configuração do FreeBSD, incluindo alguns dos parâmetros que podem ser configurados para ajustar um sistema FreeBSD.</p></div><div class=paragraph><p>Depois de ler este capítulo, você saberá:</p></div><div class=ulist><ul><li><p>O básico da configuração do <span class=filename>rc.conf</span> e dos scripts de inicialização <span class=filename>/usr/local/etc/rc.d</span>.</p></li><li><p>Como configurar e testar uma placa de rede.</p></li><li><p>Como configurar hosts virtuais em dispositivos de rede.</p></li><li><p>Como usar os vários arquivos de configuração em <span class=filename>/etc</span>.</p></li><li><p>Como ajustar o FreeBSD usando variáveis <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a>.</p></li><li><p>Como ajustar o desempenho do disco e modificar as limitações do kernel.</p></li></ul></div><div class=paragraph><p>Antes de ler este capítulo, você deve:</p></div><div class=ulist><ul><li><p>Entender os fundamentos do UNIX™ e do FreeBSD (<a href=../basics/#basics>Fundamentos do FreeBSD</a>).</p></li><li><p>Estar familiarizado com os conceitos básicos de configuração e compilação do kernel (<a href=../kernelconfig/#kernelconfig>Configurando o kernel do FreeBSD</a>).</p></li></ul></div></div></div><div class=sect1><h2 id=configtuning-starting-services>11.2. Inicialização de Serviços<a class=anchor href=#configtuning-starting-services></a></h2><div class=sectionbody><div class=paragraph><p>Muitos usuários instalam software de terceiros no FreeBSD a partir da coleção de Ports e precisam que os serviços instalados sejam iniciados durante a inicialização do sistema. Serviços como <a class=package href=https://cgit.freebsd.org/ports/tree/mail/postfix/>mail/postfix</a> ou <a class=package href=https://cgit.freebsd.org/ports/tree/www/apache22/>www/apache22</a> são apenas dois dos muitos pacotes de software que podem ser iniciados durante a inicialização do sistema. Esta seção explica os procedimentos disponíveis para iniciar o software de terceiros.</p></div><div class=paragraph><p>No FreeBSD, a maioria dos serviços incluídos, como o <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a>, são iniciados através dos scripts de inicialização do sistema.</p></div><div class=sect2><h3 id=_configuração_estendida_dos_aplicativos>11.2.1. Configuração Estendida dos Aplicativos<a class=anchor href=#_configuração_estendida_dos_aplicativos></a></h3><div class=paragraph><p>Agora que o FreeBSD inclui o <span class=filename>rc.d</span>, a configuração da inicialização do aplicativo é mais fácil e fornece mais recursos. Usando as palavras-chave discutidas em <a href=#configtuning-rcd>Gerenciando Serviços no FreeBSD</a>, os aplicativos podem ser configurados para iniciar depois de certos outros serviços e flags extras poderem ser passadas através do <span class=filename>/etc/rc.conf</span> no lugar de sinalizadores codificados no script de inicialização. Um script básico pode ser semelhante ao seguinte:</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
#
# PROVIDE: utility
# REQUIRE: DAEMON
# KEYWORD: shutdown

. /etc/rc.subr

name=utility
rcvar=utility_enable

command=&#34;/usr/local/sbin/utility&#34;

load_rc_config $name

#
# DO NOT CHANGE THESE DEFAULT VALUES HERE
# SET THEM IN THE /etc/rc.conf FILE
#
utility_enable=${utility_enable-&#34;NO&#34;}
pidfile=${utility_pidfile-&#34;/var/run/utility.pid&#34;}

run_rc_command &#34;$1&#34;</pre></div></div><div class=paragraph><p>Este script irá garantir que o <code>utilitário</code> fornecido será iniciado após o pseudo-serviço <code>DAEMON</code>. Ele também fornece um método para definir e rastrear o ID do processo (PID).</p></div><div class=paragraph><p>Esta aplicação poderia então ter a seguinte linha colocada no <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>utility_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Este método permite a manipulação mais fácil de argumentos de linha de comando, inclusão das funções padrões fornecidas em <span class=filename>/etc/rc.subr</span>, compatibilidade com o <a href="https://man.freebsd.org/cgi/man.cgi?query=rcorder&amp;sektion=8&amp;format=html">rcorder(8)</a>, e fornece uma configuração mais fácil via <span class=filename>rc.conf</span>.</p></div></div><div class=sect2><h3 id=_usando_o_services_para_inicializar_serviços>11.2.2. Usando o Services para Inicializar Serviços<a class=anchor href=#_usando_o_services_para_inicializar_serviços></a></h3><div class=paragraph><p>Outros serviços podem ser iniciados usando o <a href="https://man.freebsd.org/cgi/man.cgi?query=inetd&amp;sektion=8&amp;format=html">inetd(8)</a>. O uso do <a href="https://man.freebsd.org/cgi/man.cgi?query=inetd&amp;sektion=8&amp;format=html">inetd(8)</a> e sua configuração é descrita em profundidade em <a href=../network-servers/#network-inetd>O super-servidor inetd</a>.</p></div><div class=paragraph><p>Em alguns casos, pode fazer mais sentido usar o <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a> para iniciar os serviços do sistema. Esta abordagem tem várias vantagens, pois o <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a> executa estes processos como o proprietário do <a href="https://man.freebsd.org/cgi/man.cgi?query=crontab&amp;sektion=5&amp;format=html">crontab(5)</a>. Isto permite que usuários regulares iniciem e mantenham seus próprios aplicativos.</p></div><div class=paragraph><p>O recurso <code>@reboot</code> do <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a>, pode ser usado no lugar da especificação de hora. Isso faz com que o job seja executado quando <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a> é iniciado, normalmente durante a inicialização do sistema.</p></div></div></div></div><div class=sect1><h2 id=configtuning-cron>11.3. Configurando o <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a><a class=anchor href=#configtuning-cron></a></h2><div class=sectionbody><div class=paragraph><p>Um dos utilitários mais úteis no FreeBSD é o cron. Este utilitário é executado em segundo plano e verifica regularmente o <span class=filename>/etc/crontab</span> para que as tarefas sejam executadas e procura <span class=filename>/var/cron/tabs</span> para arquivos crontab personalizados. Estes arquivos são usados para planejar tarefas que o cron executa nos horários especificados. Cada entrada em um crontab define uma tarefa para ser executada e é conhecida como uma <em>tarefa do cron</em>.</p></div><div class=paragraph><p>Dois tipos diferentes de arquivos de configuração são usados: o crontab do sistema, que não deve ser modificado, e crontabs de usuário, que podem ser criados e editados conforme necessário. O formato usado por esses arquivos está documentado em <a href="https://man.freebsd.org/cgi/man.cgi?query=crontab&amp;sektion=5&amp;format=html">crontab(5)</a>. O formato do sistema crontab, <span class=filename>/etc/crontab</span> inclui uma coluna <code>who</code> que não existe nos crontabs de usuário. No crontab do sistema , o cron executa o comando como o usuário especificado nesta coluna. Em um crontab de usuário, todos os comandos são executados como o usuário que criou o crontab.</p></div><div class=paragraph><p>Os crontabs de usuário permitem que usuários individuais programem suas próprias tarefas. O usuário <code>root</code> também pode ter um <span class=filename>crontab</span> de usuário que pode ser usado para agendar tarefas que não existem no <span class=filename>crontab</span> do sistema .</p></div><div class=paragraph><p>Aqui está uma entrada de amostra do crontab do sistema, <span class=filename>/etc/crontab</span>:</p></div><div class="literalblock programlisting"><div class=content><pre># /etc/crontab - root&#39;s crontab for FreeBSD
#
# $FreeBSD: head/pt_BR.ISO8859-1/books/handbook/book.xml 53984 2020-03-15 16:03:31Z dbaio $
#<i class=conum data-value=1></i><b>(1)</b>
SHELL=/bin/sh
PATH=/etc:/bin:/sbin:/usr/bin:/usr/sbin <i class=conum data-value=2></i><b>(2)</b>
#
#minute	hour	mday	month	wday	who	command <i class=conum data-value=3></i><b>(3)</b>
#
*/5	*	*	*	*	root	/usr/libexec/atrun <i class=conum data-value=4></i><b>(4)</b></pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>Linhas que começam com o caractere <code>#</code> são comentários. Um comentário pode ser colocado no arquivo como um lembrete do que uma ação faz e do porque a sua execução é desejada. Comentários não podem estar na mesma linha que um comando ou então serão interpretados como parte do comando; eles devem estar em uma nova linha. Linhas em branco são ignoradas.</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td>O caractere igual (<code>=</code>) é usado para definir qualquer configuração de ambiente. Neste exemplo, ele é usado para definir o <code>SHELL</code> e o <code>PATH</code>. Se o <code>SHELL</code> for omitido, o cron usará o shell Bourne padrão. Se o <code>PATH</code> for omitido, o caminho completo deverá ser fornecido ao comando ou script a ser executado.</td></tr><tr><td><i class=conum data-value=3></i><b>3</b></td><td>Esta linha define os sete campos usados em um crontab do sistema: <code>minute</code>, <code>hora</code>, <code>mday</code>, <code>month</code>, <code>wday</code>, <code>who</code> e <code>command</code>. O campo <code>minute</code> é o tempo em minutos quando o comando especificado será executado, a <code>hour</code> é a hora em que o comando especificado será executado, o <code>mday</code> é o dia do mês, <code>month</code> é o mês e <code>wday</code> é o dia da semana. Estes campos devem ser valores numéricos, representando o relógio de vinte e quatro horas, ou um <code>*</code>, representando todos os valores desse campo. O campo <code>who</code> existe somente no crontab do sistema e especifica com qual usuário o comando deve ser executado. O último campo é o comando a ser executado.</td></tr><tr><td><i class=conum data-value=4></i><b>4</b></td><td>Esta entrada define os valores para este trabalho do cron. O <code><strong>/5</strong></code><strong>, seguido por vários outros caracteres <code></code></strong>, especifica que <code>/usr/libexec/atrun</code> é invocado pelo <code>root</code> a cada cinco minutos de cada hora, de cada dia e dia da semana, de cada mês.Comandos podem incluir qualquer número de opções. No entanto, os comandos que se estendem a várias linhas precisam ser quebrados com o caractere de continuação da barra invertida "\".</td></tr></tbody></table></div><div class=sect2><h3 id=configtuning-installcrontab>11.3.1. Criando um Crontab de Usuário<a class=anchor href=#configtuning-installcrontab></a></h3><div class=paragraph><p>Para criar um crontab de usuário, invoque o <code>crontab</code> no modo editor:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% crontab <span class=nt>-e</span></code></pre></div></div><div class=paragraph><p>Isto irá abrir o crontab do usuário usando o editor de texto padrão. A primeira vez que um usuário executa este comando, ele abre um arquivo vazio. Depois que um usuário cria um crontab, esse comando abrirá este arquivo para edição.</p></div><div class=paragraph><p>É útil adicionar estas linhas a parte superior do arquivo crontab para configurar as variáveis de ambiente e lembrar os significados dos campos no crontab:</p></div><div class="literalblock programlisting"><div class=content><pre>SHELL=/bin/sh
PATH=/etc:/bin:/sbin:/usr/bin:/usr/sbin
# Order of crontab fields
# minute	hour	mday	month	wday	command</pre></div></div><div class=paragraph><p>Em seguida, adicione uma linha para cada comando ou script a ser executado, especificando o horário para executar o comando. Este exemplo executa o script de shell Bourne personalizado especificado todos os dias às duas da tarde. Como o caminho para o script não está especificado em <code>PATH</code>, o caminho completo para o script é fornecido:</p></div><div class="literalblock programlisting"><div class=content><pre>0	14	*	*	*	/usr/home/dru/bin/mycustomscript.sh</pre></div></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Antes de usar um script personalizado, verifique se ele é executável e teste-o com o conjunto limitado de variáveis de ambiente definidas pelo cron. Para replicar o ambiente que seria usado para executar a entrada do cron acima, use:</p></div><div class="literalblock programlisting"><div class=content><pre>env -i SHELL=/bin/sh PATH=/etc:/bin:/sbin:/usr/bin:/usr/sbin HOME=/home/dru LOGNAME=dru /usr/home/dru/bin/mycustomscript.sh</pre></div></div><div class=paragraph><p>O ambiente definido pelo cron é discutido em <a href="https://man.freebsd.org/cgi/man.cgi?query=crontab&amp;sektion=5&amp;format=html">crontab(5)</a>. Verificar se os scripts operam corretamente em um ambiente cron é especialmente importante se incluírem quaisquer comandos que excluam arquivos usando curingas.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Quando terminar de editar o crontab, salve o arquivo. Ele será instalado automaticamente e o cron lerá o crontab e executará seus cron jobs nos horários especificados. Para listar as tarefas agendadas em um crontab, use este comando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% crontab <span class=nt>-l</span>
0	14	<span class=k>*</span>	<span class=k>*</span>	<span class=k>*</span>	/usr/home/dru/bin/mycustomscript.sh</code></pre></div></div><div class=paragraph><p>Para remover todas as tarefas cron em um crontab de usuário:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% crontab <span class=nt>-r</span>
remove crontab <span class=k>for </span>dru? y</code></pre></div></div></div></div></div><div class=sect1><h2 id=configtuning-rcd>11.4. Gerenciando Serviços no FreeBSD<a class=anchor href=#configtuning-rcd></a></h2><div class=sectionbody><div class=paragraph><p>O FreeBSD usa o sistema <a href="https://man.freebsd.org/cgi/man.cgi?query=rc&amp;sektion=8&amp;format=html">rc(8)</a> de scripts de inicialização durante a inicialização do sistema e para gerenciar serviços. Os scripts listados em <span class=filename>/etc/rc.d</span> fornecem serviços básicos que podem ser controlados com <code>start</code>, <code>stop</code> e <code>restart</code> opções para <a href="https://man.freebsd.org/cgi/man.cgi?query=service&amp;sektion=8&amp;format=html">service(8)</a>. Por exemplo, <a href="https://man.freebsd.org/cgi/man.cgi?query=sshd&amp;sektion=8&amp;format=html">sshd(8)</a> pode ser reiniciado com o seguinte comando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service sshd restart</span></code></pre></div></div><div class=paragraph><p>Este procedimento pode ser usado para iniciar serviços em um sistema em execução. Os serviços serão iniciados automaticamente no momento da inicialização, conforme especificado em <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a>. Por exemplo, para ativar o <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> na inicialização do sistema, adicione a seguinte linha ao <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>natd_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Se uma linha <code>natd_enable="NO"</code> já estiver presente, altere o <code>NO</code> para <code>YES</code>. Os scripts <a href="https://man.freebsd.org/cgi/man.cgi?query=rc&amp;sektion=8&amp;format=html">rc(8)</a> carregarão automaticamente todos os serviços dependentes durante a próxima inicialização, conforme descrito abaixo.</p></div><div class=paragraph><p>Como o sistema <a href="https://man.freebsd.org/cgi/man.cgi?query=rc&amp;sektion=8&amp;format=html">rc(8)</a> é destinado principalmente a iniciar e parar serviços na inicialização do sistema e no tempo de desligamento, o <code>start</code>, as opções <code>stop</code> e <code>restart</code> somente executarão suas ações se a variável apropriada estiver configurada no <span class=filename>/etc/rc.conf</span>. Por exemplo, o <code>sshd restart</code> só funcionará se <code>sshd_enable</code> estiver definido como <code>YES</code> em <span class=filename>/etc/rc.conf</span>. Para <code>iniciar</code>, <code>parar</code> ou <code>reiniciar</code> um serviço independente das configurações em <span class=filename>/etc/rc.conf</span>, estes comandos deve ser prefixado com "one". Por exemplo, para reiniciar <a href="https://man.freebsd.org/cgi/man.cgi?query=sshd&amp;sektion=8&amp;format=html">sshd(8)</a> independentemente da configuração atual do <span class=filename>/etc/rc.conf</span>, execute o seguinte comando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service sshd onerestart</span></code></pre></div></div><div class=paragraph><p>Para verificar se um serviço está habilitado em <span class=filename>/etc/rc.conf</span>, execute o script apropriado <a href="https://man.freebsd.org/cgi/man.cgi?query=rc&amp;sektion=8&amp;format=html">rc(8)</a> com <code>rcvar</code>. Este exemplo verifica se o <a href="https://man.freebsd.org/cgi/man.cgi?query=sshd&amp;sektion=8&amp;format=html">sshd(8)</a> está habilitado no <span class=filename>/etc/rc.conf</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service sshd rcvar</span>
<span class=c># sshd</span>
<span class=c>#</span>
<span class=nv>sshd_enable</span><span class=o>=</span><span class=s2>&#34;YES&#34;</span>
<span class=c>#   (default: &#34;&#34;)</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>A linha <code># sshd</code> é gerada pelo comando acima, não pelo console do <code>root</code>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Para determinar se um serviço está ou não em execução, use <code>status</code>. Por exemplo, para verificar se o <a href="https://man.freebsd.org/cgi/man.cgi?query=sshd&amp;sektion=8&amp;format=html">sshd(8)</a> está em execução:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service sshd status</span>
sshd is running as pid 433.</code></pre></div></div><div class=paragraph><p>Em alguns casos, também é possível fazer o <code>reload</code> denum serviço. Isso tenta enviar um sinal para um serviço individual, forçando o serviço a recarregar seus arquivos de configuração. Na maioria dos casos, isso significa enviar ao serviço um sinal <code>SIGHUP</code>. O suporte para esse recurso não está incluído para todos os serviços.</p></div><div class=paragraph><p>O sistema <a href="https://man.freebsd.org/cgi/man.cgi?query=rc&amp;sektion=8&amp;format=html">rc(8)</a> é usado para serviços de rede e também contribui para a maior parte da inicialização do sistema. Por exemplo, quando o script <span class=filename>/etc/rc.d/bgfsck</span> é executado, ele imprime a seguinte mensagem:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Starting background file system checks <span class=k>in </span>60 seconds.</code></pre></div></div><div class=paragraph><p>Esse script é usado para verificações do sistema de arquivos em segundo plano, que ocorrem apenas durante a inicialização do sistema.</p></div><div class=paragraph><p>Muitos serviços do sistema dependem de outros serviços para funcionar corretamente. Por exemplo, o <a href="https://man.freebsd.org/cgi/man.cgi?query=yp&amp;sektion=8&amp;format=html">yp(8)</a> e outros serviços baseados em RPC podem falhar ao iniciar até que o <a href="https://man.freebsd.org/cgi/man.cgi?query=rpcbind&amp;sektion=8&amp;format=html">rpcbind(8)</a> seja iniciado. Para resolver esse problema, informações sobre dependências e outros meta-dados são incluídas nos comentários na parte superior de cada script de inicialização. O programa <a href="https://man.freebsd.org/cgi/man.cgi?query=rcorder&amp;sektion=8&amp;format=html">rcorder(8)</a> é usado para analisar esses comentários durante a inicialização do sistema para determinar a ordem na qual os serviços do sistema devem ser invocados para satisfazer as dependências.</p></div><div class=paragraph><p>A seguinte palavra-chave deve ser incluída em todos os scripts de inicialização, conforme exigido pelo <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.subr&amp;sektion=8&amp;format=html">rc.subr(8)</a> para "habilitar" o script de inicialização:</p></div><div class=ulist><ul><li><p><code>PROVIDE</code>: Especifica os serviços que este arquivo fornece.</p></li></ul></div><div class=paragraph><p>As seguintes palavras-chave podem ser incluídas na parte superior de cada script de inicialização. Eles não são estritamente necessárias, mas são úteis como sugestões para <a href="https://man.freebsd.org/cgi/man.cgi?query=rcorder&amp;sektion=8&amp;format=html">rcorder(8)</a>:</p></div><div class=ulist><ul><li><p><code>REQUIRE</code>: lista os serviços necessários para este serviço. O script que contém esta palavra chave será executado <em>após</em> os serviços especificados.</p></li><li><p><code>BEFORE</code>: lista os serviços que dependem deste serviço. O script que contém esta palavra chave será executado <em>antes</em> dos serviços especificados.</p></li></ul></div><div class=paragraph><p>Ao definir cuidadosamente essas palavras-chave para cada script de inicialização, um administrador passa a ter um nível refinado de controle da ordem de inicialização dos scripts, sem a necessidade dos "runlevels" usados por alguns sistemas operacionais UNIX™.</p></div><div class=paragraph><p>Informações adicionais podem ser encontradas em <a href="https://man.freebsd.org/cgi/man.cgi?query=rc&amp;sektion=8&amp;format=html">rc(8)</a> e <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.subr&amp;sektion=8&amp;format=html">rc.subr(8)</a>. Consulte <a href=https://docs.freebsd.org/pt-br/articles/rc-scripting/>este artigo</a> para obter instruções sobre como criar um script <a href="https://man.freebsd.org/cgi/man.cgi?query=rc&amp;sektion=8&amp;format=html">rc(8)</a> personalizado.</p></div><div class=sect2><h3 id=configtuning-core-configuration>11.4.1. Gerenciando a configuração específica do sistema<a class=anchor href=#configtuning-core-configuration></a></h3><div class=paragraph><p>A localização principal das informações de configuração do sistema é arquivo <span class=filename>/etc/rc.conf</span>. Este arquivo contém uma ampla gama de informações de configuração e é lido na inicialização do sistema para configurar o sistema. Ele fornece as informações de configuração para os arquivos <span class=filename>rc*</span>.</p></div><div class=paragraph><p>As entradas em <span class=filename>/etc/rc.conf</span> substituem as configurações padrões em <span class=filename>/etc/defaults/rc.conf</span>. O arquivo contendo as configurações padrões não deve ser editado. Ao invés disso, todas as alterações específicas do sistema devem ser feitas em <span class=filename>/etc/rc.conf</span>.</p></div><div class=paragraph><p>Várias estratégias podem ser aplicadas em aplicativos em cluster para separar as configurações que afetam todo o site da configuração específica do sistema para reduzir a sobrecarga de administração. A abordagem recomendada é colocar a configuração específica do sistema em <span class=filename>/etc/rc.conf.local</span>. Por exemplo, estas entradas em <span class=filename>/etc/rc.conf</span> aplicam-se a todos os sistemas:</p></div><div class="literalblock programlisting"><div class=content><pre>sshd_enable=&#34;YES&#34;
keyrate=&#34;fast&#34;
defaultrouter=&#34;10.1.1.254&#34;</pre></div></div><div class=paragraph><p>Considerando que estas entradas em <span class=filename>/etc/rc.conf.local</span> se aplicam somente a este sistema:</p></div><div class="literalblock programlisting"><div class=content><pre>hostname=&#34;node1.example.org&#34;
ifconfig_fxp0=&#34;inet 10.1.1.1/8&#34;</pre></div></div><div class=paragraph><p>Distribua o <span class=filename>/etc/rc.conf</span> para cada sistema usando um aplicativo como o rsync ou o puppet, enquanto o <span class=filename>/etc/rc.conf.local</span> permanece único.</p></div><div class=paragraph><p>A atualização do sistema não sobrescreverá o <span class=filename>/etc/rc.conf</span>, portanto as informações de configuração do sistema não serão perdidas.</p></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Ambos <span class=filename>/etc/rc.conf</span> e <span class=filename>/etc/rc.conf.local</span> são analisados pelo <a href="https://man.freebsd.org/cgi/man.cgi?query=sh&amp;sektion=1&amp;format=html">sh(1)</a>. Isto permite que os operadores do sistema criem cenários de configuração complexos. Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a> para obter mais informações sobre este tópico.</p></div></td></tr></tbody></table></div></div></div></div><div class=sect1><h2 id=config-network-setup>11.5. Configurando Placas de Interface de Rede<a class=anchor href=#config-network-setup></a></h2><div class=sectionbody><div class=paragraph><p>Adicionar e configurar uma placa de interface de rede (NIC) é uma tarefa comum para qualquer administrador do FreeBSD.</p></div><div class=sect2><h3 id=_localizando_o_driver_correto>11.5.1. Localizando o Driver Correto<a class=anchor href=#_localizando_o_driver_correto></a></h3><div class=paragraph><p>Primeiro, determine o modelo da NIC e o chip utilizado. O FreeBSD suporta uma ampla variedade de NICs. Verifique a lista de compatibilidade de hardware para a release do FreeBSD para ver se a NIC é suportada.</p></div><div class=paragraph><p>Se a NIC é suportada, determine o nome do driver do FreeBSD para a NIC. Consulte <span class=filename>/usr/src/sys/conf/NOTES</span> e <span class=filename>/usr/src/sys/arch/conf/NOTES</span> para a lista de Drivers NIC com algumas informações sobre os chipsets suportados. Em caso de dúvida, leia a página de manual do driver, pois ele fornecerá mais informações sobre o hardware suportado e quaisquer limitações conhecidas do driver.</p></div><div class=paragraph><p>Os drivers para as NICs comuns já estão presentes no kernel <span class=filename>GENERIC</span>, o que significa que a NIC deve ser verificada durante a inicialização. As mensagens de inicialização do sistema podem ser visualizadas digitando <code>more /var/run/dmesg.boot</code> e usando a barra de espaço para percorrer o texto. Neste exemplo, duas NICs Ethernet que utilizam o driver <a href="https://man.freebsd.org/cgi/man.cgi?query=dc&amp;sektion=4&amp;format=html">dc(4)</a> estão presentes no sistema:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>dc0: &lt;82c169 PNIC 10/100BaseTX&gt; port 0xa000-0xa0ff mem 0xd3800000-0xd38
000ff irq 15 at device 11.0 on pci0
miibus0: &lt;MII bus&gt; on dc0
bmtphy0: &lt;BCM5201 10/100baseTX PHY&gt; PHY 1 on miibus0
bmtphy0:  10baseT, 10baseT-FDX, 100baseTX, 100baseTX-FDX, auto
dc0: Ethernet address: 00:a0:cc:da:da:da
dc0: <span class=o>[</span>ITHREAD]
dc1: &lt;82c169 PNIC 10/100BaseTX&gt; port 0x9800-0x98ff mem 0xd3000000-0xd30
000ff irq 11 at device 12.0 on pci0
miibus1: &lt;MII bus&gt; on dc1
bmtphy1: &lt;BCM5201 10/100baseTX PHY&gt; PHY 1 on miibus1
bmtphy1:  10baseT, 10baseT-FDX, 100baseTX, 100baseTX-FDX, auto
dc1: Ethernet address: 00:a0:cc:da:da:db
dc1: <span class=o>[</span>ITHREAD]</code></pre></div></div><div class=paragraph><p>Se o driver da NIC não estiver presente em <span class=filename>GENERIC</span>, mas houver um driver disponível, o driver precisará ser carregado antes que a NIC possa ser configurada e usada. Isso pode ser feito de duas maneiras:</p></div><div class=ulist><ul><li><p>A maneira mais fácil é carregar um módulo do kernel para a NIC usando o <a href="https://man.freebsd.org/cgi/man.cgi?query=kldload&amp;sektion=8&amp;format=html">kldload(8)</a>. Para carregar automaticamente o driver no momento da inicialização, adicione a linha apropriada ao <span class=filename>/boot/loader.conf</span>. Nem todos os drivers NIC estão disponíveis como módulos.</p></li><li><p>Como alternativa, compile estaticamente o suporte para a NIC em um kernel personalizado. Consulte <span class=filename>/usr/src/sys/conf/NOTES</span>, <span class=filename>/usr/src/sys/arch/conf/NOTES</span> e a página de manual do driver para determinar qual linha adicionar ao arquivo de configuração do kernel personalizado. Para mais informações sobre como recompilar o kernel, consulte <a href=../kernelconfig/#kernelconfig>Configurando o kernel do FreeBSD</a>. Se a NIC foi detectada na inicialização, o kernel não precisa ser recompilado.</p></li></ul></div><div class=sect3><h4 id=config-network-ndis>11.5.1.1. Utilizando os Drivers Windows™NDIS<a class=anchor href=#config-network-ndis></a></h4><div class=paragraph><p>Infelizmente, ainda existem muitos fornecedores que não fornecem esquemas para seus drivers para a comunidade de código aberto porque consideram essas informações como segredos comerciais. Consequentemente, os desenvolvedores do FreeBSD e de outros sistemas operacionais são deixados com duas opções: desenvolver os drivers por um processo longo e complexo de engenharia reversa ou usar os binários de drivers existentes disponíveis para plataforma Microsoft™ Windows™.</p></div><div class=paragraph><p>O FreeBSD fornece suporte "nativo" para a especificação de interface de driver de rede (NDIS). Ele inclui o <a href="https://man.freebsd.org/cgi/man.cgi?query=ndisgen&amp;sektion=8&amp;format=html">ndisgen(8)</a> que pode ser utilizado para converter um driver Windows™ XP num formato que pode ser usado no FreeBSD. Como o driver <a href="https://man.freebsd.org/cgi/man.cgi?query=ndis&amp;sektion=4&amp;format=html">ndis(4)</a> usa um binário Windows™ XP, ele só é executado em sistemas i386™ e amd64. Dispositivos PCI, CardBus, PCMCIA e USB são suportados.</p></div><div class=paragraph><p>Para usar o <a href="https://man.freebsd.org/cgi/man.cgi?query=ndisgen&amp;sektion=8&amp;format=html">ndisgen(8)</a>, três coisas são necessárias:</p></div><div class="olist arabic"><ol class=arabic><li><p>Código-fonte do kernel do FreeBSD.</p></li><li><p>Um binário do driver do Windows™ XP com uma extensão <span class=filename>.SYS</span>.</p></li><li><p>Um arquivo de configuração do driver do Windows™ XP com uma extensão <span class=filename>.INF</span>.</p></li></ol></div><div class=paragraph><p>Faça o download dos arquivos <span class=filename>.SYS</span> e <span class=filename>.INF</span> para a NIC específica. Geralmente, eles podem ser encontrados no CD do driver ou no site do fornecedor. Os exemplos a seguir usam o <span class=filename>W32DRIVER.SYS</span> e o <span class=filename>W32DRIVER.INF</span>.</p></div><div class=paragraph><p>A largura do bit do driver deve corresponder à versão do FreeBSD. Para FreeBSD/i386, use um driver de 32 bits Windows™. Para o FreeBSD/amd64, é necessário um driver de 64 bits do Windows™.</p></div><div class=paragraph><p>O próximo passo é compilar o binário do driver em um módulo do kernel carregável. Como <code>root</code>, use <a href="https://man.freebsd.org/cgi/man.cgi?query=ndisgen&amp;sektion=8&amp;format=html">ndisgen(8)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ndisgen /path/to/W32DRIVER.INF /path/to/W32DRIVER.SYS</span></code></pre></div></div><div class=paragraph><p>Este comando é interativo e solicita qualquer informação extra necessária. Um novo módulo do kernel será gerado no diretório atual. Use <a href="https://man.freebsd.org/cgi/man.cgi?query=kldload&amp;sektion=8&amp;format=html">kldload(8)</a> para carregar o novo módulo:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload ./W32DRIVER_SYS.ko</span></code></pre></div></div><div class=paragraph><p>Além do módulo do kernel gerado, os módulos <span class=filename>ndis.ko</span> e <span class=filename>if_ndis.ko</span> devem ser carregados. Isso deve acontecer automaticamente quando qualquer módulo que dependa do <a href="https://man.freebsd.org/cgi/man.cgi?query=ndis&amp;sektion=4&amp;format=html">ndis(4)</a> for carregado. Caso contrário, carregue-os manualmente, usando os seguintes comandos:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload ndis</span>
<span class=c># kldload if_ndis</span></code></pre></div></div><div class=paragraph><p>O primeiro comando carrega o wrapper do driver da miniporta <a href="https://man.freebsd.org/cgi/man.cgi?query=ndis&amp;sektion=4&amp;format=html">ndis(4)</a> e o segundo carrega o driver NIC gerado.</p></div><div class=paragraph><p>Execute o comando <a href="https://man.freebsd.org/cgi/man.cgi?query=dmesg&amp;sektion=8&amp;format=html">dmesg(8)</a> para ver se houve algum erro de carregamento. Se tudo correu bem, a saída deve ser semelhante à seguinte:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>ndis0: &lt;Wireless-G PCI Adapter&gt; mem 0xf4100000-0xf4101fff irq 3 at device 8.0 on pci1
ndis0: NDIS API version: 5.0
ndis0: Ethernet address: 0a:b1:2c:d3:4e:f5
ndis0: 11b rates: 1Mbps 2Mbps 5.5Mbps 11Mbps
ndis0: 11g rates: 6Mbps 9Mbps 12Mbps 18Mbps 36Mbps 48Mbps 54Mbps</code></pre></div></div><div class=paragraph><p>A partir daqui, o <span class=filename>ndis0</span> pode ser configurado como qualquer outra NIC.</p></div><div class=paragraph><p>Para configurar o sistema para carregar os módulos <a href="https://man.freebsd.org/cgi/man.cgi?query=ndis&amp;sektion=4&amp;format=html">ndis(4)</a> no momento da inicialização, copie o módulo gerado, <span class=filename>W32DRIVER_SYS.ko</span>, para <span class=filename>/boot/modules</span>. Em seguida, adicione a seguinte linha ao <span class=filename>/boot/loader.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>W32DRIVER_SYS_load=&#34;YES&#34;</pre></div></div></div></div><div class=sect2><h3 id=_configurando_a_placa_de_rede>11.5.2. Configurando a placa de rede<a class=anchor href=#_configurando_a_placa_de_rede></a></h3><div class=paragraph><p>Quando o driver correto é carregado para a NIC, a placa precisa ser configurada. Ele pode ter sido configurado no momento da instalação por <a href="https://man.freebsd.org/cgi/man.cgi?query=bsdinstall&amp;sektion=8&amp;format=html">bsdinstall(8)</a>.</p></div><div class=paragraph><p>Para exibir a configuração da NIC, digite o seguinte comando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ifconfig
dc0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        <span class=nv>options</span><span class=o>=</span>80008&lt;VLAN_MTU,LINKSTATE&gt;
        ether 00:a0:cc:da:da:da
        inet 192.168.1.3 netmask 0xffffff00 broadcast 192.168.1.255
        media: Ethernet autoselect <span class=o>(</span>100baseTX &lt;full-duplex&gt;<span class=o>)</span>
        status: active
dc1: <span class=nv>flags</span><span class=o>=</span>8802&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        <span class=nv>options</span><span class=o>=</span>80008&lt;VLAN_MTU,LINKSTATE&gt;
        ether 00:a0:cc:da:da:db
        inet 10.0.0.1 netmask 0xffffff00 broadcast 10.0.0.255
        media: Ethernet 10baseT/UTP
        status: no carrier
lo0: <span class=nv>flags</span><span class=o>=</span>8049&lt;UP,LOOPBACK,RUNNING,MULTICAST&gt; metric 0 mtu 16384
        <span class=nv>options</span><span class=o>=</span>3&lt;RXCSUM,TXCSUM&gt;
        inet6 fe80::1%lo0 prefixlen 64 scopeid 0x4
        inet6 ::1 prefixlen 128
        inet 127.0.0.1 netmask 0xff000000
        nd6 <span class=nv>options</span><span class=o>=</span>3&lt;PERFORMNUD,ACCEPT_RTADV&gt;</code></pre></div></div><div class=paragraph><p>Neste exemplo, os seguintes dispositivos foram exibidos:</p></div><div class=ulist><ul><li><p><span class=filename>dc0</span>: A primeira interface Ethernet.</p></li><li><p><span class=filename>dc1</span>: A segunda interface Ethernet.</p></li><li><p><span class=filename>lo0</span>: o dispositivo de loopback.</p></li></ul></div><div class=paragraph><p>O FreeBSD usa o nome do driver seguido da ordem em que a placa é detectada na inicialização para nomear a NIC. Por exemplo, <span class=filename>sis2</span> é a terceira NIC no sistema usando driver <a href="https://man.freebsd.org/cgi/man.cgi?query=sis&amp;sektion=4&amp;format=html">sis(4)</a>.</p></div><div class=paragraph><p>Neste exemplo, o <span class=filename>dc0</span> está ativo e em execução. Os principais indicadores são:</p></div><div class="olist arabic"><ol class=arabic><li><p><code>UP</code> significa que a placa está configurada e pronta.</p></li><li><p>A placa tem um endereço da Internet (<code>inet</code>), <code>192.168.1.3</code>.</p></li><li><p>Ela tem uma máscara de sub-rede válida (<code>netmask</code>), onde <code>0xffffff00</code> é o mesmo que <code>255.255.255.0</code> .</p></li><li><p>Tem um endereço de broadcast válido, <code>192.168.1.255</code>.</p></li><li><p>O endereço MAC da placa (<code>ether</code>) é <code>00:a0:cc:da:da:da</code>.</p></li><li><p>A seleção de mídia física está no modo de seleção automática (<code>media:Ethernet autoselect (100baseTX &lt;full-duplex>)</code>). Neste exemplo, o <span class=filename>dc1</span> está configurado para ser executado com a mídia <code>10baseT/UTP</code>. Para obter mais informações sobre tipos de mídia disponíveis para um driver, consulte sua página de manual.</p></li><li><p>O status do link (<code>status</code>) é <code>active</code>, indicando que o sinal da portadora foi detectado. Para <span class=filename>dc1</span>, o status <code>status: no carrier</code> é normal quando um cabo Ethernet não está conectado à placa.</p></li></ol></div><div class=paragraph><p>Se a saída <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a> tivesse mostrado algo semelhante a:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>dc0: <span class=nv>flags</span><span class=o>=</span>8843&lt;BROADCAST,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
	<span class=nv>options</span><span class=o>=</span>80008&lt;VLAN_MTU,LINKSTATE&gt;
	ether 00:a0:cc:da:da:da
	media: Ethernet autoselect <span class=o>(</span>100baseTX &lt;full-duplex&gt;<span class=o>)</span>
	status: active</code></pre></div></div><div class=paragraph><p>isso indicaria que a placa não foi configurada.</p></div><div class=paragraph><p>A placa deve ser configurada como <code>root</code>. A configuração da NIC pode ser realizada a partir da linha de comando com o <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a>, mas não persistirá após uma reinicialização, a menos que a configuração também seja adicionada ao <span class=filename>/etc/rc.conf</span>. Se um servidor DHCP estiver presente na LAN, basta adicionar esta linha:</p></div><div class="literalblock programlisting"><div class=content><pre>ifconfig_dc0=&#34;DHCP&#34;</pre></div></div><div class=paragraph><p>Substitua <em>dc0</em> com o valor correto para o sistema.</p></div><div class=paragraph><p>A linha adicionada, então, segue as instruções dadas em <a href=#config-network-testing>Teste e solução de problemas</a>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Se a rede foi configurada durante a instalação, algumas entradas para a NIC podem já estar presentes. Verifique novamente o <span class=filename>/etc/rc.conf</span> antes de adicionar novas linhas.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Se não existir um servidor DHCP, a NIC deve ser configurada manualmente. Adicione uma linha para cada NIC presente no sistema, conforme mostrado neste exemplo:</p></div><div class="literalblock programlisting"><div class=content><pre>ifconfig_dc0=&#34;inet 192.168.1.3 netmask 255.255.255.0&#34;
ifconfig_dc1=&#34;inet 10.0.0.1 netmask 255.255.255.0 media 10baseT/UTP&#34;</pre></div></div><div class=paragraph><p>Substitua <span class=filename>dc0</span> e <span class=filename>dc1</span> e as informações de endereço IP com os valores corretos para o sistema. Consulte a man page do driver, <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a> e <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a> para maiores detalhes sobre as opções permitidas e a sintaxe de <span class=filename>/etc/rc.conf</span>.</p></div><div class=paragraph><p>Se a rede não estiver usando DNS, edite o <span class=filename>/etc/hosts</span> para adicionar os nomes e endereços IP dos hosts na LAN, se eles ainda não estiverem lá. Para maiores informações, consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=hosts&amp;sektion=5&amp;format=html">hosts(5)</a> e <span class=filename>/usr/shared/examples/etc/hosts</span>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Se não houver um servidor DHCP e o acesso à Internet for necessário, configure manualmente o gateway padrão e o nameserver:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># echo &#39;defaultrouter=&#34;your_default_router&#34;&#39; &gt;&gt; /etc/rc.conf</span>
<span class=c># echo &#39;nameserver your_DNS_server&#39; &gt;&gt; /etc/resolv.conf</span></code></pre></div></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=config-network-testing>11.5.3. Teste e solução de problemas<a class=anchor href=#config-network-testing></a></h3><div class=paragraph><p>Uma vez que as alterações necessárias no <span class=filename>/etc/rc.conf</span> sejam salvas, uma reinicialização pode ser usada para testar a configuração de rede e verificar se o sistema é reiniciado sem nenhum erro. Como alternativa, aplique as configurações ao sistema de rede com este comando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service netif restart</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Se um gateway padrão foi configurado no <span class=filename>/etc/rc.conf</span>, também execute este comando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service routing restart</span></code></pre></div></div></td></tr></tbody></table></div><div class=paragraph><p>Uma vez que o sistema de rede tiver sido reiniciado, teste as NIC.</p></div><div class=sect3><h4 id=_testando_uma_placa_ethernet>11.5.3.1. Testando uma placa Ethernet<a class=anchor href=#_testando_uma_placa_ethernet></a></h4><div class=paragraph><p>Para verificar se uma placa Ethernet está configurada corretamente, execute um <a href="https://man.freebsd.org/cgi/man.cgi?query=ping&amp;sektion=8&amp;format=html">ping(8)</a> na própria interface e, em seguida, <a href="https://man.freebsd.org/cgi/man.cgi?query=ping&amp;sektion=8&amp;format=html">ping(8)</a> outra máquina na LAN:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ping <span class=nt>-c5</span> 192.168.1.3
PING 192.168.1.3 <span class=o>(</span>192.168.1.3<span class=o>)</span>: 56 data bytes
64 bytes from 192.168.1.3: <span class=nv>icmp_seq</span><span class=o>=</span>0 <span class=nv>ttl</span><span class=o>=</span>64 <span class=nb>time</span><span class=o>=</span>0.082 ms
64 bytes from 192.168.1.3: <span class=nv>icmp_seq</span><span class=o>=</span>1 <span class=nv>ttl</span><span class=o>=</span>64 <span class=nb>time</span><span class=o>=</span>0.074 ms
64 bytes from 192.168.1.3: <span class=nv>icmp_seq</span><span class=o>=</span>2 <span class=nv>ttl</span><span class=o>=</span>64 <span class=nb>time</span><span class=o>=</span>0.076 ms
64 bytes from 192.168.1.3: <span class=nv>icmp_seq</span><span class=o>=</span>3 <span class=nv>ttl</span><span class=o>=</span>64 <span class=nb>time</span><span class=o>=</span>0.108 ms
64 bytes from 192.168.1.3: <span class=nv>icmp_seq</span><span class=o>=</span>4 <span class=nv>ttl</span><span class=o>=</span>64 <span class=nb>time</span><span class=o>=</span>0.076 ms

<span class=nt>---</span> 192.168.1.3 ping statistics <span class=nt>---</span>
5 packets transmitted, 5 packets received, 0% packet loss
round-trip min/avg/max/stddev <span class=o>=</span> 0.074/0.083/0.108/0.013 ms</code></pre></div></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ping <span class=nt>-c5</span> 192.168.1.2
PING 192.168.1.2 <span class=o>(</span>192.168.1.2<span class=o>)</span>: 56 data bytes
64 bytes from 192.168.1.2: <span class=nv>icmp_seq</span><span class=o>=</span>0 <span class=nv>ttl</span><span class=o>=</span>64 <span class=nb>time</span><span class=o>=</span>0.726 ms
64 bytes from 192.168.1.2: <span class=nv>icmp_seq</span><span class=o>=</span>1 <span class=nv>ttl</span><span class=o>=</span>64 <span class=nb>time</span><span class=o>=</span>0.766 ms
64 bytes from 192.168.1.2: <span class=nv>icmp_seq</span><span class=o>=</span>2 <span class=nv>ttl</span><span class=o>=</span>64 <span class=nb>time</span><span class=o>=</span>0.700 ms
64 bytes from 192.168.1.2: <span class=nv>icmp_seq</span><span class=o>=</span>3 <span class=nv>ttl</span><span class=o>=</span>64 <span class=nb>time</span><span class=o>=</span>0.747 ms
64 bytes from 192.168.1.2: <span class=nv>icmp_seq</span><span class=o>=</span>4 <span class=nv>ttl</span><span class=o>=</span>64 <span class=nb>time</span><span class=o>=</span>0.704 ms

<span class=nt>---</span> 192.168.1.2 ping statistics <span class=nt>---</span>
5 packets transmitted, 5 packets received, 0% packet loss
round-trip min/avg/max/stddev <span class=o>=</span> 0.700/0.729/0.766/0.025 ms</code></pre></div></div><div class=paragraph><p>Para testar a resolução da rede, use o nome do host em vez do endereço IP. Se não houver nenhum servidor DNS na rede, o <span class=filename>/etc/hosts</span> deve ser configurado primeiro. Para este propósito, edite o <span class=filename>/etc/hosts</span> para adicionar os nomes e os endereços IP dos hosts na LAN, se eles ainda não estiverem lá . Para maiores informações, consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=hosts&amp;sektion=5&amp;format=html">hosts(5)</a> e <span class=filename>/usr/shared/examples/etc/hosts</span>.</p></div></div><div class=sect3><h4 id=_solução_de_problemas>11.5.3.2. Solução de problemas<a class=anchor href=#_solução_de_problemas></a></h4><div class=paragraph><p>Ao solucionar problemas de configurações de hardware e software, verifique primeiro as coisas simples. O cabo de rede está conectado? Os serviços de rede estão configurados corretamente? O firewall está configurado corretamente? A NIC é suportada pelo FreeBSD? Antes de enviar um relatório de bug, sempre verifique as Notas de Hardware, atualize a versão do FreeBSD para a versão mais recente do STABLE, verifique os arquivos da lista de discussão e pesquise na Internet.</p></div><div class=paragraph><p>Se a placa funcionar, mas o desempenho for ruim, leia <a href="https://man.freebsd.org/cgi/man.cgi?query=tuning&amp;sektion=7&amp;format=html">tuning(7)</a>. Além disso, verifique a configuração da rede, pois configurações de rede incorretas podem causar conexões lentas.</p></div><div class=paragraph><p>Alguns usuários experimentam uma ou duas mensagens de <code>device timeout</code>, o que é normal para algumas placas. Se eles continuarem ou forem incômodos, verifique se o dispositivo está em conflito com outro. Verifique novamente as conexões dos cabos. Considere tentar outra placa.</p></div><div class=paragraph><p>Para resolver erros de <code>watchdog timeout</code>, primeiro verifique o cabo de rede. Muitas placas requerem um slot PCI que suporte a masterização de barramento. Em algumas placas-mãe antigas, apenas um slot PCI permite, normalmente o slot 0. Verifique a NIC e a documentação da placa-mãe para determinar se esse pode ser o problema.</p></div><div class=paragraph><p>As mensagens <code>No route to host</code> ocorrem se o sistema não puder rotear um pacote para o host de destino. Isso pode acontecer se nenhuma rota padrão for especificada ou se um cabo for desconectado. Verifique a saída do <code>netstat -rn</code> e certifique-se de que haja uma rota válida para o host. Se não houver, leia <a href=../advanced-networking/#network-routing>Gateways e Rotas</a>.</p></div><div class=paragraph><p>As mensagens de erro <code>ping: sendto: Permission denied</code> são geralmente causadas por um firewall mal configurado. Se um firewall está habilitado no FreeBSD, mas nenhuma regra foi definida, a política padrão é negar todo o tráfego, mesmo o <a href="https://man.freebsd.org/cgi/man.cgi?query=ping&amp;sektion=8&amp;format=html">ping(8)</a>. Consulte <a href=../firewalls/#firewalls>Firewalls</a> para maiores informações.</p></div><div class=paragraph><p>Às vezes, o desempenho da placa é ruim ou abaixo da média. Nesses casos, tente configurar o modo de seleção de mídia de <code>autoselect</code> para a seleção de mídia correta. Embora isso funcione para a maioria dos hardwares, isso pode ou não resolver o problema. Novamente, verifique todas as configurações de rede e consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=tuning&amp;sektion=7&amp;format=html">tuning(7)</a>.</p></div></div></div></div></div><div class=sect1><h2 id=configtuning-virtual-hosts>11.6. Hosts Virtuais<a class=anchor href=#configtuning-virtual-hosts></a></h2><div class=sectionbody><div class=paragraph><p>Um uso comum do FreeBSD é a hospedagem de sites virtuais, onde um servidor aparece na rede como muitos servidores. Isso é conseguido atribuindo vários endereços de rede a uma única interface.</p></div><div class=paragraph><p>Uma determinada interface de rede tem um endereço "real" e pode ter qualquer número de endereços "alias". Esses aliases são normalmente adicionados colocando entradas de alias no <span class=filename>/etc/rc.conf</span>, como mostrado neste exemplo:</p></div><div class="literalblock programlisting"><div class=content><pre>ifconfig_fxp0_alias0=&#34;inet xxx.xxx.xxx.xxx netmask xxx.xxx.xxx.xxx&#34;</pre></div></div><div class=paragraph><p>As entradas de alias devem começar com <code>alias_0_</code> usando um número sequencial como <code>alias0</code>, <code>alias1</code> e assim por diante. O processo de configuração será interrompido no primeiro número ausente.</p></div><div class=paragraph><p>O cálculo de máscaras de alias é importante. Para uma determinada interface, deve haver um endereço que represente corretamente a máscara de rede da rede. Qualquer outro endereço dentro dessa rede deve ter uma máscara de rede toda de <code>1</code>s, expressa como <code>255.255.255.255</code> ou <code>0xffffffff</code>.</p></div><div class=paragraph><p>Por exemplo, considere o caso em que a interface <span class=filename>fxp0</span> está conectada a duas redes: <code>10.1.1.0</code> com uma máscara de rede de <code>255.255.255.0</code> e <code>202.0.75.16</code> com uma máscara de rede de <code>255.255.255.240</code>. O sistema deve ser configurado para aparecer nos intervalos <code>10.1.1.1</code> até <code>10.1.1.5</code> e <code>202.0.75.17</code> até <code>202.0.75.20</code>. Somente o primeiro endereço em um determinado intervalo de rede deve ter uma máscara de rede real. Todo o resto de (<code>10.1.1.2</code> até <code>10.1.1.5</code> e de <code>202.0.75.18</code> até <code>202.0.75.20</code>) deve ser configurado com uma máscara de rede <code>255.255.255.255</code>.</p></div><div class=paragraph><p>As seguintes entradas <span class=filename>/etc/rc.conf</span> configuram o adaptador corretamente para este cenário:</p></div><div class="literalblock programlisting"><div class=content><pre>ifconfig_fxp0=&#34;inet 10.1.1.1 netmask 255.255.255.0&#34;
ifconfig_fxp0_alias0=&#34;inet 10.1.1.2 netmask 255.255.255.255&#34;
ifconfig_fxp0_alias1=&#34;inet 10.1.1.3 netmask 255.255.255.255&#34;
ifconfig_fxp0_alias2=&#34;inet 10.1.1.4 netmask 255.255.255.255&#34;
ifconfig_fxp0_alias3=&#34;inet 10.1.1.5 netmask 255.255.255.255&#34;
ifconfig_fxp0_alias4=&#34;inet 202.0.75.17 netmask 255.255.255.240&#34;
ifconfig_fxp0_alias5=&#34;inet 202.0.75.18 netmask 255.255.255.255&#34;
ifconfig_fxp0_alias6=&#34;inet 202.0.75.19 netmask 255.255.255.255&#34;
ifconfig_fxp0_alias7=&#34;inet 202.0.75.20 netmask 255.255.255.255&#34;</pre></div></div><div class=paragraph><p>Uma maneira mais simples de expressar isso é com uma lista separada por espaço de intervalos de endereços IP. O primeiro endereço receberá a máscara de sub-rede indicada e os endereços adicionais terão uma máscara de sub-rede <code>255.255.255.255</code>.</p></div><div class="literalblock programlisting"><div class=content><pre>ifconfig_fxp0_aliases=&#34;inet 10.1.1.1-5/24 inet 202.0.75.17-20/28&#34;</pre></div></div></div></div><div class=sect1><h2 id=configtuning-syslog>11.7. Configurando o log do sistema<a class=anchor href=#configtuning-syslog></a></h2><div class=sectionbody><div class=paragraph><p>Gerar e ler logs do sistema é um aspecto importante da administração do sistema. As informações nos registros do sistema podem ser usadas para detectar problemas de hardware e software, bem como erros de configuração dos aplicativos e do sistema. Essas informações também desempenham um papel importante na auditoria de segurança e na resposta a incidentes. A maioria dos daemons e aplicativos do sistema geram entradas de log.</p></div><div class=paragraph><p>O FreeBSD fornece um registrador de sistema, o syslogd, para gerenciar o registro. Por padrão, o syslogd é iniciado quando o sistema é inicializado. Isto é controlado pela variável <code>syslogd_enable</code> no <span class=filename>/etc/rc.conf</span>. Existem vários argumentos de aplicação que podem ser definidos usando <code>syslogd_flags</code> no <span class=filename>/etc/rc.conf</span>. Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=syslogd&amp;sektion=8&amp;format=html">syslogd(8)</a> para obter maiores informações sobre os argumentos disponíveis.</p></div><div class=paragraph><p>Esta seção descreve como configurar o criador de logs do sistema FreeBSD para log local e remoto e como executar a rotação de log e o gerenciamento de log.</p></div><div class=sect2><h3 id=_configurando_os_logs_locais>11.7.1. Configurando os logs locais<a class=anchor href=#_configurando_os_logs_locais></a></h3><div class=paragraph><p>O arquivo de configuração, <span class=filename>/etc/syslog.conf</span>, controla o que o syslogd faz com as entradas de log à medida que são recebidas. Existem vários parâmetros para controlar o tratamento de eventos recebidos. O <em>facility</em> descreve qual subsistema gerou a mensagem, como o kernel ou um daemon, e o <em>level</em> descreve a gravidade do evento que ocorreu. Isso possibilita configurar onde uma mensagem de log é registrada, dependendo da instalação e do nível. Também é possível executar uma ação dependendo do aplicativo que enviou a mensagem e, no caso de log remoto, o nome do host da máquina que gera o evento de log.</p></div><div class=paragraph><p>Este arquivo de configuração contém uma linha por ação, em que a sintaxe de cada linha é um campo seletor seguido por um campo de ação. A sintaxe do campo seletor é <em>facility.level</em>, que corresponderá às mensagens de log de <em>facility</em> no nível <em>level</em> ou superior. Também é possível adicionar um sinalizador de comparação opcional antes do nível para especificar mais precisamente o que está registrado. Vários campos seletores podem ser usados para a mesma ação e são separados por um ponto-e-vírgula (<code>;</code>). Usar <code>*</code> irá corresponder a tudo. O campo de ação indica para onde enviar a mensagem de log, como para um arquivo ou host de log remoto. Por exemplo, aqui está o <span class=filename>syslog.conf</span> padrão do FreeBSD:</p></div><div class="literalblock programlisting"><div class=content><pre># $FreeBSD: head/pt_BR.ISO8859-1/books/handbook/book.xml 53984 2020-03-15 16:03:31Z dbaio $
#
#       Spaces ARE valid field separators in this file. However,
#       other *nix-like systems still insist on using tabs as field
#       separators. If you are sharing this file between systems, you
#       may want to use only tabs as field separators here.
#       Consult the syslog.conf(5) manpage.
*.err;kern.warning;auth.notice;mail.crit                /dev/console
*.notice;authpriv.none;kern.debug;lpr.info;mail.crit;news.err   /var/log/messages
security.*                                      /var/log/security
auth.info;authpriv.info                         /var/log/auth.log
mail.info                                       /var/log/maillog
lpr.info                                        /var/log/lpd-errs
ftp.info                                        /var/log/xferlog
cron.*                                          /var/log/cron
!-devd
*.=debug                                        /var/log/debug.log
*.emerg                                         *
# uncomment this to log all writes to /dev/console to /var/log/console.log
#console.info                                   /var/log/console.log
# uncomment this to enable logging of all log messages to /var/log/all.log
# touch /var/log/all.log and chmod it to mode 600 before it will work
#*.*                                            /var/log/all.log
# uncomment this to enable logging to a remote loghost named loghost
#*.*                                            @loghost
# uncomment these if you&#39;re running inn
# news.crit                                     /var/log/news/news.crit
# news.err                                      /var/log/news/news.err
# news.notice                                   /var/log/news/news.notice
# Uncomment this if you wish to see messages produced by devd
# !devd
# *.&gt;=info
!ppp
*.*                                             /var/log/ppp.log
!*</pre></div></div><div class=paragraph><p>Neste exemplo:</p></div><div class=ulist><ul><li><p>A linha 8 combina todas as mensagens com um nível de <code>err</code> ou superior, bem como <code>kern.warning</code>, <code>auth.notice</code> e <code>mail.crit</code>, e envia essas mensagens de log para o console (<span class=filename>/dev/console</span>).</p></li><li><p>A linha 12 combina todas as mensagens do recurso <code>mail</code> no nível <code>info</code> ou acima e registra as mensagens em <span class=filename>/var/log/maillog</span>.</p></li><li><p>A linha 17 usa um sinalizador de comparação (<code>=</code>) para corresponder apenas as mensagens no nível <code>debug</code> e registrá-las em <span class=filename>/var/log/debug.log</span>.</p></li><li><p>A linha 33 é um exemplo de uso de uma especificação de programa. Isso faz com que as regras que a seguem apenas sejam válidas para o programa especificado. Neste caso, somente as mensagens geradas pelo ppp são registradas em <span class=filename>/var/log/ppp.log</span>.</p></li></ul></div><div class=paragraph><p>Os níveis disponíveis, na ordem dos mais para o menos críticos, são <code>emerg</code>, <code>alert</code>, <code>crit</code>, <code>err</code>, <code>warning</code>, <code>notice</code>, <code>info</code>, and <code>debug</code>.</p></div><div class=paragraph><p>As facilities, em nenhuma ordem particular, são <code>auth</code>, <code>authpriv</code>, <code>console</code>, <code>cron</code>, <code>daemon</code>, <code>ftp</code>, <code>kern</code>, <code>lpr</code>, <code>mail</code>, <code>mark</code>, <code>news</code>, <code>security</code>, <code>syslog</code>, <code>user</code>, <code>uucp</code>, and <code>local0</code> through <code>local7</code>. Esteja ciente de que outros sistemas operacionais podem ter recursos diferentes.</p></div><div class=paragraph><p>Para registrar tudo do nível <code>notice</code> e superior para <span class=filename>/var/log/daemon.log</span>, adicione a seguinte entrada:</p></div><div class="literalblock programlisting"><div class=content><pre>daemon.notice                                        /var/log/daemon.log</pre></div></div><div class=paragraph><p>Para obter mais informações sobre os diferentes níveis e facilities, consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=syslog&amp;sektion=3&amp;format=html">syslog(3)</a> e <a href="https://man.freebsd.org/cgi/man.cgi?query=syslogd&amp;sektion=8&amp;format=html">syslogd(8)</a>. Para maiores informações sobre <span class=filename>/etc/syslog.conf</span>, sua sintaxe e exemplos de uso mais avançados, veja <a href="https://man.freebsd.org/cgi/man.cgi?query=syslog.conf&amp;sektion=5&amp;format=html">syslog.conf(5)</a>.</p></div></div><div class=sect2><h3 id=_gerenciamento_de_log_e_rotação>11.7.2. Gerenciamento de log e rotação<a class=anchor href=#_gerenciamento_de_log_e_rotação></a></h3><div class=paragraph><p>Os arquivos de log podem crescer rapidamente, ocupando espaço em disco e dificultando a localização de informações úteis. O gerenciamento de log tenta atenuar isso. No FreeBSD, o newsyslog é usado para gerenciar arquivos de log. Este programa interno rotaciona e comprime periodicamente arquivos de log e, opcionalmente, cria arquivos de log ausentes e sinaliza os programas quando os arquivos de log são movidos. Os arquivos de log podem ser gerados pelo syslogd ou por qualquer outro programa que gere arquivos de log. Enquanto o newsyslog é normalmente executado a partir do <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a>, ele não é um daemon do sistema. Na configuração padrão, ele é executado a cada hora.</p></div><div class=paragraph><p>Para saber quais ações executar, o newsyslog lê seu arquivo de configuração, <span class=filename>/etc/newsyslog.conf</span>. Este arquivo contém uma linha para cada arquivo de log que o newsyslog gerencia. Cada linha indica o proprietário do arquivo, suas permissões, quando rotacionar esse arquivo, flags opcionais que afetam a rotação do log, como compactação, e programas para sinalizar quando o log é rotacionado. Aqui está a configuração padrão no FreeBSD:</p></div><div class="literalblock programlisting"><div class=content><pre># configuration file for newsyslog
# $FreeBSD: head/pt_BR.ISO8859-1/books/handbook/book.xml 53984 2020-03-15 16:03:31Z dbaio $
#
# Entries which do not specify the &#39;/pid_file&#39; field will cause the
# syslogd process to be signalled when that log file is rotated.  This
# action is only appropriate for log files which are written to by the
# syslogd process (ie, files listed in /etc/syslog.conf).  If there
# is no process which needs to be signalled when a given log file is
# rotated, then the entry for that file should include the &#39;N&#39; flag.
#
# The &#39;flags&#39; field is one or more of the letters: BCDGJNUXZ or a &#39;-&#39;.
#
# Note: some sites will want to select more restrictive protections than the
# defaults.  In particular, it may be desirable to switch many of the 644
# entries to 640 or 600.  For example, some sites will consider the
# contents of maillog, messages, and lpd-errs to be confidential.  In the
# future, these defaults may change to more conservative ones.
#
# logfilename          [owner:group]    mode count size when  flags [/pid_file] [sig_num]
/var/log/all.log                        600  7     *    @T00  J
/var/log/amd.log                        644  7     100  *     J
/var/log/auth.log                       600  7     100  @0101T JC
/var/log/console.log                    600  5     100  *     J
/var/log/cron                           600  3     100  *     JC
/var/log/daily.log                      640  7     *    @T00  JN
/var/log/debug.log                      600  7     100  *     JC
/var/log/kerberos.log                   600  7     100  *     J
/var/log/lpd-errs                       644  7     100  *     JC
/var/log/maillog                        640  7     *    @T00  JC
/var/log/messages                       644  5     100  @0101T JC
/var/log/monthly.log                    640  12    *    $M1D0 JN
/var/log/pflog                          600  3     100  *     JB    /var/run/pflogd.pid
/var/log/ppp.log        root:network    640  3     100  *     JC
/var/log/devd.log                       644  3     100  *     JC
/var/log/security                       600  10    100  *     JC
/var/log/sendmail.st                    640  10    *    168   B
/var/log/utx.log                        644  3     *    @01T05 B
/var/log/weekly.log                     640  5     1    $W6D0 JN
/var/log/xferlog                        600  7     100  *     JC</pre></div></div><div class=paragraph><p>Cada linha começa com o nome do log a ser rotacionado, seguido opcionalmente por um proprietário e um grupo para arquivos rotacionados e recém-criados. O campo <code>mode</code> define as permissões no arquivo de log e <code>count</code> indica quantos arquivos de log rotacionados devem ser mantidos. Os campos <code>size</code> e <code>when</code> informam o newsyslog quando rotacionar o arquivo. Um arquivo de log é rotacionado quando seu tamanho é maior que o campo <code>size</code> ou quando o tempo no campo <code>when</code> tiver terminado. Um asterisco (<code>*</code>) significa que este campo é ignorado. O campo <em>flags</em> fornece instruções adicionais, por exemplo, como compactar o arquivo rotacionado ou criar o arquivo de log se ele estiver ausente. Os dois últimos campos são opcionais e especificam o nome do arquivo de ID de Processo (PID) e um número de sinal para enviar a esse processo quando o arquivo é rotacionado.</p></div><div class=paragraph><p>Para obter maiores informações sobre todos os campos, sinalizadores válidos e como sobre especificar o tempo de rotação, consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=newsyslog.conf&amp;sektion=5&amp;format=html">newsyslog.conf(5)</a>. Como o newsyslog é executado a partir do <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a>, ele não pode rotacionar arquivos com mais frequência do que a que está planejada para ser executada no <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a>.</p></div></div><div class=sect2><h3 id=network-syslogd>11.7.3. Configurando o log remoto<a class=anchor href=#network-syslogd></a></h3><div class=paragraph><p>Monitorar os arquivos de log de vários hosts pode se tornar difícil à medida que o número de sistemas aumenta. Configurar o log centralizado pode reduzir parte da carga administrativa da administração dos arquivos de log.</p></div><div class=paragraph><p>No FreeBSD, a agregação, a fusão e a rotação centralizada de arquivos de log podem ser configuradas usando o syslogd e o newsyslog. Esta seção demonstra um exemplo de configuração, em que host o <code>A</code>, chamado <code>logserv.example.com</code>, coletará informações de log para a rede local. O host <code>B</code>, denominado <code>logclient.example.com</code>, será configurado para transmitir informações de log para o servidor de registro em log.</p></div><div class=sect3><h4 id=_configuração_do_servidor_de_log>11.7.3.1. Configuração do servidor de log<a class=anchor href=#_configuração_do_servidor_de_log></a></h4><div class=paragraph><p>Um servidor de log é um sistema que foi configurado para aceitar informações de log de outros hosts. Antes de configurar um servidor de log, verifique o seguinte:</p></div><div class=ulist><ul><li><p>Se houver um firewall entre o servidor de log e qualquer cliente de log, certifique-se de que o conjunto de regras do firewall permita a porta 514 do UDP para os clientes e o servidor.</p></li><li><p>O servidor de log e todas as máquinas clientes devem ter entradas de nome diretas e reversas no DNS local. Se a rede não tiver um servidor DNS, crie entradas no <span class=filename>/etc/hosts</span> de cada sistema. A resolução adequada de nomes é necessária para que as entradas de log não sejam rejeitadas pelo servidor de log.</p></li></ul></div><div class=paragraph><p>No servidor de log, edite o <span class=filename>/etc/syslog.conf</span> para especificar o nome do cliente para receber as entradas de log, o recurso de log a ser usado e o nome do log para armazenar as entradas de log do host. Este exemplo adiciona o nome do host de <code>B</code>, registra todos os recursos e armazena as entradas de log em <span class=filename>/var/log/logclient.log</span>.</p></div><div class=exampleblock><div class=title>Exemplo 1. Configuração do servidor de log de exemplo</div><div class=content><div class="literalblock programlisting"><div class=content><pre>+logclient.example.com
*.*     /var/log/logclient.log</pre></div></div></div></div><div class=paragraph><p>Ao adicionar vários clientes de log, adicione uma entrada semelhante de duas linhas para cada cliente. Maiores informações sobre os recursos disponíveis podem ser encontradas em <a href="https://man.freebsd.org/cgi/man.cgi?query=syslog.conf&amp;sektion=5&amp;format=html">syslog.conf(5)</a>.</p></div><div class=paragraph><p>Em seguida, configure o <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>syslogd_enable=&#34;YES&#34;
syslogd_flags=&#34;-a logclient.example.com -v -v&#34;</pre></div></div><div class=paragraph><p>A primeira entrada inicia o syslogd na inicialização do sistema. A segunda entrada permite entradas de log do cliente especificado. A opção <code>-v -v</code> aumenta a verbosidade das mensagens registradas. Isso é útil para ajustar os recursos, pois os administradores podem ver o tipo de mensagens que estão sendo registradas em cada facility.</p></div><div class=paragraph><p>Múltiplas opções <code>-a</code> podem ser especificadas para permitir o registro de múltiplos clientes. Endereços IP e netblocks inteiros também podem ser especificados. Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=syslogd&amp;sektion=8&amp;format=html">syslogd(8)</a> para obter uma lista completa de opções possíveis.</p></div><div class=paragraph><p>Finalmente, crie o arquivo de log:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># touch /var/log/logclient.log</span></code></pre></div></div><div class=paragraph><p>Neste ponto, o syslogd deve ser reiniciado e verificado:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service syslogd restart</span>
<span class=c># pgrep syslog</span></code></pre></div></div><div class=paragraph><p>Se um PID for retornado, o servidor será reiniciado com êxito e a configuração do cliente poderá ser iniciada. Se o servidor não reiniciar, consulte <span class=filename>/var/log/messages</span> para visualizar o erro.</p></div></div><div class=sect3><h4 id=_configuração_do_cliente_de_log>11.7.3.2. Configuração do cliente de log<a class=anchor href=#_configuração_do_cliente_de_log></a></h4><div class=paragraph><p>Um cliente de log envia entradas de log para um servidor de log na rede. O cliente também mantém uma cópia local de seus próprios logs.</p></div><div class=paragraph><p>Uma vez que o servidor de log foi configurado, edite o <span class=filename>/etc/rc.conf</span> no cliente de registro:</p></div><div class="literalblock programlisting"><div class=content><pre>syslogd_enable=&#34;YES&#34;
syslogd_flags=&#34;-s -v -v&#34;</pre></div></div><div class=paragraph><p>A primeira entrada ativa o syslogd na inicialização. A segunda entrada impede que os logs sejam aceitos por esse cliente de outros hosts (<code>-s</code>) e aumenta a verbosidade das mensagens registradas.</p></div><div class=paragraph><p>Em seguida, defina o servidor de log no <span class=filename>/etc/syslog.conf</span> do cliente. Neste exemplo, todos os facilities registrados são enviados para um sistema remoto, indicado pelo símbolo <code>@</code>, com o nome do host especificado:</p></div><div class="literalblock programlisting"><div class=content><pre>*.*		@logserv.example.com</pre></div></div><div class=paragraph><p>Depois de salvar a edição, reinicie o syslogd para que as alterações entrem em vigor:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service syslogd restart</span></code></pre></div></div><div class=paragraph><p>Para testar se as mensagens de log estão sendo enviadas pela rede, use o <a href="https://man.freebsd.org/cgi/man.cgi?query=logger&amp;sektion=1&amp;format=html">logger(1)</a> no cliente para enviar uma mensagem para syslogd:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># logger &#34;Test message from logclient&#34;</span></code></pre></div></div><div class=paragraph><p>Esta mensagem agora deve existir tanto no <span class=filename>/var/log/messages</span> do cliente e no <span class=filename>/var/log/logclient.log</span> do servidor de log.</p></div></div><div class=sect3><h4 id=_debugando_servidores_de_log>11.7.3.3. Debugando servidores de log<a class=anchor href=#_debugando_servidores_de_log></a></h4><div class=paragraph><p>Se nenhuma mensagem estiver sendo recebida no servidor de log, a causa provavelmente é um problema de conectividade de rede, um problema de resolução de nome de host ou um erro de digitação em um arquivo de configuração. Para isolar a causa, certifique-se de que o servidor de log e o cliente de log sejam capazes de comunicarem através do <code>ping</code> usando o nome do host especificado em seu <span class=filename>/etc/rc.conf</span>. Se isso falhar, verifique o cabeamento da rede, o conjunto de regras do firewall e as entradas de nome de host no servidor DNS ou <span class=filename>/etc/hosts</span> no servidor de log e nos clientes. Repita até que o <code>ping</code> seja bem-sucedido em ambos os hosts.</p></div><div class=paragraph><p>Se o <code>ping</code> for bem-sucedido em ambos os hosts, mas as mensagens de log ainda não estiverem sendo recebidas, aumente temporariamente o detalhamento do log para diminuir o problema de configuração. No exemplo a seguir, o <span class=filename>/var/log/logclient.log</span> no servidor de log está vazio e o <span class=filename>/var/log/messages</span> no cliente de log não indica uma razão para a falha. Para aumentar a saída de debug, edite a entrada <code>syslogd_flags</code> no servidor de log e execute uma reinicialização:</p></div><div class="literalblock programlisting"><div class=content><pre>syslogd_flags=&#34;-d -a logclient.example.com -v -v&#34;</pre></div></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service syslogd restart</span></code></pre></div></div><div class=paragraph><p>Dados de debug semelhantes aos seguintes irão aparecer no console imediatamente após a reinicialização:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>logmsg: pri 56, flags 4, from logserv.example.com, msg syslogd: restart
syslogd: restarted
logmsg: pri 6, flags 4, from logserv.example.com, msg syslogd: kernel boot file is /boot/kernel/kernel
Logging to FILE /var/log/messages
syslogd: kernel boot file is /boot/kernel/kernel
cvthname<span class=o>(</span>192.168.1.10<span class=o>)</span>
validate: dgram from IP 192.168.1.10, port 514, name logclient.example.com<span class=p>;</span>
rejected <span class=k>in </span>rule 0 due to name mismatch.</code></pre></div></div><div class=paragraph><p>Neste exemplo, as mensagens de log estão sendo rejeitadas devido a um erro de digitação que resulta em uma incompatibilidade de nome de host. O nome do host do cliente deve ser <code>logclient</code>, não <code>logclien</code>. Corrija o erro de digitação, execute uma reinicialização e verifique os resultados:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service syslogd restart</span>
logmsg: pri 56, flags 4, from logserv.example.com, msg syslogd: restart
syslogd: restarted
logmsg: pri 6, flags 4, from logserv.example.com, msg syslogd: kernel boot file is /boot/kernel/kernel
syslogd: kernel boot file is /boot/kernel/kernel
logmsg: pri 166, flags 17, from logserv.example.com,
msg Dec 10 20:55:02 &lt;syslog.err&gt; logserv.example.com syslogd: exiting on signal 2
cvthname<span class=o>(</span>192.168.1.10<span class=o>)</span>
validate: dgram from IP 192.168.1.10, port 514, name logclient.example.com<span class=p>;</span>
accepted <span class=k>in </span>rule 0.
logmsg: pri 15, flags 0, from logclient.example.com, msg Dec 11 02:01:28 trhodes: Test message 2
Logging to FILE /var/log/logclient.log
Logging to FILE /var/log/messages</code></pre></div></div><div class=paragraph><p>Neste ponto, as mensagens estão sendo recebidas e colocadas corretamente no arquivo correto.</p></div></div><div class=sect3><h4 id=_considerações_de_segurança>11.7.3.4. Considerações de segurança<a class=anchor href=#_considerações_de_segurança></a></h4><div class=paragraph><p>Como com qualquer serviço de rede, os requisitos de segurança devem ser considerados antes de implementar um servidor de log. Os arquivos de log podem conter dados confidenciais sobre serviços ativados no host local, contas de usuário e dados de configuração. Os dados enviados pela rede do cliente para o servidor não serão criptografados nem protegidos por senha. Se houver necessidade de criptografia, considere o uso do <a class=package href=https://cgit.freebsd.org/ports/tree/security/stunnel/>security/stunnel</a>, que transmitirá os dados de log em um túnel criptografado.</p></div><div class=paragraph><p>A segurança local também é um problema. Os arquivos de log não são criptografados durante o uso ou após a rotação do log. Usuários locais podem acessar arquivos de log para obter informações adicionais sobre a configuração do sistema. Definir permissões adequadas nos arquivos de log é crítico. O rotacionador de log integrado, newsyslog, suporta a configuração de permissões em arquivos de log recém-criados e rotacionados. A configuração de arquivos de log no modo <code>600</code> deve impedir o acesso indesejado por usuários locais. Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=newsyslog.conf&amp;sektion=5&amp;format=html">newsyslog.conf(5)</a> para obter informações adicionais.</p></div></div></div></div></div><div class=sect1><h2 id=configtuning-configfiles>11.8. Arquivos de Configuração<a class=anchor href=#configtuning-configfiles></a></h2><div class=sectionbody><div class=sect2><h3 id=_layout_do_etc>11.8.1. Layout do <span class=filename>/etc</span><a class=anchor href=#_layout_do_etc></a></h3><div class=paragraph><p>Existem vários diretórios nos quais as informações de configuração são mantidas. Estes incluem:</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/etc</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Informações de configuração específica do sistema genérico.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/etc/defaults</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Versões padrão dos arquivos de configuração do sistema.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/etc/mail</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Configuração extra do <a href="https://man.freebsd.org/cgi/man.cgi?query=sendmail&amp;sektion=8&amp;format=html">sendmail(8)</a> e outros arquivos de configuração MTA.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/etc/ppp</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Configuração para ambos os programas, user- e kernel-ppp.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/local/etc</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Arquivos de configuração para aplicativos instalados. Pode conter subdiretórios para cada aplicativo.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/local/etc/rc.d</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>scripts <a href="https://man.freebsd.org/cgi/man.cgi?query=rc&amp;sektion=8&amp;format=html">rc(8)</a> para os aplicativos instalados.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/var/db</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Arquivos de banco de dados específicos do sistema gerados automaticamente, como o banco de dados de pacotes e o banco de dados <a href="https://man.freebsd.org/cgi/man.cgi?query=locate&amp;sektion=1&amp;format=html">locate(1)</a>.</p></td></tr></tbody></table></div><div class=sect2><h3 id=_hostnames>11.8.2. Hostnames<a class=anchor href=#_hostnames></a></h3><div class=sect3><h4 id=_etcresolv_conf>11.8.2.1. <span class=filename>/etc/resolv.conf</span><a class=anchor href=#_etcresolv_conf></a></h4><div class=paragraph><p>Como um sistema FreeBSD acessa o Sistema de Nomes de Domínio da Internet (Internet Domain Name System - DNS) é controlado por <a href="https://man.freebsd.org/cgi/man.cgi?query=resolv.conf&amp;sektion=5&amp;format=html">resolv.conf(5)</a>.</p></div><div class=paragraph><p>As entradas mais comuns para o <span class=filename>/etc/resolv.conf</span> são:</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>nameserver</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>O endereço IP de um servidor de nomes que o resolvedor deve consultar. Os servidores são consultados na ordem listada com um máximo de três.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>search</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Lista de pesquisa, para busca de nomes de host. Isso é normalmente determinado pelo domínio do nome do host local.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>domain</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>O nome do domínio local.</p></td></tr></tbody></table><div class=paragraph><p>Um típico <span class=filename>/etc/resolv.conf</span> é assim:</p></div><div class="literalblock programlisting"><div class=content><pre>search example.com
nameserver 147.11.1.11
nameserver 147.11.100.30</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Apenas uma das opções <code>search</code> e <code>domain</code> deve ser usada.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Ao usar o DHCP, o <a href="https://man.freebsd.org/cgi/man.cgi?query=dhclient&amp;sektion=8&amp;format=html">dhclient(8)</a> geralmente reescreve o <span class=filename>/etc/resolv.conf</span> com informações recebidas do servidor DHCP.</p></div></div><div class=sect3><h4 id=_etchosts>11.8.2.2. <span class=filename>/etc/hosts</span><a class=anchor href=#_etchosts></a></h4><div class=paragraph><p>O <span class=filename>/etc/hosts</span> é um banco de dados de texto simples que funciona em conjunto com o DNS e o NIS para fornecer o nome do host aos mapeamentos de endereços IP. Entradas para computadores locais conectados através de uma LAN podem ser adicionadas a este arquivo para propósitos simplistas de nomeação em vez de configurar um servidor <a href="https://man.freebsd.org/cgi/man.cgi?query=named&amp;sektion=8&amp;format=html">named(8)</a>. Além disso, o <span class=filename>/etc/hosts</span> pode ser usado para fornecer um registro local de nomes da Internet, reduzindo a necessidade de consultar servidores DNS externos para nomes comumente acessados.</p></div><div class="literalblock programlisting"><div class=content><pre># $FreeBSD: head/pt_BR.ISO8859-1/books/handbook/book.xml 53984 2020-03-15 16:03:31Z dbaio $
#
#
# Host Database
#
# This file should contain the addresses and aliases for local hosts that
# share this file.  Replace &#39;my.domain&#39; below with the domainname of your
# machine.
#
# In the presence of the domain name service or NIS, this file may
# not be consulted at all; see /etc/nsswitch.conf for the resolution order.
#
#
::1			localhost localhost.my.domain
127.0.0.1		localhost localhost.my.domain
#
# Imaginary network.
#10.0.0.2		myname.my.domain myname
#10.0.0.3		myfriend.my.domain myfriend
#
# According to RFC 1918, you can use the following IP networks for
# private nets which will never be connected to the Internet:
#
#	10.0.0.0	-   10.255.255.255
#	172.16.0.0	-   172.31.255.255
#	192.168.0.0	-   192.168.255.255
#
# In case you want to be able to connect to the Internet, you need
# real official assigned numbers.  Do not try to invent your own network
# numbers but instead get one from your network provider (if any) or
# from your regional registry (ARIN, APNIC, LACNIC, RIPE NCC, or AfriNIC.)
#</pre></div></div><div class=paragraph><p>O formato do <span class=filename>/etc/hosts</span> é o seguinte:</p></div><div class="literalblock programlisting"><div class=content><pre>[Internet address] [official hostname] [alias1] [alias2] ...</pre></div></div><div class=paragraph><p>Por exemplo:</p></div><div class="literalblock programlisting"><div class=content><pre>10.0.0.1 myRealHostname.example.com myRealHostname foobar1 foobar2</pre></div></div><div class=paragraph><p>Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=hosts&amp;sektion=5&amp;format=html">hosts(5)</a> para obter maiores informações.</p></div></div></div></div></div><div class=sect1><h2 id=configtuning-sysctl>11.9. Efetuando ajustes com o <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a><a class=anchor href=#configtuning-sysctl></a></h2><div class=sectionbody><div class=paragraph><p>O <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> é usado para fazer mudanças em um sistema FreeBSD em execução. Isso inclui muitas opções avançadas da stack TCP/IP e do sistema de memória virtual as quais podem melhorar drasticamente o desempenho do FreeBSD para um administrador de sistema experiente. Mais de quinhentas variáveis do sistema podem ser lidas e definidas usando o <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a>.</p></div><div class=paragraph><p>Em sua essência, o <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> serve duas funções: ler e modificar as configurações do sistema.</p></div><div class=paragraph><p>Para ver todas as variáveis legíveis:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% sysctl <span class=nt>-a</span></code></pre></div></div><div class=paragraph><p>Para ler uma variável específica, especifique seu nome:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% sysctl kern.maxproc
kern.maxproc: 1044</code></pre></div></div><div class=paragraph><p>Para definir uma variável específica, use a sintaxe <em>variable</em>=<em>value</em>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl kern.maxfiles=5000</span>
kern.maxfiles: 2088 -&gt; 5000</code></pre></div></div><div class=paragraph><p>As configurações das variáveis sysctl são geralmente strings, números ou booleanos, onde um booleano é <code>1</code> para sim <code>0</code> para não.</p></div><div class=paragraph><p>Para definir automaticamente algumas variáveis sempre que a máquina inicializar, adicione-as ao <span class=filename>/etc/sysctl.conf</span>. Para maiores informações, consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl.conf&amp;sektion=5&amp;format=html">sysctl.conf(5)</a> e <a href=#configtuning-sysctlconf><span class=filename>sysctl.conf</span></a>.</p></div><div class=sect2><h3 id=configtuning-sysctlconf>11.9.1. <span class=filename>sysctl.conf</span><a class=anchor href=#configtuning-sysctlconf></a></h3><div class=paragraph><p>O arquivo de configuração para o <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a>, <span class=filename>/etc/sysctl.conf</span>, se parece muito com o <span class=filename>/etc /rc.conf</span>. Os valores são definidos na forma <code>variable=value</code>. Os valores especificados são definidos após o sistema entrar no modo multiusuário. Nem todas as variáveis são configuráveis neste modo.</p></div><div class=paragraph><p>Por exemplo, para desativar o log de saídas de sinais fatais e impedir que os usuários vejam processos iniciados por outros usuários, os seguintes ajustes podem ser configurados em <span class=filename>/etc/sysctl.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre># Do not log fatal signal exits (e.g., sig 11)
kern.logsigexit=0

# Prevent users from seeing information about processes that
# are being run under another UID.
security.bsd.see_other_uids=0</pre></div></div></div><div class=sect2><h3 id=sysctl-readonly>11.9.2. Variáveis <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> apenas de leitura<a class=anchor href=#sysctl-readonly></a></h3><div class=paragraph><p>Em alguns casos, pode ser desejável modificar os valores de variáveis do <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> que são somente de leitura, o que exigirá uma reinicialização do sistema.</p></div><div class=paragraph><p>Por exemplo, em alguns modelos de laptops, o dispositivo <a href="https://man.freebsd.org/cgi/man.cgi?query=cardbus&amp;sektion=4&amp;format=html">cardbus(4)</a> não examinará os intervalos de memória e falhará com erros semelhantes a:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>cbb0: Could not map register memory
device_probe_and_attach: cbb0 attach returned 12</code></pre></div></div><div class=paragraph><p>A correção requer a modificação de uma configuração definida por uma variável do <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> que é somente de leitura. Adicione <code>hw.pci.allow_unsupported_io_range=1</code> ao arquivo <span class=filename>/boot/loader.conf</span> e reinicie. Agora o <a href="https://man.freebsd.org/cgi/man.cgi?query=cardbus&amp;sektion=4&amp;format=html">cardbus(4)</a> deve funcionar corretamente.</p></div></div></div></div><div class=sect1><h2 id=configtuning-disk>11.10. Otimização de Discos<a class=anchor href=#configtuning-disk></a></h2><div class=sectionbody><div class=paragraph><p>A seção a seguir discutirá vários mecanismos e opções de ajuste que podem ser aplicados a dispositivos de disco. Em muitos casos, discos com partes mecânicas, como unidades SCSI, serão o gargalo que reduz o desempenho geral do sistema. Embora a solução seja instalar uma unidade sem peças mecânicas, como uma unidade de estado sólido, as unidades mecânicas não irão desaparecer num futuro próximo. Quando estiver otimizando discos, é aconselhável utilizar os recursos do comando <a href="https://man.freebsd.org/cgi/man.cgi?query=iostat&amp;sektion=8&amp;format=html">iostat(8)</a> para testar várias mudanças no sistema. Este comando permitirá ao usuário obter informações valiosas sobre o sistema IO.</p></div><div class=sect2><h3 id=_variáveis_sysctl>11.10.1. Variáveis Sysctl<a class=anchor href=#_variáveis_sysctl></a></h3><div class=sect3><h4 id=_vfs_vmiodirenable>11.10.1.1. <code>vfs.vmiodirenable</code><a class=anchor href=#_vfs_vmiodirenable></a></h4><div class=paragraph><p>A variável <code>vfs.vmiodirenable</code> <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> pode ser definida como <code>0</code> (off ) ou <code>1</code> (on). Está definida para <code>1</code> por padrão. Esta variável controla como os diretórios são armazenados em cache pelo sistema. A maioria dos diretórios é pequena, usando apenas um único fragmento (normalmente 1K) no sistema de arquivos e, normalmente, 512 bytes no cache de buffer. Com esta variável desativada, o cache de buffer armazenará apenas um número fixo de diretórios, mesmo que o sistema tenha uma quantidade enorme de memória. Quando ativado, este <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> permite que o cache de buffer use o cache de página VM para armazenar em cache os diretórios, disponibilizando toda a memória para fazer cache dos diretórios. No entanto, a memória mínima no núcleo usada para armazenar em cache um diretório é o tamanho da página física (geralmente 4K) em vez de 512 bytes. Manter esta opção ativada é recomendado se o sistema estiver executando quaisquer serviços que manipulem um grande número de arquivos. Esses serviços podem incluir caches da web, grandes sistemas de correio e sistemas de notícias. Manter essa opção geralmente não reduz o desempenho, mesmo com a memória desperdiçada, mas deve-se experimentar para descobrir.</p></div></div><div class=sect3><h4 id=_vfs_write_behind>11.10.1.2. <code>vfs.write_behind</code><a class=anchor href=#_vfs_write_behind></a></h4><div class=paragraph><p>A variável <code>vfs.write_behind</code> <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> é padronizada para <code>1</code> (ligada). Isso informa ao sistema de arquivos para emitir gravações de mídia à medida que clusters completos são coletados, o que normalmente ocorre ao gravar arquivos sequenciais grandes. Isso evita saturar o cache de buffer com buffers sujos quando não beneficia o desempenho de I/O. No entanto, isso pode atrasar os processos e, sob certas circunstâncias, deve ser desativado.</p></div></div><div class=sect3><h4 id=_vfs_hirunningspace>11.10.1.3. <code>vfs.hirunningspace</code><a class=anchor href=#_vfs_hirunningspace></a></h4><div class=paragraph><p>A variável <code>vfs.hirunningspace</code> <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> determina quanto de I/O de gravação pendente pode ser enfileirado no sistema de controladores de disco como um todo em qualquer instância. O padrão é geralmente suficiente, mas em máquinas com muitos discos, tente aumentar para quatro ou cinco <em>megabytes</em>. Definir um valor muito alto, que exceda o limite de gravação do cache de buffer, pode levar a um mau desempenho de cluster. Não defina esse valor arbitrariamente alto, pois valores de gravação mais altos podem adicionar latência a leituras que ocorrem ao mesmo tempo.</p></div><div class=paragraph><p>Há vários outros caches de buffer e valores de cache de página VM relacionados a <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a>. Modificar esses valores não é recomendado, pois o sistema VM faz um bom trabalho de ajuste automático.</p></div></div><div class=sect3><h4 id=_vm_swap_idle_enabled>11.10.1.4. <code>vm.swap_idle_enabled</code><a class=anchor href=#_vm_swap_idle_enabled></a></h4><div class=paragraph><p>A variável <code>vm.swap_idle_enabled</code> <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> é útil em grandes sistemas multiusuários com muitos usuários ativos, e muitos processos ociosos. Tais sistemas tendem a gerar pressão contínua nas reservas de memória livre. Ativar esse recurso e aprimorar a histerese de troca (em segundos ociosos) por meio de <code>vm.swap_idle_threshold1</code> e <code>vm.swap_idle_threshold2</code> reduz a prioridade das páginas de memória associadas aos processos inativos mais rapidamente do que no algoritmo de pageout normal. Isso dá uma ajuda ao daemon de pageout. Apenas ative essa opção se necessário, porque a compensação é essencialmente fazer o pre-page da memoria mais cedo, o que consome mais swap e largura de banda de disco. Em um sistema pequeno, esta opção terá um efeito determinável, mas em um sistema grande que já está paginando moderadamente, esta opção permite que o sistema VM instale processos inteiros dentro e fora da memória facilmente.</p></div></div><div class=sect3><h4 id=_hw_ata_wc>11.10.1.5. <code>hw.ata.wc</code><a class=anchor href=#_hw_ata_wc></a></h4><div class=paragraph><p>Desativar o cache de gravação IDE reduz a largura de banda de gravação em discos IDE, mas às vezes pode ser necessário devido a problemas de consistência de dados introduzidos por fornecedores de disco rígido. O problema é que algumas unidades IDE mentem sobre quando uma gravação é concluída. Com o cache de gravação IDE ativado, os discos rígidos IDE gravam os dados fora de ordem e às vezes atrasam a gravação de alguns blocos indefinidamente quando estão sob carga pesada de disco. Uma falha ou falha de energia pode causar corrupção séria do sistema de arquivos. Verifique o padrão no sistema observando a variável <code>hw.ata.wc</code> <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a>. Se o cache de gravação IDE estiver desativado, pode-se definir essa variável somente leitura como <code>1</code> em <span class=filename>/boot/loader.conf</span> para ativar no momento da inicialização.</p></div><div class=paragraph><p>Para maiores informações, consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=ata&amp;sektion=4&amp;format=html">ata(4)</a>.</p></div></div><div class=sect3><h4 id=_scsi_delay_kern_cam_scsi_delay>11.10.1.6. <code>SCSI_DELAY</code> (<code>kern.cam.scsi_delay</code>)<a class=anchor href=#_scsi_delay_kern_cam_scsi_delay></a></h4><div class=paragraph><p>A opção de configuração do kernel <code>SCSI_DELAY</code> pode ser usada para reduzir os tempos de inicialização do sistema. Os padrões são razoavelmente altos e podem ser responsáveis por <code>15</code> segundos de atraso no processo de inicialização. Reduzindo-o para <code>5</code> segundos geralmente funciona com unidades modernas. A variável de tempo de inicialização <code>kern.cam.scsi_delay</code> deve ser usada. A opção de configuração ajustável e a configuração do kernel aceitam valores em termos de <em>milissegundos</em> e <em>não__segundos</em>.</p></div></div></div><div class=sect2><h3 id=soft-updates>11.10.2. Soft Updates<a class=anchor href=#soft-updates></a></h3><div class=paragraph><p>Para ajustar um sistema de arquivos, use <a href="https://man.freebsd.org/cgi/man.cgi?query=tunefs&amp;sektion=8&amp;format=html">tunefs(8)</a>. Este programa tem muitas opções diferentes. Para ativar e desativar o Soft Updates, use:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># tunefs -n enable /filesystem</span>
<span class=c># tunefs -n disable /filesystem</span></code></pre></div></div><div class=paragraph><p>Um sistema de arquivos não pode ser modificado com <a href="https://man.freebsd.org/cgi/man.cgi?query=tunefs&amp;sektion=8&amp;format=html">tunefs(8)</a> enquanto estiver montado. Um bom momento para ativar o Soft Updates é antes que qualquer partição tenha sido montada, no modo de single-user.</p></div><div class=paragraph><p>O Soft Updates é recomendado para sistemas de arquivos UFS, pois melhora drasticamente o desempenho de metadados, principalmente a criação e exclusão de arquivos, através do uso de um cache em memória. Há duas desvantagens no Soft Updates que você deve conhecer. Primeiro, o Soft Updates garante a consistência do sistema de arquivos no caso de uma falha, mas pode facilmente levar vários segundos ou até um minuto para atualizar o disco físico. Se o sistema falhar, os dados não gravados poderão ser perdidos. Em segundo lugar, os Soft Updates atrasam a liberação de blocos do sistema de arquivos. Se o sistema de arquivos raiz estiver quase cheio, a execução de uma atualização importante, como <code>make installworld</code>, poderá causar a falta de espaço do sistema de arquivos e a atualização falhará.</p></div><div class=sect3><h4 id=_mais_detalhes_sobre_soft_updates>11.10.2.1. Mais detalhes sobre soft updates<a class=anchor href=#_mais_detalhes_sobre_soft_updates></a></h4><div class=paragraph><p>As atualizações de metadados são atualizações para dados que não são de conteúdo, como inodes ou diretórios. Existem duas abordagens tradicionais para gravar os metadados de um sistema de arquivos em disco.</p></div><div class=paragraph><p>Historicamente, o comportamento padrão era gravar atualizações de metadados de forma síncrona. Se um diretório fosse alterado, o sistema aguardava até que a alteração fosse gravada no disco. Os buffers de dados do arquivo (conteúdo do arquivo) foram passados pelo cache de buffer e foram copiados para o disco posteriormente de maneira assíncrona. A vantagem dessa implementação é que ela opera com segurança. Se houver uma falha durante uma atualização, os metadados estarão sempre em um estado consistente. Um arquivo é criado completamente ou não é de todo. Se os blocos de dados de um arquivo não encontrarem saída do cache de buffer para o disco no momento da falha, o <a href="https://man.freebsd.org/cgi/man.cgi?query=fsck&amp;sektion=8&amp;format=html">fsck(8)</a> reconhece isso e repara o sistema de arquivos definindo o comprimento do arquivo como <code>0</code>. Além disso, a implementação é clara e simples. A desvantagem é que as alterações nos metadados são lentas. Por exemplo, <code>rm -r</code> toca todos os arquivos em um diretório sequencialmente, mas cada alteração de diretório será gravada de forma síncrona no disco. Isso inclui atualizações para o próprio diretório, para a tabela de inode e possivelmente para blocos indiretos alocados pelo arquivo. Considerações semelhantes aplicam-se ao desenrolar hierarquias grandes usando <code>tar -x</code>.</p></div><div class=paragraph><p>A segunda abordagem é usar atualizações de metadados assíncronas. Este é o padrão para um sistema de arquivos UFS montado com <code>mount -o async</code>. Como todas as atualizações de metadados também são passadas pelo cache de buffer, elas serão mescladas com as atualizações dos dados de conteúdo do arquivo. A vantagem dessa implementação é que não há necessidade de esperar até que cada atualização de metadados seja gravada no disco, portanto, todas as operações que causam grandes quantidades de atualizações de metadados funcionam muito mais rápido do que no caso síncrono. Essa implementação ainda é clara e simples, portanto, há um baixo risco de erros se infiltrarem no código. A desvantagem é que não há garantia para um estado consistente do sistema de arquivos. Se houver uma falha durante uma operação que atualizou grandes quantidades de metadados, como uma falha de energia ou alguém pressionando o botão de reinicialização, o sistema de arquivos será deixado em um estado imprevisível. Não há oportunidade de examinar o estado do sistema de arquivos quando o sistema é reativado, pois os blocos de dados de um arquivo já podem ter sido gravados no disco enquanto as atualizações da tabela de inodes ou do diretório associado não foram. É impossível implementar um <a href="https://man.freebsd.org/cgi/man.cgi?query=fsck&amp;sektion=8&amp;format=html">fsck(8)</a> que é capaz de limpar o caos resultante porque as informações necessárias não estão disponíveis no disco. Se o sistema de arquivos foi danificado além do reparo, a única opção é reformatá-lo e restaurá-lo a partir do backup.</p></div><div class=paragraph><p>A solução usual para este problema é implementar <em>dirty region logging</em>, que também é chamado de <em>journaling</em>. As atualizações de metadados ainda são gravadas de forma síncrona, mas apenas em uma pequena região do disco. Mais tarde, eles são movidos para o local apropriado. Como a área de registro é uma região pequena e contígua no disco, não há longas distâncias para as cabeças de disco se moverem, mesmo durante operações pesadas, portanto, essas operações são mais rápidas do que as atualizações síncronas. Além disso, a complexidade da implementação é limitada, portanto, o risco de erros estarem presentes é baixo. Uma desvantagem é que todos os meta-dados são gravados duas vezes, uma vez na região de registro e uma vez no local apropriado, portanto, pode resultar em "piora" na performance. Por outro lado, em caso de falha, todas as operações de metadados pendentes podem ser rapidamente recuperadas ou concluídas a partir da área de registro depois que o sistema for ativado novamente, resultando em uma inicialização rápida do sistema de arquivos.</p></div><div class=paragraph><p>Kirk McKusick, o desenvolvedor do Berkeley FFS, resolveu esse problema com o Soft Updates. Todas as atualizações de meta-dados pendentes são mantidas na memória e gravadas no disco em uma sequência ordenada ("atualizações de metadados ordenadas"). Isso tem o efeito de que, no caso de operações pesadas de meta-dados, atualizações posteriores em um item "catch" as anteriores que ainda estão na memória e ainda não foram gravadas no disco. Todas as operações são geralmente executadas na memória antes da atualização ser gravada no disco e os blocos de dados são classificados de acordo com sua posição, de modo que não estarão no disco antes de seus meta-dados. Se o sistema travar, um "reenvio de log" implícito faz com que todas as operações que não foram gravadas no disco apareçam como se nunca tivessem acontecido. Um estado consistente do sistema de arquivos é mantido e parece ser o de 30 a 60 segundos antes. O algoritmo usado garante que todos os recursos em uso sejam marcados como tal em seus blocos e inodes. Após uma falha, o único erro de alocação de recursos que ocorre é que os recursos são marcados como "used", que são, na verdade, "free". O <a href="https://man.freebsd.org/cgi/man.cgi?query=fsck&amp;sektion=8&amp;format=html">fsck(8)</a> reconhece essa situação e libera os recursos que não são mais usados. É seguro ignorar o estado sujo do sistema de arquivos após uma falha forçando a montagem com <code>mount -f</code>. Para liberar recursos que podem não ser utilizados, O <a href="https://man.freebsd.org/cgi/man.cgi?query=fsck&amp;sektion=8&amp;format=html">fsck(8)</a> precisa ser executado posteriormente. Esta é a idéia por trás do <em><a href="https://man.freebsd.org/cgi/man.cgi?query=fsck&amp;sektion=8&amp;format=html">fsck(8)</a> em background</em>: no momento da inicialização do sistema, apenas um <em>snapshot</em> do sistema de arquivos é gravado e o <a href="https://man.freebsd.org/cgi/man.cgi?query=fsck&amp;sektion=8&amp;format=html">fsck(8)</a> é executado posteriormente. Todos os sistemas de arquivos podem ser montados "sujos", para que a inicialização do sistema prossiga no modo multiusuário. Em seguida, o <a href="https://man.freebsd.org/cgi/man.cgi?query=fsck&amp;sektion=8&amp;format=html">fsck(8)</a> em background é planejado para todos os sistemas de arquivos em que isso é necessário, para liberar recursos que podem não ser utilizados. Os sistemas de arquivos que não usam Soft Updates ainda precisam executar o <a href="https://man.freebsd.org/cgi/man.cgi?query=fsck&amp;sektion=8&amp;format=html">fsck(8)</a> em primeiro plano de forma usual .</p></div><div class=paragraph><p>A vantagem é que as operações de meta-dados são quase tão rápidas quanto as atualizações assíncronas e são mais rápidas que o <em>logging</em>, que precisa escrever os meta-dados duas vezes. As desvantagens são a complexidade do código, um maior consumo de memória e algumas idiosincrasias. Depois de uma falha, o estado do sistema de arquivos parece ser um pouco mais "velho". Em situações onde a abordagem síncrona padrão teria causado a existencia de alguns arquivos de comprimento zero após o <a href="https://man.freebsd.org/cgi/man.cgi?query=fsck&amp;sektion=8&amp;format=html">fsck(8)</a>, esses arquivos sequer chegam a existir com Soft Updates porque nem os metadados e nem o conteúdo do arquivo foram gravados no disco. O espaço em disco não é liberado até que as atualizações tenham sido gravadas no disco, o que pode ocorrer algum tempo depois de executar <a href="https://man.freebsd.org/cgi/man.cgi?query=rm&amp;sektion=1&amp;format=html">rm(1)</a>. Isso pode causar problemas ao instalar grandes quantidades de dados em um sistema de arquivos que não tenha espaço livre suficiente para armazenar todos os arquivos duas vezes.</p></div></div></div></div></div><div class=sect1><h2 id=configtuning-kernel-limits>11.11. Ajustando os Limites do Kernel<a class=anchor href=#configtuning-kernel-limits></a></h2><div class=sectionbody><div class=sect2><h3 id=file-process-limits>11.11.1. Limites de arquivos/processos<a class=anchor href=#file-process-limits></a></h3><div class=sect3><h4 id=kern-maxfiles>11.11.1.1. <code>kern.maxfiles</code><a class=anchor href=#kern-maxfiles></a></h4><div class=paragraph><p>A variável <code>kern.maxfiles</code> <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> pode ser aumentada ou diminuída com base nos requisitos do sistema. Essa variável indica o número máximo de descritores de arquivos no sistema. Quando a tabela do descritor de arquivos estiver cheia, o erro <code>file: table is full</code> aparecerá repetidamente no buffer de mensagem do sistema, que pode ser visualizado usando <a href="https://man.freebsd.org/cgi/man.cgi?query=dmesg&amp;sektion=8&amp;format=html">dmesg(8)</a>.</p></div><div class=paragraph><p>Cada arquivo aberto, socket ou fifo usa um descritor de arquivo. Um servidor de produção em larga escala pode facilmente exigir muitos milhares de descritores de arquivos, dependendo do tipo e número de serviços executados simultaneamente.</p></div><div class=paragraph><p>Em versões mais antigas do FreeBSD, o valor padrão de <code>kern.maxfiles</code> é derivado do <code>maxusers</code> no arquivo de configuração do kernel. O <code>kern.maxfiles</code> cresce proporcionalmente ao valor do <code>maxusers</code>. Ao compilar um kernel personalizado, considere configurar esta opção de configuração do kernel de acordo com o uso do sistema. A partir desse número, o kernel recebe a maioria dos seus limites predefinidos. Mesmo que uma máquina de produção não tenha 256 usuários simultâneos, os recursos necessários podem ser semelhantes a um servidor da Web de alta escala.</p></div><div class=paragraph><p>A variável read-only <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a><code>kern.maxusers</code> é dimensionada automaticamente na inicialização com base na quantidade de memória disponível no sistema, e pode ser determinado em tempo de execução, inspecionando o valor de <code>kern.maxusers</code>. Alguns sistemas requerem valores maiores ou menores de <code>kern.maxusers</code> e valores de <code>64</code>, <code>128</code>, e <code>256</code> não são incomuns. Ir acima de <code>256</code> não é recomendado, a menos que seja necessário um grande número de descritores de arquivos. Muitos dos valores ajustáveis definidos para seus padrões por <code>kern.maxusers</code> podem ser individualmente sobrescritos no tempo de inicialização ou em tempo de execução no <span class=filename>/boot/loader.conf</span>. Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=loader.conf&amp;sektion=5&amp;format=html">loader.conf(5)</a> e <span class=filename>/boot/defaults/loader.conf</span> para mais detalhes e algumas dicas.</p></div><div class=paragraph><p>Em versões mais antigas, o sistema ajustará automaticamente o <code>maxusers</code> se ele estiver definido como <code>0</code>. . Ao configurar esta opção, configure o <code>maxusers</code> para pelo menos <code>4</code>, especialmente se o sistema executar o Xorg ou se for usado para compilar software. A tabela mais importante definida por <code>maxusers</code> é o número máximo de processos, que é definido como <code>20 + 16 * maxusers</code>. Se <code>maxusers</code> for definido como <code>1</code>, só podem existir <code>36</code> processos simultâneos, incluindo <code>18</code> ou mais para que o sistema seja iniciado no boot ou <code>15</code> usado pelo Xorg. Até mesmo uma tarefa simples, como ler uma página de manual, iniciará nove processos para filtrar, descompactar e visualizar. Configurar o <code>maxusers</code> para <code>64</code> permite até <code>1044</code> processos simultâneos, o que deve ser suficiente para quase todos os usos. Se, no entanto, o erro for exibido ao tentar iniciar outro programa ou se um servidor estiver sendo executado com um grande número de usuários simultâneos, aumente o número e recompile.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>O <code>maxusers</code> <em>não</em> limita o número de usuários que podem logar na máquina. Em vez disso, ele configura vários tamanhos de tabela para valores razoáveis, considerando o número máximo de usuários no sistema e quantos processos cada usuário executará.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=_kern_ipc_soacceptqueue>11.11.1.2. <code>kern.ipc.soacceptqueue</code><a class=anchor href=#_kern_ipc_soacceptqueue></a></h4><div class=paragraph><p>A variável <code>kern.ipc.soacceptqueue</code> do <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> limita o tamanho da fila de escuta para aceitar novas conexões <code>TCP</code>. O valor padrão de <code>128</code> é normalmente muito baixo para o manuseio robusto de novas conexões em um servidor Web com carga pesada. Para tais ambientes, recomenda-se aumentar este valor para <code>1024</code> ou superior. Um serviço como o <a href="https://man.freebsd.org/cgi/man.cgi?query=sendmail&amp;sektion=8&amp;format=html">sendmail(8)</a>, ou Apache pode limitar por ele mesmo o tamanho da fila de escuta, mas frequentemente terá uma diretiva em seu arquivo de configuração para ajustar o tamanho da fila. Filas de escuta grandes fazem um trabalho melhor evitando ataques de negação de serviço (Denial of Service - DoS).</p></div></div></div><div class=sect2><h3 id=nmbclusters>11.11.2. Limites de rede<a class=anchor href=#nmbclusters></a></h3><div class=paragraph><p>A opção de configuração do kernel <code>NMBCLUSTERS</code> determina a quantidade de Mbufs de rede disponível para o sistema. Um servidor com muito tráfego e um baixo número de Mbufs prejudicará o desempenho. Cada cluster representa aproximadamente 2K de memória, portanto, um valor de <code>1024</code> representa <code>2</code> megabytes de memória do kernel reservada para buffers de rede. Um cálculo simples pode ser feito para descobrir quantos são necessários. Um servidor web que suporte um maximo de <code>1000</code> conexões simultâneas onde cada conexão usa um buffer de envio de 16K e recebe 6K, requer aproximadamente 32 MB de buffers de rede para cobrir o servidor web. Uma boa regra é multiplicar por <code>2</code>, então 2x32MB / 2KB = 64MB / 2kB = <code>32768</code>. Valores entre <code>4096</code> e <code>32768</code> são recomendados para máquinas com maiores quantidades de memória. Nunca especifique um valor arbitrariamente alto para este parâmetro, pois isso pode levar a uma falha no tempo de inicialização. Para observar o uso do cluster de rede, use a opção <code>-m</code> com o <a href="https://man.freebsd.org/cgi/man.cgi?query=netstat&amp;sektion=1&amp;format=html">netstat(1)</a>.</p></div><div class=paragraph><p>A variável <code>kern.ipc.nmbclusters</code> deve ser usada para configurar isso no momento da inicialização. Apenas as versões mais antigas do FreeBSD irão requerer o uso da opção <code>NMBCLUSTERS</code> no <a href="https://man.freebsd.org/cgi/man.cgi?query=config&amp;sektion=8&amp;format=html">config(8)</a> do kernel.</p></div><div class=paragraph><p>Para servidores ocupados que fazem uso extensivo da chamada de sistema <a href="https://man.freebsd.org/cgi/man.cgi?query=sendfile&amp;sektion=2&amp;format=html">sendfile(2)</a>, pode ser necessário aumentar o número de buffers <a href="https://man.freebsd.org/cgi/man.cgi?query=sendfile&amp;sektion=2&amp;format=html">sendfile(2)</a> através da opção de configuração do kernel <code>NSFBUFS</code> ou definindo seu valor no <span class=filename>/boot/loader.conf</span> (veja <a href="https://man.freebsd.org/cgi/man.cgi?query=loader&amp;sektion=8&amp;format=html">loader(8)</a> para detalhes). Um indicador comum de que esse parâmetro precisa ser ajustado é quando os processos são vistos no estado <code>sfbufa</code>. A variável <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a><code>kern.ipc.nsfbufs</code> é somente de leitura. Este parâmetro nominalmente escala com o <code>kern.maxusers</code>, no entanto, pode ser necessário ajustar de acordo.</p></div><div class="admonitionblock important"><table><tbody><tr><td class=icon><i class="fa icon-important" title=Important></i></td><td class=content><div class=paragraph><p>Mesmo que um socket tenha sido marcado como non-blocking, chamar o <a href="https://man.freebsd.org/cgi/man.cgi?query=sendfile&amp;sektion=2&amp;format=html">sendfile(2)</a> em um socket non-blocking pode resultar no bloqueio do <a href="https://man.freebsd.org/cgi/man.cgi?query=sendfile&amp;sektion=2&amp;format=html">sendfile(2)</a> até que sejam disponibilizados <code>struct sf_buf</code> suficientes.</p></div></td></tr></tbody></table></div><div class=sect3><h4 id=_net_inet_ip_portrange>11.11.2.1. <code>net.inet.ip.portrange.*</code><a class=anchor href=#_net_inet_ip_portrange></a></h4><div class=paragraph><p>As variáveis <code>net.inet.ip.portrange.*</code> do <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> controlam os intervalos de números de porta automaticamente ligados a sockets <code>TCP</code> e <code>UDP</code>. Existem três intervalos: um intervalo baixo, um intervalo padrão e um intervalo alto. A maioria dos programas de rede usam o intervalo padrão que é controlado por <code>net.inet.ip.portrange.first</code> e <code>net.inet.ip.portrange.last</code>, cujo padrão é <code>1024</code> e <code>5000</code>, respectivamente. Intervalos de porta ligados são usados para conexões de saída e é possível executar o sistema fora das portas sob certas circunstâncias. Isso ocorre mais comumente ao executar um proxy web com muita carga. O intervalo de portas não é um problema ao executar um servidor que lida principalmente com conexões de entrada, como um servidor Web, ou que tenha um número limitado de conexões de saída, como um mail relay. Para situações em que há falta de portas, é recomendado aumentar modestamente o <code>net.inet.ip.portrange.last</code>. Um valor de <code>10000</code>, <code>20000</code> ou <code>30000</code> pode ser razoável. Considere os efeitos do firewall ao alterar o intervalo de portas. Alguns firewalls podem bloquear grandes intervalos de portas, geralmente portas de numeração baixa, e esperam que os sistemas usem intervalos mais altos de portas para conexões de saída. Por esta razão, não é recomendado que o valor de <code>net.inet.ip.portrange.first</code> seja diminuído.</p></div></div><div class=sect3><h4 id=_produto_de_atraso_de_largura_de_banda_tcp>11.11.2.2. Produto de atraso de largura de banda <code>TCP</code><a class=anchor href=#_produto_de_atraso_de_largura_de_banda_tcp></a></h4><div class=paragraph><p>A limitação do produto de atraso de largura de banda <code>TCP</code> pode ser ativada configurando a variável <code>net.inet.tcp.inflight.enable</code> do <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> para <code>1</code>. Isso instrui o sistema a tentar calcular o produto de atraso de largura de banda para cada conexão e a limitar a quantidade de dados na fila para envio à rede para a quantidade necessária para manter o rendimento ideal.</p></div><div class=paragraph><p>Esse recurso é útil ao servir dados sobre modems, Gigabit Ethernet, links <code>WAN</code> de alta velocidade ou qualquer outro link com um produto de atraso de largura de banda alta, especialmente quando também estiver usando dimensionamento de janela ou quando uma janela de envio grande tiver sido configurado. Ao habilitar essa opção, defina também a variável <code>net.inet.tcp.inflight.debug</code> para <code>0</code> para desabilitar a depuração. Para uso em produção, definir a variável <code>net.inet.tcp.inflight.min</code> para pelo menos <code>6144</code> pode ser benéfico. Definir valores mínimos altos pode efetivamente desabilitar a limitação de largura de banda, dependendo do link. O recurso de limitação reduz a quantidade de dados acumulados nas rotas intermediárias e nas filas de pacotes de switchs e reduz a quantidade de dados acumulados na fila de interface do host local. Com menos pacotes enfileirados, as conexões interativas, especialmente os modems lentos, funcionarão com menores <em>Round Trip Times</em>. Esse recurso afeta apenas a transmissão de dados do lado do servidor, como o upload. Não tem efeito na recepção ou download de dados.</p></div><div class=paragraph><p>Ajustar o valor da variável <code>net.inet.tcp.inflight.stab</code> <em>não</em> é recomendado. Este parâmetro é padronizado para <code>20</code>, representando 2 pacotes máximos adicionados ao cálculo da janela de produto de atraso de largura de banda. A janela adicional é necessária para estabilizar o algoritmo e melhorar a capacidade de resposta às mudanças de condições, mas também pode resultar em um <a href="https://man.freebsd.org/cgi/man.cgi?query=ping&amp;sektion=8&amp;format=html">ping(8)</a> mais alto em links lentos , embora ainda muito menor do que sem o algoritmo inflight. Nesses casos, tente reduzir esse parâmetro para <code>15</code>, <code>10</code> ou <code>5</code> e reduza a variável <code>net.inet.tcp.inflight.min</code> para um valor como <code>3500</code> para obter o efeito desejado. A redução desses parâmetros deve ser feita apenas como último recurso.</p></div></div></div><div class=sect2><h3 id=_memória_virtual>11.11.3. Memória virtual<a class=anchor href=#_memória_virtual></a></h3><div class=sect3><h4 id=_kern_maxvnodes>11.11.3.1. <code>kern.maxvnodes</code><a class=anchor href=#_kern_maxvnodes></a></h4><div class=paragraph><p>Um vnode é a representação interna de um arquivo ou diretório. Aumentar o número de vnodes disponíveis para o sistema operacional reduz a I/O do disco. Normalmente, isso é tratado pelo sistema operacional e não precisa ser alterado. Em alguns casos em que o I/O de disco é um gargalo e o sistema está ficando sem vnodes, essa configuração precisa ser aumentada. A quantidade de RAM inativa e livre precisará ser levada em conta.</p></div><div class=paragraph><p>Para ver o número atual de vnodes em uso:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl vfs.numvnodes</span>
vfs.numvnodes: 91349</code></pre></div></div><div class=paragraph><p>Para ver o máximo de vnodes:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl kern.maxvnodes</span>
kern.maxvnodes: 100000</code></pre></div></div><div class=paragraph><p>Se o uso atual do vnode estiver próximo do máximo, tente aumentar o <code>kern.maxvnodes</code> por um valor de <code>1000</code>. Fique de olho no número de <code>vfs.numvnodes</code>. Se subir até o máximo novamente, o <code>kern.maxvnodes</code> precisará ser aumentado ainda mais. Caso contrário, uma mudança no uso da memória como reportado pelo <a href="https://man.freebsd.org/cgi/man.cgi?query=top&amp;sektion=1&amp;format=html">top(1)</a> deve estar visível e mais memória deve estar ativa.</p></div></div></div></div></div><div class=sect1><h2 id=adding-swap-space>11.12. Adicionando Espaço de Swap<a class=anchor href=#adding-swap-space></a></h2><div class=sectionbody><div class=paragraph><p>Às vezes, um sistema requer mais espaço de swap. Esta seção descreve dois métodos para aumentar o espaço de troca: adicionar swap a uma partição existente ou em um novo disco rígido e criar um arquivo de swap em uma partição existente.</p></div><div class=paragraph><p>Para obter informações sobre como criptografar o espaço de swap, quais opções existem e por que isso deve ser feito, consulte <a href=../disks/#swap-encrypting>Criptografando Swap</a>.</p></div><div class=sect2><h3 id=new-drive-swap>11.12.1. Swap em um novo disco rígido ou partição existente<a class=anchor href=#new-drive-swap></a></h3><div class=paragraph><p>Adicionar um novo disco rígido para swap resulta em um melhor desempenho do que usando uma partição em uma unidade existente. A configuração de partições e discos rígidos é explicada em <a href=../disks/#disks-adding>Adicionando Discos</a> enquanto <a href=../bsdinstall/#configtuning-initial>Criando o layout da partição</a> discute layouts de partições e considerações sobre o tamanho de partições de swap.</p></div><div class=paragraph><p>Use o <code>swapon</code> para adicionar uma partição swap ao sistema. Por exemplo:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># swapon /dev/ada1s1b</span></code></pre></div></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>É possível usar qualquer partição que não esteja atualmente montada, mesmo que já contenha dados. O uso do <code>swapon</code> em uma partição que contém dados sobrescreverá e destruirá esses dados. Certifique-se de que a partição a ser incluída como swap seja realmente a partição pretendida antes de executar o <code>swapon</code>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Para adicionar automaticamente essa partição swap na inicialização, adicione uma entrada ao <span class=filename>/etc/fstab</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>/dev/ada1s1b	none	swap	sw	0	0</pre></div></div><div class=paragraph><p>Veja <a href="https://man.freebsd.org/cgi/man.cgi?query=fstab&amp;sektion=5&amp;format=html">fstab(5)</a> para uma explicação das entradas do <span class=filename>/etc/fstab</span>. Maiores informações sobre <code>swapon</code> podem ser encontradas em <a href="https://man.freebsd.org/cgi/man.cgi?query=swapon&amp;sektion=8&amp;format=html">swapon(8)</a>.</p></div></div><div class=sect2><h3 id=create-swapfile>11.12.2. Criando um arquivo de swap<a class=anchor href=#create-swapfile></a></h3><div class=paragraph><p>Esses exemplos criam um arquivo de swap de 512M chamado <span class=filename>/usr/swap0</span> em vez de usar uma partição.</p></div><div class=paragraph><p>O uso de arquivos de swap requer que o módulo necessário pelo <a href="https://man.freebsd.org/cgi/man.cgi?query=md&amp;sektion=4&amp;format=html">md(4)</a> tenha sido embutido no kernel ou tenha sido carregado antes do swap ser ativado. Veja <a href=../kernelconfig/#kernelconfig>Configurando o kernel do FreeBSD</a> para informações sobre como compilar um kernel customizado.</p></div><div id=swapfile-10-and-later class=exampleblock><div class=title>Exemplo 2. Criando um arquivo de swap</div><div class=content><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Crie o arquivo de swap:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dd if=/dev/zero of=/usr/swap0 bs=1m count=512</span></code></pre></div></div></li><li><p>Defina as permissões adequadas no novo arquivo:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># chmod 0600 /usr/swap0</span></code></pre></div></div></li><li><p>Informe o sistema sobre o arquivo de swap adicionando uma linha ao <span class=filename>/etc/fstab</span>:</p><div class="literalblock programlisting"><div class=content><pre>md99	none	swap	sw,file=/usr/swap0,late	0	0</pre></div></div><div class=paragraph><p>O dispositivo <span class=filename>md99</span> do <a href="https://man.freebsd.org/cgi/man.cgi?query=md&amp;sektion=4&amp;format=html">md(4)</a> é usado, deixando números de dispositivos inferiores disponíveis para uso interativo.</p></div></li><li><p>O espaço de swap será adicionado na inicialização do sistema. Para adicionar espaço de swap imediatamente, use o <a href="https://man.freebsd.org/cgi/man.cgi?query=swapon&amp;sektion=8&amp;format=html">swapon(8)</a>:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># swapon -aL</span></code></pre></div></div></li></ol></div></div></div></div></div></div></div></div><div class=sect1><h2 id=acpi-overview>11.13. Gerenciamento de energia e recursos<a class=anchor href=#acpi-overview></a></h2><div class=sectionbody><div class=paragraph><p>É importante utilizar recursos de hardware de maneira eficiente. O gerenciamento de energia e recursos permite que o sistema operacional monitore os limites do sistema e, possivelmente, forneça um alerta se a temperatura do sistema aumentar inesperadamente. Uma especificação anterior para fornecer gerenciamento de energia foi o recurso Gerenciamento Avançado de Energia (Advanced Power Management - APM). O APM controla o uso de energia de um sistema com base em sua atividade. No entanto, era difícil e inflexível para os sistemas operacionais gerenciar o uso de energia e as propriedades térmicas de um sistema. O hardware era gerenciado pelo BIOS e o usuário tinha configuração e visibilidade limitadas nas configurações de gerenciamento de energia. O APMBIOS fornecido é específico da plataforma de hardware. Um driver APM no sistema operacional intermedia o acesso à interface do software APM, que permite o gerenciamento dos níveis de energia.</p></div><div class=paragraph><p>Existem quatro problemas principais no APM. Primeiro, o gerenciamento de energia é feito pelo BIOS específico do fornecedor, separado do sistema operacional. Por exemplo, o usuário pode definir valores de tempo ocioso para um disco rígido no APMBIOS para que, quando excedido, o BIOS diminua o disco rígido sem o consentimento do sistema operacional. Segundo, a lógica do APM é incorporada no BIOS e opera fora do escopo do sistema operacional. Isso significa que os usuários só podem corrigir problemas no APMBIOS, fazendo o flash de um novo ROM, que é um procedimento perigoso com potencial para deixar o sistema em um estado irrecuperável se falhar. Terceiro, o APM é uma tecnologia específica do fornecedor, o que significa que há muita duplicidade de esforços e que os erros encontrados no BIOS de um fornecedor podem não serem resolvidos em outros. Por fim, o APMBIOS não tinha espaço suficiente para implementar uma política de energia sofisticada ou que pudesse se adaptar bem ao propósito da máquina.</p></div><div class=paragraph><p>O BIOS plug and play (PNPBIOS) não era confiável em muitas situações. O PNPBIOS é uma tecnologia de 16 bits, portanto, o sistema operacional precisa usar a emulação de 16 bits para fazer interface com os métodos PNPBIOS. O FreeBSD fornece um driver APM, pois o APM ainda deve ser usado para sistemas fabricados antes do ano 2000. O driver está documentado em <a href="https://man.freebsd.org/cgi/man.cgi?query=apm&amp;sektion=4&amp;format=html">apm(4)</a>.</p></div><div class=paragraph><p>O sucessor do APM é a Interface Avançada de Configuração e Energia (Advanced Configuration and Power Interface - ACPI). O ACPI é um padrão escrito por uma aliança de fornecedores para fornecer uma interface para recursos de hardware e gerenciamento de energia. É um elemento-chave na <em>configuração direcionada do sistema operacional e gerenciamento de energia</em>, pois proporciona mais controle e flexibilidade ao sistema operacional.</p></div><div class=paragraph><p>Este capítulo demonstra como configurar o ACPI no FreeBSD. Em seguida, ele oferece algumas dicas sobre como depurar o ACPI e como enviar um relatório de problemas contendo informações de depuração para que os desenvolvedores possam diagnosticar e corrigir problemas no ACPI.</p></div><div class=sect2><h3 id=acpi-config>11.13.1. Configurando o ACPI<a class=anchor href=#acpi-config></a></h3><div class=paragraph><p>No FreeBSD, o driver <a href="https://man.freebsd.org/cgi/man.cgi?query=acpi&amp;sektion=4&amp;format=html">acpi(4)</a> é carregado por padrão na inicialização do sistema e <em>não</em> deve ser compilado no kernel. Este driver não pode ser descarregado após a inicialização porque o barramento do sistema o utiliza para várias interações de hardware. No entanto, se o sistema estiver com problemas, o ACPI pode ser desativado completamente ao reinicializar após a configurar <code>hint.acpi.0.disabled="1"</code> no <span class=filename>/boot/loader.conf</span> ou definindo esta variável no prompt do loader, como descrito em <a href=../boot/#boot-loader>Estágio três</a>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>O ACPI e o APM não podem coexistir e devem ser usados separadamente. O último a ser carregado terminará se o driver perceber que o outro já está sendo executado.</p></div></td></tr></tbody></table></div><div class=paragraph><p>O ACPI pode ser usado para colocar o sistema em modo de suspensão com o <code>acpiconf</code>, a opção <code>-s</code> e um número de <code>1</code> a <code>5</code>. A maioria dos usuários só precisa de <code>1</code> (suspensão rápida para RAM) ou <code>3</code> (suspender para RAM). A opção <code>5</code> executa um soft-off que é o mesmo que executar <code>halt -p</code>.</p></div><div class=paragraph><p>Outras opções estão disponíveis usando o <code>sysctl</code>. Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=acpi&amp;sektion=4&amp;format=html">acpi(4)</a> e <a href="https://man.freebsd.org/cgi/man.cgi?query=acpiconf&amp;sektion=8&amp;format=html">acpiconf(8)</a> para maiores informações.</p></div></div><div class=sect2><h3 id=ACPI-comprob>11.13.2. Problemas comuns<a class=anchor href=#ACPI-comprob></a></h3><div class=paragraph><p>O ACPI está presente em todos os computadores modernos que estão em conformidade com as arquiteturas ia32 (x86) e amd64 (AMD). O padrão completo tem muitos recursos, incluindo gerenciamento de desempenho da CPU, controle de planos de energia, zonas térmicas, vários sistemas de bateria, controladores incorporados e enumeração de barramento. A maioria dos sistemas implementa menos que o padrão completo. Por exemplo, um sistema de desktop geralmente só implementa a enumeração de barramento, enquanto um laptop também pode ter suporte a refrigeração e gerenciamento de bateria. Os laptops também têm suspensão e retomada, com sua própria complexidade associada.</p></div><div class=paragraph><p>Um sistema compatível com ACPI possui vários componentes. Os fornecedores de BIOS e chipset fornecem várias tabelas fixas, como FADT, na memória que especificam coisas como o mapa APIC (usado para SMP), registros de configuração e valores simples de configuração. Além disso, uma tabela de bytecode, a Tabela de Descrição de Sistema Diferenciada DSDT, especifica um espaço de nome de dispositivos e métodos em forma de árvore.</p></div><div class=paragraph><p>O driver ACPI deve analisar as tabelas fixas, implementar um interpretador para o bytecode e modificar os drivers de dispositivos e o kernel para aceitar informações do subsistema ACPI. Para o FreeBSD, a Intel™ forneceu um interpretador (ACPI-CA) que é compartilhado com o Linux™ e o NetBSD. O caminho para o código-fonte ACPI-CA é <span class=filename>src/sys/contrib/dev/acpica</span>. O código especifico que permite que o ACPI-CA funcione no FreeBSD está em <span class=filename>src/sys/dev/acpica/Osd</span>. Finalmente, drivers que implementam vários dispositivos ACPI são encontrados em <span class=filename>src/sys/dev/acpica</span>.</p></div><div class=paragraph><p>Para que o ACPI funcione corretamente, todas as partes devem funcionar corretamente. Aqui estão alguns problemas comuns, em ordem de freqüência em que ocorrem, e algumas possíveis soluções ou correções. Se uma correção não resolver o problema, consulte <a href=#ACPI-submitdebug>Obtendo e enviando informações de depuração</a> para obter instruções sobre como enviar um relatório de bug.</p></div><div class=sect3><h4 id=_problemas_do_mouse>11.13.2.1. Problemas do mouse<a class=anchor href=#_problemas_do_mouse></a></h4><div class=paragraph><p>Em alguns casos, retomar a partir de uma operação de suspensão fará com que o mouse falhe. Um work around conhecido é adicionar <code>hint.psm.0.flags="0x3000"</code> ao <span class=filename>/boot/loader.conf</span>.</p></div></div><div class=sect3><h4 id=_suspendresume>11.13.2.2. Suspend/Resume<a class=anchor href=#_suspendresume></a></h4><div class=paragraph><p>O ACPI tem três estados de suspensão para RAM (STR), <code>S1</code>-<code>S3</code>, e um de suspensão de estado para disco (STD), chamado <code>S4</code>. O STD pode ser implementado de duas maneiras separadas. O <code>S4</code> BIOS é uma suspensão para disco auxiliada pelo BIOSe o <code>S4</code>OS é implementado inteiramente pelo sistema operacional. O estado normal em que o sistema se encontra quando conectado, mas não ligado, é "soft off" (<code>S5</code>).</p></div><div class=paragraph><p>Use o <code>sysctl hw.acpi</code> para verificar os itens relacionados à suspensão. Estes resultados de exemplo são de um Thinkpad:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>hw.acpi.supported_sleep_state: S3 S4 S5
hw.acpi.s4bios: 0</code></pre></div></div><div class=paragraph><p>Use o <code>acpiconf -s</code> para testar os estados <code>S3</code>, <code>S4</code> e <code>S5</code>. Um <code>s4bios</code> de um (<code>1</code>) indica suporte ao <code>S4</code> BIOS em vez do <code>S4</code> suportado pelo sistema operacional.</p></div><div class=paragraph><p>Ao testar as ações de suspend/resume, inicie com o <code>S1</code>, se suportado. É mais provável que esse estado funcione, pois não requer muito suporte ao driver. Ninguém implementou <code>S2</code>, que é similar ao <code>S1</code>. Em seguida, tente o <code>S3</code>. Este é o estado mais profundo do STR e requer muito suporte ao driver para reinicializar corretamente o hardware.</p></div><div class=paragraph><p>Um problema comum com suspend/resume é que muitos drivers de dispositivo não salvam, restauram ou reinicializam seu firmware, registros ou memória do dispositivo adequadamente. Como primeira tentativa de depuração do problema, tente:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl debug.bootverbose=1</span>
<span class=c># sysctl debug.acpi.suspend_bounce=1</span>
<span class=c># acpiconf -s 3</span></code></pre></div></div><div class=paragraph><p>Esse teste emula o ciclo de suspend/resume de todos os drivers de dispositivo sem entrar realmente no estado <code>S3</code>. Em alguns casos, problemas como perder o estado do firmware, tempo limite do watchdog do dispositivo e tentar novamente para sempre podem ser capturados com esse método. Note que o sistema não entrará realmente no estado <code>S3</code>, o que significa que os dispositivos não perderão energia, e muitos funcionarão bem mesmo se os métodos suspend/resume estiverem totalmente ausentes, ao contrário do real estado <code>S3</code>.</p></div><div class=paragraph><p>Casos mais difíceis requerem hardware adicional, como uma porta serial e um cabo para depuração através de um console serial, uma porta Firewire e um cabo para o uso do <a href="https://man.freebsd.org/cgi/man.cgi?query=dcons&amp;sektion=4&amp;format=html">dcons(4)</a> e habilidades de depuração do kernel.</p></div><div class=paragraph><p>Para ajudar a isolar o problema, descarregue o maior número possível de drivers. Se funcionar, diminua o driver que é o problema carregando os drivers até que ele falhe novamente. Normalmente, drivers binários como <span class=filename>nvidia.ko</span>, drivers de exibição e USB terão mais problemas, enquanto as interfaces Ethernet normalmente funcionam bem. Se os drivers puderem ser carregados e descarregados adequadamente, automatize isso colocando os comandos apropriados em <span class=filename>/etc/rc.suspend</span> e <span class=filename>/etc/rc.resume</span>. Tente configurar o <code>hw.acpi.reset_video</code> para <code>1</code> se a tela estiver desarrumada após a retomada. Tente definir valores mais longos ou mais curtos para <code>hw.acpi.sleep_delay</code> para ver se isso ajuda.</p></div><div class=paragraph><p>Tente carregar uma distribuição recente do Linux™ para ver se o suspend/resume funciona no mesmo hardware. Se funciona no Linux™, é provável que seja um problema no driver do FreeBSD. Descobrir qual driver causa o problema ajudará os desenvolvedores a corrigir o problema. Como os mantenedores do ACPI raramente mantêm outros drivers, como som ou ATA, qualquer problema de driver também deve ser postado na lista <a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-current>freebsd-current</a> e enviada para o mantenedor do driver. Os usuários avançados podem incluir os <a href="https://man.freebsd.org/cgi/man.cgi?query=printf&amp;sektion=3&amp;format=html">printf(3)</a>s de debug do driver problemático para rastrear onde, em sua função de reinício, ele é interrompido.</p></div><div class=paragraph><p>Por fim, tente desativar o ACPI e ativar o APM. Se o comando suspend/resume funcionar com APM, use o APM, especialmente em hardware mais antigo (anterior a 2000). Demorou algum tempo para que os fornecedores obtivessem suporte ACPI correto e os hardwares antigos são mais prováveis de terem problemas de BIOS com ACPI.</p></div></div><div class=sect3><h4 id=_travamentos_do_sistema>11.13.2.3. Travamentos do sistema<a class=anchor href=#_travamentos_do_sistema></a></h4><div class=paragraph><p>A maioria dos travamentos do sistema é resultado de interrupções perdidas ou de uma tempestade de interrupções. Chipsets podem ter problemas com base na inicialização, como o BIOS configura as interrupções antes da correção da tabela APIC (MADT) e o roteamento do sistema de controle de interrupções (SCI).</p></div><div class=paragraph><p>Tempestades de interrupção podem ser distinguidas de interrupções perdidas, verificando a saída do <code>vmstat -i</code> e observando a linha que possui <code>acpi0</code>. Se o contador está aumentando em mais de um par por segundo, há uma tempestade de interrupção. Se o sistema parece travado, tente acessar o DDB (<span class=keyseq><kbd>CTRL</kbd>+<kbd>ALT</kbd>+<kbd>ESC</kbd></span> no console) e digite <code>show interrupts</code>.</p></div><div class=paragraph><p>Ao lidar com problemas de interrupção, tente desativar o suporte ao APIC com <code>hint.apic.0.disabled="1"</code> no <span class=filename>/boot/loader.conf</span> .</p></div></div><div class=sect3><h4 id=_panics>11.13.2.4. Panics<a class=anchor href=#_panics></a></h4><div class=paragraph><p>Os panics são relativamente raros para ACPI e são a prioridade máxima a ser corrigida. O primeiro passo é isolar as etapas para reproduzir o panic, se possível, e obter um backtrace. Siga as instruções para habilitar <code>options DDB</code> e configurar um console serial em <a href=../serialcomms/#serialconsole-ddb>Entrando no Depurador DDB da Linha Serial</a> ou configurar uma partição de despejo. Para obter um backtrace no DDB, use <code>tr</code>. Ao escrever o backtrace, obtenha pelo menos as cinco últimas e as cinco principais linhas do rastro.</p></div><div class=paragraph><p>Em seguida, tente isolar o problema inicializando com ACPI desabilitado. Se isso funcionar, isole o subsistema ACPI usando vários valores de <code>debug.acpi.disable</code>. Veja <a href="https://man.freebsd.org/cgi/man.cgi?query=acpi&amp;sektion=4&amp;format=html">acpi(4)</a> para alguns exemplos.</p></div></div><div class=sect3><h4 id=_o_sistema_é_ativado_após_a_sua_suspensão_ou_desligamento>11.13.2.5. O sistema é ativado após a sua suspensão ou desligamento<a class=anchor href=#_o_sistema_é_ativado_após_a_sua_suspensão_ou_desligamento></a></h4><div class=paragraph><p>Primeiro, tente definir <code>hw.acpi.disable_on_poweroff="0"</code> no <span class=filename>/boot/loader.conf</span>. Isso impede que a ACPI desative vários eventos durante o processo de desligamento. Alguns sistemas precisam desse valor definido como <code>1</code> (o padrão) pelo mesmo motivo. Isso geralmente corrige o problema de um sistema ser ativado espontaneamente após uma suspensão ou desligamento.</p></div></div><div class=sect3><h4 id=ACPI-aslanddump>11.13.2.6. BIOS contém Bytecode com bugs<a class=anchor href=#ACPI-aslanddump></a></h4><div class=paragraph><p>Alguns fornecedores de BIOS fornecem bytecode incorreto ou com bugs. Isso geralmente é manifestado por mensagens do console do kernel como esta:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>ACPI-1287: <span class=k>***</span> Error: Method execution failed <span class=o>[</span><span class=se>\\</span>_SB_.PCI0.LPC0.FIGD._STA] <span class=se>\\</span>
<span class=o>(</span>Node 0xc3f6d160<span class=o>)</span>, AE_NOT_FOUND</code></pre></div></div><div class=paragraph><p>Geralmente, esses problemas podem ser resolvidos com a atualização do BIOS para a revisão mais recente. A maioria das mensagens do console é inofensiva, mas se houver outros problemas, como o status da bateria não estar funcionando, essas mensagens são um bom lugar para começar a procurar por problemas.</p></div></div></div><div class=sect2><h3 id=_substituindo_o_padrão_aml>11.13.3. Substituindo o padrão AML<a class=anchor href=#_substituindo_o_padrão_aml></a></h3><div class=paragraph><p>O bytecode do BIOS, conhecido como ACPI Machine Language (AML), é compilado de uma linguagem de origem chamada ACPI Source Language (ASL). O AML é encontrado na tabela conhecida como Tabela de Descrição do Sistema Diferenciado (Differentiated System Description Table - DSDT).</p></div><div class=paragraph><p>O objetivo do FreeBSD é que todos trabalhem com ACPI sem qualquer intervenção do usuário. Soluções alternativas ainda estão sendo desenvolvidas para erros comuns feitos pelos fornecedores de BIOS. O interpretador Microsoft™ (<span class=filename>acpi.sys</span> e <span class=filename>acpiec.sys</span>) não verifica rigorosamente a conformidade com o padrão e, portanto, muitos fornecedores de BIOS que testam apenas ACPI sob Windows™ nunca corrigem seu ASL. Os desenvolvedores do FreeBSD continuam a identificar e documentar qual comportamento não padrão é permitido pelo interpretador da Microsoft™ para replicá-lo para que o FreeBSD possa funcionar sem forçar os usuários a corrigir o ASL.</p></div><div class=paragraph><p>Para ajudar a identificar o comportamento de bugs e possivelmente corrigi-lo manualmente, uma cópia pode ser feita do ASL do sistema. Para copiar o ASL do sistema para um nome de arquivo especificado, use <code>acpidump</code> com <code>-t</code>, para mostrar o conteúdo das tabelas fixas e <code>-d</code>, para desmontar o AML:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># acpidump -td &gt; my.asl</span></code></pre></div></div><div class=paragraph><p>Algumas versões de AML assumem que o usuário está executando o Windows™. Para sobrescrever isto, defina <code>hw.acpi.osname=<em>"Windows 2009"</em></code> no <span class=filename>/boot/loader.conf</span>, usando a mais recente versão do Windows™ listada no ASL.</p></div><div class=paragraph><p>Outras soluções alternativas podem exigir que o <span class=filename>my.asl</span> seja personalizado. Se este arquivo for editado, compile o novo ASL usando o seguinte comando. Os avisos geralmente podem ser ignorados, mas erros são bugs que geralmente impedem que o ACPI funcione corretamente.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># iasl -f my.asl</span></code></pre></div></div><div class=paragraph><p>Incluir <code>-f</code> força a criação do AML, mesmo que haja erros durante a compilação. Alguns erros, como a falta de declarações de retorno, são automaticamente contornados pelo interpretador do FreeBSD.</p></div><div class=paragraph><p>O nome do arquivo de saída padrão para <code>iasl</code> é <span class=filename>DSDT.aml</span>. Carregue este arquivo em vez da cópia com bugs do BIOS, que ainda está presente na memória flash, editando o <span class=filename>/boot/loader.conf</span> como segue:</p></div><div class="literalblock programlisting"><div class=content><pre>acpi_dsdt_load=&#34;YES&#34;
acpi_dsdt_name=&#34;/boot/DSDT.aml&#34;</pre></div></div><div class=paragraph><p>Certifique-se de copiar o <span class=filename>DSDT.aml</span> para <span class=filename>/boot</span> e, em seguida, reinicialize o sistema. Se isso resolver o problema, envie um <a href="https://man.freebsd.org/cgi/man.cgi?query=diff&amp;sektion=1&amp;format=html">diff(1)</a> do antigo e novo ASL para a lista <a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-acpi>freebsd-acpi</a> para que os desenvolvedores possam contornar o comportamento de bugs no <span class=filename>acpica</span>.</p></div></div><div class=sect2><h3 id=ACPI-submitdebug>11.13.4. Obtendo e enviando informações de depuração<a class=anchor href=#ACPI-submitdebug></a></h3><div class=paragraph><p>O driver ACPI possui um recurso de depuração flexível. Um conjunto de subsistemas e o nível de detalhamento podem ser especificados. Os subsistemas a serem depurados são especificados como camadas e são divididos em componentes (<code>ACPI_ALL_COMPONENTS</code>) e suporte de hardware ACPI (<code>ACPI_ALL_DRIVERS</code>). O detalhamento da saída de depuração é especificado como o nível e varia de apenas erros de relatório (<code>ACPI_LV_ERROR</code>) para tudo (<code>ACPI_LV_VERBOSE</code>). O nível é uma máscara de bits, por isso, várias opções podem ser definidas de uma só vez, separadas por espaços. Na prática, um console serial deve ser usado para registrar a saída para que ela não seja perdida quando o buffer de mensagem do console for liberado. Uma lista completa das camadas e níveis individuais é encontrada em <a href="https://man.freebsd.org/cgi/man.cgi?query=acpi&amp;sektion=4&amp;format=html">acpi(4)</a>.</p></div><div class=paragraph><p>A saída de depuração não está ativada por padrão. Para ativá-la, adicione as opções <code>ACPI_DEBUG</code> ao arquivo de configuração do kernel personalizado se ACPI estiver compilado no kernel. Adicione <code>ACPI_DEBUG=1</code> ao <span class=filename>/etc/make.conf</span> para ativá-lo globalmente. Se um módulo for usado em vez de um kernel personalizado, recompile apenas o módulo <span class=filename>acpi.ko</span> como segue:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /sys/modules/acpi/acpi &amp;&amp; make clean &amp;&amp; make ACPI_DEBUG=1</span></code></pre></div></div><div class=paragraph><p>Copie o <span class=filename>acpi.ko</span> compilado para <span class=filename>/boot/kernel</span> e adicione o nível e camada desejados ao <span class=filename>/boot/loader.conf</span>. As entradas neste exemplo permitem mensagens de depuração para todos os componentes e drivers de hardware ACPI e mensagens de erro de saída no nível menos detalhado:</p></div><div class="literalblock programlisting"><div class=content><pre>debug.acpi.layer=&#34;ACPI_ALL_COMPONENTS ACPI_ALL_DRIVERS&#34;
debug.acpi.level=&#34;ACPI_LV_ERROR&#34;</pre></div></div><div class=paragraph><p>Se as informações necessárias forem acionadas por um evento específico, como suspend e resume, não modifique o <span class=filename>/boot/loader.conf</span>. Em vez disso, use o <code>sysctl</code> para especificar o layer e o nível após inicializar e preparar o sistema para o evento específico. As variáveis que podem ser definidas usando <code>sysctl</code> são nomeadas da mesma forma que os parâmetros no <span class=filename>/boot/loader.conf</span>.</p></div><div class=paragraph><p>Depois que as informações de depuração forem coletadas, elas podem ser enviadas para a lista <a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-acpi>freebsd-acpi</a> para que possam ser usadas pelos mantenedores do FreeBSD ACPI para identificar a causa raiz do problema e desenvolver uma solução.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Antes de enviar as informações de depuração para esta lista, certifique-se de que a versão mais recente do BIOS esteja instalada e, se disponível, a versão do firmware do controlador incorporado.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Ao enviar um relatório de problemas, inclua as seguintes informações:</p></div><div class=ulist><ul><li><p>Descrição do comportamento de bugs, incluindo tipo de sistema, modelo e qualquer coisa que faça com que o erro apareça. Explique com a maior precisão possível quando o bug começou a ocorrer se for novo.</p></li><li><p>A saída do <code>dmesg</code> após executar <code>boot -v</code>, incluindo quaisquer mensagens de erro geradas pelo bug.</p></li><li><p>A saída <code>dmesg</code> do <code>boot -v</code> com o ACPI desabilitado, se a desativação do ACPI ajudar a corrigir o problema.</p></li><li><p>Saída do <code>sysctl hw.acpi</code>. Isso lista quais recursos o sistema oferece.</p></li><li><p>A URL para uma versão do ASL do sistema hospedada na web. <em>Não</em> envie o ASL diretamente para a lista, pois pode ser muito grande. Gere uma cópia do ASL executando este comando:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># acpidump -dt &gt; name-system.asl</span></code></pre></div></div><div class=paragraph><p>Substitua o nome de login para <em>name</em> e fabricante/modelo para <em>system</em>. Por exemplo, use <span class=filename>njl-FooCo6000.asl</span>.</p></div></li></ul></div><div class=paragraph><p>A maioria dos desenvolvedores do FreeBSD assina a lista de discussão <a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-current>FreeBSD-CURRENT</a>, mas deve-se enviar os problemas para a lista <a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-acpi>freebsd-acpi</a> para ter certeza de que ele será visto. Seja paciente ao esperar por uma resposta. Se o bug não for imediatamente aparente, envie um relatório de bug. Ao inserir um PR, inclua as mesmas informações solicitadas acima. Isso ajuda os desenvolvedores a rastrear o problema e resolvê-lo. Não envie um PR sem enviar primeiro um e-mail para a lista <a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-acpi>freebsd-acpi</a> pois é provável que o problema já tenha sido relatado antes.</p></div></div><div class=sect2><h3 id=ACPI-References>11.13.5. Referências<a class=anchor href=#ACPI-References></a></h3><div class=paragraph><p>Mais informações sobre ACPI podem ser encontradas nos seguintes locais:</p></div><div class=ulist><ul><li><p>Arquivos da lista de e-mail do FreeBSD ACPI (<a href=https://lists.freebsd.org/pipermail/freebsd-acpi/>https://lists.freebsd.org/pipermail/freebsd-acpi/</a>)</p></li><li><p>A <a href=https://uefi.org/specifications#ACPI>especificação ACPI</a></p></li><li><p><a href="https://man.freebsd.org/cgi/man.cgi?query=acpi&amp;sektion=4&amp;format=html">acpi(4)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=acpi_thermal&amp;sektion=4&amp;format=html">acpi_thermal(4)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=acpidump&amp;sektion=8&amp;format=html">acpidump(8)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=iasl&amp;sektion=8&amp;format=html">iasl(8)</a>, e <a href="https://man.freebsd.org/cgi/man.cgi?query=acpidb&amp;sektion=8&amp;format=html">acpidb(8)</a></p></li></ul></div></div></div></div></div><hr><div class=last-modified><p><strong>Última alteração em</strong>: 9 de março de 2024 por <a href="https://cgit.freebsd.org/doc/commit/?id=6199af92e7" target=_blank>Danilo G. Baio</a></p></div><div class=buttons><div class=prev><i class="fa fa-angle-left" aria-hidden=true title=Anterior></i><div class=container><a href=http://172.16.201.134:1313/pt-br/books/handbook/partiii class=direction>Anterior</a></div></div><div class=home><i class="fa fa-home" aria-hidden=true title=Início></i><div class=container><a href=../ class=direction>Início</a></div></div><div class=next><div class=container><a href=http://172.16.201.134:1313/pt-br/books/handbook/boot class=direction>Próximo</a></div><i class="fa fa-angle-right" aria-hidden=true title=Próximo></i></div></div><label class="hidden book-menu-overlay" for=menu-control></label></div><aside class=toc><div class=toc-content><h3>Índice</h3><nav id=TableOfContents><ul><li><a href=#config-synopsis>11.1. Sinopse</a></li><li><a href=#configtuning-starting-services>11.2. Inicialização de Serviços</a></li><li><a href=#configtuning-cron>11.3. Configurando o cron(8)</a></li><li><a href=#configtuning-rcd>11.4. Gerenciando Serviços no FreeBSD</a></li><li><a href=#config-network-setup>11.5. Configurando Placas de Interface de Rede</a></li><li><a href=#configtuning-virtual-hosts>11.6. Hosts Virtuais</a></li><li><a href=#configtuning-syslog>11.7. Configurando o log do sistema</a></li><li><a href=#configtuning-configfiles>11.8. Arquivos de Configuração</a></li><li><a href=#configtuning-sysctl>11.9. Efetuando ajustes com o sysctl(8)</a></li><li><a href=#configtuning-disk>11.10. Otimização de Discos</a></li><li><a href=#configtuning-kernel-limits>11.11. Ajustando os Limites do Kernel</a></li><li><a href=#adding-swap-space>11.12. Adicionando Espaço de Swap</a></li><li><a href=#acpi-overview>11.13. Gerenciamento de energia e recursos</a></li></ul></nav><hr><div class=resources><h3>Recursos</h3><ul class=contents><li><i class="fa fa-file-pdf-o" aria-hidden=true title="Download PDF"></i><a href=https://download.freebsd.org/doc/pt-br/books/handbook/handbook_pt-br.pdf>Download PDF</a></li><li><i class="fa fa-pencil-square-o" aria-hidden=true title="Edite essa página"></i><a href=https://github.com/freebsd/freebsd-doc/blob/main/documentation/content/pt-br/_index target=_blank>Edite essa página</a></li></ul></div></div></aside><a class=to-top href=#top><i class="fa fa-arrow-circle-up" aria-hidden=true></i></a></main><footer><div class=footer-container><section class=logo-column><img src=http://172.16.201.134:1313/images/FreeBSD-colors.svg width=160 height=50 alt="FreeBSD logo"><div class=options-container><div class=language-container><a id=languages href=http://172.16.201.134:1313/pt-br/languages><img src=http://172.16.201.134:1313/images/language.png class=language-image alt="Escolha o idioma">
<span>Brazilian Portuguese</span></a></div><div class=theme-container><select id=theme-chooser><option value=theme-system>System</option><option value=theme-light>Light</option><option value=theme-dark>Dark</option><option value=theme-high-contrast>Alto contraste</option></select></div></div></section><section class=about-column><h3 class=column-title>About</h3><ul class=column-elements-container><li><a href=https://www.freebsd.org/about/ target=_blank class=column-element>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/ target=_blank class=column-element>FreeBSD Foundation</a></li><li><a href=https://www.freebsd.org/where/ target=_blank class=column-element>Get FreeBSD</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct target=_blank class=column-element>Code of Conduct</a></li><li><a href=https://www.freebsd.org/security/ target=_blank class=column-element>Security Advisories</a></li></ul></section><section class=documentation-column><h3 class=column-title>Documentation</h3><ul class=column-elements-container><li><a href=/pt-br class=column-element>Documentation portal</a></li><li><a href=https://man.FreeBSD.org target=_blank class=column-element>Manual pages</a></li><li><a href=https://papers.FreeBSD.org target=_blank class=column-element>Presentations and papers</a></li><li><a href=https://docs-archive.freebsd.org/doc/ target=_blank class=column-element>Previous versions</a></li><li><a href=https://docs-archive.freebsd.org/44doc/ target=_blank class=column-element>4.4BSD Documents</a></li><li><a href=https://wiki.freebsd.org/ target=_blank class=column-element>Wiki</a></li></ul></section><section class=community-column><h3 class=column-title>Community</h3><ul class=column-elements-container><li><a href=http://172.16.201.134:1313/pt-br/articles/contributing class=column-element>Get involved</a></li><li><a href=https://forums.freebsd.org/ target=_blank class=column-element>Community forum</a></li><li><a href=https://lists.freebsd.org/ target=_blank class=column-element>Mailing lists</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank class=column-element>IRC Channels</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank class=column-element>Bug Tracker</a></li></ul></section><section class=legal-column><h3 class=column-title>Legal</h3><ul class=column-elements-container><li><a href=https://freebsdfoundation.org/donate/ target=_blank class=column-element>Donations</a></li><li><a href=https://www.freebsd.org/copyright/freebsd-license/ target=_blank class=column-element>Licensing</a></li><li><a href=https://www.freebsd.org/privacy/ target=_blank class=column-element>Privacy Policy</a></li><li><a href=https://www.freebsd.org/copyright/ target=_blank class=column-element>Legal notices</a></li></ul></section><section class=copyright-column><p>&copy; 1994-2024 The FreeBSD Project. All rights reserved</p><span>Made with <span class=heart>♥</span> by the FreeBSD Community</span></section></div></footer></body></html>