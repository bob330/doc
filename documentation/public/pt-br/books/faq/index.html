<!doctype html><html class=theme-light lang=pt-br><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content><meta name=keywords content><meta name=copyright content="1995-2024 The FreeBSD Foundation"><link rel=canonical href=http://172.16.201.134:1313/pt-br/books/faq/><title>Perguntas freqüentes para o FreeBSD 11.X e 12.X | FreeBSD Documentation Portal</title>
<meta name=theme-color content="#790000"><meta name=color-scheme content="system light dark high-contrast"><link rel="shortcut icon" href=http://172.16.201.134:1313/favicon.ico><link rel=stylesheet href=http://172.16.201.134:1313/styles/main.min.css><link rel=stylesheet href=http://172.16.201.134:1313/css/font-awesome-min.css><script defer src=/js/theme-chooser.min.js></script><script defer src=/js/copy-clipboard.min.js></script><script defer src=/js/search.min.js></script><meta name=twitter:card content="summary"><meta name=twitter:domain content="docs.FreeBSD.org"><meta name=twitter:site content="@freebsd"><meta name=twitter:url content="https://twitter.com/freebsd"><meta property="og:title" content="Perguntas freqüentes para o FreeBSD 11.X e 12.X"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:image" content="http://172.16.201.134:1313/favicon.ico"><meta property="og:image:alt" content="FreeBSD Logo"><meta property="og:locale" content="pt-br"><meta property="og:url" content="http://172.16.201.134:1313/pt-br/books/faq/"><meta property="og:site_name" content="FreeBSD Documentation Portal"><script type=application/ld+json>{"@context":"http://schema.org","@type":"Article","url":"http:\/\/172.16.201.134:1313\/pt-br\/books\/faq\/","name":"FreeBSD Documentation Portal","headline":"FreeBSD Documentation Portal","description":"FreeBSD Documentation Portal"}</script></head><body><header><div class=header-container><div class=logo-menu-bars-container><a href=https://www.FreeBSD.org class=logo><img src=http://172.16.201.134:1313/images/FreeBSD-monochromatic.svg width=160 height=50 alt="FreeBSD logo">
</a><label class=menu-bars for=menu-bars><i class="fa fa-bars" aria-hidden=true></i></label></div><input id=menu-bars type=checkbox><nav><ul class=menu><li class=menu-item><input id=about type=checkbox>
<a href=# aria-label="Navigate to About section"><label class=menu-item-description for=about>About
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/about/ target=_blank>About</a></li><li><a href=https://www.freebsd.org/about/ target=_blank>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/about-us/about-the-foundation/ target=_blank>FreeBSD Foundation</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct/ target=_blank>Code of Conduct</a></li></ul></li><li class=menu-item><input id=download type=checkbox>
<a href=# aria-label="Navigate to get FreeBSD section"><label class=menu-item-description for=download>Get FreeBSD
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/where/ target=_blank>Get FreeBSD</a></li><li><a href=https://www.freebsd.org/releases/ target=_blank>Release Information</a></li><li><a href=https://www.freebsd.org/releng/ target=_blank>Release Engineering</a></li><li><a href=https://www.freebsd.org/security/ target=_blank>Security Advisories</a></li></ul></li><li class=menu-item><input id=documentation type=checkbox>
<a href=# aria-label="Navigate to get Documentation section"><label class=menu-item-description for=documentation>Documentation
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=/pt-br>Documentation portal</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/handbook>FreeBSD Handbook</a></li><li><a href=http://172.16.201.134:1313/pt-br/books/porters-handbook>Porter's Handbook</a></li><li><a href=https://docs.FreeBSD.org/en/books/fdp-primer>Documentation Project Handbook</a></li><li><a href=https://man.FreeBSD.org target=_blank>Manual pages</a></li><li><a href=https://papers.FreeBSD.org target=_blank>Presentations and papers</a></li><li><a href=https://wiki.FreeBSD.org target=_blank>Wiki</a></li><li><a href=http://172.16.201.134:1313/pt-br/books>Books</a></li><li><a href=http://172.16.201.134:1313/pt-br/articles>Articles</a></li></ul></li><li class=menu-item><input id=community type=checkbox>
<a href=# aria-label="Navigate to get Community section"><label class=menu-item-description for=community>Community
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/community/>Community</a></li><li><a href=http://172.16.201.134:1313/pt-br/articles/contributing>Get involved</a></li><li><a href=https://forums.freebsd.org/ target=_blank>Forum</a></li><li><a href=https://lists.freebsd.org/ target=_blank>Mailing lists</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank>IRC Channels</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank>Bug Tracker</a></li><li><a href=https://www.freebsd.org/support/ target=_blank>Support</a></li></ul></li></ul></nav><div class=search-donate-container><form class=search method=get id=search-header-form action=https://docs.freebsd.org/search name=search-header-form><input type=hidden name=DB value=pt-br>
<input id=words name=P type=text size=20 maxlength=255>
<button>
<i class="fa fa-search" aria-hidden=true></i></button></form><div class=donate><a href=https://freebsdfoundation.org/donate/ target=_blank><span class=heart>♥</span>
Donate</a></div></div></div></header><input type=checkbox class="hidden toggle" id=menu-control><main class=main-wrapper-book><a id=top></a><div class=book><h1 class=title>Perguntas freqüentes para o FreeBSD 11.X e 12.X</h1><div class="admonitionblock note"><p><i class="fa fa-exclamation-circle" aria-hidden=true></i>
Esta tradução pode estar desatualizada. Para ajudar com as traduções, acesse a <a href=https://translate-dev.freebsd.org/ target=_blank>ferramenta de traduções do FreeBSD</a>.</p></div><div class=legalnotice><a id=trademarks></a><details><summary>trademarks</summary></details></div><div class=toc-mobile><h3>Índice</h3><nav id=TableOfContents><ul><li><a href=#_introdução>1. Introdução</a></li><li><a href=#_documentação_e_suporte>2. Documentação e Suporte</a></li><li><a href=#_instalação>3. Instalação</a></li><li><a href=#_compatibilidade_de_hardware>4. Compatibilidade de Hardware</a></li><li><a href=#_solução_de_problemas>5. Solução de problemas</a></li><li><a href=#_aplicativos_do_usuário>6. Aplicativos do Usuário</a></li><li><a href=#_configuração_do_kernel>7. Configuração do Kernel</a></li><li><a href=#_discos_sistemas_de_arquivos_e_boot_loaders>8. Discos, sistemas de arquivos e boot loaders</a></li><li><a href=#_zfs>9. ZFS</a></li><li><a href=#_administração_do_sistema>10. Administração do Sistema</a></li><li><a href=#_o_sistema_x_window_e_consoles_virtuais>11. O sistema X Window e consoles virtuais</a></li><li><a href=#_networking>12. Networking</a></li><li><a href=#_segurança>13. Segurança</a></li><li><a href=#_comunicações_seriais>14. Comunicações Seriais</a></li><li><a href=#_perguntas_diversas>15. Perguntas Diversas</a></li><li><a href=#_coisas_legais_do_freebsd>16. Coisas legais do FreeBSD</a></li><li><a href=#_tópicos_avançados>17. Tópicos Avançados</a></li><li><a href=#_agradecimentos>18. Agradecimentos</a></li></ul></nav></div><div class=book-content><div id=preamble><div class=sectionbody><div class="paragraph abstract-title"><p>Resumo</p></div><div class=paragraph><p>Estas são as Perguntas Mais Frequentes (FAQ) para as versões do FreeBSD 13.X e 12.X. Todos os esforços foram feitos para tornar este FAQ o mais informativo possível; Se você tiver alguma sugestão de como ele pode ser melhorado, envie-a para a <a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-doc>lista de discussão do projeto de documentação do FreeBSD</a>.</p></div><div class=paragraph><p>A versão mais recente deste documento está sempre disponível no <a href=https://docs.freebsd.org/pt-br/books/faq/>website do FreeBSD</a>. Ela também pode ser baixada como um grande arquivo <a href=.>HTML</a> por HTTP ou em uma grande variedade de outros formatos a partir do <a href=https://download.freebsd.org/doc/>servidor de FTP do projeto FreeBSD</a>.</p></div><hr></div></div><div class=sect1><h2 id=_introdução>1. Introdução<a class=anchor href=#_introdução></a></h2><div class=sectionbody><div class=sect2><h3 id=_o_que_é_o_freebsd>1.1. O que é o FreeBSD?<a class=anchor href=#_o_que_é_o_freebsd></a></h3><div class=paragraph><p>O FreeBSD é um sistema operacional moderno para desktops, laptops, servidores e sistemas embarcados, com suporte para um grande número de <a href=https://www.FreeBSD.org/platforms/>plataformas</a>.</p></div><div class=paragraph><p>Ele é baseado no sistema "4.4BSD-Lite" da U.C. de Berkeley, com algumas melhorias oriundas do "4.4BSD-Lite2". Ele também se baseia indiretamente no port para i386™ feito por William Jolitz do sistema "Net/2" da U.C. Berkeley, conhecido como "386BSD", embora muito pouco do código original do 386BSD ainda esteja presente.</p></div><div class=paragraph><p>O FreeBSD é usado por empresas, provedores de serviços de Internet, pesquisadores, profissionais da computação, estudantes e usuários domésticos em todo o mundo em seu trabalho, educação e recreação.</p></div><div class=paragraph><p>Para informações mais detalhadas sobre o FreeBSD, consulte o <a href=https://docs.freebsd.org/pt-br/books/handbook/book/>Manual do FreeBSD</a>.</p></div></div><div class=sect2><h3 id=FreeBSD-goals>1.2. Qual é o objetivo do projeto FreeBSD?<a class=anchor href=#FreeBSD-goals></a></h3><div class=paragraph><p>O objetivo do Projeto FreeBSD é fornecer um sistema operacional de propósito geral estável e rápido que possa ser usado para qualquer propósito sem restrições.</p></div></div><div class=sect2><h3 id=_a_licença_do_freebsd_tem_alguma_restrição>1.3. A licença do FreeBSD tem alguma restrição?<a class=anchor href=#_a_licença_do_freebsd_tem_alguma_restrição></a></h3><div class=paragraph><p>Sim. Essas restrições não controlam como o código é usado, mas como tratar o próprio projeto FreeBSD. A licença em si está disponível em <a href=https://www.FreeBSD.org/copyright/freebsd-license/>licença</a> e pode ser resumida da seguinte forma:</p></div><div class=ulist><ul><li><p>Não reivindique que você escreveu o sistema.</p></li><li><p>Não nos processe se ele quebrar.</p></li><li><p>Não remova ou modifique a licença.</p></li></ul></div><div class=paragraph><p>Muitos de nós têm um investimento significativo no projeto e certamente não nos importaríamos com uma pequena compensação financeira de vez em quando, mas nós definitivamente não insistimos nisso. Acreditamos que a nossa primeira e principal "missão" é fornecer código a todos os participantes, e para qualquer finalidade, para que o código obtenha o maior uso possível e forneça o maior benefício possível. Este, acreditamos, é um dos objetivos mais fundamentais do Software Livre e um dos que apoiamos entusiasticamente.</p></div><div class=paragraph><p>O código em nosso repositório de código-fonte que se enquadra na <a href=https://www.FreeBSD.org/copyright/COPYING>Licença Pública Geral GNU (GPL)</a> ou na <a href=https://www.FreeBSD.org/copyright/COPYING.LIB>Licença Pública Geral da Biblioteca GNU (LGPL)</a> vem com algumas restrições adicionais, ainda que sejam no sentido de forçar o acesso, em vez do habitual oposto. Devido às complexidades adicionais que podem surgir no uso comercial de um software GPL, nós nos esforçamos para substituir tais softwares por outros sob a <a href=https://www.FreeBSD.org/copyright/freebsd-license/>Licença FreeBSD</a> que é menos restritiva, sempre que possível.</p></div></div><div class=sect2><h3 id=_o_freebsd_pode_substituir_meu_sistema_operacional_atual>1.4. O FreeBSD pode substituir meu sistema operacional atual?<a class=anchor href=#_o_freebsd_pode_substituir_meu_sistema_operacional_atual></a></h3><div class=paragraph><p>Para a maioria das pessoas, sim. Mas esta questão não é assim tão simples.</p></div><div class=paragraph><p>A maioria das pessoas não usa um sistema operacional. Elas usam aplicativos. São os aplicativos que realmente usam o sistema operacional. O FreeBSD é projetado para fornecer um ambiente robusto e completo para aplicativos. Ele suporta uma grande variedade de navegadores da web, pacotes de escritório, leitores de e-mail, programas gráficos, ambientes de programação, servidores de rede e muito mais. A maioria destes aplicativos pode ser gerenciada através da <a href=https://www.FreeBSD.org/ports/>Coleção de Ports</a>.</p></div><div class=paragraph><p>Se um aplicativo estiver disponível apenas para um determinado sistema operacional, esse sistema operacional não poderá ser substituído. No entanto é provável que exista um aplicativo muito semelhante no FreeBSD. Seja como um sólido servidor corporativo, um servidor de Internet ou ainda uma confiável estação de trabalho, o FreeBSD quase certamente fará tudo o que você precisa. Muitos usuários de computador ao redor do mundo, incluindo novatos e experientes administradores UNIX™, usam o FreeBSD como seu único sistema operacional de desktop.</p></div><div class=paragraph><p>Os usuários que migrarem para o FreeBSD vindos de outro ambiente UNIX™-like irão achar o FreeBSD bastante similar. Os usuários de Windows™ e do Mac OS™ podem se interessar em usar o <a href=https://www.furybsd.org/>FuryBSD</a>, <a href=https://ghostbsd.org/>GhostBSD</a> ou <a href=https://www.midnightbsd.org/>MidnightBSD</a>, três distribuições desktop baseadas no FreeBSD. Os usuários que não estão habituados ao uso de sistemas UNIX™ devem investir algum tempo adicional aprendendo a maneira de fazer as coisas no UNIX™. Este FAQ e o <a href=https://docs.freebsd.org/pt-br/books/handbook/book/>Manual do FreeBSD</a> são excelentes lugares para iniciar.</p></div></div><div class=sect2><h3 id=_por_que_ele_é_chamado_de_freebsd>1.5. Por que ele é chamado de FreeBSD?<a class=anchor href=#_por_que_ele_é_chamado_de_freebsd></a></h3><div class=ulist><ul><li><p>Pode ser usado gratuitamente, até mesmo por usuários comerciais.</p></li><li><p>O código fonte completo do sistema operacional está disponível gratuitamente, e foram colocadas restrições mínimas sobre seu uso, distribuição e incorporação em outro trabalho (comercial ou não comercial).</p></li><li><p>Qualquer pessoa que tenha uma melhoria ou correção de bug está livre para enviar seu código e para adicioná-lo ao repositório de código-fonte (sujeito a uma ou duas provisões óbvias).</p></li></ul></div><div class=paragraph><p>Vale ressaltar que a palavra "free" está sendo usada de duas formas aqui: uma que significa "sem custo" (grátis) e a outra que significa "faça o que quiser" (Livre). Fora uma ou duas coisas que você <em>não pode</em> fazer com o código do FreeBSD, por exemplo, fingir que você o escreveu, você pode realmente fazer o que quiser com ele.</p></div></div><div class=sect2><h3 id=_quais_são_as_diferenças_entre_o_freebsd_o_netbsd_o_openbsd_e_os_outros_sistemas_operacionais_bsd_de_código_aberto>1.6. Quais são as diferenças entre o FreeBSD, o NetBSD, o OpenBSD e os outros sistemas operacionais BSD de código aberto?<a class=anchor href=#_quais_são_as_diferenças_entre_o_freebsd_o_netbsd_o_openbsd_e_os_outros_sistemas_operacionais_bsd_de_código_aberto></a></h3><div class=paragraph><p>O James Howard escreveu uma boa explicação da história e das diferenças entre os vários projetos BSD, chamada <a href=https://jameshoward.us/archive/the-bsd-family-tree/>A árvore genealógica do BSD</a>, a qual é uma boa forma de responder a esta pergunta. Algumas das informações estão desatualizadas, mas a parte da história em particular permanece precisa.</p></div><div class=paragraph><p>A maioria dos BSDs compartilha patches e códigos, até hoje. Todos os BSDs descendem dos mesmos ancestrais.</p></div><div class=paragraph><p>Os objetivos de design do FreeBSD estão descritos em <a href=#FreeBSD-goals>Qual é o objetivo do projeto FreeBSD?</a>, acima. Os objetivos de design dos outros BSDs mais populares podem ser resumidos da seguinte forma:</p></div><div class=ulist><ul><li><p>O OpenBSD visa a segurança do sistema operacional acima de tudo. A equipe do OpenBSD escreveu o <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh&amp;sektion=1&amp;format=html">ssh(1)</a> e o <a href="https://man.freebsd.org/cgi/man.cgi?query=pf&amp;sektion=4&amp;format=html">pf(4)</a>, os quais foram portados para o FreeBSD.</p></li><li><p>O NetBSD pretende ser facilmente portado para outras plataformas de hardware.</p></li><li><p>O DragonFly BSD é um fork do FreeBSD 4.8 o qual desenvolveu muitas características interessantes ao longo dos anos, incluindo o sistema de arquivos HAMMER e o suporte para "vkernels" no modo de usuário.</p></li></ul></div></div><div class=sect2><h3 id=_qual_é_a_última_versão_do_freebsd>1.7. Qual é a última versão do FreeBSD?<a class=anchor href=#_qual_é_a_última_versão_do_freebsd></a></h3><div class=paragraph><p>A qualquer momento no desenvolvimento do FreeBSD, podem existir vários branches paralelos. As releases 12.<em>X</em> são geradas a partir da branch <em>12-STABLE</em> e as releases 11.<em>X</em> são geradas a partir do branch <em>11-STABLE</em>.</p></div><div class=paragraph><p>Até o lançamento da versão 12.0, a série 11.<em>X</em> era a conhecida como <em>-STABLE</em>. No entanto, a partir da 13.<em>X</em>, a branch 11.<em>X</em> será designada para um status de "suporte estendido" e passará a receber apenas correções para problemas maiores, como as correções relacionadas à segurança.</p></div><div class=paragraph><p>As releases são liberadas a <a href=#release-freq>cada poucos meses</a>. Embora muitas pessoas se mantenham mais que isso por meio do código fonte do FreeBSD (veja as perguntas em <a href=#current>FreeBSD-CURRENT</a> e <a href=#stable>FreeBSD-STABLE</a> ), esta periodicidade está mais para um compromisso, já que o código fonte é um alvo em movimento.</p></div><div class=paragraph><p>Mais informações sobre as releases do FreeBSD podem ser encontradas na <a href=https://www.FreeBSD.org/releng/#release-build>página de Engenharia de Releases</a> e em <a href="https://man.freebsd.org/cgi/man.cgi?query=release&amp;sektion=7&amp;format=html">release(7)</a>.</p></div></div><div class=sect2><h3 id=_o_que_é_o_freebsd_current>1.8. O que é o FreeBSD-CURRENT?<a class=anchor href=#_o_que_é_o_freebsd_current></a></h3><div class=paragraph><p>O <a href=https://docs.freebsd.org/pt-br/books/handbook/book/updating-upgrading#current>FreeBSD-CURRENT</a> é a versão de desenvolvimento do sistema operacional, que no devido tempo se tornará o novo branch FreeBSD-STABLE. Como tal, ele é recomendado apenas para os desenvolvedores que trabalham no sistema e usuários amadores obstinados. Consulte a <a href=https://docs.freebsd.org/pt-br/books/handbook/book/updating-upgrading#current>seção relevante</a> no <a href=https://docs.freebsd.org/pt-br/books/handbook/book/>Handbook</a> para detalhes sobre como executar o <em>-CURRENT</em>.</p></div><div class=paragraph><p>Usuários não familiarizados com o FreeBSD não devem usar o FreeBSD-CURRENT. Este branch às vezes evolui muito rapidamente e, devido a um erro, pode ser difícil de compilá-lo às vezes. Espera-se que as pessoas que usam o FreeBSD-CURRENT possam analisar, depurar e reportar problemas.</p></div></div><div class=sect2><h3 id=_qual_é_o_conceito_do_freebsd_stable>1.9. Qual é o conceito do FreeBSD-STABLE?<a class=anchor href=#_qual_é_o_conceito_do_freebsd_stable></a></h3><div class=paragraph><p>O <em>FreeBSD-STABLE</em> é o branch de desenvolvimento a partir do qual os releases principais são feitos. Mudanças entram nesta branch em um ritmo mais lento e com a suposição geral de que eles foram testados primeiro no FreeBSD-CURRENT. No entanto, a qualquer momento, o código fonte para o FreeBSD-STABLE pode ou não ser adequado para uso geral, devido a descoberta de bugs e/ou outros casos específicos que ainda não foram encontrados no FreeBSD-CURRENT. Usuários que não possuem recursos para realizar testes devem, ao invés dessa, executar a release mais recente do FreeBSD. O <em>FreeBSD-CURRENT</em>, por outro lado, tem sido uma linha ininterrupta desde que o 2.0 foi lançado.</p></div><div class=paragraph><p>Para obter informações mais detalhadas sobre as branches, consulte "<a href=https://docs.freebsd.org/pt-br/articles/releng/#rel-branch>Engenharia de Releases do FreeBSD: Criando uma Release Branch</a>", o status dos branches e o cronograma para releases futuros podem ser encontrados na página <a href=https://www.FreeBSD.org/releng>Release Engineering Information</a>.</p></div><div class=paragraph><p>A versão <a href=https://download.FreeBSD.org/releases/amd64/amd64/12.1-RELEASE/>12.1</a> é a última release da branch <em>12-STABLE</em>; ela foi lançada em Novembro de 2019. A versão <a href=https://download.FreeBSD.org/releases/amd64/amd64/11.3-RELEASE/>11.3</a> é a release mais recente da branch <em>11-STABLE</em>; e foi lançada em Julho de 2019.</p></div></div><div class=sect2><h3 id=_quando_são_realizados_os_lançamentos_de_novas_versões_do_freebsd>1.10. Quando são realizados os lançamentos de novas versões do FreeBSD?<a class=anchor href=#_quando_são_realizados_os_lançamentos_de_novas_versões_do_freebsd></a></h3><div class=paragraph><p>A Equipe de Engenharia de Releases (Release Engineering Team) <a href=mailto:re@FreeBSD.org>re@FreeBSD.org</a> lança uma nova versão principal do FreeBSD a cada 18 meses e uma nova versão secundária a cada 8 meses, em média. As datas de lançamento são anunciadas com bastante antecedência, para que as pessoas que trabalham no sistema saibam quando seus projetos precisam ser finalizados e testados. Um período de teste precede cada lançamento, para garantir que a adição de novos recursos não comprometa a estabilidade do lançamento. Muitos usuários consideram este cuidado como uma das melhores coisas do FreeBSD, apesar de que a espera para que todas as novidades mais recentes sejam disponibilizadas no <em>-STABLE</em> possa ser um pouco frustrante.</p></div><div class=paragraph><p>Maiores informações sobre o processo de engenharia de releases (incluindo a programação das releases futuros) podem ser encontradas na página <a href=https://www.FreeBSD.org/releng/>engenharia de release</a> no site do FreeBSD.</p></div><div class=paragraph><p>Para aquelas pessoas que precisam ou querem um pouco mais de emoção, os snapshots binários são disponibilizados semanalmente, como discutido acima.</p></div></div><div class=sect2><h3 id=_quando_são_feitos_os_snapshots_do_freebsd>1.11. Quando são feitos os snapshots do FreeBSD?<a class=anchor href=#_quando_são_feitos_os_snapshots_do_freebsd></a></h3><div class=paragraph><p>As <a href=https://www.FreeBSD.org/snapshots/>snapshot</a> releases do FreeBSD são disponibilizadas com base no estado atual das branchs <em>-CURRENT</em> e <em>-STABLE</em>. Os objetivos por trás de cada release de snapshot são:</p></div><div class=ulist><ul><li><p>Testar a versão mais recente do software de instalação.</p></li><li><p>Para que as pessoas que gostariam de executar o <em>-CURRENT</em> ou o <em>-STABLE</em> mas que não têm tempo ou largura de banda para acompanhá-lo no dia-a-dia tenham uma maneira fácil de instalá-las em seus sistemas.</p></li><li><p>Para preservar um ponto de referência fixo para o código em questão, apenas no caso de quebrarmos algo de forma muito seria depois. (Embora o Subversion normalmente previna que uma coisa horrível como esta ocorra.)</p></li><li><p>Para garantir que todos os novos recursos e correções que precisam de testes tenham contato o maior número possível de testadores em potencial.</p></li></ul></div><div class=paragraph><p>Não temos a pretensão de que qualquer snapshot <em>-CURRENT</em> possa ser considerado com "qualidade de produção" para qualquer finalidade. Se você necessita de um sistema estável e totalmente testado, limite-se ao uso das releases completas.</p></div><div class=paragraph><p>As snapshots releases estão disponíveis em <a href=https://www.FreeBSD.org/snapshots/>snapshot</a>.</p></div><div class=paragraph><p>Os snapshots oficiais são gerados regularmente para todas as branchs ativamente desenvolvidas.</p></div></div><div class=sect2><h3 id=_quem_é_responsável_pelo_freebsd>1.12. Quem é responsável pelo FreeBSD?<a class=anchor href=#_quem_é_responsável_pelo_freebsd></a></h3><div class=paragraph><p>As principais decisões relativas ao projeto FreeBSD, tais como a direção geral do projeto e quem tem permissão para adicionar código ao repositório de código fonte, são feitas por meio de um <a href=https://www.FreeBSD.org/administration/#t-core>core team</a> de 9 pessoas. Existe uma equipe muito maior, com mais de 350 <a href=https://docs.freebsd.org/pt-br/articles/contributors/#staff-committers>committers</a> que estão autorizados a fazer alterações diretamente na árvore de fontes do FreeBSD.</p></div><div class=paragraph><p>No entanto, a maioria das alterações não-triviais é discutida com antecedência nas <a href=#mailing>listas de discussão</a>, e não há restrições sobre quem pode participar da discussão.</p></div></div><div class=sect2><h3 id=_onde_posso_obter_o_freebsd>1.13. Onde posso obter o FreeBSD?<a class=anchor href=#_onde_posso_obter_o_freebsd></a></h3><div class=paragraph><p>Todas releases importantes do FreeBSD estão disponíveis via FTP anônimo no <a href=https://download.FreeBSD.org/releases/>site FTP do FreeBSD</a>:</p></div><div class=ulist><ul><li><p>O último release da série <em>12-STABLE</em>, o 12.1-RELEASE, pode ser encontrado no <a href=https://download.FreeBSD.org/releases/amd64/amd64/12.1-RELEASE/>diretório 12.1-RELEASE</a>.</p></li><li><p>Mensalmente são produzidos <a href=https://www.FreeBSD.org/snapshots/>snapshot</a> releases para as branchs <a href=#current>-CURRENT</a> e <a href=#stable>-STABLE</a>, as quais destinam-se primariamente ao uso por parte dos desenvolvedores e testadores.</p></li><li><p>O último release da série <em>11-STABLE</em>, o 11.3-RELEASE, pode ser encontrado no <a href=https://download.FreeBSD.org/releases/amd64/amd64/11.3-RELEASE/>diretório 11.3-RELEASE</a>.</p></li></ul></div><div class=paragraph><p>Informações sobre como obter o FreeBSD em CD, DVD e outras mídias podem ser encontradas no <a href=https://docs.freebsd.org/pt-br/books/handbook/book/mirrors#mirrors>Handbook</a>.</p></div></div><div class=sect2><h3 id=_como_acesso_o_banco_de_dados_dos_relatórios_de_problemas>1.14. Como acesso o banco de dados dos Relatórios de Problemas?<a class=anchor href=#_como_acesso_o_banco_de_dados_dos_relatórios_de_problemas></a></h3><div class=paragraph><p>O banco de dados com os Relatórios de Problemas contendo todas as solicitações de mudança enviadas pelos nossos usuários pode ser consultado usando nossa interface web de <a href=https://bugs.FreeBSD.org/search/>consulta</a> de PRs.</p></div><div class=paragraph><p>A <a href=https://www.FreeBSD.org/support/bugreports/>interface web de envio de relatórios de problemas</a> pode ser usada para enviar relatórios de problemas através de um navegador.</p></div><div class=paragraph><p>Antes de enviar um relatório de problema, leia <a href=https://docs.freebsd.org/pt-br/articles/problem-reports/>Escrevendo Relatórios de Problemas do FreeBSD</a>, um artigo sobre como escrever bons relatórios de problemas.</p></div></div></div></div><div class=sect1><h2 id=_documentação_e_suporte>2. Documentação e Suporte<a class=anchor href=#_documentação_e_suporte></a></h2><div class=sectionbody><div class=sect2><h3 id=_quais_os_livros_existentes_sobre_o_freebsd>2.1. Quais os livros existentes sobre o FreeBSD?<a class=anchor href=#_quais_os_livros_existentes_sobre_o_freebsd></a></h3><div class=paragraph><p>O projeto produz uma ampla gama de documentação, disponível on-line a partir deste <a href=https://www.FreeBSD.org/docs/>https://www.FreeBSD.org/docs</a>.</p></div></div><div class=sect2><h3 id=_a_documentação_está_disponível_em_outros_formatos_tais_como_texto_simples_ascii_ou_pdf>2.2. A documentação está disponível em outros formatos, tais como texto simples (ASCII) ou PDF?<a class=anchor href=#_a_documentação_está_disponível_em_outros_formatos_tais_como_texto_simples_ascii_ou_pdf></a></h3><div class=paragraph><p>Sim. A documentação está disponível em vários formatos diferentes e esquemas de compressão no site FTP do FreeBSD, no diretório <a href=https://download.freebsd.org/doc/>/doc/</a>.</p></div><div class=paragraph><p>A documentação é categorizada de várias maneiras diferentes. Que incluem:</p></div><div class=ulist><ul><li><p>O nome do documento, tais como como <code>faq</code> ou <code>handbook</code>.</p></li><li><p>A linguagem e codificação do documento. Estes são baseados nos nomes de local encontrados sob o diretório <span class=filename>/usr/shared/locale</span> em um sistema FreeBSD. Os idiomas e codificações atuais são os seguintes:</p><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Nome</th><th class="tableblock halign-left valign-top">Significado</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>en_US.ISO8859-1</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Inglês (Estados Unidos)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>bn_BD.ISO10646-1</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Bengali ou Bangla (Bangladesh)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>da_DK.ISO8859-1</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Dinamarquês (Dinamarca)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>de_DE.ISO8859-1</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Alemão (Alemanha)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>el_GR.ISO8859-7</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Grego (Grécia)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>es_ES.ISO8859-1</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Espanhol (Espanha)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>fr_FR.ISO8859-1</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Francês (França)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>hu_HU.ISO8859-2</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Húngaro (Hungria)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>it_IT.ISO8859-15</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Italiano (Itália)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>ja_JP.eucJP</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Japonês (Japão, codificação EUC)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>ko_KR.UTF-8</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Coreano (Coreia, codificação UTF-8)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>mn_MN.UTF-8</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Mongol (Mongólia, codificação UTF-8)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>nl_NL.ISO8859-1</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Holandês (Holanda)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>pl_PL.ISO8859-2</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Polonês (Polônia)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>pt_BR.ISO8859-1</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Português (Brasil)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>ru_RU.KOI8-R</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Russo (Rússia, codificação KOI8-R)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>tr_TR.ISO8859-9</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Turco (Turquia)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>zh_CN.UTF-8</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Chinês Simplificado (China, codificação UTF-8)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>zh_TW.UTF-8</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Chinês Tradicional (Taiwan, codificação UTF-8)</p></td></tr></tbody></table><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Alguns documentos podem não estar disponíveis em todos os idiomas.</p></div></td></tr></tbody></table></div></li><li><p>O formato do documento. Produzimos a documentação em vários formatos de saída diferentes. Cada formato tem suas próprias vantagens e desvantagens. Alguns formatos são mais adequados para leitura on-line, enquanto outros estão formatados para serem esteticamente agradáveis quando impressos em papel. A disponibilização da documentação em diversos formatos garante que os nossos leitores possam ler as partes nas quais estão interessados, seja em seu monitor ou em papel após imprimi-los documentos. Os formatos disponíveis atualmente são:</p><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Formato</th><th class="tableblock halign-left valign-top">Significado</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>html-split</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Uma coleção de pequenos arquivos HTML vinculados.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>html</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Um grande arquivo HTML contendo o documento inteiro</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>pdf</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Formato de documento portátil da Adobe</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>txt</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Texto simples</p></td></tr></tbody></table></li><li><p>O esquema de compactação e empacotamento.</p><div class="olist loweralpha"><ol class=loweralpha type=a><li><p>Onde o formato é <code>html-split</code>, os arquivos são agrupados usando <a href="https://man.freebsd.org/cgi/man.cgi?query=tar&amp;sektion=1&amp;format=html">tar(1)</a>. O arquivo resultante <span class=filename>.tar</span> é então compactado usando os esquemas de compactação detalhados no próximo passo.</p></li><li><p>Todos os outros formatos geram um único arquivo. Por exemplo, <span class=filename>article.pdf</span>, <span class=filename>book.html</span> e assim por diante.</p><div class=paragraph><p>Esses arquivos são então compactados usando os esquemas de compactação <code>zip</code> ou <code>bz2</code>. O comando <a href="https://man.freebsd.org/cgi/man.cgi?query=tar&amp;sektion=1&amp;format=html">tar(1)</a> pode ser usado para descompactar esses arquivos.</p></div><div class=paragraph><p>Portanto, a versão PDF do Handbook, compactada usando <code>bzip2</code> será armazenada em um arquivo chamado <span class=filename>book.ps.bz2</span> no diretório <span class=filename>handbook/</span>.</p></div></li></ol></div></li></ul></div><div class=paragraph><p>Depois de escolher o formato e o mecanismo de compactação, baixe os arquivos compactados, descompacte-os e copie os documentos para um lugar apropriado.</p></div><div class=paragraph><p>Por exemplo, a versão split HTML do FAQ, compactada usando <a href="https://man.freebsd.org/cgi/man.cgi?query=bzip2&amp;sektion=1&amp;format=html">bzip2(1)</a>, pode ser encontrada em <span class=filename>doc/en_US.ISO8859-1/books/faq/book.html-split.tar.bz2</span> Para baixar e descompactar esse arquivo, digite:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># fetch https://download.freebsd.org/doc/en_US.ISO8859-1/books/faq/book.html-split.tar.bz2</span>
<span class=c># tar xvf book.html-split.tar.bz2</span></code></pre></div></div><div class=paragraph><p>Se o arquivo estiver compactado, o tar detectará automaticamente o formato apropriado e o descompactará corretamente, resultando em uma coleção de arquivos <span class=filename>.html</span>. O principal deles é chamado <span class=filename>index.html</span>, que conterá o sumário, o material introdutório e os links para as outras partes do documento.</p></div></div><div class=sect2><h3 id=_onde_encontro_informações_sobre_as_listas_de_discussão_do_freebsd_quais_grupos_de_notícias_do_freebsd_estão_disponíveis>2.3. Onde encontro informações sobre as listas de discussão do FreeBSD? Quais grupos de notícias do FreeBSD estão disponíveis?<a class=anchor href=#_onde_encontro_informações_sobre_as_listas_de_discussão_do_freebsd_quais_grupos_de_notícias_do_freebsd_estão_disponíveis></a></h3><div class=paragraph><p>Consulte as seções do Handbook sobre as <a href=https://docs.freebsd.org/pt-br/books/handbook/book/eresources#eresources-mail>listas de discussão</a> e sobre os <a href=https://docs.freebsd.org/pt-br/books/handbook/book/eresources#eresources-news>grupos de notícias</a>.</p></div></div><div class=sect2><h3 id=_existem_canais_de_irc_internet_relay_chat_sobre_o_freebsd>2.4. Existem canais de IRC (Internet Relay Chat) sobre o FreeBSD?<a class=anchor href=#_existem_canais_de_irc_internet_relay_chat_sobre_o_freebsd></a></h3><div class=paragraph><p>Sim, a maioria das redes de IRC hospedam um canal de chat do FreeBSD:</p></div><div class=ulist><ul><li><p>Canal <code>#FreeBSDhelp</code> na <a href=http://www.efnet.org/index.php>EFNet</a> é um canal dedicado a ajudar usuários do FreeBSD.</p></li><li><p>Canal <code><mark>FreeBSD</mark></code> na <a href=http://freenode.net/>Freenode</a> é um canal de ajuda geral com muitos usuários a qualquer horário. É de conhecimento que conversas off-topic acontecem em alguns momentos, mas a prioridade é dada aos usuários com perguntas sobre o FreeBSD. Outros usuários podem ajudar com o básico, consultando o Handbook sempre que possível e fornecendo links para ajudá-lo a aprender mais sobre um determinado tópico. Este é um canal em que a comunicação ocorre primariamente em inglês, embora seja frequentado por usuários de todo o mundo. As pessoas que não são falantes nativas do inglês devem tentar fazer as suas perguntas primeiro em inglês e, em seguida, tentar nos canais <code># freebsd-lang</code> conforme apropriado.</p></li><li><p>Canal <code>#FreeBSD</code> na <a href=http://www.dal.net/>DALNET</a> está disponível em <code>irc.dal.net</code> nos EUA e <code>irc.eu.dal.net</code> na Europa.</p></li><li><p>O canal <code>#FreeBSD</code> na <a href=http://www.undernet.org/>UNDERNET</a> está disponível em <code>us.undernet.org</code> nos EUA e <code>eu.undernet.org</code> na Europa. Como é um canal de ajuda, prepare-se para ler os documentos aos quais você for direcionado.</p></li><li><p>O canal <code>#FreeBSD</code> na <a href=http://www.rusnet.org.ru/>RUSNET</a> é um canal de língua russa dedicado a ajudar os usuários do FreeBSD. Este também é um bom lugar para discussões não técnicas.</p></li><li><p>O canal <code>#bsdchat</code> na <a href=http://freenode.net/>Freenode</a> é um canal de idioma chinês tradicional (codificação UTF-8) dedicado a ajudar os usuários do FreeBSD. Este também é um bom lugar para discussões não técnicas.</p></li></ul></div><div class=paragraph><p>A wiki do FreeBSD tem uma <a href=https://wiki.freebsd.org/IRC/Channels>boa lista</a> dos canais de IRC.</p></div><div class=paragraph><p>Cada um destes canais são distintos e não estão conectados entre si. Como os estilos de bate-papo diferem, experimente cada um deles para encontrar um adequado ao seu estilo de bate-papo.</p></div></div><div class=sect2><h3 id=_existem_fóruns_na_web_para_discutir_o_freebsd>2.5. Existem fóruns na web para discutir o FreeBSD?<a class=anchor href=#_existem_fóruns_na_web_para_discutir_o_freebsd></a></h3><div class=paragraph><p>Os fóruns oficiais do FreeBSD estão localizados em <a href=https://forums.FreeBSD.org/>https://forums.FreeBSD.org/</a>.</p></div></div><div class=sect2><h3 id=_onde_posso_obter_treinamento_e_suporte_comercial_para_o_freebsd>2.6. Onde posso obter treinamento e suporte comercial para o FreeBSD?<a class=anchor href=#_onde_posso_obter_treinamento_e_suporte_comercial_para_o_freebsd></a></h3><div class=paragraph><p>A <a href=http://www.ixsystems.com>iXsystems, Inc. </a>, empresa controladora do <a href=http://www.freebsdmall.com/>FreeBSD Mall</a>, fornece <a href=http://www.ixsystems.com/support>supporte</a> comercial para o FreeBSD e TrueOS, e também soluções de desenvolvimento e customização para o FreeBSD.</p></div><div class=paragraph><p>A BSD Certification Group, Inc. fornece certificações de administração do sistema para o DragonFly BSD, FreeBSD, NetBSD e OpenBSD. Consulte <a href=http://www.BSDCertification.org>seu site</a> para maiores informações.</p></div><div class=paragraph><p>Quaisquer outras organizações que forneçam treinamento e suporte devem entrar em contato com o Projeto FreeBSD para serem listadas aqui.</p></div></div></div></div><div class=sect1><h2 id=_instalação>3. Instalação<a class=anchor href=#_instalação></a></h2><div class=sectionbody><div class=sect2><h3 id=_qual_plataforma_devo_baixar_eu_tenho_uma_cpu_compatível_com_64_bits_intel_mas_eu_só_encontro_amd64>3.1. Qual plataforma devo baixar? Eu tenho uma CPU compatível com 64 bits Intel, mas eu só encontro amd64.<a class=anchor href=#_qual_plataforma_devo_baixar_eu_tenho_uma_cpu_compatível_com_64_bits_intel_mas_eu_só_encontro_amd64></a></h3><div class=paragraph><p>amd64 é o termo que o FreeBSD usa para arquiteturas x86 compatíveis com 64 bits (também conhecidas como "x86-64" ou "x64"). Para a maioria dos computadores modernos você deve usar a opção amd64. Para hardware mais antigo você deve usar o i386. Ao instalar em uma arquitetura não compatível com x86, selecione a plataforma que melhor corresponda ao hardware.</p></div></div><div class=sect2><h3 id=_qual_arquivo_eu_baixo_para_ter_o_freebsd>3.2. Qual arquivo eu baixo para ter o FreeBSD?<a class=anchor href=#_qual_arquivo_eu_baixo_para_ter_o_freebsd></a></h3><div class=paragraph><p>Na página <a href=https://www.freebsd.org/where/>Como obter o FreeBSD</a>, selecione <code>[iso]</code> ao lado da arquitetura que corresponde ao seu hardware.</p></div><div class=paragraph><p>Qualquer um dos itens a seguir pode ser usado:</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">arquivo</th><th class="tableblock halign-left valign-top">descrição</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>disc1.iso</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Contém o suficiente para instalar o FreeBSD e um conjunto mínimo de pacotes.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>dvd1.iso</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Semelhante ao <span class=filename>disc1.iso</span>, mas com pacotes adicionais.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>memstick.img</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Uma imagem inicializável para se gravar em um pendrive.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>bootonly.iso</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Uma imagem mínima e que requer acesso à rede durante a instalação para que possa instalar completamente o FreeBSD.</p></td></tr></tbody></table><div class=paragraph><p>Instruções completas sobre este procedimento e um pouco mais sobre problemas de instalação em geral podem ser encontradas na seção do Handbook <a href=https://docs.freebsd.org/pt-br/books/handbook/book/bsdinstall#bsdinstall>sobre instalação do FreeBSD</a>.</p></div></div><div class=sect2><h3 id=_o_que_eu_faço_se_a_imagem_de_instalação_não_inicializar>3.3. O que eu faço se a imagem de instalação não inicializar?<a class=anchor href=#_o_que_eu_faço_se_a_imagem_de_instalação_não_inicializar></a></h3><div class=paragraph><p>Isso pode ocorrer caso você não tenha baixado a imagem no modo <em>binário</em> ao usar o FTP.</p></div><div class=paragraph><p>Alguns clientes FTP padronizam seu modo de transferência para <em>ascii</em> e tentam alterar quaisquer caracteres de end-of-line recebidos para corresponder às convenções usadas pelo sistema do cliente. Isso quase invariavelmente corromperá a imagem de inicialização. Verifique checksum SHA-256 da imagem de inicialização baixada: se não estiver <em>exatamente</em> como no servidor, o processo de download pode ter corrompido o arquivo.</p></div><div class=paragraph><p>Ao usar um cliente FTP de linha de comando, digite <em>binary</em> no prompt de comando FTP depois de se conectar ao servidor e antes de iniciar o download da imagem.</p></div></div><div class=sect2><h3 id=_onde_estão_as_instruções_para_instalar_o_freebsd>3.4. Onde estão as instruções para instalar o FreeBSD?<a class=anchor href=#_onde_estão_as_instruções_para_instalar_o_freebsd></a></h3><div class=paragraph><p>As instruções para instalação podem ser encontradas na seção do Handbook <a href=https://docs.freebsd.org/pt-br/books/handbook/book/bsdinstall#bsdinstall>sobre instalação do FreeBSD</a>.</p></div></div><div class=sect2><h3 id=_como_posso_criar_minha_própria_versão_personalizada_ou_disco_de_instalação>3.5. Como posso criar minha própria versão personalizada ou disco de instalação?<a class=anchor href=#_como_posso_criar_minha_própria_versão_personalizada_ou_disco_de_instalação></a></h3><div class=paragraph><p>Uma mídia customizada de instalação do FreeBSD pode ser criada através da construção de uma release personalizada. Siga as instruções do artigo <a href=https://docs.freebsd.org/pt-br/articles/releng/>Release Engineering</a>.</p></div></div><div class=sect2><h3 id=_o_windows_pode_coexistir_com_o_freebsd_específico_de_x86>3.6. O Windows pode coexistir com o FreeBSD? (específico de x86)<a class=anchor href=#_o_windows_pode_coexistir_com_o_freebsd_específico_de_x86></a></h3><div class=paragraph><p>Se o Windows™ for instalado primeiro, então sim. O gerenciador de boot do FreeBSD irá então inicializar o Windows™ e o FreeBSD. Se o Windows™ for instalado posteriormente, ela sobrescreverá o gerenciador de inicialização. Se isso acontecer, veja a próxima seção.</p></div></div><div class=sect2><h3 id=_outro_sistema_operacional_destruiu_meu_gerenciador_de_inicialização_como_faço_para_recuperá_lo_específico_de_x86>3.7. Outro sistema operacional destruiu meu Gerenciador de Inicialização. Como faço para recuperá-lo? (específico de x86)<a class=anchor href=#_outro_sistema_operacional_destruiu_meu_gerenciador_de_inicialização_como_faço_para_recuperá_lo_específico_de_x86></a></h3><div class=paragraph><p>Isso depende do gerenciador de inicialização. O menu de seleção de inicialização do FreeBSD pode ser reinstalado usando <a href="https://man.freebsd.org/cgi/man.cgi?query=boot0cfg&amp;sektion=8&amp;format=html">boot0cfg(8)</a>. Por exemplo, para restaurar o menu de inicialização no disco <em>ada0</em>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># boot0cfg -B ada0</span></code></pre></div></div><div class=paragraph><p>O gerenciador de inicialização MBR não interativo pode ser instalado usando <a href="https://man.freebsd.org/cgi/man.cgi?query=gpart&amp;sektion=8&amp;format=html">gpart(8)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gpart bootcode -b /boot/mbr ada0</span></code></pre></div></div><div class=paragraph><p>Para situações mais complexas, incluindo discos GPT, consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=gpart&amp;sektion=8&amp;format=html">gpart(8)</a>.</p></div></div><div class=sect2><h3 id=_preciso_instalar_o_código_fonte>3.8. Preciso instalar o código fonte?<a class=anchor href=#_preciso_instalar_o_código_fonte></a></h3><div class=paragraph><p>Em geral, não. Não há nada no sistema base que exija a presença do código fonte para operar. Alguns ports, como o <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/lsof/>sysutils/lsof</a>, não serão compilados a menos que o código fonte esteja instalado. Em particular, se o port compila um módulo de kernel ou opera diretamente em estruturas de kernel, o código fonte deve ser instalado.</p></div></div><div class=sect2><h3 id=_eu_preciso_compilar_um_kernel>3.9. Eu preciso compilar um kernel?<a class=anchor href=#_eu_preciso_compilar_um_kernel></a></h3><div class=paragraph><p>Geralmente não. O kernel <code>GENERIC</code> fornecido contém todos os drivers que um computador comum precisará. O <a href="https://man.freebsd.org/cgi/man.cgi?query=freebsd-update&amp;sektion=8&amp;format=html">freebsd-update(8)</a>, a ferramenta de atualização binária do FreeBSD, não pode atualizar kernels customizados, o que é uma outra razão para se manter com o kernel <code>GENERIC</code> sempre que possível. Para computadores com uma quantidade de memória RAM muito limitada, como sistemas embarcados, pode valer a pena compilar um kernel customizado menor contendo apenas os drivers necessários.</p></div></div><div class=sect2><h3 id=_devo_usar_senhas_des_blowfish_ou_md5_e_como_eu_específico_qual_tipo_meus_usuários_irão_receber>3.10. Devo usar senhas DES, Blowfish ou MD5 e como eu específico qual tipo meus usuários irão receber?<a class=anchor href=#_devo_usar_senhas_des_blowfish_ou_md5_e_como_eu_específico_qual_tipo_meus_usuários_irão_receber></a></h3><div class=paragraph><p>O FreeBSD usa <em>SHA512</em> por padrão. Senhas DES ainda estão disponíveis para compatibilidade com sistemas operacionais que ainda usam um formato de senha menos seguro. O FreeBSD também suporta os formatos de senha Blowfish e MD5. O formato de senha que será usado para novas senhas é controlado pelo recurso de login <code>passwd_format</code> no arquivo <span class=filename>/etc/login.conf</span>, que recebe valores de <code>des</code>, <code>blf</code> (se estiverem disponíveis) ou <code>md5</code>. Veja a página de manual <a href="https://man.freebsd.org/cgi/man.cgi?query=login.conf&amp;sektion=5&amp;format=html">login.conf(5)</a> para maiores informações sobre as capacidades de login.</p></div></div><div class=sect2><h3 id=_quais_são_os_limites_para_sistemas_de_arquivos_ffs>3.11. Quais são os limites para sistemas de arquivos FFS?<a class=anchor href=#_quais_são_os_limites_para_sistemas_de_arquivos_ffs></a></h3><div class=paragraph><p>Para os sistemas de arquivos FFS, o tamanho máximo é praticamente limitado pela quantidade de memória necessária para executar o <a href="https://man.freebsd.org/cgi/man.cgi?query=fsck&amp;sektion=8&amp;format=html">fsck(8)</a> no sistema de arquivo. O <a href="https://man.freebsd.org/cgi/man.cgi?query=fsck&amp;sektion=8&amp;format=html">fsck(8)</a> requer um bit por fragmento, que com o tamanho de fragmento padrão de 4 KB equivale a 32 MB de memória por TB de disco. Isso significa que nas arquiteturas que limitam os processos userland a 2 GB (por exemplo, i386™), o tamanho máximo do sistema de arquivos que o <a href="https://man.freebsd.org/cgi/man.cgi?query=fsck&amp;sektion=8&amp;format=html">fsck(8)</a> permite operar é de ~ 60 TB.</p></div><div class=paragraph><p>Se não houvesse um limite de memória para o <a href="https://man.freebsd.org/cgi/man.cgi?query=fsck&amp;sektion=8&amp;format=html">fsck(8)</a>, o tamanho máximo do sistema de arquivos seria 2 ^ 64 (blocks) * 32 KB ⇒ 16 Exa * 32 KB ⇒ 512 ZettaBytes.</p></div><div class=paragraph><p>O tamanho máximo de um único arquivo FFS é de aproximadamente 2 PB com o tamanho de bloco padrão de 32 KB. Cada bloco de 32 KB pode apontar para 4096 blocos. Com blocos triplo indiretos, o cálculo é 32 KB * 12 + 32 KB * 4096 + 32 KB * 4096 ^ 2 + 32 KB * 4096 ^ 3. Aumentar o tamanho do bloco para 64 KB aumentará o tamanho máximo do arquivo por um fator de 16.</p></div></div><div class=sect2><h3 id=_por_que_recebo_uma_mensagem_de_erro_readin_failed_depois_de_compilar_e_inicializar_um_novo_kernel>3.12. Por que recebo uma mensagem de erro, readin failed depois de compilar e inicializar um novo kernel?<a class=anchor href=#_por_que_recebo_uma_mensagem_de_erro_readin_failed_depois_de_compilar_e_inicializar_um_novo_kernel></a></h3><div class=paragraph><p>O world (aplicativos e bicliotecas do userland)e o kernel estão fora de sincronia. Isso não é suportado. Certifique-se de usar <code>make buildworld</code> e <code>make build-kernel</code> para atualizar o kernel.</p></div><div class=paragraph><p>Inicialize o sistema especificando o kernel diretamente no segundo estágio, pressionando qualquer tecla quando o <code>|</code> aparecer antes que o utilitário de carga (loader) seja iniciado.</p></div></div><div class=sect2><h3 id=_existe_uma_ferramenta_para_realizar_tarefas_de_configuração_pós_instalação>3.13. Existe uma ferramenta para realizar tarefas de configuração pós-instalação?<a class=anchor href=#_existe_uma_ferramenta_para_realizar_tarefas_de_configuração_pós_instalação></a></h3><div class=paragraph><p>Sim. O bsdconfig fornece uma boa interface para configurar o FreeBSD na pós-instalação.</p></div></div></div></div><div class=sect1><h2 id=_compatibilidade_de_hardware>4. Compatibilidade de Hardware<a class=anchor href=#_compatibilidade_de_hardware></a></h2><div class=sectionbody><div class=sect2><h3 id=compatibility-general>4.1. Geral<a class=anchor href=#compatibility-general></a></h3><div class=sect3><h4 id=_eu_quero_obter_um_componente_de_hardware_para_o_meu_sistema_freebsd_qual_modelomarcatipo_é_o_melhor>4.1.1. Eu quero obter um componente de hardware para o meu sistema FreeBSD. Qual modelo/marca/tipo é o melhor?<a class=anchor href=#_eu_quero_obter_um_componente_de_hardware_para_o_meu_sistema_freebsd_qual_modelomarcatipo_é_o_melhor></a></h4><div class=paragraph><p>Isso é discutido continuamente nas listas de discussão do FreeBSD, mas isto é de se esperar, já que o hardware muda tão rapidamente. Leia as Notas de Hardware do FreeBSD <a href=https://www.FreeBSD.org/releases/12.1r/hardware/>12.1</a> ou <a href=https://www.FreeBSD.org/releases/11.3r/hardware/>11.3</a> e pesquise os <a href=https://www.FreeBSD.org/search/#mailinglists>arquivos</a> da lista de discussão antes de perguntar sobre o hardware mais recente e melhor. As chances são de que uma discussão sobre esse tipo de hardware tenha acontecido na semana passada.</p></div><div class=paragraph><p>Antes de comprar um laptop, verifique os arquivos da <a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-questions>lista de discussão de questões gerais do FreeBSD</a>, ou possivelmente uma lista de discussão específica para um tipo específico de hardware.</p></div></div><div class=sect3><h4 id=_quais_são_os_limites_para_a_memória>4.1.2. Quais são os limites para a memória?<a class=anchor href=#_quais_são_os_limites_para_a_memória></a></h4><div class=paragraph><p>O FreeBSD como sistema operacional geralmente suporta tanta memória física (RAM) quanto a disponível na plataforma em que está rodando. Tenha em mente que plataformas diferentes têm limites diferentes para a memória; por exemplo i386™ sem PAE suporta no máximo 4 GB de memória (e geralmente menos que isso por causa do espaço de endereçamento PCI) e i386™ com PAE suporta no máximo 64 GB de memória. A partir do FreeBSD 10, as plataformas AMD64 suportam até 4 TB de memória física.</p></div></div><div class=sect3><h4 id=_por_que_o_freebsd_reporta_menos_de_4_gb_de_memória_quando_instalado_em_uma_máquina_i386>4.1.3. Por que o FreeBSD reporta menos de 4 GB de memória quando instalado em uma máquina i386?<a class=anchor href=#_por_que_o_freebsd_reporta_menos_de_4_gb_de_memória_quando_instalado_em_uma_máquina_i386></a></h4><div class=paragraph><p>O espaço total de endereços nas máquinas i386™ é de 32 bits, o que significa que no máximo 4 GB de memória são endereçáveis (podem ser acessados). Além disso, alguns endereços nesse intervalo são reservados por hardware para diferentes finalidades, por exemplo, para usar e controlar dispositivos PCI, para acessar a memória de vídeo e assim por diante. Portanto, a quantidade total de memória utilizável pelo sistema operacional para o seu kernel e aplicativos é limitada a significativamente menos de 4 GB. Normalmente, temos de 3,2 GB a 3,7 GB de memória física máxima utilizável nessa configuração.</p></div><div class=paragraph><p>Para acessar mais de 3,2 GB a 3,7 GB de memória instalada (ou seja, até 4 GB, mas também mais de 4 GB), um ajuste especial chamado PAE deve ser usado. PAE significa Physical Address Extension e é uma maneira das CPUs x86 de 32 bits endereçarem mais de 4 GB de memória. Ele remapeia a memória que de outra forma seria sobreposta pelas reservas de endereço para dispositivos de hardware acima do intervalo de 4 GB e a usa como memória física adicional (veja <a href="https://man.freebsd.org/cgi/man.cgi?query=pae&amp;sektion=4&amp;format=html">pae(4)</a>). Usar o PAE tem alguns inconvenientes; este modo de acesso à memória é um pouco mais lento que o modo normal (sem PAE) e módulos carregáveis (veja <a href="https://man.freebsd.org/cgi/man.cgi?query=kld&amp;sektion=4&amp;format=html">kld(4)</a>) não são suportados. Isso significa que todos os drivers devem ser compilados estaticamente no kernel.</p></div><div class=paragraph><p>A maneira mais comum de ativar o PAE é compilar um novo kernel com o arquivo especial de configuração do kernel, chamado <span class=filename>PAE</span>, que já está configurado para compilar um kernel seguro. Observe que algumas entradas neste arquivo de configuração do kernel são muito conservadoras e alguns drivers marcados como não prontos para serem usados com o PAE na verdade são possíveis de serem utilizados. Uma regra básica é que, se o driver for utilizável em arquiteturas de 64 bits (como o AMD64), ele também poderá ser usado com o PAE. Ao criar um arquivo de configuração de kernel personalizado, o suporte ao PAE pode ser ativada adicionando a seguinte linha:</p></div><div class="literalblock programlisting"><div class=content><pre>options       PAE</pre></div></div><div class=paragraph><p>O PAE não é muito usado atualmente porque a maioria dos novos hardwares x86 também suporta a execução no modo de 64 bits, conhecido como AMD64 ou Intel™64. Ele tem um espaço de endereçamento muito maior e não precisa tais ajustes. O FreeBSD suporta o AMD64 e é recomendado que esta versão do FreeBSD seja usada no lugar da versão i386™ se forem necessários 4 GB ou mais de memória.</p></div></div></div><div class=sect2><h3 id=compatibility-processors>4.2. Arquiteturas e Processadores<a class=anchor href=#compatibility-processors></a></h3><div class=sect3><h4 id=_o_freebsd_suporta_arquiteturas_diferentes_do_x86>4.2.1. O FreeBSD suporta arquiteturas diferentes do x86?<a class=anchor href=#_o_freebsd_suporta_arquiteturas_diferentes_do_x86></a></h4><div class=paragraph><p>Sim. O FreeBSD divide o suporte em vários níveis. Arquiteturas de Tier 1, como i386 ou amd64; são totalmente suportados. Tiers 2 e 3 são suportados com base no melhor esforço. Uma explicação completa do sistema de tiers está disponível no <a href=https://docs.freebsd.org/pt-br/articles/committers-guide/#archs>Guia dos Committers.</a></p></div><div class=paragraph><p>Uma lista completa de arquiteturas suportadas pode ser encontrada na <a href=https://www.FreeBSD.org/platforms/>páginas de plataformas.</a></p></div></div><div class=sect3><h4 id=_o_freebsd_suporta_o_multiprocessamento_simétrico_smp>4.2.2. O FreeBSD suporta o Multiprocessamento Simétrico (SMP)?<a class=anchor href=#_o_freebsd_suporta_o_multiprocessamento_simétrico_smp></a></h4><div class=paragraph><p>O FreeBSD suporta multiprocessadores simétricos (SMP) em todas as plataformas não-embarcadas (por exemplo, i386, amd64, etc.). O SMP também é suportado em kernels arm e MIPS, embora algumas CPUs possam não suportar isso. A implementação do SMP do FreeBSD usa o bloqueio refinado, e o desempenho escala quase linearmente com o número de CPUs.</p></div><div class=paragraph><p>A página de manual do <a href="https://man.freebsd.org/cgi/man.cgi?query=smp&amp;sektion=4&amp;format=html">smp(4)</a> tem maiores detalhes.</p></div></div><div class=sect3><h4 id=_o_que_é_microcódigo_como_eu_instalo_as_atualizações_de_microcódigo_da_intel>4.2.3. O que é microcódigo? Como eu instalo as atualizações de microcódigo da Intel?<a class=anchor href=#_o_que_é_microcódigo_como_eu_instalo_as_atualizações_de_microcódigo_da_intel></a></h4><div class=paragraph><p>Microcódigo é um método de implementar programaticamente instruções de nível de hardware. Isso permite que os bugs da CPU sejam corrigidos sem a necessidade de substituir fisicamente o chip.</p></div><div class=paragraph><p>Instale o <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/devcpu-data/>sysutils/devcpu-data</a> e adicione:</p></div><div class="literalblock programlisting"><div class=content><pre>microcode_update_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>no <span class=filename>/etc/rc.conf</span></p></div></div></div><div class=sect2><h3 id=compatibility-peripherals>4.3. Periféricos<a class=anchor href=#compatibility-peripherals></a></h3><div class=sect3><h4 id=_que_tipo_de_periféricos_o_freebsd_suporta>4.3.1. Que tipo de periféricos o FreeBSD suporta?<a class=anchor href=#_que_tipo_de_periféricos_o_freebsd_suporta></a></h4><div class=paragraph><p>Veja a lista completa nas Notas de Hardware para o FreeBSD <a href=https://www.FreeBSD.org/releases/12.1r/hardware>12.1</a> ou <a href=https://www.FreeBSD.org/releases/11.3r/hardware>11.3</a>.</p></div></div></div><div class=sect2><h3 id=compatibility-kbd-mice>4.4. Teclados e Mouses<a class=anchor href=#compatibility-kbd-mice></a></h3><div class=sect3><h4 id=moused>4.4.1. É possível usar um mouse fora do sistema X Window?<a class=anchor href=#moused></a></h4><div class=paragraph><p>O driver de console padrão, <a href="https://man.freebsd.org/cgi/man.cgi?query=vt&amp;sektion=4&amp;format=html">vt(4)</a>, fornece a capacidade de usar um ponteiro de mouse em consoles de texto para cortar & colar o texto. Execute o daemon do mouse, <a href="https://man.freebsd.org/cgi/man.cgi?query=moused&amp;sektion=8&amp;format=html">moused(8)</a> e ative o ponteiro do mouse no console virtual:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># moused -p /dev/xxxx -t yyyy</span>
<span class=c># vidcontrol -m on</span></code></pre></div></div><div class=paragraph><p>No qual <em>xxxx</em> é o nome do dispositivo de mouse e <em>yyyy</em> é o tipo de protocolo para o mouse. O daemon do mouse pode determinar automaticamente o tipo de protocolo da maioria dos mouses, exceto antigos mouses seriais. Especifique o protocolo <code>auto</code> para invocar a detecção automática. Se a detecção automática não funcionar, consulte a página de manual <a href="https://man.freebsd.org/cgi/man.cgi?query=moused&amp;sektion=8&amp;format=html">moused(8)</a> para obter uma lista dos tipos de protocolos suportados.</p></div><div class=paragraph><p>Para um mouse PS/2, adicione <code>moused_enable="YES"</code> ao arquivo <span class=filename>/etc/rc.conf</span> para iniciar o daemon do mouse no momento da inicialização. Além disso, para usar o daemon do mouse em todos os terminais virtuais em vez de apenas no console, adicione <code>allscreens_flags="-m on"</code> ao arquivo <span class=filename>/etc/rc.conf</span>.</p></div><div class=paragraph><p>Quando o daemon do mouse está em execução, o acesso ao mouse deve ser coordenado entre o daemon do mouse e outros programas, tais como o X Windows. Consulte o FAQ<a href=#x-and-moused>Por que meu mouse não funciona com o X?</a> para obter mais detalhes sobre esse problema.</p></div></div><div class=sect3><h4 id=_como_faço_para_cortar_e_colar_texto_com_um_mouse_no_console_de_texto>4.4.2. Como faço para cortar e colar texto com um mouse no console de texto?<a class=anchor href=#_como_faço_para_cortar_e_colar_texto_com_um_mouse_no_console_de_texto></a></h4><div class=paragraph><p>Não é possível remover (cortar) dados usando o mouse. No entanto, é possível copiar e colar. Quando o daemon do mouse estiver em execução, conforme descrito na <a href=#moused>pergunta anterior</a>, mantenha pressionado o botão 1 (botão esquerdo) e mova o mouse para selecionar uma região do texto. Em seguida, pressione o botão 2 (botão do meio) para colar no cursor de texto. Pressionar o botão 3 (botão direito) irá " estender " a região selecionada do texto.</p></div><div class=paragraph><p>Se o mouse não tiver um botão do meio, é possível emular um ou remapear os botões usando as opções do daemon do mouse. Consulte a página de manual <a href="https://man.freebsd.org/cgi/man.cgi?query=moused&amp;sektion=8&amp;format=html">moused(8)</a> para obter detalhes.</p></div></div><div class=sect3><h4 id=_meu_mouse_tem_uma_roda_e_botões_extravagantes_posso_usá_los_no_freebsd>4.4.3. Meu mouse tem uma roda e botões extravagantes. Posso usá-los no FreeBSD?<a class=anchor href=#_meu_mouse_tem_uma_roda_e_botões_extravagantes_posso_usá_los_no_freebsd></a></h4><div class=paragraph><p>A resposta é, infelizmente, "Depende". Esses mouses com recursos adicionais exigem um driver especializado na maioria dos casos. A menos que o driver do dispositivo do mouse ou o programa do usuário tenha suporte específico para o mouse, ele funcionará exatamente como um mouse padrão de dois ou três botões.</p></div><div class=paragraph><p>Para o possível uso de rodas do mouse no ambiente X Window, consulte <a href=#x-and-wheel>essa seção</a>.</p></div></div><div class=sect3><h4 id=_como_eu_uso_a_minha_tecla_de_delete_no_sh_e_csh>4.4.4. Como eu uso a minha tecla de delete no sh e csh?<a class=anchor href=#_como_eu_uso_a_minha_tecla_de_delete_no_sh_e_csh></a></h4><div class=paragraph><p>Para o Bourne Shell, inclua as seguintes linhas no arquivo <span class=filename>~/.shrc</span>. Veja <a href="https://man.freebsd.org/cgi/man.cgi?query=sh&amp;sektion=1&amp;format=html">sh(1)</a> e <a href="https://man.freebsd.org/cgi/man.cgi?query=editrc&amp;sektion=5&amp;format=html">editrc(5)</a>.</p></div><div class="literalblock programlisting"><div class=content><pre>bind ^[[3~ ed-delete-next-char # para o xterm</pre></div></div><div class=paragraph><p>Para o C Shell, adicione as seguintes linhas ao <span class=filename>~/.cshrc</span>. Veja <a href="https://man.freebsd.org/cgi/man.cgi?query=csh&amp;sektion=1&amp;format=html">csh(1)</a>.</p></div><div class="literalblock programlisting"><div class=content><pre>bindkey ^[[3~ delete-char # para o xterm</pre></div></div></div></div><div class=sect2><h3 id=compatibility-other>4.5. Outro hardware<a class=anchor href=#compatibility-other></a></h3><div class=sect3><h4 id=_algum_workaround_para_o_problema_de_não_sair_nenhum_som_da_minha_placa_de_som_pcm4>4.5.1. Algum workaround para o problema de não sair nenhum som da minha placa de som pcm4?<a class=anchor href=#_algum_workaround_para_o_problema_de_não_sair_nenhum_som_da_minha_placa_de_som_pcm4></a></h4><div class=paragraph><p>Algumas placas de som definem seu volume de saída como 0 em cada inicialização. Execute o seguinte comando toda vez que a máquina inicializar:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mixer pcm 100 vol 100 cd 100</span></code></pre></div></div></div><div class=sect3><h4 id=_o_freebsd_suporta_o_gerenciamento_de_energia_no_meu_laptop>4.5.2. O FreeBSD suporta o gerenciamento de energia no meu laptop?<a class=anchor href=#_o_freebsd_suporta_o_gerenciamento_de_energia_no_meu_laptop></a></h4><div class=paragraph><p>O FreeBSD suporta os recursos ACPI encontrados em componentes modernos de hardware. Maiores informações podem ser encontradas em <a href="https://man.freebsd.org/cgi/man.cgi?query=acpi&amp;sektion=4&amp;format=html">acpi(4)</a>.</p></div></div></div></div></div><div class=sect1><h2 id=_solução_de_problemas>5. Solução de problemas<a class=anchor href=#_solução_de_problemas></a></h2><div class=sectionbody><div class=sect2><h3 id=_por_que_o_freebsd_está_encontrando_a_quantidade_errada_de_memória_no_hardware_i386>5.1. Por que o FreeBSD está encontrando a quantidade errada de memória no hardware i386?<a class=anchor href=#_por_que_o_freebsd_está_encontrando_a_quantidade_errada_de_memória_no_hardware_i386></a></h3><div class=paragraph><p>O motivo mais provável é a diferença entre endereços de memória física e endereços virtuais.</p></div><div class=paragraph><p>A convenção para a maioria dos hardwares de PC é usar a área de memória entre 3,5 GB e 4 GB para uma finalidade especial (geralmente para PCI). Este espaço de endereço é usado para acessar o hardware PCI. Como resultado real, a memória física não pode ser acessada por esse espaço de endereço.</p></div><div class=paragraph><p>O que acontece com a memória que deveria aparecer nesse local depende do hardware. Infelizmente, alguns hardwares não fazem nada e a capacidade de usar estes últimos 500 MB de RAM é totalmente perdida.</p></div><div class=paragraph><p>Felizmente, a maioria dos hardwares faz o remapeamento da memória para um local mais alto, para que ela ainda possa ser usada. No entanto, isso pode causar alguma confusão ao observar as mensagens de inicialização.</p></div><div class=paragraph><p>Em uma versão de 32 bits do FreeBSD, a memória parece perdida, uma vez que ela será remapeada acima de 4 GB, uma área a qual um kernel de 32 bits não consegue acessar. Neste caso, a solução é construir um kernel habilitado para PAE. Veja a seção sobre os limites de memória para mais informações.</p></div><div class=paragraph><p>Em uma versão de 64 bits do FreeBSD, ou quando o kernel estiver habilitado para PAE, o FreeBSD irá corretamente detectar e remapear a memória para que ela seja utilizável. Durante a inicialização, no entanto, pode parecer que o FreeBSD está detectando mais memória do que o sistema realmente possui, devido ao remapeamento descrito. Isso é normal e a memória disponível será corrigida conforme o processo de inicialização for concluído.</p></div></div><div class=sect2><h3 id=_por_que_meus_programas_morrem_ocasionalmente_com_erros_signal_11>5.2. Por que meus programas morrem ocasionalmente com erros Signal 11 ?<a class=anchor href=#_por_que_meus_programas_morrem_ocasionalmente_com_erros_signal_11></a></h3><div class=paragraph><p>Os erros de sinal 11 são causados quando um processo tentou acessar a memória à qual o sistema operacional não concedeu acesso. Se algo assim está acontecendo em intervalos aparentemente aleatórios, comece a investigar a causa.</p></div><div class=paragraph><p>Esses problemas geralmente podem ser atribuídos a:</p></div><div class="olist arabic"><ol class=arabic><li><p>Se o problema está ocorrendo apenas em um aplicativo customizado específico, é provavelmente um bug no código.</p></li><li><p>Se é um problema com parte do sistema base do FreeBSD, também pode ser resultado de um código com bugs, mas na maioria das vezes esses problemas são encontrados e corrigidos muito antes que o publico em geral e que normalmente lê o FAQ usem essas partes do código (é para isso que -CURRENT existe).</p></li></ol></div><div class=paragraph><p>Provavelmente não é um erro do FreeBSD se o problema ocorrer na compilação de um programa, mas sim da atividade que o compilador está realizando e que muda a cada vez.</p></div><div class=paragraph><p>Por exemplo, se <code>make buildworld</code> falhar ao tentar compilar <span class=filename>ls.c</span> para <span class=filename>ls.o</span> e, quando executado novamente, ele falhar no mesmo lugar, significa que o código está quebrado. Tente atualizar o código fonte e tente compilar novamente. Se a compilação falhar em outro lugar, é quase certo que a causa é um problema de hardware.</p></div><div class=paragraph><p>No primeiro caso, use um depurador como o <a href="https://man.freebsd.org/cgi/man.cgi?query=gdb&amp;sektion=1&amp;format=html">gdb(1)</a> para localizar o ponto no programa que está tentando acessar um endereço falso e corrija-o.</p></div><div class=paragraph><p>No segundo caso, verifique qual peça de hardware está com defeito.</p></div><div class=paragraph><p>As causas comuns disso incluem:</p></div><div class="olist arabic"><ol class=arabic><li><p>Os discos rígidos podem estar superaquecidos: Verifique se os ventiladores ainda estão funcionando, pois o disco e outros componentes de hardware podem estar superaquecendo.</p></li><li><p>O processador está superaquecendo: pode ser porque o processador sofreu overclock ou o ventilador do processador pode ter parado de funcionar. Em ambos os casos, certifique-se de que o hardware esteja sendo utilizado de acordo com as condições especificadas pelo fabricante, pelo menos ao tentar resolver esse problema. Se não estiver, volte o clock para as configurações padrão.)</p><div class=paragraph><p>Em relação ao overclocking, é muito mais barato ter um sistema lento do que um sistema frito que precisa ser substituído! Além disso, a comunidade não é simpática a problemas em sistemas com overclock.</p></div></li><li><p>Memória Errática: se vários módulos de memórias SIMMS/DIMMS estiverem instalados, retire-os e tente executar a máquina instalando cada SIMM ou DIMM individualmente para encontrar o modulo DIMM/SIMM problemático ou até mesmo encontrar uma combinação de módulos com problema.</p></li><li><p>Configurações over-otimizadas da placa-mãe: as configurações da BIOS e alguns jumpers da placa-mãe oferecem opções para definir vários intervalos de tempo. Os valores padrões geralmente são suficientes, mas, às vezes, a configuração dos estados de espera na RAM para valores muito baixos, ou a configuração da opção "RAM Speed: Turbo" causará um comportamento estranho. Uma ideia válida é restaurar a configuração padrão da BIOS, depois é claro de anotar as configurações atuais.</p></li><li><p>Fonte com potência insuficiente para energizar a placa-mãe: Remova qualquer placa de I/O não utilizada, discos rígidos ou CD-ROMs, desconectando o cabo de alimentação deles para ver se a fonte de alimentação pode gerenciar uma carga menor. Ou utilize outra fonte de alimentação, de preferência uma com um pouco mais de potência. Por exemplo, se a fonte de alimentação atual é recomendada para uma carga de 250 Watts, tente uma que seja recomendada para uma carga de 300 Watts.</p></li></ol></div><div class=paragraph><p>Leia a seção sobre o <a href=#signal11>Signal 11</a> para obter maiores explicações e a discussão sobre como um software ou hardware de teste de memória ainda pode deixar passar uma memória defeituosa. Existe uma extensa FAQ sobre o problema do SIG11 disponível <a href=http://www.bitwizard.nl/sig11/>neste link</a>.</p></div><div class=paragraph><p>Por fim, se nada disso ajudou, trata-se possivelmente de um bug no FreeBSD. Siga <a href=#access-pr>estas instruções</a> para enviar um relatório de problemas.</p></div></div><div class=sect2><h3 id=_meu_sistema_trava_com_fatal_trap_12_page_fault_in_kernel_mode_ou_panic_e_mostra_um_monte_de_informações_o_que_devo_fazer>5.3. Meu sistema trava com Fatal trap 12: page fault in kernel mode ou panic:, e mostra um monte de informações. O que devo fazer?<a class=anchor href=#_meu_sistema_trava_com_fatal_trap_12_page_fault_in_kernel_mode_ou_panic_e_mostra_um_monte_de_informações_o_que_devo_fazer></a></h3><div class=paragraph><p>Os desenvolvedores do FreeBSD estão interessados ​​nesses erros, mas precisam de mais informações do que apenas a mensagem de erro. Copie a mensagem completa da falha. Em seguida, consulte a seção FAQ em <a href=#kernel-panic-troubleshooting>kernel panics</a>, compile um kernel de depuração e obtenha um backtrace. Isso pode parecer difícil, mas não requer nenhuma habilidade de programação. Apenas siga as instruções.</p></div></div><div class=sect2><h3 id=_qual_é_o_significado_do_erro_maxproc_limit_exceeded_by_uid_i_please_see_tuning7_and_login_conf5>5.4. Qual é o significado do erro maxproc limit exceeded by uid %i, please see tuning(7) and login.conf(5)?<a class=anchor href=#_qual_é_o_significado_do_erro_maxproc_limit_exceeded_by_uid_i_please_see_tuning7_and_login_conf5></a></h3><div class=paragraph><p>O kernel do FreeBSD permitirá que apenas um certo número de processos exista ao mesmo tempo. O número é baseado na variável <code>kern.maxusers</code> do <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a>. O valor da variável <code>kern.maxusers</code> também afeta vários outros limites dentro do kernel, como por exemplo os buffers de rede. Se a máquina estiver muito carregada, aumente o <code>kern.maxusers</code>. Isso aumentará esses outros limites do sistema além do número máximo de processos.</p></div><div class=paragraph><p>Para ajustar o valor da variável <code>kern.maxusers</code>, consulte a seção <a href=https://docs.freebsd.org/pt-br/books/handbook/book/config-tuning#kern-maxfiles>Limites de Arquivos / Processos</a> do Handbook. Apesar desta seção se referir a arquivos abertos, os mesmos limites se aplicam aos processos.</p></div><div class=paragraph><p>Se a máquina estiver levemente carregada, mas executando um número muito grande de processos, ajuste o valor do <code>kern.maxproc</code> definindo-o no arquivo <span class=filename>/boot/loader.conf</span>. O ajuste não terá efeito até que o sistema seja reinicializado. Para mais informações sobre o tuning de variáveis, consulte o manual do <a href="https://man.freebsd.org/cgi/man.cgi?query=loader.conf&amp;sektion=5&amp;format=html">loader.conf(5)</a>. Se esses processos estiverem sendo executados por um único usuário, ajuste o <code>kern.maxprocperuid</code> para que fique menor em 1 unidade do novo valor do <code>kern.maxproc</code>. Ele deve ser pelo menos uma unidade menor porque o programa do sistema, <a href="https://man.freebsd.org/cgi/man.cgi?query=init&amp;sektion=8&amp;format=html">init(8)</a>, deve estar sempre em execução.</p></div></div><div class=sect2><h3 id=_por_que_aplicativos_de_tela_cheia_em_máquinas_remotas_se_comportam_de_forma_errática>5.5. Por que aplicativos de tela cheia em máquinas remotas se comportam de forma errática?<a class=anchor href=#_por_que_aplicativos_de_tela_cheia_em_máquinas_remotas_se_comportam_de_forma_errática></a></h3><div class=paragraph><p>A máquina remota pode estar configurando o tipo de terminal para algo diferente de <code>xterm</code>, que é o tipo requerido pelo console do FreeBSD. Alternativamente, o kernel pode ter valores errados para a largura e a altura do terminal.</p></div><div class=paragraph><p>Verifique se o valor da variável de ambiente <code>TERM</code> é <code>xterm</code>. Se a máquina remota não suportar isso, tente <code>vt100</code>.</p></div><div class=paragraph><p>Execute o <code>stty -a</code> para verificar o que o kernel acha que são as dimensões do terminal. Se estiverem incorretos, eles podem ser alterados executando <code>stty rows_RR_cols_CC_</code>.</p></div><div class=paragraph><p>Alternativamente, se a máquina do cliente tiver o <a class=package href=https://cgit.freebsd.org/ports/tree/x11/xterm/>x11/xterm</a> instalado, a execução do <code>resize</code> consultará o terminal para as dimensões corretas e as definirá.</p></div></div><div class=sect2><h3 id=_por_que_demora_tanto_para_conectar_ao_meu_computador_via_ssh_ou_telnet>5.6. Por que demora tanto para conectar ao meu computador via ssh ou telnet?<a class=anchor href=#_por_que_demora_tanto_para_conectar_ao_meu_computador_via_ssh_ou_telnet></a></h3><div class=paragraph><p>O sintoma: há um longo atraso entre o momento em que a conexão TCP é estabelecida e a hora em que o software cliente solicita uma senha (ou, no caso do <a href="https://man.freebsd.org/cgi/man.cgi?query=telnet&amp;sektion=1&amp;format=html">telnet(1)</a>, quando um prompt de login aparece).</p></div><div class=paragraph><p>O problema: mais provável do que não, o atraso é causado pelo software do servidor tentando resolver o endereço IP do cliente em um nome de host. Muitos servidores, incluindo os servidores Telnet e SSH que vêm com o FreeBSD, fazem isso para armazenar o nome do host em um arquivo de log para referência futura pelo administrador.</p></div><div class=paragraph><p>A solução: se o problema ocorrer sempre, independente do servidor ao que o computador cliente se conecta, o problema está no cliente. Se o problema ocorrer apenas quando o computador cliente se conecta a um determinado servidor, o problema está no servidor.</p></div><div class=paragraph><p>Se o problema for com o cliente, a única solução é corrigir o DNS para que o servidor possa resolvê-lo. Se isso estiver ocorrendo em uma rede local, considere um problema no servidor e continue lendo. Se isso estiver ocorrendo na Internet, entre em contato com seu ISP.</p></div><div class=paragraph><p>Se o problema for com um servidor em uma rede local, configure o servidor para resolver as consultas de endereço para nome de host para o intervalo de endereços da rede local. Veja as páginas de manual para o <a href="https://man.freebsd.org/cgi/man.cgi?query=hosts&amp;sektion=5&amp;format=html">hosts(5)</a> e o <a href="https://man.freebsd.org/cgi/man.cgi?query=named&amp;sektion=8&amp;format=html">named(8)</a> para maiores informações. Se o problema for com um servidor na Internet, o problema pode ser que o resolver local do servidor não está funcionando corretamente. Para verificar se é isto, tente procurar outro host, como <code>www.yahoo.com</code>. Se isso não funcionar, este é o problema.</p></div><div class=paragraph><p>Após uma nova instalação do FreeBSD, também é possível que as informações do domínio e do servidor de nomes estejam faltando no <span class=filename>/etc/resolv.conf</span>. Isso geralmente causará um atraso no SSH, já que a opção <code>UseDNS</code> é definida como <code>yes</code> por padrão no <span class=filename>/etc/ssh/sshd_config</span>. Se isso estiver causando o problema, preencha as informações ausentes no arquivo <span class=filename>/etc/resolv.conf</span> ou configure a opção <code>UseDNS</code> para <code>no</code> no arquivo <span class=filename>sshd_config</span> como uma solução temporária.</p></div></div><div class=sect2><h3 id=_por_que_a_mensagem_file_table_is_full_aparece_repetidamente_no_dmesg8>5.7. Por que a mensagem file: table is full aparece repetidamente no dmesg8?<a class=anchor href=#_por_que_a_mensagem_file_table_is_full_aparece_repetidamente_no_dmesg8></a></h3><div class=paragraph><p>Essa mensagem de erro indica que o número de file descriptors disponíveis no sistema esgotaram. Consulte a informação sobre a variável <a href=https://docs.freebsd.org/pt-br/books/handbook/book/config-tuning#kern-maxfiles>kern.maxfiles</a> na seção <a href=https://docs.freebsd.org/pt-br/books/handbook/book/config-tuning#configtuning-kernel-limits>Ajustando os Limites do Kernel</a> do Handbook para uma discussão e solução.</p></div></div><div class=sect2><h3 id=_por_que_o_relógio_do_meu_computador_mantém_se_com_o_horário_incorreto>5.8. Por que o relógio do meu computador mantém-se com o horário incorreto?<a class=anchor href=#_por_que_o_relógio_do_meu_computador_mantém_se_com_o_horário_incorreto></a></h3><div class=paragraph><p>O computador tem dois ou mais relógios e o FreeBSD escolheu usar o errado.</p></div><div class=paragraph><p>Execute o comando <a href="https://man.freebsd.org/cgi/man.cgi?query=dmesg&amp;sektion=8&amp;format=html">dmesg(8)</a> e verifique as linhas que contêm a palavra <code>Timecounter</code>. Aquele com o maior valor de quality é o que o FreeBSD escolheu.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dmesg | grep Timecounter</span>
Timecounter <span class=s2>&#34;i8254&#34;</span> frequency 1193182 Hz quality 0
Timecounter <span class=s2>&#34;ACPI-fast&#34;</span> frequency 3579545 Hz quality 1000
Timecounter <span class=s2>&#34;TSC&#34;</span> frequency 2998570050 Hz quality 800
Timecounters tick every 1.000 msec</code></pre></div></div><div class=paragraph><p>Confirme isso verificando o valor da variável <code>kern.timecounter.hardware</code> no <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=3&amp;format=html">sysctl(3)</a>.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl kern.timecounter.hardware</span>
kern.timecounter.hardware: ACPI-fast</code></pre></div></div><div class=paragraph><p>Pode ser um timer ACPI quebrado. A solução mais simples é desabilitar o timer ACPI no arquivo <span class=filename>/boot/loader.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>debug.acpi.disabled=&#34;timer&#34;</pre></div></div><div class=paragraph><p>Ou a BIOS poderá modificar o relógio TSC - talvez para mudar a velocidade do processador quando estiver funcionando a partir de baterias, ou quando estiver entrando em modo de economia de energia, mas o FreeBSD não tem conhecimento desses ajustes e parece ganhar ou perder tempo.</p></div><div class=paragraph><p>Neste exemplo, o relógio <code>i8254</code> também está disponível e pode ser selecionado alterando-se a variável <code>kern.timecounter.hardware</code> do <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=3&amp;format=html">sysctl(3)</a>.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl kern.timecounter.hardware=i8254</span>
kern.timecounter.hardware: TSC -&gt; i8254</code></pre></div></div><div class=paragraph><p>O computador agora deve começar a manter seu relógio mais preciso.</p></div><div class=paragraph><p>Para que essa mudança seja executada automaticamente no momento da inicialização, adicione a seguinte linha ao arquivo <span class=filename>/etc/sysctl.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>kern.timecounter.hardware=i8254</pre></div></div></div><div class=sect2><h3 id=_o_que_significa_o_erro_swap_pager_indefinite_wait_buffer>5.9. O que significa o erro swap_pager: indefinite wait buffer:?<a class=anchor href=#_o_que_significa_o_erro_swap_pager_indefinite_wait_buffer></a></h3><div class=paragraph><p>Isso significa que um processo está tentando armazenar em memória RAM a memória do disco (swap), e que o processo foi interrompido depois de tentar sem sucesso acessar o disco por mais de 20 segundos. Isso pode ser causado por blocos defeituosos na unidade de disco, fiação de disco defeituosa, cabos ou qualquer outro hardware relacionado a I/O de disco. Se a própria unidade estiver com problemas, erros de disco aparecerão em <span class=filename>/var/log/messages</span> e na saída do comando <code>dmesg</code>. Caso contrário, verifique os cabos e conexões.</p></div></div><div class=sect2><h3 id=_o_que_é_um_lock_order_reversal_inversão_de_ordem_de_bloqueio>5.10. O que é um lock order reversal (inversão de ordem de bloqueio)?<a class=anchor href=#_o_que_é_um_lock_order_reversal_inversão_de_ordem_de_bloqueio></a></h3><div class=paragraph><p>O kernel do FreeBSD usa vários locks de recursos para arbitrar a contenção de certos recursos. Quando várias threads do kernel tentam obter vários locks de recursos, há sempre o potencial para um impasse (deadlock), em que duas threads obtiveram cada uma um dos locks e trava para sempre esperando que a outra thread libere um dos outros locks. Esse tipo de problema de locking pode ser evitado se todas as threads obtiverem os locks na mesma ordem.</p></div><div class=paragraph><p>Um sistema de diagnóstico lock em tempo de execução chamado <a href="https://man.freebsd.org/cgi/man.cgi?query=witness&amp;sektion=4&amp;format=html">witness(4)</a>, ativado no FreeBSD-CURRENT e desabilitado por padrão para a branch stable e releases, detecta o potencial para deadlocks devido a erros de locking, incluindo erros causados ​​pela obtenção de vários locks de recursos com uma ordem diferente de partes diferentes do kernel. O framework <a href="https://man.freebsd.org/cgi/man.cgi?query=witness&amp;sektion=4&amp;format=html">witness(4)</a> tenta detectar esse problema quando ele ocorre e relata isso imprimindo uma mensagem no console do sistema sobre um <code>lock order reversal</code> (geralmente também chamado de LOR).</p></div><div class=paragraph><p>É possível obter falsos positivos, uma vez que o <a href="https://man.freebsd.org/cgi/man.cgi?query=witness&amp;sektion=4&amp;format=html">witness(4)</a> é conservador. Um relatório positivo verdadeiro <em>não</em> significa que um sistema está travado; em vez disso, deve ser entendido como um aviso de que um deadlock poderia ter acontecido.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Os problemas de LOR tendem a ser consertados rapidamente, então verifique a lista de discussão do <a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-current>FreeBSD-CURRENT</a> antes de postar sobre um.</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=_o_que_significa_o_erro_called_with_the_following_non_sleepable_locks_held>5.11. O que significa o erro Called …​ with the following non-sleepable locks held?<a class=anchor href=#_o_que_significa_o_erro_called_with_the_following_non_sleepable_locks_held></a></h3><div class=paragraph><p>Isso significa que uma função que pode dormir foi chamada enquanto um lock mutex (ou outro unsleepable) era mantido.</p></div><div class=paragraph><p>A razão pela qual isso é um erro é porque os mutexes não devem ser mantidos por longos períodos de tempo; eles deveriam existir apenas para manter curtos períodos de sincronização. Este contrato de programação permite que os drivers de dispositivos usem mutexes para sincronizar com o resto do kernel durante as interrupções. As interrupções (no FreeBSD) podem não dormir. Por isso, é imperativo que nenhum subsistema bloqueie o kernel por um longo período mantendo um mutex ativo.</p></div><div class=paragraph><p>Para capturar tais erros, asserções podem ser adicionadas ao kernel que interage com o subsistema <a href="https://man.freebsd.org/cgi/man.cgi?query=witness&amp;sektion=4&amp;format=html">witness(4)</a> para emitir um aviso ou erro fatal (dependendo a configuração do sistema) quando uma chamada potencialmente de bloqueio é feita enquanto um mutex estiver sendo mantido.</p></div><div class=paragraph><p>Em resumo, tais avisos não são fatais, no entanto, com um timing infeliz, podem causar efeitos indesejáveis, desde um pequeno erro na capacidade de resposta do sistema até o seu travamento completo.</p></div><div class=paragraph><p>Para obter informações adicionais sobre locking no FreeBSD, consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=locking&amp;sektion=9&amp;format=html">locking(9)</a>.</p></div></div><div class=sect2><h3 id=_por_que_o_buildworld_installworld_morre_com_a_mensagem_touch_not_found>5.12. Por que o buildworld / installworld morre com a mensagem touch: not found?<a class=anchor href=#_por_que_o_buildworld_installworld_morre_com_a_mensagem_touch_not_found></a></h3><div class=paragraph><p>Este erro não significa que o utilitário <a href="https://man.freebsd.org/cgi/man.cgi?query=touch&amp;sektion=1&amp;format=html">touch(1)</a> esteja ausente. O erro é provavelmente devido às datas dos arquivos que estão sendo definidos em algum momento no futuro. Se o relógio do CMOS estiver configurado para a hora local, execute <code>adjkerntz -i</code> para ajustar o relógio do kernel ao inicializar no modo de usuário único.</p></div></div></div></div><div class=sect1><h2 id=_aplicativos_do_usuário>6. Aplicativos do Usuário<a class=anchor href=#_aplicativos_do_usuário></a></h2><div class=sectionbody><div class=sect2><h3 id=_onde_estão_todas_as_aplicações_de_usuário>6.1. Onde estão todas as aplicações de usuário?<a class=anchor href=#_onde_estão_todas_as_aplicações_de_usuário></a></h3><div class=paragraph><p>Consulte <a href=https://www.FreeBSD.org/ports/>a página dos ports</a> para informações sobre pacotes de software portados para o FreeBSD.</p></div><div class=paragraph><p>A maioria dos ports deve funcionar em todas as versões suportadas do FreeBSD. Aqueles que não funcionam, estão especificamente sinalizados como tal. Cada vez que uma release do FreeBSD é construída, um snapshot da coleção de ports no momento da construção também é incluída no diretório <span class=filename>ports/</span>.</p></div><div class=paragraph><p>O FreeBSD suporta pacotes binários compactados para facilitar a instalação e desinstalação dos ports. Use o comando <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg&amp;sektion=7&amp;format=html">pkg(7)</a> para controlar a instalação de pacotes.</p></div></div><div class=sect2><h3 id=_como_faço_para_baixar_a_coleção_de_ports_eu_deveria_estar_usando_o_subversion>6.2. Como faço para baixar a coleção de ports? Eu deveria estar usando o Subversion?<a class=anchor href=#_como_faço_para_baixar_a_coleção_de_ports_eu_deveria_estar_usando_o_subversion></a></h3><div class=paragraph><p>Qualquer um dos métodos listados aqui funciona:</p></div><div class=ulist><ul><li><p>Use o portsnap para a maioria dos casos de uso. Consulte a seção <a href=https://docs.freebsd.org/pt-br/books/handbook/book/ports#ports-using>Usando a coleção de ports</a> para obter instruções sobre como usar essa ferramenta .</p></li><li><p>Use o Subversion se for necessário a aplicação de patches customizados na árvore de ports ou se estiver rodando FreeBSD-CURRENT. Consulte a seção <a href=https://docs.freebsd.org/pt-br/books/handbook/book/mirrors#svn>Usando o Subversion</a> para obter detalhes.</p></li></ul></div></div><div class=sect2><h3 id=_por_que_não_posso_compilar_esse_port_na_minha_máquina_11_x_ou_12_x_stable>6.3. Por que não posso compilar esse port na minha máquina 11.X - ou 12.X -STABLE?<a class=anchor href=#_por_que_não_posso_compilar_esse_port_na_minha_máquina_11_x_ou_12_x_stable></a></h3><div class=paragraph><p>Se a versão do FreeBSD instalada estiver significativamente atrás do <em>-CURRENT</em> ou do <em>-STABLE</em>, atualize a coleção de ports usando as instruções disponíveis na seção <a href=https://docs.freebsd.org/pt-br/books/handbook/book/ports#ports-using>Usando a coleção de ports</a>. Se o sistema estiver atualizado, alguém pode ter feito uma alteração no port que funciona para <em>-CURRENT</em> mas que quebrou o port para o <em>-STABLE</em>. <a href=https://bugs.FreeBSD.org/submit/>Envie</a> um relatório de bug, já que a Coleção de Ports deve funcionar tanto para o branch <em>-CURRENT</em> e quanto o <em>-STABLE</em>.</p></div></div><div class=sect2><h3 id=_acabei_de_tentar_compilar_o_index_usando_o_comando_make_index_e_ele_falhou_por_quê>6.4. Acabei de tentar compilar o INDEX usando o comando make index, e ele falhou. Por quê?<a class=anchor href=#_acabei_de_tentar_compilar_o_index_usando_o_comando_make_index_e_ele_falhou_por_quê></a></h3><div class=paragraph><p>Primeiro, certifique-se de que a Coleção de Ports esteja atualizada. Erros que afetam a compilação do <span class=filename>INDEX</span> a partir de uma cópia atualizada da coleção de ports são de alta visibilidade e, portanto, quase sempre são corrigidos imediatamente.</p></div><div class=paragraph><p>Existem casos raros em que o <span class=filename>INDEX</span> não será compilado devido a casos estranhos envolvendo a variável <code>OPTIONS_SET</code> sendo definida em <span class=filename>make.conf</span>. Se você suspeitar que este é o caso, tente fazer o <span class=filename>INDEX</span> com estas variáveis desativadas antes de reportar o erro para a <a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-ports>Lista de discussão de ports do FreeBSD</a>.</p></div></div><div class=sect2><h3 id=_eu_atualizei_os_fontes_agora_como_faço_para_atualizar_meus_ports_instalados>6.5. Eu atualizei os fontes, agora como faço para atualizar meus ports instalados?<a class=anchor href=#_eu_atualizei_os_fontes_agora_como_faço_para_atualizar_meus_ports_instalados></a></h3><div class=paragraph><p>O FreeBSD não inclui uma ferramenta de atualização de ports, mas possui algumas ferramentas para facilitar o processo de atualização. Ferramentas adicionais estão disponíveis para simplificar o manuseio dos ports e são descritas na seção <a href=https://docs.freebsd.org/pt-br/books/handbook/book/ports#ports-using>Atualizando Ports</a> no Handbook do FreeBSD .</p></div></div><div class=sect2><h3 id=_preciso_recompilar_todos_os_ports_sempre_que_realizo_uma_atualização_de_versão_principal>6.6. Preciso recompilar todos os ports sempre que realizo uma atualização de versão principal?<a class=anchor href=#_preciso_recompilar_todos_os_ports_sempre_que_realizo_uma_atualização_de_versão_principal></a></h3><div class=paragraph><p>Sim! Apesar de um sistema recente ser capaz de executar os softwares compilados em uma versão mais antiga, as coisas irão falhar aleatoriamente e deixar de funcionar quando outros ports forem instalados ou atualizados.</p></div><div class=paragraph><p>Quando o sistema é atualizado, várias bibliotecas compartilhadas, módulos carregáveis ​​e outras partes do sistema serão substituídas por versões mais recentes. Os aplicativos vinculados às versões mais antigas podem não iniciar ou, em outros casos, não funcionar corretamente.</p></div><div class=paragraph><p>Para obter maiores informações, consulte a <a href=https://docs.freebsd.org/pt-br/books/handbook/book/updating-upgrading#freebsdupdate-upgrade>seção sobre atualizações</a> no Handbook do FreeBSD.</p></div></div><div class=sect2><h3 id=_preciso_recompilar_cada_port_toda_vez_que_faço_uma_atualização_de_versão_secundária>6.7. Preciso recompilar cada port toda vez que faço uma atualização de versão secundária?<a class=anchor href=#_preciso_recompilar_cada_port_toda_vez_que_faço_uma_atualização_de_versão_secundária></a></h3><div class=paragraph><p>Em geral, não. Os desenvolvedores do FreeBSD fazem o máximo para garantir compatibilidade binária em todos os releases com o mesmo número de versão principal. Quaisquer exceções serão documentadas nas Release Notes, e os conselhos dados lá devem ser seguidos.</p></div></div><div class=sect2><h3 id=_por_que_o_binsh_é_tão_pequeno_por_que_o_freebsd_não_usa_o_bash_ou_outro_shell>6.8. Por que o /bin/sh é tão pequeno? Por que o FreeBSD não usa o bash ou outro shell?<a class=anchor href=#_por_que_o_binsh_é_tão_pequeno_por_que_o_freebsd_não_usa_o_bash_ou_outro_shell></a></h3><div class=paragraph><p>Muitas pessoas precisam escrever shell scripts que serão portados para muitos sistemas. É por isso que o POSIX™ especifica os comandos shell e utilitários em grande detalhe. A maioria dos scripts são escritos em Bourne shell (<a href="https://man.freebsd.org/cgi/man.cgi?query=sh&amp;sektion=1&amp;format=html">sh(1)</a>) e porque várias interfaces de programação importantes (<a href="https://man.freebsd.org/cgi/man.cgi?query=make&amp;sektion=1&amp;format=html">make(1)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=system&amp;sektion=3&amp;format=html">system(3)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=popen&amp;sektion=3&amp;format=html">popen(3)</a> e análogos em linguagens de script de alto nível como Perl e Tcl) são especificados para usar o Bourne shell para interpretar comandos. Como o Bourne shell é usado com tanta frequência e em larga escala, é importante que ele seja iniciado rapidamente, que seja determinístico em seu comportamento e que ocupe o menor espaço possível na memória.</p></div><div class=paragraph><p>A implementação existente é resultado do nosso melhor esforço para atender simultaneamente o quanto pudermos desses requisitos. Para manter o <code>/bin/sh</code> pequeno, não fornecemos muitos dos recursos de conveniência que os outros shells possuem. É por isso que outras shells com mais recursos, como o <code>bash</code>, o <code>scsh</code>, o <a href="https://man.freebsd.org/cgi/man.cgi?query=tcsh&amp;sektion=1&amp;format=html">tcsh(1)</a>, e o <code>zsh</code> estão disponíveis. Compare a utilização de memória desses shells observando as colunas " VSZ " e " RSS " em uma listagem gerada com o comando <code>ps -u</code>.</p></div></div></div></div><div class=sect1><h2 id=_configuração_do_kernel>7. Configuração do Kernel<a class=anchor href=#_configuração_do_kernel></a></h2><div class=sectionbody><div class=sect2><h3 id=make-kernel>7.1. Eu gostaria de customizar meu kernel. É difícil?<a class=anchor href=#make-kernel></a></h3><div class=paragraph><p>De modo nenhum! Confira a seção <a href=https://docs.freebsd.org/pt-br/books/handbook/book/kernelconfig#kernelconfig>configuração do kernel do Handbook</a>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>O novo <span class=filename>kernel</span> será instalado no diretório <span class=filename>/boot/kernel</span> junto com os seus módulos, enquanto o kernel antigo e seus módulos serão movidos para o diretório <span class=filename>/boot/kernel.old</span>. Se um erro for cometido na configuração, basta inicializar utilizando a versão anterior do kernel.</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=_por_que_meu_kernel_é_tão_grande>7.2. Por que meu kernel é tão grande?<a class=anchor href=#_por_que_meu_kernel_é_tão_grande></a></h3><div class=paragraph><p>Os kernels <code>GENERIC</code> enviados com o FreeBSD são compilados com o <em>modo de depuração</em> habilitado. Kernels compilados no modo de depuração contêm dados de depuração em arquivos separados que são usados ​​para depuração. Versões do FreeBSD anteriores a 11.0 armazenam esses arquivos de depuração no mesmo diretório que o próprio kernel, <span class=filename>/boot/kernel/</span>. No FreeBSD 11.0 e posterior, os arquivos de depuração são armazenados em <span class=filename>/usr/lib/debug/boot/kernel/</span>. Observe que haverá pouca ou nenhuma perda de desempenho ao executar um kernel com o modo de depuração habilitado, e é útil manter um por perto em caso de panic no sistema.</p></div><div class=paragraph><p>Quando estiver com pouco espaço em disco, existem diferentes opções para reduzir o tamanho de <span class=filename>/boot/kernel/</span> e <span class=filename>/usr/lib/debug/</span>.</p></div><div class=paragraph><p>Para não instalar os arquivos de símbolos, certifique-se que a seguinte linha existe em <span class=filename>/etc/src.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>WITHOUT_KERNEL_SYMBOLS=yes</pre></div></div><div class=paragraph><p>Para mais informações veja <a href="https://man.freebsd.org/cgi/man.cgi?query=src.conf&amp;sektion=5&amp;format=html">src.conf(5)</a>.</p></div><div class=paragraph><p>Se você quiser evitar completamente a criação de arquivos de depuração, certifique-se de que ambos os itens a seguir sejam verdadeiros:</p></div><div class=ulist><ul><li><p>Esta linha não existe no arquivo de configuração do kernel:</p><div class="literalblock programlisting"><div class=content><pre>makeoptions DEBUG=-g</pre></div></div></li><li><p>Não execute o comando <a href="https://man.freebsd.org/cgi/man.cgi?query=config&amp;sektion=8&amp;format=html">config(8)</a> com a opção <code>-g</code>.</p></li></ul></div><div class=paragraph><p>Qualquer uma das configurações acima fará com que o kernel seja construído com suporte ao modo de depuração.</p></div><div class=paragraph><p>Para construir e instalar somente os módulos desejados, liste-os em <span class=filename>/etc/make.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>MODULES_OVERRIDE= accf_http ipfw</pre></div></div><div class=paragraph><p>Substitua <em>accf_httpd ipfw</em> com a lista dos módulos que precisa. Apenas os módulos listados serão compilados. Isso reduz o tamanho do diretório do kernel e diminui o tempo necessário para compilar o kernel. Para mais informações, leia <span class=filename>/usr/shared/examples/etc/make.conf</span>.</p></div><div class=paragraph><p>Dispositivos desnecessários podem ser removidos do kernel para reduzir ainda mais o tamanho. Veja <a href=#make-kernel>Eu gostaria de customizar meu kernel. É difícil?</a> para mais informações.</p></div><div class=paragraph><p>Para colocar qualquer uma dessas opções em vigor, siga as instruções para <a href=https://docs.freebsd.org/pt-br/books/handbook/book/kernelconfig/#kernelconfig-building>compilar e instalar</a> um novo kernel.</p></div><div class=paragraph><p>Para referência, o kernel amd64 do FreeBSD 11 (<span class=filename>/boot/kernel/kernel</span>) é de aproximadamente 25 MB.</p></div></div><div class=sect2><h3 id=_por_que_todo_kernel_que_eu_tento_construir_falha_ao_compilar_até_mesmo_o_generic>7.3. Por que todo kernel que eu tento construir falha ao compilar, até mesmo o GENERIC?<a class=anchor href=#_por_que_todo_kernel_que_eu_tento_construir_falha_ao_compilar_até_mesmo_o_generic></a></h3><div class=paragraph><p>Há várias causas possíveis para esse problema:</p></div><div class=ulist><ul><li><p>A o código fonte de origem é diferente do usado para construir o sistema atualmente em execução. Ao tentar uma atualização, leia o arquivo <span class=filename>/usr/src/UPDATING</span>, prestando atenção especial à seção "ITENS COMUNS" no final.</p></li><li><p>O comando <code>make buildkernel</code> não foi concluído com sucesso. O comando <code>make buildkernel</code> depende dos arquivos gerados pelo comando <code>make buildworld</code> para concluir seu trabalho corretamente.</p></li><li><p>Mesmo quando estiver compilando o <a href=#stable>FreeBSD-STABLE</a>, é possível que o código fonte tenha sido obtido em um momento em que estava sendo modificado ou em que estava quebrado. Somente os releases possuem a garantia de que podem ser compilados, apesar do <a href=#stable>FreeBSD-STABLE</a> compilar corretamente na maioria das vezes. Tente atualizar novamente o código fonte e veja se o problema desaparece. Tente usar um servidor de distribuição diferente, caso o anterior esteja com problemas.</p></li></ul></div></div><div class=sect2><h3 id=_qual_agendador_está_em_uso_em_um_sistema_em_execução>7.4. Qual agendador está em uso em um sistema em execução?<a class=anchor href=#_qual_agendador_está_em_uso_em_um_sistema_em_execução></a></h3><div class=paragraph><p>O nome do agendador que atualmente sendo usado está diretamente disponível como o valor da variavel <code>kern.sched.name</code> do sysctl:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% sysctl kern.sched.name
kern.sched.name: ULE</code></pre></div></div></div><div class=sect2><h3 id=_o_que_é_o_kern_sched_quantum>7.5. O que é o kern.sched.quantum?<a class=anchor href=#_o_que_é_o_kern_sched_quantum></a></h3><div class=paragraph><p>A variável <code>kern.sched.quantum</code> define o número máximo de pulsos que um processo pode executar sem ser "preempted" no scheduler 4BSD.</p></div></div></div></div><div class=sect1><h2 id=_discos_sistemas_de_arquivos_e_boot_loaders>8. Discos, sistemas de arquivos e boot loaders<a class=anchor href=#_discos_sistemas_de_arquivos_e_boot_loaders></a></h2><div class=sectionbody><div class=sect2><h3 id=_como_posso_adicionar_o_meu_novo_disco_rígido_ao_meu_sistema_freebsd>8.1. Como posso adicionar o meu novo disco rígido ao meu sistema FreeBSD?<a class=anchor href=#_como_posso_adicionar_o_meu_novo_disco_rígido_ao_meu_sistema_freebsd></a></h3><div class=paragraph><p>Veja a seção <a href=https://docs.freebsd.org/pt-br/books/handbook/book/disks#disks-adding>Adicionando Discos</a> no Handbook do FreeBSD.</p></div></div><div class=sect2><h3 id=_como_faço_para_mover_meu_sistema_para_o_meu_novo_disco_enorme>8.2. Como faço para mover meu sistema para o meu novo disco enorme?<a class=anchor href=#_como_faço_para_mover_meu_sistema_para_o_meu_novo_disco_enorme></a></h3><div class=paragraph><p>A melhor maneira é reinstalar o sistema operacional no novo disco e depois passar os dados do usuário. Isto é altamente recomendado ao seguir o <em>-STABLE</em> por mais de uma release ou ao atualizar uma release ao invés de instalar uma nova. Instale o booteasy em ambos os discos com <a href="https://man.freebsd.org/cgi/man.cgi?query=boot0cfg&amp;sektion=8&amp;format=html">boot0cfg(8)</a> e use a opção de dual boot até que esteja satisfeito com a nova configuração. Pule o próximo parágrafo para descobrir como mover os dados depois de fazer isso.</p></div><div class=paragraph><p>Alternativamente, particione e rotule o novo disco utilizando o <a href="https://man.freebsd.org/cgi/man.cgi?query=sade&amp;sektion=8&amp;format=html">sade(8)</a> ou o <a href="https://man.freebsd.org/cgi/man.cgi?query=gpart&amp;sektion=8&amp;format=html">gpart(8)</a>. Se os discos forem formatados com MBR, o booteasy pode ser instalado em ambos os discos utilizando-se o <a href="https://man.freebsd.org/cgi/man.cgi?query=boot0cfg&amp;sektion=8&amp;format=html">boot0cfg(8)</a> para que o computador possa inicializar dualmente com o antigo ou novo sistema após a conclusão da cópia.</p></div><div class=paragraph><p>Depois que o novo disco estiver configurado, os dados não podem ser simplesmente copiados. Em vez disso, use ferramentas que entendam device files e system flags, tais como o <a href="https://man.freebsd.org/cgi/man.cgi?query=dump&amp;sektion=8&amp;format=html">dump(8)</a>. Embora seja recomendado que você mova os dados com o sistema em modo single user, isto não é necessário.</p></div><div class=paragraph><p>Quando os discos estiverem formatados com UFS, nunca use nada além do <a href="https://man.freebsd.org/cgi/man.cgi?query=dump&amp;sektion=8&amp;format=html">dump(8)</a> e do <a href="https://man.freebsd.org/cgi/man.cgi?query=restore&amp;sektion=8&amp;format=html">restore(8)</a> para mover o sistema de arquivos raiz. Esses comandos também devem ser usados para mover uma única partição para uma outra partição vazia. A seqüência de etapas para usar o comando <code>dump</code> para mover os dados de uma partição UFS para uma nova partição é:</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Execute o <code>newfs</code> na nova partição.</p></li><li><p>Utilize o <code>mount</code> para disponibilizá-la em um ponto de montagem temporário.</p></li><li><p>Vá para o diretório desejado utilizando o comando <code>cd</code>.</p></li><li><p>Faça o <code>dump</code> da partição antiga e redirecione a saída para a nova.</p></li></ol></div></div></div><div class=paragraph><p>Por exemplo, para mover <span class=filename>/dev/ada1s1a</span> tendo <span class=filename>/mnt</span> como o ponto de montagem temporário, digite:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># newfs /dev/ada1s1a</span>
<span class=c># mount /dev/ada1s1a /mnt</span>
<span class=c># cd /mnt</span>
<span class=c># dump 0af - / | restore rf -</span></code></pre></div></div><div class=paragraph><p>Reorganizar as partições com o comando <code>dump</code> requer um pouco mais de trabalho. Para mesclar uma partição como <span class=filename>/var</span> com a partição pai, crie uma nova partição grande o suficiente para conter ambas, mova a partição pai conforme descrito acima e mova a partição filha para o diretório vazio criado pela primeira movimentação:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># newfs /dev/ada1s1a</span>
<span class=c># mount /dev/ada1s1a /mnt</span>
<span class=c># cd /mnt</span>
<span class=c># dump 0af - / | restore rf -</span>
<span class=c># cd var</span>
<span class=c># dump 0af - /var | restore rf -</span></code></pre></div></div><div class=paragraph><p>Para separar um diretório do seu pai, digamos colocar <span class=filename>/var</span> em sua própria partição quando não era antes, crie as duas partições, monte a partição filho no diretório apropriado no ponto de montagem temporário e mova a antiga partição única:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># newfs /dev/ada1s1a</span>
<span class=c># newfs /dev/ada1s1d</span>
<span class=c># mount /dev/ada1s1a /mnt</span>
<span class=c># mkdir /mnt/var</span>
<span class=c># mount /dev/ada1s1d /mnt/var</span>
<span class=c># cd /mnt</span>
<span class=c># dump 0af - / | restore rf -</span></code></pre></div></div><div class=paragraph><p>Os utilitários <a href="https://man.freebsd.org/cgi/man.cgi?query=cpio&amp;sektion=1&amp;format=html">cpio(1)</a> e <a href="https://man.freebsd.org/cgi/man.cgi?query=pax&amp;sektion=1&amp;format=html">pax(1)</a> também estão disponíveis para mover dados do usuário. Estes comandos são conhecidos por perder as flags com as informações dos arquivo, portanto, use-os com cuidado.</p></div></div><div class=sect2><h3 id=_quais_partições_podem_usar_com_segurança_o_soft_updates_ouvi_dizer_que_o_uso_de_soft_updates_no_pode_causar_problemas_e_quanto_ao_journaled_soft_updates>8.3. Quais partições podem usar com segurança o Soft Updates? Ouvi dizer que o uso de Soft Updates no / pode causar problemas. E quanto ao Journaled Soft Updates?<a class=anchor href=#_quais_partições_podem_usar_com_segurança_o_soft_updates_ouvi_dizer_que_o_uso_de_soft_updates_no_pode_causar_problemas_e_quanto_ao_journaled_soft_updates></a></h3><div class=paragraph><p>Resposta curta: Soft Updates geralmente podem ser usados ​​com segurança em todas as partições.</p></div><div class=paragraph><p>Resposta longa: o Soft Updates possui duas características que podem ser indesejáveis ​​em determinadas partições. Primeiro, uma partição com Soft Updates tem uma pequena chance de perder dados durante uma falha do sistema. A partição não será corrompida, pois os dados serão simplesmente perdidos. Em segundo lugar, o uso de Soft Updates pode causar escassez temporária de espaço.</p></div><div class=paragraph><p>Ao usar o Soft Updates, o kernel pode levar até trinta segundos para gravar alterações no disco físico. Quando um arquivo grande é excluído, o arquivo ainda reside no disco até que o kernel execute a exclusão. Isso pode causar uma "race condition" muito simples. Suponha que um arquivo grande seja excluído e outro arquivo grande seja criado imediatamente. O primeiro arquivo grande ainda não foi removido do disco físico, portanto, o disco pode não ter espaço suficiente para o segundo arquivo grande. Isso produzirá um erro de que a partição não tem espaço suficiente, mesmo que um grande espaço tenha acabado de ser liberado. Alguns segundos depois, a criação do arquivo funciona conforme o esperado.</p></div><div class=paragraph><p>Se um sistema travar depois que o kernel tiver aceito um bloco de dados para gravar no disco, mas antes que os dados sejam realmente gravados, os dados poderão ser perdidos. Esse risco é extremamente pequeno, e geralmente gerenciável.</p></div><div class=paragraph><p>Esses problemas afetam todas as partições usando as Soft Updates. Então, o que isso significa para a partição raiz?</p></div><div class=paragraph><p>Informações vitais sobre a partição raiz mudam muito raramente. Se o sistema travar dentro da janela de 30 segundos depois de uma alteração ter sido feita, é possível que os dados possam ser perdidos. Esse risco é insignificante para a maioria dos aplicativos, mas esteja ciente de que existe. Se o seu sistema não puder tolerar este risco, não use as Soft Updates no sistema de arquivos raiz!</p></div><div class=paragraph><p>O <span class=filename>/</span> é tradicionalmente uma das menores partições. Se o <span class=filename>/tmp</span> estiver localizado dentro do <span class=filename>/</span>, pode haver problemas intermitentes de falta de espaço. A criação de um link simbólico apontando o <span class=filename>/tmp</span> para <span class=filename>/var/tmp</span> resolverá esse problema.</p></div><div class=paragraph><p>Por fim, o <a href="https://man.freebsd.org/cgi/man.cgi?query=dump&amp;sektion=8&amp;format=html">dump(8)</a> não funciona no modo live (-L) em um sistema de arquivos, com Journaled Soft Updates (SU + J).</p></div></div><div class=sect2><h3 id=_posso_acessar_outros_sistemas_de_arquivos_não_nativos_do_freebsd>8.4. Posso acessar outros sistemas de arquivos não-nativos do FreeBSD?<a class=anchor href=#_posso_acessar_outros_sistemas_de_arquivos_não_nativos_do_freebsd></a></h3><div class=paragraph><p>O FreeBSD suporta uma variedade de outros sistemas de arquivos.</p></div><div class=dlist><dl><dt class=hdlist1>UFS</dt><dd><p>Os CD-ROMs UFS podem ser montados diretamente no FreeBSD. Montar partições de disco do Digital UNIX e de outros sistemas que suportam o UFS pode ser mais complexo, dependendo dos detalhes do particionamento do disco para o sistema operacional em questão.</p></dd><dt class=hdlist1>ext2/ext3</dt><dd><p>O FreeBSD suporta partições <code>ext2fs</code> e <code>ext3fs</code>. Veja <a href="https://man.freebsd.org/cgi/man.cgi?query=ext2fs&amp;sektion=5&amp;format=html">ext2fs(5)</a> para mais informações.</p></dd><dt class=hdlist1>NTFS</dt><dd><p>O suporte ao NTFS baseia-se no FUSE está disponível como um port (<a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/fusefs-ntfs/>sysutils/fusefs-ntfs</a>). Para mais informações, consulte <a href=http://www.tuxera.com/community/ntfs-3g-manual/>ntfs-3g</a>.</p></dd><dt class=hdlist1>FAT</dt><dd><p>O FreeBSD inclui um driver FAT de leitura-gravação. Para obter mais informações, consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=mount_msdosfs&amp;sektion=8&amp;format=html">mount_msdosfs(8)</a>.</p></dd><dt class=hdlist1>ZFS</dt><dd><p>O FreeBSD inclui um port do driver ZFS da Sun™. A recomendação atual é usá-lo apenas em plataformas amd64 com memória suficiente. Para obter mais informações, consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=zfs&amp;sektion=8&amp;format=html">zfs(8)</a>.</p></dd></dl></div><div class=paragraph><p>O FreeBSD inclui o sistema de arquivos de rede NFS e a Coleção de Ports do FreeBSD fornece vários aplicativos FUSE para suportar muitos outros sistemas de arquivos.</p></div></div><div class=sect2><h3 id=_como_faço_para_montar_uma_partição_secundária_do_dos>8.5. Como faço para montar uma partição secundária do DOS?<a class=anchor href=#_como_faço_para_montar_uma_partição_secundária_do_dos></a></h3><div class=paragraph><p>As partições secundárias do DOS são encontradas depois de <em>todas</em> as partições primárias. Por exemplo, se <code>E</code> for a segunda partição DOS na segunda unidade SCSI, haverá um arquivo de dispositivo para a "slice 5" em <span class=filename>/dev</span>. Para montá-lo:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount -t msdosfs /dev/da1s5 /dos/e</span></code></pre></div></div></div><div class=sect2><h3 id=_existe_um_sistema_de_arquivos_criptográficos_para_o_freebsd>8.6. Existe um sistema de arquivos criptográficos para o FreeBSD?<a class=anchor href=#_existe_um_sistema_de_arquivos_criptográficos_para_o_freebsd></a></h3><div class=paragraph><p>Sim, o <a href="https://man.freebsd.org/cgi/man.cgi?query=gbde&amp;sektion=8&amp;format=html">gbde(8)</a> e o <a href="https://man.freebsd.org/cgi/man.cgi?query=geli&amp;sektion=8&amp;format=html">geli(8)</a>. Consulte a seção <a href=https://docs.freebsd.org/pt-br/books/handbook/book/disks#disks-encrypting>Partições de Disco com Criptografia</a> do Handbook do FreeBSD.</p></div></div><div class=sect2><h3 id=_como_inicializo_o_freebsd_e_o_linux_utilizando_o_grub>8.7. Como inicializo o FreeBSD e o Linux utilizando o GRUB?<a class=anchor href=#_como_inicializo_o_freebsd_e_o_linux_utilizando_o_grub></a></h3><div class=paragraph><p>Para inicializar o FreeBSD usando o GRUB, adicione o seguinte ao <span class=filename>/boot/grub/menu.lst</span> ou ao <span class=filename>/boot/grub/grub.conf</span>, dependendo de qual é usado pela sua distribuição Linux ™.</p></div><div class="literalblock programlisting"><div class=content><pre>title FreeBSD 9.1
	root (hd0,a)
	kernel /boot/loader</pre></div></div><div class=paragraph><p>No qual <em>hd0,a</em> aponta para a partição raiz no primeiro disco. Para especificar o número da slice, use algo como isto <em>(hd0,2,a)</em>. Por padrão, se o número da slice for omitido, o GRUB pesquisará a primeira slice que tiver a partição <code>a</code>.</p></div></div><div class=sect2><h3 id=_como_inicializo_o_freebsd_e_o_linux_usando_o_booteasy>8.8. Como inicializo o FreeBSD e o Linux usando o BootEasy?<a class=anchor href=#_como_inicializo_o_freebsd_e_o_linux_usando_o_booteasy></a></h3><div class=paragraph><p>Instale o LILO no início da partição de inicialização Linux™ em vez de no Master Boot Record. Em seguida, inicialize o LILO a partir do BootEasy.</p></div><div class=paragraph><p>Isto é recomendado ao executar o Windows™ e o Linux™, pois torna mais fácil fazer o Linux™ inicializar novamente se o Windows™ for reinstalado.</p></div></div><div class=sect2><h3 id=_como_faço_para_alterar_o_prompt_de_inicialização_de_para_algo_mais_significativo>8.9. Como faço para alterar o prompt de inicialização de ??? para algo mais significativo?<a class=anchor href=#_como_faço_para_alterar_o_prompt_de_inicialização_de_para_algo_mais_significativo></a></h3><div class=paragraph><p>Isso não pode ser feito com o gerenciador de inicialização padrão sem reescrevê-lo. Há vários outros gerenciadores de inicialização na categoria <span class=filename>sysutils</span> da coleção de ports.</p></div></div><div class=sect2><h3 id=_como_faço_para_usar_uma_nova_unidade_removível>8.10. Como faço para usar uma nova unidade removível?<a class=anchor href=#_como_faço_para_usar_uma_nova_unidade_removível></a></h3><div class=paragraph><p>Se a unidade já tiver um sistema de arquivos, use um comando como este:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount -t msdosfs /dev/da0s1 /mnt</span></code></pre></div></div><div class=paragraph><p>Se a unidade só for usada com sistemas FreeBSD, particione-a com UFS ou ZFS. Isso fornecerá suporte a nomes longos de arquivo, melhoria no desempenho e na estabilidade. Se a unidade for usada por outros sistemas operacionais, uma escolha mais portátil, como por exemplo o msdosfs, será mais apropriada.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dd if=/dev/zero of=/dev/da0 count=2</span>
<span class=c># gpart create -s GPT /dev/da0</span>
<span class=c># gpart add -t freebsd-ufs /dev/da0</span></code></pre></div></div><div class=paragraph><p>Finalmente, crie um novo sistema de arquivos:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># newfs /dev/da0p1</span></code></pre></div></div><div class=paragraph><p>e monte-o:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount /dev/da0s1 /mnt</span></code></pre></div></div><div class=paragraph><p>É uma boa ideia adicionar uma linha ao <span class=filename>/etc/fstab</span> (veja <a href="https://man.freebsd.org/cgi/man.cgi?query=fstab&amp;sektion=5&amp;format=html">fstab(5)</a>) para que você possa digitar apenas <code>mount /mnt</code> no futuro:</p></div><div class="literalblock programlisting"><div class=content><pre>/dev/da0p1 /mnt ufs rw,noauto 0 0</pre></div></div></div><div class=sect2><h3 id=_por_que_recebo_o_erro_incorrect_super_block_ao_montar_um_cd>8.11. Por que recebo o erro Incorrect super block ao montar um CD?<a class=anchor href=#_por_que_recebo_o_erro_incorrect_super_block_ao_montar_um_cd></a></h3><div class=paragraph><p>O tipo de dispositivo a ser montado deve ser especificado. Isso está descrito no Handbook na seção <a href=https://docs.freebsd.org/pt-br/books/handbook/book/disks#mounting-cd>Usando CDs de Dados</a>.</p></div></div><div class=sect2><h3 id=_por_que_recebo_o_erro_device_not_configured_ao_montar_um_cd>8.12. Por que recebo o erro Device not configured ao montar um CD?<a class=anchor href=#_por_que_recebo_o_erro_device_not_configured_ao_montar_um_cd></a></h3><div class=paragraph><p>Isso geralmente significa que não há CD na unidade ou a unidade não está visível no barramento. Consulte a seção <a href=https://docs.freebsd.org/pt-br/books/handbook/book/disks#mounting-cd>Usando CDs de Dados</a> do Handbook para uma discussão detalhada desta questão.</p></div></div><div class=sect2><h3 id=_por_que_todos_os_caracteres_não_ingleses_em_nomes_de_arquivos_aparecem_como_em_meus_cds_quando_montados_no_freebsd>8.13. Por que todos os caracteres não-ingleses em nomes de arquivos aparecem como ? em meus CDs quando montados no FreeBSD?<a class=anchor href=#_por_que_todos_os_caracteres_não_ingleses_em_nomes_de_arquivos_aparecem_como_em_meus_cds_quando_montados_no_freebsd></a></h3><div class=paragraph><p>O CD provavelmente usa a extensão "Joliet" para armazenar informações sobre arquivos e diretórios. Isso é discutido na seção <a href=https://docs.freebsd.org/pt-br/books/handbook/book/disks#mounting-cd>Usando CD-ROMs de Dados</a> do Handbook.</p></div></div><div class=sect2><h3 id=_um_cd_gravado_no_freebsd_não_pode_ser_lido_sob_nenhum_outro_sistema_operacional_por_quê>8.14. Um CD gravado no FreeBSD não pode ser lido sob nenhum outro sistema operacional. Por quê?<a class=anchor href=#_um_cd_gravado_no_freebsd_não_pode_ser_lido_sob_nenhum_outro_sistema_operacional_por_quê></a></h3><div class=paragraph><p>Isso significa que um raw file foi gravado no CD, em vez de criar um sistema de arquivos ISO 9660. Dê uma olhada na seção <a href=https://docs.freebsd.org/pt-br/books/handbook/book/disks#mounting-cd>Usando CDs de Dados</a>.</p></div></div><div class=sect2><h3 id=_como_posso_criar_uma_imagem_de_um_cd_de_dados>8.15. Como posso criar uma imagem de um CD de dados?<a class=anchor href=#_como_posso_criar_uma_imagem_de_um_cd_de_dados></a></h3><div class=paragraph><p>Isso é discutido na seção Handbook sobre <a href=https://docs.freebsd.org/pt-br/books/handbook/book/disks#mkisofs>como gravar dados em um sistema de arquivos ISO</a>. Para mais informações sobre como trabalhar com CD-ROMs, consulte a <a href=https://docs.freebsd.org/pt-br/books/handbook/book/disks#creating-cds>Seção Criando CDs</a> no capítulo sobre Armazenamento do Handbook.</p></div></div><div class=sect2><h3 id=_por_que_não_consigo_usar_o_comando_mount_com_um_cd_de_áudio>8.16. Por que não consigo usar o comando mount com um CD de áudio?<a class=anchor href=#_por_que_não_consigo_usar_o_comando_mount_com_um_cd_de_áudio></a></h3><div class=paragraph><p>Tentar montar um CD de áudio produzirá um erro do tipo <code>cd9660: /dev/cd0: Invalid argument</code>. Isso ocorre porque o comando <code>mount</code> só funciona em sistemas de arquivos. CDs de áudio não possuem sistemas de arquivos; eles têm apenas dados. Em vez disso, use um programa que leia CDs de áudio, como o pacote ou port <a class=package href=https://cgit.freebsd.org/ports/tree/audio/xmcd/>audio/xmcd</a>.</p></div></div><div class=sect2><h3 id=_como_eu_faço_para_usar_o_comando_mount_com_um_cd_multi_sessão>8.17. Como eu faço para usar o comando mount com um CD multi-sessão?<a class=anchor href=#_como_eu_faço_para_usar_o_comando_mount_com_um_cd_multi_sessão></a></h3><div class=paragraph><p>Por padrão, o <a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a> tentará montar a última trilha de dados (sessão) de um CD. Para carregar uma sessão anterior, use o argumento de linha de comando <code>-s</code>. Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=mount_cd9660&amp;sektion=8&amp;format=html">mount_cd9660(8)</a> para exemplos específicos.</p></div></div><div class=sect2><h3 id=_como_posso_permitir_que_usuários_não_privilegiados_montem_cd_roms_dvds_unidades_usb_e_outras_mídias_removíveis>8.18. Como posso permitir que usuários não privilegiados montem CD-ROMs, DVDs, unidades USB e outras mídias removíveis?<a class=anchor href=#_como_posso_permitir_que_usuários_não_privilegiados_montem_cd_roms_dvds_unidades_usb_e_outras_mídias_removíveis></a></h3><div class=paragraph><p>Como <code>root</code>, defina a variável <code>vfs.usermount</code> do sysctl como <code>1</code>.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl vfs.usermount=1</span></code></pre></div></div><div class=paragraph><p>Para tornar o ajuste permanente, adicione a linha <code>vfs.usermount=1</code> ao arquivo <span class=filename>/etc/sysctl.conf</span> para que a variável seja redefinids no momento da inicialização do sistema.</p></div><div class=paragraph><p>Os usuários só podem montar dispositivos para os quais tenham permissões de leitura. Para permitir que os usuários montem um dispositivo, as permissões devem ser definidas em <span class=filename>/etc/devfs.conf</span>.</p></div><div class=paragraph><p>Por exemplo, para permitir que os usuários montem a primeira unidade USB, adicione:</p></div><div class="literalblock programlisting"><div class=content><pre># Allow all users to mount a USB drive.
	    own       /dev/da0       root:operator
	    perm      /dev/da0       0666</pre></div></div><div class=paragraph><p>Todos os usuários agora podem montar dispositivos que eles podem ler em um diretório que eles possuem:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>mkdir</span> ~/my-mount-point
% mount <span class=nt>-t</span> msdosfs /dev/da0 ~/my-mount-point</code></pre></div></div><div class=paragraph><p>Desmontar o dispositivo é simples:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% umount ~/my-mount-point</code></pre></div></div><div class=paragraph><p>Ativar a variável <code>vfs.usermount</code>, no entanto, tem implicações negativas de segurança. Uma maneira melhor de acessar uma mídia formatada para o MS-DOS™ é usar o pacote <a class=package href=https://cgit.freebsd.org/ports/tree/emulators/mtools/>emulators/mtools</a> da Coleção de Ports.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>O nome do dispositivo usado nos exemplos anteriores deve ser alterado de acordo com a configuração.</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=_os_comandos_du_e_df_mostram_informações_diferentes_sobre_a_quantia_disponível_de_espaço_em_disco_o_que_está_acontecendo>8.19. Os comandos du e df mostram informações diferentes sobre a quantia disponível de espaço em disco. O que está acontecendo?<a class=anchor href=#_os_comandos_du_e_df_mostram_informações_diferentes_sobre_a_quantia_disponível_de_espaço_em_disco_o_que_está_acontecendo></a></h3><div class=paragraph><p>Isso se deve ao modo como esses comandos realmente funcionam. O <code>du</code> passa pela árvore de diretórios, ele mede o tamanho de cada arquivo e apresenta os totais. O <code>df</code> apenas pergunta ao sistema de arquivos quanto espaço ainda resta. Eles parecem ser a mesma coisa, mas um arquivo sem uma entrada de diretório afetará <code>df</code> mas não <code>du</code>.</p></div><div class=paragraph><p>Quando um programa está usando um arquivo e o arquivo é excluído, o arquivo não é realmente removido do sistema de arquivos até que o programa pare de usá-lo. O arquivo é imediatamente excluído da listagem do diretório, no entanto. Como exemplo, considere um arquivo grande o suficiente para afetar a saída de <code>du</code> e <code>df</code>. Um arquivo sendo visualizado com <code>more</code> pode ser excluído sem causar um erro. A entrada é removida do diretório para que nenhum outro programa ou usuário possa acessá-la. No entanto, o <code>du</code> mostra que ele desapareceu, já que percorreu a árvore de diretórios e o arquivo não está mais listado. Já o <code>df</code> mostra que ele ainda está lá, pois o sistema de arquivos sabe que o comando <code>more</code> ainda está usando esse espaço. Quando a sessão do <code>more</code> terminar, o <code>du</code> e <code>df</code> apresentarão o mesmo resultado.</p></div><div class=paragraph><p>Essa situação é comum em servidores web. Muitas pessoas configuram um servidor web no FreeBSD e esquecem de rotacionar os arquivos de log. O log de acesso enche o <span class=filename>/var</span>. O administrador novato exclui o arquivo, mas o sistema ainda reclama que a partição está cheia. Parar e reiniciar o programa do servidor Web liberaria o arquivo, permitindo que o sistema liberasse o espaço em disco. Para evitar que isso aconteça, configure o <a href="https://man.freebsd.org/cgi/man.cgi?query=newsyslog&amp;sektion=8&amp;format=html">newsyslog(8)</a>.</p></div><div class=paragraph><p>Observe que o Soft Updates pode atrasar a liberação de espaço em disco e pode levar até 30 segundos para que a alteração fique visível.</p></div></div><div class=sect2><h3 id=_como_posso_adicionar_mais_espaço_de_swap>8.20. Como posso adicionar mais espaço de swap?<a class=anchor href=#_como_posso_adicionar_mais_espaço_de_swap></a></h3><div class=paragraph><p>Esta seção <a href=https://docs.freebsd.org/pt-br/books/handbook/book/config-tuning#adding-swap-space>do Handbook</a> descreve como fazer isso.</p></div></div><div class=sect2><h3 id=_por_que_o_freebsd_vê_meu_disco_como_sendo_menor_do_que_o_fabricante_diz_que_ele_é>8.21. Por que o FreeBSD vê meu disco como sendo menor do que o fabricante diz que ele é?<a class=anchor href=#_por_que_o_freebsd_vê_meu_disco_como_sendo_menor_do_que_o_fabricante_diz_que_ele_é></a></h3><div class=paragraph><p>Os fabricantes de discos calculam gigabytes como um bilhão de bytes cada, enquanto o FreeBSD os calcula como 1.073.741.824 bytes cada. Isso explica por que, por exemplo, as mensagens de boot do FreeBSD reportarão um disco que supostamente tem 80 GB como contendo 76.319 MB.</p></div><div class=paragraph><p>Observe também que o FreeBSD irá (por padrão) <a href=#disk-more-than-full>reservar</a> cerca de 8% do espaço em disco.</p></div></div><div class=sect2><h3 id=_como_é_possível_que_uma_partição_esteja_com_mais_de_100_de_ocupação>8.22. Como é possível que uma partição esteja com mais de 100% de ocupação?<a class=anchor href=#_como_é_possível_que_uma_partição_esteja_com_mais_de_100_de_ocupação></a></h3><div class=paragraph><p>Uma parte de cada partição UFS (8%, por padrão) é reservada para uso pelo sistema operacional e pelo usuário <code>root</code>. O <a href="https://man.freebsd.org/cgi/man.cgi?query=df&amp;sektion=1&amp;format=html">df(1)</a> não contabiliza esse espaço ao calcular a coluna <code>Capacity</code>, portanto, ela pode exceder 100%. Observe que a coluna <code>Blocks</code> é sempre maior que a soma das colunas <code>Used</code> e <code>Avail</code>, geralmente por um fator de 8%.</p></div><div class=paragraph><p>Para mais detalhes, procure prls opção <code>-m</code> em <a href="https://man.freebsd.org/cgi/man.cgi?query=tunefs&amp;sektion=8&amp;format=html">tunefs(8)</a>.</p></div></div></div></div><div class=sect1><h2 id=_zfs>9. ZFS<a class=anchor href=#_zfs></a></h2><div class=sectionbody><div class=sect2><h3 id=_qual_é_a_quantidade_mínima_de_ram_que_um_usuário_deve_ter_para_utilizar_o_zfs>9.1. Qual é a quantidade mínima de RAM que um usuário deve ter para utilizar o ZFS?<a class=anchor href=#_qual_é_a_quantidade_mínima_de_ram_que_um_usuário_deve_ter_para_utilizar_o_zfs></a></h3><div class=paragraph><p>É necessário um mínimo de 4 GB de RAM para uso confortável, mas as cargas de trabalho individuais podem variar muito.</p></div></div><div class=sect2><h3 id=_o_que_é_o_zil_e_quando_ele_é_usado>9.2. O que é o ZIL e quando ele é usado?<a class=anchor href=#_o_que_é_o_zil_e_quando_ele_é_usado></a></h3><div class=paragraph><p>O ZIL (log de intenção do ZFS ) é um log de gravação usado para implementar semânticas de compromisso de escrita posix entre travamentos. Normalmente, as gravações são agrupadas em grupos de transações e gravadas no disco quando preenchidas ("Transaction Group Commit "). No entanto, syscalls como <a href="https://man.freebsd.org/cgi/man.cgi?query=fsync&amp;sektion=2&amp;format=html">fsync(2)</a> requerem um compromisso de que os dados são gravados no armazenamento estável antes de retornar. O ZIL é necessário para gravações que foram reconhecidas como gravadas, mas que ainda não estão no disco como parte de uma transação. Os grupos de transações contam com registro de data e hora. No caso de uma falha, o último registro de data e hora válido é encontrado e os dados ausentes são mesclados a partir do ZIL.</p></div></div><div class=sect2><h3 id=_preciso_de_um_ssd_para_o_zil>9.3. Preciso de um SSD para o ZIL?<a class=anchor href=#_preciso_de_um_ssd_para_o_zil></a></h3><div class=paragraph><p>Por padrão, o ZFS armazena o ZIL no pool com todos os demais dados. Se um aplicativo tiver uma carga de gravação pesada, o armazenamento do ZIL em um dispositivo separado e que tenha um desempenho de gravação sequencial síncrono muito rápido pode melhorar a performance do sistema de uma forma geral. Para outras cargas de trabalho, é improvável que um SSD consiga uma melhoria significativa.</p></div></div><div class=sect2><h3 id=_o_que_é_o_l2arc>9.4. O que é o L2ARC?<a class=anchor href=#_o_que_é_o_l2arc></a></h3><div class=paragraph><p>O L2ARC é um cache de leitura armazenado em um dispositivo rápido, como um SSD. Esse cache não é persistente nas reinicializações. Observe que a RAM é usada como a primeira camada de cache e o L2ARC só é necessário se a quantidade de memória RAM for insuficiente.</p></div><div class=paragraph><p>O L2ARC precisa de espaço no ARC para indexá-lo. Então, perversamente, um conjunto de trabalho que se encaixa perfeitamente no ARC não se encaixará mais perfeitamente se um L2ARC for usado porque parte do ARC estará mantendo o índice L2ARC, empurrando parte do conjunto de trabalho para o L2ARC que é mais lento que a RAM.</p></div></div><div class=sect2><h3 id=_a_ativação_da_funcionalidade_de_desduplicação_é_recomendável>9.5. A ativação da funcionalidade de desduplicação é recomendável?<a class=anchor href=#_a_ativação_da_funcionalidade_de_desduplicação_é_recomendável></a></h3><div class=paragraph><p>De um modo geral, não.</p></div><div class=paragraph><p>A deduplicação ocupa uma quantidade significativa de RAM e pode tornar mais lento os tempos de acesso ao disco para leitura e gravação. A menos que um esteja armazenando dados muito duplicados, como imagens de máquinas virtuais ou backups de usuários, é possível que a deduplicação faça mais mal do que bem. Outra consideração é a incapacidade de reverter o status da deduplicação. Se os dados forem gravados quando a deduplicação estiver ativada, desabilitar a deduplicação não fará com que os blocos deduplicados sejam replicados até que sejam modificados em novamente.</p></div><div class=paragraph><p>A deduplicação também pode levar há algumas situações inesperadas. Em particular, a exclusão de arquivos pode se tornar muito mais lenta.</p></div></div><div class=sect2><h3 id=_não_consigo_excluir_ou_criar_arquivos_no_meu_pool_do_zfs_como_posso_consertar_isso>9.6. Não consigo excluir ou criar arquivos no meu pool do ZFS. Como posso consertar isso?<a class=anchor href=#_não_consigo_excluir_ou_criar_arquivos_no_meu_pool_do_zfs_como_posso_consertar_isso></a></h3><div class=paragraph><p>Isso pode acontecer porque o pool está 100% cheio. O ZFS requer espaço no disco para gravar metadados de transação. Para restaurar o pool para um estado utilizável, primeiro faça o truncate do arquivo que irá excluir:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>truncate</span> <span class=nt>-s</span> 0 unimportant-file</code></pre></div></div><div class=paragraph><p>O truncamento de arquivo funciona porque uma nova transação não é iniciada, novos blocos de reserva são criados.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Em sistemas que utilizam o ZFS com um dataset customizado, por exemplo com a funcionalidade de deduplicação ativada, o espaço pode não ficar disponível imediatamente</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=_o_zfs_suporta_trim_para_unidades_de_estado_sólido>9.7. O ZFS suporta TRIM para unidades de estado sólido?<a class=anchor href=#_o_zfs_suporta_trim_para_unidades_de_estado_sólido></a></h3><div class=paragraph><p>O suporte ao ZFS TRIM foi adicionado ao FreeBSD 10-CURRENT com revisão r<a href=https://svnweb.freebsd.org/changeset/base/240868>r240868</a>. O suporte ao ZFS TRIM foi adicionado a todas as branchs do FreeBSD-STABLE na revisão r<a href=https://svnweb.freebsd.org/changeset/base/252162>r252162</a> e r<a href=https://svnweb.freebsd.org/changeset/base/251419>r251419</a>, respectivamente.</p></div><div class=paragraph><p>O ZFS TRIM é ativado por padrão e pode ser desativado adicionando-se esta linha ao arquivo <span class=filename>/etc/sysctl.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>vfs.zfs.trim.enabled=0</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>O suporte ao ZFS TRIM foi adicionado ao GELI em r<a href=https://svnweb.freebsd.org/changeset/base/286444>r286444</a>. Por favor, veja <a href="https://man.freebsd.org/cgi/man.cgi?query=geli&amp;sektion=8&amp;format=html">geli(8)</a> e a opção <code>-T</code>.</p></div></td></tr></tbody></table></div></div></div></div><div class=sect1><h2 id=_administração_do_sistema>10. Administração do Sistema<a class=anchor href=#_administração_do_sistema></a></h2><div class=sectionbody><div class=sect2><h3 id=_onde_estão_os_arquivos_de_configuração_de_inicialização_do_sistema>10.1. Onde estão os arquivos de configuração de inicialização do sistema?<a class=anchor href=#_onde_estão_os_arquivos_de_configuração_de_inicialização_do_sistema></a></h3><div class=paragraph><p>O arquivo de configuração principal é o <span class=filename>/etc/defaults/rc.conf</span>, o qual está descrito em <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a>. Os scripts de inicialização do sistema, tais como <span class=filename>/etc/rc</span> e <span class=filename>/etc/rc.d</span>, que são descritos em <a href="https://man.freebsd.org/cgi/man.cgi?query=rc&amp;sektion=8&amp;format=html">rc(8)</a>, incluem este arquivo. <em>Não edite este arquivo!</em> Em vez disso, para editar uma entrada do <span class=filename>/etc/default/rc.conf</span>, copie a linha para o arquivo <span class=filename>/etc/rc.conf</span> e altere-a lá.</p></div><div class=paragraph><p>Por exemplo, se para iniciar <a href="https://man.freebsd.org/cgi/man.cgi?query=named&amp;sektion=8&amp;format=html">named(8)</a>, o servidor DNS incluído:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># echo &#39;named_enable=&#34;YES&#34;&#39; &gt;&gt; /etc/rc.conf</span></code></pre></div></div><div class=paragraph><p>Para iniciar serviços locais, coloque seus shell scripts no diretório <span class=filename>/usr/local/etc/rc.d</span>. Estes shell scripts devem estar definidos como executáveis, o modo de arquivo padrão é <code>555</code>.</p></div></div><div class=sect2><h3 id=_como_eu_adiciono_um_usuário_facilmente>10.2. Como eu adiciono um usuário facilmente?<a class=anchor href=#_como_eu_adiciono_um_usuário_facilmente></a></h3><div class=paragraph><p>Use o comando <a href="https://man.freebsd.org/cgi/man.cgi?query=adduser&amp;sektion=8&amp;format=html">adduser(8)</a>, para as situações mais complexas utilize o comando <a href="https://man.freebsd.org/cgi/man.cgi?query=pw&amp;sektion=8&amp;format=html">pw(8)</a>.</p></div><div class=paragraph><p>Para remover o usuário, use o comando <a href="https://man.freebsd.org/cgi/man.cgi?query=rmuser&amp;sektion=8&amp;format=html">rmuser(8)</a> ou, se necessário, o comando <a href="https://man.freebsd.org/cgi/man.cgi?query=pw&amp;sektion=8&amp;format=html">pw(8)</a>.</p></div></div><div class=sect2><h3 id=_por_que_eu_continuo_recebendo_mensagens_como_root_not_found_depois_de_editar_o_arquivo_etccrontab>10.3. Por que eu continuo recebendo mensagens como root: not found depois de editar o arquivo /etc/crontab?<a class=anchor href=#_por_que_eu_continuo_recebendo_mensagens_como_root_not_found_depois_de_editar_o_arquivo_etccrontab></a></h3><div class=paragraph><p>Isto normalmente é causado pela edição do crontab do sistema. Esta não é a maneira correta de fazer as coisas, pois o crontab do sistema tem um formato diferente dos crontabs por usuário. O crontab do sistema possui um campo extra, especificando qual usuário irá executar o comando. O <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a> assume que este usuário é a primeira palavra do comando a ser executado. Como esse comando não existe, essa mensagem de erro é exibida.</p></div><div class=paragraph><p>Para excluir o crontab extra incorreto:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># crontab -r</span></code></pre></div></div></div><div class=sect2><h3 id=_por_que_eu_recebo_o_erro_you_are_not_in_the_correct_group_to_su_root_quando_tento_executar_o_comando_su_para_o_usuário_root>10.4. Por que eu recebo o erro, you are not in the correct group to su root quando tento executar o comando su para o usuário root ?<a class=anchor href=#_por_que_eu_recebo_o_erro_you_are_not_in_the_correct_group_to_su_root_quando_tento_executar_o_comando_su_para_o_usuário_root></a></h3><div class=paragraph><p>Este é um recurso de segurança. Para executar <code>su</code> para <code>root</code>, ou qualquer outra conta com privilégios de superusuário, a conta do usuário deve ser um membro do grupo <code>wheel</code>. Se este recurso não estivesse lá, qualquer pessoa com uma conta em um sistema e que também descobrisse a senha do <code>root</code> seria capaz de obter acesso de nível de superusuário ao sistema.</p></div><div class=paragraph><p>Para permitir que alguém execute o comando <code>su root</code>, coloque-os no grupo <code>wheel</code> usando o comando <code>pw</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pw groupmod wheel -m lisa</span></code></pre></div></div><div class=paragraph><p>O exemplo acima adicionará o usuário <code>lisa</code> ao grupo <code>wheel</code>.</p></div></div><div class=sect2><h3 id=_cometi_um_erro_no_rc_conf_ou_outro_arquivo_de_inicialização_e_agora_não_posso_editá_lo_porque_o_sistema_de_arquivos_está_montado_somente_leitura_o_que_devo_fazer>10.5. Cometi um erro no rc.conf, ou outro arquivo de inicialização, e agora não posso editá-lo porque o sistema de arquivos está montado somente leitura. O que devo fazer?<a class=anchor href=#_cometi_um_erro_no_rc_conf_ou_outro_arquivo_de_inicialização_e_agora_não_posso_editá_lo_porque_o_sistema_de_arquivos_está_montado_somente_leitura_o_que_devo_fazer></a></h3><div class=paragraph><p>Reinicie o sistema usando <code>boot -s</code> no prompt do loader para entrar no modo single user. Quando o sistema solicitar o caminho do shell, apenas pressione <kbd>Enter</kbd> e execute <code>mount -urw /</code> para remontar novamente o sistema de arquivos raiz no modo de leitura e gravação. Você também pode precisar executar o comando <code>mount -a -t ufs</code> para montar o sistema de arquivos no qual seu editor favorito é mantido. Se esse editor estiver em um sistema de arquivos de rede, configure a rede manualmente antes de montar os sistemas de arquivos de rede ou use um editor que resida em um sistema de arquivos local, tal como o <a href="https://man.freebsd.org/cgi/man.cgi?query=ed&amp;sektion=1&amp;format=html">ed(1)</a>.</p></div><div class=paragraph><p>Para usar um editor de tela inteira, tal como o <a href="https://man.freebsd.org/cgi/man.cgi?query=vi&amp;sektion=1&amp;format=html">vi(1)</a> ou <a href="https://man.freebsd.org/cgi/man.cgi?query=emacs&amp;sektion=1&amp;format=html">emacs(1)</a>, execute <code>export TERM=xterm</code> para que esses editores possam carregar os dados corretos do banco de dados do <a href="https://man.freebsd.org/cgi/man.cgi?query=termcap&amp;sektion=5&amp;format=html">termcap(5)</a>.</p></div><div class=paragraph><p>Depois de executar estas etapas, edite o arquivo <span class=filename>/etc/rc.conf</span> para corrigir o erro de sintaxe. A mensagem de erro exibida imediatamente após as mensagens de inicialização do kernel deve indicar o número da linha no arquivo que está com erro.</p></div></div><div class=sect2><h3 id=_por_que_estou_tendo_problemas_para_configurar_minha_impressora>10.6. Por que estou tendo problemas para configurar minha impressora?<a class=anchor href=#_por_que_estou_tendo_problemas_para_configurar_minha_impressora></a></h3><div class=paragraph><p>Consulte a seção sobre <a href=https://docs.freebsd.org/pt-br/books/handbook/book/printing#printing>impressão</a> no Handbook do FreeBSD para dicas de soluções de problemas.</p></div></div><div class=sect2><h3 id=_como_posso_corrigir_os_mapeamentos_de_teclado_para_o_meu_sistema>10.7. Como posso corrigir os mapeamentos de teclado para o meu sistema?<a class=anchor href=#_como_posso_corrigir_os_mapeamentos_de_teclado_para_o_meu_sistema></a></h3><div class=paragraph><p>Consulte a seção <a href=https://docs.freebsd.org/pt-br/books/handbook/book/l10n#using-localization>usando localização</a> do Handbook, mais especificamente a seção sobre a <a href=https://docs.freebsd.org/pt-br/books/handbook/book/l10n#setting-console>configuração do console</a>.</p></div></div><div class=sect2><h3 id=_por_que_não_consigo_colocar_as_quotas_de_usuários_para_funcionar_corretamente>10.8. Por que não consigo colocar as quotas de usuários para funcionar corretamente?<a class=anchor href=#_por_que_não_consigo_colocar_as_quotas_de_usuários_para_funcionar_corretamente></a></h3><div class="olist arabic"><ol class=arabic><li><p>É possível que o kernel não esteja configurado para usar quotas. Neste caso, adicione a seguinte linha ao arquivo de configuração do kernel e recompile o kernel:</p><div class="literalblock programlisting"><div class=content><pre>options QUOTA</pre></div></div><div class=paragraph><p>Consulte a<a href=https://docs.freebsd.org/pt-br/books/handbook/book/disks#quotas>seção do Handbook sobre quotas</a> para obter detalhes completos.</p></div></li><li><p>Não ative o uso de quotas na partição <span class=filename>/</span>.</p></li><li><p>Coloque o arquivo de quotas no sistema de arquivos para o qual quotas precisam ser aplicadas:</p><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Sistema de arquivo</th><th class="tableblock halign-left valign-top">Arquivo de quota</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/admin/quotas</span></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/home</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/home/admin/quotas</span></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>…​</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>…​</p></td></tr></tbody></table></li></ol></div></div><div class=sect2><h3 id=_o_freebsd_suporta_system_v_ipc_primitives>10.9. O FreeBSD suporta System V IPC primitives?<a class=anchor href=#_o_freebsd_suporta_system_v_ipc_primitives></a></h3><div class=paragraph><p>Sim, o FreeBSD suporta o IPC no estilo do System V, incluindo memória compartilhada, mensagens e semáforos, no kernel <span class=filename>GENERIC</span>. Em um kernel personalizado, o suporte pode ser por meio do carregamento dos módulos de kernel <span class=filename>sysvshm.ko</span>, <span class=filename>sysvsem.ko</span> e <span class=filename>sysvmsg.ko</span>, ou habilitado de forma estática no kernel personalizado adicionando as seguintes linhas ao arquivo de configuração do mesmo:</p></div><div class="literalblock programlisting"><div class=content><pre>options    SYSVSHM          # enable shared memory
options    SYSVSEM          # enable for semaphores
options    SYSVMSG          # enable for messaging</pre></div></div><div class=paragraph><p>Recompile e instale o kernel.</p></div></div><div class=sect2><h3 id=_qual_outro_software_de_servidor_de_correio_posso_usar_em_substituição_ao_sendmail>10.10. Qual outro software de servidor de correio posso usar em substituição ao Sendmail?<a class=anchor href=#_qual_outro_software_de_servidor_de_correio_posso_usar_em_substituição_ao_sendmail></a></h3><div class=paragraph><p>O servidor <a href=http://www.sendmail.org/>Sendmail </a>é o software de servidor de email padrão do FreeBSD, mas pode ser substituído por outro MTA instalado a partir da coleção de ports. Os ports disponíveis incluem o <a class=package href=https://cgit.freebsd.org/ports/tree/mail/exim/>mail/exim</a>, o <a class=package href=https://cgit.freebsd.org/ports/tree/mail/postfix/>mail/postfix</a> e o <a class=package href=https://cgit.freebsd.org/ports/tree/mail/qmail/>mail/qmail</a>. Procure informações nas listas de discussão sobre as vantagens e desvantagens dos MTAs disponíveis.</p></div></div><div class=sect2><h3 id=_esqueci_a_senha_do_root_o_que_eu_faço>10.11. Esqueci a senha do root! O que eu faço?<a class=anchor href=#_esqueci_a_senha_do_root_o_que_eu_faço></a></h3><div class=paragraph><p>Não entre em pânico! Reinicie o sistema, digite <code>boot -s</code> no prompt <code>Boot:</code> para entrar no modo single user. Na pergunta sobre o shell a ser usado, pressione <kbd>Enter</kbd>, que será exibido um prompt <code>#</code>. Insira o comando <code>mount -urw /</code> para remontar o sistema de arquivos raiz no modo de leitura e gravação e, em seguida, execute o comando <code>mount -a</code> para remontar todos os sistemas de arquivos. Execute o comando <code>passwd root</code> para alterar a senha do usuário <code>root</code> e então execute o comando <a href="https://man.freebsd.org/cgi/man.cgi?query=exit&amp;sektion=1&amp;format=html">exit(1)</a> para continuar a inicialização.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Se você ainda for solicitado a entrar com a senha do usuário <code>root</code> ao entrar no modo single user único, isso significa que o console foi configurado como <code>inseguro</code> no arquivo <span class=filename>/etc/ttys</span>. Neste caso, será necessário inicializar a partir de um disco de instalação do FreeBSD, escolher o <span class=guimenuitem>Live CD</span> ou <span class=guimenuitem>Shell</span> no início do processo de instalação e executar os comandos mencionados acima. Monte a partição específica neste caso e, em seguida, execute o chroot para ela. Por exemplo, substitua <code>mount -urw /</code> por <code>mount /dev/ada0p1 /mnt; chroot /mnt</code> para um sistema em instalado em <em>ada0p1</em>.</p></div></td></tr></tbody></table></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Se a partição raiz não puder ser montada a partir do modo de usuário único, é possível que as partições estejam criptografadas e será impossível montá-las sem as chaves de acesso. Para obter mais informações, consulte a seção sobre discos criptografados no <a href=https://docs.freebsd.org/pt-br/books/handbook/book/disks#disks-encrypting>Handbook</a> do FreeBSD.</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=_como_evito_que_a_combinação_de_teclas_controlaltdelete_reinicialize_o_sistema>10.12. Como evito que a combinação de teclas ControlAltDelete reinicialize o sistema?<a class=anchor href=#_como_evito_que_a_combinação_de_teclas_controlaltdelete_reinicialize_o_sistema></a></h3><div class=paragraph><p>Ao usar <a href="https://man.freebsd.org/cgi/man.cgi?query=vt&amp;sektion=4&amp;format=html">vt(4)</a>, o driver de console padrão, isso pode ser feito configurando o seguinte sysctl <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl kern.vt.kbd_reboot=0</span></code></pre></div></div></div><div class=sect2><h3 id=_como_faço_para_converter_arquivos_de_texto_do_dos_para_unix>10.13. Como faço para converter arquivos de texto do DOS para UNIX?<a class=anchor href=#_como_faço_para_converter_arquivos_de_texto_do_dos_para_unix></a></h3><div class=paragraph><p>Use este comando <a href="https://man.freebsd.org/cgi/man.cgi?query=perl&amp;sektion=1&amp;format=html">perl(1)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% perl <span class=nt>-i</span>.bak <span class=nt>-npe</span> <span class=s1>&#39;s/\r\n/\n/g&#39;</span> file<span class=o>(</span>s<span class=o>)</span></code></pre></div></div><div class=paragraph><p>no qual <em>files(s)</em> trata-se de um ou mais arquivos que desejamos processar. A modificação é feita in-place, o arquivo original é preservado com uma extensão <span class=filename>.bak</span>.</p></div><div class=paragraph><p>Alternativamente, use o <a href="https://man.freebsd.org/cgi/man.cgi?query=tr&amp;sektion=1&amp;format=html">tr(1)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>tr</span> <span class=nt>-d</span> <span class=s1>&#39;\r&#39;</span> &lt; dos-text-file <span class=o>&gt;</span> unix-file</code></pre></div></div><div class=paragraph><p>O <em>dos-text-file</em> é o arquivo que contém o texto no formato DOS, enquanto o <em>unix-file</em> contém a saída convertida. Esta opção pode ser um pouco mais rápida do que usar o <code>perl</code>.</p></div><div class=paragraph><p>Uma outra maneira de reformatar arquivos de texto do DOS é usar o port <a class=package href=https://cgit.freebsd.org/ports/tree/converters/dosunix/>converters/dosunix</a> da Coleção de Ports. Consulte a sua documentação para maiores detalhes.</p></div></div><div class=sect2><h3 id=_como_faço_para_reler_o_arquivo_etcrc_conf_e_reiniciar_o_etcrc_sem_dar_boot>10.14. Como faço para reler o arquivo /etc/rc.conf e reiniciar o /etc/rc sem dar boot?<a class=anchor href=#_como_faço_para_reler_o_arquivo_etcrc_conf_e_reiniciar_o_etcrc_sem_dar_boot></a></h3><div class=paragraph><p>Entre no modo single user e retorne ao modo multi usuário:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># shutdown now</span>
<span class=c># return</span>
<span class=c># exit</span></code></pre></div></div></div><div class=sect2><h3 id=_tentei_atualizar_o_meu_sistema_para_a_versão_stable_mais_recente_mas_obtive_a_betax_rc_ou_prerelease_o_que_está_acontecendo>10.15. Tentei atualizar o meu sistema para a versão -STABLE mais recente, mas obtive a -BETAx, -RC ou -PRERELEASE! O que está acontecendo?<a class=anchor href=#_tentei_atualizar_o_meu_sistema_para_a_versão_stable_mais_recente_mas_obtive_a_betax_rc_ou_prerelease_o_que_está_acontecendo></a></h3><div class=paragraph><p>Resposta curta: é apenas um nome. <em>RC</em> significa "Release Candidate". Isso significa que uma nova release é iminente. No FreeBSD, <em>-PRERELEASE</em> é tipicamente sinônimo do congelamento de código antes de uma release. (Para algumas versões, o rótulo <em>-BETA</em> foi usado da mesma forma que o <em>-PRERELEASE</em>.)</p></div><div class=paragraph><p>Resposta longa: o FreeBSD deriva suas releases de um de dois lugares. Releases principais (major) ponto-zero, como a 9.0-RELEASE são derivadas a partir do branch principal de desenvolvimento, comumente referida como <a href=#current>-CURRENT</a>. Releases secundárias (minor), como a 6.3-RELEASE ou a 5.2-RELEASE, foram snapshots da branch <a href=#stable>-STABLE</a> ativa. A partir do 4.3-RELEASE, cada release também tem sua própria branch, a qual pode ser seguida por pessoas que exigem uma taxa extremamente conservadora de desenvolvimento (geralmente apenas avisos de segurança).</p></div><div class=paragraph><p>Quando um release está prestes a ser feito, o branch do qual ele será derivado tem que passar por um determinado processo. Parte desse processo é um congelamento de código. Quando um congelamento de código é iniciado, o nome da branch é alterado para refletir que está prestes a se tornar uma release. Por exemplo, se a ramificação costumava ser chamada de 6.2-STABLE, seu nome será alterado para 6.3-PRERELEASE para indicar o congelamento de código e indicar que testes extras de pré-release devem estar acontecendo. Correções de bugs ainda podem ser adicionadas ao repositório de código fonte para fazer parte da release. Quando o código-fonte estiver estabilizado para a release, o nome será alterado para 6.3-RC para indicar que uma release está prestes a ser feita a partir dele. Uma vez no estágio RC, somente os bugs mais críticos que forem encontrados podem ser corrigidos. Uma vez que o release (6.3-RELEASE neste exemplo) e o branch de release foram feitos, o branch será renomeado para 6.3-STABLE.</p></div><div class=paragraph><p>Para mais informações sobre números de versão e as várias branches do Subversion, consulte o artigo <a href=https://docs.freebsd.org/pt-br/articles/releng/>Release Engineering</a>.</p></div></div><div class=sect2><h3 id=_tentei_instalar_um_novo_kernel_e_o_chflags1_falhou_como_faço_para_contornar_isso>10.16. Tentei instalar um novo kernel, e o chflags1 falhou. Como faço para contornar isso?<a class=anchor href=#_tentei_instalar_um_novo_kernel_e_o_chflags1_falhou_como_faço_para_contornar_isso></a></h3><div class=paragraph><p>Resposta curta: o nível de segurança é maior que 0. Reinicialize diretamente para o modo de single user para instalar o kernel.</p></div><div class=paragraph><p>Resposta longa: O FreeBSD não permite alterar os flags do sistema em níveis de segurança superiores a 0. Para verificar o nível de segurança atual:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl kern.securelevel</span></code></pre></div></div><div class=paragraph><p>O nível de segurança não pode ser diminuído no modo multiusuário, portanto, inicialize no modo single user para instalar o kernel ou altere o nível de segurança em <span class=filename>/etc/rc.conf</span> e reinicialize. Veja a página de manual <a href="https://man.freebsd.org/cgi/man.cgi?query=init&amp;sektion=8&amp;format=html">init(8)</a> para detalhes sobre o <code>securelevel</code>, e veja <span class=filename>/etc/defaults/rc .conf</span> e a página de manual <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a> para mais informações sobre o <span class=filename>rc.conf</span>.</p></div></div><div class=sect2><h3 id=_não_consigo_alterar_a_hora_no_meu_sistema_em_mais_de_um_segundo_como_faço_para_contornar_isso>10.17. Não consigo alterar a hora no meu sistema em mais de um segundo! Como faço para contornar isso?<a class=anchor href=#_não_consigo_alterar_a_hora_no_meu_sistema_em_mais_de_um_segundo_como_faço_para_contornar_isso></a></h3><div class=paragraph><p>Resposta curta: o sistema está em um nível de segurança maior que 1. Reinicialize diretamente para o modo de single user para alterar a data.</p></div><div class=paragraph><p>Resposta longa: O FreeBSD proíbe a alteração do tempo em mais de um segundo em níveis de segurança superiores a 1. Para verificar o nível de segurança:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl kern.securelevel</span></code></pre></div></div><div class=paragraph><p>O nível de segurança não pode ser diminuído no modo multiusuário. Inicialize no modo single user para alterar a data ou altere o nível de segurança no arquivo <span class=filename>/etc/rc.conf</span> e reinicialize. Veja a página de manual <a href="https://man.freebsd.org/cgi/man.cgi?query=init&amp;sektion=8&amp;format=html">init(8)</a> para detalhes sobre o <code>securelevel</code>, e veja <span class=filename>/etc/defaults/rc .conf</span> e a página de manual <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a> para mais informações sobre o <span class=filename>rc.conf</span>.</p></div></div><div class=sect2><h3 id=_por_que_o_rpc_statd_está_usando_256_mb_de_memória>10.18. Por que o rpc.statd está usando 256 MB de memória?<a class=anchor href=#_por_que_o_rpc_statd_está_usando_256_mb_de_memória></a></h3><div class=paragraph><p>Não, não há vazamento de memória e ele não está usando 256 MB de memória. Por conveniência, o <code>rpc.statd</code> mapeia uma quantidade obscena de memória em seu espaço de endereço. Não há nada terrivelmente errado com isso do ponto de vista técnico; mas isso confunde o <a href="https://man.freebsd.org/cgi/man.cgi?query=top&amp;sektion=1&amp;format=html">top(1)</a> e o <a href="https://man.freebsd.org/cgi/man.cgi?query=ps&amp;sektion=1&amp;format=html">ps(1)</a>.</p></div><div class=paragraph><p>O <a href="https://man.freebsd.org/cgi/man.cgi?query=rpc.statd&amp;sektion=8&amp;format=html">rpc.statd(8)</a> mapeia seu arquivo de status (residente no <span class=filename>/var</span>) em seu espaço de endereçamento; para evitar se preocupar com o remapeamento do arquivo de status mais tarde quando ele precisar crescer, ele mapeia o arquivo de status com um tamanho generoso. Isso é muito evidente no código-fonte, onde é possível ver que o argumento length para o <a href="https://man.freebsd.org/cgi/man.cgi?query=mmap&amp;sektion=2&amp;format=html">mmap(2)</a> é <code>0x10000000</code> , ou décima sexta parte do espaço de endereço em um IA32, ou seja, exatamente 256 MB.</p></div></div><div class=sect2><h3 id=_por_que_não_posso_dar_unset_na_flag_schg_de_um_arquivo>10.19. Por que não posso dar unset na flag schg de um arquivo?<a class=anchor href=#_por_que_não_posso_dar_unset_na_flag_schg_de_um_arquivo></a></h3><div class=paragraph><p>O sistema está sendo executado em um nível de segurança maior que 0. Reduza o nível de segurança e tente novamente. Para obter mais informações, consulte <a href=#securelevel>a entrada do FAQ referente ao securelevel</a> e a página de manual do <a href="https://man.freebsd.org/cgi/man.cgi?query=init&amp;sektion=8&amp;format=html">init(8)</a>.</p></div></div><div class=sect2><h3 id=_o_que_é_vnlru>10.20. O que é vnlru?<a class=anchor href=#_o_que_é_vnlru></a></h3><div class=paragraph><p>O <code>vnlru</code> descarrega e libera vnodes quando o sistema atinge o limite de <code>kern.maxvnodes</code>. Essa thread do kernel fica ociosa na maior parte do tempo e só é ativada quando existe uma quantidade enorme de RAM e os usuários estiverem acessando dezenas de milhares de arquivos minúsculos.</p></div></div><div class=sect2><h3 id=_o_que_os_vários_estados_de_memória_exibidos_pelo_top_significam>10.21. O que os vários estados de memória exibidos pelo top significam?<a class=anchor href=#_o_que_os_vários_estados_de_memória_exibidos_pelo_top_significam></a></h3><div class=ulist><ul><li><p><code>Active</code>: são páginas usadas recentemente.</p></li><li><p><code>Inactive</code>: são páginas que não foram utilizadas recentemente.</p></li><li><p><code>Laundry</code>: páginas recentemente não utilizadas estatisticamente, mas conhecidas por estarem sujas, ou seja, cujo conteúdo precisa ser paginado antes que possa ser reutilizado.</p></li><li><p><code>Free</code>: páginas sem conteúdo, que podem ser reutilizadas imediatamente.</p></li><li><p><code>Wired</code>: são páginas que estão fixadas na memória, geralmente para propósitos do kernel, mas também para uso especial em processos.</p></li></ul></div><div class=paragraph><p>As páginas geralmente são gravadas em disco (um tipo de sincronização de VM) quando elas estão no estado laundry, mas as páginas ativas ou inativas também podem ser sincronizadas. Isso depende do rastreamento da CPU do bit modificado estar disponível e, em determinadas situações pode haver uma vantagem para um bloco de páginas da VM serem sincronizadas, independentemente da fila a que pertencem. Na maioria dos casos, é melhor pensar na fila laundry como uma fila de páginas relativamente não usadas que podem ou não estar no processo de serem gravadas no disco. A fila inativa contém uma mistura de páginas limpas e sujas; as páginas limpas próximas ao início da fila são recuperadas imediatamente para aliviar a falta de páginas livres e as páginas sujas são movidas para a fila laundry para processamento posterior.</p></div><div class=paragraph><p>Existem alguns outros flags (por exemplo, flag de ocupado ou de contagem ocupada) que podem modificar algumas das regras descritas.</p></div></div><div class=sect2><h3 id=_quanta_memória_livre_está_disponível>10.22. Quanta memória livre está disponível?<a class=anchor href=#_quanta_memória_livre_está_disponível></a></h3><div class=paragraph><p>Existem alguns tipos de "memória livre". O mais comum é a quantidade de memória disponível imediatamente, sem recuperar a memória já em uso. Esse é o tamanho da fila de páginas livres mais algumas outras páginas reservadas. Esse valor é exportado pelo <code>vm.stats.vm.v_free_count</code> <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a>, mostrado, por exemplo, pelo <a href="https://man.freebsd.org/cgi/man.cgi?query=top&amp;sektion=1&amp;format=html">top(1)</a>. Outro tipo de "memória livre" é a quantidade total de memória virtual disponível para os processos da área de usuário, que depende da soma do espaço de swap e da memória utilizável. Outros tipos de descrições de "memória livre" também são possíveis, mas é relativamente inútil defini-las, mas é importante garantir que a taxa de paginação seja mantida baixa e evitar ficar sem espaço de swap.</p></div></div><div class=sect2><h3 id=_o_que_é_o_varempty>10.23. O que é o /var/empty?<a class=anchor href=#_o_que_é_o_varempty></a></h3><div class=paragraph><p>O <span class=filename>/var/empty</span> é um diretório que o programa <a href="https://man.freebsd.org/cgi/man.cgi?query=sshd&amp;sektion=8&amp;format=html">sshd(8)</a> utiliza ao executar a separação de privilégios. O diretório <span class=filename>/var/empty</span> está vazio, pertence ao usuário <code>root</code> e possui as flags <code>schg</code> definidas. Este diretório não deve ser excluído.</p></div></div><div class=sect2><h3 id=_acabei_de_alterar_o_etcnewsyslog_conf_como_posso_verificar_se_ele_faz_o_que_eu_espero>10.24. Acabei de alterar o /etc/newsyslog.conf . Como posso verificar se ele faz o que eu espero?<a class=anchor href=#_acabei_de_alterar_o_etcnewsyslog_conf_como_posso_verificar_se_ele_faz_o_que_eu_espero></a></h3><div class=paragraph><p>Para ver o que <a href="https://man.freebsd.org/cgi/man.cgi?query=newsyslog&amp;sektion=8&amp;format=html">newsyslog(8)</a> vai fazer, use o seguinte:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% newsyslog <span class=nt>-nrvv</span></code></pre></div></div></div><div class=sect2><h3 id=_minha_hora_está_errada_como_posso_mudar_o_fuso_horário>10.25. Minha hora está errada, como posso mudar o fuso horário?<a class=anchor href=#_minha_hora_está_errada_como_posso_mudar_o_fuso_horário></a></h3><div class=paragraph><p>Use o <a href="https://man.freebsd.org/cgi/man.cgi?query=tzsetup&amp;sektion=8&amp;format=html">tzsetup(8)</a>.</p></div></div></div></div><div class=sect1><h2 id=_o_sistema_x_window_e_consoles_virtuais>11. O sistema X Window e consoles virtuais<a class=anchor href=#_o_sistema_x_window_e_consoles_virtuais></a></h2><div class=sectionbody><div class=sect2><h3 id=_o_que_é_o_sistema_x_window>11.1. O que é o sistema X Window?<a class=anchor href=#_o_que_é_o_sistema_x_window></a></h3><div class=paragraph><p>O sistema de janelas X (comumente chamado de <code>X11</code>) é o sistema de janelas mais amplamente disponível capaz de executar em Sistemas UNIX™ e sistemas UNIX™-Like, incluindo o FreeBSD. A <a href=http://www.x.org/wiki/>Fundação X.Org</a> administra os <a href=http://en.wikipedia.org/wiki/X_Window_System_core_protocol>padrões de protocolo X</a>, sendo que a implementação de referência atual é a versão 11 release 7.7, então as referências são frequentemente encurtadas para <code>X11</code>.</p></div><div class=paragraph><p>Muitas implementações estão disponíveis para diferentes arquiteturas e sistemas operacionais. Uma implementação do código do lado do servidor é conhecida como um <code>Servidor X</code>.</p></div></div><div class=sect2><h3 id=_eu_quero_rodar_o_xorg_como_faço_para_isso>11.2. Eu quero rodar o Xorg, como faço para isso?<a class=anchor href=#_eu_quero_rodar_o_xorg_como_faço_para_isso></a></h3><div class=paragraph><p>Para instalar o Xorg, siga um destes procedimentos:</p></div><div class=paragraph><p>Use o meta-port <a class=package href=https://cgit.freebsd.org/ports/tree/x11/xorg/>x11/xorg</a>, que constrói e instala todos os componentes do Xorg.</p></div><div class=paragraph><p>Use <a class=package href=https://cgit.freebsd.org/ports/tree/x11/xorg-minimal/>x11/xorg-minimal</a>, que constrói e instala apenas os componentes Xorg necessários.</p></div><div class=paragraph><p>Instale o Xorg a partir de pacotes do FreeBSD:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> <span class=c># pkg install xorg</span></code></pre></div></div><div class=paragraph><p>Após a instalação do Xorg, siga as instruções da seção <a href=https://docs.freebsd.org/pt-br/books/handbook/book/x11#x-config>Configuração X11</a> do Handbook do FreeBSD.</p></div></div><div class=sect2><h3 id=_eu_tentei_executar_o_x_mas_eu_recebo_um_erro_no_devices_detected_quando_eu_digito_startx_o_que_eu_faço_agora>11.3. Eu tentei executar o X, mas eu recebo um erro No devices detected. quando eu digito startx. O que eu faço agora?<a class=anchor href=#_eu_tentei_executar_o_x_mas_eu_recebo_um_erro_no_devices_detected_quando_eu_digito_startx_o_que_eu_faço_agora></a></h3><div class=paragraph><p>O sistema provavelmente está sendo executado em um <code>securelevel</code> alto. Não é possível iniciar o X em <code>securelevel</code> alto porque o X requer acesso de ao <a href="https://man.freebsd.org/cgi/man.cgi?query=io&amp;sektion=4&amp;format=html">io(4)</a>. Para obter mais informações, consulte a página de manual do <a href="https://man.freebsd.org/cgi/man.cgi?query=init&amp;sektion=8&amp;format=html">init(8)</a>.</p></div><div class=paragraph><p>Existem duas soluções para o problema: definir o <code>securelevel</code> novamente a zero ou executar <a href="https://man.freebsd.org/cgi/man.cgi?query=xdm&amp;sektion=1&amp;format=html">xdm(1)</a> (ou um gerenciador de exibição alternativo) no momento da inicialização antes que o <code>securelevel</code> seja elevado.</p></div><div class=paragraph><p>Veja <a href=#xdm-boot>Como faço para carregar o XDM na inicialização?</a> para mais informações sobre como executar o <a href="https://man.freebsd.org/cgi/man.cgi?query=xdm&amp;sektion=1&amp;format=html">xdm(1)</a> no momento da inicialização.</p></div></div><div class=sect2><h3 id=_por_que_meu_mouse_não_funciona_com_o_x>11.4. Por que meu mouse não funciona com o X?<a class=anchor href=#_por_que_meu_mouse_não_funciona_com_o_x></a></h3><div class=paragraph><p>Ao usar <a href="https://man.freebsd.org/cgi/man.cgi?query=vt&amp;sektion=4&amp;format=html">vt(4)</a>, o driver de console padrão, o FreeBSD pode ser configurado para suportar um ponteiro de mouse em cada tela virtual. Para evitar conflito com o X, o <a href="https://man.freebsd.org/cgi/man.cgi?query=vt&amp;sektion=4&amp;format=html">vt(4)</a> suporta um dispositivo virtual chamado <span class=filename>/dev/sysmouse</span>. Todos os eventos de mouse recebidos do dispositivo de mouse real são gravados no dispositivo via <a href="https://man.freebsd.org/cgi/man.cgi?query=sysmouse&amp;sektion=4&amp;format=html">sysmouse(4)</a><a href="https://man.freebsd.org/cgi/man.cgi?query=moused&amp;sektion=8&amp;format=html">moused(8)</a>. Para usar o mouse em um ou mais consoles virtuais, <em>e</em> usar X, veja <a href=#moused>É possível usar um mouse fora do sistema X Window?</a> e configure o <a href="https://man.freebsd.org/cgi/man.cgi?query=moused&amp;sektion=8&amp;format=html">moused(8)</a>.</p></div><div class=paragraph><p>Em seguida, edite o arquivo <span class=filename>/etc/X11/xorg.conf</span> e verifique se as seguintes linhas existem:</p></div><div class="literalblock programlisting"><div class=content><pre>Section &#34;InputDevice&#34;
   Option          &#34;Protocol&#34; &#34;SysMouse&#34;
   Option          &#34;Device&#34; &#34;/dev/sysmouse&#34;
.....</pre></div></div><div class=paragraph><p>Começando com a versão 7.4 do Xorg, as seções <code>InputDevice</code> no <span class=filename>xorg.conf</span> são ignoradas em favor dos dispositivos autodetectados. Para restaurar o comportamento antigo, adicione a seguinte linha à seção <code>ServerLayout</code> ou <code>ServerFlags</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>Option &#34;AutoAddDevices&#34; &#34;false&#34;</pre></div></div><div class=paragraph><p>Algumas pessoas preferem usar o <span class=filename>/dev/mouse</span> com o X. Para fazer esse trabalho, <span class=filename>/dev/mouse</span> deve estar vinculado a <span class=filename>/dev/sysmouse</span> (veja <a href="https://man.freebsd.org/cgi/man.cgi?query=sysmouse&amp;sektion=4&amp;format=html">sysmouse(4)</a>) adicionando a seguinte linha ao <span class=filename>/etc/devfs.conf</span> (veja <a href="https://man.freebsd.org/cgi/man.cgi?query=devfs.conf&amp;sektion=5&amp;format=html">devfs.conf(5)</a>):</p></div><div class="literalblock programlisting"><div class=content><pre>link    sysmouse    mouse</pre></div></div><div class=paragraph><p>Este link pode ser criado reiniciando o <a href="https://man.freebsd.org/cgi/man.cgi?query=devfs&amp;sektion=5&amp;format=html">devfs(5)</a> com o seguinte comando (executado como <code>root</code>):</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service devfs restart</span></code></pre></div></div></div><div class=sect2><h3 id=_meu_mouse_tem_uma_fancy_wheel_posso_usá_lo_no_x>11.5. Meu mouse tem uma fancy wheel. Posso usá-lo no X?<a class=anchor href=#_meu_mouse_tem_uma_fancy_wheel_posso_usá_lo_no_x></a></h3><div class=paragraph><p>Sim, se o X estiver configurado para um mouse de 5 botões. Para fazer isso, adicione as linhas <code>Buttons 5</code> e <code>ZAxisMapping 4 5</code> na seção "InputDevice" do arquivo <span class=filename>/etc/X11/xorg.conf</span>, como visto neste exemplo:</p></div><div class="literalblock programlisting"><div class=content><pre>Section &#34;InputDevice&#34;
   Identifier      &#34;Mouse1&#34;
   Driver          &#34;mouse&#34;
   Option          &#34;Protocol&#34; &#34;auto&#34;
   Option          &#34;Device&#34; &#34;/dev/sysmouse&#34;
   Option          &#34;Buttons&#34; &#34;5&#34;
   Option          &#34;ZAxisMapping&#34; &#34;4 5&#34;
EndSection</pre></div></div><div class=paragraph><p>O mouse pode ser habilitado no Emacs adicionando estas linhas ao <span class=filename>~/.emacs</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>;; wheel mouse
(global-set-key [mouse-4] &#39;scroll-down)
(global-set-key [mouse-5] &#39;scroll-up)</pre></div></div></div><div class=sect2><h3 id=_meu_laptop_tem_um_touchpad_synaptics_posso_usá_lo_no_x>11.6. Meu laptop tem um touchpad Synaptics. Posso usá-lo no X?<a class=anchor href=#_meu_laptop_tem_um_touchpad_synaptics_posso_usá_lo_no_x></a></h3><div class=paragraph><p>Sim, depois de configurar algumas coisas para que funcione.</p></div><div class=paragraph><p>Para usar o driver synaptics do Xorg, primeiro remova <code>moused_enable</code> do <span class=filename>rc.conf</span>.</p></div><div class=paragraph><p>Para habilitar a synaptics, adicione a seguinte linha ao <span class=filename>/boot/loader.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>hw.psm.synaptics_support=&#34;1&#34;</pre></div></div><div class=paragraph><p>Adicione o seguinte ao <span class=filename>/etc/X11/xorg.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>Section &#34;InputDevice&#34;
Identifier  &#34;Touchpad0&#34;
Driver      &#34;synaptics&#34;
Option      &#34;Protocol&#34; &#34;psm&#34;
Option      &#34;Device&#34; &#34;/dev/psm0&#34;
EndSection</pre></div></div><div class=paragraph><p>E não se esqueça de adicionar o seguinte na seção "ServerLayout":</p></div><div class="literalblock programlisting"><div class=content><pre>InputDevice    &#34;Touchpad0&#34; &#34;SendCoreEvents&#34;</pre></div></div></div><div class=sect2><h3 id=_como_eu_uso_displays_x_remotos>11.7. Como eu uso displays X remotos?<a class=anchor href=#_como_eu_uso_displays_x_remotos></a></h3><div class=paragraph><p>Por motivos de segurança, a configuração padrão é não permitir que uma máquina abra remotamente uma janela.</p></div><div class=paragraph><p>Para ativar esse recurso, inicie o X com o argumento opcional <code>-listen_tcp</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% startx <span class=nt>-listen_tcp</span></code></pre></div></div></div><div class=sect2><h3 id=_o_que_é_um_console_virtual_e_como_faço_outros>11.8. O que é um console virtual e como faço outros?<a class=anchor href=#_o_que_é_um_console_virtual_e_como_faço_outros></a></h3><div class=paragraph><p>Os consoles virtuais fornecem várias sessões simultâneas na mesma máquina sem fazer nada complicado, como configurar uma rede ou executar o X.</p></div><div class=paragraph><p>Quando o sistema iniciar, ele exibirá um prompt de login no monitor depois de exibir todas as mensagens de inicialização. Digite seu nome de login e senha para começar a trabalhar no primeiro console virtual.</p></div><div class=paragraph><p>Para iniciar outra sessão, talvez para examinar a documentação de um programa ou para ler mensagens enquanto aguarda a conclusão de uma transferência por FTP, pressione <kbd>Alt</kbd> e pressione <kbd>F2</kbd>. Isso exibirá o prompt de login do segundo console virtual. Para voltar à sessão original, pressione <span class=keyseq><kbd>Alt</kbd>+<kbd>F1</kbd></span>.</p></div><div class=paragraph><p>A instalação padrão do FreeBSD possui oito consoles virtuais habilitados. A combinação de teclas <span class=keyseq><kbd>Alt</kbd>+<kbd>F1</kbd></span>, <span class=keyseq><kbd>Alt</kbd>+<kbd>F2</kbd></span>, <span class=keyseq><kbd>Alt</kbd>+<kbd>F3</kbd></span>, e assim por diante alternará entre esses consoles virtuais.</p></div><div class=paragraph><p>Para habilitar mais consoles virtuais, edite <span class=filename>/etc/ttys</span> (veja <a href="https://man.freebsd.org/cgi/man.cgi?query=ttys&amp;sektion=5&amp;format=html">ttys(5)</a>) e adicione entradas do <span class=filename>ttyv8</span> até o <span class=filename>ttyvc</span>, após os comentários na seção "Virtual terminals":</p></div><div class="literalblock programlisting"><div class=content><pre># Edit the existing entry for ttyv8 in /etc/ttys and change
# &#34;off&#34; to &#34;on&#34;.
ttyv8   &#34;/usr/libexec/getty Pc&#34;         xterm  on secure
ttyv9   &#34;/usr/libexec/getty Pc&#34;         xterm  on secure
ttyva   &#34;/usr/libexec/getty Pc&#34;         xterm  on secure
ttyvb   &#34;/usr/libexec/getty Pc&#34;         xterm  on secure</pre></div></div><div class=paragraph><p>Quanto mais terminais virtuais estiverem ativos, mais recursos serão usados. Isso pode ser um problema em sistemas com 8 MB de RAM ou menos. Considere mudar a opção <code>secure</code> para <code>insecure</code>.</p></div><div class="admonitionblock important"><table><tbody><tr><td class=icon><i class="fa icon-important" title=Important></i></td><td class=content><div class=paragraph><p>Para executar um servidor X, pelo menos um terminal virtual deverá ser deixado como <code>off</code> para ele usar. Isso significa que apenas onze das teclas de função Alt podem ser usadas como consoles virtuais, de modo que uma deverá ser deixada livre para uso do servidor X.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Por exemplo, para executar o X e onze consoles virtuais, a configuração para o terminal virtual 12 deve ser:</p></div><div class="literalblock programlisting"><div class=content><pre>ttyvb   &#34;/usr/libexec/getty Pc&#34;         xterm  off secure</pre></div></div><div class=paragraph><p>A maneira mais fácil de ativar os consoles virtuais é reinicializar.</p></div></div><div class=sect2><h3 id=_como_eu_acesso_os_consoles_virtuais_a_partir_do_x>11.9. Como eu acesso os consoles virtuais a partir do X?<a class=anchor href=#_como_eu_acesso_os_consoles_virtuais_a_partir_do_x></a></h3><div class=paragraph><p>Utilize <span class=keyseq><kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>Fn</kbd></span> para voltar a um console virtual. Pressione <span class=keyseq><kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>F1</kbd></span> para retornar ao primeiro console virtual.</p></div><div class=paragraph><p>Uma vez em um console de texto, use <span class=keyseq><kbd>Alt</kbd>+<kbd>F n</kbd></span> para mover-se entre eles.</p></div><div class=paragraph><p>Para retornar à sessão X, mude para o console virtual que está executando o X. Se o X foi iniciado a partir da linha de comando usando <code>startx</code>, a sessão X será anexada ao próximo console virtual não utilizado, e não ao console de texto no qual foi invocado. Para oito terminais virtuais ativos, o X será executado no nono, portanto use <span class=keyseq><kbd>Alt</kbd>+<kbd>F9</kbd></span>.</p></div></div><div class=sect2><h3 id=xdm-boot>11.10. Como faço para carregar o XDM na inicialização?<a class=anchor href=#xdm-boot></a></h3><div class=paragraph><p>Existem duas escolas de pensamento sobre como iniciar o <a href="https://man.freebsd.org/cgi/man.cgi?query=xdm&amp;sektion=1&amp;format=html">xdm(1)</a>. Uma escola inicia o <code>xdm</code> a partir do <span class=filename>/etc/ttys</span> (veja <a href="https://man.freebsd.org/cgi/man.cgi?query=ttys&amp;sektion=5&amp;format=html">ttys(5)</a>) usando o exemplo fornecido, enquanto o outro executa o <code>xdm</code> a partir do <span class=filename>rc.local</span> (veja <a href="https://man.freebsd.org/cgi/man.cgi?query=rc&amp;sektion=8&amp;format=html">rc(8)</a>) ou de um script <span class=filename>X</span> localizado em <span class=filename>/usr/local/etc/rc.d</span>. Ambos são igualmente válidos, e um pode funcionar em situações em que o outro não funciona. Em ambos os casos, o resultado é o mesmo: O X mostrará um prompt de login gráfico.</p></div><div class=paragraph><p>O método <a href="https://man.freebsd.org/cgi/man.cgi?query=ttys&amp;sektion=5&amp;format=html">ttys(5)</a> tem a vantagem de documentar qual vty X iniciará e passando a responsabilidade de reiniciar o servidor X no logout para o <a href="https://man.freebsd.org/cgi/man.cgi?query=init&amp;sektion=8&amp;format=html">init(8)</a>. O método <a href="https://man.freebsd.org/cgi/man.cgi?query=rc&amp;sektion=8&amp;format=html">rc(8)</a> facilita o <code>kill xdm</code> se houver um problema ao iniciar o servidor X.</p></div><div class=paragraph><p>Se carregado pelo <a href="https://man.freebsd.org/cgi/man.cgi?query=rc&amp;sektion=8&amp;format=html">rc(8)</a>, o <code>xdm</code> deve ser iniciado sem nenhum argumento. <code>xdm</code> deve iniciar <em>após</em> o <a href="https://man.freebsd.org/cgi/man.cgi?query=getty&amp;sektion=8&amp;format=html">getty(8)</a> ser executado, ou então <code>getty</code> e <code>xdm</code> entrarão em conflito, bloqueando o console. A melhor maneira de contornar isso é fazer com que o script espere 10 segundos ou mais e, em seguida, iniciar o <code>xdm</code>.</p></div><div class=paragraph><p>Ao iniciar o <code>xdm</code> pelo <span class=filename>/etc/ttys</span>, ainda há uma chance de conflito entre <code>xdm</code> e <a href="https://man.freebsd.org/cgi/man.cgi?query=getty&amp;sektion=8&amp;format=html">getty(8)</a>. Uma maneira de evitar isso é adicionar o número <code>vt</code> no arquivo <span class=filename>/usr/local/lib/X11/xdm/Xservers</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>:0 local /usr/local/bin/X vt4</pre></div></div><div class=paragraph><p>O exemplo acima irá direcionar o servidor X para ser executado em <span class=filename>/dev/ttyv3</span>. Observe que o número é compensado por um. O servidor X conta a vty a partir de 1, enquanto o kernel do FreeBSD numera a vty a partir de zero.</p></div></div><div class=sect2><h3 id=_por_que_eu_obtenho_o_erro_couldnt_open_console_quando_executo_o_xconsole>11.11. Por que eu obtenho o erro Couldn’t open console quando executo o xconsole?<a class=anchor href=#_por_que_eu_obtenho_o_erro_couldnt_open_console_quando_executo_o_xconsole></a></h3><div class=paragraph><p>Quando o X é iniciado com o comando <code>startx</code>, as permissões em <span class=filename>/dev/console</span><em>não</em> serão alteradas, o que resultará um comportamento errático de algumas coisas tais como o não funcionamento do <code>xterm -C</code> e do <code>xconsole</code>.</p></div><div class=paragraph><p>Isso ocorre devido à maneira como as permissões do console são definidas por padrão. Em um sistema multiusuário, não é necessário que qualquer usuário possa escrever no console do sistema. Para os usuários que estão logando diretamente em uma máquina com um VTY, existe o arquivo <a href="https://man.freebsd.org/cgi/man.cgi?query=fbtab&amp;sektion=&amp;format=html">fbtab()</a> para resolver tais problemas.</p></div><div class=paragraph><p>Em poucas palavras, certifique-se de que uma linha não comentada do formulário esteja no <span class=filename>/etc/fbtab</span> (veja <a href="https://man.freebsd.org/cgi/man.cgi?query=fbtab&amp;sektion=5&amp;format=html">fbtab(5)</a>):</p></div><div class="literalblock programlisting"><div class=content><pre>/dev/ttyv0 0600 /dev/console</pre></div></div><div class=paragraph><p>Ele irá garantir que quem fizer o login em <span class=filename>/dev/ttyv0</span> será o dono do console.</p></div></div><div class=sect2><h3 id=_por_que_meu_mouse_ps2_não_funciona_direito_no_x>11.12. Por que meu mouse PS/2 não funciona direito no X?<a class=anchor href=#_por_que_meu_mouse_ps2_não_funciona_direito_no_x></a></h3><div class=paragraph><p>O mouse e o driver do mouse podem estar fora de sincronização. Em casos raros, o driver também pode relatar erroneamente erros de sincronização:</p></div><div class="literalblock programlisting"><div class=content><pre>psmintr: out of sync (xxxx != yyyy)</pre></div></div><div class=paragraph><p>Se isso acontecer, desative o código de verificação de sincronização definindo as flags de driver para o driver de mouse PS/2 como <code>0x100</code>. Isto pode ser mais facilmente alcançado adicionando <code>hint.psm.0.flags="0x100"</code> ao arquivo <span class=filename>/boot/loader.conf</span> e reiniciando.</p></div></div><div class=sect2><h3 id=_como_eu_inverto_os_botões_do_mouse>11.13. Como eu inverto os botões do mouse?<a class=anchor href=#_como_eu_inverto_os_botões_do_mouse></a></h3><div class=paragraph><p>Digite <code>xmodmap -e "pointer = 3 2 1"</code>. Adicione este comando ao <span class=filename>~/.xinitrc</span> ou <span class=filename>~/.xsession</span> para que isso aconteça automaticamente.</p></div></div><div class=sect2><h3 id=_como_faço_para_instalar_uma_splash_screen_e_onde_posso_encontrá_las>11.14. Como faço para instalar uma splash screen e onde posso encontrá-las?<a class=anchor href=#_como_faço_para_instalar_uma_splash_screen_e_onde_posso_encontrá_las></a></h3><div class=paragraph><p>A resposta detalhada para essa pergunta pode ser encontrada na seção <a href=https://docs.freebsd.org/pt-br/books/handbook/book/boot#boot-splash>Telas de inicialização do tempo de inicialização</a> do FreeBSD Handbook.</p></div></div><div class=sect2><h3 id=_posso_usar_as_teclas_do_windows_do_meu_teclado_no_x>11.15. Posso usar as teclas do Windows do meu teclado no X?<a class=anchor href=#_posso_usar_as_teclas_do_windows_do_meu_teclado_no_x></a></h3><div class=paragraph><p>Sim. Use o <a href="https://man.freebsd.org/cgi/man.cgi?query=xmodmap&amp;sektion=1&amp;format=html">xmodmap(1)</a> para definir quais funções as teclas devem executar.</p></div><div class=paragraph><p>Supondo que todos os teclados Windows sigam um padrão, os códigos de teclas para essas três teclas são os seguintes:</p></div><div class=ulist><ul><li><p>115 - tecla <kbd>Windows</kbd>, entre as teclas <kbd>Ctrl</kbd> e <kbd>Alt</kbd> do lado esquerdo</p></li><li><p>116 - tecla <kbd>Windows</kbd>, à direita de <kbd>AltGr</kbd></p></li><li><p>117 - <kbd>Menu</kbd>, à esquerda da tecla <kbd>Ctrl</kbd> da direita</p></li></ul></div><div class=paragraph><p>Para que a tecla <kbd>Windows</kbd> da esquerda imprima uma vírgula, tente isto.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># xmodmap -e &#34;keycode 115 = comma&#34;</span></code></pre></div></div><div class=paragraph><p>Para que os mapeamentos de teclas <kbd>Windows</kbd> sejam ativados automaticamente toda vez que X for iniciado, coloque os comandos <code>xmodmap</code> em <span class=filename>~/.xinitrc</span> ou, preferencialmente, crie um <span class=filename>~/.xmodmaprc</span> e inclua as opções <code>xmodmap</code>, uma por linha, e adicione a seguinte linha ao <span class=filename>~/.xinitrc</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>xmodmap $HOME/.xmodmaprc</pre></div></div><div class=paragraph><p>Por exemplo, para mapear as 3 chaves para serem <kbd>F13</kbd>, <kbd>F14</kbd> e <kbd>F15</kbd>, respectivamente. Isso facilitaria mapeá-los para funções úteis em aplicativos ou no gerenciador de janelas.</p></div><div class=paragraph><p>Para fazer isto, coloque o seguinte em <span class=filename>~/.xmodmaprc</span>.</p></div><div class="literalblock programlisting"><div class=content><pre>keycode 115 = F13
keycode 116 = F14
keycode 117 = F15</pre></div></div><div class=paragraph><p>Para o gerenciador da área de trabalho <a class=package href=https://cgit.freebsd.org/ports/tree/x11-wm/fvwm2/>x11-wm/fvwm2</a>, pode-se mapear as chaves para que <kbd>F13</kbd> seja minimizada a janela em que o cursor está ou a maximize, <kbd>F14</kbd> traz a janela em que o cursor está para a frente ou, se já estiver na frente, a coloca em background <kbd>F15</kbd> aparece no menu principal do Workplace mesmo que o cursor não esteja a área de trabalho, o que é útil quando nenhuma parte da área de trabalho está visível.</p></div><div class=paragraph><p>As seguintes entradas em <span class=filename>~/.fvwmrc</span> implementam a configuração acima mencionada:</p></div><div class="literalblock programlisting"><div class=content><pre>Key F13        FTIWS    A        Iconify
Key F14        FTIWS    A        RaiseLower
Key F15        A        A        Menu Workplace Nop</pre></div></div></div><div class=sect2><h3 id=_como_posso_obter_aceleração_de_hardware_3d_para_o_opengl>11.16. Como posso obter aceleração de hardware 3D para o OpenGL ?<a class=anchor href=#_como_posso_obter_aceleração_de_hardware_3d_para_o_opengl></a></h3><div class=paragraph><p>A disponibilidade da aceleração 3D depende da versão do Xorg e do tipo de chip de vídeo. Para um chip da nVidia, use os drivers binários fornecidos para o FreeBSD instalando um dos seguintes ports:</p></div><div class=paragraph><p>As versões mais recentes das placas nVidia são suportadas pelo port <a class=package href=https://cgit.freebsd.org/ports/tree/x11/nvidia-driver/>x11/nvidia-driver</a>.</p></div><div class=paragraph><p>Drivers mais antigos estão disponíveis como <a class=package href="https://cgit.freebsd.org/ports/tree/x11/nvidia-driver-<mark>#</mark>/">x11/nvidia-driver-<mark>#</mark></a></p></div><div class=paragraph><p>A nVidia fornece informações detalhadas sobre qual placa é suportada por qual driver em seu site: <a href=http://www.nvidia.com/object/IO_32667.html>http://www.nvidia.com /object/IO_32667.html</a>.</p></div><div class=paragraph><p>Para a Matrox G200/G400, verifique o port <a class=package href=https://cgit.freebsd.org/ports/tree/x11-drivers/xf86-video-mga/>x11-drivers/xf86-video-mga</a>.</p></div><div class=paragraph><p>Para a ATI Rage 128 e Radeon, consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=ati&amp;sektion=4&amp;format=html">ati(4)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=r128&amp;sektion=4&amp;format=html">r128(4)</a> and <a href="https://man.freebsd.org/cgi/man.cgi?query=radeon&amp;sektion=4&amp;format=html">radeon(4)</a>.</p></div></div></div></div><div class=sect1><h2 id=_networking>12. Networking<a class=anchor href=#_networking></a></h2><div class=sectionbody><div class=sect2><h3 id=_onde_posso_obter_informações_sobre_a_inicialização_sem_disco>12.1. Onde posso obter informações sobre a inicialização sem disco?<a class=anchor href=#_onde_posso_obter_informações_sobre_a_inicialização_sem_disco></a></h3><div class=paragraph><p>"Inicialização sem disco" significa que o sistema FreeBSD é inicializado através de uma rede e lê os arquivos necessários de um servidor ao invés de seu disco rígido. Para maiores detalhes, consulte a entrada do Handbook <a href=https://docs.freebsd.org/pt-br/books/handbook/book/advanced-networking#network-diskless>Inicialização sem disco</a>.</p></div></div><div class=sect2><h3 id=_uma_maquina_freebsd_pode_ser_usada_como_um_roteador_de_rede_dedicado>12.2. Uma maquina FreeBSD pode ser usada como um roteador de rede dedicado?<a class=anchor href=#_uma_maquina_freebsd_pode_ser_usada_como_um_roteador_de_rede_dedicado></a></h3><div class=paragraph><p>Sim. Consulte a entrada do Manual em <a href=https://docs.freebsd.org/pt-br/books/handbook/book/advanced-networking#advanced-networking>rede avançada</a>, especificamente a seção sobre <a href=https://docs.freebsd.org/pt-br/books/handbook/book/advanced-networking#network-routing>roteamento e gateways</a>.</p></div></div><div class=sect2><h3 id=_o_freebsd_suporta_nat_ou_mascaramento_de_ips>12.3. O FreeBSD suporta NAT ou Mascaramento de IPs?<a class=anchor href=#_o_freebsd_suporta_nat_ou_mascaramento_de_ips></a></h3><div class=paragraph><p>Sim. Para obter instruções sobre como usar o NAT em uma conexão PPP, consulte a seção do <a href=https://docs.freebsd.org/pt-br/books/handbook/book/ppp-and-slip#userppp>PPP</a> no manual. Para usar o NAT em algum outro tipo de conexão de rede, consulte a seção <a href=https://docs.freebsd.org/pt-br/books/handbook/book/#network-natd>natd</a> do manual.</p></div></div><div class=sect2><h3 id=_como_posso_configurar_aliases_de_ethernet>12.4. Como posso configurar aliases de Ethernet?<a class=anchor href=#_como_posso_configurar_aliases_de_ethernet></a></h3><div class=paragraph><p>Se o alias estiver na mesma sub-rede que um endereço já configurado na interface, adicione <code>netmask 0xffffffff</code> a este comando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig ed0 alias 192.0.2.2 netmask 0xffffffff</span></code></pre></div></div><div class=paragraph><p>Caso contrário, especifique o endereço de rede e a máscara de rede como de costume:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig ed0 alias 172.16.141.5 netmask 0xffffff00</span></code></pre></div></div><div class=paragraph><p>Mais informações podem ser encontradas <a href=https://docs.freebsd.org/pt-br/books/handbook/book/config-tuning#configtuning-virtual-hosts>Handbook</a> do FreeBSD.</p></div></div><div class=sect2><h3 id=_por_que_não_posso_montar_o_nfs_de_uma_máquina_linux>12.5. Por que não posso montar o NFS de uma máquina Linux?<a class=anchor href=#_por_que_não_posso_montar_o_nfs_de_uma_máquina_linux></a></h3><div class=paragraph><p>Algumas versões do código NFS do Linux™ aceitam somente solicitações de montagem vindas de uma porta privilegiada; tente executar o seguinte comando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount -o -P linuxbox:/blah /mnt</span></code></pre></div></div></div><div class=sect2><h3 id=_por_que_o_comando_mountd_continua_me_dizendo_que_ele_cant_change_attributes_não_pode_alterar_os_atributos_e_que_eu_tenho_uma_bad_exports_list_lista_de_exports_ruins_no_meu_servidor_nfs_do_freebsd>12.6. Por que o comando mountd continua me dizendo que ele can’t change attributes (não pode alterar os atributos) e que eu tenho uma bad exports list (lista de exports ruins) no meu servidor NFS do FreeBSD?<a class=anchor href=#_por_que_o_comando_mountd_continua_me_dizendo_que_ele_cant_change_attributes_não_pode_alterar_os_atributos_e_que_eu_tenho_uma_bad_exports_list_lista_de_exports_ruins_no_meu_servidor_nfs_do_freebsd></a></h3><div class=paragraph><p>O problema mais freqüente é não entender o formato correto de <span class=filename>/etc/exports</span>. Revise <a href="https://man.freebsd.org/cgi/man.cgi?query=exports&amp;sektion=5&amp;format=html">exports(5)</a> e o <a href=https://docs.freebsd.org/pt-br/books/handbook/book/network-servers#network-nfs>NFS</a> no manual, especialmente na seção <a href=https://docs.freebsd.org/pt-br/books/handbook/book/#configuring-nfs>configurando o NFS</a>.</p></div></div><div class=sect2><h3 id=_como_faço_para_ativar_o_suporte_a_multicast_ip>12.7. Como faço para ativar o suporte a multicast IP?<a class=anchor href=#_como_faço_para_ativar_o_suporte_a_multicast_ip></a></h3><div class=paragraph><p>Instale o pacote ou port <a class=package href=https://cgit.freebsd.org/ports/tree/net/mrouted/>net/mrouted</a> e adicione <code>mrouted_enable="YES"</code> ao <span class=filename>/etc/rc.conf</span> para que o FreeBSD inicie este serviço no momento da inicialização.</p></div></div><div class=sect2><h3 id=_por_que_preciso_usar_o_fqdn_para_hosts_na_minha_rede>12.8. Por que preciso usar o FQDN para hosts na minha rede?<a class=anchor href=#_por_que_preciso_usar_o_fqdn_para_hosts_na_minha_rede></a></h3><div class=paragraph><p>Veja a resposta no <a href=https://docs.freebsd.org/pt-br/books/handbook/book/mail#mail-trouble>Handbook</a> do FreeBSD.</p></div></div><div class=sect2><h3 id=_por_que_recebo_oerro_permission_denied_para_todas_as_operações_de_rede>12.9. Por que recebo oerro, Permission denied, para todas as operações de rede?<a class=anchor href=#_por_que_recebo_oerro_permission_denied_para_todas_as_operações_de_rede></a></h3><div class=paragraph><p>Se o kernel é compilado com a opção <code>IPFIREWALL</code>, esteja ciente de que a política padrão é negar todos os pacotes que não são explicitamente permitidos.</p></div><div class=paragraph><p>Se o firewall foi inadvertidamente configurado de forma errada, restaure a operacionalidade da rede digitando o seguinte comando como <code>root</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ipfw add 65534 allow all from any to any</span></code></pre></div></div><div class=paragraph><p>Considere configurar a opção <code>firewall_type="open"</code> no <span class=filename>/etc/rc.conf</span>.</p></div><div class=paragraph><p>Para obter mais informações sobre como configurar seu firewall, consulte o <a href=https://docs.freebsd.org/pt-br/books/handbook/book/firewalls#firewalls-ipfw>Handbook</a>.</p></div></div><div class=sect2><h3 id=_por_que_minha_regra_ipfw_fwd_para_redirecionar_um_serviço_para_outra_máquina_que_não_está_funcionando>12.10. Por que minha regra ipfw fwd para redirecionar um serviço para outra máquina que não está funcionando?<a class=anchor href=#_por_que_minha_regra_ipfw_fwd_para_redirecionar_um_serviço_para_outra_máquina_que_não_está_funcionando></a></h3><div class=paragraph><p>Possivelmente porque você precisa utilizar a conversão de endereços de rede (NAT) em vez de apenas encaminhar os pacotes. Uma regra "fwd" apenas encaminha os pacotes, ela não altera os dados dentro do pacote. Considere esta regra:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>01000 fwd 10.0.0.1 from any to foo 21</code></pre></div></div><div class=paragraph><p>Quando um pacote com um endereço de destino <em>foo</em> chega à máquina com esta regra, o pacote é encaminhado para <em>10.0.0.1</em>, mas ainda tem o endereço de destino <em>foo</em>. O endereço de destino do pacote não é alterado para <em>10.0.0.1</em>. A maioria das máquinas provavelmente descartaria um pacote que recebesse com um endereço de destino que não fosse o seu. Portanto, usar uma regra "fwd" geralmente não funciona da maneira esperada pelo usuário. Esse comportamento é um recurso e não um bug.</p></div><div class=paragraph><p>Veja o <a href=#service-redirect>FAQ sobre redirecionamento de serviços</a>, o manual do <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a>, ou um dos vários utilitários de redirecionamento de porta na <a href=https://www.FreeBSD.org/ports/>Coleção de Portas</a> para uma maneira correta de fazer isso.</p></div></div><div class=sect2><h3 id=_como_posso_redirecionar_as_solicitações_de_serviço_de_uma_máquina_para_outra>12.11. Como posso redirecionar as solicitações de serviço de uma máquina para outra?<a class=anchor href=#_como_posso_redirecionar_as_solicitações_de_serviço_de_uma_máquina_para_outra></a></h3><div class=paragraph><p>FTP e outras solicitações de serviço podem ser redirecionadas com o pacote ou port <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/socket/>sysutils/socket</a>. Substitua a entrada para o serviço em <span class=filename>/etc/inetd.conf</span> para chamar <code>socket</code>, conforme visto neste exemplo para ftpd:</p></div><div class="literalblock programlisting"><div class=content><pre>ftp stream tcp nowait nobody /usr/local/bin/socket socket ftp.example.com ftp</pre></div></div><div class=paragraph><p>na qual <em>ftp.example.com</em> e <em>ftp</em> são o host e a porta de destino do redirecionamento, respectivamente.</p></div></div><div class=sect2><h3 id=_onde_posso_obter_uma_ferramenta_de_gerenciamento_de_largura_de_banda>12.12. Onde posso obter uma ferramenta de gerenciamento de largura de banda?<a class=anchor href=#_onde_posso_obter_uma_ferramenta_de_gerenciamento_de_largura_de_banda></a></h3><div class=paragraph><p>Existem três ferramentas de gerenciamento de largura de banda disponíveis para o FreeBSD. <a href="https://man.freebsd.org/cgi/man.cgi?query=dummynet&amp;sektion=4&amp;format=html">dummynet(4)</a> é integrado ao FreeBSD como parte do <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfw&amp;sektion=4&amp;format=html">ipfw(4)</a>. <a href=http://www.sonycsl.co.jp/person/kjc/programs.html>ALTQ</a> foi integrado ao FreeBSD como parte do <a href="https://man.freebsd.org/cgi/man.cgi?query=pf&amp;sektion=4&amp;format=html">pf(4)</a>. O Bandwidth Manager das <a href=http://www.etinc.com/>Tecnologias Emergentes </a>é um produto comercial.</p></div></div><div class=sect2><h3 id=_por_que_estou_recebendo_o_erro_devbpf0_device_not_configured>12.13. Por que estou recebendo o erro /dev/bpf0: device not configured?<a class=anchor href=#_por_que_estou_recebendo_o_erro_devbpf0_device_not_configured></a></h3><div class=paragraph><p>O aplicativo em execução requer o Packet Filter da Berkeley (<a href="https://man.freebsd.org/cgi/man.cgi?query=bpf&amp;sektion=4&amp;format=html">bpf(4)</a>), mas ele foi removido de um kernel personalizado. Adicione isto ao arquivo de configuração do kernel e construa um novo kernel:</p></div><div class="literalblock programlisting"><div class=content><pre>device bpf        # Berkeley Packet Filter</pre></div></div></div><div class=sect2><h3 id=_como_faço_para_montar_um_disco_de_uma_máquina_windows_que_esteja_na_minha_rede_tal_como_o_smbmount_no_linux>12.14. Como faço para montar um disco de uma máquina Windows que esteja na minha rede, tal como o smbmount no Linux?<a class=anchor href=#_como_faço_para_montar_um_disco_de_uma_máquina_windows_que_esteja_na_minha_rede_tal_como_o_smbmount_no_linux></a></h3><div class=paragraph><p>Use o conjunto de ferramentas SMBFS. Ele inclui um conjunto de modificações do kernel e um conjunto de programas da área de usuário. Os programas e as informações necessárias estão disponíveis como <a href="https://man.freebsd.org/cgi/man.cgi?query=mount_smbfs&amp;sektion=8&amp;format=html">mount_smbfs(8)</a> no sistema base.</p></div></div><div class=sect2><h3 id=_o_que_são_essas_mensagens_sobre_limiting_icmpopen_portclosed_port_response_em_meus_arquivos_de_log>12.15. O que são essas mensagens sobre: ​​Limiting icmp/open port/closed port response em meus arquivos de log?<a class=anchor href=#_o_que_são_essas_mensagens_sobre_limiting_icmpopen_portclosed_port_response_em_meus_arquivos_de_log></a></h3><div class=paragraph><p>Esta mensagem do kernel indica que alguma atividade está provocando o envio de uma grande quantidade de respostas de reset de ICMP ou TCP (RST). As respostas ICMP são frequentemente geradas como resultado de tentativas de conexão a portas UDP não utilizadas. Os resets TCP são geradas como resultado de tentativas de conexão a portas TCP não abertas. Entre outros, esses são os tipos de atividades que podem causar essas mensagens:</p></div><div class=ulist><ul><li><p>Ataques de negação de serviço (DoS) de força bruta (em oposição a ataques de pacote único que exploram uma vulnerabilidade específica).</p></li><li><p>Varreduras de porta que tentam se conectar a um grande número de portas (em oposição a apenas tentar algumas portas conhecidas).</p></li></ul></div><div class=paragraph><p>O primeiro número na mensagem indica quantos pacotes o kernel teria enviado se o limite não estivesse no lugar e o segundo indica o limite. Este limite é controlado usando <code>net.inet.icmp.icmplim</code>. Este exemplo define o limite para <code>300</code> pacotes por segundo:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl net.inet.icmp.icmplim=300</span></code></pre></div></div><div class=paragraph><p>Para desativar essas mensagens sem desativar a limitação de resposta, use o <code>net.inet.icmp.icmplim_output</code> para desativar a saída:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl net.inet.icmp.icmplim_output=0</span></code></pre></div></div><div class=paragraph><p>Finalmente, para desabilitar completamente a limitação de resposta, configure <code>net.inet.icmp.icmplim</code> para <code>0</code>. Desabilitar a limitação de resposta é desencorajado pelos motivos listados acima.</p></div></div><div class=sect2><h3 id=_o_que_são_essas_mensagens_de_erro_arp_unknown_hardware_address_format>12.16. O que são essas mensagens de erro arp: unknown hardware address format?<a class=anchor href=#_o_que_são_essas_mensagens_de_erro_arp_unknown_hardware_address_format></a></h3><div class=paragraph><p>Isso significa que algum dispositivo na Ethernet local está usando um endereço MAC em um formato que o FreeBSD não reconhece. Isso provavelmente é causado por alguém que está experimentando uma placa Ethernet em algum outro lugar da rede. Isso é mais comumente visto em redes de modem a cabo. É inofensivo e não deve afetar o desempenho do sistema FreeBSD.</p></div></div><div class=sect2><h3 id=_por_que_eu_continuo_vendo_mensagens_como_192_168_0_10_is_on_fxp1_but_got_reply_from_00151767cf82_on_rl0_e_como_desabilitá_lo>12.17. Por que eu continuo vendo mensagens como: 192.168.0.10 is on fxp1 but got reply from 00:15:17:67:cf:82 on rl0, e como desabilitá-lo?<a class=anchor href=#_por_que_eu_continuo_vendo_mensagens_como_192_168_0_10_is_on_fxp1_but_got_reply_from_00151767cf82_on_rl0_e_como_desabilitá_lo></a></h3><div class=paragraph><p>Porque um pacote está vindo de fora da rede inesperadamente. Para desativá-los, defina <code>net.link.ether.inet.log_arp_wrong_iface</code> como <code>0</code>.</p></div></div><div class=sect2><h3 id=_como_faço_para_compilar_um_kernel_com_suporte_somente_ao_ipv6>12.18. Como faço para compilar um kernel com suporte somente ao IPv6?<a class=anchor href=#_como_faço_para_compilar_um_kernel_com_suporte_somente_ao_ipv6></a></h3><div class=paragraph><p>Configure seu kernel com estas configurações:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>include GENERIC
ident GENERIC-IPV6ONLY
makeoptions MKMODULESENV+<span class=o>=</span><span class=s2>&#34;WITHOUT_INET_SUPPORT=&#34;</span>
nooptions INET
nodevice gre</code></pre></div></div></div></div></div><div class=sect1><h2 id=_segurança>13. Segurança<a class=anchor href=#_segurança></a></h2><div class=sectionbody><div class=sect2><h3 id=_o_que_é_uma_caixa_de_areia_sandbox>13.1. O que é uma caixa de areia (sandbox)?<a class=anchor href=#_o_que_é_uma_caixa_de_areia_sandbox></a></h3><div class=paragraph><p>"Sandbox" é um termo de segurança. Isso pode significar duas coisas:</p></div><div class=ulist><ul><li><p>Um processo que é colocado dentro de um conjunto de paredes virtuais que são projetadas para impedir que alguém que interrompa o processo seja capaz de invadir o sistema mais amplo.</p><div class=paragraph><p>O processo só é capaz de correr dentro das barreiras. Desde que nada que o processo faça em relação à execução de código seja capaz de violar as barreiras, uma auditoria detalhada de seu código não é necessária para poder dizer certas coisas sobre sua segurança.</p></div><div class=paragraph><p>As barreiras podem ser um ID do usuário, por exemplo. Esta é a definição usada nas páginas de manual de <a href="https://man.freebsd.org/cgi/man.cgi?query=security&amp;sektion=7&amp;format=html">security(7)</a> e <a href="https://man.freebsd.org/cgi/man.cgi?query=named&amp;sektion=8&amp;format=html">named(8)</a>.</p></div><div class=paragraph><p>Veja o serviço <code>ntalk</code>, por exemplo (veja <a href="https://man.freebsd.org/cgi/man.cgi?query=inetd&amp;sektion=8&amp;format=html">inetd(8)</a>). Este serviço costumava rodar como ID de usuário <code>root</code>. Agora ele é executado como ID do usuário <code>tty</code>. O usuário <code>tty</code> é um sandbox projetado para tornar mais difícil para alguém que invadiu o sistema com sucesso através do <code>ntalk</code> ser capaz de hackear além do seu ID de usuário.</p></div></li><li><p>Um processo que é colocado dentro de uma simulação da máquina. Isso significa que alguém que é capaz de entrar no processo pode acreditar que ele pode invadir a máquina mais ampla, mas está, na verdade, apenas invadindo uma simulação dessa máquina e não modificando nenhum dado real.</p><div class=paragraph><p>A maneira mais comum de fazer isso é construir um ambiente simulado em um subdiretório e então executar os processos nesse diretório chrooted para que o diretório <span class=filename>/</span> para esse processo seja este, não o diretório <span class=filename>/</span> real do sistema).</p></div><div class=paragraph><p>Outro uso comum é montar um sistema de arquivos subjacente somente leitura e, em seguida, criar uma camada do sistema de arquivos sobre ele, o que dá a um processo uma visualização aparentemente gravável nesse sistema de arquivos. O processo pode acreditar que é capaz de escrever nesses arquivos, mas o processo apenas vê os efeitos - outros processos no sistema não, necessariamente.</p></div><div class=paragraph><p>Foi feita uma tentativa de tornar esse tipo de sandbox tão transparente que o usuário (ou hacker) não percebe que está dentro dele.</p></div></li></ul></div><div class=paragraph><p>O UNIX™ implementa dois sandboxes principais. Um está no nível do processo e o outro está no nível do usuário.</p></div><div class=paragraph><p>Todo processo UNIX™ é completamente protegido contra qualquer outro processo UNIX™. Um processo não pode modificar o espaço de endereço de outro.</p></div><div class=paragraph><p>Um processo UNIX™ é de propriedade de um determinado ID de usuário. Se o ID de usuário não for o usuário <code>root</code>, ele servirá para proteger o processo contra processos pertencentes a outros usuários. O ID do usuário também é usado para proteger os dados no disco.</p></div></div><div class=sect2><h3 id=_o_que_é_securelevel>13.2. O que é securelevel?<a class=anchor href=#_o_que_é_securelevel></a></h3><div class=paragraph><p><code>securelevel</code> é um mecanismo de segurança implementado no kernel. Quando o nível de segurança é positivo, o kernel restringe certas tarefas; nem mesmo o superusuário (<code>root</code>) pode executá-los. O mecanismo de securelevel limita a capacidade de:</p></div><div class=ulist><ul><li><p>Desativar determinados flags de arquivo, tais como <code>schg</code> (o flag de sistema imutável).</p></li><li><p>Escrever na memória do kernel através de <span class=filename>/dev/mem</span> e <span class=filename>/dev/kmem</span>.</p></li><li><p>Carregar módulos do kernel.</p></li><li><p>Alterar as regras do firewall.</p></li></ul></div><div class=paragraph><p>Para verificar o status do securelevel em um sistema em execução:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl -n kern.securelevel</span></code></pre></div></div><div class=paragraph><p>A saída contém o valor atual do nível de segurança. Se for maior que 0, pelo menos algumas das proteções do securelevel são ativadas.</p></div><div class=paragraph><p>O securelevel de um sistema em execução não pode ser reduzido, pois isso invalidaria seu propósito. Se uma tarefa exigir que o securelevel seja não-positivo, altere as variáveis ​​<code>kern_securelevel</code> e <code>kern_securelevel_enable</code> em <span class=filename>/etc/rc.conf</span> e reinicialize.</p></div><div class=paragraph><p>Para obter mais informações sobre o securelevel e as coisas específicas que todos os níveis fazem, consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=init&amp;sektion=8&amp;format=html">init(8)</a>.</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>O securelevel não é uma bala de prata; tem muitas deficiências conhecidas. Mais frequentemente do que não, fornece uma falsa sensação de segurança.</p></div><div class=paragraph><p>Um dos seus maiores problemas é que, para que seja eficaz, todos os arquivos usados ​​no processo de inicialização até que o nível de segurança seja definido devem ser protegidos. Se um invasor puder fazer o sistema executar seu código antes do nível de segurança que está sendo definido (o que acontece muito tarde no processo de inicialização, pois algumas coisas que o sistema deve fazer na inicialização não podem ser feitas em um nível elevado), suas proteções são invalidadas . Embora essa tarefa de proteger todos os arquivos usados ​​no processo de inicialização não seja tecnicamente impossível, se for obtida, a manutenção do sistema se tornará um pesadelo, já que seria necessário desativar o sistema, pelo menos no modo de usuário único, para modificar um arquivo de configuração.</p></div><div class=paragraph><p>Este ponto e outros são frequentemente discutidos nas listas de discussão, particularmente na <a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-security>lista de discussão de segurança do FreeBSD</a>. Pesquise nos arquivos <a href=https://www.FreeBSD.org/search/>aqui</a> para uma discussão extensa. Um mecanismo mais refinado é o preferido.</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=_o_que_é_essa_conta_uid_0_toor_eu_fui_comprometido>13.3. O que é essa conta UID 0 toor? Eu fui comprometido?<a class=anchor href=#_o_que_é_essa_conta_uid_0_toor_eu_fui_comprometido></a></h3><div class=paragraph><p>Não se preocupe. <code>toor</code> é uma conta de superusuário "alternativa", onde toor é root soletrada para ao contrário. Ele deve ser usado com um shell não padrão, portanto, o shell padrão para <code>root</code> não precisa ser alterado. Isto é importante porque os shells que não fazem parte da distribuição base, mas que são instalados a partir de ports ou packages, são instalados em <span class=filename>/usr/local/bin</span> que, por padrão, reside em um sistema de arquivos diferente . Se o shell do <code>root</code> estiver localizado em <span class=filename>/usr/local/bin</span> e o sistema de arquivos contendo <span class=filename>/usr/local/bin</span>) não está montado, <code>root</code> não poderá efetuar login para corrigir um problema e terá que reinicializar no modo de usuário único para inserir o caminho para um shell.</p></div><div class=paragraph><p>Algumas pessoas usam <code>toor</code> para tarefas do dia-a-dia do <code>root</code> com um shell não padrão, deixando o <code>root</code>, com um shell padrão, para o modo de usuário único ou emergências. Por padrão, um usuário não pode logar usando <code>toor</code> porque ele não tem uma senha, então efetue login como <code>root</code> e defina um senha para <code>toor</code> antes de usá-lo para efetuar login.</p></div></div></div></div><div class=sect1><h2 id=_comunicações_seriais>14. Comunicações Seriais<a class=anchor href=#_comunicações_seriais></a></h2><div class=sectionbody><div class=paragraph><p>Esta seção responde a perguntas comuns sobre comunicação serial com o FreeBSD.</p></div><div class=sect2><h3 id=_como_obtenho_o_prompt_de_boot_em_um_console_serial>14.1. Como obtenho o prompt de boot: em um console serial?<a class=anchor href=#_como_obtenho_o_prompt_de_boot_em_um_console_serial></a></h3><div class=paragraph><p>Veja <a href=https://docs.freebsd.org/pt-br/books/handbook/book/serialcomms#serialconsole-setup>esta seção do Handbook</a>.</p></div></div><div class=sect2><h3 id=_como_sei_se_o_freebsd_encontrou_minhas_portas_seriais_ou_placas_de_modem>14.2. Como sei se o FreeBSD encontrou minhas portas seriais ou placas de modem?<a class=anchor href=#_como_sei_se_o_freebsd_encontrou_minhas_portas_seriais_ou_placas_de_modem></a></h3><div class=paragraph><p>Quando o kernel do FreeBSD for inicializado, ele irá sondar as portas seriais para as quais o kernel está configurado. Observe atentamente as mensagens de inicialização ou execute este comando após o sistema estar ativo e em execução:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>grep</span> <span class=nt>-E</span> <span class=s1>&#39;^(sio|uart)[0-9]&#39;</span> &lt; /var/run/dmesg.boot
sio0: &lt;16550A-compatible COM port&gt; port 0x3f8-0x3ff irq 4 flags 0x10 on acpi0
sio0: <span class=nb>type </span>16550A
sio1: &lt;16550A-compatible COM port&gt; port 0x2f8-0x2ff irq 3 on acpi0
sio1: <span class=nb>type </span>16550A</code></pre></div></div><div class=paragraph><p>Este exemplo mostra duas portas seriais. O primeiro está no IRQ4, endereço de porta <code>0x3f8</code>, e possui um chip UART tipo 16550A. O segundo usa o mesmo tipo de chip, mas está no IRQ3 e está no endereço de porta <code>0x2f8</code>. As placas de modem internas são tratadas como portas seriais, exceto pelo fato de sempre terem um modem conectado à porta.</p></div><div class=paragraph><p>O kernel <span class=filename>GENERIC</span> inclui suporte para duas portas seriais usando as mesmas configurações de IRQ e endereço de porta no exemplo acima. Se estas configurações não forem adequadas para o sistema, ou se houver mais placas de modem ou portas seriais do que o kernel está configurado, reconfigure usando as instruções em <a href=#make-kernel>construindo um kernel</a> para mais detalhes.</p></div></div><div class=sect2><h3 id=_como_eu_acesso_as_portas_seriais_no_freebsd_específico_de_x86>14.3. Como eu acesso as portas seriais no FreeBSD? (específico de x86)<a class=anchor href=#_como_eu_acesso_as_portas_seriais_no_freebsd_específico_de_x86></a></h3><div class=paragraph><p>A terceira porta serial, <span class=filename>sio2</span>, ou <span class=filename>COM3</span>, está em <span class=filename>/dev/cuad2</span> para dispositivos dial-out e em <span class=filename>/dev/ttyd2</span> para dispositivos dial-in. Qual é a diferença entre essas duas classes de dispositivos?</p></div><div class=paragraph><p>Ao abrir <span class=filename>/dev/ttydX</span> no modo de bloqueio, um processo aguardará o dispositivo <span class=filename>cuadX</span> correspondente ficar inativo e, em seguida, aguardar a ativação da linha de detecção. Quando o dispositivo <span class=filename>cuadX</span> é aberto, ele garante que a porta serial não esteja em uso pelo dispositivo <span class=filename>ttydX</span>. Se a porta estiver disponível, ela a rouba do dispositivo <span class=filename>ttydX</span>. Além disso, o dispositivo <span class=filename>cuadX</span> não se importa com a detecção da portadora. Com este esquema e um modem de resposta automática, os usuários remotos podem efetuar login e os usuários locais ainda podem discar com o mesmo modem e o sistema cuidará de todos os conflitos.</p></div></div><div class=sect2><h3 id=_como_habilitar_o_suporte_para_uma_placa_serial_com_várias_portas>14.4. Como habilitar o suporte para uma placa serial com várias portas?<a class=anchor href=#_como_habilitar_o_suporte_para_uma_placa_serial_com_várias_portas></a></h3><div class=paragraph><p>A seção sobre configuração do kernel fornece informações sobre como configurar o kernel. Para uma placa serial com várias portas, coloque uma linha <a href="https://man.freebsd.org/cgi/man.cgi?query=sio&amp;sektion=4&amp;format=html">sio(4)</a> para cada porta serial na placa no <a href="https://man.freebsd.org/cgi/man.cgi?query=device.hints&amp;sektion=5&amp;format=html">device.hints(5)</a>. Mas coloque os especificadores de IRQ em apenas uma das entradas. Todas as portas no cartão devem compartilhar um IRQ. Para consistência, use a última porta serial para especificar o IRQ. Além disso, especifique a seguinte opção no arquivo de configuração do kernel:</p></div><div class="literalblock programlisting"><div class=content><pre>options COM_MULTIPORT</pre></div></div><div class=paragraph><p>O exemplo a seguir <span class=filename>/boot/device.hints</span> é para uma placa serial AST de 4 portas no IRQ 12:</p></div><div class="literalblock programlisting"><div class=content><pre>hint.sio.4.at=&#34;isa&#34;
hint.sio.4.port=&#34;0x2a0&#34;
hint.sio.4.flags=&#34;0x701&#34;
hint.sio.5.at=&#34;isa&#34;
hint.sio.5.port=&#34;0x2a8&#34;
hint.sio.5.flags=&#34;0x701&#34;
hint.sio.6.at=&#34;isa&#34;
hint.sio.6.port=&#34;0x2b0&#34;
hint.sio.6.flags=&#34;0x701&#34;
hint.sio.7.at=&#34;isa&#34;
hint.sio.7.port=&#34;0x2b8&#34;
hint.sio.7.flags=&#34;0x701&#34;
hint.sio.7.irq=&#34;12&#34;</pre></div></div><div class=paragraph><p>Os flags indicam que a porta principal possui um número menor <code>7</code> (<code>0x700</code>) e todas as portas compartilham um IRQ (<code>0x001</code>).</p></div></div><div class=sect2><h3 id=_posso_definir_os_parâmetros_seriais_padrões_para_uma_porta>14.5. Posso definir os parâmetros seriais padrões para uma porta?<a class=anchor href=#_posso_definir_os_parâmetros_seriais_padrões_para_uma_porta></a></h3><div class=paragraph><p>Veja a seção <a href=https://docs.freebsd.org/pt-br/books/handbook/book/serialcomms#serial-hw-config>Comunicações Seriais</a> no Handbook do FreeBSD .</p></div></div><div class=sect2><h3 id=_por_que_não_consigo_executar_o_comando_tip_ou_o_cu>14.6. Por que não consigo executar o comando tip ou o cu?<a class=anchor href=#_por_que_não_consigo_executar_o_comando_tip_ou_o_cu></a></h3><div class=paragraph><p>Os utilitários <a href="https://man.freebsd.org/cgi/man.cgi?query=tip&amp;sektion=1&amp;format=html">tip(1)</a> and <a href="https://man.freebsd.org/cgi/man.cgi?query=cu&amp;sektion=1&amp;format=html">cu(1)</a> só podem acessar o diretório <span class=filename>/var/spool/lock</span> via usuário <code>uucp</code> e grupo <code>dialer</code> . Use o grupo <code>dialer</code> para controlar quem tem acesso ao modem ou sistemas remotos adicionando contas de usuário ao <code>dialer</code>.</p></div><div class=paragraph><p>Como alternativa, todos podem ser configurados para executar <a href="https://man.freebsd.org/cgi/man.cgi?query=tip&amp;sektion=1&amp;format=html">tip(1)</a> e <a href="https://man.freebsd.org/cgi/man.cgi?query=cu&amp;sektion=1&amp;format=html">cu(1)</a> digitando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># chmod 4511 /usr/bin/cu</span>
<span class=c># chmod 4511 /usr/bin/tip</span></code></pre></div></div></div></div></div><div class=sect1><h2 id=_perguntas_diversas>15. Perguntas Diversas<a class=anchor href=#_perguntas_diversas></a></h2><div class=sectionbody><div class=sect2><h3 id=_o_freebsd_usa_muito_espaço_de_swap_mesmo_quando_o_computador_tem_memória_livre_sobrando_por_quê>15.1. O FreeBSD usa muito espaço de swap mesmo quando o computador tem memória livre sobrando. Por quê?<a class=anchor href=#_o_freebsd_usa_muito_espaço_de_swap_mesmo_quando_o_computador_tem_memória_livre_sobrando_por_quê></a></h3><div class=paragraph><p>O FreeBSD irá proativamente mover páginas ociosas e não usadas da memória principal para swap, a fim de disponibilizar mais memória principal para uso ativo. Esse uso pesado de swap é balanceado usando a memória extra livre para armazenamento em cache.</p></div><div class=paragraph><p>Note que enquanto o FreeBSD é proativo a esse respeito, ele não decide arbitrariamente trocar páginas quando o sistema está realmente inativo. Assim, o sistema não será todo paginado depois de deixá-lo ocioso durante a noite.</p></div></div><div class=sect2><h3 id=_por_que_top_mostra_pouca_memória_livre_mesmo_quando_tenho_poucos_programas_em_execução>15.2. Por que top mostra pouca memória livre mesmo quando tenho poucos programas em execução?<a class=anchor href=#_por_que_top_mostra_pouca_memória_livre_mesmo_quando_tenho_poucos_programas_em_execução></a></h3><div class=paragraph><p>A resposta simples é que a memória livre é uma memória desperdiçada. Qualquer memória que os programas não aloquem ativamente é usada pelo kernel do FreeBSD como cache de disco. Os valores mostrados por <a href="https://man.freebsd.org/cgi/man.cgi?query=top&amp;sektion=1&amp;format=html">top(1)</a> rotulados como <code>Inactivo</code> e <code>Laundry</code> são todos os dados armazenados em cache em diferentes níveis de envelhecimento. Esses dados em cache significam que o sistema não precisa acessar um disco lento novamente para os dados que acessou recentemente, aumentando assim o desempenho geral. Em geral, um valor baixo mostrado para a memória <code>Free</code> no <a href="https://man.freebsd.org/cgi/man.cgi?query=top&amp;sektion=1&amp;format=html">top(1)</a> é considerado bom, desde que não seja <em>muito</em> baixo.</p></div></div><div class=sect2><h3 id=_por_que_o_chmod_não_altera_as_permissões_nos_links_simbólicos>15.3. Por que o chmod não altera as permissões nos links simbólicos?<a class=anchor href=#_por_que_o_chmod_não_altera_as_permissões_nos_links_simbólicos></a></h3><div class=paragraph><p>Os links simbólicos não têm permissões e, por padrão, <a href="https://man.freebsd.org/cgi/man.cgi?query=chmod&amp;sektion=1&amp;format=html">chmod(1)</a> seguirá links simbólicos para alterar as permissões no arquivo de origem, se possível. Para o arquivo, <span class=filename>foo</span> com um link simbólico chamado <span class=filename>bar</span>, este comando será sempre bem-sucedido.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>chmod </span>g-w bar</code></pre></div></div><div class=paragraph><p>No entanto, as permissões no arquivo <span class=filename>bar</span> não serão alteradas.</p></div><div class=paragraph><p>Ao alterar os modos das hierarquias de arquivos do usuario root em vez dos próprios arquivos, use <code>-H</code> ou <code>-L</code> junto com <code>-R</code> para este trabalho. Veja <a href="https://man.freebsd.org/cgi/man.cgi?query=chmod&amp;sektion=1&amp;format=html">chmod(1)</a> e <a href="https://man.freebsd.org/cgi/man.cgi?query=symlink&amp;sektion=7&amp;format=html">symlink(7)</a> para mais em formação.</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p><code>-R</code> faz um <a href="https://man.freebsd.org/cgi/man.cgi?query=chmod&amp;sektion=1&amp;format=html">chmod(1)</a> recursivo. Tenha cuidado ao especificar diretórios ou links simbólicos para diretórios para o <a href="https://man.freebsd.org/cgi/man.cgi?query=chmod&amp;sektion=1&amp;format=html">chmod(1)</a>. Para alterar as permissões de um diretório referenciado por um link simbólico, use <a href="https://man.freebsd.org/cgi/man.cgi?query=chmod&amp;sektion=1&amp;format=html">chmod(1)</a> sem nenhuma opção e siga o link simbólico com uma barra à direita (<span class=filename>/</span>). Por exemplo, se <span class=filename>foo</span> for um link simbólico para o diretório <span class=filename>bar</span>, para alterar as permissões de <span class=filename>foo</span> (na verdade <span class=filename>bar</span>) faça algo como:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>chmod </span>555 foo/</code></pre></div></div><div class=paragraph><p>Com a barra final, <a href="https://man.freebsd.org/cgi/man.cgi?query=chmod&amp;sektion=1&amp;format=html">chmod(1)</a> seguirá o link simbólico, <span class=filename>foo</span>, para alterar as permissões do diretório, <span class=filename>bar</span>.</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=_posso_executar_binários_do_dos_no_freebsd>15.4. Posso executar binários do DOS no FreeBSD?<a class=anchor href=#_posso_executar_binários_do_dos_no_freebsd></a></h3><div class=paragraph><p>Sim. Um programa de emulação DOS, <a class=package href=https://cgit.freebsd.org/ports/tree/emulators/doscmd/>emulators/doscmd</a>, está disponível na Coleção de Ports do FreeBSD.</p></div><div class=paragraph><p>Se o doscmd não for suficiente, o <a class=package href=https://cgit.freebsd.org/ports/tree/emulators/pcemu/>emulators/pcemu</a> emulará um 8088 e serviços de BIOS suficientes para executar muitos aplicativos em modo texto do DOS. Requer o sistema de janelas X.</p></div><div class=paragraph><p>A coleção de ports também tem o <a class=package href=https://cgit.freebsd.org/ports/tree/emulators/dosbox/>emulators/dosbox</a>. O foco principal deste aplicativo é emular antigos jogos do DOS usando o sistema de arquivos local para os arquivos.</p></div></div><div class=sect2><h3 id=_o_que_eu_preciso_fazer_para_traduzir_um_documento_do_freebsd_para_minha_língua_nativa>15.5. O que eu preciso fazer para traduzir um documento do FreeBSD para minha língua nativa?<a class=anchor href=#_o_que_eu_preciso_fazer_para_traduzir_um_documento_do_freebsd_para_minha_língua_nativa></a></h3><div class=paragraph><p>Veja a <a href=https://docs.freebsd.org/pt-br/books/fdp-primer/#translations>FAQ de traduções</a> na Documentação do Primer Project do FreeBSD.</p></div></div><div class=sect2><h3 id=_por_que_os_meus_emails_destinados_a_qualquer_endereço_no_dominio_freebsd_org_são_sempre_rejeitados>15.6. Por que os meus emails destinados a qualquer endereço no dominio FreeBSD.org são sempre rejeitados?<a class=anchor href=#_por_que_os_meus_emails_destinados_a_qualquer_endereço_no_dominio_freebsd_org_são_sempre_rejeitados></a></h3><div class=paragraph><p>O sistema de mensagens do <code>FreeBSD.org</code> implementa algumas verificações do Postfix nos e-mails recebidos e rejeita e-mails que são de retransmissões mal configurados ou que parecem ser spam. Alguns dos requisitos específicos são:</p></div><div class=ulist><ul><li><p>O endereço IP do cliente SMTP deve possuir um registro de DNS reverso para encaminhar hostnames confirmados.</p></li><li><p>O nome completo do host fornecido na conversação SMTP (HELO ou EHLO) deve ser resolvido para o endereço IP do cliente.</p></li></ul></div><div class=paragraph><p>Outros conselhos para ajudar suas mensagens a chegar ao seu destino incluem:</p></div><div class=ulist><ul><li><p>O email deve ser enviado em texto simples, e as mensagens enviadas para as listas de discussão geralmente não devem ter mais de 200 KB.</p></li><li><p>Evite postagem cruzadas excessivas. Escolha <em>uma</em> lista de discussão que pareça mais relevante e envie-a para lá.</p></li></ul></div><div class=paragraph><p>Se você ainda tiver problemas com a infra-estrutura de e-mail no <code>FreeBSD.org</code>, envie uma observação com os detalhes para <a href=mailto:postmaster@freebsd.org>postmaster@freebsd.org</a>; Inclua um intervalo de data/hora para que os registros possam ser revisados ​​-- e observe que apenas mantemos uma semana de registros de e-mail. (Certifique-se de especificar o fuso horário ou o deslocamento de UTC.)</p></div></div><div class=sect2><h3 id=_onde_posso_conseguir_uma_conta_gratuita_freebsd>15.7. Onde posso conseguir uma conta gratuita FreeBSD?<a class=anchor href=#_onde_posso_conseguir_uma_conta_gratuita_freebsd></a></h3><div class=paragraph><p>Embora o FreeBSD não forneça acesso aberto a nenhum de seus servidores, outros fornecem sistemas UNIX™ de acesso aberto. A taxa varia e serviços limitados podem estar disponíveis.</p></div><div class=paragraph><p><a href=http://www.arbornet.org/>A Arbornet, Inc </a>, também conhecida como <em>M-Net</em>, oferece acesso livre a sistemas UNIX™ desde 1983. Começando num Altos rodando o System III, o site mudou para o BSD/OS em 1991. Em junho de 2000, o site mudou novamente para o FreeBSD. <em>M-Net</em> pode ser acessado via telnet e SSH e fornece acesso básico a todo o pacote de software FreeBSD. No entanto, o acesso à rede é limitado a membros e usuários que doam para o sistema, que é executado como uma organização sem fins lucrativos. O <em>M-Net</em> também oferece um sistema de quadro de avisos e um bate-papo interativo.</p></div></div><div class=sect2><h3 id=_qual_é_o_nome_do_mascotinho_vermelho>15.8. Qual é o nome do mascotinho vermelho?<a class=anchor href=#_qual_é_o_nome_do_mascotinho_vermelho></a></h3><div class=paragraph><p>Ele não tem um, e é chamado apenas de "o daemon BSD". Se você insistir em usar um nome, chame-o de "beastie". Note que "beastie" é pronunciado "BSD".</p></div><div class=paragraph><p>Mais informações sobre o daemon BSD estão disponíveis em sua <a href=http://www.mckusick.com/beastie/index.html>home page</a>.</p></div></div><div class=sect2><h3 id=_posso_usar_a_imagem_do_daemon_do_bsd>15.9. Posso usar a imagem do daemon do BSD?<a class=anchor href=#_posso_usar_a_imagem_do_daemon_do_bsd></a></h3><div class=paragraph><p>Possivelmente. O daemon BSD tem copyright de Marshall Kirk McKusick. Verifique sua <a href=http://www.mckusick.com/beastie/mainpage/copyright.html>Declaração sobre o Uso da Figura do Daemon do BSD</a> para termos de uso detalhados.</p></div><div class=paragraph><p>Em resumo, a imagem pode ser usada com bom gosto, para uso pessoal, desde que seja dado o crédito apropriado. Antes de usar o logotipo comercialmente, entre em contato com Kirk McKusick <a href=mailto:mckusick@FreeBSD.org>mckusick@FreeBSD.org</a> para obter permissão. Mais detalhes estão disponíveis na <a href=http://www.mckusick.com/beastie/index.html>Home page do BSD Daemon</a>.</p></div></div><div class=sect2><h3 id=_vocês_tem_alguma_imagem_bsd_daemon_que_eu_poderia_usar>15.10. Vocês tem alguma imagem BSD daemon que eu poderia usar?<a class=anchor href=#_vocês_tem_alguma_imagem_bsd_daemon_que_eu_poderia_usar></a></h3><div class=paragraph><p>Desenhos Xfig e eps estão disponíveis em <span class=filename>/usr/shared/examples/BSD_daemon/</span>.</p></div></div><div class=sect2><h3 id=_eu_vi_um_acrônimo_ou_outro_termo_nas_listas_de_discussão_e_não_entendo_o_que_isso_significa_onde_devo_procurar>15.11. Eu vi um acrônimo ou outro termo nas listas de discussão e não entendo o que isso significa. Onde devo procurar?<a class=anchor href=#_eu_vi_um_acrônimo_ou_outro_termo_nas_listas_de_discussão_e_não_entendo_o_que_isso_significa_onde_devo_procurar></a></h3><div class=paragraph><p>Consulte o <a href=https://docs.freebsd.org/pt-br/books/handbook/book/glossary#freebsd-glossary>Glossário do FreeBSD</a>.</p></div></div><div class=sect2><h3 id=_por_que_eu_deveria_me_importar_com_a_cor_da_bikeshed>15.12. Por que eu deveria me importar com a cor da bikeshed?<a class=anchor href=#_por_que_eu_deveria_me_importar_com_a_cor_da_bikeshed></a></h3><div class=paragraph><p>A resposta realmente curta é que você não deveria. A resposta um pouco mais longa é que só porque você é capaz de construir um bikeshed não significa que você deve impedir os outros de construir um só porque você não gosta da cor na qual eles planejam pintá-lo. Esta é uma metáfora indicando que você não precisa discutir sobre cada pequena característica apenas porque você sabe o suficiente para fazê-lo. Algumas pessoas comentaram que a quantidade de ruído gerada por uma mudança é inversamente proporcional à complexidade da mudança.</p></div><div class=paragraph><p>A resposta mais longa e completa é que depois de uma longa discussão sobre se <a href="https://man.freebsd.org/cgi/man.cgi?query=sleep&amp;sektion=1&amp;format=html">sleep(1)</a> deve receber argumentos secundários fracionários, Poul-Henning Kamp <a href=mailto:phk@FreeBSD.org>phk@FreeBSD.org</a> publicou uma longa mensagem intitulada "<a href=http://www.bikeshed.com> Um galpão de bicicleta (qualquer cor serve) na grama mais verde…​</a>"As partes apropriadas dessa mensagem são citadas abaixo.</p></div><div class=paragraph><p>Poul-Henning Kamp <a href=mailto:phk@FreeBSD.org>phk@FreeBSD.org</a> em <a href=http://lists.FreeBSD.org/mailman/listinfo/freebsd-hackers>freebsd-hackers</a> 2 de outubro de 1999
"O que acontece com esse bicicletário? " Alguns de vocês me perguntaram.</p></div><div class=paragraph><p>É uma longa história, ou melhor, é uma história antiga, mas na verdade é bem curta. C. Northcote Parkinson escreveu um livro no início dos anos 1960, chamado "Lei de Parkinson", que contém muitas informações sobre a dinâmica da administração.</p></div><div class=paragraph><p><em>[recorte um pouco o comentário sobre o livro]</em></p></div><div class=paragraph><p>No exemplo específico envolvendo o bicicletário, o outro componente vital é uma usina atômica, acho que isso ilustra a idade do livro.</p></div><div class=paragraph><p>Parkinson mostra como você pode entrar na diretoria e obter aprovação para a construção de uma usina de energia atômica multimilionária ou mesmo bilionária, mas se você quiser construir um galpão de bicicleta, você ficará envolvido em discussões intermináveis.</p></div><div class=paragraph><p>Parkinson explica que isso ocorre porque uma usina atômica é tão vasta, tão cara e tão complicada que as pessoas não conseguem entendê-la e, em vez de tentar, recuam supondo que alguém tenha verificado todos os detalhes antes de chegar tão longe. Richard P. Feynmann dá alguns exemplos interessantes, e muito importantes, relacionados a Los Alamos em seus livros.</p></div><div class=paragraph><p>Uma bicicletário por outro lado. Qualquer um pode construir um desses em um fim de semana e ainda ter tempo de assistir ao jogo na TV. Portanto, não importa o quão bem preparado, não importa o quão razoável você é com a sua proposta, alguém vai aproveitar a chance de mostrar que ele está fazendo o seu trabalho, que ele está prestando atenção, que ele está <em>aqui</em>.</p></div><div class=paragraph><p>Na Dinamarca, chamamos de "definindo sua identidade". É sobre orgulho pessoal e prestígio, é sobre poder apontar para algum lugar e dizer "Lá! <em>Eu</em> fiz aquilo. " É um traço forte nos políticos, mas presente na maioria das pessoas que têm chance. Basta pensar em passos em cimento molhado.</p></div></div></div></div><div class=sect1><h2 id=_coisas_legais_do_freebsd>16. Coisas legais do FreeBSD<a class=anchor href=#_coisas_legais_do_freebsd></a></h2><div class=sectionbody><div class=sect2><h3 id=_quão_legal_é_o_freebsd>16.1. Quão legal é o FreeBSD?<a class=anchor href=#_quão_legal_é_o_freebsd></a></h3><div class="qlist qanda"><ol><li><p><em>Alguém fez algum teste de temperatura durante a execução do FreeBSD? Eu sei que o Linux™ é mais legal que o DOS, mas nunca vi uma menção ao FreeBSD. Parece ser muito rápido.</em></p><p>Não, mas fizemos numerosos testes de gostos em voluntários vendados que também receberam 250 microgramas de LSD-25 administrados antecipadamente. 35% dos voluntários disseram que o FreeBSD tinha um gosto de um tipo de laranja, enquanto o Linux™ tinha gosto de névoa roxa. Nenhum dos grupos mencionou variações significativas na temperatura. Eventualmente nós tivemos que lançar os resultados desta pesquisa completamente de qualquer maneira quando descobrimos que muitos voluntários estavam vagando fora da sala durante os testes, assim distorcendo os resultados. Nós achamos que a maioria dos voluntários está na Apple agora, trabalhando em sua nova GUI "risca e arrisca". É um negócio antigo e engraçado em que estamos!</p></li></ol></div><div class=paragraph><p>Sério, o FreeBSD usa a instrução HLT (halt) quando o sistema está ocioso, reduzindo assim seu consumo de energia e, portanto, o calor gerado. Além disso, se você tiver ACPI (Configuração Avançada e Interface de Energia) configurado, então o FreeBSD também pode colocar a CPU em um modo de baixa energia.</p></div></div><div class=sect2><h3 id=_quem_está_coçando_nos_meus_bancos_de_memória>16.2. Quem está coçando nos meus bancos de memória??<a class=anchor href=#_quem_está_coçando_nos_meus_bancos_de_memória></a></h3><div class="qlist qanda"><ol><li><p><em>Existe alguma coisa "estranha" que o FreeBSD faz ao compilar o kernel que faria com que a memória fizesse um som de algo coçando? Ao compilar (e por um breve momento depois de reconhecer o drive de disquete na inicialização também), um estranho som de algo coçando emana do que parecem ser os bancos de memória.</em></p><p>Sim! Você verá referências freqüentes a "daemons" na documentação do BSD, e o que a maioria das pessoas não sabe é que isso se refere a entidades genuínas e não corporais que agora possuem seu computador. O som áspero vindo de sua memória é, na verdade, um sussurro agudo entre os daemons, pois eles decidem como lidar com várias tarefas de administração do sistema.</p></li></ol></div><div class=paragraph><p>Se o ruído chegar até você, um bom <code>fdisk/mbr</code> do DOS irá se livrar deles, mas não fique surpreso se eles reagirem negativamente e tentarem pará-lo. Na verdade, se em algum momento durante o exercício você ouvir a voz satânica de Bill Gates vindo do alto-falante embutido, saia correndo e não olhe para trás! Livres da influência contrabalançadora dos daemons BSD, os demônios gêmeos do DOS e Windows™ são frequentemente capazes de reafirmar o controle total sobre sua máquina para a danação eterna de sua alma. Agora que você sabe, dada uma escolha, você provavelmente preferiria se acostumar com os ruídos ásperos, não?</p></div></div><div class=sect2><h3 id=_quantos_hackers_do_freebsd_são_necessários_para_trocar_uma_lâmpada>16.3. Quantos hackers do FreeBSD são necessários para trocar uma lâmpada?<a class=anchor href=#_quantos_hackers_do_freebsd_são_necessários_para_trocar_uma_lâmpada></a></h3><div class=paragraph><p>Mil, cento e sessenta e nove:</p></div><div class=paragraph><p>Vinte e três para reclamar com -CURRENT sobre as luzes estarem apagadas;</p></div><div class=paragraph><p>Quatro para afirmar que trata-se de um problema de configuração e que tais questões realmente pertencem a -questions;</p></div><div class=paragraph><p>Três para enviar PRs sobre o assunto, uma das quais está arquivada sob doc e consiste apenas da declaração "está escuro";</p></div><div class=paragraph><p>Um para cometer uma lâmpada não testada que quebra o buildworld, e depois retorna cinco minutos depois;</p></div><div class=paragraph><p>Oito para chamar os remetentes de RP por não incluir patches em seus PRs;</p></div><div class=paragraph><p>Cinco para reclamar sobre o buildworld sendo quebrado;</p></div><div class=paragraph><p>Trinta e um para responder que funciona para eles, e eles devem ter atualizado em um momento ruim;</p></div><div class=paragraph><p>Um para postar um patch para uma nova luz para -hackers;</p></div><div class=paragraph><p>Um para reclamar que ele tinha patches para isso há três anos, mas quando ele os enviou para -CURRENT eles foram ignorados, e ele teve más experiências com o sistema de PRs; além disso, a nova luz proposta não é reflexiva;</p></div><div class=paragraph><p>Trinta e sete para gritar que essa luz não pertencem ao sistema básico, que os committers não têm o direito de fazer coisas assim sem consultar a Comunidade, e O QUE O -CORE ESTÁ FAZENDO SOBRE ISSO!?</p></div><div class=paragraph><p>Duzentos para reclamar da cor do bicicletário;</p></div><div class=paragraph><p>Três para salientar que o patch quebra o <a href="https://man.freebsd.org/cgi/man.cgi?query=style&amp;sektion=9&amp;format=html">style(9)</a>;</p></div><div class=paragraph><p>Dezessete para reclamar que a nova luz proposta está sob a GPL;</p></div><div class=paragraph><p>Quinhentos e oitenta e seis para iniciar uma guerra contra as vantagens comparativas da GPL, da licença da BSD, da licença do MIT, da NPL e da higiene pessoal dos fundadores da FSF, que não são nomeados;</p></div><div class=paragraph><p>Sete para mover várias partes do segmento para -chat e -vocacy;</p></div><div class=paragraph><p>Um para comitar a luz sugerida, mesmo que ela seja mais escura que a antiga;</p></div><div class=paragraph><p>Dois para recuar com uma chama furiosa de uma mensagem de commit, argumentando que o FreeBSD está melhor no escuro do que com uma lâmpada fraca;</p></div><div class=paragraph><p>Quarenta e seis para argumentar veementemente sobre o apoio da luz fraca e exigir uma declaração do alto desempenho;</p></div><div class=paragraph><p>Onze para solicitar uma lâmpada menor para que ela caiba em seu Tamagotchi se decidirmos portar o FreeBSD para essa plataforma;</p></div><div class=paragraph><p>Setenta e três para reclamar sobre o SNR em -chackers e -chat e cancelar a inscrição em protesto;</p></div><div class=paragraph><p>Treze para postar "cancelar a inscrição", " Como posso cancelar a inscrição? ", ou "Por favor, remova-me da lista", seguido do rodapé habitual;</p></div><div class=paragraph><p>Um para comitar uma lâmpada de trabalho enquanto todos estão ocupados demais chamando a atenção de todos os outros para esse commit;</p></div><div class=paragraph><p>Trinta e um para salientar que a nova lâmpada iria brilhar 0,364% a mais se compilada com TenDRA (embora tenha que ser reformulada em um cubo), e que o FreeBSD deve, portanto, mudar para TenDRA ao invés de GCC;</p></div><div class=paragraph><p>Um para reclamar que a nova lâmpada não tem carenagem;</p></div><div class=paragraph><p>Nove (incluindo os criadores de PRs) para perguntar "o que é o MFC?";</p></div><div class=paragraph><p>Cinquenta e sete para se queixar das luzes apagadas duas semanas depois de a lâmpada ter sido trocada.</p></div><div class=paragraph><p><em>Nik Clayton</em> <a href=mailto:nik@FreeBSD.org>nik@FreeBSD.org</a> acrescenta:</p></div><div class=paragraph><p><em>Eu estava rindo bastante disso.</em></p></div><div class=paragraph><p><em>E então eu pensei, " Espere, não deveria haver '1 para documentar isso.' nessa lista em algum lugar? "</em></p></div><div class=paragraph><p><em>E então eu fui iluminado :-)</em></p></div><div class=paragraph><p><em>Thomas Abthorpe</em> <a href=mailto:tabthorpe@FreeBSD.org>tabthorpe@FreeBSD.org</a> diz: " Nenhum, um hacker <em>real</em> do FreeBSD não têm medo do escuro! "</p></div></div><div class=sect2><h3 id=_onde_os_dados_gravados_em_devnull_vão_parar>16.4. Onde os dados gravados em /dev/null vão parar?<a class=anchor href=#_onde_os_dados_gravados_em_devnull_vão_parar></a></h3><div class=paragraph><p>Ele entra em um coletor de dados especial na CPU, onde é convertido em calor que é ventilado através do conjunto do dissipador de calor / ventilador. É por isso que o resfriamento da CPU é cada vez mais importante; À medida que as pessoas se acostumam com processadores mais rápidos, elas se tornam descuidadas com seus dados e mais e mais delas acabam no <span class=filename>/dev/null</span>, superaquecendo suas CPUs. Se você apagar <span class=filename>/dev/null</span> (o que efetivamente desativa o dissipador de dados da CPU) sua CPU pode ficar mais fria, mas seu sistema rapidamente ficará constipado com todos esses dados em excesso e começará a se comportar de maneira irregular. Se você tem uma conexão de rede rápida, pode resfriar sua CPU lendo dados de <span class=filename>/dev/random</span> e enviá-los para algum lugar; No entanto, você corre o risco de superaquecer sua conexão de rede e <span class=filename>/</span> ou irritar seu ISP, pois a maioria dos dados acabará sendo convertida em calor pelo equipamento, mas eles geralmente têm um bom resfriamento, então se você não exagere você deve estar bem.</p></div><div class=paragraph><p><em>Paul Robinson acrescenta:</em></p></div><div class=paragraph><p>Existem outros métodos. Como todo bom administrador de sistemas sabe, é parte da prática padrão enviar dados para a tela de variedade interessante para manter todos os pixies que compõem sua imagem felizes. Os duendes de tela (comumente com erros de digitação ou renomeados como "pixels") são categorizados pelo tipo de chapéu que usam (vermelho, verde ou azul) e serão ocultados ou exibidos (mostrando a cor do chapéu ) sempre que recebem um pequeno pedaço de comida. Placas de vídeo transformam dados em comida de duende, e então os enviam para os duendes - quanto mais cara a carta, melhor a comida, então é melhor que os pixies se comportem melhor. Eles também precisam de estímulo constante - é por isso que existem proteções de tela.</p></div><div class=paragraph><p>Para levar suas sugestões adiante, você poderia simplesmente jogar os dados aleatórios no console, permitindo que os duendes os consumam. Isso faz com que nenhum calor seja produzido, mantém os pixies felizes e se livra de seus dados rapidamente, mesmo que isso faça as coisas parecerem um pouco confusas na sua tela.</p></div><div class=paragraph><p>Incidentalmente, como um ex-administrador de um grande ISP que teve muitos problemas ao tentar manter uma temperatura estável em uma sala de servidores, eu desencorajaria fortemente as pessoas que enviam os dados que não querem para a rede. As fadas que fazem a troca e o encaminhamento de pacotes também se irritam com isso.</p></div></div><div class=sect2><h3 id=_minha_colega_fica_muito_no_computador_como_eu_posso_brincar_com_ela>16.5. Minha colega fica muito no computador, como eu posso brincar com ela?<a class=anchor href=#_minha_colega_fica_muito_no_computador_como_eu_posso_brincar_com_ela></a></h3><div class=paragraph><p>Instale o <a class=package href=https://cgit.freebsd.org/ports/tree/games/sl/>games/sl</a> e espere ela digitar <code>sl</code> para <code>ls</code>.</p></div></div></div></div><div class=sect1><h2 id=_tópicos_avançados>17. Tópicos Avançados<a class=anchor href=#_tópicos_avançados></a></h2><div class=sectionbody><div class=sect2><h3 id=_como_posso_aprender_mais_sobre_os_componentes_internos_do_freebsd>17.1. Como posso aprender mais sobre os componentes internos do FreeBSD?<a class=anchor href=#_como_posso_aprender_mais_sobre_os_componentes_internos_do_freebsd></a></h3><div class=paragraph><p>Veja o <a href=https://docs.freebsd.org/en/books/arch-handbook/>Handbook de Arquitetura do FreeBSD</a>.</p></div><div class=paragraph><p>Além disso, muito do conhecimento geral sobre o UNIX™ é diretamente aplicável ao FreeBSD.</p></div></div><div class=sect2><h3 id=_como_posso_contribuir_para_o_freebsd_o_que_posso_fazer_para_ajudar>17.2. Como posso contribuir para o FreeBSD? O que posso fazer para ajudar?<a class=anchor href=#_como_posso_contribuir_para_o_freebsd_o_que_posso_fazer_para_ajudar></a></h3><div class=paragraph><p>Nós aceitamos todos os tipos de contribuições: documentação, código e até mesmo arte. Veja o artigo <a href=https://docs.freebsd.org/pt-br/articles/contributing/>Contribuindo com o FreeBSD</a> para obter maiores informações sobre como fazer isso.</p></div><div class=paragraph><p>E obrigado por considerar nos ajudar!</p></div></div><div class=sect2><h3 id=_o_que_são_snapshots_e_releases>17.3. O que são Snapshots e Releases?<a class=anchor href=#_o_que_são_snapshots_e_releases></a></h3><div class=paragraph><p>Atualmente existem 3 branches ativas/semi-ativas no <a href=http://svnweb.FreeBSD.org/base/>Repositório Subversion</a> do FreeBSD. (Os branches anteriores são alterados muito raramente, e é por isso que existem apenas 3 branches ativas de desenvolvimento):</p></div><div class=ulist><ul><li><p>stable/11/ AKA <em>11-STABLE</em></p></li><li><p>stable/12/ AKA <em>12-STABLE</em></p></li><li><p>head/ AKA <em>-CURRENT</em> AKA <em>13-CURRENT</em></p></li></ul></div><div class=paragraph><p><code>HEAD</code> não é uma tag de branch real. É uma constante simbólica para o fluxo de desenvolvimento atual, não ramificado, conhecido como <em>-CURRENT</em>.</p></div><div class=paragraph><p>No momento, o <em>-CURRENT</em> é o fluxo de desenvolvimento 13.<em>X</em>; o branch <em>12-STABLE</em>, stable/12/, derivou do <em>-CURRENT</em> em Dezembro de 2018 e o branch ​​<em>11-STABLE</em>,stable/11/, derivou do <em>-CURRENT</em> em Outubro de 2016.</p></div></div><div class=sect2><h3 id=_como_posso_aproveitar_ao_máximo_os_dados_que_vejo_quando_meu_kernel_entra_em_panic>17.4. Como posso aproveitar ao máximo os dados que vejo quando meu kernel entra em panic?<a class=anchor href=#_como_posso_aproveitar_ao_máximo_os_dados_que_vejo_quando_meu_kernel_entra_em_panic></a></h3><div class=paragraph><p>Aqui está um panic típico do kernel:</p></div><div class="literalblock programlisting"><div class=content><pre>Fatal trap 12: page fault while in kernel mode
fault virtual address   = 0x40
fault code              = supervisor read, page not present
instruction pointer     = 0x8:0xf014a7e5
stack pointer           = 0x10:0xf4ed6f24
frame pointer           = 0x10:0xf4ed6f28
code segment            = base 0x0, limit 0xfffff, type 0x1b
                        = DPL 0, pres 1, def32 1, gran 1
processor eflags        = interrupt enabled, resume, IOPL = 0
current process         = 80 (mount)
interrupt mask          =
trap number             = 12
panic: page fault</pre></div></div><div class=paragraph><p>Esta mensagem não é suficiente. Embora o valor do ponteiro de instrução seja importante, ele também depende da configuração, pois varia dependendo da imagem do kernel. Se for uma imagem de kernel <span class=filename>GENERIC</span> de um dos snapshots, é possível que alguém rastreie a função problemática, mas para um kernel personalizado, somente você pode nos dizer onde a falha ocorreu.</p></div><div class=paragraph><p>Para prosseguir:</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Anote o valor do ponteiro de instrução. Note que a parte <code>0x8:</code> no começo não é relevante neste caso: é a parte <code>0xf0xxxxxx</code> que nós queremos.</p></li><li><p>Quando o sistema for reinicializado, faça o seguinte:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% nm <span class=nt>-n</span> kernel.that.caused.the.panic | <span class=nb>grep </span>f0xxxxxx</code></pre></div></div><div class=paragraph><p>no qual <code>f0xxxxxx</code> é o valor do ponteiro de instrução. As probabilidades são de que você não obterá uma correspondência exata, pois os símbolos na tabela de símbolos do kernel são para os pontos de entrada das funções e o endereço do ponteiro de instrução estará em algum lugar dentro de uma função, não no início. Se você não obtiver uma correspondência exata, omita o último dígito do valor do ponteiro de instrução e tente novamente:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% nm <span class=nt>-n</span> kernel.that.caused.the.panic | <span class=nb>grep </span>f0xxxxx</code></pre></div></div><div class=paragraph><p>Se isso não produzir nenhum resultado, corte outro dígito. Repita até que haja algum tipo de saída. O resultado será uma possível lista das funções que causaram o panic. Este é um mecanismo menos do que exato para rastrear o ponto de falha, mas é melhor do que nada.</p></div></li></ol></div></div></div><div class=paragraph><p>No entanto, a melhor maneira de rastrear a causa de um panic é capturar um despejo de memória e usar o <a href="https://man.freebsd.org/cgi/man.cgi?query=kgdb&amp;sektion=1&amp;format=html">kgdb(1)</a> para gerar um rastreamento de pilha no despejo de memória.</p></div><div class=paragraph><p>Em qualquer caso, o método é este:</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Certifique-se de que a seguinte linha esteja incluída no arquivo de configuração do kernel:</p><div class="literalblock programlisting"><div class=content><pre>makeoptions     DEBUG=-g          # Build kernel with gdb(1) debug symbols</pre></div></div></li><li><p>Mude para o diretório <span class=filename>/usr/src</span>:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/src</span></code></pre></div></div></li><li><p>Compile o kernel:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># make buildkernel KERNCONF=MYKERNEL</span></code></pre></div></div></li><li><p>Aguarde até o <a href="https://man.freebsd.org/cgi/man.cgi?query=make&amp;sektion=1&amp;format=html">make(1)</a> terminar a compilação.</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># make installkernel KERNCONF=MYKERNEL</span></code></pre></div></div></li><li><p>Reinicie.</p></li></ol></div></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Se a variável <code>KERNCONF</code> não for informada na linha de comando, o kernel <span class=filename>GENERIC</span> será compilado e instalado.</p></div></td></tr></tbody></table></div><div class=paragraph><p>O processo <a href="https://man.freebsd.org/cgi/man.cgi?query=make&amp;sektion=1&amp;format=html">make(1)</a> terá compilado dois kernels. O <span class=filename>/usr/obj/usr/src/sys/MYKERNEL/kernel</span> e o <span class=filename>/usr/obj/usr/src/sys/MYKERNEL/kernel.debug</span>. O <span class=filename>kernel</span> foi instalado como <span class=filename>/boot/kernel/kernel</span>, enquanto o <span class=filename>kernel.debug</span> pode ser usado como fonte de símbolos de depuração para o <a href="https://man.freebsd.org/cgi/man.cgi?query=kgdb&amp;sektion=1&amp;format=html">kgdb(1)</a>.</p></div><div class=paragraph><p>Para capturar um despejo de memória, edite o <span class=filename>/etc/rc.conf</span> e defina o <code>dumpdev</code> para apontar para a partição de swap ou para <code>AUTO</code>. Isso fará com que os scripts <a href="https://man.freebsd.org/cgi/man.cgi?query=rc&amp;sektion=8&amp;format=html">rc(8)</a> usem o comando <a href="https://man.freebsd.org/cgi/man.cgi?query=dumpon&amp;sektion=8&amp;format=html">dumpon(8)</a> para ativar os despejos de memória. Este comando também pode ser executado manualmente. Após um panic, o despejo de memória pode ser recuperado usando o <a href="https://man.freebsd.org/cgi/man.cgi?query=savecore&amp;sektion=8&amp;format=html">savecore(8)</a>; se o <code>dumpdev</code> estiver configurado em <span class=filename>/etc/rc.conf</span>, os scripts <a href="https://man.freebsd.org/cgi/man.cgi?query=rc&amp;sektion=8&amp;format=html">rc(8)</a> executarão o <a href="https://man.freebsd.org/cgi/man.cgi?query=savecore&amp;sektion=8&amp;format=html">savecore(8)</a> automaticamente e colocarão o despejo de memória em <span class=filename>/var/crash</span>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Os despejos de memória do FreeBSD são geralmente do mesmo tamanho que a RAM física. Portanto, verifique se há espaço suficiente em <span class=filename>/var/crash</span> para manter o despejo. Como alternativa, execute <a href="https://man.freebsd.org/cgi/man.cgi?query=savecore&amp;sektion=8&amp;format=html">savecore(8)</a> manualmente e faça com que recupere o despejo de memória para outro diretório com mais espaço. É possível limitar o tamanho do despejo de memória usando <code>options MAXMEM=N</code> onde <em>N</em> é o tamanho da memória utilizada do kernel em KBs. Por exemplo, para 1 GB de RAM, limite o uso de memória pelo kernel a 128 MB, para que o tamanho do despejo de memória seja de 128 MB em vez de 1 GB.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Depois que o despejo de memória for recuperado, obtenha um rastreamento de pilha da seguinte maneira:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% kgdb /usr/obj/usr/src/sys/MYKERNEL/kernel.debug /var/crash/vmcore.0
<span class=o>(</span>kgdb<span class=o>)</span> backtrace</code></pre></div></div><div class=paragraph><p>Note que pode haver várias telas de informação valiosa. Idealmente, use <a href="https://man.freebsd.org/cgi/man.cgi?query=script&amp;sektion=1&amp;format=html">script(1)</a> para capturar todas elas. Usar a imagem do kernel unstripped com todos os símbolos de depuração deve mostrar a linha exata do código fonte do kernel onde o panic ocorreu. O rastreamento de pilha geralmente é lido de baixo para cima para rastrear a sequência exata de eventos que levam à falha. O <a href="https://man.freebsd.org/cgi/man.cgi?query=kgdb&amp;sektion=1&amp;format=html">kgdb(1)</a> também pode ser usado para imprimir o conteúdo de várias variáveis ​​ou estruturas para examinar o estado do sistema no momento da falha.</p></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Se um segundo computador estiver disponível, o <a href="https://man.freebsd.org/cgi/man.cgi?query=kgdb&amp;sektion=1&amp;format=html">kgdb(1)</a> pode ser configurado para fazer uma depuração remota, incluindo pontos de interrupção de configuração e passos únicos através do código do kernel.</p></div></td></tr></tbody></table></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Se o <code>DDB</code> estiver habilitado e o kernel cair no depurador, um panic e um despejo de memória podem ser forçados digitando <code>panic</code> no prompt do <code>ddb</code>. O processo pode parar no depurador novamente durante a fase de panic. Se isso acontecer, digite <code>continue</code> e ele concluirá o despejo de memória.</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=_por_que_dlsym_parou_de_funcionar_para_executáveis_elf>17.5. Por que dlsym() parou de funcionar para executáveis ​​ELF?<a class=anchor href=#_por_que_dlsym_parou_de_funcionar_para_executáveis_elf></a></h3><div class=paragraph><p>A toolchain ELF não faz, por padrão, os símbolos definidos em um executável visíveis para o vinculador dinâmico. Consequentemente, a busca da função <code>dlsym()</code> por identificadores obtidos de chamadas para <code>dlopen(NULL, flags)</code> não conseguirá encontrar tais símbolos.</p></div><div class=paragraph><p>Para pesquisar, usando a função <code>dlsym()</code>, os símbolos presentes no executável principal de um processo, vincule o executável usando a opção <code>- export-dynamic</code> ao vinculador ELF (<a href="https://man.freebsd.org/cgi/man.cgi?query=ld&amp;sektion=1&amp;format=html">ld(1)</a>).</p></div></div><div class=sect2><h3 id=_como_posso_aumentar_ou_reduzir_o_espaço_de_endereçamento_do_kernel_em_uma_máquina_i386>17.6. Como posso aumentar ou reduzir o espaço de endereçamento do kernel em uma máquina i386?<a class=anchor href=#_como_posso_aumentar_ou_reduzir_o_espaço_de_endereçamento_do_kernel_em_uma_máquina_i386></a></h3><div class=paragraph><p>Por padrão, o espaço de endereço do kernel é de 1 GB (2 GB para PAE) para a arquitetura i386. Se você estiver executando um servidor com uso intensivo de rede ou utilizando o ZFS, isso provavelmente não será suficiente.</p></div><div class=paragraph><p>Adicione a seguinte linha ao arquivo de configuração do kernel para aumentar o espaço disponível e recompile o kernel:</p></div><div class="literalblock programlisting"><div class=content><pre>options KVA_PAGES=N</pre></div></div><div class=paragraph><p>Para encontrar o valor correto de <em>N</em>, divida o tamanho do espaço de endereço desejado (em megabytes) por quatro. (Por exemplo, é <code>512</code> para 2 GB.)</p></div></div></div></div><div class=sect1><h2 id=_agradecimentos>18. Agradecimentos<a class=anchor href=#_agradecimentos></a></h2><div class=sectionbody><div class=paragraph><p>Este inocente documento de Perguntas Frequentes foi escrito, reescrito, editado, dobrado, fustigado, mutilado, eviscerado, contemplado, desconcertado, cogitado, regurgitado, reconstruído, castigado e revigorado na última década, por um elenco de centenas, se não milhares de voluntários. Repetidamente.</p></div><div class=paragraph><p>Gostaríamos de agradecer a cada uma das pessoas responsáveis, e nós o encorajamos a <a href=https://docs.freebsd.org/pt-br/articles/contributing/>se juntar a eles</a> para tornar este FAQ ainda melhor.</p></div></div></div></div><hr><div class=last-modified><p><strong>Última alteração em</strong>: 14 de janeiro de 2022 por <a href="https://cgit.freebsd.org/doc/commit/?id=0c272255af" target=_blank>Li-Wen Hsu</a></p></div><div class=buttons><div class=home><i class="fa fa-home" aria-hidden=true title=Início></i><div class=container><a href=../ class=direction>Início</a></div></div></div><label class="hidden book-menu-overlay" for=menu-control></label></div><aside class=toc><div class=toc-content><h3>Índice</h3><nav id=TableOfContents><ul><li><a href=#_introdução>1. Introdução</a></li><li><a href=#_documentação_e_suporte>2. Documentação e Suporte</a></li><li><a href=#_instalação>3. Instalação</a></li><li><a href=#_compatibilidade_de_hardware>4. Compatibilidade de Hardware</a></li><li><a href=#_solução_de_problemas>5. Solução de problemas</a></li><li><a href=#_aplicativos_do_usuário>6. Aplicativos do Usuário</a></li><li><a href=#_configuração_do_kernel>7. Configuração do Kernel</a></li><li><a href=#_discos_sistemas_de_arquivos_e_boot_loaders>8. Discos, sistemas de arquivos e boot loaders</a></li><li><a href=#_zfs>9. ZFS</a></li><li><a href=#_administração_do_sistema>10. Administração do Sistema</a></li><li><a href=#_o_sistema_x_window_e_consoles_virtuais>11. O sistema X Window e consoles virtuais</a></li><li><a href=#_networking>12. Networking</a></li><li><a href=#_segurança>13. Segurança</a></li><li><a href=#_comunicações_seriais>14. Comunicações Seriais</a></li><li><a href=#_perguntas_diversas>15. Perguntas Diversas</a></li><li><a href=#_coisas_legais_do_freebsd>16. Coisas legais do FreeBSD</a></li><li><a href=#_tópicos_avançados>17. Tópicos Avançados</a></li><li><a href=#_agradecimentos>18. Agradecimentos</a></li></ul></nav><hr><div class=resources><h3>Recursos</h3><ul class=contents><li><i class="fa fa-file-pdf-o" aria-hidden=true title="Download PDF"></i><a href=https://download.freebsd.org/doc/pt-br/books/faq/faq_pt-br.pdf>Download PDF</a></li><li><i class="fa fa-pencil-square-o" aria-hidden=true title="Edite essa página"></i><a href=https://github.com/freebsd/freebsd-doc/blob/main/documentation/content/pt-br/_index target=_blank>Edite essa página</a></li></ul></div></div></aside><a class=to-top href=#top><i class="fa fa-arrow-circle-up" aria-hidden=true></i></a></main><footer><div class=footer-container><section class=logo-column><img src=http://172.16.201.134:1313/images/FreeBSD-colors.svg width=160 height=50 alt="FreeBSD logo"><div class=options-container><div class=language-container><a id=languages href=http://172.16.201.134:1313/pt-br/languages><img src=http://172.16.201.134:1313/images/language.png class=language-image alt="Escolha o idioma">
<span>Brazilian Portuguese</span></a></div><div class=theme-container><select id=theme-chooser><option value=theme-system>System</option><option value=theme-light>Light</option><option value=theme-dark>Dark</option><option value=theme-high-contrast>Alto contraste</option></select></div></div></section><section class=about-column><h3 class=column-title>About</h3><ul class=column-elements-container><li><a href=https://www.freebsd.org/about/ target=_blank class=column-element>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/ target=_blank class=column-element>FreeBSD Foundation</a></li><li><a href=https://www.freebsd.org/where/ target=_blank class=column-element>Get FreeBSD</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct target=_blank class=column-element>Code of Conduct</a></li><li><a href=https://www.freebsd.org/security/ target=_blank class=column-element>Security Advisories</a></li></ul></section><section class=documentation-column><h3 class=column-title>Documentation</h3><ul class=column-elements-container><li><a href=/pt-br class=column-element>Documentation portal</a></li><li><a href=https://man.FreeBSD.org target=_blank class=column-element>Manual pages</a></li><li><a href=https://papers.FreeBSD.org target=_blank class=column-element>Presentations and papers</a></li><li><a href=https://docs-archive.freebsd.org/doc/ target=_blank class=column-element>Previous versions</a></li><li><a href=https://docs-archive.freebsd.org/44doc/ target=_blank class=column-element>4.4BSD Documents</a></li><li><a href=https://wiki.freebsd.org/ target=_blank class=column-element>Wiki</a></li></ul></section><section class=community-column><h3 class=column-title>Community</h3><ul class=column-elements-container><li><a href=http://172.16.201.134:1313/pt-br/articles/contributing class=column-element>Get involved</a></li><li><a href=https://forums.freebsd.org/ target=_blank class=column-element>Community forum</a></li><li><a href=https://lists.freebsd.org/ target=_blank class=column-element>Mailing lists</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank class=column-element>IRC Channels</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank class=column-element>Bug Tracker</a></li></ul></section><section class=legal-column><h3 class=column-title>Legal</h3><ul class=column-elements-container><li><a href=https://freebsdfoundation.org/donate/ target=_blank class=column-element>Donations</a></li><li><a href=https://www.freebsd.org/copyright/freebsd-license/ target=_blank class=column-element>Licensing</a></li><li><a href=https://www.freebsd.org/privacy/ target=_blank class=column-element>Privacy Policy</a></li><li><a href=https://www.freebsd.org/copyright/ target=_blank class=column-element>Legal notices</a></li></ul></section><section class=copyright-column><p>&copy; 1994-2024 The FreeBSD Project. All rights reserved</p><span>Made with <span class=heart>♥</span> by the FreeBSD Community</span></section></div></footer></body></html>