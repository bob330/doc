<!doctype html><html class=theme-light lang=hu><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content><meta name=keywords content><meta name=copyright content="1995-2024 The FreeBSD Foundation"><link rel=canonical href=http://172.16.201.134:1313/hu/books/faq/><title>Gyakran Ismételt Kérdések a FreeBSD 6.X, 7.X és 8.X változatairól | FreeBSD Documentation Portal</title>
<meta name=theme-color content="#790000"><meta name=color-scheme content="system light dark high-contrast"><link rel="shortcut icon" href=http://172.16.201.134:1313/favicon.ico><link rel=stylesheet href=http://172.16.201.134:1313/styles/main.min.css><link rel=stylesheet href=http://172.16.201.134:1313/css/font-awesome-min.css><script defer src=/js/theme-chooser.min.js></script><script defer src=/js/copy-clipboard.min.js></script><script defer src=/js/search.min.js></script><meta name=twitter:card content="summary"><meta name=twitter:domain content="docs.FreeBSD.org"><meta name=twitter:site content="@freebsd"><meta name=twitter:url content="https://twitter.com/freebsd"><meta property="og:title" content="Gyakran Ismételt Kérdések a FreeBSD 6.X, 7.X és 8.X változatairól"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:image" content="http://172.16.201.134:1313/favicon.ico"><meta property="og:image:alt" content="FreeBSD Logo"><meta property="og:locale" content="hu"><meta property="og:url" content="http://172.16.201.134:1313/hu/books/faq/"><meta property="og:site_name" content="FreeBSD Documentation Portal"><script type=application/ld+json>{"@context":"http://schema.org","@type":"Article","url":"http:\/\/172.16.201.134:1313\/hu\/books\/faq\/","name":"FreeBSD Documentation Portal","headline":"FreeBSD Documentation Portal","description":"FreeBSD Documentation Portal"}</script></head><body><header><div class=header-container><div class=logo-menu-bars-container><a href=https://www.FreeBSD.org class=logo><img src=http://172.16.201.134:1313/images/FreeBSD-monochromatic.svg width=160 height=50 alt="FreeBSD logo">
</a><label class=menu-bars for=menu-bars><i class="fa fa-bars" aria-hidden=true></i></label></div><input id=menu-bars type=checkbox><nav><ul class=menu><li class=menu-item><input id=about type=checkbox>
<a href=# aria-label="Navigate to About section"><label class=menu-item-description for=about>About
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/about/ target=_blank>About</a></li><li><a href=https://www.freebsd.org/about/ target=_blank>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/about-us/about-the-foundation/ target=_blank>FreeBSD Foundation</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct/ target=_blank>Code of Conduct</a></li></ul></li><li class=menu-item><input id=download type=checkbox>
<a href=# aria-label="Navigate to get FreeBSD section"><label class=menu-item-description for=download>Get FreeBSD
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/where/ target=_blank>Get FreeBSD</a></li><li><a href=https://www.freebsd.org/releases/ target=_blank>Release Information</a></li><li><a href=https://www.freebsd.org/releng/ target=_blank>Release Engineering</a></li><li><a href=https://www.freebsd.org/security/ target=_blank>Security Advisories</a></li></ul></li><li class=menu-item><input id=documentation type=checkbox>
<a href=# aria-label="Navigate to get Documentation section"><label class=menu-item-description for=documentation>Documentation
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=/hu>Documentation portal</a></li><li><a href=http://172.16.201.134:1313/hu/books/handbook>FreeBSD Handbook</a></li><li><a href=http://172.16.201.134:1313/hu/books/porters-handbook>Porter's Handbook</a></li><li><a href=https://docs.FreeBSD.org/en/books/fdp-primer>Documentation Project Handbook</a></li><li><a href=https://man.FreeBSD.org target=_blank>Manual pages</a></li><li><a href=https://papers.FreeBSD.org target=_blank>Presentations and papers</a></li><li><a href=https://wiki.FreeBSD.org target=_blank>Wiki</a></li><li><a href=http://172.16.201.134:1313/hu/books>Books</a></li><li><a href=http://172.16.201.134:1313/hu/articles>Articles</a></li></ul></li><li class=menu-item><input id=community type=checkbox>
<a href=# aria-label="Navigate to get Community section"><label class=menu-item-description for=community>Community
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/community/>Community</a></li><li><a href=http://172.16.201.134:1313/hu/articles/contributing>Get involved</a></li><li><a href=https://forums.freebsd.org/ target=_blank>Forum</a></li><li><a href=https://lists.freebsd.org/ target=_blank>Mailing lists</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank>IRC Channels</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank>Bug Tracker</a></li><li><a href=https://www.freebsd.org/support/ target=_blank>Support</a></li></ul></li></ul></nav><div class=search-donate-container><form class=search method=get id=search-header-form action=https://docs.freebsd.org/search name=search-header-form><input type=hidden name=DB value=hu>
<input id=words name=P type=text size=20 maxlength=255>
<button>
<i class="fa fa-search" aria-hidden=true></i></button></form><div class=donate><a href=https://freebsdfoundation.org/donate/ target=_blank><span class=heart>♥</span>
Donate</a></div></div></div></header><input type=checkbox class="hidden toggle" id=menu-control><main class=main-wrapper-book><a id=top></a><div class=book><h1 class=title>Gyakran Ismételt Kérdések a FreeBSD 6.X, 7.X és 8.X változatairól</h1><div class="admonitionblock note"><p><i class="fa fa-exclamation-circle" aria-hidden=true></i>
This translation may be out of date. To help with the translations please access the <a href=https://translate-dev.freebsd.org/ target=_blank>FreeBSD translations instance</a>.</p></div><div class=copyright>Copyright © 1995-2020 A FreeBSD Dokumentációs Projekt</div><div class=legalnotice><a id=trademarks></a><details><summary>trademarks</summary><p>A FreeBSD a FreeBSD Foundation bejegyzett védjegye.</p><p>Az IBM, AIX, OS/2, PowerPC, PS/2, S/390 és ThinkPad az International Business Machines Corporation védjegyei az Egyesült Államokban, más országokban, vagy mindkettõben.</p><p>Az IEEE, POSIX és 802 az Institute of Electrical and Electronics Engineers, Inc. bejegyzett védjegyei az Egyesült Államokban.</p><p>A 3Com és HomeConnect a 3Com Corporation bejegyzett védjegyei.</p><p>Az Adobe, Acrobat, Acrobat Reader, és PostScript az Adobe Systems Incorporated bejegyzett védjegyei, vagy védjegyei az Egyesült Államokban és/vagy más országokban.</p><p>Az Intel, Celeron, EtherExpress, i386, i486, Itanium, Pentium és Xeon az Intel Corporation vagy leányvállalatainak védjegyei vagy bejegyzett védjegyei az Egyesült Államokban és más országokban.</p><p>A Linux Linus Torvalds bejegyzett védjegye.</p><p>A Microsoft, IntelliMouse, MS-DOS, Outlook, Windows, Windows Media és Windows NT a Microsoft Corporation bejegyzett veacute;djegyei, vagy védjegyei az Egyesült Államokban és/vagy más országokban.</p><p>A Motif, OSF/1 és UNIX a The Open Group bejegyzett védjegyei, az IT DialTone és a The Open Group pedig védjegyei az Egyesült államokban és/vagy más országokban.</p><p>A SPARC, SPARC64, és UltraSPARC a SPARC International, Inc védjegyei az Egyesült államokban és más országokban. A SPARC International, Inc birtokolja az összes SPARC védjegyet és annak tagjai között teszi azok megfelelõ használatát elérhetõvé a licencelési megegyezések alapján.</p><p>A Sun, Sun Microsystems, Java, Java Virtual Machine, JDK, JRE, JSP, JVM, Netra, OpenJDK, Solaris, StarOffice, SunOS és VirtualBox a Sun Microsystems, Inc. védjegyei vagy bejegyzett védjegyei az Egyesült Államokban és más országokban.</p><p>Az Oracle az Oracle Corporation bejegyzett védjegye.</p><p>Az XFree86 az XFree86 Project, Inc. védjegye.</p><p>A gyártók és terjesztõk által használt megnevezések közül sok védjegy jogot követel. Ahol ilyen megnevezés tûnik fel ebben a dokumentumban, és a FreeBSD Projektnek tudomása volt a védjegyrõl, a megnevezést a “™” vagy a “®” szimbólum követi.</p></details></div><div class=toc-mobile><h3>Table of Contents</h3><nav id=TableOfContents><ul><li><a href=#_bevezetés>1. Bevezetés</a></li><li><a href=#_dokumentációs_és_támogatás>2. Dokumentációs és támogatás</a></li><li><a href=#_telepítés>3. Telepítés</a></li><li><a href=#hardware>4. Hardverkompatibilitás</a></li><li><a href=#_hibaelhárítás>5. Hibaelhárítás</a></li><li><a href=#_kereskedelmi_alkalmazások>6. Kereskedelmi alkalmazások</a></li><li><a href=#_felhasználói_alkalmazások>7. Felhasználói alkalmazások</a></li><li><a href=#_a_rendszermag_beállítása>8. A rendszermag beállítása</a></li><li><a href=#_lemezek_állományrendszerek_és_rendszertöltők>9. Lemezek, állományrendszerek és rendszertöltők</a></li><li><a href=#_rendszeradminisztráció>10. Rendszeradminisztráció</a></li><li><a href=#_az_x_window_system_és_a_virtuális_konzolok_használata>11. Az X Window System és a virtuális konzolok használata</a></li><li><a href=#_hálózatok>12. Hálózatok</a></li><li><a href=#_biztonság>13. Biztonság</a></li><li><a href=#_ppp>14. PPP</a></li><li><a href=#_soros_vonali_kommunikáció>15. Soros vonali kommunikáció</a></li><li><a href=#_egyéb_kérdések>16. Egyéb kérdések</a></li><li><a href=#_mókás_dolgok_a_freebsd_vel_kapcsolatban>17. Mókás dolgok a FreeBSD-vel kapcsolatban</a></li><li><a href=#_témák_haladóknak>18. Témák haladóknak</a></li><li><a href=#_köszönetnyilvánítás>19. Köszönetnyilvánítás</a></li><li><a href=#bibliography>Irodalomjegyzék</a></li></ul></nav></div><div class=book-content><div id=preamble><div class=sectionbody><div class="paragraph abstract-title"><p>Kivonat</p></div><div class=paragraph><p>Ezek a gyakran ismételt kérdések a FreeBSD 6.<em>X</em>, 7.<em>X</em> és 8.<em>X</em> változataira vonatkoznak. Az összes bejegyzés a FreeBSD 6.<em>X</em> vagy annál újabb változataira vonatkozik, hacsak azt külön nem jelezzük. Ha szeretnénk segíteni a projektnek, akkor küldjünk egy levelet a <a href=https://lists.FreeBSD.org/subscription/freebsd-doc>FreeBSD Dokumentációs Projekt levelezési lista</a> címére! Ennek a dokumentumnak a legfrissebb változata mindig elérhetõ a <a href=https://docs.freebsd.org/hu/books/faq//>FreeBSD World Wide Web szerverérõl</a>. HTTP-n keresztül letölthetõ egyetlen nagy <a href=.>HTML</a> állományként, vagy <a href=ftp://ftp.FreeBSD.org/pub/FreeBSD/doc/>a FreeBSD FTP szerverérõl</a> szöveges, PostScript® PDF stb. formátumban. Továbbá <a href=https://www.FreeBSD.org/search/>keresni is tudunk a GYIK-ban</a>.</p></div><div class=paragraph><p><em>Fordította: Páli Gábor, utolsó ellenõrzés: 2010.11.28.</em></p></div><hr></div></div><div class=sect1><h2 id=_bevezetés>1. Bevezetés<a class=anchor href=#_bevezetés></a></h2><div class=sectionbody><div class=paragraph><p>Üdvözöljük a FreeBSD 6.<em>X</em>-8.<em>X</em> Gyakran Ismételt Kérdéseiben!</p></div><div class=paragraph><p>Hasonlóan a Usenetes GYIK-okhoz, ennek a dokumentumnak is az a célja, hogy a FreeBSD operációs rendszerrel kapcsolatban feltegye a legyakrabban ismételt kérdéseket (és persze megválaszolja ezeket!). Habár eredetileg azért íródott, hogy megspórolja a feleslegesen elvesztegetett sávszélességet és hogy megelõzze a régóta ismert kérdések újbóli feltételét, a GYIK idõközben egy értékes információforrássá is vált.</p></div><div class=paragraph><p>Igyekeztünk minden megtenni annak érdekében, hogy a GYIK a lehetõ legtöbb információt szolgáltassa. Ha szeretnénk javaslatokat tenni a továbbfejlesztésére, írjunk bátran a <a href=https://lists.FreeBSD.org/subscription/freebsd-doc>FreeBSD Dokumentációs Projekt levelezési lista</a> címére!</p></div><div class=sect2><h3 id=_mi_az_a_freebsd>1.1. Mi az a FreeBSD?<a class=anchor href=#_mi_az_a_freebsd></a></h3><div class=paragraph><p>Ha tömören akarjuk összefoglalni, akkor a FreeBSD egy AMD64, Intel® EM64T, i386™, PC-98, IA-64, ARM®, PowerPC® és UltraSPARC® platformokra fejlesztett UNIX®-szerû operációs rendszer, amely a Kaliforniai Egyetem (Berkeley) rendszerének "4.4BSD-Lite" kiadására épül, valamint a "4.4BSD-Lite2" kiadásból tartalmaz még néhány továbbfejlesztést. Továbbá közvetett módon még felhasználja a Berkeley "Net/2" kiadásának i386™ architektúrára készített portját, a "386BSD" forrásait is, amit annak idején William Jolitz készített, noha ebbõl ténylegesen már csak nagyon kevés található a rendszerben. A FreeBSD részletesebb bemutatása és annak tulajdonságai a <a href=https://www.FreeBSD.org/hu/>FreeBSD honlapján</a> találhatóak.</p></div><div class=paragraph><p>A FreeBSD-t munkához, oktatáshoz és szórakozáshoz rengeteg cég, internetszolgáltató, kutató, informatikus, diák és otthoni felhasználó használja a világ minden táján.</p></div><div class=paragraph><p>A FreeBSD bõvebb bemutatásához olvassuk el a <a href=https://docs.freebsd.org/hu/books/handbook/>FreeBSD kézikönyvet</a>.</p></div></div><div class=sect2><h3 id=_mi_a_freebsd_projekt_célja>1.2. Mi a FreeBSD Projekt célja?<a class=anchor href=#_mi_a_freebsd_projekt_célja></a></h3><div class=paragraph><p>A FreeBSD Projektnek az a célja, hogy olyan szoftvereket állítson elõ, amelyek tetszõlegesen felhasználhatóak, mindenféle kötöttségek nélkül. A fejlesztõk közül sokan nagyon sok idõt és munkát fektetnek a forráskódba (és így a Projektbe), ami nyilván megérdemelne némi anyagi ellensúlyozást olykor, de egyáltalán nem ragaszkodunk hozzá. Úgy érezzük, mindenek elõtt az a "küldetésünk", hogy feltétel nélkül segítsünk mindenkit a munkánkkal, függetlenül annak szándékaitól, így a munkánk a lehetõ legnagyobb körben kerül felhasználására és így nyújtja a lehetõ legtöbb hasznot. Véleményünk szerint ez az egyik legalapvetõbb célja a szabad szoftvereknek és ezt a hozzáállást támogatjuk a leginkább.</p></div><div class=paragraph><p>A forrásaink között található, <a href=http://www.FreeBSD.org/copyright/COPYING>GNU General Public License (GPL)</a> vagy a <a href=http://www.FreeBSD.org/copyright/COPYING.LIB>GNU Library General Public License (LGPL)</a> licencelésû munkák azonban már valamivel több kötöttséggel járnak, habár ezek inkább a közzétételükre vonatkoznak, nem pedig annak ellenkezõjére, ahogy azt általában megszokhattuk. A GPL licencû szoftverek kereskedelmi célú felhasználásának további esetleges nehézségei miatt azonban lehetõségeink szerint igyekszünk ezeket olyan szoftverekkel felváltani, amelyek a kevésbé szigorúbb <a href=http://www.FreeBSD.org/copyright/freebsd-license/>FreeBSD licencet</a> alkalmazzák.</p></div></div><div class=sect2><h3 id=_a_freebsd_licenc_tartalmaz_valamilyen_megszorítást>1.3. A FreeBSD licenc tartalmaz valamilyen megszorítást?<a class=anchor href=#_a_freebsd_licenc_tartalmaz_valamilyen_megszorítást></a></h3><div class=paragraph><p>Igen. Ezek a megszorítások azonban nem az adott munka felhasználását szabályozzák, hanem csupán azt, hogy miként viszonyuljunk a FreeBSD Projekthez. Ha komoly kétségeink lennének a licenceléssel kapcsolatban, olvassuk a jelenleg érvényes <a href=http://www.FreeBSD.org/copyright/freebsd-license/>licencet</a> (angolul). Az egyszerû kíváncsiskodók kedvéért nagyjából így tudnánk összefoglalni a licencet:</p></div><div class=ulist><ul><li><p>Ne állítsuk, hogy mi készítettük.</p></li><li><p>Ne pereljük a Projektet, ha nem mûködik.</p></li></ul></div></div><div class=sect2><h3 id=_a_freebsd_képes_kiváltani_a_jelenleg_használt_operációs_rendszerünket>1.4. A FreeBSD képes kiváltani a jelenleg használt operációs rendszerünket?<a class=anchor href=#_a_freebsd_képes_kiváltani_a_jelenleg_használt_operációs_rendszerünket></a></h3><div class=paragraph><p>A legtöbb ember számára igen. A kérdés megválaszolása azonban természetesen nem ennyire egyértelmû.</p></div><div class=paragraph><p>Sokan nem is magát az operációs rendszert, hanem inkább az alkalmazásokat használják. Valójában pedig maguk az alkalmazások azok, amelyek az operációs rendszert használják. A FreeBSD-t úgy alakították ki, hogy az alkalmazások számára egy szilárd és mindentudó környezetet nyújtson. Támogatja a böngészõk, irodai programcsomagok, levelezõ programok, grafikus programok, programozási környezetek, hálózati szerverek széles választékát, és szinte minden mást, amire csak szükségünk lehet. Az ilyen alkalmazások legnagyobb része elérhetõ a <a href=http://www.FreeBSD.org/ports/>Portgyûjteményen</a> keresztül.</p></div><div class=paragraph><p>Ha viszont olyan alkalmazást kívánunk használni, amely csak bizonyos operációs rendszereken érhetõ el, nem tudjuk magát az operációs rendszert egyszerûen lecserélni alatta. Bizonyos esetekben azonban elõfordulhat, hogy FreeBSD alatt is találunk hozzá hasonló alkalmazásokat. Amikor egy stabil irodai vagy internet szerverre van szükségünk, esetleg egy megbízható munkaállomásra, vagy egyszerûen csak megszakítások nélkül szeretnénk végezni a munkánkat, a FreeBSD-ben igényeinkhez mérten szinte minden megtalálhatunk. A világon rengeteg felhasználó, beleértve a kezdõket és a tapasztalt UNIX® rendszergazdákat egyaránt, asztali operációs rendszerként is a FreeBSD-t használja.</p></div><div class=paragraph><p>Ha egy másik UNIX® környezetrõl akarunk FreeBSD-re váltani, akkor a legtöbb dolog már ismerõs lehet számunkra. Amennyiben viszont valamilyen grafikus operációs rendszerrõl, például Windows®-ról vagy a Mac OS® valamelyik régebbi változatáról szándékozunk átállni, minden bizonnyal idõt kell majd szánnunk a feladatok UNIX® stílusú megvalósításának megismerésére. Ez a GYIK és a <a href=https://docs.freebsd.org/hu/books/handbook/>FreeBSD kézikönyv</a> ehhez tökéletes kiindulási alapot biztosít.</p></div></div><div class=sect2><h3 id=_miért_hívják_freebsd_nek>1.5. Miért hívják FreeBSD-nek?<a class=anchor href=#_miért_hívják_freebsd_nek></a></h3><div class=ulist><ul><li><p>Szabadon (mint "free") felhasználható, akár kereskedelmi célokra is.</p></li><li><p>Az operációs rendszer teljes forráskódja bárki által szabadon elérhetõ, minimális megkötésekkel arra vonatkozóan, hogy miként használható és más (kereskedelmi vagy nem kereskedelmi) munkák részeként miként építhetõ be, terjeszthetõ.</p></li><li><p>Bárki, akinek fejlesztési vagy hibajavítási javaslata van a rendszerrel kapcsolatban, szabadon benyújthatja azt, amely aztán bekerül a források közé (egy-két nyilvánvaló ellenõrzést követõen).</p></li></ul></div><div class=paragraph><p>Érdemes valamint rámutatni, hogy a "szabad" szót az imént két értelemben is használtuk: az egyik jelentése szerint "költségek nélkül", míg a másik jelentése szerint "tetszés szerint". Egy-két <em>tiltott</em> dologtól, például azt állítjuk, hogy mi írtuk, eltekintve tényleg bármit csinálhatunk vele.</p></div></div><div class=sect2><h3 id=_mi_a_különbség_a_freebsd_a_netbsd_openbsd_és_a_többi_nyílt_forráskódú_bsd_operációs_rendszerek_között>1.6. Mi a különbség a FreeBSD, a NetBSD, OpenBSD és a többi nyílt forráskódú BSD operációs rendszerek között?<a class=anchor href=#_mi_a_különbség_a_freebsd_a_netbsd_openbsd_és_a_többi_nyílt_forráskódú_bsd_operációs_rendszerek_között></a></h3><div class=paragraph><p>James Howard <a href=http://www.freebsdworld.gr/freebsd/bsd-family-tree.html>The BSD Family Tree</a> címmel (angolul) készített egy alapos leírást a különbözõ projektek közti eltérések bemutatására.</p></div></div><div class=sect2><h3 id=_melyik_a_freebsd_legújabb_változata>1.7. Melyik a FreeBSD legújabb változata?<a class=anchor href=#_melyik_a_freebsd_legújabb_változata></a></h3><div class=paragraph><p>Jelen pillanatban a FreeBSD fejlesztése két párhuzamos ágon folyik, és mind a kettõbõl készülnek kiadások. A 7.<em>X</em> sorozat kiadásai a <em>7-STABLE</em> ágból, míg a 8.<em>X</em> sorozat kiadásai a <em>8-STABLE</em> ágból készülnek.</p></div><div class=paragraph><p>A 8.0-s kiadás megjelenéséig a 7.<em>X</em> sorozat volt a <em>-STABLE</em>. A 8.0 kiadás megjelenésével azonban a 7.<em>X</em> ág "meghosszabbított támogatást" kapott, és már csak a nagyobb hibákat, például a biztonsági hibákat javítják benne. Az <em>7-STABLE</em> ágból még várhatóak további kiadások is, azonban ezt jelenleg már "örökségi" ágnak tekintjük, és a legtöbb munka már a <em>8-STABLE</em> részeként jelenik meg.</p></div><div class=paragraph><p>A <a href=ftp://ftp.FreeBSD.org/pub/FreeBSD/releases/i386/12.0-RELEASE/>12.0</a> változat a <em>8-STABLE</em> ág legfrissebb kiadása, amely December 11, 2018ban jelent meg. Az <em>7-STABLE</em> ágból a <a href=ftp://ftp.FreeBSD.org/pub/FreeBSD/releases/i386/11.2-RELEASE/>11.2</a> a legfrissebb kiadás, amely June 28, 2018ban jelent meg.</p></div><div class=paragraph><p>Ha röviden össze akarjuk foglalni, akkor a <em>-STABLE</em> változatokat elsõsorban az internet-szolgáltatók, vállalkozások számára ajánljuk, illetve minden olyan felhasználó számára, aki a legújabb (és minden bizonnyal még instabil) <em>-CURRENT</em> pillanatkiadásokhoz viszonyítottan a legkevesebb változtatással kívánnak egy megbízható, stabil verziót használni a rendszerbõl. Ugyan bármelyik ágból készülhetnek, azonban a <em>-CURRENT</em> esetében meglehetõsen sok változásra kell felkészülnünk (a <em>-STABLE</em> ághoz képest) az egyes kiadások között.</p></div><div class=paragraph><p>A kiadások <a href=#release-freq>néhány havonta</a> készülnek. Mivel a legtöbben ennél pontosabban követik a FreeBSD forrásait (lásd a <a href=#current>FreeBSD-CURRENT</a> és <a href=#stable>FreeBSD-STABLE</a> változatokra vonatkozó kérdéseket), ennél valamire többre van szükségünk, hiszen a források folyamatosan változnak.</p></div><div class=paragraph><p>A FreeBSD egyes kiadásairól a <a href=http://www.FreeBSD.org/releng/>Kiadások megjelentetését összefoglaló oldalon</a> tájékozódhatunk a FreeBSD honlapján.</p></div></div><div class=sect2><h3 id=_mi_az_a_freebsd_current>1.8. Mi az a FreeBSD-CURRENT?<a class=anchor href=#_mi_az_a_freebsd_current></a></h3><div class=paragraph><p>A <a href=https://docs.freebsd.org/hu/books/handbook/updating-upgrading#current>FreeBSD-CURRENT</a> az operációs rendszer aktív fejlesztés alatt álló változata, amely idõvel az új FreeBSD-STABLE ággá válik. Ez a változat tulajdonképpen csak a rendszeren dolgozó fejlesztõk és a megátalkodott hobbifelhasználók számára érdekes. A <a href=https://docs.freebsd.org/hu/books/handbook/>kézikönyv</a> <a href=https://docs.freebsd.org/hu/books/handbook/updating-upgrading#current>erre vonatkozó szakaszában</a> olvashatunk részletesebben a <em>-CURRENT</em> használatáról.</p></div><div class=paragraph><p>Ha nem mozgunk otthonosan az operációs rendszerek világában, vagy ha nem tudjuk megmondani a különbséget egy valódi és egy ideiglenes probléma között, akkor nem javasoljuk a FreeBSD-CURRENT használatát. Ez a fejlesztési vonal nagyon gyorsan fejlõdik és néha lefordíthatatlan állapotba kerül. A FreeBSD-CURRENT változat használóitól elvárjuk, hogy képesek legyenek felmérni a felbukkanó problémákat, és közülük csak azokat jelenteni, amelyek valóban hibákat takarnak és nem pedig csak apró "bökkenõk". Ezért a <a href=https://lists.FreeBSD.org/subscription/freebsd-current>FreeBSD-CURRENT levelezési lista</a> olvasói általában "A make world parancs valami csoportra panaszkodik" típusú kérdéseket általában figyelembe se veszik.</p></div><div class=paragraph><p>A <em>-CURRENT</em> és <em>-STABLE</em> ágak aktuális állapotáról minden hónapban <a href=https://www.FreeBSD.org/snapshots/>pillanatkiadások</a> készülnek. Célunk ezzel:</p></div><div class=ulist><ul><li><p>A telepítõ legfrissebb változatának tesztelése.</p></li><li><p>Idõt és sávszélességet szeretnénk megspórolni a <em>-CURRENT</em> vagy <em>-STABLE</em> változatok azon felhasználóinak, akik az iméntiek hiányából fakadóan nem tudják naponta frissíteni a rendszerüket.</p></li><li><p>Kiindulási pontokat rögzítünk a kód aktuális állapota alapján, ha késõbb netalán valamilyen szörnyûség történne. (Noha a CVS általában védelmet nyújt az ilyen rémisztõ dolgok bekövetkezése ellen.)</p></li><li><p>Az összes tesztelendõ újítást és javítást ezen a módon kívánjuk a lehetõ legszélesebb körben elérhetõvé tenni.</p></li></ul></div><div class=paragraph><p>Egyik <em>-CURRENT</em> pillanatkiadás sem tekinthetõ "hétköznapi felhasználásra alkalmasnak". Ha egy megbízható és széles körben tesztelt rendszerre van szükségünk, akkor vagy maradjunk a kiadásoknál vagy használjuk a <em>-STABLE</em> vonalból készült pillanatkiadásokat.</p></div><div class=paragraph><p>A pillanatkiadások <a href=https://www.FreeBSD.org/snapshots/>innen</a> érhetõek el.</p></div><div class=paragraph><p>Minden aktívan fejlesztett ághoz havonta készülnek hivatalos pillanatkiadások. A népszerûbb i386 és amd64 ágakból azonban napi kiadások is elérhetõek a <a href=http://snapshots.us.freebsd.org>http://snapshots.us.freebsd.org</a> a címen.</p></div></div><div class=sect2><h3 id=_mit_takar_a_freebsd_stable>1.9. Mit takar a FreeBSD-STABLE?<a class=anchor href=#_mit_takar_a_freebsd_stable></a></h3><div class=paragraph><p>Amikor a FreeBSD 2.0.5 megjelent, a FreeBSD fejlesztése kettévált. Az egyik ág neve <a href=https://docs.freebsd.org/hu/books/handbook/updating-upgrading#stable>-STABLE</a>, a másiké pedig <a href=https://docs.freebsd.org/hu/books/handbook/updating-upgrading#current>-CURRENT</a> lett. A <em>FreeBSD-STABLE</em> az olyan internet-szolgáltatók és egyéb vállalkozások számára készült, ahol a fejlesztés alatt álló újítások vagy a hirtelen váltások által okozott problémák gyakran nem engedhetõek meg. Ide csak olyan hibajavítások és kisebb módosítások kerülnek, amelyeket alaposan leteszteltek. A <em>FreeBSD-CURRENT</em> ezzel szemben a 2.0 megjelenése óta egyetlen, szakadásmentes fejlesztési vonalat képvisel, amely a 12.0-RELEASE és az azon túli kiadások felé halad. Ha többet szeretnénk megtudni a jelenlegi ágak állapotáról és a következõ kiadások ütemezésérõl, akkor ezzel kapcsolatban olvassuk el a <a href=https://docs.freebsd.org/en/articles/releng/#REL-BRANCH>FreeBSD Release Engineering</a> címû cikk kiadások leágaztatásáról szóló részét (angolul). Az ágak jelenlegi állapota és a jövõbeni kiadások ütemterve a <a href=https://www.FreeBSD.org/releng>Kiadások információk oldalán</a> található (angolul).</p></div><div class=paragraph><p>A 2.2-STABLE ág a 2.2.8 megjelenésével nyugdíjba vonult. A 3-STABLE ág a 3.5.1 mint az utolsó 3.<em>X</em> kiadás megjelenésével ért véget. A 4-STABLE ág a 4.11 mint az utolsó 4.<em>X</em> kiadással fejezõdött be. Ezekbe az ágakban a legtöbb esetben már csak biztonsági javításokat végeznek. Az 5-STABLE ág fejlesztése az utolsó 5.<em>X</em> kiadás, az 5.5 megjelenésével lezárult. A 6-STABLE ág fejlesztése még folytatódik valameddig, de ez alatt leginkább már csak a biztonsági rések és egyéb komoly problémák javításait kell érteni.</p></div><div class=paragraph><p>A 12.0-STABLE a jelenleg fejlesztett <em>-STABLE</em> ág. A 12.0-STABLE ágból megjelent legfrissebb kiadás a 12.0-RELEASE, amely December 11, 2018ban jelent meg.</p></div><div class=paragraph><p>A 9-CURRENT a <em>-CURRENT</em> ág legfrissebb változata, és ez a FreeBSD következõ generációja. Errõl az ágról a <a href=#current>Mi az a FreeBSD-CURRENT?</a> kérdésnél szolgálunk részletesebb információkkal.</p></div></div><div class=sect2><h3 id=_mikor_készülnek_freebsd_kiadások>1.10. Mikor készülnek FreeBSD kiadások?<a class=anchor href=#_mikor_készülnek_freebsd_kiadások></a></h3><div class=paragraph><p>A Release Engineering Team &lt;<a href=mailto:re@FreeBSD.org>re@FreeBSD.org</a>> átlagosan a FreeBSD egy újabb nagyobb változatát 18 havonta, míg egy kisebb kiadását 8 havonta jelenteti meg. A kiadások dátumát elõre kihirdetik, így a rendszeren dolgozó emberek pontosan tudják, hogy mikorra kell befejezniük a munkájukat és letesztelni azt. Minden kiadást egy tesztelési idõszak elõz meg, ahol megbizonyosodnak róla, hogy az elkészült újítások nem veszélyeztetik az új kiadás megbízhatóságát. A legtöbb felhasználó pontosan ezt a típusú elõvigyázatosságot szereti legjobban a FreeBSD-ben, még annak árán is, hogy a legújabb finomságok bekerülésére még a <em>-STABLE</em> ág esetén gyakran sokat kell várni.</p></div><div class=paragraph><p>A kiadások szerkesztésérõl (valamint a soronkövetkezõ kiadások ütemezésérõl) a FreeBSD honlapján belül <a href=http://www.FreeBSD.org/releng/>ezen</a> az oldalon olvashatunk részletesebben (angolul).</p></div><div class=paragraph><p>Akik egy kicsivel több izgalomra vágynak, azok részére az elõbb említett, naponta készített bináris pillanatkiadásokat ajánljuk.</p></div></div><div class=sect2><h3 id=_ki_felel_a_freebsd_ért>1.11. Ki felel a FreeBSD-ért?<a class=anchor href=#_ki_felel_a_freebsd_ért></a></h3><div class=paragraph><p>A FreeBSD Projektre vonatkozó fontosabb döntéseket, mint például a Projekt haladási irányát vagy hogy vehet részt a forráskód fejlesztésében, egy 9 fõs <a href=https://www.FreeBSD.org/hu/administration/#t-core>irányító csoport</a> hozza. Rajtuk kívül még egy több mint 350 fõs <a href=https://docs.freebsd.org/en/articles/contributors/#STAFF-COMMITTERS>fejlesztõi csapat</a> jogosult közvetlenül módosítani a FreeBSD forrásait.</p></div><div class=paragraph><p>A legtöbb bonyolultabb változtatást általában azonban a megfelelõ <a href=#mailing>levelezési listákon</a> is megvitatják, amiben bárki különösebb korlátozás nélkül részt vehet.</p></div></div><div class=sect2><h3 id=_honnan_lehet_a_freebsd_t_beszerezni>1.12. Honnan lehet a FreeBSD-t beszerezni?<a class=anchor href=#_honnan_lehet_a_freebsd_t_beszerezni></a></h3><div class=paragraph><p>A FreeBSD összes fontosabb kiadása elérhetõ anonim FTP-n keresztül a <a href=ftp://ftp.FreeBSD.org/pub/FreeBSD/>FreeBSD FTP oldaláról</a>:</p></div><div class=ulist><ul><li><p>A legfrissebb 8-STABLE kiadás, a 12.0-RELEASE <a href=ftp://ftp.FreeBSD.org/pub/FreeBSD/releases/i386/12.0-RELEASE/>ebbõl</a> a könyvtárból érhetõ el.</p></li><li><p>Havonta készülnek <a href=https://www.FreeBSD.org/snapshots/>pillanatkiadások</a> a <a href=#current>-CURRENT</a> és a <a href=#stable>-STABLE</a> ágakból, de ezek leginkább a legújabb változatot tesztelõk és a fejlesztõk számára fontosak.</p></li><li><p>A legfrissebb 7-STABLE kiadás, a 11.2-RELEASE <a href=ftp://ftp.FreeBSD.org/pub/FreeBSD/releases/i386/11.2-RELEASE/>ebbõl</a> a könyvtárból érhetõ el.</p></li></ul></div><div class=paragraph><p>Ha a FreeBSD-t CD-n, DVD-n vagy más egyéb telepítõeszközön szeretnénk megkapni, akkor ezzel kapcsolatban nézzük meg <a href=https://docs.freebsd.org/hu/books/handbook/mirrors/#mirrors>a kézikönyvet</a>.</p></div></div><div class=sect2><h3 id=_hogyan_lehet_elérni_a_hibajelentések_adatbázisát>1.13. Hogyan lehet elérni a hibajelentések adatbázisát?<a class=anchor href=#_hogyan_lehet_elérni_a_hibajelentések_adatbázisát></a></h3><div class=paragraph><p>A felhasználók kéréseit tartalmazó hibajelentések adatbázisát a honlap webes hibajelentésekkel foglalkozó <a href=http://www.FreeBSD.org/cgi/query-pr.cgi?query>felületén</a> keresztül érhetjük el.</p></div><div class=paragraph><p>A <a href="https://man.freebsd.org/cgi/man.cgi?query=send-pr&amp;sektion=1&amp;format=html">send-pr(1)</a> parancs segítségével tudunk e-mailen keresztül hibajelentéseket és egyéb változtatási kéréseket küldeni. Emellett még böngészõ segítségével is tudunk hibajelentéseket küldeni a honlap <a href=http://www.freebsd.org/send-pr/>webes hibabejelentõ felületén</a>.</p></div><div class=paragraph><p>Mielõtt beküldenénk egy hibajelentést, olvassuk el a <a href=https://docs.freebsd.org/en/articles/problem-reports/>Writing FreeBSD Problem Reports</a> címû cikket (angolul), amelybõl megtudhatjuk, hogyan készítsünk jól hasznosítható hibajelentéseket.</p></div></div><div class=sect2><h3 id=_honnan_tudhatunk_meg_még_többet>1.14. Honnan tudhatunk meg még többet?<a class=anchor href=#_honnan_tudhatunk_meg_még_többet></a></h3><div class=paragraph><p>Nézzük meg a <a href=http://www.FreeBSD.org>FreeBSD</a> Projekt honlapjáról elérhetõ <a href=http://www.FreeBSD.org/docs/>dokumentációkat</a>.</p></div></div></div></div><div class=sect1><h2 id=_dokumentációs_és_támogatás>2. Dokumentációs és támogatás<a class=anchor href=#_dokumentációs_és_támogatás></a></h2><div class=sectionbody><div class=sect2><h3 id=_milyen_jó_könyvek_szólnak_a_freebsd_rõl>2.1. Milyen jó könyvek szólnak a FreeBSD-rõl?<a class=anchor href=#_milyen_jó_könyvek_szólnak_a_freebsd_rõl></a></h3><div class=paragraph><p>A Projekt igen széles körû dokumentációval rendelkezik, amely a következõ linkrõl érhetõ el: <a href=http://www.FreeBSD.org/docs/>http://www.FreeBSD.org/docs/</a>. Emellett a GYIK <a href=#bibliography>végén szereplõ</a>, valamint a kézikönyvben található <a href=https://docs.freebsd.org/hu/books/handbook/bibliography/#bibliography>irodalomjegyzék</a> tartalmazza az ajánlott könyveket.</p></div></div><div class=sect2><h3 id=_a_dokumentáció_elérhetõ_más_formátumokban_is_például_szöveges_ascii_állományban_vagy_postscript_ben>2.2. A dokumentáció elérhetõ más formátumokban is, például szöveges (ASCII) állományban vagy PostScript®-ben?<a class=anchor href=#_a_dokumentáció_elérhetõ_más_formátumokban_is_például_szöveges_ascii_állományban_vagy_postscript_ben></a></h3><div class=paragraph><p>Igen. A dokumentáció több különbözõ állomány- és tömörítési formátumban elérhetõ az FreeBSD FTP oldalán belül a <a href=ftp://ftp.FreeBSD.org/pub/FreeBSD/doc/>/pub/FreeBSD/doc/</a> könyvtárból.</p></div><div class=paragraph><p>A dokumentációt több különbözõ módon osztályozhatjuk. Többek közt:</p></div><div class=ulist><ul><li><p>A dokumentum neve alapján, például <code>faq</code> (GYIK), vagy <code>handbook</code> (kézikönyv).</p></li><li><p>A dokumentum nyelv és karakterkódolása alapján. Ezeket a FreeBSD rendszerekben, a <span class=filename>/usr/shared/locale</span> könyvtárban megtalálható nyelvi beállítások nevei szerint adjuk meg. Jelenleg a következõ nyelveken és kódolásokban érhetõ el a dokumentáció:</p><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Név</th><th class="tableblock halign-left valign-top">Leírás</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>en_US.ISO8859-1</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Angol (Egyesült Államok)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>bn_BD.ISO10646-1</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Bengáli vagy bangla (Banglades)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>da_DK.ISO8859-1</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Dán (Dánia)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>de_DE.ISO8859-1</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Német (Németország)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>el_GR.ISO8859-7</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Görög (Görögország)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>es_ES.ISO8859-1</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Spanyol (Spanyolország)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>fr_FR.ISO8859-1</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Francia (Franciaország)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>hu_HU.ISO8859-2</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Magyar (Magyarország)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>it_IT.ISO8859-15</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Olasz (Olaszország)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>ja_JP.eucJP</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Japán (Japán, EUC kódolás)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>mn_MN.UTF-8</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Mongol (Mongólia, UTF-8 kódolás)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>nl_NL.ISO8859-1</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Holland (Hollandia)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>no_NO.ISO8859-1</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Norvég (Norvégia)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>pl_PL.ISO8859-2</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Lengyel (Lengyelország)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>pt_BR.ISO8859-1</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Portugál (Brazília)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>ru_RU.KOI8-R</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Orosz (Oroszország, KOI8-R kódolás)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>sr_YU.ISO8859-2</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Szerb (Szerbia)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>tr_TR.ISO8859-9</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Török (Törökország)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>zh_CN.GB2312</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Egyszerûsített kínai (Kína, GB2312 kódolás)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>zh_TW.Big5</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Hagyományos kínai (Tajvan, Big5 kódolás)</p></td></tr></tbody></table><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Nem mindegyik dokumentum érthetõ el mindegyik nyelven.</p></div></td></tr></tbody></table></div></li><li><p>A dokumentum formátuma alapján. A dokumentumok több különbözõ formátumban állnak rendelkezésre. Mindegyik formátum használatának megvannak az elõnyei és hátrányai. Egyes formátumok inkább az interneten keresztüli olvasgatásra megfelelõek, mások pedig nyomtatott formában nyújtanak esztétikus hatást. A több különbözõ formátumnak köszönhetõen az olvasók igényeik szerint el tudják olvasni a dokumentáció különbözõ részeit akár a képernyõn, akár papíron. Jelenleg a következõ formátumokban érhetõek el a dokumentumok:</p><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Formátum</th><th class="tableblock halign-left valign-top">Leírás</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>html-split</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Kis méretû, hiperhivatkozásokkal ellátott HTML állományok gyûjteménye</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>html</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Egyetlen óriási, az egész dokumentumot tartalmazó HTML állomány</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>pdf</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Az Adobe-féle Portable Document Format</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>ps</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>PostScript®</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>rtf</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>A Microsoft Rich Text formátuma</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>txt</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Egyszerû szöveges állomány</p></td></tr></tbody></table><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Amikor egy ilyen dokumentumot betöltünk a Wordbe, akkor az oldalszámok maguktól nem frissülnek. Ehhez a dokumentum betöltése után nyomjuk le a <span class=keyseq><kbd>Ctrl</kbd>+<kbd>A</kbd></span>, <span class=keyseq><kbd>Ctrl</kbd>+<kbd>End</kbd></span>, <kbd>F9</kbd> billentyûket.</p></div></td></tr></tbody></table></div></li><li><p>A tömörítés és csomagolás típusa alapján. Ezek közül jelenleg hármat használunk.</p><div class="olist loweralpha"><ol class=loweralpha type=a><li><p>Ahol a formátum <code>html-split</code>, ott az állományokat a <a href="https://man.freebsd.org/cgi/man.cgi?query=tar&amp;sektion=1&amp;format=html">tar(1)</a> segítségével csomagoltuk össze. Az így keletkezõ <span class=filename>.tar</span> állományt ezek után az alábbi részben szereplõ tömörítési megoldásokkal tömörítettük.</p></li><li><p>Az összes többi formátum esetén csak egyetlen állomány keletkezik, amelynek a neve <span class=filename>típus.formátum</span> (tehát például <span class=filename>article.pdf</span>, <span class=filename>book.html</span> és így tovább).</p><div class=paragraph><p>Ezeket az állományokat azután két tömörítési eljárással tömörítjük.</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Eljárás</th><th class="tableblock halign-left valign-top">Leírás</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>zip</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>A <code>zip</code> formátum. FreeBSD alatt ezt úgy tudjuk kitömöríteni, ha elõször telepítjük a <a class=package href=https://cgit.freebsd.org/ports/tree/archivers/unzip/>archivers/unzip</a> portot.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>bz2</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>A <code>bzip2</code> formátum. Nem olyan elterjedt, mint a <code>zip</code>, de általában kisebb méretû állományokat készít. Ilyen állományokat akkor tudunk kitömöríteni, ha telepítjük a <a class=package href=https://cgit.freebsd.org/ports/tree/archivers/bzip2/>archivers/bzip2</a> portot.</p></td></tr></tbody></table><div class=paragraph><p>Ennek megfelelõen tehát a kézikönyv <code>bzip2</code>-vel tömörített PostScript® változata a <span class=filename>handbook/</span> könyvtáron belül <span class=filename>book.ps.bz2</span> néven található.</p></div></li></ol></div></li></ul></div><div class=paragraph><p>Miután kiválasztottuk a számunkra megfelelõ letöltendõ formátumot és tömörítési módszert, magunknak kell letölteni a kiválasztott tömörített állományokat, majd kibontani ezeket és átmásolni a megfelelõ helyre.</p></div><div class=paragraph><p>Például, ha a GYIK fejezetekre darabolt, <a href="https://man.freebsd.org/cgi/man.cgi?query=bzip2&amp;sektion=1&amp;format=html">bzip2(1)</a> segítségével tömörített változata a <span class=filename>doc/en_US.ISO8859-1/books/faq/book.html-split.tar.bz2</span> állományban található meg. A letöltéséhez és kibontásához a következõket kell tennünk:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># fetch ftp://ftp.FreeBSD.org/pub/FreeBSD/doc/en_US.ISO8859-1/books/faq/book.html-split.tar.bz2</span>
<span class=c># bzip2 -d book.html-split.tar.bz2</span>
<span class=c># tar xvf book.html-split.tar</span></code></pre></div></div><div class=paragraph><p>A mûvelet befejezõdésével kapunk néhány <span class=filename>.html</span> kiterjesztésû állományt. Ezek közül az egyik neve <span class=filename>index.html</span>, ebben található a tartalomjegyzék, a bevezetés és a dokumentum többi részére mutató hivatkozások. Ezeket az állományokat kell szükség szerint átmásolnunk vagy átmozgatnunk a megfelelõ helyre.</p></div></div><div class=sect2><h3 id=_hol_található_információ_a_freebsd_levelezési_listáiról>2.3. Hol található információ a FreeBSD levelezési listáiról?<a class=anchor href=#_hol_található_információ_a_freebsd_levelezési_listáiról></a></h3><div class=paragraph><p>Az összes velük kapcsolatos információt a <a href=https://docs.freebsd.org/hu/books/handbook/eresources#eresources-mail>kézikönyv levelezési listákról szóló részében</a> találjuk.</p></div></div><div class=sect2><h3 id=_milyen_freebsd_hírcsoportok_léteznek>2.4. Milyen FreeBSD hírcsoportok léteznek?<a class=anchor href=#_milyen_freebsd_hírcsoportok_léteznek></a></h3><div class=paragraph><p>Az összes rájuk vonatkozó információt a <a href=https://docs.freebsd.org/hu/books/handbook/eresources/#eresources-news>kézikönyv hírcsoportokról szóló részében</a> találjuk meg.</p></div></div><div class=sect2><h3 id=_vannak_freebsd_s_irc_internet_relay_chat_csatornák>2.5. Vannak FreeBSD-s IRC (Internet Relay Chat) csatornák?<a class=anchor href=#_vannak_freebsd_s_irc_internet_relay_chat_csatornák></a></h3><div class=paragraph><p>Igen, a legtöbb nagyobb IRC hálózaton található FreeBSD-vel foglalkozó csatorna:</p></div><div class=ulist><ul><li><p>Az <a href=http://www.efnet.org/index.php>EFNet</a> hálózaton található <code>#FreeBSD</code> csatorna lényegében egy FreeBSD-vel foglalkozó fórum, de itt ne nagyon próbálkozzunk segítséget kérni a többiektõl, ha netalán lusták lennénk elolvasni a man oldalakat vagy éppen kutatunk valamit. Ez a hely elsõsorban csevegésre szolgál, ahol mindenféle téma felmerül, a szextõl kezdve a sportokon keresztül a nukleáris fegyverekig éppen úgy, ahogy a FreeBSD-rõl is. Mi szóltunk elõre! A szerver a <code>irc.efnet.org</code> címen érhetõ el.</p></li><li><p>Az <a href=http://www.efnet.org/index.php>EFNet</a> hálózaton található <code>#FreeBSDhelp</code> csatorna kifejezetten a FreeBSD felhasználók megsegítését veszi célba. Az itt levõk sokkal szívesebben válaszolnak a kérdéseinkre, mint a <code>#FreeBSD</code> csatornán.</p></li><li><p>A <a href=http://freenode.net/>Freenode</a> hálózaton található <code><mark>FreeBSD</mark></code> csatornán mindig sokan vannak, itt bármilyen témában kérhetünk segítséget. A beszélgetések idõnként ugyan kifutnak a szigorú szakmai témákból, de a FreeBSD-vel kapcsolatos kérdések itt mindig elsõbbséget élveznek. Szívesen segítünk bárkinek, és lehetõség szerint igyekszünk a kézikönyv megfelelõ részeire hivatkozni, vagy adni valamilyen útmutatást arra vonatkozóan, hogy merre tájékozódhatunk részletesebben a problémánkkal kapcsolatban. Ez alapvetõen egy angol nyelvû csatorna, habár a világ minden tájáról érkeznek tagjaink. Ha az anyanyelvünkön szeretnénk inkább csevegni, akkor elõször tegyük fel a kérdésünket angolul, aztán próbálkozzunk a megfelelõ <code>freebsd-nyelv</code> csatornán.</p></li><li><p>A <a href=http://www.dal.net/>DALNET</a> hálózaton található <code>#FreeBSD</code> csatorna az Egyesült Államokból a <code>irc.dal.net</code> szerveren, Európából pedig az <code>irc.eu.dal.net</code> szerveren keresztül érhetõ el.</p></li><li><p>A <a href=http://www.dal.net/>DALNET</a> hálózaton található <code>#FreeBSDHelp</code> csatorna az Egyesült Államokból a <code>irc.dal.net</code> szerveren, Európából pedig a <code>irc.eu.dal.net</code> szerveren keresztül érhetõ el.</p></li><li><p>Az <a href=http://www.undernet.org/>UNDERNET</a> hálózaton található <code>#FreeBSD</code> csatorna az Egyesült Államokból a <code>us.undernet.org</code>, Európából pedig a <code>eu.undernet.org</code> szerveren keresztül érhetõ el. Mivel ez a csatornát leginkább segítségnyújtásra tartjuk fenn, készüljünk fel arra, hogy a hivatkozott dokumentumokat is el kell olvasnunk.</p></li><li><p>A <a href=http://www.rusnet.org.ru/>RUSNET</a> hálózaton található <code>#FreeBSD</code> csatorna az oroszul beszélõ FreeBSD felhasználók számára igyekszik segítséget nyújtani. Emellett viszont remek hely a nem szakmai jellegû témák megvitatásához is.</p></li><li><p>A <a href=http://freenode.net/>Freenode</a> hálózaton található <code>#bsdchat</code> csatorna a hagyományos kínai (UTF-8 kódolású) nyelvet beszélõ FreeBSD felhasználókat igyekszik segíteni. A nem szakmai jellegû témák részére is egy remek hely.</p></li></ul></div><div class=paragraph><p>Az említett csatornák mindegyike egymástól független, és nem állnak egymással kapcsolatban. Sõt, még a csevegési stílusuk is eltérõ, ezért érdemes a saját stílusunkhoz leginkább illeszkedõt megkeresni. Mint ahogy az <em>összes</em> IRC csatorna esetében elõfordul, itt is könnyedén érhetnek bennünket személyes sértések vagy egyszerûen csak sok szóbeli sárdobálást láthatunk (mivel jóval több az ilyen helyeken a balga ifjú, mint a higgadtabb idõs) - ezekkel ne is törõdjünk!</p></div></div><div class=sect2><h3 id=_hol_kaphatok_kereskedelmi_szintû_freebsd_tréninget_és_támogatást>2.6. Hol kaphatok kereskedelmi szintû FreeBSD tréninget és támogatást?<a class=anchor href=#_hol_kaphatok_kereskedelmi_szintû_freebsd_tréninget_és_támogatást></a></h3><div class=paragraph><p>A FreeBSD Mall is nyújt keresdelmi támogatást a FreeBSD-hez. Errõl a <a href=http://www.freebsdmall.com/cgi-bin/fm>honlapjunkon</a> tudhatunk meg többet.</p></div><div class=paragraph><p>A BSD Certification Group, Inc. DragonFly BSD, FreeBSD, NetBSD és OpenBSD rendszerekhez ad rendszergazdai képesítéseket. Amennyiben érdekel minket, látogassunk el a <a href=http://www.BSDCertification.org>honlapjukra</a>.</p></div><div class=paragraph><p>Kérünk minden olyan további szervezetet, amely tréninget vagy támogatást kíván nyújtani a Projektnek, hogy jelentkezzenek és felvesszük õket a listánkra!</p></div></div></div></div><div class=sect1><h2 id=_telepítés>3. Telepítés<a class=anchor href=#_telepítés></a></h2><div class=sectionbody><div class=sect2><h3 id=_milyen_állományokat_kell_letöltenünk_a_freebsd_telepítéséhez>3.1. Milyen állományokat kell letöltenünk a FreeBSD telepítéséhez?<a class=anchor href=#_milyen_állományokat_kell_letöltenünk_a_freebsd_telepítéséhez></a></h3><div class=paragraph><p>Ehhez a következõ három floppy image-re lesz alapvetõen szükségünk: <span class=filename>floppies/boot.flp</span>, <span class=filename>floppies/kern1.flp</span> és <span class=filename>floppies/kern2.flp</span>. Ezeket az image-eket az <code>fdimage</code> vagy <a href="https://man.freebsd.org/cgi/man.cgi?query=dd&amp;sektion=1&amp;format=html">dd(1)</a> segédprogramokkal kell rámásolnunk lemezekre.</p></div><div class=paragraph><p>Ha magukat a terjesztéseket akarjuk letölteni (mert például egy DOS típusú állományrendszerrõl akarunk telepíteni), akkor az alábbi terjesztéseket kell beszereznünk:</p></div><div class=ulist><ul><li><p>base/</p></li><li><p>manpages/</p></li><li><p>compat*/</p></li><li><p>doc/</p></li><li><p>src/ssys.*</p></li></ul></div><div class=paragraph><p>A teljes folyamatot, valamint a telepítéssel kapcsolatos általános tudnivalókat valamivel bõvebben a <a href=https://docs.freebsd.org/hu/books/handbook/install/#install>kézikönyv FreeBSD telepítésével foglalkozó részébõl</a> ismerhetjük meg.</p></div></div><div class=sect2><h3 id=_mit_tegyünk_ha_a_floppy_image_ek_nem_férnek_rá_egyetlen_lemezre>3.2. Mit tegyünk, ha a floppy image-ek nem férnek rá egyetlen lemezre?<a class=anchor href=#_mit_tegyünk_ha_a_floppy_image_ek_nem_férnek_rá_egyetlen_lemezre></a></h3><div class=paragraph><p>Egy 3,5 colos (1,44 MB kapacitású) lemezen 1 474 560 byte-nyi adat fér el. A rendszerindításhoz használt image mérete is pontosan 1 474 560 byte.</p></div><div class=paragraph><p>A rendszerindító lemezek elõkészítése során elkövetett hibák általában a következõk:</p></div><div class=ulist><ul><li><p>Amikor az image-eket FTP-n keresztül töltjük le, elfelejtünk <em>bináris</em> (binary) átviteli módot használni.</p><div class=paragraph><p>Egyes FTP kliensek alapértelmezés szerint <em>szöveges</em> (ascii) módban viszik át az állományokat, és ennek során megpróbálják a sorvége karaktereket az adott operációs rendszer konvenciói szerint átalakítani. Ilyenkor szinte kétségtelen, hogy ezzel tönkreteszik az image-et. Ezért ne felejtsük el ellenõrizni a letöltött image-eket: ha a méretük nem egyezik meg <em>pontosan</em> a szerveren levõ változatukéval, akkor gyaníthatóan a letöltés közben történt velük valami.</p></div><div class=paragraph><p>Megoldás: miután csatlakoztunk a szerverhez, de még mielõtt elkezdük volna a letöltést, az FTP kliens parancssorában gépeljük be, hogy <em>binary</em>.</p></div></li><li><p>Az image lemezre másolása a DOS <code>copy</code> parancsának (vagy hasonló grafikus eszközök) használatával.</p><div class=paragraph><p>A <code>copy</code> és a hozzá hasonló programok nem használhatóak erre a célra, mivel az image-eket közvetlenül a rendszeindításhoz hozták létre. Ennek megfelelõen az egyes image-ek a lemezek teljes tartalmát sávról sávra tartalmazzák, és így nem hétköznapi állományként kell velük bánni. Ezeket a floppykra alacsonyszintû eszközök (például az <code>fdimage</code> vagy <code>rawrite</code>) segítségével, "nyers" módban kell felvinni, ahogy azt a <a href=https://docs.freebsd.org/hu/books/handbook/install/#install>FreeBSD telepítését leíró útmutatóban</a> is olvashatjuk.</p></div></li></ul></div></div><div class=sect2><h3 id=_hol_található_leírás_a_freebsd_telepítésérõl>3.3. Hol található leírás a FreeBSD telepítésérõl?<a class=anchor href=#_hol_található_leírás_a_freebsd_telepítésérõl></a></h3><div class=paragraph><p>A telepítés részletes leírása a <a href=https://docs.freebsd.org/hu/books/handbook/install/#install>kézikönyv FreeBSD telepítésérõl szóló részében</a> olvasható.</p></div></div><div class=sect2><h3 id=_mire_van_szükség_a_freebsd_használatához>3.4. Mire van szükség a FreeBSD használatához?<a class=anchor href=#_mire_van_szükség_a_freebsd_használatához></a></h3><div class=paragraph><p>A FreeBSD használatához egy 486-os vagy jobb processzorral rendelkezõ számítógépre, 24 MB vagy annál több memóriára, és legalább 150 MB tárhelyre lesz szükségünk.</p></div><div class=paragraph><p>A FreeBSD összes változata képes futni szinte bármilyen olcsó MDA típusú grafikus kártyával, de az Xorg használatához már VGA vagy annál jobb videokártya szükségeltetik.</p></div><div class=paragraph><p>Lásd <a href=#hardware>Hardverkompatibilitás</a>.</p></div></div><div class=sect2><h3 id=_hogyan_lehet_saját_telepítõfloppyt_készíteni>3.5. Hogyan lehet saját telepítõfloppyt készíteni?<a class=anchor href=#_hogyan_lehet_saját_telepítõfloppyt_készíteni></a></h3><div class=paragraph><p>Jelen pillanatban ennek nincs <em>egyszerû</em> módja. Minden egyes kiadáshoz tartoznak telepítõfloppyk, használjuk ezeket.</p></div><div class=paragraph><p>Ha egy módosított kiadást akarunk készíteni, kövessük a(z angol nyelvû) <a href=https://docs.freebsd.org/en/articles/releng/>Release Engineering</a> cikk útmutatásait.</p></div></div><div class=sect2><h3 id=_windows_mellé_is_telepíhetõ_freebsd>3.6. Windows® mellé is telepíhetõ FreeBSD?<a class=anchor href=#_windows_mellé_is_telepíhetõ_freebsd></a></h3><div class=paragraph><p>Elõször telepítsük a Windows®t, majd a FreeBSD-t. A FreeBSD boot managere ekkor képes lesz a Windows® és a FreeBSD indítására is. Vigyázzunk, mert ha a Windows®t telepítjük fel másodikként, akkor az minden figyelmeztetés nélkül durván felülírja az aktuális boot managert. Ha ezt tapasztaljuk, akkor olvassuk el a következõ szakaszt.</p></div></div><div class=sect2><h3 id=_a_windows_letörölte_a_boot_managert_hogyan_lehet_visszaállítani>3.7. A Windows® letörölte a boot managert! Hogyan lehet visszaállítani?<a class=anchor href=#_a_windows_letörölte_a_boot_managert_hogyan_lehet_visszaállítani></a></h3><div class=paragraph><p>A FreeBSD-hez tartozó boot managert háromféleképpen tudjuk újratelepíteni:</p></div><div class=ulist><ul><li><p>Indítsuk el a DOS-t, lépjünk be a FreeBSD terjesztéshez tartozó <span class=filename>tools</span> könyvtárba és keressük meg a <span class=filename>bootinst.exe</span> nevû állományt. Indítsuk el a következõ módon:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>...<span class=se>\T</span>OOLS&gt; bootinst.exe boot.bin</code></pre></div></div><div class=paragraph><p>Ekkor a boot manager visszakerül a helyére.</p></div></li><li><p>Használjuk a FreeBSD-hez létrehozott rendszerindító lemezeket, és a telepítõben válasszuk a <span class=guimenuitem>Custom</span> (Egyéni telepítés) menüpontot, majd azon belül válasszuk a <span class=guimenuitem>Partition</span> (Partíció) pontot. Itt válasszuk ki azt a meghajtót, ahol korábban a boot managerünk volt (ez valószínûleg a felsorolásban az elsõ lesz) és amikor belépünk a partíciószerkesztõbe, akkor egybõl válasszuk a <code>Write</code> (<kbd>W</kbd>) opciót (tehát ne változtassunk semmit). Ez megerõsítést fog kérni, amire válasszuk a <b class=button>yes</b> gombot, és amikor a boot manager kiválasztása rész jelenik meg, válasszuk a FreeBSD Boot Manager pontot. Ezzel a boot manager újra a lemezre íródik. Miután ezzel végeztünk, lépjünk ki a telepítõbõl és indítsuk újra a rendszerünket a megszokott módon.</p></li><li><p>Indítsuk a rendszerünket a FreeBSD rendszerindító lemezérõl (vagy CD-jérõl), majd válasszuk a telepítõben a <span class=guimenuitem>Fixit</span> (Javítás) menüpontot. Ezután válasszuk a javítófloppy vagy a(z "élõ" állományrendszerrel rendelkezõ) 2. CD használatát, majd lépjünk be a javításhoz elindított parancsértelmezõbe. Ezt követõen adjuk ki az alábbi parancsot:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Fixit# fdisk <span class=nt>-B</span> <span class=nt>-b</span> /boot/boot0 eszköz</code></pre></div></div><div class=paragraph><p>A parancsban az <em>eszköz</em> helyére annak az eszköznek a nevét adjuk meg, amelyrõl a rendszert szoktuk indítani, például <span class=filename>ad0</span> (az elsõ IDE-lemez), <span class=filename>ad4</span> (az elsõ IDE-lemez valamelyik vezérlõn), <span class=filename>da0</span> (az elsõ SCSI-lemez) stb.</p></div></li></ul></div></div><div class=sect2><h3 id=_az_a_t_és_x_sorozatú_ibm_thinkpad_laptopok_lefagynak_a_freebsd_telepítése_utáni_elsõ_indulásuk_során_hogy_lehet_ezen_segíteni>3.8. Az A, T és X sorozatú IBM Thinkpad laptopok lefagynak a FreeBSD telepítése utáni elsõ indulásuk során. Hogy lehet ezen segíteni?<a class=anchor href=#_az_a_t_és_x_sorozatú_ibm_thinkpad_laptopok_lefagynak_a_freebsd_telepítése_utáni_elsõ_indulásuk_során_hogy_lehet_ezen_segíteni></a></h3><div class=paragraph><p>Ezeken a gépeken az IBM BIOS-ának egy korai hibás változata található, amely a FreeBSD által használt partíciókat tévesen "suspend-to-disk" típusú partícióknak tekinti. Ennek következtében amikor a BIOS megpróbálja értelmezni a FreeBSD által létrehozott partíciót, megakad.</p></div><div class=paragraph><p>Az IBM szerint az alábbi típus/BIOS változatokban található meg ez a hiba.</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Típus</th><th class="tableblock halign-left valign-top">BIOS</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>T20</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>IYET49WW vagy késõbbi</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>T21</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>KZET22WW vagy késõbbi</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>A20p</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>IVET62WW vagy késõbbi</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>A20m</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>IWET54WW vagy késõbbi</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>A21p</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>KYET27WW vagy késõbbi</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>A21m</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>KXET24WW vagy késõbbi</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>A21e</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>KUET30WW</p></td></tr></tbody></table><div class=paragraph><p>Úgy értesültünk, hogy az IBM BIOS-ok késõbbi változataiban ismét felbukkant ez a típusú hiba. <a href=http://docs.FreeBSD.org/cgi/mid.cgi?20010427133759.A71732>Ebben az üzenetben</a> Jacques Vidrine &lt;<a href=mailto:nectar@FreeBSD.org>nectar@FreeBSD.org</a>> a <a href=https://lists.FreeBSD.org/subscription/freebsd-mobile>FreeBSD laptop computer levelezési lista</a> tagjainak egy olyan módszert mutat be, ami segíthet, ha az újabb típusú IBM laptopunk nem tudja elindítani a FreeBSD-t, és így váltani tudunk a BIOS elõzõ vagy következõ verziójára.</p></div><div class=paragraph><p>Ha régebbi típusú BIOS-szal rendelkezünk és a frissítés nem megoldható, akkor a FreeBSD-t telepíthetjük úgy is, hogy megváltoztatjuk a FreeBSD által használt partíció azonosítóját és egy olyan rendszerindító blokkot telepítünk, amelyik képes ezt kezelni.</p></div><div class=paragraph><p>Ehhez elõször is a gépet egy olyan állapotba kell visszahoznunk, ahol már túl tudunk jutni a rendszerindító képernyõn. Ezt úgy tudjuk elérni, ha nem engedjük, hogy a gép indulása közben észrevegye az elsõdleges lemezen található FreeBSD partíciót. Erre az egyik lehetséges megoldás, ha a gépbõl ideiglenesen eltávolítjuk a merevlemezt és átrakjuk egy régebbi ThinkPadba (például egy ThinkPad 600-as típusba) vagy a megfelelõ átalakító használatával az asztali számítógépünkbe. Miután ezzel megvagyunk, töröljük le a FreeBSD partícióját és tegyük vissza a lemezt. Ekkor a ThinkPad újból mûködõképes lesz.</p></div><div class=paragraph><p>Ezt követõen az alábbi utasításokat követve tudjuk telepíteni a FreeBSD-t:</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Töltsük le a <span class=filename>boot1</span> és <span class=filename>boot2</span> állományokat a <a href=http://people.FreeBSD.org/~bmah/ThinkPad/>http://people.FreeBSD.org/~bmah/ThinkPad/</a> címrõl. Olyan helyre tegyük ezeket, ahol késõbb is még el tudjuk érni.</p></li><li><p>A megszokott módon telepítsük a FreeBSD-t a ThinkPadre. Ilyenkor <em>ne</em> használjuk a <code>Veszélyesen dedikált</code> (Dangerously Dedicated) módot. A telepítés befejezése után <em>ne</em> indítsuk újra a gépet.</p></li><li><p>Váltsunk át a vészhelyzetekben használatos parancsértelmezõre ("Emergency Holographic Shell", <span class=keyseq><kbd>Alt</kbd>+<kbd>F4</kbd></span>) vagy indítsuk el egy javításhoz használt ("fixit") parancsértelmezõt.</p></li><li><p>Az <a href="https://man.freebsd.org/cgi/man.cgi?query=fdisk&amp;sektion=8&amp;format=html">fdisk(8)</a> segítségével változtassuk meg a FreeBSD-s partíció azonosítóját a <code>165</code> értékrõl a <code>166</code> értékre (ezt a típust az OpenBSD használja).</p></li><li><p>Másoljuk át az imént letöltött <span class=filename>boot1</span> és <span class=filename>boot2</span> állományokat a helyi állományrendszerre.</p></li><li><p>A <a href="https://man.freebsd.org/cgi/man.cgi?query=disklabel&amp;sektion=8&amp;format=html">disklabel(8)</a> segítségével rögzítsük a <span class=filename>boot1</span> és <span class=filename>boot2</span> tartalmát a FreeBSD slice-unkra.</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># disklabel -B -b boot1 -s boot2 ad0sn</span></code></pre></div></div><div class=paragraph><p>ahol az <em>n</em> annak a slice-nak a sorszáma, ahová a FreeBSD-t telepítettük.</p></div></li><li><p>Indítsuk újra a gépet. A rendszerindító parancssorban ekkora megjelenik az <code>OpenBSD</code> indításának lehetõsége. Ezen keresztül tudjuk a FreeBSD-t elindítani.</p></li></ol></div></div></div><div class=paragraph><p>A kedves Olvasónak meghagytuk azt az esetet, amikor ugyanezen a konfiguráción OpenBSD és FreeBSD rendszereket akarunk egyszerre használni.</p></div></div><div class=sect2><h3 id=_lehet_telepíteni_hibás_szektorokat_tartalmazó_lemezre_is>3.9. Lehet telepíteni hibás szektorokat tartalmazó lemezre is?<a class=anchor href=#_lehet_telepíteni_hibás_szektorokat_tartalmazó_lemezre_is></a></h3><div class=paragraph><p>Igen, ez lehetséges, de egyáltalán nem ajánlott.</p></div><div class=paragraph><p>Manapság ha egy IDE-meghajtón hibás szektorokat találunk, akkor az arra utal, hogy hamarosan tönkremegy (a meghajtó belsõ átképezõ funkciói már képesek megbirkózni a rossz szektorok növekvõ számával, ami arra enged következtetni, hogy a lemez felülete jelentõs mértékben sérült). Ezért inkább egy új merevlemezes meghajtó vásárlását javasoljuk.</p></div><div class=paragraph><p>Ha hibás SCSI-meghajtónk van, <a href=#awre>ezt a választ</a> olvassuk el.</p></div></div><div class=sect2><h3 id=_furcsa_dolgok_történnek_a_telepítõfloppy_használata_közben_mi_okozhatja>3.10. Furcsa dolgok történnek a telepítõfloppy használata közben! Mi okozhatja?<a class=anchor href=#_furcsa_dolgok_történnek_a_telepítõfloppy_használata_közben_mi_okozhatja></a></h3><div class=paragraph><p>Ha olyan furcsa dolgokkal találkozunk a telepítõfloppy használata során, mint például a lemez állandó darálása vagy a rendszer váratlan újraindulása, akkor a következõ három kérdést érdemes feltennünk magunknak:</p></div><div class="olist arabic"><ol class=arabic><li><p>Biztos, hogy új, frissen formázott, teljesen hibamentes floppykat használunk (tehát olyanokat, amelyeket egy frissen bontott dobozból vettünk ki, és nem olyanokat, amelyeket valamelyik magazin mellékletébõl szedtük ki vagy éppen három évig az ágy alatt tároltunk)?</p></li><li><p>Biztos, hogy bináris (vagy image) módban töltöttük le a lemezek image-eit? (Ne szégyelljük, mindenki életében legalább egyszer töltött már le véletlenül bináris állományt szöveges formátumban!)</p></li><li><p>Windows® 95 vagy Windows® 98 alatt DOS módban használtuk az <code>fdimage</code> vagy <code>rawrite</code> parancsot? Ezek az operációs rendszerek általában nem férnek össze az olyan programokkal, amelyek közvetlenül a hardverrel akarnak kommunikálni, amire a lemezek írásához is szükség van. Ez a probléma leginkább akkor merülhet fel, amikor a grafikus felületen belül egy DOS ablakban futtatjuk ezeket a programokat.</p></li></ol></div><div class=paragraph><p>Kaptunk olyan visszajelzést is, hogy gondjaink lehetnek, ha <a href="https://man.freebsd.org/cgi/man.cgi?query=getenv&amp;sektion=3&amp;format=html">getenv(3)</a>-pel töltjük le a rendszerindító lemezeket, ezért lehetõség szerint igyekezzünk más FTP klienst használni.</p></div></div><div class=sect2><h3 id=_atapi_cd_meghajtóról_indult_a_rendszer_de_a_telepítõ_szerint_nem_található_semmilyen_cd_meghajtó_hova_tûnt>3.11. ATAPI CD-meghajtóról indult a rendszer, de a telepítõ szerint nem található semmilyen CD-meghajtó. Hova tûnt?<a class=anchor href=#_atapi_cd_meghajtóról_indult_a_rendszer_de_a_telepítõ_szerint_nem_található_semmilyen_cd_meghajtó_hova_tûnt></a></h3><div class=paragraph><p>Ezt a problémát általában egy rosszul beállított CD-meghajtó okozza. A CD-meghajtó rengeteg számítógépben a másodlagos IDE-vezérlõ slave (szolga) portján található, a master (mester) port használata nélkül. Ez az ATAPI specifikációi szerint nem szabályos, de a Windows® ezzel különösebben nem törõdik, a BIOS pedig egyszerûen figyelmen kívül hagyja a rendszer indítása során. Ezért képes a BIOS ilyenkor látni a CD-meghajtót, és ezért nem képes a FreeBSD teljes telepítésnél használni.</p></div><div class=paragraph><p>Ezen úgy tudunk segíteni, ha a CD-meghajtónkat az IDE-vezérlõn átállítjuk masterre, vagy arra az IDE-vezérlõre teszünk egy master eszközt.</p></div></div><div class=sect2><h3 id=_plip_parallel_line_ip_használatával_lehet_laptopra_telepíteni>3.12. PLIP (Parallel Line IP) használatával lehet laptopra telepíteni?<a class=anchor href=#_plip_parallel_line_ip_használatával_lehet_laptopra_telepíteni></a></h3><div class=paragraph><p>Igen. Ehhez csupán egy szabványos Laplink-kábel kell. Amennyiben szükséges, a párhuzamos vonali hálózatkezelés beállításához olvassuk el <a href=https://docs.freebsd.org/hu/books/handbook/advanced-networking/#network-plip>kézikönyv PLIP-rõl szóló részét</a>.</p></div></div><div class=sect2><h3 id=_a_lemezmeghajtók_esetében_milyen_geometriai_beállításokat_érdemes_használni>3.13. A lemezmeghajtók esetében milyen geometriai beállításokat érdemes használni?<a class=anchor href=#_a_lemezmeghajtók_esetében_milyen_geometriai_beállításokat_érdemes_használni></a></h3><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>A lemez "geometriája" alatt a lemezen található cilinderek, fejek és a sávonkénti szektorok számát értjük. Ezt a továbbiakban csak CHS-értéknek nevezzük (mint Cylinder/Head/Sector). Ebbõl állapítja meg a PC-s BIOS, hogy a lemezen honnan kell olvasnia és hova kell írnia.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Ez rengeteg félreértést okoz az újdonsült rendszergazdák számára. Elõször is megemlítenénk, hogy egy SCSI-lemez <em>fizikai</em> geometriája ebben az esetben teljesen lényegtelen, mivel a FreeBSD lemezblokkokban gondolkozik. Igazából nem létezik "a" fizikai geometria fogalma, ugyanis a szektorok sûrûsége a lemezen felületén belül sem állandó. Amit a gyártók általában "fizikai geometriának" hívnak, az általában az a geometria, amely a legkevesebb helyveszteséggel jár. Az IDE-lemezek esetében a FreeBSD ugyan CHS-értékekkel dolgozik, de ezt minden modernebb meghajtó legbelül blokkhivatkozásokká alakítja.</p></div><div class=paragraph><p>Egyedül tehát a <em>logikai</em> geometria számít. Ez a válasz, amikor a BIOS megkérdezi a meghajtónkat: "Mik a geometriai beállításaid?", és ennek felhasználásával kommunikál vele a késõbbiekben. Mivel a FreeBSD is ezt az értéket használja fel a rendszer indításánál, fontos, hogy jól adjuk meg. Ez különösen abban az esetben számít, amikor több operációs rendszer is található a lemezen, hiszen mindegyiküknek azonos geometriai beállításokat kell használniuk. Ellenkezõ esetben komoly gondok léphetnek fel a rendszer indítása során!</p></div><div class=paragraph><p>A SCSI-lemezek esetében a beállítandó geometria értéke attól függ, hogy a vezérlõn használjuk-e a bõvített fordítás támogatását (extended translation support, amelyet gyakran csak úgy neveznek, hogy "Support for DOS disks >1GB" vagy ehhez hasonlóan). Ha ezt letiltottuk, akkor használjuk az <em>N</em> cilinder, 64 fej és 32 szektor sávonkénti felírást, ahol <em>N</em> a lemez MB-okban számított mérete. Így például egy 2 GB méretû lemez geometriai beállítása 2048 cilinder, 64 fej és 32 szektor sávonként.</p></div><div class=paragraph><p>Ha viszont <em>engedélyeztük</em> (ami gyakran elõfordul, mivel így lehet az MS-DOS® bizonyos korlátozásait megkerülni) és a lemez kapacitása 1 GB-nál több, adjunk meg <em>M</em> cilindert, 255 fejet, 63 (és <em>nem</em> 64) szektort sávonként, ahol az <em>M</em> a lemez MB-okban mért kapacitása osztva 7,844238-al (!). Tehát az iménti példában is említett 2 GB-os meghajtó esetében 261 cilindert, 255 fejet és sávonként 63 szektort kapunk.</p></div><div class=paragraph><p>Ha nem lennénk benne biztosak, vagy a FreeBSD-nek a telepítés közben nem sikerül megállapítania a lemez geometriai beállításait, mi magunk is könnyen meg tudjuk határozni, ha készítünk egy kis méretû DOS partíciót a lemezen. A BIOS ekkor észlelni fogja a megfelelõ geometriai beállításokat, és ha már nincs rá tovább szükségünk, akkor a partíciószerkesztõben nyugodtan törölhetjük. Hálózati kártyák és hasonló hardverek programozásához azonban még a késõbbiekben hasznos lehet.</p></div><div class=paragraph><p>Használhatjuk viszont a FreeBSD-hez mellékelt <span class=filename>pfdisk.exe</span> segédprogramot is. Ezt a FreeBSD CD vagy a FreeBSD FTP oldalainak <span class=filename>tools</span> könyvtárában találhatjuk meg. Ennek a programnak a segítségével ki tudjuk deríteni, hogy a lemezen levõ többi operációs rendszer milyen geometriai beállításokat használ. Az így kapott értékeket fel tudjuk használni a partíciószerkesztõben.</p></div></div><div class=sect2><h3 id=_van_valamilyen_korlátozás_a_lemezek_felosztására_vonatkozóan>3.14. Van valamilyen korlátozás a lemezek felosztására vonatkozóan?<a class=anchor href=#_van_valamilyen_korlátozás_a_lemezek_felosztására_vonatkozóan></a></h3><div class=paragraph><p>Igen. A rendszerindításhoz használt (gyökér)partíciónak az 1024. cilinder alatt kell kezdõdnie, mivel a BIOS csak így képes betölteni onnan a rendszermagot. (Ez a korlátozás a PC-s BIOS-ok miatt van, nem a FreeBSD miatt.)</p></div><div class=paragraph><p>A SCSI-lemezek esetében ez általában azt jelenti, hogy rendszerindításhoz használt partíciónak az elsõ 1024 MB alatt kell kezdõdnie (vagy az elsõ 4096 MB alatt, ha a bõvített fordítást is engedélyeztük - lásd az elõzõ kérdést). Az IDE-lemezek esetében ez 504 MB-nak felel meg.</p></div></div><div class=sect2><h3 id=_a_freebsd_kompatibilis_valamilyen_disk_managerrel>3.15. A FreeBSD kompatibilis valamilyen disk managerrel?<a class=anchor href=#_a_freebsd_kompatibilis_valamilyen_disk_managerrel></a></h3><div class=paragraph><p>A FreeBSD felismeri az Ontrack Disk Managert és figyelembe veszi. A többi disk managert nem támogatja.</p></div><div class=paragraph><p>Ha egyedül csak a FreeBSD-t akarjuk használni, akkor nincs szükségünk disk managerre. Egyszerûen csak állítsunk be egy akkora méretû lemezt, amivel a BIOS képes még megbirkózni (a határ általában 504 MB) és majd a FreeBSD kideríti, hogy valójában mennyi hely áll a rendelkezésére. Ha régebbi gyártmányú merevlemezünk van MFM-vezérlõvel, akkor a FreeBSD-nek konkrétan meg kell mondanunk, hogy mennyi cilindert használhat.</p></div><div class=paragraph><p>Ha a FreeBSD mellett más operációs rendszereket akarunk használni, akkor ezt disk manager nélkül is megtehetjük. Egyedül arra kell vigyáznunk, hogy a FreeBSD indításához használt partíció és a másik operációs rendszer slice-a az elsõ 1024 cilinder alatt kezdõdjön. Ha nagyon körültekintõek akarunk lenni, akkor erre a célra egy 20 MB méretû rendszerindító partíció tökéletesen megfelel.</p></div></div><div class=sect2><h3 id=_amikor_a_freebsd_t_telepítése_után_elõször_elindul_akkor_egy_hiányzó_operációs_rendszer_vagy_egy_missing_operating_system_hiba_jelenik_meg_mi_történt>3.16. Amikor a FreeBSD-t telepítése után elõször elindul, akkor egy Hiányzó operációs rendszer vagy egy Missing Operating System hiba jelenik meg. Mi történt?<a class=anchor href=#_amikor_a_freebsd_t_telepítése_után_elõször_elindul_akkor_egy_hiányzó_operációs_rendszer_vagy_egy_missing_operating_system_hiba_jelenik_meg_mi_történt></a></h3><div class=paragraph><p>Ez általában akkor fordul elõ, amikor a FreeBSD és a DOS vagy más operációs rendszerek nem értenek egyet a lemez <a href=#geometry>geometriai beállításaiban</a>. Telepítsük újra a FreeBSD-t és ezúttal figyelmesen kövessük a fentebb adott utasításokat!</p></div></div><div class=sect2><h3 id=_miért_nem_lehet_továbblépni_a_boot_manager_f_menüjénél>3.17. Miért nem lehet továbblépni a boot manager F? menüjénél?<a class=anchor href=#_miért_nem_lehet_továbblépni_a_boot_manager_f_menüjénél></a></h3><div class=paragraph><p>Ez az elõbbi kérdéssel kapcsolatos probléma egy másik tünete: a BIOS és a FreeBSD által használt geometriai beállítások nem egyeznek! Amennyiben a vezérlõ vagy a BIOS támogatja a cilinderek fordítását (amelyet gyakran ">1GB driver support" néven találhatunk meg), akkor próbáljuk meg átállítani és így újratelepíteni a FreeBSD-t.</p></div></div><div class=sect2><h3 id=_az_összes_forrást_telepíteni_kell>3.18. Az összes forrást telepíteni kell?<a class=anchor href=#_az_összes_forrást_telepíteni_kell></a></h3><div class=paragraph><p>Alapvetõen nem. Ettõl függetlenül azonban javasoljuk legalább a <code>base</code> források telepítését, ahol számos olyan állomány megtalálható, amelyekre a késõbbiekben még hivatkozni fogunk, valamint a <code>sys</code> (rendszermag) források telepítését, amelyben a rendszermag forrásai találhatóak. A rendszeren belül azonban a mûködéshez semmi sem igényli közvetlenül a források jelenlétét, egyedül talán a rendszermag beállítását végzõ <a href="https://man.freebsd.org/cgi/man.cgi?query=config&amp;sektion=8&amp;format=html">config(8)</a> program. A rendszermag forrásainak kivételével a rendszerben a fordítás menetét úgy építettük fel, hogy akár egy írásvédett módon csatlakoztatott NFS állományrendszerrõl is képes legyen dolgozni (a rendszermag forrásaira vonatkozó megszorítások miatt azonban azt javasoljuk, hogy ezt közvetlenül ne a <span class=filename>/usr/src</span> könyvtárba csatlakoztassuk, hanem egy másik helyre, ahol aztán szimbolikus linkek segítségével másoljuk le a forráskód könyvtárszerkezetének legfelsõ szintjét).</p></div><div class=paragraph><p>Ha kéznél vannak a források és tisztában vagyunk a rendszerfordítás folyamatával, akkor a késõbbiekben sokkal könnyebben tudjuk a FreeBSD rendszerünket frissíteni.</p></div><div class=paragraph><p>A források egyes részeinek kiválasztásához lépjünk be a telepítõprogram <span class=guimenuitem>Custom</span> (Egyéni telepítés), majd a <span class=guimenuitem>Distributions</span> (Terjesztések) menübe.</p></div></div><div class=sect2><h3 id=_kell_rendszermagot_fordítani>3.19. Kell rendszermagot fordítani?<a class=anchor href=#_kell_rendszermagot_fordítani></a></h3><div class=paragraph><p>Egy új rendszermag fordítása korábban fontos része volt a FreeBSD telepítésének, de a legújabb kiadások már kihasználják a rendszermag beállításának sokkal baratságosabb módszereit is. A FreeBSD 5.X és az azt követõ változatokban már a betöltõbõl könnyen be tudjuk állítani a rendszermagot a beépített "hints" (eszközökre vonatkozó útmutatások) módszere által felkínált rugalmasabb lehetõségeknek köszönhetõen.</p></div><div class=paragraph><p>Egy új rendszermag készítése viszont olyan esetekben még továbbra is hasznos lehet, amikor csak azokat a meghajtókat akarjuk megtartani benne, amelyekre ténylegesen szükségünk van. Ezzel többnyire memóriát tudunk megspórolni, habár a legtöbb rendszer esetében erre igazából nincs szükségünk.</p></div></div><div class=sect2><h3 id=_a_jelszavak_tárolására_használható_e_des_blowfish_vagy_md5_és_ha_igen_akkor_hogyan_lehet_megadni>3.20. A jelszavak tárolására használható-e DES, Blowfish vagy MD5, és ha igen, akkor hogyan lehet megadni?<a class=anchor href=#_a_jelszavak_tárolására_használható_e_des_blowfish_vagy_md5_és_ha_igen_akkor_hogyan_lehet_megadni></a></h3><div class=paragraph><p>A FreeBSD alapértelmezés szerint <em>MD5</em>-alapú jelszavakat használ. Ezeket a <em>DES</em> algoritmuson alapuló hagyományos UNIX®-os jelszavaknál sokkal megbízhatóbbnak tartják. A DES formátum természetesen továbbra is elérhetõ olyan esetekben, amikor a kevésbé biztonságos jelszavakat használó régi operációs rendszerekkel akarunk együttmûködni. Emellett a FreeBSD-ben lehetõségünk van a sokkal biztonságosabb Blowfish jelszóformátum használatára is. Az új jelszavak formátumát az <span class=filename>/etc/login.conf</span> állományban található <code>passwd_format</code> bejelentkezési tulajdonság adja meg, amelynek értéke <code>des</code>, <code>blf</code> (amennyiben elérhetõ), illetve <code>md5</code> lehet. A bejelentkezési tulajdonságokkal kapcsolatban a <a href="https://man.freebsd.org/cgi/man.cgi?query=login.conf&amp;sektion=5&amp;format=html">login.conf(5)</a> man oldalt érdemes elolvasni.</p></div></div><div class=sect2><h3 id=_a_rendszerindító_lemez_elõször_elindul_de_aztán_miért_akad_meg_a_probing_devices_képernyõn>3.21. A rendszerindító lemez elõször elindul, de aztán miért akad meg a Probing Devices…​ képernyõn?<a class=anchor href=#_a_rendszerindító_lemez_elõször_elindul_de_aztán_miért_akad_meg_a_probing_devices_képernyõn></a></h3><div class=paragraph><p>Ha a rendszerünkhöz IDE-s Zip® vagy Jaz® meghajtót csatlakoztattunk, akkor próbálkozzunk újra az eltávolítása után. A rendszerindító floppy ugyanis hajlamos összekeverni a meghajtókat. A rendszer telepítése után természetesen újra csatlakoztathatjuk a meghajtót. Ezt remélhetõleg egy következõ verzióban már kijavítják.</p></div></div><div class=sect2><h3 id=_a_rendszer_telepítését_követõ_újraindítás_után_miért_jelenik_meg_a_panic_cant_mount_root_hibaüzenet>3.22. A rendszer telepítését követõ újraindítás után miért jelenik meg a panic: can’t mount root hibaüzenet?<a class=anchor href=#_a_rendszer_telepítését_követõ_újraindítás_után_miért_jelenik_meg_a_panic_cant_mount_root_hibaüzenet></a></h3><div class=paragraph><p>Ez a hiba a rendszerindító blokk és a rendszermag közti félreértésbõl, a lemezes eszközök helytelen kezelésébõl fakad. Ilyen hibát általában olyan rendszerekben kapunk, ahol két masternek beállított IDE-lemez található vagy ha az egyes IDE-vezérlõkre csak egy-egy eszközt csatlakoztattunk és a FreeBSD-t a másodlagos IDE-vezérlõre kapcsolódó lemezre telepítettük. Ekkor a rendszerindító blokk szerint a rendszert az <span class=filename>ad0</span> (de a BIOS-ban a második) lemezre telepítettük, miközben a rendszermag szerint ez a másodlagos IDE-vezérlõn elhelyezkedõ elsõ lemez, az <span class=filename>ad2</span>. Az eszközök felkutatása után a rendszermag megpróbálja a rendszerindító blokk által nyilvántartott eszközrõl, az <span class=filename>ad0</span> lemezrõl csatlakoztatni a rendszerindító partíciót, ami viszont számára a <span class=filename>ad2</span> eszköz lesz, így ez a próbálkozása meghiúsul.</p></div><div class=paragraph><p>Ezt a félreértést a következõ módokon lehet helyretenni:</p></div><div class="olist arabic"><ol class=arabic><li><p>Indítsuk újra a rendszert és nyomjuk le az <kbd>Enter</kbd> billentyût, amikor a <code>Booting kernel in 10 seconds; hit [Enter] to interrupt</code> szöveg megjelenik. Ezzel a rendszerbetöltõ parancssorába kerülünk.</p><div class=paragraph><p>Ezután gépeljük be a <code>set root_disk_unit="lemezszám"</code> sort. Itt a <em>lemezszám</em> értéke <code>0</code> lesz, ha a FreeBSD-t az elsõdleges IDE-vezérlõ master portján levõ merevlemezre telepítettük, <code>1</code>, ha az elsõdleges IDE-vezérlõ slave portjára, <code>2</code>, ha a másodlagos IDE-vezérlõ master portjára, és végül <code>3</code>, ha a másodlagos IDE-vezérlõ slave portjára.</p></div><div class=paragraph><p>Most már begépelhetjük, hogy <code>boot</code>, és így a rendszernek el is kell indulnia.</p></div><div class=paragraph><p>Ha ezt a változtatást véglegesíteni akarjuk (vagyis nem akarjuk ugyanezt eljátszani a FreeBSD minden egyes indítása során), akkor a <span class=filename>/boot/loader.conf.local</span> állományba vegyünk fel a <code>root_disk_unit="lemezszám"</code> sort.</p></div></li><li><p>Tegyük át a FreeBSD-t tartalmazó lemezt az elsõdleges IDE-vezérlõre, és ezzel megszûnik az iménti félreértés.</p></li></ol></div></div><div class=sect2><h3 id=_mennyi_memóriát_tudunk_használni>3.23. Mennyi memóriát tudunk használni?<a class=anchor href=#_mennyi_memóriát_tudunk_használni></a></h3><div class=paragraph><p>A memóriára vonatkozó korlátozások platformonként változnak. Egy szabványos i386™ telepítés esetén például ez a határ 4 GB, de <a href="https://man.freebsd.org/cgi/man.cgi?query=pae&amp;sektion=4&amp;format=html">pae(4)</a> segítségével akár még ennél több is elérhetõ. Ehhez olvassuk el az i386™ platformon 4 GB-nál több memória használatára vonatkozó <a href=#memory-i386-over-4gb>utasításokat</a>.</p></div><div class=paragraph><p>A FreeBSD/pc98 esetén a korlát szintén 4 GB, azonban itt a PAE nem használható. A FreeBSD által támogatott összes többi architektúra elméletileg ennél több memóriát képes kezelni (több terabyte-ot).</p></div></div><div class=sect2><h3 id=_mik_az_ffs_állományrendszerek_korlátai>3.24. Mik az FFS állományrendszerek korlátai?<a class=anchor href=#_mik_az_ffs_állományrendszerek_korlátai></a></h3><div class=paragraph><p>Az FFS állományrendszerek méretének elméleti határa 8 TB (2 milliárd blokk), illetve az alapértelmezett 8 KB-os blokkméret esetén 16 TB. A gyakorlatban azonban szoftveresen ebbõl 1 TB használható ki, de kisebb módosításokkal akár 4 TB-os állományrendszer is használható (és létezik).</p></div><div class=paragraph><p>Egyetlen FFS állományrendszerbeli állomány mérete megközelítõleg legfeljebb 1 milliárd blokk lehet, ami 4 KB-os blokkmérettel számolva 4 TB-ot jelent.</p></div><table class="tableblock frame-all grid-all stretch"><caption class=title>Táblázat 1. Az állományok maximális mérete</caption><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Blokkméret</th><th class="tableblock halign-left valign-top">Gyakorlatban</th><th class="tableblock halign-left valign-top">Elméletben</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>4 KB</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>> 4 GB</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>4 TB - 1</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>8 KB</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>> 32 GB</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>32 TB - 1</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>16 KB</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>> 128 GB</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>32 TB - 1</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>32 KB</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>> 512 GB</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>64 TB - 1</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>64 KB</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>> 2048 GB</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>128 TB - 1</p></td></tr></tbody></table><div class=paragraph><p>4 KB-os blokkméret esetén a háromszoros indirekcióval származtatott blokkok a gyakorlatban is kihasználhatóak, és az egészet elméletben egyedül csak az állományrendszerben így ábrázolható blokkok maximális száma korlátozná (ami kb. 1024 + 1024 + 1024), azonban a gyakorlatban ezt az állományrendszeri blokkokra vonatkozó 1 GB - 1 méretû (rossz) határ korlátozza. Az állományrendszeri blokkok számát ugyanis ki kellene terjeszteni a 2 GB - 1 méretig. 2 GB - 1 számú blokk használata körül jelentkezik ugyan néhány hiba, de ezek 4 KB-os blokkméret esetén nem is érhetõek el.</p></div><div class=paragraph><p>A 8 KB-nál nagyobb blokkméretek esetén mindenre a blokkok 2 GB - 1 maximális mennyisége érvényes, de a gyakorlatban ezt a blokkok számának 1 GB - 1 határa korlátozza. Az eredeti 2 GB - 1 mennyiségû blokk használata gondokat okozhat.</p></div></div><div class=sect2><h3 id=_egy_új_rendszermag_fordítása_után_miért_jelenik_meg_a_archsw_readin_failed_hibaüzenet_az_indítás_során>3.25. Egy új rendszermag fordítása után miért jelenik meg a archsw.readin.failed hibaüzenet az indítás során?<a class=anchor href=#_egy_új_rendszermag_fordítása_után_miért_jelenik_meg_a_archsw_readin_failed_hibaüzenet_az_indítás_során></a></h3><div class=paragraph><p>Mert a rendszermag és a felhasználói programok verziója eltér. A rendszermag frissítésekor feltétlenül használjuk a <code>make buildworld</code> és a <code>make buildkernel</code> parancsokat is!</p></div><div class=paragraph><p>A rendszerindítás második fokozatában közvetlenül meg tudjuk adni a betöltendõ rendszermagot, ha a betöltõ indítása elõtt, a <code>|</code> jel megjelenésekor lenyomunk egy billentyût.</p></div></div><div class=sect2><h3 id=_a_telepítés_megszakad_a_rendszer_indítása_közben_mit_lehet_ezzel_kezdeni>3.26. A telepítés megszakad a rendszer indítása közben, mit lehet ezzel kezdeni?<a class=anchor href=#_a_telepítés_megszakad_a_rendszer_indítása_közben_mit_lehet_ezzel_kezdeni></a></h3><div class=paragraph><p>Próbáljuk meg letiltani az ACPI támogatást. Ezt úgy tudjuk megtenni, hogy amikor a rendszertöltõ elindul, lenyomjuk a <kbd>Szóköz</kbd> billentyût. Ekkor a következõt kapjuk:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>OK</code></pre></div></div><div class=paragraph><p>Itt gépeljük be az alábbi parancsot:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> <span class=nb>unset </span>acpi_load</code></pre></div></div><div class=paragraph><p>Majd ezt:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> boot</code></pre></div></div></div></div></div><div class=sect1><h2 id=hardware>4. Hardverkompatibilitás<a class=anchor href=#hardware></a></h2><div class=sectionbody><div class=sect2><h3 id=compatibility-general>4.1. Általános kérdések<a class=anchor href=#compatibility-general></a></h3><div class=sect3><h4 id=_a_freebsd_rendszerükhöz_szeretnénk_hardvert_vásárolni_melyik_gyártmánymárkatípus_a_legjobb>4.1.1. A FreeBSD rendszerükhöz szeretnénk hardvert vásárolni. Melyik gyártmány/márka/típus a legjobb?<a class=anchor href=#_a_freebsd_rendszerükhöz_szeretnénk_hardvert_vásárolni_melyik_gyártmánymárkatípus_a_legjobb></a></h4><div class=paragraph><p>Ez állandó téma a FreeBSD levelezési listákon. Mivel a hardverek gyorsan változnak, nem is számíthatunk másra. <em>Továbbra</em> is határozottan javasoljuk, hogy olvassuk át figyelmesen a FreeBSD <a href=https://www.FreeBSD.org/releases/12.0R/hardware/>12.0</a> vagy <a href>11.2</a> változatához tartozó hardverjegyzéket (Hardware Notes) és nézzünk után a levelezési listák <a href=http://www.FreeBSD.org/search/#mailinglists>archívumában</a> mielõtt bármire is rákérdeznéünk a legfrissebb és legjobb hardverek ügyében. Könnyen elõfordulhat, hogy éppen a múlt héten esett szó arról a típusú eszközrõl, amirõl éppen érdeklõdni szeretnénk.</p></div><div class=paragraph><p>Ha laptoppal kapcsolatban lenne kérdésünk, akkor nézzük meg a <a href=https://lists.FreeBSD.org/subscription/freebsd-mobile>FreeBSD laptop computer levelezési lista</a> archívumát. Minden más esetben érdemes inkább a <a href=https://lists.FreeBSD.org/subscription/freebsd-questions>FreeBSD general questions levelezési lista</a> archívumait megnézni vagy az adott hardverhez tartozó levelezési listát böngészni.</p></div></div></div><div class=sect2><h3 id=compatibility-memory>4.2. Memória<a class=anchor href=#compatibility-memory></a></h3><div class=sect3><h4 id=_a_freebsd_képes_4_gb_nál_16_gb_nál_vagy_akár_48_gb_nál_több_memóriát_ram_ot_támogatni>4.2.1. A FreeBSD képes 4 GB-nál, 16 GB-nál vagy akár 48 GB-nál több memóriát (RAM-ot) támogatni?<a class=anchor href=#_a_freebsd_képes_4_gb_nál_16_gb_nál_vagy_akár_48_gb_nál_több_memóriát_ram_ot_támogatni></a></h4><div class=paragraph><p>Igen. A FreeBSD operációs rendszerként képes az adott platformon kihasználni az összes rendelkezésre álló fizikai memóriát. Ne felejtsük el azonban, hogy az egyes platformokon ennek határa eltér. Például az i386™ platformon a PAE használata nélkül legfeljebb csak 4 GB memóriát tudunk elérni (amely azonban a PCI számára fenntartott címtér miatt a valóságban némileg kevesebb), illetve a PAE használatával legfeljebb 64 GB memóriát. Az AMD64 platformokon viszont már egészen 1 TB memóriáig is elmehetünk.</p></div></div><div class=sect3><h4 id=_a_freebsd_miért_jelez_4_gb_nál_kevesebb_memóriát_i386_architektúrájú_számítógépeken>4.2.2. A FreeBSD miért jelez 4 GB-nál kevesebb memóriát i386™ architektúrájú számítógépeken?<a class=anchor href=#_a_freebsd_miért_jelez_4_gb_nál_kevesebb_memóriát_i386_architektúrájú_számítógépeken></a></h4><div class=paragraph><p>Az i386™ platformon a címtér 32 bites, ami azt jelenti, hogy itt legfeljebb 4 GB memória címezhetõ meg (és érhetõ el). Ráadásul a címtér bizonyos tartományait a hardvereszközök számára tartják fenn különbözõ célokra, például a PCI eszközök mûködtetésére és vezérlésére, a videomemória hozzáférésére stb. Ennélfogva az operációs rendszer és annak rendszermagja által felhasználható teljes memória mérete jelentõsen kevesebb, mint 4 GB. Ezen a típusú konfigurációkon általában 3,2 GB és 3,7 GB között mozog a maximálisan kihasználható fizikai memória mérete.</p></div><div class=paragraph><p>Ha mégis 3,2 vagy 3,7 GB-nál több memóriát szeretnénk elérni (4 GB-ot vagy akár annál is többet), akkor ahhoz a PAE nevû speciális módosításra lesz szükségünk. A PAE a "Physical Address Extension" ("Fizikai címkiterjesztés") rövidítése, és egy olyan módszerre utal, amellyel a 32 bites x86 típusú processzorokon tudunk 4 GB-nál több memóriát címezni. Lényegében nem csinál mást, csak 4 GB-os határ felé képezi le azokat a memóriaterületeket, amelyeket egyébként a hardverek részére tartanak fenn, ezzel kiegészíti a fizikai memóriát (<a href="https://man.freebsd.org/cgi/man.cgi?query=pae&amp;sektion=4&amp;format=html">pae(4)</a>). A PAE használatának számos hátránya van: ebben a módban a megszokottnál (vagyis PAE nélkül) némileg lassabb a memória elérése, illetve ilyenkor a betölthetõ rendszermag-modulok (lásd <a href="https://man.freebsd.org/cgi/man.cgi?query=kld&amp;sektion=4&amp;format=html">kld(4)</a>) sem támogatottak. Emiatt az összes meghajtót bele kell fordítanunk a rendszermagba.</p></div><div class=paragraph><p>A PAE használatát általában a <span class=filename>PAE</span> nevû, a rendszermaghoz gyárilag mellékelt konfigurációs állománnyal engedélyezhetjük. Ezt eleve úgy állították össze, hogy gond nélkül készíteni tudjuk egy ilyen rendszermagot. Érdemes azonban megemlíteni, hogy a konfigurációs állomány bizonyos tekintetben egy kissé konzervatív, mivel egyes PAE esetén használhatatlannak megjelölt meghajtók valójában mégis minden gond nélkül hozzáadhatóak a konfigurációhoz. Ezzel kapcsolatban azt javasoljuk, hogy ha az adott meghajtó használható valamelyik 64 bites architektúrán (például AMD64-en), akkor nagy valószínûséggel PAE-vel is mûködni fog. Amennyiben saját magunk szeretnénk egy PAE-rendszermagot készíteni, akkor a következõ sort tegyük bele a konfigurációs állományba:</p></div><div class="literalblock programlisting"><div class=content><pre>options       PAE</pre></div></div><div class=paragraph><p>A PAE alkalmazása napjainkban annyira már nem jellemzõ, mivel az újabb x86 hardverek mindegyike képes 64 bites (AMD64 vagy Intel® 64) módban futni. Ebben az esetben már lényegesen nagyobb címtér használatára nyílik lehetõségünk, így nincs szükségünk további trükkökre. A FreeBSD támogatja az AMD64 architektúrát, így ha 4 GB-nál több memóriát szeretnénk elérni, akkor inkább a FreeBSD ezen változatát érdemes alkalmazni.</p></div></div></div><div class=sect2><h3 id=compatibility-processors>4.3. Architektúrák és processzorok<a class=anchor href=#compatibility-processors></a></h3><div class=sect3><h4 id=_a_freebsd_az_x86_on_kívül_támogat_más_architektúrájú_rendszereket_is>4.3.1. A FreeBSD az x86-on kívül támogat más architektúrájú rendszereket is?<a class=anchor href=#_a_freebsd_az_x86_on_kívül_támogat_más_architektúrájú_rendszereket_is></a></h4><div class=paragraph><p>Igen. A FreeBSD jelenleg az Intel x86 és az AMD64 architektúrákon mûködik. A Az Intel EM64T, IA-64, ARM®, PowerPC®, sun4v és sparc64 architektúrák is támogatottak. A további tervezett platformok között van még a MIPS® és az S/390®, a MIPS® aktuális állapotáról és <a href=https://lists.FreeBSD.org/subscription/freebsd-mips>FreeBSD MIPS levelezési lista</a> segítségével értesülhetünk. Az újabb architektúrákhoz kapcsolódó általános jellegû megbeszéléseket a <a href=https://lists.FreeBSD.org/subscription/freebsd-platforms>FreeBSD non-Intel platforms levelezési lista</a> foglalja össze.</p></div><div class=paragraph><p>Amennyiben a számítógépünk architektúrája nem szerepel a jelenleg támogatottak között, és valamilyen gyors megoldásra lenne szükségünk, akkor javasoljuk a <a href=http://www.netbsd.org/>NetBSD</a> vagy az <a href=http://www.openbsd.org/>OpenBSD</a> használatát.</p></div></div><div class=sect3><h4 id=_a_freebsd_támogatja_a_szimmetrikus_többprocesszoros_smp_rendszereket>4.3.2. A FreeBSD támogatja a szimmetrikus többprocesszoros (SMP) rendszereket?<a class=anchor href=#_a_freebsd_támogatja_a_szimmetrikus_többprocesszoros_smp_rendszereket></a></h4><div class=paragraph><p>A FreeBSD általánosságban véve támogatja a többprocesszoros rendszereket, noha egyes esetekben a BIOS vagy az alaplap hibájából fakadóan problémáink adódhatnak. A <a href=https://lists.FreeBSD.org/subscription/freebsd-smp>FreeBSD symmetric multiprocessing levelezési lista</a> átolvasása segíthet tisztázni ezeket.</p></div><div class=paragraph><p>A FreeBSD képes kihasználni az Intel processzorai által felkínált HyperThreading (HTT) támogatás elõnyeit. Az <code>options SMP</code> beállítással fordított rendszermagok alapból maguktól felismerik a rendszerünkben található logikai processzorokat. A FreeBSD alapértelmezett ütemezõje ezeket a logikai processzorokat a többivel teljesen egyenrangúnak tekinti, vagyis semmilyen ütemezési kérdés eldöntésénél nem fogja figyelembevenni az egy processzoron belül elhelyezkedõ logikai processzorokat. Ezen naív ütemezési felfogás miatt bizonyos esetekben a rendszerünk teljesítménye nem tökéletesen optimális, ezért adódhatnak olyan helyzetek, amikor a <code>machdep.hlt_logical_cpus</code> sysctl-változó segítségével szükséges lehet a logikai processzorok használatának letiltása. Ezenkívül még a <code>machdep.hlt_logical_cpus</code> sysctl-változón keresztül lehetõségünk van leállítani az üresjáratban mûködõ processzorokat. Ennek részleteirõl bõvebben a <a href="https://man.freebsd.org/cgi/man.cgi?query=smp&amp;sektion=4&amp;format=html">smp(4)</a> man oldalon olvashatunk.</p></div></div></div><div class=sect2><h3 id=compatibility-drives>4.4. Merevlemezes, szalagos, CD- és DVD-meghajtók<a class=anchor href=#compatibility-drives></a></h3><div class=sect3><h4 id=_a_freebsd_milyen_típusú_merevlemezes_meghajtókat_ismer>4.4.1. A FreeBSD milyen típusú merevlemezes meghajtókat ismer?<a class=anchor href=#_a_freebsd_milyen_típusú_merevlemezes_meghajtókat_ismer></a></h4><div class=paragraph><p>A FreeBSD ismeri az EIDE-, SATA-, SCSI- és SAS-meghajtókat (és a velük kompatibilis vezérlõket, errõl bõvebben lásd a következõ szakaszt), valamint az összes olyan meghajtót, amely az eredeti "Western Digital" (MFM, RLL, ESDI és természetesen az IDE) interfészt használja. Néhány egyedi fejlesztésû ESDI vezérlõ nem fog mûködni, ezért lehetõleg maradjunk a WD1002/3/6/7 interfészeknél és azok másolatainál.</p></div></div><div class=sect3><h4 id=_milyen_scsi_vagy_sas_vezérlõket_ismer>4.4.2. Milyen SCSI- vagy SAS-vezérlõket ismer?<a class=anchor href=#_milyen_scsi_vagy_sas_vezérlõket_ismer></a></h4><div class=paragraph><p>A teljes listát a FreeBSD hardverjegyzékében találhatjuk meg a <a href=https://www.FreeBSD.org/releases/12.0R/hardware/>12.0</a> vagy <a href>11.2</a> kiadásban.</p></div></div><div class=sect3><h4 id=_milyen_szalagos_meghajtókat_ismer>4.4.3. Milyen szalagos meghajtókat ismer?<a class=anchor href=#_milyen_szalagos_meghajtókat_ismer></a></h4><div class=paragraph><p>A FreeBSD a SCSI és QIC-36 (QIC-02 interfésszel) szabványokat ismeri. Ezek közé értendõek a 8 mm-es (más néven Exabyte) és DAT-meghajtók is.</p></div><div class=paragraph><p>Bizonyos régebbi 8 mm-es meghajtók nem egészen kompatibilisek a SCSI-2 szabvánnyal, ezért a FreeBSD-vel sem feltétlenül képesek együttmûködni.</p></div></div><div class=sect3><h4 id=_a_freebsd_támogatja_a_szalagok_cseréjét>4.4.4. A FreeBSD támogatja a szalagok cseréjét?<a class=anchor href=#_a_freebsd_támogatja_a_szalagok_cseréjét></a></h4><div class=paragraph><p>A FreeBSD <a href="https://man.freebsd.org/cgi/man.cgi?query=ch&amp;sektion=4&amp;format=html">ch(4)</a> eszközön és a <a href="https://man.freebsd.org/cgi/man.cgi?query=chio&amp;sektion=1&amp;format=html">chio(1)</a> parancson keresztül támogatja a SCSI szabványú szalagcserélõket. A használat pontos részleteirõl a <a href="https://man.freebsd.org/cgi/man.cgi?query=chio&amp;sektion=1&amp;format=html">chio(1)</a> man oldalán olvashatunk részletesebben.</p></div><div class=paragraph><p>Ha nem az AMANDA vagy a hozzá hasonló programokat használjuk, amelyek alapból ismerik a szalagcserélés lehetõségét, akkor ne feledkezzünk meg arról, hogy a szalagot csak az egyik helyrõl a másikra tudjuk mozgatni, ezért nekünk kell figyelnünk arra, hogy melyik rekeszben vannak szalagok és a meghajtónak ezek közül melyiket kell használnia.</p></div></div><div class=sect3><h4 id=_a_freebsd_milyen_cd_meghajtókat_ismer>4.4.5. A FreeBSD milyen CD-meghajtókat ismer?<a class=anchor href=#_a_freebsd_milyen_cd_meghajtókat_ismer></a></h4><div class=paragraph><p>Bármilyen támogatott SCSI-vezérlõhöz csatlakoztatható SCSI-meghajtót ismer.</p></div><div class=paragraph><p>Ezenkívül még az alábbi CD-interfészek ismertek:</p></div><div class=ulist><ul><li><p>Mitsumi LU002 (8 bites), LU005 (16 bites) és FX001D (16 bites, dupla sebességû).</p></li><li><p>Sony CDU 31/33A</p></li><li><p>Sound Blaster nem-SCSI CD-meghajtók</p></li><li><p>Matsushita/Panasonic CD-meghajtók</p></li><li><p>ATAPI kompatibilis IDE CD-meghajtók</p></li></ul></div><div class=paragraph><p>Az összes ismert nem-SCSI kártya nagyon lassan mûködik a SCSI-meghajtókhoz képest, és bizonyos ATAPI CD-meghajtók nem használhatóak.</p></div><div class=paragraph><p>A Daemon News-tól és a FreeBSD Mall-tól rendelhetõ hivatalos FreeBSD CD-krõl akár közvetlenül el is tudjuk indítani a rendszert.</p></div></div><div class=sect3><h4 id=_a_freebsd_milyen_cd_rw_meghajtókat_ismer>4.4.6. A FreeBSD milyen CD-RW meghajtókat ismer?<a class=anchor href=#_a_freebsd_milyen_cd_rw_meghajtókat_ismer></a></h4><div class=paragraph><p>A FreeBSD bármilyen ATAPI-kompatibilis IDE CD-R vagy CD-RW meghajtót ismer. Ennek részleteit lásd a <a href="https://man.freebsd.org/cgi/man.cgi?query=burncd&amp;sektion=8&amp;format=html">burncd(8)</a> man oldalán.</p></div><div class=paragraph><p>A FreeBSD ezeken kívül még tetszõleges SCSI CD-R vagy CD-RW meghajtót támogat. A használatukhoz telepítsük a <code>cdrecord</code> programot a portok vagy csomagok közül, és gondoskodjunk róla, hogy a <span class=filename>pass</span> eszköz támogatása benne legyen a rendszermagban.</p></div></div><div class=sect3><h4 id=_a_freebsd_ismeri_az_zip_meghajtókat>4.4.7. A FreeBSD ismeri az Zip® meghajtókat?<a class=anchor href=#_a_freebsd_ismeri_az_zip_meghajtókat></a></h4><div class=paragraph><p>A FreeBSD alapból ismeri a SCSI és ATAPI (IDE) interfészen kommunikáló Zip® meghajtókat. A SCSI ZIP-meghajtók ugyan egyedül az 5 és 6 target ID-krõl hajlandóak mûködni, de ha a SCSI-kártyánk BIOS-a támogatja, akkor még a rendszert is el tudjuk indítani róluk. Egyelõre nem tisztázott, hogy milyen kártyák képesek a 0 és 1 ID-ken kívül máshonnan is rendszert indítani, ezért ennek a hozzá tartozó dokumentációben érdemes utánajárnunk.</p></div><div class=paragraph><p>A FreeBSD ezenkívül még a párhuzamos porton csatlakoztatható ZIP-meghajtókat is ismeri. Ehhez ellenõrizzük, hogy a rendszermagunkban megtalálhatóak az <span class=filename>scbus0</span>, <span class=filename>da0</span>, <span class=filename>ppbus0</span> és <span class=filename>vp0</span> meghajtók (a <span class=filename>GENERIC</span> rendszermagban a <span class=filename>vp0</span> kivételével mindegyik szerepel). Segítségükkel a párhuzamos vonalon csatlakozó meghajtó a <span class=filename>da0s4</span> eszközön keresztül érhetõ el. Ennek megfelelõen az állományrendszerek a <code>mount /dev/da0s4 /mnt</code> <em>vagy</em> (DOS esetén) a <code>mount -t msdosfs /dev/da0s4 /mnt</code> parancs kiadásával csatlakoztathatóak.</p></div><div class=paragraph><p>Emellett még érdemes a GYIK <a href=#media-change>cserélhetõ lemezes meghajtókról szóló részét</a> is elolvasnunk ebben a fejezetben, valamint <a href=#removable-drives>a "formázásról" szóló megjegyzést</a> az adminisztrációról szóló fejezetben.</p></div></div><div class=sect3><h4 id=_a_freebsd_ismeri_a_jaz_ez_és_a_többi_cserélhetõ_lemezes_meghajtót>4.4.8. A FreeBSD ismeri a Jaz®, EZ és a többi cserélhetõ lemezes meghajtót?<a class=anchor href=#_a_freebsd_ismeri_a_jaz_ez_és_a_többi_cserélhetõ_lemezes_meghajtót></a></h4><div class=paragraph><p>Használhatóak. Ezek többsége SCSI eszköz, ezért a FreeBSD SCSI-lemezként látja, az IDE csatolós EZ pedig IDE-meghajtóként érhetõ el.</p></div><div class=paragraph><p>A rendszer indítása elõtt ne felejtsük el bekapcsolni a külsõ egységeket.</p></div><div class=paragraph><p><a id=media-change></a>Ha tárolóeszközt akarunk cserélni a rendszer mûködése közben, olvassuk el a <a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=umount&amp;sektion=8&amp;format=html">umount(8)</a> és (SCSI eszközök esetén) a <a href="https://man.freebsd.org/cgi/man.cgi?query=camcontrol&amp;sektion=8&amp;format=html">camcontrol(8)</a> vagy (IDE eszközök esetén) a <a href="https://man.freebsd.org/cgi/man.cgi?query=atacontrol&amp;sektion=8&amp;format=html">atacontrol(8)</a> man oldalakat, valamint a GYIK egy késõbbi részében található <a href=#removable-drives>részt a cserélhetõ lemezes meghajtókról</a>.</p></div></div></div><div class=sect2><h3 id=compatibility-kbd-mice>4.5. Egér és billentyûzet<a class=anchor href=#compatibility-kbd-mice></a></h3><div class=sect3><h4 id=_a_freebsd_ismeri_az_usb_billentyûzeket>4.5.1. A FreeBSD ismeri az USB billentyûzeket?<a class=anchor href=#_a_freebsd_ismeri_az_usb_billentyûzeket></a></h4><div class=paragraph><p>A FreeBSD alapból ismeri az USB billentyûzeket. Miután engedélyeztük rendszerünkben az USB billentyûzet támogatását, az AT billentyûzet <span class=filename>/dev/kbd0</span> lesz és az USB billentyûzet pedig <span class=filename>/dev/kbd1</span>, már amennyiben mind a kettõt csatlakoztattuk a számítógépünkhöz. Ha viszont csak USB billentyûzetünk van, akkor az a <span class=filename>/dev/ukbd0</span> lesz.</p></div><div class=paragraph><p>Ha az USB billentyûzetet konzolban akarjuk használni, akkor erre figyelmeztetnünk kell a konzolos meghajtót. Ezt úgy tudjuk megtenni, ha a következõ parancsot lefuttatjuk a rendszer indítása közben:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kbdcontrol -k /dev/kbd1 &lt; /dev/console &gt; /dev/null</span></code></pre></div></div><div class=paragraph><p>Amikor viszont csak USB billentyûzetünk van, akkor az <span class=filename>/dev/ukbd0</span> eszközön keresztül tudjuk elérni, ezért a parancsnak ilyenkor így kell kinéznie:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kbdcontrol -k /dev/ukbd0 &lt; /dev/console &gt; /dev/null</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Ha véglegesíteni akarjuk ezt a beállítást, akkor tegyük a <code>keyboard="/dev/ukbd0"</code> sort az <span class=filename>/etc/rc.conf</span> állományba.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Miután ezt megcsináltuk, az USB billentyûzet X alatt is mûködni fog minden további beállítás nélkül.</p></div><div class=paragraph><p>Ezzel a paranccsal tudunk visszaváltani az alapértelmezett billentyûzetre:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kbdcontrol -k /dev/kbd0 &gt; /dev/null</span></code></pre></div></div><div class=paragraph><p>A <a href="https://man.freebsd.org/cgi/man.cgi?query=kbdmux&amp;sektion=4&amp;format=html">kbdmux(4)</a> meghajtón keresztül az alábbi parancsok kiadásával engedélyezhetjük az elsõdleges AT billentyûzet és a másodlagos USB billentyûzet párhuzamos használatát a konzolon:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kbdcontrol -K &lt; /dev/console &gt; /dev/null</span>
<span class=c># kbdcontrol -a atkbd0 &lt; /dev/kbdmux0 &gt; /dev/null</span>
<span class=c># kbdcontrol -a ukbd1 &lt; /dev/kbdmux0 &gt; /dev/null</span>
<span class=c># kbdcontrol -k /dev/kbdmux0 &lt; /dev/console &gt; /dev/null</span></code></pre></div></div><div class=paragraph><p>Részletesebb információkat az <a href="https://man.freebsd.org/cgi/man.cgi?query=ukbd:&amp;sektion=4&amp;format=html">ukbd:(4)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=kbdcontrol&amp;sektion=1&amp;format=html">kbdcontrol(1)</a> és <a href="https://man.freebsd.org/cgi/man.cgi?query=kbdmux&amp;sektion=4&amp;format=html">kbdmux(4)</a> man oldalakon találhatunk.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Az USB billentyûzet menet közbeni csatlakoztatása és leválasztása nem feltétlenül fog mûködni. Ezért a problémák elkerülése érdekében azt javasoljuk, hogy a rendszer indítása elõtt mindenképpen csatlakoztassuk a billentyûzetet és hagyjuk egészen úgy, amíg le nem állítottuk.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=_a_nem_szabványos_buszos_egereket_hogyan_lehet_beállítani>4.5.2. A nem szabványos buszos egereket hogyan lehet beállítani?<a class=anchor href=#_a_nem_szabványos_buszos_egereket_hogyan_lehet_beállítani></a></h4><div class=paragraph><p>A FreeBSD ismeri a buszos, illetve a Microsoft, Logitech és az ATI által gyártott InPort buszos egereket. A <span class=filename>GENERIC</span> rendszermag azonban ehhez nem tartalmaz meghajtót. A rendszermag konfigurációs állományába a következõ sort kell megadni, ha egy buszos egereket támogató rendszermagot akarunk készíteni:</p></div><div class="literalblock programlisting"><div class=content><pre>device mse0 at isa? port 0x23c irq5</pre></div></div><div class=paragraph><p>A buszos egerekhez általában saját interfészkártya is tartozik. Ezeket a kártyákat a fentitõl eltérõ portcímre és IRQ megszakításra is beállíthatjuk. Részletesebb információkat az egerünk man oldalán és a <a href="https://man.freebsd.org/cgi/man.cgi?query=mse&amp;sektion=4&amp;format=html">mse(4)</a> man oldalon olvashatunk.</p></div></div><div class=sect3><h4 id=_hogyan_lehet_ps2_egérportos_vagy_billentyûzetes_egeret_használni>4.5.3. Hogyan lehet PS/2 (egérportos vagy billentyûzetes) egeret használni?<a class=anchor href=#_hogyan_lehet_ps2_egérportos_vagy_billentyûzetes_egeret_használni></a></h4><div class=paragraph><p>Az PS/2 egereket alapból támogatjuk. Az ehhez szükséges <span class=filename>psm</span> meghajtó megtalálható a rendszermagban.</p></div><div class=paragraph><p>Ha a saját magunk által összeállított rendszermagunk nem tartalmazza ezt a meghajtót, akkor a következõ sort kell felvennünk a konfigurációs állományba:</p></div><div class="literalblock programlisting"><div class=content><pre>device psm0 at atkbdc? irq 12</pre></div></div><div class=paragraph><p>Miután a rendszermag a rendszer indítása során helyesen észlelte a <span class=filename>psm0</span> eszközt, magától létrejön.</p></div></div><div class=sect3><h4 id=moused>4.5.4. Az egeret az X Window Systemen kívül is lehet valamilyen módon használni?<a class=anchor href=#moused></a></h4><div class=paragraph><p>Ha az alapértelmezett konzolos <a href="https://man.freebsd.org/cgi/man.cgi?query=syscons&amp;sektion=4&amp;format=html">syscons(4)</a> meghajtót használjuk, akkor a szöveges felületû konzolokon az egérmutató segítségével tudunk szövegrészeket kijelölni és másolni. Ehhez nem kell mást tennünk, csupán elindítani a <a href="https://man.freebsd.org/cgi/man.cgi?query=moused&amp;sektion=8&amp;format=html">moused(8)</a> egérdémont és engedélyezni az egérmutatót a virtuális konzolokon:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># moused -p /dev/xxxx -t yyyy</span>
<span class=c># vidcontrol -m on</span></code></pre></div></div><div class=paragraph><p>Itt az <em>xxxx</em> az egeret leképezõ eszköz neve és az <em>yyyy</em> az egérhez használt protokoll típusa. Az egérdémon a legtöbb egér esetén képes magától megállapítani az alkalmazott protokoll típusát, kivéve a régebbi soros egereket. Az <code>auto</code> érték megadásával tudjuk aktiválni ezt az automatikus felderítést. Amennyiben ez nem mûködik, a <a href="https://man.freebsd.org/cgi/man.cgi?query=moused&amp;sektion=8&amp;format=html">moused(8)</a> man oldalán nézhetünk után a támogatott protokolloknak.</p></div><div class=paragraph><p>Ha PS/2 egerünk van, akkor egyszerûen csak vegyük fel a <code>moused_enable="YES"</code> sor az <span class=filename>/etc/rc.conf</span> állományba, és az egérdémon elindul a rendszer indítása közben. Valamint hogy ha az egérdémont a konzol helyett az összes virtuális konzolon is használni akarjuk, akkor az <span class=filename>/etc/rc.conf</span> állományba tegyük bele a <code>allscreens_flags="-m on"</code> sort.</p></div><div class=paragraph><p>Miután az egérdémon elindult, valamilyen módon koordinálni kell az egér hozzáférését az egérdémon és az összes többi program, például az X Window System között. Errõl a problémáról a GYIK <a href=#x-and-moused>Miért nem mûködik X alatt az egér?</a> kérdésében olvashatunk részletesebb.</p></div></div><div class=sect3><h4 id=_hogyan_lehet_szöveget_kijelölni_és_másolni_a_szöveges_konzolban>4.5.5. Hogyan lehet szöveget kijelölni és másolni a szöveges konzolban?<a class=anchor href=#_hogyan_lehet_szöveget_kijelölni_és_másolni_a_szöveges_konzolban></a></h4><div class=paragraph><p>Ahogy sikerült elindítanunk az egérdémont (lásd az <a href=#moused>elõzõ szakaszt</a>), tartsuk lenyomva az egér elsõ (bal oldali) gombját és az egér mozgatásával jelöljük ki a szöveget. Ezután nyomjuk le a második (középsõ) gombját, amivel a kurzor mellett megjelenik az imént kijelölt szöveg. A harmadik (jobb oldali) gomb segítségével a szöveg kijelölését tudjuk "kiterjeszteni".</p></div><div class=paragraph><p>Amennyiben az egerünkön nem található középsõ gomb, az egérdémon beállításainak segítségével megpróbálkozhatunk emulálni vagy áthelyezni a vele kapcsolatos funkciókat egy másik gombra. A <a href="https://man.freebsd.org/cgi/man.cgi?query=moused&amp;sektion=8&amp;format=html">moused(8)</a> man oldalán olvashatunk errõl részletesebben.</p></div></div><div class=sect3><h4 id=_az_egéren_van_mindenféle_görgõ_és_gomb_ki_lehet_ezeket_valahogy_használni_freebsd_alatt_is>4.5.6. Az egéren van mindenféle görgõ és gomb. Ki lehet ezeket valahogy használni FreeBSD alatt is?<a class=anchor href=#_az_egéren_van_mindenféle_görgõ_és_gomb_ki_lehet_ezeket_valahogy_használni_freebsd_alatt_is></a></h4><div class=paragraph><p>A válaszunk erre sajnos csupán annyi, hogy "Attól függ". A különbözõ kiegészítõkkel rendelkezõ egerekhez általában egy külön meghajtó szükségeltetik. Hacsak az egér meghajtóprogramja vagy a hozzá tartozó felhasználói program nem nyújt valamilyen támogatást, az eszköz egyszerûen csak egy szabványos két- vagy háromgombos egérként fog funkcionálni.</p></div><div class=paragraph><p>Ha az X Window környezetben akarunk görgõket használni, esetleg <a href=#x-and-wheel>ezt a szakaszt</a> érdemes elolvasnunk.</p></div></div><div class=sect3><h4 id=_a_laptopokon_megtalálható_egértrackballtouchpad_hogyan_használható>4.5.7. A laptopokon megtalálható egér/trackball/touchpad hogyan használható?<a class=anchor href=#_a_laptopokon_megtalálható_egértrackballtouchpad_hogyan_használható></a></h4><div class=paragraph><p>Olvassuk el <a href=#ps2mouse>az elõzõ kérdésre adott választ</a>.</p></div></div><div class=sect3><h4 id=_a_delete_billentyû_hogyan_használható_a_sh_és_csh_parancsértelmezõkben>4.5.8. A Delete billentyû hogyan használható a sh és csh parancsértelmezõkben?<a class=anchor href=#_a_delete_billentyû_hogyan_használható_a_sh_és_csh_parancsértelmezõkben></a></h4><div class=paragraph><p>A Bourne Shell esetében az alábbi sorokat kell megadnunk az <span class=filename>.shrc</span> állományunkban. Lásd <a href="https://man.freebsd.org/cgi/man.cgi?query=sh&amp;sektion=1&amp;format=html">sh(1)</a> és <a href="https://man.freebsd.org/cgi/man.cgi?query=editrc&amp;sektion=5&amp;format=html">editrc(5)</a>.</p></div><div class="literalblock programlisting"><div class=content><pre>bind ^? ed-delete-next-char # a konzolhoz
bind ^[[3~ ed-delete-next-char # az xtermhez</pre></div></div><div class=paragraph><p>A C Shell esetében a következõ soroknak kell az <span class=filename>.cshrc</span> állományba kerülnie. Lásd <a href="https://man.freebsd.org/cgi/man.cgi?query=csh&amp;sektion=1&amp;format=html">csh(1)</a>.</p></div><div class="literalblock programlisting"><div class=content><pre>bindkey ^? delete-char # a konzolhoz
bindkey ^[[3~ delete-char # az xtermhez</pre></div></div><div class=paragraph><p>További információkat <a href=http://www.ibb.net/~anne/keyboard.html>ezen az oldalon</a> találhatunk.</p></div></div></div><div class=sect2><h3 id=compatibility-networking>4.6. Hálózati és soros eszközök<a class=anchor href=#compatibility-networking></a></h3><div class=sect3><h4 id=_a_freebsd_milyen_hálózati_kártyákat_ismer>4.6.1. A FreeBSD milyen hálózati kártyákat ismer?<a class=anchor href=#_a_freebsd_milyen_hálózati_kártyákat_ismer></a></h4><div class=paragraph><p>Ezek teljes listáját a FreeBSD egyes kiadásaihoz tartozó hardverjegyzékben találjuk meg.</p></div></div><div class=sect3><h4 id=_a_freebsd_ismer_szoftveres_modemeket_például_winmodemeket>4.6.2. A FreeBSD ismer szoftveres modemeket, például winmodemeket?<a class=anchor href=#_a_freebsd_ismer_szoftveres_modemeket_például_winmodemeket></a></h4><div class=paragraph><p>A FreeBSD különbözõ kiegészítõ szoftvereken keresztül több szoftveres modemet is támogat. A <a class=package href=https://cgit.freebsd.org/ports/tree/comms/ltmdm/>comms/ltmdm</a> port például a szélesebb körben elterjedt Lucent LT chipsetes modemekhez ad támogatást.</p></div><div class=paragraph><p>A FreeBSD azonban nem telepíthetõ szoftveres modemen keresztül. A hozzá tartozó szoftvert csak az operációs rendszer telepítése után tudjuk telepíteni.</p></div></div><div class=sect3><h4 id=_van_natív_meghajtó_a_broadcom_43xx_típusú_kártyákhoz>4.6.3. Van natív meghajtó a Broadcom 43xx típusú kártyákhoz?<a class=anchor href=#_van_natív_meghajtó_a_broadcom_43xx_típusú_kártyákhoz></a></h4><div class=paragraph><p>Nem, és valószínûleg nem is lesz.</p></div><div class=paragraph><p>A Broadcom nem hajlandó nyilvánossá tenni azokat az információkat, amik az általuk gyártott vezeték nélküli chipsetek programozásához lennének szükségesek, mivel szoftveresen vezérelt rádiót használnak. Az alkatrészeik FCC szintû engedélyeztetéséhez ugyanis valamilyen módon gondoskodniuk kell róla, hogy a felhasználók nem képesek bizonyos dolgokat módosítani vele kapcsolatban, például a mûködési frekvenciát, a modulációs paramétereket vagy a kimenõ teljesítményt. A chipsetek programozásának ismerete nélkül azonban szinte lehetetlen elkészíteni hozzájuk a megfelelõ meghajtót.</p></div></div><div class=sect3><h4 id=_a_freebsd_milyen_többportos_soros_vonali_kártyákat_ismer>4.6.4. A FreeBSD milyen többportos soros vonali kártyákat ismer?<a class=anchor href=#_a_freebsd_milyen_többportos_soros_vonali_kártyákat_ismer></a></h4><div class=paragraph><p>Ezek listáját a kézikönyv <a href=https://docs.freebsd.org/hu/books/handbook/serialcomms/#serial>Soros vonali kommunikációról szóló része</a> tartalmazza.</p></div><div class=paragraph><p>Bizonyos névtelen másolatok is használhatók, különösen azok, amelyek magukat AST-kompatibilisnek nevezik.</p></div><div class=paragraph><p>Az ilyen kártyák beállításáról a <a href="https://man.freebsd.org/cgi/man.cgi?query=sio&amp;sektion=4&amp;format=html">sio(4)</a> man oldalon olvashatunk részletesebben.</p></div></div><div class=sect3><h4 id=_hogyan_lehet_a_boot_parancssort_elõhozni_soros_vonali_konzolon>4.6.5. Hogyan lehet a boot: parancssort elõhozni soros vonali konzolon?<a class=anchor href=#_hogyan_lehet_a_boot_parancssort_elõhozni_soros_vonali_konzolon></a></h4><div class=paragraph><p>Olvassuk el a kézikönyvben <a href=https://docs.freebsd.org/hu/books/handbook/serialcomms/#serialconsole-setup>ezt a fejezetet</a>.</p></div></div></div><div class=sect2><h3 id=compatibility-sound>4.7. Hang<a class=anchor href=#compatibility-sound></a></h3><div class=sect3><h4 id=_a_freebsd_milyen_hangkártyákat_ismer>4.7.1. A FreeBSD milyen hangkártyákat ismer?<a class=anchor href=#_a_freebsd_milyen_hangkártyákat_ismer></a></h4><div class=paragraph><p>A FreeBSD rengeteg hangkártyát ismer, (ennek részleteit lásd a <a href=https://www.FreeBSD.org/releases/>FreeBSD kiadásait tartalmazó</a> honlapon és a <a href="https://man.freebsd.org/cgi/man.cgi?query=snd&amp;sektion=4&amp;format=html">snd(4)</a> man oldalon). Korlátozott módon az MPU-401 és a vele kompatibilis MIDI-kártyákat is támogatja. A Microsoft® Sound System specifikációinak megfelelõ kártyákat tudjuk használni.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Ez azonban csak a hangra vonatkozik! Ez a meghajtó a SoundBlaster® kivételével nem támogatja a kártyákon található CD-, SCSI- és joystick csatlakozásokat. A SoundBlaster® SCSI csatlakozása és bizonyos nem-SCSI CD-meghajtókat ugyan támogat, de rendszert például nem tudunk róluk indítani.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=_miért_nincs_hang_a_pcm4_által_támogatott_hangkártyán>4.7.2. Miért nincs hang a <a href="https://man.freebsd.org/cgi/man.cgi?query=pcm&amp;sektion=4&amp;format=html">pcm(4)</a> által támogatott hangkártyán?<a class=anchor href=#_miért_nincs_hang_a_pcm4_által_támogatott_hangkártyán></a></h4><div class=paragraph><p>Egyes hangkártyák esetében a hangerõ minden indításkor nullára állítódik. Ezért ilyenkor mindig ki kell adni a következõ parancsot:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mixer pcm 100 vol 100 cd 100</span></code></pre></div></div></div></div><div class=sect2><h3 id=compatibility-other>4.8. Egyéb eszközök<a class=anchor href=#compatibility-other></a></h3><div class=sect3><h4 id=_képes_a_freebsd_kihasználni_az_energiagazdálkodási_lehetõségeket_egy_laptopon>4.8.1. Képes a FreeBSD kihasználni az energiagazdálkodási lehetõségeket egy laptopon?<a class=anchor href=#_képes_a_freebsd_kihasználni_az_energiagazdálkodási_lehetõségeket_egy_laptopon></a></h4><div class=paragraph><p>A FreeBSD bizonyos gépeken képes az APM használatára. Errõl az <a href="https://man.freebsd.org/cgi/man.cgi?query=apm&amp;sektion=4&amp;format=html">apm(4)</a> man oldalon találunk pontosabb leírást.</p></div><div class=paragraph><p>A FreeBSD ezenkívül még a legújabb hardverekben megtalálható ACPI lehetõségeit is igyekezik kihasználni. Errõl részletesebben az <a href="https://man.freebsd.org/cgi/man.cgi?query=acpi&amp;sektion=4&amp;format=html">acpi(4)</a> man oldalon olvashatunk. Amennyiben a rendszerünk egyaránt tartalmazza az APM és az ACPI támogatását, bármelyiket használhatjuk. Ilyen esetben javasoljuk mind a kettõ kipróbálását és az igényeinkhez leginkább illeszkedõ megoldás kiválasztását.</p></div></div><div class=sect3><h4 id=_hogy_lehet_letiltani_az_acpi_támogatását>4.8.2. Hogy lehet letiltani az ACPI támogatását?<a class=anchor href=#_hogy_lehet_letiltani_az_acpi_támogatását></a></h4><div class=paragraph><p>Tegyük bele az alábbi sort az <span class=filename>/boot/device.hints</span> állományba:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>hint.acpi.0.disabled<span class=o>=</span><span class=s2>&#34;1&#34;</span></code></pre></div></div></div><div class=sect3><h4 id=_miért_fagynak_le_a_micron_típusú_rendszerek_indulás_közben>4.8.3. Miért fagynak le a Micron típusú rendszerek indulás közben?<a class=anchor href=#_miért_fagynak_le_a_micron_típusú_rendszerek_indulás_közben></a></h4><div class=paragraph><p>Egyes Micron gyártmányú alaplapokon olyan PCI BIOS található, amely nem felel meg az szabványoknak, és ezért a FreeBSD nem tud elindulni, mivel a PCI eszközök nem jelentik le az általuk használt címeket.</p></div><div class=paragraph><p>Ezt a problémát úgy tudjuk megoldani, ha a BIOS-ban kikapcsoljuk (<code>Disabled</code> értékûre állítjuk) a "Plug and Play Operating System" beállítást.</p></div></div><div class=sect3><h4 id=_a_rendszerindító_lemez_nem_képes_az_asus_k7v_alaplapokkal_mûködni_hogyan_lehet_ezt_orvosolni>4.8.4. A rendszerindító lemez nem képes az ASUS K7V alaplapokkal mûködni. Hogyan lehet ezt orvosolni?<a class=anchor href=#_a_rendszerindító_lemez_nem_képes_az_asus_k7v_alaplapokkal_mûködni_hogyan_lehet_ezt_orvosolni></a></h4><div class=paragraph><p>Menjünk be a BIOS-ba és kapcsoljuk ki (állítsuk <code>Disabled</code> értékre) a "Boot Virus Protection" beállítást.</p></div></div><div class=sect3><h4 id=_miért_nem_mûködnek_a_3com_pci_hálózati_kártyák_a_micron_típusú_számítógépekben>4.8.5. Miért nem mûködnek a 3Com® PCI hálózati kártyák a Micron típusú számítógépekben?<a class=anchor href=#_miért_nem_mûködnek_a_3com_pci_hálózati_kártyák_a_micron_típusú_számítógépekben></a></h4><div class=paragraph><p>Nézzük meg <a href=#micron-hang-boot>az elõzõ választ</a>.</p></div></div></div></div></div><div class=sect1><h2 id=_hibaelhárítás>5. Hibaelhárítás<a class=anchor href=#_hibaelhárítás></a></h2><div class=sectionbody><div class=sect2><h3 id=_miért_állapítja_meg_rosszul_a_freebsd_a_memória_mennyiségét_i386_hardveren>5.1. Miért állapítja meg rosszul a FreeBSD a memória mennyiségét i386™ hardveren?<a class=anchor href=#_miért_állapítja_meg_rosszul_a_freebsd_a_memória_mennyiségét_i386_hardveren></a></h3><div class=paragraph><p>A válasz nagy valószínûséggel a fizikai és virtuális memóriacímek közti különbségben rejlik.</p></div><div class=paragraph><p>A legtöbb PC-s hardvereszköz megegyezés szerint a 3,5 GB és 4 GB közti memóriaterületet speciális célokra tartja fenn (általában a PCI számára). Ezen a címterületen keresztül éri a PCI eszközöket. Ennek egyik következménye, hogy a fizikai memória ezen a részen nem érhetõ el.</p></div><div class=paragraph><p>Hogy pontosan mi történik az itt elhelyezkedõ memóriával, teljesen a hardvertõl függ. Sajnálatos módon bizonyos eszközök semmilyen megoldást nem nyújtanak a problémára, és így lényegében az utolsó 500 MB-nyi memória elveszik.</p></div><div class=paragraph><p>Szerencsére a legtöbb eszköz azonban képes ezt a területet egy felsõbb címre leképezni, így ki tudjuk használni. Ilyenkor azonban tapasztalhatunk némi félreértést, amikor megnézzük a rendszerindítás közben megjelenõ üzeneteket.</p></div><div class=paragraph><p>A FreeBSD 32 bites változata esetén ez a memóriaterület elveszik, mivel a címe a 4 GB-os határ felé kerül, amelyet a 32 bites módban futó rendszermag már nem képes elérni. Ezen egy PAE támogatással rendelkezõ rendszermag használatával segíthetünk. A GYIK-on belül <a href=#memory-limits>ebben a bejegyzésben</a> olvashatunk bõvebben a memóriakorlátokról, valamint <a href=#memory-upper-limitation>ebben a részben</a> láthatjuk a különbözõ platformokra vonatkozó memóriakorlátozásokat.</p></div><div class=paragraph><p>A FreeBSD 64 bites változata vagy a PAE használata esetén azonban a FreeBSD rendesen felismeri és leképezi a fennmaradó memóriaterületeket, így azok használhatóvá válnak. A rendszerindítás során azonban az elõbb említett leképezés miatt látszólag úgy fog tûnni, mintha a FreeBSD több memóriát észlelne, mint amennyivel valójában rendelkezünk. Ez teljesen normálisnak tekinthetõ és a ténylegesen elérhetõ memória mennyisége a folyamat végén be fog állítódni.</p></div></div><div class=sect2><h3 id=_mit_tegyünk_ha_meghibásodott_szektorokat_találunk_a_merevlemezünkön>5.2. Mit tegyünk, ha meghibásodott szektorokat találunk a merevlemezünkön?<a class=anchor href=#_mit_tegyünk_ha_meghibásodott_szektorokat_találunk_a_merevlemezünkön></a></h3><div class=paragraph><p>A SCSI-meghajtók esetében a meghajtó általában képes önmagától átképezni az ilyen szektorokat. A legtöbb meghajtóban ez a lehetõség viszont alapból nem engedélyezett.</p></div><div class=paragraph><p>A hibás szektorok átképezéséhez az eszköz elsõ lapmódját kell átírnunk, amelyet (<code>root</code> felhasználóként) így tehetünk meg:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># camcontrol modepage sd0 -m 1 -e -P 3</span></code></pre></div></div><div class=paragraph><p>Változtassuk meg az AWRE (az írás automatikus átképzése) és ARRE (az olvasás automatikus átképzése) beállítások értékeit 0-ról 1-re:</p></div><div class="literalblock programlisting"><div class=content><pre>AWRE (Auto Write Reallocation Enbld):  1
ARRE (Auto Read Reallocation Enbld):  1</pre></div></div><div class=paragraph><p>A modernebb IDE-meghajtók is képesek a vezérlõjükkel nyilvántartani az idõközben meghibásodott szektorokat, és ezt általában alapból engdélyezik.</p></div><div class=paragraph><p>Ha rossz szektorokra figyelmeztetõ hibaüzeneteket látunk (akármilyen típusú meghajtónk is legyen), az kétségtelenül arra utal, hogy ideje lecserélnünk a hardvert. A hibás szektorok használatát esetleg a gyártó saját diagnosztikai programjával le tudjuk tiltani, de hosszabb távon mindenképpen az lesz a legjobb, ha veszünk egy újat.</p></div></div><div class=sect2><h3 id=_a_freebsd_miért_nem_találja_meg_a_hp_netserver_scsi_vezérlõjét>5.3. A FreeBSD miért nem találja meg a HP Netserver SCSI-vezérlõjét?<a class=anchor href=#_a_freebsd_miért_nem_találja_meg_a_hp_netserver_scsi_vezérlõjét></a></h3><div class=paragraph><p>Ez tulajdonképpen egy ismert probléma. A HP Netserver gépekben egy integrált EISA buszos SCSI-vezérlõ található, amely a 11-es EISA bõvítõhelyen található, ezért az összes "valódi" EISA bõvítõhely ez elõtt helyezkedik el. Sajnos a 10 feletti EISA bõvítõhelyek címei ütköznek a PCI eszközök számára kiosztott címekkel, ezért a FreeBSD önmagától nem tudja valami jól kezelni az ilyen helyzeteket.</p></div><div class=paragraph><p>Ezért a legjobban akkor járunk, ha egyszerûen letagadjuk a címterek ütközését :) Ezt úgy tudjuk megtenni, ha a rendszermag <code>EISA_SLOTS</code> nevû beállítását a 12 értékre állítjuk. Ezután már csak be kell konfigurálunk és újra kell fordítanunk a rendszermagot, ahogy azt a <a href=https://docs.freebsd.org/hu/books/handbook/kernelconfig/#kernelconfig>kézikönyv megfelelõ része is tárgyalja</a>.</p></div><div class=paragraph><p>Természetesen, amikor egy ilyen gépre akarunk telepíteni, a helyzet tovább bonyolódik. A telepítést úgy tudjuk megoldani, ha a <em>UserConfig</em> programon belül alkalmazunk egy apró trükköt. Most ne a "vizuális" felületét használjuk, hanem a parancssoros részt. Gépeljük be, majd a megszokottak szerint telepítsük a rendszert:</p></div><div class="literalblock programlisting"><div class=content><pre>eisa 12
quit</pre></div></div><div class=paragraph><p>Ettõl függetlenül természetesen továbbra is javasolt egy, az elõbbiek szerint módosított rendszermagot fordítanunk és telepítenünk.</p></div><div class=paragraph><p>A következõ verziókban remélhetõleg már lesz valamilyen megoldás erre a problémára.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>A HP Netserver esetén nem tudunk a lemezeken <code>Veszélyesen dedikált</code> (<code>Dangerously Dedicated</code>) módot használni. Errõl <a href=#dedicate>itt</a> olvashatunk bõvebben.</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=_állandóan_ed1_timeout_és_ahhoz_hasonló_üzenetek_jelennek_meg_mi_lehet_velük_kezdeni>5.4. Állandóan ed1: timeout és ahhoz hasonló üzenetek jelennek meg. Mi lehet velük kezdeni?<a class=anchor href=#_állandóan_ed1_timeout_és_ahhoz_hasonló_üzenetek_jelennek_meg_mi_lehet_velük_kezdeni></a></h3><div class=paragraph><p>Ezt a hibát általában a megszakítások ütközése okozza (például két kártya ugyanazt a megszakítást akarja használni). Indítsuk a rendszerünket a <code>-c</code> beállítás használatával és az <span class=filename>ed0</span>/<span class=filename>de0</span>/…​ bejegyzéseket változtassuk meg a kártyáknak megfelelõen.</p></div><div class=paragraph><p>Ha a hálózati kártyánkon BNC típusú csatlakozó található, akkor még elõfordulhat, hogy azért látunk ilyen hibaüzeneteket, mert nem jól zártuk le a csatlakozást. Ezt úgy tudjuk könnyen ellenõrizni, ha a lezárót közvetlenül a kártyára dugjuk rá (kábel nélkül) és figyeljük, hogy továbbra is jönnek-e a hibaüzenetek.</p></div><div class=paragraph><p>Egyes NE2000-kompatibilis kártyák akkor adják ezt a hibát, ha az UTP portjukon nincs aktív összeköttetés vagy nem dugtuk be a kábelt.</p></div></div><div class=sect2><h3 id=_miért_állnak_le_a_3com_3c509_kártyák_minden_különösebb_ok_nélkül>5.5. Miért állnak le a 3Com® 3C509 kártyák minden különösebb ok nélkül?<a class=anchor href=#_miért_állnak_le_a_3com_3c509_kártyák_minden_különösebb_ok_nélkül></a></h3><div class=paragraph><p>Az ilyen típusú kártyák néha hajlamosak elfelejteni a beállításaikat. Frissítsük a kártya beállításait a <code>3c5x9.exe</code> program segítségével.</p></div></div><div class=sect2><h3 id=_a_párhuzamos_nyomtató_nevetségesen_lassú_mi_lehet_ezzel_kezdeni>5.6. A párhuzamos nyomtató nevetségesen lassú. Mi lehet ezzel kezdeni?<a class=anchor href=#_a_párhuzamos_nyomtató_nevetségesen_lassú_mi_lehet_ezzel_kezdeni></a></h3><div class=paragraph><p>Ha csupán annyi a problémánk, hogy a nyomtató irdatlanul lassan mûködik, akkor próbáljuk meg a kézikönyv <a href=https://docs.freebsd.org/hu/books/handbook/printing/#printing-intro-setup>nyomtatásról szóló részében</a> leírtakhoz hasonlóan átállítani a <a href=https://docs.freebsd.org/hu/books/handbook/printing#printing-parallel-port-mode>nyomtató portkezelését</a>.</p></div></div><div class=sect2><h3 id=_a_programok_miért_állnak_le_idõnként_signal_11_hibákkal>5.7. A programok miért állnak le idõnként Signal 11 hibákkal?<a class=anchor href=#_a_programok_miért_állnak_le_idõnként_signal_11_hibákkal></a></h3><div class=paragraph><p>Ezek a hibák akkor keletkeznek, amikor a futó programok olyan memóriaterülethez próbálnak meg hozzáférni, amihez eredetileg nem lenne szabad. Ha valami ehhez hasonló történik a rendszerünkben látszólag teljesen véletlenszerûen, akkor nagyon óvatosan kezdjünk el vizsgálódni.</p></div><div class=paragraph><p>A lehetséges okok az alábbiak lehetnek:</p></div><div class="olist arabic"><ol class=arabic><li><p>Ha csak olyan alkalmazások esetében jelentkezik ez a hiba, amelyeket mi magunk fejlesztünk, akkor az valószínûleg arra utal, hogy valamelyik része hibásan mûködik.</p></li><li><p>Ha a FreeBSD alaprendszerének valamelyik részében tapasztalunk ilyen hibákat, akkor azt szintén okozhatja hibás kód, de az ilyen hibákat általában hamarabb meg szokták találni és ki szokták javítani, mint ahogy a GYIK-ot olvasók többsége találkozna velük (a <code>-CURRENT</code> ág pontosan ezt a célt szolgálja).</p></li></ol></div><div class=paragraph><p>Elõfordulhat, hogy ez egy olyan furcsaság eredménye, amely <em>nem</em> a FreeBSD hibája: például ugyanazon program fordításakor mindig mást csinál a fordítóprogram.</p></div><div class=paragraph><p>Például tegyük fel, hogy a <code>make buildworld</code> parancsot futtatjuk, és a fordítás félbeszakad, amikor az <span class=filename>ls.c</span> állományból el akarja készíteni az <span class=filename>ls.o</span> állományt. Ha ezután megint megpróbáljuk kiadni a <code>make buildworld</code> parancsot, akkor a fordítás ugyanazon a helyen újból meghiúsul - valószínûleg hibás a forráskód, frissítsük a forrásainkat és próbáljuk meg ismét. Ha viszont a fordítás ilyenkor már egy másik helyen akad el, akkor szinte biztos, hogy hardverhibával akadtunk össze.</p></div><div class=paragraph><p>Amit ilyenkor tenni tudunk:</p></div><div class=paragraph><p>Az elsõ esetben egy nyomkövetõ, például a <a href="https://man.freebsd.org/cgi/man.cgi?query=gdb&amp;sektion=1&amp;format=html">gdb(1)</a> segítségével keressük meg a program azon pontját, ahol rossz memóriaterülethez próbál meg hozzáférni és javítsuk ki.</p></div><div class=paragraph><p>A második esetben ellenõrizzük, hogy nem a hardver a hibás.</p></div><div class=paragraph><p>Ennek okai többek közt a következõk lehetnek:</p></div><div class="olist arabic"><ol class=arabic><li><p>Túlmelegednek a merevlemezeink: ellenõrizzük, hogy a gépben található ventillátorok rendesen mûködnek-e (persze elõfordulhat, hogy más eszközök melegednek túl).</p></li><li><p>A processzor túlmelegedett: lehet, hogy mert túlságosan nagy órajelen járatjuk, vagy mert egyszerûen leállt a hûtése. Akármelyik eset is következett be, legalább a hiba felderítéséig állítsuk vissza a hivatalos sebességére.</p><div class=paragraph><p>Ha feltétlenül ragaszkodunk a rendszerünk tuningolásához, akkor érdemes elgondolkoznunk azon, hogy egy lassabb rendszerrel jobban járunk, mint egy állandóan cserélendõ, ropogósra sült rendszerrel. Az emberek általában nem is nagyon szeretik az ilyen rendszereket, független attól, hogy szerintünk érdemes-e ilyet csinálni vagy sem.</p></div></li><li><p>Hibás memóriamodulok: ha több SIMM és DIMM modul is található a gépünkben, akkor vegyük ki az összeset és próbáljuk ki mindegyiket egyesével, ezzel is leszûkíthetjük a probléma felderítését a hibás DIMM/SIMM modulokra vagy azok kombinációjára.</p></li><li><p>Az alaplap túlbecslõ értékei: a BIOS beállításai között vagy az alaplapon található jumperekkel szabályozni tudjuk a különbözõ idõzítéseket, ahol általában az alapértelmezett értékek megfelelnek, de néha elõfordulhat, hogy a memóriamodulok késleltetését lassúra, vagy éppen turbó sebességre állítják ("RAM Speed: Turbo" vagy ehhez hasonló néven keressük a BIOS-ban), ami szintén okozhat furcsa viselkedést. Próbáljuk meg visszaállítani az BIOS alapértelmezett értékeit, de elõtte érdemes lejegyezni az aktuális beállításainkat.</p></li><li><p>Az alaplap zajos vagy kevés áramot kap: ha vannak használaton kívüli I/O kártyáink, merevlemezeink, CD-meghajtóink a rendszerünkben, akkor próbáljuk meg ideiglenesen eltávolítani ezeket vagy egyszerûen csak lehúzni róluk a tápkábelt. Ezzel tudjuk vizsgálni, hogy a számítógépünk tápegysége képes-e megbirkózni a kisebb terheléssel. Esetleg kipróbálhatunk egy másik tápegységet is, lehetõleg egy kicsivel erõsebbet (például ha a jelenlegi tápegységünk teljesítménye 250 watt, akkor használjunk helyette egy 300 wattosat).</p></li></ol></div><div class=paragraph><p>Továbbá érdemes lehet még elolvasnunk a SIG11 GYIK-ot (lásd lentebb), ahol mindezeket a problémákat részletesen kifejtik, noha a Linux® nézõpontjából. Arról is olvashatunk benne, hogy egy hibás memóriát miért nem képesek észlelni a szoftveres vagy hardveres tesztelõeszközök.</p></div><div class=paragraph><p>Végezetül, ha az egyik javaslat sem segített a probléma megoldásában, akkor valószínûleg sikerült hibát találnunk a FreeBSD kódjában, amirõl nyugodtan írhatunk a fejlesztõknek egy hibajelentést.</p></div><div class=paragraph><p>A problémáról minden részletre kiterjedõ módon <a href=http://www.bitwizard.nl/sig11/>A SIG11-es probléma GYIK-ja</a> írásban olvashatunk (angolul).</p></div></div><div class=sect2><h3 id=_a_rendszer_összeomlik_vagy_egy_fatal_trap_12_page_fault_in_kernel_mode_vagy_pedig_valamilyen_panic_hibaüzenettel_és_egy_halom_számot_ír_ki_mit_tegyünk>5.8. A rendszer összeomlik vagy egy Fatal trap 12: page fault in kernel mode vagy pedig valamilyen panic: hibaüzenettel és egy halom számot ír ki. Mit tegyünk?<a class=anchor href=#_a_rendszer_összeomlik_vagy_egy_fatal_trap_12_page_fault_in_kernel_mode_vagy_pedig_valamilyen_panic_hibaüzenettel_és_egy_halom_számot_ír_ki_mit_tegyünk></a></h3><div class=paragraph><p>A FreeBSD fejlesztõi nagyon kíváncsiak az ilyen hibákra, de a felderítéséhez sajnos jóval több információra van szükségük, mint amennyit láthattunk. Másoljuk le az összeomláshoz tartozó teljes üzenetet. Ezután nézzük meg a GYIK-nak azt a részét, amely a <a href=#kernel-panic-troubleshooting>rendszermag összeomlásáról</a> szól, készítsünk egy nyomkövetési információkkal ellátott rendszermagot és kérjük le a hívási láncot. Ez elsõre talán bonyolultnak hangzik, de ehhez igazából nem igényel semmilyen programozási tudást, egyszerûen csak a megadott utasításokat kell követnünk.</p></div></div><div class=sect2><h3 id=_a_rendszer_indulása_közben_miért_sötétül_a_képernyõ_és_megy_el_rajta_a_kép>5.9. A rendszer indulása közben miért sötétül a képernyõ és megy el rajta a kép?<a class=anchor href=#_a_rendszer_indulása_közben_miért_sötétül_a_képernyõ_és_megy_el_rajta_a_kép></a></h3><div class=paragraph><p>Ez az ATI Mach 64 videokártyák esetében jelentkezõ probléma. Ilyenkor az a gond, hogy a kártya a <code>0x2e8</code> címet használja, akárcsak a negyedik soros port. A <a href="https://man.freebsd.org/cgi/man.cgi?query=sio&amp;sektion=4&amp;format=html">sio(4)</a> meghajtóban levõ hiba (vagy netalán beállítás?) miatt azonban a negyedik soros portot <em>még</em> akkor is használni fogja, ha kikapcsoljuk a <span class=filename>sio3</span> (a negyedik soros port) eszközt.</p></div><div class=paragraph><p>A hibát kijavításáig így kerülhetjük meg:</p></div><div class="olist arabic"><ol class=arabic><li><p>A betöltõ parancssorában adjuk meg a <code>-c</code> paramétert. (Így elõ tudjuk hozni a rendszermag konfigurációs módját.)</p></li><li><p>Kapcsoljuk ki a <span class=filename>sio0</span>, <span class=filename>sio1</span>, <span class=filename>sio2</span> és <span class=filename>sio3</span> eszközöket (tehát mindegyiket). Emiatt a <a href="https://man.freebsd.org/cgi/man.cgi?query=sio&amp;sektion=4&amp;format=html">sio(4)</a> meghajtó nem indul el, és így nem okoz problémát.</p></li><li><p>Lépjünk ki és folytassuk a rendszer indítását.</p></li></ol></div><div class=paragraph><p>Ha a soros portokat is használni akarjuk, akkor következõ módosításokkal készítsünk egy új rendszermagot: a <span class=filename>/usr/src/sys/dev/sio/sio.c</span> (vagy pc98 esetén a <span class=filename>/usr/src/sys/pc98/cbus/sio.c</span>) állományban keressük meg a <code>0x2e8</code> karakterláncot és az azt megelõzõ vesszõt távolítsuk el (de az utána következõt tartsuk meg). Miután végrehajtottuk ezt a módosítást, a megszokott módon fordítsuk újra a rendszermagot.</p></div></div><div class=sect2><h3 id=_a_freebsd_miért_csak_64_mb_memóriát_használ_amikor_128_mb_van_a_gépben>5.10. A FreeBSD miért csak 64 MB memóriát használ, amikor 128 MB van a gépben?<a class=anchor href=#_a_freebsd_miért_csak_64_mb_memóriát_használ_amikor_128_mb_van_a_gépben></a></h3><div class=paragraph><p>Mivel FreeBSD a BIOS-tól próbálja megtudni a rendelkezésre álló memória méretét, ezért csak 16 biten képes lekérdezni a KB-okban (vagyis 65 535 KByte = 64 MB, vagy még ennél is kevesebb, mivel egyes BIOS-ok legfeljebb 16 MB memóriát engednek látni). Tehát ha 64 MB-nál több memóriával rendelkezünk, akkor a FreeBSD ugyan megpróbálja azt felderíteni, de nem feltétlenül fog sikerülni.</p></div><div class=paragraph><p>Ezt úgy tudjuk megoldani, ha a rendszermag alábbi beállítását használjuk. Alapvetõen ugyanis létezik egy módszer, amivel le lehet kérdezni a memória teljes méretét a BIOS-tól, de a hozzá tartozó rutin nem fért el a rendszerindító blokkban. Ha egyszer majd sikerül neki helyet csinálni, akkor a rendszer képes lesz kizárólag ezzel a módszerrel dolgozni. Amíg viszont ez nem így van, addig kénytelenek leszünk a most következõ megoldást választani:</p></div><div class="literalblock programlisting"><div class=content><pre>options MAXMEM=N</pre></div></div><div class=paragraph><p>ahol <em>N</em> a memória Kilobyte-okban megadott mérete. Tehát egy 128 MB memóriával rendelkezõ számítógép esetén ez <code>131072</code>.</p></div></div><div class=sect2><h3 id=_a_számítógépben_több_mint_1_gb_memória_van_de_mégis_kmem_map_too_small_üzenetek_jelennek_meg_mi_a_gond>5.11. A számítógépben több mint 1 GB memória van, de mégis kmem_map too small üzenetek jelennek meg. Mi a gond?<a class=anchor href=#_a_számítógépben_több_mint_1_gb_memória_van_de_mégis_kmem_map_too_small_üzenetek_jelennek_meg_mi_a_gond></a></h3><div class=paragraph><p>A FreeBSD általában a rendszermag néhány fontos paraméterét, mint például az egyszerre megnyitható állományok maximális számát a számítógépben található memória méretébõl származtatja. Az 1 GB memóriánál több esetén azonban elképzelhetõ, hogy ez az "automatikus méretezés" túlságosan is nagy értékeket választ. Így a rendszer indításakor a rendszermag olyan nagy méretû táblázatokat és egyéb struktúrákat foglal le, amelyek betöltik a rendelkezésére bocsátott terület nagy részét. Késõbb, a rendszer futása közben pedig a rendszermag szépen lassan kifogy a dinamikus memóriaterületekbõl és összeomlik.</p></div><div class=paragraph><p>Készítsünk egy olyan saját rendszermagot, ahol a <code>VM_KMEM_SIZE_MAX</code> beállítást megnöveljük egészen a maximális 400 MB-os értékig (<code>options VM_KMEM_SIZE_MAX=419430400</code>). 400 MB használata valószínûleg elég lesz egészen 6 GB memóriáig.</p></div></div><div class=sect2><h3 id=_a_számítógépben_nincs_1_gb_memória_a_freebsd_mégis_kmem_map_too_small_hibával_leáll>5.12. A számítógépben nincs 1 GB memória, a FreeBSD mégis kmem_map too small hibával leáll!<a class=anchor href=#_a_számítógépben_nincs_1_gb_memória_a_freebsd_mégis_kmem_map_too_small_hibával_leáll></a></h3><div class=paragraph><p>Ez a hibaüzenet arra utal, hogy a rendszer kifogyott a hálózati pufferek (különösen az mbuf klaszterek) számára kiosztott virtuális memóriából. Az mbuf klaszterek részére fenntartott virtuális memória méretének beállításáról a kézikönyv <a href=https://docs.freebsd.org/hu/books/handbook/config-tuning#nmbclusters>Hálózati korlátozások</a> címû szakaszában olvashatunk.</p></div></div><div class=sect2><h3 id=_miért_jelenik_meg_a_kernel_proc_table_is_full_hibaüzenet>5.13. Miért jelenik meg a kernel: proc: table is full hibaüzenet?<a class=anchor href=#_miért_jelenik_meg_a_kernel_proc_table_is_full_hibaüzenet></a></h3><div class=paragraph><p>A FreeBSD rendszermagja egyszerre csak bizonyos számú programot enged futni. Ezek konkrét száma a <code>kern.maxusers</code> <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a>-változótól függ. A <code>kern.maxusers</code> ezenkívül még hatással van más belsõ korlátokra is, például a hálózati pufferekre (lásd <a href=#panic-kmemmap-too-small>ezt</a> a korábbi kérdést). Ha a számítógépünk túlságosan leterhelt, akkor érdemes megpróbálkoznunk a <code>kern.maxusers</code> értékének növelésével. Ennek átállítása a rendszerben egyszerre futtatható maximális programok számával együtt sok más rendszerszintû korlátozást is finomít.</p></div><div class=paragraph><p>A <code>kern.maxusers</code> értékének beállításához nézzük meg a kézikönyv <a href=https://docs.freebsd.org/hu/books/handbook/config-tuning#kern-maxfiles>Az állományok és futó programok korlátozásairól</a> szóló szakaszát. (Miközben ez a rész a megnyitható állományok maximális számáról szól, addig ugyanez érvényes a futó programokra is.)</p></div><div class=paragraph><p>Ha viszont a számítógépünk nem éri akkora terhelés, de mégis szeretnénk egyszerre nagyobb számú programot is futtatni rajta, akkor ehhez elegendõ csak <code>kern.maxproc</code> változót átállítanunk. Ezt úgy tudjuk megtenni, ha felvesszük a <span class=filename>/boot/loader.conf</span> állományba. Ez az érték természetesen addig nem beállítódni, amíg a rendszerünket újra nem indítjuk. Ezekrõl a változókról a <a href="https://man.freebsd.org/cgi/man.cgi?query=loader.conf&amp;sektion=5&amp;format=html">loader.conf(5)</a> és <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl.conf&amp;sektion=5&amp;format=html">sysctl.conf(5)</a> man oldalakon tájékozódhatunk részletesebben. Ha az összes programot egyetlen felhasználóval akarjuk futtatni, akkor a <code>kern.maxprocperuid</code> változót értékét is át kell állítanunk, méghozzá a <code>kern.maxproc</code> új értékénél eggyel kisebbre. (Ezért kell így csinálni, mert egy rendszerprogram, az <a href="https://man.freebsd.org/cgi/man.cgi?query=init&amp;sektion=8&amp;format=html">init(8)</a> mindig fut.)</p></div><div class=paragraph><p>A sysctl változók beállításait úgy is tudjuk véglegesíteni, ha felvesszük ezeket az <span class=filename>/etc/sysctl.conf</span> állományba. A kézikönyv <a href=https://docs.freebsd.org/hu/books/handbook/config-tuning#configtuning-sysctl>A rendszermag korlátainak finomhangolása</a> címû szakaszában részletesebb is olvashatunk róla, hogy miként állítsuk be a rendszerünket.</p></div></div><div class=sect2><h3 id=_az_új_rendszermag_indításakor_miért_keletkezik_cmap_busy_hibaüzenet>5.14. Az új rendszermag indításakor miért keletkezik CMAP busy hibaüzenet?<a class=anchor href=#_az_új_rendszermag_indításakor_miért_keletkezik_cmap_busy_hibaüzenet></a></h3><div class=paragraph><p>Az elavult <span class=filename>/var/db/kvm_*.db</span> állományokat összegyûjtõ rutin idõnként nem mûködik megfelelõen, és a nem egyezõ állományok esetén össze is omolhat.</p></div><div class=paragraph><p>Amikor ilyen történik, indítsuk újra a rendszert egyfelhasználós módban és gépeljük be:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># rm /var/db/kvm_*.db</span></code></pre></div></div></div><div class=sect2><h3 id=_mit_jelent_az_ahc0_brkadrint_illegal_host_access_at_seqaddr_0x0_üzenet>5.15. Mit jelent az ahc0: brkadrint, Illegal Host Access at seqaddr 0x0 üzenet?<a class=anchor href=#_mit_jelent_az_ahc0_brkadrint_illegal_host_access_at_seqaddr_0x0_üzenet></a></h3><div class=paragraph><p>Ez az Ultrastor SCSI vezérlõkártya ütközésére utal.</p></div><div class=paragraph><p>A rendszerindítás közben lépjünk be a rendszermag konfigurációs menüjébe és tiltsuk le a gondot okozó <span class=filename>uha0</span> eszközt.</p></div></div><div class=sect2><h3 id=_amikor_elindul_a_rendszer_egy_ahc0_illegal_cable_configuration_hibaüzenet_jelenik_meg_a_kábelek_bekötésével_semmilyen_gond_nincs_mégis_akkor_mi_a_baj>5.16. Amikor elindul a rendszer, egy ahc0: illegal cable configuration hibaüzenet jelenik meg. A kábelek bekötésével semmilyen gond nincs. Mégis akkor mi a baj?<a class=anchor href=#_amikor_elindul_a_rendszer_egy_ahc0_illegal_cable_configuration_hibaüzenet_jelenik_meg_a_kábelek_bekötésével_semmilyen_gond_nincs_mégis_akkor_mi_a_baj></a></h3><div class=paragraph><p>Az alaplapon nem található olyan áramkör, amely támogatja az automatikus lezárást ("automatic termination"). A SCSI BIOS-ban az automatikus lezárás helyett adjuk meg a megfelelõ lezárást. Az <a href="https://man.freebsd.org/cgi/man.cgi?query=ahc&amp;sektion=4&amp;format=html">ahc(4)</a> meghajtója nem képes rendesen érzékelni a kábeleket, ha az alaplapon van ilyen érzékelés (és így automatikus lezárás). A meghajtó egyszerûen annyit feltételez, hogy ennek támogatása csak akkor érhetõ el, ha az EEPROM-ban megadtuk az "automatic termination" beállítást. A megfelelõ kábeldetektáló eszköz nélkül a meghajtó gyakran rosszul állapítja meg a lezárást, ami pedig így veszélyezteti a SCSI busz megbízhatóságát.</p></div></div><div class=sect2><h3 id=_miért_küld_a_sendmail_mail_loops_back_to_myself_hibaüzenetet>5.17. Miért küld a sendmail mail loops back to myself hibaüzenetet?<a class=anchor href=#_miért_küld_a_sendmail_mail_loops_back_to_myself_hibaüzenetet></a></h3><div class=paragraph><p>Errõl részletesebben a <a href=https://docs.freebsd.org/hu/books/handbook/>kézikönyvben</a> olvashatunk.</p></div></div><div class=sect2><h3 id=_a_távoli_gépeken_miért_viselkednek_olyan_furcsán_a_teljes_képernyõs_alkalmazások>5.18. A távoli gépeken miért viselkednek olyan furcsán a teljes képernyõs alkalmazások?<a class=anchor href=#_a_távoli_gépeken_miért_viselkednek_olyan_furcsán_a_teljes_képernyõs_alkalmazások></a></h3><div class=paragraph><p>Elõfordulhat, hogy az adott távoli gépen a terminál típusa nem <code>cons25</code>, amire viszont a FreeBSD konzolnak a megfelelõ mûködéshez szüksége lenne.</p></div><div class=paragraph><p>Ezt a problémát többféle módon is meg tudjuk kerülni:</p></div><div class=ulist><ul><li><p>Mikor bejelentkezünk a távoli gépre, állítsuk a <code>TERM</code> környezeti változót az <code>ansi</code> vagy <code>sco</code> értékre, amibõl kiderül, hogy egyáltalán ismeri ezeket a termináltípusokat.</p></li><li><p>A FreeBSD konzolban használjunk VT100 emulátort, például a screen alkalmazást. A screen segítségével egyetlen terminálról egyszerre több munkamenetet is tudunk indítani, de egyébként is egy nagyon jó program. Minden screen által létrehozott ablak VT100-as terminálként mûködik, ezért a távoli gépen a <code>TERM</code> környezeti változó nyugodtan beállítható a <code>vt100</code> értékre.</p></li><li><p>Tegyük hozzá a <code>cons25</code> bejegyzést a távoli gép terminálokat tároló adatbázisához. Ez pontos módszere jelentõs mértékben függ az adott gépen található operációs rendszertõl. Ebben leginkább az adott gépen található man oldalak tudnak segíteni.</p></li><li><p>Indítsunk el a FreeBSD rendszert futtató gépen egy X szervert és a távoli géprõl egy X rendszerre íródott terminálemulátorral, például az <code>xterm</code> vagy az <code>rxvt</code> programmal jelentkezzük be. A távoli gépen ekkor a <code>TERM</code> változó értéke vagy <code>xterm</code>, vagy pedig <code>vt100</code> lesz.</p></li></ul></div></div><div class=sect2><h3 id=_a_plug_and_play_kártyákat_miért_nem_találja_meg_vagy_unknown_típusúként_látja_a_freebsd>5.19. A Plug and Play kártyákat miért nem találja meg (vagy unknown típusúként látja) a FreeBSD?<a class=anchor href=#_a_plug_and_play_kártyákat_miért_nem_találja_meg_vagy_unknown_típusúként_látja_a_freebsd></a></h3><div class=paragraph><p>Ennek az okait a következõ levélben fejtette ki Peter Wemm &lt;<a href=mailto:peter@FreeBSD.org>peter@FreeBSD.org</a>> a <a href=https://lists.FreeBSD.org/subscription/freebsd-questions>FreeBSD general questions levelezési lista</a> tagjainak, amelyben arra válaszolt, hogy egy belsõ modemet miért nem észlel a rendszer miután frissítették FreeBSD 4.<em>X</em>-re (az érthetõség kedvéért szögletes zárójelek között hozzáadtunk néhány kiegészítést is).</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Az eredeti szövegbõl készült idézetet frissítettük.</p></div></td></tr></tbody></table></div><div class=paragraph><p>A PNP BIOS beállította [a modemet] és magára hagyta valahol a portok számára fenntartott címtérben, így az ISA eszközök régi típusú [3.<em>X</em>-ben levõ] eszközpróbálgatásai ott "találták" meg.</p></div><div class=paragraph><p>A 4.0 esetében azonban az ISA eszközöket kezelõ kód már sokkal inkább a PnP támogatására koncentrál. Korábban [a 3.X verziókban] elõfordulhatott az is, hogy az ISA eszközök keresése során a rendszer egy "kóbor" eszközt talált, majd ugyanazt megtalálta PnP eszközként és ütköztek az így duplán lefoglalni kívánt erõforrások. Ennek kivédésére elõször tehát letiltjuk a programozható kártyák felderítését, így ez a típusú kettõs detektálás nem történhet meg. Ez továbbá azt is jelenti, hogy a támogatott PnP hardverek azonosítóit elõre ismerni kell. Ennek hangolhatóságát már tervbevettük.</p></div><div class=paragraph><p>Tehát egy ilyen eszköz mûködtetéséhez szükségünk lesz a PnP azonosítójára, valamint arra, hogy felvegyük a felderítendõ PnP eszközök ISA eszközök közé. Ezt a <a href="https://man.freebsd.org/cgi/man.cgi?query=pnpinfo&amp;sektion=8&amp;format=html">pnpinfo(8)</a> segítségével kérhetjük le, amely például egy belsõ modem esetén a következõ kimenetet fogja adni:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pnpinfo</span>
Checking <span class=k>for </span>Plug-n-Play devices...

Card assigned CSN <span class=c>#1</span>
Vendor ID PMC2430 <span class=o>(</span>0x3024a341<span class=o>)</span>, Serial Number 0xffffffff
PnP Version 1.0, Vendor Version 0
Device Description: Pace 56 Voice Internal Plug &amp; Play Modem

Logical Device ID: PMC2430 0x3024a341 <span class=c>#0</span>
        Device supports I/O Range Check
TAG Start DF
    I/O Range 0x3f8 .. 0x3f8, alignment 0x8, len 0x8
        <span class=o>[</span>16-bit addr]
    IRQ: 4  - only one <span class=nb>type</span> <span class=o>(</span><span class=nb>true</span>/edge<span class=o>)</span></code></pre></div></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>TAG End DF
End Tag

Successfully got 31 resources, 1 logical fdevs
<span class=nt>--</span> card <span class=k>select</span> <span class=c># 0x0001</span>

CSN PMC2430 <span class=o>(</span>0x3024a341<span class=o>)</span>, Serial Number 0xffffffff

Logical device <span class=c>#0</span>
IO:  0x03e8 0x03e8 0x03e8 0x03e8 0x03e8 0x03e8 0x03e8 0x03e8
IRQ 5 0
DMA 4 0
IO range check 0x00 activate 0x01</code></pre></div></div><div class=paragraph><p>Innen a <code>Vendor ID</code> kezdetû sorra lesz szükségünk. A zárójelek között szereplõ hexadecimális szám (ami a példában a <code>0x3024a341</code>) lesz az eszköz PnP azonosítója, valamint a közvetlenül ez elõtt szereplõ karakterlánc az egyedi ASCII azonosítója (<code>PMC2430</code>).</p></div><div class=paragraph><p>Ha a <a href="https://man.freebsd.org/cgi/man.cgi?query=pnpinfo&amp;sektion=8&amp;format=html">pnpinfo(8)</a> lefuttatásának eredményeképpen megjelenõ lista nem tartalmazza a kérdéses eszközt, akkor helyette a <a href="https://man.freebsd.org/cgi/man.cgi?query=pciconf&amp;sektion=8&amp;format=html">pciconf(8)</a> használatával is próbálkozhatunk. Íme a <code>pciconf -vl</code> parancs kimenete egy integrált hangkártya esetében:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pciconf -vl</span>
chip1@pci0:31:5:        <span class=nv>class</span><span class=o>=</span>0x040100 <span class=nv>card</span><span class=o>=</span>0x00931028 <span class=nv>chip</span><span class=o>=</span>0x24158086 <span class=nv>rev</span><span class=o>=</span>0x02 <span class=nv>hdr</span><span class=o>=</span>0x00
    vendor   <span class=o>=</span> <span class=s1>&#39;Intel Corporation&#39;</span>
    device   <span class=o>=</span> <span class=s1>&#39;82801AA 8xx Chipset AC&#39;</span>97 Audio Controller<span class=s1>&#39;
    class    = multimedia
    subclass = audio</span></code></pre></div></div><div class=paragraph><p>Ebbõl a <code>chip</code> változót, vagyis a <code>0x24158086</code> értéket kell felhasználnunk.</p></div><div class=paragraph><p>Ezt az információt (a <code>Vendor ID</code> vagy a <code>chip</code> értékét) ezután a <span class=filename>/usr/src/sys/dev/sio/sio_isa.c</span> állományba kell felvennünk.</p></div><div class=paragraph><p>Ehhez elõször is készítsünk egy biztonsági másolatát a <span class=filename>sio_isa.c</span> állományról arra az esetre, ha véletlenül valami rossz történne. Ez azért is hasznunkra fog válni, mert így tudunk egy javítást mellékelni a hibajelentésünk mellé (mert ugye írni fogunk róla hibajelentést, ugye?). Szóval, keressük meg a <span class=filename>sio_isa.c</span> állományban a következõ sort:</p></div><div class="literalblock programlisting"><div class=content><pre>static struct isa_pnp_id sio_ids[] = {</pre></div></div><div class=paragraph><p>Menjük lentebb egészen addig, amíg nem találunk egy helyet, ahova be tudunk szúrni egy bejegyzést az eszközünkhöz. A bejegyzések megadásának módja lentebb látható, és a jobb oldalt megjegyzésbe tett ASCII Vendor ID szerint rendezettek, amelyek mellett még megtalálható (amennyiben kifér) a <a href="https://man.freebsd.org/cgi/man.cgi?query=pnpinfo&amp;sektion=8&amp;format=html">pnpinfo(8)</a> <em>Device Description</em> kimenetében kapott érték is:</p></div><div class="literalblock programlisting"><div class=content><pre>{0x0f804f3f, NULL},     /* OZO800f - Zoom 2812 (56k Modem) */
{0x39804f3f, NULL},     /* OZO8039 - Zoom 56k flex */
{0x3024a341, NULL},     /* PMC2430 - Pace 56 Voice Internal Modem */
{0x1000eb49, NULL},     /* ROK0010 - Rockwell ? */
{0x5002734a, NULL},     /* RSS0250 - 5614Jx3(G) Internal Modem */</pre></div></div><div class=paragraph><p>A megfelelõ helyre ezután vegyük fel az eszközünkhöz tartozó hexadecimális Vendor ID értéket, mentsük el az állományt, fordítsuk újra a rendszermagot és indítsuk újra vele a rendszerünket. Ha mindent jól csináltunk, akkor az eszköz <span class=filename>sio</span> eszközként fog megjelenni.</p></div></div><div class=sect2><h3 id=_miért_keletkezik_nlist_failed_hiba_például_a_top_vagy_systat_parancsok_futtatásakor>5.20. Miért keletkezik nlist failed hiba például a top vagy systat parancsok futtatásakor?<a class=anchor href=#_miért_keletkezik_nlist_failed_hiba_például_a_top_vagy_systat_parancsok_futtatásakor></a></h3><div class=paragraph><p>A gondot alapvetõen az okozza, hogy a kérdéses alkalmazás valamiért egy olyan rendszermagbeli szimbólumot keres, amit nem talál. Ez a típusú hiba a következõkbõl eredhet:</p></div><div class=ulist><ul><li><p>A rendszermag és a hozzá tartozó programok nincsenek szinkronban (vagyis fordítottunk egy új rendszermagot, de nem volt <code>installworld</code> vagy fordítva) és emiatt a szimbólumokat tároló táblázat nem teljesen úgy épül fel, ahogy azt az alkalmazás gondolja. Ha errõl lenne szó, akkor egyszerûen nincs más teendõnk, mint befejezni a frissítést (ennek pontos részleteit lásd a <span class=filename>/usr/src/UPDATING</span> állományban).</p></li><li><p>Nem a <code>/boot/loader</code>, hanem közvetlenül a <span class=filename>boot2</span> (lásd <a href="https://man.freebsd.org/cgi/man.cgi?query=boot&amp;sektion=8&amp;format=html">boot(8)</a>) segítségével töltjük be a rendszermagot. Noha alapvetõen semmilyen problémát nem nem okoz a <code>/boot/loader</code> kihagyása, általánosságban véve azért mégis jobban elérhetõvé tudja tenni a rendszermagban található szimbólumokat a felhasználói programok felé.</p></li></ul></div></div><div class=sect2><h3 id=_miért_tart_olyan_sokáig_ssh_vagy_telnet_használatával_csatlakozni_a_számítógéphez>5.21. Miért tart olyan sokáig ssh vagy telnet használatával csatlakozni a számítógéphez?<a class=anchor href=#_miért_tart_olyan_sokáig_ssh_vagy_telnet_használatával_csatlakozni_a_számítógéphez></a></h3><div class=paragraph><p>A tünet: nagyon sok idõ telik aközött, amíg a TCP kapcsolat felépül és a kliens bekéri a jelszót (vagy a <a href="https://man.freebsd.org/cgi/man.cgi?query=telnet&amp;sektion=1&amp;format=html">telnet(1)</a> esetében amíg a bejelentkezõ képernyõ megjelenik).</p></div><div class=paragraph><p>A betegség: nagyon valószínû, hogy a késlekedést az okozza, amikor a szerver megpróbálja a kliens IP-címét feloldani hálózati névvé. Sok szerver, köztük a FreeBSD-ben is megtalálható Telnet és SSH szerver is ezt csinálja, többek közt azért, hogy a rendszergazda számára el tudja tárolni egy naplóban ezt a hálózati nevet.</p></div><div class=paragraph><p>Az orvosság: ha az említett jelenség minden olyan esetben jelentkezik, amikor a számítógéprõl (mint kliensrõl) valamilyen szerverhez csatlakozni akarunk, akkor a kliens oldalán lesz a gond. Ehhez hasonlóan, ha csak egy adott szervernél tapasztaljuk, akkor azzal a számítógéppel történhetett valami.</p></div><div class=paragraph><p>Amennyiben a problémákat a kliens okozza, nem tehetünk mást, a névoldáson kell úgy javítanunk, hogy a szerver normálisan fel tudja oldani. Ha helyi hálózaton tapasztaljuk mindezt, akkor ez már a szerver problémája és olvassunk tovább. Ellenkezõ esetben az internet a felelõs, ezért nagyon valószínû, hogy fel kell vennünk a kapcsolatot az internet-szolgáltatónkkal és segítséget kérni tõlük a hiba elhárításában.</p></div><div class=paragraph><p>Ha a problémát viszont a helyi hálózaton található szerver okozza, akkor úgy kell azt beállítanunk, hogy a helyi neveket képes legyen rendesen feloldani. Ezzel kapcsolatban a <a href="https://man.freebsd.org/cgi/man.cgi?query=hosts&amp;sektion=5&amp;format=html">hosts(5)</a> és <a href="https://man.freebsd.org/cgi/man.cgi?query=named&amp;sektion=8&amp;format=html">named(8)</a> man oldalakat érdemes elolvasnunk. Ha a probléma viszont az interneten jelenik meg, akkor valószínû, hogy a szerver névfeloldása nem üzemel rendesen. Nézzünk meg egy másik gépet - például a <code>www.yahoo.com</code> címet. Ha ez sem mûködik, akkor nálunk van a gond.</p></div><div class=paragraph><p>A FreeBSD friss telepítését követõen az is elképzelhetõ, hogy egyszerûen csak hiányoznak a tartományokkal és névszerverekkel kapcsolatos megfelelõ adatok az <span class=filename>/etc/resolv.conf</span> állományból. Ez gyakran okoz késlekedést az SSH mûködésében, mivel az <span class=filename>/etc/ssh</span> könyvtárban található <span class=filename>sshd_config</span> állományban alapértelmezés szerint a <code>UseDNS</code> beállítás értéke <code>yes</code> (tehát a névfeloldás használata engedélyezett). Ha valóban ez okozza a problémát, akkor a pótoljuk az <span class=filename>/etc/resolv.conf</span> állományból hiányzó adatokat vagy az <span class=filename>sshd_config</span> állományban a <code>UseDNS</code> értéke ideiglenesen legyen <code>no</code>.</p></div></div><div class=sect2><h3 id=_mire_utal_a_stray_irq_kóbor_megszakítási_kérés_üzenet>5.22. Mire utal a stray IRQ (kóbor megszakítási kérés) üzenet?<a class=anchor href=#_mire_utal_a_stray_irq_kóbor_megszakítási_kérés_üzenet></a></h3><div class=paragraph><p>A kóbor megszakítási kéréseket jelzõ üzenetek általában a hardveres megszakítási kérések egyenletlenségeire utalnak, ezen belül is leginkább olyan esetekre, amikor az eszköz egy megszakítási kérés nyugtázása közepén eltávolítja az adott kérést.</p></div><div class=paragraph><p>Három dolgot tehetünk ezzel kapcsolatban:</p></div><div class=ulist><ul><li><p>Elviseljük ezeket a figyelmeztetéseket. Megszakítási kérésenként az elsõ öt üzenet után amúgy sem jelez többet a rendszer.</p></li><li><p>Ha platformunkhoz (mint például i386™) tartozó <span class=filename>intr_machdep.c</span> állományban található <code>MAX_STRAY_LOG</code> értékét átírjuk <code>5</code>-rõl <code>0</code>-ra és így újrafordítjuk a rendszermagot, akkor ezzel teljesen letilthatjuk a figyelmeztetéseket.</p></li><li><p>Megszüntetjük az üzeneteket úgy, hogy csatlakoztatunk a rendszerhez egy olyan párhuzamos vonali eszközt, amely a 7-es IRQ-t használja, és rakunk fel hozzá egy PPP meghajtót (a legtöbb helyen egyébként ezzel lesz a gond), valamint a 15-ös IRQ-ra pedig rakunk egy IDE-meghajtót vagy más hasonló eszközt és telepítjük hozzá a megfelelõ meghajtót.</p></li></ul></div></div><div class=sect2><h3 id=_miért_jelenik_meg_folyamatosan_a_file_table_is_full_üzenet_a_rendszernaplóban>5.23. Miért jelenik meg folyamatosan a file: table is full üzenet a rendszernaplóban?<a class=anchor href=#_miért_jelenik_meg_folyamatosan_a_file_table_is_full_üzenet_a_rendszernaplóban></a></h3><div class=paragraph><p>Ha ilyen hibaüzenetet látunk, akkor az arra utal, hogy kifogytunk a rendszerünkben egyszerre használható állományleírókból. A probléma leírásával és megoldásával kapcsolatban olvassuk el a kézikönyvben a <a href=https://docs.freebsd.org/hu/books/handbook/config-tuning#kern-maxfiles>kern.maxfiles</a> változóról szóló részt <a href=https://docs.freebsd.org/hu/books/handbook/config-tuning/#configtuning-kernel-limits>A rendszermag korlátainak finomhangolása</a> címû szakaszban.</p></div></div><div class=sect2><h3 id=_miért_árasztják_el_calcru_negative_runtime_vagy_calcru_runtime_went_backwards_üzenetek_a_konzolt>5.24. Miért árasztják el calcru: negative runtime vagy calcru: runtime went backwards üzenetek a konzolt?<a class=anchor href=#_miért_árasztják_el_calcru_negative_runtime_vagy_calcru_runtime_went_backwards_üzenetek_a_konzolt></a></h3><div class=paragraph><p>Ismert egy olyan probléma, hogy a BIOS-ban engedélyezzük az Intel® Enhanced SpeedStep technológiáját, akkor a rendszermag ehhez hasonló <code>calcru</code> üzeneteket kezd el küldözgetni:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>calcru: runtime went backwards from 6 usec to 3 usec <span class=k>for </span>pid 37 <span class=o>(</span>pagezero<span class=o>)</span>
calcru: runtime went backwards from 6 usec to 3 usec <span class=k>for </span>pid 36 <span class=o>(</span>vmdaemon<span class=o>)</span>
calcru: runtime went backwards from 170 usec to 138 usec <span class=k>for </span>pid 35 <span class=o>(</span>pagedaemon<span class=o>)</span>
calcru: runtime went backwards from 553 usec to 291 usec <span class=k>for </span>pid 15 <span class=o>(</span>swi6: task queue<span class=o>)</span>
calcru: runtime went backwards from 15521 usec to 10366 usec <span class=k>for </span>pid 2 <span class=o>(</span>g_event<span class=o>)</span>
calcru: runtime went backwards from 25 usec to 12 usec <span class=k>for </span>pid 11 <span class=o>(</span>swi1: net<span class=o>)</span>
calcru: runtime went backwards from 4417 usec to 3960 usec <span class=k>for </span>pid 1 <span class=o>(</span>init<span class=o>)</span>
calcru: runtime went backwards from 2084385 usec to 1793542 usec <span class=k>for </span>pid 1 <span class=o>(</span>init<span class=o>)</span>
calcru: runtime went backwards from 408 usec to 204 usec <span class=k>for </span>pid 0 <span class=o>(</span>swapper<span class=o>)</span></code></pre></div></div><div class=paragraph><p>Ennek oka, hogy az Intel® SpeedStep (EIST) egyes alaplapokkal nem kompatibilis.</p></div><div class=paragraph><p>Megoldás: Tiltsuk le a BIOS-ban az EIST használatát. Ekkor még az ACPI-alapú processzorfrekvencia-szabályozás továbbra is elérhetõ a <a href="https://man.freebsd.org/cgi/man.cgi?query=powerd&amp;sektion=8&amp;format=html">powerd(8)</a> használatán keresztül.</p></div></div><div class=sect2><h3 id=_miért_jár_rosszul_az_óra_a_számítógépen>5.25. Miért jár rosszul az óra a számítógépen?<a class=anchor href=#_miért_jár_rosszul_az_óra_a_számítógépen></a></h3><div class=paragraph><p>A számítógépnek kettõ vagy több idõmérõ eszköze van, és a FreeBSD pont a rosszabbikat választotta.</p></div><div class=paragraph><p>Adjuk ki a <a href="https://man.freebsd.org/cgi/man.cgi?query=dmesg&amp;sektion=8&amp;format=html">dmesg(8)</a> parancsot és vizsgáljuk meg a <code>Timecounter</code> kezdetû sorokat. Ezek közül a FreeBSD a legnagyobb "quality" értékkel rendelkezõt választotta.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dmesg | grep Timecounter</span>
Timecounter <span class=s2>&#34;i8254&#34;</span> frequency 1193182 Hz quality 0
Timecounter <span class=s2>&#34;ACPI-fast&#34;</span> frequency 3579545 Hz quality 1000
Timecounter <span class=s2>&#34;TSC&#34;</span> frequency 2998570050 Hz quality 800
Timecounters tick every 1.000 msec</code></pre></div></div><div class=paragraph><p>Errõl a <code>kern.timecounter.hardware</code> <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=3&amp;format=html">sysctl(3)</a> változó lekérdezésével tudunk ténylegesen megbizonyosodni:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl kern.timecounter.hardware</span>
kern.timecounter.hardware: ACPI-fast</code></pre></div></div><div class=paragraph><p>Elõfordulhat, hogy az ACPI-idõzítõ hibás. Ilyenkor az a legegyszerûbb, ha az <span class=filename>/etc/loader.conf</span> állományban letiltjuk az ACPI-idõzítõ használatát:</p></div><div class="literalblock programlisting"><div class=content><pre>debug.acpi.disabled=&#34;timer&#34;</pre></div></div><div class=paragraph><p>Vagy a BIOS is tudja módosítani a TSC idõzítõt - például azért, hogy csökkentse a processzor sebességét, amikor merül az akkumulátor vagy energiatakarékos módra vált. A FreeBSD sajnos nem figyel ezekre a változtatásokra és elcsúszik az idõméréssel.</p></div><div class=paragraph><p>Ahogy viszont az iménti példában is látható, itt még az <code>i8254</code> idõzítõ is használható, méghozzá úgy, hogy a <code>kern.timecounter.hardware</code> <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> változó értékét átállítjuk erre az értékre:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl -w kern.timecounter.hardware=i8254</span>
kern.timecounter.hardware: TSC -&gt; i8254</code></pre></div></div><div class=paragraph><p>Innentõl kezdve a számítógépünk már sokkal pontosabban mutatja az idõt.</p></div><div class=paragraph><p>Ezt a változtatást úgy tudjuk minden rendszerindítás során automatikusan megtenni, ha felvesszük a következõ sort az <span class=filename>/etc/sysctl.conf</span> állományba:</p></div><div class="literalblock programlisting"><div class=content><pre>kern.timecounter.hardware=i8254</pre></div></div></div><div class=sect2><h3 id=_a_rendszer_laptopon_miért_nem_tudja_rendesen_megtalálni_a_pc_kártyákat>5.26. A rendszer laptopon miért nem tudja rendesen megtalálni a PC-kártyákat?<a class=anchor href=#_a_rendszer_laptopon_miért_nem_tudja_rendesen_megtalálni_a_pc_kártyákat></a></h3><div class=paragraph><p>Ez a probléma gyakran megjelenik olyan laptopokon, amelyek egynél több operációs rendszert is futtatnak, egyes nem-BSD típusú rendszerek ugyanis hajlamosak a hardvert inkonzisztens állapotban hagyni. Emiatt a <a href="https://man.freebsd.org/cgi/man.cgi?query=pccardd&amp;sektion=8&amp;format=html">pccardd(8)</a> parancs az adott kártyát <code>"(null)""(null)"</code> néven észleli a valós típusa helyett.</p></div><div class=paragraph><p>A hardvert innen teljesen csak úgy tudjuk alapállapotába hozni, ha a PC-kártya foglalatát áramtalanítjuk. Ehhez ki kell kapcsolnunk a laptopot. (Tehát ne tegyük se készenléti, se pedig hibernált állapotba - teljesen ki kell kapcsolni.) A PC-kártya ezután várhatóan már mûködni fog.</p></div><div class=paragraph><p>Némely laptopok hazudnak arról, hogy rendesen ki vannak-e kapcsolva. Amennyiben az elõbbi módszer nem válna be, próbáljuk meg úgy, hogy kikapcsoljuk a gépet, kivesszük az akkumulátort, várunk egy keveset, visszarakjuk és újra bekapcsoljuk.</p></div></div><div class=sect2><h3 id=_miért_ad_a_freebsd_rendszertöltõje_read_error_hibát_és_áll_meg_a_bios_képernyõn>5.27. Miért ad a FreeBSD rendszertöltõje Read error hibát és áll meg a BIOS képernyõn?<a class=anchor href=#_miért_ad_a_freebsd_rendszertöltõje_read_error_hibát_és_áll_meg_a_bios_képernyõn></a></h3><div class=paragraph><p>A FreeBSD rendszertöltõje rosszul ismerte fel a merevlemez geometriáját. Ezt a FreeBSD slice-ok létrehozásakor és módosításakor külön meg kell adni az <a href="https://man.freebsd.org/cgi/man.cgi?query=fdisk&amp;sektion=8&amp;format=html">fdisk(8)</a> használatakor.</p></div><div class=paragraph><p>A meghajtóhoz tartozó megfelelõ geometriai beállítások a számítógép BIOS-ában találhatóak. Keressük meg az adott meghajtó cilinder-fej-szektor (Cylinder/Head/Sector) értékét.</p></div><div class=paragraph><p>A <a href="https://man.freebsd.org/cgi/man.cgi?query=sysinstall&amp;sektion=8&amp;format=html">sysinstall(8)</a> partíciószerkesztõjében a <kbd>G</kbd> billentyû lenyomásával tudjuk beállítani ezt.</p></div><div class=paragraph><p>Ekkor egy párbeszédablak jelenik meg, ahol meg tudjuk adni a cilinderek, fejek és a sávonkénti szektorok számát. Ide perjelekkel elválasztva gépeljük e a BIOS-ban talált értékeket. Például ha a merevlemez geometriája 5000 cilinder, 250 fej és sávonként 60 szektor, akkor a <code>5000/250/60</code> értéket kell megadnunk.</p></div><div class=paragraph><p>Az <kbd>Enter</kbd> billentyû lenyomására ezek az értékek beállítódnak, és a <kbd>W</kbd> lenyomására pedig az új partíciós tábla kiíródik a lemezre.</p></div></div><div class=sect2><h3 id=_egy_másik_operációs_rendszer_letörölte_a_boot_managert_hogyan_lehet_visszaállítani>5.28. Egy másik operációs rendszer letörölte a boot managert. Hogyan lehet visszaállítani?<a class=anchor href=#_egy_másik_operációs_rendszer_letörölte_a_boot_managert_hogyan_lehet_visszaállítani></a></h3><div class=paragraph><p>Indítsuk el a <a href="https://man.freebsd.org/cgi/man.cgi?query=sysinstall&amp;sektion=8&amp;format=html">sysinstall(8)</a> programot, majd válasszuk a <span class=guimenuitem>Configure</span> és <span class=guimenuitem>Fdisk</span> menüpontokat. A partíciószerkesztõben a <kbd>Space</kbd> billentyûvel tudjuk kiválasztani azt a partíciót, amelyen korábban a boot manager volt. Ezután az <kbd>W</kbd> billentyû lenyomásával tudjuk a változtatásainkat lemezre menteni. Ekkor egy menü jelenik meg, ahol a telepíteni kívánt rendszertöltõt választhatjuk ki. Adjuk meg és ekkor visszakerül a helyére.</p></div></div><div class=sect2><h3 id=_mit_jelent_a_swap_pager_indefinite_wait_buffer_hibaüzenet>5.29. Mit jelent a swap_pager: indefinite wait buffer: hibaüzenet?<a class=anchor href=#_mit_jelent_a_swap_pager_indefinite_wait_buffer_hibaüzenet></a></h3><div class=paragraph><p>Ez arra utal, hogy egy futó program megpróbált kiírni egy lapot a memóriából a lemezre, azonban 20 másodperce már nem tudott hozzáférni a lemezhez. Ezt okozhatják hibás szektorok a lemezen, a lemez hibás kábelezése vagy esetleg valamilyen lemezmûveletekkel kapcsolatos hardver meghibásodása. Amennyiben maga a meghajtó a rossz, akkor az ilyen hibaüzenetek mellett még más, a lemez hibás mûködésére utaló üzenetet is látnunk kell a <span class=filename>/var/log/messages</span> állományban vagy a <code>dmesg</code> kimenetében. Minden más esetben érdemes a meghajtó csatlakozásait és kábelezését ellenõrizni.</p></div></div><div class=sect2><h3 id=_mik_azok_a_udma_icrc_hibák_és_hogyan_lehet_ellenük_tenni_valamit>5.30. Mik azok a UDMA ICRC hibák és hogyan lehet ellenük tenni valamit?<a class=anchor href=#_mik_azok_a_udma_icrc_hibák_és_hogyan_lehet_ellenük_tenni_valamit></a></h3><div class=paragraph><p>A <a href="https://man.freebsd.org/cgi/man.cgi?query=ata&amp;sektion=4&amp;format=html">ata(4)</a> meghajtó jelenti ezeket a <code>UDMA ICRC</code> hibákat olyan esetekben, amikor a merevlemezre vagy a merevlemezrõl érkezõ DMA átvitel hibás. A meghajtó ilyenkor még párszor megpróbálja megismételni a mûveletet. Amennyiben ezek a mûveletek is meghiúsulnak, a DMA átvitel helyett a lassabb PIO átviteli módra állítja át a merevlemez felé irányuló kommunikációt.</p></div><div class=paragraph><p>Ezt a problémát több tényezõ is okozhatja, habár ennek a leggyakoribb oka a hibás vagy rossz kábelezés. Ilyenkor mindig ellenõrizzük, hogy a merevlemezhez csatlakozó ATA-kábelek sértetlenek és a használni kívánt Ultra DMA átviteli módra alkalmasak. Ha cserélhetõ lemezes meghajtót használunk, akkor kompatibilisnek is kell lenniük. Ez a gond akkor jelentkezhet, amikor ugyanarra az ATA-csatornára egy Ultra DMA 66-os (vagy annál is gyorsabb) és egy régebbi meghajtót csatlakoztatunk. Végezetül ezek a hibaüzenetek arra is utalhatnak, hogy a meghajtó meghibásodott. A legtöbb gyártó külön szoftver ajánl fel ennek vizsgálatára, ezért ilyenkor érdemes letesztelnünk az érintett meghajtót, illetve amennyiben szükséges, biztonsági másolatot készíteni az adatainkról és kicserélni az eszközt.</p></div><div class=paragraph><p>Az <a href="https://man.freebsd.org/cgi/man.cgi?query=atacontrol&amp;sektion=8&amp;format=html">atacontrol(8)</a> segédprogram használatával ellenõrizni tudjuk, hogy jelenleg az egyes ATA-eszközök milyen DMA vagy PIO módban mûködnek. Erre a célra különösen az <code>atacontrol mode csatorna</code> parancsot javasoljuk, amivel képesek vagyünk megnézni az adott ATA-csatornára csatlakozó eszközök átviteli módjait. Itt a <em>csatorna</em> értéke nullától indul.</p></div></div><div class=sect2><h3 id=_mi_az_a_lock_order_reversal>5.31. Mi az a lock order reversal?<a class=anchor href=#_mi_az_a_lock_order_reversal></a></h3><div class=paragraph><p>Erre a kérdésre a választ a FreeBSD-s szakkifejezések gyûjteményében találjuk meg a <a href=https://docs.freebsd.org/hu/books/handbook/glossary#lor-glossary>LOR</a> címszó alatt.</p></div></div><div class=sect2><h3 id=_mit_jelent_a_called_with_the_following_non_sleepable_locks_held_üzenet>5.32. Mit jelent a Called …​ with the following non-sleepable locks held üzenet?<a class=anchor href=#_mit_jelent_a_called_with_the_following_non_sleepable_locks_held_üzenet></a></h3><div class=paragraph><p>Ez az üzenet arra utalhat, hogy egy függvény lepihent miközben nála volt egy mutex (vagy más, nem pihentethetõ) típusú zárolás.</p></div><div class=paragraph><p>Azért keletkezik ilyen hiba, mert a mutexeket nem úgy tervezték, hogy hosszabb ideig is meg lehessen tartani, kizárólag csak rövid idõtartamra vonatkozó szinkronizációt lehet velük végezni. Ez a programozói megegyezés lehetõvé teszi az eszközmeghajtók számára, hogy a megszakítások közben mutexek segítségével képesek legyenek szinkronizálni a rendszermag többi részével. A megszakítások (FreeBSD alatt) pedig nem pihenhetnek. Ezért a rendszermagon belül semmilyen olyan alrendszer nem blokkolódhat huzamosabb ideig, amelyik mutexet tart magánál.</p></div><div class=paragraph><p>Ezeket a hibákat úgy tudjuk elcsípni, ha olyan ellenõrzéseket teszünk a rendszermagba, amelyek jeleznek a <a href="https://man.freebsd.org/cgi/man.cgi?query=witness&amp;sektion=4&amp;format=html">witness(4)</a> alrendszernek, hogy küldjön figyelmeztetést vagy akár végzetes hibát (a rendszer konfigurációjától függõen) azokban a helyzetekben, amikor egy sejthetõen hosszabb ideig blokkolt hívás tart magánál egy mutexet.</p></div><div class=paragraph><p>Röviden úgy foglalhatnánk össze, hogy ezek a hibák alapvetõen nem végzetesek, de egy kis balszerencsével az egyszerû kis megakadásoktól kezdve a teljes lefagyásig szinte bármilyen hibáért felelõsek lehetnek.</p></div></div><div class=sect2><h3 id=_a_buildworldinstallworld_miért_áll_le_touch_not_found_hibával>5.33. A buildworld/installworld miért áll le touch: not found hibával?<a class=anchor href=#_a_buildworldinstallworld_miért_áll_le_touch_not_found_hibával></a></h3><div class=paragraph><p>Ez a hibaüzenet nem azt jelenti, hogy a <a href="https://man.freebsd.org/cgi/man.cgi?query=touch&amp;sektion=1&amp;format=html">touch(1)</a> segédprogram nem található, hanem inkább azt, hogy az érintett állományok dátuma a jövõre állítódott be. Ha a CMOS óránkat a helyi idõ szerint állítottuk be, akkor egyfelhasználós módban indítsuk újra a rendszert és a <code>adjkerntz -i</code> parancs kiadásával állítsuk be a rendszermag óráját.</p></div></div></div></div><div class=sect1><h2 id=_kereskedelmi_alkalmazások>6. Kereskedelmi alkalmazások<a class=anchor href=#_kereskedelmi_alkalmazások></a></h2><div class=sectionbody><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Ez a fejezet még nagyon rövid, de természetesen reméljük, hogy a különbözõ cégek hamarosan bõvíteni fogják! :) A FreeBSD fejlesztõinek ezzel kapcsolatban semmilyen anyagi érdekük nincs, csupán szeretnék felsorolni a nyilvánosan is elérhetõ szolgáltatásokat (de úgy érezzük, hogy a FreeBSD kereskedelmi irányú megközelítése a FreeBSD fejlõdésére is jó hatással lehet hosszabb távon). Javasoljuk minden kereskedelmi fejlesztõnek, hogy küldjék be ide is a saját kérdéseiket. <a href=https://www.FreeBSD.org/commercial/>A gyártók honlapján</a> olvashatjuk a teljes listájukat.</p></div></td></tr></tbody></table></div><div class=sect2><h3 id=_honnan_lehet_a_freebsd_hez_irodai_programcsomagokat_szerezni>6.1. Honnan lehet a FreeBSD-hez irodai programcsomagokat szerezni?<a class=anchor href=#_honnan_lehet_a_freebsd_hez_irodai_programcsomagokat_szerezni></a></h3><div class=paragraph><p>A nyílt forráskódú OpenOffice.org irodai programcsomag FreeBSD alatt natívan is futtatható. Oracle Open Office linuxos változata, amely az OpenOffice.org zárt forráskódú, továbbfejlesztett változata, szintén mûködik FreeBSD alatt.</p></div><div class=paragraph><p>A FreeBSD ezeken kívül még számos szövegszerkesztõt, táblázatkezelõt és rajzprogramot is tartalmaz a Portgyûjteményében.</p></div></div><div class=sect2><h3 id=_honnan_lehet_a_motif_ot_szerezni_a_freebsd_hez>6.2. Honnan lehet a Motif®-ot szerezni a FreeBSD-hez?<a class=anchor href=#_honnan_lehet_a_motif_ot_szerezni_a_freebsd_hez></a></h3><div class=paragraph><p>A The Open Group kiadta a Motif® 2.2.2 változatának forráskódját. Ez az <a class=package href=https://cgit.freebsd.org/ports/tree/x11-toolkits/open-motif/>x11-toolkits/open-motif</a> csomagból vagy portból érhetõ el. A telepítésével kapcsolatban olvassuk el a kézikönyv <a href=https://docs.freebsd.org/hu/books/handbook/ports/#ports>portokról szóló részét</a>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Az Open Motif® kizárólag csak <a href=http://www.opensource.org/>nyílt forráskódú</a> operációs rendszereken terjeszthetõ.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Ezenkívül még használhatóak a Motif® kereskedelmi változatai is. Ezek viszont már nem ingyenesek, de a licencük megengedi azt, hogy zárt forráskódú szoftverekben is felhasználhassuk. Az <a href=#apps2go>Apps2go</a>nál érdeklõdjünk a FreeBSD-re elérhetõ legolcsóbb Motif® 2.1.20 ELF (i386™) típusú terjesztésekkel kapcsolatban. <a id=apps2go></a></p></div><div class=paragraph><p>Kétfajta terjesztés létezik, a "fejlesztõi változat" és a "futásidejû változat" (valamivel olcsóbb). Az egyes terjesztésekben a következõk találhatóak:</p></div><div class=ulist><ul><li><p>OSF/Motif® manager, xmbind, panner, wsm</p></li><li><p>Fejlesztõi készlet: uil, mrm, xm, xmcxx, include és Imake állományok</p></li><li><p>Statikus és dinamikus ELF könyvtárak</p></li><li><p>Példa alkalmazások</p></li></ul></div><div class=paragraph><p>A megrendelés során ne felejtsük el megadni, hogy a Motif® melyik FreeBSD verzióhoz készített változatát kérjük (valamint az architektúrát se)! Az <em>Apps2go</em> NetBSD és OpenBSD rendszerekkel is foglalkozik, ezeket a változatokat jelenleg csak FTP-n keresztül lehet elérni.</p></div><div class=dlist><dl><dt class=hdlist1>További információk</dt><dd><p><a href=http://www.apps2go.com/>Az Apps2go honlapja</a></p></dd><dt class=hdlist1>illetve</dt><dd><p><a href=mailto:sales@apps2go.com>sales@apps2go.com</a> vagy <a href=mailto:support@apps2go.com>support@apps2go.com</a></p></dd><dt class=hdlist1>vagy</dt><dd><p>telefonon: (817) 431 8775 és +1 817 431-8775</p></dd></dl></div></div><div class=sect2><h3 id=_honnan_lehet_freebsd_re_cde_t_szerezni>6.3. Honnan lehet FreeBSD-re CDE-t szerezni?<a class=anchor href=#_honnan_lehet_freebsd_re_cde_t_szerezni></a></h3><div class=paragraph><p>A <em>Xi Graphics</em> korábban kínált fel CDE-t FreeBSD-hez, de manapság már nem foglalkoznak ezzel.</p></div><div class=paragraph><p>A <a href=http://www.kde.org/>KDE</a> a CDE-hez nagyon sok tekintetben hasonló nyílt forráskódú X11 munkakörnyezet, de érdemes pillanatást vetnünk az <a href=http://www.xfce.org>xfce</a>-re is. A KDE és az xfce egyaránt megtalalálható a <a href=https://www.FreeBSD.org/ports/>portok között</a>.</p></div></div><div class=sect2><h3 id=_használhatóak_adatbázisrendszerek_freebsd_alatt>6.4. Használhatóak adatbázisrendszerek FreeBSD alatt?<a class=anchor href=#_használhatóak_adatbázisrendszerek_freebsd_alatt></a></h3><div class=paragraph><p>Igen! A FreeBSD hivatalos honlapján megtaláljuk ezeket a <a href=https://www.FreeBSD.org/commercial/software_bycat/#CATEGORY_DATABASE>kereskedelmi gyártók</a> között.</p></div><div class=paragraph><p>Érdemes még megnéznünk a Portgyûjteményeben a <a href=https://www.FreeBSD.org/ports/>adatbázisokat</a> tartalmazó szekciót.</p></div></div><div class=sect2><h3 id=_az_oracle_fut_freebsd_alatt>6.5. Az Oracle® fut FreeBSD alatt?<a class=anchor href=#_az_oracle_fut_freebsd_alatt></a></h3><div class=paragraph><p>Igen. A <a href=http://www.shadowcom.net/freebsd-oracle9i/>http://www.shadowcom.net/freebsd-oracle9i/</a> oldalon találunk arról információt, hogyan telepíthetjük FreeBSD-re az Oracle® Linux® változatát.</p></div></div></div></div><div class=sect1><h2 id=_felhasználói_alkalmazások>7. Felhasználói alkalmazások<a class=anchor href=#_felhasználói_alkalmazások></a></h2><div class=sectionbody><div class=sect2><h3 id=_hol_vannak_a_felhasználói_programok>7.1. Hol vannak a felhasználói programok?<a class=anchor href=#_hol_vannak_a_felhasználói_programok></a></h3><div class=paragraph><p>Nézzünk szét a <a href=https://www.FreeBSD.org/ports/>portok között</a> és láthatjuk, hogy milyen szoftvereket portoltak eddig FreeBSD-re. A listában pillanatnyilag 36000 port található és naponta növekszik, ezért érdemes folyamatosan figyelni vagy az új portokról úgy is értesülhetünk rendszeresen, ha feliratkozunk a <a href=https://lists.FreeBSD.org/subscription/freebsd-announce>FreeBSD announcements levelezési lista</a> címére.</p></div><div class=paragraph><p>A legtöbb portnak mûködnie kell a 6.<em>X</em>, 7.<em>X</em> és 8.<em>X</em> ágak használata esetén is. Mindegyik FreeBSD kiadás elkészítésekor készül egy pillanatfelvétel a portokat tartalmazó könyvtárról és bekerül a <span class=filename>ports/</span> könyvtárba.</p></div><div class=paragraph><p>Ezenkívül még "csomagok" is rendelkezésünkre állnak, amelyek lényegében egy tömörített bináris terjesztési formát takarnak, némi plusz információval kiegészítve az egyéni telepítésekhez elvégzéséhez. A csomagok könnyen telepíthetõek és eltávolíthatóak anélkül, hogy pontosan ismernénk a benne található állományok összes apró részletét.</p></div><div class=paragraph><p>A különbözõ csomagokat a <a href="https://man.freebsd.org/cgi/man.cgi?query=sysinstall&amp;sektion=8&amp;format=html">sysinstall(8)</a> programban (a <span class=guimenuitem>Configure</span> menün belül) található <span class=guimenuitem>Packages</span> menüpontban tudjuk telepíteni, vagy meghívjuk meg a <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg_add&amp;sektion=1&amp;format=html">pkg_add(1)</a> parancsot. A csomagokat leginkább <span class=filename>.tbz</span> kiterjesztésükrõl lehet megismerni, valamint a telepítõ CD-ken a <span class=filename>packages/All</span> könyvtárban találhatóak. Az interneten keresztül is le tudjuk tölteni ezek közül a FreeBSD különbözõ verzióihoz tartozó változatukat a hozzánk legközelebbi tükrözésekrõl:</p></div><div class=dlist><dl><dt class=hdlist1>6.<em>X</em>-RELEASE/6-STABLE esetén</dt><dd><p><a href=ftp://ftp.FreeBSD.org/pub/FreeBSD/ports/i386/packages-6-stable/>ftp://ftp.FreeBSD.org/pub/FreeBSD/ports/i386/packages-6-stable/</a></p></dd><dt class=hdlist1>7.<em>X</em>-RELEASE/7-STABLE esetén</dt><dd><p><a href=ftp://ftp.FreeBSD.org/pub/FreeBSD/ports/i386/packages-7-stable/>ftp://ftp.FreeBSD.org/pub/FreeBSD/ports/i386/packages-7-stable</a></p></dd><dt class=hdlist1>8.<em>X</em>-RELEASE/8-STABLE esetén</dt><dd><p><a href=ftp://ftp.FreeBSD.org/pub/FreeBSD/ports/i386/packages-8-stable/>ftp://ftp.FreeBSD.org/pub/FreeBSD/ports/i386/packages-8-stable</a></p></dd><dt class=hdlist1>9-CURRENT esetén</dt><dd><p><a href=ftp://ftp.FreeBSD.org/pub/FreeBSD/ports/i386/packages-9-current/>ftp://ftp.FreeBSD.org/pub/FreeBSD/ports/i386/packages-9-current</a></p></dd></dl></div><div class=paragraph><p>Nem mindegyik port érhetõ el csomagként, mivel folyamatosan készülnek az újabbak. Ezért mindig érdemes bizonyos idõközönként ellenõrizni a központi <a href=ftp://ftp.FreeBSD.org/pub/FreeBSD/>ftp.FreeBSD.org</a> oldalon található csomagokat.</p></div></div><div class=sect2><h3 id=_hogyan_tudjuk_beállítani_az_inn_internet_news_szolgáltatást_a_gépünkön>7.2. Hogyan tudjuk beállítani az INN (Internet News) szolgáltatást a gépünkön?<a class=anchor href=#_hogyan_tudjuk_beállítani_az_inn_internet_news_szolgáltatást_a_gépünkön></a></h3><div class=paragraph><p>Telepítsük az <a class=package href=https://cgit.freebsd.org/ports/tree/news/inn/>news/inn</a> csomagot vagy portot és utána kiindulásképpen nézzük meg <a href=http://www.eyrie.org/~eagle/faqs/INN.html>az INN GYIK-ot</a>.</p></div></div><div class=sect2><h3 id=_a_freebsd_rendelkezik_java_támogatással>7.3. A FreeBSD rendelkezik Java™ támogatással?<a class=anchor href=#_a_freebsd_rendelkezik_java_támogatással></a></h3><div class=paragraph><p>Igen. Látogassunk el a <a href=https://www.FreeBSD.org/java/>http://www.FreeBSD.org/java/</a> oldalra.</p></div></div><div class=sect2><h3 id=_miért_nem_fordul_egy_port_a_6_x_stable_7_x_stable_vagy_8_x_stable_változatot_futtató_gépeken>7.4. Miért nem fordul egy port a 6.X-STABLE, 7.X-STABLE vagy 8.X-STABLE változatot futtató gépeken?<a class=anchor href=#_miért_nem_fordul_egy_port_a_6_x_stable_7_x_stable_vagy_8_x_stable_változatot_futtató_gépeken></a></h3><div class=paragraph><p>Ha olyan FreeBSD verziónk van, amely egy kicsit lemaradt az aktuális <em>-CURRENT</em> vagy <em>-STABLE</em> ágak mögött, akkor valószínûleg frissítenünk kell a Portgyûjteményünket. Ennek részleteirõl a Porterek kézikönyvében, a <a href=https://docs.freebsd.org/en/books/porters-handbook/#keeping-up>Keeping Up</a> címû részben olvashatunk (angolul). Ha viszont rendszerünkben minden a lehetõ legfrissebb, akkor elõfordulhat, hogy valaki olyan változtatást rakott fel a porthoz, amely a <em>-CURRENT</em> esetén mûködik, de a <em>-STABLE</em> változatban már nem. Ilyenkor feltétlenül küldjünk egy hibajelentést a <a href="https://man.freebsd.org/cgi/man.cgi?query=send-pr&amp;sektion=1&amp;format=html">send-pr(1)</a> paranccsal, hiszen a Portgyûjteménynek a -CURRENT és -STABLE ágak esetén egyaránt mûködnie kell.</p></div></div><div class=sect2><h3 id=_a_make_index_paranccsal_nem_sikerült_létrehozni_az_index_állomyánt_mi_a_gond>7.5. A make index paranccsal nem sikerült létrehozni az INDEX állomyánt. Mi a gond?<a class=anchor href=#_a_make_index_paranccsal_nem_sikerült_létrehozni_az_index_állomyánt_mi_a_gond></a></h3><div class=paragraph><p>Elsõként mindig ellenõrizzük, hogy a Portgyûjteményünk a lehetõ legfrissebb. A legfrissebb változatnál jelentkezõ <span class=filename>INDEX</span> készítési hibák mindig szem elõtt vannak, ezért általában gyorsan megjavulnak.</p></div><div class=paragraph><p>Ha viszont egy friss verzióval rendelkezünk, akkor elképzelhetõ, hogy egy másik hibával kerültünk szembe. A <code>make index</code> parancsnak van egy olyan hibája, amely miatt nem képes a Portgyûjtemény hiányos példányával dolgozni. Feltételezi ugyanis, hogy az összes olyan port megtalálható a rendszerünkben, amely telepítése szükséges az adott porthoz. Ennek megértéséhez most képzeljük el, hogy megvan az <span class=filename>ize/mize</span> port a lemezen, amely függ az <span class=filename>aze/maze</span> porttól, és emiatt az <span class=filename>aze/maze</span> portnak és függõségeinek is rajta kell lennie a lemezünkön. Minden más esetben a <code>make index</code> nem tud összegyûjteni elegendõ információt ahhoz, hogy létre tudja hozni a függõségi gráfot.</p></div><div class=paragraph><p>Ez különösen olyan FreeBSD felhasználókkal fordul elõ, akik a <a href="https://man.freebsd.org/cgi/man.cgi?query=cvsup&amp;sektion=1&amp;format=html">cvsup(1)</a> (vagy <a href="https://man.freebsd.org/cgi/man.cgi?query=csup&amp;sektion=1&amp;format=html">csup(1)</a>) használatával frissítik a Portgyûjteményüket, de a <span class=filename>refuse</span> állományokban kizártak néhány kategóriát. Elméletben természetesen ki lehet zárni akármilyen kategóriát, azonban a gyakorlat azt mutatja, hogy ez szinte lehetetlen, mivel túlságosan sok port függ más kategóriákban található portoktól. Amíg valaki meg nem oldja ezt a problémát, addig fogadjuk el általános szabálynak, hogy az <span class=filename>INDEX</span> létrehozásához a teljes Portgyûjteménnyel rendelkeznünk kell.</p></div><div class=paragraph><p>Néhány ritka esetben még elõfordulhat, hogy az <span class=filename>INDEX</span> azért nem jön létre, mert a <span class=filename>make.conf</span> állományban megadtunk valamilyen <code>WITH<em>*<em></em></em></code><em><em> vagy <code>WITHOUT</code></em><code>*</code></em> változót. Ha úgy érezzük, hogy ez okozhatja a problémát, akkor próbáljuk meg elõször ezen változók nélkül létrehozatni az <span class=filename>INDEX</span> állományt és csak utána jelenteni a hibát a <a href=https://lists.FreeBSD.org/subscription/freebsd-ports>FreeBSD ports levelezési lista</a> címére.</p></div></div><div class=sect2><h3 id=_a_cvsup_miért_nincs_a_freebsd_forrásai_között>7.6. A CVSup miért nincs a FreeBSD forrásai között?<a class=anchor href=#_a_cvsup_miért_nincs_a_freebsd_forrásai_között></a></h3><div class=paragraph><p>A FreeBSD alaprendszerét úgy állították össze, hogy saját magát legyen képes legyen lefordítani, vagyis az egész operációs rendszer elõállítható legyen néhány alapvetõ eszköz használatával. Ezért a források között leginkább csak az található meg, ami feltétlenül kell a források lefordításához. Ilyen például a C fordító (<a href="https://man.freebsd.org/cgi/man.cgi?query=gcc&amp;sektion=1&amp;format=html">gcc(1)</a>), a <a href="https://man.freebsd.org/cgi/man.cgi?query=make&amp;sektion=1&amp;format=html">make(1)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=awk&amp;sektion=1&amp;format=html">awk(1)</a> és a többi.</p></div><div class=paragraph><p>Mivel a CVSup a Modula-3 programozási nyelven íródott, csak úgy tudnánk beletenni a FreeBSD alaprendszerbe, ha hozzávennénk és karbantartanánk egy Modula-3 fordítót is. Ezzel együtt viszont növekedne a FreeBSD forrása, amelyet aztán karban is kellene tartani. Ezért mind a fejlesztõk, mind pedig a felhasználók számára egyszerûbb, ha a CVSup egy külön portként érhetõ el a rendszerhez. Ez viszont gyorsan telepíthetõ a FreeBSD telepítõ CD-ken található csomagokból.</p></div><div class=paragraph><p>Azonban a FreeBSD 6.2-RELEASE megjelenésétõl kezdve a FreeBSD felhasználók nem maradnak integrált CVSup kliens nélkül. Maxime Henrion &lt;<a href=mailto:mux@FreeBSD.org>mux@FreeBSD.org</a>> munkájának köszönhetõen a CVSup alkalmazásnak elkészült a C nyelven újraírt változata, a <a href="https://man.freebsd.org/cgi/man.cgi?query=csup&amp;sektion=1&amp;format=html">csup(1)</a>, amely most már az alaprendszer része. Noha jelenleg nem még nem képes mindarra, amire a CVSup, elegendõ (és nagyon gyors!) ahhoz, hogy a forrásainkat frissen tartsuk. A 6.2 elõtt kiadott rendszerek esetében ezt portból vagy csomagból is felrakhatjuk (lásd <a class=package href=https://cgit.freebsd.org/ports/tree/net/csup/>net/csup</a>).</p></div></div><div class=sect2><h3 id=_a_forrásokon_kívül_a_telepített_portokat_is_lehet_valahogy_frissíteni>7.7. A forrásokon kívül a telepített portokat is lehet valahogy frissíteni?<a class=anchor href=#_a_forrásokon_kívül_a_telepített_portokat_is_lehet_valahogy_frissíteni></a></h3><div class=paragraph><p>A FreeBSD alaprendszere ehhez nem kínál fel semmilyen eszközt, de léteznek olyan segédeszközök, amelyekkel valamennyire meg tudjuk könnyíteni a frissítés folyamatát. További segédprogramok telepítésével pedig a portok kezelését tudjuk tovább egyszerûsíteni, amirõl a FreeBSD kézikönyv <a href=https://docs.freebsd.org/hu/books/handbook/ports/#ports-using>A portok frissítése</a> címû szakaszában olvashatunk bõvebben.</p></div></div><div class=sect2><h3 id=_minden_nagyobb_verziófrissítésnél_újra_kell_fordítani_az_összes_telepített_portot_a_rendszeren>7.8. Minden nagyobb verziófrissítésnél újra kell fordítani az összes telepített portot a rendszeren?<a class=anchor href=#_minden_nagyobb_verziófrissítésnél_újra_kell_fordítani_az_összes_telepített_portot_a_rendszeren></a></h3><div class=paragraph><p>Mindenképpen! Noha látszólag a frissített rendszeren is remekül futnak a korábbi verzióra telepített alkalmazások, könnyen elõfordulhat, hogy az újabb portok telepítésékor vagy a meglevõek frissítésekor véletlenszerû összeomlásokat vagy egyéb hibákat tapasztalunk.</p></div><div class=paragraph><p>Ne felejtsük el, hogy a rendszer frissítésekor a különféle osztott könyvtárak, betölthetõ modulok és a rendszer egyéb komponensei is lecserélõdnek. Ezért a régebbi változataikhoz fordított alkalmazások egyáltalán nem fognak elindulni vagy nem mûködnek rendesen.</p></div><div class=paragraph><p>Ezzel kapcsolatban olvassuk el a FreeBSD kézikönyvének <a href=https://docs.freebsd.org/hu/books/handbook/updating-upgrading#freebsdupdate-upgrade>frissítérõl szóló szakaszát</a>.</p></div></div><div class=sect2><h3 id=_minden_kisebb_verziófrissítésnél_újra_kell_fordítani_az_összes_telepített_portot_a_rendszeren>7.9. Minden kisebb verziófrissítésnél újra kell fordítani az összes telepített portot a rendszeren?<a class=anchor href=#_minden_kisebb_verziófrissítésnél_újra_kell_fordítani_az_összes_telepített_portot_a_rendszeren></a></h3><div class=paragraph><p>Általánosságban véve nem. A FreeBSD fejlesztõi ugyanis mindent megtesznek azért, hogy ugyanazon a fõ fejlesztési ágon belüli verziók között megmaradjon a bináris szintû kompatibilitás. Az esetleges kivételeket pedig dokumentálni szokták a kiadásokhoz tartozó jegyzetekben, ahol többnyire megadják az adott változtatáshoz tartozóan a követendõ tanácsokat.</p></div></div><div class=sect2><h3 id=_a_binsh_miért_ilyen_egyszerû_a_freebsd_ben_miért_nincs_bash_vagy_valamilyen_más_rendes_parancsértelmezõ>7.10. A /bin/sh miért ilyen egyszerû? A FreeBSD-ben miért nincs bash vagy valamilyen más rendes parancsértelmezõ?<a class=anchor href=#_a_binsh_miért_ilyen_egyszerû_a_freebsd_ben_miért_nincs_bash_vagy_valamilyen_más_rendes_parancsértelmezõ></a></h3><div class=paragraph><p>Mert a POSIX® szerint lennie kell egy ilyen parancsértelmezõnek.</p></div><div class=paragraph><p>A valamivel bonyolultabb válasz: sokan szeretnének olyan szkripteket írni, amelyek több rendszer közt is átvihetõek. Ezért a POSIX® a parancsértelmezõkre és a segédprogramokra vonatkozó parancsokat igen részletesen tárgyalja. A legtöbb ilyen szkriptet a Bourne-féle parancsértelmezõben készítik, és több fontos programozói felület (<a href="https://man.freebsd.org/cgi/man.cgi?query=make&amp;sektion=1&amp;format=html">make(1)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=system&amp;sektion=3&amp;format=html">system(3)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=popen&amp;sektion=3&amp;format=html">popen(3)</a> és ezek magasabb szintû, például Perl és Tcl nyelvi megfelelõi) a Bourne-parancsértelmezõ használatán alapszik. Mivel a Bourne-parancsértelmezõ használata ilyen széles körben elterjedt, fontos, hogy gyorsan induljon, elõre megjósolható legyen a mûködése és ne foglaljon túlságosan sok memóriát.</p></div><div class=paragraph><p>A jelenlegi implementáció igyekszik ezek közül az elvárások közül egyszerre a lehetõ legtöbbet teljesíteni. A <code>/bin/sh</code> programot csak úgy tudjuk a megfelelõ méreten tartani, ha nem tesszük bele az összes többi parancsértelmezõben megtalálható kényelmi funkciót. Pontosan ezért találhatjuk meg viszont a Portgyûjteményben a többi, például a <code>bash</code>, <code>scsh</code>, <code>tcsh</code> és <code>zsh</code> parancsértelmezõket. (Ezek konkrét memóriahasználatát össze is tudjuk vetni, ha a <code>ps -u</code> parancs kimenetének "VSZ" és "RSS" oszlopait megnézzük.)</p></div></div><div class=sect2><h3 id=_a_getenv3_és_az_opera_indítása_miért_tart_olyan_sokáig>7.11. A <a href="https://man.freebsd.org/cgi/man.cgi?query=getenv&amp;sektion=3&amp;format=html">getenv(3)</a> és az Opera indítása miért tart olyan sokáig?<a class=anchor href=#_a_getenv3_és_az_opera_indítása_miért_tart_olyan_sokáig></a></h3><div class=paragraph><p>Erre az az általános válasz, hogy a névfeloldás valószínûleg rosszul mûködik a rendszerünkön. A <a href="https://man.freebsd.org/cgi/man.cgi?query=getenv&amp;sektion=3&amp;format=html">getenv(3)</a> és az Opera is ellenõrzi a névfeloldást az indulásakor. Ezért a böngészõ egészen addig nem jelenik meg az asztalon, amíg választ nem kap vagy rá nem jön, hogy nincs aktív hálózati kapcsolat.</p></div></div><div class=sect2><h3 id=_ha_a_cvsup_használatával_frissítjük_a_portgyûjteményt_akkor_sok_port_nem_fordul_le_mindenféle_rejtélyes_hibaüzenet_kíséretében_valami_nagy_baj_van_a_portgyûjteménnyel>7.12. Ha a CVSup használatával frissítjük a Portgyûjteményt, akkor sok port nem fordul le mindenféle rejtélyes hibaüzenet kíséretében! Valami nagy baj van a Portgyûjteménnyel?<a class=anchor href=#_ha_a_cvsup_használatával_frissítjük_a_portgyûjteményt_akkor_sok_port_nem_fordul_le_mindenféle_rejtélyes_hibaüzenet_kíséretében_valami_nagy_baj_van_a_portgyûjteménnyel></a></h3><div class=paragraph><p>Ha úgy korábban úgy frissítettük a CVSup használatával a Portgyûjteményt, hogy nem adtuk meg a <code>ports-all</code> CVSup algyûjteményt, akkor a <code>ports-base</code> algyûjteményt is <em>mindig</em> frissítenünk kell! Ennek okairól <a href=https://docs.freebsd.org/hu/books/handbook/mirrors#cvsup>a kézikönyvben</a> olvashatunk.</p></div></div><div class=sect2><h3 id=_hogyan_lehet_midi_állományokból_audio_cd_t_készíteni>7.13. Hogyan lehet MIDI állományokból audio CD-t készíteni?<a class=anchor href=#_hogyan_lehet_midi_állományokból_audio_cd_t_készíteni></a></h3><div class=paragraph><p>Ha MIDI állományokból akarunk audio CD-t készíteni, akkor elõször telepítsük fel a Portgyûjteménybõl a <a class=package href=https://cgit.freebsd.org/ports/tree/audio/timidity/>audio/timidity</a> portot, majd kézzel tegyük hozzá Eric A. Welsh GUS patch-eit, melyek a <a href=http://alleg.sourceforge.net/digmid.html>http://alleg.sourceforge.net/digmid.html</a> címrõl tölthetõek le. Miután a TiMidity++ sikeresen felkerült a rendszerünkre, a MIDI állományokat a következõ paranccsal tudjuk átkonvertálni WAV állományokra:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% timidity <span class=nt>-Ow</span> <span class=nt>-s</span> 44100 <span class=nt>-o</span> /tmp/juke/01.wav 01.mid</code></pre></div></div><div class=paragraph><p>A WAV állományok ezek után tetszõleges formátumba konvertálhatóak tovább vagy készíthetõ belõlük egy audio CD, ahogy azt a <a href=https://docs.freebsd.org/hu/books/handbook/disks/#creating-cds>FreeBSD kézikönyvben</a> is olvashatjuk.</p></div></div></div></div><div class=sect1><h2 id=_a_rendszermag_beállítása>8. A rendszermag beállítása<a class=anchor href=#_a_rendszermag_beállítása></a></h2><div class=sectionbody><div class=sect2><h3 id=_nehéz_testreszabni_a_rendszermagot>8.1. Nehéz testreszabni a rendszermagot?<a class=anchor href=#_nehéz_testreszabni_a_rendszermagot></a></h3><div class=paragraph><p>Egyáltalán nem! Ezzel kapcsolatban olvassuk el <a href=https://docs.freebsd.org/hu/books/handbook/kernelconfig/#kernelconfig>a FreeBSD kézikönyv rendszermag beállításairól szóló részét</a>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Az új <span class=filename>kernel</span> állomány a hozzá tartozó modulokkal együtt a <span class=filename>/boot/kernel</span> könyvtárba települ, míg a rendszermag korábbi változata és a moduljai a <span class=filename>/boot/kernel.old</span> könyvtárba kerül át, így ha netalán valamit elrontottunk volna, akkor a rendszermag korábbi változatának betöltésével lehetõségünk lesz kijavítani a hibát.</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=_a_rendszermag_nem_fordul_le_mert_a_hw_float_nem_található_hogyan_lehet_megoldani_ezt_a_problémát>8.2. A rendszermag nem fordul le, mert a _hw_float nem található. Hogyan lehet megoldani ezt a problémát?<a class=anchor href=#_a_rendszermag_nem_fordul_le_mert_a_hw_float_nem_található_hogyan_lehet_megoldani_ezt_a_problémát></a></h3><div class=paragraph><p>Ez valószínûleg azért következett be, mert eltávolítottuk az <span class=filename>npx0</span> (lásd <a href="https://man.freebsd.org/cgi/man.cgi?query=npx&amp;sektion=4&amp;format=html">npx(4)</a>) támogatást a rendszermag beállításai közül, mert a rendszerünkben nincs matematikai társprocesszor. Az <span class=filename>npx0</span> eszköz jelenléte azonban <em>kötelezõ</em>. Valahol a gépünkben lennie kell olyan eszköznek, amely a lebegõpontos számok hardveres kezelését végzi, annak ellenére, hogy nem egy különálló eszköz, ahogy régen a 386-osoknál volt. A rendszermagban szerepelnie <em>kell</em> az <span class=filename>npx0</span> eszköznek. Ha netalán még sikerülne is <span class=filename>npx0</span> támogatás nélkül fordítanunk egy rendszermagot, akkor sem tud elindulni.</p></div></div><div class=sect2><h3 id=_miért_ilyen_nagy_a_rendszermag_mérete_közel_10_mb>8.3. Miért ilyen nagy a rendszermag mérete (közel 10 MB)?<a class=anchor href=#_miért_ilyen_nagy_a_rendszermag_mérete_közel_10_mb></a></h3><div class=paragraph><p>Nagyon valószínû, hogy a rendszermagunk <em>debug módban</em> készült el. A debug módú rendszermagokban rengeteg olyan szimbólum található, amely hasznos lehet a hibák keresése és a rendszer vizsgálata során, ezért emiatt jelentõs mértékben növekszik a mérete. Emiatt nem kell aggódnunk, mert egy hibakeresésre felkészített rendszermag egyáltalán nem vagy csak egy kicsivel lassabb, mint a hagyományos változat, illetve a rendszer összeomlásakor mindig mindig szükségünk lehet ezekre a debug információkra.</p></div><div class=paragraph><p>Ha viszont kevés a lemezterület vagy egyszerûen csak nem akarunk debug módú rendszermagot akarunk futtatni, akkor a következõkre kell figyelnünk:</p></div><div class=ulist><ul><li><p>Vegyük ki a rendszermag konfigurációs állományából a következõ sort:</p><div class="literalblock programlisting"><div class=content><pre>makeoptions DEBUG=-g</pre></div></div></li><li><p>A <a href="https://man.freebsd.org/cgi/man.cgi?query=config&amp;sektion=8&amp;format=html">config(8)</a> használata során ne használjuk a <code>-g</code> beállítást.</p></li></ul></div><div class=paragraph><p>A fentiek közül akármelyiket is választjuk, a rendszermagunk debug módban jön létre. Ha azonban sikerült betartani a fentebb javasolt lépéseket, akkor egy normál rendszermagot kapunk, amely mérete ilyenkor jelentõs mértékben visszaesik: a legtöbbjük olyan 1,5 és 2 MB körül van.</p></div></div><div class=sect2><h3 id=_miért_ütköznek_a_megszakítások_amikor_többportos_soros_vonali_kártyákat_akarunk_használni>8.4. Miért ütköznek a megszakítások, amikor többportos soros vonali kártyákat akarunk használni?<a class=anchor href=#_miért_ütköznek_a_megszakítások_amikor_többportos_soros_vonali_kártyákat_akarunk_használni></a></h3><div class=paragraph><p>Ha a rendszermagot a többportos soros vonali kártyák támogatásával fordítjuk le, akkor a rendszertõl azt az üzenetet kapjuk, hogy csak az elsõ megszakítást fogja használni, a többit pedig ütközés miatt (interrupt conflict) kihagyja. Hogyan lehet ezen javítani?</p></div><div class=paragraph><p>A gondot alapvetõen az okozza, hogy a FreeBSD a rendszermagban fixen letárolja ezeket, nehogy valamilyen hardveres vagy szoftveres ütközés miatt elkallódjanak. Ezen úgy tudunk segíteni, ha egyetlen IRQ vonal kivételével az összes többi beállítását szabadon hagyjuk. Íme erre egy példa:</p></div><div class="literalblock programlisting"><div class=content><pre>#
# Többportos nagysebességû soros vonali eszközök - 16550 UART
#
device sio2 at isa? port 0x2a0 tty irq 5 flags 0x501 vector siointr
device sio3 at isa? port 0x2a8 tty flags 0x501 vector siointr
device sio4 at isa? port 0x2b0 tty flags 0x501 vector siointr
device sio5 at isa? port 0x2b8 tty flags 0x501 vector siointr</pre></div></div></div><div class=sect2><h3 id=_miért_nem_lehet_lefordítani_a_rendszermagot_még_a_generic_beállításaival_sem>8.5. Miért nem lehet lefordítani a rendszermagot, még a GENERIC beállításaival sem?<a class=anchor href=#_miért_nem_lehet_lefordítani_a_rendszermagot_még_a_generic_beállításaival_sem></a></h3><div class=paragraph><p>Ennek több oka is lehet. Ezek közül néhány, de nem feltétlenül ebben a sorrendben:</p></div><div class=ulist><ul><li><p>Nem a <code>make buildkernel</code> és <code>make installkernel</code> parancsokat használtuk és valószínûleg a forrásaink sem egyeznek meg a jelenleg futó rendszerével (például egy 12.0-RELEASE rendszert akarunk fordítani egy 11.2-RELEASE rendszeren). Ha frissíteni akarunk, akkor olvassuk el a <span class=filename>/usr/src/UPDATING</span> állományt, különös tekintettel a végén található "COMMON ITEMS" címû szakaszra.</p></li><li><p>A <code>make buildkernel</code> és <code>make installkernel</code> parancsokat használtuk, de elõtte nem futott le rendesen a <code>make buildworld</code> parancs. A <code>make buildkernel</code> parancs ugyanis erõsen támaszkodik a <code>make buildworld</code> által végzett munkára.</p></li><li><p>Gyakran a <a href=#stable>FreeBSD-STABLE</a> változat használata esetén is elõfordulhat, hogy olyan pillanatban töltöttük le a forrásokat, amikor módosítás alatt voltak vagy valamiért nem mûködtek rendesen. Kizárólag a kiadások esetén tudjuk szavatolni a hibátlan fordítást, noha a <a href=#stable>FreeBSD-STABLE</a> verzióból készült változatok is többnyire megfelelõek. Próbáljuk meg újra letölteni a forrásokat, ha eddig még nem próbálkoztunk volna vele, és nézzük meg, hogy ez segít-e megoldani a problémát. Keressük másik szervert, ha gondjaink vannak a frissítéssel.</p></li></ul></div></div><div class=sect2><h3 id=_honnan_tudhatjuk_meg_milyen_ütemezõvel_dolgozik_a_rendszerünk>8.6. Honnan tudhatjuk meg milyen ütemezõvel dolgozik a rendszerünk?<a class=anchor href=#_honnan_tudhatjuk_meg_milyen_ütemezõvel_dolgozik_a_rendszerünk></a></h3><div class=paragraph><p>Nézzük meg, hogy a rendszerünkben elérhetõ-e a <code>kern.sched.quantum</code> változó. Ha van ilyenünk, akkor valami ilyesmit kell tapasztalnunk:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% sysctl kern.sched.quantum
kern.sched.quantum: 99960</code></pre></div></div><div class=paragraph><p>Ha létezik a <code>kern.sched.quantum</code> nevû sysctl változó, akkor a 4BSD ütemezõ fut (lásd <a href="https://man.freebsd.org/cgi/man.cgi?query=sched_4bsd&amp;sektion=4&amp;format=html">sched_4bsd(4)</a>). Ha nem, akkor egy ilyen hibát kapunk a <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> parancstól (ezt nyugodtan figyelmen kívül hagyhatjuk):</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% sysctl kern.sched.quantum
sysctl: unknown oid <span class=s1>&#39;kern.sched.quantum&#39;</span></code></pre></div></div><div class=paragraph><p>Az aktuálisan használt ütemezõ neve közvetlenül elérhetõ a <code>kern.sched.name</code> sysctl változó lekérdezésén keresztül:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% sysctl kern.sched.name
kern.sched.name: 4BSD</code></pre></div></div></div><div class=sect2><h3 id=_mi_az_a_kern_sched_quantum>8.7. Mi az a kern.sched.quantum?<a class=anchor href=#_mi_az_a_kern_sched_quantum></a></h3><div class=paragraph><p>A <code>kern.sched.quantum</code> értéke határozza meg, hogy egy futó program legfeljebb mennyi órajelet futhat egyszerre, megszakítás nélkül. Ezt az értéket a 4BSD ütemezõ használja, ezért a jelenlétébõl vagy hiányából következtetni tudunk a pillanatnyilag használatban levõ ütemezõre.</p></div></div></div></div><div class=sect1><h2 id=_lemezek_állományrendszerek_és_rendszertöltők>9. Lemezek, állományrendszerek és rendszertöltők<a class=anchor href=#_lemezek_állományrendszerek_és_rendszertöltők></a></h2><div class=sectionbody><div class=sect2><h3 id=_hogyan_adjunk_lemezeket_a_freebsd_rendszerünkhöz>9.1. Hogyan adjunk lemezeket a FreeBSD rendszerünkhöz?<a class=anchor href=#_hogyan_adjunk_lemezeket_a_freebsd_rendszerünkhöz></a></h3><div class=paragraph><p>Ezzel kapcsolatban olvassuk el a lemezek hozzáadásáról szóló részt a <a href=https://docs.freebsd.org/hu/books/handbook/disks/#disks-adding>FreeBSD kézikönyvben</a>.</p></div></div><div class=sect2><h3 id=_hogyan_lehet_átteni_a_rendszert_egy_nagyobb_lemezre>9.2. Hogyan lehet átteni a rendszert egy nagyobb lemezre?<a class=anchor href=#_hogyan_lehet_átteni_a_rendszert_egy_nagyobb_lemezre></a></h3><div class=paragraph><p>Ezt legegyszerûbben úgy tudjuk megcsinálni, ha újratelepítjük az operációs rendszert az új lemezre és külön áttesszük a felhasználói adatokat. Ez különösen ajánlott abban az esetben, ha már több kiadás óta követjük a <em>-STABLE</em> változatot, vagy ha korábban már frissítettük a kiadásunkat. A <a href="https://man.freebsd.org/cgi/man.cgi?query=boot0cfg&amp;sektion=8&amp;format=html">boot0cfg(8)</a> segítségével fel tudjuk rakni a booteasyt mind a két lemezre és így egészen addig váltogatni tudjuk a kettõt, amíg teljesen át nem álltunk. Ugorjuk át a következõ bekezdést, és olvassuk el, hogy rakjuk át az adatokat.</p></div><div class=paragraph><p>Úgy is dönthetünk, hogy nem telepítjük újra a rendszert. Ekkor vagy a <a href="https://man.freebsd.org/cgi/man.cgi?query=sysinstall&amp;sektion=8&amp;format=html">sysinstall(8)</a>, vagy pedig a <a href="https://man.freebsd.org/cgi/man.cgi?query=fdisk&amp;sektion=8&amp;format=html">fdisk(8)</a> és a <a href="https://man.freebsd.org/cgi/man.cgi?query=disklabel&amp;sektion=8&amp;format=html">disklabel(8)</a> használatával osszuk fel és címkézzük meg az új lemezt. Érdemes még a <a href="https://man.freebsd.org/cgi/man.cgi?query=boot0cfg&amp;sektion=8&amp;format=html">boot0cfg(8)</a> segítségével felraknunk a booteasyt mind a két lemezre, így miután átmásoltuk a régi rendszerünket az új lemezre, ennek megtartásával ki tudjuk próbálni az új rendszert.</p></div><div class=paragraph><p>Most, miután sikeresen beállítottuk az új lemezt, készen állunk az adatok átmásolására. Sajnos nem lehet csak úgy vakon átmásolni ezeket egyik lemezrõl a másikra. Ilyenkor ugyanis bizonyos dolgok (például a <span class=filename>/dev</span> könyvtárban található eszközleírók, az állományjelzõk és a linkek stb.) hajlamosak elromlani. Ezért ehhez olyan eszközökre lesz szükségünk, amelyek ismerik ezeket a dolgokat, mint például a <a href="https://man.freebsd.org/cgi/man.cgi?query=dump&amp;sektion=8&amp;format=html">dump(8)</a>. Továbbá javasoljuk, hogy egyfelhasználós módban végezzük el az átvitelt, noha ez nem feltétlenül szükséges.</p></div><div class=paragraph><p>A rendszerindító állományrendszer átmozgatásához egyedül a <a href="https://man.freebsd.org/cgi/man.cgi?query=dump&amp;sektion=8&amp;format=html">dump(8)</a> és <a href="https://man.freebsd.org/cgi/man.cgi?query=restore&amp;sektion=8&amp;format=html">restore(8)</a> segédprogramokra lesz szükségünk. Esetleg a <a href="https://man.freebsd.org/cgi/man.cgi?query=tar&amp;sektion=1&amp;format=html">tar(1)</a> parancs is használható, de nem minden esetben. A <a href="https://man.freebsd.org/cgi/man.cgi?query=dump&amp;sektion=8&amp;format=html">dump(8)</a> és <a href="https://man.freebsd.org/cgi/man.cgi?query=restore&amp;sektion=8&amp;format=html">restore(8)</a> páros akkor is remekül használható, ha egy partíció tartalmát egy üres partícióra akarjuk átvinni. A következõ lépések szükségesek ahhoz, hogy a <code>dump</code> parancs segítségével átvigyük egyik partícióról a másikra az adatokat:</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Hozzunk létre egy új partíciót.</p></li><li><p>Ideiglenesen csatlakoztassuk egy könyvtárba.</p></li><li><p>Lépjünk be abba a könyvtárba.</p></li><li><p>Mentsük le a régi partíciót és az eredményt küldjük át az újra.</p></li></ol></div></div></div><div class=paragraph><p>Például, ha a <span class=filename>/mnt</span> könyvtárba csatlakoztatott <span class=filename>/dev/ad1s1a</span> eszközrõl akarjuk átvinni a jelenlegi gyökérpartíciónkat, akkor ezeket a parancsokat kell kiadnunk:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># newfs /dev/ad1s1a</span>
<span class=c># mount /dev/ad1s1a /mnt</span>
<span class=c># cd /mnt</span>
<span class=c># dump 0af - / | restore rf -</span></code></pre></div></div><div class=paragraph><p>További munkát igényel, ha a <code>dump</code> parancs segítségével a partícióinkat is át akarjuk szervezni. Például a <span class=filename>/var</span> partíciót úgy tudjuk beleolvasztani a tövébe, ha létrehozunk egy olyan partíciót, amely mind a kettõ számára elegendõ nagy, majd a fentebb leírt módszerrel elõször átmozgatjuk a tövét, utána pedig átmozgatjuk az alpartíció tartalmát az elsõ mozgatás során létrejött egyik üres könyvtárba:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># newfs /dev/ad1s1a</span>
<span class=c># mount /dev/ad1s1a /mnt</span>
<span class=c># cd /mnt</span>
<span class=c># dump 0af - / | restore rf -</span>
<span class=c># cd var</span>
<span class=c># dump 0af - /var | restore rf -</span></code></pre></div></div><div class=paragraph><p>Egy könyvtárat, például <span class=filename>/var</span> tartalmát pedig úgy tudunk leválasztani a tövérõl, vagyis átrakni egy korábban nem létezõ partícióra, ha elõször létrehozzuk mind a két partíciót, csatlakoztatjuk a leendõ alpartíciót az ideiglenes csatlakozási ponton belül a megfelelõ könyvtárba és mindkettõre átmozgatjuk a régi partíció teljes tartalmát:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># newfs /dev/ad1s1a</span>
<span class=c># newfs /dev/ad1s1d</span>
<span class=c># mount /dev/ad1s1a /mnt</span>
<span class=c># mkdir /mnt/var</span>
<span class=c># mount /dev/ad1s1d /mnt/var</span>
<span class=c># cd /mnt</span>
<span class=c># dump 0af - / | restore rf -</span></code></pre></div></div><div class=paragraph><p>A felhasználói adatok esetén a <a href="https://man.freebsd.org/cgi/man.cgi?query=cpio&amp;sektion=1&amp;format=html">cpio(1)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=pax&amp;sektion=1&amp;format=html">pax(1)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=tar&amp;sektion=1&amp;format=html">tar(1)</a> és <a href="https://man.freebsd.org/cgi/man.cgi?query=dump&amp;sektion=8&amp;format=html">dump(8)</a> eszközöket ajánljuk. Az írás pillanatában még úgy tudjuk, hogy nem tartják meg az állományjelzõkkel kapcsolatos információkat, ezért csak óvatosan használjuk ezeket!</p></div></div><div class=sect2><h3 id=_a_veszélyesen_dedikált_dangerously_dedicated_lemezek_veszélyesek_a_felhasználóra>9.3. A Veszélyesen dedikált (Dangerously Dedicated) lemezek veszélyesek a felhasználóra?<a class=anchor href=#_a_veszélyesen_dedikált_dangerously_dedicated_lemezek_veszélyesek_a_felhasználóra></a></h3><div class=paragraph><p><a id=dedicate></a>A telepítés során két különbözõ módon tudjuk partícionálni a lemezeinket. Alapértelmezés szerint a rendszer igyekszik kompatbilis maradni a gépünkön található többi operációs rendszerrel. Ilyenkor normális partíciós táblabeli bejegyzéseket készít (amelyeket FreeBSD alatt "slice"-oknak hívnak), és egy ilyen slice-ba teszi az összes saját partícióját. Emellé még telepíteni tudjuk az operációs rendszerek választásának lehetõségét is a rendszer indításakor. A másik lehetõség választása esetén azonban a FreeBSD teljesen kisajátítja a lemezt és nem is próbál meg kompatibilis maradni a többi operációs rendszerrel.</p></div><div class=paragraph><p>Miért is nevezzük ezt "veszélyesnek"? A lemez ebben az esetben nem tartalmaz semmi olyat, amelyet a hétköznapi programok partíciós táblaként tudnának beazonosítani. Attól függõen, hogy mennyire illedelmes, egy ilyen program panaszkodni fog, amikor megpróbálja értelmezni a lemez tartalmát, de rosszabb esetben anélkül felülírja a rendszerbetöltõt, hogy bármit is jelzett volna. Ráadásul a "veszélyesen dedikált módon" kiosztott lemezek még bizonyos BIOS-okat is képesek megzavarni, többek közt az Award (például amelyek a HP NetServer, Micronics és hasonló rendszerekben találhatóak) vagy Symbios/NCR (népszerû 53C8xx SCSI-vezérlõk) típusúak esetén találkozhatunk ezzel a problémával. Ez a lista persze nem teljes, más gyártók termékeivel is gondok akadhatnak. Ennek a hibának jellemzõ tünete a <code>read error</code> hibaüzenet, amely arra utal, hogy a FreeBSD betöltõje nem találja saját magát a lemezen, vagy éppen az egész rendszer megáll a rendszer indítása közben.</p></div><div class=paragraph><p>Akkor mégis mi értelme van ennek? Csak néhány kilobyte-tot spórolunk vele, miközben komoly gondokat okozhat egy frissen telepített rendszer esetében. A "veszélyesen dedikált mód" eredetileg az új FreeBSD telepítõket veszélyeztetõ egyik komoly hibát szeretné kiküszöbölni: a merevlemezek BIOS és lemez önmaga által ismert geometriai beállításainak egyeztetése.</p></div><div class=paragraph><p>A "lemezgeometria" fogalma tulajdonképpen már egy elavult fogalom, de a PC-k BIOS-a legbelül még mind a mai napig így kommunikál a lemezekkel. Amikor a FreeBSD telepítõjével slice-okat hozunk létre, olyan módon kell rögzítenünk a lemezre ezek pozícióját, hogy a BIOS képes legyen megtalálni. Ha ez nem sikerül, akkor nem tudjuk elindítani a rendszert.</p></div><div class=paragraph><p>A "veszélyesen dedikált" mód ezt a problémát az egyszerûsítésén keresztül próbálja megoldani, és néha sikerül is neki. Ezt azonban csak akkor javasoljuk, ha semmi más nem mûködik, hiszen az esetek túlnyomó részében más megoldás is létezik.</p></div><div class=paragraph><p>Hogy tudjuk tehát akkor elkerülni a "veszélyesen dedikált" mód használatát a telepítés során? Jegyezzük fel, hogy mik a BIOS szerint a merevlemezünk geometriai beállításai. Ezt a rendszerindítás közben a rendszermagtól is megkérdezhetjük úgy, hogy a <code>boot:</code> paranccsorába megadjuk a <code>-v</code> beállítást, vagy a betöltõben a <code>boot -v</code> parancsot használjuk. Így pontosan a telepítõ indítása elõtt a rendszermag ki fogja írni a BIOS által ismert geometriai beállításokat. Ne essünk pánikba, várjuk meg, amíg a telepítõ elindul, tekerjünk vissza a számokhoz és olvassuk le ezeket. A lemezek általában a BIOS sorrendjében jelennek meg, tehát elõször az IDE aztán a SCSI típusúak.</p></div><div class=paragraph><p>A lemez partícionálásakor ellenõrizzük, hogy az FDISK képernyõjén megjelenõ geometriai beállítások megfelelõek (tehát egyeznek a BIOS által ismert értékekkel). Ha eltérést tapasztalunk, akkor a <kbd>G</kbd> billentyû lenyomásával tudjuk átjavítani. Erre leginkább akkor lesz szükségünk, ha a lemez teljesen üres, vagy ha a lemezt egy másik rendszerbõl hoztuk át. Ez egyébként csak azoknál a lemezeknél okoz gondot, amelyekrõl a rendszert akarjuk indítani, a FreeBSD a többi lemezzel már remekül elboldogul.</p></div><div class=paragraph><p>Miután sikerült egyeztetnünk a BIOS és a FreeBSD geometriai beállításait, szinte biztos, hogy nem kell már emiatt aggódnunk, így a "veszélyesen dedikált" módra sincs szükségünk. Ha viszont mégis egy <code>read error</code> hibaüzenetet kapnánk a rendszer indítása közben, akkor tegyünk egy próbát. Semmit sem veszíthetünk.</p></div><div class=paragraph><p>Ha a "veszélyesen dedikált" mód használatáról szeretnénk visszatérni a megszokottra, akkor két lehetõségünk van. Elõször is teljesen le kell nulláznunk az MBR-t, így biztosra vehetjük, hogy az ezután következõ telepítések során egy teljesen üres lemezt látunk. Ezt például így lehet megtenni:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dd if=/dev/zero of=/dev/rda0 count=15</span></code></pre></div></div><div class=paragraph><p>A másik módszer egy hivatalosan nem dokumentált DOS-os "lehetõség" használata:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>C:<span class=se>\&gt;</span> fdisk /mbr</code></pre></div></div><div class=paragraph><p>Ezzel egy új Master Boot Recordot tudunk telepíteni, ami ezzel együtt felülírja a BSD rendszertöltõjét is.</p></div></div><div class=sect2><h3 id=_milyen_partíciókon_lehet_soft_updatest_használni_a_soft_updates_állítólag_nem_mûködik_rendesen_a_gyökérpartíció_esetén>9.4. Milyen partíciókon lehet Soft Updatest használni? A Soft Updates állítólag nem mûködik rendesen a gyökérpartíció esetén.<a class=anchor href=#_milyen_partíciókon_lehet_soft_updatest_használni_a_soft_updates_állítólag_nem_mûködik_rendesen_a_gyökérpartíció_esetén></a></h3><div class=paragraph><p>A rövid válasz: A Soft Updates bármelyik partíción minden további nélkül használható.</p></div><div class=paragraph><p>A hosszabb válasz: Korábban voltak bizonyos kétségek afelõl, hogy a Soft Updates jól mûködik a rendszerindító partíciókon is. Ez alapvetõen a Soft Updates két jellemzõjére vezethetõ vissza. Elõször is, a Soft Updatest alkalmazó partíciók esetén elõfordulhat, hogy a rendszerösszeomlás során elveszik valamennyi adat (maga a partíció nem lesz hibás, csupán némi adat tûnik el), illetve a Soft Updates ideiglenesen kifogyhat a tárhelybõl.</p></div><div class=paragraph><p>A Soft Updates használata során a rendszermag legfeljebb harminc másodperc múlva írja ki fizikailag a változtatásokat a lemezre. Tehát amikor egy nagyobb állományt törlünk, akkor ez az állomány egészen addig a lemezen marad, amíg a rendszermag ténylegesen el nem végzi ezt a törlést. Ezzel viszont nagyon egyszerûen létrehozható egy "ütközés" (race condition) az állományrendszeren. Tegyük fel, hogy letörlünk egy nagyobb állományt és utána közvetlenül létrehozunk egy másik nagyobb állományt. Mivel az elsõ állomány ilyenkor még nem törlõdik le valójában a lemezrõl, ezért a második számára már nem lesz elegendõ helyünk. A rendszer ekkor egy hibaüzenetben fog figyelmeztetni minket, miközben pontosan az imént töröltünk le egy óriási állományt! Ha néhány másodperccel késõbb újra megpróbáljuk létrehozni ezt az állományt, akkor már minden a megfelelõ módon fog zajlani. Ezt régebben sok FreeBSD felhasználó nem tudta mire vélni.</p></div><div class=paragraph><p>Ha a rendszerünk olyankor omlik össze, amikor a rendszermag már elkezdte egy nagyobb mennyiségû adat kiírását a lemezre, de még nem fejezõdött be, akkor könnyen elõfordulhat, hogy ez az adat elveszik vagy meghibásodik. Ennek kockázata nagyon kicsi, és általában kezelhetõ, viszont az IDE-meghajtókban található írási gyorsítótár használata jelentõsen növeli ezt. Ezért a Soft Updates alkalmazása során nem javasoljuk ennek használatát.</p></div><div class=paragraph><p>Ezek a problémák az összes Soft Updates partíciót veszélyeztetik. Mennyiben vonatkoznak viszont ezek a gyökérpartícióra?</p></div><div class=paragraph><p>A gyökérpartíción nagyon ritkán változnak fontos információk. A <span class=filename>/boot/kernel/kernel</span> és az <span class=filename>/etc</span> egyedül a rendszer karbantartása során frissül, vagy például amikor a felhasználók jelszót változtatnak. Ha a rendszer egy ilyen változtatás harminc másodperces idején belül omlik össze, akkor megvan rá az esélyünk, hogy elvesznek az adataink. Ez a kockázat a legtöbb alkalmazás számára elfogadható, de semmiképpen sem szabad figyelmen kívül hagynunk. Ha a rendszerünk nem képes vállalni még ennyi kockázatot sem, akkor a rendszerindító partíción tiltsuk le a Soft Updates használatát!</p></div><div class=paragraph><p>A gyökérpartíció hagyományosan az egyik legkisebb partíció. Ha viszont az ideiglenes állományok tárolására szánt <span class=filename>/tmp</span> könyvtárat is ezen belülre tesszük és gyakran használjuk, akkor ebbõl idõszakosan tárhelyproblémáink adódhatnak. Könnyen megoldhatjuk azonban ezt a problémát, ha a <span class=filename>/tmp</span> könyvtárhoz létrehoznunk egy szimbolikus linket a <span class=filename>/var/tmp</span> könyvtárra.</p></div></div><div class=sect2><h3 id=_mi_történt_a_ccd4_eszközzel>9.5. Mi történt a <a href="https://man.freebsd.org/cgi/man.cgi?query=ccd&amp;sektion=4&amp;format=html">ccd(4)</a> eszközzel?<a class=anchor href=#_mi_történt_a_ccd4_eszközzel></a></h3><div class=paragraph><p>A hibajelenség:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ccdconfig -C</span>
ccdconfig: ioctl <span class=o>(</span>CCDIOCSET<span class=o>)</span>: /dev/ccd0c: Inappropriate file <span class=nb>type </span>or format</code></pre></div></div><div class=paragraph><p>Ez általában olyankor történik, amikor olyan <code>c</code> partíciókat próbálunk meg összefûzni, amelyek alapértelmezés szerint <code>unused</code> ("nem használt") típusúak. A <a href="https://man.freebsd.org/cgi/man.cgi?query=ccd&amp;sektion=4&amp;format=html">ccd(4)</a> meghajtó azonban megköveteli, hogy az érintett partíciók <code>FS_BSDFFS</code> típusúak legyenek. Szerkesszük át a lemezeken található címkéket és változtassuk meg a partíciók típusát a <code>4.2BSD</code> értékre.</p></div></div><div class=sect2><h3 id=_miért_nem_lehet_a_ccd4_eszköz_lemezcímkéjét_szerkeszteni>9.6. Miért nem lehet a <a href="https://man.freebsd.org/cgi/man.cgi?query=ccd&amp;sektion=4&amp;format=html">ccd(4)</a> eszköz lemezcímkéjét szerkeszteni?<a class=anchor href=#_miért_nem_lehet_a_ccd4_eszköz_lemezcímkéjét_szerkeszteni></a></h3><div class=paragraph><p>A hibajelenség:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># disklabel ccd0</span>
<span class=o>(</span>itt valami gondot ír ki, ezért megpróbáljuk szerkeszteni a címkét<span class=o>)</span>
<span class=c># disklabel -e ccd0</span>
<span class=o>(</span>edit, save, quit<span class=o>)</span>
disklabel: ioctl DIOCWDINFO: No disk label on disk<span class=p>;</span>
use <span class=s2>&#34;disklabel -r&#34;</span> to <span class=nb>install </span>initial label</code></pre></div></div><div class=paragraph><p>Ezt általában azért kapjuk, mert a <a href="https://man.freebsd.org/cgi/man.cgi?query=ccd&amp;sektion=4&amp;format=html">ccd(4)</a> által visszaadott lemezcímke valójában "nem létezik" a lemezen. Ezen úgy tudunk segíteni, ha explicit módon visszaírjuk, valahogy így:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># disklabel ccd0 &gt; /tmp/lemezcimke.tmp</span>
<span class=c># disklabel -Rr ccd0 /tmp/lemezcimke.tmp</span>
<span class=c># disklabel -e ccd0</span>
<span class=o>(</span>most már működni fog<span class=o>)</span></code></pre></div></div></div><div class=sect2><h3 id=_lehet_más_operációs_rendszerek_állományrendszerét_is_csatlakoztatni_freebsd_alatt>9.7. Lehet más operációs rendszerek állományrendszerét is csatlakoztatni FreeBSD alatt?<a class=anchor href=#_lehet_más_operációs_rendszerek_állományrendszerét_is_csatlakoztatni_freebsd_alatt></a></h3><div class=paragraph><p>A FreeBSD több más állományrendszert is ismer.</p></div><div class=dlist><dl><dt class=hdlist1>UFS</dt><dd><p>Az UFS formátumú CD-k FreeBSD alatt közvetlenül csatlakoztathatóak. A Digital UNIX és más rendszerek UFS partícióit nem már annyira könnyû csatlakoztatni, ez leginkább a kérdéses operációs rendszer partícionálási megoldásaitól függ.</p></dd><dt class=hdlist1>ext2/ext3</dt><dd><p>A FreeBSD támogatja az <code>ext2fs</code> és <code>ext3fs</code> partíciókat. Errõl bõvebben lásd a <a href="https://man.freebsd.org/cgi/man.cgi?query=mount_ext2fs&amp;sektion=8&amp;format=html">mount_ext2fs(8)</a> man oldalt.</p></dd><dt class=hdlist1>NTFS</dt><dd><p>A FreeBSD csak olvasni képes az NTFS partíciókat. Ezzel kapcsolatban a <a href="https://man.freebsd.org/cgi/man.cgi?query=mount_ntfs&amp;sektion=8&amp;format=html">mount_ntfs(8)</a> man oldalán találunk részletesebb információkat. Az írhatóság használatához az <a href=http://www.tuxera.com/community/>ntfs-3g</a> portolt változatát javasoljuk (lásd <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/fusefs-ntfs/>sysutils/fusefs-ntfs</a>).</p></dd><dt class=hdlist1>FAT</dt><dd><p>A FreeBSD egyaránt képes írni és olvasni a FAT típusú partíciókat. Errõl a <a href="https://man.freebsd.org/cgi/man.cgi?query=mount_msdosfs&amp;sektion=8&amp;format=html">mount_msdosfs(8)</a> man oldalán tudhatunk meg többet.</p></dd><dt class=hdlist1>ReiserFS</dt><dd><p>A FreeBSD tudja olvasni a ReiserFS partíciókat. Ezt a <a href="https://man.freebsd.org/cgi/man.cgi?query=mount_reiserfs&amp;sektion=8&amp;format=html">mount_reiserfs(8)</a> man oldalon olvashatjuk.</p></dd><dt class=hdlist1>ZFS</dt><dd><p>A FreeBSD jelen pillanatban a Sun™ ZFS meghajtójának átiratát is tartalmazza. Jelenleg azonban csak elegendõ memóriával rendelkezõ amd64 platformokon javasoljuk a használatát. Részletesebb információkért lásd a <a href="https://man.freebsd.org/cgi/man.cgi?query=zfs&amp;sektion=8&amp;format=html">zfs(8)</a> man oldalt.</p></dd></dl></div><div class=paragraph><p>A FreeBSD hálózati állományrendszereket is támogat, többek közt az NFS-t (lásd <a href="https://man.freebsd.org/cgi/man.cgi?query=mount_nfs&amp;sektion=8&amp;format=html">mount_nfs(8)</a>), a NetWare-t (lásd <a href="https://man.freebsd.org/cgi/man.cgi?query=mount_nwfs&amp;sektion=8&amp;format=html">mount_nwfs(8)</a>), és Microsoft-féle SMB állományrendszereket (lásd <a href="https://man.freebsd.org/cgi/man.cgi?query=mount_smbfs&amp;sektion=8&amp;format=html">mount_smbfs(8)</a>). Más egyéb FUSE-alapú állományrendszer (<a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/fusefs-kmod/>sysutils/fusefs-kmod</a>) támogatását is megtalálhatjuk a portok között.</p></div></div><div class=sect2><h3 id=_hogyan_lehet_másodlagos_logikai_dos_partíciókat_csatlakoztatni>9.8. Hogyan lehet másodlagos (logikai) DOS partíciókat csatlakoztatni?<a class=anchor href=#_hogyan_lehet_másodlagos_logikai_dos_partíciókat_csatlakoztatni></a></h3><div class=paragraph><p>A logikai DOS partíciók az elsõdleges partíciók <em>után</em> találhatóak. Például, ha van egy "E" betûjelû logikai partíciónk a második SCSI-meghajtónkon, akkor lennie kell egy "ötödik slice-nak" a <span class=filename>/dev</span> könyvtárban, amelyet majd csatlakoztatni tudunk:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount -t msdosfs /dev/da1s5 /dos/e</span></code></pre></div></div></div><div class=sect2><h3 id=_használható_titkosított_állományrendszer_freebsd_alatt>9.9. Használható titkosított állományrendszer FreeBSD alatt?<a class=anchor href=#_használható_titkosított_állományrendszer_freebsd_alatt></a></h3><div class=paragraph><p>Igen. Erre a célra a <a href="https://man.freebsd.org/cgi/man.cgi?query=gbde&amp;sektion=8&amp;format=html">gbde(8)</a> és a <a href="https://man.freebsd.org/cgi/man.cgi?query=geli&amp;sektion=8&amp;format=html">geli(8)</a> is tökéletesen alkalmas. A részleteket lásd a FreeBSD kézikönyv <a href=https://docs.freebsd.org/hu/books/handbook/disks/#disks-encrypting>A lemezpartíciók titkosítása</a> címû fejezetében.</p></div></div><div class=sect2><h3 id=_a_windows_nt_rendszertöltõjével_is_el_lehet_indítani_a_freebsd_t>9.10. A Windows NT® rendszertöltõjével is el lehet indítani a FreeBSD-t?<a class=anchor href=#_a_windows_nt_rendszertöltõjével_is_el_lehet_indítani_a_freebsd_t></a></h3><div class=paragraph><p>Ehhez tulajdonképpen csak annyit kell csinálnunk, hogy átmásoljuk a FreeBSD rendszerindító partíciójának az elsõ szektorát egy állományba a DOS/Windows NT® partíción belül. Legyen ez például a <span class=filename>C:\BOOTSECT.BSD</span> állomány (a <span class=filename>C:\BOOTSECT.DOS</span> mintájára), amelyhez aztán így igazítjuk a <span class=filename>c:\boot.ini</span> állományt:</p></div><div class="literalblock programlisting"><div class=content><pre>[boot loader]
timeout=30
default=multi(0)disk(0)rdisk(0)partition(1)\WINDOWS
[operating systems]
multi(0)disk(0)rdisk(0)partition(1)\WINDOWS=&#34;Windows NT&#34;
C:\BOOTSECT.BSD=&#34;FreeBSD&#34;
C:\=&#34;DOS&#34;</pre></div></div><div class=paragraph><p>Ha a FreeBSD ugyanazon a lemezen található, ahonnan a Windows NT® is indul, akkor egyszerûen csak másoljuk át a <span class=filename>/boot/boot1</span> állományt <span class=filename>C:\BOOTSECT.BSD</span> néven. Ha viszont a FreeBSD egy másik lemezen található, akkor a <span class=filename>/boot/boot1</span> önmagában már nem elegendõ, hanem helyette a <span class=filename>/boot/boot0</span> állományra lesz szükségünk.</p></div><div class=paragraph><p>A <span class=filename>/boot/boot0</span> állományt a <a href="https://man.freebsd.org/cgi/man.cgi?query=sysinstall&amp;sektion=8&amp;format=html">sysinstall(8)</a> használatával kell telepíteni abból a menübõl, ahol a FreeBSD boot managerét kell kiválasztani. Erre azért van szükség, mert a <span class=filename>/boot/boot0</span> állományon belül a partíciós tábla teljesen üres, azonban a <a href="https://man.freebsd.org/cgi/man.cgi?query=sysinstall&amp;sektion=8&amp;format=html">sysinstall(8)</a> át fogja másolni a partíciós táblát mielõtt a <span class=filename>/boot/boot0</span> állományt az MBR-be tenné.</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p><em>Ne másoljunk át csak úgy egyszerûen a <span class=filename>/boot/boot0</span> állományt a <span class=filename>/boot/boot1</span> helyett! Ezzel felülíródik a partíciós táblánk és így a számítógépet nem tudjuk elindítani!</em></p></div></td></tr></tbody></table></div><div class=paragraph><p>Amikor a FreeBSD boot managere lefut, az utoljára indított operációs rendszert a partíciós táblában aktívként jelöli meg (ezzel lényegében megjegyzi), majd ezután beírja magát az MBR-be. Emiatt, hogy ha csak egyszerûen átmásoljuk a <span class=filename>/boot/boot0</span> állományt a <span class=filename>C:\BOOTSECT.BSD</span> állományba, akkor csak egy egyetlen aktív bejegyzést tartalmazó üres partíciós táblát fog visszaírni az MBR-be.</p></div></div><div class=sect2><h3 id=_a_lilo_ból_hogyan_lehet_freebsd_t_és_linuxot_is_indítani>9.11. A LILO-ból hogyan lehet FreeBSD-t és Linuxot is indítani?<a class=anchor href=#_a_lilo_ból_hogyan_lehet_freebsd_t_és_linuxot_is_indítani></a></h3><div class=paragraph><p>Ha a FreeBSD és a Linux® is ugyanazon a lemezen helyezkedik el, akkor nincs más teendõnk, mint követni a LILO telepítési útmutatójában a nem-Linux® típusú operációs rendszerek indítására vonatkozó utasításokat. Ezek röviden összefoglalva a következõk:</p></div><div class=paragraph><p>Indítsuk el a Linuxot és vegyük fel a következõ sort az <span class=filename>/etc/lilo.conf</span> állományba:</p></div><div class="literalblock programlisting"><div class=content><pre>other=/dev/hda2
        table=/dev/hda
        label=FreeBSD</pre></div></div><div class=paragraph><p>(A fentiekben feltételeztük, hogy a FreeBSD-t tartalmazó slice a Linux® számára <span class=filename>/dev/hda2</span> néven érhetõ el. Ez természetesen a saját konfigurációnkhoz kell szabni.) Ezután egyszerûen csak futtassuk le a <code>lilo</code> parancsot <code>root</code> felhasználóként és már készen is vagyunk.</p></div><div class=paragraph><p>Ha a FreeBSD egy másik lemezen található, akkor a <code>loader=/boot/chain.b</code> LILO-bejegyzést kell használnunk. Például:</p></div><div class="literalblock programlisting"><div class=content><pre>other=/dev/dab4
        table=/dev/dab
        loader=/boot/chain.b
        label=FreeBSD</pre></div></div><div class=paragraph><p>Bizonyos helyzetekben elõfordulhat, hogy a FreeBSD rendszertöltõjének át kell adnunk a meghajtó BIOS szerinti sorszámát, mert csak így tudjuk rendesen elindítani a második lemezrõl. Például, ha a FreeBSD szerint a SCSI-lemezünk a BIOS-ban az 1-es lemez, akkor ezt kell megadnunk a FreeBSD rendszertöltõjének:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Boot: 1:da<span class=o>(</span>0,a<span class=o>)</span>/boot/kernel/kernel</code></pre></div></div><div class=paragraph><p>A <a href="https://man.freebsd.org/cgi/man.cgi?query=boot&amp;sektion=8&amp;format=html">boot(8)</a> beállítható úgy, hogy a rendszer indításakor automatikusan mindig ezt a beállítást használja.</p></div><div class=paragraph><p>A FreeBSD és Linux® együttes használatáról további részleteket a <a href=http://tldp.org/HOWTO/Linux+FreeBSD.html>Linux®+FreeBSD mini-HOWTO</a> címû írásból tudhatunk meg.</p></div></div><div class=sect2><h3 id=_hogyan_lehet_a_grub_használatával_freebsd_t_és_linuxot_is_indítani>9.12. Hogyan lehet a GRUB használatával FreeBSD-t és Linuxot is indítani?<a class=anchor href=#_hogyan_lehet_a_grub_használatával_freebsd_t_és_linuxot_is_indítani></a></h3><div class=paragraph><p>A FreeBSD-t nagyon könnyû elindítani a GRUB segítségével. Ehhez csupán annyit kell tennünk, hogy felvesszük a következõ sorokat a GRUB konfigurációs állományába (<span class=filename>/boot/grub/menu.lst</span>, vagy bizonyos, például Red Hat-típusú rendszerekben a <span class=filename>/boot/grub/grub.conf</span>):</p></div><div class="literalblock programlisting"><div class=content><pre>title FreeBSD 6.1
	root (hd0,a)
	kernel /boot/loader</pre></div></div><div class=paragraph><p>Itt a <em>hd0,a</em> az elsõ lemezen található rendszerindító partícióra mutat. Ha a lemezen belül a slice számát is szeretnénk megadni, akkor írhatjuk így is: <em>(hd0,2,a)</em>. Ha ezt nem adjuk meg, akkor a GRUB alapértelmezés szerint a lemezen levõ elsõ <code>a</code> partícióval rendelkezõ slice-ot keresi meg.</p></div></div><div class=sect2><h3 id=_hogyan_lehet_a_booteasy_használatával_elindítani_a_freebsd_t_és_a_linuxot>9.13. Hogyan lehet a BootEasy használatával elindítani a FreeBSD-t és a Linuxot?<a class=anchor href=#_hogyan_lehet_a_booteasy_használatával_elindítani_a_freebsd_t_és_a_linuxot></a></h3><div class=paragraph><p>A LILO-t ne a Master Boot Recordba, hanem a linuxos partíciónk elejére telepítsük. Ezután a BootEasybõl már el tudjuk indítani a LILO-t.</p></div><div class=paragraph><p>Abban az esetben is ezt javasoljuk, ha Windows® és Linux® is van a gépünkön, mivel így szintén egyszerûbb lesz elindítani a Linuxot, ha netalán valamikor újra kellene telepíteni a Windows®-t (ami viszont egy "irigy" operációs rendszer, mert nem tûr meg semmilyen más operációs rendszert maga mellett a Master Boot Recordban).</p></div></div><div class=sect2><h3 id=_a_rendszerindításkor_látható_hogyan_írható_át_valami_értelmesre>9.14. A rendszerindításkor látható ??? hogyan írható át valami értelmesre?<a class=anchor href=#_a_rendszerindításkor_látható_hogyan_írható_át_valami_értelmesre></a></h3><div class=paragraph><p>Ez az szabványos boot managerrel csak úgy lehet megoldani, ha újratelepítjük. A portok között viszont a <span class=filename>sysutils</span> kategóriában rengeteg olyan más boot managert találhatunk, amely tud ilyet is.</p></div></div><div class=sect2><h3 id=_cserélhetõ_lemezes_meghajtókat_hogyan_lehet_használni>9.15. Cserélhetõ lemezes meghajtókat hogyan lehet használni?<a class=anchor href=#_cserélhetõ_lemezes_meghajtókat_hogyan_lehet_használni></a></h3><div class=paragraph><p>Legyen az akár egy Zip®, EZ drive meghajtó (esetleg egy floppy, ha így akarjuk használni), vagy éppen egy új merevlemez, miután már telepítettük és felismerte a rendszert, illetve behelyeztük a lemezt, kártyát vagy akármit, minden esetben szinte ugyanaz a teendõ.</p></div><div class=paragraph><p>(Ez a válasz leginkább Mark Mayo <a href=http://www.vmunix.com/mark/FreeBSD/ZIP-FAQ.html>ZIP GYIK</a> címû írásán alapszik.)</p></div><div class=paragraph><p>Ha tehát egy ZIP meghajtóról vagy floppylemezrõl beszélünk, amelyen egy DOS-os állományrendszer található, akkor azt parancssorból így érhetjük el, ha floppy:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount -t msdosfs /dev/fd0c /floppy</span></code></pre></div></div><div class=paragraph><p>vagy így, ha egy gyári beállításokkal rendelkezõ ZIP-lemez:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount -t msdosfs /dev/da2s4 /zip</span></code></pre></div></div><div class=paragraph><p>A többi lemez esetén a <a href="https://man.freebsd.org/cgi/man.cgi?query=fdisk&amp;sektion=8&amp;format=html">fdisk(8)</a> vagy a <a href="https://man.freebsd.org/cgi/man.cgi?query=sysinstall&amp;sektion=8&amp;format=html">sysinstall(8)</a> segítségével nézzük meg, hogy milyen partíciók és hogyan találhatóak meg rajtuk.</p></div><div class=paragraph><p>A következõ példákban egy <span class=filename>da2</span> eszközként, vagyis egy harmadik SCSI-lemezként megjelenõ ZIP-meghajtót fogunk használni.</p></div><div class=paragraph><p>Hacsak nem floppyval van dolgunk, illetve nem tervezzük másoknak is odaadni a cserélhetõ médiumot, akkor érdemes inkább BSD típusú állományrendszert telepíteni rá. Így támogatottak lesznek a hosszú állománynevek, és legalább egy kétszer gyorsabb és egy sokkal megbízhatóbb megoldást kapunk. Ehhez elõször is le kell szednünk a DOS-szintû partíciókat és állományrendszereket. Erre a célra egyaránt megfelel a <a href="https://man.freebsd.org/cgi/man.cgi?query=fdisk&amp;sektion=8&amp;format=html">fdisk(8)</a> vagy a <a href="https://man.freebsd.org/cgi/man.cgi?query=sysinstall&amp;sektion=8&amp;format=html">sysinstall(8)</a>, illetve kisebb lemezek esetén valószínûleg nem is lesz szükségünk több operációs rendszer támogatására, így aztán közvetlenül is törülhetjük ezeket:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dd if=/dev/zero of=/dev/rda2 count=2</span>
<span class=c># disklabel -Brw da2 auto</span></code></pre></div></div><div class=paragraph><p>A <a href="https://man.freebsd.org/cgi/man.cgi?query=disklabel&amp;sektion=8&amp;format=html">disklabel(8)</a> vagy a <a href="https://man.freebsd.org/cgi/man.cgi?query=sysinstall&amp;sektion=8&amp;format=html">sysinstall(8)</a> használatával ezután létre tudunk hozni BSD típusú partíciókat. Valószínûleg erre lesz szükségünk, ha lapozóállományt is tenni akarunk a lemezre, noha ennek nem sok értelme van például egy ZIP-meghajtó esetén.</p></div><div class=paragraph><p>Végezetül hozzunk létre egy új állományrendszert. Itt most ez egész ZIP-lemezen egyetlen partíció lesz:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># newfs /dev/rda2c</span></code></pre></div></div><div class=paragraph><p>Csatlakoztassuk:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount /dev/da2c /zip</span></code></pre></div></div><div class=paragraph><p>Emellett még hasznos lehet felvenni hozzá egy sort az <span class=filename>/etc/fstab</span> állományba is (lásd <a href="https://man.freebsd.org/cgi/man.cgi?query=fstab&amp;sektion=5&amp;format=html">fstab(5)</a>), így a jövõben elegendõ csak a <code>mount /zip</code> parancsot kiadnunk a csatlakoztatásához:</p></div><div class="literalblock programlisting"><div class=content><pre>/dev/da2c /zip ffs rw,noauto 0 0</pre></div></div></div><div class=sect2><h3 id=_miért_ad_a_rendszer_incorrect_super_block_hibát_cd_k_csatlakoztatásánál>9.16. Miért ad a rendszer Incorrect super block hibát CD-k csatlakoztatásánál?<a class=anchor href=#_miért_ad_a_rendszer_incorrect_super_block_hibát_cd_k_csatlakoztatásánál></a></h3><div class=paragraph><p>Fel kell világosítanunk a <a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a> parancsot a csatlakoztatandó eszköz típusáról. Errõl a <a href=https://docs.freebsd.org/hu/books/handbook/disks/#creating-cds>kézikönyv lézeres tárolóeszközökrõl szóló részében</a> olvashatunk, innen is különösen a <a href=https://docs.freebsd.org/hu/books/handbook/disks#mounting-cd>Adat CD-k használata</a> címû szakaszt ajánljuk.</p></div></div><div class=sect2><h3 id=_miért_ad_a_rendszer_device_not_configured_hibaüzenetet_cd_k_csatlakoztatásakor>9.17. Miért ad a rendszer Device not configured hibaüzenetet CD-k csatlakoztatásakor?<a class=anchor href=#_miért_ad_a_rendszer_device_not_configured_hibaüzenetet_cd_k_csatlakoztatásakor></a></h3><div class=paragraph><p>Ez általában arra utal, hogy nincs CD a meghajtóban, vagy a meghajtó nem érhetõ el a buszon. Ezzel kapcsolatban a kézikönyv <a href=https://docs.freebsd.org/hu/books/handbook/disks#mounting-cd>Adat CD-k használata</a> címû szakaszát javasoljuk elolvasásra.</p></div></div><div class=sect2><h3 id=_miért_jelenik_meg_az_összes_nemzeti_karakter_helyén_amikor_freebsd_alatt_csatlakoztatunk_egy_cd_t>9.18. Miért jelenik meg az összes nemzeti karakter helyén ?, amikor FreeBSD alatt csatlakoztatunk egy CD-t?<a class=anchor href=#_miért_jelenik_meg_az_összes_nemzeti_karakter_helyén_amikor_freebsd_alatt_csatlakoztatunk_egy_cd_t></a></h3><div class=paragraph><p>A CD-n valószínûleg a "Joliet" kiterjesztés használatával tárolják az állományok és könyvtárak adatait. Erre vonatkozóan a kézikönyvben a <a href=https://docs.freebsd.org/hu/books/handbook/disks/#creating-cds>Lézeres tárolóeszközök (CD-k) létrehozása és használata</a> címû rész elolvasását javasoljuk, különös tekintettel az <a href=https://docs.freebsd.org/hu/books/handbook/disks#mounting-cd>Adat CD-k használata</a> címû szakaszra.</p></div></div><div class=sect2><h3 id=_a_freebsd_alatt_készített_cd_ket_nem_lehet_más_operációs_rendszerekkel_olvasni_miért_nem>9.19. A FreeBSD alatt készített CD-ket nem lehet más operációs rendszerekkel olvasni. Miért nem?<a class=anchor href=#_a_freebsd_alatt_készített_cd_ket_nem_lehet_más_operációs_rendszerekkel_olvasni_miért_nem></a></h3><div class=paragraph><p>Ez minden bizonnyal abból fakad, hogy nem egy ISO 9660 állományrendszert vettük fel rá, hanem közvetlenül maguk az állományokat. Olvassuk el a kézikönyvben a <a href=https://docs.freebsd.org/hu/books/handbook/disks/#creating-cds>Lézeres tárolóeszközök (CD-k) létrehozása és használata</a> címû fejezetet, de különösen a <a href=https://docs.freebsd.org/hu/books/handbook/disks/#RAWDATA-CD#creating-cds>Nyers adat CD-k írása</a> címû részt.</p></div></div><div class=sect2><h3 id=_hogyan_lehet_lementeni_egy_adat_cd_tartalmát_a_merevlemezre>9.20. Hogyan lehet lementeni egy adat CD tartalmát a merevlemezre?<a class=anchor href=#_hogyan_lehet_lementeni_egy_adat_cd_tartalmát_a_merevlemezre></a></h3><div class=paragraph><p>Errõl a kézikönyvben találunk hasznos információkat, azon belül is az <a href=https://docs.freebsd.org/hu/books/handbook/disks#imaging-cd>Adat CD-k másolása</a> címû szakaszban. A CD-kkel végezhetõ további mûveletekrõl a kézikönyv <a href=https://docs.freebsd.org/hu/books/handbook/disks/#creating-cds>Lézeres tárolóeszközök (CD-k) létrehozása és használata</a> címû részében találhatunk részletes útmutatásokat.</p></div></div><div class=sect2><h3 id=_miért_nem_lehet_audio_cd_ket_csatlakoztatni_a_mount_paranccsal>9.21. Miért nem lehet audio CD-ket csatlakoztatni a mount paranccsal?<a class=anchor href=#_miért_nem_lehet_audio_cd_ket_csatlakoztatni_a_mount_paranccsal></a></h3><div class=paragraph><p>Ha zenei CD-ket próbálunk meg csatlakoztatni, akkor például egy <code>cd9660: /dev/acd0c: Invalid argument</code> hibát fogunk kapni a rendszertõl. Ez azért történik, mert a <code>mount</code> parancs csak állományrendszerekkel használható. A zenei CD-ken viszont semmilyen állományrendszer nincs, egyszerûen csak maga az adat. Az olvasásukhoz olyan programra lesz szükségünk, amely képes zenei CD-kkel dolgozni, mint például az <a class=package href=https://cgit.freebsd.org/ports/tree/audio/xmcd/>audio/xmcd</a> port.</p></div></div><div class=sect2><h3 id=_hogyan_lehet_többmenetes_multisession_cd_ket_csatlakoztatni_a_mount_paranccsal>9.22. Hogyan lehet többmenetes (multisession) CD-ket csatlakoztatni a mount paranccsal?<a class=anchor href=#_hogyan_lehet_többmenetes_multisession_cd_ket_csatlakoztatni_a_mount_paranccsal></a></h3><div class=paragraph><p>A <a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a> alapértelmezés szerint az CD-n található utolsó adatsávot (menetet, vagy sessiont) próbálja meg olvasni. Ha viszont egy korábbi menetet szeretnénk vele betöltetni, akkor erre használjuk a <code>-s</code> paranccsori paramétert. Erre a <a href="https://man.freebsd.org/cgi/man.cgi?query=mount_cd9660&amp;sektion=8&amp;format=html">mount_cd9660(8)</a> man oldalon találhatunk különbözõ példákat.</p></div></div><div class=sect2><h3 id=_hogyan_képesek_az_egyszerû_felhasználók_floppykat_cd_ket_és_más_egyéb_cserélhetõ_lemezes_eszközöket_használni>9.23. Hogyan képesek az egyszerû felhasználók floppykat, CD-ket és más egyéb cserélhetõ lemezes eszközöket használni?<a class=anchor href=#_hogyan_képesek_az_egyszerû_felhasználók_floppykat_cd_ket_és_más_egyéb_cserélhetõ_lemezes_eszközöket_használni></a></h3><div class=paragraph><p>A normál felhasználók számára engedélyezni tudjuk az eszközök csatlakoztatását. Íme:</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p><code>root</code> felhasználóként állítsuk be a <code>vfs.usermount</code> sysctl változót az <code>1</code> értékre:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl -w vfs.usermount=1</span></code></pre></div></div></li><li><p>A cserélhetõ eszközöket képviselõ eszközleírókra állítsuk be <code>root</code> felhasználóként a megfelelõ engedélyeket.</p><div class=paragraph><p>Például a felhasználóknak így tudjuk engedélyezni az elsõ floppymeghajtó használatát:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># chmod 666 /dev/fd0</span></code></pre></div></div><div class=paragraph><p>Az <code>operator</code> csoportban levõ felhasználók pedig így fognak tudni CD-ket csatlakoztatni:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># chgrp operator /dev/acd0c</span>
<span class=c># chmod 640 /dev/acd0c</span></code></pre></div></div></li><li><p>Fel kell vennünk ezeket a módosításokat az <span class=filename>/etc/devfs.conf</span> állományba is, mivel csak így maradnak meg a következõ rendszerindítás után.</p><div class=paragraph><p>Ehhez <code>root</code> felhasználóként a vegyük fel a megfelelõ sorokat az <span class=filename>/etc/devfs.conf</span> állományba. Például, ha a felhasználóknak engedélyezni akarjuk az elsõ floppymeghajtó használatát, akkor:</p></div><div class="literalblock programlisting"><div class=content><pre># Bármelyik felhasználó képes floppykat csatlakoztatni.
own       /dev/fd0	  root:operator
perm	  /dev/fd0	  0666</pre></div></div><div class=paragraph><p>Így engedélyezhetjük az <code>operator</code> csoport tagjainak a CD-k csatlakoztatását:</p></div><div class="literalblock programlisting"><div class=content><pre># Az operator csoport tagjai csatlakoztathatnak CD-ket.
own       /dev/acd0	  root:operator
perm	  /dev/acd0	  0660</pre></div></div></li><li><p>Végezetül tegyük a <code>vfs.usermount=1</code> sort az <span class=filename>/etc/sysctl.conf</span> állományba, így a rendszer következõ indításakor is megmarad ez a beállítás.</p></li></ol></div></div></div><div class=paragraph><p>Most már mindegyik felhasználó képes csatlakoztatni a <span class=filename>/dev/fd0</span> eszközleírón keresztül elérhetõ lemezt a saját könyvtárába:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>mkdir</span> ~/az-én-csatlakozási-pontom
% mount <span class=nt>-t</span> msdosfs /dev/fd0 ~/az-én-csatlakozási-pontom</code></pre></div></div><div class=paragraph><p>A <code>operator</code> csoport tagjai is képesek most már az <span class=filename>/dev/acd0c</span> eszközleírón keresztül elérhetõ CD-ket csatlakoztatni a saját könyvtárukba:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>mkdir</span> ~/az-én-csatlakozási-pontom
% mount <span class=nt>-t</span> cd9660 /dev/acd0c ~/az-én-csatlakozási-pontom</code></pre></div></div><div class=paragraph><p>Az eszközök leválasztása is hasonlóan egyszerû:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% umount ~/az-én-csatlakozási-pontom</code></pre></div></div><div class=paragraph><p>A <code>vfs.usermount</code> engedélyezésével azonban együttjár némi biztonsági kockázat is. Az MS-DOS® formátumú lemezek csatlakoztatására ezért inkább a Portgyûjteményben található <a class=package href=https://cgit.freebsd.org/ports/tree/emulators/mtools/>emulators/mtools</a> csomagot javasoljuk.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>A példákban használt eszközneveket természetesen a konfigurációnknak megfelelõen meg kell változtatnunk.</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=_a_du_és_a_df_parancsok_eltérõ_mennyiségû_szabad_helyet_mutatnak_mi_okozza_ezt>9.24. A du és a df parancsok eltérõ mennyiségû szabad helyet mutatnak. Mi okozza ezt?<a class=anchor href=#_a_du_és_a_df_parancsok_eltérõ_mennyiségû_szabad_helyet_mutatnak_mi_okozza_ezt></a></h3><div class=paragraph><p>A válaszhoz meg kell értenünk a <code>du</code> és a <code>df</code> mûködését. A <code>du</code> végigmegy a könyvtárszerkezeten és megnézi, hogy mekkorák az egyes állományok, majd megjeleníti a végösszegüket. A <code>df</code> ezzel szemben egyszerûen csak lekérdezi az állományrendszertõl, hogy mennyi szabad hely maradt rajta. Ezek látszólag ugyanazt a módszer fedik, azonban miközben a könyvtár nélkül állományok befolyásolják a <code>df</code> parancsot, addig a <code>du</code> parancsot nem.</p></div><div class=paragraph><p>Amikor egy program használ egy olyan állományt, amelyet eközben letörlünk, egészen addig létezni fog, amíg a program be nem fejezi a használatát. Ettõl függetlenül viszont az állomány azonnal eltûnik a könyvtárból. Ezt nagyon könnyen ki is tudjuk próbálni egy olyan programmal, mint például a <code>more</code>. Tegyük fel, hogy van akkora állományunk, amely elég nagy ahhoz, hogy feltûnjön a <code>du</code> és a <code>df</code> kimenetében. (Mivel manapság már nagyok a tárolóeszközök, ennek egy <em>igen nagy</em> állománynak kell lennie!) Ha letöröljük ezt az állományt, miközben a <code>more</code> paranccsal még használjuk, a <code>more</code> nem fog rögtön leállni és panaszkodni az állomány hiányára. Egyedül csak az állományhoz tartozó bejegyzés tûnik el a könyvtárból, így más program már nem tud hozzáférni. A <code>du</code> erre már azt mondja, hogy nem létezik - bejárta a könyvtárat és nem találta. A <code>df</code> szerint azonban még mindig ott van, hiszen az állományrendszer tudja, hogy a <code>more</code> parancsnak még szüksége van rá. Ahogy a <code>more</code> befejezte a dolgát, a <code>du</code> és a <code>df</code> által mutatott értékek ismét egyezni fognak.</p></div><div class=paragraph><p>Azt sem szabad elfelejtenünk, hogy a Soft Updates használata esetén akár 30 másodpercet is várnunk kell, hogy a változtatásaink láthatóvá váljanak!</p></div><div class=paragraph><p>Ez a helyzet nagyon gyakori webszerverek esetén. Sokan úgy állítanak be a FreeBSD rendszerükön webszervert, hogy elfelejtik beállítani hozzá a naplók archiválását és váltását. Ilyenkor a hozzáférések naplózása gyorsan meg tudja tölteni a <span class=filename>/var</span> könyvtárat. Ekkor a rendszergazda törli az adott állományt, de a rendszer még mindig panaszkodik a szabad hely hiánya miatt. A webszerver leállítása és újraindítása ekkor segít felszabadítani az állományt, így az állományrendszerrõl is törlõdhet. Ennek megelõzésére használjuk a <a href="https://man.freebsd.org/cgi/man.cgi?query=newsyslog&amp;sektion=8&amp;format=html">newsyslog(8)</a> programot.</p></div></div><div class=sect2><h3 id=_hogyan_lehet_növelni_a_lapozóterületet>9.25. Hogyan lehet növelni a lapozóterületet?<a class=anchor href=#_hogyan_lehet_növelni_a_lapozóterületet></a></h3><div class=paragraph><p>A kézikönyv <a href=https://docs.freebsd.org/hu/books/handbook/config-tuning#config-tuning>Beállítás és finomhangolás</a> címû fejezetében található <a href=https://docs.freebsd.org/hu/books/handbook/config-tuning/#adding-swap-space>egyik szakaszban</a> olvashatunk errõl.</p></div></div><div class=sect2><h3 id=_a_freebsd_miért_látja_kisebbnek_a_lemezeket_mint_amekkorának_a_gyártó_mondja_ezeket>9.26. A FreeBSD miért látja kisebbnek a lemezeket mint amekkorának a gyártó mondja ezeket?<a class=anchor href=#_a_freebsd_miért_látja_kisebbnek_a_lemezeket_mint_amekkorának_a_gyártó_mondja_ezeket></a></h3><div class=paragraph><p>A merevlemezek gyártói általában a gigabyte-okat egy milliárd byte-ként számolják, miközben a FreeBSD pedig 1 073 741 824 byte-nak. Ez remekül megmagyarázza, hogy a FreeBSD rendszerüzenetei között egy elméletileg 80 GB méretû lemez miért 76 319 MB-osnak jelenik meg.</p></div><div class=paragraph><p>Emellett érdemes még tisztában lennünk azzal is, hogy a FreeBSD (alapértelmezés szerint) <a href=#disk-more-than-full>fenntartja</a> a lemezterület 8 százalékát.</p></div></div><div class=sect2><h3 id=_hogyan_lehet_egy_partíció_100_százaléknál_is_jobban_megtelt>9.27. Hogyan lehet egy partíció 100 százaléknál is jobban megtelt?<a class=anchor href=#_hogyan_lehet_egy_partíció_100_százaléknál_is_jobban_megtelt></a></h3><div class=paragraph><p>Az UFS partíciók egy részét (amely alapértelmezés szerint a teljes kapacitás 8 százaléka) az operációs rendszer fenntartja a saját és a <code>root</code> felhasználó számára. A <a href="https://man.freebsd.org/cgi/man.cgi?query=df&amp;sektion=1&amp;format=html">df(1)</a> ezt a területet nem számolja a <code>Capacity</code> oszlopban megjelenõ értékhez, ezért tudja átlépni a 100 százalékos arányt. Sõt még azt is láthatjuk, hogy a blokkok számát jelzõ <code>Blocks</code> oszlopban megjelenõ érték mindig, általában pontosan 8 százalékkal nagyobb, mint a használt blokkokat jelzõ <code>Used</code> és a rendelkezésre álló blokkokat jelzõ <code>Avail</code> oszlopokban szereplõ értékek összege.</p></div><div class=paragraph><p>A részleteket a <a href="https://man.freebsd.org/cgi/man.cgi?query=tunefs&amp;sektion=8&amp;format=html">tunefs(8)</a> man oldalon belül a <code>-m</code> opció bemutatásánál olvashatjuk.</p></div></div></div></div><div class=sect1><h2 id=_rendszeradminisztráció>10. Rendszeradminisztráció<a class=anchor href=#_rendszeradminisztráció></a></h2><div class=sectionbody><div class=sect2><h3 id=_hol_vannak_a_rendszerindítás_beállításáért_felelõs_állományok>10.1. Hol vannak a rendszerindítás beállításáért felelõs állományok?<a class=anchor href=#_hol_vannak_a_rendszerindítás_beállításáért_felelõs_állományok></a></h3><div class=paragraph><p>Az ezzel kapcsolatos beállítások elsõsorban az <span class=filename>/etc/defaults/rc.conf</span> állományban találhatóak (lásd <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a>). A rendszer indításáért felelõs szkriptek, mint például az <span class=filename>/etc/rc</span> vagy az <span class=filename>/etc/rc.d</span> könyvtár tartalma (lásd <a href="https://man.freebsd.org/cgi/man.cgi?query=rc&amp;sektion=8&amp;format=html">rc(8)</a>) ezt használja. <em>Ezt az állományt tilos közvetlenül szerkeszteni!</em> Ha valamit meg akarunk változtatni az <span class=filename>/etc/defaults/rc.conf</span> állományban szereplõ beállítások közül, akkor ehelyett egyszerûen csak másoljuk le az <span class=filename>/etc/rc.conf</span> állományba és állítsuk be ott az értékét.</p></div><div class=paragraph><p>Például, ha el akarjuk indítani a beépített névfeloldó szolgáltatást, a <a href="https://man.freebsd.org/cgi/man.cgi?query=named&amp;sektion=8&amp;format=html">named(8)</a> démont, akkor ennyit kell tennünk:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># echo &#39;named_enable=&#34;YES&#34;&#39; &gt;&gt; /etc/rc.conf</span></code></pre></div></div><div class=paragraph><p>Ha helyi szolgáltatásokat akarunk futtatni, akkor tegyük a hozzá tartozó szkripteket az <span class=filename>/usr/local/etc/rc.d</span> könyvtárba. Ezek a szkriptek legyenek végrehajthatóak és az alapértelmezett állománymóduk legyen <code>555</code>.</p></div></div><div class=sect2><h3 id=_hogyan_lehet_felhasználókat_egyszerûen_létrehozni>10.2. Hogyan lehet felhasználókat egyszerûen létrehozni?<a class=anchor href=#_hogyan_lehet_felhasználókat_egyszerûen_létrehozni></a></h3><div class=paragraph><p>Használjuk a <a href="https://man.freebsd.org/cgi/man.cgi?query=adduser&amp;sektion=8&amp;format=html">adduser(8)</a>, vagy bonyolultabb esetekben a <a href="https://man.freebsd.org/cgi/man.cgi?query=pw&amp;sektion=8&amp;format=html">pw(8)</a> parancsot.</p></div><div class=paragraph><p>Felhasználókat törölni a <a href="https://man.freebsd.org/cgi/man.cgi?query=rmuser&amp;sektion=8&amp;format=html">rmuser(8)</a>, vagy amennyiben szükséges, a <a href="https://man.freebsd.org/cgi/man.cgi?query=pw&amp;sektion=8&amp;format=html">pw(8)</a> paranccsal tudunk.</p></div></div><div class=sect2><h3 id=_a_crontab_szerkesztése_után_miért_jelennek_meg_a_root_not_found_és_a_hozzá_hasonló_hibaüzenetek>10.3. A crontab szerkesztése után miért jelennek meg a root: not found és a hozzá hasonló hibaüzenetek?<a class=anchor href=#_a_crontab_szerkesztése_után_miért_jelennek_meg_a_root_not_found_és_a_hozzá_hasonló_hibaüzenetek></a></h3><div class=paragraph><p>Ilyen általában olyankor történik, amikor a rendszerszintû <span class=filename>crontab</span> állományt módosítjuk (<span class=filename>/etc/crontab</span>), majd a <a href="https://man.freebsd.org/cgi/man.cgi?query=crontab&amp;sektion=1&amp;format=html">crontab(1)</a> használatával megpróbáljuk telepíteni:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># crontab /etc/crontab</span></code></pre></div></div><div class=paragraph><p>Ezt nem így kell megoldani. A rendszerszintû <span class=filename>crontab</span> felépítése eltér a felhasználókhoz tartozó <span class=filename>crontab</span> állományokétól (a <a href="https://man.freebsd.org/cgi/man.cgi?query=crontab&amp;sektion=5&amp;format=html">crontab(5)</a> man oldal szemlélteti részletesebben ezeket az eltéréseket), amelyet a <a href="https://man.freebsd.org/cgi/man.cgi?query=crontab&amp;sektion=1&amp;format=html">crontab(1)</a> próbál meg ilyenkor telepíteni.</p></div><div class=paragraph><p>Ha így csináltuk, akkor a <span class=filename>crontab</span> nem lesz több, mint az <span class=filename>/etc/crontab</span> hibás formátumú változata. Töröljük le:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># crontab -r</span></code></pre></div></div><div class=paragraph><p>Legközelebb, amikor az <span class=filename>/etc/crontab</span> állományt módosítjuk, nem kell értesítenünk a <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a> démont, mivel magától észre fogja venni az elvégzett változtatásokat.</p></div><div class=paragraph><p>Ha valamit napi, heti vagy havi rendszerességgel akarunk futtatni, akkor ehelyett inkább másoljuk be az <span class=filename>/usr/local/etc/periodic</span> könyvtárba, és hagyjuk, hogy a <code>cron</code> hívja meg a <a href="https://man.freebsd.org/cgi/man.cgi?query=periodic&amp;sektion=8&amp;format=html">periodic(8)</a> parancson keresztül az összes többi rendszeresen elvégzendõ feladattal együtt.</p></div><div class=paragraph><p>Ez a hiba egyébként onnan jön, hogy rendszerszintû <span class=filename>crontab</span> állomány esetén van még egy további mezõ, amely megadja, hogy az adott parancsot melyik felhasználóval kell futtatni. Az alapértelmezett rendszerszintû <span class=filename>crontab</span> állomány esetén ez mindenhol a <code>root</code>. Amikor ezt a <span class=filename>crontab</span> állományt a <code>root</code><span class=filename>crontab</span> állományaként használjuk (amely <em>nem</em> ugyanaz, mint a rendszerszintû <span class=filename>crontab</span>), akkor a <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a> a <code>root</code> szót a végrehajtandó parancs részének fogja tekinteni, amely viszont nem létezik.</p></div></div><div class=sect2><h3 id=_miért_jelenik_meg_a_you_are_not_in_the_correct_group_to_su_root_hibaüzenet_amikor_a_su_paranccsal_át_akarunk_váltani_a_root_felhasználóra>10.4. Miért jelenik meg a you are not in the correct group to su root hibaüzenet, amikor a su paranccsal át akarunk váltani a root felhasználóra?<a class=anchor href=#_miért_jelenik_meg_a_you_are_not_in_the_correct_group_to_su_root_hibaüzenet_amikor_a_su_paranccsal_át_akarunk_váltani_a_root_felhasználóra></a></h3><div class=paragraph><p>Ez egy biztonsági megszorítás. Csak úgy tudunk átváltani a <code>root</code> felhasználóra (vagy bármilyen más olyan hozzáférésre, amely rendszeradminisztrátori jogosultságokkal rendelkezik), ha a <code>wheel</code> csoport tagjai vagyunk. Ha nem létezne ez a korlátozás, akkor a rendszerben szinte bárki képes lenne rendszeradminisztrátori jogosultságokat szerezni csupán úgy, hogy ha megszerzi valahogy a <code>root</code> jelszavát. Ennek a korlátozásnak köszönhetõen ez viszont már nem lesz feltétlenül helytálló. A <a href="https://man.freebsd.org/cgi/man.cgi?query=su&amp;sektion=1&amp;format=html">su(1)</a> még a jelszót sem engedi megadni azoknak, akik nem tagjai a <code>wheel</code> csoportnak.</p></div><div class=paragraph><p>Ha engedélyezni akarjuk valakinek a <code>root</code> felhasználóra váltást, akkor nincs más teendõnk, mint egyszerûen a hozzáadni a <code>wheel</code> csoporthoz.</p></div></div><div class=sect2><h3 id=_az_rc_conf_állományban_vagy_valamelyik_másik_konfigurációs_állományban_rosszul_adtuk_meg_a_beállításokat_és_nem_lehet_módosítani_ezeket_mert_így_írásvédett_lett_az_állományrendszer_mi_a_megoldás>10.5. Az rc.conf állományban vagy valamelyik másik konfigurációs állományban rosszul adtuk meg a beállításokat, és nem lehet módosítani ezeket, mert így írásvédett lett az állományrendszer. Mi a megoldás?<a class=anchor href=#_az_rc_conf_állományban_vagy_valamelyik_másik_konfigurációs_állományban_rosszul_adtuk_meg_a_beállításokat_és_nem_lehet_módosítani_ezeket_mert_így_írásvédett_lett_az_állományrendszer_mi_a_megoldás></a></h3><div class=paragraph><p>Indítsuk újra a rendszert és a rendszertöltõ parancssorában adjuk ki a <code>boot -s</code> parancsot, amivel így egyfelhasználós módba váltunk. Amikor meg kell adnunk a használni kívánt parancsértelmezõ nevét, egyszerûen csak nyomjuk le az <kbd>Enter</kbd> billentyût, majd a <code>mount -urw /</code> parancs kiadásával csatlakoztassuk újra írható módban rendszerindító állományrendszert. Emellett még valószínûleg a <code>mount -a -t ufs</code> paranccsal azokat az állományrendszereket is érdemes lesz csatlakoztatnunk, ahol a kedvenc szövegszerkesztõnk található. Amennyiben az érintett szövegszerkesztõ egy hálózati állományrendszeren található, akkor helyette használjunk egy helyben elérhetõ szövegszerkesztõt, például az <a href="https://man.freebsd.org/cgi/man.cgi?query=ed&amp;sektion=1&amp;format=html">ed(1)</a> programot, vagy manuálisan állítsuk be a hálózat elérését a hálózati állományrendszerek csatlakoztatásához.</p></div><div class=paragraph><p>Ha a <a href="https://man.freebsd.org/cgi/man.cgi?query=vi&amp;sektion=1&amp;format=html">vi(1)</a> vagy <a href="https://man.freebsd.org/cgi/man.cgi?query=emacs&amp;sektion=1&amp;format=html">emacs(1)</a> programokhoz hasonló teljes képernyõs szövegszerkesztõt akarunk használni, akkor elõtte nem árt a <code>export TERM=cons25</code> parancsot sem kiadnunk, így a <a href="https://man.freebsd.org/cgi/man.cgi?query=termcap&amp;sektion=5&amp;format=html">termcap(5)</a> adatbázisból elérhetõvé válnak az ehhez szükséges adatok.</p></div><div class=paragraph><p>Miután megtettük ezeket a lépéseket, már a szokásos módon át tudjuk szerkeszteni az <span class=filename>/etc/rc.conf</span> állományt. A rendszermag indulása után közvetlenül megjelenõ üzenetekben találhatjuk meg azon sorok számait, amelyeket a rendszer nem tudott értelmezni.</p></div></div><div class=sect2><h3 id=_miért_nem_sikerül_beállítani_a_nyomtatót>10.6. Miért nem sikerül beállítani a nyomtatót?<a class=anchor href=#_miért_nem_sikerül_beállítani_a_nyomtatót></a></h3><div class=paragraph><p>Olvassuk el a kézikönyv <a href=https://docs.freebsd.org/hu/books/handbook/printing/#printing>nyomtatókkal foglalkozó</a> részét, minden bizonnyal választ ad a legtöbb kérdésünkre.</p></div><div class=paragraph><p>Bizonyos nyomtatókat azonban akkor tudunk használni, ha van hozzá meghajtónk. Ezeket gyakran csak "WinPrinter" néven emlegetik, amelyeket viszont a FreeBSD nem támogat. Ha a nyomtatónk nem használható DOS vagy Windows® alatt, akkor valószínûleg egy ilyen WinPrinterrel van dolgunk. Ebben az esetben egyedül abban reménykedhetünk, hogy a <a class=package href=https://cgit.freebsd.org/ports/tree/print/pnm2ppa/>print/pnm2ppa</a> port támogatja.</p></div></div><div class=sect2><h3 id=_hogyan_lehet_módosítani_a_rendszerünkhöz_tartozó_billentyûkiosztást>10.7. Hogyan lehet módosítani a rendszerünkhöz tartozó billentyûkiosztást?<a class=anchor href=#_hogyan_lehet_módosítani_a_rendszerünkhöz_tartozó_billentyûkiosztást></a></h3><div class=paragraph><p>Olvassuk el a kézikönyv <a href=https://docs.freebsd.org/hu/books/handbook/l10n/#using-localization>honosításssal</a> foglalkozó részét, különös tekintettel a <a href=https://docs.freebsd.org/hu/books/handbook/l10n#setting-console>konzol beállításaira</a>.</p></div></div><div class=sect2><h3 id=_miért_jelenik_meg_az_unknown_pnp0303_cant_assign_resources_hibaüzenet_a_rendszer_indulásakor>10.8. Miért jelenik meg az unknown: &lt;PNP0303> can’t assign resources hibaüzenet a rendszer indulásakor?<a class=anchor href=#_miért_jelenik_meg_az_unknown_pnp0303_cant_assign_resources_hibaüzenet_a_rendszer_indulásakor></a></h3><div class=paragraph><p>Erre a <a href=https://lists.FreeBSD.org/subscription/freebsd-current>FreeBSD-CURRENT levelezési lista</a> címére postázott egyik levél adja meg a választ:</p></div><div class=paragraph><p>Garrett Wollman &lt;<a href=mailto:wollman@FreeBSD.org>wollman@FreeBSD.org</a>>, 2001. április 24.
A "can’t assign resources" üzenetek rendszerünkben olyan ISA eszközök jelenlétére utalnak, amelyekhez a rendszermagban PnP támogatást nem tartalmazó meghajtók tartoznak. Ilyenek többek közt a billentyûzetvezérlõk, a programozható megszakítás-vezérlõ chip és sok más alapvetõ elem a gépünkben. Ezek az erõforrások nem oszthatóak ki, mivel már valamelyik meghajtó használatba vette ezeket.</p></div></div><div class=sect2><h3 id=_miért_nem_mûködnek_rendesen_a_kvóták>10.9. Miért nem mûködnek rendesen a kvóták?<a class=anchor href=#_miért_nem_mûködnek_rendesen_a_kvóták></a></h3><div class="olist arabic"><ol class=arabic><li><p>Elõfordulhat, hogy a rendszermag nem támogatja a kvóták használatát. Ha errõl lenne szó, akkor vegyük fel az alábbi sort a rendszermag konfigurációs állományába és fordítsuk újra:</p><div class="literalblock programlisting"><div class=content><pre>options QUOTA</pre></div></div><div class=paragraph><p>Ennek részleteit a<a href=https://docs.freebsd.org/hu/books/handbook/disks/#quotas>kézikönyv</a> kvótákkal foglalkozó részében találjuk.</p></div></li><li><p>Az <span class=filename>/</span> állományrendszeren ne engedélyezzük a kvóták használatát.</p></li><li><p>Tegyünk kvótaállományokat azokra az állományrendszerekre, ahol be akarjuk vezetni a használatukat, például:</p><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Állományrendszer</th><th class="tableblock halign-left valign-top">Kvótaállomány</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/admin/quotas</span></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/home</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/home/admin/quotas</span></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>…​</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>…​</p></td></tr></tbody></table></li></ol></div></div><div class=sect2><h3 id=_a_freebsd_tartalmazza_a_system_v_ipc_alapeszközeit>10.10. A FreeBSD tartalmazza a System V IPC alapeszközeit?<a class=anchor href=#_a_freebsd_tartalmazza_a_system_v_ipc_alapeszközeit></a></h3><div class=paragraph><p>Igen, a FreeBSD a <span class=filename>GENERIC</span> típusú rendszermagban támogatja a System V típusú IPC megoldást, beleértve az osztott memória, az üzenetek és a szemaforok használatát. Ha saját rendszermagunk van, akkor az alábbi beállítások használatával engedélyezhetjük a használatukat:</p></div><div class="literalblock programlisting"><div class=content><pre>options    SYSVSHM          # az osztott memória engedélyezése
options    SYSVSEM          # a szemaforok engedélyeze
options    SYSVMSG          # az üzenetek kezelése</pre></div></div><div class=paragraph><p>Fordítsuk és telepítsük újra a rendszermagot.</p></div></div><div class=sect2><h3 id=_a_sendmail_helyett_milyen_más_levelezõ_szerver_használható_még>10.11. A sendmail helyett milyen más levelezõ szerver használható még?<a class=anchor href=#_a_sendmail_helyett_milyen_más_levelezõ_szerver_használható_még></a></h3><div class=paragraph><p>A <a href=http://www.sendmail.org/>sendmail</a> a FreeBSD-ben található alapértelmezett levelezõ szerver, de könnyen le tudjuk cserélni másikra (például amelyet a portok közül telepítettünk).</p></div><div class=paragraph><p>A Portgyûjteményben több különbözõ levelezõ szerver is megtalálható, amelyek közül a <a class=package href=https://cgit.freebsd.org/ports/tree/mail/exim/>mail/exim</a>, <a class=package href=https://cgit.freebsd.org/ports/tree/mail/postfix/>mail/postfix</a>, <a class=package href=https://cgit.freebsd.org/ports/tree/mail/qmail/>mail/qmail</a> és a <a class=package href=https://cgit.freebsd.org/ports/tree/mail/zmailer/>mail/zmailer</a> portok a leginkább népszerûek.</p></div><div class=paragraph><p>Szép dolog, hogy lehet válogatni a különbözõ megoldások között és hogy ilyen sok levelezõ szerver használható. Ezért lehetõleg a levelezési listákon ne kérdezzünk senkitõl olyat, hogy "De a sendmail akkor most miért jobb, mint a qmail?" Ha ilyen kérdéseink vannak, akkor elõször inkább olvassuk át az archívumokat. Szinte biztos, hogy már szinte az összes levelezõ szerver elõnyét és hátrányát kivesézték jó néhányszor.</p></div></div><div class=sect2><h3 id=_elveszett_a_root_felhasználó_jelszava_mit_tegyünk>10.12. Elveszett a root felhasználó jelszava! Mit tegyünk?<a class=anchor href=#_elveszett_a_root_felhasználó_jelszava_mit_tegyünk></a></h3><div class=paragraph><p>Ne essünk kétségbe! Indítsuk újra a rendszerünket egyfelhasználós módban. Ehhez gépeljük be a <code>boot -s</code> parancsot a rendszertöltõ <code>Boot:</code> parancssorában. Amikor a parancsértelmezõt kell megadnunk, egyszerûen csak nyomjuk le az <kbd>Enter</kbd> billentyût. Ekkor kapunk egy # parancssort. A <code>mount -urw /</code> parancs begépelésével csatlakoztassuk újra a rendszerindító partíciónkat írható módban, majd a <code>mount -a</code> paranccsal csatlakoztassuk az összes többi állományrendszert. Ezt követõen a <code>passwd root</code> parancs kiadásával változtassuk meg a <code>root</code> felhasználó jelszavát és a <a href="https://man.freebsd.org/cgi/man.cgi?query=exit&amp;sektion=1&amp;format=html">exit(1)</a> futtatásával folytassuk a rendszer indítását.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Ha az egyfelhasználós módra váltás során a rendszer a <code>root</code> felhasználó jelszavát kérné, akkor az arra utal, hogy a konzol (<span class=filename>/dev/console</span>) az <span class=filename>/etc/ttys</span> állomány szerint <code>insecure</code> (nem biztonságos) típusú. Ebben az esetben szereznünk kell egy FreeBSD telepítõlemezt, elindítanunk róla a rendszert, majd a <a href="https://man.freebsd.org/cgi/man.cgi?query=sysinstall&amp;sektion=8&amp;format=html">sysinstall(8)</a> programban a <span class=guimenuitem>Fixit</span> menüponton keresztül indított parancsértelmezõben kiadni az elõbb említett parancsokat.</p></div></td></tr></tbody></table></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Ha egyfelhasználós módban nem tudjuk csatlakoztatni a rendszerindító partíciót, akkor ennek könnyen az lehet az oka, hogy a partíciókat titkosították, ezért a megfelelõ kulcsok nélkül nem tudjuk elérni ezeket. Ez leginkább adott implementációtól függ. A FreeBSD-ben elõforduló lemeztitkosításokkal kapcsolatban a <a href=https://docs.freebsd.org/hu/books/handbook/disks/#disks-encrypting>kézikönyv</a> ad bõvebb útmutatást.</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=_hogyan_akadályozható_meg_hogy_a_controlaltdelete_billentyûkombináció_újraindítsa_a_rendszert>10.13. Hogyan akadályozható meg, hogy a ControlAltDelete billentyûkombináció újraindítsa a rendszert?<a class=anchor href=#_hogyan_akadályozható_meg_hogy_a_controlaltdelete_billentyûkombináció_újraindítsa_a_rendszert></a></h3><div class=paragraph><p>Ha a <a href="https://man.freebsd.org/cgi/man.cgi?query=syscons&amp;sektion=4&amp;format=html">syscons(4)</a> (vagyis az alapértelmezett) konzolt használjuk, akkor ehhez a következõ beállításokkal kell fordítanunk és telepítenünk egy rendszermagot:</p></div><div class="literalblock programlisting"><div class=content><pre>options SC_DISABLE_REBOOT</pre></div></div><div class=paragraph><p>Mindezt a rendszermag újrafordítása és a újraindítása nélkül is le tudjuk tiltani, ha beállítjuk az alábbi <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a>-változót:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl hw.syscons.kbd_reboot=0</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Az elõbb említett két módszer kizárja egymást. A <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> változó nem létezik, ha a rendszermagot a <code>SC_DISABLE_REBOOT</code> beállítással fordítjuk újra.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Ha viszont a <a href="https://man.freebsd.org/cgi/man.cgi?query=pcvt&amp;sektion=4&amp;format=html">pcvt(4)</a> konzolt használjuk, akkor a következõ konfigurációs beállítást kell megadnunk a rendszermag újrafordításakor:</p></div><div class="literalblock programlisting"><div class=content><pre>options PCVT_CTRL_ALT_DEL</pre></div></div></div><div class=sect2><h3 id=_hogyan_lehet_szöveges_dos_állományokat_unix_formátumúra_alakítani>10.14. Hogyan lehet szöveges DOS állományokat UNIX® formátumúra alakítani?<a class=anchor href=#_hogyan_lehet_szöveges_dos_állományokat_unix_formátumúra_alakítani></a></h3><div class=paragraph><p>Használjuk a következõ <a href="https://man.freebsd.org/cgi/man.cgi?query=perl&amp;sektion=1&amp;format=html">perl(1)</a> parancsot:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% perl <span class=nt>-i</span>.bak <span class=nt>-npe</span> <span class=s1>&#39;s/\r\n/\n/g&#39;</span> állományok</code></pre></div></div><div class=paragraph><p>ahol az <em>állományok</em> az átalakítandó állományok. A konverzió helyben történik, illetve az eredeti állományokról <span class=filename>.bak</span> kiterjesztéssel létrejön egy biztonsági mentés.</p></div><div class=paragraph><p>Erre a célra viszont ugyanígy megfelel a <a href="https://man.freebsd.org/cgi/man.cgi?query=tr&amp;sektion=1&amp;format=html">tr(1)</a> parancs is:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>tr</span> <span class=nt>-d</span> <span class=s1>&#39;\r&#39;</span> &lt; dos-szöveges-állomány <span class=o>&gt;</span> unix-szöveges-állomány</code></pre></div></div><div class=paragraph><p>Ekkor a <em>dos-szöveges-állomány</em> lesz a DOS formátumú szöveges állomány, miközben a <em>unix-szöveges-állomány</em> fogja az eredményt tartalmazni. Ez valamivel gyorsabb a <code>perl</code> megoldásánál.</p></div><div class=paragraph><p>Ez említett megoldásokon kívül a DOS szöveges állományait a Portgyûjteményben található <a class=package href=https://cgit.freebsd.org/ports/tree/converters/dosunix/>converters/dosunix</a> porttal is könnyedén át tudjuk alakítani. Ennek részleteit a hozzá tartozó dokumentációból tudjuk meg.</p></div></div><div class=sect2><h3 id=_hogyan_lehet_futó_programokat_név_szerint_leállítani>10.15. Hogyan lehet futó programokat név szerint leállítani?<a class=anchor href=#_hogyan_lehet_futó_programokat_név_szerint_leállítani></a></h3><div class=paragraph><p>Lásd <a href="https://man.freebsd.org/cgi/man.cgi?query=killall&amp;sektion=1&amp;format=html">killall(1)</a>.</p></div></div><div class=sect2><h3 id=_a_su1_miért_írja_folyton_hogy_a_felhasználó_nincs_a_root_acl_jében>10.16. A <a href="https://man.freebsd.org/cgi/man.cgi?query=su&amp;sektion=1&amp;format=html">su(1)</a> miért írja folyton, hogy a felhasználó nincs a root ACL-jében?<a class=anchor href=#_a_su1_miért_írja_folyton_hogy_a_felhasználó_nincs_a_root_acl_jében></a></h3><div class=paragraph><p>Ezt a hibát az elosztott hitelesítést végzõ Kerberos rendszer adja. Maga a probléma nem végzetes, viszont annál inkább idegesítõ. Ilyenkor vagy a <code>-K</code> kapcsolóval kell futtatni a <a href="https://man.freebsd.org/cgi/man.cgi?query=su&amp;sektion=1&amp;format=html">su(1)</a> programot, vagy a következõ kérdésben megadottak szerint el kell távolítani a Kerberos alkalmazást.</p></div></div><div class=sect2><h3 id=_hogyan_távolítható_el_a_kerberos>10.17. Hogyan távolítható el a Kerberos?<a class=anchor href=#_hogyan_távolítható_el_a_kerberos></a></h3><div class=paragraph><p>A Kerberos úgy távolítható el a rendszerbõl, ha újratelepítjük a <code>base</code> terjesztés tartalmát. Ha CD-rõl telepítettük a rendszert, akkor csatlakoztassuk (most tegyük fel, hogy a <span class=filename>/cdrom</span> könyvtárba) és futassuk a következõ parancsot:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /cdrom/base</span>
<span class=c># ./install.sh</span></code></pre></div></div><div class=paragraph><p>Másik lehetõség, ha hozzáadjuk a <code>NO_KERBEROS</code> beállítást a <span class=filename>/etc/make.conf</span> állományhoz és újrafordítjuk az alaprendszert.</p></div></div><div class=sect2><h3 id=_mi_történt_a_devmakedev_állománnyal>10.18. Mi történt a /dev/MAKEDEV állománnyal?<a class=anchor href=#_mi_történt_a_devmakedev_állománnyal></a></h3><div class=paragraph><p>A FreeBSD 5.<em>X</em> és a késõbbi változatok már a <a href="https://man.freebsd.org/cgi/man.cgi?query=devfs&amp;sektion=8&amp;format=html">devfs(8)</a> által felkínált automatikus megoldást alkalmazzák. Ilyenkor az eszközmeghajtók igény szerint hoznak létre eszközleírókat, és ezzel lényegében szükségtelenné teszik a <span class=filename>/dev/MAKEDEV</span> használatát.</p></div></div><div class=sect2><h3 id=_hogyan_lehet_még_több_pszeudoterminált_létrehozni>10.19. Hogyan lehet még több pszeudoterminált létrehozni?<a class=anchor href=#_hogyan_lehet_még_több_pszeudoterminált_létrehozni></a></h3><div class=paragraph><p>Ha sok <code>telnet</code>, <code>ssh</code>, X esetleg <code>screen</code> felhasználónk van, akkor könnyen elõfordulhat, hogy kifogyunk a pszeudoterminálokból. A FreeBSD 6.2 és az azt megelõzõ változatokban alapértelmezés szerint 256 pszeudoterminál, a FreeBSD 6.3 és késõbbi változatokban pedig 512 pszeudoterminál áll rendelkezésünkre.</p></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Szükség esetén további pszeudoterminálok is hozzáadhatóak a rendszerhez. Ehhez azonban módosítanunk kell a szabványos C függvénykönyvtárakat, a rendszermagot és az <span class=filename>/etc/ttys</span> állományt. Például a <a href=http://www.freebsd.org/~jhb/patches/pty_1152.patch>http://www.freebsd.org/~jhb/patches/pty_1152.patch</a> 1152 pszeudoterminál használatát teszi lehetõvé. Ez a konkrét javítás viszont csak a FreeBSD 6.3 és késõbbi változatok esetén alkalmazható zökkenõmentesen.</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=_hogyan_lehet_újraindítás_nélkül_az_etcrc_conf_tartalmát_újraolvastatni_és_újraindítani_az_etcrc_szkriptet>10.20. Hogyan lehet újraindítás nélkül az /etc/rc.conf tartalmát újraolvastatni és újraindítani az /etc/rc szkriptet?<a class=anchor href=#_hogyan_lehet_újraindítás_nélkül_az_etcrc_conf_tartalmát_újraolvastatni_és_újraindítani_az_etcrc_szkriptet></a></h3><div class=paragraph><p>Váltsunk egyfelhasználós módba, majd vissza többfelhasználós módba.</p></div><div class=paragraph><p>Konzolon ez így oldható meg:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># shutdown now</span>
<span class=o>(</span>Megjegyzés: nincs <span class=nt>-r</span> vagy <span class=nt>-h</span><span class=o>!)</span>

<span class=c># return</span>
<span class=c># exit</span></code></pre></div></div></div><div class=sect2><h3 id=_a_stable_rendszer_frissítésekor_betax_rc_vagy_prerelease_verzió_jelenik_meg_mi_történt>10.21. A -STABLE rendszer frissítésekor -BETAx, -RC vagy -PRERELEASE verzió jelenik meg! Mi történt?<a class=anchor href=#_a_stable_rendszer_frissítésekor_betax_rc_vagy_prerelease_verzió_jelenik_meg_mi_történt></a></h3><div class=paragraph><p>Röviden: Ez csak egy elnevezés. Az <em>RC</em> jelentése "Release Candidate", vagyis "kiadásra jelölt". Ez egy küszöbön álló kiadásra utal. A FreeBSD-ben a <em>-PRERELEASE</em> elnevezés általában egyenlõ a kiadások elõtt bekövetkezõ kódfagyasztással. (Bizonyos kiadások esetén pedig a <em>-BETA</em> címkét a <em>-PRERELEASE</em> megjelöléshez hasonlóan használják.)</p></div><div class=paragraph><p>Valamivel bõvebben: A FreeBSD fejlesztésében a kiadások általában két helyrõl származnak. A nagyobb, ún. "nullás" kiadások, mint például 7.0-RELEASE és 8.0-RELEASE, a fejlesztési ág legfrissebb állapotából készülnek, amelyet gyakran csak <a href=#current>-CURRENT</a> néven emlegetnek. A kisebb kiadások, mint például a 6.3-RELEASE vagy az 5.2-RELEASE, az aktív <a href=#stable>-STABLE</a> ágból származnak. A 4.3-RELEASE kiadástól kezdõdõen mindegyik kiadás saját ággal rendelkezik, amelyet elsõsorban olyanoknak ajánlunk, akiknek csak nagyon visszafogott változtatásokra van szükségük a rendszerben (ezek általában csak különbözõ biztonsági javításokat takarnak).</p></div><div class=paragraph><p>Amikor a fejlesztõk készíteni akarnak egy újabb kiadást, az alapjául szolgáló fejlesztési ágon elvégeznek bizonyos mûveleteket. Ennek egy része a források "befagyasztása". Amikor ez megkezdõdik, az ág neve megváltozik, és ezzel jelzik, hogy hamarosan kiadás készül belõle. Például, ha egy ág a 6.2-STABLE nevet viseli, akkor a 6.3-PRERELEASE névre vált arra az idõszakra, amíg tart a kódfagyasztás és lezajlik a kiadások megjelentetéséhez szükség további tesztelés. Hibajavítások ekkor továbbra is rakhatóak bele. Ahogy a források elérik a kiadáshoz szükséges szintet, az ág neve 6.3-RC-re vált, és ezzel jelzik, hogy a kiadás elõkészítése hamarosan befejezõdik. Az <em>RC</em> állapotban csak a legfontosabb hibákat keresik meg és javítják. Miután a kiadás (jelen esetünkben a 6.3-RELEASE kiadás) és a hozzá tartozó ág elkészült, az ág neve ismét 6.3-STABLE lesz.</p></div><div class=paragraph><p>A verziószámokról és a CVS-ben található különbözõ ágakról a <a href=https://docs.freebsd.org/en/articles/releng/>Release Engineering</a> címû cikkben olvashatunk (angolul).</p></div></div><div class=sect2><h3 id=_az_új_rendszermag_telepítése_során_a_chflags1_program_hibát_jelez_hogyan_javítható_ez_a_hiba>10.22. Az új rendszermag telepítése során a <a href="https://man.freebsd.org/cgi/man.cgi?query=chflags&amp;sektion=1&amp;format=html">chflags(1)</a> program hibát jelez. Hogyan javítható ez a hiba?<a class=anchor href=#_az_új_rendszermag_telepítése_során_a_chflags1_program_hibát_jelez_hogyan_javítható_ez_a_hiba></a></h3><div class=paragraph><p>Rövid válasz: A rendszerünk valószínûleg nullánál nagyobb biztonsági szinten fut. Indítsuk újra a rendszerünket egyfelhasználós módban és úgy telepítsük a rendszermagot.</p></div><div class=paragraph><p>A hosszabb válasz: A FreeBSD nem engedi megváltoztatni a rendszerszintû állományjelzõket nullától a nagyobb biztonsági szinteken. A jelenleg érvényben levõ biztonsági szintet a következõ paranccsal lehet lekérdezni:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl kern.securelevel</span></code></pre></div></div><div class=paragraph><p>A biztonsági szintet nem lehet csökkenteni. A rendszert egyfelhasználós módban kell újraindítani, mert csak úgy tudjuk újratelepíteni a rendszermagot. Másik lehetõségünk, ha átállítjuk a biztonsági szintet az <span class=filename>/etc/rc.conf</span> állományban és úgy indítjuk újra a rendszerünket. Az <a href="https://man.freebsd.org/cgi/man.cgi?query=init&amp;sektion=8&amp;format=html">init(8)</a> man oldalán olvashatunk bõvebben a biztonsági szintek (<code>securelevel</code>) beállításáról, az <span class=filename>rc.conf</span> használatáról pedig az <span class=filename>/etc/defaults/rc.conf</span> állományból és a <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a> man oldalon tudhatunk meg többet.</p></div></div><div class=sect2><h3 id=_a_rendszeren_nem_lehet_egyszerre_egy_másodpercnél_többel_megváltoztatni_az_idõt_hogyan_lehet_megkerülni_ezt_a_korlátozást>10.23. A rendszeren nem lehet egyszerre egy másodpercnél többel megváltoztatni az idõt! Hogyan lehet megkerülni ezt a korlátozást?<a class=anchor href=#_a_rendszeren_nem_lehet_egyszerre_egy_másodpercnél_többel_megváltoztatni_az_idõt_hogyan_lehet_megkerülni_ezt_a_korlátozást></a></h3><div class=paragraph><p>A rövid válasz: A rendszerünkben a biztonsági szintet (<code>securelevel</code>) minden bizonnyal egynél nagyobbra állították. Indítsuk újra a rendszert egyfelhasználós módban és változtassuk meg a dátumot.</p></div><div class=paragraph><p>Egy hosszabb válasz: A FreeBSD nem engedi egy másodpercnél többel megváltoztatni az idõt, ha az aktuális biztonsági szint értéke egy felett van. Ezt a következõ parancs kiadásával tudjuk ellenõrizni:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl kern.securelevel</span></code></pre></div></div><div class=paragraph><p>A biztonsági szint futás közben nem csökkenthetõ. A dátum megváltoztatásához ezért a rendszert egyfelhasználós módban kell indítanunk, vagy az <span class=filename>/etc/rc.conf</span> állományban csökkentenünk kell a biztonsági szintet. Az <a href="https://man.freebsd.org/cgi/man.cgi?query=init&amp;sektion=8&amp;format=html">init(8)</a> man oldalon olvashatunk részletesebben a biztonsági szintek mûködésérõl, illetve az <span class=filename>/etc/defaults/rc.conf</span> állományból és az <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a> man oldalról tudhatunk meg többet az <span class=filename>rc.conf</span> mûködésérõl.</p></div></div><div class=sect2><h3 id=_az_rpc_statd_parancsnak_miért_kell_256_mb_memória>10.24. Az rpc.statd parancsnak miért kell 256 MB memória?<a class=anchor href=#_az_rpc_statd_parancsnak_miért_kell_256_mb_memória></a></h3><div class=paragraph><p>Nem, itt szó sincs semmiféle memóriaszivárgásról, és egyébként sem használ 256 MB memóriát. Az <code>rpc.statd</code> parancs egyszerûen csak kényelmi megfontolásokból iszonyatos mennyiségû memóriát képez le a címterébe. Ebben technikailag semmi kivetnivaló nincsen, ezzel egyedül a <a href="https://man.freebsd.org/cgi/man.cgi?query=top&amp;sektion=1&amp;format=html">top(1)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=ps&amp;sektion=1&amp;format=html">ps(1)</a> és a hozzá hasonló programokat zavarja meg egy kicsit.</p></div><div class=paragraph><p>A <a href="https://man.freebsd.org/cgi/man.cgi?query=rpc.statd&amp;sektion=8&amp;format=html">rpc.statd(8)</a> tehát leképezi az állapotát rögzítõ állományt (amely a <span class=filename>/var</span> könyvtárban található a címterébe. Ilyenkor igyekszik egy kicsit elõre gondolkodni és felkészülni a megnövekedésére, ezért viszonylag nagy méretben hozza létre ezt a leképezést. Ezt nagyon jól megfigyelhetjük a forráskódjából is, ahol látszik, hogy a <a href="https://man.freebsd.org/cgi/man.cgi?query=mmap&amp;sektion=2&amp;format=html">mmap(2)</a> függvényt a <code>0x10000000</code> értékkel hívja meg, tehát az 32 bites Intel architektúrán megcímezhetõ memória egytizenhatod részével, ami pontosan 256 MB.</p></div></div><div class=sect2><h3 id=_miért_nem_törölhetõ_az_schg_állományjelzõ>10.25. Miért nem törölhetõ az schg állományjelzõ?<a class=anchor href=#_miért_nem_törölhetõ_az_schg_állományjelzõ></a></h3><div class=paragraph><p>Rendszerünkben a biztonsági szint (<code>securelevel</code>) nagyobb nullánál. Próbáljuk meg csökkenteni az értékét és próbálkozzunk ismét. Ezzel kapcsolatban részletesebb információkat a <a href=#securelevel>a biztonsági szintekrõl szóló kérdésbõl</a> vagy az <a href="https://man.freebsd.org/cgi/man.cgi?query=init&amp;sektion=8&amp;format=html">init(8)</a> man oldalról tudhatunk meg.</p></div></div><div class=sect2><h3 id=_az_shosts_állományon_keresztül_alapértelmezés_szerint_miért_enged_hitelesíteni_a_legújabb_freebsd_verziókban_megtalálható_ssh>10.26. Az .shosts állományon keresztül alapértelmezés szerint miért enged hitelesíteni a legújabb FreeBSD verziókban megtalálható SSH?<a class=anchor href=#_az_shosts_állományon_keresztül_alapértelmezés_szerint_miért_enged_hitelesíteni_a_legújabb_freebsd_verziókban_megtalálható_ssh></a></h3><div class=paragraph><p>A legújabb FreeBSD verziókban azért nem tudjuk az <span class=filename>.shosts</span> állományon keresztül hitelesíteni magunkat, mert az <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh&amp;sektion=1&amp;format=html">ssh(1)</a> alapértelmezés szerint rendszeradminisztrátori jogok nélkül kerül telepítésre. Ezt a "hibát" többféle módon ki tudjuk "javítani":</p></div><div class=ulist><ul><li><p>Ha tartós megoldásra van szükségünk, akkor az <span class=filename>/etc/make.conf</span> állományban állítsuk az <code>ENABLE_SUID_SSH</code> változót a <code>true</code> értékre, majd fordítsuk újra az <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh&amp;sektion=1&amp;format=html">ssh(1)</a> programot (vagy futtassuk le a <code>make world</code> parancsot).</p></li><li><p>Ha ideiglenesen akarjuk csak javítani, akkor az <span class=filename>/usr/bin/ssh</span> állomány engedélyeit <code>root</code> felhasználóként állítsuk a <code>4555</code> értékre a <code>chmod 4555 /usr/bin/ssh</code> parancs kiadásával. Ezután vegyük fel az <code>ENABLE_SUID_SSH= true</code> sort az <span class=filename>/etc/make.conf</span> állományt, így ez a változtatás a <code>make world</code> következõ futtatásakor is megmarad.</p></li></ul></div></div><div class=sect2><h3 id=_mi_az_a_vnlru>10.27. Mi az a vnlru?<a class=anchor href=#_mi_az_a_vnlru></a></h3><div class=paragraph><p>A <code>vnlru</code> törli és szabadítja fel a rendszerben keringõ vnode-okat, amikor a rendszermagban elérik a <code>kern.maxvnodes</code> változó által beállított határt. Ez a rendszermagban futó szál többnyire csak tétlenül ül a háttérben, és csak olyankor lép mûködésben, amikor rengeteg memóriát használunk és éppen több tízezernyi apró állományhoz akarunk egyszerre hozzáférni.</p></div></div><div class=sect2><h3 id=_mit_jelentenek_top_parancs_által_megjelenített_különbözõ_memóriaállapotok>10.28. Mit jelentenek top parancs által megjelenített különbözõ memóriaállapotok?<a class=anchor href=#_mit_jelentenek_top_parancs_által_megjelenített_különbözõ_memóriaállapotok></a></h3><div class=ulist><ul><li><p><code>Active</code> (Aktív): az utóbbi idõben használt lapok.</p></li><li><p><code>Inactive</code> (Inaktív): az utóbbi idõben nem használt lapok.</p></li><li><p><code>Cache</code> (Tárazott): (leginkább) azok a lapok, amelyeket még használnak, de gyakran azonnal újrafelhasználódnak (akár a régi, akár egy új hozzárendelésben). Egyes lapok az <code>active</code> állapotból közvetlenül a <code>cache</code> állapotba váltanak, ha tiszták (nem módosították), de ez az átmenet függ a házirendtõl, vagyis a VM alrendszer karbantartója által kiválasztott algoritmustól.</p></li><li><p><code>Free</code> (Szabad): effektív tartalom nélküli lapok, amelyek akár közvetlenül fel is használhatóak olyan esetekben, amikor a tárazott lapok erre nem alkalmasak. A szabad lapokat megszakításokban és a futó programokban is felhasználhatjuk.</p></li><li><p><code>Wired</code> (Rögzített): olyan lapok, amelyek a memória egy rögzített pontján foglalnak helyet. Ezeket többnyire a rendszermag használja, de speciális esetekben a programoknak is szükségük lehet rá.</p></li></ul></div><div class=paragraph><p>A lapok általában akkor kerülnek ki a lemezre (valamilyen VM alrendszerbeli szinkronizáció során), amikor inaktív állapotban vannak, de akár az aktív lapok is szinkronizálhatóak. Ez attól függ, hogy a processzor képes-e nyomkövetni a lapok módosítását, és némely helyzetekben elõnyös lehet a rendszer számára, ha annak megfelelõen szinkronizálja a VM lapjait, hogy azok aktívak vagy inaktívak. A legtöbb esetben itt egyszerûen csak egy olyan sort kell elképzelni, ahol a program számára viszonylag inaktív lapok találhatóak, amelyeket a rendszer tetszõlegesen a lemezre írhat. A tárazott lapok általában már eleve szinkronizáltak, nem leképzettek, közvetlenül a programok régi és új hozzárendelései használják ezeket. A szabad lapokat akár a megszakítások szintjén is lehet használni, miközben a tárazott vagy szabad lapokat a futó programokban érthetjük el. A tárazott lapok zárolása nem megfelelõ ahhoz, hogy megszakításokban is el lehessen érni ezeket.</p></div><div class=paragraph><p>Vannak még bizonyos jelzések (például a foglaltságot vagy foglaltság mértékét jelzõ értékek), amelyek még hatással vannak a fentebb leírt szabályokra.</p></div></div><div class=sect2><h3 id=_mekkora_a_rendelkezésre_álló_memória_mérete>10.29. Mekkora a rendelkezésre álló memória mérete?<a class=anchor href=#_mekkora_a_rendelkezésre_álló_memória_mérete></a></h3><div class=paragraph><p>A "rendelkezésre álló memóriának" rengeteg típusa létezik. Ezek közül egyik az a memória, amely közvetlenül anélkül elérhetõ, hogy bármi mást ki kellene hozzá lapoznunk. Ennek a mérete nagyjából a tárazott és a szabad lapokat tároló sorok hosszával arányos (amelyet még a rendszer beállításaitól függõ további tényezõk is módosíthatnak). A "rendelkezésre álló memória" másik típusa a teljes VM terület mérete. Ezt nem olyan könnyû meghatározni, de leginkább a lapozóterület és a fizikai memória méretétõl függ. A "rendelkezésre álló memória" több más lehetséges megfogalmazása is létezik, de szinte teljesen felesleges beszélni róluk. Egyedül az a fontos, hogy a igyekezzünk mérsékelni a lapozást és mindig legyen elegendõ lapozóterületünk.</p></div></div><div class=sect2><h3 id=_mi_az_a_varempty_nem_lehet_letörölni>10.30. Mi az a /var/empty? Nem lehet letörölni!<a class=anchor href=#_mi_az_a_varempty_nem_lehet_letörölni></a></h3><div class=paragraph><p>A <span class=filename>/var/empty</span> könyvtárat az <a href="https://man.freebsd.org/cgi/man.cgi?query=sshd&amp;sektion=8&amp;format=html">sshd(8)</a> program használja a privilégiumok elkülönítéséhez. A <span class=filename>/var/empty</span> könyvtárnak üresnek kell lennie, legyen a <code>root</code> tulajdonában és legyen rajta a <code>schg</code> állományjelzõ.</p></div><div class=paragraph><p>Noha semmiképpen sem javasoljuk a könyvtár törlését, úgy tudjuk elvégezni, ha elõször az <code>schg</code> állományjelzõt töröljük róla. A <a href="https://man.freebsd.org/cgi/man.cgi?query=chflags&amp;sektion=1&amp;format=html">chflags(1)</a> man oldalán olvashatunk ezzel kapcsolatban részletesebb információkat (azonban ne felejtsük el <a href=#unsetting-schg>számításba venni az esetleges nehézségeket</a>).</p></div></div></div></div><div class=sect1><h2 id=_az_x_window_system_és_a_virtuális_konzolok_használata>11. Az X Window System és a virtuális konzolok használata<a class=anchor href=#_az_x_window_system_és_a_virtuális_konzolok_használata></a></h2><div class=sectionbody><div class=sect2><h3 id=_mi_az_x_window_system>11.1. Mi az X Window System?<a class=anchor href=#_mi_az_x_window_system></a></h3><div class=paragraph><p>Az X Window System (vagy gyakran csak <code>X11</code>) a UNIX® és UNIX®-szerû operációs rendszereken, így többek közt a FreeBSD-n is az egyik leginkább elterjedt ablakozórendszer. A <a href=http://www.x.org/wiki/>The X.Org Foundation</a> felügyeli az <a href=http://en.wikipedia.org/wiki/X_Window_System_core_protocol>X protokoll szabványait</a>, azok aktuális referencia implementációival együtt. Ezek hivatalos megnevezése "Version 11 Release 7.7", de ezt gyakran csak <code>X11</code> néven rövidítik.</p></div><div class=paragraph><p>Számos implementációja is elérhetõ több különbözõ architektúrára és operációs rendszerre. A protokoll szerver oldali funkcióit megvalósító programokat hivatalosan "X szervereknek" nevezik.</p></div></div><div class=sect2><h3 id=_freebsd_alatt_milyen_x_implementációk_használhatóak>11.2. FreeBSD alatt milyen X implementációk használhatóak?<a class=anchor href=#_freebsd_alatt_milyen_x_implementációk_használhatóak></a></h3><div class=paragraph><p>Kezdetben a FreeBSD alapértelmezett X implementációja az XFree86™ volt, amelyet a <a href=http://www.xfree86.org>The XFree86 Project, Inc.</a> tartott karban. Ez a változat volt használatban alapértelmezés szerint egészen a FreeBSD 4.10 és 5.2 verziójáig. Habár eközben az Xorg maga is karbantartotta a saját változatát, kizárólag csak referencia célokat használt és az évek során teljesen leromlott az állapota.</p></div><div class=paragraph><p>2004 elején azonban az XFree86 néhány korábbi fejlesztõje elhagyta a projektjüket, mivel nem értettek egyet bizonyos kérdésekben, például a forráskód ütemét, a jövõbeni irányokat és egyéb személyes konfliktusokat illetõen, és helyette közvetlenül az Xorg kódját kezdték el fejleszteni. Ekkor az Xorg hozzáigazította forrásait az utolsó XFree86™ kiadás forrásaihoz (XFree86 4.3.99.903), majd megváltoztatta a licencelését. és beolvasztott több, korábban külön karbantartott változtatást, aminek eredményeképpen végül megszületett az X11R6.7.0. Egy különálló, de velük együttmûködõ projekt, a <a href=http://www.freedesktop.org/wiki/>freedesktop.org</a> (vagy röviden csak <code>fd.o</code>) jelenleg is az eredeti XFree86™ források újraszervezésén dolgozik, aminek célja a napjainkban megjelenõ grafikus kártyák minél nagyobb mértékû kihasználása (és ezáltal a rendszer gyorsítása), a rendszer modularisabbá tétele (ezáltal a rendszer karbantarthatóságának javítása, ami a kiadások gyorsabb elõkészítését és könnyebb beállíthatóságát teszi lehetõvé). Az Xorg a jövõben tervezi a <code>freedesktop.org</code> fejlesztéseit is átvenni.</p></div><div class=paragraph><p>2004 júliusától kezdõdõen a FreeBSD-CURRENT változatban az XFree86™ helyett az Xorg lett az alapértelmezett X implementáció. A FreeBSD-ben azóta is alapból az Xorg X11 implementációja található meg.</p></div><div class=paragraph><p>A témával kapcsolatban a kézikönyv <a href=https://docs.freebsd.org/hu/books/handbook/x11/#x11>X11-rõl szóló</a> fejezetében kaphatunk részletesebb felvilágosítást.</p></div></div><div class=sect2><h3 id=_mégis_miért_vált_szét_a_két_x_projekt>11.3. Mégis miért vált szét a két X projekt?<a class=anchor href=#_mégis_miért_vált_szét_a_két_x_projekt></a></h3><div class=paragraph><p>Ezt a kérdést ez a GYIK nem tudja megválaszolni. Ezzel kapcsolatban viszont érdemes elolvasnunk a különbözõ levelezési listák archívumait szerte az interneten. Keressünk rá a válaszra a kedvenc keresõnkben, de ezzel a kérdéssel ne a FreeBSD levelezési listáit zavarjuk. Az is elképzelhetõ, hogy ennek a valós okait csak néhányan ismerik egész teljesen.</p></div></div><div class=sect2><h3 id=_a_freebsd_miért_az_xorg_változatát_választotta_alapértelmezettnek>11.4. A FreeBSD miért az Xorg változatát választotta alapértelmezettnek?<a class=anchor href=#_a_freebsd_miért_az_xorg_változatát_választotta_alapértelmezettnek></a></h3><div class=paragraph><p>Az Xorg fejlesztõi azt ígérték, hogy gyorsabban fognak újabb verziókat kiadni, amelyek sokkal több újítást is fognak tartalmazni. Nos, amennyiben tényleg állják a szavukat, azzal mindenki jól jár. Emellett az õ változatuk továbbra is a hagyományos X licenc alatt érhetõ el, miközben az XFree86™ licence ettõl némileg eltér.</p></div></div><div class=sect2><h3 id=_hogyan_lehet_használni_az_x_et>11.5. Hogyan lehet használni az X-et?<a class=anchor href=#_hogyan_lehet_használni_az_x_et></a></h3><div class=paragraph><p>Amennyiben már egy meglévõ rendszerre szeretnénk telepíteni az X-et, úgy érdemes a <a class=package href=https://cgit.freebsd.org/ports/tree/x11/xorg/>x11/xorg</a> metaportot választanunk, amely magától feltelepíti az összes szükséges komponenst, vagy egyszerûen telepítsük az Xorg alkalmazást csomagból:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c>#  pkg_add -r xorg</span></code></pre></div></div><div class=paragraph><p>Emellett az Xorg a <a href="https://man.freebsd.org/cgi/man.cgi?query=sysinstall&amp;sektion=8&amp;format=html">sysinstall(8)</a> használatával is telepíthetõ: válasszuk a <span class=guimenuitem>Configure</span> (Beállítások), <span class=guimenuitem>Distributions</span> (Terjesztések), végül a <span class=guimenuitem>The X.Org Distribution</span> (Az X.Org terjesztés) menüpontokat.</p></div><div class=paragraph><p>Az Xorg sikeres telepítése után kövessük a kézikönyv <a href=https://docs.freebsd.org/hu/books/handbook/x11/#x-config>X11 beállításával foglalkozó</a> szakaszában leírtakat.</p></div></div><div class=sect2><h3 id=_az_x_indításakor_egy_kdenabio_failed_operation_not_permitted_hiba_keletkezik_közvetlenül_a_startx_parancs_kiadása_után_mi_lehet_ezzel_kezdeni>11.6. Az X indításakor egy KDENABIO failed (Operation not permitted) hiba keletkezik, közvetlenül a startx parancs kiadása után. Mi lehet ezzel kezdeni?<a class=anchor href=#_az_x_indításakor_egy_kdenabio_failed_operation_not_permitted_hiba_keletkezik_közvetlenül_a_startx_parancs_kiadása_után_mi_lehet_ezzel_kezdeni></a></h3><div class=paragraph><p>A rendszerünkön valószínûleg túlságosan magas a biztonsági szint (<code>securelevel</code>) értéke. Ilyenkor az X-et nem tudjuk elindítani, mivel a mûködéséhez szüksége van a <a href="https://man.freebsd.org/cgi/man.cgi?query=io&amp;sektion=4&amp;format=html">io(4)</a> eszköz írására. Ezzel kapcsolatban az <a href="https://man.freebsd.org/cgi/man.cgi?query=init&amp;sektion=8&amp;format=html">init(8)</a> man oldal ad részletesebb útmutatást.</p></div><div class=paragraph><p>A kérdés tehát az, hogy mit kellene ezzel csinálni. Alapvetõen két lehetõségünk van: vagy visszaállítjuk a biztonsági szintet nullára (ezt általában az <span class=filename>/etc/rc.conf</span> állományon keresztül lehet megtenni), vagy az <a href="https://man.freebsd.org/cgi/man.cgi?query=xdm&amp;sektion=1&amp;format=html">xdm(1)</a> programot még a rendszerindítás során elindítjuk (mielõtt a biztonsági szintet magasabbra állítanánk).</p></div><div class=paragraph><p>A <a href=#xdm-boot>Hogyan indítható el az XDM a rendszer indításakor?</a> szolgál arról bõvebb információval, hogy miként tudjuk használni az <a href="https://man.freebsd.org/cgi/man.cgi?query=xdm&amp;sektion=1&amp;format=html">xdm(1)</a> programot a rendszer indítása során.</p></div></div><div class=sect2><h3 id=_miért_nem_mûködik_x_alatt_az_egér>11.7. Miért nem mûködik X alatt az egér?<a class=anchor href=#_miért_nem_mûködik_x_alatt_az_egér></a></h3><div class=paragraph><p>Ha a <a href="https://man.freebsd.org/cgi/man.cgi?query=syscons&amp;sektion=4&amp;format=html">syscons(4)</a> (vagyis az alapértelmezett konzol) meghajtót használjuk, akkor be tudjuk úgy állítani a FreeBSD-t, hogy minden virtuális képernyõn látható legyen az egérkurzor. A <a href="https://man.freebsd.org/cgi/man.cgi?query=syscons&amp;sektion=4&amp;format=html">syscons(4)</a> egy <span class=filename>/dev/sysmouse</span> nevû virtuális eszköz támogatásával igyekszik elkerülni azt, hogy összeakadjon az X-szel. A valós egértõl érkezõ összes eseményt a <a href="https://man.freebsd.org/cgi/man.cgi?query=moused&amp;sektion=8&amp;format=html">moused(8)</a> démon írja folyamatosan a <a href="https://man.freebsd.org/cgi/man.cgi?query=sysmouse&amp;sektion=4&amp;format=html">sysmouse(4)</a> eszközre. Amennyiben az egerünket egy vagy több virtuális konzolon is használni akarjuk az X-szel <em>együtt</em>, akkor nézzük meg a <a href=#moused>Az egeret az X Window Systemen kívül is lehet valamilyen módon használni?</a> válaszát és állítsuk be annak megfelelõen a <a href="https://man.freebsd.org/cgi/man.cgi?query=moused&amp;sektion=8&amp;format=html">moused(8)</a> démont.</p></div><div class=paragraph><p>Ezt követõen nyissuk meg az <span class=filename>/etc/X11/xorg.conf</span> állományt és gondoskodjunk róla, hogy a következõ sorok feltétlenül szerepeljenek benne:</p></div><div class="literalblock programlisting"><div class=content><pre>Section &#34;InputDevice&#34;
   Option          &#34;Protocol&#34; &#34;SysMouse&#34;
   Option          &#34;Device&#34; &#34;/dev/sysmouse&#34;
.....</pre></div></div><div class=paragraph><p>Az Xorg 7.4 változatától kezdõdõen az <span class=filename>xorg.conf</span> állomány <code>InputDevice</code> szekciói nem kerülnek feldolgozásra a csatlakoztatott eszközök automatikus érzékelése esetén. A korábbi viselkedési mód visszaállításához vegyük fel a következõ sort a <code>ServerLayout</code> vagy <code>ServerFlags</code> szekciók valamelyikébe:</p></div><div class="literalblock programlisting"><div class=content><pre>Option &#34;AutoAddDevices&#34; &#34;false&#34;</pre></div></div><div class=paragraph><p>Néhányan inkább a <span class=filename>/dev/mouse</span> eszközt szeretik használni X alatt. Ha mi is így akarjuk használni, akkor a <span class=filename>/dev/mouse</span> eszközhöz hozzunk létre egy szimbolikus linket a <span class=filename>/dev/sysmouse</span> eszközre (lásd <a href="https://man.freebsd.org/cgi/man.cgi?query=sysmouse&amp;sektion=4&amp;format=html">sysmouse(4)</a>). Ezt úgy tudjuk megtenni, ha az <span class=filename>/etc/devfs.conf</span> állományba (lásd <a href="https://man.freebsd.org/cgi/man.cgi?query=devfs.conf&amp;sektion=5&amp;format=html">devfs.conf(5)</a>) felvesszük a következõ sort:</p></div><div class="literalblock programlisting"><div class=content><pre>link    sysmouse    mouse</pre></div></div><div class=paragraph><p>A link maga közvetlenül a <a href="https://man.freebsd.org/cgi/man.cgi?query=devfs&amp;sektion=5&amp;format=html">devfs(5)</a> újraindításával keletkezik. Ehhez (<code>root</code> felhasználóként) a következõ parancsot kell kiadnunk:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /etc/rc.d/devfs restart</span></code></pre></div></div></div><div class=sect2><h3 id=_x_alatt_lehet_használni_görgõs_egeret>11.8. X alatt lehet használni görgõs egeret?<a class=anchor href=#_x_alatt_lehet_használni_görgõs_egeret></a></h3><div class=paragraph><p>Igen.</p></div><div class=paragraph><p>Jelezni kell az X-nek, hogy ötgombos egerünk van. Ezt úgy tudjuk megcsinálni, ha az <span class=filename>/etc/X11/xorg.conf</span> állományba felvesszük a <code>Buttons 5</code> és <code>ZAxisMapping 4 5</code> sorokat az "InputDevice" szakaszba. Vegyük például, hogy az <span class=filename>/etc/X11/xorg.conf</span> állományunkban a következõ "InputDevice" szakasz található.</p></div><div class=exampleblock><div class=title>Példa 1. Egy példa Xorg konfigurációs állomány "InputDevice" szakasza görgõs egerekhez</div><div class=content><div class="literalblock programlisting"><div class=content><pre>Section &#34;InputDevice&#34;
   Identifier      &#34;Mouse1&#34;
   Driver          &#34;mouse&#34;
   Option          &#34;Protocol&#34; &#34;auto&#34;
   Option          &#34;Device&#34; &#34;/dev/sysmouse&#34;
   Option          &#34;Buttons&#34; &#34;5&#34;
   Option          &#34;ZAxisMapping&#34; &#34;4 5&#34;
EndSection</pre></div></div></div></div><div class=exampleblock><div class=title>Példa 2. Egy egyszerû példa ".emacs" állomány görgõs egerek (opcionális) használatához</div><div class=content><div class="literalblock programlisting"><div class=content><pre>;; görgõs egér
(global-set-key [mouse-4] &#39;scroll-down)
(global-set-key [mouse-5] &#39;scroll-up)</pre></div></div></div></div></div><div class=sect2><h3 id=_hogyan_lehet_távoli_x_szervereket_elérni>11.9. Hogyan lehet távoli X szervereket elérni?<a class=anchor href=#_hogyan_lehet_távoli_x_szervereket_elérni></a></h3><div class=paragraph><p>Biztonsági okokból a szerver alapértelmezés szerint nem engedélyezi, hogy egy távoli géprõl ablakot lehessen nyitni rajta.</p></div><div class=paragraph><p>Ha szükségünk lenne erre a lehetõségre, akkor nem kell mást tennünk, mint az X-et a <code>-listen_tcp</code> paraméterrel indítani:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% startx <span class=nt>-listen_tcp</span></code></pre></div></div></div><div class=sect2><h3 id=_mi_az_a_virtuális_konzol_és_hogyan_lehet_belõle_többet_létrehozni>11.10. Mi az a virtuális konzol és hogyan lehet belõle többet létrehozni?<a class=anchor href=#_mi_az_a_virtuális_konzol_és_hogyan_lehet_belõle_többet_létrehozni></a></h3><div class=paragraph><p>A virtuális konzolok röviden szólva arra alkalmasak, hogy egyetlen gépen is több párhuzamos munkamenetben tudjunk dolgozni, hálózat vagy X beállítása nélkül.</p></div><div class=paragraph><p>Amikor a rendszer elindul, a rendszerüzenetek után általában egy bejelentkezõ képernyõ jelenik meg. Ekkor az elsõ virtuális konzolon keresztül tudjuk megadni a felhasználói nevünket és jelszavunkat, majd nekilátni a munkának (vagy éppen a játszadozásnak).</p></div><div class=paragraph><p>Késõbb aztán elõfordulhat, hogy egy másik munkamenetet is szeretnénk elindítani, például elõkeresni az éppen használt program dokumentációját vagy elolvasni a leveleinket, amíg FTP-n keresztül letöltünk egy állományt. Ehhez nem kell mást csinálnunk, csak le kell nyomni az <span class=keyseq><kbd>Alt</kbd>+<kbd>F2</kbd></span> (tartsuk lenyomva az <kbd>Alt</kbd> billentyût miközben megnyomjuk az <kbd>F2</kbd> billentyût) billentyûkombinációt és máris egy másik virtuális konzolon találjuk magunkat! Ha innen vissza szeretnénk térni az elõzõ munkamenetbe, akkor nyomjuk le az <span class=keyseq><kbd>Alt</kbd>+<kbd>F1</kbd></span> billentyûkombinációt.</p></div><div class=paragraph><p>A frissen telepített FreeBSD rendszerekben alapértelmezés szerint nyolc virtuális konzol engedélyezett. Az <span class=keyseq><kbd>Alt</kbd>+<kbd>F1</kbd></span>, <span class=keyseq><kbd>Alt</kbd>+<kbd>F2</kbd></span>, <span class=keyseq><kbd>Alt</kbd>+<kbd>F3</kbd></span>, stb. lenyomásával tudunk váltogatni köztük.</p></div><div class=paragraph><p>Ha ennél többet szeretnénk egyszerre használni, akkor nyissuk meg az <span class=filename>/etc/ttys</span> állományt (lásd <a href="https://man.freebsd.org/cgi/man.cgi?query=ttys&amp;sektion=5&amp;format=html">ttys(5)</a>) és a "Virtual terminals" részben vegyünk még fel a <span class=filename>ttyv8</span> eszköz után továbbiakat, egészen a <span class=filename>ttyvc</span> eszközig:</p></div><div class="literalblock programlisting"><div class=content><pre># Írjuk át az eredeti ttyv8 bejegyzést az /etc/ttys
# állományban és engedélyezzük.
ttyv8   &#34;/usr/libexec/getty Pc&#34;         cons25  on secure
ttyv9   &#34;/usr/libexec/getty Pc&#34;         cons25  on secure
ttyva   &#34;/usr/libexec/getty Pc&#34;         cons25  on secure
ttyvb   &#34;/usr/libexec/getty Pc&#34;         cons25  on secure</pre></div></div><div class=paragraph><p>Akármennyit használhatunk belõlük. Ne felejtsük el azonban, hogy minél több virtuális terminálunk van, annál több erõforrásra lesz hozzájuk szükségünk. Ezt leginkább akkor érdemes megfontolni, ha 8 MB memóriánál kevesebbel rendelkezünk. Emellett még érdemes a <code>secure</code> értéket is az <code>insecure</code> értékre átállítani.</p></div><div class="admonitionblock important"><table><tbody><tr><td class=icon><i class="fa icon-important" title=Important></i></td><td class=content><div class=paragraph><p>Ha X szervert is akarunk futtatni, akkor legalább egy virtuális konzolt szabadon (vagy kikapcsolva) <em>kell</em> hagynunk a számára. Így tehát, ha mind a tizenkét funkcióbillentyûre szeretnénk elindítani egy-egy virtuális konzolt, nos, akkor nincs szerencsénk - ha X szervert is akarunk használni a gépen, akkor legfeljebb csak tizenegyet használhatunk belõlük.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Az egyes konzolokat legegyszerûbben úgy tudjuk letiltani, ha kikapcsoljuk ezeket. Például, ha az elõbb említettek szerint tizenkét terminálunk van, és X-et akarunk futtatni, akkor a tizenkettedik terminál beállításait meg kell változtatnunk errõl:</p></div><div class="literalblock programlisting"><div class=content><pre>ttyvb   &#34;/usr/libexec/getty Pc&#34;         cons25  on  secure</pre></div></div><div class=paragraph><p>erre:</p></div><div class="literalblock programlisting"><div class=content><pre>ttyvb   &#34;/usr/libexec/getty Pc&#34;         cons25  off secure</pre></div></div><div class=paragraph><p>Amennyiben a billentyûzetünkön csak tíz funkcióbillentyû található, elengedõ ennyi is:</p></div><div class="literalblock programlisting"><div class=content><pre>ttyv9   &#34;/usr/libexec/getty Pc&#34;         cons25  off secure
ttyva   &#34;/usr/libexec/getty Pc&#34;         cons25  off secure
ttyvb   &#34;/usr/libexec/getty Pc&#34;         cons25  off secure</pre></div></div><div class=paragraph><p>(Ezeket a sorokat akár ki is törölhetjük.)</p></div><div class=paragraph><p>Ezt követõen a legegyszerûbben (és egyben a legtisztábban) úgy tudjuk aktiválni a virtuális konzolokat, ha újraindítjuk a rendszerünket. Ha viszont nem akarjuk ezt feltétlenül megtenni, akkor állítsuk le az X szervert, majd (<code>root</code> felhasználóként) adjuk ki az alábbi parancsot:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kill -HUP 1</span></code></pre></div></div><div class=paragraph><p>Fontos, hogy a parancs végrehajtás elõtt teljesen leállítsuk az X szervert, amennyiben az fut. Ha nem tesszük meg, akkor könnyen elõfordulhat, hogy a <code>kill</code> parancs hatására lemerevedik vagy megáll a rendszerünk.</p></div></div><div class=sect2><h3 id=_hogyan_lehet_elérni_a_virtuális_konzolokat_x_bõl>11.11. Hogyan lehet elérni a virtuális konzolokat X-bõl?<a class=anchor href=#_hogyan_lehet_elérni_a_virtuális_konzolokat_x_bõl></a></h3><div class=paragraph><p>A virtuális konzolokra a <span class=keyseq><kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>FN</kbd></span> billentyûkombinációval lehet visszaváltani. Ennek megfelelõen tehát a <span class=keyseq><kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>F1</kbd></span> kombinációval az elsõ virtuális konzolra tudunk visszaváltani.</p></div><div class=paragraph><p>Ahogy visszajutottunk a szöveges konzolra, az <span class=keyseq><kbd>Alt</kbd>+<kbd>Fn</kbd></span> billentyûkombinációval a megszokott módon tudunk váltani köztük.</p></div><div class=paragraph><p>Ha innen az X szerverre akarunk visszaváltani, akkor egyszerûen csak váltsunk arra a virtuális konzolra, ahol az X fut. Ha az X-et a paranccsorból indítottuk el (például a <code>startx</code> paranccsal), akkor az X nem arra a virtuális konzolra kapcsolódik automatikusan, amelyen a parancsot kiadtuk, hanem az utána következõ, használatban még nem levõ konzolra. Ha nyolc aktív virtuális terminálunk van, akkor az X a kilencediken fog futni, ezért ide az <span class=keyseq><kbd>Alt</kbd>+<kbd>F9</kbd></span> lenyomásával tudunk visszatérni.</p></div></div><div class=sect2><h3 id=xdm-boot>11.12. Hogyan indítható el az XDM a rendszer indításakor?<a class=anchor href=#xdm-boot></a></h3><div class=paragraph><p>Alapvetõen kétféle megközelítés létezik az <a href="https://man.freebsd.org/cgi/man.cgi?query=xdm&amp;sektion=1&amp;format=html">xdm(1)</a> elindításával kapcsolatban. Az egyik megközelítés szerint az <code>xdm</code> parancsot az <span class=filename>/etc/ttys</span> állományból (lásd <a href="https://man.freebsd.org/cgi/man.cgi?query=ttys&amp;sektion=5&amp;format=html">ttys(5)</a>) tudjuk megadni a megadott példa alapján, a másikban pedig egyszerûen az <span class=filename>rc.local</span> állományból (lásd <a href="https://man.freebsd.org/cgi/man.cgi?query=rc&amp;sektion=8&amp;format=html">rc(8)</a>) vagy a <span class=filename>/usr/local/etc/rc.d</span> könyvtárban megadható <span class=filename>X</span> szkripttel. Mind a kettõ ugyanazt képviseli, de vannak bizonyos helyzetek, ahol a kettõ közül csak az egyik mûködik. Az eredmény mind a két esetben azonos, hatásukra az X egy grafikus bejelentkezõ képernyõvel jelentkezik.</p></div><div class=paragraph><p>A <a href="https://man.freebsd.org/cgi/man.cgi?query=ttys&amp;sektion=5&amp;format=html">ttys(5)</a> módszernek van egy olyan elõnye, hogy pontosan megadja, melyik virtuális terminálon fog futni az X és a szerver elindítását az <a href="https://man.freebsd.org/cgi/man.cgi?query=init&amp;sektion=8&amp;format=html">init(8)</a> programra bízza. Az <a href="https://man.freebsd.org/cgi/man.cgi?query=rc&amp;sektion=8&amp;format=html">rc(8)</a> használata esetén viszont könnyû leállítani az <code>xdm</code> programot, ha netalán valamilyen gondunk adódna az X szerver indításakor.</p></div><div class=paragraph><p>Ha az <a href="https://man.freebsd.org/cgi/man.cgi?query=rc&amp;sektion=8&amp;format=html">rc(8)</a> állományból töltöttük be, akkor az <code>xdm</code> futtatásához semmilyen paramétert nem kell megadni (például, hogy démonként fusson). Az <a href="https://man.freebsd.org/cgi/man.cgi?query=xdm&amp;sektion=1&amp;format=html">xdm(1)</a> azonban csak az <em>összes</em> <a href="https://man.freebsd.org/cgi/man.cgi?query=getty&amp;sektion=8&amp;format=html">getty(8)</a> elindulása után indítható, máskülönben a két program ütközni fog és a konzol nem tud létrejönni. Ezt a legkönnyebben úgy lehet megakadályozni, ha az <code>xdm</code> indítása elõtt várunk kb. 10 másodpercet a szkriptben.</p></div><div class=paragraph><p>Amennyiben az <span class=filename>/etc/ttys</span> állományból adjuk ki az <code>xdm</code> parancsot, úgy továbbra is fennáll az <a href="https://man.freebsd.org/cgi/man.cgi?query=xdm&amp;sektion=1&amp;format=html">xdm(1)</a> és a <a href="https://man.freebsd.org/cgi/man.cgi?query=getty&amp;sektion=8&amp;format=html">getty(8)</a> ütközésének veszélye. Ezt például úgy tudjuk elkerülni, ha felvesszük a megfelelõ virtuális terminál sorszámát a <span class=filename>/usr/local/lib/X11/xdm/Xservers</span> állományba:</p></div><div class="literalblock programlisting"><div class=content><pre>:0 local /usr/local/bin/X vt4</pre></div></div><div class=paragraph><p>A fenti példában az X szervert a <span class=filename>/dev/ttyv3</span> eszközre irányitjuk. A számozást azonban eggyel el kell tolnunk, mert míg az X szerver egytõl számozza a virtuális konzolokat, addig a FreeBSD rendszermagja nullától.</p></div></div><div class=sect2><h3 id=_az_xconsole_indításakor_miért_jelenik_meg_a_couldnt_open_console_hibaüzenet>11.13. Az xconsole indításakor miért jelenik meg a Couldn’t open console hibaüzenet?<a class=anchor href=#_az_xconsole_indításakor_miért_jelenik_meg_a_couldnt_open_console_hibaüzenet></a></h3><div class=paragraph><p>Ha az X-et a <code>startx</code> paranccsal indítottuk el, akkor a <span class=filename>/dev/console</span> eszközre <em>nem</em> állítódnak be a szükséges engedélyek, ezért az <code>xterm -C</code> és az <code>xconsole</code> parancsok nem fognak mûködni.</p></div><div class=paragraph><p>Ez a konzolok engedélyeinek alapértelmezett beállítási módjától függ. Egy többfelhasználós rendszer esetén nem feltétlenül van szükségünk arra, hogy bármelyik felhasználó kedvére írhasson a rendszerkonzolra. Az <a href="https://man.freebsd.org/cgi/man.cgi?query=fbtab&amp;sektion=5&amp;format=html">fbtab(5)</a> állomány segítségével engedélyezni tudjuk azon felhasználók számára, akik a helyi gépen, virtuális konzolon keresztül jelentkeznek be.</p></div><div class=paragraph><p>Dióhéjban az <span class=filename>/etc/fbtab</span> állományban (lásd <a href="https://man.freebsd.org/cgi/man.cgi?query=fbtab&amp;sektion=5&amp;format=html">fbtab(5)</a>) kell kivennünk a következõ sort a megjegyzésbõl:</p></div><div class="literalblock programlisting"><div class=content><pre>/dev/ttyv0 0600 /dev/console</pre></div></div><div class=paragraph><p>Ennek köszönhetõen bárki, aki az <span class=filename>/dev/ttyv0</span> eszközön keresztül jelentkezik be a rendszerbe, el tudja érni a konzolt.</p></div></div><div class=sect2><h3 id=_régebben_egyszerû_felhasználóként_is_el_lehetett_indítani_az_xfree86_szervert_most_miért_kell_root_felhasználóként_indítani>11.14. Régebben egyszerû felhasználóként is el lehetett indítani az XFree86™ szervert. Most miért kell root felhasználóként indítani?<a class=anchor href=#_régebben_egyszerû_felhasználóként_is_el_lehetett_indítani_az_xfree86_szervert_most_miért_kell_root_felhasználóként_indítani></a></h3><div class=paragraph><p>Az X szerverek csak úgy képesek közvetlenül elérni a videokártyát, ha <code>root</code> felhasználóként futtatjuk ezeket. Az XFree86™ régebbi (3.3.6 elõtti) változatai az összes szervert úgy telepítették fel automatikusan, hogy a <code>root</code> felhasználó jogaival fussanak (setuid bittel). Ennek viszont megvan a maga nyilvánvaló biztonsági kockázata, hiszen az X szerverek általában nagy és bonyolult programok. Az XFree86™ újabb változatai azonban már pontosan ebbõl kifolyólag nem állítanak be setuid <code>root</code> bitet a szerverekre.</p></div><div class=paragraph><p>Értelemszerûen az a megoldás nem fogadható el és nem is annyira biztonságos, hogy az X szervert <code>root</code> felhasználóként futtassuk. Kétféleképpen tudjuk egyszerû felhasználóként futtatni az X-et. Használhatjuk az <code>xdm</code> vagy más egyéb bejelentkeztetõ képernyõ (mint például a <code>kdm</code>) megoldását, vagy az <code>Xwrapper</code> programot.</p></div><div class=paragraph><p>Az <code>xdm</code> egy grafikus bejelentkeztetésért felelõs démon. Általában a rendszer indításakor aktiválódik, feladata a felhasználók hitelesítése és a hozzájuk tartozó munkamenetek elindítása. Lényegében a <a href="https://man.freebsd.org/cgi/man.cgi?query=getty&amp;sektion=8&amp;format=html">getty(8)</a> és a <a href="https://man.freebsd.org/cgi/man.cgi?query=login&amp;sektion=1&amp;format=html">login(1)</a> grafikus megfelelõje. Az <code>xdm</code> démonnal kapcsolatban még <a href=http://www.xfree86.org/sos/resources.html>az XFree86™ dokumentációját</a>, illetve a GYIK-ban <a href=#xdm-boot>ezt a kérdést</a> érdemes elolvasnunk.</p></div><div class=paragraph><p>Az <code>Xwrapper</code> az X szerverhez tartozó burkolóprogram (wrapper). Ez egy apró segédprogram, amely lehetõvé teszi az X szerver manuális indítását miközben igyekszik ügyelni a biztonságra is. Elvégez néhány alapvetõ ellenõrzést a paramétereken, és ha megfelelõnek találja ezeket, akkor elindítja a megfelelõ X szervert. Ha valamiért nem akarunk bejelentkeztetõ képernyõt indítani, akkor ezt pontosan nekünk találták ki! Ha telepítettük a teljes Portgyûjteményt, akkor a <a class=package href=https://cgit.freebsd.org/ports/tree//usr/ports/x11/wrapper/>/usr/ports/x11/wrapper</a> portban találjuk meg.</p></div></div><div class=sect2><h3 id=_miért_viselkednek_furcsán_a_ps2_es_egerek_x_alatt>11.15. Miért viselkednek furcsán a PS/2-es egerek X alatt?<a class=anchor href=#_miért_viselkednek_furcsán_a_ps2_es_egerek_x_alatt></a></h3><div class=paragraph><p>Valószínûleg az egér és az egérmeghajtó kiesett a szinkronból.</p></div><div class=paragraph><p>Nagyon ritkán elõfordul, hogy a meghajtó hibásan szinkronizációs hibát jelez, és ekkor a rendszermag a következõ üzenetet küldi:</p></div><div class="literalblock programlisting"><div class=content><pre>psmintr: out of sync (xxxx != yyyy)</pre></div></div><div class=paragraph><p>Közben természetesen azt tapasztaljuk, hogy az egerünk nem mûködik rendesen.</p></div><div class=paragraph><p>Ha ilyen történne velünk, akkor tiltsuk le a meghajtó szinkronizáció ellenõrzéséért felelõs rutinjait. Ezt úgy tudjuk megtenni, ha a meghajtónak beállítjuk a <code>0x100</code> értéket. Ehhez a rendszertöltõ parancssorában a <code>-c</code> kapcsolóval tudjuk behozni a <em>UserConfig</em> részt:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>boot: <span class=nt>-c</span></code></pre></div></div><div class=paragraph><p>Ezután a <em>UserConfig</em> parancssorában gépeljük be a következõt:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>UserConfig&gt; flags psm0 0x100
UserConfig&gt; quit</code></pre></div></div></div><div class=sect2><h3 id=_miért_nem_mûködnek_a_mousesystems_által_gyártott_ps2_es_egerek>11.16. Miért nem mûködnek a MouseSystems által gyártott PS/2-es egerek?<a class=anchor href=#_miért_nem_mûködnek_a_mousesystems_által_gyártott_ps2_es_egerek></a></h3><div class=paragraph><p>Kaptunk néhány visszajelzést arra vonatkozóan, hogy a MouseSystems által gyártott PS/2-es egerek bizonyos típusai csak abban az esetben mûködnek rendesen, ha "nagy felbontású" módban használjuk ezeket. Minden más esetben az egér néha fel-felugrik a képernyõ bal felsõ sarkába.</p></div><div class=paragraph><p>Úgy tudjuk nagy felbontású módban használni az egerünket, ha a PS/2-es egérmeghajtónak a <code>0x04</code> beállítást adjuk meg. Ehhez a rendszertöltõ parancssorában gépeljük be a <code>-c</code> kapcsolót:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>boot: <span class=nt>-c</span></code></pre></div></div><div class=paragraph><p>Ahogy bejön a <em>UserConfig</em> parancssora, gépeljük be a következõt:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>UserConfig&gt; flags psm0 0x04
UserConfig&gt; quit</code></pre></div></div><div class=paragraph><p>Az elõzõ részben olvashatunk egy másik hasonló egeres problémáról.</p></div></div><div class=sect2><h3 id=_hogyan_lehet_megcserélni_a_gombokat_az_egéren>11.17. Hogyan lehet megcserélni a gombokat az egéren?<a class=anchor href=#_hogyan_lehet_megcserélni_a_gombokat_az_egéren></a></h3><div class=paragraph><p>Futtassuk le a <code>xmodmap -e "pointer = 3 2 1"</code> parancsot az <span class=filename>.xinitrc</span> vagy <span class=filename>.xsession</span> állományunkból.</p></div></div><div class=sect2><h3 id=_hogyan_lehet_betöltõképet_telepíteni_és_hol_találhatóak_ilyen_képek>11.18. Hogyan lehet betöltõképet telepíteni és hol találhatóak ilyen képek?<a class=anchor href=#_hogyan_lehet_betöltõképet_telepíteni_és_hol_találhatóak_ilyen_képek></a></h3><div class=paragraph><p>Erre a kérdésre részletes választ a FreeBSD kézikönyv <a href=https://docs.freebsd.org/hu/books/handbook/boot#boot-splash>Rendszerbetöltõ képernyõk</a> címû szakaszában kapunk.</p></div></div><div class=sect2><h3 id=_x_alatt_lehet_használni_a_billentyûzeten_található_windows_billentyûket>11.19. X alatt lehet használni a billentyûzeten található Windows billentyûket?<a class=anchor href=#_x_alatt_lehet_használni_a_billentyûzeten_található_windows_billentyûket></a></h3><div class=paragraph><p>Igen. Ehhez mindössze az <a href="https://man.freebsd.org/cgi/man.cgi?query=xmodmap&amp;sektion=1&amp;format=html">xmodmap(1)</a> használatával meg kell adni a hozzájuk tartozó funkciót.</p></div><div class=paragraph><p>Feltéve, hogy mindegyik "Windows" billentyûzet szabványos, a következõ billentyûkódok tartoznak ehhez a három plusz gombhoz:</p></div><div class=ulist><ul><li><p>115 - <kbd>Windows</kbd> billentyû, a bal oldali <kbd>Ctrl</kbd> és <kbd>Alt</kbd> billentyûk között</p></li><li><p>116 - <kbd>Windows</kbd> billentyû, az <kbd>AltGr</kbd> mellett jobbra</p></li><li><p>117 - <kbd>Menü</kbd> gomb, a jobb oldali <kbd>Ctrl</kbd> mellett balra</p></li></ul></div><div class=paragraph><p>Például így lehet beállítani a bal oldali <kbd>Windows</kbd> billentyût vesszõre:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># xmodmap -e &#34;keycode 115 = comma&#34;</span></code></pre></div></div><div class=paragraph><p>A változatatások valószínûleg csak akkor fognak életbelépni, ha újraindítjuk az ablakkezelõnket.</p></div><div class=paragraph><p>Ha azt szeretnénk, hogy a <kbd>Windows</kbd> billentyûkhöz rendelt funkciók az X indításakor automatikusan beállítódjanak, akkor tegyük az <code>xmodmap</code> parancs hívását az <span class=filename>~/.xinitrc</span> állományunkba. Sokkal jobban járunk viszont, ha ehelyett inkább az <span class=filename>~/.xmodmaprc</span> állományunkba vesszük fel az <code>xmodmap</code> beállításait, soronként egyesével, és a következõ sor tesszük az <span class=filename>~/.xinitrc</span> állományunkba:</p></div><div class="literalblock programlisting"><div class=content><pre>xmodmap $HOME/.xmodmaprc</pre></div></div><div class=paragraph><p>Például ezeket a gombokat be lehet állítani az <kbd>F13</kbd>, <kbd>F14</kbd> és <kbd>F15</kbd> billentyûkre is. Ezekre aztán az alkalmazásokban vagy az ablakkezelõben további hasznos funkciókat tudunk beállítani.</p></div><div class=paragraph><p>Ehhez a következõt kell megadnunk az <span class=filename>~/.xmodmaprc</span> állományban:</p></div><div class="literalblock programlisting"><div class=content><pre>keycode 115 = F13
keycode 116 = F14
keycode 117 = F15</pre></div></div><div class=paragraph><p>Ha például az <a class=package href=https://cgit.freebsd.org/ports/tree/x11-wm/fvwm2/>x11-wm/fvwm2</a> ablakkezelõt használjuk, akkor az <kbd>F13</kbd> gombra be tudjuk állítani a kurzor alatt álló ablak lekicsinyítésére (vagy visszanagyítására); az <kbd>F14</kbd> billentyûvel az elõtérbe tudjuk hozni a kurzor alatt levõ ablakot, vagy ha már elöl van, akkor hátra tudjuk rakni; az <kbd>F15</kbd> gomb elõhozza a munkakörnyezet (alkalmazás) menüjét még olyankor is, amikor a kurzor nincs is az asztalon. Ez utóbbi abban az esetben lehet hasznos, amikor az asztal egyáltalán nem látható (és a billentyûn látható rajz pontosan is ezt mutatja).</p></div><div class=paragraph><p>A következõ beállítások valósítják meg az imént említett funkciókat az <span class=filename>~/.fvwmrc</span> állományon belül:</p></div><div class="literalblock programlisting"><div class=content><pre>Key F13        FTIWS    A        Iconify
Key F14        FTIWS    A        RaiseLower
Key F15        A        A        Menu Workplace Nop</pre></div></div></div><div class=sect2><h3 id=_hogyan_lehet_hardveres_3d_gyorsítást_használni_az_opengl_hez>11.20. Hogyan lehet hardveres 3D gyorsítást használni az OpenGL®-hez?<a class=anchor href=#_hogyan_lehet_hardveres_3d_gyorsítást_használni_az_opengl_hez></a></h3><div class=paragraph><p>Az Xorg pillanatnyilag használt verziójától és a videokártyánktól függ, hogy tudunk-e 3D gyorsítást alkalmazni. Ha nVidia kártyánk van, akkor a portok közül telepíteni tudjuk a FreeBSD-hez készített bináris meghajtót:</p></div><div class=ulist><ul><li><p>A legújabb nVidia-kártyákat az <a class=package href=https://cgit.freebsd.org/ports/tree/x11/nvidia-driver/>x11/nvidia-driver</a> port támogatja.</p></li><li><p>A GeForce2 MX/3/4 sorozatú nVidia-kártyákat a meghajtó 96XX változata támogatja, amely az <a class=package href=https://cgit.freebsd.org/ports/tree/x11/nvidia-driver-96xx/>x11/nvidia-driver-96xx</a> portból telepíthetõ.</p></li><li><p>Az ettõl is régebbi kártyák, például a GeForce vagy Riva TNT esetén a meghajtó 71XX változata javasolt, amely az <a class=package href=https://cgit.freebsd.org/ports/tree/x11/nvidia-driver-71xx/>x11/nvidia-driver-71xx</a> porton keresztül érhetõ el.</p></li></ul></div><div class=paragraph><p>Az nVidia honlapján részletes leírást találhatunk arról, hogy melyik kártyát melyik meghajtó ismeri. Ez az információ a következõ címen érhetõ el: <a href=http://www.nvidia.com/object/IO_32667.htm>http://www.nvidia.com/object/IO_32667.htm</a>.</p></div><div class=paragraph><p>A Matrox G200/G400 esetén az <a class=package href=https://cgit.freebsd.org/ports/tree/x11-servers/mga_hal/>x11-servers/mga_hal</a> portot érdemes megnéznünk.</p></div><div class=paragraph><p>ATI Rage 128 és Radeon kártyák számára a <a href="https://man.freebsd.org/cgi/man.cgi?query=ati&amp;sektion=4&amp;format=html">ati(4)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=r128&amp;sektion=4&amp;format=html">r128(4)</a> és <a href="https://man.freebsd.org/cgi/man.cgi?query=radeon&amp;sektion=4&amp;format=html">radeon(4)</a> man oldalakat ajánljuk.</p></div><div class=paragraph><p>3dfx Voodoo 3, 4, 5 és Banshee kártyák számára az <a class=package href=https://cgit.freebsd.org/ports/tree/x11-servers/driglide/>x11-servers/driglide</a> port áll rendelkezésre.</p></div></div></div></div><div class=sect1><h2 id=_hálózatok>12. Hálózatok<a class=anchor href=#_hálózatok></a></h2><div class=sectionbody><div class=sect2><h3 id=_honnan_lehet_többet_megtudni_a_lemez_nélküli_mûködésrõl>12.1. Honnan lehet többet megtudni a lemez nélküli mûködésrõl?<a class=anchor href=#_honnan_lehet_többet_megtudni_a_lemez_nélküli_mûködésrõl></a></h3><div class=paragraph><p>A "lemez nélküli mûködés" kifejezés arra utal, hogy a FreeBSD rendszerünk hálózaton keresztül indul el, valamint a mûködéséhez szükséges állományokat nem merevlemezrõl, hanem egy szerverrõl olvassa be. Ennek részleteirõl <a href=https://docs.freebsd.org/hu/books/handbook/advanced-networking/#network-diskless>kézikönyv lemez nélküli mûködésrõl szóló részében</a> olvashatunk.</p></div></div><div class=sect2><h3 id=_a_freebsd_használható_kizárólag_csak_hálózati_útválasztóként>12.2. A FreeBSD használható kizárólag csak hálózati útválasztóként?<a class=anchor href=#_a_freebsd_használható_kizárólag_csak_hálózati_útválasztóként></a></h3><div class=paragraph><p>Igen. Ezzel kapcsolatban a kézikönyv <a href=https://docs.freebsd.org/hu/books/handbook/advanced-networking/#advanced-networking>Egyéb haladó hálózati témák</a> címû fejezetét javasoljuk elolvasásra, különös tekintettel az <a href=https://docs.freebsd.org/hu/books/handbook/advanced-networking/#network-routing>útválasztás és az átjárók</a> bemutatására.</p></div></div><div class=sect2><h3 id=_freebsd_n_keresztül_lehet_windows_operációs_rendszerrel_internetre_csatlakozni>12.3. FreeBSD-n keresztül lehet Windows® operációs rendszerrel internetre csatlakozni?<a class=anchor href=#_freebsd_n_keresztül_lehet_windows_operációs_rendszerrel_internetre_csatlakozni></a></h3><div class=paragraph><p>Ezt a kérdést általában olyanok teszik fel, akiknek két számítógépük van otthon, és ezek közül az egyiken a FreeBSD, a másikon pedig a Windows® valamelyik változata fut. A FreeBSD rendszer fog az internethez csatlakozni, és ezen keresztül szeretnénk a windowsos géprõl is elérni azt. Ez tulajdonképpen az elõzõ kérdés egy speciális esete, és remekül megoldható.</p></div><div class=paragraph><p>Ha betárcsázós kapcsolattal csatlakozunk az internethez, akkor érdemes tudnunk, hogy a felhasználói módban futó <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> tartalmaz egy <code>-nat</code> kapcsolót. A <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> programot úgy tudjuk a <code>-nat</code> kapcsolóval futtatni, ha az <span class=filename>/etc/rc.conf</span> állományban a <code>gateway_enable</code> beállítást a <em>YES</em> értékre állítjuk. Ezután állítsuk be a windowsos gépünket ennek megfelelõen és minden mûködni fog. A további részletekrõl a <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> man oldalán vagy a <a href=https://docs.freebsd.org/hu/books/handbook/ppp-and-slip/#userppp>kézikönyv felhasználói PPP-rõl szóló bejegyzésében</a> olvashatunk.</p></div><div class=paragraph><p>Amennyiben rendszerszintû PPP-t használunk vagy Ethernettel csatlakozunk az internethez, akkor a <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> démonra lesz szükségünk. Erre vonatkozóan a kézikönyv <a href=https://docs.freebsd.org/hu/books/handbook//#network-natd>natd</a> démonról szóló szakaszában találhatunk részletesebb információkat.</p></div></div><div class=sect2><h3 id=_a_freebsd_támogatja_a_slip_és_a_ppp_használatát>12.4. A FreeBSD támogatja a SLIP és a PPP használatát?<a class=anchor href=#_a_freebsd_támogatja_a_slip_és_a_ppp_használatát></a></h3><div class=paragraph><p>Igen. Érdemes elolvasnunk az <a href="https://man.freebsd.org/cgi/man.cgi?query=slattach&amp;sektion=8&amp;format=html">slattach(8)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=sliplogin&amp;sektion=8&amp;format=html">sliplogin(8)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> és <a href="https://man.freebsd.org/cgi/man.cgi?query=pppd&amp;sektion=8&amp;format=html">pppd(8)</a> man oldalakat. A <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> és a <a href="https://man.freebsd.org/cgi/man.cgi?query=pppd&amp;sektion=8&amp;format=html">pppd(8)</a> egyaránt támogatja a beérkezõ és kimenõ kapcsolatokat, miközben a <a href="https://man.freebsd.org/cgi/man.cgi?query=sliplogin&amp;sektion=8&amp;format=html">sliplogin(8)</a> kizárólag csak beérkezõ kapcsolatokkal dolgozik, valamint a <a href="https://man.freebsd.org/cgi/man.cgi?query=slattach&amp;sektion=8&amp;format=html">slattach(8)</a> pedig csak kimenõ kapcsolatokkal.</p></div><div class=paragraph><p>Ezek pontos használatáról olvassuk el a <a href=https://docs.freebsd.org/hu/books/handbook/ppp-and-slip/#ppp-and-slip>kézikönyv PPP-rõl és a SLIP-rõl szóló fejezetét</a>.</p></div><div class=paragraph><p>Ha viszont csak egy "shellen" keresztül érjük el az internetet, akkor hasznos lehet megnéznünk a <a class=package href=https://cgit.freebsd.org/ports/tree/net/slirp/>net/slirp</a> csomagot. Segítségével a helyi géprõl (korlátozott módon) hozzá tudunk férni különbözõ FTP és HTTP szolgáltatásokhoz.</p></div></div><div class=sect2><h3 id=_a_freebsd_támogat_hálózati_címfordítást_nat_vagy_maszkolást>12.5. A FreeBSD támogat hálózati címfordítást (NAT) vagy maszkolást?<a class=anchor href=#_a_freebsd_támogat_hálózati_címfordítást_nat_vagy_maszkolást></a></h3><div class=paragraph><p>Igen. Ha egy felhasználói PPP kapcsolat esetén szeretnénk hálózati címfordítást alkalmazni, akkor olvassuk el a <a href=https://docs.freebsd.org/hu/books/handbook/ppp-and-slip/#userppp>kézikönyv felhasználói PPP-vel foglalkozó részét</a>. Ha viszont más típusú hálózati kapcsolatok esetén kívánunk címfordítást használni, akkor ahhoz a kézikönyv <a href=https://docs.freebsd.org/hu/books/handbook//#network-natd>natd</a> démonnal kapcsolatos részét kell fellapoznunk.</p></div></div><div class=sect2><h3 id=_a_plip_segítségével_hogyan_tudok_két_freebsd_rendszert_összekapcsolni_párhuzamos_porton_keresztül>12.6. A PLIP segítségével hogyan tudok két FreeBSD rendszert összekapcsolni párhuzamos porton keresztül?<a class=anchor href=#_a_plip_segítségével_hogyan_tudok_két_freebsd_rendszert_összekapcsolni_párhuzamos_porton_keresztül></a></h3><div class=paragraph><p>Ezt illetõen a kézikönyv <a href=https://docs.freebsd.org/hu/books/handbook/advanced-networking/#network-plip>PLIP-rõl szóló szakaszát</a> érdemes megnéznünk.</p></div></div><div class=sect2><h3 id=_hogyan_lehet_álneveket_megadni_az_ethernet_eszközöknek>12.7. Hogyan lehet álneveket megadni az Ethernet eszközöknek?<a class=anchor href=#_hogyan_lehet_álneveket_megadni_az_ethernet_eszközöknek></a></h3><div class=paragraph><p>Amennyiben az álnév ugyanazon az alhálózaton található, mint a hozzá tartozó interfész, akkor egyszerûen csak adjuk meg a <code>netmask 0xffffffff</code> paramétert az <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a> parancs meghívásakor, például így:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig ed0 alias 192.0.2.2 netmask 0xffffffff</span></code></pre></div></div><div class=paragraph><p>Minden más esetben a hagyományos módon adjunk meg egy hálózati címet és egy hálózati maszkot:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig ed0 alias 172.16.141.5 netmask 0xffffff00</span></code></pre></div></div><div class=paragraph><p>Errõl bõvebben a <a href=https://docs.freebsd.org/hu/books/handbook/config-tuning/#configtuning-virtual-hosts>FreeBSD kézikönyvben</a> olvashatunk.</p></div></div><div class=sect2><h3 id=_a_3c503_kártya_hogyan_állítható_másik_hálózati_portra>12.8. A 3C503 kártya hogyan állítható másik hálózati portra?<a class=anchor href=#_a_3c503_kártya_hogyan_állítható_másik_hálózati_portra></a></h3><div class=paragraph><p>Ha a kártyán egy másik portot szeretnénk használni, akkor ahhoz meg kell adnunk egy további paramétert a <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a> meghívásakor. Itt az alapértelmezett port a <code>link0</code>. Ha a BNC helyett az AUI portot akarjuk használni, akkor ennek a <code>link2</code> értéket kell megadnunk. Az ilyen típusú beállítások az <span class=filename>/etc/rc.conf</span> állomány (lásd <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a>) <code>ifconfig_*</code> változóival adhatóak meg.</p></div></div><div class=sect2><h3 id=_miért_okoz_gondot_az_nfs_használata_freebsd_alatt>12.9. Miért okoz gondot az NFS használata FreeBSD alatt?<a class=anchor href=#_miért_okoz_gondot_az_nfs_használata_freebsd_alatt></a></h3><div class=paragraph><p>A személyi számítógépekben található bizonyos hálózati kártyák (szépen szólva) ügyesebbek a többieknél, ami az olyan komolyabb hálózati alkalmazások, mint például az NFS esetén gondokat okozhat.</p></div><div class=paragraph><p>Ezzel kapcsolatban <a href=https://docs.freebsd.org/hu/books/handbook/network-servers/#network-nfs>kézikönyv NFS-rõl szóló részét</a> érdemes megnéznünk.</p></div></div><div class=sect2><h3 id=_miért_nem_lehet_hálózati_állományrendszereket_csatlakoztatni_linux_alól>12.10. Miért nem lehet hálózati állományrendszereket csatlakoztatni Linux® alól?<a class=anchor href=#_miért_nem_lehet_hálózati_állományrendszereket_csatlakoztatni_linux_alól></a></h3><div class=paragraph><p>A Linux® egyes változataiban található NFS kód csak bizonyos privilegizált portokról fogad el kéréseket. Próbáljuk meg a következõt:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount -o -P linux:/valami /mnt</span></code></pre></div></div></div><div class=sect2><h3 id=_miért_nem_lehet_hálózati_állományrendszereket_csatlakoztatni_sun_típusú_rendszerek_alól>12.11. Miért nem lehet hálózati állományrendszereket csatlakoztatni Sun™ típusú rendszerek alól?<a class=anchor href=#_miért_nem_lehet_hálózati_állományrendszereket_csatlakoztatni_sun_típusú_rendszerek_alól></a></h3><div class=paragraph><p>A SunOS™ 4.<em>X</em> változatait futtató munkaállomások csak privilegizált portokról fognak el kéréseket. Próbálkozzunk az alábbi paranccsal:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount -o -P sun:/valami /mnt</span></code></pre></div></div></div><div class=sect2><h3 id=_a_mountd_miért_küld_folyton_cant_change_attributes_hibaüzenetet_és_miért_jelenik_meg_a_bad_exports_list_hibaüzenet_a_freebsd_alapú_nfs_szerveren>12.12. A mountd miért küld folyton can’t change attributes hibaüzenetet és miért jelenik meg a bad exports list hibaüzenet a FreeBSD alapú NFS szerveren?<a class=anchor href=#_a_mountd_miért_küld_folyton_cant_change_attributes_hibaüzenetet_és_miért_jelenik_meg_a_bad_exports_list_hibaüzenet_a_freebsd_alapú_nfs_szerveren></a></h3><div class=paragraph><p>Ez leginkább azért történik, mert nem jól adtuk meg az <span class=filename>/etc/exports</span> állomány tartalmát. Olvassuk át a <a href="https://man.freebsd.org/cgi/man.cgi?query=exports&amp;sektion=5&amp;format=html">exports(5)</a> man oldalt és a kéziköny <a href=https://docs.freebsd.org/hu/books/handbook/network-servers/#network-nfs>NFS-rõl</a> szóló részét, különös tekintettel az <a href=https://docs.freebsd.org/hu/books/handbook/>NFS beállítására</a>.</p></div></div><div class=sect2><h3 id=_a_nextstep_gépekkel_miért_nem_sikerül_ppp_n_keresztül_kommunikálni>12.13. A NeXTStep gépekkel miért nem sikerül PPP-n keresztül kommunikálni?<a class=anchor href=#_a_nextstep_gépekkel_miért_nem_sikerül_ppp_n_keresztül_kommunikálni></a></h3><div class=paragraph><p>Próbáljuk meg az <span class=filename>/etc/rc.conf</span> állományban (lásd <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a>) kikapcsolni a TCP kiterjesztések használatát úgy, hogy az alábbi változót a <code>NO</code> értékre állítjuk:</p></div><div class="literalblock programlisting"><div class=content><pre>tcp_extensions=NO</pre></div></div><div class=paragraph><p>A <em>Xylogic</em> által gyártott <em>Annex</em> típusú gépek esetén is javasolt megtenni a fenti változtatást.</p></div></div><div class=sect2><h3 id=_hogyan_lehet_engedélyezni_a_multicast_használatát_az_ip_n_belül>12.14. Hogyan lehet engedélyezni a multicast használatát az IP-n belül?<a class=anchor href=#_hogyan_lehet_engedélyezni_a_multicast_használatát_az_ip_n_belül></a></h3><div class=paragraph><p>A FreeBSD alapértelmezés szerint támogatja a multicast mûveleteket. Amennyiben egy multicast küldéseket közvetítõ útválasztót szeretnénk beállítani, akkor újra kell fordítanunk a rendszermagunkat a <code>MROUTING</code> beállítás használatával és elindítani a <a href="https://man.freebsd.org/cgi/man.cgi?query=mrouted&amp;sektion=8&amp;format=html">mrouted(8)</a> démont. Ez a démon úgy aktiválható a rendszer minden egyes indításakor, ha az <span class=filename>/etc/rc.conf</span> állományban az <code>mrouted_enable</code> változót <code>YES</code> értékûre állítjuk.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>A FreeBSD újabb változataiban az <a href="https://man.freebsd.org/cgi/man.cgi?query=mrouted&amp;sektion=8&amp;format=html">mrouted(8)</a> multicast útválasztó démon, a <a href="https://man.freebsd.org/cgi/man.cgi?query=map-mbone&amp;sektion=8&amp;format=html">map-mbone(8)</a> valamint az <a href="https://man.freebsd.org/cgi/man.cgi?query=mrinfo&amp;sektion=8&amp;format=html">mrinfo(8)</a> segédprogramok már nem szerepelnek az alaprendszerben. Ezek a programok már a FreeBSD Portgyûjteményében az <a class=package href=https://cgit.freebsd.org/ports/tree/net/mrouted/>net/mrouted</a> portban találhatóak meg.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Az MBONE használatához további eszközök találhatóak a külön <a href=http://www.FreeBSD.org/ports/>mbone</a> kategóriában a Portgyûjeményen belül. Ha a <code>vic</code> és <code>vat</code> nevû konferenciaszervezõ eszközöket keressük, akkor itt érdemes szétnéznünk!</p></div></div><div class=sect2><h3 id=_milyen_hálózati_kártyák_épülnek_a_dec_pci_chipkészletére>12.15. Milyen hálózati kártyák épülnek a DEC PCI chipkészletére?<a class=anchor href=#_milyen_hálózati_kártyák_épülnek_a_dec_pci_chipkészletére></a></h3><div class=paragraph><p>Glen Foster (<a href=mailto:gfoster@driver.nsta.org>gfoster@driver.nsta.org</a>) a következõ listát állította össze róluk, amelyet kiegészítettünk még néhány további elemmel:</p></div><table class="tableblock frame-all grid-all stretch"><caption class=title>Táblázat 2. A DEC PCI chipkészletére épülõ hálózati kártyák</caption><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Gyártó</th><th class="tableblock halign-left valign-top">Típus</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>ASUS</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>PCI-L101-TB</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Accton</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>ENI1203</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Cogent</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>EM960PCI</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Compex</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>ENET32-PCI</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>D-Link</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>DE-530</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Dayna</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>DP1203, DP2100</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>DEC</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>DE435, DE450</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Danpex</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>EN-9400P3</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>JCIS</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Condor JC1260</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Linksys</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>EtherPCI</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Mylex</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>LNP101</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>SMC</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>EtherPower 10/100 (Model 9332)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>SMC</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>EtherPower (Model 8432)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>TopWare</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>TE-3500P</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Znyx (2.2.<em>x</em>)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>ZX312, ZX314, ZX342, ZX345, ZX346, ZX348</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Znyx (3.<em>x</em>)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>ZX345Q, ZX346Q, ZX348Q, ZX412Q, ZX414, ZX442, ZX444, ZX474, ZX478, ZX212, ZX214 (10mbps/hd)</p></td></tr></tbody></table></div><div class=sect2><h3 id=_miért_kell_teljes_hálózati_neveket_megadni>12.16. Miért kell teljes hálózati neveket megadni?<a class=anchor href=#_miért_kell_teljes_hálózati_neveket_megadni></a></h3><div class=paragraph><p>Erre a <a href=https://docs.freebsd.org/hu/books/handbook/mail/#mail-trouble>FreeBSD kézikönyvben</a> találjuk meg a választ.</p></div></div><div class=sect2><h3 id=_miért_jelenik_meg_a_permission_denied_hibaüzenet_minden_egyes_hálózati_mûvelet_esetén>12.17. Miért jelenik meg a Permission denied hibaüzenet minden egyes hálózati mûvelet esetén?<a class=anchor href=#_miért_jelenik_meg_a_permission_denied_hibaüzenet_minden_egyes_hálózati_mûvelet_esetén></a></h3><div class=paragraph><p>Amennyiben a rendszermagot az <code>IPFIREWALL</code> beállítással fordítottuk le, akkor nem szabad elfelejtenünk, hogy ez alapértelmezés szerint minden olyan csomagot eldob, amelyet külön nem engedélyeztünk.</p></div><div class=paragraph><p>Ha véletlenül rosszul állítottuk volna be a rendszerünkön futó tûzfalat, akkor a hálózat mûködését úgy tudjuk visszaállítani, ha <code>root</code> felhasználóként kiadjuk a következõ parancsot:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ipfw add 65534 allow all from any to any</span></code></pre></div></div><div class=paragraph><p>Az <span class=filename>/etc/rc.conf</span> állományban is megadhatjuk ehhez a <code>firewall_type="open"</code> sort.</p></div><div class=paragraph><p>Ha a tûzfalak beállításáról szeretnénk többet megtudni FreeBSD alatt, akkor olvassuk el a <a href=https://docs.freebsd.org/hu/books/handbook/firewalls#firewalls>kézikönyv erre vonatkozó fejezetét</a>.</p></div></div><div class=sect2><h3 id=_az_ipfw_fwd_szabálya_miért_nem_irányít_át_más_gépekre_szolgáltatásokat>12.18. Az ipfw fwd szabálya miért nem irányít át más gépekre szolgáltatásokat?<a class=anchor href=#_az_ipfw_fwd_szabálya_miért_nem_irányít_át_más_gépekre_szolgáltatásokat></a></h3><div class=paragraph><p>Valószínûleg azért, mert nem egyszerûen a csomagok továbbítására (forward) van szükségünk, hanem hálózati címfordításra. Az "fwd" szabály pontosan azt csinálja, amirõl a nevét kapta: csomagokat továbbít, de azokon belül semmit sem változtat meg. Tegyük fel, hogy van egy ilyen szabályunk:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>01000 fwd 10.0.0.1 from any to ize 21</code></pre></div></div><div class=paragraph><p>Amikor egy csomag az <em>ize</em> célcímmel megérkezik a <em>10.0.0.1</em> gépre, akkor benne a cél címe továbbra is az <em>ize</em> lesz! A csomag célcíme <em>nem</em> fog magától megváltozni a <em>10.0.0.1</em> címre. A legtöbb gép általában eldobja azokat a csomagokat, amelyeket nem egyenesen neki címeztek. Emiatt a "fwd" szabály használata nem minden esetben úgy mûködik, ahogy arra a felhasználó számít. Ez viszont ilyen, semmilyen hiba nincs benne.</p></div><div class=paragraph><p>Részletesebb információkat a <a href=#service-redirect>szolgáltatások átirányításával foglalkozó GYIK-ban</a>, a <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> man oldalán vagy a <a href=https://www.FreeBSD.org/ports/>Portgyûjtemény</a> valamelyik port átirányítással foglalkozó portjának dokumentációjában találhatunk.</p></div></div><div class=sect2><h3 id=_hogyan_lehet_egyik_géprõl_a_másikra_szolgáltatásokat_átirányítani>12.19. Hogyan lehet egyik géprõl a másikra szolgáltatásokat átirányítani?<a class=anchor href=#_hogyan_lehet_egyik_géprõl_a_másikra_szolgáltatásokat_átirányítani></a></h3><div class=paragraph><p>Az FTP (vagy más egyéb szolgáltatás-) kéréseket a Portgyûjteményen belül található <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/socket/>sysutils/socket</a> porttal tudunk átirányítani. Az adott szolgáltatás helyett egyszerûen csak adjuk meg a <code>socket</code> parancsot és annak paramétereit, valahogy így:</p></div><div class="literalblock programlisting"><div class=content><pre>ftp stream tcp nowait nobody /usr/local/bin/socket socket ftp.minta.com ftp</pre></div></div><div class=paragraph><p>ahol az <em>ftp.minta.com</em> az a gép, ahová át akarjuk irányítani a szolgáltatást, az <em>ftp</em> pedig a konkrét szolgáltatás.</p></div></div><div class=sect2><h3 id=_hogyan_lehet_a_sávszélességet_szabályozni>12.20. Hogyan lehet a sávszélességet szabályozni?<a class=anchor href=#_hogyan_lehet_a_sávszélességet_szabályozni></a></h3><div class=paragraph><p>FreeBSD alatt alapvetõen három eszköz szolgál erre a célra. A <a href="https://man.freebsd.org/cgi/man.cgi?query=dummynet&amp;sektion=4&amp;format=html">dummynet(4)</a> a FreeBSD részeként megtalálható <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfw&amp;sektion=4&amp;format=html">ipfw(4)</a> egyik komponense. Az <a href=http://www.sonycsl.co.jp/person/kjc/programs.html>ALTQ</a> a FreeBSD-ben található <a href="https://man.freebsd.org/cgi/man.cgi?query=pf&amp;sektion=4&amp;format=html">pf(4)</a> rendszer része, az <a href=http://www.etinc.com>Emerging Technologies</a> által fejlesztett Bandwith Manager pedig egy kereskedelmi termék.</p></div></div><div class=sect2><h3 id=_miért_jelenik_meg_a_devbpf0_device_not_configured_hibaüzenet>12.21. Miért jelenik meg a /dev/bpf0: device not configured hibaüzenet?<a class=anchor href=#_miért_jelenik_meg_a_devbpf0_device_not_configured_hibaüzenet></a></h3><div class=paragraph><p>Olyan programot akarunk futtatni, amelynek szüksége van a Berkeley Packet Filter (<a href="https://man.freebsd.org/cgi/man.cgi?query=bpf&amp;sektion=4&amp;format=html">bpf(4)</a>) használatára, azonban a rendszermag ezt nem tartalmazza. Úgy tudjuk aktiválni, ha a rendszermag konfigurációs állományába felvesszük a következõ sort, majd fordítunk egy új rendszermagot:</p></div><div class="literalblock programlisting"><div class=content><pre>device bpf        # Berkeley Packet Filter</pre></div></div></div><div class=sect2><h3 id=_hogyan_lehet_a_hálózaton_elérhetõ_windows_típusú_partíciókat_csatlakoztatni_mint_ahogy_az_smbmount_csinálja_linux_alatt>12.22. Hogyan lehet a hálózaton elérhetõ Windows® típusú partíciókat csatlakoztatni, mint ahogy az smbmount csinálja Linux® alatt?<a class=anchor href=#_hogyan_lehet_a_hálózaton_elérhetõ_windows_típusú_partíciókat_csatlakoztatni_mint_ahogy_az_smbmount_csinálja_linux_alatt></a></h3><div class=paragraph><p>Erre az SMBFS eszközeit használhatjuk, amely tartalmazza az ehhez szükséges rendszermagbeli módosításokat és a hozzá tartozó felhasználói programokat. Ezek a programok és a hozzájuk tartozó <a href="https://man.freebsd.org/cgi/man.cgi?query=mount_smbfs&amp;sektion=8&amp;format=html">mount_smbfs(8)</a> man oldal az alaprendszer részei.</p></div></div><div class=sect2><h3 id=_mik_azok_az_limiting_icmpopen_portclosed_port_response_üzenetek_a_naplókban>12.23. Mik azok az Limiting icmp/open port/closed port response üzenetek a naplókban?<a class=anchor href=#_mik_azok_az_limiting_icmpopen_portclosed_port_response_üzenetek_a_naplókban></a></h3><div class=paragraph><p>Ilyen üzeneteket akkor kapunk a rendszermagtól, ha valaminek a hatására több ICMP vagy TCP reset (RST) választ küld, mint amennyit kellene. Az ICMP válaszok sokszor olyankor generálódnak, amikor használaton kívüli UDP portokat akarnak elérni a rendszerünkön. A TCP reset pedig általában olyankor keletkezik, amikor meg nem nyitott TCP porthoz akarnak csatlakozni. Többek közt ilyenek okozhatják:</p></div><div class=ulist><ul><li><p>A rendszer túlterhelését célzó, nyers erõvel indított <em>Denial of Service</em> (Dos) támadások (ellentétben az egycsomagos, adott sebezhetõség kihasználó támadásokkal).</p></li><li><p>A portok szisztematikus letapogatása, amelynek során egyszerre nagy mennyiségû portot próbálnak meg átvizsgálni (ellentétben azzal, amikor csak néhány jól ismert portot nyitnak meg).</p></li></ul></div><div class=paragraph><p>Az üzenetben olvasható elsõ szám azt mondja meg, hogy a rendszermag mennyi csomagot küldött volna, ha nem korlátoztuk volna, a második pedig magát a határt jelzi. Ezt a <code>net.inet.icmp.icmplim</code> sysctl változó segítségével tudjuk beállítani, ahogy például most megnöveljük az értékét <code>300</code>-ra:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl -w net.inet.icmp.icmplim=300</span></code></pre></div></div><div class=paragraph><p>Amennyiben le szeretnénk tiltani az ilyen jellegû üzeneteket a naplókban, viszont még továbbra is szükségünk lenne a válaszküldés korlátozására, a <code>net.inet.icmp.icmplim_output</code> sysctl változó segítségével így tudjuk ezt megtenni:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl -w net.inet.icmp.icmplim_output=0</span></code></pre></div></div><div class=paragraph><p>Végezetül, ha teljesen ki akarjuk kapcsolni a válaszküldés korlátozását, akkor állítsuk a <code>net.inet.icmp.icmplim</code> sysctl változót (lásd az elõbbi példában) a <code>0</code> nulla értékre. A korlát törlése azonban a fenti okok miatt egyáltalán nem ajánlott.</p></div></div><div class=sect2><h3 id=_mik_azok_az_arp_unknown_hardware_address_format_hibaüzenetek>12.24. Mik azok az arp: unknown hardware address format hibaüzenetek?<a class=anchor href=#_mik_azok_az_arp_unknown_hardware_address_format_hibaüzenetek></a></h3><div class=paragraph><p>Ez arra utal, hogy valamelyik gép a helyi Ethernet-alapú hálózatunkon olyan MAC-címet használ, amelynek a FreeBSD nem ismeri a formátumát. Valószínûleg olyankor kapjuk ezt a hibaüzenetet, amikor valaki más kísérletezik az Ethernet kártyája beállításaival valahol a hálózaton. Leggyakrabban kábelmodemes hálózatokon tapasztalhatunk ilyet. Megnyugodhatunk, teljesen veszélytelen, semmilyen hatással nincs a FreeBSD gépünk teljesítményére.</p></div></div><div class=sect2><h3 id=_miért_jelennek_meg_192_168_0_10_is_on_fxp1_but_got_reply_from_00151767cf82_on_rl0_üzenetek_a_konzolon_és_hogyan_lehet_ezeket_kikapcsolni>12.25. Miért jelennek meg 192.168.0.10 is on fxp1 but got reply from 00:15:17:67:cf:82 on rl0 üzenetek a konzolon és hogyan lehet ezeket kikapcsolni?<a class=anchor href=#_miért_jelennek_meg_192_168_0_10_is_on_fxp1_but_got_reply_from_00151767cf82_on_rl0_üzenetek_a_konzolon_és_hogyan_lehet_ezeket_kikapcsolni></a></h3><div class=paragraph><p>Ilyen üzeneteket akkor kapunk, amikor a hálózaton kívülrõl érkezik hozzánk váratlanul egy csomag. A letiltásukhoz állítsuk a <code>net.link.ether.inet.log_arp_wrong_iface</code> értékét <code>0</code>-ra.</p></div></div><div class=sect2><h3 id=_a_cvsup_programot_telepítése_után_nem_lehet_elindítani_mert_hibákat_jelez_mi_a_gond>12.26. A CVSup programot telepítése után nem lehet elindítani, mert hibákat jelez. Mi a gond?<a class=anchor href=#_a_cvsup_programot_telepítése_után_nem_lehet_elindítani_mert_hibákat_jelez_mi_a_gond></a></h3><div class=paragraph><p>Elõször is nézzük meg, hogy az iménti hibaüzenet mellett nem látunk-e valami hasonlót:</p></div><div class="literalblock programlisting"><div class=content><pre>/usr/libexec/ld-elf.so.1: Shared object &#34;libXaw.so.6&#34; not found</pre></div></div><div class=paragraph><p>Az ilyen jellegû hibák általában olyankor keletkeznek, amikor olyan gépre telepítjük a <a class=package href=https://cgit.freebsd.org/ports/tree/net/cvsup/>net/cvsup</a> portot, amelyen viszont nem található meg a Xorg programcsomag. Amennyiben szükségünk lenne CVSup programhoz mellékelt grafikus felületre, akkor kénytelenek leszünk mellé az Xorg programjait is telepíteni. Ha viszont egyszerûen csak parancssorból szeretnénk használni a CVSup lehetõségeit, töröljük le a korábban telepített csomagot, majd helyette rakjuk fel a <a class=package href=https://cgit.freebsd.org/ports/tree/net/cvsup-without-gui/>net/cvsup-without-gui</a> vagy a <a class=package href=https://cgit.freebsd.org/ports/tree/net/csup/>net/csup</a> portot. A FreeBSD újabb változataiban megpróbálkozhatunk a <a href="https://man.freebsd.org/cgi/man.cgi?query=csup&amp;sektion=1&amp;format=html">csup(1)</a> használatával is. Ezzel a témával részletesebban a kézikönyv <a href=https://docs.freebsd.org/hu/books/handbook/mirrors/#cvsup>CVSup használatáról</a> szóló része foglalkozik.</p></div></div></div></div><div class=sect1><h2 id=_biztonság>13. Biztonság<a class=anchor href=#_biztonság></a></h2><div class=sectionbody><div class=sect2><h3 id=_mi_az_a_járóka_sandbox>13.1. Mi az a járóka (sandbox)?<a class=anchor href=#_mi_az_a_járóka_sandbox></a></h3><div class=paragraph><p>A járóka alapvetõen egy biztonsági szakkifejezés. Két dolgot jelenthet:</p></div><div class=ulist><ul><li><p>Egy virtuális falak között futó programot, melyeket azért emeltek a program köré, hogy a feltörését követõen megakadályozzák a rendszer többi részének elérését.</p><div class=paragraph><p>A program csak a falon belül "játszhat". Ilyenkor semmilyen olyan kódot nem képes futtatni, amellyel át tudna lépni a falakon, így a használatához nem kell elõzetesen átvizsgálni a forrásait ahhoz, hogy meg tudjuk gyõzõdni a biztonságosságáról.</p></div><div class=paragraph><p>Ez a fal lehet például egy felhasználói azonosító. A <a href="https://man.freebsd.org/cgi/man.cgi?query=security&amp;sektion=7&amp;format=html">security(7)</a> és <a href="https://man.freebsd.org/cgi/man.cgi?query=named&amp;sektion=8&amp;format=html">named(8)</a> man oldalakon is ezt a definíciót találjuk meg.</p></div><div class=paragraph><p>Vegyük például az <code>ntalk</code> szolgáltatást (lásd <a href="https://man.freebsd.org/cgi/man.cgi?query=inetd&amp;sektion=8&amp;format=html">inetd(8)</a>). Ezt a szolgáltatást korábban a <code>root</code> felhasználó azonosítójával futtatták, de manapság viszont már a <code>tty</code> felhasználóval fut. A <code>tty</code> felhasználó lényegében egy olyan járóka, amely az <code>ntalk</code> szolgáltatás feltörésekor nem engedi, hogy a rendszer többi részéhez is hozzá lehessen férni.</p></div></li><li><p>A valódi gépet utánzó rendszerben futó programot. Ez már egy sokkal kifinomultabb megoldás. Ha ilyenkor valakinek sikerül betörnie a programba, akkor könnyen azt hiheti, hogy sikerült a rendszer többi részét is elérnie, de valójában csak egy szimulált gépen van, és semmilyen valós adatot nem képes módosítani.</p><div class=paragraph><p>Leggyakrabban ezt úgy szokták elérni, hogy egy könyvtárban létrehoznak egy szimulált környezetet, majd itt futtatják az adott programot a <a href="https://man.freebsd.org/cgi/man.cgi?query=chroot&amp;sektion=8&amp;format=html">chroot(8)</a> segítségével. (Ekkor az iménti könyvtár lesz a gyökérkönyvtár az adott folyamat számára, nem pedig a rendszer igazi gyökere.)</p></div><div class=paragraph><p>Másik szintén gyakori megoldás a használt állományrendszerek írásvédett csatlakoztatása, amely felett aztán kialakítanak a program számára egy látszólag írható réteget. Ilyenkor a program teljesen úgy érzékeli, hogy képes a rendszerben elérhetõ állományokat módosítani, azonban egyedül csak saját maga látja ezeket, a rendszerben futó többi program viszont nem feltétlenül.</p></div><div class=paragraph><p>Ezeket a járókákat általában úgy szokták felépíteni, hogy a felhasználók (vagy a támadók) számára teljesen észrevétlenek legyenek.</p></div></li></ul></div><div class=paragraph><p>A UNIX® két alapvetõ járókát valósít meg. Az egyik a futó programok, a másik pedig a felhasználói azonosítók szintjén mûködik.</p></div><div class=paragraph><p>Futása közben minden UNIX® program teljesen elszigetelt minden más UNIX® programtól, így az egyik nem képes módosítani a másik memóriában tárolt adatait. A Windows®-tól eltérõen, ahol ugyebár az egyik program könnyedén el tudja érni egy másik memóriaterületét, ezért a program nem képesek egymásban kárt tenni.</p></div><div class=paragraph><p>A UNIX® alatt futó programok mindig egy adott felhasználóhoz tartoznak. Ha ez nem a <code>root</code> felhasználó, akkor azzal lényegében egy tûzfalat hozunk létre a különbözõ felhasználók által birtokolt folyamatok között. A felhasználók azonosítói emellett segítenek a lemezen tárolt adatokat is elszigetelni egymástól.</p></div></div><div class=sect2><h3 id=_mi_az_a_biztonsági_szint_securelevel>13.2. Mi az a biztonsági szint (securelevel)?<a class=anchor href=#_mi_az_a_biztonsági_szint_securelevel></a></h3><div class=paragraph><p>A biztonsági szintek egy rendszermagon belül megvalósított védelmi módszert képviselnek. A pozitív értékû biztonsági szintek esetén a rendszermag korlátoz bizonyos feladatokat, amelyeket ilyenkor még a rendszeradminisztrátor (vagyis a <code>root</code> felhasználó) sem képes elvégezni. Az írás pillanatában a biztonsági szintek, több más dolog mellett, a következõk szabályozására alkalmasak:</p></div><div class=ulist><ul><li><p>a különbözõ állományjelzõk, például az <code>schg</code> (a "system immutable" jelzés) törlése;</p></li><li><p>a rendszermag memóriájának elérése a <span class=filename>/dev/mem</span> és <span class=filename>/dev/kmem</span> eszközökön keresztül;</p></li><li><p>a rendszermag moduljainak betöltése;</p></li><li><p>a tûzfal szabályainak módosítása.</p></li></ul></div><div class=paragraph><p>A jelenleg futó rendszer biztonsági szintjét a következõ parancs segítségével lehet lekérdezni:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl kern.securelevel</span></code></pre></div></div><div class=paragraph><p>A parancs eredménye az adott <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> változó (vagyis esetünkben a <code>kern.securelevel</code>) és annak értéke lesz, amely egy szám. Ez utóbbi adja meg a biztonsági szint aktuális értékét. Amennyiben ez pozitív (vagyis nullánál nagyobb), akkor érvényben vannak a biztonsági szintekhez kapcsolódó bizonyos korlátozások.</p></div><div class=paragraph><p>Egy mûködõ rendszer biztonsági szintjét nem lehet csökkenteni, hiszen ezzel tulajdonképpen hatástalanná tennénk. Ha olyan feladatot akarunk végrehajtani, amely nem pozitív biztonsági szintet igényel (például az alaprendszer frissítése vagy a dátum átállítása), akkor ahhoz elõször módosítanunk kell az <span class=filename>/etc/rc.conf</span> állományt (lásd <code>kern_securelevel</code> és <code>kern_securelevel_enable</code> változók), majd újraindítani a rendszert.</p></div><div class=paragraph><p>A biztonsági szintekkel és rájuk vonatkozó információkkal kapcsolatban olvassuk el az <a href="https://man.freebsd.org/cgi/man.cgi?query=init&amp;sektion=8&amp;format=html">init(8)</a> man oldalt.</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>A biztonsági szintek nem feltétlenül jelentenek minden problémára tökéletes megoldást. Rentegeg ismert hátulütõvel rendelkeznek, és gyakran a biztonság hamis érzetét keltik.</p></div><div class=paragraph><p>Ezzel kapcsolatban az egyik legnagyobb gond, hogy csak abban az esetben mûködik rendesen a rendszer, ha a rendszerindítás során a biztonsági szintek beállításáig minden állományt levédünk. Ha a támadó képes lefuttatni a saját programját még a biztonsági szint beállítása elõtt (amely viszont elég késõn történik meg, hiszen a rendszerindítás során számos olyan dolog feladat van, amely nem végezhetõ el magasabb biztonsági szinteken), akkor azzal az egész védelmi módszer hatástalanítható. Habár a rendszerindítás folyamán felhasznált állományok biztonságba helyezése technikailag egyáltalán nem lehetetlen, nehezebbé válik tõle a rendszer karbantartása, mivel ilyenkor az egész rendszert át kell állítanunk legalább egyfelhasználós módba és úgy módosítani a konfigurációs állományokat.</p></div><div class=paragraph><p>Ezt és az ehhez hasonló problémák gyakran felmerülnek a levelezési listákon, különösen a <a href=https://lists.FreeBSD.org/subscription/freebsd-security>FreeBSD security levelezési lista</a> archívumaiban. <a href=https://www.FreeBSD.org/search/>Ezen</a> a funkción keresztül nézhetünk után a téma részletesebb tárgyalásának. Néhányan reménykednek, hogy a biztonsági szinteket hamarosan leváltja valami sokkal finomabb beállítási lehetõségekkel rendelkezõ megoldás, azonban a dolgok még eléggé homályosak ebbõl a szempontból.</p></div><div class=paragraph><p>Figyelmeztettünk mindenkit!</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=_a_bind_named_különféle_nagyobb_sorszámú_portokat_használ_miért>13.3. A BIND (named) különféle nagyobb sorszámú portokat használ. Miért?<a class=anchor href=#_a_bind_named_különféle_nagyobb_sorszámú_portokat_használ_miért></a></h3><div class=paragraph><p>A BIND a kimenõ kérésekhez véletlenszerûen kiválaszt egy nagyobb sorszámú portot. A legújabb változataiban már minden egyes kéréshez külön véletlenszerûen keres új UDP portot. Ez bizonyos hálózati konfigurációk esetén problémákhoz vezethet, különösen olyankor, amikor a beérkezõ UDP csomagokat egy tûzfal megállítja. A tûzfalak által blokkolt porttartományok használatát az <code>avoid-v4-udp-ports</code> vagy az <code>avoid-v6-udp-ports</code> beállítással tilthatjuk le a program számára.</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Ha ezt a portot (mint például az 53) az <span class=filename>/etc/namedb/named.conf</span> állományban a <code>query-source</code> vagy a <code>query-source-v6</code> beállításokkal adjuk meg explicit módon, akkor a program nem fogja véletlenszerûen váltogatni a portokat. Határozottan javasoljuk, hogy ezekkel az opciókkal ne adjunk meg elõre rögzített portokat.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Mindenesetre örülünk, hogy ezt is valaki megkérdezte! Hiába, nem árt néha nézegetni a <a href="https://man.freebsd.org/cgi/man.cgi?query=sockstat&amp;sektion=1&amp;format=html">sockstat(1)</a> kimenetét és észrevenni benne néhány furcsaságot.</p></div></div><div class=sect2><h3 id=_a_sendmail_a_szabványos_25_ös_port_mellett_az_587_es_portot_használja_miért>13.4. A sendmail a szabványos 25-ös port mellett az 587-es portot használja! Miért?<a class=anchor href=#_a_sendmail_a_szabványos_25_ös_port_mellett_az_587_es_portot_használja_miért></a></h3><div class=paragraph><p>A sendmail újabb verzióiban felfedezhetõ levélküldési lehetõségek az 587-es portot használják. Jelenleg ezt még nem sokan használják ki, de növekszik a népszerûsége.</p></div></div><div class=sect2><h3 id=_kié_az_a_nullás_felhasználói_azonosítójú_toor_fiók_betörtek_a_gépre>13.5. Kié az a nullás felhasználói azonosítójú toor fiók? Betörtek a gépre?<a class=anchor href=#_kié_az_a_nullás_felhasználói_azonosítójú_toor_fiók_betörtek_a_gépre></a></h3><div class=paragraph><p>Ne aggódjunk! A <code>toor</code> egy "alternatív" rendszergazdai hozzáférés (a "toor" a "root" visszafelé). Korábban csak a <a href="https://man.freebsd.org/cgi/man.cgi?query=bash&amp;sektion=1&amp;format=html">bash(1)</a> parancsértelmezõ telepítésekor jött létre, azonban manapság már alapértelmezés szerint létrejön. A nem szabványos parancsértelmezõk számára találták ki, így nem a <code>root</code> alapértelmezett parancsértelmezõjét kell megváltoztatnunk. Ez különösen olyan parancsértelmezõk esetén fontos, amelyek nem részei az alaprendszernek (például a portként vagy csomagként telepített parancsértelmezõk esetén) és ezért a <span class=filename>/usr/local/bin</span> könyvtárba fognak kerülni. Ez a könyvtár alapértelmezés szerint azonban egy külön állományrendszeren található. Ha a <code>root</code> parancsértelmezõje viszont a <span class=filename>/usr/local/bin</span> könyvtárban lenne, miközben a <span class=filename>/usr</span> (vagy bármelyik más állományrendszer, amely az imént említett könyvtárat tartalmazza) nem csatlakoztatható valamilyen oknál fogva, akkor a <code>root</code> nem lenne képes bejelentkezni és kijavítani a problémát. (Noha amikor újraindítjuk a rendszerünket egyfelhasználós módban, akkor a rendszer rá fog kérdezni, hogy melyik parancsértelmezõt akarjuk használni.)</p></div><div class=paragraph><p>Egyesek nem szabványos parancsértelmezõn keresztül a <code>toor</code> felhasználóval végzik el a <code>root</code> mindennapi teendõit, így a szabványos parancsértelmezõt csak a vészhelyzetekre tartogatják. Alapértelmezés szerint a <code>toor</code> felhasználóval nem tudunk bejelentkezni, mivel nincs jelszava, ezért ha használni akarjuk, akkor elõször jelentkezzünk be a <code>root</code> felhasználóval, majd állítsunk be neki egy jelszót.</p></div></div><div class=sect2><h3 id=_a_suidperl_parancs_miért_nem_mûködik_rendesen>13.6. A suidperl parancs miért nem mûködik rendesen?<a class=anchor href=#_a_suidperl_parancs_miért_nem_mûködik_rendesen></a></h3><div class=paragraph><p>Biztonsági okokból a <code>suidperl</code> parancs alapértelmezés szerint nem kerül telepítésre. Ha forrásból frissítjük rendszerünket és azt szeretnénk, hogy ennek során a <code>suidperl</code> is leforduljon, akkor a <code>perl</code> fordításának megkezdése elõtt vegyük fel a <code>ENABLE_SUIDPERL=true</code> sort az <span class=filename>/etc/make.conf</span> állományba.</p></div></div></div></div><div class=sect1><h2 id=_ppp>14. PPP<a class=anchor href=#_ppp></a></h2><div class=sectionbody><div class=sect2><h3 id=_nem_mûködik_a_ppp8_mit_lehet_a_gond>14.1. Nem mûködik a <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a>. Mit lehet a gond?<a class=anchor href=#_nem_mûködik_a_ppp8_mit_lehet_a_gond></a></h3><div class=paragraph><p>Elsõként mindenképpen olvassuk el a <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> man oldalt és a kézikönyv <a href=https://docs.freebsd.org/hu/books/handbook/ppp-and-slip#userppp>PPP-vel</a> foglalkozó részét. A következõ paranccsal engedélyezzük a naplózást:</p></div><div class="literalblock programlisting"><div class=content><pre>set log Phase Chat Connect Carrier lcp ipcp ccp command</pre></div></div><div class=paragraph><p>Ezt a parancsot a <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> parancssorában vagy az <span class=filename>/etc/ppp/ppp.conf</span> konfigurációs állományban kell megadnunk (leginkább a <code>default</code> szakasz elejére érdemes betennünk). Gondoskodjunk róla, hogy az <span class=filename>/etc/syslog.conf</span> állomány (lásd <a href="https://man.freebsd.org/cgi/man.cgi?query=syslog.conf&amp;sektion=5&amp;format=html">syslog.conf(5)</a>) tartalmazza az alábbi sort, illetve az <span class=filename>/var/log/ppp.log</span> állomány létezzen:</p></div><div class="literalblock programlisting"><div class=content><pre>!ppp
*.*        /var/log/ppp.log</pre></div></div><div class=paragraph><p>A napló segítségével már több mindent ki tudunk deríteni a <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> mûködésérõl. Ne aggódjunk, ha nem értünk belõle semmit. Kérjünk segítséget másoktól, nekik minden bizonnyal segíteni fog a probléma felderítésében.</p></div></div><div class=sect2><h3 id=_a_ppp8_miért_bontja_a_vonalat_amikor_elindul>14.2. A <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> miért bontja a vonalat, amikor elindul?<a class=anchor href=#_a_ppp8_miért_bontja_a_vonalat_amikor_elindul></a></h3><div class=paragraph><p>Ilyen általában azért történik, mert nem tudta feloldani a hálózati nevet. Ezt a legkönnyebben úgy tudjuk orvosolni, ha az <span class=filename>/etc/host.conf</span> állományba elõre rakjuk a <code>hosts</code> sort, így a névfeloldó elõször az <span class=filename>/etc/hosts</span> állománnyal fog próbálkozni. Ezután a <span class=filename>/etc/hosts</span> állományba vegyük fel a helyi gépet. Ha nincs helyi hálózatunk, akkor így írjuk át a <code>localhost</code> sort:</p></div><div class="literalblock programlisting"><div class=content><pre>127.0.0.1        ize.minta.com ize localhost</pre></div></div><div class=paragraph><p>Minden más esetben egyszerûen csak vegyünk fel egy újabb bejegyzést a gépünkhöz. Ennek pontosabb részleteivel kapcsolatban nézzük meg a megfelelõ man oldalakat.</p></div><div class=paragraph><p>Ha mindent jól csináltunk, akkor a <code>ping -c1 hostname</code> parancs hiba nélkül tér vissza.</p></div></div><div class=sect2><h3 id=_a_ppp8_miért_nem_tárcsáz_auto_módban>14.3. A <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> miért nem tárcsáz -auto módban?<a class=anchor href=#_a_ppp8_miért_nem_tárcsáz_auto_módban></a></h3><div class=paragraph><p>Elõször is ellenõrizzük, hogy létezik az alapértelmezett útvonal. A <code>netstat -rn</code> parancs (lásd <a href="https://man.freebsd.org/cgi/man.cgi?query=netstat&amp;sektion=1&amp;format=html">netstat(1)</a>) kiadása után nagyjából a következõ két bejegyzést kell látnunk:</p></div><div class="literalblock programlisting"><div class=content><pre>Destination        Gateway            Flags     Refs     Use     Netif Expire
default            10.0.0.2           UGSc        0        0      tun0
10.0.0.2           10.0.0.1           UH          0        0      tun0</pre></div></div><div class=paragraph><p>Feltételezzük, hogy a kézikönyvbõl, a man oldalról vagy <span class=filename>ppp.conf.sample</span> állományból másoltuk ki ezeket a címeket. Ha nincs alapértelmezett útvonalunk, akkor annak az lehet az oka, hogy a <span class=filename>ppp.conf</span> állományba elfelejtettük felvenni a <code>HISADDR</code> kulcsszót.</p></div><div class=paragraph><p>Az alapértelmezett útvonal hiányának másik oka lehet még, ha az <span class=filename>/etc/rc.conf</span> állományban (lásd <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a>) beállítottunk egy alapértelmezett átjárót, de elfelejtettük az <span class=filename>ppp.conf</span> állományba betenni a következõ sort:</p></div><div class="literalblock programlisting"><div class=content><pre>delete ALL</pre></div></div><div class=paragraph><p>Ebben az esetben menjünk vissza a kézikönyv <a href=https://docs.freebsd.org/hu/books/handbook/ppp-and-slip#userppp-final>A rendszer végsõ beállítása</a> címû részéhez.</p></div></div><div class=sect2><h3 id=_mit_jelent_a_no_route_to_host_hibaüzenet>14.4. Mit jelent a No route to host hibaüzenet?<a class=anchor href=#_mit_jelent_a_no_route_to_host_hibaüzenet></a></h3><div class=paragraph><p>Általában azért jelentkezik, mert az <span class=filename>/etc/ppp/ppp.linkup</span> állományban nem adtuk meg az alábbiakat:</p></div><div class="literalblock programlisting"><div class=content><pre>MYADDR:
  delete ALL
  add 0 0 HISADDR</pre></div></div><div class=paragraph><p>Erre csak akkor van szükségünk, ha dinamikus IP-címünk van, vagy nem ismerjük az átjáró címét. Ha az interaktív módot használjuk, akkor ehhez a következõket kell begépelni csomag módba lépés után (a csomag módot a csupa nagybetûs PPP jelzi a parancssorban):</p></div><div class="literalblock programlisting"><div class=content><pre>delete ALL
add 0 0 HISADDR</pre></div></div><div class=paragraph><p>A kézikönyv <a href=https://docs.freebsd.org/hu/books/handbook/ppp-and-slip#userppp-dynamicip>A PPP és a dinamikus IP-címek</a> címû részében olvashatunk errõl bõvebben.</p></div></div><div class=sect2><h3 id=_miért_szakad_meg_a_kapcsolat_3_perc_után>14.5. Miért szakad meg a kapcsolat 3 perc után?<a class=anchor href=#_miért_szakad_meg_a_kapcsolat_3_perc_után></a></h3><div class=paragraph><p>A PPP alrendszer alapértelmezett lejárati ideje 3 perc. Ezt a beállítást a következõ sor megadásával tudjuk módosítani:</p></div><div class="literalblock programlisting"><div class=content><pre>set timeout NNN</pre></div></div><div class=paragraph><p>ahol az <em>NNN</em> másodpercekben megadja a kapcsolat lezárása elõtti inaktivitás maximális idejét. Ha az <em>NNN</em> értéke nulla, akkor a kapcsolat idõtúllépés miatt soha nem fog magától megszakadni. Ezt a parancsot a <span class=filename>ppp.conf</span> állományba tudjuk felvenni, vagy interaktív módban a parancssorban gépelhetjük be. Emellett menet közben is állítani tudjuk ezt az értéket, ha a ppp szerverre a <a href="https://man.freebsd.org/cgi/man.cgi?query=telnet&amp;sektion=1&amp;format=html">telnet(1)</a> vagy a <a href="https://man.freebsd.org/cgi/man.cgi?query=pppctl&amp;sektion=8&amp;format=html">pppctl(8)</a> segítségével rácsatlakozunk. Errõl a <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> man oldal ad részletesebb tájékoztatást.</p></div></div><div class=sect2><h3 id=_a_kapcsolat_miért_szakad_meg_nagyobb_terhelést_alatt>14.6. A kapcsolat miért szakad meg nagyobb terhelést alatt?<a class=anchor href=#_a_kapcsolat_miért_szakad_meg_nagyobb_terhelést_alatt></a></h3><div class=paragraph><p>Ha beállítottuk a Link Quality Reporting (LQR) használatát, akkor elõfordulhat, hogy túlságosan sok csomag veszik el a gépünk és a másik oldal között. A <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> ezért a vonalat rossznak érzékeli és bontja. A FreeBSD 2.2.5 változata elõtt az LQR alapértelmezés szerint engedélyezett volt. Az LQR így tiltható le:</p></div><div class="literalblock programlisting"><div class=content><pre>disable lqr</pre></div></div></div><div class=sect2><h3 id=_a_kapcsolat_miért_szakad_meg_véletlenszerûen>14.7. A kapcsolat miért szakad meg véletlenszerûen?<a class=anchor href=#_a_kapcsolat_miért_szakad_meg_véletlenszerûen></a></h3><div class=paragraph><p>Néha elõfordulhat, hogy a zajos telefonvonal esetén vagy a hívásvárakoztatás használatakor a modem bontja a vonalat, mivel (helytelenül) azt hiszi, hogy nincs kapcsolat.</p></div><div class=paragraph><p>Manapság a legtöbb modemen általában be lehet valahogy állítani, hogy mennyire legyenek elnézõek a kapcsolat ideiglenes megszakadásával szemben. Például egy U.S. Robotics® Sportster® esetén ezt tizedmásodpercekben mérik az <code>S10</code> regiszter segítségével. A modemünk ilyenkor tehát úgy tehetõ sokkal toleránsabbá, ha a következõ hívási beállítást adjuk:</p></div><div class="literalblock programlisting"><div class=content><pre>set dial &#34;...... ATS10=10 OK ......&#34;</pre></div></div><div class=paragraph><p>További részleteket a modem kézikönyvébõl tudhatunk meg.</p></div></div><div class=sect2><h3 id=_a_kapcsolat_miért_fullad_le_véletlenszerûen>14.8. A kapcsolat miért fullad le véletlenszerûen?<a class=anchor href=#_a_kapcsolat_miért_fullad_le_véletlenszerûen></a></h3><div class=paragraph><p>Sokan tapasztalják, hogy a kapcsolat minden különösebb magyarázat nélkül lefullad. Ilyenkor elsõként azt érdemes tisztázni, hogy az összeköttetés melyik oldalán történt a vonal bontása.</p></div><div class=paragraph><p>Ha belsõ modemet használunk, akkor próbáljuk meg a <a href="https://man.freebsd.org/cgi/man.cgi?query=ping&amp;sektion=8&amp;format=html">ping(8)</a> paranccsal ellenõrizni, hogy a modem TD lámpája villog-e az adatok küldésekor. Amennyiben igen (miközben az RD lámpa viszont nem), akkor a gond a vonal másik végén lesz. Ha viszont a TD nem villog, akkor a probléma a mi oldalunkon áll fenn. A belsõ modemek esetében a <span class=filename>ppp.conf</span> állományban a <code>set server</code> parancsot is érdemes megadnunk, így amikor a kapcsolat leállását tapasztaljuk, a <a href="https://man.freebsd.org/cgi/man.cgi?query=pppctl&amp;sektion=8&amp;format=html">pppctl(8)</a> segítségével rá tudunk csatlakozni a <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> démonra. Ha a hálózati kapcsolat ekkor hirtelen erõre kapna (mivel rácsatlakoztunk kívülrõl) vagy egyáltalán nem tudunk csatlakozni (feltételezve, hogy a <code>set socket</code> parancs sikeresen lefutott az induláskor), akkor a probléma még mindig nálunk lesz. Ha viszont sikerül csatlakoznunk és a vonallal még mindig gondok vannak, akkor próbáljuk a <code>set log local async</code> parancs használatával engedélyezni a helyi aszinkron naplózást, majd egy másik konzolból a <a href="https://man.freebsd.org/cgi/man.cgi?query=ping&amp;sektion=8&amp;format=html">ping(8)</a> parancs segítségével kezdjük el használni az összeköttetést. Az aszinkron naplózás jelezni fogja, ha sikerül adatokat átvinni és fogadni a kapcsolaton keresztül. Ha ilyenkor nem látunk visszafele érkezõ adatokat, akkor az arra utal, hogy a gond a vonal távoli végén van.</p></div><div class=paragraph><p>Miután sikeresen kiderítettük, hogy az adott probléma helyi vagy távoli, két lehetõségünk van:</p></div><div class=ulist><ul><li><p>Amennyiben távoli, olvassuk el a <a href=#ppp-remote-not-responding>A vonal túlsó végérõl nem érkezik válasz. Mi lehet tenni?</a> válaszát.</p></li><li><p>Amennyiben helyi, olvassuk el a <a href=#ppp-hung>A ppp(8) teljesen megállt. Mi lehet tenni?</a> válaszát.</p></li></ul></div></div><div class=sect2><h3 id=ppp-remote-not-responding>14.9. A vonal túlsó végérõl nem érkezik válasz. Mi lehet tenni?<a class=anchor href=#ppp-remote-not-responding></a></h3><div class=paragraph><p>Ezzel szemben nagyon keveset tudunk mi, felhasználók tenni. A legtöbb internetszolgáltató egyszerûen nem hajlandó segítséget nyújtani abban az esetben, ha nem valamelyik Microsoft® operációs rendszert használjuk. A <span class=filename>ppp.conf</span> állományunkban a <code>enable lqr</code> sor megadásával engedélyezni tudjuk a <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> számára, hogy észlelhesse a távoli hibákat és bontsa a vonalat, de ez a vizsgálat viszonylag idõigényes és ennélfogva nem túlságosan hasznos. A szolgáltatónknak pedig ne nagyon emlegessük, hogy felhasználói PPP-t futtatunk.</p></div><div class=paragraph><p>Elõször próbáljunk meg letiltani mindenféle tömörítést a következõ sor megadásával:</p></div><div class="literalblock programlisting"><div class=content><pre>disable pred1 deflate deflate24 protocomp acfcomp shortseq vj
deny pred1 deflate deflate24 protocomp acfcomp shortseq vj</pre></div></div><div class=paragraph><p>Kapcsolódjunk újra és ellenõrizzük, hogy továbbra is mûködõképes a kapcsolat. Ha ennek hatására javul a helyzet vagy a probléma teljesen megoldódik, akkor a beállítások egyenkénti próbálgatásával keressük meg, hogy melyik okozta a gondot. Ez már elegendõ lesz ahhoz, hogy komolyabban felvegyük a kapcsolatot a szolgáltatónkkal (habár ebbõl gyorsan ki fog derülni, hogy nem Microsoft® terméket használunk).</p></div><div class=paragraph><p>Mielõtt szólnánk a szolgáltatónknak, a gépünkön engedélyezzük az aszinkron naplózást és várjuk meg, amíg a kapcsolat újra megszakad. Erre nem árt felkészülnünk, mert viszonylag sok tárhelyet igényel. Innen majd a portról utoljára olvasott adat lesz a lényeges. Ez általában szöveges adat és akár a probléma konkrét okára is utalhat (<code>Memory fault</code>, <code>Core dumped</code>?).</p></div><div class=paragraph><p>Ha segítõkész szolgáltatót választottuk, akkor a naplózást akár az õ oldalunkon is engedélyezhetjük, így amikor a vonal megszakad, az õ szemszögükbõl is képesek leszünk elemezni a problémát. Ilyen esetben nyugodtan küldjünk egy levelet Brian Somers &lt;<a href=mailto:brian@FreeBSD.org>brian@FreeBSD.org</a>> címére vagy kérjük meg a szolgáltatónkat, hogy közvetlenül vele tárgyaljon.</p></div></div><div class=sect2><h3 id=ppp-hung>14.10. A <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> teljesen megállt. Mi lehet tenni?<a class=anchor href=#ppp-hung></a></h3><div class=paragraph><p>A legjobban úgy járunk, ha a <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> programot nyomkövetési információkkal fordítjuk újra, majd a <a href="https://man.freebsd.org/cgi/man.cgi?query=gdb&amp;sektion=1&amp;format=html">gdb(1)</a> segítségével lekérünk egy hívási láncot az éppen megakadt ppp példánytól. A ppp alkalmazást a következõ parancsokkal tudjuk úgy újrafordítani, hogy tartalmazza a kívánt információkat:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gdb ppp `pgrep ppp`</span></code></pre></div></div><div class=paragraph><p>Ezt követõen a gdb parancssorában a <code>bt</code> és <code>where</code> parancsok segítségével hozzá tudunk jutni a hívási lánchoz. Mentsük el valahova a gdb által kinyert adatokat, majd a <code>detach</code> paranccsal váljunk le a futó programról és a <code>quit</code> begépelésével lépjünk ki a gdb programból.</p></div><div class=paragraph><p>Végezetül az elmentett eredményeket küldjük el Brian Somers &lt;<a href=mailto:brian@FreeBSD.org>brian@FreeBSD.org</a>> címére.</p></div></div><div class=sect2><h3 id=_miért_nem_történik_semmi_a_login_ok_üzenet_után>14.11. Miért nem történik semmi a Login OK! üzenet után?<a class=anchor href=#_miért_nem_történik_semmi_a_login_ok_üzenet_után></a></h3><div class=paragraph><p>A FreeBSD 2.2.5 elõtti kiadásaiban a <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> az összeköttetés létrejötte után megvárta, hogy a távoli pont kezdeményezze a kapcsolatvezérlõ protokoll (Line Control Protocol, LCP) használatát. Sok szolgáltató azonban nem csinál ilyet, ehelyett inkább a klienstõl várják mindezt. Az LCP kezdeményezését így kényszeríthetjük ki a <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> használata során:</p></div><div class="literalblock programlisting"><div class=content><pre>set openmode active</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Általában semmilyen gond nem származik abból, ha a mind a két oldal kezdeményez, így az <code>openmode</code> alapértelmezés szerint <code>active</code> értékû. A következõ szakaszban azonban bemutatjuk mikor <em>gondot okoz</em> a használata.</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=_folyamatosan_magic_is_same_hibák_jelennek_meg_ez_mire_utal>14.12. Folyamatosan Magic is same hibák jelennek meg. Ez mire utal?<a class=anchor href=#_folyamatosan_magic_is_same_hibák_jelennek_meg_ez_mire_utal></a></h3><div class=paragraph><p>Csatlakozás után idõnként elõfordulhat, hogy <code>magic is the same</code> hibaüzeneteket látunk a naplóban. Ezek az üzenetek bizonyos esetekben teljesen ártalmatlanok, máskor viszont akár komolyabb problémákat is jelezhet. A legtöbb PPP implementáció nem él túl egy ilyen hibát, és még ha látszólag létre is jön ilyenkor a kapcsolat, folyamatosan konfigurációs kérések és válaszok jönnek-mennek a naplóban egészen addig, amíg a <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> végül fel nem adja és lezárja a kapcsolatot.</p></div><div class=paragraph><p>Ez általában olyan szervereken jelenik meg, ahol nem elég gyorsak a lemezek és minden kapcsolathoz elindítanak egy <a href="https://man.freebsd.org/cgi/man.cgi?query=getty&amp;sektion=8&amp;format=html">getty(8)</a> és a bejelentkezéskor vagy azt következõ elindítják a <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> programot. Egyes visszajelzések szerint ilyen egyébként gyakran elõfordul a slirp használatakor. A problémát egyébként a <a href="https://man.freebsd.org/cgi/man.cgi?query=getty&amp;sektion=8&amp;format=html">getty(8)</a> és a <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> indítása között eltelt idõ okozza, amikor a kliens oldalán futó <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> elkezdi küldeni a kapcsolatvezérlõ (Line Control Protocol, LCP) csomagokat. Mivel ilyenkor az ECHO még mindig aktív a szerver adott portján, a kliens <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> a saját csomagjainak "tükrözõdését" fogja látni.</p></div><div class=paragraph><p>Az LCP beállításának része az összeköttetés két oldalán egy-egy bûvös szám ("magic number") megállapítása, amellyel ezután észlelhetõek az ilyen "tükrözõdések". A protokoll szerint amikor a két pont megpróbálja ugyanazt a bûvös számot használni, akkor visszautasítja (NAK jelzést küld) és egy másikat választ. Ha ilyenkor még a szerver portján aktív az ECHO, akkor a kliens oldali <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> azt tapasztalja, hogy elkezd LCP csomagokat küldeni, majd mivel ugyanazt kapja vissza, erre egy NAK jelzést válaszol. Ugyanígy látja magát a NAK jelzést (aminek hatására a <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> megváltoztatja a bûvös számát) is. Ennek eredményeképpen hirtelen nagy mennyiségû bûvösszám-váltás keletkezik, ami pedig szépen felhalmozódik a szerver terminálpufferében. Ahogy a <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> végre elindul a szerveren, elönti ez a rengeteg információ, aminek alapján sikertelennek ítéli meg az LCP beállítását és feladja a további próbálkozást. Eközben a kliens számára megszûnnek a visszaverõdõ csomagok és csak annyit lát, hogy a szerver bontja a kapcsolatot.</p></div><div class=paragraph><p>Ezt úgy tudjuk elkerülni, ha a <span class=filename>ppp.conf</span> állományban a távoli pontra bízzuk az beállítás kezdeményezését:</p></div><div class="literalblock programlisting"><div class=content><pre>set openmode passive</pre></div></div><div class=paragraph><p>Ennek hatására a <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> megvárja, hogy a szerver kezdeményezze az LCP beállítását. Egyes szerverek azonban sosem teszik meg ezt. Ilyenkor valami ilyesmit tudunk tenni:</p></div><div class="literalblock programlisting"><div class=content><pre>set openmode active 3</pre></div></div><div class=paragraph><p>Így a <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> 3 másodpercig passzív marad, majd csak ezután kezd el LCP kérésket küldeni. Ha a távoli pont eközben küld valamilyen kérést, az <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> azonnal válaszol rá és nem várja végig a 3 másodperces idõtartamot.</p></div></div><div class=sect2><h3 id=_az_lcp_beállítása_egészen_a_kapcsolat_befejezõdéséig_folytatódik_mi_lehet_a_probléma>14.13. Az LCP beállítása egészen a kapcsolat befejezõdéséig folytatódik. Mi lehet a probléma?<a class=anchor href=#_az_lcp_beállítása_egészen_a_kapcsolat_befejezõdéséig_folytatódik_mi_lehet_a_probléma></a></h3><div class=paragraph><p>A <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> programban jelenleg van egy olyan hibásan implementált jellemzõ, ahol az LCP, CCP és IPCP válaszokat nem társítja az eredeti kérésekhez. Ennek következményeképpen, ha az egyik PPP implementáció 6 másodperccel lassabb a másik oldalnál, akkor az még két további LCP konfigurációs kérést is küld, ami viszont végzetesnek bizonyul.</p></div><div class=paragraph><p>Vegyünk például két implementációt, az <code>A</code> és a <code>B</code> pontokat. Az <code>A</code> már közvetlenül a csatlakozás után LCP kéréseket kezd el küldeni, miközben a <code>B</code> csak 7 másodperc múlva tud elindulni. Mire végre a <code>B</code> pont is elindul, addigra az <code>A</code> már kiküldött 3 LCP kérést. Most feltételezzük, hogy nincs ECHO, máskülönben az elõzõ szakaszban leírt, bûvös számokkal kapcsolatos problémába ütköznénk. A <code>B</code> ekkor tehát küld egy kérést, majd nyugtázza az <code>A</code> ponttól kapott korábbi kérést. Ennek hatására az <code>A</code> pont OPENED állapotba megy át, újra küld és nyugtázza az elõzõ kérést <code>B</code> felé. Eközben a <code>B</code> további két nyugtázást küld az <code>A</code> pontról kapott további két kérésre, a <code>B</code> indulása elõttrõl. A <code>B</code> ekkor megkapja az <code>A</code> elsõ nyugtáját és átvált OPENED állapotba. Az <code>A</code> ekkor megkapja a második nyugtát a <code>B</code> ponttól és visszavált REQ-SENT állapotba, majd az RFC szerint elküld (elõre) egy újabb kérést. Ekkor megkapja a harmadik nyugtát és OPENED állapotba vált. Eközben a <code>B</code> megkapja elõre küldött kérést a <code>A</code> ponttól, amelynek hatására ACK-SENT állapotba vált vissza, és az RFC szerint ismét küld egy (második) kérést és egy nyugtázást. Az <code>A</code> erre megkapja a kérést, visszavált REQ-SENT állapotban és küld egy újabb kérést. Ekkor közvetlenül megkapja a rákövetkezõ nyugtázást és átvált OPENED állapotba.</p></div><div class=paragraph><p>Ez egészen addig folytatódik, amíg az egyik oldal rá nem eszmél, hogy ennek nincs túlságosan sok értelme és feladja a próbálkozást.</p></div><div class=paragraph><p>Ez legkönnyebben úgy kerülhetõ el, ha ilyenkor az egyik oldalt <code>passive</code> típusúra állítjuk, vagyis az egyik oldalon várunk egy keveset a beállítás kezdeményezésére. Ezt a következõ paranccsal lehet megoldani:</p></div><div class="literalblock programlisting"><div class=content><pre>set openmode passive</pre></div></div><div class=paragraph><p>Óvatosan bánjunk ezzel a paraméterrel! A beállítás kezdeményezésének várakoztatási idejét a következõ paraméterrel tudjuk megadni:</p></div><div class="literalblock programlisting"><div class=content><pre>set stopped N</pre></div></div><div class=paragraph><p>Használhatjuk viszont ezt a parancsot is (ahol <em>N</em> adja meg, hogy mennyi másodperc teljen el a beállítás megkezdése elõtt):</p></div><div class="literalblock programlisting"><div class=content><pre>set openmode active N</pre></div></div><div class=paragraph><p>Az ezzel kapcsolatos további részleteket a man oldalon olvashatjuk.</p></div></div><div class=sect2><h3 id=_miért_akad_meg_a_ppp8_ha_egy_külsõ_parancsot_adunk_ki_alatta>14.14. Miért akad meg a <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a>, ha egy külsõ parancsot adunk ki alatta?<a class=anchor href=#_miért_akad_meg_a_ppp8_ha_egy_külsõ_parancsot_adunk_ki_alatta></a></h3><div class=paragraph><p>A <code>shell</code> vagy <code>!</code> parancsok végrehajtásakor a <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> elindít egy parancsértelmezõt (illetve ha paramétereket is adtunk meg, akkor a <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> átadja azokat is), majd megvárja annak befejezõdését. Ha a parancs futtatása közben éppen egy PPP kapcsolatot akartunk használni, akkor erre az idõre az elõbbiek miatt látszólag meg fog állni. Ez tehát azért történik, mert a <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> megvárja a parancs lefutását.</p></div><div class=paragraph><p>Ha nem akarjuk megvárni a parancs befejezõdését, akkor inkább használjuk a <code>!bg</code> parancsot. Ennek hatására az adott parancs a háttérben fog lefutni és a <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> képes lesz folyamatosan szemmel tartani az összeköttetést.</p></div></div><div class=sect2><h3 id=_a_ppp8_null_modem_kábel_használatakor_miért_nem_lép_ki_soha>14.15. A <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> null-modem kábel használatakor miért nem lép ki soha?<a class=anchor href=#_a_ppp8_null_modem_kábel_használatakor_miért_nem_lép_ki_soha></a></h3><div class=paragraph><p>A <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> ilyen esetekben nem képes magától megállapítani, hogy mikor bontották a vonalat. Ennek oka a tûk null-modem kábelben kiosztott szerepében keresendõ. Amikor ilyen típusú kapcsolattal dolgozunk, a következõ sor megadásával ne felejtsük el engedélyezni az LQR használatát:</p></div><div class="literalblock programlisting"><div class=content><pre>enable lqr</pre></div></div><div class=paragraph><p>Ha a távoli pont LQR csomagokat küld, akkor a <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> alapértelmezés szerint fogadja azokat.</p></div></div><div class=sect2><h3 id=_a_ppp8_miért_tárcsáz_látszólag_minden_különösebb_ok_nélkül_auto_módban>14.16. A <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> miért tárcsáz látszólag minden különösebb ok nélkül -auto módban?<a class=anchor href=#_a_ppp8_miért_tárcsáz_látszólag_minden_különösebb_ok_nélkül_auto_módban></a></h3><div class=paragraph><p>Amennyiben a <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> szándékainkkal szemben váratlanul kezdene el tárcsázni, akkor keressük meg kiváltó okát és használjunk hívási szûrést (Dial filter, dfilter) ennek megelõzésére.</p></div><div class=paragraph><p>A tárcsázás okát a következõ sor használatával tudjuk kideríteni:</p></div><div class="literalblock programlisting"><div class=content><pre>set log +tcp/ip</pre></div></div><div class=paragraph><p>Ennek hatására a kapcsolaton keresztüláramló összes forgalmat naplózni fogjuk. Így a legközelebb, amikor a vonal hirtelen aktív lesz, a hozzá tartozó idõbélyegek alapján könnyen elõ tudjuk keresni, hogy pontosan miért is történt.</p></div><div class=paragraph><p>Az automatikus tárcsázást bizonyos esetekben le tudjuk tiltani. Ez általában egy olyan probléma, amely a névfeloldások miatt keletkezik. Úgy tudjuk megakadályozni, hogy a névfeloldások felépítsék a kapcsolatot (ami viszont <em>nem</em> gátolja abban a <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> programot, hogy egy már meglevõ kapcsolaton keresztül küldjön ilyen csomagokat), ha az alábbi beállításokat adjuk meg:</p></div><div class="literalblock programlisting"><div class=content><pre>set dfilter 1 deny udp src eq 53
set dfilter 2 deny udp dst eq 53
set dfilter 3 permit 0/0 0/0</pre></div></div><div class=paragraph><p>Ezek az értékek nem minden esetben megfelelõek számunkra, hiszen ezzel együtt az igény szerinti tárcsázás kényelmét is szûkítjük, mivel a legtöbb program közvetlenül névfeloldással kezd, mielõtt komolyabb hálózati forgalmat bonyolítana le.</p></div><div class=paragraph><p>A névfeloldás esetében igyekezzünk kideríteni, hogy pontosan melyik program is próbál hálózati neveket feloldatni. Az esetek többségében valószínûleg a <a href="https://man.freebsd.org/cgi/man.cgi?query=sendmail&amp;sektion=8&amp;format=html">sendmail(8)</a> lesz a bûnös. Amennyiben ez a helyzet, akkor az sendmail démonnak a saját konfigurációs állományában kell beállítanunk, hogy ne oldasson fel hálózati neveket. Az érintett konfigurációs állomány módosításának pontos részleteirõl a kézikönyv <a href=https://docs.freebsd.org/hu/books/handbook/mail/#smtp-dialup>Levelezés betárcsázós kapcsolattal</a> címû szakszában olvashatunk bõvebben. Továbbá az <span class=filename>.mc</span> állományunkba a következõ sort is érdemes felvennünk:</p></div><div class="literalblock programlisting"><div class=content><pre>define(`confDELIVERY_MODE&#39;, `d&#39;)dnl</pre></div></div><div class=paragraph><p>Ezzel a sendmail beindításáig mindent egy sorban fog eltárolni (általában a sendmail démont a <code>-bd -q30m</code> paraméterekkel szokták meghívni, ami arra utasítja, hogy 30 percenként dolgozza fel a sorát) vagy amíg a <code>sendmail -q</code> parancs le nem fut (például a <span class=filename>ppp.linkup</span> állományból).</p></div></div><div class=sect2><h3 id=_mit_jelentenek_a_ccp_hibák>14.17. Mit jelentenek a CCP hibák?<a class=anchor href=#_mit_jelentenek_a_ccp_hibák></a></h3><div class=paragraph><p>A naplóban folyamatosan a következõ üzeneteket lehet látni:</p></div><div class="literalblock programlisting"><div class=content><pre>CCP: CcpSendConfigReq
CCP: Received Terminate Ack (1) state = Req-Sent (6)</pre></div></div><div class=paragraph><p>Ilyenek azért keletkeznek, mert a <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> a <code>Predictor1</code> tömörítési eljárást próbálja meg beállítani, azonban a távoli pont egyáltalán semmilyen tömörítést nem akar használni. Az ilyen üzenetek többnyire ártalmatlanok, de ha el akarjuk tüntetni ezeket, akkor próbáljuk meg a következõ módon kikapcsolni a <code>Predictor1</code> tömörítés használatát:</p></div><div class="literalblock programlisting"><div class=content><pre>disable pred1</pre></div></div></div><div class=sect2><h3 id=_a_ppp8_miért_nem_naplózza_a_kapcsolat_sebességét>14.18. A <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> miért nem naplózza a kapcsolat sebességét?<a class=anchor href=#_a_ppp8_miért_nem_naplózza_a_kapcsolat_sebességét></a></h3><div class=paragraph><p>A modemmel végzett teljes "beszélgetés" szövegének rögzítéséhez a következõket kell engedélyezni:</p></div><div class="literalblock programlisting"><div class=content><pre>set log +connect</pre></div></div><div class=paragraph><p>Ennek eredményeképpen a <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> egészen az utolsóként lekért karakterláncig naplóz mindent.</p></div><div class=paragraph><p>Ha PAP vagy CHAP hitelesítést használunk (ezért a <code>CONNECT</code> parancs kiadása után már nincs semmi "mondanivalónk" a hívószkriptben, tehát nincs <code>set login</code> szkript), és szeretnénk látni a csatlakozási sebességet, ne felejtsük el utasítani a <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> programot, hogy a teljes <code>CONNECT</code> sort kérje le, valahogy így:</p></div><div class="literalblock programlisting"><div class=content><pre>set dial &#34;ABORT BUSY ABORT NO\\sCARRIER TIMEOUT 4 \
  \&#34;\&#34; ATZ OK-ATZ-OK ATDT\\T TIMEOUT 60 CONNECT \\c \\n&#34;</pre></div></div><div class=paragraph><p>Itt most megkapjuk a <code>CONNECT</code> sort, ezután nem küldünk semmit, majd várunk egy soremelést, aminek hatására a <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> arra kényszerül, hogy a teljes <code>CONNECT</code> választ beolvassa.</p></div></div><div class=sect2><h3 id=_a_ppp8_miért_hagyja_figyelmen_kívül_a_karaktereket_a_szkriptekben>14.19. A <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> miért hagyja figyelmen kívül a \ karaktereket a szkriptekben?<a class=anchor href=#_a_ppp8_miért_hagyja_figyelmen_kívül_a_karaktereket_a_szkriptekben></a></h3><div class=paragraph><p>A ppp a konfigurációs állományokból minden sort külön beolvas, ezért a <code>set phone "123 456 789"</code> és hozzá hasonló karakterláncok esetén képes felismerni, hogy a megadott számok valójában <em>egyetlen</em> paramétert formáznak. A <code>"</code> megadásához a visszaper karaktert (<code>\</code>) kell használnunk.</p></div><div class=paragraph><p>Amikor tárcsázásért felelõs értelmezõ beolvassa az egyes paramétereket, újraértelmezi ezeket olyan speciális helyettesítési szekvenciák után kutatva, mint például a <code>\P</code> vagy <code>\T</code> (részletesebben lásd a man oldalon). A kettõs elemzés miatt nekünk is a megfelelõ számban kell megadnunk ezeket a helyettesítendõ karaktereket.</p></div><div class=paragraph><p>Ha tehát egy <code>\</code> karaktert szeretnénk átküldeni a modemünknek, akkor nagyjából valami ilyesmit kellene írnunk:</p></div><div class="literalblock programlisting"><div class=content><pre>set dial &#34;\&#34;\&#34; ATZ OK-ATZ-OK AT\\\\X OK&#34;</pre></div></div><div class=paragraph><p>Ennek az eredménye a következõ lesz:</p></div><div class="literalblock programlisting"><div class=content><pre>ATZ
OK
AT\X
OK</pre></div></div><div class=paragraph><p>Vagy:</p></div><div class="literalblock programlisting"><div class=content><pre>set phone 1234567
set dial &#34;\&#34;\&#34; ATZ OK ATDT\\T&#34;</pre></div></div><div class=paragraph><p>Ez pedig a következõ szekvenciát adja:</p></div><div class="literalblock programlisting"><div class=content><pre>ATZ
OK
ATDT1234567</pre></div></div></div><div class=sect2><h3 id=_a_ppp8_miért_küld_segmentation_fault_hibát_miközben_nem_is_keletkezik_ppp_core_állomány>14.20. A <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> miért küld Segmentation Fault hibát, miközben nem is keletkezik ppp.core állomány?<a class=anchor href=#_a_ppp8_miért_küld_segmentation_fault_hibát_miközben_nem_is_keletkezik_ppp_core_állomány></a></h3><div class=paragraph><p>A ppp (vagy más hasonló program) elméletileg soha nem hoz létre <span class=filename>.core</span> állományt. Mivel a <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> tulajdonképpen a nullás felhasználói azonosítóval fut, az operációs rendszer soha nem fogja a <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> memórialenyomatát leállítása elõtt a lemezre menteni. Ha viszont <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> mûködése valóban leáll egy szegmentációs hiba vagy bármilyen más <span class=filename>.core</span> állományt eredményezõ jelzés miatt, <em>és</em> valóban a legfrissebb változatát használjuk (lásd a fejezet elejét), akkor a következõt tehetjük:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/src/usr.sbin/ppp</span>
<span class=c># echo STRIP= &gt;&gt; /etc/make.conf</span>
<span class=c># echo CFLAGS+=-g &gt;&gt; /etc/make.conf</span>
<span class=c># make install clean</span></code></pre></div></div><div class=paragraph><p>A fenti parancsokkal telepíteni tudjuk a <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> egy nyomonkövethetõ változatát. A <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> futtatásához <code>root</code> felhasználónak kell lennünk, mivel minden korábbi engedélyét felülírtuk az elõbbiek során. A <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> indításakor ne felejtsük el megjegyezni pontosan az aktuális könyvtárat sem.</p></div><div class=paragraph><p>Innentõl kezdve, amikor a <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> kap egy szegmentációs hibára vonatkozó jelzést, létre fog hozni egy <span class=filename>ppp.core</span> nevû állományt. Ennek birtokában a következõt kell csinálnunk:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% su
<span class=c># gdb /usr/sbin/ppp ppp.core</span>
<span class=o>(</span>gdb<span class=o>)</span> bt
..
<span class=o>(</span>gdb<span class=o>)</span> f 0
..
<span class=o>(</span>gdb<span class=o>)</span> i args
..
<span class=o>(</span>gdb<span class=o>)</span> l
..</code></pre></div></div><div class=paragraph><p>Az így beszerzett információkat mellékelve nagyobb valószínûséggel kaphatunk választ az ezzel kapcsolatos kérdésünkre.</p></div><div class=paragraph><p>Ha járatosak vagyunk a <a href="https://man.freebsd.org/cgi/man.cgi?query=gdb&amp;sektion=1&amp;format=html">gdb(1)</a> használatában, akkor a <span class=filename>.core</span> állományban további részletek és információk utáni is kutathatunk, például mi okozta a hibát, milyen változóknak ekkor milyen értékei voltak stb.</p></div></div><div class=sect2><h3 id=_miért_nem_csatlakozik_soha_az_a_program_amely_a_hívást_kezdeményezte_auto_módban>14.21. Miért nem csatlakozik soha az a program, amely a hívást kezdeményezte -auto módban?<a class=anchor href=#_miért_nem_csatlakozik_soha_az_a_program_amely_a_hívást_kezdeményezte_auto_módban></a></h3><div class=paragraph><p>Ez korábban egy ismert probléma volt a <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> használatával kapcsolatban, amikor dinamikus helyi IP-címet akart beállítani <code>-auto</code> módban. Ez a hiba az újabb változatokban már nem nincs meg (a man oldalon keressünk rá az <code>iface</code> részre).</p></div><div class=paragraph><p>A gondot az okozta, hogy amikor a tárcsázást elindító program meghívja a <a href="https://man.freebsd.org/cgi/man.cgi?query=connect&amp;sektion=2&amp;format=html">connect(2)</a> rendszerhívást, akkor a <a href="https://man.freebsd.org/cgi/man.cgi?query=tun&amp;sektion=4&amp;format=html">tun(4)</a> interfészhez tartozó IP-cím a végpontot képviselõ sockethez társul. A rendszermag létrehozza az elsõ kimenõ csomagot és kiírja a <a href="https://man.freebsd.org/cgi/man.cgi?query=tun&amp;sektion=4&amp;format=html">tun(4)</a> eszközre. A <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> ekkor beolvassa a csomagot és felépíti a kapcsolatot. Ha a <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> dinamikus IP-cím kiosztásának eredményeképpen ilyenkor az interfész címe megváltozik, akkor azzal egyidõben az eredeti socket végpont érvénytelenné válik. Így a távoli végpont felé küldött további csomagok általában eldobódnak. Ha valahogy mégis eljutnának a céljukhoz, a válasz már semmiképpen sem érkezhet meg, mivel a küldéshez használt IP-címnek már nem az adott gép a tulajdonosa.</p></div><div class=paragraph><p>Számos elméleti megközelítés létezik az imént felvázolt probléma megoldására. A legszebb az lenne, ha a távoli pont lehetõség szerint a korábban használt IP-címet osztaná ki újra. A <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> jelenlegi változata pontosan ugyanezt teszi, viszont a legtöbbi implementáció már nem.</p></div><div class=paragraph><p>Részünkrõl az bizonyulna a legegyszerûbb megoldásnak, ha a <a href="https://man.freebsd.org/cgi/man.cgi?query=tun&amp;sektion=4&amp;format=html">tun(4)</a> intefész IP-címe egyáltalán nem változhatna meg, hanem helyette menet közben az összes kimenõ csomag, köztük természetesen a forrás IP-címe az interfész IP-címérõl az idõközben beállított IP-címre változna. Ez lényegében az, amit a <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> legújabb változataiban felbukkanó <code>iface-alias</code> opció is csinál (a <a href="https://man.freebsd.org/cgi/man.cgi?query=libalias&amp;sektion=3&amp;format=html">libalias(3)</a> és a <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> <code>-nat</code> kapcsolója segítségével): karbantartja az összes korábban használt interfész címét és átfordítja ezeket az utoljára beállított címre.</p></div><div class=paragraph><p>A másik (és valószínûleg a sokkal megbízhatóbb) lehetõség egy olyan rendszerhívás implementálása lenne, amely képes az összes használatban levõ socketet egyik IP-címrõl a másik IP-címre átállítani. A <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> ekkor fel tudná használni ezt arra, hogy módosítsa az összes addig futó program socketjét az új IP-cím beállításakor. Ugyanezzel a rendszerhívással a DHCP kliensek is képesek lennének átállítani a socketjeiket.</p></div><div class=paragraph><p>Lehetõségünk van még IP-cím nélkül is létrehozni interfészeket. A kimenõ csomagok ekkor a <code>255.255.255.255</code> IP-címet használnák egészen addig, amíg az elsõ <code>SIOCAIFADDR</code> <a href="https://man.freebsd.org/cgi/man.cgi?query=ioctl&amp;sektion=2&amp;format=html">ioctl(2)</a> rendszerhívás le nem zajlik. A <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> feladata ilyenkor a forrás IP-cím megváltoztatása, de ha ez <code>255.255.255.255</code>, akkor egyedül csak az IP-címnek és az ellenõrzõösszegnek kell megváltoznia. Ez viszont már valamilyen mértékben trükközést a rendszermagon belül, mivel így könnyen tudunk csomagokat küldeni egy rosszul beállított interfészre is, feltételezve, hogy valamilyen módon képesek vagyunk ilyeneket visszamenõleg helyreállítani.</p></div></div><div class=sect2><h3 id=_a_legtöbb_játék_miért_nem_mûködik_a_nat_kapcsoló_megadásával>14.22. A legtöbb játék miért nem mûködik a -nat kapcsoló megadásával?<a class=anchor href=#_a_legtöbb_játék_miért_nem_mûködik_a_nat_kapcsoló_megadásával></a></h3><div class=paragraph><p>A játékok és a hozzájuk hasonló alkalmazások általában azért nem mûködnek, amikor a <a href="https://man.freebsd.org/cgi/man.cgi?query=libalias&amp;sektion=3&amp;format=html">libalias(3)</a> könyvtárat használjuk, mert a távoli gép megpróbál kapcsolódni a belsõ hálózatunkon levõ géphez és kéretlen UDP csomagokat kezd el küldeni neki. A címfordítást végzõ programnak fogalma sincs róla, hogy ezeket a csomagokat egy belsõ gépnek kell továbbküldenie.</p></div><div class=paragraph><p>Akkor lehetünk biztosak ebben, ha egyedül csak azt a szoftvert indítjuk el, amellyel gondjaink akadtak, majd a vagy az átjáró <a href="https://man.freebsd.org/cgi/man.cgi?query=tun&amp;sektion=4&amp;format=html">tun(4)</a> interfészét kezdjük el a <a href="https://man.freebsd.org/cgi/man.cgi?query=tcpdump&amp;sektion=1&amp;format=html">tcpdump(1)</a> segítségével, vagy pedig engedélyezzük az átjárón a <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> TCP/IP naplózó funkcióját (<code>set log +tcp/ip</code>).</p></div><div class=paragraph><p>Ahogy elindítjuk a gondokat okozó programot, látnunk kell a csomagjait, ahogy megpróbálnak keresztüljutni az átjárón. Az erre érkezõ válaszolok eldobódnak (ez jelenti a problémát). Jegyezzük fel a csomagokhoz társuló portszámokat és állítsuk el a programot. Csináljuk meg néhányszor ezt a vizsgálatot, így ellenõrizni tudjuk, hogy mindig ugyanazokat a portokat használja-e. Amennyiben úgy tapasztaljuk, hogy igen, akkor az <span class=filename>/etc/ppp/ppp.conf</span> állományba a következõ sort kell betenni a megfelelõ helyre a mûködés helyreállításához:</p></div><div class="literalblock programlisting"><div class=content><pre>nat port protokoll belsõ-gép:port port</pre></div></div><div class=paragraph><p>ahol a <em>protokoll</em> lehet <code>tcp</code> vagy <code>udp</code>, a <em>belsõ-gép</em> annak a gépnek a címe, ahova tovább akarjuk küldeni a csomagokat, valamint a <em>port</em> a csomagok célportját adja meg.</p></div><div class=paragraph><p>A fenti parancs megváltoztatása nélkül nem tudjuk ugyanezt a szoftvert más gépeken is használni, és itt azzal most nem is foglalkozunk, hogy miként lehet két belsõ géprõl használni ugyanazt a programot. Mindenesetre annyi biztos, hogy a külvilág felé a belsõ hálózatunk csupán egyetlen gépnek fog látszani.</p></div><div class=paragraph><p>Ha azt látjuk, hogy az alkalmazás nem mindig ugyanazt a portot használja, akkor három választási lehetõségünk van:</p></div><div class="olist arabic"><ol class=arabic><li><p>Készítsük el a támogatását a <a href="https://man.freebsd.org/cgi/man.cgi?query=libalias&amp;sektion=3&amp;format=html">libalias(3)</a> függvénykönyvtárhoz. A különbözõ "szélsõséges esetekre" a <span class=filename>/usr/src/sys/netinet/libalias/alias_*.c</span> állományokban találhatunk példákat (az <span class=filename>alias_ftp.c</span> tökéletes kiindulási alap). Ez általában annyit jelent, hogy beolvasunk bizonyos ismert kimenõ csomagokat, beazonosítjuk benne azt az utasítást, amelynek hatására a külsõ gép csatlakozni próbál a belsõ géphez egy adott (véletlenszerûen választott) porton, majd beállítunk hozzá egy "útvonalat", így a rákövetkezõ csomagok már tudni fogják, hogy merre menjenek.</p><div class=paragraph><p>Ez ugyan a legnehezebb megoldás, de egyben ez is a legjobb, ráadásul így a szoftver több gépen is mûködtethetõ.</p></div></li><li><p>Proxy használata. Elõfordulhat, hogy az alkalmazás támogatja a <code>socks5</code> protokollt vagy (mint ahogy a <code>cvsup</code> is csinálja) rendelkezik "passzív" móddal, és így lehetõleg igyekszik elkerülni azt, hogy a távoli géprõl kapcsolatot próbáljanak meg indítani a helyi gépre.</p></li><li><p>A <code>nat addr</code> használatával irányítsunk át mindent a belsõ gépre. Ez viszont egy nagyon durva megközelítés.</p></li></ol></div></div><div class=sect2><h3 id=_valaki_összeírta_már_a_hasznosabb_portok_sorszámait>14.23. Valaki összeírta már a hasznosabb portok sorszámait?<a class=anchor href=#_valaki_összeírta_már_a_hasznosabb_portok_sorszámait></a></h3><div class=paragraph><p>Egyelõre még nem, de szándékunkban áll összeállítani egy ilyen listát (már amennyiben igény lesz rá). Minden itt szereplõ példában az <em>belsõ</em> helyett mindig annak a gépnek a belsõ IP-címét írjuk, amelyrõl játszani akarunk.</p></div><div class=ulist><ul><li><p>Asheron’s Call</p><div class=paragraph><p><code>nat port udp belsõ :65000 65000</code></p></div><div class=paragraph><p>Manuálisan változtassuk meg a játékon belül a portszámot <code>65000</code>-re. Ha a belsõ hálózatunkról több gépen is szeretnénk játszni, akkor mindegyiknek adjuk meg egy egyedi portot (vagyis <code>65001</code>, <code>65002</code> stb.), majd vegyünk fel mindegyikhez egy-egy <code>nat port</code> sort.</p></div></li><li><p>Half Life</p><div class=paragraph><p><code>nat port udp belsõ:27005 27015</code></p></div></li><li><p>PCAnywhere 8.0</p><div class=paragraph><p><code>nat port udp belsõ:5632 5632</code></p></div><div class=paragraph><p><code>nat port tcp belsõ:5631 5631</code></p></div></li><li><p>Quake</p><div class=paragraph><p><code>nat port udp belsõ:6112 6112</code></p></div></li><li><p>Quake 2</p><div class=paragraph><p><code>nat port udp belsõ:27901 27910</code></p></div><div class=paragraph><p><code>nat port udp belsõ:60021 60021</code></p></div><div class=paragraph><p><code>nat port udp belsõ:60040 60040</code></p></div></li><li><p>Red Alert</p><div class=paragraph><p><code>nat port udp belsõ:8675 8675</code></p></div><div class=paragraph><p><code>nat port udp belsõ:5009 5009</code></p></div></li></ul></div></div><div class=sect2><h3 id=_mik_azok_az_fcs_hibák>14.24. Mik azok az FCS hibák?<a class=anchor href=#_mik_azok_az_fcs_hibák></a></h3><div class=paragraph><p>Az FCS jelentése <code>F</code>rame <code>C</code>heck <code>S</code>equence, vagyis az "Adatkeret ellenõrzésének sorozata". Mindegyik PPP csomaghoz tartozik egy ellenõrzõösszeg, amely arról gondoskodik, hogy ugyanaz az adat érkezzen meg, mint amit elküldtek. Amennyiben egy bejövõ csomag FCS értéke érvénytelennek minõsül, a csomag eldobódik és a HDLC FCS számláló értékkel eggyel növekszik. A HDLC hibaszámlálói a <code>show hdlc</code> parancs segítségével tekinthetõek meg.</p></div><div class=paragraph><p>Ha rosszul mûködik az összeköttetés (vagy a soros vonali meghajtónk folyamatosan eldobja a csomagokat), akkor láthatunk helyenként FCS hibákat. Többnyire nem érdemes az ilyenek miatt aggódni, habár ez jelentõs mértékben lassítja a tömörítést végzõ protokollok munkáját. Ha külsõ modemünk van, akkor ne felejtsük el a megfelelõ módon leárnyékolni, mivel ebbõl is származhat a probléma.</p></div><div class=paragraph><p>Ha a vonal a kapcsolódást követõen szinte azonnal lemerevedik és hirtelen nagy mennyiségû FCS hiba jelentkezik, akkor az arra is utalhat, hogy az összeköttetés nem tisztán 8 bites. Gondoskodjunk róla, hogy a modem ne a szoftveres forgalomirányítást (XON/XOFF) használja. Ha viszont az adatok közvetítéséhez mégis szoftveres forgalomirányítást <em>kell</em> használnunk, akkor a <code>set accmap 0x000a0000</code> parancs kiadásával jelezzük a <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> felé, hogy a <code>^Q</code> és <code>^S</code> karaktereket helyettesítse.</p></div><div class=paragraph><p>Nagy mennyiségû FCS hibát olyan esetekben is tapasztalhatunk, amikor a távoli pont abbahagyta a PPP üzenetek küldését. Ilyenkor javasolt engedélyezni az aszinkron naplózás használatát, aminek segítségével gyorsan meg tudjuk állapítani, hogy a beérkezõ adatok bejelentkezõ vagy shell üzeneteket. Ha a másik oldalon egy shell parancssorát kapjuk meg, akkor a <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> a <code>close lcp</code> megadásával a vonal eldobása nélkül leállítható (az utána következõ <code>term</code> paranccsal pedig a távoli gépen futó shellre tudunk csatlakozni).</p></div><div class=paragraph><p>Ha a naplókban látszólag semmi sem indokolja az összeköttetés leállását, próbáljunk meg erre rákérdezni a távoli pont (talán a szolgáltató?) karbantartójánál.</p></div></div><div class=sect2><h3 id=PPPoEwithNAT>14.25. A Mac OS® és Windows® 98 alól indított kapcsolatok miért állnak le, ha PPPoE fut az átjárón?<a class=anchor href=#PPPoEwithNAT></a></h3><div class=paragraph><p>A probléma megoldását Michael Wozniak (<a href=mailto:mwozniak@netcom.ca>mwozniak@netcom.ca</a>) adta meg, valamint Dan Flemming (<a href=mailto:danflemming@mac.com>danflemming@mac.com</a>) alkalmazta ugyanezt Macre:</p></div><div class=paragraph><p>Ennek oka az ún. útválasztási "fekete lyuk". A Mac OS® és a Windows® 98 (de valószínûleg az összes többi Microsoft® operációs rendszer) olyan nagy méretû TCP csomagokat küld, amelyek már nem férnek bele egy PPPoE keretbe (amely mérete Ethernet estén 1500 byte alapértelmezés szerint) <em>és</em> beállítja hozzá a darabolás letiltását jelzõ ("do not fragment") bitet (TCP esetén ez alapértelmezett), és a Telco útválasztó pedig nem küldi el a "must fragment" ("darabolni kell") ICMP csomagot a letölteni kívánt oldal szolgáltatója felé. (Másik lehetõség, hogy az útválasztó ugyan küld egy ilyen ICMP csomagot, de ezt a tartalomszolgáltatónál található tûzfal eldobja.) Amikor válaszul a szolgáltató olyan kereteket kezd el küldeni, amelyek nem illeszkednek a PPPoE keresztmetszetébe, a Telco útválasztó egyszerûen eldobja ezeket és a lap nem pedig nem lesz elérhetõ (egyes képek és oldalak esetén elõfordul). Úgy tûnik, ez az alapbeállítás a legtöbb Telco PPPoE konfiguráció esetében.</p></div><div class=paragraph><p>Ezt a hibát úgy javíthatjuk, ha a Windows® 95/98 rendszerekben megtalálható <code>regedit</code> segítségével felvesszük a következõ regisztrációs bejegyzést:</p></div><div class="literalblock programlisting"><div class=content><pre>HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\Class\NetTrans\0000\MaxMTU</pre></div></div><div class=paragraph><p>A karakterlánc értéke legyen <code>1436</code>, mivel bizonyos ADSL útválasztók állítólag nem képesek ennél nagyobb méretû csomagokat kezelni. Windows® 2000 esetén ezt a beállítást a <code>Tcpip\Parameters\Interfaces\a hálózati kártya azonosítója\MTU</code> helyen kell keresni és típusa duplaszó (DWORD).</p></div><div class=paragraph><p>A Windows® MTU beállításaival kapcsolatban olvassuk el a Microsoft Knowledge Base címén található dokumentumokat: <a href=http://support.microsoft.com/support/kb/articles/Q158/4/74.asp>Q158474 - Windows TCPIP Registry Entries</a> és <a href=http://support.microsoft.com/support/kb/articles/Q120/6/42.asp>Q120642 - TCPIP & NBT Configuration Parameters for Windows NT® </a>.</p></div><div class=paragraph><p>Windows® 2000 alatt a regisztrációs adatbázisban érdemes még a <code>Tcpip\Parameters\Interfaces\a hálózati kártya azonosítója\EnablePMTUBHDetect</code> duplaszó értékét <code>1</code>-re állítani, ahogy arra az imént említett 120642-es Microsoft® dokumentum is hivatkozik.</p></div><div class=paragraph><p>Sajnos a Mac OS® nem nyújt semmilyen beállítási lehetõséget a TCP/IP beállítások megváltoztatására. Léteznek viszont kereskedelmi termékek, amelyek lehetõvé teszi a felhasználók számára, hogy igényeik szerint módosítsák rendszerük TCP/IP beállításait. A hálózati címfordítást használók keressék meg az MTU beállításaikat és adják meg az <code>1450</code> értéket az eredeti <code>1500</code> helyett.</p></div><div class=paragraph><p>A <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> újabb (2.3 vagy afeletti) változatai már tartalmaznak egy <code>enable tcpmssfixup</code> parancsot, amellyel az MSS értéke tetszõlegesen átállítható. Ez alapértelmezés szerint engedélyezett. Ha valamiért mégis a <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> egy korábbi változatával kellene dolgoznunk, akkor érdemes megnéznünk <a class=package href=https://cgit.freebsd.org/ports/tree/net/tcpmssd/>net/tcpmssd</a> portot.</p></div></div><div class=sect2><h3 id=_ezek_közül_egyik_sem_használt_segítség_mit_lehetne_még_tenni>14.26. Ezek közül egyik sem használt - segítség! Mit lehetne még tenni?<a class=anchor href=#_ezek_közül_egyik_sem_használt_segítség_mit_lehetne_még_tenni></a></h3><div class=paragraph><p>Ha eddig minden más csõdött mondott, akkor próbáljuk meg elküldeni az összes beszerezhetõ információt, beleértve a konfigurációs állományokat, hogyan indítjuk el a <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> programot, a naplók fontosabb részeit és a <code>netstat -rn</code> parancs kimenetét (a csatlakozás elõtt és után) a <a href=https://lists.FreeBSD.org/subscription/freebsd-questions>FreeBSD general questions levelezési lista</a> címére vagy a <a href=news:comp.unix.bsd.freebsd.misc>comp.unix.bsd.freebsd.misc</a> hírcsoportba, és valaki talán majd megmutatja a helyes irányt.</p></div></div></div></div><div class=sect1><h2 id=_soros_vonali_kommunikáció>15. Soros vonali kommunikáció<a class=anchor href=#_soros_vonali_kommunikáció></a></h2><div class=sectionbody><div class=paragraph><p>Ebben a szakaszban a FreeBSD alatti soros vonali kommunikációval kapcsolatos kérdéseket tárgyaljuk. A PPP és SLIP használatáról a <a href=#networking>Hálózatok</a> címû részben esik szó.</p></div><div class=sect2><h3 id=_honnan_deríthetõ_ki_hogy_a_freebsd_felismerte_a_soros_portokat_a_gépben>15.1. Honnan deríthetõ ki, hogy a FreeBSD felismerte a soros portokat a gépben?<a class=anchor href=#_honnan_deríthetõ_ki_hogy_a_freebsd_felismerte_a_soros_portokat_a_gépben></a></h3><div class=paragraph><p>Ahogy a FreeBSD rendszermagja az elindulása után azokat a soros portokat fogja keresni, amelyeket a konfigurációs állományban beállítottunk. Figyeljük a rendszer indulása közben megjelenõ üzeneteket vagy adjuk ki a következõ parancsot a rendszer indulásának befejeztével:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% dmesg | <span class=nb>grep</span> <span class=nt>-E</span> <span class=s2>&#34;^sio[0-9]&#34;</span></code></pre></div></div><div class=paragraph><p>Íme egy példa az iménti parancs kimenetére:</p></div><div class="literalblock programlisting"><div class=content><pre>sio0: &lt;16550A-compatible COM port&gt; port 0x3f8-0x3ff irq 4 flags 0x10 on acpi0
sio0: type 16550A
sio1: &lt;16550A-compatible COM port&gt; port 0x2f8-0x2ff irq 3 on acpi0
sio1: type 16550A</pre></div></div><div class=paragraph><p>Ezen két soros portot láthatunk. Az elsõ a negyedik megszakítást és a <code>0x3f8</code> címet használja és egy 16550A típusú UART chip. A második ugyanolyan chip, de a harmadik megszakítást és a <code>0x2f8</code> címet használja. A belsõ modemeket a rendszer úgy kezeli, mintha soros portok lennének, azzal a kivétellel, hogy a modem mindig "kapcsolódik" az adott porthoz.</p></div><div class=paragraph><p>A <span class=filename>GENERIC</span> rendszermag alapértelmezés szerint két soros portot támogat, a példában szereplõ megszakítási- és memóriaértékek felhasználásával. Ha ezek a beállítások nem felelnek meg a rendszerünk számára, esetleg modemet raktunk a gépünkbe vagy a rendszermagban több soros portot is támogatni szeretnénk, akkor nincs más teendõnk, mint ennek megfelelõen megváltoztatni a rendszermag paramétereit. A <a href=#make-kernel>rendszermag fordításáról szóló</a> rész tárgyalja ennek részleteit.</p></div></div><div class=sect2><h3 id=_honnan_deríthetõ_ki_hogy_a_freebsd_felismerte_a_modemkártyát_a_gépben>15.2. Honnan deríthetõ ki, hogy a FreeBSD felismerte a modemkártyát a gépben?<a class=anchor href=#_honnan_deríthetõ_ki_hogy_a_freebsd_felismerte_a_modemkártyát_a_gépben></a></h3><div class=paragraph><p>Olvassuk el az elõzõ kérdésre adott választ.</p></div></div><div class=sect2><h3 id=_hogyan_lehet_a_soros_portokat_elérni_freebsd_alatt>15.3. Hogyan lehet a soros portokat elérni FreeBSD alatt?<a class=anchor href=#_hogyan_lehet_a_soros_portokat_elérni_freebsd_alatt></a></h3><div class=paragraph><p>A harmadik soros port, a <span class=filename>sio2</span> (lásd <a href="https://man.freebsd.org/cgi/man.cgi?query=sio&amp;sektion=4&amp;format=html">sio(4)</a>, DOS alatt <span class=filename>COM3</span>) a <span class=filename>/dev/cuad2</span> eszközön keresztül érhetõ el tárcsázó eszközként, és a <span class=filename>/dev/ttyd2</span> eszközön keresztül behívó eszközként. Mi a különbség a két eszközosztály között?</p></div><div class=paragraph><p>A <span class=filename>ttydX</span> eszközöket behívásra használjuk. Amikor tehát a <span class=filename>/dev/ttydX</span> eszközt blokkoló módban nyitjuk meg, akkor a hívó program egészen addig várni fog, amíg a megfelelõ <span class=filename>cuadX</span> eszköz inaktívvá nem válik, majd kivárja, hogy megérkezzen a hívás fogadását tolmácsoló jelzés. Amikor megnyitjuk a <span class=filename>cuadX</span> eszközt, gondoskodik róla, hogy a soros portot ekkor ne használja a <span class=filename>ttydX</span> eszköz. Ha a port szabaddá válik, egyszerûen "ellopja" a <span class=filename>ttydX</span> eszköztõl. Sõt, a <span class=filename>cuadX</span> eszközt egyáltalán nem érdekli a hívás fogadása jelzés. Ezzel a megoldással és egy automata modem segítségével a távoli felhasználók bármikor be tudnak jelentkezni a rendszerünkbe, hogy közben ugyanezzel a modemmel továbbra is tudunk tárcsázni, mivel a rendszer elintézi a többit.</p></div></div><div class=sect2><h3 id=_hogyan_lehet_engedélyezi_a_többportos_soros_vonali_kártyák_támogatását>15.4. Hogyan lehet engedélyezi a többportos soros vonali kártyák támogatását?<a class=anchor href=#_hogyan_lehet_engedélyezi_a_többportos_soros_vonali_kártyák_támogatását></a></h3><div class=paragraph><p>Ismét megemlítjük, hogy a rendszermag beállításával foglalkozó részben olvashatunk bõvebben a rendszermag paraméterezésének mikéntjérõl. A többportos soros vonali kártyák esetén a kártyán található mindegyik soros porthoz vegyünk fel egy-egy <a href="https://man.freebsd.org/cgi/man.cgi?query=sio&amp;sektion=4&amp;format=html">sio(4)</a> bejegyzést a <a href="https://man.freebsd.org/cgi/man.cgi?query=device.hints&amp;sektion=5&amp;format=html">device.hints(5)</a> állományába. Az IRQ és vektor értékeket azonban csak az egyiknél adjuk meg, mivel a kártyán található összes port egyetlen megszakításon fog osztozni. A következetesség kedvéért az utolsó porthoz adjuk meg a megszakítást. Ne felejtsük el még megadni a rendszermag konfigurációs állományában az alábbi opciót sem:</p></div><div class="literalblock programlisting"><div class=content><pre>options COM_MULTIPORT</pre></div></div><div class=paragraph><p>Az alábbi <span class=filename>/boot/device.hints</span> egy AST típusú négyportos soros vonali kártyát láthatunk a tizenkettedik megszakításon:</p></div><div class="literalblock programlisting"><div class=content><pre>hint.sio.4.at=&#34;isa&#34;
hint.sio.4.port=&#34;0x2a0&#34;
hint.sio.4.flags=&#34;0x701&#34;
hint.sio.5.at=&#34;isa&#34;
hint.sio.5.port=&#34;0x2a8&#34;
hint.sio.5.flags=&#34;0x701&#34;
hint.sio.6.at=&#34;isa&#34;
hint.sio.6.port=&#34;0x2b0&#34;
hint.sio.6.flags=&#34;0x701&#34;
hint.sio.7.at=&#34;isa&#34;
hint.sio.7.port=&#34;0x2b8&#34;
hint.sio.7.flags=&#34;0x701&#34;
hint.sio.7.irq=&#34;12&#34;</pre></div></div><div class=paragraph><p>A <code>flags</code> paraméterrel megadott értékek azt jelzik, hogy a fõport <code>7</code> alszámmal rendelkezik (<code>0x700</code>), valamint az összes port ugyanazon a megszakításon osztozik (<code>0x001</code>).</p></div></div><div class=sect2><h3 id=_a_freebsd_képes_több_többportos_soros_vonali_kártyát_ugyanazon_a_megszakításon_keresztül_használni>15.5. A FreeBSD képes több többportos soros vonali kártyát ugyanazon a megszakításon keresztül használni?<a class=anchor href=#_a_freebsd_képes_több_többportos_soros_vonali_kártyát_ugyanazon_a_megszakításon_keresztül_használni></a></h3><div class=paragraph><p>Sajnos még nem. Minden kártyához másik megszakítást kell megadni.</p></div></div><div class=sect2><h3 id=_hogyan_lehet_beállítani_a_portok_alapértelmezett_paramétereit>15.6. Hogyan lehet beállítani a portok alapértelmezett paramétereit?<a class=anchor href=#_hogyan_lehet_beállítani_a_portok_alapértelmezett_paramétereit></a></h3><div class=paragraph><p>Ezzel kapcsolatban olvassuk el a FreeBSD kézikönyv <a href=https://docs.freebsd.org/hu/books/handbook/serialcomms#serial-hw-config>soros kommunikációt</a> tárgyaló részét.</p></div></div><div class=sect2><h3 id=_hogyan_lehet_a_modemen_betárcsázást_beállítani>15.7. Hogyan lehet a modemen betárcsázást beállítani?<a class=anchor href=#_hogyan_lehet_a_modemen_betárcsázást_beállítani></a></h3><div class=paragraph><p>Erre vonatkozóan olvassuk el a FreeBSD kézikönyv <a href=https://docs.freebsd.org/hu/books/handbook/serialcomms/#dialup>betárcsázós szolgáltatásokkal</a> kapcsolatos részét.</p></div></div><div class=sect2><h3 id=_hogyan_lehet_buta_terminálokat_freebsd_re_csatlakoztatni>15.8. Hogyan lehet buta terminálokat FreeBSD-re csatlakoztatni?<a class=anchor href=#_hogyan_lehet_buta_terminálokat_freebsd_re_csatlakoztatni></a></h3><div class=paragraph><p>Az ezzel kapcsolatos információkat a FreeBSD kézikönyv <a href=https://docs.freebsd.org/hu/books/handbook/serialcomms/#term>terminálokról</a> szóló részében találhatjuk meg.</p></div></div><div class=sect2><h3 id=_miért_nem_indul_el_a_tip_vagy_cu_parancs>15.9. Miért nem indul el a tip vagy cu parancs?<a class=anchor href=#_miért_nem_indul_el_a_tip_vagy_cu_parancs></a></h3><div class=paragraph><p>Elõfordulhat, hogy rendszerünkön a <a href="https://man.freebsd.org/cgi/man.cgi?query=tip&amp;sektion=1&amp;format=html">tip(1)</a> és <a href="https://man.freebsd.org/cgi/man.cgi?query=cu&amp;sektion=1&amp;format=html">cu(1)</a> programok csak az <code>uucp</code> felhasználón és a <code>dialer</code> csoporton keresztül tudnak hozzáférni a mûködésükhöz szükséges <span class=filename>/var/spool/lock</span> könyvtárhoz. A <code>dialer</code> csoport segítségével lehet szabályozni, hogy ki férhessen hozzá a modemekhez vagy a távoli rendszerekhez. Ilyenkor egyszerûen csak vegyük fel magunkat a <code>dialer</code> csoportba.</p></div><div class=paragraph><p>A következõ parancs kiadásával viszont ettõl függetlenül is engedélyezhetjük a rendszerünkön belül, hogy bárki használhassa a <a href="https://man.freebsd.org/cgi/man.cgi?query=tip&amp;sektion=1&amp;format=html">tip(1)</a> vagy <a href="https://man.freebsd.org/cgi/man.cgi?query=cu&amp;sektion=1&amp;format=html">cu(1)</a> parancsokat:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># chmod 4511 /usr/bin/cu</span>
<span class=c># chmod 4511 /usr/bin/tip</span></code></pre></div></div></div><div class=sect2><h3 id=_a_rendszerhez_csatlakozó_hayes_szabványú_modem_támogatott_mi_ilyenkor_teendõ>15.10. A rendszerhez csatlakozó Hayes szabványú modem támogatott - mi ilyenkor teendõ?<a class=anchor href=#_a_rendszerhez_csatlakozó_hayes_szabványú_modem_támogatott_mi_ilyenkor_teendõ></a></h3><div class=paragraph><p>A FreeBSD kézikönyvben lásd <a href=https://docs.freebsd.org/hu/books/handbook/serialcomms#hayes-unsupported>ezt</a> a választ.</p></div></div><div class=sect2><h3 id=_hogyan_adjuk_meg_az_at_parancsokat>15.11. Hogyan adjuk meg az AT parancsokat?<a class=anchor href=#_hogyan_adjuk_meg_az_at_parancsokat></a></h3><div class=paragraph><p>A FreeBSD kézikönyvben lásd <a href=https://docs.freebsd.org/hu/books/handbook/serialcomms#direct-at>ezt</a> a választ.</p></div></div><div class=sect2><h3 id=_a_pn_tulajdonságnál_miért_nem_lehet_jelet_megadni>15.12. A pn tulajdonságnál miért nem lehet @ jelet megadni?<a class=anchor href=#_a_pn_tulajdonságnál_miért_nem_lehet_jelet_megadni></a></h3><div class=paragraph><p>A FreeBSD kézikönyvben lásd <a href=https://docs.freebsd.org/hu/books/handbook/serialcomms#gt-failure>ezt</a> a választ.</p></div></div><div class=sect2><h3 id=_hogyan_lehet_telefonszámokat_tárcsázni_parancssorból>15.13. Hogyan lehet telefonszámokat tárcsázni parancssorból?<a class=anchor href=#_hogyan_lehet_telefonszámokat_tárcsázni_parancssorból></a></h3><div class=paragraph><p>A FreeBSD kézikönyvben lásd <a href=https://docs.freebsd.org/hu/books/handbook/serialcomms#dial-command-line>ezt</a> a választ.</p></div></div><div class=sect2><h3 id=_minden_alkalommal_meg_kell_adni_az_adatátviteli_sebességet>15.14. Minden alkalommal meg kell adni az adatátviteli sebességet?<a class=anchor href=#_minden_alkalommal_meg_kell_adni_az_adatátviteli_sebességet></a></h3><div class=paragraph><p>A FreeBSD kézikönyvben lásd <a href=https://docs.freebsd.org/hu/books/handbook/serialcomms#set-bps>ezt</a> a választ.</p></div></div><div class=sect2><h3 id=_terminálszerver_segítségével_hogyan_lehet_könnyen_elérni_egyszerre_több_gépet_is>15.15. Terminálszerver segítségével hogyan lehet könnyen elérni egyszerre több gépet is?<a class=anchor href=#_terminálszerver_segítségével_hogyan_lehet_könnyen_elérni_egyszerre_több_gépet_is></a></h3><div class=paragraph><p>A FreeBSD kézikönyvben lásd <a href=https://docs.freebsd.org/hu/books/handbook/serialcomms#terminal-server>ezt</a> a választ.</p></div></div><div class=sect2><h3 id=_a_tip1_képes_több_vonalat_is_használni_az_egyes_gépek_eléréséhez>15.16. A <a href="https://man.freebsd.org/cgi/man.cgi?query=tip&amp;sektion=1&amp;format=html">tip(1)</a> képes több vonalat is használni az egyes gépek eléréséhez?<a class=anchor href=#_a_tip1_képes_több_vonalat_is_használni_az_egyes_gépek_eléréséhez></a></h3><div class=paragraph><p>A FreeBSD kézikönyvben lásd <a href=https://docs.freebsd.org/hu/books/handbook/serialcomms#tip-multiline>ezt</a> a választ.</p></div></div><div class=sect2><h3 id=_miért_kell_kétszer_lenyomni_a_ctrlp_billentyûket_hogy_egyszer_elküldjük_ezeket>15.17. Miért kell kétszer lenyomni a CtrlP billentyûket, hogy egyszer elküldjük ezeket?<a class=anchor href=#_miért_kell_kétszer_lenyomni_a_ctrlp_billentyûket_hogy_egyszer_elküldjük_ezeket></a></h3><div class=paragraph><p>A FreeBSD kézikönyvben lásd <a href=https://docs.freebsd.org/hu/books/handbook/serialcomms#multi-contorlp>ezt</a> a választ.</p></div></div><div class=sect2><h3 id=_miért_lett_hirtelen_minden_nagybetûs>15.18. Miért lett hirtelen minden NAGYBETûS?<a class=anchor href=#_miért_lett_hirtelen_minden_nagybetûs></a></h3><div class=paragraph><p>A FreeBSD kézikönyvben lásd <a href=https://docs.freebsd.org/hu/books/handbook/serialcomms#uppercase>ezt</a> a választ.</p></div></div><div class=sect2><h3 id=_hogyan_lehet_állományokat_mozgatni_a_tip_használatával>15.19. Hogyan lehet állományokat mozgatni a tip használatával?<a class=anchor href=#_hogyan_lehet_állományokat_mozgatni_a_tip_használatával></a></h3><div class=paragraph><p>A FreeBSD kézikönyvben lásd <a href=https://docs.freebsd.org/hu/books/handbook/serialcomms#tip-filetransfer>ezt</a> a választ.</p></div></div><div class=sect2><h3 id=_hogyan_használható_a_zmodem_protokoll_a_tip_programmal>15.20. Hogyan használható a zmodem protokoll a tip programmal?<a class=anchor href=#_hogyan_használható_a_zmodem_protokoll_a_tip_programmal></a></h3><div class=paragraph><p>A FreeBSD kézikönyvben lásd <a href=https://docs.freebsd.org/hu/books/handbook/serialcomms#zmode-tip>ezt</a> a választ.</p></div></div></div></div><div class=sect1><h2 id=_egyéb_kérdések>16. Egyéb kérdések<a class=anchor href=#_egyéb_kérdések></a></h2><div class=sectionbody><div class=sect2><h3 id=_a_freebsd_miért_használ_sokkal_több_lapozóállományt_mint_a_linux>16.1. A FreeBSD miért használ sokkal több lapozóállományt, mint a Linux®?<a class=anchor href=#_a_freebsd_miért_használ_sokkal_több_lapozóállományt_mint_a_linux></a></h3><div class=paragraph><p>A FreeBSD csupán látszólag használ több helyet a lapozásra, mint a Linux®, valójában egyébként nem. A FreeBSD és a Linux® közt az egyik leglényegesebb különbség, hogy a FreeBSD valamivel elõre gondolkodik, és az összes pillanatnyilag nem használt lapot kilapozza a központi memóriából a lapozóterületre. Ezzel igyekszik minél több memóriát elõkészíteni az aktív használatra. A Linux® ezzel szemben a lapozást csak végsõ esetben használja. Ennek megfelelõen a lapozóterület gyakoribb használatát remekül ellensúlyozza a fizikai memória hatékonyabb kihasználása.</p></div><div class=paragraph><p>Habár a FreeBSD igyekszik ebben a tekintetben elõrelátó lenni, nem minden esetben tudja pontosan eldönteni, hogy a rendszerben mely lapokat nem használják éppen. Emiatt nem fogja az összes memóriát kilapozni, ha például egész éjszakára futni hagyjuk a gépünket.</p></div></div><div class=sect2><h3 id=_a_top_miért_jelez_kevés_szabad_memóriát_miközben_csak_néhány_program_fut>16.2. A top miért jelez kevés szabad memóriát, miközben csak néhány program fut?<a class=anchor href=#_a_top_miért_jelez_kevés_szabad_memóriát_miközben_csak_néhány_program_fut></a></h3><div class=paragraph><p>Röviden úgy válaszolhatnánk meg ezt a kérdést, hogy a szabad memória igazából elvesztegetett memória. A programok által szabadon hagyott memóriát a FreeBSD rendszermagja többnyire a lemez gyorsítótárazására használja fel. A <a href="https://man.freebsd.org/cgi/man.cgi?query=top&amp;sektion=1&amp;format=html">top(1)</a> kimenetében olvasható <code>Inact</code>, <code>Cache</code> és <code>Buf</code> értékek a lényegében különbözõ öregedési szintek szerint kategorizált tárazott adatok. A tárazás lényegében arra utal, hogy a rendszernek így nem a lassú elérésû lemezen kell a gyakran elérni kívánt adatok után kutatni, aminek köszönhetõen növekszik az összteljesítmény. A <a href="https://man.freebsd.org/cgi/man.cgi?query=top&amp;sektion=1&amp;format=html">top(1)</a> kimenetében tehát <code>Free</code> kategória alacsony értéke alapvetõen jót jelent, feltéve, ha nem <em>nagyon</em> kevés.</p></div></div><div class=sect2><h3 id=_a_chmod_miért_nem_változtatja_meg_a_szimbolikus_linkek_engedélyeit>16.3. A chmod miért nem változtatja meg a szimbolikus linkek engedélyeit?<a class=anchor href=#_a_chmod_miért_nem_változtatja_meg_a_szimbolikus_linkek_engedélyeit></a></h3><div class=paragraph><p>A szimbolikus linkekhez alapértelmezés szerint nem tartoznak engedélyek, ezért a <a href="https://man.freebsd.org/cgi/man.cgi?query=chmod&amp;sektion=1&amp;format=html">chmod(1)</a> ilyen esetekben az eredeti állomány engedélyeit változtatja meg. Ezért például, ha adott egy <span class=filename>ize</span> nevû állomány, valamint erre egy <span class=filename>mize</span> nevû szimbolikus link, akkor a következõ parancs mindig mûködni fog:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>chmod </span>g-w mize</code></pre></div></div><div class=paragraph><p>Ennek ellenére az <span class=filename>mize</span> engedélyei nem fognak megváltozni.</p></div><div class=paragraph><p>Ha egy adott könyvtárszerkezetben elhelyezkedõ állományok engedélyeit akarjuk egyszerre módosítani, akkor a <code>-R</code> opció mellett a <code>-H</code> vagy <code>-L</code> opciókat is meg kell adnunk. Errõl részletesebb információkat a <a href="https://man.freebsd.org/cgi/man.cgi?query=chmod&amp;sektion=1&amp;format=html">chmod(1)</a> és a <a href="https://man.freebsd.org/cgi/man.cgi?query=symlink&amp;sektion=7&amp;format=html">symlink(7)</a> man oldalairól tudhatunk meg.</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>A <a href="https://man.freebsd.org/cgi/man.cgi?query=chmod&amp;sektion=1&amp;format=html">chmod(1)</a> <code>-R</code> opciója <em>rekurzív</em> mûködést tesz lehetõvé. Óvatosan bánjunk a könyvtárakkal vagy a könyvtárakra mutató szimbolikus linkekkel a <a href="https://man.freebsd.org/cgi/man.cgi?query=chmod&amp;sektion=1&amp;format=html">chmod(1)</a> használata során. Ha egy szimbolikus link által hivatkozott könyvtár engedélyeit akarjuk megváltoztatni, akkor a <a href="https://man.freebsd.org/cgi/man.cgi?query=chmod&amp;sektion=1&amp;format=html">chmod(1)</a> parancsnak ne adjunk meg semmilyen paramétert és a nevet zárjuk perjellel (<span class=filename>/</span>). Például, ha az <span class=filename>ize</span> a <span class=filename>mize</span> könyvtárra mutató szimbolikus link, és meg akarjuk változtatni az <span class=filename>ize</span> engedélyeit (ami valójában a <span class=filename>mize</span> engedélyeit jelenti), akkor valami ilyesmit kellene megadnunk:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>chmod </span>555 ize/</code></pre></div></div><div class=paragraph><p>A név végén szereplõ perjelbõl a <a href="https://man.freebsd.org/cgi/man.cgi?query=chmod&amp;sektion=1&amp;format=html">chmod(1)</a> tudni fogja, hogy követnie kell a <span class=filename>foo</span> szimbolikus linket és így az általa hivatkozott könyvtár, a <span class=filename>mize</span> engedélyeit fogja megváltoztatni.</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=_a_freebsd_képes_dos_programokat_futtatni>16.4. A FreeBSD képes DOS programokat futtatni?<a class=anchor href=#_a_freebsd_képes_dos_programokat_futtatni></a></h3><div class=paragraph><p>Igen, a Portgyûjteményben található <a class=package href=https://cgit.freebsd.org/ports/tree/emulators/doscmd/>emulators/doscmd</a>, vagyis egy DOS emulációs program segítségével.</p></div><div class=paragraph><p>Amennyiben a doscmd önmagában még nem lenne elegendõ, egy másik segédprogram, a <a class=package href=https://cgit.freebsd.org/ports/tree/emulators/pcemu/>emulators/pcemu</a> segítségével emulálni tudunk egy 8088-as processzort, valamint a BIOS annyi részét, hogy futtatni tudjunk szöveges DOS alkalmazásokat. A használatához az X Window Systemre is szükségünk lesz.</p></div><div class=paragraph><p>Érdemes ezenkívül még megpróbálnunk a FreeBSD Portgyûjteményében található <a class=package href=https://cgit.freebsd.org/ports/tree/emulators/dosbox/>emulators/dosbox</a> portot is. Ez az alkalmazás elsõsorban a régi DOS-os játékok futtatásához szükséges környezet emulációjára koncentrál, a helyi állományrendszerben található állományok felhasználásával.</p></div></div><div class=sect2><h3 id=_hogyan_tudjuk_az_anyanyelvünkre_lefordítani_a_freebsd_dokumentációját>16.5. Hogyan tudjuk az anyanyelvünkre lefordítani a FreeBSD dokumentációját?<a class=anchor href=#_hogyan_tudjuk_az_anyanyelvünkre_lefordítani_a_freebsd_dokumentációját></a></h3><div class=paragraph><p>Olvassuk el a FreeBSD Dokumentációs Projekt bevezetõjében található <a href=https://docs.freebsd.org/en/books/fdp-primer/#translations>Fordítói GYIK-ot</a>.</p></div></div><div class=sect2><h3 id=_a_freebsd_org_tartományon_belüli_e_mail_címekre_küldött_levelek_miért_pattannak_vissza>16.6. A FreeBSD.org tartományon belüli e-mail címekre küldött levelek miért pattannak vissza?<a class=anchor href=#_a_freebsd_org_tartományon_belüli_e_mail_címekre_küldött_levelek_miért_pattannak_vissza></a></h3><div class=paragraph><p>A <code>FreeBSD.org</code> levelezõrendszere a bejövõ levelekre vonatkozóan átvett néhány szigorúbb ellenõrzést a Postfix alkalmazástól, és ezért eldobja azokat a leveleket, amelyek formátuma hibás vagy feltehetõen szemét. A leveleink az alábbi okok miatt pattanhatnak vissza:</p></div><div class=ulist><ul><li><p>A levelet olyan név- vagy IP-tartományból küldtük, ahonnan korábban levélszemetet küldtek, ezért feketelistára került.</p><div class=paragraph><p>A FreeBSD levelezõ szerverei eldobnak minden olyan levelet, amelyek feketelistás tartományokból érkeznek. Ha olyan cégen vagy tartományon keresztül akarunk küldeni, amelyik levélszemetet gyárt vagy továbbít, akkor váltsunk szolgáltatót.</p></div></li><li><p>A levél törzse csak HTML kódot tartalmaz.</p><div class=paragraph><p>A leveleinket egyszerû szöveges formátumban küldjük. Állítsuk be a levelezõ kliensünket erre.</p></div></li><li><p>A <code>FreeBSD.org</code> címen üzemelõ levelezõ szerver nem tudta a csatlakozó gép IP-címét szimbolikus névre feloldani.</p><div class=paragraph><p>Az ellenkezõ irányú névfeloldás sikeressége alapvetõ követelmény a levelek fogadásához. Gondoskodjunk róla, hogy a levelezõ szerverünk IP-címével mûködjön az inverz névfeloldás, Sok otthoni szolgáltatás (DSL, kábel, betárcsázós stb. kapcsolat) erre nem ad lehetõséget. Ilyenkor a leveleinket próbáljuk meg a szolgáltatónk levelezõ szerverein keresztül küldeni.</p></div></li><li><p>Az SMTP protokoll EHLO/HELO részében megadott hálózati név nem oldható fel valós IP-címre.</p><div class=paragraph><p>Egy teljes, feloldható hálózati név elegendhetetlen a levél elfogadásához szükséges SMTP párbeszéd érvényességéhez. Ha nincs hivatalosan bejegyzett hálózati nevünk, akkor a szolgáltató levelezõ szervereit kell használnunk a levél elküldéséhez.</p></div></li><li><p>A küldött üzenet azonosítója (Message ID) végén a <code>localhost</code> szerepel.</p><div class=paragraph><p>Egyes levelezõ kliensek rossz azonosítónak hoznak létre az üzenetekhez, ezért a rendszer nem hajlandó elfogadni ezeket. Ilyenkor vagy rávesszük valahogy a levelezõ kliensünket, hogy rendes azonosítókat készítsen, vagy úgy állítjuk be a levéltovábbítónkat, hogy érvényes azonosítókra írja át.</p></div></li></ul></div></div><div class=sect2><h3 id=_hogyan_lehet_egyszerûen_freebsd_rendszereket_elérni>16.7. Hogyan lehet egyszerûen FreeBSD rendszereket elérni?<a class=anchor href=#_hogyan_lehet_egyszerûen_freebsd_rendszereket_elérni></a></h3><div class=paragraph><p>Habár a FreeBSD maga nem nyújt akárki számára hozzáférést a saját szervereihez, mások viszont kínálnak bárki által elérhetõ UNIX® rendszereket. Ennek költsége és minõsége szolgáltatónként változik.</p></div><div class=paragraph><p>Az <a href=http://www.arbornet.org/>Arbornet, Inc</a>, vagy másik nevén <em>M-Net</em> 1983 óta szolgáltat nyílt hozzáférést UNIX® típusú rendszerekhez. Egy System III alapokon mûködõ Altos rendszerrõl a 1991-ben BSD/OS-re váltottak, majd 2000 júliusában aztán FreeBSD-re váltottak. Az <em>M-Net</em> telnet és SSH szolgáltatásokon keresztül is elérhetõ, és lényegében a FreeBSD alatt elérhetõ összes programhoz enged egy alapvetõ hozzáférést. A hálózati hozzáférés azonban csak a tagok és a támogatók számára engedélyezett. Ez egy non-profit szervezet. Az <em>M-Net</em> rendelkezik üzenõfallal (bulletin board system, BBS) és interaktív csevegõrendszerrel is.</p></div><div class=paragraph><p>A <a href=http://www.grex.org/>Grex</a> az <em>M-Net</em> szolgáltatásához hasonlóan ugyanúgy kínál üzenõfalat és csevegési lehetõséget. Többségében azonban Sun™ 4M gépeik vannak, amelyen SunOS™ fut.</p></div></div><div class=sect2><h3 id=_mi_az_a_sup_és_hogyan_lehet_használni>16.8. Mi az a sup és hogyan lehet használni?<a class=anchor href=#_mi_az_a_sup_és_hogyan_lehet_használni></a></h3><div class=paragraph><p>A <a href=http://www.FreeBSD.org/cgi/ports.cgi?^sup>SUP</a> mozaikszó mögött a "Software Update Protocol" ("Szoftverfrissítési protokoll") áll, amelyet fejlesztési fák szinkronban tartására dolgoztak ki a Carnegie-Mellon Egyetemen. Régebben ennek segítségével tartották frissítették magukat a fejlesztõi források különbözõ tükrözései a FreeBSD Projekten belül.</p></div><div class=paragraph><p>A SUP nem kifejezetten egy sávszélesség-takarékos megoldás, és egy ideje már nyugdíjba vonult. A forrásainkat jelen pillanatban a <a href=https://docs.freebsd.org/hu/books/handbook/mirrors#cvsup>CVSup</a> használatával tudjuk frissíteni.</p></div></div><div class=sect2><h3 id=_hogy_hívják_azt_a_cuki_kis_vörös_fickót>16.9. Hogy hívják azt a cuki kis vörös fickót?<a class=anchor href=#_hogy_hívják_azt_a_cuki_kis_vörös_fickót></a></h3><div class=paragraph><p>Igazából nincs neve, mindenki egyszerûen csak "BSD démonnak" nevezi. Ha mégis hívni szeretnénk valahogy, akkor szólítsuk csak "beastie"-nek, ugyanis a "beastie" kiejtése megegyezik a "BSD" szóéval ("bíeszdi").</p></div><div class=paragraph><p>A BSD démonról a saját <a href=http://www.mckusick.com/beastie/index.html>honlapján</a> tudhatunk meg többet.</p></div></div><div class=sect2><h3 id=_felhasználható_a_bsd_démon_képe>16.10. Felhasználható a BSD démon képe?<a class=anchor href=#_felhasználható_a_bsd_démon_képe></a></h3><div class=paragraph><p>Talán. A BSD démon jogait Marshall Kirk McKusick birtokolja. A felhasználás pontos lehetõségeivel kapcsolatban olvassuk el <a href=http://www.mckusick.com/beastie/mainpage/copyright.html>Statement on the Use of the BSD Daemon Figure</a> címû írást.</p></div><div class=paragraph><p>Röviden úgy foglalhatnánk össze, hogy ízléses stílusban a saját céljainkra mindaddig nyugodtan felhasználhatjuk a képet, amíg megemlítjük az eredeti szerzõt. Ha kereskedelmi céljaink vannak, akkor írjunk Kirk McKusick &lt;<a href=mailto:mckusick@FreeBSD.org>mckusick@FreeBSD.org</a>> címére. A pontosabb részleteket a <a href=http://www.mckusick.com/beastie/index.html>BSD démon honlapján</a> olvashatjuk.</p></div></div><div class=sect2><h3 id=_található_valahol_felhasználható_kép_a_bsd_démonról>16.11. Található valahol felhasználható kép a BSD démonról?<a class=anchor href=#_található_valahol_felhasználható_kép_a_bsd_démonról></a></h3><div class=paragraph><p>EPS és XFig formátumú rajzok a <span class=filename>/usr/shared/examples/BSD_daemon/</span> könyvtárban vannak.</p></div></div><div class=sect2><h3 id=_a_levelezési_listákon_szerepeltek_ismeretlen_kifejezések_vagy_rövidítések_hol_lehet_ezeknek_utánanézni>16.12. A levelezési listákon szerepeltek ismeretlen kifejezések vagy rövidítések. Hol lehet ezeknek utánanézni?<a class=anchor href=#_a_levelezési_listákon_szerepeltek_ismeretlen_kifejezések_vagy_rövidítések_hol_lehet_ezeknek_utánanézni></a></h3><div class=paragraph><p>Olvassuk el a <a href=https://docs.freebsd.org/hu/books/handbook/glossary/#freebsd-glossary>FreeBSD szakkifejezéseinek gyûjteményét</a>.</p></div></div><div class=sect2><h3 id=_miért_fontos_annyira_a_biciklitároló_színe>16.13. Miért fontos annyira a biciklitároló színe?<a class=anchor href=#_miért_fontos_annyira_a_biciklitároló_színe></a></h3><div class=paragraph><p>Erre röviden úgy adhatnánk választ, hogy ezzel igazából nem kell annyira törõdnünk. Ha viszont valamivel terjedelmesebben akarunk válaszolni, akkor azt mondhatnánk, hogy azért, mert egy biciklitároló megépítése még nem tántorít el senkit sem a válaszott szín kritizálásától és az átfestésének fontolgatásától. Ez a metafora alapvetõen arról szól, hogy nem kell feltétlenül minden apró részletrõl vitatkoznunk csupán azért, mert jobban értünk hozzá. Sokak tapasztalata szerint ugyanis a változtatásokhoz kapcsolódó megjegyzések által gerjesztett zaj fordítottan arányos az adott változtatás bonyolultságával.</p></div><div class=paragraph><p>A még hosszabb és teljesebb válasz eredetileg egy nagyon hosszú és fárasztó vita eredményeképpen keletkezett, amikor arról esett szó, hogy a <a href="https://man.freebsd.org/cgi/man.cgi?query=sleep&amp;sektion=1&amp;format=html">sleep(1)</a> törtekkel dolgozzon-e vagy sem. Erre válaszul küldte Poul-Henning Kamp &lt;<a href=mailto:phk@FreeBSD.org>phk@FreeBSD.org</a>> az azóta híressé vált "<a href="http://www.FreeBSD.org/cgi/getmsg.cgi?fetch=506636+517178+/usr/local/www/db/text/1999/freebsd-hackers/19991003.freebsd-hackers">A bike shed (any color will do) on greener grass…​</a>" ("(Bármilyen színû) biciklitároló megfelelne egy zöldebb gyepen…​") címû levelét. Ebbõl szeretnénk most idézni:</p></div><div class=paragraph><p>Poul-Henning Kamp &lt;<a href=mailto:phk@FreeBSD.org>phk@FreeBSD.org</a>>, <a href=https://lists.FreeBSD.org/subscription/freebsd-hackers>freebsd-hackers</a>, 1999. október 2.
"Mirõl is szól ez a biciklitároló?" - kérdezték tõlem sokan.</p></div><div class=paragraph><p>Ez egy hosszú, vagy még inkább régi történet, amely azonban valójában meglehetõsen rövid. C. Northcote Parkinson "Parkinson törvénye" címmel írt egy könyvet az 1960-as évek elején, amelyben elég nagy betekintést adott a vezetés dinamikájába.</p></div><div class=paragraph><p><em>[a könyv részletes bemutatását most kihagyjuk]</em></p></div><div class=paragraph><p>A konkrét példában egy biciklitároló szerepel egy atomerõmûvel szemben, szóval ez is eléggé jól érzékelteti a könyv korát.</p></div><div class=paragraph><p>Parkinson ezen keresztül bemutatja, hogyan kell egy igazgatói tanács elé járulni egy több millió vagy akár milliárd dolláros atomerõmû megépítéséhez, azonban egy egyszerû biciklitároló megépítésekor könnyen véget nem érõ vitatkozásba bonyolódhatunk.</p></div><div class=paragraph><p>Parkinson elmagyarázza, mindez azért van, mert egy atomerõmû annyira óriási, drága és bonyolult, hogy az emberek egyszerûen nem értik meg. Ezért nem szólnak semmit és megnyugtatják magukat a feltételezéssel, hogy valaki más korábban már biztosan utánajárt a részleteknek. Richard P. Feynmann is könyveiben rengeteg érdekes és nagyon találó példát ad ezekre Los Alamossal kapcsolatban.</p></div><div class=paragraph><p>Vegyünk ezzel szemben most egy biciklitárolót. Bárki képes egy hétvége alatt összetákolni egy ilyet és még így is marad ideje megnézni a meccset. Ezért nem számít, mennyire jól megfogalmazott, elõkészített és logikus is a javaslatunk, valaki biztosan meg fogja ragadni a lehetõséget, hogy az orrunk elõtt fitogtassa a képességeit és megmutassa magát: õ bizony <em>itt járt</em>.</p></div><div class=paragraph><p>Dániában ezt mi úgy hívjuk, hogy "otthagyjuk a kezünk nyomát". Ez mindössze a személyes büszkeségrõl és tekintélyrõl szól, vagyis hogy végre elmondhassuk: "Ezt nézd! <em>Én</em> csináltam." Ez ugyan leginkább a politikusokra jellemzõ, de alapvetõen minden emberben ott él. Gondoljunk csak a friss betonban hagyott lábnyomokra.</p></div></div></div></div><div class=sect1><h2 id=_mókás_dolgok_a_freebsd_vel_kapcsolatban>17. Mókás dolgok a FreeBSD-vel kapcsolatban<a class=anchor href=#_mókás_dolgok_a_freebsd_vel_kapcsolatban></a></h2><div class=sectionbody><div class=sect2><h3 id=_mennyire_hûsít_a_freebsd>17.1. Mennyire hûsít a FreeBSD?<a class=anchor href=#_mennyire_hûsít_a_freebsd></a></h3><div class=paragraph><p>Kérdés: Mérte már valaki, hogy a FreeBSD futása közben mennyire melengeti meg a számítógépet? Úgy hírlik, a Linux® ebben a tekintetben sokkal jobb, mint a DOS, de FreeBSD-rõl még nem ismert ezzel kapcsolatban semmi. Mondjuk, elég tüzesnek tûnik.</p></div><div class=paragraph><p>Válasz: Nem, de korábban már számos tesztet végeztünk bekötött szemû önkénteseken, akiknek elõzetesen 250 mikrogram LSD-25-öt adagoltak. A tesztalanyok 35 százaléka szerint a FreeBSD kissé narancsos ízû volt, míg a Linux® inkább a rózsaszín ködhöz hasonlított. A hõmérséklettel kapcsolatban azonban egyik csoport sem észlelt komolyabb változást. Végül aztán teljesen el kellett vetnünk a kísérlet eredményeit, mert menet közben túlságosan sok önkéntes kóborolt el, és ezzel torzították a mérések eredményeit. A legtöbb önkéntes azóta is Apple-nél van, és azóta is egy új "színes, szagos" grafikus felületen dolgoznak. Szép kis felfordulás!</p></div><div class=paragraph><p>Komolyan: a FreeBSD és a Linux® is egyaránt a processzorokban található HLT (halt) utasítást használja arra, hogy az üresjáratban levõ rendszer energiafogyasztását és ezáltal hõtermelését is valamennyire mérsékelje. Emellett még az APM (Advanced Power Management) is támogatott, így a FreeBSD akár tetszés szerint alacsonyabb energiafogyasztású módba is tudja tenni a processzort.</p></div></div><div class=sect2><h3 id=_mi_mocorog_a_memóriamodulokban>17.2. Mi mocorog a memóriamodulokban?<a class=anchor href=#_mi_mocorog_a_memóriamodulokban></a></h3><div class=paragraph><p>Kérdés: A FreeBSD csinál valami "szokatlan" a rendszermag fordítása közben, ami miatt a memóriák felõl mocorgást lehet hallani? Amikor fordítok (vagy egy rövid ideig, amikor az indításkor a rendszer keresi a floppymeghajtót) valamilyen furcsa mocorgásszerû hang jön a memóriamodulokból.</p></div><div class=paragraph><p>Válasz: Igen! Gyakran utalnak a BSD rendszerek dokumentációiban mindenféle "démonokra", és ezzel kapcsolatban a legtöbb ember nem is tudja, hogy ezek valójában apró, öntudatos, fizikailag nem létezõ lények, amelyek a rendszer indulása után megszállják a számítógépünket. A memóriából kiszûrõdõ mocorgás hangja igazából a démonok közti magas frekvenciás beszélgetésbõl ered, amikor éppen arról egyeztetnek, hogy miként birkózzanak meg a különbözõ rendszeradminisztrációs feladatokkal.</p></div><div class=paragraph><p>Ha teljesen megõrjít minket ez a zajongás, akkor úgy tudunk tõlük megszabadulni, ha kiadjuk DOS-ból a jó öreg <code>fdisk /mbr</code> parancsot. Ekkor viszont ne lepõdjünk meg, ha netalán visszalõnének és próbálnak minket megállítani. Ha eközben a hangszóróinkból Bill Gates sátáni kacaja harsanna fel, akkor rohanjunk és ne is nézzünk többet vissza! A BSD démonok támogatásától mentesen a Windows® és a DOS ikerördögei ilyenkor gyakran visszaszerzik gépünk felett a teljes irányítást és ezzel örök szenvedésre kárhoztatják gyarló lelkünket. Ennek tudatában lehet, hogy mégis csak jobb lenne, ha egyszerûen csak hozzászoknánk azokhoz a furcsa hangokhoz, nem?</p></div></div><div class=sect2><h3 id=_hány_freebsd_fejlesztõ_kell_egy_villanykörte_kicseréléséhez>17.3. Hány FreeBSD fejlesztõ kell egy villanykörte kicseréléséhez?<a class=anchor href=#_hány_freebsd_fejlesztõ_kell_egy_villanykörte_kicseréléséhez></a></h3><div class=paragraph><p>Ezeregyszázhatvankilenc:</p></div><div class=paragraph><p>Huszonhárman panaszkodnak a -current listán, hogy már megint kiment a villany.</p></div><div class=paragraph><p>Négyen erre azt válaszolják, hogy ez csak konfigurációs probléma, ezért ennek a -questions listán a helye.</p></div><div class=paragraph><p>Hárman írnak róla hibajelentést, de ezek közül az egyik ráadásul tévesen a <code>doc</code> kategóriába kerül, és csak annyi áll benne, hogy "sötét van".</p></div><div class=paragraph><p>Erre az egyikük beszerel egy kipróbálatlan villanykörtét, amitõl nem mûködik a rendszer többi része, így öt perc múlva ki is szereli.</p></div><div class=paragraph><p>Nyolcan leszidják a hibajelentések íróit, hogy nem mellékelték a javítást a jelentéseik mellé.</p></div><div class=paragraph><p>Öten siránkoznak, hogy nem mûködik a rendszer.</p></div><div class=paragraph><p>Harmincegyen erre azt válaszolják, hogy nekik minden remekül mûködik, és az érintettek minden bizonnyal pont rosszkor frissítettek.</p></div><div class=paragraph><p>Egy küld egy új villanykörtét a -hackers listára.</p></div><div class=paragraph><p>Erre egy rászól, hogy õ már három évvel ezelõtt megcsinálta ugyanezt, de amikor beküldte a -current listára, akkor senki sem foglalkozott vele, és egyébként sem szereti a hibajelentéseket. Emellett ráadásul az új villanykörte egyébként sem tetszik.</p></div><div class=paragraph><p>Huszonheten nekiállnak skandálni, hogy a villanykörték nem tartoznak az alaprendszerbe, ezért a committerek a közösség megkérdezése nélkül nem csinálhatnak semmit, és különben is: <em>Mi errõl a -core véleménye?</em></p></div><div class=paragraph><p>Kétszázan eközben megvitatják, milyen színû legyen a biciklitároló.</p></div><div class=paragraph><p>Hárman jelzik, hogy a javítás nem felel meg a <a href="https://man.freebsd.org/cgi/man.cgi?query=style&amp;sektion=9&amp;format=html">style(9)</a> elõírásainak.</p></div><div class=paragraph><p>Tizenheten megjegyzik, hogy az újonnan javasolt villanykörte GPL licenccel rendelkezik.</p></div><div class=paragraph><p>Ötszázhatvankilencen valóságos vitaözönt indítanak a GPL, a BSD, MIT és NPL licencek elõnyeit illetõen, majd megjegyzéseket tesznek különféle meg nem nevezett FSF alapítók személyes higéniajára.</p></div><div class=paragraph><p>Heten a vita bizonyos részeit átviszik a -chat és -advocacy listákra.</p></div><div class=paragraph><p>Egy végül beszereli a javasolt villanykörtét, de az valamivel mintha halványabban világítani, mint az elõzõ.</p></div><div class=paragraph><p>Ketten leszólják a szerelést, és összekapnak azon, hogy most akkor a FreeBSD inkább maradjon sötétségben vagy érje be a halványabb világítással.</p></div><div class=paragraph><p>Negyvenhárman rikácsolva követelik a halványan világító villanykörte kiszerelését és panaszukat megírják a -core listára.</p></div><div class=paragraph><p>Tizenegyen egy kisebb villanykörtét kérnek, mert ha majd portolni akárják a Tamagotchijukra a rendszert, akkor ott is használható legyen.</p></div><div class=paragraph><p>Hetvenhárman felemelik a szavukat a -hackers és -chat listákon felerõsödött zaj miatt, és tiltakozásul leiratkoznak ezekrõl a listákról.</p></div><div class=paragraph><p>Tizenhárman erre egy "leiratkozom", " Hogyan kell innen leiratkozni?" vagy "Kérlek, vegyetek le errõl a listáról" témájú levelet küldenek a megszokott stílusban.</p></div><div class=paragraph><p>Egy eközben beszerel végre egy mûködõ villanykörtét, miközben mindenki azzal van elfoglalva, hogy szidja a másikat, így szinte észre sem veszik.</p></div><div class=paragraph><p>Harmincegy ezután hozzáteszi, hogy az új villanykörte 0,364 százalékkal jobban világítana, ha TenDRA-val csinálták volna (akkor viszont kocka alakú lenne) és a FreeBSD-nek ezért a GCC helyett TenDRA-t kellene használnia.</p></div><div class=paragraph><p>Egy valaki megemlíti, hogy az új villanykörtén nincs is burkolat.</p></div><div class=paragraph><p>Kilencen (beleértve a hibajelentések íróit) azt kérdezgetik folyton, hogy "Mi az az MFC?".</p></div><div class=paragraph><p>Ötvenheten két hét múlva kezdenek el panaszkodni, hogy a villanykörte kiment.</p></div><div class=paragraph><p><em>Nik Clayton &lt;<a href=mailto:nik@FreeBSD.org>nik@FreeBSD.org</a>> hozzáteszi:</em></p></div><div class=paragraph><p><em>Nagyon jót nevettem ezen.</em></p></div><div class=paragraph><p><em>Közben az jutott az eszembe, hogy "Várjunk csak, nem kellene valahol a felsorolásban lennie egy "egy, aki pedig ledokumentálja" résznek?"</em></p></div><div class=paragraph><p><em>És akkor végre megértettem :-)</em></p></div><div class=paragraph><p><em>Thomas Abthorpe &lt;<a href=mailto:tabthorpe@FreeBSD.org>tabthorpe@FreeBSD.org</a>></em> szerint: "Egy sem, mert a <em>valódi</em> FreeBSD fejlesztõk nem félnek a sötétben!"</p></div></div><div class=sect2><h3 id=_hova_kerül_a_devnull_eszközre_küldött_adat>17.4. Hova kerül a /dev/null eszközre küldött adat?<a class=anchor href=#_hova_kerül_a_devnull_eszközre_küldött_adat></a></h3><div class=paragraph><p>A processzoron található speciális adatsüllyesztõbe kerül, majd hõvé alakul és elszállítja a felszerelt hûtõborda és ventillátor. Ezért is annyira fontos a processzor hûtése: az emberek minél gyorsabb géppel rendelkeznek, annál inkább gondatlanná válnak és annál több adat köt ki a <span class=filename>/dev/null</span> eszközben. Ha sikerül letörölnünk a <span class=filename>/dev/null</span> eszközt (amivel így lényegében letiltjuk a processzor adatsüllyesztõjét), akkor a processzorunk ugyan kevésbé fog melegedni, viszont gyorsan eldugul a sok adattól és furcsán kezd el viselkedni. Ha nagyon gyors hálózati kapcsolattal rendelkezünk, akkor úgy is le tudjuk hûteni a processzorunkat, ha folyamatosan olvassuk a <span class=filename>/dev/random</span> eszközt és valahova elküldjük az eredményt. Ekkor viszont vigyázzunk arra, hogy ezzel a módszerrel könnyen túlmelegedhet a hálózati kártyánk és a gyökér állományrendszerünk, valamint a szolgáltató sem fog örülni ennek, mert akkor a felesleges hõ náluk keletkezik. Általában viszont jó a hûtésük, ezért ha okosan csináljuk, akkor semmi gondunk nem származik belõle.</p></div><div class=paragraph><p><em>Paul Robinson hozzáteszi:</em></p></div><div class=paragraph><p>Vannak még más módszerek is. Minden jó rendszergazda tudja, hogy szokás a képernyõre is folyamatosan adatot küldeni, mert így a pixik is vidámabbak lesznek. A képernyõt formázó pixik (melyek gyakran tévesen és hibásan "pixeleknek" hívnak) a fejükön viselt kalapok szerint három csoportba sorolhatóak (vörös, zöld vagy kék), és annak megfelelõen bújnak elõ (illetve mutatják meg a kalapjukat), hogy kapnak-e enni. A videokártyák felelõsek azért, hogy a kapott adatokból pixiétel készüljön és hogy az eljusson a pixikhez - minél drágább a kártya, annál jobb minõségû az elõállított étel, és annál fegyelmezettebben viselkednek a pixik. Állandó cirogatásra is szükségük van - ez a képernyõvédõk feladata.</p></div><div class=paragraph><p>Az elõbbi javaslatot azzal tudnám még kiegészíteni, hogy a <span class=filename>/dev/random</span> eszköztõl származó adatokat akár a konzolra is küldhetjük, így a pixiket is jól tudjuk lakatni. Ezzel együtt nem jár semmilyen hõtermelés, viszont a pixik boldogok lesznek és így könnyen meg tudunk szabadulni a felesleges adatoktól is, még úgy is, ha kissé zavarosnak tûnik közben a kép.</p></div><div class=paragraph><p>Mellesleg mint az egyik nagy szolgáltató egykori rendszergazdája elmondhatom, hogy mivel tapasztalatom szerint a szerverszobában nehéz tartani a megfelelõ hõmérsékletet, ezért nem ajánlom senkinek a felesleges adatok átküldését a hálózaton. A csomagok közvetítésével és irányításával foglalkozó tündérek sem különösebben szoktak örülni ennek.</p></div></div></div></div><div class=sect1><h2 id=_témák_haladóknak>18. Témák haladóknak<a class=anchor href=#_témák_haladóknak></a></h2><div class=sectionbody><div class=sect2><h3 id=_honnan_lehet_többet_megtudni_a_freebsd_belsõ_felépítésérõl>18.1. Honnan lehet többet megtudni a FreeBSD belsõ felépítésérõl?<a class=anchor href=#_honnan_lehet_többet_megtudni_a_freebsd_belsõ_felépítésérõl></a></h3><div class=paragraph><p>Jelen pillanatban csak egyetlen mû foglalkozik az operációs rendszerek felépítésével a FreeBSD szemszögébõl, név szerint a Marshall Kirk McKusick és George V. Neville-Neil által írt "The Design and Implementation of the FreeBSD Operating System" címû könyv (ISBN 0-201-70245-2), amely a FreeBSD 5.<em>X</em> változatára koncentrál.</p></div><div class=paragraph><p>Emellett a UNIX® típusú rendszerek használatával kapcsolatos ismeret remekül alkalmazható a FreeBSD esetén is.</p></div><div class=paragraph><p>A témához tartozó többi könyvet a kézikönyv <a href=https://docs.freebsd.org/hu/books/handbook/bibliography/#bibliography-osinternals>Az operációs rendszerek belsõ mûködésével</a> foglalkozó irodalomjegyzékben találhatjuk meg.</p></div></div><div class=sect2><h3 id=_hogyan_lehet_bekapcsolódni_a_freebsd_fejlesztésébe>18.2. Hogyan lehet bekapcsolódni a FreeBSD fejlesztésébe?<a class=anchor href=#_hogyan_lehet_bekapcsolódni_a_freebsd_fejlesztésébe></a></h3><div class=paragraph><p>Pontosabb tanácsokat akkor kapunk, ha elolvassuk a <a href=https://docs.freebsd.org/en/articles/contributing/>FreeBSD fejlesztésérõl szóló cikket</a>. Nagyon is számítunk mindenki segítségére!</p></div></div><div class=sect2><h3 id=_mik_azok_a_pillanatkiadások_és_kiadások>18.3. Mik azok a pillanatkiadások és kiadások?<a class=anchor href=#_mik_azok_a_pillanatkiadások_és_kiadások></a></h3><div class=paragraph><p>Jelenleg három aktív és félig aktív ág van a FreeBSD <a href=http://www.FreeBSD.org/cgi/cvsweb.cgi>CVS repositoryjában</a>. (A korábbi ágakat már csak nagyon ritkán módosítják, ezért is csak három aktív fejlesztési ágon fejlesztenek):</p></div><div class=ulist><ul><li><p><code>RELENG_7</code> avagy <em>7-STABLE</em></p></li><li><p><code>RELENG_8</code> avagy <em>8-STABLE</em></p></li><li><p><code>HEAD</code> avagy <em>-CURRENT</em> avagy <em>9-CURRENT</em></p></li></ul></div><div class=paragraph><p>A <code>HEAD</code> nem olyan ág, mint a másik kettõ. Ez egyszerûen csak "<em>a jelenlegi, még el nem ágaztatott fejlesztési irány</em>" jelentéssel bír, amire pedig sokszor röviden csak <em>-CURRENT</em> néven hivatkoznak.</p></div><div class=paragraph><p>Jelen pillanatban a <em>-CURRENT</em> a 9.<em>X</em> fejlesztési irányát képviseli; az <code>6-STABLE</code> ág, a RELENG_6, 2005 novemberében, a <code>7-STABLE</code> ág, a RELENG_7, 2008 februárjában, míg a <code>8-STABLE</code> ág, a RELENG_8, 2009 novemberében vált le a "-CURRENT" ágból.</p></div></div><div class=sect2><h3 id=_hogyan_lehet_saját_kiadást_készíteni>18.4. Hogyan lehet saját kiadást készíteni?<a class=anchor href=#_hogyan_lehet_saját_kiadást_készíteni></a></h3><div class=paragraph><p>Olvassuk el a <a href=https://docs.freebsd.org/en/articles/releng/>kiadások készítésérõl szóló</a> cikket.</p></div></div><div class=sect2><h3 id=_a_make_world_parancs_miért_írja_felül_a_korábban_telepített_binárisokat>18.5. A make world parancs miért írja felül a korábban telepített binárisokat?<a class=anchor href=#_a_make_world_parancs_miért_írja_felül_a_korábban_telepített_binárisokat></a></h3><div class=paragraph><p>Mert alapvetõen ez lenne a cél: ahogy a neve is sugallja, a rendszer újrafordítása, vagyis a <code>make world</code> parancs feladata a rendszerben található összes bináris újrafordítása, aminek eredményeképpen egy tiszta és összefüggõ környezetet kapunk (ezért is tart ilyen sokáig).</p></div><div class=paragraph><p>Ha a <code>make world</code> vagy a <code>make install</code> parancs futtatása elõtt megadjuk a <code>DESTDIR</code> környezeti változót, akkor a frissen létrehozott binárisok az általa mutatott könyvtárba fognak kerülni pontosan úgy, ahogy az eredeti rendszer. Az osztott könyvtárak bizonyos módosításai és egyes programok fordítása azonban könnyen térdre kényszerítheti a <code>make world</code> futását.</p></div></div><div class=sect2><h3 id=_miért_nem_forgó_round_robin_névfeloldással_lehet_elérni_a_cvsup_szervereket_és_így_megosztani_köztük_a_terhelést>18.6. Miért nem forgó (round robin) névfeloldással lehet elérni a CVSup szervereket és így megosztani köztük a terhelést?<a class=anchor href=#_miért_nem_forgó_round_robin_névfeloldással_lehet_elérni_a_cvsup_szervereket_és_így_megosztani_köztük_a_terhelést></a></h3><div class=paragraph><p>Habár a CVSup tükrözések óránként frissítik magukat a központi CVSup szerverrõl, maga a frissítés azonban bármikor megtörténhet. Ennek következményeképpen egyes szervereken frissebb kód található, miközben a többin még az egy órával ezelõtti állapot szerepel. Ha a <code>cvsup.FreeBSD.org</code> forgó névfeloldással mûködne, akkor a felhasználók mindig egy véletlenszerûen választott CVSup szervert kapnának, és ezért a CVSup egymás utáni futtatásakor könnyen elõfordulhatna, hogy a rendszer régebbi forrásait kapjuk vissza.</p></div></div><div class=sect2><h3 id=_a_current_forrásait_korlátozott_interneteléréssel_is_lehet_követni>18.7. A -CURRENT forrásait korlátozott interneteléréssel is lehet követni?<a class=anchor href=#_a_current_forrásait_korlátozott_interneteléréssel_is_lehet_követni></a></h3><div class=paragraph><p>Igen, ezt a <a href=https://docs.freebsd.org/hu/books/handbook/updating-upgrading#synching>CTM</a> használatával <em>anélkül</em> is megtudjuk tenni, hogy le kellene töltenünk az egész forrásfát.</p></div></div><div class=sect2><h3 id=_hogyan_lehet_1392_kb_os_darabokra_felosztani_az_egyes_terjesztéseket>18.8. Hogyan lehet 1392 KB-os darabokra felosztani az egyes terjesztéseket?<a class=anchor href=#_hogyan_lehet_1392_kb_os_darabokra_felosztani_az_egyes_terjesztéseket></a></h3><div class=paragraph><p>Az újabb BSD alapú rendszerekben a <a href="https://man.freebsd.org/cgi/man.cgi?query=split&amp;sektion=1&amp;format=html">split(1)</a> parancsnak már van egy <code>-b</code> paramétere, amellyel tetszõleges méretûre fel tudunk darabolni állományokat.</p></div><div class=paragraph><p>Íme erre egy példa a <span class=filename>/usr/src/release/Makefile</span> állományból:</p></div><div class="literalblock programlisting"><div class=content><pre>ZIPNSPLIT=              gzip --no-name -9 -c | split -b 1392k -</pre></div></div></div><div class=sect2><h3 id=_hova_lehet_küldeni_a_rendszermaghoz_írt_kiegészítéseket>18.9. Hova lehet küldeni a rendszermaghoz írt kiegészítéseket?<a class=anchor href=#_hova_lehet_küldeni_a_rendszermaghoz_írt_kiegészítéseket></a></h3><div class=paragraph><p>Erre vonatkozóan vessünk egy pillantást a <a href=https://docs.freebsd.org/en/articles/contributing/>FreeBSD továbbfejlesztésérõl szóló</a> cikkre.</p></div><div class=paragraph><p>Köszönjük, hogy gondolt ránk!</p></div></div><div class=sect2><h3 id=_a_rendszer_hogyan_érzékeli_és_inicializálja_a_plug_and_play_isa_kártyákat>18.10. A rendszer hogyan érzékeli és inicializálja a Plug and Play ISA kártyákat?<a class=anchor href=#_a_rendszer_hogyan_érzékeli_és_inicializálja_a_plug_and_play_isa_kártyákat></a></h3><div class=paragraph><p>Frank Durda IV (<a href=mailto:uhclem@nemesis.lonestar.org>uhclem@nemesis.lonestar.org</a>) válasza:</p></div><div class=paragraph><p>Dióhéjban úgy tudnám ezt elmagyarázni, hogy van néhány I/O port, amelyet lekérdezve a PnP kártya képes válaszolni, hogy elérhetõ-e. Ezért a PnP eszközök keresése azzal kezdõdik, hogy a rendszer felteszi a kérdést, van-e PnP kártya a számítógépben. Erre aztán a különbözõ kártyák a típusuk megjelölésével válaszolnak, amelyet ugyanezen az I/O porton kell visszaolvasni, így ha már legalább egy bitet beállít valaki, akkor folytatható a keresés. Ezután a keresést végzõ kódrész letiltja az <code>X</code> alatti (a Microsoft® és az Intel® által kiosztott) azonosítóval rendelkezõ kártyákat, majd ismét megnézi, hogy valaki továbbra is válaszol-e. Amennyiben a válasz <code>0</code>, az arra utal, hogy már nincs aktív kártya az <code>X</code> azonosító felett. Ezt követõen a rendszer megpróbálkozik az <code>X</code> alatti azonosítók lekérdezésével. Végül folytatja az <code>X</code> alatti keresést az <code>X -(korlát / 4)</code> feletti azonosítók letiltásával, majd megismétli az iménti kérdést. Ezzel a félig-meddig bináris keresési módszerrel aztán képes 2 lépésnél jóval kevesebbõl felderíteni a rendszerünkben megtalálható PnP kártyákat.</p></div><div class=paragraph><p>Az azonosítók két 32 bit hosszúságú mezõbõl (ezért írtunk az elõbb 2 lépést) és egy 8 bites ellenõrzõösszegbõl állnak. Az elsõ 32 bit a gyártót azonosítja. Ugyan soha nem vallják be, de úgy tûnik, hogy még ugyanannak a gyártónak is lehetnek eltérõ gyártóazonosítóval rendelkezõ kártyái. A gyártók számára fenntartott 32 bites mezõ ezért valamennyire túlzás.</p></div><div class=paragraph><p>A második 32 bit lehet a kártya sorozatszáma vagy bárki más, amely alapján egyértelmûen beazonosítható. A gyártó ugyanazzal a 32 bites értékkel nem gyárthat egy másik kártyát, csak abban az esetben, ha a másik 32 bit is eltér. Ennek köszönhetõen egy gépen belül még az azonos típusú kártyák is el fognak térni 64 biten.</p></div><div class=paragraph><p>Az iménti 32 bites csoportok nem lehetnek teljesen nullák, ezért lehetséges, hogy a bináris keresés során a válaszban legalább egy bit mindig aktív lesz.</p></div><div class=paragraph><p>Miután a rendszer sikeresen beazonosította a rendelkezésre álló kártyákat, egyenként újra elindítja ezeket (ugyanazon az I/O porton keresztül), és megpróbálja kitalálni, hogy az adott eszközöknek milyen erõforrásokra van szüksége, milyen megszakítást akarnak használni stb. Az összes kártyától lekérdezi ezeket az információkat.</p></div><div class=paragraph><p>Az így megszerzett információkat aztán még kiegészíti a merevlemezen vagy az MLB BIOS-ban található ECU állományok tartalmával. Az ECU és az MLB BIOS PnP támogatása általában viszont nem valódi, és az ilyen eszközök igazából nem is állítanak be semmit maguktól. A BIOS és az ECU átvizsgálása azonban segít a felderítést végzõ rutinnak értesíteni a tényleges PnP eszközöket, hogy ne foglaljanak el olyan erõforrásokat, amelyeket a rendszer nem tud áthelyezni.</p></div><div class=paragraph><p>Ezután a PnP eszközöket a kód még egyszer végigjárja és átadja nekik a mûködésükhöz szükséges I/O, DMA, IRQ és memóracímek hozzárendeléseit. Az eszközök ekkor a megadott helyeken elérhetõvé válnak és úgy is maradnak a rendszer következõ indításáig, de igazából semmi sem rögzíti ezeket.</p></div><div class=paragraph><p>Talán túlságosan is egyszerûsítettem a fentieket, de szerintem már ennyi is elegendõ az alapok megértéséhez.</p></div><div class=paragraph><p>A Microsoft® néhány elsõdleges nyomtatási állapotot jelzõ portot átrakott PnP-re, azzal a címszóval, hogy egyik kártya sem kódolta át ezeket a címeket az ellenkezõ I/O ciklusok számára. Találtam is egy eredeti IBM nyomtatókártyát, amely valóban át tudta írni az állapotjelzõ portot a PnP kezdeti változataiban, de arra a Microsoft® csak annyit mondott, hogy "fogós". Ezért a nyomtatási állapotot jelzõ portot a címek beállítására használja, illetve még a <code>0x800</code>-as portot és egy harmadik I/O portot valahol a <code>0x200</code> és a <code>0x3ff</code> környékén.</p></div></div><div class=sect2><h3 id=_hogyan_lehet_fõeszközazonosítót_rendelni_egy_általunk_fejlesztett_meghajtóhoz>18.11. Hogyan lehet fõeszközazonosítót rendelni egy általunk fejlesztett meghajtóhoz?<a class=anchor href=#_hogyan_lehet_fõeszközazonosítót_rendelni_egy_általunk_fejlesztett_meghajtóhoz></a></h3><div class=paragraph><p>2003 februárja óta a FreeBSD képes dinamikusan és önmûködõen futás közben lefoglalni fõeszközazonosítókat a meghajtóknak (lásd <a href="https://man.freebsd.org/cgi/man.cgi?query=devfs&amp;sektion=5&amp;format=html">devfs(5)</a>), ezért erre tulajdonképpen már nincs szükség.</p></div></div><div class=sect2><h3 id=_a_könyvtárakra_vonatkozóan_milyen_más_kiosztási_házirendek_léteznek_még>18.12. A könyvtárakra vonatkozóan milyen más kiosztási házirendek léteznek még?<a class=anchor href=#_a_könyvtárakra_vonatkozóan_milyen_más_kiosztási_házirendek_léteznek_még></a></h3><div class=paragraph><p>A könyvtárak más fajta kiosztására vonatkozóan annyit tudok válaszolni, hogy a jelenleg is alkalmazott sémát az 1983-ban megalkotott változata óta változatlanul használjuk. Eredetileg a gyors állományrendszerhez készítettem, de soha nem ragaszkodtam hozzá. Remekül megoldja a cilindercsoportok betelésének problémáját, azonban sokan megjegyezték már, hogy a <a href="https://man.freebsd.org/cgi/man.cgi?query=find&amp;sektion=1&amp;format=html">find(1)</a> esetén gyengén mûködik. A legtöbb állományrendszert mélységi bejárással hozzák létre, így a könyvtárak szétszóródnak a cilindercsoportok közt és ezzel a késõbbi mélységi keresések számára a lehetõ legrosszabb helyzetet alakítják ki. Ha valaki például tudja elõre a létrehozni kívánt könyvtárak számát, akkor ezt úgy lehet megoldani, ha a mûvelet során <code>(összes / cilindercsoportok)</code> mennyiségû könyvtárat hozunk létre az egyes cilindercsoportokban. Ennek meghatározására nyilvánvalóan lehet adni valamilyen heurisztikát. Már egy kisebb elõre rögzített szám, mint például a 10 kiválasztása is legalább egy nagyságrendnyi javulást jelent. Ha szeretnénk megkülönböztetni az állományrendszerek visszaállítását a hagyományos mûködéstõl (amire a jelenlegi algoritmus sokkal érzékenyebb), akkor érdemes tizes csoportokba összefogni a könyvtárakat, feltéve, hogy 10 másodpercen belül hoztuk létre ezeket. Mindenesetre elmondható, hogy ezzel nyugodtan lehet kísérletezni.</p></div><div class=paragraph><p>Kirk McKusick &lt;<a href=mailto:mckusick@FreeBSD.org>mckusick@FreeBSD.org</a>>, 1998 szeptembere</p></div></div><div class=sect2><h3 id=_hogyan_lehet_kinyerni_a_legtöbb_információt_a_rendszermag_összeomlásából>18.13. Hogyan lehet kinyerni a legtöbb információt a rendszermag összeomlásából?<a class=anchor href=#_hogyan_lehet_kinyerni_a_legtöbb_információt_a_rendszermag_összeomlásából></a></h3><div class=paragraph><p>Általában így néz ki a rendszermag összeomlása:</p></div><div class="literalblock programlisting"><div class=content><pre>Fatal trap 12: page fault while in kernel mode
fault virtual address   = 0x40
fault code              = supervisor read, page not present
instruction pointer     = 0x8:0xf014a7e5
stack pointer           = 0x10:0xf4ed6f24
frame pointer           = 0x10:0xf4ed6f28
code segment            = base 0x0, limit 0xfffff, type 0x1b
                        = DPL 0, pres 1, def32 1, gran 1
processor eflags        = interrupt enabled, resume, IOPL = 0
current process         = 80 (mount)
interrupt mask          =
trap number             = 12
panic: page fault</pre></div></div><div class=paragraph><p>Amikor egy ilyen üzenetet látunk, akkor nem elegendõ újra elõcsalni a hibát és beküldeni. Az utasításszámláló ("instruction pointer") értéke ugyan nagyon fontos, de sajnos konfigurációk szerint eltérhet. Más szóval úgy fogalmazhatnék, hogy ennek az értéke a használatban levõ rendszermag értékétõl függõen változhat. Ha a <span class=filename>GENERIC</span> rendszermagot használjuk valamelyik kiadásból, akkor viszont már elképzelhetõ, hogy valaki más is le tudja nyomozni a hibát okozó függvényt. Ha viszont egy saját beállításokkal rendelkezõ rendszermagot használunk, akkor egyedül csak <em>mi</em> vagyunk képesek megmondani a hiba pontos helyét.</p></div><div class=paragraph><p>Ezért a javaslatom a következõ:</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Jegyezzük le az utasításszámláló értékét. A <code>0x8:</code> rész ebben az esetben annyira nem fontos, egyedül csak a <code>0xf0xxxxxx</code> részre van szükségünk.</p></li><li><p>A rendszer újraindításakor írjuk be a következõt:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% nm <span class=nt>-n</span> /a.hibát.okozó.rendszermag | <span class=nb>grep </span>f0xxxxxx</code></pre></div></div><div class=paragraph><p>ahol az <code>f0xxxxxx</code> az utasításszámláló értéke. Könnyen elõfordulhat, hogy ilyenkor még nem találunk egyezést, mivel a rendszermag szimbólumtáblájában csak az egyes függvények belépési pontjai találhatóak, és ha az utasításszámláló általában valamelyikük belsejébe mutat, nem az elejükre. Ha tehát nem még látunk semmit, akkor egyszerûen hagyjuk el az utolsó számjegyet és próbálkozzunk így:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% nm <span class=nt>-n</span> /a.hibát.okozó.rendszermag | <span class=nb>grep </span>f0xxxxx</code></pre></div></div><div class=paragraph><p>Ha még ez sem hoz eredményt, akkor vágjunk le a végérõl egy újabb számjegyet. Egészen addig csináljuk, amíg nem kapunk valami értékelhetõ eredményt. Ilyennek tekintjük például azokat a függvényeket, amelyek a hibát okozhatták. Ez ugyan egy nem annyira pontos felderítési eszköz, viszont még ez is jobb a semminél.</p></div></li></ol></div></div></div><div class=paragraph><p>A legjobb viszont mégis az, amikor sikerül lementeni a hiba bekövetkezésekor a memória tartalmát, majd a <a href="https://man.freebsd.org/cgi/man.cgi?query=kgdb&amp;sektion=1&amp;format=html">kgdb(1)</a> használatával elõbányászni belõle egy hívási láncot.</p></div><div class=paragraph><p>Ehhez többnyire a következõ módszer javasolt:</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>A rendszermag konfigurációs állományába (<span class=filename>/usr/src/sys/arch/conf/RENDSZERMAGKONFIG</span>) vegyük fel a következõ sort:</p><div class="literalblock programlisting"><div class=content><pre>makeoptions     DEBUG=-g          # A rendszermag fordítása gdb(1) szimbólumokkal</pre></div></div></li><li><p>Lépjünk be a <span class=filename>/usr/src</span> könyvtárba:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/src</span></code></pre></div></div></li><li><p>Fordítsuk le a rendszermagot:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># make buildkernel KERNCONF=RENDSZERMAGKONFIG</span></code></pre></div></div></li><li><p>Várjuk meg, amíg a <a href="https://man.freebsd.org/cgi/man.cgi?query=make&amp;sektion=1&amp;format=html">make(1)</a> befejezi a fordítást.</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># make installkernel KERNCONF=RENDSZERMAGKONFIG</span></code></pre></div></div></li><li><p>Indítsuk újra a gépet.</p></li></ol></div></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>A <code>KERNCONF</code> használata nélkül a <span class=filename>GENERIC</span> rendszermag fordul és telepítõdik.</p></div></td></tr></tbody></table></div><div class=paragraph><p>A <a href="https://man.freebsd.org/cgi/man.cgi?query=make&amp;sektion=1&amp;format=html">make(1)</a> programnak a folyamat végeredményeként két rendszermagot kell készítenie: a <span class=filename>/usr/obj/usr/src/sys/RENDSZERMAGKONFIG/kernel</span> és a <span class=filename>/usr/obj/usr/src/sys/RENDSZERMAGKONFIG/kernel.debug</span>. Ezek közül a <span class=filename>kernel</span> <span class=filename>/boot/kernel/kernel</span> néven mentõdik el, miközben a <span class=filename>kernel.debug</span> használható nyomonkövetésre a <a href="https://man.freebsd.org/cgi/man.cgi?query=kgdb&amp;sektion=1&amp;format=html">kgdb(1)</a> programmal.</p></div><div class=paragraph><p>A rendszer csak akkor fogja elmenteni összeomláskor a memória tartalmát, ha az <span class=filename>/etc/rc.conf</span> állományban beállítjuk a <code>dumpdev</code> értékét a lapozóállományt tároló partícióra (vagy az <code>AUTO</code> értékre). Ennek hatására az <a href="https://man.freebsd.org/cgi/man.cgi?query=rc&amp;sektion=8&amp;format=html">rc(8)</a> szkriptek a <a href="https://man.freebsd.org/cgi/man.cgi?query=dumpon&amp;sektion=8&amp;format=html">dumpon(8)</a> paranccsal képesek engedélyezni a memória lementését. A <a href="https://man.freebsd.org/cgi/man.cgi?query=dumpon&amp;sektion=8&amp;format=html">dumpon(8)</a> természetesen manuálisan is elindítható. Az összeomlást követõen a memória lementett tartalmához a <a href="https://man.freebsd.org/cgi/man.cgi?query=savecore&amp;sektion=8&amp;format=html">savecore(8)</a> programmal férhetünk hozzá. Amikor viszont az <span class=filename>/etc/rc.conf</span> állományban megadjuk a <code>dumpdev</code> értékét, az <a href="https://man.freebsd.org/cgi/man.cgi?query=rc&amp;sektion=8&amp;format=html">rc(8)</a> szkriptek maguktól lefuttatják a <a href="https://man.freebsd.org/cgi/man.cgi?query=savecore&amp;sektion=8&amp;format=html">savecore(8)</a> parancsot és átrakják a mentést a <span class=filename>/var/crash</span> könyvtárba.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>A FreeBSD által létrehozott memóriamentések mérete általában a számítógépünkben levõ fizikai memória mennyiségével egyezik meg. Tehát ha 512 MB RAM van a gépünkben, akkor egy 512 MB méretû mentést fogunk kapni. Ezért gondoskodjunk róla, hogy a <span class=filename>/var/crash</span> könyvtárban mindig legyen elegendõ hely az állomány tárolásához. A <a href="https://man.freebsd.org/cgi/man.cgi?query=savecore&amp;sektion=8&amp;format=html">savecore(8)</a> kézzel is lefuttathazó, és ilyenkor a memóriát akár egy másik könyvtárba is menthetjük. A mentés méretét <code>options MAXMEM=N</code> beállítással is korlátozhatjuk, ahol az <em>N</em> értéke a rendszermag által használható memória mérete KB-okban. Például, ha 1 GB RAM van a gépünkben, de a rendszermag által használható memóriát lekorlátozzuk 128 MB-ra, akkor a mentés mérete sem 1 GB lesz, hanem csak 128 MB.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Ahogy sikerült hozzájutnunk a memóriamentéshez, azonnal is kérhetünk a <a href="https://man.freebsd.org/cgi/man.cgi?query=kgdb&amp;sektion=1&amp;format=html">kgdb(1)</a> használatával egy hívási láncot belõle:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% kgdb /usr/obj/usr/sys/RENDSZERMAGKONFIG/kernel.debug /var/crash/vmcore.0
<span class=o>(</span>kgdb<span class=o>)</span> backtrace</code></pre></div></div><div class=paragraph><p>Elõfordulhat, hogy ilyenkor több oldalnyi információ özönlik hirtelen a képernyõre, ezért javasolt ezeket lementeni a <a href="https://man.freebsd.org/cgi/man.cgi?query=script&amp;sektion=1&amp;format=html">script(1)</a> programmal. A nyomkövetési szimbólumokat is tartalmazó rendszermag esetén még akár azt a sort is megkapjuk a rendszermagon belül, ahol a hiba történt. A hívási láncot általában alulról felfelé kell olvasni, és ebbõl deríthetõ, hogy pontosan milyen események is vezettek az összeomláshoz. A <a href="https://man.freebsd.org/cgi/man.cgi?query=kgdb&amp;sektion=1&amp;format=html">kgdb(1)</a> használatával még a különbözõ változók és struktúrák értékeit is meg tudjuk vizsgálni, így még többet megtudhatunk a rendszer állapotáról az összeomlás pillanatában.</p></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Ha az iméntiek mentén nagyon fellelkesültünk volna és van egy másik számítógépünk is, akkor a <a href="https://man.freebsd.org/cgi/man.cgi?query=kgdb&amp;sektion=1&amp;format=html">kgdb(1)</a> akár távoli nyomkövetésre is beállítható, aminek köszönhetõen a <a href="https://man.freebsd.org/cgi/man.cgi?query=kgdb&amp;sektion=1&amp;format=html">kgdb(1)</a> használatával az egyik rendszeren meg tudjuk állítani a másikon futó rendszermagot, ellenõrizhetjük a viselkedését, akárcsak bármelyik más felhasználói program esetében.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Ha netalán engedélyeztük volna a <code>DDB</code> beállítást, és a rendszermag beleáll a nyomkövetõbe, akkor a rendszert mi magunk is össze tudjuk omlasztani (és így a memóriát elmenteni) a <code>ddb</code> parancssorában a <code>panic</code> parancs kiadásával. Ilyenkor a nyomkövetõ általában még egyszer megáll az összeomláskor. Ekkor a <code>continue</code> paranccsal fejeztethetjük be a memória lementését.</p></div></div><div class=sect2><h3 id=_a_dlsym_függvény_miért_nem_mûködik_már_az_elf_állományokra>18.14. A dlsym() függvény miért nem mûködik már az ELF állományokra?<a class=anchor href=#_a_dlsym_függvény_miért_nem_mûködik_már_az_elf_állományokra></a></h3><div class=paragraph><p>Az ELF állományokhoz tartozó segédprogramok alapértelmezés szerint nem teszik láthatóvá a dinamikus linker számára a végrehajtható állományban definiált szimbólumokat. Ennek eredményeképpen a <code>dlsym()</code> a <code>dlopen(NULL, flags)</code> függvénytõl kapott információk alapján nem találja meg a keresett szimbólumokat.</p></div><div class=paragraph><p>Ha szükségünk lenne ilyen keresésekre a <code>dlsym()</code> használata során a program végrehajtható állományán belül, akkor az adott programot a <code>--export-dynamic</code> opció megadásával kell linkelni (lásd <a href="https://man.freebsd.org/cgi/man.cgi?query=ld&amp;sektion=1&amp;format=html">ld(1)</a>).</p></div></div><div class=sect2><h3 id=_hogyan_növelhetõ_vagy_csökkenthetõ_a_rendszermag_címtere_i386_architektúrán>18.15. Hogyan növelhetõ vagy csökkenthetõ a rendszermag címtere i386™ architektúrán?<a class=anchor href=#_hogyan_növelhetõ_vagy_csökkenthetõ_a_rendszermag_címtere_i386_architektúrán></a></h3><div class=paragraph><p>Az i386™ platformon a rendszermag címtere alapértelmezés szerint 1 GB (PAE esetén 2 GB). Ha komolyabb hálózati forgalmat bonyolító szerverünk van (például egy nagyobb FTP vagy HTTP szerver) vagy rendszerükön használni akarjuk a ZFS állományrendszert, akkor könnyen kifuthatunk a címtérbõl.</p></div><div class=paragraph><p>A címtér méretének megváltoztatásához vegyük fel a következõ sort a rendszermag konfigurációs állományába, majd fordítsuk újra a rendszermagot:</p></div><div class="literalblock programlisting"><div class=content><pre>options KVA_PAGES=N</pre></div></div><div class=paragraph><p>Az <em>N</em> megfelelõ értékének megállapításához osszuk el a beállítani kívánt címtér (MB-okban megadott) méretét néggyel. (Tehát például 2 GB esetén ez <code>512</code> lesz.)</p></div></div></div></div><div class=sect1><h2 id=_köszönetnyilvánítás>19. Köszönetnyilvánítás<a class=anchor href=#_köszönetnyilvánítás></a></h2><div class=sectionbody><div class=paragraph><p>Ezt a szegény kis ártatlan GYIKocskát több százan, ha nem is éppen több ezren írták, újraírták, szerkesztették, hajtogatták, tekergették, csonkítgatták, kibelezték, nézegették, összekutyulták, emlegették, felöklendezték, újraépítették, javítgatták és felpezsdítették az utóbbi években. Folyamatosan.</p></div><div class=paragraph><p>Ezúton is szeretnénk köszönetet mondani mindazoknak, akik gondozásukba vették, és mindenkit csak bátorítani tudunk, hogy <a href=https://docs.freebsd.org/en/articles/contributing/>csatlakozzon hozzájuk</a> a GYIK továbbfejlesztésében.</p></div></div></div><div class=sect1><h2 id=bibliography>Irodalomjegyzék<a class=anchor href=#bibliography></a></h2><div class=sectionbody><div class=paragraph><p>[biblio-unleashed] FreeBSD Unleashed. Michael Urban und Brian Tiemann. Sams. Erste Ausgabe. 992 Seiten. Oktober 2001. ISBN 0-67232-206-4.</p></div><div class=paragraph><p>[biblio-44sysman] 4.4BSD System Manager’s Manual. Computer Systems Research Group, University of California, Berkeley. O’Reilly and Associates. Erste Ausgabe. Juni 1994. 804 Seiten. ISBN 1-56592-080-5.</p></div><div class=paragraph><p>[biblio-44userman] 4.4BSD User’s Reference Manual. Computer Systems Research Group, University of California, Berkeley. O’Reilly and Associates. Erste Ausgabe. Juni 1994. 905 Seiten. ISBN 1-56592-075-9.</p></div><div class=paragraph><p>[biblio-44suppman] 4.4BSD User’s Supplementary Documents. Computer Systems Research Group, University of California, Berkeley. O’Reilly and Associates. Erste Ausgabe. Juni 1994. 712 Seiten. ISBN 1-56592-076-7.</p></div><div class=paragraph><p>[biblio-44progman] 4.4BSD Programmer’s Reference Manual. Computer Systems Research Group, University of California, Berkeley. O’Reilly and Associates. Erste Ausgabe. Juni 1994. 866 Seiten. ISBN 1-56592-078-3.</p></div><div class=paragraph><p>[biblio-44progsupp] 4.4BSD Programmer’s Supplementary Documents. Computer Systems Research Group, University of California, Berkeley. O’Reilly and Associates. Erste Ausgabe. Juni 1994. 596 Seiten. ISBN 1-56592-079-1.</p></div><div class=paragraph><p>[biblio-44kernel] The Design and Implementation of the 4.4BSD Operating System. M. K. McKusick, Kirk Marshall, Keith Bostic, Michael J Karels und John Quarterman. Addison-Wesley. Reading MA . 1996. ISBN 0-201-54979-4.</p></div><div class=paragraph><p>[biblio-freebsdkernel] The Design and Implementation of the FreeBSD Operating System. M. K. McKusick und George V. Neville-Neil. Addison-Wesley. Boston MA . 2004. ISBN 0-201-70245-2.</p></div><div class=paragraph><p>[biblio-nemeth3rd] Unix System Administration Handbook. Evi Nemeth, Garth Snyder, Scott Seebass, Trent R. Hein und John Quarterman. Prentice-Hall. Dritte Ausgabe. 2000. ISBN 0-13-020601-6.</p></div><div class=paragraph><p>[lehey3rd] The Complete FreeBSD. Greg Lehey. Walnut Creek. Dritte Ausgabe. Juni 1999. 773 Seiten. ISBN 1-57176-246-9.</p></div><div class=paragraph><p>[McKusick et al, 1994] Berkeley Software Architecture Manual, 4.4BSD Edition. M. K. McKusick, M. J. Karels, S. J. Leffler, W. N. Joy und R. S. Faber. 5:1-42.</p></div><div class=paragraph><p>[biblio-ja-fbsdpc98] FreeBSD for PC 98’ers (in Japanisch). SHUWA System Co, LTD.. ISBN 4-87966-468-5 C3055 P2900E.</p></div><div class=paragraph><p>[biblio-ja-fbsd] FreeBSD (in Japanisch). CUTT. ISBN 4-906391-22-2.</p></div><div class=paragraph><p>[biblio-ja-compintro] Complete Introduction to FreeBSD (in Japanisch). Shoeisha Co., Ltd. ISBN 4-88135-473-6 P3600E.</p></div><div class=paragraph><p>[biblio-ja-unixstarterkit] Personal UNIX Starter Kit FreeBSD (in Japanisch). ASCII. ISBN 4-7561-1733-3 P3000E.</p></div><div class=paragraph><p>[biblio-ja-fbsdhb] FreeBSD Handbook (Japanische Übersetzung). ASCII. ISBN 4-7561-1580-2 P3800E.</p></div><div class=paragraph><p>[biblio-ge-fbsdmitmeth] FreeBSD mit Methode (in Deutsch). Computer und Literature Verlag/Vertrieb Hanser. 1998. ISBN 3-932311-31-0.</p></div><div class=paragraph><p>[biblio-ja-fbsdinstandutil] FreeBSD install and Utilization Manual (in Japanisch). Mainichi Communications Inc..</p></div><div class=paragraph><p>[biblio-indo-intserv] Building Internet Server with FreeBSD (in Indonesisch). Elex Media Komputindo. Onno W Purbo, Dodi Maryanto, Syahrial Hubbany und Widjil Widodo.</p></div><div class=paragraph><p>[biblio-fbsdcorpnetguide] The FreeBSD Corporate Networker’s Guide. Addison-Wesley.</p></div><div class=paragraph><p>[biblio-unixnutshell] UNIX in a Nutshell. O’Reilly & Associates, Inc.. 1990. ISBN 093717520X.</p></div><div class=paragraph><p>[biblio-cantfindadmin] What You Need To Know When You Can’t Find Your Unix System Administrator. O’Reilly & Associates, Inc.. 1995. Linda Mui. ISBN 1-56592-104-6.</p></div><div class=paragraph><p>[biblio-ja-fbsdusrrefman] FreeBSD User’s Reference Manual (Japanische Übersetzung). Mainichi Communications Inc.. Jpman Project, Japan FreeBSD Users Group. 1998. ISBN 4-8399-0088-4 P3800E.</p></div><div class=paragraph><p>[biblio-newcomeunix] <a href=http://unixhelp.ed.ac.uk/>Online Guide for newcomers to the UNIX environment</a>“. <a href=http://www.ed.ac.uk/>Edinburgh University</a>.</p></div><div class=paragraph><p>[biblio-dnsandbind] DNS and BIND. O’Reilly & Associates, Inc. ISBN 1-56592-512-2. Paul Albitz Albitz und Cricket Liu. 1998. Dritte Ausgabe.</p></div><div class=paragraph><p>[biblio-sendmail] Sendmail. O’Reilly & Associates, Inc. 1997. Zweite Auflage. Brian Costales. ISBN 1-56592-222-0.</p></div><div class=paragraph><p>[biblio-esssysadmin] Essential System Administration. Æleen Frisch. Zweite Auflage. O’Reilly & Associates. 1995. ISBN 1-56592-127-5.</p></div><div class=paragraph><p>[biblio-tcpipnetworkadministration] TCP/IP Network Administration. Craig Hunt. Zweite Auflage. O’Reilly & Associates, Inc. 1997. ISBN 1-56592-322-7.</p></div><div class=paragraph><p>[biblio-managingnfsandnis] Managing NFS and NIS. Hal Stern. O’Reilly & Associates, Inc. 1991. ISBN 0-937175-75-7.</p></div><div class=paragraph><p>[biblio-jpmanprojectjfug] <a href=http://www.pc.mycom.co.jp/FreeBSD/sam.html>FreeBSD System Administration’s Manual</a>. <a href=http://www.jp.freebsd.org/>Jpman Project, Japan FreeBSD Users Group</a>. <a href=http://www.pc.mycom.co.jp/>Mainichi Communications Inc.</a>. 1998. ISBN 4-8399-0109-0 P3300E.</p></div><div class=paragraph><p>[biblio-xwinsystoolkit] X Window System Toolkit. Digital Press. Paul Asente. ISBN 1-55558-051-3.</p></div><div class=paragraph><p>[biblio-carefman] C: A Reference Manual. Prentice Hall. 1995. Vierte Auflage. Samuel P. Harbison und Guy L. Jr. Steele. ISBN 0-13-326224-3.</p></div><div class=paragraph><p>[biblio-thecproglang] The C Programming Language. Prentice Hall. 1998. Brian Kernighan und Dennis Ritchie. ISBN 0-13-110362-9.</p></div><div class=paragraph><p>[biblio-portingunixsoft] Porting UNIX Software. Greg Lehey. O’Reilly & Associates, Inc.. 1995. ISBN 1-56592-126-7.</p></div><div class=paragraph><p>[biblio-thestandardclibrary] The Standard C Library. Prentice Hall. 1992. P. J. Plauger. ISBN 0-13-131509-9.</p></div><div class=paragraph><p>[biblio-advprogintheunixenv] Advanced Programming in the UNIX Environment. Addison-Wesley. 1992. W. Richard Stevens. ISBN 0-201-56317-7.</p></div><div class=paragraph><p>[biblio-unixnetprog] UNIX Network Programming. W. Richard Stevens. Prentice Hall. 1998. Zweite Auflage. ISBN 0-13-490012-X.</p></div><div class=paragraph><p>[biblio-writeserialdriverforunix] Writing Serial Drivers for UNIX. Bill Wells. Dezember 1994. Dr. Dobb’s Journal. pp68-71, pp97-99.</p></div><div class=paragraph><p>[biblio-unixsysarch] UNIX System Architecture. Prentice-Hall, Inc. 1990. Prabhat K. Andleigh. ISBN 0-13-949843-5.</p></div><div class=paragraph><p>[biblio-portingunixtothe386] Porting UNIX to the 386. William Jolitz. Dr. Dobb’s Journal. Januar 1991 - Juli 1992.</p></div><div class=paragraph><p>[biblio-tcpipillv1theprotocols] TCP/IP Illustrated, Volume 1: The Protocols. W. Richard Stevens. Addison-Wesley. 1996. ISBN 0-201-63346-9.</p></div><div class=paragraph><p>[biblio-unixsysformodrnarch] Unix Systems for Modern Architectures. Addison-Wesley. Curt Schimmel. 1994. ISBN 0-201-63338-8.</p></div><div class=paragraph><p>[biblio-tcpipillvol3] TCP/IP Illustrated, Volume 3: TCP for Transactions, HTTP, NNTP and the UNIX Domain Protocols. Addison-Wesley. 1996. W. Richard Stevens. ISBN 0-201-63495-3.</p></div><div class=paragraph><p>[biblio-unixinternthenewfrontiers] UNIX Internals — The New Frontiers. Uresh Vahalia. Prentice Hall. 1996. ISBN 0-13-101908-2.</p></div><div class=paragraph><p>[biblio-tcpipillvol2theimplementation] TCP/IP Illustrated, Volume 2: The Implementation. Gary R. Wright und W. Richard Stevens. 1995. Addison-Wesley. ISBN 0-201-63354-X.</p></div><div class=paragraph><p>[biblio-firewallsandinternetsecurity] Firewalls and Internet Security: Repelling the Wily Hacker. William R. CHeswick und Steven M. Bellovin. Addison-Wesley. 1995. ISBN 0-201-63357-4.</p></div><div class=paragraph><p>[biblio-practicalunixsecurity] Practical UNIX Security. Simson Garfinkel und Gene Spafford. 1996. Zweite Auflage. O’Reilly & Associates, Inc. ISBN 1-56592-148-8.</p></div><div class=paragraph><p>[biblio-pgpprettygoodprivacy] PGP Pretty Good Privacy. Simson Garfinkel. O’Reilly & Associates, Inc. 1995. ISBN 1-56592-098-8.</p></div><div class=paragraph><p>[biblio-pentiumprocarch] Pentium Processor System Architecture. Don Anderson und Tom Shanley. Addison-Wesley. 1995. Zweite Auflage. ISBN 0-201-40992-5.</p></div><div class=paragraph><p>[biblio-progguidetothesvgacards] Programmer’s Guide to the EGA, VGA, and Super VGA Cards. Richard F. Ferraro. Dritte Ausgabe. Addison-Wesley. 1995. ISBN 0-201-62490-7.</p></div><div class=paragraph><p>[biblio-80486] 80486 System Architecture. Tom Shanley. Addison-Wesley. 1995. Dritte Ausgabe. ISBN 0-201-40994-1.</p></div><div class=paragraph><p>[biblio-isasysarch] ISA System Architecture. Tom Shanley. Addison-Wesley. Dritte Ausgabe. 1995. ISBN 0-201-40996-8.</p></div><div class=paragraph><p>[biblio-pcisysarch] PCI System Architecture. Tom Shanley. Addison-Wesley. 1995. Dritte Ausgabe. ISBN 0-201-40993-3.</p></div><div class=paragraph><p>[biblio-theundocumentedpc] The Undocumented PC. Frank Van Gilluwe. Addison-Wesley. 1994. ISBN 0-201-62277-7.</p></div><div class=paragraph><p>[biblio-bellsystemtechnicaljournal] Bell System Technical Journal, Unix Time-Sharing System. American Telephone & Telegraph Company. Juli - August 1978. Vol 57, No 6, Part 2. ISSN0005-8580.</p></div><div class=paragraph><p>[biblio-commentaryonunix] Lion’s Commentary on UNIX. John Lion. ITP Media Group. 1996. Sechste Ausgabe. ISBN 1573980137.</p></div><div class=paragraph><p>[biblio-newhackerdict] The New Hacker’s Dictionary. Eric S. Raymond. MIT Press. 1996. Dritte Ausgabe. ISBN 0-262-68092-0.</p></div><div class=paragraph><p>[biblio-aqtrcentofunix] A quarter century of UNIX. Peter H. Salus. Addison-Wesley. 1994. ISBN 0-201-54777-5.</p></div><div class=paragraph><p>[biblio-unixhatershandbook] The UNIX-HATERS Handbook. Steven Strassman, Daniel Weise und Simon Garfinkel. IDG Books Worldwide, Inc. 1994. ISBN 1-56884-203-1.</p></div><div class=paragraph><p>[biblio-lifewithunix] Life with UNIX - special edition. Don Libes und Sandy Ressler. Prentice-Hall. 1989. ISBN 0-13-536657-7.</p></div><div class=paragraph><p>[biblio-bsdfamilytree] <a href="https://svnweb.freebsd.org/base/head/shared/misc/bsd-family-tree?view=co">The BSD Family Tree</a>. 1997.</p></div><div class=paragraph><p>[absolutebsd] Absolute BSD. Michael Lucas. No Starch Press. Juni 2002. ISBN 1-886411-74-3.</p></div><div class=paragraph><p>[biblio-ccppusersjournal] The C/C++ Users Journal. R&amp;D Publications Inc.. ISSN 1075-2838.</p></div><div class=paragraph><p>[biblio-sysadminthejournalforunixsysadmins] Sys Admin - The Journal for UNIX System Administrators. Miller Freeman, Inc. ISSN 1061-2688.</p></div></div></div></div><hr><div class=last-modified><p><strong>Last modified on</strong>: 2021. november 3. by <a href="https://cgit.freebsd.org/doc/commit/?id=64acd169b8" target=_blank>Sergio Carlavilla Delgado</a></p></div><div class=buttons><div class=home><i class="fa fa-home" aria-hidden=true title=Home></i><div class=container><a href=../ class=direction>Home</a></div></div></div><label class="hidden book-menu-overlay" for=menu-control></label></div><aside class=toc><div class=toc-content><h3>Table of Contents</h3><nav id=TableOfContents><ul><li><a href=#_bevezetés>1. Bevezetés</a></li><li><a href=#_dokumentációs_és_támogatás>2. Dokumentációs és támogatás</a></li><li><a href=#_telepítés>3. Telepítés</a></li><li><a href=#hardware>4. Hardverkompatibilitás</a></li><li><a href=#_hibaelhárítás>5. Hibaelhárítás</a></li><li><a href=#_kereskedelmi_alkalmazások>6. Kereskedelmi alkalmazások</a></li><li><a href=#_felhasználói_alkalmazások>7. Felhasználói alkalmazások</a></li><li><a href=#_a_rendszermag_beállítása>8. A rendszermag beállítása</a></li><li><a href=#_lemezek_állományrendszerek_és_rendszertöltők>9. Lemezek, állományrendszerek és rendszertöltők</a></li><li><a href=#_rendszeradminisztráció>10. Rendszeradminisztráció</a></li><li><a href=#_az_x_window_system_és_a_virtuális_konzolok_használata>11. Az X Window System és a virtuális konzolok használata</a></li><li><a href=#_hálózatok>12. Hálózatok</a></li><li><a href=#_biztonság>13. Biztonság</a></li><li><a href=#_ppp>14. PPP</a></li><li><a href=#_soros_vonali_kommunikáció>15. Soros vonali kommunikáció</a></li><li><a href=#_egyéb_kérdések>16. Egyéb kérdések</a></li><li><a href=#_mókás_dolgok_a_freebsd_vel_kapcsolatban>17. Mókás dolgok a FreeBSD-vel kapcsolatban</a></li><li><a href=#_témák_haladóknak>18. Témák haladóknak</a></li><li><a href=#_köszönetnyilvánítás>19. Köszönetnyilvánítás</a></li><li><a href=#bibliography>Irodalomjegyzék</a></li></ul></nav><hr><div class=resources><h3>Resources</h3><ul class=contents><li><i class="fa fa-file-pdf-o" aria-hidden=true title="Download PDF"></i><a href=https://download.freebsd.org/doc/hu/books/faq/faq_hu.pdf>Download PDF</a></li><li><i class="fa fa-pencil-square-o" aria-hidden=true title="Edit this page"></i><a href=https://github.com/freebsd/freebsd-doc/blob/main/documentation/content/hu/_index target=_blank>Edit this page</a></li></ul></div></div></aside><a class=to-top href=#top><i class="fa fa-arrow-circle-up" aria-hidden=true></i></a></main><footer><div class=footer-container><section class=logo-column><img src=http://172.16.201.134:1313/images/FreeBSD-colors.svg width=160 height=50 alt="FreeBSD logo"><div class=options-container><div class=language-container><a id=languages href=http://172.16.201.134:1313/hu/languages><img src=http://172.16.201.134:1313/images/language.png class=language-image alt="Choose language">
<span>Hungarian</span></a></div><div class=theme-container><select id=theme-chooser><option value=theme-system>System</option><option value=theme-light>Light</option><option value=theme-dark>Dark</option><option value=theme-high-contrast>High contrast</option></select></div></div></section><section class=about-column><h3 class=column-title>About</h3><ul class=column-elements-container><li><a href=https://www.freebsd.org/about/ target=_blank class=column-element>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/ target=_blank class=column-element>FreeBSD Foundation</a></li><li><a href=https://www.freebsd.org/where/ target=_blank class=column-element>Get FreeBSD</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct target=_blank class=column-element>Code of Conduct</a></li><li><a href=https://www.freebsd.org/security/ target=_blank class=column-element>Security Advisories</a></li></ul></section><section class=documentation-column><h3 class=column-title>Documentation</h3><ul class=column-elements-container><li><a href=/hu class=column-element>Documentation portal</a></li><li><a href=https://man.FreeBSD.org target=_blank class=column-element>Manual pages</a></li><li><a href=https://papers.FreeBSD.org target=_blank class=column-element>Presentations and papers</a></li><li><a href=https://docs-archive.freebsd.org/doc/ target=_blank class=column-element>Previous versions</a></li><li><a href=https://docs-archive.freebsd.org/44doc/ target=_blank class=column-element>4.4BSD Documents</a></li><li><a href=https://wiki.freebsd.org/ target=_blank class=column-element>Wiki</a></li></ul></section><section class=community-column><h3 class=column-title>Community</h3><ul class=column-elements-container><li><a href=http://172.16.201.134:1313/hu/articles/contributing class=column-element>Get involved</a></li><li><a href=https://forums.freebsd.org/ target=_blank class=column-element>Community forum</a></li><li><a href=https://lists.freebsd.org/ target=_blank class=column-element>Mailing lists</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank class=column-element>IRC Channels</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank class=column-element>Bug Tracker</a></li></ul></section><section class=legal-column><h3 class=column-title>Legal</h3><ul class=column-elements-container><li><a href=https://freebsdfoundation.org/donate/ target=_blank class=column-element>Donations</a></li><li><a href=https://www.freebsd.org/copyright/freebsd-license/ target=_blank class=column-element>Licensing</a></li><li><a href=https://www.freebsd.org/privacy/ target=_blank class=column-element>Privacy Policy</a></li><li><a href=https://www.freebsd.org/copyright/ target=_blank class=column-element>Legal notices</a></li></ul></section><section class=copyright-column><p>&copy; 1994-2024 The FreeBSD Project. All rights reserved</p><span>Made with <span class=heart>♥</span> by the FreeBSD Community</span></section></div></footer></body></html>