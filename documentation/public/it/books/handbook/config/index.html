<!doctype html><html class=theme-light lang=it><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content><meta name=keywords content><meta name=copyright content="1995-2024 The FreeBSD Foundation"><link rel=canonical href=https://docs.freebsd.org/it/books/handbook/config/><title>Capitolo 11. Configurazione e Messa a Punto | FreeBSD Documentation Portal</title>
<meta name=theme-color content="#790000"><meta name=color-scheme content="system light dark high-contrast"><link rel="shortcut icon" href=https://docs.freebsd.org/favicon.ico><link rel=stylesheet href=https://docs.freebsd.org/styles/main.min.css><link rel=stylesheet href=https://docs.freebsd.org/css/font-awesome-min.css><script defer src=/js/theme-chooser.min.js></script><script defer src=/js/copy-clipboard.min.js></script><script defer src=/js/search.min.js></script><meta name=twitter:card content="summary"><meta name=twitter:domain content="docs.FreeBSD.org"><meta name=twitter:site content="@freebsd"><meta name=twitter:url content="https://twitter.com/freebsd"><meta property="og:title" content="Capitolo 11. Configurazione e Messa a Punto"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:image" content="https://docs.freebsd.org/favicon.ico"><meta property="og:image:alt" content="FreeBSD Logo"><meta property="og:locale" content="it"><meta property="og:url" content="https://docs.freebsd.org/it/books/handbook/config/"><meta property="og:site_name" content="FreeBSD Documentation Portal"><script type=application/ld+json>{"@context":"http://schema.org","@type":"Article","url":"https:\/\/docs.freebsd.org\/it\/books\/handbook\/config\/","name":"FreeBSD Documentation Portal","headline":"FreeBSD Documentation Portal","description":"FreeBSD Documentation Portal"}</script></head><body><header><div class=header-container><div class=logo-menu-bars-container><a href=https://www.FreeBSD.org class=logo><img src=https://docs.freebsd.org/images/FreeBSD-monochromatic.svg width=160 height=50 alt="FreeBSD logo">
</a><label class=menu-bars for=menu-bars><i class="fa fa-bars" aria-hidden=true></i></label></div><input id=menu-bars type=checkbox><nav><ul class=menu><li class=menu-item><input id=about type=checkbox>
<a href=# aria-label="Navigate to About section"><label class=menu-item-description for=about>About
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/about/ target=_blank>About</a></li><li><a href=https://www.freebsd.org/about/ target=_blank>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/about-us/about-the-foundation/ target=_blank>FreeBSD Foundation</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct/ target=_blank>Code of Conduct</a></li></ul></li><li class=menu-item><input id=download type=checkbox>
<a href=# aria-label="Navigate to get FreeBSD section"><label class=menu-item-description for=download>Get FreeBSD
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/where/ target=_blank>Get FreeBSD</a></li><li><a href=https://www.freebsd.org/releases/ target=_blank>Release Information</a></li><li><a href=https://www.freebsd.org/releng/ target=_blank>Release Engineering</a></li><li><a href=https://www.freebsd.org/security/ target=_blank>Security Advisories</a></li></ul></li><li class=menu-item><input id=documentation type=checkbox>
<a href=# aria-label="Navigate to get Documentation section"><label class=menu-item-description for=documentation>Documentation
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=/it>Documentation portal</a></li><li><a href=https://docs.freebsd.org/it/books/handbook>FreeBSD Handbook</a></li><li><a href=https://docs.freebsd.org/it/books/porters-handbook>Porter's Handbook</a></li><li><a href=https://docs.FreeBSD.org/en/books/fdp-primer>Documentation Project Handbook</a></li><li><a href=https://man.FreeBSD.org target=_blank>Manual pages</a></li><li><a href=https://papers.FreeBSD.org target=_blank>Presentations and papers</a></li><li><a href=https://wiki.FreeBSD.org target=_blank>Wiki</a></li><li><a href=https://docs.freebsd.org/it/books>Books</a></li><li><a href=https://docs.freebsd.org/it/articles>Articles</a></li></ul></li><li class=menu-item><input id=community type=checkbox>
<a href=# aria-label="Navigate to get Community section"><label class=menu-item-description for=community>Community
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/community/>Community</a></li><li><a href=https://docs.freebsd.org/it/articles/contributing>Get involved</a></li><li><a href=https://forums.freebsd.org/ target=_blank>Forum</a></li><li><a href=https://lists.freebsd.org/ target=_blank>Mailing lists</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank>IRC Channels</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank>Bug Tracker</a></li><li><a href=https://www.freebsd.org/support/ target=_blank>Support</a></li></ul></li></ul></nav><div class=search-donate-container><form class=search method=get id=search-header-form action=https://docs.freebsd.org/search name=search-header-form><input type=hidden name=DB value=it>
<input id=words name=P type=text size=20 maxlength=255>
<button>
<i class="fa fa-search" aria-hidden=true></i></button></form><div class=donate><a href=https://freebsdfoundation.org/donate/ target=_blank><span class=heart>♥</span>
Donate</a></div></div></div></header><input type=checkbox class="hidden toggle" id=menu-control><main class=main-wrapper-book><a id=top></a><aside class=book-menu><div class=book-menu-content><input id=search-book type=text placeholder=Ricerca aria-label=Ricerca maxlength=128><nav id=MenuContents><ul><li><input type=checkbox id=chapter-eb2a98ce203d8afd517726e6d8776be3 class=toggle>
<label class="icon cursor" for=chapter-eb2a98ce203d8afd517726e6d8776be3><a role=button></a></label><a href=https://docs.freebsd.org/it/books/handbook/preface/>Prefazione</a><ul><li><a href=https://docs.freebsd.org/it/books/handbook/preface/#preface-audience>A chi si rivolge</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/preface/#italian-notes>Note alla Edizione Italiana</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/preface/#preface-overview>Organizzazione di Questo Libro</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/preface/#preface-conv>Convenzioni usate in questo libro</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/preface/#preface-acknowledgements>Riconoscimenti</a></li></ul></li><li><input type=checkbox id=chapter-14a525fce014b90b8a458a894818255a class=toggle>
<label for=chapter-14a525fce014b90b8a458a894818255a><a role=button></a></label><a href=https://docs.freebsd.org/it/books/handbook/parti/>Parte I. Per Cominciare</a></li><li><input type=checkbox id=chapter-f9c9f3451644df30d224350da97d5da6 class=toggle>
<label class="icon cursor" for=chapter-f9c9f3451644df30d224350da97d5da6><a role=button></a></label><a href=https://docs.freebsd.org/it/books/handbook/introduction/>Capitolo 1. Introduzione</a><ul><li><a href=https://docs.freebsd.org/it/books/handbook/introduction/#introduction-synopsis>1.1. Sinossi</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/introduction/#nutshell>1.2. Benvenuto in FreeBSD!</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/introduction/#history>1.3. Informazioni sul FreeBSD Project</a></li></ul></li><li><input type=checkbox id=chapter-6aaec170775233b7c45f6cdcfb70d466 class=toggle>
<label class="icon cursor" for=chapter-6aaec170775233b7c45f6cdcfb70d466><a role=button></a></label><a href=https://docs.freebsd.org/it/books/handbook/install/>Capitolo 2. Installazione di FreeBSD</a><ul><li><a href=https://docs.freebsd.org/it/books/handbook/install/#install-synopsis>2.1. Sinossi</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/install/#install-pre>2.2. Compiti Prima dell’Installazione</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/install/#install-start>2.3. Iniziare l’Installazione</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/install/#using-sysinstall>2.4. Introduzione a Sysinstall</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/install/#install-steps>2.5. Allocazione dello Spazio su Disco</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/install/#install-choosing>2.6. Scegliere Cosa Installare</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/install/#install-media>2.7. Scegli il Tuo Media di Installazione</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/install/#install-final-warning>2.8. Procedere con l’Installazione</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/install/#install-post>2.9. Post-installazione</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/install/#install-supported-hardware>2.10. Hardware Supportato</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/install/#install-trouble>2.11. Localizzazione dei guasti</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/install/#install-advanced>2.12. Guida per un’Installazione Avanzata</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/install/#install-diff-media>2.13. Preparare i Propri Media di Installazione</a></li></ul></li><li><input type=checkbox id=chapter-9f6db261075f578742036fcc6000eecd class=toggle>
<label class="icon cursor" for=chapter-9f6db261075f578742036fcc6000eecd><a role=button></a></label><a href=https://docs.freebsd.org/it/books/handbook/basics/>Capitolo 3. Basi di Unix</a><ul><li><a href=https://docs.freebsd.org/it/books/handbook/basics/#basics-synopsis>3.1. Sinossi</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/basics/#consoles>3.2. Console Virtuali e Terminali</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/basics/#permissions>3.3. I Permessi</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/basics/#dirstructure>3.4. Struttura delle Directory</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/basics/#disk-organization>3.5. Organizzazione del Disco</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/basics/#mount-unmount>3.6. Montaggio e Smontaggio dei File system</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/basics/#basics-processes>3.7. I Processi</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/basics/#basics-daemons>3.8. I Demoni, i Segnali, e come Uccidere i Processi</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/basics/#shells>3.9. Le Shell</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/basics/#editors>3.10. Editor di Testo</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/basics/#basics-devices>3.11. Dispositivi e Nodi di Dispositivo</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/basics/#binary-formats>3.12. Formati dei Binari</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/basics/#basics-more-information>3.13. Per Maggiori Informazioni</a></li></ul></li><li><input type=checkbox id=chapter-01c5707e95d14c0ff84bf62600c958d1 class=toggle>
<label class="icon cursor" for=chapter-01c5707e95d14c0ff84bf62600c958d1><a role=button></a></label><a href=https://docs.freebsd.org/it/books/handbook/ports/>Capitolo 4. Installazione delle Applicazioni: Port e Package</a><ul><li><a href=https://docs.freebsd.org/it/books/handbook/ports/#ports-synopsis>4.1. Sinossi</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/ports/#ports-overview>4.2. Uno Sguardo all’Installazione del Software</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/ports/#ports-finding-applications>4.3. Ricerca della Propria Applicazione</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/ports/#packages-using>4.4. Utilizzo del Sistema dei Package</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/ports/#ports-using>4.5. Utilizzo della Collezione dei Port</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/ports/#ports-nextsteps>4.6. Attività del Dopo Installazione</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/ports/#ports-broken>4.7. Avere a che Fare con Port non Funzionanti</a></li></ul></li><li><input type=checkbox id=chapter-3405c00581365a8b5d16af70fe4d1b72 class=toggle>
<label class="icon cursor" for=chapter-3405c00581365a8b5d16af70fe4d1b72><a role=button></a></label><a href=https://docs.freebsd.org/it/books/handbook/x11/>Capitolo 5. L'X Window System</a><ul><li><a href=https://docs.freebsd.org/it/books/handbook/x11/#x11-synopsis>5.1. Sinossi</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/x11/#x-understanding>5.2. Capire X</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/x11/#x-install>5.3. Installazione di X11</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/x11/#x-config>5.4. La Configurazione di X11</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/x11/#x-fonts>5.5. Usare i Font in X11</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/x11/#x-xdm>5.6. L’X Display Manager</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/x11/#x11-wm>5.7. Desktop Environment</a></li></ul></li><li><input type=checkbox id=chapter-0eab3565e8f59f5a8a896dfba7eb3680 class=toggle>
<label for=chapter-0eab3565e8f59f5a8a896dfba7eb3680><a role=button></a></label><a href=https://docs.freebsd.org/it/books/handbook/partii/>Parte II. Compiti Ordinari</a></li><li><input type=checkbox id=chapter-b33cf28993f3f7bf5baf036e79da0f39 class=toggle>
<label class="icon cursor" for=chapter-b33cf28993f3f7bf5baf036e79da0f39><a role=button></a></label><a href=https://docs.freebsd.org/it/books/handbook/desktop/>Capitolo 6. Applicazioni Desktop</a><ul><li><a href=https://docs.freebsd.org/it/books/handbook/desktop/#desktop-synopsis>6.1. Sinossi</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/desktop/#desktop-browsers>6.2. Browser</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/desktop/#desktop-productivity>6.3. Produttività</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/desktop/#desktop-viewers>6.4. Visualizzatori di Documenti</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/desktop/#desktop-finance>6.5. Bilancio</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/desktop/#desktop-summary>6.6. Sommario</a></li></ul></li><li><input type=checkbox id=chapter-152f694a19312ad72ec7bb4e1c3c33b2 class=toggle>
<label class="icon cursor" for=chapter-152f694a19312ad72ec7bb4e1c3c33b2><a role=button></a></label><a href=https://docs.freebsd.org/it/books/handbook/multimedia/>Capitolo 7. Multimedia</a><ul><li><a href=https://docs.freebsd.org/it/books/handbook/multimedia/#multimedia-synopsis>7.1. Sinossi</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/multimedia/#sound-setup>7.2. Configurazione della Scheda Audio</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/multimedia/#sound-mp3>7.3. Audio MP3</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/multimedia/#video-playback>7.4. Riproduzione Video</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/multimedia/#tvcard>7.5. Configurazione delle Schede TV</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/multimedia/#scanners>7.6. Scanner di immagini</a></li></ul></li><li><input type=checkbox id=chapter-80888b4ee02e3e409e5f71cf97a36450 class=toggle>
<label class="icon cursor" for=chapter-80888b4ee02e3e409e5f71cf97a36450><a role=button></a></label><a href=https://docs.freebsd.org/it/books/handbook/kernelconfig/>Capitolo 8. Configurazione del Kernel di FreeBSD</a><ul><li><a href=https://docs.freebsd.org/it/books/handbook/kernelconfig/#kernelconfig-synopsis>8.1. Synopsis</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/kernelconfig/#kernelconfig-custom-kernel>8.2. Perchè creare un kernel custom?</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/kernelconfig/#kernelconfig-building>8.3. Compilare ed installare un Kernel Custom</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/kernelconfig/#kernelconfig-config>8.4. Il File di Configurazione</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/kernelconfig/#kernelconfig-trouble>8.5. Se Qualcosa Va Male</a></li></ul></li><li><input type=checkbox id=chapter-cb174c55879b17ab955f2f16989a79e0 class=toggle>
<label class="icon cursor" for=chapter-cb174c55879b17ab955f2f16989a79e0><a role=button></a></label><a href=https://docs.freebsd.org/it/books/handbook/printing/>Capitolo 9. Stampa</a><ul><li><a href=https://docs.freebsd.org/it/books/handbook/printing/#_sinossi>9.1. Sinossi</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/printing/#printing-intro-spooler>9.2. Introduction</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/printing/#printing-intro-setup>9.3. Basic Setup</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/printing/#printing-advanced>9.4. Advanced Printer Setup</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/printing/#printing-using>9.5. Using Printers</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/printing/#printing-lpd-alternatives>9.6. Alternatives to the Standard Spooler</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/printing/#printing-troubleshooting>9.7. Troubleshooting</a></li></ul></li><li><input type=checkbox id=chapter-c12b8c3f2a8fcefce87087241f695c83 class=toggle>
<label class="icon cursor" for=chapter-c12b8c3f2a8fcefce87087241f695c83><a role=button></a></label><a href=https://docs.freebsd.org/it/books/handbook/linuxemu/>Capitolo 10. Compatibilità con i Binari di Linux</a><ul><li><a href=https://docs.freebsd.org/it/books/handbook/linuxemu/#linuxemu-synopsis>10.1. Sinossi</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/linuxemu/#linuxemu-lbc-install>10.2. Installazione</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/linuxemu/#linuxemu-mathematica>10.3. Installazione di Mathematica®</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/linuxemu/#linuxemu-maple>10.4. Installazione di Maple™</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/linuxemu/#linuxemu-matlab>10.5. Installazione di MATLAB®</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/linuxemu/#linuxemu-oracle>10.6. Installazione di Oracle®</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/linuxemu/#sapr3>10.7. Installazione di SAP® R/3®</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/linuxemu/#linuxemu-advanced>10.8. Argomenti Avanzati</a></li></ul></li><li><input type=checkbox id=chapter-03b11ba627b9a0c85b247f5641bde272 class=toggle>
<label for=chapter-03b11ba627b9a0c85b247f5641bde272><a role=button></a></label><a href=https://docs.freebsd.org/it/books/handbook/partiii/>Parte III. Amministrazione del Sistema</a></li><li><input type=checkbox id=chapter-6c31587f8d736319f099cd4dc1961301 class=toggle checked>
<label class="icon cursor" for=chapter-6c31587f8d736319f099cd4dc1961301><a role=button></a></label><a href=https://docs.freebsd.org/it/books/handbook/config/>Capitolo 11. Configurazione e Messa a Punto</a><ul><li><a href=https://docs.freebsd.org/it/books/handbook/config/#config-synopsis>11.1. Sinossi</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/config/#configtuning-initial>11.2. Configurazione Iniziale</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/config/#configtuning-core-configuration>11.3. Configurazione Principale</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/config/#configtuning-appconfig>11.4. Configurazione delle Applicazioni</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/config/#configtuning-starting-services>11.5. Avvio dei Servizi</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/config/#configtuning-cron>11.6. Configurare l’Utility <code>cron</code></a></li><li><a href=https://docs.freebsd.org/it/books/handbook/config/#configtuning-rcd>11.7. Usare rc con FreeBSD</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/config/#config-network-setup>11.8. Configurazione delle Interfacce di Rete</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/config/#configtuning-virtual-hosts>11.9. Host Virtuali</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/config/#configtuning-configfiles>11.10. File di Configurazione</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/config/#configtuning-sysctl>11.11. Messa a Punto con sysctl</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/config/#configtuning-disk>11.12. Messa a Punto dei Dischi</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/config/#configtuning-kernel-limits>11.13. Messa a Punto dei Limiti del Kernel</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/config/#adding-swap-space>11.14. Aggiunta di Spazio di Swap</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/config/#acpi-overview>11.15. Gestione dell’Energia e delle Risorse</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/config/#ACPI-debug>11.16. Usare e Debuggare ACPI di FreeBSD</a></li></ul></li><li><input type=checkbox id=chapter-459f0012b3b4f0b6b123010f029da5e4 class=toggle>
<label class="icon cursor" for=chapter-459f0012b3b4f0b6b123010f029da5e4><a role=button></a></label><a href=https://docs.freebsd.org/it/books/handbook/boot/>Capitolo 12. La Procedura di Avvio di FreeBSD</a><ul><li><a href=https://docs.freebsd.org/it/books/handbook/boot/#boot-synopsis>12.1. Sinossi</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/boot/#boot-introduction>12.2. Il Problema dell’Avvio</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/boot/#boot-blocks>12.3. Il Boot Manager e le Fasi di Boot</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/boot/#boot-kernel>12.4. Interazione con il Kernel Durante l’Avvio</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/boot/#device-hints>12.5. Device Hints</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/boot/#boot-init>12.6. Init: Inizializzazione del Controllo dei Processi</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/boot/#boot-shutdown>12.7. Sequenza di Spegnimento</a></li></ul></li><li><input type=checkbox id=chapter-d251c21b963b5ab783e5aec225e02b5a class=toggle>
<label class="icon cursor" for=chapter-d251c21b963b5ab783e5aec225e02b5a><a role=button></a></label><a href=https://docs.freebsd.org/it/books/handbook/users/>Capitolo 13. Gestione degli Utenti e degli Account di Base</a><ul><li><a href=https://docs.freebsd.org/it/books/handbook/users/#users-synopsis>13.1. Sinossi</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/users/#users-introduction>13.2. Introduction</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/users/#users-superuser>13.3. The Superuser Account</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/users/#users-system>13.4. System Accounts</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/users/#users-user>13.5. User Accounts</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/users/#users-modifying>13.6. Modifying Accounts</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/users/#users-limiting>13.7. Limiting Users</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/users/#users-personalizing>13.8. Personalizing Users</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/users/#users-groups>13.9. Groups</a></li></ul></li><li><input type=checkbox id=chapter-917c75fcffbb14d48ed6d0a48e7028f2 class=toggle>
<label class="icon cursor" for=chapter-917c75fcffbb14d48ed6d0a48e7028f2><a role=button></a></label><a href=https://docs.freebsd.org/it/books/handbook/security/>Capitolo 14. Sicurezza</a><ul><li><a href=https://docs.freebsd.org/it/books/handbook/security/#security-synopsis>14.1. Sinossi</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/security/#security-intro>14.2. Introduzione</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/security/#securing-freebsd>14.3. Rendere sicuro FreeBSD</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/security/#crypt>14.4. DES, MD5 e Crypt</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/security/#one-time-passwords>14.5. Password One-time</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/security/#tcpwrappers>14.6. TCP Wrappers</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/security/#kerberosIV>14.7. KerberosIV</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/security/#kerberos5>14.8. Kerberos5</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/security/#openssl>14.9. OpenSSL</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/security/#ipsec>14.10. IPsec</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/security/#openssh>14.11. OpenSSH</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/security/#fs-acl>14.12. File System Access Control Lists</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/security/#security-portaudit>14.13. Monitoring Third Party Security Issues</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/security/#security-advisories>14.14. FreeBSD Security Advisories</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/security/#security-accounting>14.15. Process Accounting</a></li></ul></li><li><input type=checkbox id=chapter-1a2a8e719703649c2c66d99aa7a25fd4 class=toggle>
<label class="icon cursor" for=chapter-1a2a8e719703649c2c66d99aa7a25fd4><a role=button></a></label><a href=https://docs.freebsd.org/it/books/handbook/jails/>Capitolo 15. Jail</a><ul><li><a href=https://docs.freebsd.org/it/books/handbook/jails/#jails-synopsis>15.1. Sinossi</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/jails/#jails-terms>15.2. Termini Relativi alle Jail</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/jails/#jails-intro>15.3. Introduzione</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/jails/#jails-build>15.4. Creare e Controllare la Jail</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/jails/#jails-tuning>15.5. Messa a Punto ed Amministrazione</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/jails/#jails-application>15.6. Applicazioni di Jail</a></li></ul></li><li><input type=checkbox id=chapter-8f4620c77e572cbb58917911a33c73cf class=toggle>
<label class="icon cursor" for=chapter-8f4620c77e572cbb58917911a33c73cf><a role=button></a></label><a href=https://docs.freebsd.org/it/books/handbook/mac/>Capitolo 16. Mandatory Access Control</a><ul><li><a href=https://docs.freebsd.org/it/books/handbook/mac/#mac-synopsis>16.1. Sinossi</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/mac/#mac-inline-glossary>16.2. Key Terms in this Chapter</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/mac/#mac-initial>16.3. Explanation of MAC</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/mac/#mac-understandlabel>16.4. Understanding MAC Labels</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/mac/#mac-modules>16.5. Module Configuration</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/mac/#mac-bsdextended>16.6. The MAC bsdextended Module</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/mac/#mac-ifoff>16.7. The MAC ifoff Module</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/mac/#mac-portacl>16.8. The MAC portacl Module</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/mac/#mac-labelingpolicies>16.9. MAC Policies with Labeling Features</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/mac/#mac-partition>16.10. The MAC partition Module</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/mac/#mac-mls>16.11. The MAC Multi-Level Security Module</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/mac/#mac-biba>16.12. The MAC Biba Module</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/mac/#mac-lomac>16.13. The MAC LOMAC Module</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/mac/#mac-implementing>16.14. Implementing a Secure Environment with MAC</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/mac/#MAC-examplehttpd>16.15. Another Example: Using MAC to Constrain A Web Server</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/mac/#mac-examplesandbox>16.16. An Example of a MAC Sandbox</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/mac/#mac-troubleshoot>16.17. Troubleshooting the MAC Framework</a></li></ul></li><li><input type=checkbox id=chapter-9598d66a76cb3182057b6bcd775149a0 class=toggle>
<label class="icon cursor" for=chapter-9598d66a76cb3182057b6bcd775149a0><a role=button></a></label><a href=https://docs.freebsd.org/it/books/handbook/audit/>Capitolo 17. Auditing degli Eventi di Sicurezza</a><ul><li><a href=https://docs.freebsd.org/it/books/handbook/audit/#audit-synopsis>17.1. Sinossi</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/audit/#audit-inline-glossary>17.2. Termini chiave - Parole da conoscere</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/audit/#audit-install>17.3. Installare il Supporto Audit</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/audit/#audit-config>17.4. Configurazione dell’Audit</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/audit/#audit-administration>17.5. Amministrare il Sottosistema Audit</a></li></ul></li><li><input type=checkbox id=chapter-e1edcad13d9db6e8e4cb645d378ecfaf class=toggle>
<label class="icon cursor" for=chapter-e1edcad13d9db6e8e4cb645d378ecfaf><a role=button></a></label><a href=https://docs.freebsd.org/it/books/handbook/disks/>Capitolo 18. Archiviazione dei Dati</a><ul><li><a href=https://docs.freebsd.org/it/books/handbook/disks/#disks-synopsis>18.1. Sinossi</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/disks/#disks-naming>18.2. Device Names</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/disks/#disks-adding>18.3. Adding Disks</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/disks/#raid>18.4. RAID</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/disks/#creating-cds>18.5. Creating and Using Optical Media (CDs & DVDs)</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/disks/#floppies>18.6. Creating and Using Floppy Disks</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/disks/#backups-tapebackups>18.7. Creating and Using Data Tapes</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/disks/#backups-floppybackups>18.8. Backups to Floppies</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/disks/#backup-basics>18.9. Backup Basics</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/disks/#disks-virtual>18.10. Network, Memory, and File-Based File Systems</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/disks/#snapshots>18.11. File System Snapshots</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/disks/#quotas>18.12. File System Quotas</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/disks/#disks-encrypting>18.13. Encrypting Disk Partitions</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/disks/#swap-encrypting>18.14. Encrypting Swap Space</a></li></ul></li><li><input type=checkbox id=chapter-dde37901a0e0ea32745b67607854900f class=toggle>
<label class="icon cursor" for=chapter-dde37901a0e0ea32745b67607854900f><a role=button></a></label><a href=https://docs.freebsd.org/it/books/handbook/geom/>Capitolo 19. GEOM: Framework modulare per la trasformazione del disco</a><ul><li><a href=https://docs.freebsd.org/it/books/handbook/geom/#GEOM-synopsis>19.1. Sinossi</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/geom/#GEOM-intro>19.2. Introduzione a GEOM</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/geom/#GEOM-striping>19.3. RAID0 - Striping</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/geom/#GEOM-mirror>19.4. RAID1 - Mirroring</a></li></ul></li><li><input type=checkbox id=chapter-dcd5a59a66ab6bff19287ccc6a33fd7e class=toggle>
<label class="icon cursor" for=chapter-dcd5a59a66ab6bff19287ccc6a33fd7e><a role=button></a></label><a href=https://docs.freebsd.org/it/books/handbook/vinum/>Capitolo 20. Il Gestore di Volumi Vinum</a><ul><li><a href=https://docs.freebsd.org/it/books/handbook/vinum/#vinum-synopsis>20.1. Sinossi</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/vinum/#vinum-intro>20.2. Dischi Troppo Piccoli</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/vinum/#vinum-access-bottlenecks>20.3. Colli di Bottiglia nell’Accesso</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/vinum/#vinum-data-integrity>20.4. Integrità dei Dati</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/vinum/#vinum-objects>20.5. Oggetti Vinum</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/vinum/#vinum-examples>20.6. Alcuni Esempi</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/vinum/#vinum-object-naming>20.7. Nomenclatura degli Oggetti</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/vinum/#vinum-config>20.8. Configurare Vinum</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/vinum/#vinum-root>20.9. Usare Vinum nel Filesystem Root</a></li></ul></li><li><input type=checkbox id=chapter-375257268d95faaf87faf4f7a2e6aa67 class=toggle>
<label class="icon cursor" for=chapter-375257268d95faaf87faf4f7a2e6aa67><a role=button></a></label><a href=https://docs.freebsd.org/it/books/handbook/virtualization/>Capitolo 21. Virtualizzazione</a><ul><li><a href=https://docs.freebsd.org/it/books/handbook/virtualization/#virtualization-synopsis>21.1. Sinossi</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/virtualization/#virtualization-guest>21.2. FreeBSD as a Guest OS</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/virtualization/#virtualization-host>21.3. FreeBSD as a Host OS</a></li></ul></li><li><input type=checkbox id=chapter-49f1e96591c090304ea532012257f4ef class=toggle>
<label class="icon cursor" for=chapter-49f1e96591c090304ea532012257f4ef><a role=button></a></label><a href=https://docs.freebsd.org/it/books/handbook/l10n/>Capitolo 22. Localizzazione - Uso e Impostazione dell'I18N/L10N</a><ul><li><a href=https://docs.freebsd.org/it/books/handbook/l10n/#l10n-synopsys>22.1. Sinossi</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/l10n/#l10n-basics>22.2. Principi di Base</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/l10n/#using-localization>22.3. Come Utilizzare la Localizzazione</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/l10n/#l10n-compiling>22.4. Compilazione dei Programmi con Supporto I18N</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/l10n/#lang-setup>22.5. Localizzazione di FreeBSD con Lingue Particolari</a></li></ul></li><li><input type=checkbox id=chapter-dead2b4c5ea325dd390a9b0dccd8f763 class=toggle>
<label class="icon cursor" for=chapter-dead2b4c5ea325dd390a9b0dccd8f763><a role=button></a></label><a href=https://docs.freebsd.org/it/books/handbook/cutting-edge/>Capitolo 23. Lo Stato dell'Arte</a><ul><li><a href=https://docs.freebsd.org/it/books/handbook/cutting-edge/#_sinossi>23.1. Sinossi</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/cutting-edge/#current-stable>23.2. FreeBSD-CURRENT vs. FreeBSD-STABLE</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/cutting-edge/#synching>23.3. Synchronizing Your Source</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/cutting-edge/#makeworld>23.4. Using <code>make world</code></a></li><li><a href=https://docs.freebsd.org/it/books/handbook/cutting-edge/#small-lan>23.5. Tracking for multiple machines</a></li></ul></li><li><input type=checkbox id=chapter-bbd25f9a194f9c39ca2d658c75767db5 class=toggle>
<label for=chapter-bbd25f9a194f9c39ca2d658c75767db5><a role=button></a></label><a href=https://docs.freebsd.org/it/books/handbook/partiv/>Parte IV. Comunicazione di Rete</a></li><li><input type=checkbox id=chapter-499dab596afd7ddac77e80295314e0dd class=toggle>
<label class="icon cursor" for=chapter-499dab596afd7ddac77e80295314e0dd><a role=button></a></label><a href=https://docs.freebsd.org/it/books/handbook/serialcomms/>Capitolo 24. Comunicazioni Seriali</a><ul><li><a href=https://docs.freebsd.org/it/books/handbook/serialcomms/#serial-synopsis>24.1. Sinossi</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/serialcomms/#serial>24.2. Introduzione</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/serialcomms/#term>24.3. Terminali</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/serialcomms/#dialup>24.4. Servizio di Ricezione Chiamate</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/serialcomms/#dialout>24.5. Servizio di Effettuazione Chiamate</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/serialcomms/#serialconsole-setup>24.6. Impostazione della Console Seriale</a></li></ul></li><li><input type=checkbox id=chapter-95e4571c48bee1cced5e84a538d302e3 class=toggle>
<label class="icon cursor" for=chapter-95e4571c48bee1cced5e84a538d302e3><a role=button></a></label><a href=https://docs.freebsd.org/it/books/handbook/ppp-and-slip/>Capitolo 25. PPP e SLIP</a><ul><li><a href=https://docs.freebsd.org/it/books/handbook/ppp-and-slip/#_sinossi>25.1. Sinossi</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/ppp-and-slip/#userppp>25.2. Using User PPP</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/ppp-and-slip/#ppp>25.3. Using Kernel PPP</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/ppp-and-slip/#pppoe>25.4. Using PPP over Ethernet (PPPoE)</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/ppp-and-slip/#pppoa>25.5. Using PPP over ATM (PPPoA)</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/ppp-and-slip/#slip>25.6. Using SLIP</a></li></ul></li><li><input type=checkbox id=chapter-f089ac726c401c9b4bd5c34a295e11bb class=toggle>
<label class="icon cursor" for=chapter-f089ac726c401c9b4bd5c34a295e11bb><a role=button></a></label><a href=https://docs.freebsd.org/it/books/handbook/mail/>Capitolo 26. Posta Elettronica</a><ul><li><a href=https://docs.freebsd.org/it/books/handbook/mail/#mail-synopsis>26.1. Sinossi</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/mail/#mail-using>26.2. Utilizzo della Posta Elettronica</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/mail/#sendmail>26.3. Configurazione di sendmail</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/mail/#mail-changingmta>26.4. Sostituzione del proprio Mail Transfer Agent</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/mail/#mail-trouble>26.5. Risoluzione dei Problemi</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/mail/#mail-advanced>26.6. Argomenti Avanzati</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/mail/#SMTP-UUCP>26.7. SMTP con UUCP</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/mail/#outgoing-only>26.8. Configurazione del Sistema di Posta solo per l’Invio</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/mail/#SMTP-dialup>26.9. Uso della Posta con una Connessione Dialup</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/mail/#SMTP-Auth>26.10. Autenticazione SMTP</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/mail/#mail-agents>26.11. Mail User Agent</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/mail/#mail-fetchmail>26.12. Usare fetchmail</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/mail/#mail-procmail>26.13. Usare procmail</a></li></ul></li><li><input type=checkbox id=chapter-6de4de3fe925639d4175ce4b6f8c1829 class=toggle>
<label class="icon cursor" for=chapter-6de4de3fe925639d4175ce4b6f8c1829><a role=button></a></label><a href=https://docs.freebsd.org/it/books/handbook/network-servers/>Capitolo 27. Server di rete</a><ul><li><a href=https://docs.freebsd.org/it/books/handbook/network-servers/#network-servers-synopsis>27.1. Sinossi</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/network-servers/#network-inetd>27.2. Il "Super-Server"inetd</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/network-servers/#network-nfs>27.3. Network File System (NFS)</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/network-servers/#network-nis>27.4. Network Information System (NIS/YP)</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/network-servers/#network-dhcp>27.5. Configurazione Automatica della Rete (DHCP)</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/network-servers/#network-dns>27.6. Domain Name System (DNS)</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/network-servers/#network-apache>27.7. Apache HTTP Server</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/network-servers/#network-ftp>27.8. File Transfer Protocol (FTP)</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/network-servers/#network-samba>27.9. Servizi di File e Stampa per client Microsoft® Windows® (Samba)</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/network-servers/#network-ntp>27.10. Sincronizzazione del Clock con NTP</a></li></ul></li><li><input type=checkbox id=chapter-776d855c7b75e048f90b5c2c9b35ffe0 class=toggle>
<label class="icon cursor" for=chapter-776d855c7b75e048f90b5c2c9b35ffe0><a role=button></a></label><a href=https://docs.freebsd.org/it/books/handbook/firewalls/>Capitolo 28. Firewall</a><ul><li><a href=https://docs.freebsd.org/it/books/handbook/firewalls/#firewalls-intro>28.1. Introduzione</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/firewalls/#firewalls-concepts>28.2. Concetti sui Firewall</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/firewalls/#firewalls-apps>28.3. Firewall come Applicaizoni Software</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/firewalls/#firewalls-pf>28.4. Il Firewall PF (Packet Filter)</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/firewalls/#firewalls-ipf>28.5. Il Firewall IPF (IPFILTER)</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/firewalls/#firewalls-ipfw>28.6. IPFW</a></li></ul></li><li><input type=checkbox id=chapter-5b07f776a0e6155c1c89aa0d15610380 class=toggle>
<label class="icon cursor" for=chapter-5b07f776a0e6155c1c89aa0d15610380><a role=button></a></label><a href=https://docs.freebsd.org/it/books/handbook/advanced-networking/>Capitolo 29. Networking Avanzato</a><ul><li><a href=https://docs.freebsd.org/it/books/handbook/advanced-networking/#advanced-networking-synopsis>29.1. Sinossi</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/advanced-networking/#network-routing>29.2. Gateways e Routes</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/advanced-networking/#network-wireless>29.3. Wireless</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/advanced-networking/#network-bluetooth>29.4. Bluetooth</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/advanced-networking/#network-bridging>29.5. Bridging</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/advanced-networking/#network-diskless>29.6. Modalità senza dischi</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/advanced-networking/#network-isdn>29.7. ISDN</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/advanced-networking/#network-natd>29.8. NAT</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/advanced-networking/#network-plip>29.9. PLIP</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/advanced-networking/#network-ipv6>29.10. IPv6</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/advanced-networking/#network-atm>29.11. ATM</a></li></ul></li><li><input type=checkbox id=chapter-171a77aa9d067a1024f849470e1f33e8 class=toggle>
<label for=chapter-171a77aa9d067a1024f849470e1f33e8><a role=button></a></label><a href=https://docs.freebsd.org/it/books/handbook/partv/>Parte V. Appendici</a></li><li><input type=checkbox id=chapter-8050f436a0a7986a4aaded93d8e49469 class=toggle>
<label class="icon cursor" for=chapter-8050f436a0a7986a4aaded93d8e49469><a role=button></a></label><a href=https://docs.freebsd.org/it/books/handbook/mirrors/>Appendice A. Ottenere FreeBSD</a><ul><li><a href=https://docs.freebsd.org/it/books/handbook/mirrors/#mirrors-cdrom>A.1. Editori di CDROM e DVD</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/mirrors/#mirrors-ftp>A.2. Siti FTP</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/mirrors/#anoncvs>A.3. CVS Anonimo</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/mirrors/#ctm>A.4. Uso di CTM</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/mirrors/#cvsup>A.5. Uso di CVSup</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/mirrors/#portsnap>A.6. Usare Portsnap</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/mirrors/#cvs-tags>A.7. Tag CVS</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/mirrors/#mirrors-afs>A.8. Siti AFS</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/mirrors/#mirrors-rsync>A.9. Siti rsync</a></li></ul></li><li><input type=checkbox id=chapter-128b630a8f88f158e7027fe6c2184d21 class=toggle>
<label class="icon cursor" for=chapter-128b630a8f88f158e7027fe6c2184d21><a role=button></a></label><a href=https://docs.freebsd.org/it/books/handbook/bibliography/>Appendice B. Bibliografia</a><ul><li><a href=https://docs.freebsd.org/it/books/handbook/bibliography/#bibliography-freebsd>B.1. Libri & Riviste Specifiche su FreeBSD</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/bibliography/#bibliography-userguides>B.2. Guide per gli Utenti</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/bibliography/#bibliography-adminguides>B.3. Guide per gli Amministratori</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/bibliography/#bibliography-programmers>B.4. Guide per i Programmatori</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/bibliography/#bibliography-osinternals>B.5. Architettura del Sistema Operativo</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/bibliography/#bibliography-security>B.6. Riferimenti sulla Sicurezza</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/bibliography/#bibliography-hardware>B.7. Riferimenti sull’Hardware</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/bibliography/#bibliography-history>B.8. Storia di UNIX®</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/bibliography/#bibliography-journals>B.9. Riviste e Giornali</a></li></ul></li><li><input type=checkbox id=chapter-8bbb8867c46dac315e2253945d8c18a8 class=toggle>
<label class="icon cursor" for=chapter-8bbb8867c46dac315e2253945d8c18a8><a role=button></a></label><a href=https://docs.freebsd.org/it/books/handbook/eresources/>Appendice C. Risorse su Internet</a><ul><li><a href=https://docs.freebsd.org/it/books/handbook/eresources/#eresources-mail>C.1. Mailing Lists</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/eresources/#eresources-news>C.2. Newsgroup Usenet</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/eresources/#eresources-web>C.3. Server World Wide Web</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/eresources/#eresources-email>C.4. Indirizzi Email</a></li><li><a href=https://docs.freebsd.org/it/books/handbook/eresources/#eresources-shell>C.5. Shell Accounts</a></li></ul></li><li><input type=checkbox id=chapter-a80ea4f5a4480b8725422710f954ef36 class=toggle>
<label class="icon cursor" for=chapter-a80ea4f5a4480b8725422710f954ef36><a role=button></a></label><a href=https://docs.freebsd.org/it/books/handbook/pgpkeys/>Appendice D. Chiavi PGP</a><ul><li><a href=https://docs.freebsd.org/it/books/handbook/pgpkeys/#pgpkeys-officers>D.1. Cariche Ufficiali</a></li></ul></li><li></li></ul></nav></div></aside><div class=book><div class=book-menu-mobile><label for=menu-control><span class=menu-control-button><i class="fa fa-list" aria-hidden=true title="Indice del libro"></i>
Indice del libro</span></label></div><h1 class=title>Capitolo 11. Configurazione e Messa a Punto</h1><div class="admonitionblock note"><p><i class="fa fa-exclamation-circle" aria-hidden=true></i>
This translation may be out of date. To help with the translations please access the <a href=https://translate-dev.freebsd.org/ target=_blank>FreeBSD translations instance</a>.</p></div><div class=toc-mobile><h3>Indice</h3><nav id=TableOfContents><ul><li><a href=#config-synopsis>11.1. Sinossi</a></li><li><a href=#configtuning-initial>11.2. Configurazione Iniziale</a></li><li><a href=#configtuning-core-configuration>11.3. Configurazione Principale</a></li><li><a href=#configtuning-appconfig>11.4. Configurazione delle Applicazioni</a></li><li><a href=#configtuning-starting-services>11.5. Avvio dei Servizi</a></li><li><a href=#configtuning-cron>11.6. Configurare l’Utility <code>cron</code></a></li><li><a href=#configtuning-rcd>11.7. Usare rc con FreeBSD</a></li><li><a href=#config-network-setup>11.8. Configurazione delle Interfacce di Rete</a></li><li><a href=#configtuning-virtual-hosts>11.9. Host Virtuali</a></li><li><a href=#configtuning-configfiles>11.10. File di Configurazione</a></li><li><a href=#configtuning-sysctl>11.11. Messa a Punto con sysctl</a></li><li><a href=#configtuning-disk>11.12. Messa a Punto dei Dischi</a></li><li><a href=#configtuning-kernel-limits>11.13. Messa a Punto dei Limiti del Kernel</a></li><li><a href=#adding-swap-space>11.14. Aggiunta di Spazio di Swap</a></li><li><a href=#acpi-overview>11.15. Gestione dell’Energia e delle Risorse</a></li><li><a href=#ACPI-debug>11.16. Usare e Debuggare ACPI di FreeBSD</a></li></ul></nav></div><div class=book-content><div id=preamble><div class=sectionbody></div></div><div class=sect1><h2 id=config-synopsis>11.1. Sinossi<a class=anchor href=#config-synopsis></a></h2><div class=sectionbody><div class=paragraph><p>Uno degli aspetti importanti di FreeBSD è la configurazione del sistema. Una corretta configurazione del sistema aiuterà a prevenire mal di testa durante futuri aggiornamenti. Questo capitolo spiegherà molti dei processi di configurazione di FreeBSD, inclusi alcuni parametri che possono essere impostati per ottimizzare un sistema FreeBSD.</p></div><div class=paragraph><p>Dopo aver letto questo capitolo, saprai:</p></div><div class=ulist><ul><li><p>Come lavorare in maniera efficiente con i file system e le partizioni di swap.</p></li><li><p>Le basi dei sistemi di configurazione <span class=filename>rc.conf</span> e di avvio <span class=filename>/usr/local/etc/rc.d</span>.</p></li><li><p>Come configurare e provare una scheda di rete.</p></li><li><p>Come configurare host virtuali sui dispositivi di rete.</p></li><li><p>Come usare i vari file di configurazione in <span class=filename>/etc</span>.</p></li><li><p>Come mettere a punto FreeBSD usando le variabili <code>sysctl</code>.</p></li><li><p>Come ottimizzare la prestazioni del disco e modificare le limitazioni del kernel.</p></li></ul></div><div class=paragraph><p>Prima di leggere questo capitolo, dovresti:</p></div><div class=ulist><ul><li><p>Comprendere le basi di UNIX® e di FreeBSD (<a href=../basics/#basics>Basi di UNIX</a>).</p></li><li><p>Avere dimestichezza nella configurazione/compilazione del kernel (<a href=../kernelconfig/#kernelconfig>Configurazione del Kernel di FreeBSD</a>).</p></li></ul></div></div></div><div class=sect1><h2 id=configtuning-initial>11.2. Configurazione Iniziale<a class=anchor href=#configtuning-initial></a></h2><div class=sectionbody><div class=sect2><h3 id=_disposizione_delle_partizioni>11.2.1. Disposizione delle Partizioni<a class=anchor href=#_disposizione_delle_partizioni></a></h3><div class=sect3><h4 id=_partizioni_di_base>11.2.1.1. Partizioni di Base<a class=anchor href=#_partizioni_di_base></a></h4><div class=paragraph><p>Nel disegnare il tuo file system con <a href="https://man.freebsd.org/cgi/man.cgi?query=bsdlabel&amp;sektion=8&amp;format=html">bsdlabel(8)</a> o <a href="https://man.freebsd.org/cgi/man.cgi?query=sysinstall&amp;sektion=8&amp;format=html">sysinstall(8)</a>, ricorda che i dischi rigidi possono trasferire dati ad un ritmo maggiore dalle tracce esterne rispetto a quelle interne. Quindi i file system più piccoli e con un gran numero di accessi dovrebbero essere più vicini alla parte esterna del disco, mentre le partizioni più ampie, come <span class=filename>/usr</span>, dovrebbero essere posizionate verso l’interno. È una buona idea creare le partizioni in un ordine simile al seguente: root, swap, <span class=filename>/var</span>, <span class=filename>/usr</span>.</p></div><div class=paragraph><p>Le dimensioni della partizione <span class=filename>/var</span> riflettono l’uso che intendi fare della macchina. <span class=filename>/var</span> viene usata per mantenere le caselle di posta, i file di log, e gli spool della stampante. Le caselle di posta e file di log potrebbero crescere in maniera imprevedibile in relazione al numero di utenti presenti sul tuo sistema e da quanto a lungo manterrai i file di log. La maggior parte degli utenti non avrà mai bisogno di un gigabyte, ma ricorda che <span class=filename>/var/tmp</span> deve essere abbastanza ampia da contenere tutti i pacchetti.</p></div><div class=paragraph><p>La partizione <span class=filename>/usr</span> contiene molti dei file richiesti per far funzionare il sistema, la collezioni dei <a href="https://man.freebsd.org/cgi/man.cgi?query=ports&amp;sektion=7&amp;format=html">ports(7)</a> (raccomandata) e il codice sorgente (opzionale). Entrambi sono opzionali al momento dell’installazione. Almeno 2 gigabyte sono raccomandati per questa partizione.</p></div><div class=paragraph><p>Quando decidi le dimensioni delle partizioni, tieni a mente le richieste di spazio. Esaurire lo spazio in una partizione mentre ne usi poco in un’altra può essere molto fastidioso.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Alcuni utenti hanno scoperto che il dimensionamento <code>auto-predefinito</code> di <a href="https://man.freebsd.org/cgi/man.cgi?query=sysinstall&amp;sektion=8&amp;format=html">sysinstall(8)</a> a volte crea partizioni <span class=filename>/var</span> o <span class=filename>/</span> più piccole del necessario. Partiziona saggiamente e generosamente.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=swap-design>11.2.1.2. Partizione di Swap<a class=anchor href=#swap-design></a></h4><div class=paragraph><p>Come regola generale, la partizione di swap dovrebbe essere tipicamente il doppio della quantità di memoria principale (RAM). Ad esempio, se la macchina avesse 128 megabyte di memoria, il file di swap dovrebbe essere di 256 megabyte. Sistemi con meno memoria potrebbero funzionare meglio con uno swap maggiore. Meno di 256 megabyte di swap non è raccomandato e dovresti pensare ad una espansione della memoria. Gli algoritmi di paginazione sono ottimizzati per funzionare al meglio quando la partizione di swap è almeno due volte la dimensione della memoria principale. Configurare uno swap troppo piccolo potrebbe portare ad una inefficienza nel codice di scansione della VM e potrebbe creare problemi in seguito, nel caso di aggiunta di memoria alla macchina.</p></div><div class=paragraph><p>Su sistemi più grandi con dischi SCSI multipli (o dischi IDE multipli collegati a diversi controller) è consigliabile che ci sia uno swap per ogni disco (fino a quattro dischi). Le partizioni di swap dovrebbero avere approssimativamente le stesse dimensioni. Il kernel può gestire dimensioni arbitrarie ma internamente le strutture dati scalano meglio fino a quattro volte la dimensione della partizione di swap più ampia. Avere partizioni di swap con dimensioni simili permetterà al kernel di distribuire al meglio lo spazio di swap tra i dischi. Partizioni di swap grandi vanno bene, anche se non vengono usate molto. Potrebbe essere più semplice recuperare il sistema da un programma impazzito prima di essere costretti a riavviare.</p></div></div><div class=sect3><h4 id=_perchè_partizionare>11.2.1.3. Perchè Partizionare?<a class=anchor href=#_perchè_partizionare></a></h4><div class=paragraph><p>Molti utenti pensano che un’unica grande partizione vada bene, ma ci sono molte ragioni per cui questa è una cattiva idea. Primo, ogni partizione ha differenti caratteristiche operative e separarle permette ai file system di ottimizzare se stessi di conseguenza. Ad esempio, le partizioni root e <span class=filename>/usr</span> sono per lo più usate in lettura, senza molte operazioni di scrittura. Un sacco di letture e scritture potrebbero esserci in <span class=filename>/var</span> e <span class=filename>/var/tmp</span>.</p></div><div class=paragraph><p>Partizionando in maniera appropriata il sistema, la frammentazione introdotta nelle partizioni più piccole, con più carico in scrittura, non inciderà sulle partizioni per lo più di lettura. Mantenere le partizioni con maggiore carico in scrittura vicine al bordo del disco aumenterà le prestazioni di I/O nelle partizioni dove ne hai più bisogno. Ora, sebbene potresti avere bisogno di prestazioni di I/O anche nelle partizioni più ampie, spostarle verso il bordo del disco non porterebbe nessun miglioramento significativo delle prestazioni, al contrario dello spostamento di <span class=filename>/var</span> all’esterno. Infine, ci sono problemi riguardanti la sicurezza. Una piccola, simpatica partizione di root che è essenzialmente di sola lettura ha ottime possibilità di sopravvivere intatta a un brutto crash.</p></div></div></div></div></div><div class=sect1><h2 id=configtuning-core-configuration>11.3. Configurazione Principale<a class=anchor href=#configtuning-core-configuration></a></h2><div class=sectionbody><div class=paragraph><p>Il posto principale per le informazioni di configurazione del sistema è in <span class=filename>/etc/rc.conf</span>. Questo file contiene un’ampia gamma di informazioni di configurazione, usate principalmente all’avvio della macchina per la configurazione del sistema. Il suo nome è autoesplicativo; si tratta di informazioni di configurazione per i file <span class=filename>rc*</span>.</p></div><div class=paragraph><p>Un amministratore dovrebbe aggiungere dei campi nel file <span class=filename>rc.conf</span> per cambiare le impostazioni predefinite di <span class=filename>/etc/defaults/rc.conf</span>. Il file predefinito non dovrebbe essere semplicemente copiato in <span class=filename>/etc</span> - esso contiene valori di default, non esempi. Tutti i cambiamenti specifici del sistema dovrebbero essere effettuati nel file <span class=filename>rc.conf</span> stesso.</p></div><div class=paragraph><p>Nelle applicazioni cluster possono essere adottate differenti strategie per separare le configurazioni generali da quelle specifiche del sistema in maniera da mantenere basso l’impegno di amministrazione. L’approccio raccomandato è di porre le configurazioni generali in un altro file, ad esempio <span class=filename>/etc/rc.conf.site</span>, e poi includerlo in <span class=filename>/etc/rc.conf</span>, che conterrà solo le informazioni specifiche del sistema.</p></div><div class=paragraph><p>Visto che <span class=filename>rc.conf</span> viene letto da <a href="https://man.freebsd.org/cgi/man.cgi?query=sh&amp;sektion=1&amp;format=html">sh(1)</a> è semplice farlo. Ad esempio:</p></div><div class=ulist><ul><li><p>rc.conf:</p><div class="literalblock programlisting"><div class=content><pre>        . /etc/rc.conf.site
        hostname=&#34;node15.example.com&#34;
        network_interfaces=&#34;fxp0 lo0&#34;
        ifconfig_fxp0=&#34;inet 10.1.1.1&#34;</pre></div></div></li><li><p>rc.conf.site:</p><div class="literalblock programlisting"><div class=content><pre>        defaultrouter=&#34;10.1.1.254&#34;
        saver=&#34;daemon&#34;
        blanktime=&#34;100&#34;</pre></div></div></li></ul></div><div class=paragraph><p>Il file <span class=filename>rc.conf.site</span> potrà poi essere distribuito su ogni sistema usando <code>rsync</code> o un programma simile, mentre il file <span class=filename>rc.conf</span> rimarrà unico.</p></div><div class=paragraph><p>L’aggiornamento del sistema tramite <a href="https://man.freebsd.org/cgi/man.cgi?query=sysinstall&amp;sektion=8&amp;format=html">sysinstall(8)</a> o <code>make world</code> non sovrascriverà il file <span class=filename>rc.conf</span>, quindi le configurazioni del sistema non andranno perse.</p></div></div></div><div class=sect1><h2 id=configtuning-appconfig>11.4. Configurazione delle Applicazioni<a class=anchor href=#configtuning-appconfig></a></h2><div class=sectionbody><div class=paragraph><p>Tipicamente, le applicazioni installate hanno i propri file di configurazione, con la loro sintassi, ecc. È importante che questi file siano tenuti separati dal sistema di base, in maniera da essere facilmente individuati e gestiti dagli strumenti di gestione dei pacchetti.</p></div><div class=paragraph><p>In genere, questi file vengono installati in <span class=filename>/usr/local/etc</span>. Nel caso in cui un’applicazione abbia un grande numero di file di configurazione, verrà creata una sottodirectory per contenerli.</p></div><div class=paragraph><p>Normalmente, quando viene installato un pacchetto, vengono installati anche file di configurazione d’esempio. In genere questi vengono identificati da un suffisso <span class=filename>.default</span>. Se non ci sono file di configurazione esistenti per l’applicazione, verranno creati copiando i file <span class=filename>.default</span>.</p></div><div class=paragraph><p>Ad esempio, considera il contenuto della directory <span class=filename>/usr/local/etc/apache</span>:</p></div><div class=literalblock><div class=content><pre>-rw-r--r--  1 root  wheel   2184 May 20  1998 access.conf
-rw-r--r--  1 root  wheel   2184 May 20  1998 access.conf.default
-rw-r--r--  1 root  wheel   9555 May 20  1998 httpd.conf
-rw-r--r--  1 root  wheel   9555 May 20  1998 httpd.conf.default
-rw-r--r--  1 root  wheel  12205 May 20  1998 magic
-rw-r--r--  1 root  wheel  12205 May 20  1998 magic.default
-rw-r--r--  1 root  wheel   2700 May 20  1998 mime.types
-rw-r--r--  1 root  wheel   2700 May 20  1998 mime.types.default
-rw-r--r--  1 root  wheel   7980 May 20  1998 srm.conf
-rw-r--r--  1 root  wheel   7933 May 20  1998 srm.conf.default</pre></div></div><div class=paragraph><p>Le differenze nelle dimensioni dei file mostrano che solo <span class=filename>srm.conf</span> è stato modificato. Una successiva installazione di Apache dai port non sovrascriverà questo file modificato.</p></div></div></div><div class=sect1><h2 id=configtuning-starting-services>11.5. Avvio dei Servizi<a class=anchor href=#configtuning-starting-services></a></h2><div class=sectionbody><div class=paragraph><p>Molti utenti scelgono di installare software di terze parti in FreeBSD attraverso la collezione dei port. Nell magior parte dei casi potrebbe essere necessario configurare il software in un modo tale che sia avviato all’inizializzazione di sistema. Servizi, come <a class=package href=https://cgit.freebsd.org/ports/tree/mail/postfix/>mail/postfix</a> o <a class=package href=https://cgit.freebsd.org/ports/tree/www/apache13/>www/apache13</a> sono solo due fra i molti pacchetti software che possono essere avviati durante l’inizializzazione di sistema. Questa sezione spiega le procedure disponibili per avviare software di terze parti.</p></div><div class=paragraph><p>In FreeBSD, molti servizi inclusi, come <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a>, sono avviati attraverso gli script di startup. Questi script possono differire a seconda della verione di FreeBSD o del produttore; comunque il più importante aspetto da considerare è che la configurazione di startup può essere gestita tramite semplici script di inizializzazione.</p></div><div class=paragraph><p>Prima dell’avvento di <span class=filename>rc.d</span>, gli applicativi lasciavano un semplice script di avvio nella directory <span class=filename>/usr/local/etc/rc.d</span> che sarebbe stato poi letto dagli script di inizializzazione di sistema. Questi script sarebbero poi eseguiti durante la fase di avvio del sistema.</p></div><div class=paragraph><p>Mentre molti individui hanno speso ore cercando di integrare il vecchio stile di configurazione nel nuovo sistema, resta il fatto che qualche utility di terze parti necessita ancora di uno script semplicemente lasciato nella succitata directory. Le sottili differenze negli script dipendono dal fatto se <span class=filename>rc.d</span> sia usato o meno. Prima di FreeBSD 5.1 viene usato il vecchio metodo di configurazione ed in quasi tutti i casi uno script di nuovo tipo funzionerebbe perfettamente.</p></div><div class=paragraph><p>Mentre ogni script deve rispettare alcuni requisiti minimi, il più delle volte questi requisiti sono indipendenti dalla versioni di FreeBSD. Ogni script deve avere una estensione <span class=filename>.sh</span> appesa alla fine ed ogni script deve essere eseguibile dal sistema. L’ultima richiesta può essere soddisfatta usando il comando <code>chmod</code> e impostando i permessi a <code>755</code>. Ci dovrebbe essere, come minimo, un’opzione per fare lo <code>start</code> dell’applicativo ed un’opzione per farne lo <code>stop</code>.</p></div><div class=paragraph><p>Il più semplice script di avvio probabilmente sembrerebbe simile al seguente:</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
echo -n &#39; utility&#39;

case &#34;$1&#34; in
start)
        /usr/local/bin/utility
        ;;
stop)
        kill -9 `cat /var/run/utility.pid`
        ;;
*)
        echo &#34;Usage: `basename $0` {start|stop}&#34; &gt;&amp;2
        exit 64
        ;;
esac

exit 0</pre></div></div><div class=paragraph><p>Questo script fornisce un’opzione <code>stop</code> e <code>start</code> per l’applicazione a cui ci riferiamo semplicemente come <code>utility</code>.</p></div><div class=paragraph><p>Potrebbe essere avviata manualmente con:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /usr/local/etc/rc.d/utility.sh start</span></code></pre></div></div><div class=paragraph><p>Mentre non tutto il software di terze parti richiede la linea in <span class=filename>rc.conf</span>, quasi ogni giorno un nuovo port viene modificato per accettare questa configurazione. Controlla l’output finale dell’installazione per maggiori informazioni su un applicativo specifico. Ci sarà del software di terze parti che fornisce script di avvio che permettono all’applicativo di essere usato con <span class=filename>rc.d</span>; tuttavia, questo sarà discusso nella successiva sezione.</p></div><div class=sect2><h3 id=_configurazione_estesa_degli_applicativi>11.5.1. Configurazione Estesa degli Applicativi<a class=anchor href=#_configurazione_estesa_degli_applicativi></a></h3><div class=paragraph><p>Ora che FreeBSD include <span class=filename>rc.d</span>, la configurazione dell’avvio degli applicativi è diventata più semplice, e più flessibile. Usando le parole chiave discusse nella sezione <a href=#configtuning-rcd>rc.d</a>, gli applicativi ora possono essere configurati dopo certi altri servizi come ad esempio il DNS; possono permettere che siano passati flag extra nel codice attraverso <span class=filename>rc.conf</span> al posto di flag statici negli script di avvio, e molto altro. Uno script basilare potrebbe assomigliare al seguente:</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
#
# PROVIDE: utility
# REQUIRE: DAEMON
# KEYWORD: shutdown

. /etc/rc.subr

name=utility
rcvar=utility_enable

command=&#34;/usr/local/sbin/utility&#34;

load_rc_config $name

#
# DO NOT CHANGE THESE DEFAULT VALUES HERE
# SET THEM IN THE /etc/rc.conf FILE
#
utility_enable=${utility_enable-&#34;NO&#34;}
pidfile=${utility_pidfile-&#34;/var/run/utility.pid&#34;}

run_rc_command &#34;$1&#34;</pre></div></div><div class=paragraph><p>Questo script assicurerà che utility partirà dopo il servizio <code>daemon</code>. Fornisce inoltre un metodo per settare e tracciare il PID, o il file dell’ID di processo.</p></div><div class=paragraph><p>Questa applicazione potrebbe avere le seguenti linee piazzate in <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>utility_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Questo metodo permette inoltre una semplice manipolazione degli argomenti di linea di comando, incluse le funzioni di default definite in <span class=filename>/etc/rc.subr</span>, compatibilità con l’utility <a href="https://man.freebsd.org/cgi/man.cgi?query=rcorder&amp;sektion=8&amp;format=html">rcorder(8)</a> e fornisce una più semplice configurazione attraverso il file <span class=filename>rc.conf</span>.</p></div></div><div class=sect2><h3 id=_usare_i_servizi_per_avviare_i_servizi>11.5.2. Usare i Servizi per Avviare i Servizi<a class=anchor href=#_usare_i_servizi_per_avviare_i_servizi></a></h3><div class=paragraph><p>Altri servizi, come i demoni POP3, IMAP, etc. potrebbero essere avviati usando <a href="https://man.freebsd.org/cgi/man.cgi?query=inetd&amp;sektion=8&amp;format=html">inetd(8)</a>. Questo implica l’installazione del servizio dalla collezione dei port e l’aggiunta di una linea di configurazione al file <span class=filename>/etc/inetd.conf</span> o togliendo dei commenti in una delle linee di configurazione del file stesso. L’uso di inetd e la sua configurazione è descritto in dettaglio nella sezione <a href=../network-servers/#network-inetd>inetd</a>.</p></div><div class=paragraph><p>In alcuni casi, potrebbe essere più plausibile usare il demone <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a> per avviare i servizi di sistema. Questo approccio ha alcuni vantaggi poichè <code>cron</code> esegue questi processi come l’utente proprietario del file <span class=filename>crontab</span>. Questo permette ad utenti regolari di avviare e mantenere alcuni applicativi.</p></div><div class=paragraph><p>Il comando <code>cron</code> fornisce una caratteristica unica, <code>@reboot</code>, che potrebbe essere usato al posto della specifica del tempo. Questo farà sì che il job sia eseguito quando <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a> è avviato, normalmente durante l’inizializzazione di sistema.</p></div></div></div></div><div class=sect1><h2 id=configtuning-cron>11.6. Configurare l’Utility <code>cron</code><a class=anchor href=#configtuning-cron></a></h2><div class=sectionbody><div class=paragraph><p>Uno dei comandi più utili presenti in FreeBSD è <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a>. L’utility <code>cron</code> viene eseguita in background e controlla costantemente il file <span class=filename>/etc/crontab</span>. <code>cron</code> controlla anche la directory <span class=filename>/var/cron/tabs</span>, alla ricerca di nuovi file <span class=filename>crontab</span>. Questi file <span class=filename>crontab</span> contengono informazioni sulle specifiche funzioni che ci si aspetta vengano compiute da <code>cron</code> a determinati intervalli temporali.</p></div><div class=paragraph><p>L’utility <code>cron</code> usa due differenti tipi di file di configurazione, il crontab di sistema ed il crontab utente. La sola differenza fra questi due file è nel sesto campo. Nel crontab di sistema, il sesto campo è il nome dell’utente sotto il quale viene eseguito il comando. Questo dà al crontab di sistema la capacità di eseguire comandi come ogni utente. Nel crontab utente, il sesto campo è il comando da eseguire, e tutti i comandi vengono eseguiti come l’utente che ha creato il crontab; questa è un’importante caratteristica di sicurezza.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>I crontab utenti permettono ad utenti individuali di schedulare task senza i privilegi di <code>root</code>. I comandi in un crontab utente vengono eseguiti con i permessi dell’utente che posseggono il file crontab.</p></div><div class=paragraph><p>L’utente <code>root</code> può possedere il crontab proprio come ogni altro utente. Qui c’è una differenza rispetto a <span class=filename>/etc/crontab</span> (il crontab di sistema). Per via del crontab di sistema, di solito non c’è bisogno di creare un crontab per <code>root</code>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Diamo un’occhiata al file <span class=filename>/etc/crontab</span> (il crontab di sistema):</p></div><div class="literalblock programlisting"><div class=content><pre># /etc/crontab - il crontab di root per FreeBSD
#
# $FreeBSD: src/etc/crontab,v 1.32 2002/11/22 16:13:39 tom Exp $
#<i class=conum data-value=1></i><b>(1)</b>
#
SHELL=/bin/sh
PATH=/etc:/bin:/sbin:/usr/bin:/usr/sbin <i class=conum data-value=2></i><b>(2)</b>
HOME=/var/log
#
#
#minute    hour    mday    month   wday    who command <i class=conum data-value=3></i><b>(3)</b>
#
#
*/5    *   *   *   *   root    /usr/libexec/atrun <i class=conum data-value=4></i><b>(4)</b></pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>Come in molti file di configurazione di FreeBSD, il carattere <code>#</code> rappresenta un commento. Un commento può essere posto nel file come una nota su cosa si desidera fare con un certo comando. I commenti non possono essere nella stessa linea di un comando o saranno interpretati come parte di un comando; devono trovarsi su una linea a sè. Le linee vuote vengono ignorate.</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td>Anzitutto, deve essere definito l’ambiente. I segni di uguale (<code>=</code>) vengono usati per definire ogni impostazione dell’ambiente, come viene fatto in questo esempio per <code>SHELL</code>, <code>PATH</code>, e <code>HOME</code>. Se la linea relativa alla shell viene omessa, <code>cron</code> userà quella di default, che è <code>sh</code>. Se si omette la variabile <code>PATH</code>, non verrà usato nessun default e le locazioni dei file dovranno essere assolute. Se viene omessa <code>HOME</code>, <code>cron</code> userà la home directory dello user che lo ha richiamato.</td></tr><tr><td><i class=conum data-value=3></i><b>3</b></td><td>Questa linea definisce un totale di sette campi. Qui sono elencati i valori <code>minute</code>, <code>hour</code>, <code>mday</code>, <code>month</code>, <code>wday</code>, <code>who</code>, e <code>command</code>. Questi nomi sono più o meno autoesplicativi. <code>minute</code> è il tempo in minuti al quale dovrà essere eseguito il comando. <code>hour</code> è uguale, ma per le ore. <code>mday</code> rappresenta il giorno del mese. <code>month</code> è simile ad <code>hour</code> e <code>minute</code>, ma rappresenta il mese. L’opzione <code>wday</code> rappresenta il giorno della settimana. Tutti questi campi devono avere un valore numerico, e seguire l’orario di ventiquattro ore. Il campo <code>who</code> è speciale, ed esiste solo nel file <span class=filename>/etc/crontab</span>. Questo campo specifica l’utente con il quale deve essere eseguito il comando. Quando un utente installa il suo file <span class=filename>crontab</span>, non avrà a disposizione questa opzione. Infine, viene elencata l’opzione <code>command</code>. Questo è l’ultimo campo, e naturalmente indica il comando che deve essere eseguito.</td></tr><tr><td><i class=conum data-value=4></i><b>4</b></td><td>Quest’ultima linea definirà i valori discussi prima. Notate che abbiamo un <code><strong>/5</strong></code><strong>, seguito da parecchi caratteri <code></code></strong>. Questi caratteri <code>*</code> significano "dalla prima all’ultima volta", e possono essere interpretati come <em>ogni</em> volta. Dunque, basandosi su questa linea, sembra che il comando <code>atrun</code> debba essere invocato da <code>root</code> ogni cinque minuti, prescindendo da quale giorno o mese sia. Per maggiori informazioni sul comando <code>atrun</code>, vedere la pagina di manuale <a href="https://man.freebsd.org/cgi/man.cgi?query=atrun&amp;sektion=8&amp;format=html">atrun(8)</a>.I comandi possono essere richiamati con qualsiasi numero di flag; i comandi che si estendono per più righe potrebbero però avere bisogno di essere spezzati con il carattere di continuazione "\".</td></tr></tbody></table></div><div class=paragraph><p>Questa è l’impostazione di base per ogni file <span class=filename>crontab</span>, anche se c’è qualcosa di particolare in questo. Il sesto campo, dove abbiamo specificato il nome utente, esiste solo nel file di sistema <span class=filename>/etc/crontab</span>. Questo campo dovrebbe venire omesso nei <span class=filename>crontab</span> dei vari utenti.</p></div><div class=sect2><h3 id=configtuning-installcrontab>11.6.1. Installare un Crontab<a class=anchor href=#configtuning-installcrontab></a></h3><div class="admonitionblock important"><table><tbody><tr><td class=icon><i class="fa icon-important" title=Important></i></td><td class=content><div class=paragraph><p>Non devi usare la procedura descritta qui per editare/installare il crontab di sistema. Semplicemente usa il tuo editor favorito: l’utility <code>cron</code> noterà che il file è cambiato e immediatamente inizierà ad usare la versione aggiornata. Vedi <a href=https://docs.freebsd.org/en/books/faq/#ROOT-NOT-FOUND-CRON-ERRORS>queste FAQ</a> per maggiori informazioni.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Per installare un <span class=filename>crontab</span> appena scritto, prima usa il tuo editor preferito per creare un file nel formato corretto, e poi usa l’utility <code>crontab</code>. L’uso più corretto è:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% crontab crontab-file</code></pre></div></div><div class=paragraph><p>In questo esempio, <span class=filename>crontab-file</span> è il nome di un file <span class=filename>crontab</span> che era stato creato in precedenza.</p></div><div class=paragraph><p>C’è anche un’opzione per elencare i file <span class=filename>crontab</span> già installati: passate semplicemente <code>-l</code> a <code>crontab</code> e date un’occhiata all’output.</p></div><div class=paragraph><p>Per gli utenti che desiderino scrivere il proprio file crontab da zero, senza usare un template, è disponibile <code>crontab -e</code>. Questa opzione permetterà loro di invocare l’editor prescelto su un file vuoto. Quando il file verrà salvato, esso verrà automaticamente installato dal comando <code>crontab</code>.</p></div><div class=paragraph><p>Se successivamente vuoi rimuovere il tuo <span class=filename>crontab</span> completamente, usa <code>crontab</code> con l’opzione <code>-r</code>.</p></div></div></div></div><div class=sect1><h2 id=configtuning-rcd>11.7. Usare rc con FreeBSD<a class=anchor href=#configtuning-rcd></a></h2><div class=sectionbody><div class=paragraph><p>Nel 2002 FreeBSD ha integrato il sistema di inizializzazione <span class=filename>rc.d</span> di NetBSD. Gli utenti dovrebbero aver notato i file elencati nella cartella <span class=filename>/etc/rc.d</span>. Molti di questi file sono servizi di base che possono essere controllati con opzioni <code>start</code>, <code>stop</code>, e <code>restart</code>. Ad esempio, <a href="https://man.freebsd.org/cgi/man.cgi?query=sshd&amp;sektion=8&amp;format=html">sshd(8)</a> può essere riavviato con il comando seguente:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /etc/rc.d/sshd restart</span></code></pre></div></div><div class=paragraph><p>Questa procedura è simile a quella per altri servizi. Naturalmente, i servizi in genere vengono avviati automaticamente in fase di avvio secondo quanto specificato in <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a>. Ad esempio, per abilitare il demone per il NAT (Network Address Translation) all’avvio basta aggiungere la linea seguente a <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>natd_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Se esiste già una linea <code>natd_enable="NO"</code>, allora basta cambiare il valore da <code>NO</code> a <code>YES</code>. Gli script rc caricheranno automaticamente ogni altro servizio durante il riavvio seguente, come descritto più avanti.</p></div><div class=paragraph><p>Poichè il sistema di <span class=filename>rc.d</span> è inteso prevalentemente per avviare/bloccare i servizi al momento dell’accensione/spegnimento, le opzioni standard <code>start</code>, <code>stop</code> e <code>restart</code> avranno il comportamento appropriato solo seè stata impostata la variabile appropriata in <span class=filename>/etc/rc.conf</span>. Ad esempio il comando precedente <code>sshd restart</code> funzionerà solo se in <span class=filename>/etc/rc.conf</span> è stata impostata l’opzione <code>sshd_enable</code> a <code>YES</code>. Per avviare (<code>start</code>), fermare (<code>stop</code>) o riavviare (<code>restart</code>) un servizio, ignorandole impostazioni in <span class=filename>/etc/rc.conf</span>, i comandi devono avere il prefisso "one". Ad esempio per riavviare <code>sshd</code> trascurando le impostazioni esistenti in <span class=filename>/etc/rc.conf</span>, impartite il comando seguente:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /etc/rc.d/sshd onerestart</span></code></pre></div></div><div class=paragraph><p>È semplice controllare se un servizio è stato abilitato in <span class=filename>/etc/rc.conf</span> eseguendo lo script appropriato in <span class=filename>rc.d</span> con l’opzione <code>rcvar</code>. Dunque, un amministratore può controllare che <code>sshd</code> sia effettivamente abilitato in <span class=filename>/etc/rc.conf</span> eseguendo:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /etc/rc.d/sshd rcvar</span>
<span class=c># sshd</span>
<span class=nv>$sshd_enable</span><span class=o>=</span>YES</code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>La seconda linea (<code># sshd</code>) è l’output del comando <code>sshd</code>; non una console di <code>root</code>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Per determinare se un servizio è attivo, è disponibile l’opzione <code>status</code>. Ad esempio per verificare che <code>sshd</code> sia effettivamente avviato:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /etc/rc.d/sshd status</span>
sshd is running as pid 433.</code></pre></div></div><div class=paragraph><p>In alcuni case è anche possibile effettuare il <code>reload</code> di un servizio. Questo tenterà di inviare un segnale al servizio, per fargli ricaricare il suo file di configurazione. Nella maggior parte dei casi si tratterà del segnale <code>SIGHUP</code>. Il supporto per questa caratteristica non è garantito per tutti i servizi.</p></div><div class=paragraph><p>La struttura di <span class=filename>rc.d</span> non viene usata solo per i servizi di rete, ma contribuisce anche per buona parte all’inizializzazione del sistema. Ad esempio, considerate il file <span class=filename>bgfsck</span>. Quando lo script viene eseguito, esso stamperà il seguente messaggio:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Starting background file system checks <span class=k>in </span>60 seconds.</code></pre></div></div><div class=paragraph><p>Dunque questo file viene usato per il controllo del file system in background, che avviene solo durante l’inizializzazione del sistema.</p></div><div class=paragraph><p>Molti servizi di sistema dipendono da altri servizi per poter funzionare in maniera appropriata. Ad esempio, il NIS ed altri servizi basati sulle RPC potrebbero non funzionare in assenza di <code>rpcbind</code> (portmapper). Per risolvere il problema, nei commenti all’inizio di ogni script di avvio ci sono informazioni sulle dipendenze ed altri metadati. Il programma <a href="https://man.freebsd.org/cgi/man.cgi?query=rcorder&amp;sektion=8&amp;format=html">rcorder(8)</a> viene poi utilizzato per effettuare il parsing di questi commenti durante l’inizializzazione di sistema e per determinare l’ordine con il quale questi servizi devono essere avviati per avere le proprie dipendenze soddisfatte. In cima ad ogni file di avvio possono essere incluse le seguenti parole:</p></div><div class=ulist><ul><li><p>PROVIDE: Specifica i servizi forniti dal file.</p></li><li><p>REQUIRE: Elenca i servizi richiesti per far funzionare correttamente questo servizio. Questo file verrà eseguito <em>dopo</em> i tali servizi.</p></li><li><p>BEFORE: Elenca i servizi che dipendono da questo. Questo file verrà lanciato <em>prima</em> dei servizi specificati.</p></li></ul></div><div class=paragraph><p>Usando questo metodo, un amministratore può controllare facilmente i servizi di sistema senza il fastidio dei "runlevel" come alcuni altri sistemi operativi UNIX®.</p></div><div class=paragraph><p>Informazioni addizionali sul sistema <span class=filename>rc.d</span> possono essere trovate nelle pagine man di <a href="https://man.freebsd.org/cgi/man.cgi?query=rc&amp;sektion=8&amp;format=html">rc(8)</a> e <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.subr&amp;sektion=8&amp;format=html">rc.subr(8)</a>. Se sei interessato a scrivere un tuo script <span class=filename>rc.d</span> o a migliorarne uno esisente, ti può essere utile <a href=https://docs.freebsd.org/en/articles/rc-scripting/>questo articolo</a>.</p></div></div></div><div class=sect1><h2 id=config-network-setup>11.8. Configurazione delle Interfacce di Rete<a class=anchor href=#config-network-setup></a></h2><div class=sectionbody><div class=paragraph><p>Al giorno d’oggi non riusciamo a pensare ad un computer senza pensare ad una connessione di rete. Aggiungere e configurare una scheda di rete è un compito comune per ogni amministratore di FreeBSD.</p></div><div class=sect2><h3 id=_individuazione_del_driver_corretto>11.8.1. Individuazione del Driver Corretto<a class=anchor href=#_individuazione_del_driver_corretto></a></h3><div class=paragraph><p>Prima di cominciare, dovresti conoscere il modello della scheda di rete che possiedi, il chip che usa, e se si tratta di una scheda PCI o ISA. FreeBSD supporta un’ampia varietà sia di schede PCI che ISA. Verifica l’Hardware Compatibility List della tua release per vedere se la scheda è supportata.</p></div><div class=paragraph><p>Una volta sicuro che la tua scheda sia supportata, hai bisogno di determinare il driver appropriato per la scheda. I file <span class=filename>/usr/src/conf/NOTES</span> e <span class=filename>/usr/src/sys/arch/conf/NOTES</span> ti forniranno un elenco di driver per le interfacce di rete con alcune informazioni su chipset/schede supportate. Se hai dubbi su quale sia il driver corretto, leggi la pagina man del driver. La pagina man fornirà ulteriori informazioni sull’hardware supportato ed anche sui possibili problemi che potrebbero capitare.</p></div><div class=paragraph><p>Se sei in possesso di una scheda comune, la maggior parte delle volte non dovrai cercare molto per trovare un driver. I driver per le schede di reti comuni sono presenti nel kernel <span class=filename>GENERIC</span>, quindi la tua scheda dovrebbe presentarsi durante l’avvio, in questo modo:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>dc0: &lt;82c169 PNIC 10/100BaseTX&gt; port 0xa000-0xa0ff mem 0xd3800000-0xd38
000ff irq 15 at device 11.0 on pci0
dc0: Ethernet address: 00:a0:cc:da:da:da
miibus0: &lt;MII bus&gt; on dc0
ukphy0: &lt;Generic IEEE 802.3u media interface&gt; on miibus0
ukphy0:  10baseT, 10baseT-FDX, 100baseTX, 100baseTX-FDX, auto
dc1: &lt;82c169 PNIC 10/100BaseTX&gt; port 0x9800-0x98ff mem 0xd3000000-0xd30
000ff irq 11 at device 12.0 on pci0
dc1: Ethernet address: 00:a0:cc:da:da:db
miibus1: &lt;MII bus&gt; on dc1
ukphy1: &lt;Generic IEEE 802.3u media interface&gt; on miibus1
ukphy1:  10baseT, 10baseT-FDX, 100baseTX, 100baseTX-FDX, auto</code></pre></div></div><div class=paragraph><p>In questo esempio, vediamo che nel sistema sono presenti due schede che usano il driver <a href="https://man.freebsd.org/cgi/man.cgi?query=dc&amp;sektion=4&amp;format=html">dc(4)</a>.</p></div><div class=paragraph><p>Se il driver per la tua NIC non è presente in <span class=filename>GENERIC</span>, dovrai caricare i driver appropriati per usare la tua NIC. Questo dovrà essere fatto in uno di questi due modi:</p></div><div class=ulist><ul><li><p>Il modo più semplice è caricare un modulo del kernel con <a href="https://man.freebsd.org/cgi/man.cgi?query=kldload&amp;sektion=8&amp;format=html">kldload(8)</a> o caricarlo automaticamente al momento del boot aggiungendo le linee appropriate a <span class=filename>/boot/loader.conf</span>. Non tutti i driver NIC sono disponibili come moduli; esempi notevoli di driver per i quali non esistono moduli sono schede ISA.</p></li><li><p>Alternativamente, puoi compilare staticamente il supporto per la tua scheda nel kernel. Controlla <span class=filename>/usr/src/sys/conf/NOTES</span>, <span class=filename>/usr/src/sys/arch/conf/NOTES</span> e la pagina di manuale del driver per sapere cosa aggiungere nel tuo file di configurazione del kernel. Per maggiori informazioni sul modo di ricompilare il kernel, per favore consulta il <a href=../kernelconfig/#kernelconfig>Configurazione del Kernel di FreeBSD</a>. Se la tua scheda era riconosciuta al boot dal tuo kernel (<span class=filename>GENERIC</span>) non devi ricompilare un nuovo kernel.</p></li></ul></div><div class=sect3><h4 id=config-network-ndis>11.8.1.1. Usare driver NDIS Windows®<a class=anchor href=#config-network-ndis></a></h4><div class=paragraph><p>Sfortunatamente, ci sono ancora molti venditori di hardware che non forniscono specifiche dei loro driver alla comunità open source perchè ritengono che tale informazione sia un segreto commerciale. Conseguentemente, gli sviluppatori di FreeBSD e di altri sistemi operativi hanno due scelte: sviluppare i driver con un lungo ed arduo processo di reverse engineering o usare i driver binari disponibili per le piattaforme Microsoft® Windows®. La maggior parte degli sviluppatori, inclusi quelli coinvolti in FreeBSD, ha preso la seconda strada.</p></div><div class=paragraph><p>Grazie al contributo di Bill Paul (wpaul), a partire da FreeBSD 5.3-RELEASE c’è supporto "nativo" per Network Driver Interface Specification (NDIS). Il NDISulator di FreeBSD (anche noto come Progetto Evil) prende un driver binario per Windows® e sostanzialmente crea un inganno fingendo di eseguirlo in Windows®. Poichè il driver <a href="https://man.freebsd.org/cgi/man.cgi?query=ndis&amp;sektion=4&amp;format=html">ndis(4)</a> sta usando un binario Windows®, è usabile solo su sistemi i386™ e amd64.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Il driver <a href="https://man.freebsd.org/cgi/man.cgi?query=ndis&amp;sektion=4&amp;format=html">ndis(4)</a> è designato per supportare principalmente device PCI, CardBus e PCMCIA, i device USB non sono ancora supportati.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Per usare il NDISulator, hai bisogno sostanzialmente di tre cose:</p></div><div class="olist arabic"><ol class=arabic><li><p>Sorgenti del kernel</p></li><li><p>binari dei driver di Windows® XP (estensione <span class=filename>.SYS</span>)</p></li><li><p>file di configurazione dei driver per Windows® XP (estensione <span class=filename>.INF</span>)</p></li></ol></div><div class=paragraph><p>Localizza i file per la tua carta specifica. Generalmente, posso essere trovati nel CD incluso o sui siti web dei venditori. Nei seguenti esempi, useremo <span class=filename>W32DRIVER.SYS</span> e <span class=filename>W32DRIVER.INF</span>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Non puoi usare un driver Windows®/i386 con FreeBSD/amd64, devi trovare un driver Windows®/amd64 per farlo funzionare correttamente.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Il prossimo passo è compilare il binario del driver in un modulo caricabile dal kernel. Per fare questo, come <code>root</code>, usa <a href="https://man.freebsd.org/cgi/man.cgi?query=ndisgen&amp;sektion=8&amp;format=html">ndisgen(8)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ndisgen /path/to/W32DRIVER.INF /path/to/W32DRIVER.SYS</span></code></pre></div></div><div class=paragraph><p>L’utility <a href="https://man.freebsd.org/cgi/man.cgi?query=ndisgen&amp;sektion=8&amp;format=html">ndisgen(8)</a> è interattiva e chiederà altre informazioni di cui necessita; produrrà un modulo del kernel nella presente directory che può essere caricato in questo modo:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload ./W32DRIVER.ko</span></code></pre></div></div><div class=paragraph><p>In aggiunta al modulo del kernel generato, devi caricare i moduli <span class=filename>ndis.ko</span> e <span class=filename>if_ndis.ko</span>. Questo dovrebbe avvenire automaticamente quando uno carica un modulo che dipende da <a href="https://man.freebsd.org/cgi/man.cgi?query=ndis&amp;sektion=4&amp;format=html">ndis(4)</a>. Se vuoi caricarli manualmente, usa il seguente comando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload ndis</span>
<span class=c># kldload if_ndis</span></code></pre></div></div><div class=paragraph><p>Il primo comando carica il wrapper del driver miniport NDIS, il secondo carica l’interfaccia di rete in questione.</p></div><div class=paragraph><p>Ora controlla <a href="https://man.freebsd.org/cgi/man.cgi?query=dmesg&amp;sektion=8&amp;format=html">dmesg(8)</a> per vedere se c’era qualche errore durante il caricamento. Se tutto è andato bene, dovresti ottenere dell’output che somiglia a questo:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>ndis0: &lt;Wireless-G PCI Adapter&gt; mem 0xf4100000-0xf4101fff irq 3 at device 8.0 on pci1
ndis0: NDIS API version: 5.0
ndis0: Ethernet address: 0a:b1:2c:d3:4e:f5
ndis0: 11b rates: 1Mbps 2Mbps 5.5Mbps 11Mbps
ndis0: 11g rates: 6Mbps 9Mbps 12Mbps 18Mbps 36Mbps 48Mbps 54Mbps</code></pre></div></div><div class=paragraph><p>D’ora in poi, puoi trattare il device <span class=filename>ndis0</span> come ogni altra scheda di rete (ad esempio <span class=filename>dc0</span>).</p></div><div class=paragraph><p>Puoi configurare il sistema perché carichi il modulo NDIS al momento del boot nello stesso modo di ogni altro modulo. Per prima cosa, copia il modulo generato <span class=filename>W32DRIVER.ko</span>, nella directory <span class=filename>/boot/modules</span>. Quindi, aggiungi le seguenti linee a <span class=filename>/boot/loader.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>W32DRIVER_load=&#34;YES&#34;</pre></div></div></div></div><div class=sect2><h3 id=_configurazione_della_scheda_di_rete>11.8.2. Configurazione della Scheda di Rete<a class=anchor href=#_configurazione_della_scheda_di_rete></a></h3><div class=paragraph><p>Una volta che il driver giusto per la scheda di rete è stato caricato, la scheda ha bisogno di essere configurata. Come molte altre cose, la scheda di rete potrebbe essere già stata configurata al momento dell’installazione tramite sysinstall.</p></div><div class=paragraph><p>Per mostrare la configurazione delle interfacce di rete sul tuo sistema, immetti il seguente comando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ifconfig
dc0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
        inet 192.168.1.3 netmask 0xffffff00 broadcast 192.168.1.255
        ether 00:a0:cc:da:da:da
        media: Ethernet autoselect <span class=o>(</span>100baseTX &lt;full-duplex&gt;<span class=o>)</span>
        status: active
dc1: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
        inet 10.0.0.1 netmask 0xffffff00 broadcast 10.0.0.255
        ether 00:a0:cc:da:da:db
        media: Ethernet 10baseT/UTP
        status: no carrier
lp0: <span class=nv>flags</span><span class=o>=</span>8810&lt;POINTOPOINT,SIMPLEX,MULTICAST&gt; mtu 1500
lo0: <span class=nv>flags</span><span class=o>=</span>8049&lt;UP,LOOPBACK,RUNNING,MULTICAST&gt; mtu 16384
        inet 127.0.0.1 netmask 0xff000000
tun0: <span class=nv>flags</span><span class=o>=</span>8010&lt;POINTOPOINT,MULTICAST&gt; mtu 1500</code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Vecchie versioni di FreeBSD potrebbero richiedere l’opzione <code>-a</code> dopo <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a>, per maggiori dettagli sulla sintassi corretta di <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a>, fai riferimento alla pagina man. Nota anche che le voci relative all’IPv6 (<code>inet6</code> ecc.) sono state omesse in questo esempio.</p></div></td></tr></tbody></table></div><div class=paragraph><p>In questo esempio, vengono mostrati i seguenti dispositivi:</p></div><div class=ulist><ul><li><p><span class=filename>dc0</span>: La prima interfaccia Ethernet</p></li><li><p><span class=filename>dc1</span>: La seconda interfaccia Ethernet</p></li><li><p><span class=filename>lp0</span>: L’interfaccia della porta parallela</p></li><li><p><span class=filename>lo0</span>: Il dispositivo di loopback</p></li><li><p><span class=filename>tun0</span>: Il dispositivo tunnel usato da ppp</p></li></ul></div><div class=paragraph><p>FreeBSD usa il nome del driver seguito dall’ordine nel quale la scheda è stata rilevata all’avvio del kernel per dare un nome alla scheda di rete. Ad esempio <span class=filename>sis2</span> sarebbe la terza scheda di rete nel sistema che usa il driver <a href="https://man.freebsd.org/cgi/man.cgi?query=sis&amp;sektion=4&amp;format=html">sis(4)</a>.</p></div><div class=paragraph><p>In questo esempio, il dispositivo <span class=filename>dc0</span> è attivo. Gli indicatori chiave sono:</p></div><div class="olist arabic"><ol class=arabic><li><p><code>UP</code> significa che la scheda è pronta e configurata.</p></li><li><p>La scheda ha un indirizzo Internet (<code>inet</code>) (in questo caso <code>192.168.1.3</code>).</p></li><li><p>Ha una maschera di sotto-rete valida (<code>netmask</code>; <code>0xffffff00</code> è lo stesso di <code>255.255.255.0</code>).</p></li><li><p>Ha un indirizzo di broadcast valido (in questo caso, <code>192.168.1.255</code>).</p></li><li><p>L’indirizzo MAC della scheda (<code>ether</code>) è <code>00:a0:cc:da:da:da</code>.</p></li><li><p>La selezione del mezzo fisico è in modalità auto selezione (<code>media: Ethernet autoselect (100baseTX &lt;full-duplex>)</code>). Vediamo che <span class=filename>dc1</span> è stata configurata con un mezzo fisico <code>10baseT/UTP</code>. Per ulteriori informazioni sui tipi di mezzi disponibili per un driver, fai riferimento alla sua pagina man.</p></li><li><p>Lo stato del collegamento (<code>status</code>) è <code>active</code>, ovvero è stata rilevata la portante. Per <span class=filename>dc1</span>, vediamo <code>status: no carrier</code>. Questo è normale quando un cavo Ethernet non è stato inserito nella scheda.</p></li></ol></div><div class=paragraph><p>Se l’output di <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a> avesse mostrato qualcosa di simile a:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>dc0: <span class=nv>flags</span><span class=o>=</span>8843&lt;BROADCAST,SIMPLEX,MULTICAST&gt; mtu 1500
                ether 00:a0:cc:da:da:da</code></pre></div></div><div class=paragraph><p>ciò avrebbe indicato che la scheda non era stata ben configurata.</p></div><div class=paragraph><p>Per configurare la tua scheda, avrai bisogno dei privilegi di <code>root</code>. La configurazione della scheda di rete può essere effettuata da riga di comando con <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a>, ma avresti bisogno di farlo ad ogni riavvio del sistema. Il file <span class=filename>/etc/rc.conf</span> è il posto giusto dove scrivere la configurazione della scheda di rete.</p></div><div class=paragraph><p>Apri <span class=filename>/etc/rc.conf</span> con il tuo editor preferito. Avrai bisogno di aggiungere una riga per ogni scheda di rete presente nel sistema, ad esempio nel nostro caso, abbiamo aggiunto queste linee:</p></div><div class="literalblock programlisting"><div class=content><pre>ifconfig_dc0=&#34;inet 192.168.1.3 netmask 255.255.255.0&#34;
ifconfig_dc1=&#34;inet 10.0.0.1 netmask 255.255.255.0 media 10baseT/UTP&#34;</pre></div></div><div class=paragraph><p>Dovrai sostituire <span class=filename>dc0</span>, <span class=filename>dc1</span>, e così via, con i dispositivi corretti per la tua scheda, e gli indirizzi con quelli appropriati. Dovresti leggere le pagine man del driver e di <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a> per maggiori dettagli sulle opzioni permesse ed anche la pagina man di <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a> per maggiori informazioni sulla sintassi di <span class=filename>/etc/rc.conf</span>.</p></div><div class=paragraph><p>Se hai configurato la rete durante l’installazione, alcune linee relative alle schede di rete potrebbero essere già presenti. Controlla due volte <span class=filename>/etc/rc.conf</span> prima di aggiungere ogni linea.</p></div><div class=paragraph><p>Avrai anche bisogno di modificare il file <span class=filename>/etc/hosts</span> per aggiungere i nomi e gli IP delle varie macchine della LAN, se non sono già lì. Per maggiori informazioni, fai riferimento a <a href="https://man.freebsd.org/cgi/man.cgi?query=hosts&amp;sektion=5&amp;format=html">hosts(5)</a> ed a <span class=filename>/usr/shared/examples/etc/hosts</span>.</p></div></div><div class=sect2><h3 id=_verifica_e_risoluzione_dei_problemi>11.8.3. Verifica e Risoluzione dei Problemi<a class=anchor href=#_verifica_e_risoluzione_dei_problemi></a></h3><div class=paragraph><p>Una volta che hai effettuato i cambiamenti necessari a <span class=filename>/etc/rc.conf</span>, dovresti riavviare la macchina. Ciò farà sì che i cambiamenti alle interfacce vengano applicati, e verificherà che il sistema si riavvii senza nessun errore di configurazione.</p></div><div class=paragraph><p>Una volta che il sistema è stato riavviato, dovresti testare le interfacce di rete.</p></div><div class=sect3><h4 id=_test_della_scheda_ethernet>11.8.3.1. Test della Scheda Ethernet<a class=anchor href=#_test_della_scheda_ethernet></a></h4><div class=paragraph><p>Per verificare che una scheda Ethernet sia configurata correttamente, si devono provare due cose. Prima, effettuare un ping verso l’interfaccia stessa, e poi un ping verso un’altra macchina sulla LAN.</p></div><div class=paragraph><p>Prima proviamo l’interfaccia:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ping <span class=nt>-c5</span> 192.168.1.3
PING 192.168.1.3 <span class=o>(</span>192.168.1.3<span class=o>)</span>: 56 data bytes
64 bytes from 192.168.1.3: <span class=nv>icmp_seq</span><span class=o>=</span>0 <span class=nv>ttl</span><span class=o>=</span>64 <span class=nb>time</span><span class=o>=</span>0.082 ms
64 bytes from 192.168.1.3: <span class=nv>icmp_seq</span><span class=o>=</span>1 <span class=nv>ttl</span><span class=o>=</span>64 <span class=nb>time</span><span class=o>=</span>0.074 ms
64 bytes from 192.168.1.3: <span class=nv>icmp_seq</span><span class=o>=</span>2 <span class=nv>ttl</span><span class=o>=</span>64 <span class=nb>time</span><span class=o>=</span>0.076 ms
64 bytes from 192.168.1.3: <span class=nv>icmp_seq</span><span class=o>=</span>3 <span class=nv>ttl</span><span class=o>=</span>64 <span class=nb>time</span><span class=o>=</span>0.108 ms
64 bytes from 192.168.1.3: <span class=nv>icmp_seq</span><span class=o>=</span>4 <span class=nv>ttl</span><span class=o>=</span>64 <span class=nb>time</span><span class=o>=</span>0.076 ms

<span class=nt>---</span> 192.168.1.3 ping statistics <span class=nt>---</span>
5 packets transmitted, 5 packets received, 0% packet loss
round-trip min/avg/max/stddev <span class=o>=</span> 0.074/0.083/0.108/0.013 ms</code></pre></div></div><div class=paragraph><p>Ora dobbiamo effettuare un ping verso un’altra macchina della LAN:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ping <span class=nt>-c5</span> 192.168.1.2
PING 192.168.1.2 <span class=o>(</span>192.168.1.2<span class=o>)</span>: 56 data bytes
64 bytes from 192.168.1.2: <span class=nv>icmp_seq</span><span class=o>=</span>0 <span class=nv>ttl</span><span class=o>=</span>64 <span class=nb>time</span><span class=o>=</span>0.726 ms
64 bytes from 192.168.1.2: <span class=nv>icmp_seq</span><span class=o>=</span>1 <span class=nv>ttl</span><span class=o>=</span>64 <span class=nb>time</span><span class=o>=</span>0.766 ms
64 bytes from 192.168.1.2: <span class=nv>icmp_seq</span><span class=o>=</span>2 <span class=nv>ttl</span><span class=o>=</span>64 <span class=nb>time</span><span class=o>=</span>0.700 ms
64 bytes from 192.168.1.2: <span class=nv>icmp_seq</span><span class=o>=</span>3 <span class=nv>ttl</span><span class=o>=</span>64 <span class=nb>time</span><span class=o>=</span>0.747 ms
64 bytes from 192.168.1.2: <span class=nv>icmp_seq</span><span class=o>=</span>4 <span class=nv>ttl</span><span class=o>=</span>64 <span class=nb>time</span><span class=o>=</span>0.704 ms

<span class=nt>---</span> 192.168.1.2 ping statistics <span class=nt>---</span>
5 packets transmitted, 5 packets received, 0% packet loss
round-trip min/avg/max/stddev <span class=o>=</span> 0.700/0.729/0.766/0.025 ms</code></pre></div></div><div class=paragraph><p>Puoi usare il nome della macchina invece di <code>192.168.1.2</code> se hai sistemato il file <span class=filename>/etc/hosts</span>.</p></div></div><div class=sect3><h4 id=_risoluzione_dei_problemi>11.8.3.2. Risoluzione dei Problemi<a class=anchor href=#_risoluzione_dei_problemi></a></h4><div class=paragraph><p>Risolvere i problemi delle varie configurazioni hardware e software è sempre una faticaccia, ma è una fatica che può essere diminuita controllando da subito le cose semplici. Avete collegato il cavo di rete? Avete configurato i servizi di rete? Avete configurato il firewall correttamente? La scheda di rete che state usando è supportata da FreeBSD? Controllate sempre le note sul vostro hardware prima di inviare un bug report. Aggiornate la vostra versione di FreeBSD all’ultima versione STABLE disponibile. Controllate gli archivi delle mailing list, o magari cercate su Internet.</p></div><div class=paragraph><p>Se la scheda funziona, ma le prestazioni sono scadenti, potrebbe esservi utile la lettura della pagina man <a href="https://man.freebsd.org/cgi/man.cgi?query=tuning&amp;sektion=7&amp;format=html">tuning(7)</a>. Potreste anche verificare la vostra configurazione della rete, poichè una configurazione scorretta può essere la causa di connessioni lente.</p></div><div class=paragraph><p>Alcuni utenti riscontrano dei <code>device timeouts</code>, il che è normale per alcune schede. Se questi continuano, o se sono fastidiosi, potreste voler ricontrollare che non ci siano conflitti con altri dispositivi. Controllate due volte la connessione di rete. Forse dovreste procurarvi un’altra scheda.</p></div><div class=paragraph><p>Alcune volte, gli utenti notano alcuni errori <code>watchdog timeout</code>. La prima cosa da fare è controllare il cavo di rete. Alcune schede di rete richiedono uno slot PCI che supporti il Bus Mastering. Su alcune vecchie schede madri, ciò è permesso solo per uno slot PCI (tipicamente lo slot 0). Controllate la documentazione della scheda di rete e della scheda madre per determinare se possa essere quello il problema.</p></div><div class=paragraph><p>Messaggi <code>No route to host</code> vengono generati se il sistema non è in grado di effettuare il routing di un pacchetto verso una certa destinazione. Ciò può accadere se non è specificata una route di default, o se il cavo è scollegato. Controllate l’output di <code>netstat -rn</code> ed assicuratevi che ci sia una route valida per l’host che state cercando di raggiungere. Se non c’è, leggete il <a href=../advanced-networking/#advanced-networking>Networking Avanzato</a>.</p></div><div class=paragraph><p>I messaggi d’errore <code>ping: sendto: Permission denied</code> sono spessi causati da un firewall mal configurato. Se <code>ipfw</code> è abilitato nel kernel ma non ci sono regole definite, allora la politica di default è di negare tutto il traffico, comprese le richieste di ping! Leggete il <a href=../firewalls/#firewalls>Firewall</a> per maggiori informazioni.</p></div><div class=paragraph><p>Talvolta le prestazioni della scheda di rete sono scadenti, o sotto la media. In questi casi è preferibile cambiare la selezione del media da <code>autoselect</code> ad una selezione corretta. Anche se questo sistema funziona con la maggior parte dell’hardware, potrebbe non risolvere il problema per tutti. Ancora una volta, controllate tutte le impostazioni di rete, e leggete la pagina man <a href="https://man.freebsd.org/cgi/man.cgi?query=tuning&amp;sektion=7&amp;format=html">tuning(7)</a> .</p></div></div></div></div></div><div class=sect1><h2 id=configtuning-virtual-hosts>11.9. Host Virtuali<a class=anchor href=#configtuning-virtual-hosts></a></h2><div class=sectionbody><div class=paragraph><p>Un uso piuttosto comune di FreeBSD è come hosting di siti virtuali, dove un solo server appare alla rete come molti server distinti. Ciò viene effettuato assegnando indirizzi di rete multipli ad una sola interfaccia.</p></div><div class=paragraph><p>Una data interfaccia di rete ha un solo indirizzo "reale", e può avere un numero qualsiasi di indirizzi "alias". Questi alias vengono normalmente aggiunti mettendo dei campi alias in <span class=filename>/etc/rc.conf</span>.</p></div><div class=paragraph><p>Un campo alias per l’interfaccia <span class=filename>fxp0</span> appare così:</p></div><div class="literalblock programlisting"><div class=content><pre>ifconfig_fxp0_alias0=&#34;inet xxx.xxx.xxx.xxx netmask xxx.xxx.xxx.xxx&#34;</pre></div></div><div class=paragraph><p>Nota che il campo alias deve iniziare con <code>alias0</code> e aumentare in ordine, (ad esempio, <code>_alias1</code>, <code>_alias2</code>, e così via). Il processo di configurazione si fermerà al primo numero mancante.</p></div><div class=paragraph><p>Il calcolo delle maschere di sotto-rete degli alias è importante, ma, fortunatamente, è anche abbastanza semplice. Per una data interfaccia, deve esserci un indirizzo che rappresenta correttamente la maschera di sotto-rete. Ogni altro indirizzo che ricada in questa rete deve avere una maschera di sotto-rete con tutti <code>1</code> (espressi come <code>255.255.255.255</code> o <code>0xffffffff</code>).</p></div><div class=paragraph><p>Ad esempio, considera il caso in cui l’interfaccia <span class=filename>fxp0</span> sia connessa a due reti, la rete <code>10.1.1.0</code> con maschera di sotto-rete <code>255.255.255.0</code> e la rete <code>202.0.75.16</code> con maschera di sotto-rete <code>255.255.255.240</code>. Vogliamo che il sistema sia visibile come <code>10.1.1.1</code> fino a <code>10.1.1.5</code> e come <code>202.0.75.17</code> fino a <code>202.0.75.20</code>. Come notato sopra, solo il primo indirizzo in un dato range di sotto-rete (in questo caso, <code>10.0.1.1</code> e <code>202.0.75.17</code>) dovrebbe avere una vera netmask; tutto il resto ( <code>10.1.1.2</code> fino a <code>10.1.1.5</code> e <code>202.0.75.18</code> fino a <code>202.0.75.20</code>) dovrebbe essere configurato con una netmask di <code>255.255.255.255</code>.</p></div><div class=paragraph><p>Le seguenti righe configurano il dispositivo correttamente per questo scopo:</p></div><div class="literalblock programlisting"><div class=content><pre> ifconfig_fxp0=&#34;inet 10.1.1.1 netmask 255.255.255.0&#34;
 ifconfig_fxp0_alias0=&#34;inet 10.1.1.2 netmask 255.255.255.255&#34;
 ifconfig_fxp0_alias1=&#34;inet 10.1.1.3 netmask 255.255.255.255&#34;
 ifconfig_fxp0_alias2=&#34;inet 10.1.1.4 netmask 255.255.255.255&#34;
 ifconfig_fxp0_alias3=&#34;inet 10.1.1.5 netmask 255.255.255.255&#34;
 ifconfig_fxp0_alias4=&#34;inet 202.0.75.17 netmask 255.255.255.240&#34;
 ifconfig_fxp0_alias5=&#34;inet 202.0.75.18 netmask 255.255.255.255&#34;
 ifconfig_fxp0_alias6=&#34;inet 202.0.75.19 netmask 255.255.255.255&#34;
 ifconfig_fxp0_alias7=&#34;inet 202.0.75.20 netmask 255.255.255.255&#34;</pre></div></div></div></div><div class=sect1><h2 id=configtuning-configfiles>11.10. File di Configurazione<a class=anchor href=#configtuning-configfiles></a></h2><div class=sectionbody><div class=sect2><h3 id=_struttura_di_etc>11.10.1. Struttura di <span class=filename>/etc</span><a class=anchor href=#_struttura_di_etc></a></h3><div class=paragraph><p>Ci sono molte directory nelle quali vengono tenute le informazioni di configurazione. Tra queste ci sono:</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/etc</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Informazioni generiche sulla configurazione del sistema; questi dati sono specifici del sistema.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/etc/defaults</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Versioni di default dei file di configurazione del sistema.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/etc/mail</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Configurazioni extra di <a href="https://man.freebsd.org/cgi/man.cgi?query=sendmail&amp;sektion=8&amp;format=html">sendmail(8)</a>, o file di configurazione di altri MTA.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/etc/ppp</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Configurazione ppp sia per i programmi a livello utente che a livello kernel.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/etc/namedb</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Posizione predefinita per i dati di <a href="https://man.freebsd.org/cgi/man.cgi?query=named&amp;sektion=8&amp;format=html">named(8)</a>. Normalmente qui si trova <span class=filename>named.conf</span> insieme ai file di zona.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/local/etc</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>File di configurazione per le applicazioni installate. Può contenere sottodirectory.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/local/etc/rc.d</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Script start/stop per i programmi installati.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/var/db</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>File di dati specifici del sistema generati automaticamente, come il database dei package, il database di locate, e così via.</p></td></tr></tbody></table></div><div class=sect2><h3 id=_nomi_degli_host>11.10.2. Nomi degli Host<a class=anchor href=#_nomi_degli_host></a></h3><div class=sect3><h4 id=_etcresolv_conf>11.10.2.1. <span class=filename>/etc/resolv.conf</span><a class=anchor href=#_etcresolv_conf></a></h4><div class=paragraph><p><span class=filename>/etc/resolv.conf</span> detta il modo in cui il sistema di risoluzione dei nomi di FreeBSD accede al DNS (Internet Domain Name System).</p></div><div class=paragraph><p>I campi più comuni in <span class=filename>resolv.conf</span> sono:</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>nameserver</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>L’indirizzo IP di un name server al quale dovrà rivolgersi il sistema di risoluzione. I server vengono interrogati nell’ordine in cui sono elencati, fino a un massimo di tre.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>search</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Lista di ricerca per i nomi degli host. Normalmente questo viene determinato dal dominio dell’host locale.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>domain</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Il nome del dominio locale.</p></td></tr></tbody></table><div class=paragraph><p>Un <span class=filename>resolv.conf</span> tipico:</p></div><div class="literalblock programlisting"><div class=content><pre>search example.com
nameserver 147.11.1.11
nameserver 147.11.100.30</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Si dovrebbe usare solo una tra le due opzioni <code>search</code> e <code>domain</code>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Se stai usando DHCP, <a href="https://man.freebsd.org/cgi/man.cgi?query=dhclient&amp;sektion=8&amp;format=html">dhclient(8)</a> generalmente sovrascriverà <span class=filename>resolv.conf</span> con le informazioni ricevute dal server DHCP.</p></div></div><div class=sect3><h4 id=_etchosts>11.10.2.2. <span class=filename>/etc/hosts</span><a class=anchor href=#_etchosts></a></h4><div class=paragraph><p><span class=filename>/etc/hosts</span> è un semplice database testuale, reminiscenza della vecchia rete Internet. Esso lavora in congiunzione con DNS e NIS fornendo una mappatura da nome a indirizzo IP. Computer locali connessi ad una LAN possono essere messi in questo file per una gestione semplice dei nomi, invece di mettere su un server <a href="https://man.freebsd.org/cgi/man.cgi?query=named&amp;sektion=8&amp;format=html">named(8)</a>. Inoltre, <span class=filename>/etc/hosts</span> può essere usato per fornire un registro locale dei nomi di Internet, riducendo la necessità di effettuare richieste esternamente per i nomi ad accesso frequente.</p></div><div class="literalblock programlisting"><div class=content><pre># $FreeBSD$
#
# Host Database
# Questo file dovrebbe contenere gli indirizzi e gli alias
# per gli host locali che condividono questo file.
# In presenza di DNS o NIS, questo file potrebbe non essere consultato affatto;
# guarda /etc/nsswitch.conf per l&#39;ordine di risoluzione.
#
#
::1                     localhost localhost.my.domain myname.my.domain
127.0.0.1               localhost localhost.my.domain myname.my.domain

#
# Rete immaginaria.
#10.0.0.2               myname.my.domain myname
#10.0.0.3               myfriend.my.domain myfriend
#
# In accordo all&#39;RFC 1918, puoi usare le seguenti classi di IP per reti private
# che non verranno mai connesse ad Internet:
#
#       10.0.0.0        -   10.255.255.255
#       172.16.0.0      -   172.31.255.255
#       192.168.0.0     -   192.168.255.255
#
# In caso volessi essere in grado di collegarti ad Internet, avrai bisogno
# di veri numeri ufficiali assegnati.  PER FAVORE PER FAVORE PER FAVORE
# non tentare di inventarti i numeri della tua rete ma fattene assegnare
# uno dal tuo provider (se ne hai uno) o dall&#39;Internet Registry (ftp su
# rs.internic.net, directory `/templates&#39;).
#</pre></div></div><div class=paragraph><p><span class=filename>/etc/hosts</span> accetta il semplicissimo formato:</p></div><div class="literalblock programlisting"><div class=content><pre>[Indirizzo Internet ] [nome host ufficiale] [alias1] [alias2] ...</pre></div></div><div class=paragraph><p>Ad esempio:</p></div><div class="literalblock programlisting"><div class=content><pre>10.0.0.1 myRealHostname.example.com myRealHostname foobar1 foobar2</pre></div></div><div class=paragraph><p>Consulta <a href="https://man.freebsd.org/cgi/man.cgi?query=hosts&amp;sektion=5&amp;format=html">hosts(5)</a> per maggiori informazioni.</p></div></div></div><div class=sect2><h3 id=_configurazione_dei_file_di_log>11.10.3. Configurazione dei File di Log<a class=anchor href=#_configurazione_dei_file_di_log></a></h3><div class=sect3><h4 id=_syslog_conf>11.10.3.1. <span class=filename>syslog.conf</span><a class=anchor href=#_syslog_conf></a></h4><div class=paragraph><p><span class=filename>syslog.conf</span> è il file di configurazione per il programma <a href="https://man.freebsd.org/cgi/man.cgi?query=syslogd&amp;sektion=8&amp;format=html">syslogd(8)</a>. Indica quale tipo di messaggi <code>syslog</code> verranno scritti su ogni file di log.</p></div><div class="literalblock programlisting"><div class=content><pre># $FreeBSD$
#
#       Gli spazi SONO validi separatori dei campi in questo file. Ad ogni modo,
#       altri sistemi *nix-like insistono ancora nell&#39;usare tab come separatori
#       di campo. Se condividi questo file tra più sistemi, potresti
#       voler usare solo dei tab come separatori.
#       Consulta la pagina man di syslog.conf(5).
*.err;kern.debug;auth.notice;mail.crit          /dev/console
*.notice;kern.debug;lpr.info;mail.crit;news.err /var/log/messages
security.*                                      /var/log/security
mail.info                                       /var/log/maillog
lpr.info                                        /var/log/lpd-errs
cron.*                                          /var/log/cron
*.err                                           root
*.notice;news.err                               root
*.alert                                         root
*.emerg                                         *
# togli il commento a questo per loggare tutte le scritture su /dev/console
# in /var/log/console.log
#console.info                                   /var/log/console.log
# togli il commento a questo per abilitare il logging di tutti i messaggi di log
# su /var/log/all.log
#*.*                                            /var/log/all.log
# togli il commento a questo per abilitare il logging su un host remoto di nome
# loghost
#*.*                                            @loghost
# togli i commenti a questi se hai inn in funzione
# news.crit                                     /var/log/news/news.crit
# news.err                                      /var/log/news/news.err
# news.notice                                   /var/log/news/news.notice
!startslip
*.*                                             /var/log/slip.log
!ppp
*.*                                             /var/log/ppp.log</pre></div></div><div class=paragraph><p>Consulta la pagina man di <a href="https://man.freebsd.org/cgi/man.cgi?query=syslog.conf&amp;sektion=5&amp;format=html">syslog.conf(5)</a> per maggiori informazioni.</p></div></div><div class=sect3><h4 id=_newsyslog_conf>11.10.3.2. <span class=filename>newsyslog.conf</span><a class=anchor href=#_newsyslog_conf></a></h4><div class=paragraph><p><span class=filename>newsyslog.conf</span> è il file di configurazione di <a href="https://man.freebsd.org/cgi/man.cgi?query=newsyslog&amp;sektion=8&amp;format=html">newsyslog(8)</a>, un programma che normalmente viene eseguito da <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a>. <a href="https://man.freebsd.org/cgi/man.cgi?query=newsyslog&amp;sektion=8&amp;format=html">newsyslog(8)</a> determina quando i file di log richiedono un’archiviazione o un riordinamento. <span class=filename>logfile</span> viene rinominato in <span class=filename>logfile.0</span>, <span class=filename>logfile.0</span> in <span class=filename>logfile.1</span> e così via. Alternativamente, i file potranno essere archiviati in formato <a href="https://man.freebsd.org/cgi/man.cgi?query=gzip&amp;sektion=1&amp;format=html">gzip(1)</a>, e quindi diventeranno: <span class=filename>logfile.0.gz</span>, <span class=filename>logfile.1.gz</span>, e così via.</p></div><div class=paragraph><p><span class=filename>newsyslog.conf</span> indica quali file di log devono essere gestiti, quanti devono essere mantenuti, e quando devono essere toccati. I file di log possono essere riordinati e/o archiviati quando raggiungono una certa dimensione, o a una certa data/ora periodica.</p></div><div class="literalblock programlisting"><div class=content><pre># file di configurazione per newsyslog
# $FreeBSD$
#
# filename          [owner:group]    mode count size when [ZB] [/pid_file] [sig_num]
/var/log/cron                           600  3     100  *     Z
/var/log/amd.log                        644  7     100  *     Z
/var/log/kerberos.log                   644  7     100  *     Z
/var/log/lpd-errs                       644  7     100  *     Z
/var/log/maillog                        644  7     *    @T00  Z
/var/log/sendmail.st                    644  10    *    168   B
/var/log/messages                       644  5     100  *     Z
/var/log/all.log                        600  7     *    @T00  Z
/var/log/slip.log                       600  3     100  *     Z
/var/log/ppp.log                        600  3     100  *     Z
/var/log/security                       600  10    100  *     Z
/var/log/wtmp                           644  3     *    @01T05 B
/var/log/daily.log                      640  7     *    @T00  Z
/var/log/weekly.log                     640  5     1    $W6D0 Z
/var/log/monthly.log                    640  12    *    $M1D0 Z
/var/log/console.log                    640  5     100  *     Z</pre></div></div><div class=paragraph><p>Consulta la pagina man di <a href="https://man.freebsd.org/cgi/man.cgi?query=newsyslog&amp;sektion=8&amp;format=html">newsyslog(8)</a> per maggiori informazioni.</p></div></div></div><div class=sect2><h3 id=configtuning-sysctlconf>11.10.4. <span class=filename>sysctl.conf</span><a class=anchor href=#configtuning-sysctlconf></a></h3><div class=paragraph><p><span class=filename>sysctl.conf</span> assomiglia molto a <span class=filename>rc.conf</span>. I valori vengono impostati nella forma <code>variabile=valore</code>. I valori specificati vengono impostati dopo che il sistema è entrato in modalità multiutente. Non tutte le variabili sono gestibili in questo modo.</p></div><div class=paragraph><p>Per disabilitare il log sulle uscite dei processi per segnale fatale ed impedire agli utenti di vedere che i processi sono avviati con altre utenze, puoi settare in <span class=filename>sysctl.conf</span> la riga seguente:</p></div><div class="literalblock programlisting"><div class=content><pre># Do not log fatal signal exits (e.g. sig 11)
kern.logsigexit=0

# Prevent users from seeing information about processes that
# are being run under another UID.
security.bsd.see_other_uids=0</pre></div></div></div></div></div><div class=sect1><h2 id=configtuning-sysctl>11.11. Messa a Punto con sysctl<a class=anchor href=#configtuning-sysctl></a></h2><div class=sectionbody><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> è un’interfaccia che permette di effettuare cambiamenti ad un sistema FreeBSD già attivo. Questo include molte opzioni avanzate dello stack TCP/IP e del sistema di memoria virtuale che possono permettere di migliorare drammaticamente le prestazioni ad un sistemista che abbia esperienza. Più di cinquecento variabili di sistema possono essere lette e modificate usando <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a>.</p></div><div class=paragraph><p>In sostanza, <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> serve a due cose: a leggere e a modificare le impostazioni di sistema.</p></div><div class=paragraph><p>Per visualizzare tutte le variabili leggibili:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% sysctl <span class=nt>-a</span></code></pre></div></div><div class=paragraph><p>Per leggere una particolare variabile, ad esempio, <code>kern.maxproc</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% sysctl kern.maxproc
kern.maxproc: 1044</code></pre></div></div><div class=paragraph><p>Per impostare una particolare variabile, usa l’intuitiva sintassi <em>variabile</em>=<em>valore</em>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl kern.maxfiles=5000</span>
kern.maxfiles: 2088 -&gt; 5000</code></pre></div></div><div class=paragraph><p>I valori validi per le variabili di sysctl sono generalmente o stringhe, o numeri, o valori booleani (un valore booleano può valere <code>1</code> per sì o <code>0</code> per no).</p></div><div class=paragraph><p>Se vuoi settare in modo automatico alcune variabile ad ogni avvio della macchina, usa il file <span class=filename>/etc/sysctl.conf</span>. Per maggiori informazioni guarda la pagina man di <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl.conf&amp;sektion=5&amp;format=html">sysctl.conf(5)</a> e la <a href=#configtuning-sysctlconf><span class=filename>sysctl.conf</span></a>.</p></div><div class=sect2><h3 id=sysctl-readonly>11.11.1. <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> in sola lettura<a class=anchor href=#sysctl-readonly></a></h3><div class=paragraph><p>In alcuni casi può essere desiderabile modificare i valori di <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> in sola lettura. Anche se questo talvolta è inevitabile, può essere fatto solo con un riavvio.</p></div><div class=paragraph><p>Ad esempio in alcuni modelli di laptop il dispositivo <a href="https://man.freebsd.org/cgi/man.cgi?query=cardbus&amp;sektion=4&amp;format=html">cardbus(4)</a> non effettuerà il controllo sugli intervalli di memoria, e fallirà con errori che assomigliano a questi:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>cbb0: Could not map register memory
device_probe_and_attach: cbb0 attach returned 12</code></pre></div></div><div class=paragraph><p>Casi come il precedente richiedono tipicamente la modifica di alcuni valori predefiniti di <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> che sono impostati come sola lettura. Per superare queste situazioni un utente può mettere degli "OID" di <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> nel proprio <span class=filename>/boot/loader.conf.local</span>. I valori predefiniti sono indicati nel file <span class=filename>/boot/defaults/loader.conf</span>.</p></div><div class=paragraph><p>Per risolvere i problemi menzionati qui sopra sarà necessario modificare <code>hw.pci.allow_unsupported_io_range=1</code> nel file suddetto. Ora <a href="https://man.freebsd.org/cgi/man.cgi?query=cardbus&amp;sektion=4&amp;format=html">cardbus(4)</a> funzionerà correttamente.</p></div></div></div></div><div class=sect1><h2 id=configtuning-disk>11.12. Messa a Punto dei Dischi<a class=anchor href=#configtuning-disk></a></h2><div class=sectionbody><div class=sect2><h3 id=_variabili_sysctl>11.12.1. Variabili Sysctl<a class=anchor href=#_variabili_sysctl></a></h3><div class=sect3><h4 id=_vfs_vmiodirenable>11.12.1.1. <code>vfs.vmiodirenable</code><a class=anchor href=#_vfs_vmiodirenable></a></h4><div class=paragraph><p>La variabile sysctl <code>vfs.vmiodirenable</code> può essere impostata a 0 (inattivo) o 1 (attivo); di default è 1. Questa variabile controlla il modo in cui le directory vengono messe nella cache dal sistema. La maggior parte delle directory sono piccole, e usano solo un singolo frammento (tipicamente 1 K) nel file system e meno (tipicamente 512 byte) nella cache. Con questa variabile impostata a 0, il buffer manterrà soltanto un numero fissato di directory nella cache anche se hai una quantità enorme di memoria. Attivando questa sysctl si permette al buffer di usare la VM Page Cache per immagazzinare le directory, rendendo disponibile tutta la memoria disponibile per il caching delle directory. In ogni caso, la minima quantità di memoria usata per memorizzare una directory sarà la dimensione della pagina fisica (in genere 4 K) invece di 512 byte. Noi consigliamo di attivare questa opzione se si hanno in esecuzione dei servizi che manipolano un grosso numero file. Servizi di questo tipo sono le cache web, i grandi sistemi di posta, e quelli di news. Attivare questa opzione in generale non ridurrà le prestazioni nonostante la memoria sprecata, ma dovresti sperimentare tu stesso per verificare.</p></div></div><div class=sect3><h4 id=_vfs_write_behind>11.12.1.2. <code>vfs.write_behind</code><a class=anchor href=#_vfs_write_behind></a></h4><div class=paragraph><p>La variabile sysctl <code>vfs.write_behind</code> ha il valore predefinito di <code>1</code> (attivo). Essa dice al file system di effettuare le scritture sul media quando vengono raccolti cluster completi, il che accade tipicamente quando si scrivono grossi file sequenziali. L’idea è di evitare la saturazione del buffer cache con buffer "sporchi" quando le prestazioni dell’I/O non ne trarrebbero giovamento. Ad ogni modo, questo può causare uno stallo dei processi, ed in alcune circostanze potreste desiderare di disabilitarlo.</p></div></div><div class=sect3><h4 id=_vfs_hirunningspace>11.12.1.3. <code>vfs.hirunningspace</code><a class=anchor href=#_vfs_hirunningspace></a></h4><div class=paragraph><p>La variabile sysctl <code>vfs.hirunningspace</code> determina quanto grande deve essere la coda I/O in tutti i controller dei dischi nel sistema in un dato momento. Il valore predefinito in genere è sufficiente ma su macchine con molti dischi potreste voler aumentarlo a quattro o cinque <em>megabyte</em>. Notate che impostandolo ad un valore troppo alto (superando i limiti della cache) potreste avere delle performance peggiori. Non impostate un valore troppo alto arbitrariamente! Valori più alti aumentano la latenza nelle letture contemporanee.</p></div><div class=paragraph><p>Ci sono altre sysctl relative alla buffer-cache ed alle cache delle pagine VM. Non vi consigliamo di cambiare questi valori, il sistema di VM fa già un ottimo lavoro di messa a punto automatica.</p></div></div><div class=sect3><h4 id=_vm_swap_idle_enabled>11.12.1.4. <code>vm.swap_idle_enabled</code><a class=anchor href=#_vm_swap_idle_enabled></a></h4><div class=paragraph><p>La variabile sysctl <code>vm.swap_idle_enabled</code> è utile in grossi sistemi multiutente dove si hanno molti utenti che entrano ed escono lasciando molti processi inattivi. Questi sistemi tendono a generare un grande pressione sulle riserve di memoria libera. Attivando questa caratteristica e manipolando l’isteresi di swap (in secondi di inattività) tramite <code>vm.swap_idle_threshold1</code> e <code>vm.swap_idle_threshold2</code> potete abbassare la priorità delle pagine di memoria associate con i processi inattivi più velocemente che con il normale algoritmo di paginazione. Ciò dà una mano al demone di paginazione. Non attivate questa opzione a meno che non ne abbiate bisogno, poichè il compromesso che state accettando è essenzialmente di pre-paginare la memoria in anticipo piuttosto che in ritardo, consumando dunque più swap e banda di trasmissione verso il disco. In un piccolo sistema questa opzione avrà un effetto ridotto ma in un grosso sistema che è già sottoposto a un moderato carico di paginazione questa opzione permette al sistema VM di spostare facilmente interi processi dentro e fuori la memoria.</p></div></div><div class=sect3><h4 id=_hw_ata_wc>11.12.1.5. <code>hw.ata.wc</code><a class=anchor href=#_hw_ata_wc></a></h4><div class=paragraph><p>FreeBSD 4.3 ha giocato un pò con l’idea di disattivare il caching IDE in scrittura. Questo ha ridotto la larghezza di banda in scrittura verso i dischi IDE ma è stato considerato necessario a causa di gravi problemi di consistenza dei dati introdotti dai venditori di dischi rigidi. Il problema è che il disco IDE rimane inattivo dopo che una scrittura è stata completata. Con il caching in scrittura attivo, i dischi IDE non scrivono soltanto i dati sui dischi in maniera disordinata, ma talvolta rimandano la scrittura indefinitamente sotto carichi di lavoro del disco pesanti. Un crash o un calo di tensione possono condurre a seri problemi di corruzione del file system. L’impostazione predefinita di FreeBSD fu cambiata in favore della sicurezza. Sfortunatamente, il risultato è stato una perdita di prestazioni talmente tremenda che abbiamo dovuto reinserire il caching in scrittura di default dopo quella release. Dovresti verificare il valore di default sul tuo sistema osservando la variabile sysctl <code>hw.ata.wc</code>. Se il caching IDE in scrittura è disattivato, potete attivarlo reimpostando la variabile del kernel a 1. Questo dovrebbe essere effettuato dal boot loader all’avvio. Tentare di effettuare questo cambiamento dopo che il kernel è stato avviato non avrà nessun effetto.</p></div><div class=paragraph><p>Per maggiori informazioni, guarda <a href="https://man.freebsd.org/cgi/man.cgi?query=ata&amp;sektion=4&amp;format=html">ata(4)</a>.</p></div></div><div class=sect3><h4 id=_scsi_delay_kern_cam_scsi_delay>11.12.1.6. <code>SCSI_DELAY</code> (<code>kern.cam.scsi_delay</code>)<a class=anchor href=#_scsi_delay_kern_cam_scsi_delay></a></h4><div class=paragraph><p>La configurazione del kernel <code>SCSI_DELAY</code> può ridurre il tempo di avvio del sistema. I valori di default sono piuttosto alti e possono essere responsabili anche di <code>15</code> secondi di ritardo nel processo di avvio. Ridurre il valore a <code>5</code> secondi funziona in molti casi (specialmente con i dispositivi moderni). Nuove versioni di FreeBSD (5.0 e superiori) dovrebbero essere in grado di usare <code>kern.cam.scsi_delay</code> come un’opzione da boot. Quest’ultima e l’opzione di configurazione del kernel accettano valori in <em>millisecondi</em> , e <em>non</em> in <em>secondi</em>.</p></div></div></div><div class=sect2><h3 id=soft-updates>11.12.2. Soft Update<a class=anchor href=#soft-updates></a></h3><div class=paragraph><p>Il programma <a href="https://man.freebsd.org/cgi/man.cgi?query=tunefs&amp;sektion=8&amp;format=html">tunefs(8)</a> può essere usato per mettere a punto con accuratezza un file system. Questo programma ha molte opzioni differenti, ma per ora noi ci preoccuperemo solo di attivare e disattivare i Soft Update, che verrà effettuato tramite:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># tunefs -n enable /filesystem</span>
<span class=c># tunefs -n disable /filesystem</span></code></pre></div></div><div class=paragraph><p>Un file system non potrà essere modificato con <a href="https://man.freebsd.org/cgi/man.cgi?query=tunefs&amp;sektion=8&amp;format=html">tunefs(8)</a> mentre è montato. Un buon momento per attivare i Soft Update è prima che le partizioni siano montate, in modalità singolo utente.</p></div><div class=paragraph><p>I Soft Update migliorano drasticamente le prestazioni dei meta-dati, principalmente la creazione e la cancellazione di file, attraverso l’uso di una memoria cache. Consigliamo di attivare i Soft Update su tutti i file system. Ci sono due lati negativi relativi ai Soft Update dei quali dovresti essere a conoscenza: primo, i Soft Update garantiscono la consistenza del file system in caso di crash ma è più che probabile che passino molti secondi (anche un minuto!) prima che venga aggiornato fisicamente il disco. Se il sistema va in crash potresti perdere molto più lavoro in questo modo. Secondo, i Soft Update rallentano la liberazione dei blocchi liberi del file system. Se hai un file system (come il file system root) che è quasi pieno, la realizzazione di un grosso aggiornamento, come un <code>make installworld</code>, potrebbe essere causa di un superamento dei limiti di spazio del file system e di un fallimento dell’aggiornamento.</p></div><div class=sect3><h4 id=_maggiori_dettagli_sui_soft_update>11.12.2.1. Maggiori Dettagli sui Soft Update<a class=anchor href=#_maggiori_dettagli_sui_soft_update></a></h4><div class=paragraph><p>Ci sono due approcci tradizionalmente nella scrittura dei meta-dati del file system su disco. (Gli aggiornamenti dei meta-dati sono aggiornamenti ai dati che non sono contenuto, come gli inode o le directory.)</p></div><div class=paragraph><p>Storicamente, il comportamento predefinito era di scrivere gli aggiornamenti dei meta-dati in maniera sincrona. Se una directory veniva modificata, il sistema attendeva finchè il cambiamento venisse effettivamente scritto su disco. I buffer con i dati dei file (i contenuti dei file) venivano passati attraverso la cache e salvati su disco in seguito, in maniera asincrona. Il vantaggio di questa implementazione è che avviene in maniera sicura. Se si verifica un problema durante un aggiornamento, i meta-dati sono sempre in uno stato consistente. Un file viene creato completamente o non viene creato affatto. Se i blocchi dati di un file non sono riusciti ad uscire dalla cache e arrivare al disco prima del crash, <a href="https://man.freebsd.org/cgi/man.cgi?query=fsck&amp;sektion=8&amp;format=html">fsck(8)</a> è in grado di capirlo e riparare il file system impostando a zero la lunghezza del file. Inoltre, l’implementazione è chiara e semplice. Lo svantaggio è che i cambiamenti dei meta-dati sono lenti. Un <code>rm -r</code>, ad esempio, tocca tutti i file in una directory consecutivamente, ma ogni cambiamento della directory (la cancellazione del file) verrà scritto su disco in maniera sincrona. Questo include gli aggiornamenti alla directory stessa, alla tabella degli inode, e magari anche ai blocchi indiretti allocati dal file. Simili considerazioni si applicano nell’elenco di grosse gerarchie (<code>tar -x</code>).</p></div><div class=paragraph><p>Il secondo caso è l’aggiornamento asincrono dei meta-dati. Questo è il comportamento predefinito per Linux/ext2fs e <code>mount -o async</code> per *BSD/ufs. Anche tutti gli aggiornamenti dei meta-dati vengono semplicemente fatti passare attraverso la cache, cioè vengono mescolati con gli aggiornamenti dei dati contenuti nel file. Il vantaggio di questa implementazione è che non c’è bisogno di attendere che ogni aggiornamento dei meta-dati venga scritto su disco, dunque tutte le operazioni che causano enormi quantità di aggiornamenti dei meta-dati lavorano molto più velocemente che nel caso sincrono. Inoltre, l’implementazione è ancora semplice e chiara, dunque c’è un basso rischio che si annidino dei bug nel codice. Lo svantaggio è che non c’è nessuna garanzia di uno stato consistente del file system. Se si verifica un problema durante un’operazione che ha aggiornato grandi quantità di meta-dati (ad esempio un abbassamento di tensione, o qualcuno che preme il tasto reset), il file system verrà lasciato in uno stato imprevedibile. Non c’è opportunità di esaminare lo stato del file system quando il sistema viene riavviato; i blocchi dati di un file potrebbero essere già stati scritti sul disco mentre gli aggiornamenti della tabella degli inode o la directory associata non lo sono. È praticamente impossibile implementare un <code>fsck</code> che sia in grado di ripulire il caos risultante (perchè i dati necessari non sono disponibili sul disco). Se il file system è stato danneggiato più del riparabile, la sola scelta è di usare <a href="https://man.freebsd.org/cgi/man.cgi?query=newfs&amp;sektion=8&amp;format=html">newfs(8)</a> per ricrearlo e recuperarlo da un backup.</p></div><div class=paragraph><p>La soluzione comune di questo problema era implementare <em>la registrazione delle regioni sporche</em>, a cui spesso si fa riferimento come <em>journaling</em>, anche se questo termine non viene usato coerentemente e talvolta viene applicato ad altre forme di logging delle transazioni. Gli aggiornamenti dei meta-dati sono ancora scritti in maniera sincrona, ma solo in una piccola regione del disco. In seguito vengono spostati nella posizione appropriata. Poichè l’area di registrazione è una piccola regione contigua sul disco, non ci sono lunghe distanze da percorrere per le testine del disco, anche durante le operazioni pesanti, dunque queste operazioni sono più veloci degli aggiornamenti sincroni. Inoltre la complessità dell’implementazione è piuttosto limitata, dunque il rischio che si presentino dei bug è basso. Uno svantaggio è che tutti i meta-dati vengono scritti due volte (una volta nella regione di logging ed un’altra nella posizione appropriata) e quindi per un lavoro normale si può avere un "peggioramento" delle prestazioni. D’altro canto, in caso di crash, tutte le operazioni sui meta-dati in sospeso possono essere velocemente annullate o recuperate dall’area di registrazione quando il sistema è di nuovo attivo, e come risultato si ha un avvio veloce del file system.</p></div><div class=paragraph><p>Kirk McKusick, lo sviluppatore del Berkeley FFS, ha risolto questo problema con i Soft Update: tutti gli aggiornamenti dei meta-dati vengono tenuti in memoria e vengono scritti su disco in sequenza ordinata ("aggiornamenti ordinati dei meta-dati"). Ciò porta all’effetto che, in caso di operazioni pesanti sui meta-dati, gli ultimi aggiornamenti ad un elemento "recuperano" i precedenti se questi sono ancora in memoria e non sono già stati scritti su disco. Dunque tutte le operazioni, diciamo su una directory, vengono effettuate principalmente in memoria prima che l’aggiornamento sia scritto su disco (i blocchi dei dati vengono ordinati in relazione alla loro posizione, in modo che non vengano scritti su disco prima dei loro meta-dati). Se il sistema va in crash, ciò causa un implicito "riavvolgimento del log": tutte le operazioni che non hanno ancora trovato posto sul disco appariranno come mai effettuate. Viene mantenuto uno stato consistente del file system che sarà quello di 30 o 60 secondi prima. L’algoritmo usato garantisce anche che tutte le risorse in uso siano marcate come tali nelle appropriate tabelle di bit: blocchi e inode. Dopo un crash, il solo errore di allocazione è che vengono marcate come "usate" anche risorse che sono effettivamente "libere". <a href="https://man.freebsd.org/cgi/man.cgi?query=fsck&amp;sektion=8&amp;format=html">fsck(8)</a> riconosce questa situazione, e libera le risorse che non sono più in uso. Non c’è pericolo nell’ignorare lo stato di <em>sporcizia</em> del file system dopo un crash montandolo di forza con <code>mount -f</code>. Per poter liberare le risorse che potrebbero essere non usate, <a href="https://man.freebsd.org/cgi/man.cgi?query=fsck&amp;sektion=8&amp;format=html">fsck(8)</a> ha bisogno di essere avviato in seguito. Questa è l’idea di un <em>fsck in background</em>: all’avvio del sistema, viene registrata solo una <em>immagine</em> del file system. <code>fsck</code> può essere eseguito in seguito. Tutti i file system possono essere montati "sporchi", quindi il processo di avvio del sistema procede in modalità multiutente. In seguito, <code>fsck</code> viene avviato in background su tutti i file system dove è necessario, per liberare le risorse che potrebbero essere inutilizzate. (I file system che non usano i Soft Updates hanno ancora bisogno del solito <code>fsck</code>, comunque.)</p></div><div class=paragraph><p>Il vantaggio è che le operazioni sui meta-dati sono veloci quasi come gli aggiornamenti asincroni (cioè più veloci che con il <em>logging</em>, che deve scrivere i meta-dati due volte). Gli svantaggi sono nella complessità del codice (che implica un maggiore rischio di trovare bug in un’area molto sensibile, essendo legata alla perdita dei dati degli utenti), ed un consumo di memoria maggiore. Inoltre ci sono alcune idiosincrasie alle quali ci si deve abituare. Dopo un crash, lo stato del file system appare in qualche modo "vecchio". In situazioni dove l’approccio sincrono avrebbe causato la permanenza di alcuni file di lunghezza zero dopo un <code>fsck</code>, questi file non esistono affatto con un file system con Soft Update, perchè nè i meta-dati nè i contenuti dei file sono mai stati scritti su disco. Lo spazio su disco non viene rilasciato finchè gli aggiornamenti non sono stati scritti su disco, il che può avvenire qualche tempo dopo che è stato eseguito <code>rm</code>. Questo potrebbe causare problemi durante l’installazione di grandi quantità di dati su un file system che non avesse abbastanza spazio per contenere tutti i file due volte.</p></div></div></div></div></div><div class=sect1><h2 id=configtuning-kernel-limits>11.13. Messa a Punto dei Limiti del Kernel<a class=anchor href=#configtuning-kernel-limits></a></h2><div class=sectionbody><div class=sect2><h3 id=file-process-limits>11.13.1. Limiti dei File/Processi<a class=anchor href=#file-process-limits></a></h3><div class=sect3><h4 id=kern-maxfiles>11.13.1.1. <code>kern.maxfiles</code><a class=anchor href=#kern-maxfiles></a></h4><div class=paragraph><p><code>kern.maxfiles</code> può essere aumentato o abbassato a seconda dei requisiti del tuo sistema. Questa variabile indica il numero massimo di descrittori di file sul tuo sistema. Quando la tabella dei descrittori di file è piena, apparirà ripetutamente la scritta <code>file: table is full</code> nel buffer dei messaggi di sistema, che può essere visualizzato con il comando <code>dmesg</code>.</p></div><div class=paragraph><p>Ogni file, socket, o fifo aperta usa un descrittore di file. Un server di produzione di larga scala può richiedere facilmente molte migliaia di descrittori di file, in relazione al tipo e al numero di servizi in esecuzione insieme.</p></div><div class=paragraph><p>Nelle vecchie release di FreeBSD, il valore predefinito di <code>kern.maxfile</code> viene dettato dall’opzione <code>maxusers</code> nel file di configurazione del kernel. <code>kern.maxfiles</code> cresce proporzionalmente al valore di <code>maxusers</code>. Quando si compila un kernel personalizzato, è una buona idea impostare questa opzione di configurazione del kernel in base agli usi del proprio sistema. Da questo numero, dipendono molti dei limiti predefiniti del kernel. Anche se una macchina in produzione potrebbe non avere effettivamente 256 utenti connessi contemporaneamente, le risorse necessarie potrebbero essere simili a quelle di un server web su larga scala.</p></div><div class=paragraph><p>A partire da FreeBSD 4.5, <code>kern.maxusers</code> è automaticamente dimensionato sulla base della memoria disponibile nel sistema, e può essere determinato a run-time leggendo il valore del sysctl read-only <code>kern.maxusers</code>. Alcuni siti richiedono valori minori o maggiori di <code>kern.maxusers</code> e questo può essere impostato come un parametro modificabile dal loader; valori di 64, 128 o 256 non sono fuori dal comune. Non raccomandiamo di andare oltre i 256 a meno che non si necessiti di un numero esagerato di file descriptor; molti dei valori modificati nel loro default da <code>kern.maxusers</code> possono essere singolarmente sovrascritti a boot-time o a run-time in <span class=filename>/boot/loader.conf</span> (leggi la pagina di manuale <a href="https://man.freebsd.org/cgi/man.cgi?query=loader.conf&amp;sektion=5&amp;format=html">loader.conf(5)</a> o il file <span class=filename>/boot/defaults/loader.conf</span> per alcuni suggerimenti) o come descritto altrove in questo documento. Sistemi precedenti a FreeBSD 4.4 devono invece impostare questo valore attraverso l’opzione di <a href="https://man.freebsd.org/cgi/man.cgi?query=config&amp;sektion=8&amp;format=html">config(8)</a> <code>maxusers</code>.</p></div><div class=paragraph><p>Nelle release precedenti, il sistema setterà in modo automatico <code>maxusers</code> se lo imposti a <code>0</code>. Quando usi quest’opzione, impostalo almeno a 4, specialmente se stai usando il sistema a finestre X o se compili software. Questo è dovuto al fatto che la tabella più importante settata da <code>maxusers</code> è quella relativa al numero massimo di processi, risultato di <code>20 + 16 * maxusers</code>, e quindi se setti <code>maxusers</code> a 1, puoi avere solo 36 processi in modo simultaneo, inclusi i 18 o più di avvio del sistema e i 15 o più che verranno creati all’avvio del sistema a finestre X. Perfino una semplice attività come la lettura di una pagina man avvia fino a 9 processi per filtrare, decomprimere, e visualizzare la pagina. Settando <code>maxusers</code> a 64 avrai fino a 1044 processi simultanei, che dovrebbero essere sufficienti per quasi tutti gli utenti. Ad ogni modo, se vedi il temuto errore quando tenti di avviare un programma, o se stai usando un server con molti utenti simultanei (come <code>ftp.FreeBSD.org</code>), puoi sempre incrementare il numero e ricompilare.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p><code>maxusers</code> <em>non</em> limita il numero degli utenti che possono loggarsi sulla tua macchina. Semplicemente setta la dimensione di alcune tabelle a un valore ragionevole considerando il numero massimo di utenti che probabilmente avrai sul tuo sistema e quanti processi ognuno di loro avranno in esecuzione. Un’opzione che limita il numero di login remoti simultanei e di terminali windows è <a href=../kernelconfig/#kernelconfig-ptys><code>pseudo-device pty 16</code></a>. Con FreeBSD 5.X, non ti devi preoccupare di questo numero poichè il driver <a href="https://man.freebsd.org/cgi/man.cgi?query=pty&amp;sektion=4&amp;format=html">pty(4)</a> è "auto-cloning"; semplicemente usa la linea <code>device pty</code> nel tuo file di configurazione.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=_kern_ipc_somaxconn>11.13.1.2. <code>kern.ipc.somaxconn</code><a class=anchor href=#_kern_ipc_somaxconn></a></h4><div class=paragraph><p>La variabile sysctl <code>kern.ipc.somaxconn</code> limita la dimensione della coda in ascolto per le connessioni TCP. Il valore predefinito è di <code>128</code>, generalmente troppo basso per una gestione robusta di nuove connessioni in ambienti come i web server molto carichi. Per tali ambienti, è consigliato aumentare questo valore a <code>1024</code> o maggiore. Il demone di servizio può a sua volta limitare la dimensione della coda (e.g. <a href="https://man.freebsd.org/cgi/man.cgi?query=sendmail&amp;sektion=8&amp;format=html">sendmail(8)</a>, o Apache) ma spesso avrà una direttiva nel proprio file di configurazione per correggere la dimensione della coda. Grosse code di ascolto aiutano anche ad evitare attacchi di tipo Denial of Service ().</p></div></div></div><div class=sect2><h3 id=nmbclusters>11.13.2. Limiti di Rete<a class=anchor href=#nmbclusters></a></h3><div class=paragraph><p>L’opzione di configurazione del kernel <code>NMBCLUSTERS</code> decide la quantità di Mbuf di rete disponibili al sistema. Un server molto trafficato con un numero basso di Mbuf ostacolerebbe le possibilità di FreeBSD. Ogni cluster rappresenta approssimativamente 2 K di memoria, dunque un valore di 1024 rappresenta 2 megabyte di memoria del kernel riservata per i buffer di rete. Può essere effettuato un semplice calcolo per capire quanti ne siano necessari. Se hai un web server che arriva al massimo a 1000 connessioni simultanee, ed ogni connessione consuma un buffer di 16 K in ricezione e un altro di 16 K in trasmissione, avrai bisogno approssimativamente di 32 MB di buffer di rete per coprire il web server. Una buona regola generale è di moltiplicare per 2, dunque 2x32 MB / 2 KB = 64 MB / 2 KB = 32768. Consigliamo valori compresi tra 4096 e 32768 per macchine con grandi quantità di memoria. In nessun caso dovreste specificare un valore alto arbitrario per questo parametro, poichè potrebbe portare ad un crash all’avvio. L’opzione <code>-m</code> di <a href="https://man.freebsd.org/cgi/man.cgi?query=netstat&amp;sektion=1&amp;format=html">netstat(1)</a> può essere usata per osservare l’uso della rete.</p></div><div class=paragraph><p>L’opzione del loader <code>kern.ipc.nmbclusters</code> può essere usata per impostare questi valori all’avvio. Solo versioni vecchie di FreeBSD richiedono l’uso dell’opzione <code>NMBCLUSTERS</code> come configurazione del kernel (<a href="https://man.freebsd.org/cgi/man.cgi?query=config&amp;sektion=8&amp;format=html">config(8)</a>).</p></div><div class=paragraph><p>Per server sotto carico che fanno un uso massiccio della chiamata di sistema <a href="https://man.freebsd.org/cgi/man.cgi?query=sendfile&amp;sektion=2&amp;format=html">sendfile(2)</a>, potrebbe essere necessario aumentare il numero di buffer <a href="https://man.freebsd.org/cgi/man.cgi?query=sendfile&amp;sektion=2&amp;format=html">sendfile(2)</a> tramite l’opzione di configurazione del kernel <code>NSFBUFS</code> o impostando il suo valore in <span class=filename>/boot/loader.conf</span> (vedere <a href="https://man.freebsd.org/cgi/man.cgi?query=loader&amp;sektion=8&amp;format=html">loader(8)</a> per maggiori dettagli). Un indicatore comune che questo parametro deve essere corretto è la comparsa di processi nello stato <code>sfbufa</code>. La variabile sysctl <code>kern.ipc.nsfbufs</code> è solo un riferimento read-only alla variabile configurata nel kernel. Questo parametro aumenta nominalmente con <code>kern.maxusers</code>, in ogni caso potrebbe essere necessario effettuare piccole correzioni per farli concordare.</p></div><div class="admonitionblock important"><table><tbody><tr><td class=icon><i class="fa icon-important" title=Important></i></td><td class=content><div class=paragraph><p>Anche se un socket è stato segnalato come non-bloccante, richiamando <a href="https://man.freebsd.org/cgi/man.cgi?query=sendfile&amp;sektion=2&amp;format=html">sendfile(2)</a> su di esso si potrebbe avere un blocco della chiamata <a href="https://man.freebsd.org/cgi/man.cgi?query=sendfile&amp;sektion=2&amp;format=html">sendfile(2)</a> fino a quando non sono disponibili delle <code>struct sf_buf</code>.</p></div></td></tr></tbody></table></div><div class=sect3><h4 id=_net_inet_ip_portrange>11.13.2.1. <code>net.inet.ip.portrange.*</code><a class=anchor href=#_net_inet_ip_portrange></a></h4><div class=paragraph><p>La variabili sysctl <code>net.inet.ip.portrange.*</code> controllano i numeri di porta automaticamente assegnate a socket TCP ed UDP. Ci sono tre intervalli: uno basso, uno predefinito, ed uno alto. La maggior parte dei programmi usa l’intervallo predefinito che è controllato da <code>net.inet.ip.portrange.first</code> e <code>net.inet.ip.portrange.last</code>, che hanno valori predefiniti di 1024 e 5000. Questi intervalli sono usati per le connessioni in uscita, ed è possibile che il sistema esaurisca le porte in alcune circostanze. Ciò accade per lo più quando avete un web proxy molto carico. L’intervallo di porte non è un problema quando si usano server che abbiano per lo più connessioni in ingresso, come i normali web server, o un numero limitato di connessioni in uscita, come i relay di posta. Per situazioni nelle quali potreste terminare le porte, è consigliato aumentare leggermente <code>net.inet.ip.portrange.last</code>. Un valore di <code>10000</code>, <code>20000</code> o <code>30000</code> può essere ragionevole. Dovreste anche considerare gli effetti relativi ad un firewall nel cambiare il range di porte. Alcuni firewall potrebbero bloccare grandi intervalli di porte (tipicamente le porte basse) ed aspettarsi che i sistemi usino porte più alte per le connessioni in uscita - per questa ragione si consiglia di non abbassare il valore di <code>net.inet.ip.portrange.first</code>.</p></div></div><div class=sect3><h4 id=_prodotto_del_ritardo_di_banda_tcp>11.13.2.2. Prodotto del Ritardo di Banda TCP<a class=anchor href=#_prodotto_del_ritardo_di_banda_tcp></a></h4><div class=paragraph><p>Il limite del Prodotto del Ritardo di Banda TCP è simile a TCP/Vegas in NetBSD. Può essere abilitato impostando la variabile sysctl <code>net.inet.tcp.inflight_enable</code> ad <code>1</code>. Il sistema tenterà di calcolare il prodotto del ritardo di banda per ogni connessione e limiterà l’ammontare di dati accodati per la trasmissione su rete al livello migliore per garantire il massimo throughput.</p></div><div class=paragraph><p>Questa funzionalità è utile quando si inviano dati su modem multipli, su Ethernet Gigabit, o su collegamenti WAN ad alta velocità (o qualsiasi altro collegamento con un alto prodotto a banda di ritardo), in particolar modo se state usando anche il window scaling o se avete configurato una finestra TCP molto ampia. Se abilitate questa opzione, dovreste anche assicurarvi di impostare a <code>0 net.inet.tcp.inflight_debug</code> (per disabilitare il debugging), e per un uso di produzione può essere utile impostare <code>net.inet.tcp.inflight_min</code> ad almeno <code>6144</code>. Notate comunque che impostando dei livelli minimi alti può in pratica disabilitare la limitazione di banda, su alcuni tipi di collegamento. La funzionalità di limitazione della banda riduce la quantità di dati creati in rotte intermedie e fa circolare le code di pacchetti così come riduce la quantità di dati creati nella coda di interfaccia dell’host locale. Con meno pacchetti accodati, le connessioni interattive, specialmente sopra modem lenti, opereranno con lenti <em>Round Trip Times</em> (tempi di andata e ritorno). Comunque, nota che questa feature ha effetto solo sulla trasmissione dati (uploading / lato server). Non ha effetto sulla ricezione (downloading).</p></div><div class=paragraph><p>Modificare <code>net.inet.tcp.inflight.stab</code> non è raccomandato. Questo parametro è di default a 20, rappresentando 2 pacchetti massimi aggiunti al ritardo del prodotto della banda della finestra. La finestra addizionale è richiesta per stabilizzare l’algoritmo e migliorare la risposta alle condizioni che cambiano ma può risultare in tempi lunghi sui ping sopra link lenti (anche se molto più lento di quello che otterresti senza l’algoritmo di inflight). In questi casi, puoi voler ridurre questo parametro a 15, 10 o 5; e puoi anche ridurre <code>net.inet.tcp.inflight.min</code> (per esempio, a 3500) per ottenere l’effetto desiderato. Ridurre questi parametri dovrebbe essere fatto solo come ultima spiaggia.</p></div></div></div><div class=sect2><h3 id=_memoria_virtuale>11.13.3. Memoria Virtuale<a class=anchor href=#_memoria_virtuale></a></h3><div class=sect3><h4 id=_kern_maxvnodes>11.13.3.1. <code>kern.maxvnodes</code><a class=anchor href=#_kern_maxvnodes></a></h4><div class=paragraph><p>Un vnode è la rappresentazione di un file o una directory. Aumentare il numero di vnodi disponibili sul sistema operativo aumenterà l’I/O di disco. Normalmente questo viene gestito dal sistema operativo e non deve essere cambiato. In pochi casi dove l’I/O di disco è un collo di bottiglia ed il sistema sta finendo i suoi vnodi, questo parametro sarà aumentato. L’aumento di RAM libera ed inattiva sarà tenuto in conto.</p></div><div class=paragraph><p>Per vedere il numero corrente di vnodi in uso:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl vfs.numvnodes</span>
vfs.numvnodes: 91349</code></pre></div></div><div class=paragraph><p>Per vedere il numero massimo di vnodi:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl kern.maxvnodes</span>
kern.maxvnodes: 100000</code></pre></div></div><div class=paragraph><p>Se l’uso del nodo corrente è vicino alla fine, aumentare <code>kern.maxvnodes</code> di un valore di 1.000 è probabilmente una buona idea. Tenete un occhio sul numero di <code>vfs.numvnodes</code>. Se scala al massimo, <code>kern.maxvnodes</code> dovrà essere incrementato ancora. Dovrebbe essere visibile con <a href="https://man.freebsd.org/cgi/man.cgi?query=top&amp;sektion=1&amp;format=html">top(1)</a> uno spostamento nell’uso della memoria. Molta memoria dovrebbe essere attiva.</p></div></div></div></div></div><div class=sect1><h2 id=adding-swap-space>11.14. Aggiunta di Spazio di Swap<a class=anchor href=#adding-swap-space></a></h2><div class=sectionbody><div class=paragraph><p>Non importa con quanta cura pianifichi tutto, a volte un sistema non funziona come ti aspetti. Se ti trovi ad avere bisogno di maggiore spazio di swap, è abbastanza semplice aggiungerlo. Ci sono tre modi per aumentare lo spazio di swap: aggiungere un nuovo disco rigido, abilitare lo swap su NFS, e creare un file di swap su una partizione esistente.</p></div><div class=paragraph><p>Per informazioni su come criptare lo spazio di swap, quali opzioni esistono e perchè dovrebbe essere fatto, vedere la sezione swap-encrypting del Manuale.</p></div><div class=sect2><h3 id=new-drive-swap>11.14.1. Swap su un Nuovo Disco Rigido<a class=anchor href=#new-drive-swap></a></h3><div class=paragraph><p>Il modo migliore per aggiungere dello swap, ovviamente, è usare questa come scusa per aggiungere un altro disco rigido. Puoi sempre aggiungere un nuovo disco, dopo tutto. Se puoi fare così, vai a rileggere la discussione sullo spazio di swap nella <a href=#configtuning-initial>Configurazione Iniziale</a> del Manuale per alcuni suggerimenti su come organizzare al meglio lo spazio di swap.</p></div></div><div class=sect2><h3 id=nfs-swap>11.14.2. Swap su NFS<a class=anchor href=#nfs-swap></a></h3><div class=paragraph><p>Lo swap su NFS è consigliato solo se non hai un disco locale su cui realizzare lo swap. Lo swap via NFS è limitato dalla larghezza di banda disponibile sulla rete e aggiunge ulteriore lavoro per il server NFS.</p></div></div><div class=sect2><h3 id=create-swapfile>11.14.3. File di Swap<a class=anchor href=#create-swapfile></a></h3><div class=paragraph><p>Puoi creare un file delle dimensioni specifiche per usarlo come file di swap. In questo nostro esempio useremo un file di 64MB chiamato <span class=filename>/usr/swap0</span>. Puoi usare qualsiasi nome vuoi, ovviamente.</p></div><div class=exampleblock><div class=title>Esempio 1. Creare un file di Swap su FreeBSD</div><div class=content><div class="olist arabic"><ol class=arabic><li><p>Accertati che il tuo file di configurazione del kernel includa il memory disk driver (<a href="https://man.freebsd.org/cgi/man.cgi?query=md&amp;sektion=4&amp;format=html">md(4)</a>). È di default nel kernel <span class=filename>GENERIC</span>.</p><div class="literalblock programlisting"><div class=content><pre>device   md   # Memory &#34;disks&#34;</pre></div></div></li><li><p>Crea un file di swap (<span class=filename>/usr/swap0</span>):</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dd if=/dev/zero of=/usr/swap0 bs=1024k count=64</span></code></pre></div></div></li><li><p>Imposta i permessi appropriati su (<span class=filename>/usr/swap0</span>):</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># chmod 0600 /usr/swap0</span></code></pre></div></div></li><li><p>Riavvia la macchina o per abilitare il file di swap immediatamente scrivi:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mdconfig -a -t vnode -f /usr/swap0 -u 0 &amp;&amp; swapon /dev/md0</span></code></pre></div></div></li></ol></div></div></div></div></div></div><div class=sect1><h2 id=acpi-overview>11.15. Gestione dell’Energia e delle Risorse<a class=anchor href=#acpi-overview></a></h2><div class=sectionbody><div class=paragraph><p>È importante utilizzare le risorse hardware in maniera efficiente. Prima che ACPI fosse introdotto era difficile e per nulla flessibile per il sistema operativo gestire l’energia e le proprietà termiche del sistema. L’hardware era controllato dal BIOS e quindi l’utente aveva meno controllo e visibilità per il settaggio della gestione dell’energia. Una configurazione limitata era disponibile tramite <em>Advanced Power Management (APM)</em>. La gestione dell’energia e delle risorse è uno dei concetti fondamentali di un moderno sistema operativo. Per esempio, puoi far sì che un sistema operativo faccia il monitoraggio dei limiti di sistema (e possibilmente ti avvisi) in caso la temperatura del sistema cresca in maniera incontrollata.</p></div><div class=paragraph><p>In questa sezione del Manuale di FreeBSD, ti forniremo informazioni esaustive circa ACPI. Alla fine saranno forniti maggiori riferimenti per ulteriori letture.</p></div><div class=sect2><h3 id=acpi-intro>11.15.1. Cos’è ACPI?<a class=anchor href=#acpi-intro></a></h3><div class=paragraph><p>ACPI (Advanced Configuration and Power Interface) è uno standard scritto da un gruppo di venditori per fornire un’interfaccia standard per risorse hardware e gestione dell’energia (da qui il nome). È un elemento centrale nella <em>configurazione diretta del sistema operativo e nella gestione dell’energia</em>, ad esempio: fornisce più controllo e flessibilità al sistema operativo (OS). I sistemi moderni "stressano" i limiti delle interfacce correnti Plug and Play, prima della introduzione di ACPI. ACPI è il diretto successore di APM (Advanced Power Management).</p></div></div><div class=sect2><h3 id=acpi-old-spec>11.15.2. Riassunto della Gestione Avanzata dell’Energia (APM)<a class=anchor href=#acpi-old-spec></a></h3><div class=paragraph><p>La tecnologia <em>Advanced Power Management (APM)</em> controlla l’uso dell’energia di un sistema basandosi sulla sua attività. Il BIOS APM è fornito dal venditore del sistema ed è specifico alla piattaforma hardware. Un driver APM nell’OS media l’accesso all'<em>Interfaccia Software APM</em> che permette la gestione dei livelli di energia. APM dovrebbe essere usato per sistemi prodotti nel o prima dell’anno 2000.</p></div><div class=paragraph><p>Ci sono quattro problemi maggiori in APM. Primo, la gestione dell’energia è fatta dal BIOS (specifico del venditore) e l’OS non ne ha conoscenza. Un esempio di questo è quando l’utente imposta i valori di pausa per un disco nell’APM BIOS, che quando vengono ecceduti, il BIOS rallenta il disco, senza il consenso dell’OS. Secondo, la logica di APM è integrata nel BIOS, e opera al di fuori lo scopo dell’OS. Questo significa che gli utenti possono riparare i problemi nel loro BIOS APM facendo un flash di una nuova memoria nel ROM; il che è una procedura molto difficile con il pericolo potenziale di lasciare il sistema in uno stato irrecuperabile se fallisce. Terzo, APM è una tecnologia specifica del venditore il che significa che c’è un sacco di duplicazione degli sforzi e bachi trovati nel BIOS di un venditore che non possono essere risolti in altri. In ultima analisi, il BIOS APM non ha abbastanza spazio per implementare una politica sofisticata, o una che può adattarsi molto bene allo scopo della macchina.</p></div><div class=paragraph><p><em>Plug and Play BIOS (PNPBIOS)</em> era inaffidabile in molte situazioni. PNPBIOS era una tecnologia a 16 bit, così il sistema operativo doveva usare l’emulazione a 16 bit per "interfacciarsi" con i metodi PNPBIOS.</p></div><div class=paragraph><p>Il driver APM di FreeBSD è documentato nella pagina di manuale <a href="https://man.freebsd.org/cgi/man.cgi?query=apm&amp;sektion=4&amp;format=html">apm(4)</a>.</p></div></div><div class=sect2><h3 id=acpi-config>11.15.3. Configurare ACPI<a class=anchor href=#acpi-config></a></h3><div class=paragraph><p>Il driver <span class=filename>acpi.ko</span> è caricato di default all’avvio dal <a href="https://man.freebsd.org/cgi/man.cgi?query=loader&amp;sektion=8&amp;format=html">loader(8)</a> e <em>non</em> dovrebbe essere compilato nel kernel. Il ragionamento dietro a questo è che è più facile lavorare coi moduli, ad esempio se si passa ad un altro <span class=filename>acpi.ko</span> senza fare un rebuild del kernel. Questo ha il vantaggio di rendere il testing più facile. Un altro motivo è che avviare ACPI dopo che un sistema è stato riavviato spesso non funziona bene. Se incontri dei problemi, puoi disabilitare completamente ACPI. Questo driver non dovrebbe e non può essere scaricato perchè il bus di sistema lo usa per diverse interazioni hardware. ACPI può essere disabilitato settando <code>hint.acpi.0.disabled="1"</code> in <span class=filename>/boot/loader.conf</span> o al prompt del <a href="https://man.freebsd.org/cgi/man.cgi?query=loader&amp;sektion=8&amp;format=html">loader(8)</a>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>ACPI ed APM non possono coesistere e dovrebbero essere usati separatamente. L’ultimo ad essere caricato terminerà se il driver nota che l’altro è già in funzione.</p></div></td></tr></tbody></table></div><div class=paragraph><p>ACPI può essere usato per mettere il sistema in modalità sleep con <a href="https://man.freebsd.org/cgi/man.cgi?query=acpiconf&amp;sektion=8&amp;format=html">acpiconf(8)</a>, l’opzione <code>-s</code> ed un’opzione <code>1-5</code>. La maggior parte degli utenti avranno bisogno solo di <code>1</code> o <code>3</code> (sospensione della RAM). L’opzione <code>5</code> farà un morbido shutdown che è la stessa azione di:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># halt -p</span></code></pre></div></div><div class=paragraph><p>Sono disponibili altre opzioni via <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a>. Controlla la pagina man di <a href="https://man.freebsd.org/cgi/man.cgi?query=acpi&amp;sektion=4&amp;format=html">acpi(4)</a> e <a href="https://man.freebsd.org/cgi/man.cgi?query=acpiconf&amp;sektion=8&amp;format=html">acpiconf(8)</a> per maggiori informazioni.</p></div></div></div></div><div class=sect1><h2 id=ACPI-debug>11.16. Usare e Debuggare ACPI di FreeBSD<a class=anchor href=#ACPI-debug></a></h2><div class=sectionbody><div class=paragraph><p>ACPI è un modo fondamentalmente nuovo di utilizzare dispositivi, gestire le risorse elettriche, e fornire accesso standardizzato all’hardware gestito precedentemente dal BIOS. Si stanno facendo progressi per far funzionare ACPI su tutti i sistemi, ma continuano ad apparire bachi nel codice del <em>Linguaggio Macchina ACPI</em> (AML), incompletezza nel sottosistema kernel di FreeBSD, e bachi nell’interprete ACPI-CA di Intel®.</p></div><div class=paragraph><p>Questo documento è creato per aiutarti ad assistere i manutentori di ACPI di FreeBSD nell’identificare le cause primarie dei problemi che riscontri e debuggare e sviluppare una soluzione. Grazie per l’attenzione e speriamo di poter risolvere i problemi del tuo sistema.</p></div><div class=sect2><h3 id=ACPI-submitdebug>11.16.1. Fornire Informazione di Debug<a class=anchor href=#ACPI-submitdebug></a></h3><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Prima di sottomettere un problema, accertati di avere in esecuzione l’ultima versione del BIOS e, se disponibile, la versione del firmware del controller integrato.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Per quelli di voi che vogliono sottomettere un problema subito, per favore inviate la seguente informazione a <a href=mailto:freebsd-acpi@FreeBSD.org></a><a href=mailto:freebsd-acpi@FreeBSD.org>freebsd-acpi@FreeBSD.org</a>:</p></div><div class=ulist><ul><li><p>Descrizione del comportamento affetto da bachi, inclusi il tipo di sistema ed il modello e tutto quello che fa sì che il baco appaia. Inoltre, per favore annotati il più accuratamente possibile quando il baco è iniziato ad apparire se è nuovo per il tuo sistema.</p></li><li><p>L’output del comando <a href="https://man.freebsd.org/cgi/man.cgi?query=dmesg&amp;sektion=8&amp;format=html">dmesg(8)</a> dopo <code>boot -v</code>, incluso ogni messaggio di errore generato dal tuo sistema mentre investigavi questo baco.</p></li><li><p>L’output del comando <a href="https://man.freebsd.org/cgi/man.cgi?query=dmesg&amp;sektion=8&amp;format=html">dmesg(8)</a> dopo <code>boot -v</code> con ACPI disabilitato, se disabitarlo ti aiuta a rimettere a posto il sistema.</p></li><li><p>L’output di <code>sysctl hw.acpi</code>. Anche questo è un buon modo di figurarti quali caratteristiche il tuo sistema offre.</p></li><li><p>URL dove il tuo <em>ACPI Source Language</em> (ASL) risiede. <em>Non</em> inviare la ASL direttamente alla lista dato che può essere molto grande. Generate una copia della vostra ASL eseguendo questo comando:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># acpidump -dt &gt; name-system.asl</span></code></pre></div></div><div class=paragraph><p>(Sostituite <em>name</em> con la vostra login ed il modello/manifattura del <em>sistema</em>. Ad esempio <span class=filename>njl-FooCoo6000.asl</span>)</p></div></li></ul></div><div class=paragraph><p>Molti degli sviluppatori seguono la <a href=https://lists.FreeBSD.org/subscription/freebsd-current>mailing list su FreeBSD-CURRENT</a> ma per favore sottomettete i vostri problemi a <a href=https://lists.FreeBSD.org/subscription/freebsd-acpi>mailing list su ACPI in FreeBSD</a> per essere sicuri che siano visti. Per favore siate pazienti, abbiamo tutti lavori full-time altrove. Se i vostri bachi non sono chiarissimi, vi chiederemo di sottomettere un PR attraverso <a href="https://man.freebsd.org/cgi/man.cgi?query=send-pr&amp;sektion=1&amp;format=html">send-pr(1)</a>. Quando si invia un PR, per favore includete le stesse informazioni sopracitate. Questo aiuterà a tracciare il problema e risolverlo. Non inviare un PR senza prima inviare una email a <a href=https://lists.FreeBSD.org/subscription/freebsd-acpi>mailing list su ACPI in FreeBSD</a>, dato che noi usiamo PR come promemoria di problemi esistenti, non come meccanismo di reporting. È probabile che i vostri problemi siano stati riportati da qualcun altro prima.</p></div></div><div class=sect2><h3 id=ACPI-background>11.16.2. Background<a class=anchor href=#ACPI-background></a></h3><div class=paragraph><p>ACPI è presente su tutti i computer moderni che conformi all’architettura ia32(x86), ia64 (Itanium), e amd64 (AMD). L’intero standard ha molte caratteristiche che includono la gestione della performance della CPU, il controllo dei piani energetici, delle zone termiche, delle batterie del sistema, controller incorporati, ed enumerazione dei bus. Molti sistemi implementano meno dello standard completo. Per esempio, un sistema desktop di solito implementa le parti di enumerazione dei bus mentre un laptop potrebbe avere il raffreddamento ed anche il supporto alla gestione della batteria. I laptop hanno anche sospensioni e riavvii, con la loro complessità associata.</p></div><div class=paragraph><p>Un sistema ACPI-compliant ha molte componenti. Il BIOS ed i venditori di chipset forniscono varie tabelle fisse in memoria (ad esempio FADT) che specificano cose come la mappa APIC (usata per SMP), i registri di configurazione, e semplici valori di configurazione. Inoltre viene fornita una tabella di codici di byte (la <em>Differentiated System Description Table</em> DSDT) per specificare uno spazio dei nomi ad albero di dispositivi e metodi.</p></div><div class=paragraph><p>Il driver ACPI deve fare il parse delle tabelle fisse, implementare un interprete per il codice di byte, e modificare i device driver ed il kernel per accettare informazioni dal sottosistema ACPI. Per FreeBSD, Intel® ha fornito un interprete (ACPI-CA) che è condiviso fra Linux e NetBSD. Il path al codice sorgente ACPI-CA è <span class=filename>src/sys/contrib/dev/acpica</span>. Il codice che permette ad ACPI-CA di lavorare con FreeBSD è in <span class=filename>src/sys/dev/acpica/Osd</span>. Finalmente, i driver che implementano vari dispositivi ACPI si trovano in <span class=filename>src/sys/dev/acpica</span>.</p></div></div><div class=sect2><h3 id=ACPI-comprob>11.16.3. Problemi Comuni<a class=anchor href=#ACPI-comprob></a></h3><div class=paragraph><p>Affincè ACPI funzioni correttamente tutte le parti devono funzionare correttamente. Ci sono alcuni problemi comuni, in ordine di frequenza di apparizione, ed alcuni possibili workaround o mezzi per aggiustarli.</p></div><div class=sect3><h4 id=_questioni_di_mouse>11.16.3.1. Questioni di Mouse<a class=anchor href=#_questioni_di_mouse></a></h4><div class=paragraph><p>In alcuni casi, ripartire dopo una operazione di sospensione, fa sì che il mouse non riparta. Un noto workaround è aggiungere <code>hint.psm.0.flags="0x3000"</code> al file <span class=filename>/boot/loader.conf</span>. Se questo non funziona allora per favore considera l’invio di un report del baco come descritto in precedenza.</p></div></div><div class=sect3><h4 id=_sospensioneriavvio>11.16.3.2. Sospensione/Riavvio<a class=anchor href=#_sospensioneriavvio></a></h4><div class=paragraph><p>ACPI ha tre stati di sospensione RAM (STR), <code>S1</code>-<code>S3</code> ed un stato di sospensione disco (<code>STD</code>), chiamato <code>S4</code>. <code>S5</code> è il "soft off" ed è il normale stato in cui il tuo sistema si trova quando è collegato ma non acceso. <code>S4</code> può essere implementato in due modi separati. <code>S4</code>BIOS è una sospensione BIOS-assistita da disco. <code>S4</code>OS è implementato direttamente dal sistema operativo.</p></div><div class=paragraph><p>Inizia a controllare <code>sysctl hw.acpi</code> per le entry relative alla sospensione. Questi sono i risultati per un Thinkpad:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>hw.acpi.supported_sleep_state: S3 S4 S5
hw.acpi.s4bios: 0</code></pre></div></div><div class=paragraph><p>Questo significa che possiamo usare <code>acpiconf -s</code> per testare <code>S3</code>, <code>S4</code>OS, <code>S5</code>. Se <code>s4bios</code> fosse stato uno (<code>1</code>), avremmo supporto a <code>S4</code>BIOS invece di <code>S4</code>OS.</p></div><div class=paragraph><p>Quando si testa la sospensione/riavvio, inizia con <code>S1</code>, se supportato. È più probabile che funzioni questo stato dato che non richiede molto supporto dal driver. Nessuno ha implementato <code>S2</code>, ma se tu lo hai, è simile a <code>S1</code>. La prossima cosa da provare è <code>S3</code>. Questo è lo stato più profondo STR e richiede molto supporto dal driver per reinizializzare il tuo hardware. Se hai problemi a riavviarlo, sentiti libero di segnalarlo via mail alla lista <a href=https://lists.FreeBSD.org/subscription/freebsd-acpi>mailing list su ACPI in FreeBSD</a> ma non aspettarti che il problema sia risolto dato che ci sono molti driver/hardware che hanno bisogno di test e di lavoro aggiuntivo.</p></div><div class=paragraph><p>Per aiutare ad isolare il problema, rimuovi quanti più driver possibile dal tuo kernel. Se funziona, puoi scoprire quale driver causa il problema caricando dei driver fino a che il problema si ripresenta. Tipicamente i driver binari come <span class=filename>nvidia.ko</span>, i driver di display di X11, e USB avranno la maggior parte dei problemi mentre interfacce Ethernet funzioneranno bene. Se puoi caricare/scaricare driver correttamente, puoi automatizzare questo piazzando i comandi appropriati in <span class=filename>/etc/rc.suspend</span> e <span class=filename>/etc/rc.resume</span>. C’è un esempio commentato su come caricare e scaricare un driver. Prova a impostare <code>hw.acpi.reset_video</code> a zero (<code>0</code>) se il tuo display è confuso dopo il riavvio. Prova a impostare valori più lunghi o corti per <code>hw.acpi.sleep_delay</code> per vedere se aiuta.</p></div><div class=paragraph><p>Un’altra cosa da provare è caricare una distribuzione Linux recente con supporto ACPI e testare il loro supporto sospensione/riavvio sullo stesso hardware. Se funziona su Linux, è probabile che sia un problema driver relativo a FreeBSD e restringere il campo di indagine su quale driver causi il problema può aiutare a risolvere il problema. Notate che i manutentori di ACPI non mantengono altri driver (ad esempio suono, ATA, etc.) così ogni lavoro fatto sull’identificazione del problema del driver dovrebbe alla fine essere risolto dalla lista <a href=https://lists.FreeBSD.org/subscription/freebsd-current>mailing list su FreeBSD-CURRENT</a> e inviato via mail al manutentore del driver. Se ti senti avventuroso, vai avanti e inizia a porre qualche <a href="https://man.freebsd.org/cgi/man.cgi?query=printf&amp;sektion=3&amp;format=html">printf(3)</a> in un driver che dà problemi per tracciare in quale driver nella sua funzione di resume vada in palla.</p></div><div class=paragraph><p>Alla fine, cerca di disabilitare ACPI ed ad abilitare APM invece. Se la sospensione ed il riavvio funziona con APM, è meglio che tu continui con APM, specialmente su hardware vecchio (pre-2000). Ci vuole un pò di tempo per i venditori per ottenere un supporto corretto all’ACPI e l’hardware più vecchio è più probabile che abbia problemi BIOS con ACPI.</p></div></div><div class=sect3><h4 id=_blocco_del_sistema_temporanea_o_permanente>11.16.3.3. Blocco del Sistema (temporanea o permanente)<a class=anchor href=#_blocco_del_sistema_temporanea_o_permanente></a></h4><div class=paragraph><p>La maggior parte dei blocchisono causati da interrupt persi o da una tempesta di interrupt. I chipset hanno un sacco di problemi su come il BIOS configuri gli interrupt prima del boot, la correttezza delle tabelle ACPI (MADT) ed il routing del <em>System Control Interrupt</em> (SCI).</p></div><div class=paragraph><p>Le tempeste di interrupt possono essere distinte da interrupt persi controllando l’output di <code>vmstat -i</code> e guardando alla linea che riguarda <code>acpi0</code>. Se il contatore sta avanzando più di un paio di secondi per volta, hai una tempesta di interrupt. Se il sistema si blocca, cerca di di entrare in DDB (<span class=keyseq><kbd>CTRL</kbd>+<kbd>ALT</kbd>+<kbd>ESC</kbd></span> sulla console) e digita <code>show interrupts</code>.</p></div><div class=paragraph><p>Il modo migliore in caso di problemi di interrupt è provare a disabilitare il supporto APIC con <code>hint.apic.0.disabled="1"</code> in <span class=filename>loader.conf</span>.</p></div></div><div class=sect3><h4 id=_panici>11.16.3.4. Panici<a class=anchor href=#_panici></a></h4><div class=paragraph><p>I panici sono relativamente rari per ACPI e sono il primo problema ad essere corretto. Il primo passo da fare è riprodurre il panico (se possibile) ed ottenere un backtrace. Segui l’avvertimento per abilitare <code>options DDB</code> e imposta una console seriale (vedi la <a href=../serialcomms/#serialconsole-ddb>Accesso al Debugger DDB dalla Linea Seriale</a>) o imposta una partizione di <a href="https://man.freebsd.org/cgi/man.cgi?query=dump&amp;sektion=8&amp;format=html">dump(8)</a>. Puoi ottenere un backtrace in DDB con <code>tr</code>. Se hai scritto a mano il backtrace, accertati di ottenere le ultime cinque (5) e le prime cinque (5) linee nella traccia.</p></div><div class=paragraph><p>Poi, prova ad isolare il problema facendo boot con ACPI disabilitato. Se funziona, puoi isolare il sottosistema ACPI usando vari valori di <code>debug.acpi.disable</code>. Leggi la pagina di manuale di <a href="https://man.freebsd.org/cgi/man.cgi?query=acpi&amp;sektion=4&amp;format=html">acpi(4)</a> per alcuni esempi.</p></div></div><div class=sect3><h4 id=_riavvii_di_sistema_dopo_sospensioni_o_spegnimenti>11.16.3.5. Riavvii di sistema dopo Sospensioni o Spegnimenti<a class=anchor href=#_riavvii_di_sistema_dopo_sospensioni_o_spegnimenti></a></h4><div class=paragraph><p>Prima, cerca di impostare <code>hw.acpi.disable_on_poweroff="0"</code> in <a href="https://man.freebsd.org/cgi/man.cgi?query=loader.conf&amp;sektion=5&amp;format=html">loader.conf(5)</a>. Questo fa sì che ACPI abbia disabilitato alcuni eventi durante il processo di shutdown. Alcuni sistemi hanno bisogno di impostare questo valore a <code>1</code> (il default) per la stessa ragione. Questo di solito aggiusta il problema di un sistema che si accende spontaneamente dopo una sospensione o uno spegnimento.</p></div></div><div class=sect3><h4 id=_altri_problemi>11.16.3.6. Altri problemi<a class=anchor href=#_altri_problemi></a></h4><div class=paragraph><p>Se hai altri problemi con ACPI (lavorare con un docking station, dispositivi non trovati, ecc.), per favore invia via mail una descrizione anche alla mailing list; comunque, alcune di queste questioni possono essere correlate a parti del sottosistema ACPI così può volerci un pò prima che siano implementate. Per favore sii paziente e preparato a testare le patch che ti vengono inviate.</p></div></div></div><div class=sect2><h3 id=ACPI-aslanddump>11.16.4. ASL, <code>acpidump</code>, e IASL<a class=anchor href=#ACPI-aslanddump></a></h3><div class=paragraph><p>Il più comune problema è il BIOS di venditori che forniscono bytecode incorretto (o addirittura con bachi). Questo si deduce usualmente da messaggi del kernel come questo:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>ACPI-1287: <span class=k>***</span> Error: Method execution failed <span class=o>[</span><span class=se>\\</span>_SB_.PCI0.LPC0.FIGD._STA] <span class=se>\\</span>
<span class=o>(</span>Node 0xc3f6d160<span class=o>)</span>, AE_NOT_FOUND</code></pre></div></div><div class=paragraph><p>Spesso puoi risolvere questi problemi aggiornando il tuo BIOS all’ultima versione. La maggior parte dei messaggi di console non indica nulla di notevole, ma se hai altri problemi come lo stato della batteria non funzionante, questi sono un buon inizio per iniziare a cercare problemi in AML. Il bytecode, noto come AML, è compilato da un insieme di codici sorgenti chiamato ASL. L’AML, è trovato nella tabella nota come come DSDT. Per trovare una copia del tuo ASL usa <a href="https://man.freebsd.org/cgi/man.cgi?query=acpidump&amp;sektion=8&amp;format=html">acpidump(8)</a>. Dovresti usare entrambe le opzioni <code>-t</code> (mostra i contenuti della tabella fissa) e la <code>-d</code> (disassembla AML ad ASL). Vedi la sezione <a href=#ACPI-submitdebug>Fornire Informazione di Debug</a> per un esempio della sintassi.</p></div><div class=paragraph><p>Il tuo primo controllo che puoi fare è ricompilare il tuo ASL per controllare errori. Possono essere ignorati i 'warning' ma gli errori sono bachi che impediranno all’ACPI di funzionare correttamente. Per ricompilare il tuo ASL, usa il comando seguente:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># iasl your.asl</span></code></pre></div></div></div><div class=sect2><h3 id=ACPI-fixasl>11.16.5. Aggiustare il tuo ASL<a class=anchor href=#ACPI-fixasl></a></h3><div class=paragraph><p>Alla lunga, il nostro obiettivo è avere ACPI che funzioni per tutti senza intervento. A questo punto, comunque stiamo ancora sviluppando workaround per errori comuni fatti dal venditore del BIOS. L’interprete Microsoft® (<span class=filename>acpi.sys</span> e <span class=filename>acpiec.sys</span>) non è strettamente conforme agli standard, e così molti venditori BIOS che testano solo ACPI sotto Windows® non aggiustano mai il loro ASL. Vogliamo continuare a identificare e documentare esattamente quali comportamenti non standard sono concessi dall’interprete Microsoft® e replicarlo cosicchè FreeBSD può funzionare senza forzare gli utenti ad usare ASL. Come workaround e per aiutarci ad identificare il comportamento puoi fissare la ASL manualmente. Se questo funziona per favore invia un <a href="https://man.freebsd.org/cgi/man.cgi?query=diff&amp;sektion=1&amp;format=html">diff(1)</a> del vecchio e del nuovo ASL, cosicchè possiamo lavorare attorno al comportamento bacato di ACPI-CA e così rimettere a posto il necessario.</p></div><div class=paragraph><p>Qui c’è una lista di messaggi di errori comuni, le loro cause e come fissarli:</p></div><div class=sect3><h4 id=_dipendenze_os>11.16.5.1. Dipendenze OS<a class=anchor href=#_dipendenze_os></a></h4><div class=paragraph><p>Alcuni AML assumono che il mondo consiste di varie versioni Windows®. Puoi far sì che FreeBSD simuli qualsiasi OS per vedere se questo risolve il problema che hai. Un modo facile per sovrascrivere questo è porre <code>hw.acpi.osname="Windows 2001"</code> in <span class=filename>/boot/loader.conf</span> o altre stringhe simili che trovi nella ASL.</p></div></div><div class=sect3><h4 id=_valori_di_ritorno_mancanti>11.16.5.2. Valori di Ritorno Mancanti<a class=anchor href=#_valori_di_ritorno_mancanti></a></h4><div class=paragraph><p>Alcuni metodi non ritornano esplicitamente un valore come i requisiti standard. Mentre ACPI-CA non gestisce questo, FreeBSD ha un workaround che permette di ritornare i valori implicitamente. Puoi anche aggiungere espliciti Valori di Ritorno dove si richiede se sai quale valore dovrebbe essere ritornato. Per forzare <code>iasl</code> a compilare l’ASL usa il flag <code>-f</code>.</p></div></div><div class=sect3><h4 id=_sovrascrivere_il_default_aml>11.16.5.3. Sovrascrivere il Default AML<a class=anchor href=#_sovrascrivere_il_default_aml></a></h4><div class=paragraph><p>Dopo che personalizzi il tuo <span class=filename>your.asl</span>, potresti volerlo compilare, esegui:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># iasl your.asl</span></code></pre></div></div><div class=paragraph><p>Puoi aggiungere il flag <code>-f</code> per forzare la creazione dell’AML, anche se ci sono errori durante la compilazione. Ricorda che alcuni errori (ad esempio valori di Ritorno mancanti) sono automaticamente riaggiustati dall’interprete.</p></div><div class=paragraph><p><span class=filename>DSDT.aml</span> è il nome del file di default del comando <code>iasl</code>. Puoi caricare questo invece della copia difettosa del tuo BIOS (che è ancora presente in memoria) editando il file <span class=filename>/boot/loader.conf</span> come segue:</p></div><div class="literalblock programlisting"><div class=content><pre>acpi_dsdt_load=&#34;YES&#34;
acpi_dsdt_name=&#34;/boot/DSDT.aml&#34;</pre></div></div><div class=paragraph><p>Assicurati di copiare il tuo file <span class=filename>DSDT.aml</span> nella directory <span class=filename>/boot</span>.</p></div></div></div><div class=sect2><h3 id=ACPI-debugpoint>11.16.6. Ottenere Output di Debug da ACPI<a class=anchor href=#ACPI-debugpoint></a></h3><div class=paragraph><p>Il driver ACPI ha una facility di debug molto utile. Permette di specificare un insieme di sottosistemi come anche un livello di verbosità. I sottosistemi che desideri debuggare sono specificati come "strati" e sono divisi in componenti ACPI-CA (ACPI_ALL_COMPONENTS) e supporto hardware ACPI (ACPI_ALL_DRIVERS). La verbosità dell’output di debug è specificata come "livello" e varia da ACPI_LV_ERROR (riporta solo gli errori) ad ACIP_LV_VERBOSE (tutto). Il "livello" è una bitmask che fa sì che molte opzioni possano essere impostate una alla volta, separate da spazi. In pratica, puoi usare una console seriale per loggare l’output se è così lungo da riempire il buffer di messaggi della console. Una lista completa degli strati individuali e dei livelli è disponibile nella pagina man <a href="https://man.freebsd.org/cgi/man.cgi?query=acpi&amp;sektion=4&amp;format=html">acpi(4)</a>.</p></div><div class=paragraph><p>L’output di debug non è abilitato di default. Per abilitarlo, aggiungi <code>options ACPI_DEBUG</code> al tuo file di configurazione del kernel se ACPI è compilato nel kernel. Puoi aggiungere <code>ACPI_DEBUG=1</code> al tuo <span class=filename>/etc/make.conf</span> per abilitarlo in modo globale. Se è un modulo, puoi ricompilare soltanto il tuo modulo <span class=filename>acpi.ko</span> come segue:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /sys/modules/acpi/acpi</span>
<span class=o>&amp;&amp;</span> make clean <span class=o>&amp;&amp;</span>
make <span class=nv>ACPI_DEBUG</span><span class=o>=</span>1</code></pre></div></div><div class=paragraph><p>Installa <span class=filename>acpi.ko</span> in <span class=filename>/boot/kernel</span> ed aggiungi il tuo livello desiderato e gli strati in <span class=filename>loader.conf</span>. Questo esempio abilita i messaggi per tutti i componenti ACPI-CA e tutti i driver hardware ACPI (CPU, LID, etc.). Produrrà solo messaggi di errore, i meno verbosi.</p></div><div class="literalblock programlisting"><div class=content><pre>debug.acpi.layer=&#34;ACPI_ALL_COMPONENENTS ACPI_ALL_DRIVERS&#34;
debug.acpi.level=&#34;ACPI_LV_ERROR&#34;</pre></div></div><div class=paragraph><p>Se l’informazione che vuoi ottenere è prodotta da un evento specifico (ad esempio, una sospensione ed un riavvio), puoi tralasciare i cambiamenti di <span class=filename>loader.conf</span> ed invece usare <code>sysctl</code> per specificare lo strato ed il livello dopo il boot e preparare il tuo sistema per l’evento specifico. I <code>sysctl</code> sono nominati allo stesso modo dei parametri in <span class=filename>loader.conf</span>.</p></div></div><div class=sect2><h3 id=ACPI-References>11.16.7. Riferimenti<a class=anchor href=#ACPI-References></a></h3><div class=paragraph><p>Maggiori informazioni su ACPI possono essere trovate nei seguenti posti:</p></div><div class=ulist><ul><li><p>La <a href=https://lists.FreeBSD.org/subscription/freebsd-acpi>mailing list su ACPI in FreeBSD</a></p></li><li><p>Gli archivi della mailing list ACPI <a href=http://lists.freebsd.org/pipermail/freebsd-acpi/>http://lists.freebsd.org/pipermail/freebsd-acpi/</a></p></li><li><p>I vecchi archivi della mailing list ACPI <a href=http://home.jp.FreeBSD.org/mail-list/acpi-jp/>http://home.jp.FreeBSD.org/mail-list/acpi-jp/</a></p></li><li><p>La <a href=https://uefi.org/specifications#ACPI>specificazione ACPI</a></p></li><li><p>Le pagine man di FreeBSD: <a href="https://man.freebsd.org/cgi/man.cgi?query=acpi&amp;sektion=4&amp;format=html">acpi(4)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=acpi_thermal&amp;sektion=4&amp;format=html">acpi_thermal(4)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=acpidump&amp;sektion=8&amp;format=html">acpidump(8)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=iasl&amp;sektion=8&amp;format=html">iasl(8)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=acpidb&amp;sektion=8&amp;format=html">acpidb(8)</a></p></li><li><p><a href=http://www.cpqlinux.com/acpi-howto.html#fix_broken_dsdt>Le risorse di debugging di DSDT</a>. (Usa Compaq come esempio ma è sempre utile.)</p></li></ul></div></div></div></div></div><hr><div class=last-modified><p><strong>Ultima modifica</strong>: 9 marzo 2024 da <a href="https://cgit.freebsd.org/doc/commit/?id=6199af92e7" target=_blank>Danilo G. Baio</a></p></div><div class=buttons><div class=prev><i class="fa fa-angle-left" aria-hidden=true title=Precedente></i><div class=container><a href=https://docs.freebsd.org/it/books/handbook/partiii class=direction>Precedente</a></div></div><div class=home><i class="fa fa-home" aria-hidden=true title=Home></i><div class=container><a href=../ class=direction>Home</a></div></div><div class=next><div class=container><a href=https://docs.freebsd.org/it/books/handbook/boot class=direction>Successivo</a></div><i class="fa fa-angle-right" aria-hidden=true title=Successivo></i></div></div><label class="hidden book-menu-overlay" for=menu-control></label></div><aside class=toc><div class=toc-content><h3>Indice</h3><nav id=TableOfContents><ul><li><a href=#config-synopsis>11.1. Sinossi</a></li><li><a href=#configtuning-initial>11.2. Configurazione Iniziale</a></li><li><a href=#configtuning-core-configuration>11.3. Configurazione Principale</a></li><li><a href=#configtuning-appconfig>11.4. Configurazione delle Applicazioni</a></li><li><a href=#configtuning-starting-services>11.5. Avvio dei Servizi</a></li><li><a href=#configtuning-cron>11.6. Configurare l’Utility <code>cron</code></a></li><li><a href=#configtuning-rcd>11.7. Usare rc con FreeBSD</a></li><li><a href=#config-network-setup>11.8. Configurazione delle Interfacce di Rete</a></li><li><a href=#configtuning-virtual-hosts>11.9. Host Virtuali</a></li><li><a href=#configtuning-configfiles>11.10. File di Configurazione</a></li><li><a href=#configtuning-sysctl>11.11. Messa a Punto con sysctl</a></li><li><a href=#configtuning-disk>11.12. Messa a Punto dei Dischi</a></li><li><a href=#configtuning-kernel-limits>11.13. Messa a Punto dei Limiti del Kernel</a></li><li><a href=#adding-swap-space>11.14. Aggiunta di Spazio di Swap</a></li><li><a href=#acpi-overview>11.15. Gestione dell’Energia e delle Risorse</a></li><li><a href=#ACPI-debug>11.16. Usare e Debuggare ACPI di FreeBSD</a></li></ul></nav><hr><div class=resources><h3>Risorse</h3><ul class=contents><li><i class="fa fa-file-pdf-o" aria-hidden=true title="Scarica PDF"></i><a href=https://download.freebsd.org/doc/it/books/handbook/handbook_it.pdf>Scarica PDF</a></li><li><i class="fa fa-pencil-square-o" aria-hidden=true title="Modifica questa pagina"></i><a href=https://github.com/freebsd/freebsd-doc/blob/main/documentation/content/it/_index target=_blank>Modifica questa pagina</a></li></ul></div></div></aside><a class=to-top href=#top><i class="fa fa-arrow-circle-up" aria-hidden=true></i></a></main><footer><div class=footer-container><section class=logo-column><img src=https://docs.freebsd.org/images/FreeBSD-colors.svg width=160 height=50 alt="FreeBSD logo"><div class=options-container><div class=language-container><a id=languages href=https://docs.freebsd.org/it/languages><img src=https://docs.freebsd.org/images/language.png class=language-image alt="Scegli una lingua">
<span>Italian</span></a></div><div class=theme-container><select id=theme-chooser><option value=theme-system>System</option><option value=theme-light>Light</option><option value=theme-dark>Dark</option><option value=theme-high-contrast>Alto contrasto</option></select></div></div></section><section class=about-column><h3 class=column-title>About</h3><ul class=column-elements-container><li><a href=https://www.freebsd.org/about/ target=_blank class=column-element>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/ target=_blank class=column-element>FreeBSD Foundation</a></li><li><a href=https://www.freebsd.org/where/ target=_blank class=column-element>Get FreeBSD</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct target=_blank class=column-element>Code of Conduct</a></li><li><a href=https://www.freebsd.org/security/ target=_blank class=column-element>Security Advisories</a></li></ul></section><section class=documentation-column><h3 class=column-title>Documentation</h3><ul class=column-elements-container><li><a href=/it class=column-element>Documentation portal</a></li><li><a href=https://man.FreeBSD.org target=_blank class=column-element>Manual pages</a></li><li><a href=https://papers.FreeBSD.org target=_blank class=column-element>Presentations and papers</a></li><li><a href=https://docs-archive.freebsd.org/doc/ target=_blank class=column-element>Previous versions</a></li><li><a href=https://docs-archive.freebsd.org/44doc/ target=_blank class=column-element>4.4BSD Documents</a></li><li><a href=https://wiki.freebsd.org/ target=_blank class=column-element>Wiki</a></li></ul></section><section class=community-column><h3 class=column-title>Community</h3><ul class=column-elements-container><li><a href=https://docs.freebsd.org/it/articles/contributing class=column-element>Get involved</a></li><li><a href=https://forums.freebsd.org/ target=_blank class=column-element>Community forum</a></li><li><a href=https://lists.freebsd.org/ target=_blank class=column-element>Mailing lists</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank class=column-element>IRC Channels</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank class=column-element>Bug Tracker</a></li></ul></section><section class=legal-column><h3 class=column-title>Legal</h3><ul class=column-elements-container><li><a href=https://freebsdfoundation.org/donate/ target=_blank class=column-element>Donations</a></li><li><a href=https://www.freebsd.org/copyright/freebsd-license/ target=_blank class=column-element>Licensing</a></li><li><a href=https://www.freebsd.org/privacy/ target=_blank class=column-element>Privacy Policy</a></li><li><a href=https://www.freebsd.org/copyright/ target=_blank class=column-element>Legal notices</a></li></ul></section><section class=copyright-column><p>&copy; 1994-2024 The FreeBSD Project. All rights reserved</p><span>Made with <span class=heart>♥</span> by the FreeBSD Community</span></section></div></footer></body></html>