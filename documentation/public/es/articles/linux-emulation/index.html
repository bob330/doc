<!doctype html><html class=theme-light lang=es><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Una descripción técnica acerca del funcionamiento interno de la capa de emulación Linux en FreeBSD"><meta name=keywords content="Emulation,Linuxulator,kernel,FreeBSD"><meta name=copyright content="1995-2024 The FreeBSD Foundation"><link rel=canonical href=http://172.16.201.134:1313/es/articles/linux-emulation/><title>Emulación Linux(R) en FreeBSD | Portal de documentación de FreeBSD</title>
<meta name=theme-color content="#790000"><meta name=color-scheme content="system light dark high-contrast"><link rel="shortcut icon" href=http://172.16.201.134:1313/favicon.ico><link rel=stylesheet href=http://172.16.201.134:1313/styles/main.min.css><link rel=stylesheet href=http://172.16.201.134:1313/css/font-awesome-min.css><script defer src=/js/theme-chooser.min.js></script><script defer src=/js/copy-clipboard.min.js></script><script defer src=/js/search.min.js></script><meta name=twitter:card content="summary"><meta name=twitter:domain content="docs.FreeBSD.org"><meta name=twitter:site content="@freebsd"><meta name=twitter:url content="https://twitter.com/freebsd"><meta property="og:title" content="Emulación Linux(R) en FreeBSD"><meta property="og:description" content="Una descripción técnica acerca del funcionamiento interno de la capa de emulación Linux en FreeBSD"><meta property="og:type" content="website"><meta property="og:image" content="http://172.16.201.134:1313/favicon.ico"><meta property="og:image:alt" content="FreeBSD Logo"><meta property="og:locale" content="es"><meta property="og:url" content="http://172.16.201.134:1313/es/articles/linux-emulation/"><meta property="og:site_name" content="Portal de documentación de FreeBSD"><script type=application/ld+json>{"@context":"http://schema.org","@type":"Article","url":"http:\/\/172.16.201.134:1313\/es\/articles\/linux-emulation\/","name":"Portal de documentación de FreeBSD","headline":"Portal de documentación de FreeBSD","description":"FreeBSD Documentation Portal"}</script></head><body><header><div class=header-container><div class=logo-menu-bars-container><a href=https://www.FreeBSD.org class=logo><img src=http://172.16.201.134:1313/images/FreeBSD-monochromatic.svg width=160 height=50 alt="FreeBSD logo">
</a><label class=menu-bars for=menu-bars><i class="fa fa-bars" aria-hidden=true></i></label></div><input id=menu-bars type=checkbox><nav><ul class=menu><li class=menu-item><input id=about type=checkbox>
<a href=# aria-label="Navigate to About section"><label class=menu-item-description for=about>About
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/about/ target=_blank>About</a></li><li><a href=https://www.freebsd.org/about/ target=_blank>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/about-us/about-the-foundation/ target=_blank>FreeBSD Foundation</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct/ target=_blank>Code of Conduct</a></li></ul></li><li class=menu-item><input id=download type=checkbox>
<a href=# aria-label="Navigate to get FreeBSD section"><label class=menu-item-description for=download>Get FreeBSD
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/where/ target=_blank>Get FreeBSD</a></li><li><a href=https://www.freebsd.org/releases/ target=_blank>Release Information</a></li><li><a href=https://www.freebsd.org/releng/ target=_blank>Release Engineering</a></li><li><a href=https://www.freebsd.org/security/ target=_blank>Security Advisories</a></li></ul></li><li class=menu-item><input id=documentation type=checkbox>
<a href=# aria-label="Navigate to get Documentation section"><label class=menu-item-description for=documentation>Documentation
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=/es>Documentation portal</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook>FreeBSD Handbook</a></li><li><a href=http://172.16.201.134:1313/es/books/porters-handbook>Porter's Handbook</a></li><li><a href=https://docs.FreeBSD.org/en/books/fdp-primer>Documentation Project Handbook</a></li><li><a href=https://man.FreeBSD.org target=_blank>Manual pages</a></li><li><a href=https://papers.FreeBSD.org target=_blank>Presentations and papers</a></li><li><a href=https://wiki.FreeBSD.org target=_blank>Wiki</a></li><li><a href=http://172.16.201.134:1313/es/books>Books</a></li><li><a href=http://172.16.201.134:1313/es/articles>Articles</a></li></ul></li><li class=menu-item><input id=community type=checkbox>
<a href=# aria-label="Navigate to get Community section"><label class=menu-item-description for=community>Community
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/community/>Community</a></li><li><a href=http://172.16.201.134:1313/es/articles/contributing>Get involved</a></li><li><a href=https://forums.freebsd.org/ target=_blank>Forum</a></li><li><a href=https://lists.freebsd.org/ target=_blank>Mailing lists</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank>IRC Channels</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank>Bug Tracker</a></li><li><a href=https://www.freebsd.org/support/ target=_blank>Support</a></li></ul></li></ul></nav><div class=search-donate-container><form class=search method=get id=search-header-form action=https://docs.freebsd.org/search name=search-header-form><input type=hidden name=DB value=es>
<input id=words name=P type=text size=20 maxlength=255>
<button>
<i class="fa fa-search" aria-hidden=true></i></button></form><div class=donate><a href=https://freebsdfoundation.org/donate/ target=_blank><span class=heart>♥</span>
Donate</a></div></div></div></header><main class=main-wrapper-article><div class=article><h1 class=title>Emulación Linux(R) en FreeBSD</h1><div class="admonitionblock note"><p><i class="fa fa-exclamation-circle" aria-hidden=true></i>
This translation may be out of date. To help with the translations please access the <a href=https://translate-dev.freebsd.org/ target=_blank>FreeBSD translations instance</a>.</p></div><div class=legalnotice><a id=trademarks></a><details><summary>Marcas registradas</summary><p>FreeBSD es una marca registrada de la Fundación FreeBSD</p><p>IBM, AIX, OS/2, PowerPC, PS/2, S/390, y ThinkPad son marcas registradas de International Business Machines Corporation en los Estados Unidos de América, otros países, o ambos.</p><p>Adobe, Acrobat, Acrobat Reader, Flash y PostScript son marcas registradas o marcas comerciales de Adobe Systems Incorporated en los Estados Unidos de América y/o otros países.</p><p>Linux es una marca registrada de Linus Torvalds.</p><p>Sun, Sun Microsystems, Java, Java Virtual Machine, JDK, JRE, JSP, JVM, Netra, OpenJDK, Solaris, StarOffice, SunOS y VirtualBox son marcas comerciales o marcas registradas de Sun Microsystems, Inc. en los Estados Unidos de América y otros países.</p><p>NetBSD es una marca registrada de la Fundación NetBSD.</p><p>RealNetworks, RealPlayer, and RealAudio son marcas registradas de RealNetworks, Inc.</p><p>Oracle es una marca registrada de Oracle Corporation.</p><p>Muchos de los nombres usados por los fabricantes y vendedores para diferenciar sus productos son designados como marcas comerciales. Allí donde estos nombres aparezcan en este documento y el Proyecto FreeBSD fuera consciente de la alegación de marca comercial, los nombres tienen a continuación el símbolo “™” o “®”.</p></details></div><div class=toc-mobile><h3>Tabla de contenidos</h3><nav id=TableOfContents><ul><li><a href=#intro>1. Introducción</a></li><li><a href=#inside>2. Una mirada al interior …</a></li><li><a href=#freebsd-emulation>3. Emulación</a></li><li><a href=#md>4. Parte MD de la capa de emulación de Linux®</a></li><li><a href=#mi>5. Parte MI de la capa de emulación Linux®</a></li><li><a href=#conclusion>6. Conclusión</a></li><li><a href=#literatures>7. Bibliografía</a></li></ul></nav></div><div id=preamble><div class=sectionbody><div class="paragraph abstract-title"><p>Resumen</p></div><div class=paragraph><p>Esta tesis doctoral trata sobre cómo actualizar la capa de emulación de Linux® (también llamada <em>Linuxulator</em>). La tarea consistía en actualizar dicha capa para alcanzar en funcionalidad a Linux® 2.6. Como implementación de referencia se escogió el kernel Linux® 2.6.16. El concepto se basa ligeramente en la implementación de NetBSD. La mayoría del trabajo se realizó en el verano de 2006 como parte del programa de estudiantes Google Summer of Code. El foco se situó en añadir soporte para <em>NPTL</em> (la nueva librería de hilos POSIX®) a la capa de emulación, incluyento <em>TLS</em> (almacenamiento local para hilos), <em>futexes</em> (mutex rápidos en espacio de usuario), <em>PID mangling</em> y otras cosas menores. En el proceso se identificaron y arreglaron muchos problemas menores. Mi trabajo se integró en el repositorio fuente principal de FreeBSD y estará disponible en la próxima versión 7.0R. Los miembros del equipo de desarrollo de emulación estamos trabajando para que la emulación de Linux® 2.6 sea la capa de emulación por defecto en FreeBSD.</p></div><hr></div></div><div class=sect1><h2 id=intro>1. Introducción<a class=anchor href=#intro></a></h2><div class=sectionbody><div class=paragraph><p>En los últimos años, los sistemas operativos basados en el código abierto de UNIX® han empezado a ser desplegados ampliamente tanto en máquinas cliente como servidores. Entre estos sistemas operativos me gustaría resaltar dos: FreeBSD, por su herencia BSD, base de código que resiste el paso del tiempo y por tener muchas características interesantes y Linux® por su amplio número de usuarios, comunidad de desarrolladores entusiasta y abierta y el apoyo de grandes corporaciones. FreeBSD se suele utilizar en máquinas de tipo servidor que realizan duras tareas intensivas de red con menos uso en máquinas de tipo escritorio para usuarios ordinarios. Aunque Linux® tiene el mismo uso en servidores, es mucho más usado por usuarios en sus casas. Esto lleva a una situación en la que hay muchos programas sólo disponibles en forma binaria para Linux® y que no tienen soporte para FreeBSD.</p></div><div class=paragraph><p>Naturalmente, surge la necesidad de ejecutar binarios de Linux® en un sistema FreeBSD y eso es de lo que trata esta tesis: la emulación del kernel Linux® en el sistema operativo FreeBSD.</p></div><div class=paragraph><p>En el verano de 2006 Google Inc. patrocinó un proyecto enfocado en extender la capa de emulación Linux® (el llamado Linuxulator) en FreeBSD para incluir las capacidades de Linux® 2.6. Esta tesis se escribió como parte de este proyecto.</p></div></div></div><div class=sect1><h2 id=inside>2. Una mirada al interior …<a class=anchor href=#inside></a></h2><div class=sectionbody><div class=paragraph><p>En esta sección vamos a describir cada sistema operativo en cuestión. Cómo manejan las llamadas al sistema, trapframes, etc., todo lo que sea bajo nivel. También describimos la manera en la que entienden primitivas comunes de UNIX® como qué es un PID, qué es un hilo, etc. En la tercera subsección hablamos acerca de cómo se podría hacer emulación UNIX® sobre UNIX® de forma general.</p></div><div class=sect2><h3 id=what-is-unix>2.1. Qué es UNIX®<a class=anchor href=#what-is-unix></a></h3><div class=paragraph><p>UNIX® es un sistema operativo con una larga historia que ha influenciado a casi todos los sistemas operativos que se utilizan actualmente. Comenzando en 1960, su desarrollo continúa en la actualidad (aunque en diferentes proyectos). El desarrollo de UNIX® pronto se dividió en dos ramas principales: las familias BSD y System III/V. Ambas se influenciaron mutuamente haciendo crecer el estándar UNIX®. Entre las contribuciones que se originaron en BSD podemos nombrar la memoria virtual, las redes TCP/IP, FFS, y muchos otros. La rama System V aportó las primitivas SysV de comunicación entre procesos, el copy-on-write, etc. UNIX® en sí mismo ya no existe pero sus ideas se han usado en muchos otros sistemas operativos por todo el mundo formando así los llamados sistemas operativos tipo UNIX®. Actualmente los más influyentes son Linux®, Solaris, y posiblemente (hasta cierto punto) FreeBSD. Hay derivados de UNIX® internos en algunas compañías (AIX, HP-UX etc.) pero estos han sido migrados cada vez más a los sistemas mencionados anteriormente. Resumamos las características típicas de UNIX®.</p></div></div><div class=sect2><h3 id=tech-details>2.2. Detalles técnicos<a class=anchor href=#tech-details></a></h3><div class=paragraph><p>Cada programa en ejecución constituye un proceso que representa el estado de la computación. Un proceso en ejecución se divide entre espacio del kernel y espacio de usuario. Algunas operaciones sólo se pueden hacer en espacio de kernel (tratar con hardware etc.), pero el proceso debería pasar la mayoría de su vida en espacio de usuario. El kernel es donde tienen lugar la gestión de los procesos, hardware y los detalles de bajo nivel. El kernel proporciona al espacio de usuario un API UNIX® estándar y unificado. Las más importantes se tratan abajo.</p></div><div class=sect3><h4 id=kern-proc-comm>2.2.1. Comunicación entre el kernel y el proceso de espacio de usuario<a class=anchor href=#kern-proc-comm></a></h4><div class=paragraph><p>El API común de UNIX® define llamadas al sistema como forma de ejecutar comandos en el kernel desde espacio de usuario. La implementación más habitual es utilizar una interrupción o una instrucción especializada (como las instrucciones <code>SYSENTER</code>/<code>SYSCALL</code> en ia32). Las llamadas al sistema se definen mediante un número. Por ejemplo en FreeBSD, la llamada al sistema número 85 es la llamada al sistema de <a href="https://man.freebsd.org/cgi/man.cgi?query=swapon&amp;sektion=2&amp;format=html">swapon(2)</a> y la llamada al sistema número 132 es <a href="https://man.freebsd.org/cgi/man.cgi?query=mkfifo&amp;sektion=2&amp;format=html">mkfifo(2)</a>. Algunas llamadas al sistema necesitan parámetros, que son pasados desde espacio de usuario a espacio de kernel de varias formas (dependiendo de la implementación). Las llamadas al sistema son síncronas.</p></div><div class=paragraph><p>Otra forma posible de comunicarse es mediante un <em>trap</em>. Los traps (trampas) ocurren de forma asíncrona después de que ocurra algún evento (división por cero, fallo de página, etc.). Un trap puede ser transparente para un proceso (error de página) o puede resultar en una reacción como enviar una <em>señal</em> (división por cero).</p></div></div><div class=sect3><h4 id=proc-proc-comm>2.2.2. Comunicación entre procesos<a class=anchor href=#proc-proc-comm></a></h4><div class=paragraph><p>Hay otras API (System V IPC, memoria compartida, etc.) pero la API más importante es la señal. Las señales son enviadas por procesos o por el kernel y recibidas por procesos. Algunas señales pueden ser ignoradas o manejadas por una rutina proporcionada por el usuario, otras dan como resultado una acción predefinida que no se puede alterar ni ignorar.</p></div></div><div class=sect3><h4 id=proc-mgmt>2.2.3. Gestión de procesos<a class=anchor href=#proc-mgmt></a></h4><div class=paragraph><p>Las instancias del kernel se procesan las primeras en el sistema (llamado init). Cada proceso en ejecución puede crear una copia idéntica a sí mismo utilizando la llamada al sistema <a href="https://man.freebsd.org/cgi/man.cgi?query=fork&amp;sektion=2&amp;format=html">fork(2)</a>. Se han introducido algunas versiones ligeramente modificadas de esta llamada pero la semántica es básicamente la misma. Cada proceso en ejecución se puede convertir en otro proceso utilizando la llamada al sistema <a href="https://man.freebsd.org/cgi/man.cgi?query=exec&amp;sektion=3&amp;format=html">exec(3)</a>. Se han introducido algunas modificaciones a esta llamada pero todas tienen básicamente el mismo propósito. Los procesos terminan sus vidas invocando la llamada al sistema <a href="https://man.freebsd.org/cgi/man.cgi?query=exit&amp;sektion=2&amp;format=html">exit(2)</a>. Cada proceso se identifica por un número único llamado PID. Cada proceso tiene definido un padre (identificado por su PID).</p></div></div><div class=sect3><h4 id=thread-mgmt>2.2.4. Gestión de hilos<a class=anchor href=#thread-mgmt></a></h4><div class=paragraph><p>Los UNIX® tradicionales no definen ni un API ni una implementación para hilos, mientras que POSIX® define un API para hilos pero la implementación no está definida. Tradicionalmente había dos formas de implementar hilos. Manejarlos como procesos separados (modelo 1:1) o envolver todo el grupo de hilos en un proceso y manejar los hilos en espacio de usuario (modelo 1:N). Comparando las características principales de cada aproximación:</p></div><div class=paragraph><p>Hilos 1: 1</p></div><div class=ulist><ul><li><p>hilos pesados</p></li><li><p>el usuario no puede alterar la planificación (ligeramente mitigado por el
API de POSIX®)
+ no es necesario un recubrimiento para la llamada al sistema
+ puede utilizar varias CPU</p></li></ul></div><div class=paragraph><p>Hilos 1: N</p></div><div class=paragraph><p>+ hilos ligeros
+ el usuario puede modificar fácilmente la planificación
- las llamadas al sistema necesitan estar recubiertas
- no puede utilizar más de una CPU</p></div></div></div><div class=sect2><h3 id=what-is-freebsd>2.3. ¿Qué es FreeBSD?<a class=anchor href=#what-is-freebsd></a></h3><div class=paragraph><p>El proyecto FreeBSD es uno de los sistemas operativos open source más antiguos que están actualmente disponibles para uso diario. Es un descendiente directo del UNIX® genuino así que se podría afirmar que es un UNIX® verdadero aunque asuntos con las licencias no permiten hacerlo. El inicio del proyecto data de principios de los 90 cuando un grupo de usuarios de BSD parchearon el sistema operativo 386BSD. Basado en este conjunto de parches surgió un nuevo sistema operativo llamado FreeBSD debido a su licencia liberal. Otro grupo creó el sistema operativo NetBSD pensando en diferentes objetivos . Nos centraremos en FreeBSD.</p></div><div class=paragraph><p>FreeBSD es un sistema operativo moderno basado en UNIX® con todas las características de UNIX®. Multitarea preemptiva, capacidades multiusuario, redes TCP/IP, protección de memoria, soporte para multiprocesamiento simétrico, memoria virtual con cache de buffer y VM fusionadas, todo está ahí. Una de las características interesantes y extremadamente útiles es la habilidad de emular otros sistemas operativos tipo UNIX®. A fecha de Diciembre de 2006 en el desarrollo de 7-CURRENT, se soportan las siguientes características de emulación:</p></div><div class=ulist><ul><li><p>Emulación FreeBSD/i386 en FreeBSD/amd64</p></li><li><p>Emulación FreeBSD/i386 en FreeBSD/ia64</p></li><li><p>Emulación del sistema operativo Linux® en FreeBSD</p></li><li><p>Emulación NDIS de la interfaz de controladores de red de Windows</p></li><li><p>Emulación NetBSD del sistema operativo NetBSD</p></li><li><p>Soporte PECoff para ejecutables PECoff FreeBSD</p></li><li><p>Emulación del UNIX® System V revision 4</p></li></ul></div><div class=paragraph><p>Las emulaciones activamente en desarrollo son la capa de Linux® y las capas de FreeBSD sobre FreeBSD. Otras no están soportadas para funcionar correctamente o no son utilizables actualmente.</p></div><div class=sect3><h4 id=freebsd-tech-details>2.3.1. Detalles técnicos<a class=anchor href=#freebsd-tech-details></a></h4><div class=paragraph><p>FreeBSD es una versión tradicional de UNIX® en el sentido en el que divide la ejecución de los procesos en dos mitades: espacio de kernel y ejecución en espacio de usuario. Hay dos tipos de entradas al kernel para los procesos: una llamada al sistema y un trap. Sólo hay una forma de volver. En las siguientes secciones se describirán las tres puertas desde/hacia el kernel. Toda la descripción aplica a la arquitectura i386 ya que el Linuxulator sólo existe ahí pero el concepto es similar para otras arquitecturas. La información se ha tomado de [1] y del código fuente.</p></div><div class=sect4><h5 id=freebsd-sys-entries>2.3.1.1. Entradas del sistema<a class=anchor href=#freebsd-sys-entries></a></h5><div class=paragraph><p>FreeBSD tiene una abstracción denominada cargador de clases de ejecución que es un enganche a la llamada al sistema <a href="https://man.freebsd.org/cgi/man.cgi?query=execve&amp;sektion=2&amp;format=html">execve(2)</a>. Esta emplea una estructura <code>sysentvec</code> que describe el ABI de un ejecutable. Contiene cosas como la tabla de traducción de errno, la tabla de traducción de señales, varias funciones para satisfacer las necesidades de las llamadas al sistema (fixups de la pila, volcado de cores, etc). Cada ABI que el kernel de FreeBSD quiera soportar debe definir esta estructura puesto que es utilizada después el código de procesamiento de la llamada al sistema y en algunos otros sitios. Las entradas al sistema se manejan mediante manejadores de traps donde podemos acceder al espacio del kernel y de usuario al mismo tiempo.</p></div></div><div class=sect4><h5 id=freebsd-syscalls>2.3.1.2. Llamadas al sistema<a class=anchor href=#freebsd-syscalls></a></h5><div class=paragraph><p>Las llamadas al sistema en FreeBSD se llevan a cabo ejecutando la interrupción <code>0x80</code> con el registro <code>%eax</code> establecido al número de la llamada deseado y con los argumentos pasados en la pila.</p></div><div class=paragraph><p>Cuando un proceso realiza una interrupción <code>0x80</code>, se invoca el manejador de trap de llamada al sistema <code>int0x80</code> (definido en <span class=filename>sys/i386/i386/exception.s</span>), el cual prepara los argumentos (es decir, los copia a la pila) para llamar a una función C <a href="https://man.freebsd.org/cgi/man.cgi?query=syscall&amp;sektion=2&amp;format=html">syscall(2)</a> (definida en <span class=filename>sys/i386/i386/trap.c</span>) que procesa el marco de trap pasado. El procesamiento consiste en preparar la llamada al sistema (dependiendo de la entrada de <code>sysvec</code>), determinar si la llamada es de 32 o 64 bit (cambia el tamaño de los parámetros), luego copiar los parámetros incluyendo la llamada al sistema. Después, se ejecuta la llamada al sistema real procesando el código de retorno (casos especiales para los errores <code>ERESTART</code> y <code>EJUSTRETURN</code>). Por último se planifica un <code>userret()</code>, cambiando el proceso de nuevo a espacio de usuario. Los parámetros para la llamada al sistema real se pasan con la forma de los argumentos <code>struct thread *td</code>, <code>struct syscall args *</code> donde el segundo parámetro es un puntero a la estructura de parámetros copiada.</p></div></div><div class=sect4><h5 id=freebsd-traps>2.3.1.3. Trampas<a class=anchor href=#freebsd-traps></a></h5><div class=paragraph><p>El manejo de traps en FreeBSD es similar al manejo de llamadas al sistema. Siempre que ocurre un trap, se llama a un manejador en ensamblador. Se elige entre todos los traps, aquellas con registros empujados a la pila o traps de llamadas dependiendo del tipo de trap. Este controlador prepara argumentos para una llamada a una función C <code>trap()</code> (definida en <span class=filename>sys/i386/i386/trap.c</span>), que luego procesa el trap ocurrido. Después del procesamiento, puede enviar una señal al proceso y / o salir al espacio de usuario usando <code>userret()</code>.</p></div></div><div class=sect4><h5 id=freebsd-exits>2.3.1.4. Salida<a class=anchor href=#freebsd-exits></a></h5><div class=paragraph><p>Las salidas del kernel al espacio de usuario ocurren usando la rutina en ensamblador <code>doreti</code> independientemente de si se ingresó al kernel mediante un trap o mediante una llamada al sistema. Esto restaura el estado del programa desde la pila y vuelve al espacio de usuario.</p></div></div><div class=sect4><h5 id=freebsd-unix-primitives>2.3.1.5. Primitivas UNIX®<a class=anchor href=#freebsd-unix-primitives></a></h5><div class=paragraph><p>El sistema operativo FreeBSD sigue el esquema tradicional UNIX®, donde cada proceso tiene un número único de identificación, el llamado <em>PID</em> (Process ID). Los números PID se generan o linealmente o de forma aleatoria en el rango <code>0</code> a <code>PID_MAX</code>. La generación de números PID se hace usando una búsqueda lineal en el espacio PID. Cada hilo en un proceso recibe el mismo número PID como resultado de llamar a <a href="https://man.freebsd.org/cgi/man.cgi?query=getpid&amp;sektion=2&amp;format=html">getpid(2)</a>.</p></div><div class=paragraph><p>Actualmente hay dos formas de implementar multihilo en FreeBSD. La primera es M:N seguido del modelo 1:1. La librería usada por defecto es multihilo M:N (<code>libpthread</code>) y puedes cambiar en tiempo de ejecución a multihilo 1:1 (<code>libthr</code>). El plan es cambiar pronto a la librería 1:1 por defecto. Aunque estas dos librerías utilizan las mismas primitivas del kernel, se acceden mediante APIs diferentes. La librería M:N utiliza la familia <code>kse_*</code> de llamadas al sistema mientras que la librería 1:1 utiliza la familia <code>thr_*</code> de llamadas al sistema. Debido a esto, no hay un concepto general de ID de hilo compartido entre el kernel y el espacio de usuario. Por supuesto, ambas librerías implementan el API de ID de hilo de pthread. Cada hilo del kernel (descrito por <code>struct thread</code>) tiene el identificador tid pero no es directamente accesible desde espacio de usuario y sólo sirve para cubrir necesidades del kernel. También se usa para la librería 1:1 como el ID de hilo de pthread pero este manejo es interno a la librería y no se puede depender de él.</p></div><div class=paragraph><p>Como se indicó anteriormente, hay dos implementaciones de multihilo en FreeBSD. La biblioteca M:N divide el trabajo entre el espacio del kernel y el espacio de usuario. El hilo es una entidad que se planifica en el kernel, pero puede representar varios hilos en espacio de usuario. M hilos en espacio de usuario se asignan a N hilos del núcleo, lo que ahorra recursos y mantiene la capacidad de explotar el paralelismo de multiprocesador. Se puede obtener más información sobre la implementación en la página del manual o en [1]. La biblioteca 1:1 mapea directamente un hilo de espacio de usuario a un hilo del kernel, lo que simplifica enormemente el esquema. Ninguno de estos diseños implementa un mecanismo de equidad (se implementó un mecanismo de este tipo, pero se eliminó recientemente porque causaba una grave lentitud y hacía que el código fuera más difícil de tratar).</p></div></div></div></div><div class=sect2><h3 id=what-is-linux>2.4. Qué es Linux®<a class=anchor href=#what-is-linux></a></h3><div class=paragraph><p>Linux® es un kernel de tipo UNIX® desarrollado originalmente por Linus Torvalds, y al que ahora contribuye un enorme número de programadores en todo el mundo. Desde sus primeros comienzos hasta ahora, con amplio apoyo de compañías como IBM o Google, Linux® se ha asociado con su rápido ritmo de desarrollo, amplio soporte hardware y su modelo de organización de tipo dictador benevolente.</p></div><div class=paragraph><p>El desarrollo de Linux® comenzó como un hobby en 1991 en la Universidad de Helsinki en Finlandia. Desde entonces ha adquirido todas las características de un sistema operativo moderno tipo UNIX®: multiprocesamiento, soporte multiusuario, memoria virtual, redes, básicamente lo tiene todo. También hay características altamente avanzadas como virtualización, etc.</p></div><div class=paragraph><p>A fecha de 2006 Linux® parece ser el sistema operativo open source más ampliamente usado con soporte de empresas de software independientes como Oracle, RealNetworks, Adobe, etc. La mayoría del software comercial que se distribuye para Linux® sólo se puede obtener en forma binaria de forma que recompilar para otros sistemas operativos es imposible.</p></div><div class=paragraph><p>La mayoría del desarrollo de Linux® tiene lugar en el sistema de control de versiones Git. Git es un sistema distribuido de forma que no hay una fuente de código central de Linux®, pero algunas ramas se consideran prominentes y oficiales. El esquema de numeración de versiones implementado por Linux® consiste en cuatro números A.B.C.D. El desarrollo actual tiene lugar en 2.6.C.C, donde C representa la versión mayor, donde se cambian o añaden nuevas características mientras que D es la versión menor sólo para arreglos de bugs.</p></div><div class=paragraph><p>Se puede obtener más información en [3].</p></div><div class=sect3><h4 id=linux-tech-details>2.4.1. Detalles técnicos<a class=anchor href=#linux-tech-details></a></h4><div class=paragraph><p>Linux® sigue el esquema tradicional UNIX® de dividir la ejecución de un proceso en dos partes: espacio de kernel y espacio de usuario. Al kernel se puede entrar de dos formas: vía trap o vía llamada al sistema. La vuelta se maneja de una sola forma. La descripción que sigue aplica a Linux® 2.6 en la arquitectura i386™. La información se ha obtenido de [2].</p></div><div class=sect4><h5 id=linux-syscalls>2.4.1.1. Llamadas al sistema<a class=anchor href=#linux-syscalls></a></h5><div class=paragraph><p>Las llamadas al sistema en Linux® se realizan (en espacio de usuario) utilizando las macros <code>syscallX</code> donde X se sustituye por el número que representa el número de parámetros de la llamada al sistema. Esta macro traduce a un código que carga el registro <code>%eax</code> con un número de llamada al sistema y ejecuta la interrupción <code>0x80</code>. Después de la llamada al sistema se llama a return, que traslada valores de retorno negativos a valores positivos <code>errno</code> y establece <code>res</code> a <code>-1</code> en caso de error. Cada vez que se llama a la interrupción <code>0x80</code> el proceso entra en el kernel en un manejador de llamada al sistema. Esta rutina salva todos los registros en la pila y llama a la entrada de llamada al sistema seleccionada. Nótese que la convención de llamadas de Linux® espera que los parámetros de la llamada al sistema se pasen vía registros como se muestra aquí:</p></div><div class="olist arabic"><ol class=arabic><li><p>parámetro → <code>%ebx</code></p></li><li><p>parámetro → <code>%ecx</code></p></li><li><p>parámetro → <code>%edx</code></p></li><li><p>parámetro → <code>%esi</code></p></li><li><p>parámetro → <code>%edi</code></p></li><li><p>parámetro → <code>%ebp</code></p></li></ol></div><div class=paragraph><p>Hay algunas excepciones a esta regla, donde Linux® utiliza una convención de llamadas diferente (principalmente en la llamada al sistema <code>clone</code>).</p></div></div><div class=sect4><h5 id=linux-traps>2.4.1.2. Trampas<a class=anchor href=#linux-traps></a></h5><div class=paragraph><p>Los manejadores de traps se encuentran en <span class=filename>arch/i386/kernel/traps.c</span> y la mayoría de estos manejadores viven en <span class=filename>arch/i386/kernel/entry.S</span>, donde ocurre el manejo de los traps.</p></div></div><div class=sect4><h5 id=linux-exits>2.4.1.3. Salida<a class=anchor href=#linux-exits></a></h5><div class=paragraph><p>La vuelta de la llamada al sistema se gestiona mediante la llamada al sistema <a href="https://man.freebsd.org/cgi/man.cgi?query=exit&amp;sektion=3&amp;format=html">exit(3)</a> que comprueba que el proceso no tenga trabajo sin finalizar, luego comprueba si hemos utilizado los selectores proporcionados por el usuario. Si esto sucede se aplica un fix a la pila y finalmente se restauran los registros desde la pila y el proceso vuelve a espacio de usuario.</p></div></div><div class=sect4><h5 id=linux-unix-primitives>2.4.1.4. Primitivas UNIX®<a class=anchor href=#linux-unix-primitives></a></h5><div class=paragraph><p>En la versión 2.6, el sistema operativo Linux® redefinió algunas de las primitivas tradicionales de UNIX®, en particular PID, TID e hilo. PID no se define como único para cada proceso, así que para algunos procesos (hilos) <a href="https://man.freebsd.org/cgi/man.cgi?query=getpid&amp;sektion=2&amp;format=html">getpid(2)</a> devuelve el mismo valor. La identificación única de proceso se proporciona mediante TID. Esto es así porque <em>NPTL</em> (New POSIX® Thread Library) define los hilos como procesos normales (el llamado multihilo 1:1). Crear un nuevo proceso en Linux® 2.6 se hace utilizando la llamada al sistema <code>clone</code> (las variantes de fork se reimplementan usando esta). Esta llamada al sistema clone define una serie de flags que afecta el comportamiento de los procesos clonados respecto a la implementación del multihilo. La semántica es un poco difusa ya que no hay un único flag para decirle a la llamada al sistema que cree un hilo.</p></div><div class=paragraph><p>Las banderas de clonado implementadas son:</p></div><div class=ulist><ul><li><p><code>CLONE_VM</code> - los procesos comparten su espacio de memoria</p></li><li><p><code>CLONE_FS</code> - comparte umask, cwd y namespace (espacio de nombres)</p></li><li><p><code>CLONE_FILES</code> - comparte ficheros abiertos</p></li><li><p><code>CLONE_SIGHAND</code> - comparte manejadores de señales y señales bloqueadas</p></li><li><p><code>CLONE_PARENT</code> - comparte padre</p></li><li><p><code>CLONE_THREAD</code> - sé un hilo (más explicación abajo)</p></li><li><p><code>CLONE_NEWNS</code> - nuevo espacio de nombres</p></li><li><p><code>CLONE_SYSVSEM</code> - comparte estructuras para deshacer operaciones en semáforos de SysV</p></li><li><p><code>CLONE_SETTLS</code> - establece TLS en la dirección proporcionada</p></li><li><p><code>CLONE_PARENT_SETTID</code> - establece TID en el padre</p></li><li><p><code>CLONE_CHILD_CLEARTID</code> - borra TID en el hijo</p></li><li><p><code>CLONE_CHILD_SETTID</code> - establece TID en el hijo</p></li></ul></div><div class=paragraph><p><code>CLONE_PARENT</code> establece el padre real al padre del llamante. Esto es útil para los hilos porque si el hilo A crea el hilo B queremos que el padre del hilo B sea todo el grupo de hilos. <code>CLONE_THREAD</code> hace exactamente lo mismo que <code>CLONE_PARENT</code>, <code>CLONE_VM</code> y <code>CLONE_SIGHAND</code>, reescribe el PID para que sea igual al PID del llamante, blanquea la señal exit y se une al grupo de hilos. <code>CLONE_SETTLS</code> establece las entradas GDT para el manjeo de TLS. El conjunto de flags <code>CLONE_*_*TID</code> establece/borra la dirección proporcionada por el usuario a TID o 0.</p></div><div class=paragraph><p>Como puedes ver <code>CLONE_THREAD</code> hace la mayor parte del trabajo y no parece encajar muy bien en el esquema. La intención original no está clara (incluso para los autores, según los comentarios en el código), pero creo que originalmente había un flag de hilo, que luego se dividió entre muchos otros flags pero esta separación nunca se terminó por completo. Tampoco está claro para qué sirve esta partición, ya que glibc no la usa, por lo que solo el uso a mano de clone permite al programador acceder a estas funciones.</p></div><div class=paragraph><p>Para programas no multihilo el PID y el TID son iguales. Para programas multihilo el PID y el TID del primer hilo son el mismo y cada hilo que se crea comparte el mismo PID y se le asigna un TID único (porque se pasa <code>CLONE_THREAD</code>) también se comparte el padre en todos los procesos que forman este programa multihilo.</p></div><div class=paragraph><p>El código que implementa <a href="https://man.freebsd.org/cgi/man.cgi?query=pthread_create&amp;sektion=3&amp;format=html">pthread_create(3)</a> en NPTL define los flags de clone así:</p></div><div class="literalblock programlisting"><div class=content><pre>int clone_flags = (CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGNAL

 | CLONE_SETTLS | CLONE_PARENT_SETTID

| CLONE_CHILD_CLEARTID | CLONE_SYSVSEM
#if __ASSUME_NO_CLONE_DETACHED == 0

| CLONE_DETACHED
#endif

| 0);</pre></div></div><div class=paragraph><p><code>CLONE_SIGNAL</code> se define como</p></div><div class="literalblock programlisting"><div class=content><pre>#define CLONE_SIGNAL (CLONE_SIGHAND | CLONE_THREAD)</pre></div></div><div class=paragraph><p>el último 0 significa que no se envía ninguna señal cuando alguno de los hilos sale.</p></div></div></div></div><div class=sect2><h3 id=what-is-emu>2.5. Que es la emulación<a class=anchor href=#what-is-emu></a></h3><div class=paragraph><p>Según una definición de diccionario, la emulación es la capacidad de un programa o dispositivo para imitar otro programa o dispositivo. Esto se logra proporcionando la misma reacción a un estímulo dado que la que produce el objeto emulado. En la práctica, en el mundo del software hay principalmente tres tipos de emulación: un programa utilizado para emular una máquina (QEMU, varios emuladores de consola de juegos, etc.), emulación de software de una instalación de hardware (emuladores OpenGL, emulación de unidades de punto flotante, etc.) y emulación del sistema operativo (ya sea en el núcleo del sistema operativo o como un programa de espacio de usuario).</p></div><div class=paragraph><p>La emulación se usa generalmente en un lugar donde usar el componente original no es factible ni posible en absoluto. Por ejemplo, alguien podría querer usar un programa desarrollado para un sistema operativo diferente al que usa. Entonces la emulación es útil. A veces no hay otra forma que usar la emulación, por ejemplo, cuando el dispositivo de hardware que intentas utilizar no existe (todavía/más), no hay otra forma que la emulación. Esto sucede a menudo cuando se traslada un sistema operativo a una plataforma nueva (inexistente). A veces es más barato emular.</p></div><div class=paragraph><p>Desde el punto de vista de la implementación, hay dos enfoques principales para la implementación de la emulación. Puedes emular todo, aceptando posibles entradas del objeto original, manteniendo el estado interno y emitiendo la salida correcta según el estado y/o la entrada. Este tipo de emulación no requiere condiciones especiales y básicamente se puede implementar en cualquier lugar para cualquier dispositivo/programa. El inconveniente es que implementar tal emulación es bastante difícil, requiere mucho tiempo y es propenso a errores. En algunos casos, podemos utilizar un enfoque más simple. Imagina que quieres emular una impresora que imprime de izquierda a derecha en una impresora que imprime de derecha a izquierda. Es obvio que no hay necesidad de una capa de emulación compleja, pero basta con invertir el texto impreso. A veces, el entorno de emulación es muy similar al emulado, por lo que solo se necesita una capa fina de traducción para proporcionar una emulación completamente funcional. Como puedes ver, esto es mucho menos exigente de implementar, por lo que consume menos tiempo y es menos propenso a errores que el enfoque anterior. Pero la condición necesaria es que los dos entornos sean lo suficientemente similares. El tercer enfoque combina los dos anteriores. La mayoría de las veces los objetos no brindan las mismas capacidades, por lo que en el caso de emular el más potente en el menos potente, tenemos que emular las características faltantes con la emulación completa descrita anteriormente.</p></div><div class=paragraph><p>Esta tesis trata de la emulación de UNIX® en UNIX®, que es exactamente el caso, donde una fina capa de traducción es suficiente para proporcionar emulación completa. El API UNIX® consiste en un conjunto de llamadas al sistema, las cuales están normalmente autocontenidas y no afectan al estado global del kernel.</p></div><div class=paragraph><p>Hay algunas llamadas al sistema que afectan el estado interno, pero esto se puede solucionar proporcionando algunas estructuras que mantienen el estado adicional.</p></div><div class=paragraph><p>Ninguna emulación es perfecta y las emulaciones tienden a carecer de algunas partes, pero esto no suele causar inconvenientes graves. Imagina un emulador de consola de juegos que emula todo menos la salida de música. No hay duda de que los juegos se pueden jugar y se puede usar el emulador. Puede que no sea tan cómodo como la consola de juegos original, pero es un compromiso aceptable entre precio y comodidad.</p></div><div class=paragraph><p>Lo mismo aplica al API de UNIX®. La mayoría de los programas pueden vivir con un conjunto muy limitado de llamadas al sistema funcionales. Esas llamadas al sistemas suelen ser las más antiguas (<a href="https://man.freebsd.org/cgi/man.cgi?query=read&amp;sektion=2&amp;format=html">read(2)</a>/<a href="https://man.freebsd.org/cgi/man.cgi?query=write&amp;sektion=2&amp;format=html">write(2)</a>, la familia <a href="https://man.freebsd.org/cgi/man.cgi?query=fork&amp;sektion=2&amp;format=html">fork(2)</a>, manejo de <a href="https://man.freebsd.org/cgi/man.cgi?query=signal&amp;sektion=3&amp;format=html">signal(3)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=exit&amp;sektion=3&amp;format=html">exit(3)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=socket&amp;sektion=2&amp;format=html">socket(2)</a> API) y por lo tanto es fácil de emular porque sus semánticas se comparten entre todos los UNIX® que existen a día de hoy.</p></div></div></div></div><div class=sect1><h2 id=freebsd-emulation>3. Emulación<a class=anchor href=#freebsd-emulation></a></h2><div class=sectionbody><div class=sect2><h3 id=_cómo_funciona_la_emulación_en_freebsd>3.1. Cómo funciona la emulación en FreeBSD<a class=anchor href=#_cómo_funciona_la_emulación_en_freebsd></a></h3><div class=paragraph><p>Como se ha mencionado antes, FreeBSD suporta ejecutar binarios de otros UNIX®. Esto funciona porque FreeBSD tiene una capa de abstracción llamada el cargador de clases de ejecución. Este se inserta en la llamada al sistema <a href="https://man.freebsd.org/cgi/man.cgi?query=execve&amp;sektion=2&amp;format=html">execve(2)</a> de forma que cuando <a href="https://man.freebsd.org/cgi/man.cgi?query=execve&amp;sektion=2&amp;format=html">execve(2)</a> está a punto de ejecutar un binario examina su tipo.</p></div><div class=paragraph><p>Básicamente, existen dos tipos de binarios en FreeBSD. Scripts de texto tipo shell que se identifican por <code>#!</code> como sus dos primeros caracteres y binarios (typically <em>ELF</em>) normales, que son una representación de un objeto compilado ejecutable. La gran mayoría (se podría decir que todos) de los binarios en FreeBSD son del tipo ELF. Los archivos ELF contienen un encabezado, que especifica la ABI del sistema operativo para este archivo ELF. Al leer esta información, el sistema operativo puede determinar con precisión de qué tipo de binario es el archivo dado.</p></div><div class=paragraph><p>Cada ABI de sistema operativo tiene que estar registrada en el kernel de FreeBSD. Esto aplica también al ABI nativo de FreeBSD. Cuando <a href="https://man.freebsd.org/cgi/man.cgi?query=execve&amp;sektion=2&amp;format=html">execve(2)</a> ejecuta un binario itera por la lista de APIs registradas y cuando encuentra la correcta usa la información contenida en la descripción del ABI (su tabla de llamadas al sistema, tabla de traducción de <code>errno</code>, etc.). Así que cada vez que un proceso realiza una llamada al sistema, utiliza su propio conjunto de llamadas al sistema en lugar de uno global. Esto de forma efectiva proporciona una forma muy elegante de soportar la ejecución de varios formatos binarios.</p></div><div class=paragraph><p>La naturaleza de la emulación de diferentes sistemas operativos (y también algunos otros subsistemas) llevó a los desarrolladores a introducir un mecanismo de manejadores de eventos. Hay varios lugares en el kernel, donde se llama a una lista de manejadores de eventos. Cada subsistema puede registrar un manejador de eventos y se los llama en consecuencia. Por ejemplo, cuando un proceso termina, se llama a un manejador que posiblemente limpia lo que sea que el subsistema necesite que se limpie.</p></div><div class=paragraph><p>Esos simples servicios básicamente proporcionan todo lo que se necesita para la infraestructura de emulación y de hecho esto es básicamente lo único necesario para implementar la capa de emulación Linux®.</p></div></div><div class=sect2><h3 id=freebsd-common-primitives>3.2. Primitivas comunes en el kernel de FreeBSD<a class=anchor href=#freebsd-common-primitives></a></h3><div class=paragraph><p>Las capas de emulación necesitan soporte del sistema operativo. Voy a describir algunas de las primitivas soportadas en el sistema operativo FreeBSD.</p></div><div class=sect3><h4 id=freebsd-locking-primitives>3.2.1. Primitivas de bloqueo<a class=anchor href=#freebsd-locking-primitives></a></h4><div class=paragraph><p>Aportado por: <code>Attilio Rao &lt;<a href=mailto:attilio@FreeBSD.org>attilio@FreeBSD.org</a>></code></p></div><div class=paragraph><p>El conjunto de primitivas de sincronización de FreeBSD se basa en la idea de suministrar un número bastante grande de primitivas diferentes de manera que se pueda utilizar la mejor para cada situación particular y apropiada.</p></div><div class=paragraph><p>Desde un punto de vista de alto nivel, puede considerar tres tipos de primitivas de sincronización en el kernel de FreeBSD:</p></div><div class=ulist><ul><li><p>operaciones atómicas y barreras de memoria</p></li><li><p>Locks</p></li><li><p>barreras de planificación</p></li></ul></div><div class=paragraph><p>A continuación hay descripciones de las 3 familias. Para cada bloqueo, deberías consultar la página de manual vinculada (cuando sea posible) para obtener explicaciones más detalladas.</p></div><div class=sect4><h5 id=freebsd-atomic-op>3.2.1.1. Operaciones atómicas y barreras de memoria<a class=anchor href=#freebsd-atomic-op></a></h5><div class=paragraph><p>Las operaciones atómicas se implementan a través de un conjunto de funciones que realizan aritmética simple sobre operandos de memoria de forma atómica con respecto a eventos externos (interrupciones, apropiación, etc.). Las operaciones atómicas pueden garantizar la atomicidad solo en tipos de datos pequeños (en el orden de magnitud del tipo de datos <code>.long.</code> de arquitectura C), por lo que rara vez se debe usar directamente en el código de nivel final, sino solo para operaciones muy simples (como la configuración de flags en un mapa de bits, por ejemplo). De hecho, es bastante simple y común escribir una semántica incorrecta basada solo en operaciones atómicas (generalmente llamadas "sin bloqueo"). El kernel de FreeBSD ofrece una forma de realizar operaciones atómicas junto con una barrera de memoria. Las barreras de memoria garantizarán que ocurra una operación atómica siguiendo un orden específico con respecto a otros accesos a la memoria. Por ejemplo, si necesitamos que ocurra una operación atómica justo después de que se completen todas las demás escrituras pendientes (en términos de instrucciones que reordenan las actividades de buffer), necesitamos usar explícitamente una barrera de memoria junto con esta operación atómica. Por lo tanto, es sencillo entender por qué las barreras de memoria juegan un papel clave para la construcción de bloqueos de alto nivel (como refcounts, mutexes, etc.). Para obtener una explicación detallada sobre las operaciones atómicas, consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=atomic&amp;sektion=9&amp;format=html">atomic(9)</a>. Sin embargo, se está lejos de señalar que las operaciones atómicas (y las barreras de memoria también) deberían idealmente usarse solo para construir bloqueos frontales (como mutex).</p></div></div><div class=sect4><h5 id=freebsd-refcounts>3.2.1.2. Contadores de referencias<a class=anchor href=#freebsd-refcounts></a></h5><div class=paragraph><p>Los refcounts son interfaces para manejar contadores de referencia. Se implementan a través de operaciones atómicas y están destinadas a usarse solo en casos donde el contador de referencia es lo único que debe protegerse, por lo que incluso algo como un spin-mutex está en desuso. El uso de la interfaz refcount para estructuras, donde ya se usa un mutex, a menudo es incorrecto, ya que probablemente deberíamos cerrar el contador de referencia en algunas rutas ya protegidas. Actualmente no existe una página de manual que discuta refcount, solo lee <span class=filename>sys/refcount.h</span> para obtener una descripción general de la API existente.</p></div></div><div class=sect4><h5 id=freebsd-locks>3.2.1.3. Locks<a class=anchor href=#freebsd-locks></a></h5><div class=paragraph><p>El kernel de FreeBSD tiene muchas clases de bloqueos. Cada bloqueo está definido por algunas propiedades peculiares, pero probablemente la más importante es el evento vinculado a los elementos que compiten (o en otros términos, el comportamiento de los hilos que no pueden adquirir el bloqueo). El esquema de bloqueo de FreeBSD presenta tres comportamientos diferentes para los contendientes:</p></div><div class="olist arabic"><ol class=arabic><li><p>iterando</p></li><li><p>bloqueo</p></li><li><p>dormir</p></li></ol></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>los números no son casuales</p></div></td></tr></tbody></table></div></div><div class=sect4><h5 id=freebsd-spinlocks>3.2.1.4. Spin locks<a class=anchor href=#freebsd-spinlocks></a></h5><div class=paragraph><p>Los spinlocks permiten a los que esperan iterar indefinidamente hasta que no pueden adquirir el lock. Un asunto importante que tratar es cuando un hilo compite en un spinlock si no se desplanifica su ejecución. Dado que el kernel de FreeBSD es preventivo, esto expone el spinlock al riesgo de interbloqueos que pueden resolverse simplemente deshabilitando las interrupciones mientras se adquieren. Por esta y otras razones (como la falta de soporte de propagación de prioridad, deficiencias en los esquemas de equilibrio de carga entre las CPU, etc.), los spinlocks están destinados a proteger rutas de código muy pequeñas o, idealmente, no deben usarse en absoluto si no se solicitan explícitamente (explicado más adelante).</p></div></div><div class=sect4><h5 id=freebsd-blocking>3.2.1.5. Bloqueo<a class=anchor href=#freebsd-blocking></a></h5><div class=paragraph><p>Los locks de bloques permiten que los que esperan sean desprogramados y bloqueados hasta que el propietario del lock no lo libere y despierte a uno o más contendientes. Para evitar problemas de inanición, los locks de bloque propagan la prioridad de los que esperan al propietario. Los locks de bloque deben implementarse a través de la interfaz turnstile y están destinados a ser el tipo de bloqueo más utilizado en el núcleo, si no se cumplen condiciones particulares.</p></div></div><div class=sect4><h5 id=freebsd-sleeping>3.2.1.6. Dormir<a class=anchor href=#freebsd-sleeping></a></h5><div class=paragraph><p>Los sleep lock permiten a los que esperan ser desplanificados y ponerse a dormir hasta que el elemento que tiene el lock no lo libere y despierte a uno o más de los elementos dormidos. Puesto que los sleep locks están pensados para proteger grandes rutas de código y de abastecer eventos asíncronos, no hacen ningún tipo de propagación de prioridad. Se deben implementar mediante la interfaz <a href="https://man.freebsd.org/cgi/man.cgi?query=sleepqueue&amp;sektion=9&amp;format=html">sleepqueue(9)</a>.</p></div><div class=paragraph><p>El orden utilizado para adquirir locks es muy importante, no solo por la posibilidad de interbloqueo debido a las inversiones de orden de lock, sino incluso porque la adquisición de locks debe seguir reglas específicas vinculadas a la naturaleza de los locks. Si echas un vistazo a la tabla de arriba, la regla práctica es que si un hilo tiene un lock de nivel n (donde el nivel es el número listado cerca del tipo de lock) no está permitido adquirir un lock de niveles superiores , ya que esto rompería la semántica especificada para una ruta. Por ejemplo, si un hilo tiene un lock de bloque (nivel 2), se le permite adquirir un spin lock (nivel 1) pero no un sleep lock (nivel 3), ya que los locks de bloque están destinados a proteger rutas más pequeñas que el bloqueo de suspensión (sin embargo, estas reglas no se refieren a operaciones atómicas o barreras de programación).</p></div><div class=paragraph><p>Esta es una lista de bloqueo con sus respectivos comportamientos:</p></div><div class=ulist><ul><li><p>spin mutex - iterativo - <a href="https://man.freebsd.org/cgi/man.cgi?query=mutex&amp;sektion=9&amp;format=html">mutex(9)</a></p></li><li><p>sleep mutex - bloqueante - <a href="https://man.freebsd.org/cgi/man.cgi?query=mutex&amp;sektion=9&amp;format=html">mutex(9)</a></p></li><li><p>pool mutex - bloqueante - <a href="https://man.freebsd.org/cgi/man.cgi?query=mtx&amp;sektion=pool&amp;format=html">mtx(pool)</a></p></li><li><p>sleep family - suspendido - <a href="https://man.freebsd.org/cgi/man.cgi?query=sleep&amp;sektion=9&amp;format=html">sleep(9)</a> pause tsleep msleep msleep spin msleep rw msleep sx</p></li><li><p>condvar - suspendido - <a href="https://man.freebsd.org/cgi/man.cgi?query=condvar&amp;sektion=9&amp;format=html">condvar(9)</a></p></li><li><p>rwlock - bloqueante - <a href="https://man.freebsd.org/cgi/man.cgi?query=rwlock&amp;sektion=9&amp;format=html">rwlock(9)</a></p></li><li><p>sxlock - suspendido - <a href="https://man.freebsd.org/cgi/man.cgi?query=sx&amp;sektion=9&amp;format=html">sx(9)</a></p></li><li><p>lockmgr - bloqueante - <a href="https://man.freebsd.org/cgi/man.cgi?query=lockmgr&amp;sektion=9&amp;format=html">lockmgr(9)</a></p></li><li><p>semaphores - bloqueante - <a href="https://man.freebsd.org/cgi/man.cgi?query=sema&amp;sektion=9&amp;format=html">sema(9)</a></p></li></ul></div><div class=paragraph><p>Entre estos bloqueos, solo los mutex, sxlocks, rwlocks y lockmgrs están pensados para manejar recursividad, pero actualmente la recursividad solo es compatible con mutexes y lockmgrs.</p></div></div><div class=sect4><h5 id=freebsd-scheduling>3.2.1.7. Barreras de programación<a class=anchor href=#freebsd-scheduling></a></h5><div class=paragraph><p>Las barreras de programación están destinadas a utilizarse para impulsar la programación multihilo. Consisten principalmente en tres elementos diferentes:</p></div><div class=ulist><ul><li><p>secciones críticas (y preemptividad)</p></li><li><p>sched_bind</p></li><li><p>sched_pin</p></li></ul></div><div class=paragraph><p>Normalmente, estos sólo se deberían utilizar en un contexto particular e incluso aunque muchas veces pueden reemplazar a los locks, se deberían evitar porque no permiten el diagnóstico de problemas simples con las herramientas de depuración de locking (como <a href="https://man.freebsd.org/cgi/man.cgi?query=witness&amp;sektion=4&amp;format=html">witness(4)</a>).</p></div></div><div class=sect4><h5 id=freebsd-critical>3.2.1.8. Secciones críticas<a class=anchor href=#freebsd-critical></a></h5><div class=paragraph><p>El kernel de FreeBSD se ha hecho preemptivo básicamente para tratar con hilos de interrupción. De hecho, para evitar una latencia de interrupción alta, los hilos de tiempo compartido con prioridad pueden ser reemplazados por hilos de interrupción (de esta manera, no necesitan esperar para ser programados como vistas previas de la ruta normal). Un kernel preemptivo, sin embargo, introduce nuevos puntos de carrera que también deben manejarse. A menudo, para hacer frente a la preemptividad, lo más sencillo es desactivarla por completo. Una sección crítica define un fragmento de código (delimitado por el par de funciones <a href="https://man.freebsd.org/cgi/man.cgi?query=critical_enter&amp;sektion=9&amp;format=html">critical_enter(9)</a> y <a href="https://man.freebsd.org/cgi/man.cgi?query=critical_exit&amp;sektion=9&amp;format=html">critical_exit(9)</a>, donde se garantiza que la preemptividad no ocurrirá hasta que el código protegido se ejecute por completo). Esto a menudo puede reemplazar un lock de manera efectiva, pero debe usarse con cuidado para no perder toda la ventaja que brinda la preemptividad.</p></div></div><div class=sect4><h5 id=freebsd-schedpin>3.2.1.9. sched_pin/sched_unpin<a class=anchor href=#freebsd-schedpin></a></h5><div class=paragraph><p>Otra forma de lidiar con la preemptividad es la interfaz <code>sched_pin()</code>. Si un fragmento de código está cerrado en el par de funciones <code>sched_pin()</code> y <code>sched_unpin()</code>, se garantiza que el hilo respectivo, incluso si puede ser reemplazado, siempre se ejecutará en la misma CPU. La fijación (pinning) es muy eficaz en el caso particular en que tenemos que acceder a datos por CPU y asumimos que otros hilos no cambiarán esos datos. La última condición determinará una sección crítica como una condición demasiado fuerte para nuestro código.</p></div></div><div class=sect4><h5 id=freebsd-schedbind>3.2.1.10. sched_bind/sched_unbind<a class=anchor href=#freebsd-schedbind></a></h5><div class=paragraph><p><code>sched_bind</code> es una API que se utiliza para vincular un hilo a una CPU en particular durante todo el tiempo que ejecuta el código, hasta que no lo desvincula la llamada a la función <code>sched_unbind</code>. Esta función tiene un papel clave en situaciones en las que no puedes confiar en el estado actual de las CPU (por ejemplo, en las primeras etapas del arranque), ya que deseas evitar que tu hilo migre a CPUs inactivas. Como <code>sched_bin</code> y <code>sched_unbind</code> manipulan las estructuras internas del planificador, es necesario que estén dentro de la adquisición/liberación <code>sched_lock</code> cuando se usan.</p></div></div></div><div class=sect3><h4 id=freebsd-proc>3.2.2. Estructura de proceso<a class=anchor href=#freebsd-proc></a></h4><div class=paragraph><p>Varias capas de emulación a veces requieren algunos datos adicionales por proceso. Puede administrar estructuras separadas (una lista, un árbol, etc.) que contienen estos datos para cada proceso, pero esto tiende a ser lento y consume memoria. Para solucionar este problema la estructura <code>proc</code> de FreeBSD contiene <code>p_emuldata</code>, que es un puntero vacío a algunos datos específicos de la capa de emulación. La entrada a este <code>proc</code> está protegida por el mutex proc.</p></div><div class=paragraph><p>La estructura <code>proc</code> de FreeBSD contiene una entrada <code>p_sysent</code> que identifica qué ABI está ejecutando este proceso. De hecho, es un puntero al <code>sysentvec</code> descrito arriba. Entonces, comparando este punto con la dirección donde se almacena la estructura <code>sysentvec</code> para la ABI dada podemos determinar si el proceso corresponde a nuestra capa de emulación. El código típicamente se parece a esto:</p></div><div class="literalblock programlisting"><div class=content><pre>if (__predict_true(p-&gt;p_sysent != &amp;elf_Linux(R)_sysvec))
	  return;</pre></div></div><div class=paragraph><p>Como puedes ver, utilizamos el modificador <code>__predict_true</code> para colapsar el caso más común (proceso de FreeBSD) a una simple operación de retorno preservando así un alto rendimiento. Este código debería convertirse en una macro porque actualmente no es muy flexible, es decir no soportamos emulación Linux®64 o procesos Linux® A.OUT en i386.</p></div></div><div class=sect3><h4 id=freebsd-vfs>3.2.3. VFS<a class=anchor href=#freebsd-vfs></a></h4><div class=paragraph><p>El subsistema VFS de FreeBSD es muy complejo pero la capa de emulación de Linux® sólo usa una pequeña parte mediante una API bien definida. Puede operar con vnodes o con manejadores de ficheros. Vnode representa un nodo virtual, es decir es la representación de un nodo en VFS. Otra representación es un manejador de fichero que representa un fichero abierto desde la perspectiva de un proceso. Un manejador de fichero puede representar un socket o un fichero ordinario. Un manejador de fichero contiene un puntero a su vnode. Varios manejadores de fichero pueden apuntar al mismo vnode.</p></div><div class=sect4><h5 id=freebsd-namei>3.2.3.1. namei<a class=anchor href=#freebsd-namei></a></h5><div class=paragraph><p>La rutina <a href="https://man.freebsd.org/cgi/man.cgi?query=namei&amp;sektion=9&amp;format=html">namei(9)</a> es el punto central de entrada para la búsqueda de rutas y su traducción. Recorre la ruta punto por punto desde el comienzo hasta el fin utilizando una función de búsqueda que es interna a VFS. La llamada al sistema <a href="https://man.freebsd.org/cgi/man.cgi?query=namei&amp;sektion=9&amp;format=html">namei(9)</a> puede manejar enlaces simbólicos y rutas absolutas y relativas. Cuando se busca una ruta con <a href="https://man.freebsd.org/cgi/man.cgi?query=namei&amp;sektion=9&amp;format=html">namei(9)</a> se introduce en la caché de nombres. Este comportamiento se puede eliminar. Esta rutina se usa en todo el kernel y su rendimiento es altamente crítico.</p></div></div><div class=sect4><h5 id=freebsd-vn>3.2.3.2. vn_fullpath<a class=anchor href=#freebsd-vn></a></h5><div class=paragraph><p>La función <a href="https://man.freebsd.org/cgi/man.cgi?query=vn_fullpath&amp;sektion=9&amp;format=html">vn_fullpath(9)</a> hace todo lo posible por recorrerse la caché de nombres de VFS y devolver la ruta para un vnode (bloqueado) dado. Este proceso no es fiable pero funciona bien para los casos más comunes. Esta falta de fiabilidad se produce porque depende de la caché de VFS (no recorre las estructuras del medio en cuestión), no funciona con enlaces duros, etc. Esta rutina se usa en varios sitios en el Linuxulator.</p></div></div><div class=sect4><h5 id=freebsd-vnode>3.2.3.3. Operaciones de vnode<a class=anchor href=#freebsd-vnode></a></h5><div class=ulist><ul><li><p><code>fgetvp</code> - dado un hilo y un número de descriptor de fichero devuelve el vnode asociado</p></li><li><p><a href="https://man.freebsd.org/cgi/man.cgi?query=vn_lock&amp;sektion=9&amp;format=html">vn_lock(9)</a> - bloquea un vnode</p></li><li><p><code>vn_unlock</code> - desbloquea un vnode</p></li><li><p><a href="https://man.freebsd.org/cgi/man.cgi?query=VOP_READDIR&amp;sektion=9&amp;format=html">VOP_READDIR(9)</a> - lee un directorio referenciado por un vnode</p></li><li><p><a href="https://man.freebsd.org/cgi/man.cgi?query=VOP_GETATTR&amp;sektion=9&amp;format=html">VOP_GETATTR(9)</a> - obtiene los atributos de un fichero o directorio referenciados por un vnode</p></li><li><p><a href="https://man.freebsd.org/cgi/man.cgi?query=VOP_LOOKUP&amp;sektion=9&amp;format=html">VOP_LOOKUP(9)</a> - busca una ruta a un directorio dado</p></li><li><p><a href="https://man.freebsd.org/cgi/man.cgi?query=VOP_OPEN&amp;sektion=9&amp;format=html">VOP_OPEN(9)</a> - abre un fichero referenciado por un vnode</p></li><li><p><a href="https://man.freebsd.org/cgi/man.cgi?query=VOP_CLOSE&amp;sektion=9&amp;format=html">VOP_CLOSE(9)</a> - cierra un fichero referenciado por un vnode</p></li><li><p><a href="https://man.freebsd.org/cgi/man.cgi?query=vput&amp;sektion=9&amp;format=html">vput(9)</a> - decrementa al contador de uso de un vnode y lo desbloquea</p></li><li><p><a href="https://man.freebsd.org/cgi/man.cgi?query=vrele&amp;sektion=9&amp;format=html">vrele(9)</a> - decrementa el contador de uso de un vnode</p></li><li><p><a href="https://man.freebsd.org/cgi/man.cgi?query=vref&amp;sektion=9&amp;format=html">vref(9)</a> - incrementa el contador de uso de un vnode</p></li></ul></div></div><div class=sect4><h5 id=freebsd-file-handler>3.2.3.4. Operaciones del controlador de archivos<a class=anchor href=#freebsd-file-handler></a></h5><div class=ulist><ul><li><p><code>fget</code> - dado un hilo y un número de descriptor de fichero devuelve el manejador de fichero asociado y lo referencia</p></li><li><p><code>fdrop</code> - elimina una referencia al menejador de fichero</p></li><li><p><code>fhold</code> - referencia un manejador de fichero</p></li></ul></div></div></div></div></div></div><div class=sect1><h2 id=md>4. Parte MD de la capa de emulación de Linux®<a class=anchor href=#md></a></h2><div class=sectionbody><div class=paragraph><p>Esta sección trata de la implementación de la capa de emulación Linux® en el sistema operativo FreeBSD. Primero describe la parte que depende de la arquitectura hablando sobre cómo y dónde se implementa la interacción entre el kernel y el espacio de usuario. Habla acerca de llamadas al sistema, señales, ptrace, traps, arreglos de la pila. Esta parte trata sobre i386 pero está escrita de forma general de forma que otras arquitecturas no deberían ser muy diferentes. La siguiente parte es la parte del Linuxulator independiente de la arquitectura. Esta sección sólo cubre el manejo de i386 y ELF. A.OUT está obsoleto y sin probar.</p></div><div class=sect2><h3 id=syscall-handling>4.1. Manejo de llamadas al sistema<a class=anchor href=#syscall-handling></a></h3><div class=paragraph><p>El manejo de llamadas al sistema está escrito principalmente en <span class=filename>linux_sysvec.c</span>, el cual cubre la mayoría de las rutinas indicadas en la estructura <code>sysentvec</code>. Cuando un proceso Linux® que se ejecuta en FreeBSD realiza una llamada al sistema, la rutina general de llamadas al sistema llama a la rutina linux prepsyscall para el ABI de Linux®.</p></div><div class=sect3><h4 id=linux-prepsyscall>4.1.1. Linux® prepsyscall<a class=anchor href=#linux-prepsyscall></a></h4><div class=paragraph><p>Linux® pasa los argumentos a las llamadas al sistema mediante registros (por eso está limitado a 6 parámetros en i386) mientras que FreeBSD utiliza la pila. La rutina prepsyscall de Linux® debe copiar los parámetros desde los registros a la pila. El orden de los registros es: <code>%ebx</code>, <code>%ecx</code>, <code>%edx</code>, <code>%esi</code>, <code>%edi</code>, <code>%ebp</code>. El truco es que esto es verdad sólo para la <em>mayoría</em> de las llamadas al sistema. Algunas (principalmente <code>clone</code>) utiliza un orden distinto pero se puede arreglar fácilmente introduciendo un parámetro dummy en el prototipo de <code>linux_clone</code>.</p></div></div><div class=sect3><h4 id=syscall-writing>4.1.2. Escritura de syscall<a class=anchor href=#syscall-writing></a></h4><div class=paragraph><p>Cada llamada al sistema implementada en el Linuxulator debe tener su prototipo con varios flags en <span class=filename>syscalls.master</span>. La forma del archivo es:</p></div><div class="literalblock programlisting"><div class=content><pre>...
	AUE_FORK STD		{ int linux_fork(void); }
...
	AUE_CLOSE NOPROTO	{ int close(int fd); }
...</pre></div></div><div class=paragraph><p>La primera columna representa el número de llamada al sistema. La segunda columna es para proporcionar auditoría. La tercera columna representa el tipo de llamada al sistema. Es una de <code>STD</code>, <code>OBSOL</code>, <code>NOPROTO</code> o <code>UNIMPL</code>. <code>STD</code> es una llamada al sistema estándar con un prototipo e implementación completas. <code>OBSOL</code> es una llamada obsoleta que define sólo el prototipo. <code>NOPROTO</code> significa que la llamada al sistema está implementada en otro sitio así que no hay que añadir el prefijo del ABI, etc. <code>UNIMPL</code> significa que la llamada al sistema será sustituida por la llamada <code>nosys</code> (una llamada al sistema que tan sólo muestra un mensaje diciendo que la llamada no está implementada y que devuelve <code>ENOSYS</code>).</p></div><div class=paragraph><p>A partir de <span class=filename>syscalls.master</span> un script genera tres ficheros: <span class=filename>linux_syscall.h</span>, <span class=filename>linux_proto.h</span> y <span class=filename>linux_sysent.c</span>. <span class=filename>linux_syscall.h</span> contiene las definiciones de los nombres de las llamadas al sistema y sus valores numéricos, ejemplo:</p></div><div class="literalblock programlisting"><div class=content><pre>...
#define LINUX_SYS_linux_fork 2
...
#define LINUX_SYS_close 6
...</pre></div></div><div class=paragraph><p><span class=filename>linux_proto.h</span> contiene definiciones de estructuras de argumentos de todas las llamadas al sistema, ejemplo:</p></div><div class="literalblock programlisting"><div class=content><pre>struct linux_fork_args {
  register_t dummy;
};</pre></div></div><div class=paragraph><p>Y finalmente, <span class=filename>linux_sysent.c</span> contiene una estructura que describe la tabla de entrada del sistema, utilizada para enviar una llamada al sistema, por ejemplo:</p></div><div class="literalblock programlisting"><div class=content><pre>{ 0, (sy_call_t *)linux_fork, AUE_FORK, NULL, 0, 0 }, /* 2 = linux_fork */
{ AS(close_args), (sy_call_t *)close, AUE_CLOSE, NULL, 0, 0 }, /* 6 = close */</pre></div></div><div class=paragraph><p>Como puedes ver <code>linux_fork</code> se implementa en el propio Linuxulator de modo que la definición de su tipo es <code>STD</code> y no tiene argumentos lo que se ve por la estructura de argumentos dummy. Por otro lado <code>close</code> es sólo un alias para la llamada <a href="https://man.freebsd.org/cgi/man.cgi?query=close&amp;sektion=2&amp;format=html">close(2)</a> real de FreeBSD de forma que no tiene una estructura de argumentos de linux asociada y en la tabla de entrada al sistema no tiene un prefijo "linux" ya que llama a la función <a href="https://man.freebsd.org/cgi/man.cgi?query=close&amp;sektion=2&amp;format=html">close(2)</a> real del kernel.</p></div></div><div class=sect3><h4 id=dummy-syscalls>4.1.3. Llamadas al sistema ficticias<a class=anchor href=#dummy-syscalls></a></h4><div class=paragraph><p>La capa de emulación de Linux® no es completa ya que algunas llamadas al sistema no están implementadas de forma adecuada y otras no están implementadas en absoluto. La capa de emulación utiliza un método para marcar las llamadas al sistema no implementadas con la macro <code>DUMMY</code>. Estas definiciones dummy se encuentran en <span class=filename>linux_dummy.c</span> en la forma <code>DUMMY(syscall)</code>, que luego se traduce a varios ficheros auxiliares de llamadas al sistema y cuya implementación consiste en imprimir un mensaje diciendo que la llamada no está implementada. El prototipo <code>UNIMPL</code> no se utiliza porque queremos ser capaces de identificar el nombre de la llamada al sistema que fue invocada con el fin de saber qué llamadas al sistema son importantes de implementar.</p></div></div></div><div class=sect2><h3 id=signal-handling>4.2. Manejo de señales<a class=anchor href=#signal-handling></a></h3><div class=paragraph><p>El manejo de señales se hace normalmente en el kernel de FreeBSD para todas las compatibilidades binarias con una llamada a la capa compat-dependiente. La capa de compatibilidad Linux® define la rutina <code>linux_sendsig</code> con este propósito.</p></div><div class=sect3><h4 id=linux-sendsig>4.2.1. Linux® sendsig<a class=anchor href=#linux-sendsig></a></h4><div class=paragraph><p>Esta rutina comprueba primero si la señal se ha instalado con un <code>SA_SIGINFO</code> en cuyo caso llama en su lugar a la rutina <code>linux_rt_sendsig</code>. Además, asigna (o reutiliza uno existente) un contexto de manejador de señal ya existente, luego crea una lista de argumentos para el manejador de señal. Traduce el número de señal basado en la tabla de traducción de señales, asigna un manejador, traduce sigset. Luego guarda contexto para la rutina <code>sigreturn</code> (varios registros, número de trap traducido y máscara de señal). Finalmente, copia el contexto de la señal al espacio de usuario y prepara el contexto para que se ejecute el manejador de señal real.</p></div></div><div class=sect3><h4 id=linux-rt-sendsig>4.2.2. linux_rt_sendsig<a class=anchor href=#linux-rt-sendsig></a></h4><div class=paragraph><p>Esta rutina es similar a <code>linux_sendsig</code>, sólo es diferente la preparación del contexto de la señal. Añade <code>siginfo</code>, <code>ucontext</code> y algunas partes POSIX®. Podría ser interesante considerar si esas dos funciones podrían fusionarse en una sola con el beneficio de una menor duplicación de código y una posible ejecución de código más rápida.</p></div></div><div class=sect3><h4 id=linux-sigreturn>4.2.3. linux_sigreturn<a class=anchor href=#linux-sigreturn></a></h4><div class=paragraph><p>Esta llamada al sistema se utiliza para la devolución desde controlador de señales. Realiza algunas comprobaciones de seguridad y restaura el contexto del proceso original. También desenmascara la señal en la máscara de señal de proceso.</p></div></div></div><div class=sect2><h3 id=ptrace>4.3. Ptrace<a class=anchor href=#ptrace></a></h3><div class=paragraph><p>Muchos derivados de UNIX® implementan la llamada al sistema <a href="https://man.freebsd.org/cgi/man.cgi?query=ptrace&amp;sektion=2&amp;format=html">ptrace(2)</a> para proporcionar diversas características de depuración y traza. Estas características permiten la traza de un proceso para obtener información valiosa acerca del proceso que es trazado, como volcado de registros, cualquier posición de memoria del espacio de direcciones del proceso, etc. y también para trazar procesos para saltar una instrucción o entre entradas al sistema (llamadas al sistema y traps). <a href="https://man.freebsd.org/cgi/man.cgi?query=ptrace&amp;sektion=2&amp;format=html">ptrace(2)</a> también te permite establecer información en los procesos trazados (registros, etc). <a href="https://man.freebsd.org/cgi/man.cgi?query=ptrace&amp;sektion=2&amp;format=html">ptrace(2)</a> es un estándar ampliamente disponible e implementado en la mayoría de UNIX® en todo el mundo.</p></div><div class=paragraph><p>La emulación de Linux® en FreeBSD implementa las características de <a href="https://man.freebsd.org/cgi/man.cgi?query=ptrace&amp;sektion=2&amp;format=html">ptrace(2)</a> en <span class=filename>linux_ptrace.c</span>. Las rutinas para convertir registros entre Linux® y FreeBSD y la llamada al systema real de la emulación de <a href="https://man.freebsd.org/cgi/man.cgi?query=ptrace&amp;sektion=2&amp;format=html">ptrace(2)</a>. La llamada al sistema es un gran bloque switch que implementa su parte contraria en FreeBSD para cada comando de <a href="https://man.freebsd.org/cgi/man.cgi?query=ptrace&amp;sektion=2&amp;format=html">ptrace(2)</a>. Los comandos de <a href="https://man.freebsd.org/cgi/man.cgi?query=ptrace&amp;sektion=2&amp;format=html">ptrace(2)</a> son mayoritariamente iguales entre Linux® y FreeBSD de forma que normalmente sólo se necesita una pequeña modificación. Por ejemplo <code>PT_GETREGS</code> en Linux® opera sobre datos directamente mientras que en FreeBSD utiliza un puntero a los datos de forma que después de ejecutar una llamada a <a href="https://man.freebsd.org/cgi/man.cgi?query=ptrace&amp;sektion=2&amp;format=html">ptrace(2)</a> nativo, se debe hacer un copyout para preservar la semántica de Linux®.</p></div><div class=paragraph><p>La implementación de <a href="https://man.freebsd.org/cgi/man.cgi?query=ptrace&amp;sektion=2&amp;format=html">ptrace(2)</a> en el Linuxulator tiene algunas debilidades. Ha habido algunos "panics" cuando se ha usado <code>strace</code> (que consume <a href="https://man.freebsd.org/cgi/man.cgi?query=ptrace&amp;sektion=2&amp;format=html">ptrace(2)</a>) en el entorno del Linuxulator. Tampoco se ha implementado <code>PT_SYSCALL</code>.</p></div></div><div class=sect2><h3 id=traps>4.4. Trampas<a class=anchor href=#traps></a></h3><div class=paragraph><p>En cualquier momento en el que un proceso Linux® está ejecutándose en un trap de la capa de emulación la propia trap en sí misma es manejada de forma transparente con excepción de la traducción del trap. Linux® y FreeBSD tienen opiniones diferentes sobre lo que es un trap y cómo manejarlas. El código es normalmente muy corto:</p></div><div class="literalblock programlisting"><div class=content><pre>static int
translate_traps(int signal, int trap_code)
{

  if (signal != SIGBUS)
    return signal;

  switch (trap_code) {

    case T_PROTFLT:
    case T_TSSFLT:
    case T_DOUBLEFLT:
    case T_PAGEFLT:
      return SIGSEGV;

    default:
      return signal;
  }
}</pre></div></div></div><div class=sect2><h3 id=stack-fixup>4.5. Reparación de pila<a class=anchor href=#stack-fixup></a></h3><div class=paragraph><p>El editor de enlaces en tiempo de ejecución de (RTLD) espera las llamadas etiquetas AUX en la pila durante una llamada a <code>execve</code> por lo que se debe realizar una reparación para garantizar esto. Por supuesto, cada sistema RTLD es diferente, por lo que la capa de emulación debe proporcionar su propia rutina de reparación de la pila para hacer esto. Linuxulator también. <code>elf_linux_fixup</code> simplemente copia las etiquetas AUX a la pila y ajusta la pila del proceso de espacio de usuario para que apunte justo después de esas etiquetas. Entonces RTLD funciona de manera inteligente.</p></div></div><div class=sect2><h3 id=aout-support>4.6. soporte A.OUT<a class=anchor href=#aout-support></a></h3><div class=paragraph><p>La capa de emulación Linux® en i386 también soporta binarios A.OUT de Linux®. Básicamente todo lo descrito en las secciones anteriores se tiene que implementar para el soporte de A.OUT (además de traducción de traps y envío de señales). El soporte de binarios A.OUT ya no se mantiene, en concreto la emulación de 2.6 ya no trabaja con ello pero esto no causa ningún problema ya que linux-base en ports probablemente no soporta en absoluto los binarios A.OUT. Es probable que se quite el soporte en el futuro. La mayoría de lo necesario para cargar binarios A.OUT de Linux® está en el fichero <span class=filename>imgact_linux.c</span>.</p></div></div></div></div><div class=sect1><h2 id=mi>5. Parte MI de la capa de emulación Linux®<a class=anchor href=#mi></a></h2><div class=sectionbody><div class=paragraph><p>Esta sección trata acerca de la parte del Linuxulator que es independiente de la arquitectura. Cubre la infraestructura de emulación necesaria para Linux® 2.6, la implementación en i386 del almacenamiento local para hilos (TLS) y futexes. Después hablamos brevemente acerca de algunas llamadas al sistema.</p></div><div class=sect2><h3 id=nptl-desc>5.1. Descripción de NPTL<a class=anchor href=#nptl-desc></a></h3><div class=paragraph><p>Una de las áreas de mayor progreso en el desarrollo de Linux® 2.6 fue el multihilo. Antes de 2.6, el soporte de multihilo de Linux® estaba implementado en la librería linuxthreads. La librería era una implementación parcial de hilos POSIX®. El sistema de hilos se implementó utilizando procesos separados para cada hilo utilizando la llamada al sistema <code>clone</code> para dejarles compartir el espacio de direcciones (y otras cosas). La principal debilidad de esta aproximación era que cada hilo tenía un PID diferente, el envío de señales estaba roto (desde la perspectiva de pthreads), etc. Tampoco el rendimiento era muy bueno (uso de señales <code>SIGUSR</code> para sincronización de hilos, consumo de recursos del kernel, etc.) de forma que para solucionar estos problemas se desarrolló un nuevo sistema de hilos que se llamó NPTL.</p></div><div class=paragraph><p>La librería NPTL se centraba en dos cosas pero una tercera surgió de forma que se considera parte de NPTL. Esas dos cosas eran introducir hilos en la estructura de un proceso y los futexes. La tercera cosa adicional fue TLS, que no es necesaria directamente para NPTL pero toda la librería NPTL en espacio de usuario depende de ello. Todas estas mejoras resultaron en mucho mejor rendimiento y adhesión a los estándares. NPTL es a día de hoy una librería de hilos estándar en los sistemas Linux®.</p></div><div class=paragraph><p>La implementación del Linuxulator de FreeBSD se aproxima a la NTPL en tres áreas principales. TLS, futexes y renombrado de PID que se utiliza para simular hilos de Linux®. Secciones posteriores describen cada una de estas áreas.</p></div></div><div class=sect2><h3 id=linux26-emu>5.2. Infraestructura de emulación de Linux® 2.6<a class=anchor href=#linux26-emu></a></h3><div class=paragraph><p>Estas secciones tratan con la forma en la que se gestionan los hilos de Linux® y cómo lo simulamos en FreeBSD.</p></div><div class=sect3><h4 id=linux26-runtime>5.2.1. Determinación del entorno de ejecución de la emulación 2.6<a class=anchor href=#linux26-runtime></a></h4><div class=paragraph><p>La capa de emulación de Linux® en FreeBSD soporta la configuración del entorno de ejecución de la versión emulada. Esto se hace vía <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a>, en concreto <code>compat.linux.osrelease</code>. Establecer esta <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> afecta al comportamiento del entorno de ejecución de la capa de emulación. Cuando se establece a 2.6.x se establece el valor de <code>linux_use_linux26</code> mientras que si se establece a otra cosa no se pone nada. Esta variable (más las variables correspondientes del mismo tipo por cada jail) determinan qué infraestructura 2.6 (principalmente PID mangling) se usa o no en el código. El establecimiento de la versión se realiza en todo el sistema y afecta a todos los procesos Linux®. <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> no se debería cambiar cuando un binario Linux® se está ejecutando ya que podría romper algo.</p></div></div><div class=sect3><h4 id=linux-proc-thread>5.2.2. Procesos Linux® e identificadores de hilos<a class=anchor href=#linux-proc-thread></a></h4><div class=paragraph><p>Las semánticas de los hilos en Linux® son un poco confusas y utilizan una nomenclatura completamente diferente a la utilizada en FreeBSD. Un proceso en Linux® consiste en una <code>struct task</code> que contiene dos campos identificadores PID y TGID. PID <em>no</em> es el ID del proceso sino el ID del hilo. El TGID identifica a un grupo de hilos o en otras palabras, a un proceso. Para procesos monohilo el PID es igual al TGID.</p></div><div class=paragraph><p>El hilo en NPTL es tan sólo un proceso ordinario que resulta que tiene un TGID que no es igual al PID y que tiene un líder de grupo que no es él mismo (y VM compartida etc. por supuesto). Todo lo demás sucede de la misma forma que en un proceso ordinario. No hay separación entre un estado compartido y una estructura externa como en FreeBSD. Esto crea algo de información duplicada y una posible inconsistencia de datos. El kernel de Linux® aparentemente utiliza la información de task→group en algunos sitios y la información de la tarea en otros sitios y no es muy consistente y es propensa a errores.</p></div><div class=paragraph><p>Cada hilo NPTL se crea mediante una llamada a la llamada al sistema <code>clone</code> con un conjunto específico de flags (más en la siguiente subsección). La librería NPTL implementa un mecanismo de hilos estricto 1:1.</p></div><div class=paragraph><p>En FreeBSD emulamos hilos NPTL con procesos FreeBSD ordinarios que comparten espacio VM, etc. y la gimnasia que se hace con el PID simplemente se imita en la estructura específica de emulación adjunta al proceso. La estructura adjunta al proceso se ve así:</p></div><div class="literalblock programlisting"><div class=content><pre>struct linux_emuldata {
  pid_t pid;

  int *child_set_tid; /* in clone(): Child.s TID to set on clone */
  int *child_clear_tid;/* in clone(): Child.s TID to clear on exit */

  struct linux_emuldata_shared *shared;

  int pdeath_signal; /* parent death signal */

  LIST_ENTRY(linux_emuldata) threads; /* list of linux threads */
};</pre></div></div><div class=paragraph><p>El PID se utiliza para identificar el proceso de FreeBSD que contiene esta estructura. Los campos <code>child_se_tid</code> y <code>child_clear_tid</code> se usan para hacer un copyout de la dirección del TID cuando un proceso sale y es creado. El puntero <code>shared</code> apunta a una estructura compartida entre los hilos. La variable <code>pdeath_signal</code> identifica la señal de morir del padre y el punto <code>threads</code> se utiliza para enlazar esta estructura a la lista de hilos. La estructura <code>linux_emuldata_shared</code> tiene este aspecto:</p></div><div class="literalblock programlisting"><div class=content><pre>struct linux_emuldata_shared {

  int refs;

  pid_t group_pid;

  LIST_HEAD(, linux_emuldata) threads; /* head of list of linux threads */
};</pre></div></div><div class=paragraph><p><code>refs</code> es un contador de referencias que se usa para determinar cuándo liberar la estructura para evitar pérdidas de memoria. <code>group_id</code> se usa para identificar el PID (=TGID) de todo el proceso (=grupo de hilos). El puntero <code>threads</code> es la cabecera de la lista de hilos en el proceso.</p></div><div class=paragraph><p>La estructura <code>linux_emuldata</code> se puede obtener a partir del proceso utilizando <code>em_find</code>. El prototipo de la función es:</p></div><div class="literalblock programlisting"><div class=content><pre>struct linux_emuldata *em_find(struct proc *, int locked);</pre></div></div><div class=paragraph><p>Aquí, <code>proc</code> es el proceso del cual queremos la estructura emuldata y el parámetro locked determina si queremos o no bloquear. Los valores aceptados son <code>EMUL_DOLOCK</code> y <code>EMUL_DOUNLOCK</code>. Más acerca de esto después.</p></div></div><div class=sect3><h4 id=pid-mangling>5.2.3. Ajuste de PID<a class=anchor href=#pid-mangling></a></h4><div class=paragraph><p>Puesto que hay una diferencia en la visión en cuanto a la idea de ID de proceso e ID de hilo entre FreeBSD y Linux® tenemos que traducir esa visión de algún modo. Lo hacemos modificando el PID. Esto significa que falseamos lo que son el PID (=TGID) y el TID (=PID) entre el kernel y el espacio de usuario. La regla básica es que en el kernel (en el Linuxulator) PID = PID y TGID = shared → group pid y que en espacio de usuario presentamos <code>PID = shared → group_pid</code> y <code>TID = proc → p_pid</code>. El miembro PID de la estructura <code>linux_emuldata</code> es un PID de FreeBSD.</p></div><div class=paragraph><p>Lo descrito arriba afecta principalmente a las llamadas al sistema getpid, getppid y gettid. Donde utilizamos PID/TGID respectivamente. Al hacer el copyout de los TID en <code>child_clear_tid</code> y <code>child_set_tid</code> copiamos hacia afuera el PID de FreeBSD.</p></div></div><div class=sect3><h4 id=clone-syscall>5.2.4. Llamada al sistema clone<a class=anchor href=#clone-syscall></a></h4><div class=paragraph><p>La llamada al sistema <code>clone</code> es la forma en la que se crean hilos en Linux®. El prototipo de la llamada es como este:</p></div><div class="literalblock programlisting"><div class=content><pre>int linux_clone(l_int flags, void *stack, void *parent_tidptr, int dummy,
void * child_tidptr);</pre></div></div><div class=paragraph><p>El parámetro <code>flags</code> le dice a la llamada al sistema cómo se tiene que clonar el proceso exactamente. Como se ha descrito arriba, Linux® puede crear procesos compartiendo varias cosas de forma independiente, por ejemplo dos procesos pueden compartir descriptores de ficheros pero no VM, etc. El último byte del parámetro <code>flags</code> es la señal de salida del proceso recién creado. El parámetro <code>stack</code> si no es <code>NULL</code> indica dónde está la pila del hilo y si es <code>NULL</code> se supone que debemos hacer un copy-on-write de la pila del proceso que llama (es decir hacer lo que hace la rutina <a href="https://man.freebsd.org/cgi/man.cgi?query=fork&amp;sektion=2&amp;format=html">fork(2)</a> normal). El parámetro <code>parent_tidptr</code> se usa como dirección para copiar hacia afuera el PID del proceso (es decir, el id del hilo) una vez que el proceso está suficientemente instanciado pero todavía no es ejecutable. El parámetro <code>dummy</code> está aquí por la convención de llamada tan extraña que tiene esta llamada al sistema en i386. Usa los registros directamente y deja que lo haga el compilador por lo que se necesita una llamada al sistema dummy. El parámetro <code>child_tidptr</code> se usa como dirección para copiar hacia afuera el PID una vez que el proceso ha terminado de crearse y cuando el proceso sale.</p></div><div class=paragraph><p>La llamada al sistema en sí procede estableciendo los flags correspondientes dependiendo de los flags que se le hayan pasado. Por ejemplo, <code>CLONE_VM</code> se corresponde con RFMEM (compartir VM), etc. El único detalle aquí son <code>CLONE_FS</code> y <code>CLONE_FILES</code> porque FreeBSD no permite establecerlos por separado por lo que lo falseamos al no establecer RFFDG (la copia de la tabla de descriptores de fichero y otra información de sistemas de ficheros) si alguno de los dos está definido. Esto no causa problemas porque esos dos flags siempre se establecen juntos. Después de establecer los flags el proceso se bifurca utilizando la rutina interna <code>fork1</code>, se insta a que el proceso no sea puesto en una cola de ejecución, es decir no se establece como ejecutable. Después de terminar el bifurcado posiblemente establezcamos el padre al nuevo proceso creado para emular la semántica de <code>CLONE_PARENT</code>. La siguiente parte es crear los datos de emulación. Los hilos en Linux® no señalizan a sus padres de forma que establecemos la señal exit a 0 para desabilitar esto. Después se establecen <code>child_set_tid</code> y <code>child_clear_tid</code> activando esta funcionalidad posteriormente en el código. En este punto copiamos el PID hacia afuera en la dirección especificada por <code>parent_tidptr</code>. La configuración de la pila del proceso se realiza simplemente reescribiendo el registro de marco de hilo <code>%esp</code> (<code>%rsp</code> en amd64). La siguiente parte es configurar TLS para el proceso recién creado. Después de esto ya se pueden emular las semánticas de <a href="https://man.freebsd.org/cgi/man.cgi?query=vfork&amp;sektion=2&amp;format=html">vfork(2)</a> y finalmente el proceso creado se pone en una cola de ejecución y se copia su PID en el proceso padre mediante el valor de retorno de <code>clone</code>.</p></div><div class=paragraph><p>La llamada al sistema <code>clone</code> es capaz y de hecho se usa para emular las llamadas al sistema clásicas <a href="https://man.freebsd.org/cgi/man.cgi?query=fork&amp;sektion=2&amp;format=html">fork(2)</a> y <a href="https://man.freebsd.org/cgi/man.cgi?query=vfork&amp;sektion=2&amp;format=html">vfork(2)</a>. Versiones nuevas de glibc funcionando con kernels 2.6 usan <code>clone</code> para implementar las llamadas a <a href="https://man.freebsd.org/cgi/man.cgi?query=fork&amp;sektion=2&amp;format=html">fork(2)</a> y <a href="https://man.freebsd.org/cgi/man.cgi?query=vfork&amp;sektion=2&amp;format=html">vfork(2)</a>.</p></div></div><div class=sect3><h4 id=locking>5.2.5. Bloqueos<a class=anchor href=#locking></a></h4><div class=paragraph><p>El mecanismo de bloqueo se implementa por cada subsistema porque no esperamos en ellos mucha contención. Hay dos locks: <code>emul_lock</code> se usa para manipular de forma segura <code>linux_emuldata</code> y <code>emul_shared_lock</code> se usa para manipular <code>linux_emuldata_shared</code>. <code>emul_lcok</code> es un mutex con el que no se puede dormir mientras que <code>emul_shared_lock</code> es un <code>sx_lock</code> con el que se puede dormir. Debido al mecanismo de bloqueo por subsistema podemos juntar algunos locks y por eso em_find proporciona acceso sin necesidad de bloqueos.</p></div></div></div><div class=sect2><h3 id=tls>5.3. TLS<a class=anchor href=#tls></a></h3><div class=paragraph><p>Esta sección trata sobre TLS, también conocido como almacenamiento local de hilos.</p></div><div class=sect3><h4 id=trheading-intro>5.3.1. Introducción al manejo de hilos<a class=anchor href=#trheading-intro></a></h4><div class=paragraph><p>Los hilos en ciencias de la computación son entidades en un proceso que pueden ser planificadas de forma independiente al resto de hilos. Los hilos de un proceso comparten muchos datos del proceso (descriptores de fichero, etc) pero también tienen su propia pila para sus propios datos. Algunas veces hay necesidad para tener datos de nivel de proceso pero específicos para un determinado hilo. Imagina el nombre de un hilo en ejecución o algo así. El API de hilos tradicional de UNIX®, pthreads proporciona un método para hacerlo mediante <a href="https://man.freebsd.org/cgi/man.cgi?query=pthread_key_create&amp;sektion=3&amp;format=html">pthread_key_create(3)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=pthread_setspecific&amp;sektion=3&amp;format=html">pthread_setspecific(3)</a> y <a href="https://man.freebsd.org/cgi/man.cgi?query=pthread_getspecific&amp;sektion=3&amp;format=html">pthread_getspecific(3)</a> donde un hilo puede crear una clave para el dato local del hilo y manipular ese dato mediante <a href="https://man.freebsd.org/cgi/man.cgi?query=pthread_getspecific&amp;sektion=3&amp;format=html">pthread_getspecific(3)</a> o <a href="https://man.freebsd.org/cgi/man.cgi?query=pthread_getspecific&amp;sektion=3&amp;format=html">pthread_getspecific(3)</a>. Se definió una nueva palabra clave que especifica que una variable es específica de un hilo. Puedes ver que esta no es la forma más cómoda de conseguir este objetivo. De forma que varios creadores de compiladores de C/C++ introdujeron un mecanismo mejor. También se desarrolló un nuevo método para acceder a dichas variables (al menos en i386). El método de pthreads se suele implementar en espacio de usuario como una tabla de búsqueda trivial. El rendimiento de esta solución no es muy bueno. El nuevo método utiliza registros de segmento (en i386) para direccionar un segmento donde se almacena el área TLS de forma que el acceso real a la variable del hilo consisten en añadir el registro del segmento a la dirección y acceder mediante ella. Los registros de segmento son normalmente <code>%gs</code> y <code>%fs</code> y actúan como selectores de segmentos. Cada hilo tiene su propia área donde se almacenan lo datos locales al hilo y el segmento se tiene que cargar en cada cambio de contexto. Este método es muy rápido y se utiliza casi en exclusiva en el mundo i386 de UNIX®. Tanto FreeBSD como Linux® implementan esta aproximación y se obtienen muy buenos resultados. El único problema es la necesidad de recargar el segmento en cada cambio de contexto lo que puede hacer los cambios de contexto más lentos. FreeBSD intenta evitar esta sobrecargar utilizando sólo 1 descriptor de segmento para esto mientras que Linux® utiliza 3. Algo interesante es que prácticamente nada utiliza más de 1 descriptor (sólo Wine parece utilizar 2) de forma que Linux® para un precio innecesario por los cambios de contexto.</p></div></div><div class=sect3><h4 id=i386-segs>5.3.2. Segmentos en i386<a class=anchor href=#i386-segs></a></h4><div class=paragraph><p>La arquitectura i386 implementa los llamados segmentos. Un segmento es una descripción de un área de memoria. La dirección base (abajo) del área de memoria, el final (techo), tipo, protección, etc. Se puede acceder a la memoria descrita por un segmento utilizando un registro de selección de segmento (<code>%cs</code>, <code>%ds</code>, <code>%ss</code>, <code>%es</code>, <code>%fs</code>, <code>%gs</code>). Por ejemplo supongamos que tenemos un segmento cuya dirección base es 0x1234 y también tenemos su longitud y este código:</p></div><div class="literalblock programlisting"><div class=content><pre>mov %edx,%gs:0x10</pre></div></div><div class=paragraph><p>Esto cargará el contenido del registro <code>%edx</code> en la ubicación de memoria 0x1244. Algunos registros de segmento tienen un uso especial, por ejemplo <code>%cs</code> se utiliza para el segmento de código y <code>%ss</code> se utiliza para el segmento de pila pero <code>%fs</code> y <code>%gs</code> generalmente no se utilizan. Los segmentos se almacenan en una tabla GDT global o en una tabla LDT local. Se accede a LDT a través de una entrada en el GDT. El LDT puede almacenar más tipos de segmentos. LDT puede ser por proceso. Ambas tablas definen hasta 8191 entradas.</p></div></div><div class=sect3><h4 id=linux-i386>5.3.3. Implementación en Linux® i386<a class=anchor href=#linux-i386></a></h4><div class=paragraph><p>Hay dos formas principales de establecer TLS en Linux®. Se puede establecer cuando se clona un proceso con la llamada al sistema <code>clone</code> o se puede llamar a <code>set_thread_area</code>. Cuando un proceso para el flag <code>CLONE_SETTLS</code> a <code>clone</code>, el kernel espera que la memoria apuntada por el registro <code>%esi</code> sea una representación en espacio de usuario de un segmento Linux® que se traduce a la representación máquina de un segmento y se carga en una entrada de la GDT. La entrada de la GDT se puede especificar con un número o se puede usar -1 que significa que el sistema puede escoger la primera entrada que encuentre libre. En la práctica, la gran mayoría de programas utilizan sólo una entrada TLS y no se preocupan acerca del número de la misma. Aprovechamos esto en la emulación y de hecho dependemos de ello.</p></div></div><div class=sect3><h4 id=tls-emu>5.3.4. Emulación del TLS de Linux®<a class=anchor href=#tls-emu></a></h4><div class=sect4><h5 id=tls-i386>5.3.4.1. i386<a class=anchor href=#tls-i386></a></h5><div class=paragraph><p>La carga del TLS del hilo actual se realiza llamando a <code>set_thread_area</code> mientras que la carga del TLS para un segundo proceso en <code>clone</code> se realiza en el bloque separado en <code>clone</code>. Estas dos funciones son muy parecidas. La única diferencia es la carga del segmento GDT que sucede en el siguiente cambio de contexto para el nuevo proceso creado mientras que <code>set_thread_area</code> tiene que cargarlos directamente. El código básicamente hace esto. Copia la forma Linux® del descriptor de segmento desde el espacio de usuario. El código comprueba el número del descriptor pero como difieren entre FreeBSD y Linux® lo falseamos un poco. Sólo soportamos los índices 6, 3 y -1. El 6 es un número genuino de Linux®, el tres es genuino de FreeBSD y el -1 significa autoselección. Después establecemos el número del descriptor de forma constante a 3 y lo copiamos de vuelva a espacio de usuario. Dependemos de que el proceso en espacio de usuario use el número del descriptor pero esto funciona casi siempre (no he visto nunca un caso donde no funciones) ya que el proceso de espacio de usuario normalmente pasa -1. Después convertimos el descriptor de la forma Linux® a una forma dependiente de la máquina (es decir forma independiente del sistema operativo) y lo copiamos al descriptor de segmento definido en FreeBSD. Finalmente podemos cargarlo. Asignamos el descriptor en los PCB (bloque de control de proceso) de los hilos y cargamos el segmento <code>%gs</code> utilizando <code>load_gs</code>. Esta carga se tiene que hacer dentro de una sección crítica de forma que nada la interrumpa. El caso <code>CLONE_SETTLS</code> funciona exactamente así salvo que no se realiza la carga utilizando <code>load_gs</code>. El segmento que se usa para esto (número de segmento 3) se comparte para este uso entre los procesos de FreeBSD y de Linux® de forma que la capa de emulación Linux® no añade nada de sobrecarga respecto al funcionamiento normal de FreeBSD.</p></div></div><div class=sect4><h5 id=tls-amd64>5.3.4.2. amd64<a class=anchor href=#tls-amd64></a></h5><div class=paragraph><p>La implementación de amd64 es similar a la de i386, pero inicialmente no se utilizó un descriptor de segmento de 32 bits para este propósito (por lo tanto, ni siquiera los usuarios nativos de TLS de 32 bits funcionaban), por lo que tuvimos que agregar dicho segmento e implementar su carga en cada cambio de contexto (cuando se establece el flag de uso de 32 bits). Aparte de esto, la carga de TLS es exactamente la misma, solo que los números de segmento son diferentes y el formato del descriptor y la carga difieren ligeramente.</p></div></div></div></div><div class=sect2><h3 id=futexes>5.4. Futexes<a class=anchor href=#futexes></a></h3><div class=sect3><h4 id=sync-intro>5.4.1. Introducción a la sincronización<a class=anchor href=#sync-intro></a></h4><div class=paragraph><p>Los hilos necesitan algún tipo de sincronización y POSIX® proporciona algunos de ellos: mutex para exclusión mutua, locks de lectura y escritura para exclusión mutua con una proporción sesgada de lecturas y escrituras y variables de condición para señalar un cambio de estado. Es interesante notar que la API de hilos de POSIX® carece de soporte para semáforos. Esas implementaciones de rutinas de sincronización dependen en gran medida del tipo de soporte de hilos que tenemos. En el modelo puro 1:M (espacio de usuario), la implementación se puede realizar únicamente en el espacio de usuario y, por lo tanto, es muy rápida (las variables de condición probablemente terminarán implementándose mediante señales, es decir, no tan rápido) y simple. En el modelo 1:1, la situación también es bastante clara: los hilos deben sincronizarse utilizando las primitivas del kernel (lo cual es muy lento porque se debe realizar una llamada al sistema). El escenario mixto M:N simplemente combina el primer y segundo enfoque o se basa únicamente en el kernel. La sincronización de hilos es una parte vital de la programación habilitada para hilos y su rendimiento puede afectar mucho al programa resultante. Pruebas de rendimiento recientes en el sistema operativo FreeBSD mostraron que una implementación mejorada de sx_lock producía un 40% de aceleración en <em>ZFS</em> (un usuario intensivo de sx), esto es algo dentro del kernel pero muestra claramente cuán importante es el rendimiento de las primitivas de sincronización.</p></div><div class=paragraph><p>Los programas multihilo se deberían escribir con la menor contención posible. De otro modo en lugar de hacer trabajo útil el hilo simplemente espera en un bloqueo. Como resultado los programas mejores escritos muestran poca contención en bloqueos.</p></div></div><div class=sect3><h4 id=futex-intro>5.4.2. Introducción a los futexes<a class=anchor href=#futex-intro></a></h4><div class=paragraph><p>Linux® implementa multihilo 1:1, es decir tiene que utilizar primitivas de sincronización dentro del kernel. Como se ha dicho antes, un programa bien escrito tiene poca contención. Así que una secuencia típica se podría realizar como dos incrementos/decrementos de contadores de referencia mutex atómicos, lo que es muy rápido, como se muestra en el siguiente ejemplo:</p></div><div class="literalblock programlisting"><div class=content><pre>pthread_mutex_lock(&amp;mutex);
...
pthread_mutex_unlock(&amp;mutex);</pre></div></div><div class=paragraph><p>El modelo 1:1 nos obliga a realizar dos llamadas al sistema para esas llamadas mutex, lo cual es muy lento.</p></div><div class=paragraph><p>La solución que implementa Linux® 2.6 se llama futexes. Los futexes implementan la comprobación de la contención en espacio de usuario y llaman al kernel sólo en caso de contención. Por lo tanto el caso típico tiene lugar sin intervención del kernel. Esto ofrece una implementación de primitivas de sincronización razonablemente rápidas y flexibles.</p></div></div><div class=sect3><h4 id=futex-api>5.4.3. Futex API<a class=anchor href=#futex-api></a></h4><div class=paragraph><p>La llamada al sistema futex se ve así:</p></div><div class="literalblock programlisting"><div class=content><pre>int futex(void *uaddr, int op, int val, struct timespec *timeout, void *uaddr2, int val3);</pre></div></div><div class=paragraph><p>En este ejemplo <code>uaddr</code> es una dirección del mutex en espacio de usuario, <code>op</code> es una operación que estamos a punto de realizar y los otros parámetros tienen significados por operación.</p></div><div class=paragraph><p>Los Futexes implementan las siguientes operaciones:</p></div><div class=ulist><ul><li><p><code>FUTEX_WAIT</code></p></li><li><p><code>FUTEX_WAKE</code></p></li><li><p><code>FUTEX_FD</code></p></li><li><p><code>FUTEX_REQUEUE</code></p></li><li><p><code>FUTEX_CMP_REQUEUE</code></p></li><li><p><code>FUTEX_WAKE_OP</code></p></li></ul></div><div class=sect4><h5 id=futex-wait>5.4.3.1. FUTEX_WAIT<a class=anchor href=#futex-wait></a></h5><div class=paragraph><p>Esta operación verifica que se ha escrito el valor <code>val</code> en la dirección <code>uaddr</code>. Si no, se devuelve <code>EWOULDBLOCK</code>, de otro modo el hilo se encola en el futex y se suspende. Si el argumento <code>timeout</code> no es cero entonces especifica el tiempo máximo para estar durmiendo, de lo contrario se duerme indefinidamente.</p></div></div><div class=sect4><h5 id=futex-wake>5.4.3.2. FUTEX_WAKE<a class=anchor href=#futex-wake></a></h5><div class=paragraph><p>Esta operación toma un futex en la dirección <code>uaddr</code> y despierta los primeros <code>val</code> futexes encolados en el futex.</p></div></div><div class=sect4><h5 id=futex-fd>5.4.3.3. FUTEX_FD<a class=anchor href=#futex-fd></a></h5><div class=paragraph><p>Esta operación asocia un descriptor de archivo con un futex dado.</p></div></div><div class=sect4><h5 id=futex-requeue>5.4.3.4. FUTEX_REQUEUE<a class=anchor href=#futex-requeue></a></h5><div class=paragraph><p>Esta operación toma <code>val</code> hilos encolados en el futex que está en la dirección <code>uaddr</code>, los despierta y toma los siguientes <code>val2</code> hilos y los reencola en el futex en la dirección <code>uaddr2</code>.</p></div></div><div class=sect4><h5 id=futex-cmp-requeue>5.4.3.5. FUTEX_CMP_REQUEUE<a class=anchor href=#futex-cmp-requeue></a></h5><div class=paragraph><p>Esta operación hace lo mismo que <code>FUTEX_REQUEUE</code> pero primero comprueba que <code>val3</code> sea igual que <code>val</code>.</p></div></div><div class=sect4><h5 id=futex-wake-op>5.4.3.6. FUTEX_WAKE_OP<a class=anchor href=#futex-wake-op></a></h5><div class=paragraph><p>Esta operación realiza una operación atómica en <code>val3</code> (que contiene otro valor codificado) y <code>uaddr</code>. Después despierta <code>val</code> hilos en el futex de la dirección <code>uaddr</code> y si la operación atómica devolvió un número positivo despierta <code>val2</code> hilos en el futex de la dirección <code>uaddr2</code>.</p></div><div class=paragraph><p>Las operaciones implementadas en <code>FUTEX_WAKE_OP</code>:</p></div><div class=ulist><ul><li><p><code>FUTEX_OP_SET</code></p></li><li><p><code>FUTEX_OP_ADD</code></p></li><li><p><code>FUTEX_OP_OR</code></p></li><li><p><code>FUTEX_OP_AND</code></p></li><li><p><code>FUTEX_OP_XOR</code></p></li></ul></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>No hay parámetro <code>val2</code> en el prototipo de futex. <code>val2</code> se toma del parámetro <code>struct timespec *timeout</code> para las operaciones <code>FUTEX_REQUEUE</code>, <code>FUTEX_CMP_REQUEUE</code> y <code>FUTEX_WAKE_OP</code>.</p></div></td></tr></tbody></table></div></div></div><div class=sect3><h4 id=futex-emu>5.4.4. Emulación Futex en FreeBSD<a class=anchor href=#futex-emu></a></h4><div class=paragraph><p>La emulación de futex en FreeBSD ha sido importada de NetBSD y después extendida por nosotros. Se encuentra en los ficheros <code>linux_futex.c</code> y <span class=filename>linux_futex.h</span>. La estructura <code>futex</code> tiene este aspecto:</p></div><div class="literalblock programlisting"><div class=content><pre>struct futex {
  void *f_uaddr;
  int f_refcount;

  LIST_ENTRY(futex) f_list;

  TAILQ_HEAD(lf_waiting_paroc, waiting_proc) f_waiting_proc;
};</pre></div></div><div class=paragraph><p>Y la estructura <code>waiting_proc</code> es:</p></div><div class="literalblock programlisting"><div class=content><pre>struct waiting_proc {

  struct thread *wp_t;

  struct futex *wp_new_futex;

  TAILQ_ENTRY(waiting_proc) wp_list;
};</pre></div></div><div class=sect4><h5 id=futex-get>5.4.4.1. futex_get / futex_put<a class=anchor href=#futex-get></a></h5><div class=paragraph><p>Un futex se obtiene utilizando la función <code>futex_get</code>, que busca en una lista lineal de futexes y devuelve el encontrado o crea un nuevo futex. Cuando liberamos un futex llamamos a la función <code>futex_put</code>, que disminuye un contador de referencia del futex y si el refcount llega a cero lo libera.</p></div></div><div class=sect4><h5 id=futex-sleep>5.4.4.2. futex_sleep<a class=anchor href=#futex-sleep></a></h5><div class=paragraph><p>Cuando un futex encola un hilo para que duerma crea una estructura <code>working_proc</code> y la pone en la lista dentro de la estructura del futext, después simplemente llama a <a href="https://man.freebsd.org/cgi/man.cgi?query=tsleep&amp;sektion=9&amp;format=html">tsleep(9)</a> para suspender el hilo. El tiempo de suspensión puede finalizar por timeout. Después de volver the <a href="https://man.freebsd.org/cgi/man.cgi?query=tsleep&amp;sektion=9&amp;format=html">tsleep(9)</a> (el hilo ha sido despertado o ha ocurrido un timeout) se quita la estructura <code>working_proc</code> de la lista y se destruye. Todo esto se hace en la función <code>futex_sleep</code>. Si se nos despertó con <code>futex_wak</code> tenemos <code>wp_new_futex</code> establecido de forma que lo utilizamos para dormir. De este modo el reencolado en realidad se hace en esta función.</p></div></div><div class=sect4><h5 id=futex-wake-2>5.4.4.3. futex_wake<a class=anchor href=#futex-wake-2></a></h5><div class=paragraph><p>Despertar a un hilo que está durmiendo en un futex se hace con la función <code>futex_wake</code>. En esta función lo primero que hacemos es imitar el extraño comportamiento de Linux®, donde despierta N hilos para todas las operaciones, la únca excepción es que las operaciones REQUEUE se hacen en N+1 hilos. Pero normalmente esto no supone ninguna diferencia ya que estamos despertando todos los hilos. Lo siguiente en la función es el bucle en el que despertamos n hilos, después comprobamos si hay algún futex nuevo para reencolar. Si es así, reencolamos un máximo de n2 hilos en el nuevo futex. Esto coopera con <code>futex_sleep</code>.</p></div></div><div class=sect4><h5 id=futex-wake-op-2>5.4.4.4. futex_wake_op<a class=anchor href=#futex-wake-op-2></a></h5><div class=paragraph><p>La operación <code>FUTEX_WAKE_OP</code> is bastante complicada. Primero obtenemos dos futex en las direcciones <code>uaddr</code> y <code>uaddr2</code> después realizamos una operación atómica usando <code>val3</code> y <code>uaddr2</code>. Después se despierta a <code>val</code> hilos que estuvieran durmiendo y si se cumple la condición de la operación atómica despertamos <code>val2</code> (es decir <code>timeout</code>) hilos durmientes en el segundo futex.</p></div></div><div class=sect4><h5 id=futex-atomic-op>5.4.4.5. operación atómica futex<a class=anchor href=#futex-atomic-op></a></h5><div class=paragraph><p>La operación atómica toma dos parámetros <code>encoded_op</code> y <code>uaddr</code>. La operación codificada codifica la operación en sí, comparando valor, argumento de operación y argumento de comparación. El pseudocódigo para la operación es como este:</p></div><div class="literalblock programlisting"><div class=content><pre>oldval = *uaddr2
*uaddr2 = oldval OP oparg</pre></div></div><div class=paragraph><p>Y esto se hace automáticamente. Primero se realiza la copia del número en <code>uaddr</code> y la operación ha terminado. El código maneja fallos de página y si no ocurre ningún se compara <code>oldval</code> con <code>cmparg</code> con el comparador cmp.</p></div></div><div class=sect4><h5 id=futex-locking>5.4.4.6. Bloqueo futex<a class=anchor href=#futex-locking></a></h5><div class=paragraph><p>La implementación de futex utiliza dos listas de bloqueo que protegen <code>sx_lock</code> y locks globales (ya sea Giant u otro <code>sx_lock</code>). Cada operación se realiza estando bloqueada desde el principio hasta el final.</p></div></div></div></div><div class=sect2><h3 id=syscall-impl>5.5. Implementación de varias llamadas al sistema<a class=anchor href=#syscall-impl></a></h3><div class=paragraph><p>En esta sección voy a describir algunas llamadas al sistema más pequeñas que vale la pena mencionar porque su implementación no es obvia o esas llamadas al sistema son interesantes desde otro punto de vista.</p></div><div class=sect3><h4 id=syscall-at>5.5.1. Familia de llamadas al sistema *at<a class=anchor href=#syscall-at></a></h4><div class=paragraph><p>Durante el desarrollo del kernel 2.6.16 de Linux® se añadieron las llamadas al sistema *at. Esas llamadas (<code>openat</code> por ejemplo) funcionan igual que sus pares sin <code>at</code> con la pequeña diferencia del parámetro <code>dirfd</code>. Este parámetro cambia con el fichero dado sobre el que se va a realizar la llamada al sistema. Cuando el parámetro <code>filename</code> es absoluto <code>dirfd</code> es ignorado pero cuando la ruta al fichero es relativa, entra en juego. El parámetro <code>dirfd</code> es un directorio relativo al cual se comprueba la ruta relativa. El parámetro <code>dirfd</code> es un descriptor de fichero de algún directorio o <code>AT_FDCWD</code>. Por ejemplo la llamada al sistema <code>openat</code> podría ser así:</p></div><div class="literalblock programlisting"><div class=content><pre>descriptor de fichero 123 = /tmp/foo/, directorio de trabajo actual = /tmp/

openat(123, /tmp/bah\, flags, mode)	/* opens /tmp/bah */
openat(123, bah\, flags, mode)		/* opens /tmp/foo/bah */
openat(AT_FDWCWD, bah\, flags, mode)	/* opens /tmp/bah */
openat(stdio, bah\, flags, mode)	/* returns error because stdio is not a directory */</pre></div></div><div class=paragraph><p>Esta infraestructura es necesaria para evitar condiciones de carrera cuando se abren ficheros fuera del directorio de trabajo actual. Imagina un proceso que consiste en dos hilos, hilo A e hilo B. El hilo A realiza <code>open(./tmp/foo/bah., flags, mode)</code> y antes de volver es desalojado y se ejecuta el hilo B. El hilo B no se preocupa por las necesidades del hilo A y renombra o elimina <span class=filename>/tmp/foo/</span>. Tenemos una condición de carrera. Para evitar esto podemos abrir <span class=filename>/tmp/foo</span> y utilizarlo como <code>dirfd</code> en la llamada al sistema <code>openat</code>. Esto permite al usuario implementar directorios de trabajo por hilo.</p></div><div class=paragraph><p>La familia *at de llamadas al sistema de Linux® contiene: <code>linux_openat</code>, <code>linux_mkdirat</code>, <code>linux_mknodat</code>, <code>linux_fchownat</code>, <code>linux_futimesat</code>, <code>linux_fstatat64</code>, <code>linux_unlinkat</code>, <code>linux_renameat</code>, <code>linux_linkat</code>, <code>linux_symlinkat</code>, <code>linux_readlinkat</code>, <code>linux_fchmodat</code> y <code>linux_faccessat</code>. Todas se implementan utilizando la rutina modificada <a href="https://man.freebsd.org/cgi/man.cgi?query=nami&amp;sektion=9&amp;format=html">nami(9)</a> y una sencilla capa de envoltorio.</p></div><div class=sect4><h5 id=implementation>5.5.1.1. Implementación<a class=anchor href=#implementation></a></h5><div class=paragraph><p>La implementación se hace modificando la rutina <a href="https://man.freebsd.org/cgi/man.cgi?query=namei&amp;sektion=9&amp;format=html">namei(9)</a> (descrita arriba) para que tenga un parámetro adicional <code>dirfd</code> en su estructura <code>nameidata</code>, que especifica el punto de comienzo de la búsqueda de la ruta en lugar de utilizar el directorio de trabajo cada vez. La resolución de <code>dirfd</code> a vnode a partir del número de descriptor de fichero se hace en las llamadas al sistema *at nativas. Cuando <code>dirfd</code> es <code>AT_FDCWD</code> la entrada <code>dvp</code> en la estructura <code>nameidata</code> es <code>NULL</code> pero cuando <code>dirfd</code> otro número obtenemos el fichero para este descriptor de fichero, comprobamos si el fichero es válido y si tiene un vnode asociado lo obtenemos. Después comprobamos que el vnode sea un directorio. En la rutina <a href="https://man.freebsd.org/cgi/man.cgi?query=namei&amp;sektion=9&amp;format=html">namei(9)</a> real simplemente sustituimos el vnode <code>dvp</code> por la variable <code>dp</code> en la función <a href="https://man.freebsd.org/cgi/man.cgi?query=namei&amp;sektion=9&amp;format=html">namei(9)</a> que determina el punto de comienzo. <a href="https://man.freebsd.org/cgi/man.cgi?query=namei&amp;sektion=9&amp;format=html">namei(9)</a> no se usa directamente sino mediante una traza de diferentes funciones a diferentes niveles. Por ejemplo <code>openat</code> hace esto:</p></div><div class="literalblock programlisting"><div class=content><pre>openat() --&gt; kern_openat() --&gt; vn_open() -&gt; namei()</pre></div></div><div class=paragraph><p>Por esta razón <code>kern_open</code> y <code>vn_open</code> deben modificarse para incorporar el parámetro adicional <code>dirfd</code>. No se crea una capa de compatibilidad para aquellos porque no hay muchos usuarios de esta y los usuarios se pueden convertir fácilmente. Esta implementación general permite a FreeBSD implementar su propio *at llamadas al sistema. Esto está siendo discutido ahora mismo.</p></div></div></div><div class=sect3><h4 id=ioctl>5.5.2. Ioctl<a class=anchor href=#ioctl></a></h4><div class=paragraph><p>La interfaz ioctl es bastante frágil debido a su genericidad. Tenemos que tener en cuenta que los dispositivos difieren entre Linux® y FreeBSD, por lo que se debe tener cuidado para que la emulación de ioctl funcione correctamente. El manejo de ioctl se implementa en <code>linux_ioctl.c</code>, donde se define la función <code>linux_ioctl</code>. Esta función simplemente itera sobre conjuntos de manejadores ioctl para encontrar un manejador que implemente un comando dado. La llamada al sistema ioctl tiene tres parámetros, el descriptor de archivo, el comando y un argumento. El comando es un número de 16 bits, que en teoría se divide en 8 bits altos que determinan la clase del comando ioctl y 8 bits bajos, que son el comando real dentro del conjunto dado. La emulación aprovecha esta división. Implementamos controladores para cada conjunto, como <code>sound_handler</code> o <code>disk_handler</code>.Cada controlador tiene un comando máximo y un comando mínimo definido, que se utiliza para determinar qué controlador se utiliza. Hay leves problemas con este enfoque porque Linux® no usa la división de conjuntos de manera consistente, por lo que a veces los ioctls de un conjunto diferente están dentro de un conjunto al que no deberían pertenecer (ioctls genéricos SCSI dentro del conjunto cdrom, etc.). FreeBSD actualmente no implementa muchos ioctls de Linux® (en comparación con NetBSD, por ejemplo) pero el plan es portarlos de NetBSD. La tendencia es usar ioctls de Linux® incluso en los controladores nativos de FreeBSD debido a la fácil migración de las aplicaciones.</p></div></div><div class=sect3><h4 id=debugging>5.5.3. Depuración<a class=anchor href=#debugging></a></h4><div class=paragraph><p>Cada llamada al sistema debería ser depurable. Para ello introducimos una pequeña infraestructura. Tenemos la función ldebug, que indica si una llamada al sistema determinada debe depurarse (configurable mediante un sysctl). Para imprimir tenemos macros LMSG y ARGS. Se utilizan para alterar una cadena imprimible para mensajes de depuración uniformes.</p></div></div></div></div></div><div class=sect1><h2 id=conclusion>6. Conclusión<a class=anchor href=#conclusion></a></h2><div class=sectionbody><div class=sect2><h3 id=results>6.1. Resultados<a class=anchor href=#results></a></h3><div class=paragraph><p>A fecha de abril de 2007 la capa de emulación de Linux® es capaz de emular el kernel Linux® 2.6.16 bastante bien. Los problemas que quedan son sobre futexes, la familia de llamadas al sistema *at sin terminar, problemas con el envío de señales, la ausencia de <code>epoll</code> y <code>inotify</code> y probablemente algunos bugs que no se han descubierto todavía. A pesar de esto somos capaces de ejecutar básicamente todos los programas Linux® incluidos en la colección de ports con Fedora Core 4 en 2.6.16 y hay algunos informes rudimentarios de éxito con Fedora Core 6 en 2.6.16. El linux_base de Fedora Core 6 se añadió al repositorio recientemente permitiendo más pruebas de la capa de emulación y dándonos más pistas sobre dónde debemos poner el esfuerzo para implementar las cosas que faltan.</p></div><div class=paragraph><p>Somos capaces de ejecutar las aplicaciones más usadas como <a class=package href=https://cgit.freebsd.org/ports/tree/www/linux-firefox/>www/linux-firefox</a>, <a class=package href=https://cgit.freebsd.org/ports/tree/net-im/skype/>net-im/skype</a> y algunos juegos de la colección de ports. Algunos programas tienen un mal comportamiento bajo la emulación de 2.6 pero se está investigando y con suerte se solucionará pronto. La única aplicación grande que se sabe que no funciona es el Java™ Development Kit de Linux®. Esto es porque requiere <code>epoll</code> el cual no está directamente relacionado con el kernel Linux® 2.6.</p></div><div class=paragraph><p>Esperamos habilitar la emulación 2.6.16 por defecto algún tiempo después del lanzamiento de FreeBSD 7.0 al menos para exponer las partes de la emulación 2.6 para pruebas más amplias. Una vez hecho esto, podemos cambiar a Fedora Core 6 linux_base, que es el plan definitivo.</p></div></div><div class=sect2><h3 id=future-work>6.2. Trabajo futuro<a class=anchor href=#future-work></a></h3><div class=paragraph><p>El trabajo futuro debe centrarse en solucionar los problemas restantes con futexes, implementar el resto de la familia de llamadas al sistema *at, arreglar el envío de señales y posiblemente implementar <code>epoll</code> y <code>inotify</code>.</p></div><div class=paragraph><p>Esperamos poder ejecutar pronto los programas más importantes sin problemas, por lo que podremos cambiar a la emulación 2.6 por defecto y hacer que Fedora Core 6 sea la linux_base predeterminada porque nuestro Fedora Core 4 que usamos actualmente ya no es compatible.</p></div><div class=paragraph><p>El otro objetivo posible es compartir nuestro código con NetBSD y DragonflyBSD. NetBSD tiene algo de soporte para la emulación 2.6 pero está lejos de estar terminado y no se ha probado realmente. DragonflyBSD ha expresado cierto interés en portar las mejoras 2.6.</p></div><div class=paragraph><p>En general, conforme se desarrolla Linux® nos gustaría seguir actualizados con su desarrollo, implementando las nuevas llamadas al sistema. Splice se me viene a la cabeza. Algunas de las llamadas al sistema ya implementadas son subóbtimas, por ejemplo <code>mremap</code> y otras. Se pueden hacer algunas mejoras de rendimiento, bloqueos más finos y otras cosas.</p></div></div><div class=sect2><h3 id=team>6.3. Equipo<a class=anchor href=#team></a></h3><div class=paragraph><p>Colaboré en este proyecto con (en orden alfabético):</p></div><div class=ulist><ul><li><p><code>John Baldwin &lt;<a href=mailto:jhb@FreeBSD.org>jhb@FreeBSD.org</a>></code></p></li><li><p><code>Konstantin Belousov &lt;<a href=mailto:kib@FreeBSD.org>kib@FreeBSD.org</a>></code></p></li><li><p>Emmanuel Dreyfus</p></li><li><p>Scot Hetzel</p></li><li><p><code>Jung-uk Kim &lt;<a href=mailto:jkim@FreeBSD.org>jkim@FreeBSD.org</a>></code></p></li><li><p><code>Alexander Leidinger &lt;<a href=mailto:netchild@FreeBSD.org>netchild@FreeBSD.org</a>></code></p></li><li><p><code>Suleiman Souhlal &lt;<a href=mailto:ssouhlal@FreeBSD.org>ssouhlal@FreeBSD.org</a>></code></p></li><li><p>Li Xiao</p></li><li><p><code>David Xu &lt;<a href=mailto:davidxu@FreeBSD.org>davidxu@FreeBSD.org</a>></code></p></li></ul></div><div class=paragraph><p>Me gustaría agradecer a todas esas personas por sus consejos, revisiones de código y apoyo general.</p></div></div></div></div><div class=sect1><h2 id=literatures>7. Bibliografía<a class=anchor href=#literatures></a></h2><div class=sectionbody><div class="olist arabic"><ol class=arabic><li><p>Marshall Kirk McKusick - George V. Nevile-Neil. Diseño e implementación del sistema operativo FreeBSD. Addison-Wesley, 2005.</p></li><li><p><a href=https://tldp.org>https://tldp.org</a></p></li><li><p><a href=https://www.kernel.org>https://www.kernel.org</a></p></li></ol></div></div></div><hr><div class=last-modified><p><strong>Last modified on</strong>: 23 de agosto de 2022 by <a href="https://cgit.freebsd.org/doc/commit/?id=86a3cc6ef8" target=_blank>Fernando Apesteguía</a></p></div></div><aside class=toc><div class=toc-content><h3>Tabla de contenidos</h3><nav id=TableOfContents><ul><li><a href=#intro>1. Introducción</a></li><li><a href=#inside>2. Una mirada al interior …</a></li><li><a href=#freebsd-emulation>3. Emulación</a></li><li><a href=#md>4. Parte MD de la capa de emulación de Linux®</a></li><li><a href=#mi>5. Parte MI de la capa de emulación Linux®</a></li><li><a href=#conclusion>6. Conclusión</a></li><li><a href=#literatures>7. Bibliografía</a></li></ul></nav><hr><div class=resources><h3>Recursos</h3><ul class=contents><li><i class="fa fa-file-pdf-o" aria-hidden=true title="Descargar PDF"></i><a href=https://download.freebsd.org/doc/es/articles/linux-emulation/linux-emulation_es.pdf>Descargar PDF</a></li><li><i class="fa fa-pencil-square-o" aria-hidden=true title="Editar esta página"></i><a href=https://github.com/freebsd/freebsd-doc/blob/main/documentation/content/es/_index target=_blank>Editar esta página</a></li></ul></div></div></aside></main><footer><div class=footer-container><section class=logo-column><img src=http://172.16.201.134:1313/images/FreeBSD-colors.svg width=160 height=50 alt="FreeBSD logo"><div class=options-container><div class=language-container><a id=languages href=http://172.16.201.134:1313/es/languages><img src=http://172.16.201.134:1313/images/language.png class=language-image alt="Elegir idioma">
<span>Spanish</span></a></div><div class=theme-container><select id=theme-chooser><option value=theme-system>System</option><option value=theme-light>Claro</option><option value=theme-dark>Oscuro</option><option value=theme-high-contrast>Alto contraste</option></select></div></div></section><section class=about-column><h3 class=column-title>About</h3><ul class=column-elements-container><li><a href=https://www.freebsd.org/about/ target=_blank class=column-element>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/ target=_blank class=column-element>FreeBSD Foundation</a></li><li><a href=https://www.freebsd.org/where/ target=_blank class=column-element>Get FreeBSD</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct target=_blank class=column-element>Code of Conduct</a></li><li><a href=https://www.freebsd.org/security/ target=_blank class=column-element>Security Advisories</a></li></ul></section><section class=documentation-column><h3 class=column-title>Documentation</h3><ul class=column-elements-container><li><a href=/es class=column-element>Documentation portal</a></li><li><a href=https://man.FreeBSD.org target=_blank class=column-element>Manual pages</a></li><li><a href=https://papers.FreeBSD.org target=_blank class=column-element>Presentations and papers</a></li><li><a href=https://docs-archive.freebsd.org/doc/ target=_blank class=column-element>Previous versions</a></li><li><a href=https://docs-archive.freebsd.org/44doc/ target=_blank class=column-element>4.4BSD Documents</a></li><li><a href=https://wiki.freebsd.org/ target=_blank class=column-element>Wiki</a></li></ul></section><section class=community-column><h3 class=column-title>Community</h3><ul class=column-elements-container><li><a href=http://172.16.201.134:1313/es/articles/contributing class=column-element>Get involved</a></li><li><a href=https://forums.freebsd.org/ target=_blank class=column-element>Community forum</a></li><li><a href=https://lists.freebsd.org/ target=_blank class=column-element>Mailing lists</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank class=column-element>IRC Channels</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank class=column-element>Bug Tracker</a></li></ul></section><section class=legal-column><h3 class=column-title>Legal</h3><ul class=column-elements-container><li><a href=https://freebsdfoundation.org/donate/ target=_blank class=column-element>Donations</a></li><li><a href=https://www.freebsd.org/copyright/freebsd-license/ target=_blank class=column-element>Licensing</a></li><li><a href=https://www.freebsd.org/privacy/ target=_blank class=column-element>Privacy Policy</a></li><li><a href=https://www.freebsd.org/copyright/ target=_blank class=column-element>Legal notices</a></li></ul></section><section class=copyright-column><p>&copy; 1994-2024 The FreeBSD Project. All rights reserved</p><span>Made with <span class=heart>♥</span> by the FreeBSD Community</span></section></div></footer></body></html>