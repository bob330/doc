<!doctype html><html class=theme-light lang=es><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Una guía para escribir nuevos scripts rc.d y entender aquellos que ya están escritos"><meta name=keywords content="rc.d,scripting,guide,tutorial,FreeBSD"><meta name=copyright content="1995-2024 The FreeBSD Foundation"><link rel=canonical href=https://docs.freebsd.org/es/articles/rc-scripting/><title>Scripting práctico rc.d en BSD | Portal de documentación de FreeBSD</title>
<meta name=theme-color content="#790000"><meta name=color-scheme content="system light dark high-contrast"><link rel="shortcut icon" href=https://docs.freebsd.org/favicon.ico><link rel=stylesheet href=https://docs.freebsd.org/styles/main.min.css><link rel=stylesheet href=https://docs.freebsd.org/css/font-awesome-min.css><script defer src=/js/theme-chooser.min.js></script><script defer src=/js/copy-clipboard.min.js></script><script defer src=/js/search.min.js></script><meta name=twitter:card content="summary"><meta name=twitter:domain content="docs.FreeBSD.org"><meta name=twitter:site content="@freebsd"><meta name=twitter:url content="https://twitter.com/freebsd"><meta property="og:title" content="Scripting práctico rc.d en BSD"><meta property="og:description" content="Una guía para escribir nuevos scripts rc.d y entender aquellos que ya están escritos"><meta property="og:type" content="website"><meta property="og:image" content="https://docs.freebsd.org/favicon.ico"><meta property="og:image:alt" content="FreeBSD Logo"><meta property="og:locale" content="es"><meta property="og:url" content="https://docs.freebsd.org/es/articles/rc-scripting/"><meta property="og:site_name" content="Portal de documentación de FreeBSD"><script type=application/ld+json>{"@context":"http://schema.org","@type":"Article","url":"https:\/\/docs.freebsd.org\/es\/articles\/rc-scripting\/","name":"Portal de documentación de FreeBSD","headline":"Portal de documentación de FreeBSD","description":"FreeBSD Documentation Portal"}</script></head><body><header><div class=header-container><div class=logo-menu-bars-container><a href=https://www.FreeBSD.org class=logo><img src=https://docs.freebsd.org/images/FreeBSD-monochromatic.svg width=160 height=50 alt="FreeBSD logo">
</a><label class=menu-bars for=menu-bars><i class="fa fa-bars" aria-hidden=true></i></label></div><input id=menu-bars type=checkbox><nav><ul class=menu><li class=menu-item><input id=about type=checkbox>
<a href=# aria-label="Navigate to About section"><label class=menu-item-description for=about>About
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/about/ target=_blank>About</a></li><li><a href=https://www.freebsd.org/about/ target=_blank>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/about-us/about-the-foundation/ target=_blank>FreeBSD Foundation</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct/ target=_blank>Code of Conduct</a></li></ul></li><li class=menu-item><input id=download type=checkbox>
<a href=# aria-label="Navigate to get FreeBSD section"><label class=menu-item-description for=download>Get FreeBSD
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/where/ target=_blank>Get FreeBSD</a></li><li><a href=https://www.freebsd.org/releases/ target=_blank>Release Information</a></li><li><a href=https://www.freebsd.org/releng/ target=_blank>Release Engineering</a></li><li><a href=https://www.freebsd.org/security/ target=_blank>Security Advisories</a></li></ul></li><li class=menu-item><input id=documentation type=checkbox>
<a href=# aria-label="Navigate to get Documentation section"><label class=menu-item-description for=documentation>Documentation
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=/es>Documentation portal</a></li><li><a href=https://docs.freebsd.org/es/books/handbook>FreeBSD Handbook</a></li><li><a href=https://docs.freebsd.org/es/books/porters-handbook>Porter's Handbook</a></li><li><a href=https://docs.FreeBSD.org/en/books/fdp-primer>Documentation Project Handbook</a></li><li><a href=https://man.FreeBSD.org target=_blank>Manual pages</a></li><li><a href=https://papers.FreeBSD.org target=_blank>Presentations and papers</a></li><li><a href=https://wiki.FreeBSD.org target=_blank>Wiki</a></li><li><a href=https://docs.freebsd.org/es/books>Books</a></li><li><a href=https://docs.freebsd.org/es/articles>Articles</a></li></ul></li><li class=menu-item><input id=community type=checkbox>
<a href=# aria-label="Navigate to get Community section"><label class=menu-item-description for=community>Community
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/community/>Community</a></li><li><a href=https://docs.freebsd.org/es/articles/contributing>Get involved</a></li><li><a href=https://forums.freebsd.org/ target=_blank>Forum</a></li><li><a href=https://lists.freebsd.org/ target=_blank>Mailing lists</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank>IRC Channels</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank>Bug Tracker</a></li><li><a href=https://www.freebsd.org/support/ target=_blank>Support</a></li></ul></li></ul></nav><div class=search-donate-container><form class=search method=get id=search-header-form action=https://docs.freebsd.org/search name=search-header-form><input type=hidden name=DB value=es>
<input id=words name=P type=text size=20 maxlength=255>
<button>
<i class="fa fa-search" aria-hidden=true></i></button></form><div class=donate><a href=https://freebsdfoundation.org/donate/ target=_blank><span class=heart>♥</span>
Donate</a></div></div></div></header><main class=main-wrapper-article><div class=article><h1 class=title>Scripting práctico rc.d en BSD</h1><div class="admonitionblock note"><p><i class="fa fa-exclamation-circle" aria-hidden=true></i>
This translation may be out of date. To help with the translations please access the <a href=https://translate-dev.freebsd.org/ target=_blank>FreeBSD translations instance</a>.</p></div><div class=copyright>Copyright © 2005-2006, 2012 The FreeBSD Project</div><div class=legalnotice><a id=trademarks></a><details><summary>Marcas registradas</summary><p>FreeBSD es una marca registrada de la Fundación FreeBSD</p><p>NetBSD es una marca registrada de la Fundación NetBSD.</p><p>Muchos de los nombres usados por los fabricantes y vendedores para diferenciar sus productos son designados como marcas comerciales. Allí donde estos nombres aparezcan en este documento y el Proyecto FreeBSD fuera consciente de la alegación de marca comercial, los nombres tienen a continuación el símbolo “™” o “®”.</p></details></div><div class=toc-mobile><h3>Tabla de contenidos</h3><nav id=TableOfContents><ul><li><a href=#rcng-intro>1. Introducción</a></li><li><a href=#rcng-task>2. Delineando la tarea</a></li><li><a href=#rcng-dummy>3. Un guión ficticio</a></li><li><a href=#rcng-confdummy>4. Un script ficticio configurable</a></li><li><a href=#rcng-daemon>5. Arranque y parada de un demonio simple</a></li><li><a href=#rcng-daemon-adv>6. Arranque y parada de un demonio avanzado</a></li><li><a href=#rcng-hookup>7. Conectando un script al framework rc.d</a></li><li><a href=#rcng-args>8. Dar más flexibilidad a un script rc.d</a></li><li><a href=#rcng-furthur>9. Otras lecturas</a></li></ul></nav></div><div id=preamble><div class=sectionbody><div class="paragraph abstract-title"><p>Resumen</p></div><div class=paragraph><p>Los principiantes pueden tener dificultades para relacionar los hechos de la documentación formal del framwork <span class=filename>rc.d</span> de BSD con las tareas prácticas de scripting de <span class=filename>rc.d</span>. En este artículo, consideramos algunos casos típicos de complejidad creciente, mostramos <span class=filename>rc.d</span> características adecuadas para cada caso y comentamos cómo funcionan. Dicho examen debe proporcionar puntos de referencia para un estudio más detallado del diseño y la aplicación eficiente de <span class=filename>rc.d</span>.</p></div><hr></div></div><div class=sect1><h2 id=rcng-intro>1. Introducción<a class=anchor href=#rcng-intro></a></h2><div class=sectionbody><div class=paragraph><p>El BSD histórico tenía un script de arranque monolítico, <span class=filename>/etc/rc</span>. Era invocado por <a href="https://man.freebsd.org/cgi/man.cgi?query=init&amp;sektion=8&amp;format=html">init(8)</a> durante el arranque del sistema y realizaba todas las tareas en modo usuario que se requerían para operar en modo multi-usuario: comprobar y montar los sistemas de ficheros, configurar la red, arrancar demonios y demás. La lista precisa de tareas no era la misma en cada sistema; los administradores necesitaban personalizarla. Salvo en unas pocas excepciones, se tenía que modificar <span class=filename>/etc/rc</span>, y a los verdaderos hackers les gustaba.</p></div><div class=paragraph><p>El verdadero problema con el enfoque monolítico era que no proporcionaba control sobre los componentes individuales a partir de <span class=filename>/etc/rc</span>. Por ejemplo, <span class=filename>/etc/rc</span> no podía reiniciar un solo demonio. El administrador del sistema tenía que encontrar el proceso del demonio a mano, matarlo, esperar hasta que realmente terminara y luego examinar <span class=filename>/etc/rc</span> para los flags, y finalmente escribir la línea de comando completa para iniciar el demonio nuevamente. La tarea se volvía aún más difícil y propensa a errores si el servicio a reiniciar consistía en más de un demonio o exigía acciones adicionales. En pocas palabras, el script único no cumplía con el propósito de los scripts: facilitar la vida del administrador del sistema.</p></div><div class=paragraph><p>Posteriormente hubo un intento de separar algunas partes de <span class=filename>/etc/rc</span> para poder arrancar los subsistemas más importantes de forma separada. Un ejemplo importante era <span class=filename>/etc/netstart</span> para levantar la red. Permitía acceder a la red desde el modo de usuario único, pero no se integraba bien con el proceso de arranque automático debido a que algunas partes de su código necesitaban intercalarse con acciones que en esencia no estaban relacionadas con la red. Por eso <span class=filename>/etc/netstart</span> se cambió a <span class=filename>/etc/rc.network</span>. El segundo ya no era un script ordinario; estaba compuesto de funciones <a href="https://man.freebsd.org/cgi/man.cgi?query=sh&amp;sektion=1&amp;format=html">sh(1)</a> grandes y entrelazadas que se llamaban desde <span class=filename>/etc/rc</span> en diferentes fases del sistema de arranque. Sin embargo, a medida que las tareas de arranque se hicieron más diversas y sofisticadas, la aproximación "casi modular" se convirtió en un lastre casi más de lo que había sido el <span class=filename>/etc/rc</span> monolítico.</p></div><div class=paragraph><p>Sin un framework limpio y bien diseñado, los scripts de inicio tuvieron que hacer todo lo posible para satisfacer las necesidades de los sistemas operativos basados en BSD en rápido desarrollo. Por fin se hizo evidente que se necesitan más pasos en el camino hacia una sistema <span class=filename>rc</span> refinado y extensible. Así nació el <span class=filename>rc.d</span> de BSD. Sus padres reconocidos fueron Luke Mewburn y la comunidad NetBSD. Posteriormente se importó a FreeBSD. Su nombre se refiere a la ubicación de los scripts del sistema para servicios individuales, que se encuentra en <span class=filename>/etc/rc.d</span>. Pronto conoceremos más componentes del sistema <span class=filename>rc.d</span> y veremos cómo se invocan los scripts individuales.</p></div><div class=paragraph><p>Las ideas básicas detrás del <span class=filename>rc.d</span> de BSD son <em>modularidad fina</em> y <em>reutilización de código</em>. <em>Modularidad fina</em> significa que cada "servicio" básico tales como un demonio del sistema o una primitiva de arranque tienen su propio script <a href="https://man.freebsd.org/cgi/man.cgi?query=sh&amp;sektion=1&amp;format=html">sh(1)</a> capaz de arrancar el servicio, pararlo, recargarlo y comprobar su estado. Se escoge una acción particular mediante un argumento en la línea de comando del script. El script <span class=filename>/etc/rc</span> todavía dirige el sistema de arranque, pero ahora simplemente invoca scripts más pequeños uno a uno con el argumento <code>start</code>. También es fácil realizar tareas de parado ejecutando el mismo conjunto de scripts con el argumento <code>stop</code>, que es lo que hace <span class=filename>/etc/rc.shutdown</span>. Date cuenta de cómo esto sigue de cerca la manera Unix de tener un conjunto pequeño de herramientas especializadas, cada una realizando su tarea lo mejor posible. <em>Reutilización de código</em> significa que las operaciones comunes están implementadas como funciones <a href="https://man.freebsd.org/cgi/man.cgi?query=sh&amp;sektion=1&amp;format=html">sh(1)</a> y compiladas en <span class=filename>/etc/rc.subr</span>. Ahora un script típico puede tener sólo unas pocas líneas de código <a href="https://man.freebsd.org/cgi/man.cgi?query=sh&amp;sektion=1&amp;format=html">sh(1)</a>. Finalmente, una parte importante del framework <span class=filename>rc.d</span> es <a href="https://man.freebsd.org/cgi/man.cgi?query=rcorder&amp;sektion=8&amp;format=html">rcorder(8)</a>, que ayuda a <span class=filename>/etc/rc</span> a ejecutar los scripts pequeños de forma ordenada respecto a las dependencias entre ellos. También puede ayudar a <span class=filename>/etc/rc.shutdown</span>, porque el orden adecuado de apagado es el opuesto al de arranque.</p></div><div class=paragraph><p>El diseño del <span class=filename>rc.d</span> de BSD se describe en <a href=#lukem>el artículo original de Luke Mewburn</a>, y los componentes de <span class=filename>rc.d</span> están documentados con gran detalle en <a href=#manpages>las respectivas páginas de manual</a>. Sin embargo, puede que no parezca obvio para un novato de <span class=filename>rc.d</span> cómo unir las numerosas partes y piezas para crear un script con estilo para una tarea en particular. Por lo tanto, este artículo intentará un enfoque diferente para describir <span class=filename>rc.d</span>. Mostrará qué funciones deben usarse en varios casos típicos y por qué. Ten en cuenta que este no es un documento de instrucciones porque nuestro objetivo no es dar recetas listas para usar, sino mostrar algunas formas fáciles de introducirse en el reino de <span class=filename>rc.d</span>. Este artículo tampoco sustituye a las páginas del manual correspondientes. No dudes en consultarlas para obtener documentación más formal y completa mientras lees este artículo.</p></div><div class=paragraph><p>Hay prerequisitos para entender este artículo. Antes de nada, para dominar <span class=filename>rc.d</span> deberías estar familiarizado con el lenguaje de scripting de <a href="https://man.freebsd.org/cgi/man.cgi?query=sh&amp;sektion=1&amp;format=html">sh(1)</a>. Además deberías conocer cómo el sistema realiza las tareas de arranque y parada en modo usuario, que está descrito en <a href="https://man.freebsd.org/cgi/man.cgi?query=rc&amp;sektion=8&amp;format=html">rc(8)</a>.</p></div><div class=paragraph><p>Este artículo se centra en la rama FreeBSD de <span class=filename>rc.d</span>. Sin embargo, también puede ser útil para los desarrolladores de NetBSD, porque las dos ramas de <span class=filename>rc.d</span> de BSD no solo comparten el mismo diseño, sino que también son similares en sus aspectos visibles para los creadores de scripts.</p></div></div></div><div class=sect1><h2 id=rcng-task>2. Delineando la tarea<a class=anchor href=#rcng-task></a></h2><div class=sectionbody><div class=paragraph><p>Un poco de reflexión antes de arrancar <code>$EDITOR</code> no dolerá. Para escribir un script <span class=filename>rc.d</span> bien hecho para un servicio del sistema, deberíamos poder responder las siguientes preguntas primero:</p></div><div class=ulist><ul><li><p>¿El servicio es obligatorio u opcional?</p></li><li><p>¿El script servirá a un solo programa, por ejemplo, un demonio, o realizará acciones más complejas?</p></li><li><p>¿De qué otros servicios dependerá nuestro servicio y viceversa?</p></li></ul></div><div class=paragraph><p>De los ejemplos que siguen veremos por qué es importante conocer las respuestas a estas preguntas.</p></div></div></div><div class=sect1><h2 id=rcng-dummy>3. Un guión ficticio<a class=anchor href=#rcng-dummy></a></h2><div class=sectionbody><div class=paragraph><p>El siguiente script simplemente emite un mensaje cada vez que se inicia el sistema:</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh <i class=conum data-value=1></i><b>(1)</b>

. /etc/rc.subr <i class=conum data-value=2></i><b>(2)</b>

name=&#34;dummy&#34; <i class=conum data-value=3></i><b>(3)</b>
start_cmd=&#34;${name}_start&#34; <i class=conum data-value=4></i><b>(4)</b>
stop_cmd=&#34;:&#34; <i class=conum data-value=5></i><b>(5)</b>

dummy_start() <i class=conum data-value=6></i><b>(6)</b>
{
	echo &#34;Nothing started.&#34;
}

load_rc_config $name <i class=conum data-value=7></i><b>(7)</b>
run_rc_command &#34;$1&#34; <i class=conum data-value=8></i><b>(8)</b></pre></div></div><div class=paragraph><p>Las cosas a tener en cuenta son:</p></div><div class=paragraph><p>➊ Un script interpretado debería empezar con la línea mágica "shebang". Esa línea especifica el programa intérprete para el script. Gracias a la línea shebang, el script se puede invocar exactamente igual que un programa binario si se ha establecido el bit de ejecución. (Consulta <a href="https://man.freebsd.org/cgi/man.cgi?query=chmod&amp;sektion=1&amp;format=html">chmod(1)</a>.) Por ejemplo, un administrador puede ejecutar nuestro script de forma manual, desde la línea de comando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /etc/rc.d/dummy start</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Para que los scripts puedan ser gestionados por el framework <span class=filename>rc.d</span> tienen que estar escritos en lenguaje <a href="https://man.freebsd.org/cgi/man.cgi?query=sh&amp;sektion=1&amp;format=html">sh(1)</a>. Si tienes un servicio o port que usa una utilidad de control binaria o una rutina de arranque escrita en otro lenguaje, instala ese elemento en <span class=filename>/usr/sbin</span> (para el sistema) o <span class=filename>/usr/local/sbin</span> (para ports) e invócalo desde un script <a href="https://man.freebsd.org/cgi/man.cgi?query=sh&amp;sektion=1&amp;format=html">sh(1)</a> en el directorio <span class=filename>rc.d</span> apropiado.</p></div></td></tr></tbody></table></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Si quieres conocer los detalles acerca de por qué los scripts de <span class=filename>rc.d</span> se tienen que escribir en lenguaje <a href="https://man.freebsd.org/cgi/man.cgi?query=sh&amp;sektion=1&amp;format=html">sh(1)</a>, consulta cómo <span class=filename>/etc/rc</span> los invoca mediante <code>run_rc_script</code>, luego estudia la implementación de <code>run_rc_script</code> en <span class=filename>/etc/rc.subr</span>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>➋ En <span class=filename>/etc/rc.subr</span>, se definen un número de funciones <a href="https://man.freebsd.org/cgi/man.cgi?query=sh&amp;sektion=1&amp;format=html">sh(1)</a> para que las use el script <span class=filename>rc.d</span>. Las funciones están documentadas en <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.subr&amp;sektion=8&amp;format=html">rc.subr(8)</a>. Aunque es teóricamente posible escribir un script <span class=filename>rc.d</span> sin llegar a usar <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.subr&amp;sektion=8&amp;format=html">rc.subr(8)</a>, sus funciones han demostrado ser extremadamente útiles y hacen el trabajo un orden de magnitud más fácil. Así que no es una sorpresa que todo el mundo recurra a <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.subr&amp;sektion=8&amp;format=html">rc.subr(8)</a> en los scripts de <span class=filename>rc.d</span>. Nosotros no vamos a ser una excepción.</p></div><div class=paragraph><p>Un script <span class=filename>rc.d</span> debe incluir <span class=filename>/etc/rc.subr</span> (utilizando “.”) <em>antes</em> de llamar a funciones de <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.subr&amp;sektion=8&amp;format=html">rc.subr(8)</a> de forma que <a href="https://man.freebsd.org/cgi/man.cgi?query=sh&amp;sektion=1&amp;format=html">sh(1)</a> tenga una oportunidad para saber acerca de las funciones. El estilo preferido es hacer "source" de <span class=filename>/etc/rc.subr</span> antes de nada.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Algunas funciones útiles relacionadas con redes son proporcionadas por otro archivo de inclusión, <span class=filename>/etc/network.subr</span>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>➌ <a id=name-var></a>La variable obligatoria <code>name</code> especifica el nombre de nuestro script. Es un requisito de <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.subr&amp;sektion=8&amp;format=html">rc.subr(8)</a>. Es decir, cada script <span class=filename>rc.d</span> <em>debe establecer</em> <code>name</code> antes de llamar a las funciones de <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.subr&amp;sektion=8&amp;format=html">rc.subr(8)</a>.</p></div><div class=paragraph><p>Ahora es el momento adecuado para elegir un nombre único para nuestro script de una vez por todas. Lo usaremos en varios lugares mientras desarrollamos el script. Para empezar, démosle también el mismo nombre al archivo del script.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>El estilo actual de los scripts <span class=filename>rc.d</span> es englobar los valores asignados a variables entre comillas dobles. Ten en cuenta que esto es sólo una cuestión de estilo y que podría no ser aplicable siempre. Puedes omitir las comillas de forma segura alrededor de palabras sencillas que no contengan metacaracteres de <a href="https://man.freebsd.org/cgi/man.cgi?query=sh&amp;sektion=1&amp;format=html">sh(1)</a>, mientras que en ciertos casos necesitarás comillas simples para evitar cualquier interpretación del valor por parte de <a href="https://man.freebsd.org/cgi/man.cgi?query=sh&amp;sektion=1&amp;format=html">sh(1)</a>. Un programador debería ser capaz de distinguir la sintaxis del lenguaje de las convenciones de estilo y aplicar ambas de forma apropiada.</p></div></td></tr></tbody></table></div><div class=paragraph><p>➍ La idea principal detrás de <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.subr&amp;sektion=8&amp;format=html">rc.subr(8)</a> es que un script <span class=filename>rc.d</span> proporciona manejadores, o métodos, para que los invoque <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.subr&amp;sektion=8&amp;format=html">rc.subr(8)</a>. En particular, <code>start</code>, <code>stop</code>, y otros argumentos pasados a un script <span class=filename>rc.d</span> se manejan de esta forma. Un método es una expresión <a href="https://man.freebsd.org/cgi/man.cgi?query=sh&amp;sektion=1&amp;format=html">sh(1)</a> que se almacena en una variable llamada <code>argument_cmd</code>, donde <em>argument</em> corresponde a lo que se puede especificar en la línea de comando del script. Luego veremos cómo <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.subr&amp;sektion=8&amp;format=html">rc.subr(8)</a> proporciona métodos por defecto para los argumentos estándar.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Para hacer el código en <span class=filename>rc.d</span> más uniforme, es común usar <code>${name}</code> donde sea apropiado. Por tanto, es posible simplemente copiar varias líneas de un script a otro.</p></div></td></tr></tbody></table></div><div class=paragraph><p>➎ Deberíamos tener en cuenta que <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.subr&amp;sektion=8&amp;format=html">rc.subr(8)</a> proporciona métodos por defecto para los argumentos estándar. Consecuentemente, debemos sobrescribir un método con una expresión no-op de <a href="https://man.freebsd.org/cgi/man.cgi?query=sh&amp;sektion=1&amp;format=html">sh(1)</a> si queremos que no haga nada.</p></div><div class=paragraph><p>➏ El cuerpo de un método sofisticado se puede implementar como una función. Es una buena idea que el nombre de la función tenga un significado.</p></div><div class="admonitionblock important"><table><tbody><tr><td class=icon><i class="fa icon-important" title=Important></i></td><td class=content><div class=paragraph><p>Se recomienda encarecidamente añadir el prefijo <code>${name}</code> a los nombres de todas las funciones definidas en nuestro script de forma que nunca colisionen con funciones de <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.subr&amp;sektion=8&amp;format=html">rc.subr(8)</a> o cualquier otro fichero que se incluya de forma habitual.</p></div></td></tr></tbody></table></div><div class=paragraph><p>➐ Esta llamada a <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.subr&amp;sektion=8&amp;format=html">rc.subr(8)</a> carga las variables de <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a>. Nuestro script no las utiliza todavía, pero aún así se recomienda cargar <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a> porque puede haber variables de <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a> controlando al propio <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.subr&amp;sektion=8&amp;format=html">rc.subr(8)</a>.</p></div><div class=paragraph><p>➑ Normalmente este es el último comando en un script <span class=filename>rc.d</span>. Invoca la maquinaria de <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.subr&amp;sektion=8&amp;format=html">rc.subr(8)</a> para realizar la acción solicitada utilizando las variables y métodos que ha proporcionado nuestro script.</p></div></div></div><div class=sect1><h2 id=rcng-confdummy>4. Un script ficticio configurable<a class=anchor href=#rcng-confdummy></a></h2><div class=sectionbody><div class=paragraph><p>Ahora añadamos algunos controles a nuestro script de prueba. Como sabes, los scripts <span class=filename>rc.d</span> están controlados por <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a>. Afortunadamente, <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.subr&amp;sektion=8&amp;format=html">rc.subr(8)</a> nos oculta todas las complicaciones. El siguiente script usa <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a> mediante <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.subr&amp;sektion=8&amp;format=html">rc.subr(8)</a> para ver en primer lugar si está habilitado, y para obtener un mensaje que mostrar en el momento del arranque. Estas dos tareas son de hecho independientes. En un lado, un script <span class=filename>rc.d</span> puede simplemente soportar la activación y desactivación de su servicio. Por otro lado, un script <span class=filename>rc.d</span> obligatorio puede tener las variables de configuración. Sin embargo, nosotros haremos ambas cosas en el mismo script:</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh

. /etc/rc.subr

name=dummy
rcvar=dummy_enable <i class=conum data-value=1></i><b>(1)</b>

start_cmd=&#34;${name}_start&#34;
stop_cmd=&#34;:&#34;

load_rc_config $name <i class=conum data-value=2></i><b>(2)</b>
: ${dummy_enable:=no} <i class=conum data-value=3></i><b>(3)</b>
: ${dummy_msg=&#34;Nothing started.&#34;} <i class=conum data-value=4></i><b>(4)</b>

dummy_start()
{
	echo &#34;$dummy_msg&#34; <i class=conum data-value=5></i><b>(5)</b>
}

run_rc_command &#34;$1&#34;</pre></div></div><div class=paragraph><p>¿Qué cambió en este ejemplo?</p></div><div class=paragraph><p>➊ La variable <code>rcvar</code> especifica el nombre de la variable ON/OFF.</p></div><div class=paragraph><p>➋ Ahora <code>load_rc_config</code> es invocado pronto en el script, antes de que se acceda a alguna variable de <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Cuando examines scripts <span class=filename>rc.d</span>, ten en cuenta que <a href="https://man.freebsd.org/cgi/man.cgi?query=sh&amp;sektion=1&amp;format=html">sh(1)</a> retrasa la evaluación de expresiones en una función hasta que ésta es invocada. Por lo tanto, no es un error invocar <code>load_rc_config</code> tan tarde como justo antes de <code>run_rc_command</code> y aún así acceder a variables de <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a> desde los métodos exportados a <code>run_rc_command</code>. Esto es porque los métodos se llaman desde <code>run_rc_command</code>, que es invocado <em>después</em> de <code>load_rc_config</code>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>➌ Se emitirá un aviso desde <code>run_rc_command</code> si <code>rcvar</code> está establecida, pero la variable en sí no lo está. Si tu script <span class=filename>rc.d</span> es para el sistema base, deberías añadir un valor por defecto para la variable en <span class=filename>/etc/defaults/rc.conf</span> y documentarlo en <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a>. De lo contrario tu script debería proporcionar un valor por defecto para la variable. La aproximación canónica para el último caso se muestra en el ejemplo.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Puedes hacer que <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.subr&amp;sektion=8&amp;format=html">rc.subr(8)</a> actúe como si la variable estuviera a <code>ON</code>, independientemente de su estado actual, poniendo como prefijo del argumento del script <code>one</code> o <code>force</code>, como en <code>onestart</code> o <code>forcestop</code>. Ten en cuenta sin embargo que <code>force</code> tiene otros efectos peligrosos que mencionaremos abajo, mientras que <code>one</code> simplemente tiene preferencia sobre la variable ON/OFF. Por ejemplo, asume que <code>dummy_enable</code> es <code>OFF</code>. El siguiente comando ejecutará el método <code>start</code> a pesar de esa configuración:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /etc/rc.d/dummy onestart</span></code></pre></div></div></td></tr></tbody></table></div><div class=paragraph><p>➍ Ahora el mensaje que se mostrará en el arranque ya no está inmutable en el script. Se especifica en una variable de <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a> llamada <code>dummy_msg</code>. Este es un ejemplo trivial de cómo un script de <span class=filename>rc.d</span> puede ser controlado por variables de <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a>.</p></div><div class="admonitionblock important"><table><tbody><tr><td class=icon><i class="fa icon-important" title=Important></i></td><td class=content><div class=paragraph><p>Los nombres de todas las variables <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a> usadas en exclusiva por nuestro script <em>deben tener</em> el mismo prefijo: <code>${name}_</code>. Por ejemplo: <code>dummy_mode</code>, <code>dummy_state_file</code>, y así sucesivamente.</p></div></td></tr></tbody></table></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Aunque es posible utilizar internamente un nombre más corto, por ejemplo simplemente <code>msg</code>, añadir el prefijo único <code>${name}_</code> a todos los nombres globales introducidos por nuestro script nos evitará posibles colisiones en el espacio de nombres de <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.subr&amp;sektion=8&amp;format=html">rc.subr(8)</a>.</p></div><div class=paragraph><p>Como norma, los scripts <span class=filename>rc.d</span> del sistema base no necesitan proporcionar valores por defecto para sus variables en <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a> porque estos deberían establecerse en cambio en <span class=filename>/etc/defaults/rc.conf</span>. Por otro lado, los scripts <span class=filename>rc.d</span> para ports deberían proporcionar los valores por defecto como se muestra en el ejemplo.</p></div></td></tr></tbody></table></div><div class=paragraph><p>➎ Aquí utilizamos <code>dummy_msg</code> en realidad para controlar nuestro script, es decir, para emitir un mensaje variable. Utilizar una función de shell para esto es demasiado ya que sólo ejecuta un comando. Una alternativa igualmente válida es:</p></div><div class="literalblock programlisting"><div class=content><pre>start_cmd=&#34;echo \&#34;$dummy_msg\&#34;&#34;</pre></div></div></div></div><div class=sect1><h2 id=rcng-daemon>5. Arranque y parada de un demonio simple<a class=anchor href=#rcng-daemon></a></h2><div class=sectionbody><div class=paragraph><p>Dijimos antes que <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.subr&amp;sektion=8&amp;format=html">rc.subr(8)</a> podía proporcionar métodos por defecto. Obviamente, estos no pueden ser muy generales. Se adaptan bien al caso común de arrancar y parar un programa tipo demonio que sea sencillo. Asumamos ahora que necesitamos escribir un script <span class=filename>rc.d</span> para dicho demonio llamado <code>mumbled</code>. Aquí está:</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh

. /etc/rc.subr

name=mumbled
rcvar=mumbled_enable

command=&#34;/usr/sbin/${name}&#34; <i class=conum data-value=1></i><b>(1)</b>

load_rc_config $name
run_rc_command &#34;$1&#34;</pre></div></div><div class=paragraph><p>Agradablemente simple, ¿no? Examinemos nuestro pequeño script. Lo único nuevo a tener en cuenta es lo siguiente:</p></div><div class=paragraph><p>➊ La variable <code>command</code> tiene sentido para <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.subr&amp;sektion=8&amp;format=html">rc.subr(8)</a>. Si está establecida, <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.subr&amp;sektion=8&amp;format=html">rc.subr(8)</a> actuará en consecuencia con el escenario de servir un demonio convencional. En particular, se proporcionarán los métodos por defecto para los argumentos: <code>start</code>, <code>stop</code>, <code>restart</code>, <code>poll</code>, y <code>status</code>.</p></div><div class=paragraph><p>El demonio se arrancará ejecutando <code>$command</code> con los flags especificados por <code>$mumbled_flags</code>. Por lo tanto todos los datos de entrada para el método <code>start</code> por defecto están disponibles en las variables establecidas por nuestro script. A diferencia de <code>start</code>, otros métodos podrían requerir información adicional acerca del proceso arrancado. Por ejemplo, <code>stop</code> debe saber el PID del proceso para poder terminarlo. En el caso actual, <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.subr&amp;sektion=8&amp;format=html">rc.subr(8)</a> escaneará la lista de todos los procesos, buscando un proceso cuyo nombre sea <code>procname</code>. Esto último es otra variable que tiene significado para <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.subr&amp;sektion=8&amp;format=html">rc.subr(8)</a> y su valor por defecto es el valor de <code>command</code>. En otras palabras, cuando establecemos <code>command</code>, <code>procname</code> se establece al mismo valor. Esto posibilita que nuestro script pueda matar el demonio y así como comprobar en primer lugar si se está ejecutando.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Algunos programas son de hecho scripts ejecutables. El sistema ejecuta dichos scripts iniciando su intérprete y pasándole el nombre del script como un argumento en línea de comandos. Esto se refleja en la lista de procesos, que puede confundir a <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.subr&amp;sektion=8&amp;format=html">rc.subr(8)</a>. Deberías establecer además <code>command_interpreter</code> para que <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.subr&amp;sektion=8&amp;format=html">rc.subr(8)</a> sepa cuál es el verdadero nombre del proceso si <code>$command</code> es un script.</p></div><div class=paragraph><p>Para cada script <span class=filename>rc.d</span>, hay una variable opcional en <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a> que tiene preferencia sobre <code>command</code>. Su nombre se construye de la siguiente manera: <code>${name}_program</code>, donde <code>name</code> es la variable obligatoria que discutimos <a href=#name-var>anteriormente</a>. Ejemplo, en este caso será <code>mumbled_program</code>. Es <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.subr&amp;sektion=8&amp;format=html">rc.subr(8)</a> quien hace que <code>${name}_program</code> tenga más prioridad que <code>command</code>.</p></div><div class=paragraph><p>Por supuesto, <a href="https://man.freebsd.org/cgi/man.cgi?query=sh&amp;sektion=1&amp;format=html">sh(1)</a> te permitirá establecer <code>${name}_program</code> desde <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a> o incluso desde el propio script si <code>command</code> no está establecido. En ese caso, las propiedades especiales de <code>${name}_program</code> se pierden y se convierte en una variable ordinaria que tu script puede usar para sus propios fines. Sin embargo, el uso aislado de <code>${name}_program</code> está desaconsejado porque usarlo junto con <code>command</code> se ha convertido en algo idiomático en los scripts de <span class=filename>rc.d</span>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Para una información más detallada acerca de los métodos por defecto, consulta <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.subr&amp;sektion=8&amp;format=html">rc.subr(8)</a>.</p></div></div></div><div class=sect1><h2 id=rcng-daemon-adv>6. Arranque y parada de un demonio avanzado<a class=anchor href=#rcng-daemon-adv></a></h2><div class=sectionbody><div class=paragraph><p>Agreguemos un poco de carne a los huesos del guión anterior y hagámoslo más complejo y más rico en características. Los métodos predeterminados pueden hacer un buen trabajo por nosotros, pero es posible que necesitemos ajustar algunos de sus aspectos. Ahora aprenderemos cómo ajustar los métodos predeterminados a nuestras necesidades.</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh

. /etc/rc.subr

name=mumbled
rcvar=mumbled_enable

command=&#34;/usr/sbin/${name}&#34;
command_args=&#34;mock arguments &gt; /dev/null 2&gt;&amp;1&#34; <i class=conum data-value=1></i><b>(1)</b>

pidfile=&#34;/var/run/${name}.pid&#34; <i class=conum data-value=2></i><b>(2)</b>

required_files=&#34;/etc/${name}.conf /usr/share/misc/${name}.rules&#34; <i class=conum data-value=3></i><b>(3)</b>

sig_reload=&#34;USR1&#34; <i class=conum data-value=4></i><b>(4)</b>

start_precmd=&#34;${name}_prestart&#34; <i class=conum data-value=5></i><b>(5)</b>
stop_postcmd=&#34;echo Bye-bye&#34; <i class=conum data-value=6></i><b>(6)</b>

extra_commands=&#34;reload plugh xyzzy&#34; <i class=conum data-value=7></i><b>(7)</b>

plugh_cmd=&#34;mumbled_plugh&#34; <i class=conum data-value=8></i><b>(8)</b>
xyzzy_cmd=&#34;echo &#39;Nothing happens.&#39;&#34;

mumbled_prestart()
{
	if checkyesno mumbled_smart; then <i class=conum data-value=9></i><b>(9)</b>
		rc_flags=&#34;-o smart ${rc_flags}&#34; <i class=conum data-value=10></i><b>(10)</b>
	fi
	case &#34;$mumbled_mode&#34; in
	foo)
		rc_flags=&#34;-frotz ${rc_flags}&#34;
		;;
	bar)
		rc_flags=&#34;-baz ${rc_flags}&#34;
		;;
	*)
		warn &#34;Invalid value for mumbled_mode&#34; <i class=conum data-value=11></i><b>(11)</b>
		return 1 <i class=conum data-value=12></i><b>(12)</b>
		;;
	esac
	run_rc_command xyzzy <i class=conum data-value=13></i><b>(13)</b>
	return 0
}

mumbled_plugh() <i class=conum data-value=14></i><b>(14)</b>
{
	echo &#39;A hollow voice says &#34;plugh&#34;.&#39;
}

load_rc_config $name
run_rc_command &#34;$1&#34;</pre></div></div><div class=paragraph><p>➊ Se pueden pasar argumentos adicionales a <code>$command</code> mediante <code>command_args</code>. Se añadirán a la línea de comando después de <code>$mumbled_flags</code>. Como la línea de comando final se pasa a <code>eval</code> para su ejecución, se pueden especificar redirecciones de entrada y salida en <code>command_args</code>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p><em>Nunca</em> incluyas opciones con guiones, como <code>-X</code> o <code>--foo</code>, en <code>command_args</code>. El contenido de <code>command_args</code> aparecerá al final de la línea de comando, por lo tanto seguramente aparezcan después que los argumentos presentes en <code>${name}_flags</code>; pero la mayoría de los comandos no reconocen opciones con guiones que aparezcan después de los argumentos ordinarios. Una forma mejor de pasar opciones adicionales a <code>$command</code> es añadirlas al principio de <code>${name}_flags</code>. Otra forma es modificar <code>rc_flags</code> <a href=#rc-flags>como se muestra más adelante</a>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>➋ Un demonio con buenos modales debería crear un <em>pidfile</em> de forma que su proceso se pueda encontrar de forma más fácil y segura. La variable <code>pidfile</code>, si está establecida, le dice a <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.subr&amp;sektion=8&amp;format=html">rc.subr(8)</a> dónde puede encontrar el pidfile para que lo usen sus métodos por defecto.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>De hecho, <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.subr&amp;sektion=8&amp;format=html">rc.subr(8)</a> también usará el pidfile para ver si el demonio está corriendo antes de arrancarlo. Esta comprobación se puede omitir utilizando el argumento <code>faststart</code>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>➌ Si el demonio no puede ejecutarse a menos que exista cierto fichero, tan solo inclúyelos en la lista <code>required_files</code>, y <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.subr&amp;sektion=8&amp;format=html">rc.subr(8)</a> comprobará que esos ficheros existen antes de arrancar el demonio. También existen <code>required_dirs</code> y <code>required_vars</code> para directorios y variables de entorno respectivamente. Todas ellas están descritas con detalle en <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.subr&amp;sektion=8&amp;format=html">rc.subr(8)</a>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Se puede forzar el método por defecto de <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.subr&amp;sektion=8&amp;format=html">rc.subr(8)</a> para que se salte las comprobaciones de prerequisitos utilizando <code>forcestart</code> como argumento del script.</p></div></td></tr></tbody></table></div><div class=paragraph><p>➍ Podemos personalizar qué señales enviar al demonio en caso de que difieran de las que son bien conocidas. En particular, <code>sig_reload</code> especifica la señal que hace que el demonio recargue su configuración; es SIGHUP por defecto. Otra señal se envía para parar el proceso del demonio; por defecto es SIGTERM, pero se puede cambiar estableciendo <code>sig_stop</code> de forma apropiada.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Los nombres de las señales se tienen que especificar a <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.subr&amp;sektion=8&amp;format=html">rc.subr(8)</a> sin el prefijo <code>SIG</code>, como se muestra en el ejemplo. La versión de <a href="https://man.freebsd.org/cgi/man.cgi?query=kill&amp;sektion=1&amp;format=html">kill(1)</a> de FreeBSD puede reconocer el prefijo <code>SIG</code>, pero versiones de otros tipos de OS podrían no hacerlo.</p></div></td></tr></tbody></table></div><div class=paragraph><p>➎➏ Realizar tareas adicionales antes o después de los métodos por defecto es fácil. Para cada comando-argumento soportado por nuestro script, podemos definir <code>argument_precmd</code> y <code>argument_postcmd</code>. Estos comandos <a href="https://man.freebsd.org/cgi/man.cgi?query=sh&amp;sektion=1&amp;format=html">sh(1)</a> se invocan antes y después del método respectivo, como es evidente por sus nombres.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Sobrescribir un método por defecto con un <code>argument_cmd</code> personalizado no nos impide usar <code>argument_precmd</code> o <code>argument_postcmd</code> si lo necesitamos. En particular, el primero es bueno para comprobar condiciones sofisticadas, personalizadas que se deberían cumplir antes de ejecutar el comando. Usar <code>argument_precmd</code> junto con <code>argument_cmd</code> nos permite realizar una separación lógica de las comprobaciones y la acción.</p></div><div class=paragraph><p>No olvides que puedes poner cualquier expresión <a href="https://man.freebsd.org/cgi/man.cgi?query=sh&amp;sektion=1&amp;format=html">sh(1)</a> válida dentro de los métodos, pre-, y post-commands que defines. Invocar simplemente una función que realiza el trabajo es un buen estilo en la mayoría de los casos, pero nunca dejes que el estilo limite tu entendimiento de lo que sucede por debajo.</p></div></td></tr></tbody></table></div><div class=paragraph><p>➐ Si quieres implementar argumentos personalizados, que también se pueden entender como <em>comandos</em> para nuestro script, necesitamos listarlos en <code>extra_commands</code> y proporcionar métodos para manejarlos.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>El comando <code>reload</code> es especial. Por un lados tiene un método preestablecido en <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.subr&amp;sektion=8&amp;format=html">rc.subr(8)</a>. Por otro, <code>reload</code> no se ofrece por defecto. El motivo es que no todos los demonios usan el mismo mecanismo de recarga y algunos no tienen nada que recargar. De forma que tenemos que pedir explícitamente que se proporcione la funcionalidad. Podemos hacerlo mediante <code>extra_commands</code>.</p></div><div class=paragraph><p>¿Qué obtenemos del método por defecto para <code>reload</code>? A menudo los demonios recargan su configuración al recibir una señal - típicamente, SIGHUP. Por lo tanto <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.subr&amp;sektion=8&amp;format=html">rc.subr(8)</a> intenta recargar el demonio enviándole una señal. La están señal está preestablecida a SIGHUP pero se puede cambiar mediante <code>sig_reload</code> si es necesario.</p></div></td></tr></tbody></table></div><div class=paragraph><p>➑⓮ Nuestro script soporta dos comandos no estándar, <code>plugh</code> y <code>xyzzy</code>. Los hemos visto listados en <code>extra_commands</code>, y ahora es momento de proporcionarles métodos. El método para <code>xyzzy</code> está entre líneas mientras que el de <code>plugh</code> se implementa en la función <code>mumbled_plugh</code>.</p></div><div class=paragraph><p>Los comandos no estándar no se invocan durante el arranque o el apagado. Normalmente están ahí por conveniencia para los administradores. También se pueden usar desde otros subsistemas, por ejemplo, <a href="https://man.freebsd.org/cgi/man.cgi?query=devd&amp;sektion=8&amp;format=html">devd(8)</a> si se especifica en <a href="https://man.freebsd.org/cgi/man.cgi?query=devd.conf&amp;sektion=5&amp;format=html">devd.conf(5)</a>.</p></div><div class=paragraph><p>Se puede encontrar la lista completa de comandos disponibles en la línea de uso imprimida por <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.subr&amp;sektion=8&amp;format=html">rc.subr(8)</a> cuando se invoca el script sin argumentos. Por ejemplo, esta es la línea de uso para el script que estamos estudiando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /etc/rc.d/mumbled</span>
Usage: /etc/rc.d/mumbled <span class=o>[</span>fast|force|one]<span class=o>(</span>start|stop|restart|rcvar|reload|plugh|xyzzy|status|poll<span class=o>)</span></code></pre></div></div><div class=paragraph><p>⓭ Un script puede invocar sus comandos estándar y no estándar si lo necesita. Esto parece similar a llamar a funciones, pero sabemos que los comandos y funciones del shell no son siempre la misma cosa. Por ejemplo, <code>xyzzy</code> aquí no se implementa como una función. Además, puede haber pre-comandos y post-comandos, que se deberían invocar en orden. De modo que la forma apropiada para que un script ejecute sus propios comandos es mediante <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.subr&amp;sektion=8&amp;format=html">rc.subr(8)</a>, como se muestra en el ejemplo.</p></div><div class=paragraph><p>➒ <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.subr&amp;sektion=8&amp;format=html">rc.subr(8)</a> proporciona una función útil llamada <code>checkyesno</code>. Admite una variable como argumento y devuelve cero si y sólo si la variable está establecida a <code>YES</code>, o <code>TRUE</code>, o <code>ON</code>, o <code>1</code>, sin considerar mayúsculas y minúsculas; devuelve un valor distinto de cero en caso contrario. En el último caso, la función comprueba que la variable esté establecida a <code>NO</code>, <code>FALSE</code>, <code>OFF</code>, o <code>0</code>, sin distinguir entre mayúsculas y minúsculas; imprime un aviso si la variable contiene cualquier otra cosa, es decir, basura.</p></div><div class=paragraph><p>Ten en cuenta que para <a href="https://man.freebsd.org/cgi/man.cgi?query=sh&amp;sektion=1&amp;format=html">sh(1)</a> un código de salida igual a cero significa verdadero y distinto de cero significa falso.</p></div><div class="admonitionblock important"><table><tbody><tr><td class=icon><i class="fa icon-important" title=Important></i></td><td class=content><div class=paragraph><p>La función <code>checkyesno</code> admite un <em>nombre de variable</em>. No pases el <em>valor</em> expandido de una variable; no funcionará como se espera.</p></div><div class=paragraph><p>Lo siguiente es un uso correcto de <code>checkyesno</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>if checkyesno mumbled_enable; then
        foo
fi</pre></div></div><div class=paragraph><p>Por el contrario, llamar a <code>checkyesno</code> como se muestra abajo no funcionará - al menos no como se espera:</p></div><div class="literalblock programlisting"><div class=content><pre>if checkyesno &#34;${mumbled_enable}&#34;; then
        foo
fi</pre></div></div></td></tr></tbody></table></div><div class=paragraph><p>➓ <a id=rc-flags></a>Podemos alterar los flags que se pasan a <code>$command</code> modificando <code>rc_flags</code> en <code>$start_precmd</code>.</p></div><div class=paragraph><p>⓫ En algunos casos podríamos necesitar emitir un mensaje importante que debería ir también a <code>syslog</code>. Se puede hacer fácilmente con las siguientes funciones de <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.subr&amp;sektion=8&amp;format=html">rc.subr(8)</a>: <code>debug</code>, <code>info</code>, <code>warn</code>, y <code>err</code>. La última función sale del script con el código especificado.</p></div><div class=paragraph><p>⓬ Los códigos de salida de los métodos y sus pre-comandos no se ignoran simplemente por defecto. Si <code>argument_precmd</code> devuelve un código de salida distinto de cero, el método principal no se ejecutará. Del mismo modo, <code>argument_postcmd</code> no será invocado a menos que el método principal devuelva un código de salida igual a cero.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Sin embargo, desde la línea de comando se puede indicar a <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.subr&amp;sektion=8&amp;format=html">rc.subr(8)</a> que ignore esos códigos de salida e invoque todos los comandos añadiendo el prefijo <code>force</code> a los argumentos, como en <code>forcestart</code>.</p></div></td></tr></tbody></table></div></div></div><div class=sect1><h2 id=rcng-hookup>7. Conectando un script al framework rc.d<a class=anchor href=#rcng-hookup></a></h2><div class=sectionbody><div class=paragraph><p>Después de que se ha escrito un script, es necesario integrarlo en <span class=filename>rc.d</span>. El paso crucial es instalar el script en <span class=filename>/etc/rc.d</span> (para el sistema base) o <span class=filename>/usr/local/etc/rc.d</span> (para los ports). Tanto <span class=filename>bsd.prog.mk</span> como <span class=filename>bsd.port.mk</span> proporcionan los hooks necesarios para ello, y normalmente no tienes que preocuparte acerca de los permisos y el propietario. Los scripts de sistema deberían instalarse desde <span class=filename>src/libexec/rc/rc.d</span> mediante el <span class=filename>Makefile</span> que se encuentra allí. Los scripts de ports se pueden instalar con <code>USE_RC_SUBR</code> como se describe <a href=https://docs.freebsd.org/en/books/porters-handbook/#rc-scripts>en el Porter’s Handbook</a>.</p></div><div class=paragraph><p>Sin embargo, debemos considerar de antemano el lugar de nuestro script en la secuencia de inicio del sistema. Es probable que el servicio manejado por nuestro script dependa de otros servicios. Por ejemplo, un demonio de red no puede funcionar sin las interfaces de red y enrutamiento en funcionamiento. Incluso si un servicio parece no exigir nada, difícilmente puede iniciarse antes de que se hayan verificado y montado los sistemas de archivos básicos.</p></div><div class=paragraph><p>Ya hemos mencionado <a href="https://man.freebsd.org/cgi/man.cgi?query=rcorder&amp;sektion=8&amp;format=html">rcorder(8)</a>. Ahora es momento de mirarlo detenidamente. En pocas palabras, <a href="https://man.freebsd.org/cgi/man.cgi?query=rcorder&amp;sektion=8&amp;format=html">rcorder(8)</a> toma un conjunto de ficheros, examina el contenido e imprime una lista ordenada de dependencias de ficheros del conjunto a <code>stdout</code>. El objetivo es mantener la información de dependencia <em>dentro</em> de los ficheros de forma que cada uno de ellos sólo habla por sí mismo. Un fichero puede especificar la siguiente información:</p></div><div class=ulist><ul><li><p>los nombres de las "condiciones" (lo que para nosotros significa servicios) que <em>proporciona</em>;</p></li><li><p>los nombres de las "condiciones" que <em>requiere</em>;</p></li><li><p>los nombres de las "condiciones" para las cuales este fichero debería ejecutarse <em>con anterioridad</em>;</p></li><li><p><em>palabras clave</em> adicionales que se pueden usar para seleccionar un subconjunto de todo el conjunto de ficheros (se puede indicar a <a href="https://man.freebsd.org/cgi/man.cgi?query=rcorder&amp;sektion=8&amp;format=html">rcorder(8)</a> mediante opciones que incluya u omita ficheros que contengan determinadas palabras clave)</p></li></ul></div><div class=paragraph><p>No es sorprendente que <a href="https://man.freebsd.org/cgi/man.cgi?query=rcorder&amp;sektion=8&amp;format=html">rcorder(8)</a> pueda manejar sólo ficheros de texto con una sintaxis similar a la de <a href="https://man.freebsd.org/cgi/man.cgi?query=sh&amp;sektion=1&amp;format=html">sh(1)</a>. Es decir, las líneas especiales entendidas por <a href="https://man.freebsd.org/cgi/man.cgi?query=rcorder&amp;sektion=8&amp;format=html">rcorder(8)</a> se parecen a comentarios de <a href="https://man.freebsd.org/cgi/man.cgi?query=sh&amp;sektion=1&amp;format=html">sh(1)</a>. La sintaxis de dichas líneas especiales es bastante rígida para simplificar su procesamiento. Lee <a href="https://man.freebsd.org/cgi/man.cgi?query=rcorder&amp;sektion=8&amp;format=html">rcorder(8)</a> para más detalles.</p></div><div class=paragraph><p>Además de utilizar líneas especiales de <a href="https://man.freebsd.org/cgi/man.cgi?query=rcorder&amp;sektion=8&amp;format=html">rcorder(8)</a>, un script puede incidir en sus dependencias de otro servicio forzando su arranque. Esto podría ser necesario cuando el otro servicio es opcional y no arrancará por sí mismo porque el administrador lo ha deshabilitado por error en <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a>.</p></div><div class=paragraph><p>Con este conocimiento general en mente, consideremos el script demonio simple mejorado con información de dependencia:</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh

# PROVIDE: mumbled oldmumble <i class=conum data-value=1></i><b>(1)</b>
# REQUIRE: DAEMON cleanvar frotz <i class=conum data-value=2></i><b>(2)</b>
# BEFORE:  LOGIN <i class=conum data-value=3></i><b>(3)</b>
# KEYWORD: nojail shutdown <i class=conum data-value=4></i><b>(4)</b>

. /etc/rc.subr

name=mumbled
rcvar=mumbled_enable

command=&#34;/usr/sbin/${name}&#34;
start_precmd=&#34;${name}_prestart&#34;

mumbled_prestart()
{
	if ! checkyesno frotz_enable &amp;&amp; \
	    ! /etc/rc.d/frotz forcestatus 1&gt;/dev/null 2&gt;&amp;1; then
		force_depend frotz || return 1 <i class=conum data-value=5></i><b>(5)</b>
	fi
	return 0
}

load_rc_config $name
run_rc_command &#34;$1&#34;</pre></div></div><div class=paragraph><p>Como antes, sigue un análisis detallado:</p></div><div class=paragraph><p>➊ Esa línea declara los nombres de las "condiciones" que proporciona nuestro script. Ahora otros scripts pueden registrar una dependencia de nuestro script usando dichos nombres.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Por lo general, un script especifica una sola condición proporcionada. Sin embargo, nada nos impide enumerar varias condiciones allí, por ejemplo, por razones de compatibilidad.</p></div><div class=paragraph><p>En cualquier caso, el nombre de la condición <code>PROVIDE:</code> principal, o única, debería ser el mismo que <code>${name}</code>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>➋➌ Nuestro script indica de qué "condiciones" depende que son proporcionadas por otros scripts. Según esas líneas nuestro script pide a <a href="https://man.freebsd.org/cgi/man.cgi?query=rcorder&amp;sektion=8&amp;format=html">rcorder(8)</a> situarlo después del script (o los scripts) que proporcionan <span class=filename>DAEMON</span> y <span class=filename>cleanvar</span>, pero antes de los que proporcionan <span class=filename>LOGIN</span>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>No se debería abusar de la línea <code>BEFORE:</code> para evitar una lista de dependencias incompleta en el otro script. El caso apropiado para usar <code>BEFORE:</code> es cuando el otro script no se preocupa por el nuestro, pero nuestro script puede hacer mejor su tarea si se ejecuta antes que el otro. Un ejemplo típico de la vida real son las interfaces de red frente al firewall: si bien las interfaces no dependen del firewall para hacer su trabajo, la seguridad del sistema se beneficiará de que el firewall esté listo antes de que haya tráfico de red.</p></div><div class=paragraph><p>Además de las condiciones que se corresponden con un solo servicio, hay meta-condiciones y sus scripts tipo "placeholder" para asegurar que ciertos grupos de operaciones se ejecutan antes que otras. Se distinguen por sus nombres en <span class=filename>MAYÚSCULAS</span>. Su listado y propósito se puede encontrar en <a href="https://man.freebsd.org/cgi/man.cgi?query=rc&amp;sektion=8&amp;format=html">rc(8)</a>.</p></div><div class=paragraph><p>Ten en cuenta que poner un nombre de servicio en la línea <code>REQUIRE:</code> no garantiza que el servicio se esté ejecutando cuando nuestro script arranque. El servicio podría fallar al arrancar o estar deshabilitado en <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a>. Obviamente, <a href="https://man.freebsd.org/cgi/man.cgi?query=rcorder&amp;sektion=8&amp;format=html">rcorder(8)</a> no puede controlar esos detalles y <a href="https://man.freebsd.org/cgi/man.cgi?query=rc&amp;sektion=8&amp;format=html">rc(8)</a> tampoco lo hará. Por lo tanto, la aplicación arrancada por nuestro script debería ser capaz de lidiar con situaciones en las que algún servicio requerido no esté disponible. En ciertos casos, podemos evitarlo como se discute <a href=#forcedep>abajo</a></p></div></td></tr></tbody></table></div><div class=paragraph><p><a id=keywords></a>➍ Como recordamos del texto anterior, las palabras clave de <a href="https://man.freebsd.org/cgi/man.cgi?query=rcorder&amp;sektion=8&amp;format=html">rcorder(8)</a> se pueden utilizar para seleccionar o excluir algunos scripts. Cualquier consumidor de <a href="https://man.freebsd.org/cgi/man.cgi?query=rcorder&amp;sektion=8&amp;format=html">rcorder(8)</a> puede especificar mediante las opciones <code>-k</code> y <code>-s</code> qué palabras clave están en la lista "a mantener" y la lista "a omitir", respectivamente. De todos los ficheros que serán ordenados como dependencias, <a href="https://man.freebsd.org/cgi/man.cgi?query=rcorder&amp;sektion=8&amp;format=html">rcorder(8)</a> escogerá sólo aquellos que tengan las palabras clave de la lista "a mantener" (a menos que esté vacía) y que no tenga la palabra clave en la lista "a omitir".</p></div><div class=paragraph><p>En FreeBSD, <span class=filename>/etc/rc</span> y <span class=filename>/etc/rc.shutdown</span> usan <a href="https://man.freebsd.org/cgi/man.cgi?query=rcorder&amp;sektion=8&amp;format=html">rcorder(8)</a>. Estos dos scripts definen la lista estándar de palabras clave del <span class=filename>rc.d</span> de FreeBSD y su significado es el que sigue:</p></div><div class=dlist><dl><dt class=hdlist1>nojail</dt><dd><p>El servicio no es para un entorno <a href="https://man.freebsd.org/cgi/man.cgi?query=jail&amp;sektion=8&amp;format=html">jail(8)</a>. Los procedimientos automáticos de arranque y parada ignorarán el script si está dentro de un jail.</p></dd><dt class=hdlist1>nostart</dt><dd><p>El servicio se tiene que arrancar manualmente o no se arrancará. El procedimiento de arranque automático ignorará el script. Esto se puede usar, junto con la palabra clave <span class=filename>shutdown</span>, para escribir scripts que hace algo sólo cuando se para el sistema.</p></dd><dt class=hdlist1>shutdown</dt><dd><p>Esta palabra clave se especifica <em>explícitamente</em> si se necesita parar el servicio antes de la parada del sistema.</p></dd></dl></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Cuando el sistema se va a apagar, se ejecuta <span class=filename>/etc/rc.shutdown</span>. Asume que la mayoría de los scripts <span class=filename>rc.d</span> no tienen nada que hacer la mayoría del tiempo. Por lo tanto <span class=filename>/etc/rc.shutdown</span> invoca los scripts de <span class=filename>rc.d</span> de forma selectiva con la palabra clave <span class=filename>shutdown</span>, ignorando de forma efectiva el resto de los scripts. Para hacer un apagado incluso más rápido <span class=filename>/etc/rc.shutdown</span> pasa el comando <span class=filename>faststop</span> a los scripts que ejecuta de forma que se salten las comprobaciones preliminares, por ejemplo la comprobación del pidfile. Como los servicios dependientes se deberían parar antes que sus prerequisitos, <span class=filename>/etc/rc.shutdown</span> ejecuta los scripts en orden inverso de dependencia. Si escribes un script <span class=filename>rc.d</span>, deberías considerar si es relevante en el momento del apagado. Por ejemplo, si tu script hace su trabajo como respuesta sólo al comando <span class=filename>start</span>, entonces no necesitas incluir esta palabra clave. Sin embargo, si tu script gestiona un servicio, probablemente es una buena idea pararlo antes de que el sistema proceda a la fase final de su secuencia de apagado descrito en <a href="https://man.freebsd.org/cgi/man.cgi?query=halt&amp;sektion=8&amp;format=html">halt(8)</a>. En particular, un servicio se debería parar de forma explícita si necesita un tiempo considerable o acciones especiales para pararse de forma limpia. Un ejemplo típico de dicho servicio es un motor de bases de datos.</p></div></td></tr></tbody></table></div><div class=paragraph><p><a id=forcedep></a>➎ Para empezar, <code>force_depend</code> debería usarse con mucho cuidado. Normalmente es mejor revisar la jerarquía de variables de configuración para tu script de <span class=filename>rc.d</span> si son interdependientes.</p></div><div class=paragraph><p>Si aún así no puedes evitar usar <code>force_depend</code>, el ejemplo ofrece una forma habitual de cómo invocarlo de forma condicional. En el ejemplo, nuestro demonio <code>mumbled</code> requiere que otro, <code>frotz</code>, se arranque con antelación. Sin embargo, <code>frotz</code> también es opcional; y <a href="https://man.freebsd.org/cgi/man.cgi?query=rcorder&amp;sektion=8&amp;format=html">rcorder(8)</a> no sabe nada acerca de ese detalle. Afortunadamente, nuestro script tiene acceso a todas las variables de <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a>. Si <code>frotz_enable</code> es verdadero, esperamos lo mejor y confiamos en que <span class=filename>rc.d</span> haya arrancado <code>frotz</code>. De lo contrario comprobamos el estado de <code>frotz</code>. Finalmente, forzamos nuestra dependencia de <code>frotz</code> si se constata que no se está ejecutando. <code>force_depend</code> emitirá un mensaje de aviso porque se debería invocar sólo si se ha detectado una mala configuración.</p></div></div></div><div class=sect1><h2 id=rcng-args>8. Dar más flexibilidad a un script rc.d<a class=anchor href=#rcng-args></a></h2><div class=sectionbody><div class=paragraph><p>Cuando se invoca durante el arranque o la parada, un script <span class=filename>rc.d</span> se supone que actúa en todo el subsistema del que es responsable. Por ejemplo, <span class=filename>/etc/rc.d/netif</span> debería arrancar o parar todas las interfaces de red descritas en <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a>. Se puede indicar cualquiera de los dos comandos utilizando un argumento como <code>start</code> o <code>stop</code>. Entre el arranque y la parada, los scripts <span class=filename>rc.d</span> ayudan al administrador a controlar el sistema en ejecución, y es cuando surge la necesidad de mayor flexibilidad y precisión. Por ejemplo, el administrador podría querer añadir la configuración de una nueva interfaz de red a <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a> y luego arrancarla sin interferir con la operación de las interfaces existentes. La siguiente vez el administrador podría necesitar parar una interfaz de red concreta. Siguiendo el espíritu de la línea de comandos, el script respectivo de <span class=filename>rc.d</span> necesita un argumento extra, el nombre de la interfaz.</p></div><div class=paragraph><p>Afortunadamente, <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.subr&amp;sektion=8&amp;format=html">rc.subr(8)</a> permite pasar un número arbitrario de argumentos a los métodos del script (dentro de los límites del sistema). Debido a esto, los cambios en el script pueden ser mínimos.</p></div><div class=paragraph><p>¿Cómo puede <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.subr&amp;sektion=8&amp;format=html">rc.subr(8)</a> obtener acceso a los argumentos extra de la línea de comando? ¿Debería simplemente obtenerlos? De ningún modo. Primero, una función de <a href="https://man.freebsd.org/cgi/man.cgi?query=sh&amp;sektion=1&amp;format=html">sh(1)</a> no tiene acceso a los parámetros posicionales del llamante, pero <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.subr&amp;sektion=8&amp;format=html">rc.subr(8)</a> es simplemente una pila de dichas funciones. Segundo, las buenas maneras de <span class=filename>rc.d</span> dictan que es el script principal el encargado de decidir qué argumentos se pasan a sus métodos.</p></div><div class=paragraph><p>De modo que la aproximación de <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.subr&amp;sektion=8&amp;format=html">rc.subr(8)</a> es como sigue: <code>run_rc_command</code> pasa todos sus argumentos salvo el primero de forma literal al método respectivo. El primer argumento, omitido, es el nombre del método en sí: <code>start</code>, <code>stop</code>, etc. <code>run_rc_commad</code> lo desplazará de forma que lo que es <code>$2</code> en la línea de comandos original se presentará como <code>$1</code> al método y así sucesivamente.</p></div><div class=paragraph><p>Para ilustrar esta oportunidad, modifiquemos el script ficticio primitivo para que sus mensajes dependan de los argumentos adicionales proporcionados. Aquí vamos:</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh

. /etc/rc.subr

name=&#34;dummy&#34;
start_cmd=&#34;${name}_start&#34;
stop_cmd=&#34;:&#34;
kiss_cmd=&#34;${name}_kiss&#34;
extra_commands=&#34;kiss&#34;

dummy_start()
{
        if [ $# -gt 0 ]; then <i class=conum data-value=1></i><b>(1)</b>
                echo &#34;Greeting message: $*&#34;
        else
                echo &#34;Nothing started.&#34;
        fi
}

dummy_kiss()
{
        echo -n &#34;A ghost gives you a kiss&#34;
        if [ $# -gt 0 ]; then <i class=conum data-value=2></i><b>(2)</b>
                echo -n &#34; and whispers: $*&#34;
        fi
        case &#34;$*&#34; in
        *[.!?])
                echo
                ;;
        *)
                echo .
                ;;
        esac
}

load_rc_config $name
run_rc_command &#34;$@&#34; <i class=conum data-value=3></i><b>(3)</b></pre></div></div><div class=paragraph><p>¿Qué cambios esenciales podemos notar en el script?</p></div><div class=paragraph><p>➊ Todos los argumentos que escribas después de <code>start</code> terminan como parámetros posicionales en el método respectivo. Podemos utilizarlos de cualquier forma de acuerdo con nuestra tarea, habilidades e imaginación. En el ejemplo actual, simplemente los pasamos todos a <a href="https://man.freebsd.org/cgi/man.cgi?query=echo&amp;sektion=1&amp;format=html">echo(1)</a> como una cadena en la siguiente línea - fíjate en <code>$*</code> dentro de las comillas dobles. Aquí se ve cómo se puede invocar ahora el script:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /etc/rc.d/dummy start</span>
Nothing started.

<span class=c># /etc/rc.d/dummy start Hello world!</span>
Greeting message: Hello world!</code></pre></div></div><div class=paragraph><p>➋ Lo mismo aplica a cualquier método proporcionado por nuestro script, no sólo a los estándar. Hemos añadido un método personalizado llamado <code>kiss</code> y puede aprovecharse de los argumentos extra del mismo modo que lo hace <code>start</code>. Ejemplo:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /etc/rc.d/dummy kiss</span>
A ghost gives you a kiss.

<span class=c># /etc/rc.d/dummy kiss Once I was Etaoin Shrdlu...</span>
A ghost gives you a kiss and whispers: Once I was Etaoin Shrdlu...</code></pre></div></div><div class=paragraph><p>➌ Si queremos pasar todos los argumentos extra a cualquier método, podemos simplemente sustituir <code>"$@"</code> por <code>"$1"</code> en la última línea de nuestro script, cuando invocamos <code>run_rc_command</code>.</p></div><div class="admonitionblock important"><table><tbody><tr><td class=icon><i class="fa icon-important" title=Important></i></td><td class=content><div class=paragraph><p>Un programador de <a href="https://man.freebsd.org/cgi/man.cgi?query=sh&amp;sektion=1&amp;format=html">sh(1)</a> tiene que entender la sutil diferencia entre <code>$*</code> y <code>$@</code> como formas de designar todos los parámetros posicionales. Para una discusión en profundidad, consulta un buen manual de script de <a href="https://man.freebsd.org/cgi/man.cgi?query=sh&amp;sektion=1&amp;format=html">sh(1)</a>. <em>No</em> uses las expresiones hasta que las entiendas completamente porque un uso inadecuado puede resultar en scripts defectuosos e inseguros.</p></div></td></tr></tbody></table></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Actualmente <code>run_rc_command</code> podría tener un bug que impide que mantenga los límites originales entre los argumentos. Es decir, los argumentos con espacios en blanco podrían no procesarse correctamente. El bug nace de un uso inadecuado de <code>$*</code>.</p></div></td></tr></tbody></table></div></div></div><div class=sect1><h2 id=rcng-furthur>9. Otras lecturas<a class=anchor href=#rcng-furthur></a></h2><div class=sectionbody><div class=paragraph><p><a id=lukem></a><a href=http://www.mewburn.net/luke/papers/rc.d.pdf>El artículo original de Luke Mewburn</a> ofrece una visión general de <span class=filename>rc.d</span> y una explicación detallada de las decisiones de diseño. Proporciona información sobre todo el framework de <span class=filename>rc.d</span> y su lugar de un sistema operativo BSD moderno.</p></div><div class=paragraph><p><a id=manpages></a>Las páginas del manual de <a href="https://man.freebsd.org/cgi/man.cgi?query=rc&amp;sektion=8&amp;format=html">rc(8)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.subr&amp;sektion=8&amp;format=html">rc.subr(8)</a>, y <a href="https://man.freebsd.org/cgi/man.cgi?query=rcorder&amp;sektion=8&amp;format=html">rcorder(8)</a> documentan los componentes de <span class=filename>rc.d</span> en gran detalle. No puedes usar toda la potencia de <span class=filename>rc.d</span> sin estudiar las páginas del manual y hacer referencia a ellas mientras escribes tus propios scripts.</p></div><div class=paragraph><p>La mayor fuente de ejemplos de la vida real en funcionamiento es <span class=filename>/etc/rc.d</span> en un sistema real. Su contenido es fácil y agradable de leer porque la mayoría de los asuntos espinosos están escondidos en <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.subr&amp;sektion=8&amp;format=html">rc.subr(8)</a>. De cualquier forma ten en cuenta que los scripts de <span class=filename>/etc/rc.d</span> no han sido escritos por los ángeles, así que podrían tener bugs y decisiones de diseño subóptimas. ¡Ahora puedes mejorarlos!</p></div></div></div><hr><div class=last-modified><p><strong>Last modified on</strong>: 29 de diciembre de 2022 by <a href="https://cgit.freebsd.org/doc/commit/?id=6a086fefdd" target=_blank>Fernando Apesteguía</a></p></div></div><aside class=toc><div class=toc-content><h3>Tabla de contenidos</h3><nav id=TableOfContents><ul><li><a href=#rcng-intro>1. Introducción</a></li><li><a href=#rcng-task>2. Delineando la tarea</a></li><li><a href=#rcng-dummy>3. Un guión ficticio</a></li><li><a href=#rcng-confdummy>4. Un script ficticio configurable</a></li><li><a href=#rcng-daemon>5. Arranque y parada de un demonio simple</a></li><li><a href=#rcng-daemon-adv>6. Arranque y parada de un demonio avanzado</a></li><li><a href=#rcng-hookup>7. Conectando un script al framework rc.d</a></li><li><a href=#rcng-args>8. Dar más flexibilidad a un script rc.d</a></li><li><a href=#rcng-furthur>9. Otras lecturas</a></li></ul></nav><hr><div class=resources><h3>Recursos</h3><ul class=contents><li><i class="fa fa-file-pdf-o" aria-hidden=true title="Descargar PDF"></i><a href=https://download.freebsd.org/doc/es/articles/rc-scripting/rc-scripting_es.pdf>Descargar PDF</a></li><li><i class="fa fa-pencil-square-o" aria-hidden=true title="Editar esta página"></i><a href=https://github.com/freebsd/freebsd-doc/blob/main/documentation/content/es/_index target=_blank>Editar esta página</a></li></ul></div></div></aside></main><footer><div class=footer-container><section class=logo-column><img src=https://docs.freebsd.org/images/FreeBSD-colors.svg width=160 height=50 alt="FreeBSD logo"><div class=options-container><div class=language-container><a id=languages href=https://docs.freebsd.org/es/languages><img src=https://docs.freebsd.org/images/language.png class=language-image alt="Elegir idioma">
<span>Spanish</span></a></div><div class=theme-container><select id=theme-chooser><option value=theme-system>System</option><option value=theme-light>Claro</option><option value=theme-dark>Oscuro</option><option value=theme-high-contrast>Alto contraste</option></select></div></div></section><section class=about-column><h3 class=column-title>About</h3><ul class=column-elements-container><li><a href=https://www.freebsd.org/about/ target=_blank class=column-element>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/ target=_blank class=column-element>FreeBSD Foundation</a></li><li><a href=https://www.freebsd.org/where/ target=_blank class=column-element>Get FreeBSD</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct target=_blank class=column-element>Code of Conduct</a></li><li><a href=https://www.freebsd.org/security/ target=_blank class=column-element>Security Advisories</a></li></ul></section><section class=documentation-column><h3 class=column-title>Documentation</h3><ul class=column-elements-container><li><a href=/es class=column-element>Documentation portal</a></li><li><a href=https://man.FreeBSD.org target=_blank class=column-element>Manual pages</a></li><li><a href=https://papers.FreeBSD.org target=_blank class=column-element>Presentations and papers</a></li><li><a href=https://docs-archive.freebsd.org/doc/ target=_blank class=column-element>Previous versions</a></li><li><a href=https://docs-archive.freebsd.org/44doc/ target=_blank class=column-element>4.4BSD Documents</a></li><li><a href=https://wiki.freebsd.org/ target=_blank class=column-element>Wiki</a></li></ul></section><section class=community-column><h3 class=column-title>Community</h3><ul class=column-elements-container><li><a href=https://docs.freebsd.org/es/articles/contributing class=column-element>Get involved</a></li><li><a href=https://forums.freebsd.org/ target=_blank class=column-element>Community forum</a></li><li><a href=https://lists.freebsd.org/ target=_blank class=column-element>Mailing lists</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank class=column-element>IRC Channels</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank class=column-element>Bug Tracker</a></li></ul></section><section class=legal-column><h3 class=column-title>Legal</h3><ul class=column-elements-container><li><a href=https://freebsdfoundation.org/donate/ target=_blank class=column-element>Donations</a></li><li><a href=https://www.freebsd.org/copyright/freebsd-license/ target=_blank class=column-element>Licensing</a></li><li><a href=https://www.freebsd.org/privacy/ target=_blank class=column-element>Privacy Policy</a></li><li><a href=https://www.freebsd.org/copyright/ target=_blank class=column-element>Legal notices</a></li></ul></section><section class=copyright-column><p>&copy; 1994-2024 The FreeBSD Project. All rights reserved</p><span>Made with <span class=heart>♥</span> by the FreeBSD Community</span></section></div></footer></body></html>