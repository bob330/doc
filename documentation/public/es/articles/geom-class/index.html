<!doctype html><html class=theme-light lang=es><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Una guía sobre los detalles de GEOM y cómo escribir tu propia clase GEOM"><meta name=keywords content="GEOM,kernel,modules,FreeBSD"><meta name=copyright content="1995-2024 The FreeBSD Foundation"><link rel=canonical href=http://172.16.201.134:1313/es/articles/geom-class/><title>Escribiendo una clase GEOM | Portal de documentación de FreeBSD</title>
<meta name=theme-color content="#790000"><meta name=color-scheme content="system light dark high-contrast"><link rel="shortcut icon" href=http://172.16.201.134:1313/favicon.ico><link rel=stylesheet href=http://172.16.201.134:1313/styles/main.min.css><link rel=stylesheet href=http://172.16.201.134:1313/css/font-awesome-min.css><script defer src=/js/theme-chooser.min.js></script><script defer src=/js/copy-clipboard.min.js></script><script defer src=/js/search.min.js></script><meta name=twitter:card content="summary"><meta name=twitter:domain content="docs.FreeBSD.org"><meta name=twitter:site content="@freebsd"><meta name=twitter:url content="https://twitter.com/freebsd"><meta property="og:title" content="Escribiendo una clase GEOM"><meta property="og:description" content="Una guía sobre los detalles de GEOM y cómo escribir tu propia clase GEOM"><meta property="og:type" content="website"><meta property="og:image" content="http://172.16.201.134:1313/favicon.ico"><meta property="og:image:alt" content="FreeBSD Logo"><meta property="og:locale" content="es"><meta property="og:url" content="http://172.16.201.134:1313/es/articles/geom-class/"><meta property="og:site_name" content="Portal de documentación de FreeBSD"><script type=application/ld+json>{"@context":"http://schema.org","@type":"Article","url":"http:\/\/172.16.201.134:1313\/es\/articles\/geom-class\/","name":"Portal de documentación de FreeBSD","headline":"Portal de documentación de FreeBSD","description":"FreeBSD Documentation Portal"}</script></head><body><header><div class=header-container><div class=logo-menu-bars-container><a href=https://www.FreeBSD.org class=logo><img src=http://172.16.201.134:1313/images/FreeBSD-monochromatic.svg width=160 height=50 alt="FreeBSD logo">
</a><label class=menu-bars for=menu-bars><i class="fa fa-bars" aria-hidden=true></i></label></div><input id=menu-bars type=checkbox><nav><ul class=menu><li class=menu-item><input id=about type=checkbox>
<a href=# aria-label="Navigate to About section"><label class=menu-item-description for=about>About
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/about/ target=_blank>About</a></li><li><a href=https://www.freebsd.org/about/ target=_blank>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/about-us/about-the-foundation/ target=_blank>FreeBSD Foundation</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct/ target=_blank>Code of Conduct</a></li></ul></li><li class=menu-item><input id=download type=checkbox>
<a href=# aria-label="Navigate to get FreeBSD section"><label class=menu-item-description for=download>Get FreeBSD
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/where/ target=_blank>Get FreeBSD</a></li><li><a href=https://www.freebsd.org/releases/ target=_blank>Release Information</a></li><li><a href=https://www.freebsd.org/releng/ target=_blank>Release Engineering</a></li><li><a href=https://www.freebsd.org/security/ target=_blank>Security Advisories</a></li></ul></li><li class=menu-item><input id=documentation type=checkbox>
<a href=# aria-label="Navigate to get Documentation section"><label class=menu-item-description for=documentation>Documentation
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=/es>Documentation portal</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook>FreeBSD Handbook</a></li><li><a href=http://172.16.201.134:1313/es/books/porters-handbook>Porter's Handbook</a></li><li><a href=https://docs.FreeBSD.org/en/books/fdp-primer>Documentation Project Handbook</a></li><li><a href=https://man.FreeBSD.org target=_blank>Manual pages</a></li><li><a href=https://papers.FreeBSD.org target=_blank>Presentations and papers</a></li><li><a href=https://wiki.FreeBSD.org target=_blank>Wiki</a></li><li><a href=http://172.16.201.134:1313/es/books>Books</a></li><li><a href=http://172.16.201.134:1313/es/articles>Articles</a></li></ul></li><li class=menu-item><input id=community type=checkbox>
<a href=# aria-label="Navigate to get Community section"><label class=menu-item-description for=community>Community
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/community/>Community</a></li><li><a href=http://172.16.201.134:1313/es/articles/contributing>Get involved</a></li><li><a href=https://forums.freebsd.org/ target=_blank>Forum</a></li><li><a href=https://lists.freebsd.org/ target=_blank>Mailing lists</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank>IRC Channels</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank>Bug Tracker</a></li><li><a href=https://www.freebsd.org/support/ target=_blank>Support</a></li></ul></li></ul></nav><div class=search-donate-container><form class=search method=get id=search-header-form action=https://docs.freebsd.org/search name=search-header-form><input type=hidden name=DB value=es>
<input id=words name=P type=text size=20 maxlength=255>
<button>
<i class="fa fa-search" aria-hidden=true></i></button></form><div class=donate><a href=https://freebsdfoundation.org/donate/ target=_blank><span class=heart>♥</span>
Donate</a></div></div></div></header><main class=main-wrapper-article><div class=article><h1 class=title>Escribiendo una clase GEOM</h1><div class="admonitionblock note"><p><i class="fa fa-exclamation-circle" aria-hidden=true></i>
This translation may be out of date. To help with the translations please access the <a href=https://translate-dev.freebsd.org/ target=_blank>FreeBSD translations instance</a>.</p></div><div class=legalnotice><a id=trademarks></a><details><summary>Marcas registradas</summary><p>FreeBSD es una marca registrada de la Fundación FreeBSD</p><p>Intel, Celeron, Centrino, Core, EtherExpress, i386, i486, Itanium, Pentium, y Xeon son marcas registradas de ntel Corporation o sus subsidiarias en los Estados Unidos de América y otros países.</p><p>Muchos de los nombres usados por los fabricantes y vendedores para diferenciar sus productos son designados como marcas comerciales. Allí donde estos nombres aparezcan en este documento y el Proyecto FreeBSD fuera consciente de la alegación de marca comercial, los nombres tienen a continuación el símbolo “™” o “®”.</p></details></div><div class=toc-mobile><h3>Tabla de contenidos</h3><nav id=TableOfContents><ul><li><a href=#intro>1. Introducción</a></li><li><a href=#prelim>2. Preliminares</a></li><li><a href=#kernelprog>3. Programación del kernel de FreeBSD</a></li><li><a href=#geom>4. Programación GEOM</a></li></ul></nav></div><div id=preamble><div class=sectionbody><div class="paragraph abstract-title"><p>Resumen</p></div><div class=paragraph><p>Este texto documenta algunos puntos de partida en el desarrollo de clases GEOM y módulos del kernel en general. Se asume que el lector está familiarizado con la programación en C en modo usuario.</p></div><hr></div></div><div class=sect1><h2 id=intro>1. Introducción<a class=anchor href=#intro></a></h2><div class=sectionbody><div class=sect2><h3 id=intro-docs>1.1. Documentación<a class=anchor href=#intro-docs></a></h3><div class=paragraph><p>La documentación sobre la programación del kernel es escasa - es una de las pocas áreas donde casi no hay tutoriales amigables, y la frase, "¡usa el código fuente!", realmente es cierta. Sin embargo, hay algunos trozos (algunos de ellos muy desactualizados) flotando alrededor que deben estudiarse antes de comenzar a programar:</p></div><div class=ulist><ul><li><p>El <a href=https://docs.freebsd.org/en/books/developers-handbook/>FreeBSD Developer’s Handbook</a> - parte del proyecto de documentación, no contiene nada específico a la programación del kernel sino más bien algo de información útil en general.</p></li><li><p>El <a href=https://docs.freebsd.org/en/books/arch-handbook/>FreeBSD Architecture Handbook</a> - también parte del proyecto de documentación, contiene descripciones de varios servicios y procedimientos de bajo nivel. El capítulo más importante es el 13, <a href=https://docs.freebsd.org/en/books/arch-handbook/#driverbasics>Writing FreeBSD device drivers</a>.</p></li><li><p>La sección Blueprints del sitio web <a href=http://www.freebsddiary.org>FreeBSD Diary</a> - contiene varios artículos interesantes sobre servicios del kernel.</p></li><li><p>Las páginas del manual en la sección 9 — para documentación importante sobre las funciones del kernel.</p></li><li><p>La página de manual <a href="https://man.freebsd.org/cgi/man.cgi?query=geom&amp;sektion=4&amp;format=html">geom(4)</a> y <a href=http://phk.freebsd.dk/pubs/>PHK’s GEOM slides</a> - para una introducción general al subsistema GEOM.</p></li><li><p>Las páginas del manual <a href="https://man.freebsd.org/cgi/man.cgi?query=g_bio&amp;sektion=9&amp;format=html">g_bio(9)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=g_event&amp;sektion=9&amp;format=html">g_event(9)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=g_data&amp;sektion=9&amp;format=html">g_data(9)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=g_geom&amp;sektion=9&amp;format=html">g_geom(9)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=g_provider&amp;sektion=9&amp;format=html">g_provider(9)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=g_consumer&amp;sektion=9&amp;format=html">g_consumer(9)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=g_access&amp;sektion=9&amp;format=html">g_access(9)</a> y otras enlazadas desde estas, para documentación sobre funcionalidades específicas.</p></li><li><p>La página del manual <a href="https://man.freebsd.org/cgi/man.cgi?query=style&amp;sektion=9&amp;format=html">style(9)</a> - para documentación sobre las convenciones que debe seguir el estilo del código para todo aquel que se va a añadir al árbol de FreeBSD.</p></li></ul></div></div></div></div><div class=sect1><h2 id=prelim>2. Preliminares<a class=anchor href=#prelim></a></h2><div class=sectionbody><div class=paragraph><p>La mejor forma de hacer desarrollo del kernel es tener (al menos) dos ordenadores separados. Uno de ellos debería de tener el entorno de desarrollo y el código fuente, y el otro sería usado para probar el código recién escrito, inicializando y montando su sistema de archivos a través de la red desde el primer ordenador. De esta forma, si el nuevo código contiene errores y bloquea el ordenador, esto no dañará el código fuente (ni ningún otro dato que este ejecutándose en "caliente"). El segundo sistema ni siquiera necesita un monitor adecuado. En su lugar, podría estar conectado con un cable serie o KVM al primer ordenador.</p></div><div class=paragraph><p>Pero como no todo el mundo tiene dos o más ordenadores a mano, hay unas pocas cosas que se pueden hacer para preparar un entorno "en caliente" para desarrollar código del kernel. Esta configuración también se puede aplicar para desarrollar en una máquina virtual <a href=http://www.vmware.com/>VMWare</a> o <a href=http://www.qemu.org/>QEmu</a> (lo siguiente mejor después de tener una máquina como entorno dedicado).</p></div><div class=sect2><h3 id=prelim-system>2.1. Modificar un sistema para el desarrollo<a class=anchor href=#prelim-system></a></h3><div class=paragraph><p>Para cualquier programación del kernel, es obligatoria tener activada la opción <code>INVARIANTS</code>. Así que añade estas líneas a tu archivo de configuración del kernel:</p></div><div class="literalblock programlisting"><div class=content><pre>options INVARIANT_SUPPORT
options INVARIANTS</pre></div></div><div class=paragraph><p>Para tener un mayor nivel de depuración, también debes incluir el soporte de WITNESS, que te advertirá sobre errores relacionados con los bloqueos:</p></div><div class="literalblock programlisting"><div class=content><pre>options WITNESS_SUPPORT
options WITNESS</pre></div></div><div class=paragraph><p>Para depurar los volcados de memoria, se necesita un kernel con símbolos de depuración:</p></div><div class="literalblock programlisting"><div class=content><pre>  makeoptions    DEBUG=-g</pre></div></div><div class=paragraph><p>Con la forma habitual de instalar el kernel (<code>make installkernel</code>) no se instala el kernel de depuración de forma automática. Se llama <span class=filename>kernel.debug</span> y se encuentra en <span class=filename>/usr/obj/usr/src/sys/KERNELNAME/</span>. Por comodidad se debería copiar a <span class=filename>/boot/kernel/</span>.</p></div><div class=paragraph><p>Otra cosa útil es habilitar la depuración del kernel para que puedas examinar el kernel panic cuando suceda. Para esto, introduce las siguientes líneas en su archivo de configuración del kernel:</p></div><div class="literalblock programlisting"><div class=content><pre>options KDB
options DDB
options KDB_TRACE</pre></div></div><div class=paragraph><p>Para que esto funcione, es posible que necesites establecer un sysctl (si no está activado de forma predeterminada):</p></div><div class="literalblock programlisting"><div class=content><pre>  debug.debugger_on_panic=1</pre></div></div><div class=paragraph><p>Ocurrirán kernel panics, por lo que se debe tener cuidado con la cache del sistema de archivos. En particular, tener habilitadas las softupdates puede significar que la última versión del archivo podría perderse si se produce un kernel panic antes de que se haya hecho commit al almacenamiento. Deshabilitar las softupdates produce un gran impacto en el rendimiento, y no garantiza la consistencia de los datos. Para eso es necesario montar el sistema de archivos con la opción "sync". Como solución de compromiso, se pueden acortar los tiempos de espera de la cache de softupdates. Hay tres sysctls que son útiles para esto (lo mejor es establecerlas en <span class=filename>/etc/sysctl.conf</span>):</p></div><div class="literalblock programlisting"><div class=content><pre>kern.filedelay=5
kern.dirdelay=4
kern.metadelay=3</pre></div></div><div class=paragraph><p>Los números representan segundos.</p></div><div class=paragraph><p>Para depurar los kernel panics, los volcados del kernel (core dumps) son necesarios. Dado que un kernel panic podría inutilizar los sistemas de archivos, este volcado de memoria se graba primero en una partición sin formato (raw). Por lo general, ésta es la partición swap. Esta partición debe ser al menos tan grande como la RAM física del ordenador. En el siguiente arranque, el volcado se copia en un archivo normal. Esto sucede después de que los sistemas de archivos se verifiquen y monten, y antes de habilitar la swap. Este proceso se controla con dos variables en <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>dumpdev=&#34;/dev/ad0s4b&#34;
dumpdir=&#34;/usr/core</pre></div></div><div class=paragraph><p>La variable <code>dumpdev</code> especifica la partición swap y <code>dumpdir</code> le indica al sistema dónde copiar el dore dump al reiniciar.</p></div><div class=paragraph><p>Escribir volcados del kernel es lento y lleva mucho tiempo, por lo que si tienes mucha memoria (>256M) y muchos kernel panics, puede ser frustrante sentarse y esperar mientras se hace (dos veces — primero escribirlo en el swap, luego reubicarlo al sistema de archivos). Es conveniente limitar la cantidad de RAM que utilizará el sistema a través de una variable en <span class=filename>/boot/loader.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>  hw.physmem=&#34;256M&#34;</pre></div></div><div class=paragraph><p>Si los kernel panics son frecuentes y los sistemas de archivos son grandes (o simplemente no confías en softupdates + fsck en segundo plano), es aconsejable desactivar fsck en segundo plano mediante la siguiente variable en <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>  background_fsck=&#34;NO&#34;</pre></div></div><div class=paragraph><p>De esta forma, los sistemas de archivos siempre serán verificados cuando sea necesario. Ten en cuenta que con fsck en segundo plano, podría producirse un nuevo kernel panic mientras comprueba los discos. Una vez más, la forma más segura es no tener muchos sistemas de archivos sino utilizar otro ordenador como servidor NFS.</p></div></div><div class=sect2><h3 id=prelim-starting>2.2. Empezando el proyecto<a class=anchor href=#prelim-starting></a></h3><div class=paragraph><p>Con el fin de crear una nueva clase GEOM, se debe crear un subdirectorio vacío bajo un directorio arbitrario que sea accesible por el usuario. No es necesario crear el directorio del módulo en <span class=filename>/usr/src</span>.</p></div></div><div class=sect2><h3 id=prelim-makefile>2.3. El Makefile<a class=anchor href=#prelim-makefile></a></h3><div class=paragraph><p>Es una buena práctica crear <span class=filename>Makefiles</span> para cada proyecto de programación que no sea trivial, lo que incluye obviamente módulos del kernel.</p></div><div class=paragraph><p>Crear el archivo <span class=filename>Makefile</span> es sencillo gracias a un extenso conjunto de rutinas de ayuda proporcionadas por el sistema. En resumen, aquí hay un ejemplo de cómo es un <span class=filename>Makefile</span> mínimo para un módulo del kernel:</p></div><div class="literalblock programlisting"><div class=content><pre>SRCS=g_journal.c
KMOD=geom_journal

.include &lt;bsd.kmod.mk&gt;</pre></div></div><div class=paragraph><p>Este <span class=filename>Makefile</span> (con nombres de archivo modificados) funcionará para cualquier módulo del kernel, y una clase GEOM puede residir en un solo módulo del kernel. Si se necesita más de un archivo, añadelo a la variable <code>SRCS</code>, separado con espacios en blanco de los otros nombres de archivos.</p></div></div></div></div><div class=sect1><h2 id=kernelprog>3. Programación del kernel de FreeBSD<a class=anchor href=#kernelprog></a></h2><div class=sectionbody><div class=sect2><h3 id=kernelprog-memalloc>3.1. Asignación de memoria<a class=anchor href=#kernelprog-memalloc></a></h3><div class=paragraph><p>Lee <a href="https://man.freebsd.org/cgi/man.cgi?query=malloc&amp;sektion=9&amp;format=html">malloc(9)</a>. La asignación básica de memoria sólo es un poco diferente de su equivalente en espacio de usuario. Lo más llamativo es que <code>malloc</code>() y <code>free</code>() aceptan parámetros adicionales como se describe en la página del manual.</p></div><div class=paragraph><p>Se tiene que declarar un "malloc type" en la sección de declaraciones de un fichero de código de este modo:</p></div><div class="literalblock programlisting"><div class=content><pre>  static MALLOC_DEFINE(M_GJOURNAL, &#34;gjournal data&#34;, &#34;GEOM_JOURNAL Data&#34;);</pre></div></div><div class=paragraph><p>Para usar esta macro se tienen que incluir los ficheros de cabecera <span class=filename>sys/param.h</span>, <span class=filename>sys/kernel.h</span> y <span class=filename>sys/malloc.h</span>.</p></div><div class=paragraph><p>Hay otro mecanismo para reservar memoria, el UMA (Universal Memory Allocator). Lee <a href="https://man.freebsd.org/cgi/man.cgi?query=uma&amp;sektion=9&amp;format=html">uma(9)</a> para obtener detalles, pero es un tipo especial de gestor que se utiliza principalmente para acelerar la reserva de listas compuestas de elementos del mismo tamaño (por ejemplo, arrays dinámicos de estructuras).</p></div></div><div class=sect2><h3 id=kernelprog-lists>3.2. Listas y colas<a class=anchor href=#kernelprog-lists></a></h3><div class=paragraph><p>Lee <a href="https://man.freebsd.org/cgi/man.cgi?query=queue&amp;sektion=3&amp;format=html">queue(3)</a>. Hay MUCHOS casos en los que se necesita mantener una lista de cosas. Afortunadamente esta estructura de datos se implementa (de muchas formas) mediante macros de C incluidas en el sistema. El tipo de lista más utilizado es TAILQ porque es el más flexible. También es el que requiere más memoria (sus elementos están doblemente enlazados) y también el más lento (aunque la variación de velocidad está en el orden de varias instrucciones de CPU, así que esto no se debería tomar en serio).</p></div><div class=paragraph><p>Si la velocidad de recuperación de los datos es importante, consulta <a href="https://man.freebsd.org/cgi/man.cgi?query=tree&amp;sektion=3&amp;format=html">tree(3)</a> y <a href="https://man.freebsd.org/cgi/man.cgi?query=hashinit&amp;sektion=9&amp;format=html">hashinit(9)</a>.</p></div></div><div class=sect2><h3 id=kernelprog-bios>3.3. BIOs<a class=anchor href=#kernelprog-bios></a></h3><div class=paragraph><p>La estructura <code>bio</code> se utiliza para todas las operaciones de Entrada/Salida que tengan que ver con GEOM. Básicamente contiene información acerca de qué dispositivo ('provider') debería satisfacer la petición, el tipo de petición, el desplazamiento, la longitud, el puntero al buffer, y un montón de flags y campos "específicos de usuario" que pueden ayudar a implementar varios hacks.</p></div><div class=paragraph><p>Lo importante aquí es que los <code>bio</code> se manejan de forma asíncrona. Esto quiere decir que en la mayor parte del código no hay un análogo a las llamadas <a href="https://man.freebsd.org/cgi/man.cgi?query=read&amp;sektion=2&amp;format=html">read(2)</a> y <a href="https://man.freebsd.org/cgi/man.cgi?query=write&amp;sektion=2&amp;format=html">write(2)</a> de espacio de usuario que no retornan hasta que la petición ha terminado. En su lugar se utiliza una función proporcionada por el desarrollador que es invocada como una notificación cuando la solicitud se ha completado (o ha terminado en error).</p></div><div class=paragraph><p>El modelo asíncrono de programación (también llamado orientado a eventos, o "event-driven") es algo más difícil que el modo imperativo que se usa mucho más en espacio de usuario (al menos lleva un tiempo acostumbrarse). En algunos casos se pueden usar las rutinas de soporte <code>g_write_data</code>() y <code>g_read_data</code>() pero <em>no siempre</em>. En concreto, no se pueden usar cuando se está bloqueando en un mutex; por ejemplo, el mutex para la topología de GEOM o el mutex interno que se adquiere en las funciones <code>.start</code>() y <code>.stop</code>().</p></div></div></div></div><div class=sect1><h2 id=geom>4. Programación GEOM<a class=anchor href=#geom></a></h2><div class=sectionbody><div class=sect2><h3 id=geom-ggate>4.1. Ggate<a class=anchor href=#geom-ggate></a></h3><div class=paragraph><p>Si no se necesita el máximo rendimiento, una forma mucho más sencilla de realizar una transformación de datos es implementarla en el espacio de usuario a través del servicio ggate (GEOM gate). Desafortunadamente, no hay una manera fácil de convertir o incluso compartir código entre las dos aproximaciones.</p></div></div><div class=sect2><h3 id=geom-class>4.2. Clase GEOM<a class=anchor href=#geom-class></a></h3><div class=paragraph><p>Las clases GEOM son transformaciones sobre los datos. Estas transformaciones se pueden combinar en forma de árbol. Las instancias de las clases GEOM se llaman <em>geoms</em>.</p></div><div class=paragraph><p>Cada clase GEOM tiene varios "métodos de clase" que son invocados cuando no se dispone de una instancia geom (o simplemente no están ligadas a una única instancia):</p></div><div class=ulist><ul><li><p><code>.init</code> se llama cuando GEOM se entera de una nueva clase GEOM (cuando se carga el módulo del kernel.)</p></li><li><p><code>.fini</code> se llama cuando GEOM abandona la clase (cuando se descarga el módulo)</p></li><li><p>A continuación se llama a <code>.taste</code>, una vez por cada proveedor que el sistema tenga disponible. Si corresponde, esta función generalmente creará e iniciará una instancia geom.</p></li><li><p><code>.destroy_geom</code> se llama cuando se debe desmantelar el geom</p></li><li><p><code>.ctlconf</code> se invoca cuando el usuario solicita la reconfiguración de un geom existente</p></li></ul></div><div class=paragraph><p>También se definen las funciones de eventos GEOM, que se copiarán en la instancia de geom.</p></div><div class=paragraph><p>El campo <code>.geom</code> en la estructura <code>g_class</code> es una lista (LIST) de los geoms instanciados a partir de la clase.</p></div><div class=paragraph><p>Estas funciones son llamadas desde el hilo del kernel g_event.</p></div></div><div class=sect2><h3 id=geom-softc>4.3. Softc<a class=anchor href=#geom-softc></a></h3><div class=paragraph><p>El nombre "softc" es un término heredado para"driver private data" (datos privados del controlador). El nombre probablemente proviene del término arcaico "software control block" (bloque de control software). En GEOM, es una estructura (para ser más precisos: un puntero a una estructura) que se puede adjuntar a una instancia de geom para mantener cualquier información que sea privada para dicha instancia. La mayoría de las clases de GEOM tienen los siguientes elementos:</p></div><div class=ulist><ul><li><p><code>struct g_provider *provider</code> : El "provider" que instancia este geom</p></li><li><p><code>uint16_t n_disks</code> : Número de consumidores que consume este geom</p></li><li><p><code>struct g_consumer **disks</code> : Array de <code>struct g_consumer*</code>. (No es posible utilizar un sólo nivel de indirección porque los struct g_consumer* los crea GEOM en nuestro nombre).</p></li></ul></div><div class=paragraph><p>La estructura <code>softc</code> contiene el estado completo de la instancia geom. Cada instancia geom tiene su propio softc.</p></div></div><div class=sect2><h3 id=geom-metadata>4.4. Metadatos<a class=anchor href=#geom-metadata></a></h3><div class=paragraph><p>El formato de los metadatos es más o menos dependiente de la clase, pero DEBE comenzar por:</p></div><div class=ulist><ul><li><p>Un buffer de 16 bytes para la firma terminada en null (normalmente el nombre de la clase)</p></li><li><p>ID de la versión del tipo uint32</p></li></ul></div><div class=paragraph><p>Se supone que las clases de geom saben cómo manejar los metadatos con ID de versión menores que los suyos.</p></div><div class=paragraph><p>Los metadatos se encuentran en el último sector del proveedor (y, por lo tanto, deben encajar en él).</p></div><div class=paragraph><p>(Todo depende de la implementación, pero todo el código existente funciona así, y es compatible con las bibliotecas.)</p></div></div><div class=sect2><h3 id=geom-creating>4.5. Etiquetar/crear un GEOM<a class=anchor href=#geom-creating></a></h3><div class=paragraph><p>La secuencia de eventos es:</p></div><div class=ulist><ul><li><p>El usuario invoca la utilidad <a href="https://man.freebsd.org/cgi/man.cgi?query=geom&amp;sektion=8&amp;format=html">geom(8)</a> (o alguno de sus amigos que están enlazados)</p></li><li><p>la utilidad averigua qué clase geom se supone que tiene que manejar y busca la librería <span class=filename>geom_CLASSNAME.so</span> (que está normalmente en <span class=filename>/lib/geom</span>).</p></li><li><p>usa <a href="https://man.freebsd.org/cgi/man.cgi?query=dlopen&amp;sektion=3&amp;format=html">dlopen(3)</a> para cargar la librería y extrae las definiciones de los parámetros de línea de comandos y de las funciones de apoyo.</p></li></ul></div><div class=paragraph><p>En el caso de crear/etiquetar un nuevo geom, esto es lo que sucede:</p></div><div class=ulist><ul><li><p><a href="https://man.freebsd.org/cgi/man.cgi?query=geom&amp;sektion=8&amp;format=html">geom(8)</a> busca el comando (normalmente <code>label</code>) en los argumentos de línea de comando y llama a la función de apoyo.</p></li><li><p>La función auxiliar comprueba los parámetros y recopila los metadatos, que procede a escribir a todos los proveedores interesados.</p></li><li><p>Esto "echa a perder" los geoms existentes (si los hubiera) e inicializa una nueva ronda de "pruebas" de los proveedores. La clase geom reconoce los metadatos y levanta el geom.</p></li></ul></div><div class=paragraph><p>(La secuencia de eventos anterior depende de la implementación, pero todo el código existente funciona así, y es compatible con las bibliotecas.)</p></div></div><div class=sect2><h3 id=geom-command>4.6. Estructura del comando GEOM<a class=anchor href=#geom-command></a></h3><div class=paragraph><p>La librería de apoyo <span class=filename>geom_CLASSNAME.so</span> exporta la estructura <code>class_commands</code> que es un array de elementos de tipo <code>struct g_command</code>. Los comandos tienen un formato uniforme que se parece a:</p></div><div class="literalblock programlisting"><div class=content><pre>  verb [-options] geomname [other]</pre></div></div><div class=paragraph><p>Los verbos comunes son:</p></div><div class=ulist><ul><li><p>label — para escribir metadatos en los dispositivos para que puedan ser reconocidos en la prueba y creados en geoms</p></li><li><p>destroy — para destruir los metadatos, de forma que se destruyen los geoms</p></li></ul></div><div class=paragraph><p>Las opciones comunes son:</p></div><div class=ulist><ul><li><p><code>-v</code> : sé verboso</p></li><li><p><code>-f</code> : forzar</p></li></ul></div><div class=paragraph><p>Muchas acciones, como etiquetar y destruir los metadatos, se pueden hacer en espacio de usuario. Para esto, <code>struct g_command</code> proporciona el campo <code>gc_func</code> al que se puede asignar una función (en el mismo <span class=filename>.so</span>) que será llamada para procesar un verbo. Si <code>gc_func</code> es NULL, el comando se pasará al módulo del kernel, a la función <code>.ctlreq</code> de la clase geom.</p></div></div><div class=sect2><h3 id=geom-geoms>4.7. Geoms<a class=anchor href=#geom-geoms></a></h3><div class=paragraph><p>Los geoms son instancias de clases GEOM. Tienen datos internos (una estructura softc) y algunas funciones con las que responden a eventos externos.</p></div><div class=paragraph><p>Las funciones del evento son:</p></div><div class=ulist><ul><li><p><code>.access</code> : calcula permisos (read/write/exclusive)</p></li><li><p><code>.dumpconf</code> : devuelve información sobre el geom en formato XML</p></li><li><p><code>.orphan</code> : llamada cuando algún proveedor subyacente se desconecta</p></li><li><p><code>.spoiled</code> : llamada cuando se escribe en algún proveedor subyacente</p></li><li><p><code>.start</code> : maneja E/S (I/O)</p></li></ul></div><div class=paragraph><p>Estas funciones se llaman desde el hilo <code>g_down</code> del kernel y no puede haber inactividad en este contexto, (consulta la definición de inactividad en otra parte) lo que limita un poco lo que se puede hacer, pero obliga a que el manejo sea rápido.</p></div><div class=paragraph><p>De estas funciones, la más importante para realizar un trabajo útil real es la función <code>.start</code>() , que se llama cuando una solicitud BIO llega a un proveedor administrado por una instancia de la clase geom.</p></div></div><div class=sect2><h3 id=geom-threads>4.8. Hilos de GEOM<a class=anchor href=#geom-threads></a></h3><div class=paragraph><p>Hay tres hilos del kernel creados y ejecutados por el framework GEOM:</p></div><div class=ulist><ul><li><p><code>g_down</code> : Maneja las peticiones que vienen de entidades de nivel superior (como una petición de espacio de usuario) hacia los dispositivos físicos</p></li><li><p><code>g_up</code> : Maneja respuestas de los controladores de dispositivos a las peticiones hechas por entidades de nivel superior</p></li><li><p><code>g_event</code> : Maneja los demás casos: creación de instancias geom, contadores de acceso, eventos "spoil", etc.</p></li></ul></div><div class=paragraph><p>Cuando un proceso de usuario realiza una petición de tipo "lee el dato X en el offset Y de un fichero", esto es lo que sucede:</p></div><div class=ulist><ul><li><p>El sistema de archivos convierte la solicitud en una instancia de struct bio y lo transmite al subsistema GEOM. Sabe qué instancia geom debería encargarse porque los sistemas de archivos se alojan directamente en una instancia geom.</p></li><li><p>La solicitud termina como una llamada a la función <code>.start</code>() realizada en el hilo g_down y llega a la instancia de geom de nivel superior.</p></li><li><p>Esta instancia de nivel superior (por ejemplo el particionador) determina que la petición se debería dirigir a una instancia de nivel inferior (por ejemplo el controlador del disco). Hace una copia de la petición bio (¡las peticiones bio <em>SIEMPRE</em> se tienen que copiar entre instancias, con <code>g_clone_bio</code>()!), modifica los campos para el offset de los datos y el proveedor objetivo y ejecuta la copia con <code>g_io_request</code>()</p></li><li><p>El controlador de disco también obtiene la petición bio al llamar a la función <code>.start</code>() del hilo <code>g_down</code>. Habla con el hardware, obtiene los datos y llama a <code>g_io_deliver</code>() en el bio.</p></li><li><p>Ahora, la notificación de bio completada "sube" en el hilo <code>g_up</code>. Primero se llama a <code>.done</code>() del particionador en el hilo <code>g_up</code>, usa la información almacenada en el bio para liberar la estructura <code>bio</code> clonada (con <code>g_destroy_bio</code>()) y llama a <code>g_io_deliver</code>() en la petición original.</p></li><li><p>El sistema de archivos obtiene los datos y los transfiere al espacio de usuario.</p></li></ul></div><div class=paragraph><p>Consulta la página de manual <a href="https://man.freebsd.org/cgi/man.cgi?query=g_bio&amp;sektion=9&amp;format=html">g_bio(9)</a> para obtener información sobre cómo se pasan los datos de un lado para otro en la estructura <code>bio</code> (en particular date cuenta cómo se manejan los campos <code>bio_parent</code> y <code>bio_children</code>).</p></div><div class=paragraph><p>Una característica importante es que: <em>NO PUEDE HABER HILOS G_UP Y G_DOWN QUE SE VAYAN A DORMIR</em>. Esto significa que en esos hilos no se puede hacer ninguna de las siguientes cosas (la lista por supuesto no está completa, es sólo informativa):</p></div><div class=ulist><ul><li><p>Llamadas a <code>msleep</code>() y <code>tsleep</code>(), evidentemente.</p></li><li><p>Llamadas a <code>g_write_data</code>() y <code>g_read_data</code>(), porque estas duermen entre el paso de datos hacia los consumidores y la vuelta.</p></li><li><p>Esperar por la E/S.</p></li><li><p>Llamadas a <a href="https://man.freebsd.org/cgi/man.cgi?query=malloc&amp;sektion=9&amp;format=html">malloc(9)</a> y <code>uma_zalloc</code>() con el flag <code>M_WAITOK</code> establecido</p></li><li><p>sx y otros sleepable locks</p></li></ul></div><div class=paragraph><p>Esta restricción está aquí para impedir que el código GEOM obstruya la ruta de las solicitudes de E/S, ya que el dormir no tiene limite de tiempo y puede no haber garantías sobre cuánto tiempo tardará (también hay algunas otras razones más técnicas). También significa que no hay mucho que se pueda hacer en estos hilos; por ejemplo, prácticamente cualquier cosa compleja requiere asignación de memoria. Afortunadamente, hay una salida: crear hilos adicionales en el kernel.</p></div></div><div class=sect2><h3 id=geom-kernelthreads>4.9. Hilos del kernel para usar en el código GEOM<a class=anchor href=#geom-kernelthreads></a></h3><div class=paragraph><p>Los hilos del kernel se crean con la función <a href="https://man.freebsd.org/cgi/man.cgi?query=kthread_create&amp;sektion=9&amp;format=html">kthread_create(9)</a> y se comportan de una forma similar a los hilos en espacio de usuario, sólo que no pueden volver al llamante para indicarles que han terminado sino que tienen que invocar <a href="https://man.freebsd.org/cgi/man.cgi?query=kthread_exit&amp;sektion=9&amp;format=html">kthread_exit(9)</a>.</p></div><div class=paragraph><p>En el código GEOM, el uso habitual de los hilos es para descargar el procesamiento de peticiones del hilo <code>g_down</code>(la función <code>.start</code>()). Estos hilos parecen "manejadores de eventos": tienen vinculada una lista de eventos asociados a ellos (en los cuales los eventos pueden publicarse mediante varias funciones en varios hilos, por lo que deben estar protegidos por un mutex), toma los eventos de la lista, uno por uno, y los procesa en una gran instrucción <code>switch</code>().</p></div><div class=paragraph><p>La principal ventaja de utilizar un hilo para manejar las solicitudes de E/S es que pueden dormir (sleep) cuando sea necesario. Ahora, esto suena bien, pero se debe pensar cuidadosamente. Dormir (sleeping) es bueno y muy conveniente, pero puede ser muy efectivo destruyendo el rendimiento de la transformación de geom. Las clases extremadamente sensibles al rendimiento probablemente deberían hacer todo el trabajo en la llamada a la función <code>.start</code>(), teniendo mucho cuidado de manejar los errores de falta de memoria y similares.</p></div><div class=paragraph><p>El otro beneficio de tener un hilo manejador de eventos como este es serializar en un sólo hilo todas las peticiones y respuestas que vienen de los distintos hilos de geom. Esto también es muy cómodo pero puede ser lento. En la mayoría de los casos, el manejo de las peticiones de <code>.done</code>() se puede dejar en manos del hilo <code>g_up</code>.</p></div><div class=paragraph><p>Los mutex en el kernel de FreeBSD (consulta <a href="https://man.freebsd.org/cgi/man.cgi?query=mutex&amp;sektion=9&amp;format=html">mutex(9)</a>) tienen una característica distintiva respecto de sus primos en espacio de usuario - el código no puede dormir mientras se tiene un mutex cogido. Si el código necesita dormir a menudo, los locks <a href="https://man.freebsd.org/cgi/man.cgi?query=sx&amp;sektion=9&amp;format=html">sx(9)</a> podrían ser más apropiados. Por otro lado, si haces casi todo en un solo hilo, podrías no necesitar mutex en absoluto.</p></div></div></div></div><hr><div class=last-modified><p><strong>Last modified on</strong>: 24 de agosto de 2022 by <a href="https://cgit.freebsd.org/doc/commit/?id=62330eeb76" target=_blank>Fernando Apesteguía</a></p></div></div><aside class=toc><div class=toc-content><h3>Tabla de contenidos</h3><nav id=TableOfContents><ul><li><a href=#intro>1. Introducción</a></li><li><a href=#prelim>2. Preliminares</a></li><li><a href=#kernelprog>3. Programación del kernel de FreeBSD</a></li><li><a href=#geom>4. Programación GEOM</a></li></ul></nav><hr><div class=resources><h3>Recursos</h3><ul class=contents><li><i class="fa fa-file-pdf-o" aria-hidden=true title="Descargar PDF"></i><a href=https://download.freebsd.org/doc/es/articles/geom-class/geom-class_es.pdf>Descargar PDF</a></li><li><i class="fa fa-pencil-square-o" aria-hidden=true title="Editar esta página"></i><a href=https://github.com/freebsd/freebsd-doc/blob/main/documentation/content/es/_index target=_blank>Editar esta página</a></li></ul></div></div></aside></main><footer><div class=footer-container><section class=logo-column><img src=http://172.16.201.134:1313/images/FreeBSD-colors.svg width=160 height=50 alt="FreeBSD logo"><div class=options-container><div class=language-container><a id=languages href=http://172.16.201.134:1313/es/languages><img src=http://172.16.201.134:1313/images/language.png class=language-image alt="Elegir idioma">
<span>Spanish</span></a></div><div class=theme-container><select id=theme-chooser><option value=theme-system>System</option><option value=theme-light>Claro</option><option value=theme-dark>Oscuro</option><option value=theme-high-contrast>Alto contraste</option></select></div></div></section><section class=about-column><h3 class=column-title>About</h3><ul class=column-elements-container><li><a href=https://www.freebsd.org/about/ target=_blank class=column-element>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/ target=_blank class=column-element>FreeBSD Foundation</a></li><li><a href=https://www.freebsd.org/where/ target=_blank class=column-element>Get FreeBSD</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct target=_blank class=column-element>Code of Conduct</a></li><li><a href=https://www.freebsd.org/security/ target=_blank class=column-element>Security Advisories</a></li></ul></section><section class=documentation-column><h3 class=column-title>Documentation</h3><ul class=column-elements-container><li><a href=/es class=column-element>Documentation portal</a></li><li><a href=https://man.FreeBSD.org target=_blank class=column-element>Manual pages</a></li><li><a href=https://papers.FreeBSD.org target=_blank class=column-element>Presentations and papers</a></li><li><a href=https://docs-archive.freebsd.org/doc/ target=_blank class=column-element>Previous versions</a></li><li><a href=https://docs-archive.freebsd.org/44doc/ target=_blank class=column-element>4.4BSD Documents</a></li><li><a href=https://wiki.freebsd.org/ target=_blank class=column-element>Wiki</a></li></ul></section><section class=community-column><h3 class=column-title>Community</h3><ul class=column-elements-container><li><a href=http://172.16.201.134:1313/es/articles/contributing class=column-element>Get involved</a></li><li><a href=https://forums.freebsd.org/ target=_blank class=column-element>Community forum</a></li><li><a href=https://lists.freebsd.org/ target=_blank class=column-element>Mailing lists</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank class=column-element>IRC Channels</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank class=column-element>Bug Tracker</a></li></ul></section><section class=legal-column><h3 class=column-title>Legal</h3><ul class=column-elements-container><li><a href=https://freebsdfoundation.org/donate/ target=_blank class=column-element>Donations</a></li><li><a href=https://www.freebsd.org/copyright/freebsd-license/ target=_blank class=column-element>Licensing</a></li><li><a href=https://www.freebsd.org/privacy/ target=_blank class=column-element>Privacy Policy</a></li><li><a href=https://www.freebsd.org/copyright/ target=_blank class=column-element>Legal notices</a></li></ul></section><section class=copyright-column><p>&copy; 1994-2024 The FreeBSD Project. All rights reserved</p><span>Made with <span class=heart>♥</span> by the FreeBSD Community</span></section></div></footer></body></html>