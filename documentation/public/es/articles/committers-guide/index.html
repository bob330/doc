<!doctype html><html class=theme-light lang=es><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Información de introducción para los committers de FreeBSD"><meta name=keywords content="FreeBSD Committer's Guide,Guide,Community"><meta name=copyright content="1995-2024 The FreeBSD Foundation"><link rel=canonical href=https://docs.freebsd.org/es/articles/committers-guide/><title>Guía para los Committers | Portal de documentación de FreeBSD</title>
<meta name=theme-color content="#790000"><meta name=color-scheme content="system light dark high-contrast"><link rel="shortcut icon" href=https://docs.freebsd.org/favicon.ico><link rel=stylesheet href=https://docs.freebsd.org/styles/main.min.css><link rel=stylesheet href=https://docs.freebsd.org/css/font-awesome-min.css><script defer src=/js/theme-chooser.min.js></script><script defer src=/js/copy-clipboard.min.js></script><script defer src=/js/search.min.js></script><meta name=twitter:card content="summary"><meta name=twitter:domain content="docs.FreeBSD.org"><meta name=twitter:site content="@freebsd"><meta name=twitter:url content="https://twitter.com/freebsd"><meta property="og:title" content="Guía para los Committers"><meta property="og:description" content="Información de introducción para los committers de FreeBSD"><meta property="og:type" content="website"><meta property="og:image" content="https://docs.freebsd.org/favicon.ico"><meta property="og:image:alt" content="FreeBSD Logo"><meta property="og:locale" content="es"><meta property="og:url" content="https://docs.freebsd.org/es/articles/committers-guide/"><meta property="og:site_name" content="Portal de documentación de FreeBSD"><script type=application/ld+json>{"@context":"http://schema.org","@type":"Article","url":"https:\/\/docs.freebsd.org\/es\/articles\/committers-guide\/","name":"Portal de documentación de FreeBSD","headline":"Portal de documentación de FreeBSD","description":"FreeBSD Documentation Portal"}</script></head><body><header><div class=header-container><div class=logo-menu-bars-container><a href=https://www.FreeBSD.org class=logo><img src=https://docs.freebsd.org/images/FreeBSD-monochromatic.svg width=160 height=50 alt="FreeBSD logo">
</a><label class=menu-bars for=menu-bars><i class="fa fa-bars" aria-hidden=true></i></label></div><input id=menu-bars type=checkbox><nav><ul class=menu><li class=menu-item><input id=about type=checkbox>
<a href=# aria-label="Navigate to About section"><label class=menu-item-description for=about>About
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/about/ target=_blank>About</a></li><li><a href=https://www.freebsd.org/about/ target=_blank>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/about-us/about-the-foundation/ target=_blank>FreeBSD Foundation</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct/ target=_blank>Code of Conduct</a></li></ul></li><li class=menu-item><input id=download type=checkbox>
<a href=# aria-label="Navigate to get FreeBSD section"><label class=menu-item-description for=download>Get FreeBSD
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/where/ target=_blank>Get FreeBSD</a></li><li><a href=https://www.freebsd.org/releases/ target=_blank>Release Information</a></li><li><a href=https://www.freebsd.org/releng/ target=_blank>Release Engineering</a></li><li><a href=https://www.freebsd.org/security/ target=_blank>Security Advisories</a></li></ul></li><li class=menu-item><input id=documentation type=checkbox>
<a href=# aria-label="Navigate to get Documentation section"><label class=menu-item-description for=documentation>Documentation
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=/es>Documentation portal</a></li><li><a href=https://docs.freebsd.org/es/books/handbook>FreeBSD Handbook</a></li><li><a href=https://docs.freebsd.org/es/books/porters-handbook>Porter's Handbook</a></li><li><a href=https://docs.FreeBSD.org/en/books/fdp-primer>Documentation Project Handbook</a></li><li><a href=https://man.FreeBSD.org target=_blank>Manual pages</a></li><li><a href=https://papers.FreeBSD.org target=_blank>Presentations and papers</a></li><li><a href=https://wiki.FreeBSD.org target=_blank>Wiki</a></li><li><a href=https://docs.freebsd.org/es/books>Books</a></li><li><a href=https://docs.freebsd.org/es/articles>Articles</a></li></ul></li><li class=menu-item><input id=community type=checkbox>
<a href=# aria-label="Navigate to get Community section"><label class=menu-item-description for=community>Community
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/community/>Community</a></li><li><a href=https://docs.freebsd.org/es/articles/contributing>Get involved</a></li><li><a href=https://forums.freebsd.org/ target=_blank>Forum</a></li><li><a href=https://lists.freebsd.org/ target=_blank>Mailing lists</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank>IRC Channels</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank>Bug Tracker</a></li><li><a href=https://www.freebsd.org/support/ target=_blank>Support</a></li></ul></li></ul></nav><div class=search-donate-container><form class=search method=get id=search-header-form action=https://docs.freebsd.org/search name=search-header-form><input type=hidden name=DB value=es>
<input id=words name=P type=text size=20 maxlength=255>
<button>
<i class="fa fa-search" aria-hidden=true></i></button></form><div class=donate><a href=https://freebsdfoundation.org/donate/ target=_blank><span class=heart>♥</span>
Donate</a></div></div></div></header><main class=main-wrapper-article><div class=article><h1 class=title>Guía para los Committers</h1><div class="admonitionblock note"><p><i class="fa fa-exclamation-circle" aria-hidden=true></i>
This translation may be out of date. To help with the translations please access the <a href=https://translate-dev.freebsd.org/ target=_blank>FreeBSD translations instance</a>.</p></div><div class=copyright>Copyright © 1999-2022 The FreeBSD Documentation Project</div><div class=legalnotice><a id=trademarks></a><details><summary>Marcas registradas</summary><p>FreeBSD es una marca registrada de la Fundación FreeBSD</p><p>Coverity es una marca registrada; Coverity Extend, Coverity Prevent y Coverity Prevent SQS son marcas registradas de Coverity, Inc.</p><p>IBM, AIX, OS/2, PowerPC, PS/2, S/390, y ThinkPad son marcas registradas de International Business Machines Corporation en los Estados Unidos de América, otros países, o ambos.</p><p>Git and the Git logo are either registered trademarks or trademarks of Software Freedom Conservancy, Inc., corporate home of the Git Project, in the United States and/or other countries.</p><p>GitHub is a trademark of GitHub Inc., registered in the United States and other countries.</p><p>GITLAB is a trademark of GitLab Inc. in the United States and other countries and regions.</p><p>Intel, Celeron, Centrino, Core, EtherExpress, i386, i486, Itanium, Pentium, y Xeon son marcas registradas de ntel Corporation o sus subsidiarias en los Estados Unidos de América y otros países.</p><p>Muchos de los nombres usados por los fabricantes y vendedores para diferenciar sus productos son designados como marcas comerciales. Allí donde estos nombres aparezcan en este documento y el Proyecto FreeBSD fuera consciente de la alegación de marca comercial, los nombres tienen a continuación el símbolo “™” o “®”.</p></details></div><div class=toc-mobile><h3>Tabla de contenidos</h3><nav id=TableOfContents><ul><li><a href=#admin>1. Detalles administrativos</a></li><li><a href=#pgpkeys>2. Claves OpenPGP de FreeBSD</a></li><li><a href=#kerberos-ldap>3. Kerberos y contraseña web LDAP para el clúster de FreeBSD</a></li><li><a href=#committer.types>4. Tipos de Commit Bits</a></li><li><a href=#git-primer>5. Introducción a Git</a></li><li><a href=#vcs-history>6. Histórico del Control de Versiones</a></li><li><a href=#conventions>7. Configuración, Convenciones y Tradiciones</a></li><li><a href=#pre-commit-review>8. Revisión previa al commit</a></li><li><a href=#commit-log-message>9. Mensajes de Commit</a></li><li><a href=#pref-license>10. Licencia preferida para los nuevos archivos</a></li><li><a href=#tracking.license.grants>11. Seguimiento de las licencias concedidas al proyecto FreeBSD</a></li><li><a href=#spdx.tags>12. Etiquetas SPDX en el árbol</a></li><li><a href=#developer.relations>13. Relaciones con los desarrolladores</a></li><li><a href=#if-in-doubt>14. Si tienes dudas …​</a></li><li><a href=#bugzilla>15. Bugzilla</a></li><li><a href=#phabricator>16. Phabricator</a></li><li><a href=#people>17. Quien es Quien</a></li><li><a href=#ssh.guide>18. Guía de inicio rápido de SSH</a></li><li><a href=#coverity>19. Disponibilidad de Coverity® para los Committers de FreeBSD</a></li><li><a href=#rules>20. La gran lista de reglas de los Committers de FreeBSD</a></li><li><a href=#archs>21. Soporte para múltiples arquitecturas</a></li><li><a href=#ports>22. Preguntas frecuentes sobre ports específicos</a></li><li><a href=#non-committers>23. Problemas Específicos para Desarrolladores que No Son Committers</a></li><li><a href=#google-analytics>24. Información sobre Google Analytics</a></li><li><a href=#misc>25. Preguntas misceláneas</a></li><li><a href=#benefits>26. Beneficios y Ventajas para los committers de FreeBSD</a></li></ul></nav></div><div id=preamble><div class=sectionbody><div class="paragraph abstract-title"><p>Resumen</p></div><div class=paragraph><p>Este documento proporciona información para la comunidad de committers de FreeBSD. Todos los committers nuevos deben leer este documento antes de empezar, y se recomienda encarecidamente a los committers actuales que lo revisen de vez en cuando.</p></div><div class=paragraph><p>Casi todos los desarrolladores de FreeBSD tienen derecho de acceso a uno o más repositorios. Sin embargo, algunos desarrolladores no lo tienen, y cierta información aquí expuesta también les afecta. (Por ejemplo, algunas personas sólo tienen derecho a trabajar con la base de datos de reporte de problemas.) Por favor lea <a href=#non-committers>Problemas Específicos para Desarrolladores que No Son Committers</a> para más información.</p></div><div class=paragraph><p>Este documento también puede ser de interés para los miembros de la comunidad de FreeBSD que quieran saber más sobre el funcionamiento del proyecto.</p></div><hr></div></div><div class=sect1><h2 id=admin>1. Detalles administrativos<a class=anchor href=#admin></a></h2><div class=sectionbody><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><em>Métodos de inicio de sesión</em></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a href="https://man.freebsd.org/cgi/man.cgi?query=ssh&amp;sektion=1&amp;format=html">ssh(1)</a>, sólo protocolo 2</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><em>Host Shell Principal</em></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>freefall.FreeBSD.org</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><em>Máquinas de Referencia</em></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>ref*.FreeBSD.org</code>, <code>universe*.freeBSD.org</code> (consulta también <a href=https://www.FreeBSD.org/internal/machines/>Máquinas del Proyecto FreeBSD</a>)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><em>SMTP Host</em></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>smtp.FreeBSD.org:587</code> (consulta también <a href=#smtp-setup>Configuración de acceso SMTP</a>).</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code><em>src/</em></code> Repositorio Git</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>ssh://git@gitrepo.FreeBSD.org/src.git</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code><em>doc/</em></code> Repositorio Git</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>ssh://git@gitrepo.FreeBSD.org/doc.git</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code><em>ports/</em></code> Repositorio Git</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>ssh://git@gitrepo.FreeBSD.org/ports.git</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><em>Listas de Correo Internas</em></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>developers (técnicamente llamada all-developers) doc-developers, doc-committers, ports-developers, ports-committers, src-developers, src-committers. (Cada repositorio del proyecto tiene su propia lista de correo terminada en -developers y -committers. Se pueden encontrar archivos para estas listas en los ficheros <span class=filename>/local/mail/repository-name-developers-archive</span> y <span class=filename>/local/mail/repository-name-committers-archive</span> en <code>freefall.FreeBSD.org</code>.)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><em>Informes mensuales del Core Team</em></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/home/core/public/reports</span> en el clúster <code>FreeBSD.org</code>.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><em>Informes mensuales del Ports Management Team</em></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/home/portmgr/public/monthly-reports</span> en el clúster <code>FreeBSD.org</code>.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><em>Notablemente Ramas de Git de <code>src/</code>:</em></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>stable/n</code> (<code>n</code>-STABLE), <code>main</code> (-CURRENT)</p></td></tr></tbody></table><div class=paragraph><p>Se requiere <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh&amp;sektion=1&amp;format=html">ssh(1)</a> para conectarse a los servidores del proyecto. Para más información, lea <a href=#ssh.guide>Guía de inicio rápido de SSH</a>.</p></div><div class=paragraph><p>Enlaces de interés:</p></div><div class=ulist><ul><li><p><a href=https://www.FreeBSD.org/internal/>Páginas Internas del Proyecto FreeBSD</a></p></li><li><p><a href=https://www.FreeBSD.org/internal/machines/>Servidores del Proyecto FreeBSD</a></p></li><li><p><a href=https://www.FreeBSD.org/administration/>Grupos Administrativos del Proyecto FreeBSD</a></p></li></ul></div></div></div><div class=sect1><h2 id=pgpkeys>2. Claves OpenPGP de FreeBSD<a class=anchor href=#pgpkeys></a></h2><div class=sectionbody><div class=paragraph><p>Claves criptográficas que siguen al estándar OpenPGP (<em>Pretty Good Privacy</em>) son utilizadas por el Proyecto FreeBSD para autentificar a los colaboradores. Mensajes que contengan información importante como claves SSH públicas pueden ser firmadas con una clave OpenPGP para demostrar que provienen realmente del colaborador. Véase <a href=https://nostarch.com/releases/pgp_release.pdf>PGP & GPG: Email for the Practical Paranoid by Michael Lucas</a> y <a href=http://en.wikipedia.org/wiki/Pretty_Good_Privacy class=bare>http://en.wikipedia.org/wiki/Pretty_Good_Privacy</a> para más información.</p></div><div class=sect2><h3 id=pgpkeys-creating>2.1. Creando una clave<a class=anchor href=#pgpkeys-creating></a></h3><div class=paragraph><p>Se pueden utilizar claves ya existentes, pero primero deberían ser comprobadas primero con <span class=filename>documentation/tools/checkkey.sh</span>. En este caso, comprueba que la clave tiene un identificador de usuario de FreeBSD.</p></div><div class=paragraph><p>Para aquellos que todavía no tengan una clave OpenPGP, o necesiten una nueva para reunir los requerimientos de seguridad de FreeBSD, se mostrará a continuación como generarla.</p></div><div id=pgpkeys-create-steps class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Instala <span class=filename>security/gnupg</span>. Inserta las siguientes líneas en <span class=filename>~/.gnupg/gpg.conf</span> para establecer valores aceptables por defecto:</p><div class="literalblock programlisting"><div class=content><pre>fixed-list-mode
keyid-format 0xlong
personal-digest-preferences SHA512 SHA384 SHA256 SHA224
default-preference-list SHA512 SHA384 SHA256 SHA224 AES256 AES192 AES CAST5 BZIP2 ZLIB ZIP Uncompressed
verify-options show-uid-validity
list-options show-uid-validity
sig-notation issuer-fpr@notations.openpgp.fifthhorseman.net=%g
cert-digest-algo SHA512</pre></div></div></li><li><p>Genera una clave:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% gpg <span class=nt>--full-gen-key</span>
gpg <span class=o>(</span>GnuPG<span class=o>)</span> 2.1.8<span class=p>;</span> Copyright <span class=o>(</span>C<span class=o>)</span> 2015 Free Software Foundation, Inc.
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.

Warning: using insecure memory!
Please <span class=k>select </span>what kind of key you want:
   <span class=o>(</span>1<span class=o>)</span> RSA and RSA <span class=o>(</span>default<span class=o>)</span>
   <span class=o>(</span>2<span class=o>)</span> DSA and Elgamal
   <span class=o>(</span>3<span class=o>)</span> DSA <span class=o>(</span>sign only<span class=o>)</span>
   <span class=o>(</span>4<span class=o>)</span> RSA <span class=o>(</span>sign only<span class=o>)</span>
Your selection? 1
RSA keys may be between 1024 and 4096 bits long.
What keysize <span class=k>do </span>you want? <span class=o>(</span>2048<span class=o>)</span> 2048 <i class=conum data-value=1></i><b>(1)</b>
Requested keysize is 2048 bits
Please specify how long the key should be valid.
	 0 <span class=o>=</span> key does not expire
      &lt;n&gt;  <span class=o>=</span> key expires <span class=k>in </span>n days
      &lt;n&gt;w <span class=o>=</span> key expires <span class=k>in </span>n weeks
      &lt;n&gt;m <span class=o>=</span> key expires <span class=k>in </span>n months
      &lt;n&gt;y <span class=o>=</span> key expires <span class=k>in </span>n years
Key is valid <span class=k>for</span>? <span class=o>(</span>0<span class=o>)</span> 3y <i class=conum data-value=2></i><b>(2)</b>
Key expires at Wed Nov  4 17:20:20 2015 MST
Is this correct? <span class=o>(</span>y/N<span class=o>)</span> y
GnuPG needs to construct a user ID to identify your key.

Real name: Chucky Daemon <i class=conum data-value=3></i><b>(3)</b>
Email address: notreal@example.com
Comment:
You selected this USER-ID:
<span class=s2>&#34;Chucky Daemon &lt;notreal@example.com&gt;&#34;</span>

Change <span class=o>(</span>N<span class=o>)</span>ame, <span class=o>(</span>C<span class=o>)</span>omment, <span class=o>(</span>E<span class=o>)</span>mail or <span class=o>(</span>O<span class=o>)</span>kay/<span class=o>(</span>Q<span class=o>)</span>uit? o
You need a Passphrase to protect your secret key.</code></pre></div></div></li></ol></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>Claves de 2048 bits con una expiración de tres años proporcionan una protección adecuada actualmente (202-10).</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td>Tres años de vida útil para una clave hacen que sea lo suficientemente corta como para hacer que quede obsoleta por el avance de la potencia de los ordenadores, pero lo suficientemente larga como para reducir los problemas de administración de claves.</td></tr><tr><td><i class=conum data-value=3></i><b>3</b></td><td>Utiliza tu nombre real aquí, preferiblemente coincidente con el nombre de tu documento de identificación oficial para ayudar a otros a verificar tu identidad. En la sección <code>Comment</code> se puede introducir texto que ayude a otros a identificarte.<div class=paragraph><p>Después de introducir la dirección de correo electrónico, se solicita una contraseña. Los métodos para crear una contraseña segura son bastante polémicos. En lugar de sugerir una única forma, aquí hay algunos enlaces a sitios que describen varios métodos: <a href=https://world.std.com/~reinhold/diceware.html class=bare>https://world.std.com/~reinhold/diceware.html</a>, <a href=https://www.iusmentis.com/security/passphrasefaq/ class=bare>https://www.iusmentis.com/security/passphrasefaq/</a>, <a href=https://xkcd.com/936/ class=bare>https://xkcd.com/936/</a>, <a href=https://en.wikipedia.org/wiki/Passphrase class=bare>https://en.wikipedia.org/wiki/Passphrase</a>.</p></div></td></tr></tbody></table></div></div></div><div class=paragraph><p>Protege la clave privada y la contraseña. Si la clave privada o la contraseña fueran comprometidas o reveladas, notifícalo de forma inmediata a <a href=mailto:accounts@FreeBSD.org>accounts@FreeBSD.org</a> y revoca la clave.</p></div><div class=paragraph><p>Los pasos para enviar la nueva clave se muestran en <a href=#commit-steps>Pasos para los Nuevos Committers</a>.</p></div></div></div></div><div class=sect1><h2 id=kerberos-ldap>3. Kerberos y contraseña web LDAP para el clúster de FreeBSD<a class=anchor href=#kerberos-ldap></a></h2><div class=sectionbody><div class=paragraph><p>El clúster de FreeBSD requiere una contraseña de Kerberos para acceder a ciertos servicios. La contraseña de Kerberos también sirve como contraseña web LDAP, ya que LDAP hace de proxy a Kerberos en el clúster. Algunos de los servicios que requieren esto incluyen:</p></div><div class=ulist><ul><li><p><a href=https://bugs.freebsd.org/bugzilla>Bugzilla</a></p></li><li><p><a href=https://ci.freebsd.org>Jenkins</a></p></li></ul></div><div class=paragraph><p>Para crear una nueva cuenta de Kerberos en el clúster de FreeBSD, o para restablecer una contraseña de Kerberos para una cuenta existente utilizando un generador de contraseñas aleatorias:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ssh kpasswd.freebsd.org</code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Esto debe hacerse desde una máquina fuera del clúster de FreeBSD.org.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Una contraseña de Kerberos también puede ser establecida manualmente iniciando sesión en <code>freefall.FreeBSD.org</code> y ejecutando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% kpasswd</code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>A menos que los servicios autentificados con Kerberos del clúster de FreeBSD.org hayan sido usados previamente, se mostrará <code>Client unknown</code>. Este error significa que el método de <code>ssh kpasswd.freebsd.org</code> mostrado previamente tendrá que ser usado para inicializar la cuenta de Kerberos.</p></div></td></tr></tbody></table></div></div></div><div class=sect1><h2 id=committer.types>4. Tipos de Commit Bits<a class=anchor href=#committer.types></a></h2><div class=sectionbody><div class=paragraph><p>El repositorio de FreeBSD tiene una serie de componentes que, cuando se combinan, integran el código fuente del sistema base del sistema operativo, la documentación, la infraestructura de ports de las aplicaciones de terceros y varias utilidades mantenidas. Cuando se asignan los commit bits, se especifican las áreas del árbol donde se tiene permiso. Generalmente, las áreas asociadas con un commit bit reflejan quién autorizó la asignación del commit bit. Se pueden agregar más áreas de autoridad posteriormente: cuando esto ocurre, el committer debe seguir los procedimientos normales de asignación de commit bit para esa área del árbol, buscar la aprobación de la entidad apropiada y posiblemente obtener un mentor para esa área durante un cierto periodo de tiempo.</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Tipos de Commiters</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><em>Responsable</em></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><em>Componentes del Árbol</em></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>src</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>core@</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>src/</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>doc</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>doceng@</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>doc/, ports/, src/ documentación</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>ports</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>portmgr@</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>ports/</p></td></tr></tbody></table><div class=paragraph><p>Los commit bits asignados antes de que se desarrollara la idea de áreas de autoridad, pueden ser apropiados para su uso en muchas partes del árbol. Sin embargo, el sentido común dicta que un committer que no haya trabajado previamente en esa área del árbol busque una revisión antes de realizar el commit, busque la aprobación del equipo responsable, y/o trabaje con un mentor. Dado que las reglas con respecto al mantenimiento del código difieren según el área del árbol, esto beneficiará tanto a quién trabaja en un área del árbol con la que no está muy familiarizado como a quienes trabajan en el árbol.</p></div><div class=paragraph><p>Se anima a los committers a buscar la revisión de su trabajo como parte del proceso natural del desarrollo, independientemente del área del árbol en la cual se esté realizando el trabajo.</p></div><div class=sect2><h3 id=_política_para_la_actividad_de_los_committers_en_otros_árboles>4.1. Política para la actividad de los Committers en otros árboles<a class=anchor href=#_política_para_la_actividad_de_los_committers_en_otros_árboles></a></h3><div class=ulist><ul><li><p>Todos los committers pueden modificar <span class=filename>src/share/misc/committers-*.dot</span>, <span class=filename>src/usr.bin/calendar/calendars/calendar.freebsd</span>, y <span class=filename>ports/astro/xearth/files</span>.</p></li><li><p>Los committers de documentación pueden realizar commits en la documentación de <span class=filename>src</span>, como las páginas del manual, READMEs, bases de datos de fortune, archivos de calendario y correcciones de comentarios sin la aprobación de un src committer, teniendo en cuenta las normas requeridas para la correcta realización de los commits.</p></li><li><p>Cualquier committer puede realizar cambios en cualquier otro árbol con un "Approved by" de un committer que no esté tutelado y dispone del commit bit apropiado. Los committers con mentor pueden proporcionar un comentario "Reviewed by" pero no un "Approved by".</p></li><li><p>Los committers pueden adquirir commit bit adicionales mediante el proceso habitual de encontrar a un mentor que lo proponga a core, doceng o portmgr, según sea el caso. Una vez aprobados, se añadirán al "acceso" y se producirá el periodo normal de tutoría, que implicará una continuación de "Approved by" durante algún tiempo.</p></li></ul></div><div class=sect3><h4 id=doc-blanket-approval>4.1.1. Aprobación Implícita (Blanket) de Documentación<a class=anchor href=#doc-blanket-approval></a></h4><div class=paragraph><p>Algunos arreglos tienen "blanket approval" por parte de Grupo de Ingeniería de Documentación &lt;<a href=mailto:doceng@FreeBSD.org>doceng@FreeBSD.org</a>>, permitiendo a cualquier committer arreglar ese tipo de problemas en cualquier parte del árbol de documentación. Estos arreglos no necesitan aprobación o revisión por parte de un committer de documentación si el autor no tiene un commit bit de documentación.</p></div><div class=paragraph><p>El blanket approval aplica en estos tipos de arreglos:</p></div><div class=ulist><ul><li><p>Faltas de ortografía</p></li><li><p>Arreglos triviales</p><div class=paragraph><p>Puntuación, URLs, fechas, rutas y nombres de fichero con información desactualizada o incorrecta, y otros errores comunes que puedan confundir a los lectores.</p></div></li></ul></div><div class=paragraph><p>A lo largo de los años, se han concedido algunas aprobaciones implícitas en el árbol de documentación. Esta lista muestra los casos más comunes:</p></div><div class=ulist><ul><li><p>Cambios en <span class=filename>documentation/content/en/books/porters-handbook/versions/_index.adoc</span></p><div class=paragraph><p><a href=https://docs.freebsd.org/en/books/porters-handbook/versions/>__FreeBSD_version Values (Porter’s Handbook)</a>, utilizado principalmente por committers de src.</p></div></li><li><p>Cambios en <span class=filename>doc/shared/contrib-additional.adoc</span></p><div class=paragraph><p>Mantenimiento de <a href=https://docs.freebsd.org/en/articles/contributors/#contrib-additional>Colaboradores Adicionales de FreeBSD</a>.</p></div></li><li><p>Todo <a href=#commit-steps>Pasos para los Nuevos Committers</a>, relacionado con documentación</p></li><li><p>Avisos de seguridad; Notas de Errata; Releases;</p><div class=paragraph><p>Utilizado por Grupo Responsables de Seguridad &lt;<a href=mailto:security-officer@FreeBSD.org>security-officer@FreeBSD.org</a>> y Grupo de Ingeniería de Releases &lt;<a href=mailto:re@FreeBSD.org>re@FreeBSD.org</a>>.</p></div></li><li><p>Cambios en <span class=filename>website/content/en/donations/donors.adoc</span></p><div class=paragraph><p>Utilizado por el Responsable de Donaciones &lt;<a href=mailto:donations@FreeBSD.org>donations@FreeBSD.org</a>>.</p></div></li></ul></div><div class=paragraph><p>Antes de un commit, es necesario comprobar la compilación; consulta las secciones de 'Overview' y 'The FreeBSD Documentation Build Process' de <a href=https://docs.freebsd.org/en/books/fdp-primer/>Introducción al Proyecto de Documentación de FreeBSD para Nuevos Voluntarios</a> para más detalles.</p></div></div></div></div></div><div class=sect1><h2 id=git-primer>5. Introducción a Git<a class=anchor href=#git-primer></a></h2><div class=sectionbody><div class=sect2><h3 id=git-basics>5.1. Git básico<a class=anchor href=#git-basics></a></h3><div class=paragraph><p>Cuando uno busca "Introducción a Git" aparecen unos cuantos buenos las introducciones de Daniel Miessler <a href=https://danielmiessler.com/study/git/>A git primer</a> y de Willie Willus <a href=https://gist.github.com/williewillus/068e9a8543de3a7ef80adb2938657b6b>Git - Quick Primer</a> son ambas buenas. El libro de Git también es completo, pero mucho más largo <a href=https://git-scm.com/book/en/v2 class=bare>https://git-scm.com/book/en/v2</a>. También hay un sitio web <a href=https://dangitgit.com/ class=bare>https://dangitgit.com/</a> para errores comunes y problemas de Git, en caso de que necesites ayuda para arreglar algo. Por último una introducción <a href=https://eagain.net/articles/git-for-computer-scientists/>dirigida a científicos computacionales</a> ha demostrado ser útil para algunos a la hora de explicar cómo Git ve el mundo.</p></div><div class=paragraph><p>Este documento asumirá que lo has leído y tratará de no insistir en lo básico (aunque lo cubrirá brevemente).</p></div></div><div class=sect2><h3 id=git-mini-primer>5.2. Mini Introducción a Git<a class=anchor href=#git-mini-primer></a></h3><div class=paragraph><p>Esta introducción tiene un ámbito menos ambicioso que la antigua Introducción a Subversion, pero debería cubrir lo básico.</p></div><div class=sect3><h4 id=_ámbito>5.2.1. Ámbito<a class=anchor href=#_ámbito></a></h4><div class=paragraph><p>Si quieres descargar FreeBSD, compilarlo desde las fuentes, y en general mantenerte actualizado de ese modo, esta introducción es para ti. Cubre cómo obtener las fuentes, actualizarlas, hacer bisección y trata brevemente cómo lidiar con unos pocos cambios locales. Cubre lo básico y trata de dar buenos consejos para un tratamiento más en profundidad para cuando el lector encuentre lo básico insuficiente. Otras secciones de esta guía cubren temas más avanzados relacionados con cómo contribuir al proyecto.</p></div><div class=paragraph><p>El objetivo de esta sección es resaltar aquellas partes de Git que se necesitan para seguir la pista a las fuentes. Asumen un conocimiento básico de Git. Hay muchas introducciones de Git en la web, pero el <a href=https://git-scm.com/book/en/v2>Git Book</a> proporciona una de las mejores.</p></div></div><div class=sect3><h4 id=git-mini-primer-getting-started>5.2.2. Primeros Pasos Para Desarrolladores<a class=anchor href=#git-mini-primer-getting-started></a></h4><div class=paragraph><p>Esta sección describe el acceso de lectura-escritura para que los committers hagan push de los commits de los desarrolladores o colaboradores.</p></div><div class=sect4><h5 id=git-mini-daily-use>5.2.2.1. Uso diario<a class=anchor href=#git-mini-daily-use></a></h5><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>In the examples below, replace <code>${repo}</code> with the name of the desired FreeBSD repository: <code>doc</code>, <code>ports</code>, or <code>src</code>.</p></div></td></tr></tbody></table></div><div class=ulist><ul><li><p>Clona el repositorio:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% git clone <span class=nt>-o</span> freebsd <span class=nt>--config</span> remote.freebsd.fetch<span class=o>=</span><span class=s1>&#39;+refs/notes/*:refs/notes/*&#39;</span> https://git.freebsd.org/<span class=k>${</span><span class=nv>repo</span><span class=k>}</span>.git</code></pre></div></div><div class=paragraph><p>Después deberías tener tu remote apuntando a los mirrors oficiales:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% git remote <span class=nt>-v</span>
freebsd  https://git.freebsd.org/<span class=k>${</span><span class=nv>repo</span><span class=k>}</span>.git <span class=o>(</span>fetch<span class=o>)</span>
freebsd  https://git.freebsd.org/<span class=k>${</span><span class=nv>repo</span><span class=k>}</span>.git <span class=o>(</span>push<span class=o>)</span></code></pre></div></div></li><li><p>Configura los datos del committer de FreeBSD:</p><div class=paragraph><p>El commit hook en repo.freebsd.org comprueba que el campo "Commit" coincide con la información del committer en FreeBSD.org. La forma más fácil de conseguir la configuración sugerida es ejecutar el script <code>/usr/local/bin/gen-gitconfig.sh</code> en freefall:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% gen-gitconfig.sh
<span class=o>[</span>...]
% git config user.name <span class=o>(</span>your name <span class=k>in </span>gecos<span class=o>)</span>
% git config user.email <span class=o>(</span>your login<span class=o>)</span>@FreeBSD.org</code></pre></div></div></li><li><p>Establece la URL para hacer push:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% git remote set-url <span class=nt>--push</span> freebsd git@gitrepo.freebsd.org:<span class=k>${</span><span class=nv>repo</span><span class=k>}</span>.git</code></pre></div></div><div class=paragraph><p>Después deberías tener URLs separadas para fetch y push que es la configuración más eficiente:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% git remote <span class=nt>-v</span>
freebsd  https://git.freebsd.org/<span class=k>${</span><span class=nv>repo</span><span class=k>}</span>.git <span class=o>(</span>fetch<span class=o>)</span>
freebsd  git@gitrepo.freebsd.org:<span class=k>${</span><span class=nv>repo</span><span class=k>}</span>.git <span class=o>(</span>push<span class=o>)</span></code></pre></div></div><div class=paragraph><p>De nuevo, date cuenta de que <code>gitrepo.freebsd.org</code> ha sido convertido a su forma canónica <code>repo.freebsd.org</code>.</p></div></li><li><p>Instala el hook para la plantilla del mensaje de commit:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% fetch https://cgit.freebsd.org/src/plain/tools/tools/git/hooks/prepare-commit-msg <span class=nt>-o</span> .git/hooks
% <span class=nb>chmod </span>755 .git/hooks/prepare-commit-msg</code></pre></div></div></li></ul></div></div><div class=sect4><h5 id=admin-branch>5.2.2.2. rama "admin"<a class=anchor href=#admin-branch></a></h5><div class=paragraph><p>Los ficheros <code>access</code> y <code>metors</code> se almacenan en una rama huérfana, <code>internal/admin</code>, en cada repositorio.</p></div><div class=paragraph><p>El siguiente ejemplo muestra cómo obtener la rama <code>internal/admin</code> en una rama local <code>admin</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% git config <span class=nt>--add</span> remote.freebsd.fetch <span class=s1>&#39;+refs/internal/*:refs/internal/*&#39;</span>
% git fetch
% git checkout <span class=nt>-b</span> admin internal/admin</code></pre></div></div><div class=paragraph><p>De forma alternativa, puedes añadir un árbol de trabajo (worktree) para la rama <code>admin</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>git worktree add <span class=nt>-b</span> admin ../<span class=k>${</span><span class=nv>repo</span><span class=k>}</span><span class=nt>-admin</span> internal/admin</code></pre></div></div><div class=paragraph><p>Para visualizar la rama <code>internal/admin</code> en la web: <code><a href="https://cgit.freebsd.org/${repo}/log/?h=internal/admin" class=bare>https://cgit.freebsd.org/${repo}/log/?h=internal/admin</a></code></p></div><div class=paragraph><p>For pushing, specify the full refspec:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>git push freebsd HEAD:refs/internal/admin</code></pre></div></div></div></div><div class=sect3><h4 id=_mantenerse_actualizado_con_el_árbol_src_de_freebsd>5.2.3. Mantenerse Actualizado Con el Árbol src de FreeBSD<a class=anchor href=#_mantenerse_actualizado_con_el_árbol_src_de_freebsd></a></h4><div id=keeping_current class=paragraph><p>Primer paso: clonar un árbol. Esto descarga el árbol completo. Hay dos formas de hacerlo. La mayoría de la gente quiere hacer un clonado profundo del repositorio. Sin embargo, hay momentos en los que quieres hacer un clonado superficial.</p></div><div class=sect4><h5 id=_nombres_de_las_ramas>5.2.3.1. Nombres de las Ramas<a class=anchor href=#_nombres_de_las_ramas></a></h5><div class=paragraph><p>FreeBSD-CURRENT utiliza la rama <code>main</code>.</p></div><div class=paragraph><p><code>main</code> es la rama por defecto.</p></div><div class=paragraph><p>Para FreeBSD-STABLE, los nombres de las ramas incluyen <code>stable/12</code> y <code>stable/13</code>.</p></div><div class=paragraph><p>Para FreeBSD-RELEASE, los nombres de las ramas de ingeniería de versiones incluyen <code>releng/12.4</code> y <code>releng/13.2</code>.</p></div><div class=paragraph><p><a href=https://www.freebsd.org/releng/ class=bare>https://www.freebsd.org/releng/</a> muestra:</p></div><div class=ulist><ul><li><p>ramas <code>main</code> y <code>stable/⋯</code> abiertas</p></li><li><p>ramas <code>releng/⋯</code> , cada una de las cuales es congelada cuando se etiqueta una versión.</p></li></ul></div><div class=paragraph><p>Ejemplos:</p></div><div class=ulist><ul><li><p>etiqueta <a href="https://cgit.freebsd.org/src/tag/?h=release/13.1.0">release/13.1.0</a> en la rama <a href="https://cgit.freebsd.org/src/log/?h=releng/13.1">releng/13.1</a></p></li><li><p>etiqueta <a href="https://cgit.freebsd.org/src/tag/?h=release/13.2.0">release/13.2.0</a> en la rama <a href="https://cgit.freebsd.org/src/log/?h=releng/13.2">releng/13.2</a>.</p></li></ul></div></div><div class=sect4><h5 id=_repositorios>5.2.3.2. Repositorios<a class=anchor href=#_repositorios></a></h5><div class=paragraph><p>Por favor consulta <a href=#admin>Detalles Administrativos</a> para la última información sobre dónde obtener las fuentes de FreeBSD. El $URL que se muestra abajo se puede obtener en esa página.</p></div><div class=paragraph><p>Nota: El proyecto no utiliza submódulos ya que no encajan en nuestro flujo de trabajo y modelo de desarrollo. Cómo seguimos la pista a los cambios en las aplicaciones de terceros se discute en otro sitio y en general no es de interés para un usuario casual.</p></div></div><div class=sect4><h5 id=_clonado_profundo>5.2.3.3. Clonado Profundo<a class=anchor href=#_clonado_profundo></a></h5><div class=paragraph><p>Un clonado profundo se trae el árbol entero, así como las ramas y toda la historia. Es lo más fácil de hacer. También te permite usar la característica de los árboles de trabajo para tener todas tus ramas activas en directorios separados pero con una sola copia del repositorio.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% git clone <span class=nt>-o</span> freebsd <span class=nv>$URL</span> <span class=nt>-b</span> branch <span class=o>[</span>&lt;directory&gt;]</code></pre></div></div><div class=paragraph><p> — creará un clonado profundo. <code>branch</code> debería ser una de las ramas listadas en la sección anterior. Si no se proporciona <code>branch</code> se usará la rama por defecto (<code>main</code>). Si no se proporciona <code>&lt;directory></code> se usará como nombre del nuevo directorio el que coincida con el nombre del repositorio (<span class=filename>doc</span>, <span class=filename>ports</span> o <span class=filename>src</span>).</p></div><div class=paragraph><p>Querrás un clonado profundo si estás interesado en el histórico, planeas hacer cambios locales, o planeas trabajar en más de una rama. Es la forma más fácil también de mantenerse actualizado. Si estás interesado en el histórico pero vas a trabajar sólo con una rama y andas corto de espacio, también puedes usar --single-branch para descargar la rama (aunque algunos commits de merge no referenciarán la rama desde la que se mergearon lo que podría ser importante para algunos usuarios interesados en versiones detalladas del histórico).</p></div></div><div class=sect4><h5 id=_clonado_superficial>5.2.3.4. Clonado Superficial<a class=anchor href=#_clonado_superficial></a></h5><div class=paragraph><p>Un clonado superficial sólo copia el código más actual, pero nada o poco del histórico. Esto puede ser útil cuando necesitas construir una revisión específica de FreeBSD o cuando simplemente estás empezando y planeas seguir la pista al árbol de forma más completa. También puedes usarlo para limitar el histórico a un número determinado de revisiones. Sin embargo, lee más abajo para una limitación importante a esta aproximación.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% git clone <span class=nt>-o</span> freebsd <span class=nt>-b</span> branch <span class=nt>--depth</span> 1 <span class=nv>$URL</span> <span class=o>[</span><span class=nb>dir</span><span class=o>]</span></code></pre></div></div><div class=paragraph><p>Esto clona el repositorio, pero sólo la versión más reciente. El resto del histórico no se descarga. Si cambiaras de opinión más tarde, puedes hacer <code>git fetch --unshallow</code> para obtener el histórico antiguo.</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Cuando haces un clonado superficial, pierdes el contador de commits en la salida de uname. Esto puede hacer más difícil determinar si tu sistema necesita ser actualizado cuando se notifica un aviso de seguridad.</p></div></td></tr></tbody></table></div></div><div class=sect4><h5 id=_compilando>5.2.3.5. Compilando<a class=anchor href=#_compilando></a></h5><div class=paragraph><p>Una vez que has descargado, la compilación se hace como se describe en el manual, por ejemplo.:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>cd </span>src
% make buildworld
% make buildkernel
% make installkernel
% make installworld</code></pre></div></div><div class=paragraph><p>de forma que no lo cubriremos en profundidad.</p></div><div class=paragraph><p>Si quieres construir un kernel personalizado, <a href=https://docs.freebsd.org/es/books/handbook/#kernelconfig>la sección de configuración del kernel</a> del FreeBSD Handbook recomienda crear un fichero MYKERNEL bajo sys/${ARCH}/conf con tus cambios contra GENERIC. Para que Git ignore MYKERNEL, se puede añadir a .git/info/exclude.</p></div></div><div class=sect4><h5 id=_actualización>5.2.3.6. Actualización<a class=anchor href=#_actualización></a></h5><div class=paragraph><p>Para actualizar ambos tipos de árbol utilizan los mismos comandos. Esto se trae todas las revisiones desde tu última actualización.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% git pull <span class=nt>--ff-only</span></code></pre></div></div><div class=paragraph><p>actualizará el árbol. En Git, un merge tipo 'fast forward' es aquel que sólo necesita establecer el puntero a una rama nueva y no necesita recrear los commits. Haciendo siempre un merge/pull de tipo 'fast forward', te asegurarás de que tienes una copia exacta del árbol de FreeBSD. Esto será importante si quieres mantener parches locales.</p></div><div class=paragraph><p>Lee más abajo para saber cómo gestionar cambios locales. Lo más sencillo es utilizar <code>--autostash</code> con el comando <code>git pull</code>, pero hay disponibles opciones más sofisticadas.</p></div></div></div><div class=sect3><h4 id=_seleccionando_una_versión_específica>5.2.4. Seleccionando una Versión Específica<a class=anchor href=#_seleccionando_una_versión_específica></a></h4><div class=paragraph><p>En Git, <code>git checkout</code> se trae tanto ramas como versiones específicas. Las versiones de Git son hashes largos en lugar de números secuenciales.</p></div><div class=paragraph><p>Cuando te traes una versión específica, simplemente especifica en la línea de comando el hash que quieres (el comando git log te ayudará a decidir cuál es el hash que quieres):</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% git checkout 08b8197a74</code></pre></div></div><div class=paragraph><p>y ya te lo has traído. Se te saludará con un mensaje como el siguiente:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Note: checking out <span class=s1>&#39;08b8197a742a96964d2924391bf9fdfeb788865d&#39;</span><span class=nb>.</span>

You are <span class=k>in </span>a <span class=s1>&#39;detached HEAD&#39;</span> state. You can look around, make experimental
changes and commit them, and you can discard any commits you make <span class=k>in </span>this
state without impacting any branches by performing another checkout.

If you want to create a new branch to retain commits you create, you may
<span class=k>do </span>so <span class=o>(</span>now or later<span class=o>)</span> by using <span class=nt>-b</span> with the checkout <span class=nb>command </span>again. Example:

  git checkout <span class=nt>-b</span> &lt;new-branch-name&gt;

HEAD is now at 08b8197a742a hook gpiokeys.4 to the build</code></pre></div></div><div class=paragraph><p>donde la última línea es generada a partir del hash que te has traído y la primera línea del mensaje de commit de esa revisión. El hash se puede abreviar a la longitud única más corta que exista. Git es inconsistente acerca de cuántos dígitos muestra.</p></div></div><div class=sect3><h4 id=_bisección>5.2.5. Bisección<a class=anchor href=#_bisección></a></h4><div class=paragraph><p>A veces, algo va mal. La última versión funcionó pero la última a la que te has actualizado no. Un desarrollador podría pedirte que bisecciones el problema para localizar qué commit causó la regresión.</p></div><div class=paragraph><p>Git hacer fácil biseccionar cambios con un potente comando <code>git bisect</code>. Aquí hay una breve introducción a cómo usarlo. Para más información, puedes ver <a href=https://www.metaltoad.com/blog/beginners-guide-git-bisect-process-elimination class=bare>https://www.metaltoad.com/blog/beginners-guide-git-bisect-process-elimination</a> o <a href=https://git-scm.com/docs/git-bisect class=bare>https://git-scm.com/docs/git-bisect</a> para más detalles. La página de manual de git-bisect es buena describiendo lo que puede salir mal, qué hacer cuando las versiones no compilan, cuándo quieres usar otros términos diferentes de 'bueno' y 'malo', etc, nada de lo cual se cubrirá aquí.</p></div><div class=paragraph><p><code>git bisect start --first-parent</code> comenzará el proceso de bisección. Después necesitarás decirle un rango para que trabaje. <code>git bisect good XXXXXX</code> le dirá la revisión que funciona y <code>git bisect bad XXXXX</code> le dirá la revisión mala. La revisión mala casi siempre será HEAD (un tag especial para lo que te has traído). La versión buena será la última que te trajiste. El argumento <code>--first-parent</code> es necesario para que llamadas siguientes a <code>git bisect</code> no intenten traerse una rama externa que carece de las fuentes completas de FreeBSD.</p></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Si quieres saber la última versión que te trajiste, deberías usar <code>git reflog</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>5ef0bd68b515 <span class=o>(</span>HEAD -&gt; main, freebsd/main, freebsd/HEAD<span class=o>)</span> HEAD@<span class=o>{</span>0<span class=o>}</span>: pull <span class=nt>--ff-only</span>: Fast-forward
a8163e165c5b <span class=o>(</span>upstream/main<span class=o>)</span> HEAD@<span class=o>{</span>1<span class=o>}</span>: checkout: moving from b6fb97efb682994f59b21fe4efb3fcfc0e5b9eeb to main
...</code></pre></div></div><div class=paragraph><p>me muestra moviendo el directorio de trabajo a la rama <code>main</code> (a816…​) y después actualizando desde el origen (a 5ef0…​). En esta caso, malo sería HEAD (o 5rf0bd68) y bueno sería a8163e165. Como puedes ver en la salida, HEAD@{1} también funciona, pero no es a prueba de fallos si has hecho otras cosas en tu árbol después de actualizar, pero antes de que descubrieras que tenías que hacer bisección.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Primero establece la versión 'good', luego la mala (aunque el orden no importa). Cuando establezcas la versión mala, te dará algunas estadísticas sobre el proceso:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% git bisect start <span class=nt>--first-parent</span>
% git bisect good a8163e165c5b
% git bisect bad HEAD
Bisecting: 1722 revisions left to <span class=nb>test </span>after this <span class=o>(</span>roughly 11 steps<span class=o>)</span>
<span class=o>[</span>c427b3158fd8225f6afc09e7e6f62326f9e4de7e] Fixup r361997 by balancing parens.  Duh.</code></pre></div></div><div class=paragraph><p>Después deberías compilar/instalar esa versión. Si es buena, teclearías <code>git bisect good</code> si no <code>git bisect bad</code>. Si la versión no compila, teclea <code>git bisect skip</code>. Recibirás un mensaje similar al de arriba para cada paso. Una vez que hayas terminado, informa al desarrollador de la versión mala (o arregla el fallo tú mismo y envía un parche). <code>git bisect reset</code> terminará el proceso y te devolverá a donde empezaste (normalmente a la punta de <code>main</code>). De nuevo, el manual de git-bisect (enlazado arriba) es un buen recurso para cuando las cosas van mal o en casos inusuales.</p></div></div><div class=sect3><h4 id=git-gpg-signing>5.2.6. Firmando los commits, tags, y pushes, con GnuPG<a class=anchor href=#git-gpg-signing></a></h4><div class=paragraph><p>Git sabe cómo firmar commits, tags y pushes. Cuando firmas un commit o tag de Git, puedes probar que el código que enviaste vino de ti y que no fue alterado mientras lo transferías. También puedes probar que tú enviaste el código y no otra persona.</p></div><div class=paragraph><p>Se puede encontrar documentación más en profundidad sobre cómo firmar commits y tags en el capítulo <a href=https://git-scm.com/book/en/v2/Git-Tools-Signing-Your-Work>Git Tools - Signing Your Work</a> del libro de Git.</p></div><div class=paragraph><p>El motivo tras la firma de pushes se puede encontrar en el <a href=https://github.com/git/git/commit/a85b377d0419a9dfaca8af2320cc33b051cbed04>commit que introdujo esta característica</a>.</p></div><div class=paragraph><p>La mejor forma es simplemente decirle a Git que siempre quieres firmar commits, tags y pushes. Puedes hacerlo estableciendo unas pocas variables de configuración:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% git config <span class=nt>--add</span> user.signingKey LONG-KEY-ID
% git config <span class=nt>--add</span> commit.gpgSign <span class=nb>true</span>
% git config <span class=nt>--add</span> tag.gpgSign <span class=nb>true</span>
% git config <span class=nt>--add</span> push.gpgSign <span class=k>if</span><span class=nt>-asked</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Para evitar posibles colisiones, asegúrate de darle a Git una id de clave que sea largo. Puedes obtenerlo con: <code>gpg --list-secret-keys --keyid-format LONG</code>.</p></div></td></tr></tbody></table></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Para utilizar subclaves específicas y no hacer que GnuPG resuelva la subclave a una clave primaria, añade <code>!</code> a la clave. Por ejemplo, para encriptar la subclave <code>DEADBEEF</code>, usa <code>DEADBEEF!</code>.</p></div></td></tr></tbody></table></div><div class=sect4><h5 id=_verificando_firmas>5.2.6.1. Verificando firmas<a class=anchor href=#_verificando_firmas></a></h5><div class=paragraph><p>Las firmas de los commits se pueden verificar ejecutando <code>git verify-commit &lt;commit hash></code>, o <code>git log --show-signature</code>.</p></div><div class=paragraph><p>Las firmas de los tags se pueden verificar con <code>git verity-tag &lt;tag name></code>, o <code>git tag -v &lt;tag name></code>.</p></div></div></div><div class=sect3><h4 id=_consideraciones_para_ports>5.2.7. Consideraciones para Ports<a class=anchor href=#_consideraciones_para_ports></a></h4><div class=paragraph><p>El árbol de ports funciona de la misma forma. Los nombres de las ramas son diferentes y los repositorios están en diferentes lugares.</p></div><div class=paragraph><p>La interfaz web cgit del repositorio para ser usada desde navegadores web está en <a href=https://cgit.FreeBSD.org/ports/ class=bare>https://cgit.FreeBSD.org/ports/</a>. El repositorio Git de producción está en <a href=https://git.FreeBSD.org/ports.git class=bare>https://git.FreeBSD.org/ports.git</a> y en ssh://anongit@git.FreeBSD.org/ports.git (o <a href=mailto:anongit@git.FreeBSD.org>anongit@git.FreeBSD.org</a>:ports.git).</p></div><div class=paragraph><p>También hay un mirror en GitHub, lee <a href=https://docs.freebsd.org/es/books/handbook//mirrors#mirrors>Mirrors externos</a> para un resumen. La rama más actual es 'main'. Las ramas <em>trimestrales</em> se llaman <code>yyyyQn</code> para el año 'yyyy' y el trimestre 'n'.</p></div><div class=sect4><h5 id=port-commit-message-formats>5.2.7.1. Formatos de mensaje de commits<a class=anchor href=#port-commit-message-formats></a></h5><div class=paragraph><p>El repositorio de ports tiene disponible en <a href=https://cgit.freebsd.org/ports/tree/.hooks/prepare-commit-msg>.hooks/prepare-commit-message</a> un hook para ayudarte a escribir tus mensajes de commit. Se puede activar ejecutando <code>git config --add core.hooksPath .hooks</code>.</p></div><div class=paragraph><p>La razón principal es que un mensaje de commit se debería formatear de la siguiente forma:</p></div><div class=literalblock><div class=content><pre>category/port: Summary.

Descripción de por qué se han hecho los cambios.

PR:	    12345</pre></div></div><div class="admonitionblock important"><table><tbody><tr><td class=icon><i class="fa icon-important" title=Important></i></td><td class=content><div class=paragraph><p>La primera línea es el título del commit, contiene por qué el port ha cambiado, y un resumen del commit. Debería ser de no más de 50 caracteres.</p></div><div class=paragraph><p>Se debería utilizar una línea en blanco para separarlo del resto del mensaje de commit.</p></div><div class=paragraph><p>El resto del mensaje se debería limitar a no más de 72 caracteres por línea.</p></div><div class=paragraph><p>Si hay campos de metadatos se debería utilizar otra línea en blanco, de forma que se distingan fácilmente del mensaje de commit.</p></div></td></tr></tbody></table></div></div></div><div class=sect3><h4 id=_gestionando_cambios_locales>5.2.8. Gestionando Cambios Locales<a class=anchor href=#_gestionando_cambios_locales></a></h4><div class=paragraph><p>This section addresses tracking local changes. If you have no local changes you can skip this section.</p></div><div class=paragraph><p>Un punto que es importante para todos ellos: todos los cambios son locales hasta que se hace push. A diferencia de Subversion, Git utiliza un modelo distribuido. Para la mayoría de los usuarios y los casos, hay poca diferencia. Sin embargo, si tienes cambios locales, puedes usar la misma herramienta para gestionarlos que la que usara para traerte los cambios de FreeBSD. Todos los cambios para los que no has hecho push son locales y se pueden cambiar fácilmente (git rebase, discutido más abajo hace esto).</p></div><div class=sect4><h5 id=_manteniendo_cambios_locales>5.2.8.1. Manteniendo cambios locales<a class=anchor href=#_manteniendo_cambios_locales></a></h5><div class=paragraph><p>La forma más sencilla de mantener cambios locales (especialmente si son triviales) es usar <code>git stash</code>. En su forma más simple, utilizas <code>git stash</code> para grabar los cambios (lo que los empuja a la pila del stash). La mayoría de la gente utiliza esto para guardar cambios antes de actualizar un árbol como se describe arriba. Después utilizan <code>git stash apply</code> para reaplicarlos al árbol. El stash es una pila de cambios que se puede examinar con <code>git stash list</code>. La página del manual de git-stash (<a href=https://git-scm.com/docs/git-stash class=bare>https://git-scm.com/docs/git-stash</a>) tiene todos los detalles.</p></div><div class=paragraph><p>Este método va bien cuando tienes pequeños cambios en el árbol. Cuando tienes algo no trivial, probablemente sea mejor mantener una rama local y rebasarla. Guardar los cambios (stashing) también es algo integrado en el comando <code>git pull</code>: simplemente añade <code>--autostash</code> en la línea de comando.</p></div></div><div class=sect4><h5 id=_manteniendo_una_rama_local>5.2.8.2. Manteniendo una rama local<a class=anchor href=#_manteniendo_una_rama_local></a></h5><div id=keeping_a_local_branch class=paragraph><p>Es mucho más fácil mantener una rama local con Git que con Subversion. En Subversion necesitas mergear el commit, y resolver los conflictos. Esto es manejable, pero puede llevar a un histórico complicado que es difícil de mover al origen (upstream) si fuera necesario, o difícil de replicar si lo necesitas. Git también permite mergear, con los mismos problemas. Esa es una forma de gestionar la rama, pero es la menos flexible.</p></div><div class=paragraph><p>Además de hacer merging, Git soporta el concepto de rebase que evita estos problemas. El comando <code>git rebase</code> rehace todos los commits de una rama en un lugar nuevo de la rama padre. Cubriremos los casos más comunes que surgen al usarlo.</p></div><div class=sect5><h6 id=_crear_una_rama>5.2.8.2.1. Crear una rama<a class=anchor href=#_crear_una_rama></a></h6><div class=paragraph><p>Digamos que quieres hacer un cambio en el comando ls de FreeBSD para que nunca use colores. Hay muchas razones para hacer esto, pero en este ejemplo usaremos esto como punto de partida. El comando ls de FreeBSD cambia de cuándo en cuándo y necesitarás lidiar con esos cambios. Afortunadamente, con Git rebase esto es algo normalmente automático.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>cd </span>src
% git checkout main
% git checkout <span class=nt>-b</span> no-color-ls
% <span class=nb>cd </span>bin/ls
% vi ls.c     <span class=c># hack the changes in</span>
% git diff    <span class=c># check the changes</span>
diff <span class=nt>--git</span> a/bin/ls/ls.c b/bin/ls/ls.c
index 7378268867ef..cfc3f4342531 100644
<span class=nt>---</span> a/bin/ls/ls.c
+++ b/bin/ls/ls.c
@@ <span class=nt>-66</span>,6 +66,7 @@ __FBSDID<span class=o>(</span><span class=s2>&#34;</span><span class=nv>$FreeBSD</span><span class=s2>$&#34;</span><span class=o>)</span><span class=p>;</span>
 <span class=c>#include &lt;stdlib.h&gt;</span>
 <span class=c>#include &lt;string.h&gt;</span>
 <span class=c>#include &lt;unistd.h&gt;</span>
+#undef COLORLS
 <span class=c>#ifdef COLORLS</span>
 <span class=c>#include &lt;termcap.h&gt;</span>
 <span class=c>#include &lt;signal.h&gt;</span>
% <span class=c># these look good, make the commit...</span>
% git commit ls.c</code></pre></div></div><div class=paragraph><p>El commit te llevará a un editor para que describas lo que has hecho. Una vez hecho esto, tienes tu propia rama <strong>local</strong> en el repo de Git. Compila e instala como harías normalmente, siguiendo las instrucciones del manual. Git es diferente a otros sistemas de control de versiones en cuanto que tienes que decirle explícitamente qué ficheros quieres incluir en el commit. He optado por hacerlo en la linea de comando pero también puedes hacerlo con <code>git add</code> que se cubre en muchos de los tutoriales más detallados.</p></div></div><div class=sect5><h6 id=_momento_de_actualizar>5.2.8.2.2. Momento de actualizar<a class=anchor href=#_momento_de_actualizar></a></h6><div class=paragraph><p>Cuando es momento de sacar una nueva versión, es casi lo mismo que sin ramas. Actualizarías como se ha hecho arriba, pero hay un comando extra antes de que actualices y uno después. Lo que sigue asume que empiezas con un árbol sin modificar. Es importante empezar las operaciones de rebase con un árbol limpio (es un requisito en Git).</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% git checkout main
% git pull <span class=nt>--ff-only</span>
% git rebase <span class=nt>-i</span> main no-color-ls</code></pre></div></div><div class=paragraph><p>Eso arrancará un editor que lista todos los commits. Para este ejemplo, no lo cambies. Esto es típicamente lo que haces mientras actualizas la base (aunque también puedes utilizar el comando rebase de Git para filtrar los commits que quieres en la rama).</p></div><div class=paragraph><p>Una vez que has terminado con lo de arriba, tienes que avanzar los commits de ls.c desde la versión vieja de FreeBSD a la nueva.</p></div><div class=paragraph><p>A veces hay conflictos al fusionar. Está bien. No te asustes. En lugar de eso, trátalos como cualquier otro conflicto de merge. Para hacerlo sencillo, simplemente describiré un problema común que puede aparecer. Se puede encontrar un enlace a un tratamiento más completo al final de esta sección.</p></div><div class=paragraph><p>Digamos que los includes cambian en el proyecto origen de una forma radical para terminfo así como también un cambio de nombre para la opción. Cuando te actualizaste, podrías haber visto algo como esto:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Auto-merging bin/ls/ls.c
CONFLICT <span class=o>(</span>content<span class=o>)</span>: Merge conflict <span class=k>in </span>bin/ls/ls.c
error: could not apply 646e0f9cda11... no color <span class=nb>ls
</span>Resolve all conflicts manually, mark them as resolved with
<span class=s2>&#34;git add/rm &lt;conflicted_files&gt;&#34;</span>, <span class=k>then </span>run <span class=s2>&#34;git rebase --continue&#34;</span><span class=nb>.</span>
You can instead skip this commit: run <span class=s2>&#34;git rebase --skip&#34;</span><span class=nb>.</span>
To abort and get back to the state before <span class=s2>&#34;git rebase&#34;</span>, run <span class=s2>&#34;git rebase --abort&#34;</span><span class=nb>.</span>
Could not apply 646e0f9cda11... no color <span class=nb>ls</span></code></pre></div></div><div class=paragraph><p>que da miedo. Si abres un editor, verás que es una resolución de conflicto típica de 3 vías con la que podrías estar familiarizado de otros sistemas de control de código (el resto de ls.c se ha omitido):</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> <span class=o>&lt;&lt;&lt;&lt;&lt;&lt;</span>&lt; HEAD
 <span class=c>#ifdef COLORLS_NEW</span>
 <span class=c>#include &lt;terminfo.h&gt;</span>
 <span class=o>=======</span>
 <span class=c>#undef COLORLS</span>
 <span class=c>#ifdef COLORLS</span>
 <span class=c>#include &lt;termcap.h&gt;</span>
 <span class=o>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span> 646e0f9cda11... no color <span class=nb>ls</span>
....
El código nuevo está primero, y tu código segundo.
El arreglo correcto aquí es añadir simplemente <span class=c>#undef COLORLS_NEW ante de @ifdef y después borrar los cambios antiguos:</span>
<span class=o>[</span><span class=nb>source</span>,shell]
....
<span class=c>#undef COLORLS_NEW #ifdef COLORLS_NEW #include &lt;terminfo.h&gt;</span>
....
guarda el fichero.
El rebase fue interrumpido, así que tienes que completarlo:
<span class=o>[</span><span class=nb>source</span>,shell]
....
% git add ls.c % git rebase <span class=nt>--continue</span>
....</code></pre></div></div><div class=paragraph><p>que le dice a Git que ls.c ha sido arreglado y que puede continuar con el rebase.
Puesto que hubo un conflicto, se te dirigirá al editor para actualizar el mensaje de commit si es necesario.
Si el mensaje sigue siendo preciso, simplemente sal del editor.</p></div><div class=paragraph><p>Si te atascas durante el rebase, no te asustes. git rebase --abort te llevará de nuevo a un estado limpio.
Sin embargo, es importante empezar con un árbol sin modificar.
Una nota: el <code>git reflog</code> mencionado arriba es útil aquí ya que tendrá una lista de todos los commits (intermedios) que puedes ver, inspeccionar o seleccionar con cherry-pick.</p></div><div class=paragraph><p>Para saber más sobre esto, <a href=https://www.freecodecamp.org/news/the-ultimate-guide-to-git-merge-and-git-rebase/ class=bare>https://www.freecodecamp.org/news/the-ultimate-guide-to-git-merge-and-git-rebase/</a> proporciona un tratamiento bastante amplio.
Es un buen recursos para problemas que puedan surgir de forma ocasional pero que son muy oscuros para esta guía.</p></div></div></div><div class=sect4><h5 id=_cambiando_a_una_rama_diferente_de_freebsd>5.2.8.3. Cambiando a una Rama Diferente de FreeBSD<a class=anchor href=#_cambiando_a_una_rama_diferente_de_freebsd></a></h5><div class=paragraph><p>Si quieres cambiar de stable/12 a la rama current. Si tienes un clonado profundo, lo siguiente es suficiente: [source,shell]</p></div><div class=literalblock><div class=content><pre>% git checkout main % # build and install here...</pre></div></div><div class=paragraph><p>Sin embargo, si tienes una rama local, hay algún problema.
Primero, rebase sobreescribirá el histórico de forma que querrás hacer algo para salvarlo.
Segundo, saltar entre ramas suele causar más conflictos.
Si imaginamos que el ejemplo anterior era relativo a stable/12, entonces para moverlo a <code>main</code>, sugeriría lo siguiente:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% git checkout no-color-ls
% git checkout <span class=nt>-b</span> no-color-ls-stable-12   <span class=c># create another name for this branch</span>
% git rebase <span class=nt>-i</span> stable/12 no-color-ls <span class=nt>--onto</span> main</code></pre></div></div><div class=paragraph><p>Lo anterior se trae no-color-ls.
Luego le da un nombre nuevo (no-color-ls-stable-12) en caso de que necesites volver a ella.
Después rebase sobre la rama <code>main</code>.
Esto encontrará todos los commits de la rama no-color-ls actual (hacia atrás hasta donde se encuentra con la rama stable/12) y después los aplicará de nuevo sobre la rama main creando una nueva rama no-color-ls allí (para lo cual te hice crear un nombre tipo place holder).</p></div></div></div></div><div class=sect2><h3 id=mfc-with-git>5.3. Procedimientos MFC (Merge From Current)<a class=anchor href=#mfc-with-git></a></h3><div class=sect3><h4 id=_resumen>5.3.1. Resumen<a class=anchor href=#_resumen></a></h4><div class=paragraph><p>El flujo de trabajo de MFC se puede resumir como <code>git cherry-pick -x</code> más <code>git commit --amend</code> para ajustar el mensaje de commit. Para múltiples commits, usa <code>git rebase -i</code> para refundirlos juntos y editar el mensaje de commit.</p></div></div><div class=sect3><h4 id=_mfc_de_un_sólo_commit>5.3.2. MFC de un sólo commit<a class=anchor href=#_mfc_de_un_sólo_commit></a></h4><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% git checkout stable/X % git cherry-pick <span class=nt>-x</span> <span class=nv>$HASH</span> <span class=nt>--edit</span></code></pre></div></div><div class=paragraph><p>Para commits MFC, por ejemplo una importación externa, necesitarías especificar un padre para cherry-pick.
Normalmente, sería el "primer padre" de la rama de la que estás haciendo cherry-pick, así que:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% git checkout stable/X % git cherry-pick <span class=nt>-x</span> <span class=nv>$HASH</span> <span class=nt>-m</span> 1 <span class=nt>--edit</span></code></pre></div></div><div class=paragraph><p>Si algo va mal, necesitarás abortar el cherry-pick con <code>git cherry-pick --abort</code> o arreglarlo y hacer un <code>git cherry-pick --continue</code>.</p></div><div class=paragraph><p>Una vez terminado el cherry-pick, empuja con <code>git push</code>.
Si recibes un error por haber perdido una carrera por el commit, utiliza <code>git pull --rebase</code> y prueba a empujarlo de nuevo.</p></div></div><div class=sect3><h4 id=_mfc_a_una_rama_releng>5.3.3. MFC a una rama RELENG<a class=anchor href=#_mfc_a_una_rama_releng></a></h4><div class=paragraph><p>Se necesita más cuidado para hacer MFCs a ramas para las cuales se necesita aprobación. El proceso es el mismo tanto para un merge típico como para un commit directo excepcional.</p></div><div class=ulist><ul><li><p>Integra o hace commit directamente a la rama <code>stable/X</code> apropiada antes de integrarlo en la rama <code>releng/X.Y</code>.</p></li><li><p>Utiliza el hash que está en la rama <code>stable/X</code> para el MFC a la rama <code>releng/X.Y</code>.</p></li><li><p>Deja ambas líneas "cherry picked from" en el mensaje de commit.</p></li><li><p>Asegúrate de añadir la línea <code>Approved by:</code> cuando estés en el editor.</p></li></ul></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% git checkout releng/13.0 % git cherry-pick <span class=nt>-x</span> <span class=nv>$HASH</span> <span class=nt>--edit</span></code></pre></div></div><div class=paragraph><p>Si se te olvida añadir la línea <code>Approved by:</code>, puedes hacer un <code>git commit --amend</code> para editar el mensaje de commit antes de empujar los cambios.</p></div></div><div class=sect3><h4 id=_mfc_de_varios_commits>5.3.4. MFC de varios commits<a class=anchor href=#_mfc_de_varios_commits></a></h4><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% git checkout <span class=nt>-b</span> tmp-branch stable/X % <span class=k>for </span>h <span class=k>in</span> <span class=nv>$HASH_LIST</span><span class=p>;</span> <span class=k>do </span>git cherry-pick <span class=nt>-x</span> <span class=nv>$h</span><span class=p>;</span> <span class=k>done</span> % git rebase <span class=nt>-i</span> stable/X <span class=c># mark each of the commits after the first as &#39;squash&#39; # Actualiza el mensaje de commit para reflejar todos los cambios del mismo, si fuera necesario. # Asegúrate de mantener las líneas &#34;cherry picked from&#34;. % git push freebsd HEAD:stable/X</span></code></pre></div></div><div class=paragraph><p>Si el push falla por perder la carrera del commit, haz rebase y prueba de nuevo:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% git checkout stable/X % git pull % git checkout tmp-branch % git rebase stable/X % git push freebsd HEAD:stable/X</code></pre></div></div><div class=paragraph><p>Una vez que el MFC se ha completado, puedes borrar la rama temporal:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% git checkout stable/X % git branch <span class=nt>-d</span> tmp-branch</code></pre></div></div></div><div class=sect3><h4 id=_haciendo_mfc_de_una_importación_externa>5.3.5. Haciendo MFC de una importación externa<a class=anchor href=#_haciendo_mfc_de_una_importación_externa></a></h4><div class=paragraph><p>Las importaciones externas son lo único en el árbol que crean un commit tipo merge en la rama <code>main</code>. Seleccionar commits tipo merge en stable/XX representa una dificultad adicional porque hay dos padres para un commit tipo merge. En general, querrás la diferencia del primer padre ya que es la diferencia con <code>main</code> (aunque podría haber algunas excepciones).</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% git cherry-pick <span class=nt>-x</span> <span class=nt>-m</span> 1 <span class=nv>$HASH</span></code></pre></div></div><div class=paragraph><p>es normalmente lo que quieres.
Esto le dirá a cherry-pick que aplique el diff correcto.</p></div><div class=paragraph><p>Hay algunos pocos casos (con suerte) donde es posible que la rama <code>main</code> haya sido mergeada hacia atrás por el script de conversión.
Si ese fuera el caso (y todavía no hemos encontrado ninguno), cambiarías lo de arriba por '-m 2' para escoger el padre adecuado.
Simplemente haz:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% git cherry-pick <span class=nt>--abort</span> % git cherry-pick <span class=nt>-x</span> <span class=nt>-m</span> 2 <span class=nv>$HASH</span></code></pre></div></div><div class=paragraph><p>para hacerlo. El <code>--abort</code> limpiará el primer intento fallido.</p></div></div><div class=sect3><h4 id=_rehaciendo_un_mfc>5.3.6. Rehaciendo un MFC<a class=anchor href=#_rehaciendo_un_mfc></a></h4><div class=paragraph><p>Si haces un MFC y va terriblemente mal y quieres empezar de nuevo, lo más fácil es usar <code>git reset --hard</code> así: [source,shell]</p></div><div class=literalblock><div class=content><pre>% git reset --hard freebsd/stable/12</pre></div></div><div class=paragraph><p>aunque si tienes algunas revisiones que quieres mantener, y otras que no,es mejor usar <code>git rebase -i</code>.</p></div></div><div class=sect3><h4 id=_consideraciones_cuando_se_hace_un_mfc>5.3.7. Consideraciones cuando se hace un MFC<a class=anchor href=#_consideraciones_cuando_se_hace_un_mfc></a></h4><div class=paragraph><p>Cuando se hace commit the commits the código fuente a las ramas stable y releng, tenemos los siguientes objetivos:</p></div><div class=ulist><ul><li><p>Señala claramente los commits directos de aquellos que introducen un cambio desde otra rama.</p></li><li><p>Evita introducir errores en las ramas stable y releng.</p></li><li><p>Permite a los desarrolladores determinar qué cambias han sido o no traídos desde otra rama.</p></li></ul></div><div class=paragraph><p>Con Subversion, usábamos las siguientes prácticas para conseguir estos objetivos:</p></div><div class=ulist><ul><li><p>Usar las etiquetas <code>MFC</code> y <code>MFS</code> para marcar los commits que integran cambios desde otra rama.</p></li><li><p>Compactar los commits de correcciones en el commit principal cuando se integra un cambio.</p></li><li><p>Grabar mergeinfo de forma que <code>svn mergeinfo --show-revs</code> funcionara.</p></li></ul></div><div class=paragraph><p>Con Git, necesitaremos usar diferentes estrategias para conseguir los mismos objetivos.
Este documento trata de definir las mejores prácticas para conseguir estos objetivos con Git cuando se mergean cambios de código fuente.
En general, tratamos de usar el soporte nativo de Git para conseguir los objetivos en lugar de forzar a realizar las prácticas construidas sobre el modelo de Subversion.</p></div><div class=paragraph><p>Una nota general: debido a las diferencias técnicas con Git, no utilizaremos los "merge commits" de Git (creados mediante <code>git merge</code>) en las ramas stable o releng.
En su lugar, cuando este documento habla de "merge commits", significa el commit original hecho en <code>main</code> que es replicado o "aterrizado" (landed) en una rama stable, o un commit de una rama stable que es replicado a una rama releng con alguna variación de <code>git cherry-pick</code>.</p></div></div><div class=sect3><h4 id=_encontrando_hashes_seleccionables_para_mfc>5.3.8. Encontrando Hashes Seleccionables para MFC<a class=anchor href=#_encontrando_hashes_seleccionables_para_mfc></a></h4><div class=paragraph><p>Git proporciona algo de soporte para esto mediante los comandos <code>git cherry</code> y <code>git log --cherry</code>. Estos comandos comparan los diffs en crudo de los commits (pero no otros metadatos como los mensajes de log) para determinar si dos commits son idénticos. Esto funciona bien cuando cada commit de <code>main</code> se lleva como un sólo commit a la rama stable, pero falla si múltiples commits de <code>main</code> se compactan juntos como un sólo commit en la rama stable. El proyecto utiliza mucho <code>git cherry-pick -x</code> preservando todas las líneas para evitar estas dificultades y funciona con herramientas automatizadas.</p></div></div><div class=sect3><h4 id=_estándares_para_los_mensajes_de_commit>5.3.9. Estándares para los mensajes de commit<a class=anchor href=#_estándares_para_los_mensajes_de_commit></a></h4><div class=sect4><h5 id=_marcar_mfcs>5.3.9.1. Marcar MFCs<a class=anchor href=#_marcar_mfcs></a></h5><div class=paragraph><p>El proyecto ha adoptado las siguientes prácticas para marcar MFCs:</p></div><div class=ulist><ul><li><p>Usa el flag <code>-x</code> con <code>git cherry-pick</code>. Esto añade una línea al mensaje de commit que incluye el hash del commit original cuando se hace el merge. Puesto que Git lo añade directamente, los committers no tienen que editar manualmente el log cuando hacen el merge.</p></li></ul></div><div class=paragraph><p>Cuando se mergean varios commits, mantén todas las líneas "cherry picked from".</p></div></div><div class=sect4><h5 id=_recortar_metadatos>5.3.9.2. ¿Recortar Metadatos?<a class=anchor href=#_recortar_metadatos></a></h5><div class=paragraph><p>Un área que no estaba documentada de forma clara con Subversion (ni con CVS) era cómo formatear los metadatos en los mensajes de log para los commits tipo MFC. ¿Debería incluir los metadatos del commit original sin modificar o se debería modificar para reflejar la información acerca del propio commit MFC?</p></div><div class=paragraph><p>Históricamente la práctica ha variado, aunque parte de la variación es por campo. Por ejemplo, MFCs relativos a un PR normalmente incluyen el campo PR en el MFC de forma que los commits MFC se incluyen en el log de autoría del sistema de reportes de error (bug tracker). Con otros campos está menos claro. Por ejemplo, Phabricator muestra la diferencia entre el último commit etiquetado a una revisión, de forma que incluir URLs de Phabricator reemplaza el commit principal con los commits "aterrizados". La lista de revisores tampoco está clara. Si un revisor ha aprobado un cambio a <code>main</code>, ¿significa eso que han aprobado el commit MFC? ¿Es cierto si el código es idéntico o con sólo cambios triviales? Claramente no es cierto para trabajos más extensivos. Incluso para código idéntico ¿qué pasa si el commit no tiene conflicto pero introduce un cambio en el ABI? Un revisor podría haber dado el visto bueno para un commit en <code>main</code> debido al rompimiento del ABI pero podría no aprobar el mergeado del mismo commit tal cual. Cada uno tiene que usar su mejor juicio hasta que acordemos unas directrices claras.</p></div><div class=paragraph><p>Para MFCs que están regulados por re@, se añaden nuevos campos de metadatos como la etiqueta Approved by para commits aprobados. Estos nuevos metadatos se tendrán que añadir con <code>git commit --amend</code> o similar después de que el commit original haya sido revisado y aprobado. También podríamos querer reservar algunos campos en los metadatos de los commtis MFC como las URLs de Phabricator para uso futuro por parte de re@.</p></div><div class=paragraph><p>Preservar los metadatos existentes proporciona un flujo de trabajo sencillo. Los desarrolladores usan <code>git cherry-pick-x</code> sin tener que editar el mensaje de log.</p></div><div class=paragraph><p>Si por el contrario escogemos ajustar los metadatos en los MFCs, los desarrolladores tendrán que editar los mensajes de log de forma explícita mediante el uso de <code>git cherry-pick --edit</code> o <code>git commit --amend</code>. Sin embargo, comparado con svn, al menos el mensaje de commit existente se puede precargar y los campos de metadatos se pueden añadir o eliminar sin tener que reescribir el mensaje de commit entero.</p></div><div class=paragraph><p>La conclusión es que los desarrolladores seguramente tengan que refinar los mensajes de commit para los MFCs que no sean triviales.</p></div></div></div></div><div class=sect2><h3 id=vendor-import-git>5.4. Importaciones Externas con Git<a class=anchor href=#vendor-import-git></a></h3><div class=paragraph><p>Esta sección describe en detalle el procedimiento para hacer importaciones de terceros con Git.</p></div><div class=sect3><h4 id=_convenciones_en_el_nombrado_de_ramas>5.4.1. Convenciones en el nombrado de ramas<a class=anchor href=#_convenciones_en_el_nombrado_de_ramas></a></h4><div class=paragraph><p>Todas las ramas de terceros y etiquetas comienzan con <code>vendor/</code>. Estas ramas y etiquetas son visibles por defecto.</p></div><div class=paragraph><p>[NOTE] ==== Este capítulo sigue la convención de que el origen <code>freebsd</code> es el nombre del origen del repositorio Git oficial de FreeBSD. Si usas otra convención, en los ejemplos de abajo reemplaza <code>freebsd</code> con el nombre que uses en su lugar. ====</p></div><div class=paragraph><p>Exploraremos un ejemplo para actualizar el mtree de NetBSD que está en nuestro árbol. La rama externa para esto es <code>vendor/NetBSD/mtree</code>.</p></div></div><div class=sect3><h4 id=_actualizando_una_importación_externa_antigua>5.4.2. Actualizando una importación externa antigua<a class=anchor href=#_actualizando_una_importación_externa_antigua></a></h4><div class=paragraph><p>Los árboles externos normalmente tienen sólo un subconjunto del software de terceros que es apropiado para FreeBSD. Estos árboles son muy pequeños en comparación con el árbol de FreeBSD. Los worktrees de Git son por lo tanto bastante pequeños y rápidos y el método preferido a usar. Asegúrate de que el directorio que escojas debajo (el <code>../mtree</code>) no existe.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% git worktree add ../mtree vendor/NetBSD/mtree</code></pre></div></div></div><div class=sect3><h4 id=_actualizar_las_fuentes_en_la_rama_vendor>5.4.3. Actualizar las Fuentes en la Rama Vendor<a class=anchor href=#_actualizar_las_fuentes_en_la_rama_vendor></a></h4><div class=paragraph><p>Prepara un árbol limpio, completo con las fuentes externas. Importa todo pero mergea sólo lo que es necesario.</p></div><div class=paragraph><p>Este ejemplo asume que las fuentes de NetBSD se han traído de su mirror de GitHub en <code>~/git/NetBSD</code>. Date cuenta de que "upstream" podría haber añadido o eliminado ficheros, por lo que queremos asegurarnos de que los borrados también se propagan. Normalmente <a class=package href=https://cgit.freebsd.org/ports/tree/net/rsync/>net/rsync</a> está instalado así que lo usaremos.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>cd</span> ../mtree
% rsync <span class=nt>-va</span> <span class=nt>--del</span> <span class=nt>--exclude</span><span class=o>=</span><span class=s2>&#34;.git&#34;</span> ~/git/NetBSD/usr.sbin/mtree/ <span class=nb>.</span>
% git add <span class=nt>-A</span>
% git status
...
% git diff <span class=nt>--staged</span>
...
% git commit <span class=nt>-m</span> <span class=s2>&#34;Vendor import of NetBSD&#39;s mtree at 2020-12-11&#34;</span>
<span class=o>[</span>vendor/NetBSD/mtree 8e7aa25fcf1] Vendor import of NetBSD<span class=s1>&#39;s mtree at 2020-12-11
 7 files changed, 114 insertions(+), 82 deletions(-)
% git tag -a vendor/NetBSD/mtree/20201211</span></code></pre></div></div><div class=paragraph><p>Nota: Ejecuto los comandos <code>git diff</code> y <code>git status</code> para asegurarme de que no hay nada raro.
También usé <code>-m</code> de forma ilustrativa, pero tú deberías componer un mensaje apropiado en un editor (usando una plantilla para el mensaje de commit).</p></div><div class=paragraph><p>También es importante crear una etiqueta anotada utilizando <code>git tag -a</code>, de lo contrario el push será rechazado.
Sólo se permite hacer push de etiquetas anotadas.
Las etiquetas anotadas te dan una oportunidad de introducir un mensaje de commit.
Introduce la versión que estás importando así como cualquier característica que resalte o arreglos que lleve la versión.</p></div></div><div class=sect3><h4 id=_actualizando_la_copia_de_freebsd>5.4.4. Actualizando la Copia de FreeBSD<a class=anchor href=#_actualizando_la_copia_de_freebsd></a></h4><div class=paragraph><p>En este momento puedes empujar la importación a <code>vendor</code> en nuestro propio repo.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% git push <span class=nt>--follow-tags</span> freebsd vendor/NetBSD/mtree</code></pre></div></div><div class=paragraph><p><code>--follow-tags</code> le dice a <code>git push</code> que también empuje las etiquetas asociadas con la revisión local de la que se ha hecho commit.</p></div></div><div class=sect3><h4 id=_actualizando_el_árbol_de_fuentes_de_freebsd>5.4.5. Actualizando el árbol de fuentes de FreeBSD<a class=anchor href=#_actualizando_el_árbol_de_fuentes_de_freebsd></a></h4><div class=paragraph><p>Ahora necesitas actualizar el mtree en FreeBSD. Las fuentes están en <code>contrib/mtree</code> ya que es software de terceros.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>cd</span> ../src % git subtree merge <span class=nt>-P</span> contrib/mtree vendor/NetBSD/mtree</code></pre></div></div><div class=paragraph><p>Esto generaría un commit merge para el subárbol <code>contrib/mtree</code> contra la rama local <code>vendor/NetBSD/mtree</code>.
Si hubiera conflictos, necesitarías arreglarlos antes de hacer el commit.
Incluye detalles en el mensaje de commit acerca de los cambios que se están mergeando.</p></div></div><div class=sect3><h4 id=_rebasando_to_cambio_contra_lo_último_del_árbol_de_fuentes_de_freebsd>5.4.6. Rebasando to cambio contra lo último del árbol de fuentes de FreeBSD<a class=anchor href=#_rebasando_to_cambio_contra_lo_último_del_árbol_de_fuentes_de_freebsd></a></h4><div class=paragraph><p>Puesto que la política actual no recomienda utilizar meges, si el <code>main</code> de FreeBSD remoto avanzó antes de que tuvieras oportunidad de hacer el push, tendrías que rehacer el merge.</p></div><div class=paragraph><p>Los <code>git rebase</code> o <code>git pull --rebase</code> habituales no saben cómo rebasar un commit tipo merge <strong>como un commit merge</strong>, así que tendrías que recrear el commit.</p></div><div class=paragraph><p>Se deberían seguir los siguientes pasos para facilitar recrear el commit tipo merge como si <code>git rebase --merge-commits</code> hubiese funcionado adecuadamente:</p></div><div class=ulist><ul><li><p>Muévete al directorio raíz del repositorio</p></li><li><p>Crea una rama <code>XXX</code> con el <strong>contenido</strong> del árbol mergeado.</p></li><li><p>Actualiza este lado de la rama <code>XXX</code> para mergearla y tenerla actualizada respecto a la rama <code>main</code> de FreeBSD.</p><div class=ulist><ul><li><p>En el peor caso, tendrías que resolver conflictos, si hubiera alguno, pero esto debería ser raro.</p></li><li><p>Resuelve los conflictos, y compacta varios commits en uno si es necesario (si no hay conflictos, no hay necesidad de compactar)</p></li></ul></div></li><li><p>Haz checkout de <code>main</code></p></li><li><p>crea una rama <code>YYY</code> (permite deshacer los cambios si algo va mal)</p></li><li><p>Rehaz el merge del subárbol</p></li><li><p>En lugar de resolver conflictos en el subárbol mergeado, haz un checkout del contenido de XXX encima de él.</p><div class=ulist><ul><li><p>El último <code>.</code> es importante, igual que lo es estar en el directorio raíz del repositorio.</p></li><li><p>En lugar de cambiar a la rama XXX, pone el contenido de XXX sobre el repositorio.</p></li></ul></div></li><li><p>Haz commit del repositorio con el mensaje de commit anterior (el ejemplo asume que sólo hay un merge en la rama XXX).</p></li><li><p>Asegúrate de que las ramas son iguales.</p></li><li><p>Haz las revisiones que necesites, incluyendo involucrar a otros si crees que es necesario.</p></li><li><p>Empuja el commit, si has 'perdido la carrera' otra vez, simplemente haz otra vez estos pasos (lee más abajo para una receta)</p></li><li><p>Borra las ramas una vez que el commit está en el repositorio. Son desechables.</p></li></ul></div><div class=paragraph><p>Los comandos que uno usaría, siguiendo el ejemplo de mtree, sería como esto (el símbolo <code>#</code> marca un comentario para ayudar y enlazar los comandos con las descripciones de arriba):</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>cd</span> ../src			<span class=c># cambiar a la raíz del árbol</span>
% git checkout <span class=nt>-b</span> XXX		<span class=c># crea la rama XXX de usar y tirar para hacer el merge</span>
% git fetch freebsd		<span class=c># Obtiene los datos de upstream</span>
% git merge freebsd/main	<span class=c># Mergea los cambios y resuelve conflictos</span>
% git checkout <span class=nt>-b</span> YYY freebsd/main <span class=c># Crea una nueva rama de usar y tirar YYY para rehacer</span>
% git subtree merge <span class=nt>-P</span> contrib/mtree vendor/NetBSD/mtree <span class=c># Redo subtree merge</span>
% git checkout XXX <span class=nb>.</span>		<span class=c># La rama XXX tiene la resolución del conflicto</span>
% git commit <span class=nt>-c</span> XXX~1		<span class=c># -c reutiliza el mensaje de commit del commit anterior al rebase</span>
% git diff XXX YYY		<span class=c># Debería estar vacío</span>
% git show YYY			<span class=c># Sólo debería tener los cambios que quieres, y ser un commit merge desde la rama del vendor</span></code></pre></div></div><div class=paragraph><p>Nota: si algo va mal con el commit, puedes resetear la rama <code>YYY</code> para comenzar de nuev volviendo a ejecutar el comando checkout que la creó con -B :</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% git checkout <span class=nt>-B</span> YYY freebsd/main <span class=c># Crea una nueva rama YYY de usar y tirar si empezar desde cero es más sencillo</span></code></pre></div></div></div><div class=sect3><h4 id=_empujando_los_cambios>5.4.7. Empujando los cambios<a class=anchor href=#_empujando_los_cambios></a></h4><div class=paragraph><p>Una vez que crees que tienes un conjunto de diferencias que es bueno, puedes empujarlo a un fork de GitHub o Gitlab para que otros lo revisen. Una cosa buena de Git es que te permite publicar borradores de tu trabajo para que otros lo revisen. Mientras que Phabricator es bueno para revisión de contenido, publicar una rama externa actualizada y los commits tipo merge permite a otros comprobar los detalles tal y como aparecerán eventualmente en el repositorio.</p></div><div class=paragraph><p>Después de la revisión, cuando estás seguro de que es un buen cambio, puedes empujarlo al repo de FreeBSD:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% git push freebsd YYY:main	<span class=c># put the commit on upstream&#39;s &#39;main&#39; branch % git branch -D XXX		# Throw away the throw-a-way branches. % git branch -D YYY</span></code></pre></div></div><div class=paragraph><p>Nota: He usado <code>XXX</code> y <code>YYY</code> para que sea obvio que son nombres horribles que no deberían abandonar tu máquina.
Si usas esos nombres para otro trabajo, necesitarás escoger nombres diferentes, o arriesgarte a perder el otro trabajo.
No hay nada mágico sobre estos nombres.
Upstream no te permitirá empujarlos, pero de todas formas, por favor presta atención a los comandos exactos de arriba.
Algunos comandos usan sintaxis que es algo diferente respecto de los casos típicos y ese comportamiento diferente es crítico para que esta receta funcione.</p></div></div><div class=sect3><h4 id=_como_rehacer_cosas_si_es_necesario>5.4.8. Como rehacer cosas si es necesario<a class=anchor href=#_como_rehacer_cosas_si_es_necesario></a></h4><div class=paragraph><p>Si has intentado empujar los cambios de la sección anterior y ha fallado, entonces deberías hacer lo siguiente para 'rehacer' las cosas. Esta secuencia mantiene el commit cno el mensaje de commit simpre en XXX~1 para que sea más fácil.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% git checkout <span class=nt>-B</span> XXX YYY	<span class=c># recreate that throw-away-branch XXX and switch to it % git merge freebsd/main	# Merge the changes and resolve conflicts % git checkout -B YYY freebsd/main # Recreate new throw-away YYY branch for redo % git subtree merge -P contrib/mtree vendor/NetBSD/mtree # Redo subtree merge % git checkout XXX .		# XXX branch has the conflict resolution % git commit -c XXX~1		# -c reuses the commit message from commit before rebase</span></code></pre></div></div><div class=paragraph><p>Después haz el checkout como arriba y empuja los cambios como arriba cuando estén listos.</p></div></div></div><div class=sect2><h3 id=_crear_una_nueva_rama_externa>5.5. Crear una nueva rama externa<a class=anchor href=#_crear_una_nueva_rama_externa></a></h3><div class=paragraph><p>Hay varias formas de crear una nueva rama externa. La forma recomendada es crear un nuevo repositorio y después mergearlo con FreeBSD. Supongamos que se importa <code>glorbnitz</code> en el árbol de FreeBSD, release 3.1415. Por simplicidad, no recortaremos esta release. Es un simple comando de usuario que pone el dispositivo nitz en diferentes estados mágicos glorb y es suficientemente pequeño como para que recortarlo no ahorre demasiado.</p></div><div class=sect3><h4 id=_crear_el_repo>5.5.1. Crear el repo<a class=anchor href=#_crear_el_repo></a></h4><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>cd</span> /some/where % <span class=nb>mkdir </span>glorbnitz % <span class=nb>cd </span>glorbnitz % git init % git checkout <span class=nt>-b</span> vendor/glorbnitz</code></pre></div></div><div class=paragraph><p>En este momento, tienes un nuevo repo, donde irán todos los commits de la rama <code>vendor/glorbnitz</code>.</p></div><div class=paragraph><p>Los expertos en Git pueden hacer esto directamente en su clon de FreeBSD usando <code>git checkout --orphan vendor/glorbnitz</code> si así se sienten más cómodos.</p></div></div><div class=sect3><h4 id=_copia_las_fuentes>5.5.2. Copia las fuentes<a class=anchor href=#_copia_las_fuentes></a></h4><div class=paragraph><p>Puesto que es una nueva importación, puedes simplemente usar cp, o tar o incluso rsync como se muestra arriba. Y añadiremos todo, asumiendo que no hay ficheros dot.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>cp</span> <span class=nt>-r</span> ~/glorbnitz/<span class=k>*</span> <span class=nb>.</span> % git add <span class=k>*</span></code></pre></div></div><div class=paragraph><p>En este punto, deberías tener una copia prístina de glorbnitz lista para hacer commit.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% git commit <span class=nt>-m</span> <span class=s2>&#34;Import GlorbNitz frobnosticator revision 3.1415&#34;</span></code></pre></div></div><div class=paragraph><p>Como arriba, he usado <code>-m</code> por simplicidad, pero seguramente deberías crear un mensaje de commit que explica qué es un Glorb y por qué usarías un Nitz para conseguirlo.
No todo el mundo lo sabrá así que para tu commit de verdad, deberías seguir la sección <a href=#commit-log-message>mensaje de log del commit</a> en lugar de emular el estilo corto utilizado aquí.</p></div></div><div class=sect3><h4 id=_ahora_importa_en_nuestro_repositorio>5.5.3. Ahora importa en nuestro repositorio<a class=anchor href=#_ahora_importa_en_nuestro_repositorio></a></h4><div class=paragraph><p>Ahora necesitas importar la rama en nuestro repositorio.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>cd</span> /path/to/freebsd/repo/src % git remote add glorbnitz /some/where/glorbnitz % git fetch glorbnitz vendor/glorbnitz</code></pre></div></div><div class=paragraph><p>Fíjate que la rama vendor/glorbnitz está en el repo. En este momento puedes borrar <code>/some/where/glorbnitz</code> si quieres.
Ha cumplido su labor.</p></div></div><div class=sect3><h4 id=_etiquetas_y_push>5.5.4. Etiquetas y push<a class=anchor href=#_etiquetas_y_push></a></h4><div class=paragraph><p>Los pasos desde aquí en adelante son básicamente los mismos que en el caso de la actualización de una rama externa, aunque sin el paso de actualizar la rama externa.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% git worktree add ../glorbnitz vendor/glorbnitz % <span class=nb>cd</span> ../glorbnitz % git tag <span class=nt>--annotate</span> vendor/glorbnitz/3.1415 <span class=c># Make sure the commit is good with &#34;git show&#34; % git push --follow-tags freebsd vendor/glorbnitz</span></code></pre></div></div><div class=paragraph><p>Por 'bueno' nos referimos a:</p></div><div class="olist arabic"><ol class=arabic><li><p>Todos los ficheros están presentes</p></li><li><p>Ninguno de los ficheros erróneos está presente</p></li><li><p>La rama vendor apunta a algo que tiene sentido</p></li><li><p>La etiqueta tienen buena pinta, y está anotada</p></li><li><p>El mensaje de commit para la etiqueta tiene un resumen con las novedades respecto de la última etiqueta</p></li></ol></div></div><div class=sect3><h4 id=_momento_de_mergear_finalmente_en_el_árbol_base>5.5.5. Momento de mergear finalmente en el árbol base<a class=anchor href=#_momento_de_mergear_finalmente_en_el_árbol_base></a></h4><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>cd</span> ../src
% git subtree add <span class=nt>-P</span> contrib/glorbnitz vendor/glorbnitz
<span class=c># Make sure the commit is good with &#34;git show&#34;</span>
% git commit <span class=nt>--amend</span>   <span class=c># one last sanity check on commit message</span>
% git push freebsd</code></pre></div></div><div class=paragraph><p>Aquí 'bueno' significa:</p></div><div class="olist arabic"><ol class=arabic><li><p>Todos los ficheros correctos, y ninguno de los incorrectos, se mergearon en contrib/glorbnitz.</p></li><li><p>No hay otros cambios en el árbol.</p></li><li><p>Los mensajes de commit están <a href=#commit-log-message>bien</a>. Debería contener un resumen de lo que ha cambiado desde el último merge a la rama <code>main</code> de FreeBSD así como cualquier problema.</p></li><li><p>Se debería actualizar UPDATING si hay algo que reseñar, como cambios visibles por el usuario, preocupaciones sobre la actualización, etc.</p></li></ol></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Todavía no hemos conectado <code>glorbnitz</code> a la construcción.
Hacerlo es específico al software que se importa y está fuera del alcance de este tutorial.</p></div></td></tr></tbody></table></div><div class=sect4><h5 id=_mantenerse_actualizado>5.5.5.1. Mantenerse actualizado<a class=anchor href=#_mantenerse_actualizado></a></h5><div class=paragraph><p>El tiempo pasa. Es momento de actualizar el árbol con los últimos cambios. Cuando haces un checkout de <code>main</code> asegúrate de que no tienes diferencias. Es mucho más fácil hacer commit de esos cambios en una rama (o utilizar <code>git stash</code>) antes de hacer lo siguiente.</p></div><div class=paragraph><p>Si estás acostumbrado a <code>git pull</code> recomendamos encarecidamente el uso de la opción <code>--ff-only</code> y además establecerla como la opción por defecto. De forma alternativ, <code>git pull --rebase</code> es útil si tienes cambios guardados en la rama <code>main</code>.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% git config <span class=nt>--global</span> pull.ff only</code></pre></div></div><div class=paragraph><p>Podrías necesitar omitir el --global si quieres que esta configuración sólo aplique en este repositorio.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>cd </span>freebsd-src % git checkout main % git pull <span class=o>(</span><span class=nt>--ff-only</span>|--rebase<span class=o>)</span></code></pre></div></div><div class=paragraph><p>Hay un problema habitual, que la combinación del comando <code>git pull</code> intentará hacer un merge, que algunas veces creará un commit de tipo merge que no existía antes.
Esto puede ser difícil de arreglar.</p></div><div class=paragraph><p>La forma larga también se recomienda.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>cd </span>freebsd-src % git checkout main % git fetch freebsd % git merge <span class=nt>--ff-only</span> freebsd/main</code></pre></div></div><div class=paragraph><p>Estos comandos restauran tu árbol a la rama <code>main</code> y después lo actualizan desde donde hiciste el pull originalmente.
Es importante cambiarse a <code>main</code> antes de hacer esto de forma que avance.
Ahora es momento de avanzar los cambios:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% git rebase <span class=nt>-i</span> main working</code></pre></div></div><div class=paragraph><p>Esto traerá un pantalla interactiva para cambiar los valores por defecto.
Por ahora, simplemente sal del editor.
Todo debería aplicar.
Si no, necesitarás resolver los diffs.
<a href=https://docs.github.com/en/free-pro-team@latest/github/using-git/resolving-merge-conflicts-after-a-git-rebase>Este documento de github</a> te puede ayudar en el proceso.</p></div></div><div class=sect4><h5 id=git-push-upstream>5.5.5.2. Momento de empujar los cambios<a class=anchor href=#git-push-upstream></a></h5><div class=paragraph><p>Primero, asegúrate de que la URL de push está correctamente configurada para el repositorio remoto.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% git remote set-url <span class=nt>--push</span> freebsd ssh://git@gitrepo.freebsd.org/src.git</code></pre></div></div><div class=paragraph><p>Después, verifica que el usuario y el email están correctamente configurados.
Requerimos que coincidan exactamente con la entrada del fichero passwd del clúster de FreeBSD.</p></div><div class=paragraph><p>Usa</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>freefall% gen-gitconfig.sh</code></pre></div></div><div class=paragraph><p>en freefall.freebsd.org para obtener un texto que puedes usar directamente, asumiendo que /usr/local/bin está en el PATH.</p></div><div class=paragraph><p>El comando de abajo integra la rama <code>working</code> en la línea principal.
Es importante que filtres tus cambios para que sean justo lo que quieres en el repo de fuentes de FreeBSD antes de hacer esto.
Esta sintaxis empuja la rama <code>working</code> a <code>main</code>, avanzando la rama <code>main</code>.
Sólo podrás hacer esto si resulta en un cambio lineal a <code>main</code>(es decir, no merges).</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% git push freebsd working:main</code></pre></div></div><div class=paragraph><p>Si se rechaza tu push debido a que perdiste una carrera, haz un rebase de tu rama antes de intentarlo de nuevo:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% git checkout working % git fetch freebsd % git rebase freebsd/main % git push freebsd working:main</code></pre></div></div></div><div class=sect4><h5 id=git-push-upstream-alt>5.5.5.3. Momento de empujar los cambios (alternativa)<a class=anchor href=#git-push-upstream-alt></a></h5><div class=paragraph><p>Algunas personas encuentran más fácil mergear sus cambios a su <code>main</code> local antes de empujarlos al repositorio remoto. También <code>git arc stage</code> mueve los cambios de una rama al <code>main</code> local cuando necesitas hacer un subconjunto de una rama. Las instrucciones son similares a las de la sección anterior: [source,shell]</p></div><div class=literalblock><div class=content><pre>% git checkout main % git merge --ff-only `working` % git push freebsd</pre></div></div><div class=paragraph><p>Si pierdes la carrera, inténtalo de nuevo con</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% git pull <span class=nt>--rebase</span> % git push freebsd</code></pre></div></div><div class=paragraph><p>Estos comandos recuperarán el <code>freebsd/main</code> más reciente y después rebasará los cambios del <code>main</code> local encima, que es lo que quieres cuando pierdes una carrera por el commit.
Nota: integrar commits de ramas externas no funcionará con esta técnica.</p></div></div><div class=sect4><h5 id=_encontrar_la_revisión_de_subversion>5.5.5.4. Encontrar la Revisión de Subversion<a class=anchor href=#_encontrar_la_revisión_de_subversion></a></h5><div class=paragraph><p>Tendrás que asegurarte de que has recuperado las notas (lee <a href=#git-mini-daily-use>Uso diario</a> para más detalles). Una vez que las tengas, las notas se mostrarán el comando git log de la siguiente forma:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% git log</code></pre></div></div><div class=paragraph><p>Si tienes una versión específica en mente, puedes utilizar esto:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% git log <span class=nt>--grep</span> <span class=nv>revision</span><span class=o>=</span>XXXX</code></pre></div></div><div class=paragraph><p>para encontrar la revisión específica.
El número hexadecimal después de 'commit' es el hash que puedes usar para referirte a este commit.</p></div></div></div></div><div class=sect2><h3 id=git-faq>5.6. Git FAQ<a class=anchor href=#git-faq></a></h3><div class=paragraph><p>Esta sección proporciona un número de respuestas para usuarios y desarrolladores a preguntas que suelen surgir a menudo.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Usamos la convención habitual de tener el origen del repositorio de FreeBSD en 'freebsd' en lugar del 'origin' por defecto para permitir que la gente use ese para sus propios desarrollo y para minimizar los pushes "ooops" al repositorio incorrecto.</p></div></td></tr></tbody></table></div><div class=sect3><h4 id=_usuarios>5.6.1. Usuarios<a class=anchor href=#_usuarios></a></h4><div class=sect4><h5 id=_cómo_puedo_monitorizar_current_y_stable_con_una_sola_copia_del_repositorio>5.6.1.1. Cómo puedo monitorizar -current y -stable con una sola copia del repositorio?<a class=anchor href=#_cómo_puedo_monitorizar_current_y_stable_con_una_sola_copia_del_repositorio></a></h5><div class=paragraph><p><strong>Q:</strong> Aunque el espacio en disco no es un asunto importante, es más eficiente usar sólo una copia del repositorio.
Con SVN podía tener varios árboles del mismo repositorio.
¿Cómo hago esto con Git?</p></div><div class=paragraph><p><strong>A:</strong> Puedes usar worktrees.
Hay varias formas de hacer esto, pero la más sencilla es utilizar un clone para monitorizar -current, y un worktree para hacer lo mismo con las releases stables.
Aunque usar un 'repositorio desnudo' se ha propuesto como una forma de lidiar con esto, es más complicado y no se documentará aquí.</p></div><div class=paragraph><p>Primero, necesitas un clon de un repositorio de FreeBSD, mostrado aquí en <code>freebsd-current</code> para reducir la confusión.
$URL es el mirror que mejor que funcione:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% git clone <span class=nt>-o</span> freebsd <span class=nt>--config</span> remote.freebsd.fetch<span class=o>=</span><span class=s1>&#39;+refs/notes/*:refs/notes/*&#39;</span> <span class=nv>$URL</span> freebsd-current</code></pre></div></div><div class=paragraph><p>que una vez clonado, puedes simplemente crear un worktree a partir de él:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>cd </span>freebsd-current % git worktree add ../freebsd-stable-12 stable/12</code></pre></div></div><div class=paragraph><p>esto se traerá <code>stable/12</code> a un directorio llamado <code>freebsd-stable-12</code> que es un análogo al directorio <code>freebsd-current</code>.
Una vez creado se actualiza de forma similar a como cabría esperar:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>cd </span>freebsd-current % git checkout main % git pull <span class=nt>--ff-only</span> <span class=c># changes from upstream now local and current tree updated % cd ../freebsd-stable-12 % git merge --ff-only freebsd/stable/12 # now your stable/12 is up to date too</span></code></pre></div></div><div class=paragraph><p>Recomiendo usar <code>--ff-only</code> porque es más seguro y evita que te metas accidentalmente en una 'pesadilla de integraciones' donde tienes un cambio extra en tu árbol, forzándote a una integración complicada en lugar de hacer uno sencillo.</p></div><div class=paragraph><p>Aquí hay <a href=https://adventurist.me/posts/00296>un buen texto</a> que tiene más detalles.</p></div></div></div><div class=sect3><h4 id=_desarrolladores>5.6.2. Desarrolladores<a class=anchor href=#_desarrolladores></a></h4><div class=sect4><h5 id=_ooops_he_hecho_commit_en_main_en_lugar_de_en_otra_rama>5.6.2.1. ¡Ooops! He hecho commit en <code>main</code> en lugar de en otra rama.<a class=anchor href=#_ooops_he_hecho_commit_en_main_en_lugar_de_en_otra_rama></a></h5><div class=paragraph><p><strong>Q:</strong> De vez en cuando meto la pata y hago un commit en <code>main</code> en lugar de una rama. ¿Qué hago?</p></div><div class=paragraph><p><strong>A:</strong> Primero, que no te entre el pánico.</p></div><div class=paragraph><p>Segundo, no hagas push.
De hecho, puedes arreglar casi cualquier cosa si no has hecho push.
Todas las respuestas en esta sección asumen que no se ha hecho push.</p></div><div class=paragraph><p>La siguiente respuesta asume que has hecho commit en <code>main</code> y quieres crear una rama llamada <code>issue</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% git branch issue                <span class=c># Create the &#39;issue&#39; branch</span>
% git reset <span class=nt>--hard</span> freebsd/main   <span class=c># Reset &#39;main&#39; back to the official tip</span>
% git checkout issue              <span class=c># Back to where you were</span></code></pre></div></div></div><div class=sect4><h5 id=_ooops_he_hecho_commit_de_algo_en_la_rama_equivocada>5.6.2.2. ¡Ooops! ¡He hecho commit de algo en la rama equivocada!<a class=anchor href=#_ooops_he_hecho_commit_de_algo_en_la_rama_equivocada></a></h5><div class=paragraph><p><strong>Q:</strong> Estaba trabajando en una característica en la rama <code>wilma</code>, pero accidentalmente he hecho commit de un cambio relacionado con la rama <code>fred</code> en la rama <code>wilma</code>.
¿Qué hago?</p></div><div class=paragraph><p><strong>A:</strong> La respuesta es similar a la anterior pero escogiendo cambios (cherry picking).
Se asume que sólo hay un commit en wilma, pero lo generalizaremos a situaciones más complicadas.
También se asume que es el último commit en wilma (por lo tanto se usa wilma en el comando <code>git cherry-pick</code>), pero también se puede generalizar.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># We&#39;re on branch wilma % git checkout fred		# move to fred branch % git cherry-pick wilma		# copy the misplaced commit % git checkout wilma		# go back to wilma branch % git reset --hard HEAD^	# move what wilma refers to back 1 commit</span></code></pre></div></div><div class=paragraph><p>Los expertos en Git primero rebobinarían la rama wilma en 1 commit, cambiarían a la rama fred y después usarían <code>git reflog</code> para ver cuál era el commit borrado para poder hacer cherry-pick sobre él.</p></div><div class=paragraph><p><strong>Q:</strong> Pero ¿Y si quiero hacer commit de unos cuantos cambios a <code>main</code>, pero dejar el resto en <code>wilma</code> por algún motivo?</p></div><div class=paragraph><p><strong>A:</strong> La misma técnica de arriba funciona si quieres llevar partes de la rama en la que estás trabajando a <code>main</code> antes de que el resto de la rama está listo (digamos que has visto un error ortográfico no relacionado, o has arreglado un bug puntual).
Puedes usar seleccionar esos cambios y llevarlos a <code>main</code>, luego empuja al repositorio padre.
Una vez hecho esto, limpiar no podría ser más fácil: simplemente <code>git rebase -i</code>.
Git se dará cuenta de que has hecho esto y omitirá los cambios comunes automáticamente (incluso si tienes que cambiar el mensaje de commit o modificar el commit ligeramente).
No hay necesidad de cambiar de nuevo a wilma para ajustarlo: ¡simplemente rebásalo!</p></div><div class=paragraph><p><strong>Q:</strong> Quiero separar algunos cambios de la rama <code>wilma</code> y llevarlos a una rama <code>fred</code></p></div><div class=paragraph><p><strong>A:</strong> La respuesta más general sería la misma que previamente.
Crearías la rama <code>fred</code>, escogerías los cambios que quieres de <code>wilma</code> uno a uno, luego rebasa <code>wilma</code> para eliminar esos cambios que has seleccionado.
<code>git rebase -i main wilma</code> te llevará a un editor, luego elimina las líneas <code>pick</code> que se corresponden con los cambios que has llevado a <code>fred</code>.
Si todo va bien y no hay conflictos, has terminado.
Si no, necesitarás resolver los conflictos sobre la marcha.</p></div><div class=paragraph><p>La otra forma de hacer esto sería hacer un checkout de <code>wilma</code> y luego crear la rama <code>fred</code> apuntando al mismo punto del árbol.
Después puedes hacer <code>git rebase -i</code> en ambas ramas, seleccionando los cambios que quieres en <code>fred</code> o <code>wilma</code> manteniendo las líneas "pick" y eliminando el resto en el editor.
Algunas personas crearían una etiqueta/rama llamada <code>pre-split</code> antes de empezar por si algo va mal.
Puedes deshacerlo con la siguiente secuencia:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% git checkout pre-split	<span class=c># Go back % git branch -D fred		# delete the fred branch % git checkout -B wilma		# reset the wilma branch % git branch -d pre-split	# Pretend it didn&#39;t happen</span></code></pre></div></div><div class=paragraph><p>El último paso es opcional.
Si vas a intentar hacer el split de nuevo, lo omitirías.</p></div><div class=paragraph><p><strong>Q:</strong> Pero lo he hecho todo como he leído que se hacía y no he visto tu consejo al final para crear una rama y ahora <code>fred</code> y <code>wilma</code> están hechas un lío.
¿Cómo sé cuál era el estado de <code>wilma</code> antes de que empezara?
No sé cuántas veces he movido las cosas de sitio.</p></div><div class=paragraph><p><strong>A:</strong> No todo está perdido. Puedes averiguarlo, siempre que no haya pasado mucho tiempo o haya habido muchos commits (cientos).</p></div><div class=paragraph><p>Creé una rama wilma e hice commit de un par de cosas, luego decidí que quería dividirla en fred y wilma.
No pasó nada raro cuando lo hice, pero digamos que hubiera sido así.
La forma de ver lo que has hecho es con <code>git reflog</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% git reflog 6ff9c25 <span class=o>(</span>HEAD -&gt; wilma<span class=o>)</span> HEAD@<span class=o>{</span>0<span class=o>}</span>: rebase <span class=nt>-i</span> <span class=o>(</span>finish<span class=o>)</span>: returning to refs/heads/wilma 6ff9c25 <span class=o>(</span>HEAD -&gt; wilma<span class=o>)</span> HEAD@<span class=o>{</span>1<span class=o>}</span>: rebase <span class=nt>-i</span> <span class=o>(</span>start<span class=o>)</span>: checkout main 869cbd3 HEAD@<span class=o>{</span>2<span class=o>}</span>: rebase <span class=nt>-i</span> <span class=o>(</span>start<span class=o>)</span>: checkout wilma a6a5094 <span class=o>(</span>fred<span class=o>)</span> HEAD@<span class=o>{</span>3<span class=o>}</span>: rebase <span class=nt>-i</span> <span class=o>(</span>finish<span class=o>)</span>: returning to refs/heads/fred a6a5094 <span class=o>(</span>fred<span class=o>)</span> HEAD@<span class=o>{</span>4<span class=o>}</span>: rebase <span class=nt>-i</span> <span class=o>(</span>pick<span class=o>)</span>: Encourage contributions 1ccd109 <span class=o>(</span>freebsd/main, main<span class=o>)</span> HEAD@<span class=o>{</span>5<span class=o>}</span>: rebase <span class=nt>-i</span> <span class=o>(</span>start<span class=o>)</span>: checkout main 869cbd3 HEAD@<span class=o>{</span>6<span class=o>}</span>: rebase <span class=nt>-i</span> <span class=o>(</span>start<span class=o>)</span>: checkout fred 869cbd3 HEAD@<span class=o>{</span>7<span class=o>}</span>: checkout: moving from wilma to fred 869cbd3 HEAD@<span class=o>{</span>8<span class=o>}</span>: commit: Encourage contributions ... %</code></pre></div></div><div class=paragraph><p>Aquí vemos los cambios que he hecho.
Puedes utilizarlo para averiguar dónde han empezado a ir mal las cosas.
Señalaré unas pocosas cosas.
La primera es que HEAD@{X} es algo relacionado con los commits de forma que lo puedes usar como argumento para algunos comandos.
Aunque si ese comando hace commit de algo en el repositorio, la X cambia.
También puedes usar el hash (primera columna).</p></div><div class=paragraph><p>Luego, 'Encourage contributions' fue el último commit que hice en <code>wilma</code> antes de que decidiera separar las ramas.
Puedes ver ahí el mismo hash que cuando creé la rama <code>fred</code>.
Empecé rebasando <code>fred</code> y puedes ver el 'start', cada paso y el 'finish' para ese proceso.
Aunque no sea necesario ahora, puedes averiguar exactamente lo que pasó.
Afortunadamente, para arreglar esto, puedes seguir los pasos de la respuesta anterior pero con el hash <code>869cbd3</code> en lugar de <code>pre-split</code>.
Aunque puede parecer un poco verboso, es fácil de recordar ya que haces una cosa cada vez.
También puedes apilar:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% git checkout <span class=nt>-B</span> wilma 869cbd3 % git branch <span class=nt>-D</span> fred</code></pre></div></div><div class=paragraph><p>y ya estás listo para probar de nuevo.
El 'checkout -B' con el hash combina hacer checkout y crear una rama.
El -B en lugar de -b fuerza el movimiento de una rama pre-existente.
De cualquiera de las maneras funciona, lo que está genial (y también es horrible) en Git.
Un motivo por el que suelo usar <code>git checkout -B xxxx hash</code> en lugar de hacer checkout del hash y después crear / mover la rama es simplemente para evitar el mensaje ligeramente angustioso sobre los 'detached heads':</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% git checkout 869cbd3 M	faq.md Note: checking out <span class=s1>&#39;869cbd3&#39;</span><span class=nb>.</span>

You are <span class=k>in</span> <span class=s1>&#39;detached HEAD&#39;</span> state. You can look around, make experimental changes and commit them, and you can discard any commits you make <span class=k>in </span>this state without impacting any branches by performing another checkout.

If you want to create a new branch to retain commits you create, you may <span class=k>do </span>so <span class=o>(</span>now or later<span class=o>)</span> by using <span class=nt>-b</span> with the checkout <span class=nb>command </span>again. Example:

  git checkout <span class=nt>-b</span> &lt;new-branch-name&gt;

HEAD is now at 869cbd3 Encourage contributions % git checkout <span class=nt>-B</span> wilma</code></pre></div></div><div class=paragraph><p>esto produce el mismo efecto, pero tengo que leer mucho más y las cabezas cortadas (detached heads) no es una imagen que me guste contemplar.</p></div></div><div class=sect4><h5 id=_ooops_he_hecho_un_git_pull_y_he_creado_un_commit_tipo_merge_qué_hago>5.6.2.3. ¡Ooops! He hecho un <code>git pull</code> y he creado un commit tipo merge, ¿qué hago?<a class=anchor href=#_ooops_he_hecho_un_git_pull_y_he_creado_un_commit_tipo_merge_qué_hago></a></h5><div class=paragraph><p><strong>Q:</strong> Estaba con el piloto automático y he hecho <code>git pull</code> desde mi árbol de desarrollo y eso ha creado un commit tipo merge en la rama <code>main</code>.
¿Cómo lo recupero?</p></div><div class=paragraph><p><strong>A:</strong> Esto puede pasar cuando invocas el pull con un checkout de tu rama de desarrollo.</p></div><div class=paragraph><p>Justo después del pull, tendrás en el checkout el nuevo commit tipo merge.
Git soporta la sintaxis <code>HEAD^#</code> para examinar los padres de un commit tipo merge:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>git log <span class=nt>--oneline</span> HEAD^1   <span class=c># Look at the first parent&#39;s commits</span>
git log <span class=nt>--oneline</span> HEAD^2   <span class=c># Look at the second parent&#39;s commits</span></code></pre></div></div><div class=paragraph><p>A partir de esos logs, puedes identificar fácilmente qué commit es tu trabajo de desarrollo.
Después simplemente restaura tu rama al <code>HEAD^#</code> correspondiente:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>git reset <span class=nt>--hard</span> HEAD^2</code></pre></div></div><div class=paragraph><p><strong>Q:</strong> Pero también necesito arreglar mi rama <code>main</code>. ¿Cómo lo hago?</p></div><div class=paragraph><p><strong>A:</strong> Git controla las ramas del repositorio remoto en el espacio de nombres <code>freebsd/</code>.
Para arreglar tu rama <code>main</code>, simplemente ponla apuntando al <code>main</code> de tu remoto:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>git branch <span class=nt>-f</span> main freebsd/main</code></pre></div></div><div class=paragraph><p>No hay nada mágico en las ramas de Git: tan sólo son etiquetas en un grafo que se mueven automáticamente hacia adelante cuando se hacen commits.
Así que lo de arriba funciona porque tan sólo estamos moviendo una etiqueta.
Debido a ello, no hay metadatos de la rama que se necesiten preservar.</p></div></div><div class=sect4><h5 id=_mezclando_y_combinando_ramas>5.6.2.4. Mezclando y combinando ramas<a class=anchor href=#_mezclando_y_combinando_ramas></a></h5><div class=paragraph><p><strong>Q:</strong> Digamos que tengo dos ramas <code>worker</code> y <code>async</code> que me gustaría combinar en una rama llamada <code>feature</code>
a la vez que mantengo los commits de ambas.</p></div><div class=paragraph><p><strong>A:</strong> Esto es trabajo para cherry pick.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% git checkout worker % git checkout <span class=nt>-b</span> feature	<span class=c># create a new branch % git cherry-pick main..async	# bring in the changes</span></code></pre></div></div><div class=paragraph><p>Ahora tienes una nueva rama llamada <code>feature</code>.
Esta rama combina commits de ambas ramas.
Puedes filtrar más utilizando <code>git rebase</code>.</p></div><div class=paragraph><p><strong>Q:</strong> Tengo una rama llamada <code>driver</code> y me gustaría partirla en <code>kernel</code> y <code>userland</code> de forma que pueda hacerlas evolucionar por separado y hacer commit en cada rama cuando estén listas.</p></div><div class=paragraph><p><strong>A:</strong> Esto necesita un poco de trabajo preparatorio, pero <code>git rebase</code> hará
todo el trabajo duro.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% git checkout driver		<span class=c># Checkout the driver % git checkout -b kernel	# Create kernel branch % git checkout -b userland	# Create userland branch</span></code></pre></div></div><div class=paragraph><p>Ahora tienes dos ramas idénticas.
Es momento de separar los commits.
Asumiremos inicialmente que todos los commits de <code>driver</code> van en las ramas <code>kernel</code> o en <code>userland</code> pero no en ambas.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% git rebase <span class=nt>-i</span> main kernel</code></pre></div></div><div class=paragraph><p>y simplemente incluye los cambios que quieres (con una línea 'p' o 'pick') y borra los commits que no quieres (da miedo, pero si sucede lo peor, puedes tirar todo esto a la basura y empezar de nuevo con la rama <code>driver</code> ya que todavía no la has movido).</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% git rebase <span class=nt>-i</span> main userland</code></pre></div></div><div class=paragraph><p>y haz lo mismo que hiciste con la rama <code>kernel</code>.</p></div><div class=paragraph><p><strong>Q:</strong> ¡Oh, genial! Seguí las instrucciones de arriba y me olvidé de hacer commit en la rama <code>kernel</code>.
¿Cómo lo arreglo?</p></div><div class=paragraph><p><strong>A:</strong> Puedes usar la rama <code>driver</code> para encontrar el hash del commit que falta y
seleccionarlo con cherry pick.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% git checkout kernel % git log driver % git cherry-pick <span class=nv>$HASH</span></code></pre></div></div><div class=paragraph><p><strong>Q:</strong> OK. Tengo la misma situación que arriba, pero mis commits están todos mezclados.
Necesito que partes de un commit vayan a una rama y el resto a otra.
De hecho, tengo varias.
Tu método basado en rebase suena complicado.</p></div><div class=paragraph><p><strong>A:</strong> En esta situación, lo mejor sería filtrar la rama original para separar los commits
y luego usar el método descrito arriba para separar las ramas.</p></div><div class=paragraph><p>Asumamos que sólo hay un commit con un árbol limpio.
Puedes usar <code>git rebase</code> con una línea <code>edit</code> o puedes usarlo con el commit en el extremo (tip).
Los pasos son los mismos de cualquiera de las dos formas.
Lo primero que tenemos que hacer es echar atrás un commit mientras dejamos los cambios en el árbol sin hacer commit:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% git reset HEAD^</code></pre></div></div><div class=paragraph><p>Nota: No añadas, repito no añadas <code>--hard</code> aquí porque esto también elimina los cambios de tu árbol.</p></div><div class=paragraph><p>Ahora, si tienes suerte, el cambio que necesita partirse cae completamente en las líneas del fichero.
En ese caso puedes hacer el <code>git add</code> habitual para los ficheros de cada grupo y luego hacer <code>git commit</code>.
Nota: cuando hagas esto, perderás el mensaje de commit al hacer el reset, así que si lo necesitas por algún motivo, deberías guardar una copia (aunque <code>git log $HASH</code> puede recuperarlo).</p></div><div class=paragraph><p>Si no tienes suerte, tendrás que partir ficheros.
Hay otra herramienta para hacer eso que puedes aplicar en cada fichero.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>git add <span class=nt>-i</span> foo/bar.c</code></pre></div></div><div class=paragraph><p>iterará por los diffs, preguntándote a cada paso si quieres incluir o excluir un trozo del cambio.
Cuando hayas terminado, haz <code>git commit</code> y tendrás lo que quede en tu árbol.
Puedes ejecutarlo varias veces también o incluso en varios ficheros (aunque encuentro más fácil hacerlo en un fichero cada vez y después utilizar <code>git rebase -i</code> para agrupar juntos commits que están relacionados).</p></div></div></div><div class=sect3><h4 id=_clonar_y_duplicar_crear_un_mirror>5.6.3. Clonar y Duplicar (crear un mirror)<a class=anchor href=#_clonar_y_duplicar_crear_un_mirror></a></h4><div class=paragraph><p><strong>Q:</strong> Me gustaría crear un mirror de todo el repositorio Git, ¿cómo lo hago?</p></div><div class=paragraph><p><strong>A:</strong> Si todo lo que quieres es un mirror, entonces</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% git clone <span class=nt>--mirror</span> <span class=nv>$URL</span></code></pre></div></div><div class=paragraph><p>hará lo que quieres.
Sin embargo, hay dos desventajas si quieres utilizar esto para algo más que hacer un mirror del cual crearás un clon.</p></div><div class=paragraph><p>Primero, esto es un 'repositorio desnudo' que tiene la base de datos del repositorio, pero no tiene ningún worktree.
Esto es genial para crear un mirror, pero es terrible para el trabajo del día a día.
Hay maneras de solventar esto con 'git worktree':</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% git clone <span class=nt>--mirror</span> https://git.freebsd.org/ports.git ports.git % <span class=nb>cd </span>ports.git % git worktree add ../ports main % git worktree add ../quarterly branches/2020Q4 % <span class=nb>cd</span> ../ports</code></pre></div></div><div class=paragraph><p>Pero si no estás usando tu mirror para hacer más clones locales, entonces esta es una alternativa algo pobre.</p></div><div class=paragraph><p>La segunda desventaja es que Git normalmente sobrescribe las refs (nombres de ramas, etiquetas, etc) del repositorio remoto de forma que tus refs locales pueden evolucionar de forma independiente. Esto significa que perderás los cambios si haces commit a este repositorio en cualquier sitio que no sean ramas de proyectos privados.</p></div><div class=paragraph><p><strong>Q:</strong> ¿Qué puedo hacer entonces?</p></div><div class=paragraph><p><strong>A:</strong> Puedes agrupar todas las refs del repositorio remoto en un espacio de nombres privado en tu repositorio local.
Git clona todo mediante un 'refspec' y el refspec por defecto es:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>        fetch <span class=o>=</span> +refs/heads/<span class=k>*</span>:refs/remotes/freebsd/<span class=k>*</span></code></pre></div></div><div class=paragraph><p>que le dice que se traiga las refs de la rama.</p></div><div class=paragraph><p>Sin embargo, el repositorio de FreeBSD tiene otras cosas.
Para verlas, puedes añadir refspects de forma explícita para cada espacio de nombres o puedes traértelo todo.
Para configurar tu repositorio para que haga eso:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>git config <span class=nt>--add</span> remote.freebsd.fetch <span class=s1>&#39;+refs/*:refs/freebsd/*&#39;</span></code></pre></div></div><div class=paragraph><p>que pondrá todo el repositorio remoto en tu espacio de nombres 'refs/freebsd/' de tu repositorio local.
Por favor, date cuenta de que esto también se trae ramas externas sin convertir y el número de refs que tienen asociadas es bastante grande.</p></div><div class=paragraph><p>Necesitarás hacer referencia a estas 'refs' con su nombre completo porque no son espacios de nombres regulares de Git.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>git log refs/freebsd/vendor/zlib/1.2.10</code></pre></div></div><div class=paragraph><p>mostraría el log de la rama externa para zlib comenzando en 1.2.10.</p></div></div></div><div class=sect2><h3 id=_colaborando_con_otros>5.7. Colaborando con otros<a class=anchor href=#_colaborando_con_otros></a></h3><div class=paragraph><p>Una de las claves para un buen desarrollo de software en un proyecto tan grande como FreeBSD es la habilidad para colaborar con otros antes de que empujes tus cambios al árbol. Los repositorios Git del proyecto FreeBSD todavía no permiten la creación de ramas de usuario que puedan ser empujadas al repositorio y por lo tanto si quieres compartir tus cambios con otros debes usar otro mecanismo como GitLab o GitHub, para compartir los cambios en una rama generada por el usuario.</p></div><div class=paragraph><p>Las siguientes instrucciones muestran cómo preparar una rama de usuario, basada en la rama <code>main</code> de FreeBSD y cómo empujarla a GitHub.</p></div><div class=paragraph><p>Antes de empezar, asegúrate de que tu repo local de Git está actualizado y tiene los orígenes correctos <a href=#keeping_current>como se muestra arriba.</a></p></div><div class=paragraph><p><code class=source><code>` % git remote -v freebsd <a href=https://git.freebsd.org/src.git class=bare>https://git.freebsd.org/src.git</a> (fetch) freebsd ssh://git@gitrepo.freebsd.org/src.git (push) </code>`</code></p></div><div class=paragraph><p>El primer paso es crear un fork de <a href=https://github.com/freebsd/freebsd-src>FreeBSD</a> en GitHub siguiendo estas <a href=https://docs.github.com/en/github/getting-started-with-github/fork-a-repo>instrucciones</a>. El destino del fork debería ser tu propia cuenta personal de GitHub (en mi caso gvnn3).</p></div><div class=paragraph><p>Ahora añade un remoto a tu sistema local que apunte a tu fork: [source,shell]</p></div><div class=literalblock><div class=content><pre>% git remote add github git@github.com:gvnn3/freebsd-src.git % git remote -v github	git@github.com:gvnn3/freebsd-src.git (fetch) github	git@github.com:gvnn3/freebsd-src.git (push) freebsd	https://git.freebsd.org/src.git (fetch) freebsd	ssh://git@gitrepo.freebsd.org/src.git (push)</pre></div></div><div class=paragraph><p>Una vez hecho esto puedes crear una rama <a href=#keeping_a_local_branch>como se muestra arriba.</a></p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% git checkout <span class=nt>-b</span> gnn-pr2001-fix</code></pre></div></div><div class=paragraph><p>Haz las modificaciones que quieras en tu rama. Compila, prueba y una vez que estés listo para colaborar con otros es momento de empujar tus cambios a la rama. Antes de que puedas hacerlo, deberás establecer el upstream apropiado, ya que Git te lo pedirá la primera vez que intentes empujar a tu remoto en github:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% git push github fatal: The current branch gnn-pr2001-fix has no upstream branch. To push the current branch and <span class=nb>set </span>the remote as upstream, use

    git push <span class=nt>--set-upstream</span> github gnn-pr2001-fix</code></pre></div></div><div class=paragraph><p>Establecer el push como git recomienda hace que se pueda completar con éxito:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% git push <span class=nt>--set-upstream</span> github gnn-feature
Enumerating objects: 20486, <span class=k>done</span><span class=nb>.</span>
Counting objects: 100% <span class=o>(</span>20486/20486<span class=o>)</span>, <span class=k>done</span><span class=nb>.</span>
Delta compression using up to 8 threads
Compressing objects: 100% <span class=o>(</span>12202/12202<span class=o>)</span>, <span class=k>done</span><span class=nb>.</span>
Writing objects: 100% <span class=o>(</span>20180/20180<span class=o>)</span>, 56.25 MiB | 13.15 MiB/s, <span class=k>done</span><span class=nb>.</span>
Total 20180 <span class=o>(</span>delta 11316<span class=o>)</span>, reused 12972 <span class=o>(</span>delta 7770<span class=o>)</span>, pack-reused 0
remote: Resolving deltas: 100% <span class=o>(</span>11316/11316<span class=o>)</span>, completed with 247 <span class=nb>local </span>objects.
remote:
remote: Create a pull request <span class=k>for</span> <span class=s1>&#39;gnn-feature&#39;</span> on GitHub by visiting:
remote:      https://github.com/gvnn3/freebsd-src/pull/new/gnn-feature
remote:
To github.com:gvnn3/freebsd-src.git
<span class=o>[</span>new branch]                gnn-feature -&gt; gnn-feature
Branch <span class=s1>&#39;gnn-feature&#39;</span> <span class=nb>set </span>up to track remote branch <span class=s1>&#39;gnn-feature&#39;</span> from <span class=s1>&#39;github&#39;</span>.</code></pre></div></div><div class=paragraph><p>Los siguientes cambios en la rama se podrán empujar correctamente con el comando por defecto:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% git push
Enumerating objects: 4, <span class=k>done</span><span class=nb>.</span>
Counting objects: 100% <span class=o>(</span>4/4<span class=o>)</span>, <span class=k>done</span><span class=nb>.</span>
Delta compression using up to 8 threads
Compressing objects: 100% <span class=o>(</span>2/2<span class=o>)</span>, <span class=k>done</span><span class=nb>.</span>
Writing objects: 100% <span class=o>(</span>3/3<span class=o>)</span>, 314 bytes | 1024 bytes/s, <span class=k>done</span><span class=nb>.</span>
Total 3 <span class=o>(</span>delta 1<span class=o>)</span>, reused 1 <span class=o>(</span>delta 0<span class=o>)</span>, pack-reused 0
remote: Resolving deltas: 100% <span class=o>(</span>1/1<span class=o>)</span>, completed with 1 <span class=nb>local </span>object.
To github.com:gvnn3/freebsd-src.git
   9e5243d7b659..cf6aeb8d7dda  gnn-feature -&gt; gnn-feature</code></pre></div></div><div class=paragraph><p>En este momento tu trabajo está en tu rama de GitHub y puedes compartir el enlace con otros colaboradores.</p></div></div><div class=sect2><h3 id=github-pull-land>5.8. Traer al proyecto una pull request de github<a class=anchor href=#github-pull-land></a></h3><div class=paragraph><p>Esta sección documenta cómo traerse una pull request de GitHub que se ha hecho contra los mirros de Git de FreeBSD en GitHub. Aunque en este momento esta no es una forma oficial de enviar parches, a veces buenos arreglos vienen de esta forma y es más fácil cogerlos del árbol de un committer que hacerles que lo empujen al árbol de FreeBSD desde ahí. Se pueden usar pasos similares para traerse ramas de otros repositorios. Cuando se hace commit de pull requests de otros, se debe tener especial cuidado en examinar todos los cambios para asegurar que son exactamente lo que representan.</p></div><div class=paragraph><p>Antes de empezar, asegúrate de que tu repo local de Git está actualizado y de que tiene el origen correctamente establecido <a href=#keeping_current>como se muestra arriba.</a> Además, asegúrate de tener los siguientes orígenes: [source,shell]</p></div><div class=literalblock><div class=content><pre>% git remote -v freebsd https://git.freebsd.org/src.git (fetch) freebsd ssh://git@gitrepo.freebsd.org/src.git (push) github https://github.com/freebsd/freebsd-src (fetch) github https://github.com/freebsd/freebsd-src (fetch)</pre></div></div><div class=paragraph><p>Muchas veces las pull requests son sencillas: peticiones que contienen un sólo commit.
En este caso, se puede utilizar una aproximación directa, aunque la aproximación de la sección anterior también funciona.
Aquí se crea una rama, se selecciona el cambio con cherry pick, se ajusta el mensaje de commit y se hacen controles de calidad antes de empujar el cambio.
En este ejemplo se usa la rama <code>staging</code> pero podría utilizarse cualquier nombre.
Esta técnica funciona para cualquier número de commits que haya en la pull request, especialmente cuando el cambio se puede aplicar limpiamente al árbol de FreeBSD.
Sin embargo, cuando hay varios commits, especialmente cuando se necesitan pequeños ajustes, <code>git rebase -i</code> funciona mejor que <code>git cherry-pick</code>.
Brevemente, estos comandos crean una rama; seleccionan los cambios de la rama del pull request; los prueban; ajustan los mensajes de commit; y lo mergean de vuelta a <code>main</code> haciendo un fast forward.
El número de PR abajo es <code>$PR</code>.
Cuando se ajusta el mensaje, añade <code>Pull Request: <a href=https://github.com/freebsd-src/pull/$PR class=bare>https://github.com/freebsd-src/pull/$PR</a></code>.
Todas las pull requests enviadas al repositorio de FreeBSD deberían ser revisadas por al menos una persona.
No es necesario que sea la persona que hace el commit, pero en ese caso la persona que lo hace debería confiar en la competencia de los otros revisores para revisar el commit.
Los committers que hacen revisión de código de una pull request antes de empujarla al repo deberían añadir una línea <code>Reviewed by:</code> al commit, porque en este caso no es implícito.
Añade también a la línea <code>Reviewed by:</code> a cualquiera que revise y apruebe el commit en github.
Como siempre, se debe poner cuidado para asegurar que el código hace lo que se supone que hace y que no hay código malicioso.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Además, por favor asegúrate de que el nombre del autor de la pull request no es anónimo.
El interfaz web de edición de GitHub genera nombres como:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Author:     github-user &lt;38923459+github-user@users.noreply.github.com&gt;</code></pre></div></div><div class=paragraph><p>Se debería hacer una solicitud educada al autor para que proporcione un nombre mejor y/o un email.
Se debería poner cuidado para asegurar de que no hay problemas de estilo ni se introduce código malicioso.</p></div></td></tr></tbody></table></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% git fetch github pull/<span class=nv>$PR</span>/head:staging % git rebase <span class=nt>-i</span> main staging	<span class=c># to move the staging branch forward, adjust commit message here &lt;do testing here, as needed&gt; % git checkout main % git pull --ff-only		# to get the latest if time has passed % git checkout main % git merge --ff-only staging &lt;test again if needed&gt; % git push freebsd --push-option=confirm-author</span></code></pre></div></div><div class="exampleblock procedure"><div class=content><div class=paragraph><p>Para pull requests complicadas que tienen varios commits con conflictos, sigue el siguiente esquema.</p></div><div class="olist arabic"><ol class=arabic><li><p>haz checkout de la pull request <code>git checkout github/pull/XXX</code></p></li><li><p>crea una rama para hacer un rebase <code>git checkout -b staging</code></p></li><li><p>rebasa la rama <code>staging</code> con lo último de <code>main</code> con <code>git rebase -i main staging</code></p></li><li><p>resuelve conflictos y haz las pruebas que sean necesarias</p></li><li><p>haz fast forward de la rama <code>staging</code> in la rama <code>main</code> como arriba</p></li><li><p>últimas comprobaciones de cambios para asegurarse de que todo está bien</p></li><li><p>empuja al repositorio Git de FreeBSD.</p></li></ol></div><div class=paragraph><p>Esto también funcionará cuando nos traigamos ramas desarrolladas en otros sitios hasta el árbol local para hacer commit.</p></div></div></div><div class=paragraph><p>Una vez que hayas terminado con la pull request, ciérrala usando el interfaz web de GitHub. Merece la pena mencionar que si tu origen <code>github</code> utiliza <code>https://</code>, el único paso para el que necesitas una cuenta de GitHub es para cerrar la pull request.</p></div></div></div></div><div class=sect1><h2 id=vcs-history>6. Histórico del Control de Versiones<a class=anchor href=#vcs-history></a></h2><div class=sectionbody><div class=paragraph><p>El proyecto se ha movido a <a href=#git-primer>git</a>.</p></div><div class=paragraph><p>El repositorio fuente de FreeBSD pasó de CVS a Subversion el 31 de Mayo de 2008. El primer commit real de SVN es <em>r179447</em>. El repositorio fuente cambió de Subversion a Git el 23 de Diciembre de 2020. El último commit real de svn es <em>r368820</em>. El hash del primer commit real en git es <em>5ef5f51d2bef80b0ede9b10ad5b0e9440b60518c</em>.</p></div><div class=paragraph><p>El repositorio <code>doc/www</code> de FreeBSD cambió de CVS a Subversion el 19 de Mayo de 2012. El primer commit real de SVN es <em>r38821</em>. El repositorio de documentación cambió de Subversion a Git el 8 de Diciembre de 2020. El último commit de SVN es <em>r54737</em>. El has del primer commit real de git es <em>3be01a475855e7511ad755b2defd2e0da5d58bbe</em>.</p></div><div class=paragraph><p>El repositorio de <code>ports</code> de FreeBSD cambió de CVS a Subversion el 14 de Julio de 2012. El primer commit real de SVN es <em>r300894</em>. El repositorio de ports cambió de Subversion a Git el 6 de Abril de 2021. El último commit de SVN es <em>r569609</em>. El hash del primer commit de git es <em>ed8d3eda309dd863fb66e04bccaa513eee255cbf</em>.</p></div></div></div><div class=sect1><h2 id=conventions>7. Configuración, Convenciones y Tradiciones<a class=anchor href=#conventions></a></h2><div class=sectionbody><div class=paragraph><p>Hay una serie de cosas que hacer como nuevo desarrollador. La primera serie de pasos es específica solamente para los committers. Estos pasos deben ser realizados por un mentor para aquellos que no son committers.</p></div><div class=sect2><h3 id=conventions-committers>7.1. Para los Nuevos Committers<a class=anchor href=#conventions-committers></a></h3><div class=paragraph><p>Aquellos a los que se les han concedido derechos de envío a los repositorios de FreeBSD deben seguir estos pasos.</p></div><div class=ulist><ul><li><p>¡Obtén aprobación de tu mentor para hacer commit de cada uno de estos cambios!</p></li><li><p>Todos los commits de <span class=filename>src</span> van primero a FreeBSD-CURRENT antes de llevarse a FreeBSD-STABLE. La rama FreeBSD-STABLE debe mantener la compatibilidad de ABI y API con versiones anteriores de esa rama. No lleves cambios que rompan esta compatibilidad.</p></li></ul></div><div id=commit-steps class="exampleblock procedure"><div class=content><div class=paragraph><p>Pasos para los Nuevos Committers</p></div><div class="olist arabic"><ol class=arabic><li><p>Añade una Entidad de Autor</p><div class=paragraph><p><span class=filename>doc/shared/authors.adoc</span> - Añade una entidad de autor. Los pasos posteriores dependen de esta entidad, y saltarse este paso provocará que la construcción de <span class=filename>doc/</span> falle. Esta es una tarea relativamente sencilla, pero sigue siendo una buena primera tarea de prueba de las habilidades de control de versiones.</p></div></li><li><p>Actualiza la Lista de Desarrolladores y Colaboradores</p><div class=paragraph><p><span class=filename>doc/shared/contrib-committers.adoc</span> - Añade una entrada, la cual aparecerá en la sección "Developers" de la ection of the <a href=https://docs.freebsd.org/en/articles/contributors/#staff-committers>Lista de Colaboradores</a>. Las entradas están ordenadas por apellido.</p></div><div class=paragraph><p><span class=filename>doc/shared/contrib-additional.adoc</span> - <em>Elimina</em> la entrada. Las entradas están ordenadas por nombre.</p></div></li><li><p>Añade un Ítem a las Noticias</p><div class=paragraph><p><span class=filename>doc/website/data/en/news/news.toml</span> - Añade una entrada. Busca otras entradas que anuncien nuevos committers y sigue el formato. Usa la fecha del correo de aprobación del commit bit.</p></div></li><li><p>Añade una Clave PGP</p><div class=paragraph><p><code>Dag-Erling Smørgrav &lt;<a href=mailto:des@FreeBSD.org>des@FreeBSD.org</a>></code> ha escrito un shell script (<span class=filename>doc/documentation/tools/addkey.sh</span>) para hacerlos más fácil. Lee el fichero <a href=https://cgit.freebsd.org/doc/plain/documentation/static/pgpkeys/README>README</a> para más información.</p></div><div class=paragraph><p>Usa <span class=filename>doc/documentation/tools/checkkey.sh</span> para verificar que la clave cumple con el mínimo de las buenas prácticas estándar.</p></div><div class=paragraph><p>Después de añadir y comprobar la clave, añade ambos ficheros actualizados al control de código y luego haz commit. Las entradas en este fichero están ordenadas por apellido.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Es muy importante tener una clave PGP/GnuPG actualizada en el repositorio. Se podría requerir la clave para identificar a un committer. Por ejemplo, el <code>Administradores de FreeBSD &lt;<a href=mailto:admins@FreeBSD.org>admins@FreeBSD.org</a>></code> podría necesitarlo para recuperar una cuenta. Hay un llavero completo de usuarios de <code>FreeBSD.org</code> disponible para descarga desde <a href=https://docs.FreeBSD.org/pgpkeys/pgpkeys.txt>https://docs.FreeBSD.org/pgpkeys/pgpkeys.txt</a>.</p></div></td></tr></tbody></table></div></li><li><p>Actualiza la información del Mentor y el Alumno</p><div class=paragraph><p><span class=filename>src/share/misc/committers-&lt;repository>.dot</span> - Añade una entrada a la sección de committers actuales, donde <em>repository</em> es <code>doc</code>, <code>ports</code>, o <code>src</code>, dependiendo de los privilegios de commit concedidos.</p></div><div class=paragraph><p>Añade una entrada para cada relación mentor/alumno individual al final de la sección.</p></div></li><li><p>Genera una Contraseña de Kerberos</p><div class=paragraph><p>Lee <a href=#kerberos-ldap>Kerberos y contraseña web LDAP para el clúster de FreeBSD</a> para generar o establecer una cuenta de Kerberos para utilizarla con otros servicios de FreeBSD como la <a href=https://bugs.freebsd.org/bugzilla/>base de datos de bugs</a> (obtienes una cuenta en la base de datos como parte de ese paso).</p></div></li><li><p>Opcional: Activa la Cuenta de la Wiki</p><div class=paragraph><p><a href=https://wiki.freebsd.org>FreeBSD Wiki</a> Account - Una cuenta en la wiki permite compartir proyectos e ideas.
Aquellos que todavía no tienen una cuenta pueden seguir las instrucciones en <a href=https://wiki.freebsd.org/Wiki/About>Wiki/About page</a> para obtener una.
Contacta con <a href=mailto:wiki-admin@FreeBSD.org>wiki-admin@FreeBSD.org</a> si necesitas ayuda con tu cuenta Wiki.</p></div></li><li><p>Opcional: Actualiza la Información de la Wiki</p><div class=paragraph><p>Información en la Wiki - Después de obtener acceso a la wiki, algunas personas añaden entradas a las páginas <a href=https://wiki.freebsd.org/HowWeGotHere>Cómo Hemos Llegado Aquí</a>, <a href=https://wiki.freebsd.org/IRC/Nicknames>Nicks de IRC</a>, <a href=https://wiki.freebsd.org/Community/Dogs>Perros de FreeBSD</a>, y o <a href=https://wiki.freebsd.org/Community/Cats>Gatos de FreeBSD</a>.</p></div></li><li><p>Opcional: Actualiza los Ports con Información Personal</p><div class=paragraph><p><span class=filename>ports/astro/xearth/files/freebsd.committers.markers</span> y <span class=filename>src/usr.bin/calendar/calendars/calendar.freebsd</span> - Algunas personas añaden entradas para ellos mismos a estos ficheros para mostrar dónde viven o su fecha de cumpleaños.</p></div></li><li><p>Opcional: Evita Correos Duplicados</p><div class=paragraph><p>Los subscriptores de <a href=https://lists.FreeBSD.org/subscription/dev-commits-doc-all>Mensajes de commit para todas la ramas del repositorio doc</a>, <a href=https://lists.FreeBSD.org/subscription/dev-commits-ports-all>Mensajes de commit para todas las ramas del repositorio de ports</a> o <a href=https://lists.FreeBSD.org/subscription/dev-commits-src-all>Mensajes de commit para todas las ramas del repositorio src</a> podrían querer darse de baja para evitar recibir copias duplicadas de los mensajes de commit y de sus continuaciones.</p></div></li></ol></div></div></div></div><div class=sect2><h3 id=conventions-everyone>7.2. Para Todos<a class=anchor href=#conventions-everyone></a></h3><div id=conventions-everyone-steps class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Preséntate ante los otros desarrolladores, de otro modo nadie tendrá ni
idea de quién eres o en qué trabajas. La presentación no tiene que ser una
biografía completa, tan sólo escribe un párrafo o dos acerca de quién eres,
en qué piensas trabajar como desarrollador de FreeBSD, y quién será tu
mentor. Envía este correo a Lista de correo de desarrolladores de FreeBSD y habrás terminado. Entra en
<code>freefall.FreeBSD.org</code> y crea un fichero <span class=filename>/var/forward/usuario</span>
(donde <em>usuario</em> es tu nombre de usuario) que contenga la dirección de
correo donde quieres que se reenvíen los correos dirigidos a
<em>tunombredeusuario</em>@FreeBSD.org. Esto incluye todos los mensajes de commit
así como cualquier otro correo enviado a Lista de correo para 'committers' de FreeBSD y a
Lista de correo de desarrolladores de FreeBSD. Los buzones de correo realmente grandes que están en
<code>freefall</code> podrían ser truncados sin previo aviso si se necesita liberar
espacio, así que reenvíalo o sálvalo en otra parte.</p><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Si tu sistema de correo electrónico usa SPF con reglas estrictas, deberías
excluir <code>mx2.FreeBSD.org</code> de las comprobaciones de SPF.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Debido a la severa carga que tratar con SPAM produce en los servidores
centrales de correo que hacen el procesamiento de las listas de correo, el
servidor front-end hace algunas comprobaciones básicas y eliminará algunos
mensajes basándose en estas comprobaciones. En este momento sólo se
comprueba la que la información de DNS para el host que se conecta es la
adecuada, pero esto podría cambiar. Algunas personas culpan a estas
comprobaciones de bloquear correo válido. Para deshabilitar estas
comprobaciones para tu correo, crea un fichero llamado
<span class=filename>~/.spam_lover</span> en <code>freefall.FreeBSD.org</code>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Aquellos que sean desarrolladores pero no committers no estarán suscritos a
las listas de committers o desarrolladores. Las suscripciones se derivan de
los permisos de acceso.</p></div></td></tr></tbody></table></div></li></ol></div></div></div><div class=sect3><h4 id=smtp-setup>7.2.1. Configuración de acceso SMTP<a class=anchor href=#smtp-setup></a></h4><div class=paragraph><p>Para aquellos que deseen enviar mensajes de correo electrónico a través de la infraestructura de FreeBSD.org, sigan las siguientes instrucciones:</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Apunta tu cliente de correo a <code>smtp.FreeBSD.org:587</code>. Activa
STATTLS. Asegúrate de que tu dirección <code>From:</code> está establecida a
<code><em>tunombredeusuario</em>@FreeBSD.org</code>. Para la autenticación puedes usar tu
nombre de usuario de Kerberos y tu contraseña (lee <a href=#kerberos-ldap>Kerberos y contraseña web LDAP para el clúster de FreeBSD</a>). Se
prefiere el <code><em>tunombredeusuario</em>/mail</code> principal, ya que sólo se usa para
validar recursos de correo</p><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>No incluyas <code>FreeBSD.org</code> cuando introduzcas tu nombre de usuario</p></div></td></tr></tbody></table></div></li><li><p>Notas adicionales</p><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=ulist><ul><li><p>Sólo se aceptará correo desde <code><em>tunombredeusuario</em>@FreeBSD.org</code>. Si estás
autenticado como un usuario, no se te permite enviar correo como otro.</p></li><li><p>Se añadirá una cabecera con el nombre de usuario SASL: (<code>Authenticated
sender: <em>username</em></code>).</p></li><li><p>La máquina tiene varios límites de velocidad para cortar los intentos de
fuerza bruta.</p></li></ul></div></td></tr></tbody></table></div></li></ol></div></div></div><div class=sect4><h5 id=smtp-setup-local-mta>7.2.1.1. Uso de un MTA local para reenviar correos electrónicos al servicio SMTP de FreeBSD.org<a class=anchor href=#smtp-setup-local-mta></a></h5><div class=paragraph><p>También es posible utilizar un MTA local para reenviar emails enviados localmente a los servidores SMTP de FreeBSD.org.</p></div><div id=smtp-setup-local-postfix class=exampleblock><div class=title>Ejemplo 1. Usando Postfix</div><div class=content><div class=paragraph><p>Para decirle a una instancia local de Postfix que se debería reenviar a los servidores FreeBSD.org cualquier cosa que venga de <code><em>tunombredeusuario</em>@FreeBSD.org</code>, añade esto a tu <span class=filename>main.cf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>sender_dependent_relayhost_maps = hash:/usr/local/etc/postfix/relayhost_maps smtp_sasl_auth_enable = yes smtp_sasl_security_options = noanonymous smtp_sasl_password_maps = hash:/usr/local/etc/postfix/sasl_passwd smtp_use_tls = yes</pre></div></div><div class=paragraph><p>Crea <span class=filename>/usr/local/etc/postfix/relayhost_maps</span> con el siguiente contenido:</p></div><div class="literalblock programlisting"><div class=content><pre>tunombredeusuario@FreeBSD.org [smtp.freebsd.org]:587</pre></div></div><div class=paragraph><p>Crea <span class=filename>/usr/local/etc/postfix/sasl_passwd</span> con el siguiente contenido:</p></div><div class="literalblock programlisting"><div class=content><pre>[smtp.freebsd.org]:587          tunombredeusuario:tucontraseña</pre></div></div><div class=paragraph><p>Si otras personas utilizan el servidor de correo electrónico, es posible que quieras evitar que envíen correos electrónicos desde tu dirección. Para lograr esto, agrega esto a tu <span class=filename>main.cf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>smtpd_sender_login_maps = hash:/usr/local/etc/postfix/sender_login_maps smtpd_sender_restrictions = reject_known_sender_login_mismatch</pre></div></div><div class=paragraph><p>Crea <span class=filename>/usr/local/etc/postfix/sender_login_maps</span> con el siguiente contenido:</p></div><div class="literalblock programlisting"><div class=content><pre>tunombredeusuario@FreeBSD.org tunombredeusuariolocal</pre></div></div><div class=paragraph><p>Donde <em>tunombredeusuariolocal</em> es el nombre de usuario SASL utilizado para conectar a la instancia local de Postfix.</p></div></div></div><div id=smtp-setup-local-opensmtpd class=exampleblock><div class=title>Ejemplo 2. Usando OpenSMTPD</div><div class=content><div class=paragraph><p>Para decirle a una instancia local de OpenSMTPD que se debería reenviar a los sevidores FreeBSD.org cualquier cosa que venga de <code><em>tunombredeusuario</em>@FreeBSD.org</code>, añade esto a tu <span class=filename>smtpd.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>action &#34;freebsd&#34; relay host smtp+tls://freebsd@smtp.freebsd.org:587 auth &lt;secrets&gt; match from any auth yourlocalusername mail-from &#34;_yourusername_@freebsd.org&#34; for any action &#34;freebsd&#34;</pre></div></div><div class=paragraph><p>Donde <em>tunombredeusuariolocal</em> es el nombre de usuario SASL utilizado para conectar a la instancia local de OpenSMTPD.</p></div><div class=paragraph><p>Crea <span class=filename>/usr/local/etc/mail/secrets</span> con el siguiente contenido:</p></div><div class="literalblock programlisting"><div class=content><pre>freebsd	tunombredeusuario:tucontraseña</pre></div></div></div></div><div id=smtp-setup-local-exim class=exampleblock><div class=title>Ejemplo 3. Usando Exim</div><div class=content><div class=paragraph><p>Para decirle a una instancia local de Exim que se debería reenviar a los sevidores FreeBSD.ORG cualquier cosa que venga de <code><em>example</em>@FreeBSD.org</code>
añade esto a tu <span class=filename>configuration</span> de Exim:</p></div><div class="literalblock programlisting"><div class=content><pre>Routers section: (at the top of the list):
freebsd_send:
   driver = manualroute
   domains = !+local_domains
   transport = freebsd_smtp
   route_data = ${lookup {${lc:$sender_address}} lsearch {/usr/local/etc/exim/freebsd_send}}

Transport Section:
freebsd_smtp:
        driver = smtp
  tls_certificate=&lt;local certificate&gt;
  tls_privatekey=&lt;local certificate private key&gt;
  tls_require_ciphers = EECDH+ECDSA+AESGCM:EECDH+aRSA+AESGCM:EECDH+ECDSA+SHA384:EECDH+ECDSA+SHA256:EECDH+aRSA+SHA384:EECDH+aRSA+SHA256:EECDH+AESGCM:EECDH:EDH+AESGCM:EDH+aRSA:HIGH:!MEDIUM:!LOW:!aNULL:!eNULL:!LOW:!RC4:!MD5:!EXP:!PSK:!SRP:!DSS
  dkim_domain = &lt;local DKIM domain&gt;
  dkim_selector = &lt;local DKIM selector&gt;
  dkim_private_key= &lt;local DKIM private key&gt;
  dnssec_request_domains = *
  hosts_require_auth = smtp.freebsd.org

Authenticators:
fixed_plain:
  driver = plaintext
  public_name = PLAIN
  client_send = ^example/mail^examplePassword</pre></div></div><div class=paragraph><p>Crea <span class=filename>/usr/local/etc/exim/freebsd_send</span> con el siguiente contenido:</p></div><div class="literalblock programlisting"><div class=content><pre>example@freebsd.org:smtp.freebsd.org::587</pre></div></div></div></div></div></div></div><div class=sect2><h3 id=mentors>7.3. Mentores<a class=anchor href=#mentors></a></h3><div class=paragraph><p>Todos los nuevos desarrolladores tienen un mentor asignado durante los primeros meses. Un mentor es responsable de enseñar a los aprendices las reglas y convenciones del proyecto y de guiar sus primeros pasos en la comunidad de desarrolladores. El mentor también es personalmente responsable de las acciones de los aprendices durante este período inicial.</p></div><div class=paragraph><p>Para los committers: no envíes nada sin obtener primero la aprobación del mentor. Documenta esa aprobación con una línea <code>Approved by:</code> en el mensaje de commit.</p></div><div class=paragraph><p>Cuando el mentor decide que un aprendiz ha aprendido las reglas y está listo para hacer envíos por su cuenta, el mentor lo anuncia con un commit en <span class=filename>mentors</span>. Este archivo está en la rama huérfana <span class=filename>admin</span> de cada repositorio. Se puede encontrar información detallada sobre cómo acceder a estas ramas en <a href=#admin-branch>rama "admin"</a>.</p></div></div></div></div><div class=sect1><h2 id=pre-commit-review>8. Revisión previa al commit<a class=anchor href=#pre-commit-review></a></h2><div class=sectionbody><div class=paragraph><p>La revisión de código es una forma de incrementar la calidad del software. Las siguientes guías aplican a los commits a la rama <code>main</code>(-CURREN) del repositorio <code>src</code>. Otras ramas y los árboles <code>ports</code> y <code>docs</code> tienen sus propias políticas, pero estas directrices aplican generalmente a commits que necesitan revisión:</p></div><div class=ulist><ul><li><p>Todos los cambios no triviales deberían ser revisados antes de hacer commit en el repositorio.</p></li><li><p>Las revisiones se pueden realizar por email, en Bugzilla, en Phabricator, o por otro mecanismo. Cuando sea posible, las revisiones deberían ser públicas.</p></li><li><p>El desarrollador responsable de un cambio de código también es responsable de hacer todos los cambios relacionados con la revisión.</p></li><li><p>La revisión de código puede ser un proceso iterativo, que continúa hasta que el parche está listo para ser comprometido. Específicamente, una vez que se envía un parche para su revisión, debes recibir un "looks good" explícito antes de hacer commit. Siempre que sea explícito, esto puede tomar cualquier forma que tenga sentido para el método de revisión.</p></li><li><p>Los timeouts no sustituyen una revisión.</p></li></ul></div><div class=paragraph><p>A veces las revisiones de los códigos tardan más de lo que se espera, especialmente para las funciones más grandes. Las formas aceptadas de acelerar los tiempos de revisión de tus parches son:</p></div><div class=ulist><ul><li><p>Revisa los parches de otras personas. Si tú ayudas, todo el mundo estará más dispuesto a hacer lo mismo por ti; la buena voluntad es nuestra moneda.</p></li><li><p>Avisa del parche. Si es urgente, proporciona razones por las que es importante que este parche sea incluido y avisa cada dos días. Si no es urgente, la cortesía habitual es llamar la atención sobre el parche una vez a la semana. Recuerda que estás pidiendo tiempo valioso de otro desarrollador profesional.</p></li><li><p>Pide ayuda en las listas de correo, IRC, etc. Otros podrían ser capaces de ayudarte directamente, o de sugerir un revisor.</p></li><li><p>Parte tu parche en varios parches más pequeños que se apliquen uno sobre otro. Cuanto más pequeño sea tu parche, más alta será la probabilidad de que alguien le eche un vistazo.</p><div class=paragraph><p>Cuando hagas cambios grandes, es útil tener en cuenta esto desde el comienzo ya que romper cambios en trozos más pequeños es normalmente difícil al hacerlo más tarde.</p></div></li></ul></div><div class=paragraph><p>Los desarrolladores deben participar en las revisiones de código como revisores y revisados.
Si alguien tiene la amabilidad de revisar tu código, deberías devolverle el favor a otra persona.
Ten en cuenta que aunque cualquiera es bienvenido a revisar y dar su opinión sobre un parche, sólo un experto en la materia puede aprobar un cambio.
Normalmente será un especialista que trabaje con el código en cuestión de forma regular.</p></div><div class=paragraph><p>En algunos casos, es posible que no se disponga de un experto en la materia.
En esos casos, basta con un examen por parte de un desarrollador experimentado cuando se combina con las pruebas apropiadas.</p></div></div></div><div class=sect1><h2 id=commit-log-message>9. Mensajes de Commit<a class=anchor href=#commit-log-message></a></h2><div class=sectionbody><div class=paragraph><p>Esta sección contiene algunas sugerencias y tradiciones sobre cómo se formatean los mensajes de commit.</p></div><div class=sect2><h3 id=_por_qué_son_importantes_los_mensajes_de_commit>9.1. ¿Por qué son importantes los mensajes de commit?<a class=anchor href=#_por_qué_son_importantes_los_mensajes_de_commit></a></h3><div class=paragraph><p>Cuando haces commit en Git, Subversion, o cualquier otro sistema de control de versiones (VCS), se te pide un texto que describa el cambio — un mensaje de commit. ¿Cómo de importante es este mensaje? ¿Deberías dedicar un esfuerzo significativo escribiéndolo? ¿Realmente importa si escribes simplemente "arregla un bug"?</p></div><div class=paragraph><p>La mayoría de los proyectos tienen más de un desarrollador y duran un tiempo determinado. Los mensajes de commit son un método muy importante de comunicación con otros desarrolladores, en el presente y para el futuro.</p></div><div class=paragraph><p>FreeBSD tiene cientos de desarrolladores activos y cientos de miles de commits a lo largo de décadas de historia. Durante ese tiempo la comunidad de desarrolladores ha aprendido cómo de valiosos son los buenos mensajes de commit; a veces se ha tenido que aprender a la fuerza.</p></div><div class=paragraph><p>Los mensajes de commit sirven al menos tres propósitos:</p></div><div class=ulist><ul><li><p>Comunicándote con otros desarrolladores</p><div class=paragraph><p>Los commits en FreeBSD generan emails en varias listas de correo.
Estos incluyen el mensaje de commit junto con una copia del propio parche.
Los mensajes de commit también se visualizan a través de comandos como git log.
Esto sirve para que otros desarrolladores sean conscientes de los cambios que se están produciendo; que otro desarrollador podría querer probar el cambio, podría tener un interés en el asunto en cuestión y querrá revisarlo en más detalle, o que podría tener sus propios proyectos en curso que se beneficiarían de una posible interacción entre ambos.</p></div></li><li><p>Haciendo que los Cambios sean Descubribles</p><div class=paragraph><p>En un proyecto grande con mucha historia podría ser difícil encontrar cambios de interés cuando se está investigando un problema o un cambio de comportamiento.
Los mensajes de commit largos y detallados permiten buscar cambios que podrían ser relevantes.
Por ejemplo, <code>git log --since 1year --grep 'USB timeout'</code>.</p></div></li><li><p>Proporcionando documentación histórica</p><div class=paragraph><p>Los mensajes de commit se utilizan para documentar los cambios para los futuros desarrolladores, quizás años o décadas más tardes.
Este desarrollador futuro podrías ser tú, el autor original.
Un cambio que hoy podría resultar obvio, podría no serlo mucho tiempo después.</p></div></li></ul></div><div class=paragraph><p>El comando <code>git blame</code> anota cada línea de un fichero fuente con el cambio (hash y línea de título) que lo incorporó.</p></div><div class=paragraph><p>Habiendo establecido su importancia, aquí hay algunos ejemplos de buenos mensajes de commit en FreeBSD:</p></div></div><div class=sect2><h3 id=_comienza_con_una_línea_para_el_título>9.2. Comienza con una línea para el título<a class=anchor href=#_comienza_con_una_línea_para_el_título></a></h3><div class=paragraph><p>Los mensajes de commit deberían empezar con una sola línea para el título que resume brevemente el cambio. El título, por sí mismo, debería permitir al lector determinar de forma rápida si el cambio tiene algún interés o no.</p></div></div><div class=sect2><h3 id=_mantén_las_líneas_de_título_cortas>9.3. Mantén las líneas de título cortas<a class=anchor href=#_mantén_las_líneas_de_título_cortas></a></h3><div class=paragraph><p>La línea de título debería ser lo más corta posible a la vez que mantiene la información requerida. Esto hace que navegar el log de Git sea más eficiente, y también que git log --oneline pueda mostrar el hash corto y el título en una línea de 80 columnas. Una buena regla básica es mantenerse por debajo de 63 caracteres, e intentar hacerlo en 50 o menos si es posible.</p></div></div><div class=sect2><h3 id=_añade_al_título_un_prefijo_para_el_componente_si_aplica>9.4. Añade al título un prefijo para el componente si aplica<a class=anchor href=#_añade_al_título_un_prefijo_para_el_componente_si_aplica></a></h3><div class=paragraph><p>Si el cambio está relacionado con un componente específico, se puede añadir ala línea del título un prefijo con el nombre del componente y dos puntos (:).</p></div><div class=paragraph><p>✓ <code>foo: Add -k option to keep temporary data</code></p></div><div class=paragraph><p>Incluye el prefijo en el límite de 63 caracteres sugerido arriba, de forma que <code>git log --oneline</code> evite partir la línea.</p></div></div><div class=sect2><h3 id=_usa_mayúsculas_para_la_primera_letra_del_título>9.5. Usa mayúsculas para la primera letra del título<a class=anchor href=#_usa_mayúsculas_para_la_primera_letra_del_título></a></h3><div class=paragraph><p>Utiliza mayúscula en la primera letra del título. El prefijo, si lo hay, no utiliza mayúsculas a menos que sea necesario (por ejemplo, <code>USB:</code> va en mayúsculas).</p></div></div><div class=sect2><h3 id=_no_termines_el_título_con_punto>9.6. No termines el título con punto<a class=anchor href=#_no_termines_el_título_con_punto></a></h3><div class=paragraph><p>No termines en punto o con cualquier otro signo de puntuación. En este aspecto la línea de título es como el titular de un periódico.</p></div></div><div class=sect2><h3 id=_separa_el_título_y_el_cuerpo_con_una_línea_en_blanco>9.7. Separa el título y el cuerpo con una línea en blanco<a class=anchor href=#_separa_el_título_y_el_cuerpo_con_una_línea_en_blanco></a></h3><div class=paragraph><p>Separa el cuerpo del título con una línea en blanco.</p></div><div class=paragraph><p>Algunos commits triviales no necesitan cuerpo y tendrán sólo un título.</p></div><div class=paragraph><p>✓ <code>ls: Fix typo in usage text</code></p></div></div><div class=sect2><h3 id=_limita_los_mensajes_a_72_columnas>9.8. Limita los mensajes a 72 columnas<a class=anchor href=#_limita_los_mensajes_a_72_columnas></a></h3><div class=paragraph><p><code>git log</code> y <code>git format-patch</code> tabulan el mensaje de commit utilizando cuatro espacios. Cortar en 72 columnas proporciona un margen en el borde derecho. Limitar los mensajes a 72 caracteres también mantiene el mensaje de commit en parches formateados bajo el límite de longitud de línea de email de 78 caracteres fijado en el RFC 2822. Este límite funciona bien con un buen número de herramientas que podrían mostrar mensajes de commit; el cortado de líneas podría ser inconsistente con longitudes de línea más largas.</p></div></div><div class=sect2><h3 id=_usa_el_modo_presente_en_imperativo>9.9. Usa el modo presente en imperativo<a class=anchor href=#_usa_el_modo_presente_en_imperativo></a></h3><div class=paragraph><p>Esto favorece las líneas de título cortas y proporciona consistencia, incluyendo la generación automática de mensajes de commit (ejemplo, como los generados por git revert). Esto es importante cuando se lee una lista de títulos de commit. Piensa en los títulos como las partes finales de la frase "cuando se aplica, este cambio…​".</p></div><div class=paragraph><p>✓ <code>foo: Implement the -k (keep) option</code><br>✗ <code>foo: Implemented the -k option</code><br>✗ <code>This change implements the -k option in foo</code><br>✗ <code>-k option added</code></p></div></div><div class=sect2><h3 id=_céntrate_en_el_qué_y_el_por_qué_no_en_el_cómo>9.10. Céntrate en el qué y el por qué, no en el cómo<a class=anchor href=#_céntrate_en_el_qué_y_el_por_qué_no_en_el_cómo></a></h3><div class=paragraph><p>Explica qué hace el cambio y por qué se ha hecho, en lugar de cómo lo hace.</p></div><div class=paragraph><p>No asumas que el lector está familiarizado con el asunto. Explica los antecedentes y la motivación para el cambio. Incluye datos de pruebas si los tienes.</p></div><div class=paragraph><p>Si hay limitaciones o aspectos incompletos del cambio, descríbelos en el mensaje de commit.</p></div></div><div class=sect2><h3 id=_considera_si_hay_partes_del_mensaje_de_commit_que_podrían_ser_en_realidad_comentarios_de_código>9.11. Considera si hay partes del mensaje de commit que podrían ser en realidad comentarios de código<a class=anchor href=#_considera_si_hay_partes_del_mensaje_de_commit_que_podrían_ser_en_realidad_comentarios_de_código></a></h3><div class=paragraph><p>A veces mientras escribes un mensaje de commit puedes ver que estás escribiendo un par de frases explicando algún aspecto confuso del cambio. Cuando esto suceda considera si sería valioso tener esa explicación también en el código en forma de comentario.</p></div></div><div class=sect2><h3 id=_escribe_mensajes_de_commit_para_tu_yo_del_futuro>9.12. Escribe mensajes de commit para tu yo del futuro<a class=anchor href=#_escribe_mensajes_de_commit_para_tu_yo_del_futuro></a></h3><div class=paragraph><p>Mientras escribes un mensaje de commit para un cambio tienes todo el contexto en la cabeza - qué motivó el cambio, aproximaciones alternativas que se consideraron y fueron rechazadas, limitaciones del cambio y demás. Imagínate a ti mismo revisitando el cambio en uno o dos años y escribe el mensaje de commit de forma que proporcione el contexto necesario.</p></div></div><div class=sect2><h3 id=_los_mensajes_de_commit_deberían_ser_autocontenidos>9.13. Los mensajes de commit deberían ser autocontenidos<a class=anchor href=#_los_mensajes_de_commit_deberían_ser_autocontenidos></a></h3><div class=paragraph><p>Puedes incluir referencias a mensajes de la lista de correo, resultados de pruebas en sitios web, o enlaces a revisiones de código. Sin embargo, los mensajes de código deberían contener toda la información relevante en caso de que estas referencias ya no estén disponibles en el futuro.</p></div><div class=paragraph><p>De forma similar, un commit podría referenciar un commit anterior, por ejemplo en el caso de un arreglo y una marcha atrás. Además del identificador del commit (revisión o hash), incluye la línea de título del commit referenciado (u otra referencia breve que sirva). Con cada migración de VCS (de CVS a Subversion a Git) los identificadores de revisión de los sistemas previos podrían ser difíciles de seguir.</p></div></div><div class=sect2><h3 id=_incluye_los_metadatos_apropiados_al_pie>9.14. Incluye los metadatos apropiados al pie<a class=anchor href=#_incluye_los_metadatos_apropiados_al_pie></a></h3><div class=paragraph><p>Además de incluir un mensaje informativo con cada envío, es posible que se necesite información adicional.</p></div><div class=paragraph><p>Esta información consta de una o más líneas que contienen la palabra o frase clave, dos puntos, pestañas para formatear y, a continuación, la información adicional.</p></div><div class=paragraph><p>Las palabras o frases clave son:</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:20%><col style=width:80%><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>PR:</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>El informe de error (si lo hay) que se ve afectado (típicamente, cerrándolo) por este commit. Se pueden especificar varios PRs en una línea, separados por comas o espacios.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>Reported by:</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>El nombre y dirección de correo de la persona que reportó el problema: para desarrolladores sólo el nombre de usuario en el clúster de FreeBSD.
Típicamente utilizando cuando no hay PR, por ejemplo si el problema fue reportado
en una lista de correo.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>Submitted by:</code><br>(deprecated)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Esto es obsoleto con git; los parches enviados deberían tener el autor establecido usando <code>git commit --author</code> con un nombre completo y una dirección de email válida.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>Reviewed by:</code></p></td><td class="tableblock halign-left valign-top"><div class=content><div class=paragraph><p>El nombre y dirección de correo de la persona o personas que revisaron el cambio; para los desarrolladores tan solo el nombre de usuario en el clúster de FreeBSD. Si se envió un parche a la lista de correo para ser revisado y la revisión fue favorable, entonces simplemente incluye el nombre de la lista. Si el revisor no es un miembro del proyecto, proporciona el nombre, email y si es el caso de ports un rol externo como el de mantenedor:</p></div><div class=paragraph><p>Revisado por un desarrollador:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Reviewed by: username</code></pre></div></div><div class=paragraph><p>Revisado por un mantenedor de ports que no es un desarrollador:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Reviewed by: Full Name &lt;valid@email&gt; <span class=o>(</span>maintainer<span class=o>)</span></code></pre></div></div></div></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>Tested by:</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>El nombre y dirección de correo de la persona o personas que probaron el cambio; para desarrolladores, sólo el nombre de usuario en el clúster de FreeBSD.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>Approved by:</code></p></td><td class="tableblock halign-left valign-top"><div class=content><div class=paragraph><p>El nombre y la dirección de correo de la persona o personas que aprobaron el cambio; para desarrolladores el nombre de usuario en el clúster de FreeBSD.</p></div><div class=paragraph><p>Hay varios casos donde se suele necesitar aprobación:</p></div><div class=ulist><ul><li><p>cuando un committer todavía está bajo tutorización</p></li><li><p>commits en un are del árbol cubierto bajo el fichero LOCKS (srv)</p></li><li><p>durante el ciclo de liberación</p></li><li><p>hacer commit a un repo en el que no tienes commit bit (por ejemplo un committer de src haciendo commit en docs)</p></li><li><p>hacer commit a un port que mantenga otra persona</p></li></ul></div><div class=paragraph><p>Mientras estés aprendiendo, obtén aprobación de tu mentor antes de hacer commit. Introduce el nombre de usuario del mentor en este cambio y haz referencia a que es un mentor:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Approved by: username-of-mentor <span class=o>(</span>mentor<span class=o>)</span></code></pre></div></div><div class=paragraph><p>Si los commits los aprueba un grupo incluye el nombre del grupo seguido del nombre de usuario entre paréntesis de la persona que aprobó. Por ejemplo:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Approved by: re <span class=o>(</span>username<span class=o>)</span></code></pre></div></div></div></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>Obtained from:</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>El nombre el proyecto (si aplica) del que se obtuvo el código. No uses esta línea para el nombre de una persona individual.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>Fixes:</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>El hash corto de Git y la línea de título del commit que se arregla con este cambio tal y como lo devuelve <code>git log -n 1 --oneline GIT-COMMIT-HASH</code>.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>MFC after:</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Para recibir un correo con un recordatorio para hacer MFC posteriormente, especifica el número de días, semanas o meses después de los cuales se planea hacer el MFC.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>MFC to:</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Si el commit se debe mergear a un subconjunto de ramas estables, especifica los nombres de las ramas.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>MFH:</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Si el commit se debe mergear a una rama trimestral de ports, especifica la rama trimestral. Por ejemplo <code>2021Q2</code>.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>Relnotes:</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Si el cambio es candidato para inclusión en las notas de la versión para la siguiente versión de la rama, establece el campo a <code>yes</code>.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>Security:</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Si el cambio está relacionado con una vulnerabilidad de seguridad o riesgo de seguridad, incluye una o más referencias o una descripción del problema. Si es posible incluye una URL de VuXML o un ID de CVE.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>Event:</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>La descripción del evento donde se hizo este commit. Si es un evento recurrente, añade el año o incluso el mes. Por ejemplo, podría ser <code>FooBSDcon 2019</code>. La idea de esta línea es darle reconocimiento a las conferencias, reuniones y otro tipo de encuentros y mostrar que son útiles. Por favor no utilices la línea <code>Sponsored by:</code> para esto ya que se utiliza para organizaciones que son patrocinadores de ciertas características o de desarrolladores que trabajan en ellas.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>Sponsored by:</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Organizaciones que patrocinan este cambio, si aplica. Separa varias organizaciones con comas. Si sólo se patrocinó una parte del trabajo, o distintos autores patrocinaron a distintos niveles, por favor, da el crédito apropiado entre paréntesis después de cada nombre de los patrocinadores. Por ejemplo, <code>Example.com (alice, refactorización de código), Wormulon (bob), Momcorp (cindy)</code> muestra que Alice fue patrocinada por Example.com para hacer refactorización de código, mientras que Wormulon patrocinó el trabajo de Bob y Momcorp patrocinó el trabajo de Cindy. Otros autores o no fueron patrocinados o escogieron no listar dicho patrocinio.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>Pull Request:</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Este cambio fue enviado como una pull request o merge request contra uno de los repositorios Git de sólo lectura de FreeBSD.
Debería incluir la URL completa de la pull request, ya que normalmente sirve para hacer la revisión del código.
Por ejemplo: <code><a href=https://github.com/freebsd/freebsd-src/pull/745 class=bare>https://github.com/freebsd/freebsd-src/pull/745</a></code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>Co-authored-by:</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>The name and email address of an additional author of the commit.
GitHub has a detailed description of the Co-authored-by trailer at <a href=https://docs.github.com/en/pull-requests/committing-changes-to-your-project/creating-and-editing-commits/creating-a-commit-with-multiple-authors class=bare>https://docs.github.com/en/pull-requests/committing-changes-to-your-project/creating-and-editing-commits/creating-a-commit-with-multiple-authors</a>.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>Signed-off-by:</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>El ID certifica que cumple con <a href=https://developercertificate.org/ class=bare>https://developercertificate.org/</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>Differential Revision:</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>La URL completa de la revisión de Phabricator. Esta línea <em>debe ser la última línea</em>. Por ejemplo: <code><a href=https://reviews.freebsd.org/D1708 class=bare>https://reviews.freebsd.org/D1708</a></code>.</p></td></tr></tbody></table><div class=exampleblock><div class=title>Ejemplo 4. Registro de compromiso para un compromiso basado en un PR</div><div class=content><div class=paragraph><p>El commit se basa en un parche en un PR enviado por John Smith. El cambio "PR" del mensaje de commit está relleno.</p></div><div class="literalblock programlisting"><div class=content><pre>...

PR:		12345</pre></div></div><div class=paragraph><p>El committer establece el autor del parche con <code>git commit --author "John Smith &lt;<a href=mailto:John.Smith@example.com>John.Smith@example.com</a>>"</code>.</p></div></div></div><div class=exampleblock><div class=title>Ejemplo 5. Confirmar registro para una confirmación que necesita revisión</div><div class=content><div class=paragraph><p>Se está cambiando el sistema de memoria virtual. Después de publicar los parches en la lista de correo correspondiente (en este caso, <code>freebsd-arch</code>) y los cambios han sido aprobados.</p></div><div class="literalblock programlisting"><div class=content><pre>...

Reviewed by:	-arch</pre></div></div></div></div><div class=exampleblock><div class=title>Ejemplo 6. Registro de compromiso para un compromiso que necesita aprobación</div><div class=content><div class=paragraph><p>HAcer un commit de un port, después de trabajar con el MAINTAINER, quien dio el visto bueno para hacer el commit.</p></div><div class="literalblock programlisting"><div class=content><pre>...

Approved by:	abc (maintainer)</pre></div></div><div class=paragraph><p>Donde <em>abc</em> es el nombre de la cuenta de la persona que lo aprobó.</p></div></div></div><div class=exampleblock><div class=title>Ejemplo 7. Commit Log para una confirmación que trae código desde OpenBSD</div><div class=content><div class=paragraph><p>Hacer commit de código basado en el trabajo realizado en el proyecto OpenBSD.</p></div><div class="literalblock programlisting"><div class=content><pre>...

Obtained from:	OpenBSD</pre></div></div></div></div><div class=exampleblock><div class=title>Ejemplo 8. Commit Log para un cambio en FreeBSD-CURRENT con un compromiso planificado en FreeBSD-STABLE para seguir en una fecha posterior.</div><div class=content><div class=paragraph><p>Haciendo commit de un código que se fusionará de FreeBSD-CURRENT en la rama FreeBSD-STABLE después de dos semanas.</p></div><div class="literalblock programlisting"><div class=content><pre>...

MFC after:	2 weeks</pre></div></div><div class=paragraph><p>Donde <em>2</em> es el número de días, semanas, o meses después de los cuales se planea hacer un MFC. La opción <em>weeks</em> podría ser <code>day</code>, <code>days</code>, <code>week</code>, <code>weeks</code>, <code>month</code>, <code>months</code>.</p></div></div></div><div class=paragraph><p>A menudo es necesario combinarlos.</p></div><div class=paragraph><p>Considera la situación en la que un usuario ha enviado un PR que contiene código del proyecto NetBSD. Mirando el PR, el desarrollador ve que no es un área del árbol en la que trabaja habitualmente de forma que se solicita que el cambio sea revisado por la lista de correo <code>arch</code>. Como el cambio es complejo, el desarrollador opta por hacer MFC después de un mes para permitir que se hagan las pruebas adecuadas.</p></div><div class=paragraph><p>La información adicional para incluir en la confirmación sería algo así como</p></div><div class=exampleblock><div class=title>Ejemplo 9. Ejemplo de Registro de Commit Combinado</div><div class=content><div class="literalblock programlisting"><div class=content><pre>PR:		54321
Reviewed by:	-arch
Obtained from:	NetBSD
MFC after:	1 month
Relnotes:	yes</pre></div></div></div></div></div></div></div><div class=sect1><h2 id=pref-license>10. Licencia preferida para los nuevos archivos<a class=anchor href=#pref-license></a></h2><div class=sectionbody><div class=paragraph><p>La política completa de licencias del Proyecto FreeBSD se puede encontrar en <a href=https://www.FreeBSD.org/internal/software-license/>https://www.FreeBSD.org/internal/software-license</a>. El resto de esta sección está pensada para ponerte en funcionamiento. Como regla, cuando tengas dudas, pregunta. Es mucho más fácil dar consejo que arreglar el árbol de fuentes.</p></div><div class=paragraph><p>El Proyecto FreeBSD sugiere y usa este texto como el esquema de licencia preferido:</p></div><div class="literalblock programlisting"><div class=content><pre>/*-
 * SPDX-License-Identifier: BSD-2-Clause
 *
 * Copyright (c) [year] [your name]
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS&#39;&#39; AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * [id for your version control system, if any]
 */</pre></div></div><div class=paragraph><p>El proyecto FreeBSD desaconseja rotundamente la denominada "cláusula publicitaria" en el nuevo código. Debido a la gran cantidad de colaboradores al proyecto FreeBSD, cumplir con esta cláusula para muchos proveedores comerciales se ha vuelto difícil. Si tienes código en el árbol con la cláusula publicitaria, considera eliminarlo. De hecho, considera usar la licencia anterior para tu código.</p></div><div class=paragraph><p>El proyecto FreeBSD desaconseja licencias completamente nuevas y variaciones de las licencias estándar. Las nuevas licencias requieren la aprobación del <a href=mailto:core@FreeBSD.org>core@FreeBSD.org</a> para que se añadan al repositorio <code>src</code>. Cuantas más licencias diferentes se utilicen en el árbol, más problemas ocasionará a quienes deseen utilizar este código, por lo general debido a las consecuencias no deseadas de una licencia mal redactada.</p></div><div class=paragraph><p>La política del proyecto dicta que el código de algunas licencias que no sean BSD debe colocarse solo en secciones específicas del repositorio y, en algunos casos, la compilación debe ser condicional o incluso deshabilitada de forma predeterminada. Por ejemplo, el núcleo GENERIC debe compilarse únicamente bajo licencias idénticas o sustancialmente similares a la licencia BSD. El software con licencia GPL, APSL, CDDL, etc., no debe compilarse en GENERIC.</p></div><div class=paragraph><p>Se recuerda a los desarrolladores que en el código abierto, conseguir "abrir" correctamente es tan importante como conseguir una "fuente" correcta, ya que el manejo inadecuado de la propiedad intelectual tiene graves consecuencias. Cualquier pregunta o inquietud debe comunicarse inmediatamente al Core Team.</p></div></div></div><div class=sect1><h2 id=tracking.license.grants>11. Seguimiento de las licencias concedidas al proyecto FreeBSD<a class=anchor href=#tracking.license.grants></a></h2><div class=sectionbody><div class=paragraph><p>Existen varias piezas de software y datos en los repositorios para los cuales se ha concedido al proyecto FreeBSD una licencia especial de uso. Un caso de ejemplo es la fuente Terminus para utilizar con <a href="https://man.freebsd.org/cgi/man.cgi?query=vt&amp;sektion=4&amp;format=html">vt(4)</a>. Aquí el autor Dimitar Zhekov nos ha permitido utilizar la fuente "Terminus BSD Console" bajo una licencia BSD de dos cláusulas en lugar de las licencia regular Open Font License que utiliza é normalmente.</p></div><div class=paragraph><p>Conviene claramente mantener un registro de dichas concesiones de licencias. Para tal fin, <a href=mailto:core@FreeBSD.org>core@FreeBSD.org</a> ha decidido mantener un archivo de ellas. Cuando se le otorga al proyecto FreeBSD una licencia especial, obligamos a que se notifique a <a href=mailto:core@FreeBSD.org>core@FreeBSD.org</a>. A cualquier desarrollador involucrado en acordar dichas concesiones de licencia, por favor, envía los detalles a <a href=mailto:core@FreeBSD.org>core@FreeBSD.org</a> incluyendo:</p></div><div class=ulist><ul><li><p>Datos de contacto de personas u organizaciones que otorgan la licencia especial.</p></li><li><p>Qué archivos, directorios, etc. de los repositorios están cubiertos por la concesión de licencia, incluidos los números de revisión donde se comprometió cualquier material con licencia especial.</p></li><li><p>La fecha en que la licencia entra en vigor. A menos que se acuerde lo contrario, esta será la fecha en que la licencia fue emitida por los autores del software en cuestión.</p></li><li><p>El texto de la licencia.</p></li><li><p>Una nota de cualquier restricción, limitación o excepción que se aplique específicamente al uso de FreeBSD del material licenciado.</p></li><li><p>Cualquier otra información relevante.</p></li></ul></div><div class=paragraph><p>Una vez que <a href=mailto:core@FreeBSD.org>core@FreeBSD.org</a> está satisfecho con todos los detalles necesarios que se han recopilado y que estos son correctos, el secretario enviará un acuse de recibo firmado con PGP que incluye los detalles de la licencia. Este recibo se almacenará de forma persistente y servirá como registro permanente de la concesión de la licencia.</p></div><div class=paragraph><p>El archivo de licencias sólo debería contener detalles de las concesiones de licencias; no es lugar para discusiones acerca de licencias en sí u otros asuntos. El acceso a los datos del fichero de licencias estará disponible bajo petición al <a href=mailto:core@FreeBSD.org>core@FreeBSD.org</a>.</p></div></div></div><div class=sect1><h2 id=spdx.tags>12. Etiquetas SPDX en el árbol<a class=anchor href=#spdx.tags></a></h2><div class=sectionbody><div class=paragraph><p>El proyecto utiliza etiquetas <a href=https://spdx.dev>SPDX</a> en nuestra base de fuentes. En este momento, las etiquetas están indentadas para ayudar a las herramientas automáticas a reconstruir los requisitos de las licencias mecánicamente. Todas las etiquetas <em>SPDX-License-Identifier</em> en el árbol deberían considerarse informativas. Todos los ficheros en el árbol de fuentes de FreeBSD con estas etiquetas también tienen una copia de la licencia de gobierna el uso de dicho fichero. En el caso de alguna discrepancia, la licencia literal es la que domina. El proyecto intenta seguir la <a href=https://spdx.github.io/spdx-spec/>SPDX Specification, Version 2.2</a>. Se puede ver cómo crear ficheros fuente y expresiones algebraicas válidas en <a href=https://spdx.github.io/spdx-spec/appendix-IV-SPDX-license-expressions/>Appendix IV</a> y <a href=https://spdx.github.io/spdx-spec/appendix-V-using-SPDX-short-identifiers-in-source-files/>Appendix V</a>. El proyecto extrae identificadores de la lista de <a href=https://spdx.org/licenses/>identificadores cortos de licencias</a> de SPDX. El proyecto sólo utiliza la etiqueta <em>SPDX-License-Identifier</em>.</p></div><div class=paragraph><p>A fecha de Marzo de 2021, se han marcado aproximadamente 25,000 de los 90,000 ficheros en el árbol.</p></div></div></div><div class=sect1><h2 id=developer.relations>13. Relaciones con los desarrolladores<a class=anchor href=#developer.relations></a></h2><div class=sectionbody><div class=paragraph><p>Cuando trabajes directamente en tu propio código o en un código que ya está bien establecido como tu responsabilidad, entonces probablemente haya poca necesidad de verificar con otros committers antes de hacer un commit. Cuandoo trabajes en un arreglo para un error en un área del sistema que está claramente huérfana (y hay algunas áreas de este tipo, para nuestra vergüenza), se aplica lo mismo. Cuando modifiques partes del sistema que se mantienen, formal o informalmente, considera solicitar una revisión tal como lo haría un desarrollador antes de convertirse en un committer. Para ports, contacta con el <code>MAINTAINER</code> que aparece listado en el <span class=filename>Makefile</span>.</p></div><div class=paragraph><p>Para determinar si se mantiene un área del árbol, consulta el archivo MAINTAINERS en la raíz del árbol. Si no aparece nadie, escanea el historial de revisiones para ver quién ha realizado cambios en el pasado. Para listar los nombres y direcciones de correo de todos los autores de commits de un fichero concreto en los dos últimos años y el número de commits de cada autor, ordenado por número descendente de commits, usa:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% git <span class=nt>-C</span> /path/to/repo shortlog <span class=nt>-sne</span> <span class=nt>--since</span><span class=o>=</span><span class=s2>&#34;2 years&#34;</span> <span class=nt>--</span> relative/path/to/file</code></pre></div></div><div class=paragraph><p>Si las consultas quedan sin respuesta o el committer de otro modo indica una falta de interés en el área afectada, continúa adelante y realiza el commit.</p></div><div class="admonitionblock important"><table><tbody><tr><td class=icon><i class="fa icon-important" title=Important></i></td><td class=content><div class=paragraph><p>Evita enviar correos electrónicos privados a los mantenedores. Otras personas podrían estar interesadas en la conversación, no sólo en el resultado final.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Si hay alguna duda sobre un commit por cualquier motivo, hazlo revisar antes de realizar el commit. Es mejor que reciba críticas en ese mismo momento que cuando es parte del repositorio. Si un commit da lugar a que surja una controversia, puede ser aconsejable considerar deshacer el cambio hasta que se resuelva el asunto. Recuerda, con un sistema de control de versiones siempre podemos volver a cambiarlo.</p></div><div class=paragraph><p>No impugnes las intenciones de los demás. Si ven una solución diferente a un problema, o incluso un problema diferente, probablemente no sea porque sean estúpidos, porque tienen una paternidad cuestionable o porque están tratando de destruir el trabajo duro, la imagen personal o FreeBSD, sino básicamente porque tienen una perspectiva diferente del mundo. Diferente es bueno.</p></div><div class=paragraph><p>Discrepa de forma honesta. Argumenta tu posición desde sus méritos, sé honesto acerca de cualquier deficiencia que puedas tener y mantente abierto a ver su solución, o incluso su visión del problema, con una mente abierta.</p></div><div class=paragraph><p>Acepta la corrección. Todos cometemos errores. Cuando hayas cometido un error, discúlpate y sigue con tu vida. No te castigues a ti mismo, y ciertamente no castigues a otros por tu error. No pierdas el tiempo en vergüenza o recriminación, simplemente soluciona el problema y sigue adelante.</p></div><div class=paragraph><p>Pide ayuda. Busca (y proporciona) revisiones de pares. Una de las formas en que se supone que el software de código abierto sobresale es en la cantidad de ojos que se le aplican; esto no se aplica si nadie revisa el código.</p></div></div></div><div class=sect1><h2 id=if-in-doubt>14. Si tienes dudas …​<a class=anchor href=#if-in-doubt></a></h2><div class=sectionbody><div class=paragraph><p>Cuando no estés seguro de algo, ya sea un problema técnico o una convención del proyecto, asegúrate de preguntar. Si te quedas en silencio, nunca progresarás.</p></div><div class=paragraph><p>Si se relaciona con un problema técnico, pregunta en las listas de correo públicas. Evita la tentación de enviar un correo electrónico a la persona que conoce la respuesta. De esta manera, todos podrán aprender de la pregunta y la respuesta.</p></div><div class=paragraph><p>Para preguntas administrativas o específicas del proyecto, pregunta, en orden:</p></div><div class=ulist><ul><li><p>Tu mentor o ex mentor.</p></li><li><p>Un cometer experimentado en IRC, correo electrónico, etc.</p></li><li><p>Cualquier equipo con "sombrero", ya que pueden darte una respuesta definitiva.</p></li><li><p>Si aún así no estás seguro, pregunta en Lista de correo de desarrolladores de FreeBSD.</p></li></ul></div><div class=paragraph><p>Una vez que se responda tu pregunta, si nadie te indicó la documentación que detalla la respuesta a tu pregunta, documenta, ya que otros tendrán la misma pregunta.</p></div></div></div><div class=sect1><h2 id=bugzilla>15. Bugzilla<a class=anchor href=#bugzilla></a></h2><div class=sectionbody><div class=paragraph><p>El proyecto FreeBSD utiliza Bugzilla para rastrear errores y solicitudes de cambio. Si haces un commit de un arreglo o una sugerencia que está en la base de datos de PR asegúrate de cerrarlo. También se considera bueno si te tomas tiempo para cerrar cualquier PR asociado con tus commits, si corresponde.</p></div><div class=paragraph><p>Committers sin una cuenta <code>FreeBSD.org</code> en Bugzilla pueden fusionar la antigua cuenta con su cuenta <code>FreeBSD.org</code> siguiendo los siguientes pasos:</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Inicie sesión con su cuenta anterior.</p></li><li><p>Abre un nuevo bug. Escoge <code>Services</code> como Product y <code>Bug Tracker</code> como Component. En la descripción del bug lista las cuentas que quieres fusionar.</p></li><li><p>Haz login utilizando la cuenta <code>FreeBSD.org</code> y haz un comentario en el bug recién abierto para confirmar la propiedad. Visita <a href=#kerberos-ldap>Kerberos y contraseña web LDAP para el clúster de FreeBSD</a> para más detalles sobre cómo generar o establecer una contraseña para tu cuenta <code>FreeBSD.org</code>.</p></li><li><p>Si hay más de dos cuentas para fusionar, publique comentarios de cada una de ellas.</p></li></ol></div></div></div><div class=paragraph><p>Puedes encontrar más acerca de Bugzilla en:</p></div><div class=ulist><ul><li><p><a href=https://docs.freebsd.org/es/articles/pr-guidelines/>FreeBSD Problem Report Handling Guidelines</a></p></li><li><p><a href=https://www.FreeBSD.org/support/>https://www.FreeBSD.org/support</a></p></li></ul></div></div></div><div class=sect1><h2 id=phabricator>16. Phabricator<a class=anchor href=#phabricator></a></h2><div class=sectionbody><div class=paragraph><p>El Proyecto FreeBSD utiliza <a href=https://reviews.freebsd.org>Phabricator</a> para las solicitudes de revisión de código. Visita la <a href=https://wiki.freebsd.org/Phabricator>página de la wiki de Phabricator</a> para más detalles.</p></div><div class=paragraph><p>Committers sin una cuenta <code>FreeBSD.org</code> en Phabricator pueden fusionar la antigua cuenta con su cuenta <code>FreeBSD.org</code> siguiendo los siguientes pasos:</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Cambia tu cuenta de correo de Phabricator a tu dirección <code>FreeBSD.org</code>.</p></li><li><p>Abre un nuevo informe de error en nuestra base de datos usando tu cuenta <code>FreeBSD.org</code>, visita <a href=#bugzilla>Bugzilla</a> para más información. Escoge <code>Services</code> como Product y <code>Code Review</code> como Component. En la descripción del bug solicita que se renombre tu cuenta de Phabricator y proporciona un enlace a tu usuario de Phabricator. Por ejemplo, <code><a href=https://reviews.freebsd.org/p/bob_example.com/ class=bare>https://reviews.freebsd.org/p/bob_example.com/</a></code></p></li></ol></div></div></div><div class="admonitionblock important"><table><tbody><tr><td class=icon><i class="fa icon-important" title=Important></i></td><td class=content><div class=paragraph><p>Las cuentas de Phabricator no se pueden fusionar, por favor no abras una cuenta nueva.</p></div></td></tr></tbody></table></div></div></div><div class=sect1><h2 id=people>17. Quien es Quien<a class=anchor href=#people></a></h2><div class=sectionbody><div class=paragraph><p>Además de los meisters del repositorio, hay otros miembros y equipos del proyecto FreeBSD a los que probablemente conocerá en su rol de committer. Brevemente, y de ninguna manera todo incluido, estos son:</p></div><div class=dlist><dl><dt class=hdlist1><code>Grupo de Ingeniería de Documentación &lt;<a href=mailto:doceng@FreeBSD.org>doceng@FreeBSD.org</a>></code></dt><dd><p>doceng es el grupo responsable de la infraestructura de construcción de documentación, aprobar nuevos committers de documentación, y asegurar que el sitio web de FreeBSD y la documentación en el sitio FTP están actualizados respecto del árbol de Subversion. No es un órgano de resolución de conflictos. La mayoría de las discusiones relacionadas con documentación tienen lugar en <a href=https://lists.FreeBSD.org/subscription/freebsd-doc>Lista de correo del proyecto de documentación de FreeBSD</a>. Se pueden encontrar más detalles acerca del equipo de doceng en su <a href=https://www.FreeBSD.org/internal/doceng/>charter</a>. Los committers interesados en contribuir a la documentación se deberían familiarizar con el <a href=https://docs.freebsd.org/en/books/fdp-primer/>Documentation Project Primer</a>.</p></dd><dt class=hdlist1><code>Konstantin Belousov &lt;<a href=mailto:kib@FreeBSD.org>kib@FreeBSD.org</a>>, Dave Cottlehuber &lt;<a href=mailto:dch@FreeBSD.org>dch@FreeBSD.org</a>>, Marc Fonvieille &lt;<a href=mailto:blackend@FreeBSD.org>blackend@FreeBSD.org</a>>, John Hixson &lt;<a href=mailto:jhixson@FreeBSD.org>jhixson@FreeBSD.org</a>>, Xin Li &lt;<a href=mailto:delphij@FreeBSD.org>delphij@FreeBSD.org</a>>, Ed Maste &lt;<a href=mailto:emaste@FreeBSD.org>emaste@FreeBSD.org</a>>, Mahdi Mokhtari &lt;<a href=mailto:mmokhi@FreeBSD.org>mmokhi@FreeBSD.org</a>>, Colin Percival &lt;<a href=mailto:cperciva@FreeBSD.org>cperciva@FreeBSD.org</a>>, Doug Rabson &lt;<a href=mailto:dfr@FreeBSD.org>dfr@FreeBSD.org</a>>, Muhammad Moinur Rahman &lt;<a href=mailto:bofh@FreeBSD.org>bofh@FreeBSD.org</a>></code></dt><dd><p>Estos son los miembros del equipo de ingeniería de versiones <code>Grupo de Ingeniería de Releases &lt;<a href=mailto:re@FreeBSD.org>re@FreeBSD.org</a>></code>. Este equipo es responsable de establecer los plazos de publicación y controlar el proceso de publicación. Durante la congelación del código, los ingenieros de versiones tienen la autoridad final sobre todos los cambios en el sistema para cualquier rama que tenga el estado de versión pendiente. Si hay algo que quieras incluir de FreeBSD-CURRENT a FreeBSD-STABLE (independientemente de los valores que puedan tener en un momento dado), estas son las personas con las que hablar al respecto.</p></dd><dt class=hdlist1><code>Gordon Tetlow &lt;<a href=mailto:gordon@FreeBSD.org>gordon@FreeBSD.org</a>></code></dt><dd><p><code>Gordon Tetlow</code> es el <a href=https://www.FreeBSD.org/security/>FreeBSD Security Officer</a> y supervisa el <code>Grupo Responsables de Seguridad &lt;<a href=mailto:security-officer@FreeBSD.org>security-officer@FreeBSD.org</a>></code>.</p></dd><dt class=hdlist1>Lista de correo para 'committers' de FreeBSD</dt><dd><p>{dev-src-all}, {dev-ports-all} y {dev-doc-all} son las listas de correo que utiliza el sistema de control de versiones para mandar mensajes de commit. <em>Nunca</em> envíes correo directamente a esas listas. Envía sólo respuestas a esta lista cuando son cortas y directamente relacionadas con un commit.</p></dd><dt class=hdlist1>Lista de correo de desarrolladores de FreeBSD</dt><dd><p>Todos los committers están suscritos a -developers. Esta lista se creó como un foro para los asuntos relacionados con la "communidad" de committers. Ejemplos son las votaciones de Core, anuncios, etc.</p><div class=paragraph><p>La Lista de correo de desarrolladores de FreeBSD es de uso exclusivo de los committers de FreeBSD. Para desarrollar FreeBSD, los committers deben tener la capacidad de discutir asuntos abiertamente que se resolverán antes de que sean anunciados públicamente. Discusiones con franqueza sobre el trabajo en curso no son aptas para la publicación abierta y podrían dañar a FreeBSD.</p></div><div class=paragraph><p>Se espera que todos los committers de FreeBSD no publiquen ni reenvíen mensajes de la lista de correo de desarrolladores de FreeBSD fuera de la membresía de la lista sin el permiso de todos los autores. Los infractores serán eliminados de la lista de correo de desarrolladores de FreeBSD, lo que resultará en la suspensión de los privilegios de commit. Las violaciones repetidas o flagrantes pueden resultar en la revocación permanente de los privilegios de commit.</p></div><div class=paragraph><p>Esta lista <em>no</em> está pensada como un sito para hacer revisiones de código o para otras cuestiones técnicas. De hecho utilizarla para eso daña el Proyecto FreeBSD ya que le da un aire de lista cerrada donde las decisiones que afectan a toda la comunidad que usa FreeBSD no se hacen de forma "abierta". Por último, pero no menos importante, nunca, nunca, nunca, mandes un correo a {developers-mail} y pongas en CC:/BCC: a otra lista de FreeBSD. Nunca, nunca envíes correo a otra lista de correo de FreeBSD con CC:/BCC: a la Lista de correo de desarrolladores de FreeBSD. Hacerlo puede disminuir los beneficios de esta lista.</p></div></dd></dl></div></div></div><div class=sect1><h2 id=ssh.guide>18. Guía de inicio rápido de SSH<a class=anchor href=#ssh.guide></a></h2><div class=sectionbody><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Si no quieres escribir tu contraseña cada vez que uses <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh&amp;sektion=1&amp;format=html">ssh(1)</a>, y utilizas claves para autenticar, <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-agent&amp;sektion=1&amp;format=html">ssh-agent(1)</a> está aquí para ayudarte. Si quieres usar <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-agent&amp;sektion=1&amp;format=html">ssh-agent(1)</a>, asegúrate de ejecutarlo antes que otras aplicaciones. Los usuarios de X, por ejemplo, normalmente hacen esto en su <span class=filename>.xsession</span> o <span class=filename>.xinitrc</span>. Lee <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-agent&amp;sektion=1&amp;format=html">ssh-agent(1)</a> para más detalles.</p></li><li><p>Genera un par de claves con <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-keygen&amp;sektion=1&amp;format=html">ssh-keygen(1)</a>. El clave de pares terminará en tu directorio <span class=filename>$HOME/.ssh/</span>.</p><div class="admonitionblock important"><table><tbody><tr><td class=icon><i class="fa icon-important" title=Important></i></td><td class=content><div class=paragraph><p>Sólo se soportan claves ECDSA, Ed25519 o RSA.</p></div></td></tr></tbody></table></div></li><li><p>Envía tu clave pública (<span class=filename>$HOME/.ssh/id_ecdsa.pub</span>, <span class=filename>$HOME/.ssh/id_ed25519.pub</span>, o <span class=filename>$HOME/.ssh/id_rsa.pub</span>) a la persona que te está dando de alta como committer de forma que la pueda poner en <span class=filename>yourlogin</span> en <span class=filename>/etc/ssh-keys/</span> en <code>freefall</code>.</p></li></ol></div></div></div><div class=paragraph><p>Ahora se puede usar <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-add&amp;sektion=1&amp;format=html">ssh-add(1)</a> para autenticarse una vez por sesión. Solicita la frase de paso de la clave privada y después la almacena en el agente de autenticación (<a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-agent&amp;sektion=1&amp;format=html">ssh-agent(1)</a>). Utiliza <code>ssh-add -d</code> para eliminar las claves almacenadas en el agente.</p></div><div class=paragraph><p>Pruébalo con un comando remoto sencillo: <code>ssh freefall.FreeBSD.org ls /usr</code>.</p></div><div class=paragraph><p>Para más información, lee <a class=package href=https://cgit.freebsd.org/ports/tree/security/openssh-portable/>security/openssh-portable</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh&amp;sektion=1&amp;format=html">ssh(1)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-add&amp;sektion=1&amp;format=html">ssh-add(1)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-agent&amp;sektion=1&amp;format=html">ssh-agent(1)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-keygen&amp;sektion=1&amp;format=html">ssh-keygen(1)</a>, y <a href="https://man.freebsd.org/cgi/man.cgi?query=scp&amp;sektion=1&amp;format=html">scp(1)</a>.</p></div><div class=paragraph><p>Para información sobre cómo añadir, cambiar o eliminar claves <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh&amp;sektion=1&amp;format=html">ssh(1)</a>, lee <a href=https://wiki.freebsd.org/clusteradm/ssh-keys>este artículo</a>.</p></div></div></div><div class=sect1><h2 id=coverity>19. Disponibilidad de Coverity® para los Committers de FreeBSD<a class=anchor href=#coverity></a></h2><div class=sectionbody><div class=paragraph><p>Todos los desarrolladores de FreeBSD pueden obtener acceso a los resultados de análisis de Coverity para todo el software del Proyecto FreeBSD. Todo aquel que esté interesado en el acceso a los resultados de análisis de las ejecuciones automáticas de Coverity, pueden registrarse en <a href=http://scan.coverity.com/>Coverity Scan</a>.</p></div><div class=paragraph><p>La wiki de FreeBSD incluye una mini-guía para desarrolladores interesados en trabajar con los informes de análisis de Coverity®: <a href=https://wiki.freebsd.org/CoverityPrevent>https://wiki.freebsd.org/CoverityPrevent</a>. Por favor, ten en cuenta que esta mini-guía sólo es accesible para los desarrolladores de FreeBSD, así que si no puedes acceder a esta página, tendrás que pedirle a alguien que te añada a la lista de acceso apropiada de la Wiki.</p></div><div class=paragraph><p>Por último, a todos los desarrolladores de FreeBSD que vayan a usar Coverity® se les anima a preguntar por más detalles e información de uso, mediante el envío de preguntas a la lista de correo de desarrolladores de FreeBSD.</p></div></div></div><div class=sect1><h2 id=rules>20. La gran lista de reglas de los Committers de FreeBSD<a class=anchor href=#rules></a></h2><div class=sectionbody><div class=paragraph><p>Todo aquel involucrado en el proyecto FreeBSD debe seguir el <em>Código de Conducta</em> disponible en <a href=https://www.FreeBSD.org/internal/code-of-conduct/>https://www.FreeBSD.org/internal/code-of-conduct</a>. Como committer, tú eres la cara visible del proyecto y cómo te comportas tiene un impacto vital en la percepción pública del mismo. Esta guía expande las partes del <em>Código de Conducta</em> específicas para committers.</p></div><div class="olist arabic"><ol class=arabic><li><p>Respeta a los demás committers.</p></li><li><p>Respeta a otros colaboradores.</p></li><li><p>Discute cualquier cambio significativo <em>antes</em> de hacer commit.</p></li><li><p>Respeta los mantenedores que existan (si están listados en el campo <code>MAINTAINER</code> en <span class=filename>Makefile</span> o en <span class=filename>MAINTAINER</span> en el directorio raíz).</p></li><li><p>Cualquier cambio en disputa debe ser anulado en espera de la resolución de la disputa si lo solicita un mantenedor. Los cambios relacionados con la seguridad pueden anular los deseos del mantenedor a discreción del oficial de seguridad.</p></li><li><p>Los cambios van a FreeBSD-CURRENT antes de FreeBSD-STABLE a menos que el ingeniero de versiones lo permita específicamente o que no sean aplicables a FreeBSD-CURRENT. Cualquier cambio no trivial o no urgente que sea aplicable también debe permitirse que permanezca en FreeBSD-CURRENT durante al menos 3 días antes de fusionarse para que se puedan realizar las pruebas suficientes. El ingeniero de versiones tiene la misma autoridad sobre la rama FreeBSD-STABLE que se describe para el mantenedor en la regla # 5.</p></li><li><p>No luches en público con otros committers; se ve mal.</p></li><li><p>Respeta la congelación de código y lee las listas de correo de <code>committers</code> y <code>developers</code> regularmente de forma que sepas que hay una congelación de código en marcha.</p></li><li><p>En caso de duda sobre cualquier procedimiento, ¡pregunta primero!</p></li><li><p>Prueba tus cambios antes de realizarlos.</p></li><li><p>No hagas commit en software contribuido sin aprobación <em>explícita</em> de los respectivos mantenedores.</p></li></ol></div><div class=paragraph><p>Como se señaló anteriormente, romper algunas de estas reglas puede ser motivo de suspensión o, en caso de reincidencia, eliminación permanente de los privilegios de committer. Los miembros individuales de core tienen el poder de suspender temporalmente los privilegios de commit hasta que core en su conjunto tenga la oportunidad de revisar el problema. En caso de "emergencia" (un committer que daña el repositorio), los meisters del repositorio también pueden realizar una suspensión temporal. Solo una mayoría de 2/3 de core tiene la autoridad para suspender los privilegios de commit durante más de una semana o para eliminarlos permanentemente. Esta regla no existe para que core se convierta en un grupo de dictadores crueles que pueden deshacerse de los responsables de manera tan casual como las latas de refresco vacías, sino para darle al proyecto una especie de mecanismo de seguridad. Si alguien está fuera de control, es importante poder lidiar con esto de inmediato en lugar de quedar paralizado por el debate. En todos los casos, un comitter cuyos privilegios se suspenden o revocan tiene derecho a una "vista" ante core, determinándose en ese momento la duración total de la suspensión. Un committer cuyos privilegios estén suspendidos también puede solicitar una revisión de la decisión después de 30 días y cada 30 días a partir de entonces (a menos que el período total de suspensión sea inferior a 30 días). Un committer cuyos privilegios hayan sido revocados por completo puede solicitar una revisión después de que haya transcurrido un período de 6 meses. Esta política de revisión es "estrictamente informal" y, en todos los casos, core se reserva el derecho de actuar o ignorar las solicitudes de revisión si sienten que su decisión original es la correcta.</p></div><div class=paragraph><p>En todos los demás aspectos de la operación del proyecto, core es un subconjunto de committers y está vinculado por las <em>mismas reglas</em>. El hecho de que alguien esté en core no significa que tenga una dispensación especial para salir de cualquiera de las líneas pintadas aquí; los "poderes especiales" de core solo se activan cuando actúa como grupo, no de forma individual. Como individuos, los miembros del equipo central son todos committers primero y miembros de core en segundo lugar.</p></div><div class=sect2><h3 id=_detalles>20.1. Detalles<a class=anchor href=#_detalles></a></h3><div id=respect class="olist arabic"><ol class=arabic><li><p>Respeta a los demás committers.</p><div class=paragraph><p>Esto significa que debes tratar a los demás committers como los desarrolladores de grupos de iguales que son. A pesar de nuestros ocasionales intentos de demostrar lo contrario, uno no llega a committer siendo estúpido y nada irrita más que ser tratado de esa manera por uno de sus compañeros. Si siempre sentimos respeto por los demás o no (y todos tienen días libres), todavía tenemos que <em>tratar</em> a otros committers con respeto en todo momento, en foros públicos y en correos privados.</p></div><div class=paragraph><p>Poder trabajar juntos a largo plazo es el mayor activo de este proyecto, uno mucho más importante que cualquier conjunto de cambios en el código, y convertir los argumentos sobre el código en problemas que afectan nuestra capacidad a largo plazo para trabajar juntos en armonía simplemente no vale la pena. -abandonado por cualquier tramo concebible de la imaginación.</p></div><div class=paragraph><p>Para cumplir con esta regla, no envíes correos electrónicos cuando estés enfadado o te comportes de una manera que pueda parecer a los demás como una confrontación innecesaria. Primero cálmate, luego piensa en cómo comunicarte de la manera más efectiva para convencer a las otras personas de que tu lado del argumento es correcto, no te desahogues un poco para sentirte mejor en el corto plazo a costa de una guerra de llamas a largo plazo. No solo esto es una mala "economía energética", sino que las demostraciones repetidas de agresión pública que perjudican nuestra capacidad para trabajar bien juntos serán tratadas severamente por el liderazgo del proyecto y pueden resultar en la suspensión o terminación de tus privilegios de commit. El liderazgo del proyecto tendrá en cuenta tanto las comunicaciones públicas como las privadas que se le presenten. No buscará la divulgación de comunicaciones privadas, pero la tendrá en cuenta si es voluntaria por parte de los autores de la denuncia.</p></div><div class=paragraph><p>Todo esto nunca es una opción de la que disfrute en lo más mínimo el liderazgo del proyecto, pero la unidad es lo primero. Ninguna cantidad de código o buen consejo se puede cambiar por esta unidad.</p></div></li><li><p>Respeta a otros colaboradores.</p><div class=paragraph><p>No siempre fuiste un committer. Hubo un tiempo en que contribuiste. Recuerda eso en todo momento. Recuerda lo que fue tratar de obtener ayuda y atención. No olvides que tu trabajo como colaborador fue muy importante para ti. Recuerda cómo fue. No desanimes, menosprecies o hagas de menos a los voluntarios. Trátalos con respeto. Son nuestros committers en espera. Son tan importantes para el proyecto como los committers. Sus contribuciones son tan válidas e importantes como las tuyas. Después de todo, hiciste muchas contribuciones antes de convertirse en committer. Recuerda eso siempre.</p></div><div class=paragraph><p>Considera los puntos mencionados en <a href=#respect>Respeta a otros committers</a> y aplícalos también a los voluntarios.</p></div></li><li><p>Discute cualquier cambio significativo <em>antes</em> de hacer commit.</p><div class=paragraph><p>El repositorio no es donde los cambios se envían inicialmente para su corrección o para ser discutidos, eso ocurre primero en las listas de correo o mediante el uso del servicio Phabricator. El commit solo ocurrirá una vez que se haya alcanzado algo parecido al consenso. Esto no significa que se requiera permiso antes de corregir todos los errores de sintaxis obvios o errores ortográficos de la página del manual, solo que es bueno desarrollar una idea de cuándo un cambio propuesto no es tan obvio y requiere algunos comentarios primero. A la gente realmente no le importan los cambios radicales si el resultado es claramente mejor que lo que tenían antes, simplemente no les gusta ser <em>sorprendidos</em> por esos cambios. La mejor manera de asegurarse de que todo va por buen camino es hacer que el código sea revisado por uno o más committers.</p></div><div class=paragraph><p>En caso de duda, ¡solicite una revisión!</p></div></li><li><p>Respeta a los mantenedores existentes si están listados como tales.</p><div class=paragraph><p>Muchas partes de FreeBSD no tienen "dueño" en el sentido de que cualquier individuo saltará sobre ti y te gritará si haces un cambio en "su" área, pero aún así merece la pena comprobarlo primero. Una convención que usamos es poner una linea "maintainer" en el <span class=filename>Makefile</span> para cualquier paquete o subárbol que es mantenido de forma activa por una o más personas; visita see <a href=https://docs.freebsd.org/en/books/developers-handbook/#policies>Directrices y Políticas del Árbol de Fuentes</a> para obtener documentación sobre esto. Donde hay secciones de código con varios mantenedores, los commits efectuados por un mantenedor en dicha área deben ser revisados por al menos otro mantenedor. En los casos donde el mantenimiento de algo no está claro, mira los logs del repositorio para los ficheros en cuestión y mira si alguien ha estado trabajando recientemente o de forma predominante en esa área.</p></div></li><li><p>Cualquier cambio en disputa debe ser anulado en espera de la resolución de la disputa si lo solicita un mantenedor. Los cambios relacionados con la seguridad pueden anular los deseos del mantenedor a discreción del oficial de seguridad.</p><div class=paragraph><p>Esto puede ser difícil de aceptar en tiempos de conflicto (cuando cada parte está convencida de que tienen razón, por supuesto), pero un sistema de control de versiones hace innecesario tener una disputa en curso cuando es mucho más fácil simplemente revertir el cambio, para calmar a todos nuevamente y luego intentar averiguar cuál es la mejor manera de proceder. Si el cambio resulta ser lo mejor después de todo, se puede recuperar fácilmente. Si resulta que no es así, entonces los usuarios no tenían que vivir con el falso cambio en el árbol mientras todos debatían afanosamente sus méritos. La gente <em>muy</em> raramente pide deshacer cambios en el repositorio, ya que la discusión generalmente expone cambios malos o controvertidos incluso antes de que ocurra la confirmación, pero en ocasiones tan raras, el retroceso debe hacerse sin discutir para que podamos pasar inmediatamente al tema de resolver si era falso o no.</p></div></li><li><p>Los cambios van a FreeBSD-CURRENT antes de FreeBSD-STABLE a menos que el ingeniero de versiones lo permita específicamente o que no sean aplicables a FreeBSD-CURRENT. Cualquier cambio no trivial o no urgente que sea aplicable también debe permitirse que permanezca en FreeBSD-CURRENT durante al menos 3 días antes de fusionarse para que se puedan realizar las pruebas suficientes. El ingeniero de versiones tiene la misma autoridad sobre la rama FreeBSD-STABLE como se describe en la regla # 5.</p><div class=paragraph><p>Este es otro problema de tipo "no discutas sobre eso", ya que es el ingeniero de versiones el responsable en última instancia (y recibe una paliza) si un cambio resulta ser malo. Respeta esto y brinda al ingeniero de versiones tu total cooperación cuando se trata de la rama FreeBSD-STABLE. El manejo de FreeBSD-STABLE puede parecer con frecuencia demasiado conservador para el observador casual, pero también ten en cuenta el hecho de que se supone que el conservadurismo es el sello distintivo de FreeBSD-STABLE y que se aplican reglas diferentes a las de FreeBSD-CURRENT. Tampoco tiene sentido que FreeBSD-CURRENT sea un campo de pruebas si los cambios se fusionan con FreeBSD-STABLE inmediatamente. Los cambios necesitan la oportunidad de ser probados por los desarrolladores de FreeBSD-CURRENT, así que deja pasar un tiempo antes de fusionarlos, a menos que la corrección de FreeBSD-STABLE sea crítica, urgente o tan obvia como para hacer innecesarias más pruebas (corrección de errores / errores tipográficos, etc.) En otras palabras, aplica el sentido común.</p></div><div class=paragraph><p>Los cambios a las ramas de seguridad (por ejemplo, <code>releng/9.3</code>) deben ser aprobados por un miembro de <code>Grupo Responsables de Seguridad &lt;<a href=mailto:security-officer@FreeBSD.org>security-officer@FreeBSD.org</a>></code>, o en algunos casos, por un miembro de <code>Grupo de Ingeniería de Releases &lt;<a href=mailto:re@FreeBSD.org>re@FreeBSD.org</a>></code>.</p></div></li><li><p>No luches en público con otros committers; se ve mal.</p><div class=paragraph><p>Este proyecto tiene una imagen pública que defender y esa imagen es muy importante para todos nosotros, especialmente si queremos seguir atrayendo nuevos miembros. Habrá ocasiones en las que, a pesar de los mejores intentos de autocontrol de todos, se pierden los ánimos y se intercambian palabras de enojo. Lo mejor que se puede hacer en tales casos es minimizar los efectos de esto hasta que todos se hayan calmado de nuevo. No transmitas palabras de enojo en público y no reenvíes correspondencia privada u otras comunicaciones privadas a listas de correo públicas, alias de correo, canales de mensajería instantánea o sitios de redes sociales. Lo que la gente dice cara a cara a menudo está menos suavizado que lo que dirían en público y, por lo tanto, tales comunicaciones no tienen cabida allí; solo sirven para inflamar una situación que ya es mala. Si la persona que envía un mensaje incendiario al menos tuvo el detalle de enviarlo en privado, entonces ten el detalle de mantenerlo en privado. Si sientes que otro desarrollador te está tratando injustamente y te está causando angustia, plantea el asunto a Core en lugar de hacerlo público. Core hará todo lo posible para pacificar y hacer que las cosas vuelvan a la cordura. En los casos en que la disputa implique un cambio en la base de código y los participantes no parezcan estar llegando a un acuerdo amistoso, Core puede designar a un tercero de mutuo acuerdo para resolver la disputa. Todas las partes involucradas deben aceptar quedar vinculadas por la decisión tomada por este tercero.</p></div></li><li><p>Respeta todas las congelaciones de código y lee las listas de correo de <code>committers</code> y <code>developers</code> regularmente de forma que sepas cuando una congelación está en curso.</p><div class=paragraph><p>Realizar cambios no aprobados durante una congelación de código es un gran error y se espera que los committers se mantengan actualizados sobre lo que está sucediendo antes de saltar después de una larga ausencia y hacer commit de 10 megabytes de material acumulado. A las personas que abusen de esto de forma regular se les suspenderán sus privilegios de commit hasta que regresen del Happy Reeducation Camp de FreeBSD que llevamos a cabo en Groenlandia.</p></div></li><li><p>En caso de duda sobre cualquier procedimiento, ¡pregunta primero!</p><div class=paragraph><p>Cuando se tiene prisa se cometen muchos errores y simplemente asume que sabe la forma correcta de hacer algo. Si no lo has hecho antes, es muy probable que no sepas realmente la forma en que hacemos las cosas y realmente necesites preguntar primero o te avergonzarás por completo en público. No hay vergüenza en preguntar "¿Cómo diablos hago esto?" Ya sabemos que eres una persona inteligente; de lo contrario, no serías un committer.</p></div></li><li><p>Prueba tus cambios antes de realizarlos.</p><div class=paragraph><p>Si tus cambios son en el kernel, asegúrate de que aún puedes compilar tanto GENERIC como LINT. Si tus cambios están en cualquier otro lugar, asegúrate de que aún puedes compilar el resto del sistema (make world). Si tus cambios son en una rama, asegúrate de que la prueba se realice con una máquina que ejecute ese código. Si tienes un cambio que también puede romper otra arquitectura, asegúrate de probar en todas las arquitecturas compatibles. Por favor asegúrate de que tu cambio funciona para <a href=#compilers>supported toolchains</a>. Por favor dirígete a <a href=https://www.FreeBSD.org/internal/>FreeBSD Internal Page</a> para obtener una lista de los recursos disponibles. A medida que se agregan otras arquitecturas a la lista de plataformas compatibles con FreeBSD, los recursos de prueba compartidos apropiados estarán disponibles.</p></div></li><li><p>No hagas commit en software contribuido sin aprobación <em>explícita</em> de los respectivos mantenedores.</p><div class=paragraph><p>Código contribuido es cualquier cosa bajo los árboles <span class=filename>src/contrib</span>, <span class=filename>src/crypto</span>, o <span class=filename>src/sys/contrib</span>.</p></div><div class=paragraph><p>Los árboles mencionados anteriormente son para software contribuido generalmente importado a una rama de un proveedor. Hacer commit allí puede causar dolores de cabeza innecesarios al importar versiones más nuevas del software. En general, considera enviar parches directamente al proveedor. Los parches se pueden enviar a FreeBSD primero con el permiso del desarrollador.</p></div><div class=paragraph><p>Las razones para modificar el software en el proyecto original van desde querer un control estricto sobre una dependencia estrechamente acoplada hasta la falta de portabilidad en la distribución del código del repositorio canónico. Independientemente de la razón, el esfuerzo por minimizar la carga de mantenimiento de nuestra copia es útil para los compañeros mantenedores. Evita realizar cambios triviales o estéticos en los archivos, ya que hace que cada merge a partir de entonces sea más difícil: dichos parches deben volver a verificarse manualmente en cada importación.</p></div><div class=paragraph><p>Si un trozo particular de software no tienen mantenedor, se te anima a que tomes propiedad del mismo. Si no estás seguro del estado actual del mantenimiento del código envía un correo a <a href=https://lists.FreeBSD.org/subscription/freebsd-arch>Lista sobre arquitectura y diseño de FreeBSD</a> y pregunta.</p></div></li></ol></div></div><div class=sect2><h3 id=_política_sobre_arquitecturas_múltiples>20.2. Política sobre arquitecturas múltiples<a class=anchor href=#_política_sobre_arquitecturas_múltiples></a></h3><div class=paragraph><p>FreeBSD ha añadido varias arquitecturas nuevas durante los últimos ciclos de lanzamiento y ya no es en realidad un sistema operativo centrado en i386™. En un esfuerzo por hace más fácil el poder mantener FreeBSD portable en las distintas plataformas que soportamos, Core ha desarrollado esta exigencia:</p></div><div class="paragraph blockquote"><p>Nuestra plataforma de referencia de 32 bits es i386 y nuestra plataforma de referencia de 64 bits es amd64. El trabajo de diseño importante (incluidos los cambios importantes de API y ABI) debe demostrar su valía en al menos una plataforma de 32 bits y al menos una de 64 bits, preferiblemente las plataformas de referencia primarias, antes de que se pueda hacer commit en el árbol de fuentes.</p></div><div class=paragraph><p>Los desarrolladores también deben conocer nuestra Política de Niveles para el soporte a largo plazo de arquitecturas de hardware. Las reglas aquí están destinadas a proporcionar una guía durante el proceso de desarrollo y son distintas de los requisitos para las características y arquitecturas enumeradas en esa sección. Las reglas de nivel para el soporte de características en arquitecturas en el momento del lanzamiento son más estrictas que las reglas de cambios durante el proceso de desarrollo.</p></div></div><div class=sect2><h3 id=compilers>20.3. Política sobre Múltiples Compiladores<a class=anchor href=#compilers></a></h3><div class=paragraph><p>FreeBSD compila tanto con Clang como con GCC. El proyecto hace esto de forma cuidadosa y controlada para maximizar los beneficios de este trabajo extra, a la vez que mantiene el trabajo extra en mínimos. Suportar tanto Clang como GCC mejora la flexibilidad que tienen nuestros usuarios. Estos compiladores tienen distintas fortalezas y debilidades, y soportar ambos permite a los usuarios escoger el que mejor se adapta a sus necesidades. Clang y GCC soportan dialectos similares de C y C++, necesitándose una cantidad relativamente pequeña de código condicional. El proyecto gana más cobertura de código y mejora la calidad del código usando características de ambos compiladores. El proyecto es capaz de compilar en más entornos de usuario y aprovechar más entornos de CI al soportar este rango, incrementando las ventajas para los usuarios y dándoles más herramientas con las que probar. Mediante la restricción cuidadosa de las versiones modernas soportadas en estos compiladores, el proyecto evita incrementar la matriz de pruebas sin necesidad. Los compiladores más viejos y oscuros, así como dialectos más antiguos de los lenguajes, tienen un soporte extremadamente limitado que permite a los programas de usuarios compilar con ellos, pero sin limitar a que el sistema base se compile con ellos. El equilibro exacto está en constante evolución para asegurar que los beneficios del trabajo extra son mayores que la carga que imponen. El proyecto solía soportar compiladores de Intel realmente antiguos o versiones antiguas de GCC, pero cambiamos soportar esos compiladores obsoletos por una selección cuidadosas de compiladores modernos. Esta sección documenta dónde usamos los diferentes compiladores, y las expectativas al respecto.</p></div><div class=paragraph><p>El proyecto FreeBSD incorpora el compilador Clang. Debido a que está en el árbol, este es el compilador mejor soportado. Todos los cambios tienen que compilar con él, antes de hacer el commit. Las comprobaciones completas, como sean apropiadas para el cambio, se deberían hacer con este compilador.</p></div><div class=paragraph><p>En cualquier momento, el proyecto FreeBSD también soporta uno o más compiladores fuera del árbol. En este momento, esto es GCC 12.x. Idealemente, los committers deberían compilar con este compilador, especialmente para cambios grandes o arriesgados. El compilador está disponible como el paquete <code>${TARGET_ARCH}-gcc${VERSION}</code> como <a class=package href=https://cgit.freebsd.org/ports/tree/devel/freebsd-gcc12/>aarch64-gcc12</a> o <a class=package href=https://cgit.freebsd.org/ports/tree/devel/freebsd-gcc12/>riscv64-gcc12</a>. El proyecto ejecuta trabajos automáticos de CI para compilar todo con estos compiladores. Se espera que los committers arreglen los trabajos que se rompan con sus cambios. Los committers pueden probar la compilación con, por ejemplo <code>CROSS_TOOLCHAIN=aarch64-gcc12</code> o <code>CROSS_TOOLCHAIN=llvm15</code> cuando sea necesario.</p></div><div class=paragraph><p>El proyecto FreeBSD también tiene algunos pipelines de CI en github. Para las pull requests en github y algunas ramas empujadas a los forks de github, se ejecutan algunos trabajos de compilación cruzada. Estos comprueba la compilación de FreeBSD usando una versión de Clang que a veces durante un tiempo está una versión por delante de la versión incluida en el árbol.</p></div><div class=paragraph><p>El proyecto FreeBSD también actualiza los compiladores. Tanto Clang como GCC se cambian constantemente. Algunos cambios en el árbol, por ejemplo eliminando las declaraciones y definiciones de funciones en estilo antiguo K&amp;R, se introducirán en el árbol antes de cambiar el compilador. Los committers deberían tratar de ser conscientes de esto y ser receptivos a la hora de analizar problemas con su código o cambios con estos nuevos compiladores. Además, justo después de que se ha introducido una nueva versión del compilador en el árbol, la gente necesita compilar con la versión antigua si se sospecha que ha habido una regresión no detectada.</p></div><div class=paragraph><p>Además del compilador, el compilador usa directamente LDD de LLVM y las binutils de GNU. Los committers deberían ser conscientes de las diferencias en la sintaxis de ensamblador y las características de los enlazadores y asegurarse de que ambas variantes funcionan. Estos componentes se comprobarán como parte de los trabajos de CI de FreeBSD para Clang o GCC.</p></div><div class=paragraph><p>El proyecto FreeBSD proporciona cabeceras y librerías que permiten que se puedan usar otros compiladores que no estén en el sistema base. Estas cabeceras tienen soporte para hacer que el entorno sea tan estricto como el estándar, soportando dialectos anteriores a ANSI-C hasta C89, y otros casos esquina que la colección de ports ha dejado al descubierto Este soporte limita la retirada de estándares antiguos en sitios como ficheros de cabecera, pero no limitan la actualización del sistema base a nuevos dialectos. Tampoco requiere que el sistema base compile con estos estándares antiguos. Romper el soporte causaría fallos en los paquetes de la colección de ports, de forma que se debería evitar en la medida de lo posible, y arreglarlo rápidamente cuando sea fácil hacerlo.</p></div><div class=paragraph><p>El sistema de compilación de FreeBSD actualmente soporta estos entornos diferentes. Conforme se añaden nuevos avisos a los compiladores, el proyecto intenta arreglarlos. Sin embargo, a veces estos avisos requieren un trabajo extensivo, de forma que se silencian de alguna forma usando variables que evalúen a lo que sea apropiado dependiendo de la versión del compilador. Los desarrolladores deberían ser conscientes de esto, y asegurar que cualquier flag específico de un compilador debería ser usado condicionalmente.</p></div><div class=sect3><h4 id=_versiones_actuales_de_los_compiladores>20.3.1. Versiones Actuales de los Compiladores<a class=anchor href=#_versiones_actuales_de_los_compiladores></a></h4><div class=paragraph><p>El compilador en el sistema base es actualmente Clang 15.x. Actualmente, se prueban GCC 12 y Clang 12, 13, 14 y 15 en los trabajos de CI de jenkins en github. Se está trabajando para preparar el árbol para Clang 16. La rama soportada más antigua del proyecto tiene Clang 12, así que las porciones del build que hacen el arranque deben funcionar con Clang desde la versión 12 hasta la 15.</p></div></div></div><div class=sect2><h3 id=_otras_sugerencias>20.4. Otras sugerencias<a class=anchor href=#_otras_sugerencias></a></h3><div class=paragraph><p>Al realizar cambios en la documentación, utiliza un corrector ortográfico antes de realizar el commit. Para todos los documentos XML, verifica que las directivas de formato sean correctas ejecutando <code>make lint</code> y <a class=package href=https://cgit.freebsd.org/ports/tree/textproc/igor/>textproc/igor</a>.</p></div><div class=paragraph><p>Para páginas de manual, ejecuta <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/manck/>sysutils/manck</a> y <a class=package href=https://cgit.freebsd.org/ports/tree/textproc/igor/>textproc/igor</a> sobre las páginas de manual para verificar que todas las referencias cruzadas y las referencias de ficheros son correctas y que la página del manual tiene instalados todos los <code>MLINKS</code> apropiados.</p></div><div class=paragraph><p>No mezcles arreglos de estilo con nuevas funciones. Una corrección de estilo es cualquier cambio que no modifica la funcionalidad del código. La combinación de los cambios confunde el cambio de funcionalidad al solicitar diferencias entre las revisiones, lo que puede ocultar cualquier error nuevo. No incluyas cambios de espacios en blanco con cambios de contenido en los commits de <span class=filename>doc/</span>. El desorden adicional en las diferencias hace que el trabajo de los traductores sea mucho más difícil. En su lugar, realiza cambios de estilo o espacios en blanco en commits separados que estén claramente etiquetados como tales en el mensaje de commit.</p></div></div><div class=sect2><h3 id=_funciones_obsoletas>20.5. Funciones obsoletas<a class=anchor href=#_funciones_obsoletas></a></h3><div class=paragraph><p>Cuando sea necesario eliminar la funcionalidad del software en el sistema base, sigue estas pautas siempre que sea posible:</p></div><div class="olist arabic"><ol class=arabic><li><p>En la página del manual y posiblemente en las notas de la versión se menciona que la opción, utilidad o interfaz está obsoleta. El uso de la función obsoleta genera una advertencia.</p></li><li><p>La opción, utilidad o interfaz se conserva hasta la próxima versión principal (punto cero).</p></li><li><p>La opción, utilidad o interfaz se elimina y ya no se documenta. Ahora está obsoleto. También es generalmente una buena idea anotar su eliminación en las notas de la versión.</p></li></ol></div></div><div class=sect2><h3 id=_privacidad_y_confidencialidad>20.6. Privacidad y confidencialidad<a class=anchor href=#_privacidad_y_confidencialidad></a></h3><div class="olist arabic"><ol class=arabic><li><p>La mayoría de los negocios de FreeBSD se realizan en público.</p><div class=paragraph><p>FreeBSD es un proyecto <em>abierto</em>. Lo cual significa no solo que cualquiera puede usar el código fuente, sino que la mayoría del proceso de desarrollo está abierto para el escrutinio público.</p></div></li><li><p>Ciertos asuntos delicados deben permanecer privados o mantenidos bajo embargo.</p><div class=paragraph><p>Lamentablemente, no puede haber una transparencia total. Como desarrollador de FreeBSD, tendrás un cierto grado de acceso privilegiado a la información. En consecuencia, se espera que respetes ciertos requisitos de confidencialidad. A veces la necesidad de confidencialidad proviene de colaboradores externos o tiene un límite de tiempo específico. Sin embargo, sobre todo, se trata de no liberar comunicaciones privadas.</p></div></li><li><p>El oficial de seguridad tiene el control exclusivo sobre la publicación de avisos de seguridad.</p><div class=paragraph><p>Mientras que hay problemas de seguridad que afectan a muchos sistemas operativos diferentes, FreeBSD frecuentemente depende del acceso temprano para poder preparar avisos para el lanzamiento coordinado. A menos que se pueda confiar en que los desarrolladores de FreeBSD mantendrán la seguridad, dicho acceso temprano no estará disponible. El oficial de seguridad es responsable de controlar el acceso previo al lanzamiento a la información sobre vulnerabilidades y de programar el lanzamiento de todos los avisos. Puedes solicitar ayuda bajo condición de confidencialidad de cualquier desarrollador con conocimientos relevantes para preparar soluciones de seguridad.</p></div></li><li><p>Las comunicaciones con Core se mantienen confidenciales durante el tiempo que sea necesario.</p><div class=paragraph><p>Las comunicaciones con Core inicialmente se tratarán de forma confidencial. Sin embargo, con el tiempo, la mayor parte del negocio de Core se resumirá en informes básicos mensuales o trimestrales. Se tendrá cuidado de no hacer públicos los detalles sensibles. Es posible que los registros de algunos temas particularmente sensibles no se informen en absoluto y se conservarán solo en los archivos privados de Core.</p></div></li><li><p>Es posible que se requieran acuerdos de no divulgación para acceder a ciertos datos comercialmente sensibles.</p><div class=paragraph><p>El acceso a ciertos datos comercialmente sensibles solo puede estar disponible bajo un Acuerdo de Confidencialidad. Se debe consultar al personal legal de la Fundación FreeBSD antes de firmar cualquier acuerdo vinculante.</p></div></li><li><p>Las comunicaciones privadas no deben hacerse públicas sin permiso.</p><div class=paragraph><p>Más allá de los requisitos específicos anteriores, existe una expectativa general de no publicar comunicaciones privadas entre desarrolladores sin el consentimiento de todas las partes involucradas. Pide permiso antes de reenviar un mensaje a una lista de correo pública o publicarlo en un foro o sitio web al que puedan acceder otras personas que no sean los corresponsales originales.</p></div></li><li><p>Las comunicaciones en canales de acceso restringido o solo para proyectos deben mantenerse privadas.</p><div class=paragraph><p>De manera similar a las comunicaciones personales, ciertos canales de comunicación internos, incluidas las listas de correo de FreeBSD Committer y los canales de IRC de acceso restringido, se consideran comunicaciones privadas. Se requiere permiso para publicar material de estas fuentes.</p></div></li><li><p>Core puede aprobar la publicación.</p><div class=paragraph><p>Cuando no sea práctico obtener permiso debido a la cantidad de corresponsales o cuando el permiso para publicar se niegue sin razón, Core puede aprobar la divulgación de tales asuntos privados que merecen una publicación más general.</p></div></li></ol></div></div></div></div><div class=sect1><h2 id=archs>21. Soporte para múltiples arquitecturas<a class=anchor href=#archs></a></h2><div class=sectionbody><div class=paragraph><p>FreeBSD es un sistema operativo altamente portable destinado a funcionar en muchos tipos diferentes de arquitecturas de hardware. Mantener una separación limpia del código dependiente de la máquina (MD) y el código independiente de la máquina (MI), así como minimizar el código MD, es una parte importante de nuestra estrategia para permanecer ágiles con respecto a las tendencias actuales de hardware. Cada nueva arquitectura de hardware soportada por FreeBSD aumenta sustancialmente el coste del mantenimiento del código, el soporte de la cadena de herramientas y la ingeniería de versiones. También aumenta drásticamente el coste de las pruebas efectivas de los cambios del kernel. Como tal, existe una fuerte motivación para diferenciar entre clases de soporte para varias arquitecturas mientras se mantiene fuerte en algunas arquitecturas clave que se ven como FreeBSD "Público objetivo".</p></div><div class=sect2><h3 id=_declaración_de_intención_general>21.1. Declaración de intención general<a class=anchor href=#_declaración_de_intención_general></a></h3><div class=paragraph><p>El proyecto FreeBSD tiene como objetivo "estaciones de trabajo comerciales listas para usar (COTS) de calidad de producción, servidores y sistemas integrados de alta gama". Al mantener un enfoque en un conjunto estrecho de arquitecturas de interés en estos entornos, el Proyecto FreeBSD puede mantener altos niveles de calidad, estabilidad y rendimiento, así como minimizar la carga en varios equipos de soporte en el proyecto, como el equipo de ports, equipo de documentación, oficial de seguridad y equipos de ingenieros de versiones. La diversidad en el soporte de hardware amplía las opciones para los consumidores de FreeBSD al ofrecer nuevas características y oportunidades de uso, pero estos beneficios siempre deben considerarse cuidadosamente en términos del coste de mantenimiento del mundo real asociado con el soporte de plataforma adicional.</p></div><div class=paragraph><p>El Proyecto FreeBSD diferencia los objetivos de la plataforma en cuatro niveles. Cada nivel incluye una lista de garantías en las que los consumidores pueden confiar, así como las obligaciones del Proyecto y los desarrolladores para cumplir con esas garantías. Estas listas definen las garantías mínimas para cada nivel. El Proyecto y los desarrolladores pueden proporcionar niveles adicionales de soporte más allá de las garantías mínimas para un nivel determinado, pero dicho soporte adicional no está garantizado. Cada objetivo de plataforma se asigna a un nivel específico para cada rama estable. Como resultado, a una plataforma de destino podría asignarsele diferentes niveles en ramas estables concurrentes.</p></div></div><div class=sect2><h3 id=_objetivos_de_plataforma>21.2. Objetivos de plataforma<a class=anchor href=#_objetivos_de_plataforma></a></h3><div class=paragraph><p>El soporte para una plataforma de hardware consta de dos componentes: el soporte del kernel y las interfaces binarias de aplicaciones (ABI) del área de usuario. El soporte de la plataforma del kernel incluye las cosas necesarias para ejecutar un kernel FreeBSD en una plataforma de hardware, como la administración de memoria virtual dependiente de la máquina y los controladores de dispositivo. Una ABI de área de usuario especifica una interfaz para que los procesos de usuario interactúen con un núcleo de FreeBSD y bibliotecas del sistema base. Una ABI de área de usuario incluye interfaces de llamada al sistema, el diseño y la semántica de las estructuras de datos públicas y el diseño y la semántica de los argumentos que se pasan a las subrutinas. Algunos componentes de una ABI pueden definirse mediante especificaciones como el diseño de objetos de excepción de C ++ o convenciones de llamada para funciones de C.</p></div><div class=paragraph><p>Un kernel de FreeBSD también usa una ABI (a veces denominada interfaz binaria del kernel (KBI)) que incluye la semántica y los diseños de las estructuras de datos públicas y el diseño y la semántica de los argumentos de las funciones públicas dentro del propio kernel.</p></div><div class=paragraph><p>Un kernel de FreeBSD puede admitir múltiples ABI de usuario. Por ejemplo, el kernel amd64 de FreeBSD es compatible con las ABI de área de usuario amd64 e i386 de FreeBSD, así como con las ABI de área de usuario de Linux x86_64 e i386. Un kernel de FreeBSD debería admitir un ABI "nativo" como ABI predeterminado. El "ABI" nativo generalmente comparte ciertas propiedades con la ABI del kernel, como la convención de llamadas de C, tamaños de tipos básicos, etc.</p></div><div class=paragraph><p>Los niveles se definen tanto para los núcleos como para las ABI del área de usuario. En el caso común, el kernel de una plataforma y las ABI de FreeBSD se asignan al mismo nivel.</p></div></div><div class=sect2><h3 id=_nivel_1_arquitecturas_totalmente_compatibles>21.3. Nivel 1: Arquitecturas totalmente compatibles<a class=anchor href=#_nivel_1_arquitecturas_totalmente_compatibles></a></h3><div class=paragraph><p>Las plataformas de nivel 1 son las plataformas FreeBSD más maduras. Están respaldados por el oficial de seguridad, la ingeniería de versiones y el Equipo de Gestión de Ports. Se espera que las arquitecturas de nivel 1 sean de calidad de producción con respecto a todos los aspectos del sistema operativo FreeBSD, incluidos los entornos de instalación y desarrollo.</p></div><div class=paragraph><p>El Proyecto FreeBSD ofrece las siguientes garantías a los consumidores de plataformas Tier 1:</p></div><div class=ulist><ul><li><p>Las imágenes oficiales de lanzamiento de FreeBSD serán proporcionadas por el equipo de ingenieros de lanzamiento.</p></li><li><p>Se proporcionarán actualizaciones binarias y parches de origen para avisos de seguridad y avisos de erratas para las versiones compatibles.</p></li><li><p>Se proporcionarán parches de origen para avisos de seguridad para las sucursales admitidas.</p></li><li><p>Las actualizaciones binarias y los parches de origen para los avisos de seguridad multiplataforma se proporcionarán normalmente en el momento del anuncio.</p></li><li><p>Los cambios en las ABI del área de usuario generalmente incluirán ajustes de compatibilidad para garantizar el funcionamiento correcto de los binarios compilados en cualquier rama estable donde la plataforma sea de nivel 1. Es posible que estos ajustes no estén habilitados en la instalación predeterminada. Si no se proporcionan calzas de compatibilidad para un cambio de ABI, la falta de calzas se documentará claramente en las notas de la versión.</p></li><li><p>Los cambios en ciertas partes de la ABI del kernel incluirán ajustes de compatibilidad para garantizar el funcionamiento correcto de los módulos del kernel compilados con la versión compatible más antigua de la rama. Tenga en cuenta que no todas las partes de la ABI del kernel están protegidas.</p></li><li><p>El equipo de ports proporcionará paquetes binarios oficiales para software de terceros. Para las arquitecturas integradas, estos paquetes pueden construirse de forma cruzada a partir de una arquitectura diferente.</p></li><li><p>Los ports más relevantes deberían construir o tener los filtros apropiados para evitar que se construyan otros inapropiados.</p></li><li><p>Las nuevas características que no son inherentemente específicas de la plataforma serán completamente funcionales en todas las arquitecturas de Nivel 1.</p></li><li><p>Las características y las correcciones de compatibilidad utilizadas por los binarios compilados contra ramas estables más antiguas pueden eliminarse en versiones principales más recientes. Dichas eliminaciones se documentarán claramente en las notas de la versión.</p></li><li><p>Las plataformas de nivel 1 deben estar completamente documentadas. Las operaciones básicas se documentarán en el manual de FreeBSD.</p></li><li><p>Las plataformas de nivel 1 se incluirán en el árbol de fuentes.</p></li><li><p>Las plataformas de nivel 1 deben ser auto contenidas, ya sea a través de la cadena de herramientas en árbol o una cadena de herramientas externa. Si se requiere una cadena de herramientas externa, se proporcionarán paquetes binarios oficiales para una cadena de herramientas externa.</p></li></ul></div><div class=paragraph><p>Para mantener la madurez de las plataformas de Nivel 1, el Proyecto FreeBSD mantendrá los siguientes recursos para apoyar el desarrollo:</p></div><div class=ulist><ul><li><p>Crea y prueba el soporte de automatización, ya sea en el clúster de FreeBSD.org o en alguna otra ubicación fácilmente disponible para todos los desarrolladores. Las plataformas integradas pueden sustituir un emulador disponible en el clúster de FreeBSD.org por hardware real.</p></li><li><p>Inclusión en los objetivos <code>make universe</code> y <code>make tinderbox</code>.</p></li><li><p>Hardware dedicado en uno de los clústeres de FreeBSD para la construcción de paquetes (ya sea de forma nativa o mediante qemu-user).</p></li></ul></div><div class=paragraph><p>En conjunto, los desarrolladores deben proporcionar lo siguiente para mantener el estado de Nivel 1 de una plataforma:</p></div><div class=ulist><ul><li><p>Los cambios en el árbol de fuentes no deben romper conscientemente la construcción de una plataforma de Nivel 1.</p></li><li><p>Las arquitecturas de nivel 1 deben tener un ecosistema maduro y saludable de usuarios y desarrolladores activos.</p></li><li><p>Los desarrolladores deberían poder crear paquetes en sistemas de Nivel 1 no integrados y comúnmente disponibles. Esto puede significar compilaciones nativas si los sistemas no integrados están comúnmente disponibles para la plataforma en cuestión, o puede significar compilaciones cruzadas alojadas en alguna otra arquitectura de Nivel 1.</p></li><li><p>Los cambios no pueden romper la ABI del área de usuario. Si se requiere un cambio de ABI, la compatibilidad de ABI para binarios existentes debe proporcionarse mediante el uso de versiones de símbolos o cambios de versión de biblioteca compartida.</p></li><li><p>Los cambios combinados en ramas estables no pueden romper las partes protegidas de la ABI del kernel. Si se requiere un cambio de ABI del kernel, el cambio debe modificarse para preservar la funcionalidad de los módulos del kernel existentes.</p></li></ul></div></div><div class=sect2><h3 id=_nivel_2_arquitecturas_de_desarrollo_y_de_nicho>21.4. Nivel 2: Arquitecturas de desarrollo y de nicho<a class=anchor href=#_nivel_2_arquitecturas_de_desarrollo_y_de_nicho></a></h3><div class=paragraph><p>Las plataformas de nivel 2 son plataformas FreeBSD funcionales, pero menos maduras. No cuentan con el apoyo del oficial de seguridad, la ingeniería de versiones y los equipos de administración de ports.</p></div><div class=paragraph><p>Las plataformas de nivel 2 pueden ser candidatas a plataformas de nivel 1 que aún se encuentran en desarrollo activo. Las arquitecturas que llegan al final de su vida útil también pueden pasar del estado de Nivel 1 al estado de Nivel 2 a medida que disminuye la disponibilidad de recursos para continuar manteniendo el sistema en un estado de Calidad de Producción. Las arquitecturas especializadas bien soportadas también pueden ser de Nivel 2.</p></div><div class=paragraph><p>El Proyecto FreeBSD proporciona las siguientes garantías a los consumidores de plataformas Tier 2:</p></div><div class=ulist><ul><li><p>La infraestructura de ports debe incluir soporte básico para arquitecturas de Nivel 2 suficiente para soportar la construcción de ports y paquetes. Esto incluye soporte para paquetes básicos como ports-mgmt / pkg, pero no hay garantía de que los ports arbitrarios sean compilables o funcionales.</p></li><li><p>Las nuevas características que no son inherentemente específicas de la plataforma deberían ser factibles en todas las arquitecturas de Nivel 2 si no se implementan.</p></li><li><p>Las plataformas de nivel 2 se incluirán en el árbol de fuentes.</p></li><li><p>Las plataformas de nivel 2 deben auto alojarse a través de la cadena de herramientas en árbol o una cadena de herramientas externa. Si se requiere una cadena de herramientas externa, se proporcionarán paquetes binarios oficiales para una cadena de herramientas externa.</p></li><li><p>Las plataformas de nivel 2 deben proporcionar kernels funcionales y áreas de usuario incluso si no se proporciona una distribución de lanzamiento oficial.</p></li></ul></div><div class=paragraph><p>Para mantener la madurez de las plataformas Tier 2, el Proyecto FreeBSD mantendrá los siguientes recursos para apoyar el desarrollo:</p></div><div class=ulist><ul><li><p>Inclusión en los objetivos <code>make universe</code> y <code>make tinderbox</code>.</p></li></ul></div><div class=paragraph><p>En conjunto, los desarrolladores deben proporcionar lo siguiente para mantener el estado de Nivel 2 de una plataforma:</p></div><div class=ulist><ul><li><p>Los cambios en el árbol de fuentes no deberían romper a sabiendas la construcción de una plataforma de Nivel 2.</p></li><li><p>Las arquitecturas de nivel 2 deben tener un ecosistema activo de usuarios y desarrolladores.</p></li><li><p>Si bien se permite que los cambios rompan la ABI del área de usuario, la ABI no debe romperse gratuitamente. Los cambios significativos en la ABI del área de usuario deben restringirse a las versiones principales.</p></li><li><p>Las nuevas funciones que aún no se han implementado en las arquitecturas de nivel 2 deberían proporcionar un medio para desactivarlas en esas arquitecturas.</p></li></ul></div></div><div class=sect2><h3 id=_nivel_3_arquitecturas_experimentales>21.5. Nivel 3: Arquitecturas experimentales<a class=anchor href=#_nivel_3_arquitecturas_experimentales></a></h3><div class=paragraph><p>Las plataformas de nivel 2 son plataformas FreeBSD funcionales, pero menos maduras. No cuentan con el apoyo del oficial de seguridad, la ingeniería de versiones y el Equipo de Gestión de Ports.</p></div><div class=paragraph><p>Las plataformas de nivel 3 son arquitecturas en las primeras etapas de desarrollo, para plataformas de hardware no convencionales, o que se consideran sistemas heredados con pocas probabilidades de tener un uso amplio en el futuro. El soporte inicial para las plataformas de Nivel 3 puede existir en un repositorio separado en lugar del repositorio de origen principal.</p></div><div class=paragraph><p>El Proyecto FreeBSD no ofrece garantías a los consumidores de plataformas de Nivel 3 y no se compromete a mantener los recursos para apoyar el desarrollo. Es posible que las plataformas de nivel 3 no siempre sean compilables, ni ningún núcleo o ABI de área de usuario se considera estable.</p></div></div><div class=sect2><h3 id=_arquitecturas_no_soportadas>21.6. Arquitecturas No Soportadas<a class=anchor href=#_arquitecturas_no_soportadas></a></h3><div class=paragraph><p>Otras plataformas no están soportadas en absoluto por el proyecto. El proyecto antes las describía como sistemas de Nivel 4.</p></div><div class=paragraph><p>Después de que una plataforma pase a ser no soportada, se elimina de los árboles de fuentes, ports y documentación todo su soporte. Nótese que el soporte en ports debe permanecer mientras la plataforma esté soportada en una rama todavía soportada por los ports.</p></div></div><div class=sect2><h3 id=_política_sobre_el_cambio_de_nivel_de_una_arquitectura>21.7. Política sobre el cambio de nivel de una arquitectura<a class=anchor href=#_política_sobre_el_cambio_de_nivel_de_una_arquitectura></a></h3><div class=paragraph><p>Los sistemas solo se pueden mover de un nivel a otro con la aprobación del Core Team de FreeBSD, que tomará esa decisión en colaboración con el Oficial de Seguridad, la Ingeniería de Versiones y el Equipo de Gestión de Ports. Para que una plataforma sea promovida a un nivel superior, las garantías de soporte que falten deben cumplirse antes de que se complete la promoción.</p></div></div></div></div><div class=sect1><h2 id=ports>22. Preguntas frecuentes sobre ports específicos<a class=anchor href=#ports></a></h2><div class=sectionbody><div class=sect2><h3 id=ports-qa-adding>22.1. Agregar un port nuevo<a class=anchor href=#ports-qa-adding></a></h3><div class=sect3><h4 id=ports-qa-add-new>22.1.1. ¿Cómo agrego un nuevo port?<a class=anchor href=#ports-qa-add-new></a></h4><div class=paragraph><p>Añadir un port al árbol es algo relativamente sencillo. Una vez que el port está listo para ser añadido, como se explica en <a href=#ports-qa-add-new-extra>aquí</a>, necesitas añadir la entrada al directorio de port en el <span class=filename>Makefile</span> de la categoría correspondiente. En este <span class=filename>Makefile</span>, los ports están listados en orden alfabético y añadidos a la variable <code>SUBDIR</code>, de este modo:</p></div><div class="literalblock programlisting"><div class=content><pre>	SUBDIR += newport</pre></div></div><div class=paragraph><p>Una vez que el port y el Makefile de su categoría están listos, se puede hacer commit del nuevo port:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% git add category/Makefile category/newport
% git commit
% git push</code></pre></div></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>No te olvides de <a href=#port-commit-message-formats>establecer los hooks de git para el árbol de ports como se explica aquí</a>; se ha desarrollado un hook específico para verificar la categoría del <span class=filename>Makefile</span>.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=ports-qa-add-new-extra>22.1.2. ¿Alguna otra cosa que deba saber cuando agregue un nuevo port?<a class=anchor href=#ports-qa-add-new-extra></a></h4><div class=paragraph><p>Verifica el port, preferiblemente para asegurarse de que se compila y empaqueta correctamente.</p></div><div class=paragraph><p>The <a href=https://docs.freebsd.org/en/books/porters-handbook/testing>Porters Handbook’s Testing Chapter</a> contains more detailed instructions. See the <a href=https://docs.freebsd.org/en/books/porters-handbook/testing#testing-portclippy>Portclippy / Portfmt</a> and the <a href=https://docs.freebsd.org/en/books/porters-handbook/testing#testing-poudriere>poudriere</a> sections.</p></div><div class=paragraph><p>No necesitas eliminar todos los avisos pero asegúrate de haber corregido los más simples.</p></div><div class=paragraph><p>Si el port viene de alguien que no ha contribuido anteriormente al Proyecto, añade el nombre de esa persona a la sección <a href=https://docs.freebsd.org/en/articles/contributors/#contrib-additional>Additional Contributors</a> de la Lista de Colaboradores de FreeBSD.</p></div><div class=paragraph><p>Si el port vino a través de un PR, ciérralo. Para cerrar un PR, cambia el estado a <code>Issue Resolved</code> y la resolución a <code>Fixed</code>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>If for some reason using <a href=https://docs.freebsd.org/en/books/porters-handbook/testing#testing-poudriere>poudriere</a> to test the new port is not possible, the bare minimum of testing includes this sequence:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># make install</span>
<span class=c># make package</span>
<span class=c># make deinstall</span>
<span class=c># pkg add package you built above</span>
<span class=c># make deinstall</span>
<span class=c># make reinstall</span>
<span class=c># make package</span></code></pre></div></div><div class=paragraph><p>Date cuenta de que poudriere es la referencia para la construcción de paquetes, si el paquete no compila en poudriere, será eliminado.</p></div></td></tr></tbody></table></div></div></div><div class=sect2><h3 id=ports-qa-removing>22.2. Eliminar un port existente<a class=anchor href=#ports-qa-removing></a></h3><div class=sect3><h4 id=ports-qa-remove-one>22.2.1. ¿Cómo elimino un port existente?<a class=anchor href=#ports-qa-remove-one></a></h4><div class=paragraph><p>Primero, lea la sección sobre copias del repositorio. Antes de eliminar el port, debe verificar que no haya otros ports que dependan de él.</p></div><div class=ulist><ul><li><p>Asegúrese de que no haya dependencia del port en la colección de ports:</p><div class=ulist><ul><li><p>El PKGNAME del port aparece exactamente en una línea en un archivo INDEX reciente.</p></li><li><p>Ningún otro port contiene ninguna referencia al directorio del port o PKGNAME en sus Makefiles</p><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Cuando uses Git, considera utilizar <a href="https://man.freebsd.org/cgi/man.cgi?query=git-grep&amp;sektion=1&amp;format=html">git-grep(1)</a>, es mucho más rápido que <code>grep -r</code>.</p></div></td></tr></tbody></table></div></li></ul></div></li><li><p>Luego, quita el port:</p><div class="exampleblock procedure"><div class=content><div class=ulist><ul><li><p>Elimina los ficheros del port y el directorio con <code>git rm</code>.</p></li><li><p>Elimina la entrada <code>SUBDIR</code> del port en el <span class=filename>Makefile</span> del directorio padre.</p></li><li><p>Añade una entrada en <span class=filename>ports/MOVED</span>.</p></li><li><p>Elimina el port de <span class=filename>ports/LEGAL</span> si estuviera ahí.</p></li></ul></div></div></div></li></ul></div><div class=paragraph><p>Como alternativa, puedes utilizar el script rmport, de <span class=filename>ports/Tools/scripts</span>. Este script fue escrito por Vasil Dimov &lt;<a href=mailto:vd@FreeBSD.org>vd@FreeBSD.org</a>>. Cuando envíes preguntas acerca de este script a <a href=https://lists.FreeBSD.org/subscription/freebsd-ports>Lista de correo sobre los ports de FreeBSD</a>, por favor, pon en copia a Chris Rees &lt;<a href=mailto:crees@FreeBSD.org>crees@FreeBSD.org</a>>, el actual mantenedor.</p></div></div></div><div class=sect2><h3 id=ports-qa-move-port>22.3. ¿Cómo muevo un port a un lugar nuevo?<a class=anchor href=#ports-qa-move-port></a></h3><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Realiza una comprobación exhaustiva de la colección de ports buscando cualquier dependencia de la localización/nombre antiguo del port y actualízalos. Ejecutar <code>grep</code> en <span class=filename>INDEX</span> no es suficiente porque algunos ports tienen dependencias activadas a través de opciones de tiempo de compilación. Se recomienda hacer un <a href="https://man.freebsd.org/cgi/man.cgi?query=git-grep&amp;sektion=1&amp;format=html">git-grep(1)</a> completo sobre la colección de ports.</p></li><li><p>Elimina la entrada <code>SUBDIR</code> del Makefile de la categoría antigua y añade una entrada <code>SUBDIR</code> en el Makefile de la nueva categoría.</p></li><li><p>Añade una entrada en <span class=filename>ports/MOVED</span>.</p></li><li><p>Busca entradas en los ficheros xml de <span class=filename>ports/security/vuxml</span> y ajústalos en consecuencia. En particular, verifica los paquetes anteriores con el nuevo nombre cuya versión podría incluir el nuevo port.</p></li><li><p>Mueve el port con <code>git mv</code>.</p></li><li><p>Haz commit de los cambios.</p></li></ol></div></div></div></div><div class=sect2><h3 id=ports-qa-copy-port>22.4. ¿Cómo copio un port a un lugar nuevo?<a class=anchor href=#ports-qa-copy-port></a></h3><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Copia el port con <code>cp -R old-cat/old-port new-cat/new-port</code>.</p></li><li><p>Añade el nuevo port a <span class=filename>new-cat/Makefile</span>.</p></li><li><p>Cambia lo que se necesite en <span class=filename>new-cat/new-port</span>.</p></li><li><p>Haz commit de los cambios.</p></li></ol></div></div></div></div><div class=sect2><h3 id=ports-qa-freeze>22.5. Congelación de ports<a class=anchor href=#ports-qa-freeze></a></h3><div class=sect3><h4 id=ports-qa-freeze-what>22.5.1. ¿Qué es una "congelación de ports"?<a class=anchor href=#ports-qa-freeze-what></a></h4><div class=paragraph><p>Una "Congelación de ports" era un estado restringido en el que se colocaba el árbol de ports antes de un lanzamiento de versión. Se utilizó para garantizar una mayor calidad de los paquetes enviados con una versión. Solía durar un par de semanas. Durante ese tiempo, se solucionaban los problemas de compilación y se compilaban los paquetes para dicha versión. Esta práctica ya no se utiliza, ya que los paquetes para las versiones se crean a partir de la rama trimestral estable actual.</p></div><div class=paragraph><p>Para más información sobre cómo mergear commits en la rama trimestral, lee <a href=#ports-qa-misc-request-mfh>¿Cuál es el procedimiento para solicitar autorización para fusionar un compromiso con la sucursal trimestral?</a>.</p></div></div></div><div class=sect2><h3 id=ports-qa-quarterly>22.6. Sucursales trimestrales<a class=anchor href=#ports-qa-quarterly></a></h3><div class=sect3><h4 id=ports-qa-misc-request-mfh>22.6.1. ¿Cuál es el procedimiento para solicitar autorización para fusionar un compromiso con la sucursal trimestral?<a class=anchor href=#ports-qa-misc-request-mfh></a></h4><div class=paragraph><p>Desde el 30 de Noviembre de 2020 no es necesario buscar aprobación explícita para hacer commit en la rama trimestral.</p></div></div><div class=sect3><h4 id=ports-qa-misc-commit-mfh>22.6.2. ¿Cuál es el procedimiento para mergear commits con la rama trimestral?<a class=anchor href=#ports-qa-misc-commit-mfh></a></h4><div class=paragraph><p>Mergear commits a la rama trimestral (un proceso que llamamos MFH por razones históricas) es muy similar a hacer un commit MFC en el repositorio de src, así que básicamente:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% git checkout 2021Q2
% git cherry-pick <span class=nt>-x</span> <span class=nv>$HASH</span>
<span class=o>(</span>verify everything is OK, <span class=k>for </span>example by doing a build <span class=nb>test</span><span class=o>)</span>
% git push</code></pre></div></div><div class=paragraph><p>donde <code>$HASH</code> es el hash del commit que quieres copiar a la rama trimestral. El parámetro <code>-x</code> asegura que se incluye el hash <code>$HASH</code> de la rama <code>main</code> en el nuevo mensaje de commit de la rama trimestral.</p></div></div></div><div class=sect2><h3 id=ports-qa-new-category>22.7. Crear una nueva categoría<a class=anchor href=#ports-qa-new-category></a></h3><div class=sect3><h4 id=ports-qa-new-category-how>22.7.1. ¿Cuál es el procedimiento para crear una nueva categoría?<a class=anchor href=#ports-qa-new-category-how></a></h4><div class=paragraph><p>Por favor, lee <a href=https://docs.freebsd.org/en/books/porters-handbook/#proposing-categories>Proposing a New Category</a> en el Porter’s Handbook. Una vez que se ha seguido el procedimiento y que se ha asignado el PR a Grupo de Administración de ports &lt;<a href=mailto:portmgr@FreeBSD.org>portmgr@FreeBSD.org</a>>, es su decisión si se aprueba o no. Si lo hacen, es su responsabilidad:</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Realiza los movimientos necesarios. (Esto solo se aplica a las categorías físicas.)</p></li><li><p>Actualiza la definición de <code>VALID_CATEGORIES</code> en <span class=filename>ports/Mk/bsd.port.mk</span>.</p></li><li><p>Asígnate el PR de nuevo.</p></li></ol></div></div></div></div><div class=sect3><h4 id=ports-qa-new-category-physical>22.7.2. ¿Qué debo hacer para implementar una nueva categoría física?<a class=anchor href=#ports-qa-new-category-physical></a></h4><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Actualizar cada <span class=filename>Makefile</span> de los ports movidos. No conectes todavía la nueva categoría a la compilación.</p><div class=paragraph><p>Para hacer esto, necesitarás:</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Cambiar <code>CATEGORIES</code> del port (este era el objetivo del ejercicio, ¿recuerdas?) Primero se lista la nueva categoría. Esto ayudará a que el PKGORIGIN sea correcto.</p></li><li><p>Ejecutar un <code>make describe</code>. Puesto que el <code>make index</code> de nivel raíz que ejecutarás en unos pocos pasos es una iteración de un <code>make describe</code> realizado sobre toda la jerarquía de ports, detectar cualquier error aquí te evitará tener que volver a ejecutar ese paso más adelante.</p></li><li><p>Si quieres ser realmente concienzudo, ahora podría ser un buen momento para ejecutar <a href="https://man.freebsd.org/cgi/man.cgi?query=portlint&amp;sektion=1&amp;format=html">portlint(1)</a>.</p></li></ol></div></div></div></li><li><p>Comprueba que los <code>PKGORIGIN</code> son correctos. El sistema de ports utiliza la entrada <code>CATEGORIES</code> de cada port para crear su <code>PKGORIGIN</code>, el cual se usa para conectar los paquetes instalados con el directorio de port a partir del cual fue construido. Si esta entrada es incorrecta, herramientas habituales de los prots como <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg-version&amp;sektion=8&amp;format=html">pkg-version(8)</a> y <a href="https://man.freebsd.org/cgi/man.cgi?query=portupgrade&amp;sektion=1&amp;format=html">portupgrade(1)</a> fallarán.</p><div class=paragraph><p>Para hacer esto, utiliza la herramienta <span class=filename>chkorigin.sh</span>: <code>env PORTSDIR=/path/to/ports sh -e /path/to/ports/Tools/scripts/chkorigin.sh</code>. Esto comprobará cada port en el árbol, incluso aquellos que no estén conectados a la compilación, de forma que puedes ejecutarlo directamente después de la operación de mover el port. Truco: ¡no te olvides de mirar los <code>PKGORIGIN</code> de los ports esclavos en los ports que acabas de mover!</p></div></li><li><p>En tu propio sistema local, comprueba los cambios propuestos: primero, comenta las entradas SUBDIR en los <span class=filename>Makefile</span>s de las categorías de los ports antiguos; luego activa la construcción de la nueva categoría en <span class=filename>ports/Makefile</span>. Ejecuta <code>make checksubdirs</code> en los directorios de las categorías afectadas para comprobar las entradas SUBDIR. Después en el directorio <span class=filename>ports/</span> ejecuta <code>make index</code>. Esto puede durar más de 40 minutos incluso en sistemas modernos; sin embargo, es un paso necesario para evitar que otra gente tenga problemas.</p></li><li><p>Una vez hecho esto, puedes hacer commit del <span class=filename>ports/Makefile</span> actualizado para conectar la nueva categoría a la compilación y también hacer commit de los cambios en el <span class=filename>Makefile</span> para la(s) categoría(s) nueva(s).</p></li><li><p>Añade las entradas apropiadas a <span class=filename>ports/MOVED</span>.</p></li><li><p>Actualiza la documentación modificando:</p><div class=ulist><ul><li><p>el <a href=https://docs.freebsd.org/en/books/porters-handbook/#PORTING-CATEGORIES>list of categories</a> en el Porter’s Handbook</p></li></ul></div></li><li><p>Solo una vez que se haya hecho todo lo anterior, y ya no se informe de problemas con los nuevos ports, los ports antiguos deben eliminarse de sus ubicaciones anteriores en el repositorio.</p></li></ol></div></div></div></div><div class=sect3><h4 id=_qué_debo_hacer_para_implementar_una_nueva_categoría_virtual>22.7.3. ¿Qué debo hacer para implementar una nueva categoría virtual?<a class=anchor href=#_qué_debo_hacer_para_implementar_una_nueva_categoría_virtual></a></h4><div class=paragraph><p>Esto es mucho más simple que una categoría física. Solo se necesitan algunas modificaciones:</p></div><div class=ulist><ul><li><p>el <a href=https://docs.freebsd.org/en/books/porters-handbook/#PORTING-CATEGORIES>list of categories</a> en el Porter’s Handbook</p></li></ul></div></div></div><div class=sect2><h3 id=ports-qa-misc-questions>22.8. Preguntas misceláneas<a class=anchor href=#ports-qa-misc-questions></a></h3><div class=sect3><h4 id=ports-qa-misc-blanket-approval>22.8.1. ¿Hay cambios de los que se pueda hacer commit sin pedir la aprobación del mantenedor?<a class=anchor href=#ports-qa-misc-blanket-approval></a></h4><div class=paragraph><p>La aprobación general para la mayoría de los ports se aplica a estos tipos de arreglos:</p></div><div class=ulist><ul><li><p>La mayoría de los cambios de infraestructura sobre un port (es decir, modernizarlo, pero no cambiar la funcionalidad). Por ejemplo, el "blanket" cubre convertir ports para que utilicen una nueva macro <code>USES</code>, habilitar compilación con más información de log y cambiar a una nueva sintaxis en el sistema de ports.</p></li><li><p>Arreglos triviales <em>y probados</em> en compilación y tiempo de ejecución.</p></li><li><p>Cambios de documentación y metadatos en los ports, como <span class=filename>pkg-descr</span> o <code>COMMENT</code>.</p></li></ul></div><div class="admonitionblock important"><table><tbody><tr><td class=icon><i class="fa icon-important" title=Important></i></td><td class=content><div class=paragraph><p>Cualquier cosa mencionada por Grupo de Administración de ports &lt;<a href=mailto:portmgr@FreeBSD.org>portmgr@FreeBSD.org</a>> o el Grupo Responsables de Seguridad &lt;<a href=mailto:security-officer@FreeBSD.org>security-officer@FreeBSD.org</a>> pueden ser excepciones a estas reglas. Nunca se pueden hacer commits no autorizados en ports mantenidos por esos grupos.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=ports-qa-misc-correctly-building>22.8.2. ¿Cómo sé si mi port se está construyendo correctamente o no?<a class=anchor href=#ports-qa-misc-correctly-building></a></h4><div class=paragraph><p>Los paquetes se construyen varias veces por semana. Si un port falla, el mantenedor recibe un email de <code>pkg-fallout@FreeBSD.org</code>.</p></div><div class=paragraph><p>Informes de todos las construcciones de paquetes (oficiales, experimentales y de no-regresión) se agregan en <a href=pkg-status.FreeBSD.org>pkg-status.FreeBSD.org</a>.</p></div></div><div class=sect3><h4 id=ports-qa-misc-INDEX>22.8.3. He añadido un nuevo port. ¿Necesito añadirlo al <span class=filename>INDEX</span>?<a class=anchor href=#ports-qa-misc-INDEX></a></h4><div class=paragraph><p>No. El fichero se puede generar bien ejecutando <code>make index</code>, o se puede descargar una versión pre-generada con <code>make fetchindex</code>.</p></div></div><div class=sect3><h4 id=ports-qa-misc-no-touch>22.8.4. ¿Hay otros archivos que no pueda tocar?<a class=anchor href=#ports-qa-misc-no-touch></a></h4><div class=paragraph><p>Cualquier fichero bajo <span class=filename>ports/</span>, o cualquier fichero bajo un subdirectorio que empieza con una letra mayúscula (<span class=filename>Mk/</span>, <span class=filename>Tools/</span>, etc.). En concreto, Grupo de Administración de ports &lt;<a href=mailto:portmgr@FreeBSD.org>portmgr@FreeBSD.org</a>> es muy protector con <span class=filename>ports/Mk/bsd.port*.mk</span> así que no hagas commit de cambios en esos ficheros a menos que quieras enfrentarte a su ira.</p></div></div><div class=sect3><h4 id=ports-qa-misc-updated-distfile>22.8.5. ¿Cuál es el procedimiento adecuado para actualizar la suma de comprobación de un archivo distfile de un pport cuando el archivo cambia sin un cambio de versión?<a class=anchor href=#ports-qa-misc-updated-distfile></a></h4><div class=paragraph><p>Cuando la suma de comprobación (checksum) de un archivo de distribución se actualiza debido a que el autor actualizó el archivo sin cambiar la revisión del port, el mensaje de confirmación incluye un resumen de las diferencias relevantes entre el archivo de distribución original y el nuevo para garantizar que el archivo de distribución no haya sido dañado o alterado maliciosamente. Si la versión actual del port ha estado en el árbol de ports durante un tiempo, una copia del antiguo archivo de distribución estará disponible en los servidores ftp; de lo contrario, se debe contactar con el autor o el encargado del mantenimiento para averiguar por qué ha cambiado el archivo de distribución.</p></div></div><div class=sect3><h4 id=ports-exp-run>22.8.6. ¿Cómo se puede solicitar una construcción experimental (exp-run) del árbol de ports?<a class=anchor href=#ports-exp-run></a></h4><div class=paragraph><p>Se debe completar una ejecución de exp-run antes de que se haga commit de parches con un impacto significativo en los ports. El parche puede ser contra el árbol de ports o el sistema base.</p></div><div class=paragraph><p>Se hará una construcción completa con los parches proporcionados por el peticionario, y éste es responsable de corregir los problemas detectados <em>(fallout)</em> antes de hacer commit.</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Visita la página <a href=https://bugs.freebsd.org/submit>Bugzilla new PR page</a>.</p></li><li><p>Selecciona el producto relacionado con tu parche.</p></li><li><p>Completa el informe de error como de costumbre. Recuerda adjuntar el parche.</p></li><li><p>Si arriba dice “Show Advanced Fields”, haz click en el enlace. Ahora dirá “Hide Advanced Fields”. Habrá disponibles muchos más campos. Si ya dice “Hide Advanced Fields”, no se necesita hacer nada.</p></li><li><p>En la sección “Flags”, establece “exp-run” a <code>?</code>. Respecto a los otros campos, pasando el ratón por encima de cualquier campo hace que se muestren más detalles.</p></li><li><p>Envía. Espera a que se ejecute la compilación.</p></li><li><p>El Grupo de Administración de ports &lt;<a href=mailto:portmgr@FreeBSD.org>portmgr@FreeBSD.org</a>> contestará con los posibles errores detectados.</p></li><li><p>Dependiendo del resultado:</p><div class=ulist><ul><li><p>Si no hay errores, el procedimiento se detiene aquí y se puede hacer commit del cambio, pendiente de cualquier otra aprobación requerida.</p><div class="olist lowerroman"><ol class=lowerroman type=i><li><p>Si hay errores, <em>deben</em> ser corregidos, bien arreglando los ports directamente en el árbol de ports, o añadiéndolo al parche enviado.</p></li><li><p>Una vez hecho esto, vuelve al paso 6 y di que los errores se han solucionado y espera a que se vuelva a ejecutar el exp-run. Repite mientras haya ports rotos.</p></li></ol></div></li></ul></div></li></ol></div></div></div></div></div></div></div><div class=sect1><h2 id=non-committers>23. Problemas Específicos para Desarrolladores que No Son Committers<a class=anchor href=#non-committers></a></h2><div class=sectionbody><div class=paragraph><p>Algunas personas que tienen acceso a las máquinas FreeBSD no tienen commit bits. Casi todo este documento también aplicará a estos desarrolladores (excepto los aspectos específicos de los commits y las pertenencias a las listas de correo que las acompañan). En particular, te recomendamos que leas:</p></div><div class=ulist><ul><li><p><a href=#admin>Detalles administrativos</a></p></li><li><p><a href=#conventions-everyone>Para Todos</a></p><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Pídele a tu mentor que te añada al "Additional Contributors" (<span class=filename>doc/shared/contrib-additional.adoc</span>), si todavía no estás en la lista.</p></div></td></tr></tbody></table></div></li><li><p><a href=#developer.relations>Relaciones con los desarrolladores</a></p></li><li><p><a href=#ssh.guide>Guía de inicio rápido de SSH</a></p></li><li><p><a href=#rules>La gran lista de reglas de los Committers de FreeBSD</a></p></li></ul></div></div></div><div class=sect1><h2 id=google-analytics>24. Información sobre Google Analytics<a class=anchor href=#google-analytics></a></h2><div class=sectionbody><div class=paragraph><p>A partir del 12 de diciembre de 2012, se habilitó Google Analytics en el sitio web del Proyecto FreeBSD para recopilar estadísticas de uso anónimas con respecto al uso del sitio.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>El 3 de Marzo de 2022, Google Analytics fue eliminado del Proyecto FreeBSD.</p></div></td></tr></tbody></table></div></div></div><div class=sect1><h2 id=misc>25. Preguntas misceláneas<a class=anchor href=#misc></a></h2><div class=sectionbody><div class=sect2><h3 id=_cómo_accedo_a_people_freebsd_org_para_incluir_algo_de_información_personal_o_información_acerca_de_un_proyecto>25.1. ¿Cómo accedo a people.FreeBSD.org para incluir algo de información personal o información acerca de un proyecto?<a class=anchor href=#_cómo_accedo_a_people_freebsd_org_para_incluir_algo_de_información_personal_o_información_acerca_de_un_proyecto></a></h3><div class=paragraph><p><code>people.FreeBSD.org</code> es lo mismo que <code>freefall.FreeBSD.org</code>. Simplemente crea un directorio <span class=filename>public_html</span>. Cualquier cosa que dejes en ese directorio será automáticamente visible bajo <a href=https://people.FreeBSD.org/>https://people.FreeBSD.org/</a>.</p></div></div><div class=sect2><h3 id=_dónde_se_almacenan_los_archivos_de_la_lista_de_correo>25.2. ¿Dónde se almacenan los archivos de la lista de correo?<a class=anchor href=#_dónde_se_almacenan_los_archivos_de_la_lista_de_correo></a></h3><div class=paragraph><p>Las listas de correo se archivan en <span class=filename>/local/mail</span> en <code>freefall.FreeBSD.org</code>.</p></div></div><div class=sect2><h3 id=_me_gustaría_ser_mentor_de_un_nuevo_committer_qué_proceso_debo_seguir>25.3. Me gustaría ser mentor de un nuevo committer. ¿Qué proceso debo seguir?<a class=anchor href=#_me_gustaría_ser_mentor_de_un_nuevo_committer_qué_proceso_debo_seguir></a></h3><div class=paragraph><p>Lee el documento <a href=https://www.freebsd.org/internal/new-account/>New Account Creation Procedure</a> en las páginas internas.</p></div></div></div></div><div class=sect1><h2 id=benefits>26. Beneficios y Ventajas para los committers de FreeBSD<a class=anchor href=#benefits></a></h2><div class=sectionbody><div class=sect2><h3 id=benefits-recognition>26.1. Reconocimiento<a class=anchor href=#benefits-recognition></a></h3><div class=paragraph><p>El reconocimiento como ingeniero de software competente es el valor más duradero. Además, tener la oportunidad de trabajar con algunas de las mejores personas con las que todo ingeniero soñaría conocer ¡es una gran ventaja!</p></div></div><div class=sect2><h3 id=benefits-freebsdmall>26.2. Centro comercial FreeBSD<a class=anchor href=#benefits-freebsdmall></a></h3><div class=paragraph><p>Los committers de FreeBSD pueden obtener gratis en las conferencias un conjunto de 4-CDs o DVD de <a href=http://www.freebsdmall.com>FreeBSD Mall, Inc.</a>.</p></div></div><div class=sect2><h3 id=benefits-gandi>26.3. <code>Gandi.net</code><a class=anchor href=#benefits-gandi></a></h3><div class=paragraph><p><a href=https://gandi.net>Gandi</a> proporciona hospedaje web, computación en la nube, registro de dominios y servicios de certificados X.509.</p></div><div class=paragraph><p>Gandi oferta una tarifa E-rate de descuento a todos los desarrolladores de FreeBSD. Para facilitar el proceso de obtener el descuento, primero crea una cuenta en Gandi, rellena la información de facturación y selecciona la moneda. Después envía un email a <a href=mailto:non-profit@gandi.net>non-profit@gandi.net</a> usando tu dirección <code>@freebsd.org</code> e indica tu identificador de Gandi.</p></div></div><div class=sect2><h3 id=benefits-rsync>26.4. <code>rsync.net</code><a class=anchor href=#benefits-rsync></a></h3><div class=paragraph><p><a href=https://rsync.net>rsync.net</a> proporciona almacenamiento en la nube para backup que está optimizado para usuarios UNIX. Su servicio funciona en su totalidad con FreeBSD y ZFS.</p></div><div class=paragraph><p>rsync.net oferta una cuenta de 500 GB gratis para siempre para los desarrolladores de FreeBSD. Simplemente regístrate en <a href=https://www.rsync.net/freebsd.html>https://www.rsync.net/freebsd.html</a> usando tu dirección <code>@freebsd.org</code> para recibir esta cuenta gratuita.</p></div></div><div class=sect2><h3 id=benefits-jetbrains>26.5. <code>JetBrains</code><a class=anchor href=#benefits-jetbrains></a></h3><div class=paragraph><p><a href=https://www.jetbrains.com>JetBrains</a> es una compañía de desarrollo de software que crea herramientas para desarrolladores de software y gestores de proyectos. La compañía ofrece varios entornos integrados de desarrollo (IDEs) para distintos lenguajes de programación.</p></div><div class=paragraph><p>JetBrain oferta 100 licencias anuales de forma gratuita para todos <a href=https://www.jetbrains.com/products>sus IDE</a>. Simplemente regístrate en <a href=https://account.jetbrains.com/a/322tl3z7>https://account.jetbrains.com/a/322tl3z7</a> usando tu dirección <code>@freebsd.org</code> y la cuenta tendrá una licencia asociada a ella automáticamente. Una vez que la cuenta esté activa úsala en cualquiera de los productos para activarlos y ya has terminado.</p></div><div class="admonitionblock important"><table><tbody><tr><td class=icon><i class="fa icon-important" title=Important></i></td><td class=content><div class=paragraph><p>Por favor, utiliza estas licencias sólo para uso personal y no las compartas con nadie fuera del proyecto FreeBSD, ya que eso sería una violación de los términos de donación.</p></div></td></tr></tbody></table></div></div></div></div><hr><div class=last-modified><p><strong>Last modified on</strong>: 25 de julio de 2023 by <a href="https://cgit.freebsd.org/doc/commit/?id=9c013aa68f" target=_blank>Fernando Apesteguía</a></p></div></div><aside class=toc><div class=toc-content><h3>Tabla de contenidos</h3><nav id=TableOfContents><ul><li><a href=#admin>1. Detalles administrativos</a></li><li><a href=#pgpkeys>2. Claves OpenPGP de FreeBSD</a></li><li><a href=#kerberos-ldap>3. Kerberos y contraseña web LDAP para el clúster de FreeBSD</a></li><li><a href=#committer.types>4. Tipos de Commit Bits</a></li><li><a href=#git-primer>5. Introducción a Git</a></li><li><a href=#vcs-history>6. Histórico del Control de Versiones</a></li><li><a href=#conventions>7. Configuración, Convenciones y Tradiciones</a></li><li><a href=#pre-commit-review>8. Revisión previa al commit</a></li><li><a href=#commit-log-message>9. Mensajes de Commit</a></li><li><a href=#pref-license>10. Licencia preferida para los nuevos archivos</a></li><li><a href=#tracking.license.grants>11. Seguimiento de las licencias concedidas al proyecto FreeBSD</a></li><li><a href=#spdx.tags>12. Etiquetas SPDX en el árbol</a></li><li><a href=#developer.relations>13. Relaciones con los desarrolladores</a></li><li><a href=#if-in-doubt>14. Si tienes dudas …​</a></li><li><a href=#bugzilla>15. Bugzilla</a></li><li><a href=#phabricator>16. Phabricator</a></li><li><a href=#people>17. Quien es Quien</a></li><li><a href=#ssh.guide>18. Guía de inicio rápido de SSH</a></li><li><a href=#coverity>19. Disponibilidad de Coverity® para los Committers de FreeBSD</a></li><li><a href=#rules>20. La gran lista de reglas de los Committers de FreeBSD</a></li><li><a href=#archs>21. Soporte para múltiples arquitecturas</a></li><li><a href=#ports>22. Preguntas frecuentes sobre ports específicos</a></li><li><a href=#non-committers>23. Problemas Específicos para Desarrolladores que No Son Committers</a></li><li><a href=#google-analytics>24. Información sobre Google Analytics</a></li><li><a href=#misc>25. Preguntas misceláneas</a></li><li><a href=#benefits>26. Beneficios y Ventajas para los committers de FreeBSD</a></li></ul></nav><hr><div class=resources><h3>Recursos</h3><ul class=contents><li><i class="fa fa-file-pdf-o" aria-hidden=true title="Descargar PDF"></i><a href=https://download.freebsd.org/doc/es/articles/committers-guide/committers-guide_es.pdf>Descargar PDF</a></li><li><i class="fa fa-pencil-square-o" aria-hidden=true title="Editar esta página"></i><a href=https://github.com/freebsd/freebsd-doc/blob/main/documentation/content/es/_index target=_blank>Editar esta página</a></li></ul></div></div></aside></main><footer><div class=footer-container><section class=logo-column><img src=https://docs.freebsd.org/images/FreeBSD-colors.svg width=160 height=50 alt="FreeBSD logo"><div class=options-container><div class=language-container><a id=languages href=https://docs.freebsd.org/es/languages><img src=https://docs.freebsd.org/images/language.png class=language-image alt="Elegir idioma">
<span>Spanish</span></a></div><div class=theme-container><select id=theme-chooser><option value=theme-system>System</option><option value=theme-light>Claro</option><option value=theme-dark>Oscuro</option><option value=theme-high-contrast>Alto contraste</option></select></div></div></section><section class=about-column><h3 class=column-title>About</h3><ul class=column-elements-container><li><a href=https://www.freebsd.org/about/ target=_blank class=column-element>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/ target=_blank class=column-element>FreeBSD Foundation</a></li><li><a href=https://www.freebsd.org/where/ target=_blank class=column-element>Get FreeBSD</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct target=_blank class=column-element>Code of Conduct</a></li><li><a href=https://www.freebsd.org/security/ target=_blank class=column-element>Security Advisories</a></li></ul></section><section class=documentation-column><h3 class=column-title>Documentation</h3><ul class=column-elements-container><li><a href=/es class=column-element>Documentation portal</a></li><li><a href=https://man.FreeBSD.org target=_blank class=column-element>Manual pages</a></li><li><a href=https://papers.FreeBSD.org target=_blank class=column-element>Presentations and papers</a></li><li><a href=https://docs-archive.freebsd.org/doc/ target=_blank class=column-element>Previous versions</a></li><li><a href=https://docs-archive.freebsd.org/44doc/ target=_blank class=column-element>4.4BSD Documents</a></li><li><a href=https://wiki.freebsd.org/ target=_blank class=column-element>Wiki</a></li></ul></section><section class=community-column><h3 class=column-title>Community</h3><ul class=column-elements-container><li><a href=https://docs.freebsd.org/es/articles/contributing class=column-element>Get involved</a></li><li><a href=https://forums.freebsd.org/ target=_blank class=column-element>Community forum</a></li><li><a href=https://lists.freebsd.org/ target=_blank class=column-element>Mailing lists</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank class=column-element>IRC Channels</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank class=column-element>Bug Tracker</a></li></ul></section><section class=legal-column><h3 class=column-title>Legal</h3><ul class=column-elements-container><li><a href=https://freebsdfoundation.org/donate/ target=_blank class=column-element>Donations</a></li><li><a href=https://www.freebsd.org/copyright/freebsd-license/ target=_blank class=column-element>Licensing</a></li><li><a href=https://www.freebsd.org/privacy/ target=_blank class=column-element>Privacy Policy</a></li><li><a href=https://www.freebsd.org/copyright/ target=_blank class=column-element>Legal notices</a></li></ul></section><section class=copyright-column><p>&copy; 1994-2024 The FreeBSD Project. All rights reserved</p><span>Made with <span class=heart>♥</span> by the FreeBSD Community</span></section></div></footer></body></html>