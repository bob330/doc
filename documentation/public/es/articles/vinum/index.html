<!doctype html><html class=theme-light lang=es><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="El Gestor de Volúmenes vinum en FreeBSD"><meta name=keywords content="vinum,Volume Manager,FreeBSD"><meta name=copyright content="1995-2024 The FreeBSD Foundation"><link rel=canonical href=https://docs.freebsd.org/es/articles/vinum/><title>El Gestor de Volúmenes vinum | Portal de documentación de FreeBSD</title>
<meta name=theme-color content="#790000"><meta name=color-scheme content="system light dark high-contrast"><link rel="shortcut icon" href=https://docs.freebsd.org/favicon.ico><link rel=stylesheet href=https://docs.freebsd.org/styles/main.min.css><link rel=stylesheet href=https://docs.freebsd.org/css/font-awesome-min.css><script defer src=/js/theme-chooser.min.js></script><script defer src=/js/copy-clipboard.min.js></script><script defer src=/js/search.min.js></script><meta name=twitter:card content="summary"><meta name=twitter:domain content="docs.FreeBSD.org"><meta name=twitter:site content="@freebsd"><meta name=twitter:url content="https://twitter.com/freebsd"><meta property="og:title" content="El Gestor de Volúmenes vinum"><meta property="og:description" content="El Gestor de Volúmenes vinum en FreeBSD"><meta property="og:type" content="website"><meta property="og:image" content="https://docs.freebsd.org/favicon.ico"><meta property="og:image:alt" content="FreeBSD Logo"><meta property="og:locale" content="es"><meta property="og:url" content="https://docs.freebsd.org/es/articles/vinum/"><meta property="og:site_name" content="Portal de documentación de FreeBSD"><script type=application/ld+json>{"@context":"http://schema.org","@type":"Article","url":"https:\/\/docs.freebsd.org\/es\/articles\/vinum\/","name":"Portal de documentación de FreeBSD","headline":"Portal de documentación de FreeBSD","description":"FreeBSD Documentation Portal"}</script></head><body><header><div class=header-container><div class=logo-menu-bars-container><a href=https://www.FreeBSD.org class=logo><img src=https://docs.freebsd.org/images/FreeBSD-monochromatic.svg width=160 height=50 alt="FreeBSD logo">
</a><label class=menu-bars for=menu-bars><i class="fa fa-bars" aria-hidden=true></i></label></div><input id=menu-bars type=checkbox><nav><ul class=menu><li class=menu-item><input id=about type=checkbox>
<a href=# aria-label="Navigate to About section"><label class=menu-item-description for=about>About
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/about/ target=_blank>About</a></li><li><a href=https://www.freebsd.org/about/ target=_blank>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/about-us/about-the-foundation/ target=_blank>FreeBSD Foundation</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct/ target=_blank>Code of Conduct</a></li></ul></li><li class=menu-item><input id=download type=checkbox>
<a href=# aria-label="Navigate to get FreeBSD section"><label class=menu-item-description for=download>Get FreeBSD
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/where/ target=_blank>Get FreeBSD</a></li><li><a href=https://www.freebsd.org/releases/ target=_blank>Release Information</a></li><li><a href=https://www.freebsd.org/releng/ target=_blank>Release Engineering</a></li><li><a href=https://www.freebsd.org/security/ target=_blank>Security Advisories</a></li></ul></li><li class=menu-item><input id=documentation type=checkbox>
<a href=# aria-label="Navigate to get Documentation section"><label class=menu-item-description for=documentation>Documentation
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=/es>Documentation portal</a></li><li><a href=https://docs.freebsd.org/es/books/handbook>FreeBSD Handbook</a></li><li><a href=https://docs.freebsd.org/es/books/porters-handbook>Porter's Handbook</a></li><li><a href=https://docs.FreeBSD.org/en/books/fdp-primer>Documentation Project Handbook</a></li><li><a href=https://man.FreeBSD.org target=_blank>Manual pages</a></li><li><a href=https://papers.FreeBSD.org target=_blank>Presentations and papers</a></li><li><a href=https://wiki.FreeBSD.org target=_blank>Wiki</a></li><li><a href=https://docs.freebsd.org/es/books>Books</a></li><li><a href=https://docs.freebsd.org/es/articles>Articles</a></li></ul></li><li class=menu-item><input id=community type=checkbox>
<a href=# aria-label="Navigate to get Community section"><label class=menu-item-description for=community>Community
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/community/>Community</a></li><li><a href=https://docs.freebsd.org/es/articles/contributing>Get involved</a></li><li><a href=https://forums.freebsd.org/ target=_blank>Forum</a></li><li><a href=https://lists.freebsd.org/ target=_blank>Mailing lists</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank>IRC Channels</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank>Bug Tracker</a></li><li><a href=https://www.freebsd.org/support/ target=_blank>Support</a></li></ul></li></ul></nav><div class=search-donate-container><form class=search method=get id=search-header-form action=https://docs.freebsd.org/search name=search-header-form><input type=hidden name=DB value=es>
<input id=words name=P type=text size=20 maxlength=255>
<button>
<i class="fa fa-search" aria-hidden=true></i></button></form><div class=donate><a href=https://freebsdfoundation.org/donate/ target=_blank><span class=heart>♥</span>
Donate</a></div></div></div></header><main class=main-wrapper-article><div class=article><h1 class=title>El Gestor de Volúmenes vinum</h1><div class="admonitionblock note"><p><i class="fa fa-exclamation-circle" aria-hidden=true></i>
This translation may be out of date. To help with the translations please access the <a href=https://translate-dev.freebsd.org/ target=_blank>FreeBSD translations instance</a>.</p></div><div class=toc-mobile><h3>Tabla de contenidos</h3><nav id=TableOfContents><ul><li><a href=#vinum-synopsis>1. Sinopsis</a></li><li><a href=#vinum-access-bottlenecks>2. Cuellos de botella de acceso</a></li><li><a href=#vinum-data-integrity>3. Integridad de los Datos</a></li><li><a href=#vinum-objects>4. Objetos <span class=filename>vinum</span></a></li><li><a href=#vinum-examples>5. Algunos Ejemplos</a></li><li><a href=#vinum-object-naming>6. Nombrado de Objetos</a></li><li><a href=#vinum-config>7. Configurando <span class=filename>vinum</span></a></li><li><a href=#vinum-root>8. Usando <span class=filename>vinum</span> para el Sistema de Ficheros Raíz</a></li></ul></nav></div><div id=preamble><div class=sectionbody><hr></div></div><div class=sect1><h2 id=vinum-synopsis>1. Sinopsis<a class=anchor href=#vinum-synopsis></a></h2><div class=sectionbody><div class=paragraph><p>Independientemente del tipo de disco, siempre hay problemas potenciales. Los discos pueden ser muy pequeños, muy lentos, o muy poco fiables para cumplir con los requisitos del sistema. Aunque los discos crecen, también lo hacen los requisitos de almacenamiento. A menudo se necesita un sistema de ficheros que es mayor que la capacidad del disco. Se han propuesto e implementado varias soluciones a estos problemas.</p></div><div class=paragraph><p>Un método es mediante el uso de múltiples, y a veces redundantes, discos. Además de soportar varias tarjetas y controladores hardware de sistemas de Arrays Redundantes de Discos Independientes <code>RAID</code> , el sistema base de FreeBSD incluye el gestor de volúmenes <span class=filename>vinum</span> , un controlador de dispositivos de bloques que implementa unidades virtuales de disco y que aborda estos tres problemas. <span class=filename>vinum</span> proporciona más flexibilidad, rendimiento, y fiabilidad que el almacenamiento de disco tradicional e implementa los modelos <code>RAID</code>-0, <code>RAID</code>-1, y <code>RAID</code>-5 , tanto individualmente como combinados.</p></div><div class=paragraph><p>Este capítulo proporciona una visión general de los problemas potenciales del almacenamiento tradicional en disco, y una introducción al gestor de volúmenes <span class=filename>vinum</span>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Comenzando con FreeBSD 5, <span class=filename>vinum</span> ha sido reescrito para adaptarlo a la <a href=https://docs.freebsd.org/es/books/handbook/#geom>GEOM architecture</a>, a la vez que se mantienen las ideas originales, terminología, y metadata en disco. Esta reescritura se llama <em>gvinum</em> (por <em>GEOM vinum</em>). Aunque este capítulo utiliza el término <span class=filename>vinum</span>, cualquier invocación de comando se debe realizar con <code>gvinum</code>. El nombre del módulo del kernel ha cambiado del original <span class=filename>vinum.ko</span> a <span class=filename>geom_vinum.ko</span>, y todos los nodos de dispositivo residen bajo <span class=filename>/dev/gvinum</span> en lugar de <span class=filename>/dev/vinum</span>. A partir de FreeBSD 6, la implementación original de <span class=filename>vinum</span> no está disponible en el código base.</p></div></td></tr></tbody></table></div></div></div><div class=sect1><h2 id=vinum-access-bottlenecks>2. Cuellos de botella de acceso<a class=anchor href=#vinum-access-bottlenecks></a></h2><div class=sectionbody><div class=paragraph><p>Los sistemas modernos necesitan frecuentemente acceder a los datos de una forma altamente concurrente. Por ejemplo, grandes servidores de FTP o HTTP pueden mantener miles de sesiones concurrents y tener conexiones de 100 Mbit/s al mundo exterior, mucho más que la tasa de transferencia mantenida de la mayoría de los discos.</p></div><div class=paragraph><p>Las unidades de disco actuales pueden transferir datos secuencialmente hasta unos 70 MB/s, pero este valor tiene poca importancia en un entorno en el que muchos procesos independientes acceden a un dispositivo, y donde solo pueden conseguir una fracción de esos valores. En tales casos, es más interesante ver el problema desde el punto de vista del subsistema de disco. El parámetro importante es la carga que una transferencia supone en el subsistema, o el tiempo para el cual la transferencia ocupa los dispositivos involucrados en la misma.</p></div><div class=paragraph><p>En cualquier transferencia de disco, la unidad debe primero posicionar el cabezal, esperar a que el primer sector pase bajo la cabeza de lectura, y después realizar la transferencia. Estas acciones pueden considerarse atómicas y que no tiene sentido interrumpirlas.</p></div><div class=paragraph><p><a id=vinum-latency></a>Considera una transferencia típica de unos 10 kB: la generación actual de discos de alto rendimiento pueden situar los cabezales en unos 3.5 ms de media. Los discos más rápidos giran a 15,000 rpm, así que la latencia rotacional media (media revolución) es 2 ms. A 70 MB/s, la propia transferencia tarda unos 150 μs, casi nada comparado con el tiempo de posicionamiento. En ese caso, la tasa efectiva de transferencia cae hasta un poco más de 1 MB/s y depende claramente del tamaño de la transferencia.</p></div><div class=paragraph><p>La solución obvia y tradicional a este cuello de botella es "más agujas": en lugar de usar un gran disco, usar varios discos pequeños con el mismo espacio de almacenamiento agregado. Cada disco es capaz de posicionar y transferir de forma independiente, así que el rendimiento efectivo aumenta en un factor próximo al número de discos utilizados.</p></div><div class=paragraph><p>La mejora de rendimiento real es menor que el número de discos involucrados. Aunque cada dispositivo es capaz de transferir en paralelo, no hay forma de asegurar que las peticiones se distribuyen de forma equilibrada entre los dispositivos. Inevitablemente la carga en un dispositivo será mayor que en otro.</p></div><div class=paragraph><p>El reparto equitativo de la carga en los discos depende fuertemente de la forma en la que los datos se comparten entre los dispositivos. En la siguiente discusión, es conveniente pensar en el almacenamiento de disco como un número grande de sectores que son direccionables mediante un número, parecido a las páginas de un libro. El método más obvio es dividir el disco virtual en grupos de sectores consecutivos del tamaño de los discos físicos individuales y almacenarlos de este modo, como coger un libro grande y romperlo en secciones pequeñas. Este método se llama <em>concatenación</em> y tiene la ventaja de que los discos no requieren tener ninguna relación específica de tamaño entre ellos. Funciona bien cuando los accesos al disco virtual se reparten equitativamente en su espacio de direcciones. Cuando el acceso se concentra en un área más pequeña, la mejora es menos acentuada. <a href=#vinum-concat>Organización Concatenada</a> ilustra una secuencia en la que las unidades de almacenamiento están asignadas en una organización concatenada.</p></div><div id=vinum-concat class=imageblock><div class=content><img src=../../../images/articles/vinum/vinum-concat.png alt="vinum concat"></div><div class=title>Figura 1. Organización Concatenada</div></div><div class=paragraph><p>Un mapeo alternativo es dividir el espacio de direcciones en componentes más pequeños del mismos tamaño y almacenarlos secuencialmente en distintos dispositivos. Por ejemplo, los primeros 256 sectores podrían ser almacenados en el primer disco, los 256 sectores siguientes en el siguiente disco, etc. Después de rellenar el último disco, el proceso se repite hasta que los discos están llenos. Este mapeo se llama <em>segmentado</em> o <code>RAID-0</code>.</p></div><div class=paragraph><p><code>RAID</code> ofrece varias formas de tolerancia a fallos, aunque <code>RAID-0</code> es algo engañoso ya que no provee redundancia. El segmentado requiere algo más de esfuerzo para localizar el dato, y puede ocasionar carga de E/S adicional cuando una transferencia está repartida por múltiples discos, pero también puede proporcionar una carga más constante entre los discos. <a href=#vinum-striped>Organización Segmentada</a> ilustra la secuencia en la que las unidades de discos están asignadas en una organización segmentada.</p></div><div id=vinum-striped class=imageblock><div class=content><img src=../../../images/articles/vinum/vinum-striped.png alt="vinum striped"></div><div class=title>Figura 2. Organización Segmentada</div></div></div></div><div class=sect1><h2 id=vinum-data-integrity>3. Integridad de los Datos<a class=anchor href=#vinum-data-integrity></a></h2><div class=sectionbody><div class=paragraph><p>El último problema con los discos es que no son fiables. Aunque la fiabilidad se ha incrementado tremendamente en los últimos años, las unidades de disco todavía son el componente central de un servidor más propensos a fallar. Cuando lo hacen, los resultados pueden ser catastróficas y reemplazar una unidad de disco que ha fallado y restaurar los datos puede resultar en tiempo de parada del servidor.</p></div><div class=paragraph><p>Una aproximación a este problema es el <em>mirroring</em>, o <code>RAID-1</code>, que mantiene dos copias de los datos en distinto hardware físico. Cualquier escritura en el volumen escribe en ambos discos; una lectura puede ser resuelta por cualquiera, así que si un disco falla, los datos todavía están disponibles en la otra unidad.</p></div><div class=paragraph><p>La configuración en espejo tiene dos problemas:</p></div><div class=ulist><ul><li><p>Requiere el doble de espacio de almacenamiento que una solución sin redundancia.</p></li><li><p>Las escrituras deben realizarse en las dos unidades, de forma que utilizan el doble de ancho de banda que un volumen sin espejo. Las lecturas no sufren penalización en lectura e incluso pueden ser más rápidas.</p></li></ul></div><div class=paragraph><p>Una solución alternativa es la <em>paridad</em>, implementada en los niveles <code>RAID</code> 2, 3, 4 y 5. De estos, <code>RAID-5</code> es el más interesante. Como está implementado en <span class=filename>vinum</span>, es una variante en una organización segmentada que dedica un bloque en cada segmento para guardar la paridad de los otros bloques. Tal como está implementado en <span class=filename>vinum</span>, un <code>RAID-5</code> plex es similar a un plex segmentado, excepto que implementa <code>RAID-5</code> al incluir un bloque de paridad en cada segmento. Según lo requerido por <code>RAID-5</code>, la localización de este bloque de paridad cambia de un segmento al siguiente. Los números en los bloques de datos indican los números de bloque relativos.</p></div><div id=vinum-raid5-org class=imageblock><div class=content><img src=../../../images/articles/vinum/vinum-raid5-org.png alt="vinum raid5 org"></div><div class=title>Figura 3. Organización <code>RAID</code>-5</div></div><div class=paragraph><p>Comparado con la configuración en espejo, <code>RAID-5</code> tiene la ventaja de que requiere mucho menos espacio de almacenamiento. El acceso de lectura es similar a una organización segmentada, pero el acceso de escritura es significativamente más lento, aproximadamente el 25% del rendimiento de lectura. Si una unidad falla, el array puede seguir operando en un modo degradado donde una lectura de una de las unidades que quedan accesibles continua normalmente, pero una lectura de una unidad que ha fallado es recalculada a partir de los bloques correspondientes del resto de unidades.</p></div></div></div><div class=sect1><h2 id=vinum-objects>4. Objetos <span class=filename>vinum</span><a class=anchor href=#vinum-objects></a></h2><div class=sectionbody><div class=paragraph><p>Para abordar estos problemas, <span class=filename>vinum</span> implementa una jerarquía de objetos en cuatro niveles:</p></div><div class=ulist><ul><li><p>El objeto más visible es el disco virtual, llamado <em>volumen</em>. Volúmenes tienen esencialmente las mismas propiedades que una unidad de disco UNIX® aunque hay algunas pequeñas diferencias. Una de ellas, que no tienen limitación de tamaño.</p></li><li><p>Los volúmenes se componen de <em>plexes</em>, cada uno de los cuales representa el espacio de direcciones total de un volumen. Este nivel en la jerarquía proporciona redundancia. Piensa en los plexes como en discos individuales en un array replicado en espejo, cada uno conteniendo los mismos datos.</p></li><li><p>Puesto que <span class=filename>vinum</span> existe dentro del framework de almacenamiento de disco de UNIX®, sería posible utilizar particiones UNIX como bloques de construcción para plexes multi-disco. En realidad, esto resulta demasiado poco flexible ya que los discos UNIX sólo pueden tener un número limitado de particiones. En su lugar, <span class=filename>vinum</span> subdivide una única partición UNIX, la <em>drive</em>, en areas contiguas llamadas <em>subdiscos</em>, los cuales se utilizan como bloques de construcción de plexes.</p></li><li><p>Los subdiscos residen en <em>unidades</em> <span class=filename>vinum</span>, actualmente particiones UNIX®. Las unidades <span class=filename>vinum</span> pueden tener cualquier número de subdiscos. Con la excepción de una pequeña área al comienzo de la unidad, que es utilizada para almacenar información de estado y configuración, la unidad entera está disponible para almacenamiento de datos.</p></li></ul></div><div class=paragraph><p>Las secciones siguientes describen el modo en el que estos objetos proporcionan la funcionalidad requerida por <span class=filename>vinum</span>.</p></div><div class=sect2><h3 id=_consideraciones_sobre_el_tamaño_del_volumen>4.1. Consideraciones sobre el Tamaño del Volumen<a class=anchor href=#_consideraciones_sobre_el_tamaño_del_volumen></a></h3><div class=paragraph><p>Plexes pueden incluir múltiples subdiscos repartidos por todas las unidades en la configuración de <span class=filename>vinum</span>.. Como resultado, el tamaño de una unidad individual no limita el tamaño de un plex o un volumen.</p></div></div><div class=sect2><h3 id=_almacenamiento_de_datos_redundante>4.2. Almacenamiento de Datos Redundante<a class=anchor href=#_almacenamiento_de_datos_redundante></a></h3><div class=paragraph><p><span class=filename>vinum</span>. implementa configuraciones en espejo adjuntando varios plexes a un volumen. Cada plex es una representación de los datos en un volumen. Un volumen puede contener entre uno y ocho plexes.</p></div><div class=paragraph><p>Aunque un plex representa los datos completos de un volumen, es posible que algunas partes de esta representación falten físicamente, bien por diseño (no definiendo un subdisco para algunas partes del plex) o por accidente (como resultado del fallo de una unidad). Mientras un plex pueda proveer los datos para el rango completo de direcciones del volumen, este es plenamente funcional.</p></div></div><div class=sect2><h3 id=_qué_organización_plex>4.3. ¿Qué Organización Plex?<a class=anchor href=#_qué_organización_plex></a></h3><div class=paragraph><p><span class=filename>vinum</span>. implementa tanto concatenación como segmentado a nivel de plex:</p></div><div class=ulist><ul><li><p>Un <em>plex concatenado</em> usa el espacio de direcciones de cada subdisco por turnos. Los plexes concatenados son los más flexibles ya que pueden contener cualquier número de subdiscos, y los subidscos pueden ser de distintas longitudes. El plex se puede extender añadiendo subdiscos adicionales. Requieren menos tiempo de <code>CPU</code> que los plexes segmentados, aunque la diferencia en sobrecarga de <code>CPU</code> casi no se nota. Por otro lado, son más susceptibles a los puntos calientes, en donde un disco está muy activo y los otros ociosos.</p></li><li><p>Un <em>plex segmentado</em> reparte los datos entre los distintos subdiscos. Los subdiscos deben tener todos el mismo tamaño y debe haber al menos dos subdiscos para poder distinguirlo de un plex concatenado. La mayor ventaja de los plexes segmentados es que reducen los puntos calientes. Escogiendo un tamaño óptimo de segmento, alrededor de 256 kB, la carga se puede repartir equitativamente entre las unidades. Extender un plex añadiendo nuevos subdiscos es tan complicado que <span class=filename>vinum</span> no lo implementa.</p></li></ul></div><div class=paragraph><p><a href=#vinum-comparison><span class=filename>vinum</span> Organizaciones Plex</a> resume las ventajas y desventajas de cada organización plex.</p></div><table id=vinum-comparison class="tableblock frame-none grid-all stretch"><caption class=title>Tabla 1. <span class=filename>vinum</span> Organizaciones Plex</caption><col style=width:20%><col style=width:20%><col style=width:20%><col style=width:20%><col style=width:20%><thead><tr><th class="tableblock halign-left valign-top">Tipo Plex</th><th class="tableblock halign-left valign-top">Subdiscos mínimos</th><th class="tableblock halign-left valign-top">Puede añadir subdiscos</th><th class="tableblock halign-left valign-top">Debe tener el mismo tamaño</th><th class="tableblock halign-left valign-top">Aplicación</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>concatenado</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>1</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>sí</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>no</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Gran almacenamiento de datos con máxima flexibilidad de disposición y rendimiento moderado</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>segmentado</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>2</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>no</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>sí</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Alto rendimiento combinado con alto acceso concurrente</p></td></tr></tbody></table></div></div></div><div class=sect1><h2 id=vinum-examples>5. Algunos Ejemplos<a class=anchor href=#vinum-examples></a></h2><div class=sectionbody><div class=paragraph><p><span class=filename>vinum</span> mantiene una <em>base de datos de configuración</em> la cual describe los objetos que son conocidos a un sistema individual. Inicialmente, el usuario crea la base de datos de configuración a partir de uno o más ficheros de configuración utilizando <a href="https://man.freebsd.org/cgi/man.cgi?query=gvinum&amp;sektion=8&amp;format=html">gvinum(8)</a>. <span class=filename>vinum</span> almacena una copia de su base de datos de configuración en cada <em>dispositivo</em> de disco bajo su control. Esta base de datos se actualiza con cada cambio de estado, de forma que un reinicio restablece de forma precisa el estado de cada objeto de <span class=filename>vinum</span>.</p></div><div class=sect2><h3 id=_el_fichero_de_configuración>5.1. El Fichero de Configuración<a class=anchor href=#_el_fichero_de_configuración></a></h3><div class=paragraph><p>El fichero de configuración describe objetos de <span class=filename>vinum</span> individuales. La definición de un volumen sencillo podría ser:</p></div><div class="literalblock programlisting"><div class=content><pre>    drive a device /dev/da3h
    volume myvol
      plex org concat
        sd length 512m drive a</pre></div></div><div class=paragraph><p>Este fichero describe cuatro objetos <span class=filename>vinum</span>:</p></div><div class=ulist><ul><li><p>La línea <em>unidad</em> describe una partición de disco (<em>unidad</em>) y su localización relativa al hardware que hay debajo. Se le da el nombre simbólico <em>a</em>. La separación entre los nombres simbólicos y los nombres de dispositivo permite mover discos de un lugar a otro sin confusión.</p></li><li><p>La línea <em>volumen</em> describe un volumen. El único atributo requerido es el nombre, en este caso <em>myvol</em>.</p></li><li><p>La línea <em>plex</em> define un plex. El único parámetro requerido es la organización, en este caso <em>concat</em>. El nombre no es necesario ya que el sistema genera uno automáticamente a partir del nombre del volumen añadiendo el sufijo <em>.px</em>, donde <em>x</em> es el número del plex en el volumen. Por lo tanto este plex se llamará <em>myvol.p0</em>.</p></li><li><p>La línea <em>sd</em> describe un subdisco. La especificación mínima incluye el nombre de la unidad en la que almacenarlo, y la longitud del subdisco. El nombre no es necesario ya que el sistema asigna un nombre automáticamente derivado del nombre del plex añadiendo el sufijo <em>.sx</em>, donde <em>x</em> es el número del subdisco en el plex. Por lo tanto <span class=filename>vinum</span> asigna a este subdisco el nombre <em>myvol.p0.s0</em>.</p></li></ul></div><div class=paragraph><p>Después de procesar este fichero, <a href="https://man.freebsd.org/cgi/man.cgi?query=gvinum&amp;sektion=8&amp;format=html">gvinum(8)</a> produce la siguiente salida:</p></div><div class="literalblock programlisting"><div class=content><pre>#  gvinum -&gt; create config1
Configuration summary
Drives:         1 (4 configured)
Volumes:        1 (4 configured)
Plexes:         1 (8 configured)
Subdisks:       1 (16 configured)

  D a                     State: up       Device /dev/da3h      Avail: 2061/2573 MB (80%)

  V myvol                 State: up       Plexes:       1 Size:      512 MB

  P myvol.p0            C State: up       Subdisks:     1 Size:      512 MB

  S myvol.p0.s0           State: up       PO:        0  B Size:      512 MB</pre></div></div><div class=paragraph><p>Esta salida muestra el formato de lista abreviada de <a href="https://man.freebsd.org/cgi/man.cgi?query=gvinum&amp;sektion=8&amp;format=html">gvinum(8)</a>. Está representado gráficamente en <a href=#vinum-simple-vol>Un Volumen <span class=filename>vinum</span> Simple</a>.</p></div><div id=vinum-simple-vol class=imageblock><div class=content><img src=../../../images/articles/vinum/vinum-simple-vol.png alt="vinum simple vol"></div><div class=title>Figura 4. Un Volumen <span class=filename>vinum</span> Simple</div></div><div class=paragraph><p>Esta imagen, y las que siguen, representa un volumen, el cual contiene plexes, que a su vez contienen subdiscos. En este ejemplo, el volumen contiene un plex, y el plex contiene un subdisco.</p></div><div class=paragraph><p>Este volumen en particular no tiene ninguna ventaja sobre una partición de disco convencional. Contiene un solo plex, así que no es redundante. El plex contiene un solo subdisco, así que no hay diferencia en la asignación de almacenamiento respecto a una partición de disco convencional. Las siguientes secciones ilustran varios métodos de configuración más interesantes.</p></div></div><div class=sect2><h3 id=_resiliencia_incrementada_configuración_en_espejo>5.2. Resiliencia Incrementada: Configuración en Espejo<a class=anchor href=#_resiliencia_incrementada_configuración_en_espejo></a></h3><div class=paragraph><p>La resiliencia de un volumen puede ser incrementada mediante una configuración en espejo. Cuando se diseña un volumen en espejo, es importante asegurar que los subdiscos de cada plex están en diferentes unidades, de forma que el fallo de una unidad no arrastre ambos plexes. La siguiente configuración crea un espejo de un volumen:</p></div><div class="literalblock programlisting"><div class=content><pre>	drive b device /dev/da4h
	volume mirror
      plex org concat
        sd length 512m drive a
	  plex org concat
	    sd length 512m drive b</pre></div></div><div class=paragraph><p>En este ejemplo, no ha sido necesario especificar la definición de la unidad <em>a</em> de nuevo, ya que <span class=filename>vinum</span> hace un seguimiento de todos los objetos en su base de datos de configuración. Después de procesar esta definición, la configuración tiene este aspecto:</p></div><div class="literalblock programlisting"><div class=content><pre>	Drives:         2 (4 configured)
	Volumes:        2 (4 configured)
	Plexes:         3 (8 configured)
	Subdisks:       3 (16 configured)

	D a                     State: up       Device /dev/da3h       Avail: 1549/2573 MB (60%)
	D b                     State: up       Device /dev/da4h       Avail: 2061/2573 MB (80%)

    V myvol                 State: up       Plexes:       1 Size:        512 MB
    V mirror                State: up       Plexes:       2 Size:        512 MB

    P myvol.p0            C State: up       Subdisks:     1 Size:        512 MB
    P mirror.p0           C State: up       Subdisks:     1 Size:        512 MB
    P mirror.p1           C State: initializing     Subdisks:     1 Size:        512 MB

    S myvol.p0.s0           State: up       PO:        0  B Size:        512 MB
	S mirror.p0.s0          State: up       PO:        0  B Size:        512 MB
	S mirror.p1.s0          State: empty    PO:        0  B Size:        512 MB</pre></div></div><div class=paragraph><p><a href=#vinum-mirrored-vol>Un Volumen <span class=filename>vinum</span> en Espejo</a> muestra la estructura gráficamente.</p></div><div id=vinum-mirrored-vol class=imageblock><div class=content><img src=../../../images/articles/vinum/vinum-mirrored-vol.png alt="vinum mirrored vol"></div><div class=title>Figura 5. Un Volumen <span class=filename>vinum</span> en Espejo</div></div><div class=paragraph><p>En este ejemplo, cada plex contiene los 512 MB del espacio de direcciones completo. Como en el ejemplo anterior, cada plex contiene solo un subdisco.</p></div></div><div class=sect2><h3 id=_optimizando_el_rendimiento>5.3. Optimizando el Rendimiento<a class=anchor href=#_optimizando_el_rendimiento></a></h3><div class=paragraph><p>El volumen en espejo del ejemplo anterior es más resistente a fallos que un volumen que no esté en espejo, pero su rendimiento es menor ya que cada escritura en el volumen requiere una escritura en ambas unidades, usando una mayor porción del ancho de banda total del disco. Las consideraciones de rendimiento requieren una aproximación diferente: en lugar de replicar en espejo, los datos son segmentados en tantas unidades de disco como sea posible. La siguiente configuración muestra un volumen con un plex segmentado en cuatro discos:</p></div><div class="literalblock programlisting"><div class=content><pre>        drive c device /dev/da5h
	drive d device /dev/da6h
	volume stripe
	plex org striped 512k
	  sd length 128m drive a
	  sd length 128m drive b
	  sd length 128m drive c
	  sd length 128m drive d</pre></div></div><div class=paragraph><p>Como antes, no es necesario definir las unidades que ya son conocidas por <span class=filename>vinum</span>. Después de procesar esta definición, la configuración tiene este aspecto:</p></div><div class="literalblock programlisting"><div class=content><pre>	Drives:         4 (4 configured)
	Volumes:        3 (4 configured)
	Plexes:         4 (8 configured)
	Subdisks:       7 (16 configured)

    D a                     State: up       Device /dev/da3h        Avail: 1421/2573 MB (55%)
    D b                     State: up       Device /dev/da4h        Avail: 1933/2573 MB (75%)
    D c                     State: up       Device /dev/da5h        Avail: 2445/2573 MB (95%)
    D d                     State: up       Device /dev/da6h        Avail: 2445/2573 MB (95%)

    V myvol                 State: up       Plexes:       1 Size:        512 MB
    V mirror                State: up       Plexes:       2 Size:        512 MB
    V striped               State: up       Plexes:       1 Size:        512 MB

    P myvol.p0            C State: up       Subdisks:     1 Size:        512 MB
    P mirror.p0           C State: up       Subdisks:     1 Size:        512 MB
    P mirror.p1           C State: initializing     Subdisks:     1 Size:        512 MB
    P striped.p1            State: up       Subdisks:     1 Size:        512 MB

    S myvol.p0.s0           State: up       PO:        0  B Size:        512 MB
    S mirror.p0.s0          State: up       PO:        0  B Size:        512 MB
    S mirror.p1.s0          State: empty    PO:        0  B Size:        512 MB
    S striped.p0.s0         State: up       PO:        0  B Size:        128 MB
    S striped.p0.s1         State: up       PO:      512 kB Size:        128 MB
    S striped.p0.s2         State: up       PO:     1024 kB Size:        128 MB
    S striped.p0.s3         State: up       PO:     1536 kB Size:        128 MB</pre></div></div><div id=vinum-striped-vol class=imageblock><div class=content><img src=../../../images/articles/vinum/vinum-striped-vol.png alt="vinum striped vol"></div><div class=title>Figura 6. Un Volumen <span class=filename>vinum</span> Segmentado</div></div><div class=paragraph><p>Este volumen está representado en <a href=#vinum-striped-vol>Un Volumen <span class=filename>vinum</span> Segmentado</a>. El color oscuro de los segmentos indican la posición dentro del espacio de direcciones del plex, donde los segmentos más claros aparecen primero y los más oscuros últimos.</p></div></div><div class=sect2><h3 id=_resiliencia_y_rendimiento>5.4. Resiliencia y Rendimiento<a class=anchor href=#_resiliencia_y_rendimiento></a></h3><div class=paragraph><p><a id=vinum-resilience></a>Con suficiente hardware, es posible construir volúmenes que muestren resiliencia aumentada y rendimiento aumentado comparado con particiones UNIX® estándar. Una configuración típica podría ser:</p></div><div class="literalblock programlisting"><div class=content><pre>	volume raid10
      plex org striped 512k
        sd length 102480k drive a
        sd length 102480k drive b
        sd length 102480k drive c
        sd length 102480k drive d
        sd length 102480k drive e
      plex org striped 512k
        sd length 102480k drive c
        sd length 102480k drive d
        sd length 102480k drive e
        sd length 102480k drive a
        sd length 102480k drive b</pre></div></div><div class=paragraph><p>Los subdiscos del segundo plex están desplazados en dos unidades respecto a aquellos en el primer flex. Esto ayuda a garantizar que las escrituras no van al mismo subdisco incluso si la transferencia se realiza sobre dos unidades.</p></div><div class=paragraph><p><a href=#vinum-raid10-vol>Un Volumen <span class=filename>vinum</span> Segmentado en Espejo</a> representa la estructura de este volumen.</p></div><div id=vinum-raid10-vol class=imageblock><div class=content><img src=../../../images/articles/vinum/vinum-raid10-vol.png alt="vinum raid10 vol"></div><div class=title>Figura 7. Un Volumen <span class=filename>vinum</span> Segmentado en Espejo</div></div></div></div></div><div class=sect1><h2 id=vinum-object-naming>6. Nombrado de Objetos<a class=anchor href=#vinum-object-naming></a></h2><div class=sectionbody><div class=paragraph><p><span class=filename>vinum</span> asigna nombres por defecto a los plexes y los subdiscos, aunque pueden ser modificados. Modificar los nombres por defecto no está recomendado ya que no proporciona una ventaja significativa y puede provocar confusión.</p></div><div class=paragraph><p>Los nombres pueden contener cualquier carácter que no sea blanco, pero se recomienda restringirlos a letras, dígitos y al carácter subrayado. Los nombres de los volúmenes, plexes y subdiscos pueden tener hasta 64 caracteres de longitud, y los nombres de unidades pueden ser de hasta 32 caracteres de longitud.</p></div><div class=paragraph><p>A los objetos <span class=filename>vinum</span> se les asignan nodos de dispositivo en la jerarquía <span class=filename>/dev/gvinum</span>. La configuración que se muestra arriba haría que <span class=filename>vinum</span> creara los siguientes nodos de dispositivo:</p></div><div class=ulist><ul><li><p>Entradas de dispositivo para cada volumen. Estos son los dispositivos principales utilizados por <span class=filename>vinum</span>. La configuración anterior incluiría los dispositivos <span class=filename>/dev/gvinum/myvol</span>, <span class=filename>/dev/gvinum/mirror</span>, <span class=filename>/dev/gvinum/striped</span>, <span class=filename>/dev/gvinum/raid5</span> y <span class=filename>/dev/gvinum/raid10</span>.</p></li><li><p>Todos los volúmenes tienen entradas directas bajo <span class=filename>/dev/gvinum/</span>.</p></li><li><p>Los directorios <span class=filename>/dev/gvinum/plex</span>, y <span class=filename>/dev/gvinum/sd</span>, los cuales contienen nodos de dispositivo para cada plex y para cada subdisco, respectivamente.</p></li></ul></div><div class=paragraph><p>Por ejemplo, considera el siguiente fichero de configuración:</p></div><div class="literalblock programlisting"><div class=content><pre>	drive drive1 device /dev/sd1h
	drive drive2 device /dev/sd2h
	drive drive3 device /dev/sd3h
	drive drive4 device /dev/sd4h
    volume s64 setupstate
      plex org striped 64k
        sd length 100m drive drive1
        sd length 100m drive drive2
        sd length 100m drive drive3
        sd length 100m drive drive4</pre></div></div><div class=paragraph><p>Después de procesar este fichero, <a href="https://man.freebsd.org/cgi/man.cgi?query=gvinum&amp;sektion=8&amp;format=html">gvinum(8)</a> crea la siguiente estructura en <span class=filename>/dev/gvinum</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>	drwxr-xr-x  2 root  wheel       512 Apr 13
16:46 plex
	crwxr-xr--  1 root  wheel   91,   2 Apr 13 16:46 s64
	drwxr-xr-x  2 root  wheel       512 Apr 13 16:46 sd

    /dev/vinum/plex:
    total 0
    crwxr-xr--  1 root  wheel   25, 0x10000002 Apr 13 16:46 s64.p0

    /dev/vinum/sd:
    total 0
    crwxr-xr--  1 root  wheel   91, 0x20000002 Apr 13 16:46 s64.p0.s0
    crwxr-xr--  1 root  wheel   91, 0x20100002 Apr 13 16:46 s64.p0.s1
    crwxr-xr--  1 root  wheel   91, 0x20200002 Apr 13 16:46 s64.p0.s2
    crwxr-xr--  1 root  wheel   91, 0x20300002 Apr 13 16:46 s64.p0.s3</pre></div></div><div class=paragraph><p>Aunque se recomienda que los plexes y subdiscos no tengan asignados nombres específicos, las unidades de <span class=filename>vinum</span> deben tener nombre. Esto hace posible mover una unidad a una localización diferente y que sea reconocida automáticamente. Los nombres de unidad pueden tener una longitud de hasta 32 caracteres.</p></div><div class=sect2><h3 id=_creando_sistemas_de_ficheros>6.1. Creando Sistemas de Ficheros<a class=anchor href=#_creando_sistemas_de_ficheros></a></h3><div class=paragraph><p>En el sistema los volúmenes parecen idénticos a los discos, con una excepción. A diferencia de las unidades UNIX®, <span class=filename>vinum</span> no particiona los volúmenes, por lo que estos no tienen tabla de particiones. Esto ha requerido modificaciones en algunas utilidades de disco, notablemente de <a href="https://man.freebsd.org/cgi/man.cgi?query=newfs&amp;sektion=8&amp;format=html">newfs(8)</a>, de forma que no intente interpretar la última letra de un nombre de volumen <span class=filename>vinum</span>. Por ejemplo, una unidad de disco podría tener un nombre como /dev/ad0a# o /dev/da2h#. Estos nombres representan la primera partición (<span class=filename>a</span>) en el primer (0) disco IDE (<span class=filename>ad</span>) y la octava partición (<span class=filename>h</span>) en el tercer (2) disco SCSI (<span class=filename>da</span>) respectivamente. Por el contrario, un volumen <span class=filename>vinum</span> podría llamarse /dev/gvinum/concat#, que no guarda relación con un nombre de partición.</p></div><div class=paragraph><p>Para crear un sistema de ficheros en este volumen, usa <a href="https://man.freebsd.org/cgi/man.cgi?query=newfs&amp;sektion=8&amp;format=html">newfs(8)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># newfs /dev/gvinum/concat</span></code></pre></div></div></div></div></div><div class=sect1><h2 id=vinum-config>7. Configurando <span class=filename>vinum</span><a class=anchor href=#vinum-config></a></h2><div class=sectionbody><div class=paragraph><p>El kernel <span class=filename>GENERIC</span> no contiene <span class=filename>vinum</span>. Es posible construir un kernel a medida que incluya <span class=filename>vinum</span>, pero no se recomienda. La forma estándar de arrancar <span class=filename>vinum</span> es como un módulo del kernel. <a href="https://man.freebsd.org/cgi/man.cgi?query=kldload&amp;sektion=8&amp;format=html">kldload(8)</a> no es necesario porque cuando <a href="https://man.freebsd.org/cgi/man.cgi?query=gvinum&amp;sektion=8&amp;format=html">gvinum(8)</a> arranca, comprueba si el módulo ha sido cargado, y si no es así, lo carga automáticamente.</p></div><div class=sect2><h3 id=_arranque>7.1. Arranque<a class=anchor href=#_arranque></a></h3><div class=paragraph><p><span class=filename>vinum</span> almacena información de configuración en las porciones de disco de forma esencialmente igual a como guarda los ficheros de configuración. Cuando lee de la base de datos de configuración, <span class=filename>vinum</span> reconoce un número de palabras clave que no están permitidas en los ficheros de configuración. Por ejemplo, una configuración de disco podría contener el siguiente texto:</p></div><div class="literalblock programlisting"><div class=content><pre>volume myvol state up
volume bigraid state down
plex name myvol.p0 state up org concat vol myvol
plex name myvol.p1 state up org concat vol myvol
plex name myvol.p2 state init org striped 512b vol myvol
plex name bigraid.p0 state initializing org raid5 512b vol bigraid
sd name myvol.p0.s0 drive a plex myvol.p0 state up len 1048576b driveoffset 265b plexoffset 0b
sd name myvol.p0.s1 drive b plex myvol.p0 state up len 1048576b driveoffset 265b plexoffset 1048576b
sd name myvol.p1.s0 drive c plex myvol.p1 state up len 1048576b driveoffset 265b plexoffset 0b
sd name myvol.p1.s1 drive d plex myvol.p1 state up len 1048576b driveoffset 265b plexoffset 1048576b
sd name myvol.p2.s0 drive a plex myvol.p2 state init len 524288b driveoffset 1048841b plexoffset 0b
sd name myvol.p2.s1 drive b plex myvol.p2 state init len 524288b driveoffset 1048841b plexoffset 524288b
sd name myvol.p2.s2 drive c plex myvol.p2 state init len 524288b driveoffset 1048841b plexoffset 1048576b
sd name myvol.p2.s3 drive d plex myvol.p2 state init len 524288b driveoffset 1048841b plexoffset 1572864b
sd name bigraid.p0.s0 drive a plex bigraid.p0 state initializing len 4194304b driveoff set 1573129b plexoffset 0b
sd name bigraid.p0.s1 drive b plex bigraid.p0 state initializing len 4194304b driveoff set 1573129b plexoffset 4194304b
sd name bigraid.p0.s2 drive c plex bigraid.p0 state initializing len 4194304b driveoff set 1573129b plexoffset 8388608b
sd name bigraid.p0.s3 drive d plex bigraid.p0 state initializing len 4194304b driveoff set 1573129b plexoffset 12582912b
sd name bigraid.p0.s4 drive e plex bigraid.p0 state initializing len 4194304b driveoff set 1573129b plexoffset 16777216b</pre></div></div><div class=paragraph><p>Aquí las diferencias obvias son la presencia de información explícita de localización y nombrado, ambas permitidas pero no recomendadas, y la información de los estados. <span class=filename>vinum</span> no almacena información sobre las unidades en la información de configuración. Encuentra las unidades escaneando las unidades de disco configuradas en busca de particiones con una etiqueta <span class=filename>vinum</span>. Esto posibilita que <span class=filename>vinum</span> identifique las unidades correctamente incluso si se les han asignado identificadores de unidad UNIX® diferentes.</p></div><div class=sect3><h4 id=vinum-rc-startup>7.1.1. Arranque Automático<a class=anchor href=#vinum-rc-startup></a></h4><div class=paragraph><p><em>Gvinum</em> siempre realiza un arranque automático una vez que el módulo del kernel ha sido cargado, via <a href="https://man.freebsd.org/cgi/man.cgi?query=loader.conf&amp;sektion=5&amp;format=html">loader.conf(5)</a>. Para cargar el módulo de <em>Gvinum</em> en el arranque, añade <code>geom_vinum_load="YES"</code> a <span class=filename>/boot/loader.conf</span>.</p></div><div class=paragraph><p>Cuando <span class=filename>vinum</span> es arrancado con <code>gvinum start</code>, <span class=filename>vinum</span> lee la base de datos de configuración de una de las unidades <span class=filename>vinum</span>. En condiciones normales, cada unidad contiene una copia idéntica de la base de datos de configuración, de forma que no importa de qué unidad se lea. Después de una caída, sin embargo, <span class=filename>vinum</span> debe determinar qué unidad fue actualizada más recientemente y leer la configuración de esta unidad. Después actualiza la configuración progresivamente, si es necesario, de unidades más antiguas.</p></div></div></div></div></div><div class=sect1><h2 id=vinum-root>8. Usando <span class=filename>vinum</span> para el Sistema de Ficheros Raíz<a class=anchor href=#vinum-root></a></h2><div class=sectionbody><div class=paragraph><p>Para una máquina que tiene sistemas de ficheros completamente en espejo usando <span class=filename>vinum</span>, es deseable también configurar en espejo el sistema de ficheros raíz. Establecer dicha configuración es menos trivial que configurar en espejo un sistema de ficheros arbitrario porque:</p></div><div class=ulist><ul><li><p>El sistema de ficheros raíz debe estar disponible muy temprano durante el proceso de arranque, por lo que la infraestructura <span class=filename>vinum</span> debe estar disponible en ese momento.</p></li><li><p>El volumen que contiene el sistema de ficheros raíz, también contiene el sistema de arranque y el kernel. Estos deben ser leídos usando las utilidades nativas del sistema hospedador, como la BIOS, que frecuentemente no puede ser informada de los detalles de <span class=filename>vinum</span>.</p></li></ul></div><div class=paragraph><p>En las secciones siguientes, el término "volumen raíz" se utiliza para describir el volumen <span class=filename>vinum</span> que contiene el sistema de ficheros raíz.</p></div><div class=sect2><h3 id=_arrancando_vinum_suficientemente_pronto_para_el_sistema_de_ficheros_raíz>8.1. Arrancando <span class=filename>vinum</span> Suficientemente Pronto para el Sistema de Ficheros Raíz<a class=anchor href=#_arrancando_vinum_suficientemente_pronto_para_el_sistema_de_ficheros_raíz></a></h3><div class=paragraph><p><span class=filename>vinum</span> debe estar disponible pronto en el arranque del sistema puesto que <a href="https://man.freebsd.org/cgi/man.cgi?query=loader&amp;sektion=8&amp;format=html">loader(8)</a> debe ser capaz de cargar el módulo del kernel de vinum antes de arrancar el kernel. Esto se puede conseguir poniendo la siguiente línea en <span class=filename>/boot/loader.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>geom_vinum_load=&#34;YES&#34;</pre></div></div></div><div class=sect2><h3 id=_haciendo_accesible_un_volumen_raíz_basado_en_vinum_en_el_código_de_arranque>8.2. Haciendo Accesible un Volumen Raíz basado en <span class=filename>vinum</span> en el Código de Arranque<a class=anchor href=#_haciendo_accesible_un_volumen_raíz_basado_en_vinum_en_el_código_de_arranque></a></h3><div class=paragraph><p>El código de arranque de FreeBSD ocupa sólo 7.5 KB y no entiende las estructuras internas de <span class=filename>vinum</span>. Esto significa que no puede parsear los datos de configuración de <span class=filename>vinum</span> o resolver los elementos de un volumen de arranque. Por lo tanto, se necesitan algunas soluciones alternativas para proporcionar al código de arranque con el espejismo de una partición estándar <code>a</code> que contiene el sistema de ficheros raíz.</p></div><div class=paragraph><p>Para que esto sea posible, el volumen raíz debe cumplir los siguientes requisitos:</p></div><div class=ulist><ul><li><p>El volumen raíz no debe ser un segmento o <code>RAID</code>-5.</p></li><li><p>El volumen raíz no debe contener más de un subdisco concatenado por plex.</p></li></ul></div><div class=paragraph><p>Ten en cuenta que es deseable y posible utilizar múltiples plexes, cada uno conteniendo una réplica del sistema de ficheros raíz. El proceso de arranque sólo utilizará una réplica para encontrar el sistema de arranca y todos los ficheros de arranque, hasta que el kernel monta el sistema de ficheros raíz. Cada subdisco en estos plexes necesita su propio espejismo de partición <code>a</code>, para que el dispositivo respectivo sea arrancable. No es estrictamente necesario que cada una de estas particiones <code>a</code> simuladas estén localizadas en el mismo desplazamiento en el dispositivo, comparado con otros dispositivos que contienen plexes del volumen raíz. Sin embargo, probablemente sea buena idea crear volúmenes <span class=filename>vinum</span> de ese modo de forma que los dispositivos en espejo sean simétricos, para evitar confusión.</p></div><div class=paragraph><p>Para establecer estas particiones <code>a</code> para cada dispositivo que contiene una parte del volumen raíz, se necesite lo siguiente:</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>La localización, desplazamiento desde el principio del dispositivo, y el tamaño del subdisco del dispositivo que forma parte del volumen raíz necesita ser examinado, usando el siguiente comando:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gvinum l -rv root</span></code></pre></div></div><div class=paragraph><p>Los desplazamientos y tamaños en <span class=filename>vinum</span> se miden en bytes. Estos deben ser divididos entre 512 para obtener los números de bloque que van a ser usados por <code>bsdlabel</code>.</p></div></li><li><p>Ejecuta este comando para cada dispositivo que participa en el volumen raíz:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># bsdlabel -e devname</span></code></pre></div></div><div class=paragraph><p><em>devname</em> debe ser o el nombre del disco, como <span class=filename>da0</span> para discos sin una tabla de rebanadas, or el nombre de la rebanada, como <span class=filename>ad0s1</span>.</p></div><div class=paragraph><p>Si ya hay en el dispositivo una partición <code>a</code> de un sistema raíz pre-<span class=filename>vinum</span>>vinum#>, se debería renombrar a algo diferente de forma que se mantenga accesible (por si acaso), pero ya no será utilizado como arranque por defecto del sistema. Un sistema de ficheros raíz que está actualmente montado no puede ser renombrado, así que esto se debe ejecutar arrancando desde un medio "Fixit", o en un proceso de dos pasos donde, en una configuración en espejo, el disco que no está siendo arrancando es manipulado primero.</p></div><div class=paragraph><p>El desplazamiento de la partición <span class=filename>vinum</span> en este dispositivo (si lo hay) se debe añadir al desplazamiento del subdisco del volumen raíz respectivo en este dispositivo.El valor resultante será el valor del <code>offset</code> para la nueva partición <code>a</code>. El valor de <code>size</code> para esta partición se tomará de forma literal del cálculo anterior. El <code>fstype</code> debería ser <code>4.2BSD</code>. Los valores <code>fsize</code>, <code>bsize</code>, y <code>cpg</code> deberían ser escogidos para que coincidan con el sistema de ficheros real, aunque no son realmente importantes en este contexto.</p></div><div class=paragraph><p>De ese modo, se establecerá una nueva partición <code>a</code> que solapa la partición <span class=filename>vinum</span> en este dispositivo.<code>bsdlabel</code> solo permitirá este solapamiento si la partición <span class=filename>vinum</span> ha sido adecuadamente marcada utilizando el fstype <code>vinum</code>.</p></div></li><li><p>Ahora existe una falsa partición <code>a</code> en cada dispositivo que tiene una réplica del volumen raíz. Es altamente recomendable verificar el resultado usando un comando como:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># fsck -n /dev/devnamea</span></code></pre></div></div></li></ol></div></div></div><div class=paragraph><p>Debería recordarse que todos los ficheros que contienen información de control deben ser relativos al sistema de ficheros raíz en el volumen <span class=filename>vinum</span> que, cuando se establece un nuevo volumen raíz <span class=filename>vinum</span>, podría no coincidir con el sistema de ficheros raíz que está actualmente activo. Así que en concreto, hay que tener cuidado con <span class=filename>/etc/fstab</span> y <span class=filename>/boot/loader.conf</span>.</p></div><div class=paragraph><p>En el siguiente reinicio, el código de arranque debería averiguar la información de control apropiada en el nuevo sistema de ficheros raíz <span class=filename>vinum</span>, y actuar en consecuencia. Al final del proceso de inicialización del kernel, después de que todos los dispositivos han sido anunciados, el aviso destacado que muestra el éxito de esta configuración es un mensaje como este:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Mounting root from ufs:/dev/gvinum/root</code></pre></div></div></div><div class=sect2><h3 id=_ejemplo_de_una_configuración_raíz_basada_en_vinum>8.3. Ejemplo de una Configuración Raíz basada en <span class=filename>vinum</span><a class=anchor href=#_ejemplo_de_una_configuración_raíz_basada_en_vinum></a></h3><div class=paragraph><p>Después de que el volumen raíz <span class=filename>vinum</span> ha sido configurado, la salida de <code>gvinum l -rv root</code> podría ser como:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>...
Subdisk root.p0.s0:
		Size:        125829120 bytes <span class=o>(</span>120 MB<span class=o>)</span>
		State: up
		Plex root.p0 at offset 0 <span class=o>(</span>0  B<span class=o>)</span>
		Drive disk0 <span class=o>(</span>/dev/da0h<span class=o>)</span> at offset 135680 <span class=o>(</span>132 kB<span class=o>)</span>

Subdisk root.p1.s0:
		Size:        125829120 bytes <span class=o>(</span>120 MB<span class=o>)</span>
		State: up
		Plex root.p1 at offset 0 <span class=o>(</span>0  B<span class=o>)</span>
		Drive disk1 <span class=o>(</span>/dev/da1h<span class=o>)</span> at offset 135680 <span class=o>(</span>132 kB<span class=o>)</span></code></pre></div></div><div class=paragraph><p>Los valores en los que fijarse son <code>135680</code> para el offset, en relación a la partición /dev/da0h#. Esto se traduce en 256 bloques de disco de 512 bytes en términos de <code>bsdlabel</code>. De igual modo, el tamaño de este volumen raíz es 245760 bloques de 512 bytes. /dev/da1h#, al contener la segunda réplica de este volumen raíz, tiene una configuración asimétrica.</p></div><div class=paragraph><p>El bsdlabel para estos dispositivos podría parecerse a:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>...
8 partitions:
<span class=c>#        size   offset    fstype   [fsize bsize bps/cpg]</span>
  a:   245760      281    4.2BSD     2048 16384     0  <span class=c># (Cyl.    0*- 15*)</span>
  c: 71771688        0    unused        0     0        <span class=c># (Cyl.    0 - 4467*)</span>
  h: 71771672       16     vinum                       <span class=c># (Cyl.    0*- 4467*)</span></code></pre></div></div><div class=paragraph><p>Se puede observar que el parámetro <code>size</code> para la partición falsa <code>a</code> coincide con el valor esbozado arriba, mientras que el parámetro <code>offset</code> es la suma del desplazamiento dentro de la partición <span class=filename>vinum</span> <code>h</code>, y el desplazamiento de esta partición dentro del dispositivo o rebanada. Esta es una configuración típica que es necesaria para evitar el problema descrito en <a href=#vinum-root-panic>Nada Arranca, el Arranque entra en Pánico</a>. La partición <code>a</code> entera está completamente dentro de la partición <code>h</code> que contiene todos los datos <span class=filename>vinum</span> para este dispositivo.</p></div><div class=paragraph><p>En el ejemplo de arriba, el dispositivo entero está dedicado a <span class=filename>vinum</span> y no hay una partición raíz pre-<span class=filename>vinum</span> restante.</p></div></div><div class=sect2><h3 id=_solución_de_problemas>8.4. Solución de problemas<a class=anchor href=#_solución_de_problemas></a></h3><div class=paragraph><p>La siguiente lista contiene unos pocos problemas conocidos y sus soluciones.</p></div><div class=sect3><h4 id=_el_sistema_de_arranque_carga_pero_el_sistema_no_arranca>8.4.1. El Sistema de Arranque Carga, pero el Sistema No Arranca<a class=anchor href=#_el_sistema_de_arranque_carga_pero_el_sistema_no_arranca></a></h4><div class=paragraph><p>Si por algún motivo el sistema con continúa con el arranque, el proceso de arranque se puede interrumpir presionando <kbd>espacio</kbd> durante el aviso de 10 segundos. La variable del cargador <code>vinum.autostart</code> puede examinarse tecleando <code>show</code> y manipularse usando <code>set</code> o <code>unset</code>.</p></div><div class=paragraph><p>Si el módulo del kernel de <span class=filename>vinum</span> no estaba en la lista de módulos que son cargados automáticamente, teclea <code>load geom_vinum</code>.</p></div><div class=paragraph><p>Cuando está listo, el proceso de arranque puede continuar tecleando <code>boot -as</code> cuyo parámetro <code>-as</code> solicita al kernel que pregunte por el sistema de ficheros raíz a montar (<code>-a</code>) y hacer que el proceso de arranque pare en modo de usuario único (<code>-s</code>), donde el sistema de ficheros raíz está montado como solo lectura. De ese modo, incluso si sólo ha sido montado un plex de un volumen multi-plex, no hay riesgo de inconsistencia de datos entre plexes.</p></div><div class=paragraph><p>En el prompt en el que se pregunta por el sistema de ficheros raíz a montar, se puede introducir cualquier dispositivo que contiene un sistema de ficheros raíz válido. Si <span class=filename>/etc/fstab</span> está configurado correctamente, el valor por defecto debería ser algo como <code>ufs:/dev/gvinum/root</code>. Una opción alternativa típica sería algo como <code>ufs:da0d</code> que podría contener una hipotética partición de un sistema de ficheros raíz pre-<span class=filename>vinum</span>. Ha que tener cuidado si se introduce uno de los alias de las particiones <code>a</code>, que en realidad referencia los subdiscos del dispositivo raíz <span class=filename>vinum</span>, porque en una configuración en espejo, esto sólo montaría un trozo del dispositivo raíz en espejo. Si este sistema de ficheros se va a montar como lectura-escritura posteriormente, es necesario eliminar el otro plex(es) del volumen raíz <span class=filename>vinum</span> puesto que de otro modo los plexes tendrían datos inconsistentes.</p></div></div><div class=sect3><h4 id=_sólo_arranca_la_configuración_de_arranque_primaria>8.4.2. Sólo Arranca la Configuración de Arranque Primaria<a class=anchor href=#_sólo_arranca_la_configuración_de_arranque_primaria></a></h4><div class=paragraph><p>Si <span class=filename>/boot/loader</span> falla al cargar, pero la configuración de arranque primaria todavía carga (visible mediante un sólo guión en la columna de la izquierda de la pantalla justo después de que comience el proceso de arranque), se puede intentar interrumpir el arranque primario presionando <kbd>espacio</kbd>. Esto hará que el proceso de arranque se pare en <a href=https://docs.freebsd.org/es/books/handbook/#boot-boot1>stage two</a>. Aquí se puede intentar arrancar desde una partición alternativa, como la partición que contiene sl sistema de ficheros raíz anterior que ha sido movido desde <code>a</code>.</p></div></div><div class=sect3><h4 id=vinum-root-panic>8.4.3. Nada Arranca, el Proceso de Arranque entra en Pánico<a class=anchor href=#vinum-root-panic></a></h4><div class=paragraph><p>Esta situación ocurrirá si el código de arranque ha sido destruido por la instalación de <span class=filename>vinum</span>. Desafortunadamente, <span class=filename>vinum</span> deja por accidente sólo 4KB libres al comienzo de su partición antes de empezar a escribir la información de cabecera de <span class=filename>vinum</span>. Sin embargo, los códigos de arranque de las fases uno y dos más bsdlabel requieren 8 KB. Así que si una partición <span class=filename>vinum</span> empezó en un offset 0 dentro de una rebanada o disco que se pretendía que fuera arrancable, la configuración de <span class=filename>vinum</span> se llevará por delante el código de arranque.</p></div><div class=paragraph><p>De forma similar, si se ha recuperado de la situación anterior, arrancando desde un medio "Fixit", y el código de arranque ha sido reinstalado utilizando <code>bsdlabel -B</code> como se describe en <a href=https://docs.freebsd.org/es/books/handbook/#boot-boot1>stage two</a>, el código de arranque destruirá la cabecera <span class=filename>vinum</span>, y <span class=filename>vinum</span> ya no podrá encontrar su(s) disco(s). Aunque ningún volumen <span class=filename>vinum</span> o datos de configuración de <span class=filename>vinum</span> serán destruidos, y sería posible recuperar todos los datos introduciendo de nuevo exactamente los mismos datos de configuración de <span class=filename>vinum</span> la situación es difícil de arreglar. Es necesario mover la partición <span class=filename>vinum</span> entera al menos 4 KB, para que la cabecera <span class=filename>vinum</span> y el código de arranque del sistema ya no colisionen.</p></div></div></div></div></div><hr><div class=last-modified><p><strong>Last modified on</strong>: 19 de julio de 2022 by <a href="https://cgit.freebsd.org/doc/commit/?id=83c9b18753" target=_blank>Fernando Apesteguía</a></p></div></div><aside class=toc><div class=toc-content><h3>Tabla de contenidos</h3><nav id=TableOfContents><ul><li><a href=#vinum-synopsis>1. Sinopsis</a></li><li><a href=#vinum-access-bottlenecks>2. Cuellos de botella de acceso</a></li><li><a href=#vinum-data-integrity>3. Integridad de los Datos</a></li><li><a href=#vinum-objects>4. Objetos <span class=filename>vinum</span></a></li><li><a href=#vinum-examples>5. Algunos Ejemplos</a></li><li><a href=#vinum-object-naming>6. Nombrado de Objetos</a></li><li><a href=#vinum-config>7. Configurando <span class=filename>vinum</span></a></li><li><a href=#vinum-root>8. Usando <span class=filename>vinum</span> para el Sistema de Ficheros Raíz</a></li></ul></nav><hr><div class=resources><h3>Recursos</h3><ul class=contents><li><i class="fa fa-file-pdf-o" aria-hidden=true title="Descargar PDF"></i><a href=https://download.freebsd.org/doc/es/articles/vinum/vinum_es.pdf>Descargar PDF</a></li><li><i class="fa fa-pencil-square-o" aria-hidden=true title="Editar esta página"></i><a href=https://github.com/freebsd/freebsd-doc/blob/main/documentation/content/es/_index target=_blank>Editar esta página</a></li></ul></div></div></aside></main><footer><div class=footer-container><section class=logo-column><img src=https://docs.freebsd.org/images/FreeBSD-colors.svg width=160 height=50 alt="FreeBSD logo"><div class=options-container><div class=language-container><a id=languages href=https://docs.freebsd.org/es/languages><img src=https://docs.freebsd.org/images/language.png class=language-image alt="Elegir idioma">
<span>Spanish</span></a></div><div class=theme-container><select id=theme-chooser><option value=theme-system>System</option><option value=theme-light>Claro</option><option value=theme-dark>Oscuro</option><option value=theme-high-contrast>Alto contraste</option></select></div></div></section><section class=about-column><h3 class=column-title>About</h3><ul class=column-elements-container><li><a href=https://www.freebsd.org/about/ target=_blank class=column-element>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/ target=_blank class=column-element>FreeBSD Foundation</a></li><li><a href=https://www.freebsd.org/where/ target=_blank class=column-element>Get FreeBSD</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct target=_blank class=column-element>Code of Conduct</a></li><li><a href=https://www.freebsd.org/security/ target=_blank class=column-element>Security Advisories</a></li></ul></section><section class=documentation-column><h3 class=column-title>Documentation</h3><ul class=column-elements-container><li><a href=/es class=column-element>Documentation portal</a></li><li><a href=https://man.FreeBSD.org target=_blank class=column-element>Manual pages</a></li><li><a href=https://papers.FreeBSD.org target=_blank class=column-element>Presentations and papers</a></li><li><a href=https://docs-archive.freebsd.org/doc/ target=_blank class=column-element>Previous versions</a></li><li><a href=https://docs-archive.freebsd.org/44doc/ target=_blank class=column-element>4.4BSD Documents</a></li><li><a href=https://wiki.freebsd.org/ target=_blank class=column-element>Wiki</a></li></ul></section><section class=community-column><h3 class=column-title>Community</h3><ul class=column-elements-container><li><a href=https://docs.freebsd.org/es/articles/contributing class=column-element>Get involved</a></li><li><a href=https://forums.freebsd.org/ target=_blank class=column-element>Community forum</a></li><li><a href=https://lists.freebsd.org/ target=_blank class=column-element>Mailing lists</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank class=column-element>IRC Channels</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank class=column-element>Bug Tracker</a></li></ul></section><section class=legal-column><h3 class=column-title>Legal</h3><ul class=column-elements-container><li><a href=https://freebsdfoundation.org/donate/ target=_blank class=column-element>Donations</a></li><li><a href=https://www.freebsd.org/copyright/freebsd-license/ target=_blank class=column-element>Licensing</a></li><li><a href=https://www.freebsd.org/privacy/ target=_blank class=column-element>Privacy Policy</a></li><li><a href=https://www.freebsd.org/copyright/ target=_blank class=column-element>Legal notices</a></li></ul></section><section class=copyright-column><p>&copy; 1994-2024 The FreeBSD Project. All rights reserved</p><span>Made with <span class=heart>♥</span> by the FreeBSD Community</span></section></div></footer></body></html>