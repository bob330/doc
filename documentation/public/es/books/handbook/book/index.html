<!doctype html><html class=theme-light lang=es><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content><meta name=keywords content><meta name=copyright content="1995-2024 The FreeBSD Foundation"><link rel=canonical href=http://172.16.201.134:1313/es/books/handbook/book/><title>Manual de FreeBSD | Portal de documentación de FreeBSD</title>
<meta name=theme-color content="#790000"><meta name=color-scheme content="system light dark high-contrast"><link rel="shortcut icon" href=http://172.16.201.134:1313/favicon.ico><link rel=stylesheet href=http://172.16.201.134:1313/styles/main.min.css><link rel=stylesheet href=http://172.16.201.134:1313/css/font-awesome-min.css><script defer src=/js/theme-chooser.min.js></script><script defer src=/js/copy-clipboard.min.js></script><script defer src=/js/search.min.js></script><meta name=twitter:card content="summary"><meta name=twitter:domain content="docs.FreeBSD.org"><meta name=twitter:site content="@freebsd"><meta name=twitter:url content="https://twitter.com/freebsd"><meta property="og:title" content="Manual de FreeBSD"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:image" content="http://172.16.201.134:1313/favicon.ico"><meta property="og:image:alt" content="FreeBSD Logo"><meta property="og:locale" content="es"><meta property="og:url" content="http://172.16.201.134:1313/es/books/handbook/book/"><meta property="og:site_name" content="Portal de documentación de FreeBSD"><script type=application/ld+json>{"@context":"http://schema.org","@type":"Article","url":"http:\/\/172.16.201.134:1313\/es\/books\/handbook\/book\/","name":"Portal de documentación de FreeBSD","headline":"Portal de documentación de FreeBSD","description":"FreeBSD Documentation Portal"}</script></head><body><header><div class=header-container><div class=logo-menu-bars-container><a href=https://www.FreeBSD.org class=logo><img src=http://172.16.201.134:1313/images/FreeBSD-monochromatic.svg width=160 height=50 alt="FreeBSD logo">
</a><label class=menu-bars for=menu-bars><i class="fa fa-bars" aria-hidden=true></i></label></div><input id=menu-bars type=checkbox><nav><ul class=menu><li class=menu-item><input id=about type=checkbox>
<a href=# aria-label="Navigate to About section"><label class=menu-item-description for=about>About
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/about/ target=_blank>About</a></li><li><a href=https://www.freebsd.org/about/ target=_blank>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/about-us/about-the-foundation/ target=_blank>FreeBSD Foundation</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct/ target=_blank>Code of Conduct</a></li></ul></li><li class=menu-item><input id=download type=checkbox>
<a href=# aria-label="Navigate to get FreeBSD section"><label class=menu-item-description for=download>Get FreeBSD
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/where/ target=_blank>Get FreeBSD</a></li><li><a href=https://www.freebsd.org/releases/ target=_blank>Release Information</a></li><li><a href=https://www.freebsd.org/releng/ target=_blank>Release Engineering</a></li><li><a href=https://www.freebsd.org/security/ target=_blank>Security Advisories</a></li></ul></li><li class=menu-item><input id=documentation type=checkbox>
<a href=# aria-label="Navigate to get Documentation section"><label class=menu-item-description for=documentation>Documentation
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=/es>Documentation portal</a></li><li><a href=http://172.16.201.134:1313/es/books/handbook>FreeBSD Handbook</a></li><li><a href=http://172.16.201.134:1313/es/books/porters-handbook>Porter's Handbook</a></li><li><a href=https://docs.FreeBSD.org/en/books/fdp-primer>Documentation Project Handbook</a></li><li><a href=https://man.FreeBSD.org target=_blank>Manual pages</a></li><li><a href=https://papers.FreeBSD.org target=_blank>Presentations and papers</a></li><li><a href=https://wiki.FreeBSD.org target=_blank>Wiki</a></li><li><a href=http://172.16.201.134:1313/es/books>Books</a></li><li><a href=http://172.16.201.134:1313/es/articles>Articles</a></li></ul></li><li class=menu-item><input id=community type=checkbox>
<a href=# aria-label="Navigate to get Community section"><label class=menu-item-description for=community>Community
<i class="fa fa-angle-down fa-lg" aria-hidden=true></i></label></a><ul class=sub-menu><li class=title><a href=https://www.freebsd.org/community/>Community</a></li><li><a href=http://172.16.201.134:1313/es/articles/contributing>Get involved</a></li><li><a href=https://forums.freebsd.org/ target=_blank>Forum</a></li><li><a href=https://lists.freebsd.org/ target=_blank>Mailing lists</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank>IRC Channels</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank>Bug Tracker</a></li><li><a href=https://www.freebsd.org/support/ target=_blank>Support</a></li></ul></li></ul></nav><div class=search-donate-container><form class=search method=get id=search-header-form action=https://docs.freebsd.org/search name=search-header-form><input type=hidden name=DB value=es>
<input id=words name=P type=text size=20 maxlength=255>
<button>
<i class="fa fa-search" aria-hidden=true></i></button></form><div class=donate><a href=https://freebsdfoundation.org/donate/ target=_blank><span class=heart>♥</span>
Donate</a></div></div></div></header><input type=checkbox class="hidden toggle" id=menu-control><main class=main-wrapper-book><a id=top></a><div class=book><h1 class=title>Manual de FreeBSD</h1><div class="admonitionblock note"><p><i class="fa fa-exclamation-circle" aria-hidden=true></i>
This translation may be out of date. To help with the translations please access the <a href=https://translate-dev.freebsd.org/ target=_blank>FreeBSD translations instance</a>.</p></div><div class=copyright>Copyright © 1995-2020 Proyecto de Documentación de FreeBSD</div><div class=legalnotice><a id=trademarks></a><details><summary>Marcas registradas</summary><p>FreeBSD es una marca registrada de la Fundación FreeBSD</p><p>IBM, AIX, OS/2, PowerPC, PS/2, S/390, y ThinkPad son marcas registradas de International Business Machines Corporation en los Estados Unidos de América, otros países, o ambos.</p><p>IEEE, POSIX, y 802 son marcas registradas del Institute of Electrical and Electronics Engineers, Inc. en los Estados Unidos de América.</p><p>Red Hat, RPM, son marcas registradas de Red Hat, Inc. en los Estados Unidos de América y otros países.</p><p>3Com y HomeConnect son marcas registradas de 3Com Corporation.</p><p>Adobe, Acrobat, Acrobat Reader, Flash y PostScript son marcas registradas o marcas comerciales de Adobe Systems Incorporated en los Estados Unidos de América y/o otros países.</p><p>Apple, AirPort, FireWire, iMac, iPhone, iPad, Mac, Macintosh, Mac OS, Quicktime, y TrueType son marcas comerciales de Apple Inc., registradas en los Estados Unidos de América y otros países.</p><p>Intel, Celeron, Centrino, Core, EtherExpress, i386, i486, Itanium, Pentium, y Xeon son marcas registradas de ntel Corporation o sus subsidiarias en los Estados Unidos de América y otros países.</p><p>Linux es una marca registrada de Linus Torvalds.</p><p>Microsoft, IntelliMouse, MS-DOS, Outlook, Windows, Windows Media y Windows NT son marcas registradas o marcas comerciales de Microsoft Corporation en los Estados Unidos de América y/o otros países.</p><p>Motif, OSF/1, y UNIX son marcas registradas y IT DialTone y The Open Group son marcas comerciales de The Open Group en los Estados Unidos de América y otros países.</p><p>Sun, Sun Microsystems, Java, Java Virtual Machine, JDK, JRE, JSP, JVM, Netra, OpenJDK, Solaris, StarOffice, SunOS y VirtualBox son marcas comerciales o marcas registradas de Sun Microsystems, Inc. en los Estados Unidos de América y otros países.</p><p>RealNetworks, RealPlayer, and RealAudio son marcas registradas de RealNetworks, Inc.</p><p>Oracle es una marca registrada de Oracle Corporation.</p><p>3ware es una marca registrada de 3ware Inc.</p><p>ARM es una marca registrada de ARM Limited.</p><p>Adaptec es una marca registrada de Adaptec, Inc.</p><p>Heidelberg, Helvetica, Palatino, y Times Roman son marcas registradas o marcas comerciales de Heidelberger Druckmaschinen AG en los Estados Unidos de América y otros países.</p><p>Intuit y Quicken son marcas registradas y/o marcas registradas de servicios de Intuit Inc., o uno de sus subsidiarios, en los Estados Unidos de América y otros países.</p><p>LSI Logic, AcceleRAID, eXtremeRAID, MegaRAID y Mylex son marcas registradas o marcas comerciales de LSI Logic Corp.</p><p>MATLAB es una marca registrada de The MathWorks, Inc.</p><p>SpeedTouch es una marca comercial de Thomson.</p><p>VMware es una marca comercial de VMware, Inc.</p><p>Mathematica es una marca registrada de Wolfram Research, Inc.</p><p>Ogg Vorbis y Xiph.Org son marcas comerciales de Xiph.Org.</p><p>XFree86 es una marca comercial de The XFree86 Project, Inc.</p><p>Muchos de los nombres usados por los fabricantes y vendedores para diferenciar sus productos son designados como marcas comerciales. Allí donde estos nombres aparezcan en este documento y el Proyecto FreeBSD fuera consciente de la alegación de marca comercial, los nombres tienen a continuación el símbolo “™” o “®”.</p></details></div><div class=toc-mobile><h3>Tabla de contenidos</h3><nav id=TableOfContents><ul><li><a href=#book-preface>Prefacio</a><ul><li><a href=#preface-audience>A quién va dirigido este texto</a></li><li><a href=#preface-changes-from2>Cambios desde la segunda edición</a></li><li><a href=#preface-changes>Cambios desde la primera edición</a></li><li><a href=#preface-overview>Cómo se organiza este libro</a></li><li><a href=#preface-conv>Convenciones usadas en este libro</a></li><li><a href=#preface-acknowledgements>Agradecimientos</a></li></ul></li><li><a href=#getting-started>Parte I: Primeros pasos</a><ul><li><a href=#introduction>Capítulo 1. Introducción</a></li><li><a href=#bsdinstall>Capítulo 2. Instalación de FreeBSD</a></li><li><a href=#basics>Capítulo 3. Conceptos básicos de Unix</a></li><li><a href=#ports>Capítulo 4. Instalación de aplicaciones: packages y ports</a></li><li><a href=#x11>Capítulo 5. El sistema X Window</a></li></ul></li><li><a href=#common-tasks>Parte II: Tareas comunes</a><ul><li><a href=#desktop>Capítulo 6. Aplicaciones de escritorio</a></li><li><a href=#multimedia>Capítulo 7. Multimedia</a></li><li><a href=#kernelconfig>Capítulo 8. Configuración del kernel de FreeBSD</a></li><li><a href=#printing>Capítulo 9. Imprimir</a></li><li><a href=#linuxemu>Capítulo 10. Compatibilidad binaria con Linux</a></li></ul></li><li><a href=#system-administration>Parte III: Administración del sistema.</a><ul><li><a href=#config-tuning>Capítulo 11. Configuración y Adaptación del Sistema</a></li><li><a href=#boot>Capítulo 12. El proceso de arranque en FreeBSD</a></li><li><a href=#users>Capítulo 13. Usuarios y administración básica de cuentas</a></li><li><a href=#security>Capítulo 14. Seguridad</a></li><li><a href=#jails>Capítulo 15. Jaulas</a></li><li><a href=#mac>Capítulo 16. Mandatory Access Control</a></li><li><a href=#audit>Capítulo 17. Auditoría de eventos de seguridad</a></li><li><a href=#disks>Capítulo 18. Almacenamiento</a></li><li><a href=#geom>Capítulo 19. GEOM: Marco de trabajo modular de transformación de discos</a></li><li><a href=#vinum-vinum>Capítulo 20. El Gestor de Volúmenes Vinum</a></li><li><a href=#virtualization>Capítulo 21. Virtualización</a></li><li><a href=#l10n>Capítulo 22. Localización - Uso y configuración de I18N/L10N</a></li><li><a href=#updating-upgrading>Capítulo 23. Lo último de lo último</a></li></ul></li><li><a href=#network-communication>Parte IV: Comunicaciones en red</a><ul><li><a href=#serialcomms>Capítulo 24. Comunicaciones serie</a></li><li><a href=#ppp-and-slip>Capítulo 25. PPP y SLIP</a></li><li><a href=#mail>Capítulo 26. Electronic Mail</a></li><li><a href=#network-servers>Capítulo 27. Networking avanzado</a></li><li><a href=#firewalls>Capítulo 28. Cortafuegos</a></li><li><a href=#advanced-networking>Capítulo 29. Redes Avanzadas</a></li></ul></li><li><a href=#appendices>Parte V: Apéndices</a><ul><li><a href=#mirrors>Apéndice A: Cómo obtener FreeBSD</a></li><li><a href=#bibliography>Apéndice B: Bibliografía</a></li><li><a href=#eresources>Apéndice C: Recursos en Internet</a></li><li><a href=#pgpkeys>Apéndice D: PGP keys</a></li></ul></li></ul></nav></div><div class=book-content><div id=preamble><div class=sectionbody><div class="quoteblock abstract abstract-title"><blockquote>Resumen</blockquote></div><div class=paragraph><p>¡Bienvenido a FreeBSD! Este manual cubre la instalación y uso diario de <em>FreeBSD 12.1-RELEASE</em> and <em>FreeBSD 11.4-RELEASE</em>. Este manual está en <em>constante evolución</em> y es el resultado del trabajo de muchas personas. Algunas secciones no están completas y otras necesitan ser actualizadas. Si está interesado en colaborar en este proyecto envíe un mensaje de correo electrónico a <a href=https://lists.FreeBSD.org/subscription/freebsd-doc>Lista de correo del proyecto de documentación de FreeBSD</a>. La última versión de este documento está siempre disponible en el <a href=http://www.FreeBSD.org>sitio web de FreeBSD</a>. También puede encontrarla en diferentes formatos y opciones de compresión en el <a href=ftp://ftp.FreeBSD.org/pub/FreeBSD/doc/>servidor FTP de FreeBSD</a> o en las numerosas <a href=./#mirrors-ftp>réplicas</a>. Si prefiere una copia en papel de este manual puede comprarla en <a href=http://www.freebsdmall.com/>FreeBSD Mall</a>. También es posible <a href=https://www.FreeBSD.org/search/>hacer búsquedas</a> en este manual.</p></div><hr></div></div><div class=sect1><h2 id=book-preface>Prefacio<a class=anchor href=#book-preface></a></h2><div class=sectionbody><div class=sect2><h3 id=preface-audience>A quién va dirigido este texto<a class=anchor href=#preface-audience></a></h3><div class=paragraph><p>La primera sección de este libro está pensada para guiar a los recién llegados a FreeBSD durante el proceso de instalación y presentarles los conceptos y convenciones que dan entidad a UNIX®. Para sacar provecho de esta sección lo único que el lector necesitará son ganas de explorar y habilidad para ir interiorizando nuevos conceptos a medida que le van planteando.</p></div><div class=paragraph><p>La siguiente sección, la segunda, mucho más extensa, es una referencia completa de todo tipo de temas de interés para administradores de sistemas FreeBSD. Es posible que alguno de esos capítulos requiera que previamente lea otros textos; si es el caso esto se anuncia en la sinopsis situada al principio de cada capítulo.</p></div><div class=paragraph><p>Hay una lista de fuentes de información adicionales en el <a href=./#bibliography>Bibliografía</a>.</p></div></div><div class=sect2><h3 id=preface-changes-from2>Cambios desde la segunda edición<a class=anchor href=#preface-changes-from2></a></h3><div class=paragraph><p>Esta tercera edición es la culminación de más de dos años de trabajo de los miembros del FreeBSD Documentation Project. Estos son los cambios más importantes que encontrará en esta nueva edición:</p></div><div class=ulist><ul><li><p><a href=./#config-tuning>Configuración y Adaptación del Sistema</a>, configuración y adaptación del sistema, ha sido ampliado con nuevos datos sobre el sistema de gestión de energía y recursos ACPI, la utilidad del sistema <code>cron</code> y más opciones de personalización del kernel.</p></li><li><p><a href=./#security>Seguridad</a>, seguridad, ha sido ampliado con información sobre redes privadas virtuales (VPN), listas de control de accesos al sistema de ficheros (más conocidas por ACL) e información sobre avisos de seguridad.</p></li><li><p><a href=./#mac>Mandatory Access Control</a>, Mandatory Access Control (MAC), es un capítulo nuevo. En él se expone qué es MAC y de qué forma puede utilizarse en FreeBSD como complemento de la seguridad del sistema.</p></li><li><p><a href=./#disks>Almacenamiento</a>, almacenamiento, se ha ampliado con información sobre dispositivos USB de almacenamiento, instantáneas ("snapshots") de sistemas de ficheros, sistemas de ficheros basados en ficheros y en red, y particiones de disco cifradas.</p></li><li><p><a href=./#vinum>El Gestor de Volúmenes Vinum</a>, Vinum, es un capítulo nuevo. Describe el uso de Vinum, un gestor de volúmenes lógicos que permite disponer de discos lógicos independientes de dispositivo, así como de RAID-0, RAID-1 y RAID-5 por software.</p></li><li><p>Se ha añadido una sección de depuración de problemas al <a href=./#ppp-and-slip>PPP y SLIP</a>.</p></li><li><p><a href=./#mail>Correo electrónico</a>, correo electrónico, ha sido ampliado con información sobre el uso de MTA alternativos, autentificación SMTP, UUCP, fetchmail, procmail así como otros temas avanzados relacionados con el correo.</p></li><li><p><a href=./#network-servers>Servidores de red</a>, servidores de red, es un capítulo nuevo. En él se incluye información sobre la configuración de Apache HTTP Server, ftpd y cómo configurar Samba para su uso con clientes Microsoft® Windows®. Ciertas partes de <a href=./#advanced-networking>Networking avanzado</a>, se han trasladado a este capítulo para dar más solidez al contenido.</p></li><li><p><a href=./#advanced-networking>Networking avanzado</a>, incluye en esta edición nuevos datos sobre el uso de dispositivos Bluetooth® en FreeBSD, la configuración de redes "wireless" y el "networking" ATM (Asynchronous Transfer Mode).</p></li><li><p>Se ha creado un glosario para disponer de una ubicación centralizada donde encontrar definiciones de términos técnicos que se utilizan a lo largo del libro.</p></li><li><p>Las tablas e imágenes que aparecen en el libro han experimentado diversas mejoras estáticas.</p></li></ul></div></div><div class=sect2><h3 id=preface-changes>Cambios desde la primera edición<a class=anchor href=#preface-changes></a></h3><div class=paragraph><p>La segunda edición fue la culminación de más de dos años de trabajo de los miembros del FreeBSD Documentation Project. Estos son los principales cambios que encontrará en esta edición:</p></div><div class=ulist><ul><li><p>Se ha creado un índice completo.</p></li><li><p>Todos los esquemas ASCII han sido reemplazados por diagramas gráficos.</p></li><li><p>Se ha añadido una sinopsis estándar a cada capítulo donde se ofrece un breve sumario del contenido del capítulo y qué se espera que sepa el lector para poder sacarle provecho.</p></li><li><p>Se ha reorganizado de forma lógica el contenido en tres partes: "primeros pasos", "administración del sistema " y "apéndices".</p></li><li><p>La <a href=./#install>Instalación de FreeBSD</a> ("instalación de FreeBSD") ha sido reescrito completamente e incluye gran cantidad de capturas de pantalla para facilitar su comprensión a los nuevos usuarios.</p></li><li><p>Los <a href=./#basics>Conceptos básicos de Unix</a> ("conceptos básicos de UNIX®") se ha ampliado con más información sobre procesos, dæmons y señales.</p></li><li><p>El <a href=./#ports>Instalación de aplicaciones: «packages» y ports</a> ("instalación de aplicaciones") incluye información sobre la gestión de paquetes binarios.</p></li><li><p>El <a href=./#x11>El sistema X Window</a>, ("El sistema X Window") ha sido reescrito totalmente, con especial énfasis en el uso de modernas tecnologías de escritorio como KDE y GNOME en XFree86™ 4.X.</p></li><li><p>El <a href=./#boot>El proceso de arranque en FreeBSD</a> ("El proceso de arranque de FreeBSD") ha sido ampliado.</p></li><li><p>El <a href=./#disks>Almacenamiento</a> ("Almacenamiento") ha sido el fruto de refundir el contenido de lo eran dos capítulos sobre "discos" y "copias de seguridad". Pensamos que estos temas eran más fáciles de entender si se trataban en un mismo capítulo. Se ha añadido también una sección sobre RAID (tanto hardware como software).</p></li><li><p>El <a href=./#serialcomms>Comunicaciones serie</a> ("communicaciones serie") ha sido reorganizado y actualizado completamente con información sobre FreeBSD 4.X y 5.X.</p></li><li><p>El <a href=./#ppp-and-slip>PPP y SLIP</a> ("PPP y SLIP") ha sido actualizado en gran parte.</p></li><li><p>Se han añadido muchas secciones nuevas al <a href=./#advanced-networking>Networking avanzado</a> ("Networking avanzado").</p></li><li><p>El <a href=./#mail>Correo Electrónico</a> ("correo electrónico" incluye ahora más información sobre la configuración de sendmail.</p></li><li><p>El <a href=./#linuxemu>Compatibilidad binaria con Linux</a> ("compatibilidad conLinux®") se ha ampliado con información sobre la instalación de Oracle® y SAP® R/3®.</p></li><li><p>En esta segunda edición se incluyen también estos nuevos contenidos:</p><div class=ulist><ul><li><p>Configuración y adaptación del sistema (<a href=./#config-tuning>Configuración y Adaptación del Sistema</a>).</p></li><li><p>Multimedia (<a href=./#multimedia>Multimedia</a>)</p></li></ul></div></li></ul></div></div><div class=sect2><h3 id=preface-overview>Cómo se organiza este libro<a class=anchor href=#preface-overview></a></h3><div class=paragraph><p>Este libro se divide en cinco secciones lógicamente distintas. La primera, <em>primeros pasos</em>, trata sobre la instalación y el uso más básico de FreeBSD. Está pensada para que el lector los recorra en secuencialmente, aunque puede saltarse algunos si tratan sobre temas que le resulten familiares. La segunda sección, <em>Tareas comunes</em>, está dedicada a las características de FreeBSD que suelen utilizarse con más frecuencia. Esta sección, así como las siguientes, pueden leerse en cualquier orden. Cada capítulo comienza con una sinopsis sucinta en la que se describe el contenido del capítulo y qué es lo que se espera que sepa el lector antes de leerlo. Esto se hace para dar ocasión al lector ocasional a que elija el capítulo que más pueda interesarle. La tercera sección, <em>Administración del sistema</em>, trata sobre diversos aspectos de la administración del sistema. La cuarta sección, <em>Redes y comunicaciones</em>, está dedicada al "networking" y temas relacionados con los servidores. La quinta sección dispone de apéndices con información de referencia.</p></div><div class=dlist><dl><dt class=hdlist1><em><a href=./#introduction>Introducción</a></em></dt><dd><p>Este capítulo, como su nombre indica, presenta FreeBSD al usuario. En él se cuenta la historia del Proyecto FreeBSD, sus objetivos y su modelo de desarrollo.</p></dd><dt class=hdlist1><em><a href=./#install>Instalación de FreeBSD</a></em></dt><dd><p>Guía al usuario a través de un proceso completo de instalación. Se explican también algunos aspectos avanzados como la instalación a través de una consola serie.</p></dd><dt class=hdlist1><em><a href=./#basics>Conceptos básicos de Unix</a></em></dt><dd><p>Se explican los comandos más básicos y el funcionamiento del sistema operativo FreeBSD. Si ya se tiene experiencia con Linux® u otro tipo de UNIX® posiblemente sea este un capítulo que no deba leerse.</p></dd><dt class=hdlist1><em><a href=./#ports>Instalación de aplicaciones: «packages» y ports</a></em></dt><dd><p>Se explica la instalación de software desarrollado por personas ajenas al proyecto, tanto mediante la innovadora "Colección de Ports" de FreeBSD como mediante paquetes binarios estándar ("packages").</p></dd><dt class=hdlist1><em><a href=./#x11>El sistema X Window</a></em></dt><dd><p>Describe el sistema X Windows en general y su uso en FreeBSD en particular. Describe también entornos de escritorio de uso común como KDE y GNOME.</p></dd><dt class=hdlist1><em><a href=./#desktop>Aplicaciones de escritorio</a></em></dt><dd><p>Se enumeran algunas aplicaciones de escritorio muy comunes, como navegadores web y suites ofimáticas, y cómo instalar estas aplicaciones en FreeBSD.</p></dd><dt class=hdlist1><em><a href=./#multimedia>Multimedia</a></em></dt><dd><p>Trata sobre la configuración la reproducción de sonido y vídeo en su sistema. Describe también algunas aplicaciones de sonido y vídeo.</p></dd><dt class=hdlist1><em><a href=./#kernelconfig>Configuración del kernel de FreeBSD</a></em></dt><dd><p>Explica bajo qué circunstancias tendrá que configurar un nuevo kernel y facilita instrucciones detalladas para la configuración, compilación e instalación de un kernel personalizado.</p></dd><dt class=hdlist1><em><a href=./#printing>Imprimir</a></em></dt><dd><p>Describe la gestión de impresoras en FreeBSD, abarcando aspectos diversos como las páginas "banner", las cuentas de impresión así como la configuración inicial.</p></dd><dt class=hdlist1><em><a href=./#linuxemu>Compatibilidad binaria con Linux</a></em></dt><dd><p>Describe las características de compatibilidad con Linux® de FreeBSD. Incluye también instrucciones detalladas de instalación de varias aplicaciones Linux® muy populares, como Oracle®, SAP® R/3® y Mathematica®.</p></dd><dt class=hdlist1><em><a href=./#config-tuning>Configuración y adaptación del sistema</a></em></dt><dd><p>Describe los parámetros que los administradores de sistemas tienen a su alcance para hacer que FreeBSD rinda al máximo. Describe también los diversos ficheros de configuración que se usan en FreeBSD y dónde están.</p></dd><dt class=hdlist1><em><a href=./#boot>El proceso de arranque en FreeBSD</a></em></dt><dd><p>Describe el proceso de arranque de FreeBSD y explica cómo controlar este proceso mediante opciones de configuración.</p></dd><dt class=hdlist1><em><a href=./#users>Usuarios y administración básica de cuentas</a></em></dt><dd><p>Describe la creación y gestión de cuentas de usuario. Trata también sobre la limitación de recursos que puede aplicarse sobre los mismos, así como otras tareas administrativas.</p></dd><dt class=hdlist1><em><a href=./#security>Seguridad</a></em></dt><dd><p>Describe las abudantes herramientas diferentes que pueden ayudar a que su sistema FreeBSD esté y permanezca seguro. Entre ellas encontrará a Kerberos, IPsec y OpenSSH.</p></dd><dt class=hdlist1><em><a href=./#jails>Jaulas</a></em></dt><dd><p>Describe el uso de jaulas en FreeBSD y el avance que este "framework" supone respecto al tradicional uso de chroot que se hacía en FreeBSD.</p></dd><dt class=hdlist1><em><a href=./#mac>Mandatory Access Control</a></em></dt><dd><p>Explica qué es Mandatory Access Control (MAC) y cómo puede usarse este mecanismo para hacer más seguro FreeBSD</p></dd><dt class=hdlist1><em><a href=./#audit>Auditoría de eventos de seguridad</a></em></dt><dd><p>Describe qué es la auditoría de eventos en FreeBSD cómo instalarla y configurarla y cómo pueden inspeccionarse y monitorizarse dichas auditorías.</p></dd><dt class=hdlist1><em><a href=./#disks>Almacenamiento</a></em></dt><dd><p>Describe cómo gestionar medios de almacenamiento y sistemas de ficheros en FreeBSD, tanto discos físicos, arreglos RAID, medios ópticos o en cinta, como discos en memoria y sistemas de ficheros en red.</p></dd><dt class=hdlist1><em><a href=./#geom>GEOM: Marco de trabajo modular de transformación de discos</a></em></dt><dd><p>Trata sobre el "framework""GEOM" de FreeBSD y cómo configurar con él alguno de los diversos niveles de RAID que admite.</p></dd><dt class=hdlist1><em><a href=./#vinum-vinum>El Gestor de Volúmenes Vinum</a></em></dt><dd><p>Describe cómo usar Vinum, un gestor de volúmenes lógicos que permite tanto el uso de discos lógicos independientes de dispositivo, como RAID-0, RAID-1 y RAID-5 por software.</p></dd><dt class=hdlist1><em><a href=./#virtualization>Virtualización</a></em></dt><dd><p>Describe los sistemas de virtualización disponibles en FreeBSD y cómo utilizarlos.</p></dd><dt class=hdlist1><em><a href=./#l10n>Localización - Uso y configuración de I18N/L10N</a></em></dt><dd><p>Describe el uso en FreeBSD de idiomas distintos del inglés. Trata tanto la localización del sistema como de las aplicaciones.</p></dd><dt class=hdlist1><em><a href=./#updating-upgrading>Lo último de lo último</a></em></dt><dd><p>Explica las diferencias existentes entre FreeBSD-STABLE, FreeBSD-CURRENT y las releases de FreeBSD. Describe también qué tipos de usuario pueden beneficiarse de seguir el desarrollo contínuo del sistema en su propia máquina y muestra el proceso a seguir.</p></dd><dt class=hdlist1><em><a href=./#serialcomms>Comunicaciones serie</a></em></dt><dd><p>Explica cómo conectar terminales serie y módems a su sistema FreeBSD tanto para conexiones entrantes como salientes.</p></dd><dt class=hdlist1><em><a href=./#ppp-and-slip>PPP y SLIP</a></em></dt><dd><p>Describe cómo usar en FreeBSD PPP, SLIP o PPP sobre Ethernet para conexiones a sistemas remotos.</p></dd><dt class=hdlist1><em><a href=./#mail>Correo electrónico</a></em></dt><dd><p>Detalla los distintos elementos que componen un servidor de correo electrónico y explica diversos aspectos sencillos de la configuración del servidor de correo más extendido: sendmail.</p></dd><dt class=hdlist1><em><a href=./#network-servers>Servidores de red</a></em></dt><dd><p>En este capítulo encontrará instrucciones detalladas y ficheros de configuración de ejemplo que le permitirán configurar su sistema FreeBSD como servidor NFS, servidor de nombres, servidor NIS o de sincronización de hora.</p></dd><dt class=hdlist1><em><a href=./#firewalls>Cortafuegos</a></em></dt><dd><p>Explica la filosofía que sustenta los cortafuegos por software y facilita información detallada sobre la configuración de los distintos cortafuegos disponibles en FreeBSD.</p></dd><dt class=hdlist1><em><a href=./#advanced-networking>Networking avanzado</a></em></dt><dd><p>Describe diversos temas relacionados con el "networking", desde compartir la conexión a Internet con otras máquinas de su LAN a diversos aspectos avanzados del encaminamiento de tráfico, pasando por las redes "wireless", Bluetooth®, ATM, IPv6 y mucho más.</p></dd><dt class=hdlist1><em><a href=./#mirrors>Cómo conseguir FreeBSD</a></em></dt><dd><p>Enumera las diferentes fuentes desde la que puede conseguirse FreeBSD en CDROM o DVD, así como los numerosos sitios de Internet desde los que puede descargar e instalar FreeBSD.</p></dd><dt class=hdlist1><em><a href=./#bibliography>Bibliografía</a></em></dt><dd><p>Este libro toca tantos temas que es muy posible que el lector se quede a falta de una explicación más detallada. En la bibliografía muchos libros estupendos relacionados con el contenido de este texto.</p></dd><dt class=hdlist1><em><a href=./#eresources>Recursos en Internet</a></em></dt><dd><p>Describe los abundantes foros de que disponen los usuarios de FreeBSD para enviar preguntas y participar en conversaciones técnicas sobre FreeBSD.</p></dd><dt class=hdlist1><em><a href=./#pgpkeys>PGP Keys</a></em></dt><dd><p>Lista las claves públicas PGP de varios desarrolladores de FreeBSD.</p></dd></dl></div></div><div class=sect2><h3 id=preface-conv>Convenciones usadas en este libro<a class=anchor href=#preface-conv></a></h3><div class=paragraph><p>Con el ánimo de mantener la consistencia y facilitar la lectura del texto se siguen varias convenciones a lo largo del libro.</p></div><div class=sect3><h4 id=preface-conv-typographic>Convenciones tipográficas<a class=anchor href=#preface-conv-typographic></a></h4><div class=dlist><dl><dt class=hdlist1><em>Cursiva</em></dt><dd><p>Se usa un tipo de letra_cursiva_ cuando se citan nombres de fichero, URL, texto en el que se quiere hacer énfasis y cuando un término técnico aparece por primera vez en el texto.</p></dd><dt class=hdlist1><code>Tipografía de máquina de escribir</code></dt><dd><p>Se usa un tipo de letra <code>de máquina de escribir</code> cuando se muestran mensajes de error, comandos, variables de entorno, nombres de "ports", nombres de máquina, nombres de usuario o de grupo, nombres de dispositivo, variables y cuando Se usa un tipo de letra <code>monospaced</code> cuando se muestran mensajes de error, comandos, variables de entorno, nombres de "ports", nombres de máquina, nombres de usuario o de grupo, nombres de dispositivo, variables y cuando se muestran fragmentos de código.</p></dd><dt class=hdlist1>Negrita</dt><dd><p>Se usa un tipo de letra negrita en el nombre de aplicaciones, comandos y cuando se muestran claves.</p></dd></dl></div></div><div class=sect3><h4 id=preface-conv-commands>Datos que introduce el usuario<a class=anchor href=#preface-conv-commands></a></h4><div class=paragraph><p>Las claves se muestran en <strong>negrita</strong> para distinguirlas de cualquier otro texto. Las combinaciones de teclas que implican que sean pulsadas simultáneamente se muestran con el símbolo <code>+</code> entre una y otra, como en:</p></div><div class=paragraph><p><span class=keyseq><kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>Supr</kbd></span></p></div><div class=paragraph><p>Esto significa que el usuario debe pulsar las teclas <kbd>Ctrl</kbd>, <kbd>Ctrl</kbd>, <kbd>Alt</kbd> y <kbd>Supr</kbd> al mismo tiempo.</p></div><div class=paragraph><p>Las teclas que deben pulsarse secuencialmente se separan con comas, como en este ejemplo:</p></div><div class=paragraph><p><span class=keyseq><kbd>Ctrl</kbd>+<kbd>X</kbd></span>, <span class=keyseq><kbd>Ctrl</kbd>+<kbd>S</kbd></span></p></div><div class=paragraph><p>Esto significa que el usuario debe pulsar simultáneamente las teclas <kbd>Ctrl</kbd> y <kbd>X</kbd> y después pulsar simultáneamente <kbd>Ctrl</kbd> y <kbd>S</kbd>.</p></div></div><div class=sect3><h4 id=preface-conv-examples>Ejemplos<a class=anchor href=#preface-conv-examples></a></h4><div class=paragraph><p>Un comienzo como <span class=filename>E:\></span> indica un ejemplo de comando de MS-DOS®. A menos que se especifique otra cosa, estos comandos deben ejecutarse en una terminal "Command Prompt" de un sistema Microsoft® Windows® moderno.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>E:<span class=se>\&gt;</span> tools<span class=se>\f</span>dimage floppies<span class=se>\k</span>ern.flp A:</code></pre></div></div><div class=paragraph><p>Si hay un # indica que el comando debe ejecutarse como superusuario en FreeBSD. Puede acceder al sistema como <code>root</code> y ejecutar el comando o bien con su usuario habitual y utilizar <a href="https://man.freebsd.org/cgi/man.cgi?query=su&amp;sektion=1&amp;format=html">su(1)</a> para disponer de privilegios de superusuario.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dd if=kern.flp of=/dev/fd0</span></code></pre></div></div><div class=paragraph><p>Si el ejemplo comienza con un % indica que el comando puede ejecutarse en una cuenta de usuario normal. Salvo que se indique otra cosa se usa la sintaxis de C-shell para asignar valores a variables de entorno u otros comandos.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% top</code></pre></div></div></div></div><div class=sect2><h3 id=preface-acknowledgements>Agradecimientos<a class=anchor href=#preface-acknowledgements></a></h3><div class=paragraph><p>Este libro representa el esfuerzo de muchos cientos de personas del mundo entero. Tanto si fue en forma de correción de errores de contenido como gramaticales, o bien fue un capítulo entero lo que enviaron, toda contribución ha sido muy valiosa.</p></div><div class=paragraph><p>Varias compañías han colaborado en el desarrollo de este documento pagando a tiempo completo a varios autores, financiando la publicación, etc. En especial BSDi (posteriormente adquirida por <a href=http://www.windriver.com>Wind River Systems</a>) pagaron a varios miembros del FreeBSD Documentation Project por trabajar en la mejora lo que fue la primera edición de este libro, que apareció en marzo de 2000 (ISBN 1-57176-241-8). Además de esto, Wind River Systems aportó el dinero para que otros autores pudieran realizar gran cantidad de mejoras en la estructura de creación de material listo para impresión y para pudieran añadir nuevos capítulos. Este trabajo culminó con la publicación de la segunda edición impresa en noviembre de 2001 (ISBN 1-57176-303-1). En 2003 y 2004 <a href=http://www.freebsdmall.com>FreeBSD Mall, Inc</a>, pagó a varios autores para que se dedicaran a lo que será la tercera edición.</p></div></div></div></div><h1 id=getting-started class=sect0>Parte I: Primeros pasos<a class=anchor href=#getting-started></a></h1><div class="openblock partintro"><div class=content><div class=paragraph><p>Esta parte del manual de FreeBSD es para usuarios y administradores nuevos en FreeBSD. El cometido de estos capítulos es:</p></div><div class=ulist><ul><li><p>Ofrecer una introducción a FreeBSD.</p></li><li><p>Guiar a través de una instalación de FreeBSD.</p></li><li><p>Explicar conceptos básica de Unix.</p></li><li><p>Explicar cómo instalar la gran cantidad de software de terceros disponible para FreeBSD.</p></li><li><p>Presentar una introducción al manejo de X Window, el sistema de ventanas de UNIX®, y detallar cómo configurar un entorno de escritorio más productivo.</p></li></ul></div><div class=paragraph><p>Se ha intentado minimizar el número de referencias a otras secciones de este documento para evitar el salto entre páginas y facilitar la lectura continuada.</p></div></div></div><div class=sect1><h2 id=introduction>Capítulo 1. Introducción<a class=anchor href=#introduction></a></h2><div class=sectionbody><div class=sect2><h3 id=introcution-synopsis>1.1. Sinopsis<a class=anchor href=#introcution-synopsis></a></h3><div class=paragraph><p>Gracias por su interés en FreeBSD. El siguiente capítulo trata varios temas relativos al Proyecto FreeBSD, como su historia, objetivos, modelo de desarrollo, etc.</p></div><div class=paragraph><p>Después de leer este capítulo sabrá:</p></div><div class=ulist><ul><li><p>Qué relación guarda FreeBSD con otros sistemas operativos.</p></li><li><p>La historia del Proyecto FreeBSD.</p></li><li><p>Los objetivos del Proyecto FreeBSD.</p></li><li><p>Los fundamentos del modelo de desarrollo de código abierto de FreeBSD.</p></li><li><p>Y por supuesto: de dónde procede el nombre "FreeBSD".</p></li></ul></div></div><div class=sect2><h3 id=nutshell>1.2. Bienvenido a FreeBSD<a class=anchor href=#nutshell></a></h3><div class=paragraph><p>FreeBSD es un sistema operativo basado en 4.4BSD-Lite para ordenadores Intel (x86 e Itanium®), AMD64, Alpha™ y Sun UltraSPARC®. Se está trabajando también en versiones para otras arquitecturas. También puede leer sobre <a href=#history>la historia de FreeBSD</a>, o sobre la <a href=#relnotes>distribución actual</a>. Si cree que puede ayudar al proyecto de algún modo (desarrollando código, donando hardware, dinero, etc) consulte el artículo <a href=https://docs.freebsd.org/es/articles/contributing/>Contribuir a FreeBSD</a>.</p></div><div class=sect3><h4 id=os-overview>1.2.1. ¿Qué puede hacer FreeBSD?<a class=anchor href=#os-overview></a></h4><div class=paragraph><p>FreeBSD tiene muchas características notables. Algunas de ellas son:</p></div><div class=ulist><ul><li><p><em>Multitarea expropiativa</em> con prioridades dinámicamente ajustadas para asegurar que distintas aplicaciones y usuarios compartan los recursos del sistema de un modo equitativo, incluso bajo la mayor de las cargas.</p></li><li><p><em>Servicios multiusuario</em> que permiten a mucha gente usar un sistema FreeBSD simultáneamente para distintas cosas. Ésto significa, por ejemplo, que los periféricos del sistema como impresoras y dispositivos de cinta son compartidos adecuadamente por varios usuarios del sistema o la red, y que pueden establecerse límites sobre recursos concretos para usuarios o grupos de usuarios, protegiendo los recursos críticos del sistema de un uso abusivo.</p></li><li><p>Conexión de <em>redes TCP/IP</em> muy robusta, con soporte para estándares industriales como SCTP, DHCP, NFS, NIS, PPP, SLIP, IPSec e IPv6. Esto quiere decir que su sistema FreeBSD puede interactuar fácilmente con otros sistemas y hacer de servidor en una empresa, proporcionando servicios clave como NFS (acceso a ficheros remotos) y servicios de correo electrónico, o proporcinando la presencia en Internet de su organización mediante WWW, FTP, servicios de encaminamiento y cortafuegos.</p></li><li><p>La <em>protección de memoria</em> garantiza que las aplicaciones (o los usuarios) no se estorben los unos a los otros. Un error catastrófico en una aplicación no afecta al resto.</p></li><li><p>FreeBSD es un sistema operativo de <em>32-bits</em> (de <em>64-bits</em> en Alpha, Itanium®, AMD64, y UltraSPARC®) y fue diseñado como tal desde el principio.</p></li><li><p><em>X Window System</em> (X11R6), estándar de la industria, dota a los usuarios una interfaz gráfica (GUI) por el coste de una tarjeta VGA y un monitor comunes, y viene con los fuentes completos.</p></li><li><p><em>Compatibilidad binaria</em> con muchos programas nativos de Linux, SCO, SVR4, BSDI y NetBSD.</p></li><li><p>Hay en Internet miles y miles de aplicaciones <em>listas para su uso</em>. FreeBSD es compatible a nivel de código fuente con la mayoría de sistemas UNIX® comerciales; por tanto la mayoría de aplicaciones requieren poco o ningún cambio para compilar en FreeBSD.</p></li><li><p>En Internet hay miles de aplicaciones <em>fáciles de portar</em>. El código fuente de FreeBSD es compatible con el de los sistemas UNIX® comerciales más populares y por ello la mayoría de las aplicaciones tan sólo necesitan pocos cambios, si es que necesitan alguno, para compilar.</p></li><li><p>El diseño de la <em>memoria virtual</em> con paginación bajo demanda y de la "caché unificada de VM/buffer" satisface a aplicaciones que requieren grandes cantidades de memoria de forma eficiente aun dando respuestas interactivas a otros usuarios.</p></li><li><p>Soporte para <em>SMP</em> en máquinas con múltiples CPUs.</p></li><li><p>Una colección completa de herramientas de desarrollo en <em>C</em>, <em>C++</em>, <em>Fortran</em>, y <em>Perl</em>. Podrá encontrar muchos otros lenguajes avanzados para investigación y desarrollo tanto en la la Colección de Ports como en forma de <em>packace</em>.</p></li><li><p>Disponer del <em>código fuente</em> del sistema entero significa contar con el mayor nivel de control posible sobre su entorno. ?Para qué atarse a una solución propietaria a merced de un fabricante cuando puede tener un verdadero sistema abierto?</p></li><li><p>Documentación exhaustiva <em>en línea</em>.</p></li><li><p><em>¡Y mucho más!</em></p></li></ul></div><div class=paragraph><p>FreeBSD está basado en la versión 4.4BSD-Lite del Computer Systems Research Group (CSRG) de la Universidad de California en Berkeley, y continúa la distinguida tradición de desarrollo de sistemas BSD. Además del excelente trabajo del CSRG, el Proyecto FreeBSD ha invertido miles de horas en ajustar el sistema para conseguir un rendimiento y una fiabilidad máximas en situaciones de carga reales. Mientras que muchos de los gigantes comerciales se esfuerzan en dotar a los sistemas operativos para PC de esas características, rendimiento y fiabilidad, FreeBSD puede ofrecerlas ¡<em>ya</em>!</p></div><div class=paragraph><p>Los usos que pueda darle a FreeBSD se ven limitados tan sólo por su imaginación. Desde el desarrollo de programas hasta la automatización de fábricas, desde control de inventarios hasta corrección de azimut de antenas de satélites remotos; Si puede hacerse con un UNIX® comercial lo más seguro es que también pueda llevarse a cabo con FreeBSD. FreeBSD también hace buen uso de las literalmente miles de aplicaciones de alta calidad que se desarrollan en centros de investigación y universidades de todo el mundo, frecuentemente disponibles por poco o ningún coste. También existen aplicaciones comerciales, cuyo número aumenta cada dia.</p></div><div class=paragraph><p>Dado que el código fuente de FreeBSD está disponible para todo el mundo el sistema puede personalizarse en un grado nunca visto para aplicaciones o proyectos especiales, y de maneras generalmente imposibles con los sistemas operativos de la mayoría de los fabricantes comerciales. Aquí damos tan sólo una muestra de aplicaciones en las que se está usando actualmente FreeBSD:</p></div><div class=ulist><ul><li><p><em>Servicios de Internet:</em> La robusta conectividad TCP/IP integrada en FreeBSD hace de este sistema una plataforma ideal para servicios de Internet como:</p><div class=ulist><ul><li><p>Servidores FTP</p></li><li><p>Servidores web (estándares o seguros [SSL])</p></li><li><p>Cortafuegos y pasarelas NAT ("enmascaramiento IP").</p></li><li><p>Servidores de correo electrónico</p></li><li><p>USENET y BBSs</p></li><li><p>y muchos más.</p><div class=paragraph><p>Con FreeBSD puede empezar fácilmente con un pequeño y económico PC de tipo 386 e ir actualizando su equipo hasta un tetraprocesador Xeon con almacenamiento RAID a medida que su proyecto crezca.</p></div></li></ul></div></li><li><p><em>Educación:</em> ?Es estudiante de informática o de algún campo relacionado con la ingeniería? No hay mejor modo de estudiar sistemas operativos, arquitectura de computadores y redes que la experiencia a bajo nivel que FreeBSD puede aportar. Para aquéllos cuyo principal interés en los ordenadores no es otro que el de poder realizar su trabajo existe una serie de paquetes gratuitos de CAD, matemáticas y diseño gráfico que hacen de FreeBSD un sistema verdaderamente útil.</p></li><li><p><em>Investigación:</em> Encontrándose disponible el código fuente del sistema entero FreeBSD es una excelente plataforma para la investigación en sistemas operativos y otras ramas de la informática. El hecho de que FreeBSD esté disponible gratuítamente hace posible que grupos remotos puedan colaborar con ideas o compartan desarrollos sin tener que preocuparse de acuerdos de licencias especiales o de limitaciones acerca de lo que puede discutirse en foros públicos.</p></li><li><p><em>Redes:</em> ?Necesita un nuevo "router"? ?Un servidor de nombres (DNS)? ?Un cortafuegos que haga más segura su red interna? FreeBSD puede convertir ese PC 386 o 486 que tiene arrinconado en un "router" avanzado con sofisticadas capacidades de filtrado de paquetes.</p></li><li><p><em>Estación de trabajo X:</em> FreeBSD es una magnífica elección como terminal X de bajo coste gracias al servidor libre X11. A diferencia de las terminales X FreeBSD permite ejecutar muchas aplicaciones en local si así se quiere, aligerando de este modo la carga soportada por el servidor central. FreeBSD puede incluso arrancar "sin disco", permitiendo que las estaciones sean aún más económicas y fáciles de administrar.</p></li><li><p><em>Desarrollo de software:</em> El sistema base de FreeBSD incluye una completa colección de herramientas de desarrollo que incluyen el famoso compilador y depurador de C/C++ de GNU.</p></li></ul></div><div class=paragraph><p>Puede conseguir FreeBSD tanto en forma de código fuente como binaria por FTP anónimo o en CDROM. Por favor, consulte el <a href=./#mirrors>Cómo obtener FreeBSD</a> para más información.</p></div></div><div class=sect3><h4 id=_quién_usa_freebsd>1.2.2. ¿Quién usa FreeBSD?<a class=anchor href=#_quién_usa_freebsd></a></h4><div class=paragraph><p>Algunos de los mayores sitios web de Internet utilizan FreeBSD; he aquí algunos de ellos:</p></div><div class=ulist><ul><li><p><a href=http://www.yahoo.com/>Yahoo!</a></p></li><li><p><a href=http://www.apache.org/>Apache</a></p></li><li><p><a href=http://www.bluemountain.com/>Blue Mountain Arts</a></p></li><li><p><a href=http://www.pair.com/>Pair Networks</a></p></li><li><p><a href=http://www.sony.co.jp/>Sony Japón</a></p></li><li><p><a href=http://www.netcraft.com/>Netcraft</a></p></li><li><p><a href=http://www.wni.com/>Weathernews</a></p></li><li><p><a href=http://www.supervalu.com/>Supervalu</a></p></li><li><p><a href=http://www.telehouse.com/>TELEHOUSE America</a></p></li><li><p><a href=http://www.sophos.com/>Sophos Anti-Virus</a></p></li><li><p><a href=http://www.jmawired.com/>JMA Wired</a></p></li></ul></div><div class=paragraph><p>y muchos más.</p></div></div></div><div class=sect2><h3 id=history>1.3. Acerca del Proyecto FreeBSD<a class=anchor href=#history></a></h3><div class=paragraph><p>En la siguiente sección se explican ciertos aspectos básicos del Proyecto, una breve historia, sus objetivos y el modelo de desarrollo del mismo.</p></div><div class=sect3><h4 id=intro-history>1.3.1. Breve historia de FreeBSD<a class=anchor href=#intro-history></a></h4><div class=paragraph><p>La génesis del proyecto FreeBSD se remonta a comienzos de 1993, en parte como una extensión del "Unofficial 386BSD Patchkit" debida a los tres últimos coordinadores del patchkit: Nate Williams, Rod Grimes y yo mismo.</p></div><div class=paragraph><p>Nuestro objetivo original era producir una instantánea de 386BSD intermedia para arreglar una serie de problemas que no se podían solventar con uno de nuestros parches. Quizás haya quien recuerde que el primer nombre del proyecto fue "386BSD 0.5" o "386BSD Interim" debido a esto.</p></div><div class=paragraph><p>386BSD era el sistema operativo de Bill Jolitz, que hasta ese punto había estado sufriendo severamente las consecuencias de prácticamente un año que más valdría olvidar. A medida que el "patchkit" se iba haciendo haciendo más incómodo cada dia que pasaba, así que acordamos ayudar a Bill con una instantánea del sistema. Estos planes se vieron bruscamente interrumpidos cuando Bill Jolitz decidió repentinamente retirar su aprobación al proyecto sin dejar ninguna indicación clara de qué debía hacerse a continuación.</p></div><div class=paragraph><p>No tardamos mucho en decidir que el objetivo seguía valiendo la pena, aun sin el soporte de Bill, así que adoptamos el nombre de "FreeBSD", una idea de David Greenman. Nuestros objetivos iniciales se fijaron tras consultar a los usuarios del sistema y cuando quedó claro que el proyecto estaba en marcha y que podía llegar a ser una realidad contacté con Walnut Creek CDROM con idea de mejorar los canales de distribución de FreeBSD y hacer más fácil llegar a aquellas personas que no tenían la suerte de tener acceso a Internet. Walnut Creek CDROM no solo nos ayudó con la idea de distribuir FreeBSD en CD; también facilitó al Proyecto una máquina en la que trabajar y una conexión rápida a Internet. Sin la fe casi sin precedentes que tuvo Walnut Creek CDROM en lo que era en aquél momento un proyecto completamente desconocido, es bastante improbable que FreeBSD hubiera logrado tanto y tan rápido como ha logrado hasta el dia de hoy.</p></div><div class=paragraph><p>La primera distribución en CDROM (y disponible por la red) fue FreeBSD 1.0, publicado en diciembre de 1993. Estaba basado en la cinta de U.C. Berkeley del 4.3BSD-Lite ("Net/2"), con bastantes componentes de 386BSD y de trabajos proveniente de la Free Software Foundation. Fue un logro bastante apreciable para una primera versión; pronto le siguió FreeBSD 1.1 en mayo de 1994, que tuvo un gran éxito.</p></div><div class=paragraph><p>Por entonces se formaron unos inesperados nubarrones en el horizonte ya que Novell y la Universidad de Berkeley resolvieron el largo juicio acerca del estatus legal de la cinta de Berkeley Net/2. Una condición del acuerdo fue la concesión por parte de Berkeley de que una gran parte de Net/2 era código "gravado" y propiedad de Novell, quien a su vez lo había adquirido de AT&amp;T anteriormente. Berkeley obtuvo a cambio de Novell el "beneplácito" para que 4.4BSD-Lite, cuando saliera, fuera declarado como "no gravado" y se instara a los usuarios de Net/2 a cambiar. Esto repercutió sobre el Proyecto FreeBSD, a quienes se dio hasta julio de 1994 para dejar de sacar su producto basado en Net/2. Bajo los términos de aquel acuerdo se permitía al Proyecto sacar una última versión antes de la fecha límite: esa versión fue FreeBSD 1.1.5.1.</p></div><div class=paragraph><p>FreeBSD tuvo entonces que acometer la ardua tarea de (literalmente) reinventarse a sí mismo a partir de partes nuevas y bastante incompletas de 4.4BSD-Lite. Las versiones "Lite" eran ligeras en parte porque el CSRG de Berkeley quitó grandes partes del código necesario para construir un sistema que pudiera arrancar (debido a diversos requisitos legales) y porque la versión del 4.4 para Intel era muy incompleta. Hasta noviembre de 1994 el proyecto al fin realizó esa transición; apareció FreeBSD 2.0 en la red y (a finales de diciembre) en CDROM. A pesar de no estar suficientemente pulida esta distribución fue un éxito significativo, al cual siguió el más robusto y fácil de instalar FreeBSD 2.0.5; era junio de 1995.</p></div><div class=paragraph><p>Sacamos FreeBSD 2.1.5 en Agosto de 1996; pareció ser suficientemente popular entre ISPs y otras comunidades comerciales como para que mereciera otra versión de la rama 2.1-STABLE. Fue FreeBSD 2.1.7.1, publicada en febrero de 1997, que marcó el final de la línea principal de desarrollo en 2-1.STABLE. Una vez en puesta en mantenimiento, en esa rama (RELENG_2_1_0) sólo se harían ya mejoras en seguridad y se corregirían errores críticos.</p></div><div class=paragraph><p>FreeBSD se ramificó desde la línea principal de desarrollo ("-CURRENT") en noviembre de 1996 como la rama RELENG_2_2, y la primera versión completa (2.2.1) salió en abril de 1997. Se hicieron más versiones de la rama 2.2 en verano y otoño de 1997, la última de las cuales (2.2.8) apareció en noviembre de 1998. La primera versión 3.0 oficial salió en octubre de 1998 y marcó el inicio del fin de la rama 2.2.</p></div><div class=paragraph><p>El árbol se ramificó de nuevo el 20 de Enero de 1999, dando lugar a las ramas 4.0-CURRENT y 3.X-STABLE. A partir de la 3.X-STABLE salió 3.1 el 15 de febrero de 1999, 3.2 el 15 de mayo de 1999, 3.3 el 16 de septiembre de 1999, 3.4 el 20 de diciembre de 1999 y 3.5 el 24 de junio de 2000. Pocos dias después de esta apareció una actualización menor, la 3.5.1, que incorporaba parches de seguridad de última hora para Kerberos. Esa fue la última versión de la rama 3.X.</p></div><div class=paragraph><p>Hubo otra ramificación el 13 de Marzo de 2000 que dio lugar a la rama 4.X-STABLE. Ha habido varias versiones de la misma desde entonces: 4.0-RELEASE salió en marzo de 2000 y la última versión de la rama, 4.11-RELEASE, apareció en enero de 2005.</p></div><div class=paragraph><p>La largamente esperada 5.0-RELEASE se anunció el 19 de enero de 2003, culminando casi tres años de trabajo; esta versión situó a FreeBSD en el escenario del multiproceso avanzado y el soporte de hilos para las aplicaciones, e introdujo soporte para las plataformas UltraSPARC® y <code>ia64</code>. Siguió a esta la versión 5.1 lanzada en Junio de 2003. La última versión de 5.X como la rama -CURRENT fué 5.2.1-RELEASE, que salió en febrero de 2004.</p></div><div class=paragraph><p>La rama RELENG_5, creada en agosto de 2004, desembocó en 5.3-RELEASE, que marcó el inicio de la rama de versiones 5-STABLE. La versión 5.5-RELEASE más reciente apareció en mayo de 2006. No aparecerán más versiones a partir de la rama RELENG_5.</p></div><div class=paragraph><p>El árbol se dividió de nuevo en julio de 2005, en esta ocasión para crear RELENG_6. 6.0-RELEASE, la primera versión de la rama 6.X, apareció en noviembre de 2005. 11.2-RELEASE apareció en June 28, 2018. Irán apareciendo más versiones a partir de la rama RELENG_6.</p></div><div class=paragraph><p>La rama RELENG_7</p></div></div><div class=sect3><h4 id=goals>1.3.2. Objetivos del Proyecto FreeBSD<a class=anchor href=#goals></a></h4><div class=paragraph><p>Los objetivos del Proyecto FreeBSD son producir software que pueda usarse con cualquier propósito y sin ningún tipo de restricción. Muchos de nosotros participamos de forma significativa en el código (y en el proyecto) y ciertamente no nos importaría recibir una pequeña compensación económica de vez en cuando, pero no vamos a insistir en ello. Creemos que nuestra "misión" más importante y primordial es facilitar el acceso al código a cualquiera, para lo que quiera usarlo y de forma que se use tanto y para sacarle tanto provecho para sea posible. Creo que éste es uno de los objetivos más fundamentales del software libre y algo que nosotros apoyamos con entusiasmo.</p></div><div class=paragraph><p>El código fuente de nuestro árbol que se halla bajo la GNU General Public License (GPL) o la Library General Public License (LGPL) viene con algunas restricciones más, si bien para garantizar acceso al mismo, y no al contrario como es lo habitual. Debido a las complicaciones adicionales que pueden surgir en el uso comercial de software con licencia GPL preferimos que el software que incluyamos en el árbol venga bajo la licencia BSD, menos restrictiva, siempre y cuando sea una opción razonable.</p></div></div><div class=sect3><h4 id=development>1.3.3. El modelo de desarrollo de FreeBSD<a class=anchor href=#development></a></h4><div class=paragraph><p>El desarrollo de FreeBSD es un proceso muy abierto y flexible: FreeBSD está literalmente compuesto de partes hechas por centenares de personas de todo el mundo, como puede verse en <a href=https://docs.freebsd.org/en/articles/contributors/>este texto</a>. la infraestructura de desarrollo del proyecto FreeBSD permite a estos cientos de desarrolladores trabajar a través de Internet. Estamos buscando constantemente de nuevos desarrolladores e ideas. Las personas interesadas en vincularse más al proyecto tienen que ponerse en contacto con nosotros en la <a href=https://lists.FreeBSD.org/subscription/freebsd-hackers>Lista de correo de discusiones técnicas en FreeBSD</a>. La <a href=https://lists.FreeBSD.org/subscription/freebsd-announce>Lista de anuncios importantes del Proyecto FreeBSD</a> está a disposición de quienes deseen dar a conocer a otros usuarios de FreeBSD grandes áreas de trabajo.</p></div><div class=paragraph><p>Veamos unas cuantas cosas útiles sobre el Proyecto FreeBSD y su proceso de desarrollo, ya sea trabajando de forma independiente o en estrecha cooperación:</p></div><div class=dlist><dl><dt class=hdlist1>Los repositorios SVN y CVS<a id=development-cvs-repository></a></dt><dd><p>El árbol central de código de FreeBSD se ha mantenido mediante <a href=http://ximbiot.com/cvs/wiki/>CVS</a> (Concurrent Versions System, o sistema concurrente de versiones), una herramienta de control de código totalmente libre que forma parte de FreeBSD. En junio de 2008 el Proyecto adoptó <a href=http://subversion.tigris.org>SVN</a> (Subversion). La necesidad de un cambio como este venía de largo a medida que las limitaciones técnicas que el uso de CVS imponía se iban haciendo más y más obvias con la rápida expansión del árbol de código y de la cantidad de historial de cambios que hay que almacenar y gestionar. Aunque el repositorio principal use SVN las aplicaciones del lado del cliente como CVSup y csup, que dependen de la infraestructura anterior basada en CVS, siguen funcionando normalmente; los cambios que se hacen en el repositorio SVN se van replicando en el repositorio CVS con este fin. Actualmente (octubre 2008) solamente el árbol central de código usa SVN. Los repositorios de documentación, WWW y Ports siguen usando still using CVS. El <a href=http://www.FreeBSD.org/cgi/cvsweb.cgi>repositorio</a> primario está alojado en una máquina en Santa Clara (California, EEUU), que constituye el original del que todas las réplicas (a las que llamamos a veces "mirrors") son copias exactas actualizadas cada muy poco tiempo. El árbol SVN, que contiene también los árboles <a href=./#current>-CURRENT</a> y <a href=./#stable>-STABLE</a>, puede replicarse muy fácilmente en local en su máquina. Consulte la sección <a href=./#synching>Sincronización del árbol de código</a> para más información.</p></dd><dt class=hdlist1>La lista de committers<a id=development-committers></a></dt><dd><p>Los <em>committers</em> son la gente que tienen permisos de <em>escritura</em> en el los fuentes de FreeBSD (el término "committer" viene de la orden <code>commit</code> de <a href="https://man.freebsd.org/cgi/man.cgi?query=cvs&amp;sektion=1&amp;format=html">cvs(1)</a>, que sirve para hacer cambios en el repositorio CVS). La mejor manera de enviar aportaciones para que sean revisadas por los committers es usar <a href="https://man.freebsd.org/cgi/man.cgi?query=send-pr&amp;sektion=1&amp;format=html">send-pr(1)</a>. Si le parece que si pareciera que algo va mal en el sistema también puede enviar correo electrónico a la Lista de correo para 'committers' de FreeBSD.</p></dd><dt class=hdlist1>El Core Team de FreeBSD<a id=development-core></a></dt><dd><p>El <em>Core Team de FreeBSD</em> sería el equivalente a una junta directiva si el Proyecto FreeBSD fuese una compañía. La tarea principal del Core Team es la de garantizar que el Proyecto como un todo tenga salud y se mueva en las direcciones adecuadas. Otra de sus funciones es invitar a desarrolladores comprometidos y responsables a que se unan a nuestro equipo, además de reclutar nuevos miembros del Core Team cuando alguno se va. El Core Team actual fue elegido entre un conjunto de candidatos committers en julio de 2008. Se celebran elecciones cada dos años.</p><div class=paragraph><p>Algunos miembros del Core Team tienen también áreas específicas de responsabilidad, pues se encargan de garantizar que grandes secciones del sistema funcionen según lo previsto. Hay una lista completa de desarrolladores de FreeBSD con sus áreas de responsabilidad en la <a href=https://docs.freebsd.org/en/articles/contributors/>lista de colaboradores</a>. .</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>La mayoría de los miembros del Core Team trabaja de forma altruísta en el desarrollo de FreeBSD y no reciben beneficio económico del Proyecto; es por esto que "compromiso" no debe confundirse con "soporte garantizado". La anterior analogía de la "junta directiva" en realidad no es del todo exacta; quizá fuera más acertado decir que esa es la gente que dedica su vida a FreeBSD <em>en contra de lo que les aconseja su propio sentido común</em>.</p></div></td></tr></tbody></table></div></dd><dt class=hdlist1>Contribuidores externos</dt><dd><p>Por último, y no por ello menos importante, el mayor grupo de desarrolladores está formado por los mismos usuarios, quienes constantemente nos aportan comentarios y corrección de errores. La mejor manera de seguir de cerca el desarrollo (al estilo descentralizado de FreeBSD) es suscribirse a la <a href=https://lists.FreeBSD.org/subscription/freebsd-hackers>Lista de correo de discusiones técnicas en FreeBSD</a>, que es donde se habla de este tipo de cosas. Consulte el <a href=./#eresources>Recursos en Internet</a> si necesita más información sobre las diferentes listas de correo de FreeBSD.</p><div class=paragraph><p>La lista de colaboradores es larga y no para de crecer. ?Por qué no apuntarse y hacer algo en FreeBSD hoy mismo?</p></div><div class=paragraph><p>Aportar código no es la única manera de ayudar al proyecto; hay una lista completa de tareas pendientes en el <a href=http://www.freebsd.org>sitio web del Proyecto FreeBSD</a>.</p></div></dd></dl></div><div class=paragraph><p>En resumen, nuestro modelo de desarrollo está organizado como un conjunto de círculos concéntricos. El modelo centralizado está diseñado pensando el la comodidad de los "usuarios" de FreeBSD, que así tienen un modo sencillo de estar al dia con una base de código central y por supuesto <em>no para excluir a quien quiera ayudar</em>. Nuestro afán es ofrecer un sistema operativo estable con un gran conjunto de <a href=./#ports>aplicaciones</a> coherentes que los usuarios puedan instalar y usar fácilmente (y este modelo está dando buenos resultados)</p></div><div class=paragraph><p>Lo único que pedimos a quienes quieran unirse a nosotros como desarrolladores de FreeBSD es la misma dedicación que los integrantes actuales tienen.</p></div></div><div class=sect3><h4 id=relnotes>1.3.4. En qué consiste el FreeBSD que distribuimos<a class=anchor href=#relnotes></a></h4><div class=paragraph><p>FreeBSD es un sistema operativo libre y gratuito que se distribuye con el código fuente íntegro. Está basado en 4.4BSD-Lite y está diseñado para funcionar en sistemas Intel i386™, i486™, Pentium®, Pentium® Pro, Celeron®, Pentium® II, Pentium® III, Pentium® III, Pentium®4 (o compatible), Xeon™, DEC Alpha™ y sistemas basados en SUN UltraSPARC®. Está basado principalmente en software del grupo CSRG de la Universidad de Berkeley (California), y tiene mejoras importadas de NetBSD, OpenBSD, 386BSD y código creado al amparo de la Free Software Foundation.</p></div><div class=paragraph><p>Desde la versión 2.0 de FreeBSD de finales del 94 el rendimiento, conjunto de funcionalidades, y estabilidad del sistema han mejorado drásticamente. El último cambio consiste en un rediseño del sistema de memoria virtual con una caché unificada de VM/buffer que no solo aumenta el rendimiento sino que reduce el consumo de memoria de FreeBSD, haciendo que una configuración de 5 MB sea un mínimo más aceptable. Otras mejoras incluyen soporte completo para clientes y servidores NIS, soporte para transacciones TCP, llamada bajo demanda PPP, soporte para DHCP integrado, un subsistema SCSI mejorado, soporte para RDSI (ISDN), soporte para ATM, FDDI, adaptadores Fast y Gigabit Ethernet (1000 Mbit), soporte mejorado para los últimos controladores Adaptec y cientos de correcciones de errores.</p></div><div class=paragraph><p>Además de la distribución base FreeBSD ofrece una colección de software con miles de programas de uso común. <em>En el momento de escribir esto hay unos 36000 "Ports"</em> La lista de Ports comprende desde servidores HTTP (WWW), juegos, lenguajes de programación, editores, y prácticamente cualquier cosa. La colección de Ports completa requiere un espacio de aproximadamente 3 GB, todos ellos expresados como "deltas" de sus fuentes originales. Esto hace que nos sea mucho más fácil actualizar Ports y reduce notablemente el espacio en disco que necesitaba la anterior Colección de Ports 1.0. Para compilar un port uno simplemente se sitúa bajo el directorio del programa que desea instalar, escribe <code>make install</code> y deja que el sistema se encargue del resto. La distribución original completa de cada port que compile se descargará dinámicamente de un CDROM o un sitio FTP, de modo que sólo necesita el espacio necesario para compilar los ports que quiera. La mayoría de los ports también están precompilados como "packages", que quienes no quieran compilar Ports pueden instalar con una simple orden: <code>pkg_add</code>. En el <a href=./#ports>Instalación de aplicaciones: «packages» y ports</a> tiene más información sobre los "packages" y Ports.</p></div><div class=paragraph><p>Algunos documentos que pueden ser de ayuda en el proceso de instalación y al utilizar FreeBSD pueden también encontrarse el directorio <span class=filename>/usr/shared/doc</span> de cualquier máquina con una versión reciente de FreeBSD encontrará varios documentos que pueden serle de ayuda en el proceso de instalación o al usar FreeBSD. Para poder consultarlos utilice cualquier navegador para seguir estos enlaces:</p></div><div class=dlist><dl><dt class=hdlist1>El <em>Handbook</em> de FreeBSD</dt><dd><p><a href=file://localhost/usr/shared/doc/handbook/index.html>/usr/shared/doc/handbook/index.html</a></p></dd><dt class=hdlist1>Las FAQ de FreeBSD</dt><dd><p><a href=file://localhost/usr/shared/doc/faq/index.html>/usr/shared/doc/faq/index.html</a></p></dd></dl></div><div class=paragraph><p>También puede ver la copia original (y más frecuentemente actualizada) en <a href=http://www.FreeBSD.org/>http://www.FreeBSD.org/</a>.</p></div></div></div></div></div><div class=sect1><h2 id=bsdinstall>Capítulo 2. Instalación de FreeBSD<a class=anchor href=#bsdinstall></a></h2><div class=sectionbody><div class=sect2><h3 id=install-synopsis>2.1. Sinopsis<a class=anchor href=#install-synopsis></a></h3><div class=paragraph><p>FreeBSD dispone de un programa en modo texto muy fácil de usar llamado sysinstall. Es el programa de instalación por omisión en FreeBSD, pero quien decida distribuir FreeBSD tiene todo el derecho de facilitar un sistema de instalación propio si así lo desea. Este capítulo trata sobre cómo usar sysinstall para instalar FreeBSD</p></div><div class=paragraph><p>Tras leer este capítulo sabrá usted:</p></div><div class=ulist><ul><li><p>Cómo crear los discos de instalación de FreeBSD</p></li><li><p>Cómo interpreta (y subdivide) FreeBSD sus discos duros.</p></li><li><p>Cómo arrancar sysinstall.</p></li><li><p>Qué preguntas le hará sysinstall, qué significan y cómo responderlas.</p></li></ul></div><div class=paragraph><p>Antes de leer este capítulo debería usted:</p></div><div class=ulist><ul><li><p>Leer la lista de hardware soportado que se suministra con la con la versión de FreeBSD que va a instalar y verificar que su hardware está en dicha lista.</p></li></ul></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>En general éstas instrucciones de instalación han sido escritas para computadoras de arquitectura i386™ («PC compatible»). En algunos puntos concretos se darán instrucciones específicas para otras plataformas (por ejemplo Alpha). A pesar de que esta guía se intenta mantener todo lo al día que es posible puede que se encuentre con pequeñas diferencias entre el programa de instalación y lo que aquí se le muestra. Le sugerimos que use este capítulo como una guía general más que como un manual literal de instalación.</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=install-hardware>2.2. Requisitos de hardware<a class=anchor href=#install-hardware></a></h3><div class=sect3><h4 id=install-hardware-minimal>2.2.1. Configuración mínima<a class=anchor href=#install-hardware-minimal></a></h4><div class=paragraph><p>La configuración mínima para instalar FreeBSD varía según la versión de FreeBSD y la arquitectura de hardware.</p></div><div class=paragraph><p>Tiene información sobre la confuración mínima en las Notas de Instalación que encontrará en la sección de <a href=http://www.FreeBSD.org/releases/index.html>Información de Releases</a> del sitio web de FreeBSD. En la siguiente sección se facilita un resumen de dicha información. Dependiendo de cuál sea el método de instalación que elija para instalar FreeBSD necesitará un floppy, un lector de CDROM que pueda utilizar con FreeBSD o quizás un adaptador de red. Todo esto se explica en la <a href=#install-floppies>Preparación del medio de arranque</a>.</p></div><div class=sect4><h5 id=_freebsdi386_y_freebsdpc98>2.2.1.1. FreeBSD/i386 y FreeBSD/pc98<a class=anchor href=#_freebsdi386_y_freebsdpc98></a></h5><div class=paragraph><p>Tanto FreeBSD/i386 como FreeBSD/pc98 necesitan un procesador 486 o superior y un mínimo de 24 MB de RAM. Necesitará también al menos 150 MB de espacio libre en disco, que es lo que necesita la instalación mínima.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>En sistemas muy antiguos la mayoría de las veces será de mucha más ayuda conseguir más RAM y espacio de disco que un procesador más rápido.</p></div></td></tr></tbody></table></div></div><div class=sect4><h5 id=_freebsdalpha>2.2.1.2. FreeBSD/alpha<a class=anchor href=#_freebsdalpha></a></h5><div class=paragraph><p>Para instalar FreeBSD/alpha necesitará una plataforma que esté soportada (consulte <a href=#install-hardware-supported>Hardware soportado</a>) y un disco duro dedicado a FreeBSD. En este momento no es posible compartir un disco con otro sistema operativo. Este disco debe estar necesariamente conectado a una controladora SCSI que esté soportada por el firmware SRM, o si se trata de un disco IDE el SRM de su máquina debe permitir el arranque desde discos IDE.</p></div><div class=paragraph><p>Necesitará el firmware de la consola SRM de su plataforma. En ciertos casos es posible pasar del firmware AlphaBIOS (o ARC) al SRM. En otros casos no habrá más remedio que descargar un nuevo firmware desde el sito web del fabricante.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>A partir de FreeBSD 7.0 no hay soporte para Alpha. La serie FreeBSD 6.<em>X</em> es la última que ofrece soporte para esta arquitectura.</p></div></td></tr></tbody></table></div></div><div class=sect4><h5 id=_freebsdamd64>2.2.1.3. FreeBSD/amd64<a class=anchor href=#_freebsdamd64></a></h5><div class=paragraph><p>Hay dos tipos de procesadores capaces de ejecutar FreeBSD/amd64. La primera son los procesadores AMD64, entre los que están los AMD Athlon™64, AMD Athlon™64-FX, AMD Opteron™ y los modelos superiores.</p></div><div class=paragraph><p>La segunda categoría de procesadores que pueden usar FreeBSD/amd64 es la de los procesadores de arquitectura EM64T de Intel®, por ejemplo las familias de procesadores Intel® Core™ 2 Duo, Quad, y Extreme, y la secuencia de procesadores Intel® Xeon™ 3000, 5000 y 7000.</p></div><div class=paragraph><p>Si tiene una máquina basada en una nVidia nForce3 Pro-150 <em>tendrá que usar la configuración de la BIOS</em> para deshabilitar IO ACPI. Si no tiene la opción de hacerlo tendrá que deshabilitar ACPI. Hay errores en el chipset Pro-150 para los que no hemos encontrado aún una solución.</p></div></div><div class=sect4><h5 id=_freebsdsparc64>2.2.1.4. FreeBSD/sparc64<a class=anchor href=#_freebsdsparc64></a></h5><div class=paragraph><p>Para instalar FreeBSD/sparc64 necesita una plataforma que esté soportada (consulte la <a href=#install-hardware-supported>Hardware soportado</a>).</p></div><div class=paragraph><p>Necesitará un disco dedicado a FreeBSD/sparc64. De momento es imposible compartir un disco duro con otro sistema operativo.</p></div></div></div><div class=sect3><h4 id=install-hardware-supported>2.2.2. Hardware soportado<a class=anchor href=#install-hardware-supported></a></h4><div class=paragraph><p>Cada versión de FreeBSD incluye una lista de hardware soportado en las «FreeBSD Hardware Notes». Este documento suele estar en un fichero llamado <span class=filename>HARDWARE.TXT</span>, que está en el directorio raiz del CDROM o distribución FTP, o en el menú de documentación de sysinstall. En este documento se listan los dispositivos de hardware que se sabe que funcionan con cada versión de FreeBSD y para qué arquitectura. En la página de <a href=http://www.FreeBSD.org/releases/>Información de Releases</a> del sitio web de FreeBSD encontrará copias de esta lista para diversas releases y arquitecturas.</p></div></div></div><div class=sect2><h3 id=install-pre>2.3. Tareas anteriores a la instalación<a class=anchor href=#install-pre></a></h3><div class=sect3><h4 id=install-inventory>2.3.1. Inventario de su sistema<a class=anchor href=#install-inventory></a></h4><div class=paragraph><p>Antes de instalar FreeBSD en su sistema debería hacer un inventario de los componentes de su computadora. El sistema de instalación de FreeBSD le mostrará los componentes (discos duros, tarjetas de red, unidades de CDROM, etc.) con sus datos de modelo y fabricante. FreeBSD tratará también de determinar la configuración correcta para dichos dispositivos, lo que incluye información sobre las IRQ y el uso de puertos IO. A causa de la ingente variedad de hardware para PC este proceso no siempre se puede culminar con éxito y es posible que deba corregir las decisiones de FreeBSD retocando la configuración.</p></div><div class=paragraph><p>Si ya dispone de otro sistema operativo instalado (como Windows® o Linux) puede usar los recursos que dicho o dichos sistemas operativos le faciliten para determinar exactamente qué hardware tiene y cómo está configurado. Si tiene del todo claro qué configuración está usando una tarjeta de expasión concreta es posible que pueda encontrar esos datos impresos en la propia tarjeta. Es muy habitual el uso de las IRQ 3, 5 y 7 y las direcciones de los puertos IO suelen representarse con números hexadecimales, como 0x330.</p></div><div class=paragraph><p>Le recomendamos imprimir o tomar nota de todos esos datos antes de instalar FreeBSD. Una tabla como esta puede serle de mucha ayuda:</p></div><table class="tableblock frame-none grid-all stretch"><caption class=title>Tabla 1. Ejemplo de inventario de dispositivos</caption><col style=width:25%><col style=width:25%><col style=width:25%><col style=width:25%><thead><tr><th class="tableblock halign-left valign-top">Nombre de dispositivo</th><th class="tableblock halign-left valign-top">IRQ</th><th class="tableblock halign-left valign-top">Puerto(s) IO</th><th class="tableblock halign-left valign-top">Notas</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Primer disco duro</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>N/A</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>N/A</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>40 GB, fabricado por Seagate, primer maestro IDE</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>CDROM</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>N/A</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>N/A</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Primer esclavo IDE</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Segundo disco duro</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>N/A</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>N/A</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>20 GB, fabricado por IBM, segundo maestro IDE</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Primera controladora IDE</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>14</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>0x1f0</p></td><td class="tableblock halign-left valign-top"></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Tarjeta de red</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>N/A</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>N/A</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Intel® 10/100</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Módem</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>N/A</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>N/A</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>3Com® 56K faxmodem, en COM1</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>…​</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>…​</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>…​</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>…​</p></td></tr></tbody></table><div class=paragraph><p>Una vez termine el inventorio de componentes de su sistema debe comprobar si aparecen en la lista de hardware soportado de la versión de FreeBSD que vaya a instalar.</p></div></div><div class=sect3><h4 id=_haga_una_copia_de_seguridad_de_sus_datos>2.3.2. Haga una copia de seguridad de sus datos<a class=anchor href=#_haga_una_copia_de_seguridad_de_sus_datos></a></h4><div class=paragraph><p>Si la máquina en la que va a instalar FreeBSD contiene datos que desea conservar por algún motivo asegúrese de haber hecho una copia de seguridad de los mismos y de que esa copia es de fiar antes de instalar FreeBSD. El sistema de instalación de FreeBSD le mostrará una advertencia antes de modificar datos en su disco pero una vez que el proceso ha comenzado no hay manera de dar marcha atrás.</p></div></div><div class=sect3><h4 id=install-where>2.3.3. Decida dónde instalar FreeBSD<a class=anchor href=#install-where></a></h4><div class=paragraph><p>Si quiere que FreeBSD use todo su disco duro puede saltar tranquilamente a la siguiente sección.</p></div><div class=paragraph><p>Si por el contrario necesita que FreeBSD coexista con otros sistemas operativos tendrá que comprender cómo se almacenan los datos en el disco duro y cómo le afecta esto.</p></div><div class=sect4><h5 id=install-where-i386>2.3.3.1. Esquemas de disco en FreeBSD/i386™<a class=anchor href=#install-where-i386></a></h5><div class=paragraph><p>Un disco de PC puede dividirse en varias partes. Estas partes reciben el nombre de <em>partitions</em>. Dado que FreeBSD internamente también tiene particiones la nomenclatura puede ser confusa muy rápidamente, así que estas partes del disco reciben el nombre de «disk slices» o sencillamente «slices» («rebanadas de disco»y «rebanadas» respectivamente). Por ejemplo, la versión de <code>fdisk</code> que usará FreeBSD con las particiones de disco de PC usa la palabra «slices» en lugar de «partitions». Debido a limitaciones de diseño la plataforma PC sólo admite cuatro particiones por disco. Dichas particiones reciben el nombre de <em>particiones primarias</em>. Esta limitación puede sortearse (y de ese modo disponer de más de cuatro particiones) gracias a que se creó un nuevo tipo de partición, las <em>particiones extendidas</em>. Un disco puede contener una única partición extendida. Dentro de ella pueden crearse particiones especiales, que reciben el nombre de <em>particiones lógicas</em>.</p></div><div class=paragraph><p>Cada partición tiene un <em>identificador de partición</em> (o <em>partition ID</em>), que es un número que se usa para identificar el tipo de datos que alberga la partición. Las particiones FreeBSD tienen como identificador de partición <code>165</code>.</p></div><div class=paragraph><p>Normalmente cada sistema operativo que vaya a utilizar identificará las particiones de un modo propio. Por ejemplo DOS (y sus descendientes, como Windows®) asignan a cada partición primaria y lógica una <em>letra de unidad</em> a partir de <span class=filename>C:</span>.</p></div><div class=paragraph><p>FreeBSD debe instalarse en una partición primaria. FreeBSD puede albergar todos los datos que necesita, incluyendo cualquier fichero que pueda usted crear, en esta partición. Si tiene usted varios discos duros puede crear particiones para que FreeBSD las use en todos ellos o en algunos nada más. Al instalar FreeBSD debe usar al menos una partición. Puede usar una partición vacía que haya preparado o puede usar también una partición que contenga datos que no desea conservar.</p></div><div class=paragraph><p>Si está usando todas las particiones de todos sus discos tendrá que dejar libre una de ellas para FreeBSD usando las herramientas del otro sistema operativo que esté usando (por ejemplo <code>fdisk</code> en DOS o en Windows®).</p></div><div class=paragraph><p>Si tiene una partición sobrante puede usarla, pero puede verse en la necesidad de reducir una o más de las particiones que está usando.</p></div><div class=paragraph><p>Una instalación mínima de FreeBSD cabrí en sólo 100 MB de disco pero tenga en cuenta que apenas quedaría espacio para los ficheros que quiera crear. Un mínimo más realista sería de 250 MB si no pretende usar entorno gráfico y 350 MB o más si quiere usar un interfaz gráfico de usuario. Si quiere instalar gran cantidad de software para usarlo en FreeBSD sin duda necesitará más espacio.</p></div><div class=paragraph><p>Para ello puede usar herramientas comerciales como PartitionMagic® o libres como GParted para redimensionar sus particiones y hacer sitio para FreeBSD. El directorio <span class=filename>tools</span> directory del CDROM de instalación contiene dos herramientas libres con las que puede hacer hacer esta redimensión: FIPS y PResizer. En el mismo directorio encontrará documentación de ambas. FIPS, PResizer y PartitionMagic® pueden redimensionar particiones FAT16 y FAT32, que pueden encontrarse desde MS-DOS® hasta Windows® ME. Tanto PartitionMagic® como GParted funcionan también en particiones NTFS. GParted forma parte de diversas distribuciones de «Live CD» de Linux, como <a href=http://www.sysresccd.org/>SystemRescueCD</a>.</p></div><div class=paragraph><p>Hay informes de problemas redimensionando particiones de Microsoft® Vista. Le recomendamos tener a mano un disco de instalación de Vista cuando intente hacer esto. Lo dicho para cualquier otra tarea de mantenimiento de discos es válido aquí: tenga una copia de seguridad <em>fiable</em> y reciente a mano.</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>El uso incorrecto de estas herramientas puede borrar datos de su disco duro. Recuerde, asegúrese de disponer de copias de seguridad recientes y utilizables antes de usarlas.</p></div></td></tr></tbody></table></div><div class=exampleblock><div class=title>Ejemplo 1. Uso de una partición sin cambiar nada</div><div class=content><div class=paragraph><p>Supongamos que tiene una máquina con un sólo disco de 4 GB que ya tiene una versión de Windows® instalada y que ese disco está dividido en dos unidades, <span class=filename>C:</span> y <span class=filename>D:</span>, cada una de las cuales tiene un tamaño de 2 GB. Tiene 1 GB de datos en <span class=filename>C:</span> y 0.5 GB de datos en <span class=filename>D:</span>.</p></div><div class=paragraph><p>Esto significa que su disco duro tiene dos particiones, una por cada letra de unidad. Copie todos sus datos de <span class=filename>D:</span> en <span class=filename>C:</span>; de este modo vaciará la segunda partició y podrá usarla con FreeBSD.</p></div></div></div><div class=exampleblock><div class=title>Ejemplo 2. Reducir una partición existente</div><div class=content><div class=paragraph><p>Suponga que tiene una máquina con un sólo disco de 4 GB que contiene una versión de Windows® instalada. Cuando instaló Windows® creó una gran partición, lo que le dió como resultado una unidad <span class=filename>C:</span> de 4 GB. Está usando 1.5 GB de espacio y quiere que FreeBSD tenga 2 GB de espacio.</p></div><div class=paragraph><p>Para poder instalar FreeBSD tendrá que realizar una de las siguientes tareas:</p></div><div class="olist arabic"><ol class=arabic><li><p>Haga una copia de sus datos de Windows® y después reinstale Windows®, eligiendo una partición de 2 GB en el momento de la instalación.</p></li><li><p>Utilice alguna herramienta del estilo de PartitionMagic® que se han descrito antes para reducir el tamaño de su partición de Windows®.</p></li></ol></div></div></div></div><div class=sect4><h5 id=_estructura_de_discos_en_alpha>2.3.3.2. Estructura de discos en Alpha<a class=anchor href=#_estructura_de_discos_en_alpha></a></h5><div class=paragraph><p>Tendrá que dedicar un disco de su sistema para usar FreeBSD puesto que de momento es imposible compartir un disco con otro sistema operativo. Dependiendo de la la máquina Alpha que tenga el disco podrá ser SCSI o IDE en la medida en que sea posible arrancar desde tales discos.</p></div><div class=paragraph><p>Siguiendo las normas de los manuales de Digital / Compaq todos los datos suministrados a SRM se muestran en mayúsculas. SRM no distingue entre mayúsculas y minúsculas.</p></div><div class=paragraph><p>Use <code>SHOW DEVICE</code> en la consola de SRM para saber qué tipo de discos hay en su sistema:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=o>&gt;&gt;&gt;</span>SHOW DEVICE
dka0.0.0.4.0               DKA0           TOSHIBA CD-ROM XM-57  3476
dkc0.0.0.1009.0            DKC0                       RZ1BB-BS  0658
dkc100.1.0.1009.0          DKC100             SEAGATE ST34501W  0015
dva0.0.0.0.1               DVA0
ewa0.0.0.3.0               EWA0              00-00-F8-75-6D-01
pkc0.7.0.1009.0            PKC0                  SCSI Bus ID 7  5.27
pqa0.0.0.4.0               PQA0                       PCI EIDE
pqb0.0.1.4.0               PQB0                       PCI EIDE</code></pre></div></div><div class=paragraph><p>Este ejemplo es de una Digital Personal Workstation 433au y muestra tres discos instalados en el sistema. El primer disco es una unidad CDROM llamada <span class=filename>DKA0</span> y los otros dos reciben los nombres de <span class=filename>DKC0</span> y <span class=filename>DKC100</span> respectivamente.</p></div><div class=paragraph><p>Los discos con nombres tipo <span class=filename>DKx</span> son discos SCSI. Por ejemplo <span class=filename>DKA100</span> se refiere a un disco SCSI con el «target ID 1» en el primer bus SCSI (A), mientras que <span class=filename>DKC300</span> es un disco SCSI con un ID 3 en el tercer bus SCSI ©. Los nombres de dispositivo <span class=filename>PKx</span> son para adaptadores de bus SCSI. Como hemos visto en la salida de <code>SHOW DEVICE</code> las unidades CDROM SCSI son consideradas iguales a otros discos duros SCSI.</p></div><div class=paragraph><p>Los discos IDE tienen nombres similares a <span class=filename>DQx</span>, mientras que <span class=filename>PQx</span> es la controladora IDE asociada.</p></div></div></div><div class=sect3><h4 id=_recopile_los_datos_de_la_configuración_de_la_red>2.3.4. Recopile los datos de la configuración de la red<a class=anchor href=#_recopile_los_datos_de_la_configuración_de_la_red></a></h4><div class=paragraph><p>Si pretende conectarse a alguna red durante la instalación de FreeBSD (por ejemplo si pretende hacerlo desde un sitio FTP o mediante un servidor NFS) tendrá que conocer la configuración de su red. Durante la instalación se le pedirán esos datos para que FreeBSD pueda conectarse a la red y realizar la instalación.</p></div><div class=sect4><h5 id=_conexión_a_una_red_ethernet_o_a_un_módem_cabledsl>2.3.4.1. Conexión a una red Ethernet o a un módem Cable/DSL<a class=anchor href=#_conexión_a_una_red_ethernet_o_a_un_módem_cabledsl></a></h5><div class=paragraph><p>Necesitará la siguiente información si va a conectarse a una red Ethernet o si tiene una conexión a Internet a través de una adaptador Ethernet via cable o DSL:</p></div><div class="olist arabic"><ol class=arabic><li><p>Dirección IP</p></li><li><p>Dirección IP de la pasarela («gateway», «puerta de enlace»)</p></li><li><p>Nombre del sistema («hostname»)</p></li><li><p>Dirección IP del servidor DNS</p></li><li><p>Máscara de subred</p></li></ol></div><div class=paragraph><p>Si no conoce estos datos póngase en contacto con su administrador de sistemas o con su proveedor de servicios. Es que le digan que tal información se asigna automáticamente mediante <em>DHCP</em>. Si es así, anótelo.</p></div></div><div class=sect4><h5 id=_conexión_mediante_módem>2.3.4.2. Conexión mediante módem<a class=anchor href=#_conexión_mediante_módem></a></h5><div class=paragraph><p>Si usted se conecta con su ISP mediante un módem tradicional sigue pudiendo instalar FreeBSD a través de Internet; el problema es que tardará mucho más que por otros medios.</p></div><div class=paragraph><p>Necesitará saber:</p></div><div class="olist arabic"><ol class=arabic><li><p>El número de teléfono de su ISP a través del que accederá a Internet</p></li><li><p>El COM: el puerto al que está conectado su módem</p></li><li><p>Su nombre de usuario y su contraseña de acceso a Internet</p></li></ol></div></div></div><div class=sect3><h4 id=_consulte_freebsd_errata>2.3.5. Consulte «FreeBSD Errata»<a class=anchor href=#_consulte_freebsd_errata></a></h4><div class=paragraph><p>A pesar de que el proyecto FreeBSD hace todo lo humanamente posible para asegurarse de que cada «release» de FreeBSD es todo lo estable posible a veces algún error logra entrar en escena. En contadísimas ocasiones esos errores llegan a afectar al proceso de instalación. Cuando esos errores son ubicados y corregidos aparecen en lo que llamamos la <a href=http://www.FreeBSD.org/releases/12.0r/errata/>FreeBSD Errata</a>, que encontrará en el sitio web de FreeBSD. Debería consultar este texto antes de la instalación para asegurarse de que no hay problemas de última hora de los que deba preocuparse.</p></div><div class=paragraph><p>Tiene información sobre las «releases», incluyendo la «errata» de cada una de ellas, en la <a href=http://www.FreeBSD.org/releases/>sección de información de «releases» </a>del <a href=http://www.FreeBSD.org/>sitio web de FreeBSD</a>.</p></div></div><div class=sect3><h4 id=_obtención_de_los_ficheros_de_instalación_de_freebsd>2.3.6. Obtención de los ficheros de instalación de FreeBSD<a class=anchor href=#_obtención_de_los_ficheros_de_instalación_de_freebsd></a></h4><div class=paragraph><p>El proceso de instalación de FreeBSD permite instalar FreeBSD desde ficheros ubicados en cualquiera de los siguientes sitios:</p></div><div class=ulist><div class=title>Medios locales</div><ul><li><p>Un CDROM o DVD</p></li><li><p>Una partición DOS en la propia computadora</p></li><li><p>Una cinta SCSI o QIC</p></li><li><p>Discos floppy</p></li></ul></div><div class=ulist><div class=title>Red</div><ul><li><p>Un sitio FTP, saliendo a través de un cortafuegos o usando un proxy HTTP si fuera necesario</p></li><li><p>Un servidor NFS</p></li><li><p>Una conexión serie o a través de una cable paralelo</p></li></ul></div><div class=paragraph><p>Si ha adquirido FreeBSD en CD o DVD ya tiene todo lo que necesitará, puede pasar a la siguiente sección: (<a href=#install-floppies>Preparación del medio de arranque</a>).</p></div><div class=paragraph><p>Si no dispone de los ficheros de instalación de FreeBSD debería consultar la <a href=#install-diff-media>Cómo preparar su propio medio de instalación</a>, donde se explica cómo preparar la instalación de FreeBSD desde cualquiera de los medios listados anteriormente. Tras leer esa sección puede volver aquí y leer la <a href=#install-floppies>Preparación del medio de arranque</a>.</p></div></div><div class=sect3><h4 id=install-floppies>2.3.7. Preparación del medio de arranque<a class=anchor href=#install-floppies></a></h4><div class=paragraph><p>El proceso de instalación de FreeBSD comienza por arrancar su sistema mediante el instalador de FreeBSD: no es un programa que pueda ejecutar desde otro sistema operativo. Su sistema suele arrancar usando el sistema operativo que está instalado en su disco duro pero puede también ser configurado para que lo haga desde un floppy «arrancable». Las computadoras más modernas pueden también arrancar desde un CDROM introducido en la unidad CDROM.</p></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Si tiene FreeBSD en CDROM o DVD (por haberlo comprado o haberlo preparado por usted) y su sistema puede arracar desde CDROM o DVD (suele ser una opción de BIOS llamada «Boot Order» o algo similar) puede saltarse esta sección. Las imágenes de CDROM o DVD de FreeBSD permiten arrancar desde ellas y pueden emplearse para instalar FreeBSD sin ninguna preparación especial.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Siga estos pasos para crear las imágenes que le permitirán arrancar desde floppy:</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Consiga las imágenes de arranque desde floppy</p><div class=paragraph><p>Los discos de arranque se encuentran en el directorio <span class=filename>floppies/</span> del medio de instalación o pueden descargarse desde el directorio correspondiente de <code><a href="ftp://ftp.FreeBSD.org/pub/FreeBSD/releases/<arch>/<version>-RELEASE/floppies/" class=bare>ftp://ftp.FreeBSD.org/pub/FreeBSD/releases/&lt;arch>/&lt;version>-RELEASE/floppies/</a></code>. Reemplace <em>&lt;arch></em> y <em>&lt;version></em> con la arquitectura y la versión de FreeBSD que quiera instalar. Por ejemplo, las imágenes de arranque desde floppy para FreeBSD 12.0-RELEASE para i386™ están en from <a href=ftp://ftp.FreeBSD.org/pub/FreeBSD/releases/i386/12.0-RELEASE/floppies/>ftp://ftp.FreeBSD.org/pub/FreeBSD/releases/i386/12.0-RELEASE/floppies/</a>.</p></div><div class=paragraph><p>Las imágenes de floppy tienen la extensión <span class=filename>.flp</span>. El directorio <span class=filename>floppies/</span> contiene diferentes imágenes y las que usted necesitará dependerán de la versión de FreeBSD que vaya a instalar y, en algunos casos, del hardware en el que lo va a instalar. En la mayoría de de los casos solamente usará dos ficheros: <span class=filename>kern.flp</span> y <span class=filename>mfsroot.flp</span>. La instalación en algunos sistemas concretos requerirá controladores de dispositivo adicionales, que se encuentran en la imagen <span class=filename>drivers.flp</span>. Consulte <span class=filename>README.TXT</span> en el propio directorio, ahí encontrará la información más reciente sobre las imágenes.</p></div><div class="admonitionblock important"><table><tbody><tr><td class=icon><i class="fa icon-important" title=Important></i></td><td class=content><div class=paragraph><p>Su programa de FTP debe usar <em>modo binario</em> para descargar las imágenes. Algunos navegadores web suelen usar el modo <em>texto</em> ( o <em>ASCII</em>). He aquí lo primero a comprobar si no puede arrancar desde los disquetes que ha creado.</p></div></td></tr></tbody></table></div></li><li><p>Preparación de los discos floppy</p><div class=paragraph><p>Tendrá que preperar un disquete por cada imagen que descargue. Es imprescindible que esos discos carezcan de errores. La forma más sencilla de asegurarlo es formatearlos usted. No confíe en disquetes preformateados. La herramienta de formateo de Windows® no le advertirá del hallazgo de bloques defectuosos, si encuentra alguno sencillamente lo marcará como «defectuoso» y lo ignorará. Le recomendamos que use disquetes nuevos si decide usar este procedimiento de instalación.</p></div><div class="admonitionblock important"><table><tbody><tr><td class=icon><i class="fa icon-important" title=Important></i></td><td class=content><div class=paragraph><p>Si instenta instalar FreeBSD y el programa de instalación falla, se queda congelado o sucede alguna otra catástrofe uno de las primeras cosas de las que sospechar son los disquetes. Vuelque los ficheros de imagen en discos nuevos e inténtelo de nuevo.</p></div></td></tr></tbody></table></div></li><li><p>Escriba los ficheros de imagen en discos floppy («disquetes»)</p><div class=paragraph><p>Los ficheros <span class=filename>.flp</span> <em>no</em> son ficheros normales que puedan copiarse a disco. Son imágenes del contenido completo de los discos. Esto significa que <em>no puede</em> simplemente copiar esos ficheros de un disco a otro. Debe usar herramientas especializadas para escribir esas imágenes directamente al disco correspondiente.</p></div><div class=paragraph><p>Si va a crear los disquetes de arranque en un sistema en el que se está ejecutando MS-DOS®/Windows® utilice la herramienta <code>fdimage</code>.</p></div><div class=paragraph><p>Si las imágenes están en el CDROM y su CDROM es la unidad <span class=filename>E:</span> ejecute lo siguiente:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>E:<span class=se>\&gt;</span> tools<span class=se>\f</span>dimage floppies<span class=se>\k</span>ern.flp A:</code></pre></div></div><div class=paragraph><p>Repita el proceso con cada fichero <span class=filename>.flp</span> reemplazando cada vez el disco y recuerde etiquetarlos con el nombre del fichero que ha copiado en cada uno. Modifique la línea del comando donde sea necesario, adaptándola al lugar donde tenga usted los ficheros <span class=filename>.flp</span>. Puede descargar <code>fdimage</code> desde el directorio <a href=ftp://ftp.FreeBSD.org/pub/FreeBSD/tools/>tools </a>del sitio FTP de FreeBSD.</p></div><div class=paragraph><p>Si va a crear los disquetes en un sistema UNIX® (por ejemplo otro sistema FreeBSD) puede utilizar <a href="https://man.freebsd.org/cgi/man.cgi?query=dd&amp;sektion=1&amp;format=html">dd(1)</a> para volcar las imágenes a los discos. En FreeBSD puede ejecutar algo como:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dd if=kern.flp of=/dev/fd0</span></code></pre></div></div><div class=paragraph><p>En FreeBSD <span class=filename>/dev/fd0</span> es la primera unidad de disquetes (la unidad <span class=filename>A:</span>). <span class=filename>/dev/fd1</span> sería la unidad <span class=filename>B:</span> y así sucesivamente. Otras versiones de UNIX® pueden asignar nombres diferentes a las unidades de disquetes; consulte la documentación de su sistema.</p></div></li></ol></div></div></div><div class=paragraph><p>Ya podemos instalar instalar FreeBSD.</p></div></div></div><div class=sect2><h3 id=install-start>2.4. Inicio de la instalación<a class=anchor href=#install-start></a></h3><div class="admonitionblock important"><table><tbody><tr><td class=icon><i class="fa icon-important" title=Important></i></td><td class=content><div class=paragraph><p>La instalación no efectúa ningún cambio en su disco o discos duros hasta la aparición del siguiente mensaje:</p></div><div class=listingblock><div class=content><pre>Last Chance: Are you SURE you want continue the installation?

If you&#39;re running this on a disk with data you wish to save then WE
STRONGLY ENCOURAGE YOU TO MAKE PROPER BACKUPS before proceeding!

We can take no responsibility for lost disk contents!</pre></div></div><div class=paragraph><p>Es decir:</p></div><div class=listingblock><div class=content><pre>Última oportunidad: ?Seguro que quiere seguir adelante con la instalación?

¡Si está ejecutando este programa en un disco que contenga datos
que quiera conservar LE RECOMENDAMOS ENCARECIDAMENTE QUE HAGA
COPIAS DE SEGURIDAD FIABLES antes de proseguir!

¡No podemos responsabilizarnos de datos perdidos!</pre></div></div><div class=paragraph><p>El proceso de instalación puede abandonarse en cualquier momento antes de la advertencia final sin efectuar cambios en el contenido del disco duro. Si advierte que ha configurado algo de forma incorrecta basta con que apague su sistema y no estropeará nada.</p></div></td></tr></tbody></table></div><div class=sect3><h4 id=install-starting>2.4.1. El arranque<a class=anchor href=#install-starting></a></h4><div class=sect4><h5 id=install-starting-i386>2.4.1.1. El arranque en i386™<a class=anchor href=#install-starting-i386></a></h5><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Comience con su sistema apagado.</p></li><li><p>Arranque el sistema. Durante el arranque deberí mostrarse la opción para entrar en la BIOS, normalmente mediante las teclas <kbd>F2</kbd>, <kbd>F10</kbd>, <kbd>Del</kbd>, o <span class=keyseq><kbd>Alt</kbd>+<kbd>S</kbd></span>. Utilice la tecla o combinación de las mismas que se le indique en pantalla. En algunos casos el sistema puede mostrar un gráfico durante el arranque. Pulsar <kbd>Esc</kbd> suele disminuir en esos casos el tamaño del gráfico y le permitirá ver los mensajes del arranque.</p></li><li><p>Encuentre el parámetro que controla desde qué dispositivos arranca el sistema. Normalmente se llama «Boot Order» y suele presentarse como una lista de dispositivos, como <code>Floppy</code>, <code>CDROM</code>, <code>First Hard Disk</code>, etc.</p><div class=paragraph><p>Si necesita disquetes de arranque asegúrese de que selecciona la unidad correspondiente. Si va a arrancar desde CDROM, seleccione la unidad CDROM. En caso de duda consulte el manual que venía con su computadora y/o el de su placa base.</p></div><div class=paragraph><p>Haga los cambios necesarios, guarde los cambios y salga. El sistema debería reiniciarse.</p></div></li><li><p>Si ha elegido arrancar desde disquete, tal y como se describe en <a href=#install-floppies>Preparación del medio de arranque</a>, uno de ellos será el primer disco de arranque, probablemente el que contiene <span class=filename>kern.flp</span>. Introduzca ese disco en su unidad de disquetes.</p><div class=paragraph><p>Si va a arrancar desde CDROM tendrá que arrancar el sistema e introducir el CDROM en cuanto tenga ocasión.</p></div><div class=paragraph><p>Si su sistema arranca normalmente y carga el sistema operativo que ya está instalado puede ocurrir alguna de estas cosas:
.. Los discos no se introdujeron lo suficientemente pronto en el proceso de arranque. Déjelos insertados y reinicie su sistema.
.. Los cambios que hizo en la BIOS no han funcionado. Debería repetir los pasos previos hasta que dé con la opción correcta.
.. Su BIOS en concreto no admite el arranque el arranque desde el medio que ha elegido.</p></div></li><li><p>FreeBSD comenzará a arrancar. Si está arrancando desde CDROM debería ver algo parecido a esto (se ha omitido la información de número de versión):</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Verifying DMI Pool Data ........
Boot from ATAPI CD-ROM :
 1. FD 2.88MB  System Type-<span class=o>(</span>00<span class=o>)</span>
Uncompressing ... <span class=k>done

</span>BTX loader 1.00 BTX version is 1.01
Console: internal video/keyboard
BIOS drive A: is disk0
BIOS drive B: is disk1
BIOS drive C: is disk2
BIOS drive D: is disk3
BIOS 639kB/261120kB available memory

FreeBSD/i386 bootstrap loader, Revision 0.8

/kernel <span class=nv>text</span><span class=o>=</span>0x277391 <span class=nv>data</span><span class=o>=</span>0x3268c+0x332a8 |

|
Hit <span class=o>[</span>Enter] to boot immediately, or any other key <span class=k>for </span><span class=nb>command </span>prompt.
Booting <span class=o>[</span>kernel] <span class=k>in </span>9 seconds... _</code></pre></div></div><div class=paragraph><p>Si arranca desde floppy verá algo parecido a esto (se ha omitido la información de número de versión):</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Verifying DMI Pool Data ........

BTX loader 1.00  BTX version is 1.01
Console: internal video/keyboard
BIOS drive A: is disk0
BIOS drive C: is disk1
BIOS 639kB/261120kB available memory

FreeBSD/i386 bootstrap loader, Revision 0.8

/kernel <span class=nv>text</span><span class=o>=</span>0x277391 <span class=nv>data</span><span class=o>=</span>0x3268c+0x332a8 |

Please insert MFS root floppy and press enter:</code></pre></div></div><div class=paragraph><p>Siga las instrucciones y extraiga el disco <span class=filename>kern.flp</span> disc, inserte el disco <span class=filename>mfsroot.flp</span> y pulse <kbd>Intro</kbd>.</p></div></li><li><p>Tanto si arranca desde disquete como CDROM el proceso de arranque llegará a este punto:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Hit <span class=o>[</span>Enter] to boot immediately, or any other key <span class=k>for </span><span class=nb>command </span>prompt.
Booting <span class=o>[</span>kernel] <span class=k>in </span>9 seconds... _</code></pre></div></div><div class=paragraph><p>Dicho y hecho: espere diez segundos o pulse <kbd>Enter</kbd>. Esto lanzará el menú de configuración del kernel.</p></div></li></ol></div></div></div></div><div class=sect4><h5 id=_arranque_en_alpha>2.4.1.2. Arranque en Alpha<a class=anchor href=#_arranque_en_alpha></a></h5><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Comience con su sistema apagado.</p></li><li><p>Encienda su computadora y espera un mensaje de arranque en el monitor.</p></li><li><p>Si va a arrancar desde disquetes, tal y como se describe en la <a href=#install-floppies>Preparación del medio de arranque</a>, uno de ellos será el primer disco de arranque, probablemente el que contiene <span class=filename>kern.flp</span>. Ponga este disco en la unidad de disquetes y escriba el siguiente comando para lanzar el arranque desde el disco (corrija el nombre de su unidad de disquetes si fuera necesario):</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=o>&gt;&gt;&gt;</span>BOOT DVA0 <span class=nt>-FLAGS</span> <span class=s1>&#39;&#39;</span> <span class=nt>-FILE</span> <span class=s1>&#39;&#39;</span></code></pre></div></div><div class=paragraph><p>Si va a arrancar desde CDROM introduzca el CDROM en la unidad y escriba el siguiente comando para iniciar la instalación (corrija el nombre de la unidad correcta de CDROM si fuera necesario):</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=o>&gt;&gt;&gt;</span>BOOT DKA0 <span class=nt>-FLAGS</span> <span class=s1>&#39;&#39;</span> <span class=nt>-FILE</span> <span class=s1>&#39;&#39;</span></code></pre></div></div></li><li><p>FreeBSD comenzará a arrancar. Si está arrancando desde disquete llegado un cierto punto verá usted este mensaje:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Please insert MFS root floppy and press enter:</code></pre></div></div><div class=paragraph><p>Siga las instrucciones del programa de instalación y retire el disco <span class=filename>kern.flp</span>, inserte el disco <span class=filename>mfsroot.flp</span> y pulse <kbd>Intro</kbd>.</p></div></li><li><p>Tanto si arrancó desde disquete como desde CDROM el proceso de arranque llegará a este punto:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Hit <span class=o>[</span>Enter] to boot immediately, or any other key <span class=k>for </span><span class=nb>command </span>prompt.
Booting <span class=o>[</span>kernel] <span class=k>in </span>9 seconds... _</code></pre></div></div><div class=paragraph><p>Dicho y hecho: Espere diez segundos o pulse <kbd>Enter</kbd>. Esto iniciará el menú de configuración del kernel.</p></div></li></ol></div></div></div></div><div class=sect4><h5 id=_arranque_en_sparc64>2.4.1.3. Arranque en sparc64<a class=anchor href=#_arranque_en_sparc64></a></h5><div class=paragraph><p>La mayoría de sistemas sparc64 están configurados para arrancar automáticamente desde disco. Si quiere instalar FreeBSD tendrá que arrancar por red o desde un CDROM, lo que requiere que acceda a la PROM (OpenFirmware).</p></div><div class=paragraph><p>Reinicie el sistema y espere hasta que aparezca el mensaje de arranque. Depende del modelo, pero debería parecerse a este:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Sun Blade 100 <span class=o>(</span>UltraSPARC-IIe<span class=o>)</span>, Keyboard Present
Copyright 1998-2001 Sun Microsystems, Inc.  All rights reserved.
OpenBoot 4.2, 128 MB memory installed, Serial <span class=c>#51090132.</span>
Ethernet address 0:3:ba:b:92:d4, Host ID: 830b92d4.</code></pre></div></div><div class=paragraph><p>Si en este punto su sistema arranca desde el disco pulse <span class=keyseq><kbd>L1</kbd>+<kbd>A</kbd></span> o <span class=keyseq><kbd>Stop</kbd>+<kbd>A</kbd></span>, o envíe un <code>BREAK</code> desde la consola serie serial console (usando, por ejemplo, <code>~#</code> en <a href="https://man.freebsd.org/cgi/man.cgi?query=tip&amp;sektion=1&amp;format=html">tip(1)</a> o <a href="https://man.freebsd.org/cgi/man.cgi?query=cu&amp;sektion=1&amp;format=html">cu(1)</a>) para así recuperar el prompt de PROM. Tiene este aspecto:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>ok     <i class=conum data-value=1></i><b>(1)</b>
ok <span class=o>{</span>0<span class=o>}</span> <i class=conum data-value=2></i><b>(2)</b></code></pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>Este es el prompt que verá en sistemas con una sola CPU.</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td>Este prompt se usa en sistemas SMP; el dígito indica el número de la CPU activa.</td></tr></tbody></table></div><div class=paragraph><p>Ponga el CDROM dentro de la unidad y teclée <code>boot cdrom</code> en el prompt de la PROM.</p></div></div></div><div class=sect3><h4 id=view-probe>2.4.2. Revisión de los resultados de la prueba de dispositivos<a class=anchor href=#view-probe></a></h4><div class=paragraph><p>Es posible revisar los últimos cientos de líneas que se han mostrado en pantalla, pues se almacenan en un búfer con ese propósito.</p></div><div class=paragraph><p>Pulse <kbd>Bloq Despl</kbd> (<kbd>Scroll Lock</kbd>) y ya puede revisar el búfer. Para moverse use las flechas o <kbd>RePág</kbd> y <kbd>AvPág</kbd> (<kbd>PageUp</kbd> y <kbd>PageDown</kbd> respectivamente). Pulse de nuevo <kbd>Bloq Despl</kbd> (<kbd>Scroll Lock</kbd>) cuando quiera salir del búfer.</p></div><div class=paragraph><p>Pruébelo, revise el texto que ha generado el kernel al probar los dispositivos del sistema. Verá un texto muy similar al de la <a href=#install-dev-probe>Ejemplo de resultado de prueba de dispositivos</a>, aunque en su caso concreto se mostrarán los dispositivos que tenga su sistema.</p></div><div id=install-dev-probe class=exampleblock><div class=title>Ejemplo 3. Ejemplo de resultado de prueba de dispositivos</div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>avail memory <span class=o>=</span> 253050880 <span class=o>(</span>247120K bytes<span class=o>)</span>
Preloaded elf kernel <span class=s2>&#34;kernel&#34;</span> at 0xc0817000.
Preloaded mfs_root <span class=s2>&#34;/mfsroot&#34;</span> at 0xc0817084.
md0: Preloaded image &lt;/mfsroot&gt; 4423680 bytes at 0xc03ddcd4

md1: Malloc disk
Using <span class=nv>$PIR</span> table, 4 entries at 0xc00fde60
npx0: &lt;math processor&gt; on motherboard
npx0: INT 16 interface
pcib0: &lt;Host to PCI bridge&gt; on motherboard
pci0: &lt;PCI bus&gt; on pcib0
pcib1:&lt;VIA 82C598MVP <span class=o>(</span>Apollo MVP3<span class=o>)</span> PCI-PCI <span class=o>(</span>AGP<span class=o>)</span> bridge&gt; at device 1.0 on pci0
pci1: &lt;PCI bus&gt; on pcib1
pci1: &lt;Matrox MGA G200 AGP graphics accelerator&gt; at 0.0 irq 11
isab0: &lt;VIA 82C586 PCI-ISA bridge&gt; at device 7.0 on pci0
isa0: &lt;iSA bus&gt; on isab0
atapci0: &lt;VIA 82C586 ATA33 controller&gt; port 0xe000-0xe00f at device 7.1 on pci0
ata0: at 0x1f0 irq 14 on atapci0
ata1: at 0x170 irq 15 on atapci0
uhci0 &lt;VIA 83C572 USB controller&gt; port 0xe400-0xe41f irq 10 at device 7.2 on pci
0
usb0: &lt;VIA 83572 USB controller&gt; on uhci0
usb0: USB revision 1.0
uhub0: VIA UHCI root hub, class 9/0, rev 1.00/1.00, addr1
uhub0: 2 ports with 2 removable, self powered
pci0: &lt;unknown card&gt; <span class=o>(</span><span class=nv>vendor</span><span class=o>=</span>0x1106, <span class=nv>dev</span><span class=o>=</span>0x3040<span class=o>)</span> at 7.3
dc0: &lt;ADMtek AN985 10/100BaseTX&gt; port 0xe800-0xe8ff mem 0xdb000000-0xeb0003ff ir
q 11 at device 8.0 on pci0
dc0: Ethernet address: 00:04:5a:74:6b:b5
miibus0: &lt;MII bus&gt; on dc0
ukphy0: &lt;Generic IEEE 802.3u media interface&gt; on miibus0
ukphy0: 10baseT, 10baseT-FDX, 100baseTX, 100baseTX-FDX, auto
ed0: &lt;NE2000 PCI Ethernet <span class=o>(</span>RealTek 8029<span class=o>)&gt;</span> port 0xec00-0xec1f irq 9 at device 10.
0 on pci0
ed0 address 52:54:05:de:73:1b, <span class=nb>type </span>NE2000 <span class=o>(</span>16 bit<span class=o>)</span>
isa0: too many dependant configs <span class=o>(</span>8<span class=o>)</span>
isa0: unexpected small tag 14
orm0: &lt;Option ROM&gt; at iomem 0xc0000-0xc7fff on isa0
fdc0: &lt;NEC 72065B or clone&gt; at port 0x3f0-0x3f5,0x3f7 irq 6 drq2 on isa0
fdc0: FIFO enabled, 8 bytes threshold
fd0: &lt;1440-KB 3.5” drive&gt; on fdc0 drive 0
atkbdc0: &lt;Keyboard controller <span class=o>(</span>i8042<span class=o>)&gt;</span> at port 0x60,0x64 on isa0
atkbd0: &lt;AT Keyboard&gt; flags 0x1 irq1 on atkbdc0
kbd0 at atkbd0
psm0: &lt;PS/2 Mouse&gt; irq 12 on atkbdc0
psm0: model Generic PS/@ mouse, device ID 0
vga0: &lt;Generic ISA VGA&gt; at port 0x3c0-0x3df iomem 0xa0000-0xbffff on isa0
sc0: &lt;System console&gt; at flags 0x100 on isa0
sc0: VGA &lt;16 virtual consoles, <span class=nv>flags</span><span class=o>=</span>0x300&gt;
sio0 at port 0x3f8-0x3ff irq 4 flags 0x10 on isa0
sio0: <span class=nb>type </span>16550A
sio1 at port 0x2f8-0x2ff irq 3 on isa0
sio1: <span class=nb>type </span>16550A
ppc0: &lt;Parallel port&gt; at port 0x378-0x37f irq 7 on isa0
pppc0: SMC-like chipset <span class=o>(</span>ECP/EPP/PS2/NIBBLE<span class=o>)</span> <span class=k>in </span>COMPATIBLE mode
ppc0: FIFO with 16/16/15 bytes threshold
plip0: &lt;PLIP network interface&gt; on ppbus0
ad0: 8063MB &lt;IBM-DHEA-38451&gt; <span class=o>[</span>16383/16/63] at ata0-master UDMA33
acd0: CD-RW &lt;LITE-ON LTR-1210B&gt; at ata1-slave PIO4
Mounting root from ufs:/dev/md0c
/stand/sysinstall running as init on vty0</code></pre></div></div></div></div><div class=paragraph><p>Compruebe cuidadosamente que FreeBSD haya encontrado todos los dispositivos que debe encontrar. Si no se lista algún dispositivo significa que FreeBSD no lo ha encontrado. Un <a href=./#kernelconfig>kernel personalizado</a> le permitirá agregar al sistema el soporte de dispositivos que no aparecen en el kernel <span class=filename>GENERIC</span>, que suele ser el caso de algunas tarjetas de sonido.</p></div><div class=paragraph><p>En FreeBSD 6.2 y versiones siguientes verá tras la prueba de dispositivos verá lo que muestra la <a href=#config-country>Menú de selección de país</a>. Utilice las flechas del teclado para elegir país, región o grupo. Cuando acabe pulse <kbd>Intro</kbd>, con lo que habrá elegido país y esquema de teclado. En cualquier momento puede salir de easily. It is also easy to exit the sysinstall y volver a empezar.</p></div><div id=config-country class=imageblock><div class=content><img src=../../../../images/books/handbook/install/config-country.png alt="config country"></div><div class=title>Figura 1. Menú de selección de país</div></div><div id=sysinstall-exit class=imageblock><div class=content><img src=../../../../images/books/handbook/install/sysinstall-exit.png alt="sysinstall exit"></div><div class=title>Figura 2. Salir de Sysinstall</div></div><div class=paragraph><p>Para salir de sysinstall utilice las flechas del teclado para seleccionar <span class=guimenuitem>Exit Install</span> en el menú de la pantalla principal de instalación. Aparecerá el siguiente mensaje:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>                      User Confirmation Requested
         Are you sure you wish to <span class=nb>exit</span>? The system will reboot
           <span class=o>(</span>be sure to remove any floppies/CDs/DVDs from the drives<span class=o>)</span><span class=nb>.</span>

                            <span class=o>[</span> Yes <span class=o>]</span>    No</code></pre></div></div><div class=paragraph><p>Si pulsa <b class=button>yes</b> y no retira el CDROM durante el reinicio el programa de instalación comenzará de nuevo.</p></div><div class=paragraph><p>Si está arrancando desde disquetes tendrá que retirar el floppy <span class=filename>boot.flp</span> antes de reiniciar.</p></div></div></div><div class=sect2><h3 id=using-sysinstall>2.5. ¿Qué es sysinstall?<a class=anchor href=#using-sysinstall></a></h3><div class=paragraph><p>sysinstall es la aplicación que el Proyecto FreeBSD creó para la instalación del sistema. Está orientada a consola y consta de diversos menús y pantallas que podrá usar para configurar y ejecutar el proceso de instalación.</p></div><div class=paragraph><p>El sistema de menús de sysinstall se controla mediante las flechas del teclado, <kbd>Intro</kbd>,el <kbd>tabulador</kbd>), <kbd>Espacio</kbd> y otras teclas. Tiene una descripción detallada de todas esas teclas y qué es lo que hacen en la información de uso de sysinstall.</p></div><div class=paragraph><p>Si quiere consultarla seleccione <span class=guimenuitem>Usage</span> y asegúrese de que el botón <b class=button>Select</b> esté seleccionado (como se ven en la <a href=#sysinstall-main3>Selección de «Usage» en el menú principal de sysinstall</a>) y pulse <kbd>Intro</kbd>.</p></div><div class=paragraph><p>Aparecerán las instrucciones de uso del sistema de menús. Una vez revisadas pulse <kbd>Enter</kbd> y volverá al menú principal.</p></div><div id=sysinstall-main3 class=imageblock><div class=content><img src=../../../../images/books/handbook/install/main1.png alt=main1></div><div class=title>Figura 3. Selección de «Usage» en el menú principal de sysinstall</div></div><div class=sect3><h4 id=select-doc>2.5.1. Selección del menú de documentación<a class=anchor href=#select-doc></a></h4><div class=paragraph><p>Una vez en el menú principal seleccione <span class=guimenuitem>Doc</span> con las flechas del teclado y pulse <kbd>Enter</kbd>.</p></div><div id=main-doc class=imageblock><div class=content><img src=../../../../images/books/handbook/install/main-doc.png alt="main doc"></div><div class=title>Figura 4. Selección del menú de documentación</div></div><div class=paragraph><p>Esto mostrará el menú de documentación.</p></div><div id=docmenu1 class=imageblock><div class=content><img src=../../../../images/books/handbook/install/docmenu1.png alt=docmenu1></div><div class=title>Figura 5. El menú de documentación de sysinstall</div></div><div class=paragraph><p>Es muy importante qeu lea la documentación de sysinstall.</p></div><div class=paragraph><p>Si quiere consultar un documento seleccionelo con las flechas y pulse <kbd>Intro</kbd>. Cuando acabe pulse de nuevo <kbd>Intro</kbd> y volverá al menú de documentación.</p></div><div class=paragraph><p>Si desea regresar al menú principal de la instalación seleccione <span class=guimenuitem>Exit</span> con las flechas y pulse <kbd>Intro</kbd>.</p></div></div><div class=sect3><h4 id=keymap>2.5.2. Selección del menú de esquemas de teclado<a class=anchor href=#keymap></a></h4><div class=paragraph><p>Si quiere cambiar el esquema de teclado seleccione el que <span class=guimenuitem>Keymap</span> y pulse <kbd>Enter</kbd>. Tendrá que hacer esto si su teclado no es el estándar en los EEUU.</p></div><div id=sysinstall-keymap class=imageblock><div class=content><img src=../../../../images/books/handbook/install/main-keymap.png alt="main keymap"></div><div class=title>Figura 6. Menú principal de sysinstall</div></div><div class=paragraph><p>La selección de un esquema de teclado se hace del siguiente modo: seleccione uno de la lista mediante las flechas arriba/abajo y pulse <kbd>Espacio</kbd>. Si pulsa <kbd>Espacio</kbd> otra vez anulará la selección. Una vez que tenga clara su elección use las flechas para seleccionar <b class=button>OK</b> y pulse <kbd>Intro</kbd>.</p></div><div class=paragraph><p>En esta pantalla solamente se muestra una parte de la lista. Seleccione <b class=button>Cancel</b> usando el <kbd>tabulador</kbd> si ha decido seguir usando el esquema de teclado por omisión y regresar al menú principal de instalación.</p></div><div id=sysinstall-keymap-menu class=imageblock><div class=content><img src=../../../../images/books/handbook/install/keymap.png alt=keymap></div><div class=title>Figura 7. Menú de esquemas de teclado de sysinstall</div></div></div><div class=sect3><h4 id=viewsetoptions>2.5.3. Pantalla de opciones de instalación<a class=anchor href=#viewsetoptions></a></h4><div class=paragraph><p>Seleccione <span class=guimenuitem>Options</span> y pulse <kbd>Intro</kbd>.</p></div><div id=sysinstall-options class=imageblock><div class=content><img src=../../../../images/books/handbook/install/main-options.png alt="main options"></div><div class=title>Figura 8. Menú principal de sysinstall</div></div><div id=options class=imageblock><div class=content><img src=../../../../images/books/handbook/install/options.png alt=options></div><div class=title>Figura 9. Opciones de sysinstall</div></div><div class=paragraph><p>Los valores por omisión deberían bastar para la mayoría de usuarios. El número de «release» variará según sea la versión que se está instalando.</p></div><div class=paragraph><p>La descripción del elemento seleccionado aparecerá resaltada en azul en la parte baja de la pantalla. Observe que una de las opciones es <span class=guimenuitem>Use Defaults</span>, que devuelve todos los valores a los asignados por omisión al principio del proceso de instalación.</p></div><div class=paragraph><p>Si pulsa <kbd>F1</kbd> podrá leer la pantalla de ayuda de las diversas opciones.</p></div><div class=paragraph><p>Si pulsa <kbd>Q</kbd> volverá al menú principal de la instalación.</p></div></div><div class=sect3><h4 id=start-install>2.5.4. Comenzar una instalación estándar<a class=anchor href=#start-install></a></h4><div class=paragraph><p>La instalación estándar (<span class=guimenuitem>Standard</span>) es la opción más adecuada para aquellas personas con poca o ninguna experiencia con UNIX® o FreeBSD. Utilice las flechas para seleccionar <span class=guimenuitem>Standard</span> y pulse <kbd>Intro</kbd>; a partir de ahí comenzará la instalación.</p></div><div id=sysinstall-standard class=imageblock><div class=content><img src=../../../../images/books/handbook/install/main-std.png alt="main std"></div><div class=title>Figura 10. Comenzar una instalación estándar</div></div></div></div><div class=sect2><h3 id=install-steps>2.6. Asignación de espacio en disco<a class=anchor href=#install-steps></a></h3><div class=paragraph><p>Lo primero que tiene que hacer es asignar espacio en disco a FreeBSD para que sysinstall lo pueda dejar listo para su uso. Para ello debe saber cómo espera FreeBSD encontrar la información en el disco.</p></div><div class=sect3><h4 id=install-drive-bios-numbering>2.6.1. Numeración de unidades desde el punto de vista de la BIOS<a class=anchor href=#install-drive-bios-numbering></a></h4><div class=paragraph><p>Antes de instalar y configurar FreeBSD en su sistema hay una cosa más de la que ocuparse, especialmente si tiene más de un disco duro.</p></div><div class=paragraph><p>La BIOS es capz de abstraer el orden normal de los discos si hablamos de un PC en el que se está ejecutando un sistema operativo "BIOS-dependiente" como MS-DOS® o Microsoft® Windows®, que admiten esos cambios sin problemas. Tal cosa permite al usuario arrancar desde un disco duro distinto del llamado «maestro principal». Esto viene muy bien a los usuarios que tienen el «backup» del sistema más barato que existe, comprar un disco duro idéntico al primero y copiar periódicamente la primera unidad en la segunda mediante Ghost o XCOPY. De este modo si la primera unidad falla, sufre el ataque de un virus o sufre las consecuencias de un fallo del sistema operativo sólo hay que decirle a la BIOS que interpole lógicamente las unidades. Es como intercambiar las conexiones de los discos sin tener que abrir la caja del sistema.</p></div><div class=paragraph><p>en sistemas más caros a veces pueden encontrarse controladoras SCSI que incorporan extensiones BIOS, que permiten organizar hasta siete unidades SCSI de un modo muy similar.</p></div><div class=paragraph><p>Cualquiera que esté acostumbrado a usar las técnicas descritas se llevará una sorpresa al intentar usarlas en FreeBSD. FreeBSD no usa la BIOS y no tiene en cuenta en absoluto la «notación de unidades lógicas desde el punto de vista de la BIOS». Esto puede dar lugar a situaciones bastante chocantes, especialmente cuando las unidades son físicamente idénticas en geometría y han sido creadas como clones de datos la una de la otra.</p></div><div class=paragraph><p>Si va a usar FreeBSD recuerde siempre devolver a la BIOS a los valores de numeración «natural» antes de la instalación y dejarlos así. Si tiene que intercambiar unidades hágalo, pero a la vieja usanza: abra la caja, toque los «jumpers» y los cables todo lo que sea menester.</p></div><div class=sidebarblock><div class=content><div class=paragraph><p>Pedro decide dedicar una vieja máquina «Wintel» para prepararle un sistema FreeBSD a Pablo. Pedro le instala una sola unidad SCSI como «unidad SCSI 0» e instala FreeBSD en ella.</p></div><div class=paragraph><p>Pablo comienza a usar el sistema pero a los pocos dias advierte que esa vieja unidad SCSI está mostrando numerosos errores lógicos, así que informa del hecho a Pedro.</p></div><div class=paragraph><p>Dias después Pedro decide solucionar el problema; consigue un disco idéntico al que instaló a Pablo. Le pasa un chequeo de superficie que da resultados satisfactorios, así que instala este disco como «unidad SCSI 4» y hace una copia binaria de la unidad 0 (el primer disco) a la recién instalada unidad 4. Una vez que el nuevo disco está instalado Pedro decide que hay que empezar a usarlo, así que configura la BIOS SCSI para reorganizar las unidades de disco para que el sistema arranque desde la unidad SCSI 4. FreeBSD arranca desde dicha unidad y todo funciona perfectamente.</p></div><div class=paragraph><p>Pablo sigue trabajando varios dias y no pasa mucho tiempo antes de que Pedro y Pablo decidan que ya es hora de meterse en una nueva aventura: actualizarse a la nueva versín de FreeBSD. Bill retira la unidad SCSI 0 de la máquina porque le parece poco de fiar y la reemplaza por un disco que obtiene de su en apariencia inagotable trastero. Pedro instala la última versión de FreeBSD en la nueva unidad SCSI mediante los disquetes FTP mágicos que Pablo ha bajado de Internet. La instalación se ejecuta sin problemas.</p></div><div class=paragraph><p>Pablo utiliza la nueva versión de FreeBSD durante unos dias y comprueba que en efecto es lo bastante buena como para usarla en el departamento de ingeniería. Ha llegado, por tanto, el momento de copiar los datos que tiene en la versión anterior de FreeBSD a su nuevo alojamiento. Pablo monta la unidad SCSI 4 (la última que instaló con la versión anterior de FreeBSD). Pablo queda consternado al comprobar que en la unidad SCSI 4 no hay ni rastro de sus preciados datos.</p></div><div class=paragraph><p>¿Dónde están los datos?</p></div><div class=paragraph><p>Cuando Pedro hizo la copia binaria de la unidad SCSI 0 en la unidad SCSI 4, la unidad se convirtió en el «el nuevo clon». Cuando Pedro reconfiguró la BIOS SCSI para poder arrancar desde la unidad SCSI 4 tan sólo estaba engañándose a sí mismo puesto que FreeBSD seguía arrancando desde la unidad SCSI 0. Al hacer tal cambio en la BIOS causamos que parte del código de arranque y del cargador del sistema se copie de una a otra unidad pero en cuanto los controladores del kernel de FreeBSD toman el control de la situación el esquema de nomenclatura de unidades de la BIOS es desestimado y FreeBSD recupera el esquema normal de nomenclatura. En nuestro ejemplo el sistema sigue funcionando desde la unidad SCSI 0 y ahí están todos los datos de Pablo, no en la unidad SCSI 4. El hecho de que pareciera que el sistema estaba funcionando en la unidad SCSI 4 era un producto de la imaginación humana.</p></div><div class=paragraph><p>Estamos encantados de decir que ni un solo byte fue herido o maltratado durante el descubrimiento de este fenómeno. La vieja unidad SCSI 0 fué recuperada del montón de discos caídos en acto de servicio y fue posible devolver todo el trabajo de Pablo a su legítimo dueño. Por si fuera poco, ahora Pedro sabe con certeza que es capaz de contar hasta cero.</p></div><div class=paragraph><p>En el ejemplo se han usado unidades SCSI pero los conceptos pueden aplicarse perfectamente a unidades IDE.</p></div></div></div></div><div class=sect3><h4 id=main-fdisk>2.6.2. Creación de «slices» con FDisk<a class=anchor href=#main-fdisk></a></h4><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Aún no ha hecho modificaciones en su disco duro. Si cree que ha cometido algún error y quiere comenzar de nuevo puede hacerlo, salga de los menús de sysinstall e inténtelo de nuevo o pulse <kbd>U</kbd> para ejecutar la opción <span class=guimenuitem>Undo</span> (deshacer). Si se pierde o no sabe cómo salir siempre puede apagar su sistema.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Si ha elegido iniciar una instalación estándar sysinstall le mostrará el siguiente mensaje:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>                                 Message
 In the next menu, you will need to <span class=nb>set </span>up a DOS-style <span class=o>(</span><span class=s2>&#34;fdisk&#34;</span><span class=o>)</span>
 partitioning scheme <span class=k>for </span>your hard disk. If you simply wish to devote
 all disk space to FreeBSD <span class=o>(</span>overwriting anything <span class=k>else </span>that might be on
 the disk<span class=o>(</span>s<span class=o>)</span> selected<span class=o>)</span> <span class=k>then </span>use the <span class=o>(</span>A<span class=o>)</span>ll <span class=nb>command </span>to <span class=k>select </span>the default
 partitioning scheme followed by a <span class=o>(</span>Q<span class=o>)</span>uit. If you wish to allocate only
 free space to FreeBSD, move to a partition marked <span class=s2>&#34;unused&#34;</span> and use the
 <span class=o>(</span>C<span class=o>)</span>reate command.
                                <span class=o>[</span>  OK  <span class=o>]</span>

                      <span class=o>[</span> Press enter or space <span class=o>]</span></code></pre></div></div><div class=paragraph><p>Es decir:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>                                 Mensaje
 En el siguiente menú tendrá que configurar un esquema de particionado
 estilo DOS <span class=o>(</span><span class=s2>&#34;fdisk&#34;</span><span class=o>)</span> en su disco duro.  Si quiere dedicar todo el
 espacio de disco a FreeBSD <span class=o>(</span>cosa que sobreescribirá cualquier cosa
 que contuviera el/los disco/s<span class=o>)</span> use el comando <span class=o>(</span>A<span class=o>)</span>ll <span class=o>(</span>Todo<span class=o>)</span> para
 seleccionar el esquema de particiones por defecto y luego pulse
 <span class=o>(</span>Q<span class=o>)</span>uit <span class=o>(</span>Salir<span class=o>)</span><span class=nb>.</span>  Si quiere asignar a FreeBSD sólamente el espacio
 libre en la unidad elija una partición que figure marcada como
 <span class=s2>&#34;unused&#34;</span> <span class=o>(</span>sin usar<span class=o>)</span> y ejecute el comando <span class=o>(</span>C<span class=o>)</span>reate <span class=o>(</span>Crear<span class=o>)</span><span class=nb>.</span>
                                <span class=o>[</span>  OK  <span class=o>]</span>

                      <span class=o>[</span> Pulse Intro o Espacio <span class=o>]</span></code></pre></div></div><div class=paragraph><p>Pulse <kbd>Intro</kbd> tal y como se le dice. Se le mostrará una lista con todas las unidades de disco duro que el kernel ha econtrado al hacer el chequeo del sistema. La <a href=#sysinstall-fdisk-drive1>Elija en qué unidad usar FDisk</a> muestra un ejemplo de un sistema con dos discos IDE. Reciben los nombres de <span class=filename>ad0</span> y <span class=filename>ad2</span>.</p></div><div id=sysinstall-fdisk-drive1 class=imageblock><div class=content><img src=../../../../images/books/handbook/install/fdisk-drive1.png alt="fdisk drive1"></div><div class=title>Figura 11. Elija en qué unidad usar FDisk</div></div><div class=paragraph><p>Quizás esté preguntandose por qué <span class=filename>ad1</span> no aparece por ningún lado. ?Acaso hemos pasado algo por alto?</p></div><div class=paragraph><p>Veamos qué ocurriría si tuviera usted dos discos duros IDE, uno como maestro de la primera controladora IDE y el otro como maestro en la segunda controladora IDE. Si FreeBSD asignara números de unidad en el orden en el que las encuentra en el ejemplo habríamos visto <span class=filename>ad0</span> y <span class=filename>ad1</span> y todo funcionaría sin mayor problema.</p></div><div class=paragraph><p>Pero si tuviera usted que añadir un tercer disco, digamos como esclavo de la primera controladora IDE, tendría que llamarse <span class=filename>ad1</span> y el disco que antes era <span class=filename>ad1</span> pasaría a llamarse <span class=filename>ad2</span>. Los nombres de dispositivo (como por ejemplo <span class=filename>ad1s1a</span>) se usan para ubicar sistemas de ficheros, así que podría encontrarse con que alguno de sus sistemas de ficheros no está donde debiera y tendría que modificar la configuración de su FreeBSD.</p></div><div class=paragraph><p>Para evitar este problema el kernel puede configurarse para asignar nombres a discos IDE basándose en dónde están en lugar de hacerlo por el orden en el que los encuentra. Según dicho esquema el disco maestro de la segunda contoladora IDE <em>siempre</em> será <span class=filename>ad2</span>, incluso si no existen dispositivos <span class=filename>ad0</span> o <span class=filename>ad1</span>.</p></div><div class=paragraph><p>Ésta es la configuración por omisión que incorpora el kernel de FreeBSD, por lo que muestra las unidades <span class=filename>ad0</span> y <span class=filename>ad2</span>. La máquina en la que se tomaron las capturas de pantalla tiene sendos discos IDE en ambos canales maestros de las dos controladoras y carece de discos en los canales esclavos.</p></div><div class=paragraph><p>Seleccione el disco en el que desea instalar FreeBSD y pulse <b class=button>OK</b>. FDisk arrancará y le mostrará una pantalla similar a la que muestra la <a href=#sysinstall-fdisk1>Un ejemplo de particionamiento típico con FDisk</a>.</p></div><div class=paragraph><p>La pantalla de FDisk se divide en tres partes.</p></div><div class=paragraph><p>La primera parte, que ocupa las dos primeras líneas de la pantalla, muestra los detalles del disco que seleccionemos, el nombre que FreeBSD le da, la geometría del disco y el tamaño total del disco.</p></div><div class=paragraph><p>La segunda parte muestra las «slices» que haya en el disco, dónde comienzan y acaban, cuál es su tamaño, qué nombre les da FreeBSD, su descripción y subtipo. Este ejemplo muestra dos pequeñas «slices» sin usar; las «slices» (del inglés «rebanadas») son un tipo de esquema estructural de los discos de PC. También muestra una gran «slice» FAT, que casi con total seguridad aparecerá como <span class=filename>C:</span> en MS-DOS® / Windows®, y una «slice» extendida, que podría contener otras letras de unidad de MS-DOS® / Windows®.</p></div><div class=paragraph><p>La tercera parte muestra las órdenes que pueden usarse en FDisk.</p></div><div id=sysinstall-fdisk1 class=imageblock><div class=content><img src=../../../../images/books/handbook/install/fdisk-edit1.png alt="fdisk edit1"></div><div class=title>Figura 12. Un ejemplo de particionamiento típico con FDisk</div></div><div class=paragraph><p>Lo que deba hacer a partir de ahora dependerá mucho de la forma en la que quiera distribuir su disco.</p></div><div class=paragraph><p>Si desea usar FreeBSD en el resto del disco (lo que implica borrar todos los datos que pudiera haber en el disco una vez que le confirme a sysinstall que desea seguir adelante con la instalación) pulse <kbd>A</kbd>, que equivale a la opción <span class=guimenuitem>Use Entire Disk</span> (Utilizar el disco íntegro). Las «slices» que existieran se borrarán y serán reemplazadas por un pequeño área de disco marcado como <code>sin usar</code> (otro recurso de la estructura de disco de los PC) y tras él una gran «slice» destinada a FreeBSD. Ahora marque la partición FreeBSD que acaba de crear como arrancable: pulse <kbd>S</kbd>. La pantalla que verá ha de ser muy similar a la <a href=#sysinstall-fdisk2>Partición con FDisk usando el disco completo</a>. Observe la <code>A</code> en la columna <code>Flags</code>: indica que la «slice» es <em>activa</em> y se arrancará desde ella.</p></div><div class=paragraph><p>Si desea borrar una «slice» para hacer más sitio a FreeBSD selecciónela mediante las flechas y pulse <kbd>D</kbd>. Después pulse <kbd>C</kbd> y verá un mensaje en el que se le pedirá el tamaño de la «slice» que va a crear. Introduzca los datos apropiados y pulse <kbd>Intro</kbd>. El valor por defecto en ésta pantalla es el de la «slice» más grande que pueda crear en el disco, que debería ser la mayor parte del disco que queda sin usar o el tamaño del disco duro completo.</p></div><div class=paragraph><p>Si ha hecho sitio para FreeBSD (quizás con una herramienta como PartitionMagic®) puede pulsar press <kbd>C</kbd> y crear una nueva «slice». Verá de nuevo un mensaje en el que se le pedirá que escriba el tamaño de la «slice» que va a crear.</p></div><div id=sysinstall-fdisk2 class=imageblock><div class=content><img src=../../../../images/books/handbook/install/fdisk-edit2.png alt="fdisk edit2"></div><div class=title>Figura 13. Partición con FDisk usando el disco completo</div></div><div class=paragraph><p>Cuando acabe pulse <kbd>Q</kbd>. Sus cambios se guardarán en sysinstall, pero de momento no se guardarán en disco.</p></div></div><div class=sect3><h4 id=bootmgr>2.6.3. Instalación de un gestor de arranque<a class=anchor href=#bootmgr></a></h4><div class=paragraph><p>Ha llegado el momento de instalar un gestor de arranque. Elija el gestor de arranque de FreeBSD si:</p></div><div class=ulist><ul><li><p>Tiene más de un disco y ha instalado FreeBSD en cualquiera que no sea el primero.</p></li><li><p>Ha instalado FreeBSD codo con codo con otro sistema operativo y quiere poder elegir si arrancar FreeBSD o ese otro sistema operativo cuando arranque su sistema.</p></li></ul></div><div class=paragraph><p>Si FreeBSD va a ser el único sistema operativo en el sistema y va a instalarlo en el primer disco duro elija el gestor estándar (que, obviamente, está en la opción <span class=guimenuitem>Standard</span>). Elija <span class=guimenuitem>None</span> (ninguno) si va a usar algún otro gestor de arranque que sea capaz de arrancar FreeBSD.</p></div><div class=paragraph><p>Elija y pulse <kbd>Intro</kbd>.</p></div><div id=sysinstall-bootmgr class=imageblock><div class=content><img src=../../../../images/books/handbook/install/boot-mgr.png alt="boot mgr"></div><div class=title>Figura 14. Menú de gestores de arranque de sysinstall</div></div><div class=paragraph><p>La pantalla de ayuda, que puede consultar en cualquier momento pulsando <kbd>F1</kbd>, puede serle de mucha ayuda con los problemas que puede encontrarse al intentar compartir un disco duro entre varios sistemas operativos.</p></div></div><div class=sect3><h4 id=_creación_de_slices_en_otra_unidad>2.6.4. Creación de «slices» en otra unidad.<a class=anchor href=#_creación_de_slices_en_otra_unidad></a></h4><div class=paragraph><p>Si hay más de una unidad de disco el programa de instalación volverá a la pantalla «Select Drives» («selección de unidades») una vez elegido el gestor de arranque. Si quiere instalar FreeBSD en más de un disco seleccione aquí ese otro disco y repita el proceso con las «slices» mediante FDisk.</p></div><div class="admonitionblock important"><table><tbody><tr><td class=icon><i class="fa icon-important" title=Important></i></td><td class=content><div class=paragraph><p>Si va a instalar FreeBSD en una unidad que no sea la primera tendrá que instalar el gestor de arranque de FreeBSD en ambas unidades.</p></div></td></tr></tbody></table></div><div id=sysinstall-fdisk-drive2 class=imageblock><div class=content><img src=../../../../images/books/handbook/install/fdisk-drive2.png alt="fdisk drive2"></div><div class=title>Figura 15. Salir de la selección de unidad</div></div><div class=paragraph><p>El <kbd>tabulador</kbd> se usa para hacer pasar el cursor entre <b class=button>OK</b>, <b class=button>Cancel</b>.</p></div><div class=paragraph><p>Pulse <kbd>tabulador</kbd> para pasar el cursor a <b class=button>OK</b> y pulse <kbd>Enter</kbd> para proseguir con la instalación.</p></div></div><div class=sect3><h4 id=bsdlabeleditor>2.6.5. Creación de particiones con Disklabel<a class=anchor href=#bsdlabeleditor></a></h4><div class=paragraph><p>Tendrá que crear particiones dentro de las «slices» que haya creado. Recuerde que cada partición está asociada a una letra entre la <code>a</code> y la <code>h</code>y que las particiones <code>b</code>, <code>c</code> y <code>d</code> tienen significados heredados que tendrá que respetar.</p></div><div class=paragraph><p>Ciertas aplicaciones pueden optimizar su rendimiento de un esquema de particiones concreto, sobre todo si hace particiones repartidas en más de un disco. Si embargo si esta es su primera instalación de FreeBSD no necesita dedicarle demasiado tiempo a decidir cómo partir el disco duro. Es mucho más importante que instale FreeBSD y empiece a aprender a usarlo. Siempre estáa tiempo de reinstalar FreeBSD y cambiar su esquema de particiones cuando esté más familiarizado con el sistema operativo.</p></div><div class=paragraph><p>El siguiente esquema consta de cuatro particiones: una para la swap y tres para los sistemas de ficheros.</p></div><table class="tableblock frame-none grid-all stretch"><caption class=title>Tabla 2. Estructura de particiones del primer disco</caption><col style=width:10%><col style=width:10%><col style=width:10%><col style=width:70%><thead><tr><th class="tableblock halign-left valign-top">Partición</th><th class="tableblock halign-left valign-top">Sistema de ficheros</th><th class="tableblock halign-left valign-top">Tamaño</th><th class="tableblock halign-left valign-top">Descripción</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>a</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>512 MB</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Este es el sistema de ficheros raíz. el resto de sistemas de ficheros se montarán en algún punto de este sistema raíz. 100 MB es un tamaño razonable para él. No es el mejor sitio para almacenar muchos datos y la instalación de FreeBSD escribirá cerca de 40 MB de datos en ella. El resto del espacio es para datos temporales y por si futuras versiones de FreeBSD necesitan más espacio en <span class=filename>/</span>.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>b</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>N/A</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>2-3 x RAM</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Esta partición es el espacio de memoria de intercambio (o «swap») del sistema. La elección de la cantidad correcta de swap es casi un arte en sí mismo. Hay una regla básica que es asignar a la swap el doble o el triple de MB de los que haya en la memoria física (RAM) del sistema. Debería tener al menos 64 MB de swap así que si tiene menos de 32 MB de RAM asígnele a su swap 64 MB.</p><p class=tableblock>Si tiene más de un disco puede poner espacio swap en cada disco. FreeBSD usará ambas swap con el resultado de acelerar notablemente el intercambio de páginas de memoria. Calcule el total de swap que necesita (por ejemplo 128 MB) y divida esa cantidad por el número de discos que tenga (por ejemplo dos) y ya tiene la cantidad de espacio que debe destinar a swap en cada uno de sus discos. En nuestro ejemplo 64 MB de swap por disco.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>e</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/var</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>256 MB to 1024 MB</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>El directorio <span class=filename>/var</span> contiene ficheros que están en continuo cambio, como «logs» y otros ficheros administrativos. Muchos de esos ficheros son una consecuencia o son de gran ayuda para el correcto funcionamiento diario de FreeBSD. FreeBSD ubica dichos ficheros en ese sistema de ficheros para optimizar el acceso a los mismos sin afectar a otros ficheros ni directorios que tienen similar patrón de accesos.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>f</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Resto del disco(al menos 2 GB)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>El resto de sus ficheros pueden almacenarse en <span class=filename>/usr</span> y sus subdirectorios.</p></td></tr></tbody></table><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Los valores que se han mostrado son simples ejemplos y se recomienda su uso exclusivamente a usuarios experimentados. Recomendamos a los usuarios que utilicen la opción <code>Auto Defaults</code>, que elegirá unas proporciones adecuadas para el espacio que encuentre disponible.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Si va a instalar FreeBSD en más de un disco puede crear particiones el las demás «slices» que haya creado. La forma más fácil de hacerlo es creando dos particiones en cada disco, una para la swap y la otra para los sistemas de ficheros.</p></div><table class="tableblock frame-none grid-all stretch"><caption class=title>Tabla 3. Esquema de particiones para varios discos</caption><col style=width:10%><col style=width:10%><col style=width:10%><col style=width:70%><thead><tr><th class="tableblock halign-left valign-top">Partición</th><th class="tableblock halign-left valign-top">Sistema de ficheros</th><th class="tableblock halign-left valign-top">Tamaño</th><th class="tableblock halign-left valign-top">Descripción</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>b</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>N/A</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Ver descripción</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Tal y como se ha explicado puede repartir su espacio swap entre varios discos. Aunque piense que la partición <code>a</code> está libre la costumbre (y se dice que «las costumbres son leyes» dicta que el espacio swap reside en la partición <code>b</code>.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>e</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>/disco<em>n</em></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Resto del disco</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>El resto del disco puede dejarse en una sola partición. Esto podría ubicarse simplemente en la partición <code>a</code> en lugar de en la <code>e</code>. Sin embargo la costumbre dice que la partición <code>a</code> de una «slice» está reservada para el sistema de ficheros que ha de albergar el sistema de ficheros raíz (<span class=filename>/</span>). No tiene por qué seguir la costumbre pero tenga en cuenta que sysinstall sí que lo hace, así que si la sigue sabe que está haciendo una instalación más limpia. Puede montar los sistemas de ficheros donde prefiera; este ejemplo le sugiere que los monte como directorios <span class=filename>/discon</span>, donde <em>n</em> es un número que cambia en cada disco. Por supuesto que puede usar el esquema que prefiera.</p></td></tr></tbody></table><div class=paragraph><p>Una vez que haya elegido el esquema de particiones creelo en sysinstall. Verá este mensaje:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>                                 Message
 Now, you need to create BSD partitions inside of the fdisk
 partition<span class=o>(</span>s<span class=o>)</span> just created. If you have a reasonable amount of disk
 space <span class=o>(</span>200MB or more<span class=o>)</span> and don<span class=s1>&#39;t have any special requirements, simply
 use the (A)uto command to allocate space automatically. If you have
 more specific needs or just don&#39;</span>t care <span class=k>for </span>the layout chosen by
 <span class=o>(</span>A<span class=o>)</span>uto, press F1 <span class=k>for </span>more information on manual layout.

                                <span class=o>[</span>  OK  <span class=o>]</span>
                          <span class=o>[</span> Press enter or space <span class=o>]</span></code></pre></div></div><div class=paragraph><p>Es decir:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>                                 Message
 Debe crear particiones BSD dentro de las <span class=s1>&#39;particiones
 fdisk&#39;</span> que acaba de crear.  Si tiene una cantidad de espacio en
 disco razonablemente grande <span class=o>(</span>200MB o más<span class=o>)</span> y no tiene necesidades
 especiales puede simplemente usar el comando <span class=o>(</span>A<span class=o>)</span>uto para asignar
 el espacio automáticamente. Si tiene necesidades más concretas o
 simplemente no le gusta la estructura que le da <span class=o>(</span>A<span class=o>)</span>uto pulse
 F1 y obtendrá más información sobre la creación manual de
 la estructura.

                                <span class=o>[</span>  OK  <span class=o>]</span>
                          <span class=o>[</span> Pulse Intro o Espacio <span class=o>]</span></code></pre></div></div><div class=paragraph><p>Al pulsar <kbd>Intro</kbd> arrancará el editor de particiones de FreeBSD, Disklabel.</p></div><div class=paragraph><p>La <a href=#sysinstall-label>El editor Disklabel</a> muestra lo que verá cuando arranque Disklabel. La pantalla se divide en tres secciones.</p></div><div class=paragraph><p>Las primeras líneas muestran el nombre del disco en el que estamos haciendo cambios y el de la «slice» que contiene las particiones que estamos creando (Disklabel las muestra bajo <code>Partition name</code> («nombre de partición») en lugar de hacerlo como «slices»). Vemos también ahí la cantidad de espacio libre en la «slice», esto es, el espacio que hay asignado a la «slice» pero que aún no ha sido asignado a ninguna partición.</p></div><div class=paragraph><p>En la mitad de la pantalla se muestran las particiones que se han creado, el nombre de los sistemas de ficheros que contiene cada partición, sus tamaños y algunas opciones relacionadas con la creación de sistemas de ficheros.</p></div><div class=paragraph><p>La tercera parte de la pantalla, la de más abajo, muestra los atajos de teclado que pueden usarse en Disklabel.</p></div><div id=sysinstall-label class=imageblock><div class=content><img src=../../../../images/books/handbook/install/disklabel-ed1.png alt="disklabel ed1"></div><div class=title>Figura 16. El editor Disklabel</div></div><div class=paragraph><p>Disklabel puede crear automáticamente particiones y asignarles tamaños por omisión. Estos tamaños se calculan con la ayuda de un algoritmo interno de dimensionamiento de particiones que analiza el tamaño del disco. Puede probarlo pulsando <kbd>A</kbd>. Verá una pantalla similar a la que aparece en la <a href=#sysinstall-label2>Editor Disklabel con valores por omisión</a>. Dependiendo del tamaño del disco que esté usando los valores por omisión pueden o no ser los apropiados. Esto no es algo de lo que deba preocuparse dado que no está obligado a aceptar esos valores por omisión.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>En el esquema de particiones por omisión el directorio <span class=filename>/tmp</span> tiene su propia partición en lugar de formar parte de <span class=filename>/</span>. Esto ayuda a evitar el desbordamiento de <span class=filename>/</span> con ficheros temporales.</p></div></td></tr></tbody></table></div><div id=sysinstall-label2 class=imageblock><div class=content><img src=../../../../images/books/handbook/install/disklabel-auto.png alt="disklabel auto"></div><div class=title>Figura 17. Editor Disklabel con valores por omisión</div></div><div class=paragraph><p>Si decide no usar los valores por defecto para las particiones y quiere reemplazar tales valores por los suyos use las flechas: elija la primera partición y pulse <kbd>D</kbd> para borrarla. Repita el proceso para borrar todas las particiones que desee.</p></div><div class=paragraph><p>Vamos a crear la primera partición (<code>a</code>, montada como <span class=filename>/</span> o raíz). Seleccione la «slice» adecuada y pulse <kbd>C</kbd>. Aparecerá un diálogo pidiéndole que escriba el tamaño de la nueva partición (como se muestra en la in <a href=#sysinstall-label-add>Liberar espacio para la partición raíz</a>). Puede introducir el tamaño expresado en bloques de disco o como un número seguido de una <code>M</code> para expresarlo en megabytes, una <code>G</code> para usar gygabytes o una <code>C</code> si quiere expresarlo en cilindros.</p></div><div id=sysinstall-label-add class=imageblock><div class=content><img src=../../../../images/books/handbook/install/disklabel-root1.png alt="disklabel root1"></div><div class=title>Figura 18. Liberar espacio para la partición raíz</div></div><div class=paragraph><p>El tamaño por omisión que se muestra creará una partición que ocupe el resto de la «slice». Si va a usar los tamaños de partición que se daban en el ejemplo anterior borre el texto existente pulsando <kbd>Retroceso</kbd>; escriba <code>64M</code>, como se puede ver en la <a href=#sysinstall-label-add2>Edición del tamaño de la partición raíz</a>. Después pulse <b class=button>OK</b>.</p></div><div id=sysinstall-label-add2 class=imageblock><div class=content><img src=../../../../images/books/handbook/install/disklabel-root2.png alt="disklabel root2"></div><div class=title>Figura 19. Edición del tamaño de la partición raíz</div></div><div class=paragraph><p>Una vez elegido el tamaño de la partición tendrá que elegir si esta partición ha de contener un sistema de ficheros o espacio swap y escribir lo que corresponda en una pantalla como la que se muestra en la <a href=#sysinstall-label-type>Elegir el tipo de partición raíz</a>. Esta primera partición contendrá un sistema de ficheros, así que seleccionamos <span class=guimenuitem>FS</span> y pulsamos <kbd>Intro</kbd>.</p></div><div id=sysinstall-label-type class=imageblock><div class=content><img src=../../../../images/books/handbook/install/disklabel-fs.png alt="disklabel fs"></div><div class=title>Figura 20. Elegir el tipo de partición raíz</div></div><div class=paragraph><p>Para acabar, dado que está creando un sistema de ficheros, tendrá que decirle a Disklabel dónde hay que montarlo. La pantalla se muestra en la <a href=#sysinstall-label-mount>Elegir el punto de montaje del sistema de ficheros raíz</a>. El punto de montaje del sistema de ficheros raíz es <span class=filename>/</span>, así que tendrá que teclear <code>/</code> y luego pulsar <kbd>Intro</kbd>.</p></div><div id=sysinstall-label-mount class=imageblock><div class=content><img src=../../../../images/books/handbook/install/disklabel-root3.png alt="disklabel root3"></div><div class=title>Figura 21. Elegir el punto de montaje del sistema de ficheros raíz</div></div><div class=paragraph><p>La pantalla le mostrará ahora la partición que acaba de crear. Repita el procedimiento todas las veces que necesite con las demás particiones. Cuando cree la partición swap no se le pedirá el punto de montaje puesto que las particiones swap nunca se montan como tales. Cuando cree la última partición <span class=filename>/usr</span>, puede dejar el tamaño que se le sugiere, esto es, usar el resto del espacio en la «slice».</p></div><div class=paragraph><p>La última pantalla del editor Disklabel será muy parecida a la <a href=#sysinstall-label4>Editor Disklabel</a>, aunque los valores pueden ser diferentes. Pulse <kbd>Q</kbd> para salir del editor.</p></div><div id=sysinstall-label4 class=imageblock><div class=content><img src=../../../../images/books/handbook/install/disklabel-ed2.png alt="disklabel ed2"></div><div class=title>Figura 22. Editor Disklabel</div></div></div></div><div class=sect2><h3 id=install-choosing>2.7. Elección de qué instalar<a class=anchor href=#install-choosing></a></h3><div class=sect3><h4 id=distset>2.7.1. Elección del tipo de instalación<a class=anchor href=#distset></a></h4><div class=paragraph><p>La elección de qué tipo de instalación debe hacer depende enormemente del uso que se va a dar al sistema y del espacio de disco disponible. El rango de opciones predefinidas está entre hacer la instalación más pequeña posible o instalarlo todo. Las personas con poco o ninguna experiencia en UNIX® o FreeBSD deberán elegir alguna de las opciones predefinidas que se les ofrecen, a las que llamaremos distribuciones (de «distribution set») tal y como aparecen en el menú de sysinstall. Una instalación ·a medida es algo más adecuado para para usuarios con más experiencia.</p></div><div class=paragraph><p>Si pulsa <kbd>F1</kbd> podrá acceder a más información sobre las opciones de tipo de instalación y qué contiene cada distribución. Cuando acabe de consultar la ayuda pulse <kbd>Intro</kbd> y volverá al al menú de selección de instalación de distribuciones.</p></div><div class=paragraph><p>Si tiene intención de instalar un interfaz gráfico de usuario tendrá que instalar una de las distribuciones cuyo nombre comienza por <code>X</code>. La configuración del servidor X y la selección de un entorno de escritorio son algunas de las tareas que tendrá una vez instalado FreeBSD. Tiene más información sobre la configuración de un servidor X en <a href=./#x11>El sistema X Window</a>.</p></div><div class=paragraph><p>La versión de X11 por omisión en FreeBSD es Xorg.</p></div><div class=paragraph><p>Si preve compilar un kernel a medida selecciones la opción que incluye el código fuente. Para más información sobre las razones por las que debe compilarse un kernel a medida y sobre cómo compilarlo consulte el <a href=./#kernelconfig>Configuración del kernel de FreeBSD</a>.</p></div><div class=paragraph><p>Evidentemente el sistema más versátil es aquél que lo tiene todo. Si dispone de espacio de disco suficiente seleccione <span class=guimenuitem>All</span>, como se muestra en la <a href=#distribution-set1>Elección de distribuciones</a>, usando las flechas y pulsando <kbd>Intro</kbd>. Si el espacio en disco es limitado piense en usar alguna de las otras opciones. No pierda con ello demasiado tiempo puesto que el resto de distribuciones pueden añadirse en cualquier momento tras la intalación.</p></div><div id=distribution-set1 class=imageblock><div class=content><img src=../../../../images/books/handbook/install/dist-set.png alt="dist set"></div><div class=title>Figura 23. Elección de distribuciones</div></div></div><div class=sect3><h4 id=portscol>2.7.2. Instalación de la colección de ports<a class=anchor href=#portscol></a></h4><div class=paragraph><p>Tras seleccionar la distribución elegida se le presentará la opción de instalar el árbol de ports, o Colección de Ports, de FreeBSD. Los ports son una forma fácil y cómoda de instalar software. El árbol de ports no contiene el código fuente necesario para compilar software; es una gran colección de ficheros que automatiza la descarga, la compilación y la instalación de paquetes de software de todo tipo. El <a href=./#ports>Instalación de aplicaciones: «packages» y ports</a> explica con detalle cómo utilizar los ports.</p></div><div class=paragraph><p>El programa de instalación no comprueba si tiene espacio suficiente. Seleccione esta opción si dispone de sitio en el disco. En FreeBSD 12.0 los ports ocupan cerca de 3 GB en disco. Puede asumir tranquilamente que en las nuevas versiones del sistema irán ocupando más y más.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>                         User Confirmation Requested
 Would you like to <span class=nb>install </span>the FreeBSD ports collection?

 This will give you ready access to over 24,000 ported software packages,
 at a cost of around 500 MB of disk space when <span class=s2>&#34;clean&#34;</span> and possibly much
 more than that <span class=k>if </span>a lot of the distribution tarballs are loaded
 <span class=o>(</span>unless you have the extra CDs from a FreeBSD CD/DVD distribution
 available and can mount it on /cdrom, <span class=k>in </span>which <span class=k>case</span> this is far less
 of a problem<span class=p>)</span><span class=nb>.</span>

 The Ports Collection is a very valuable resource and well worth having
 on your /usr partition, so it is advisable to say Yes to this option.

 For more information on the Ports Collection &amp; the latest ports,
 visit:
     http://www.FreeBSD.org/ports

                              <span class=o>[</span> Yes <span class=o>]</span>     No</code></pre></div></div><div class=paragraph><p>Es decir:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> Petición de confirmación del usuario
 ?Quiere instalar la colección de ports de FreeBSD?

 Tendrá acceso inmediato a más de 24,000 paquetes de software listos
 para usarse en FreeBSD, aunque necesitará cerca de 500 MB de
 espacio en disco como mínimo y posiblemente mucho más
 si descarga los <span class=s1>&#39;tarballs&#39;</span> de código fuente <span class=o>(</span>aunque si tiene los CD
 extra de una versión de FreeBSD en CD/DVD puede montarlos en /cdrom, de forma
 que esto dejaría de ser un problema<span class=o>)</span><span class=nb>.</span>

 La colección de ports es un recurso extremadamente valioso y es muy
 recomendable que la instale en su partición /usr, así que debería
 responder Sí a la siguiente pregunta.

 Si quiere estar al tanto de las últimas novedades y las últimas
 entradas en la colección de ports visite:
     http://www.FreeBSD.org/ports

                              <span class=o>[</span> Yes <span class=o>]</span>     No</code></pre></div></div><div class=paragraph><p>Seleccione <b class=button>yes</b> con las flechas e instale los ports o <b class=button>no</b> para obviar la pregunta. Pulse <kbd>Intro</kbd> para seguir con la instalación. Volvemos al menú de elección de distribuciones.</p></div><div id=distribution-set2 class=imageblock><div class=content><img src=../../../../images/books/handbook/install/dist-set2.png alt="dist set2"></div><div class=title>Figura 24. Confirmar la elección de distribuciones</div></div><div class=paragraph><p>Si ya ha elegido todo lo que necesita seleccione <span class=guimenuitem>Exit</span> con las flechas, asegúrese de que <b class=button>OK</b> está seleccionado también y pulse <kbd>Intro</kbd>.</p></div></div></div><div class=sect2><h3 id=install-media>2.8. Elección del medio de instalación<a class=anchor href=#install-media></a></h3><div class=paragraph><p>Si va a instalar FreeBSD desde CDROM o DVD seleccione <span class=guimenuitem>Install from a FreeBSD CD/DVD</span> con las flechas. Una vez <b class=button>OK</b> está seleccionado pulse <kbd>Intro</kbd> y siga adelante con la instalación.</p></div><div class=paragraph><p>Si quiere usar otro método de instalación seleccione la opción correspondiente y siga las instrucciones.</p></div><div class=paragraph><p>Pulse <kbd>F1</kbd> si necesita acceder a la ayuda del medio de instalación elegido. Pulse <kbd>Intro</kbd> para regresar al menú de selección de medios.</p></div><div id=choose-media class=imageblock><div class=content><img src=../../../../images/books/handbook/install/media.png alt=media></div><div class=title>Figura 25. Choose Installation Media</div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=title>Tipos de instalación desde FTP</div><div class=paragraph><p>Hay tres tipos de instalación por FTP entre las que puede elegir: FTP activo, FTP pasivo o a través de un proxy HTTP.</p></div><div class=dlist><dl><dt class=hdlist1>FTP Activo: <span class=guimenuitem>Install from an FTP server</span>, es decir: «Instalar desde un servidor FTP»</dt><dd><p>Esta opción hará que todas las transferencias FTP usen el modo «Activo». No funcionará a través de cortafuegos pero seguramente funcionará con viejos servidores FTP que no soportan el modo pasivo. Si su conexión se cuelga cuando usa el modo pasivo (el modo por omisión) pruebe el modo activo.</p></dd><dt class=hdlist1>FTP Pasivo: <span class=guimenuitem>Install from an FTP server through a firewall</span>, es decir «Instalar desde un servidor FTP tras un cortafuegos».</dt><dd><p>Esta opción configura sysinstall para que use el modo «Pasivo» para todas las operaciones FTP. Esto permite al usuario pasar a través de cortafuegos que no permiten conexiones entrantes a puertos TCP aleatorios.</p></dd><dt class=hdlist1>FTP via un proxy HTTP: <span class=guimenuitem>Install from an FTP server through a http proxy</span>, es decir «Instalar desde un un servidor FTP via un proxy HTTP».</dt><dd><p>Esta opción configura sysinstall para que use el protocolo HTTP (como si fuera un navegador web) para conectarse a un proxy en todas las operaciones FTP. El proxy traducirá las peticiones del usuario de forma que pasarán a través de un cortafuegos que no permita ningún tipo de conexiones FTP pero ofrezca un proxy HTTP. Tendrá que configurar los datos del proxy además de los del servidor FTP.</p></dd></dl></div><div class=paragraph><p>Si quiere usar un servidor proxy FTP tendrá que usar el nombre del servidor con el que realmente quiere conectar como nombre de usuario seguido de un signo «@». Veamos un ejemplo. Quiere usted instalar desde <code>ftp.FreeBSD.org</code> a través del servidor proxy FTP <code>talycual.ejemplo.com</code>, que escucha en el puerto 1024.</p></div><div class=paragraph><p>Vaya al menú opciones, ponga <code>ftp@ftp.FreeBSD.org</code> como nombre de usuario FTP, y su dirección de correo electrónico como contraseña. El medio de instalación será FTP (o FTP pasivo si el proxy lo permite) y la URL <code><a href=ftp://talycual.ejemplo.com:1234/pub/FreeBSD class=bare>ftp://talycual.ejemplo.com:1234/pub/FreeBSD</a></code>.</p></div><div class=paragraph><p>Dado accede al directorio <span class=filename>/pub/FreeBSD</span> de <code>ftp.FreeBSD.org</code> a través del proxy <code>talycual.ejemplo.com</code> puede usted instalar desde <em>ésta</em> máquina, que irá descargando los ficheros que necesite desde <code>ftp.FreeBSD.org</code> a medida que el proceso de instalación los vaya requiriendo.</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=install-final-warning>2.9. El punto sin retorno<a class=anchor href=#install-final-warning></a></h3><div class=paragraph><p>A partir de aquí entramos en la instalación propiamente dicha. Esta es la última oportunidad antes de empezar a escribir datos en el disco duro.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>                       User Confirmation Requested
 Last Chance! Are you SURE you want to <span class=k>continue </span>the installation?

 If you<span class=s1>&#39;re running this on a disk with data you wish to save then WE
 STRONGLY ENCOURAGE YOU TO MAKE PROPER BACKUPS before proceeding!

 We can take no responsibility for lost disk contents!

                             [ Yes ]    No</span></code></pre></div></div><div class=paragraph><p>Es decir:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>   Petición de confirmación del usuario
 ¡Última oportunidad!.  ?SEGURO que quiere seguir con la instalación?

 Si está ejecutando este proceso en un disco que contenga datos que
 quiera coservar LE RECOMENDAMOS ENCARECIDAMENTE QUE HAGA COPIAS DE
 SEGURIDAD FIABLES antes de instalar.

 No podemos asumir nigún tipo de responsabilidad por datos que pierda.

                             <span class=o>[</span> Yes <span class=o>]</span>    No</code></pre></div></div><div class=paragraph><p>Seleccione <b class=button>yes</b> y pulse <kbd>Intro</kbd>.</p></div><div class=paragraph><p>La instalación tardará más o menos tiempo según la distribución que haya elegido, el medio de instalación y la velocidad del sistema. Se le irán mostrando mensajes durante el proceso para irle informando de cómo van las cosas.</p></div><div class=paragraph><p>Cuando acabe la instalación verá un mensaje como este:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>                               Message

Congratulations! You now have FreeBSD installed on your system.

We will now move on to the final configuration questions.
For any option you <span class=k>do </span>not wish to configure, simply <span class=k>select </span>No.

If you wish to re-enter this utility after the system is up, you may
<span class=k>do </span>so by typing: sysinstall <span class=nb>.</span>

                                 <span class=o>[</span> OK <span class=o>]</span>

                      <span class=o>[</span>  Press enter to <span class=k>continue</span>  <span class=o>]</span></code></pre></div></div><div class=paragraph><p>Es decir:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>                               Mensaje

         ¡Enhorabuena! Ha instalado FreeBSD en su sistema.

Ahora terminaremos la configuración del sistema.  Si hay alguna
opción que no quiere configurar bastará con que elija No.

Si en algún momento quiere regresar a este programa escriba
sysinstall <span class=nb>.</span>

                                 <span class=o>[</span> OK <span class=o>]</span>

                      <span class=o>[</span>  Pulse Intro  <span class=o>]</span></code></pre></div></div><div class=paragraph><p>Pulse <kbd>Intro</kbd>; pasaremos a acometer ciertas tareas posteriores a la instalación.</p></div><div class=paragraph><p>Si selecciona <b class=button>no</b> y pulsa <kbd>Intro</kbd> la instalación se detendrá para evitar hacer más modificaciones en su sistema. Verá el el siguiente mensaje.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>                                Message
Installation <span class=nb>complete </span>with some errors.  You may wish to scroll
through the debugging messages on VTY1 with the scroll-lock feature.
You can also choose <span class=s2>&#34;No&#34;</span> at the next prompt and go back into the
installation menus to retry whichever operations have failed.

                                 <span class=o>[</span> OK <span class=o>]</span></code></pre></div></div><div class=paragraph><p>Es decir:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>                                Mensaje
La instalación ha finalizado con errores.  Puede moverse por la
pantalla de mensajes de depuración de VTY1 tras pulsar la tecla
de Bloqueo de Pantalla.  También puede elegir <span class=s2>&#34;No&#34;</span> en el próximo
menú y volver a los menús de instalación y repetir cualquier
operación que haya fallado.

                                 <span class=o>[</span> OK <span class=o>]</span></code></pre></div></div><div class=paragraph><p>Este mensaje se ha generado porque no se ha instalado nada. Pulse <kbd>Intro</kbd> para volver al menún principal y salir de la instalación.</p></div></div><div class=sect2><h3 id=install-post>2.10. Después de la instalación<a class=anchor href=#install-post></a></h3><div class=paragraph><p>Para poder terminar una instalación de FreeBSD que merezca tal nombre debemos responder todavía a unas cuantas preguntas. Para ello debemos entrar en la configuración antes de entrar en el nuevo sistema FreeBSD o una vez en dentro del sistema desde <code>sysinstall</code>, seleccionando <span class=guimenuitem>Configure</span>.</p></div><div class=sect3><h4 id=inst-network-dev>2.10.1. Network Device Configuration<a class=anchor href=#inst-network-dev></a></h4><div class=paragraph><p>Si ha tenido que configurar PPP para poder instalar desde FTP esta pantalla no aparecerá. Puede modificar la configuración tal y como se ha explicado más arriba.</p></div><div class=paragraph><p>Si necesita información sobre redes de área local y la configuración de FreeBSD necesaria para que haga de «gateway/router» consulte el <a href=./#advanced-networking>Advanced Networking</a> chapter.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>                      User Confirmation Requested
   Would you like to configure any Ethernet or SLIP/PPP network devices?

                             <span class=o>[</span> Yes <span class=o>]</span>   No</code></pre></div></div><div class=paragraph><p>Si quiere configurar dispositivos de red seleccione <b class=button>yes</b> y pulse <kbd>Intro</kbd>. Si no quiere seleccione <b class=button>no</b>.</p></div><div id=ed-config1 class=imageblock><div class=content><img src=../../../../images/books/handbook/install/ed0-conf.png alt="ed0 conf"></div><div class=title>Figura 26. Selección de un dispositivo Ethernet</div></div><div class=paragraph><p>Seleccione con las flechas el interfaz de red que desea configurar y pulse <kbd>Enter</kbd>.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>                      User Confirmation Requested
       Do you want to try IPv6 configuration of the interface?

                              Yes   <span class=o>[</span> No <span class=o>]</span></code></pre></div></div><div class=paragraph><p>En la red local del ejemplo el tipo de protocolo de Internet que había (IPv4) parecía más que suficiente, así que se eligió <b class=button>no</b>.</p></div><div class=paragraph><p>Si puede conectar con alguna red IPv6 mediante un servidor RA elija <b class=button>yes</b> y pulse <kbd>Intro</kbd>. La búsqueda de servidores RA se hará en unos instantes.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>                             User Confirmation Requested
        Do you want to try DHCP configuration of the interface?

                              Yes   <span class=o>[</span> No <span class=o>]</span></code></pre></div></div><div class=paragraph><p>Si no necesita DHCP seleccione <b class=button>no</b> con las flechas y pulse <kbd>Intro</kbd>.</p></div><div class=paragraph><p>Si selecciona <b class=button>yes</b> ejecutará dhclient y, si ha funcionado, completará los datos de configuración automáticamente. Para más información consulte la <a href=./#network-dhcp>DHCP</a>.</p></div><div class=paragraph><p>La siguiente ilustración muestra la configuración de un dispositivo Ethernet en un sistema que cumplirá las funciones de «gateway» en una red local.</p></div><div id=ed-config2 class=imageblock><div class=content><img src=../../../../images/books/handbook/install/ed0-conf2.png alt="ed0 conf2"></div><div class=title>Figura 27. Configuración de ed0</div></div><div class=paragraph><p>Use el <kbd>tabulador</kbd> para ir pasando de un campo al siguiente una vez que los vaya rellenando:</p></div><div class=dlist><dl><dt class=hdlist1>Host</dt><dd><p>El nombre de la máquina; por ejemplo, <code>k6-2.ejemplo.com</code>.</p></dd><dt class=hdlist1>Dominio</dt><dd><p>El nombre del dominio al que pertenece la máquina, en este caso <code>ejemplo.com</code>.</p></dd><dt class=hdlist1>«Gateway»IPv4</dt><dd><p>La dirección IP del sistema que reenvia paquetes a destinos fuera de la red local. Debe rellenar este campo si esta función la realiza una máquina que forme parte de la red. <em>Déjelo en blanco</em> si el sistema es el enlace de su red con Internet. El «gateway» recibe también los nombres de puerta de enlace o ruta por omisión.</p></dd><dt class=hdlist1>Servidor de nombres</dt><dd><p>Dirección IP de su servidor local de DNS. En la red del ejemplo no hay servidor DNS local así que se ha introducido la dirección IP del servidor DNS del proveedor de Internet: <code>208.163.10.2</code>.</p></dd><dt class=hdlist1>Dirección IPv4</dt><dd><p>En este interfaz se usará la dirección IP <code>192.168.0.1</code></p></dd><dt class=hdlist1>Máscara de red</dt><dd><p>En esta red local se usa un bloque de redes de Clase C <code>192.168.0.0</code> - <code>192.168.0.255</code>. La máscara de red es, por tanto, <code>255.255.255.0</code>.</p></dd><dt class=hdlist1>Opciones adicionales de ifconfig</dt><dd><p>Cualquiera de las opciones que quiera agregar a su interfaz mediante <code>ifconfig</code>. En nuestro caso no había ninguna.</p></dd></dl></div><div class=paragraph><p>Utilice el <kbd>tabulador</kbd> para seleccionar <b class=button>OK</b> cuando haya acabado y pulse<kbd>Intro</kbd>.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>                      User Confirmation Requested
        Would you like to Bring Up the ed0 interface right now?

                             <span class=o>[</span> Yes <span class=o>]</span>   No</code></pre></div></div><div class=paragraph><p>Seleccione <b class=button>yes</b> y pulse <kbd>Enter</kbd> si quiere conectar inmediatamente su sistema a la red mediante el o los interfaces que acaba de configurar, pero recuerde que aún tendrá que reiniciar la máquina.</p></div></div><div class=sect3><h4 id=gateway>2.10.2. Configuración del «gateway»<a class=anchor href=#gateway></a></h4><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>                       User Confirmation Requested
       Do you want this machine to <span class=k>function </span>as a network gateway?

                              <span class=o>[</span> Yes <span class=o>]</span>    No</code></pre></div></div><div class=paragraph><p>Si el sistema hará de enlace de la red local y reenviará paquetes entre otras máquinas elija <b class=button>yes</b> y pulse <kbd>Intro</kbd>. Si la máquina es un nodo de una red elija <b class=button>no</b> y pulse <kbd>Intro</kbd>.</p></div></div><div class=sect3><h4 id=inetd-services>2.10.3. Configuración de servicios de internet<a class=anchor href=#inetd-services></a></h4><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>                      User Confirmation Requested
Do you want to configure inetd and the network services that it provides?

                               Yes   <span class=o>[</span> No <span class=o>]</span></code></pre></div></div><div class=paragraph><p>Si selecciona <b class=button>no</b> varios servicios de la máquina, como telnetd y otros, no se activarán. Eso significa que los usuarios remotos no podrán acceder al sistema mediante telnet. Los usuarios locales, en cambio, podrán acceder a sistemas remotos mediante telnet.</p></div><div class=paragraph><p>Dichos servicios pueden activarse en cualquier momento editando <span class=filename>/etc/inetd.conf</span> con el editor de texto que prefiera. Para más información consulte la <a href=./#network-inetd-overview>Resumen</a>.</p></div><div class=paragraph><p>Seleccione <b class=button>yes</b> si desea configurar estos servicios durante la instalación. Se le mostrará el siguiente mensaje:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>                      User Confirmation Requested
The Internet Super Server <span class=o>(</span>inetd<span class=o>)</span> allows a number of simple Internet
services to be enabled, including finger, ftp and telnetd.  Enabling
these services may increase risk of security problems by increasing
the exposure of your system.

With this <span class=k>in </span>mind, <span class=k>do </span>you wish to <span class=nb>enable </span>inetd?

                             <span class=o>[</span> Yes <span class=o>]</span>   No</code></pre></div></div><div class=paragraph><p>Select <b class=button>yes</b> to continue.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>                      User Confirmation Requested
inetd<span class=o>(</span>8<span class=o>)</span> relies on its configuration file, /etc/inetd.conf, to determine
which of its Internet services will be available.  The default FreeBSD
inetd.conf<span class=o>(</span>5<span class=o>)</span> leaves all services disabled by default, so they must be
specifically enabled <span class=k>in </span>the configuration file before they will
<span class=k>function</span>, even once inetd<span class=o>(</span>8<span class=o>)</span> is enabled.  Note that services <span class=k>for
</span>IPv6 must be separately enabled from IPv4 services.

Select <span class=o>[</span>Yes] now to invoke an editor on /etc/inetd.conf, or <span class=o>[</span>No] to
use the current settings.

                             <span class=o>[</span> Yes <span class=o>]</span>   No</code></pre></div></div><div class=paragraph><p>Es decir:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>      Petición de confirmación del usuario
El Super Servidor de Internet <span class=o>(</span>inetd<span class=o>)</span> le permite activar diversos
servicios sencillos de Internet, como finger, ftp y telnetd.  Si
activa tales servicios puede sobreexponer su sistema al exterior, lo
que puede incrementar el riesgo de tener problemas de seguridad.

Dicho esto ?desea activar inetd?

                             <span class=o>[</span> Yes <span class=o>]</span>   No</code></pre></div></div><div class=paragraph><p>Si selecciona <b class=button>yes</b> podrá añadir servicios borrando caracteres <code>#</code> al comienzo de las líneas correspondientes.</p></div><div id=inetd-edit class=imageblock><div class=content><img src=../../../../images/books/handbook/install/edit-inetd-conf.png alt="edit inetd conf"></div><div class=title>Figura 28. Edición de <span class=filename>inetd.conf</span></div></div><div class=paragraph><p>Una vez que haya añadido los servicios que quiera en el sistema pulse <kbd>Esc</kbd> y verá un menú en el que se le preguntará si quiere guardar los cambios.</p></div></div><div class=sect3><h4 id=ssh-login>2.10.4. Activar el acceso al sistema mediante SSH<a class=anchor href=#ssh-login></a></h4><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>                      User Confirmation Requested
                  Would you like to <span class=nb>enable </span>SSH login?
                           Yes        <span class=o>[</span>  No  <span class=o>]</span></code></pre></div></div><div class=paragraph><p>Si selecciona <b class=button>yes</b> activará <a href="https://man.freebsd.org/cgi/man.cgi?query=sshd&amp;sektion=8&amp;format=html">sshd(8)</a>, el dæmon de OpenSSH. De este modo será posible el acceso remoto y seguro al sistema. Para más información sobre OpenSSH visite <a href=./#openssh>Security</a>.</p></div></div><div class=sect3><h4 id=ftpanon>2.10.5. FTP anónimo<a class=anchor href=#ftpanon></a></h4><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>                      User Confirmation Requested
 Do you want to have anonymous FTP access to this machine?

                              Yes    <span class=o>[</span> No <span class=o>]</span></code></pre></div></div><div class=sect4><h5 id=deny-anon>2.10.5.1. Rechazar el acceso al sistema mediante FTP anónimo<a class=anchor href=#deny-anon></a></h5><div class=paragraph><p>si acepta la respuesta por omisión (<b class=button>no</b>) y pulsa <kbd>Intro</kbd> tenga en cuenta que los usuarios que tengan cuenta en la máquina podrán seguir accediendo al sistema.</p></div></div><div class=sect4><h5 id=ftpallow>2.10.5.2. Aceptar el acceso al sistema mediante FTP anónimo<a class=anchor href=#ftpallow></a></h5><div class=paragraph><p>Si decide aceptar conexiones FTP anónimas cualquiera podrá conectarse al sistema. Antes de activar esta opción debería meditar sobre las implicaciones de seguridad de esa decisión. Para más información sobre la seguridad y FreeBSD consulte el <a href=./#security>Seguridad</a>.</p></div><div class=paragraph><p>Si ha decidido activar el FTP anónimo seleccione con las flechas <b class=button>yes</b> y pulse <kbd>Intro</kbd>. Verá la siguiente pantalla (o una muy similar):</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>This screen allows you to configure the anonymous FTP user.

The following configuration values are editable:

UID:     The user ID you wish to assign to the anonymous FTP user.
         All files uploaded will be owned by this ID.

Group:   Which group you wish the anonymous FTP user to be <span class=k>in</span><span class=nb>.</span>

Comment: String describing this user <span class=k>in</span> /etc/passwd

FTP Root Directory:

        Where files available <span class=k>for </span>anonymous FTP will be kept.

Upload subdirectory:

        Where files uploaded by anonymous FTP <span class=nb>users </span>will go.</code></pre></div></div><div class=paragraph><p>Es decir:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>En esta pantalla puede configurar el usuario de FTP
        anónimo.

Puede editar los siguientes valores de la configuración:

UID:     El ID del usuario que quiere asignar al usuario anónimo de
         de FTP.  Todos los ficheros que se suban le  pertenecerán.

Group:   El grupo al que pertenecerá el usuario FTP anónimo.

Comment: La descripción del usuario en /etc/passwd

FTP Root Directory:

        Dónde se guardarán contenidos para los usuarios anónimos.

Upload subdirectory:

        Dónde se guardarán los ficheros que suban los usuarios
	de FTP anónimo.</code></pre></div></div><div class=paragraph><p>Por omisión el directorio raíz del ftp será <span class=filename>/var</span>. Si no hay sitio suficiente para lo que prevea que va a necesitar puede usar <span class=filename>/usr</span>; puede poner el Directorio Raíz de FTP en <span class=filename>/usr/ftp</span>.</p></div><div class=paragraph><p>Cuando haya terminado con la configuración pulse <kbd>Intro</kbd>.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>                          User Confirmation Requested
         Create a welcome message file <span class=k>for </span>anonymous FTP <span class=nb>users</span>?

                              <span class=o>[</span> Yes <span class=o>]</span>    No</code></pre></div></div><div class=paragraph><p>Si selecciona <b class=button>yes</b> y pulsa <kbd>Intro</kbd> arrancará automáticamente un editor y podrá crear un mensaje que verá los usuarios de FTP anónimo al conectarse a la máquina.</p></div><div id=anon-ftp4 class=imageblock><div class=content><img src=../../../../images/books/handbook/install/ftp-anon2.png alt="ftp anon2"></div><div class=title>Figura 29. Edición del mensaje de bienvenida de FTP</div></div><div class=paragraph><p>Vemos en acción un editor de texto llamado <code>ee</code>. Puede modificar el mensaje ahora mismo o hacerlo en cualquier otro momento con el editor de texto que prefiera. Observe el fichero y su ubicación en la parte baja de la pantalla.</p></div><div class=paragraph><p>Pulse <kbd>Esc</kbd>, aparecerá una ventana flotante con la opción por omisión de to <span class=guimenuitem>a) leave editor</span> (salir del editor). Pulse <kbd>Intro</kbd> si quiere salir y seguir con lo que estaba haciendo. Pulse <kbd>Intro</kbd> de nuevo para guardar los cambios que hubiera hecho.</p></div></div></div><div class=sect3><h4 id=nfsconf>2.10.6. Configuración de NFS<a class=anchor href=#nfsconf></a></h4><div class=paragraph><p>NFS («Network File System» (de Network File System, o Sistema de Ficheros en Red) le permitirá compartir ficheros a través de una red. Una máquina puede configurarse como servidor, como cliente o ambos. Para má información consulte la <a href=./#network-nfs>NFS</a>.</p></div><div class=sect4><h5 id=nsf-server-options>2.10.6.1. Servidor NFS<a class=anchor href=#nsf-server-options></a></h5><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>                       User Confirmation Requested
 Do you want to configure this machine as an NFS server?

                              Yes    <span class=o>[</span> No <span class=o>]</span></code></pre></div></div><div class=paragraph><p>Si no tiene necesidad de usar un servidor NFS seleccione <b class=button>no</b> y pulse <kbd>Intro</kbd>.</p></div><div class=paragraph><p>Si ha elegido <b class=button>yes</b> verá un mensaje emergente indicando que hay que crear el fichero <span class=filename>exports</span>.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>                               Message
Operating as an NFS server means that you must first configure an
/etc/exports file to indicate which hosts are allowed certain kinds of
access to your <span class=nb>local </span>filesystems.
Press <span class=o>[</span>Enter] now to invoke an editor on /etc/exports
                               <span class=o>[</span> OK <span class=o>]</span></code></pre></div></div><div class=paragraph><p>Es decir:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>                               Mensaje
Hacer funcionar un servidor NFS implica que tendrá que configurar
un fichero /etc/exports para indicar qué hosts estarán autorizados a
acceder de qué manera a sus sistemas de ficheros locales.
Pulse <span class=o>[</span>Intro] para abrir /etc/exports en un editor
                               <span class=o>[</span> OK <span class=o>]</span></code></pre></div></div><div class=paragraph><p>Pulse <kbd>Intro</kbd> para seguir adelante. Se abrirá un editor de texto gracias al cual se podrá editar y crear el fichero <span class=filename>exports</span>.</p></div><div id=nfs-server-edit class=imageblock><div class=content><img src=../../../../images/books/handbook/install/nfs-server-edit.png alt="nfs server edit"></div><div class=title>Figura 30. Edición de <span class=filename>exports</span></div></div><div class=paragraph><p>Puede editar el fichero ahora mismo o más tarde con el editor de texto que prefiera. Observe que el nombre del fichero y su ubicación aparecen en la parte de abajo de de la pantalla.</p></div><div class=paragraph><p>Pulse <kbd>Escape</kbd>; aparecerá un mensaje emergente que por omisión le ofrecerá <span class=guimenuitem>a) leave editor</span> (es decir, salir del editor). Pulse <kbd>Intro</kbd> para salir del editor y seguir adelante.</p></div></div><div class=sect4><h5 id=nfs-client-options>2.10.6.2. Cliente NFS<a class=anchor href=#nfs-client-options></a></h5><div class=paragraph><p>El cliente NFS permite que su máquina pueda acceder a servidores NFS.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>                       User Confirmation Requested
 Do you want to configure this machine as an NFS client?

                              Yes   <span class=o>[</span> No <span class=o>]</span></code></pre></div></div><div class=paragraph><p>Utilice las flechas para elegir si quiere o no disponer de cliente NFS (respectivamente con <b class=button>yes</b> y <b class=button>no</b> y pulse <kbd>Intro</kbd>.</p></div></div></div><div class=sect3><h4 id=console>2.10.7. Configuración de la consola del sistema<a class=anchor href=#console></a></h4><div class=paragraph><p>La consola del sistema tiene diversas opciones que puede usted adaptar a sus gustos o necesidades.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>                      User Confirmation Requested
       Would you like to customize your system console settings?

                              <span class=o>[</span> Yes <span class=o>]</span>  No</code></pre></div></div><div class=paragraph><p>Si quiere ver y modificar las opciones seleccione <b class=button>yes</b> y pulse <kbd>Intro</kbd>.</p></div><div id=saver-options class=imageblock><div class=content><img src=../../../../images/books/handbook/install/console-saver1.png alt="console saver1"></div><div class=title>Figura 31. Opciones de configuración de la consola del sistema</div></div><div class=paragraph><p>Una opción que suele elegirse es el uso del salvapantallas. Elija <span class=guimenuitem>Saver</span> y luego pulse <kbd>Intro</kbd>.</p></div><div id=saver-select class=imageblock><div class=content><img src=../../../../images/books/handbook/install/console-saver2.png alt="console saver2"></div><div class=title>Figura 32. Opciones del salvapantallas</div></div><div class=paragraph><p>Desplácese arriba y abajo con las flechas por la lista de salvapantallas y elija el que prefiera pulsando <kbd>Intro</kbd> sobre él. Se le mostrará de nuevo el menú de configuración de la consola.</p></div><div class=paragraph><p>El intervalo por defecto es de 300 segundos. Si quiere cambiarlo seleccione <span class=guimenuitem>Saver</span> otra vez. Busque <span class=guimenuitem>Timeout</span> en el menú de opciones del salvapantallas y pulse <kbd>Intro</kbd>. Aparecerá un mensaje en pantalla:</p></div><div id=saver-timeout class=imageblock><div class=content><img src=../../../../images/books/handbook/install/console-saver3.png alt="console saver3"></div><div class=title>Figura 33. Retardo del salvapantallas</div></div><div class=paragraph><p>Asigne el retardo del salvapantallas a su gusto, seleccione <b class=button>OK</b> y pulse <kbd>Intro</kbd> para volver al menú de configuración de la consola del sistema.</p></div><div id=saver-exit class=imageblock><div class=content><img src=../../../../images/books/handbook/install/console-saver4.png alt="console saver4"></div><div class=title>Figura 34. Salida del menú de configuración de la consola del sistema</div></div><div class=paragraph><p>Seleccione <span class=guimenuitem>Exit</span> y pulse <kbd>Intro</kbd> para seguir adelante con la configuración necesaria tras la instalación.</p></div></div><div class=sect3><h4 id=timezone>2.10.8. Configuración de la zona horaria<a class=anchor href=#timezone></a></h4><div class=paragraph><p>Si su sistema tiene correctamente configurada la zona horaria podrá corregir cualquier automáticamente cualquier cambio horario regional, así como cumplir adecuadamente con otras funciones relacionadas con zonas horarias.</p></div><div class=paragraph><p>El ejemplo que se muestra en las capturas de pantalla es de una máquina ubicada en la zona horaria del Este de los EEUU.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>                      User Confirmation Requested
          Would you like to <span class=nb>set </span>this machine<span class=s1>&#39;s time zone now?

                            [ Yes ]   No</span></code></pre></div></div><div class=paragraph><p>Seleccione <b class=button>yes</b> y pulse <kbd>Intro</kbd>. Vamos a configurar la zona horaria del sistema.</p></div><div class=paragraph><p>Seleccione <b class=button>yes</b> y pulse <kbd>Intro</kbd>.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>                       User Confirmation Requested
 Is this machine<span class=s1>&#39;s CMOS clock set to UTC? If it is set to local time
 or you don&#39;</span>t know, please choose NO here!

                              Yes   <span class=o>[</span> No <span class=o>]</span></code></pre></div></div><div class=paragraph><p>Seleccione <b class=button>yes</b> o <b class=button>no</b> según esté configurado el reloj del sistema y pulse <kbd>Intro</kbd>.</p></div><div id=set-timezone-region class=imageblock><div class=content><img src=../../../../images/books/handbook/install/timezone1.png alt=timezone1></div><div class=title>Figura 35. Elección de región</div></div><div class=paragraph><p>Elija la zona adecuada mediante las flechas y pulse <kbd>Intro</kbd>.</p></div><div id=set-timezone-country class=imageblock><div class=content><img src=../../../../images/books/handbook/install/timezone2.png alt=timezone2></div><div class=title>Figura 36. Elección de país</div></div><div class=paragraph><p>Elija el país adecuado con las flechas y pulse <kbd>Intro</kbd>.</p></div><div id=set-timezone-locality class=imageblock><div class=content><img src=../../../../images/books/handbook/install/timezone3.png alt=timezone3></div><div class=title>Figura 37. Elección de zona horaria</div></div><div class=paragraph><p>Elija la zona horaria adecuada con las flechas y pulse <kbd>Intro</kbd>.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>                            Confirmation
            Does the abbreviation <span class=s1>&#39;EDT&#39;</span> look reasonable?

                            <span class=o>[</span> Yes <span class=o>]</span>   No</code></pre></div></div><div class=paragraph><p>Confirme si la abreviatura de la zona horaria es la correcta. Cuando todo esté correcto pulse <kbd>Intro</kbd> y siga adelante.</p></div></div><div class=sect3><h4 id=linuxcomp>2.10.9. Compatibilidad con Linux®<a class=anchor href=#linuxcomp></a></h4><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>                      User Confirmation Requested
          Would you like to <span class=nb>enable </span>Linux binary compatibility?

                            <span class=o>[</span> Yes <span class=o>]</span>   No</code></pre></div></div><div class=paragraph><p>Si selecciona <b class=button>yes</b> y pulsa <kbd>Intro</kbd> podrá ejecutar software Linux® en FreeBSD. La instalación añadirá los paquetes necesarios para poder tener compatibilidad binaria con Linux®.</p></div><div class=paragraph><p>Si realiza la instalación por FTP la máquina necesitará conectarse a Internet. A veces los servidores ftp no tienen todas las distribuciones, de forma que si no puede instalar la distribución de compatibilidad con Linux® no se preocupe, puede probar con otro servidor o instalarla más tarde.</p></div></div><div class=sect3><h4 id=mouse>2.10.10. Configuración del ratón<a class=anchor href=#mouse></a></h4><div class=paragraph><p>Esta opción le permitirá cortar y pegar texto en consola y en otros programas mediante un ratón de tres botones. Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=moused&amp;sektion=8&amp;format=html">moused(8)</a> si usa uno de 2 botones, es posible emular ese tercer botón. En el siguiente ejemplo veremos la configuración de un ratón «no USB» (es decir, PS/2 o de puerto COM):</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>                      User Confirmation Requested
         Does this system have a PS/2, serial, or bus mouse?

                            <span class=o>[</span> Yes <span class=o>]</span>    No</code></pre></div></div><div class=paragraph><p>Seleccione <b class=button>yes</b> si tiene un ratón que no sea USB o por el contrario seleccione <b class=button>no</b> si tiene un ratón USB. Después pulse <kbd>Intro</kbd>.</p></div><div id=mouse-protocol class=imageblock><div class=content><img src=../../../../images/books/handbook/install/mouse1.png alt=mouse1></div><div class=title>Figura 38. Elija el protocolo que usa el ratón</div></div><div class=paragraph><p>Seleccione <span class=guimenuitem>Type</span> usando las flechas y pulse <kbd>Intro</kbd>.</p></div><div id=set-mouse-protocol class=imageblock><div class=content><img src=../../../../images/books/handbook/install/mouse2.png alt=mouse2></div><div class=title>Figura 39. Ajuste del protocolo del ratón</div></div><div class=paragraph><p>En el ejemplo se ha usado un ratón PS/2, así que <span class=guimenuitem>Auto</span> era correcto. Para cambiar el protocolo use las flechas para moverse por el menú y elegir otra opción. Para salir seleccione <b class=button>OK</b> y pulse <kbd>Intro</kbd>.</p></div><div id=config-mouse-port class=imageblock><div class=content><img src=../../../../images/books/handbook/install/mouse3.png alt=mouse3></div><div class=title>Figura 40. Configuración del puerto del ratón</div></div><div class=paragraph><p>Seleccione <span class=guimenuitem>Port</span> y pulse <kbd>Intro</kbd>.</p></div><div id=set-mouse-port class=imageblock><div class=content><img src=../../../../images/books/handbook/install/mouse4.png alt=mouse4></div><div class=title>Figura 41. Configuración del puerto del ratón</div></div><div class=paragraph><p>El sistema de ejemplo tiene un ratóna <span class=guimenuitem>PS/2</span>, de forma que la configuración por omisión basta. Si quiere modificarla utilice las flechas y después pulse<kbd>Intro</kbd>.</p></div><div id=test-daemon class=imageblock><div class=content><img src=../../../../images/books/handbook/install/mouse5.png alt=mouse5></div><div class=title>Figura 42. Arranque del dæmon del ratón</div></div><div class=paragraph><p>Por último, utilice las flechas para elegir <span class=guimenuitem>Enable</span> y pulse <kbd>Intro</kbd>; así se activa y prueba el dæmon del ratón.</p></div><div id=test-mouse-daemon class=imageblock><div class=content><img src=../../../../images/books/handbook/install/mouse6.png alt=mouse6></div><div class=title>Figura 43. Prueba del dæmon del ratón</div></div><div class=paragraph><p>Mueva el ratón un poco por la pantalla hasta asegurarse de que el cursor responde adecuadamente. Si todo es correcto seleccione <b class=button>yes</b> y pulse <kbd>Intro</kbd>. Si hay algo que no funcione correctamente seleccione <b class=button>no</b> e inténtelo con otras opciones de configuración.</p></div><div class=paragraph><p>Seleccione <span class=guimenuitem>Exit</span> y pulse <kbd>Intro</kbd> para volver a la configuración del sistema.</p></div></div><div class=sect3><h4 id=packages>2.10.11. Instalación de «packages»<a class=anchor href=#packages></a></h4><div class=paragraph><p>Los «packages» son binarios precompilados; son una forma muy cómoda de instalar software.</p></div><div class=paragraph><p>Veamos la instalación de un «package» Este es un buen momento para instalar «packages» si así lo desea. De todos modos una vez concluida la instalación puede entrar cuando quiera a <code>sysinstall</code> e instalar lo que necesite.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>                     User Confirmation Requested
 The FreeBSD package collection is a collection of hundreds of
 ready-to-run applications, from text editors to games to WEB servers
 and more. Would you like to browse the collection now?

                            <span class=o>[</span> Yes <span class=o>]</span>   No</code></pre></div></div><div class=paragraph><p>Elija <b class=button>yes</b> y pulse <kbd>Intro</kbd>: verá la pantalla de selección de paquetes:</p></div><div id=package-category class=imageblock><div class=content><img src=../../../../images/books/handbook/install/pkg-cat.png alt="pkg cat"></div><div class=title>Figura 44. Categorías de «packages»</div></div><div class=paragraph><p>Los «packages» presentes en el medio de instalación que esté accesible en cada momento son los únicos que se pueden instalar.</p></div><div class=paragraph><p>Todos los «packages» disponibles en el medio se mostrarán al seleccionar la categoría <span class=guimenuitem>All</span>. Elija una categoría y pulse <kbd>Intro</kbd>.</p></div><div class=paragraph><p>Al seleccionar una categoría aparecerá un menú con los paquetes disponibles existentes en la misma:</p></div><div id=package-select class=imageblock><div class=content><img src=../../../../images/books/handbook/install/pkg-sel.png alt="pkg sel"></div><div class=title>Figura 45. Selección de «packages»</div></div><div class=paragraph><p>Hemos elegido la shell bash. Seleccione tantos «packages» como quiera instalar y pulse <kbd>Espacio</kbd>. Se mostrará una breve descripción de cada «package» en la esquina inferior izquierda de la pantalla.</p></div><div class=paragraph><p>Pulsando el <kbd>Tabulador</kbd> desplazará el cursor entre el último «package» que haya seleccionado, <b class=button>OK</b> y <b class=button>Cancel</b>.</p></div><div class=paragraph><p>Cuando haya seleccionado todos los «packages» que quiera instalar pulse <kbd>Tabulador</kbd> una sola vez para que el cursor pase a <b class=button>OK</b> y pulse <kbd>Intro</kbd>, lo que le llevará al menú de selección de «packages».</p></div><div class=paragraph><p>Las flechas «izquierda» y «derecha» pueden usarse para mover el cursor entre <b class=button>OK</b> y <b class=button>Cancel</b>. Use esto para seleccionar <b class=button>OK</b> y pulsar <kbd>Intro</kbd> para volver al menú de selección de «packages».</p></div><div id=package-install class=imageblock><div class=content><img src=../../../../images/books/handbook/install/pkg-install.png alt="pkg install"></div><div class=title>Figura 46. Instalación de «packages»</div></div><div class=paragraph><p>Utilice el <kbd>tabulador</kbd> y las flechas para seleccionar <b class=button>Install</b> y pulse <kbd>Intro</kbd>. Se le pedirá que confirme que quiere instalar «packages»:</p></div><div id=package-install-confirm class=imageblock><div class=content><img src=../../../../images/books/handbook/install/pkg-confirm.png alt="pkg confirm"></div><div class=title>Figura 47. Confirmación previa a la instalación de «packages»</div></div><div class=paragraph><p>Si selecciona <b class=button>OK</b> y pulsa <kbd>Intro</kbd> comenzará la instalación de «packages». Irán apareciendo mensajes relacionados con los diversos procesos de instalación hasta que se cumplan todos. Esté atento por si aparecieran mensajes de error.</p></div><div class=paragraph><p>Tras la instalación de «packages» nos quedan unos toques finales a la configuración. Si no ha elegido ningún «package» y quiere regresar al menú de configuración seleccione <b class=button>Install</b> de todos modos.</p></div></div><div class=sect3><h4 id=addusers>2.10.12. Añadir usuarios y grupos<a class=anchor href=#addusers></a></h4><div class=paragraph><p>Deberí al menos añadir un usuario al sistema para poder usarlo para acceder al sistema una vez reiniciado sin tener que recurrir a <code>root</code>. La partición raíz suele ser pequeña y ejecutar aplicaciones como <code>root</code> tiene a llenarla rápidamente. Pero hay un peligro mucho mayor:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>                     User Confirmation Requested
 Would you like to add any initial user accounts to the system? Adding
 at least one account <span class=k>for </span>yourself at this stage is suggested since
 working as the <span class=s2>&#34;root&#34;</span> user is dangerous <span class=o>(</span>it is easy to <span class=k>do </span>things which
 adversely affect the entire system<span class=o>)</span><span class=nb>.</span>

                            <span class=o>[</span> Yes <span class=o>]</span>   No</code></pre></div></div><div class=paragraph><p>Es decir:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>     Petición de confirmación del usuario
 ?Quiere añadir algún usuario al sistema? Le sugerimos que añada al menos
 uno para usted puesto que trabajar como <span class=s2>&#34;root&#34;</span> es peligroso <span class=o>(</span>es fácil
 hacer algo con consecuencias en todo el sistema<span class=o>)</span><span class=nb>.</span>

                            <span class=o>[</span> Yes <span class=o>]</span>   No</code></pre></div></div><div class=paragraph><p>Seleccione <b class=button>yes</b> y pulse <kbd>Intro</kbd> para añadir un usuario.</p></div><div id=add-user2 class=imageblock><div class=content><img src=../../../../images/books/handbook/install/adduser1.png alt=adduser1></div><div class=title>Figura 48. Selección de «Añadir un usuario»</div></div><div class=paragraph><p>Seleccione <span class=guimenuitem>User</span> con las flechas y y pulse<kbd>Intro</kbd>.</p></div><div id=add-user3 class=imageblock><div class=content><img src=../../../../images/books/handbook/install/adduser2.png alt=adduser2></div><div class=title>Figura 49. Añadir la información del usuario</div></div><div class=paragraph><p>A medida que vaya seleccionando los campos ayudándose del <kbd>Tabulador</kbd> se le irán mostrando las siguientes descripciones en la parte baja de la pantalla:</p></div><div class=dlist><dl><dt class=hdlist1>Login ID</dt><dd><p>El nombre del usuario (obligatorio).</p></dd><dt class=hdlist1>UID</dt><dd><p>El ID numérico del usuario Déjelo en blanco si quiere el que sistema lo asigne automáticamente.</p></dd><dt class=hdlist1>Group</dt><dd><p>El grupo al que pertenecerá el usuario. Déjelo en blanco si quiere que el sistema lo asigne automáticamente.</p></dd><dt class=hdlist1>Password</dt><dd><p>La contraseña del usuario. <em>Rellene este campo con mucho cuidado</em>.</p></dd><dt class=hdlist1>Full name</dt><dd><p>El nombre completo del usuario (o un comentario descriptivo.</p></dd><dt class=hdlist1>Member groups</dt><dd><p>Los grupos a los que este usuario pertenece, es decir, de los que hereda sus derechos de acceso.</p></dd><dt class=hdlist1>Home directory</dt><dd><p>El directorio «home» del usuario; déjelo en blanco si quiere que el sistema lo asigne automáticamente.</p></dd><dt class=hdlist1>Login shell</dt><dd><p>La shell con la que el usuario accederá al sistema. Déjela en blanco si le sirve <span class=filename>/bin/sh</span>, la shell por omisión.</p></dd></dl></div><div class=paragraph><p>En nuestro ejemplo no se eligió <span class=filename>/bin/sh</span> sino <span class=filename>/usr/local/bin/bash</span>, para lo cual hubo que instalar previamente la shell bash como «package». No intente usar una shell que no existe o no podrá acceder al sistema con ese usuario. La shell más habitual en el mundo BSD es <span class=filename>/bin/tcsh</span>, la «C shell».</p></div><div class=paragraph><p>El usuario se añadió también al grupo <code>wheel</code> para que pueda convertirse en superusuario con privilegios de <code>root</code>.</p></div><div class=paragraph><p>Cuando haya terminado pulse <b class=button>OK</b> y volverá al menú de gestión de grupos y usuarios.</p></div><div id=add-user4 class=imageblock><div class=content><img src=../../../../images/books/handbook/install/adduser3.png alt=adduser3></div><div class=title>Figura 50. Salir de la gestión de usuarios y grupos</div></div><div class=paragraph><p>Los grupos también pueden añadirse en este momento si fuera necesario. También puede hacerse desde <span class=filename>sysinstall</span> una vez culminada la instalación.</p></div><div class=paragraph><p>Cuando haya acabado de añadir usuarios seleccione <span class=guimenuitem>Exit</span> con las flechas y pulse <kbd>Intro</kbd> y siga con la instalación.</p></div></div><div class=sect3><h4 id=rootpass>2.10.13. Asignar contraseña a <code>root</code> Password<a class=anchor href=#rootpass></a></h4><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>                        Message
 Now you must <span class=nb>set </span>the system manager<span class=s1>&#39;s password.
 This is the password you&#39;</span>ll use to log <span class=k>in </span>as <span class=s2>&#34;root&#34;</span><span class=nb>.</span>

                         <span class=o>[</span> OK <span class=o>]</span>

               <span class=o>[</span> Press enter or space <span class=o>]</span></code></pre></div></div><div class=paragraph><p>Es decir:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>                        Mensaje
 Debe asignar la contraseña del administrador del sistema.
 Esta es la contraseña que usará cuando acceda al sistema como
 <span class=s2>&#34;root&#34;</span><span class=nb>.</span>

                         <span class=o>[</span> OK <span class=o>]</span>

                    <span class=o>[</span> Pulse Intro <span class=o>]</span></code></pre></div></div><div class=paragraph><p>Pulse <kbd>Intro</kbd> y asígnele una contraseña a <code>root</code>.</p></div><div class=paragraph><p>Tendrá que escribir la contraseña correctamente dos veces. No hay necesidad de decirle que es importante que recuerde esa contraseña.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>New password:
Retype new password :</code></pre></div></div><div class=paragraph><p>La instalación proseguirá una vez que introduzca la contraseña correctamente dos veces.</p></div></div><div class=sect3><h4 id=exit-inst>2.10.14. Salir de la instalación<a class=anchor href=#exit-inst></a></h4><div class=paragraph><p>Si tiene que configurar <a href=#network-services>servicios de red</a> o cualquier otra cosa, puede hacerlo ahora mismo o tras terminar la instalación ejecutando <code>sysinstall</code>.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>                     User Confirmation Requested
 Visit the general configuration menu <span class=k>for </span>a chance to <span class=nb>set </span>any last
 options?

                              Yes   <span class=o>[</span> No <span class=o>]</span></code></pre></div></div><div class=paragraph><p>Seleccione <b class=button>no</b> con las flechas y pulse <kbd>Intro</kbd> para volver al menú principal de la instalación.</p></div><div id=final-main class=imageblock><div class=content><img src=../../../../images/books/handbook/install/mainexit.png alt=mainexit></div><div class=title>Figura 51. Salir de la instalación</div></div><div class=paragraph><p>Seleccione <b class=button>X Exit Install</b> con las flechas y pulse <kbd>Intro</kbd>. Se le pedirá que confirme que quiere salir de la instalación:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>                     User Confirmation Requested
 Are you sure you wish to <span class=nb>exit</span>? The system will reboot <span class=o>(</span>be sure to
 remove any floppies/CDs/DVDs from the drives<span class=o>)</span><span class=nb>.</span>

                            <span class=o>[</span> Yes <span class=o>]</span>   No</code></pre></div></div><div class=paragraph><p>Es decir:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>            Petición del Confirmación al usuario
 ?Seguro que quiere salir?  El sistema reiniciará <span class=o>(</span>compruebe que
 ha retirado los disquetes de la unidad<span class=o>)</span><span class=nb>.</span>

                            <span class=o>[</span> Yes <span class=o>]</span>   No</code></pre></div></div><div class=paragraph><p>Seleccione <b class=button>yes</b> y extraiga el disquete si ha arrancado desde floppy. La unidad CDROM está bloqueada hasta que la máquina comience a reiniciarse. La unidad CDROM se desbloquea y (actuando con agilidad felina) puede extraerse el CDROM.</p></div><div class=paragraph><p>El sistema reiniciará. Esté atento por si aparece algún mensaje de error.</p></div><div class=paragraph><p>Si apareciera algún error durante el arranque consulte la <a href=#freebsdboot>El arranque de FreeBSD</a>.</p></div></div><div class=sect3><h4 id=network-services>2.10.15. Configuración de servicios de red<a class=anchor href=#network-services></a></h4><div class=paragraph><p>La configuración de servicios de red puede ser una tarea peliaguda para usuarios inexpertos si no tienen demasiados conocimientos en la materia. Todo lo relacionado con las redes (y ahí entra Internet) tiene una importancia crítica en cualquier sistema operativo moderno y FreeBSD no es una excepción. Es por esta razón que le será muy útil saber un poco sobre la conectividad en general de FreeBSD desde el momento mismo de la instalación y los servicios de que puede disponer.</p></div><div class=paragraph><p>Los servicios de red son programas que aceptan entradas de datos desde cualquier punto de la red. Se pone mucho empeño en evitar que estos programas puedan ser «dañinos» pero por desgracia los programadores no son perfectos y de tanto en cuanto aparecen errores en los servicios de red que algunos logran aprovechar para hacer maldades. Es crucial que solamente active los servicios que sabe que va a necesitar. Si tiene dudas con alguno lo mejor es que no lo active hasta que no sea evidente que lo necesita. Puede activarlo cuando sea necesario ejecutando later by re-running sysinstall o utilizando el fichero <span class=filename>/etc/rc.conf</span> file.</p></div><div class=paragraph><p>Si selecciona la opción <b class=menuref>Networking</b> verá un menú muy parecido a este:</p></div><div id=network-configuration class=imageblock><div class=content><img src=../../../../images/books/handbook/install/net-config-menu1.png alt="net config menu1"></div><div class=title>Figura 52. Primer nivel de servicios de red</div></div><div class=paragraph><p>La primera opción, <span class=guimenuitem>Interfaces</span>, la hemos visto en la <a href=#inst-network-dev>Network Device Configuration</a>, así que podemos ignorarla.</p></div><div class=paragraph><p>Si selecciona la opción <span class=guimenuitem>AMD</span> añadirá al sistema la aplicación montaje automático de dispositivos de BSD. Suele usarse junto con el protocolo NFS protocol (ver más adelante) para automatizar el montaje de sistemas de ficheros remotos. No es necesario que configure nada.</p></div><div class=paragraph><p>La siguiente opción es <span class=guimenuitem>AMD Flags</span>. Si la selecciona verá un menú emergente que le requerirá parámetros específicos de AMD. El menú dispone ya de un conjunto de opciones por omisión:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=nt>-a</span> /.amd_mnt <span class=nt>-l</span> syslog /host /etc/amd.map /net /etc/amd.map</code></pre></div></div><div class=paragraph><p>La opción <code>-a</code> fija el punto de montaje por omisión, en este caso <span class=filename>/.amd_mnt</span>. La opción <code>-l</code> indica el <span class=filename>log</span> por omisió, aunque si usa <code>syslogd</code> todos los datos de log se enviarán al dæmon de logs del sistema. El directorio <span class=filename>/host</span> se usa para montar sistemas de ficheros exportados desde una máquina remota, mientras que el directorio <span class=filename>/net</span> se usa para montar sistemas de ficheros exportados desde una dirección IP. El fichero <span class=filename>/etc/amd.map</span> define las opciones de exportación que AMD exporta por omisión.</p></div><div class=paragraph><p>La opción <span class=guimenuitem>Anon FTP</span> permite conexiones FTP anónimas. Seleccione esta opción si quiere utilizar la máquina como servidor servidor FTP anónimo. Tenga muy en cuenta los riesgos de seguridad que conlleva esta opción. Se le ofrecerá otro menú en el que se explican en profundidad los riesgos de seguridad y la configuración.</p></div><div class=paragraph><p>El menú de configuración <span class=guimenuitem>Gateway</span> preparará la máquina para que cumpla las funciones de pasarela, tal y como se ha explicado previamente. Puede utilizarlo también para desactivar la opción <span class=guimenuitem>Gateway</span> si la seleccionón sin querer durante la instalación.</p></div><div class=paragraph><p>La opción <span class=guimenuitem>Inetd</span> permite desactivar el dæmon <a href="https://man.freebsd.org/cgi/man.cgi?query=inetd&amp;sektion=8&amp;format=html">inetd(8)</a>.</p></div><div class=paragraph><p>La opción <span class=guimenuitem>Mail</span> se usa para configurar el MTA (de Mail Transfer Agent, agente de transferencia de correo) del sistema. Si selecciona esta opción llegará al siguiente menú:</p></div><div id=mta-selection class=imageblock><div class=content><img src=../../../../images/books/handbook/install/mta-main.png alt="mta main"></div><div class=title>Figura 53. Elegir el MTA del sistema</div></div><div class=paragraph><p>Aquí se le pide que elija qué MTA quiere instalar en su sistema. Un MTA no es otra cosa que un servidor de correo que entrega correo electrónico a los usuarios del sistema o los que acceden a través de Internet.</p></div><div class=paragraph><p>Si selecciona <span class=guimenuitem>Sendmail</span> instalará el célebre sendmail, el MTA de FreeBSD por omisión. La opción <span class=guimenuitem>Sendmail local</span> hará que sendmail sea el MTA del sistema pero desactivará la capacidad de recibir correo entrante desde Internet. Las demás opciones, <span class=guimenuitem>Postfix</span> y <span class=guimenuitem>Exim</span> son en el fonodo similares a <span class=guimenuitem>Sendmail</span>. Ambas aplicaciones gestionan correo aunque hay usuarios que los elegirían como su MTA antes que sendmail.</p></div><div class=paragraph><p>Tras elegir un MTA (o si ha elegido no usar ninguno) el menú de configuración de red nos muestra la siguiente opción: <span class=guimenuitem>NFS client</span>.</p></div><div class=paragraph><p>La opción <span class=guimenuitem>NFS client</span> configura el sistema para comunicarse con servidores NFS. Un servidor NFS permite que, mediante el uso del protocolo NFS, otras máquinas de la red puedan acceder a sus sistemas de ficheros. Si no hay más máquinas en su red puede dejar la opción sin seleccionar. El sistema puede necesitar más configuración; consulte la <a href=./#network-nfs>NFS</a> para más información sobre cómo configurar el cliente y el servidor.</p></div><div class=paragraph><p>La siguiente opción es <span class=guimenuitem>NFS server</span>, que le permitirá configurar su sistema como servidor NFS. Con esta opción añadirá la información necesaria para el arranque de RPC, los servicios de llamada de procedimientos remotos. RPC se usa para coordinar conexiones entre sistemas y programas.</p></div><div class=paragraph><p>La siguiente opción es <span class=guimenuitem>Ntpdate</span>, la sincronización de la hora. Al seleccionarla verá un menú como este:</p></div><div id=Ntpdate-config class=imageblock><div class=content><img src=../../../../images/books/handbook/install/ntp-config.png alt="ntp config"></div><div class=title>Figura 54. Configuración de Ntpdate</div></div><div class=paragraph><p>Elija en el menú el servidor más cercano al lugar donde está la máquina. De este modo la sincronozación será más precisa, puesto que un servidor más lejano puede padecer de conexiones con más latencia.</p></div><div class=paragraph><p>La siguiente opción es PCNFSD. Esta opción instalará el «package» <a class=package href=https://cgit.freebsd.org/ports/tree/net/pcnfsd/>net/pcnfsd</a> desde la colección de Ports. Es una aplicación muy útil que da servicios de autentificación NFS a sistemas que son incapaces de tenerlos por sí mismos, como por ejemplo el sistema operativo MS-DOS® de Microsoft.</p></div><div class=paragraph><p>Si usa las flechas podrá ver más opciones:</p></div><div id=Network-configuration-cont class=imageblock><div class=content><img src=../../../../images/books/handbook/install/net-config-menu2.png alt="net config menu2"></div><div class=title>Figura 55. Segundo nivel de configuración de red</div></div><div class=paragraph><p>Las aplicaciones <a href="https://man.freebsd.org/cgi/man.cgi?query=rpcbind&amp;sektion=8&amp;format=html">rpcbind(8)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=rpc.statd&amp;sektion=8&amp;format=html">rpc.statd(8)</a> y <a href="https://man.freebsd.org/cgi/man.cgi?query=rpc.lockd&amp;sektion=8&amp;format=html">rpc.lockd(8)</a> utilities se utilizan en las llamadas de procesos remotos (RPC). <code>rpcbind</code> gestiona la comunicación entre servidores y clientes NFS; los servidores NFS lo necesitan para poder funcionar correctamente. El dæmon rpc.statd se comunica con el dæmon rpc.statd de otras máquinas para facilitar seguimiento de estado. La información de estado se deposita por omisión en <span class=filename>/var/db/statd.status</span>. La siguiente opción que vemos es <span class=guimenuitem>rpc.lockd</span>; si se selecciona facilita servicios de bloqueo de ficheros. Se suele usar conjuntamente con rpc.statd para monitorizar qué máquina pide bloqueos y con qué frecuencia. Si bien es cierto que estas dos útimas opciones son fantásticas para depuración, también lo es que no son necesarias para que clientes y servidores NFS funcionen correctamente.</p></div><div class=paragraph><p>El siguiente elemento de la lista es <span class=guimenuitem>Routed</span>, un dæmon de encaminamiento. <a href="https://man.freebsd.org/cgi/man.cgi?query=routed&amp;sektion=8&amp;format=html">routed(8)</a> gestiona tablas de rutas, encuentra «routers» multicast y, bajo petición, facilita una copia de la tabla de rutas a cualquier máquina conectada físicamente a la red. Suele usarse principalmente en máquinas que hacen funciones de pasarela de una red local. Si la selecciona verá un menú en el que se le requerirá que indique la ubicación de la aplicación. Por omisión ya está configurada, así que basta que la confirme pulsando <kbd>Intro</kbd> key. Se le presentará un menú más, pidiendole esta vez parámetros que quiera proporcionarle a routed. Por omisión <code>-q</code> estará ya dispuesto y debería aparecer así en pantalla.</p></div><div class=paragraph><p>La siguiente opción que aparece es <span class=guimenuitem>Rwhod</span>; si la selecciona arrancará el dæmon <a href="https://man.freebsd.org/cgi/man.cgi?query=rwhod&amp;sektion=8&amp;format=html">rwhod(8)</a> durante el arranque del sistema. La aplicación <code>rwhod</code> envía mensajes del sistema (en broadcast) periódicamente a través de la red, o si está en modo «consumer» los va recogiendo. Tiene más información en las páginas de manual de <a href="https://man.freebsd.org/cgi/man.cgi?query=ruptime&amp;sektion=1&amp;format=html">ruptime(1)</a> y <a href="https://man.freebsd.org/cgi/man.cgi?query=rwho&amp;sektion=1&amp;format=html">rwho(1)</a>.</p></div><div class=paragraph><p>La siguiente opción del menú está relacionada con el dæmon <a href="https://man.freebsd.org/cgi/man.cgi?query=sshd&amp;sektion=8&amp;format=html">sshd(8)</a>. Se trata del servidor de shell segura de OpenSSH y le recomendamos encarecidamente su uso en lugar de los servidores telnet y FTP. El servidor sshd se usa para crear una conexión segura de una máquina a otra mediante conexiones cifradas.</p></div><div class=paragraph><p>La última opción es <span class=guimenuitem>TCP Extensions</span>, que activa las extensiones TCP definidas en las RFC 1323 y RFC 1644. En algunas máquinas puede acelerar conexiones, pero también puede haber conexiones que se pierdan. No se recomienda su uso en servidores, pero puede ser de utilidad en máquinas aisladas.</p></div><div class=paragraph><p>Una vez configurados los servicios de red, vaya al principio del menú ( <span class=guimenuitem>X Exit</span>)a o vuelva a sysinstall seleccionando dos veces <span class=guimenuitem>X Exit</span> y después <b class=button>X Exit Install</b>.</p></div></div><div class=sect3><h4 id=freebsdboot>2.10.16. El arranque de FreeBSD<a class=anchor href=#freebsdboot></a></h4><div class=sect4><h5 id=freebsdboot-i386>2.10.16.1. El arranque de FreeBSD/i386<a class=anchor href=#freebsdboot-i386></a></h5><div class=paragraph><p>Si todo ha ido bien debería ver una pantalla de mensajes pasando frente a usted hasta que llegue a lo que llamamos un «login prompt». Puede volver a ver los mensajes del arranque pulsando <kbd>Bloq Deslp</kbd> y usando <kbd>RePág</kbd> y <kbd>AvPág</kbd>. Pulsando <kbd>Bloq Despl</kbd> otra vez volverá al prompt.</p></div><div class=paragraph><p>El mensaje del arranque no puede mostrarse completo debido a las limitaciones del búfer, pero puede consultarse desde la shell mediante <code>dmesg</code>.</p></div><div class=paragraph><p>Entre al sistema utilizando un nombre de usuario y contraseña que haya creado durante la instalación (en nuestro ejemplo <code>rpratt</code>). Evite entrar al sistema como <code>root</code> salvo en los casos en los que sea estrictamente necesario.</p></div><div class=paragraph><p>Este es un típico mensaje de arranque (se ha eliminado la información de la versión):</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Copyright <span class=o>(</span>c<span class=o>)</span> 1992-2002 The FreeBSD Project.
Copyright <span class=o>(</span>c<span class=o>)</span> 1979, 1980, 1983, 1986, 1988, 1989, 1991, 1992, 1993, 1994
        The Regents of the University of California. All rights reserved.

Timecounter <span class=s2>&#34;i8254&#34;</span>  frequency 1193182 Hz
CPU: AMD-K6<span class=o>(</span>tm<span class=o>)</span> 3D processor <span class=o>(</span>300.68-MHz 586-class CPU<span class=o>)</span>
  Origin <span class=o>=</span> <span class=s2>&#34;AuthenticAMD&#34;</span>  Id <span class=o>=</span> 0x580  Stepping <span class=o>=</span> 0
  <span class=nv>Features</span><span class=o>=</span>0x8001bf&lt;FPU,VME,DE,PSE,TSC,MSR,MCE,CX8,MMX&gt;
  AMD <span class=nv>Features</span><span class=o>=</span>0x80000800&lt;SYSCALL,3DNow!&gt;
real memory  <span class=o>=</span> 268435456 <span class=o>(</span>262144K bytes<span class=o>)</span>
config&gt; di sn0
config&gt; di lnc0
config&gt; di le0
config&gt; di ie0
config&gt; di fe0
config&gt; di cs0
config&gt; di bt0
config&gt; di aic0
config&gt; di aha0
config&gt; di adv0
config&gt; q
avail memory <span class=o>=</span> 256311296 <span class=o>(</span>250304K bytes<span class=o>)</span>
Preloaded elf kernel <span class=s2>&#34;kernel&#34;</span> at 0xc0491000.
Preloaded userconfig_script <span class=s2>&#34;/boot/kernel.conf&#34;</span> at 0xc049109c.
md0: Malloc disk
Using <span class=nv>$PIR</span> table, 4 entries at 0xc00fde60
npx0: &lt;math processor&gt; on motherboard
npx0: INT 16 interface
pcib0: &lt;Host to PCI bridge&gt; on motherboard
pci0: &lt;PCI bus&gt; on pcib0
pcib1: &lt;VIA 82C598MVP <span class=o>(</span>Apollo MVP3<span class=o>)</span> PCI-PCI <span class=o>(</span>AGP<span class=o>)</span> bridge&gt; at device 1.0 on pci0
pci1: &lt;PCI bus&gt; on pcib1
pci1: &lt;Matrox MGA G200 AGP graphics accelerator&gt; at 0.0 irq 11
isab0: &lt;VIA 82C586 PCI-ISA bridge&gt; at device 7.0 on pci0
isa0: &lt;ISA bus&gt; on isab0
atapci0: &lt;VIA 82C586 ATA33 controller&gt; port 0xe000-0xe00f at device 7.1 on pci0
ata0: at 0x1f0 irq 14 on atapci0
ata1: at 0x170 irq 15 on atapci0
uhci0: &lt;VIA 83C572 USB controller&gt; port 0xe400-0xe41f irq 10 at device 7.2 on pci0
usb0: &lt;VIA 83C572 USB controller&gt; on uhci0
usb0: USB revision 1.0
uhub0: VIA UHCI root hub, class 9/0, rev 1.00/1.00, addr 1
uhub0: 2 ports with 2 removable, self powered
chip1: &lt;VIA 82C586B ACPI interface&gt; at device 7.3 on pci0
ed0: &lt;NE2000 PCI Ethernet <span class=o>(</span>RealTek 8029<span class=o>)&gt;</span> port 0xe800-0xe81f irq 9 at
device 10.0 on pci0
ed0: address 52:54:05:de:73:1b, <span class=nb>type </span>NE2000 <span class=o>(</span>16 bit<span class=o>)</span>
isa0: too many dependant configs <span class=o>(</span>8<span class=o>)</span>
isa0: unexpected small tag 14
fdc0: &lt;NEC 72065B or clone&gt; at port 0x3f0-0x3f5,0x3f7 irq 6 drq 2 on isa0
fdc0: FIFO enabled, 8 bytes threshold
fd0: &lt;1440-KB 3.5<span class=s2>&#34; drive&gt; on fdc0 drive 0
atkbdc0: &lt;keyboard controller (i8042)&gt; at port 0x60-0x64 on isa0
atkbd0: &lt;AT Keyboard&gt; flags 0x1 irq 1 on atkbdc0
kbd0 at atkbd0
psm0: &lt;PS/2 Mouse&gt; irq 12 on atkbdc0
psm0: model Generic PS/2 mouse, device ID 0
vga0: &lt;Generic ISA VGA&gt; at port 0x3c0-0x3df iomem 0xa0000-0xbffff on isa0
sc0: &lt;System console&gt; at flags 0x1 on isa0
sc0: VGA &lt;16 virtual consoles, flags=0x300&gt;
sio0 at port 0x3f8-0x3ff irq 4 flags 0x10 on isa0
sio0: type 16550A
sio1 at port 0x2f8-0x2ff irq 3 on isa0
sio1: type 16550A
ppc0: &lt;Parallel port&gt; at port 0x378-0x37f irq 7 on isa0
ppc0: SMC-like chipset (ECP/EPP/PS2/NIBBLE) in COMPATIBLE mode
ppc0: FIFO with 16/16/15 bytes threshold
ppbus0: IEEE1284 device found /NIBBLE
Probing for PnP devices on ppbus0:
plip0: &lt;PLIP network interface&gt; on ppbus0
lpt0: &lt;Printer&gt; on ppbus0
lpt0: Interrupt-driven port
ppi0: &lt;Parallel I/O&gt; on ppbus0
ad0: 8063MB &lt;IBM-DHEA-38451&gt; [16383/16/63] at ata0-master using UDMA33
ad2: 8063MB &lt;IBM-DHEA-38451&gt; [16383/16/63] at ata1-master using UDMA33
acd0: CDROM &lt;DELTA OTC-H101/ST3 F/W by OIPD&gt; at ata0-slave using PIO4
Mounting root from ufs:/dev/ad0s1a
swapon: adding /dev/ad0s1b as swap device
Automatic boot in progress...
/dev/ad0s1a: FILESYSTEM CLEAN; SKIPPING CHECKS
/dev/ad0s1a: clean, 48752 free (552 frags, 6025 blocks, 0.9% fragmentation)
/dev/ad0s1f: FILESYSTEM CLEAN; SKIPPING CHECKS
/dev/ad0s1f: clean, 128997 free (21 frags, 16122 blocks, 0.0% fragmentation)
/dev/ad0s1g: FILESYSTEM CLEAN; SKIPPING CHECKS
/dev/ad0s1g: clean, 3036299 free (43175 frags, 374073 blocks, 1.3% fragmentation)
/dev/ad0s1e: filesystem CLEAN; SKIPPING CHECKS
/dev/ad0s1e: clean, 128193 free (17 frags, 16022 blocks, 0.0% fragmentation)
Doing initial network setup: hostname.
ed0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
        inet 192.168.0.1 netmask 0xffffff00 broadcast 192.168.0.255
        inet6 fe80::5054::5ff::fede:731b%ed0 prefixlen 64 tentative scopeid 0x1
        ether 52:54:05:de:73:1b
lo0: flags=8049&lt;UP,LOOPBACK,RUNNING,MULTICAST&gt; mtu 16384
        inet6 fe80::1%lo0 prefixlen 64 scopeid 0x8
        inet6 ::1 prefixlen 128
        inet 127.0.0.1 netmask 0xff000000
Additional routing options: IP gateway=YES TCP keepalive=YES
routing daemons:.
additional daemons: syslogd.
Doing additional network setup:.
Starting final network daemons: creating ssh RSA host key
Generating public/private rsa1 key pair.
Your identification has been saved in /etc/ssh/ssh_host_key.
Your public key has been saved in /etc/ssh/ssh_host_key.pub.
The key fingerprint is:
cd:76:89:16:69:0e:d0:6e:f8:66:d0:07:26:3c:7e:2d root@k6-2.example.com
 creating ssh DSA host key
Generating public/private dsa key pair.
Your identification has been saved in /etc/ssh/ssh_host_dsa_key.
Your public key has been saved in /etc/ssh/ssh_host_dsa_key.pub.
The key fingerprint is:
f9:a1:a9:47:c4:ad:f9:8d:52:b8:b8:ff:8c:ad:2d:e6 root@k6-2.example.com.
setting ELF ldconfig path: /usr/lib /usr/lib/compat /usr/X11R6/lib
/usr/local/lib
a.out ldconfig path: /usr/lib/aout /usr/lib/compat/aout /usr/X11R6/lib/aout
starting standard daemons: inetd cron sshd usbd sendmail.
Initial rc.i386 initialization:.
rc.i386 configuring syscons: blank_time screensaver moused.
Additional ABI support: linux.
Local package initialization:.
Additional TCP options:.

FreeBSD/i386 (k6-2.example.com) (ttyv0)

login: rpratt
Password:</span></code></pre></div></div><div class=paragraph><p>La generación de claves RSA y DSA puede llevar su tiempo en máquinas lentas. Esto solamente sucede en el primer arranque después de la instalación. Los demás arranques serán más rápidos.</p></div><div class=paragraph><p>Si ya hay un servidor X configurado y ha elegido un escritorio por omisión puede arrancarlo tecleando <code>startx</code> en la shell.</p></div></div><div class=sect4><h5 id=_el_arranque_de_freebsdalpha>2.10.16.2. El arranque de FreeBSD/alpha<a class=anchor href=#_el_arranque_de_freebsdalpha></a></h5><div class=paragraph><p>Una vez acabado el proceso de instalación podrá arrancar FreeBSD tecleando algo muy parecido a esto en el prompt de SRM:</p></div><div class=paragraph><p>Once the install procedure has finished, you will be able to start FreeBSD by typing something like this to the SRM prompt:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=o>&gt;&gt;&gt;</span>BOOT DKC0</code></pre></div></div><div class=paragraph><p>Esto hace que el firmware arranque desde el disco especificado. Para que FreeBSD arranque automáticamente de ahí en adelante utilice lo siguiente:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=o>&gt;&gt;&gt;</span> SET BOOT_OSFLAGS A
<span class=o>&gt;&gt;&gt;</span> SET BOOT_FILE <span class=s1>&#39;&#39;</span>
<span class=o>&gt;&gt;&gt;</span> SET BOOTDEF_DEV DKC0
<span class=o>&gt;&gt;&gt;</span> SET AUTO_ACTION BOOT</code></pre></div></div><div class=paragraph><p>Los mensajes de arranque serán muy similares (aunque no iguales) a los que aparecen durante el arranque de FreeBSD en i386™.</p></div></div></div><div class=sect3><h4 id=shutdown>2.10.17. El apagado de FreeBSD<a class=anchor href=#shutdown></a></h4><div class=paragraph><p>Es importante apagar correctamente el sistema operativo. No basta con darle al interruptor. Lo primero que debe hacer es convertirse en superusuario tecleando en la shell <code>su</code> e introduciendo la contraseña de <code>root</code>. Tenga en cuenta que esto funcionará solamente si el usuario es miembro del grupo <code>wheel</code>. Si no lo es siempre puede acceder al sistema como <code>root</code> y utilizar <code>shutdown -h now</code>.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>The operating system has halted.
Please press any key to reboot.</code></pre></div></div><div class=paragraph><p>Una vez que vea el mensaje de «<em>Please press any key to reboot</em> » puede apagar la máquina. Si pulsa cualquier tecla en lugar de apagar la máquina el sistema reiniciará.</p></div><div class=paragraph><p>También puede usar la combinación de teclas <span class=keyseq><kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>Supr</kbd></span> para reiniciar el sistema, aunque no le recomendamos que lo haga durante el funcionamiento normal del sistema.</p></div></div></div><div class=sect2><h3 id=install-trouble>2.11. Solución de problemas<a class=anchor href=#install-trouble></a></h3><div class=paragraph><p>Esta sección trata sobre la solución de problemas habituales durante la instalación que la comunidad de usuarios ha documentado. Hay también unas cuantas preguntas y respuestas para quienes quieren poder elegir en el arranque entre FreeBSD y MS-DOS®.</p></div><div class=sect3><h4 id=_qué_hacer_si_algo_va_mal>2.11.1. Qué hacer si algo va mal<a class=anchor href=#_qué_hacer_si_algo_va_mal></a></h4><div class=paragraph><p>A causa de las diversas limitaciones de la arquitectura PC es imposible hacer que nada funcione con un 100% de probabilidades, pero al menos hay unas cuantas cosas que pueden hacerse si algo va mal.</p></div><div class=paragraph><p>Consulte la <a href=http://www.FreeBSD.org/releases/>lista de hardware soportado</a> de su versión de FreeBSD y asegúrese de que su hardware debería funcionar con ella.</p></div><div class=paragraph><p>Si su hardware está soportado y sigue experimentando «cuelgues» u otro tipo de problemas tendrá que <a href=./#kernelconfig>compilar un kernel personalizado</a>. Esto le permitirá disponer de soporte que no está incluido en el kernel <span class=filename>GENERIC</span>. El kernel que se incluye en los discos de arranque está configurado asumiendo que la mayoría de los dispositivos van a funcionar con la configuración por omisión de fábrica (en términos de IRQ, direcciones IO y canales DMA). Si su hardware ha sido reconfigurado quizás tendrá que usar el editor de configuración para decirle a FreeBSD dónde encontrar cada cosa.</p></div><div class=paragraph><p>Es posible también que la prueba de un dispositivo que no está en el sistema cause problemas más tarde al probar un dispositivo que sí está en la máquina. Si ese puede ser su caso desactive las pruebas de controladores conflictivos.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Algunos problemas de instalación pueden evitarse o al menos aliviarse actualizando el firmware de ciertos tipos de hardware; esto es especialmente cierto en el caso de las placas El firmware de las placas base se llama también BIOS y la mayoría de las placas base y de los fabricantes de computadoras tienen un sitio web en el que suelen encontrarse actualizaciones e información sobre su uso.</p></div><div class=paragraph><p>La mayoría de los fabricantes recomienda que no se actualice la BIOS de la placa base a menos que tenga una buena razón para hacerlo, por ejemplo una actualización crítica. El proceso de actualización <em>podría</em> fallar, lo que puede acarrrear daños en el chip de la BIOS.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=_uso_de_sistemas_de_ficheros_de_ms_dos_y_windows>2.11.2. Uso de sistemas de ficheros de MS-DOS® y Windows®<a class=anchor href=#_uso_de_sistemas_de_ficheros_de_ms_dos_y_windows></a></h4><div class=paragraph><p>No puede usar sistemas de ficheros comprimidos con Double Space™. Deberá por lo tanto descomprimir el sistema de ficheros antes de acceder a los datos desde FreeBSD. Ejecute el Agente de compresión desde <span class=guimenuitem>Inicio</span> > <span class=guimenuitem>Programas</span> > <span class=guimenuitem>Herramientas del sistema</span>.</p></div><div class=paragraph><p>FreeBSD puede usar sistemas de ficheros MS-DOS®. <a href="https://man.freebsd.org/cgi/man.cgi?query=mount_msdos&amp;sektion=8&amp;format=html">mount_msdos(8)</a> inserta estos sistemas de ficheros en la jerarquía de directorios del sistema, haciendo posible el acceso a los datos. <a href="https://man.freebsd.org/cgi/man.cgi?query=mount_msdos&amp;sektion=8&amp;format=html">mount_msdos(8)</a> no suele usarse directamente; el sistema lo utiliza debido a alguna entrada en <span class=filename>/etc/fstab</span> o porque <a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a> lo invoque debido a que se le hayan dado los parámetros adecuados para ello.</p></div><div class=paragraph><p>Veamos una de esas entradas en el fichero <span class=filename>/etc/fstab</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>/dev/ad0sN  /dos  msdosfs rw  0	0</pre></div></div><div class=paragraph><p>El directorio <span class=filename>/dos</span> debe existir previamente o no funcionará. Tiene todos los detalles del formato correcto de las entradas en <span class=filename>/etc/fstab</span> en <a href="https://man.freebsd.org/cgi/man.cgi?query=fstab&amp;sektion=5&amp;format=html">fstab(5)</a>.</p></div><div class=paragraph><p>Veamos ahora un ejemplo de llamada de <a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a> a un sistema de ficheros MS-DOS®:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount_msdos /dev/ad0s1 /mnt</span></code></pre></div></div><div class=paragraph><p>En el ejemplo el sistema de ficheros MS-DOS® está en la primera partición del primer disco duro. La situación en su sistema puede ser diferente: compruebe la salida de <code>dmesg</code> y <code>mount</code>. Deberían darle suficiente información como para darle una idea completa de la estructura de particiones en la que está trabajando.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>FreeBSD suele numerar las las «slices» (que es como decir los sistemas de ficheros MS-DOS®) de un modo distinto al de otros sistemas operativos. Más concretamente, las particiones extendidas de MS-DOS® suelen tener un número mayor de «slice» que las particiones primarias de MS-DOS®. <a href="https://man.freebsd.org/cgi/man.cgi?query=fdisk&amp;sektion=8&amp;format=html">fdisk(8)</a> le será de ayuda a la hora de determinar qué «slices» pertenecen a FreeBSD y cuáles a otros sistemas operativos.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Las particiones NTFS se montan de una forma muy similar gracias a <a href="https://man.freebsd.org/cgi/man.cgi?query=mount_ntfs&amp;sektion=8&amp;format=html">mount_ntfs(8)</a>.</p></div></div><div class=sect3><h4 id=_preguntas_y_respuestas_de_la_resolución_de_problemas>2.11.3. Preguntas y respuestas de la resolución de problemas<a class=anchor href=#_preguntas_y_respuestas_de_la_resolución_de_problemas></a></h4><div class=sect4><h5 id=_mi_sistema_se_cuelga_durante_el_arranque_o_se_comporta_de_modo_extraño_durante_la_instalación_o_no_llega_a_comprobar_el_funcionamiento_del_lector_de_disquetes>2.11.3.1. Mi sistema se «cuelga» durante el arranque, o se comporta de modo extraño durante la instalación, o no llega a comprobar el funcionamiento del lector de disquetes.<a class=anchor href=#_mi_sistema_se_cuelga_durante_el_arranque_o_se_comporta_de_modo_extraño_durante_la_instalación_o_no_llega_a_comprobar_el_funcionamiento_del_lector_de_disquetes></a></h5><div class=paragraph><p>FreeBSD utiliza profusamente el servicio ACPI del sistema en las plataformas i386, amd64 e ia64 con el fin de ayudar en la configuración del sistema durante la detección de hardware durante el arranque. Por desgracia todavía hay errores tanto en el controlador ACPI como en algunas BIOS y placas base. Puede desactivar ACPI en la tercera fase del cargador de arranque del sistema haciendo que <code>hint.acpi.0.disabled</code> tenga el siguiente valor:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> <span class=nb>set </span>hint.acpi.0.disabled<span class=o>=</span><span class=s2>&#34;1&#34;</span></code></pre></div></div><div class=paragraph><p>Tenga en cuenta que tendría que volver a hacerlo cada vez que el sistema arranque, así que añada <code>hint.acpi.0.disabled="1"</code> al fichero <span class=filename>/boot/loader.conf</span>. Tiene más información sobre el cargador de arranque en <a href=./#boot-synopsis>Sinopsis</a>.</p></div></div><div class=sect4><h5 id=_cuando_voy_a_arrancar_freebsd_por_primera_vez_después_de_la_instalación_el_kernel_carga_y_prueba_mi_hardware_pero_se_detiene_y_muestra_mensajes_como_este>2.11.3.2. Cuando voy a arrancar FreeBSD por primera vez después de la instalación el kernel carga y prueba mi hardware, pero se detiene y muestra mensajes como este:<a class=anchor href=#_cuando_voy_a_arrancar_freebsd_por_primera_vez_después_de_la_instalación_el_kernel_carga_y_prueba_mi_hardware_pero_se_detiene_y_muestra_mensajes_como_este></a></h5><div class=paragraph><p>Hay un problema que ya lleva tiempo con nosotros cuando el disco desde el que se arranca no es el primero en el sistema. La BIOS utiliza un esquema de numeración distinto al que usa FreeBSD y a veces saber qué número es el que corresponde a qué resulta un poco complicado.</p></div><div class=paragraph><p>Cuando el disco de arranque no sea el primer disco del sistema FreeBSD necesitará un poco de ayuda para poderlo encontrar. Puede haber dos escenarios donde suceda esto y en ambos hay que decirle a FreeBSD, dónde encontrar el sistema de ficheros raíz. Esto se hace especificando el número de disco según la BIOS, el tipo de disco y el número de disco que FreeBSD le dará a ese disco.</p></div><div class=paragraph><p>El primer caso es cuando hay dos discos IDE, ambos configurados como maestros de sus respectivos buses IDE y quiere usted arrancar desde el segundo disco. La BIOS dice que son el disco 0 y el disco 1, mientras que FreeBSD los ve como <span class=filename>ad0</span> y <span class=filename>ad2</span>.</p></div><div class=paragraph><p>FreeBSD está en el disco BIOS 1, de tipo <code>ad</code> y el número de disco FreeBSD es el 2, así que habrá que decir lo siguiente:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>1:ad<span class=o>(</span>2,a<span class=o>)</span>kernel</code></pre></div></div><div class=paragraph><p>Tenga en cuenta que si tiene un disco esclavo en el bus primario esto no es necesario (de hecho es un error hacerlo).</p></div><div class=paragraph><p>El segundo escenario es el arranque desde un disco SCSI teniendo uno o más discos IDE en el sistema. En este caso el número de disco FreeBSD es más bajo que el número de disco BIOS. Si tiene dos discos IDE además del disco SCSI, el disco SCSI es el disco 2 de BIOS, del tipo <code>da</code> y para FreeBSD es el disco número disk number 0, so 0, así que tendrá que usar</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>2:da<span class=o>(</span>0,a<span class=o>)</span>kernel</code></pre></div></div><div class=paragraph><p>para decirle a FreeBSD que quiere arrancar desde el disco 2 de BIOS, que es el primer disco SCSI del sistema. Si solamente tiene un disco IDE tendrá que poner <code>1:</code>.</p></div><div class=paragraph><p>Una vez que sabe con exactitud los valores que debe usar póngalos exactamente como los ha tecleado en <span class=filename>/boot.config</span> utilizando el editor de texto que prefiera. Salvo que se le diga lo contrario FreeBSD utilizará el contenido de este fichero decidiráel comportamiento por omisión del prompt de <code>boot:</code> prompt.</p></div></div><div class=sect4><h5 id=_cuando_voy_a_arrancar_desde_disco_duro_por_primera_vez_tras_la_instalación_de_freebsd_el_prompt_del_gestor_de_arranque_muestra_f_en_el_menú_de_arranque_y_no_pasa_de_ahí>2.11.3.3. Cuando voy a arrancar desde disco duro por primera vez tras la instalación de FreeBSD el prompt del gestor de arranque muestra F? en el menú de arranque y no pasa de ahí.<a class=anchor href=#_cuando_voy_a_arrancar_desde_disco_duro_por_primera_vez_tras_la_instalación_de_freebsd_el_prompt_del_gestor_de_arranque_muestra_f_en_el_menú_de_arranque_y_no_pasa_de_ahí></a></h5><div class=paragraph><p>La geometría del disco duro se configuró mal cuando se utilizó el editor de particiones durante la instalación. Ejecute el editor de particiones e introduzca la geometría del disco correctamente. Tendrá que reinstalar FreeBSD completamente dado que habrá cambiado la geometría del disco.</p></div><div class=paragraph><p>Si no encuentra la manera de saber cuál es la geometría correcta pruebe con esto: Cree una pequeña partición DOS al principio del disco e instale FreeBSD en el espacio de disco inmediatamente contiguo. El programa de instalación verá la partición DOS e intentará deducir la geometría correcta a partir de ahí; esto suele funcionar.</p></div><div class=paragraph><p>Le mostramos otra sugerencia que, aunque no es recomendable de seguir, se muestra para que sirva de referencia:</p></div><div class="paragraph blockquote"><p>Si lo que está instalando es un servidor o máquina de escritorio dedicado a FreeBSD y no le preocupa que en el futuro cercano tenga que mantener la convivencia con DOS, Linux u otro sistema operativo siempre tiene la opción de utilizar el disco entero (la opción <span class=guimenuitem>A</span> en el editor de particiones). Es una opción no estándar gracias a la cual FreeBSD ocupa todo el disco, desde el primer sector al último. De este modo nos olvidamos de todos los problemas relacionados con la geometría de disco, pero le obliga a no poder instalar ningún otro sistema operativo aparte de FreeBSD en ese disco.</p></div></div><div class=sect4><h5 id=_el_sistema_encuentra_mi_tarjeta_de_red_ed4_pero_me_dan_errores_de_timeout>2.11.3.4. El sistema encuentra mi tarjeta de red <a href="https://man.freebsd.org/cgi/man.cgi?query=ed&amp;sektion=4&amp;format=html">ed(4)</a> pero me dan errores de «timeout».<a class=anchor href=#_el_sistema_encuentra_mi_tarjeta_de_red_ed4_pero_me_dan_errores_de_timeout></a></h5><div class=paragraph><p>Lo más probable es que su tarjeta esté utilizando una IRQ distinta de la que debería estar usando según lo que aparece en <span class=filename>/boot/device.hints</span> . El controlador <a href="https://man.freebsd.org/cgi/man.cgi?query=ed&amp;sektion=4&amp;format=html">ed(4)</a> no utiliza configuración does not use the «soft» por omisión (es decir, valores que se le suministren mediante EZSETUP bajo DOS) pero como casi todo en esta vida hay solución. En este caso, de hecho, hay dos.</p></div><div class=paragraph><p>Ponga el «jumper» de la tarjeta en una configuración «dura» (es posible que tenga que modificar la configuración del kernel debido a esto) o modifique el valor de la IRQ con el valor <code>-1</code> del siguiente modo: by setting the hint <code>hint.ed.0.irq="-1"</code>. Así le dirá al kernel que utilice la configuración «suave».</p></div><div class=paragraph><p>Hay otra posibilidad, que es cuando su tarjeta esté utilizando la IRQ 9, que suele compartir funciones con la IRQ 2, circunstancia que es con frecuencia causa de problemas (sobre todo cuando entra en escena una tarjeta VGA que utiliza justamente la IRQ 2). Le recomendamos encarecidamente que haga todo lo posible para no utilizar ni la IRQ 2 ni la IRQ 9.</p></div></div></div></div><div class=sect2><h3 id=install-advanced>2.12. Guía avanzada de instalación<a class=anchor href=#install-advanced></a></h3><div class=paragraph><p>This section describes how to install FreeBSD in exceptional cases.</p></div><div class=sect3><h4 id=headless-install>2.12.1. Instalación de FreeBSD en un sistema sin monitor o teclado<a class=anchor href=#headless-install></a></h4><div class=paragraph><p>Es posible instalar FreeBSD en máquinas que no tengan teclado ni siquiera monitor conectado. De hecho no tienen por qué tener ni salida VGA. ?Cómo es posible?, se preguntará: Haciendolo todo a través de una consola serie. Una consola serie consiste básicamente en usar otro sistema como la pantalla y el teclado de una máquina. Siga las instrucciones de creación de los disquetes que se detallan en la <a href=#install-floppies>Preparación del medio de arranque</a>.</p></div><div class=paragraph><p>Tendrá que modificar esos disquetes para que arranquen en la consola serie; siga estas instrucciones:</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Modificación de los disquetes de arranque para que permitan el arranque en la consola serie</p><div class=paragraph><p>Si arrancara con los disquetes que acaba de crear FreeBSD arrancaría en el modo normal de instalación. Lo que queremos es que FreeBSD arranque en una consola serie, así que hemos de montar el disquete <span class=filename>kern.flp</span> en un sistema FreeBSD mediante <a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a>.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount /dev/fd0 /mnt</span></code></pre></div></div><div class=paragraph><p>Una vez montado el disquete entre en el directorio <span class=filename>/mnt</span> :</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /mnt</span></code></pre></div></div><div class=paragraph><p>Aquí es donde enseñaremos al disquete a arrancar en la consola serie. Debe crearse un fichero llamado <span class=filename>boot.config</span> que contenga lo siguiente: <code>/boot/loader -h</code>. Con esto le pasamos cargador de arranque (el «bootloader») el parámetro necesario para que intente arrancar en una consola serie.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># echo &#34;/boot/loader -h&#34;  boot.config</span></code></pre></div></div><div class=paragraph><p>Una vez configurado correctamente nuestro disquete lo desmontamos con <a href="https://man.freebsd.org/cgi/man.cgi?query=umount&amp;sektion=8&amp;format=html">umount(8)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /</span>
<span class=c># umount /mnt</span></code></pre></div></div><div class=paragraph><p>Y podemos extraer el disquete de la unidad.</p></div></li><li><p>Conexión del cable modem</p><div class=paragraph><p>Tiene que conectar un <a href=./#term-cables-null>cable módem nulo</a> entre dos máquinas. <em>Un cable serie normal no funcionará</em>, necesitará un cable módem nulo porque tiene cruzado alguno de los hilos.</p></div></li><li><p>Arranque de la instalación</p><div class=paragraph><p>Podemos iniciar la instalación. Introduzca el disquete <span class=filename>kern.flp</span> en la unidad de disquetes de la máquina en la que quiere hacer la instalación y encienda la máquina.</p></div></li><li><p>La conexión a su máquina sin teclado ni monitor</p><div class=paragraph><p>Conéctese usando <a href="https://man.freebsd.org/cgi/man.cgi?query=cu&amp;sektion=1&amp;format=html">cu(1)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cu -l /dev/cuaa0</span></code></pre></div></div></li></ol></div></div></div><div class=paragraph><p>?Ya está! Desde este momento ya puede controlar su máquina sin monitor ni teclado desde la sesión <code>cu</code> que acaba de abrir. El sistema le pedirá que introduzca el disco <span class=filename>kern1.flp</span> y después tendrá que elegir qué tipo de terminal va a utilizar. Elija la consola en color de FreeBSD y buena suerte con la instalación.</p></div></div></div><div class=sect2><h3 id=install-diff-media>2.13. Cómo preparar su propio medio de instalación<a class=anchor href=#install-diff-media></a></h3><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Para evitar la repetición «disco FreeBSD» será en adelante un CDROM o un DVD de FreeBSD que haya comprado o hecho por sus propios medios.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Es posible que tengaque crear su propio medio de instalación de FreeBSD. Puede tratarse de un medio físico como una cinta o una fuente para que sysinstall pueda obtener los ficheros que vaya necesitando, como un sitio FTP local, o bien puede tratarse de una partición MS-DOS®.</p></div><div class=paragraph><p>Por ejemplo:</p></div><div class=ulist><ul><li><p>Tiene muchas máquinas conectadas a una red local y un sólo disco FreeBSD. Quiere crear un sitio FTP local con el contenido del disco FreeBSD y que desde él sus máquinas obtengan los ficheros en lugar de tener que conectarse a Internet.</p></li><li><p>Tiene un disco FreeBSD y FreeBSD no reconoce su unidad CD/DVD pero MS-DOS®/Windows® sí. Quiere copiar los ficheros de instalación de FreeBSD a una partición DOS en mismo sistema y luego instalar FreeBSD usando esos ficheros.</p></li><li><p>El sistema en el que quiere instalar FreeBSD no tiene unidad CD/DVD ni tarjeta de red pero puede conectar un cable paralelo o un cable serie «Laplink» a una computadora que sí que tiene.</p></li><li><p>Quiere crear una cinta desde la que se pueda instalar FreeBSD.</p></li></ul></div><div class=sect3><h4 id=install-cdrom>2.13.1. Creación de un CDROM de instalación<a class=anchor href=#install-cdrom></a></h4><div class=paragraph><p>Con cada «release» el Proyecto FreeBSD libera dos imágenes de CDROM («imágenes ISO»). Dichas imágenes pueden copiarse a CD si dispone de una grabadora y usarse posteriormente para instalar FreeBSD. Si tiene una grabadora de CD y el ancho de banda no le supone un problema la forma más fácil de instalar FreeBSD es esta.</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Descargar la imagen ISO correcta</p><div class=paragraph><p>Puede descargar las imágenes ISO de cada «release» desde <span class=filename><a href=ftp://ftp.FreeBSD.org/pub/FreeBSD/ISO-IMAGES-arquitectura/versión class=bare>ftp://ftp.FreeBSD.org/pub/FreeBSD/ISO-IMAGES-arquitectura/versión</a></span> o desde la réplica más próxima. Sustituya <em>arquitectura</em> y <em>versión</em> por lo que corresponda.</p></div><div class=paragraph><p>Ese directorio contendrá normalmente las siguientes imágenes:</p></div><table class="tableblock frame-none grid-all stretch"><caption class=title>Tabla 4. Nombres y funciones de las imágenes de FreeBSD 6.<em>X</em> and 7.<em>X</em></caption><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Nombre</th><th class="tableblock halign-left valign-top">Contenido</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>versión-RELEASE-arch-bootonly.iso</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Todo lo necesario para arrancar un kernel de FreeBSD y ejecutar la interfaz de instalación. Los ficheros que vayan haciendo falta tendrán que irse descargando por FTP o por algún otro medio.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>versión-RELEASE-arch-disc1.iso</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Todo lo necesario para instalar AFreeBSD y un «live filesystem», que le será muy útil (conjuntamente con la aplicación «Repair» de sysinstall.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>versión-RELEASE-arch-disc2.iso</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Todas las aplicaciones que puedan caber en un disco.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>versión-RELEASE-arch-docs.iso</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>La documentacióN de FreeBSD.</p></td></tr></tbody></table><div class=paragraph><p>Descargue la imagen ISO de arranque (si existe para su plataforma) o la imagen del disco uno. <em>No</em> descargue ambas, puesto que el disco uno contiene todo lo que hay en la imagen ISO de arranque.</p></div><div class=paragraph><p>Utilice la imagen ISO de arranque si su acceso a Internet es barato. Con ella podrá instalar FreeBSD e instalar todo tipo de software descargándolo como paquetes/ports (consulte el <a href=./#ports>Instalación de aplicaciones: «packages» y ports</a>) cuando lo precise.</p></div><div class=paragraph><p>Utilice la imagen del disco uno si quiere disponer en el propio disco de una selección bastante completa de software.</p></div><div class=paragraph><p>Si tiene acceso de alta velocidad a Internet las demás imágenes de disco son útiles pero no esenciales.</p></div></li><li><p>Escribir los CD</p><div class=paragraph><p>Si va a grabar los CD en un sistema FreeBSD consulte la <a href=./#creating-cds>Creación y uso de medios ópticos (CD)</a> (en particular la <a href=./#burncd>burncd</a> y la <a href=./#cdrecord>cdrecord</a>).</p></div><div class=paragraph><p>Las imágenes se hacen en un formato ISO estándar; si va a grabarlas en cualquier otra plataforma no debería tener problemas para hacerlo cualquiera que sea la aplicación que use para grabar CD.</p></div></li></ol></div></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Si lo que quiere hacer es crear una «release» personalizada de FreeBSD consulte el artículo <a href=https://docs.freebsd.org/en/articles/releng/>Release Engineering</a>.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=install-ftp>2.13.2. Creación de un sitio FTP local a partir de un disco de instalación de FreeBSD<a class=anchor href=#install-ftp></a></h4><div class=paragraph><p>Los discos de FreeBSD tienen la misma estructura que los sitios FTP. Esa circunstancia le facilitará mucho la tarea de crear un sitio FTP local para uso de otras máquinas de su red durante la instalación de FreeBSD.</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Monte el CDROM en el directorio <span class=filename>/cdrom</span> del sistema que va a albergar el sitio FTP.</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount /cdrom</span></code></pre></div></div></li><li><p>Cree una cuenta apta para FTP anónimo en <span class=filename>/etc/passwd</span> editando <span class=filename>/etc/passwd</span> con <a href="https://man.freebsd.org/cgi/man.cgi?query=vipw&amp;sektion=8&amp;format=html">vipw(8)</a>. Añádale lo siguiente:</p><div class="literalblock programlisting"><div class=content><pre>ftp:*:99:99::0:0:FTP:/cdrom:/nonexistent</pre></div></div></li><li><p>Compruebe que el servicio FTP está activado en <span class=filename>/etc/inetd.conf</span>.</p></li></ol></div></div></div><div class=paragraph><p>Ahora cualquier máquina capaz de conectarse a su sistema a través de una red puede elegir como medio de instalación «FTP» y escribir <code><a href=ftp://su class=bare>ftp://su</a> máquina</code> tras seleccionar «Other» en el menú de sitios FTP.</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Acabamos de exponer una buena solución para usar en un sistema de su propia red y que además está protegido por un cortafuegos. Si ofrece servicios FTP a máquinas de Internet (y no de su red local) expone su sistema a caer bajo la atención de «crackers» y otras variedades de indeseable. Le recomendamos encarecidamente que siga a rajatabla políticas sensatas de seguridad.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=_creación_de_disquetes_de_instalación>2.13.3. Creación de disquetes de instalación<a class=anchor href=#_creación_de_disquetes_de_instalación></a></h4><div class=paragraph><p>Si quiere instalar FreeBSD desde disquetes (cosa que, de antemano, le sugerimos que <em>no</em> haga) bien sea porque FreeBSD no soporta cierto componente necesario de su sistema o sencillamente porque insiste en querer hacer las cosas de la manera más difícil, tendrá que tener a mano unos cuantos disquetes.</p></div><div class=paragraph><p>Como mínimo necesitará tantos disquetes de 1.44 MB o 1.2 MB como hagan falta para dar cabida a todos los ficheros que hay en <span class=filename>bin</span>. Recuerde la entrada «binary distribution» (distribución binaria) durante la instalación. Si está generando los disquetes en DOS <em>debe formatearlos</em> con <code>FORMAT</code> de MS-DOS®. Si está usando Windows® puede usar el Explorador para formatear disquetes: botón derecho del ratón sobre la unidad <span class=filename>A:</span> y elija «Formatear».</p></div><div class=paragraph><p><em>No</em> confíe en el preformateo de fábrica de los disquetes. Formatéelos usted de nuevo, sólo para asegurarse. La mayoría de los problemas de los que se ha informado se han debido a formateos defectuosos, téngalo en cuenta.</p></div><div class=paragraph><p>Si puede crear los disquetes en una máquina FreeBSD un formateo sigue sin ser una mala idea, pero no necesitará crear un sistema de ficheros DOS en cada floppy. Use <code>disklabel</code> y <code>newfs</code> para crear un sistema de ficheros UFS en los disquetes tal y como se muestra aquí (en un floppy de 1.44 MB y 3.5") :</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># fdformat -f 1440 fd0.1440</span>
<span class=c># disklabel -w -r fd0.1440 floppy3</span>
<span class=c># newfs -t 2 -u 18 -l 1 -i 65536 /dev/fd0</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Tendrá que usar <code>fd0.1200</code> y <code>floppy5</code> si usa discos de 5.25" y 1.2 MB.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Ahora puede montarlos y escribir en ellos igual que en cualquier otro sistema de ficheros del sistema.</p></div><div class=paragraph><p>Tras el formateo de los disquetes pasamos a llenarlos. Los ficheros necesarios para crear la distribución se dividen en partes de tamaño regular de modo que cinco de ellas entren en otros tantos disquetes de 1.44 MB. Empaquete tantos ficheros como pueda en cada uno hasta que tenga todas las distribuciones que necesita listas para pasar a los disquetes. Cada distribución debería ir en un subdirectorio del floppy, por ejemplo <span class=filename>a:\bin\bin.aa</span>, <span class=filename>a:\bin\bin.ab</span>, etc.</p></div><div class=paragraph><p>Una vez en el menú de selección de medio de instalación elija <span class=guimenuitem>Floppy</span> y siga las instrucciones.</p></div></div><div class=sect3><h4 id=install-msdos>2.13.4. Instalación desde una partición MS-DOS®<a class=anchor href=#install-msdos></a></h4><div class=paragraph><p>Copie los ficheros de la distribución en un directorio llamado <span class=filename>freebsd</span> en el directorio raíz de la partición, por ejemplo <span class=filename>c:\freebsd</span>. La estructura de directorios del sitio FTP o el CDROM debe reproducirse parcialmente en este directorio, así que le sugerimos que use <code>xcopy</code> si está copiando los datos desde un CD. En el siguiente ejemplo vamos a preparar una instalación mínima de FreeBSD:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>C:<span class=se>\&gt;</span> md c:<span class=se>\f</span>reebsd
C:<span class=se>\&gt;</span> xcopy e:<span class=se>\b</span><span class=k>in </span>c:<span class=se>\f</span>reebsd<span class=se>\b</span><span class=k>in</span><span class=se>\ </span>/s
C:<span class=se>\&gt;</span> xcopy e:<span class=se>\m</span>anpages c:<span class=se>\f</span>reebsd<span class=se>\m</span>anpages<span class=se>\ </span>/s</code></pre></div></div><div class=paragraph><p>Se ha asumido que <span class=filename>C:</span> es donde tiene espacio libre y <span class=filename>E:</span> es donde tiene montada su unidad CDROM.</p></div><div class=paragraph><p>Si no tiene unidad CDROM puede descargar la distribución desde <a href=ftp://ftp.FreeBSD.org/pub/FreeBSD/releases/i386/12.0-RELEASE/>ftp.FreeBSD.org</a>. Cada distribución dispone de su propio directorio; por ejemplo, la distribución <em>base</em> está en el directorio<a href=ftp://ftp.FreeBSD.org/pub/FreeBSD/releases/i386/12.0-RELEASE/base/>12.0/base/</a>.</p></div><div class=paragraph><p>La única distribución <em>imprescindible</em> es <code>BIN</code>. Guarde esta y todas las distribuciones que quiera instalar desde una partición MS-DOS® bajo <span class=filename>c:\freebsd</span>.</p></div></div><div class=sect3><h4 id=_creación_de_una_cinta_de_instalación>2.13.5. Creación de una cinta de instalación<a class=anchor href=#_creación_de_una_cinta_de_instalación></a></h4><div class=paragraph><p>La instalación desde cinta es probablemente el método más fácil, casi tanto como una instalación desde una réplica FTP o desde un CDROM. Lo único que el programa de instalación necesita es que los ficheros estén empaquetados con tar y en una cinta. Veamos un ejemplo:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /freebsd/distdir</span>
<span class=c># tar cvf /dev/rwt0 dist1 ... dist2</span></code></pre></div></div><div class=paragraph><p>Cuando esté preparando la instalación tenga la precaución de dejar sitio suficiente en algún directorio temporal (accesible en ese momento) para dejar <em>todos los ficheros</em> que hubiera en la cinta de instalación. A causa del acceso secuencial propio del diseño de las cintas este método de instalación requiere un poco de almacenamiento temporal.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Recuerde que antes de arrancar desde el disquete de arranque la cinta <em>debe estar en la unidad</em>. La prueba de hardware de la instalación no encontraría la cinta.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=_before_installing_over_a_network>2.13.6. Before Installing over a Network<a class=anchor href=#_before_installing_over_a_network></a></h4><div class=paragraph><p>Hay tres tipos de instalación a través de una red disponibles en FreeBSD: Puerto serie (SLIP o PPP), puerto paralelo (PLIP (cable «laplink»)) y Ethernet.</p></div><div class=paragraph><p>El adaptador Ethernet es, debido a su velocidad de transferencia, la mejor elección. FreeBSD soporta la mayoría de los adaptadores Ethernet. Tiene una lista de dispositivos soportados en las notas de hardware de cada «release» de FreeBSD. Si disponde alguno de los adaptadores Ethernet PCMCIA soportados por FreeBSD recuerde que debe estar presente en el sistema <em>antes</em> de que el sistema arranque. Por desgracia FreeBSD no soporta aún la inserción en caliente de tarjetas PCMCIA durante la instalación.</p></div><div class=paragraph><p>Tendrá que saber también la dirección IP de la red, la máscara de red correcta para la clase de su red y el nombre de su máquina. Si va a instalar mediante una conexión PPP y no tiene IP estática no se preocupe, su ISP puede asignarle una IP temporal dinámicamente. Su administrador de sistemas seguramente puede ayudarle con la configuración de su red. Si va a intentar conectarse con otras máquinas mediante sus nombres en lugar de sus direcciones IP necesitará los datos de un servidor de nombres y es posible que necesite también la dirección de un «gateway» (si usa PPP vale con la dirección IP de su proveedor). Si va a instalar por FTP a través de un proxy HTTP necesitará la dirección del proxy. Si no sabe qué pueden significar todas (o la mayoría) de estas preguntas hable con su administrador de sistemas o con su ISP <em>antes</em> de intentar instalar FreeBSD de esta forma.</p></div><div class=sect4><h5 id=_antes_de_instalar_via_nfs>2.13.6.1. Antes de instalar via NFS<a class=anchor href=#_antes_de_instalar_via_nfs></a></h5><div class=paragraph><p>La instalación por NFS es bastante sencilla. Sólo tendrá que copiar los ficheros de la distribución a un servidor NFS, seleccionar NFS como medio de instalación y apuntar a los contenidos a donde los haya copiado.</p></div><div class=paragraph><p>si el servidor sólo soporta «puertos privilegiados» (que suele ser la configuración por omisión en estaciones de trabajo Sun) tendrá que seleccionar la opción <code>NFS Secure</code> en el menú «Options» antes de comenzar con la instalación.</p></div><div class=paragraph><p>Si usa tarjeta Ethernet de mala calidad y está experimentando velocidades de transferencia muy bajas puede probar con el parámetro <code>NFS Slow</code>.</p></div><div class=paragraph><p>Para que la instalación via NFS funcione el servidor debe permitir el montaje de subdirectorios. Por ejemplo, si su distribución FreeBSD 12.0 está en <span class=filename>ziggy:/usr/archive/stuff/FreeBSD</span> el servidor <code>ziggy</code> tendrá que permitir que pueda montarse <span class=filename>/usr/archive/stuff/FreeBSD</span>, no simplemente como <span class=filename>/usr</span> o <span class=filename>/usr/archive/stuff</span>.</p></div><div class=paragraph><p>En el fichero <span class=filename>/etc/exports</span> de FreeBSD eso puede controlarse mediante la opción <code>-alldirs</code>. Puede que otros servidores NFS requieran de parámetros diferentes. Si ve mensajes de <code>permission denied</code> seguramente no ha activado esto correctamente.</p></div></div></div></div></div></div><div class=sect1><h2 id=basics>Capítulo 3. Conceptos básicos de Unix<a class=anchor href=#basics></a></h2><div class=sectionbody><div class=sect2><h3 id=basics-synopsis>3.1. Sinopsis<a class=anchor href=#basics-synopsis></a></h3><div class=paragraph><p>El siguiente capítulo comprende la funcionalidad y órdenes básicas del sistema operativo FreeBSD. Gran parte de este material es relevante para cualquier sistema operativo tipo UNIX®. Puede saltarse este capítulo si considera que ya conoce el funcionamiento de UNIX®. Si no tiene experiencia previa con FreeBSD debería leer este capítulo con mucha atención.</p></div><div class=paragraph><p>Después de leer este capítulo, usted sabrá:</p></div><div class=ulist><ul><li><p>Cómo usar las «consolas virtuales» de FreeBSD.</p></li><li><p>Cómo funcionan los permisos de fichero UNIX® en relación con las banderas de fichero en FreeBSD.</p></li><li><p>La disposición de sistemas de ficheros por omisión en FreeBSD.</p></li><li><p>La organización de disco de FreeBSD.</p></li><li><p>Cómo montar y desmontar sistemas de ficheros.</p></li><li><p>Qué son los procesos, dæmons y señales.</p></li><li><p>Qué es una shell, cómo modificar sus variables de entorno por omisión.</p></li><li><p>Cómo utilizar editores de texto básicos.</p></li><li><p>Qué son los dispositivos y nodos de dispositivos.</p></li><li><p>Qué formato binario se usa en FreeBSD.</p></li><li><p>Cómo buscar información en las páginas de manual.</p></li></ul></div></div><div class=sect2><h3 id=consoles>3.2. Consolas virtuales y terminales<a class=anchor href=#consoles></a></h3><div class=paragraph><p>FreeBSD puede utilizarse de muchas maneras. Una de ellas es tecleando órdenes en una terminal de texto. De este modo, mucha de la flexibilidad y poder de un sistema operativo UNIX® está inmediatamente en sus manos cuando usa FreeBSD. Esta sección describe qué son «terminales» y «consolas» y cómo puede usarlas en FreeBSD.</p></div><div class=sect3><h4 id=consoles-intro>3.2.1. La consola<a class=anchor href=#consoles-intro></a></h4><div class=paragraph><p>Si no ha configurado FreeBSD para ejecutar automáticamente un entorno gráfico en el arranque, el sistema le presentará un «prompt» de entrada después del arranque, inmediatamente después de que los «scripts» de inicio terminen de ejecutarse. Verá algo similar a esto:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Additional ABI support:.
Local package initialization:.
Additional TCP options:.

Fri Sep 20 13:01:06 EEST 2002

FreeBSD/i386 <span class=o>(</span>pc3.ejemplo.org<span class=o>)</span> <span class=o>(</span>ttyv0<span class=o>)</span>

login:</code></pre></div></div><div class=paragraph><p>Los mensajes pueden ser un poco diferentes en su sistema, pero verá algo similar. Las últimas dos líneas son las que nos interesan por el momento. La penúltima línea dice:</p></div><div class="literalblock programlisting"><div class=content><pre>FreeBSD/i386 (pc3.ejemplo.org) (ttyv0)</pre></div></div><div class=paragraph><p>Esta línea contiene información acerca del sistema que acaba de arrancar. Esta usted ante una consola «FreeBSD» que se ejecuta en un procesador Intel o compatible de la arquitectura x86. El nombre de esta máquina (todas las máquinas UNIX® tiene un nombre) es <code>pc3.ejemplo.org</code>, y usted está ahora ante su consola de sistema (la terminal <span class=filename>ttyv0</span>).</p></div><div class=paragraph><p>Para acabar, la última línea siempre es:</p></div><div class="literalblock programlisting"><div class=content><pre>login:</pre></div></div><div class=paragraph><p>Este es el lugar donde se usted tecleará su «nombre de usuario» para entrar en FreeBSD. La siguiente sección describe cómo hacerlo.</p></div></div><div class=sect3><h4 id=consoles-login>3.2.2. La entrada a FreeBSD<a class=anchor href=#consoles-login></a></h4><div class=paragraph><p>FreeBSD es un sistema multiusuario multiprocesador. Esta es la descripción formal que se suele dar a un sistema que puede ser utilizado por muchas personas diferentes, que simultáneamente ejecutan muchos programas en un sola máquina.</p></div><div class=paragraph><p>Cada sistema multiusuario necesita algún modo de distinguir a un «usuario» del resto. En FreeBSD (y en todos los sistemas operativos de tipo UNIX®) esto se logra requiriendo que cada usuario «acceda» al sistema antes de poder ejecutar programas. Cada usuario tiene un nombre único (el «nombre de usuario») y una clave secreta, personal (la «contraseña»). FreeBSD preguntará por ambos antes de permitirle a un usuario ejecutar cualquier programa.</p></div><div class=paragraph><p>Justo después de que FreeBSD arranque y termine de ejecutar sus «scripts» de inicio , le presentará un «prompt» y solicitará un nombre válido de usuario:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>login:</code></pre></div></div><div class=paragraph><p>En este ejemplo vamos a asumir que su nombre de usuario es <code>john</code>. Teclée <code>john</code> en el «prompt» y pulse <kbd>Intro</kbd>. Debería presentársele un «prompt» donde introducir una «contraseña»:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>login: john
Password:</code></pre></div></div><div class=paragraph><p>Teclée ahora la contraseña de <code>john</code> y pulse <kbd>Enter</kbd>. La contraseña <em>no se muestra en pantalla</em>, pero no debe preocuparse por ello. Esto se hace así por motivos de seguridad.</p></div><div class=paragraph><p>Si ha tecleado su contraseña correctamente ya está usted en un sistema FreeBSD, listo para probar todas las órdenes disponibles.</p></div><div class=paragraph><p>Verá el MOTD (mensaje del día) seguido por un «prompt» (un caracter <code>#</code>, <code>$</code> o <code>%</code>). Esto confirma que ha validado con éxito su usuario en FreeBSD.</p></div></div><div class=sect3><h4 id=consoles-virtual>3.2.3. Consolas múltiples<a class=anchor href=#consoles-virtual></a></h4><div class=paragraph><p>Ejecutar órdenes UNIX® en una consola está bien, pero FreeBSD puede ejecutar muchos programas a la vez. Tener una consola donde se pueden teclear órdenes puede ser un desperdicio cuando un sistema operativo como FreeBSD puede ejecutar docenas de programas al mismo tiempo. Aquí es donde las «consolas virtuales» muestran su potencial.</p></div><div class=paragraph><p>FreeBSD puede configurarse para presentarle diferentes consolas virtuales. Puede cambiar de una de ellas a cualquier otra consola virtual pulsando un par de teclas en su teclado. Cada consola tiene su propio canal de salida, y FreeBSD se ocupa de redirigir correctamente la entrada del teclado y la salida al monitor cuando cambia de una consola virtual a la siguiente.</p></div><div class=paragraph><p>Se han reservado ciertas combinaciones especiales de teclas para pasar de unas consolas virtuales a otras en FreeBSD . Puede utilizar <span class=keyseq><kbd>Alt</kbd>+<kbd>F1</kbd></span>, <span class=keyseq><kbd>Alt</kbd>+<kbd>F2</kbd></span> y así sucesivamente hasta <span class=keyseq><kbd>Alt</kbd>+<kbd>F8</kbd></span> para cambiar a una consola virtual diferente en FreeBSD.</p></div><div class=paragraph><p>Mientras está cambiando de una consola a la siguiente, FreeBSD se ocupa de guardar y restaurar la salida de pantalla. El resultado es la «ilusión» de tener varias pantallas y teclados «virtuales» que puede utilizar para teclear órdenes para que FreeBSD los ejecute. El programa que usted lanza en una consola virtual no deja de ejecutarse cuando la consola no está visible. Continúan ejecutándose cuando se cambia a una consola virtual diferente.</p></div></div><div class=sect3><h4 id=consoles-ttys>3.2.4. El fichero <span class=filename>/etc/ttys</span><a class=anchor href=#consoles-ttys></a></h4><div class=paragraph><p>La configuración por omisión de FreeBSD iniciará con ocho consolas virtuales. No es una configuración estática por hardware, así que puede personalizar fácilmente su sistema para arrancar con más o menos consolas virtuales. El número y propiedades de las consolas virtuales están detallados en <span class=filename>/etc/ttys</span>.</p></div><div class=paragraph><p>En <span class=filename>/etc/ttys</span> es donde se configuran las consolas virtuales de FreeBSD. Cada línea no comentada de este fichero (líneas que no comienzan con un caracter <code>#</code>) contiene propiedades para una sola terminal o consola virtual. La versión por omisión de este fichero en FreeBSD configura nueve consolas virtuales y habilita ocho de ellas. Son las líneas que comienzan con <code>ttyv</code>:</p></div><div class="literalblock programlisting"><div class=content><pre># name  getty                           type    status          comments
#
ttyv0   &#34;/usr/libexec/getty Pc&#34;         cons25  on  secure
# Virtual terminals
ttyv1   &#34;/usr/libexec/getty Pc&#34;         cons25  on  secure
ttyv2   &#34;/usr/libexec/getty Pc&#34;         cons25  on  secure
ttyv3   &#34;/usr/libexec/getty Pc&#34;         cons25  on  secure
ttyv4   &#34;/usr/libexec/getty Pc&#34;         cons25  on  secure
ttyv5   &#34;/usr/libexec/getty Pc&#34;         cons25  on  secure
ttyv6   &#34;/usr/libexec/getty Pc&#34;         cons25  on  secure
ttyv7   &#34;/usr/libexec/getty Pc&#34;         cons25  on  secure
ttyv8   &#34;/usr/X11R6/bin/xdm -nodaemon&#34;  xterm   off secure</pre></div></div><div class=paragraph><p>Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=ttys&amp;sektion=5&amp;format=html">ttys(5)</a> si quiere una descripción detallada de cada columna en este fichero y todas las opciones que puede usar para configurar las consolas virtuales.</p></div></div><div class=sect3><h4 id=consoles-singleuser>3.2.5. Consola en modo monousuario<a class=anchor href=#consoles-singleuser></a></h4><div class=paragraph><p>En la <a href=./#boot-singleuser>Modo monousuario</a> encontrará una descripción detallada de lo que es «modo monousuario». No importa que sólo exista una consola cuando ejecuta FreeBSD en modo monousuario. No hay otra consola virtual disponible. Las configuraciones de la consola en modo monousuario se pueden encontrar también en <span class=filename>/etc/ttys</span>. Busque la línea que comienza por <code>console</code>:</p></div><div class="literalblock programlisting"><div class=content><pre># name  getty                           type    status          comments
#
# Si la consola está marcada como &#34;insecure&#34;, entonces init
# le pedirá la contraseña de root al entrar a modo monousuario.
console none                            unknown off secure</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Tal y como indican los comentarios por encima de la línea <code>console</code>, puede editar esta línea y cambiar <code>secure</code> por <code>insecure</code>. Si lo hace, cuando FreeBSD arranque en modo monousuario el sistema le pedirá la contraseña de <code>root</code>.</p></div><div class=paragraph><p><em>Tenga cuidado si cambia esto a <code>insecure</code></em>. Si olvida la contraseña de <code>root</code> arrancar en modo monousuario será con seguridad más complicado. Sigue siendo posible, pero será un poco difícil para alguien que no esté familiarizado con le proceso de arranque de FreeBSD y los programas involucrados en dicho proceso.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=consoles-vidcontrol>3.2.6. Cambio del modo de video de la consola<a class=anchor href=#consoles-vidcontrol></a></h4><div class=paragraph><p>La consola FreeBSD por omisión tiene un modo de video que puede ajustarse a 1024x768, 1280x1024 o cualquier otra resolución que admita su chip gráfico y su monitor. Si quiere utilizar uno diferente tendrá que recompilar su kernel con estas dos opciones añadidas:</p></div><div class="literalblock programlisting"><div class=content><pre>options VESA
options SC_PIXEL_MODE</pre></div></div><div class=paragraph><p>Una vez recompilado el kernel con esas dos opciones en él determine qué modos de video admite su hardware; para ello use <a href="https://man.freebsd.org/cgi/man.cgi?query=vidcontrol&amp;sektion=1&amp;format=html">vidcontrol(1)</a>. Con lo siguiente le mostrará una lista de modos de video soportados:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># vidcontrol -i mode</span></code></pre></div></div><div class=paragraph><p>La salida de esta orden es una lista de los modos de que admite su tarjeta. Para elegir uno de ellos tendrá que ejecutar <a href="https://man.freebsd.org/cgi/man.cgi?query=vidcontrol&amp;sektion=1&amp;format=html">vidcontrol(1)</a> en una consola como <code>root</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># vidcontrol MODE_279</span></code></pre></div></div><div class=paragraph><p>Si el modo de video que ha elegido le parece adecuado puede configurarlo de forma permanente haciendo que funcione desde el momento del arranque; para ello debe editar <span class=filename>/etc/rc.conf</span> file:</p></div><div class="literalblock programlisting"><div class=content><pre>allscreens_flags=&#34;MODE_279&#34;</pre></div></div></div></div><div class=sect2><h3 id=permissions>3.3. Permisos<a class=anchor href=#permissions></a></h3><div class=paragraph><p>FreeBSD, cuya raíz histórica es el UNIX® BSD, se fundamenta en varios conceptos clave de UNIX. El primero y más importante es que FreeBSD es un sistema operativo multi-usuario. El sistema puede gestionar múltiples usuarios trabajando simultáneamente y en tareas que no guarden relación entre sí. El sistema se encarga de compartir y administrar peticiones de dispositivos de hardware, periféricos, memoria y tiempo de CPU de manera equitativa para cada usuario.</p></div><div class=paragraph><p>Debido a que el sistema es capaz de soportar múltiples usuarios, todo lo que el sistema administra tiene un conjunto de permisos que usa para decidir quién puede leer, escribir y ejecutar un recurso. Estos permisos se guardan como octetos divididos en tres partes: una para el propietario del fichero, otra para el grupo al que el fichero pertenece, y otra para todos los demás grupos y usuarios. Veamos una representación numérica de esto:</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Valor</th><th class="tableblock halign-left valign-top">Permiso</th><th class="tableblock halign-left valign-top">Listado de directorio</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>0</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>No leer, no escribir, no ejecutar</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>---</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>1</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>No leer, no escribir, ejecutar</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>--x</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>2</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>No leer, escribir, no ejecutar</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>-w-</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>3</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>No leer, escribir, ejecutar</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>-wx</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>4</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Leer, no escribir, no ejecutar</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>r--</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>5</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Leer, no escribir, ejecutar</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>r-x</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>6</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Leer, escribir, no ejecutar</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>rw-</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>7</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Leer, escribir, ejecutar</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>rwx</code></p></td></tr></tbody></table><div class=paragraph><p>Puede utilizar el parámetro de línea de órdenes <code>-l</code> de <a href="https://man.freebsd.org/cgi/man.cgi?query=ls&amp;sektion=1&amp;format=html">ls(1)</a> para ver un listado largo que incluya una columna con información acerca de los permisos de fichero para el propietario, grupo y los demás. Por ejemplo, un <code>ls -l</code> en un directorio puede mostrar algo como esto:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>ls</span> <span class=nt>-l</span>
total 530
<span class=nt>-rw-r--r--</span>  1 root  wheel     512 Sep  5 12:31 mifichero
<span class=nt>-rw-r--r--</span>  1 root  wheel     512 Sep  5 12:31 otrofichero
<span class=nt>-rw-r--r--</span>  1 root  wheel    7680 Sep  5 12:31 email.txt
...</code></pre></div></div><div class=paragraph><p>Aquí está como se divide la primera columna de <code>ls -l</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=nt>-rw-r--r--</span></code></pre></div></div><div class=paragraph><p>El primer caracter (más a la izquierda) indica si este fichero es un fichero regular, un directorio, un dispositivo especial de caracter, un socket o cualquier otro dispositivo especial pseudo-ficheroa . En este caso, el <code>-</code> un fichero regular. Los siguientes tres caracteres, <code>rw-</code> en este ejemplo, dan los permisos para el propietario del fichero. Los siguientes tres caracteres, <code>r--</code>, dan los permisos para el grupo al que el fichero pertenece. Los últimos tres caracteres, <code>r--</code>, dan los permisos para el resto del mundo. Un guión indica que el permiso está desactivado. En el caso de este fichero, los permisos están asignados de tal manera que el propietario puede leer y escribir en el fichero, el grupo puede leer el fichero, y el resto del mundo sólo puede leer el fichero. De acuerdo con la tabla de arriba, los permisos para este fichero serían <code>644</code>, donde cada dígito representa las tres partes de los permisos del fichero.</p></div><div class=paragraph><p>Todo ésto está muy bien, pero ?cómo controla el sistema los permisos de los dispositivos? FreeBSD en realidad trata la mayoría de los dispositivos hardware como un fichero que los programas pueden abrir, leer y en los que pueden escribir datos como si de cualquier otro fichero se tratara. Estos ficheros especiales de dispositivo se encuentran en el directorio <span class=filename>/dev</span>.</p></div><div class=paragraph><p>Los directorios también son tratados como ficheros. Tienen permisos de lectura, escritura y ejecución. El bit de ejecución en un directorio tiene un significado ligeramente distinto que para los ficheros. Cuando un directorio está marcado como ejecutable significa que se puede mirar dentro, se puede hacer un «cd» (cambiar directorio) a él. Esto también significa que dentro del directorio es posible acceder a ficheros cuyos nombres son conocidos (sujeto, claro está, a los permisos de los ficheros mismos).</p></div><div class=paragraph><p>En particular, para poder realizar un listado de directorio, el permiso de lectura debe ser activado en el directorio, mientras que para borrar un fichero del que se conoce el nombre es necesario tener permisos de escritura <em>y</em> ejecución en el directorio que contiene el fichero.</p></div><div class=paragraph><p>Existen más permisos, pero se usan principalmente en circunstancias especiales como los binarios ejecutables de tipo setuid y los los directorios de tipo «sticky». Si desea más información acerca de los permisos de ficheros y cómo establecerlos, consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=chmod&amp;sektion=1&amp;format=html">chmod(1)</a>.</p></div><div class=sect3><h4 id=_permisos_simbólicos>3.3.1. Permisos simbólicos<a class=anchor href=#_permisos_simbólicos></a></h4><div class=paragraph><p>Los permisos simbólicos, también conocidos como expresiones simbólicas, utilizan caracteres en lugar de valores octales para asignar permisos a ficheros o directorios. Las expresiones simbólicas utilizan la sintaxis de (quién) (acción) (permisos) mediante los siguientes valores:</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Opción</th><th class="tableblock halign-left valign-top">Letra</th><th class="tableblock halign-left valign-top">Representa</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>(quién)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>u</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Usuario</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>(quién)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>g</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Grupo propietario</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>(quién)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>o</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Otro</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>(quién)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>a</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Todos («todo el mundo»)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>(acción)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>+</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Añadir permisos</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>(acción)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>-</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Quitar permisos</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>(acción)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>=</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Activar permisos explícitamente</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>(permisos)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>r</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Lectura</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>(permisos)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>w</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Escritura</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>(permisos)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>x</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Ejecución</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>(permisos)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>t</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Bit Sticky («pegajoso»)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>(permisos)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>s</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Activar UID o GID</p></td></tr></tbody></table><div class=paragraph><p>Estos valores se aplican con <a href="https://man.freebsd.org/cgi/man.cgi?query=chmod&amp;sektion=1&amp;format=html">chmod(1)</a> de la misma manera que los anteriores, pero con letras. Por ejemplo, podría usar la siguiente orden para bloquear a otros usuarios el acceso a <em>FICHERO</em>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>chmod </span><span class=nv>go</span><span class=o>=</span> FICHERO</code></pre></div></div><div class=paragraph><p>Puede usarse una lista separada por comas cuando se quiera aplicar más de un conjunto de cambios a un fichero. Por ejemplo la siguiente orden eliminará los permisos de escritura de grupo y «mundo» a <em>FICHERO</em>, y añade permisos de ejecución para todos:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>chmod </span>go-w,a+x FILE</code></pre></div></div></div><div class=sect3><h4 id=_banderas_de_fichero_en_freebsd>3.3.2. Banderas de fichero en FreeBSD<a class=anchor href=#_banderas_de_fichero_en_freebsd></a></h4><div class=paragraph><p>Además de los permisos de fichero previamente expuestos, FreeBSD permite el uso de «banderas de fichero». Estas banderas añaden un nivel de seguridad y control adicional a los ficheros, pero no a los directorios.</p></div><div class=paragraph><p>Las banderas de fichero añaden un nivel adicional de control sobre los ficheros ayudando a asegurar que en algunos casos ni siquiera <code>root</code> pueda eliminar o alterar ficheros.</p></div><div class=paragraph><p>Las banderas de fichero se modifican mediante <a href="https://man.freebsd.org/cgi/man.cgi?query=chflags&amp;sektion=1&amp;format=html">chflags(1)</a>, gracias a una interfaz muy sencilla. Por ejemplo, para habilitar la bandera imborrable de sistema en <span class=filename>fichero1</span>, escriba lo siguiente:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># chflags sunlink fichero1</span></code></pre></div></div><div class=paragraph><p>Y para dehabilitar la bandera imborrable de sistema, simplemente escriba la orden previa con «no» antes de <code>sunlink</code>. Observe:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># chflags nosunlink fichero1</span></code></pre></div></div><div class=paragraph><p>Para ver las banderas de este fichero, utilice <a href="https://man.freebsd.org/cgi/man.cgi?query=ls&amp;sektion=1&amp;format=html">ls(1)</a> con las opciones <code>-lo</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ls -lo fichero1</span></code></pre></div></div><div class=paragraph><p>La salida debería ser como esta:</p></div><div class="literalblock programlisting"><div class=content><pre>-rw-r--r--  1 trhodes  trhodes  sunlnk 0 Mar  1 05:54 fichero1</pre></div></div><div class=paragraph><p>Varias banderas solo pueden ser añadidas o retiradas de ficheros por el usuario <code>root</code>. En otros casos, el propietario del fichero puede activar estas banderas. Se recomienda que para más información la persona encargada de la administración del sistema consulte las páginas de manual <a href="https://man.freebsd.org/cgi/man.cgi?query=chflags&amp;sektion=1&amp;format=html">chflags(1)</a> y <a href="https://man.freebsd.org/cgi/man.cgi?query=chflags&amp;sektion=2&amp;format=html">chflags(2)</a>.</p></div></div><div class=sect3><h4 id=_los_permisos_setuid_setgid_y_sticky>3.3.3. Los permisos <code>setuid</code>, <code>setgid</code> y <code>sticky</code><a class=anchor href=#_los_permisos_setuid_setgid_y_sticky></a></h4><div class=paragraph><p>Además de los permisos que se han explicado hay más, hay tres tipos más que todos los administradores deberían conocer. Son los permisos <code>setuid</code>, <code>setgid</code> y <code>sticky</code>.</p></div><div class=paragraph><p>Estos permisos juegan un papel clave en ciertas operaciones UNIX® puesto que facilitan funcionalidades que no se suelen permitir a los usuarios normales. Para comprenderlas totalmente hay que comprender la diferencia entre el ID real del usuario y el ID efectivo.</p></div><div class=paragraph><p>El ID del usuario real es el UID que arranca (y el propietario) del proceso. El UID efectivo es el ID bajo el que se ejecuta el proceso. Veamos un ejemplo; el programa <a href="https://man.freebsd.org/cgi/man.cgi?query=passwd&amp;sektion=1&amp;format=html">passwd(1)</a> se ejecuta con el ID real del usuario puesto que el usuario está cambiando su contraseña. Pero para poder manipular la base de datos de contraseñas debe ejecutarse con el ID efectivo del usuario <code>root</code>. De este modo es posible que los usuarios cambien su contraseña sin llegar a ver un error de <code>Permission Denied</code> (permiso denegado).</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>La opción <code>nosuid</code> de <a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a> hace que estos binarios den errores silenciosos, es decir, fallarán pero el usuario no recibirá ningún mensaje de error por ello. Esta opción no funciona siempre, pues, según la página man de <a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a>, un «wrapper» <code>nosuid</code> puede sortear esta limitación.</p></div></td></tr></tbody></table></div><div class=paragraph><p>El permiso setuid puede asignarse colocando un número cuatro (4) antes de los permisos. Se ve mejor con un ejemplo:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># chmod 4755 ejemplosuid.sh</span></code></pre></div></div><div class=paragraph><p>Los permisos de <span class=filename>ejemplosuid.sh</span> deberían ser así:</p></div><div class="literalblock programlisting"><div class=content><pre>-rwsr-xr-x   1 trhodes  trhodes    63 Aug 29 06:36 ejemplosuid.sh</pre></div></div><div class=paragraph><p>Fíjese atentamente en la <code>s</code> que ha aparecido en los permisos del fichero, en la parte de los permisos del propietario; esa <code>s</code> está en donde estaría el bit de ejecución. Gracias a esto el funcionamiento de aplicaciones que necesitan permisos elevados, como <code>passwd</code>, pueden funcionar.</p></div><div class=paragraph><p>Si quiere ver un ejemplo con sus propios ojos abra dos terminales. En una arranque un proceso (ejecute) <code>passwd</code> con un usuario normal. Mientras la aplicación espera a que le de una nueva contraseña busque la información de usuario del proceso <code>passwd</code> en la tabla de procesos.</p></div><div class=paragraph><p>En la terminal A:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Changing <span class=nb>local </span>password <span class=k>for </span>trhodes
Old Password:</code></pre></div></div><div class=paragraph><p>En la terminal B:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ps aux | grep passwd</span></code></pre></div></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>trhodes  5232  0.0  0.2  3420  1608   0  R+    2:10AM   0:00.00 <span class=nb>grep </span>passwd
root     5211  0.0  0.2  3620  1724   2  I+    2:09AM   0:00.01 passwd</code></pre></div></div><div class=paragraph><p>Tal y como se ha dicho, un usuario normal puede ejecutar <code>passwd</code>, pero en realidad está utilizando el UID efectivo de <code>root</code>.</p></div><div class=paragraph><p>El permiso <code>setgid</code> actúa del mismo modo que el <code>setuid</code>, pero afecta a los permisos del grupo. Cuando una aplicación funciona con esta configuración lo hace con los permisos del grupo al que pertenece el fichero, no los del usuario que ha arrancado el proceso.</p></div><div class=paragraph><p>Si quiere utilizar el permiso <code>setgid</code> debe situar un núnmero dos (2) al principio de los permisos que vaya a asignar mediante <code>chmod</code>.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># chmod 2755 ejemplosuid.sh</span></code></pre></div></div><div class=paragraph><p>La nueva configuración tiene un aspecto muy similar a la que tenía antes, pero observe que la <code>s</code> de antes está ahora en el campo de los permisos de grupo:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=nt>-rwxr-sr-x</span>   1 trhodes  trhodes    44 Aug 31 01:49 ejemplosuid.sh</code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>En ambos ejemplos, incluso si el «script» en cuestión es ejecutable, no se va a ejecutar con un EUID distinto o un ID efectivo de usuario porque los «scripts» de shell no pueden acceder a la llama del sistema <a href="https://man.freebsd.org/cgi/man.cgi?query=setuid&amp;sektion=2&amp;format=html">setuid(2)</a>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Los dos permisos que acabamos de mostrar los bits de permisos (<code>setuid</code> y <code>setgid</code>) pueden reducir el nivel de seguridad haciendo que se escalen los permisos. Pero hay un tercer bit especial de permisos que puede ser de mucha ayuda para reforzar la seguridad del sistema: el <code>sticky bit</code>.</p></div><div class=paragraph><p>El <code>sticky bit</code>( que podríamos traducir como «bit pegajoso») aplicado a un directorio hace que solamente el propietario de un fichero pueda borrarlo. Esto evita el borrado de ficheros ajenos en directorios públicos como <span class=filename>/tmp</span>. Si quiere usarlo coloque un uno (1) antes de los permisos. Veamos un ejemplo:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># chmod 1777 /tmp</span></code></pre></div></div><div class=paragraph><p>Para ver el <code>;sticky bit</code> en acción usamos <code>ls</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ls -al / | grep tmp</span></code></pre></div></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>drwxrwxrwt  10 root  wheel         512 Aug 31 01:49 tmp</code></pre></div></div><div class=paragraph><p>El <code>sticky bit</code> es la letra <code>t</code> al final de los permisos.</p></div></div></div><div class=sect2><h3 id=dirstructure>3.4. Estructura de directorios<a class=anchor href=#dirstructure></a></h3><div class=paragraph><p>La jerarquía del sistema de ficheros de FreeBSD es fundamental para obtener una compresión completa del sistema. El concepto más importante a entender es el del directorio raíz, «/». Este directorio es el primero en ser montado en el arranque y contiene el sistema básico necesario para preparar el sistema operativo para su funcionamiento en modo multiusuario. El directorio raíz también contiene puntos de montaje para cualquier otro sistema de ficheros que se pretenda montar.</p></div><div class=paragraph><p>Un punto de montaje es un directorio del que se pueden colgar sistemas de ficheros adicionales en un sistema padre (que suele ser el directorio raíz). Esto se explica con detalle en la <a href=#disk-organization>Organización de disco</a>. Los puntos de montaje estándar son, por ejemplo, <span class=filename>/usr</span>, <span class=filename>/var</span>, <span class=filename>/tmp</span>, <span class=filename>/mnt</span> y <span class=filename>/cdrom</span>. Estos directorios suelen corresponderse con entradas en <span class=filename>/etc/fstab</span>. <span class=filename>/etc/fstab</span> es una tabla que sirve de referencia al sistema y contiene los diferentes sistemas de ficheros y sus respectivos puntos de montaje. La mayoría de los sistemas de ficheros en <span class=filename>/etc/fstab</span> se montan automáticamente en el arranque gracias al «script» <a href="https://man.freebsd.org/cgi/man.cgi?query=rc&amp;sektion=8&amp;format=html">rc(8)</a>, a menos que contengan la opción <code>noauto</code>. Si quiere más información consulte la <a href=#disks-fstab>El fichero <span class=filename>fstab</span></a>.</p></div><div class=paragraph><p>Veremos ahora una descripción de los directorios más comunes. Si desea información más completa consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=hier&amp;sektion=7&amp;format=html">hier(7)</a>.</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Directorio</th><th class="tableblock halign-left valign-top">Descripción</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Directorio raíz del sistema de ficheros.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/bin/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Utilidades de usuario fundamentales tanto para el ambiente monousuario como para el multiusuario.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/boot/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Programas y ficheros de configuración necesarios durante el arranque del sistema operativo.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/boot/defaults/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Ficheros de configuración por omisión del arranque; ver <a href="https://man.freebsd.org/cgi/man.cgi?query=loader.conf&amp;sektion=5&amp;format=html">loader.conf(5)</a>.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/dev/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Nodos de dispositivo; ver <a href="https://man.freebsd.org/cgi/man.cgi?query=intro&amp;sektion=4&amp;format=html">intro(4)</a>.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/etc/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Ficheros de configuración y «scripts» del sistema.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/etc/defaults/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Ficheros de configuración por omisión del sistema; ver <a href="https://man.freebsd.org/cgi/man.cgi?query=rc&amp;sektion=8&amp;format=html">rc(8)</a>.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/etc/mail/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Ficheros de configuración para agentes de transporte de correo como <a href="https://man.freebsd.org/cgi/man.cgi?query=sendmail&amp;sektion=8&amp;format=html">sendmail(8)</a>.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/etc/namedb/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Ficheros de configuración de <code>named</code>; ver <a href="https://man.freebsd.org/cgi/man.cgi?query=named&amp;sektion=8&amp;format=html">named(8)</a>.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/etc/periodic/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>«Scripts» que se ejecutan diariamente, semanalmente y mensualmente mediante <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a>; ver <a href="https://man.freebsd.org/cgi/man.cgi?query=periodic&amp;sektion=8&amp;format=html">periodic(8)</a>.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/etc/ppp/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Ficheros de configuración de <code>ppp</code>; ver <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a>.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/mnt/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Directorio vacío utilizado de forma habitual por administradores de sistemas como punto de montaje temporal.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/proc/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Sistema de ficheros de procesos; ver <a href="https://man.freebsd.org/cgi/man.cgi?query=procfs&amp;sektion=5&amp;format=html">procfs(5)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=mount_procfs&amp;sektion=8&amp;format=html">mount_procfs(8)</a>.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/rescue/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Programas enlazados estáticamente para restauraciones de emergencia; ver <a href="https://man.freebsd.org/cgi/man.cgi?query=rescue&amp;sektion=8&amp;format=html">rescue(8)</a>.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/root/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Directorio local para la cuenta <code>root</code>.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/sbin/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Programas del sistema y utilidades fundamentales de administración para ambientes monousuario y multiusuario.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/tmp/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Ficheros temporales. El contenido de <span class=filename>/tmp</span><em>NO</em> suelen conservarse después de un reinicio del sistema. Los sistemas de ficheros basados en memoria suelen montarse en <span class=filename>/tmp</span> Puede automatizarse mediante variables de tmpmfs en <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a> (o con una entrada en <span class=filename>/etc/fstab</span>; ver <a href="https://man.freebsd.org/cgi/man.cgi?query=mdmfs&amp;sektion=8&amp;format=html">mdmfs(8)</a>, o para FreeBSD 4.X, <a href="https://man.freebsd.org/cgi/man.cgi?query=mfs&amp;sektion=8&amp;format=html">mfs(8)</a>).</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>La mayoría de utilidades y aplicaciones de usuario.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/bin/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Aplicaciones comunes, herramientas de programación y otras aplicaciones.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/include/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Ficheros «include» estándar de C.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/lib/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Bibliotecas.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/libdata/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Ficheros de datos con diversas funciones.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/libexec/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Dæmons del sistema y utilidades del sistema (ejecutados por otros programas).</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/local/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Ejecutables locales, bibliotecas, etc. también se usa como destino por omisión de la infraestructura de ports de FreeBSD. Dentro de <span class=filename>/usr/local</span> debe seguirse el esquema general definido en <a href="https://man.freebsd.org/cgi/man.cgi?query=hier&amp;sektion=7&amp;format=html">hier(7)</a> para <span class=filename>/usr</span>. Las excepciones son el directorio man, que está directamente bajo <span class=filename>/usr/local</span> en lugar de debajo de <span class=filename>/usr/local/share</span>, y la documentación de los ports está en <span class=filename>share/doc/port</span>.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/obj/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Arbol destino dependiente de arquitectura fruto de la compilación del árbol <span class=filename>/usr/src</span>.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/ports</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>La colección de Ports de FreeBSD (opcional).</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/sbin/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Dæmons del sistema y utilidades del sistema (ejecutados por usuarios del sistema).</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/shared/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Ficheros independientes de arquitectura.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/src/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Ficheros fuente BSD y/o local.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr/X11R6/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Ejecutables de la distribución X11R6, bibliotecas, etc (opcional).</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/var/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Ficheros multipropósito de log, temporales, en tránsito y de «spool». En ocasiones se monta en <span class=filename>/var</span> un sistema de ficheros basado en memoria.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/var/log/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Diversos ficheros de log del sistema.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/var/mail/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Ficheros de buzones de correo de usuarios.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/var/spool/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Directorios diversos del sistema de spool de impresora y correo.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/var/tmp/</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Ficheros temporales. Suelen conservarse tras el Estos ficheros suelen conservarse tras el reinicio del sistema, a menos que <span class=filename>/var</span> sea un sistema de ficheros basado en memoria.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/var/yp</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Mapas NIS.</p></td></tr></tbody></table></div><div class=sect2><h3 id=disk-organization>3.5. Organización de disco<a class=anchor href=#disk-organization></a></h3><div class=paragraph><p>La unidad más pequeña que FreeBSD utiliza para ubicar ficheros es el nombre de fichero. Los nombres de fichero son sensibles a las mayúsculas, lo que significa que <span class=filename>readme.txt</span> y <span class=filename>README.TXT</span> son dos ficheros distintos. FreeBSD no utiliza la extensión (<span class=filename>.txt</span>) de un fichero para determinar si es un programa, o un documento o alguna otra forma de datos.</p></div><div class=paragraph><p>Los ficheros se almacenan en directorios. Un directorio puede estar vacío, o puede contener cientos de ficheros. Un directorio también puede contener otros directorios, permitiéndole contruir una jerarquía de directorios dentro de otro. Esto hace mucho más fácil la organización de sus datos.</p></div><div class=paragraph><p>Para referirse a ficheros o directorios se usa el nombre de archivo o de directorio, seguido por una barra, <code>/</code>, seguido por cualquier otro nombre de directorio que sea necesario. Si tiene un directorio <span class=filename>tal</span>, el cual contiene el directorio <span class=filename>cual</span>, el cual contiene el fichero <span class=filename>readme.txt</span>, entonces el nombre completo o <em>ruta</em> al fichero es <span class=filename>tal/cual/readme.txt</span>.</p></div><div class=paragraph><p>Los directorios y ficheros se almacenan en un sistema de ficheros. Cada sistema de ficheros contiene un sólo directorio en el nivel más elevado, que es el <em>directorio raíz</em> de ese sistema de ficheros. Este directorio raíz puede contener otros directorios.</p></div><div class=paragraph><p>Lo visto hasta ahora probablemente sea similar a cualquier otro sistema operativo que pueda haber utilizado, pero hay unas cuantas diferencias; por ejemplo, MS-DOS® utiliza <code>\</code> para separar nombres de fichero y directorio, mientras que Mac OS® usa <code>:</code>.</p></div><div class=paragraph><p>FreeBSD no utiliza letras de unidades, u otro nombre de unidad en la ruta. Por tanto, no podrá escribir <span class=filename>c:/tal/cual/readme.txt</span> en FreeBSD.</p></div><div class=paragraph><p>En FreeBSD, en cambio, un sistema de ficheros recibe el nombre de <em>sistema de ficheros raíz</em>. El directorio raíz del sistema de ficheros raíz se representa como <code>/</code>. Cualquier otro sistema de ficheros, por tanto, se <em>monta</em> bajo el sistema de ficheros raíz. No importa cuántos discos tenga en su sistema FreeBSD, cada directorio parecerá ser parte del mismo disco.</p></div><div class=paragraph><p>Suponga que tiene tres sistemas de ficheros, denominados <code>A</code>, <code>B</code> y <code>C</code>. Cada sistema de ficheros tiene un directorio raíz, el cual contiene otros dos directorios, llamados <code>A1</code>, <code>A2</code> (y de la misma manera <code>B1</code>, <code>B2</code> y <code>C1</code>, <code>C2</code>).</p></div><div class=paragraph><p>Usaremos <code>A</code> como sistema de ficheros raíz. Si usara <code>ls</code> para ver el contenido de este directorio vería dos subdirectorios, <code>A1</code> y <code>A2</code>. El árbol de directorios sería como este:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/basics/example-dir1.png alt="example dir1"></div></div><div class=paragraph><p>Un sistema de ficheros debe montarse en un directorio de otro sistema de ficheros. Ahora suponga que monta el sistema de ficheros <code>B</code> en el directorio <code>A1</code>. El directorio raíz de <code>B</code> reemplaza a <code>A1</code>, y los directorios en <code>B</code> aparecen de esta manera:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/basics/example-dir2.png alt="example dir2"></div></div><div class=paragraph><p>Cualquier fichero que esté en el directorio <code>B1</code> o <code>B2</code> puede encontrarse con la ruta <span class=filename>/A1/B1</span> o <span class=filename>/A1/B2</span> según sea necesario. Cualquier fichero que esté en <span class=filename>/A1</span> ha desaparecido temporalmente. Aparecerán de nuevo si <code>B</code> se <em>desmonta</em> de A.</p></div><div class=paragraph><p>Si <code>B</code> se monta en <code>A2</code> entonces el diagrama se vería así:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/basics/example-dir3.png alt="example dir3"></div></div><div class=paragraph><p>y las rutas serían <span class=filename>/A2/B1</span> y <span class=filename>/A2/B2</span> respectivamente.</p></div><div class=paragraph><p>Pueden montarse sistemas de ficheros uno sobre otro. Continuando con el ejemplo anterior, el sistema de ficheros <code>C</code> podría montarse en el directorio <code>B1</code> en el sistema de ficheros <code>B</code>, lo que nos llevaría a esto:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/basics/example-dir4.png alt="example dir4"></div></div><div class=paragraph><p>O <code>C</code> podría montarse directamente en el sistema de ficheros <code>A</code>, bajo el directorio <code>A1</code>:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/basics/example-dir5.png alt="example dir5"></div></div><div class=paragraph><p>Si está familiarizado con MS-DOS® esto es similar, aunque no idéntico, a utilizar <code>join</code>.</p></div><div class=paragraph><p>Esto no es algo a lo deba usted dedicar tiempo de forma habitual. Normalmente creará sistemas de ficheros al instalar FreeBSD y decidirá dónde montarlos; lo más habitual es que no los cambie de sitio a menos que agregue un disco nuevo.</p></div><div class=paragraph><p>Es perfectamente posible tener un sistema de ficheros raíz extenso y no necesitar crear otros. Este esquema tiene unos cuantos inconvenientes y una ventaja:</p></div><div class=ulist><div class=title>Ventajas de disponer de múltiples sistemas de ficheros</div><ul><li><p>Si dispone de varios sistemas de ficheros puede optar por usar distintas <em>opciones de montaje</em>. Por ejemplo, gracias a una planificación cuidadosa, el sistema de ficheros raíz puede montarse como sólo-lectura, haciendo imposible borrar sin querer o editar un fichero crítico. Al mantener separados sistemas de ficheros en los que los usuarios pueden escribir, como <span class=filename>/home</span>, de otros sistemas de ficheros también le permite montar con la opción <em>nosuid</em>; dicha opción previene que los bits <em>suid</em>/<em>guid</em> en los ejecutables almacenados en el sistema de ficheros tengan efecto, mejorando en cierto modo la seguridad.</p></li><li><p>FreeBSD optimiza automáticamente el esquema de ficheros en un sistema de ficheros, dependiendo de cómo el sistema de ficheros esté siendo utilizado. Uno que contenga muchos ficheros pequeños tendrá una optimización distinta de uno que contenga menos ficheros y más grandes. Si sólo tiene un gran sistema de ficheros no hay manera de aplicar esta optimización.</p></li><li><p>Los sistemas de ficheros de FreeBSD son muy robustos en caso de sufrir un caída eléctrica. De todas maneras, un fallo eléctrico en un momento crítico puede dañar la estructura del sistema de ficheros. Si reparte sus datos en múltiples sistemas de ficheros hará que sea más probable que el sistema arranque después de uno de esos fallos, haciéndole además más fácil la tarea de restaurarlo desde un respaldo si fuera necesario.</p></li></ul></div><div class=ulist><div class=title>Ventajas de un sólo sistema de ficheros</div><ul><li><p>Los sistemas de ficheros son de un tamaño fijo. Si crea un sistema de ficheros cuando instala FreeBSD y le da un tamaño específico, tal vez descubra más tarde que necesita hacer la partición más grande. Esto no es fácil de realizar sin hacer una copia de seguridad, crear de nuevo el sistema de ficheros con el nuevo tamaño y entonces restaurar los datos respaldados.</p><div class="admonitionblock important"><table><tbody><tr><td class=icon><i class="fa icon-important" title=Important></i></td><td class=content><div class=paragraph><p>FreeBSD dispone de <a href="https://man.freebsd.org/cgi/man.cgi?query=growfs&amp;sektion=8&amp;format=html">growfs(8)</a>, que permite incrementar el tamanño de un sistema de ficheros «al vuelo», eliminando esta limitación.</p></div></td></tr></tbody></table></div></li></ul></div><div class=paragraph><p>Los sistemas de ficheros están alojados en particiones. Este es un detalle muy importante, puesto que el término <em>partición</em> no significa aquí lo mismo que en otros entornos (por ejemplo, en MS-DOS®) debido a la herencia UNIX® de FreeBSD. Cada partición se identifica con una letra desde <code>a</code> hasta <code>h</code>. Cada partición puede contener solamente un sistema de ficheros, lo que significa que los sistemas de ficheros suelen definirse mediante su punto de montaje en la jerarquía del sistema de ficheros o por la letra de la partición en la que están alojados.</p></div><div class=paragraph><p>FreeBSD también utiliza espacio de disco como <em>espacio de intercambio (swap)</em>. El espacio de intercambio le brinda a FreeBSD <em>memoria virtual</em>. Esto permite al su sistema comportarse como si tuviera más memoria de la que realmente tiene. Cuando a FreeBSD se le agota la memoria mueve algunos de los datos que no está utilizando en ese momento al espacio de intercambio, y los vuelve a poner donde estaban (desplazando alguna otra cosa) cuando los necesita.</p></div><div class=paragraph><p>Algunas particiones tienen ciertas convenciones heredadas.</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Partición</th><th class="tableblock halign-left valign-top">Representación</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>a</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Normalmente contiene el sistema de ficheros raíz</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>b</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Normalmente contiene el espacio de intercambio (swap)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>c</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Suele tener el mismo tamaño de la «slice» que la encierra. Esto permite a las utilidades que necesitan trabajar en toda la «slice» entera (por ejemplo durante una búsqueda de bloques dañados) trabajar en la partición <code>c</code>. Normalmente no debería usted crear un sistema de ficheros en esta partición.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>d</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>La partición <code>d</code> solía tuvo un significado especial asociado pero ya no lo tiene.</p></td></tr></tbody></table><div class=paragraph><p>Cada partición que contiene un sistema de ficheros se almacena en lo que FreeBSD llama una «slice». «slice» es en FreeBSD lo que en otros ámbitos se denomina partición; es un hecho que deriva de los orígenes de FreeBSD como ya sabemos basado en UNIX®.</p></div><div class=paragraph><p>Los números de «slice» muestran el nombre de dispositivo, al que precede una <code>s</code> y un número que puede ser un 1 u otro número mayor. Por lo tanto «da0<em>s1</em>» es la primera slice en la primera unidad SCSI. Sólo puede haber cuatro «slice» físicas en un disco, pero puede haber «slice» lógicas dentro «slice» físicas del tipo apropiado. Estas «slice»extendidas se numeran a partir de 5, así que «ad0<em>s5</em>» es la primera «slice» extendida en el primer disco IDE. Estos dispositivos se usan en sistemas de ficheros que se preve que ocupen una slice.</p></div><div class=paragraph><p>Tanto las «slice» y las unidades físicas «peligrosamente dedicadas», como otras unidades contienen <em>particiones</em>, que se designan mediante letras desde la <code>a</code> hasta <code>h</code>. Esta letra se añade al nombre del dispositivo. Se verá mucho mejor mediante ejemplos: «da0<em>a</em>» es la partición a en la primera unidad da y es una de esas a las que llamamos «peligrosamente dedicada». «ad1s3<em>e</em>» es la quinta partición en la tercera slice de la segunda unidad de disco IDE.</p></div><div class=paragraph><p>Para terminar, cada disco en el sistema tiene también su designación. El nombre de disco comienza por un código que indica el tipo de disco, luego un número, que indica qué disco es. A diferencia de las «slice», la numeración de discos comienza desde 0. Puede las numeraciones más comunes en el <a href=#basics-dev-codes>Códigos de dispositivos de disco</a>.</p></div><div class=paragraph><p>Cuando se hace referencia a una partición, FreeBSD necesita que también se nombre la «slice» y el disco que contiene la partició. Esto se hace con el nombre de disco, <code>s</code>, el número «slice» y por último la letra de la partición. Tiene varios casos en el <a href=#basics-disk-slice-part>Ejemplo de nombres de disco, «slice» y partición</a>.</p></div><div class=paragraph><p>En el <a href=#basics-concept-disk-model>Modelo conceptual de un disco</a> muestra un modelo conceptual del esquema de un disco que debería ayudarle a aclarar las cosas.</p></div><div class=paragraph><p>Antes de instalar FreeBSD tendrá que configurar las «slice» de disco, después crear particiones dentro de las «slice» que vaya a usar en FreeBSD y luego crear un sistema de ficheros (o swap) en cada partición y luego decidir cuál va a ser el punto de montaje del sistema de ficheros.</p></div><table id=basics-dev-codes class="tableblock frame-none grid-all stretch"><caption class=title>Tabla 5. Códigos de dispositivos de disco</caption><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Código</th><th class="tableblock halign-left valign-top">Significado</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>ad</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Disco ATAPI (IDE)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>da</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Disco de acceso directo SCSI</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>acd</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>CDROM ATAPI (IDE)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>cd</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>CDROM SCSI</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>fd</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Disquete (floppy)</p></td></tr></tbody></table><div id=basics-disk-slice-part class=exampleblock><div class=title>Ejemplo 4. Ejemplo de nombres de disco, «slice» y partición</div><div class=content><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Nombre</th><th class="tableblock halign-left valign-top">Significado</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>ad0s1a</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>La primera partición (<code>a</code>) en la primera slice (<code>s1</code>) en el primer disco IDE (<code>ad0</code>).</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>da1s2e</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>La quinta partición (<code>e</code>) en la segunda slice (<code>s2</code>) en el segundo disco SCSI (<code>da1</code>).</p></td></tr></tbody></table></div></div><div id=basics-concept-disk-model class=exampleblock><div class=title>Ejemplo 5. Modelo conceptual de un disco</div><div class=content><div class=paragraph><p>Este diagrama muestra cómo ve FreeBSD el primer disco IDE en el sistema. Se asume que el disco es de 4 GB, y contiene dos «slices» de 2 GB (particiones MS-DOS®). La primera partición contiene un disco MS-DOS®, <span class=filename>C:</span>, y la segunda partición contiene una instalación de FreeBSD. Esta instalación de ejemplo tiene tres particiones, y una partición swap.</p></div><div class=paragraph><p>Cada una de las tres particiones tiene un sistema de ficheros. La partición <code>a</code> se utilizará para el sistema de ficheros raíz, <code>e</code> para la jerarquía del directorio <span class=filename>/var</span>, y <code>f</code> para la jerarquía del directorio <span class=filename>/usr</span>.</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/basics/disk-layout.png alt="disk layout"></div></div></div></div></div><div class=sect2><h3 id=mount-unmount>3.6. Montaje y desmontaje de sistemas de ficheros<a class=anchor href=#mount-unmount></a></h3><div class=paragraph><p>El sistema de ficheros se visualiza mejor como un árbol enraizado, tal y como esá, en <span class=filename>/</span>. <span class=filename>/dev</span>, <span class=filename>/usr</span> y todos los demás directorios en el directorio raíz son raamas, las cuales pueden tener sus propias ramas, como <span class=filename>/usr/local</span> y así sucesivamente.</p></div><div class=paragraph><p>Existen varias razones para albergar algunos de estos directorios en sistemas de ficheros separados. <span class=filename>/var</span> contiene los directorios <span class=filename>log/</span>, <span class=filename>spool/</span> y varios tipos de ficheros temporales y pueden llegar a desbordarse. Agotar el espacio del sistema de ficheros raíz no es nada bueno desde cualquier punto de vista, así que separar <span class=filename>/var</span> de de <span class=filename>/</span> es algo que debería hacerse siempre que sea posible.</p></div><div class=paragraph><p>Otra razón para meter ciertos árboles de directorios en otros sistemas de ficheros es si van a estar albergados en discos físicos separados, o si son discos virtuales separados, como un montaje por <a href=./#network-nfs>NFS</a> en el caso de unidades de CDROM.</p></div><div class=sect3><h4 id=disks-fstab>3.6.1. El fichero <span class=filename>fstab</span><a class=anchor href=#disks-fstab></a></h4><div class=paragraph><p>Durante el <a href=./#boot>proceso de arranque</a> los sistemas de ficheros listados en <span class=filename>/etc/fstab</span> se montan automáticamente (a menos que estén listados con la opción <code>noauto</code>).</p></div><div class=paragraph><p><span class=filename>/etc/fstab</span> contiene una lista de líneas con el siguiente formato:</p></div><div class="literalblock programlisting"><div class=content><pre>dispositivo       /punto-de-montaje punto de montaje     opciones      dumpfreq     passno</pre></div></div><div class=dlist><dl><dt class=hdlist1><code>dispositivo</code></dt><dd><p>Un nombre de dispositivo (<em>debe existir</em>).</p></dd><dt class=hdlist1><code>punto-de-montaje</code></dt><dd><p>Un directorio (que debe existir) en el que montar el sistema de ficheros.</p></dd><dt class=hdlist1><code>tipo de sistema ficheros</code></dt><dd><p>El tipo de sistema de ficheros es un parámetro que interpretará <a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a>. El sistema de ficheros por omisión de FreeBSD es <code>ufs</code>.</p></dd><dt class=hdlist1><code>opciones</code></dt><dd><p>Ya sea <code>rw</code> para sistemas de ficheros de lectura-escritura, o <code>ro</code> para sistemas de ficheros de sólo lectura, seguido de cualquier otra opción que sea necesaria. Una opción muy habitual es <code>noauto</code>, que se suele usar en sistemas de ficheros que no se deben montar durante la secuencia de arranque. Tiene otras opciones en la página de manual de <a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a>.</p></dd><dt class=hdlist1><code>dumpfreq</code></dt><dd><p><a href="https://man.freebsd.org/cgi/man.cgi?query=dump&amp;sektion=8&amp;format=html">dump(8)</a> la usa para determinar qué sistema de ficheros requieren volcado. Si el campo no está declarado se asume un valor de cero.</p></dd><dt class=hdlist1><code>passno</code></dt><dd><p>Determina el orden en el cual los sistemas de ficheros deben revisarse. Los sistemas de ficheros que hayan de saltarse deben tener su <code>passno</code> a cero. El sistema de ficheros raíz (que obviamente debe ser revisado antes que cualquier otro) debe tener su <code>passno</code> puesto a uno, y los demás sistemas de ficheros deben tener valores mayores que uno. Si más de un sistema de ficheros tiene el mismo <code>passno</code> <a href="https://man.freebsd.org/cgi/man.cgi?query=fsck&amp;sektion=8&amp;format=html">fsck(8)</a> tratará de revisarlos en paralelo en caso de ser posible.</p></dd></dl></div><div class=paragraph><p>Consulte la página de manual de <a href="https://man.freebsd.org/cgi/man.cgi?query=fstab&amp;sektion=5&amp;format=html">fstab(5)</a> para mayor información sobre el formato del fichero <span class=filename>/etc/fstab</span> y las opciones que contiene.</p></div></div><div class=sect3><h4 id=disks-mount>3.6.2. La orden <code>mount</code><a class=anchor href=#disks-mount></a></h4><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a> es al fin y al cabo quien monta los sistemas de ficheros.</p></div><div class=paragraph><p>En su forma más básica se usa lo siguiente:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount dispositivo punto-de-montaje</span></code></pre></div></div><div class=paragraph><p>Existe una gran cantidad de opciones (las encontrará todas en <a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a>) pero las más comunes son:</p></div><div class=dlist><div class=title>Opciones de montaje</div><dl><dt class=hdlist1><code>-a</code></dt><dd><p>Montar todos los sistemas de ficheros que aparezcan en <span class=filename>/etc/fstab</span>, excepto aquellos marcados como «noauto», excluidos por el parámetro <code>-t</code> o aquellos que ya estén montados.</p></dd><dt class=hdlist1><code>-d</code></dt><dd><p>Realizar todo excepto la llamada real de montaje del sistema. Esta opción es muy útil en caso de problemas si se combina con la opción <code>-v</code> para determinar qué es lo que <a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a> está haciendo realmente.</p></dd><dt class=hdlist1><code>-f</code></dt><dd><p>Forzar el montaje de un sistema de ficheros inestable (por ejemplo uno que da errores tras un reinicio súbito, algo que es bastante <em>peligroso</em>), o forzar la revocación de accesos de escritura cuando se cambia el estado de un sistema de ficheros de lectura-escritura a solo lectura.</p></dd><dt class=hdlist1><code>-r</code></dt><dd><p>Montar el sistema de ficheros como sólo lectura. Esto es idéntico a utilizar el argumento <code>ro</code> (<code>rdonly</code> para versiones anteriores a FreeBSD 5.2) en la opción <code>-o</code>.</p></dd><dt class=hdlist1><code>-t</code> <em>tipo de sistema de ficheros</em></dt><dd><p>Montar un sistema de ficheros dado con el tipo de sistema de ficheros, o montar solamente sistemas de ficheros del tipo dado si se proporciona la opción <code>-a</code>.</p><div class=paragraph><p>«ufs» es el sistema de ficheros por omisión.</p></div></dd><dt class=hdlist1><code>-u</code></dt><dd><p>Actualizar puntos de montaje en el sistema de ficheros.</p></dd><dt class=hdlist1><code>-v</code></dt><dd><p>Mostrar mayor información.</p></dd><dt class=hdlist1><code>-w</code></dt><dd><p>Montar el sistema de ficheros como lectura-escritura.</p></dd></dl></div><div class=paragraph><p>La opción <code>-o</code> toma una lista las siguientes opciones separada por comas:</p></div><div class=dlist><dl><dt class=hdlist1>nodev</dt><dd><p>No interpretar dispositivos especiales en el sistema ficheros. Es una opción de seguridad que puede ser muy útil.</p></dd><dt class=hdlist1>noexec</dt><dd><p>No permitir la ejecución de binarios en este sistema de ficheros. Esta también es una opción de seguridad útil.</p></dd><dt class=hdlist1>nosuid</dt><dd><p>No interpretar bits setuid o setgid en el sistema de ficheros. Esta también es una opción de seguridad útil.</p></dd></dl></div></div><div class=sect3><h4 id=disks-umount>3.6.3. La orden <code>umount</code><a class=anchor href=#disks-umount></a></h4><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=umount&amp;sektion=8&amp;format=html">umount(8)</a> toma como parámetro un punto de montaje, un nombre de dispositivo, o la opción <code>-a</code> o <code>-A</code>.</p></div><div class=paragraph><p>Todas las formas toman <code>-f</code> para forzar el desmontaje y <code>-v</code> para mostrar más información. Tenga muy en cuenta que usar <code>-f</code> no suele ser una forma recomendable de proceder. Desmontar a la fuerza los sistemas de ficheros puede acarrear el congelar la máquina o dañar los datos en el sistema de ficheros.</p></div><div class=paragraph><p><code>-a</code> y <code>-A</code> se usan para desmontar todos los sistemas de ficheros montados, con la ventaja de poder elegir el tipo de sistema de ficheros que se use tras <code>-t</code>. De todas maneras <code>-A</code> no trata de desmontar el sistema de ficheros raíz.</p></div></div></div><div class=sect2><h3 id=basics-processes>3.7. Procesos<a class=anchor href=#basics-processes></a></h3><div class=paragraph><p>FreeBSD es un sistema operativo multitarea. Esto significa que parece como si más de un programa se estuviera ejecutando al mismo tiempo. Cada programa uno de esos programas que se está ejecutando en un momento dado se denomina <em>proceso</em>. Cada orden que ejecuta iniciará al menos un proceso nuevo, y hay muchos procesos que se están que se están ejecutando en todo momento, manteniendo el sistema en funcionamiento.</p></div><div class=paragraph><p>Cada proceso tiene un identificador individual consistente en un número llamado <em>ID del proceso</em>, o <em>PID</em>, y al igual que sucede con los ficheros, cada proceso tiene un propietario y un grupo. La información de propietario y grupo se usa para determinar qué ficheros y dispositivos puede abrir el proceso mediante los permisos de fichero explicados anteriormente. La mayoría de los procesos también tiene un proceso padre. El proceso padre es el proceso que los inició. Por ejemplo, si está tecleando órdenes en la shell, la shell es un proceso, y cualquier orden que usted ejecute también lo será. De este modo cada proceso que ejecute tendrá como proceso padre a su shell. La excepción es un proceso especial llamado <a href="https://man.freebsd.org/cgi/man.cgi?query=init&amp;sektion=8&amp;format=html">init(8)</a>. <code>init</code> es siempre el primer proceso, así que su PID siempre es 1. El kernel arranca automáticamente <code>init</code> en el arranque de FreeBSD.</p></div><div class=paragraph><p>Hay dos órdenes particularmente útiles para ver los procesos en el sistema, <a href="https://man.freebsd.org/cgi/man.cgi?query=ps&amp;sektion=1&amp;format=html">ps(1)</a> y <a href="https://man.freebsd.org/cgi/man.cgi?query=top&amp;sektion=1&amp;format=html">top(1)</a>. <code>ps</code> se usa para mostrar una lista estática de los procesos que se ejecutan en el sistema en es momento, y puede mostrar sus PID, cuánta memoria está usando, la línea de órdenes con la que fueron iniciados y muchas más cosas. <code>top</code> despliega todos los procesos que se están ejecutando y actualiza la pantalla cada pocos segundos para que pueda ver lo que está haciendo su sistema.</p></div><div class=paragraph><p>Por omisión <code>ps</code> solo le muestra las órdenes que están ejecutando <em>y</em> que sean propiedad de su usuario. Por ejemplo:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ps
  PID  TT  STAT      TIME COMMAND
  298  p0  Ss     0:01.10 tcsh
 7078  p0  S      2:40.88 xemacs mdoc.xsl <span class=o>(</span>xemacs-21.1.14<span class=o>)</span>
37393  p0  I      0:03.11 xemacs freebsd.dsl <span class=o>(</span>xemacs-21.1.14<span class=o>)</span>
48630  p0  S      2:50.89 /usr/local/lib/netscape-linux/navigator-linux-4.77.bi
48730  p0  IW     0:00.00 <span class=o>(</span>dns helper<span class=o>)</span> <span class=o>(</span>navigator-linux-<span class=o>)</span>
72210  p0  R+     0:00.00 ps
  390  p1  Is     0:01.14 tcsh
 7059  p2  Is+    1:36.18 /usr/local/bin/mutt <span class=nt>-y</span>
 6688  p3  IWs    0:00.00 tcsh
10735  p4  IWs    0:00.00 tcsh
20256  p5  IWs    0:00.00 tcsh
  262  v0  IWs    0:00.00 <span class=nt>-tcsh</span> <span class=o>(</span>tcsh<span class=o>)</span>
  270  v0  IW+    0:00.00 /bin/sh /usr/X11R6/bin/startx <span class=nt>--</span> <span class=nt>-bpp</span> 16
  280  v0  IW+    0:00.00 xinit /home/nik/.xinitrc <span class=nt>--</span> <span class=nt>-bpp</span> 16
  284  v0  IW     0:00.00 /bin/sh /home/nik/.xinitrc
  285  v0  S      0:38.45 /usr/X11R6/bin/sawfish</code></pre></div></div><div class=paragraph><p>Como puede ver en este ejemplo la salida de <a href="https://man.freebsd.org/cgi/man.cgi?query=ps&amp;sektion=1&amp;format=html">ps(1)</a> está organizada en columnas. <code>PID</code> es el ID de proceso anteriormente expuesto. Los PIDs se asignan a partir del 1 y hasta 99999, y vuelven a comenzar desde el 1 otra cuando se terminan los números. La columna <code>TT</code> muestra la tty en la que el programa se está ejecutando; podemos ignorarla tranquilamente por el momento. <code>STAT</code> muestra el estado del programa; de momento también podemos ignorarlo. <code>TIME</code> es la cantidad de tiempo que el programa ha se ha estado ejecutando en la CPU (generalmente no es el tiempo transcurrido desde que se inició el programa, ya que la mayoría de los programas pasan mucho tiempo esperando antes de que necesiten gastar tiempo en la CPU. Finalmente, <code>COMMAND</code> es la línea de órdenes que se empleó para ejecutar el programa.</p></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=ps&amp;sektion=1&amp;format=html">ps(1)</a> admite muchas opciones sobre la información que se desea ver. Uno de los conjuntos más útiles es <code>auxww</code>. <code>a</code> muestra información acerca de todos los procesos ejecutándose, no solamente los suyos. <code>u</code> despliega el nombre de usuario del propietario del proceso, así como el uso de memoria. <code>x</code> despliega información acerca de los procesos dæmon y <code>ww</code> hace que <a href="https://man.freebsd.org/cgi/man.cgi?query=ps&amp;sektion=1&amp;format=html">ps(1)</a> despliegue la línea de órdenes completa, en lugar de truncarla cuando es demasiado larga para caber en la pantalla.</p></div><div class=paragraph><p>La salida de <a href="https://man.freebsd.org/cgi/man.cgi?query=top&amp;sektion=1&amp;format=html">top(1)</a> es similar. Veamos un ejemplo:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% top
last pid: 72257<span class=p>;</span>  load averages:  0.13,  0.09,  0.03    up 0+13:38:33  22:39:10
47 processes:  1 running, 46 sleeping
CPU states: 12.6% user,  0.0% <span class=nb>nice</span>,  7.8% system,  0.0% interrupt, 79.7% idle
Mem: 36M Active, 5256K Inact, 13M Wired, 6312K Cache, 15M Buf, 408K Free
Swap: 256M Total, 38M Used, 217M Free, 15% Inuse

  PID USERNAME PRI NICE  SIZE    RES STATE    TIME   WCPU    CPU COMMAND
72257 nik       28   0  1960K  1044K RUN      0:00 14.86%  1.42% top
 7078 nik        2   0 15280K 10960K <span class=k>select   </span>2:54  0.88%  0.88% xemacs-21.1.14
  281 nik        2   0 18636K  7112K <span class=k>select   </span>5:36  0.73%  0.73% XF86_SVGA
  296 nik        2   0  3240K  1644K <span class=k>select   </span>0:12  0.05%  0.05% xterm
48630 nik        2   0 29816K  9148K <span class=k>select   </span>3:18  0.00%  0.00% navigator-linu
  175 root       2   0   924K   252K <span class=k>select   </span>1:41  0.00%  0.00% syslogd
 7059 nik        2   0  7260K  4644K poll     1:38  0.00%  0.00% mutt
...</code></pre></div></div><div class=paragraph><p>La salida está dividida en dos secciones. La cabecera (las primeras cinco líneas) muestra el PID del último proceso en ejecutarse, la carga promedio del sistema (una medida de la carga del sistema), el «uptime» del sistema (tiempo desde el último reinicio) y la hora actual. Las otras cifras en la cabecera se relacionan con cuántos procesos hay en ejecución en el sistema (47 en este caso), cuánta memoria y espacio de intercambio (swap) está en uso, y cuánto tiempo está el sistema en diferentes estados de CPU.</p></div><div class=paragraph><p>Más abajo hay una serie de columnas con información similar a la salida de <a href="https://man.freebsd.org/cgi/man.cgi?query=ps&amp;sektion=1&amp;format=html">ps(1)</a>. Igual que antes, puede usted ver el PID, el nombre de usuario, la cantidad de tiempo de CPU en uso y la orden que se ejecutó. <a href="https://man.freebsd.org/cgi/man.cgi?query=top&amp;sektion=1&amp;format=html">top(1)</a> también mostrará por omisión la cantidad de espacio de memoria que emplea cada proceso. Está dividido en dos columnas, una para el tamaño total y otra para el tamaño residente (el tamaño total es cuánta memoria ha necesitado la aplicación y el tamaño residente es cuánta se está usando en ese momento concreto). En este ejemplo puede verse que <a href="https://man.freebsd.org/cgi/man.cgi?query=getenv&amp;sektion=3&amp;format=html">getenv(3)</a> requerido casi 30 MB de RAM, pero actualmente solo está usando 9 MB.</p></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=top&amp;sektion=1&amp;format=html">top(1)</a> actualiza automáticamente el listado cada dos segundos, pero este lapso puede cambiarse mediante la opción <code>s</code>.</p></div></div><div class=sect2><h3 id=basics-daemons>3.8. Dæmons, señales y cómo matar procesos<a class=anchor href=#basics-daemons></a></h3><div class=paragraph><p>cuando ejecuta un editor es fácil controlarlo, decirle que cargue ficheros y demás. Puede hacerse porque el editor permite ese control y porque el editor depende de una <em>terminal</em>. Algunos programas no están diseñados para ejecutarse entradas continuas por parte del usuario, así que se desconectan de la terminal a la primera oportunidad. Por ejemplo, un servidor web pasa todo el dia respondiendo peticiones web y normalmente no necesita que usted le haga caso. Los programas que transportan correo electrónico de un sitio a otro son otro ejemplo de esta clase de aplicación.</p></div><div class=paragraph><p>Llamamos a estos programas <em>dæmons</em>. Los Dæmons eran personajes de la mitología griega; no eran ni buenos ni malos, eran pequeños espíritus sirvientes que, en gran medida, hacían cosas útiles por la humanidad. Algo muy parecido a cómo los servidores web y los servidores de correo hacen hoy día tantas cosas útiles para nosotros. Por eso, desde hace mucho tiempo la mascota de BSD es ese dæmon de aspecto tan ufano con su tridente y su cómodo calzado deportivo.</p></div><div class=paragraph><p>Hay una norma según la cual se da nombre a los programas que suelen ejecutarse como dæmons con una «d» final. BIND es el dæmon de nombres de Berkeley (y el programa que en realidad se ejecuta se llama <code>named</code>); el servidor web Apache se llama <code>httpd</code>, el dæmon de «spool» de impresora de línea es <code>lpd</code> y así sucesivamente. Se trata de un acuerdo, no una ley férrea; por ejemplo el dæmon principal de correo de Sendmail se llama <code>sendmail</code>, y no <code>maild</code>, como podría suponerse visto lo precedente.</p></div><div class=paragraph><p>Algunas veces necesitará comunicarse con un dæmon. Estas comunicaciones se denominan <em>señales</em>; es posible comunicarse con un dæmon (o con cualquier otro proceso ejecutándose) mandándole una señal. Existen diversos tipos de señales diferentes que puede mandar: algunas tienen un significado especial, otras son interpretadas por la aplicación y la documentación de la aplicación le dirá cómo interpreta la señal esa aplicación). Solamente puede enviar una señal a un del que sea usted propietario. Si manda una señal a un proceso de otro usuario con <a href="https://man.freebsd.org/cgi/man.cgi?query=kill&amp;sektion=1&amp;format=html">kill(1)</a> o <a href="https://man.freebsd.org/cgi/man.cgi?query=kill&amp;sektion=2&amp;format=html">kill(2)</a> verá un mensaje del sistema en el que se le comunica que no tiene permiso para hacer tal cosa. La excepción a esto es el usuario <code>root</code>, que puede mandar señales a los procesos de cualquier usuario del sistema.</p></div><div class=paragraph><p>FreeBSD también enviará señales de aplicación en determinados casos. Si una aplicación está mal escrita y trata de acceder a memoria a la que no está previsto que acceda FreeBSD manda al proceso la señal <em>Violación de segmento</em> (<code>SIGSEGV</code>). Si una aplicación ha utilizado la llamada de sistema <a href="https://man.freebsd.org/cgi/man.cgi?query=alarm&amp;sektion=3&amp;format=html">alarm(3)</a> para ser avisada después de que un periodo de tiempo haya transcurrido se le mandará la señal de alarma (<code>SIGALRM</code>), y así sucesivamente.</p></div><div class=paragraph><p>Hay dos señales que pueden usarse para detener un proceso, <code>SIGTERM</code> y <code>SIGKILL</code>. <code>SIGTERM</code> es la manera amable de matar un proceso; el proceso puede <em>recibir</em> la señal, darse cuenta que usted quiere que se apague, cerrar cualquier fichero de log que pueda tener abierto y generalmente terminar cualquier tarea que esté realizando en ese momento antes de apagarse. En algunos casos un proceso puede incluso ignorar <code>SIGTERM</code> si se encuentra inmerso en una tarea que no puede ser interrumpida.</p></div><div class=paragraph><p>Por el contrario, un proceso no puede ignorar una señal <code>SIGKILL</code>. Esta es la señal «No me importa lo que estás haciendo, detente ahora mismo». Si manda un <code>SIGKILL</code> a un proceso FreeBSD detendrá ese proceso inmediatamente..</p></div><div class=paragraph><p>Otras señales que puede usar: <code>SIGHUP</code>, <code>SIGUSR1</code> y <code>SIGUSR2</code>. Son señales de propósito general, y aplicaciones diferentes pueden hacer cosas diferentes cuando se utilicen.</p></div><div class=paragraph><p>Suponga que ha cambiado el fichero de configuración de su servidor web; es un buen momento para decirle al servidor web que lea y aplique la configuración. Podría detener y reiniciar <code>httpd</code>, pero esto implicaría un período breve de suspensión del servicio de su servidor web, lo cual puede no ser asumible. La mayoría de los dæmons fueron creados pensando en que fueran capaces de responder a la señal <code>SIGHUP</code> releyendo su fichero de configuración. En lugar de matar y reiniciar <code>httpd</code> le podría mandar la señal <code>SIGHUP</code>. Dado que no hay una manera estándar para responder a estas señales, diferentes dæmons tendrán diferente comportamiento, así que asegúrese de leer la documentación del dæmon en cuestión.</p></div><div class=paragraph><p>Las señales se envian mediante <a href="https://man.freebsd.org/cgi/man.cgi?query=kill&amp;sektion=1&amp;format=html">kill(1)</a>, como puede verse en el siguiente ejemplo.</p></div><div class="exampleblock procedure"><div class=content><div class=paragraph><p><strong>Procedure: Envío de una señal a un proceso</strong></p></div><div class=paragraph><p>Este ejemplo muestra como enviar una señal a <a href="https://man.freebsd.org/cgi/man.cgi?query=inetd&amp;sektion=8&amp;format=html">inetd(8)</a>. El fichero de configuración de <code>inetd</code> es <span class=filename>/etc/inetd.conf</span> e <code>inetd</code> releerá dicho fichero de configuración cuando se le envíe un <code>SIGHUP</code>.</p></div><div class="olist arabic"><ol class=arabic><li><p>Identifique el ID de proceso del proceso al que quiere enviarle la señal mediante <a href="https://man.freebsd.org/cgi/man.cgi?query=ps&amp;sektion=1&amp;format=html">ps(1)</a> y <a href="https://man.freebsd.org/cgi/man.cgi?query=grep&amp;sektion=1&amp;format=html">grep(1)</a>. <a href="https://man.freebsd.org/cgi/man.cgi?query=grep&amp;sektion=1&amp;format=html">grep(1)</a> se usa para buscar cadenas de texto de su elección en la salida estándar. Puede ejecutarse como un usuario normal, mientras que <a href="https://man.freebsd.org/cgi/man.cgi?query=inetd&amp;sektion=8&amp;format=html">inetd(8)</a> se ejecuta como <code>root</code>, así que debe pasarle los parámetros <code>ax</code> a <a href="https://man.freebsd.org/cgi/man.cgi?query=ps&amp;sektion=1&amp;format=html">ps(1)</a>.</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ps <span class=nt>-ax</span> | <span class=nb>grep </span>inetd
198  ??  IWs    0:00.00 inetd <span class=nt>-wW</span></code></pre></div></div><div class=paragraph><p>Vemos que el PID de <a href="https://man.freebsd.org/cgi/man.cgi?query=inetd&amp;sektion=8&amp;format=html">inetd(8)</a> es 198. En algunos casos <code>grep inetd</code> también puede aparecer en esta salida. Esto se debe a la manera en que <a href="https://man.freebsd.org/cgi/man.cgi?query=ps&amp;sektion=1&amp;format=html">ps(1)</a> tiene que encontrar la lista de procesos ejecutándose.</p></div></li><li><p>Utilice <a href="https://man.freebsd.org/cgi/man.cgi?query=kill&amp;sektion=1&amp;format=html">kill(1)</a> para enviar la señal. Debido a que <a href="https://man.freebsd.org/cgi/man.cgi?query=inetd&amp;sektion=8&amp;format=html">inetd(8)</a> está siendo ejecutado po <code>root</code> tendrá que usar primero <a href="https://man.freebsd.org/cgi/man.cgi?query=su&amp;sektion=1&amp;format=html">su(1)</a> para volverse <code>root</code>.</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% su

<span class=c># /bin/kill -s HUP 198</span></code></pre></div></div><div class=paragraph><p>Del mismo modo que la mayoría de órdenes UNIX® <a href="https://man.freebsd.org/cgi/man.cgi?query=kill&amp;sektion=1&amp;format=html">kill(1)</a> no imprimirá ninguna salida si ha funcionado bien. Si envía una señal a un proceso del que no es el propietario verá lo siguiente: <code>kill: <em>PID</em>: Operation not permitted</code>. Si no teclea bien el PID puede enviar la señal a un proceso equivocado, lo cual puede ser malo, o si tiene suerte, habrá enviado la señal a un proceso que no está en uso y verá el sistema le dirá <code>kill: <em>PID</em>: No such process</code>.</p></div></li></ol></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=title>¿Por qué utilizar <code>/bin/kill</code>?</div><div class=paragraph><p>Muchas shells incorporan su propio <code>kill</code>; esto es, el shell mandará la señal directamente, en lugar de ejecutar <span class=filename>/bin/kill</span>. Esto puede ser útil pero las diferentes shells tienen diferentes sintaxis para especificar el nombre de la señal que envían. En lugar de tratar de aprederse todas ellas, es más fácil simplemente usar <code>/bin/kill …​</code> sea la que sea la shell que prefiera usar.</p></div></td></tr></tbody></table></div></div></div><div class=paragraph><p>El envío de otras señales es muy similar; sustituya <code>TERM</code> o <code>KILL</code> en la línea de órdenes según sea necesario.</p></div><div class="admonitionblock important"><table><tbody><tr><td class=icon><i class="fa icon-important" title=Important></i></td><td class=content><div class=paragraph><p>Matar procesos aleatorios en el sistema es una mala idea. En particular, <a href="https://man.freebsd.org/cgi/man.cgi?query=init&amp;sektion=8&amp;format=html">init(8)</a>, ID de proceso 1, es muy especial. Ejecutar <code>/bin/kill -s KILL 1</code> es una manera rápida de apagar su sistema. <em>Siempre</em> revise dos veces los argumentos con los que ejecuta <a href="https://man.freebsd.org/cgi/man.cgi?query=kill&amp;sektion=1&amp;format=html">kill(1)</a> <em>antes</em> de pulsar <kbd>Intro</kbd>.</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=shells>3.9. Shells<a class=anchor href=#shells></a></h3><div class=paragraph><p>En FreeBSD gran parte del trabajo diario se hace en una interfaz de línea de órdenes llamada shell. El trabajo principal de la shell es ir recibiendo órdenes mediante un canal de entrada y ejecutarlos. Muchas shells también tienen funciones integradas para ayudar ayudar con las tareas diarias como manipulación de ficheros, gestión de archivos con expresiones regulares, edición en la propia línea de órdenes, macros de órdenes y variables de entorno. FreeBSD incluye diversas shells, como <code>sh</code>, el shell Bourne y <code>tcsh</code>, el shell C mejorado. Hay muchas otras shells disponibles en la colección de ports de FreeBSD, como <code>zsh</code> y <code>bash</code>.</p></div><div class=paragraph><p>?Qué shell usar? es una cuestión de gustos. Si va a programar en C puede preferir usar una shell tipo C, como <code>tcsh</code>. Si viene del mundo Linux o si es nuevo en la interfaz de línea de órdenes de UNIX® puede probar con <code>bash</code>. Tenga en cuenta que cada shell posee unas propiedades únicas que pueden o no funcionar con su entorno de trabajo preferido y que puede usted elegir qué shell usar.</p></div><div class=paragraph><p>Una de las propiedades comunes de las shell es que completan los nombres de fichero. Una vez que ha introducido las primeras letras de una orden o del nombre de un fichero, se puede hacer que la shell complete automáticamente el resto de la orden o nombre de fichero pulsando la tecla <kbd>Tab</kbd>. Veamos un ejemplo. Suponga que tiene dos ficheros llamados <span class=filename>talcual</span> y <span class=filename>tal.cual</span>. Usted quiere borrar <span class=filename>tal.cual</span>. Lo que habría que teclear es: <code>rm ta[tabulador].[tabulador]</code>.</p></div><div class=paragraph><p>La shell mostraría en pantalla <code>rm ta[BIP].cual</code>.</p></div><div class=paragraph><p>El [BIP] es la campana de la consola, es decir, la shell está diciéndome que no pudo completar totalmente el nombre de fichero porque hay más de una coincidencia. Tanto <span class=filename>talcual</span> como <span class=filename>tal.cual</span> comienzan por <code>ta</code>, pero solo se pudo completar hasta <code>tal</code>. Si se teclea <code>.</code>, y de nuevo <kbd>tabulador</kbd> la shell es capaz de añadir el resto del nombre de fichero.</p></div><div class=paragraph><p>Otra función de la shell son las variables de entorno. Las variables de entorno son parejas de valores clave almacenados en el espacio de entorno del shell. Este espacio puede ser leído por cualquier programa invocado por la shell y por lo tanto contiene mucha configuración de programas. Esta es una lista de las variables de entorno más comunes y su significado:</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Variable</th><th class="tableblock halign-left valign-top">Descripción</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>USER</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Nombre de usuario en el sistema.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>PATH</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Lista de directorios, separados por punto y coma, en los que se buscan ejecutables.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>DISPLAY</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Nombre de red de la pantalla X11 a la que conectarse, si está disponible.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>SHELL</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>La shell actual.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>TERM</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>El nombre de la terminal del usuario. Se usa para determinar las características de la terminal.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>TERMCAP</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Base de datos donde encontrar los códigos de escape necesarios para realizar diferentes funciones en la terminal.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>OSTYPE</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Tipo de sistema operativo. Por ejemplo, FreeBSD.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>MACHTYPE</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Arquitectura de CPU en la que se está ejecutando el sistema.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>EDITOR</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>El editor de texto preferido por el usuario.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>PAGER</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>El paginador de texto preferido por el usuario.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>MANPATH</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Lista de directorios separados por punto y coma en los que se buscan páginas de manual.</p></td></tr></tbody></table><div class=paragraph><p>Establecer una variable de entorno difiere ligeramente de shell a shell. Por ejemplo, en las shells al estilo C como <code>tcsh</code> y <code>csh</code>, se usa <code>setenv</code> para establecer las variables de entorno. Bajo shells Bourne como <code>sh</code> y <code>bash</code>, se usa <code>export</code> para establecer las variables de entorno actuales. Por ejemplo, para establecer o modificar la variable de entorno <code>EDITOR</code> (bajo <code>csh</code> o <code>tcsh</code>) la siguiente orden establece <code>EDITOR</code> como <span class=filename>/usr/local/bin/emacs</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% setenv EDITOR /usr/local/bin/emacs</code></pre></div></div><div class=paragraph><p>Bajo shells Bourne:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>export </span><span class=nv>EDITOR</span><span class=o>=</span><span class=s2>&#34;/usr/local/bin/emacs&#34;</span></code></pre></div></div><div class=paragraph><p>También se puede hacer que la mayoría de las shells muestren el contenido de una variable de entorno situando el carácter <code>$</code> delante del nombre de la variable en la línea de órdenes. Por ejemplo, <code>echo $TERM</code> mostrará cualquiera que sea el valor que haya establecido para <code>$TERM</code>, porque la shell expande el valor de <code>$TERM</code> y se lo pasa al programa <code>echo</code>.</p></div><div class=paragraph><p>Las shells manejan muchos caracteres especiales, llamados metacaracteres, como representaciones especiales de datos. El más común es el caracter <code>*</code>, que representa cualquier número de caracteres en un nombre de fichero. Estos metacaracteres especiales se pueden usar para la expansión de nombres de fichero. Por ejemplo, teclear <code>echo *</code> es casi lo mismo que introducir <code>ls</code> porque la shell toma todos los ficheros que coinciden con <code>*</code> y se los pone en la línea de órdenes para que <code>echo</code> los vea.</p></div><div class=paragraph><p>Para evitar que la shell interprete estos caracteres especiales pueden escamotearse anteponiéndoles una contrabarra (<code>\</code>). <code>echo $TERM</code> imprime el nombre de terminal que esté usando. <code>echo \$TERM</code> imprime <code>$TERM</code>, literalmente.</p></div><div class=sect3><h4 id=changing-shells>3.9.1. Cómo cambiar su shell<a class=anchor href=#changing-shells></a></h4><div class=paragraph><p>La manera más fácil de cambiar de shell es mediante <code>chsh</code>. <code>chsh</code> le colocará dentro del editor que esté configurado en la variable de entorno <code>EDITOR</code>; si no la ha modificado, el sistema ejecutará <code>vi</code>, el editor por omisión. Cambie la línea «Shell:» según sus gustos.</p></div><div class=paragraph><p>También se le puede suministrar a <code>chsh</code> la opción <code>-s</code>; ésto establecerá la shell sin necesidad de entrar en el editor de texto. Si por ejemplo quiere que <code>bash</code> sea su shell por omisión puede configurarlo del siguiente modo:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% chsh <span class=nt>-s</span> /usr/local/bin/bash</code></pre></div></div><div class=paragraph><p>Ejecutar <code>chsh</code> sin parámetros y editar la shell desde ahí también funciona.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>La shell que se desee usar <em>debe</em> estar incluida en <span class=filename>/etc/shells</span>. Si se ha instalado una shell desde la <a href=./#ports>colección de ports</a> esto deberí estar hecho automáticamente. Si ha instalado la shell manualmente, tendrá usted que realizar el cambio oportuno en <span class=filename>/etc/shells</span>.</p></div><div class=paragraph><p>Por ejemplo, si instaló manualmente <code>bash</code> y lo ubicó en <span class=filename>/usr/local/bin</span> debería hacer lo siguiente:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># echo /usr/local/bin/bash  /etc/shells</span></code></pre></div></div><div class=paragraph><p>Hecho esto vuelva a ejecutar <code>chsh</code>.</p></div></td></tr></tbody></table></div></div></div><div class=sect2><h3 id=editors>3.10. Editores de texto<a class=anchor href=#editors></a></h3><div class=paragraph><p>Gran parte de la configuración de FreeBSD se realiza modificando ficheros de texto, así que le conviene familiarizarse con alguno de ellos. FreeBSD viene con unos cuantos como parte del sistema base y encontrará muchos más en la colección de ports.</p></div><div class=paragraph><p>El editor de textos más sencillo y fácil de aprender es uno llamado ee, cuyo nombre proviene del inglés «easy editor» (editor fácil). Para iniciar ee se debe teclear en la línea de órdenes <code>ee nombre-de-fichero</code>, donde <em>nombre-de-fichero</em> es el nombre del fichero que se quiere editar. Por ejemplo, para editar <span class=filename>/etc/rc.conf</span> teclée <code>ee /etc/rc.conf</code>. Una vez dentro de <code>ee</code> todas las órdenes para manipular las funciones del editor están listadas en la parte superior de la pantalla. El caracter <code>^</code> representa la tecla <kbd>Ctrl</kbd> del teclado, por lo tanto <code>^e</code> significa la combinación de teclas <span class=keyseq><kbd>Ctrl</kbd>+<kbd>e</kbd></span>. Para salir de ee pulse la tecla <kbd>Esc</kbd> y elija abandonar («leave») el editor. El editor preguntará entonces si quiere conservar los cambios si el fichero hubiera sido modificado.</p></div><div class=paragraph><p>FreeBSD viene también con editores de texto mucho más potentes, como vi, como parte del sistema base, mientras que otros editores, como Emacs y vim son parte de la colección de ports de FreeBSD (<a class=package href=https://cgit.freebsd.org/ports/tree/editors/emacs/>editors/emacs</a> y <a class=package href=https://cgit.freebsd.org/ports/tree/editors/vim/>editors/vim</a>). Estos editores son muchísimo más poderosos, pero tienen la desventaja de ser un poco más complicados de aprender a manejar. De cualquier manera si planea hacer mucho trabajo de edición de texto, aprender a usar un editor de texto más poderoso como vim o Emacs le ahorrará muchísimo más tiempo a la larga.</p></div></div><div class=sect2><h3 id=basics-devices>3.11. Dispositivos y nodos de dispositivos<a class=anchor href=#basics-devices></a></h3><div class=paragraph><p>Dispositivo es un término utilizado la mayoría de las veces para actividades relacionadas con hardware del sistema, como discos, impresoras, tarjetas gráficas y teclados. Cuando FreeBSD arranca, la mayoría de lo que FreeBSD despliega son dispositivos en el momento de ser detectados. Si lo desea, puede volver a ver todos los mensajes que el sistema emite durante el arranque consultando <span class=filename>/var/run/dmesg.boot</span>.</p></div><div class=paragraph><p>Por ejemplo, <span class=filename>acd0</span> es la primera unidad CDROM IDE, mientras que <span class=filename>kbd0</span> representa el teclado.</p></div><div class=paragraph><p>En un sistema operativo UNIX® debe accederse a la mayoría de estos dispositivos a través de ficheros especiales llamados nodos de dispositivo, que se encuentran en el directorio <span class=filename>/dev</span>.</p></div><div class=sect3><h4 id=_creación_de_nodos_de_dispositivo>3.11.1. Creación de nodos de dispositivo<a class=anchor href=#_creación_de_nodos_de_dispositivo></a></h4><div class=paragraph><p>Cuando agregue un nuevo dispositivo a su sistema, o compile soporte para dispositivos adicionales, puede que necesite crear uno o más nodos de dispositivo.</p></div><div class=sect4><h5 id=_devfs_dispositivo_de_sistema_de_ficheros_device_file_system>3.11.1.1. <code>DEVFS</code> Dispositivo de sistema de ficheros (DEVice File System)<a class=anchor href=#_devfs_dispositivo_de_sistema_de_ficheros_device_file_system></a></h5><div class=paragraph><p>El dispositivo de sistema de ficheros, o <code>DEVFS</code>, ofrece acceso a dispositivos del espacio de nombres del kernel en el espacio de nombres del sistema de ficheros global. En lugar de tener que crear y modificar nodos de dispositivo, <code>DEVFS</code> se encarga del mantenimiento dinámico de este sistema de fichero.</p></div><div class=paragraph><p>Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=devfs&amp;sektion=5&amp;format=html">devfs(5)</a> si quiere más información.</p></div></div></div></div><div class=sect2><h3 id=binary-formats>3.12. Formatos binarios<a class=anchor href=#binary-formats></a></h3><div class=paragraph><p>Para poder entender por qué FreeBSD utiliza el formato <a href="https://man.freebsd.org/cgi/man.cgi?query=elf&amp;sektion=5&amp;format=html">elf(5)</a> primero debe saber ciertas cosas sobre los tres formatos de ejecutables «dominantes» en UNIX®:</p></div><div class=ulist><ul><li><p><a href="https://man.freebsd.org/cgi/man.cgi?query=a.out&amp;sektion=5&amp;format=html">a.out(5)</a></p><div class=paragraph><p>El formato objeto de UNIX® más antiguo y «clásico». Utiliza una cabecera corta y compacta con un número mágico al inicio que se usa frecuentemente para identificar el formato (vea <a href="https://man.freebsd.org/cgi/man.cgi?query=a.out&amp;sektion=5&amp;format=html">a.out(5)</a> para más información). Contiene tres segmentos cargados: .text, .data, y .bss además de una tabla de símbolos y una tabla de cadena («strings»).</p></div></li><li><p>COFF</p><div class=paragraph><p>El formato objeto de SVR3. La cabecera consiste en una tabla de sección, para que pueda tener más contenido además de las secciones .text, .data, y .bss.</p></div></li><li><p><a href="https://man.freebsd.org/cgi/man.cgi?query=elf&amp;sektion=5&amp;format=html">elf(5)</a></p><div class=paragraph><p>Es el sucesor de COFF; dispone de secciones múltiples y valores posibles de 32-bits o 64-bits. Una gran desventaja: ELF fué también diseñado asumiendo que solamente existiría una ABI por cada arquitectura de sistema. Esa suposición es en realidad bastante incorrecta y ni siquiera en el mundo comercial SYSV (el cual tiene al menos tres ABIs: SVR4, Solaris y SCO) se puede dar por buena.</p></div><div class=paragraph><p>FreeBSD trata de solucionar este problema de alguna manera ofreciendo una herramienta para <em>marcar</em> un ejecutable ELF conocido con información acerca de la ABI con la que funciona. Si quiere más información consulte la página de manual de <a href="https://man.freebsd.org/cgi/man.cgi?query=brandelf&amp;sektion=1&amp;format=html">brandelf(1)</a>.</p></div></li></ul></div><div class=paragraph><p>FreeBSD viene del campo «clásico» y ha utilizado el formato <a href="https://man.freebsd.org/cgi/man.cgi?query=a.out&amp;sektion=5&amp;format=html">a.out(5)</a>, una tecnología usada y probada en muchas de muchas generaciones de versiones de BSD hasta el inicio de la rama 3.X. Aunque era posible compilar y ejecutar binarios nativos ELF (y kernels) en un sistema FreeBSD desde algún tiempo antes de esto, FreeBSD al principio se mantuvo «contra corriente» y no cambió a ELF como formato por defecto. ?Por qué? Bueno, cuando el mundo Linux efectuó su dolorosa transición a ELF no fué tanto por huir del formato <span class=filename>a.out</span> como por su inflexible mecanismo de bibliotecas compartidas basado en tablas de saltos, que hacía igual de difícil la construcción de bibliotecas compartidas tanto para los desarrolladores como para los proveedores. Ya que las herramientas ELF disponibles ofrecían una solución al problema de las bibliotecas compartidas y eran vistas por mucha gente como «la manera de avanzar», el costo de migración fué aceptado como necesario y se realizó la transición. El mecanismo de bibliotecas compartidas de FreeBSD está diseñado de manera más cercana al estilo del sistema de bibliotecas compartidas de SunOS™ de Sun y, como tal, es muy sencillo de utilizar.</p></div><div class=paragraph><p>Entonces, ?por qué existen tantos formatos diferentes?</p></div><div class=paragraph><p>En un tiempo muy, muy lejano, existía hardware simple. Este hardware tan simple soportaba un sistema pequeño, simple. <span class=filename>a.out</span> era idóneo para el trabajo de representar binarios en este sistema tan simple (un PDP-11). A medida que la gente portaba UNIX® desde este sistema simple, retuvieron el formato <span class=filename>a.out</span> debido a que era suficiente para los primeros portes de UNIX® a arquitecturas como 68k de Motorola, VAXen, etc.</p></div><div class=paragraph><p>Entonces algún brillante ingeniero de hardware decidió que si podía forzar al software a hacer algunos trucos sucios podría sortear ciertos obstáculos del diseño y permitir al núcleo de su CPU correr más rápidamente. Aunque estaba hecho para trabajar con este nuevo tipo de hardware (conocido entonces como RISC), <span class=filename>a.out</span> no estaba bien adaptado para este hardware, así que varios formatos fueron desarrollados para obtener un rendimiento mayor de este hardware que el podía extraerse del limitado y simple formato <span class=filename>a.out</span>. Así fué cómo COFF, ECOFF y algunos otros formatos más extraños fueron inventados y sus limitaciones exploradas hasta que se fué llegando a la elección de ELF.</p></div><div class=paragraph><p>Además, el tamaño de los programas estaba volviendose gigante y los discos (y la memoria física) eran relativamente pequeños, así que el concepto de una biblioteca compartida nació. El sistema VM también se volvió más sofisticado. A pesar de que todos estos avances se hicieron utilizando el formato <span class=filename>a.out</span>, su utilidad se iba reduciendo paulatinamente con cada nueva opción. Además, la gente quería cargar cosas dinámicamente en el momento de ejecución, o descartar partes de su programa después de que el código de inicio se ejecutara para ahorrar memoria principal y espacio de swap. Al volverse más sofisticados los lenguajes, la gente empezó a ver la necesidad de introducir código antes del inicio del programa de forma automática. Se hicieron muchos hacks al formato <span class=filename>a.out</span> para permitir que todas estas cosas sucedieran y lo cierto es que por un tiempo funcionaron. Pero <span class=filename>a.out</span> no estaba para solucionar todos estos problemas sin incrementar la carga y complejidad del código. Aunque ELF resolvía muchos de estos problemas, en ese momento hubiera sido terrible dejar de lado un sistema que funcionaba, así que ELF tuvo que esperar hasta que fué más doloroso permanecer con <span class=filename>a.out</span> que migrar a ELF.</p></div><div class=paragraph><p>De todas maneras, con el paso del tiempo las herramientas de compilación de las que FreeBSD derivó las suyas (en especial el ensamblador y el cargador) evolucionaron en dos árboles paralelos. El árbol FreeBSD FreeBSD añadió bibliotecas compartidas y corrigió algunos errores. La gente de GNU (que fueron quienes escribieron estos programas) los reescribió y añadieron una forma más simple de disponer de compiladores cruzados («cross compilers»), el uso de diferentes formatos, etc. Aunque mucha gente quería compiladores cruzados con FreeBSD como «blanco» no hubo suerte, porque los fuentes que que FreeBSD tenía para as y ld no estaban listos para cumplir esa tarea. La nueva cadena de herramientas GNU (binutils) soporta compilación cruzada, ELF, bibliotecas compartidas, extensiones C++, etc. Además, muchos proveedores están liberando binarios ELF y es algo muy bueno que FreeBSD los pueda ejecutar.</p></div><div class=paragraph><p>ELF es más expresivo que <span class=filename>a.out</span> y permite un sistema base más extensible. Las herramientas ELF están mejor mantenidas y ofrecen soporte de compilación cruzada, muy importante para mucha gente. ELF puede ser un poco más lento que <span class=filename>a.out</span>, pero tratar de medirlo puede ser difícil. También existen numerosos detalles que son diferentes entre los dos en cómo gestionan páginas, cómo gestionan código de inicio, etc. Ninguna es muy importante, pero las diferencias existen. Con el tiempo, el soporte para <span class=filename>a.out</span> será eliminado del kernel <span class=filename>GENERIC</span> y es muy posible que se elimine del kernel la posibilidad de ejecutar tales binarios una vez que la necesidad de usar programas <span class=filename>a.out</span> haya pasado.</p></div></div><div class=sect2><h3 id=basics-more-information>3.13. Más información<a class=anchor href=#basics-more-information></a></h3><div class=sect3><h4 id=basics-man>3.13.1. Páginas de manual<a class=anchor href=#basics-man></a></h4><div class=paragraph><p>La documentación más exhaustiva de FreeBSD está en las páginas de manual. Casi todos los programas del sistema vienen con un breve manual de referencia explicando el funcionamiento básico y sus diferentes argumentos. Estos manuales pueden revisarse mediante <code>man</code>. El uso de <code>man</code> es simple:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% man orden</code></pre></div></div><div class=paragraph><p><code>orden</code> es el nombre de la orden sobre la que que desea saber más. Por ejemplo, para más información sobre <code>ls</code> escriba:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% man <span class=nb>ls</span></code></pre></div></div><div class=paragraph><p>El manual en línea está dividido en secciones numeradas:</p></div><div class="olist arabic"><ol class=arabic><li><p>Comandos de usuario.</p></li><li><p>Llamadas al sistema y números de error.</p></li><li><p>Funciones en las bibliotecas de C.</p></li><li><p>Controladores de dispositivo.</p></li><li><p>Formatos de fichero.</p></li><li><p>Juegos y demás pasatiempos.</p></li><li><p>Información sobre temas diversos.</p></li><li><p>Comandos relacionados con el mantenimiento del sistema y su funcionamiento.</p></li><li><p>Desarrolladores del Kernel.</p></li></ol></div><div class=paragraph><p>En algunos casos, el mismo tema puede aparecer en más de una sección del manual en línea. Por ejemplo, existe una orden de usuario <code>chmod</code> y una llamada del sistema <code>chmod()</code>. En este caso se le puede decir a <code>man</code> cuál desea consultar especificando la sección:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% man 1 <span class=nb>chmod</span></code></pre></div></div><div class=paragraph><p>Esto desplegará la página de manual de la orden de usuario <code>chmod</code>. Las referencias a una sección concreta del manual en línea tradicionalmente suelen colocarse entre paréntesis en la documentación escrita, por lo tanto <a href="https://man.freebsd.org/cgi/man.cgi?query=chmod&amp;sektion=1&amp;format=html">chmod(1)</a> se refiere a la orden de usuario <code>chmod</code> y <a href="https://man.freebsd.org/cgi/man.cgi?query=chmod&amp;sektion=2&amp;format=html">chmod(2)</a> se refiere a la llamada de sistema.</p></div><div class=paragraph><p>Esto está muy bien si se conoce el nombre del programa y simplemente se quiere saber como usarlo. Pero ?y si no puede recordar el nombre de la orden? Se puede usar man para que realice una búsqueda mediante palabras clave en las descripciones de programas utilizando el argumento <code>-k</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% man <span class=nt>-k</span> mail</code></pre></div></div><div class=paragraph><p>Dicha orden mostrará una lista de órdenes que contengan la palabra clave «mail» en sus descripciones. Esto es funcionalmente equivalente a usar <code>apropos</code>.</p></div><div class=paragraph><p>Así que, ¿está viendo todos esos programas tan atractivos en <span class=filename>/usr/bin</span> pero no tiene ni la menor idea de lo que la mayoría de ellos hace? Haga lo siguiente:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>cd</span> /usr/bin
% man <span class=nt>-f</span> <span class=k>*</span></code></pre></div></div><div class=paragraph><p>o</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>cd</span> /usr/bin
% whatis <span class=k>*</span></code></pre></div></div><div class=paragraph><p>que hace exactamente lo mismo.</p></div></div><div class=sect3><h4 id=basics-info>3.13.2. Ficheros de información GNU: info<a class=anchor href=#basics-info></a></h4><div class=paragraph><p>FreeBSD incluye muchas aplicaciones y utilidades producidas por la FSF (Free Software Foundation). Además de con las correspondientes páginas de manual, estos programas vienen con documentos de hipertexto más detallados, llamados ficheros <code>info</code>, los cuales pueden ser visualizados con <code>info</code>, o si tiene instalado emacs, con el modo info de emacs.</p></div><div class=paragraph><p>Si quiere utilizar la orden <a href="https://man.freebsd.org/cgi/man.cgi?query=info&amp;sektion=1&amp;format=html">info(1)</a> teclée:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% info</code></pre></div></div><div class=paragraph><p>Para una breve introducción teclée <code>h</code>. Cuando necesite una referencia rápida, teclée <code>?</code>.</p></div></div></div></div></div><div class=sect1><h2 id=ports>Capítulo 4. Instalación de aplicaciones: packages y ports<a class=anchor href=#ports></a></h2><div class=sectionbody><div class=sect2><h3 id=ports-synopsis>4.1. Sinopsis<a class=anchor href=#ports-synopsis></a></h3><div class=paragraph><p>FreeBSD viene con una excelente colección de herramientas de sistema como parte del sistema base. A pesar de esto, existe gran cantidad de cosas que uno requiere hacer para poner las cosas realmente en marcha, para lo cual se necesita instalar software adicional de terceros. FreeBSD ofrece dos tecnologías complementarias para instalar software de terceros en nuestro sistema: la Colección de Ports de FreeBSD y «packages»(paquetes) binarios. Cualquiera de los dos sistemas puede usarse para instalar las versiones más recientes, de forma local o directamente desde la red.</p></div><div class=paragraph><p>Después de leer este capítulo usted sabrá:</p></div><div class=ulist><ul><li><p>Cómo instalar packages binarios de software de terceros.</p></li><li><p>Cómo compilar software de terceros desde la Colección de Ports.</p></li><li><p>Cómo eliminar packages o ports instalados previamente.</p></li><li><p>Cómo sobreescribir los valores por omisión que utiliza la colección de ports.</p></li><li><p>Cómo encontrar la aplicación adecuada.</p></li><li><p>Cómo actualizar aplicaciones.</p></li></ul></div></div><div class=sect2><h3 id=ports-overview>4.2. Aproximación a la instalación de software<a class=anchor href=#ports-overview></a></h3><div class=paragraph><p>Si ha usado un sistema UNIX® con anterioridad sabrá que el procedimiento típico para instalar software de terceros es algo similar a esto:</p></div><div class="olist arabic procedure"><ol class=arabic><li><p>Descargar el software, que puede distribuirse en formato de código fuente o binario.</p></li><li><p>Desempaquetar el software de su formato de distribución (normalmente en un «tarball» comprimido con <a href="https://man.freebsd.org/cgi/man.cgi?query=compress&amp;sektion=1&amp;format=html">compress(1)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=gzip&amp;sektion=1&amp;format=html">gzip(1)</a> o <a href="https://man.freebsd.org/cgi/man.cgi?query=bzip2&amp;sektion=1&amp;format=html">bzip2(1)</a>).</p></li><li><p>Consultar la documentación (quizás un fichero <span class=filename>INSTALL</span> o <span class=filename>README</span>, o los ficheros del subdirectorio <span class=filename>doc/</span>) para ver como instalar el software.</p></li><li><p>Si el software se distribuye como fuente, compilarlo. Esto puede requerir que editemos el fichero <span class=filename>Makefile</span> o que ejecutemos el «script» <code>configure</code>, entre otras cosas.</p></li><li><p>Instalar y probar el software.</p></li></ol></div><div class=paragraph><p>Y esto solamente si todo marcha bien. Si está instalando un software que no ha sido portado específicamente para FreeBSD, puede que sea necesario editar el código para que funcione correctamente.</p></div><div class=paragraph><p>Si lo desea puede continuar instalando software de la forma «tradicional» en FreeBSD, aunque FreeBSD dispone de dos tecnologías que le pueden ahorrar gran cantidad de tiempo y esfuerzo: los packages y los ports. En el momento de escribir esto existen más de 36000 aplicaciones de terceros.</p></div><div class=paragraph><p>En cualquier aplicación el paquete de FreeBSD es un solo fichero que tiene que descargar. Los paquetes contienen copia de los programas binarios precompilados de la aplicación, así como cualquier fichero de configuración o documentación. Los paquetes descargados se pueden manipular con las herramientas de gestión de paquetes de FreeBSD: <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg_add&amp;sektion=1&amp;format=html">pkg_add(1)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg_delete&amp;sektion=1&amp;format=html">pkg_delete(1)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg_info&amp;sektion=1&amp;format=html">pkg_info(1)</a>, etc. Instalar una aplicación nueva puede realizarse con una sola orden.</p></div><div class=paragraph><p>Un port de FreeBSD es una colección de ficheros diseñada para automatizar el proceso de compilación desde el código fuente.</p></div><div class=paragraph><p>Recuerde que existen ciertos pasos que deberá llevar a cabo para compilar un programa por usted mismo (descargar, desempaquetar, parchear, compilar e instalar). Los ficheros que conforman un port permiten que el sistema se encargue de todo esto. Usted ejecuta un conjunto simple de órdenes y el código fuente se descarga, desempaqueta, parchea, compila e instala.</p></div><div class=paragraph><p>De hecho el sistema de ports también se puede usar para crear paquetes que posteriormente se pueden manipular con <code>pkg_add</code> y las demás utilidades de gestión de packages que veremos en breve.</p></div><div class=paragraph><p>Tanto el sistema de ports como el de paquetes entienden las <em>dependencias</em>. Suponga que desea instalar una aplicación que depende de que una biblioteca específica esté instalada. Tanto la biblioteca como la aplicación existen en FreeBSD como paquete o port. Si utiliza <code>pkg_add</code> o el sistema de ports para instalar la aplicación ambos notarán que la biblioteca no está instalada y procederán a instalarla antes que nada.</p></div><div class=paragraph><p>Dado que ambas tecnologís son similares quizás se pregunte por qué FreeBSD se toma la molestía de contar con ambas. Los Packages y los Ports tienen sus propias ventajas, así que cuál utilizar dependerá de su elección en cada momento.</p></div><div class=ulist><div class=title>Ventajas de los Paquetes</div><ul><li><p>El fichero tarball de un package es normalmente más pequeño que el tarball con el código fuente de la aplicación.</p></li><li><p>Los paquetes no requieren compilación. En el caso de aplicaciones grandes, como Mozilla, KDE, o GNOME este detalle puede ser importante, especialmente si usa un equipo lento.</p></li><li><p>Los paquetes no requieren que comprenda el proceso que envuelve el compilar software bajo FreeBSD.</p></li></ul></div><div class=ulist><div class=title>Ventajas de los Ports</div><ul><li><p>Normalmente los paquetes se compilan con opciones conservadoras, en virtud del gran número de equipos donde se instalarán. Al instalar como port puede usted editar las preferencias para (por ejemplo) generar código específico para un procesador Pentium IV o Athlon.</p></li><li><p>Algunas aplicaciones tienen opciones sobre lo que pueden y lo que no pueden hacer. Por ejemplo Apache se puede configurar con una gran variedad de opciones. Al compilarlo desde los ports usted no tiene por que aceptar las opciones predefinidas, puede seleccionar que opciones desea.</p><div class=paragraph><p>En algunos casos existen varios paquetes para la misma aplicación con diferentes opciones. Por ejemplo, Ghostscript está disponible como paquete <span class=filename>ghostscript</span> y como paquete <span class=filename>ghostscript-nox11</span>, dependiendo de si usted cuenta o no con servidor X11. En este caso decidir puede ser sencillo e incluso pueden facilitarse packages con ambas opciones, pero elegir se puede volver un problema si hay más de una o dos opciones de compilación.</p></div></li><li><p>Las condiciones de la licencia de algunas aplicaciones prohiben la distribución de binarios. Solo permiten la distribución del código fuente.</p></li><li><p>Existe gente que no confía en los binarios. Al menos puede usted (en teoría) revisar el código fuente y localizar problemas potenciales.</p></li><li><p>Si tiene parches locales necesitará el código fuente para poder aplicarlos.</p></li><li><p>Hay gente a la que le gusta tener el código fuente para poder leerlo en ratos de ocio, modificarlo, tomar partes prestadas (cuando la licencia lo permite, claro está), etc.</p></li></ul></div><div class=paragraph><p>Para tener constancia de los ports actualizados, suscríbase a la <a href=https://lists.FreeBSD.org/subscription/freebsd-ports>Lista de correo sobre los ports de FreeBSD</a> y a la <a href=https://lists.FreeBSD.org/subscription/freebsd-ports-bugs>Lista de correo sobre errores en los ports de FreeBSD</a>.</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Antes de instalar cualquier aplicación consulte <a href=http://vuxml.freebsd.org>http://vuxml.freebsd.org</a> para comprobar los posibles problemas de seguridad relacionados con ella.</p></div><div class=paragraph><p>También puede instalar <a class=package href=https://cgit.freebsd.org/ports/tree/security/portaudit/>security/portaudit</a> que automáticamente comprobará las vulnerabilidades conocidas de todas las aplicaciones instaladas; también lo comprobará antes de compilar cualquier port. Mientras tanto, puede usar <code>portaudit -F -a</code> después de instalar algunos packages.</p></div></td></tr></tbody></table></div><div class=paragraph><p>El resto de este capítulo le explicará cómo usar los ports y los packages para instalar software de terceros en FreeBSD.</p></div></div><div class=sect2><h3 id=ports-finding-applications>4.3. Cómo encontrar aplicaciones<a class=anchor href=#ports-finding-applications></a></h3><div class=paragraph><p>Antes de poder instalar cualquier software debe saber qué es lo que quiere instalar y cómo se llama la aplicación.</p></div><div class=paragraph><p>La lista de software disponible para FreeBSD crece constantemente. Afortunadamente existen varias formas de localizar lo que busca:</p></div><div class=ulist><ul><li><p>El sitio web de FreeBSD mantiene una lista (actualizada y que admite búsquedas) de todas las aplicaciones disponibles para FreeBSD en la dirección <a href=http://www.freebsd.org/ports/index.html>http://www.FreeBSD.org/ports/ </a>. Esta base esta dividida en categorías, y puede buscar por nombre (si lo sabe) o bien listar las aplicaciones disponibles en cierta categoría.</p></li><li><p>Dan Langille mantiene FreshPorts en <a href=http://www.FreshPorts.org/>http://www.FreshPorts.org/</a>. FreshPorts verifica los cambios en las aplicaciones del árbol de ports, y le permite «seguir» uno o más ports, sobre los que le enviarán un correo cada vez que se actualicen.</p></li><li><p>Si no conoce el nombre de la aplicación que desea pruebe a usar un sitio como FreshMeat (<a href=http://www.freshmeat.net/>http://www.freshmeat.net/</a>) para encontrar una aplicación; después consulte el sitio web de FreeBSD para ver si la aplicación ha sido portada.</p></li><li><p>Si sabe el nombre exacto del port y solo necesita saber en qué categoria está puede usar <a href="https://man.freebsd.org/cgi/man.cgi?query=whereis&amp;sektion=1&amp;format=html">whereis(1)</a>. Simplemente escriba <code>whereis fichero</code>, donde <em>fichero</em> es el programa que quiera instalar. Si está en su sistema, le dirá dónde está:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># whereis lsof</span>
lsof: /usr/ports/sysutils/lsof</code></pre></div></div><div class=paragraph><p>Esto nos dice que <code>lsof</code> (una utilidad de sistema) está en el directorio <span class=filename>/usr/ports/sysutils/lsof</span>.</p></div></li><li><p>Otra forma de encontrar un port en particular es usando el mecanismo de búsqueda integrado en la colección de ports. Para poder usar esta opción de búsqueda debe estar en el directorio <span class=filename>/usr/ports</span>. Una vez en ese directorio ejecute <code>make search name=nombre-del-programa</code>, donde <em>nombre-del-programa</em> es el nombre del programa que desea encontrar. Por ejemplo, si busca <code>lsof</code>:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports</span>
<span class=c># make search name=lsof</span>
Port:   lsof-4.56.4
Path:   /usr/ports/sysutils/lsof
Info:   Lists information about open files <span class=o>(</span>similar to fstat<span class=o>(</span>1<span class=o>))</span>
Maint:  obrien@FreeBSD.org
Index:  sysutils
B-deps:
R-deps:</code></pre></div></div><div class=paragraph><p>Debe prestar especial atención a la línea «Path:»de la salida, porque es la que indica dónde puede encontrar el port. El resto de información no se necesita para instalar el port.</p></div><div class=paragraph><p>Si quiere hacer una búsqueda más a fondo utilice <code>make search key=cadena</code> donde <em>cadena</em> es el término que busca. Podrá buscar nombres de ports, comentarios, descripciones y dependencias; también se puede usar para encontrar ports que tengan relación con algún tema en particular si no conoce el nombre del programa que busca.</p></div><div class=paragraph><p>En ambos casos la cadena de búsqueda no distingue entre mayúsculas y minúsculas. Buscar «LSOF» dará los mismos resultados que buscar «lsof».</p></div></li></ul></div></div><div class=sect2><h3 id=packages-using>4.4. Uso del sistema de packages<a class=anchor href=#packages-using></a></h3><div class=sect3><h4 id=_instalar_un_package>4.4.1. Instalar un package<a class=anchor href=#_instalar_un_package></a></h4><div class=paragraph><p>Puede usar <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg_add&amp;sektion=1&amp;format=html">pkg_add(1)</a> para instalar un package de FreeBSD desde un fichero local o desde un servidor remoto vía red.</p></div><div class=exampleblock><div class=title>Ejemplo 6. Descarga de un paquete manualmente e instalación en nuestro sistema</div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ftp -a ftp2.FreeBSD.org</span>
Connected to ftp2.FreeBSD.org.
220 ftp2.FreeBSD.org FTP server <span class=o>(</span>Version 6.00LS<span class=o>)</span> ready.
331 Guest login ok, send your email address as password.
230-
230-     This machine is <span class=k>in </span>Vienna, VA, USA, hosted by Verio.
230-         Questions? E-mail freebsd@vienna.verio.net.
230-
230-
230 Guest login ok, access restrictions apply.
Remote system <span class=nb>type </span>is UNIX.
Using binary mode to transfer files.
ftp&gt; <span class=nb>cd</span> /pub/FreeBSD/ports/packages/sysutils/
250 CWD <span class=nb>command </span>successful.
ftp&gt; get lsof-4.56.4.tgz
<span class=nb>local</span>: lsof-4.56.4.tgz remote: lsof-4.56.4.tgz
200 PORT <span class=nb>command </span>successful.
150 Opening BINARY mode data connection <span class=k>for</span> <span class=s1>&#39;lsof-4.56.4.tgz&#39;</span> <span class=o>(</span>92375 bytes<span class=o>)</span><span class=nb>.</span>
100% |<span class=k>**************************************************</span>| 92375       00:00 ETA
226 Transfer complete.
92375 bytes received <span class=k>in </span>5.60 seconds <span class=o>(</span>16.11 KB/s<span class=o>)</span>
ftp&gt; <span class=nb>exit</span>
<span class=c># pkg_add lsof-4.56.4.tgz</span></code></pre></div></div></div></div><div class=paragraph><p>Si no tiene una fuente local de packages (por ejemplo un CDROM de FreeBSD) probablemente la mejor opción sea utilizar el argumento <code>-r</code> de <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg_add&amp;sektion=1&amp;format=html">pkg_add(1)</a>, que hará que determine automáticamente el formato del objeto correcto, para posteriormente descargarlo e instalarlo desde un FTP.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg_add -r lsof</span></code></pre></div></div><div class=paragraph><p>En el ejemplo anterior el package correspondiente se descargará e instalará sin intervención del usuario. Si desea utilizar una réplica («mirror») de packages que no sea el sitio principal de FreeBSD solo tiene configurar la variable de entorno <code>PACKAGESITE</code> correctamente para sobreescribir el sitio predefinido. <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg_add&amp;sektion=1&amp;format=html">pkg_add(1)</a> utiliza <a href="https://man.freebsd.org/cgi/man.cgi?query=fetch&amp;sektion=1&amp;format=html">fetch(1)</a> para descargar los ficheros, tomando como referencia varias variables de entorno, como <code>FTP_PASSIVE_MODE</code>, <code>FTP_PROXY</code> y <code>FTP_PASSWORD</code>. Quizás deba modificar alguna de estas si se encuentra detrás de un cortafuegos, o usa un proxy FTP/HTTP. Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=fetch&amp;sektion=3&amp;format=html">fetch(3)</a> si quiere ver una lista completa. Observe también que en el ejemplo anterior usamos <code>lsof</code> en vez de <code>lsof-4.56.4</code>. Cuando usamos la opción de descarga remota no es necesario especificar la versión del paquete. <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg_add&amp;sektion=1&amp;format=html">pkg_add(1)</a> descargará automáticamente la última versión de la aplicación.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=pkg_add&amp;sektion=1&amp;format=html">pkg_add(1)</a> descargará la última versión de su aplicación si usa FreeBSD-CURRENT o FreeBSD-STABLE, pero si usa una versión -RELEASE, descargará la versión del package que se construyó con dicha versión. Es posible configurar esto sobreescribiendo la variable de entorno <code>PACKAGESITE</code>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Los packages se destribuyen en formatos <span class=filename>.tgz</span> y <span class=filename>.tbz</span>. Puede encontrarlos en <a href=ftp://ftp.FreeBSD.org/pub/FreeBSD/ports/packages/>ftp://ftp.FreeBSD.org/pub/FreeBSD/ports/packages/</a>, o en la distribución de FreeBSD en CD-ROM. Todos los CDs en el set de 4 CDs de FreeBSD (y en el PowerPak, etc.) contienen packages en el directorio <span class=filename>/packages</span>. La estructura de los packages es similar a la del arbol de <span class=filename>/usr/ports</span>. Cada categoría tiene su propio directorio, y todos los paquetes se pueden encontrar dentro del directorio <span class=filename>All</span>.</p></div><div class=paragraph><p>La estructura del directorio de packageckages es idéntica a la de los ports, y funcionan como un todo para conformar el sistema de paquetes/ports.</p></div></div><div class=sect3><h4 id=_eliminar_un_package>4.4.2. Eliminar un package<a class=anchor href=#_eliminar_un_package></a></h4><div class=paragraph><p>Para eliminar un package instalado en el sistema utilice <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg_delete&amp;sektion=1&amp;format=html">pkg_delete(1)</a>.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg_delete xchat-1.7.1</span></code></pre></div></div></div><div class=sect3><h4 id=_miscelánea>4.4.3. Miscelánea<a class=anchor href=#_miscelánea></a></h4><div class=paragraph><p>Toda la información de los packages se guarda en <span class=filename>/var/db/pkg</span>. Ahíl encontrará la lista completa de paquetes instalados y las descripciones de los mismos.</p></div></div></div><div class=sect2><h3 id=ports-using>4.5. Uso de la colección de ports<a class=anchor href=#ports-using></a></h3><div class=paragraph><p>La siguiente sección incluye las instrucciones básicas para instalar o eliminar programas mediante la Colección de Ports de su sistema.</p></div><div class=sect3><h4 id=ports-tree>4.5.1. Cómo obtener la Colección de Ports<a class=anchor href=#ports-tree></a></h4><div class=paragraph><p>Para poder instalar ports primero debe hacerse, obviamente, con la Colección de Ports-; en esencia está compuesta por <span class=filename>Makefiles</span>, parches y ficheros con la descripción de los ports y está en <span class=filename>/usr/ports</span>.</p></div><div class=paragraph><p>Cuando instaló su sistema FreeBSD el programa sysinstall le preguntó si querí instalar la Colección de Ports. Si contestó que no siga estas instrucciones:</p></div><div class="exampleblock procedure"><div class=content><div class=paragraph><p><strong>Procedure: Mediante CVSup</strong></p></div><div class=paragraph><p>Este es un método rápido de conseguir y mantener una copia de la Colección de Ports al dia mediante el protocolo CVSup. Si quiere saber más sobre CVSup consulte <a href=./#cvsup>Uso de CVSup</a>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>La implementación del protocolo CVSup que se incluye en FreeBSD se llama csup. Apareció en FreeBSD 6.2. Los usuarios de releases anteriores de FreeBSD puden instalar <a class=package href=https://cgit.freebsd.org/ports/tree/net/csup/>net/csup</a> como port o package.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Asegúrese de que <span class=filename>/usr/ports</span> está vacío antes de ejecutar csup por primera vez. Si ya tiene la Colección de Ports porque la ha instalado por otros medios csup no purgará los parches de ports eliminados.</p></div><div class="olist arabic"><ol class=arabic><li><p>Ejecute <code>csup</code>:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># csup -L 2 -h cvsup.FreeBSD.org /usr/shared/examples/cvsup/ports-supfile</span></code></pre></div></div><div class=paragraph><p>Cambie <em>cvsup.FreeBSD.org</em> por algún otro servidor CVSup que tenga cerca. Consulte <a href=./#cvsup-mirrors>Réplicas CVSup</a> (<a href=./#cvsup-mirrors>Servidores</a>), donde encontrará una lista completa de las réplicas CVSup.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Puede usar una versión de <span class=filename>ports-supfile</span> confeccionada a su gusto, por ejemplo para evitar tener que indicarle el nombre del servidor CVSup a mano.</p></div><div class="olist loweralpha procedure"><ol class=loweralpha type=a><li><p>Haga lo siguiente: como <code>root</code> copie <span class=filename>/usr/shared/examples/cvsup/ports-supfile</span> en otro sitio, por ejemplo <span class=filename>/root</span> o su directorio /home.</p></li><li><p>Edite <span class=filename>ports-supfile</span>.</p></li><li><p>Reemplace <em>CHANGE_THIS.FreeBSD.org</em> por un servidor CVSup que esté cerca de donde esté usted. Consulte <a href=./#cvsup-mirrors>Réplicas CVSup</a> (<a href=./#cvsup-mirrors>Servidores</a>) si necesita ver una lista completa de las mismas.</p></li><li><p>Ejecute <code>csup</code> del siguiente modo:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># csup -L 2 /root/ports-supfile</span></code></pre></div></div></li></ol></div></td></tr></tbody></table></div></li><li><p>Al ejecutar <a href="https://man.freebsd.org/cgi/man.cgi?query=csup&amp;sektion=1&amp;format=html">csup(1)</a> descargará y aplicará todos los cambios recientes que haya sufrido la Colección de Ports, pero tenga en cuenta que no actualizará ninguno de los ports que ya tenga instalados en su sistema.</p></li></ol></div></div></div><div class="exampleblock procedure"><div class=content><div class=paragraph><p><strong>Procedure: Mediante portsnap</strong></p></div><div class=paragraph><p>Portsnap es un método alternativo de distribuir la Colección de Ports. Se incluyó por primera vez en FreeBSD 6.0. Puede instalar <a href="https://man.freebsd.org/cgi/man.cgi?query=portsnap&amp;sektion=8&amp;format=html">portsnap(8)</a> en versiones anteriores de FreeBSD como port (<a class=package href=https://cgit.freebsd.org/ports/tree/ports-mgmt/portsnap/>ports-mgmt/portsnap</a>) o como package:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg_add -r portsnap</span></code></pre></div></div><div class="olist arabic"><ol class=arabic><li><p>Puede saltarse esta paso a partir de FreeBSD 6.1-RELEASE y en versiones recientes de Portsnap (port o package). <span class=filename>/usr/ports</span> se creará automáticamente la primera vez que ejecute <a href="https://man.freebsd.org/cgi/man.cgi?query=portsnap&amp;sektion=8&amp;format=html">portsnap(8)</a>. En versiones anteriores de portsnap había que crear un <span class=filename>/usr/ports</span> vacío si no existía previamente:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mkdir /usr/ports</span></code></pre></div></div></li><li><p>Descargue una instantánea comprimida de la Colección de Ports en <span class=filename>/var/db/portsnap</span>. Hecho esto puede desconectar de Internet si quiere.</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portsnap fetch</span></code></pre></div></div></li><li><p>Si está ejecutando Portsnap por vez primera debe extraer la instantánea en <span class=filename>/usr/ports</span>:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portsnap extract</span></code></pre></div></div><div class=paragraph><p>Si ya tiene un <span class=filename>/usr/ports</span> y solamente está actualizando su árbol de ports ejecute lo siguiente:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portsnap update</span></code></pre></div></div></li></ol></div></div></div><div class="exampleblock procedure"><div class=content><div class=paragraph><p><strong>Procedure: Mediante Sysinstall</strong></p></div><div class=paragraph><p>Este método implica el uso de sysinstall para instalar la Colección de Ports.</p></div><div class="olist arabic"><ol class=arabic><li><p>Como usuario <code>root</code> ejecute <code>sysinstall</code> (<code>/stand/sysinstall</code> en cualquier versión previa a FreeBSD 5.2); del siguiente modo:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysinstall</span></code></pre></div></div></li><li><p>Posiciónese en la opción <span class=guimenuitem>Configure</span> y pulse <kbd>Intro</kbd>.</p></li><li><p>Seleccione la opción <span class=guimenuitem>Distributions</span> y pulse <kbd>Intro</kbd>.</p></li><li><p>Seleccione la opción <span class=guimenuitem>ports</span> y pulse la <kbd>barra espaciadora</kbd>.</p></li><li><p>Seleccione el medio de instalación deseado (CDROM, FTP, etc.)</p></li><li><p>Diríjase a la opción <span class=guimenuitem>Exit</span> y pulse <kbd>Intro</kbd>.</p></li><li><p>Pulse <kbd>X</kbd> para salir de sysinstall.</p></li></ol></div></div></div></div><div class=sect3><h4 id=ports-skeleton>4.5.2. Instalación de ports<a class=anchor href=#ports-skeleton></a></h4><div class=paragraph><p>Al hablar de la Colección de Ports lo primero que hay que explicar es a qué nos referimos cuando hablamos de un «esqueleto» (skeleton). El esqueleto de un port es un conjunto mínimo de ficheros que indican a FreeBSD cómo compilar e instalar un programa. Cada esqueleto incluye:</p></div><div class=ulist><ul><li><p>Un <span class=filename>Makefile</span>. Este <span class=filename>Makefile</span> contiene diversas sentencias que le indican al sistema cómo compilarlo y dónde instalarlo en su sistema.</p></li><li><p>Un fichero <span class=filename>distinfo</span>. Este fichero contiene información sobre los ficheros que se debe descargar para poder compilar el programa, así como el identificador «checksum», que se usa para comprobar mediante <a href="https://man.freebsd.org/cgi/man.cgi?query=md5&amp;sektion=1&amp;format=html">md5(1)</a> que la descarga ha sido correcta y que el la integridad del fichero está garantizada.</p></li><li><p>Un directorio <span class=filename>files</span>. Este directorio contiene los parches necesarios para compilar e instalar el programa en su sistema FreeBSD. Básicamente los parches son pequeños ficheros que especifican cambios en ficheros concretos. Su formato es en texto plano y suelen decir cosas como «borra la línea 10» o «Cambia la línea 26 por esto». Estos parches también se conocen como «diffs» ya que se generan con <a href="https://man.freebsd.org/cgi/man.cgi?query=diff&amp;sektion=1&amp;format=html">diff(1)</a>.</p><div class=paragraph><p>Es posible que este directorio tambié contenga algún otro fichero necesario para compilar e instalar el port.</p></div></li><li><p>Un fichero <span class=filename>pkg-descr</span>. Es una descripción más detallada del programa. En algunas ocasiones ocupa varias líneas.</p></li><li><p>Un fichero <span class=filename>pkg-plist</span>. Es una lista de todos los ficheros que instalará el port. También le indica al sistema de ports qué ficheros eliminar durante la desinstalación del programa.</p></li></ul></div><div class=paragraph><p>Algunos ports tienen otros ficheros, como <span class=filename>pkg-message</span>. El sistema de ports los usa para gestionar situaciones especiales. Si desea conocer los detalles, incluso sobre los ports en general, consulte el libro <a href=https://docs.freebsd.org/en/books/porters-handbook/>FreeBSD Porter’s Handbook</a>.</p></div><div class=paragraph><p>El port incluye las instrucciones necesarias para obtener software a partir del código fuente, pero no incluye el código. Puede obtener el código desde un CDROM o desde Internet. El código se distribuye del modo que el autor estime oportuno. Normalmente es un fichero tar comprimido con gzip, pero puede comprimirse con otra herramienta o incluso no estar comprimido. El código del programa, venga como venga, se llama «distfile». A continuación veremos los dos métodos de instalación de un port.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Debe ser el usuario <code>root</code> para instalar ports.</p></div></td></tr></tbody></table></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Antes de instalar cualquier port asegúrese de tener la Colección de Ports actualizada y de comprobar en <a href=http://vuxml.freebsd.org/>http://vuxml.freebsd.org/</a> la existencia de posibles problemas de seguridad que pudiera tener el port.</p></div><div class=paragraph><p>Puede realizar la comprobación de seguridad con portaudit antes de instalar cualquier aplicación. Esta herramienta está en la Colección de Ports (<a class=package href=https://cgit.freebsd.org/ports/tree/security/portaudit/>security/portaudit</a>). Le rogamos que al menos considere ejecutar <code>portaudit -F</code> antes de instalar un port nuevo para que descargue la nueva base de datos de vulnerabilidades. Durante la comprobación diaria de seguridad actualizará la base de datos y hará una auditoría del sistema. Para más información lea las páginas de manúal de <a href="https://man.freebsd.org/cgi/man.cgi?query=portaudit&amp;sektion=1&amp;format=html">portaudit(1)</a> y <a href="https://man.freebsd.org/cgi/man.cgi?query=periodic&amp;sektion=8&amp;format=html">periodic(8)</a>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>La Colección de Ports asume que tiene usted conexión con Internet. Si no es así tendrá que disponer de una copia del distfile en <span class=filename>/usr/ports/distfiles</span>.</p></div><div class=paragraph><p>El primer paso es ubicarse en el directorio del port que desea instalar:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/sysutils/lsof</span></code></pre></div></div><div class=paragraph><p>Una vez en el directorio <span class=filename>lsof</span> puede ver el esqueleto del port. El siguiente paso es compilar el port. Solamente tiene que teclear <code>make</code> en el prompt. Una vez hecho verá algo como esto:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># make</span>
<span class=o>&gt;&gt;</span> lsof_4.57D.freebsd.tar.gz doesn<span class=s1>&#39;t seem to exist in /usr/ports/distfiles/.
&gt;&gt; Attempting to fetch from ftp://lsof.itap.purdue.edu/pub/tools/unix/lsof/.
===&gt;  Extracting for lsof-4.57
...
[La salida de la descompresión se ha eliminado]
...
&gt;&gt; Checksum OK for lsof_4.57D.freebsd.tar.gz.
===&gt;  Patching for lsof-4.57
===&gt;  Applying FreeBSD patches for lsof-4.57
===&gt;  Configuring for lsof-4.57
...
[La salida de la configuración se ha eliminado]
...
===&gt;  Building for lsof-4.57
...
[La salida de la compilación se ha eliminado]
...
#</span></code></pre></div></div><div class=paragraph><p>Una vez que acabe la compilación se le devolverá el control del prompt. El siguiente paso es instalar el port. Para ello bastará con que añada una palabra a la orden <code>make</code>: esa palabra es <code>install</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># make install</span>
<span class=o>===&gt;</span>  Installing <span class=k>for </span>lsof-4.57
...
<span class=o>[</span>La salida de la instalación se ha eliminado]
...
<span class=o>===&gt;</span>   Generating temporary packing list
<span class=o>===&gt;</span>   Compressing manual pages <span class=k>for </span>lsof-4.57
<span class=o>===&gt;</span>   Registering installation <span class=k>for </span>lsof-4.57
<span class=o>===&gt;</span>  SECURITY NOTE:
      This port has installed the following binaries which execute with
      increased privileges.
<span class=c>#</span></code></pre></div></div><div class=paragraph><p>Una vez que vuelva usted al prompt podrá ejecutar la aplicación que acaba de instalar. Dado que <code>lsof</code> es un programa que se ejecuta con privilegios altos se le ha mostrado una advertencia de seguridad. Durante la compilación e instalación es posible que hayan aparecido otros.</p></div><div class=paragraph><p>Le recomendamos que borre el directorio que contiene todos los ficheros temporales necesarios durante la compilación. No solo consume valioso espacio en disco sino que puede dar problemas cuando vaya a actualizar el port a una versión más reciente.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># make clean</span>
<span class=o>===&gt;</span>  Cleaning <span class=k>for </span>lsof-4.57
<span class=c>#</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Puede ahorrarse teclear dos pasos si para instalar un port teclea <code>make install clean</code> en lugar de <code>make</code>, <code>make install</code> y <code>make clean</code> como tres pasos separados.</p></div></td></tr></tbody></table></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Algunas shells mantienen una caché de órdenes disponibles en los directorios que aparecen en la variable de entorno <code>PATH</code> con el fin de acelerar las operaciones de búsqueda de ejecutables de esas órdenes. Si usa una de esas shells tendrá que utilizar la orden <code>rehash</code> tras instalar un port o no podrá ejecutar aplicaciones recién instaladas. Esta orden funciona en shells como <code>tcsh</code>. Utilice <code>hash -r</code> en shells <code>sh</code>. Para más información consulte la documentación de su shell.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Algunos DVD-ROM de terceros, como el FreeBSD Toolkit de <a href=http://www.freebsdmall.com/>FreeBSD Mall</a> contienen distfiles. Puede usarlos con la Colección de Ports. Monte el DVD-ROM en <span class=filename>/cdrom</span>. Si utiliza un punto de montaje diferente asigne a <code>CD_MOUNTPTS</code> el valor adecuado. Los distfiles se irán copiando automáticamente a medida que vayan siendo necesarios.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Por favor, tenga en cuenta que la licencia de unos cuantos ports muy concretos no permite su distribución en CD-ROM. Puede deberse a que es necesario rellenar un formulario de registro antes de descargarlo, porque la redistribución no esté permitida o por otra razón. Si quiere instalar un port que no está en el CD-ROM tendrá que tener salida a Internet.</p></div></td></tr></tbody></table></div><div class=paragraph><p>El sistema de ports utiliza <a href="https://man.freebsd.org/cgi/man.cgi?query=fetch&amp;sektion=1&amp;format=html">fetch(1)</a> para descargar ficheros; en este proceso intervienen varias variables de entorno, como <code>FTP_PASSIVE_MODE</code>, <code>FTP_PROXY</code>, y <code>FTP_PASSWORD</code>. Si está detrás de un cortafuegos tendrá que asignar valores a una o más de estas variables, así como si necesita utilizar un proxy FTP/HTTP. Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=fetch&amp;sektion=3&amp;format=html">fetch(3)</a>, donde econtrará una lista detallada.</p></div><div class=paragraph><p>La opción <code>make fetch</code> se creó para los usuarios que no disponen de conexión contínua. Ejecute esta orden en el directorio raíz (<span class=filename>/usr/ports</span>) y se descargarán todos los ficheros necesarios. Esta orden también funciona en directorios situados más abajo, por ejemplo <span class=filename>/usr/ports/net</span>. Tenga en cuenta que si un port depende de librerías u otros ports éstos distfiles <em>no</em> se descargarán, a menos que reemplace <code>fetch</code> por <code>fetch-recursive</code>, que se encargará de descargar todas las dependencias de cada port.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Si quiere compilar todos los ports de una categoría y de una sola vez ejecutando la orden <code>make</code> en el directorio raíz, de muy similar manera que lo que se acaba de ver con <code>makefetch</code>. Tenga en cuenta que esto es bastante peligroso porque algunos ports no pueden coexistir. También se dan casos de ports que instalan instalan dos ficheros diferentes con el mismo nombre.</p></div></td></tr></tbody></table></div><div class=paragraph><p>En algunos casos (raros) el usuario tendrá que descargar los tarball de un sitio que no es el que se guarda en la variable de entorno <code>MASTER_SITES</code> (el sitio desde el que se descargan todos los demás normalmente). Puede sobreescribir la opción <code>MASTER_SITES</code> con la siguiente orden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/directory</span>
<span class=c># make MASTER_SITE_OVERRIDE= \</span>
ftp://ftp.FreeBSD.org/pub/FreeBSD/ports/distfiles/ fetch</code></pre></div></div><div class=paragraph><p>En este ejemplo vamos a darle a la opción <code>MASTER_SITES</code> el valor <code>ftp.FreeBSD.org/pub/FreeBSD/ports/distfiles/</code>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Algunos ports permiten (o incluso exigen) que se le faciliten opciones de compilación para activar o desactivar partes de la aplicación que no se necesiten, determinadas opciones de seguridad, etc. Casos típicos de esto son <a class=package href=https://cgit.freebsd.org/ports/tree/www/mozilla/>www/mozilla</a>, <a class=package href=https://cgit.freebsd.org/ports/tree/security/gpgme/>security/gpgme</a>, and <a class=package href=https://cgit.freebsd.org/ports/tree/mail/sylpheed-claws/>mail/sylpheed-claws</a>. Cuando debe usted tomar este tipo de decisiones se le muestra un mensaje con las opciones disponibles.</p></div></td></tr></tbody></table></div><div class=sect4><h5 id=_sobreescribir_directorios_por_omisión_de_ports>4.5.2.1. Sobreescribir directorios por omisión de ports<a class=anchor href=#_sobreescribir_directorios_por_omisión_de_ports></a></h5><div class=paragraph><p>Algunas veces es útil (u obligatorio) utilizar un directorio de trabajo o un «target» distinto al que tenemos por omisión. Las variables de entorno <code>WRKDIRPREFIX</code> y <code>PREFIX</code> pueden sobreescribirse según nuestra conveniencia. Veamos un ejemplo:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># make WRKDIRPREFIX=/usr/home/ejemplo/ports install</span></code></pre></div></div><div class=paragraph><p>compilará el port en <span class=filename>/usr/home/ejemplo/ports</span> y lo instalará en <span class=filename>/usr/local</span>.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># make PREFIX=/usr/home/ejemplo/local install</span></code></pre></div></div><div class=paragraph><p>lo compilará en <span class=filename>/usr/ports</span> y lo instalará en <span class=filename>/usr/home/ejemplo/local</span>.</p></div><div class=paragraph><p>Y por supuesto,</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># make WRKDIRPREFIX=../ports PREFIX=../local install</span></code></pre></div></div><div class=paragraph><p>combinará ambas; (ocupa demasiado para mostrarlo en una página, pero la idea general queda clara).</p></div><div class=paragraph><p>Puede asignar valores a estas variables del mismo modo que a cualquier otra de su entorno. Consulte la documentación de su shell para más información.</p></div></div><div class=sect4><h5 id=_uso_de_imake>4.5.2.2. Uso de <code>imake</code><a class=anchor href=#_uso_de_imake></a></h5><div class=paragraph><p>Algunos ports que usan <code>imake</code> (un componente del Sistema X Window) no funcionan correctamente con <code>PREFIX</code> e insistirán en instalarse en <span class=filename>/usr/X11R6</span>. Del mismo modo algunos ports de Perl ignoran <code>PREFIX</code> y se instalan en el árbol de Perl. Hacer que estos ports respeten <code>PREFIX</code> es difícil y a veces imposible.</p></div></div><div class=sect4><h5 id=_reconfigurar_ports>4.5.2.3. Reconfigurar ports<a class=anchor href=#_reconfigurar_ports></a></h5><div class=paragraph><p>Al compilar ciertos ports se le presentará un menú basado en ncurses en el cual podrá elegir entre más o menos opciones de compilación. No es raro que los usuarios quieran volver a usar ese menú para añadir, quitar o cambiar opciones una vez que el port ya está compilado. Hay bastantes formas de hacerlo. Una manera es entrar al directorio que contiene el port y teclear <code>make config</code>, que hará que se le presente de nuevo el menú con las opciones que estuvieran seleccionadas previamente. Otra opción es usar la orden <code>make showconfig</code>, que le mostrará todas las opciones de configuración del port. Hay otra opción más, <code>make rmconfig</code>, que borrará todas las opciones que estuvieran seleccionadas y le permitirá por tanto empezar desde cero. Todas estas opciones y muchas más las encontrará descritas con gran detalle en <a href="https://man.freebsd.org/cgi/man.cgi?query=ports&amp;sektion=7&amp;format=html">ports(7)</a>.</p></div></div></div><div class=sect3><h4 id=ports-removing>4.5.3. Cómo desinstalar ports<a class=anchor href=#ports-removing></a></h4><div class=paragraph><p>Ahora que sabe instalar ports probablemente quiera saber cómo eliminarlos; puede que haya instalado alguno y posteriormente se haya dado cuenta de que ha instalado el port incorrecto. Vamos a desinstalar el port del ejemplo anterior (que, para todos aquellos que no estaban atentos, era <code>lsof</code>). Igual que al instalar ports, lo primero que debemos hacer es ubicarnos en el directorio del port que deseamos eliminar del sistema, en nuestro caso <span class=filename>/usr/ports/sysutils/lsof</span>. Los ports se desinstalan exactamente igual que los packages; esto se explica en la <a href=#packages-using>sección de packages</a>) utilizando la orden <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg_delete&amp;sektion=1&amp;format=html">pkg_delete(1)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg_delete lsof-4.57</span></code></pre></div></div></div><div class=sect3><h4 id=ports-upgrading>4.5.4. Actualización de ports<a class=anchor href=#ports-upgrading></a></h4><div class=paragraph><p>Antes de nada necesita ver una lista de ports instalados de los cuales exista una nueva versión en la Colección de Ports. Utilice <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg_version&amp;sektion=1&amp;format=html">pkg_version(1)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg_version -v</span></code></pre></div></div><div class=sect4><h5 id=ports-file-updating>4.5.4.1. <span class=filename>/usr/ports/UPDATING</span><a class=anchor href=#ports-file-updating></a></h5><div class=paragraph><p>Una vez actualizada la Colección de Ports (y <em>antes</em> de intentar actualizar ningún port) debe consultar <span class=filename>/usr/ports/UPDATING</span>. Este fichero describe todas las novedades, problemas que pueden encontrarse y pasos que deben seguir los usuarios al actualizar un port; hay cambios de formato, cambios de ubicación de ficheros de configuración o incompatibilidades con versiones anteriores.</p></div><div class=paragraph><p>Si <span class=filename>UPDATING</span> se contradice de cualquier modo con lo que lea aquí tenga muy encuenta que lo que aparezca en <span class=filename>UPDATING</span> tiene prioridad absoluta.</p></div></div><div class=sect4><h5 id=portupgrade>4.5.4.2. Actualización de ports con portupgrade<a class=anchor href=#portupgrade></a></h5><div class=paragraph><p>La aplicación portupgrade se diseñó para actualizar fácilmente los ports instalados en un sistema. Puede instalarla desde el port <a class=package href=https://cgit.freebsd.org/ports/tree/ports-mgmt/portupgrade/>ports-mgmt/portupgrade</a>. La instalación es como al de cualquier otro port, use la orden <code>make install clean</code> command:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/ports-mgmt/portupgrade</span>
<span class=c># make install clean</span></code></pre></div></div><div class=paragraph><p>Compruebe la lista de ports instalados con <code>pkgdb -F</code> y arregle todas las inconsistencias que aparezcan. Le recomendamos que haga esta comprobación de forma regular y siempre antes de una actualización.</p></div><div class=paragraph><p>Si ejecuta <code>portupgrade -a</code> portupgrade intentará actualizar todos y cada uno de los ports instalados en su sistema. Utilice el parámetro <code>-i</code> si quiere que le pida confirmación antes de actualizar cada uno de los ports.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portupgrade -ai</span></code></pre></div></div><div class=paragraph><p>Si solamente quiere actualizar una sola aplicación (y no absolutamente todos los ports) utilice la orden <code>portupgrade nombre-de-aplicación</code>. Añada el modificador <code>-R</code> si quiere que portupgrade actualice antes todos los ports de los que depende la aplicación en cuestión.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portupgrade -R firefox</span></code></pre></div></div><div class=paragraph><p>Si quiere usar packages en lugar de ports use el modificador <code>-P</code> flag. Con esta opción portupgrade busca en los directorios locales que aparezcan en <code>PKG_PATH</code> o descarga los packages desde un sitio remoto si es que no los encuentra en local. Si es imposible encontrar los packages ni en local ni en remoto portupgrade utilizará ports. Si no quiere usar ports pase lo que pase utilice el modificador <code>-PP</code>.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portupgrade -PP gnome2</span></code></pre></div></div><div class=paragraph><p>Si quiere solamente descargar los distfiles (o los packages, usando <code>-P</code>) sin compilar ni instalar nada, use <code>-F</code>. Para más información consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=portupgrade&amp;sektion=1&amp;format=html">portupgrade(1)</a>.</p></div></div><div class=sect4><h5 id=portmanager>4.5.4.3. Actualización de ports con portmanager<a class=anchor href=#portmanager></a></h5><div class=paragraph><p>Portmanager es otra aplicación pensada para la actualización sencilla de ports instalados en el sistema. Puede encontrarla en <a class=package href=https://cgit.freebsd.org/ports/tree/ports-mgmt/portmanager/>ports-mgmt/portmanager</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/ports-mgmt/portmanager</span>
<span class=c># make install clean</span></code></pre></div></div><div class=paragraph><p>Puede actualizar todos los ports que tenga instalados con una sola orden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portmanager -u</span></code></pre></div></div><div class=paragraph><p>Si usa el modificador <code>-ui</code> se le pedirá confirmación a cada paso que Portmanager vaya a dar. Portmanager también puede usarse para instalar nuevos ports. A diferencia del habitual <code>make install clean</code> actualizará todos los ports que dependan antes de compilar e instalar ese port que queramos instalar.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portmanager x11/gnome2</span></code></pre></div></div><div class=paragraph><p>Si aparecen problemas con las dependencias del port que quiere instalar puede usar Portmanager para recompilar todos ello en el orden correcto. Una vez que acabe el port que estaba dando problemas será también recompilado.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portmanager graphics/gimp -f</span></code></pre></div></div><div class=paragraph><p>Para más información consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=portmanager&amp;sektion=1&amp;format=html">portmanager(1)</a>.</p></div></div><div class=sect4><h5 id=portmaster>4.5.4.4. Actualización de ports con portmaster<a class=anchor href=#portmaster></a></h5><div class=paragraph><p>Portmaster es otra aplicación para actualizar ports. Portmaster se diseñó para que utilizara las herramientas del sistema «base» (es decir, no depende de otros ports) y utiliza la información que se almacena en el directorio <span class=filename>/var/db/pkg/</span> para determinar qué port es el que hay que actualizar. Puede encontrarlo en <a class=package href=https://cgit.freebsd.org/ports/tree/ports-mgmt/portmaster/>ports-mgmt/portmaster</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/ports-mgmt/portmaster</span>
<span class=c># make install clean</span></code></pre></div></div><div class=paragraph><p>Portmaster agrupa los ports en cuatro categorías:</p></div><div class=ulist><ul><li><p>«Root ports» (no tienen dependencias, ningún port depende de ellos)</p></li><li><p>«Trunk ports» (no tienen dependencias, otros ports dependen de ellos)</p></li><li><p>«Branch ports» (tienen dependencias, otros ports dependen de ellos)</p></li><li><p>«Leaf ports» (tienen dependencias, ningún port depende de ellos)</p></li></ul></div><div class=paragraph><p>Puede ver una lista de los ports instalados y buscar actualizaciones para ellos usando el modificador <code>-L</code> :</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portmaster -L</span>
<span class=o>===&gt;&gt;&gt;</span> Root ports <span class=o>(</span>No dependencies, not depended on<span class=o>)</span>
<span class=o>===&gt;&gt;&gt;</span> ispell-3.2.06_18
<span class=o>===&gt;&gt;&gt;</span> screen-4.0.3
        <span class=o>===&gt;&gt;&gt;</span> New version available: screen-4.0.3_1
<span class=o>===&gt;&gt;&gt;</span> tcpflow-0.21_1
<span class=o>===&gt;&gt;&gt;</span> 7 root ports
...
<span class=o>===&gt;&gt;&gt;</span> Branch ports <span class=o>(</span>Have dependencies, are depended on<span class=o>)</span>
<span class=o>===&gt;&gt;&gt;</span> apache-2.2.3
        <span class=o>===&gt;&gt;&gt;</span> New version available: apache-2.2.8
...
<span class=o>===&gt;&gt;&gt;</span> Leaf ports <span class=o>(</span>Have dependencies, not depended on<span class=o>)</span>
<span class=o>===&gt;&gt;&gt;</span> automake-1.9.6_2
<span class=o>===&gt;&gt;&gt;</span> bash-3.1.17
        <span class=o>===&gt;&gt;&gt;</span> New version available: bash-3.2.33
...
<span class=o>===&gt;&gt;&gt;</span> 32 leaf ports

<span class=o>===&gt;&gt;&gt;</span> 137 total installed ports
        <span class=o>===&gt;&gt;&gt;</span> 83 have new versions available</code></pre></div></div><div class=paragraph><p>Con la siguiente orden puede actualizar todos los ports del sistema:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portmaster -a</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Por omisión Portmaster guardará una copia de seguridad (un package) de cada port antes de borrarlo. Si la instalación de la nueva versión funciona Portmaster borrará el package. Si utiliza <code>-b</code> le dirá a Portmaster que no borre automáticamente el package. Si usa el modificador <code>-i</code> arrancará Portmaster en modo interactivo, lo que significa que le pedirá confirmación antes de actualizar cada port.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Si se encuentra con errores durante el proceso de actualización puede utilizar el modificador <code>-f</code> para actualizar o recompilar todos los ports:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portmaster -af</span></code></pre></div></div><div class=paragraph><p>También puede usar Portmaster para instalar nuevos ports en el sistema, actualizando todas sus dependencias antes de compilar e instalar el nuevo port:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portmaster shells/bash</span></code></pre></div></div><div class=paragraph><p>Por favor, consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=portmaster&amp;sektion=8&amp;format=html">portmaster(8)</a> para más información.</p></div></div></div><div class=sect3><h4 id=ports-disk-space>4.5.5. Los ports y el espacio en disco<a class=anchor href=#ports-disk-space></a></h4><div class=paragraph><p>Usar la Colección de Ports consume mucho espacio de disco según pasa el tiempo. Por culpa de la tendencia del árbol de ports a crecer sin parar le recomendamos que después de compilar e instalar sofware desde los ports recuerde limpiar los directorios temporales <span class=filename>work</span> mediante la orden <code>make clean</code>. Puede limpiar de un plumazo los directorios temporales de toda la Colección de Ports con la siguiente orden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portsclean -C</span></code></pre></div></div><div class=paragraph><p>Rápidamente acumulará gran cantidad de viejas distribuciones de código en <span class=filename>distfiles</span>. Puede borrarlos a mano, pero también puede usar la siguiente orden para borrar todos los distfiles que no tengan relación con ningún port:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portsclean -D</span></code></pre></div></div><div class=paragraph><p>También puede borrar todos los distfiles sin relación con ningún port instalado en el sistema:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portsclean -DD</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p><code>portsclean</code> forma parte de la «suite» portupgrade.</p></div></td></tr></tbody></table></div><div class=paragraph><p>No olvide borrar los ports instalados una vez que deja de necesitarlos. Hay una herramienta muy útil para ayudar a automatizar esta tarea: <a class=package href=https://cgit.freebsd.org/ports/tree/ports-mgmt/pkg_cutleaves/>ports-mgmt/pkg_cutleaves</a>.</p></div></div></div><div class=sect2><h3 id=ports-nextsteps>4.6. Después de instalar un port<a class=anchor href=#ports-nextsteps></a></h3><div class=paragraph><p>Una vez que ha instalado una nueva aplicación normalmente deberáa leer toda la documentación que incluya, editar los ficheros de configuración necesarios, asegurarse de que la aplicación se ejecute al arrancar el sistema (si es un dæmon)etc.</p></div><div class=paragraph><p>Obviamente los pasos exactos para configurar cada aplicación son distintos de una a otra. De cualquier forma, si acaba de instalar aplicación y se pregunta «?Y ahora qué?» estos consejos puede que le ayuden:</p></div><div class=ulist><ul><li><p>Use <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg_info&amp;sektion=1&amp;format=html">pkg_info(1)</a> para ver qué ficheros se instalaron y dónde. Por ejemplo, si instalón el paquete Un-Package 1.0.0, lo siguiente:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg_info -L un-package-1.0.0 | less</span></code></pre></div></div><div class=paragraph><p>mostrará los ficheros instalados por el paquete. Preste especial atención a los ficheros en el directorio <span class=filename>man/</span>, que son las páginas de ayuda y los del directorio <span class=filename>etc/</span>, que contiene los ficheros de configuración; bajo el directorio <span class=filename>doc/</span> podrá encontrar información más detallada.</p></div><div class=paragraph><p>Si no está seguro de qué versión del paquete ha instalado, teclée:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg_info | grep -i un-package</span></code></pre></div></div><div class=paragraph><p>y verá todos los paquetes que se llaman <em>un-package</em>. Reemplace <em>un-package</em> en la línea de órdenes que tenga que usar en su caso.</p></div></li><li><p>Una vez que ha identificado las páginas de manual de la aplicación revíselas mediante <a href="https://man.freebsd.org/cgi/man.cgi?query=man&amp;sektion=1&amp;format=html">man(1)</a>. Revise también los ficheros de configuración, así como cualquier otro tipo de documentación que venga con el software.</p></li><li><p>Si la aplicación tiene sitio web visítelo. Es muy posible que encuentre más documentación, listas de preguntas frecuentes (FAQ), etc. Si no sabe cuál puede ser la dirección del sitio web examine la salida de la orden</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg_info un-package-1.0.0</span></code></pre></div></div><div class=paragraph><p>a veces incluye una línea <code>WWW:</code>, que contiene la dirección del sitio web de la aplicación.</p></div></li><li><p>Los ports que deben arrancar con el sistema (como los servidores de Internet) normalmente instalaran un «script» de ejemplo en <span class=filename>/usr/local/etc/rc.d</span>. Debe revisar este «script» para comprobar que todo sea correcto, editarlo o renombrarlo si fuera necesario. Consulte <a href=./#configtuning-starting-services>Cómo arrancar servicios</a> para más información.</p></li></ul></div></div><div class=sect2><h3 id=ports-broken>4.7. Ports que no funcionan<a class=anchor href=#ports-broken></a></h3><div class=paragraph><p>Si encuentra un port que no funciona hay varias cosas que puede hacer:</p></div><div class="olist arabic"><ol class=arabic><li><p>Consulte en la <a href=http://www.freebsd.org/support#gnats>Base de datos de informes de error</a> si ya se ha publicado un parche que lo solucione. Si es el caso puede aplicar aplicar el parche en su sistema.</p></li><li><p>Pida ayuda al responsable del mantenimiento (conocido como «mantainer») del port. Teclée <code>make maintainer</code> o consulte el <span class=filename>Makefile</span> del port si no sabe cuál es la dirección de correo del «mantainer». Recuerde que debe incluir el nombre y la versión del port. Envíe la línea que contiene <code>$FreeBSD:</code> al principio del <span class=filename>Makefile</span> del port y salida con el error que obtiene al intentar usar la aplicación.</p><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Algunos ports no son responsabilidad de un individuo sino de <a href=https://docs.freebsd.org/es/articles/mailing-list-faq/>una lista de correo.</a> Muchas, aunque no todas, tienen un aspecto parecido a <a href=mailto:freebsd-nombredelalista@FreeBSD.org>freebsd-nombredelalista@FreeBSD.org</a>. Por favor, téngalo en cuenta cuando envie ese correo sobre el port que no funciona.</p></div><div class=paragraph><p>Hay un caso especial: Los ports que tienen como «mantainer» <a href=mailto:freebsd-ports@FreeBSD.org>freebsd-ports@FreeBSD.org</a> en realidad no son responsabilidad de nadie. Los parches y el soporte, en caso de existir, vienen de la comunidad de usuarios y desarrolladores que están suscritos a la lista. Por cierto, siempre hacen falta más voluntarios.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Si no recibe respuesta utilice <a href="https://man.freebsd.org/cgi/man.cgi?query=send-pr&amp;sektion=1&amp;format=html">send-pr(1)</a> para enviar un informe de errores. Consulte <a href=https://docs.freebsd.org/es/articles/problem-reports/>Cómo escribir informes de error</a>)</p></div></li><li><p><em>Arreglarlo</em>. El «Porter’s Handbook» incluye información detallada sobre la infraestructura de los ports, así que puede arreglar un port roto o incluso enviar su propio port.</p></li><li><p>Descargue el paquete de algún sitio FTP. El servidor «principal» de la colección de paquetes está en el <a href=ftp://ftp.FreeBSD.org/pub/FreeBSD/ports/packages/>directorio de paquetes</a> de <code>ftp.FreeBSD.org</code> <em>pero asegúrese de mirar antes en la réplica más próxima</em>. Esta es una forma de instalar aplicaciones más fácil y más rápida. Instale el paquete mediante <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg_add&amp;sektion=1&amp;format=html">pkg_add(1)</a>.</p></li></ol></div></div></div></div><div class=sect1><h2 id=x11>Capítulo 5. El sistema X Window<a class=anchor href=#x11></a></h2><div class=sectionbody><div class=sect2><h3 id=x11-synopsis>5.1. Sinopsis<a class=anchor href=#x11-synopsis></a></h3><div class=paragraph><p>FreeBSD usa X11 para proporcionar una potente interfaz gráfica. X11 es una implementación de código abierto del sistema X Window que incluye Xorg y XFree86™. En las versiones de FreeBSD hasta FreeBSD 4.10-RELEASE y FreeBSD 5.3-RELEASE el sistema X window que se instalará por defecto es XFree86™, el servidor X11 distribuido por el proyecto XFree86™. Después de FreeBSD 5.3-RELEASE el sistema X Window pasó a ser Xorg, el servidor X11 distribuido por la Fundación X.Org.</p></div><div class=paragraph><p>Este capítulo cubre la instalación y configuración de X11 poniendo énfasis en Xorg. Si quiere información sobre la configuración de XFree86™ o versiones anteriores de Xorg consulte las versiones archivadas del «Handbook» de FreeBSD en <a href=http://docs.FreeBSD.org/doc/>http://docs.FreeBSD.org/doc/</a>.</p></div><div class=paragraph><p>Para mas información del hardware de vídeo que X11 soporta consulte la página web de <a href=http://www.x.org/>Xorg</a>.</p></div><div class=paragraph><p>Después de leer este capítulo usted sabrá:</p></div><div class=ulist><ul><li><p>Cuáles son los diferentes componentes del sistema X Window y como interoperan.</p></li><li><p>Cómo instalar y configurar X11.</p></li><li><p>Cómo instalar y usar diferentes gestores de ventanas.</p></li><li><p>Cómo usar tipos de letra TrueType® en X11.</p></li><li><p>Como preparar su sistema para iniciar la sesión de forma gráfica (XDM).</p></li></ul></div><div class=paragraph><p>Antes de leer este capítulo debería:</p></div><div class=ulist><ul><li><p>Saber cómo instalar software de terceros (<a href=./#ports>Instalación de aplicaciones: «packages» y ports</a>).</p></li></ul></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Este capítulo cubre la instalación y configuración de los servidores X11 Xorg y XFree86™. La mayoría de los ficheros de configuración, órdenes y sintaxis son idénticos. En los casos en que haya diferencias se mostrará la sintaxis de Xorg y XFree86™.</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=x-understanding>5.2. Entender X<a class=anchor href=#x-understanding></a></h3><div class=paragraph><p>Usar X por primera vez puede resultar chocante para alguien familiarizado con otros entornos gráficos, como Microsoft® Windows® o Mac OS®.</p></div><div class=paragraph><p>No es necesario entender todos los detalles de los diferentes componentes de X y como interactúan, pero un conocimiento básico hace posible el sacarle más provecho a la potencia de X.</p></div><div class=sect3><h4 id=_por_qué_x>5.2.1. ¿Por qué X?<a class=anchor href=#_por_qué_x></a></h4><div class=paragraph><p>X no es el primer sistema de ventanas escrito para UNIX® pero es el más popular de todos ellos. El equipo original que desarrolló X trabajó en otro sistema de ventanas antes de escribir X. Ese sistema se llamó «W» (de «Window» que significa ventana en inglés). X era solo la siguiente letra en el alfabeto Romano.</p></div><div class=paragraph><p>X se puede llamar «X» «X Window System», «X11» y de otras formas. También puede usar el término «X Windows» para describir X11 si lo que quiere es ofender a algunas personas; si quiere saber más sobre esto consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=X&amp;sektion=7&amp;format=html">X(7)</a>.</p></div></div><div class=sect3><h4 id=_el_modelo_clienteservidor_de_x>5.2.2. El modelo cliente/servidor de X<a class=anchor href=#_el_modelo_clienteservidor_de_x></a></h4><div class=paragraph><p>X fue diseñado desde el principio pensando en redes y adoptó un modelo «cliente-servidor».</p></div><div class=paragraph><p>En el modelo de X el «servidor X» se ejecuta en la máquina que tiene el teclado, monitor y ratón. El servidor es responsable de manejar la pantalla, la entrada de datos a través del teclado, el ratón, etc. Cada aplicación X (como una XTerm o <a href="https://man.freebsd.org/cgi/man.cgi?query=getenv&amp;sektion=3&amp;format=html">getenv(3)</a>) es un «cliente». Un cliente manda mensajes al servidor como «Por favor dibuja una ventana en estas coordenadas» y el servidor devuelve mensajes como «El usuario ha pulsado el botón OK».</p></div><div class=paragraph><p>Sí solo hay un ordenador involucrado, como en una casa o una pequeña oficina, el servidor X y los clientes X seguramente se ejecutarán en el mismo sistema. Sin embargo, es perfectamente posible ejecutar el servidor X en un sistema de escritorio menos potente y ejecutar las aplicaciones X (los clientes) en, por ejemplo, la potente y cara máquina que sirve la oficina. En este panorama la comunicación entre el cliente X y el servidor tiene lugar a través de la red.</p></div><div class=paragraph><p>Esto confunde a algunas personas, porque la terminología es exactamente opuesta a lo que ellos esperan. Ellos esperan que el «servidor X» sea la máquina grande que hay en el sótano y que el «cliente X» sea la máquina de su mesa.</p></div><div class=paragraph><p>Es importante que recuerde que el servidor X es la máquina con el monitor y el teclado y que los clientes X son los programas que muestran las ventanas.</p></div><div class=paragraph><p>No hay nada en el protocolo que obligue a que el cliente y el servidor tengan que usar el mismo sistema operativo o incluso que estén en el mismo sistema. Es posible ejecutar un servidor X en Microsoft® Windows® o en el Mac OS® de Apple; de hecho hay varias aplicaciones libres y comerciales que hacen exactamente eso.</p></div><div class=paragraph><p>A partir de FreeBSD 5.3-RELEASE, el servidor X que se instala con FreeBSD es Xorg, que es libre y se distribuye bajo una licencia muy similar a la de FreeBSD. También hay servidores X comerciales para FreeBSD.</p></div></div><div class=sect3><h4 id=_el_gestor_de_ventanas>5.2.3. El gestor de ventanas<a class=anchor href=#_el_gestor_de_ventanas></a></h4><div class=paragraph><p>La filosofía de diseño de X es más parecida a la de UNIX®: «herramientas, no normas». Esto significa que X no impone cómo debe hacerse una tarea. En lugar de eso proporciona herramientas al usuario y es responsabilidad suya decidir qué hacer con ellas.</p></div><div class=paragraph><p>Esta filosofía se extiende a X; no impone como deben verse las ventanas en la pantalla, cómo moverlas con el ratón, qué teclas deberían usarse para moverse entre ventanas (por ejemplo <span class=keyseq><kbd>Alt</kbd>+<kbd>Tab</kbd></span>, en Microsoft® Windows®), cómo deben ser las barras de título en cada ventana, si tienen o no botón de cierre, etc.</p></div><div class=paragraph><p>En lugar de eso X delega esta responsabilidad en una aplicación llamada «gestor de ventanas». Hay docenas de gestores de ventanas disponibles para X: AfterStep, Blackbox, ctwm, Enlightenment, fvwm, Sawfish, twm, Window Maker, etc. Cada uno de estos gestores de ventanas tiene un aspecto diferente; algunos soportan «escritorios virtuales»; otros permiten personalizar las teclas para manejar el escritorio; otros tienen un botón de «Inicio» o algo similar; otros tienen «diseños modificables», permitiendo un cambio completo del aspecto mediante un nuevo diseño. Estos gestores de ventanas, y muchos otros, están en la categoría <span class=filename>x11-wm</span> de los ports.</p></div><div class=paragraph><p>Además, los entornos de escritorio KDE y GNOME tienen sus propios gestores de ventanas integrados con el escritorio.</p></div><div class=paragraph><p>Cada gestor de ventanas tiene diferentes mecanismos de configuración; en algunos debe escribir el fichero de configuración a mano, otros tienen herramientas gráficas para la mayor parte de la configuración; y al menos uno (Sawfish) tiene un fichero de configuración escrito en un dialecto del lenguaje Lisp.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=title>Política de foco</div><div class=paragraph><p>Otra responsabilidad del gestor de ventanas es la «política de foco» del ratón. Todos los sistemas de ventanas necesitan algo para elegir una ventana activa que recibirá los eventos y también debieran indicar claramente qué ventana está activa.</p></div><div class=paragraph><p>Una política muy popular es la de «click to focus». Este es el modelo que utiliza Microsoft® Windows®, en el que una ventana se convierte en activa al recibir un clic del ratón.</p></div><div class=paragraph><p>X no tiene ninguna política de foco. En lugar de eso el gestor de ventanas controla qué ventana tiene el foco en todo momento. Los diferentes gestores de ventanas tienen diferentes políticas de foco. Todos soportan la política «clic-para-foco» y la mayoría de ellos también soportan otros métodos.</p></div><div class=paragraph><p>Las políticas de foco más populares son:</p></div><div class=dlist><dl><dt class=hdlist1>el-foco-sigue-al-ratón (<code>focus-follows-mouse</code>)</dt><dd><p>La ventana que esta bajo el puntero del ratón es la ventana que tiene el foco. No es necesario que la ventana esté encima de las demás ventanas. El foco se cambia al apuntar a otra ventana, aunque no es necesario hacer clic en ella.</p></dd><dt class=hdlist1>foco-descuidado <code>sloppy-focus</code></dt><dd><p>Esta política es una pequeña extensión de «el-foco-sigue-al-ratón». En «el-foco-sigue-al-ratón» si el ratón se mueve sobre la ventana raíz (o fondo) ninguna ventana tiene el foco y las pulsaciones del teclado se perderán. Con la política «foco-descuidado» el foco sólo cambia cuando el cursor entra en una nueva ventana y no cuando sale de la ventana actual.</p></dd><dt class=hdlist1>click-para-foco <code>click-to-focus</code></dt><dd><p>La ventana activa se selecciona con un clic del ratón. La ventana se puede «levantar» y aparecer delante de las demás ventanas. Todas las pulsaciones de teclado serán redirigidas a esa ventana aunque el cursor se mueva a otra ventana.</p></dd></dl></div><div class=paragraph><p>Muchos gestores de ventanas soportan otras políticas o variaciones de estas. Consulte la documentación del propio gestor de ventanas.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=_widgets>5.2.4. Widgets<a class=anchor href=#_widgets></a></h4><div class=paragraph><p>La idea de X de hacer herramientas en vez de normas y se extiende a los «widgets» que se ven en la pantalla de cada aplicación.</p></div><div class=paragraph><p>«Widget» es un término que abarca todos los objetos en el interfaz de usuario que pueden pulsarse con el ratón manipularse de alguna manera: botones, «check boxes», listas, etc. Microsoft® Windows® los llama «controles».</p></div><div class=paragraph><p>Microsoft® Windows® y Mac OS® de Apple tienen una política de «widgets» muy rígida. Se supone que los desarrolladores de aplicaciones comparten el aspecto. En X no se consideró imponer un estilo gráfico o un conjunto de «widgets» al que adherirse.</p></div><div class=paragraph><p>Como resultado no se puede esperar que las aplicaciones de X tengan un aspecto homogéneo. Hay varios conjuntos de «widgets» y variaciones muy populares como el «widget» Athena creado en el MIT, Motif® (donde los «widgets» de Microsoft® Windows® fueron modelados, con todos los bordes biselados y tres tonos de gris), OpenLook, y otros.</p></div><div class=paragraph><p>Las aplicaciones más modernas de X usan un conjunto de «widgets» con mejor aspecto, o Qt, utilizado por KDE, o GTK+, que usa el proyecto GNOME. Se intenta que el aspecto del escritorio de UNIX® sea parecido, lo que hace la vida más fácil al usuario novato.</p></div></div></div><div class=sect2><h3 id=x-install>5.3. Instalar X11<a class=anchor href=#x-install></a></h3><div class=paragraph><p>Xorg es la implementación de X11 por omisión en FreeBSD. Xorg está basado en código de XFree86™ 4.4RC2 y X11R6.6. La versión de Xorg que se distribuye actualmente en la Colección de Ports de FreeBSD es la 7.7.</p></div><div class=paragraph><p>Para compilar e instalar Xorg desde la colección de ports:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/x11/xorg</span>
<span class=c># make install clean</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Si quiere compilar e instalar Xorg entero, asegúrese de tener como mínimo 2GB de espacio disponible.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Si lo prefiere puede instalar Xorg con packages. Cuando utilice la capacidad de <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg_add&amp;sektion=1&amp;format=html">pkg_add(1)</a> para instalar packages que descargue remotamente recuerde que no debe escribir el número de versión. <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg_add&amp;sektion=1&amp;format=html">pkg_add(1)</a> descargará automáticamente la última versión de la aplicación..</p></div><div class=paragraph><p>Veamos qué es lo que hay que hacer para descargar e instalar el package de Xorg:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg_add -r xorg</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>El anterior ejemplo instala la distribución X11 completa, es decir, servidores, clientes, tipos de letra, etc. Hay packages y ports con cada uno de esos elementos por separado.</p></div></td></tr></tbody></table></div><div class=paragraph><p>En el resto del capítulo se explica cómo configurar X11 y cómo configurar un entorno de escritorio que le resulte productivo.</p></div></div><div class=sect2><h3 id=x-config>5.4. Configuración de X11<a class=anchor href=#x-config></a></h3><div class=sect3><h4 id=_antes_de_empezar>5.4.1. Antes de empezar<a class=anchor href=#_antes_de_empezar></a></h4><div class=paragraph><p>Antes de configurar X11 necesitará la siguiente información sobre el sistema:</p></div><div class=ulist><ul><li><p>Especificaciones del monitor</p></li><li><p>Chipset de la tarjeta de vídeo</p></li><li><p>Memoria de la tarjeta de vídeo</p></li></ul></div><div class=paragraph><p>X11 usa las especificaciones del monitor para determinar la resolución y la frecuencia de refresco a la que funcionará. Estas especificaciones se pueden encontrar normalmente en la documentación que viene con el monitor o en la web del fabricante. Se necesitan dos rangos de números: la frecuencia de refresco horizontal y la vertical.</p></div><div class=paragraph><p>El chipset de la tarjeta de vídeo define qué controlador utilizará X11 para comunicarse con el hardware gráfico. Con la mayoría de chipsets es posible detectarlo automáticamente pero es útil saberlo en caso de que la detección automática no funcione.</p></div><div class=paragraph><p>La memoria de la tarjeta gráfica determina la resolución y la profundidad de color a la que el sistema funcionará. Es importante saberlo para que el usuario conozca las limitaciones del sistema.</p></div></div><div class=sect3><h4 id=_configurar_x11>5.4.2. Configurar X11<a class=anchor href=#_configurar_x11></a></h4><div class=paragraph><p>A partir de la versión 7.3 Xorg puede funcionar sin utilizar fichero de configuración; basta con teclear en el prompt:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% startx</code></pre></div></div><div class=paragraph><p>Si no funciona, o si la configuración por omisión no es aceptable, hay que configurar X11 a mano.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Ciertos entornos de escritorio como GNOME, KDE o XFce tienen herramientas que permiten al usuario configurar fácilmente parámetros de la pantalla como la resolución. Si la configuración por omisión no sirve y tiene idea de instalar un entorno de escritorio puede seguir adelante tranquilamente con la instalación del entorno de escritorio y utilice la herramienta que el software que instale le facilite.</p></div></td></tr></tbody></table></div><div class=paragraph><p>La configuración de X11 es un proceso que consta de múltiples pasos. El primero es generar un fichero inicial de configuración. Como superusuario teclee:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># Xorg -configure</span></code></pre></div></div><div class=paragraph><p>Esto generará un fichero de configuración bastante esquemático pero completo en <span class=filename>/root</span> llamado <span class=filename>xorg.conf.new</span> (si ha utilizado <a href="https://man.freebsd.org/cgi/man.cgi?query=su&amp;sektion=1&amp;format=html">su(1)</a> o ha entrado directamente como superusuario afectará al valor que tenga la variable de directorio <code>$HOME</code>). X11 intentará probar el hardware gráfico del sistema y escribir un fichero de configuración en el que registrar los controladores de dispositivo adecuados para hacer funcionar el harware que haya detectado.</p></div><div class=paragraph><p>El siguiente paso es probar el fichero generado para verificar si Xorg puede funcionar con el hardware gráfico del sistema. Para ello teclee:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># Xorg -config xorg.conf.new</span></code></pre></div></div><div class=paragraph><p>Si aparece una rejilla negra y gris junto con el cursor del ratón con forma de X es que la configuración ha tenido éxito. Para salir de la prueba pulse simultáneamente <span class=keyseq><kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>Retroceso</kbd></span>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Si el ratón no funciona tendrá que configurarlo antes de continuar. Consulte la <a href=./#mouse>Configuratión del ratón</a> en el capítulo de instalación de FreeBSD.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Después modifique el fichero <span class=filename>xorg.conf.new</span> a su gusto. Abra el fichero con un editor de texto (como <a href="https://man.freebsd.org/cgi/man.cgi?query=emacs&amp;sektion=1&amp;format=html">emacs(1)</a> o <a href="https://man.freebsd.org/cgi/man.cgi?query=ee&amp;sektion=1&amp;format=html">ee(1)</a>). Primero añada las frecuencias del monitor. Estas suelen estar expresadas en frecuencia de refresco horizontal y vertical. Estos valores se añaden al fichero <span class=filename>xorg.conf.new</span> en la sección <code>"Monitor"</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>Section &#34;Monitor&#34;
        Identifier   &#34;Monitor0&#34;
        VendorName   &#34;Monitor Vendor&#34;
        ModelName    &#34;Monitor Model&#34;
        HorizSync    30-107
        VertRefresh  48-120
EndSection</pre></div></div><div class=paragraph><p>Las palabras <code>HorizSync</code> y <code>VertRefresh</code> podrían no existir en el fichero de configuración. Si no existen es necesario añadirlas con la frecuencia horizontal correcta puesta después de la palabra <code>HorizSync</code> y la frecuencia vertical correcta después de la palabra <code>VertRefresh</code>. En el ejemplo anterior se pusieron las frecuencias del monitor.</p></div><div class=paragraph><p>X permite usar las características DPMS (Energy Star) con los monitores que lo soportan. El programa <a href="https://man.freebsd.org/cgi/man.cgi?query=xset&amp;sektion=1&amp;format=html">xset(1)</a> controla el «timeout», y puede forzar los modos «standby», suspendido o apagado. Si desea habilitar las características DPMS para su monitor tendrá que añadir la siguiente línea en la sección <code>monitor</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>        Option       &#34;DPMS&#34;</pre></div></div><div class=paragraph><p>Agrege a su <span class=filename>xorg.conf.new</span> la resolución por omisión y la profundidad de color deseada. Esto se define en la sección <code>"Screen"</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>Section &#34;Screen&#34;
        Identifier &#34;Screen0&#34;
        Device     &#34;Card0&#34;
        Monitor    &#34;Monitor0&#34;
        DefaultDepth 24
        SubSection &#34;Display&#34;
                Viewport  0 0
                Depth     24
                Modes     &#34;1024x768&#34;
        EndSubSection
EndSection</pre></div></div><div class=paragraph><p>La palabra <code>DefaultDepth</code> describe la profundidad de color a la que arrancará por omisión. Esto puede sobrescribirse con el argumento <code>-bpp</code> de <a href="https://man.freebsd.org/cgi/man.cgi?query=Xorg&amp;sektion=1&amp;format=html">Xorg(1)</a> (o <a href="https://man.freebsd.org/cgi/man.cgi?query=XFree86&amp;sektion=1&amp;format=html">XFree86(1)</a>). La palabra <code>Modes</code> describe la resolución a la que funcionará para esa profundidad de color. Observe que sólo los modos estándar VESA están soportados por el hardware gráfico. En el ejemplo anterior la profundidad de color es 24 bits por pixel. En esta profundidad de color la resolución aceptada es 1024 por 768 pixels.</p></div><div class=paragraph><p>Para acabar guarde el fichero de configuración y pruébelo usando el modo de prueba descrito anteriormente</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Una de las herramientas disponibles para ayudarle con el proceso de solución de problemas es el fichero de «logs», que contiene información de cada dispositivo al que el servidor X11 se conecta. Los «logs» (o bitácoras) de Xorg se pueden encontrar en <span class=filename>/var/log/Xorg.0.log</span> El nombre exacto del fichero de «log» puede variar entre <span class=filename>Xorg.0.log</span> y <span class=filename>Xorg.8.log</span> y así sucesivamente.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Si todo ha ido bien ha llegado el momento de ubicar el fichero de configuración donde <a href="https://man.freebsd.org/cgi/man.cgi?query=Xorg&amp;sektion=1&amp;format=html">Xorg(1)</a> pueda encontrarlo. Puede dejarlo en <span class=filename>/etc/X11/xorg.conf</span> o <span class=filename>/usr/local/etc/X11/xorg.conf</span>.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cp xorg.conf.new /etc/X11/xorg.conf</span></code></pre></div></div><div class=paragraph><p>El proceso de configuración de X11 ha concluido. Arranque Xorg mediante <a href="https://man.freebsd.org/cgi/man.cgi?query=startx&amp;sektion=1&amp;format=html">startx(1)</a>. Puede también arrancar el servidor X11 utilizando <a href="https://man.freebsd.org/cgi/man.cgi?query=xdm&amp;sektion=1&amp;format=html">xdm(1)</a>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Existe también una herramienta gráfica de configuración en X11, <a href="https://man.freebsd.org/cgi/man.cgi?query=xorgcfg&amp;sektion=1&amp;format=html">xorgcfg(1)</a>. Permite definir de forma interactiva su configuració mediante la elección de los controladores y las opciones adecuadas. Este programa también puede usarse desde consola mediante la orden <code>xorgcfg -textmode</code>. Para más información consulte la página de manual de <a href="https://man.freebsd.org/cgi/man.cgi?query=xorgcfg&amp;sektion=1&amp;format=html">xorgcfg(1)</a>.</p></div><div class=paragraph><p>Puede usar también <a href="https://man.freebsd.org/cgi/man.cgi?query=xorgconfig&amp;sektion=1&amp;format=html">xorgconfig(1)</a>. Este programa es una herramienta orientada a consola que es bastante menos atractiva para el usuario, pero que puede funcionar en situaciones en las que otras herramientas no sirven.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=_configuración_avanzada>5.4.3. Configuración avanzada<a class=anchor href=#_configuración_avanzada></a></h4><div class=sect4><h5 id=_configuración_de_chipsets_gráficos_intel_i810>5.4.3.1. Configuración de chipsets gráficos Intel® i810<a class=anchor href=#_configuración_de_chipsets_gráficos_intel_i810></a></h5><div class=paragraph><p>Para configurar los chipsets integrados Intel® i810 es necesario el interfaz de programación AGP <span class=filename>agpart</span> para que X11 pueda usarla. Consulte la página de manual de <a href="https://man.freebsd.org/cgi/man.cgi?query=agp&amp;sektion=4&amp;format=html">agp(4)</a> para más información.</p></div><div class=paragraph><p>Hecho esto podrá configurar el hardware como cualquier otra tarjeta gráfica. Tenga en cuenta que si en un sistema que no tenga el controlador <a href="https://man.freebsd.org/cgi/man.cgi?query=agp&amp;sektion=4&amp;format=html">agp(4)</a> intenta cargar el módulo del kernel con <a href="https://man.freebsd.org/cgi/man.cgi?query=kldload&amp;sektion=8&amp;format=html">kldload(8)</a> no va a funcionar. El controlador tiene necesariamente que estar en el kernel desde el mismo momento del arranque, cosa que puede obtenerse bien compilando un nuevo kernel, bien utilizando <span class=filename>/boot/loader.conf</span>.</p></div></div><div class=sect4><h5 id=_añadir_una_pantalla_panorámica_a_nuestro_sistema>5.4.3.2. Añadir una pantalla panorámica a nuestro sistema<a class=anchor href=#_añadir_una_pantalla_panorámica_a_nuestro_sistema></a></h5><div class=paragraph><p>A lo largo de esta sección se asumen unos mínimos de soltura con ciertos aspectos de configuración avanzada. Si Si las herramientas estándar de configuración que se han descrito previamente no le ayudan a tener una configuración funcional busque en los ficheros de log, ahí encontrará información suficiente para lograrlo. Tendrá que utilizar un editor de texto a lo largo de estas instrucciones.</p></div><div class=paragraph><p>Los formatos actuales de pantalla panorámica, (también conocidas como «Widescreen», WSXGA, WSXGA+, WUXGA, WXGA, WXGA+, etc, soportan formatos de 16:10 y 10:9 o aspectos-tasa que pueden ser problemáticos. Veamos algunos ejemplos de resoluciones de pantalla en formatos 16:10:</p></div><div class=ulist><ul><li><p>2560x1600</p></li><li><p>1920x1200</p></li><li><p>1680x1050</p></li><li><p>1440x900</p></li><li><p>1280x800</p></li></ul></div><div class=paragraph><p>At some point, it will be as easy as adding one of these resolutions as a possible <code>Mode</code> in the <code>Section "Screen"</code> as such:</p></div><div class="literalblock programlisting"><div class=content><pre>Section &#34;Screen&#34;
Identifier &#34;Screen0&#34;
Device     &#34;Card0&#34;
Monitor    &#34;Monitor0&#34;
DefaultDepth 24
SubSection &#34;Display&#34;
	Viewport  0 0
	Depth     24
	Modes     &#34;1680x1050&#34;
EndSubSection
EndSection</pre></div></div><div class=paragraph><p>Xorg se basta y se sobra para recabar la información de resolución de su pantalla panorámica mediante la información I2C/DDC, así que sabe qué frecuencias y resoluciones puede manejar el monitor.</p></div><div class=paragraph><p>Si esas <code>ModeLines</code> no existen en los controladores tendrá usted que ayudar un poco a Xorg. Lea atentamente el contenido de <span class=filename>/var/log/Xorg.0.log</span>; de él podrá extraer suficiente información como para crear un <code>ModeLine</code> que funcione. Todo lo que tiene que hacer es buscar información que se parezca a esta:</p></div><div class="literalblock programlisting"><div class=content><pre>(II) MGA(0): Supported additional Video Mode:
(II) MGA(0): clock: 146.2 MHz   Image Size:  433 x 271 mm
(II) MGA(0): h_active: 1680  h_sync: 1784  h_sync_end 1960 h_blank_end 2240 h_border: 0
(II) MGA(0): v_active: 1050  v_sync: 1053  v_sync_end 1059 v_blanking: 1089 v_border: 0
(II) MGA(0): Ranges: V min: 48  V max: 85 Hz, H min: 30  H max: 94 kHz, PixClock max 170 MHz</pre></div></div><div class=paragraph><p>Esta información se llama información EDID. Para crear una <code>ModeLine</code> a partir de estos datos solamente tiene que poner los números en el orden correcto:</p></div><div class="literalblock programlisting"><div class=content><pre>ModeLine &lt;name&gt; &lt;clock&gt; &lt;4 horiz. timings&gt; &lt;4 vert. timings&gt;</pre></div></div><div class=paragraph><p>Así que la <code>ModeLine</code> en la <code>Section "Monitor"</code> del ejemplo tendría este aspecto:</p></div><div class="literalblock programlisting"><div class=content><pre>Section &#34;Monitor&#34;
Identifier      &#34;Monitor1&#34;
VendorName      &#34;Bigname&#34;
ModelName       &#34;BestModel&#34;
ModeLine        &#34;1680x1050&#34; 146.2 1680 1784 1960 2240 1050 1053 1059 1089
Option          &#34;DPMS&#34;
EndSection</pre></div></div><div class=paragraph><p>Como ve, con un poco de edición hemos culminado la tarea y X debería ya poder arrancar sin problemas en su nuevo monitor panorámico.</p></div></div></div></div><div class=sect2><h3 id=x-fonts>5.5. Uso de tipos en X11<a class=anchor href=#x-fonts></a></h3><div class=sect3><h4 id=type1>5.5.1. Tipos Type1<a class=anchor href=#type1></a></h4><div class=paragraph><p>Los tipos que X11 incluye por omisión no son precisamente ideales para las aplicaciones típicas. Los tipos grandes para presentaciones aparecen dentados y con un aspecto poco profesional, mientras que los tipos pequeños en <a href="https://man.freebsd.org/cgi/man.cgi?query=getenv&amp;sektion=3&amp;format=html">getenv(3)</a> son prácticamente ilegibles. Sin embargo hay varios tipos de letra libres Type1 de alta calidad (PostScript®) que se pueden usar con X11. Por ejemplo los tipos URW (<a class=package href=https://cgit.freebsd.org/ports/tree/x11-fonts/urwfonts/>x11-fonts/urwfonts</a>) incluyen una versión de alta calidad de los tipos estándar Type 1 (Times Roman™, (Helvetica™, (Palatino™, y muchas otras). Las Freefonts (<a class=package href=https://cgit.freebsd.org/ports/tree/x11-fonts/freefonts/>x11-fonts/freefonts</a> ) incluyen muchas más pero la mayoría están pensadas para usarse con software gráfico como el Gimp y no son lo bastante completos para usarse como tipos de pantalla. Además X11 se puede configurar para usar tipos TrueType® con un esfuerzo mínimo. Para más detalles sobre esto consulte la página del manual <a href="https://man.freebsd.org/cgi/man.cgi?query=X&amp;sektion=7&amp;format=html">X(7)</a> o la <a href=#truetype>sección de tipos TrueType®</a>.</p></div><div class=paragraph><p>Para instalar los tipos Type1 desde los ports ejecute las siguientes órdenes:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/x11-fonts/urwfonts</span>
<span class=c># make install clean</span></code></pre></div></div><div class=paragraph><p>Proceda del mismo modo con los FreeFonts o cualesquiera otras. Para que el servidor X las detecte añada la siguiente línea al fichero de configuración de X (<span class=filename>/etc/X11/xorg.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>FontPath &#34;/usr/X11R6/lib/X11/fonts/URW/&#34;</pre></div></div><div class=paragraph><p>o bien desde una emulación de terminal durante una sesión X ejecute</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% xset fp+ /usr/X11R6/lib/X11/fonts/URW
% xset fp rehash</code></pre></div></div><div class=paragraph><p>Esto funcionará hasta que la sesión X se cierre a menos que lo añada a su fichero de inicio (<span class=filename>~/.xinitrc</span> en el caso de una sesión <code>startx</code> normal o <span class=filename>~/.xsession</span> si hace login desde un gestor gráfico como XDM). Una tercera forma sería usando el nuevo fichero <span class=filename>/usr/X11R6/etc/fonts/local.conf</span>: consulte la sección de <a href=#antialias>anti-aliasing</a>.</p></div></div><div class=sect3><h4 id=truetype>5.5.2. Tipos TrueType®<a class=anchor href=#truetype></a></h4><div class=paragraph><p>Xorg se diseñó pensando en que utilizara tipos TrueType®. Hay dos módulos diferentes que pueden habilitar esta opción. El módulo freetype se usa en en este ejemplo porque es más consistente con el resto de «back-ends» de representación. Para habilitar el módulo freetype debe añadir la siguiente línea a la sección <code>"Module"</code> del fichero <span class=filename>/etc/X11/xorg.conf</span>.</p></div><div class="literalblock programlisting"><div class=content><pre>Load &#34;freetype&#34;</pre></div></div><div class=paragraph><p>Ahora haga un directorio para los tipos TrueType® (por ejemplo <span class=filename>/usr/X11R6/lib/X11/fonts/TrueType</span>) y copie todos los tipos TrueType® en este directorio. Recuerde que los tipos TrueType® no se pueden coger directamente de un Macintosh®; tienen que estar en formato UNIX®/MS-DOS®/Windows® para usarlas con X11. Una vez que los ficheros se hayan copiado en este directorio use ttmkfdir para crear un fichero <span class=filename>fonts.dir</span>, para que el representador de tipos de X sepa que se han instalado estos ficheros nuevos. <code>ttmkfdir</code> forma parte de la Colección de Ports de FreeBSD: <a class=package href=https://cgit.freebsd.org/ports/tree/x11-fonts/ttmkfdir/>x11-fonts/ttmkfdir</a>.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/local/lib/X11/fonts/TrueType</span>
<span class=c># ttmkfdir -o fonts.dir</span></code></pre></div></div><div class=paragraph><p>Ahora añada el directorio TrueType® a la ruta de tipos. Esto es igual que lo anteriormente descrito sobre los tipos <a href=#type1>Type1</a>. Ejecute:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% xset fp+ /usr/local/lib/X11/fonts/TrueType
% xset fp rehash</code></pre></div></div><div class=paragraph><p>o añada una línea <code>FontPath</code> en su <span class=filename>/etc/X11/xorg.conf</span>.</p></div><div class=paragraph><p>Esto es todo. Ahora <a href="https://man.freebsd.org/cgi/man.cgi?query=getenv&amp;sektion=3&amp;format=html">getenv(3)</a>, Gimp, StarOffice™ y el resto de aplicaciones X debieran reconocer los tipos TrueType® instalados. Los tipos muy pequeños (como el texto en una pantalla con alta resolución viendo una página web) y los tipos muy grandes (Dentro de StarOffice™) se verán muchísimo mejor ahora.</p></div></div><div class=sect3><h4 id=antialias>5.5.3. Tipos Anti-Aliasing<a class=anchor href=#antialias></a></h4><div class=paragraph><p>Los «tipos anti-aliasing» han estado en X11 desde XFree86™ 4.0.2. Aunque la configuración de los tipos era incómoda antes de XFree86™ 4.3.0. A partir de XFree86™ 4.3.0 todos los tipos de X11 que se encuentren en <span class=filename>/usr/local/lib/X11/fonts/</span> y <span class=filename>~/.fonts/</span> están disponibles automáticamente para aplicaciones que soporten Xft. No todas las aplicaciones soportan Xft pero muchas ya tienen soporte Xft. Ejemplos de aplicaciones que lo soportan son Qt 2.3 o superior (el «toolkit» del escritorio KDE), GTK+ 2.0 o superior (el «toolkit» del escritorio GNOME ) y Mozilla 1.2 o superior.</p></div><div class=paragraph><p>Para controlar qué tipos «anti-aliasing» o configurar las propiedades «anti-aliasing» crée (o edite, si ya existe) el fichero <span class=filename>/usr/local/etc/fonts/local.conf</span>. Se pueden modificar diversas opciones avanzadas del sistema de tipos Xft usando este fichero; esta sección describe solo algunas posibilidades simples. Para más detalles consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=fonts-conf&amp;sektion=5&amp;format=html">fonts-conf(5)</a>.</p></div><div class=paragraph><p>Este fichero tiene que estar en formato XML. Preste especial atención a las mayúsculas y minúsculas y asegúrese de que las etiquetas están cerradas correctamente. El fichero empieza con la típica cabecera XML seguida de una definición DOCTYPE y después la etiqueta <code>&lt;fontconfig></code>:</p></div><div class="literalblock programlisting"><div class=content><pre>        &lt;?xml version=&#34;1.0&#34;?&gt;
        &lt;!DOCTYPE fontconfig SYSTEM &#34;fonts.dtd&#34;&gt;
        &lt;fontconfig&gt;</pre></div></div><div class=paragraph><p>Como se ha dicho antes todos los tipos en <span class=filename>/usr/local/lib/X11/fonts/</span> y en <span class=filename>~/.fonts/</span> están ya disponibles para las aplicaciones que soporten Xft. Si usted desea añadir otro directorio además de estos dos árboles de directorios añada una línea similar a esta en el fichero <span class=filename>/usr/local/etc/fonts/local.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>&lt;dir&gt;/ruta/de/mis/tipos&lt;/dir&gt;</pre></div></div><div class=paragraph><p>Después de añadir los nuevos tipos, y en especial los nuevos directorios de tipos, debe ejecutar la siguiente orden para reconstruir la caché de tipos:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># fc-cache -f</span></code></pre></div></div><div class=paragraph><p>Los «tipos anti-aliasing» hacen los bordes ligeramente borrosos, lo que hace que el texto muy pequeño sea más legible y elimina los escalones del texto grande pero puede causar fatiga visual aplicada al texto normal. Para excluir los tipos de menos de 14 puntos del «anti-aliasing» incluya las siguientes líneas:</p></div><div class="literalblock programlisting"><div class=content><pre>        &lt;match target=&#34;font&#34;&gt;
            &lt;test name=&#34;size&#34; compare=&#34;less&#34;&gt;
                &lt;double&gt;14&lt;/double&gt;
            &lt;/test&gt;
            &lt;edit name=&#34;antialias&#34; mode=&#34;assign&#34;&gt;
                &lt;bool&gt;false&lt;/bool&gt;
            &lt;/edit&gt;
        &lt;/match&gt;
        &lt;match target=&#34;font&#34;&gt;
            &lt;test name=&#34;pixelsize&#34; compare=&#34;less&#34; qual=&#34;any&#34;&gt;
                &lt;double&gt;14&lt;/double&gt;
            &lt;/test&gt;
            &lt;edit mode=&#34;assign&#34; name=&#34;antialias&#34;&gt;
                &lt;bool&gt;false&lt;/bool&gt;
            &lt;/edit&gt;
        &lt;/match&gt;</pre></div></div><div class=paragraph><p>El espacio entre algunos tipos también podría ser inapropiado con «anti-aliasing», por ejemplo en el caso de KDE. Una posible solución para esto es forzar que el espacio entre los tipos sea 100. Añada las siguientes líneas:</p></div><div class="literalblock programlisting"><div class=content><pre>       &lt;match target=&#34;pattern&#34; name=&#34;family&#34;&gt;
             &lt;test qual=&#34;any&#34; name=&#34;family&#34;&gt;
                 &lt;string&gt;fixed&lt;/string&gt;
             &lt;/test&gt;
             &lt;edit name=&#34;family&#34; mode=&#34;assign&#34;&gt;
                 &lt;string&gt;mono&lt;/string&gt;
             &lt;/edit&gt;
          &lt;/match&gt;
          &lt;match target=&#34;pattern&#34; name=&#34;family&#34;&gt;
              &lt;test qual=&#34;any&#34; name=&#34;family&#34;&gt;
                  &lt;string&gt;console&lt;/string&gt;
              &lt;/test&gt;
              &lt;edit name=&#34;family&#34; mode=&#34;assign&#34;&gt;
                  &lt;string&gt;mono&lt;/string&gt;
              &lt;/edit&gt;
          &lt;/match&gt;</pre></div></div><div class=paragraph><p>(Esto selecciona los otros nombres comunes para «tipos fixed» como <code>"mono"</code>); añada también lo siguiente:</p></div><div class="literalblock programlisting"><div class=content><pre>         &lt;match target=&#34;pattern&#34; name=&#34;family&#34;&gt;
             &lt;test qual=&#34;any&#34; name=&#34;family&#34;&gt;
                 &lt;string&gt;mono&lt;/string&gt;
             &lt;/test&gt;
             &lt;edit name=&#34;spacing&#34; mode=&#34;assign&#34;&gt;
                 &lt;int&gt;100&lt;/int&gt;
             &lt;/edit&gt;
         &lt;/match&gt;</pre></div></div><div class=paragraph><p>Algunos tipos, como Helvetica, podrían tener problemas con «anti-aliasing». Normalmente esto se manifiesta en tipos que parecen cortados verticalmente por la mitad. En el peor de los casos podría causar que el funcionamiento de aplicaciones como Mozilla se interrumpiese. Para evitar esto puede añadir lo siguiente a <span class=filename>local.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>         &lt;match target=&#34;pattern&#34; name=&#34;family&#34;&gt;
             &lt;test qual=&#34;any&#34; name=&#34;family&#34;&gt;
                 &lt;string&gt;Helvetica&lt;/string&gt;
             &lt;/test&gt;
             &lt;edit name=&#34;family&#34; mode=&#34;assign&#34;&gt;
                 &lt;string&gt;sans-serif&lt;/string&gt;
             &lt;/edit&gt;
         &lt;/match&gt;</pre></div></div><div class=paragraph><p>Una vez que haya terminado de editar <span class=filename>local.conf</span> asegúrese de que el fichero termina con la etiqueta <code>&lt;/fontconfig></code>. Si no lo hace los cambios que haya hecho serán ignorados.</p></div><div class=paragraph><p>Los tipos por omisión que vienen con X11 no son los ideales para «anti-aliasing». Puede encontrar otros mucho mejores en el port <a class=package href=https://cgit.freebsd.org/ports/tree/x11-fonts/bitstream-vera/>x11-fonts/bitstream-vera</a>. Este port instalará el fichero <span class=filename>/usr/local/etc/fonts/local.conf</span> si aun no se ha creado. Si el fichero existe el port creara el fichero <span class=filename>/usr/local/etc/fonts/local.conf-vera</span>. Combine el contenido de este fichero con <span class=filename>/usr/local/etc/fonts/local.conf</span> y los tipos Bitstream reemplazarán automáticamente los tipos por defecto por X11 Serif, Sans Serif y Monospaced.</p></div><div class=paragraph><p>Por si esto fuera poco los usuarios pueden añadir sus propios ajustes mediante sus ficheros personales <span class=filename>.fonts.conf</span>. Los usuarios que deseen hacerlo deberán crear un fichero <span class=filename>~/.fonts.conf</span>. Este fichero tiene que estar también en formato XML.</p></div><div class=paragraph><p>Un último punto: con pantallas LCD sería deseable un muestreo de subpixel, que consiste en configurar los componentes (separados horizontalmente) rojo, verde y azul para mejorar la resolución horizontal; los resultados pueden ser impresionantes. Para habilitarlo añada la siguiente línea a <span class=filename>local.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>        &lt;match target=&#34;font&#34;&gt;
            &lt;test qual=&#34;all&#34; name=&#34;rgba&#34;&gt;
                &lt;const&gt;unknown&lt;/const&gt;
            &lt;/test&gt;
            &lt;edit name=&#34;rgba&#34; mode=&#34;assign&#34;&gt;
                &lt;const&gt;rgb&lt;/const&gt;
            &lt;/edit&gt;
        &lt;/match&gt;</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Dependiendo del tipo de pantalla <code>rgb</code> podría ser <code>bgr</code> o <code>vrgb</code> o <code>vbgr</code>: experimente y elija cuál de ellos funciona mejor.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Una vez concluido el proceso «anti-aliasing» se debería activar la próxima vez que arranque X, aunque los programas necesitan saber como utilizarlo. En este momento el «toolkit» Qt es capaz de hacerlo, así que KDE entero puede usar «tipos anti-aliasing». GTK+ y GNOME también pueden usar «tipos anti-aliasing» mediante el «applet» «Font» (consulte <a href=#x11-wm-gnome-antialias>Tipos «Anti-aliased» en GNOME</a> para más detalle). Por omisión Mozilla 1.2 y versiones siguientes usarán automáticamente «tipos anti-aliasing». Para deshabilitarlos recompile Mozilla usando el parámetro <code>-DWITHOUT_XFT</code>.</p></div></div></div><div class=sect2><h3 id=x-xdm>5.6. El gestor de pantalla X<a class=anchor href=#x-xdm></a></h3><div class=sect3><h4 id=_descripción>5.6.1. Descripción<a class=anchor href=#_descripción></a></h4><div class=paragraph><p>El gestor de pantalla X (XDM) es una parte opcional del sistema X Window que se usa para la gestión de sesiones. Esto es útil en diferentes situaciones, como «Terminales X» con escritorios mínimos y grandes servidores de red. Como X Window System es independiente del protocolo y de la red hay muchas configuraciones posibles para ejecutar clientes y servidores X en diferentes equipos conectados a una red. XDM dispone de un interfaz gráfico para elegir a qué pantalla se quiere conectar y pedir la información de autentificación como el nombre de usuario y le contraseña.</p></div><div class=paragraph><p>XDM ac6túa como proveedor de la misma funcionalidad que <a href="https://man.freebsd.org/cgi/man.cgi?query=getty&amp;sektion=8&amp;format=html">getty(8)</a> (consulte <a href=./#term-config>Configuración</a> para más detalles). Esto quiere decir que se encarga de las entradas al sistema en la pantalla a la que está conectado y arranca el gestor de sesiones para que lo utilice el usuario (normalmente un gestor de ventanas X). XDM espera a que el programa termine, envía la señal de que el usuario ha terminado y que se le debería desconectar de la pantalla. En este punto XDM puede mostrar las pantallas de entrada al sistema y de selección de pantalla para que el siguiente usuario intente acceder al sistema.</p></div></div><div class=sect3><h4 id=_uso_de_xdm>5.6.2. Uso de XDM<a class=anchor href=#_uso_de_xdm></a></h4><div class=paragraph><p>El dæmon XDM está en <span class=filename>/usr/local/bin/xdm</span>. Este programa se puede arrancar en cualquier momento como <code>root</code> y empezará a gestionar la pantalla X en la máquina local. Si se quiere que XDM arranque cada vez que la máquina se encienda puede hacerlo añadiendo una entrada a <span class=filename>/etc/ttys</span>. Para más información sobre el formato y uso de este fichero consulte la <a href=./#term-etcttys>Agregando una entrada a /etc/ttys</a>. Por omisión hay una línea en <span class=filename>/etc/ttys</span> que permite arrancar el dæmon XDM en una terminal virtual:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>ttyv8   <span class=s2>&#34;/usr/local/bin/xdm -nodaemon&#34;</span>  xterm   off secure</code></pre></div></div><div class=paragraph><p>Por omisión esta entrada está deshabilitada; para habilitarla cambie el campo 5 de <code>off</code> a <code>on</code> y reinicie <a href="https://man.freebsd.org/cgi/man.cgi?query=init&amp;sektion=8&amp;format=html">init(8)</a> usando los pasos descritos en la <a href=./#term-hup>Forzar init a que relea /etc/ttys</a>. El primer campo es el nombre de la terminal que que gestiona el programa, <code>ttyv8</code>. Es decir, XDM empezará a ejecutarse en la terminal virtual número 9.</p></div></div><div class=sect3><h4 id=_configuración_de_xdm>5.6.3. Configuración de XDM<a class=anchor href=#_configuración_de_xdm></a></h4><div class=paragraph><p>El directorio de configuración de XDM está en <span class=filename>/usr/local/lib/X11/xdm</span>. En este directorio hay varios ficheros que se usan para intervenir en el comportamiento y la apariencia de XDM. Normalmente tendrá estos ficheros:</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Fichero</th><th class="tableblock halign-left valign-top">Descripción</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>Xaccess</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Reglas de acceso para clientes.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>Xresources</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Recursos de X por omisión.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>Xservers</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Lista de pantallas locales y remotas a gestionar.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>Xsession</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>«script» por omisión para el acceso al sistema.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>Xsetup_</span>*</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>«script» para lanzar aplicaciones antes del acceso al sistema.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>xdm-config</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Configuración de todas las pantallas de este equipo.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>xdm-errors</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Errores generados por el programa servidor.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>xdm-pid</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>El ID de proceso del XDM que está funcionando.</p></td></tr></tbody></table><div class=paragraph><p>En este directorio también hay unos cuantos programas y «scripts» que se usan para arrancar el escritorio cuando XDM se está ejecutando. El objetivo de cada uno de estos ficheros será descrito brevemente. La sintaxis exacta y el uso de todos estos ficheros se describe en <a href="https://man.freebsd.org/cgi/man.cgi?query=xdm&amp;sektion=1&amp;format=html">xdm(1)</a>.</p></div><div class=paragraph><p>La configuración por omisión es una simple ventana rectangular de acceso al sistema con el nombre de la máquina en la parte superior en un tipo de letra grande y unos campos para que introduzca«Login:» y «Password:» debajo. Este es un buen punto de partida para aprender a cambiar el aspecto de las pantallas de XDM.</p></div><div class=sect4><h5 id=_xaccess>5.6.3.1. Xaccess<a class=anchor href=#_xaccess></a></h5><div class=paragraph><p>El protocolo para conectar con las pantallas controladas por XDM se llama «X Display Manager Connection Protocol» (XDMCP). Este fichero es un conjunto de reglas para controlar las conexiones XDMCP desde otros equipos. Por defecto permite a cualquier cliente conectar, pero eso no importa a menos que <span class=filename>xdm-config</span> se cambie para escuchar conexiones remotas. La configuración básica no permite conexiones desde ningún cliente.</p></div></div><div class=sect4><h5 id=_xresources>5.6.3.2. Xresources<a class=anchor href=#_xresources></a></h5><div class=paragraph><p>Este es el fichero de opciones por defecto para el selector de pantalla y acceso al sistema. Aquí es donde se puede modificar la apariencia del programa de «login». El formato es idéntico al fichero de opciones por defecto descrito en la documentación de X11.</p></div></div><div class=sect4><h5 id=_xservers>5.6.3.3. Xservers<a class=anchor href=#_xservers></a></h5><div class=paragraph><p>Una lista de pantallas remotas entre las que elegir.</p></div></div><div class=sect4><h5 id=_xsession>5.6.3.4. Xsession<a class=anchor href=#_xsession></a></h5><div class=paragraph><p>Este es el «script» de sesión que por defecto XDM arrancará después de que el usuario acceda al sistema. Normalmente cada usuario tendrá una versión personalizada del «script» de sesión en <span class=filename>~/.xsession</span> que sobreescribe el «script» por defecto.</p></div></div><div class=sect4><h5 id=_xsetup>5.6.3.5. Xsetup_*<a class=anchor href=#_xsetup></a></h5><div class=paragraph><p>Estos se arrancarán automáticamente antes de que se muestre el interfaz de selección o de acceso al sistema. Hay un «script» por cada gestor de ventanas disponible llamados <span class=filename>Xsetup_</span> seguido por el número de pantalla local (por ejemplo <span class=filename>Xsetup_0</span>). Normalmente estos «scripts» arrancan uno o dos programas en segundo plano, por ejemplo <code>xconsole</code>.</p></div></div><div class=sect4><h5 id=_xdm_config>5.6.3.6. xdm-config<a class=anchor href=#_xdm_config></a></h5><div class=paragraph><p>Este fichero contiene las opciones por defecto aplicables a todas las pantallas que gestiona la instalación.</p></div></div><div class=sect4><h5 id=_xdm_errors>5.6.3.7. xdm-errors<a class=anchor href=#_xdm_errors></a></h5><div class=paragraph><p>Este fichero contiene la salida de los servidores X que XDM intente arrancar. Si alguna pantalla que XDM intente arrancar se cuelga por alguna razón este es un buen sitio para buscar los mensajes de error. Estos mensajes también se escriben en el fichero <span class=filename>~/.xsession-errors</span> del usuario en cada sesión.</p></div></div></div><div class=sect3><h4 id=_ejecutar_un_servidor_de_pantalla_a_través_de_la_red>5.6.4. Ejecutar un servidor de pantalla a través de la red<a class=anchor href=#_ejecutar_un_servidor_de_pantalla_a_través_de_la_red></a></h4><div class=paragraph><p>Para que otros clientes puedan conectar al servidor de pantalla edite las reglas de acceso y habilite la escucha en la conexión. Por omisión se aplican restricciones. Si quiere que XDM escuche conexiones comente la siguiente línea en el fichero <span class=filename>xdm-config</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=o>!</span> SECURITY: <span class=k>do </span>not listen <span class=k>for </span>XDMCP or Chooser requests
<span class=o>!</span> Comment out this line <span class=k>if </span>you want to manage X terminals with xdm
DisplayManager.requestPort:     0</code></pre></div></div><div class=paragraph><p>y después reinicie XDM. Recuerde que los comentarios en los ficheros de opciones por defecto comienzan con el carácter«!» en vez del típico «\#». Puede aplicar controles más restrictivos. Consulte las opciones de ejemplo en <span class=filename>Xaccess</span> y la página de manual de <a href="https://man.freebsd.org/cgi/man.cgi?query=xdm&amp;sektion=1&amp;format=html">xdm(1)</a>.</p></div></div><div class=sect3><h4 id=_alternativas_a_xdm>5.6.5. Alternativas a XDM<a class=anchor href=#_alternativas_a_xdm></a></h4><div class=paragraph><p>Hay algunas alternativas al programa por defecto XDM. Una de ellas, kdm (que se incluye con KDE) se describe más adelante en este capítulo. kdm ofrece muchas ventajas visuales y funcionalidad para permitir a los usuarios elegir su gestor de ventanas en el momento del acceso al sistema.</p></div></div></div><div class=sect2><h3 id=x11-wm>5.7. Entornos de escritorio<a class=anchor href=#x11-wm></a></h3><div class=paragraph><p>Está sección describe los diferentes entornos de escritorio disponibles para X en FreeBSD. Un «entorno de escritorio» puede ser cualquier cosa que vaya desde un simple gestor de ventanas hasta una completa «suite» de aplicaciones de escritorio como KDE o GNOME.</p></div><div class=sect3><h4 id=x11-wm-gnome>5.7.1. GNOME<a class=anchor href=#x11-wm-gnome></a></h4><div class=sect4><h5 id=x11-wm-gnome-about>5.7.1.1. Acerca de GNOME<a class=anchor href=#x11-wm-gnome-about></a></h5><div class=paragraph><p>GNOME es un entorno de escritorio amigable que permite a los usuarios una configuración fácil de sus sistemas. GNOME incluye un panel (para iniciar las aplicaciones y mostrar su estado), un escritorio (donde pueden colocarse los datos y las aplicaciones), un conjunto de herramientas y aplicaciones de escritorio estándar y un conjunto de convenciones para facilitar la creación de aplicaciones que sean consistentes y colaboren unas con otras. Los usuarios de otros sistemas operativos o entornos pueden sentirse como en casa utilizando el poderoso entorno gráfico GNOME. Encontrará más información sobre GNOME en FreeBSD en la página <a href=http://www.FreeBSD.org/gnome>del Proyecto FreeBSD GNOME</a>.</p></div></div><div class=sect4><h5 id=x11-wm-gnome-install>5.7.1.2. Instación de GNOME<a class=anchor href=#x11-wm-gnome-install></a></h5><div class=paragraph><p>GNOME puede instalarse fácilmente utilizando packages precompilados o desde la Colección de Ports:</p></div><div class=paragraph><p>Para instalar el paquete de GNOME desde la red, simplemente teclee:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg_add -r gnome2</span></code></pre></div></div><div class=paragraph><p>Para compilar GNOME a partir del código fuente, es decir, como port:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/x11/gnome2</span>
<span class=c># make install clean</span></code></pre></div></div><div class=paragraph><p>Una vez GNOME esté instalado debe indicarle al servidor X como iniciar GNOME para convertirlo en el gestor de ventanas predeterminado.</p></div><div class=paragraph><p>La manera más fácil de arrancar GNOME es con GDM, el gestor de pantalla de GNOME. GDM, que se instala con el escritorio GNOME al ser parte del mismo (aunque venga desactivado por omisión) se activa añadiendo <code>gdm_enable="YES"</code> a <span class=filename>/etc/rc.conf</span>. Tras reiniciar, GNOME arrancará automáticamente al acceder al sistema; no es necesario configurar nada más.</p></div><div class=paragraph><p>Puede arrancar GNOME también desde la línea de órdenes configurando adecuadamente un fichero llamado <span class=filename>.xinitrc</span>. Si ya tiene un <span class=filename>.xinitrc</span> personalizado tendrá que reemplazar la línea que arranca el gestor de ventanas anterior por otra que contenga /usr/local/bin/gnome-session. Si no ha modificado el fichero previamente basta con que teclée lo siguiente:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>echo</span> <span class=s2>&#34;/usr/local/bin/gnome-session&#34;</span> <span class=o>&gt;</span> ~/.xinitrc</code></pre></div></div><div class=paragraph><p>Después teclée <code>startx</code> y debería iniciarse el entorno de escritorio GNOME.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Si utiliza un gestor de pantalla antíguo, como XDM, lo anteriormente descrito no funcionará. Cree un fichero ejecutable <span class=filename>.xsession</span> con la misma orden en él. Edite el fichero y sustituya la orden para iniciar su actual gestor de ventanas por /usr/local/bin/gnome-session:</p></div></td></tr></tbody></table></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>echo</span> <span class=s2>&#34;#!/bin/sh&#34;</span> <span class=o>&gt;</span> ~/.xsession
% <span class=nb>echo</span> <span class=s2>&#34;/usr/local/bin/gnome-session&#34;</span> <span class=o>&gt;&gt;</span> ~/.xsession
% <span class=nb>chmod</span> +x ~/.xsession</code></pre></div></div><div class=paragraph><p>Otra opción es configurar el gestor de pantalla para que permita seleccionar el gestor de ventanas durante el acceso; la sección de <a href=#x11-wm-kde-details>detalles de KDE</a> explica cómo hacerlo para kdm, el gestor de pantalla de KDE.</p></div></div><div class=sect4><h5 id=x11-wm-gnome-antialias>5.7.1.3. Tipos «Anti-aliased» en GNOME<a class=anchor href=#x11-wm-gnome-antialias></a></h5><div class=paragraph><p>X11 soporta «anti-aliasing» a través de la extensión «RENDER». Gtk+ 2.0 y superiores (el «toolkit» utilizado por GNOME) disponen de esta funcionalidad. La configuración del «anti-aliasing» se describe en la <a href=#antialias>Tipos Anti-Aliasing</a>. Una vez configurado el software es posible utilizar «anti-aliasing» en el entorno de escritorio GNOME. Sólamente tiene que ir a <span class=menuseq><b class=menu>Applications</b> <i class="fa fa-angle-right caret"></i> <b class=submenu>Desktop Preferences</b> <i class="fa fa-angle-right caret"></i> <b class=menuitem>Font</b></span>, y seleccione entre <b class=button>Best shapes</b>, <b class=button>Best contrast</b>, o <b class=button>Subpixel smoothing (LCDs)</b>. En el caso de una aplicación Gtk+ que no forme parte del escritorio GNOME asigne a la variable de entorno <code>GDK_USE_XFT</code> un valor de <code>1</code> antes de arrancar el programa.</p></div></div></div><div class=sect3><h4 id=x11-wm-kde>5.7.2. KDE<a class=anchor href=#x11-wm-kde></a></h4><div class=sect4><h5 id=x11-wm-kde-about>5.7.2.1. Acerca de KDE<a class=anchor href=#x11-wm-kde-about></a></h5><div class=paragraph><p>KDE es un entorno de escritorio contemporáneo y fácil de usar. Veamos alguna de las cosas que KDE brinda al usuario:</p></div><div class=ulist><ul><li><p>Un bello escritorio contemporáneo.</p></li><li><p>Un escritorio completamente transparente en red.</p></li><li><p>Un sistema de ayuda integrado que facilita un acceso adecuado y consistente a la ayuda durante el uso del escritorio KDE y sus aplicaciones.</p></li><li><p>Un aspecto consistente de todas las aplicaciones KDE.</p></li><li><p>Menús y barras de herramientas estándares, teclas programables, esquemas de color, etc.</p></li><li><p>Internacionalización: KDE está disponible en más de 40 idiomas.</p></li><li><p>Un diálogo de configuración del escritorio centralizado y consistente.</p></li><li><p>Un gran número de útiles aplicaciones KDE.</p></li></ul></div><div class=paragraph><p>KDE incluye un navegador web llamado Konqueror, que es un sólido competidor del resto de navegadores web existentes en sistemas UNIX®. Puede encontrar más información sobre KDE en el <a href=http://www.kde.org/>sitio web de KDE</a>. Si quiere información específica y recursos sobre KDE en FreeBSD consulte el sitio web del <a href=http://freebsd.kde.org/>equipo de KDE en FreeBSD</a>.</p></div><div class=paragraph><p>Hay dos versiones de KDE en FreeBSD: la versión 3 lleva ya bastante tiempo en el sistema y es muy estable en todos los sentidos. La versión 4, la nueva generación de KDE, también está en los ports. Si quiere puede instalar ambas versiones simultáneamente.</p></div></div><div class=sect4><h5 id=x11-wm-kde-install>5.7.2.2. Instalación de KDE<a class=anchor href=#x11-wm-kde-install></a></h5><div class=paragraph><p>Igual que sucede con GNOME o cualquier otro entorno de escritorio puede instalarlo como package o desde la Colección de Ports:</p></div><div class=paragraph><p>Si quiere instalar como package KDE3 (desde la red) escriba:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg_add -r kde</span></code></pre></div></div><div class=paragraph><p>Si quiere instalar como package KDE4 (desde la red) escriba:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg_add -r kde4</span></code></pre></div></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=pkg_add&amp;sektion=1&amp;format=html">pkg_add(1)</a> descargará automáticamente la versión más reciente de la aplicación.</p></div><div class=paragraph><p>Si lo que desea es compilar KDE3 desde el código fuente utilice el árbol de ports:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/x11/kde3</span>
<span class=c># make install clean</span></code></pre></div></div><div class=paragraph><p>Si lo que desea es compilar KDE4 desde el código fuente utilice el árbol de ports:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/x11/kde4</span>
<span class=c># make install clean</span></code></pre></div></div><div class=paragraph><p>Una vez instalado KDE debe indicarle al servidor X cómo iniciar la aplicación para que se convierta en el gestor de ventanas por defecto. Edite <span class=filename>.xinitrc</span>:</p></div><div class=paragraph><p>Para KDE3:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>echo</span> <span class=s2>&#34;exec startkde&#34;</span> <span class=o>&gt;</span> ~/.xinitrc</code></pre></div></div><div class=paragraph><p>Para KDE4:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>echo</span> <span class=s2>&#34;exec /usr/local/kde4/bin/startkde&#34;</span> <span class=o>&gt;</span> ~/.xinitrc</code></pre></div></div><div class=paragraph><p>A partir de ahora cuando se llame al sistema X Window con <code>startx</code> el escritorio será KDE.</p></div><div class=paragraph><p>Si utiliza un gestor de pantalla, como por ejemplo xdm, la configuración es ligeramente diferente. En vez de lo antedicho edite <span class=filename>.xsession</span>. Las instrucciones para kdm se decribirán más adelante en este capítulo.</p></div></div></div><div class=sect3><h4 id=x11-wm-kde-details>5.7.3. Más detalles sobre KDE<a class=anchor href=#x11-wm-kde-details></a></h4><div class=paragraph><p>Una vez KDE está instalado en el sistema la mayoría de las cosas se pueden ir descubriendo utilizando las páginas de ayuda o sencillamente a golpe de ratón en los diversos menús. Los usuarios de Windows® y Mac® se sentiráan como en casa.</p></div><div class=paragraph><p>La mejor referencia para KDE es la documentación «on-line». KDE incluye su propio navegador, Konqueror, docenas de útiles aplicaciones y una extensa documentación. El resto de esta sección trata sobre cuestiones técnicas que son difíciles de aprender mediante una exploración al azar.</p></div><div class=sect4><h5 id=x11-wm-kde-kdm>5.7.3.1. El gestor de pantalla de KDE<a class=anchor href=#x11-wm-kde-kdm></a></h5><div class=paragraph><p>El administrador de un sistemas multiusuario puede querer ofrecer a sus usuarios una pantalla de bienvenido que se les presente al acceder al sistema. Tal y como se ha explicado previamente puede usar <a href=#x-xdm>XDM</a>. De todos modos KDE incluye su propia alternativa, alternative, kdm, diseñado pensando en ser más atractivo y tener más opciones que ofrecer en el momento del acceso al sistema. Más concretamente ofrece a los usuarios la posibilidad de elegir mediante un menú qué entorno de escritorio (KDE, GNOME, o cualquier otro) quiere ejecutar el usuario una vez validado.</p></div><div class=paragraph><p>Si quiere activar kdm debe modificar la entrada de <code>ttyv8</code> en <span class=filename>/etc/ttys</span>. La línea debe quedar del siguiente modo:</p></div><div class=paragraph><p>Si va a usar KDE3:</p></div><div class="literalblock programlisting"><div class=content><pre>ttyv8 &#34;/usr/local/bin/kdm -nodaemon&#34; xterm on secure</pre></div></div><div class=paragraph><p>En el caso de KDE4:</p></div><div class="literalblock programlisting"><div class=content><pre>ttyv8 &#34;/usr/local/kde4/bin/kdm -nodaemon&#34; xterm on secure</pre></div></div></div></div><div class=sect3><h4 id=x11-wm-xfce>5.7.4. XFce<a class=anchor href=#x11-wm-xfce></a></h4><div class=sect4><h5 id=x11-wm-xfce-about>5.7.4.1. Acerca de XFce<a class=anchor href=#x11-wm-xfce-about></a></h5><div class=paragraph><p>XFce es un entorno de escritorio basado en el «toolkit» GTK utilizado por GNOME pero es mucho más ligero y está pensado para aquellos que quieran un escritorio sencillo, eficiente y fácil de utlizar y configurar. Visualmente es muy parecido a CDE, que podemos encontrar en sistemas UNIX® comerciales. Alguna de las caracterésticas de XFce son:</p></div><div class=ulist><ul><li><p>Un escritorio sencillo y fácil de utilizar.</p></li><li><p>Completamente configurable utilizando el ratón, con arrastrar y soltar, etc.</p></li><li><p>Panel principal similar al de CDE, con menús, «applets» y accesos directos a las aplicaciones.</p></li><li><p>Gestor de ventanas integrado, gestor de ficheros, gestor de sonido, módulo de compatibilidad con GNOME, y muchas cosas más.</p></li><li><p>Aspecto configurable (utiliza GTK).</p></li><li><p>Rápido, ligero y eficiente: ideal para máquinas viejas, lentas o máquinas con memoria limitada.</p></li></ul></div><div class=paragraph><p>Puede encontrar más información sobre XFce en el <a href=http://www.xfce.org/>sitio web de XFce</a>.</p></div></div><div class=sect4><h5 id=x11-wm-xfce-install>5.7.4.2. Instalar XFce<a class=anchor href=#x11-wm-xfce-install></a></h5><div class=paragraph><p>En el momento de escribir este texto existe un paquete binario para XFce. Para instalarlo escriba:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg_add -r xfce4</span></code></pre></div></div><div class=paragraph><p>También puede compilarlo desde el código gracias a la Colección de Ports:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/x11-wm/xfce4</span>
<span class=c># make install clean</span></code></pre></div></div><div class=paragraph><p>Para indicar al servidor X que use XFce la próxima vez que arranque simplemente escriba lo siguiente:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>echo</span> <span class=s2>&#34;/usr/X11R6/bin/startxfce4&#34;</span> <span class=o>&gt;</span> ~/.xinitrc</code></pre></div></div><div class=paragraph><p>La próxima vez que arranque X XFce será el escritorio. Como antes, si se usa un gestor de pantalla como <span class=filename>xdm</span> cree un <span class=filename>.xsession</span> tal y como se ha descrito en la anterior sección en <a href=#x11-wm-gnome>GNOME</a>, pero con la orden <span class=filename>/usr/local/bin/startxfce4</span>; puede configurar el gestor de pantalla para permitir elegir el escritorio en el momento de acceder al sistema tal y como se ha explicado en la sección de <a href=#x11-wm-kde-kdm>kdm</a>.</p></div></div></div></div></div></div><h1 id=common-tasks class=sect0>Parte II: Tareas comunes<a class=anchor href=#common-tasks></a></h1><div class="openblock partintro"><div class=content><div class=paragraph><p>Una vez tratados los aspectos más básicos, pasaremos a detallar alguna de las características más utilizadas de FreeBSD:</p></div><div class=ulist><ul><li><p>Introducción a algunas de las aplicaciones de escritorio más útiles y extendidas: navegadores, herramientas de productividad, visores de documentos, etc.</p></li><li><p>Introducción a algunas de las herramientas multimedia de FreeBSD.</p></li><li><p>Explicación de cómo crear un kernel personalizado en FreeBSD, lo que le permitirá añadir nuevas funcionalidades al sistema.</p></li><li><p>Descripción en detalle del sistema de impresión, tanto en entornos de escritorio como en impresoras conectadas en red.</p></li><li><p>Cómo ejecutar aplicaciones de Linux® en FreeBSD.</p></li></ul></div><div class=paragraph><p>Algunos de los capítulos recomiendan lecturas de capítulos anteriores, lo que se indica al inicio de cada capítulo.</p></div></div></div><div class=sect1><h2 id=desktop>Capítulo 6. Aplicaciones de escritorio<a class=anchor href=#desktop></a></h2><div class=sectionbody><div class=sect2><h3 id=desktop-synopsis>6.1. Sinopsis<a class=anchor href=#desktop-synopsis></a></h3><div class=paragraph><p>FreeBSD puede ejecutar gran número de aplicaciones de escritorio, como navegadores y procesadores de texto. La mayoría de ellas están disponibles como packages o se pueden compilar automáticamente desde la colección de ports. Muchos usuarios nuevos esperan encontrar este tipo de aplicaciones en su escritorio. Este capítulo mostrará cómo instalar de forma fácil algunas aplicaciones populares, bien como packages o desde la colección de ports.</p></div><div class=paragraph><p>Tenga en cuenta que cuando se instalan programas desde los ports se compilan desde el código fuente. Esto puede tardar muchísimo tiempo, dependiendo de qué esté compilando y la potencia de proceso de su máquina. Si compilar una o más aplicaciones le requiere una cantidad de tiempo desmesurada para sus necesidades recuerde que puede instalar la mayoría de programas de la Colección de Ports como packages precompilados.</p></div><div class=paragraph><p>FreeBSD tiene compatibilidad binaria con Linux®, así que muchas aplicaciones originariamente desarrolladas para Linux existen también para su escritorio. Le recomendamos encarecidamente que lea el <a href=./#linuxemu>Compatibilidad binaria con Linux</a> antes instalar aplicaciones Linux. Muchos de los ports que usan la compatibilidad binaria de Linux empiezan por «linux-». Recuérdelo cuando busque un port en particular, por ejemplo con <a href="https://man.freebsd.org/cgi/man.cgi?query=whereis&amp;sektion=1&amp;format=html">whereis(1)</a>. En el siguiente texto se asume que ha habilitado usted la compatibilidad binaria de Linux antes de instalar aplicaciones de Linux.</p></div><div class=paragraph><p>Estas son las categorías que cubre este capítulo:</p></div><div class=ulist><ul><li><p>Navegadores (como Mozilla, <a href="https://man.freebsd.org/cgi/man.cgi?query=getenv&amp;sektion=3&amp;format=html">getenv(3)</a>, Opera, Firefox, Konqueror)</p></li><li><p>Productividad (como KOffice, AbiWord, The GIMP, OpenOffice.org)</p></li><li><p>Visores de documentos (como Acrobat Reader®, gv, Xpdf, GQview)</p></li><li><p>Finanzas (como GnuCash, Gnumeric, Abacus)</p></li></ul></div><div class=paragraph><p>Antes de leer este capítulo, usted debería:</p></div><div class=ulist><ul><li><p>Saber como instalar software de terceros (<a href=./#ports>Instalación de aplicaciones: «packages» y ports</a>).</p></li><li><p>Saber como instalar software de Linux (<a href=./#linuxemu>Compatibilidad binaria con Linux</a>).</p></li></ul></div><div class=paragraph><p>Si quiere más información sobre cómo conseguir un entorno un entorno multimedia en FreeBSD consulte el <a href=./#multimedia>Multimedia</a>. Si quiere configurar y usar el correo electrónico consulte el crossref:[mail,Correo Electrónico].</p></div></div><div class=sect2><h3 id=desktop-browsers>6.2. Navegadores<a class=anchor href=#desktop-browsers></a></h3><div class=paragraph><p>FreeBSD no trae ningún navegador preinstalado, pero en el directorio <a href=http://www.FreeBSD.org/ports/>www</a> de la colección de ports tiene muchos navegadores listos para instalar. Si no tiene tiempo para compilarlo todo (esto puede requerir muchísimo tiempo en algunos casos) muchos de ellos están disponibles como packages.</p></div><div class=paragraph><p>KDE y GNOME ya proporcionan navegadores HTML. Consulte la <a href=./#x11-wm>Entornos de escritorio</a> para más información sobre cómo configurar estos escritorios.</p></div><div class=paragraph><p>Si busca navegadores ligeros tiene en la colección de ports <a class=package href=https://cgit.freebsd.org/ports/tree/www/dillo/>www/dillo</a>, <a class=package href=https://cgit.freebsd.org/ports/tree/www/links/>www/links</a>, o <a class=package href=https://cgit.freebsd.org/ports/tree/www/w3m/>www/w3m</a>.</p></div><div class=paragraph><p>Esta sección cubre estas aplicaciones:</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:25%><col style=width:25%><col style=width:25%><col style=width:25%><thead><tr><th class="tableblock halign-left valign-top">Nombre de aplicación</th><th class="tableblock halign-left valign-top">Recursos necesarios</th><th class="tableblock halign-left valign-top">Instalación desde los Ports</th><th class="tableblock halign-left valign-top">Dependencias importantes</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Mozilla</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>pesado</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>pesado</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Gtk+</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Opera</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>ligero</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>ligero</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Versiones para FreeBSD y Linux disponibles. La versión de Linux depende de la compatibiliad binaria de Linux y de linux-openmotif.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Firefox</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>medio</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>pesado</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Gtk+</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Konqueror</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>medio</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>pesado</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>KDE Librerís</p></td></tr></tbody></table><div class=sect3><h4 id=_mozilla>6.2.1. Mozilla<a class=anchor href=#_mozilla></a></h4><div class=paragraph><p>Mozilla es una navegador moderno y estable que dispone de soporte completo en FreeBSD: dispone de un motor de presentación de HTML muy ajustado a los estándares, tiene cliente de correo electrónico, lector de noticias e incluso ofrece un editor de páginas HTML por si quiere crear páginas web. Los usuarios de <a href="https://man.freebsd.org/cgi/man.cgi?query=getenv&amp;sektion=3&amp;format=html">getenv(3)</a> encontrarán semejanzas con la suite Communicator, dado que ambos navegadores comparten parte de la base de desarrollo.</p></div><div class=paragraph><p>En máquinas lentas, con una CPU de velocidad inferior a 233MHz o con menos de 64MB de RAM, Mozilla puede consumir demasiados recursos para poder utilizarse. Puede usar el navegador Opera, mucho más ligero, que se describe más adelante en este mismo capítulo.</p></div><div class=paragraph><p>Si no puede o no quiere compilar Mozilla por algún motivo, el equipo de FreeBSD GNOME ya lo ha hecho por usted. Instale el package desde la red del siguiente modo:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg_add -r mozilla</span></code></pre></div></div><div class=paragraph><p>Si no hay package disponible y tiene suficiente tiempo y espacio en el disco puede obtener el código de Mozilla, compilarlo e instalarlo en su sistema. Esto se hace con:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/www/mozilla</span>
<span class=c># make install clean</span></code></pre></div></div><div class=paragraph><p>El port de Mozilla se asegura de que se inicialice adecuadamente ejecutando la configuración del registro «chrome» con privilegios de <code>root</code>, aunque si quiere instalar algún añadido como «mouse gestures» (gestos del ratón) tendrá que ejecutar que correr Mozilla como <code>root</code> para que se instale correctamente.</p></div><div class=paragraph><p>Una vez efectuada la instalación de Mozilla no es necesario ser <code>root</code> por más tiempo. Puede arrancar Mozilla como navegador escribiendo:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% mozilla</code></pre></div></div><div class=paragraph><p>Puede arrancarlo directamente como lector de correo y noticias del siguiente modo:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% mozilla <span class=nt>-mail</span></code></pre></div></div></div><div class=sect3><h4 id=_firefox>6.2.2. Firefox<a class=anchor href=#_firefox></a></h4><div class=paragraph><p>Firefox es un navegador de nueva generación basado en el código fuente de Mozilla. Mozilla es una suite completa de aplicaciones en la que encontrará un navegador, un cliente de correo, un cliente de chat y muchas otras. Firefox es solamente un navegador, lo que hace que sea mucho más pequeño y ligero.</p></div><div class=paragraph><p>Puede instalarlo como package del siguiente modo:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg_add -r firefox</span></code></pre></div></div><div class=paragraph><p>Si prefiere compilar el código fuente e instalarlo desde los ports puede hacer esto otro:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/www/firefox</span>
<span class=c># make install clean</span></code></pre></div></div></div><div class=sect3><h4 id=moz-java-plugin>6.2.3. Firefox, Mozilla y el «plugin» Java™<a class=anchor href=#moz-java-plugin></a></h4><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>En esta sección y en la siguiente asumiremos que ya ha instalado Firefox o Mozilla.</p></div></td></tr></tbody></table></div><div class=paragraph><p>La FreeBSD Foundation disponde una licencia de Sun Microsystems que le permite distribuir binarios FreeBSD del Java Runtime Environment (JRE™) y del Java Development Kit (JDK™). Puede descargar packages binarios para FreeBSD desde el <a href=http://www.freebsdfoundation.org/downloads/java.shtml>sitio web</a> de la FreeBSD Foundation.</p></div><div class=paragraph><p>Para añadir soporte Java™ a Firefox o Mozilla tiene que instalar el port the <a class=package href=https://cgit.freebsd.org/ports/tree/java/javavmwrapper/>java/javavmwrapper</a>. Después descargue el package Diablo JRE™ desde <a href=http://www.freebsdfoundation.org/downloads/java.shtml>http://www.freebsdfoundation.org/downloads/java.shtml</a> e instálelo con <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg_add&amp;sektion=1&amp;format=html">pkg_add(1)</a>.</p></div><div class=paragraph><p>Arranque su navegador, introduzca <code>about:plugins</code> en la barra de navegación y pulse <kbd>Intro</kbd>. Verá una página con una lista de los «plugins» que tenga instalados; el «plugin» Java™ debería ser uno de los que aparezcan. Si no es así ejecute (como <code>root</code>) lo siguiente</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ln -s /usr/local/diablo-jre1.6.0/plugin/i386/ns7/libjavaplugin_oji.so \</span>
  /usr/local/lib/browser_plugins/</code></pre></div></div><div class=paragraph><p>y reinicie su navegador.</p></div></div><div class=sect3><h4 id=_opera>6.2.4. Opera<a class=anchor href=#_opera></a></h4><div class=paragraph><p>Opera es un navegador muy rápido, completo y que cumple con los estándares. Hay dos versiones: la versión «nativa» de FreeBSD y la versión que se ejecuta bajo la emulación de Linux. Para cada sistema operativo hay una versión gratuita que muestra publicidad y otra sin publicidad que se puede comprar en <a href=http://www.opera.com/>la página web de Opera</a>.</p></div><div class=paragraph><p>Para navegar por la web con la versión para FreeBSD de Opera tendrá que instalar el package:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg_add -r opera</span></code></pre></div></div><div class=paragraph><p>Algunos sitios FTP no tienen todos los paquetes, pero puede instalarlo desde la Colección de Ports:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/www/opera</span>
<span class=c># make install clean</span></code></pre></div></div><div class=paragraph><p>Si quiere instalar la versión de Linux de Opera ponga <code>linux-opera</code> en lugar de <code>opera</code> en los atnteriores ejemplos. La versión de Linux es útil en situaciones donde se necesitan «plugins» de los que sólo hay versiones para Linux, como Adobe Acrobat Reader®. En todos los demás aspectos las versiones de FreeBSD y Linux son iguales.</p></div></div><div class=sect3><h4 id=_konqueror>6.2.5. Konqueror<a class=anchor href=#_konqueror></a></h4><div class=paragraph><p>Konqueror forma parte de KDE pero también se puede instalar y usar independienmente de KDE instalando <a class=package href=https://cgit.freebsd.org/ports/tree/x11/kdebase3/>x11/kdebase3</a>. Konqueror es mucho más que un navegador, también es gestor de ficheros y visor multimedia.</p></div><div class=paragraph><p>Konqueror también trae un conjunto de «plugins», disponibles en <a class=package href=https://cgit.freebsd.org/ports/tree/misc/konq-plugins/>misc/konq-plugins</a>.</p></div><div class=paragraph><p>Konqueror también soporta Flash™, hay un tutorial en <a href=http://freebsd.kde.org/howto.php>http://freebsd.kde.org/howto.php</a>.</p></div></div></div><div class=sect2><h3 id=desktop-productivity>6.3. Productividad<a class=anchor href=#desktop-productivity></a></h3><div class=paragraph><p>Cuando se trata de productividad, normalmente los nuevos usuarios piensan en una buena suite ofimática o un procesador de textos amigable. Mientras que algunos <a href=./#x11-wm>entornos de escritorio</a> como KDE ofrecen una suite ofimática propia, no hay una aplicación por defecto. FreeBSD permite usar todo lo que se necesite sin importar qué entorno de escritorio use.</p></div><div class=paragraph><p>Esta sección cubre estas aplicaciones:</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:25%><col style=width:25%><col style=width:25%><col style=width:25%><thead><tr><th class="tableblock halign-left valign-top">Nombre de la aplicación</th><th class="tableblock halign-left valign-top">Recursos necesarios</th><th class="tableblock halign-left valign-top">Instalación desde los ports</th><th class="tableblock halign-left valign-top">Dependencias importantes</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>KOffice</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>ligero</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>pesado</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>KDE</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>AbiWord</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>ligero</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>ligero</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Gtk+ o GNOME</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>The Gimp</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>ligero</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>pesado</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Gtk+</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>OpenOffice.org</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>pesado</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>enorme</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>GCC 3.1, JDK™ 1.3, Mozilla</p></td></tr></tbody></table><div class=sect3><h4 id=_koffice>6.3.1. KOffice<a class=anchor href=#_koffice></a></h4><div class=paragraph><p>La comunidad de KDE ha dotado su entorno de escritorio con una suite ofimática totalmente independiente de KDE. Incluye los 4 componentes estándar que se pueden encontrar en otras suites ofimáticas. KWord es el procesador de textos, KSpread es la hoja de cálculo, KPresenter se encarga de las presentaciones y Kontour le permite dibujar documentos gráficos.</p></div><div class=paragraph><p>Antes de instalar el último KOffice asegúrese de que tiene una versión actualizada de KDE.</p></div><div class=paragraph><p>Para instalar KOffice como un paquete ejecute la siguiente orden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg_add -r koffice</span></code></pre></div></div><div class=paragraph><p>Si el paquete no está disponible puede usar la colección de ports. Por ejemplo, para instalar KOffice para KDE3 haga lo siguiente:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/editors/koffice-kde3</span>
<span class=c># make install clean</span></code></pre></div></div></div><div class=sect3><h4 id=_abiword>6.3.2. AbiWord<a class=anchor href=#_abiword></a></h4><div class=paragraph><p>AbiWord es un procesador de textos libre con un aspecto parecido a Microsoft® Word. Es útil para escribir documentos, cartas, informes, notas, etc. Es muy rápido, tiene muchas opciones y es muy amigable.</p></div><div class=paragraph><p>AbiWord puede importar o exportar muchos formatos de fichero, incluyendo algunos propietarios como Microsoft <span class=filename>.doc</span>.</p></div><div class=paragraph><p>AbiWord está disponible como package. Si quiere instalarlo haga lo siguiente:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg_add -r AbiWord2</span></code></pre></div></div><div class=paragraph><p>Si el package no está disponible por el motivo que fuere puede instalarlo desde la colección de Ports. La colección de ports debería estar más actualizada:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/editors/AbiWord2</span>
<span class=c># make install clean</span></code></pre></div></div></div><div class=sect3><h4 id=_the_gimp>6.3.3. The GIMP<a class=anchor href=#_the_gimp></a></h4><div class=paragraph><p>GIMP es un programa de manipulación de imágenes muy sofisticado que le permitirá también crearlas y retocarlas. Puede usarlo como un programa de dibujo sencillo o como una sofisticada herramienta de retoque fotográfico. Admite una gran cantidad de «plug-ins» y tiene opciones tan interesantes como una interfaz para «scripts». GIMP puede leer y escribir un gran número de formatos de fichero. Soporta escáners y tabletas gráficas.</p></div><div class=paragraph><p>Instale el package mediante la siguiente orden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg_add -r gimp</span></code></pre></div></div><div class=paragraph><p>Si su servidor FTP no tiene este package puede usar la colección de ports. El directorio <a href=http://www.FreeBSD.org/ports/>graphics</a> de la colección de ports también contiene The Gimp Manual. Si quiere instalarlo haga lo siguiente:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/graphics/gimp</span>
<span class=c># make install clean</span>
<span class=c># cd /usr/ports/graphics/gimp-manual-pdf</span>
<span class=c># make install clean</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>El directorio <a href=http://www.FreeBSD.org/ports/>graphics</a> de la colección de ports tiene la versión de desarrollo de GIMP en <a class=package href=https://cgit.freebsd.org/ports/tree/graphics/gimp-devel/>graphics/gimp-devel</a>. Hay una versión en HTML de The Gimp Manual en <a class=package href=https://cgit.freebsd.org/ports/tree/graphics/gimp-manual-html/>graphics/gimp-manual-html</a>.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=_openoffice_org>6.3.4. OpenOffice.org<a class=anchor href=#_openoffice_org></a></h4><div class=paragraph><p>OpenOffice.org incluye todas las aplicaciónes esenciales en una completa suite ofimática: un procesador de textos, una hoja de cálculo, un gestor de presentaciones y un programa de dibujo. Su interfaz de usuario es muy parecida a otras suites ofimáticas y puede importar y exportar diversos formatos muy extendidos. Está disponible en diversos idiomas; el proceso de internacionalización incluye interfaces, correctores ortográficos y diccionarios.</p></div><div class=paragraph><p>El procesador de textos de OpenOffice.org usa un fichero XML nativo para aumentar la portabilidad y la eficiencia. El programa de hojas de cálculo tiene un lenguaje de macros y puede usarse desde bases de datos externas. OpenOffice.org es estable y hay versiones nativas para Windows®, Solaris™, Linux, FreeBSD, y Mac OS® X. Tiene más información sobre OpenOffice.org en <a href=http://www.openoffice.org/>la página web de OpenOffice</a>. Si quiere información específica para FreeBSD, o si quiere bajar directamente los packages use la página web de <a href=http://porting.openoffice.org/freebsd/>FreeBSD OpenOffice Porting Team</a>.</p></div><div class=paragraph><p>Para instalar OpenOffice.org ejecute:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg_add -r openoffice</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Si usa una versión -RELEASE de FreeBSD todo lo antedicho funcionará. Si usa cualquier otra versión visite el sitio web del FreeBSD OpenOffice.org Porting Team, desde el cual podrá descargar e instalar el package más adecuado e instalarlo mediante <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg_add&amp;sektion=1&amp;format=html">pkg_add(1)</a>. En este sitio web encontrará tanto una versión current como la de desarrollo.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Una vez instalado el package escriba la siguiente orden para ejecutar OpenOffice.org:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% openoffice.org</code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>En el primer arranque se le harán diversas preguntas se creará un directorio <span class=filename>.openoffice.org2</span> en su «home».</p></div></td></tr></tbody></table></div><div class=paragraph><p>Si no hay packages de OpenOffice.org disponibles siempre tiene la opción de compilar el port. Tenga muy en cuenta que necesitará gran cantidad de espacio en disco y que este port necesita una cantidad de tiempo monstruosa para efectuar la compilación.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/editors/openoffice.org-2</span>
<span class=c># make install clean</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Si quiere compilar una de las muchas versiones que existen en idiomas distintos del inglés sustituya la orden anterior por la que se muestra a continuación:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># make LOCALIZED_LANG=su_idioma install clean</span></code></pre></div></div><div class=paragraph><p>Sustituya <em>su_idioma</em> por el código ISO del idioma que quiera. Tiene una lista de códigos de idioma disponibles dentro del directorio del port en <span class=filename>files/Makefile.localized</span>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Hecho esto puede ejecutar OpenOffice.org con la orden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% openoffice.org</code></pre></div></div></div></div><div class=sect2><h3 id=desktop-viewers>6.4. Visores de documentos<a class=anchor href=#desktop-viewers></a></h3><div class=paragraph><p>Desde la aparición de UNIX® han ido apareciendo formatos de documento de lo más diverso, alguno de los cuales se ha hecho muy popular. Los visores de documentos estándar que requieren no tienen por qué estar en el sistema base. En esta sección veremos cómo instalar estos visores.</p></div><div class=paragraph><p>Esta sección cubre las siguientes aplicaciones:</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:25%><col style=width:25%><col style=width:25%><col style=width:25%><thead><tr><th class="tableblock halign-left valign-top">Nombre de la aplicación</th><th class="tableblock halign-left valign-top">Recursos necesarios</th><th class="tableblock halign-left valign-top">Instalación desde los ports</th><th class="tableblock halign-left valign-top">Dependencias importantes</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Acrobat Reader®</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>ligero</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>ligero</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Compatibilidad binaria de Linux</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>gv</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>ligero</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>ligero</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Xaw3d</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Xpdf</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>ligero</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>ligero</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>FreeType</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>GQview</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>ligero</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>ligero</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Gtk+ o GNOME</p></td></tr></tbody></table><div class=sect3><h4 id=_acrobat_reader>6.4.1. Acrobat Reader®<a class=anchor href=#_acrobat_reader></a></h4><div class=paragraph><p>Muchos documentos se distribuyen en formato PDF, siglas de «Portable Document Format». Uno de los visores recomendados para este tipo de ficheros es Acrobat Reader®, un producto de Adobe para Linux. Dado que FreeBSD puede ejecutar binarios de Linux también existe para FreeBSD.</p></div><div class=paragraph><p>Para instalar Acrobat Reader® 7 desde la Colección de Ports ejecute:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/print/acroread7</span>
<span class=c># make install clean</span></code></pre></div></div><div class=paragraph><p>No hay package debido a las restricciones que impone la licencia del software.</p></div></div><div class=sect3><h4 id=_gv>6.4.2. gv<a class=anchor href=#_gv></a></h4><div class=paragraph><p>gv es un visor de PostScript® y PDF. Tiene su origen en ghostview pero tiene un aspecto bastante mejorado gracias a la librería Xaw3d. Es rápido y tiene una interfaz limpia. gv tiene muchas opciónes como orientación, tamaño del papel, escalado o antialias. Casi todas las operaciones se pueden realizar desde el teclado o desde el ratón.</p></div><div class=paragraph><p>Para instalar gv como package ejecute:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg_add -r gv</span></code></pre></div></div><div class=paragraph><p>Si no puede obtener el package puede usar la colección de ports:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/print/gv</span>
<span class=c># make install clean</span></code></pre></div></div></div><div class=sect3><h4 id=_xpdf>6.4.3. Xpdf<a class=anchor href=#_xpdf></a></h4><div class=paragraph><p>Si quiere un visor de PDF pequeño, Xpdf es un visor ligero y eficiente. Requiere muy pocos recursos y es muy estable. Usa los tipos estándar de X y no depende de Motif® ni de ningún otro «toolkit» de X.</p></div><div class=paragraph><p>Para instalar el package de Xpdf use la siguiente orden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg_add -r xpdf</span></code></pre></div></div><div class=paragraph><p>Si el paquete no está disponible o prefiere usar la colección de ports ejecute:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/graphics/xpdf</span>
<span class=c># make install clean</span></code></pre></div></div><div class=paragraph><p>Una vez que la instalación haya concluido puede lanzar Xpdf; use el botón derecho del ratón para activar el menú.</p></div></div><div class=sect3><h4 id=_gqview>6.4.4. GQview<a class=anchor href=#_gqview></a></h4><div class=paragraph><p>GQview es un visor de imágenes. Puede ver un fichero con un click, lanzar un editor externo, obtener imágenes de previsualización y muchas cosas más. También tiene un modo de presentación y admite algunas opciones básicas de manipulación de ficheros. Puede gestionar colecciones de imágenes y encontrar ficheros duplicados con facilidad. GQview puede mostrar las imágenes a pantalla completa y está preparado para la internacionalización.</p></div><div class=paragraph><p>Si quiere instalar el paquete de GQview ejecute:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg_add -r gqview</span></code></pre></div></div><div class=paragraph><p>Si el paquete no está disponible o prefiere usar la colección de ports ejecute:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/graphics/gqview</span>
<span class=c># make install clean</span></code></pre></div></div></div></div><div class=sect2><h3 id=desktop-finance>6.5. Finanzas<a class=anchor href=#desktop-finance></a></h3><div class=paragraph><p>Si por algun motivo quisiera gestionar sus finanzas personales en su escritorio FreeBSD hay algunas aplicaciones potentes y sencillas de utilizar que puede instalar. Algunas de ellas son compatibles con formatos muy extendidos como documentos de Quicken o Excel.</p></div><div class=paragraph><p>Esta sección cubre las siguientes aplicaciones:</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:25%><col style=width:25%><col style=width:25%><col style=width:25%><thead><tr><th class="tableblock halign-left valign-top">Nombre de aplicación</th><th class="tableblock halign-left valign-top">Recursos necesarios</th><th class="tableblock halign-left valign-top">Instalación desde los ports</th><th class="tableblock halign-left valign-top">Dependencias importantes</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>GnuCash</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>ligero</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>pesado</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>GNOME</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Gnumeric</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>ligero</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>pesado</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>GNOME</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Abacus</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>ligero</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>pesado</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Tcl/Tk</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>KMyMoney</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>ligero</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>pesado</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>KDE</p></td></tr></tbody></table><div class=sect3><h4 id=_gnucash>6.5.1. GnuCash<a class=anchor href=#_gnucash></a></h4><div class=paragraph><p>GnuCash es parte del afán de GNOME por ofrecer aplicaciones de uso sencillo pero a la vez potentes a los usuarios. Con GnuCash, puede gestionar sus ingresos y sus gastos, sus cuentas bancarias o sus acciones. Tiene una interfaz intuitiva pero muy profesional.</p></div><div class=paragraph><p>GnuCash dispone de un registro elegante, un sistema jerárquico de cuentas, muchos atajos de teclado y métodos de autocompletado. Puede dividir una transacción en varias partes más detalladas. GnuCash puede importar y mezclar ficheros QIF de Quicken. También admite muchos formatos internacionales de fecha y moneda.</p></div><div class=paragraph><p>Para instalar GnuCash en su sistema ejecute:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg_add -r gnucash</span></code></pre></div></div><div class=paragraph><p>Si el paquete no está disponible puede usar la colección de ports:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/finance/gnucash</span>
<span class=c># make install clean</span></code></pre></div></div></div><div class=sect3><h4 id=_gnumeric>6.5.2. Gnumeric<a class=anchor href=#_gnumeric></a></h4><div class=paragraph><p>Gnumeric es una hoja de cálculo que forma parte del entorno de escritorio GNOME. Implementa una «predicción» automática de la entrada del usuario de acuerdo con el formato de celda y un sistema de completado automático para múltiples secuencias. Puede importar ficheros de un gran número de formatos muy extendidos, como Excel, Lotus 1-2-3 o Quattro Pro. Gnumeric soporta gráficas mediante el programa de gráficas <a class=package href=https://cgit.freebsd.org/ports/tree/math/guppi/>math/guppi</a>. Tiene un gran námero de funciones internas y permite todos los formatos normales de celda como número, moneda, fecha, hora y muchos más.</p></div><div class=paragraph><p>Para instalar Gnumeric como package ejecute:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg_add -r gnumeric</span></code></pre></div></div><div class=paragraph><p>Si el package no está disponible puede usar la colección de ports del siguiente modo:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/math/gnumeric</span>
<span class=c># make install clean</span></code></pre></div></div></div><div class=sect3><h4 id=_abacus>6.5.3. Abacus<a class=anchor href=#_abacus></a></h4><div class=paragraph><p>Abacus es una hoja de cálculo pequeña y fácil de usar. Tiene muchas funciones útiles en varios ámbitos como la estadística, las finanzas y las matemáticas. Puede importar y exportar ficheros con formato Excel. Abacus puede generar ficheros PostScript®.</p></div><div class=paragraph><p>Para instalar Abacus como package ejecute:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pkg_add -r abacus</span></code></pre></div></div><div class=paragraph><p>Si no hay package al alcance puede usar la colección de ports:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/deskutils/abacus</span>
<span class=c># make install clean</span></code></pre></div></div></div></div><div class=sect2><h3 id=desktop-summary>6.6. Resumen<a class=anchor href=#desktop-summary></a></h3><div class=paragraph><p>FreeBSD está muy extendido en ISP por su alto rendimiento y estabilidad, pero también se puede usar a diario como escritorio. Hay miles de aplicaciones disponibles como <a href=http://www.FreeBSD.org/where/>packages</a> o <a href=http://www.FreeBSD.org/ports/>ports</a> con las que puede crear un escritorio que cubra todas sus necesidades.</p></div><div class=paragraph><p>Aqui hay un resumen de todas las aplicaciones cubiertas en este cápitulo:</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Nombre De La Aplicación</th><th class="tableblock halign-left valign-top">Nombre Del Paquete</th><th class="tableblock halign-left valign-top">Nombre Del Port</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Mozilla</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>mozilla</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/www/mozilla/>www/mozilla</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Opera</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>opera</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/www/opera/>www/opera</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Firefox</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>firefox</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/www/firefox/>www/firefox</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>KOffice</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>koffice-kde3</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/editors/koffice-kde3/>editors/koffice-kde3</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>AbiWord</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>AbiWord2</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/editors/AbiWord2/>editors/AbiWord2</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>GIMP</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>gimp</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/graphics/gimp/>graphics/gimp</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>OpenOffice.org</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>openoffice</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/editors/openoffice-1.1/>editors/openoffice-1.1</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Acrobat Reader®</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>acroread</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/print/acroread7/>print/acroread7</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>gv</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>gv</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/print/gv/>print/gv</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Xpdf</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>xpdf</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/graphics/xpdf/>graphics/xpdf</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>GQview</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>gqview</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/graphics/gqview/>graphics/gqview</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>GnuCash</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>gnucash</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/finance/gnucash/>finance/gnucash</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Gnumeric</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>gnumeric</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/math/gnumeric/>math/gnumeric</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Abacus</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>abacus</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/deskutils/abacus/>deskutils/abacus</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>KMyMoney</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>kmymoney2</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/finance/kmymoney2/>finance/kmymoney2</a></p></td></tr></tbody></table></div></div></div><div class=sect1><h2 id=multimedia>Capítulo 7. Multimedia<a class=anchor href=#multimedia></a></h2><div class=sectionbody><div class=sect2><h3 id=_sinopsis>7.1. Sinopsis<a class=anchor href=#_sinopsis></a></h3><div class=paragraph><p>FreeBSD admite una gran variedad de tarjetas de sonido, lo que permite disfrutar de sonido de alta fidelidad en su sistema. Ésto incluye la posibilidad de grabar y reproducir ficheros de audio tanto en los formatos MPEG Audio Layer 3 (MP3), WAV y Ogg Vorbis, así como muchos otros. La Colección de Ports de FreeBSD contiene también aplicaciones que le permitirán editar audio previamente grabado, añadir efectos y controlar dispositivos MIDI.</p></div><div class=paragraph><p>Tras unas cuantas pruebas podrá reproducir ficheros de video y DVD en FreeBSD. La cantidad de aplicaciones disponibles para codificar, convertir y reproducir los diversos soportes de video es más limitada que lo que hay disponible para el sonido. Por ejemplo, en el momento de escribir este texto no hay en la Colección de Ports de FreeBSD una buena aplicación que permita pasar datos de un formato a otro, el equivalente a lo que hay en el campo del sonido con <a class=package href=https://cgit.freebsd.org/ports/tree/audio/sox/>audio/sox</a>. A pesar de eso la situación en este área está cambiando rápidamente.</p></div><div class=paragraph><p>Este capítulo muestra los pasos necesarios para configurar una tarjeta de sonido. La configuración e instalación de X11 (<a href=./#x11>El sistema X Window</a>) habrá solucionado ya todos los problemas que hubiera podido darle su tarjeta gráfica, aunque quizás haya algún pequeño detalle que añadir para mejorar la reproducción.</p></div><div class=paragraph><p>Tras leer éste capítulo sabrá usted:</p></div><div class=ulist><ul><li><p>Cómo configurar su sistema de modo que su tarjeta de sonido sea reconocida por el mismo.</p></li><li><p>Confirmar el funcionamiento de su tarjeta usando herramientas de muestreo.</p></li><li><p>Cómo enfrentarse a problemas de configuración de sonido.</p></li><li><p>Cómo reproducir y crear ficheros MP3 y otros.</p></li><li><p>Cómo gestiona el video el servidor X.</p></li><li><p>Identificar unos cuantos ports para reproducir y codificar video que le darán muy buenos resultados.</p></li><li><p>Cómo reproducir DVD y ficheros <span class=filename>.mpg</span> y <span class=filename>.avi</span>.</p></li><li><p>Cómo convertir CD y DVD en ficheros de datos.</p></li><li><p>Cómo configurar una tarjeta de TV.</p></li><li><p>Cómo configurar un escáner de imágenes.</p></li></ul></div><div class=paragraph><p>Antes de leer éste capítulo debería:</p></div><div class=ulist><ul><li><p>Saber configurar e instalar un nuevo kernel (<a href=./#kernelconfig>Configuración del kernel de FreeBSD</a>).</p></li></ul></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Si intenta montar un cd con <a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a> provocará (como mínimo) un error en el sistema, pero puede llegar a provocar un <em>kernel panic</em>. Dichos soportes tienen codificaciones especiales sustancialmente diferentes de los típicos sistemas de ficheros ISO.</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=sound-setup>7.2. Configuración de la tarjeta de sonido<a class=anchor href=#sound-setup></a></h3><div class=sect3><h4 id=sound-device>7.2.1. Configuración del sistema<a class=anchor href=#sound-device></a></h4><div class=paragraph><p>Antes de nada tendrá que saber a ciencia cierta el modelo de tarjeta que tiene, qué chip utiliza y si es PCI o ISA. FreeBSD admite una amplia variedad de tarjetas, tanto PCI como ISA. Consulte la lista de dispositivos de sonido que puede usar en FreeBSD en las <a href=https://www.FreeBSD.org/releases/12.0R/hardware/>Hardware Notes</a>. Las «Hardware Notes» le dirán también qué controlador es el que hace funcionar su tarjeta.</p></div><div class=paragraph><p>Para poder usar su dispositivo de sonido en FreeBSD tiene que cargar el controlador de dispositivo adecuado, cosa que puede hacerse de dos maneras. La forma más fácil es cargar el módulo del kernel correspondiente a su tarjeta de sonido mediante <a href="https://man.freebsd.org/cgi/man.cgi?query=kldload&amp;sektion=8&amp;format=html">kldload(8)</a>. Puede hacerlo en su shell con la siguiente orden</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload snd_emu10k1</span></code></pre></div></div><div class=paragraph><p>o añadiendo la línea apropiada al fichero <span class=filename>/boot/loader.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>snd_emu10k1_load=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Ambos ejemplos son para una tarjeta de sonido Creative SoundBlaster® Live!. Encontrará una lista de módulos de sonido que puede cargar del mismo modo en <span class=filename>/boot/defaults/loader.conf</span>. Si no está del todo seguro sobre el controlador que debe usar pruebe con el módulo <span class=filename>snd_driver</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload snd_driver</span></code></pre></div></div><div class=paragraph><p>Se trata de un «metacontrolador» que carga en memoria todos los controladores más habituales. De este modo acelerará notablemente el proceso de detectar cuál es el controlador perfecto para su hardware. También puede cargar todos los controladores de sonido desde <span class=filename>/boot/loader.conf</span>.</p></div><div class=paragraph><p>Si quiere saber qué controlador se corresponde con su tarjeta de sonido una vez cargado el «metadriver» <span class=filename>snd_driver</span> debe comprobar el contenido de <span class=filename>/dev/sndstat</span> mediante la orden <code>cat /dev/sndstat</code>.</p></div><div class=paragraph><p>El segundo método es compilar de forma estática el soporte para su tarjeta de sonido dentro de un kernel personalizado. En la siguiente sección encontrará la información necesaria para añadir a su kernel el soporte que necesita su hardware. Para más información sobre la compilación de un kernel consulte el <a href=./#kernelconfig>Configuración del kernel de FreeBSD</a>.</p></div><div class=sect4><h5 id=_configuración_de_un_kernel_personalizado_con_soporte_de_sonido>7.2.1.1. Configuración de un kernel personalizado con soporte de sonido<a class=anchor href=#_configuración_de_un_kernel_personalizado_con_soporte_de_sonido></a></h5><div class=paragraph><p>Lo primero que hay que hacer es añadir el controlador del «framework» de sonido <a href="https://man.freebsd.org/cgi/man.cgi?query=sound&amp;sektion=4&amp;format=html">sound(4)</a> al kernel; tendrá que añadir la siguiente línea a su fichero de configuración del kernel:</p></div><div class="literalblock programlisting"><div class=content><pre>device sound</pre></div></div><div class=paragraph><p>Una vez hecho esto tiene que añadir el soporte para su tarjeta de sonido. Evidentemente tendrá que saber exactamente qué controlador es el que hace funcionar su tarjeta. Consulte la lista de dispositivos de sonido soportados que encontrará en las <a href=https://www.FreeBSD.org/releases/12.0R/hardware/>Hardware Notes</a> y elija el controlador perfecto para su tarjeta. Por ejemplo una una tarjeta de sonido Creative SoundBlaster® Live! usará el controlador <a href="https://man.freebsd.org/cgi/man.cgi?query=snd_emu10k1&amp;sektion=4&amp;format=html">snd_emu10k1(4)</a>. Siguiendo con el ejemplo, si queremos añadir soporte para esta tarjeta agregaremos lo siguiente:</p></div><div class="literalblock programlisting"><div class=content><pre>device snd_emu10k1</pre></div></div><div class=paragraph><p>Por favor, lea la página de manual del controlador si tiene dudas con la sintaxis. La sintaxis específica para la configuración en el kernel de cada tarjeta de sonido soportada existente puede encontrarse también en <span class=filename>/usr/src/sys/conf/NOTES</span>.</p></div><div class=paragraph><p>Las tarjetas ISA no PnP pueden requerir que se le facilite al kernel la información de la configuración de la tarjeta (IRQ, puerto de E/S, etc). Esto se hace modificando el fichero <span class=filename>/boot/device.hints</span>. Durante el proceso de arranque <a href="https://man.freebsd.org/cgi/man.cgi?query=loader&amp;sektion=8&amp;format=html">loader(8)</a> leerá este fichero y le pasará los parámetros al kernel. Veamos un ejemplo: una vieja tarjeta Creative SoundBlaster® 16 ISA no PnP utilizará el controlador <a href="https://man.freebsd.org/cgi/man.cgi?query=snd_sbc&amp;sektion=4&amp;format=html">snd_sbc(4)</a> junto con <code>snd_sb16</code>. En el caso de esta tarjeta habrá que añadir las siguientes líneas al fichero de configuración del kernel</p></div><div class="literalblock programlisting"><div class=content><pre>device snd_sbc
device snd_sb16</pre></div></div><div class=paragraph><p>y añadir lo siguiente a <span class=filename>/boot/device.hints</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>hint.sbc.0.at=&#34;isa&#34;
hint.sbc.0.port=&#34;0x220&#34;
hint.sbc.0.irq=&#34;5&#34;
hint.sbc.0.drq=&#34;1&#34;
hint.sbc.0.flags=&#34;0x15&#34;</pre></div></div><div class=paragraph><p>La tarjeta del ejemplo usa el puerto de E/S <code>0x220</code> I/O port y la IRQ <code>5</code>.</p></div><div class=paragraph><p>La sintaxis a utilizar en <span class=filename>/boot/device.hints</span> se explica en la página de manual de <a href="https://man.freebsd.org/cgi/man.cgi?query=sound&amp;sektion=4&amp;format=html">sound(4)</a> y en la del controlador en cuestión.</p></div><div class=paragraph><p>En el ejemplo se muestran los parámetros por omisión. En ciertos casos habrá que usar otra IRQ o usar otros parámetros para hacer funcionar la tarjeta de sonido. Consulte la página de manual de <a href="https://man.freebsd.org/cgi/man.cgi?query=snd_sbc&amp;sektion=4&amp;format=html">snd_sbc(4)</a> para más información sobre esta tarjeta.</p></div></div></div><div class=sect3><h4 id=sound-testing>7.2.2. Cómo probar su tarjeta de sonido<a class=anchor href=#sound-testing></a></h4><div class=paragraph><p>Una vez que haya reiniciado con su kernel personalizado, o tras cargar el mólo del kernel necesario la tarjeta de sonido aparecerá en el búfer de mensajes del sistema (<a href="https://man.freebsd.org/cgi/man.cgi?query=dmesg&amp;sektion=8&amp;format=html">dmesg(8)</a>); deberí ser algo muy parecido a esto:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>pcm0: &lt;Intel ICH3 <span class=o>(</span>82801CA<span class=o>)&gt;</span> port 0xdc80-0xdcbf,0xd800-0xd8ff irq 5 at device 31.5 on pci0
pcm0: <span class=o>[</span>GIANT-LOCKED]
pcm0: &lt;Cirrus Logic CS4205 AC97 Codec&gt;</code></pre></div></div><div class=paragraph><p>Puede comprobar el estado de la tarjeta de sonido en el fichero <span class=filename>/dev/sndstat</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cat /dev/sndstat</span>
FreeBSD Audio Driver <span class=o>(</span>newpcm<span class=o>)</span>
Installed devices:
pcm0: &lt;Intel ICH3 <span class=o>(</span>82801CA<span class=o>)&gt;</span> at io 0xd800, 0xdc80 irq 5 bufsz 16384
kld snd_ich <span class=o>(</span>1p/2r/0v channels duplex default<span class=o>)</span></code></pre></div></div><div class=paragraph><p>El resultado en su sistema seguramente será distinto. Si no aparecen dispositivos <span class=filename>pcm</span> revise todo el proceso a ver dónde está el error. Revise su fichero de configuración del kernel nuevamente y compruebe que eligió el controlador de dispositivo adecuado. Tiene una lista de problemas habituales en la <a href=#troubleshooting>Problemas habituales</a>.</p></div><div class=paragraph><p>Si todo ha ido bien ya tiene una tarjeta de sonido funcionando en su sistema. Si los pins de salida de sonido de su CD-ROM o DVD-ROM están colocados correctamente puede poner un CD en la unidad y reproducirlo con <a href="https://man.freebsd.org/cgi/man.cgi?query=cdcontrol&amp;sektion=1&amp;format=html">cdcontrol(1)</a>.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% cdcontrol <span class=nt>-f</span> /dev/acd0 play 1</code></pre></div></div><div class=paragraph><p>Hay muchas aplicaciones como <a class=package href=https://cgit.freebsd.org/ports/tree/audio/workman/>audio/workman</a> que le ofrecerán un interfaz más amigable. Si quiere escuchar ficheros MP3 puede instalar, por ejemplo, <a class=package href=https://cgit.freebsd.org/ports/tree/audio/mpg123/>audio/mpg123</a>.</p></div><div class=paragraph><p>Hay otra via aún más rápida de probar su tarjeta de sonido. Envíe datos a to <span class=filename>/dev/dsp</span> del siguiente modo:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>cat </span>fichero <span class=o>&gt;</span> /dev/dsp</code></pre></div></div><div class=paragraph><p>donde <span class=filename>fichero</span> puede ser cualquier fichero. Esta orden producirá ruido, lo que confirmará que la tarjeta de sonido funciona.</p></div><div class=paragraph><p>Puede manejar los niveles de la tarjeta de sonido con <a href="https://man.freebsd.org/cgi/man.cgi?query=mixer&amp;sektion=8&amp;format=html">mixer(8)</a>. Tiene todos los detalles en la página de manual de <a href="https://man.freebsd.org/cgi/man.cgi?query=mixer&amp;sektion=8&amp;format=html">mixer(8)</a>.</p></div><div class=sect4><h5 id=troubleshooting>7.2.2.1. Problemas habituales<a class=anchor href=#troubleshooting></a></h5><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Error</th><th class="tableblock halign-left valign-top">Solution</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>sb_dspwr(XX) timed out</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>El puerto de E/S no ha sido configurado correctamente.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>bad irq XX</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>No ha elegido correctamente la IRQ. Asegúrese de que la IRQ que ha elegido y la IRQ del sonido son la misma.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>xxx: gus pcm not attached, out of memory</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>No queda memoria suficiente en el sistema para poder usar el dispositivo.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>xxx: can’t open /dev/dsp!</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Compruebe si hay otra aplicación utilizando (y por tanto ocupando) el dispositivo. Escriba <code>fstat | grep dsp</code>. Los sospechosos habituales son esound y el sistema de sonido de KDE.</p></td></tr></tbody></table></div></div><div class=sect3><h4 id=sound-multiple-sources>7.2.3. Cómo utilizar múltiples fuentes de sonido<a class=anchor href=#sound-multiple-sources></a></h4><div class=paragraph><p>Disponer de múltiples fuentes de sonido puede ser muy útil, por ejemplo cuando esound o artsd no permiten compartir el dispositivo de sonido con otra aplicación.</p></div><div class=paragraph><p>FreeBSD permite hacerlo gracias a los <em>Virtual Sound Channels</em> (<code>canales virtuales de sonido</code>), que se activan mediante <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a>. Los canales virtuales permiten multiplexar la reproducción de sonido de su tarjeta mezclando el sonido en el kernel.</p></div><div class=paragraph><p>El número de canales virtuales se configura utilizando dos sysctl; como <code>root</code> escriba lo siguiente:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl hw.snd.pcm0.vchans=4</span>
<span class=c># sysctl hw.snd.maxautovchans=4</span></code></pre></div></div><div class=paragraph><p>En el ejemplo anterior se han creado cuatro canales virtuales, una cantidad muy razonable para el uso normal. <code>hw.snd.pcm0.vchans</code> es el número de canales virtuales de que dispone <span class=filename>pcm0</span>; puede configurarlo en cuanto el dispositivo sea reconocido por el sistema. <code>hw.snd.maxautovchans</code> es el número de canales virtuales que se le asignan a un nuevo dispositivo de audio cuando se conecta al sistema mediante <a href="https://man.freebsd.org/cgi/man.cgi?query=kldload&amp;sektion=8&amp;format=html">kldload(8)</a>. Puesto que el módulo <span class=filename>pcm</span> puede cargarse independientemente de los controladores de hardware <code>hw.snd.maxautovchans</code> puede almacenar cuántos canales virtuales tienen asignados los dispositivos que se vayan conectando al sistema.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>No es posible modificar el número de canales virtuales de un dispositivo que esté en marcha. Cierre antes todos los programas que estén utilizando el dispositivo, como reproductores de música o dæmons de sonido.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Si no usa <a href="https://man.freebsd.org/cgi/man.cgi?query=devfs&amp;sektion=5&amp;format=html">devfs(5)</a> tendrá que configurar sus aplicaciones para que apunten a <span class=filename>/dev/dsp0</span>.<em>x</em>, donde <em>x</em> es un número entre 0 y 3 si <code>hw.snd.pcm.0.vchans</code> tiene un valor de 4 como en el ejemplo anterior. Si se estuviera usando <a href="https://man.freebsd.org/cgi/man.cgi?query=devfs&amp;sektion=5&amp;format=html">devfs(5)</a> en el ejemplo anterior cualquier programa que pidiera <span class=filename>/dev/dsp0</span> sería atendido de forma totalmente transparente.</p></div></div><div class=sect3><h4 id=_asignación_a_los_canales_de_mezcla_de_valores_por_omisión>7.2.4. Asignación a los canales de mezcla de valores por omisión<a class=anchor href=#_asignación_a_los_canales_de_mezcla_de_valores_por_omisión></a></h4><div class=paragraph><p>Los valores por defecto de los distintos canales de mezcla están fijados en el código del controlador <a href="https://man.freebsd.org/cgi/man.cgi?query=pcm&amp;sektion=4&amp;format=html">pcm(4)</a>. Hay distintas aplicaciones y dæmons que le permitirán asignar valores al mezclador y que permanezcan entre uso y uso, pero no es una solución demasiado limpia. Puede asignar valores por omisión a las mezclas a nivel de controlador definiendo los valores apropiados en <span class=filename>/boot/device.hints</span>. Veamos un ejemplo:</p></div><div class="literalblock programlisting"><div class=content><pre>hint.pcm.0.vol=&#34;50&#34;</pre></div></div><div class=paragraph><p>Esto asignará al canal de volumen un valor por omisión de 50 al cargar el módulo <a href="https://man.freebsd.org/cgi/man.cgi?query=pcm&amp;sektion=4&amp;format=html">pcm(4)</a>.</p></div></div></div><div class=sect2><h3 id=sound-mp3>7.3. Sonido MP3<a class=anchor href=#sound-mp3></a></h3><div class=paragraph><p>El formato MP3 (MPEG Layer 3 Audio) llega casi al nivel de calidad del CD, por lo que no hay motivo por el deba faltar en su escritorio FreeBSD.</p></div><div class=sect3><h4 id=mp3-players>7.3.1. Reproductores de MP3<a class=anchor href=#mp3-players></a></h4><div class=paragraph><p>El reproductor de MP3 para X11 más extendido es, de lejos, XMMS (X Multimedia System). Puede usar en él «skins»de Winamp puesto que el interfaz gráfico de XMMS es casi idéntico al de Nullsoft Winamp. XMMS incluye también soporte nativo para «plug-ins».</p></div><div class=paragraph><p>Puede instalar XMMS como port (<a class=package href=https://cgit.freebsd.org/ports/tree/multimedia/xmms/>multimedia/xmms</a>) o como package.</p></div><div class=paragraph><p>La interfaz de XMMS es intuitiva e incluye una lista de reproducción, un ecualizador gráfico y muchas otras cosas. Si está acostumbrado a WinampXMMS le será muy fácil de usar.</p></div><div class=paragraph><p>El port <a class=package href=https://cgit.freebsd.org/ports/tree/audio/mpg123/>audio/mpg123</a> es un reproductor MP3 que se usa desde la shell.</p></div><div class=paragraph><p>Puede especificarle desde la misma línea de órdenes a mpg123 el dispositivo de sonido que debe usar y el fichero MP3 que debe reproducir. Veamos un ejemplo:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mpg123 -a /dev/dsp1.0 ASaber-GrandesÉxitos.mp3</span>
High Performance MPEG 1.0/2.0/2.5 Audio Player <span class=k>for </span>Layer 1, 2 and 3.
Version 0.59r <span class=o>(</span>1999/Jun/15<span class=o>)</span><span class=nb>.</span> Written and copyrights by Michael Hipp.
Uses code from various people. See <span class=s1>&#39;README&#39;</span> <span class=k>for </span>more!
THIS SOFTWARE COMES WITH ABSOLUTELY NO WARRANTY! USE AT YOUR OWN RISK!

Playing MPEG stream from ASaber-GrandesÉxitos.mp3 ...
MPEG 1.0 layer III, 128 kbit/s, 44100 Hz joint-stereo</code></pre></div></div><div class=paragraph><p>Sustituya <span class=filename>/dev/dsp1.0</span> por el dispositivo <span class=filename>dsp</span> que haya en su sistema.</p></div></div><div class=sect3><h4 id=rip-cd>7.3.2. Extracción de pistas de sonido de un CD<a class=anchor href=#rip-cd></a></h4><div class=paragraph><p>Antes de convirtir una pista o todo un CD a MP3 la información sonido debe volcarse al disco duro. Esto se hace convirtiendo los datos «raw CDDA» (CD Digital Audio) a ficheros WAV.</p></div><div class=paragraph><p>La herramienta <code>cdda2wav</code>, que forma parte del port <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/cdrtools/>sysutils/cdrtools</a>, permite la extracción de información de sonido en CD así como la información asociada a él.</p></div><div class=paragraph><p>Con el CD en la unidad la siguiente orden (como <code>root</code>) un CD entero en ficheros WAV individuales, uno por pista:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cdda2wav -D 0,1,0 -B</span></code></pre></div></div><div class=paragraph><p>cdda2wav soporta unidades CDROM ATAPI (IDE). En el caso de unidades IDE especifique el número de dispositivo en el lugar correspondiente al núro de unidad SCSI. Por ejemplo, para extraer la pista 7 desde una unidad IDE:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cdda2wav -D /dev/acd0 -t 7</span></code></pre></div></div><div class=paragraph><p>La opción <code>-D <em>0,1,0</em></code> indica el dispositivo SCSI <span class=filename>0,1,0</span>, que corresponde con la salida de <code>cdrecord -scanbus</code>.</p></div><div class=paragraph><p>Para extraer pistas de forma selectiva use la opción <code>-t</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cdda2wav -D 0,1,0 -t 7</span></code></pre></div></div><div class=paragraph><p>Esta opción extrae la séptima pista de un CDROM de sonido. Si quiere extraer un rango de pistas, por ejemplo las pistas de la uno a la siete, declare el rango del siguiente modo:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cdda2wav -D 0,1,0 -t 1+7</span></code></pre></div></div><div class=paragraph><p>La herramienta <a href="https://man.freebsd.org/cgi/man.cgi?query=dd&amp;sektion=1&amp;format=html">dd(1)</a> le permite también extraer pistas de sonido desde unidades ATAPI; consulte la <a href=./#duplicating-audiocds>Copiar CD de audio</a> para más información.</p></div></div><div class=sect3><h4 id=mp3-encoding>7.3.3. Codificación de MP3<a class=anchor href=#mp3-encoding></a></h4><div class=paragraph><p>Hoy por hoy el codificador de MP3 por antonomasia es lame. Puede encontrar lame en <a class=package href=https://cgit.freebsd.org/ports/tree/audio/lame/>audio/lame</a>.</p></div><div class=paragraph><p>Partiendo de ficheros WAV previamente extraidos la siguiente orden convierte <span class=filename>audio01.wav</span> en <span class=filename>audio01.mp3</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># lame -h -b 128 \</span>
<span class=nt>--tt</span> <span class=s2>&#34;Título de copla o cantar&#34;</span> <span class=se>\</span>
<span class=nt>--ta</span> <span class=s2>&#34;Grupo, solista o coral sinfónica&#34;</span> <span class=se>\</span>
<span class=nt>--tl</span> <span class=s2>&#34;Título del álbum&#34;</span> <span class=se>\</span>
<span class=nt>--ty</span> <span class=s2>&#34;2001&#34;</span> <span class=se>\</span>
<span class=nt>--tc</span> <span class=s2>&#34;Autor de la extracción y paso a MP3&#34;</span> <span class=se>\</span>
<span class=nt>--tg</span> <span class=s2>&#34;Estilo&#34;</span> <span class=se>\</span>
audio01.wav audio01.mp3</code></pre></div></div><div class=paragraph><p>Los 128 kbits pasan por se el estándar de ratio de bits de los MP3, aunque puede que usted sea de los que prefieren calidades más altas, 160 o incluso 192. A mayor ratio de bits, más espacio en disco necesitará, aunque la calidad también será mayor. La opción <code>-h</code> usa el modo «más calidad pero algo más lento». Las opciones que empiezan por <code>--t</code> indican etiquetas ID3, que suelen contener información de la canción que contiene el fichero MP3. Tiene información sobre otras opciones de codificación en la página de manual de lame.</p></div></div><div class=sect3><h4 id=mp3-decoding>7.3.4. Decodificación de MP3<a class=anchor href=#mp3-decoding></a></h4><div class=paragraph><p>Para grabar un CD de sonido desde ficheros MP3 hay que convertirlos a formato WAV no comprimido. Tanto XMMS como mpg123 soportan la conversión de MP3 a un formato de fichero no comprimido.</p></div><div class=paragraph><p>Escritura a disco desde XMMS:</p></div><div class="olist arabic procedure"><ol class=arabic><li><p>Arranque XMMS.</p></li><li><p>Botón derecho del raón en la ventana para acceder al menú de XMMS.</p></li><li><p>Elija <code>Preferences</code> en <code>Options</code>.</p></li><li><p>Cambie el «Output Plugin» a «Disk Writer Plugin».</p></li><li><p>Pulse <code>Configure</code>.</p></li><li><p>Elija un directorio en el que guardar los ficheros descomprimidos.</p></li><li><p>Cargue el fichero MP3 en XMMS de la forma habitual, pero asegúrese de tener el volumen al 100% y las opciones de ecualización desactivadas.</p></li><li><p>Pulse <code>Play</code> - parecerá que XMMS está reproduciendo música pero no sonará nada. Lo que está haciendo es volcar el MP3 a un fichero.</p></li><li><p>Recuerde que antes de poder volver a escuchar ficheros MP3 de nuevo tendrá que devolver el «Plugin de salida» por omisión a la posición inicial.</p></li></ol></div><div class=paragraph><p>Escritura de la salida estándar en mpg123:</p></div><div class="olist arabic procedure"><ol class=arabic><li><p>Ejecute <code>mpg123 -s audio01.mp3 > audio01.pcm</code></p></li></ol></div><div class=paragraph><p>XMMS genera un fichero WAV, mientras que mpg123 convierte MP3 a datos de sonido raw PCM. Puede usar cdrecord con ambos formatos para crear CD de sonido. Tendrá que usar <a href="https://man.freebsd.org/cgi/man.cgi?query=burncd&amp;sektion=8&amp;format=html">burncd(8)</a> para raw PCM. Si lo que tiene son ficheros WAV escuchará un ligero clic al principio de cada pista: se trata de la cabecera del fichero WAV. Puede eliminar esta cabecera mediante SoX (que puede instalar como port desde <a class=package href=https://cgit.freebsd.org/ports/tree/audio/sox/>audio/sox</a> o si lo prefiere como package):</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% sox <span class=nt>-t</span> wav <span class=nt>-r</span> 44100 <span class=nt>-s</span> <span class=nt>-w</span> <span class=nt>-c</span> 2 pista.wav pista.raw</code></pre></div></div><div class=paragraph><p>Consulte la <a href=./#creating-cds>Creación y uso de medios ópticos (CD)</a> para más información sobre el uso de grabadoras de CD en FreeBSD.</p></div></div></div><div class=sect2><h3 id=video-playback>7.4. Reproducción de vídeo<a class=anchor href=#video-playback></a></h3><div class=paragraph><p>La reproducción de vídeo es un área muy nueva y en la que se producen grandes cambios a gran velocidad. Tenga paciencia. Aquí no va a ser todo tan sencillo como al configurar el sonido.</p></div><div class=paragraph><p>Antes de comenzar es imprescindible que sepa con certeza cuál es el modelo de su tarjeta gráfica y qué chip usa. Tanto Xorg como XFree86™ soportan gran cantidad de tarjetas gráficas, pero de pocas se puede decir que den un buen rendiemiento de reproducción. Puede consultar una lista de extensiones que el servidor X puede hacer funcionar en su tarjeta ejecutando <a href="https://man.freebsd.org/cgi/man.cgi?query=xdpyinfo&amp;sektion=1&amp;format=html">xdpyinfo(1)</a> desde una sesión X11.</p></div><div class=paragraph><p>Le recomendamos que tenga a mano un fichero MPEG no muy grande para usarlo en las pruebas que haga con los diversos reproductores y opciones. Algunos reproductores de DVD buscarán por omisión soportes DVD en <span class=filename>/dev/dvd</span> (algunos incluso tienen fijado en el código el nombre de dicha unidad) seguramente le resultará útil ejecutar los siguientes enlaces simbólicos:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ln -sf /dev/acd0 /dev/dvd</span>
<span class=c># ln -sf /dev/acd0 /dev/rdvd</span></code></pre></div></div><div class=paragraph><p>Tenga en cuenta que debido al diseño de <a href="https://man.freebsd.org/cgi/man.cgi?query=devfs&amp;sektion=5&amp;format=html">devfs(5)</a> los enlaces creados a mano no sobrevivirán a un reinicio del sistema. Para que así suceda tras cada reinicio debe añadir las siguientes líneas a <span class=filename>/etc/devfs.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>link acd0 dvd
link acd0 rdvd</pre></div></div><div class=paragraph><p>Además, el descifrado de DVD (una tarea que hará necesario llamar a funciones especiales de los DVD-ROM) requiere permisos de escritura en unidades DVD.</p></div><div class=paragraph><p>Le recomendamos que aumente la memoria compartida del interfaz X11, para lo cual tendrá que incremente los valores asignados a varias <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a>:</p></div><div class="literalblock programlisting"><div class=content><pre>kern.ipc.shmmax=67108864
kern.ipc.shmall=32768</pre></div></div><div class=sect3><h4 id=video-interface>7.4.1. Cómo determinar las características de video<a class=anchor href=#video-interface></a></h4><div class=paragraph><p>Hay varias formas de reproducir vídeo en X11, pero cuál de ellas sea la que funcione depende en gran medida del hardware que intervenga. Cada uno de los métodos que se describen más son mejores o peores según en qué hardware se ejecute. Además el procesamiento de video en X11 es un asunto que está recibiendo mucha atención últimamente y en cada nueva versión de Xorg y de XFree86™ no es extraño encontrar avances significativos.</p></div><div class=paragraph><p>Veamos una lista de interfaces de vídeo muy comunes:</p></div><div class="olist arabic"><ol class=arabic><li><p>X11: salida normal de X11 utilizando memoria compartida.</p></li><li><p>XVideo: una extensión del interfaz X11 que permite la reproducción de vídeo en las ventanas de X11.</p></li><li><p>SDL: Simple Directmedia Layer.</p></li><li><p>DGA: Direct Graphics Access (<code>acceso directo a gráficos</code>.</p></li><li><p>SVGAlib: capa de consola de gráficos a bajo nivel.</p></li></ol></div><div class=sect4><h5 id=video-interface-xvideo>7.4.1.1. XVideo<a class=anchor href=#video-interface-xvideo></a></h5><div class=paragraph><p>Xorg y XFree86™ 4.X tienen una extensión llamada <em>XVideo</em> (también conocida como Xvideo, Xv o xv) que permite reproducir vídeo en ventanas del sistema X11 a través de un tipo de aceleración especial. Dicha extensión ofrece una calidad de reproducción muy alta incluso en máquinas muy cortas de recursos.</p></div><div class=paragraph><p>Utilice <code>xvinfo</code> para saber qué extensión está utilizando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% xvinfo</code></pre></div></div><div class=paragraph><p>XVideo is supported for your card if the result looks like:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>X-Video Extension version 2.2
screen <span class=c>#0</span>
  Adaptor <span class=c>#0: &#34;Savage Streams Engine&#34;</span>
    number of ports: 1
    port base: 43
    operations supported: PutImage
    supported visuals:
      depth 16, visualID 0x22
      depth 16, visualID 0x23
    number of attributes: 5
      <span class=s2>&#34;XV_COLORKEY&#34;</span> <span class=o>(</span>range 0 to 16777215<span class=o>)</span>
              client settable attribute
              client gettable attribute <span class=o>(</span>current value is 2110<span class=o>)</span>
      <span class=s2>&#34;XV_BRIGHTNESS&#34;</span> <span class=o>(</span>range <span class=nt>-128</span> to 127<span class=o>)</span>
              client settable attribute
              client gettable attribute <span class=o>(</span>current value is 0<span class=o>)</span>
      <span class=s2>&#34;XV_CONTRAST&#34;</span> <span class=o>(</span>range 0 to 255<span class=o>)</span>
              client settable attribute
              client gettable attribute <span class=o>(</span>current value is 128<span class=o>)</span>
      <span class=s2>&#34;XV_SATURATION&#34;</span> <span class=o>(</span>range 0 to 255<span class=o>)</span>
              client settable attribute
              client gettable attribute <span class=o>(</span>current value is 128<span class=o>)</span>
      <span class=s2>&#34;XV_HUE&#34;</span> <span class=o>(</span>range <span class=nt>-180</span> to 180<span class=o>)</span>
              client settable attribute
              client gettable attribute <span class=o>(</span>current value is 0<span class=o>)</span>
    maximum XvImage size: 1024 x 1024
    Number of image formats: 7
      <span class=nb>id</span>: 0x32595559 <span class=o>(</span>YUY2<span class=o>)</span>
        guid: 59555932-0000-0010-8000-00aa00389b71
        bits per pixel: 16
        number of planes: 1
        <span class=nb>type</span>: YUV <span class=o>(</span>packed<span class=o>)</span>
      <span class=nb>id</span>: 0x32315659 <span class=o>(</span>YV12<span class=o>)</span>
        guid: 59563132-0000-0010-8000-00aa00389b71
        bits per pixel: 12
        number of planes: 3
        <span class=nb>type</span>: YUV <span class=o>(</span>planar<span class=o>)</span>
      <span class=nb>id</span>: 0x30323449 <span class=o>(</span>I420<span class=o>)</span>
        guid: 49343230-0000-0010-8000-00aa00389b71
        bits per pixel: 12
        number of planes: 3
        <span class=nb>type</span>: YUV <span class=o>(</span>planar<span class=o>)</span>
      <span class=nb>id</span>: 0x36315652 <span class=o>(</span>RV16<span class=o>)</span>
        guid: 52563135-0000-0000-0000-000000000000
        bits per pixel: 16
        number of planes: 1
        <span class=nb>type</span>: RGB <span class=o>(</span>packed<span class=o>)</span>
        depth: 0
        red, green, blue masks: 0x1f, 0x3e0, 0x7c00
      <span class=nb>id</span>: 0x35315652 <span class=o>(</span>RV15<span class=o>)</span>
        guid: 52563136-0000-0000-0000-000000000000
        bits per pixel: 16
        number of planes: 1
        <span class=nb>type</span>: RGB <span class=o>(</span>packed<span class=o>)</span>
        depth: 0
        red, green, blue masks: 0x1f, 0x7e0, 0xf800
      <span class=nb>id</span>: 0x31313259 <span class=o>(</span>Y211<span class=o>)</span>
        guid: 59323131-0000-0010-8000-00aa00389b71
        bits per pixel: 6
        number of planes: 3
        <span class=nb>type</span>: YUV <span class=o>(</span>packed<span class=o>)</span>
      <span class=nb>id</span>: 0x0
        guid: 00000000-0000-0000-0000-000000000000
        bits per pixel: 0
        number of planes: 0
        <span class=nb>type</span>: RGB <span class=o>(</span>packed<span class=o>)</span>
        depth: 1
        red, green, blue masks: 0x0, 0x0, 0x0</code></pre></div></div><div class=paragraph><p>Tenga en cuenta que los formatos que aparecen en el listado (YUV2, YUV12, etc) no aparecen en todas las implementaciones de de XVideo y su ausencia puede despistar a algunos reproductores.</p></div><div class=paragraph><p>Si el resultado se parece mucho a esto</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>X-Video Extension version 2.2
screen <span class=c>#0</span>
no adaptors present</code></pre></div></div><div class=paragraph><p>lo más probable es que su tarjeta no soporte XVideo.</p></div><div class=paragraph><p>Si su tarjeta gráfica no soporta XVideo lo único que significa es que para su sistema será más complicado alcanzar los requisitos computacionales necesarios para el procesamiento de vídeo. Dependiendo de la tarjeta gráfica y el procesador que tenga es posible que de todos modos pueda salvar la papeleta. Consulte la sección sobre recursos avanzados en la <a href=#video-further-reading>Lecturas adicionales</a>.</p></div></div><div class=sect4><h5 id=video-interface-SDL>7.4.1.2. Simple Directmedia Layer<a class=anchor href=#video-interface-SDL></a></h5><div class=paragraph><p>SDL (Simple Directmedia Layer) se creó pensando en una capa que permitiera aplicaciones fáciles de portar entre las plataformas Microsoft® Windows®, BeOS y UNIX® y que permitiera al mismo tiempo un uso eficiente del sonido y el vídeo. La capa SDL ofrece abstracción de hardware a bajo nivel, lo que a veces puee ser más eficiente que la propia interfaz X11.</p></div><div class=paragraph><p>SDL está en <a class=package href=https://cgit.freebsd.org/ports/tree/devel/sdl12/>devel/sdl12</a>.</p></div></div><div class=sect4><h5 id=video-interface-DGA>7.4.1.3. Direct Graphics Access<a class=anchor href=#video-interface-DGA></a></h5><div class=paragraph><p>«Direct Graphics Access» es una extensión de X11 que permite que un programa sortée el servidor X y acceda directamente al «framebuffer». Utiliza memoria de bajo nivel, así es imprescindible que se ejecute como <code>root</code>.</p></div><div class=paragraph><p>Puede probar y analizar el rendimiento de la extensión DGA con <a href="https://man.freebsd.org/cgi/man.cgi?query=dga&amp;sektion=1&amp;format=html">dga(1)</a>. Al ejecutar <code>dga</code> la pantalla cambia de color cada vez que pulsa una tecla. Para salir de la aplicación pulse <kbd>q</kbd>.</p></div></div></div><div class=sect3><h4 id=video-ports>7.4.2. Ports y packages relacionados con el vídeo<a class=anchor href=#video-ports></a></h4><div class=paragraph><p>Esta sección expone el software existente en la Colección de Ports de FreeBSD que puede usar para la reproducción de vídeo. La reproducción de vídeo es un área del desarrollo de software donde hay muchísima actividad, de manera que las características de más de una de las aplicaciones que vamos a describir pueden ser distintas.</p></div><div class=paragraph><p>Lo primero que hay que conocer es el importante detalle de que la mayoría de las aplicaciones de vídeo que funcionan en FreeBSD se desarrollaron para Linux. Muchas de esas aplicaciones todavía están en versiones beta. Estos son algunos de los problemas que puede encontrarse durante el uso de software de vídeo en FreeBSD:</p></div><div class="olist arabic"><ol class=arabic><li><p>Una aplicación no puede reproducir un fichero que ha generado otra aplicación distinta.</p></li><li><p>Una aplicación no puede reproducir un fichero que ella misma a generado.</p></li><li><p>La misma aplicación ejecutándose en dos máquinas distintas, compilada en cada una de esas máquinas; la reproducción del mismo fichero da resultados diferentes.</p></li><li><p>El uso de un filtro aparentemente trivial como es redimensionar una imagen aplicando una escala da como fruto un resultado horroroso debido a que la rutina encargada de aplicarla es defectuosa.</p></li><li><p>Que una aplicación de volcados de memoria («core dumps»).</p></li><li><p>La documentación no se instala con el port, pero sí que existe en la web o en el directorio <span class=filename>work</span> del port.</p></li></ol></div><div class=paragraph><p>La mayoría de estas aplicaciones muestra síntomas evidente de «Linuxismo», es decir, hay problemas derivados del modo en el que se implementan las bibliotecas en las distribuciones de Linux, o del hecho de que ciertas características del kernel de Linux han sido dadas por omnipresentes por los autores de las aplicaciones. Estos problemas no siempre han sido advertidas y solucionadas de algún modo por los responsables de los ports, lo que puede desembocar en problemas como:</p></div><div class="olist arabic"><ol class=arabic><li><p>El uso de <span class=filename>/proc/cpuinfo</span> para detectar las características del procesador.</p></li><li><p>El uso erróneo de los hilos puede causar que ciertos programas se cuelguen al intentar cerrarse en lugar de cerrarse correctamente.</p></li><li><p>Software que aún no está en la Colección de Ports de FreeBSD usado frecuentemente con la aplicación.</p></li></ol></div><div class=paragraph><p>Hasta ahora los autores de las aplicaciones han colaborado de buen grado con los responsables de los ports para hacer más sencillo el trabajo de portar estas aplicaciones a FreeBSD.</p></div><div class=sect4><h5 id=video-mplayer>7.4.2.1. MPlayer<a class=anchor href=#video-mplayer></a></h5><div class=paragraph><p>MPlayer es un reproductor de vídeo desarrollado muy recientemente y con un desarrollo rapidísimo. Los objetivos del equipo MPlayer son la velocidad y la flexibilidad en Linux y otros sistemas Unix. El proyecto comenzó cuando el fundador del equipo se cansó de padecer el pobre rendimiento de los reproductores de vídeo que había disponibles en ese momento. Hay quien dice que el interfaz gráfico fue sacrificado en pos de un diseño más ligero, aunque una vez que se acostumbre a las opciones desde la línea de órdenes y a los atajos de teclado todo irá como la seda.</p></div><div class=sect5><h6 id=video-mplayer-building>7.4.2.1.1. Compilación de MPlayer<a class=anchor href=#video-mplayer-building></a></h6><div class=paragraph><p>Encontrará MPlayer en <a class=package href=https://cgit.freebsd.org/ports/tree/multimedia/mplayer/>multimedia/mplayer</a>. MPlayer ejecuta una serie de pruebas de hardware durante el proceso de compilación, dando como resultado un binario que no tiene por qué funcionar en otros sistemas. Recuerde, por tanto, compilar la aplicación como port y no utilice el package binario. Además hay múltiples parámetros que puede pasarle a <code>make</code>, tal y como verá al comenzar la compilación:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/multimedia/mplayer</span>
<span class=c># make</span>
N - O - T - E

Take a careful look into the Makefile <span class=k>in </span>order
to learn how to tune mplayer towards you personal preferences!
For example,
make WITH_GTK1
builds MPlayer with GTK1-GUI support.
If you want to use the GUI, you can either <span class=nb>install</span>
/usr/ports/multimedia/mplayer-skins
or download official skin collections from
http://www.mplayerhq.hu/homepage/dload.html</code></pre></div></div><div class=paragraph><p>Las opciones por omisión del port deberían bastar para la mayoría de los usuarios, aunque si va a necesitar el codec XviD tendrá que especificar <code>WITH_XVID</code> en la línea de órdenes. La unidad de DVD por defecto se puede definir con la opción <code>WITH_DVD_DEVICE</code> si la opción por omisión, <span class=filename>/dev/acd0</span>, no le sirve.</p></div><div class=paragraph><p>En el momento de escribir esto el port de MPlayer genera la documentación en formato HTML y dos ejecutables: <code>mplayer</code> y <code>mencoder</code>, que es una herramienta para recodificar vídeo.</p></div><div class=paragraph><p>La documentación en HTML de MPlayer es muy informativa. Si el lector no cubre todas sus dudas sobre hardware de vídeo e interfaces con el contenido de este capítulo la documentación de MPlayer es el sitio donde debe buscar. Si quiere más información sobre el soporte de vídeo en UNIX® el mejor sitio para consultar es, sin duda alguna, la documentación de MPlayer.</p></div></div><div class=sect5><h6 id=video-mplayer-using>7.4.2.1.2. Uso de MPlayer<a class=anchor href=#video-mplayer-using></a></h6><div class=paragraph><p>Los usuarios de MPlayer deben crear un subdirectorio <span class=filename>.mplayer</span> en su «home». Para crear este directorio (necesario para el funcionamiento de la aplicación) teclée lo siguiente:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>cd</span> /usr/ports/multimedia/mplayer
% make install-user</code></pre></div></div><div class=paragraph><p>Las opciones de <code>mplayer</code> para la línea de órdenes se detallan en la página de manual. Si necesita todavía más detalles consulte la documentación en HTML. En esta sección se va a explicar solamente lo más básico.</p></div><div class=paragraph><p>Para reproducir el fichero <span class=filename>ficherodeprueba.avi</span>, mediante una de las diversas interfaces de vídeo utilice la opción <code>-vo</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% mplayer <span class=nt>-vo</span> xv ficherodeprueba.avi</code></pre></div></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% mplayer <span class=nt>-vo</span> sdl ficherodeprueba.avi</code></pre></div></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% mplayer <span class=nt>-vo</span> x11 ficherodeprueba.avi</code></pre></div></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mplayer -vo dga ficherodeprueba.avi</span></code></pre></div></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mplayer -vo &#39;sdl:dga&#39; ficherodeprueba.avi</span></code></pre></div></div><div class=paragraph><p>Merece la pena que pruebe todas, puesto que el rendimiento relativo depende en gran medida de muchos factores y será muy distinto el resultado dependiendo del hardware.</p></div><div class=paragraph><p>Si quiere reproducir un DVD sustituya <span class=filename>ficherodeprueba.avi</span> por <code>dvd://<em>N</em> -dvd-device <em>DISPOSITIVO</em></code>, donde <em>N</em> es el número de título que quiere reproducir y <span class=filename>DISPOSITIVO</span> es el nodo de dispositivo del DVD-ROM. Veamos un ejemplo: para reproducir el título 3 desde <span class=filename>/dev/dvd</span> ejecutaremos:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mplayer -vo xv dvd://3 -dvd-device /dev/dvd</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>La unidad de DVD por omisión puede definirse durante la compilación del port de MPlayer con la opción <code>WITH_DVD_DEVICE</code>. Por defecto apunta a <span class=filename>/dev/acd0</span>. Tiene todos los detalles en el <span class=filename>Makefile</span> del port.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Consulte los atajos de teclado para parar la reproducción, ponerla en pausa, etc. consulte la salida de <code>mplayer -h</code> o mejor aún lése la página de manual.</p></div><div class=paragraph><p>Hay otras opciones que le resultarán de interés para la reproducción: <code>-fs -zoom</code>, para la reproducción a pantalla completa y <code>-framedrop</code>, que mejora el rendimiento.</p></div><div class=paragraph><p>Para evitar que la línea de órdenes se haga demasiado larga puede crear un fichero <span class=filename>.mplayer/config</span> e introducir en él las opciones que quiera usar desde el arranque de la aplicación:</p></div><div class="literalblock programlisting"><div class=content><pre>vo=xv
fs=yes
zoom=yes</pre></div></div><div class=paragraph><p>Para terminar, puede usar <code>mplayer</code> para extraer un título de un DVD a un fichero <span class=filename>.vob</span>. Por ejemplo, si quiere extraer el segundo título de un DVD escriba esto:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mplayer -dumpstream -dumpfile salida.vob dvd://2 -dvd-device /dev/dvd</span></code></pre></div></div><div class=paragraph><p>El fichero de salida, <span class=filename>salida.vob</span>, un MPEG y puede manipularlo con las aplicaciones que se describen en esta sección.</p></div></div><div class=sect5><h6 id=video-mencoder>7.4.2.1.3. mencoder<a class=anchor href=#video-mencoder></a></h6><div class=paragraph><p>Antes de empezar a usar <code>mencoder</code> le recomendamos que se familiarice con las opciones que se detallan en la documentación HTML. Hay también una página de manual, pero no es de mucha utilidad sin la documentación HTML. Hay una ingente cantidad de formas de mejorar la calidad, reducir el ratio de bits y cambiar formatos; alguno de esos pequeños trucos pueden marcar la diferencia entre un buen y un mal rendimiento. Le mostramos un par de ejemplos por los que puede empezar. El primero es una simple copia:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% mencoder entrada.avi <span class=nt>-oac</span> copy <span class=nt>-ovc</span> copy <span class=nt>-o</span> salida.avi</code></pre></div></div><div class=paragraph><p>Ciertas combinaciones erróneas de opciones en la línea de órdenes pueden dar como fruto un fichero de salida que no puede reproducir ni siquiera el propio <code>mplayer</code>, así que si lo que quiere es extraer datos a un fichero siga usando tranquilamente la opción <code>-dumpfile</code> de <code>mplayer</code>.</p></div><div class=paragraph><p>Para convertir <span class=filename>entrada.avi</span> con codificación MPEG4 y audio con codificación MPEG3 (necesitará <a class=package href=https://cgit.freebsd.org/ports/tree/audio/lame/>audio/lame</a>):</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% mencoder entrada.avi <span class=nt>-oac</span> mp3lame <span class=nt>-lameopts</span> <span class=nv>br</span><span class=o>=</span>192 <span class=se>\</span>
	 <span class=nt>-ovc</span> lavc <span class=nt>-lavcopts</span> <span class=nv>vcodec</span><span class=o>=</span>mpeg4:vhq <span class=nt>-o</span> salida.avi</code></pre></div></div><div class=paragraph><p>El fichero de salida puede verse con <code>mplayer</code> y con <code>xine</code>.</p></div><div class=paragraph><p>Si sustituye <span class=filename>entrada.avi</span> por <code>dvd://1 -dvd-device /dev/dvd</code> y lo ejecuta como <code>root</code> puede recodificar un título de DVD directamente. Es posible que el resultado no sea muy satisfactorio tras los primeros intentos, así que le recomendamos que vuelque el título a un fichero y haga todas las pruebas que necesite sobre ese fichero.</p></div></div></div><div class=sect4><h5 id=video-xine>7.4.2.2. El reproductor de vídeo xine<a class=anchor href=#video-xine></a></h5><div class=paragraph><p>El reproductor de vídeo xine es un ambicioso proyecto que tiene como meta ofrecer no solamente una aplicación de vídeo «todo en uno», sino crear una biblioteca base reutilizable y un ejecutable modular que puede ampliarse mediante «plugins». Existe como package y también como port: <a class=package href=https://cgit.freebsd.org/ports/tree/multimedia/xine/>multimedia/xine</a>.</p></div><div class=paragraph><p>El reproductor xine está todavía en mantillas, pero sus primeros pasos están siendo muy interesantes. xine requiere o una CPU rápida o una tarjeta gráfica, o bien soporte para la extensión XVideo. El GUI es intuitivo, aunque un tanto pedestre.</p></div><div class=paragraph><p>En el momento de escribir esto xine no incorpora ningún módulo de entrada que sirva para reproducir DVD codificados con CSS. Hay versiones compiladas por terceros que tienen módulos que lo permiten, pero ninguna de ellas está en la Colección de Ports de FreeBSD.</p></div><div class=paragraph><p>Comparado con MPlayerxine deja las cosas más hechas para el usuario, pero al mismo tiempo pone más difícil el control exhaustivo sobre todo lo que pasa. El reproductor xine da un mejor rendimiento en interfaces XVideo.</p></div><div class=paragraph><p>Por omisión xine arranca con un intefaz gráfico de usuario. Los menús pueden usarse para abrir un fichero en concreto:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% xine</code></pre></div></div><div class=paragraph><p>También puede invocar la aplicación desde la línea de órdenes para que reproduzca un fichero inmediatamente y sin utilizar el GUI:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% xine <span class=nt>-g</span> <span class=nt>-p</span> fichero.avi</code></pre></div></div></div><div class=sect4><h5 id=video-ports-transcode>7.4.2.3. Las herramientas transcode<a class=anchor href=#video-ports-transcode></a></h5><div class=paragraph><p>transcode no es un reproductor, sino una suite de herramientas para recodificar (también se podría usar la palabra «transcodificar», de ahí su nombre) ficheros de sonido y de vídeo. Con transcode es posible fundir ficheros de video y reparar ficheros deteriorados desde la línea de órdenes y en las interfaces de flujo <span class=filename>stdin/stdout</span>.</p></div><div class=paragraph><p>Puede configurar gran cantidad de opciones en el momento de la compilación de <a class=package href=https://cgit.freebsd.org/ports/tree/multimedia/transcode/>multimedia/transcode</a>; le recomendamos que use la siguiente línea de órdenes para compilar transcode:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># make WITH_OPTIMIZED_CFLAGS=yes WITH_LIBA52=yes WITH_LAME=yes WITH_OGG=yes \</span>
<span class=nv>WITH_MJPEG</span><span class=o>=</span><span class=nb>yes</span> <span class=nt>-DWITH_XVID</span><span class=o>=</span><span class=nb>yes</span></code></pre></div></div><div class=paragraph><p>La configuración que le proponemos deberí satisfacer a la mayoría de los usuarios.</p></div><div class=paragraph><p>Veamos un ejemplo ilustrativo de las posibilidades de <code>transcode</code>: convertir un fichero DivX en un fichero PAL MPEG-1 (PAL VCD):</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% transcode <span class=nt>-i</span> input.avi <span class=nt>-V</span> <span class=nt>--export_prof</span> vcd-pal <span class=nt>-o</span> output_vcd
% mplex <span class=nt>-f</span> 1 <span class=nt>-o</span> output_vcd.mpg output_vcd.m1v output_vcd.mpa</code></pre></div></div><div class=paragraph><p>Puede reproducir el fichero MPEG resultante, <span class=filename>output_vcd.mpg</span>, con MPlayer. Si quiere también puede grabar el fichero en un CD-R y tendrá un VideoCD, aunque para eso tendrá que instalar <a class=package href=https://cgit.freebsd.org/ports/tree/multimedia/vcdimager/>multimedia/vcdimager</a> y <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/cdrdao/>sysutils/cdrdao</a>.</p></div><div class=paragraph><p>Consulte la página de manual de <code>transcode</code>, pero no olvide consultar también el <a href=http://www.transcoding.org/cgi-bin/transcode>wiki de transcode</a>, en el que encontrará más información y muchos ejemplos.</p></div></div></div><div class=sect3><h4 id=video-further-reading>7.4.3. Lecturas adicionales<a class=anchor href=#video-further-reading></a></h4><div class=paragraph><p>El desarrollo de las diversas aplicaciones de vídeo disponibles en FreeBSD avanza rápidamente. Es muy posible que en un futuro cercano la mayoría de los problemas de los que hemos hablado aquí hayan sido resueltos. Mientras tanto quien quiera exprimir las capacidades de FreeBSD en las áreas del sonido y el vídeo tendrán que recopilar la información repartida en varias FAQ y tutoriales y utilizar unos cuantos programas diferentes. En esta sección se le proponen al lector interesado varias fuentes de información adicional.</p></div><div class=paragraph><p>La <a href=http://www.mplayerhq.hu/DOCS/>documentación de MPlayer</a> contiene una gran cantidad de información técnica. Cualquiera que quiera alcanzar un alto grado de conocimiento en vídeo sobre UNIX® debe consultar esa documentación. La lista de correo de MPlayer es sumamente hostil hacia quien no se ha molestado en leer la documentación <em>antes</em> de preguntar, así que si va a enviar informes de errores a esa lista, por favor, <em>léase la documentación.</em>.</p></div><div class=paragraph><p>El texto <a href=http://dvd.sourceforge.net/xine-howto/en_GB/html/howto.html>xine HOWTO</a> contiene un capítulo sobre mejora del rendimiento que afecta a todos los reproductores.</p></div><div class=paragraph><p>Hay unas cuantas aplicaciones muy prometedoras que el lector debería al menos probar:</p></div><div class=ulist><ul><li><p><a href=http://avifile.sourceforge.net/>Avifile</a>, que encontrará en los ports:<a class=package href=https://cgit.freebsd.org/ports/tree/multimedia/avifile/>multimedia/avifile</a>.</p></li><li><p><a href=http://www.dtek.chalmers.se/groups/dvd/>Ogle</a>, también en la colección de ports: <a class=package href=https://cgit.freebsd.org/ports/tree/multimedia/ogle/>multimedia/ogle</a>.</p></li><li><p><a href=http://xtheater.sourceforge.net/>Xtheater</a></p></li><li><p><a class=package href=https://cgit.freebsd.org/ports/tree/multimedia/dvdauthor/>multimedia/dvdauthor</a>, una aplicación libre para la producción de contenidos en DVD.</p></li></ul></div></div></div><div class=sect2><h3 id=tvcard>7.5. Configuración de tarjetas de TV<a class=anchor href=#tvcard></a></h3><div class=sect3><h4 id=_introducción>7.5.1. Introducción<a class=anchor href=#_introducción></a></h4><div class=paragraph><p>Las tarjetas de TV le permiten ver en su sistema emisiones de TV tradicionales o incluso por cable. La mayoría aceptan vídeo compuesto mediante RCA o una entrada de S-video; algunas de estas tarjetas incorporan también un sintonizador de radio FM.</p></div><div class=paragraph><p>FreeBSD puede utilizar tarjetas de TV PCI que tengan el chip Brooktree Bt848/849/878/879 o el chip de captura de vídeo Conexant CN-878/Fusion 878a gracias al controlador <a href="https://man.freebsd.org/cgi/man.cgi?query=bktr&amp;sektion=4&amp;format=html">bktr(4)</a>. Asegúrese de que la tarjeta tiene un sintonizador que esté soportado: consulte la lista de sintonizadores soportados que encontrará en la página de manual de <a href="https://man.freebsd.org/cgi/man.cgi?query=bktr&amp;sektion=4&amp;format=html">bktr(4)</a>.</p></div></div><div class=sect3><h4 id=_añadir_el_controlador>7.5.2. Añadir el controlador<a class=anchor href=#_añadir_el_controlador></a></h4><div class=paragraph><p>Poder usar la tarjeta tendrá que cargar el controlador <a href="https://man.freebsd.org/cgi/man.cgi?query=bktr&amp;sektion=4&amp;format=html">bktr(4)</a>. Una forma de hacerlo es añdir la siguiente línea al fichero <span class=filename>/boot/loader.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>bktr_load=&#34;YES&#34;</pre></div></div><div class=paragraph><p>También puede hacerlo compilando estáticamente el soporte para la tarjeta de TV en su kernel; añada las siguientes líneas al fichero de configuración de su kernel:</p></div><div class="literalblock programlisting"><div class=content><pre>device	 bktr
device	iicbus
device	iicbb
device	smbus</pre></div></div><div class=paragraph><p>Es necesario incluir todas esas lineas adicionales porque los componentes de la tarjeta están conectados entre sí por un bus I2C. Hecho esto compile e instale su nuevo kernel.</p></div><div class=paragraph><p>Una vez añadido el soporte de la tarjeta al sistema tendrá que reiniciar. Durante el arranque deberían aparecer rastros de su tarjeta de TV. Veamos un ejemplo:</p></div><div class="literalblock programlisting"><div class=content><pre>bktr0: &lt;BrookTree 848A&gt; mem 0xd7000000-0xd7000fff irq 10 at device 10.0 on pci0
iicbb0: &lt;I2C bit-banging driver&gt; on bti2c0
iicbus0: &lt;Philips I2C bus&gt; on iicbb0 master-only
iicbus1: &lt;Philips I2C bus&gt; on iicbb0 master-only
smbus0: &lt;System Management Bus&gt; on bti2c0
bktr0: Pinnacle/Miro TV, Philips SECAM tuner.</pre></div></div><div class=paragraph><p>Es obvio que estos mensajes serán distintos según sea el hardware del que se trate. Asegúrese de que el sistema detecta correctamente el sintonizador. Se puede sobreescribir alguno de los parámetros detectados por el sistema mediante MIB <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> y opciones del fichero de configuración del kernel. Si por ejemplo quiere obligar al sintonizador para que se comporte como un Phillips SECAM añada lo siguiente al fichero de configuración de su kernel:</p></div><div class="literalblock programlisting"><div class=content><pre>options OVERRIDE_TUNER=6</pre></div></div><div class=paragraph><p>Puede utilizar directamente <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl hw.bt848.tuner=6</span></code></pre></div></div><div class=paragraph><p>Consulte en <a href="https://man.freebsd.org/cgi/man.cgi?query=bktr&amp;sektion=4&amp;format=html">bktr(4)</a> y en <span class=filename>/usr/src/sys/conf/NOTES</span> si necesita más detalles sobre las opciones disponibles.</p></div></div><div class=sect3><h4 id=_aplicaciones_útiles>7.5.3. Aplicaciones útiles<a class=anchor href=#_aplicaciones_útiles></a></h4><div class=paragraph><p>Tendrá que instalar una de estas aplicaciones para poder utilizar su tarjeta de TV:</p></div><div class=ulist><ul><li><p><a class=package href=https://cgit.freebsd.org/ports/tree/multimedia/fxtv/>multimedia/fxtv</a> ofrece «TV en una ventana» y captura de imagen/sonido/vídeo.</p></li><li><p><a class=package href=https://cgit.freebsd.org/ports/tree/multimedia/xawtv/>multimedia/xawtv</a>: otra aplicación de TV; ofrece lo mismo que fxtv.</p></li><li><p><a class=package href=https://cgit.freebsd.org/ports/tree/misc/alevt/>misc/alevt</a> decodifica y reproduce videotexto y teletexto.</p></li><li><p><a class=package href=https://cgit.freebsd.org/ports/tree/audio/xmradio/>audio/xmradio</a> permite utilizar el sintonizador de radio FM que incorporan algunas tarjetas de TV.</p></li><li><p><a class=package href=https://cgit.freebsd.org/ports/tree/audio/wmtune/>audio/wmtune</a>, una aplicación de escritorio muy útil para el uso de sintonizadores de radio.</p></li></ul></div><div class=paragraph><p>Hay más aplicaciones útiles en la Colección de de Ports de FreeBSD.</p></div></div><div class=sect3><h4 id=_solución_de_problemas>7.5.4. Solución de problemas<a class=anchor href=#_solución_de_problemas></a></h4><div class=paragraph><p>Si tiene algún problema con su tarjeta de TV compruebe en primer lugar que el chip de captura de vídeo y el sintonizador realmente funcionan con el controlador <a href="https://man.freebsd.org/cgi/man.cgi?query=bktr&amp;sektion=4&amp;format=html">bktr(4)</a> y si ha utilizado las opciones de configuración más adecuadas. Si necesita más ayuda o necesita respuestas sobre su tarjeta de TV puede recurrir a la lista de correo <a href=https://lists.FreeBSD.org/subscription/freebsd-multimedia>Lista de correo sobre multimedia en FreeBSD</a>.</p></div></div></div><div class=sect2><h3 id=scanners>7.6. Escáneres de imágenes<a class=anchor href=#scanners></a></h3><div class=sect3><h4 id=_introducción_2>7.6.1. Introducción<a class=anchor href=#_introducción_2></a></h4><div class=paragraph><p>El acceso a escáneres de imágenes en FreeBSD funciona gracias a la APISANE (siglas de «Scanner Access Now Easy», «el acceso a escáneres ahora es fácil»), disponible en la Colección de Ports de FreeBSD. SANE utiliza también ciertos controladores de FreeBSD para acceder al hardware del escáner.</p></div><div class=paragraph><p>FreeBSD puede utilizar tanto escáneres SCSI como USB. Asegúrese de que el suyo funciona con SANE antes de intentar ningún tipo de configuración. SANE tiene una lista de <a href=http://www.sane-project.org/sane-supported-devices.html>dispositivos soportados</a> donde encontrará información actualizada sobre hasta dónde funciona el escáner y su estatus. La página de manual de <a href="https://man.freebsd.org/cgi/man.cgi?query=uscanner&amp;sektion=4&amp;format=html">uscanner(4)</a> incluye una listas de escáneres USB que funcionan con SANE.</p></div></div><div class=sect3><h4 id=_configuración_del_kernel>7.6.2. Configuración del kernel<a class=anchor href=#_configuración_del_kernel></a></h4><div class=paragraph><p>Como ya se ha dicho tanto los interfaces USB como las SCSI funcionan. Según sea el interfaz de su escáner necesitará un tipo diferente de controlador:</p></div><div class=sect4><h5 id=scanners-kernel-usb>7.6.2.1. Interfaz USB<a class=anchor href=#scanners-kernel-usb></a></h5><div class=paragraph><p>El kernel <span class=filename>GENERIC</span> incluye por omisión los controladores de dispositivo necesarios para poder usar escáneres USB. Si va a personalizar su kernel asegúrese de que esto está en el fichero de configuración del mismo:</p></div><div class="literalblock programlisting"><div class=content><pre>device usb
device uhci
device ohci
device uscanner</pre></div></div><div class=paragraph><p>Según cual sea el chipset de su placa base tendrá que usar <code>device uhci</code> o <code>device ohci</code>, aunque si tiene ambos no tendrá problemas por eso.</p></div><div class=paragraph><p>Si por cualquier motivo no quiere recompilar su kernel y su kernel no es el <span class=filename>GENERIC</span> puede cargar el módulo controlador de dispositivo <a href="https://man.freebsd.org/cgi/man.cgi?query=uscanner&amp;sektion=4&amp;format=html">uscanner(4)</a> con <a href="https://man.freebsd.org/cgi/man.cgi?query=kldload&amp;sektion=8&amp;format=html">kldload(8)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload uscanner</span></code></pre></div></div><div class=paragraph><p>Si quiere cargar este módulo cada vez que arranque el sistema debe añadir la siguiente línea a <span class=filename>/boot/loader.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>uscanner_load=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Tras reiniciar con el kernel correcto (o una vez que el módulo esté cargado) conecte su escáner USB. Debe aparecer en el «buffer» de mensajes del sistema (<a href="https://man.freebsd.org/cgi/man.cgi?query=dmesg&amp;sektion=8&amp;format=html">dmesg(8)</a>) un mensaje una línea como la siguiente:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>uscanner0: EPSON EPSON Scanner, rev 1.10/3.02, addr 2</code></pre></div></div><div class=paragraph><p>La línea del ejemplo muestra que nuestro escáner está utilizando el nodo de dispositivo <span class=filename>/dev/uscanner0</span>.</p></div></div><div class=sect4><h5 id=_interfaz_scsi>7.6.2.2. Interfaz SCSI<a class=anchor href=#_interfaz_scsi></a></h5><div class=paragraph><p>Si su escáner tiene un interfaz SCSI es importante saber qué controladora SCSI incorpora. El chipset SCSI que tenga influirá en la configuración del kernel que tenga que personalizar. El kernel <span class=filename>GENERIC</span> tiene controladores de dispositivo para las controladoras SCSI más comunes. Consulte el fichero <span class=filename>NOTES</span> y añada la línea correcta al fichero de configuración de su kernel. Tendrá que añadir también la siguiente línea:</p></div><div class="literalblock programlisting"><div class=content><pre>device scbus
device pass</pre></div></div><div class=paragraph><p>Una vez compilado e instalado el kernel correctamente tiene ya que ver sus nuevos dispositivos en el «buffer» de mensajes del sistema:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>pass2 at aic0 bus 0 target 2 lun 0
pass2: &lt;AGFA SNAPSCAN 600 1.10&gt; Fixed Scanner SCSI-2 device
pass2: 3.300MB/s transfers</code></pre></div></div><div class=paragraph><p>Si su escáner estaba apagado durante el arranque puede forzar manualmente la detección si ejecuta una búsqueda de buses SCSI con <a href="https://man.freebsd.org/cgi/man.cgi?query=camcontrol&amp;sektion=8&amp;format=html">camcontrol(8)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># camcontrol rescan all</span>
Re-scan of bus 0 was successful
Re-scan of bus 1 was successful
Re-scan of bus 2 was successful
Re-scan of bus 3 was successful</code></pre></div></div><div class=paragraph><p>El escáner aparecerá en la lista de dispositivos SCSI:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># camcontrol devlist</span>
&lt;IBM DDRS-34560 S97B&gt;              at scbus0 target 5 lun 0 <span class=o>(</span>pass0,da0<span class=o>)</span>
&lt;IBM DDRS-34560 S97B&gt;              at scbus0 target 6 lun 0 <span class=o>(</span>pass1,da1<span class=o>)</span>
&lt;AGFA SNAPSCAN 600 1.10&gt;           at scbus1 target 2 lun 0 <span class=o>(</span>pass3<span class=o>)</span>
&lt;PHILIPS CDD3610 CD-R/RW 1.00&gt;     at scbus2 target 0 lun 0 <span class=o>(</span>pass2,cd0<span class=o>)</span></code></pre></div></div><div class=paragraph><p>Tiene todos los detalles sobre los dispositivos SCSI en las páginas de manual de <a href="https://man.freebsd.org/cgi/man.cgi?query=scsi&amp;sektion=4&amp;format=html">scsi(4)</a> y <a href="https://man.freebsd.org/cgi/man.cgi?query=camcontrol&amp;sektion=8&amp;format=html">camcontrol(8)</a>.</p></div></div></div><div class=sect3><h4 id=_configuración_de_sane>7.6.3. Configuración de SANE<a class=anchor href=#_configuración_de_sane></a></h4><div class=paragraph><p>El sistema SANE se divide en dos partes: los «backends» (<a class=package href=https://cgit.freebsd.org/ports/tree/graphics/sane-backends/>graphics/sane-backends</a>) y los «frontends» (<a class=package href=https://cgit.freebsd.org/ports/tree/graphics/sane-frontends/>graphics/sane-frontends</a>). Los «backends» facilitan el acceso al escáner propiamente dicho. La <a href=http://www.sane-project.org/sane-supported-devices.html>lista de dispositivos que funcionan con </a>SANE le dirá qué «backend» hará funcionar su escáner de imágenes. No hay más remedio que identificar correctamente el «backend» de su escáner para poder usarlo. Los «frontends» ofrecen una interfaz gráfica para escanear (xscanimage).</p></div><div class=paragraph><p>Lo primero que hay que hacer es instalar el port o package de <a class=package href=https://cgit.freebsd.org/ports/tree/graphics/sane-backends/>graphics/sane-backends</a>. Después ejecute la orden <code>sane-find-scanner</code> para comprobar el funcionamiento de la detección de escáneres del sistema SANE:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sane-find-scanner -q</span>
found SCSI scanner <span class=s2>&#34;AGFA SNAPSCAN 600 1.10&#34;</span> at /dev/pass3</code></pre></div></div><div class=paragraph><p>En la salida de la orden anterior se le mostrará el tipo de interfaz del escáner y el nodo de dispositivo a través del cual el sistema accede a él. Es posible que no aparezcan la marca y el modelo, pero eso no tiene importancia.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Algunos escáneres USB necesitan que les instale un «firmware»; esto se explica en la página de manual del «backend» correspondiente. También debe leer las páginas de manual <a href="https://man.freebsd.org/cgi/man.cgi?query=sane-find-scanner&amp;sektion=1&amp;format=html">sane-find-scanner(1)</a> y <a href="https://man.freebsd.org/cgi/man.cgi?query=linprocfs&amp;sektion=7&amp;format=html">linprocfs(7)</a>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Ahora hay que comprobar que el «frontend» de escaneo puede identificar el escáner. Por omisión los «backends» de SANE incorporan una herramienta de línea de órdenes llamada <a href="https://man.freebsd.org/cgi/man.cgi?query=sane&amp;sektion=1&amp;format=html">sane(1)</a>, que le mostrará una lista de dispositivos e incluso una captura de imagen desde la shell. La opción <code>-L</code> muestra una lista de escáners:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># scanimage -L</span>
device <span class=sb>`</span>snapscan:/dev/pass3<span class=s1>&#39; is a AGFA SNAPSCAN 600 flatbed scanner</span></code></pre></div></div><div class=paragraph><p>Si el software no lanza ningún mensaje, o si el mensaje indica que no se han encontrado escáneres significa que <a href="https://man.freebsd.org/cgi/man.cgi?query=sane&amp;sektion=1&amp;format=html">sane(1)</a> no puede identificar su escáner. Si este es el caso tendrá que editar el fichero de configuración del «backend»y definir en él el escáner que quiera utilizar. Encontrará todos los ficheros de configuración de los «backends» en el directorio <span class=filename>/usr/local/etc/sane.d/</span>. Este problema con la identificación del hardware es relativamente frecuente con ciertos modelos de escáneres USB.</p></div><div class=paragraph><p>Por ejemplo, con el escáner que hemos usado en la <a href=#scanners-kernel-usb>Interfaz USB</a> la orden <code>sane-find-scanner</code> nos da la siguiente información:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sane-find-scanner -q</span>
found USB scanner <span class=o>(</span>UNKNOWN vendor and product<span class=o>)</span> at device /dev/uscanner0</code></pre></div></div><div class=paragraph><p>El escáner ha sido detectado sin problemas, utiliza el interfaz USB y está conectado al nodo de dispositivo <span class=filename>/dev/uscanner0</span> . Ahora comprobaremos que podemos identificar correctamente el escáner:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># scanimage -L</span>

No scanners were identified. If you were expecting something different,
check that the scanner is plugged <span class=k>in</span>, turned on and detected by the
sane-find-scanner tool <span class=o>(</span><span class=k>if </span>appropriate<span class=o>)</span><span class=nb>.</span> Please <span class=nb>read </span>the documentation
which came with this software <span class=o>(</span>README, FAQ, manpages<span class=o>)</span>.</code></pre></div></div><div class=paragraph><p>No hemos podido identificar el escáner, así que hemos de editar el fichero <span class=filename>/usr/local/etc/sane.d/epson.conf</span>. Estamos usando el modelo de escáner EPSON Perfection® 1650, así que ya sabemos que el escáner utilizará el «backend» <code>epson</code>. Lea atentamente los comentarios que hay en los ficheros de configuración de los «backends». Lo que hay que hacer es muy sencillo: basta con comentar las líneas en las que aparecen interfaces que no sean el perfecto para su escáner. En nuestro caso comentaremos todas las líneas que comiencen por <code>scsi</code> puesto que nuestro escáner tiene interfaz USB. Después de esto hay que añadir una lína al final del fichero declarando el interfaz y el nodo de dispositivo que se van a usar. En el caso del ejemplo esto es lo que añadimos:</p></div><div class="literalblock programlisting"><div class=content><pre>usb /dev/uscanner0</pre></div></div><div class=paragraph><p>Por favor, lea los comentarios que encontrará en el fichero de configuración del «backend» y la pángina de manual de del «backend» si necesita más información sobre la sintaxis que debe usar. Hecho esto podemos verificar si ya podemos identificar el escáner:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># scanimage -L</span>
device <span class=sb>`</span>epson:/dev/uscanner0<span class=s1>&#39; is a Epson GT-8200 flatbed scanner</span></code></pre></div></div><div class=paragraph><p>Hemos identificado nuestro escáner USB. Ni tiene importancia si la marca y modelo que hemos visto no coinciden con nuestro escáner. Lo único realmente importante es el campo <code>`epson:/dev/uscanner0'</code>, que nos da el nombre correcto del «backend» y el nodo de dispositivo correcto.</p></div><div class=paragraph><p>Una vez que <code>scanimage -L</code> llega a ver al escáner hemos terminado con la configuración. El dispositivo está listo para escanear imángenes.</p></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=sane&amp;sektion=1&amp;format=html">sane(1)</a> permite ejecutar una captura de imágen desde la línea de órdenes, pero siempre es mejor utilizar un interfaz gráfico de usuario para estas tareas. SANE ofrece un interfaz gráfico simple pero eficiente: xscanimage (<a class=package href=https://cgit.freebsd.org/ports/tree/graphics/sane-frontends/>graphics/sane-frontends</a>).</p></div><div class=paragraph><p>Otro «frontend» gráfico para escanear que se ha hecho muy popular es Xsane (<a class=package href=https://cgit.freebsd.org/ports/tree/graphics/xsane/>graphics/xsane</a>). Este «frontend» tiene características muy avanzadas como varios modos de escaneo (fotocopia, fax, etc.), corrección de color, escaneo de imágenes por lotes, etc. Ambas aplicaciones pueden utilizarse además como «plugins» de GIMP.</p></div></div><div class=sect3><h4 id=_dar_acceso_al_escáner_a_otros_usuarios>7.6.4. Dar acceso al escáner a otros usuarios<a class=anchor href=#_dar_acceso_al_escáner_a_otros_usuarios></a></h4><div class=paragraph><p>Todo lo que se ha mostrado en esta sección se ha ejecutado con privilegios de <code>root</code>. Lo normal es que haya otros usuarios que tengan que tener acceso al escáner. Un usuario que quiera usar el escáner tiene que tener acceso de lectura y escritura al nodo de dispositivo que usa el escáner. Por ejemplo, nuestro escáner USB utiliza el nodo de dispositivo <span class=filename>/dev/uscanner0</span> propiedad del grupo <code>operator</code>. Al añadir al usuario <code><em>joe</em></code> al grupo <code>operator</code> éste podrá acceder al escáner:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pw groupmod operator -m joe</span></code></pre></div></div><div class=paragraph><p>Para más información sobre el uso de <a href="https://man.freebsd.org/cgi/man.cgi?query=pw&amp;sektion=8&amp;format=html">pw(8)</a> lea su página de manual. Tendrá también que configurar correctamente los permisos de escritura (0660 o 0664) en el nodo de dispositivo <span class=filename>/dev/uscanner0</span>; por omisión los miembros del grupo <code>operator</code> sólo tienen acceso de lectura en este nodo de dispositivo. Añada las siguientes líneas al fichero lines to the <span class=filename>/etc/devfs.rules</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>[system=5]
add path uscanner0 mode 660</pre></div></div><div class=paragraph><p>Ahora añada lo siguiente a <span class=filename>/etc/rc.conf</span> y reinicie la máquina:</p></div><div class="literalblock programlisting"><div class=content><pre>devfs_system_ruleset=&#34;system&#34;</pre></div></div><div class=paragraph><p>Para más información sobre lo que acaba de leer consulte la página de manual de <a href="https://man.freebsd.org/cgi/man.cgi?query=devfs&amp;sektion=8&amp;format=html">devfs(8)</a>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Por seguridad debería pensarse dos veces el hecho mismo de añadir cualquier usuario a un grupo y muy especialmente al grupo <code>operator</code>.</p></div></td></tr></tbody></table></div></div></div></div></div><div class=sect1><h2 id=kernelconfig>Capítulo 8. Configuración del kernel de FreeBSD<a class=anchor href=#kernelconfig></a></h2><div class=sectionbody><div class=sect2><h3 id=_sinopsis_2>8.1. Sinopsis<a class=anchor href=#_sinopsis_2></a></h3><div class=paragraph><p>El kernel de FreeBSD es el corazón del sistema operativo. Es el responsable de la gestión y control de la memoria, reforzamiento de los controles de seguridad, gestión de redes, acceso a dispositivos y muchas cosas más. FreeBSD es un sistema dinámico y configurable, pero a veces sigue siendo necesario reconfigurar y recompilar un kernel hecho a la medida de nuestras necesidades.</p></div><div class=paragraph><p>Una vez leido este capítulo sabrá usted:</p></div><div class=ulist><ul><li><p>Por qué puede ser necesario que compile un kernel personalizado.</p></li><li><p>Cómo crear un fichero de configuración del kernel, o bien editar un fichero existente.</p></li><li><p>Cómo utilizar el fichero de configuración para crear y compilar un nuevo kernel.</p></li><li><p>Cómo instalar su nuevo kernel.</p></li><li><p>Cómo resolver algunos problemas si algo sale mal.</p></li></ul></div></div><div class=sect2><h3 id=_qué_razones_hay_para_compilar_un_kernel_personalizado>8.2. ¿Qué razones hay para compilar un kernel personalizado?<a class=anchor href=#_qué_razones_hay_para_compilar_un_kernel_personalizado></a></h3><div class=paragraph><p>Tradicionalmente FreeBSD ha contado con lo que se conoce como un kernel "monolítico". Esto quiere decir que el kernel era un gran y único programa que se comunicaba con una lista previa de dispositivos, y que si se deseaba modificar el comportamiento del kernel se debía compilar un nuevo kernel y reiniciar el sistema con el nuevo kernel.</p></div><div class=paragraph><p>Hoy en día FreeBSD evoluciona muy rápidamente hacia un modelo donde la funcionalidad del kernel se basa en módulos, los cuales pueden cargarse y descargarse dinámicamente de acuerdo a las necesidades del kernel. Esto permite al kernel adaptarse al nuevo hardware que sale al mercado (como las tarjetas PCMCIA en sistemas portátiles), o bien añadir nuevas funcionalidades al kernel que no eran al compilarlo la vez anterior. Esto es lo que conocemos como kernel modular.</p></div><div class=paragraph><p>A pesar de lo dicho aún es necesario llevar a cabo cierta configuración estática en la configuración del kernel. A veces se debe a que la funcionalidad del sistema está tan ligada al kernel que no puede hacerse mediante carga dinámica de módulos. En otros casos puede tratarse simplemente de que nadie ha programado un módulo para esa funcionalidad concreta que pueda cargarse dinámicamente en el kernel.</p></div><div class=paragraph><p>Compilar un kernel personalizado es uno de los ritos de iniciación más importantes a los que los usuarios de casi todos los BSD han de enfrentarse. Este proceso lleva su tiempo, pero le aportará grandes beneficios a su sistema FreeBSD. A diferencia del kernel <span class=filename>GENERIC</span>, con el que puede funcionar una cantidad apabullante de hardware disponible en el mercado, un kernel personalizado contiene únicamente lo necesario para que funcione el hardware de <em>su</em> sistema. Obviamente esto tiene sus ventajas:</p></div><div class=ulist><ul><li><p>Mayor rapidez en el arranque del sistema. Dado que el kernel sólo tiene que probar el hardware que realmente está en el sistema el tiempo que necesitará para arrancar se reducirá visiblemente.</p></li><li><p>Menor uso de memoria. Generalmente un kernel personalizado utiliza menos memoria que un kernel <code>GENERIC</code>, lo cual es importante ya que el kernel debe encontrarse siempre en memoria real. Por ésta razón un kernel personalizado puede ser de gran utilidad en sistemas con una cantidad limitada de memoria RAM.</p></li><li><p>Hacer funcionar hardware específico. Un kernel personalizado le permite añadir al sistema dispositivos como tarjetas de sonido, que no están incluidas en el kernel <code>GENERIC</code>.</p></li></ul></div></div><div class=sect2><h3 id=kernelconfig-devices>8.3. Inventario de hardware del sistema<a class=anchor href=#kernelconfig-devices></a></h3><div class=paragraph><p>Antes de aventurarnos en la configuración del kernel nunca está de más disponer de un inventario completo del hardware que hay en la máquina. En los casos en los que FreeBSD no es el sistema operativo principal de la máquina puede conseguir el inventario consultando la configuración de otro sistema operativo. Por ejemplo, el Gestor de dispositivos de Microsoft® suele contener información importante sobre los dispositivos que haya en la máquina. El Gestor de dispositivos está en el panel de control.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Algunas versiones de Microsoft® Windows® tienen un icono de Sistema con forma de pantalla desde el que se puede acceder al Gestor de dispositivos.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Si no hay otro sistema operativo en la máquina el administrador tendrá que conseguir la información por su cuenta. Una forma de hacerlo es mediante <a href="https://man.freebsd.org/cgi/man.cgi?query=dmesg&amp;sektion=8&amp;format=html">dmesg(8)</a> y <a href="https://man.freebsd.org/cgi/man.cgi?query=man&amp;sektion=1&amp;format=html">man(1)</a>. La mayoría de los controladores de dispositivo que hay en FreeBSD tienen una página de manual, que suele incluir una lista del hardware que puede hacer funcionar. En la prueba del sistema durante el arranque va apareciendo una lista del harware que hay en la máquina. Por ejemplo, las siguientes líneas indican que el controlador <span class=filename>psm</span> ha encontrado un ratón:</p></div><div class="literalblock programlisting"><div class=content><pre>psm0: &lt;PS/2 Mouse&gt; irq 12 on atkbdc0
psm0: [GIANT-LOCKED]
psm0: [ITHREAD]
psm0: model Generic PS/2 mouse, device ID 0</pre></div></div><div class=paragraph><p>Puede añadir este controlador al fichero de configuración de su kernel personalizado o cargarlo utilizando <a href="https://man.freebsd.org/cgi/man.cgi?query=loader.conf&amp;sektion=5&amp;format=html">loader.conf(5)</a>.</p></div><div class=paragraph><p>A veces los datos que muestra <code>dmesg</code> solamente muestran mensajes del sistema en lugar de la salida de la prueba de arranque. En esos casos puede ver la verdadera salida de <code>dmesg</code> en el fichero <span class=filename>/var/run/dmesg.boot</span>.</p></div><div class=paragraph><p>Otro método para identificar el hardware del sistema es usar <a href="https://man.freebsd.org/cgi/man.cgi?query=pciconf&amp;sektion=8&amp;format=html">pciconf(8)</a>, que tiene una salida mucho más verbosa. Veamos un ejemplo:</p></div><div class="literalblock programlisting"><div class=content><pre>ath0@pci0:3:0:0:        class=0x020000 card=0x058a1014 chip=0x1014168c rev=0x01 hdr=0x00
    vendor     = &#39;Atheros Communications Inc.&#39;
    device     = &#39;AR5212 Atheros AR5212 802.11abg wireless&#39;
    class      = network
    subclass   = ethernet</pre></div></div><div class=paragraph><p>Este fragmento, obtenido con <code>pciconf -lv</code> muestra cómo el controlador <span class=filename>ath</span> ha encontrado un dispositivo Ethernet inalámbrico. Escriba <code>man ath</code> para consultar la página de manual de <a href="https://man.freebsd.org/cgi/man.cgi?query=ath&amp;sektion=4&amp;format=html">ath(4)</a>.</p></div><div class=paragraph><p>La opción <code>-k</code> de <a href="https://man.freebsd.org/cgi/man.cgi?query=man&amp;sektion=1&amp;format=html">man(1)</a> le suministrará valiosa información. Sigamos con el ejemplo anterior:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># man -k Atheros</span></code></pre></div></div><div class=paragraph><p>Con esto obtendremos una lista de páginas de manual que contienen esa palabra en particular:</p></div><div class="literalblock programlisting"><div class=content><pre>ath(4)                   - Atheros IEEE 802.11 wireless network driver
ath_hal(4)               - Atheros Hardware Access Layer (HAL)</pre></div></div><div class=paragraph><p>Una vez que tenemos nuestra flamante lista de hardware del sistema el proceso de compilar un kernel personalizado debería parecer un poco menos inquietante.</p></div></div><div class=sect2><h3 id=kernelconfig-modules>8.4. Controladores del kernel, subsistemas y módulos<a class=anchor href=#kernelconfig-modules></a></h3><div class=paragraph><p>Antes de compilar un kernel personalizado conviene pensar antes los motivos. Si lo que se necesita es añadir hardware específico al sistema es posible que sea posible utilizarlo mediante un módulo.</p></div><div class=paragraph><p>Los módulos del kernel están en el directorio <span class=filename>/boot/kernel</span> y se pueden cargar dinámicamente en un kernel en funcionamiento con <a href="https://man.freebsd.org/cgi/man.cgi?query=kldload&amp;sektion=8&amp;format=html">kldload(8)</a>. La mayoría, por no decir todos, los controladores del kernel tienen un módulo específico y una página de manual. Por ejemplo, en la sección anterior hablábamos del controlador Ethernet inalámbrico <span class=filename>ath</span>. La página de manual de este dispositivo contiene la siguiente información:</p></div><div class="literalblock programlisting"><div class=content><pre>Alternatively, to load the driver as a module at boot time, place the
     following line in loader.conf(5):

           if_ath_load=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Si hace lo que dice ahí, es decir, añadir la línea <code>if_ath_load="YES"</code> al fichero <span class=filename>/boot/loader.conf</span> hará que el módulo se cargue dinámicamente cada vez que el sistema arranque.</p></div><div class=paragraph><p>Hay casos, no obstante, en los que no existe el módulo correspondiente. Esto sucede con ciertos subsistemas y con controladores muy importantes, como por ejemplo el de FFS, que necesita el kernel. Igual sucede con la posibilidad de utilizar redes (INET). Por desgracia, en estos casos la única forma de saber si hace falta un controlador es buscar el módulo.</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Es sumamente fácil quitar un dispositivo o una opción del kernel y encontrarse de manos a boca con un kernel que no funciona. Por ejemplo, si elimina el controlador <a href="https://man.freebsd.org/cgi/man.cgi?query=ata&amp;sektion=4&amp;format=html">ata(4)</a> del fichero de configuración del kernel un sistema que utilice unidades de disco ATA no podrá arrancar a menos que se añada la línea correspondiente al fichero <span class=filename>loader.conf</span>. Si tiene dudas busque el módulo y deje el kernel como está.</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=kernelconfig-building>8.5. Compilación e instalación de un kernel personalizado<a class=anchor href=#kernelconfig-building></a></h3><div class=paragraph><p>En primer lugar, hagamos un breve recorrido por el directorio donde se lleva a cabo la compilación del kernel. Todos los directorios mencionados hacen referencia al directorio principal, que es <span class=filename>/usr/src/sys</span>, al que también podemos acceder desde <span class=filename>/sys</span>. Existen gran cantidad de subdirectorios que representan diferentes partes del kernel, pero el más importante para lo que deseamos hacer son <span class=filename>arch</span> y <span class=filename>/conf</span>, que es donde se llevara a cabo la edición del fichero de configuración y la compilación propiamente dicha del mismo, el punto de partida para la personalización del kernel. El directorio <span class=filename>arch</span> representa la arquitectura del sistema, por lo que puede ser <span class=filename>i386</span>, <span class=filename>alpha</span>, <span class=filename>amd64</span>, <span class=filename>ia64</span>, <span class=filename>powerpc</span>, <span class=filename>sparc64</span> o <span class=filename>pc98</span> (una arquitectura alternativa, similar a PC y muy popular en Japón). Todo lo que existe dentro de un directorio de una arquitectura en particular, es específico para dicha arquitectura; el resto del código es común para todas las plataformas en las que FreeBSD puede funcionar. Observe la organización lógica de la estructura de los directorios, con cada dispositivo utilizable en el sistema, sistema de ficheros y opciones, cada cosa en su propio subdirectorio.</p></div><div class=paragraph><p>A lo largo de este capítulo asumiremos que está utilizando la arquitectura i386, puesto que sobre ella son los ejemplos que vamos a ir exponiendo. Si no es este su caso debe hacer los cambios adecuados a su arquitectura de hardware en las rutas que vayamos utilizando.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Si <em>no existe</em> el directorio <span class=filename>/usr/src/sys</span> en su sistema quiere decir que no están instaladas las fuentes del kernel. La forma más sencilla de tenerlas es mediante <code>/stand/sysinstall</code>. Como usuario <code>root</code> seleccione <code>Configure</code>, luego <code>Distributions</code>, después <code>src</code> y finalmente <code>sys</code>. Si no le gusta mucho sysinstall y tiene acceso a un CDROM "oficial" de FreeBSD puede instalar las fuentes por medio de la siguiente línea de órdenes:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount /cdrom</span>
<span class=c># mkdir -p /usr/src/sys</span>
<span class=c># ln -s /usr/src/sys /sys</span>
<span class=c># cat /cdrom/sys/ssys.[a-d]* | tar -xzvf</span></code></pre></div></div></td></tr></tbody></table></div><div class=paragraph><p>Ahora vaya al al directorio <span class=filename>arch/conf</span> y copie el fichero de configuración <span class=filename>GENERIC</span> con el nombre que desee. Por ejemplo:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/src/sys/i386/conf</span>
<span class=c># cp GENERIC MIKERNEL</span></code></pre></div></div><div class=paragraph><p>Por tradición el nombre se escribe con mayúsuculas y si tiene varias maquinas FreeBSD, con diferente hardware es recomendable darle a cada kernel el mismo nombre que la máquina en la que va a ejecutarse. En este ejemplo usaremos el nombre de <span class=filename>MIKERNEL</span> .</p></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Guardar su fichero de configuración directamente bajo el directorio <span class=filename>/usr/src</span>, puede que no sea una idea muy astuta. Si empieza a tener problemas puede ser muy tentador borrar <span class=filename>/usr/src</span> y comenzar desde cero. Cinco segundos después de haber hecho esto se dará cuenta de que ha eliminado el fichero de configuración de su kernel, en el que quizás llevaba horas trabajando.</p></div><div class=paragraph><p>Le proponemos una alternativa: guardar su fichero de configuración cualquier otro sitio y crear un enlace simbólico al fichero que hay en el directorio <span class=filename>i386</span>.</p></div><div class=paragraph><p>Por ejemplo:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/src/sys/i386/conf</span>
<span class=c># mkdir /root/kernels</span>
<span class=c># cp GENERIC /root/kernels/MIKERNEL</span>
<span class=c># ln -s /root/kernels/MIKERNEL</span></code></pre></div></div></td></tr></tbody></table></div><div class=paragraph><p>Ahora edite el fichero de configuración <span class=filename>MIKERNEL</span> con su editor de textos favorito. Si se trata de una instalación reciente probablemente el único editor disponible sea vi, del cual es complicado explicar su uso detallado en este documento, pero existen bastantes libros que detallan su uso; puede ver algunos en la <a href=./#bibliography>bibliografía</a>. FreeBSD dispone de un editor de uso muy sencillo, llamado ee; si es usted principiante le será de mucha ayuda. Cambie los comentarios al principio del fichero con algo que refleje los cambios realizados o al menos para diferenciarlo del fichero <span class=filename>GENERIC</span>.</p></div><div class=paragraph><p>Si ha compilado un kernel en SunOS™ o algún otro sistema operativo BSD seguramente la mayor parte de fichero le será muy familiar. Si viene usted de otros sistemas operativos como DOS, el fichero <span class=filename>GENERIC</span> puede parecerle intimidante, así que siga las instrucciones descritas en <a href=#kernelconfig-config>El Fichero de Configuración</a> detenidamente y con sumo cuidado.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Asegúrese siempre de verificar el fichero <span class=filename>/usr/src/UPDATING</span> antes de realizar cualquier actualización del sistema si ha <a href=./#cutting-edge>sincronizado sus fuentes</a> para disponer de la última versión de los mismos. En el fichero <span class=filename>/usr/src/UPDATING</span> está toda la información importante sobre las actualizaciones. Al distribuirse con FreeBSD dicha información deberá estar más actualizada que la que hay en este mismo texto.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Ahora es momento de llevar a cabo la compilación del código fuente del kernel.</p></div><div class="olist arabic procedure"><div class=title>Procedure: Compilación del kernel</div><ol class=arabic><li><p>Vaya al directorio <span class=filename>/usr/src</span>:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/src</span></code></pre></div></div></li><li><p>Compile el kernel:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># make buildkernel KERNCONF=MIKERNEL</span></code></pre></div></div></li><li><p>Instale el nuevo kernel:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># make installkernel KERNCONF=MIKERNEL</span></code></pre></div></div></li></ol></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Es imprescindible que disponga del código fuente completo de FreeBSD para poder compilar el kernel.</p></div></td></tr></tbody></table></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Por omisión, si compila un kernel personalizado <em>todos</em> los módulos del kernel serán recompilados también. Si quiere que la actualización de su kernel sea mucho más rápida o compilar solamente ciertos módulos personalizados, edite kernel modules will be rebuilt as well. <span class=filename>/etc/make.conf</span> antes de compilar el kernel:</p></div><div class="literalblock programlisting"><div class=content><pre>MODULES_OVERRIDE = linux acpi sound/sound sound/driver/ds1 ntfs</pre></div></div><div class=paragraph><p>Esta variable crea una lista de módulos listos para ser compilados, sin tocar los demás.</p></div><div class="literalblock programlisting"><div class=content><pre>WITHOUT_MODULES = linux acpi sound/sound sound/driver/ds1 ntfs</pre></div></div><div class=paragraph><p>Esta variable crea una lista de módulos que serán excluidos del proceso de compilación. Hay otras variables que pueden resultarle útiles durante este proceso; consulte la página de manual de <a href="https://man.freebsd.org/cgi/man.cgi?query=make.conf&amp;sektion=5&amp;format=html">make.conf(5)</a>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>El nuevo kernel se copiará al directorio raíz como <span class=filename>/kernel</span> y el kernel viejo tendrá el nombre de <span class=filename>/kernel.old</span>. Ahora reinicie su sistema para poder probar su nuevo kernel. En caso de que se presente algun problema hay algunos consejos para la <a href=#kernelconfig-trouble>resolución de problemas</a> al final de este capítulo. Asegúrese de leer la sección que explica cómo recuperar el sistema en caso de que su kernel <a href=#kernelconfig-noboot>no quiera arrancar</a>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Ciertos ficheros relacionados con el proceso de arranque, como <a href="https://man.freebsd.org/cgi/man.cgi?query=loader&amp;sektion=8&amp;format=html">loader(8)</a>y su configuración, se guardan en <span class=filename>/boot</span>. Los módulos personalizados o de terceros se suelen guardar en <span class=filename>/boot/kernel</span>, aunque debe tener presente que es muy importante que los módulos y el kernel estén sincronizados. Si intenta usar módulos con un kernel para el que no están destinados puede haber errores o incluso producirse intesatabilidades.</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=kernelconfig-config>8.6. El fichero de configuración<a class=anchor href=#kernelconfig-config></a></h3><div class=paragraph><p>El formato de un fichero de configuración es bastante simple. Cada línea contiene una palabra clave con uno o más argumentos. Para simplificar, hay muchas líneas que solamente contienen un argumento. Cualquier cosa detrás de un <code>\#</code> se considerará un comentario y en consecuencia será ignorado. Las siguientes secciones describen todas las palabras clave en el orden en el que aparecen en <span class=filename>GENERIC</span>. <a id=kernelconfig-options></a>Si quiere una lista exhaustiva de de opciones dependientes de arquitectura y de dispositivos puede consultar el fichero <span class=filename>NOTES</span> en el mismo directorio donde está el fichero <span class=filename>GENERIC</span>. Si quiere ver las opciones independientes de arquitectura consulte <span class=filename>/usr/src/sys/conf/NOTES</span>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Puede generar un fichero que contenga todas las opciones disponibles en un kernel. Esto es algo que solamente se usa para hacer pruebas. Si quiere generarlo ejecute, como <code>root</code>, lo siguiente:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/src/sys/i386/conf &amp;&amp; make LINT</span></code></pre></div></div></td></tr></tbody></table></div><div class=paragraph><p>A continuación veremos un ejemplo de fichero de configuración de un kernel <span class=filename>GENERIC</span> al que se han añadido comentarios adicionales donde se ha visto que era necesario abundar un poco para mayor claridad. Este ejemplo es igual (o, en el peor de los casos, casi igual) que la copia del mismo que tiene usted en <span class=filename>/usr/src/sys/i386/conf/GENERIC</span>.</p></div><div class="literalblock programlisting"><div class=content><pre>machine		i386</pre></div></div><div class=paragraph><p>Esta es la arquitectura de la máquina. Debe ser <code>alpha</code>, <code>amd64</code>, <code>i386</code>, <code>ia64</code>, <code>pc98</code>, <code>powerpc</code> o <code>sparc64</code>.</p></div><div class="literalblock programlisting"><div class=content><pre>cpu          I486_CPU
cpu          I586_CPU
cpu          I686_CPU</pre></div></div><div class=paragraph><p>Las opciones anteriores definen el tipo de CPU que haya en su sistema. Puede dejar varias líneas de CPU (si, por ejemplo, no está seguro de usar <code>I586_CPU</code> o <code>I686_CPU</code>), pero si está personalizando su kernel es mucho mejor que solamente ponga la CPU que tenga. Si no está seguro de la CPU que tiene busque en los mensajes de arranque que se guardan en <span class=filename>/var/run/dmesg.boot</span>.</p></div><div class="literalblock programlisting"><div class=content><pre>ident          GENERIC</pre></div></div><div class=paragraph><p>Este es el identificador del kernel. Modifíquelo para que cuadre con el nombre que le haya dado a su kernel, es decir, <code>MIKERNEL</code> si ha seguido los ejemplos anteriores. El valor que asigne a la cadena <code>ident</code> será el que se muestre cuando arranque con su kernel, así que es útil darle a su kernel un nombre distintivo que permita distinguirlo fácilmente de otros, por ejemplo, si está compilando un kernel experimental.</p></div><div class="literalblock programlisting"><div class=content><pre>#To statically compile in device wiring instead of /boot/device.hints
#hints          &#34;GENERIC.hints&#34;         # Default places to look for devices.</pre></div></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=device.hints&amp;sektion=5&amp;format=html">device.hints(5)</a> se usa para configurar opciones de controladores de dispositivo. La ubicación por defecto en la que <a href="https://man.freebsd.org/cgi/man.cgi?query=loader&amp;sektion=8&amp;format=html">loader(8)</a> buscará durante el arranque es <span class=filename>/boot/device.hints</span>. Si usa la opción <code>hints</code> puede compilar el contenido de <span class=filename>device.hints</span> en su kernel, lo que hará innecesario crear ese fichero en <span class=filename>/boot</span>.</p></div><div class="literalblock programlisting"><div class=content><pre>makeoptions     DEBUG=-g          # Build kernel with gdb(1) debug symbols</pre></div></div><div class=paragraph><p>El proceso normal de compilación en FreeBSD incluye información de depuración de errores si se compila un kernel con la opción <code>-g</code>, que activa la información de depuración de errores al pasar a <a href="https://man.freebsd.org/cgi/man.cgi?query=gcc&amp;sektion=1&amp;format=html">gcc(1)</a>.</p></div><div class="literalblock programlisting"><div class=content><pre>options          SCHED_4BSD         # 4BSD scheduler</pre></div></div><div class=paragraph><p>El planificador de tareas tradicional y por omisión de FreeBSD. Déjelo como está.</p></div><div class="literalblock programlisting"><div class=content><pre>options          PREEMPTION         # Enable kernel thread preemption</pre></div></div><div class=paragraph><p>Permite que hilos que están en el kernel puedan asociarse con hilos cuya prioridad sea más alta. Ayuda con la interactividad y permite que los hilos interrumpidos puedan ejecutarse antes en lugar de tener que esperar.</p></div><div class="literalblock programlisting"><div class=content><pre>options          INET              # InterNETworking</pre></div></div><div class=paragraph><p>Networking. Deje esto como está, incluso si no tiene en mente conectar la máquina a una red. Muchos programas necesitan al menos disponer de lo que se llama «loopback networking» (esto es, poder efectuar conexiones de red con su propia máquina) así que tener esto es obligatorio.</p></div><div class="literalblock programlisting"><div class=content><pre>options          INET6             # IPv6 communications protocols</pre></div></div><div class=paragraph><p>Activa los protocolos de comunicación IPv6.</p></div><div class="literalblock programlisting"><div class=content><pre>options          FFS               # Berkeley Fast Filesystem</pre></div></div><div class=paragraph><p>El sistema de ficheros básico para discos duros. Debe dejarlo como está si pretende poder arrancar desde disco duro.</p></div><div class="literalblock programlisting"><div class=content><pre>options          SOFTUPDATES       # Enable FFS Soft Updates support</pre></div></div><div class=paragraph><p>Activa Soft Updates en el kernel, lo que acelerará los accesos de escritura a sus discos. Esta funcionalidad la facilita el kernel, pero debe activarse para cada disco de forma específica. Revise la salida de <a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a> y verá si Soft Updates está activado en los discos de su sistema. Si no aparece la opción <code>soft-updates</code> actívela mediante <a href="https://man.freebsd.org/cgi/man.cgi?query=tunefs&amp;sektion=8&amp;format=html">tunefs(8)</a> (para sistemas de ficheros ya existentes) o <a href="https://man.freebsd.org/cgi/man.cgi?query=newfs&amp;sektion=8&amp;format=html">newfs(8)</a> (en el caso de sistemas de ficheros nuevos).</p></div><div class="literalblock programlisting"><div class=content><pre>options          UFS_ACL           # Support for access control lists</pre></div></div><div class=paragraph><p>Esta opción activa en el kernel las listas de control de acceso. Consiste en el uso de atributos extendidos y UFS2 junto con las características que se describen detalladamente en la <a href=./#fs-acl>Listas de control de acceso a sistemas de ficheros</a>. Las ACL por omisión están activadas, y no deben desactivarse del kernel una vez que hayan sido usadas en un sistema de ficheros puesto que eliminará las listas de control de acceso y el modo en el que se protegen esos ficheros de un modo totalmente fuera de control.</p></div><div class="literalblock programlisting"><div class=content><pre>options          UFS_DIRHASH       # Improve performance on big directories</pre></div></div><div class=paragraph><p>This option includes functionality to speed up disk operations on large directories, at the expense of using additional memory. You would normally keep this for a large server, or interactive workstation, and remove it if you are using FreeBSD on a smaller system where memory is at a premium and disk access speed is less important, such as a firewall.</p></div><div class="literalblock programlisting"><div class=content><pre>options          MD_ROOT           # MD is a potential root device</pre></div></div><div class=paragraph><p>Esta opción permite que la partición raíz esté en un disco virtual basado en memoria.</p></div><div class="literalblock programlisting"><div class=content><pre>options          NFSCLIENT         # Network Filesystem Client
options          NFSSERVER         # Network Filesystem Server
options          NFS_ROOT          # NFS usable as /, requires NFSCLIENT</pre></div></div><div class=paragraph><p>NFS, el sistema de ficheros en red. Salvo que tenga intención de montar particiones de sistemas de ficheros UNIX® de un servidor a través de TCP/IP puede comentar estas opciones.</p></div><div class="literalblock programlisting"><div class=content><pre>options          MSDOSFS           # MSDOS Filesystem</pre></div></div><div class=paragraph><p>El sistema de ficheros MS-DOS®. Salvo que tenga en mente montar particiones de disco duro con formato DOS durante el arranque puede comentar esta opción. En caso de necesidad esta funcionalidad se cargará automáticamente. También tiene a su <a class=package href=https://cgit.freebsd.org/ports/tree/emulators/mtools/>emulators/mtools</a>, que le permitirá acceder a disquetes DOS sin tener que montarlos y desmontarlos (y ni siquiera requiere <code>MSDOSFS</code>).</p></div><div class="literalblock programlisting"><div class=content><pre>options          CD9660            # ISO 9660 Filesystem</pre></div></div><div class=paragraph><p>El sistema de ficheros ISO 9660 para CDROM. Coméntelo si no tiene unidad CDROM o solamente monta CD muy de vez en cuando; cuando lo necesite el sistema lo cargará dinámicamente. Los CD de sonido no utilizan este sistema de ficheros.</p></div><div class="literalblock programlisting"><div class=content><pre>options          PROCFS            # Process filesystem (requires PSEUDOFS)</pre></div></div><div class=paragraph><p>El sistema de ficheros de procesos. Es un sistema de ficheros "simulado" que se monta en <span class=filename>/proc</span> y permite a programas como <a href="https://man.freebsd.org/cgi/man.cgi?query=ps&amp;sektion=1&amp;format=html">ps(1)</a> suministrar más información sobre qué procesos están ejecutándose. En la mayoaría de los casos no es necesario usar <code>PROCFS</code>, puesto que la mayoría de las herramientas de monitorización y depuración han sido adaptadas para que funcionen sin <code>PROCFS</code>. De hecho aunque lo instale el sistema no lo montará por omisión.</p></div><div class="literalblock programlisting"><div class=content><pre>options          PSEUDOFS          # Pseudo-filesystem framework</pre></div></div><div class=paragraph><p>Los kernel 6.X pueden usar <code>PSEUDOFS</code> al utilizar <code>PROCFS</code>.</p></div><div class="literalblock programlisting"><div class=content><pre>options          GEOM_GPT          # GUID Partition Tables.</pre></div></div><div class=paragraph><p>Con esta opción se puede tener una gran cantidad de particiones en un único disco.</p></div><div class="literalblock programlisting"><div class=content><pre>options          COMPAT_43         # Compatible with BSD 4.3 [KEEP THIS!]</pre></div></div><div class=paragraph><p>Compatibilidad con 4.3BSD. Déjelo como está; ciertos programas pueden comportarse de formas muy extrañas si comenta esta opción.</p></div><div class="literalblock programlisting"><div class=content><pre>options          COMPAT_FREEBSD4   # Compatible with FreeBSD4</pre></div></div><div class=paragraph><p>FreeBSD 5.X en sistemas i386™ y Alpha necesita esta opción para poder usar aplicaciones compiladas en versiones antiguas de FreeBSD que utilizan, por tanto, llamadas al sistema más antiguas. Esta opción no es necesaria en plataformas en las que funciona FreeBSD desde 5.X, como ia64 y sparc64.</p></div><div class="literalblock programlisting"><div class=content><pre>options          COMPAT_FREEBSD5   # Compatible with FreeBSD5</pre></div></div><div class=paragraph><p>Esta opción hace falta en sistemas FreeBSD 6.X y versiones posteriores para poder ejecutar aplicaciones compiladas en FreeBSD 5.X, que usan interfaces de llamada al sistema FreeBSD 5.X.</p></div><div class="literalblock programlisting"><div class=content><pre>options          SCSI_DELAY=5000  # Delay (in ms) before probing SCSI</pre></div></div><div class=paragraph><p>Hace que el kernel haga una pausa de 5 segundos antes de probar los dispositivos SCSI del sistema. Si solamente tiene discos IDE puede ignorar esta opción, o también puede asignarle un valor menos para evitar el retardo en el arranque. Si lo hace y FreeBSD tiene problemas para reconocer dispositivos SCSI en el sistema es obvio que tendrá que incrementar el valor.</p></div><div class="literalblock programlisting"><div class=content><pre>options          KTRACE            # ktrace(1) support</pre></div></div><div class=paragraph><p>Activa las trazas en el kernel, algo muy útil para la depuración de errores.</p></div><div class="literalblock programlisting"><div class=content><pre>options          SYSVSHM           # SYSV-style shared memory</pre></div></div><div class=paragraph><p>Facilita memoria compartida System V. El uso más habitual es la extensión XSHM de X, que utiliza la mayoría de programas que hacen uso intensivo de los gráficos para incrementar la velocidad. Si usa X es casi seguro que le vendrá bien esta opción.</p></div><div class="literalblock programlisting"><div class=content><pre>options          SYSVMSG           # SYSV-style message queues</pre></div></div><div class=paragraph><p>Mensajes System V. Esta opción añade solamente unos cuantos bytes al kernel.</p></div><div class="literalblock programlisting"><div class=content><pre>options          SYSVSEM           # SYSV-style semaphores</pre></div></div><div class=paragraph><p>Semáforos System V. No es demasiado frecuente que se utilicen, pero solamente añaden unos cuantos cientos de bytes al kernel.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>La opción <code>-p</code> de <a href="https://man.freebsd.org/cgi/man.cgi?query=ipcs&amp;sektion=1&amp;format=html">ipcs(1)</a> le mostrará una lista de procesos que estén utilizando características System V.</p></div></td></tr></tbody></table></div><div class="literalblock programlisting"><div class=content><pre>options 	     _KPOSIX_PRIORITY_SCHEDULING # POSIX P1003_1B real-time extensions</pre></div></div><div class=paragraph><p>Extensiones en tiempo real añadidas en 1993 POSIX®. Ciertas aplicaciones de la Colección de Ports las utilizan, por ejemplo StarOffice™.</p></div><div class="literalblock programlisting"><div class=content><pre>options          KBD_INSTALL_CDEV  # install a CDEV entry in /dev</pre></div></div><div class=paragraph><p>This option is required to allow the creation of keyboard device nodes in <span class=filename>/dev</span>.</p></div><div class="literalblock programlisting"><div class=content><pre>options          ADAPTIVE_GIANT    # Giant mutex is adaptive.</pre></div></div><div class=paragraph><p>Giant es un mecanismo de exclusión mutua («sleep mutex») que protege un gran conjunto de recursos del kernel. Hoy en dia no es asumible tener un cuello de botella así por el impacto que tiene en el rendimiento, así que está siendo reemplazado por bloqueos que protegen los recursos de manera individual. <code>ADAPTIVE_GIANT</code> hace que Giant sea incluido en un conjunto de «mutextes» que va rotando Esto es, cuando un hilo quiere bloquear el Giant mutex (pero ya está bloqueado por un hilo de otra CPU) el primer hilo seguirá ejecutándose a la espera de que se libere el bloqueo. Generalmente el hilo volverá al estado de reposo y esperará hasta que aparezca otra oportunidad de ejecutarse. Si no está seguro de lo que está haciendo es mejor que deje esta opción tal y como está.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Tenga en cuenta que en FreeBSD 8.0-CURRENT y versiones siguientes todos los «mutexes» son adaptables por omisión, salvo que se use la opción <code>NO_ADAPTIVE_MUTEXES</code>. El resultado evidente que es Giant es adaptable por omisión, así que la opción <code>ADAPTIVE_GIANT</code> ha sido eliminada de la configuración.</p></div></td></tr></tbody></table></div><div class="literalblock programlisting"><div class=content><pre>device          apic               # I/O APIC</pre></div></div><div class=paragraph><p>El dispositivo apic activa la E/S APIC en la entrega de interrupciones. El dispositivo apic puede usarse tanto en kernels para un procesador (UP) como para sistemas multiprocesador (SMP). Si añada <code>options SMP</code> funcionará en sistemas multiprocesador.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>El dispositivo apic existe solamente en la arquitectura i386, de modo que no debe usarse esta línea en otras arquitecturas.</p></div></td></tr></tbody></table></div><div class="literalblock programlisting"><div class=content><pre>device          eisa</pre></div></div><div class=paragraph><p>Use esta opción si tiene una placa base EISA. Activa la detección automática y permite la configuración de todos los dispositivos que estén en el bus EISA.</p></div><div class="literalblock programlisting"><div class=content><pre>device          pci</pre></div></div><div class=paragraph><p>Use esta opción si tiene una placa PCI. Permite la detección automática de tarjetas PCI y permite la configuración entre el bus ISA y el PCI.</p></div><div class="literalblock programlisting"><div class=content><pre># Floppy drives
device          fdc</pre></div></div><div class=paragraph><p>Este dispositivo es el controlador de la unidad de disquetes.</p></div><div class="literalblock programlisting"><div class=content><pre># ATA and ATAPI devices
device          ata</pre></div></div><div class=paragraph><p>Este controlador permite utilizar dispositivos ATA y ATAPI. Si añade al kernel one <code>device ata</code> éste detectará cualquier dispositivo ATA/ATAPI PCI que conecte a una máquina moderna.</p></div><div class="literalblock programlisting"><div class=content><pre>device          atadisk                 # ATA disk drives</pre></div></div><div class=paragraph><p>Si usa <code>device ata</code> tendrá que añadir también esto para poder usar unidades de disco ATA.</p></div><div class="literalblock programlisting"><div class=content><pre>device          ataraid                 # ATA RAID drives</pre></div></div><div class=paragraph><p>Si usa <code>device ata</code> tendrá que añadir también esto para poder usar unidades de disco ATA RAID.</p></div><div class="literalblock programlisting"><div class=content><pre>device          atapicd                 # ATAPI CDROM drives</pre></div></div><div class=paragraph><p>Si usa <code>device ata</code> tendrá que añadir también esto para poder usar unidades ATAPI CDROM.</p></div><div class="literalblock programlisting"><div class=content><pre>device          atapifd                 # ATAPI floppy drives</pre></div></div><div class=paragraph><p>Si usa <code>device ata</code> tendrá que añadir también esto para poder usar unidades de disquete ATAPI.</p></div><div class="literalblock programlisting"><div class=content><pre>device          atapist                 # ATAPI tape drives</pre></div></div><div class=paragraph><p>Si usa <code>device ata</code> tendrá que añadir también esto para poder usar unidades de cinta ATAPI.</p></div><div class="literalblock programlisting"><div class=content><pre>options         ATA_STATIC_ID           # Static device numbering</pre></div></div><div class=paragraph><p>Con esta opción hace que el número de controladores sea estático; si no se usa los números de dispositivo se asignan dinámicamente.</p></div><div class="literalblock programlisting"><div class=content><pre># SCSI Controllers
device          ahb        # EISA AHA1742 family
device          ahc        # AHA2940 and onboard AIC7xxx devices
options         AHC_REG_PRETTY_PRINT    # Print register bitfields in debug
                                        # output.  Adds ~128k to driver.
device          ahd        # AHA39320/29320 and onboard AIC79xx devices
options         AHD_REG_PRETTY_PRINT    # Print register bitfields in debug
                                        # output.  Adds ~215k to driver.
device          amd        # AMD 53C974 (Teckram DC-390(T))
device          isp        # Qlogic family
#device         ispfw      # Firmware for QLogic HBAs- normally a module
device          mpt        # LSI-Logic MPT-Fusion
#device         ncr        # NCR/Symbios Logic
device          sym        # NCR/Symbios Logic (newer chipsets + those of `ncr&#39;)
device          trm        # Tekram DC395U/UW/F DC315U adapters

device          adv        # Advansys SCSI adapters
device          adw        # Advansys wide SCSI adapters
device          aha        # Adaptec 154x SCSI adapters
device          aic        # Adaptec 15[012]x SCSI adapters, AIC-6[23]60.
device          bt         # Buslogic/Mylex MultiMaster SCSI adapters

device          ncv        # NCR 53C500
device          nsp        # Workbit Ninja SCSI-3
device          stg        # TMC 18C30/18C50</pre></div></div><div class=paragraph><p>Controladoras SCSI. Coméntelas si no las tiene en su sistema. Si en su sistema tiene solamente unidades IDE puede borrarlas todas. Las líneas <code>*_REG_PRETTY_PRINT</code> son opciones de depuración de errores de sus respectivos controladores de dispositivo.</p></div><div class="literalblock programlisting"><div class=content><pre># SCSI peripherals
device          scbus      # SCSI bus (required for SCSI)
device          ch         # SCSI media changers
device          da         # Direct Access (disks)
device          sa         # Sequential Access (tape etc)
device          cd         # CD
device          pass       # Passthrough device (direct SCSI access)
device          ses        # SCSI Environmental Services (and SAF-TE)</pre></div></div><div class=paragraph><p>Periféricos SCSI. Estos también puede borrarlos sin problemas si no los tiene en su sistema o si solamente tiene hardware IDE.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>El controlador USB <a href="https://man.freebsd.org/cgi/man.cgi?query=umass&amp;sektion=4&amp;format=html">umass(4)</a> (y unos cuantos controladores más) utilizan el subsistema SCSI aunque no sean dispositivos SCSI reales. No elimine el subsistema SCSI del kernel si va a utilizar cualquiera de estos controladores.</p></div></td></tr></tbody></table></div><div class="literalblock programlisting"><div class=content><pre># RAID controllers interfaced to the SCSI subsystem
device          amr        # AMI MegaRAID
device          arcmsr     # Areca SATA II RAID
device          asr        # DPT SmartRAID V, VI and Adaptec SCSI RAID
device          ciss       # Compaq Smart RAID 5*
device          dpt        # DPT Smartcache III, IV - See NOTES for options
device          hptmv      # Highpoint RocketRAID 182x
device          rr232x     # Highpoint RocketRAID 232x
device          iir        # Intel Integrated RAID
device          ips        # IBM (Adaptec) ServeRAID
device          mly        # Mylex AcceleRAID/eXtremeRAID
device          twa        # 3ware 9000 series PATA/SATA RAID

# RAID controllers
device          aac        # Adaptec FSA RAID
device          aacp       # SCSI passthrough for aac (requires CAM)
device          ida        # Compaq Smart RAID
device          mfi        # LSI MegaRAID SAS
device          mlx        # Mylex DAC960 family
device          pst        # Promise Supertrak SX6000
device          twe        # 3ware ATA RAID</pre></div></div><div class=paragraph><p>Controladoras RAID que pueden utilizarse en FreeBSD. Si no las tiene en su sistema puede borrarlas.</p></div><div class="literalblock programlisting"><div class=content><pre># atkbdc0 controls both the keyboard and the PS/2 mouse
device          atkbdc     # AT keyboard controller</pre></div></div><div class=paragraph><p>El controlador de teclado (<code>atkbdc</code>) ofrece servicios de E/S con teclados AT y ratones PS/2. El controlador de teclado (<code>atkbd</code>) y el controlador de ratón PS/2 (<code>psm</code>) necesitan este dispositivo.</p></div><div class="literalblock programlisting"><div class=content><pre>device          atkbd      # AT keyboard</pre></div></div><div class=paragraph><p>El controlador <code>atkbd</code>, junto con el controlador <code>atkbdc</code>, permiten utilizar el teclado AT 84 u otros tipos de teclados AT mejorados que se conecten mediante el controlador de teclado AT.</p></div><div class="literalblock programlisting"><div class=content><pre>device          psm        # PS/2 mouse</pre></div></div><div class=paragraph><p>Utilice este dispositivo si conecta su ratón en el puerto PS/2.</p></div><div class="literalblock programlisting"><div class=content><pre>device          kbdmux        # keyboard multiplexer</pre></div></div><div class=paragraph><p>Funcionalidad básica para múltiples teclados. Si no tiene en mente usar más de un teclado en el sistema puede borrar esta línea sin mayor problema.</p></div><div class="literalblock programlisting"><div class=content><pre>device          vga        # VGA video card driver</pre></div></div><div class=paragraph><p>El controlador de la tarjeta gráfica.</p></div><div class="literalblock programlisting"><div class=content><pre>device          splash     # Splash screen and screen saver support</pre></div></div><div class=paragraph><p>«Splash screen» en el arranque. Los salvapantallas necesitan este dispositivo.</p></div><div class="literalblock programlisting"><div class=content><pre># syscons is the default console driver, resembling an SCO console
device          sc</pre></div></div><div class=paragraph><p><code>sc</code> por omisión es el controlador de dispositivo de la consola; se parece mucho a una consola de SCO. Dado que muchos programas de pantalla completa acceden a la consola a través de la biblioteca de bases de datos de terminal <span class=filename>termcap</span> no tiene demasiada importancia si usa <code>vt</code>, el controlador de consola compatible <code>VT220</code>. Cuando acceda al sistema asigne a su variable <code>TERM</code> el valor <code>scoansi</code> si los programas a pantalla completa tienen algún problema para acceder a la consola.</p></div><div class="literalblock programlisting"><div class=content><pre># Enable this for the pcvt (VT220 compatible) console driver
#device          vt
#options         XSERVER          # support for X server on a vt console
#options         FAT_CURSOR       # start with block cursor</pre></div></div><div class=paragraph><p>El controlador de dispositivo VT220-compatible; es compatible con VT100/102, anterior a él. Funciona bien en ciertos sistemas portátiles que adolecen de incompatibilidad de harware con <code>sc</code>. Asigne a su variable de entorno <code>TERM</code> el valor <code>vt100</code> o <code>vt220</code> cuando acceda al sistema. Este controlador le puede ser de utilidad si tiene que acceder a gran cantidad de máquinas a través de una red, una situación en la que suele suceder que <span class=filename>termcap</span> o <span class=filename>terminfo</span> no están ahí para que las use <code>sc</code>. <code>vt100</code>, por el contrario, debería aparecer en práticamente cualquier plataforma.</p></div><div class="literalblock programlisting"><div class=content><pre>device          agp</pre></div></div><div class=paragraph><p>Utilice esta opción si tiene en el sistema una tarjeta AGP. Activará AGP y también AGP GART si su tarjeta puede usarla.</p></div><div class="literalblock programlisting"><div class=content><pre># Power management support (see NOTES for more options)
#device          apm</pre></div></div><div class=paragraph><p>Gestión avanzada de la energía. Muy útil en sistemas portátiles. Viene desactivada por omisión en el kernel <span class=filename>GENERIC</span> .</p></div><div class="literalblock programlisting"><div class=content><pre># Add suspend/resume support for the i8254.
device           pmtimer</pre></div></div><div class=paragraph><p>Controlador del reloj para eventos de gestión de la energía, como APM y ACPI.</p></div><div class="literalblock programlisting"><div class=content><pre># PCCARD (PCMCIA) support
# PCMCIA and cardbus bridge support
device          cbb               # cardbus (yenta) bridge
device          pccard            # PC Card (16-bit) bus
device          cardbus           # CardBus (32-bit) bus</pre></div></div><div class=paragraph><p>Dispositivos PCMCIA. Si el sistema es portátil necesita tener esto activado.</p></div><div class="literalblock programlisting"><div class=content><pre># Serial (COM) ports
device          sio               # 8250, 16[45]50 based serial ports</pre></div></div><div class=paragraph><p>Estos son los puertos serie a los que se conoce como puertos <span class=filename>COM</span> en entornos MS-DOS®/Windows®.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Si tiene un módem interno en <span class=filename>COM4</span> un puerto serie en <span class=filename>COM2</span> tendrá que asignar a la IRQ del módem el 2 (por razones técnicas ignotas IRQ2 = IRQ 9) para que pueda acceder al dispositivo desde FreeBSD. Si tiene una tarjeta serie multipuerto consulte la página de manual de <a href="https://man.freebsd.org/cgi/man.cgi?query=sio&amp;sektion=4&amp;format=html">sio(4)</a> si quiere más detalles sobre los valores que debe añadir a <span class=filename>/boot/device.hints</span>. Algunas tarjetas gráficas (sobre todo las que usan chips S3) utilizan direcciones IO del tipo <code>0x*2e8</code> y dado que muchas tarjetas serie de baja calidad no decodifican correctamente el espacio de direcciones de 16 bits chocan con estas tarjetas, haciendo que el puerto <span class=filename>COM4</span> sea prácticamente inútil.</p></div><div class=paragraph><p>Es necesario que cada puerto serie tenga una IRQ única (salvo que use una tarjeta multipuerto que permita compartir interrupciones), así que las IRQ de <span class=filename>COM3</span> y de <span class=filename>COM4</span> no se pueden utilizar.</p></div></td></tr></tbody></table></div><div class="literalblock programlisting"><div class=content><pre># Parallel port
device          ppc</pre></div></div><div class=paragraph><p>El interfaz del puerto paralelo de bus ISA.</p></div><div class="literalblock programlisting"><div class=content><pre>device          ppbus      # Parallel port bus (required)</pre></div></div><div class=paragraph><p>El bus del puerto paralelo.</p></div><div class="literalblock programlisting"><div class=content><pre>device          lpt        # Printer</pre></div></div><div class=paragraph><p>Permite usar el puerto paralelo para conectar impresoras.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Necesitará disponer de los tres anteriores para poder utilizar impresoras mediante el puerto paralelo.</p></div></td></tr></tbody></table></div><div class="literalblock programlisting"><div class=content><pre>device          plip       # TCP/IP over parallel</pre></div></div><div class=paragraph><p>Este controlador es para la interfaz de red a través del puerto paralelo.</p></div><div class="literalblock programlisting"><div class=content><pre>device          ppi        # Parallel port interface device</pre></div></div><div class=paragraph><p>La E/S de propósito general (conocida también como "puerto geek") + E/S IEEE1284.</p></div><div class="literalblock programlisting"><div class=content><pre>#device         vpo        # Requires scbus and da</pre></div></div><div class=paragraph><p>Este dispositivo se usa con unidades Iomega Zip. Necesita <code>scbus</code> y <code>da</code> . El mejor rendimiento se alcanza con el uso de los puertos en modo EPP 1.9.</p></div><div class="literalblock programlisting"><div class=content><pre>#device         puc</pre></div></div><div class=paragraph><p>Puede utilizar este dispositivo si tiene una tarjeta PCI "tonta" (por puerto serie o paralelo) que funcione mediante el controlador <a href="https://man.freebsd.org/cgi/man.cgi?query=puc&amp;sektion=4&amp;format=html">puc(4)</a>.</p></div><div class="literalblock programlisting"><div class=content><pre># PCI Ethernet NICs.
device          de         # DEC/Intel DC21x4x (Tulip)
device          em         # Intel PRO/1000 adapter Gigabit Ethernet Card
device          ixgb       # Intel PRO/10GbE Ethernet Card
device          txp        # 3Com 3cR990 (Typhoon)
device          vx         # 3Com 3c590, 3c595 (Vortex)</pre></div></div><div class=paragraph><p>Diversos controladores para tarjetas de red PCI. Puede borrar todas las que no estén en su sistema.</p></div><div class="literalblock programlisting"><div class=content><pre># PCI Ethernet NICs that use the common MII bus controller code.
# NOTE: Be sure to keep the &#39;device miibus&#39; line in order to use these NICs!
device          miibus     # MII bus support</pre></div></div><div class=paragraph><p>El poder utilizar bus MII es necesario para ciertas tarjetas Ethernet PCI 10/100, más concretamente las que usan transceptores compatibles con MII o implementan interfaces de control de transceptores que funcionan como si fueran MII. Si incluye <code>device miibus</code> al kernel dispondrá de la API miibus genérica y todos los controladores PHY, incluyendo uno que hará funcionar hardware que, siendo del tipo PHY, no está bajo ninguno de los controladores PHY específicos.</p></div><div class="literalblock programlisting"><div class=content><pre>device          bce        # Broadcom BCM5706/BCM5708 Gigabit Ethernet
device          bfe        # Broadcom BCM440x 10/100 Ethernet
device          bge        # Broadcom BCM570xx Gigabit Ethernet
device          dc         # DEC/Intel 21143 and various workalikes
device          fxp        # Intel EtherExpress PRO/100B (82557, 82558)
device          lge        # Level 1 LXT1001 gigabit ethernet
device          msk        # Marvell/SysKonnect Yukon II Gigabit Ethernet
device          nge        # NatSemi DP83820 gigabit ethernet
device          nve        # nVidia nForce MCP on-board Ethernet Networking
device          pcn        # AMD Am79C97x PCI 10/100 (precedence over &#39;lnc&#39;)
device          re         # RealTek 8139C+/8169/8169S/8110S
device          rl         # RealTek 8129/8139
device          sf         # Adaptec AIC-6915 (Starfire)
device          sis        # Silicon Integrated Systems SiS 900/SiS 7016
device          sk         # SysKonnect SK-984x &amp; SK-982x gigabit Ethernet
device          ste        # Sundance ST201 (D-Link DFE-550TX)
device          stge       # Sundance/Tamarack TC9021 gigabit Ethernet
device          ti         # Alteon Networks Tigon I/II gigabit Ethernet
device          tl         # Texas Instruments ThunderLAN
device          tx         # SMC EtherPower II (83c170 EPIC)
device          vge        # VIA VT612x gigabit ethernet
device          vr         # VIA Rhine, Rhine II
device          wb         # Winbond W89C840F
device          xl         # 3Com 3c90x (Boomerang, Cyclone)</pre></div></div><div class=paragraph><p>Controladores que utilizan el código del controlador de bus MII.</p></div><div class="literalblock programlisting"><div class=content><pre># ISA Ethernet NICs.  pccard NICs included.
device          cs         # Crystal Semiconductor CS89x0 NIC
# &#39;device ed&#39; requires &#39;device miibus&#39;
device          ed         # NE[12]000, SMC Ultra, 3c503, DS8390 cards
device          ex         # Intel EtherExpress Pro/10 and Pro/10+
device          ep         # Etherlink III based cards
device          fe         # Fujitsu MB8696x based cards
device          ie         # EtherExpress 8/16, 3C507, StarLAN 10 etc.
device          lnc        # NE2100, NE32-VL Lance Ethernet cards
device          sn         # SMC&#39;s 9000 series of Ethernet chips
device          xe         # Xircom pccard Ethernet

# ISA devices that use the old ISA shims
#device         le</pre></div></div><div class=paragraph><p>Controladores Ethernet ISA. Consulte <span class=filename>/usr/src/sys/i386/conf/NOTES</span> para más detalles sobre qué tarjetas hace funcionar qué controlador.</p></div><div class="literalblock programlisting"><div class=content><pre># Wireless NIC cards
device          wlan            # 802.11 support</pre></div></div><div class=paragraph><p>802.11 genérico. Necesitará esta línea si va a usar redes inalámbricas.</p></div><div class="literalblock programlisting"><div class=content><pre>device          wlan_wep        # 802.11 WEP support
device          wlan_ccmp       # 802.11 CCMP support
device          wlan_tkip       # 802.11 TKIP support</pre></div></div><div class=paragraph><p>Criptografía en dispositivos 802.11. Necesita estas líneas si quiere utilizar criptografía y protocolos de seguridad 802.11.</p></div><div class="literalblock programlisting"><div class=content><pre>device          an         # Aironet 4500/4800 802.11 wireless NICs.
device          ath             # Atheros pci/cardbus NIC&#39;s
device          ath_hal         # Atheros HAL (Hardware Access Layer)
device          ath_rate_sample # SampleRate tx rate control for ath
device          awi        # BayStack 660 and others
device          ral        # Ralink Technology RT2500 wireless NICs.
device          wi         # WaveLAN/Intersil/Symbol 802.11 wireless NICs.
#device         wl         # Older non 802.11 Wavelan wireless NIC.</pre></div></div><div class=paragraph><p>Diversas tarjetas inalámbricas.</p></div><div class="literalblock programlisting"><div class=content><pre># Pseudo devices
device   loop          # Network loopback</pre></div></div><div class=paragraph><p>El dispositivo de «loopback» para TCP/IP. Si accede por telnet o FTP or FTP to <code>localhost</code> también conocido como <code>127.0.0.1</code>) lo hará a través de este dispositivo. Es <em>imprescindible</em> tenerlo en el sistema.</p></div><div class="literalblock programlisting"><div class=content><pre>device   random        # Entropy device</pre></div></div><div class=paragraph><p>Generador de números criptográficamente seguro.</p></div><div class="literalblock programlisting"><div class=content><pre>device   ether         # Ethernet support</pre></div></div><div class=paragraph><p><code>ether</code> solo es necesario si tiene alguna tarjeta Ethernet. Incluye código genérico del protocolo Ethernet.</p></div><div class="literalblock programlisting"><div class=content><pre>device   sl            # Kernel SLIP</pre></div></div><div class=paragraph><p><code>sl</code> permite utilizar SLIP. Ha sido sustituido casi totalmente por PPP, que es más fácil de usar, está mejor capacitado para la conexión de módem a módem y es, en general, claramente mejor.</p></div><div class="literalblock programlisting"><div class=content><pre>device   ppp           # Kernel PPP</pre></div></div><div class=paragraph><p>Este dispositivo incluye en el kernel la capacidad de gestionar conexiones de llamada entrante «dial-up». Hay también una versión de PPP implementada como aplicación de usuario; utiliza <code>tun</code> y ofrece más flexibilidad y características como la llamada bajo petición.</p></div><div class="literalblock programlisting"><div class=content><pre>device   tun           # Packet tunnel.</pre></div></div><div class=paragraph><p>Este dispositivo lo usa el software PPP de usuario. Consulte la sección sobre <a href=./#userppp>PPP</a> de este mismo libro.</p></div><div class="literalblock programlisting"><div class=content><pre>device   pty           # Pseudo-ttys (telnet etc)</pre></div></div><div class=paragraph><p>Este dispositivo es una "pseudoterminal", o un puerto de entrada al sistema simulado. Se usa en sesiones entrantes de <code>telnet</code> y <code>rlogin</code>; también lo usan xterm y otras aplicaciones, entre las que encontramos a Emacs.</p></div><div class="literalblock programlisting"><div class=content><pre>device   md            # Memory disks</pre></div></div><div class=paragraph><p>Pseudodispositivos de disco basados en memoria.</p></div><div class="literalblock programlisting"><div class=content><pre>device   gif           # IPv6 and IPv4 tunneling</pre></div></div><div class=paragraph><p>Este dispositivo implementa túneles de IPv6 sobre IPv4, IPv4 sobre IPv6, IPv4 sobre IPv4 e IPv6 sobre IPv6. El dispositivo <code>gif</code> se puede clonar a sí mismo, así que los nodos de dispositivo se van creando a medida que van haciendo falta.</p></div><div class="literalblock programlisting"><div class=content><pre>device   faith         # IPv6-to-IPv4 relaying (translation)</pre></div></div><div class=paragraph><p>Este pseudodispositivo captura paquetes que se le hayan enviado y los dirige hacia el dæmon de traducción IPv4/IPv6.</p></div><div class="literalblock programlisting"><div class=content><pre># The `bpf&#39; device enables the Berkeley Packet Filter.
# Be aware of the administrative consequences of enabling this!
# Note that &#39;bpf&#39; is required for DHCP.
device   bpf           # Berkeley packet filter</pre></div></div><div class=paragraph><p>El filtro de paquetes de Berkeley. Este pseudodispositivo permite poner interfaces de red en modo promíscuo, lo que significa que capturan todos los paquetes que circulen por una red broadcast (por ejemplo una Ethernet). Dichos paquetes pueden guardarse en disco para su posterior examen mediante <a href="https://man.freebsd.org/cgi/man.cgi?query=tcpdump&amp;sektion=1&amp;format=html">tcpdump(1)</a> (el análisis con <a href="https://man.freebsd.org/cgi/man.cgi?query=tcpdump&amp;sektion=1&amp;format=html">tcpdump(1)</a> no puede hacerse directamente también).</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>El dispositivo <a href="https://man.freebsd.org/cgi/man.cgi?query=bpf&amp;sektion=4&amp;format=html">bpf(4)</a> también lo usa <a href="https://man.freebsd.org/cgi/man.cgi?query=dhclient&amp;sektion=8&amp;format=html">dhclient(8)</a> para obtener direcciones IP del encaminador (gateway) por omisión. Si usa DHCP deje esta opción como está.</p></div></td></tr></tbody></table></div><div class="literalblock programlisting"><div class=content><pre># USB support
device          uhci          # UHCI PCI-&gt;USB interface
device          ohci          # OHCI PCI-&gt;USB interface
device          ehci          # EHCI PCI-&gt;USB interface (USB 2.0)
device          usb           # USB Bus (required)
#device         udbp          # USB Double Bulk Pipe devices
device          ugen          # Generic
device          uhid          # Human Interface Devices
device          ukbd          # Keyboard
device          ulpt          # Printer
device          umass         # Disks/Mass storage - Requires scbus and da
device          ums           # Mouse
device          ural          # Ralink Technology RT2500USB wireless NICs
device          urio          # Diamond Rio 500 MP3 player
device          uscanner      # Scanners
# USB Ethernet, requires mii
device          aue           # ADMtek USB Ethernet
device          axe           # ASIX Electronics USB Ethernet
device          cdce          # Generic USB over Ethernet
device          cue           # CATC USB Ethernet
device          kue           # Kawasaki LSI USB Ethernet
device          rue           # RealTek RTL8150 USB Ethernet</pre></div></div><div class=paragraph><p>Diversos dispositivos USB.</p></div><div class="literalblock programlisting"><div class=content><pre># FireWire support
device          firewire      # FireWire bus code
device          sbp           # SCSI over FireWire (Requires scbus and da)
device          fwe           # Ethernet over FireWire (non-standard!)</pre></div></div><div class=paragraph><p>Diversos dispositivos Firewire.</p></div><div class=paragraph><p>Tiene más información y una lista con más dispositivos que funcionan en FreeBSD consulte <span class=filename>/usr/src/sys/i386/conf/NOTES</span>.</p></div><div class=sect3><h4 id=_configuraciones_con_grandes_cantidades_de_memoria_pae>8.6.1. Configuraciones con grandes cantidades de memoria (PAE)<a class=anchor href=#_configuraciones_con_grandes_cantidades_de_memoria_pae></a></h4><div class=paragraph><p>Las máquinas que tienen configuraciones con grandes cantidades de memoria necesitan acceder a más de 4 gigabytes de espacio de direcciones KVA (User+Kernel Virtual Address). Debido a esta limitación Intel añadió a las CPU Pentium® Pro y modelos posteriores la posibilidad de acceso al espacio de direcciones físicas de 36 bits.</p></div><div class=paragraph><p>PAE (Physical Address Extension) a las CPU Intel® Pentium® Pro y los modelos posteriores configuraciones de memoria de hasta 64 gigabytes. Para poder aprovechar esto en FreeBSD existe la opción del kernel <code>PAE</code>, disponible en todas las versiones modernas de FreeBSD. A causa de esta limitación de memoria en los Intel no hay nada que distinga de algún modo la memoria situada por debajo del límite de los 4 gigabytes. La memoria que esté por encima de los 4 gigabytes se coloca en el «pool» de memoria disponible.</p></div><div class=paragraph><p>Si quiere activar PAE en el kernel tiene que añadir la siguiente liínea al fichero de configuración del kernel:</p></div><div class="literalblock programlisting"><div class=content><pre>options		    PAE</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>En FreeBSD PAE solamente existe en procesadores Intel® IA-32. Hemos de advertirle de que PAE no ha sido probado todo lo necesario, así que debe considerarse de calidad beta, sobre todo si se le compara con otras características de FreeBSD.</p></div></td></tr></tbody></table></div><div class=paragraph><p>PAE en FreeBSD tiene varias limitaciones:</p></div><div class=ulist><ul><li><p>Un solo proceso no puede acceder a más de 4 gigabytes de espacio VM.</p></li><li><p>No puede cargar módulos KLD en un kernel que tenga PAE activado debido a las diferencias existentes entre el «framework» de compilación del módulo y el del kernel mismo.</p></li><li><p>Los controladores de dispositivo que utilizan el interfaz <a href="https://man.freebsd.org/cgi/man.cgi?query=bus_dma&amp;sektion=9&amp;format=html">bus_dma(9)</a> pueden provocar corrupción de datos en un kernel con PAE activado, una excelente razón para no utilizarlos. Esta es la razón de que FreeBSD incorpore un fichero de configuración de un kernel <span class=filename>PAE</span> del que se han extraído todos los módulos que se sabe que no funcionan en un kernel con PAE activado.</p></li><li><p>Algunos «system tunables» determinan el uso de recursos de memoria basándose en la memoria física disponible. Estos «tunables» pueden asignar más memoria de la que realmente debieran debido a que el sistema PAE está íntimamente ligado a cantidades bastante importantes de memoria. Un ejemplo de esto es la sysctl <code>kern.maxvnodes</code>, que controla el número máximo de vnodes permitidos en el kernel. Le recomendamos que ajuste este y otros tunables dentro valores razonables.</p></li><li><p>Es posible que tenga que aumentar el espacio virtual de direcciones del kernel (el KVA) o reducir la cantidad de recursos exclusivos del kernel que se utilicen exhaustivamente (ver más arriba) para evitar que KVA literalmente se ahogue. La opción del kernel <code>KVA_PAGES</code> permite incrementar el espacio KVA.</p></li></ul></div><div class=paragraph><p>Si quiere saber más sobre la estabilidad del sistema consulte la página de manual de <a href="https://man.freebsd.org/cgi/man.cgi?query=tuning&amp;sektion=7&amp;format=html">tuning(7)</a>. La página de manual de <a href="https://man.freebsd.org/cgi/man.cgi?query=pae&amp;sektion=4&amp;format=html">pae(4)</a> contiene información actualizada sobre PAE y FreeBSD.</p></div></div></div><div class=sect2><h3 id=kernelconfig-trouble>8.7. Qué hacer si algo va mal<a class=anchor href=#kernelconfig-trouble></a></h3><div class=paragraph><p>Hay cuatro categorías de problemas que podemos encontrarnos en el proceso de compilación de un kernel personalizado:</p></div><div class=dlist><dl><dt class=hdlist1>Fallo de <code>config</code></dt><dd><p>Si <a href="https://man.freebsd.org/cgi/man.cgi?query=config&amp;sektion=8&amp;format=html">config(8)</a> falla cuando le pasa la descripción de su kernel seguramente ha cometido algún pequeño error. Por suerte <a href="https://man.freebsd.org/cgi/man.cgi?query=config&amp;sektion=8&amp;format=html">config(8)</a> les mostrará el número de la línea que le está dando problemas, así que no tendrá mayor problema para localizarla. Veamos un ejemplo:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>config: line 17: syntax error</code></pre></div></div><div class=paragraph><p>Si ve algo así asegúrese de que ha tecleado la palabra clave que hay en esa lína. Compare la de su fichero de configuración del kernel con la de <span class=filename>GENERIC</span>.</p></div></dd><dt class=hdlist1>Fallo de <code>make</code></dt><dd><p>If the <code>make</code> command fails, it usually signals an error in your kernel description which is not severe enough for <a href="https://man.freebsd.org/cgi/man.cgi?query=config&amp;sektion=8&amp;format=html">config(8)</a> to catch. Again, look over your configuration, and if you still cannot resolve the problem, send mail to the <a href=mailto:http://lists.freebsd.org/mailman/listinfo/freebsd-questions>lista de correo para preguntas generales sobre FreeBSD</a> with your kernel configuration, and it should be diagnosed quickly.</p><div class=dlist><dl><dt class=hdlist1>El kernel no arranca:<a id=kernelconfig-noboot></a></dt><dd><p>Si su nuevo kernel no arranca o no reconoce sus dispositivos de hardware no desespere. FreeBSD dispone de excelentes mecanismos de recuperación ante kernels defectuosos. Elija el kernel con el que quiere arrancar en el gestor de arranque de FreeBSD. Puede acceder al gestor de arranque en el momento en el que aparece el menú de arranque. Elija la opción número seis, "Escape to a loader prompt" option, Escriba en el prompt <code>unload kernel</code> y después escriba <code>boot /boot/kernel.old/kernel</code>, o el nombre de cualquier otro kernel que tenga en el sistema y del que sepa que puede fiarse. Si va a reconfigurar un kernel es una buenísima idea guardar un kernel que sepa que funciona.</p><div class=paragraph><p>Tras arrancar con un kernel de fiar verifique el fichero de configuración e intente de nuevo una compilación. El fichero <span class=filename>/var/log/messages</span> es una fuente de información muy valiosa puesto que registra, entre otras cosas, todos los mensajes que deja el kernel cada vez que hay un arranque satisfactorio. <a href="https://man.freebsd.org/cgi/man.cgi?query=dmesg&amp;sektion=8&amp;format=html">dmesg(8)</a> le mostrará los mensajes que el kernel ha generado durante el último arranque.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Si tiene problemas compilando un kernel recuerde que es de vital importancia que guarde una copia de un kernel <span class=filename>GENERIC</span> u otro del que pueda fiarse y que (esto es muy importante) tenga un nombre distinto de <span class=filename>kernel.old</span> para evitar que el sistema lo borre una vez que termine una nueva compilación. No puede confiar en su kernel <span class=filename>kernel.old</span> porque al instalar un nuevo kernel (que aún no sabe si será el que funcione tal y como espera de él) el kernel <span class=filename>kernel.old</span> se sobreescribe con el kernel que instale. Otra cosa importante es que copie ese kernel de fiar a <span class=filename>/boot/kernel</span>, o ciertas herramientas como <a href="https://man.freebsd.org/cgi/man.cgi?query=ps&amp;sektion=1&amp;format=html">ps(1)</a> no funcionarán. Basta con que haga lo siguiente:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mv /boot/kernel /boot/kernel.malo</span>
<span class=c># mv /boot/kernel.bueno /boot/kernel</span></code></pre></div></div></td></tr></tbody></table></div></dd></dl></div></dd><dt class=hdlist1>El kernel funciona, pero <a href="https://man.freebsd.org/cgi/man.cgi?query=ps&amp;sektion=1&amp;format=html">ps(1)</a> no</dt><dd><p>Si el kernel que tiene instalado es de una versión de FreeBSD y las utilidades del sistema son de otra, por ejemplo un kernel -CURRENT en una -RELEASE, hay muchas herramientas de monitorización del sistema como <a href="https://man.freebsd.org/cgi/man.cgi?query=ps&amp;sektion=1&amp;format=html">ps(1)</a> y <a href="https://man.freebsd.org/cgi/man.cgi?query=vmstat&amp;sektion=8&amp;format=html">vmstat(8)</a> no funcionarán. Ejecute un <a href=./#makeworld>make buildworld y un make install world</a> con la misma versión de código fuente con la que ha compilado su kernel. Esta es una de las razones por las que no es una idea demasiado buena utilizar versiones diferentes de kernel y de sistema operativo.</p></dd></dl></div></div></div></div><div class=sect1><h2 id=printing>Capítulo 9. Imprimir<a class=anchor href=#printing></a></h2><div class=sectionbody><div class=sect2><h3 id=_sinopsis_3>9.1. Sinopsis<a class=anchor href=#_sinopsis_3></a></h3><div class=paragraph><p>FreeBSD puede utilizarse para imprimir en una gran variedad de impresoras, desde las antiguas impresoras de matriciales hasta las más modernas impresoras laser y todo lo que existe entre unas y otras, con lo que podrá imprimir con una calidad muy alta desde cualquier aplicación.</p></div><div class=paragraph><p>FreeBSD puede usarse también como servidor de impresión en red; FreeBSD puede recibir peticiones de impresión de una gran cantidad de sistemas, bien sean FreeBSD, Windows® y Mac OS®. FreeBSD se encarga de los trabajos se vayan imprimiendo uno tras otro y puede mantener estadísticas sobre qué usuarios y qué máquinas están imprimiendo más, generar páginas de «encabezado» para colocarlas antes de cada trabajo y distinguir así de quién es la impresión, etc.</p></div><div class=paragraph><p>Tras leer el presente capítulo sabrá usted:</p></div><div class=ulist><ul><li><p>Cómo configurar la cola de impresión en FreeBSD.</p></li><li><p>Cómo instalar filtros de impresión para gestionar diversos trabajos especiales como la conversión de documentos a formatos aptos para su impresora.</p></li><li><p>Cómo habilitar encabezados en sus impresiones.</p></li><li><p>Cómo imprimir en impresoras conectadas a otras máquinas.</p></li><li><p>Cómo imprimir en impresoras conectadas directamente a la red.</p></li><li><p>Cómo controlar restricciones de impresión, como por ejemplo limitaciones del tamaño de trabajos o evitar que ciertos usuarios puedan imprimir.</p></li><li><p>Cómo mantener estadísticas de impresión y cuentas de usuario de impresión.</p></li><li><p>Cómo solucionar los problemas de impresión más comunes.</p></li></ul></div><div class=paragraph><p>Antes de leer este capítulo usted debería:</p></div><div class=ulist><ul><li><p>Saber cómo compilar e instalar un kernel personalizado (<a href=./#kernelconfig>Configuración del kernel de FreeBSD</a>).</p></li></ul></div></div><div class=sect2><h3 id=printing-intro-spooler>9.2. Introducción<a class=anchor href=#printing-intro-spooler></a></h3><div class=paragraph><p>Si quiere utilizar impresoras con FreeBSD debe configurarlas de forma que funcionen con el sistema de cola de impresión de Berkeley, también conocido como sistema de cola LPD. Es el sistema de control de impresión estándar en FreeBSD. Este capítulo trata sobre el sistema LPD, al que en adelante nos referiremos simplemente como LPD, y le introducirá en la configuración del mismo.</p></div><div class=paragraph><p>Si está familiarizado con el sistema de cola de impresión LPD, o bien con algún otro sistema de impresión, puede pasar a la sección <a href=#printing-intro-setup>Configuración del sistema de cola de impresión</a>.</p></div><div class=paragraph><p>LPD se encarga de controlar todo lo relacionado con la impresión, lo que en consecuencia implica encargarse de lo siguiente:</p></div><div class=ulist><ul><li><p>Controlar el acceso a las impresoras conectadas directamente al sistema y a impresoras conectadas a otras máquinas de la red.</p></li><li><p>Permitir que ciertos usuarios puedan enviar ficheros para su impresión; estos envíos reciben el nombre de <em>trabajos</em> ("jobs").</p></li><li><p>Evita que usuarios diferentes accedan a la impresora al mismo tiempo manteniendo un orden estricto en la cola de impresión de cada impresora.</p></li><li><p>Imprimir <em>encabezados</em> de forma que los usuarios puedan distinguir fácilmente los trabajos que han impreso.</p></li><li><p>Se ocupa de los parámetros para impresoras conectadas a puertos serie.</p></li><li><p>Enviar trabajos de impresión a través de una red a la cola LPD de una máquina remota.</p></li><li><p>Ejecutar filtros especiales para formatear trabajos que requieren la gestión de lenguajes de impresión o impresoras de diferentes características.</p></li><li><p>Mantener un registro del uso de la impresora.</p></li></ul></div><div class=paragraph><p>Gracias al fichero de configuración (<span class=filename>/etc/printcap</span>) y mediante programas especiales de filtrado puede hacerse que el sistema LPD cumpla todas las tareas citadas o si lo prefiere solo unas cuantas; además puede hacerlo en una gran variedad de impresoras.</p></div><div class=sect3><h4 id=printing-intro-why>9.2.1. ¿Por qué utilizar una cola de impresión?<a class=anchor href=#printing-intro-why></a></h4><div class=paragraph><p>Si es usted la única persona que usa el sistema se estará por qué preocuparse de utilizar un sistema de cola de impresión si es evidente que no necesita restricciones de acceso, encabezados ni cuentas de impresión. Puede utilizar el acceso directo a impresión, pero debería utilizar una cola de impresión por las siguientes razones:</p></div><div class=ulist><ul><li><p>El sistema LPD ejecuta los trabajos en segundo plano, esto es, no tiene que esperar a que la impresora procese los datos para seguir trabajando.</p></li><li><p>LPD puede procesar un trabajo de forma que pase por filtros, añadir cabeceras de fecha y hora o convertir un fichero de formato especial (por ejemplo TeX DVI) a un formato que la impresora entienda y que no tenga usted que ocuparse de ello manualmente.</p></li><li><p>Muchos programas, tanto libres como comerciales, desde los que se puede imprimir están hechos pensando en que haya disponible un sistema de impresión. Una vez que configure un sistema de colas podrá utilizar software que ya tiene instalado y preparar el campo para el que instale en el futuro.</p></li></ul></div></div></div><div class=sect2><h3 id=printing-intro-setup>9.3. Configuración básica<a class=anchor href=#printing-intro-setup></a></h3><div class=paragraph><p>Pendiente de traducción.</p></div></div><div class=sect2><h3 id=printing-advanced>9.4. Configuración avanzada de impresoras<a class=anchor href=#printing-advanced></a></h3><div class=paragraph><p>Pendiente de traducción</p></div></div><div class=sect2><h3 id=printing-using>9.5. Cómo utilizar impresoras<a class=anchor href=#printing-using></a></h3><div class=paragraph><p>Pendiente de traducción.</p></div></div><div class=sect2><h3 id=printing-lpd-alternatives>9.6. Alternativas a LPD<a class=anchor href=#printing-lpd-alternatives></a></h3><div class=paragraph><p>Pendiente de traducción</p></div></div><div class=sect2><h3 id=printing-troubleshooting>9.7. Solución de problemas<a class=anchor href=#printing-troubleshooting></a></h3><div class=paragraph><p>Pendiente de traducción</p></div></div></div></div><div class=sect1><h2 id=linuxemu>Capítulo 10. Compatibilidad binaria con Linux<a class=anchor href=#linuxemu></a></h2><div class=sectionbody><div class=sect2><h3 id=linuxemu-synopsis>10.1. Sinopsis<a class=anchor href=#linuxemu-synopsis></a></h3><div class=paragraph><p>FreeBSD proporciona compatibilidad de binarios con muchos otros sistemas operativos tipo UNIX®, incluyendo Linux. Puede estarse preguntando ?por qué necesita FreeBSD ejecutar binarios de Linux? La respuesta a esa pregunta es muy simple. Muchos desarrolladores y compañías desarrollan sólo para Linux, ya que últimamente es el blanco de todas las miradas dentro del mundo de las tecnologís de la información. Esto hace que la comunidad FreeBSD tenga que exigir a esas compañías y desarrolladores que produzcan versiones nativas de sus aplicaciones para FreeBSD. El problema es que la mayoría de esas compañías no suelen saber realmente cuánta gente utilizaría su producto si existieran esas versiones para FreeBSD, y la mayoría continúa desarrollando únicamente para Linux. Vista la situación ?que puede hacer un usuario de FreeBSD? Aquí es donde entra en juego la compatibilidad binaria con Linux.</p></div><div class=paragraph><p>Para expresarlo en pocas palabras, dicha compabitilidad permite a los usuarios de FreeBSD cerca del 90% de las aplicaciones de Linux sin tener que modificarlas en absoluto. Entre estas está StarOffice™, la versión Linux de <a href="https://man.freebsd.org/cgi/man.cgi?query=getenv&amp;sektion=3&amp;format=html">getenv(3)</a>, Adobe® Acrobat®, RealPlayer, VMware, Oracle®, WordPerfect, Doom, Quake y muchas más. En determinados casos los binarios Linux rinden mejor en FreeBSD que en Linux.</p></div><div class=paragraph><p>Existen, por desgracia, ciertas características específicas de Linux que no funcionan en FreeBSD. Los binarios Linux no funcionarán en FreeBSD si recurren a llamadas específicas de i386™ como la activación del modo virtual 8086.</p></div><div class=paragraph><p>Tras leer este capítulo sabrá usted:</p></div><div class=ulist><ul><li><p>cómo activar la compatibilidad binaria con Linux en su sistema.</p></li><li><p>cómo instalar bibliotecas compartidas de Linux que pueda necesitar.</p></li><li><p>cómo instalar aplicaciones de Linux en su sistema FreeBSD.</p></li><li><p>cuáles son los detalles de la implementación de compatibilidad binaria con Linux en FreeBSD.</p></li></ul></div><div class=paragraph><p>Antes de leer este capítulo es necesario que sepa:</p></div><div class=ulist><ul><li><p>cómo instalar software de terceros (<a href=./#ports>Instalación de aplicaciones: «packages» y ports</a>).</p></li></ul></div></div><div class=sect2><h3 id=linuxemu-lbc-install>10.2. Instalación<a class=anchor href=#linuxemu-lbc-install></a></h3><div class=paragraph><p>La compatibilidad binaria con Linux no viene activada por omisión. La forma más sencilla de habilitarla es cargar el KLD ("objeto cargable en el kernel") <code>linux</code>. Como usuario <code>root</code> proceda del siguiente modo:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload linux</span></code></pre></div></div><div class=paragraph><p>Si quiere que la compatibilidad con Linux esté siempre activada tendrá que añadir la siguiente línea en <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>linux_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Utilice <a href="https://man.freebsd.org/cgi/man.cgi?query=kldstat&amp;sektion=8&amp;format=html">kldstat(8)</a> para verificar que el KLD esté cargado:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% kldstat
Id Refs Address    Size     Name
 1    2 0xc0100000 16bdb8   kernel
 7    1 0xc24db000 d000     linux.ko</code></pre></div></div><div class=paragraph><p>Si por alguna razón no desea o no puede cargar el KLD, entonces puede enlazar estáticamente la compatibilidad de binarios Linux en el kernel agregando <code>options COMPAT_LINUX</code> a su fichero de configuración del kernel. Luego instale su nuevo kernel como se describe en <a href=./#kernelconfig>Configuración del kernel de FreeBSD</a>.</p></div><div class=sect3><h4 id=_instalación_de_bibliotecas_de_ejecución_linux>10.2.1. Instalación de bibliotecas de ejecución Linux<a class=anchor href=#_instalación_de_bibliotecas_de_ejecución_linux></a></h4><div class=paragraph><p>Puede hacerse de dos maneras, ya sea usando el port <a href=#linuxemu-libs-port>linux_base</a>, o instalándolas <a href=#linuxemu-libs-manually>de forma manual</a>.</p></div><div class=sect4><h5 id=linuxemu-libs-port>10.2.1.1. Instalación usando el port linux_base<a class=anchor href=#linuxemu-libs-port></a></h5><div class=paragraph><p>Este es con mucho el método mas sencillo para instalar bibliotecas de ejecución. Es como instalar cualquier otro port de la <a href=file://localhost/usr/ports/>Colección de Ports</a>. Es tan sencillo como esto:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/emulators/linux_base</span>
<span class=c># make install distclean</span></code></pre></div></div><div class=paragraph><p>Hecho esto debería disponer de compatibilidad binaria con Linux. Algunos programas pueden "quejarse" por la presencia de versiones antiguas de algunas bibliotecas del sistema. Generalmente esto no suele ser un problema muy grave.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Pueden coexistir múltiples versiones del port <a class=package href=https://cgit.freebsd.org/ports/tree/emulators/linux_base/>emulators/linux_base</a> disponibles correspondientes a distintas versiones de diversas distribuciones de Linux. Tendrá que instalar el port que más se ajuste a las necesidades de las aplicaciones de Linux que quiera instalar.</p></div></td></tr></tbody></table></div></div><div class=sect4><h5 id=linuxemu-libs-manually>10.2.1.2. Instalación manual de bibliotecas<a class=anchor href=#linuxemu-libs-manually></a></h5><div class=paragraph><p>Si, por el motivo que fuese, no tiene instalada la colección de ports puede instalar las bibliotecas que necesite de forma manual. Necesitará las bibliotecas compartidas Linux de las que depende el programa y el enlazador en tiempo de ejecución ("runtime linker"). Necesitará también crear un directorio <span class=filename>/compat/linux</span> donde alojar las bibliotecas Linux en su sistema FreeBSD Cualquier biblioteca compartida a la que haya recurrido un programa de Linux ejecutado en FreeBSD buscará en primer lugar en dicho directorio. Por lo tanto, si se carga un programa Linux, por ejemplo <span class=filename>/lib/libc.so</span>, FreeBSD intentará en primer lugar abrir <span class=filename>/compat/linux/lib/libc.so</span> y, si no existe, lo intentará con <span class=filename>/lib/libc.so</span>. Las bibliotecas compartidas deben instalarse en <span class=filename>/compat/linux/lib</span> en lugar de las rutas que el <code>ld.so</code> de Linux proporcione.</p></div><div class=paragraph><p>En general, necesitará buscar las bibliotecas compartidas de las que los binarios Linux dependen sólamente las primeras veces que instale un programa Linux en su FreeBSD. Más adelante tendrá un conjunto suficiente de bibliotecas compartidas Linux en su sistema para poder ejecutar binarios Linux sin que tenga que hacer nada más.</p></div></div><div class=sect4><h5 id=_cómo_instalar_bibliotecas_compartidas_adicionales>10.2.1.3. Cómo instalar bibliotecas compartidas adicionales<a class=anchor href=#_cómo_instalar_bibliotecas_compartidas_adicionales></a></h5><div class=paragraph><p>?Que pasaría si instalara el port <span class=filename>linux_base</span> y su aplicación todavía tuviera problemas debido a bibliotecas compartidas que no encuentra en el sistema? ?Cómo saber qué bibliotecas compartidas necesitan los binarios Linux? Básicamente hay dos posibilidades (para poder ejecutar las siguientes instrucciones necesitará estar como <code>root</code></p></div><div class=paragraph><p>Si tiene acceso a un sistema Linux busque en él qué bibliotecas necesita la aplicación, y cópielas a su sistema FreeBSD. Veamos unos ejemplos:</p></div><div class=paragraph><p>Asumiremos que utilizó FTP para conseguir los binarios Linux de Doom y los puso en un sistema Linux. Para ver qué bibliotecas compartidas necesitará ejecute <code>ldd linuxdoom</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ldd linuxdoom
libXt.so.3 <span class=o>(</span>DLL Jump 3.1<span class=o>)</span> <span class=o>=&gt;</span> /usr/X11/lib/libXt.so.3.1.0
libX11.so.3 <span class=o>(</span>DLL Jump 3.1<span class=o>)</span> <span class=o>=&gt;</span> /usr/X11/lib/libX11.so.3.1.0
libc.so.4 <span class=o>(</span>DLL Jump 4.5pl26<span class=o>)</span> <span class=o>=&gt;</span> /lib/libc.so.4.6.29</code></pre></div></div><div class=paragraph><p>Necesitaría todos los ficheros de la segunda columna, y tendrá que ponerlos en <span class=filename>/compat/linux</span> con los nombres de la primera columna como enlaces simbólicos apuntando hacia ellos. De este modo tendría en su sistema FreeBSD los siguientes ficheros:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>/compat/linux/usr/X11/lib/libXt.so.3.1.0
/compat/linux/usr/X11/lib/libXt.so.3 -&gt; libXt.so.3.1.0
/compat/linux/usr/X11/lib/libX11.so.3.1.0
/compat/linux/usr/X11/lib/libX11.so.3 -&gt; libX11.so.3.1.0
/compat/linux/lib/libc.so.4.6.29
/compat/linux/lib/libc.so.4 -&gt; libc.so.4.6.29</code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Recuerde que si ya tiene una biblioteca compartida Linux con un número de versión mayor que coincida con la primera columna de la salida de <code>ldd</code> no necesitará copiar el fichero que aparece en la última columna; el que tiene debería funcionar, aunque se aconseja copiar la biblioteca compartida de todas maneras si es una nueva versión. Puede eliminar la vieja siempre que haga que el enlace simbólico apunte a la nueva. Si tiene estas bibliotecas en su sistema:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>/compat/linux/lib/libc.so.4.6.27
/compat/linux/lib/libc.so.4 -&gt; libc.so.4.6.27</code></pre></div></div><div class=paragraph><p>y un binario requiere una versión más reciente (como indica la siguiente salida de <code>ldd</code>):</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>libc.so.4 <span class=o>(</span>DLL Jump 4.5pl26<span class=o>)</span> -&gt; libc.so.4.6.29</code></pre></div></div><div class=paragraph><p>si solo ve una o dos versiones desfasadas en los últimos dígitos no se preocupe de copiar <span class=filename>/lib/libc.so.4.6.29</span>, el programa debería funcionar bien con una versión ligeramente antigua. De todas formas, si así lo prefiere, puede actualizar <span class=filename>libc.so</span>; el resultado sería este:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>/compat/linux/lib/libc.so.4.6.29
/compat/linux/lib/libc.so.4 -&gt; libc.so.4.6.29</code></pre></div></div></td></tr></tbody></table></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>El mecanismo de enlazado simbólico <em>sólamente</em> es necesario con binarios Linux. El enlazador en tiempo de ejecución de FreeBSD se encarga de buscar él mismo las versiones correctas, así que no tendrá que preocuparse usted de hacerlo.</p></div></td></tr></tbody></table></div></div></div><div class=sect3><h4 id=_instalar_binarios_elf_linux>10.2.2. Instalar binarios ELF Linux<a class=anchor href=#_instalar_binarios_elf_linux></a></h4><div class=paragraph><p>Los binarios ELF algunas veces requieren un paso extra de "marcado". Si trata de ejecutar un binario ELF no marcado recibirá un mensaje de error como el siguiente:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ./mi-binario-elf
ELF binary <span class=nb>type </span>not known
Abort</code></pre></div></div><div class=paragraph><p>Para ayudar al kernel de FreeBSD a distinguir entre un binario ELF de FreeBSD y uno de Linux utilice <a href="https://man.freebsd.org/cgi/man.cgi?query=brandelf&amp;sektion=1&amp;format=html">brandelf(1)</a>.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% brandelf <span class=nt>-t</span> Linux mi-binario-elf-de-linux</code></pre></div></div><div class=paragraph><p>Las herramientas GNU se encargan de ubicar automáticamente la marca apropiada en los binarios ELF, por lo tanto este paso será innecesario en un futuro próximo.</p></div></div><div class=sect3><h4 id=_configuración_de_la_resolución_de_nombres_de_equipos>10.2.3. Configuración de la resolución de nombres de equipos<a class=anchor href=#_configuración_de_la_resolución_de_nombres_de_equipos></a></h4><div class=paragraph><p>Si el DNS no funciona u obtiene este mensaje:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>resolv+: <span class=s2>&#34;bind&#34;</span> is an invalid keyword resolv+:
<span class=s2>&#34;hosts&#34;</span> is an invalid keyword</code></pre></div></div><div class=paragraph><p>Necesitará un fichero <span class=filename>/compat/linux/etc/host.conf</span> con el siguiente contenido:</p></div><div class="literalblock programlisting"><div class=content><pre>order hosts, bind
multi on</pre></div></div><div class=paragraph><p>Significa que <span class=filename>/etc/hosts</span> seráanalizado en primer lugar y después se usará DNS. Si <span class=filename>/compat/linux/etc/host.conf</span> no está instalado, las aplicaciones Linux usan el <span class=filename>/etc/host.conf</span> de FreeBSD y chocan con la sintaxis (incompatible) de FreeBSD. Borre <code>bind</code> de su <span class=filename>/etc/resolv.conf</span> si no tiene configurado un servidor de nombres.</p></div></div></div><div class=sect2><h3 id=linuxemu-mathematica>10.3. Instalación de Mathematica®<a class=anchor href=#linuxemu-mathematica></a></h3><div class=paragraph><p>Este documento describe el proceso de instalación de la versión para Linux de Mathematica® 5.X en un sistema FreeBSD.</p></div><div class=paragraph><p>Puede pedir a Wolfram, el fabricante, La versión para para Linux de Mathematica® o la versión de Mathematica® para estudiantes en su sitio web, <a href=http://www.wolfram.com/>http://www.wolfram.com/</a>.</p></div><div class=sect3><h4 id=_el_instalador_de_mathematica>10.3.1. El instalador de Mathematica®<a class=anchor href=#_el_instalador_de_mathematica></a></h4><div class=paragraph><p>Lo primero que tiene que hacer es decirle a FreeBSD que los binarios de Mathematica® para Linux utilizan la ABI Linux. La forma más sencilla de hacerlo es marcar por omisión todos los binarios sin marcas como Linux ELF.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysctl kern.fallback_elf_brand=3</span></code></pre></div></div><div class=paragraph><p>Hecho esto FreeBSD asumirá que cualquier binario sin marca que encuentre utiliza la ABI Linux; de este modo podrá ejecutar el binario directamente desde el CDROM.</p></div><div class=paragraph><p>Copie el fichero <span class=filename>MathInstaller</span> en su disco duro</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount /cdrom</span>
<span class=c># cp /cdrom/Unix/Installers/Linux/MathInstaller /directoriolocal/</span></code></pre></div></div><div class=paragraph><p>Edite este fichero y sustituya la primera línea, <code>/bin/sh</code>, por <code>/compat/linux/bin/sh</code> para asegurarnos de que lo que ejecute el instalador sea la verión de <a href="https://man.freebsd.org/cgi/man.cgi?query=sh&amp;sektion=1&amp;format=html">sh(1)</a> de Linux. El siguiente paso es sustituir todos los <code>Linux)</code> por <code>FreeBSD)</code> con un editor de texto on con el script que encontrará en la siguiente sección. Esto se hace para ayudar al instalador de Mathematica®, el cual en un cierto momento invoca a <code>uname -s</code> para determinar el sistema operativo, a tratar a FreeBSD como si fuera un sistema operativo muy similar a Linux. Hecho todo esto, cuando ejecute <code>MathInstaller</code> podrá instalar Mathematica®.</p></div></div><div class=sect3><h4 id=_modificación_de_los_ejecutables_de_mathematica>10.3.2. Modificación de los ejecutables de Mathematica®<a class=anchor href=#_modificación_de_los_ejecutables_de_mathematica></a></h4><div class=paragraph><p>Debe modificar los scripts de shell que Mathematica® creó durante la instalación antes de usarlos. Si eligió ubicar en <span class=filename>/usr/local/bin</span> los ejecutables de Mathematica® verá que en ese directorio hay enlaces simbólicos a ficheros como <span class=filename>math</span>, <span class=filename>mathematica</span>, <span class=filename>Mathematica</span> y <span class=filename>MathKernel</span>. En cada uno de esos ficheros debe sustituir <code>Linux)</code> por <code>FreeBSD)</code> con un editor de texto o bien con el siguiente script de shell:</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
cd /usr/local/bin
for i in math mathematica Mathematica MathKernel
  do sed &#39;s/Linux)/FreeBSD)/g&#39; $i &gt; $i.tmp
  sed &#39;s/\/bin\/sh/\/compat\/linux\/bin\/sh/g&#39; $i.tmp &gt; $i
  rm $i.tmp
  chmod a+x $i
done</pre></div></div></div><div class=sect3><h4 id=_cómo_obtener_una_contraseña_de_mathematica>10.3.3. Cómo obtener una contraseña de Mathematica®<a class=anchor href=#_cómo_obtener_una_contraseña_de_mathematica></a></h4><div class=paragraph><p>Cuando arranque Mathematica® por primera vez se le pedirá una contraseña. Si Wolfram no le ha enviado ya necesita un "machine ID", para lo cual debe ir al directorio de instalación y ejecutar <code>mathinfo</code>. Este "machine IDE" se obtiene de la dirección MAC de la primera tarjeta Ethernet de la máquina y tiene como objetivo que no pueda ejecutar Mathematica® en más de una máquina.</p></div><div class=paragraph><p>Durante el proceso de registro en Wolfram (ya sea por correo electrónico, teléfono o fax) les dará el "machine ID" y Wolfram le enviará una contraseña relacionada con él, consistente en grupos de números.</p></div></div><div class=sect3><h4 id=_ejecución_del_frontend_de_mathematica_través_de_una_red>10.3.4. Ejecución del «frontend» de Mathematica® través de una red<a class=anchor href=#_ejecución_del_frontend_de_mathematica_través_de_una_red></a></h4><div class=paragraph><p>Mathematica® usa unos cuantos tipos especiales para mostrar caracteres que no están en ningún conjunto estándar de tipos: integrales, sumas, letras griegas, etc. El protocolo X exige que los tipos estén instalados <em>en local</em>, es decir, tiene que copiar los tipos del CDROM o la máquina desde la que ha instalado Mathematica® a su máquina. Los tipos están en el directorio del CDDROM <span class=filename>/cdrom/Unix/Files/SystemFiles/Fonts</span> y se supone que deben estar en su disco duro en el directorio <span class=filename>/usr/local/mathematica/SystemFiles/Fonts</span>. Los tipos están realmente en los subdirectorios <span class=filename>Type1</span> y <span class=filename>X</span>. Hay varias formas de utilizarlos.</p></div><div class=paragraph><p>La primera es copiarlos en uno de los directorios de tipos que hay en <span class=filename>/usr/X11R6/lib/X11/fonts</span>, antes de lo cual tendrá que añadir a <span class=filename>fonts.dir</span> los nombres de los tipos; tendrá también que cambiar el número de tipos en la primera línea. Por otra parte, todo esto puede hacerse ejecutando <a href="https://man.freebsd.org/cgi/man.cgi?query=mkfontdir&amp;sektion=1&amp;format=html">mkfontdir(1)</a> en el directorio donde haya copiado los tipos.</p></div><div class=paragraph><p>La segunda forma de utilizar estos tipos es copiarlos bajo <span class=filename>/usr/X11R6/lib/X11/fonts</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/X11R6/lib/X11/fonts</span>
<span class=c># mkdir X</span>
<span class=c># mkdir MathType1</span>
<span class=c># cd /cdrom/Unix/Files/SystemFiles/Fonts</span>
<span class=c># cp X/* /usr/X11R6/lib/X11/fonts/X</span>
<span class=c># cp Type1/* /usr/X11R6/lib/X11/fonts/MathType1</span>
<span class=c># cd /usr/X11R6/lib/X11/fonts/X</span>
<span class=c># mkfontdir</span>
<span class=c># cd ../MathType1</span>
<span class=c># mkfontdir</span></code></pre></div></div><div class=paragraph><p>Añada los nuevos directorios de tipos a su ruta de tipos:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># xset fp+ /usr/X11R6/lib/X11/fonts/X</span>
<span class=c># xset fp+ /usr/X11R6/lib/X11/fonts/MathType1</span>
<span class=c># xset fp rehash</span></code></pre></div></div><div class=paragraph><p>Si usa el servidor Xorg puede cargar los tipos automáticamente añadiéndolos al fichero <span class=filename>xorg.conf</span>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>En servidores XFree86™ el fichero de configuración es <span class=filename>XF86Config</span>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Si <em>no</em> tiene ya en su sistema un directorio <span class=filename>/usr/X11R6/lib/X11/fonts/Type1</span> puede cambiarle el nombre al directorio <span class=filename>MathType1</span> del ejemplo anterior por <span class=filename>Type1</span>.</p></div></div></div><div class=sect2><h3 id=linuxemu-maple>10.4. Instalación de Maple™<a class=anchor href=#linuxemu-maple></a></h3><div class=paragraph><p>Maple™ es un programa comercial de matemáticas similar a Mathematica®. Puede adquirir este software en <a href=http://www.maplesoft.com/>http://www.maplesoft.com/</a>; tras registrarlo recibirá un fichero de licencia. Si quiere instalar este software en FreeBSD siga los siguienes pasos:</p></div><div class="olist arabic procedure"><ol class=arabic><li><p>Ejecute el "script" de shell <span class=filename>INSTALL</span> desde el lugar de instalación del producto. Elija la opción "RedHat" cuando le pregunte el programa de instalación. <span class=filename>/usr/local/maple</span> es un buen sitio para instalar el software.</p></li><li><p>Si no lo ha hecho ya, solicite una licencia para Maple™ a Maple Waterloo Software (<a href=http://register.maplesoft.com/>http://register.maplesoft.com/</a>) y cópiela a <span class=filename>/usr/local/maple/license/license.dat</span>.</p></li><li><p>Instale el gestor de licencias FLEXlm ejecutando el "script" de shell de instalación <span class=filename>INSTALL_LIC</span> que viene con Maple™. Introduzca el nombre de su máquina (el servidor de licencias lo necesita).</p></li><li><p>Parchée el fichero <span class=filename>/usr/local/maple/bin/maple.system.type</span> con lo siguiente:</p><div class="literalblock programlisting"><div class=content><pre>   ----- snip ------------------
*** maple.system.type.orig      Sun Jul  8 16:35:33 2001
--- maple.system.type   Sun Jul  8 16:35:51 2001
***************
*** 72,77 ****
--- 72,78 ----
          # the IBM RS/6000 AIX case
          MAPLE_BIN=&#34;bin.IBM_RISC_UNIX&#34;
          ;;
+     &#34;FreeBSD&#34;|\
      &#34;Linux&#34;)
          # the Linux/x86 case
        # We have two Linux implementations, one for Red Hat and
   ----- snip end of patch -----</pre></div></div><div class=paragraph><p>Tenga muy presente que después de <code>"FreeBSD"|\</code> no debe haber ningún espacio en blanco.</p></div><div class=paragraph><p>Este parche le dice a Maple™ que interprete "FreeBSD" como un tipo de sistema Linux. El "script" de shell <span class=filename>bin/maple</span> llama al "script" de shell <span class=filename>bin/maple.system.type</span>, que a su vez recurre a <code>uname -a</code> para dictaminar el nombre del sistema operativo. Dependiendo de cuál sea sabrá qué binarios utilizar.</p></div></li><li><p>Inicio del servidor de licencias.</p><div class=paragraph><p>El siguiente "script", sito en <span class=filename>/usr/local/etc/rc.d/lmgrd.sh</span>, le permitirá arrancar <code>lmgrd</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>   ----- snip ------------

#! /bin/sh
PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/usr/X11R6/bin
PATH=${PATH}:/usr/local/maple/bin:/usr/local/maple/FLEXlm/UNIX/LINUX
export PATH

LICENSE_FILE=/usr/local/maple/license/license.dat
LOG=/var/log/lmgrd.log

case &#34;$1&#34; in
start)
	lmgrd -c ${LICENSE_FILE} 2&lt;&lt; ${LOG} 1&lt;&amp;2
	echo -n &#34; lmgrd&#34;
	;;
stop)
	lmgrd -c ${LICENSE_FILE} -x lmdown 2&lt;&lt; ${LOG} 1&lt;&amp;2
	;;
*)
	echo &#34;Usage: `basename $0` {start|stop}&#34; 1&lt;&amp;2
	exit 64
	;;
esac

exit 0
   ----- snip ------------</pre></div></div></li><li><p>Prueba de arranque de Maple™:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>cd</span> /usr/local/maple/bin
% ./xmaple</code></pre></div></div><div class=paragraph><p>Todo debería funcionar perfectamente. Si es así aún le queda un último paso: escribir a Maplesoft y decirles que sería genial una versión nativa para FreeBSD.</p></div></li></ol></div><div class=sect3><h4 id=_problemas_frecuentes>10.4.1. Problemas frecuentes<a class=anchor href=#_problemas_frecuentes></a></h4><div class=ulist><ul><li><p>El gestor de licencias FLEXlm puede ser un tanto difícil de usar. En caso de necesitarla tiene más información en <a href=http://www.globetrotter.com/>http://www.globetrotter.com/</a>.</p></li><li><p><code>lmgrd</code> tiene una reconocida fama de ser muy meticuloso en todo lo relacionado con el fichero de licencia; suele generar volcados de memoria si se encuentra con algún problema. Un fichero de licencia correcto tiene que parecerse mucho a este:</p><div class="literalblock programlisting"><div class=content><pre># =======================================================
# License File for UNIX Installations (&#34;Pointer File&#34;)
# =======================================================
SERVER chillig ANY
#USE_SERVER
VENDOR maplelmg

FEATURE Maple maplelmg 2000.0831 permanent 1 XXXXXXXXXXXX \
         PLATFORMS=i86_r ISSUER=&#34;Waterloo Maple Inc.&#34; \
         ISSUED=11-may-2000 NOTICE=&#34; Technische Universitat Wien&#34; \
         SN=XXXXXXXXX</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>El número de serie y la clave han sido sobreescritos con X. <code>chillig</code> es el nombre de un equipo.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Puede editar el fichero de licencia siempre que no toque la línea "FEATURE" (que está protegida por la clave de la licencia).</p></div></li></ul></div></div></div><div class=sect2><h3 id=linuxemu-matlab>10.5. Instalación de MATLAB®<a class=anchor href=#linuxemu-matlab></a></h3><div class=paragraph><p>Este documento describe el proceso de instalación de la versión para Linux de MATLAB® version 6.5 en FreeBSD. En general funciona bastante bien, excepción hecha de Java Virtual Machine™ (consulte la <a href=#matlab-jre>Enlace del entorno de ejecución Java™</a>).</p></div><div class=paragraph><p>La versión Linux de MATLAB® puede pedirse directamente en el sitio de The MathWorks, <a href=http://www.mathworks.com>http://www.mathworks.com</a>. Tiene que recibir también el fichero de licencia o instrucciones de cómo crearlo. Al hacer su pedido aproveche para decirles que sería muy buena idea que ofrecieran una versión nativa de su software para FreeBSD.</p></div><div class=sect3><h4 id=_instalación_de_matlab>10.5.1. Instalación de MATLAB®<a class=anchor href=#_instalación_de_matlab></a></h4><div class=paragraph><p>Para instalar MATLAB® haga lo siguiente:</p></div><div class="olist arabic procedure"><ol class=arabic><li><p>Inserte el CD de instalación y móntelo. Conviértase en <code>root</code> e inicie la instalación:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /compat/linux/bin/sh /cdrom/install</span></code></pre></div></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>El instalador es gráfico. Si obtiene errores acerca de no ser capaz de abrir un display teclée <code>setenv HOME ~USUARIO</code>, donde <em>USUARIO</em> es el nombre del usuario con el que hizo <a href="https://man.freebsd.org/cgi/man.cgi?query=su&amp;sektion=1&amp;format=html">su(1)</a>.</p></div></td></tr></tbody></table></div></li><li><p>Teclée <code>/compat/linux/usr/local/matlab</code> donde el instalador le pida el directorio raíz de MATLAB®.</p><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Esto último le facilitará la entrada de datos durante el resto de la instalación. Introduzca lo siguiente en el "prompt" de su shell: <code>set MATLAB=/compat/linux/usr/local/matlab</code></p></div></td></tr></tbody></table></div></li><li><p>Edite el fichero de licencia tal y como consta en las instrucciones de la licencia de MATLAB®.</p><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Puede tenerlo ya editado y copiado a <span class=filename>$MATLAB/license.dat</span> desde antes de que el instalador se lo pida.</p></div></td></tr></tbody></table></div></li><li><p>Complete el proceso de instalación.</p></li></ol></div><div class=paragraph><p>La instalación MATLAB® ha finalizado. Los siguientes pasos aplicarán el "pegamento" necesario para conectarlo a su sistema FreeBSD.</p></div></div><div class=sect3><h4 id=_inicio_del_administrador_de_licencias>10.5.2. Inicio del administrador de licencias<a class=anchor href=#_inicio_del_administrador_de_licencias></a></h4><div class="olist arabic procedure"><ol class=arabic><li><p>Crée los enlaces simbólicos que necesitan los "scripts" del administrador de licencias:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ln -s $MATLAB/etc/lmboot /usr/local/etc/lmboot_TMW</span>
<span class=c># ln -s $MATLAB/etc/lmdown /usr/local/etc/lmdown_TMW</span></code></pre></div></div></li><li><p>Crée un fichero de inicio en <span class=filename>/usr/local/etc/rc.d/flexlm.sh</span>. El siguiente ejemplo es una versión modificada de <span class=filename>$MATLAB/etc/rc.lm.glnx86</span> que viene con la distribución de MATLAB®. Los cambios que se han hecho en él obedecen a la ubicación de los ficheros y el arranque del administrador de licencias bajo emulación de Linux.</p><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
case &#34;$1&#34; in
  start)
        if [ -f /usr/local/etc/lmboot_TMW ]; then
              /compat/linux/bin/sh /usr/local/etc/lmboot_TMW -u nombre-de-usuario &amp;&amp; echo &#39;MATLAB_lmgrd&#39;
        fi
        ;;
  stop)
	if [ -f /usr/local/etc/lmdown_TMW ]; then
            /compat/linux/bin/sh /usr/local/etc/lmdown_TMW  &gt; /dev/null 2&gt;&amp;1
	fi
        ;;
  *)
	echo &#34;Usage: $0 {start|stop}&#34;
	exit 1
	;;
esac

exit 0</pre></div></div><div class="admonitionblock important"><table><tbody><tr><td class=icon><i class="fa icon-important" title=Important></i></td><td class=content><div class=paragraph><p>El fichero debe ser ejecutable:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># chmod +x /usr/local/etc/rc.d/flexlm.sh</span></code></pre></div></div><div class=paragraph><p>Tendrá que reemplazar la entrada <em>nombre-de-usuario</em> de nuestro ejemplo por un nombre de usuario válido en su sistema (que no sea <code>root</code>).</p></div></td></tr></tbody></table></div></li><li><p>Arranque el administrador de licencias:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /usr/local/etc/rc.d/flexlm.sh start</span></code></pre></div></div></li></ol></div></div><div class=sect3><h4 id=matlab-jre>10.5.3. Enlace del entorno de ejecución Java™<a class=anchor href=#matlab-jre></a></h4><div class=paragraph><p>Cambie el enlace del entorno de ejecución Java™ (JRE) a uno que funcione en FreeBSD:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd $MATLAB/sys/java/jre/glnx86/</span>
<span class=c># unlink jre; ln -s ./jre1.1.8 ./jre</span></code></pre></div></div></div><div class=sect3><h4 id=_creación_de_un_script_de_arranque_para_matlab>10.5.4. Creación de un "script" de arranque para MATLAB®<a class=anchor href=#_creación_de_un_script_de_arranque_para_matlab></a></h4><div class="olist arabic procedure"><ol class=arabic><li><p>Coloque el siguiente "script" de arranque en <span class=filename>/usr/local/bin/matlab</span>:</p><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
/compat/linux/bin/sh /compat/linux/usr/local/matlab/bin/matlab &#34;$@&#34;</pre></div></div></li><li><p>Escriba <code>chmod +x /usr/local/bin/matlab</code>.</p></li></ol></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Dependiendo de su versión de <a class=package href=https://cgit.freebsd.org/ports/tree/emulators/linux_base/>emulators/linux_base</a> tal vez obtenga errores al ejecutar este "script". Para evitarlo edite <span class=filename>/compat/linux/usr/local/matlab/bin/matlab</span> y cambie la línea en la que aparece:</p></div><div class="literalblock programlisting"><div class=content><pre>if [ `expr &#34;$lscmd&#34; : &#39;.*-&gt;.*&#39;` -ne 0 ]; then</pre></div></div><div class=paragraph><p>(en la versión 13.0.1 es en la línea 410) por esta otra línea:</p></div><div class="literalblock programlisting"><div class=content><pre>if test -L $newbase; then</pre></div></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=_creación_de_un_script_para_detener_matlab>10.5.5. Creación de un "script" para detener MATLAB®<a class=anchor href=#_creación_de_un_script_para_detener_matlab></a></h4><div class=paragraph><p>Este "script" solucionará las dificultades que pueda tener para detener MATLAB® correctamente.</p></div><div class="olist arabic procedure"><ol class=arabic><li><p>Crée un fichero llamado <span class=filename>$MATLAB/toolbox/local/finish.m</span> y ponga en él una sola línea con este texto:</p><div class="literalblock programlisting"><div class=content><pre>! $MATLAB/bin/finish.sh</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p><code>$MATLAB</code> debe escribirse tal cual.</p></div></td></tr></tbody></table></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>En el mismo directorio encontrará los ficheros <span class=filename>finishsav.m</span> y <span class=filename>finishdlg.m</span>, que le permiten guardar su trabajo antes de salir de la aplicación. Si quiere usar alguno de ellos, inserte la línea de arriba inmediatamente después de <code>save</code>.</p></div></td></tr></tbody></table></div></li><li><p>Crée un fichero <span class=filename>$MATLAB/bin/finish.sh</span> con el siguiente contenido:</p><div class="literalblock programlisting"><div class=content><pre>#!/usr/compat/linux/bin/sh
(sleep 5; killall -1 matlab_helper) &amp;
exit 0</pre></div></div></li><li><p>El fichero tiene que ser ejecutable:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># chmod +x $MATLAB/bin/finish.sh</span></code></pre></div></div></li></ol></div></div><div class=sect3><h4 id=matlab-using>10.5.6. Uso de MATLAB®<a class=anchor href=#matlab-using></a></h4><div class=paragraph><p>Desde este momento ya puede usted teclear <code>matlab</code> y empezar a usarlo.</p></div></div></div><div class=sect2><h3 id=linuxemu-oracle>10.6. Instalación de Oracle®<a class=anchor href=#linuxemu-oracle></a></h3><div class=sect3><h4 id=_prefacio>10.6.1. Prefacio<a class=anchor href=#_prefacio></a></h4><div class=paragraph><p>Este texto describe el proceso de instalación de Oracle® 8.0.5 y Oracle® 8.0.5.1 Enterprise Edition para Linux en una máquina FreeBSD.</p></div></div><div class=sect3><h4 id=_instalación_del_entorno_linux>10.6.2. Instalación del entorno Linux<a class=anchor href=#_instalación_del_entorno_linux></a></h4><div class=paragraph><p>Debe tener instalados los ports <a class=package href=https://cgit.freebsd.org/ports/tree/emulators/linux_base/>emulators/linux_base</a> y <a class=package href=https://cgit.freebsd.org/ports/tree/devel/linux_devtools/>devel/linux_devtools</a>. Si tiene dificultades con estos ports es posible que tenga que usar los paquetes o quizás versiones más antiguas de dichas aplicaciones que encontrará en la Colección de Ports.</p></div><div class=paragraph><p>Si quiere usar el agente inteligente también tendrá que instalar el paquete Tcl de Red Hat, <span class=filename>tcl-8.0.3-20.i386.rpm</span>. La orden genérica para instalar paquetes con el port oficial de RPM (<a class=package href=https://cgit.freebsd.org/ports/tree/archivers/rpm/>archivers/rpm</a>) es:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># rpm -i --ignoreos --root /compat/linux --dbpath /var/lib/rpm paquete</span></code></pre></div></div><div class=paragraph><p>La instalación de dicho <em>paquete</em> no debe generar ningún error.</p></div></div><div class=sect3><h4 id=_creación_del_entorno_oracle>10.6.3. Creación del entorno Oracle®<a class=anchor href=#_creación_del_entorno_oracle></a></h4><div class=paragraph><p>Antes de instalar Oracle® tendrá que configurar un entorno apropiado. Este documento solamente explica lo que hay que hacer <em>especialmente</em> para utilizar la versión de Linux para Oracle® FreeBSD, no lo que figura en la guía de instalación de Oracle®.</p></div><div class=sect4><h5 id=linuxemu-kernel-tuning>10.6.3.1. Personalización del kernel<a class=anchor href=#linuxemu-kernel-tuning></a></h5><div class=paragraph><p>Tal y como consta en la guía de instalación de Oracle®, debe configurar la cantidad máxima de memoria compartida. No utilice <code>SHMMAX</code> en FreeBSD. <code>SHMMAX</code> se calcula a partir de <code>SHMMAXPGS</code> y <code>PGSIZE</code>, así que defina <code>SHMMAXPGS</code>. Todas las demás opciones pueden usarse tal y como se describen en la guía. Por ejemplo:</p></div><div class="literalblock programlisting"><div class=content><pre>options SHMMAXPGS=10000
options SHMMNI=100
options SHMSEG=10
options SEMMNS=200
options SEMMNI=70
options SEMMSL=61</pre></div></div><div class=paragraph><p>Configure estas opciones para que se ajusten al uso que pretenda darle a Oracle®.</p></div><div class=paragraph><p>Asegúrese también de que las siguientes opciones están en el fichero de configuración de su kernel:</p></div><div class="literalblock programlisting"><div class=content><pre>options SYSVSHM #SysV shared memory
options SYSVSEM #SysV semaphores
options SYSVMSG #SysV interprocess communication</pre></div></div></div><div class=sect4><h5 id=linuxemu-oracle-account>10.6.3.2. Cuenta Oracle®<a class=anchor href=#linuxemu-oracle-account></a></h5><div class=paragraph><p>Crée una cuenta <code>oracle</code> según el procedimiento habitual de creación de usuarios. La cuenta <code>oracle</code>, empero, tiene algo especial puesto que debe teer una shell <em>de</em> Linux. Añada <code>/compat/linux/bin/bash</code> a <span class=filename>/etc/shells</span> y asigne a la cuenta <code>oracle</code><span class=filename>/compat/linux/bin/bash</span> como shell por omisión.</p></div></div><div class=sect4><h5 id=linuxemu-environment>10.6.3.3. Entorno<a class=anchor href=#linuxemu-environment></a></h5><div class=paragraph><p>Además de las variables normales para Oracle®, como <code>ORACLE_HOME</code> y <code>ORACLE_SID</code>, debe configurar las siguientes variables de entorno:</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Variable</th><th class="tableblock halign-left valign-top">Valor</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>LD_LIBRARY_PATH</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>$ORACLE_HOME/lib</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>CLASSPATH</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>$ORACLE_HOME/jdbc/lib/classes111.zip</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>PATH</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>/compat/linux/bin /compat/linux/sbin /compat/linux/usr/bin /compat/linux/usr/sbin /bin /sbin /usr/bin /usr/sbin /usr/local/bin $ORACLE_HOME/bin</code></p></td></tr></tbody></table><div class=paragraph><p>Le aconsejamos configurar todas las variables de entorno en <span class=filename>.profile</span>. Veamos un ejemplo completo:</p></div><div class="literalblock programlisting"><div class=content><pre>ORACLE_BASE=/oracle; export ORACLE_BASE
ORACLE_HOME=/oracle; export ORACLE_HOME
LD_LIBRARY_PATH=$ORACLE_HOME/lib
export LD_LIBRARY_PATH
ORACLE_SID=ORCL; export ORACLE_SID
ORACLE_TERM=386x; export ORACLE_TERM
CLASSPATH=$ORACLE_HOME/jdbc/lib/classes111.zip
export CLASSPATH
PATH=/compat/linux/bin:/compat/linux/sbin:/compat/linux/usr/bin
PATH=$PATH:/compat/linux/usr/sbin:/bin:/sbin:/usr/bin:/usr/sbin
PATH=$PATH:/usr/local/bin:$ORACLE_HOME/bin
export PATH</pre></div></div></div></div><div class=sect3><h4 id=_instalación_de_oracle>10.6.4. Instalación de Oracle®<a class=anchor href=#_instalación_de_oracle></a></h4><div class=paragraph><p>Debido a una pequeña inconsistencia en el emulador Linux tendrá que crear un directorio llamado <span class=filename>.oracle</span> en <span class=filename>/var/tmp</span> antes de iniciar el instalador. Haga que sea propiedad del usuario <code>oracle</code>. Hecho esto deberí poder instalar Oracle® sin ningún problema. Si no es así <em>revise su distribución</em> Oracle® y su configuración. Una vez finalizada la instalación de Oracle® aplique los parches que se detallan en las dos siguientes subsecciones.</p></div><div class=paragraph><p>Un problema que se da con una cierta frecuencia es que el adaptador del protocolo TCP no está correctamente instalado. Como consecuencia no puede iniciarse ninguna escucha TCP, a las que también se les llama directamente «listeners». Esto le ayudará a resolver el problema.:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd $ORACLE_HOME/network/lib</span>
<span class=c># make -f ins_network.mk ntcontab.o</span>
<span class=c># cd $ORACLE_HOME/lib</span>
<span class=c># ar r libnetwork.a ntcontab.o</span>
<span class=c># cd $ORACLE_HOME/network/lib</span>
<span class=c># make -f ins_network.mk install</span></code></pre></div></div><div class=paragraph><p><em>No se olvide de ejecutar <span class=filename>root.sh</span> de nuevo</em>.</p></div><div class=sect4><h5 id=linuxemu-patch-root>10.6.4.1. Cómo parchear root.sh<a class=anchor href=#linuxemu-patch-root></a></h5><div class=paragraph><p>Durante la instalación de Oracle® algunas acciones que requieren ser ejecutadas como <code>root</code> deben almacenarse en un "script" de shell llamado <span class=filename>root.sh</span>. Dicho "script" está en el directorio <span class=filename>orainst</span>. Aplique el siguiente parche a <span class=filename>root.sh</span> para que utilice la ruta correcta de <code>chown</code> o ejecute el "script" bajo una shell nativa de Linux.</p></div><div class="literalblock programlisting"><div class=content><pre>*** orainst/root.sh.orig Tue Oct 6 21:57:33 1998
--- orainst/root.sh Mon Dec 28 15:58:53 1998
***************
*** 31,37 ****
# This is the default value for CHOWN
# It will redefined later in this script for those ports
# which have it conditionally defined in ss_install.h
! CHOWN=/bin/chown
#
# Define variables to be used in this script
--- 31,37 ----
# This is the default value for CHOWN
# It will redefined later in this script for those ports
# which have it conditionally defined in ss_install.h
! CHOWN=/usr/sbin/chown
#
# Define variables to be used in this script</pre></div></div><div class=paragraph><p>Si no está instalando Oracle® desde un CD puede parchear las fuentes de <span class=filename>root.sh</span>. Se llama <span class=filename>rthd.sh</span> y está en el directorio <span class=filename>orainst</span> del árbol de fuentes.</p></div></div><div class=sect4><h5 id=linuxemu-patch-tcl>10.6.4.2. Cómo parchear genclntsh<a class=anchor href=#linuxemu-patch-tcl></a></h5><div class=paragraph><p>El "script" <code>genclntsh</code> se usa para crear una biblioteca de cliente compartida y para construir los demos. Al aplicar el siguiente parche comentará la definición de <code>PATH</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>*** bin/genclntsh.orig Wed Sep 30 07:37:19 1998
--- bin/genclntsh Tue Dec 22 15:36:49 1998
***************
*** 32,38 ****
#
# Explicit path to ensure that we&#39;re using the correct commands
#PATH=/usr/bin:/usr/ccs/bin export PATH
! PATH=/usr/local/bin:/bin:/usr/bin:/usr/X11R6/bin export PATH
#
# each product MUST provide a $PRODUCT/admin/shrept.lst
--- 32,38 ----
#
# Explicit path to ensure that we&#39;re using the correct commands
#PATH=/usr/bin:/usr/ccs/bin export PATH
! #PATH=/usr/local/bin:/bin:/usr/bin:/usr/X11R6/bin export PATH
#
# each product MUST provide a $PRODUCT/admin/shrept.lst</pre></div></div></div></div><div class=sect3><h4 id=_ejecución_de_oracle>10.6.5. Ejecución de Oracle®<a class=anchor href=#_ejecución_de_oracle></a></h4><div class=paragraph><p>Una vez seguidas estas instrucciones podrá ejecutar Oracle® como si la hubiera instalado en Linux.</p></div></div></div><div class=sect2><h3 id=sapr3>10.7. Instalación de SAP® R/3®<a class=anchor href=#sapr3></a></h3><div class=paragraph><p>Las instalaciones de sistemas SAP® en FreeBSD no reciben soporte técnico de SAP®. SAP® solamente lo ofrece si se usan plataformas certificadas.</p></div><div class=sect3><h4 id=preface>10.7.1. Introducción<a class=anchor href=#preface></a></h4><div class=paragraph><p>Este texto expone una forma de instalar un SAP® R/3® System con una Oracle® Database para Linux en una máquina FreeBSD, incluyendo la instalación de FreeBSD y Oracle®. Se muestran dos configuraciones diferentes:</p></div><div class=ulist><ul><li><p>SAP® R/3® 4.6B (IDES) con Oracle® 8.0.5 en FreeBSD 4.3-STABLE</p></li><li><p>SAP® R/3® 4.6C con Oracle® 8.1.7 en FreeBSD 4.5-STABLE</p></li></ul></div><div class=paragraph><p>Aunque este documento trate de describir todos los pasos importantes con detalle no ha sido escrito como sustituto de las guías de instalación de Oracle® y SAP® R/3®.</p></div><div class=paragraph><p>Por favor, consulte la documentación de SAP® R/3® que se incluye en la edición para Linux de SAP® y las preguntas específicas sobre Oracle®, así como los recursos que estén a su disposición sobre Oracle® y SAP® OSS.</p></div></div><div class=sect3><h4 id=software>10.7.2. Software<a class=anchor href=#software></a></h4><div class=paragraph><p>Durante la instalación de SAP® se han utilizado los siguientes CD-ROM:</p></div><div class=sect4><h5 id=software-46b>10.7.2.1. SAP® R/3® 4.6B, Oracle® 8.0.5<a class=anchor href=#software-46b></a></h5><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Nombre</th><th class="tableblock halign-left valign-top">Número</th><th class="tableblock halign-left valign-top">Descripción</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>KERNEL</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>51009113</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>SAP Kernel Oracle / Installation / AIX, Linux, Solaris</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>RDBMS</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>51007558</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Oracle / RDBMS 8.0.5.X / Linux</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>EXPORT1</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>51010208</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>IDES / DB-Export / Disco 1 de 6</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>EXPORT2</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>51010209</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>IDES / DB-Export / Disco 2 de 6</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>EXPORT3</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>51010210</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>IDES / DB-Export / Disco 3 de 6</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>EXPORT4</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>51010211</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>IDES / DB-Export / Disco 4 de 6</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>EXPORT5</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>51010212</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>IDES / DB-Export / Disco 5 de 6</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>EXPORT6</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>51010213</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>IDES / DB-Export / Disco 6 de 6</p></td></tr></tbody></table><div class=paragraph><p>También utilizamos el CD de Oracle® 8 Server (versión pre-producción 8.0.5 para Linux, versión de kernel 2.0.33), que no es realmente necesario y FreeBSD 4.3-STABLE (a unos cuantos días de la liberación de 4.3-RELEASE).</p></div></div><div class=sect4><h5 id=software-46c>10.7.2.2. SAP® R/3® 4.6C SR2, Oracle® 8.1.7<a class=anchor href=#software-46c></a></h5><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Nombre</th><th class="tableblock halign-left valign-top">Número</th><th class="tableblock halign-left valign-top">Descripción</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>KERNEL</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>51014004</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>SAP Kernel Oracle / SAP Kernel Version 4.6D / DEC, Linux</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>RDBMS</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>51012930</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Oracle 8.1.7/ RDBMS / Linux</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>EXPORT1</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>51013953</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Release 4.6C SR2 / Export / Disco 1 de 4</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>EXPORT1</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>51013953</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Release 4.6C SR2 / Export / Disco 2 de 4</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>EXPORT1</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>51013953</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Release 4.6C SR2 / Export / Disco 3 de 4</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>EXPORT1</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>51013953</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Release 4.6C SR2 / Export / Disco 4 de 4</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>LANG1</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>51013954</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Release 4.6C SR2 / Language / DE, EN, FR / Disco 1 de 3</p></td></tr></tbody></table><div class=paragraph><p>Según los idiomas que quiera usar es posible que necesite otros CD de idiomas. Sólo hemos utilizado DE y EN, así que nos bastó con el primer CD. Para su información, los números de los cuatro CD EXPORT son idénticos. Los tres CD de idiomas también tienen el mismo número, aunque esto es distinto en los CD de la versión 4.6B IDES. Al escribir este texto (20.03.2002) ejecutamos la instalación en FreeBSD 4.5-STABLE (20.03.2002).</p></div></div></div><div class=sect3><h4 id=sap-notes>10.7.3. Notas SAP®<a class=anchor href=#sap-notes></a></h4><div class=paragraph><p>Las siguientes notas han resultado ser muy útiles durante la instalación, así que le recomendamos encarecidamente que las lea antes de instalar SAP® R/3®:</p></div><div class=sect4><h5 id=sap-notes-46b>10.7.3.1. SAP® R/3® 4.6B, Oracle® 8.0.5<a class=anchor href=#sap-notes-46b></a></h5><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Número</th><th class="tableblock halign-left valign-top">Título</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>0171356</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>SAP Software on Linux: Essential Comments</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>0201147</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>INST: 4.6C R/3 Inst. on UNIX - Oracle</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>0373203</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Update / Migration Oracle 8.0.5 -→ 8.0.6/8.1.6 LINUX</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>0072984</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Release of Digital UNIX 4.0B for Oracle</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>0130581</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>R3SETUP step DIPGNTAB terminates</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>0144978</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Your system has not been installed correctly</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>0162266</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Questions and tips for R3SETUP on Windows NT / W2K</p></td></tr></tbody></table></div><div class=sect4><h5 id=sap-notes-46c>10.7.3.2. SAP® R/3® 4.6C, Oracle® 8.1.7<a class=anchor href=#sap-notes-46c></a></h5><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Número</th><th class="tableblock halign-left valign-top">Título</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>0015023</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Initializing table TCPDB (RSXP0004) (EBCDIC)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>0045619</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>R/3 with several languages or typefaces</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>0171356</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>SAP Software on Linux: Essential Comments</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>0195603</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>RedHat 6.1 Enterprise version: Known problems</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>0212876</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>The new archiving tool SAPCAR</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>0300900</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Linux: Released DELL Hardware</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>0377187</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>RedHat 6.2: important remarks</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>0387074</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>INST: R/3 4.6C SR2 Installation on UNIX</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>0387077</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>INST: R/3 4.6C SR2 Inst. on UNIX - Oracle</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>0387078</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>SAP Software on UNIX: OS Dependencies 4.6C SR2</p></td></tr></tbody></table></div></div><div class=sect3><h4 id=hardware-requirements>10.7.4. Requisitos de hardware<a class=anchor href=#hardware-requirements></a></h4><div class=paragraph><p>El siguiente equipo es suficiente para la instalación de un sistema SAP® R/3®. Si pretende darle uso productivo necesitará hacer un estudio detallado de sus necesidades:</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Componente</th><th class="tableblock halign-left valign-top">4.6B</th><th class="tableblock halign-left valign-top">4.6C</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Procesador</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Pentium® III 800MHz x 2</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Pentium® III 800MHz x 2</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Memoria</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>1GB ECC</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>2GB ECC</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Espacio en disco</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>50-60GB (IDES)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>50-60GB (IDES)</p></td></tr></tbody></table><div class=paragraph><p>Para su uso en producción le recomendamos procesadores Xeon™ con una caché grande, discos de alta velocidad (SCSI, controlador de RAID por hardware), USV y ECC-RAM. Un espacio en disco tan grande se debe al sistema IDES preconfigurado, que crea ficheros de bases de datos de 27 GB durante la instalación. Este espacio también es suficiente para sistemas de producción iniciales y datos de aplicación.</p></div><div class=sect4><h5 id=hardware-46b>10.7.4.1. SAP® R/3® 4.6B, Oracle® 8.0.5<a class=anchor href=#hardware-46b></a></h5><div class=paragraph><p>Este es el hardware que utilizamos al escribir este texto: placa base dual con 2 procesadores Pentium® III a 800 MHz, adaptador SCSI Adaptec® 29160 Ultra160 (para acceder a una unidad de cinta 40/80 GB DLT y CDROM), Mylex® AcceleRAID™ (2 canales, firmware 6.00-1-00 con 32 MB RAM). La controladora Mylex® RAID tiene conectados dos discos duros de 17 GB (replicados) y cuatro discos duros de 36 GB (RAID nivel 5).</p></div></div><div class=sect4><h5 id=hardware-46c>10.7.4.2. SAP® R/3® 4.6C, Oracle® 8.1.7<a class=anchor href=#hardware-46c></a></h5><div class=paragraph><p>Para esta instalación se usó un Dell™ PowerEdge™ 2500: placa base dual con 2 procesadores Pentium® III a 1000 MHz (256 kB de Caché), 2 GB PC133 ECC SDRAM, controladora RAID PERC/3 DC PCI con 128 MB y una unidad EIDE DVD-ROM. La controladora RAID tiene conectados dos discos duros 18 GB (replicados) y cuatro discos duros de 36 GB (RAID nivel 5).</p></div></div></div><div class=sect3><h4 id=installation>10.7.5. Instalación de FreeBSD<a class=anchor href=#installation></a></h4><div class=paragraph><p>Lo primero que tiene que hacer es instalar FreeBSD. Hay muchas formas de hacerlo. Nosotros instalamos FreeBSD 4.3 desde un FTP y FreeBSD 4.5 desde el CD de la distribución. Si necesita más información sobre los medios de instalación de FreeBSD consulte la <a href=./#install-diff-media>Cómo preparar su propio medio de instalación</a>.</p></div><div class=sect4><h5 id=disk-layout>10.7.5.1. Esquema de disco<a class=anchor href=#disk-layout></a></h5><div class=paragraph><p>Quisimos hacer el proceso lo más simple posible, así que usamos el esquema de disco de SAP® R/3® 46B y SAP® R/3® 46C SR2. Solo cambiamos los nombres de dispositivo debido a que las instalaciones tuvieron lugar en hardware diferente (<span class=filename>/dev/da</span> y <span class=filename>/dev/amr</span> respectivamente. Si utiliza una AMI MegaRAID® verá en pantalla <span class=filename>/dev/amr0s1a</span> en lugar de <span class=filename>/dev/da0s1a</span>):</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:25%><col style=width:25%><col style=width:25%><col style=width:25%><thead><tr><th class="tableblock halign-left valign-top">Sistema de ficheros</th><th class="tableblock halign-left valign-top">Tamaño (bloques de 1k)</th><th class="tableblock halign-left valign-top">Tamaño (GB)</th><th class="tableblock halign-left valign-top">Montado en</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/dev/da0s1a</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>1.016.303</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>1</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/</span></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/dev/da0s1b</span></p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"><p class=tableblock>6</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>swap</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/dev/da0s1e</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>2.032.623</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>2</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/var</span></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/dev/da0s1f</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>8.205.339</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>8</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/usr</span></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/dev/da1s1e</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>45.734.361</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>45</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/compat/linux/oracle</span></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/dev/da1s1f</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>2.032.623</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>2</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/compat/linux/sapmnt</span></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/dev/da1s1g</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>2.032.623</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>2</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/compat/linux/usr/sap</span></p></td></tr></tbody></table><div class=paragraph><p>Configure e inicialice antes que nada las dos unidades lógicas con el software Mylex® o PERC/3 RAID. El software puede iniciarse durante la fase de arranque de BIOS.</p></div><div class=paragraph><p>Por favor, tenga en cuenta que el esquema de disco que utilizamos difiere ligeramente de las recomendaciones de SAP®, ya que SAP® sugiere montar los subdirectorios Oracle® (y algunos otros) por separado. Decidimos crearlos como subdirectorios reales para simplificar.</p></div></div><div class=sect4><h5 id=makeworldandnewkernel>10.7.5.2. <code>make world</code> y un nuevo kernel<a class=anchor href=#makeworldandnewkernel></a></h5><div class=paragraph><p>Descargue las fuentes -STABLE más recientes. Ejecute <code>make world</code> y compile su kernel personalizado. Recuerde incluir en él tanto los <a href=#kerneltuning>parámetros del kernel</a> requeridos por SAP® R/3® como los que necesita Oracle®.</p></div></div></div><div class=sect3><h4 id=installingthelinuxenviornment>10.7.6. Instalación del entorno Linux<a class=anchor href=#installingthelinuxenviornment></a></h4><div class=sect4><h5 id=installinglinuxbase-system>10.7.6.1. Instalación del sistema base Linux<a class=anchor href=#installinglinuxbase-system></a></h5><div class=paragraph><p>Primero instale el port <a href=#linuxemu-libs-port>linux_base</a> (como <code>root</code>):</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/emulators/linux_base</span>
<span class=c># make install distclean</span></code></pre></div></div></div><div class=sect4><h5 id=installinglinuxdevelopment>10.7.6.2. Instalación del entorno de desarrollo Linux<a class=anchor href=#installinglinuxdevelopment></a></h5><div class=paragraph><p>El entorno de desarrollo Linux es imprescindible si quiere instalar Oracle® en FreeBSD según se explica en la <a href=#linuxemu-oracle>Instalación de Oracle®</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/devel/linux_devtools</span>
<span class=c># make install distclean</span></code></pre></div></div><div class=paragraph><p>El entorno de desarrollo Linux solo ha de instalarse si sigue el proceso para instalar SAP® R/3® 46B IDES. No es necesario si Oracle® DB no está reenlazado («relinked») con el sistema FreeBSD. Este sería su caso si está usa el fichero comprimido tar de Oracle® de un sistema Linux.</p></div></div><div class=sect4><h5 id=installingnecessaryrpms>10.7.6.3. Instalación de los RPM necesarios<a class=anchor href=#installingnecessaryrpms></a></h5><div class=paragraph><p>Necesitará soporte PAM para iniciar el programa <code>R3SETUP</code>. Durante la primera instalación de SAP® en FreeBSD 4.3-STABLE intentamos instalar PAM con todas las dependencias y finalmente forzamos la instalación del paquete PAM, y funcionó. En SAP® R/3® 4.6C SR2 forzamos la instalación del RPM PAM, que también funcionó, así que parece que las dependencias no lo son tanto:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># rpm -i --ignoreos --nodeps --root /compat/linux --dbpath /var/lib/rpm \</span>
pam-0.68-7.i386.rpm</code></pre></div></div><div class=paragraph><p>Para que Oracle® 8.0.5 pueda lanzar el agente inteligente también tendremos que instalar el paquete Tcl de RedHat <span class=filename>tcl-8.0.5-30.i386.rpm</span> (si no, cuando lo reenlace durante la instalación de Oracle® no funcionará). Existen otros aspectos relacionados con el reenlazado de Oracle® a tener en cuenta durante la instalación, pero atañen a la versión para Linux de Oracle® y no son específicos de FreeBSD.</p></div></div><div class=sect4><h5 id=linuxprocandfallbackelfbrand>10.7.6.4. Sugerencias<a class=anchor href=#linuxprocandfallbackelfbrand></a></h5><div class=paragraph><p>Le recomendamos añadir <code>linprocfs</code> a <span class=filename>/etc/fstab</span>. Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=linprocfs&amp;sektion=5&amp;format=html">linprocfs(5)</a> para más información. Otro parámetro que debería configurar es <code>kern.fallback_elf_brand=3</code> en <span class=filename>/etc/sysctl.conf</span>.</p></div></div></div><div class=sect3><h4 id=creatingsapr3env>10.7.7. Creación del entorno SAP® R/3®<a class=anchor href=#creatingsapr3env></a></h4><div class=sect4><h5 id=filesystemsandmountpoints>10.7.7.1. Creación de los sistemas de ficheros y puntos de montaje necesarios<a class=anchor href=#filesystemsandmountpoints></a></h5><div class=paragraph><p>Para una instalación sencilla es suficiente con crear los siguientes sistemas de ficheros:</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">punto de montaje</th><th class="tableblock halign-left valign-top">tamaño en GB</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/compat/linux/oracle</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>45 GB</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/compat/linux/sapmnt</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>2 GB</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/compat/linux/usr/sap</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>2 GB</p></td></tr></tbody></table><div class=paragraph><p>También es necesario crear algunos enlaces. Si no, el instalador SAP® tendrá problemas ya que buscará los siguientes enlaces:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ln -s /compat/linux/oracle /oracle</span>
<span class=c># ln -s /compat/linux/sapmnt /sapmnt</span>
<span class=c># ln -s /compat/linux/usr/sap /usr/sap</span></code></pre></div></div><div class=paragraph><p>Veamos unos cuantos errores que se le pueden presentar durante la instalación (en este caso con el sistema <em>PRD</em> y la instalación de SAP® R/3® 4.6C SR2):</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>INFO 2002-03-19 16:45:36 R3LINKS_IND_IND SyLinkCreate:200
    Checking existence of symbolic <span class=nb>link</span> /usr/sap/PRD/SYS/exe/dbg to
    /sapmnt/PRD/exe. Creating <span class=k>if </span>it does not exist...

WARNING 2002-03-19 16:45:36 R3LINKS_IND_IND SyLinkCreate:400
    Link /usr/sap/PRD/SYS/exe/dbg exists but it points to file
    /compat/linux/sapmnt/PRD/exe instead of /sapmnt/PRD/exe. The
    program cannot go on as long as this <span class=nb>link </span>exists at this
    location. Move the <span class=nb>link </span>to another location.

ERROR 2002-03-19 16:45:36 R3LINKS_IND_IND Ins_SetupLinks:0
    can not setup <span class=nb>link</span> <span class=s1>&#39;/usr/sap/PRD/SYS/exe/dbg&#39;</span> with content
    <span class=s1>&#39;/sapmnt/PRD/exe&#39;</span></code></pre></div></div></div><div class=sect4><h5 id=creatingusersanddirectories>10.7.7.2. Creación de usuarios y directorios<a class=anchor href=#creatingusersanddirectories></a></h5><div class=paragraph><p>SAP® R/3® necesita dos usuarios y tres grupos. Los nombres de usuario dependen del "SAP® system ID" (SID), y consisten en tres letras. Algunos de estos SID están reservados por SAP® (por ejemplo <code>SAP</code> y <code>NIX</code>. Tiene una lista completa de ellos en la documentación de SAP®). Para la instalación de IDES usamos <code>IDS</code> y para la instalación de 4.6C SR2 <code>PRD</code>, dado que ese sistema está pensado para un uso de producción. Tenemos por lo tanto los siguientes grupos (Los ID de grupo pueden ser diferentes, estos son solamente los valores que utilizamos en nuestra instalación):</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">ID de grupo</th><th class="tableblock halign-left valign-top">nombre de grupo</th><th class="tableblock halign-left valign-top">descripción</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>100</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>dba</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Administrador de base de datos</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>101</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>sapsys</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Sistema SAP®</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>102</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>oper</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Operador de base de datos</p></td></tr></tbody></table><div class=paragraph><p>En una instalación por omisión de Oracle® solo se usa el grupo <code>dba</code>. Puede usar el grupo <code>oper</code> como grupo <code>dba</code> (consulte la documentación de Oracle® y SAP® para más información).</p></div><div class=paragraph><p>También necesitaremos los siguientes usuarios:</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:16.6666%><col style=width:16.6666%><col style=width:16.6666%><col style=width:16.6666%><col style=width:16.6666%><col style=width:16.667%><thead><tr><th class="tableblock halign-left valign-top">ID de usuario</th><th class="tableblock halign-left valign-top">nombre de usuario</th><th class="tableblock halign-left valign-top">nombre genérico</th><th class="tableblock halign-left valign-top">grupo</th><th class="tableblock halign-left valign-top">grupos adicionales</th><th class="tableblock halign-left valign-top">descripción</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>1000</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>idsadm/prdadm</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><em>sid</em>adm</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>sapsys</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>oper</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Administrador SAP®</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>1002</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>oraids/oraprd</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>ora<em>sid</em></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>dba</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>oper</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Administrador Oracle®</p></td></tr></tbody></table><div class=paragraph><p>Al añadir dichos usuarios mediante <a href="https://man.freebsd.org/cgi/man.cgi?query=adduser&amp;sektion=8&amp;format=html">adduser(8)</a> tenga en cuenta que debe incluir las siguientes entradas (observe la shell y el directorio home) al crear el "administrador SAP®":</p></div><div class="literalblock programlisting"><div class=content><pre>Name: sidadm
Password: ******
Fullname: SAP Administrator SID
Uid: 1000
Gid: 101 (sapsys)
Class:
Groups: sapsys dba
HOME: /home/sidadm
Shell: bash  (/compat/linux/bin/bash)</pre></div></div><div class=paragraph><p>y para el "Administrador Oracle®":</p></div><div class="literalblock programlisting"><div class=content><pre>Name: orasid
Password: ******
Fullname: Oracle Administrator SID
Uid: 1002
Gid: 100 (dba)
Class:
Groups: dba
HOME: /oracle/sid
Shell: bash  (/compat/linux/bin/bash)</pre></div></div><div class=paragraph><p>Esto también incluye al grupo <code>oper</code> en caso de que esté usando el grupo <code>dba</code> y el grupo <code>oper</code>.</p></div></div><div class=sect4><h5 id=creatingdirectories>10.7.7.3. Creación de directorios<a class=anchor href=#creatingdirectories></a></h5><div class=paragraph><p>Estos directorios se crean como sistemas de ficheros independientes. Esto depende totalmente de sus necesidades. Nosotros decidimos crearlos como directorios ya que todos están en el mismo RAID 5:</p></div><div class=paragraph><p>Primero vamos a configurar los propietarios y los derechos de algunos directorios (como <code>root</code>):</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># chmod 775 /oracle</span>
<span class=c># chmod 777 /sapmnt</span>
<span class=c># chown root:dba /oracle</span>
<span class=c># chown sidadm:sapsys /compat/linux/usr/sap</span>
<span class=c># chmod 775 /compat/linux/usr/sap</span></code></pre></div></div><div class=paragraph><p>Luego vamos a crear directorios como el usuario <code>ora<em>sid</em></code>. Estos serán todos subdirectorios de <span class=filename>/oracle/SID</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># su - orasid</span>
<span class=c># cd /oracle/SID</span>
<span class=c># mkdir mirrlogA mirrlogB origlogA origlogB</span>
<span class=c># mkdir sapdata1 sapdata2 sapdata3 sapdata4 sapdata5 sapdata6</span>
<span class=c># mkdir saparch sapreorg</span>
<span class=c># exit</span></code></pre></div></div><div class=paragraph><p>Para la instalación de Oracle® 8.1.7 tendrá que crear unos cuantos directorios más:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># su - orasid</span>
<span class=c># cd /oracle</span>
<span class=c># mkdir 805_32</span>
<span class=c># mkdir client stage</span>
<span class=c># mkdir client/80x_32</span>
<span class=c># mkdir stage/817_32</span>
<span class=c># cd /oracle/SID</span>
<span class=c># mkdir 817_32</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>El directorio <span class=filename>client/80x_32</span> tiene que tener exactamente este nombre. No sustituya la <em>x</em> por un número ni por ninguna otra cosa.</p></div></td></tr></tbody></table></div><div class=paragraph><p>En el tercer paso creamos directorios como usuario <code><em>sid</em>adm</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># su - sidadm</span>
<span class=c># cd /usr/sap</span>
<span class=c># mkdir SID</span>
<span class=c># mkdir trans</span>
<span class=c># exit</span></code></pre></div></div></div><div class=sect4><h5 id=entriesinslashetcslashservices>10.7.7.4. Entradas en <span class=filename>/etc/services</span><a class=anchor href=#entriesinslashetcslashservices></a></h5><div class=paragraph><p>SAP® R/3® requiere algunas entradas en <span class=filename>/etc/services</span> que es posible que no estén correctamente activadas durante la instalalación. Añada las siguientes entradas (necesita al menos las entradas correspondientes al número de instancia, en este caso, <code>00</code>. No hará ningún daño añadir todas las entradas de <code>00</code> hasta <code>99</code> para <code>dp</code>, <code>gw</code>, <code>sp</code> y <code>ms</code>). Si va a utilizar un SAProuter o necesita acceder a SAP® OSS, también necesitará <code>99</code>, ya que el puerto 3299 se usa generalmente para el proceso SAProuter en el sistema destino:</p></div><div class="literalblock programlisting"><div class=content><pre>sapdp00    3200/tcp # SAP Dispatcher.      3200 + Instance-Number
sapgw00  3300/tcp # SAP Gateway.         3300 + Instance-Number
sapsp00  3400/tcp #                      3400 + Instance-Number
sapms00  3500/tcp #                      3500 + Instance-Number
sapmsSID 3600/tcp # SAP Message Server.  3600 + Instance-Number
sapgw00s   4800/tcp # SAP Secure Gateway   4800 + Instance-Number</pre></div></div></div><div class=sect4><h5 id=necessarylocales>10.7.7.5. Locales necesarios<a class=anchor href=#necessarylocales></a></h5><div class=paragraph><p>SAP® requiere al menos dos locales que no forman parte de la instalación por defecto de RedHat. SAP® dispone de los paquetes RPMs que pueda necesitar; puede descargalos desde su FTP, aunque tenga en cuenta que solo pueden acceder al mismo los clientes con acceso OSS). Consulte la nota 0171356, que contiene una lista de los RPM que necesitará.</p></div><div class=paragraph><p>También puede crear enlaces (por ejemplo desde <em>de_DE</em> y <em>en_US</em> ), pero no se lo recomendamos si pretende configurar un sistema de producción (no obstante, hemos de reconocer que a nosotros nos ha funcionado con el sistema IDES sin ningún problema). Necesitará al menos los siguientes locales:</p></div><div class="literalblock programlisting"><div class=content><pre>de_DE.ISO-8859-1
en_US.ISO-8859-1</pre></div></div><div class=paragraph><p>Haga los enlaces de esta manera:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /compat/linux/usr/shared/locale</span>
<span class=c># ln -s de_DE de_DE.ISO-8859-1</span>
<span class=c># ln -s en_US en_US.ISO-8859-1</span></code></pre></div></div><div class=paragraph><p>Si no están habrá algunos problemas durante la instalación. Si se ignoran (es decir, si configura el <code>STATUS</code> de los pasos relacionados con esos locales a <code>OK</code> en el fichero <span class=filename>CENTRDB.R3S</span>) será imposible entrar al sistema SAP® sin tener que recurrir a ciertas triquiñuelas.</p></div></div><div class=sect4><h5 id=kerneltuning>10.7.7.6. Personalización del kernel<a class=anchor href=#kerneltuning></a></h5><div class=paragraph><p>Los sistemas SAP® R/3® necesitan muchos recursos, por eso hemos añadido los siguientes parámetros al fichero de configuración de su kernel:</p></div><div class="literalblock programlisting"><div class=content><pre># Set these for memory pigs (SAP and Oracle):
options MAXDSIZ=&#34;(1024*1024*1024)&#34;
options DFLDSIZ=&#34;(1024*1024*1024)&#34;
# System V options needed.
options SYSVSHM #SYSV-style shared memory
options SHMMAXPGS=262144 #max amount of shared mem. pages
#options SHMMAXPGS=393216 #use this for the 46C inst.parameters
options SHMMNI=256 #max number of shared memory ident if.
options SHMSEG=100 #max shared mem.segs per process
options SYSVMSG #SYSV-style message queues
options MSGSEG=32767 #max num. of mes.segments in system
options MSGSSZ=32 #size of msg-seg. MUST be power of 2
options MSGMNB=65535 #max char. per message queue
options MSGTQL=2046 #max amount of msgs in system
options SYSVSEM #SYSV-style semaphores
options SEMMNU=256 #number of semaphore UNDO structures
options SEMMNS=1024 #number of semaphores in system
options SEMMNI=520 #number of semaphore identifiers
options SEMUME=100       #number of UNDO keys</pre></div></div><div class=paragraph><p>Puede consultar los valores mínimos en la documentación de SAP®. Como no hay detalles sobre Linux, consulte para mayor información la sección de HP-UX (32-bit). El sistema de instalación 4.6C SR2 tiene más memoria principal, asín que los segmentos compartidos pueden ser más extensos tanto para SAP® como para Oracle®; elija, por tanto, un número mayor de páginas de memoria compartida.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>En la instalación por omisión de FreeBSD 4.5 en i386™, configure <code>MAXDSIZ</code> y <code>DFLDSIZ</code> como máximo a 1 GB. Si no lo hace podrían aparecer errores extraños como <code>ORA-27102: out of memory</code> y <code>Linux Error: 12: Cannot allocate memory</code>.</p></div></td></tr></tbody></table></div></div></div><div class=sect3><h4 id=installingsapr3>10.7.8. Instalación de SAP® R/3®<a class=anchor href=#installingsapr3></a></h4><div class=sect4><h5 id=preparingsapcdroms>10.7.8.1. Preparación de los CDROM<a class=anchor href=#preparingsapcdroms></a></h5><div class=paragraph><p>Hay que montar y desmontar muchos CD-ROM durante la instalación. Si tiene suficientes unidades de CDROM, podría montarlos todos. Nosotros decidimos copiar el contenido de los CD-ROM a los directorios correspondientes:</p></div><div class="literalblock programlisting"><div class=content><pre>/oracle/SID/sapreorg/nombre-cd</pre></div></div><div class=paragraph><p>Donde <em>nombre-cd</em> era <span class=filename>KERNEL</span>, <span class=filename>RDBMS</span>, <span class=filename>EXPORT1</span>, <span class=filename>EXPORT2</span>, <span class=filename>EXPORT3</span>, <span class=filename>EXPORT4</span>, <span class=filename>EXPORT5</span> y <span class=filename>EXPORT6</span> para la instalación 4.6B/IDES, y <span class=filename>KERNEL</span>, <span class=filename>RDBMS</span>, <span class=filename>DISK1</span>, <span class=filename>DISK2</span>, <span class=filename>DISK3</span>, <span class=filename>DISK4</span> y <span class=filename>LANG</span> para la instalación 4.6C SR2. Todos los nombres de fichero en los CDs montados deben estar en mayúsculas; si no es así use la opción <code>-g</code> al montar. Utilice lo siguiente:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount_cd9660 -g /dev/cd0a /mnt</span>
<span class=c># cp -R /mnt/* /oracle/SID/sapreorg/nombre-cd</span>
<span class=c># umount /mnt</span></code></pre></div></div></div><div class=sect4><h5 id=runningtheinstall-script>10.7.8.2. Ejecución del "script" de instalación<a class=anchor href=#runningtheinstall-script></a></h5><div class=paragraph><p>Primero tendrá que preparar un directorio <span class=filename>install</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /oracle/SID/sapreorg</span>
<span class=c># mkdir install</span>
<span class=c># cd install</span></code></pre></div></div><div class=paragraph><p>Una vez arrancado el "script" de instalación copiará casi todos los ficheros relevantes en el directorio <span class=filename>install</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /oracle/SID/sapreorg/KERNEL/UNIX/INSTTOOL.SH</span></code></pre></div></div><div class=paragraph><p>La instalación IDES (4.6B) incluye un sistema de demostración SAP® R/3® totalmente personalizado, así que hay seis CD EXPORT en lugar de solo tres. La plantilla de instalación <span class=filename>CENTRDB.R3S</span> está pensada para una instancia central estándar (R/3® y base de datos), no la instancia central IDES, así que hay que copiar el <span class=filename>CENTRDB.R3S</span> correspondiente del directorio <span class=filename>EXPORT1</span>. Si no lo hace <code>R3SETUP</code> solo pedirá tres CD EXPORT.</p></div><div class=paragraph><p>La nueva versión de SAP® 4.6C SR2 incluye cuatro CDs EXPORT. El fichero de parámetros que controla los pasos de la instalación es <span class=filename>CENTRAL.R3S</span>. A diferencia de versiones versiones anteriores, no existen patrones de instalación por separado para una instancia central con o sin base de datos. SAP® utiliza un patrón separado para la instalación de la base de datos. Para reiniciar la instalación después es suficiente reiniciarla con el fichero original.</p></div><div class=paragraph><p>Durante y después de la instalación, SAP® necesita que <code>hostname</code> devuelva <em>sólamente</em> el nombre del sistema, no el nombre cualificado de dominio. Configure el nombre del equipo de ese modo, o active un alias mediante <code>alias hostname='hostname -s'</code> para <code>ora<em>sid</em></code> y para <code><em>sid</em>adm</code> (y para <code>root</code> al menos durante los pasos de la instalación realizados como <code>root</code>). También puede configurar los ficheros <span class=filename>.profile</span> y <span class=filename>.login</span> de los usuarios que se crean durante la instalación SAP®.</p></div></div><div class=sect4><h5 id=startr3setup-46B>10.7.8.3. Inicio de <code>R3SETUP</code> 4.6B<a class=anchor href=#startr3setup-46B></a></h5><div class=paragraph><p>Asegúrese de que <code>LD_LIBRARY_PATH</code> esté configurada correctamente:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># export LD_LIBRARY_PATH=/oracle/IDS/lib:/sapmnt/IDS/exe:/oracle/805_32/lib</span></code></pre></div></div><div class=paragraph><p>Inicie <code>R3SETUP</code> como <code>root</code> desde el directorio de instalación:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /oracle/IDS/sapreorg/install</span>
<span class=c># ./R3SETUP -f CENTRDB.R3S</span></code></pre></div></div><div class=paragraph><p>El "script" le preguntará algunas cosas; le mostramos aquí entre corchetes la respuesta por defecto, y después la respuesta que nosotros introdujimos:</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Pregunta</th><th class="tableblock halign-left valign-top">Por omisión</th><th class="tableblock halign-left valign-top">Entrada</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Enter SAP System ID</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>[C11]</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>IDS<kbd>Intro</kbd></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Enter SAP Instance Number</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>[00]</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><kbd>Intro</kbd></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Enter SAPMOUNT Directory</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>[/sapmnt]</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><kbd>Intro</kbd></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Enter name of SAP central host</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>[troubadix.domain.de]</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><kbd>Intro</kbd></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Enter name of SAP db host</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>[troubadix]</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><kbd>Intro</kbd></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Select character set</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>[1] (WE8DEC)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><kbd>Intro</kbd></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Enter Oracle server version (1) Oracle 8.0.5, (2) Oracle 8.0.6, (3) Oracle 8.1.5, (4) Oracle 8.1.6</p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"><p class=tableblock>1<kbd>Intro</kbd></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Extract Oracle Client archive</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>[1] (Yes, extract)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><kbd>Intro</kbd></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Enter path to KERNEL CD</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>[/sapcd]</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>/oracle/IDS/sapreorg/KERNEL</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Enter path to RDBMS CD</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>[/sapcd]</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>/oracle/IDS/sapreorg/RDBMS</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Enter path to EXPORT1 CD</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>[/sapcd]</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>/oracle/IDS/sapreorg/EXPORT1</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Directory to copy EXPORT1 CD</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>[/oracle/IDS/sapreorg/CD4_DIR]</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><kbd>Intro</kbd></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Enter path to EXPORT2 CD</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>[/sapcd]</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>/oracle/IDS/sapreorg/EXPORT2</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Directory to copy EXPORT2 CD</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>[/oracle/IDS/sapreorg/CD5_DIR]</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><kbd>Intro</kbd></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Enter path to EXPORT3 CD</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>[/sapcd]</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>/oracle/IDS/sapreorg/EXPORT3</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Directory to copy EXPORT3 CD</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>[/oracle/IDS/sapreorg/CD6_DIR]</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><kbd>Intro</kbd></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Enter path to EXPORT4 CD</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>[/sapcd]</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>/oracle/IDS/sapreorg/EXPORT4</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Directory to copy EXPORT4 CD</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>[/oracle/IDS/sapreorg/CD7_DIR]</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><kbd>Intro</kbd></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Enter path to EXPORT5 CD</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>[/sapcd]</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>/oracle/IDS/sapreorg/EXPORT5</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Directory to copy EXPORT5 CD</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>[/oracle/IDS/sapreorg/CD8_DIR]</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><kbd>Intro</kbd></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Enter path to EXPORT6 CD</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>[/sapcd]</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>/oracle/IDS/sapreorg/EXPORT6</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Directory to copy EXPORT6 CD</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>[/oracle/IDS/sapreorg/CD9_DIR]</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><kbd>Intro</kbd></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Enter amount of RAM for SAP + DB</p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"><p class=tableblock>850<kbd>Intro</kbd> (en Megabytes)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Service Entry Message Server</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>[3600]</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><kbd>Intro</kbd></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Enter Group-ID of sapsys</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>[101]</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><kbd>Intro</kbd></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Enter Group-ID of oper</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>[102]</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><kbd>Intro</kbd></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Enter Group-ID of dba</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>[100]</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><kbd>Intro</kbd></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Enter User-ID of <em>sid</em>adm</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>[1000]</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><kbd>Intro</kbd></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Enter User-ID of ora<em>sid</em></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>[1002]</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><kbd>Intro</kbd></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Number of parallel procs</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>[2]</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><kbd>Intro</kbd></p></td></tr></tbody></table><div class=paragraph><p>Si no ha copiado los CD a su disco duro el instalador SAP® no podrá encontrar el CD que necesite (identifica los contenidos mediante fichero <span class=filename>LABEL.ASC</span> de cada CD) y por lo tanto le pedirá que introduzca y monte el CD, o que confirme o introduzca la ruta de montaje.</p></div><div class=paragraph><p><span class=filename>CENTRDB.R3S</span> puede contener algún error. En nuestro caso, solicitó el CD EXPORT4 más de una vez, pero se le indicó la clave correcta (6_LOCATION, luego 7_LOCATION, etc), así que pudimos continuar introduciendo los valores correctos.</p></div><div class=paragraph><p>Aparte de algunos problemas que se detallan más adelante deberíamos ir llegando a la instalación del software de base de datos Oracle®.</p></div></div><div class=sect4><h5 id=startr3setup-46C>10.7.8.4. Iniciar <code>R3SETUP</code> 4.6C SR2<a class=anchor href=#startr3setup-46C></a></h5><div class=paragraph><p>Asegúrese de que <code>LD_LIBRARY_PATH</code> esté correctamente configurada. Tenga en cuenta de que es un valor diferente de la instalación 4.6B con Oracle® 8.0.5:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># export LD_LIBRARY_PATH=/sapmnt/PRD/exe:/oracle/PRD/817_32/lib</span></code></pre></div></div><div class=paragraph><p>Arranque <code>R3SETUP</code> como el usuario <code>root</code> desde el directorio de instalación:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /oracle/PRD/sapreorg/install</span>
<span class=c># ./R3SETUP -f CENTRAL.R3S</span></code></pre></div></div><div class=paragraph><p>El "script" le preguntará algunas cosas. Le presentamos la respuesta por omisión entre corchetes y después la respuesta que dimos nosotros):</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Pregunta</th><th class="tableblock halign-left valign-top">Por omisión</th><th class="tableblock halign-left valign-top">Entrada</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Enter SAP System ID</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>[C11]</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>PRD<kbd>Intro</kbd></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Enter SAP Instance Number</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>[00]</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><kbd>Intro</kbd></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Enter SAPMOUNT Directory</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>[/sapmnt]</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><kbd>Intro</kbd></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Enter name of SAP central host</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>[majestix]</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><kbd>Intro</kbd></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Enter Database System ID</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>[PRD]</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>PRD<kbd>Intro</kbd></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Enter name of SAP db host</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>[majestix]</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><kbd>Intro</kbd></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Select character set</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>[1] (WE8DEC)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><kbd>Intro</kbd></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Enter Oracle server version (2) Oracle 8.1.7</p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"><p class=tableblock>2<kbd>Intro</kbd></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Extract Oracle Client archive</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>[1] (Yes, extract)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><kbd>Intro</kbd></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Enter path to KERNEL CD</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>[/sapcd]</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>/oracle/PRD/sapreorg/KERNEL</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Enter amount of RAM for SAP + DB</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>2044</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>1800<kbd>Intro</kbd> (in Megabytes)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Service Entry Message Server</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>[3600]</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><kbd>Intro</kbd></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Enter Group-ID of sapsys</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>[100]</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><kbd>Intro</kbd></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Enter Group-ID of oper</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>[101]</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><kbd>Intro</kbd></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Enter Group-ID of dba</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>[102]</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><kbd>Intro</kbd></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Enter User-ID of <code>oraprd</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>[1002]</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><kbd>Intro</kbd></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Enter User-ID of <code>prdadm</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>[1000]</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><kbd>Intro</kbd></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>LDAP support</p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"><p class=tableblock>3<kbd>Intro</kbd> (no support)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Installation step completed</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>[1] (continue)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><kbd>Intro</kbd></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Choose installation service</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>[1] (DB inst,file)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><kbd>Intro</kbd></p></td></tr></tbody></table><div class=paragraph><p>La creación de usuarios da un error durante la instalación en las fases OSUSERDBSID_IND_ORA (al crear al usuario <code>ora<em>sid</em></code>) y OSUSERSIDADM_IND_ORA (al crear el usuario <code><em>sid</em>adm</code>).</p></div><div class=paragraph><p>Más adelante hablaremos de cierto problemas que aún tenemos pendientes, pero ha llegado el momento de instalar el software de base de datos Oracle®.</p></div></div></div><div class=sect3><h4 id=installingoracle805>10.7.9. Instalación de Oracle® 8.0.5<a class=anchor href=#installingoracle805></a></h4><div class=paragraph><p>Consulte los <span class=filename>Readme</span> de Oracle® y las notas de de SAP® sobre Linux y Oracle® DB por si hubiera algo que le pueda afectar. La mayoría de los problemas, por no decir todos, tienen su origen en bibliotecas incompatibles.</p></div><div class=paragraph><p>Para mayor información sobre la instalación de Oracle® diríjase al <a href=#linuxemu-oracle>capítulo de instalación de Oracle®.</a></p></div><div class=sect4><h5 id=installingtheoracle805withorainst>10.7.9.1. Instalación de Oracle® 8.0.5 con <code>orainst</code><a class=anchor href=#installingtheoracle805withorainst></a></h5><div class=paragraph><p>Si quiere instalar Oracle® 8.0.5 necesitará unas cuantas bibliotecas para el enlazado, ya que Oracle® 8.0.5 fué enlazado con una glibc antigua (la de RedHat 6.0), pero RedHat 6.1 usa una nueva glibc. Tendrá que instalar los siguientes paquetes para asegurarse que el reenlazado funcione:</p></div><div class=paragraph><p><span class=filename>compat-libs-5.2-2.i386.rpm</span></p></div><div class=paragraph><p><span class=filename>compat-glibc-5.2-2.0.7.2.i386.rpm</span></p></div><div class=paragraph><p><span class=filename>compat-egcs-5.2-1.0.3a.1.i386.rpm</span></p></div><div class=paragraph><p><span class=filename>compat-egcs-c++-5.2-1.0.3a.1.i386.rpm</span></p></div><div class=paragraph><p><span class=filename>compat-binutils-5.2-2.9.1.0.23.1.i386.rpm</span></p></div><div class=paragraph><p>Para más información consulte las notas correspondientes de SAP® o los <span class=filename>Readme</span> de Oracle®. Si no es posible (durante la instalación no tuvimos tiempo suficiente para ello), se podrían utilizar los binarios originales, o los binarios reenlazados de un sistema original RedHat.</p></div><div class=paragraph><p>Instale el paquete Tcl de RedHat para compilar el agente inteligente. Si no puede conseguir <span class=filename>tcl-8.0.3-20.i386.rpm</span> debería funcionar una versión más reciente, por ejemplo <span class=filename>tcl-8.0.5-30.i386.rpm</span> para RedHat.</p></div><div class=paragraph><p>Aparte del reenlazado, la instalación es muy sencilla:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># su - oraids</span>
<span class=c># export TERM=xterm</span>
<span class=c># export ORACLE_TERM=xterm</span>
<span class=c># export ORACLE_HOME=/oracle/IDS</span>
<span class=c># cd $ORACLE_HOME/orainst_sap</span>
<span class=c># ./orainst</span></code></pre></div></div><div class=paragraph><p>Confirme todas las pantallas con <kbd>Intro</kbd> hasta que el software esté instalado; todas excepto en la que debe quitar la marca de instalación al <em>visualizador de textos Oracle® en línea</em>, ya que no existe para Linux. Oracle® intentará, gracias a esto, reenlazar con <code>i386-glibc20-linux-gcc</code> en lugar de <code>gcc</code>, <code>egcs</code> o <code>i386-redhat-linux-gcc</code>.</p></div><div class=paragraph><p>Debido a la falta de tiempo decidimos usar los binarios de una versión Oracle® 8.0.5 PreProduction, después de que nuestro primer intento de que funcionara la versión del CD RDBMS fallara y viendo que encontrar y utilizar los RPM correctos hubiera sido una pesadilla.</p></div></div><div class=sect4><h5 id=installingtheoracle805preproduction>10.7.9.2. Instalación de Oracle® 8.0.5 "Pre-production Release" para Linux (Kernel 2.0.33)<a class=anchor href=#installingtheoracle805preproduction></a></h5><div class=paragraph><p>La instalación es bastante fácil. Monte el CD e inicie el instalador. Le preguntará por la ubicación del directorio home de Oracle®, y copiará en él todos los binarios. (Nosotros no eliminamos los restos de una instalación RDBMS anterior que no terminó de llegó a terminar).</p></div><div class=paragraph><p>Tras esto la base de datos Oracle® puede arrancar.</p></div></div></div><div class=sect3><h4 id=installingoracle817>10.7.10. Instalación desde el fichero comprimido de Linux Oracle® 8.1.7<a class=anchor href=#installingoracle817></a></h4><div class=paragraph><p>Descomprima el fichero <span class=filename>oracle81732.tgz</span> (creado en el directorio de instalación en un sistema Linux) y descomprímalo en <span class=filename>/oracle/SID/817_32/</span>.</p></div></div><div class=sect3><h4 id=continuewithsapr4installation>10.7.11. Continúe con la instalación SAP® R/3®<a class=anchor href=#continuewithsapr4installation></a></h4><div class=paragraph><p>Revise las configuraciones del entorno de los usuarios <code>idsamd</code> (<em>sid</em>adm) y <code>oraids</code> (ora<em>sid</em>). Ambos deben tener los ficheros <span class=filename>.profile</span>, <span class=filename>.login</span> y <span class=filename>.cshrc</span> con <code>hostname</code> correctamente configurado. En caso que el nombre del sistema sea el nombre cualificado completo tendrá que cambiar <code>hostname</code> a <code>hostname -s</code> en los tres ficheros anteriormente citados.</p></div><div class=sect4><h5 id=databaseload>10.7.11.1. Carga de la base de datos<a class=anchor href=#databaseload></a></h5><div class=paragraph><p>Hecho esto puede rearrancar <code>R3SETUP</code> o volver a arrancar la instalación (dependiendo si eligió salir o no). <code>R3SETUP</code> crea las tablas y carga los datos (en 46B IDES, desde EXPORT1 a EXPORT6, en 46C desde DISK1 a DISK4) mediante <code>R3load</code>.</p></div><div class=paragraph><p>Cuando se termina la carga de la base de datos (que puede llevar un par de horas) se le pedirán algunas contraseñas. En una instalación de prueba puede usar unas contraseñas de compromiso. (<em>use una contraseña de verdad si le preocupa siquiera ligeramente la seguridad</em>):</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Pregunta</th><th class="tableblock halign-left valign-top">Entrada</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Enter Password for sapr3</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>sap<kbd>Intro</kbd></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Confirum Password for sapr3</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>sap<kbd>Intro</kbd></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Enter Password for sys</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>change_on_install<kbd>Enter</kbd></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Confirm Password for sys</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>change_on_install<kbd>Enter</kbd></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Enter Password for system</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>manager<kbd>Intro</kbd></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Confirm Password for system</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>manager<kbd>Intro</kbd></p></td></tr></tbody></table><div class=paragraph><p>Aquí tuvimos problemas con <code>dipgntab</code> en la instalación de 4.6B.</p></div></div><div class=sect4><h5 id=listener>10.7.11.2. Las escuchas<a class=anchor href=#listener></a></h5><div class=paragraph><p>Arranque las escuchas de Oracle® con el usuario <code>ora<em>sid</em></code> de la siguiente manera:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>umask </span>0<span class=p>;</span> lsnrctl start</code></pre></div></div><div class=paragraph><p>Si no lo hace así verá un error ORA-12546, ya que los sockets no tendrán los permisos correctos. Consulte la nota 072984 de SAP®.</p></div></div><div class=sect4><h5 id=mnlstables>10.7.11.3. Actualización de tablas MNLS<a class=anchor href=#mnlstables></a></h5><div class=paragraph><p>Si tiene previsto importar idiomas que no sean Latin-1 en SAP® tiene que actualizar las tablas "Multi National Language Support". Tiene más información sobre esto en las notas de SAP® OSS 15023 y 45619. Si no es su caso puede saltarse esta parte de la instalación de SAP®.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Aunque no necesite soporte MNLS sigue siendo necesario que revise la tabla TCPDB y que la inicialice si no lo ha hecho ya. Consulte las notas 0015023 y 0045619 de SAP® para más información.</p></div></td></tr></tbody></table></div></div></div><div class=sect3><h4 id=postinstallationsteps>10.7.12. Pasos para después de la instalación<a class=anchor href=#postinstallationsteps></a></h4><div class=sect4><h5 id=requestsapr3licensekey>10.7.12.1. Solicitar una licencia SAP® R/3®<a class=anchor href=#requestsapr3licensekey></a></h5><div class=paragraph><p>Tiene que solicitar una licencia de SAP® R/3®. No tendrá más remedio, puesto que la licencia temporal que se usa durante la instalación tiene un límite de validez de cuatro semanas. Necesitará la llave hardware. Entre al sistema como usuario <code>idsadm</code> y ejecute <code>saplicense</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /sapmnt/IDS/exe/saplicense -get</span></code></pre></div></div><div class=paragraph><p>Si ejecuta <code>saplicense</code> sin parámetros verá una lista de opciones. Una vez que tenga la licencia en su poder la podrá instalar del siguiente modo:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /sapmnt/IDS/exe/saplicense -install</span></code></pre></div></div><div class=paragraph><p>Se le solicitará que introduzca los siguientes valores:</p></div><div class="literalblock programlisting"><div class=content><pre>SAP SYSTEM ID   = SID, 3 caracteres
CUSTOMER KEY    = llave hardware, 11 caracteres
INSTALLATION NO = instalación, 10 caracteres
EXPIRATION DATE = yyyymmdd, normalmente &#34;99991231&#34;
LICENSE KEY     = licencia, 24 caracteres</pre></div></div></div><div class=sect4><h5 id=creatingusers>10.7.12.2. Crear usuarios<a class=anchor href=#creatingusers></a></h5><div class=paragraph><p>Cree un usuario dentro del cliente 000 (es necesario para algunas tareas que requieren hacerse dentro del cliente 000, pero con un usuario que no sea ni <code>sap*</code> ni <code>ddic</code>). Nosotros solemos elegir para este usuario el nombre de <code>wartung</code> (o <code>service</code>, ambos "servicio" en castellano). Los perfiles son <code>sap_new</code> y <code>sap_all</code>. Para mayor seguridad las contraseñas para usuarios por defecto dentro de todos los clientes deben cambiarse (incluidos los usuarios <code>sap*</code> y <code>ddic</code>).</p></div></div><div class=sect4><h5 id=configtranssysprofileopermodesetc>10.7.12.3. Configurar sistema de transporte, perfil, modos de operación, etc.<a class=anchor href=#configtranssysprofileopermodesetc></a></h5><div class=paragraph><p>Dentro del cliente 000 y con un usuario que no sea <code>ddic</code> ni <code>sap*</code>, haga al menos lo siguiente:</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Tarea</th><th class="tableblock halign-left valign-top">Transacción</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Configurar sistema de transporte, por ejemplo como <em>Stand-Alone Transport Domain Entity</em></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>STMS</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Crear / editar perfil para el sistema</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>RZ10</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Mantener modos de operación e instancias</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>RZ04</p></td></tr></tbody></table><div class=paragraph><p>Todos estos (y muchos más) pasos para ejecutar después de la instalación se explican de forma detallada en las guías de instalación de SAP®.</p></div></div><div class=sect4><h5 id=editintsidsap>10.7.12.4. Editar <span class=filename>initsid.sap</span> (<span class=filename>initIDS.sap</span>)<a class=anchor href=#editintsidsap></a></h5><div class=paragraph><p>El fichero <span class=filename>/oracle/IDS/dbs/initIDS.sap</span> contiene la copia de seguridad del perfil de de SAP®. Aquí es donde debe definir el tamaño de la cinta a utilizar, tipo de conpresión, etc. Las siguientes modificaciones nos permitirían ejecutar <code>sapdba</code> / <code>brbackup</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>compress = hardware
archive_function = copy_delete_save
cpio_flags = &#34;-ov --format=newc --block-size=128 --quiet&#34;
cpio_in_flags = &#34;-iuv --block-size=128 --quiet&#34;
tape_size = 38000M
tape_address = /dev/nsa0
tape_address_rew = /dev/sa0</pre></div></div><div class=paragraph><p>Explicación:</p></div><div class=paragraph><p><code>compress</code>: La cinta que usamos es una HP DLT1 que tiene compresión por hardware.</p></div><div class=paragraph><p><code>archive_function</code>: Define el comportamiento por omisión del almacenaje de los logs de Oracle®: los nuevos ficheros de log se guardan en cinta, los ficheros de log que ya han sido guardados se guardan de nuevo y luego se borran. Así se evitan muchos problemas si necesita recuperar la base de datos y una de las cintas está dañada.</p></div><div class=paragraph><p><code>cpio_flags</code>: por omisión se usa <code>-B</code>, que asigna un tamaño de bloque de 5120 Bytes. HP recomienda un tamaño de bloque de 32 K como mínimo; usamos <code>--block-size=128</code> para que sea de 64 K. Necesitaremos usar <code>--format=newc</code> porque tenemos números de inodo mayores a 65535. La última opción (<code>--quiet</code>) se necesita ya que <code>brbackup</code> se queja en cuanto <code>cpio</code> imprime los números de bloque guardados.</p></div><div class=paragraph><p><code>cpio_in_flags</code>: Parámetros necesarios para cargar datos desde la cinta. El formato es reconocido automáticamente.</p></div><div class=paragraph><p><code>tape_size</code>: La capacidad de almacenaje de la cinta. Por razones de seguridad (nosotros usamos compresión por hardware) el valor es ligeramente menor que el valor real.</p></div><div class=paragraph><p><code>tape_address</code>: El dispositivo (que no permite el rebobinado) que se usará con <code>cpio</code>.</p></div><div class=paragraph><p><code>tape_address_rew</code>: El dispositivo (que permite el rebobinado) que se usará con <code>cpio</code>.</p></div></div><div class=sect4><h5 id=_aspectos_de_la_configuración_una_vez_concluida_la_instalación>10.7.12.5. Aspectos de la configuración una vez concluida la instalación<a class=anchor href=#_aspectos_de_la_configuración_una_vez_concluida_la_instalación></a></h5><div class=paragraph><p>Los siguientes parámetros SAP® deben personalizarse una vez concluída la instalación (los ejemplos son para IDES 46B, 1 GB de memoria):</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Nombre</th><th class="tableblock halign-left valign-top">Valor</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>ztta/roll_extension</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>250000000</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>abap/heap_area_dia</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>300000000</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>abap/heap_area_nondia</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>400000000</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>em/initial_size_MB</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>256</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>em/blocksize_kB</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>1024</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>ipc/shm_psize_40</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>70000000</p></td></tr></tbody></table><div class=paragraph><p>SAP® Note 0013026:</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Nombre</th><th class="tableblock halign-left valign-top">Valor</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>ztta/dynpro_area</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>2500000</p></td></tr></tbody></table><div class=paragraph><p>SAP® Note 0157246:</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Nombre</th><th class="tableblock halign-left valign-top">Valor</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>rdisp/ROLL_MAXFS</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>16000</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>rdisp/PG_MAXFS</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>30000</p></td></tr></tbody></table><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>En un sistema con 1 GB de memoria y los parámetros arriba expuestos puede esperarse encontrar un consumo de memoria similar al siguiente:</p></div><div class="literalblock programlisting"><div class=content><pre>Mem: 547M Active, 305M Inact, 109M Wired, 40M Cache, 112M Buf, 3492K Free</pre></div></div></td></tr></tbody></table></div></div></div><div class=sect3><h4 id=problemsduringinstallation>10.7.13. Problemas durante la instalación<a class=anchor href=#problemsduringinstallation></a></h4><div class=sect4><h5 id=restartr3setup>10.7.13.1. Reiniciar <code>R3SETUP</code> una vez arreglado el problema<a class=anchor href=#restartr3setup></a></h5><div class=paragraph><p><code>R3SETUP</code> se detiene si encuentra un error. Si ha revisado los logs y ha corregido el error reinicie <code>R3SETUP</code>; hágalo seleccionando la opción REPEAT en el paso donde <code>R3SETUP</code> se detuvo.</p></div><div class=paragraph><p>Cuando quiera reiniciar <code>R3SETUP</code> inícielo con el fichero <span class=filename>R3S</span> correspondiente:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ./R3SETUP -f CENTRDB.R3S</span></code></pre></div></div><div class=paragraph><p>en el caso de 4.6B, o con</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ./R3SETUP -f CENTRAL.R3S</span></code></pre></div></div><div class=paragraph><p>en 4.6C; no importa si el error ocurrió con <span class=filename>CENTRAL.R3S</span> o con <span class=filename>DATABASE.R3S</span>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>En algunas etapas, <code>R3SETUP</code> asume que la base de datos y los procesos SAP® están en marcha (como aquellos en los cuales se completaron los pasos). Si hay errores y por ejemplo la base de datos no se puede iniciar tendrá que arrancar la base de datos y SAP® manualmente una vez haya corregido los errores y antes de iniciar <code>R3SETUP</code> nuevamente.</p></div><div class=paragraph><p>No olvide iniciar también la escucha de Oracle® (como <code>ora<em>sid</em></code> con <code>umask 0; lsnrctl start</code>) si también tuvo que detenerlo (si por ejemplo hubo que reiniciar el sistema).</p></div></td></tr></tbody></table></div></div><div class=sect4><h5 id=indoraduringduringr3setup>10.7.13.2. OSUSERSIDADM_IND_ORA durante <code>R3SETUP</code><a class=anchor href=#indoraduringduringr3setup></a></h5><div class=paragraph><p>Si <code>R3SETUP</code> se queja en este etapa edite la plantilla <code>R3SETUP</code> que esté usando en ese momento (<span class=filename>CENTRDB.R3S</span> (en 4.6B) o <span class=filename>CENTRAL.R3S</span> o <span class=filename>DATABASE.R3S</span> (en 4.6C)). Ubique <code>[OSUSERSIDADM_IND_ORA]</code> o busque la única entrada <code>STATUS=ERROR</code> y edite los siguientes valores:</p></div><div class="literalblock programlisting"><div class=content><pre>HOME=/home/sidadm (was empty)
STATUS=OK (had status ERROR)</pre></div></div><div class=paragraph><p>Hecho esto, reinicie <code>R3SETUP</code>.</p></div></div><div class=sect4><h5 id=indoraduringr3setup>10.7.13.3. OSUSERDBSID_IND_ORA durante <code>R3SETUP</code><a class=anchor href=#indoraduringr3setup></a></h5><div class=paragraph><p>Es posible que <code>R3SETUP</code> se queje también en esta etapa. El error aquí es similar al de la fase OSUSERSIDADM_IND_ORA. Edite la plantilla <code>R3SETUP</code> que esté usando (<span class=filename>CENTRDB.R3S</span> (en 4.6B) o <span class=filename>CENTRAL.R3S</span> o <span class=filename>DATABASE.R3S</span> (en 4.6C)). Ubique <code>[OSUSERDBSID_IND_ORA]</code> o busque la única entrada <code>STATUS=ERROR</code> y edite los siguientes valores en esa sección:</p></div><div class="literalblock programlisting"><div class=content><pre>STATUS=OK</pre></div></div><div class=paragraph><p>Hecho esto reinicie <code>R3SETUP</code>.</p></div></div><div class=sect4><h5 id=oraviewvrffilenotfound>10.7.13.4. <code>oraview.vrf FILE NOT FOUND</code> durante la instalación de Oracle®<a class=anchor href=#oraviewvrffilenotfound></a></h5><div class=paragraph><p>No ha dejado sin seleccionar la opción de instalar el <em>visualizador de texto en línea de Oracle®</em> antes de iniciar la instalación. Está seleccionado para ser instalado, aunque la aplicación no existe para Linux. Deje sin seleccionar el producto en el menú de instalación de Oracle® y reinicie la instalación.</p></div></div><div class=sect4><h5 id=textenvincalid>10.7.13.5. <code>TEXTENV_INVALID</code> durante <code>R3SETUP</code>, o inicio de RFC o SAPgui<a class=anchor href=#textenvincalid></a></h5><div class=paragraph><p>Si se encuentra con este error significa que falta el locale correcto. La nota 0171356 de SAP® contiene una lista de RPM que deben instalarse (p.ej. <span class=filename>saplocales-1.0-3</span>, <span class=filename>saposcheck-1.0-1</span> para RedHat 6.1). En caso de que ignore todos los errores relacionados y configure los <code>STATUS</code> correspondientes de <code>ERROR</code> a <code>OK</code> (en <span class=filename>CENTRDB.R3S</span>) cada vez que <code>R3SETUP</code> se queje y simplemente reinicie <code>R3SETUP</code>; el sistema SAP® no estará configurado correctamente y no podrá conectarse al sistema con SAPgui, aunque el sistema pueda arrancar. Si intenta conectar con el antiguo SAPgui de Linux recibirá los siguientes mensajes:</p></div><div class="literalblock programlisting"><div class=content><pre>Sat May 5 14:23:14 2001
*** ERROR =&gt; no valid userarea given [trgmsgo. 0401]
Sat May 5 14:23:22 2001
*** ERROR =&gt; ERROR NR 24 occured [trgmsgi. 0410]
*** ERROR =&gt; Error when generating text environment. [trgmsgi. 0435]
*** ERROR =&gt; function failed [trgmsgi. 0447]
*** ERROR =&gt; no socket operation allowed [trxio.c 3363]
Speicherzugriffsfehler</pre></div></div><div class=paragraph><p>Este comportamiento se debe a que SAP® R/3® es incapaz de asignar correctamente un locale y tampoco puede configurarse a sí mismo correctamente (faltan entradas en algunas tablas de la base de datos). Añada las siguientes entradas al fichero <span class=filename>DEFAULT.PFL</span> y podrá conectarse a SAP® (vea la nota 0043288):</p></div><div class="literalblock programlisting"><div class=content><pre>abap/set_etct_env_at_new_mode = 0
install/collate/active = 0
rscp/TCP0B = TCP0B</pre></div></div><div class=paragraph><p>Reinicie el sistema SAP®. Puede conectar al sistema, aunque la configuración de idioma o de país puede que no funcione como se espera de ella. Una vez corregidas las configuraciones de país (y proporcionados los locales adecuados) puede eliminar estas entradas de <span class=filename>DEFAULT.PFL</span> y el sistema SAP® puede reiniciarse.</p></div></div><div class=sect4><h5 id=ora-00001>10.7.13.6. ORA-00001<a class=anchor href=#ora-00001></a></h5><div class=paragraph><p>Este error solo aparece con Oracle® 8.1.7 en FreeBSD 4.5. Se debe a que la base de datos Oracle® no puede inicializarse correctamente y se viene abajo, dejando semáforos y memoria compartida en el sistema. El siguiente intento de iniciar la base de datos produce el error ORA-00001.</p></div><div class=paragraph><p>Encuéntrelos con <code>ipcs -a</code> y elimínelos con <code>ipcrm</code>.</p></div></div><div class=sect4><h5 id=ora-00445pmon>10.7.13.7. ORA-00445 (Brackground Process PMON Did Not Start)<a class=anchor href=#ora-00445pmon></a></h5><div class=paragraph><p>Este error tuvo lugar con Oracle® 8.1.7. Aparece si se arranca la base de datos con el "script" <code>startsap</code> (por ejemplo <code>startsap_majestix_00</code>) con el usuario <code>prdadm</code>.</p></div><div class=paragraph><p>Una solución (entre otras) es iniciar la base de datos con el usuario <code>oraprd</code> en lugar de hacerlo con <code>svrmgrl</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% svrmgrl
SVRMGR&gt; connect internal<span class=p>;</span>
SVRMGR&gt; startup<span class=p>;</span>
SVRMGR&gt; <span class=nb>exit</span></code></pre></div></div></div><div class=sect4><h5 id=ora-12546>10.7.13.8. ORA-12546 (Start Listener with Correct Permissions)<a class=anchor href=#ora-12546></a></h5><div class=paragraph><p>Inicie la escucha de Oracle® como usuario <code>oraids</code> con la siguiente orden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># umask 0; lsnrctl start</span></code></pre></div></div><div class=paragraph><p>De no ser así puede encontrarse con el error ORA-12546, ya que los sockets no tendrán los permisos adecuados. Consulte la nota de SAP® 0072984.</p></div></div><div class=sect4><h5 id=ora-27102>10.7.13.9. ORA-27102 (Out of Memory)<a class=anchor href=#ora-27102></a></h5><div class=paragraph><p>Este error ocurre al tratar de usar valores mayores a 1 GB (1024x1024x1024) en <code>MAXDSIZ</code> y <code>DFLDSIZ</code>. Recibiremos, además, este otro error: <code>Linux Error 12: Cannot allocate memory</code>.</p></div></div><div class=sect4><h5 id=dipgntabindind>10.7.13.10. [DIPGNTAB_IND_IND] during <code>R3SETUP</code><a class=anchor href=#dipgntabindind></a></h5><div class=paragraph><p>Consulte la nota de SAP® 0130581 de (<code>R3SETUP</code> step (<code>DIPGNTAB</code> terminates). Por alguna razón durante la instalación específica IDES el proceso de instalación no usaba el nombre de sistema correcto SAP®"IDS" sino la cadena vacía <code>""</code>. Esto provocaba algunos errores menores en el acceso a directorios, ya que las rutas se generan dinámicamente en base a dicho <em>SID</em> (en este caso IDS). En lugar de ejecutar los accesos del siguiente modo :</p></div><div class="literalblock programlisting"><div class=content><pre>/usr/sap/IDS/SYS/...
/usr/sap/IDS/DVMGS00</pre></div></div><div class=paragraph><p>se usaron las siguientes rutas:</p></div><div class="literalblock programlisting"><div class=content><pre>/usr/sap//SYS/...
/usr/sap/D00</pre></div></div><div class=paragraph><p>Para continuar con la instalación creamos un enlace y un directorio adicional:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pwd</span>
/compat/linux/usr/sap
<span class=c># ls -l</span>
total 4
drwxr-xr-x 3  idsadm sapsys 512 May 5 11:20 D00
drwxr-x--x 5  idsadm sapsys 512 May 5 11:35 IDS
lrwxr-xr-x 1  root   sapsys 7 May 5 11:35 SYS -&gt; IDS/SYS
drwxrwxr-x 2  idsadm sapsys 512 May 5 13:00 tmp
drwxrwxr-x 11 idsadm sapsys 512 May 4 14:20 trans</code></pre></div></div><div class=paragraph><p>Encontramos una descripción de este comportamiento en las notas de SAP®. (0029227 y 0008401). En la instalación de SAP® 4.6C no tuvimos estos problemas.</p></div></div><div class=sect4><h5 id=rfcrswboiniindind>10.7.13.11. [RFCRSWBOINI_IND_IND] during <code>R3SETUP</code><a class=anchor href=#rfcrswboiniindind></a></h5><div class=paragraph><p>Durante la instalación de SAP® 4.6C nos encontramos con este error, cuyo origen está en un error que tuvo lugar anteriormente durante la propia instalación. Busque en sus ficheros de log y corrija el problema.</p></div><div class=paragraph><p>Si despues de buscar en los logs el error resulta ser el correcto (revise las notas de SAP®), puede poner el <code>STATUS</code> del paso donde se produce el error de <code>ERROR</code> a <code>OK</code> (en el fichero <span class=filename>CENTRDB.R3S</span>) y reiniciar <code>R3SETUP</code>. Una vez finalizada la instalación, tiene que ejecutar el informe <code>RSWBOINS</code> de la transacción SE38. Consulte la nota SAP® 0162266 para más información sobre las fases <code>RFCRSWBOINI</code> y <code>RFCRADDBDIF</code>.</p></div></div><div class=sect4><h5 id=rfcraddbdifindind>10.7.13.12. [RFCRADDBDIF_IND_IND] during <code>R3SETUP</code><a class=anchor href=#rfcraddbdifindind></a></h5><div class=paragraph><p>Aquí sucede lo mismo de antes, asegúrese, revisando los logs, de que la causa de este error no esté en algún problema previo.</p></div><div class=paragraph><p>Si en la nota de SAP® 0162266 está la solución ponga el <code>STATUS</code> del paso donde se produce el error de <code>ERROR</code> a <code>OK</code> (en el fichero <span class=filename>CENTRDB.R3S</span>) y reinicie <code>R3SETUP</code>. Una vez finalizada la instalación ejecute el informe <code>RADDBDIF</code> desde la transacción SE38.</p></div></div><div class=sect4><h5 id=sigactionsig31>10.7.13.13. sigaction sig31: File size limit exceeded<a class=anchor href=#sigactionsig31></a></h5><div class=paragraph><p>Este error ocurrió durante el inicio del proceso SAP®<em>disp+work</em>. Si inicia SAP® con el "script" <code>startsap</code> se inician los subprocesos que se separan y hacen el "trabajo sucio" de iniciar el resto de procesos de SAP®, pero es importante saber que el propio "script" no notará si algo ha ido mal.</p></div><div class=paragraph><p>Puede revisar si los procesos SAP® se iniciaron correctamente con <code>ps ax | grep SID</code>, que le proporcionará una lista de todos los procesos de Oracle® y de SAP®. Si parece que algunos procesos no están, o si no puede conectarse al sistema SAP® revise los logs que encontrará en <span class=filename>/usr/sap/SID/DVEBMGSnr/work/</span>. Los ficheros que debe revisar son <span class=filename>dev_ms</span> y <span class=filename>dev_disp</span>.</p></div><div class=paragraph><p>La señal 31 aparece si la cantidad de memoria compartida asignada a Oracle® y SAP® supera la definida dentro del fichero de configuración del kernel y puede resolverse usando un valor mayor:</p></div><div class="literalblock programlisting"><div class=content><pre># larger value for 46C production systems:
options SHMMAXPGS=393216
# smaller value sufficient for 46B:
#options SHMMAXPGS=262144</pre></div></div></div><div class=sect4><h5 id=saposcolfails>10.7.13.14. Start of <code>saposcol</code> Failed<a class=anchor href=#saposcolfails></a></h5><div class=paragraph><p>Hay algunos problemas con el programa <code>saposcol</code> (version 4.6D). El sistema SAP® utiliza <code>saposcol</code> para recoger datos del rendimiento del sistema. Este programa no es necesario para usar el sistema SAP®, así que el problema puede considerarse como poco importante. La versión más antigua (4.6B) funciona, pero no recoge todos los datos (muchas llamadas devolverán un 0, por ejemplo el uso de CPU).</p></div></div></div></div><div class=sect2><h3 id=linuxemu-advanced>10.8. Temas avanzados<a class=anchor href=#linuxemu-advanced></a></h3><div class=paragraph><p>Si siente curiosidad por saber cómo funciona la compatibilidad con Linux esta es la sección que debe leer. La mayor parte de lo que sigue está basado casi en su totalidad en un mensaje enviado por Terry Lambert <a href=mailto:tlambert@primenet.com>tlambert@primenet.com</a> a la lista <a href=https://lists.FreeBSD.org/subscription/freebsd-chat>Lista de charla de FreeBSD</a> (Message ID: <code>&lt;<a href=mailto:199906020108.SAA07001@usr09.primenet.com>199906020108.SAA07001@usr09.primenet.com</a>></code>).</p></div><div class=sect3><h4 id=_cómo_funciona>10.8.1. ?Cómo funciona?<a class=anchor href=#_cómo_funciona></a></h4><div class=paragraph><p>FreeBSD dispone de una abstracció denominada "cargador de clase en ejecución". Esto no es más que un bloque de código incrustado en la llamada <a href="https://man.freebsd.org/cgi/man.cgi?query=execve&amp;sektion=2&amp;format=html">execve(2)</a> del sistema.</p></div><div class=paragraph><p>Históricamente las plataformas UNIX® disponían de un único cargador de binarios, que en última instancia (<em>fallback</em>) recurría al cargador <code>#!</code> para ejecutar cualesquiera intérpretes o scripts de la shell. Ese cargador único examinaba el número mágico (generalmente los 4 u 8 primeros bytes del fichero) para ver si era un binario reconocible por el sistema y, en tal caso, invocaba al cargador binario.</p></div><div class=paragraph><p>Si no era de tipo binario, la llamada <a href="https://man.freebsd.org/cgi/man.cgi?query=execve&amp;sektion=2&amp;format=html">execve(2)</a> devolvía un error y la shell intentaba empezar a ejecutarlo como órdenes shell, tomando por defecto como punto de partida "la shell actual, sea cual sea".</p></div><div class=paragraph><p>Posteriormente se pensó en hacer una modificación de manera que <a href="https://man.freebsd.org/cgi/man.cgi?query=sh&amp;sektion=1&amp;format=html">sh(1)</a> examinara los dos primeros caracteres, de modo que si eran <code>:\n</code> se llamaba a la shell <a href="https://man.freebsd.org/cgi/man.cgi?query=csh&amp;sektion=1&amp;format=html">csh(1)</a> en su lugar (parece ser que en SCO fueron los primeros en utilizar ese truco).</p></div><div class=paragraph><p>Lo que ocurre ahora es que FreeBSD dispone de una lista de cargadores, en lugar de uno solo. FreeBSD recorre esa lista de cargadores, con un cargador genérico <code>#!</code> que sabe reconocer los intérpretes en base a los caracteres que siguen al siguiente espacio en blanco, con <span class=filename>/bin/sh</span> como último recurso.</p></div><div class=paragraph><p>Para dar soporte a la ABI ("Application Binary Interface") de Linux, FreeBSD interpreta el número mágico como un binario ELF ("Executable and Linking Format"): En este punto no hace distinción entre FreeBSD, Solaris™, Linux® o cualquier otro SO que tenga un tipo de imagen ELF.</p></div><div class=paragraph><p>El cargador ELF busca entonces una marca (<em>brand</em>) especial, una sección de comentarios en la imagen ELF que no está presente en los binarios ELF de SVR4/Solaris™.</p></div><div class=paragraph><p>Para que los binarios de Linux funcionen deben estar marcados con <a href="https://man.freebsd.org/cgi/man.cgi?query=brandelf&amp;sektion=1&amp;format=html">brandelf(1)</a> como tipo <code>Linux</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># brandelf -t Linux file</span></code></pre></div></div><div class=paragraph><p>Hecho esto el cargador ELF verá la marca <code>Linux</code> en el fichero.</p></div><div class=paragraph><p>Cuando el cargador ELF ve la marca <code>Linux</code> sustituye un puntero en la estructura <code>proc</code>. Todas las llamadas del sistema se indexan a través de este puntero (en un sistema UNIX® tradicional sería el «array» de estructura <code>sysent[]</code> que contiene las llamadas del sistema). Además, el proceso se marca con unos indicadores ("flags") para que el vector trampa del código de envío señales lo maneje de una forma determinada, así como otros arreglos (menores) que serán utilizados por el módulo Linux del kernel.</p></div><div class=paragraph><p>El vector de llamada del sistema Linux contiene, entre otras cosas, una lista de entradas <code>sysent[]</code> cuyas direcciones residen en el módulo del kernel.</p></div><div class=paragraph><p>Cuando el binario Linux realiza una llamada al sistema, el código trampa extrae el puntero a la función de la llamada del sistema de la estructura <code>proc</code>, y así obtiene los puntos de entrada a las llamadas del sistema Linux, no las de FreeBSD.</p></div><div class=paragraph><p>Además, el modo Linux cambia la raíz de las búsquedas de una forma dinámica. En efecto, esto es lo que hace la opción <code>union</code> cuando se monta un sistema de ficheros (¡y que <em>no</em> es lo mismo que el sistema de ficheros <code>unionfs</code>!). Primero se hace un intento de buscar el fichero en el directorio <span class=filename>/compat/linux/ruta-original</span> y <em>solo después</em>, si lo anterior falla, se repite la búsqueda en el directorio <span class=filename>/ruta-original</span>. Esto permite que se puedan ejecutar binarios que necesitan de otros binarios (por ejemplo las herramientas de programación ("toolchain") de Linux pueden ejecutarse en su totalidad bajo la ABI de Linux). Esto significa también que los binarios Linux pueden cargar y ejecutar binarios FreeBSD si los binarios Linux equivalentes no se hallan presentes y que se puede poner una orden <a href="https://man.freebsd.org/cgi/man.cgi?query=uname&amp;sektion=1&amp;format=html">uname(1)</a> en el árbol de directorios <span class=filename>/compat/linux</span> para poder estar seguros de que los binarios Linux no puedan decir que no estaban ejecutándose en Linux.</p></div><div class=paragraph><p>En efecto, hay un kernel Linux en el kernel FreeBSD; las distintas funciones subyacentes que implementan todos los servicios proporcionados por el kernel son idénticas en ambas, las tablas de entradas de llamadas del sistema en FreeBSD y en Linux: operaciones del sistema de ficheros, operaciones de memoria virtual, envío de señales IPC System V, etc. La única diferencia es que los binarios FreeBSD reciben sus funciones de conexión ("<em>glue</em>") y los binarios Linux las suyas (la mayoría de los sistemas operativos más antiguos solo tienen sus propias funciones de conexión: direcciones de funciones en un "array" de estructura <code>sysent[]</code> estática y global, en lugar de direcciones de funciones que se extraen a partir de un puntero inicializado dinámicamente en la estructura <code>proc</code> del proceso que hace la llamada).</p></div><div class=paragraph><p>?Cuál es entonces la ABI nativa de FreeBSD? No importa. Básicamente, la única diferencia es (ahora mismo; esto podría cambiar y probablemente lo hará en una release futura) que las funciones de conexión de FreeBSD están enlazadas estáticamente en el kernel mientras que las de Linux pueden estarlo también estáticamente o se puede acceder a ellas por medio de un módulo del kernel.</p></div><div class=paragraph><p>Bien, pero ?de verdad es esto una emulación? No. Es una implementación ABI, no una emulación. No hay un emulador involucrado (ni un simulador, para adelantarnos a la siguiente pregunta).</p></div><div class=paragraph><p>Entonces ?por qué a veces se le llama "emulación Linux"? ¡Para hacer más difícil el vender FreeBSD! En serio, se debe a que la primera implementación se hizo en un momento en que realmente no había ninguna palabra distinta a esa para describir lo que se estaba haciendo; decir que FreeBSD ejecutaba binarios Linux no era cierto si no se compilaba el código o se cargaba un módulo; hacía falta una forma de describir todo esto y acabamos usando "emulador Linux".</p></div></div></div></div></div><h1 id=system-administration class=sect0>Parte III: Administración del sistema.<a class=anchor href=#system-administration></a></h1><div class="openblock partintro"><div class=content><div class=paragraph><p>Los restantes capítulos de este libro cubren todos los aspectos de administración de un sistema FreeBSD. Cada capítulo comienza describiendo lo que será aprendido una vez finalizada la lectura, explicando también los conocimientos mínimos necesarios para una comprensión satisfactoria del texto.</p></div><div class=paragraph><p>Estos capítulos están diseñados para leerse cuando se necesita la información. No es necesario leerlos en un determinado orden ni es necesario leerlos todos antes de comenzar a usar FreeBSD.</p></div></div></div><div class=sect1><h2 id=config-tuning>Capítulo 11. Configuración y Adaptación del Sistema<a class=anchor href=#config-tuning></a></h2><div class=sectionbody><div class=sect2><h3 id=config-network-setup>11.1. Configuración de Tarjetas de Red<a class=anchor href=#config-network-setup></a></h3><div class=paragraph><p>Pendiente de Traducción</p></div></div><div class=sect2><h3 id=configtuning-starting-services>11.2. "Arrancar servicios"<a class=anchor href=#configtuning-starting-services></a></h3><div class=paragraph><p>Pendiente de Traducción</p></div></div><div class=sect2><h3 id=soft-updates>11.3. "Soft Updates"<a class=anchor href=#soft-updates></a></h3><div class=paragraph><p>Pendiente de Traducción</p></div></div><div class=sect2><h3 id=adding-swap-space>11.4. Añadir espacio swap<a class=anchor href=#adding-swap-space></a></h3><div class=paragraph><p>Pendiente de traducción</p></div></div></div></div><div class=sect1><h2 id=boot>Capítulo 12. El proceso de arranque en FreeBSD<a class=anchor href=#boot></a></h2><div class=sectionbody><div class=sect2><h3 id=boot-synopsis>12.1. Sinopsis<a class=anchor href=#boot-synopsis></a></h3><div class=paragraph><p>Al proceso de inicio del sistema y carga del sistema operativo se le conoce como "mecanismo de arranque" (bootstrap), o simplemente "arranque" (booting). El proceso de arranque de FreeBSD provee de gran flexibilidad al configurar lo que ocurre cuando se inicia el sistema, permitiendole seleccionar de diferentes sistemas operativos instalados en el mismo ordenador, o inclusive diferentes versiones del mismo sistema oprativo o kernels instalados.</p></div><div class=paragraph><p>Este capítulo detalla las opciones de configuración que puede manejar y como personalizar el proceso de arranque de FreeBSD. Esto incluye todo lo que sucede hasta que el kernel de FreeBSD comienza con la comprobación de dispositivos y se inicializa <a href="https://man.freebsd.org/cgi/man.cgi?query=init&amp;sektion=8&amp;format=html">init(8)</a>. En caso de que usted desconozca cuando ocurre todo esto, esto sucede cuando el color del texto que aparece al iniciar el sistema, cambia de blanco a gris.</p></div><div class=paragraph><p>Una vez que concluya con la lectura de este capítulo, usted sabrá:</p></div><div class=ulist><ul><li><p>Cuales son los componentes del mecanismo de arranque de FreeBSD, y como es que interactuan entre sí.</p></li><li><p>Las opciones que puede manejar con los componentes del mecanismo de arranque de FreeBSD, para controlar el proceso de inicio del sistema.</p></li></ul></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=title>Sólo x86</div><div class=paragraph><p>El presente capítulo describe únicamente el proceso de inicio, para sistemas FreeBSD que corren en plataformas Intel x86.</p></div></td></tr></tbody></table></div></div><div class=sect2><h3 id=boot-introduction>12.2. El problema que representa arrancar el sistema<a class=anchor href=#boot-introduction></a></h3><div class=paragraph><p>El encender una computadora e iniciar el sistema operativo, trae consigo un dilema interesante. Por definición, la computadora no sabe hacer nada, hasta que el sistema operativo ha sido cargado. Esto incluye la ejecución de programas desde el disco duro. Así que este es el dilema; si la computadora no sabe hacer nada hasta que se cargue el sistema operativo, y el sistema operativo es un conjunto de programas que residen en el disco duro, ?Cómo es que arranca el sistema operativo?</p></div><div class=paragraph><p>Este problema se asemeja a un problema del libro Las Aventuras del Barón Munchausen. Donde un personaje ha caido parcialmente en un hoyo, y ha podido salir al tomarse de las cintas de sus botas y jalarse hacia fuera. En los años mozos de la computación, el término utilizado para hablar sobre el proceso de carga del sistema operativo era <em>mecanismo de arranque</em> (bootstrap), que por efectos de simplificación ahora conocemos como "arranque" (booting).</p></div><div class=paragraph><p>En equipos con arquitectura x86, el Sistema Básico de Entrada/Salida (BIOS) es el responsable de cargar el sistema operativo. Para hacer esto, el BIOS busca en el disco duro el Registro Maestro de Arranque (RMA) (N de T. Conocido como MBR-Master Boot Record), el cual debe localizarse en un lugar específico del disco. El BIOS cuenta con suficiente información, para cargar y ejecutar el RMA, y asumir que el RMA puede encargarse del resto de las tareas necesarias en la carga del sistema operativo.</p></div><div class=paragraph><p>Si usted sólo cuenta con un sistema operativo instalado en su disco duro, el RMA estándar será suficiente. Este RMA buscará la primer partición del disco que pueda arrancar, y posteriormente ejecutará el código restante de dicha partición, para efecto de completar la carga del sistema operativo.</p></div><div class=paragraph><p>Si usted cuenta con varios sistemas operativos instalados en su disco, entonces puede hacer uso de un RMA diferente, uno que despliegue una lista de los diferentes sistemas operativos, y le permita escoger cual de ellos desea que se cargue. FreeBSD cuenta con un RMA de este tipo que puede ser instalado, así como otros distribuidores de sistemas operativos cuentan con RMAs alternativos.</p></div><div class=paragraph><p>En el caso de FreeBSD, el resto del mecanismo de arranque, está dividido en tres etapas. La primer etapa es ejecutada por al RMA, que sabe lo suficiente como para poner a la computadora en un estado específico y ejecutar la segunda etapa. La segunda etapa puede hacer un poco más que esto, antes de ejecutar la tercer etapa. La tercer etapa finaliza el trabajo de carga del sistema operativo. El trabajo es dividido en tres etapas, debido a las limitantes que tiene una PC, en cuanto al tamaño de los programas a ejecutar, durante las etapas uno y dos. El encadenar estas tareas, le permiten a FreeBSD contar con un arrancador más flexible.</p></div><div class=paragraph><p>Posteriormente el kernel es inicializado y comienza con la comprobación de dispositivos, y prepararlos para su uso. Una vez que el proceso de arranque del kernel ha finalizado, el kernel transfiere el control al proceso de usuario <a href="https://man.freebsd.org/cgi/man.cgi?query=init&amp;sektion=8&amp;format=html">init(8)</a>, quien se asegura de que los discos se encuentren en buen estado para su uso. Posteriormente <a href="https://man.freebsd.org/cgi/man.cgi?query=init&amp;sektion=8&amp;format=html">init(8)</a> inicia la configuración fuente a nivel de usuario, que monta los sistemas de ficheros, configura las tarjetas de red para que pueden comunicarse en la red, y comunmente inicia todos los procesos que normalmente son ejecutados en un sistema FreeBSD al arrancar el mismo.</p></div></div><div class=sect2><h3 id=boot-blocks>12.3. El RMA y las etapas de arranque uno, dos y tres<a class=anchor href=#boot-blocks></a></h3><div class=sect3><h4 id=boot-boot0>12.3.1. RMA, <span class=filename>/boot/boot0</span><a class=anchor href=#boot-boot0></a></h4><div class=paragraph><p>El RMA de FreeBSD, se localiza en <span class=filename>/boot/boot0</span>. Este es una <em>copia</em> del RMA, ya que el RMA real debe localizarse en una parte especial del disco duro, fuera de la área de FreeBSD.</p></div><div class=paragraph><p>El fichero <span class=filename>boot0</span> es muy simple, dado que el programa en el sólo puede ser de 512 bytes. Si usted ha instalado el RMA de FreeBSD y ha instalado varios sistemas operativos en sus discos duros, entonces al momento de arrancar el sistema, visualizará una pantalla similar a la siguiente.</p></div><div id=boot-boot0-example class=exampleblock><div class=title>Ejemplo 7. Pantalla <span class=filename>boot0</span></div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>F1 DOS
F2 FreeBSD
F3 Linux
F4 ??
F5 Drive 1

Default: F2</code></pre></div></div></div></div><div class=paragraph><p>Es sabido que otros sistemas, en particular Windows 95, sobreescriben el RMA con el suyo. Si esto le sucede, o bien desea reemplazar su RMA actual con el RMA de FreeBSD, entonces puede utilizar las siguientes órdenes.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># fdisk -B -b /boot/boot0 dispositivo</span></code></pre></div></div><div class=paragraph><p>Donde <em>dispositivo</em> es aquel, desde el cual usted pretende arrancar el sistema, tal como <span class=filename>ad0</span> para el disco conectado al primer IDE, <span class=filename>ad2</span> para el disco maestro conectado al IDE secundario, <span class=filename>da0</span> para el primer disco SCSI, y así sucesivamente.</p></div><div class=paragraph><p>Por otro lado, si usted es un usuario de Linux, y prefiere que la aplicación LILO controle el proceso de arranque, puede editar el fichero <span class=filename>/etc/lilo.conf</span> para incluir a FreeBSD, o bien seleccionar la opción <code>Leave The Master Boot Record Untouched</code> durante el proceso de instalación. Si ha instalado el gestor de arranque de FreeBSD, puede arrancar Linux y modificar el fichero de configuración de LILO, <span class=filename>/etc/lilo.conf</span>, añadiendo la siguiente opción:</p></div><div class="literalblock programlisting"><div class=content><pre>other=/dev/hdXY
table=/dev/hdb
loader=/boot/chain.b
label=FreeBSD</pre></div></div><div class=paragraph><p>lo que permitirá el arranque de FreeBSD y Linux, por medio de LILO. En nuestro ejemplo hemos utilizado <em>XY</em> para especificar el disco utilizado y su partición. Si usted utiliza un sistema SCSI, deberá cambiar <em>/dev/hdXY</em> por algo similar a <em>/dev/sdXY</em>, que nuevamente utiliza la sintáxis <em>XY</em>. La opción <code>loader=/boot/chain.b</code> puede omitirse si usted cuenta con ambos sistemas operativos en el mismo disco. Una vez que esto se ha completado, puede ejecutar <code>/sbin/lilo -v</code> para que se actualicen los cambios en el sistema, lo cual deberá verificarse con los mensajes que aparezcan en pantalla.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>N de T: La opción mencionada como; <code>Leave The Master Boot Record Untouched</code>, se mostrará "tal cual" aparece en este documento, una vez que ha terminado la fase de partición del disco duro.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=boot-boot1>12.3.2. Etapa uno, <span class=filename>/boot/boot1</span>, y etapa dos, <span class=filename>/boot/boot2</span><a class=anchor href=#boot-boot1></a></h4><div class=paragraph><p>Conceptualmente las estapas uno y dos, son parte del mismo programa, en la misma área del disco. Por cuestiones de espacio se han dividido en dos, pero estas siempre se instalaran de manera conjunta.</p></div><div class=paragraph><p>Estas son localizadas en el sector de arranque, de la partición de arranque, que es donde <a href=#boot-boot0>boot0</a>, o cualquier otro programa del espera encontrar el programa que dará continuación al proceso de arranque. Los ficheros localizados bajo el directorio <span class=filename>/boot</span> son copias de los ficheros reales, que se localizan fuera del sistema de ficheros de FreeBSD.</p></div><div class=paragraph><p>El fichero <span class=filename>boot1</span> es muy simple, en virtud de que sólo puede tener un tamaño de 512 bytes, y conocer simplemente del etiquetador de discos de FreeBSD (<em>disklabel</em>), el cual almacena la información de las particiones, para efecto de localizar y ejecutar <span class=filename>boot2</span>.</p></div><div class=paragraph><p>El fichero <span class=filename>boot2</span> es un poco más sofisticado, y comprende lo suficiente del sistema de ficheros de FreeBSD como para localizar ficheros en el, y puede proveer una interfaz simple, para seleccionar el kernel o cargador que deberá ejecutarse.</p></div><div class=paragraph><p>En virtud de que el <a href=#boot-loader>cargador</a> (loader) es mucho más sofisticado, y provee una configuración de arranque más sencilla de utilizar, <span class=filename>boot2</span> la ejecuta normalmente, una vez que ha terminado de solicitar el arranque del kernel directamente.</p></div><div id=boot-boot2-example class=exampleblock><div class=title>Ejemplo 8. Pantalla de <span class=filename>boot2</span></div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=o>&gt;&gt;</span> FreeBSD/i386 BOOT
Default: 0:ad<span class=o>(</span>0,a<span class=o>)</span>/kernel
boot:</code></pre></div></div></div></div><div class=paragraph><p>Si alguna vez requiere reemplazar los ficheros <span class=filename>boot1</span> y <span class=filename>boot2</span> instalados, utilice <a href="https://man.freebsd.org/cgi/man.cgi?query=disklabel&amp;sektion=8&amp;format=html">disklabel(8)</a>.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># disklabel -B partición</span></code></pre></div></div><div class=paragraph><p>Donde <em>partición</em> es el disco y partición del cual pretende arrancar el sistema, tal como <span class=filename>ad0s1</span> para la primer partición del disco Mastro-Primario.</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=title>Modo peligrosamente dedicado</div><div class=paragraph><p>Si sólo utiliza el nombre del disco, tal como <span class=filename>ad0</span>, al usar <a href="https://man.freebsd.org/cgi/man.cgi?query=disklabel&amp;sektion=8&amp;format=html">disklabel(8)</a> creará un disco peligrosamente dedicado, sin partición alguna. Seguramente esto no es lo que desea hacer, así que asegurese dos veces antes de presionar la tecla <kbd>Return</kbd> cuando utilice <a href="https://man.freebsd.org/cgi/man.cgi?query=disklabel&amp;sektion=8&amp;format=html">disklabel(8)</a>.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=boot-loader>12.3.3. Etapa tres, <span class=filename>/boot/loader</span> (cargador de arranque)<a class=anchor href=#boot-loader></a></h4><div class=paragraph><p>El cargador es la etapa final de las tres etapas del mecanismo de arranque, y esta localizado en el sistema de ficheros, normalmente como <span class=filename>/boot/loader</span>.</p></div><div class=paragraph><p>El cargador pretende ser un metodo amistoso de configuración, utilizando una serie de órdenes integradas de fácil uso, respaldado por un intérprete más poderoso, con una serie de órdenes de mayor complejidad.</p></div><div class=sect4><h5 id=boot-loader-flow>12.3.3.1. Flujo del programa cargador<a class=anchor href=#boot-loader-flow></a></h5><div class=paragraph><p>Durante la inicialización del sistema, el cargador hará una comprobación en busca de una consola y discos, y sabra de que disco se encuentra arrancando. Establecerá las variables necesarias, y posteriormente es iniciado el intérprete donde se pueden introducir órdenes desde un "script" o de manera interactiva.</p></div><div class=paragraph><p>Posteriormente el cargador leerá el fichero <span class=filename>/boot/loader.rc</span>, que por default lee la información del fichero <span class=filename>/boot/defaults/loader.conf</span> que a su vez, establece las variables correspondientes y verifica en el fichero <span class=filename>/boot/loader.conf</span> los cambios locales que se hayan hecho, para establecer valores de las variables modificadas. Una vez llevado a cabo esto, <span class=filename>loader.rc</span> actua sobre estas variables, cargando cualquier módulo y kernel seleccionado.</p></div><div class=paragraph><p>Finalmente, y por default, el cargador hace una pausa contando 10 segundos y en espera de que al presionar una tecla se interrumpa el proceso, de no ser así, procederá a arrancar el kernel. En el caso de que al hacer esta pausa, se haya presionado una tecla (diferente de <kbd>Return</kbd>), el proceso será interrumpido y se nos mostrará un "prompt", que entiende el conjunto de órdenes de fácil-uso, y donde el usuario puede ajustar ciertas variables, cargar y descargar todos los módulos, y también arrancar o reiniciar el sistema.</p></div></div><div class=sect4><h5 id=boot-loader-commands>12.3.3.2. Órdenes internas del cargador<a class=anchor href=#boot-loader-commands></a></h5><div class=paragraph><p>A continuación se presentan las órdenes más comunes del cargador. Para ver una descripción detallada de los mismos, por favor consulte la página de manual de <a href="https://man.freebsd.org/cgi/man.cgi?query=loader&amp;sektion=8&amp;format=html">loader(8)</a></p></div><div class=dlist><dl><dt class=hdlist1>autoboot <em>segundos</em></dt><dd><p>Procede a iniciar el arranque del sistema, si es que no es interrumpido el periodo dado, en segundos. Despliega una cuenta regresiva, y el tiempo dado es de 10 segundos.</p></dd><dt class=hdlist1>boot [-opciones] [nombre_del_kernel]</dt><dd><p>Procede a iniciar el kernel de manera inmediata, con las opciones dadas, si es que fuera el caso y el kernel especificado, si es que se especifica alguno.</p></dd><dt class=hdlist1>boot-conf</dt><dd><p>Rehace la configuración automática de modulos en función a las variables definidas, como sucede al arrancar. Esta opción sólo tiene sentido utilizarla, si en primer lugar hemos usado <code>unload</code>, y hemos modificado alguna variable, siendo lo más común el <code>kernel</code>.</p></dd><dt class=hdlist1>help [tema]</dt><dd><p>Muestra la ayuda de un tema específico, que lee del fichero <span class=filename>/boot/loader.help</span>. Si el tema que se indica es <code>index</code>, entonces se mostrará una lista de todos los temas disponibles.</p></dd><dt class=hdlist1>include <em>fichero</em> …​</dt><dd><p>Procesa el fichero que se ha especificado. El fichero se lee e interpreta línea por línea. Cualquier error detendrá inmediatamente a include.</p></dd><dt class=hdlist1>load [-t tipo] <em>fichero</em></dt><dd><p>Carga el kernel, modulo del kernel, o el fichero del tipo dado, en base al fichero especificado. Cualquier argumento que se añada, será pasado al fichero.</p></dd><dt class=hdlist1>ls [-l] [ruta]</dt><dd><p>Despliega un listado de todos los ficheros que se localizan en la ruta especificada, o en el directorio raíz, si es que no se le especifica ruta alguna. Si se utiliza la opción <code>-l</code>, también se mostrara el tamaño de los ficheros.</p></dd><dt class=hdlist1>lsdev [-v]</dt><dd><p>Nos muestra una lista de todos los dispositivos desde los cuales puede ser posible cargar modulos. Si se incluye la opción <code>-v</code>, el listado que se obtiene cuenta con más detalle.</p></dd><dt class=hdlist1>lsmod [-v]</dt><dd><p>Despliega los módulos cargados. Si se utiliza la opción <code>-v</code>, se mostraran más detalles.</p></dd><dt class=hdlist1>more <em>fichero</em></dt><dd><p>Despliega el contenido del fichero especificado, haciendo una pausa a cada numero determinado de <code>LINEAS</code> mostradas.</p></dd><dt class=hdlist1>reboot</dt><dd><p>Reinicia el sistema de forma inmediata.</p></dd><dt class=hdlist1>set <em>variable</em></dt><dd><p>Especifica los valores de las variables de entorno del cargador.</p></dd><dt class=hdlist1>unload</dt><dd><p>Remueve todos los módulos cargados.</p></dd></dl></div></div><div class=sect4><h5 id=boot-loader-examples>12.3.3.3. Ejemplos de uso del cargador<a class=anchor href=#boot-loader-examples></a></h5><div class=paragraph><p>He aqui unos ejemplos prácticos sobre el uso correcto del cargador.</p></div><div class=ulist><ul><li><p>Para arrancar simplemente su kernel usual, pero en modo mono-usuario, deberá hacer lo siguiente:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> boot <span class=nt>-s</span></code></pre></div></div></li><li><p>Para descargar su kernel usual y sus módulos correspondientes, y posteriormente cargar su kernel anterior (o cualquier otro):</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>unload
load kernel.old</code></pre></div></div><div class=paragraph><p>Puede utilizar <span class=filename>kernel.GENERIC</span> para referirse al kernel generico actual que viene con la instalación, o bien puede utilizar <span class=filename>kernel.old</span> para hacer referencia al kernel anterior (por ejemplo, cuando ha actualizado su sistema o ha recompilado su propio kernel).</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Utilice lo siguiente para cargar sus módulos actuales con otro kernel:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>unload
<span class=nb>set </span><span class=nv>kernel</span><span class=o>=</span><span class=s2>&#34;kernel.old&#34;</span>
boot-conf</code></pre></div></div></td></tr></tbody></table></div></li><li><p>Para cargar un escrito de configuración (script que de forma automática hará todo lo que normalmente hace usted de forma manual al momento de ejecutarse el configurador de arranque):</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell> load <span class=nt>-t</span> escrito_de_configuración /boot/kernel.conf</code></pre></div></div></li></ul></div></div></div></div><div class=sect2><h3 id=boot-kernel>12.4. Interacción con el kernel durante el arranque<a class=anchor href=#boot-kernel></a></h3><div class=paragraph><p>Una vez que el kernel ha sido iniciado, ya sea por el <a href=#boot-loader>cargador</a> (que es lo común) o bien por <a href=#boot-boot1>boot2</a> (sobrepasando el cargador), examinará las opciones de arranque, en busca de cambios, y ajustar su comportamiento en caso de ser necesario.</p></div><div class=sect3><h4 id=boot-kernel-bootflags>12.4.1. Opciones de arranque del kernel<a class=anchor href=#boot-kernel-bootflags></a></h4><div class=paragraph><p>He aqui las opciones de arranque más comunes:</p></div><div class=dlist><dl><dt class=hdlist1><code>-a</code></dt><dd><p>durante la inicialización del kernel, pregunta por los dispositivos a utilizar, para montar el sistema de ficheros raíz.</p></dd><dt class=hdlist1><code>-C</code></dt><dd><p>arranque desde una unidad de CDROM.</p></dd><dt class=hdlist1><code>-c</code></dt><dd><p>ejecuta UserConfig, la utilidad de configuración de arranque del kernel.</p></dd><dt class=hdlist1><code>-s</code></dt><dd><p>arranca el sistem en modo mono-usuario.</p></dd><dt class=hdlist1><code>-v</code></dt><dd><p>imprime mensajes informativos durante el arranque del kernel</p></dd></dl></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Existen otras opciones de arranque, por favor vea la página de ayuda <a href="https://man.freebsd.org/cgi/man.cgi?query=boot&amp;sektion=8&amp;format=html">boot(8)</a> para más información al respecto.</p></div></td></tr></tbody></table></div></div></div><div class=sect2><h3 id=device-hints>12.5. Device Hints<a class=anchor href=#device-hints></a></h3><div class=paragraph><p>Pendiente de Traducción</p></div></div><div class=sect2><h3 id=boot-init>12.6. Init: inicialización del proceso de control<a class=anchor href=#boot-init></a></h3><div class=paragraph><p>Ya que el kernel ha finalizado de arrancar, pasará el control a un proceso de usuario llamado <code>init</code>, el cual se localiza en <span class=filename>/sbin/init</span>, o bien en la ruta especificada por la variable de entorno <code>init_path</code> del cargador.</p></div><div class=sect3><h4 id=boot-autoreboot>12.6.1. Secuencia automática de reinicio<a class=anchor href=#boot-autoreboot></a></h4><div class=paragraph><p>La secuencia automática de reinicio se asegura de que los sistemas de ficheros disponibles en el sistema sean consistentes. Si no lo son, y el programa <code>fsck</code> no puede arreglar estas inconsistencias, <code>init</code> envia el sistema a modo <a href=#boot-singleuser>monousuario</a>, de tal forma que el administrador pueda ingresar en él y arreglar los problemas directamente.</p></div></div><div class=sect3><h4 id=boot-singleuser>12.6.2. Modo monousuario<a class=anchor href=#boot-singleuser></a></h4><div class=paragraph><p>A este modo se puede llegar por medio de la <a href=#boot-autoreboot>secuencia automática de reinicio</a>, o por medio de la opción <code>-s</code> en el arranque de usuario o al establecer la variable <code>boot_single</code> en el cargador.</p></div><div class=paragraph><p>También desde el modo <a href=#boot-multiuser>multi-usuario</a> se puede acceder, al utilizar <code>shutdown</code> sin la opción de reinicio (<code>-r</code>) o la de apagado (<code>-h</code>) del sistema.</p></div><div class=paragraph><p>Si la consola del sistema esta configurada de modo <code>inseguro</code> en el fichero <span class=filename>/etc/ttys</span>, entonces el sistema solicitará la contraseña del <code>superusuario</code> (root), antes de ingresar al sistema en modo mono-usuario.</p></div><div id=boot-insecure-console class=exampleblock><div class=title>Ejemplo 9. Una consola insegura en /etc/ttys</div><div class=content><div class="literalblock programlisting"><div class=content><pre># name  getty                           type    status          comments
#
# If console is marked &#34;insecure&#34;, then init will ask for the root password
# when going to single-user mode.
console none                            unknown off insecure</pre></div></div></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Una consola <code>insegura</code> significa que usted considera como insegura físicamente su consola, por lo que desea asegurarse de que sólo quien conoce la contraseña del <code>superusuario</code> puede ingresar al sistema en modo mono-usuario, y no que desea ejecutar la consola inseguramente. Esto es, si desea contar con seguridad escoja la opción <code>insecure</code>, y no <code>secure</code>.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=boot-multiuser>12.6.3. Modo multiusuario<a class=anchor href=#boot-multiuser></a></h4><div class=paragraph><p>En el caso de que <code>init</code> encuentre en buen estado al sistema de ficheros, o una vez que el usuario ha terminado del modo <a href=#boot-singleuser>mono-usuario</a>, el sistema entrará al modo multi-usuario, en donde comienzan los ficheros de configuración-fuente del sistema.</p></div><div class=sect4><h5 id=boot-rc>12.6.3.1. Configuración-Fuente(rc)<a class=anchor href=#boot-rc></a></h5><div class=paragraph><p>La configuración fuente lee la configuración por default del fichero <span class=filename>/etc/defaults/rc.conf</span>, y detalles específicos del sistema desde el fichero <span class=filename>/etc/rc.conf</span>, y posteriormente procede a montar los sistemas de ficheros del sistema, descritos en <span class=filename>/etc/fstab</span>, iniciar servicios de red, así como varios demonios del sistema, para finalmente ejecutar los escritos (scripts) de configuración instalados por paquetes, localmente.</p></div><div class=paragraph><p>La página de ayuda <a href="https://man.freebsd.org/cgi/man.cgi?query=rc&amp;sektion=8&amp;format=html">rc(8)</a> es una buena referencia para conocer más de este tipo de ficheros, así como examinar los mismos ficheros.</p></div></div></div></div><div class=sect2><h3 id=boot-shutdown>12.7. Secuencia de apagado<a class=anchor href=#boot-shutdown></a></h3><div class=paragraph><p>Una vez que el apagado sea controlado, por medio de <code>shutdown</code>, <code>init</code> ejecutará el escrito <span class=filename>/etc/rc.shutdown</span>, para posteriormente enviar a todos los procesos la señal <code>TERM</code>, y subsecuentemente la señal <code>KILL</code> a cualquiera que no haya terminado en tiempo.</p></div></div></div></div><div class=sect1><h2 id=users>Capítulo 13. Usuarios y administración básica de cuentas<a class=anchor href=#users></a></h2><div class=sectionbody><div class=sect2><h3 id=users-synopsis>13.1. Sinopsis<a class=anchor href=#users-synopsis></a></h3><div class=paragraph><p>FreeBSD permite que varios usuarios usen el mismo ordenador. Obviamente, sólo uno de estos usuarios puede sentarse frente al monitor y al teclado en un momento dado , pero cualquier número de usuarios puede entrar por la red para hacer su trabajo. Para usar el sistema cada usuario ha de tener una cuenta.</p></div><div class=paragraph><p>Después de leer este capítulo sabrás:</p></div><div class=ulist><ul><li><p>Cuáles son las diferencias entre las distintas cuentas de usuario en sistemas FreeBSD.</p></li><li><p>Cómo añadir cuentas.</p></li><li><p>Cómo eliminar cuentas.</p></li><li><p>Cómo cambiar detalles de las cuentas, como el nombre completo del usuario, o su shell preferida.</p></li><li><p>Cómo establecer límites por cuenta, para controlar los recursos como memoria o tiempo de CPU que las cuentas y grupos de cuentas pueden emplear.</p></li><li><p>Cómo usar grupos para facilitar la administración de cuentas.</p></li></ul></div><div class=paragraph><p>Antes de leer este capítulo deberías:</p></div><div class=ulist><ul><li><p>Entender los conceptos básicos de Unix y FreeBSD (<a href=./#basics>Conceptos básicos de Unix</a>).</p></li></ul></div></div><div class=sect2><h3 id=users-introduction>13.2. Introducción<a class=anchor href=#users-introduction></a></h3><div class=paragraph><p>Todos los accesos al sistema se consiguen vía cuentas, y todos los procesos son ejecutados por usuarios, por ello la administración de usuarios y cuentas es de una gran importancia en sistemas FreeBSD.</p></div><div class=paragraph><p>Cada cuenta en un sistema FreeBSD tiene cierta información asociada que la identifica.</p></div><div class=dlist><dl><dt class=hdlist1>Nombre de usuario</dt><dd><p>El nombre de usuario como se le entraría al prompt <code>login:</code>. Los nombres de usuario han de ser únicos en la computadora; no puede haber dos usuarios con el mismo nombre de usuario. Existen algunas reglas para la creación de nombres de usuario válidos documentadas en <a href="https://man.freebsd.org/cgi/man.cgi?query=passwd&amp;sektion=5&amp;format=html">passwd(5)</a>; típicamente se usarían nombres de usuario de a lo sumo ocho caracteres, todos ellos en minúscula.</p></dd><dt class=hdlist1>Contraseña</dt><dd><p>Cada cuenta tiene una contraseña asociada. La contraseña puede ser vacía, en cuyo caso no se requerirá ninguna para acceder al sistema. Esto normalmente es una mala idea; cada cuenta debería tener una constraseña no vacía.</p></dd><dt class=hdlist1>Identificador de usuario (UID)</dt><dd><p>El UID es un numero entre 0 y 65536 que sirve para identificar unívocamente al usuario en el sistema. Internamente, FreeBSD usa el UID para identificar usuarios y cualquier comando de FreeBSD que permita especificar un nombre de usuario convertirá éste al UID antes de trabajar con él. Esto significa que puedes tener varias cuentas con nombres de usuario distintos pero con el mismo UID. En lo que a FreeBSD respecta, tales cuentas son un solo usuario. Es improbable que alguna vez tengas que hacer algo así.</p></dd><dt class=hdlist1>Identificador de grupo (GID)</dt><dd><p>El GID es un número entre 0 y 65536 que sirve para identificar unívocamente el grupo principal al cual pertenece un usuario. Los grupos son un mecanismo para controlar el acceso a recursos del sistema en base al GID, en vez del UID. Esto puede reducir significativamente el tamaño de algunos ficheros de configuración. Un usuario puede pertencer a más de un grupo.</p></dd><dt class=hdlist1>Clase de login</dt><dd><p>Las clases de login son una extensión al mecanismo de grupos que ofrecen una mayor flexibilidad a la hora de adaptar el sistema a distintos usuarios.</p></dd><dt class=hdlist1>Tiempo de cambio de contraseña</dt><dd><p>Por defecto FreeBSD no obliga a los usuarios a cambiar su contraseña periódicamente. Se puede requerir esto a determinados usuarios, haciendo que algunos o todos deban cambiar sus contraseñas al cabo de cierto periodo de tiempo.</p></dd><dt class=hdlist1>Tiempo de expiración de cuentas</dt><dd><p>Por defecto las cuentas en FreeBSD no expiran. Si estás creando cuentas que sabes que van a tener un tiempo limitado de vida, por ejemplo, las cuentas de los estudiantes de una escuela, entonces puedes especificar cuándo expiran. Una vez vencido su tiempo de expiración una cuenta no puede ser usada para entrar en el sistema, si bien sus directorios y archivos serán conservados.</p></dd><dt class=hdlist1>Nombre completo de usuario</dt><dd><p>El nombre de usuario identifica unívocamente a una cuenta para FreeBSD, pero no refleja su verdadero nombre necesariamente. Esta información puede ser asociada a la cuenta.</p></dd><dt class=hdlist1>Directorio home</dt><dd><p>El directorio home es el camino completo de un directorio en el sistema en el que el usuario se hallará cuando entre. Una convención usual consiste en poner todos los directorios home en <span class=filename>/home/nombre_de_usuario</span> o en <span class=filename>/usr/home/nombre_de_usuario</span>. Los usuarios guardarían sus archivos personales en sus directorios home, y en cualquier directorio que creasen allí.</p></dd><dt class=hdlist1>Shell de usuario</dt><dd><p>La shell provee el entorno por defecto mediante el cual los usuarios interactúan con el sistema. Existen varios tipos de shell y los usuarios experimentados tendrán sus propias preferencias, que pueden expresarse en la configuración de su cuenta.</p></dd></dl></div><div class=paragraph><p>Existen principalmente tres tipos de cuentas; la cuenta de <a href=#users-superuser>superusuario</a>, las cuentas de <a href=#users-system>usuarios del sistema</a>, y las de <a href=#users-user>usuarios</a>. La cuenta de superusuario, normalmente llamada <code>root</code>, se usa para administrar el sistema sin limitaciones en los privilegios. Los usuarios del sistema utilizan servicios del mismo. Finalmente, las cuentas de usuarios son usadas por gente real, aquellos que entran, leen correo, etcétera.</p></div></div><div class=sect2><h3 id=users-superuser>13.3. La cuenta superusuario<a class=anchor href=#users-superuser></a></h3><div class=paragraph><p>La cuenta superusuario, normalmente llamada <code>root</code>, viene preconfigurada para facilitar la administración del sistema, y no debería ser utilizada para tareas cotidianas como enviar o recibir correo, exploración general del sistema, o programación.</p></div><div class=paragraph><p>Esto es así porque el superusuario, a diferencia de las cuentas de usuario, puede operar sin límites, y un mal uso de la cuenta de superusuario puede conllevar desastres espectaculares. Las cuentas de usuario no pueden destruir el sistema por un error, por ello es generalmente mejor utilizar cuentas de usuario normales cuando sea posible, a no ser que especialmente necesites privilegios extra.</p></div><div class=paragraph><p>Deberías comprobar siempre un par o tres de veces los comandos que ejecutas como superusuario, ya que un espacio de más o un carácter omitido pueden significar una pérdida de datos irreparable.</p></div><div class=paragraph><p>Así pues, lo primero que deberías hacer después de leer este capítulo es crear una cuenta sin privilegios de uso general para ti si aún no la tienes. Esto aplica tanto si trabajas en una máquina con varios usuarios como si trabajas en una máquina con un solo usuario. Más adelante, en este mismo capítulo, explicamos cómo crear cuentas adicionales, y cómo cambiar de usuario normal a superusuario.</p></div></div><div class=sect2><h3 id=users-system>13.4. Cuentas de sistema<a class=anchor href=#users-system></a></h3><div class=paragraph><p>Los usuarios de sistema son aquéllos que corren servicios como DNS, correo, servidores web, etc. Esto es así por seguridad; si todos los servicios corrieran como superusuario podrían actuar sin ninguna restricción.</p></div><div class=paragraph><p>Algunos ejemplos de usuarios de sistema son <code>daemon</code>, <code>operator</code>, <code>bind</code> (para el DNS), y <code>news</code>. Con frecuencia, los administradores de sistemas crean el usuario <code>httpd</code> para que ejecute los servidores web que instalan.</p></div><div class=paragraph><p><code>nobody</code> es el usuario de sistema sin privelegios genérico. No obstante, es importante tener en cuenta que cuantos más servicios use <code>nobody</code>, más ficheros y procesos estarán asociados con dicho usuario, y en consecuencia más privilegiado será.</p></div></div><div class=sect2><h3 id=users-user>13.5. Cuentas de usuario<a class=anchor href=#users-user></a></h3><div class=paragraph><p>Las cuentas de usuario constituyen la principal vía de acceso al sistema para la gente real. Estas cuentas aíslan al usuario del entorno, impidiendo que pueda dañar al sistema o a otros usuarios, y permitiendo a su vez que pueda personalizar su entorno sin que esto afecte a otros.</p></div><div class=paragraph><p>Cada persona que acceda a tu sistema debería tener una sola cuenta de usuario. Esto te permite averiguar quién está haciendo qué, evita que interfieran las configuraciones de distintos usuarios, que unos puedan leer el correo de otros, etcétera.</p></div><div class=paragraph><p>Cada usuario puede configurar su entorno para acomodarlo al uso que hace del sistema, utilizando shells, editores, atajos de teclado e idioma alternativos.</p></div></div><div class=sect2><h3 id=users-modifying>13.6. Modificación de cuentas<a class=anchor href=#users-modifying></a></h3><div class=paragraph><p>Existe una variedad de comandos disponible en el entorno Unix para modificar cuentas de usuario. Los comandos más comunes se hallan resumidos a continuación, seguidos de ejemplos más detallados de su uso.</p></div><table class="tableblock frame-all grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Comando</th><th class="tableblock halign-left valign-top">Resumen</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>adduser</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>La aplicación de línea de comandos recomendada para añadir nuevos usuarios.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>rmuser</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>La aplicación de línea de comandos recomendada para eliminar usuarios.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>chpass</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Una herramienta flexible para modificar la base de datos de usuarios.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>passwd</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Una herramienta de línea de comandos simple para cambiar contraseñas de usuario.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>pw</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Una herramienta potente y flexible para modificar cualquier aspecto de las cuentas de usuario.</p></td></tr></tbody></table><div class=sect3><h4 id=users-adduser>13.6.1. adduser<a class=anchor href=#users-adduser></a></h4><div class=paragraph><p><code>adduser</code> es un programa simple para añadir usuarios. Crea entradas en los archivos de sistema <span class=filename>passwd</span> y <span class=filename>group</span>. También crea un directorio home para el nuevo usuario, copia allí ficheros de configuración por defecto ("dotfiles") de <span class=filename>/usr/shared/skel</span>, y opcionalmente puede enviar al usuario un mensaje de bienvenida.</p></div><div class=paragraph><p>Para crear el fichero inicial de configuración usa <code>adduser -s -config_create</code>. A continuación configuramos valores por defecto para adduser y creamos nuestra primera cuenta de usuario, dado que utilizar <code>root</code> para uso normal del sistema es pernicioso y peligroso.</p></div><div class=exampleblock><div class=title>Ejemplo 10. Configuración de adduser</div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># adduser -v</span>
Use option <span class=sb>``</span><span class=nt>-silent</span><span class=s1>&#39;&#39;</span> <span class=k>if </span>you don<span class=s1>&#39;t want to see all warnings and questions.
Check /etc/shells
Check /etc/master.passwd
Check /etc/group
Enter your default shell: csh date no sh tcsh zsh [sh]: zsh
Your default shell is: zsh -&gt; /usr/local/bin/zsh
Enter your default HOME partition: [/home]:
Copy dotfiles from: /usr/shared/skel no [/usr/shared/skel]:
Send message from file: /etc/adduser.message no
[/etc/adduser.message]: no
Do not send message
Use passwords (y/n) [y]: y

Write your changes to /etc/adduser.conf? (y/n) [n]: y

Ok, let&#39;</span>s go.
Don<span class=s1>&#39;t worry about mistakes. I will give you the chance later to correct any input.
Enter username [a-z0-9_-]: jru
Enter full name []: J. Random User
Enter shell csh date no sh tcsh zsh [zsh]:
Enter home directory (full path) [/home/jru]:
Uid [1001]:
Enter login class: default []:
Login group jru [jru]:
Login group is ``jru&#39;&#39;. Invite jru into other groups: guest no
[no]: wheel
Enter password []:
Enter password again []:

Name:     jru
Password: ****
Fullname: J. Random User
Uid:      1001
Gid:      1001 (jru)
Class:
Groups:   jru wheel
HOME:     /home/jru
Shell:    /usr/local/bin/zsh
OK? (y/n) [y]: y
Added user ``jru&#39;&#39;
Copy files from /usr/shared/skel to /home/jru
Add another user? (y/n) [y]: n
Goodbye!
#</span></code></pre></div></div></div></div><div class=paragraph><p>En resumen, cambiamos la shell por defecto a zsh (una shell alternativa incluida en la colección de ports), y deshabilitamos el envío de un mensaje de bienvenida a nuevos usuarios. Luego grabamos la configuración, creamos una cuenta para <code>jru</code>, y nos aseguramos de que <code>jru</code> esté en el grupo <code>wheel</code> (de modo que puede asumir el papel de <code>root</code> vía el comando <code>su</code>).</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>La contraseña que escribes no se muestra, tampoco se muestran asteriscos. Asegúrate de no entrar dos veces una contraseña equivocada.</p></div></td></tr></tbody></table></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Usa <code>adduser</code> sin argumentos en adelante, no necesitarás cambiar las opciones por defecto. Si el programa te pide modificarlas sal y prueba con la opción <code>-s</code>.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=users-rmuser>13.6.2. rmuser<a class=anchor href=#users-rmuser></a></h4><div class=paragraph><p>Puedes usar <code>rmuser</code> para eliminar completamente del sistema a un usuario. <code>rmuser</code> efectúa los siguientes pasos:</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Elimina la entrada del usuario en <a href="https://man.freebsd.org/cgi/man.cgi?query=crontab&amp;sektion=1&amp;format=html">crontab(1)</a> (si tiene alguna).</p></li><li><p>Elimina las tareas <a href="https://man.freebsd.org/cgi/man.cgi?query=at&amp;sektion=1&amp;format=html">at(1)</a> pertenecientes al usuario.</p></li><li><p>Mata todos los procesos pertenecientes al usuario.</p></li><li><p>Elimina al usuario del fichero local de contraseñas del sistema.</p></li><li><p>Borra el directorio home del usuario (si le pertenece).</p></li><li><p>Elimina los archivos de correo entrante del usuario de <span class=filename>/var/mail</span>.</p></li><li><p>Borra todos los ficheros del usuario de áreas en las que se guardan archivos temporales como <span class=filename>/tmp</span>.</p></li><li><p>Finalmente, elimina el nombre de usuario de todos aquellos grupos a los que pertenece en <span class=filename>/etc/group</span>.</p><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Si un grupo queda vacío y el nombre del grupo coincide con el del usuario, el grupo es eliminado; esto complementa la creación de grupos por usuario de <a href="https://man.freebsd.org/cgi/man.cgi?query=adduser&amp;sektion=8&amp;format=html">adduser(8)</a>.</p></div></td></tr></tbody></table></div></li></ol></div></div></div><div class=paragraph><p><code>rmuser</code> no puede ser usado para eliminar cuentas de superusuario, dado que algo así es casi siempre señal de masiva destrucción.</p></div><div class=paragraph><p>Por defecto existe un modo interactivo que intenta asegurar que uno sabe lo que hace.</p></div><div class=exampleblock><div class=title>Ejemplo 11. Eliminación interactiva de cuenta con rmuser</div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># rmuser jru</span>
Matching password entry:
jru:<span class=k>*</span>:1001:1001::0:0:J. Random User:/home/jru:/usr/local/bin/tcsh
Is this the entry you wish to remove? y
Remove user<span class=s1>&#39;s home directory (/home/jru)? y
Updating password file, updating databases, done.
Updating group file: trusted (removing group jru -- personal group is empty) done.
Removing user&#39;</span>s incoming mail file /var/mail/jru: <span class=k>done</span><span class=nb>.</span>
Removing files belonging to jru from /tmp: <span class=k>done</span><span class=nb>.</span>
Removing files belonging to jru from /var/tmp: <span class=k>done</span><span class=nb>.</span>
Removing files belonging to jru from /var/tmp/vi.recover: <span class=k>done</span><span class=nb>.</span>
<span class=c>#</span></code></pre></div></div></div></div></div><div class=sect3><h4 id=users-chpass>13.6.3. chpass<a class=anchor href=#users-chpass></a></h4><div class=paragraph><p><code>chpass</code> cambia información de los usuarios en base de datos como contraseñas, shells y datos personales.</p></div><div class=paragraph><p>Los administradores del sistema, como el superusuario, son los únicos que pueden modificar la información y contraseñas de otros usuarios con <code>chpass</code>.</p></div><div class=paragraph><p>Cuando no le pasamos más opciones, salvo un nombre de usuario opcional, <code>chpass</code> muestra un editor con información de usuario. Cuando se sale del editor la base de datos de usuarios se actualiza con la nueva información.</p></div><div class=exampleblock><div class=title>Ejemplo 12. chpass interactivo ejecutado por el superusuario</div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c>#Changing user database information for jru.</span>
Login: jru
Password: <span class=k>*</span>
Uid <span class=o>[</span><span class=c>#]: 1000</span>
Gid <span class=o>[</span><span class=c># or name]: 1000</span>
Change <span class=o>[</span>month day year]:

Expire <span class=o>[</span>month day year]:
Class:
Home directory: /home/jru
Shell: /usr/local/bin/tcsh
Full Name: J. Random User
Office Location:
Office Phone:
Home Phone:
Other information:</code></pre></div></div></div></div><div class=paragraph><p>Un usuario normal puede modificar un pequeño subconjunto de esta información, y sólo para sí mismo.</p></div><div class=exampleblock><div class=title>Ejemplo 13. chpass interactivo ejecutado por un usuario normal</div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c>#Changing user database information for jru.</span>
Shell: /usr/local/bin/tcsh
Full Name: J. Random User
Office Location:
Office Phone:
Home Phone:
Other information:</code></pre></div></div></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p><code>chfn</code> y <code>chsh</code> son enlaces a <code>chpass</code>, como también lo son <code>ypchpass</code>, <code>ypchfn</code>, e <code>ypchsh</code>. El soporte para NIS es automático, por lo que no es necesario especificar el <code>yp</code> antes del comando. Si esto te resulta algo confuso no te preocupes, NIS será tratado en el <a href=./#advanced-networking>Networking avanzado</a>.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=users-passwd>13.6.4. passwd<a class=anchor href=#users-passwd></a></h4><div class=paragraph><p><code>passwd</code> es el comando que se usa normalmente para cambiar tu propia contraseña como usuario o, como superusuario, la de otros usuarios.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Los usuarios han de introducir su contraseña original antes de cambiarla para prevenir que gente no autorizada pueda hacerlo cuando no se encuentren en la consola.</p></div></td></tr></tbody></table></div><div class=exampleblock><div class=title>Ejemplo 14. Cambio de tu contraseña</div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% passwd
Changing <span class=nb>local </span>password <span class=k>for </span>jru.
Old password:
New password:
Retype new password:
passwd: updating the database...
passwd: <span class=k>done</span></code></pre></div></div></div></div><div class=exampleblock><div class=title>Ejemplo 15. Cambio de la contraseña de otro usuario como superusuario</div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># passwd jru</span>
Changing <span class=nb>local </span>password <span class=k>for </span>jru.
New password:
Retype new password:
passwd: updating the database...
passwd: <span class=k>done</span></code></pre></div></div></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Como ocurre con <code>chpass</code>, <code>yppasswd</code> es un enlace a <code>passwd</code>, de manera que NIS funciona con ambos comandos.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=users-pw>13.6.5. pw<a class=anchor href=#users-pw></a></h4><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=pw&amp;sektion=8&amp;format=html">pw(8)</a> es una utilidad de línea de comandos para crear, eliminar, modificar, y mostrar usuarios y grupos. Hace de interfaz a los archivos del sistema de usuarios y grupos. <code>pw</code> tiene un conjunto de opciones de línea de comandos bastante potente que lo hacen adecuado para su uso en scripts de shell, aunque los nuevos usuarios puede que lo encuentren algo más complicado que el resto de comandos que presentamos aquí.</p></div></div></div><div class=sect2><h3 id=users-limiting>13.7. Limitar a los usuarios<a class=anchor href=#users-limiting></a></h3><div class=paragraph><p>En un sistema multiusuario es probable que no confíes en que el sistema no vaya a ser dañado por ningún usuario.</p></div><div class=paragraph><p>Las cuotas de disco permiten al administrador decirle al sistema de ficheros qué cantidad de espacio de disco puede utilizar un usuario; además, ofrecen una manera rápida de comprobar el uso de disco de un usuario sin tener que calcularlo cada vez. Las cuotas se estudian en el capítulo de quotas.</p></div><div class=paragraph><p>El resto de límites de recursos incluyen cantidad de CPU, memoria, y otros recursos que el usuario puede utilizar.</p></div><div class=paragraph><p>Las clases de login se definen en <span class=filename>/etc/login.conf</span>. La semántica precisa está fuera del alcance de esta sección, pero se describe con detalle en la página de manual <a href="https://man.freebsd.org/cgi/man.cgi?query=login.conf&amp;sektion=5&amp;format=html">login.conf(5)</a>. Es suficiente decir que cada usuario es asignado a una clase de login (<code>default</code> por defecto), y que cada clase de login tiene un conjunto de capacidades asociado. Una capacidad de login es un par <code>nombre=valor</code>, donde <em>nombre</em> es un identificador conocido y <em>valor</em> una cadena de texto arbitraria que se procesa en función del nombre. Establecer clases y capacidades de login es bastante sencillo y también se describe en <a href="https://man.freebsd.org/cgi/man.cgi?query=login.conf&amp;sektion=5&amp;format=html">login.conf(5)</a>.</p></div><div class=paragraph><p>Los límites de recursos son diferentes de las capacidades de login en dos sentidos. En primer lugar, para cada límite existe un límite blando (actual) y uno duro. Un límite blando puede ser ajustado por el usuario o una aplicación, pero no puede ser más alto que el límite duro. Éste último puede ser disminuido por el usuario pero nunca aumentado. En segundo lugar, la mayoría de los límites de recursos aplican a un usuario concreto por proceso, no globalmente. Nótese, no obstante, que estas diferencias vienen impuestas por cómo se tratan los límites específicamente, no por la implementación del marco de capacidades de login (es decir, en realidad no constituyen un caso especial de capacidades de login).</p></div><div class=paragraph><p>Sin más, a continuación veremos los límites de recursos más comúnmente usados (el resto, junto con el resto de capacidades de login, puede encontrarse en <a href="https://man.freebsd.org/cgi/man.cgi?query=login.conf&amp;sektion=5&amp;format=html">login.conf(5)</a>).</p></div><div class=dlist><dl><dt class=hdlist1><code>coredumpsize</code></dt><dd><p>El tamaño de un fichero core generado por un programa está, por razones obvias, subordinado a otros límites sobre uso de disco (p. ej., <code>filesize</code>, o cuotas de disco). Aun y así, se usa frecuentemente como un método menos severo de controlar consumo de espacio de disco, dado que los usuarios no generan ficheros core por ellos mismos, y a menudo no los borran, activar este límite puede evitar que agoten el espacio de disco de que disponen si algún programa grande (p. ej., emacs) deja de funcionar abruptamente.</p></dd><dt class=hdlist1><code>cputime</code></dt><dd><p>Ésta es la máxima cantidad de tiempo de CPU que los procesos de un usuario pueden consumir.</p><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Éste es un límite sobre el <em>tiempo</em> de CPU consumido, no el porcentaje de uso de CPU que se muestra en algunos campos de <a href="https://man.freebsd.org/cgi/man.cgi?query=top&amp;sektion=1&amp;format=html">top(1)</a> y <a href="https://man.freebsd.org/cgi/man.cgi?query=ps&amp;sektion=1&amp;format=html">ps(1)</a>. Un límite de ese tipo no es posible a día de hoy, y sería bastante inútil: un compilador -probablemente una tarea legítima- puede usar prácticamente el 100% de la CPU durante algún tiempo con facilidad.</p></div></td></tr></tbody></table></div></dd><dt class=hdlist1><code>filesize</code></dt><dd><p>Éste es el tamaño máximo que puede llegar a tener un fichero del usuario. A diferencia de las cuotas de disco, este límite se especifica para ficheros individuales, no para el conjunto de todos los archivos que posee.</p></dd><dt class=hdlist1><code>maxproc</code></dt><dd><p>Éste es el máximo número de procesos que un usuario puede ejecutar a la vez, incluidos tanto los procesos en primer plano como los procesos en segundo plano. Por razones obvias, este límite no puede ser mayor que el límite de sistema especificado por <code>kern.maxproc sysctl</code>. Obsérvese también que si asignamos un valor demasiado bajo a este límite podemos mermar la productividad de un usuario: frecuentemente es útil entrar múltiples veces en el sistema o ejecutar pipelines. Algunas tareas, como compilar largos programas, lanzan múltiples procesos (p. ej., <a href="https://man.freebsd.org/cgi/man.cgi?query=make&amp;sektion=1&amp;format=html">make(1)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=cc&amp;sektion=1&amp;format=html">cc(1)</a>, y demás preprocesadores intermedios).</p></dd><dt class=hdlist1><code>memorylocked</code></dt><dd><p>Ésta es la máxima cantidad de memoria que un proceso puede haber solicitado tener bloqueada en memoria principal (p. ej., ver <a href="https://man.freebsd.org/cgi/man.cgi?query=mlock&amp;sektion=2&amp;format=html">mlock(2)</a>). Algunos programas críticos para el sistema, como <a href="https://man.freebsd.org/cgi/man.cgi?query=amd&amp;sektion=8&amp;format=html">amd(8)</a>, se quedan bloqueados en la memoria principal de manera que en caso de ser llevados a swap no contribuyan a la basura del sistema si hay algún problema.</p></dd><dt class=hdlist1><code>memoryuse</code></dt><dd><p>Ésta es la mayor cantidad de memoria que un proceso puede consumir en todo momento. Incluye tanto memoria normal como uso de swap. No se trata de un límite para restringir el consumo de memoria en general, pero es un buen comienzo.</p></dd><dt class=hdlist1><code>openfiles</code></dt><dd><p>Ésta es la máxima cantidad de archivos que un proceso puede tener abiertos. En FreeBSD, los archivos se usan tambien para representar sockets y canales IPC; así, cuida de no poner este límite demasiado bajo. A nivel de sistema, el límite para esto lo define <code>kern.maxfiles sysctl</code>.</p></dd><dt class=hdlist1><code>sbsize</code></dt><dd><p>Éste es el límite de cantidad de memoria de red, y por lo tanto mbufs, que un usuario puede consumir. Se originó como respuesta a un viejo ataque DoS que creaba muchos sockets, pero puede ser usado en general para limitar las comunicaciones por red.</p></dd><dt class=hdlist1><code>stacksize</code></dt><dd><p>Éste es el tamaño máximo que puede alcanzar la pila de un proceso. Por sí solo no es suficiente para limitar la cantidad de memoria que puede usar un programa; en consecuencia, debería ser usado junto con otros límites.</p></dd></dl></div><div class=paragraph><p>Hay unas pocas cosas más a recordar cuando establecemos límites de recursos. A continuación vienen algunas recomendaciones, sugerencias, y comentarios varios.</p></div><div class=ulist><ul><li><p>Los procesos que se ponen en marcha cuando arranca el sistema por <span class=filename>/etc/rc</span> están asignados a la clase de login <code>daemon</code>.</p></li><li><p>Aunque el <span class=filename>/etc/login.conf</span> que viene con el sistema tiene valores razonables para la mayoría de los límites, sólo tú, el administrador, puedes saber lo que es apropiado para tu sistema.</p></li><li><p>A los usuarios del X Window System (X11) probablemente se les debería conceder más recursos que al resto. X11 de por sí consume muchos recursos, pero además contribuye a que los usuarios ejecuten más programas simultáneamente.</p></li><li><p>Recuerda que hay muchos límites que aplican a procesos individuales, no al usuario en general. Por ejemplo, poner <code>openfiles</code> a 50 significa que cada uno de los procesos que ejecute un usuario puede abrir a lo máximo 50 ficheros. Así, la cantidad de ficheros que un usuario puede abrir es el valor de <code>openfiles</code> multiplicado por el valor de <code>maxproc</code>. Esto también aplica al uso de memoria.</p></li></ul></div><div class=paragraph><p>Para más información acerca de límites de recursos y clases y capacidades de login en general, consulta las páginas de manual relevantes: <a href="https://man.freebsd.org/cgi/man.cgi?query=cap.mkdb&amp;sektion=1&amp;format=html">cap.mkdb(1)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=getrlimit&amp;sektion=2&amp;format=html">getrlimit(2)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=login.conf&amp;sektion=5&amp;format=html">login.conf(5)</a>.</p></div></div><div class=sect2><h3 id=users-personalizing>13.8. Personalizar a los usuarios<a class=anchor href=#users-personalizing></a></h3><div class=paragraph><p>La localización es un entorno establecido por el administrador o el usuario para dar soporte a distintos lenguajes, juegos de caracteres, estándares sobre fechas y horas, etcétera. Éste tema se trata en el capítulo <a href=./#l10n>Localización</a>.</p></div></div><div class=sect2><h3 id=users-groups>13.9. Grupos<a class=anchor href=#users-groups></a></h3><div class=paragraph><p>Un grupo es simplemente una lista de usuarios. Los grupos se identifican por su nombre de grupo y gid (ID de grupo). En FreeBSD (y en la mayoría de sistemas Unix), los dos factores que tiene en cuenta el núcleo para decidir si un proceso puede hacer algo es su ID de usuario y la lista de grupos a los que pertenece. A diferencia del ID de usuario, un proceso tiene una lista de grupos asociados. En ocasiones encontrarás menciones al "ID de grupo" de un usuario o de un proceso; la mayoría de las veces referirán simplemente al primero de los grupos de la lista.</p></div><div class=paragraph><p>La correspondencia entre nombres e IDs de grupo está en <span class=filename>/etc/group</span>. Se trata de un fichero de texto plano con cuatro campos separados por el signo dos puntos. El primer campo es el nombre de grupo, el segundo la contraseña encriptada, el tercero el ID de grupo, y el cuarto la lista de miembros separados por comas. Puede ser editado a mano sin peligro (¡suponiendo, por supuesto, que no se cometan errores de sintaxis!). Para una descripción más completa de la sintaxis, ver la página de manual <a href="https://man.freebsd.org/cgi/man.cgi?query=group&amp;sektion=5&amp;format=html">group(5)</a>.</p></div><div class=paragraph><p>Si no quieres editar <span class=filename>/etc/group</span> manualmente, puedes usar el comando <a href="https://man.freebsd.org/cgi/man.cgi?query=pw&amp;sektion=8&amp;format=html">pw(8)</a> para añadir y modificar grupos. Por ejemplo, para añadir un grupo llamado <code>teamtwo</code> y luego confirmar que existe puedes usar:</p></div><div class=exampleblock><div class=title>Ejemplo 16. Añadir un grupo usando <a href="https://man.freebsd.org/cgi/man.cgi?query=pw&amp;sektion=8&amp;format=html">pw(8)</a></div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pw groupadd teamtwo</span>
<span class=c># pw groupshow teamtwo</span>
teamtwo:<span class=k>*</span>:1100:</code></pre></div></div></div></div><div class=paragraph><p>El número <code>1100</code> en el ejemplo anterior es el ID de grupo del grupo <code>teamtwo</code>. Ahora mismo <code>teamtwo</code> no tiene miembros, y es por tanto bastante inútil. Cambiemos eso invitando a <code>jru</code> a formar parte del grupo <code>teamtwo</code>.</p></div><div class=exampleblock><div class=title>Ejemplo 17. Añadir a alguien a un grupo usando <a href="https://man.freebsd.org/cgi/man.cgi?query=pw&amp;sektion=8&amp;format=html">pw(8)</a></div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pw groupmod teamtwo -M jru</span>
<span class=c># pw groupshow teamtwo</span>
teamtwo:<span class=k>*</span>:1100:jru</code></pre></div></div></div></div><div class=paragraph><p>El argumento de la opción <code>-M</code> es una lista con los usuarios que son miembros del grupo separados por comas. Sabemos de secciones anteriores que el fichero de contraseñas también contiene un grupo para cada usuario. El usuario es automáticamente añadido a la lista de grupos por el sistema; no constará como miembro cuando usemos el comando <code>groupshow</code> con <a href="https://man.freebsd.org/cgi/man.cgi?query=pw&amp;sektion=8&amp;format=html">pw(8)</a>, pero sí cuando la información se consulte con <a href="https://man.freebsd.org/cgi/man.cgi?query=id&amp;sektion=1&amp;format=html">id(1)</a> u otra herramienta similar. En otras palabras, <a href="https://man.freebsd.org/cgi/man.cgi?query=pw&amp;sektion=8&amp;format=html">pw(8)</a> sólo manipula el fichero <span class=filename>/etc/group</span>; nunca tratará de leer datos adicionales de <span class=filename>/etc/passwd</span>.</p></div><div class=exampleblock><div class=title>Ejemplo 18. Determinar pertenencia a grupos con <a href="https://man.freebsd.org/cgi/man.cgi?query=id&amp;sektion=1&amp;format=html">id(1)</a></div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>id </span>jru
<span class=nv>uid</span><span class=o>=</span>1001<span class=o>(</span>jru<span class=o>)</span> <span class=nv>gid</span><span class=o>=</span>1001<span class=o>(</span>jru<span class=o>)</span> <span class=nb>groups</span><span class=o>=</span>1001<span class=o>(</span>jru<span class=o>)</span>, 1100<span class=o>(</span>teamtwo<span class=o>)</span></code></pre></div></div></div></div><div class=paragraph><p>Como puedes ver, <code>jru</code> es miembro de los grupos <code>jru</code> y <code>teamtwo</code>.</p></div><div class=paragraph><p>Para más información acerca de <a href="https://man.freebsd.org/cgi/man.cgi?query=pw&amp;sektion=8&amp;format=html">pw(8)</a>, consulta su página de manual, y para más información acerca del formato de <span class=filename>/etc/group</span>, consulta la página de manual de <a href="https://man.freebsd.org/cgi/man.cgi?query=group&amp;sektion=5&amp;format=html">group(5)</a>.</p></div></div></div></div><div class=sect1><h2 id=security>Capítulo 14. Seguridad<a class=anchor href=#security></a></h2><div class=sectionbody><div class=sect2><h3 id=security-synopsis>14.1. Sinopsis<a class=anchor href=#security-synopsis></a></h3><div class=paragraph><p>Este capítulo contiene una introducción básica a los conceptos de seguridad del sistema, unas cuantas normas básicas de uso y algunos avanzados del tema en FreeBSD. Muchos de los temas expuestos se aplican a la seguridad del sistema y de Internet en general. Internet ya no es aquél lugar "amistoso" en el que todo el mundo se comportaba como un buen ciudadano. Si quiere proteger sus datos, su propiedad intelectual, su tiempo y muchas más cosas de manos malintencionadas debe hacer que su sistema sea seguro.</p></div><div class=paragraph><p>FreeBSD proporciona un variado arsenal de utilidades y mecanismos para asegurar la integridad y la seguridad de su sistema y red.</p></div><div class=paragraph><p>Después de leer este capítulo:</p></div><div class=ulist><ul><li><p>conocerá conceptos básicos de la seguridad relacionados con FreeBSD.</p></li><li><p>Tendrá información sobre los diversos mecanismos de cifrado disponibles en FreeBSD, entre los cuales están DES y MD5.</p></li><li><p>Sabrá cómo configurar la autentificación de contraseñas de un solo uso.</p></li><li><p>Sabrá cómo configurar TCP Wrappers y usarlos con <code>inetd</code>.</p></li><li><p>Sabrá cómo instalar KerberosIV en versiones de FreeBSD anteriores a 5.0.</p></li><li><p>Sabrá cómo instalar Kerberos5 en versiones de FreeBSD posteriores a 5.0.</p></li><li><p>Podrá configurar IPsec y crear una VPN entre máquinas FreeBSD/Windows®.</p></li><li><p>Sabrá cómo configurar y utilizar OpenSSH, la implementación de SSH en FreeBSD.</p></li><li><p>Sabrá en qué consisten las ACL del sistema de ficheros y cómo utilizarlas.</p></li><li><p>Sabrá cómo usar Portaudit, con la que podrá auditar el software que instale desde la desde la colección de ports.</p></li><li><p>Sabrá cómo sacar partido de los avisos de seguridad que publica FreeBSD.</p></li><li><p>Podrá hacerse una idea clara de en qué consiste la contabilidad de procesos y de cómo activarla en FreeBSD.</p></li></ul></div><div class=paragraph><p>Antes de leer este capítulo:</p></div><div class=ulist><ul><li><p>Comprender conceptos básicos de FreeBSD e Internet.</p></li></ul></div><div class=paragraph><p>En otras secciones de este manual se cubren aspectos adicionales sobre seguridad. Por ejemplo, MAC (controles de acceso obligatorio) se explica en el <a href=./#mac>Mandatory Access Control</a> y los cortafuegos en el <a href=./#firewalls>Cortafuegos</a>.</p></div></div><div class=sect2><h3 id=security-intro>14.2. Introducción<a class=anchor href=#security-intro></a></h3><div class=paragraph><p>La seguridad es un trabajo que que comienza y termina en el administrador de sistema. Aunque que los sistemas multiusuario BSD UNIX® posean una seguridad inherente, el trabajo de construir y mantener mecanismos de seguridad adicionales para que los usuarios sean aún más "honestos" es probablemente una de las mayores tareas de la administración de sistemas. Los sistemas son tan seguros como uno los haga, y no hay que olvidar que los problemas de seguridad compiten con la comodidad a la que tendemos los humanos. Los sistemas UNIX® son capaces de ejecutar una gran cantidad de procesos simultáneamente, muchos de los cuales son servidores, lo que significa que las entidades externas pueden conectarse y "hablar" con ellos. Del mismo modo que las minicomputadoras de ayer se convirtieron en los sistemas de escritorio de hoy en día, la seguridad se va convirtiendo en un problemas más y más acuciante.</p></div><div class=paragraph><p>La seguridad bien entendida se implementa en capas, a la manera de una "cebolla". Básicamente lo que se hace es crear la mayor cantidad posible de capas de seguridad, para más tarde monitorizar el sistema en busca de intrusos. No es conveniente exagerar la seguridad, ya que interferiría con la detección, y la detección es uno de los aspectos más importantes de cualquier mecanismo de seguridad. Por ejemplo, no tiene mucho sentido activar la bandera <code>schg</code> (consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=chflags&amp;sektion=1&amp;format=html">chflags(1)</a>) en cada binario del sistema, ya que aunque protegería en cierto modo los binarios, haría que cualquier cambio que pudiera realizar un atacante una vez dentro del sistema fuera más difícil de detectar o incluso hacerlo del todo imposible.</p></div><div class=paragraph><p>La seguridad del sistema depende también de estar preparados para distintos tipos de ataque, incluyendo intentos de "tirar" la máquina o dejarla en un estado inutilizable, pero que no impliquen intentos de comprometer el usuario <code>root</code> Los problemas de seguridad pueden dividirse en diferentes categorías:</p></div><div class="olist arabic"><ol class=arabic><li><p>Ataques de denegación de servicio (DoS).</p></li><li><p>Comprometer cuentas de usuarios.</p></li><li><p>Comprometer root a través de servidores accesibles.</p></li><li><p>Comprometer root desde cuentas de usuario.</p></li><li><p>Creación de puertas traseras ("Backdoors").</p></li></ol></div><div class=paragraph><p>Un ataque de denegación de servicio es una acción que priva al sistema de los recursos requeridos para su funcionamiento normal. Generalmente, los ataques DoS son mecanismos de fuerza bruta que intentan "tumbar" el sistema o hacerlo inutilizable sobrecargando la capacidad de sus servidores o de la pila de red. Algunos ataques DoS intentan aprovechar errores en la pila de red para "tumbar" el sistema con un solo paquete. Estos últimos únicamente pueden solucionarse aplicando al kernel una actualización que subsane el error. Los ataques a servidores muchas veces pueden solucionarse configurando las opciones apropiadas para limitar la carga del sistema en condiciones adversas. Los ataques de fuerza bruta a redes son más complicados. Los ataques con paquetes enmascarados, por ejemplo, son casi imposibles de detener, a menos que desconecte el sistema de Internet. Puede ser que no "tiren" el sistema, pero saturarán la conexión a Internet.</p></div><div class=paragraph><p>Comprometer una cuenta de usuario es mucho más común que un ataque DoS. Muchos administradores de sistemas todavía ejecutan servidores estándar telnetd, rlogind, rshd y ftpd en sus máquinas. Estos servidores, por defecto no operan a través de conexiones cifradas. El resultado es que se si se tiene una base de usuarios de tamaño medio, tarde o temprando la contraseña de uno (o más) de sus usuarios será descubierta durante sus accesos al sistema desde ubicaciones remotas.(que es, por otra parte, la forma más común y más cómoda de acceder a un sistema). El administrador de sistemas atento analizará sus logs de acceso remoto en busca de direcciones origen spspechosas, incluso entre los accesos al sistema.</p></div><div class=paragraph><p>Se debe asumir <em>siempre</em> que, una vez que el atacante tiene acceso a una cuenta de usuario, el atacante puede comprometer la cuenta <code>root</code>. En realidad en un sistema bien mantenido y asegurado el acceso a una cuenta de usuario no necesariamente da al atacante acceso a <code>root</code>. Esta precisión es importante porque sin acceso a <code>root</code> el atacante difícilmente podrá esconder sus huellas; podrá, como mucho, hacer poco más que sembrar el caos en los ficheros del usuario o "tirar" la máquina. Comprometer cuentas de usuario es muy común porque los usuarios tienden a no tomar las precauciones que toma el administrador.</p></div><div class=paragraph><p>Los administradores de sistemas deben tener presente que existen muchas formas potenciales de comprometer la cuenta <code>root</code> de una máquina. El atacante puede conocer la contraseña de <code>root</code>, el atacante puede encontrar un error en un servidor que se ejecuta como root y ser capaz de comprometer <code>root</code> a través de una conexión de red a ese servidor; puede ser que el atacante sepa de la existencia de un error en un programa suid-root que le permita comprometer <code>root</code> una vez dentro de una cuenta de usuario. Si un atacante encuentra la manera de comprometer la cuenta <code>root</code> de una máquina puede que no necesite instalar una puerta trasera. Muchos de los agujeros <code>root</code> encontrados y cerrados hasta la fecha implican una cantidad considerable de trabajo para el atacante limpiando todo después del ataque, así que la mayoría de los atacantes instalan puertas traseras. Una puerta trasera facilita al atacante una forma sencilla de recuperar el acceso de <code>root</code> al sistema, pero también proporciona al administrador de sistemas inteligente una forma de detectar la intrusión. Si hace imposible a un atacante la instalación de una puerta trasera puede estar actuando en detrimento de su seguridad, porque no cerrará el agujero que el atacante encontró para accder al sistema la primera vez que lo hizo.</p></div><div class=paragraph><p>Las medidas de seguridad se implementan en un modelo multicapa (tipo "cebolla"), que puede categorizarse del siguiente modo:</p></div><div class="olist arabic"><ol class=arabic><li><p>Asegurar <code>root</code> y cuentas administrativas.</p></li><li><p>Asegurar los servidores que se ejecuten como <code>root</code> los binarios suid/sgid.</p></li><li><p>Asegurar cuentas de usuario.</p></li><li><p>Asegurar el fichero de contraseñas.</p></li><li><p>Asegurar el núcleo del kernel, los dispositivos en bruto y el sistema de ficheros.</p></li><li><p>Detección rápida de cambios hechos al sistema.</p></li><li><p>Paranoia.</p></li></ol></div><div class=paragraph><p>La siguiente sección de este capítulo tratará los puntos de arriba con mayor profundidad.</p></div></div><div class=sect2><h3 id=securing-freebsd>14.3. Asegurar FreeBSD<a class=anchor href=#securing-freebsd></a></h3><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=title>Orden vs. protocolo</div><div class=paragraph><p>En este capítulo usaremos el texto en negrita para referirnos a una orden o aplicación, y una fuente en <code>cursiva</code> para referirnos a órdenes específicas. Usaremos un tipo normal para los protocolos. Esta diferencia tipográfica nos será útil por ejemplo con ssh, que es tanto un protocolo como una orden.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Las siguientes secciones cubren los métodos a seguir para asegurar su sistema FreeBSD que se mencionados en la <a href=#security-intro>sección anterior</a> de este capítulo.</p></div><div class=sect3><h4 id=securing-root-and-staff>14.3.1. Asegurar la cuenta <code>root</code> y las cuentas administrativas<a class=anchor href=#securing-root-and-staff></a></h4><div class=paragraph><p>En primer lugar, no se moleste en asegurar las cuentas administrativas (o "staff") si no ha asegurado la cuenta <code>root</code>. La mayoría de los sistemas tienen una contraseña asignada para la cuenta <code>root</code>. Lo primero que se hace es asumir que la contraseña está <em>siempre</em> amenazada. Esto no significa que deba eliminar la contraseña. La contraseña es casi siempre necesaria para el acceso por consola a la máquina; significa que no se debe permitir el uso de la contraseña fuera de la consola o, mejor aún, mediante <a href="https://man.freebsd.org/cgi/man.cgi?query=su&amp;sektion=1&amp;format=html">su(1)</a>. Por ejemplo, asegúrese de que sus ptys aparezcan como <em>inseguras</em> en el fichero <span class=filename>/etc/ttys</span>, con lo que hará que los accesos como <code>root</code> vía <code>telnet</code> o <code>rlogin</code> no sean posibles. Si utiliza otros tipos de login como sshd asegúrese de que los accesos al sistema como <code>root</code> estén también deshabilitados. Para ello edite su <span class=filename>/etc/ssh/sshd_config</span> y asegúrese de que <code>PermitRootLogin</code> esté puesto a <code>NO</code>. Estudie cada método de acceso: hay servicios como FTP que frecuentemente son origen de grietas en la estructura del sistema. El acceso directo como usuario <code>root</code> sólamente debe permitirse a través de la consola.</p></div><div class=paragraph><p>Es evidente que, como administrador del sistema, debe usted tener la posibilidad de acceder a <code>root</code>, así que tendrá que abrir algunos agujeros, pero debe asegurarse de que estos agujeros necesiten contraseñas adicionales para verificar su correcto uso. Puede hacer que <code>root</code> sea accesible añadiendo cuentas administrativas al grupo <code>wheel</code> (en <span class=filename>/etc/group</span>). El personal que administra los sistemas que aparezcan en el grupo en el grupo <code>wheel</code> pueden hacer <code>su</code> a <code>root</code>. Nunca debe de proporcionar al personal administrativo el acceso nativo a <code>wheel</code> poniéndolos en el grupo <code>wheel</code> en su entrada de contraseña. Las cuentas administrativas deben colocarse en un grupo <code>staff</code>, y agregarse después al grupo <code>wheel</code> en <span class=filename>/etc/group</span>. Sólo aquellos administradores que realmente necesiten acceder a <code>root</code> deben pertenecer al grupo <code>wheel</code>. También es posible, mediante un método de autentificación como Kerberos, usar el fichero <span class=filename>.k5login</span> en la cuenta <code>root</code> para permitir un <a href="https://man.freebsd.org/cgi/man.cgi?query=ksu&amp;sektion=1&amp;format=html">ksu(1)</a> a <code>root</code> sin tener que colocar a nadie en el grupo <code>wheel</code>. Puede ser una mejor solución, ya que el mecanismo <code>wheel</code> aún permite a un atacante comprometer <code>root</code> si el intruso ha conseguido el fichero de contraseñas y puede comprometer una cuenta de administración. Recurrir al mecanismo <code>wheel</code> es mejor que no tener nada, pero no es necesariamente la opción más segura.</p></div><div class=paragraph><p>Una manera indirecta de asegurar las cuentas de staff y el acceso a <code>root</code> es utilizar un método de acceso alternativo: es lo que se conoce como "estrellar" las contraseñas cifradas de las cuentas administrativas. Use <a href="https://man.freebsd.org/cgi/man.cgi?query=vipw&amp;sektion=8&amp;format=html">vipw(8)</a> para reemplazar cada contraseña cifrada por un sólo caracter asterisco (“*”). Esto actualizará <span class=filename>/etc/master.passwd</span> y la base de datos de usuario/contraseña y deshabilitará los accesos al sistema validados mediante contraseñas.</p></div><div class=paragraph><p>Veamos una cuenta administrativa típica:</p></div><div class="literalblock programlisting"><div class=content><pre>foobar:R9DT/Fa1/LV9U:1000:1000::0:0:Foo Bar:/home/foobar:/usr/local/bin/tcsh</pre></div></div><div class=paragraph><p>y cómo debería quedar:</p></div><div class="literalblock programlisting"><div class=content><pre>foobar:*:1000:1000::0:0:Foo Bar:/home/foobar:/usr/local/bin/tcsh</pre></div></div><div class=paragraph><p>Este cambio evitará que se efectúen logins normales, ya que la contraseña cifrada nunca se corresponderá con “*”. Hecho esto, el personal de administración tendrá que usar otro mecanismo de validación como <a href="https://man.freebsd.org/cgi/man.cgi?query=kerberos&amp;sektion=1&amp;format=html">kerberos(1)</a> o <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh&amp;sektion=1&amp;format=html">ssh(1)</a> que use un par de llave pública/privada. Si decide usar algo como Kerberos tendrá que asegurar la máquina que ejecuta los servidores Kerberos y su estación de trabajo. Si usa un par de llave pública/privada con ssh, debe asegurar la máquina <em>desde</em> desde la que se hace el login (normalmente nuestra estación de trabajo). Puede añadir una capa adicional de protección al par de llaves protegiéndolas con contraseña al crearlo con <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-keygen&amp;sektion=1&amp;format=html">ssh-keygen(1)</a>. El "estrellado" de las contraseñas administrativas también garantiza que dicho personal sólo pueda entrar a través de métodos de acceso que haya usted configurado. Así obligará al personal administrativo a usar conexiones seguras, cifradas, en todas sus sesiones, lo que cierra un importante agujero de seguridad al que recurren muchos intrusos: usar un sniffer (olfateador) de red desde una máquina que le permita hacer tal cosa.</p></div><div class=paragraph><p>Los mecanismos de seguridad más indirectos también asumen que está validando su identidad desde un servidor más restrictivo un servidor menos restrictivo. Por ejemplo, si su máquina principal ejecuta toda clase de servidores su estación de trabajo no debe ejecutar ninguno. Para que su estación de trabajo sea razonablemente segura debe ejecutar los mínimos servidores posibles, si es posible ninguno, y debe usar un salvapantallas protegido por contraseña. Es evidente que un atancante con acceso físico al sistema puede romper cualquier barrera de seguridad que se disponga. Es un problema a tener en cuenta, pero la mayoría de las intrusiones tienen lugar de forma remota, a través de la red, por parte de gente que no tiene acceso físico a su estación de trabajo ni a sus servidores.</p></div><div class=paragraph><p>Usar Kerberos le ofrece también el poder de deshabilitar o cambiar la contraseña para una cuenta administrativa en un lugar, y que tenga un efecto inmediato en todas las máquinas en las cuales ese administrador pueda tener una cuenta. Si una de esas cuentas se ve comprometida la posibilidad para cambiar instantáneamente su contraseña en todas las máquinas no debe ser desestimada. Con contraseñas distintas, el cambio de una contraseña en N máquinas puede ser un problema. También puede imponer restricciones de re-contraseñas con Kerberos: no sólo se puede hacer un ticket de Kerberos que expire después de un tiempo, sino que el sistema Kerberos puede requerir al usuario que escoja una nueva contraseña después de cierto tiempo (digamos una vez al mes).</p></div></div><div class=sect3><h4 id=_asegurar_servidores_que_se_ejecutan_como_root_y_binarios_suidsgid>14.3.2. Asegurar servidores que se ejecutan como <code>root</code> y binarios SUID/SGID<a class=anchor href=#_asegurar_servidores_que_se_ejecutan_como_root_y_binarios_suidsgid></a></h4><div class=paragraph><p>Un administrador de sistemas prudente sólo ejecutará los servidores que necesita, ni uno más ni uno menos. Dese cuenta de que los servidores ajenos son los más propensos a contener errores. Por ejemplo, ejecutando una versión desfasada de imapd o popper es como dar una entrada universal de <code>root</code> al mundo entero. Nunca ejecute un servidor que no haya revisado cuidadosamente. Muchos servidores no necesitan ejecutarse como <code>root</code>. Por ejemplo, los dæmons ntalk, comsat y finger pueden ejecutarse en una <em>caja de arena (sandbox)</em> especial de usuario. Una caja de arena no es perfecta, a menos que pase por muchos problemas, pero la aproximación de cebolla a la seguridad prevalece aún y todo: Si alguien es capaz de penetrar a través de un servidor ejecutándose en una caja de arena, todavía tendrá que salir de la caja de arena. Cuantas más capas tenga que romper el atacante menor será la posibilidad de éxito que tenga. Se han encontrado vías de entrada a <code>root</code> en virtualmente todos los servidores que se haya ejecutado como <code>root</code>, incluyendo servidores básicos del sistema. Si está tiene una máquina a través de la cual la gente sólo entra por sshd, y nunca entra por telnetd, rshd, o rlogind <em>apague esos servicios</em>.</p></div><div class=paragraph><p>FreeBSD ejecuta por defecto ntalkd, comsat y finger en una caja de arena. Otro programa que puede ser candidato para ejecutarse en una caja de arena es <a href="https://man.freebsd.org/cgi/man.cgi?query=named&amp;sektion=8&amp;format=html">named(8)</a>. <span class=filename>/etc/defaults/rc.conf</span> contiene las directrices necesarias (con comentarios) para usar named en una caja de arena. Dependiendo de si está instalando un nuevo sistema o actualizando un sistema ya existente, las cuentas especiales de usuario que usan estas cajas de arena puede que no estén instaladas. El administrador de sistemas prudente debe investigar e implementar cajas de arena para servidores siempre que sea posible.</p></div><div class=paragraph><p>Existen numerosos servidores que no se suelen ejecutar en cajas de arena: sendmail, imapd, ftpd, y otros. Existen alternativas para algunos de ellos, pero instalarlas puede requerir más trabajo del que tal vez esté dispuesto a realizar (el factor comodidad ataca de nuevo). Tal vez tenga que ejecutar estos servidores como <code>root</code> y depender de otros mecanismos para detectar intrusiones que puedan tener lugar a través de ellos.</p></div><div class=paragraph><p>Los otros grandes agujeros potenciales de <code>root</code> que encontramos en un sistema son los binarios suid-root y sgid. La mayoría de estos binarios, como rlogin, están en <span class=filename>/bin</span>, <span class=filename>/sbin</span>, <span class=filename>/usr/bin</span> o <span class=filename>/usr/sbin</span>. Aunque no hay nada absolutamente seguro los binarios suid y sgid del sistema por defecto pueden considerarse razonablemente seguros. Aún así, de vez en cuando aparecen agujeros <code>root</code> en estos binarios. En 1998 se encontró un agujero <code>root</code> en <code>Xlib</code>, que hacía a xterm (que suele ser suid) vulnerable. Es mejor prevenir que curar, y el administrador de sistemas prudente restringirá los binarios suid, que sólo el personal de administración debe ejecutar, a un grupo especial al que sólo dicho personal pueda acceder, y deshacerse de cualquier binario suid (<code>chmod 000</code>) que no se use. Un servidor sin pantalla generalmente no necesita un binario xterm. Los binarios sgid pueden ser igual de peligrosos. Si un intruso logra comprometer un binario sgid-kmem, el intruso podría leer <span class=filename>/dev/kmem</span> y llegar a leer el fichero cifrado de contraseñas, poniendo en compromiso potencial cualquier cuenta con contraseña. Por otra parte, un intruso que comprometa el grupo <code>kmem</code> puede monitorizar las pulsaciones de teclado que se envien a través de ptys, incluyendo las ptys a las que acceden usuarios que emplean métodos seguros. Un intruso que comprometa el grupo <code>tty</code> puede escribir en la pty de casi cualquier usuario. Si un usuario ejecuta un programa de terminal o un emulador capaz de simular un teclado, el intruso podría generar un flujo de datos que provoque que la terminal del usuario muestre una orden en pantalla, orden que el usuario ejecutará.</p></div></div><div class=sect3><h4 id=secure-users>14.3.3. Asegurar las cuentas de usuario<a class=anchor href=#secure-users></a></h4><div class=paragraph><p>Las cuentas de usuario suelen ser las más difíciles de asegurar. Aunque puede imponer restricciones de acceso draconianas a su personal administrativo y "estrellar" sus contraseñas, tal vez no pueda hacerlo con todas las cuentas de todos sus usuarios. Si mantiene el control en un grado suficiente quizás lo logre y sea capaz de hacer que las cuentas de sus usuarios sean seguras. Si no, tendrá que ser más cuidadoso (aún) en la monitorización de esas cuentas. Usar ssh y Kerberos en cuentas de usuario da más problemas debido al soporte técnico y administrativo que requerirá, pero sigue siendo mejor solución que un fichero de contraseñas cifradas.</p></div></div><div class=sect3><h4 id=_asegurar_el_fichero_de_contraseñas>14.3.4. Asegurar el fichero de contraseñas<a class=anchor href=#_asegurar_el_fichero_de_contraseñas></a></h4><div class=paragraph><p>La única manera segura es ponerle <code>*</code> a tantas contraseñas como sea posible y utilizar ssh o Kerberos para acceder a esas cuentas. Aunque el fichero cifrado de contraseñas (<span class=filename>/etc/spwd.db</span>) sólo puede ser legible para <code>root</code>, puede que un intruso consiga acceso de lectura a ese fichero, incluso sin haber alcanzado el acceso de escritura como root.</p></div><div class=paragraph><p>Sus "scripts" de seguridad deben buscar siempre cambios en el fichero de contraseñas (consulte <a href=#security-integrity>Revisión de integridad de ficheros</a> más abajo) e informar de ellos.</p></div></div><div class=sect3><h4 id=_asegurar_el_kernel_dispositivos_en_bruto_y_el_sistema_sistema_de_ficheros>14.3.5. Asegurar el Kernel, dispositivos en bruto y el sistema sistema de ficheros<a class=anchor href=#_asegurar_el_kernel_dispositivos_en_bruto_y_el_sistema_sistema_de_ficheros></a></h4><div class=paragraph><p>Si un atacante compromete <code>root</code> puede hacer cualquier cosa, pero hay ciertas cosas que puede usted preparar para "curarse en salud". Por ejemplo, la mayoría de los kernel modernos tienen un dispositivo de los Kernels modernos tienen un integrado un dispositivo de paquetes. En FreeBSD se llama <span class=filename>bpf</span>. Un intruso típico tratará de ejecutar un "sniffer" de paquetes en una máquina comprometida. No debería darle a ese intruso tal recurso, y la mayoría de los sistemas no necesitan el dispositivo <span class=filename>bpf</span>.</p></div><div class=paragraph><p>Pero si desactiva el dispositivo <span class=filename>bpf</span> todavía tendrá que preocuparse por <span class=filename>/dev/mem</span> y <span class=filename>/dev/kmem</span>. Desde ellos el intruso podría en dispositivos de disco en bruto. También hay que tener muy en cuenta una opción del kernel llamada cargador de módulos, <a href="https://man.freebsd.org/cgi/man.cgi?query=kldload&amp;sektion=8&amp;format=html">kldload(8)</a>. Un intruso con iniciativa puede usar un módulo KLD para instalar su propio dispositivo <span class=filename>bpf</span>, u otro dispositivo que le permita el "sniffing" en un kernel en ejecución. Para prevenir estos problemas debe ejecutar el kernel en un nivel de seguridad mayor, al menos en securelevel 1. Puede configurar el securelevel mediante una <code>sysctl</code> en la variable <code>kern.securelevel</code>. Una vez que tiene su securelevel a 1, los accesos de escritura a dispositivos en bruto se denegarán y se impondrán las banderas especiales <code>schg</code>. También debe cerciorarse de activar la bandera <code>schg</code> en binarios críticos para el arranque, directorios y scripts (dicho de otro modo, todo aquello que se ejecuta <em>antes</em> de que se active el securelevel). Puede ser que todo esto sea una exageración, sobre todo teniendo en cuenta que la actualización del sistema se complica bastante a medida que se incrementa el nivel de seguridad. Puede ejecutar el sistema a un nivel de seguridad superior pero no activar la bandera <code>schg</code> en cada fichero y directorio del sistema. Otra posibilidad es montar <span class=filename>/</span> y <span class=filename>/usr</span> como sólo lectura. Recuerde que siendo demasiado draconiano en aquello que busca proteger puede dificultar mucho la detección de una intrusión.</p></div></div><div class=sect3><h4 id=security-integrity>14.3.6. Revisión de integridad de ficheros: binarios, ficheros de configuración, etc.<a class=anchor href=#security-integrity></a></h4><div class=paragraph><p>Cuando se piensa de proteccón, sólo se puede proteger la configuración central del sistema y los ficheros de control hasta el momento en el que el factor comodidad salta a la palestra. Por ejemplo, si usa <code>chflags</code> para activar el bit <code>schg</code> en la mayoría de los ficheros de <span class=filename>/</span> y <span class=filename>/usr</span> probablemente sea contraproducente; puede proteger los ficheros haciéndolo, pero también cierra una vía de detección. La última capa de su modelo de seguridad tipo cebolla es quizás la más importante: la detección. El resto de su estructura de seguridad será inútil (o peor aún, le proporcionará un sentimiento de seguridad totalmente infundado) si no puede detectar posibles intrusiones. La mitad del trabajo de la cebolla es alentar al atacante, en lugar de detenerlo, para darle a la parte de la ecuación de detección una oportunidad de atraparlo con las manos en la masa.</p></div><div class=paragraph><p>La mejor manera de detectar una intrusión es buscar ficheros modificados, perdidos, o cuya presencia o estado sea inesperado. La mejor forma de buscar ficheros modificados es desde otro sistema (que muchas veces es centralizado) con acceso restringido. Escribir sus "scripts" de seguridad en un sistema "extraseguro" y con acceso restringido los hace casi invisibles a posibles atacantes, y esto es algo muy importante. potenciales, y esto es importante. Para poderle sacar el máximo partido debe proporcionar a esa máquina con acceso restringido un acceso preferente al contenido de las otras máquinas de su entorno; suele hacerse mediante la importación vía NFS de sólo lectura de las demás máquinas, o configurando pares de llaves ssh para acceder a las otras máquinas desde la que tiene el acceso restringido. Si exceptuamos el tráfico de red, NFS es el método menos visible y le permite monitorizar los sistemas de ficheros de cada máquina cliente de forma prácticamente indetectable. Si su servidor de acceso restringido está conectado a las máquinas clientes a través de un concentrador o a través de varias capas de encaminamiento el método NFS puede ser muy inseguro, por lo que ssh puede ser la mejor opción, incluso con las huellas de auditoría que ssh va dejando.</p></div><div class=paragraph><p>Una vez que le da a una máquina de acceso restringido (al menos) acceso de lectura a los sistemas cliente que va a monitorizar, tendrá que escribir "scripts" para efectuar la monitorización. Si va a usar un montaje NFS puede escribir "scripts" utilizando simples herramientas del sistema como <a href="https://man.freebsd.org/cgi/man.cgi?query=find&amp;sektion=1&amp;format=html">find(1)</a> y <a href="https://man.freebsd.org/cgi/man.cgi?query=md5&amp;sektion=1&amp;format=html">md5(1)</a>. Es aconsejable ejecutar MD5 físicamente en los ficheros de las máquinas cliente al menos una vez al día, y comprobar los ficheros de control (los que hay en <span class=filename>/etc</span> y <span class=filename>/usr/local/etc</span>) con una frecuencia incluso mayor. Si aparecen discrepancias al compararlos con la información basada en MD5 que la máquina de acceso restringido usa como base debe hacer una comprobación inmediata y profunda. Un buen "script" también debe buscar binarios que sean suid sin razón aparente, y ficheros nuevos o borrados en particiones del sistema como <span class=filename>/</span> y <span class=filename>/usr</span>.</p></div><div class=paragraph><p>Si usa ssh en lugar de NFS será mucho más complicado escribir el "script" de seguridad. En esencia, tiene que pasar por <code>scp</code> los "scripts" a la máquina cliente para poder ejecutarlos, haciéndolos visibles; por seguridad, también tendrá que pasar vía <code>scp</code> los binarios (por ejemplo find) que utilizan dichos "scripts". El cliente ssh de la máquina cliente puede estar ya bajo el control del intruso. Con todo y con eso, puede ser necesario usar ssh si trabaja sobre enlaces inseguros, también es mucho más difícil de manejar.</p></div><div class=paragraph><p>Un buen "script" de seguridad buscará también cambios en la configuración de los ficheros de acceso de usuarios y miembros del personal de administración: <span class=filename>.rhosts</span>, <span class=filename>.shosts</span>, <span class=filename>.ssh/authorized_keys</span>, etc; en resumen, ficheros fuera del rango de revisión <code>MD5</code>.</p></div><div class=paragraph><p>Si tiene que vérselas con una cantidad enorme de espacio en disco para usuarios le llevará mucho tiempo recorrer cada fichero de cada partición. En su caso sería una buena idea configurar mediante opciones de montaje la deshabilitación de binarios y dispositivos suid en esas particiones. Revise las opciones <code>nodev</code> y <code>nosuid</code> de <a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a>. Debería comprobarlos de todas maneras al menos una vez por semana, ya que el objeto de esta capa es detectar intrusiones, efectivas o no.</p></div><div class=paragraph><p>La contabilidad de procesos (vea <a href="https://man.freebsd.org/cgi/man.cgi?query=accton&amp;sektion=8&amp;format=html">accton(8)</a>) es una opción con una carga relativamente ligera para el sistema operativo, y puede ayudarle como mecanismo de evaluación tras una intrusión. Es especialmente útil para rastrear cómo consiguión realmente acceder el intruso al sistema (asumiendo que el fichero esté intacto después de la intrusión).</p></div><div class=paragraph><p>Los "scripts" de seguridad deben procesar los logs, y los propios logs deben generarse de la forma más segura posible: un syslog remoto puede ser muy útil. Un intruso trata de cubrir sus huellas, los logs son un recurso crítico cuando el administrador de sistemas intenta determinar la hora y el método de la intrusión inicial. La ejecución de la consola del sistema en un puerto serie y recolectar la información de forma periódica en una máquina segura de monitorización de consolas es una forma de cumplir esta tarea.</p></div></div><div class=sect3><h4 id=_paranoia>14.3.7. Paranoia<a class=anchor href=#_paranoia></a></h4><div class=paragraph><p>Un poco de paranoia nunca está de más. Como norma, un administrador de sistemas puede añadir cualquier tipo de mecanismo de seguridad siempre y cuando no afecte a la comodidad, y puede añadir mecanismos de seguridad que <em>sí</em> afecten a la comodidad si tiene una buena razón para hacerlo. Más aún, un administrador de seguridad debe mezclar un poco de ambas cosas: si sigue al pie de la letra las recomendaciones que se dan en este documento también está sirviendo en bandeja de plata al posible atancante su metodología. Ese posible atacante también tiene acceso a este documento.</p></div></div><div class=sect3><h4 id=_ataques_de_denegación_de_servicio>14.3.8. Ataques de denegación de servicio<a class=anchor href=#_ataques_de_denegación_de_servicio></a></h4><div class=paragraph><p>Esta sección cubre ataques de denegación de servicio. Un ataque DoS suele consistir en un ataque mediante paquetes. NO hay mucho que pueda hacerse contra un ataque mediante paquetes falsificados ("spoofed") que busque saturar su red, pero puede limitar el daño asegurándose de que los ataques no tiren sus servidores.</p></div><div class="olist arabic"><ol class=arabic><li><p>Limitación de forks en el servidor.</p></li><li><p>Limitación de ataques "springboard" (ataques de respuesta ICMP, ping broadcast, etc.)</p></li><li><p>Caché de rutas del kernel.</p></li></ol></div><div class=paragraph><p>Un típico ataque DoS contra un servidor con instancias (forks) sería tratar de provocar que el servidor consuma procesos, descriptores de fichero y memoria hasta tirar la máquina. inetd (consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=inetd&amp;sektion=8&amp;format=html">inetd(8)</a>) dispone de varias opciones para limitar este tipo de ataque. Recuerde que aunque es posible evitar que una máquina caiga, generalmente no es posible evitar que un servicio sea vea interrumpido a causa el ataque. Consulte la página de manual de inetd atentamente y sobre todo estudie las las opciones <code>-c</code>, <code>-C</code>, y <code>-R</code>. Observe que los ataques con direcciones IP falsificadas sortearán la opción <code>-C</code> de inetd, así que debe usar una combinación de opciones. Algunos servidores autónomos ("standalone") cuentan con parámetros de autolimitación de instancias.</p></div><div class=paragraph><p>Sendmail tiene la opción <code>-OMaxDaemonChildren</code>, que tiende a funcionar mucho mejor que las opciones de límite de carga de sendmail debido al retraso que provoca la carga. Debe especificar un parámetro <code>MaxDaemonChildren</code> al inicio de sendmail que sea lo suficientemente alto como para gestionar la carga esperada, pero no tan alto que la computadora no pueda absorber tal número de sendmails sin caerse de boca. También es prudente ejecutar sendmail en modo de cola (<code>-ODeliveryMode=queued</code>) y ejecutar el dæmon (<code>sendmail -bd</code>) de manera independiente de las ejecuciones de cola (<code>sendmail -q15m</code>). Si a pesar de todo necesita entregas en tiempo real puede ejecutar la cola a un intervalo menor, como <code>-q1m</code>, pero asegúrese de especificar una opción <code>MaxDaemonChildren</code> razonable para <em>ese</em> sendmail y así evitar fallos en cascada.</p></div><div class=paragraph><p>Syslogd puede recibir ataques directos y se recomienda encarecidamente que utilice la opción <code>-s</code> siempre que sea posible, y si no la opción <code>-a</code>.</p></div><div class=paragraph><p>También debe ser extremadamente cuidadoso con servicios de conexión inversa como el ident inverso de TCP Wrapper, que puede recibir ataques directos. No se suele usar el ident inverso de TCP Wrapper por esa misma razón.</p></div><div class=paragraph><p>Es una muy buena idea proteger los servicios internos de acceso externo protegiéndolos vía con un cortafuegos en los routers de frontera. La idea es prevenir ataques de saturación desde el exterior de la LAN, y no tanto para proteger servicios internos de compromisos <code>root</code> basados en red. Configure siempre un cortafuegos exclusivo, esto es, "restringir todo <em>menos</em> los puertos A, B, C, D y M-Z". De esta manera restringirá todos sus puertos con números bajos excepto ciertos servicios específicos como named (si es el servidor primario de una zona), ntalkd, sendmail, y otros servicios accesibles desde Internet. Si configura el cortafuegos de la otra manera (como un cortafuegos inclusivo o permisivo), tiene grandes posibilidades de que olvide "cerrar" un par de servicios, o de que agregue un nuevo servicio interno y olvide actualizar el cortafuegos. Puede incluso abrir el rango de números de puerto altos en el cortafuegos para permitir operaciones de tipo permisivo sin comprometer sus puertos bajos. Recuerde también que FreeBSD le permite controlar el rango de números de puerto utilizados para asignación dinámica a través de las numerosas <code>net.inet.ip.portrange</code> de <code>sysctl</code> (<code>sysctl -a | fgrep portrange</code>), lo cual también facilita la complejidad de la configuración de su cortafuegos. Por ejemplo, puede utilizar un rango normal primero/último de 4000 ó 5000, y un rango de puerto alto de 49152 a 65535; bloquée todo por debajo de 4000 (excepto para ciertos puertos específicos accesibles desde Internet, por supuesto).</p></div><div class=paragraph><p>Otro ataque DoS común es llamado ataque "springboard": atacar un servidor de forma que genere respuestas que lo sobrecarguen, sobrecarguen la red local o alguna otra máquina. Los ataques más comunes de este tipo son los <em>ataques ICMP ping broadcast</em>. El atacante falsifica paquetes ping enviados a la dirección broadcast de su LAN simulando que la dirección IP origen es la de la máquina que desean atacar. Si sus routers de frontera no están configurados para lidiar con pings a direcciones de broadcast su LAN termina generando suficientes respuestas a la dirección origen falsificada como para saturar a la víctima, especialmente cuando el atacante utiliza el mismo truco en varias docenas de direcciones broadcast en varias docenas de redes diferentes a la vez. Se han medido ataques de broadcast de más de ciento veinte megabits. Un segundo tipo de ataque "springboard" bastante común se da contra el sistema de informe de error de ICMP. Un atacante puede saturar la conexión entrante de red de un servidor mediante la construcción de paquetes que generen respuestas de error ICMP, provocando que el servidor sature su conexión saliente de red con respuestas ICMP. Este tipo de ataque también puede tumbar el servidor agotando sus "mbufs", especialmente si el servidor no puede drenar lo suficientemente rápido las respuestas ICMP que genera. El kernel de FreeBSD tiene una opción de compilación llamada <code>ICMP_BANDLIM</code>, que limita la efectividad de este tipo de ataques. La última gran categoría de ataques "springboard" está relacionada con ciertos servicios de inetd, como el servicio de eco udp. El atacante simplemente imita un paquete UDP con el puerdo de eco del servidor A como dirección de origen, y el puerto eco del servidor B como dirección de destino, estando ambos servidores en la misma LAN. Un atacante puede sobrecargar ambos servidores y la propia LAN inyectando simplemente un par de paquetes. Existen problemas similares con el puerto chargen. Un administrador de sistemas competente apagará todos estos servicios internos de verificación de inetd.</p></div><div class=paragraph><p>Los ataques con paquetes falsificados pueden utilizarse también para sobrecargar la caché de rutas del kernel. Consulte los parámetros de <code>sysctl net.inet.ip.rtexpire</code>, <code>rtminexpire</code>, y <code>rtmaxcache</code>. Un ataque de paquetes falsificados que utiliza una dirección IP origen aleatoria provocará que el kernel genere una ruta temporal en caché en su tabla de rutas, visible con <code>netstat -rna | fgrep W3</code>. Estas rutas suelen expiran en 1600 segundos más o menos. Si el kernel detecta que la tabla de rutas en caché es ya demasiado grande reducirá dinámicamente <code>rtexpire</code>, pero nunca la reducirá a un valor que sea menor que <code>rtminexpire</code>. Esto nos presenta dos problemas:</p></div><div class="olist arabic"><ol class=arabic><li><p>El kernel no reacciona con suficiente rapidez cuando un servidor ligeramente cargado es atacado.</p></li><li><p>El <code>rtminexpire</code> no es lo suficientemente bajo para que el kernel sobreviva a un ataque sostenido.</p></li></ol></div><div class=paragraph><p>Si sus servidores están conectados a Internet mediante mediante una línea T3 o superior puede ser prudente corregir manualmente <code>rtexpire</code> y <code>rtminexpire</code> por medio de <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a>. Nunca ponga ambos parámetros a cero (a menos que desée estrellar la máquina). Configurar ambos parámetros a 2 segundos debería bastar para proteger de ataques la tabla de rutas.</p></div></div><div class=sect3><h4 id=_otros_aspectos_del_acceso_con_kerberos_y_ssh>14.3.9. Otros aspectos del acceso con Kerberos y SSH<a class=anchor href=#_otros_aspectos_del_acceso_con_kerberos_y_ssh></a></h4><div class=paragraph><p>Existen un par de detalles con respecto a Kerberos y ssh que debe analizar sy pretende usarlos. Kerberos V es un excelente protocolo de protocolo de autentificación, pero hay errores en la versión kerberizada de telnet y rlogin que las hacen inapropiadas para gestionar flujos binarios. Ademé Kerberos no cifra por defecto una sesión a menos que utilice la opción <code>-x</code>. ssh cifra todo por defecto.</p></div><div class=paragraph><p>ssh funciona bastante bien en todos los casos, con la sola salvedad de que por defecto reenvía llaves de cifrado. Esto significa que si usted tiene una estación de trabajo segura, que contiene llaves que le dan acceso al resto del sistema, y hace ssh a una máquina insegura, sus llaves se pueden utilizar. Las llaves en sí no se exponen, pero ssh crea un puerto de reenvío durante el login, y si un atacante ha comprometido el <code>root</code> de la máquina insegura, puede utilizar ese puerto para usar sus llaves y obtener acceso a cualquier otra máquina que sus llaves abran.</p></div><div class=paragraph><p>Le recomendamos que, siempre que sea posible, use ssh combinado con Kerberos en los login de su personal de administración. para logins de staff. Puede compilar ssh con soporte de Kerberos. Esto reducirá su dependencia de llaves ssh expuestas, al mismo tiempo que protege las contraseñas vía Kerberos. Las llaves ssh deben usarse sólamente para tareas automáticas desde máquinas seguras (algo que Kerberos no hace por incompatibilidad). Recomendamos también que desactive el reenvío de llaves en la configuración de ssh, o que use la opción <code>from=IP/DOMAIN</code> que ssh incluye en <span class=filename>authorized_keys</span>; así la llave sólo podrá ser utilizada por entidades que se validen desde máquinas específicas.</p></div></div></div><div class=sect2><h3 id=crypt>14.4. DES, MD5 y Crypt<a class=anchor href=#crypt></a></h3><div class=paragraph><p>Cada usuario de un sistema UNIX® tiene una contraseña asociada a su cuenta. Parece obvio que estas contraseñas sólo deben ser conocidas por el usuario y por el sistema operativo. Para que estas contraseñas permanezcan en secreto se cifran con lo que se conoce como un "hash de una pasada", esto es, sólo pueden ser fácilmente cifradas pero no descifradas. En otras palabras, lo que acabamos de decir es tan obvio que ni siguiera es verdad: el propio sistema operativo no sabe cuál es <em>realmente</em> la contraseña. Lo único que conoce es la versión <em>cifrada</em> de la contrasenña. La única manera de obtener la contraseña en "texto plano" es por medio de una búsqueda de fuerza bruta en el espacio de contraseñas posibles.</p></div><div class=paragraph><p>Por desgracia la única manera segura de cifrar contraseñas cuando UNIX® empezó a hacerlo estaba basada en DES, ("Data Encryption Standard", "estándar de cifrado de datos"). Esto no era un gran problema para usuarios residentes en los EEUU, pero el código fuente de FreeBSD no se podía exportar desde los EEUU, así que FreeBSD hubo de buscar una forma de complir las leyes de EEUU y al mismo tiempo mantener la compatibilidad con otras variantes de UNIX® que que todavía utilizaban DES.</p></div><div class=paragraph><p>La solución fué dividir las bibliotecas de cifrado para que los usuarios de EEUU pudieran instalar las bibliotecas DES pero los usuarios del resto del mundo tuvieran un método de cifrado que pudiera ser exportado. Así es como FreeBSD comenzó a usar MD5 como su método de cifrado por defecto. MD5 se considera más seguro que DES, así que se mantiene la opción de poder instalar DES por motivos de compatibilidad.</p></div><div class=sect3><h4 id=_cómo_reconocer_su_mecanismo_de_cifrado>14.4.1. Cómo reconocer su mecanismo de cifrado<a class=anchor href=#_cómo_reconocer_su_mecanismo_de_cifrado></a></h4><div class=paragraph><p>En versiones anteriores a FreeBSD 4.4 <span class=filename>libcrypt.a</span> era un enlace simbólico que apuntaba a la biblioteca que se usaba para el cifrado. En FreeBSD 4.4 se cambió <span class=filename>libcrypt.a</span> para ofrecer una biblioteca hash configurable de validación de contraseñas. Actualmente la biblioteca permite funciones hash DES, MD5 y Blowfish. FreeBSD utiliza por defecto MD5 para cifrar contraseñas.</p></div><div class=paragraph><p>Es muy sencillo identificar qué método usa FreeBSD para cifrar. Una forma es examinando las contraseñas cifradas en <span class=filename>/etc/master.passwd</span>. Las contraseñas cifradas con el hash MD5 son más largas que las cifradas con el hash DES, y también comienzan por los caracteres <code>$1$</code>. Las contraseñas que comienzan por <code>$2a$</code> están cifradas con la función hash de Blowfish. Las contraseñas DES no tienen ninguna característica particular, pero son más cortas que las contraseñas MD5, y están codificadas en un alfabeto de 64 caracteres que no incluye el caracter <code>$</code>; es por esto que una cadena relativamente corta que comience con un signo de dólar es muy probablemente una contraseña DES.</p></div><div class=paragraph><p>El formato de contraseña a usar en nuevas contraseñas se define en <span class=filename>/etc/login.conf</span> mediante <code>passwd_format</code>, pudiendo tener los valores <code>des</code>, <code>md5</code> o <code>blf</code>. Consulte la página de manual <a href="https://man.freebsd.org/cgi/man.cgi?query=login.conf&amp;sektion=5&amp;format=html">login.conf(5)</a> para más información.</p></div></div></div><div class=sect2><h3 id=one-time-passwords>14.5. Contraseñas de un solo uso<a class=anchor href=#one-time-passwords></a></h3><div class=paragraph><p>S/Key es un esquema de contraseña de un solo uso basado en una función de hash de sentido único. FreeBSD utiliza el hash MD4 por compatibilidad, pero otros sistemas usan MD5 y DES-MAC. S/Key forma parte del sistema base de FreeBSD desde la versión 1.1.5 y se usa también en un número creciente de otros sistemas operativos. S/Key es una marca registrada de Bell Communications Research, Inc.</p></div><div class=paragraph><p>A partir de la versión 5.0 de FreeBSD S/Key fué reemplazado por su equivalente OPIE ("One-time Passwords In Everything", "Contraseñas de un solo uso para todo"). OPIE usa por defecto hash MD5.</p></div><div class=paragraph><p>En esta sección se explican tres tipos de contraseña. La primera es la típica contraseña al estilo UNIX® o Kerberos; las llamaremos "contraseñas UNIX®". El segundo tipo es la contraseña de un solo uso, que se genera con el programa <code>key</code> de S/Key o con <a href="https://man.freebsd.org/cgi/man.cgi?query=opiekey&amp;sektion=1&amp;format=html">opiekey(1)</a> de OPIE, y que aceptan los programas <code>keyinit</code>, <a href="https://man.freebsd.org/cgi/man.cgi?query=opiepasswd&amp;sektion=1&amp;format=html">opiepasswd(1)</a>, y el prompt de login; llamaremos a esta una "contraseña de un solo uso". El último tipo de contraseña es la contraseña secreta que le da usted a los programas <code>key</code>/<code>opiekey</code> (y a veces <code>keyinit</code>/<code>opiepasswd</code>), que se usa para generar contraseñas de un solo uso; a estas las llamaremos "contraseñas secretas", o simplemente "contraseña".</p></div><div class=paragraph><p>La contraseña secreta no tiene nada que ver con su contraseña UNIX®; pueden ser la misma, pero no es recomendable. Las contraseñas secretas S/Key y OPIE no están limitadas a 8 caracteres como las contraseñas UNIX® antiguas, pueden ser tan largas como se quiera. Las contraseñas con frases de seis o siete palabras muy largas son bastante comunes. El funcionamiento del sistema S/Key o el OPIE es en gran parte completamente independiente del sistema de contraseñas UNIX®.</p></div><div class=paragraph><p>Además de la contraseña hay dos datos que son importantes para S/Key y OPIE. Uno es lo que se conoce como "semilla" o "llave", que consiste en dos letras y cinco dígitos. El otro dato importante se llama la "cuenta de iteración", que es un número entre 1 y 100. S/Key genera la contraseña de un solo uso concatenando la semilla y la contraseña secreta, aplica el hash MD4/MD5 tantas veces como especifique la cuenta de iteración y convierte el resultado en seis palabras cortas en inglés. Estas seis palabras en inglés son su contraseña de un solo uso. El sistema de autentificación (principalmente PAM) mantiene un registro del uso de contraseñas de un solo uso, y el usuario puede validarse si el hash de la contraseña que proporciona es igual a la contraseña previa. Como se utiliza un hash de sentido único es imposible generar futuras contraseñas de un solo uso si una contraseña que ya ha sido usada fuera capturada; la cuenta de iteración se reduce después de cada login correcto para sincronizar al usuario con el programa login. Cuanto la iteración llega a 1, S/Key y OPIE deben reinicializar.</p></div><div class=paragraph><p>Hay tres programas involucrados en cada uno de estos sistemas. Los programas <code>key</code> y <code>opiekey</code> aceptan una cuenta iterativa, una semilla y una contraseña secreta, y generan una contraseña de un solo uso o una lista consecutiva de contraseñas de un solo uso. Los programas <code>keyinit</code> y <code>opiepasswd</code> se usan respectivamente para inicializar S/Key y OPIE, y para cambiar contraseñas, cuentas iterativas o semillas; toman ya sea una frase secreta, o una cuenta iterativa y una contraseña de un solo uso. Los programas <code>keyinfo</code> y <code>opieinfo</code> examinan los ficheros de credenciales correspondientes (<span class=filename>/etc/skeykeys</span> o <span class=filename>/etc/opiekeys</span>) e imprimen la cuenta iterativa y semilla del usuario invocante.</p></div><div class=paragraph><p>Explicaremos cuatro tipos de operaciones diferentes. La primera es usar <code>keyinit</code> o <code>opiepasswd</code> a través de una conexión segura para configurar contraseñas de un solo uso por primera vez, o para cambiar su contraseña o semilla. La segunda operación es utilizar <code>keyinit</code> o <code>opiepasswd</code> a través de una conexión insegura, además de usar <code>key</code> u <code>opiekey</code> sobre una conexión segura para hacer lo mismo. La tercera es usar <code>key</code>/<code>opiekey</code> para conectarse a través de una conexión insegura. La cuarta es usar <code>opiekey</code> o <code>key</code> para generar numerosas llaves, que pueden ser escritas para llevarlas con usted al ir a algún lugar desde el que no se puedan hacer conexiones seguras a ningún sitio.</p></div><div class=sect3><h4 id=_inicialización_de_conexiones_seguras>14.5.1. Inicialización de conexiones seguras<a class=anchor href=#_inicialización_de_conexiones_seguras></a></h4><div class=paragraph><p>Para inicializar S/Key por primera vez cambie su contraseña, o cambie su semilla mientras está conectado a través de una conexión segura (esto es, en la consola de una máquina o vía ssh); use <code>keyinit</code> sin ningún parámetro:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% keyinit
Adding unfurl:
Reminder - Only use this method <span class=k>if </span>you are directly connected.
If you are using telnet or rlogin <span class=nb>exit </span>with no password and use keyinit <span class=nt>-s</span><span class=nb>.</span>
Enter secret password:
Again secret password:

ID unfurl s/key is 99 to17757
DEFY CLUB PRO NASH LACE SOFT</code></pre></div></div><div class=paragraph><p>En OPIE se utiliza <code>opiepasswd</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% opiepasswd <span class=nt>-c</span>
<span class=o>[</span>grimreaper] ~ <span class=nv>$ </span>opiepasswd <span class=nt>-f</span> <span class=nt>-c</span>
Adding unfurl:
Only use this method from the console<span class=p>;</span> NEVER from remote. If you are using
telnet, xterm, or a dial-in, <span class=nb>type</span> ^C now or <span class=nb>exit </span>with no password.
Then run opiepasswd without the <span class=nt>-c</span> parameter.
Using MD5 to compute responses.
Enter new secret pass phrase:
Again new secret pass phrase:
ID unfurl OTP key is 499 to4268
MOS MALL GOAT ARM AVID COED</code></pre></div></div><div class=paragraph><p>En <code>Enter new secret pass phrase:</code> o <code>Enter secret password:</code>, debe introducir una contraseña o frase. Recuerde que no es la contraseña que utilizará para entrar, se usará para generar sus llaves de un solo uso. La línea "ID" da los parámetros de su instancia en particular: su nombre de login, la cuenta iterativa y semilla. En el momento del login el sistema recordará estos parámetros y los presentará de nuevo para que no tenga que recordarlos. La última línea proporciona las contraseéas de un solo uso que corresponden a esos parámetros y su contraseña secreta; si fuera a hacer login de manera inmediata, debería usar esta contraseña de una sola vez.</p></div></div><div class=sect3><h4 id=_inicialización_de_conexiones_inseguras>14.5.2. Inicialización de conexiones inseguras<a class=anchor href=#_inicialización_de_conexiones_inseguras></a></h4><div class=paragraph><p>Para inicializar o cambiar su contraseña secreta a través de una conexión insegura, necesitará tener alguna conexión segura a algún lugar donde pueda ejecutar <code>key</code> u <code>opiekey</code>; puede ser gracias a un accesorio de escritorio o en una Macintosh®, o un prompt de shell en una máquina en la que confíe. Necesitará también una cuenta iterativa (100 probablemente sea un buen valor), y puede usar su propia semilla, o usar una generada aleatoriamente. Siguiendo con la conexión insegura (hacia la máquina que está inicializando), ejecute <code>keyinit -s</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% keyinit <span class=nt>-s</span>
Updating unfurl:
Old key: to17758
Reminder you need the 6 English words from the key command.
Enter sequence count from 1 to 9999: 100
Enter new key <span class=o>[</span>default to17759]:
s/key 100 to 17759
s/key access password:
s/key access password:CURE MIKE BANE HIM RACY GORE</code></pre></div></div><div class=paragraph><p>En OPIE debe usar <code>opiepasswd</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% opiepasswd

Updating unfurl:
You need the response from an OTP generator.
Old secret pass phrase:
        otp-md5 498 to4268 ext
        Response: GAME GAG WELT OUT DOWN CHAT
New secret pass phrase:
        otp-md5 499 to4269
        Response: LINE PAP MILK NELL BUOY TROY

ID mark OTP key is 499 gr4269
LINE PAP MILK NELL BUOY TROY</code></pre></div></div><div class=paragraph><p>Para aceptar la semilla por defecto (la que el programa <code>keyinit</code> llama <code>key</code>, "llave", para terminar de complicar las cosas), pulse <kbd>Enter</kbd>. Antes de introducir una una contraseña de acceso cambie a su conexión o accesorio de escritorio S/Key y dele el mismo parámetro:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% key 100 to17759
Reminder - Do not use this program <span class=k>while </span>logged <span class=k>in </span>via telnet or rlogin.
Enter secret password: &lt;secret password&gt;
CURE MIKE BANE HIM RACY GORE</code></pre></div></div><div class=paragraph><p>O para OPIE:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% opiekey 498 to4268
Using the MD5 algorithm to compute response.
Reminder: Don<span class=s1>&#39;t use opiekey from telnet or dial-in sessions.
Enter secret pass phrase:
GAME GAG WELT OUT DOWN CHAT</span></code></pre></div></div><div class=paragraph><p>Vuelva a la conexión insegura y copie la contraseña de un solo uso generada al programa que quiera usar.</p></div></div><div class=sect3><h4 id=_generación_una_sola_contraseña_de_un_solo_uso>14.5.3. Generación una sola contraseña de un solo uso<a class=anchor href=#_generación_una_sola_contraseña_de_un_solo_uso></a></h4><div class=paragraph><p>Una vez que ha inicializado S/Key u OPIE, cuando haga login verá un "prompt" parecido al siguiente:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% telnet ejemplo.com
Trying 10.0.0.1...
Connected to ejemplo.com
Escape character is <span class=s1>&#39;^]&#39;</span><span class=nb>.</span>

FreeBSD/i386 <span class=o>(</span>ejemplo.com<span class=o>)</span> <span class=o>(</span>ttypa<span class=o>)</span>

login: &lt;username&gt;
s/key 97 fw13894
Password:</code></pre></div></div><div class=paragraph><p>O, en el caso de OPIE:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% telnet ejemplo.com
Trying 10.0.0.1...
Connected to ejemplo.com
Escape character is <span class=s1>&#39;^]&#39;</span><span class=nb>.</span>

FreeBSD/i386 <span class=o>(</span>ejemplo.com<span class=o>)</span> <span class=o>(</span>ttypa<span class=o>)</span>

login: &lt;nombre_de_usuario&gt;
otp-md5 498 gr4269 ext
Password:</code></pre></div></div><div class=paragraph><p>Como una nota aparte, el "prompt" de S/Key y OPIE cuenta con una opción útil (que no se muestra aquí): si pulsa <kbd>Enter</kbd> en el "prompt" de contraseña el "prompt" activará el eco para que pueda ver en pantalla lo que teclea. Esto puede ser extremadamente útil si está tecleando una contraseña a a mano o desde un la lista impresa.</p></div><div class=paragraph><p>Ahora necesitará generar su contraseña de un sólo uso para responder a este "prompt" de login. Debe hacerlo en un sistema digno de confianza y en el que pueda ejecutar <code>key</code> u <code>opiekey</code>. Existen versiones DOS, Windows® y también para Mac OS®. Ambos usarán la cuenta iterativa y la semilla como opciones de línea de órdenes. Puede cortarlas y pegarlas desde el "prompt" de login de la máquina en la que se está identificando.</p></div><div class=paragraph><p>En el sistema de confianza:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% key 97 fw13894
Reminder - Do not use this program <span class=k>while </span>logged <span class=k>in </span>via telnet or rlogin.
Enter secret password:
WELD LIP ACTS ENDS ME HAAG</code></pre></div></div><div class=paragraph><p>Con OPIE:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% opiekey 498 to4268
Using the MD5 algorithm to compute response.
Reminder: Don<span class=s1>&#39;t use opiekey from telnet or dial-in sessions.
Enter secret pass phrase:
GAME GAG WELT OUT DOWN CHAT</span></code></pre></div></div><div class=paragraph><p>Ahora que tiene su contraseña de un solo uso puede proceder con el login:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>login: &lt;nombre_de_usuario&gt;
s/key 97 fw13894
Password: &lt;Enter para activar el eco&gt;
s/key 97 fw13894
Password <span class=o>[</span><span class=nb>echo </span>on]: WELD LIP ACTS ENDS ME HAAG
Last login: Tue Mar 21 11:56:41 from 10.0.0.2 ...</code></pre></div></div></div><div class=sect3><h4 id=_generación_de_múltiples_contraseñas_de_un_solo_uso>14.5.4. Generación de múltiples contraseñas de un solo uso<a class=anchor href=#_generación_de_múltiples_contraseñas_de_un_solo_uso></a></h4><div class=paragraph><p>A veces usted hay que ir a lugares donde no hay acceso a una máquina de fiar o a una conexión segura. En estos casos, puede utilizar <code>key</code> y <code>opiekey</code> para generar previamente numerosas contraseñas de un solo uso para, una vez impresas, llevárselas a donde hagan falta. Por ejemplo:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% key <span class=nt>-n</span> 5 30 zz99999
Reminder - Do not use this program <span class=k>while </span>logged <span class=k>in </span>via telnet or rlogin.
Enter secret password: &lt;secret password&gt;
26: SODA RUDE LEA LIND BUDD SILT
27: JILT SPY DUTY GLOW COWL ROT
28: THEM OW COLA RUNT BONG SCOT
29: COT MASH BARR BRIM NAN FLAG
30: CAN KNEE CAST NAME FOLK BILK</code></pre></div></div><div class=paragraph><p>O para OPIE:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% opiekey <span class=nt>-n</span> 5 30 zz99999
Using the MD5 algorithm to compute response.
Reminder: Don<span class=s1>&#39;t use opiekey from telnet or dial-in sessions.
Enter secret pass phrase: &lt;secret password&gt;
26: JOAN BORE FOSS DES NAY QUIT
27: LATE BIAS SLAY FOLK MUCH TRIG
28: SALT TIN ANTI LOON NEAL USE
29: RIO ODIN GO BYE FURY TIC
30: GREW JIVE SAN GIRD BOIL PHI</span></code></pre></div></div><div class=paragraph><p>El <code>-n 5</code> pide cinco llaves en secuencia, la opción <code>30</code> especifica que ese debe ser el último número de iteración. Observe que se imprimen en el orden <em>inverso</em> de uso. Si es realmente paranoico escriba los resultados a mano; si no, puede enviar la salida a <code>lpr</code>. Observe que cada línea muestra la cuenta iterativa y la contraseña de un solo uso; puede ir tachando las contraseñas según las vaya utilizando.</p></div></div><div class=sect3><h4 id=_restricción_del_uso_de_contraseñas_unix>14.5.5. Restricción del uso de contraseñas UNIX®<a class=anchor href=#_restricción_del_uso_de_contraseñas_unix></a></h4><div class=paragraph><p>S/Key puede implantar restricciones en el uso de contraseñas UNIX® basándose en el nombre de equipo, nombre de usuario, puerto de terminal o dirección IP de una sesión de login. Consulte el fichero de configuración <span class=filename>/etc/skey.access</span>. La página de manual de <a href="https://man.freebsd.org/cgi/man.cgi?query=skey.access&amp;sektion=5&amp;format=html">skey.access(5)</a> contiene más información sobre el formato del fichero y detalla también algunas precauciones de seguridad que hay que tener en cuenta antes de basar nuestra seguridad en este fichero.</p></div><div class=paragraph><p>Si <span class=filename>/etc/skey.access</span> no existiera (por defecto es así en sistemas FreeBSD 4.X) todos los usuarios podrán disponer de contraseñas UNIX®. Si el fichero existe se exigirá a todos los usuarios el uso de S/Key, a menos que se configure de otro modo en <span class=filename>skey.access</span>. En todos los casos las contraseñas UNIX® son admiten en consola.</p></div><div class=paragraph><p>Aquí hay un ejemplo del fichero de configuración <span class=filename>skey.access</span> que muestra las tres formas más comunes de configuración:</p></div><div class="literalblock programlisting"><div class=content><pre>permit internet 192.168.0.0 255.255.0.0
permit user fnord
permit port ttyd0</pre></div></div><div class=paragraph><p>La primera línea (<code>permit internet</code>) permite a usuarios cuyas direcciones IP origen (las cuales son vulnerables a una falsificación) concuerden con los valores y máscara especificados utilizar contraseñas UNIX®. Esto no debe usarse como mecanismo de seguridad, sino como medio de recordarle a los usuarios autorizados que están usando una red insegura y necesitan utilizar S/Key para la validación.</p></div><div class=paragraph><p>La segunda línea (<code>permit user</code>) permite al nombre de usuario especificado, en este caso <code>fnord</code>, utilizar contraseñas UNIX® en cualquier momento. Hablando en general, esto solo debe ser usado por gente que no puede usar el programa <code>key</code>, como aquellos con terminales tontas o refractarios al aprendizaje.</p></div><div class=paragraph><p>La tercera línea (<code>permit port</code>) permite a todos los usuarios validados en la línea de terminal especificada utilizar contraseñas UNIX®; esto puede usarse para usuarios que se conectan mediante "dial-ups".</p></div><div class=paragraph><p>OPIE puede restringir el uso de contraseñas UNIX® basándose en la dirección IP de una sesión de login igual que lo haría S/Key. El fichero que gestiona esto es <span class=filename>/etc/opieaccess</span>, que está incluído por defecto en sistemas FreeBSD 5.0 o posteriores. Revise <a href="https://man.freebsd.org/cgi/man.cgi?query=opieaccess&amp;sektion=5&amp;format=html">opieaccess(5)</a> para más información sobre este fichero y qué consideraciones de seguridad debe tener presentes a la hora de usarlo.</p></div><div class=paragraph><p>Veamos un ejemplo de <span class=filename>opieaccess</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>permit 192.168.0.0 255.255.0.0</pre></div></div><div class=paragraph><p>Esta línea permite a usuarios cuya dirección IP de origen (vulnerable a falsificación) concuerde con los valores y máscara especificados, utilizar contraseñas UNIX® en cualquier momento.</p></div><div class=paragraph><p>Si no concuerda ninguna regla en <span class=filename>opieaccess</span> se niegan por defecto los logins no-OPIE.</p></div></div></div><div class=sect2><h3 id=tcpwrappers>14.6. TCP Wrappers<a class=anchor href=#tcpwrappers></a></h3><div class=paragraph><p>Cualquiera que esté familiarizado con <a href="https://man.freebsd.org/cgi/man.cgi?query=inetd&amp;sektion=8&amp;format=html">inetd(8)</a> probablemente haya oído hablar de TCP Wrappers, pero poca gente parece comprender completamente su utilidad en un entorno de red. Parece que todos quieren instalar un cortafuegos para manejar conexiones de red. Aunque un cortafuegos tiene una amplia variedad de usos hay cosas que un cortafuegos no es capaz de gestionar, como el envío de texto como respuesta al creador de la conexión. El software TCP hace esto y más. En las siguientes secciones se explicarán unas cuantas opciones de TCP Wrappers y, cuando sea necesario, se mostrarán ejemplos de configuraciones.</p></div><div class=paragraph><p>El software TCP Wrappers extiende las habilidades de <code>inetd</code> para ofrecer soporte para cada servidor dæmon bajo su control. Utilizando este método es posible proveer soporte de logs, devolver mensajes a conexiones, permitir a un dæmon aceptar solamente conexiones internas, etc. Aunque algunas de estas opciones pueden conseguirse gracias a un cortafuegos, no sólo añadirá una capa extra de seguridad, sino que irá más allá del nivel de control ue un cortafuegos puede ofrecerle.</p></div><div class=paragraph><p>Las brillantes capacidades de TCP Wrappers no deben considerarse una alternativa a un buen cortafuegos. TCP Wrappers puede usarse conjuntamente con un cortafuegos u otro sistema de de seguridad, pues ofrece una capa extra de protección para el sistema.</p></div><div class=paragraph><p>Ya que es una extensión de la configuración de <code>inetd</code>, se da por hecho que el lector ha leído la sección <a href=./#network-inetd>configuración de inetd</a>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Aunque los programas ejecutados por <a href="https://man.freebsd.org/cgi/man.cgi?query=inetd&amp;sektion=8&amp;format=html">inetd(8)</a> no son exactamente "dæmons" tradicionalmente han recibido ese nombre. Dæmon es, por tanto, el término que usaremos en esta sección.</p></div></td></tr></tbody></table></div><div class=sect3><h4 id=_configuración_inicial>14.6.1. Configuración inicial<a class=anchor href=#_configuración_inicial></a></h4><div class=paragraph><p>El único requisito para usar TCP Wrappers en FreeBSD es que el servidor <code>inetd</code> se inicie desde <span class=filename>rc.conf</span> con la opción <code>-Ww</code> (es la configuración por defecto). Por descontado, se presupone que <span class=filename>/etc/hosts.allow</span> estará correctamente configurado, pero <a href="https://man.freebsd.org/cgi/man.cgi?query=syslogd&amp;sektion=8&amp;format=html">syslogd(8)</a> enviará mensajes a los logs del sistema si no es así.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>A diferencia de otras implementaciones de TCP Wrappers, se ha dejado de usar <span class=filename>hosts.deny</span>. Todas las opciones de configuración deben ir en <span class=filename>/etc/hosts.allow</span>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>En la configuración más simple las políticas de conexión de dæmons están configuradas ya sea a permitir o bloquear, dependiendo de las opciones en <span class=filename>/etc/hosts.allow</span>. La configuración por defecto en FreeBSD consiste en permitir una conexión a cada dæmon iniciado por <code>inetd</code>. Es posible modificar esta configuración, pero explicaremos cómo hacerlo después de exponer la configuración básica.</p></div><div class=paragraph><p>La configuración básica tiene la estructura <code>dæmon : dirección : acción</code>, donde <code>dæmon</code> es el nombre de dæmon que inicia <code>inetd</code>. La <code>dirección</code> puede ser un nombre de equipo válido, una dirección IP o IPv6 encerrada en corchetes ([ ]). El campo acción puede ser permitir o denegar para el dar el acceso apropiado. Tenga presente que la configuración funciona en base a la primera regla cuya semántica concuerde; esto significa que el fichero de configuración se lee en orden ascendente hasta que concuerde una regla. Cuando se encuentra una concordancia se aplica la regla y el proceso se detendrá.</p></div><div class=paragraph><p>Existen muchas otras opciones pero estas se explican en una sección posterior. Una línea de configuración simple puede generarse mediante datos así de simples. Por ejemplo, para permitir conexiones POP3 mediante el dæmon <a class=package href=https://cgit.freebsd.org/ports/tree/mail/qpopper/>mail/qpopper</a>, añada las siguientes líneas a <span class=filename>hosts.allow</span>:</p></div><div class="literalblock programlisting"><div class=content><pre># This line is required for POP3 connections:
qpopper : ALL : allow</pre></div></div><div class=paragraph><p>Despues de añadir esta línea tendrá que reiniciar <code>inetd</code>. Use <a href="https://man.freebsd.org/cgi/man.cgi?query=kill&amp;sektion=1&amp;format=html">kill(1)</a> o use el parámetro <span class=parameter>restart</span> de <span class=filename>/etc/rc.d/inetd</span>.</p></div></div><div class=sect3><h4 id=_configuración_avanzada_2>14.6.2. Configuración avanzada<a class=anchor href=#_configuración_avanzada_2></a></h4><div class=paragraph><p>Las opciones avanzadas de TCP Wrappers le permiten un mayor control sobre la gestión de conexiones. En algunos casos puede convenir el enío de un comentario a ciertos equipos o conexiones de dæmons. En otros casos, quizás se deba registrar una entrada en un log o enviar un correo al administrador. Otro tipo de situaciones pueden requerir el uso de un servicio solamente para conexiones locales. Todo esto es posible gracias al uso de unas opciones de configuración conocidas como <code>comodines</code>, caracteres de expansión y ejecución de órdenes externas. Las siguientes dos secciones intentarán cubrir estas situaciones.</p></div><div class=sect4><h5 id=_órdenes_externas>14.6.2.1. Órdenes externas<a class=anchor href=#_órdenes_externas></a></h5><div class=paragraph><p>Imaginemos una situación en la que una conexión debe ser denegada pero se debe mandar un motivo a quien intentó establecer esa conexión. ?Cómo? Mediante la opción <code>twist</code>. Ante un intento de conexión se invoca a <code>twist</code>, que ejecuta una orden de shell o un "script". Tiene un ejemplo en el fichero <span class=filename>hosts.allow</span>:</p></div><div class="literalblock programlisting"><div class=content><pre># The rest of the daemons are protected.
ALL : ALL \
        : severity auth.info \
        : twist /bin/echo &#34;No se permite utilizar %d desde %h.&#34;</pre></div></div><div class=paragraph><p>Este ejemplo muestra que el mensaje, "No se permite utilizar <code>dæmon</code> desde <code>nombre de equipo</code>." se enviará en el caso de cualquier dæmon no configurado previamente en el fichero de acceso. Esto es extremadamente útil para enviar una respuesta al creador de la conexión justo después de que la conexión establecida es rechazada. Observe que cualquier mensaje que se desee enviar <em>debe ir</em> entre comillas <code>"</code>; esta regla no tiene excepciones.</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Es posible lanzar un ataque de denegación de servicio al servidor si un atacante o grupo de atacantes pueden llegar a sobrecargar estos dæmons con peticiones de conexión.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Otra posibilidad en estos casos es usar la opción <code>spawn</code>. Igual que <code>twist</code>, <code>spawn</code> niega implícitamente la conexión, y puede usarse para ejecutar órdenes de shell externos o "scripts". A diferencia de <code>twist</code>, <code>spawn</code> no enviará una respuesta al origen de la conexión. Veamos un ejemplo; observe la siguiente línea de configuración:</p></div><div class="literalblock programlisting"><div class=content><pre># No permitimos conexiones desde ejemplo.com:
ALL : .ejemplo.com \
	: spawn (/bin/echo %a desde %h intento acceder a %d &gt;&gt; \
	  /var/log/connections.log) \
	: deny</pre></div></div><div class=paragraph><p>Esto denegará todos los intentos de conexión desde el dominio <code>*.ejemplo.com</code>; simultáneamente creará una entrada con el nombre del equipo, dirección IP y el dæmon al que intentó conectarse al fichero <span class=filename>/var/log/connections.log</span>.</p></div><div class=paragraph><p>Además de la sustitución de caracteres ya expuesta más arriba (por ejemplo %a) existen unas cuantas más. Si quiere ver la lista completa consulte la página de manual <a href="https://man.freebsd.org/cgi/man.cgi?query=hosts_access&amp;sektion=5&amp;format=html">hosts_access(5)</a>.</p></div></div><div class=sect4><h5 id=_opciones_comodín>14.6.2.2. Opciones comodín<a class=anchor href=#_opciones_comodín></a></h5><div class=paragraph><p>Hasta ahora se ha usado <code>ALL</code> en todos los ejemplos, pero hay otras opciones interesantes para extender un poco más la funcionalidad. Por ejemplo, <code>ALL</code> puede usarse para concordar con cualquier instancia ya sea un dæmon, dominio o dirección IP. Otro comodín es <code>PARANOID</code>, que puede utilizarse para concordar con cualquier equipo que presente una dirección IP que pueda estar falsificada. En otras palabras, <code>paranoid</code> puede usarse para definir una acción a tomar siempre que tenga lugar una conexión desde una dirección IP que difiera de su nombre de equipo. Quizás todo se vea más claro con el siguiente ejemplo:</p></div><div class="literalblock programlisting"><div class=content><pre># Bloquear peticiones posiblemente falsificadas a sendmail:
sendmail : PARANOID : deny</pre></div></div><div class=paragraph><p>En ese ejemplo todas las peticiones de conexión a <code>sendmail</code> que tengan una dirección IP que varíe de su nombre de equipo serán denegadas.</p></div><div class="admonitionblock caution"><table><tbody><tr><td class=icon><i class="fa icon-caution" title=Caution></i></td><td class=content><div class=paragraph><p>Utilizando <code>PARANOID</code> puede bloquear el acceso a servidores si el cliente o el servidor tiene una configuración de DNS incorrecta. Recomendamos al administrador la máxima cautela en su uso.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=hosts_access&amp;sektion=5&amp;format=html">hosts_access(5)</a> si quiere saber más sobre los comodines y sus posibilidades de uso.</p></div><div class=paragraph><p>Si quiere que cualquiera de los ejemplos citados funcione debe comentar la primera línea de <span class=filename>hosts.allow</span> (tal y como se dijo al principio de la sección.</p></div></div></div></div><div class=sect2><h3 id=kerberosIV>14.7. KerberosIV<a class=anchor href=#kerberosIV></a></h3><div class=paragraph><p>Kerberos es un sistema/protocolo de red agregado que permite a los usuarios identificarse a través de los servicios de un servidor seguro. Los servicios como login remoto, copia remota, copias de ficheros de un sistema a otro y otras tantas tareas arriesgadas pasan a ser considerablemente seguras y más controlables.</p></div><div class=paragraph><p>Las siguientes instrucciones pueden usarse como una guía para configurar Kerberos tal y como se distribuye con FreeBSD. De todas maneras, debe consultar diversas páginas de manual para conocer todos los detalles.</p></div><div class=sect3><h4 id=_instalación_de_kerberosiv>14.7.1. Instalación de KerberosIV<a class=anchor href=#_instalación_de_kerberosiv></a></h4><div class=paragraph><p>Kerberos es un componente opcional de FreeBSD. La manera más fácil de instalar este software es seleccionando la distribución <code>krb4</code> o <code>krb5</code> en sysinstall durante la instalación inicial de FreeBSD. Desde ahí instalará la implementación de Kerberos "eBones" (KerberosIV) o "Heimdal" (Kerberos5). Estas implementaciones se incluyen porque a que han sido desarrolladas fuera de EEUU y Canadá, lo que las convertía en accesibles para administradores de sistemas del resto del mundo durante la época restrictiva de control control de exportaciones de código criptográfico desde EEUU.</p></div><div class=paragraph><p>También puede instalar la implementación de Kerberos del MIT desde la colección de ports (<a class=package href=https://cgit.freebsd.org/ports/tree/security/krb5/>security/krb5</a>).</p></div></div><div class=sect3><h4 id=_creación_de_la_base_de_datos_inicial>14.7.2. Creación de la base de datos inicial<a class=anchor href=#_creación_de_la_base_de_datos_inicial></a></h4><div class=paragraph><p>Esto solo debe hacerse en el servidor Kerberos. Lo primero es asegurarse de que no tiene bases de datos de Kerberos anteriores. Entre al directorio <span class=filename>/etc/kerberosIV</span> y asegúrese de que solo estén los siguientes ficheros:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /etc/kerberosIV</span>
<span class=c># ls</span>
README		krb.conf        krb.realms</code></pre></div></div><div class=paragraph><p>Si existe cualquier otro fichero (como <span class=filename>principal.*</span> o <span class=filename>master_key</span>) utilice <code>kdb_destroy</code> para destruir la base de datos antigua de Kerberos. Si Kerberos no está funcionando simplemente borre los ficheros sobrantes.</p></div><div class=paragraph><p>Edite <span class=filename>krb.conf</span> y <span class=filename>krb.realms</span> para definir su dominio Kerberos. En nuestro ejemplo el dominio será <code>EJEMPLO.COM</code> y el servidor es <code>grunt.ejemplo.com</code>. Editamos o creamos <span class=filename>krb.conf</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cat krb.conf</span>
EJEMPLO.COM
EJEMPLO.COM grunt.ejemplo.com admin server
CS.BERKELEY.EDU okeeffe.berkeley.edu
ATHENA.MIT.EDU kerberos.mit.edu
ATHENA.MIT.EDU kerberos-1.mit.edu
ATHENA.MIT.EDU kerberos-2.mit.edu
ATHENA.MIT.EDU kerberos-3.mit.edu
LCS.MIT.EDU kerberos.lcs.mit.edu
TELECOM.MIT.EDU bitsy.mit.edu
ARC.NASA.GOV trident.arc.nasa.gov</code></pre></div></div><div class=paragraph><p>Los demás dominios no deben estar forzosamente en la configuración. Los hemos incluido como ejemplo de cómo puede hacerse que una máquina trabaje con múltiples dominios. Si quiere mantener todo simple puede abstenerse de incluirlos.</p></div><div class=paragraph><p>La primera línea es el dominio en el que el sistema funcionará. Las demás líneas contienen entradas dominio/equipo. El primer componente de cada línea es un dominio y el segundo es un equipo de ese dominio, que actúa como "centro de distribución de llaves". Las palabras <code>admin server</code> que siguen al nombre de equipo significan que ese equipo también ofrece un servidor de base da datos administrativo. Si quiere consultar una explicación más completa de estos términos consulte las páginas de manual de de Kerberos.</p></div><div class=paragraph><p>Ahora añadiremos <code>grunt.ejemplo.com</code> al dominio <code>EJEMPLO.COM</code> y también una entrada para poner todos los equipos en el dominio <code>.ejemplo.com</code> Kerberos <code>EJEMPLO.COM</code>. Puede actualizar su <span class=filename>krb.realms</span> del siguiente modo:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cat krb.realms</span>
grunt.ejemplo.com EJEMPLO.COM
.ejemplo.com EJEMPLO.COM
.berkeley.edu CS.BERKELEY.EDU
.MIT.EDU ATHENA.MIT.EDU
.mit.edu ATHENA.MIT.EDU</code></pre></div></div><div class=paragraph><p>Igual que en caso previo, no tiene por qué incluir los demás dominios. Se han incluido para mostrar cómo puede usar una máquina en múltiples dominios. Puede eliminarlos y simplificar la configuración.</p></div><div class=paragraph><p>La primera línea pone al sistema <em>específico</em> en el dominio nombrado. El resto de las líneas muestran cómo asignar por defecto sistemas de un subdominio a un dominio Kerberos.</p></div><div class=paragraph><p>Ya podemos crear la base de datos. Solo se ejecuta en el servidor Kerberos (o centro de distribución de llaves). Ejecute <code>kdb_init</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kdb_init</span>
Realm name <span class=o>[</span>default  ATHENA.MIT.EDU <span class=o>]</span>: EJEMPLO.COM
You will be prompted <span class=k>for </span>the database Master Password.
It is important that you NOT FORGET this password.

Enter Kerberos master key:</code></pre></div></div><div class=paragraph><p>Ahora tendremos que guardar la llave para que los servidores en la máquina local puedan recogerla. Utilice <code>kstash</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kstash</span>

Enter Kerberos master key:

Current Kerberos master key version is 1.

Master key entered. BEWARE!</code></pre></div></div><div class=paragraph><p>Esto guarda la contraseña cifrada maestra en <span class=filename>/etc/kerberosIV/master_key</span>.</p></div></div><div class=sect3><h4 id=_puesta_en_marcha_del_sistema>14.7.3. Puesta en marcha del sistema<a class=anchor href=#_puesta_en_marcha_del_sistema></a></h4><div class=paragraph><p>Tendrá que añadir a la base de datos dos entradas en concreto para <em>cada</em> sistema que vaya a usar Kerberos: <code>kpasswd</code> y <code>rcmd</code>. Se hacen para cada sistema individualmente cada sistema, y el campo "instance" es el nombre individual del sistema.</p></div><div class=paragraph><p>Estos dæmons kpasswd y rcmd permiten a otros sistemas cambiar contraseñas de Kerberos y ejecutar órdenes como <a href="https://man.freebsd.org/cgi/man.cgi?query=rcp&amp;sektion=1&amp;format=html">rcp(1)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=rlogin&amp;sektion=1&amp;format=html">rlogin(1)</a> y <a href="https://man.freebsd.org/cgi/man.cgi?query=rsh&amp;sektion=1&amp;format=html">rsh(1)</a>.</p></div><div class=paragraph><p>Ahora vamos a añadir estas entradas:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kdb_edit</span>
Opening database...

Enter Kerberos master key:

Current Kerberos master key version is 1.

Master key entered.  BEWARE!
Previous or default values are <span class=k>in</span> <span class=o>[</span>brackets] ,
enter <span class=k>return </span>to leave the same, or new value.

Principal name: passwd
Instance: grunt

&lt;Not found&gt;, Create <span class=o>[</span>y] ? y

Principal: passwd, Instance: grunt, kdc_key_ver: 1
New Password:                    &lt;<span class=nt>----</span> tecleo aleatorio
Verifying password

New Password: &lt;<span class=nt>----</span> tecleo aleatorio

Random password <span class=o>[</span>y] ? y

Principal<span class=s1>&#39;s new key version = 1
Expiration date (enter yyyy-mm-dd) [ 2000-01-01 ] ?
Max ticket lifetime (*5 minutes) [ 255 ] ?
Attributes [ 0 ] ?
Edit O.K.
Principal name: rcmd
Instance: grunt

&lt;Not found&gt;, Create [y] ?

Principal: rcmd, Instance: grunt, kdc_key_ver: 1
New Password:		&lt;---- tecleo aleatorio
Verifying password

New Password:           &lt;---- tecleo aleatorio

Random password [y] ?

Principal&#39;</span>s new key version <span class=o>=</span> 1
Expiration <span class=nb>date</span> <span class=o>(</span>enter yyyy-mm-dd<span class=o>)</span> <span class=o>[</span> 2000-01-01 <span class=o>]</span> ?
Max ticket lifetime <span class=o>(</span><span class=k>*</span>5 minutes<span class=o>)</span> <span class=o>[</span> 255 <span class=o>]</span> ?
Attributes <span class=o>[</span> 0 <span class=o>]</span> ?
Edit O.K.
Principal name:         &lt;<span class=nt>----</span> si introduce datos nulos saldrá del programa</code></pre></div></div></div><div class=sect3><h4 id=_creación_del_fichero_del_servidor>14.7.4. Creación del fichero del servidor<a class=anchor href=#_creación_del_fichero_del_servidor></a></h4><div class=paragraph><p>Ahora tendremos que extraer todas las instancias que definen los servicios en cada máquina; para ello usaremos <code>ext_srvtab</code>. Esto creará un fichero que debe ser copiado o movido <em>por medios seguros</em> al directorio <span class=filename>/etc/kerberosIV</span> de cada cliente Kerberos. Este fichero debe existir en todos los servidores y clientes dada su importancia clave para el funcionamiento de Kerberos.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ext_srvtab grunt</span>
Enter Kerberos master key:

Current Kerberos master key version is 1.

Master key entered. BEWARE!
Generating <span class=s1>&#39;grunt-new-srvtab&#39;</span>....</code></pre></div></div><div class=paragraph><p>Esta orden solo genera un fichero temporal al que tendrá que cambiar el nombre a <span class=filename>srvtab</span> para que todos los servidores puedan recogerlo. Utilice <a href="https://man.freebsd.org/cgi/man.cgi?query=mv&amp;sektion=1&amp;format=html">mv(1)</a> para moverlo al lugar correcto en el sistema original:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mv grunt-new-srvtab srvtab</span></code></pre></div></div><div class=paragraph><p>Si el fichero es para un sistema cliente y la red no puede considerarse segura copie el <span class=filename>cliente-new-srvtab</span> en un medio extraíble y transpórtelo por medios físicos seguros. Asegúrese de cambiar su nombre a <span class=filename>srvtab</span> en el directorio <span class=filename>/etc/kerberosIV</span> del cliente, y asegúrese también de que tiene modo 600:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mv grumble-new-srvtab srvtab</span>
<span class=c># chmod 600 srvtab</span></code></pre></div></div></div><div class=sect3><h4 id=_añadir_entradas_a_la_base_de_datos>14.7.5. Añadir entradas a la base de datos<a class=anchor href=#_añadir_entradas_a_la_base_de_datos></a></h4><div class=paragraph><p>Ahora tenemos que añadir entradas de usuarios a la base de datos. Primero vamos a crear una entrada para el usuario <code>jane</code>. Para ello usaremos <code>kdb_edit</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kdb_edit</span>
Opening database...

Enter Kerberos master key:

Current Kerberos master key version is 1.

Master key entered.  BEWARE!
Previous or default values are <span class=k>in</span> <span class=o>[</span>brackets] ,
enter <span class=k>return </span>to leave the same, or new value.

Principal name: jane
Instance:

&lt;Not found&gt;, Create <span class=o>[</span>y] ? y

Principal: jane, Instance: , kdc_key_ver: 1
New Password:                &lt;<span class=nt>----</span> introduzca una constraseña segura
Verifying password

New Password:                &lt;<span class=nt>----</span> introduzca de nuevo la contraseña
Principal<span class=s1>&#39;s new key version = 1
Expiration date (enter yyyy-mm-dd) [ 2000-01-01 ] ?
Max ticket lifetime (*5 minutes) [ 255 ] ?
Attributes [ 0 ] ?
Edit O.K.
Principal name:		   &lt;---- si introduce datos nulos saldrá del programa</span></code></pre></div></div></div><div class=sect3><h4 id=_prueba_del_sistema>14.7.6. Prueba del sistema<a class=anchor href=#_prueba_del_sistema></a></h4><div class=paragraph><p>Primero tenemos que iniciar los dæmons de Kerberos. Tenga en cuenta que si su <span class=filename>/etc/rc.conf</span> está configurado correctamente el inicio tendrá ligar cuando reinicie el sistema. Esta prueba solo es necesaria en el servidor Kerberos; los clientes Kerberos tomarán lo que necesiten automáticamente desde el directorio <span class=filename>/etc/kerberosIV</span>.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kerberos &amp;</span>
Kerberos server starting
Sleep forever on error
Log file is /var/log/kerberos.log
Current Kerberos master key version is 1.

Master key entered. BEWARE!

Current Kerberos master key version is 1
Local realm: EJEMPLO.COM
<span class=c># kadmind -n &amp;</span>
KADM Server KADM0.0A initializing
Please <span class=k>do </span>not use <span class=s1>&#39;kill -9&#39;</span> to <span class=nb>kill </span>this job, use a
regular <span class=nb>kill </span>instead

Current Kerberos master key version is 1.

Master key entered.  BEWARE!</code></pre></div></div><div class=paragraph><p>Ahora podemos probar a usar <code>kinit</code> para obtener un ticket para el ID <code>jane</code> que creamos antes:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% kinit jane
MIT Project Athena <span class=o>(</span>grunt.ejemplo.com<span class=o>)</span>
Kerberos Initialization <span class=k>for</span> <span class=s2>&#34;jane&#34;</span>
Password:</code></pre></div></div><div class=paragraph><p>Pruebe a listar los tokens con <code>klist</code> para ver si realmente están:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% klist
Ticket file:    /tmp/tkt245
Principal:      jane@EJEMPLO.COM

  Issued           Expires          Principal
Apr 30 11:23:22  Apr 30 19:23:22  krbtgt.EJEMPLO.COM@EJEMPLO.COM</code></pre></div></div><div class=paragraph><p>Ahora trate de cambiar la contraseña usando <a href="https://man.freebsd.org/cgi/man.cgi?query=passwd&amp;sektion=1&amp;format=html">passwd(1)</a> para comprobar si el dæmon kpasswd está autorizado a acceder a la base de datos Kerberos:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% passwd
realm EJEMPLO.COM
Old password <span class=k>for </span>jane:
New Password <span class=k>for </span>jane:
Verifying password
New Password <span class=k>for </span>jane:
Password changed.</code></pre></div></div></div><div class=sect3><h4 id=_añadir_privilegios_de_su>14.7.7. Añadir privilegios de <code>su</code><a class=anchor href=#_añadir_privilegios_de_su></a></h4><div class=paragraph><p>Kerberos nos permite dar a <em>cada</em> usuario que necesite privilegios de <code>root</code> su <em>propia</em> contraseña para <a href="https://man.freebsd.org/cgi/man.cgi?query=su&amp;sektion=1&amp;format=html">su(1)</a>. Podemos agregar un ID que esté autorizado a ejecutar <a href="https://man.freebsd.org/cgi/man.cgi?query=su&amp;sektion=1&amp;format=html">su(1)</a> <code>root</code>. Esto se controla con una instancia de <code>root</code> asociada con un usuario. Vamos a crear una entrada <code>jane.root</code> en la base de datos, para lo que recurrimos a <code>kdb_edit</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kdb_edit</span>
Opening database...

Enter Kerberos master key:

Current Kerberos master key version is 1.

Master key entered.  BEWARE!
Previous or default values are <span class=k>in</span> <span class=o>[</span>brackets] ,
enter <span class=k>return </span>to leave the same, or new value.

Principal name: jane
Instance: root

&lt;Not found&gt;, Create <span class=o>[</span>y] ? y

Principal: jane, Instance: root, kdc_key_ver: 1
New Password:                    &lt;<span class=nt>----</span> introduzca una contraseña SEGURA
Verifying password

New Password:    	 	 &lt;<span class=nt>----</span> introduzca otra vez la constraseña

Principal<span class=s1>&#39;s new key version = 1
Expiration date (enter yyyy-mm-dd) [ 2000-01-01 ] ?
Max ticket lifetime (*5 minutes) [ 255 ] ? 12 &lt;--- Keep this short!
Attributes [ 0 ] ?
Edit O.K.
Principal name:		         &lt;---- si introduce datos nulos saldrá del programa</span></code></pre></div></div><div class=paragraph><p>Ahora trate de obtener los tokens para comprobar que todo funciona:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kinit jane.root</span>
MIT Project Athena <span class=o>(</span>grunt.ejemplo.com<span class=o>)</span>
Kerberos Initialization <span class=k>for</span> <span class=s2>&#34;jane.root&#34;</span>
Password:</code></pre></div></div><div class=paragraph><p>Hemos de agregar al usuario al <span class=filename>.klogin</span> de <code>root</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cat /root/.klogin</span>
jane.root@EJEMPLO.COM</code></pre></div></div><div class=paragraph><p>Ahora trate de hacer <a href="https://man.freebsd.org/cgi/man.cgi?query=su&amp;sektion=1&amp;format=html">su(1)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% su
Password:</code></pre></div></div><div class=paragraph><p>y eche un vistazo a qué tokens tenemos:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># klist</span>
Ticket file:	/tmp/tkt_root_245
Principal:      jane.root@EJEMPLO.COM

  Issued           Expires          Principal
May  2 20:43:12  May  3 04:43:12  krbtgt.EJEMPLO.COM@EJEMPLO.COM</code></pre></div></div></div><div class=sect3><h4 id=_uso_de_otras_órdenes>14.7.8. Uso de otras órdenes<a class=anchor href=#_uso_de_otras_órdenes></a></h4><div class=paragraph><p>En un ejemplo anterior creamos un usuario llamado <code>jane</code> con una instancia <code>root</code>. Nos basamos en un usuario con el mismo nombre del "principal" (<code>jane</code>), el procedimiento por defecto en Kerberos: <code>&lt;principal>.&lt;instancia></code> con la estructura <code>&lt;nombre de usuario>. root</code> permitirá que <code>&lt;nombre de usuario></code> haga <a href="https://man.freebsd.org/cgi/man.cgi?query=su&amp;sektion=1&amp;format=html">su(1)</a> a <code>root</code> si existen las entradas necesarias en el <span class=filename>.klogin</span> que hay en el directorio home de <code>root</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cat /root/.klogin</span>
jane.root@EJEMPLO.COM</code></pre></div></div><div class=paragraph><p>De la misma manera, si un usuario tiene en su directorio home lo siguiente:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>cat</span> ~/.klogin
jane@EJEMPLO.COM
jack@EJEMPLO.COM</code></pre></div></div><div class=paragraph><p>significa que cualquier usuario del dominio <code>EJEMPLO.COM</code> que se identifique como <code>jane</code> o como <code>jack</code> (vía <code>kinit</code>, ver más arriba) podrá acceder a la cuenta de <code>jane</code> o a los ficheros de este sistema (<code>grunt</code>) vía <a href="https://man.freebsd.org/cgi/man.cgi?query=rlogin&amp;sektion=1&amp;format=html">rlogin(1)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=rsh&amp;sektion=1&amp;format=html">rsh(1)</a> o <a href="https://man.freebsd.org/cgi/man.cgi?query=rcp&amp;sektion=1&amp;format=html">rcp(1)</a>.</p></div><div class=paragraph><p>Veamos por ejemplo cómo <code>jane</code> se se identifica en otro sistema mediante Kerberos:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% kinit
MIT Project Athena <span class=o>(</span>grunt.ejemplo.com<span class=o>)</span>
Password:
% rlogin grunt
Last login: Mon May  1 21:14:47 from grumble
Copyright <span class=o>(</span>c<span class=o>)</span> 1980, 1983, 1986, 1988, 1990, 1991, 1993, 1994
        The Regents of the University of California.   All rights reserved.

FreeBSD BUILT-19950429 <span class=o>(</span>GR386<span class=o>)</span> <span class=c>#0: Sat Apr 29 17:50:09 SAT 1995</span></code></pre></div></div><div class=paragraph><p>Aquí <code>jack</code> se identifica con la cuenta de <code>jane</code> en la misma máquina (<code>jane</code> tiene configurado su fichero <span class=filename>.klogin</span> como se ha mostrado antes, y la persona encargada de la administración de Kerberos ha configurado un usuario principal <em>jack</em> con una instancia nula):</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% kinit
% rlogin grunt <span class=nt>-l</span> jane
MIT Project Athena <span class=o>(</span>grunt.ejemplo.com<span class=o>)</span>
Password:
Last login: Mon May  1 21:16:55 from grumble
Copyright <span class=o>(</span>c<span class=o>)</span> 1980, 1983, 1986, 1988, 1990, 1991, 1993, 1994
        The Regents of the University of California.   All rights reserved.
FreeBSD BUILT-19950429 <span class=o>(</span>GR386<span class=o>)</span> <span class=c>#0: Sat Apr 29 17:50:09 SAT 1995</span></code></pre></div></div></div></div><div class=sect2><h3 id=kerberos5>14.8. Kerberos5<a class=anchor href=#kerberos5></a></h3><div class=paragraph><p>Cada versión de FreeBSD posterior a FreeBSD-5.1 incluye soporte solamente para Kerberos5. Por esta razón Kerberos5 es la única versión incluida. Su configuración es similar en muchos aspectos a la de KerberosIV. La siguiente información solo atañe a Kerberos5 en versiones de FreeBSD-5.0 o posteriores. Los usuarios que deséen utilizar KerberosIV pueden instalar el port <a class=package href=https://cgit.freebsd.org/ports/tree/security/krb4/>security/krb4</a>.</p></div><div class=paragraph><p>Kerberos es un sistema/protocolo agregado para red que permite a los usuarios validar su identidad a través de los servicios de un servidor seguro. Los servicios como login remoto, copia remota, copias de fichero de un sistema a otro y otras tareas generalmente consideradas poco seguras pasan a ser considerablemente seguras y más controlables.</p></div><div class=paragraph><p>Kerberos puede describirse como un sistema proxy identificador/verificador. También puede describirse como un sistema confiable de autentificación de terceros. Kerberos solamente ofrece una función: la validación segura de usuarios a través de una red. No proporciona funciones de autorización (es decir, lo que los usuarios tienen permitido hacer) o funciones de auditoría (lo que esos usuarios hicieron). Después de que un servidor y un cliente han usado Kerberos para demostrar su identidad pueden también cifrar todas sus sus comunicaciones, asegurando de este modo su intimidad y la integridad de sus datos durante su uso del sistema.</p></div><div class=paragraph><p>Es, por tanto, altamente recomendable que se use Kerberos <em>además</em> de otros métodos de seguridad que ofrezcan servicios de autorización y auditoría.</p></div><div class=paragraph><p>Puede usar las siguientes instrucciones como una guía para configurar Kerberos tal y como se distribuye en FreeBSD. De todas maneras, debería consultar las páginas de manual adecuadas para tener toda la información.</p></div><div class=paragraph><p>Vamos a mostrar una instalación Kerberos, para lo cual usaremos los siguientes espacios de nombres:</p></div><div class=ulist><ul><li><p>El dominio DNS ("zona") será ejemplo.org.</p></li><li><p>El dominio Kerberos (realm) será EJEMPLO.ORG.</p></li></ul></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Debe utilizar nombres de dominio reales al configurar Kerberos incluso si pretende ejecutarlo internamente. Esto le evitará problemas de DNS y asegura la interoperación con otros dominios Kerberos.</p></div></td></tr></tbody></table></div><div class=sect3><h4 id=_historia>14.8.1. Historia<a class=anchor href=#_historia></a></h4><div class=paragraph><p>Kerberos fué creado en el Massachusetts Institute of Technology (MIT) como una solución a los problemas de seguridad de la red. El protocolo Kerberos utiliza criptografía fuerte para que un cliente pueda demostrar su identidad en un servidor (y viceversa) a través de una conexión de red insegura.</p></div><div class=paragraph><p>Kerberos es el nombre de un protocolo de autentificación vía red y un adjetivo para describir programas que implementan el programa (Kerberos telnet, por ejemplo, conocido también como el "telnet kerberizado"). La versión actual del protocolo es la 5, descrita en RFC 1510.</p></div><div class=paragraph><p>Existen diversas implementaciones libres de este protocolo, cubriendo un amplio rango de sistemas operativos. El MIT, donde Kerberos fué desarrollado, continúa desarrollando su propio paquete Kerberos. Suele usarse en los EEUU como producto criptográfico y como tal ha sufrido las regulaciones de exportación de los EEUU. El Kerberos del MIT existe como un port en (<a class=package href=https://cgit.freebsd.org/ports/tree/security/krb5/>security/krb5</a>). Heimdal Kerberos es otra implementación de la versión 5, y fué desarrollada de forma intencionada fuera de los EEUU para sortear las regulaciones de exportación (y por eso puede incluirse en versiones no comerciales de UNIX®). La distribución Heimdal Kerberos está en el port (<a class=package href=https://cgit.freebsd.org/ports/tree/security/heimdal/>security/heimdal</a>), y se incluye una instalación mínima en el sistema base de FreeBSD.</p></div><div class=paragraph><p>Para alcanzar la mayor audiencia estas instrucciones asumen el uso de la distribución Heimdal incluída en FreeBSD.</p></div></div><div class=sect3><h4 id=_configuración_de_un_kdc_heimdal>14.8.2. Configuración de un KDC Heimdal<a class=anchor href=#_configuración_de_un_kdc_heimdal></a></h4><div class=paragraph><p>El centro de distribución de llaves (KDC, Key Distribution Center) es el servicio centralizado de validación que proporciona Kerberos: es el sistema que emite tickets Kerberos. El KDC goza del estátus de ser considerado como "confiable" por las demás computadoras del dominio Kerberos, y por eso tiene consideraciones de seguridad más elevadas.</p></div><div class=paragraph><p>Tenga en cuenta que, aunque la ejecución del servidor Kerberos requiere muy pocos recursos, se recomienda el uso de una máquina dedicada a KDC por razones de seguridad.</p></div><div class=paragraph><p>Para empezar a configurar un KDC asegúrese de que su <span class=filename>/etc/rc.conf</span> contenga la configuración adecuada para actuar como KDC (tal vez deba ajustar algunas rutas para que cuadren con su sistema):</p></div><div class="literalblock programlisting"><div class=content><pre>kerberos5_server_enable=&#34;YES&#34;
kadmind5_server_enable=&#34;YES&#34;
kerberos_stash=&#34;YES&#34;</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p><code>kerberos_stash</code> solo existe en FreeBSD 4.X.</p></div></td></tr></tbody></table></div><div class=paragraph><p>A continuación configuraremos el fichero de configuración de Kerberos, <span class=filename>/etc/krb5.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>[libdefaults]
    default_realm = EJEMPLO.ORG [realms]
    EXAMPLE.ORG = {
        kdc = kerberos.ejemplo.org
        admin_server = kerberos.ejemplo.org
    }
[domain_realm]
    .ejemplo.org = EJEMPLO.ORG</pre></div></div><div class=paragraph><p>Tenga en cuenta que este <span class=filename>/etc/krb5.conf</span> implica que su KDC tendrá el nombre de equipo completo calificado de <code>kerberos.ejemplo.org</code>. Necesitará añadir una entrada CNAME (alias) a su fichero de zona si su KDC tiene un nombre de equipo diferente.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>En grandes redes con un servidor DNSBIND bien configurado, el ejemplo de arriba puede quedar del siguiente modo:</p></div><div class="literalblock programlisting"><div class=content><pre>[libdefaults]
      default_realm = EJEMPLO.ORG</pre></div></div><div class=paragraph><p>Con las siguientes líneas agregadas al fichero de zona <code>ejemplo.org</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>_kerberos._udp      IN  SRV     01 00 88 kerberos.ejemplo.org.
_kerberos._tcp      IN  SRV     01 00 88 kerberos.ejemplo.org.
_kpasswd._udp       IN  SRV     01 00 464 kerberos.ejemplo.org.
_kerberos-adm._tcp  IN  SRV     01 00 749 kerberos.ejemplo.org.
_kerberos           IN  TXT     EJEMPLO.ORG</pre></div></div></td></tr></tbody></table></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Para que los clientes sean capaces de encontrar los servicios Kerberos <em>debe</em> tener ya sea un <span class=filename>/etc/krb5.conf</span> configurado o un <span class=filename>/etc/krb5.conf</span> configurado de forma mínima <em>y</em> un servidor DNS configurado correctamente.</p></div></td></tr></tbody></table></div><div class=paragraph><p>A continuación crearemos la base de datos Kerberos. Esta base de datos contiene las llaves de todos los principales cifradas con una contraseña maestra. No es necesario que recuerde esta contraseña, pues se almacenará en <span class=filename>/var/heimdal/m-key</span>. Para crear la llave maestra ejecute <code>kstash</code> e introduzca una contraseña.</p></div><div class=paragraph><p>Una vez que se ha creado la llave maestra puede inicializar la base de datos usando el programa <code>kadmin</code> con la opción <code>-l</code> (que significa "local"). Esta opción le dice a <code>kadmin</code> que modifique los ficheros de la base de datos directamente en lugar de ir a través del servicio de red <code>kadmind</code>. Esto gestiona el problema del huevo y la gallina de tratar de conectar a la base de datos antes de que ésta exista. Una vez que tiene el "prompt" de <code>kadmin</code>, utilice <code>init</code> para crear su base de datos de dominios iniciales.</p></div><div class=paragraph><p>Para terminar, mientras está todavía en <code>kadmin</code> puede crear su primer principal mediante <code>add</code>. Utilice las opciones por defecto por ahora, más tarde puede cambiarlas mediante <code>modify</code>. Recuerde que puede usar <code>?</code> en cualquier "prompt" para consultar las opciones disponibles.</p></div><div class=paragraph><p>Veamos un ejemplo de sesión de creación de una base de datos:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kstash</span>
Master key: xxxxxxxx
Verifying password - Master key: xxxxxxxx

<span class=c># kadmin -l</span>
kadmin&gt; init EJEMPLO.ORG
Realm max ticket life <span class=o>[</span>unlimited]:
kadmin&gt; add tillman
Max ticket life <span class=o>[</span>unlimited]:
Max renewable life <span class=o>[</span>unlimited]:
Attributes <span class=o>[]</span>:
Password: xxxxxxxx
Verifying password - Password: xxxxxxxx</code></pre></div></div><div class=paragraph><p>Ahora puede arrancar los servicios KDC. Ejecute <code>/etc/rc.d/kerberos start</code> y <code>/etc/rc.d/kadmind start</code> para levantar dichos servicios. Recuerde que no tendrá ningún dæmon kerberizado ejecutándose pero debe poder confirmar que KDC funciona por el procedimiento de obtener y listar un boleto del principal (usuario) que acaba de crear en la línea de órdenes de KDC:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% k5init tillman
tillman@EJEMPLO.ORG<span class=s1>&#39;s Password:

% k5list
Credentials cache: FILE:/tmp/krb5cc_500
	Principal: tillman@EJEMPLO.ORG

  Issued           Expires          Principal
Aug 27 15:37:58  Aug 28 01:37:58  krbtgt/EJEMPLO.ORG@EJEMPLO.ORG</span></code></pre></div></div></div><div class=sect3><h4 id=_creación_de_un_servidor_kerberos_con_servicios_heimdal>14.8.3. Creación de un servidor Kerberos con servicios Heimdal<a class=anchor href=#_creación_de_un_servidor_kerberos_con_servicios_heimdal></a></h4><div class=paragraph><p>Antes de nada necesitaremos una copia del fichero de configuración de Kerberos, <span class=filename>/etc/krb5.conf</span>. Cópielo al cliente desde KDC de forma segura (mediante <a href="https://man.freebsd.org/cgi/man.cgi?query=scp&amp;sektion=1&amp;format=html">scp(1)</a>, o usando un disquete).</p></div><div class=paragraph><p>A continuación necesitará un fichero <span class=filename>/etc/krb5.keytab</span>. Esta es la mayor diferencia entre un servidor que proporciona dæmons habilitados con Kerberos y una estación de trabajo: el servidor debe tener un fichero <span class=filename>keytab</span>. Dicho fichero contiene las llaves de equipo del servidor, las cuales le permiten a él y al KDC verificar la identidad entre ellos. Deben transmitirse al servidor de forma segura ya que la seguridad del servidor puede verse comprometida si la llave se hace pública. Por decirlo más claro, transferirla como texto plano a través de la red (por ejemplo por FTP) es una <em>pésima idea</em>.</p></div><div class=paragraph><p>Lo normal es que transmita su <span class=filename>keytab</span> al servidor mediante el programa <code>kadmin</code>. Esto es práctico porque también debe crear el principal del equipo (el KDC que aparece al final de <span class=filename>krb5.keytab</span>) usando <code>kadmin</code>.</p></div><div class=paragraph><p>Tenga en cuenta que ya debe disponer de un ticket, y que este ticket debe poder usar el interfaz <code>kadmin</code> en <span class=filename>kadmind.acl</span>. Consulte la sección "administración remota" en la página info de Heimdal (<code>info heimdal</code>), donde se exponen los detalles de diseño de las listas de control de acceso. Si no quiere habilitar acceso remoto <code>kadmin</code>, puede conectarse de forma segura al KDC (por medio de consola local, <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh&amp;sektion=1&amp;format=html">ssh(1)</a> o <a href="https://man.freebsd.org/cgi/man.cgi?query=telnet&amp;sektion=1&amp;format=html">telnet(1)</a> Kerberos) y administrar en local mediante <code>kadmin -l</code>.</p></div><div class=paragraph><p>Después de instalar el fichero <span class=filename>/etc/krb5.conf</span> puede usar <code>kadmin</code> desde el servidor Kerberos. <code>add --random-key</code> le permitirá añadir el principal del equipo servidor, y <code>ext</code> le permitirá extraer el principal del equipo servidor a su propio keybat. Por ejemplo:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kadmin</span>
kadmin&gt; add <span class=nt>--random-key</span> host/myserver.ejemplo.org
Max ticket life <span class=o>[</span>unlimited]:
Max renewable life <span class=o>[</span>unlimited]:
Attributes <span class=o>[]</span>:
kadmin&gt; ext host/miservidor.ejemplo.org
kadmin&gt; <span class=nb>exit</span></code></pre></div></div><div class=paragraph><p>Tenga en cuenta que <code>ext</code> (contracción de "extract") almacena la llave extraída por defecto en en <span class=filename>/etc/krb5.keytab</span>.</p></div><div class=paragraph><p>Si no tiene <code>kadmind</code> ejecutándose en KDC (posiblemente por razones de seguridad) y por lo tanto carece de acceso remoto a <code>kadmin</code> puede añadir el principal de equipo (<code>host/miservidor.EJEMPLO.ORG</code>) directamente en el KDC y entonces extraerlo a un fichero temporal (para evitar sobreescribir <span class=filename>/etc/krb5.keytab</span> en el KDC) mediante algo parecido a esto:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kadmin</span>
kadmin&gt; ext <span class=nt>--keytab</span><span class=o>=</span>/tmp/ejemplo.keytab host/miservidor.ejemplo.org
kadmin&gt; <span class=nb>exit</span></code></pre></div></div><div class=paragraph><p>Puede entonces copiar de forma segura el keytab al servidor (usando <code>scp</code> o un diquete). Asegúrese de usar un nombre de keytab diferente para evitar sobreescribir el keytab en el KDC.</p></div><div class=paragraph><p>Su servidor puede comunicarse con el KDC (gracias a su fichero <span class=filename>krb5.conf</span>) y puede probar su propia identidad (gracias al fichero <span class=filename>krb5.keytab</span>). Ahora está listo para que usted habilite algunos servicios Kerberos. En este ejemplo habilitaremos el servicio <code>telnet</code> poniendo una línea como esta en su <span class=filename>/etc/inetd.conf</span> y reiniciando el servicio <a href="https://man.freebsd.org/cgi/man.cgi?query=inetd&amp;sektion=8&amp;format=html">inetd(8)</a> con <code>/etc/rc.d/inetd restart</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>telnet    stream  tcp     nowait  root    /usr/libexec/telnetd  telnetd -a user</pre></div></div><div class=paragraph><p>La parte crítica es <code>-a</code>, de autentificación de usuario. Consulte la página de manual <a href="https://man.freebsd.org/cgi/man.cgi?query=telnetd&amp;sektion=8&amp;format=html">telnetd(8)</a> para más información.</p></div></div><div class=sect3><h4 id=_kerberos_con_un_cliente_heimdal>14.8.4. Kerberos con un cliente Heimdal<a class=anchor href=#_kerberos_con_un_cliente_heimdal></a></h4><div class=paragraph><p>Configurar una computadora cliente es extremadamente fácil. Lo único que necesita es el fichero de configuración de Kerberos que encontrará en <span class=filename>/etc/krb5.conf</span>. Simplemente cópielo de forma segura a la computadora cliente desde el KDC.</p></div><div class=paragraph><p>Pruebe su computadora cliente mediante <code>kinit</code>, <code>klist</code>, y <code>kdestroy</code> desde el cliente para obtener, mostrar y luego borrar un ticket para el principal que creó antes. Debería poder usar aplicaciones Kerberos para conectarse a servidores habilitados con Kerberos, aunque si no funciona y tiene problemas al intentar obtener el boleto lo más probable es que el problema esté en el servidor y no en el cliente o el KDC.</p></div><div class=paragraph><p>Al probar una aplicación como <code>telnet</code>, trate de usar un "sniffer" de paquetes ( como <a href="https://man.freebsd.org/cgi/man.cgi?query=tcpdump&amp;sektion=1&amp;format=html">tcpdump(1)</a>) para confirmar que su contraseña no viaja en claro por la red. Trate de usar <code>telnet</code> con la opción <code>-x</code>, que cifra el flujo de datos por entero (algo parecido a lo que hace <code>ssh</code>).</p></div><div class=paragraph><p>Las aplicaciones clientes Kerberos principales (llamadas tradicionalmente <code>kinit</code>, <code>klist</code>, <code>kdestroy</code> y <code>kpasswd</code>) están incluidas en la instalación base de FreeBSD. Tenga en cuenta que en las versiones de FreeBSD anteriores a 5.0 reciben los nombres de <code>k5init</code>, <code>k5list</code>, <code>k5destroy</code>, <code>k5passwd</code> y <code>k5stash</code>.</p></div><div class=paragraph><p>También se instalan por defecto diversas aplicaciones Kerberos que no entran dentro de la categoría de "imprescindibles". Es aquí donde la naturaleza "mínima" de la instalación base de Heimdal salta a la palestra: <code>telnet</code> es el único servicio Kerberos habilitado.</p></div><div class=paragraph><p>El port Heimdal añade algunas de las aplicaciones cliente que faltan: versiones Kerberos de <code>ftp</code>, <code>rsh</code>, <code>rcp</code>, <code>rlogin</code> y algunos otros programas menos comunes. El port del MIT también contiene una suite completa de aplicaciones cliente de Kerberos.</p></div></div><div class=sect3><h4 id=_ficheros_de_configuración_de_usuario_k5login_y_k5users>14.8.5. Ficheros de configuración de usuario: <span class=filename>.k5login</span> y <span class=filename>.k5users</span><a class=anchor href=#_ficheros_de_configuración_de_usuario_k5login_y_k5users></a></h4><div class=paragraph><p>Suele ser habitual que los usuarios de un dominio Kerberos (o "principales") tengan su usuario (por ejemplo <code>tillman@EJEMPLO.ORG</code>) mapeado a una cuenta de usuario local (por ejemplo un usuario llamado llamado <code>tillman</code>). Las aplicaciones cliente como <code>telnet</code> normalmente no requieren un nombre de usuario o un principal.</p></div><div class=paragraph><p>Es posible que de vez en cuando quiera dar acceso a una una cuenta de usuario local a alguien que no tiene un principal Kerberos. Por ejemplo, <code>tillman@EJEMPLO.ORG</code> puede necesitar acceso a la cuenta de usuario local <code>webdevelopers</code>. Otros principales tal vez necesiten acceso a esas cuentas locales.</p></div><div class=paragraph><p>Los ficheros <span class=filename>.k5login</span> y <span class=filename>.k5users</span>, ubicados en el directorio home del usuario, pueden usarse de un modo similar a una combinación potente de <span class=filename>.hosts</span> y <span class=filename>.rhosts</span>. Por ejemplo, si pusiera un fichero <span class=filename>.k5login</span> con el siguiente contenido</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>tillman@example.org
jdoe@example.org</code></pre></div></div><div class=paragraph><p>en el directorio home del usuario local <code>webdevelopers</code> ambos principales listados tendrían acceso a esa cuenta sin requerir una contraseña compartida.</p></div><div class=paragraph><p>Le recomendamos encarecidamente la lectura de las páginas de manual de estas órdenes. Recuerde que la página de manual de <code>ksu</code> abarca <span class=filename>.k5users</span>.</p></div></div><div class=sect3><h4 id=_kerberos_sugerencias_trucos_y_solución_de_problemas>14.8.6. Kerberos Sugerencias, trucos y solución de problemas<a class=anchor href=#_kerberos_sugerencias_trucos_y_solución_de_problemas></a></h4><div class=ulist><ul><li><p>Tanto si utiliza el port de Heimdal o el Kerberos del MIT asegúrese de que su variable de entorno <code>PATH</code> liste las versiones de Kerberos de las aplicaciones cliente antes que las versiones del sistema.</p></li><li><p>?Todas las computadoras de su dominio Kerberos tienen la hora sincronizada? Si no, la autentificación puede fallar. <a href=./#network-ntp>NTP</a> describe como sincronizar los relojes utilizando NTP.</p></li><li><p>MIT y Heimdal conviven bien, con la excepción de <code>kadmin</code>, protocolo no está estandarizado.</p></li><li><p>Si cambia su nombre de equipo debe cambiar también el "apellido" de su principal y actualizar su keytab. Esto también se aplica a entradas especiales en keytab como el principal <code>www/</code> que usa el <a class=package href=https://cgit.freebsd.org/ports/tree/www/mod_auth_kerb/>www/mod_auth_kerb</a> de Apache.</p></li><li><p>Todos los equipos en su dominio Kerberos deben poder resolverse (tanto en la forma normal normal como en la inversa) en el DNS (o en <span class=filename>/etc/hosts</span> como mínimo). Los CNAME funcionarán, pero los registros A y PTR deben ser correctos y estar en su sitio. El mensaje de error que recibirá de no hacerlo así no es muy intuitivo: <code>Kerberos5 refuses authentication because Read req failed: Key table entry not found</code>.</p></li><li><p>Algunos sistemas operativos que puede usar como clientes de su KDC no activan los permisos para <code>ksu</code> como setuid <code>root</code>. Esto hará que <code>ksu</code> no funcione, lo cual es muy seguro pero un tanto molesto. Tenga en cuenta que no se debe a un error de KDC.</p></li><li><p>Si desea permitir que un principal tenga un ticket con una validez más larga que el valor por defecto de diez horas en Kerberos del MIT debe usar <code>modify_principal</code> en <code>kadmin</code> para cambiar "maxlife" tanto del principal en cuestión como del <code>krbtgt</code> del principal. Hecho esto, el principal puede utilizar la opción <code>-l</code> con <code>kinit</code> para solicitar un boleto con más tiempo de vida.</p></li></ul></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Si ejecuta un "sniffer" de paquetes en su KDC para ayudar con la resolución de problemas y ejecuta <code>kinit</code> desde una estación de trabajo puede encontrarse con que su TGT se envía inmediatamente después de ejecutar <code>kinit</code>: <em>incluso antes de que escriba su contraseña</em> La explicación es que el servidor Kerberos transmite tranquilamente un TGT (Ticket Granting Ticket) a cualquier petición no autorizada; de todas maneras, cada TGT está cifrado en una llave derivada de la contraseña del usuario. Por tanto, cuando un usuario teclea su contraseña no la está enviando al KDC, se está usando para descifrar el TGT que <code>kinit</code> ya obtuvo. Si el proceso de descifrado termina en un ticket válido con una marca de tiempo válida, el usuario tiene credenciales Kerberos válidas. Estas credenciales incluyen una llave de sesión para establecer comunicaciones seguras con el servidor Kerberos en el futuro, así como el TGT en sí, que se cifra con la llave del propio servidor Kerberos. Esta segunda capa de cifrado es invisible para el usuario, pero es lo que permite al servidor Kerberos verificar la autenticidad de cada TGT.</p></div></td></tr></tbody></table></div><div class=ulist><ul><li><p>Si desea utilizar tickets con un tiempo largo de vida (una semana, por ejemplo) y está utilizando OpenSSH para conectarse a la máquina donde se almacena su boleto asgúrese de que Kerberos <code>TicketCleanup</code> esté configurado a <code>no</code> en su <span class=filename>sshd_config</span> o de lo contrario sus tickets serán eliminados cuando termine la sesión.</p></li><li><p>Recuerde que los principales de equipos también pueden tener tener un tiempo de vida más largo. Si su principal de usuario tiene un tiempo de vida de una semana pero el equipo al que se conecta tiene un tiempo de vida de nueve horas, tendrá un principal de equipo expirado en su caché, y la caché de ticket no funcionará como esperaba.</p></li><li><p>Cuando esté configurando un fichero <span class=filename>krb5.dict</span> pensando específicamente en prevenir el uso de contraseñas defectuosas (la página de manual de de <code>kadmind</code> trata el tema brevemente), recuerde que solamente se aplica a principales que tienen una política de contraseñas asignada. El formato de los ficheros <span class=filename>krb5.dict</span> es simple: una cadena de texto por línea. Puede serle útil crear un enlace simbólico a <span class=filename>/usr/shared/dict/words</span>.</p></li></ul></div></div><div class=sect3><h4 id=_diferencias_con_el_port_del_mit>14.8.7. Diferencias con el port del MIT<a class=anchor href=#_diferencias_con_el_port_del_mit></a></h4><div class=paragraph><p>Las diferencias más grandes entre las instalaciones MIT y Heimdal están relacionadas con <code>kadmin</code>, que tiene un conjunto diferente (pero equivalente) de órdenes y utiliza un protocolo diferente. Esto tiene implicaciones muy grandes si su KDC es MIT, ya que no podrá utilizar el programa <code>kadmin</code> de Heimdal para administrar remotamente su KDC (o viceversa).</p></div><div class=paragraph><p>Las aplicaciones cliente pueden también disponer de diferentes opciones de línea de órdenes para lograr lo mismo. Le recomendamos seguir las instrucciones de la página web de Kerberos del MIT (<a href=http://web.mit.edu/Kerberos/www/>http://web.mit.edu/Kerberos/www/</a>). Sea cuidadoso con los parches: el port del MIT se instala por defecto en <span class=filename>/usr/local/</span>, y las aplicaciones "normales" del sistema pueden ser ejecutadas en lugar de las del MIT si su variable de entorno <code>PATH</code> lista antes los directorios del sistema.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Si usa el port del MIT<a class=package href=https://cgit.freebsd.org/ports/tree/security/krb5/>security/krb5</a> proporcionado por FreeBSD asegúrese de leer el fichero <span class=filename>/usr/local/shared/doc/krb5/README.FreeBSD</span> instalado por el port si quiere entender por qué los login vía <code>telnetd</code> y <code>klogind</code> se comportan de un modo un tanto extraño. Más importante aún, corregir la conducta de "permisos incorrectos en el fichero caché" requiere que el binario <code>login.krb5</code> se use para la validación para que pueda cambiar correctamente los permisos de propiedad de credenciales reenviadas.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=_mitigación_de_limitaciones_encontradas_en_kerberos>14.8.8. Mitigación de limitaciones encontradas en Kerberos<a class=anchor href=#_mitigación_de_limitaciones_encontradas_en_kerberos></a></h4><div class=sect4><h5 id=_kerberos_es_un_enfoque_todo_o_nada>14.8.8.1. Kerberos es un enfoque "todo o nada"<a class=anchor href=#_kerberos_es_un_enfoque_todo_o_nada></a></h5><div class=paragraph><p>Cada servicio habilitado en la red debe modificarse para funcionar con Kerberos (o debe ser asegurado contra ataques de red) o de lo contrario las credenciales de usuario pueden robarse y reutilizarse. Un ejemplo de esto podría ser que Kerberos habilite todos los shells remotos ( vía <code>rsh</code> y <code>telnet</code>, por ejemplo) pero que no cubra el servidor de correo POP3, que envía contraseñas en texto plano.</p></div></div><div class=sect4><h5 id=_kerberos_está_pensado_para_estaciones_de_trabajo_monousuario>14.8.8.2. Kerberos está pensado para estaciones de trabajo monousuario<a class=anchor href=#_kerberos_está_pensado_para_estaciones_de_trabajo_monousuario></a></h5><div class=paragraph><p>En un entorno multiusuario Kerberos es menos seguro. Esto se debe a que almacena los tickets en el directorio <span class=filename>/tmp</span>, que puede ser leído por todos los usuarios. Si un usuario está compartiendo una computadora con varias personas (esto es, si utiliza un sistema multiusuario) es posible que los tickets sean robados (copiados) por otro usuario.</p></div><div class=paragraph><p>Esto puede solventarse con la opción de línea de órdenes <code>-c</code> nombre-de-fichero o (mejor aún) la variable de entorno <code>KRB5CCNAME</code>, pero raramente se hace. Si almacena los tickets en el directorio home de los usuarios y utiliza sin mucha complicación los permisos de fichero puede mitigar este problema.</p></div></div><div class=sect4><h5 id=_el_kdc_es_el_punto_crítico_de_fallo>14.8.8.3. El KDC es el punto crítico de fallo<a class=anchor href=#_el_kdc_es_el_punto_crítico_de_fallo></a></h5><div class=paragraph><p>Por motivos de diseño el KDC es tan seguro como la base de datos principal de contraseñas que contiene. El KDC no debe ejecutar ningún otro servicio ejecutándose en él y debe ser físicamente seguro. El peligro es grande debido a que Kerberos almacena todas las contraseñas cifradas con la misma llave (la llave "maestra", que a su vez se guarda como un fichero en el KDC).</p></div><div class=paragraph><p>De todos modos una llave maestra comprometida no es algo tan terrible como parece a primera vista. La llave maestra solo se usa para cifrar la base de datos Kerberos y como semilla para el generador de números aleatorios. Mientras sea seguro el acceso a su KDC un atancante no puede hacer demasiado con la llave maestra.</p></div><div class=paragraph><p>Además, si el KDC no está disponible (quizás debido a un ataque de denegación de servicio o problemas de red) no se podrán utilizar los servicios de red ya que no se puede efectuar la validación, lo que hace que esta sea una buena forma de lanzar un ataque de denegación de servicio. Este problema puede aliviarse con múltiples KDCs (un maestro y uno o más esclavos) y con una implementación cautelosa de secundarios o autentificación de respaldo (para esto PAM es excelente).</p></div></div><div class=sect4><h5 id=_limitaciones_de_kerberos>14.8.8.4. Limitaciones de Kerberos<a class=anchor href=#_limitaciones_de_kerberos></a></h5><div class=paragraph><p>Kerberos le permite a usuarios, equipos y servicios validarse entre sí, pero no dispone de ningún mecanismo para autentificar el KDC a los usuarios, equipos o servicios. Esto significa que una versión (por ejemplo) "troyanizada" <code>kinit</code> puede grabar todos los usuarios y sus contraseñas. Puede usar <a class=package href=https://cgit.freebsd.org/ports/tree/security/tripwire/>security/tripwire</a> o alguna otra herramienta de revisión de integridad de sistemas de ficheros para intentar evitar problemas como este.</p></div></div></div><div class=sect3><h4 id=_recursos_y_más_información>14.8.9. Recursos y más información<a class=anchor href=#_recursos_y_más_información></a></h4><div class=ulist><ul><li><p><a href=http://www.faqs.org/faqs/Kerberos-faq/general/preamble.html>Las preguntas frecuentes (FAQ) de Kerberos</a></p></li><li><p><a href=http://web.mit.edu/Kerberos/www/dialogue.html>Designing an Authentication System: a Dialog in Four Scenes</a></p></li><li><p><a href="http://www.ietf.org/rfc/rfc1510.txt?number=1510">RFC 1510, The Kerberos Network Authentication Service (V5)</a></p></li><li><p><a href=http://web.mit.edu/Kerberos/www/>Página web de Kerberos del MIT</a></p></li><li><p><a href=http://www.pdc.kth.se/heimdal/>Página web de Kerberos Heimdal</a></p></li></ul></div></div></div><div class=sect2><h3 id=openssl>14.9. OpenSSL<a class=anchor href=#openssl></a></h3><div class=paragraph><p>El conjunto de herramientas OpenSSL es una característica de FreeBSD que muchos usuarios pasan por alto. OpenSSL ofrece una capa de cifrada de transporte sobre la capa normal de comunicación, permitiendo la combinación con con muchas aplicaciones y servicios de red.</p></div><div class=paragraph><p>Algunos usos de OpenSSL son la validación cifrada de clientes de correo, las transacciones basadas en web como pagos con tarjetas de crédito, etc. Muchos ports, como <a class=package href=https://cgit.freebsd.org/ports/tree/www/apache13-ssl/>www/apache13-ssl</a> y <a class=package href=https://cgit.freebsd.org/ports/tree/mail/sylpheed-claws/>mail/sylpheed-claws</a> ofrecen soporte de compilación para OpenSSL.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>En la mayoría de los casos la colección de ports tratará de compilar el port <a class=package href=https://cgit.freebsd.org/ports/tree/security/openssl/>security/openssl</a> a menos que la variable de make <code>WITH_OPENSSL_BASE</code> sea puesta explícitamente a "yes".</p></div></td></tr></tbody></table></div><div class=paragraph><p>La versión de OpenSSL incluida en FreeBSD soporta los protocolos de seguridad de red Secure Sockets Layer v2/v3 (SSLv2/SSLv3) y Transport Layer Security v1 (TLSv1) y puede utilizarse como biblioteca criptográfica general.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>OpenSSL soporta el algoritmo IDEA pero estáa deshabilitado por defecto debido a patentes en vigor en los Estados Unidos. Si quiere usarlo debe revisar la licencia, y si las restricciones le parecen aceptables active la variable <code>MAKE_IDEA</code> en <span class=filename>make.conf</span>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Uno de los usos más comunes de OpenSSL es ofrecer certificados para usar con aplicaciones de software. Estos certificados aseguran que las credenciales de la compañia o individuo son válidos y no son fraudulentos. Si el certificado en cuestión no ha sido verificado por uno de las diversas "autoridades certificadoras" o CA, suele generarse una advertencia al respecto. Una autoridad de certificados es una compañia, como <a href=http://www.verisign.com>VeriSign</a>, que firma certificados para validar credenciales de individuos o compañias. Este proceso tiene un costo asociado y no es un requisito imprescindible para usar certificados, aunque puede darle un poco de tranquilidad a los usuarios más paranóicos.</p></div><div class=sect3><h4 id=_generación_de_certificados>14.9.1. Generación de certificados<a class=anchor href=#_generación_de_certificados></a></h4><div class=paragraph><p>Para generar un certificado ejecute lo siguiente:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># openssl req -new -nodes -out req.pem -keyout cert.pem</span>
Generating a 1024 bit RSA private key
................++++++
.......................................++++++
writing new private key to <span class=s1>&#39;cert.pem&#39;</span>
<span class=nt>-----</span>
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter <span class=s1>&#39;.&#39;</span>, the field will be left blank.
<span class=nt>-----</span>
Country Name <span class=o>(</span>2 letter code<span class=o>)</span> <span class=o>[</span>AU]:US
State or Province Name <span class=o>(</span>full name<span class=o>)</span> <span class=o>[</span>Some-State]:PA
Locality Name <span class=o>(</span>eg, city<span class=o>)</span> <span class=o>[]</span>:Pittsburgh
Organization Name <span class=o>(</span>eg, company<span class=o>)</span> <span class=o>[</span>Internet Widgits Pty Ltd]:Mi compañía
Organizational Unit Name <span class=o>(</span>eg, section<span class=o>)</span> <span class=o>[]</span>:Administrador de sistemas
Common Name <span class=o>(</span>eg, YOUR name<span class=o>)</span> <span class=o>[]</span>:localhost.ejemplo.org
Email Address <span class=o>[]</span>:trhodes@FreeBSD.org

Please enter the following <span class=s1>&#39;extra&#39;</span> attributes
to be sent with your certificate request
A challenge password <span class=o>[]</span>:UNA CONTRASEÑA
An optional company name <span class=o>[]</span>:Otro nombre</code></pre></div></div><div class=paragraph><p>Tenga en cuenta que la respuesta directamente después de "prompt""Common Name" muestra un nombre de dominio. Este "prompt" requiere que se introduzca un nombre de servidor para usarlo en la verificación; si escribe cualquier otra cosa producirá un certificado inválido. Otras opciones, por ejemplo el tiempo de expiración, alternan algoritmos de cifrado, etc. Puede ver una lista completa en la página de manual de <a href="https://man.freebsd.org/cgi/man.cgi?query=openssl&amp;sektion=1&amp;format=html">openssl(1)</a>.</p></div><div class=paragraph><p>Debería tener dos ficheros en el directorio donde ha ejecutado la orden anterior. La petición de certificado, <span class=filename>req.pem</span>, es lo que debe enviar a una autoridad certificadora para que valide las credenciales que introdujo; firmará la petición y le devolverá el certificado. El segundo fichero es <span class=filename>cert.pem</span> y es la llave privada para el certificado, que debe proteger a toda costa; si cae en malas manos podrí usarse para suplantarle a usted o a sus servidores.</p></div><div class=paragraph><p>Si no necesita la firma de una CA puede crear y firmar usted mismo su certificado. Primero, genere la llave RSA:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># openssl dsaparam -rand -genkey -out myRSA.key 1024</span></code></pre></div></div><div class=paragraph><p>A continuación genere la llave CA:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># openssl gendsa -des3 -out myca.key myRSA.key</span></code></pre></div></div><div class=paragraph><p>Utilice esta llave para crear el certificado:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># openssl req -new -x509 -days 365 -key myca.key -out new.crt</span></code></pre></div></div><div class=paragraph><p>Deberín aparecer dos nuevos ficheros en su directorio: un fichero de firma de autoridad de certificados (<span class=filename>myca.key</span>) y el certificado en sí, <span class=filename>new.crt</span>. Deben ubicarse en un directorio, que se recomienda que sea <span class=filename>/etc</span>, que es legible solo para <code>root</code>. Para terminar, es recomendable asignar permisos 0700 para el fichero con <code>chmod</code>.</p></div></div><div class=sect3><h4 id=_uso_de_certificados_un_ejemplo>14.9.2. Uso de certificados; un ejemplo<a class=anchor href=#_uso_de_certificados_un_ejemplo></a></h4><div class=paragraph><p>?Qué pueden hacer estos ficheros? Cifrar conexiones al MTASendmail es un buen sitio para usarlos. De este modo eliminará el uso de validación mediante texto en claro para los usuarios que envían correo a través del MTA local.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>No es el mejor uso en el mundo, ya que algunos MUAs enviarán al usuario un mensaje de error si no tiene instalados localmente los certificados. Consulte la documentación para más datos sobre la instalación de certificados.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Debe añadir las siguientes líneas en su fichero local <span class=filename>.mc</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>dnl SSL Options
define(`confCACERT_PATH&#39;,`/etc/certs&#39;)dnl
define(`confCACERT&#39;,`/etc/certs/new.crt&#39;)dnl
define(`confSERVER_CERT&#39;,`/etc/certs/new.crt&#39;)dnl
define(`confSERVER_KEY&#39;,`/etc/certs/myca.key&#39;)dnl
define(`confTLS_SRV_OPTIONS&#39;, `V&#39;)dnl</pre></div></div><div class=paragraph><p><span class=filename>/etc/certs/</span> es el directorio destinado a almacenamiento de los ficheros de certificado y llave en local. El último requisito es una reconstrucción del fichero <span class=filename>.cf</span> local. Solo tiene que teclear <code>make</code><span class=parameter>install</span> en el directorio <span class=filename>/etc/mail</span>. A continuación ejecute un <code>make</code><span class=parameter>restart</span>, que debería reiniciar el dæmon Sendmail.</p></div><div class=paragraph><p>Si todo fué bien no habrá mensajes de error en el fichero <span class=filename>/var/log/maillog</span> y Sendmail aparecerá en la lista de procesos.</p></div><div class=paragraph><p>Puede probarlo todo de una forma muy sencilla; conéctese al servidor de correo mediante <a href="https://man.freebsd.org/cgi/man.cgi?query=telnet&amp;sektion=1&amp;format=html">telnet(1)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># telnet ejemplo.com 25</span>
Trying 192.0.34.166...
Connected to ejemplo.com.
Escape character is <span class=s1>&#39;^]&#39;</span><span class=nb>.</span>
220 ejemplo.com ESMTP Sendmail 8.12.10/8.12.10<span class=p>;</span> Tue, 31 Aug 2004 03:41:22 <span class=nt>-0400</span> <span class=o>(</span>EDT<span class=o>)</span>
ehlo ejemplo.com
250-ejemplo.com Hello ejemplo.com <span class=o>[</span>192.0.34.166], pleased to meet you
250-ENHANCEDSTATUSCODES
250-PIPELINING
250-8BITMIME
250-SIZE
250-DSN
250-ETRN
250-AUTH LOGIN PLAIN
250-STARTTLS
250-DELIVERBY
250 HELP
quit
221 2.0.0 ejemplo.com closing connection
Connection closed by foreign host.</code></pre></div></div><div class=paragraph><p>Si la línea "STARTTLS" aparece en la salida, todo está funcionando correctamente.</p></div></div></div><div class=sect2><h3 id=ipsec>14.10. VPN sobre IPsec<a class=anchor href=#ipsec></a></h3><div class=paragraph><p>Creación de una VPN entre dos redes, a través de Internet, mediante puertas de enlace ("gateways") FreeBSD.</p></div><div class=sect3><h4 id=_qué_es_ipsec>14.10.1. Qué es IPsec<a class=anchor href=#_qué_es_ipsec></a></h4><div class=paragraph><p>Esta sección le guiará a través del proceso de configuración de IPsec, y de su uso en un entorno consistente en máquinas FreeBSD y Microsoft® Windows® 2000/XP, para hacer que se comuniquen de manera segura. Para configurar IPsec es necesario que esté familiarizado con los conceptos de construcción de un kernel personalizado (consulte el <a href=./#kernelconfig>Configuración del kernel de FreeBSD</a>).</p></div><div class=paragraph><p><em>IPsec</em> es un protocolo que está sobre la capa del protocolo de Internet (IP). Le permite a dos o más equipos comunicarse de forma segura (de ahí el nombre). La "pila de red" IPsec de FreeBSD se basa en la implementación <a href=http://www.kame.net/>KAME</a>, que incluye soporte para las dos familias de protocolos, IPv4 e IPv6.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>FreeBSD 5.X contiene una pila IPsec "acelerada por hardware", conocida como "Fast IPsec", que fué obtenida de OpenBSD. Emplea hardware criptográfico (cuando es posible) a través del subsistema <a href="https://man.freebsd.org/cgi/man.cgi?query=crypto&amp;sektion=4&amp;format=html">crypto(4)</a> para optimizar el rendimiento de IPsec. Este subsistema es nuevo, y no soporta todas las opciones disponibles en la versión KAME de IPsec. Para poder habilitar IPsec acelerado por hardware debe añadir las siguientes opciones al fichero de configuración de su kernel:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>options	  FAST_IPSEC  <span class=c># new IPsec (cannot define w/ IPSEC)</span></code></pre></div></div><div class=paragraph><p>Tenga en cuenta que no es posible utilizar el subsistema "Fast IPsec" y la implementación KAME de IPsec en la misma computadora. Consulte la página de manual <a href="https://man.freebsd.org/cgi/man.cgi?query=fast_ipsec&amp;sektion=4&amp;format=html">fast_ipsec(4)</a> para más información.</p></div></td></tr></tbody></table></div><div class=paragraph><p>IPsec consta de dos sub-protocolos:</p></div><div class=ulist><ul><li><p><em>Encapsulated Security Payload (ESP)</em>, que protege los datos del paquete IP de interferencias de terceros, cifrando el contenido utilizando algoritmos de criptografía simétrica (como Blowfish, 3DES).</p></li><li><p><em>Authentication Header (AH)</em>, que protege la cabecera del paquete IP de interferencias de terceros así como contra la falsificación ("spoofing"), calculando una suma de comprobación criptográfica y aplicando a los campos de cabecera IP una función hash segura. Detrás de todo esto va una cabecera adicional que contiene el hash para permitir la validación de la información que contiene el paquete.</p></li></ul></div><div class=paragraph><p>ESP y AH pueden utilizarse conjunta o separadamente, dependiendo del entorno.</p></div><div class=paragraph><p>IPsec puede utilizarse para cifrar directamente el tráfico entre dos equipos (conocido como <em>modo de transporte</em>) o para construir "túneles virtuales" entre dos subredes, que pueden usarse para comunicación segura entre dos redes corporativas (conocido como <em>modo de túnel</em>). Este último es muy conocido como una <em>red privada virtual (Virtual Private Network, o VPN)</em>. <a href="https://man.freebsd.org/cgi/man.cgi?query=ipsec&amp;sektion=4&amp;format=html">ipsec(4)</a> contiene información detallada sobre el subsistema IPsec de FreeBSD.</p></div><div class=paragraph><p>Si quiere añdir soporte IPsec a su kernel debe incluir las siguientes opciones al fichero de configuración de su kernel:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>options   IPSEC        <span class=c>#IP security</span>
options   IPSEC_ESP    <span class=c>#IP security (crypto; define w/ IPSEC)</span></code></pre></div></div><div class=paragraph><p>Si quiere soporte para la depuración de errores no olvide la siguiente opción:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>options   IPSEC_DEBUG  <span class=c>#debug for IP security</span></code></pre></div></div></div><div class=sect3><h4 id=_el_problema>14.10.2. El Problema<a class=anchor href=#_el_problema></a></h4><div class=paragraph><p>No existe un estándar para lo que constituye una VPN. Las VPN pueden implementarse utilizando numerosas tecnologías diferentes, cada una de las cuales tiene sus pros y sus contras. Esta sección presenta un escenario, y las estrategias usadas para implementar una VPN para este escenario.</p></div></div><div class=sect3><h4 id=_el_escenario_dos_redes_conectadas_por_internet_que_queremos_que_se_comporten_como_una_sola>14.10.3. El escenario: dos redes, conectadas por Internet, que queremos que se comporten como una sola<a class=anchor href=#_el_escenario_dos_redes_conectadas_por_internet_que_queremos_que_se_comporten_como_una_sola></a></h4><div class=paragraph><p>Este es el punto de partida:</p></div><div class=ulist><ul><li><p>Usted tiene al menos dos sitios</p></li><li><p>Ambos sitios utilizan IP internamente</p></li><li><p>Ambos sitios están conectados a Internet, a través de una puerta de enlace FreeBSD.</p></li><li><p>La puerta de enlace de cada red tiene al menos una dirección IP pública.</p></li><li><p>Las direcciones internas de las dos redes pueden ser direcciones IP públicas o privadas, no importa. Puede ejecutar NAT en la máquina que hace de puerta de enlace si es necesario.</p></li><li><p>Las direcciones IP internas de las dos redes <em>no colisionan</em>. Aunque espero que sea teóricamente posible utilizar una combinación de tecnología VPN y NAT para hacer funcionar todo esto sospecho que configurarlo sería una pesadilla.</p></li></ul></div><div class=paragraph><p>Si lo que intenta es conectar dos redes y ambas usan el mismo rango de direcciones IP privadas (por ejemplo las dos usan <code>192.168.1.x</code>)debería renumerar una de las dos redes.</p></div><div class=paragraph><p>La topología de red se parecería a esto:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/security/ipsec-network.png alt="ipsec network"></div></div><div class=paragraph><p>Observe las dos direcciones IP públicas. Usaré letras para referirme a ellas en el resto de este artículo. El cualquier lugar que vea esas letras en este artículo reemplácelas con su propia dirección IP pública. Observe también que internamente las dos máquinas que hacen de puerta de enlace tienen la dirección IP .1, y que las dos redes tienen direcciones IP privadas diferentes (<code>192.168.1.x</code> y <code>192.168.2.x</code> respectivamente). Todas las máquinas de las redes privadas están configuradas para utilizar la máquina <code>.1</code> como su puerta de enlace por defecto.</p></div><div class=paragraph><p>La intención es que, desde el punto de vista de la red, cada red debe ver las máquinas en la otra red como si estuvieran directamente conectadas al mismo router (aunque aunque sea un router ligeramente lento con una tendencia ocasional a tirar paquetes).</p></div><div class=paragraph><p>Esto significa que (por ejemplo), la máquina <code>192.168.1.20</code> debe ser capaz de ejecutar</p></div><div class="literalblock programlisting"><div class=content><pre>ping 192.168.2.34</pre></div></div><div class=paragraph><p>y recibir de forma transparente una respuesta. Las máquinas Windows® deben ser capaces de ver las máquinas de la otra red, acceder a sus ficheros compartidos, etc, exactamente igual que cuando acceden a las máquinas de la red local.</p></div><div class=paragraph><p>Y todo debe hacerse de forma segura. Esto significa que el tráfico entre las dos redes tiene que ser cifrado.</p></div><div class=paragraph><p>La creación de una VPN entre estas dos redes es un proceso que requiere varios pasos. Las etapas son estas:</p></div><div class="olist arabic"><ol class=arabic><li><p>Crear un enlace de red "virtual" entre las dos redes, a través de Internet. Probarlo usando herramientas como <a href="https://man.freebsd.org/cgi/man.cgi?query=ping&amp;sektion=8&amp;format=html">ping(8)</a> para asegurarse de que funcione.</p></li><li><p>Aplicar políticas de seguridad para asegurarse de que el tráfico entre las dos redes sea cifrado y descifrado de forma transparente. Comprobarlo mediante herramientas como <a href="https://man.freebsd.org/cgi/man.cgi?query=tcpdump&amp;sektion=1&amp;format=html">tcpdump(1)</a> para asegurarse de que el tráfico esté siendo efectivamente cifrado.</p></li><li><p>Configurar software adicional en las puertas de enlace FreeBSD para permitir a las máquinas Windows® verse entre ellas a través de la VPN.</p></li></ol></div><div class=sect4><h5 id=_paso_1_creación_y_prueba_de_un_enlace_de_red_virtual>14.10.3.1. Paso 1: Creación y prueba de un enlace de red "virtual"<a class=anchor href=#_paso_1_creación_y_prueba_de_un_enlace_de_red_virtual></a></h5><div class=paragraph><p>Suponga que está en la puerta de enlace de la red red #1 (con dirección IP pública <code>A.B.C.D</code>, dirección IP privada <code>192.168.1.1</code>), y ejecuta <code>ping 192.168.2.1</code>, que es la dirección privada de la máquina con dirección IP <code>W.X.Y.Z</code>. ?Qué hace falta para esto?</p></div><div class="olist arabic"><ol class=arabic><li><p>La puerta de enlace necesita saber cómo alcanzar a <code>192.168.2.1</code>. En otras palabras, necesita tener una ruta hasta <code>192.168.2.1</code>.</p></li><li><p>Las direcciones IP privadas, como las que están en el rango <code>192.168.x</code> no deberían aparecer en Internet. Por eso, cada paquete que mande a <code>192.168.2.1</code> necesitará encerrarse dentro de otro paquete. Este paquete debe tener todas las características de haber sido enviado desde <code>A.B.C.D</code>, y tendrá que ser enviado a <code>W.X.Y.Z</code>. Este proceso recibe el nombre de <em>encapsulado</em>.</p></li><li><p>Una vez que este paquete llega a <code>W.X.Y.Z</code> necesitará ser "desencapsulado", y entregado a <code>192.168.2.1</code>.</p></li></ol></div><div class=paragraph><p>Puede verlo como si necesitara un "túnel" entre las dos redes. Las dos "bocas del túnel" son las direcciones IP <code>A.B.C.D</code> y <code>W.X.Y.Z</code>, y debe hacer que el túnel sepa cuáles serán las direcciones IP privadas que tendrán permitido el paso a través de él. El túnel se usa para transferir tráfico con direcciones IP privadas a través de la Internet pública.</p></div><div class=paragraph><p>Este túnel se crea mediante la interfaz genérica, o dispositivo <span class=filename>gif</span> en FreeBSD. Como puede imaginarse la interfaz <span class=filename>gif</span> de cada puerta de enlace debe configurarse con cuatro direcciones IP: dos para las direcciones IP públicas, y dos para las direcciones IP privadas.</p></div><div class=paragraph><p>El soporte para el dispositivo gif debe compilarse en el kernel de FreeBSD en ambas máquinas añadiendo la línea</p></div><div class="literalblock programlisting"><div class=content><pre>device gif</pre></div></div><div class=paragraph><p>a los ficheros de configuración del kernel de ambas máquinas, compilarlo, instalarlo y reiniciar.</p></div><div class=paragraph><p>La configuración del túnel es un proceso que consta de dos partes. Primero se le debe decir al túnel cuáles son las direcciones IP exteriores (o públicas) mediante <a href="https://man.freebsd.org/cgi/man.cgi?query=gifconfig&amp;sektion=8&amp;format=html">gifconfig(8)</a>. Después configure las direcciones IP con <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>En FreeBSD 5.X las funciones de <a href="https://man.freebsd.org/cgi/man.cgi?query=gifconfig&amp;sektion=8&amp;format=html">gifconfig(8)</a> se han incluido en <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>En la puerta de enlace de la red #1 debe ejecutar las siguientes dos órdenes para configurar el túnel.</p></div><div class="literalblock programlisting"><div class=content><pre>gifconfig gif0 A.B.C.D W.X.Y.Z
ifconfig gif0 inet 192.168.1.1 192.168.2.1 netmask 0xffffffff</pre></div></div><div class=paragraph><p>En la otra puerta de enlace ejecute las mismas órdenes, pero con el orden las direcciones IP invertido.</p></div><div class="literalblock programlisting"><div class=content><pre>gifconfig gif0 W.X.Y.Z A.B.C.D
ifconfig gif0 inet 192.168.2.1 192.168.1.1 netmask 0xffffffff</pre></div></div><div class=paragraph><p>Ahora ejecute:</p></div><div class="literalblock programlisting"><div class=content><pre>gifconfig gif0</pre></div></div><div class=paragraph><p>y podrá ver la configuración. Por ejemplo, en la puerta de enlace de la red #1 vería algo parecido a esto:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gifconfig gif0</span>
gif0: <span class=nv>flags</span><span class=o>=</span>8011&lt;UP,POINTTOPOINT,MULTICAST&gt; mtu 1280
inet 192.168.1.1 <span class=nt>--</span><span class=o>&gt;</span> 192.168.2.1 netmask 0xffffffff
physical address inet A.B.C.D <span class=nt>--</span><span class=o>&gt;</span> W.X.Y.Z</code></pre></div></div><div class=paragraph><p>Como puede ver se ha creado un túnel entre las direcciones físicas <code>A.B.C.D</code> y <code>W.X.Y.Z</code>, y el tráfico que puede pasar a través del túnel es entre <code>192.168.1.1</code> y <code>192.168.2.1</code>.</p></div><div class=paragraph><p>Esto también habrá agregado una entrada en la tabla de rutas de ambas máquinas, que puede examinar con <code>netstat -rn</code>. Esta salida es de la puerta de enlace de la red #1.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># netstat -rn</span>
Routing tables

Internet:
Destination      Gateway       Flags    Refs    Use    Netif  Expire
...
192.168.2.1      192.168.1.1   UH        0        0    gif0
...</code></pre></div></div><div class=paragraph><p>Como el valor de "Flags" lo indica, esta es una ruta de equipo, lo que significa que cada puerta de enlace sabe como alcanzar la otra puerta de enlace, pero no saben cómo llegar al resto de sus respectivas redes. Ese problema se solucionará en breve.</p></div><div class=paragraph><p>Es posible que disponga de un cortafuegos en ambas máquinas, por lo que tendrá que buscar la forma de que el tráfico de la VPN pueda entrar y salir limpiamente. Puede permitir todo el tráfico de ambas redes, o puede que quiera incluir reglas en el cortafuegos para que protejan ambos extremos de la VPN uno del otro.</p></div><div class=paragraph><p>Las pruebas se simplifican enormemente si configura el cortafuegos para permitir todo el tráfico a través de la VPN. Siempre puede ajustar las cosas después. Si utiliza <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfw&amp;sektion=8&amp;format=html">ipfw(8)</a> en las puertas de enlace una orden similar a</p></div><div class="literalblock programlisting"><div class=content><pre>ipfw add 1 allow ip from any to any via gif0</pre></div></div><div class=paragraph><p>permitirá todo el tráfico entre los dos extremos de la VPN, sin afectar al resto de reglas del cortafuegos. Obviamente tendrá que ejecutar esta orden en ambas puertas de enlace.</p></div><div class=paragraph><p>Esto es suficiente para permitir a cada puerta de enlace hacer un ping entre ellas. En <code>192.168.1.1</code> deberí poder ejecutar</p></div><div class="literalblock programlisting"><div class=content><pre>ping 192.168.2.1</pre></div></div><div class=paragraph><p>y obtener una respuesta; es obvio que debería poder hacer los mismo en la otra puerte de enlace.</p></div><div class=paragraph><p>Aún no podrá acceder a las máquinas internas de las redes. El problema está en el encaminamiento: aunque las puertas de enlace saben cómo alcanzarse mútuamente no saben cómo llegar a la red que hay detrás de la otra.</p></div><div class=paragraph><p>Para resolver este problema debe añadir una ruta estática en cada puerta de enlace. La orden en la primera puerta de enlace podría ser:</p></div><div class="literalblock programlisting"><div class=content><pre>route add 192.168.2.0 192.168.2.1 netmask 0xffffff00</pre></div></div><div class=paragraph><p>Esto significa "Para alcanzar los equipos en la red <code>192.168.2.0</code>, envía los paquetes al equipo <code>192.168.2.1</code>". Necesitará ejecutar una orden similar en la otra puerta de enlace, pero obviamente con las direcciones <code>192.168.1.x</code>.</p></div><div class=paragraph><p>El tráfico IP de equipos en una red no será capaz de alcanzar equipos en la otra red.</p></div><div class=paragraph><p>Ya tiene dos tercios de una VPN, puesto que ya es "virtual" y es una "red". Todavía no es privada. Puede comprobarlo con <a href="https://man.freebsd.org/cgi/man.cgi?query=ping&amp;sektion=8&amp;format=html">ping(8)</a> y <a href="https://man.freebsd.org/cgi/man.cgi?query=tcpdump&amp;sektion=1&amp;format=html">tcpdump(1)</a>. Abra una sesión en la puerta de enlace y ejecute</p></div><div class="literalblock programlisting"><div class=content><pre>tcpdump dst host 192.168.2.1</pre></div></div><div class=paragraph><p>En otra sesión en el mismo equipo ejecute</p></div><div class="literalblock programlisting"><div class=content><pre>ping 192.168.2.1</pre></div></div><div class=paragraph><p>Verá algo muy parecido a esto:</p></div><div class="literalblock programlisting"><div class=content><pre>16:10:24.018080 192.168.1.1 &gt; 192.168.2.1: icmp: echo request
16:10:24.018109 192.168.1.1 &gt; 192.168.2.1: icmp: echo reply
16:10:25.018814 192.168.1.1 &gt; 192.168.2.1: icmp: echo request
16:10:25.018847 192.168.1.1 &gt; 192.168.2.1: icmp: echo reply
16:10:26.028896 192.168.1.1 &gt; 192.168.2.1: icmp: echo request
16:10:26.029112 192.168.1.1 &gt; 192.168.2.1: icmp: echo reply</pre></div></div><div class=paragraph><p>Como puede ver los mensajes ICMP van y vienen sin cifrar. Si usa el parámetro <code>-s</code> en <a href="https://man.freebsd.org/cgi/man.cgi?query=tcpdump&amp;sektion=1&amp;format=html">tcpdump(1)</a> para tomar más bytes de datos de estos paquetes verá más información.</p></div><div class=paragraph><p>Obviamente esto es inaceptable. La siguiente sección explicará cómo asegurar el enlace entre las dos redes para que todo el tráfico se cifre automáticamente.</p></div><div class=ulist><div class=title>Sumario:</div><ul><li><p>Configure ambos kernel con "pseudo-device gif".</p></li><li><p>Edite <span class=filename>/etc/rc.conf</span> en la puerta de enlace #1 y añada las siguientes líneas (reemplazando las direcciones IP según sea necesario).</p><div class="literalblock programlisting"><div class=content><pre>gifconfig_gif0=&#34;A.B.C.D W.X.Y.Z&#34;
ifconfig_gif0=&#34;inet 192.168.1.1 192.168.2.1 netmask 0xffffffff&#34;
static_routes=&#34;vpn&#34;
route_vpn=&#34;192.168.2.0 192.168.2.1 netmask 0xffffff00&#34;</pre></div></div></li><li><p>Edite la configuración de su cortafuegos (<span class=filename>/etc/rc.firewall</span>, o lo que corresponda) en ambos equipos y añada</p><div class="literalblock programlisting"><div class=content><pre>ipfw add 1 allow ip from any to any via gif0</pre></div></div></li><li><p>Haga los cambios oportunos en el <span class=filename>/etc/rc.conf</span> de la puerta de enlace #2, invirtiendo el orden de las direcciones IP.</p></li></ul></div></div><div class=sect4><h5 id=_paso_2_asegurar_el_enlace>14.10.3.2. Paso 2: Asegurar el enlace<a class=anchor href=#_paso_2_asegurar_el_enlace></a></h5><div class=paragraph><p>Para asegurar el enlace usaremos IPsec. IPsec ofrece un mecanismo para que dos equipos coincidan en una llave de cifrado, y usar esta llave para cifrar los datos entre los dos equipos.</p></div><div class=paragraph><p>Existen dos áreas de configuración a tener en cuenta:</p></div><div class="olist arabic"><ol class=arabic><li><p>Debe existir un mecanismo para que los dos equipos se pongan de acuerdo en el mecanismo de cifrado que van a utilizar. Una vez que los dos equipos se han puesto de acuerdo dice que existe una "asociación de seguridad" entre ellos.</p></li><li><p>Debe existir un mecanismo para especificar que tráfico debe ser cifrado. Obviamente, usted no querrá cifrar todo su tráfico saliente: solo querrá cifrar el tráfico que es parte de la VPN. Las reglas con las que determinará qué tráfico será cifrado se llaman "políticas de seguridad".</p></li></ol></div><div class=paragraph><p>Tanto las asociaciones de seguridad como las políticas de seguridad son responsabilidad del kernel, pero pueden ser modificadas desde el espacio de usuario. Antes de poder hacerlo, tendrá que configurar el kernel para que incluya IPsec y el protocolo ESP (Encapsulated Security Payload). Incluya en el fichero de configuración de su kernel lo siguiente:</p></div><div class="literalblock programlisting"><div class=content><pre>options IPSEC
options IPSEC_ESP</pre></div></div><div class=paragraph><p>Recompile y resintale su kernel y reinicie. Como se dijo anteriormente, tendrá que hacer lo mismo en el kernel de las dos puertas de enlace.</p></div><div class=paragraph><p>Tiene dos opciones cuando se trata de configurar asociaciones de seguridad. Puede configurarlas a mano en los dos equipos, lo que significa elegir el algoritmo de cifrado, las llaves de cifrado, etc, o puede utilizar alguno de los dæmons que implementan el protocolo de intercambio de llaves de Internet (IKE, Internet Key Exchange).</p></div><div class=paragraph><p>Le recomiendo la segunda opción. Aparte de otras consideraciones es más fácil de configurar.</p></div><div class=paragraph><p>La edición y despliegue se efectúa con <a href="https://man.freebsd.org/cgi/man.cgi?query=setkey&amp;sektion=8&amp;format=html">setkey(8)</a>. Todo esto se entiende mejor con una analogía. <code>setkey</code> es a las tablas de políticas de seguridad del kernel lo que <a href="https://man.freebsd.org/cgi/man.cgi?query=route&amp;sektion=8&amp;format=html">route(8)</a> es a las tablas de rutas del kernel. También puede usar <code>setkey</code> ver las asociaciones de seguridad en vigor, siguiendo con la analogía, igual que puede usar <code>netstat -r</code>.</p></div><div class=paragraph><p>Existen numerosos dæmons que pueden encargarse de la gestión de asociaciones de seguridad en FreeBSD. En este texto se muestra cómo usar uno de ellos, racoon (que puede instalar desde <a class=package href=https://cgit.freebsd.org/ports/tree/security/racoon/>security/racoon</a> en la colección de ports de FreeBSD.</p></div><div class=paragraph><p>El software <a class=package href=https://cgit.freebsd.org/ports/tree/security/racoon/>security/racoon</a> debe ejecutarse en las dos puertas de enlace. En cada equipo debe configurar la dirección IP del otro extremo de la VPN y una llave secreta (que usted puede y debe elegir, y debe ser la misma en ambas puertas de enlace).</p></div><div class=paragraph><p>Los dos dæmons entran en contacto uno con otro, y confirman que son quienes dicen ser (utilizando la llave secreta que usted configuró). Los dæmons generan una nueva llave secreta, y la utilizan para cifrar el tráfico que discurre a través de la VPN. Periódicamente cambian esta llave, para que incluso si un atacante comprometiera una de las llaves (lo cual es teóricamente cercano a imposible) no le serviriía de mucho: para cuando el atacante haya "crackeado" la llave los dæmons ya habrán escogido una nueva.</p></div><div class=paragraph><p>El fichero de configuración de racoon está en <span class=filename>${PREFIX}/etc/racoon</span>. No debería tener que hacer demasiados cambios a ese fichero. El otro componente de la configuración de racoon (que <em>sí</em> tendrá que modificar) es la "llave pre-compartida".</p></div><div class=paragraph><p>La configuración por defecto de racoon espera encontrarla en <span class=filename>${PREFIX}/etc/racoon/psk.txt</span>. Es importante saber que la llave precompartida <em>no</em> es la llave que se utilizará para cifrar el tráfico a través del enlace VPN; solamente es una muestra que permite a los dæmons que administran las llaves confiar el uno en el otro.</p></div><div class=paragraph><p><span class=filename>psk.txt</span> contiene una línea por cada sitio remoto con el que esté tratando. En nuestro ejemplo, donde existen dos sitios, cada fichero <span class=filename>psk.txt</span> contendrá una línea (porque cada extremo de la VPN solo está tratando con un sitio en el otro extremo).</p></div><div class=paragraph><p>En la puerta de enlace #1 esta línea debería parecerse a esta:</p></div><div class="literalblock programlisting"><div class=content><pre>W.X.Y.Z            secreto</pre></div></div><div class=paragraph><p>Esto es, la dirección IP <em>pública</em> del extremo remoto, un espacio en blanco, y una cadena de texto que es el secreto en sí. en el extremo remoto, espacio en blanco, y un texto de cadena que proporcina el secreto. Obviamente, no debe utilizar "secret" como su llave; aplique aquí las reglas y recomendaciones habituales para la elección de contraseñas.</p></div><div class=paragraph><p>En la puerta de enlace #2 la línea se parecería a esta</p></div><div class="literalblock programlisting"><div class=content><pre>A.B.C.D            secreto</pre></div></div><div class=paragraph><p>Esto es, la dirección IP pública del extremo remoto, y la misma llave secreta. <span class=filename>psk.txt</span> debe tener modo <code>0600</code> (es decir, modo de solo lectura/escritura para <code>root</code>) antes de que ejecute racoon.</p></div><div class=paragraph><p>Debe ejecutar racoon en ambas puertas de enlace. También tendrá que añadir algunas reglas a su cortafuegos para permitir el tráfico IKE, que se transporta sobre UDP al puerto ISAKMP (Internet Security Association Key Management Protocol). Esto debe estar al principio de las reglas de su cortafuegos.</p></div><div class="literalblock programlisting"><div class=content><pre>ipfw add 1 allow udp from A.B.C.D to W.X.Y.Z isakmp
ipfw add 1 allow udp from W.X.Y.Z to A.B.C.D isakmp</pre></div></div><div class=paragraph><p>Una vez que ejecute racoon puede tratar de hacer un ping a una puerta de enlace desde la otra. La conexión todavía no está cifrada porque aún no se han creado las asociaciones de seguridad entre los dos equipos: esto puede llevar un poco de tiempo; es posible que advierta un pequeño retraso antes de los ping empiecen responder.</p></div><div class=paragraph><p>Una vez creadas las asociaciones de seguridad puede verlas utilizando <a href="https://man.freebsd.org/cgi/man.cgi?query=setkey&amp;sektion=8&amp;format=html">setkey(8)</a>. Ejecute</p></div><div class="literalblock programlisting"><div class=content><pre>setkey -D</pre></div></div><div class=paragraph><p>en cualquiera de los equipos para comprobar la información de la asociación de seguridad.</p></div><div class=paragraph><p>Ya está resuelta la mitad del problema. La otra mitad es configurar sus políticas de seguridad.</p></div><div class=paragraph><p>Queremos crear una política de seguridad sensata, así que vamos a revisar lo que tenemos configurado hasta el momento. Esta revisión abarca ambos extremos del enlace.</p></div><div class=paragraph><p>Cada paquete IP que usted manda tiene una cabecera que contiene datos acerca del paquete. La cabecera incluye la dirección IP de destino y del origen. Como ya sabemos, las direcciones IP privadas como el rango <code>192.168.x.y</code> no deberían aparezcan en Internet. Dado que es a través de Internet por donde los queremos transmitir los debemos encapsular dentro de otro paquete. Este paquete debe contener tanto la dirección IP de destino y origen públicas sustituidas por las direcciones privadas.</p></div><div class=paragraph><p>Así que si su paquete saliente empezó pareciendose a este:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/security/ipsec-out-pkt.png alt="ipsec out pkt"></div></div><div class=paragraph><p>tras el encapsulado se parecerá bastante a este:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/security/ipsec-encap-pkt.png alt="ipsec encap pkt"></div></div><div class=paragraph><p>El dispositivo <span class=filename>gif</span> se encarga del encapsulado. Como puede ver el paquete tiene una dirección IP real en el exterior, y nuestro paquete original ha sido envuelto como dato dentro del paquete que enviaremos a través de Internet.</p></div><div class=paragraph><p>Obviamente, queremos que todo el tráfico entre las VPN vaya cifrado. Pongamos esto último en palabras para comprenderlo mejor:</p></div><div class=paragraph><p>"Si un paquete sale desde <code>A.B.C.D</code>, y tiene como destino <code>W.X.Y.Z</code>, cífralo utilizando las asociaciones de seguridad necesarias."</p></div><div class=paragraph><p>"Si un paquete llega desde <code>W.X.Y.Z</code>, y tiene como destino <code>A.B.C.D</code>, descífralo utilizando las asociaciones de seguridad necesarias."</p></div><div class=paragraph><p>Este planteamiento se aproxima bastante, pero no es exactamente lo que queremos hacer. Si lo hiciera así todo el tráfico desde y hacia <code>W.X.Y.Z</code>, incluso el tráfico que no forma parte de la VPN, será cifrado; esto no es lo que queremos. La política correcta es la siguiente:</p></div><div class=paragraph><p>"Si un paquete sale desde <code>A.B.C.D</code>, y está encapsulando a otro paquete, y tiene como destino <code>W.X.Y.Z</code>, cífralo utilizando las asociaciones de seguridad necesarias."</p></div><div class=paragraph><p>"Si un paquete llega desde <code>W.X.Y.Z</code>, y está encapsulando a otro paquete, y tiene como destino <code>A.B.C.D</code>, descífralo utilizando las asociaciones de seguridad necesarias."</p></div><div class=paragraph><p>Un cambio sutil, pero necesario.</p></div><div class=paragraph><p>Las políticas de seguridad también se imponen utilizando <a href="https://man.freebsd.org/cgi/man.cgi?query=setkey&amp;sektion=8&amp;format=html">setkey(8)</a>. <a href="https://man.freebsd.org/cgi/man.cgi?query=setkey&amp;sektion=8&amp;format=html">setkey(8)</a> proporciona un lenguaje de configuración para definir la política. Puede introducir las instrucciones de configuración a través de la entrada estándar (stdin), o puede usar la opción <code>-f</code> para especificar un fichero que contenga las instrucciones de configuración.</p></div><div class=paragraph><p>La configuración en la puerta de enlace #1 (que tiene la dirección IP pública <code>A.B.C.D</code>) para forzar que todo el tráfico saliente hacia <code>W.X.Y.Z</code> vaya cifrado es:</p></div><div class="literalblock programlisting"><div class=content><pre>spdadd A.B.C.D/32 W.X.Y.Z/32 ipencap -P out ipsec esp/tunnel/A.B.C.D-W.X.Y.Z/require;</pre></div></div><div class=paragraph><p>Ponga estas órdenes en un fichero (por ejemplo <span class=filename>/etc/ipsec.conf</span>) y ejecute</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># setkey -f /etc/ipsec.conf</span></code></pre></div></div><div class=paragraph><p><code>spdadd</code> le dice a <a href="https://man.freebsd.org/cgi/man.cgi?query=setkey&amp;sektion=8&amp;format=html">setkey(8)</a> que queremos añadir una regla a la base de datos de políticas de seguridad. El resto de la línea especifica qué paquetes se ajustarán a esta política. <code>A.B.C.D/32</code> y <code>W.X.Y.Z/32</code> son las direcciones IP y máscaras de red que identifican la red o equipos a los que se aplicará esta política. En nuestro caso queremos aplicarla al tráfico entre estos dos equipos. <code>-P out</code> dice que esta política se aplica a paquetes salientes, e <code>ipsec</code> hace que el paquete sea asegurado.</p></div><div class=paragraph><p>La segunda línea especifica cómo será cifrado este paquete. <code>esp</code> es el protocolo que se utilizará, mientras que <code>tunnel</code> indica que el paquete será después encapsulado en un paquete IPsec. El uso repetido de <code>A.B.C.D</code> y <code>W.X.Y.Z</code> se utiliza para seleccionar la asociación de seguridad a usar, y por último <code>require</code> exige que los paquetes deben cifrarse si concuerdan con esta regla.</p></div><div class=paragraph><p>Esta regla solo concuerda con paquetes salientes. Necesitará una regla similar para los paquetes entrantes.</p></div><div class="literalblock programlisting"><div class=content><pre>spdadd W.X.Y.Z/32 A.B.C.D/32 ipencap -P in ipsec esp/tunnel/W.X.Y.Z-A.B.C.D/require;</pre></div></div><div class=paragraph><p>Observe el <code>in</code> en lugar del <code>out</code> en este caso, y la inversión necesaria de las direcciones IP.</p></div><div class=paragraph><p>La otra puerta de enlace (que tiene la dirección IP pública <code>W.X.Y.Z</code>) necesitará reglas similares.</p></div><div class="literalblock programlisting"><div class=content><pre>spdadd W.X.Y.Z/32 A.B.C.D/32 ipencap -P out ipsec esp/tunnel/W.X.Y.Z-A.B.C.D/require;
spdadd A.B.C.D/32 W.X.Y.Z/32 ipencap -P in ipsec esp/tunnel/A.B.C.D-W.X.Y.Z/require;</pre></div></div><div class=paragraph><p>Finalmente, necesita añadir reglas a su cortafuegos para permitir la circulación de paquetes ESP e IPENCAP de ida y vuelta. Tendrá que añadir reglas como estas a ambos equipos.</p></div><div class="literalblock programlisting"><div class=content><pre>ipfw add 1 allow esp from A.B.C.D to W.X.Y.Z
ipfw add 1 allow esp from W.X.Y.Z to A.B.C.D
ipfw add 1 allow ipencap from A.B.C.D to W.X.Y.Z
ipfw add 1 allow ipencap from W.X.Y.Z to A.B.C.D</pre></div></div><div class=paragraph><p>Debido a que las reglas son simétricas puede utilizar las mismas reglas en ambas puertas de enlace.</p></div><div class=paragraph><p>Los paquetes salientes tendrán ahora este aspecto:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/security/ipsec-crypt-pkt.png alt="ipsec crypt pkt"></div></div><div class=paragraph><p>Cuando los paquetes llegan al otro extremo de la VPN serán descifrados (utilizando las asociaciones de seguridad que han sido negociadas por racoon). Después entrarán al interfaz <span class=filename>gif</span>, que desenvuelve la segunda capa, hasta que nos quedamos con paquete má interno, que puede entonces viajar a la red interna.</p></div><div class=paragraph><p>Puede revisar la seguridad utilizando la misma prueba de <a href="https://man.freebsd.org/cgi/man.cgi?query=ping&amp;sektion=8&amp;format=html">ping(8)</a> anterior. Primero, inicie una sesión en la puerta de enlace <code>A.B.C.D</code>, y ejecute:</p></div><div class="literalblock programlisting"><div class=content><pre>tcpdump dst host 192.168.2.1</pre></div></div><div class=paragraph><p>En otra sesión en la misma máquina ejecute</p></div><div class="literalblock programlisting"><div class=content><pre>ping 192.168.2.1</pre></div></div><div class=paragraph><p>Debería ver algo similar a lo siguiente:</p></div><div class="literalblock programlisting"><div class=content><pre>XXX tcpdump output</pre></div></div><div class=paragraph><p>ahora, como puede ver, <a href="https://man.freebsd.org/cgi/man.cgi?query=tcpdump&amp;sektion=1&amp;format=html">tcpdump(1)</a> muestra los paquetes ESP. Si trata de examinarlos con la opción <code>-s</code> verá basura (aparentemente), debido al cifrado.</p></div><div class=paragraph><p>Felicidades. Acaba de configurar una VPN entre dos sitios remotos.</p></div><div class=ulist><div class=title>Sumario</div><ul><li><p>Configure ambos kernel con:</p><div class="literalblock programlisting"><div class=content><pre>options IPSEC
options IPSEC_ESP</pre></div></div></li><li><p>Instale <a class=package href=https://cgit.freebsd.org/ports/tree/security/racoon/>security/racoon</a>. Edite <span class=filename>${PREFIX}/etc/racoon/psk.txt</span> en ambas puertas de enlace añadiendo una entrada para la dirección IP del equipo remoto y una llave secreta que ambos conozcan. Asegúrese de que este fichero esté en modo 0600.</p></li><li><p>Añada las siguientes líneas a <span class=filename>/etc/rc.conf</span> en ambos equipos:</p><div class="literalblock programlisting"><div class=content><pre>ipsec_enable=&#34;YES&#34;
ipsec_file=&#34;/etc/ipsec.conf&#34;</pre></div></div></li><li><p>Crée en ambos equipos un <span class=filename>/etc/ipsec.conf</span> que contenga las líneas spdadd necesarias. En la puerta de enlace #1 sería:</p><div class="literalblock programlisting"><div class=content><pre>spdadd A.B.C.D/32 W.X.Y.Z/32 ipencap -P out ipsec
  esp/tunnel/A.B.C.D-W.X.Y.Z/require;
spdadd W.X.Y.Z/32 A.B.C.D/32 ipencap -P in ipsec
  esp/tunnel/W.X.Y.Z-A.B.C.D/require;</pre></div></div><div class=paragraph><p>En la puerta de enlace #2 sería:</p></div><div class="literalblock programlisting"><div class=content><pre>spdadd W.X.Y.Z/32 A.B.C.D/32 ipencap -P out ipsec
  esp/tunnel/W.X.Y.Z-A.B.C.D/require;
spdadd A.B.C.D/32 W.X.Y.Z/32 ipencap -P in ipsec
  esp/tunnel/A.B.C.D-W.X.Y.Z/require;</pre></div></div></li><li><p>Añada a su(s) cortafuegos las reglas necesarias para que permita(n) el paso de tráfico IKE, ESP e IPENCAP en ambos equipos:</p><div class="literalblock programlisting"><div class=content><pre>ipfw add 1 allow udp from A.B.C.D to W.X.Y.Z isakmp
ipfw add 1 allow udp from W.X.Y.Z to A.B.C.D isakmp
ipfw add 1 allow esp from A.B.C.D to W.X.Y.Z
ipfw add 1 allow esp from W.X.Y.Z to A.B.C.D
ipfw add 1 allow ipencap from A.B.C.D to W.X.Y.Z
ipfw add 1 allow ipencap from W.X.Y.Z to A.B.C.D</pre></div></div></li></ul></div><div class=paragraph><p>Los dos pasos previos deben bastar para levantar la VPN. Las máquinas en cada red seán capaces de dirigirse una a otra utilizando direcciones IP, y todo el tráfico a través del enlace será cifrado de forma automática y segura.</p></div></div></div></div><div class=sect2><h3 id=openssh>14.11. OpenSSH<a class=anchor href=#openssh></a></h3><div class=paragraph><p>OpenSSH es un conjunto de herramientas de conectividad que se usan para acceder a sistemas remotos de forma segura. Puede usarse como sustituto directo de <code>rlogin</code>, <code>rsh</code>, <code>rcp</code> y <code>telnet</code>. Además cualquier otra conexión TCP/IP puede reenviarse o enviarse a través de un túnel a través de SSH. OpenSSH cifra todo el tráfico para eliminar de forma efectiva el espionaje, el secuestro de conexiones, y otros ataques en la capa de red.</p></div><div class=paragraph><p>OpenSSH está a cargo del proyecto OpenBSD, y está basado en SSH v1.2.12, con todos los errores recientes corregidos y todas las actualizaciones correspondientes. Es compatible con los protocolos SSH 1 y 2. OpenSSH forma parte del sistema base desde FreeBSD 4.0.</p></div><div class=sect3><h4 id=_ventajas_de_utilizar_openssh>14.11.1. Ventajas de utilizar OpenSSH<a class=anchor href=#_ventajas_de_utilizar_openssh></a></h4><div class=paragraph><p>Normalmente, al utilizar <a href="https://man.freebsd.org/cgi/man.cgi?query=telnet&amp;sektion=1&amp;format=html">telnet(1)</a> o <a href="https://man.freebsd.org/cgi/man.cgi?query=rlogin&amp;sektion=1&amp;format=html">rlogin(1)</a> los datos se envían a través de la red en limpio, es decir, sin cifrar. Cualquier "sniffer" de red entre el cliente y el servidor puede robar la información de usuario/contraseña o los datos transferidos durante su sesión. OpenSSH ofrece diversos métodos de validación y cifrado para evitar que sucedan estas cosas.</p></div></div><div class=sect3><h4 id=_habilitar_sshd>14.11.2. Habilitar sshd<a class=anchor href=#_habilitar_sshd></a></h4><div class=paragraph><p>El dæmon sshd está habilitado por defecto FreeBSD 4.X y puede elegir habilitarlo o no durante la instalación en FreeBSD 5.X. Si quiere saber si está habilitado revise si la siguiente línea está en <span class=filename>rc.conf</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=nv>sshd_enable</span><span class=o>=</span><span class=s2>&#34;YES&#34;</span></code></pre></div></div><div class=paragraph><p>Esta línea cargará <a href="https://man.freebsd.org/cgi/man.cgi?query=sshd&amp;sektion=8&amp;format=html">sshd(8)</a>, el programa dæmon de OpenSSH, en el arranque de su sistema. Puede ejecutar el dæmon sshd tecleando <code>sshd</code> en la línea de órdenes.</p></div></div><div class=sect3><h4 id=_cliente_ssh>14.11.3. Cliente SSH<a class=anchor href=#_cliente_ssh></a></h4><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=ssh&amp;sektion=1&amp;format=html">ssh(1)</a> funciona de manera similar a <a href="https://man.freebsd.org/cgi/man.cgi?query=rlogin&amp;sektion=1&amp;format=html">rlogin(1)</a>.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ssh user@example.com</span>
Host key not found from the list of known hosts.
Are you sure you want to <span class=k>continue </span>connecting <span class=o>(</span><span class=nb>yes</span>/no<span class=o>)</span>? <span class=nb>yes
</span>Host <span class=s1>&#39;ejemplo.com&#39;</span> added to the list of known hosts.
usuario@ejemplo.com<span class=s1>&#39;s password: *******</span></code></pre></div></div><div class=paragraph><p>El login continuará como lo haría si fuera una sesión de <code>rlogin</code> o <code>telnet</code>. SSH utiliza un sistema de huellas de llaves para verificar la autenticidad del servidor cuando el cliente se conecta. Se le pide al usuario que introduzca <code>yes</code> solamente la primera vez que se conecta. Todos los intentos futuros de login se verifican contra la huella de la llave guardada la primera vez. El cliente SSH le alertará si la huella guardada difiere de la huella recibida en futuros intentos de acceso al sistema. Las huellas se guardan en <span class=filename>~/.ssh/known_hosts</span>, y en <span class=filename>~/.ssh/known_hosts2</span> las huellas SSH v2.</p></div><div class=paragraph><p>Por defecto las versiones recientes de los servidores OpenSSH solamente aceptan conexiones SSH v2. El cliente utilizará la versión 2 si es posible y pasará como respaldo a la versión 1. El cliente puede también ser obligado a utilizar una u otra pasándole <code>-1</code> o <code>-2</code>, respectivamente para la versión 1 y la versión 2. Se mantiene la compatibilidad del cliente con la versión 1 para mantener la compatibilidad con versiones antiguas.</p></div></div><div class=sect3><h4 id=_copia_segura>14.11.4. Copia segura<a class=anchor href=#_copia_segura></a></h4><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=scp&amp;sektion=1&amp;format=html">scp(1)</a> funciona de manera muy similar a <a href="https://man.freebsd.org/cgi/man.cgi?query=rcp&amp;sektion=1&amp;format=html">rcp(1)</a>; copia un fichero desde o hacia un sistema remoto, con la diferencia de que lo hace de una forma segura.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c>#  scp usuario@ejemplo.com:/COPYRIGHT COPYRIGHT</span>
usuario@ejemplo.com<span class=s1>&#39;s password: *******
COPYRIGHT            100% |*****************************|  4735
00:00
#</span></code></pre></div></div><div class=paragraph><p>Ya que la huella se guardó en este equipo durante el ejemplo anterior se verifica ahora al utilizar <a href="https://man.freebsd.org/cgi/man.cgi?query=scp&amp;sektion=1&amp;format=html">scp(1)</a>.</p></div><div class=paragraph><p>Los argumentos de <a href="https://man.freebsd.org/cgi/man.cgi?query=scp&amp;sektion=1&amp;format=html">scp(1)</a> son similares a <a href="https://man.freebsd.org/cgi/man.cgi?query=cp&amp;sektion=1&amp;format=html">cp(1)</a>, con el fichero o ficheros como primer argumento, y el destino como segundo. Ya que el fichero se transfiere a través de la red, a través de SSH, uno o más argumentos tienen la estructura <code>user@host:&lt;ruta_al_fichero_remoto></code>.</p></div></div><div class=sect3><h4 id=_configuración>14.11.5. Configuración<a class=anchor href=#_configuración></a></h4><div class=paragraph><p>Los ficheros de configuración del sistema tanto para el dæmon OpenSSH como para el cliente están en <span class=filename>/etc/ssh</span>.</p></div><div class=paragraph><p><span class=filename>ssh_config</span> contiene las opciones del cliente, mientras que <span class=filename>sshd_config</span> configura el dæmon.</p></div><div class=paragraph><p>Además las opciones <code>sshd_program</code> (<span class=filename>/usr/sbin/sshd</span> por defecto), y <code>sshd_flags</code> de <span class=filename>rc.conf</span> ofrecer más niveles de configuración.</p></div></div><div class=sect3><h4 id=security-ssh-keygen>14.11.6. ssh-keygen<a class=anchor href=#security-ssh-keygen></a></h4><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-keygen&amp;sektion=1&amp;format=html">ssh-keygen(1)</a> le permite validar a un usuario sin pedirle la contraseña:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ssh-keygen <span class=nt>-t</span> dsa
Generating public/private dsa key pair.
Enter file <span class=k>in </span>which to save the key <span class=o>(</span>/home/user/.ssh/id_dsa<span class=o>)</span>:
Created directory <span class=s1>&#39;/home/user/.ssh&#39;</span><span class=nb>.</span>
Enter passphrase <span class=o>(</span>empty <span class=k>for </span>no passphrase<span class=o>)</span>:
Enter same passphrase again:
Your identification has been saved <span class=k>in</span> /home/user/.ssh/id_dsa.
Your public key has been saved <span class=k>in</span> /home/user/.ssh/id_dsa.pub.
The key fingerprint is:
bb:48:db:f2:93:57:80:b6:aa:bc:f5:d5:ba:8f:79:17 usuario@host.ejemplo.com</code></pre></div></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-keygen&amp;sektion=1&amp;format=html">ssh-keygen(1)</a> creará un par de llaves pública y privada para usar en la validación. La llave privada se guarda en <span class=filename>~/.ssh/id_dsa</span> o en <span class=filename>~/.ssh/id_rsa</span>, mientras que la llave pública se guarda en <span class=filename>~/.ssh/id_dsa.pub</span> o en <span class=filename>~/.ssh/id_rsa.pub</span>, respectivamente para llaves DSA y RSA. La llave pública debe guardarse en el <span class=filename>~/.ssh/authorized_keys</span> de la máquina remota para que la configuración funcione. Las llaves RSA versión 1 deben guardarse en <span class=filename>~/.ssh/authorized_keys</span>.</p></div><div class=paragraph><p>De este modo permitirá conexiones a la máquina remota mediante llaves SSH en lugar de contraseñas.</p></div><div class=paragraph><p>Si usa una contraseña al ejecutar <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-keygen&amp;sektion=1&amp;format=html">ssh-keygen(1)</a>, se le pedirá al usuario una contraseña cada vez que quiera utilizar la llave privada. <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-agent&amp;sektion=1&amp;format=html">ssh-agent(1)</a> puede evitar la molestia de introducir repetidamente frases largas. esto se explica má adelante, en la <a href=#security-ssh-agent>ssh-agent y ssh-add</a>.</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Las opciones y ficheros pueden ser diferentes según la versión de OpenSSH que tenga en su sistema; para evitar problemas consulte la página de manual <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-keygen&amp;sektion=1&amp;format=html">ssh-keygen(1)</a>.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=security-ssh-agent>14.11.7. ssh-agent y ssh-add<a class=anchor href=#security-ssh-agent></a></h4><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-agent&amp;sektion=1&amp;format=html">ssh-agent(1)</a> y <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-add&amp;sektion=1&amp;format=html">ssh-add(1)</a> ofrecen métodos para que las llaves SSH se puedan cargar en memoria, permitiendo eliminar la necesidad de teclear la contraseña cada vez que haga falta.</p></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-agent&amp;sektion=1&amp;format=html">ssh-agent(1)</a> gestionará la validación utilizando la llave (o llaves) privada que le cargue. <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-agent&amp;sektion=1&amp;format=html">ssh-agent(1)</a> se usa para lanzar otras aplicaciones. En el nivel más básico puede generar una shell o a un nivel más avanzado un gestor de ventanas.</p></div><div class=paragraph><p>Para usar <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-agent&amp;sektion=1&amp;format=html">ssh-agent(1)</a> en una shell necesitará primero ser invocado como argumento por una shell. Segundo, añada la identidad ejecutando <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-add&amp;sektion=1&amp;format=html">ssh-add(1)</a> y facilitando la contraseña de la llave privada. Completados estos pasos el usuario puede hacer <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh&amp;sektion=1&amp;format=html">ssh(1)</a> a cualquier equipo que tenga instalada la llave pública correspondiente. Por ejemplo:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ssh-agent csh
% ssh-add
Enter passphrase <span class=k>for</span> /home/user/.ssh/id_dsa:
Identity added: /home/user/.ssh/id_dsa <span class=o>(</span>/home/user/.ssh/id_dsa<span class=o>)</span>
%</code></pre></div></div><div class=paragraph><p>Para utilizar <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-agent&amp;sektion=1&amp;format=html">ssh-agent(1)</a> en X11 tendrá que incluir una llamada a <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-agent&amp;sektion=1&amp;format=html">ssh-agent(1)</a> en <span class=filename>~/.xinitrc</span>. De este modo ofrecerá los servicios de <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-agent&amp;sektion=1&amp;format=html">ssh-agent(1)</a> a todos los programas lanzados en X11. Veamos un ejemplo de <span class=filename>~/.xinitrc</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>exec ssh-agent startxfce4</pre></div></div><div class=paragraph><p>Esto lanzaría <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-agent&amp;sektion=1&amp;format=html">ssh-agent(1)</a>, que a su vez lanzaría XFCE cada vez que inicie X11. Hecho esto y una vez reiniciado X11 para aplicar los cambios puede ejecutar <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-add&amp;sektion=1&amp;format=html">ssh-add(1)</a> para cargar todas sus llaves SSH.</p></div></div><div class=sect3><h4 id=security-ssh-tunneling>14.11.8. Túneles SSH<a class=anchor href=#security-ssh-tunneling></a></h4><div class=paragraph><p>OpenSSH permite crear un túnel en el que encapsular otro protocolo en una sesión cifrada.</p></div><div class=paragraph><p>La siguiente orden le dice a <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh&amp;sektion=1&amp;format=html">ssh(1)</a> que cree un túnel para telnet:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ssh <span class=nt>-2</span> <span class=nt>-N</span> <span class=nt>-f</span> <span class=nt>-L</span> 5023:localhost:23 usuario@foo.ejemplo.com
%</code></pre></div></div><div class=paragraph><p>Veamos las opciones que se le han suministrado a <code>ssh</code>:</p></div><div class=dlist><dl><dt class=hdlist1><code>-2</code></dt><dd><p>Obliga a <code>ssh</code> a utilizar la versión 2 del protocolo. (No la use si está trabajando con servidores SSH antiguos)</p></dd><dt class=hdlist1><code>-N</code></dt><dd><p>Indica que no se ejecutará una orden remota, o solamente túnel. Si se omite, <code>ssh</code> iniciaría una sesión normal.</p></dd><dt class=hdlist1><code>-f</code></dt><dd><p>Obliga a <code>ssh</code> a ejecutarse en segundo plano.</p></dd><dt class=hdlist1><code>-L</code></dt><dd><p>Indica un túnel local según el esquema <em>puerto local:equipo remoto:puerto remoto</em>.</p></dd><dt class=hdlist1><code>usuario@foo.ejemplo.com</code></dt><dd><p>El servidor SSH remoto.</p></dd></dl></div><div class=paragraph><p>Un túnel SSH crea un socket que escucha en <code>localhost</code> en el puerto especificado. Luego reenvía cualquier conexión recibida en el puerto/equipo local vía la conexión SSH al puerto o equipo remoto especificado.</p></div><div class=paragraph><p>En el ejemplo el puerto <em>5023</em> en <code>localhost</code> se reenvía al puerto <em>23</em> del <code>localhost</code> de la máquina remota. Ya que <em>23</em> es telnet, esto crearía una sesión telnet segura a través de un túnel SSH.</p></div><div class=paragraph><p>Puede usar esto para encapsular cualquier otro protocolo TCP inseguro como SMTP, POP3, FTP, etc.</p></div><div class=exampleblock><div class=title>Ejemplo 19. Uso de SSH para crear un túnel seguro para SMTP</div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ssh <span class=nt>-2</span> <span class=nt>-N</span> <span class=nt>-f</span> <span class=nt>-L</span> 5025:localhost:25 usuario@correo.ejemplo.com
usuario@correo.ejemplo.com<span class=s1>&#39;s password: *****
% telnet localhost 5025
Trying 127.0.0.1...
Connected to localhost.
Escape character is &#39;</span>^]<span class=s1>&#39;.
220 correo.ejemplo.com ESMTP</span></code></pre></div></div><div class=paragraph><p>Puede usar esta técnica junto con <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-keygen&amp;sektion=1&amp;format=html">ssh-keygen(1)</a> y cuentas adicionales de usuario para crear un entorno más transparente, esto es, más cómodo. Puede usar llaves en lugar de teclear contraseñas y puede ejecutar los túneles de varios usuarios.</p></div></div></div><div class=sect4><h5 id=_ejemplos_prácticos_de_túneles_ssh>14.11.8.1. Ejemplos prácticos de túneles SSH<a class=anchor href=#_ejemplos_prácticos_de_túneles_ssh></a></h5><div class=sect5><h6 id=_acceso_seguro_a_un_servidor_pop3>14.11.8.1.1. Acceso seguro a un servidor POP3<a class=anchor href=#_acceso_seguro_a_un_servidor_pop3></a></h6><div class=paragraph><p>En el trabajo hay un servidor SSH que acepta conexiones desde el exterior. En la misma red de la oficina reside un servidor de correo que ejecuta un servidor POP3. La red, o ruta de red entre su casa y oficina puede o no ser completamente de fiar. Debido a esto necesita revisar su correo electrónico de forma segura. La solución es crear una conexión SSH al servidor SSH de su oficina y llegar por un túnel al servidor de correo.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ssh <span class=nt>-2</span> <span class=nt>-N</span> <span class=nt>-f</span> <span class=nt>-L</span> 2110:correo.ejemplo.com:110 usuario@servidor-ssh.ejemplo.com
usuario@servidor-ssh.ejemplo.com<span class=s1>&#39;s password: ******</span></code></pre></div></div><div class=paragraph><p>cuando el túnel esté funcionando haga que su cliente de correo envíe peticiones POP3 a <code>localhost</code> en el puerto 2110. La conexión será reenviada de forma totalmente segura a traveés del túnel a <code>correo.ejemplo.com</code>.</p></div></div><div class=sect5><h6 id=_saltarse_un_cortafuegos_draconiano>14.11.8.1.2. Saltarse un cortafuegos draconiano<a class=anchor href=#_saltarse_un_cortafuegos_draconiano></a></h6><div class=paragraph><p>Algunos administradores de red imponen reglas de cortafuegos extremadamente draconianas, filtrando no solo las conexiones entrantes, sino también las salientes. Tal vez solo se le otorgue acceso a máquinas remotas a través de los puertos 22 y 80 para ssh y navegar en web.</p></div><div class=paragraph><p>Tal vez quiera acceder a otros servicios (que tal vez ni siquiera estén relacionados con el trabajo), como un servidor Ogg Vorbis para escuchar música. Si ese servidor Ogg Vorbis transmite en un puerto que no sea el 22 o el 80 no podrá tener acceso a él.</p></div><div class=paragraph><p>La solución es crear una conexión SSH fuera del cortafuegos de su red y utilizarla para hacer un túnel al servidor Ogg Vorbis.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ssh <span class=nt>-2</span> <span class=nt>-N</span> <span class=nt>-f</span> <span class=nt>-L</span> 8888:musica.ejemplo.com:8000 usuario@sistema-no-filtrado.ejemplo.org
usuario@sistema-no-filtrado.ejemplo.org<span class=s1>&#39;s password: *******</span></code></pre></div></div><div class=paragraph><p>Haga que el programa con el que suele escuchar música haga peticiones a <code>localhost</code> puerto 8888, que será reenviado a <code>musica.ejemplo.com</code> puerto 8000, evadiendo con éxito el cortafuegos.</p></div></div></div></div><div class=sect3><h4 id=_la_opción_de_usuarios_allowusers>14.11.9. La opción de usuarios <code>AllowUsers</code><a class=anchor href=#_la_opción_de_usuarios_allowusers></a></h4><div class=paragraph><p>Limitar qué usuarios pueden entrar y desde dónde suele ser razonable. La opción <code>AllowUsers</code> le permite configurarlo, por ejemplo, para permitir entrar solamente al usuario <code>root</code> desde <code>192.168.1.32</code>. Puede hacerlo con algo parecido a esto en <span class=filename>/etc/ssh/sshd_config</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>AllowUsers root@192.168.1.32</pre></div></div><div class=paragraph><p>Para permitir al usuario <code>admin</code> la entrada desde cualquier lugar, solamente introduzca el nombre de usuario:</p></div><div class="literalblock programlisting"><div class=content><pre>AllowUsers admin</pre></div></div><div class=paragraph><p>Puede listar múltiples usuarios en la misma línea:</p></div><div class="literalblock programlisting"><div class=content><pre>AllowUsers root@192.168.1.32 admin</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Es importante que incluya a cada usuario que necesite entrar a esta máquina o no podrán entrar.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Después de hacer los cambios a b <span class=filename>/etc/ssh/sshd_config</span> debe decirle a <a href="https://man.freebsd.org/cgi/man.cgi?query=sshd&amp;sektion=8&amp;format=html">sshd(8)</a> que cargue de nuevo sus ficheros de configuración ejecutando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /etc/rc.d/sshd reload</span></code></pre></div></div></div><div class=sect3><h4 id=_lecturas_complementarias>14.11.10. Lecturas complementarias<a class=anchor href=#_lecturas_complementarias></a></h4><div class=paragraph><p><a href=http://www.openssh.com/>OpenSSH</a></p></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=ssh&amp;sektion=1&amp;format=html">ssh(1)</a> <a href="https://man.freebsd.org/cgi/man.cgi?query=scp&amp;sektion=1&amp;format=html">scp(1)</a> <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-keygen&amp;sektion=1&amp;format=html">ssh-keygen(1)</a> <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-agent&amp;sektion=1&amp;format=html">ssh-agent(1)</a> <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-add&amp;sektion=1&amp;format=html">ssh-add(1)</a> <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh_config&amp;sektion=5&amp;format=html">ssh_config(5)</a></p></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=sshd&amp;sektion=8&amp;format=html">sshd(8)</a> <a href="https://man.freebsd.org/cgi/man.cgi?query=sftp-server&amp;sektion=8&amp;format=html">sftp-server(8)</a> <a href="https://man.freebsd.org/cgi/man.cgi?query=sshd_config&amp;sektion=5&amp;format=html">sshd_config(5)</a></p></div></div></div><div class=sect2><h3 id=fs-acl>14.12. Listas de control de acceso a sistemas de ficheros<a class=anchor href=#fs-acl></a></h3><div class=paragraph><p>Además de otras mejoras del sistema de ficheros como las instantáneas ("snapshots"), FreeBSD 5.0 y siguientes ofrecen las ACL ("Access Control Lists", listas de control de acceso) como un elemento más de seguridad.</p></div><div class=paragraph><p>Las listas de control de acceso extienden el modelo de permisos estándar de UNIX® de una manera altamente compatible (POSIX®.1e). Esta opción permite al administrador usar con gran provecho un modelo de seguridad más sofisticado.</p></div><div class=paragraph><p>Para habilitar soporte de ACL en sistemas de ficheros UFS la siguiente opción:</p></div><div class="literalblock programlisting"><div class=content><pre>options UFS_ACL</pre></div></div><div class=paragraph><p>debe ser compilada en el kernel. Si esta opción no ha sido compilada, se mostrará un mensaje de advertencia si se intenta montar un sistema de ficheros que soporte ACL. Esta opción viene incluida en el kernel <span class=filename>GENERIC</span>. Las ACL dependen de los atributos extendidos habilitados en el sistema de ficheros. Los atributos extendidos están incluidos por defecto en la nueva generación de sistemas de ficheros UNIX® UFS2.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Los atributos extendidos pueden usarse también en UFS1 pero requieren una carga de trabajo mucho más elevada que en UFS2. El rendimiento de los atributos extendidos es, también, notablemente mayor en UFS2. Por todo esto si quiere usar ACL le recomendamos encarecidamente que use UFS2.</p></div></td></tr></tbody></table></div><div class=paragraph><p>LasACL se habilitadan mediante una bandera administrativa durante el montaje, <code>acls</code>, en el fichero <span class=filename>/etc/fstab</span>. La bandera de montaje puede también activarse de forma permanente mediante <a href="https://man.freebsd.org/cgi/man.cgi?query=tunefs&amp;sektion=8&amp;format=html">tunefs(8)</a> para modificar una bandera de superbloque ACLs en la cabecera del sistema de ficheros. En general es preferible usar la bandera de superbloque por varios motivos:</p></div><div class=ulist><ul><li><p>La bandera de montaje ACL no puede cambiarse por un remontaje (<a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a> <code>-u</code>), sino con un completo <a href="https://man.freebsd.org/cgi/man.cgi?query=umount&amp;sektion=8&amp;format=html">umount(8)</a> y un <a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a>. Esto significa que no se pueden habilitar las ACL en el sistema de ficheros raíz después del arranque. También significa que no se puede cambiar la disposición de un de ficheros una vez que se ha comenzado a usar.</p></li><li><p>Activar la bandera de superbloque provocará que el sistema de ficheros se monte siempre con las ACL habilitadas incluso si no existe una entrada en <span class=filename>fstab</span> o si los dispositivos se reordenan. Esto es así para prevenir un montaje accidental del sistema de ficheros sin tener las ACL habilitadas, que podría resultar en que se impongan de forma inadecuada las ACL, y en consecuencia problema de seguridad.</p></li></ul></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Podemos cambiar el comportamiento de las ACL para permitirle a la bandera ser habilitada sin un <a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a> completo, pero puede salirle el tiro por la culata si activa las ACL, luego las desactiva, y después las vuelve a activar sin configurar desde cero las atributos extendidos. En general, una vez que se han deshabilitado las ACL en un sistema de ficheros no deben dehabilitarse, ya que la protección de ficheros resultante puede no ser compatible las que esperan los usuarios del sistema, y al volver a activar las ACL volver a asignar las ACL a ficheros cuyos permisos hubieran sido cambiados, lo que puede desenbocar en un escenario impredecible.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Los sistemas de ficheros con ACL habilitadas tienen un signo <code>+</code> (más) al visualizar sus configuraciones de permisos. Por ejemplo:</p></div><div class="literalblock programlisting"><div class=content><pre>drwx------  2 robert  robert  512 Dec 27 11:54 private
drwxrwx---+ 2 robert  robert  512 Dec 23 10:57 directorio1
drwxrwx---+ 2 robert  robert  512 Dec 22 10:20 directorio2
drwxrwx---+ 2 robert  robert  512 Dec 27 11:57 directorio3
drwxr-xr-x  2 robert  robert  512 Nov 10 11:54 public_html</pre></div></div><div class=paragraph><p>Aquí vemos que los directorios <span class=filename>directorio1</span>, <span class=filename>directorio2</span>, y <span class=filename>directorio3</span> están usando ACL. El directorio <span class=filename>public_html</span> no.</p></div><div class=sect3><h4 id=_uso_de_acl>14.12.1. Uso de ACL<a class=anchor href=#_uso_de_acl></a></h4><div class=paragraph><p>Las ACLs del sistema de ficheros pueden comprobarse con <a href="https://man.freebsd.org/cgi/man.cgi?query=getfacl&amp;sektion=1&amp;format=html">getfacl(1)</a>. Por ejemplo, para ver las configuraciones de ACL del fichero <span class=filename>test</span>, uno podría usar lo siguiente:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% getfacl <span class=nb>test</span>
	<span class=c>#file:test</span>
	<span class=c>#owner:1001</span>
	<span class=c>#group:1001</span>
	user::rw-
	group::r--
	other::r--</code></pre></div></div><div class=paragraph><p>Para cambiar las configuraciones de las ACL en este fichero use <a href="https://man.freebsd.org/cgi/man.cgi?query=setfacl&amp;sektion=1&amp;format=html">setfacl(1)</a>. Observe:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% setfacl <span class=nt>-k</span> <span class=nb>test</span></code></pre></div></div><div class=paragraph><p>La bandera <code>-k</code> eliminará todas las ACLs definidas para un fichero o sistema ficheros. El método preferible sería utilizar <code>-b</code>, ya que deja los campos básicos imprescindibles para que las ACL sigan funcionando.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% setfacl <span class=nt>-m</span> u:trhodes:rwx,group:web:r--,o::--- <span class=nb>test</span></code></pre></div></div><div class=paragraph><p>La opción <code>-m</code> se usa para modificar las entradas por defecto de las ACL. Debido a que no había entradas predefinidas puesto que fueron eliminadas por la orden anterior, restauraremos las opciones por defecto y asignará las opciones listadas. Tenga en cuenta que si añade un nuevo usuario o grupo aparecerá el error <code>Invalid argument</code> en la salida estándar <span class=filename>stdout</span>.</p></div></div></div><div class=sect2><h3 id=security-portaudit>14.13. Monitorización de fallos de seguridad de aplicaciones<a class=anchor href=#security-portaudit></a></h3><div class=paragraph><p>En estos últimos años el mundo de la seguridad ha hecho grandes avances en cuanto a la gestión de las vulnerabilidades. La amenaza de asaltos a los sistemas se incrementa cuando se instalan y configuran aplicaciones de muy diversas procedencias en virtualmente cualquier sistema operativo disponible.</p></div><div class=paragraph><p>La evaluación de vulnerabilidades es un factor clave en la seguridad; aunque FreeBSD libere avisos de seguridad relacionados con el sistema base, llevar la gestión de vulnerabilidades hasta cada aplicación que se puede instalar en FreeBSD va mucho más allá de la capacidad del proyecto FreeBSD. A pesar de esto existe una forma de mitigar las vulnerabilidades de esas aplicaciones y advertir a los administradores sobre los problemas de seguridad a medida que se detectan. Portaudit existe para hacer ese trabajo.</p></div><div class=paragraph><p>El port <a class=package href=https://cgit.freebsd.org/ports/tree/security/portaudit/>security/portaudit</a> consulta una base de datos, actualizada y mantenida por el equipo de seguridad y por los desarrolladores de FreeBSD en busca de incidentes de seguridad que hayan sido detectados.</p></div><div class=paragraph><p>Si quiere usar Portaudit instálelo desde la colección de ports:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/security/portaudit &amp;&amp; make install clean</span></code></pre></div></div><div class=paragraph><p>Durante el proceso de instalación los ficheros de configuración de <a href="https://man.freebsd.org/cgi/man.cgi?query=periodic&amp;sektion=8&amp;format=html">periodic(8)</a> se actualizan haciendo que Portaudit aparezca en el mensaje sobre la seguridad del sistema que diariamente Recuerde que ese correo (que se envia a la cuenta <code>root</code> es muy importante y debería leerlo. No hay ninguna configuración que deba modificar o crear.</p></div><div class=paragraph><p>Después de la instalación un administrador debe actualizar la base de datos alojada en local en <span class=filename>/var/db/portaudit</span> mediante:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portaudit -F</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>La base de datos será actualizada automáticamente durante la ejecución de <a href="https://man.freebsd.org/cgi/man.cgi?query=periodic&amp;sektion=8&amp;format=html">periodic(8)</a>; así que la orden anterior es totalmente opcional. Solo se necesita para los siguientes ejemplos.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Si quiere comproblar si entre las aplicaciones que haya instalado desde el árbol de ports en su sistema hay problemas de seguridad sólo tiene que ejecutar lo siguiente:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># portaudit -a</span></code></pre></div></div><div class=paragraph><p>Este es un ejemplo de la salida:</p></div><div class="literalblock programlisting"><div class=content><pre>Affected package: cups-base-1.1.22.0_1
Type of problem: cups-base -- HPGL buffer overflow vulnerability.
Reference: &lt;http://www.FreeBSD.org/ports/portaudit/40a3bca2-6809-11d9-a9e7-0001020eed82.html&gt;

1 problem(s) in your installed packages found.

You are advised to update or deinstall the affected package(s) immediately.</pre></div></div><div class=paragraph><p>El administrador del sistema obtendrá mucha más información sobre el problema de seguridad dirigiendo su navegador web a la URL que aparece en el mensaje. Esto incluye versiones afectadas (por versión de port de FreeBSD), junto con otros sitios web que contengan advertencias de seguridad.</p></div><div class=paragraph><p>En pocas palabras, Portaudit es un programa muy poderoso y extremadamente útil cuando se combina con el port Portupgrade.</p></div></div><div class=sect2><h3 id=security-advisories>14.14. FreeBSD Security Advisories<a class=anchor href=#security-advisories></a></h3><div class=paragraph><p>Como muchos sistemas operativos con calidad de producción, FreeBSD publica "Security Advisories" (advertencias de seguridad. Estas advertencias suelen enviarse por correo a las listas de seguridad e incluidas en la Errata solamente después de que la versión apropiada haya sido corregida. Esta sección tiene como fin explicar en qué consiste una advertencia de seguridad, cómo entenderla y qué medidas hay que tomar para parchear el sistema.</p></div><div class=sect3><h4 id=_qué_aspecto_tiene_una_advertencia_de_seguridad>14.14.1. ?Qué aspecto tiene una advertencia de seguridad?<a class=anchor href=#_qué_aspecto_tiene_una_advertencia_de_seguridad></a></h4><div class=paragraph><p>Las advertencias de seguridad de FreeBSD tienen un aspecto similar a la que se muestra aquí. Fué enviada a la lista de correo <a href=https://lists.FreeBSD.org/subscription/freebsd-security-notifications>Lista de correo para anuncios de seguridad que afectan a FreeBSD</a>.</p></div><div class="literalblock programlisting"><div class=content><pre>=============================================================================
FreeBSD-SA-XX:XX.UTIL                                     Security Advisory
                                                          The FreeBSD Project

Topic:          denial of service due to some problem <i class=conum data-value=1></i><b>(1)</b>

Category:       core <i class=conum data-value=2></i><b>(2)</b>
Module:         sys <i class=conum data-value=3></i><b>(3)</b>
Announced:      2003-09-23 <i class=conum data-value=4></i><b>(4)</b>
Credits:        Person@EMAIL-ADDRESS <i class=conum data-value=5></i><b>(5)</b>
Affects:        All releases of FreeBSD <i class=conum data-value=6></i><b>(6)</b>
                FreeBSD 4-STABLE prior to the correction date
Corrected:      2003-09-23 16:42:59 UTC (RELENG_4, 4.9-PRERELEASE)
                2003-09-23 20:08:42 UTC (RELENG_5_1, 5.1-RELEASE-p6)
                2003-09-23 20:07:06 UTC (RELENG_5_0, 5.0-RELEASE-p15)
                2003-09-23 16:44:58 UTC (RELENG_4_8, 4.8-RELEASE-p8)
                2003-09-23 16:47:34 UTC (RELENG_4_7, 4.7-RELEASE-p18)
                2003-09-23 16:49:46 UTC (RELENG_4_6, 4.6-RELEASE-p21)
                2003-09-23 16:51:24 UTC (RELENG_4_5, 4.5-RELEASE-p33)
                2003-09-23 16:52:45 UTC (RELENG_4_4, 4.4-RELEASE-p43)
                2003-09-23 16:54:39 UTC (RELENG_4_3, 4.3-RELEASE-p39) <i class=conum data-value=7></i><b>(7)</b>
FreeBSD only:   NO <i class=conum data-value=8></i><b>(8)</b>

For general information regarding FreeBSD Security Advisories,
including descriptions of the fields above, security branches, and the
following sections, please visit
http://www.FreeBSD.org/security/.

I.   Background <i class=conum data-value=9></i><b>(9)</b>

II.  Problem Description <i class=conum data-value=10></i><b>(10)</b>

III. Impact <i class=conum data-value=11></i><b>(11)</b>

IV.  Workaround <i class=conum data-value=12></i><b>(12)</b>

V.   Solution <i class=conum data-value=13></i><b>(13)</b>

VI.  Correction details <i class=conum data-value=14></i><b>(14)</b>

VII. References <i class=conum data-value=15></i><b>(15)</b></pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>El campo <code>Topic</code> indica cuál es exactamente el problema. Básicamente es la introducción de la advertencia de seguridad actual e indica el uso malintencionado que puede darse a la vulnerabilidad.</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td><code>Category</code> se refiere a la parte afectada del sistema, que puede ser <code>core</code>, <code>contrib</code> o <code>ports</code>. La categoría <code>core</code> significa que la vulnerabilidad afecta a un componente central del sistema operativo FreeBSD. La categoría <code>contrib</code> significa que la vulnerabilidad afecta a software que no ha sido desarrollado por el proyecto FreeBSD, como sendmail. La categoría <code>ports</code> indica que la vulnerabilidad afecta a software incluido en la colección de ports.</td></tr><tr><td><i class=conum data-value=3></i><b>3</b></td><td>El campo <code>Module</code> se refiere a la ubicación del componente, por ejemplo <code>sys</code>. En este ejemplo vemos que está afectado el módulo <code>sys</code>; por lo tanto esta vulnerabilidad afecta a componentes utilizados dentro del kernel.</td></tr><tr><td><i class=conum data-value=4></i><b>4</b></td><td>El campo <code>Announced</code> refleja la fecha de publicación de la advertencia de seguridad fué publicada o anunciada al mundo. Esto significa que el equipo de seguridad ha verificado que el que el problema existe y que se ha incluido un parche que soluciona el problema en el repositorio de código fuente de FreeBSD.</td></tr><tr><td><i class=conum data-value=5></i><b>5</b></td><td>El campo <code>Credits</code> le da el crédito al individuo u organización que descubrió y reportó la vulnerabilidad.</td></tr><tr><td><i class=conum data-value=6></i><b>6</b></td><td>El campo <code>Affects</code> explica a qué versiones de FreeBSD afecta esta vulnerabilidad. En el caso del kernel una rápida revisión de la salida de <code>ident</code> en los
ficheros afectados ayudará a determinar la versión. En el caso de de los ports el número de versión aparece después del nombre del port en <span class=filename>/var/db/pkg</span>. Si el sistema no se sincroniza con el repositorio CVS de FreeBSD y se reconstruye diariamente, existe la posibilidad de que esté afectado por el problema de seguridad.</td></tr><tr><td><i class=conum data-value=7></i><b>7</b></td><td>El campo <code>Corrected</code> indica la fecha, hora, zona horaria y versión de FreeBSD en que fué corregido.</td></tr><tr><td><i class=conum data-value=8></i><b>8</b></td><td>El campo <code>FreeBSD only</code> indica si la vulnerabilidad afecta solamente a FreeBSD o si afecta también a otros sistemas operativos.</td></tr><tr><td><i class=conum data-value=9></i><b>9</b></td><td>El campo <code>Background</code> informa acerca de qué es exactamente la aplicación afectada. La mayor parte de las veces se refiere a por qué la aplicación existe en
FreeBSD, para qué se usa y un poco de información de cómo llegó llegó a ocupar el lugar que ocupa en el sistema o el árbol de ports.</td></tr><tr><td><i class=conum data-value=10></i><b>10</b></td><td>El campo <code>Problem Description</code> explica el problema de seguridad en profundidad. Puede incluir información del código erróneo, o incluso cómo puede usarse maliciosamente el error para abrir un agujero de seguridad.</td></tr><tr><td><i class=conum data-value=11></i><b>11</b></td><td>El campo <code>Impact</code> describe el tipo de impacto que el problema pueda tener en un sistema. Por ejemplo, esto puede ser desde un ataque de denegación de servicio, hasta una escalada de privilegios de usuario, o incluso ofrecer al atacante acceso de superusuario.</td></tr><tr><td><i class=conum data-value=12></i><b>12</b></td><td>El campo <code>Workaround</code> ofrece una solución temoral posible para los administradores de sistemas que tal vez no puedan actualizar el sistema. Esto puede deberse a la falta de tiempo, disponibilidad de de red, o a muchas otras razones. A pesar de todo la la seguridad no se debe tomar a la ligera y un sistema afectado debe parchearse al menos aplicar una solución temporal para el agujero de seguridad.</td></tr><tr><td><i class=conum data-value=13></i><b>13</b></td><td>El campo <code>Solution</code> ofrece instrucciones para parchear el sistema afectado. Este es un método paso a paso, probado y verificado para parchear un sistema y que trabaje seguro.</td></tr><tr><td><i class=conum data-value=14></i><b>14</b></td><td>El campo <code>Correction Details</code> despliega la rama del CVS o el nombre de la versión con los puntos cambiados a guiones bajos. También muestra el número de revisión de los ficheros afectados dentro de cada rama.</td></tr><tr><td><i class=conum data-value=15></i><b>15</b></td><td>El campo <code>References</code> suele ofrecer fuentes adicionales de información: URL, libros, listas de correo y grupos de noticias.</td></tr></tbody></table></div></div></div><div class=sect2><h3 id=security-accounting>14.15. Contabilidad de procesos<a class=anchor href=#security-accounting></a></h3><div class=paragraph><p>La contabilidad de procesos es un método de seguridad en el cual un administrador puede mantener un seguimiento de los recursos del sistema utilizados, su distribución entre los usuarios, ofrecer monitorización del sistema y seguir la pista mínimamente a las órdenes de usuario.</p></div><div class=paragraph><p>Esto en realidad tiene sus puntos positivos y negativos. Uno de los positivos es que una intrusión puede minimizarse en el momento de producirse. Uno negativo es la cantidad de logs generados por la contabilidad de procesos y el espacio de disco que requieren. Esta sección guiará al administrador a través de los fundamentos de la contabilidad de procesos.</p></div><div class=sect3><h4 id=_cómo_habilitar_y_utilizar_la_contabilidad_de_procesos>14.15.1. Cómo habilitar y utilizar la contabilidad de procesos<a class=anchor href=#_cómo_habilitar_y_utilizar_la_contabilidad_de_procesos></a></h4><div class=paragraph><p>Antes de poder usar la contabilidad de procesos tendrá que habilitarla. Ejecute la siguiente orden:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># touch /var/account/acct</span>

<span class=c># accton /var/account/acct</span>

<span class=c># echo &#39;accounting_enable=&#34;YES&#34;&#39; &gt;&gt; /etc/rc.conf</span></code></pre></div></div><div class=paragraph><p>Una vez habilitada, la contabilidad de procesos empezará a seguir el rastro de estadísticas de la CPU, órdenes, etc. Todos los logs de contabilidad están en un formato ilegible para humanos, pero accesibles para <a href="https://man.freebsd.org/cgi/man.cgi?query=sa&amp;sektion=8&amp;format=html">sa(8)</a>. Si se ejecuta sin opciones, <code>sa</code> imprimirá información sobre el número de llamadas por usuario, el tiempo total transcurrido expresado en minutos, el tiempo total de CPU y de usuario en minutos, el número medio de operaciones de E/S, etc.</p></div><div class=paragraph><p>Para ver información acerca de las órdenes que se están ejecutados puede usar la <a href="https://man.freebsd.org/cgi/man.cgi?query=lastcomm&amp;sektion=1&amp;format=html">lastcomm(1)</a>. <code>lastcomm</code> imprime órdenes ejecutadas por los usuarios en <a href="https://man.freebsd.org/cgi/man.cgi?query=ttys&amp;sektion=5&amp;format=html">ttys(5)</a> específicas. Veamos un ejemplo:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># lastcomm ls</span>
	trhodes ttyp1</code></pre></div></div><div class=paragraph><p>Imprimiría todas las veces (conocidas) que el usuario <code>trhodes</code> ha usado <code>ls</code> en la terminal ttyp1.</p></div><div class=paragraph><p>Hay muchas más opciones que pueden serle muy útiles. Si quiere conocerlas consulte las páginas de manual <a href="https://man.freebsd.org/cgi/man.cgi?query=lastcomm&amp;sektion=1&amp;format=html">lastcomm(1)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=acct&amp;sektion=5&amp;format=html">acct(5)</a> y <a href="https://man.freebsd.org/cgi/man.cgi?query=sa&amp;sektion=8&amp;format=html">sa(8)</a>.</p></div></div></div></div></div><div class=sect1><h2 id=jails>Capítulo 15. Jaulas<a class=anchor href=#jails></a></h2><div class=sectionbody><div class=sect2><h3 id=jails-synopsis>15.1. Sinopsis<a class=anchor href=#jails-synopsis></a></h3><div class=paragraph><p>En este capítulo se explica qué son las jaulas en FreeBSD y cómo usarlas. Las jaulas, citadas con frecuencia como la nueva generación de <em>entornos chroot</em>, son una herramienta muy poderosa que se ha puesto al servicio de los administradores de sistemas, aunque su uso más básico puede ser también de suma utilidad para usuarios avanzados.</p></div><div class=paragraph><p>Tras leer este capítulo sabrá usted:</p></div><div class=ulist><ul><li><p>Qué es una jaula y para qué puede usarse en sistemas FreeBSD.</p></li><li><p>Cómo generar, arrancar y parar una jaula.</p></li><li><p>Cómo manejarse con los rudimentos de la administración de las jaulas, tanto desde dentro como desde fuera de la jaula.</p></li></ul></div><div class=paragraph><p>Otras fuentes de información útil sobre las jaulas:</p></div><div class=ulist><ul><li><p>La página de manual <a href="https://man.freebsd.org/cgi/man.cgi?query=jail&amp;sektion=8&amp;format=html">jail(8)</a>. Es la referencia completa de <code>jail</code>, la herramienta administrativa de FreeBSD con la que se arrancan, paran y controlan las jaulas.</p></li><li><p>Las listas de correo y sus respectivos archivos. Los archivos de la <a href=https://lists.FreeBSD.org/subscription/freebsd-questions>Lista de correo para preguntas generales sobre FreeBSD</a>, entre otras listas de correo alojadas en el <a href=https://lists.freebsd.org>Servidor de listas de FreeBSD</a> contienen una enorme cantidad de información sobre jaulas. La ayuda que está buscando puede obtenerla, por tanto, de una búsqueda en los archivos de las listas o de enviar una pregunta que nadie haya hecho en la lista de correo <a href=https://lists.FreeBSD.org/subscription/freebsd-questions>freebsd-questions</a>.</p></li></ul></div></div><div class=sect2><h3 id=jails-terms>15.2. Términos relacionados con las jaulas<a class=anchor href=#jails-terms></a></h3><div class=paragraph><p>Para ayudar a comprender las partes de FreeBSD que intervienen en el funcionamiento de las jaulas, su funcionamiento interno y el modo en que interactuan con el resto de FreeBSD, durante el resto del capítulo se utilizarán los siguientes términos:</p></div><div class=dlist><dl><dt class=hdlist1><a href="https://man.freebsd.org/cgi/man.cgi?query=chroot&amp;sektion=2&amp;format=html">chroot(2)</a> (comando)</dt><dd><p>Es una llamada al sistema de FreeBSD que restringe el directorio raiz de un proceso y sus hijos.</p></dd><dt class=hdlist1><a href="https://man.freebsd.org/cgi/man.cgi?query=chroot&amp;sektion=2&amp;format=html">chroot(2)</a> (entorno)</dt><dd><p>Es el entorno de procesos que se ejecutan en un "chroot". Esto incluye recursos como la parte visible del sistema de ficheros, los ID de usuario y grupo disponibles, interfaces de red u otros mecanismos IPC.</p></dd><dt class=hdlist1><a href="https://man.freebsd.org/cgi/man.cgi?query=jail&amp;sektion=8&amp;format=html">jail(8)</a> (comando)</dt><dd><p>La herramienta de administración que permite arrancar procesos dentro del entorno de una jaula.</p></dd><dt class=hdlist1>servidor (sistema, proceso, usuario, etc)</dt><dd><p>El sistema que controla una jaula. El servidor tiene acceso a todos los recursos de hardware y puede controlar procesos tanto dentro como fuera de la jaula. Una de las diferencias importantes entre el sistema que aloja la jaula y la jaula propiamente dicha: las limitaciones que afectan a los procesos que se ejecutan con privilegios de superusuario dentro de la jaula no dependen de los procesos del servidor que la aloja.</p></dd><dt class=hdlist1>enjaulado (sistema, proceso, usuario, etc.)</dt><dd><p>Un proceso, usuario u otra entidad, cuyo acceso a los recursos está restringido por una jaula de FreeBSD.</p></dd></dl></div></div><div class=sect2><h3 id=jails-intro>15.3. Introducción<a class=anchor href=#jails-intro></a></h3><div class=paragraph><p>Dado lo dificil y desconcertante de la tarea de administrar sistemas se han ido desarrollando poderosas herramientas con el fin de hacer la vida del administrador más sencilla. Dichas herramientas suelen facilitar cierto tipo de mejoras en la instalación, configuración o mantenimiento de los sistemas. Una de las tareas que se espera que cumpla un administrador de sistemas es la configuración adecuada de la seguridad, de modo que pueda dar el servicio para el que se ha destinado sin que pueda verse comprometido.</p></div><div class=paragraph><p>Una de las herramientas disponibles para mejorar los niveles de seguridad de un sistema FreeBSD es el uso de <em>jaulas</em>. Las jaulas fueron introducidas en FreeBSD 4.X por Poul-Henning Kamp &lt;<a href=mailto:phk@FreeBSD.org>phk@FreeBSD.org</a>>, pero en FreeBSD 5.X sus capacidades fueron aumentadas hasta hacer de ellas un subsistema poderoso y flexible. Su desarrollo sigue avanzando, aumentando así su utilidad, rendimiento, fiabilidad y seguridad.</p></div><div class=sect3><h4 id=jails-what>15.3.1. Qué es una jaula<a class=anchor href=#jails-what></a></h4><div class=paragraph><p>Los sistemas tipo BSD disponen de <a href="https://man.freebsd.org/cgi/man.cgi?query=chroot&amp;sektion=2&amp;format=html">chroot(2)</a> desde la época de 4.2BSD. <a href="https://man.freebsd.org/cgi/man.cgi?query=chroot&amp;sektion=8&amp;format=html">chroot(8)</a> permite restringir el directorio raiz de un conjunto de procesos, creando un entorno seguro y separado del resto del sistema. Los procesos creados dentro de un entorno chroot no pueden acceder a ficheros o recursos ubicados fuera del mismo. Por esta razón, si un atacante logra comprometer un servicio que se ejecuta en un entorno chroot no debería automáticamente poder acceder al resto del sistema. <a href="https://man.freebsd.org/cgi/man.cgi?query=chroot&amp;sektion=8&amp;format=html">chroot(8)</a> es una buena herramienta para tareas sencillas que no requieran mucha flexibilidad o características complejas o muy avanzadas. Por desgracia, desde la invención de chroot se han ido encontrando muchas formas de saltarse las barreras que chroot impone y, aunque estén corregidas en las versiones más modernas del kernel de FreeBSD, era evidente que <a href="https://man.freebsd.org/cgi/man.cgi?query=chroot&amp;sektion=2&amp;format=html">chroot(2)</a> no era la solución ideal para ejecutar servicios con seguridad. Había que implementar un nuevo subsistema.</p></div><div class=paragraph><p>Este es uno de los principales motivos por los que se crearon las <em>jaulas</em>.</p></div><div class=paragraph><p>Las jaulas llevan más allá en muchos sentidos el concepto tradicional de entorno <a href="https://man.freebsd.org/cgi/man.cgi?query=chroot&amp;sektion=2&amp;format=html">chroot(2)</a>. En un entorno <a href="https://man.freebsd.org/cgi/man.cgi?query=chroot&amp;sektion=2&amp;format=html">chroot(2)</a> tradicional los procesos solo ven limitada la parte del sistema de ficheros a la que pueden acceder. El resto de recursos del sistema, es decir, el conjunto de usuarios del sistema, los procesos en ejecución o el subsistema de red están compartidos entre el sistema alojado y el servidor. Las jaulas extienden este modelo virtualizando no solamente el acceso al sistema de ficheros, sino al conjunto de usuarios, al subsistema de red del kernel de FreeBSD y unas cuantas cosas más. En la <a href=#jails-tuning>Administración y personalización a fondo</a> se detallan diversas opciones de control exhaustivo para configurar el acceso a recursos de un entorno enjaulado.</p></div><div class=paragraph><p>Una jaula se caracteriza por disponer de cuatro elementos:</p></div><div class=ulist><ul><li><p>Un "subárbol" de directorios: el punto desde el que se entra a una jaula. Una vez dentro de la jaula un proceso no puede escapar de dicho "subárbol". Los típicos problemas de seguridad que aparecín una y otra vez en el diseño del <a href="https://man.freebsd.org/cgi/man.cgi?query=chroot&amp;sektion=2&amp;format=html">chroot(2)</a> original no afectan a las jaulas de FreeBSD.</p></li><li><p>Un nombre de máquina ("hostname"), que definirá a la jaula. Las jaulas se usan principalmente para albergar servicios de red, por lo que disponer de un nombre de máquina descriptivo ayuda enormemente al administrador de sistemas.</p></li><li><p>Una dirección IP: debe asignarse a la jaula y no cambiarse durante el ciclo de vida de la jaula. La dirección IP de una jaula suele ser un alias de un interfaz de red, aunque no es imprescindible que así sea.</p></li><li><p>Un comando: La ruta de un ejecutable ubicado dentro de la jaula. La ruta es relativa al directorio raiz de la jaula, por lo que puede ser muy diferentes según el entorno.</p></li></ul></div><div class=paragraph><p>Además, las jaulas pueden tener sus propios usuarios e incluso su propio <code>root</code>. Es obvio que este usuario <code>root</code> tiene su poder para hacer circunscrito a la jaula y, desde el punto de vista del servidor, el usuario <code>root</code> de la jaula no es omnipotente. El usuario <code>root</code> de la jaula no puede ejecutar tareas críticas fuera de la jaula (<a href="https://man.freebsd.org/cgi/man.cgi?query=jail&amp;sektion=8&amp;format=html">jail(8)</a>) a la que pertenece. Más adelante, en la <a href=#jails-tuning>Administración y personalización a fondo</a>, se dará más información sobre las restricciones del usuario <code>root</code>.</p></div></div></div><div class=sect2><h3 id=jails-build>15.4. Creación y gestión de jaulas<a class=anchor href=#jails-build></a></h3><div class=paragraph><p>Algunos administradores dividen las jaulas en dos tipos: jaulas "completas", que recrean un sistema FreeBSD real, y jaulas "de servicio", que son aquellas que están dedicadas a una sola aplicación o servicio, en muchos casos ejecutándose sin privilegios. Se trata de una división exclusivamente conceptual, por lo que el proceso de generación de una jaula no se ve afectado por ella. La página de manual <a href="https://man.freebsd.org/cgi/man.cgi?query=jail&amp;sektion=8&amp;format=html">jail(8)</a> explica claramente el procedimiento a seguir para generar una jaula:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># setenv D /aquí/está/la/jaula</span>
<span class=c># mkdir -p $D </span><i class=conum data-value=1></i><b>(1)</b>
<span class=c># cd /usr/src</span>
<span class=c># make world DESTDIR=$D </span><i class=conum data-value=2></i><b>(2)</b>
<span class=c># cd etc/ [9]</span>
<span class=c># make distribution DESTDIR=$D </span><i class=conum data-value=3></i><b>(3)</b>
<span class=c># mount_devfs devfs $D/dev </span><i class=conum data-value=4></i><b>(4)</b></code></pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>El mejor punto de partida es la elección del punto del sistema de ficheros del servidor donde estará físicamente ubicada la jaula. <span class=filename>/usr/jail/nombredelajaula</span> es un buen sitio. <em>nombredelajaula</em> es el nombre de máquina que identifica a la jaula. El sistema de ficheros <span class=filename>/usr/</span> suele tener espacio suficiente para albergar el sistema de ficheros de la jaula que, cuando se trata de jaulas "completas", es esencialmente lo necesario para alojar todos y cada uno de los sistemas de ficheros en una instalación del sistema base por omisión de FreeBSD.</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td>Este comando creará el contenido necesario (binarios, bibliotecas, páginas de manual, etc.) y lo copiará al "subárbol" elegido como ubicación física de la jaula. Todo se hace al típico estilo FreeBSD: se compila todo y luego se instala en la ruta de destino.</td></tr><tr><td><i class=conum data-value=3></i><b>3</b></td><td>Al pasar el "target" <code>distribution</code> a make se instalan todos los ficheros de configuración necesarios. En pocas palabras, instala cada fichero instalable que haya en <span class=filename>/usr/src/etc/</span> en el directorio <span class=filename>/etc</span> de la jaula, es decir, en <span class=filename>$D/etc/</span>.</td></tr><tr><td><i class=conum data-value=4></i><b>4</b></td><td>No es imprescindible montar el sistema de ficheros <a href="https://man.freebsd.org/cgi/man.cgi?query=devfs&amp;sektion=8&amp;format=html">devfs(8)</a> dentro de la jaula aunque por otra parte (casi) todas las aplicaciones necesitan acceso al menos a un dispositivo, dependiendo esto del propósito de la aplicación. Es muy importante el control del acceso a dispositivos desde la jaula, puesto que una configuración descuidada puede permitir que un atacante haga de las suyas. El control sobre <a href="https://man.freebsd.org/cgi/man.cgi?query=devfs&amp;sektion=8&amp;format=html">devfs(8)</a> se gestiona mediante reglas que se detallan en las páginas de manual <a href="https://man.freebsd.org/cgi/man.cgi?query=devfs&amp;sektion=8&amp;format=html">devfs(8)</a> y <a href="https://man.freebsd.org/cgi/man.cgi?query=devfs.conf&amp;sektion=5&amp;format=html">devfs.conf(5)</a>.</td></tr></tbody></table></div><div class=paragraph><p>Una vez instalada la jaula puede arrancarla mediante <a href="https://man.freebsd.org/cgi/man.cgi?query=jail&amp;sektion=8&amp;format=html">jail(8)</a>. <a href="https://man.freebsd.org/cgi/man.cgi?query=jail&amp;sektion=8&amp;format=html">jail(8)</a> usa los cuatro argumentos que se detallan en la <a href=#jails-what>Qué es una jaula</a>. Puede pasarle otros argumentos además de estos, por ejemplo para ejecutar procesos enjaulados bajo los permisos de un usuario específico. El argumento <code><em>comando</em></code> depende del tipo de jaula; si se trata de un <em>virtual system</em><span class=filename>/etc/rc</span> es una buena elección, puesto que ejecutará la secuencia de arranque de un sistema FreeBSD real. Si se trata de una jaula <em>de servicio</em> depende del servicio o aplicación que se quiera ejecutar mediante la jaula.</p></div><div class=paragraph><p>Con frecuencia las jaulas se arrancan durante el arranque del servidor que las aloja; el sistema <span class=filename>rc</span> de FreeBSD permite hacerlo de un modo muy sencillo.</p></div><div class="olist arabic procedure"><ol class=arabic><li><p>Puede crear una lista de jaulas que quiera arrancar en el inicio del sistema en el fichero <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a>:</p><div class="literalblock programlisting"><div class=content><pre>jail_enable=&#34;YES&#34;   # Ponga NO si quiere desactivar el arranque de jaulas
jail_list=&#34;www&#34;     # Lista de nombres de jaulas separados por espacios</pre></div></div></li><li><p>Tendrá que añadir parámetros específicos para cada jaula al fichero <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a>:</p><div class="literalblock programlisting"><div class=content><pre>jail_www_rootdir=&#34;/usr/jail/www&#34;     # directorio raiz de la jaula
jail_www_hostname=&#34;www.example.org&#34;  # nombre de máquina de la jaula
jail_www_ip=&#34;192.168.0.10&#34;           # dirección IP de la jaula
jail_www_devfs_enable=&#34;YES&#34;          # montar devfs en la jaula
jail_www_devfs_ruleset=&#34;www_ruleset&#34; # reglas a aplicar a devfs dentro de la jaula</pre></div></div><div class=paragraph><p>El arranque de jaulas por omisión que se configure en <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a> ejecutará el script <span class=filename>/etc/rc</span> de la jaula y asumirá que es un sistema virtual completo. Si se trata de una jaula de servicio el comando de arranque por omisión tendrá que cambiarse configurando la opción <code>jail<em>nombredejaula</em>exec_start</code> según convenga.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Si quiere consultar la lista completa de opciones consulte la página de manual <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a>.</p></div></td></tr></tbody></table></div></li></ol></div><div class=paragraph><p>Puede arrancar o parar a mano una jaula mediante el script <span class=filename>/etc/rc.d/jail</span> siempre y cuando la jaula aparezca en <span class=filename>rc.conf</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /etc/rc.d/jail start www</span>
<span class=c># /etc/rc.d/jail stop www</span></code></pre></div></div><div class=paragraph><p>De momento no hay una forma limpia de apagar una jaula (<a href="https://man.freebsd.org/cgi/man.cgi?query=jail&amp;sektion=8&amp;format=html">jail(8)</a>) debido a que los comandos que se usan normalmente para producir un apagado limpio del sistema no pueden usarse dentro de una jaula. La mejor forma de parar una jaula es ejecutar el siguiente comando desde dentro de la propia jaula o bien mediante <a href="https://man.freebsd.org/cgi/man.cgi?query=jexec&amp;sektion=8&amp;format=html">jexec(8)</a> desde fuera:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sh /etc/rc.shutdown</span></code></pre></div></div><div class=paragraph><p>Para más información consulte la página de manual <a href="https://man.freebsd.org/cgi/man.cgi?query=jail&amp;sektion=8&amp;format=html">jail(8)</a>.</p></div></div><div class=sect2><h3 id=jails-tuning>15.5. Administración y personalización a fondo<a class=anchor href=#jails-tuning></a></h3><div class=paragraph><p>Hay diversas opciones que pueden usarse en las jaulas y varios tipos de formas de combinar un sistema FreeBSD servidor y las jaulas y poder disponer de aplicaciones de alto nivel. En esta sección se muestra lo siguiente:</p></div><div class=ulist><ul><li><p>Algunas de las opciones disponibles para personalizar el comportamiento y las restricciones de seguridad que pueden aplicarse en una jaula.</p></li><li><p>Algunas de las aplicaciones de alto nivel creadas para la administración de jaulas. Estas aplicaciones están en la colección de ports y pueden utilizarse en conjunto para implementar productos basados en jaulas.</p></li></ul></div><div class=sect3><h4 id=jails-tuning-utilities>15.5.1. Herramientas del sistema para la personalización de jaulas en FreeBSD<a class=anchor href=#jails-tuning-utilities></a></h4><div class=paragraph><p>La personalización a fondo de las jaulas se hace en su mayor parte mediante la configuración de variables <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a>. Hay una subcategoría especial de sysctl para que sea más sencillo organizar las opciones más más importantes: se trata de las opciones de la jerarquía <code>security.jail.*</code> del kernel de FreeBSD. A continuación veremos una lista de las principales sysctl relacionadas con las jaulas y los valores que tienen por omisión. Los nombres deberían describir por sí mismos qué función tienen (N. del T.: En inglés, claro) pero si necesita más información sobre ellas consulte las páginas de manual <a href="https://man.freebsd.org/cgi/man.cgi?query=jail&amp;sektion=8&amp;format=html">jail(8)</a> y <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a>.</p></div><div class=ulist><ul><li><p><code>security.jail.set_hostname_allowed: 1</code></p></li><li><p><code>security.jail.socket_unixiproute_only: 1</code></p></li><li><p><code>security.jail.sysvipc_allowed: 0</code></p></li><li><p><code>security.jail.enforce_statfs: 2</code></p></li><li><p><code>security.jail.allow_raw_sockets: 0</code></p></li><li><p><code>security.jail.chflags_allowed: 0</code></p></li><li><p><code>security.jail.jailed: 0</code></p></li></ul></div><div class=paragraph><p>El administrador del <em>servidor</em> puede usar estas variables para añadir o quitar limitaciones impuestas por omisión al usuario <code>root</code>. Tenga en cuenta que hay ciertas limitaciones que no pueden quitarse. El usuario <code>root</code> no puede montar o desmontar sistemas de ficheros desde su jaula. El usuario <code>root</code> no puede cargar o descargar reglas de <a href="https://man.freebsd.org/cgi/man.cgi?query=devfs&amp;sektion=8&amp;format=html">devfs(8)</a>, configurar reglas de cortafuegos ni ejecutar muchas otras tareas administrativas que requieran modificaciones o acceso a datos internos del kernel, como cambiar el nivel de seguridad <code>securelevel</code> del kernel.</p></div><div class=paragraph><p>El sistema base de FreeBSD contiene un conjunto básico de herramientas que permiten el acceso a información sobre jaulas activas en el sistema, así como la conexión a una jaula para ejecutar comandos administrativos. <a href="https://man.freebsd.org/cgi/man.cgi?query=jls&amp;sektion=8&amp;format=html">jls(8)</a> y <a href="https://man.freebsd.org/cgi/man.cgi?query=jexec&amp;sektion=8&amp;format=html">jexec(8)</a> forman parte del sistema base de FreeBSD y permiten ejecutar las siguientes tareas:</p></div><div class=ulist><ul><li><p>Mostrar una lista de jaulas activas y sus correspondientes identificadores de jaula (JID), dirección IP, nombre de máquina y ruta.</p></li><li><p>Conectarse a una jaula en ejecució desde el servidor y ejecutar un comando dentro de la jaula o realizar tareas administrativas dentro de dicha jaula. Esto es muy útil cuando el usuario <code>root</code> quiere apagar la jaula de forma limpia. La herramienta <a href="https://man.freebsd.org/cgi/man.cgi?query=jexec&amp;sektion=8&amp;format=html">jexec(8)</a> permite también arrancar una shell dentro de la jaula para realizar tareas administrativas. Veamos un ejemplo:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># jexec 1 tcsh</span></code></pre></div></div></li></ul></div></div><div class=sect3><h4 id=jails-tuning-admintools>15.5.2. Herramientas para tareas administrativas de alto nivel en la Colección de Ports<a class=anchor href=#jails-tuning-admintools></a></h4><div class=paragraph><p>Entre las variadas aplicaciones ajenas al Proyecto FreeBSD que han ido apareciendo para administrar jaulas una de las más completas y útiles es <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/jailutils/>sysutils/jailutils</a>. Es un conjunto de pequeñas aplicaciones de mucha ayuda en la gestión de una jaula (<a href="https://man.freebsd.org/cgi/man.cgi?query=jail&amp;sektion=8&amp;format=html">jail(8)</a>). Por favor, consulte su página web para más información.</p></div></div></div><div class=sect2><h3 id=jails-application>15.6. Uso de las jaulas<a class=anchor href=#jails-application></a></h3><div class=sect3><h4 id=jails-service-jails>15.6.1. Jaulas "de servicio"<a class=anchor href=#jails-service-jails></a></h4><div class=paragraph><p>Esta sección está basada en una idea que Simon L. B. Nielsen &lt;<a href=mailto:simon@FreeBSD.org>simon@FreeBSD.org</a>> presentó por primera vez en <a href=http://simon.nitro.dk/service-jails.html>http://simon.nitro.dk/service-jails.html</a> y en un artículo con contenido adicional escrito por Ken Tom <a href=mailto:locals@gmail.com>locals@gmail.com</a>. En esta sección se detalla cómo configurar un sistema FreeBSD que añade una capa adicional de seguridad mediante el uso de <a href="https://man.freebsd.org/cgi/man.cgi?query=jail&amp;sektion=8&amp;format=html">jail(8)</a>. Para su verdadero aprovechamiento se asume que el sistema en el que se vaya a aplicar ejecuta al menos RELENG_6_0 y que la información que contienen las secciones previas de este capítulo se ha comprendido totalmente.</p></div><div class=sect4><h5 id=jails-service-jails-design>15.6.1.1. Diseño<a class=anchor href=#jails-service-jails-design></a></h5><div class=paragraph><p>Uno de los mayores problemas de las jaulas es la gestión de su proceso de actualización. Este proceso tiene a ser un problema porque cada jaula tiene que recompilarse íntegramente desde el código fuente cada vez que hay que actualizarla. Esto no es un gran problema si tenemos una sola jaula puesto que el proceso de actualización es bastante simple, pero si hay muchas jaulas será un trabajo largo y tedioso.</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>: Esta configuración requiere mucha experiencia con FreeBSD y el uso de sus características. Si los pasos que se detallan a continuación le parecen demasiado complicados puede echar un vistazo a sistemas más sencillos como <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/ezjail/>sysutils/ezjail</a>, que le permitirá acceder a un método de administración de jaulas en FreeBSD más sencillo y no es tan sofisticado como el que le proponemos a continuación.</p></div></td></tr></tbody></table></div><div class=paragraph><p>El origen de esta idea es resolver los problemas antes descritos compartiendo el máximo posible entre distintas jaulas, de un modo seguro (utilizando montajes using read-only <a href="https://man.freebsd.org/cgi/man.cgi?query=mount_nullfs&amp;sektion=8&amp;format=html">mount_nullfs(8)</a> mounts) para que la actualización sea más sencilla y el ubicar servicios aislados en jaulas sea más interesante. Además, se presenta una forma sencilla de añadir o borrar jaulas así como una forma de actualizarlas.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Los ejemplos de servicios en este contexto son: un servidor HTTP,un servidor DNS, un servidor SMTP, etc.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Los objetivos de la configuración descrita en esta sección son:</p></div><div class=ulist><ul><li><p>Crear una estructura de jaulas simple y fácil de entender. Esto implica <em>no</em> tener que ejecutar un "installworld" completo en todas y cada una de las jaulas.</p></li><li><p>Facilitar la creación de nuevas jaulas o el borrado de jaulas previamente existentes.</p></li><li><p>Facilitar la actualización de jaulas ya existentes.</p></li><li><p>Hacer posible el uso de una rama de FreeBSD personalizada.</p></li><li><p>Ser paranoico en cuanto a seguridad, reduciendo todo lo posible la posibilidad de que los sistemas se vean comprometidos.</p></li><li><p>Ahorrar todo el espacio e inodos que sea posible.</p></li></ul></div><div class=paragraph><p>Como ya se ha dicho, este diseño se basa en gran medida en el disponer de una única plantilla en modo de sólo lectura (a la que llamaremos nullfs) montada en cada jaula y un dispositivo en modo lectura-escritura por cada jaula. El dispositivo puede ser otro disco físico adicional, una partición o un dispositivo <a href="https://man.freebsd.org/cgi/man.cgi?query=md&amp;sektion=4&amp;format=html">md(4)</a> basado en un vnode. En este ejemplo utilizaremos montajes nullfs en modo lectura-escritura.</p></div><div class=paragraph><p>La estructura del sistema de ficheros se detalla en la siguiente lista:</p></div><div class=ulist><ul><li><p>Cada jaula se montará bajo <span class=filename>/home/j</span>.</p></li><li><p><span class=filename>/home/j/mroot</span> será la plantilla para cada jaula y la partición de sólo lectura para todas las jaulas.</p></li><li><p>Se creará un directorio vacío para cada jaula bajo el directorio <span class=filename>/home/j</span>.</p></li><li><p>Cada jaula tendrá un directorio <span class=filename>/s</span> que estará enlazado con la parte de lectura-escritura del sistema.</p></li><li><p>Cada jaula tendrá su propio sistema en modo lectura-escritura basado en <span class=filename>/home/j/skel</span>.</p></li><li><p>Cada parte de lectura-escritura correspondiente a cada jaula se creará en <span class=filename>/home/js</span>.</p></li></ul></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Se asume que las jaulas se instalarán bajo la partición <span class=filename>/home</span>. Por supuesto esto no es en absoluto obligatorio, pero hay que tener en cuenta que debe hacerse el mismo cambio en cada uno de los ejemplos que se muestran más adelante.</p></div></td></tr></tbody></table></div></div><div class=sect4><h5 id=jails-service-jails-template>15.6.1.2. Creación de la plantilla<a class=anchor href=#jails-service-jails-template></a></h5><div class=paragraph><p>En esta sección se describen los pasos necesarios para crear la plantilla maestra que conformará la parte de sólo lectura que usarán las jaulas.</p></div><div class=paragraph><p>Siempre es recomendable actualizar el sistema FreeBSD a la última rama -RELEASE. Consulte el <a href=./#makeworld>capítulo</a> correspondiente de este libro si necesita más información. En caso de que la actualización no sea posible tendrá que usar "buidworld" para poder seguir adelante. También necesitará el paquete <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/cpdup/>sysutils/cpdup</a>. Usaremos <a href="https://man.freebsd.org/cgi/man.cgi?query=portsnap&amp;sektion=8&amp;format=html">portsnap(8)</a> para descargar la Colección de Ports de FreeBSD. El capítulo sobre <a href=./#portsnap>Portsnap</a> es siempre una lectura muy recomendable para quienes no tengan experiencia con su funcionamiento.</p></div><div class="olist arabic procedure"><ol class=arabic><li><p>Lo primero que haremos será crear una estructura de directorios para el sistema de ficheros de sólo lectura que contendrá los binarios de nuestras jaulas, luego iremos al directorio que contiene el árbol de código de FreeBSD e instalaremos el sistema de ficheros de sólo lectura en la plantilla de las jaulas:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mkdir /home/j /home/j/mroot</span>
<span class=c># cd /usr/src</span>
<span class=c># make installworld DESTDIR=/home/j/mroot</span></code></pre></div></div></li><li><p>Una vez hecho esto, prepararemos la Colección de Ports de FreeBSD para nuestras jaulas así como un árbol de código FreeBSD, necesario para usar mergemaster:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /home/j/mroot</span>
<span class=c># mkdir usr/ports</span>
<span class=c># portsnap -p /home/j/mroot/usr/ports fetch extract</span>
<span class=c># cpdup /usr/src /home/j/mroot/usr/src</span></code></pre></div></div></li><li><p>Crear la estructura de directorios necesaria para la parte de lectura-escritura del sistema:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mkdir /home/j/skel /home/j/skel/home /home/j/skel/usr-X11R6 /home/j/skel/distfiles</span>
<span class=c># mv etc /home/j/skel</span>
<span class=c># mv usr/local /home/j/skel/usr-local</span>
<span class=c># mv tmp /home/j/skel</span>
<span class=c># mv var /home/j/skel</span>
<span class=c># mv root /home/j/skel</span></code></pre></div></div></li><li><p>Usamos mergemaster para instalar los ficheros de configuración que falten. Después nos libramos de los directorios adicionales que haya creado mergemaster:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mergemaster -t /home/j/skel/var/tmp/temproot -D /home/j/skel -i</span>
<span class=c># cd /home/j/skel</span>
<span class=c># rm -R bin boot lib libexec mnt proc rescue sbin sys usr dev</span></code></pre></div></div></li><li><p>Ahora enlazamos simbólicamente el sistema de ficheros de lectura-escritura con el sistema de ficheros de sólo lectura. Por favor, asegúrese de que los enlaces simbólicos se crean en las ubicaciones correctas: <span class=filename>s/</span>. Si se usan directorios reales o directorios erróneos la instalación no funcionará.</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /home/j/mroot</span>
<span class=c># mkdir s</span>
<span class=c># ln -s s/etc etc</span>
<span class=c># ln -s s/home home</span>
<span class=c># ln -s s/root root</span>
<span class=c># ln -s ../s/usr-local usr/local</span>
<span class=c># ln -s ../s/usr-X11R6 usr/X11R6</span>
<span class=c># ln -s ../../s/distfiles usr/ports/distfiles</span>
<span class=c># ln -s s/tmp tmp</span>
<span class=c># ln -s s/var var</span></code></pre></div></div></li><li><p>Como último paso, cree un <span class=filename>/home/j/skel/etc/make.conf</span> genérico con el siguiente contenido:</p><div class="literalblock programlisting"><div class=content><pre>WRKDIRPREFIX?=  /s/portbuild</pre></div></div><div class=paragraph><p>El tener <code>WRKDIRPREFIX</code> configurado de este modo hará posible compilar ports de FreeBSD dentro de cada jaula. Recuerde que el el directorio de los ports es de sólo lectura. La ruta personalizada por <code>WRKDIRPREFIX</code> permite ejecutar compilaciones en la parte de sólo lectura de cada jaula.</p></div></li></ol></div></div><div class=sect4><h5 id=jails-service-jails-creating>15.6.1.3. Creación de las jaulas<a class=anchor href=#jails-service-jails-creating></a></h5><div class=paragraph><p>Ya tenemos una plantilla de jaulas de FreeBSD completa, así que podemos configurar nuestras jaulas en <span class=filename>/etc/rc.conf</span>. En este ejemplo crearemos 3 jaulas: "NS", "MAIL" y "WWW".</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Introduzca lassiguientes lineas en el fichero <span class=filename>/etc/fstab</span>; con esto cada jaula tendrá acceso a la plantilla de sólo lectura y al espacio de lectura-escritura:</p><div class="literalblock programlisting"><div class=content><pre>/home/j/mroot   /home/j/ns     nullfs  ro  0   0
/home/j/mroot   /home/j/mail   nullfs  ro  0   0
/home/j/mroot   /home/j/www    nullfs  ro  0   0
/home/js/ns     /home/j/ns/s   nullfs  rw  0   0
/home/js/mail   /home/j/mail/s nullfs  rw  0   0
/home/js/www    /home/j/www/s  nullfs  rw  0   0</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Las particiones que tienen un 0 en la columna "pass" no serán revisadas por <a href="https://man.freebsd.org/cgi/man.cgi?query=fsck&amp;sektion=8&amp;format=html">fsck(8)</a> durante el arranque y las que tienen un 0 en la columna "dump" no serán copiadas por <a href="https://man.freebsd.org/cgi/man.cgi?query=dump&amp;sektion=8&amp;format=html">dump(8)</a>. No nos interesa que fsck compruebe la integridad de montajes nullfs ni que dump haga copias de seguridad de montajes nullfs de sólo lectura de las jaulas. Por esta razón el ejemplo de <span class=filename>fstab</span> tiene en las dos últimas columnas "0 0".</p></div></td></tr></tbody></table></div></li><li><p>Configure las jaulas en <span class=filename>/etc/rc.conf</span>:</p><div class="literalblock programlisting"><div class=content><pre>jail_enable=&#34;YES&#34;
jail_set_hostname_allow=&#34;NO&#34;
jail_list=&#34;ns mail www&#34;
jail_ns_hostname=&#34;ns.ejemplo.org&#34;
jail_ns_ip=&#34;192.168.3.17&#34;
jail_ns_rootdir=&#34;/usr/home/j/ns&#34;
jail_ns_devfs_enable=&#34;YES&#34;
jail_mail_hostname=&#34;mail.ejemplo.org&#34;
jail_mail_ip=&#34;192.168.3.18&#34;
jail_mail_rootdir=&#34;/usr/home/j/mail&#34;
jail_mail_devfs_enable=&#34;YES&#34;
jail_www_hostname=&#34;www.ejemplo.org&#34;
jail_www_ip=&#34;62.123.43.14&#34;
jail_www_rootdir=&#34;/usr/home/j/www&#34;
jail_www_devfs_enable=&#34;YES&#34;</pre></div></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>: La razón por la que <code>jail<em>nombre</em>rootdir</code> contiene <span class=filename>/usr/home</span> y no <span class=filename>/home</span> es que la ruta física del directorio <span class=filename>/home</span> en una instalación de FreeBSD por omisión es <span class=filename>/usr/home</span>. La variable <code>jail<em>nombre</em>rootdir</code> <em>no</em> debe apuntar a una ruta que contenga un enlace simbólico porque sería imposible arrancar las jaulas. Utilice la herramienta <a href="https://man.freebsd.org/cgi/man.cgi?query=realpath&amp;sektion=1&amp;format=html">realpath(1)</a> para asegurarse del valor exacto que debe asignar a la variable. Por favor, consulte el aviso de seguridad FreeBSD-SA-07:01.jail para más información.</p></div></td></tr></tbody></table></div></li><li><p>Creamos los puntos de montaje de sistemas de ficheros de sólo lectura correspondientes a cada jaula:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mkdir /home/j/ns /home/j/mail /home/j/www</span></code></pre></div></div></li><li><p>Instalamos la plantilla de lectura-escritura dentro de cada jaula. Observe que utilizamos <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/cpdup/>sysutils/cpdup</a> para asegurarnos de que se hace una copia exacta de cada directorio:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mkdir /home/js</span>
<span class=c># cpdup /home/j/skel /home/js/ns</span>
<span class=c># cpdup /home/j/skel /home/js/mail</span>
<span class=c># cpdup /home/j/skel /home/js/www</span></code></pre></div></div></li><li><p>Llegados a este punto las jaulas están configuradas y listas para arrancar. Monte los sistemas de ficheros de cada jaula y luego arránquelas con el script <span class=filename>/etc/rc.d/jail</span>:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount -a</span>
<span class=c># /etc/rc.d/jail start</span></code></pre></div></div></li></ol></div></div></div><div class=paragraph><p>Las jaulas deberían haber arrancado. Asegúrese de ello con <a href="https://man.freebsd.org/cgi/man.cgi?query=jls&amp;sektion=8&amp;format=html">jls(8)</a>. La salida que verá debe parecerse a esta:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># jls</span>
   JID  IP Address      Hostname                      Path
     3  192.168.3.17    ns.ejemplo.org                /home/j/ns
     2  192.168.3.18    mail.ejemplo.org              /home/j/mail
     1  62.123.43.14    www.ejemplo.org               /home/j/www</code></pre></div></div><div class=paragraph><p>En este punto debería ser posible entrar a cada una de las jaulas, añadir nuevos usuarios o configurar dæmons. La columna <code>JID</code> indica el número de identificación de cada jaula que esté funcionando en el sistema. Con el siguiente comando puede ejecutar tareas administrativas en la jaula cuyo <code>JID</code> sea 3:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># jexec 3 tcsh</span></code></pre></div></div></div><div class=sect4><h5 id=jails-service-jails-upgrading>15.6.1.4. Actualización<a class=anchor href=#jails-service-jails-upgrading></a></h5><div class=paragraph><p>Llegará el momento en el que sea necesario actualizar el sistema, bien por seguridad o porque sea útil para las jaulas disponer de alguna nueva característica del sistema. El diseño de esta configuración facilita una forma fácil de actualizar sus jaulas. Además, minimiza la pérdida de servicio, puesto que las jaulas deben apagarse sólamente al final de todo el proceso. Se ofrece también la posibilidad de volver a la versión anterior en caso de que algo salga mal.</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>El primer paso es actualizar el servidor que aloja las jaulas de la forma habitual. Después creamos una plantilla de sólo lectura temporal en <span class=filename>/home/j/mroot2</span>.</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mkdir /home/j/mroot2</span>
<span class=c># cd /usr/src</span>
<span class=c># make installworld DESTDIR=/home/j/mroot2</span>
<span class=c># cd /home/j/mroot2</span>
<span class=c># cpdup /usr/src usr/src</span>
<span class=c># mkdir s</span></code></pre></div></div><div class=paragraph><p>La ejecución de <code>installworld</code> crea unos cuantos directorios innecesarios que debemos borrar:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># chflags -R 0 var</span>
<span class=c># rm -R etc var root usr/local tmp</span></code></pre></div></div></li><li><p>Creamos de nuevo los enlaces simbólicos de lectura-escritura del sistema de ficheros principal:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ln -s s/etc etc</span>
<span class=c># ln -s s/root root</span>
<span class=c># ln -s s/home home</span>
<span class=c># ln -s ../s/usr-local usr/local</span>
<span class=c># ln -s ../s/usr-X11R6 usr/X11R6</span>
<span class=c># ln -s s/tmp tmp</span>
<span class=c># ln -s s/var var</span></code></pre></div></div></li><li><p>Ha llegado el momento de parar las jaulas:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /etc/rc.d/jail stop</span></code></pre></div></div></li><li><p>Desmontamos los sistemas de ficheros originales:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># umount /home/j/ns/s</span>
<span class=c># umount /home/j/ns</span>
<span class=c># umount /home/j/mail/s</span>
<span class=c># umount /home/j/mail</span>
<span class=c># umount /home/j/www/s</span>
<span class=c># umount /home/j/www</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Los sistemas de ficheros de lectura-escritura cuelgan del sistema de sólo lectura <span class=filename>/s</span> y por tanto deben desmontarse antes.</p></div></td></tr></tbody></table></div></li><li><p>Movemos el sistema de ficheros de sólo lectura viejo y lo reemplazamos por el nuevo. Nos servirá de copia de seguridad y como archivo en caso de que haya problemas. Para darle un nombre usamos la fecha en la que se creado una nueva copia del sistema de ficheros de sólo lectura. Movemos también la Colección de Ports de FreeBSD al sistema de ficheros nuevo para ahorrar un poco más de espacio e inodos:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /home/j</span>
<span class=c># mv mroot mroot.20060601</span>
<span class=c># mv mroot2 mroot</span>
<span class=c># mv mroot.20060601/usr/ports mroot/usr</span></code></pre></div></div></li><li><p>Una vez llegados a este punto la nueva plantilla de sólo lectura está lista, de manera que lo único que nos queda por hacer es montar los sistemas de ficheros y arrancar las jaulas:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount -a</span>
<span class=c># /etc/rc.d/jail start</span></code></pre></div></div></li></ol></div></div></div><div class=paragraph><p>Compruebe con <a href="https://man.freebsd.org/cgi/man.cgi?query=jls&amp;sektion=8&amp;format=html">jls(8)</a> si las jaulas han arrancado sin contratiempos. No olvide ejecutar mergemaster en cada jaula. Tendrá que actualizar tanto los ficheros de configuración como los scripts rc.d.</p></div></div></div></div></div></div><div class=sect1><h2 id=mac>Capítulo 16. Mandatory Access Control<a class=anchor href=#mac></a></h2><div class=sectionbody><div class=sect2><h3 id=mac-synopsis>16.1. Sinopsis<a class=anchor href=#mac-synopsis></a></h3><div class=paragraph><p>Pendiente de Traducción</p></div></div><div class=sect2><h3 id=mac-inline-glossary>16.2. Términos clave en este capí­tulo<a class=anchor href=#mac-inline-glossary></a></h3><div class=paragraph><p>Pendiente de traducción</p></div></div><div class=sect2><h3 id=mac-initial>16.3. Explicación de MAC<a class=anchor href=#mac-initial></a></h3><div class=paragraph><p>Pendiente de traducción</p></div></div><div class=sect2><h3 id=mac-understandlabel>16.4. Las etiquetas MAC<a class=anchor href=#mac-understandlabel></a></h3><div class=paragraph><p>Pendiente de traducción</p></div></div><div class=sect2><h3 id=mac-modules>16.5. Configuración de módulos<a class=anchor href=#mac-modules></a></h3><div class=paragraph><p>Pendiente de traducción</p></div></div><div class=sect2><h3 id=mac-ifoff>16.6. El módulo MAC ifoff<a class=anchor href=#mac-ifoff></a></h3><div class=paragraph><p>Pendiente de traducción</p></div></div><div class=sect2><h3 id=mac-portacl>16.7. El módulo MAC portacl<a class=anchor href=#mac-portacl></a></h3><div class=paragraph><p>Pendiente de traducción</p></div></div><div class=sect2><h3 id=mac-labelingpolicies>16.8. Polí­ticas de etiquetas MAC<a class=anchor href=#mac-labelingpolicies></a></h3><div class=paragraph><p>Pendiente de traducción</p></div></div><div class=sect2><h3 id=mac-partition>16.9. El módulo MAC partition<a class=anchor href=#mac-partition></a></h3><div class=paragraph><p>Pendiente de traducción</p></div></div><div class=sect2><h3 id=mac-mls>16.10. El módulo de seguridad multinivel MAC<a class=anchor href=#mac-mls></a></h3><div class=paragraph><p>Pendiente de traducción</p></div></div><div class=sect2><h3 id=mac-biba>16.11. El módulo MAC Biba<a class=anchor href=#mac-biba></a></h3><div class=paragraph><p>Pendiente de traducción</p></div></div><div class=sect2><h3 id=mac-lomac>16.12. El módulo MAC LOMAC<a class=anchor href=#mac-lomac></a></h3><div class=paragraph><p>Pendiente de traducción</p></div></div><div class=sect2><h3 id=mac-implementing>16.13. Implementación de un entorno seguro con MAC<a class=anchor href=#mac-implementing></a></h3><div class=paragraph><p>Pendiente de traducción</p></div></div><div class=sect2><h3 id=MAC-examplehttpd>16.14. Otro ejemplo: Uso de MAC para restringir un servidor web<a class=anchor href=#MAC-examplehttpd></a></h3><div class=paragraph><p>Pendiente de traducción</p></div></div><div class=sect2><h3 id=mac-troubleshoot>16.15. Depuración de errores en MAC<a class=anchor href=#mac-troubleshoot></a></h3><div class=paragraph><p>Pendiente de traducción</p></div></div></div></div><div class=sect1><h2 id=audit>Capítulo 17. Auditoría de eventos de seguridad<a class=anchor href=#audit></a></h2><div class=sectionbody><div class=sect2><h3 id=audit-synopsis>17.1. *<a class=anchor href=#audit-synopsis></a></h3><div class=paragraph><p>Pendiente de traducción.</p></div></div></div></div><div class=sect1><h2 id=disks>Capítulo 18. Almacenamiento<a class=anchor href=#disks></a></h2><div class=sectionbody><div class=sect2><h3 id=disks-synopsis>18.1. Sinopsis<a class=anchor href=#disks-synopsis></a></h3><div class=paragraph><p>Este capítulo trata sobre el uso de discos en FreeBSD. Esto incluye discos basados en memoria, discos conectados a través de la red, dispositivos de almacenamiento SCSI/IDE estándar y dispositivos que utilizan el interfaz USB.</p></div><div class=paragraph><p>Tras leer este capítulo:</p></div><div class=ulist><ul><li><p>Conocerá la terminología que se usa en FreeBSD para describir la organización de datos en un disco físico (particiones y porciones).</p></li><li><p>Sabrá cómo añadir discos duros a su sistema.</p></li><li><p>Sabrá cómo configurar FreeBSD para utilizar dispositivos de almacenamiento USB.</p></li><li><p>Sabrá cómo configurar sistemas virtuales de ficheros, como los discos de memoria.</p></li><li><p>Sabrá cómo usar cuotas para limitar el uso del espacio en disco.</p></li><li><p>Sabrá cómo cifrar discos para hacerlos más seguros ante un atacante.</p></li><li><p>Sabrá cómo se crean y graban los CD y DVD en FreeBSD.</p></li><li><p>Conocerá diversas opciones de almacenamiento de copias de seguridad.</p></li><li><p>Sabrá cómo usar diversos programas de respaldo que pueden utilizarse en FreeBSD.</p></li><li><p>Sabrá cómo hacer copias de seguridad utilizando disquetes (floppy).</p></li><li><p>Sabrá en qué consiste una instantánea ("snapshot") y cómo utilizarla de forma eficiente.</p></li></ul></div><div class=paragraph><p>Antes de leer este capítulo:</p></div><div class=ulist><ul><li><p>Debe saber cómo configurar e instalar un nuevo kernel en FreeBSD (<a href=./#kernelconfig>Configuración del kernel de FreeBSD</a>).</p></li></ul></div></div><div class=sect2><h3 id=disks-naming>18.2. Nombres de dispositivo<a class=anchor href=#disks-naming></a></h3><div class=paragraph><p>A continuación le mostraremos una lista de dispositivos de físicos almacenamiento soportados por FreeBSD y los nombres de dispositivo asociados con ellos.</p></div><table id=disk-naming-physical-table class="tableblock frame-none grid-all stretch"><caption class=title>Tabla 6. Convenciones para nombrar discos físicos</caption><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Tipo de unidad</th><th class="tableblock halign-left valign-top">Nombre de dispositivo de la unidad</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Discos duros IDE</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>ad</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Unidades CDROM IDE</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>acd</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Discos duros SCSI y dispositivos de almacenamiento masivo USB</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>da</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Unidades CDROM SCSI</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>cd</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Diferentes tipos de unidades CDROM no estándares</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>mcd</code> para CD-ROM Mitsumi, <code>scd</code> para CD-ROM Sony, <code>matcd</code> para CD-ROM Matsushita/Panasonic</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Unidades de disquete (floppy)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>fd</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Unidades de cinta SCSI</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>sa</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Unidades de cinta IDE</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>ast</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Unidades Flash</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>fla</code> para dispositivos DiskOnChip®</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Unidades RAID</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>aacd</code> para Adaptec® AdvancedRAID, <code>mlxd</code> y <code>mlyd</code> para Mylex®, <code>amrd</code> para AMI MegaRAID®, <code>idad</code> para Compaq Smart RAID, <code>twed</code> para 3ware® RAID.</p></td></tr></tbody></table></div><div class=sect2><h3 id=disks-adding>18.3. Añadir discos<a class=anchor href=#disks-adding></a></h3><div class=paragraph><p>Digamos que queremos añadir un nuevo disco SCSI a una máquina que solo tiene un disco. Comience por apagar el sistema e instale el disco siguiendo las instrucciones del fabricante de la computadora, del disco y de la controladora. Debido a la gran variedad de procedimientos posibles los detalles están más allá del alcance de este texto.</p></div><div class=paragraph><p>Entre como usuario <code>root</code>. Una vez instalado el disco inspeccione <span class=filename>/var/run/dmesg.boot</span> para asegurarse de que el sistema encontró el nuevo disco. Continuando con nuestro ejemplo, el disco recién añadido será <span class=filename>da1</span> y queremos montarlo en <span class=filename>/1</span> (si está añadiendo un disco IDE, el nombre de dispositivo será <span class=filename>wd1</span> en sistemas anteriores a 4.0, y <span class=filename>ad1</span> en sistemas 4.X y 5.X).</p></div><div class=paragraph><p>FreeBSD funciona en computadoras IBM-PC y compatibles, por lo tanto tendrá en cuenta las particiones de la BIOS del PC, que son diferentes del tipo de partición que se ha venido usando en BSD. Un disco para PC puede contener hasta cuatro entradas de particiones BIOS. Si el disco va a utilizarse íntegramente con FreeBSD puede usar el modo <em>dedicado</em>. Si no, FreeBSD tendrá que instalarse dentro de una las particiones BIOS. En FreeBSD se llama slices ("porciones" o "rebanadas") a las particiones de PC BIOS para no confundirlas con las particiones BSD. También puede utilizar slices en un disco dedicado a FreeBSD pero que se está usando en un sistema que también tiene otro sistema operativo instalado. Esta es una buena manera de evitar confundir la versión de <code>fdisk</code> de otros sistemas operativos.</p></div><div class=paragraph><p>Desde el punto de vista de las slices el disco se añadirá como <span class=filename>/dev/da1s1e</span>. Se interpreta del siguiente modo: disco SCSI, unidad número 1 (segundo disco SCSI), slice 1 (partición 1 de PC BIOS), y partición BSD <span class=filename>e</span>. Si es un disco dedicado, el disco se añadirá como <span class=filename>/dev/da1e</span>.</p></div><div class=paragraph><p>Debido al uso de enteros de 32-bits para almacenar el número de sectores, <a href="https://man.freebsd.org/cgi/man.cgi?query=bsdlabel&amp;sektion=8&amp;format=html">bsdlabel(8)</a> (llamado <a href="https://man.freebsd.org/cgi/man.cgi?query=disklabel&amp;sektion=8&amp;format=html">disklabel(8)</a> en FreeBSD 4.X) está limitado a 2^32-1 sectores por disco ó 2TB (en la mayoría de los casos). El formato de <a href="https://man.freebsd.org/cgi/man.cgi?query=fdisk&amp;sektion=8&amp;format=html">fdisk(8)</a> permite un sector de arranque de un máximo de más de 2^32-1 y no más de 2^32-1 de longitud, limitando las particiones a 2TB y los discos a 4TB (también en la mayoría de los casos). El formato <a href="https://man.freebsd.org/cgi/man.cgi?query=sunlabel&amp;sektion=8&amp;format=html">sunlabel(8)</a> tiene una limitación de 2^32-1 sectores por partición y 8 particiones en un espacio máximo de 16TB. Si va a usar discos mayores puede usar particiones <a href="https://man.freebsd.org/cgi/man.cgi?query=gpt&amp;sektion=8&amp;format=html">gpt(8)</a>.</p></div><div class=sect3><h4 id=_uso_de_sysinstall8>18.3.1. Uso de <a href="https://man.freebsd.org/cgi/man.cgi?query=sysinstall&amp;sektion=8&amp;format=html">sysinstall(8)</a><a class=anchor href=#_uso_de_sysinstall8></a></h4><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Navegar en Sysinstall</p><div class=paragraph><p>Puede utilizar <code>sysinstall</code> (<code>/stand/sysinstall</code> en versiones de FreeBSD anteriores a 5.2) para particionar y etiquetar un disco nuevo usando sus intuitivos menús. Entre como el usuario <code>root</code> o utilice <code>su</code>. Ejecute <code>sysinstall</code> y entre al menú <code>Configure</code>. Dentro de <code>FreeBSD Configuration Menu</code>, descienda y seleccione la opción <code>Fdisk</code>.</p></div></li><li><p>Editor de particiones fdisk</p><div class=paragraph><p>Una vez dentro de fdisk, teclée <code>A</code> si quiere usar el disco entero con FreeBSD Cuando se le pregunte "remain cooperative with any future possible operating systems", responda <code>YES</code>. Escriba los cambios al disco pulsando <code>W</code>. Salga del editor FDISK pulsando <code>q</code>. A continuación se le preguntará sobre el "Master Boot Record". Debido a que está añadiendo un nuevo disco a un sistema que ya está instalado, tendrá que seleccionar <code>None</code>.</p></div></li><li><p>Editor de etiquetas de disco</p><div class=paragraph><p>A continuación, debe salir de sysinstall e iniciarlo de nuevo. Siga las instrucciones arriba expuestas, pero esta vez elija la opción <code>Label</code>. De este modo accederá al <code>editor de etiquetas de disco</code>. En él creará las particiones BSD tradicionales. Un disco puede tener hasta ocho particiones, etiquetadas desde la <code>a</code> a la <code>h</code>. Algunas de las etiquetas de las particiones tienen usos especiales. La partición <code>a</code> se utiliza para la partición raíz (<span class=filename>/</span>), por lo tanto sólo su disco de sistema (esto es, el disco desde el cual arranca) tendrá una partición <code>a</code>. La partición <code>b</code> se usa como partición swap; puede tener más de una partición swap y puede alojarlas en más de un disco. La partición <code>c</code> hace referencia al disco entero en modo dedicado, o a la slice de FreeBSD completa en modo slice. Las demás particiones son para el resto de los usos típicos.</p></div><div class=paragraph><p>El editor de etiquetas de sysinstall creará la partición <code>e</code> como partición "ni raíz, ni swap". En el editor de etiquetas crée un solo sistema de ficheros tecleando <code>C</code>. Cuando se le pregunte si debe etiquetarse como FS (sistema de ficheros) o swap, elija <code>FS</code> y teclée un punto de montaje (por ejemplo <span class=filename>/mnt</span>). Al añadir un disco en modo "post-instalación"sysinstall no creará automáticamente las entradas correspondientes en <span class=filename>/etc/fstab</span>, por lo que el punto de montaje que usted especifique no tiene importancia.</p></div><div class=paragraph><p>Ahora puede escribir la nueva etiqueta al disco y crear un sistema de ficheros en él tecleando <code>W</code>. Ignore cualquier error que pudiera generar sysinstall acerca de dificultades para montar la nueva partición. Salga del editor de etiquetas y de sysinstall.</p></div></li><li><p>Terminar</p><div class=paragraph><p>El último paso es editar <span class=filename>/etc/fstab</span> y añadir una entrada para su nuevo disco.</p></div></li></ol></div></div></div></div><div class=sect3><h4 id=_uso_de_utilidades_de_línea_de_comandos>18.3.2. Uso de utilidades de línea de comandos<a class=anchor href=#_uso_de_utilidades_de_línea_de_comandos></a></h4><div class=sect4><h5 id=_uso_de_slices>18.3.2.1. Uso de slices<a class=anchor href=#_uso_de_slices></a></h5><div class=paragraph><p>Esta configuración le permitirá a su disco convivir sin sobresaltos con otro sistema operativo que pueda estar instalado en su sistema y no confundirá a las utilidades <code>fdisk</code> de esos otros sistemas operativos. Se recomienda utilizar este método para instalar discos nuevos. <em>Utilice el modo dedicado sólamente si tiene un buen motivo para hacerlo</em>.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dd if=/dev/zero of=/dev/da1 bs=1k count=1</span>
<span class=c># fdisk -BI da1 #Initialice el nuevo disco.</span>
<span class=c># disklabel -B -w -r da1s1 auto #Etiquételo.</span>
<span class=c># disklabel -e da1s1 # Edite la etiqueta de disco que acaba de crear y añada particiones.</span>
<span class=c># mkdir -p /1</span>
<span class=c># newfs /dev/da1s1e # Repita este paso por cada partición que crée.</span>
<span class=c># mount /dev/da1s1e /1 # Monte la partición o particiones.</span>
<span class=c># vi /etc/fstab # Añada la/s entrada/s apropiadas en /etc/fstab.</span></code></pre></div></div><div class=paragraph><p>Si tiene un disco IDE, sustituya <span class=filename>ad</span> por <span class=filename>da</span>. En sistemas anteriores a 4.X utilice <span class=filename>wd</span>.</p></div></div><div class=sect4><h5 id=_dedicado>18.3.2.2. Dedicado<a class=anchor href=#_dedicado></a></h5><div class=paragraph><p>Si no va a compartir el nuevo disco con otro sistema operativo puede utilizar el modo <code>dedicado</code>. Recuerde que este modo puede confundir a los sistemas operativos de Microsoft, aunque no podrán dañar por ello el disco o su contenido. Tenga en cuenta que FreeBSD (de IBM) se "apropiará" de cualquier partición que encuentre y no entienda.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dd if=/dev/zero of=/dev/da1 bs=1k count=1</span>
<span class=c># disklabel -Brw da1 auto</span>
<span class=c># disklabel -e da1				# crear partición `e&#39;</span>
<span class=c># newfs -d0 /dev/da1e</span>
<span class=c># mkdir -p /1</span>
<span class=c># vi /etc/fstab				# agregar una entrada para /dev/da1e</span>
<span class=c># mount /1</span></code></pre></div></div><div class=paragraph><p>Una forma alternativa de hacerlo sería:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dd if=/dev/zero of=/dev/da1 count=2</span>
<span class=c># disklabel /dev/da1 | disklabel -BrR da1 /dev/stdin</span>
<span class=c># newfs /dev/da1e</span>
<span class=c># mkdir -p /1</span>
<span class=c># vi /etc/fstab					# añadir una entrada para /dev/da1e</span>
<span class=c># mount /1</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>A partir de FreeBSD 5.1-RELEASE, la utilidad <a href="https://man.freebsd.org/cgi/man.cgi?query=bsdlabel&amp;sektion=8&amp;format=html">bsdlabel(8)</a> reemplazó al antiguo programa <a href="https://man.freebsd.org/cgi/man.cgi?query=disklabel&amp;sektion=8&amp;format=html">disklabel(8)</a>. En <a href="https://man.freebsd.org/cgi/man.cgi?query=bsdlabel&amp;sektion=8&amp;format=html">bsdlabel(8)</a> se han eliminado muchos parámetros y opciones obsoletas; en los ejemplos de arriba la opción <code>-r</code> debe eliminarse si se usa <a href="https://man.freebsd.org/cgi/man.cgi?query=bsdlabel&amp;sektion=8&amp;format=html">bsdlabel(8)</a>. Para más información diríjase al manual de <a href="https://man.freebsd.org/cgi/man.cgi?query=bsdlabel&amp;sektion=8&amp;format=html">bsdlabel(8)</a>.</p></div></td></tr></tbody></table></div></div></div></div><div class=sect2><h3 id=raid>18.4. RAID<a class=anchor href=#raid></a></h3><div class=sect3><h4 id=raid-soft>18.4.1. Software RAID<a class=anchor href=#raid-soft></a></h4><div class=sect4><h5 id=ccd>18.4.1.1. Configuración de controlador de disco concatenado (CCD)<a class=anchor href=#ccd></a></h5><div class=paragraph><p>Al escoger una solución de almacenamiento masivo los factores más importantes a considerar son velocidad, fiabilidad y coste. Es raro tener los tres por igual; normalmente un dispositivo de almacenamiento masivo veloz y fiable es caro, y para recortar los costes suele sacrificarse la velocidad o la fiabilidad.</p></div><div class=paragraph><p>Al diseñar el sistema descrito más adelante se eligió el coste como el factor más importante, seguido de la velocidad, y luego la fiabilidad. La velocidad de transferencia de datos para este sistema está, en última instancia, limitada por la red. Y mientras que la confiabilidad es muy importante, el controlador CCD descrito más adelante sirve datos que están respaldados en CD-R y pueden ser reemplazados sin dificultad.</p></div><div class=paragraph><p>Al escoger una solución de almacenamiento masivo el primer paso es definir sus necesidades. Si prefiere velocidad o fiabilidad por encima del coste, el resultado será distinto del que vamos a describir en esta sección.</p></div><div class=sect5><h6 id=ccd-installhw>18.4.1.1.1. Instalación del hardware<a class=anchor href=#ccd-installhw></a></h6><div class=paragraph><p>Además del disco IDE, el núcleo del disco CCD está compuesto por tres discos IDE discos IDE Western Digital de 30GB y 5400 RPM, que ofrecen aproximadamente 90GB de almacenamiento. Lo ideal sería que cada disco IDE tuviera su propio cable y controlador, pero para minimizar costes no se utilizaron controladores IDE adicionales. En lugar de eso se configuraron los discos con "jumpers" para que cada controlador IDE tuviera un maestro y un esclavo.</p></div><div class=paragraph><p>Despues de reiniciar la BIOS se configuró para que detectara automáticamente los discos conectados. FreeBSD los detectó al reiniciar:</p></div><div class="literalblock programlisting"><div class=content><pre>ad0: 19574MB &lt;WDC WD205BA&gt; [39770/16/63] at ata0-master UDMA33
ad1: 29333MB &lt;WDC WD307AA&gt; [59598/16/63] at ata0-slave UDMA33
ad2: 29333MB &lt;WDC WD307AA&gt; [59598/16/63] at ata1-master UDMA33
ad3: 29333MB &lt;WDC WD307AA&gt; [59598/16/63] at ata1-slave UDMA33</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Si FreeBSD no detecta todos los discos asegúrese de que ha colocado correctamente los "jumpers". La mayoría de los discos IDE tienen un "jumper""Cable Select". Este <em>no</em> es el "jumper" que define la relación maestro/esclavo. Consulte la documentación del disco para identificar el "jumper" correcto.</p></div></td></tr></tbody></table></div><div class=paragraph><p>El siguiente paso es estudiar cómo conectarlos para que formen parte del sistema de ficheros. Investigue Debe investigar <a href="https://man.freebsd.org/cgi/man.cgi?query=vinum&amp;sektion=8&amp;format=html">vinum(8)</a> (<a href=./#vinum>El Gestor de Volúmenes Vinum</a>) y <a href="https://man.freebsd.org/cgi/man.cgi?query=ccd&amp;sektion=4&amp;format=html">ccd(4)</a>. Nosotros elegimos <a href="https://man.freebsd.org/cgi/man.cgi?query=ccd&amp;sektion=4&amp;format=html">ccd(4)</a> para nuestra configuración.</p></div></div><div class=sect5><h6 id=ccd-setup>18.4.1.1.2. Configuración de CCD<a class=anchor href=#ccd-setup></a></h6><div class=paragraph><p>El controlador <a href="https://man.freebsd.org/cgi/man.cgi?query=ccd&amp;sektion=4&amp;format=html">ccd(4)</a> le permite tomar varios discos idénticos y concatenarlos en un solo sistema lógico de ficheros. Para poder usar <a href="https://man.freebsd.org/cgi/man.cgi?query=ccd&amp;sektion=4&amp;format=html">ccd(4)</a> necesita un kernel compilado con soporte de <a href="https://man.freebsd.org/cgi/man.cgi?query=ccd&amp;sektion=4&amp;format=html">ccd(4)</a>. Añada esta línea al fichero de configuración de su kernel, recompile y reinstale su kernel:</p></div><div class="literalblock programlisting"><div class=content><pre>pseudo-device   ccd     4</pre></div></div><div class=paragraph><p>En sistemas 5.X, use la siguiente línea:</p></div><div class="literalblock programlisting"><div class=content><pre>device   ccd</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>En FreeBSD 5.X no es necesario especificar un número de dispositivos <a href="https://man.freebsd.org/cgi/man.cgi?query=ccd&amp;sektion=4&amp;format=html">ccd(4)</a>, ya que el controlador de dispositivo <a href="https://man.freebsd.org/cgi/man.cgi?query=ccd&amp;sektion=4&amp;format=html">ccd(4)</a> es capaz de clonarse a sí mismo (se crearán nuevas instancias de dispositivo automáticamente según vayan haciendo falta).</p></div></td></tr></tbody></table></div><div class=paragraph><p>El soporte de <a href="https://man.freebsd.org/cgi/man.cgi?query=ccd&amp;sektion=4&amp;format=html">ccd(4)</a> también puede cargarse como módulo en FreeBSD 3.0 y posteriores.</p></div><div class=paragraph><p>Para configurar <a href="https://man.freebsd.org/cgi/man.cgi?query=ccd&amp;sektion=4&amp;format=html">ccd(4)</a> tendrá que usar <a href="https://man.freebsd.org/cgi/man.cgi?query=disklabel&amp;sektion=8&amp;format=html">disklabel(8)</a> para etiquetar los discos:</p></div><div class="literalblock programlisting"><div class=content><pre>disklabel -r -w ad1 auto
disklabel -r -w ad2 auto
disklabel -r -w ad3 auto</pre></div></div><div class=paragraph><p>Esto crea una etiqueta de disco para <span class=filename>ad1c</span>, <span class=filename>ad2c</span> y <span class=filename>ad3c</span> que abarcan el disco completo.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>A partir de FreeBSD 5.1-RELEASE <a href="https://man.freebsd.org/cgi/man.cgi?query=bsdlabel&amp;sektion=8&amp;format=html">bsdlabel(8)</a> reemplazó al antiguo programa <a href="https://man.freebsd.org/cgi/man.cgi?query=disklabel&amp;sektion=8&amp;format=html">disklabel(8)</a>. En <a href="https://man.freebsd.org/cgi/man.cgi?query=bsdlabel&amp;sektion=8&amp;format=html">bsdlabel(8)</a> se eliminaron muchas opciones y parámetros obsoletos; en los ejemplos de arriba la opción <code>-r</code> deben obviarse. Para más información consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=bsdlabel&amp;sektion=8&amp;format=html">bsdlabel(8)</a>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>El siguiente paso es cambiar el tipo de etiqueta de disco. Edite los discos con <a href="https://man.freebsd.org/cgi/man.cgi?query=disklabel&amp;sektion=8&amp;format=html">disklabel(8)</a>:</p></div><div class="literalblock programlisting"><div class=content><pre>disklabel -e ad1
disklabel -e ad2
disklabel -e ad3</pre></div></div><div class=paragraph><p>Esto abre la etiqueta de disco de cada disco con el editor declarado en la variable de entorno <code>EDITOR</code>, por defecto <a href="https://man.freebsd.org/cgi/man.cgi?query=vi&amp;sektion=1&amp;format=html">vi(1)</a>.</p></div><div class=paragraph><p>Esta es una etiqueta de disco sin modificar:</p></div><div class="literalblock programlisting"><div class=content><pre>8 partitions:
#        size   offset    fstype   [fsize bsize bps/cpg]
  c: 60074784        0    unused        0     0     0   # (Cyl.    0 - 59597)</pre></div></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=ccd&amp;sektion=4&amp;format=html">ccd(4)</a> necesita que añada una nueva partición <code>e</code>. Puede copiarla desde la partición <code>c</code>, pero el tipo de sistema de ficheros (la opción <code>fstype</code>) debe ser <code>4.2BSD</code>. La etiqueta del disco debería tener este aspecto:</p></div><div class="literalblock programlisting"><div class=content><pre>8 partitions:
#        size   offset    fstype   [fsize bsize bps/cpg]
  c: 60074784        0    unused        0     0     0   # (Cyl.    0 - 59597)
  e: 60074784        0    4.2BSD        0     0     0   # (Cyl.    0 - 59597)</pre></div></div></div><div class=sect5><h6 id=ccd-buildingfs>18.4.1.1.3. Contrucción del sistema de ficheros<a class=anchor href=#ccd-buildingfs></a></h6><div class=paragraph><p>Puede que todavía no exista el nodo de dispositivo para <span class=filename>ccd0c</span>. Si es así, ejecute lo siguiente:</p></div><div class="literalblock programlisting"><div class=content><pre>cd /dev
sh MAKEDEV ccd0</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>En FreeBSD 5.0 <a href="https://man.freebsd.org/cgi/man.cgi?query=devfs&amp;sektion=5&amp;format=html">devfs(5)</a> administrará automáticamente los nodos de dispositivos en <span class=filename>/dev</span>, así que no tendrá que usar <code>MAKEDEV</code>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Una vez etiquetados todos los discos construya el <a href="https://man.freebsd.org/cgi/man.cgi?query=ccd&amp;sektion=4&amp;format=html">ccd(4)</a>. Utilice <a href="https://man.freebsd.org/cgi/man.cgi?query=ccdconfig&amp;sektion=8&amp;format=html">ccdconfig(8)</a> con opciones similares a las siguientes:</p></div><div class="literalblock programlisting"><div class=content><pre>ccdconfig ccd0 32 0 /dev/ad1e /dev/ad2e /dev/ad3e</pre></div></div><div class=ulist><ul><li><p>El uso y el significado de cada una de las opciones se muestra más abajo:</p></li><li><p>El primer argumento es el dispositivo a configurar, en este caso <span class=filename>/dev/ccd0c</span>. La parte <span class=filename>/dev/</span> es opcional.</p></li><li><p>El intervalo para el sistema de ficheros. El intervalo define el tamaño de una banda en bloques de disco, normalmente 512 bytes. Por lo tanto, un intervalo de 32 equivaldría 16.384 bytes.
Banderas para <a href="https://man.freebsd.org/cgi/man.cgi?query=ccdconfig&amp;sektion=8&amp;format=html">ccdconfig(8)</a>. Si desea disponer sus discos en espejo use aquí una bandera. Esta configuración no necesita discos en espejo, por lo que está dispuesta a 0 (cero).</p></li><li><p>Los últimos argumentos de <a href="https://man.freebsd.org/cgi/man.cgi?query=ccdconfig&amp;sektion=8&amp;format=html">ccdconfig(8)</a> son los dispositivos a colocar en el array. Utilice la ruta completa para cada dispositivo.</p></li></ul></div><div class=paragraph><p>Despues de ejecutar <a href="https://man.freebsd.org/cgi/man.cgi?query=ccdconfig&amp;sektion=8&amp;format=html">ccdconfig(8)</a> el <a href="https://man.freebsd.org/cgi/man.cgi?query=ccd&amp;sektion=4&amp;format=html">ccd(4)</a> estará configurado y podrá instalar un sistema de ficheros. Consulte las opciones de <a href="https://man.freebsd.org/cgi/man.cgi?query=newfs&amp;sektion=8&amp;format=html">newfs(8)</a> y ejecute:</p></div><div class="literalblock programlisting"><div class=content><pre>newfs /dev/ccd0c</pre></div></div></div><div class=sect5><h6 id=ccd-auto>18.4.1.1.4. Automatización<a class=anchor href=#ccd-auto></a></h6><div class=paragraph><p>Seguramente querrá que <a href="https://man.freebsd.org/cgi/man.cgi?query=ccd&amp;sektion=4&amp;format=html">ccd(4)</a> esté dispuesto tras cada reinicio. Para ello, debe configurarlo. Guarde su configuración en <span class=filename>/etc/ccd.conf</span> mediante lo siguiente:</p></div><div class="literalblock programlisting"><div class=content><pre>ccdconfig -g &gt; /etc/ccd.conf</pre></div></div><div class=paragraph><p>Durante el reinicio, el "script" <code>/etc/rc</code> ejecuta <code>ccdconfig -C</code> si encuentra el fichero <span class=filename>/etc/ccd.conf</span>. De este modo <a href="https://man.freebsd.org/cgi/man.cgi?query=ccd&amp;sektion=4&amp;format=html">ccd(4)</a> queda configurado automáticamente para que pueda montarse.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Si ha arrancando en modo mono usuario necesita ejecutar el siguiente comando antes de que pueda montar el <a href="https://man.freebsd.org/cgi/man.cgi?query=ccd&amp;sektion=4&amp;format=html">ccd(4)</a> para configurar el array:</p></div><div class="literalblock programlisting"><div class=content><pre>ccdconfig -C</pre></div></div></td></tr></tbody></table></div><div class=paragraph><p>Para montar automaticamente el <a href="https://man.freebsd.org/cgi/man.cgi?query=ccd&amp;sektion=4&amp;format=html">ccd(4)</a> coloque una entrada para <a href="https://man.freebsd.org/cgi/man.cgi?query=ccd&amp;sektion=4&amp;format=html">ccd(4)</a> en <span class=filename>/etc/fstab</span> para que se monte durante el arranque:</p></div><div class="literalblock programlisting"><div class=content><pre>/dev/ccd0c              /media       ufs     rw      2       2</pre></div></div></div></div><div class=sect4><h5 id=vinum>18.4.1.2. El administrador de volúmenes Vinum<a class=anchor href=#vinum></a></h5><div class=paragraph><p>El administrador de volúmenes Vinum es un controlador de dispositivos de bloque que implementa unidades de disco virtuales. Aísla los discos hardware de la interfaz de dispositivos de bloque y mapea datos de modo que revierta en un incremento de flexibilidad, rendimiento y fiabilidad comparados con el sistema de slices de almacenamiento de disco tradicional. <a href="https://man.freebsd.org/cgi/man.cgi?query=vinum&amp;sektion=8&amp;format=html">vinum(8)</a> implementa los modelos RAID-0, RAID-1 y RAID-5, individualmente o combinados.</p></div><div class=paragraph><p>Consulte el (<a href=./#vinum>El Gestor de Volúmenes Vinum</a>) para mayor información sobre <a href="https://man.freebsd.org/cgi/man.cgi?query=vinum&amp;sektion=8&amp;format=html">vinum(8)</a>.</p></div></div></div><div class=sect3><h4 id=raid-hard>18.4.2. RAID por Hardware<a class=anchor href=#raid-hard></a></h4><div class=paragraph><p>FreeBSD admite una gran variedad de controladores RAID por hardware. Estos dispositivos controlan un subsistema RAID sin necesidad de software específico para FreeBSD que administre el array.</p></div><div class=paragraph><p>Puede controlar la mayoría de las operaciones de disco con una tarjeta que incorpore BIOS. El siguiente texto es una breve descripción de configuración utilizando una controladora Promise RAIDIDE. Cuando se instala esta tarjeta e inicia el sistema despliega un "prompt" pidiendo información. Siga las instrucciones para entrar a la pantalla de configuración de la tarjeta. Ahí tendrá posibilidad de combinar todos los discos que haya conectado. Hecho esto el disco (o discos) aparecerán como una sola unidad en FreeBSD. Pueden configurarse otros niveles de RAID.</p></div></div><div class=sect3><h4 id=_reconstrucción_de_arrays_ata_raid1>18.4.3. Reconstrucción de arrays ATA RAID1<a class=anchor href=#_reconstrucción_de_arrays_ata_raid1></a></h4><div class=paragraph><p>FreeBSD le permite reemplazar en caliente un disco dañado. Esto requiere que lo intercepte antes de reiniciar.</p></div><div class=paragraph><p>Probablemente vea algo como lo siguiente en <span class=filename>/var/log/messages</span> o en la salida de <a href="https://man.freebsd.org/cgi/man.cgi?query=dmesg&amp;sektion=8&amp;format=html">dmesg(8)</a>:</p></div><div class="literalblock programlisting"><div class=content><pre>ad6 on monster1 suffered a hard error.
ad6: READ command timeout tag=0 serv=0 - resetting
ad6: trying fallback to PIO mode
ata3: resetting devices .. done
ad6: hard error reading fsbn 1116119 of 0-7 (ad6 bn 1116119; cn 1107 tn 4 sn 11)\\
status=59 error=40
ar0: WARNING - mirror lost</pre></div></div><div class=paragraph><p>Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=atacontrol&amp;sektion=8&amp;format=html">atacontrol(8)</a> para más información:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># atacontrol list</span>
ATA channel 0:
	Master:      no device present
	Slave:   acd0 &lt;HL-DT-ST CD-ROM GCR-8520B/1.00&gt; ATA/ATAPI rev 0

ATA channel 1:
	Master:      no device present
	Slave:       no device present

ATA channel 2:
	Master:  ad4 &lt;MAXTOR 6L080J4/A93.0500&gt; ATA/ATAPI rev 5
	Slave:       no device present

ATA channel 3:
	Master:  ad6 &lt;MAXTOR 6L080J4/A93.0500&gt; ATA/ATAPI rev 5
	Slave:       no device present

<span class=c># atacontrol status ar0</span>
ar0: ATA RAID1 subdisks: ad4 ad6 status: DEGRADED</code></pre></div></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Primero debe desconectar el disco del array para que pueda retirarlo con seguridad:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># atacontrol detach 3</span></code></pre></div></div></li><li><p>Reemplace el disco.</p></li><li><p>Conecte el disco de repuesto:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># atacontrol attach 3</span>
Master:  ad6 &lt;MAXTOR 6L080J4/A93.0500&gt; ATA/ATAPI rev 5
Slave:   no device present</code></pre></div></div></li><li><p>Reconstruya el array:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># atacontrol rebuild ar0</span></code></pre></div></div></li><li><p>El comando de reconstrucción no responderá hasta que termine la tarea. Puede abrir otra terminal (mediante <span class=keyseq><kbd>Alt</kbd>+<kbd>Fn</kbd></span>) y revisar el progreso ejecutando lo siguiente:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dmesg | tail -10</span>
<span class=o>[</span>texto eliminado]
ad6: removed from configuration
ad6: deleted from ar0 disk1
ad6: inserted into ar0 disk1 as spare

<span class=c># atacontrol status ar0</span>
ar0: ATA RAID1 subdisks: ad4 ad6 status: REBUILDING 0 completed</code></pre></div></div></li><li><p>Espere hasta que termine la operación.</p></li></ol></div></div></div></div></div><div class=sect2><h3 id=usb-disks>18.5. Dispositivos de almacenamiento USB<a class=anchor href=#usb-disks></a></h3><div class=paragraph><p>Hoy día hay una enorme cantidad de soluciones de almacenamiento externoque usan el bus serie universal (USB): discos duros, "mecheros" (o "lápices") USB, grabadoras de CD-R, etc. FreeBSD puede usar estos dispositivos.</p></div><div class=sect3><h4 id=_configuración_2>18.5.1. Configuración<a class=anchor href=#_configuración_2></a></h4><div class=paragraph><p>El controlador de dispositivos de almacenamiento masivo USB, <a href="https://man.freebsd.org/cgi/man.cgi?query=umass&amp;sektion=4&amp;format=html">umass(4)</a>, ofrece soporte para dispositivos de almacenamiento USB. Si usa el kernel <span class=filename>GENERIC</span> no necesita cambiar nada en su configuración. Si utiliza un kernel personalizado asegúrese de que su fichero de configuración del kernel contiene las siguientes líneas:</p></div><div class="literalblock programlisting"><div class=content><pre>device scbus
device da
device pass
device uhci
device ohci
device usb
device umass</pre></div></div><div class=paragraph><p>El controlador <a href="https://man.freebsd.org/cgi/man.cgi?query=umass&amp;sektion=4&amp;format=html">umass(4)</a> usa el subsistema SCSI para acceder a los dispositivos de almacenamiento USB y su dispositivo USB aparecerá en el sistema como dispositivo SCSI. Dependiendo del chipset USB de su placa base sólamente necesitará <code>device uhci</code> o <code>device ohci</code>; en cualquier caso tener los dos en el fichero de configuración del kernel no provocará ningún daño. No olvide compilar e instalar el nuevo kernel si hizo alguna modificación.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Si su dispositivo USB es una grabadora CD-R o DVD el controlador SCSI CD-ROM, <a href="https://man.freebsd.org/cgi/man.cgi?query=cd&amp;sektion=4&amp;format=html">cd(4)</a>, debe ser añadirse al kernel mediante la siguiente línea:</p></div><div class="literalblock programlisting"><div class=content><pre>device cd</pre></div></div><div class=paragraph><p>Dado que la grabadora aparece como una unidad SCSI no tiene que usar el controlador <a href="https://man.freebsd.org/cgi/man.cgi?query=atapicam&amp;sektion=4&amp;format=html">atapicam(4)</a> en la configuración del kernel.</p></div></td></tr></tbody></table></div><div class=paragraph><p>En FreeBSD 5.X y en la rama 4.X desde FreeBSD 4.10-RELEASE el soporte para controladores USB 2.0 se incorpora al sistema del siguiente modo:</p></div><div class="literalblock programlisting"><div class=content><pre>device ehci</pre></div></div><div class=paragraph><p>Tenga en cuenta que <a href="https://man.freebsd.org/cgi/man.cgi?query=uhci&amp;sektion=4&amp;format=html">uhci(4)</a> y <a href="https://man.freebsd.org/cgi/man.cgi?query=ohci&amp;sektion=4&amp;format=html">ohci(4)</a> siguen siendo necesarios si quiere disponer de soporte para USB 1.X.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>En FreeBSD 4.X, El dæmon USB (<a href="https://man.freebsd.org/cgi/man.cgi?query=usbd&amp;sektion=8&amp;format=html">usbd(8)</a>) debe ejecutarse para poder ver ciertos tipos de dispositivo USB. Para habilitarlo, añada <code>usbd_enable="YES"</code> en <span class=filename>/etc/rc.conf</span> y reinicie la máquina.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=_prueba_de_la_configuración>18.5.2. Prueba de la configuración<a class=anchor href=#_prueba_de_la_configuración></a></h4><div class=paragraph><p>La configuración está lista para probarse: conecte su dispositivo USB; en el búfer de mensajes del sistema (<a href="https://man.freebsd.org/cgi/man.cgi?query=dmesg&amp;sektion=8&amp;format=html">dmesg(8)</a>), la unidad debe aparecer como algo similar a esto:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>umass0: USB Solid state disk, rev 1.10/1.00, addr 2
GEOM: create disk da0 <span class=nv>dp</span><span class=o>=</span>0xc2d74850
da0 at umass-sim0 bus 0 target 0 lun 0
da0: &lt;Generic Traveling Disk 1.11&gt; Removable Direct Access SCSI-2 device
da0: 1.000MB/s transfers
da0: 126MB <span class=o>(</span>258048 512 byte sectors: 64H 32S/T 126C<span class=o>)</span></code></pre></div></div><div class=paragraph><p>Obviamente la marca, el nodo de dispositivo (<span class=filename>da0</span>) y otros detalles pueden diferir dependiendo de su hardware.</p></div><div class=paragraph><p>Ya que el dispositivo USB aparece como uno SCSI, puede usar <code>camcontrol</code> para ver una lista de dispositivos USB conectados al sistema:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># camcontrol devlist</span>
&lt;Generic Traveling Disk 1.11&gt;      at scbus0 target 0 lun 0 <span class=o>(</span>da0,pass0<span class=o>)</span></code></pre></div></div><div class=paragraph><p>Si la unidad tiene un sistema de ficheros puede montarla. La <a href=#disks-adding>Añadir discos</a> contiene información que le resultará muy útil para formatear y crear particiones en el disco USB en caso de necesitarlo.</p></div><div class=paragraph><p>Si desconecta el dispositivo (el disco debe desmontarse previamente), debería ver en el búfer de mensajes del sistema algo parecido a esto:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>umass0: at uhub0 port 1 <span class=o>(</span>addr 2<span class=o>)</span> disconnected
<span class=o>(</span>da0:umass-sim0:0:0:0<span class=o>)</span>: lost device
<span class=o>(</span>da0:umass-sim0:0:0:0<span class=o>)</span>: removing device entry
GEOM: destroy disk da0 <span class=nv>dp</span><span class=o>=</span>0xc2d74850
umass0: detached</code></pre></div></div></div><div class=sect3><h4 id=_lecturas_recomendadas>18.5.3. Lecturas recomendadas<a class=anchor href=#_lecturas_recomendadas></a></h4><div class=paragraph><p>Ademas de las secciones <a href=#disks-adding>Cómo añadir discos</a> y <a href=./#mount-unmount>Montado y desmontado de sistemas ficheros</a>, consulte las siguientes páginas man: <a href="https://man.freebsd.org/cgi/man.cgi?query=umass&amp;sektion=4&amp;format=html">umass(4)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=camcontrol&amp;sektion=8&amp;format=html">camcontrol(8)</a> y <a href="https://man.freebsd.org/cgi/man.cgi?query=usbdevs&amp;sektion=8&amp;format=html">usbdevs(8)</a>.</p></div></div></div><div class=sect2><h3 id=creating-cds>18.6. Creación y uso de medios ópticos (CD)<a class=anchor href=#creating-cds></a></h3><div class=sect3><h4 id=_introducción_3>18.6.1. Introducción<a class=anchor href=#_introducción_3></a></h4><div class=paragraph><p>Los CD tienen muchas opciones que los hacen distintos de los discos convencionales. Al principio los usuarios no podían escribirlos. Su diseño permite que leamos en ellos sin el retardo del movimiento de una cabeza lectora de una pista a otra. También son mucho más fáciles de transportar de un sistema a otro que muchos otros soportes de información.</p></div><div class=paragraph><p>Los CD tienen pistas, pero son una sección de los que permiten lectura contínua, no una propiedad física del disco. Para crear un CD en FreeBSD debe preparar los ficheros de datos que van a constituir las pistas del CD y luego escribir las pistas al CD.</p></div><div class=paragraph><p>El sistema de ficheros ISO 9660 se diseñó para gestionar estas diferencias. Por desgracia implementa límites de sistema de ficheros que eran comunes en la época en que se diseñó. Por suerte también proporciona un mecanismo de extensiones que permite que CD escritos excediendo dichos límites funcionen en sistemas que no soportan esas extensiones.</p></div><div class=paragraph><p>El port <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/cdrtools/>sysutils/cdrtools</a> incluye <a href="https://man.freebsd.org/cgi/man.cgi?query=mkisofs&amp;sektion=8&amp;format=html">mkisofs(8)</a>, un programa que le permitirá crear un fichero de datos que contenga un sistema de ficheros ISO 9660. Incorpora opciones que soportan varias extensiones. Se describe más adelante.</p></div><div class=paragraph><p>Qué herramienta usar para grabar el CD depende de si su grabadora es ATAPI o no. Las grabadoras de CD ATAPI usan el programa <code>burncd</code>, que forma parte del sistema base. Las grabadoras SCSI y USB usan <code>cdrecord</code>, del port <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/cdrtools/>sysutils/cdrtools</a>.</p></div><div class=paragraph><p><code>burncd</code> no soporta cualquier unidad de grabación. Para saber si una unidad está soportada consulte la siguiente lista de <a href=http://www.freebsd.dk/ata/>unidades CD-R/RW soportadas</a>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Si utiliza FreeBSD 5.X, FreeBSD 4.8-RELEASE o posteriores, puede utilizar <code>cdrecord</code> y otras herramientas para unidades SCSI en hardware ATAPI con el <a href=#atapicam>módulo ATAPI/CAM</a>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Si quiere usar un interfaz gráfico con su software de grabación de CD quizás le guste X-CD-Roast o K3b. Puede instalar estas herramientas como paquetes o desde los ports <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/xcdroast/>sysutils/xcdroast</a> y <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/k3b/>sysutils/k3b</a>, respectivamente. X-CD-Roast y K3b requieren el <a href=#atapicam>módulo ATAPI/CAM</a> si usa hardware ATAPI.</p></div></div><div class=sect3><h4 id=mkisofs>18.6.2. mkisofs<a class=anchor href=#mkisofs></a></h4><div class=paragraph><p>El programa <a href="https://man.freebsd.org/cgi/man.cgi?query=mkisofs&amp;sektion=8&amp;format=html">mkisofs(8)</a> (que forma parte del port <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/cdrtools/>sysutils/cdrtools</a>) genera un sistema de ficheros ISO 9660 que es una imagen de un árbol de directorios en el espacio de nombres del sistema de ficheros UNIX®. Esta es la forma más simple de usarlo:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mkisofs -o ficherodeimagen.iso /ruta/del/árbol</span></code></pre></div></div><div class=paragraph><p>Este comando creará un <em>ficherodeimagen.iso</em> que contenga un sistema de ficheros ISO 9660 que es una copia del árbol ubicado en <em>/ruta/al/árbol</em>. En el proceso, mapeará los nombres de fichero a nombres que se ajusten a las limitaciones del estándar del sistema de ficheros ISO 9660, y excluirá ficheros que posean nombres no característicos de sistemas de ficheros ISO.</p></div><div class=paragraph><p>Existe gran cantidad de opciones que permiten superar esas restricciones. En particular, <code>-R</code> habilita las extensiones Rock Ridge comunes para sistemas UNIX®, <code>-J</code> habilita las extensiones Joliet usadas por sistemas Microsoft y <code>-hfs</code> puede usarse para crear sistemas de ficheros utilizados por Mac OS®.</p></div><div class=paragraph><p>Puede utilizar <code>-U</code> para deshabilitar todas las restricciones de nombres de fichero si quiere crear un CD que se vaya a usar exclusivamente en sistemas FreeBSD. Cuando se usa con <code>-R</code> produce una imagen de sistema de ficheros que es idéntica al árbol FreeBSD origen, aunque puede violar el estándar ISO 9660 de múltiples formas.</p></div><div class=paragraph><p>La última opción de uso general es <code>-b</code>. Se usa para configurar la ubicación de la imagen de arranque que se usará al crear un CD arrancable "El Torito". Esta opción usa como argumento la ruta a la imagen de arranque desde la raíz del árbol de directorios que se va a escribir en el CD. Por defecto <a href="https://man.freebsd.org/cgi/man.cgi?query=mkisofs&amp;sektion=8&amp;format=html">mkisofs(8)</a> crea una imagen ISO en un modo llamado "de emulación de disquete (floppy)", y por lo tanto espera que la imagen de arranque sea exactamente de 1.200, 1.440 o 2880 KB de tamaño. Algunos cargadores de arranque, como el que se usa en los discos de la distribución FreeBSD, no utilizan modo de emulación: se usa la opción <code>-no-emul-boot</code>. Por tanto, si <span class=filename>/tmp/miarranque</span> tiene un sistema FreeBSD arrancable con la imagen de arranque en <span class=filename>/tmp/miarranque/boot/cdboot</span> podría crear la imagen en un sistema de ficheros ISO 9660 en <span class=filename>/tmp/arrancable.iso</span> de la siguiente manera:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mkisofs -R -no-emul-boot -b boot/cdboot -o /tmp/arrancable.iso /tmp/miarranque</span></code></pre></div></div><div class=paragraph><p>Hecho esto, si tiene <span class=filename>vn</span> (FreeBSD 4.X), o <span class=filename>md</span> (FreeBSD 5.X) configurado en su kernel, puede montar el sistema de ficheros del siguiente modo:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># vnconfig -e vn0c /tmp/arrancable.iso</span>
<span class=c># mount -t cd9660 /dev/vn0c /mnt</span></code></pre></div></div><div class=paragraph><p>En FreeBSD 4.X y FreeBSD 5.X proceda del siguiente modo:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mdconfig -a -t vnode -f /tmp/arrancable.iso -u 0</span>
<span class=c># mount -t cd9660 /dev/md0 /mnt</span></code></pre></div></div><div class=paragraph><p>Ahora puede verificar que <span class=filename>/mnt</span> y <span class=filename>/tmp/miarranque</span> sean idénticos.</p></div><div class=paragraph><p>Existen muchas otras opciones que puede usar para depurar el comportamiento de <a href="https://man.freebsd.org/cgi/man.cgi?query=mkisofs&amp;sektion=8&amp;format=html">mkisofs(8)</a>, sobre todo en lo que se refiere al esquema ISO 9660 y la creación de discos Joliet y HFS. Consulte el manual de <a href="https://man.freebsd.org/cgi/man.cgi?query=mkisofs&amp;sektion=8&amp;format=html">mkisofs(8)</a>.</p></div></div><div class=sect3><h4 id=burncd>18.6.3. burncd<a class=anchor href=#burncd></a></h4><div class=paragraph><p>Si tiene una grabadora ATAPI puede usar <code>burncd</code> para grabar una imagen ISO en un CD. <code>burncd</code> forma parte del sistema base, y está en <span class=filename>/usr/sbin/burncd</span>. Su uso es muy sencillo, ya que tiene pocas opciones:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># burncd -f unidaddecd data ficheroimagen.iso fixate</span></code></pre></div></div><div class=paragraph><p>Esto grabará una copia de <em>ficheroimagen.iso</em> en <em>unidadcd</em>. El dispositivo por defecto es <span class=filename>/dev/acd0</span> (o <span class=filename>/dev/acd0c</span> en FreeBSD 4.X). Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=burncd&amp;sektion=8&amp;format=html">burncd(8)</a> para ver las opciones de configuración de velocidad de escritura, expulsión de CD una vez grabado, y escritura de datos de audio.</p></div></div><div class=sect3><h4 id=cdrecord>18.6.4. cdrecord<a class=anchor href=#cdrecord></a></h4><div class=paragraph><p>Si no dispone de una grabadora ATAPI de CD, tendrá que usar <code>cdrecord</code> para grabar sus CD. <code>cdrecord</code> no forma parte del sistema base; instálelo desde el port <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/cdrtools/>sysutils/cdrtools</a> o como paquete. Los cambios en el sistema base pueden hacer que las versiones binarias del programa fallen. Tendrá que actualizar el port cuando actualice su sistema o, si está <a href=#stable>siguiendo la rama -STABLE</a>, actualizar el port cuando haya una nueva versión disponible.</p></div><div class=paragraph><p>Aunque <code>cdrecord</code> tiene muchas opciones, el uso básico es incluso más simple que el de <code>burncd</code>. Así se graba una imagen ISO 9660:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cdrecord dev=dispositivo ficheroimagen.iso</span></code></pre></div></div><div class=paragraph><p>La parte complicada de utilizar <code>cdrecord</code> es encontrar qué <code>dev</code> usar. Utilice la bandera <code>-scanbus</code> para dar con la configuración apropiada. La salida será parecida a la siguiente:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cdrecord -scanbus</span>
Cdrecord 1.9 <span class=o>(</span>i386-unknown-freebsd4.2<span class=o>)</span> Copyright <span class=o>(</span>C<span class=o>)</span> 1995-2000 Jörg Schilling
Using libscg version <span class=s1>&#39;schily-0.1&#39;</span>
scsibus0:
        0,0,0     0<span class=o>)</span> <span class=s1>&#39;SEAGATE &#39;</span> <span class=s1>&#39;ST39236LW       &#39;</span> <span class=s1>&#39;0004&#39;</span> Disk
        0,1,0     1<span class=o>)</span> <span class=s1>&#39;SEAGATE &#39;</span> <span class=s1>&#39;ST39173W        &#39;</span> <span class=s1>&#39;5958&#39;</span> Disk
        0,2,0     2<span class=o>)</span> <span class=k>*</span>
        0,3,0     3<span class=o>)</span> <span class=s1>&#39;iomega  &#39;</span> <span class=s1>&#39;jaz 1GB         &#39;</span> <span class=s1>&#39;J.86&#39;</span> Removable Disk
        0,4,0     4<span class=o>)</span> <span class=s1>&#39;NEC     &#39;</span> <span class=s1>&#39;CD-ROM DRIVE:466&#39;</span> <span class=s1>&#39;1.26&#39;</span> Removable CD-ROM
        0,5,0     5<span class=o>)</span> <span class=k>*</span>
        0,6,0     6<span class=o>)</span> <span class=k>*</span>
        0,7,0     7<span class=o>)</span> <span class=k>*</span>
scsibus1:
        1,0,0   100<span class=o>)</span> <span class=k>*</span>
        1,1,0   101<span class=o>)</span> <span class=k>*</span>
        1,2,0   102<span class=o>)</span> <span class=k>*</span>
        1,3,0   103<span class=o>)</span> <span class=k>*</span>
        1,4,0   104<span class=o>)</span> <span class=k>*</span>
        1,5,0   105<span class=o>)</span> <span class=s1>&#39;YAMAHA  &#39;</span> <span class=s1>&#39;CRW4260         &#39;</span> <span class=s1>&#39;1.0q&#39;</span> Removable CD-ROM
        1,6,0   106<span class=o>)</span> <span class=s1>&#39;ARTEC   &#39;</span> <span class=s1>&#39;AM12S           &#39;</span> <span class=s1>&#39;1.06&#39;</span> Scanner
        1,7,0   107<span class=o>)</span> <span class=k>*</span></code></pre></div></div><div class=paragraph><p>Esta lista muestra los valores <code>dev</code> apropiados para los dispositivos de la lista. Localice su grabadora de CD y utilice los tres números separados por comas como valor para <code>dev</code>. En este caso, el dispositivo CDW es 1,5,0 y por tanto la entrada apropiada sería <code>dev=1,5,0</code>. Hay modos más fáciles de especificar este valor; consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=cdrecord&amp;sektion=1&amp;format=html">cdrecord(1)</a> para más detalles. También es el lugar donde buscar información sobre la escritura de pistas de audio, controlar la velocidad de escritura y muchas más cosas.</p></div></div><div class=sect3><h4 id=duplicating-audiocds>18.6.5. Copiar CD de audio<a class=anchor href=#duplicating-audiocds></a></h4><div class=paragraph><p>Puede duplicar un CD de audio extrayendo los datos de audio del CD a ficheros y escribir estos ficheros en un CD virgen. El proceso es ligeramente diferente en unidades ATAPI y SCSI.</p></div><div class="exampleblock procedure"><div class=content><div class=paragraph><p><strong>Procedure: Unidades SCSI</strong></p></div><div class="olist arabic"><ol class=arabic><li><p>Use <code>cdda2wav</code> para extraer el audio.</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% cdda2wav <span class=nt>-v255</span> <span class=nt>-D2</span>,0 <span class=nt>-B</span> <span class=nt>-Owav</span></code></pre></div></div></li><li><p>Use <code>cdrecord</code> para escribir los ficheros <span class=filename>.wav</span>.</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% cdrecord <span class=nt>-v</span> <span class=nv>dev</span><span class=o>=</span>2,0 <span class=nt>-dao</span> <span class=nt>-useinfo</span>  <span class=k>*</span>.wav</code></pre></div></div><div class=paragraph><p>Asegúrese de que <em>2,0</em> este configurado apropiadamente, como se describe en la <a href=#cdrecord>cdrecord</a>.</p></div></li></ol></div></div></div><div class="exampleblock procedure"><div class=content><div class=paragraph><p><strong>Procedure: Unidades ATAPI</strong></p></div><div class="olist arabic"><ol class=arabic><li><p>El controlador de CD ATAPI hace que cada pista sea accesible como <span class=filename>/dev/acddtnn</span>, donde <em>d</em> es el número de unidad y <em>nn</em> es el número de pista expresado con dos dígitos decimales, precedido por un cero si es necesario. La primera pista del primer disco es <span class=filename>/dev/acd0t01</span>, la segunda es <span class=filename>/dev/acd0t02</span>, la tercera es <span class=filename>/dev/acd0t03</span> y así sucesivamente.</p><div class=paragraph><p>Asegúrese de que existen los ficheros apropiados en <span class=filename>/dev</span>.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /dev</span>
<span class=c># sh MAKEDEV acd0t99</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>En FreeBSD 5.0 <a href="https://man.freebsd.org/cgi/man.cgi?query=devfs&amp;sektion=5&amp;format=html">devfs(5)</a> creará y gestionará automáticamente las entradas necesarias en <span class=filename>/dev</span>, así que no será necesario usar <code>MAKEDEV</code>.</p></div></td></tr></tbody></table></div></li><li><p>Extraer cada pista con <a href="https://man.freebsd.org/cgi/man.cgi?query=dd&amp;sektion=1&amp;format=html">dd(1)</a>. También deberá declarar un tamaño específico de bloque al extraer los ficheros.</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dd if=/dev/acd0t01 of=pista1.cdr bs=2352</span>
<span class=c># dd if=/dev/acd0t02 of=pista2.cdr bs=2352</span>
...</code></pre></div></div></li><li><p>Grabar los ficheros extraídos a disco con <code>burncd</code>. Debe declarar que son ficheros de audio y que <code>burncd</code> debe cerrar ("fixate") el disco al terminar la grabación.</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># burncd -f /dev/acd0 audio pista1.cdr pista2.cdr ... fixate</span></code></pre></div></div></li></ol></div></div></div></div><div class=sect3><h4 id=imaging-cd>18.6.6. Duplicar CDs de datos<a class=anchor href=#imaging-cd></a></h4><div class=paragraph><p>Puede copiar un CD de datos a un fichero de imagen que será funcionalmente equivalente al fichero de imagen creado con <a href="https://man.freebsd.org/cgi/man.cgi?query=mkisofs&amp;sektion=8&amp;format=html">mkisofs(8)</a>, y puede usarlo para duplicar cualquier CD de datos. El ejemplo dado aquí asume que su dispositivo CDROM es <span class=filename>acd0</span>. Sustitúyalo por el dispositivo CDROM correcto para su configuración. Bajo FreeBSD 4.X, se debe añadir una <code>c</code> al final del nombre del dispositivo para indicar la partición entera o, en el caso de los CDROM, el disco entero.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dd if=/dev/acd0 of=fichero.iso bs=2048</span></code></pre></div></div><div class=paragraph><p>Hecha la imagen puede garbarla en un CD como se describió anteriormente.</p></div></div><div class=sect3><h4 id=mounting-cd>18.6.7. Uso de CD de datos<a class=anchor href=#mounting-cd></a></h4><div class=paragraph><p>Ahora que ha creado un CDROM de datos estándar tal vez quiera montarlo y leer los datos que contiene. Por defecto <a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a> asume que los sistemas de ficheros son de tipo <code>ufs</code>. Si trata de hacer algo como</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount /dev/cd0 /mnt</span></code></pre></div></div><div class=paragraph><p>recibirá un error como este: <code>Incorrect super block</code> y no se montará. Un CDROM no es un sistema de ficheros <code>UFS</code> así que los intentos de montarlo como tal fallarán. Tendrá que decirle a <a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a> que el sistema de ficheros es de tipo <code>ISO9660</code> y funcionará. Puede hacerlo mediante la opción <code>-t cd9660</code>. Por ejemplo, si quiere montar el dispositivo CDROM <span class=filename>/dev/cd0</span> en <span class=filename>/mnt</span> ejecute:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount -t cd9660 /dev/cd0 /mnt</span></code></pre></div></div><div class=paragraph><p>Tenga en cuenta que el nombre de su dispositivo (<span class=filename>/dev/cd0</span> en este ejemplo) puede ser diferente, dependiendo de la interfaz que su CDROM utilice. Además la opción <code>-t cd9660</code> sólo ejecuta <a href="https://man.freebsd.org/cgi/man.cgi?query=mount_cd9660&amp;sektion=8&amp;format=html">mount_cd9660(8)</a>. El ejemplo de arriba puede resumirse del siguiente modo:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount_cd9660 /dev/cd0 /mnt</span></code></pre></div></div><div class=paragraph><p>En general puede usar CDROM de datos de cualquier fabricante, aunque los discos con ciertas extensiones ISO 9660 pueden mostrar un comportamiento extraño. Por ejemplo, los discos Joliet almacenan todos los nombres de fichero en caracteres unicode de dos-bytes. El kernel de FreeBSD no comprende unicode (<em>todavía</em>) así que los caracteres que no están en inglés aparecen como signos de interrogación. (Si utiliza FreeBSD 4.3 o alguna versión posterior, el controlador CD9660 incluye unas estructuras llamadas "ganchos", que le permitirán cargar una tabla de conversión unicode apropiada cuando haga falta. Hay módulos para algunas de las codificaciones más comunes en el port <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/cd9660_unicode/>sysutils/cd9660_unicode</a>.)</p></div><div class=paragraph><p>Es posible que reciba un error <code>Device not configured</code> al tratar de montar un CDROM. Generalmente esto significa que la unidad de CDROM piensa que no hay disco en la bandeja, o que la unidad no es visible en el bus. Puede llevar un par de segundos el que una unidad de CDROM se dé cuenta de que ha sido alimentada, por lo tanto sea paciente.</p></div><div class=paragraph><p>Algunas veces un CDROM SCSI puede "perdido" debido a que no tuvo tiempo suficiente para responder al reset del bus. Si tiene un CDROM SCSI añada la siguiente opción a su fichero de configuración del kernel y <a href=./#kernelconfig-building>recompile su kernel</a>.</p></div><div class="literalblock programlisting"><div class=content><pre>options SCSI_DELAY=15000</pre></div></div><div class=paragraph><p>Esto le indica a su bus SCSI que haga una pausa de 15 segundos durante el arranque para darle ocasión a su unidad de CDROM de responder al reset del bus.</p></div></div><div class=sect3><h4 id=rawdata-cd>18.6.8. Grabar CD de datos "crudos" (Raw)<a class=anchor href=#rawdata-cd></a></h4><div class=paragraph><p>Puede guardar un fichero directamente a CD sin crear un sistema de ficheros ISO 9660. Algunas personas hacen esto al crear respaldos. Es un proceso más rápido que grabar un CD estándar:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># burncd -f /dev/acd1 -s 12 data fichero.tar.gz fixate</span></code></pre></div></div><div class=paragraph><p>Para recuperar los datos guardardados de este modo en un CD, debe leer los datos desde el nodo de dispositivo "crudo":</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># tar xzvf /dev/acd1</span></code></pre></div></div><div class=paragraph><p>No puede montar este disco como lo haría con un CDROM normal. Estos CDROM no pueden leerse en ningún sistema operativo que no sea FreeBSD. Si quiere montar el CD o compartir los datos con otro sistema operativo debe utilizar <a href="https://man.freebsd.org/cgi/man.cgi?query=mkisofs&amp;sektion=8&amp;format=html">mkisofs(8)</a> como se describió previamente.</p></div></div><div class=sect3><h4 id=atapicam>18.6.9. Uso del controlador ATAPI/CAM<a class=anchor href=#atapicam></a></h4><div class=paragraph><p>Este controlador permite que dispositivos ATAPI (CD-ROM, CD-RW, unidades DVD, etc) sean accesibles a través del subsistema SCSI y por lo tanto permite el uso de aplicaciones como <a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/cdrdao/>sysutils/cdrdao</a> o <a href="https://man.freebsd.org/cgi/man.cgi?query=cdrecord&amp;sektion=1&amp;format=html">cdrecord(1)</a>.</p></div><div class=paragraph><p>Para usar este controlador necesitará añadir la siguiente línea al fichero de configuración de su kernel:</p></div><div class="literalblock programlisting"><div class=content><pre>device atapicam</pre></div></div><div class=paragraph><p>Es posible que necesite también las siguientes líneas en el fichero de configuración de su kernel:</p></div><div class="literalblock programlisting"><div class=content><pre>device ata
device scbus
device cd
device pass</pre></div></div><div class=paragraph><p>(que, por otra parte, ya deberín estar presentes).</p></div><div class=paragraph><p>Recompile, instale su nuevo kernel y reinicie su máquina. Durante el proceso de arranque su grabadora debe ser detectada; veamos un ejemplo:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>acd0: CD-RW &lt;MATSHITA CD-RW/DVD-ROM UJDA740&gt; at ata1-master PIO4
cd0 at ata1 bus 0 target 0 lun 0
cd0: &lt;MATSHITA CDRW/DVD UJDA740 1.00&gt; Removable CD-ROM SCSI-0 device
cd0: 16.000MB/s transfers
cd0: Attempt to query device size failed: NOT READY, Medium not present - tray closed</code></pre></div></div><div class=paragraph><p>Puede acceder a la unidad a través del del nombre de dispositivo <span class=filename>/dev/cd0</span>; por ejemplo, para montar un CDROM en <span class=filename>/mnt</span>, teclée lo siguiente:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount -t cd9660 /dev/cd0 /mnt</span></code></pre></div></div><div class=paragraph><p>Como <code>root</code>, puede ejecutar el siguiente comando para obtener las direcciones SCSI del dispositivo:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># camcontrol devlist</span>
&lt;MATSHITA CDRW/DVD UJDA740 1.00&gt;   at scbus1 target 0 lun 0 <span class=o>(</span>pass0,cd0<span class=o>)</span></code></pre></div></div><div class=paragraph><p>Según esto, <code>1,0,0</code> será la dirección SCSI a utilizar con <a href="https://man.freebsd.org/cgi/man.cgi?query=cdrecord&amp;sektion=1&amp;format=html">cdrecord(1)</a> y otras aplicaciones SCSI.</p></div><div class=paragraph><p>Para mayor información sobre sistemas ATAPI/CAM y SCSI, diríjase a las páginas de manual <a href="https://man.freebsd.org/cgi/man.cgi?query=atapicam&amp;sektion=4&amp;format=html">atapicam(4)</a> y <a href="https://man.freebsd.org/cgi/man.cgi?query=cam&amp;sektion=4&amp;format=html">cam(4)</a>.</p></div></div></div><div class=sect2><h3 id=creating-dvds>18.7. Crear y utilizar medios ópticos (DVDs)<a class=anchor href=#creating-dvds></a></h3><div class=sect3><h4 id=_introducción_4>18.7.1. Introducción<a class=anchor href=#_introducción_4></a></h4><div class=paragraph><p>Comparado con el CD, el DVD es la nueva generación de tecnología de almacenamiento en medios ópticos. El DVD puede almacenar más datos que cualquier CD y hoy día es el estándar para publicación de vídeo.</p></div><div class=paragraph><p>Se pueden definir cinco formatos de grabación para lo que llamamos un DVD grabable:</p></div><div class=ulist><ul><li><p>DVD-R: Este fué el primer formato de grabación de DVD. El DVD-R estándar fué definido por el <a href=http://www.dvdforum.com/forum.shtml>DVD Forum</a>. Este formato es de una sola escritura.</p></li><li><p>DVD-RW: Esta es la versión reescribible del DVD-R estándar. Un DVD-RW puede reescribirse unas 1.000 veces.</p></li><li><p>DVD-RAM: Este es también un formato reescribible soportado por el DVD Forum. Un DVD-RAM puede verse como un disco duro extraíble. Este medio no es compatible con la mayoría de las unidades DVD-ROM y reproductores de video DVD; hay muy pocas grabadoras de DVD que soporten el formato DVD-RAM.</p></li><li><p>DVD+RW: Este es un formato reescribible definido por la <a href=http://www.dvdrw.com/>DVD+RW Alliance</a>. Un DVD+RW puede reescribirse unas 1000 veces.</p></li><li><p>DVD+R: Este un formato es la versión de una sola escritura del formato DVD+RW.</p></li></ul></div><div class=paragraph><p>Un DVD grabable de una capa puede almacenar hasta 4.700.000.000 bytes, es decir, 4'38 GB o 4485 MB (1 kilobyte son 1.024 bytes).</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Debemos hacer una distinción entre medio físico y aplicación. Un DVD de vídeo es una estructura de fichero específica que puede escribirse en cualquier medio físico consistente en un DVD grabable: DVD-R, DVD+R, DVD-RW, etc. Antes de elegir el tipo de medio, debe asegurarse que la grabadora y el reproductor de DVD de vídeo (un reproductor independiente o una unidad DVD-ROM en una computadora) son compatibles con el medio que pretende utilizar.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=_configuración_3>18.7.2. Configuración<a class=anchor href=#_configuración_3></a></h4><div class=paragraph><p>Utilice <a href="https://man.freebsd.org/cgi/man.cgi?query=growisofs&amp;sektion=1&amp;format=html">growisofs(1)</a> para grabar el DVD. Forma parte de las herramientas dvd+rw-tools (<a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/dvd+rw-tools/>sysutils/dvd+rw-tools</a>). Las dvd+rw-tools permiten usar todos los tipos de DVD.</p></div><div class=paragraph><p>Estas herramientas utilizan el subsistema SCSI para acceder a los dispositivos, por lo tanto el <a href=#atapicam>soporte ATAPI/CAM</a> debe estar presente en su kernel. Si su grabadora usa el interfaz USB no tendrá que hacerlo, pero tendrá que leer la <a href=#usb-disks>Dispositivos de almacenamiento USB</a> para más información sobre la configuración de dispositivos USB.</p></div><div class=paragraph><p>También debe que habilitar el acceso DMA para dispositivos ATAPI. Para ello añada la siguiente línea a <span class=filename>/boot/loader.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>hw.ata.atapi_dma=&#34;1&#34;</pre></div></div><div class=paragraph><p>Antes de intentar utilizar dvd+rw-tools debe consultar las <a href=http://fy.chalmers.se/~appro/linux/DVD+RW/hcn.html>notas de compatibilidad de hardware de dvd+rw-tools</a> por si apareciera cualquier información relacionada con su grabadora de DVD.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Si desea un interfaz gráfico debería echar un vistazo a K3b (<a class=package href=https://cgit.freebsd.org/ports/tree/sysutils/k3b/>sysutils/k3b</a>), que ofrece un interfaz de usuario amigable para <a href="https://man.freebsd.org/cgi/man.cgi?query=growisofs&amp;sektion=1&amp;format=html">growisofs(1)</a> y muchas otras herramientas de grabación.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=_quemado_de_dvd_de_datos>18.7.3. Quemado de DVD de datos<a class=anchor href=#_quemado_de_dvd_de_datos></a></h4><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=growisofs&amp;sektion=1&amp;format=html">growisofs(1)</a> es un "frontend" de <a href=#mkisofs>mkisofs</a>, invocará a <a href="https://man.freebsd.org/cgi/man.cgi?query=mkisofs&amp;sektion=8&amp;format=html">mkisofs(8)</a> para crear una estructura de sistema de ficheros y realizará la escritura del DVD. Esto significa que no necesita crear una imagen de los datos antes del proceso de escritura.</p></div><div class=paragraph><p>La grabación en DVD+R o DVD-R de los datos del directorio <span class=filename>/ruta/a/los/datos</span>, se hace del siguiente modo:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># growisofs -dvd-compat -Z /dev/cd0 -J -R /ruta/a/los/datos</span></code></pre></div></div><div class=paragraph><p>Las opciones <code>-J -R</code> se suministran a <a href="https://man.freebsd.org/cgi/man.cgi?query=mkisofs&amp;sektion=8&amp;format=html">mkisofs(8)</a> para la creación del sistema de ficheros (en este caso: un sistema de ficheros ISO 9660 con extensiones Joliet y Rock Ridge). Consulte la página de manual <a href="https://man.freebsd.org/cgi/man.cgi?query=mkisofs&amp;sektion=8&amp;format=html">mkisofs(8)</a> para más detalles.</p></div><div class=paragraph><p>La opción <code>-Z</code> se usa la sesión inicial de grabación en todos los casos, sesiones múltiples o no. El dispositivo DVD del ejemplo, <em>/dev/cd0</em>, debe ajustarse de acuerdo a la configuración de su sistema. El parámero <code>-dvd-compat</code> cerrará el disco (no se podrá añadir nada a la grabación). Por contra, esto le brindará una mejor compatibilidad del medio con unidades DVD-ROM.</p></div><div class=paragraph><p>También es posible grabar una imagen pre-masterizada, por ejemplo para guardar la imagen <em>ficheroimagen.iso</em>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># growisofs -dvd-compat -Z /dev/cd0=ficheroimagen.iso</span></code></pre></div></div><div class=paragraph><p>La velocidad de escritura se detecta y configura automáticamente según el medio y la unidad que se esté utilizando. Si quiere forzar la velocidad de escritura utilice el parámetro <code>-speed=</code>. Para más información consulte la página de manual <a href="https://man.freebsd.org/cgi/man.cgi?query=growisofs&amp;sektion=1&amp;format=html">growisofs(1)</a>.</p></div></div><div class=sect3><h4 id=_grabación_de_un_dvd_de_vídeo>18.7.4. Grabación de un DVD de vídeo<a class=anchor href=#_grabación_de_un_dvd_de_vídeo></a></h4><div class=paragraph><p>Un DVD de vídeo es una estructura de ficheros específica basada en las especificiones ISO 9660 y micro-UDF (M-UDF). El DVD de vídeo también dispone de una jerarquía de estructura de datos específica; por esta razón es necesario un programa especializado para crear tal DVD: <a class=package href=https://cgit.freebsd.org/ports/tree/multimedia/dvdauthor/>multimedia/dvdauthor</a>.</p></div><div class=paragraph><p>Si ya tiene una imagen de un sistema de ficheros de DVD de vídeo grábelo de la misma manera que cualquier otra imagen; consulte la sección previa para ver un ejemplo. Si ha creado el DVD y el resultado está en, por ejemplo, el directorio <span class=filename>/ruta/al/vídeo</span>, use el siguiente comando para grabar el DVD de vídeo:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># growisofs -Z /dev/cd0 -dvd-video /ruta/al/vídeo</span></code></pre></div></div><div class=paragraph><p>La opción <code>-dvd-video</code> de <a href="https://man.freebsd.org/cgi/man.cgi?query=mkisofs&amp;sektion=8&amp;format=html">mkisofs(8)</a> hará posible la creación de una estructura de sistema de ficheros de DVD de vídeo. Además, la opción <code>-dvd-video</code> implica la opción <code>-dvd-compat</code> de <a href="https://man.freebsd.org/cgi/man.cgi?query=growisofs&amp;sektion=1&amp;format=html">growisofs(1)</a>.</p></div></div><div class=sect3><h4 id=_uso_de_un_dvdrw>18.7.5. Uso de un DVD+RW<a class=anchor href=#_uso_de_un_dvdrw></a></h4><div class=paragraph><p>A diferencia de un CD-RW, un DVD+RW virgen necesita ser formateado antes de usarse por primera vez. El programa <a href="https://man.freebsd.org/cgi/man.cgi?query=growisofs&amp;sektion=1&amp;format=html">growisofs(1)</a> se encargará de ello automáticamente cuando sea necesario, lo cual es el método <em>recomendado</em>. De todas formas puede usted usar el comando <code>dvd+rw-format</code> para formatear el DVD+RW:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dvd+rw-format /dev/cd0</span></code></pre></div></div><div class=paragraph><p>Necesita ejecutar esta operación solamente una vez, recuerde que sólo los DVD+RW vírgenes necesitan ser formateados. Hecho eso ya puede usar el DVD+RW de la forma expuesta en las secciones previas.</p></div><div class=paragraph><p>Si desea guardar nuevos datos (grabar un sistema de ficheros totalmente nuevo, no añadir más datos) en un DVD+RW no necesita borrarlo, sólo tiene que escribir sobre la grabación anterior (realizando una nueva sesión inicial):</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># growisofs -Z /dev/cd0 -J -R /ruta/alos/datosnuevos</span></code></pre></div></div><div class=paragraph><p>El formato DVD+RW ofrece la posibilidad de añadir datos fácilmente a una grabación previa. La operación consiste en fusionar una nueva sesión a la existente, no es escritura multisesión; <a href="https://man.freebsd.org/cgi/man.cgi?query=growisofs&amp;sektion=1&amp;format=html">growisofs(1)</a> <em>hará crecer</em> el sistema de ficheros ISO 9660 presente en el medio.</p></div><div class=paragraph><p>Si, por ejemplo, añadir datos al DVD+RW del ejemplo anterior tenemos que usar lo siguiente:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># growisofs -M /dev/cd0 -J -R /ruta/alos/datosnuevos</span></code></pre></div></div><div class=paragraph><p>Las mismas opciones de <a href="https://man.freebsd.org/cgi/man.cgi?query=mkisofs&amp;sektion=8&amp;format=html">mkisofs(8)</a> que utilizamos para quemar la sesión inicial pueden usarse en ulteriores escritura.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Puede usar la opción <code>-dvd-compat</code> si desea mejor la compatibilidad de medios con unidades DVD-ROM. Si la usa en un DVD+RW no evitará que pueda añadir más datos.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Si por alguna razón desea borrar el contenido del medio, haga lo siguiente:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># growisofs -Z /dev/cd0=/dev/zero</span></code></pre></div></div></div><div class=sect3><h4 id=_uso_de_un_dvd_rw>18.7.6. Uso de un DVD-RW<a class=anchor href=#_uso_de_un_dvd_rw></a></h4><div class=paragraph><p>Un DVD-RW acepta dos formatos de disco: el incremental secuencial y el de sobreescritura restringida. Por defecto los discos DVD-RW están en formato secuencial.</p></div><div class=paragraph><p>Un DVD-RW virgen puede utilizarse directamente sin necesidad de formateo, sin embargo un DVD-RW no virgen en formato secuencial necesita ser borrado antes de poder guardar una nueva sesión inicial.</p></div><div class=paragraph><p>Para borrar un DVD-RW en modo secuencial, ejecute:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dvd+rw-format -blank=full /dev/cd0</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Un borrado total (<code>-blank=full</code>) tardará aproximadamente una hora en un medio 1x. Un borrado rápido puede realizarse con la opción <code>-blank</code> si el DVD-RW fué grabado en modo Disk-At-Once (DAO). Para grabar el DVD-RW en modo DAO use el comando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># growisofs -use-the-force-luke=dao -Z /dev/cd0=ficheroimagen.iso</span></code></pre></div></div><div class=paragraph><p>La opción <code>-use-the-force-luke=dao</code> no es imprescindible, ya que <a href="https://man.freebsd.org/cgi/man.cgi?query=growisofs&amp;sektion=1&amp;format=html">growisofs(1)</a> trata de detectar el medio (borrado rápido) y entrar en escritura DAO.</p></div><div class=paragraph><p>Debería usarse el modo de reescritura restringida en los DVD-RW, pues este formato es más flexible que el formato de incremento secuencial, el formato por defecto.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Para escribir datos en un DVD-RW secuencial proceda del mismo modo que con los demás formatos de DVD:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># growisofs -Z /dev/cd0 -J -R /ruta/alos/datos</span></code></pre></div></div><div class=paragraph><p>Si desea añadir datos a una grabación previa tendrá que usar la opción <code>-M</code> de <a href="https://man.freebsd.org/cgi/man.cgi?query=growisofs&amp;sektion=1&amp;format=html">growisofs(1)</a>. si añade datos a un DVD-RW en modo incremental secuencial se creará en el disco una nueva sesión y el resultado será un disco multisesión.</p></div><div class=paragraph><p>Un DVD-RW en formato de sobreescritura restringido no necesita ser borrado antes de una nueva sesión inicial, sólo tiene que sobreescribir el disco con la opción <code>-Z</code>. esto es similar al caso DVD+RW. También es posible ampliar un sistema de ficheros ISO 9660 ya existente y escrito en el disco del mismo modo que para un DVD+RW con la opción <code>-M</code>. El resultado será un DVD de una sesión.</p></div><div class=paragraph><p>Para poner un DVD-RW en el formato de sobreescritura restringido haga lo siguiente:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dvd+rw-format /dev/cd0</span></code></pre></div></div><div class=paragraph><p>Para devolverlo al formato secuencial use:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dvd+rw-format -blank=full /dev/cd0</span></code></pre></div></div></div><div class=sect3><h4 id=_multisesión>18.7.7. Multisesión<a class=anchor href=#_multisesión></a></h4><div class=paragraph><p>Muy pocas unidades DVD-ROM soportan DVDs multisesión. La mayoría de las veces (y si tiene suerte) solamente leerán la primera sesión. Los DVD+R, DVD-R y DVD-RW en formato secuencial pueden aceptar multisesiones. El concepto de multisesión no existe en los formatos de sobreescritura restringida de DVD+RW y DVD-RW.</p></div><div class=paragraph><p>Usando el siguiente comando despues de una sesión inicial (no-cerrada) en un DVD+R, DVD-R o DVD-RW en formato secuencial añadirá una nueva sesión al disco:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># growisofs -M /dev/cd0 -J -R /ruta/alos/nuevosdatos</span></code></pre></div></div><div class=paragraph><p>Usando este comando con un DVD+RW o un DVD-RW en modo de sobreescritura restringida, agregará datos fusionando la nueva sesión a la ya existente. El resultado será un disco de una sola sesión. Este es el procedimiento habitual para añadir datos tras la escritura inicial.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Una cierta cantidad de espacio en el medio se usa en cada sesión al finalizar e iniciar sesiones; por tanto, se deben añadir sesiones con grandes cantidades de datos para optimizar el espacio del DVD. El número de sesiones está limitado a 154 para un DVD+R, aproximadamente 2.000 para un DVD-R y 127 para un DVD+R de doble capa.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=_para_mayor_información>18.7.8. Para mayor información<a class=anchor href=#_para_mayor_información></a></h4><div class=paragraph><p>Para más información sobre un DVD,puede ejecutar el comando <code>dvd+rw-mediainfo /dev/cd0</code> con el disco en la unidad.</p></div><div class=paragraph><p>Tiene más información sobre dvd+rw-tools en la manual <a href="https://man.freebsd.org/cgi/man.cgi?query=growisofs&amp;sektion=1&amp;format=html">growisofs(1)</a>, en el <a href=http://fy.chalmers.se/~appro/linux/DVD+RW/>sitio web de dvd+rw-tools</a> y en los archivos de la <a href=http://lists.debian.org/cdwrite/>lista de correos de cdwrite</a>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Si va a enviar un informe de problemas es imperativo que adjunte la salida que <code>dvd+rw-mediainfo</code> produjo al grabar (o no grabar) el medio. Sin esta salida será prácticamente imposible ayudarle.</p></div></td></tr></tbody></table></div></div></div><div class=sect2><h3 id=floppies>18.8. Creación y uso de disquetes (floppies)<a class=anchor href=#floppies></a></h3><div class=paragraph><p>Poder almacenar datos en discos flexibles es útil algunas veces, por ejemplo cuando no se tiene cualquier otro medio de almacenamiento extraible o cuando se necesita transferir una cantidad pequeña de datos a otro sistema.</p></div><div class=paragraph><p>Esta sección explicará cómo usar disquetes en FreeBSD. Cubrirá principalmente el formateo y utilización de disquetes DOS de 3.5 pulgadas, pero los conceptos son similares en otros formatos de disquete.</p></div><div class=sect3><h4 id=_formateo_de_disquetes>18.8.1. Formateo de disquetes<a class=anchor href=#_formateo_de_disquetes></a></h4><div class=sect4><h5 id=_el_dispositivo>18.8.1.1. El dispositivo<a class=anchor href=#_el_dispositivo></a></h5><div class=paragraph><p>El acceso a los disquetes se efectúa a través de entradas en <span class=filename>/dev</span>, igual que en otros dispositivos. Para acceder al disquete "crudo" (raw) en versiones 4.X y anteriores, se usa <span class=filename>/dev/fdN</span>, donde <em>N</em> representa el número de unidad, generalmente 0, o <span class=filename>/dev/fdNX</span>, donde <em>X</em> representa una letra.</p></div><div class=paragraph><p>En versiones 5.0 o posteriores, simplemente use <span class=filename>/dev/fdN</span>.</p></div><div class=sect5><h6 id=_el_tamaño_de_disco_en_versiones_4_x_y_anteriores>18.8.1.1.1. El tamaño de disco en versiones 4.X y anteriores<a class=anchor href=#_el_tamaño_de_disco_en_versiones_4_x_y_anteriores></a></h6><div class=paragraph><p>También existen dispositivos <span class=filename>/dev/fdN.tamaño</span>, donde <em>tamaño</em> es el tamaño del disquete en kilobytes. Estas entradas se usan durante el formateo a bajo nivel para determinar el tamaño del disco. En los siguientes ejemplos se usará el tamaño de 1440kB.</p></div><div class=paragraph><p>Algunas veces las entradas bajo <span class=filename>/dev</span> tendrán que ser (re)creadas. Para ello, ejecute:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /dev &amp;&amp; ./MAKEDEV &#34;fd*&#34;</span></code></pre></div></div></div><div class=sect5><h6 id=_el_tamaño_de_disco_en_versiones_5_0_y_posteriores>18.8.1.1.2. El tamaño de disco en versiones 5.0 y posteriores<a class=anchor href=#_el_tamaño_de_disco_en_versiones_5_0_y_posteriores></a></h6><div class=paragraph><p>En 5.0, <a href="https://man.freebsd.org/cgi/man.cgi?query=devfs&amp;sektion=5&amp;format=html">devfs(5)</a> administrará automáticamente los nodos de dispositivo en <span class=filename>/dev</span>, así que el uso de <code>MAKEDEV</code> no es necesario.</p></div><div class=paragraph><p>El tamaño de disco deseado se pasa a <a href="https://man.freebsd.org/cgi/man.cgi?query=fdformat&amp;sektion=1&amp;format=html">fdformat(1)</a> mediante la bandera <code>-f</code>. Los tamaños soportados aparecen en <a href="https://man.freebsd.org/cgi/man.cgi?query=fdcontrol&amp;sektion=8&amp;format=html">fdcontrol(8)</a>, pero tenga muy en cuenta que 1440kB es el que funciona mejor.</p></div></div></div><div class=sect4><h5 id=_formatear>18.8.1.2. Formatear<a class=anchor href=#_formatear></a></h5><div class=paragraph><p>Un disquete necesita ser formateado a bajo nivel antes de poder usarse. Esto suele hacerlo el fabricante, pero el formateo es una buena manera de revisar la integridad del medio. Aunque es posible forzar tamaños de disco más grandes (o pequeños), 1440kB es para lo que la mayoría de los disquetes están diseñados.</p></div><div class=paragraph><p>Para formatear un disquete a bajo nivel debe usar <a href="https://man.freebsd.org/cgi/man.cgi?query=fdformat&amp;sektion=1&amp;format=html">fdformat(1)</a>. Esta utilidad espera el nombre del dispositivo como argumento.</p></div><div class=paragraph><p>Tome nota de cualquier mensaje de error, ya que éstos pueden ayudarle a determinar si el disco está bien o mal.</p></div><div class=sect5><h6 id=_formateo_en_versiones_4_x_y_anteriores>18.8.1.2.1. Formateo en versiones 4.X y anteriores<a class=anchor href=#_formateo_en_versiones_4_x_y_anteriores></a></h6><div class=paragraph><p>Use el dispositivo <span class=filename>/dev/fdN.tamaño</span> para formatear el disquete. Inserte un disco de 3'5 pulgadas en su unidad y ejecute:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /usr/sbin/fdformat /dev/fd0.1440</span></code></pre></div></div></div><div class=sect5><h6 id=_formateo_en_versiones_5_0_y_posteriores>18.8.1.2.2. Formateo en versiones 5.0 y posteriores<a class=anchor href=#_formateo_en_versiones_5_0_y_posteriores></a></h6><div class=paragraph><p>Use el dispositivo <span class=filename>/dev/fdN</span> para formatear el disquete. Inserte un disco de 3'5 pulgadas en su unidad y ejecute:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /usr/sbin/fdformat -f 1440 /dev/fd0</span></code></pre></div></div></div></div></div><div class=sect3><h4 id=_la_etiqueta_de_disco>18.8.2. La etiqueta de disco<a class=anchor href=#_la_etiqueta_de_disco></a></h4><div class=paragraph><p>Tras un formato del disco a bajo nivel necesitará colocar una etiqueta de disco en él. Esta etiqueta de disco será destruida más tarde, pero es necesaria para que el sistema determine el tamaño del disco y su geometría.</p></div><div class=paragraph><p>La nueva etiqueta de disco ocupará todo el disco, y contendrá toda la información apropiada sobre la geometría del disquete. Los valores de geometría para la etiqueta de disco están en <span class=filename>/etc/disktab</span>.</p></div><div class=paragraph><p>Ejecute <a href="https://man.freebsd.org/cgi/man.cgi?query=disklabel&amp;sektion=8&amp;format=html">disklabel(8)</a> así:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /sbin/disklabel -B -r -w /dev/fd0 fd1440</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Desde FreeBSD 5.1-RELEASE <a href="https://man.freebsd.org/cgi/man.cgi?query=bsdlabel&amp;sektion=8&amp;format=html">bsdlabel(8)</a> reemplazó al viejo programa <a href="https://man.freebsd.org/cgi/man.cgi?query=disklabel&amp;sektion=8&amp;format=html">disklabel(8)</a>. En <a href="https://man.freebsd.org/cgi/man.cgi?query=bsdlabel&amp;sektion=8&amp;format=html">bsdlabel(8)</a> se eliminaron muchas opciones y parámetros obsoletos; en el ejemplo de arriba la opción <code>-r</code> no debe usarse. Para mayor información consulte la página de manual de <a href="https://man.freebsd.org/cgi/man.cgi?query=bsdlabel&amp;sektion=8&amp;format=html">bsdlabel(8)</a>.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=_el_sistema_de_ficheros>18.8.3. El sistema de ficheros<a class=anchor href=#_el_sistema_de_ficheros></a></h4><div class=paragraph><p>Ahora el disquete está listo para ser formateado a alto nivel. Esto colocará un sistema de ficheros nuevo en el disco y permitirá a FreeBSD leer y escribir en el disco. Después de crear el sistema de ficheros se destruye la etiqueta de disco, así que si desea reformatearlo, tendrá que recrear la etiqueta de disco.</p></div><div class=paragraph><p>El sistema de ficheros del disquete puede ser UFS o o FAT. FAT suele ser una mejor opción para disquetes.</p></div><div class=paragraph><p>Para formatear un disquete ejecute:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /sbin/newfs_msdos /dev/fd0</span></code></pre></div></div><div class=paragraph><p>El disco está para su uso.</p></div></div><div class=sect3><h4 id=_uso_de_un_disquete>18.8.4. Uso de un disquete<a class=anchor href=#_uso_de_un_disquete></a></h4><div class=paragraph><p>Para usar el disquete móntelo con <a href="https://man.freebsd.org/cgi/man.cgi?query=mount_msdos&amp;sektion=8&amp;format=html">mount_msdos(8)</a> (en versiones 4.X y anteriores) o con <a href="https://man.freebsd.org/cgi/man.cgi?query=mount_msdosfs&amp;sektion=8&amp;format=html">mount_msdosfs(8)</a> (en versiones 5.X o posteriores). También se puede usar <a class=package href=https://cgit.freebsd.org/ports/tree/emulators/mtools/>emulators/mtools</a>.</p></div></div></div><div class=sect2><h3 id=backups-tapebackups>18.9. Creación y uso de cintas de datos<a class=anchor href=#backups-tapebackups></a></h3><div class=paragraph><p>Los principales medios de cinta son 4mm, 8mm, QIC, mini-cartridge y DLT.</p></div><div class=sect3><h4 id=backups-tapebackups-4mm>18.9.1. 4mm (DDS: Digital Data Storage)<a class=anchor href=#backups-tapebackups-4mm></a></h4><div class=paragraph><p>Las cintas de 4mm están reemplazando a las QIC como los medios de respaldo más frecuentes en estaciones de trabajo. Esta tendencia se aceleró en gran medida cuando Conner adquirió Archive, un fabricante líder de unidades QIC, y abandonó la producción de unidades QIC. Las unidades de 4mm son pequeñas y silenciosas pero no tienen la reputación de fiabilidad de la que disfrutan las unidades de 8mm. Los cartuchos son más baratos y más pequeños (3 x 2 x 0.5 pulgadas, 76 x 51 x 12 mm) que los cartuchos de 8mm. En el caso de las cintas de 4mm, igual que las de 8mm, tienen un cabezal con una vida comparativamente más corta. Ambos utilizan el escaneado en espiral.</p></div><div class=paragraph><p>El ancho de datos de estas unidades comienza por aprox. 150 kB/s, con un pico de aprox. ~500 kB/s. La capacidad de datos va de los 1'3 GB a 2'0 GB. La compresión por hardware, disponible con la mayoría de estas unidades, dobla aproximadamente la capacidad. Existen unidades de biblioteca de cinta multi-unidad con 6 unidades en un solo armario y cambio de cinta automático. Las capacidades de estas bibliotecas alcanzan los 240 GB.</p></div><div class=paragraph><p>El estándar DDS-3 soporta capacidades de cinta de hasta 12 GB (o 24 GB con compresión).</p></div><div class=paragraph><p>Las unidades de 4mm, igual que las unidades de 8mm, utilizan escaneo en espiral. Tanto unas como otras tienen las mismas ventajas y desventajas.</p></div><div class=paragraph><p>Las cintas deben renovarse por otras después de 2,000 pasadas ó 100 respaldos completos.</p></div></div><div class=sect3><h4 id=backups-tapebackups-8mm>18.9.2. 8mm (Exabyte)<a class=anchor href=#backups-tapebackups-8mm></a></h4><div class=paragraph><p>Las cintas de 8mm son las unidades de cinta SCSI más comunes; son la mejor opción de cintas reemplazables y eso hace que las unidades de cinta Exabyte 8mm de 2 GB sean casi omnipresentes. Las unidades de 8mm son fiables, prácticas y silenciosas. Los cartuchos son baratos y bastante pequeños (4.8 x 3.3 x 0.6 pulgadas; 122 x 84 x 15 mm). Una desventaja de las cintas de 8mm es la vida relativamente corta del cabezal y de la propia cinta debido a la alta tasa de movimiento relativo de la cinta por los cabezales.</p></div><div class=paragraph><p>El ancho de datos varía de aprox. 250 kB/s hasta los 500 kB/s. La capacidad va desde los 300 MB hasta los 7 GB. La compresión por hardware, disponible con la mayoría de estas unidades, dobla aproximadamente la capacidad. Estas unidades están disponibles como unidades solas o como unidades de biblioteca de cinta multi-unidad con 6 unidades y 120 cintas en un solo armario. Las cintas las cambia automáticamente la unidad. La capacidad de dichas bibliotecas alcanza los 840+ GB.</p></div><div class=paragraph><p>El modelo Exabyte "Mammoth" soporta 12 GB en una cinta (24 GB con compresión) y cuesta aproximadamente el doble que las unidades de cinta convencionales.</p></div><div class=paragraph><p>Los datos se graban en cinta utilizando escaneo en espiral. Las cabezas se posicionan en ángulo en relación al medio (6 grados aproximadamente). La cinta se envuelve cerca de 270 grados en el cilindro que soporta las cabezas. El cilindro gira mientras la cinta se desliza sobre el cilindro. El resultado es una alta densidad de datos y pistas almacenadas muy pegadas, dispuestas en ángulo a través de la cinta de un extremo al otro.</p></div></div><div class=sect3><h4 id=backups-tapebackups-qic>18.9.3. QIC<a class=anchor href=#backups-tapebackups-qic></a></h4><div class=paragraph><p>Las cintas y unidades QIC-150 son, quizás, las unidades y medios de cinta más comunes. Las unidades de cinta QIC son las unidades de respaldo "serias" menos caras. La desventaja es el coste del medio. Las cintas QIC son caras comparadas con las cintas de 8mm o de 4mm, hasta 5 veces el precio de almacenamiento de datos por GB. No obstante, si sus necesidades pueden satisfacerse con media docena de cintas, QIC tal vez sea la decisión correcta. QIC es la unidad de cinta <em>más</em> común. Casi en todas partes tienen una unidad QIC de una u otra densidad. Y ese es el problema, QIC ofrece un enorme número de densidades en cintas físicamente similares (algunas veces idénticas). Las unidades QIC son cualquier cosa menos silenciosas. Hacen bastante ruido antes de iniciar la grabación de datos y son claramente audibles siempre que leen, escriben o hacen una búsqueda. Las cintas QIC miden 6 x 4 x 0.7 pulgadas; 152 x 102 x 17 mm.</p></div><div class=paragraph><p>El ancho de datos varía de aprox. 150 kB/s a aprox. 500 kB/s. La capacidad de datos varía de 40 MB a 15 GB. La compresión por hardware existe en muchas de las nuevas unidades QIC. Las unidades QIC se ven con menos frecuencia y además están siendo suplantadas por unidades DAT.</p></div><div class=paragraph><p>Los datos se graban en la cinta en pistas. Las pistas discurren a lo largo del extenso eje de la cinta de un extremo al otro. El número de pistas, y por lo tanto el ancho de una pista varía según la capacidad de la cinta. La mayoría, si no todas las unidades nuevas, ofrecen compatibilidad con modelos anteriores al menos para lectura (y también en muchos casos de escritura). QIC tiene buena reputación en cuanto a seguridad de los datos (las piezas mecánicas son más simples y más robustas que en las unidades de búsqueda en espiral).</p></div><div class=paragraph><p>Las cintas deben ser sustituirse por otras después de 5,000 respaldos.</p></div></div><div class=sect3><h4 id=backups-tapebackups-dlt>18.9.4. DLT<a class=anchor href=#backups-tapebackups-dlt></a></h4><div class=paragraph><p>DLT tiene la tasa de transferencia de datos más rápida de todos los tipos de unidades mostradas aquí. La cinta de 1/2" (12'5mm) está alojada en un cartucho de un solo cilindro (4 x 4 x 1 pulgadas; 100 x 100 x 25 mm). El cartucho tiene una puerta giratoria a lo largo de todo un lado del cartucho. El mecanismo de la unidad abre esta puerta para extraer el "líder". El "lider" de la cinta tiene un agujero oval que la unidad utiliza para "enganchar" la cinta. El cilindro de levantamiento está dentro de la unidad de cinta. Los demás cartuchos descritos en este texto (los cartuchos de 9 pistas son la única excepción) tienen el cilindro proveedor alojados dentro del propio cartucho de cinta.</p></div><div class=paragraph><p>El ancho de datos es aproximadamente de 1'5 MB/s, tres veces el ancho de unidades de cinta de 4mm, de 8mm o QIC. Las capacidades de datos varían entre 10 GB y 20 GB en una sola unidad. Hay unidades multicinta y con cargadores multi-cinta, y bibliotecas multiunidad que pueden albergar de 5 a 900 cintas con una a 20 unidades, con lo que pueden alcanzar desde 50 GB hasta 9 TB de almacenamiento.</p></div><div class=paragraph><p>Con compresión, el formato DLT Type IV soporta hasta 70 GB de capacidad.</p></div><div class=paragraph><p>Los datos se almacenan en cinta en pistas paralelas a la dirección del movimiento de la cinta (como en las cintas QIC). Se escriben dos pistas al mismo tiempo. El tiempo de vida de lectura/escritura es relativamente largo. Una vez que la cinta no hay movimiento relativo entre las cabezas y la cinta.</p></div></div><div class=sect3><h4 id=_ait>18.9.5. AIT<a class=anchor href=#_ait></a></h4><div class=paragraph><p>AIT es un nuevo formato de Sony, y puede almacenar hasta 50 GB (con compresión) por cinta. Las cintas contienen chips de memoria que retienen un índice de los contenidos de la cinta. Este índice puede ser leido rápidamente para determinar la posición de los ficheros en la cinta, en lugar de los varios minutos que requeriría el proceso con otras cintas. SAMS:Alexandria puede gestionar más de 40 bibliotecas de cinta AIT, comunicándose directamente con el chip de memoria de la cinta para desplegar el contenido en pantalla, determinar qué ficheros fueron respaldados a qué cinta, ubicar la cinta correcta, cargarla y restaurar los datos desde la cinta.</p></div><div class=paragraph><p>Las bibliotecas como ésta cuestan alrededor de 20.000 dólares, lo que las aleja bastante del alcance de los aficionados.</p></div></div><div class=sect3><h4 id=_estreno_de_una_cinta>18.9.6. Estreno de una cinta<a class=anchor href=#_estreno_de_una_cinta></a></h4><div class=paragraph><p>La primera vez que trate de leer o escribir una cinta nueva, completamente en blanco, la operación fallará. El mensaje de la consola se parecerá al siguiente:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>sa0<span class=o>(</span>ncr1:4:0<span class=o>)</span>: NOT READY asc:4,1
sa0<span class=o>(</span>ncr1:4:0<span class=o>)</span>:  Logical unit is <span class=k>in </span>process of becoming ready</code></pre></div></div><div class=paragraph><p>La cinta no contiene un bloque identificador (bloque número 0). Todas las unidades de cinta QIC desde la adopción del estándar QIC-525 escriben un bloque identificador en la cinta. Existen dos soluciones:</p></div><div class=ulist><ul><li><p><code>mt fsf 1</code> hace que la unidad de cinta escriba un bloque identificador a la cinta.</p></li><li><p>Use el botón del panel frontal para expulsar la cinta.</p><div class=paragraph><p>Inserte nuevamente la cinta y haga un <code>dump</code> de datos a la cinta.</p></div><div class=paragraph><p><code>dump</code> devolverá <code>DUMP: End of tape detected</code> y la consola mostrará <code>HARDWARE FAILURE info:280 asc:80,96</code>.</p></div><div class=paragraph><p>Rebobine la cinta usando: <code>mt rewind</code>.</p></div><div class=paragraph><p>A partir de ese momento podrá utilizar la cinta.</p></div></li></ul></div></div></div><div class=sect2><h3 id=backups-floppybackups>18.10. Respaldos en disquetes<a class=anchor href=#backups-floppybackups></a></h3><div class=sect3><h4 id=floppies-using>18.10.1. ?Puedo utilizar disquetes para respaldar mis datos?<a class=anchor href=#floppies-using></a></h4><div class=paragraph><p>Los disquetes no son realmente el medio ideal para hacer respaldos debido a que:</p></div><div class=ulist><ul><li><p>El medio no es fiable, especialmente después de largos periodos de tiempo.</p></li><li><p>El respaldo y la restauración es muy lento.</p></li><li><p>Tienen una capacidad muy limitada (los dís de respaldar un disco duro entero en una docena de disquetes pasaron hace mucho).</p></li></ul></div><div class=paragraph><p>De todas maneras, si no tiene otro método para respaldar sus datos los disquetes son una mejor solución que no tener ningún respaldo.</p></div><div class=paragraph><p>Si tiene que utilizar disquetes asegúrese de usar discos de buena calidad. Los disquetes que han estado almacenados en la oficina durante un par de años son una mala elección. Lo mejor sería que utilizara discos nuevos de un fabricante respetado.</p></div></div><div class=sect3><h4 id=floppies-creating>18.10.2. ?Cómo respaldo mis datos a discos flexibles?<a class=anchor href=#floppies-creating></a></h4><div class=paragraph><p>La mejor manera de respaldar a un disquete es usar <a href="https://man.freebsd.org/cgi/man.cgi?query=tar&amp;sektion=1&amp;format=html">tar(1)</a> con la opción <code>-M</code> (multi volumen), que permite que el respaldo se guarde en varios disquetes.</p></div><div class=paragraph><p>Para respaldar todos los ficheros en el directorio actual y sus subdirectorios use esto (como <code>root</code>):</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># tar Mcvf /dev/fd0 *</span></code></pre></div></div><div class=paragraph><p>Cuando el primer disquete esté lleno <a href="https://man.freebsd.org/cgi/man.cgi?query=tar&amp;sektion=1&amp;format=html">tar(1)</a> le solicitará que inserte el siguiente volumen (debido a que <a href="https://man.freebsd.org/cgi/man.cgi?query=tar&amp;sektion=1&amp;format=html">tar(1)</a> es independiente del medio se refiere a volúmenes; en éste contexto se refiere a disquetes).</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Prepare volume <span class=c>#2 for /dev/fd0 and hit return:</span></code></pre></div></div><div class=paragraph><p>Esto se repite (con el número de volumen incrementando) hasta que todos los ficheros especificados hayan sido archivados.</p></div></div><div class=sect3><h4 id=floppies-compress>18.10.3. ?Puedo comprimir mis respaldos?<a class=anchor href=#floppies-compress></a></h4><div class=paragraph><p>Desafortunadamente, <a href="https://man.freebsd.org/cgi/man.cgi?query=tar&amp;sektion=1&amp;format=html">tar(1)</a> no permite el uso de la opción <code>-z</code> para archivos multi-volumen. Puede, por supuesto, hacer un <a href="https://man.freebsd.org/cgi/man.cgi?query=gzip&amp;sektion=1&amp;format=html">gzip(1)</a> a todos los ficheros, mandarlos con <a href="https://man.freebsd.org/cgi/man.cgi?query=tar&amp;sektion=1&amp;format=html">tar(1)</a> a los disquetes, <em>y después hacer <a href="https://man.freebsd.org/cgi/man.cgi?query=gunzip&amp;sektion=1&amp;format=html">gunzip(1)</a> a los archivos</em></p></div></div><div class=sect3><h4 id=floppies-restoring>18.10.4. ?Cómo recupero mis respaldos?<a class=anchor href=#floppies-restoring></a></h4><div class=paragraph><p>Para restaurar el archivo completo use:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># tar Mxvf /dev/fd0</span></code></pre></div></div><div class=paragraph><p>Hay dos maneras que puede usar para restaurar ficheros específicos. La primera, puede comenzar por el primer disco flexible y usar:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># tar Mxvf /dev/fd0 nombredefichero</span></code></pre></div></div><div class=paragraph><p>La utilidad <a href="https://man.freebsd.org/cgi/man.cgi?query=tar&amp;sektion=1&amp;format=html">tar(1)</a> le pedirá que inserte el resto de disquetes hasta que encuentre el fichero requerido.</p></div><div class=paragraph><p>La segunda manera es: si sabe en qué disco se encuentra el fichero puede insertar ese disco y usar el comando expuesto arriba. Tenga en cuenta que si el primer fichero en el disquete es la continuación del anterior <a href="https://man.freebsd.org/cgi/man.cgi?query=tar&amp;sektion=1&amp;format=html">tar(1)</a> le advertirá que no puede restaurarlo <em>incluso si no se lo ha solicitado</em></p></div></div></div><div class=sect2><h3 id=backup-basics>18.11. Bases para respaldos<a class=anchor href=#backup-basics></a></h3><div class=paragraph><p>Los tres principales programas para respaldos son <a href="https://man.freebsd.org/cgi/man.cgi?query=dump&amp;sektion=8&amp;format=html">dump(8)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=tar&amp;sektion=1&amp;format=html">tar(1)</a> y <a href="https://man.freebsd.org/cgi/man.cgi?query=cpio&amp;sektion=1&amp;format=html">cpio(1)</a>.</p></div><div class=sect3><h4 id=_dump_y_restore>18.11.1. Dump y Restore<a class=anchor href=#_dump_y_restore></a></h4><div class=paragraph><p>Los programas UNIX® que se han usado durante muchos años para hacer copias de seguridad son <code>dump</code> y <code>restore</code>. Operan en las unidades como una colección de bloques de disco, bajo la abstracción de ficheros, los enlaces y directorios creados por el sistema de ficheros. <code>dump</code> respalda un sistema de ficheros completo en un dispositivo. No es capaz de respaldar solamente parte de un sistema de ficheros o un árbol de directorios que se extienda por más de un sistema de ficheros. <code>dump</code> no escribe ficheros y directorios a cinta, escribe los bloques de datos "crudos" (raw) que conforman los ficheros y directorios.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Si utiliza <code>dump</code> en su directorio raíz, no respaldará <span class=filename>/home</span>, <span class=filename>/usr</span> ni muchos otros directorios, ya que suelen ser puntos de montaje de otros sistemas de ficheros o enlaces simbólicos hacia dichos sistemas de ficheros.</p></div></td></tr></tbody></table></div><div class=paragraph><p><code>dump</code> tiene peculiaridades que se mantienen desde sus primeros días en la Version 6 de AT&amp;T UNIX (alrededor de 1975). Los parámetros por defecto son los adecuados para cintas de 9 pistas (6250 bpi), pero no para los medios de alta densidad disponibles hoy en día (hasta 62,182 ftpi). Estos valores por defecto deben obviarse en la línea de comandos para aprovechar la capacidad de las unidades de cinta actuales.</p></div><div class=paragraph><p>También es posible respaldar datos a través de la red a una unidad de cinta conectada a otra computadora con <code>rdump</code> y <code>rrestore</code>. Ambos programas dependen de <a href="https://man.freebsd.org/cgi/man.cgi?query=rcmd&amp;sektion=3&amp;format=html">rcmd(3)</a> y <a href="https://man.freebsd.org/cgi/man.cgi?query=ruserok&amp;sektion=3&amp;format=html">ruserok(3)</a> para acceder a la unidad de cinta remota. Por consiguiente, el usuario que realiza el respaldo debe estar listado en el fichero <span class=filename>.rhosts</span> de la computadora remota. Los argumentos para <code>rdump</code> y <code>rrestore</code> deben ser adecuados para usarse en la computadora remota. Cuando realice un <code>rdump</code> desde FreeBSD a una unidad de cinta Exabyte conectada a una Sun llamada <code>komodo</code>, use:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /sbin/rdump 0dsbfu 54000 13000 126 komodo:/dev/nsa8 /dev/da0a 2&gt;&amp;1</span></code></pre></div></div><div class=paragraph><p>Advertencia: existen implicaciones de seguridad al permitir autentificación mediante <span class=filename>.rhosts</span>. Le recomendamos que evalúe la situación cuidadosamente.</p></div><div class=paragraph><p>También es posible usar <code>dump</code> y <code>restore</code> de una forma más segura a través de <code>ssh</code>.</p></div><div class=exampleblock><div class=title>Ejemplo 20. Utilizando <code>dump</code> a través de ssh</div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /sbin/dump -0uan -f - /usr | gzip -2 | ssh -c blowfish \</span>
          usuario@maquinaobjetivo.ejemplo.com <span class=nb>dd </span><span class=nv>of</span><span class=o>=</span>/misficherosgrandes/dump-usr-l0.gz</code></pre></div></div></div></div><div class=paragraph><p>Uso del método integrado de <code>dump</code>, configurando la variable de ambiente <code>RSH</code>:</p></div><div class=exampleblock><div class=title>Ejemplo 21. Uso de <code>dump</code> a través de ssh con <code>RSH</code> configurada</div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># RSH=/usr/bin/ssh /sbin/dump -0uan -f usuario@maquinaobjetivo.ejemplo.com:/dev/sa0 /usr</span></code></pre></div></div></div></div></div><div class=sect3><h4 id=_tar>18.11.2. <code>tar</code><a class=anchor href=#_tar></a></h4><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=tar&amp;sektion=1&amp;format=html">tar(1)</a> también es de la época de la Version 6 de AT&amp;T UNIX (alrededor de 1975). <code>tar</code> trabaja en cooperación con el sistema de ficheros; escribe ficheros y directorios a cinta. <code>tar</code> no soporta el rango completo de opciones que ofrece <a href="https://man.freebsd.org/cgi/man.cgi?query=cpio&amp;sektion=1&amp;format=html">cpio(1)</a>, pero no requiere el inusual comando de pipeline que utiliza <code>cpio</code>.</p></div><div class=paragraph><p>En FreeBSD 5.3 y posteriores, tiene a su disposición GNU <code>tar</code> y el comando por defecto <code>bsdtar</code>. La versión GNU puede ser invocada mediante <code>gtar</code>. Soporta dispositivos remotos mediante la misma sintaxis que <code>rdump</code>. Para hacer un <code>tar</code> a una unidad de cinta conectada a una Sun llamada <code>komodo</code>, use:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /usr/bin/gtar cf komodo:/dev/nsa8 . 2&gt;&amp;1</span></code></pre></div></div><div class=paragraph><p>Puede hacer lo mismo con o con <code>bsdtar</code> usando un "pipe" y <code>rsh</code> para mandar los datos a una unidad de cinta remota.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># tar cf - . | rsh nombredemaquina dd of=dispositivo-de-cinta obs=20b</span></code></pre></div></div><div class=paragraph><p>Si le preocupa la seguridad del proceso de hacer un respaldo a través de una red debe usar <code>ssh</code> en lugar de <code>rsh</code>.</p></div></div><div class=sect3><h4 id=_cpio>18.11.3. <code>cpio</code><a class=anchor href=#_cpio></a></h4><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=cpio&amp;sektion=1&amp;format=html">cpio(1)</a> es el programa de intercambio de archivos de cinta para medios magnéticos. <code>cpio</code> tiene opciones (entre muchas otras) para realizar intercambio de bytes, escribir un número diferente de formatos de archivo y hacer "pipe" de datos hacia otros programas. Esta última opción hace de <code>cpio</code> una elección excelente para medios de instalación. <code>cpio</code> no sabe cómo recorrer el árbol de directorios, así que debe facilitarle una lista de directorios a través de <span class=filename>stdin</span>.</p></div><div class=paragraph><p><code>cpio</code> no permite respaldos a través de la red. Puede usar un pipe y <code>rsh</code> para mandar los datos a una unidad de cinta remota.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># for f in lista_directorios; do</span>

<span class=c># find $f &lt;&lt; backup.list</span>

<span class=c># done</span>
<span class=c># cpio -v -o --format=newc &lt; backup.list | ssh usuario@máquina &#34;cat &gt; dispositivo_de_respaldo&#34;</span></code></pre></div></div><div class=paragraph><p>Donde <em>lista_directorios</em> es la lista de directorios que desea respaldar, <em>usuario</em>@<em>máquina</em> es la combinación usuario/nombre de equipo que realizará el respaldo y <em>dispositivo_de_respaldo</em> es donde el respaldo se escribirá efectivamente (por ejemplo <span class=filename>/dev/nsa0</span>).</p></div></div><div class=sect3><h4 id=_pax>18.11.4. <code>pax</code><a class=anchor href=#_pax></a></h4><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=pax&amp;sektion=1&amp;format=html">pax(1)</a> es la respuesta IEEE/POSIX® a <code>tar</code> y <code>cpio</code>. A través de los años las diversas versiones de <code>tar</code> y <code>cpio</code> se han vuelto ligeramente incompatibles, así que en lugar de pelear por hacerlo completamente estándar, POSIX® creó una nueva utilidad de archivado. <code>pax</code> trata de leer y escribir muchos de los diversos formatos de <code>cpio</code> y <code>tar</code>, además de nuevos formatos propios. Su conjunto de comandos se parece más a <code>cpio</code> que a <code>tar</code>.</p></div></div><div class=sect3><h4 id=backups-programs-amanda>18.11.5. Amanda<a class=anchor href=#backups-programs-amanda></a></h4><div class=paragraph><p>Amanda (Advanced Maryland Network Disk Archiver) es un sistema de respaldos cliente/servidor, en lugar de un solo programa. Un servidor Amanda respaldará a una sola unidad de cinta cualquier cantidad de computadoras que tengan clientes Amanda y una conexión de red al servidor Amanda. Un problema común en sitios con gran cantidad de discos grandes es que la cantidad de tiempo requerida para respaldar los datos directamente a cinta excede la cantidad de tiempo disponible para la tarea. Amanda resuelve este problema. Amanda puede usar un "disco intermedio" para respaldar varios sistemas de ficheros al mismo tiempo. Amanda crea "conjuntos de archivo", esto es, un grupo de cintas usadas durante un periodo de tiempo para crear respaldos completos de todos los sistemas de ficheros listados en el fichero de configuración de Amanda. El "conjunto de archivo" también contiene respaldos incrementales nocturnos (o diferenciales) de todos los sistemas de ficheros. Para restaurar un sistema de ficheros dañado hace falta el respaldo completo más reciente y los respaldos incrementales.</p></div><div class=paragraph><p>El fichero de configuración ofrece un control exhaustivo de los respaldos y del tráfico de red que Amanda genera. Amanda usará cualquiera de los programas de respaldo mencionados arriba para escribir los datos a cinta. Puede instalar Amanda como paquete y como port. No forma parte del sistema base.</p></div></div><div class=sect3><h4 id=_no_hacer_nada>18.11.6. No hacer nada<a class=anchor href=#_no_hacer_nada></a></h4><div class=paragraph><p>"No hacer nada" no es un programa, pero es la estrategia de respaldo más extendida. No tiene coste. No hay un calendario de respaldos a seguir. Simplemente hay que decir <em>que no</em>. Si algo le sucediera a sus datos <em>sonría y acostúmbrese a su nueva situación</em>.</p></div><div class=paragraph><p>Si su tiempo y sus datos valen poco o nada, entonces "no hacer nada" es el programa de respaldo más adecuado para usted. Pero cuidado, UNIX® es una herramienta muy poderosa y puede suceder que dentro de seis meses tenga un montón de ficheros que sean valiosos para usted.</p></div><div class=paragraph><p>"No hacer nada" es el método correcto de respaldo para <span class=filename>/usr/obj</span> y otros árboles de directorios que pueden ser fácilmente recreados por su computadora. Un ejemplo son los archivos que forman la versión HTML o PostScript® de este manual. Estos documentos han sido generados desde ficheros SGML. Crear respaldos de los archivos HTML o PostScript® no es necesario dado que los ficheros SGML se respaldan regularmente.</p></div></div><div class=sect3><h4 id=_cuál_es_el_mejor_programa_de_respaldos>18.11.7. ?Cuál es el mejor programa de respaldos?<a class=anchor href=#_cuál_es_el_mejor_programa_de_respaldos></a></h4><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=dump&amp;sektion=8&amp;format=html">dump(8)</a>. <em>Y no hay más que hablar.</em> Elizabeth D. Zwicky realizó pruebas de estrés a a todos los programas de copia de seguridad aquí expuestos. La elección clarísima para preservar todos sus datos y todas las peculiaridades de sus sistemas de ficheros UNIX® es <code>dump</code>. Elizabeth creó sistemas de ficheros conteniendo una gran variedad de condiciones inusuales (y algunos no tan inusuales) y probó cada programa haciendo un respaldo y restaurando esos sistemas de ficheros. Esas peculiaridades incluían: ficheros con y un bloque nulo, ficheros con caracteres extraños en sus nombres, ficheros que no se podían leer ni escribir, dispositivos, ficheros que cambiaban de tamaño durante el respaldo, ficheros que eran creados/borrados durante el respaldo y cosas así. Elizabeth presentó los resultados en LISA V en octubre de 1991. Consulte <a href=http://berdmann.dyndns.org/zwicky/testdump.doc.html>torture-testing Backup and Archive Programs</a>.</p></div></div><div class=sect3><h4 id=_procedimiento_de_restauración_de_emergencia>18.11.8. Procedimiento de restauración de emergencia<a class=anchor href=#_procedimiento_de_restauración_de_emergencia></a></h4><div class=sect4><h5 id=_antes_del_desastre>18.11.8.1. Antes del desastre<a class=anchor href=#_antes_del_desastre></a></h5><div class=paragraph><p>Solamente existen cuatro pasos que debe realizar en preparación de cualquier desastre que pudiera ocurrir.</p></div><div class=paragraph><p>Primero, imprima la etiqueta de disco de cada uno de sus discos (<code>disklabel da0 | lpr</code>), su tabla de sistemas de ficheros (<span class=filename>/etc/fstab</span>) y todos los mensajes de arranque, dos copias de cada uno.</p></div><div class=paragraph><p>Segundo, asegúrese que los disquetes de rescate (<span class=filename>boot.flp</span> y <span class=filename>fixit.flp</span>) tienen todos sus dispositivos. La manera más fácil de revisarlo es reiniciar su máquina con el disquete en la unidad y revisar los mensajes de arranque. Si todos sus dispositivos aparecen en la lista y funcionan, pase al tercer paso.</p></div><div class=paragraph><p>Si ha habido algún problema tiene que crear dos disquetes de arranque personalizados, que deben tener un kernel que pueda montar todos sus discos y acceder a su unidad de cinta. Estos discos deben contener: <code>fdisk</code>, <code>disklabel</code>, <code>newfs</code>, <code>mount</code> y cualquier programa de respaldo que utilice. Estos programas deben estar enlazados estáticamente. Si usa <code>dump</code>, el disquete debe contener <code>restore</code>.</p></div><div class=paragraph><p>Tercero, use cintas de respaldo regularmente. Cualquier cambio que haga después de su último respaldo puede perderse irremediablemente. Proteja contra escritura las cintas de respaldo.</p></div><div class=paragraph><p>Cuarto, pruebe los disquetes (ya sea <span class=filename>boot.flp</span> y <span class=filename>fixit.flp</span> o los dos discos personalizados que creó en el segundo paso) y las cintas de respaldo. Documente el procedimiento. Almacene estas notas con los discos de arranque, las impresiones y las cintas de respaldo. Estará tan perturbado cuando restaure su sistema que las notas pueden pueden evitar que destruya sus cintas de respaldo. (?Como? en lugar de <code>tar xvf /dev/sa0</code>, puede teclear accidentalmente <code>tar cvf /dev/sa0</code> y sobreescribir su cinta).</p></div><div class=paragraph><p>Como medida adicional de seguridad haga discos de inicio y dos cintas de respaldo cada vez. Almacene una de cada en una ubicación remota. Una ubicación remota <em>NO</em> es el sótano del mismo edificio. Muchas firmas alojadas en el World Trade Center aprendieron esta leccón de la manera más difícil. Esa ubicación remota debe estar separada físicamente de sus computadoras y unidades de disco por una distancia significativa.</p></div><div class=exampleblock><div class=title>Ejemplo 22. Un "script" para la creación de discos flexibles de arranque</div><div class=content><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
#
# create a restore floppy
#
# format the floppy
#
PATH=/bin:/sbin:/usr/sbin:/usr/bin

fdformat -q fd0
if [ $? -ne 0 ]
then
	 echo &#34;Bad floppy, please use a new one&#34;
	 exit 1
fi

# place boot blocks on the floppy
#
disklabel -w -B /dev/fd0c fd1440

#
# newfs the one and only partition
#
newfs -t 2 -u 18 -l 1 -c 40 -i 5120 -m 5 -o space /dev/fd0a

#
# mount the new floppy
#
mount /dev/fd0a /mnt

#
# create required directories
#
mkdir /mnt/dev
mkdir /mnt/bin
mkdir /mnt/sbin
mkdir /mnt/etc
mkdir /mnt/root
mkdir /mnt/mnt			# for the root partition
mkdir /mnt/tmp
mkdir /mnt/var

#
# populate the directories
#
if [ ! -x /sys/compile/MINI/kernel ]
then
	 cat &amp;lt;&amp;lt; EOM
The MINI kernel does not exist, please create one.
Here is an example config file:
#
# MINI - A kernel to get FreeBSD onto a disk.
#
machine         &#34;i386&#34;
cpu             &#34;I486_CPU&#34;
ident           MINI
maxusers        5

options         INET                    # needed for _tcp _icmpstat _ipstat
                                        #            _udpstat _tcpstat _udb
options         FFS                     #Berkeley Fast File System
options         FAT_CURSOR              #block cursor in syscons or pccons
options         SCSI_DELAY=15           #Be pessimistic about Joe SCSI device
options         NCONS=2                 #1 virtual consoles
options         USERCONFIG              #Allow user configuration with -c XXX

config          kernel	root on da0 swap on da0 and da1 dumps on da0

device          isa0
device          pci0

device          fdc0	at isa? port &#34;IO_FD1&#34; bio irq 6 drq 2 vector fdintr
device          fd0	at fdc0 drive 0

device          ncr0

device          scbus0

device          sc0	at isa? port &#34;IO_KBD&#34; tty irq 1 vector scintr
device          npx0	at isa? port &#34;IO_NPX&#34; irq 13 vector npxintr

device          da0
device          da1
device          da2

device          sa0

pseudo-device   loop            # required by INET
pseudo-device   gzip            # Exec gzipped a.out&#39;s
EOM
	 exit 1
fi

cp -f /sys/compile/MINI/kernel /mnt

gzip -c -best /sbin/init &gt; /mnt/sbin/init
gzip -c -best /sbin/fsck &gt; /mnt/sbin/fsck
gzip -c -best /sbin/mount &gt; /mnt/sbin/mount
gzip -c -best /sbin/halt &gt; /mnt/sbin/halt
gzip -c -best /sbin/restore &gt; /mnt/sbin/restore

gzip -c -best /bin/sh &gt; /mnt/bin/sh
gzip -c -best /bin/sync &gt; /mnt/bin/sync

cp /root/.profile /mnt/root

cp -f /dev/MAKEDEV /mnt/dev
chmod 755 /mnt/dev/MAKEDEV

chmod 500 /mnt/sbin/init
chmod 555 /mnt/sbin/fsck /mnt/sbin/mount /mnt/sbin/halt
chmod 555 /mnt/bin/sh /mnt/bin/sync
chmod 6555 /mnt/sbin/restore

#
# create the devices nodes
#
cd /mnt/dev
./MAKEDEV std
./MAKEDEV da0
./MAKEDEV da1
./MAKEDEV da2
./MAKEDEV sa0
./MAKEDEV pty0
cd /

#
# create minimum file system table
#
cat &gt; /mnt/etc/fstab &amp;lt;&amp;lt;EOM
/dev/fd0a    /    ufs    rw  1  1
EOM

#
# create minimum passwd file
#
cat &gt; /mnt/etc/passwd &amp;lt;&amp;lt;EOM
root:*:0:0:Charlie &amp;amp;:/root:/bin/sh
EOM

cat &gt; /mnt/etc/master.passwd &amp;lt;&amp;lt;EOM
root::0:0::0:0:Charlie &amp;amp;:/root:/bin/sh
EOM

chmod 600 /mnt/etc/master.passwd
chmod 644 /mnt/etc/passwd
/usr/sbin/pwd_mkdb -d/mnt/etc /mnt/etc/master.passwd

#
# umount the floppy and inform the user
#
/sbin/umount /mnt
echo &#34;The floppy has been unmounted and is now ready.&#34;</pre></div></div></div></div></div><div class=sect4><h5 id=_después_del_desastre>18.11.8.2. Después del desastre<a class=anchor href=#_después_del_desastre></a></h5><div class=paragraph><p>La pregunta clave es: ?sobrevivió su hardware? Ha estado haciendo respaldos regularmente, así que no hay necesidad de preocuparse por el software.</p></div><div class=paragraph><p>Si el hardware ha sufrido daños los componentes deben reemplazarse antes de intentar de usar su sistema.</p></div><div class=paragraph><p>Si su hardware está bien revise sus discos de arranque. Si usa disquetes de arranque personalizados arranque en modo monousuario (teclée <code>-s</code> en el en el "prompt" de arranque <code>boot:</code>). Sáltese el siguiente párrafo.</p></div><div class=paragraph><p>Si utiliza usando los discos <span class=filename>boot.flp</span> y <span class=filename>fixit.flp</span>, siga leyendo. Inserte el disco <span class=filename>boot.flp</span> en la primera unidad de disquete y arranque la máquina. El menú de instalación original se desplegará en pantalla. Seleccione la opción <code>Fixit—​Repair mode with CDROM or floppy.</code>. Inserte el disco <span class=filename>fixit.flp</span> cuando se le pida. Tanto <code>restore</code> como los demás programas que necesitará están en <span class=filename>/mnt2/rescue</span> (<span class=filename>/mnt2/stand</span> para versiones de FreeBSD anteriores a 5.2).</p></div><div class=paragraph><p>Recupere cada sistema de ficheros por separado.</p></div><div class=paragraph><p>Trate de montar (por ejemplo <code>mount /dev/da0a /mnt</code>) la partición raíz de su primer disco. Si la etiqueta del disco ha sufrido daños use <code>disklabel</code> para reparticionar y etiquetar el disco de forma que coincida con la etiqueta que imprimió y guardó previamente. Use <code>newfs</code> para crear de nuevo sus sistemas de ficheros. Monte de nuevo la partición raíz del disquete en modo lectura/escritura (<code>mount -u -o rw /mnt</code>). Ejecute su programa de respaldo y utilice las cintas de respaldo para restaurar sus datos en este sistema de ficheros (<code>restore vrf /dev/sa0</code>). Desmonte el sistema de ficheros (<code>umount /mnt</code>). Repita el proceso con cada sistema de ficheros que sufrió daños.</p></div><div class=paragraph><p>Una vez que su sistema esté en marcha respalde sus datos en cintas nuevas. Cualquiera que haya sido la causa de la caída o pérdida de datos puede suceder de nuevo. Una hora más que gaste ahora puede ahorrarle mucho sufrimiento más adelante.</p></div></div></div></div><div class=sect2><h3 id=disks-virtual>18.12. Sistemas de ficheros en red, memoria y respaldados en fichero<a class=anchor href=#disks-virtual></a></h3><div class=paragraph><p>Además de los discos que conecta físicamente en su máquina (discos flexibles, CDs, discos duros, etc.) FreeBSD permite usar otro tipo de discos: <em>los discos virtuales</em>.</p></div><div class=paragraph><p>Esto incluye sistemas de ficheros en red como <a href=./#network-nfs>NFS</a> y Coda, sistemas de ficheros basados en memoria y sistemas de ficheros basados en fichero.</p></div><div class=paragraph><p>Según la versión de FreeBSD que utilice tendrá que utilizar diferentes herramientas para la creación y uso de sistemas de ficheros en memoria y sistemas de ficheros basados en fichero.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Los usuarios de FreeBSD 4.X tendrán que usar <a href="https://man.freebsd.org/cgi/man.cgi?query=MAKEDEV&amp;sektion=8&amp;format=html">MAKEDEV(8)</a> para crear los dispositivos requeridos. FreeBSD 5.0 y posteriores usan <a href="https://man.freebsd.org/cgi/man.cgi?query=devfs&amp;sektion=5&amp;format=html">devfs(5)</a> para gestionar los nodos de dispositivo correspondientes de forma transparente para el usuario.</p></div></td></tr></tbody></table></div><div class=sect3><h4 id=disks-vnconfig>18.12.1. Sistema de ficheros basado en fichero en FreeBSD 4.X<a class=anchor href=#disks-vnconfig></a></h4><div class=paragraph><p>La utilidad <a href="https://man.freebsd.org/cgi/man.cgi?query=vnconfig&amp;sektion=8&amp;format=html">vnconfig(8)</a> configura y habilita vnodes de dispositivos de pseudodisco. Un <em>vnode</em> es una representación de un fichero y es el enfoque de la actividad de fichero. Esto significa que <a href="https://man.freebsd.org/cgi/man.cgi?query=vnconfig&amp;sektion=8&amp;format=html">vnconfig(8)</a> utiliza ficheros para crear y operar un sistema de ficheros. Un uso posible es el montaje de imágenes de disquetes o CD almacenadas como ficheros.</p></div><div class=paragraph><p>Para poder usar <a href="https://man.freebsd.org/cgi/man.cgi?query=vnconfig&amp;sektion=8&amp;format=html">vnconfig(8)</a> necesitará tener <a href="https://man.freebsd.org/cgi/man.cgi?query=vn&amp;sektion=4&amp;format=html">vn(4)</a> en el fichero de configuración de su kernel:</p></div><div class="literalblock programlisting"><div class=content><pre>pseudo-device vn</pre></div></div><div class=paragraph><p>Para montar una imagen de un sistema de ficheros:</p></div><div class=exampleblock><div class=title>Ejemplo 23. Uso de vnconfig para montar una imagen de un sistema de ficheros bajo FreeBSD 4.X</div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># vnconfig vn0 imagendedisco</span>
<span class=c># mount /dev/vn0c /mnt</span></code></pre></div></div></div></div><div class=paragraph><p>Para crear una nueva imagen de un sistema de ficheros con <a href="https://man.freebsd.org/cgi/man.cgi?query=vnconfig&amp;sektion=8&amp;format=html">vnconfig(8)</a>:</p></div><div class=exampleblock><div class=title>Ejemplo 24. Creación de una imagen nueva de un sistema de ficheros respaldado en un archivo con <code>vnconfig</code></div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dd if=/dev/zero of=nuevaimagen bs=1k count=5k</span>
5120+0 records <span class=k>in
</span>5120+0 records out
<span class=c># vnconfig -s labels -c vn0 nuevaimagen</span>
<span class=c># disklabel -r -w vn0 auto</span>
<span class=c># newfs vn0c</span>
Warning: 2048 sector<span class=o>(</span>s<span class=o>)</span> <span class=k>in </span>last cylinder unallocated
/dev/vn0c:     10240 sectors <span class=k>in </span>3 cylinders of 1 tracks, 4096 sectors
        5.0MB <span class=k>in </span>1 cyl <span class=nb>groups</span> <span class=o>(</span>16 c/g, 32.00MB/g, 1280 i/g<span class=o>)</span>
super-block backups <span class=o>(</span><span class=k>for </span>fsck <span class=nt>-b</span> <span class=c>#) at:</span>
 32
<span class=c># mount /dev/vn0c /mnt</span>
<span class=c># df /mnt</span>
Filesystem  1K-blocks     Used    Avail Capacity  Mounted on
/dev/vn0c        4927        1     4532     0%    /mnt</code></pre></div></div></div></div></div><div class=sect3><h4 id=disks-mdconfig>18.12.2. Sistemas de ficheros basados en fichero en FreeBSD 5.X<a class=anchor href=#disks-mdconfig></a></h4><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=mdconfig&amp;sektion=8&amp;format=html">mdconfig(8)</a> se usa para configurar y habilitar discos habilitar discos de memoria, <a href="https://man.freebsd.org/cgi/man.cgi?query=md&amp;sektion=4&amp;format=html">md(4)</a>, en FreeBSD 5.X. Para usar <a href="https://man.freebsd.org/cgi/man.cgi?query=mdconfig&amp;sektion=8&amp;format=html">mdconfig(8)</a>, tendrá que cargar el módulo <a href="https://man.freebsd.org/cgi/man.cgi?query=md&amp;sektion=4&amp;format=html">md(4)</a> o añadir soporte para el mismo el el fichero de configuración del kernel:</p></div><div class="literalblock programlisting"><div class=content><pre>device md</pre></div></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=mdconfig&amp;sektion=8&amp;format=html">mdconfig(8)</a> soporta tres tipos de discos virtuales en memoria: discos de memoria asignados mediante <a href="https://man.freebsd.org/cgi/man.cgi?query=malloc&amp;sektion=9&amp;format=html">malloc(9)</a>, discos de memoria usando un fichero o espacio de swap como respaldo. Un uso posible es montar imágenes de disquetes o CD archivadas.</p></div><div class=paragraph><p>Para montar una imagen de un sistema de ficheros:</p></div><div class=exampleblock><div class=title>Ejemplo 25. Uso de <code>mdconfig</code> para montar una imagen de un sistema de ficheros en FreeBSD 5.X</div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mdconfig -a -t vnode -f imagendedisco -u 0</span>
<span class=c># mount /dev/md0 /mnt</span></code></pre></div></div></div></div><div class=paragraph><p>Para crear una imagen nueva de un sistema de ficheros con <a href="https://man.freebsd.org/cgi/man.cgi?query=mdconfig&amp;sektion=8&amp;format=html">mdconfig(8)</a>:</p></div><div class=exampleblock><div class=title>Ejemplo 26. Creación de un disco respaldado en fichero con <code>mdconfig</code></div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dd if=/dev/zero of=nuevaimagen bs=1k count=5k</span>
5120+0 records <span class=k>in
</span>5120+0 records out
<span class=c># mdconfig -a -t vnode -f nuevaimagen -u 0</span>
<span class=c># disklabel -r -w md0 auto</span>
<span class=c># newfs md0c</span>
/dev/md0c: 5.0MB <span class=o>(</span>10240 sectors<span class=o>)</span> block size 16384, fragment size 2048
	using 4 cylinder <span class=nb>groups </span>of 1.27MB, 81 blks, 256 inodes.
super-block backups <span class=o>(</span><span class=k>for </span>fsck <span class=nt>-b</span> <span class=c>#) at:</span>
 32, 2624, 5216, 7808
<span class=c># mount /dev/md0c /mnt</span>
<span class=c># df /mnt</span>
Filesystem  1K-blocks     Used    Avail Capacity  Mounted on
/dev/md0c        4846        2     4458     0%    /mnt</code></pre></div></div></div></div><div class=paragraph><p>Si no especifica el número de unidad con la opción <code>-u</code> <a href="https://man.freebsd.org/cgi/man.cgi?query=mdconfig&amp;sektion=8&amp;format=html">mdconfig(8)</a> usará la designación automática de <a href="https://man.freebsd.org/cgi/man.cgi?query=md&amp;sektion=4&amp;format=html">md(4)</a> para seleccionar un dispositivo sin usar. El nombre de la unidad designada se enviará a la salida esándar como <span class=filename>md4</span>. Para más información sobre <a href="https://man.freebsd.org/cgi/man.cgi?query=mdconfig&amp;sektion=8&amp;format=html">mdconfig(8)</a> consulte su página de manual.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>A partir de FreeBSD 5.1-RELEASE <a href="https://man.freebsd.org/cgi/man.cgi?query=bsdlabel&amp;sektion=8&amp;format=html">bsdlabel(8)</a> reemplazó a <a href="https://man.freebsd.org/cgi/man.cgi?query=disklabel&amp;sektion=8&amp;format=html">disklabel(8)</a>. En <a href="https://man.freebsd.org/cgi/man.cgi?query=bsdlabel&amp;sektion=8&amp;format=html">bsdlabel(8)</a> se eliminaron muchas opciones y parámetros obsoletos. En el ejemplo de arriba ignore la opción <code>-r</code>. Para más información consulte la página de manual de <a href="https://man.freebsd.org/cgi/man.cgi?query=bsdlabel&amp;sektion=8&amp;format=html">bsdlabel(8)</a>.</p></div></td></tr></tbody></table></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=mdconfig&amp;sektion=8&amp;format=html">mdconfig(8)</a> es muy útil, aunque requiere muchas líneas de comando para crear un sistema de ficheros basado en un fichero. FreeBSD 5.0 incorpora <a href="https://man.freebsd.org/cgi/man.cgi?query=mdmfs&amp;sektion=8&amp;format=html">mdmfs(8)</a>, que configura un disco <a href="https://man.freebsd.org/cgi/man.cgi?query=md&amp;sektion=4&amp;format=html">md(4)</a> utilizando <a href="https://man.freebsd.org/cgi/man.cgi?query=mdconfig&amp;sektion=8&amp;format=html">mdconfig(8)</a>, pone un sistema de ficheros UFS en él mediante <a href="https://man.freebsd.org/cgi/man.cgi?query=newfs&amp;sektion=8&amp;format=html">newfs(8)</a> y lo monta usando <a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a>. Por ejemplo, si desea crear y montar la misma imagen de sistema de ficheros de arriba, simplemente teclée lo siguiente:</p></div><div class=exampleblock><div class=title>Ejemplo 27. Configurar y montar un disco basado en un fichero con <code>mdmfs</code></div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dd if=/dev/zero of=nuevaimagen bs=1k count=5k</span>
5120+0 records <span class=k>in
</span>5120+0 records out
<span class=c># mdmfs -F newimage -s 5m md0 /mnt</span>
<span class=c># df /mnt</span>
Filesystem 1K-blocks Used Avail Capacity  Mounted on
/dev/md0        4846    2  4458     0%    /mnt</code></pre></div></div></div></div><div class=paragraph><p>Si utiliza la opción <code>md</code> sin número de unidad, <a href="https://man.freebsd.org/cgi/man.cgi?query=mdmfs&amp;sektion=8&amp;format=html">mdmfs(8)</a> usará la opción de auto unidad de <a href="https://man.freebsd.org/cgi/man.cgi?query=md&amp;sektion=4&amp;format=html">md(4)</a> para selecionar automáticamente un dispositivo sin usar. Para más información sobre <a href="https://man.freebsd.org/cgi/man.cgi?query=mdmfs&amp;sektion=8&amp;format=html">mdmfs(8)</a> diríjase a la página de manual.</p></div></div><div class=sect3><h4 id=disks-md-freebsd4>18.12.3. Sistemas de ficheros basados en memoria en FreeBSD 4.X<a class=anchor href=#disks-md-freebsd4></a></h4><div class=paragraph><p>El controlador <a href="https://man.freebsd.org/cgi/man.cgi?query=md&amp;sektion=4&amp;format=html">md(4)</a> es un modo sencillo y eficiente de crear sistemas de ficheros basados en memoria en FreeBSD 4.X. <a href="https://man.freebsd.org/cgi/man.cgi?query=malloc&amp;sektion=9&amp;format=html">malloc(9)</a> se usa para ubicar la memoria.</p></div><div class=paragraph><p>Sencillamete toma un sistema de ficheros que usted ha preparado con, por ejemplo, <a href="https://man.freebsd.org/cgi/man.cgi?query=vnconfig&amp;sektion=8&amp;format=html">vnconfig(8)</a>, y:</p></div><div class=exampleblock><div class=title>Ejemplo 28. Disco de memoria md en FreeBSD 4.X</div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dd if=nuevaimagen of=/dev/md0</span>
5120+0 records <span class=k>in
</span>5120+0 records out
<span class=c># mount /dev/md0c /mnt</span>
<span class=c># df /mnt</span>
Filesystem  1K-blocks     Used    Avail Capacity  Mounted on
/dev/md0c        4927        1     4532     0%    /mnt</code></pre></div></div></div></div><div class=paragraph><p>Para más información por favor consulte la página de manual de <a href="https://man.freebsd.org/cgi/man.cgi?query=md&amp;sektion=4&amp;format=html">md(4)</a>.</p></div></div><div class=sect3><h4 id=disks-md-freebsd5>18.12.4. sistemas de ficheros basados en memoria en FreeBSD 5.X<a class=anchor href=#disks-md-freebsd5></a></h4><div class=paragraph><p>Se usan las mismas herramientas para tratar con sistemas de ficheros basados en memoria o en ficheros: <a href="https://man.freebsd.org/cgi/man.cgi?query=mdconfig&amp;sektion=8&amp;format=html">mdconfig(8)</a> o <a href="https://man.freebsd.org/cgi/man.cgi?query=mdmfs&amp;sektion=8&amp;format=html">mdmfs(8)</a>. El almacenamiento de sistemas de ficheros basados en memoria requiere el uso de <a href="https://man.freebsd.org/cgi/man.cgi?query=malloc&amp;sektion=9&amp;format=html">malloc(9)</a>.</p></div><div class=exampleblock><div class=title>Ejemplo 29. Creación de un nuevo disco basado en memoria con <code>mdconfig</code></div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mdconfig -a -t malloc -s 5m -u 1</span>
<span class=c># newfs -U md1</span>
/dev/md1: 5.0MB <span class=o>(</span>10240 sectors<span class=o>)</span> block size 16384, fragment size 2048
	using 4 cylinder <span class=nb>groups </span>of 1.27MB, 81 blks, 256 inodes.
	with soft updates
super-block backups <span class=o>(</span><span class=k>for </span>fsck <span class=nt>-b</span> <span class=c>#) at:</span>
 32, 2624, 5216, 7808
<span class=c># mount /dev/md1 /mnt</span>
<span class=c># df /mnt</span>
Filesystem 1K-blocks Used Avail Capacity  Mounted on
/dev/md1        4846    2  4458     0%    /mnt</code></pre></div></div></div></div><div class=exampleblock><div class=title>Ejemplo 30. Creación de un nuevo disco basado en memoria con <code>mdmfs</code></div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mdmfs -M -s 5m md2 /mnt</span>
<span class=c># df /mnt</span>
Filesystem 1K-blocks Used Avail Capacity  Mounted on
/dev/md2        4846    2  4458     0%    /mnt</code></pre></div></div></div></div><div class=paragraph><p>En lugar de usar un sistema de ficheros respaldado en <a href="https://man.freebsd.org/cgi/man.cgi?query=malloc&amp;sektion=9&amp;format=html">malloc(9)</a>, es posible utilizar swap; lo único que debe hacer es sustituir <code>malloc</code> por <code>swap</code> en la línea de comando de <a href="https://man.freebsd.org/cgi/man.cgi?query=mdconfig&amp;sektion=8&amp;format=html">mdconfig(8)</a>. <a href="https://man.freebsd.org/cgi/man.cgi?query=mdmfs&amp;sektion=8&amp;format=html">mdmfs(8)</a> por defecto (sin <code>-M</code>) crea un disco basado en swap). Para más información, consulte las páginas de manual de <a href="https://man.freebsd.org/cgi/man.cgi?query=mdconfig&amp;sektion=8&amp;format=html">mdconfig(8)</a> y de <a href="https://man.freebsd.org/cgi/man.cgi?query=mdmfs&amp;sektion=8&amp;format=html">mdmfs(8)</a>.</p></div></div><div class=sect3><h4 id=_desconexión_del_sistema_de_un_disco_de_memoria>18.12.5. Desconexión del sistema de un disco de memoria<a class=anchor href=#_desconexión_del_sistema_de_un_disco_de_memoria></a></h4><div class=paragraph><p>Cuando un sistema de ficheros basado en memoria o basado en fichero no se usa puede liberar recursos del sistema. Lo primero es desmontar el sistema de ficheros: use <a href="https://man.freebsd.org/cgi/man.cgi?query=mdconfig&amp;sektion=8&amp;format=html">mdconfig(8)</a> para desconectar el disco del sistema y liberar dichos recursos.</p></div><div class=paragraph><p>Por ejemplo, para desconectar y liberar todos los recursos usados por <span class=filename>/dev/md4</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mdconfig -d -u 4</span></code></pre></div></div><div class=paragraph><p>Es posible listar información sobre dispositivos <a href="https://man.freebsd.org/cgi/man.cgi?query=md&amp;sektion=4&amp;format=html">md(4)</a> configurados en el sistema mediante <code>mdconfig -l</code>.</p></div><div class=paragraph><p>En FreeBSD 4.X se usa <a href="https://man.freebsd.org/cgi/man.cgi?query=vnconfig&amp;sektion=8&amp;format=html">vnconfig(8)</a> para desconectar el dispositivo. Por ejemplo, para desconectar y liberar todos los recursos usados por <span class=filename>/dev/vn4</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># vnconfig -u vn4</span></code></pre></div></div></div></div><div class=sect2><h3 id=snapshots>18.13. Instantáneas ("snapshots") de sistemas de ficheros<a class=anchor href=#snapshots></a></h3><div class=paragraph><p>FreeBSD 5.0 ofrece una característica relacionada con <a href=./#soft-updates>Soft Updates</a>: las instantáneas del sistema de ficheros.</p></div><div class=paragraph><p>Las instantáneas permiten a un usuario crear imágenes de uno o más sistemas de ficheros dados, y tratarlas como un fichero. Los ficheros de instantánea deben crearse en el sistema de ficheros en el que se realiza la acción, y un usuario puede crear hasta 20 (veinte) instantáneas por sistema de ficheros. Las instantáneas activas se graban en el superbloque, lo que hace que sigan ahí independientemente de montajes, remontajes y reinicios del sistema. Cuando ya no necesite una instantánea puede borrarla con <a href="https://man.freebsd.org/cgi/man.cgi?query=rm&amp;sektion=1&amp;format=html">rm(1)</a>. Las instantáneas pueden borrarse en cualquier orden pero puede que no pueda recuperar todo el espacio debido a que otra instantánea puede reclamar algunos bloques liberados.</p></div><div class=paragraph><p>La bandera inalterable de fichero <code>snapshot</code> se activa con <a href="https://man.freebsd.org/cgi/man.cgi?query=mksnap_ffs&amp;sektion=8&amp;format=html">mksnap_ffs(8)</a> después de la creación inicial de un fichero de instantánea. <a href="https://man.freebsd.org/cgi/man.cgi?query=unlink&amp;sektion=1&amp;format=html">unlink(1)</a> hace una excepción con los ficheros de instantánea, ya que permite que se les borre.</p></div><div class=paragraph><p>Las instantáneas se crean con <a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a>. Veamos un ejemplo. Vamos a colocar una instantánea de <span class=filename>/var</span> en <span class=filename>/var/snapshot/snap</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount -u -o snapshot /var/snapshot/snap /var</span></code></pre></div></div><div class=paragraph><p>También puede usar <a href="https://man.freebsd.org/cgi/man.cgi?query=mksnap_ffs&amp;sektion=8&amp;format=html">mksnap_ffs(8)</a> para crear una instantánea:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mksnap_ffs /var /var/snapshot/snap</span></code></pre></div></div><div class=paragraph><p>Si busca ficheros de instantánea en un sistema de de ficheros (por ejemplo <span class=filename>/var</span>) puede usar <a href="https://man.freebsd.org/cgi/man.cgi?query=find&amp;sektion=1&amp;format=html">find(1)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># find /var -flags snapshot</span></code></pre></div></div><div class=paragraph><p>Una instantánea tiene distintos usos:</p></div><div class=ulist><ul><li><p>Algunos administradores usan un fichero de instantánea como respaldo, puesto que la instantánea puede guardarse en CD o cinta.</p></li><li><p>Integridad de ficheros; <a href="https://man.freebsd.org/cgi/man.cgi?query=fsck&amp;sektion=8&amp;format=html">fsck(8)</a> puede ejecutarse en una instantánea. Asumiendo que el sistema de ficheros estuviera limpio cuando se montó se debe obtener un resultado limpio (e intacto). En esencia el proceso <a href="https://man.freebsd.org/cgi/man.cgi?query=fsck&amp;sektion=8&amp;format=html">fsck(8)</a> hace esto mismo en segundo plano.</p></li><li><p>Ejecución de <a href="https://man.freebsd.org/cgi/man.cgi?query=dump&amp;sektion=8&amp;format=html">dump(8)</a> en la instantánea. Se obtendrá un dump consistente con el sistema de ficheros y los sellos de hora de la instantánea. <a href="https://man.freebsd.org/cgi/man.cgi?query=dump&amp;sektion=8&amp;format=html">dump(8)</a> también puede leer una instantánea, crear una imagen dump y eliminar la instantánea en un comando usando la opción <code>-L</code>.</p></li><li><p>Ejecutar un <a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a> contra la instantánea como una imagen congelada del sistema de ficheros. Para montar la instantánea <span class=filename>/var/snapshot/snap</span> ejecute:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mdconfig -a -t vnode -f /var/snapshot/snap -u 4</span>
<span class=c># mount -r /dev/md4 /mnt</span></code></pre></div></div></li></ul></div><div class=paragraph><p>Podrá recorrer la jerarquía de su sistema de ficheros <span class=filename>/var</span> congelado montado en <span class=filename>/mnt</span>. Todo estará en el mismo estado en el que estaba cuando creó la instantánea. La única excepción es que cualquier instantánea anterior aparecerá como un fichero de longitud cero. Cuando haya acabado de usar una instantánea puede desmontarla con:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># umount /mnt</span>
<span class=c># mdconfig -d -u 4</span></code></pre></div></div><div class=paragraph><p>Para más información sobre <code>softupdates</code> e instantáneas de sistemas ficheros, incluyendo textos técnicos, visite el sitio web de Marshall Kirk McKusick: <a href=http://www.mckusick.com/>http://www.mckusick.com/</a>.</p></div></div><div class=sect2><h3 id=quotas>18.14. Cuotas en sistemas de ficheros<a class=anchor href=#quotas></a></h3><div class=paragraph><p>Las cuotas son una opción del sistema operativo que le permite limitar la cantidad de espacio en disco y/o el número de fichero que un usuario o miembros de un grupo pueden crear en el sistema, pudiendo además hacerlo de forma independiente en cada sistema de ficheros. Suele usarse principalmente en sistemas de tiempo compartido, donde se busca limitar la cantidad de recursos que cualquier usuario o grupo pueden utilizar. Esto evitará que un usuario o un grupo de usuarios consuma todos el espacio disponible en disco.</p></div><div class=sect3><h4 id=_configuración_del_sistema_para_habilitar_cuotas_de_disco>18.14.1. Configuración del sistema para habilitar cuotas de disco<a class=anchor href=#_configuración_del_sistema_para_habilitar_cuotas_de_disco></a></h4><div class=paragraph><p>Antes de intentar configurar el uso de cuotas de disco hay que asegurarse de que las cuotas están activadas en el kernel. La siguiente línea debe estar en el fichero de de configuración del kernel:</p></div><div class="literalblock programlisting"><div class=content><pre>options QUOTA</pre></div></div><div class=paragraph><p>El kernel <span class=filename>GENERIC</span> no lo tiene activado por defecto, así que tendrá que configurar, compilar e instalar un kernel personalizado para poder usar cuotas de disco. Por favor, consulte el <a href=./#kernelconfig>Configuración del kernel de FreeBSD</a> para más información sobre la configuración del kernel.</p></div><div class=paragraph><p>A continuación tendrá que habilitar las cuotas de disco en <span class=filename>/etc/rc.conf</span>. Añadale la siguiente línea:</p></div><div class="literalblock programlisting"><div class=content><pre>enable_quotas=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Hay una variable que le permitirá efectuar un control más exhaustivo sobre el arranque de cuotas. Normalmente se revisa la integridad de cuotas de cada sistema de ficheros en el arranque; el responsable es <a href="https://man.freebsd.org/cgi/man.cgi?query=quotacheck&amp;sektion=8&amp;format=html">quotacheck(8)</a>. <a href="https://man.freebsd.org/cgi/man.cgi?query=quotacheck&amp;sektion=8&amp;format=html">quotacheck(8)</a> se asegura de que los datos que hay en su base de datos de cuotas reflejen realmente los datos del sistema de ficheros. Es un proceso que lleva mucho tiempo y que afectará significativamente al tiempo que tardará su sistema en arrancar. Si desea saltarse ese paso puede usar una variable al efecto en <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>check_quotas=&#34;NO&#34;</pre></div></div><div class=paragraph><p>Para concluir tendrá que editar <span class=filename>/etc/fstab</span> para habilitar las cuotas de disco para cada sistema de ficheros. Es aquí donde podrá habilitar cuotas por usuario, por grupo, o ambos en todos sus sistemas de ficheros.</p></div><div class=paragraph><p>Para habilitar cuotas por usuario en un sistema de ficheros añada la opción <code>userquota</code> al campo de opciones en la entrada de <span class=filename>/etc/fstab</span> que corresponda al sistema de ficheros en el que quiere habilitar las cuotas. Veamos un ejemplo:</p></div><div class="literalblock programlisting"><div class=content><pre>/dev/da1s2g   /home    ufs rw,userquota 1 2</pre></div></div><div class=paragraph><p>En el caso de las cuotas de grupo es muy similar. Use la opción <code>groupquota</code> en lugar de <code>userquota</code>. Para habilitar cuotas por usuario y por grupo modifique la entrada de este modo:</p></div><div class="literalblock programlisting"><div class=content><pre>/dev/da1s2g    /home    ufs rw,userquota,groupquota 1 2</pre></div></div><div class=paragraph><p>Por defecto los ficheros de cuota se guardan en el directorio raíz del sistema de ficheros con los nombres <span class=filename>quota.user</span> y <span class=filename>quota.group</span> para cuotas de usuario y grupo respectivamente. Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=fstab&amp;sektion=5&amp;format=html">fstab(5)</a> para más información. Aunque la página de manual de <a href="https://man.freebsd.org/cgi/man.cgi?query=fstab&amp;sektion=5&amp;format=html">fstab(5)</a> diga que puede especificar otra ubicación para los ficheros de cuota, no se recomienda hacerlo debido a que las diversas herramientas de gestió cuotas no parecen sobrellevar esto adecuadamente.</p></div><div class=paragraph><p>Hecho todo esto puede reiniciar su sistema con el nuevo kernel. <span class=filename>/etc/rc</span> ejecutará automáticamente los comandos apropiados para crear los ficheros de cuota iniciales que requieran todas las entradas en en <span class=filename>/etc/fstab</span>, así que no hay necesidad de crear ficheros de cuota de longitud cero.</p></div><div class=paragraph><p>En el curso normal de operaciones no se le debería pedir que ejecute <a href="https://man.freebsd.org/cgi/man.cgi?query=quotacheck&amp;sektion=8&amp;format=html">quotacheck(8)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=quotaon&amp;sektion=8&amp;format=html">quotaon(8)</a> o <a href="https://man.freebsd.org/cgi/man.cgi?query=quotaoff&amp;sektion=8&amp;format=html">quotaoff(8)</a> manualmente. Sin embargo, tal vez quiera leer sus páginas de manual para familiarizarse con su funcionamiento.</p></div></div><div class=sect3><h4 id=_configuración_de_límites_de_cuota>18.14.2. Configuración de límites de cuota<a class=anchor href=#_configuración_de_límites_de_cuota></a></h4><div class=paragraph><p>Una vez que tenga configurado su sistema para usar cuotas verifique que en realidad estén habilitadas. Una manera sencilla de hacer esto es ejecutar:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># quota -v</span></code></pre></div></div><div class=paragraph><p>Debe ver un resumen de una sola línea de uso del disco y los límites de cuota actuales para cada sistema de ficheros donde estén habilitadas las cuotas.</p></div><div class=paragraph><p>Ahora puede iniciar la asignación de límites de cuota con <a href="https://man.freebsd.org/cgi/man.cgi?query=edquota&amp;sektion=8&amp;format=html">edquota(8)</a>.</p></div><div class=paragraph><p>Tiene varias opciones para imponer límites en el espacio de disco que un usuario o grupo puede ocupar, y cuántos ficheros pueden crear. Puede limitar el uso de disco basándose en el espacio en disco (cuotas de bloque) o en el número de ficheros (cuotas de inodo) o una combinación de ambas. Cada uno de estos límites a su vez se divide en dos categorías: límites duros y suaves.</p></div><div class=paragraph><p>Un límite duro no puede ser excedido. Una vez que un usuario alcanza su límite duro no puede realizar más ubicaciones en el sistema de ficheros en cuestión. Por ejemplo, si el usuario tiene un límite duro de 500 kbytes en un sistema de ficheros y está utilizando 490 kbytes, el usuario solo puede ocupar otros 10 kbytes. Un intento de ocupar 11 kbytes más fallará.</p></div><div class=paragraph><p>Los límites suaves pueden excederse por un periodo Este periodo de tiempo recibe el nombre de periodo de gracia, que por defecto es una semana. Si un usuario sobrepasa su periodo de gracia el límite suave se convertirá en un límite duro y no se permitirán usos de disco adicionales. Cuando el usuario devuelve su cuota de uso de recursos a un punto por debajo de su límite suave el periodo de gracia se reinicia.</p></div><div class=paragraph><p>Veamos un ejemplo de uso de <a href="https://man.freebsd.org/cgi/man.cgi?query=edquota&amp;sektion=8&amp;format=html">edquota(8)</a>. Si se usa <a href="https://man.freebsd.org/cgi/man.cgi?query=edquota&amp;sektion=8&amp;format=html">edquota(8)</a> se entra en el el editor declarado en la variable de entorno <code>EDITOR</code>, o en el editor vi si no ha modificado el valor por defecto de la variable <code>EDITOR</code>, para que pueda editar los límites de cuota.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># edquota -u test</span></code></pre></div></div><div class="literalblock programlisting"><div class=content><pre>Quotas for user test:
/usr: kbytes in use: 65, limits (soft = 50, hard = 75)
        inodes in use: 7, limits (soft = 50, hard = 60)
/usr/var: kbytes in use: 0, limits (soft = 50, hard = 75)
        inodes in use: 0, limits (soft = 50, hard = 60)</pre></div></div><div class=paragraph><p>Debería ver dos líneas por cada sistema de ficheros que tenga habilitadas las cuotas. Una línea para los límites de bloque y una línea para límites de inodo. Por ejemplo, para elevar los límites de este usuario de un límite suave de 50 y un límite duro de 75 a un límite suave de 500 y un límite duro de 600, cambie:</p></div><div class="literalblock programlisting"><div class=content><pre>/usr: kbytes in use: 65, limits (soft = 50, hard = 75)</pre></div></div><div class=paragraph><p>por:</p></div><div class="literalblock programlisting"><div class=content><pre>/usr: kbytes in use: 65, limits (soft = 500, hard = 600)</pre></div></div><div class=paragraph><p>Los nuevos límites de cuota se aplicarán en cuanto salga del editor.</p></div><div class=paragraph><p>Algunas veces se quieren activar límites de cuota en un rango de UIDs. Esto puede realizarse con la opción <code>-p</code> de <a href="https://man.freebsd.org/cgi/man.cgi?query=edquota&amp;sektion=8&amp;format=html">edquota(8)</a>. Primero asigne el límite de cuota deseado a un usuario y luego ejecute <code>edquota -p protouser startuid-enduid</code>. Por ejemplo, si el usuario <code>test</code> tiene el límite de cuota deseado, el siguiente comando puede usarse para duplicar esos límites de cuota para los UIDs de 10,000 hasta 19,999:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># edquota -p test 10000-19999</span></code></pre></div></div><div class=paragraph><p>Para más información consulte la página de manual <a href="https://man.freebsd.org/cgi/man.cgi?query=edquota&amp;sektion=8&amp;format=html">edquota(8)</a>.</p></div></div><div class=sect3><h4 id=_revisión_de_los_límites_de_cuota_y_uso_de_disco>18.14.3. Revisión de los límites de cuota y uso de disco<a class=anchor href=#_revisión_de_los_límites_de_cuota_y_uso_de_disco></a></h4><div class=paragraph><p>Puede usar <a href="https://man.freebsd.org/cgi/man.cgi?query=quota&amp;sektion=1&amp;format=html">quota(1)</a> o <a href="https://man.freebsd.org/cgi/man.cgi?query=repquota&amp;sektion=8&amp;format=html">repquota(8)</a> para revisar los límites de cuota y uso del disco. El comando <a href="https://man.freebsd.org/cgi/man.cgi?query=quota&amp;sektion=1&amp;format=html">quota(1)</a> le permitirá revisar cuotas individuales de usuario o grupo y uso del disco. Un usuario puede sólamente examinar su propia cuota y la cuota de un grupo al que pertenezca. Sólamente el superusuario puede ver las cuotas de todos los usuarios y grupos. <a href="https://man.freebsd.org/cgi/man.cgi?query=repquota&amp;sektion=8&amp;format=html">repquota(8)</a> permite obtener un resumen de todas las cuotas y uso del disco de todos los sistemas de ficheros con cuotas habilitadas.</p></div><div class=paragraph><p>En el siguiente ejemplo vemos la salida de <code>quota -v</code> para un usuario que tiene límites de cuota en dos sistemas de ficheros.</p></div><div class="literalblock programlisting"><div class=content><pre>Disk quotas for user test (uid 1002):
     Filesystem  usage    quota   limit   grace   files   quota   limit   grace
           /usr      65*     50      75   5days       7      50      60
       /usr/var       0      50      75               0      50      60</pre></div></div><div class=paragraph><p>En el sistema de ficheros <span class=filename>/usr</span> del ejemplo este usuario está actualmente 15 kbytes sobre su límite suave de 50 kbytes y le quedan 5 días de su periodo de gracia. Observe el asterisco, <code>*</code> que indica que el usuario está actualmente por encima de su límite de cuota.</p></div><div class=paragraph><p>Normalmente los sistemas de ficheros en los que el usuario no esté utilizando espacio en disco no se mostrarán en la salida del comando <a href="https://man.freebsd.org/cgi/man.cgi?query=quota&amp;sektion=1&amp;format=html">quota(1)</a>, incluso si tiene un límite de cuota asignado para esos sistemas de fichero. La opción <code>-v</code> desplegará esos sistemas de ficheros, en nuestro ejemplo el sistema de ficheros <span class=filename>/usr/var</span>.</p></div></div><div class=sect3><h4 id=_cuotas_en_nfs>18.14.4. Cuotas en NFS<a class=anchor href=#_cuotas_en_nfs></a></h4><div class=paragraph><p>Las cuotas son impuestas por el subsistema de cuotas en el servidor NFS. El dæmon <a href="https://man.freebsd.org/cgi/man.cgi?query=rpc.rquotad&amp;sektion=8&amp;format=html">rpc.rquotad(8)</a> facilita la información a <a href="https://man.freebsd.org/cgi/man.cgi?query=quota&amp;sektion=1&amp;format=html">quota(1)</a> en los clientes NFS, permitiéndoles a los usuarios de esas máquinas ver sus estadísticas de cuota.</p></div><div class=paragraph><p>Habilite <code>rpc.rquotad</code> en <span class=filename>/etc/inetd.conf</span> del siguiente modo:</p></div><div class="literalblock programlisting"><div class=content><pre>rquotad/1      dgram rpc/udp wait root /usr/libexec/rpc.rquotad rpc.rquotad</pre></div></div><div class=paragraph><p>Y reinicie <code>inetd</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kill -HUP `cat /var/run/inetd.pid`</span></code></pre></div></div></div></div><div class=sect2><h3 id=disks-encrypting>18.15. Cifrado de particiones de disco<a class=anchor href=#disks-encrypting></a></h3><div class=paragraph><p>FreeBSD ofrece un alto grado de protección contra el acceso no autorizado a los datos. Los Permisos de fichero y MAC (Mandatory Access Control, controles de acceso obligatorio, consulte el <a href=./#mac>Mandatory Access Control</a>) ayudan a evitar que otros tengan acceso no autorizado a los datos mientras el sistema operativo está funcionando y la computadora está encendida. Sin embargo los permisos impuestos por el sistema operativo son irrelevantes si un atacante tiene acceso físico al sistema y puede simplemente mover el disco duro de la computadora a otro sistema para copiar y analizar datos sensibles.</p></div><div class=paragraph><p>Independientemente de cómo un atacante pueda conseguir acceso a un disco duro a a un sistema apagado, el cifrado de disco basado en GEOM (GEOM Based Disk Encryption, gbde) puede proteger los datos de los sistemas de ficheros del sistema incluso contra atacantes muy decididos y con recursos adecuados a su disposición. A diferencia de otros métodos de cifrado más difíciles de usar, que cifran únicamente ficheos individuales, gbde cifra sistemas de ficheros completos de forma transparente. Ni un solo texto en limpio llega a tocar el disco duro.</p></div><div class=sect3><h4 id=_habilitar_gbde_en_el_kernel>18.15.1. Habilitar gbde en el kernel<a class=anchor href=#_habilitar_gbde_en_el_kernel></a></h4><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Conviértase en <code>root</code></p><div class=paragraph><p>La configuración de gbde requiere privilegios de superusuario.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% su -
Password:</code></pre></div></div></li><li><p>Verifique la versión del sistema operativo</p><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=gbde&amp;sektion=4&amp;format=html">gbde(4)</a> requiere FreeBSD 5.0 o posterior.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># uname -r</span>
5.0-RELEASE</code></pre></div></div></li><li><p>Añada soporte de <a href="https://man.freebsd.org/cgi/man.cgi?query=gbde&amp;sektion=4&amp;format=html">gbde(4)</a> al fichero de configuración de su kernel</p><div class=paragraph><p>Añada la siguiente línea al fichero de configuración de su kernel con el editor que prefiera:</p></div><div class=paragraph><p><code>options GEOM_BDE</code></p></div><div class=paragraph><p>Configure, recompile e instale el kernel de FreeBSD. Este proceso se detalla en el <a href=./#kernelconfig>Configuración del kernel de FreeBSD</a>.</p></div><div class=paragraph><p>Reinicie con el nuevo kernel.</p></div></li></ol></div></div></div></div><div class=sect3><h4 id=_preparación_del_disco_duro_cifrado>18.15.2. Preparación del disco duro cifrado<a class=anchor href=#_preparación_del_disco_duro_cifrado></a></h4><div class=paragraph><p>El siguiente ejemplo asume que añade a su sistema un disco duro nuevo que contendrá una sola partición cifrada. Esta partición se montará como <span class=filename>/private</span>. gbde puede usarse también para cifrar <span class=filename>/home</span> y <span class=filename>/var/mail</span>, pero esto requeriría instrucciones más complejas que las que se pretenden dar en esta introducción.</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Añada el nuevo disco</p><div class=paragraph><p>Instale el nuevo disco en el sistema como se explicó en la <a href=#disks-adding>Añadir discos</a>. En nuestro ejemplo hemos añadido una nueva partición de disco como <span class=filename>/dev/ad4s1c</span>. Los dispositivos <span class=filename>/dev/ad0s1*</span> representan particiones FreeBSD estándar que i existían previamente en el sistema.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ls /dev/ad*</span>
/dev/ad0        /dev/ad0s1b     /dev/ad0s1e     /dev/ad4s1
/dev/ad0s1      /dev/ad0s1c     /dev/ad0s1f     /dev/ad4s1c
/dev/ad0s1a     /dev/ad0s1d     /dev/ad4</code></pre></div></div></li><li><p>Crée un directorio para los ficheros "lock" de gbde</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mkdir /etc/gbde</span></code></pre></div></div><div class=paragraph><p>Los ficheros "lock" de gbde contienen información que gbde requiere para acceder a las particiones cifradas. Sin el acceso a los ficheros "lock"gbde no podrá descifrar los datos alojados en la partición cifrada sin una cantidad significativa de trabajo, tarea para la que además no le resultará de ayuda este software. Cada partición cifrada utiliza un fichero "lock" separado.</p></div></li><li><p>Inicialice la partición gbde</p><div class=paragraph><p>Una partición gbde debe inicializarse antes de que pueda utilizarse. Esta inicialización sólo debe hacerse una vez:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gbde init /dev/ad4s1c -i -L /etc/gbde/ad4s1c</span></code></pre></div></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=gbde&amp;sektion=8&amp;format=html">gbde(8)</a> abrirá su editor para que pueda configurar las opciones de configuración que se le presentarán en una plantilla. Para utilizar UFS1 o UFS2, ponga el sector_size a 2048:</p></div><div class="literalblock programlisting"><div class=content><pre>$FreeBSD: src/sbin/gbde/template.txt,v 1.1 2002/10/20 11:16:13 phk Exp $
#
# El tamaño de sector (sector size) es la unidad de datos más
# pequeña que podrá leer o escribir.  Si la elige demasiado
# pequeña reducirá el rendimiento y la cantidad de espacio
# útil.  Si la elige demasiado grande puede hacer que los sistemas
# de ficheros no funcionen.  512 es el tamaño mínimo y
# siempre funciona.  Si va a usar UFS utilice
#
sector_size     =       2048
[...]</pre></div></div><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=gbde&amp;sektion=8&amp;format=html">gbde(8)</a> le pedirá dos veces que escriba la contraseña que debe usarse para asegurar los datos. La contraseña debe ser la misma las dos veces. La capacidad de gbde de proteger sus datos depende íntegramente de la calidad de la contraseña que elija.</p></div><div class=paragraph><p>El fichero <code>gbde init</code> crea un fichero "lock" para su partición gbde, que en nuestro ejemplo está en <span class=filename>/etc/gbde/ad4s1c</span>.</p></div><div class="admonitionblock caution"><table><tbody><tr><td class=icon><i class="fa icon-caution" title=Caution></i></td><td class=content><div class=paragraph><p>Es imprescindible que los ficheros "lock" de gbde <em>deben</em> respaldarse junto con el contenido de cualquier partición cifrada. Aunque la sola acció de borrar un fichero "lock" no puede evitar que un atacante motivado descifre una partición gbde sin el fichero "lock", el propietario legítimo no podrá acceder a los datos en la partición cifrada sin una cantidad notable de trabajo, que es necesario señalar que no entra dentro de las funciones de <a href="https://man.freebsd.org/cgi/man.cgi?query=gbde&amp;sektion=8&amp;format=html">gbde(8)</a> ni de su diseñador.</p></div></td></tr></tbody></table></div></li><li><p>Conecte al kernel la partición cifrada</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gbde attach /dev/ad4s1c -l /etc/gbde/ad4s1c</span></code></pre></div></div><div class=paragraph><p>Se le pedirá la contraseña que elijió al inicializar la partición cifrada. El nuevo dispositivo cifrado aparecerá en <span class=filename>/dev</span> como <span class=filename>/dev/nombre_de_dispositivo.bde</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ls /dev/ad*</span>
/dev/ad0        /dev/ad0s1b     /dev/ad0s1e     /dev/ad4s1
/dev/ad0s1      /dev/ad0s1c     /dev/ad0s1f     /dev/ad4s1c
/dev/ad0s1a     /dev/ad0s1d     /dev/ad4        /dev/ad4s1c.bde</code></pre></div></div></li><li><p>Crée un sistema de ficheros en el dispositivo cifrado</p><div class=paragraph><p>Una vez el dispositivo cifrado está conectado al kernel puede crear un sistema de ficheros en el dispositivo con <a href="https://man.freebsd.org/cgi/man.cgi?query=newfs&amp;sektion=8&amp;format=html">newfs(8)</a>. Dado que es más rápido inicializar un sistema de ficheros del nuevo UFS2 que un sistema de ficheros del tradicional UFS1, le recomendamos encarecidamente usar <a href="https://man.freebsd.org/cgi/man.cgi?query=newfs&amp;sektion=8&amp;format=html">newfs(8)</a> con la opción <code>-O2</code>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>La opción <code>-O2</code> es el valor por defecto en FreeBSD 5.1-RELEASE y siguientes.</p></div></td></tr></tbody></table></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># newfs -U -O2 /dev/ad4s1c.bde</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=newfs&amp;sektion=8&amp;format=html">newfs(8)</a> debe ejecutarse en una partición gbde conectada, que podrá identificar por la extensión <span class=filename>*.bde</span> del nombre del dispositivo.</p></div></td></tr></tbody></table></div></li><li><p>Montar la partición cifrada</p><div class=paragraph><p>Crée un punto de montaje para el sistema cifrado de ficheros.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mkdir /private</span></code></pre></div></div><div class=paragraph><p>Montar el sistema cifrado de ficheros.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount /dev/ad4s1c.bde /private</span></code></pre></div></div></li><li><p>Verificar que el sistema cifrado de ficheros esté disponible</p><div class=paragraph><p>el sistema cifrado de ficheros debería ser visible para <a href="https://man.freebsd.org/cgi/man.cgi?query=df&amp;sektion=1&amp;format=html">df(1)</a> y estar listo para su uso.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>df</span> <span class=nt>-H</span>
Filesystem        Size   Used  Avail Capacity  Mounted on
/dev/ad0s1a      1037M    72M   883M     8    /
/devfs            1.0K   1.0K     0B   100    /dev
/dev/ad0s1f       8.1G    55K   7.5G     0    /home
/dev/ad0s1e      1037M   1.1M   953M     0    /tmp
/dev/ad0s1d       6.1G   1.9G   3.7G    35    /usr
/dev/ad4s1c.bde   150G   4.1K   138G     0    /private</code></pre></div></div></li></ol></div></div></div></div><div class=sect3><h4 id=_montaje_de_sistemas_cifrados_de_ficheros>18.15.3. Montaje de sistemas cifrados de ficheros<a class=anchor href=#_montaje_de_sistemas_cifrados_de_ficheros></a></h4><div class=paragraph><p>Todos los sistemas cifrados de ficheros deben reconectarse al kernel después de cada arranque. Además, antes de poder utilizarlo debe revisarlo por si contuviera errores y montarlo. Todo el proceso debe ser ejecutado por el usuario <code>root</code>.</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Conectar la partición gbde al kernel</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gbde attach /dev/ad4s1c -l /etc/gbde/ad4s1c</span></code></pre></div></div><div class=paragraph><p>Se le pedirá la contraseña que elijió en la inicialización de la partición cifrada gbde.</p></div></li><li><p>Revisión de errores en el sistema de ficheros</p><div class=paragraph><p>Como que los sistemas cifrados de ficheros no pueden aparecer en <span class=filename>/etc/fstab</span> (lo que haría que fueran montados automáticamente), los sistemas de ficheros deben revisarse manualmente mediante <a href="https://man.freebsd.org/cgi/man.cgi?query=fsck&amp;sektion=8&amp;format=html">fsck(8)</a> antes de montarlos.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># fsck -p -t ffs /dev/ad4s1c.bde</span></code></pre></div></div></li><li><p>Montar los sistemas cifrados de ficheros</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount /dev/ad4s1c.bde /private</span></code></pre></div></div><div class=paragraph><p>El sistema cifrado de ficheros está listo para su uso.</p></div></li></ol></div></div></div><div class=sect4><h5 id=_montar_automáticamente_particiones_cifradas>18.15.3.1. Montar automáticamente particiones cifradas<a class=anchor href=#_montar_automáticamente_particiones_cifradas></a></h5><div class=paragraph><p>Es posible usar un "script" para automatizar la conexión, revisión y el montaje de una partición cifrada, pero por razones de seguridad el "script" no debe contener la contraseña de <a href="https://man.freebsd.org/cgi/man.cgi?query=gbde&amp;sektion=8&amp;format=html">gbde(8)</a>. Se recomienda ejecutar esos "scripts" se ejecuten de forma manual proporcionando la contraseña vía consola o <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh&amp;sektion=1&amp;format=html">ssh(1)</a>.</p></div></div></div><div class=sect3><h4 id=_protección_criptográfica_que_usa_gbde>18.15.4. Protección criptográfica que usa gbde<a class=anchor href=#_protección_criptográfica_que_usa_gbde></a></h4><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=gbde&amp;sektion=8&amp;format=html">gbde(8)</a> cifra el XXX sector payload usando AES de 128 bits en modo CBC. Cada sector en el disco se cifra con una clave AES diferente. Para más información sobre el diseño criptográfico de gbde, incluyendo cómo se derivan las claves de sector a partir de la contraseña consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=gbde&amp;sektion=4&amp;format=html">gbde(4)</a>.</p></div></div><div class=sect3><h4 id=_problemas_de_compatibilidad>18.15.5. Problemas de compatibilidad<a class=anchor href=#_problemas_de_compatibilidad></a></h4><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=sysinstall&amp;sektion=8&amp;format=html">sysinstall(8)</a> es incompatible con dispositivos gbde cifrados. Todos los dispositivos <span class=filename>*.bde</span> deben desconectarse del kernel antes de iniciar <a href="https://man.freebsd.org/cgi/man.cgi?query=sysinstall&amp;sektion=8&amp;format=html">sysinstall(8)</a> o se "congelará" durante la prueba inicial de dispositivos. Para desconectar el el dispositivo cifrado de nuestro ejemplo haga lo siguiente:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gbde detach /dev/ad4s1c</span></code></pre></div></div><div class=paragraph><p>Tenga en cuenta también que, como <a href="https://man.freebsd.org/cgi/man.cgi?query=vinum&amp;sektion=4&amp;format=html">vinum(4)</a> no utiliza el subsistema <a href="https://man.freebsd.org/cgi/man.cgi?query=geom&amp;sektion=4&amp;format=html">geom(4)</a>, no es posible usar gbde en volúmenes vinum.</p></div></div></div></div></div><div class=sect1><h2 id=geom>Capítulo 19. GEOM: Marco de trabajo modular de transformación de discos<a class=anchor href=#geom></a></h2><div class=sectionbody><div class=sect2><h3 id=GEOM-synopsis>19.1. Sinopsis<a class=anchor href=#GEOM-synopsis></a></h3><div class=paragraph><p>Este capítulo explica el uso de discos bajo el marco de trabajo GEOM en FreeBSD. Esto incluye las principales utilidades de control de RAID que usan el marco de trabajo para su configuración. Este capítulo no se adentrará en un examen en profundidad de como GEOM maneja o controla la E/S, el subsistema subyacente, o el código. Esta información se proporciona en la página de manual <a href="https://man.freebsd.org/cgi/man.cgi?query=geom&amp;sektion=4&amp;format=html">geom(4)</a> y sus diversas referencias VEA TAMBIÉN. Este capítulo tampoco es una guía definitiva de configuraciones RAID. Sólo se examinan las clasificaciones de RAID que puede usar GEOM.</p></div><div class=paragraph><p>Tras leer este capítulo, sabrá:</p></div><div class=ulist><ul><li><p>Que tipo de soporte para RAID está disponible a través de GEOM.</p></li><li><p>Como utilizar las utilidades base para configurar, mantener, y manipular los diversos niveles de RAID.</p></li><li><p>Como replicar, unir, cifrar, y conectar remotamente dispositivos de disco por medio de GEOM.</p></li><li><p>Como solucionar problemas con los discos adscritos al marco de trabajo GEOM.</p></li></ul></div><div class=paragraph><p>Antes de leer este capítulo, debería:</p></div><div class=ulist><ul><li><p>Entender como trata FreeBSD a los dispositivos de disco (<a href=./#disks>Almacenamiento</a>).</p></li><li><p>Saber como configurar e instalar un nuevo núcleo de FreeBSD (<a href=./#kernelconfig>Configuración del kernel de FreeBSD</a>).</p></li></ul></div></div><div class=sect2><h3 id=GEOM-intro>19.2. Introducción a GEOM<a class=anchor href=#GEOM-intro></a></h3><div class=paragraph><p>GEOM permite el acceso y control de clases -sectores de arranque maestros (MBR), etiquetas BSD, etc- por medio del uso de proveedores, o de los ficheros especiales de <span class=filename>/dev</span>. Capaz de trabajar con varias configuraciones de RAID por software, GEOM proporcionará transparentemente acceso al sistema operativo y las utilidades del mismo.</p></div></div><div class=sect2><h3 id=GEOM-striping>19.3. RAID0 - Distribución por bandas<a class=anchor href=#GEOM-striping></a></h3><div class=paragraph><p>La distribución por bandas (striping) es un método que se usa para combinar varias unidades de disco en un único volumen. En muchos casos, esto se hace usando controladoras por hardware. El subsistema de discos GEOM proporciona soporte por software para RAID0, también conocido como discos configurados en bandas.</p></div><div class=paragraph><p>En un sistema RAID0, los datos se dividen en bloques que son escritos por todas las unidades de la agrupación. En lugar de tener que esperar a que el sistema escriba 256 kB en un disco, un sistema RAID0 puede escribir simultáneamente 64 kB en cada uno de los cuatro discos, ofreciendo un superior rendimiento de E/S. Este rendimiento se puede mejorar aún más usando varias controladoras de disco.</p></div><div class=paragraph><p>Cada uno de los discos de una banda RAID0 debe ser del mismo tamaño, pues las peticiones de E/S están intercaladas para leer o escribir en varios discos en paralelo.</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/geom/striping.png alt="Ilustració de la distribución por bandas de los discos"></div></div><div class="exampleblock procedure"><div class=content><div class=paragraph><p><strong>Procedure: Creación de una banda de discos ATA sin formatear</strong></p></div><div class="olist arabic"><ol class=arabic><li><p>Cargue el módulo <span class=filename>geom_stripe</span>:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload geom_stripe.ko</span></code></pre></div></div></li><li><p>Asegúrese de que existe un punto de montaje adecuado. Si este volumen se convertirá en una partición raíz, utilice temporalmente otro punto de montaje, como <span class=filename>/mnt</span>.</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mkdir /mnt</span></code></pre></div></div></li><li><p>Determine los nombres de dispositivo de los discos que serán configurados en bandas, y cree el nuevo dispositivo de banda. Por ejemplo, podría utilizar la siguiente orden para configurar en bandas dos discos ATA sin usar ni particionar: <span class=filename>/dev/ad2</span> y <span class=filename>/dev/ad3</span>.</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gstripe label -v st0 /dev/ad2 /dev/ad3</span></code></pre></div></div></li><li><p>Si se va a usar este volumen como dispositivo raíz para arrancar el sistema, debe ejecutar la siguiente orden antes de crear el sistema de ficheros:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># fdisk -vBI /dev/stripe/st0</span></code></pre></div></div></li><li><p>Se debe crear una tabla de particiones en el nuevo volumen con la siguiente orden:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># bsdlabel -wB /dev/stripe/st0</span></code></pre></div></div></li><li><p>Aademás del dispositivo <span class=filename>st0</span>, este proceso debería haber creado otros dos dispositivos en el directorio <span class=filename>/dev/stripe</span>, incluyendo <span class=filename>st0a</span> y <span class=filename>st0c</span>. Ahora se debe crear un sistema de ficheros en el dispositivo <span class=filename>st0a</span> usando la siguiente orden <code>newfs</code>:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># newfs -U /dev/stripe/st0a</span></code></pre></div></div><div class=paragraph><p>Por la pantalla se deslizarán muchos números, y al cabo de unos pocos segundos, el proceso habrá finalizado. El volumen ha sido creado y está preparado para ser montado:</p></div></li></ol></div></div></div><div class=paragraph><p>Se puede usar la siguiente orden para montar manualmente una banda de discos recién creada:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount /dev/stripe/st0a /mnt</span></code></pre></div></div><div class=paragraph><p>Para montar automáticamente este sistema de ficheros distribuido por bandas durante el proceso de arranque, ponga la información del volumen en el fichero <span class=filename>/etc/fstab</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># echo &#34;/dev/stripe/st0a /mnt ufs rw 2 2&#34; \</span>
    <span class=o>&gt;&gt;</span> /etc/fstab</code></pre></div></div><div class=paragraph><p>También se debe cargar automáticamente durante la inicialización del sistema el módulo geom, añadiendo una línea a <span class=filename>/boot/loader.conf</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># echo &#39;geom_stripe_load=&#34;YES&#34;&#39; &gt;&gt; /boot/loader.conf</span></code></pre></div></div></div><div class=sect2><h3 id=GEOM-mirror>19.4. RAID1 - Replicación<a class=anchor href=#GEOM-mirror></a></h3><div class=paragraph><p>La replicación es una tecnologín que usan muchas empresas y usuarios para hacer copias de respaldo de sus datos sin interrupciones. Cuando hay una réplica, simplemente significa que el discoB replica al discoA. O, quizá el discoC+D replica al discoA+B. Al margen de la configuración de los discos, lo importante es que la información de un disco o partición está siendo replicada. Más adelante se podría restaurar esa información más fácilmente, hacerse una copia de respaldo sin provocar intrrupciones de servicio o acceso, e incluso almacenarla físicamente en una caja fuerte para datos.</p></div><div class=paragraph><p>Para empezar, asegúrese de que el sistema tiene dos unidades de disco del mismo tamaño, eb este ejercicio se supone que son discos SCSI de acceso directo (<a href="https://man.freebsd.org/cgi/man.cgi?query=da&amp;sektion=4&amp;format=html">da(4)</a>).</p></div><div class=paragraph><p>Comience por instalar FreeBSD en el primer disco con sólo dos particiones. Una debería ser una partición de intercambio, de dos veces el tamaño de la RAM, y todo el espacio restante se dedicará al sistema de ficheros raíz (<span class=filename>/</span>). Es posible tener particiones aparte para otros puntos de montajes; sin embargo, esto multiplicará por diez el nivel de dificultad, debido a la alteración manual de las opciones de <a href="https://man.freebsd.org/cgi/man.cgi?query=bsdlabel&amp;sektion=8&amp;format=html">bsdlabel(8)</a> y <a href="https://man.freebsd.org/cgi/man.cgi?query=fdisk&amp;sektion=8&amp;format=html">fdisk(8)</a>.</p></div><div class=paragraph><p>Reinicie y espere a que el sistema se inicie por completo. Una vez haya finalizado este proceso, ingrese como usuario <code>root</code>.</p></div><div class=paragraph><p>Cree el dispositivo <span class=filename>/dev/mirror/gm</span> y enlácelo a <span class=filename>/dev/da1</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gmirror label -vnb round-robin gm0 /dev/da1</span></code></pre></div></div><div class=paragraph><p>El sistema debería responder con:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Metadata value stored on /dev/da1.
Done.</code></pre></div></div><div class=paragraph><p>Inicialice GEOM, esto cargará el módulo del núcleo <span class=filename>/boot/kernel/geom_mirror.ko</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gmirror load</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Esta orden debería haber creado en el directorio <span class=filename>/dev/mirror</span> los nodos de dispositivo <span class=filename>gm0</span>, <span class=filename>gm0s1</span>, <span class=filename>gm0s1a</span>, y <span class=filename>gm0s1c</span>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Instale una etiqueta genérica <code>fdisk</code> y el código de arranque en el recién creado dispositivo <span class=filename>gm0</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># fdisk -vBI /dev/mirror/gm0</span></code></pre></div></div><div class=paragraph><p>Ahora instale la información <code>bsdlabel</code> genérica:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># bsdlabel -wB /dev/mirror/gm0s1</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Si hay varias slices (rodajas) y particiones, necesitará modificar las opciones de las dos órdenes anteriores. Deben coincidir con la slice y tamaño de partición del otro disco.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Utilice la utilidad <a href="https://man.freebsd.org/cgi/man.cgi?query=newfs&amp;sektion=8&amp;format=html">newfs(8)</a> para crear un sistema de ficheros predefinido en nodo de dispositivo <span class=filename>gm0s1a</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># newfs -U /dev/mirror/gm0s1a</span></code></pre></div></div><div class=paragraph><p>Esto debería haber hecho que el sistema mostrara alguna información y un puñado de números. Esto es bueno. Examine la pantalla por si hay algún mensaje de error y monte el dispositivo en el punto de montaje <span class=filename>/mnt</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount /dev/mirror/gm0s1a /mnt</span></code></pre></div></div><div class=paragraph><p>Ahora mueva todos los datos del disco de arranque a este nuevo sistema de ficheros. Este ejemplo usa las órdenes <a href="https://man.freebsd.org/cgi/man.cgi?query=dump&amp;sektion=8&amp;format=html">dump(8)</a> y <a href="https://man.freebsd.org/cgi/man.cgi?query=restore&amp;sektion=8&amp;format=html">restore(8)</a>; aunque, <a href="https://man.freebsd.org/cgi/man.cgi?query=dd&amp;sektion=1&amp;format=html">dd(1)</a> también debería funcionar en este escenario. Evitamos utilizar <a href="https://man.freebsd.org/cgi/man.cgi?query=tar&amp;sektion=1&amp;format=html">tar(1)</a> porque no copiará el código de arranque. De ese modo, el fallo estaría garantizado.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dump -L -0 -f- / |(cd /mnt  restore -r -v -f-)</span></code></pre></div></div><div class=paragraph><p>Se debe hacer esto para cada sistema de ficheros. Simplemente ponga el sistema de ficheros adecuado en la ubicación correcta al ejecutar la orden mencionada.</p></div><div class=paragraph><p>Ahora edite el fichero replicado <span class=filename>/mnt/etc/fstab</span> y elimine o comente el fichero swap . Cambie la información del otro sistema de ficheros para que utilice el nuevo disco. Vea el siguiente ejemplo:</p></div><div class="literalblock programlisting"><div class=content><pre># Device                Mountpoint      FStype  Options         Dump    Pass#
#/dev/da0s2b             none            swap    sw              0       0
/dev/mirror/gm0s1a       /               ufs     rw              1       1</pre></div></div><div class=paragraph><p>Ahora cree un fichero <span class=filename>boot.conf</span> tanto en la partición actual como en la nueva partición raíz. Este fichero "ayudará" al BIOS del sistema a arrancar la unidad correcta:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># echo &#34;1:da(1,a)/boot/loader&#34;  /boot.config</span></code></pre></div></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># echo &#34;1:da(1,a)/boot/loader&#34;  /mnt/boot.config</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Lo hemos colcoado en ambas particiones raíz para asegurar un arranque correcto. Si por alguna razón el sistema no pudiera leer en la nueva partición raíz, está disponible un arranque a prueba de fallos.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Ahora agregue la siguiente línea al nuevo <span class=filename>/boot/loader.conf</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># echo &#39;geom_mirror_load=&#34;YES&#34;&#39;  /mnt/boot/loader.conf</span></code></pre></div></div><div class=paragraph><p>Esto le dice a la utilidad <a href="https://man.freebsd.org/cgi/man.cgi?query=loader&amp;sektion=8&amp;format=html">loader(8)</a> que cargue el <span class=filename>geom_mirror.ko</span> durante la inicialización del sistema.</p></div><div class=paragraph><p>Reinicie el sistema:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># shutdown -r now</span></code></pre></div></div><div class=paragraph><p>Si todo ha ido bien, el sistema debería haber arrancado desde el dispositivo <span class=filename>gm0s1a</span>, y un prompt <code>login</code> debería estar a la espera. Si algo fue mal, consulte la sección posterior de resolución de problemas. Ahora agregue el disco <span class=filename>da0</span> al dispositivo <span class=filename>gm0</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># gmirror configure -a gm0</span>
<span class=c># gmirror insert gm0 /dev/da0</span></code></pre></div></div><div class=paragraph><p>La opción <code>-a</code> le dice a <a href="https://man.freebsd.org/cgi/man.cgi?query=gmirror&amp;sektion=8&amp;format=html">gmirror(8)</a> que use sincronización automática; por ejemplo, que replique las escrituras en disco automáticamente. La página de manual explica como reconstruir y reemplazar discos, aunque utiliza <span class=filename>data</span> en vez de <span class=filename>gm0</span>.</p></div><div class=sect3><h4 id=_resolución_de_problemas>19.4.1. Resolución de problemas<a class=anchor href=#_resolución_de_problemas></a></h4><div class=sect4><h5 id=_el_sistema_se_niega_a_arrancar>19.4.1.1. El sistema se niega a arrancar<a class=anchor href=#_el_sistema_se_niega_a_arrancar></a></h5><div class=paragraph><p>Si el sistema arranca hasta un prompt similar a:</p></div><div class="literalblock programlisting"><div class=content><pre>ffs_mountroot: can&#39;t find rootvp
Root mount failed: 6
mountroot</pre></div></div><div class=paragraph><p>Reinicie la máquina utilizando el botón de encendido o el de reset. En el menú de arranque, seleccione la opción seis (6). Esto llevará al sistema a un prompt de <a href="https://man.freebsd.org/cgi/man.cgi?query=loader&amp;sektion=8&amp;format=html">loader(8)</a>. Cargue el módulo del núcleo manualmente:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>OK? load geom_mirror.ko
OK? boot</code></pre></div></div><div class=paragraph><p>Si esto funciona, es que por alguna razón el módulo no se cargaba correctamente. Ponga:</p></div><div class="literalblock programlisting"><div class=content><pre>options	GEOM_MIRROR</pre></div></div><div class=paragraph><p>en el fichero de configuración del núcleo, recompile y reinstale. Esto debería solucionar el problema.</p></div></div></div></div></div></div><div class=sect1><h2 id=vinum-vinum>Capítulo 20. El Gestor de Volúmenes Vinum<a class=anchor href=#vinum-vinum></a></h2><div class=sectionbody><div class=sect2><h3 id=vinum-synopsis>20.1. Sinopsis<a class=anchor href=#vinum-synopsis></a></h3></div><div class=sect2><h3 id=vinum-intro>20.2. Los Discos son Demasiado Pequeños<a class=anchor href=#vinum-intro></a></h3></div><div class=sect2><h3 id=vinum-access-bottlenecks>20.3. Cuellos de Botella en el Acceso<a class=anchor href=#vinum-access-bottlenecks></a></h3><div id=vinum-concat class=imageblock><div class=content><img src=../../../../images/books/handbook/vinum/vinum-concat.png alt="vinum concat"></div><div class=title>Figura 56. Organización Concatenada</div></div><div id=vinum-striped class=imageblock><div class=content><img src=../../../../images/books/handbook/vinum/vinum-striped.png alt="vinum striped"></div><div class=title>Figura 57. Organización con "Striping"</div></div></div><div class=sect2><h3 id=vinum-data-integrity>20.4. Integridad de Datos<a class=anchor href=#vinum-data-integrity></a></h3><div id=vinum-raid5-org class=imageblock><div class=content><img src=../../../../images/books/handbook/vinum/vinum-raid5-org.png alt="vinum raid5 org"></div><div class=title>Figura 58. Organización en RAID-5</div></div></div><div class=sect2><h3 id=vinum-objects>20.5. Objetos Vinum<a class=anchor href=#vinum-objects></a></h3><div class=sect3><h4 id=_consideraciones_sobre_el_tamaño_de_los_volúmenes>20.5.1. Consideraciones sobre el Tamaño de los Volúmenes<a class=anchor href=#_consideraciones_sobre_el_tamaño_de_los_volúmenes></a></h4></div><div class=sect3><h4 id=_almacenamiento_redundante_de_datos>20.5.2. Almacenamiento Redundante de Datos<a class=anchor href=#_almacenamiento_redundante_de_datos></a></h4></div><div class=sect3><h4 id=_cuestiones_relacionadas_con_el_rendimiento>20.5.3. Cuestiones Relacionadas con el Rendimiento<a class=anchor href=#_cuestiones_relacionadas_con_el_rendimiento></a></h4></div><div class=sect3><h4 id=_which_plex_organization>20.5.4. Which Plex Organization?<a class=anchor href=#_which_plex_organization></a></h4></div><div class=sect3><h4 id=_vinum_plex_organizations>20.5.5. Vinum Plex Organizations<a class=anchor href=#_vinum_plex_organizations></a></h4></div></div><div class=sect2><h3 id=vinum-examples>20.6. Ejemplos<a class=anchor href=#vinum-examples></a></h3><div class=sect3><h4 id=_el_fichero_de_configuración>20.6.1. El Fichero de Configuración<a class=anchor href=#_el_fichero_de_configuración></a></h4><div id=vinum-simple-vol class=imageblock><div class=content><img src=../../../../images/books/handbook/vinum/vinum-simple-vol.png alt="vinum simple vol"></div><div class=title>Figura 59. Un Volumen Vinum Sencillo</div></div></div><div class=sect3><h4 id=_increased_resilience_mirroring>20.6.2. Increased Resilience: Mirroring<a class=anchor href=#_increased_resilience_mirroring></a></h4><div id=vinum-mirrored-vol class=imageblock><div class=content><img src=../../../../images/books/handbook/vinum/vinum-mirrored-vol.png alt="vinum mirrored vol"></div><div class=title>Figura 60. Un Volumen Vinum Replicado</div></div></div><div class=sect3><h4 id=_optimización_del_rendimiento>20.6.3. Optimización del Rendimiento<a class=anchor href=#_optimización_del_rendimiento></a></h4><div id=vinum-striped-vol class=imageblock><div class=content><img src=../../../../images/books/handbook/vinum/vinum-striped-vol.png alt="vinum striped vol"></div><div class=title>Figura 61. Un Volumen Vinum en "Striping"</div></div></div><div class=sect3><h4 id=_resilience_and_performance>20.6.4. Resilience and Performance<a class=anchor href=#_resilience_and_performance></a></h4><div id=vinum-raid10-vol class=imageblock><div class=content><img src=../../../../images/books/handbook/vinum/vinum-raid10-vol.png alt="vinum raid10 vol"></div><div class=title>Figura 62. Un Volumen Vinum Replicado y en "Striping"</div></div></div></div><div class=sect2><h3 id=vinum-object-naming>20.7. Esquema de Nombres de los Objetos<a class=anchor href=#vinum-object-naming></a></h3><div class=ulist><ul><li><p>The control devices <span class=filename>/dev/vinum/control</span> and <span class=filename>/dev/vinum/controld</span>, which are used by <a href="https://man.freebsd.org/cgi/man.cgi?query=vinum&amp;sektion=8&amp;format=html">vinum(8)</a> and the Vinum daemon respectively.</p></li></ul></div><div class=sect3><h4 id=_creación_de_un_sistema_de_ficheros>20.7.1. Creación de un Sistema de Ficheros<a class=anchor href=#_creación_de_un_sistema_de_ficheros></a></h4></div></div><div class=sect2><h3 id=vinum-config>20.8. Configuración de Vinum<a class=anchor href=#vinum-config></a></h3><div class=sect3><h4 id=_arranque>20.8.1. Arranque<a class=anchor href=#_arranque></a></h4><div class=sect4><h5 id=vinum-rc-startup>20.8.1.1. Arranque Automático<a class=anchor href=#vinum-rc-startup></a></h5></div></div></div><div class=sect2><h3 id=vinum-root>20.9. Uso de Vinum en el Sistema de Ficheros Raíz<a class=anchor href=#vinum-root></a></h3><div class=sect3><h4 id=_inicio_de_vinum_en_el_arranque_para_que_incluya_el_sistema_de_ficheros_raíz>20.9.1. Inicio de Vinum en el Arranque para que Incluya el Sistema de Ficheros Raíz<a class=anchor href=#_inicio_de_vinum_en_el_arranque_para_que_incluya_el_sistema_de_ficheros_raíz></a></h4></div><div class=sect3><h4 id=_configuración_de_un_volumen_raíz_en_vinum_accesible_para_la_secuencia_de_arranque>20.9.2. Configuración de un Volumen Raíz en Vinum Accesible Para la Secuencia de Arranque<a class=anchor href=#_configuración_de_un_volumen_raíz_en_vinum_accesible_para_la_secuencia_de_arranque></a></h4></div><div class=sect3><h4 id=_ejemplo_de_raíz_basado_en_vinum>20.9.3. Ejemplo de Raíz basado en Vinum<a class=anchor href=#_ejemplo_de_raíz_basado_en_vinum></a></h4></div><div class=sect3><h4 id=_solución_de_problemas_2>20.9.4. Solución de Problemas<a class=anchor href=#_solución_de_problemas_2></a></h4><div class=sect4><h5 id=_la_secuencia_de_arranque_carga_pero_el_sistema_no_arranca>20.9.4.1. La Secuencia de Arranque Carga Pero el Sistema no Arranca<a class=anchor href=#_la_secuencia_de_arranque_carga_pero_el_sistema_no_arranca></a></h5></div><div class=sect4><h5 id=_sólo_se_carga_la_secuencia_primaria_de_arranca>20.9.4.2. Sólo se Carga la Secuencia Primaria de Arranca<a class=anchor href=#_sólo_se_carga_la_secuencia_primaria_de_arranca></a></h5></div><div class=sect4><h5 id=vinum-root-panic>20.9.4.3. No Hay Arranque, la Secuencia de Arranque da un Pánico<a class=anchor href=#vinum-root-panic></a></h5></div></div><div class=sect3><h4 id=vinum-root-4x>20.9.5. Particularidades de Vinum en FreeBSD 4.x<a class=anchor href=#vinum-root-4x></a></h4></div></div></div></div><div class=sect1><h2 id=virtualization>Capítulo 21. Virtualización<a class=anchor href=#virtualization></a></h2><div class=sectionbody><div class=sect2><h3 id=virtualization-synopsis>21.1. *<a class=anchor href=#virtualization-synopsis></a></h3><div class=paragraph><p>Pendiente de traducción.</p></div></div></div></div><div class=sect1><h2 id=l10n>Capítulo 22. Localización - Uso y configuración de I18N/L10N<a class=anchor href=#l10n></a></h2><div class=sectionbody><div class=sect2><h3 id=l10n-synopsis>22.1. Sinopsis<a class=anchor href=#l10n-synopsis></a></h3><div class=paragraph><p>FreeBSD es un proyecto muy distribuido, que cuenta con usuarios y contribuidores por todo el mundo. Este capítulo examina las funcionalidades de internacionalización y localización de FreeBSD que permiten llevar a cabo su trabajo a los usuarios no angloparlantes. Hay muchos aspectos en la implementación de la i18n, tanto en los niveles de sistema como de aplicación, así que cuando sea conveniente dirigiremos al lector a fuentes de documentación más específicas.</p></div><div class=paragraph><p>Tras leer este capítulo, sabrá:</p></div><div class=ulist><ul><li><p>Cómo se codifican los distintos idiomas y "locales" en los sistemas operativos modernos.</p></li><li><p>Cómo configurar las "locales " para su intérprete de órdenes.</p></li><li><p>Cómo configurar la consola para idiomas distintos al inglés.</p></li><li><p>Cómo emplear efizcamente el sistema de ventanas X en distintos idiomas.</p></li><li><p>Dónde encontrar más información sobre como escribir aplicaciones que sigan la i18n.</p></li></ul></div><div class=paragraph><p>Antes de leer este capítulo, debería:</p></div><div class=ulist><ul><li><p>Saber como instalar aplicaciones adicionales de terceras partes (<a href=./#ports>Instalación de aplicaciones: «packages» y ports</a>).</p></li></ul></div></div><div class=sect2><h3 id=l10n-basics>22.2. Lo básico<a class=anchor href=#l10n-basics></a></h3><div class=sect3><h4 id=_qué_es_i18nl10n>22.2.1. ?Qué es I18N/L10N?<a class=anchor href=#_qué_es_i18nl10n></a></h4><div class=paragraph><p>Los desarrolladores acortaron la palabra internacionalización al término I18N, contando el número de letras entre la primera y la última letra. L10N sigue el mismo esquema, y procede de "localización". Combinados, los métodos, protocolos y aplicaciones de I18N/L10N permiten a los usuarios usar el idioma de su elección.</p></div><div class=paragraph><p>Las aplicaciones I18N se programan usando herramientas de I18N de bibliotecas. Éstas permiten a los desarrolladores escribir un fichero sencillo y traducir los menús y textos contenidos a cada idioma. Animamos fervientemente a los programadores a que sigan esta convención.</p></div></div><div class=sect3><h4 id=_por_qué_debería_usar_i18nl10n>22.2.2. ?Por qué debería usar I18N/L10N?<a class=anchor href=#_por_qué_debería_usar_i18nl10n></a></h4><div class=paragraph><p>I18N/L10N se usa siempre que quiera ver, introducir o procesar datos en idiomas distintos al inglés.</p></div></div><div class=sect3><h4 id=_qué_idiomas_están_soportados_en_el_proyecto_de_i18n>22.2.3. ?Qué idiomas están soportados en el proyecto de I18N?<a class=anchor href=#_qué_idiomas_están_soportados_en_el_proyecto_de_i18n></a></h4><div class=paragraph><p>La I18N y L10N no son específicos de FreeBSD. En la actualidad, uno puede elegir entre la mayoría de los principales idiomas del mundo, incluyendo pero sin limitarse a ellos: chino, alemán, japonés, coreano, francés, ruso, vietnamita y otros.</p></div></div></div><div class=sect2><h3 id=using-localization>22.3. Uso de la localización<a class=anchor href=#using-localization></a></h3><div class=paragraph><p>En todo su esplendor, la I18N no es específica de FreeBSD, y es una convención. Le animamos a que ayude a FreeBSD siguiendo esta convención.</p></div><div class=paragraph><p>Las opciones de localización se basan en tres términos principales: código de idioma, código de país y codificación. Los nombres de las "locales" se construyen a partir de estas tres partes como sigue:</p></div><div class="literalblock programlisting"><div class=content><pre>CódigoDelIdioma
      _CódigoDelPaís.
      Codificación</pre></div></div><div class=sect3><h4 id=_códigos_de_idioma_y_país>22.3.1. Códigos de idioma y país<a class=anchor href=#_códigos_de_idioma_y_país></a></h4><div class=paragraph><p>Para localizar un sistema FreeBSD a un idioma concreto (o cualquier otro sistema de tipo UNIX® que soporte I18N), los usuarios necesitar averiguar los códigos del país e idioma concreto (los códigos de país le dicen a las aplicaciones que variedad del idioma dado deben usar). Además, los navegadores web, servidores SMTP/POP, servidores web, etc toman decisiones basándose en ellos. Los siguientes son ejemplos de códigos de idioma/país:</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Código de idioma/país</th><th class="tableblock halign-left valign-top">Descripción</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>en_US</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Inglés - Estados Unidos de América</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>ru_RU</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Ruso de Rusia</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>zh_TW</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Chino tradicional de Taiwán</p></td></tr></tbody></table></div><div class=sect3><h4 id=_codificaciones>22.3.2. Codificaciones<a class=anchor href=#_codificaciones></a></h4><div class=paragraph><p>Algunos idiomas usan codificaciones distintas al ASCII que son de 8 bits, caracteres anchos o multibyte; consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=multibyte&amp;sektion=3&amp;format=html">multibyte(3)</a> para conocer más detalles. Algunas aplicaciones más antiguas no los reconocen y los confunden con caracteres de control. Las aplicaciones modernas normalmente reconocen los caracteres de 8 bits. Dependiendo de la implementación, los usuarios pueden necesitar compilar una aplicación con soporte para caracteres anchos o multibyte, o configurarlo correctamente. Para poder introducir y procesar caracteres anchos o multibyte, la Colección de "Ports" de FreeBSD proporciona diferentes programas a cada idioma. Diríjase a la documentación de I18N del " port" de FreeBSD correspondiente.</p></div><div class=paragraph><p>Específicamente, los usuarios necesitan mirar la documentación de la aplicación para decidir como configurarla correctamente o pasar valores correctos al configure/Makefile/compilador.</p></div><div class=paragraph><p>Algunas cosas a tener presentes son:</p></div><div class=ulist><ul><li><p>Los juegos de caracteres de tipo char de C específicos para el idioma (consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=multibyte&amp;sektion=3&amp;format=html">multibyte(3)</a>), v.g. ISO-8859-1, ISO-8859-15, KOI8-R, CP437.</p></li><li><p>Las codificaciones anchas o multibyte, v.g. EUC, Big5 .</p></li></ul></div><div class=paragraph><p>Puede comprobar la lista activa de juegos de caracteres en el <a href=http://www.iana.org/assignments/character-sets>Registro IANA</a>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Las versiones 4.5 y posteriores de FreeBSD usan en su lugar codificaciones de la "locale" compatibles con X11.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=_aplicaciones_i18n>22.3.3. Aplicaciones I18N<a class=anchor href=#_aplicaciones_i18n></a></h4><div class=paragraph><p>En el sistema de paquetes y ports de FreeBSD, las aplicaciones I18N se han denominado con <code>I18N</code> en su nombre para una fácil identificación. Sin embargo, no siempre soportan el idioma necesitado.</p></div></div><div class=sect3><h4 id=setting-locale>22.3.4. Configuración de las "locales"<a class=anchor href=#setting-locale></a></h4><div class=paragraph><p>Normalmente basta con exportar el valor del nombre de la "locale" como <code>LANG</code> en el intérprete de órdenes de la sesión. Esto se podría hacer en el fichero <span class=filename>~/.login_conf</span> del usuario o en el fichero de inicio del intérprete de órdenes del usuario (<span class=filename>~/.profile</span>, <span class=filename>~/.bashrc</span>, <span class=filename>~/.cshrc</span>). No es necesario configurar las otras variables de localización como <code>LC_CTYPE</code> o <code>LC_CTIME</code>. Diríjase a la documentación de FreeBSD específica de su idioma para más información.</p></div><div class=paragraph><p>Debería configurar las siguientes dos variables de entorno en sus ficheros de configuración:</p></div><div class=ulist><ul><li><p><code>LANG</code> para las funciones de la familia <a href="https://man.freebsd.org/cgi/man.cgi?query=setlocale&amp;sektion=3&amp;format=html">setlocale(3)</a> de POSIX®</p></li><li><p><code>MM_CHARSET</code> para el juego de caracteres MIME de las aplicaciones</p></li></ul></div><div class=paragraph><p>Esto comprende la configuración del intérprete de órdenes del usuario, la configuración específica de la aplicación y la configuración de X11.</p></div><div class=sect4><h5 id=_métodos_de_configuración_de_las_locales>22.3.4.1. Métodos de configuración de las " locales"<a class=anchor href=#_métodos_de_configuración_de_las_locales></a></h5><div class=paragraph><p>Hay dos métodos para configurar las " locales", que se describen aquí abajo. El primero (que es el recomendado) es asignar las variables de entorno en una <a href=#login-class>clase de sesión</a>, y el segundo es añadir las asignaciones de las variables de entorno al <a href=#startup-file>fichero de inicio</a> del intérprete de órdenes del sistema.</p></div><div class=sect5><h6 id=login-class>22.3.4.1.1. Método de las clases de sesión<a class=anchor href=#login-class></a></h6><div class=paragraph><p>Este método permite asignar las variables de entorno necesarias para el nombre de las "locales " y el juego de caracteres MIME de una sola vez para todos los posibles intérpretes de órdenes, en vez de añadir asignaciones específicas en los ficheros de inicio de cada uno de los intérpretes de órdenes. La <a href=#usr-setup>configuración a nivel de usuario</a> la puede realizar el propio usuario, mientras que la <a href=#adm-setup>configuración a nivel de administrador</a> precisa de permisos de superusuario.</p></div><div class=sect6><h7 id=usr-setup>22.3.4.1.1.1. Configuración a nivel de usuario<a class=anchor href=#usr-setup></a></h7><div class=paragraph><p>Esto es un ejemplo minimalista de un fichero <span class=filename>.login_conf</span> de la carpeta de inicio de un usuario, que contiene las dos variables configuradas para la codificación Latin-1:</p></div><div class="literalblock programlisting"><div class=content><pre>me:\
	:charset=ISO-8859-1:\
	:lang=de_DE.ISO8859-1:</pre></div></div><div class=paragraph><p>Esto es un ejemplo de un <span class=filename>.login_conf</span> que configura las variables para el chino tradicional en la codificación BIG-5. Observe que se configuran muchas más variables porque algunos programas no respetan correctamente las variables de las "locales" para el chino, el japonés y el coreano.</p></div><div class="literalblock programlisting"><div class=content><pre>#Users who do not wish to use monetary units or time formats
#of Taiwan can manually change each variable
me:\
	:lang=zh_TW.Big5:\
	:lc_all=zh_TW.Big:\
	:lc_collate=zh_TW.Big5:\
	:lc_ctype=zh_TW.Big5:\
	:lc_messages=zh_TW.Big5:\
	:lc_monetary=zh_TW.Big5:\
	:lc_numeric=zh_TW.Big5:\
	:lc_time=zh_TW.Big5:\
	:charset=big5:\
	:xmodifiers=&#34;@im=xcin&#34;: #Setting the XIM Input Server</pre></div></div><div class=paragraph><p>Consulte la <a href=#adm-setup>configuración a nivel de administrador</a> y <a href="https://man.freebsd.org/cgi/man.cgi?query=login.conf&amp;sektion=5&amp;format=html">login.conf(5)</a> para conocer más detalles.</p></div></div></div><div class=sect5><h6 id=adm-setup>22.3.4.1.2. Configuración a nivel de administrador<a class=anchor href=#adm-setup></a></h6><div class=paragraph><p>Compruebe que la clase de sesión en <span class=filename>/etc/login.conf</span> establece el idioma adecuado. Asegúrese de que estas opciones aparecen en <span class=filename>/etc/login.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>nombre_del_idioma:título_cuentas:\
	:charset=juego_de_caracteres_MIME:\
	:lang=nombre de la locale:\
	:tc=default:</pre></div></div><div class=paragraph><p>Así que, si seguimos con nuestro ejemplo anterior que usaba Latin-1, tendría este aspecto:</p></div><div class="literalblock programlisting"><div class=content><pre>german:German Users Accounts:\
	:charset=ISO-8859-1:\
	:lang=de_DE.ISO8859-1:\
	:tc=default:</pre></div></div></div><div class=sect5><h6 id=_modificación_de_las_clases_de_sesión_con_vipw8>22.3.4.1.3. Modificación de las clases de sesión con <a href="https://man.freebsd.org/cgi/man.cgi?query=vipw&amp;sektion=8&amp;format=html">vipw(8)</a><a class=anchor href=#_modificación_de_las_clases_de_sesión_con_vipw8></a></h6><div class=paragraph><p>Utilice <code>vipw</code> para añadir nuevos usuarios, y haga que la entrada tenga este aspecto:</p></div><div class="literalblock programlisting"><div class=content><pre>usuario:contraseña:1111:11:idioma:0:0:Nombre de usuario:/home/usuario:/bin/sh</pre></div></div></div><div class=sect5><h6 id=_modificación_de_las_clases_de_sesión_con_with_adduser8>22.3.4.1.4. Modificación de las clases de sesión con with <a href="https://man.freebsd.org/cgi/man.cgi?query=adduser&amp;sektion=8&amp;format=html">adduser(8)</a><a class=anchor href=#_modificación_de_las_clases_de_sesión_con_with_adduser8></a></h6><div class=paragraph><p>Utilice <code>adduser</code> para añadir nuevos usuarios, y haga lo siguiente:</p></div><div class=ulist><ul><li><p>Establezca <code>defaultclass = idioma</code> en <span class=filename>/etc/adduser.conf</span>. Recuerde que en este caso debe introducir una clase <code>default</code> (por omisión) para todos los usuarios de otros idiomas.</p></li><li><p>Una variante alternativa es contestar el idioma indicado cada vez que <a href="https://man.freebsd.org/cgi/man.cgi?query=adduser&amp;sektion=8&amp;format=html">adduser(8)</a> muestre</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Enter login class: default
		  <span class=o>[]</span>:</code></pre></div></div></li><li><p>Otra alternativa es utilizar lo siguiente para cada usuario de un idioma diferente al que desee añadir:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># adduser -class</span>
		  idioma</code></pre></div></div></li></ul></div></div><div class=sect5><h6 id=_modificación_de_las_clases_de_sesión_con_pw8>22.3.4.1.5. Modificación de las clases de sesión con <a href="https://man.freebsd.org/cgi/man.cgi?query=pw&amp;sektion=8&amp;format=html">pw(8)</a><a class=anchor href=#_modificación_de_las_clases_de_sesión_con_pw8></a></h6><div class=paragraph><p>Si utiliza <a href="https://man.freebsd.org/cgi/man.cgi?query=pw&amp;sektion=8&amp;format=html">pw(8)</a> para añadir nuevos usuarios, llámelo de esta manera:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pw useradd</span>
	      nombre_usuario <span class=nt>-L</span>
	      idioma</code></pre></div></div></div><div class=sect5><h6 id=startup-file>22.3.4.1.6. Método de los ficheros de inicio de los intérpretes de órdenes<a class=anchor href=#startup-file></a></h6><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>No se recomienda este método porque precisa de una configuración diferente para cada intérprete de órdenes que se pueda elegir. Utilice en su lugar el <a href=#login-class>método de las clases de sesión</a>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Para añadir el nombre de la "locale " y el juego de caracteres MIME, simplemente establezca las dos variables de entorno mostradas abajo en los ficheros de inicio del intérprete de órdenes <span class=filename>/etc/profile</span> y/o <span class=filename>/etc/csh.login</span>. Aquí abajo usaremos el idioma alemán como ejemplo:</p></div><div class=paragraph><p>En <span class=filename>/etc/profile</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>LANG=de_DE.ISO8859-1; export LANG
MM_CHARSET=ISO-8859-1; export MM_CHARSET</pre></div></div><div class=paragraph><p>O en <span class=filename>/etc/csh.login</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>setenv LANG de_DE.ISO8859-1
setenv MM_CHARSET ISO-8859-1</pre></div></div><div class=paragraph><p>Como alternativa, puede añadir las instrucciones anteriores a <span class=filename>/usr/shared/skel/dot.profile</span> (similar a lo que se utilizó antes en <span class=filename>/etc/profile</span> ), o <span class=filename>/usr/shared/skel/dot.login</span> (similar a lo que se utilizó antes en <span class=filename>/etc/csh.login</span>).</p></div><div class=paragraph><p>Para X11:</p></div><div class=paragraph><p>En <span class=filename>$HOME/.xinitrc</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>LANG=de_DE.ISO8859-1; export LANG</pre></div></div><div class=paragraph><p>O:</p></div><div class="literalblock programlisting"><div class=content><pre>setenv LANG de_DE.ISO8859-1</pre></div></div><div class=paragraph><p>En función de su intérprete de órdenes (vea más arriba).</p></div></div></div></div><div class=sect3><h4 id=setting-console>22.3.5. Configuración de la consola<a class=anchor href=#setting-console></a></h4><div class=paragraph><p>Para todos los juegos de caracteres representables con el tipo char en C, establezca los tipos de letra para la consola adecuados para el idioma en cuestión en <span class=filename>/etc/rc.conf</span> con:</p></div><div class="literalblock programlisting"><div class=content><pre>font8x16=nombre_del_tipo_de_letra

font8x14=nombre_del_tipo_de_letra
font8x8=nombre_del_tipo_de_letra</pre></div></div><div class=paragraph><p>Aquí, el <em>nombre_del_tipo_de_letra</em> se toma del directorio <span class=filename>/usr/shared/syscons/fonts</span>, sin el sufijo <span class=filename>.fnt</span>.</p></div><div class=paragraph><p>Asegúrese también de configurar los mapas de teclado y pantalla correctos para su juego de caracteres C por medio de <code>sysinstall</code> (<code>/stand/sysinstall</code> en versiones de FreeBSD anteriores a la 5.2). Una vez dentro de sysinstall , seleccione <span class=guimenuitem>Configure</span>, y después <span class=guimenuitem>Console</span>. Como alternativa, puede añadir lo siguiente en <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>scrnmap=nombre_del_mapa_de_pantalla
keymap=nombre_del_mapa_de_teclado
keychange=&#34;secuencia número_tecla_de_función&#34;</pre></div></div><div class=paragraph><p>Aquí, el <em>nombre_del_mapa_de_pantalla</em> se toma del directorio <span class=filename>/usr/shared/syscons/scrnmaps</span>, sin el sufijo <span class=filename>.scm</span>. Normalmente es necesario un mapa de pantalla ("screenmap") con un tipo de letra correspondiente para poder extender de 8 a 9 bits la matriz de caracteres de una tarjeta VGA en un área pseudográfica, es decir, desplazar las letras fuera de ese área si el tipo de letra de pantalla usa una columna de 8 bits.</p></div><div class=paragraph><p>Si tiene habilitado el dæmon moused por configurar esto en su <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>moused_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>entonces estudie la información sobre el cursor del ratón del siguiente párrafo.</p></div><div class=paragraph><p>Por omisión, el cursor del ratón del controlador <a href="https://man.freebsd.org/cgi/man.cgi?query=syscons&amp;sektion=4&amp;format=html">syscons(4)</a> ocupa el intervalo 0xd0-0xd3 del juego de caracteres. Si su idioma usa este intervalo, necesita desplazar el intervalo del cursor fuera de él. En versiones de FreeBSD anteriores a la 5.0, introduzca la siguiente línea en la configuración del núcleo:</p></div><div class="literalblock programlisting"><div class=content><pre>options		SC_MOUSE_CHAR=0x03</pre></div></div><div class=paragraph><p>En FreeBSD 4.4 y posteriores, introduzca la siguiente línea en <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>mousechar_start=3</pre></div></div><div class=paragraph><p>Aquí, el <em>nombre_del_mapa_de_teclado</em> se toma del directorio <span class=filename>/usr/shared/syscons/keymaps</span>, sin el sufijo <span class=filename>.kbd</span>. Si no está seguro de cual mapa de teclado usar, puede usar <a href="https://man.freebsd.org/cgi/man.cgi?query=kbdmap&amp;sektion=1&amp;format=html">kbdmap(1)</a> para probar los mapas de teclado sin reiniciar.</p></div><div class=paragraph><p>Normalmente se necesita el <code>keychange</code> para programar las teclas de función para que coincidan con el tipo de terminal seleccionado, porque las secuencias de las teclas de función no se pueden definir en el mapa de teclado.</p></div><div class=paragraph><p>Asegúrese también de configurar el tipo de terminal consola correcto en <span class=filename>/etc/ttys</span> para todas las entradas <code>ttyv*</code>. Las correspondencias predefinidas actualmente son:</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Juego de caracteres</th><th class="tableblock halign-left valign-top">Tipo de terminal</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>ISO-8859-1 o ISO-8859-15</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>cons25l1</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>ISO-8859-2</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>cons25l2</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>ISO-8859-7</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>cons25l7</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>KOI8-R</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>cons25r</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>KOI8-U</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>cons25u</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>CP437 (predeterminada en VGA)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>cons25</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>US-ASCII</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><code>cons25w</code></p></td></tr></tbody></table><div class=paragraph><p>Para los idiomas en caracteres anchos o multibyte, utilice el port correcto de FreeBSD en su directorio <span class=filename>/usr/ports/idioma</span>. Algunos ports aparecen como consola mientras que el sistema los ve como una vtty serie, por lo tanto debe reservar suficientes vtty tanto para X11 como la consola pseudoserie. Aquí tiene una lista parcial de aplicaciones para usar otros idiomas en la consola:</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Idioma</th><th class="tableblock halign-left valign-top">Ubicación</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Chino tradicional (BIG-5)</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/chinese/big5con/>chinese/big5con</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Japonés</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/japanese/kon2-16dot/>japanese/kon2-16dot</a> o <a class=package href=https://cgit.freebsd.org/ports/tree/japanese/mule-freewnn/>japanese/mule-freewnn</a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Coreano</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a class=package href=https://cgit.freebsd.org/ports/tree/korean/han/>korean/han</a></p></td></tr></tbody></table></div><div class=sect3><h4 id=_configuración_de_x11>22.3.6. Configuración de X11<a class=anchor href=#_configuración_de_x11></a></h4><div class=paragraph><p>Aunque X11 no es parte del Proyecto FreeBSD, hemos incluido aquí algo de información para usuarios de FreeBSD. Para más detalles, acuda al <a href=http://www.x.org/>sitio web de Xorg</a> o del servidor X11 que utilice.</p></div><div class=paragraph><p>En <span class=filename>~/.Xresources</span>, puede afinar más las opciones de I18N específicas de la aplicación (v.g., tipos de letra, menús, etc).</p></div><div class=sect4><h5 id=_visualización_de_los_tipos_de_letra>22.3.6.1. Visualización de los tipos de letra<a class=anchor href=#_visualización_de_los_tipos_de_letra></a></h5><div class=paragraph><p>Instale el servidor Xorg (<a class=package href=https://cgit.freebsd.org/ports/tree/x11-servers/xorg-server/>x11-servers/xorg-server</a> o el servidor XFree86™ (<a class=package href=https://cgit.freebsd.org/ports/tree/x11-servers/XFree86-4-Server/>x11-servers/XFree86-4-Server</a>), y despúes instale los tipos de letra TrueType® del idioma. La configuración de la "locale" correcta para el idioma debería permitirle ver el idioma seleccionado en menús y similares.</p></div></div><div class=sect4><h5 id=_introducción_de_caracteres_no_ingleses>22.3.6.2. Introducción de caracteres no ingleses<a class=anchor href=#_introducción_de_caracteres_no_ingleses></a></h5><div class=paragraph><p>El protocolo Método de Introducción X11 (XIM) es un nuevo estándar para todos los clientes X11. Todas las aplicaciones X11 deberían estar escritas como clientes XIM que reciben entradas de servidores XIM. Hay varios servidores XIM disponibles para distintos idiomas.</p></div></div></div><div class=sect3><h4 id=_configuración_de_la_impresora>22.3.7. Configuración de la impresora<a class=anchor href=#_configuración_de_la_impresora></a></h4><div class=paragraph><p>Hay algunos juegos de caracteres de tipo char de C que están normalmente codificados por hardware en las impresoras. Los juegos de caracteres anchos o multibyte precisan de una configuración especial y recomendamos el uso de apsfilter. También puede convertir el documento a los formatos PostScript® o PDF usando conversores específicos del idioma.</p></div></div><div class=sect3><h4 id=_el_núcleo_y_los_sistemas_de_ficheros>22.3.8. El núcleo y los sistemas de ficheros<a class=anchor href=#_el_núcleo_y_los_sistemas_de_ficheros></a></h4><div class=paragraph><p>El sistema de ficheros rápido (FFS) de FreeBSD funciona bien a 8 bits, así que se puede usar con cualquier juego de caracteres de tipo char de C (vea <a href="https://man.freebsd.org/cgi/man.cgi?query=multibyte&amp;sektion=3&amp;format=html">multibyte(3)</a>), pero no hay almacenado ningún nombre de juego de caracteres en el sistema de ficheros; es decir, son 8 bits en bruto y no sabe nada acerca del orden de codificación. Oficialmente, FFS no soporta todavía ninguna forma de juegos de caracteres anchos o multibyte. Sin embargo, algunos juegos de caracteres anchos o multibyte tienen parches independientes para habilitar dicho soporte en FFS. Son solamente soluciones temporales no portables o "hacks", y hemos decicido no incluirlas en el árbol de código fuente. Diríjase a los sitios web de los respectivos idiomas para encontrar más información y los parches.</p></div><div class=paragraph><p>El sistema de ficheros MS-DOS®de FreeBSD tiene la capacidad configurable de convertir entre los juegos de caracteres MS-DOS®, Unicode y los juegos de caracteres seleccionados del sistema de ficheros de FreeBSD. Vea <a href="https://man.freebsd.org/cgi/man.cgi?query=mount_msdos&amp;sektion=8&amp;format=html">mount_msdos(8)</a> para más detalles.</p></div></div></div><div class=sect2><h3 id=l10n-compiling>22.4. Compilación de programas con soporte para I18N<a class=anchor href=#l10n-compiling></a></h3><div class=paragraph><p>Muchos ports de FreeBSD han sido portados con soporte para I18N. Algunos de ellos están marcados con -I18N en el nombre del port. Éstos y muchos otros programas tienen incorporado soporte para I18N y no necesitan ninguna consideración especial.</p></div><div class=paragraph><p>Sin embargo, algunas aplicaciones como MySQL necesitan tener el <span class=filename>Makefile</span> configurado con el juego de caracteres específico. Esto se hace normalmente en el <span class=filename>Makefile</span> o pasando un valor a configure en el código fuente.</p></div></div><div class=sect2><h3 id=lang-setup>22.5. Localización de FreeBSD a idiomas específicos<a class=anchor href=#lang-setup></a></h3><div class=sect3><h4 id=ru-localize>22.5.1. Idioma ruso (codificación KOI8-R)<a class=anchor href=#ru-localize></a></h4><div class=paragraph><p>Para más información sobre la codificación KOI8-R, vea las <a href=http://koi8.pp.ru/>Referencias KOI8-R (Juego de caracteres rusos para la red)</a>.</p></div><div class=sect4><h5 id=_configuración_de_la_locale>22.5.1.1. Configuración de la "locale"<a class=anchor href=#_configuración_de_la_locale></a></h5><div class=paragraph><p>Ponga las siguientes líneas en su fichero <span class=filename>~/.login_conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>me:My account:\
	:charset=KOI8-R:\
	:lang=ru_RU.KOI8-R:</pre></div></div><div class=paragraph><p>Vea anteriormente en este mismo capítulo ejemplos de configuración de las <a href=#setting-locale>locales</a>.</p></div></div><div class=sect4><h5 id=_configuración_de_la_consola>22.5.1.2. Configuración de la consola<a class=anchor href=#_configuración_de_la_consola></a></h5><div class=ulist><ul><li><p>En versiones de FreeBSD anteriores a la 5.0, añada la liguiente línea en el fichero de configuración del núcleo:</p><div class="literalblock programlisting"><div class=content><pre>options		SC_MOUSE_CHAR=0x03</pre></div></div><div class=paragraph><p>En FreeBSD 4.4 y posteriores introduzca la siguiente línea en <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>mousechar_start=3</pre></div></div></li><li><p>Utilice las siguientes opciones en <span class=filename>/etc/rc.conf</span>:</p><div class="literalblock programlisting"><div class=content><pre>keymap=&#34;ru.utf-8&#34;
scrnmap=&#34;utf-82cp866&#34;
font8x16=&#34;cp866b-8x16&#34;
font8x14=&#34;cp866-8x14&#34;
font8x8=&#34;cp866-8x8&#34;</pre></div></div></li><li><p>Para cada entrada <code>ttyv*</code> en <span class=filename>/etc/ttys</span>, utilice <code>cons25r</code> como el tipo de terminal.</p></li></ul></div><div class=paragraph><p>Vea anteriormente en este mismo capítulo ejemplos de configuración de la <a href=#setting-console>consola</a>.</p></div></div><div class=sect4><h5 id=_configuración_de_la_impresora_2>22.5.1.3. Configuración de la impresora<a class=anchor href=#_configuración_de_la_impresora_2></a></h5><div class=paragraph><p>Dado que la mayoría de las impresoras con caracteres rusos tienen un código de página CP866 en hardware, es necesario un filtro de salida especial para convertir de KOI8-R a CP866. Tal filtro es instalado por omisión como <span class=filename>/usr/libexec/lpr/ru/koi2alt</span>. Una entrada de impresora rusa <span class=filename>/etc/printcap</span> debería tener este aspecto:</p></div><div class="literalblock programlisting"><div class=content><pre>lp|Russian local line printer:\
	:sh:of=/usr/libexec/lpr/ru/koi2alt:\
	:lp=/dev/lpt0:sd=/var/spool/output/lpd:lf=/var/log/lpd-errs:</pre></div></div><div class=paragraph><p>Consulte <a href="https://man.freebsd.org/cgi/man.cgi?query=printcap&amp;sektion=5&amp;format=html">printcap(5)</a> para una explicación detallada.</p></div></div><div class=sect4><h5 id=_sistema_de_ficheros_ms_dos_y_nombres_de_ficheros_en_ruso>22.5.1.4. Sistema de ficheros MS-DOS® y nombres de ficheros en ruso<a class=anchor href=#_sistema_de_ficheros_ms_dos_y_nombres_de_ficheros_en_ruso></a></h5><div class=paragraph><p>La siguiente entrada <a href="https://man.freebsd.org/cgi/man.cgi?query=fstab&amp;sektion=5&amp;format=html">fstab(5)</a> de ejemplo habilita el soporte para nombres de fichero en ruso en los sistemas de ficheros MS-DOS® montados:</p></div><div class="literalblock programlisting"><div class=content><pre>/dev/ad0s2      /dos/c  msdos   rw,-Wkoi2dos,-Lru_RU.KOI8-R 0 0</pre></div></div><div class=paragraph><p>La opción <code>-L</code> selecciona el nombre de la "locale" usada, y <code>-W</code> establece la tabla de conversión de caracteres. Para usar la opción <code>-W</code> , asegúrese de montar <span class=filename>/usr</span> antes que la partición MS-DOS®, porque las tablas de conversión se ubican en <span class=filename>/usr/libdata/msdosfs</span>. Para más información, vea la página de manual <a href="https://man.freebsd.org/cgi/man.cgi?query=mount_msdos&amp;sektion=8&amp;format=html">mount_msdos(8)</a>.</p></div></div><div class=sect4><h5 id=_configuración_de_x11_2>22.5.1.5. Configuración de X11<a class=anchor href=#_configuración_de_x11_2></a></h5><div class="olist arabic"><ol class=arabic><li><p>Antes haga la <a href=#setting-locale>configuración de las "locales" para la consola</a> como se ha explicado.</p><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p><a id=russian-note></a>La "locale " rusa KOI8-R puede no funcionar con versiones antiguas (anteriores a la 3.3) de XFree86™. Xorg es ahora la versión predefinida del sistema de ventanas X en FreeBSD. Esto no debería ser un problema salvo que esté usando una versión antigua de FreeBSD.</p></div></td></tr></tbody></table></div></li><li><p>Si utiliza Xorg, instale el paquete <a class=package href=https://cgit.freebsd.org/ports/tree/x11-fonts/xorg-fonts-cyrillic/>x11-fonts/xorg-fonts-cyrillic</a>.</p><div class=paragraph><p>Compruebe la sección <code>"Files"</code> de su fichero <span class=filename>/etc/X11/xorg.conf</span>. Se deben añadir las siguientes líneas <em>antes</em> de ninguna otra entrada <code>FontPath</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>FontPath   &#34;/usr/X11R6/lib/X11/fonts/cyrillic/misc&#34;
FontPath   &#34;/usr/X11R6/lib/X11/fonts/cyrillic/75dpi&#34;
FontPath   &#34;/usr/X11R6/lib/X11/fonts/cyrillic/100dpi&#34;</pre></div></div><div class=paragraph><p>Si utiliza un modo de vídeo de alta resolución, intercambie las líneas 75 dpi y 100 dpi.</p></div></li><li><p>Para activar un teclado ruso, añada lo siguiente a la sección <code>"Keyboard"</code> de su fichero <span class=filename>XF86Config</span>.</p><div class=paragraph><p>Para XFree86™ 3.X:</p></div><div class="literalblock programlisting"><div class=content><pre>XkbLayout  &#34;ru&#34;
XkbOptions &#34;grp:caps_toggle&#34;</pre></div></div><div class=paragraph><p>Para Xorg (o XFree86™ 4.X):</p></div><div class="literalblock programlisting"><div class=content><pre>Option &#34;XkbLayout&#34;   &#34;us,ru&#34;
Option &#34;XkbOptions&#34;  &#34;grp:toggle&#34;</pre></div></div><div class=paragraph><p>Asegúrese también de que <code>XkbDisable</code> esté desactivado (comentado) allí.</p></div><div class=paragraph><p>Para <code>grp:caps_toggle</code> la tecla para pasar entre la codificación rusa y la latina será <kbd>BloqMayús</kbd>. La antigua función de <kbd>BloqMayús</kbd> todavía está disponible a través de <span class=keyseq><kbd>May</kbd>+<kbd>BloqMayús</kbd></span> (sólamente en modo latino). Para <code>grp:toggle</code> la tecla para pasar entre la codificación rusa y la latina será <kbd>Alt derecha</kbd>. <code>grp:caps_toggle</code> no funciona en Xorg por alguna razón desconocida.</p></div><div class=paragraph><p>Si en su teclado dispone de teclas "Windows® ", y observa que algunas teclas no alfanuméricas están mapeadas incorrectamente en el modo ruso, añada la siguiente línea en su fichero <span class=filename>XF86Config</span>.</p></div><div class=paragraph><p>Para XFree86™ 3.X:</p></div><div class="literalblock programlisting"><div class=content><pre>XkbVariant &#34;winkeys&#34;</pre></div></div><div class=paragraph><p>Para Xorg (o XFree86™ 4.X):</p></div><div class="literalblock programlisting"><div class=content><pre>Option &#34;XkbVariant&#34; &#34;,winkeys&#34;</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>El teclado XKB ruso puede no funcionar con versiones antiguas de XFree86™ , vea la <a href=#russian-note>nota anterior</a> para más información. El teclado XKB ruso puede no funcionar tampoco con aplicaciones no localizadas.</p></div></td></tr></tbody></table></div></li></ol></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Las aplicaciaones mínimamente localizadas deberían llamar una función <code>XtSetLanguageProc (NULL, NULL, NULL);</code> al principio del programa.</p></div><div class=paragraph><p>Vea <a href=http://koi8.pp.ru/xwin.html>KOI8-R para X Window</a> para más instrucciones sobre la localización de aplicaciones X11.</p></div></td></tr></tbody></table></div></div></div><div class=sect3><h4 id=_localización_al_chino_tradicional_para_taiwán>22.5.2. Localización al chino tradicional para Taiwán<a class=anchor href=#_localización_al_chino_tradicional_para_taiwán></a></h4><div class=paragraph><p>El proyecto FreeBSD-Taiwán tiene una Guía de chino para FreeBSD en <a href=http://netlab.cse.yzu.edu.tw/~statue/freebsd/zh-tut/>http://netlab.cse.yzu.edu.tw/~statue/freebsd/zh-tut/</a> que utiliza muchos ports chinos. El editor actual del <code>FreeBSD Chinese HOWTO</code> es Shen Chuan-Hsing <a href=mailto:statue@freebsd.sinica.edu.tw>statue@freebsd.sinica.edu.tw</a>.</p></div><div class=paragraph><p>Chuan-Hsing Shen <a href=mailto:statue@freebsd.sinica.edu.tw>statue@freebsd.sinica.edu.tw</a> ha creado la <a href=http://netlab.cse.yzu.edu.tw/~statue/cfc/>Colección de FreeBSD en chino (CFC)</a> usando <code>zh-L10N-tut</code> de FreeBSD-Taiwán. Los paquetes y los guiones están disponibles en <a href=ftp://freebsd.csie.nctu.edu.tw/pub/taiwan/CFC/>ftp://freebsd.csie.nctu.edu.tw/pub/taiwan/CFC/</a>.</p></div></div><div class=sect3><h4 id=_localización_al_idioma_alemán_para_todos_los_idiomas_iso_8859_1>22.5.3. Localización al idioma alemán (para todos los idiomas ISO 8859-1)<a class=anchor href=#_localización_al_idioma_alemán_para_todos_los_idiomas_iso_8859_1></a></h4><div class=paragraph><p>Slaven Rezic <a href=mailto:eserte@cs.tu-berlin.de>eserte@cs.tu-berlin.de</a> ha escrito un tutorial de como usar las diéresis en una máquina FreeBSD. El tutorial está disponible en <a href=http://www.de.FreeBSD.org/de/umlaute/>http://www.de.FreeBSD.org/de/umlaute/</a>.</p></div></div><div class=sect3><h4 id=_localización_a_los_idiomas_japonés_y_coreano>22.5.4. Localización a los idiomas japonés y coreano<a class=anchor href=#_localización_a_los_idiomas_japonés_y_coreano></a></h4><div class=paragraph><p>Para el japonés, diríjase a <a href=http://www.jp.FreeBSD.org/>http://www.jp.FreeBSD.org/</a>, y para el coreano, acuda a <a href=http://www.kr.FreeBSD.org/>http://www.kr.FreeBSD.org/</a>.</p></div></div><div class=sect3><h4 id=_documentación_sobre_freebsd_en_otros_idiomas_aparte_del_inglés>22.5.5. Documentación sobre FreeBSD en otros idiomas aparte del inglés<a class=anchor href=#_documentación_sobre_freebsd_en_otros_idiomas_aparte_del_inglés></a></h4><div class=paragraph><p>Algunos contribuidores de FreeBSD han traducido partes de FreeBSD a otros idiomas. Están disponibles a través de enlaces en el <a href=http://www.freebsd.org/>sitio principal</a> o en <span class=filename>/usr/shared/doc</span>.</p></div></div></div></div></div><div class=sect1><h2 id=updating-upgrading>Capítulo 23. Lo último de lo último<a class=anchor href=#updating-upgrading></a></h2><div class=sectionbody><div class=sect2><h3 id=_sinopsis_4>23.1. Sinopsis<a class=anchor href=#_sinopsis_4></a></h3><div class=paragraph><p>Pendiente de Traducción</p></div></div><div class=sect2><h3 id=current-stable>23.2. FreeBSD-CURRENT vs. FreeBSD-STABLE<a class=anchor href=#current-stable></a></h3><div class=sect3><h4 id=current>23.2.1. Current<a class=anchor href=#current></a></h4><div class=paragraph><p>Pendiente de Traducción</p></div></div><div class=sect3><h4 id=stable>23.2.2. Stable<a class=anchor href=#stable></a></h4><div class=paragraph><p>Pendiente de Traducción</p></div></div></div><div class=sect2><h3 id=synching>23.3. Sincronización de su código fuente<a class=anchor href=#synching></a></h3><div class=paragraph><p>Pendiente de Traducción</p></div></div><div class=sect2><h3 id=makeworld>23.4. Uso de <code>make world</code><a class=anchor href=#makeworld></a></h3><div class=paragraph><p>Pendiente de Traducción</p></div></div><div class=sect2><h3 id=small-lans>23.5. Redes pequeñas<a class=anchor href=#small-lans></a></h3><div class=paragraph><p>Pendiente de Traducción</p></div></div></div></div><h1 id=network-communication class=sect0>Parte IV: Comunicaciones en red<a class=anchor href=#network-communication></a></h1><div class="openblock partintro"><div class=content><div class=paragraph><p>FreeBSD es uno de los sistemas operativos más utilizados como servidores en red de alto rendimiento. Los siguientes capítulos cubren:</p></div><div class=ulist><ul><li><p>Comunicaciones serie</p></li><li><p>PPP y PPP sobre Ethernet</p></li><li><p>Correo electrónico</p></li><li><p>Servidores de red</p></li><li><p>Otros aspectos avanzados de red</p></li></ul></div><div class=paragraph><p>Estos capítulos están diseñados para leerse según van haciendo falta. No tienen por qué leerse en un determinado orden, ni tiene por qué leerlos todos antes de poder usar FreeBSD en un entorno de red.</p></div></div></div><div class=sect1><h2 id=serialcomms>Capítulo 24. Comunicaciones serie<a class=anchor href=#serialcomms></a></h2><div class=sectionbody><div class=sect2><h3 id=serial-synopsis>24.1. Sinopsis<a class=anchor href=#serial-synopsis></a></h3><div class=paragraph><p>UNIX® siempre ha tenido soporte para comunicación serie. De hecho, las primeras máquinas UNIX® dependían de líneas serie para tener interacción con el usuario. Las cosas han cambiado mucho desde esos días cuando la "terminal" promedio consistía de una terminal serie de 10-caracteres-por-segundo, impresora y teclado. Este capítulo cubrirá algunas de las maneras en las que FreeBSD utiliza comunicaciones serie.</p></div><div class=paragraph><p>Despues de leer este capítulo, usted entenderá:</p></div><div class=ulist><ul><li><p>Como conectar terminales a su sistema FreeBSD.</p></li><li><p>Como utilizar un modem para marcar a equipos remotos.</p></li><li><p>Como permitir a usuarios remotos entrar a su sistema con un modem.</p></li><li><p>Como arrancar su sistema desde una consola serie.</p></li></ul></div><div class=paragraph><p>Antes de leer este capítulo usted debería:</p></div><div class=ulist><ul><li><p>Saber como configurar e instalar un nuevo kernel (<a href=./#kernelconfig>Configuración del kernel de FreeBSD</a>).</p></li><li><p>Entender procesos y permisos UNIX® (<a href=./#basics>Conceptos básicos de Unix</a>).</p></li><li><p>Tener acceso al manual técnico para el hardware serie (modem o tarjeta multipuerto) que le gustaría utilizar con FreeBSD.</p></li></ul></div></div><div class=sect2><h3 id=serial>24.2. Introducción<a class=anchor href=#serial></a></h3><div class=sect3><h4 id=serial-terminology>24.2.1. Terminología<a class=anchor href=#serial-terminology></a></h4><div class=dlist><dl><dt class=hdlist1>bps</dt><dd><p>Bits por segundo - la tasa a la cual los datos son transmitidos</p></dd><dt class=hdlist1>DTE</dt><dd><p>Data Terminal Equipment (Equipo terminal de datos) - por ejemplo, su computadora</p></dd><dt class=hdlist1>DCE</dt><dd><p>Data Communications Equipment (Equipo de comunicación de datos) - su modem</p></dd><dt class=hdlist1>RS-232</dt><dd><p>Estándar EIA para hardware de comunicación serie</p></dd></dl></div><div class=paragraph><p>Cuando se habla de tasa de comunicación de datos, ésta sección no usa el término "baud". Baud se refiere al número de estados de transición eléctricos que pueden realizarse en un periodo de tiempo, mientras que "bps" (bits por segundo) es el término <em>correcto</em> a usar (al menos parece no molestar demasiado a los más aferrados).</p></div></div><div class=sect3><h4 id=serial-cables-ports>24.2.2. Cables y puertos<a class=anchor href=#serial-cables-ports></a></h4><div class=paragraph><p>Para conectar un modem o terminal a su sistema FreeBSD necesitará un puerto serie en su computadora y el cable apropiado para conectar a su dispositivo serie. Si ya está familiarizado con su hardware y el cable que requiere, puede saltarse esta sección.</p></div><div class=sect4><h5 id=term-cables>24.2.2.1. Cables<a class=anchor href=#term-cables></a></h5><div class=paragraph><p>Existen diferentes tipos de cables serie. Los dos tipos más comunes para nuestros propósitos son cables null-modem y cables RS-232 estándar ("normal"). La documentación de su hardware debería describir el tipo de cable requerido.</p></div><div class=sect5><h6 id=term-cables-null>24.2.2.1.1. Cables null-modem<a class=anchor href=#term-cables-null></a></h6><div class=paragraph><p>Un cable null-modem pasa algunas señales, como "tierra", normalmente, pero cambia otras señales. Por ejemplo, el pin "envío de datos" en un extremo va al pin "recepción de datos" en el otro.</p></div><div class=paragraph><p>Si le gusta fabricar sus propios cables, puede construir un cable null-modem para utilizar con terminales. Esta tabla muestra los nombres de señal y números de pin en un conector DB-25.</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:20%><col style=width:20%><col style=width:20%><col style=width:20%><col style=width:20%><thead><tr><th class="tableblock halign-left valign-top">Señal</th><th class="tableblock halign-left valign-top">Pin #</th><th class="tableblock halign-left valign-top"></th><th class="tableblock halign-left valign-top">Pin #</th><th class="tableblock halign-left valign-top">Señal</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>SG</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>7</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>conecta a</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>7</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>SG</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>TD</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>2</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>conecta a</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>3</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>RD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>RD</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>3</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>conecta to</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>2</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>TD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>RTS</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>4</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>conecta a</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>5</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>CTS</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>CTS</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>5</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>conecta a</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>4</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>RTS</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>DTR</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>20</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>conecta a</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>6</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>DSR</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>DCD</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>8</p></td><td class="tableblock halign-left valign-top"></td><td class="tableblock halign-left valign-top"><p class=tableblock>6</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>DSR</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>DSR</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>6</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>conecta a</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>20</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>DTR</p></td></tr></tbody></table><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Conectar "Data Set Ready" (DSR) y "Data Carrier Detect" (DCD) intérnamente en la capucha del conector, y entonces a "Data Terminal Ready" (DTR) en la capucha remota.</p></div></td></tr></tbody></table></div></div><div class=sect5><h6 id=term-cables-std>24.2.2.1.2. Cables estándard RS-232C<a class=anchor href=#term-cables-std></a></h6><div class=paragraph><p>Un cable serie estándar pasa todas las señales RS-232C normalmente. Esto es, el pin "envío de datos" en un extremo va al pin "envío de datos" en el otro extremo. Este es el tipo de cable a utilizar para conectar un modem a su sistema FreeBSD, y también es apropiado para algunas terminales.</p></div></div></div><div class=sect4><h5 id=term-ports>24.2.2.2. Puertos<a class=anchor href=#term-ports></a></h5><div class=paragraph><p>Puertos serie son los dispositivos a través de los cuales los datos son transferidos entre una computadora FreeBSD y la terminal. Esta sección describe los tipos de puertos que existen y como son referidos en FreeBSD.</p></div><div class=sect5><h6 id=term-portkinds>24.2.2.2.1. Tipos de puertos<a class=anchor href=#term-portkinds></a></h6><div class=paragraph><p>Existen varios tipos de puertos serie. antes de comprar o construir un cable, necesita asegurarse que coincida con los puertos en su terminal y en su sistema FreeBSD.</p></div><div class=paragraph><p>La mayoría de las terminales tienen puertos DB25. Computadoras personales, incluyendo PCs corriendo FreeBSD, tienen puertos DB25 o DB9. Si tiene una tarjeta multipuertos serie para su PC, tal vez tenga puertos RJ-12 o RJ-45.</p></div><div class=paragraph><p>Vea la documentación que acompaña su hardware para las especificaciones sobre el tipo de puerto en uso. Una inspección visual del puerto también funciona en la mayoría de los casos.</p></div></div><div class=sect5><h6 id=term-portnames>24.2.2.2.2. Nombres de puerto<a class=anchor href=#term-portnames></a></h6><div class=paragraph><p>En FreeBSD, se accesa cada puerto serie a través de una entrada en el directorio <span class=filename>/dev</span>. Existen dos tipos de entradas:</p></div><div class=ulist><ul><li><p>Puertos de llamada-entrante son llamados <span class=filename>/dev/ttydN</span> donde <em>N</em> es el número de puerto, iniciando desde cero. Generalmente, los puertos de llamada-entrante se utilizan para terminales. Los puertos de llamada-entrante requieren que la línea serie especifique la señal data carrier detect (DCD) para funcionar correctamente.</p></li><li><p>Puertos de llamada-saliente son llamados <span class=filename>/dev/cuaaN</span>. Usualmente no se utilizan los puertos de llamada-saliente para terminales, solo para modems. Puede utilizar el puerto de llamada-saliente si el cable serie o la terminal no soporta la señal de carrier detect.</p></li></ul></div><div class=paragraph><p>Si tiene conectada una terminal al primer puerto serie (<span class=filename>COM1</span> en MS-DOS®), entonces usará <span class=filename>/dev/ttyd0</span> para referirse a la terminal. Si la terminal está en el segundo puerto serie (también conocido como <span class=filename>COM2</span>), utilice <span class=filename>/dev/ttyd1</span>, y así sucesivamente.</p></div></div></div></div><div class=sect3><h4 id=_configuración_del_kernel_2>24.2.3. Configuración del kernel<a class=anchor href=#_configuración_del_kernel_2></a></h4><div class=paragraph><p>FreeBSD soporta cuatro puertos serie por omisión. en el mundo MS-DOS® éstos son conocidos como <span class=filename>COM1</span>, <span class=filename>COM2</span>, <span class=filename>COM3</span>, y <span class=filename>COM4</span>. FreeBSD actualmente soporta tarjetas de interfaz serie "tontas", como la BocaBoard 1008 y 2016, así como tarjetas multipuerto más inteligentes como las fabricadas por Digiboard y Stallion Technologies. De cualquier manera, el kernel por omisión solo busca por los puertos COM estándares.</p></div><div class=paragraph><p>Para ver si su kernel reconoce cualquiera de sus puertos serie, mire los mensajes mientras el kernel esta arrancando, o utilice el comando <code>/sbin/dmesg</code> para repetir los mensajes de arranque del kernel. En particular busque por mensajes que inicien con el caracter <code>sio</code>.</p></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Para ver solamente los mensajes que contienen la palabra <code>sio</code>, use el comando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /sbin/dmesg | grep &#39;sio&#39;</span></code></pre></div></div></td></tr></tbody></table></div><div class=paragraph><p>Por ejemplo, en un sistema con cuatro puertos serie, éstos son los mensajes de arranque del kernel específicos de puerto serie:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>sio0 at 0x3f8-0x3ff irq 4 on isa
sio0: <span class=nb>type </span>16550A
sio1 at 0x2f8-0x2ff irq 3 on isa
sio1: <span class=nb>type </span>16550A
sio2 at 0x3e8-0x3ef irq 5 on isa
sio2: <span class=nb>type </span>16550A
sio3 at 0x2e8-0x2ef irq 9 on isa
sio3: <span class=nb>type </span>16550A</code></pre></div></div><div class=paragraph><p>Si su kernel no reconoce todos sus puertos serie, probablemente necesitará configurar un kernel FreeBSD personalizado para su sistema. Para información detallada sobre configurar su kernel, por favor vea <a href=./#kernelconfig>Configuración del kernel de FreeBSD</a>.</p></div><div class=paragraph><p>Las líneas de dispositivo relevantes para su fichero de configuración del kernel podrín verse de esta manera, para FreeBSD 4.X:</p></div><div class="literalblock programlisting"><div class=content><pre>device		sio0	at isa? port IO_COM1 irq 4
device		sio1	at isa? port IO_COM2 irq 3
device		sio2	at isa? port IO_COM3 irq 5
device		sio3	at isa? port IO_COM4 irq 9</pre></div></div><div class=paragraph><p>y de esta manera, para FreeBSD 5.X:</p></div><div class="literalblock programlisting"><div class=content><pre>device		sio</pre></div></div><div class=paragraph><p>Puede comentar o remover completamente líneas de dispositivos que no tenga en el caso de FreeBSD 4.X; para FreeBSD 5.X tiene que editar su fichero <span class=filename>/boot/device.hints</span> para configurar sus puertos serie. Por favor diríjase a la página de manual <a href="https://man.freebsd.org/cgi/man.cgi?query=sio&amp;sektion=4&amp;format=html">sio(4)</a> para mayor información sobre puertos serie y configuración de tarjetas multipuertos. Tenga cuidado si está utilizando un fichero de configuración que fué usado anteriomente para una versión diferente de FreeBSD porque las banderas de dispositivo y la sintaxis han cambiado entre versiones.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p><code>port IO_COM1</code> es una substitución para <code>port 0x3f8</code>, <code>IO_COM2</code> es <code>0x2f8</code>, <code>IO_COM3</code> es <code>0x3e8</code>, y <code>IO_COM4</code> es <code>0x2e8</code>, las cuales son direcciones de puerto comunes para sus respectivos puertos serie; interrupciones 4,3,5 y 9 son peticiones comunes de líneas de interrupción. Note también que puertos serie regulares <em>no pueden</em> compartir interrupciones en PCs con bus ISA (las tarjetas multipuerto tienen electrónicos que les permiten a los 16550A’s compartir una o dos líneas de peticiones de interrupción).</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=_archivos_especiales_de_dispositivo>24.2.4. Archivos especiales de dispositivo<a class=anchor href=#_archivos_especiales_de_dispositivo></a></h4><div class=paragraph><p>La mayoría de dispositivos en el kernel son accesados a través de "ficheros especiales de dispositivo", los cuales están localizados en el directorio <span class=filename>/dev</span>. Los dispositivos <span class=filename>sio</span> son accesados a través de los dispositivos <span class=filename>/dev/ttydN</span> (dial-in) y <span class=filename>/dev/cuaaN</span> (call-out). FreeBSD provee también dispositivos de inicialización (<span class=filename>/dev/ttyidN</span> y <span class=filename>/dev/cuaiaN</span>) y dispositivos de bloqueo (<span class=filename>/dev/ttyldN</span> y <span class=filename>/dev/cualaN</span>). Los dispotivos de inicialización son utilizados para inicializar los parámetros de comunicación de puerto cada vez que un puerto es abierto, como <code>crtscts</code> para modems que utilizan señalización <code>RTS/CTS</code> para control de flujo. Los dispositivos de bloqueo son utilizados para bloquear banderas en puertos y prevenir que usuarios o programas cambien ciertos parámetros; vea las páginas de manual <a href="https://man.freebsd.org/cgi/man.cgi?query=termios&amp;sektion=4&amp;format=html">termios(4)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=sio&amp;sektion=4&amp;format=html">sio(4)</a>, y <a href="https://man.freebsd.org/cgi/man.cgi?query=stty&amp;sektion=1&amp;format=html">stty(1)</a> para información de las propiedades de terminales, bloqueo e inicialización de dispositivos y aplicación de opciones de terminal, respectivamente.</p></div><div class=sect4><h5 id=_creando_ficheros_de_dispositivo_especiales>24.2.4.1. Creando ficheros de dispositivo especiales<a class=anchor href=#_creando_ficheros_de_dispositivo_especiales></a></h5><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>FreeBSD 5.0 incluye el sistema de ficheros <a href="https://man.freebsd.org/cgi/man.cgi?query=devfs&amp;sektion=5&amp;format=html">devfs(5)</a> el cual crea automáticamente nodos de dispositivos según se necesiten. si está corriendo una versión de FreeBSD con <code>devfs</code> habilitado entonces puede saltarse esta sección.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Un script de shell llamado <code>MAKEDEV</code> en el directorio <span class=filename>/dev</span> administra los ficheros especiales de dispositivo. Para utilizar <code>MAKEDEV</code> para crear un fichero especial de dispositivo dial-up para <span class=filename>COM1</span> (port 0), <code>cd</code> a <span class=filename>/dev</span> y ejecute el comando <code>MAKEDEV ttyd0</code>. De la misma manera, para crear ficheros especiales de dispositivo para <span class=filename>COM2</span> (port 1), utilice <code>MAKEDEV ttyd1</code>.</p></div><div class=paragraph><p><code>MAKEDEV</code> no crea solamente el fichero especial de dispositivo <span class=filename>/dev/ttydN</span> también crea los nodos <span class=filename>/dev/cuaaN</span>, <span class=filename>/dev/cuaiaN</span>, <span class=filename>/dev/cualaN</span>, <span class=filename>/dev/ttyldN</span>, y <span class=filename>/dev/ttyidN</span>.</p></div><div class=paragraph><p>Despues de crear ficheros especiales de dispositivo nuevos, asegúrese de revisar los permisos en los ficheros (especialmente los ficheros <span class=filename>/dev/cua*</span>) para asegurarse que solamente los usuarios que deben tener acceso a esos ficheros especiales de dispositivo puedan leer y escribir en ellos - probablemente no desee permitir al usuario promedio utilizar sus modems para marcar al exterior. Los permisos por omisión en los ficheros <span class=filename>/dev/cua*</span> deberían ser suficientes:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>crw-rw----    1 uucp     dialer    28, 129 Feb 15 14:38 /dev/cuaa1
crw-rw----    1 uucp     dialer    28, 161 Feb 15 14:38 /dev/cuaia1
crw-rw----    1 uucp     dialer    28, 193 Feb 15 14:38 /dev/cuala1</code></pre></div></div><div class=paragraph><p>Estos permisos permiten al usuario <code>uucp</code> y usuarios en el grupo <code>dialer</code> utilizar dispositivos call-out.</p></div></div></div><div class=sect3><h4 id=serial-hw-config>24.2.5. Configuración de puerto serie<a class=anchor href=#serial-hw-config></a></h4><div class=paragraph><p>El dispositivo <span class=filename>ttydN</span> (o <span class=filename>cuaaN</span>) es el dispositivo regular que usted deseará abrir para sus aplicaciones. Cuando un proceso abre el dispositivo, tendrá un conjunto por omisión de propiedades de terminal E/S. Puede ver estas propiedades con el comando</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># stty -a -f /dev/ttyd1</span></code></pre></div></div><div class=paragraph><p>Cuando cambia las propiedades de este dispositivo, las propiedades son efectivas hasta que el dispositivo es cerrado. Cuando es reabierto regresa a las propiedades por omisión. Para realizar cambios al conjunto por omisión, usted puede abrir y ajustar las propiedades del dispositivo de "estado inicial" . Por ejemplo, para activar el modo <code>CLOCAL</code>, comunicación de 8 bits y control de flujo <code>XON/XOFF</code> por omisión para <span class=filename>ttyd5</span>, teclée:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># stty -f /dev/ttyid5 clocal cs8 ixon ixoff</span></code></pre></div></div><div class=paragraph><p>La inicialización para todo el sistema de los dispositivos serie es controlada en <span class=filename>/etc/rc.serial</span>. Este fichero afecta las propiedades por omisión de dispositivos serie.</p></div><div class=paragraph><p>Para prevenir que ciertas propiedades sean cambiadas por una aplicación, haga ajustes al dispositivo "bloquear estado". Por ejemplo, para confinar la velocidad en <span class=filename>ttyd5</span> a 57600 bps, teclée:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># stty -f /dev/ttyld5 57600</span></code></pre></div></div><div class=paragraph><p>Ahora, una aplicación que abra <span class=filename>ttyd5</span> y trate de cambiar la velocidad del puerto se mantendrá con 57600 bps.</p></div><div class=paragraph><p>Naturalmente, debería crear los dispositivos de estado inicial y bloqueo de estado escribible únicamente para la cuenta <code>root</code> .</p></div></div></div><div class=sect2><h3 id=term>24.3. Terminales<a class=anchor href=#term></a></h3><div class=paragraph><p>Las terminales proveen una manera conveniente y de bajo coste de accesar su sistema FreeBSD cuando no se encuentra en la consola de la computadora o en una red conectada. Esta sección describe como utilizar terminales con FreeBSD.</p></div><div class=sect3><h4 id=term-uses>24.3.1. Usos y tipos de terminales<a class=anchor href=#term-uses></a></h4><div class=paragraph><p>Los sistemas originales UNIX® no tenín consolas. En su lugar la gente se firmaba y corría programas a través de terminales conectadas a los puertos serie de la computadora. Es bastante similar a usar un modem y un programa de terminal para marcar hacia un sistema remoto para hacer trabajo en modo texto.</p></div><div class=paragraph><p>Las PCs actuales tienen consolas con gráficos de alta calidad, pero la habilidad para establecer una sesión en un puerto serie todavía existe en casi cualquier sistema operativo UNIX® al día de hoy; FreeBSD no es la excepción. Utilizando una terminal conectada a un puerto serie libre, usted puede accesar y correr cualquier programa de texto que podría correr normalmente en la consola o en una ventana <code>xterm</code> en el sistema X Window.</p></div><div class=paragraph><p>Para el usuario corporativo, se pueden conectar muchas terminales a un sistema FreeBSD y ponerlas en los escritorios de sus empleados. Para un usuario casero, una computadora de reserva, como una IBM PC más antigua o una Macintosh®, puede ser una terminal cableada a una computadora más poderosa corriendo FreeBSD. Puede convertir lo que de otra manera sería una computadora de un solo usuario en un poderoso sistema de usuarios múltiples.</p></div><div class=paragraph><p>Para FreeBSD, existen tres clases de terminales:</p></div><div class=ulist><ul><li><p><a href=#term-dumb>Terminales tontas</a></p></li><li><p><a href=#term-pcs>PCs actuando como terminales</a></p></li><li><p><a href=#term-x>Terminales X</a></p></li></ul></div><div class=paragraph><p>Las subsecciones siguientes describen cada tipo.</p></div><div class=sect4><h5 id=term-dumb>24.3.1.1. Terminales tontas<a class=anchor href=#term-dumb></a></h5><div class=paragraph><p>Terminales tontas son piezas de hardware especializadas que le permiten conectar a computadoras a través de líneas serie. Son llamadas "tontas" porque solo tienen poder computacional suficiente para desplegar, enviar y recibir texto. No puede ejecutar ningún programa en ellas. Es la computadora a la cual se conectan la que tiene todo el poder para correr editores de texto, compiladores, correo electrónico, juegos, y demás.</p></div><div class=paragraph><p>Existen cientos de tipos de terminales tontas hechas por muchos fabricantes, incluyendo VT-100 de Digital Equipment Corporation y WY-75 de Wyse. Cualquier tipo funcionará con FreeBSD. Algunas terminales superiores pueden incluso desplegar gráficos, pero solo ciertos paquetes de software pueden tomar ventaja de estas funciones avanzadas.</p></div><div class=paragraph><p>Las terminales tontas son populares en ambientes de trabajo donde los trabajadores no necesitan acceso a aplicaciones gráficas como las que provee el sistema X Window.</p></div></div><div class=sect4><h5 id=term-pcs>24.3.1.2. PCs actuando como terminales<a class=anchor href=#term-pcs></a></h5><div class=paragraph><p>Si una <a href=#term-dumb>terminal tonta</a> tiene apenas la habilidad para desplegar, enviar y recibir texto, entonces ciertamente cualquier computadora personal de reserva puede ser una terminal tonta. Todo lo que necesita es el cable apropiado y algún software de <em>emulación de terminal</em> para correr en la computadora.</p></div><div class=paragraph><p>Tal configuración es popular en hogares. Por ejemplo, si su consorte se encuentra ocupado trabajando en la consola de su sistema FreeBSD, usted puede realizar algún trabajo en modo texto al mismo tiempo desde una computadora personal menos poderosa conectada como una terminal al sistema FreeBSD.</p></div></div><div class=sect4><h5 id=term-x>24.3.1.3. Terminales X<a class=anchor href=#term-x></a></h5><div class=paragraph><p>Las terminales X son el tipo más sofisticado de terminal disponible. En lugar de conectar a un puerto serie, usualmente se conectan a una red como Ethernet. En lugar de ser relegadas a aplicaciones de modo texto pueden desplegar aplicaciones X.</p></div><div class=paragraph><p>Hemos introducido terminales X solo por complementar. Sin embargo, este capítulo <em>no</em> cubre instalación, configuración o uso de terminales X.</p></div></div></div><div class=sect3><h4 id=term-config>24.3.2. Configuración<a class=anchor href=#term-config></a></h4><div class=paragraph><p>Esta sección describe lo que necesita para configurar en su sistema FreeBSD y permitirle habilitar sesiones de entrada en una terminal. Asume que ya tiene configurado su kernel para soportar el puerto serie al cual la terminal está conectada-y que la tiene conectada.</p></div><div class=paragraph><p>Recuerde del <a href=./#boot>El proceso de arranque en FreeBSD</a> que el proceso <code>init</code> es responsable del control e inicialización de todos los procesos al inicio del sistema. Una de las tareas ejecutadas por <code>init</code> es leer el fichero <span class=filename>/etc/ttys</span> e iniciar un proceso <code>getty</code> en las terminales disponibles. El proceso <code>getty</code> es responsable de leer un nombre de entrada e iniciar el programa <code>login</code> .</p></div><div class=paragraph><p>Así, para configurar terminales para su sistema FreeBSD los siguientes pasos deben hacerse como <code>root</code>:</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Agregue una línea a <span class=filename>/etc/ttys</span> para la entrada en el directorio <span class=filename>/dev</span> para el puerto serie si todavía no se encuentra ahí.</p></li><li><p>Especifique que <code>/usr/libexec/getty</code> sea ejecutado en el puerto, y especifique el tipo apropiado de <em>getty</em> desde el fichero <span class=filename>/etc/gettytab</span> .</p></li><li><p>Especifique el tipo de terminal por omisión.</p></li><li><p>Ponga el puerto a "on."</p></li><li><p>Especifique si el puerto debe ser o no "seguro."</p></li><li><p>Obligue a <code>init</code> a releer el fichero <span class=filename>/etc/ttys</span> .</p></li></ol></div></div></div><div class=paragraph><p>Como un paso opcional, tal vez desee crear un tipo <em>getty</em> personalizado para utilizar en el paso 2 mediante una entrada en <span class=filename>/etc/gettytab</span>. Este capítulo no explica como realizarlo; por lo que se le exhorta a leer las páginas de manual <a href="https://man.freebsd.org/cgi/man.cgi?query=gettytab&amp;sektion=5&amp;format=html">gettytab(5)</a> y <a href="https://man.freebsd.org/cgi/man.cgi?query=getty&amp;sektion=8&amp;format=html">getty(8)</a> para mayor información.</p></div><div class=sect4><h5 id=term-etcttys>24.3.2.1. Agregando una entrada a <span class=filename>/etc/ttys</span><a class=anchor href=#term-etcttys></a></h5><div class=paragraph><p>El fichero <span class=filename>/etc/ttys</span> lista todos los puertos en su sistema FreeBSD donde quiere permitir logins. Por ejemplo, la primera consola virtual <span class=filename>ttyv0</span> tiene una entrada en este fichero. Puede firmarse en la consola utilizando esta entrada. Este fichero también contiene entradas para las otras consolas virtuales, puertos serie y pseudo-ttys. Para una terminal conectada por cable, solo liste la entrada <span class=filename>/dev</span> del puerto serie sin la parte de <span class=filename>/dev</span> (por ejemplo, <span class=filename>/dev/ttyv0</span> debería estar listado como <span class=filename>ttyv0</span>).</p></div><div class=paragraph><p>Una instalación por omisión de FreeBSD incluye un fichero <span class=filename>/etc/ttys</span> con soporte para los primeros cuatro puertos serie: <span class=filename>ttyd0</span> hasta <span class=filename>ttyd3</span>. Si está conectando una terminal a uno de esos puertos, no necesita agregar otra entrada.</p></div><div id=ex-etc-ttys class=exampleblock><div class=title>Ejemplo 31. Agregando entradas de terminal a <span class=filename>/etc/ttys</span></div><div class=content><div class=paragraph><p>Suponga que quisiéramos conectar dos terminales al sistema: una Wyse-50 y una vieja IBM PC 286 corriendo el software de terminal Procomm emulando una terminal VT-100. Conectamos la Wyse al segundo puerto serie y la 286 al sexto puerto serie (un puerto en una tarjeta multipuerto serie). Las entradas correspondiente en el fichero <span class=filename>/etc/ttys</span> se verían como esto:</p></div><div class="literalblock programlisting"><div class=content><pre>ttyd1  &#34;/usr/libexec/getty std.38400&#34;  wy50  on  insecure
ttyd5   &#34;/usr/libexec/getty std.19200&#34;  vt100  on  insecure</pre></div></div><div class=ulist><ul><li><p>El primer campo normalmente especifica el nombre de fichero especial de la terminal como es hallado en <span class=filename>/dev</span>.</p></li><li><p>El segundo campo es el comando a ejecutar por esta línea, el cual es usualmente <a href="https://man.freebsd.org/cgi/man.cgi?query=getty&amp;sektion=8&amp;format=html">getty(8)</a>. <code>getty</code> inicializa y abre la línea, establece la velocidad, pregunta por un nombre de usuario y entonces ejecuta el programa <a href="https://man.freebsd.org/cgi/man.cgi?query=login&amp;sektion=1&amp;format=html">login(1)</a> .El programa <code>getty</code> acepta un parámetro (opcional) en su línea de comando, el tipo <em>getty</em>. Un tipo <em>getty</em> configura características en la línea de terminal, como tasa de bps y paridad. El programa <code>getty</code> lee estas características desde el fichero <span class=filename>/etc/gettytab</span>.El fichero <span class=filename>/etc/gettytab</span> contiene muchas entradas para líneas de terminal viejas y nuevas. En la mayoría de los casos, las entradas que empiezan con el texto <code>std</code> funcionarán para terminales conectadas físicamente. Estas entradas ignoran la paridad. Existe una entrada <code>std</code> por cada tasa de bps de 110 a 115200. Por supuesto puede agregar sus propias entradas a este fichero. La página de manual <a href="https://man.freebsd.org/cgi/man.cgi?query=gettytab&amp;sektion=5&amp;format=html">gettytab(5)</a> provee mayor información.Al establecer el tipo <em>getty</em> en el fichero <span class=filename>/etc/ttys</span>, asegúrese que las propiedades de comunicaciones en la terminal concuerden.Para nuestro ejemplo, la Wyse-50 no usa paridad y conecta a 38400 bps. La 286 PC no usa paridad y conecta a 19200 bps.</p></li><li><p>El tercer campo es el tipo de terminal usualmente conectado a esa línea tty. Para puertos dial-up, <code>unknown</code> o <code>dialup</code> son usados típicamente en este campo puesto que los usuarios pueden marcar prácticamente con cualquier tipo de terminal o de software. Para terminales conectadas físicamente, el tipo de terminal no cambia, así que puede poner un tipo de terminal real del fichero de base de datos <a href="https://man.freebsd.org/cgi/man.cgi?query=termcap&amp;sektion=5&amp;format=html">termcap(5)</a> en este campo.Para nuestro ejemplo, la Wyse-50 utiliza el tipo de terminal real mientras que la PC 286 corriendo Procomm será puesta a emular una VT-100.</p></li><li><p>El cuarto campo especifica si el puerto debe habilitarse. Poniendo <code>on</code> aquí provocará que el proceso <code>init</code> inicie el programa en el segundo campo, <code>getty</code>. Si pone <code>off</code> en este campo, no habrá <code>getty</code>, y por consecuencia ningun login en el puerto.</p></li><li><p>El último campo es utilizado para especificar si el puerto es seguro. Marcar un puerto como seguro significa que se confía en él lo suficiente para permitir que la cuenta <code>root</code> (o cualquier cuenta con un ID de usuario 0) se firme desde ese puerto. Los puertos inseguros no permiten entradas de <code>root</code>. En un puerto inseguro, los usuarios deben firmarse desde cuentas sin privilegios y entonces utilizar <a href="https://man.freebsd.org/cgi/man.cgi?query=su&amp;sektion=1&amp;format=html">su(1)</a> o un mecanismo similar para acceder a privilegios de superusuario.Es altamente recomendable que utilize "insecure" incluso para terminales que se encuentran detrás de puertas con llave. Es muy sencillo entrar y usar <code>su</code> si necesita privilegios de superusuario.</p></li></ul></div></div></div></div><div class=sect4><h5 id=term-hup>24.3.2.2. Forzar <code>init</code> a que relea <span class=filename>/etc/ttys</span><a class=anchor href=#term-hup></a></h5><div class=paragraph><p>Despues de realizar los cambios necesarios al fichero <span class=filename>/etc/ttys</span> debería mandar una señal SIGHUP (hangup) al proceso <code>init</code> para forzarlo a releer su fichero de configuración. Por ejemplo:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kill -HUP 1</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p><code>init</code> siempre es el primer proceso que corre en un sistema, por lo tanto siempre tendrá el PID 1.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Si todo está puesto correctamente, todos los cables en su lugar, y las terminales están encendidas, entonces un proceso <code>getty</code> debe estar corriendo en cada terminal y debería ver prompts de entrada en sus terminales en este punto.</p></div></div></div><div class=sect3><h4 id=term-debug>24.3.3. Determinando errores en su conexión<a class=anchor href=#term-debug></a></h4><div class=paragraph><p>Incluso con la más meticulosa etención al detalle, algo puede salir mal mientras se configura una terminal. Esta es una lista de síntomas y algunos arreglos sugeridos.</p></div><div class=sect4><h5 id=_no_aparece_prompt_de_login>24.3.3.1. No aparece prompt de login<a class=anchor href=#_no_aparece_prompt_de_login></a></h5><div class=paragraph><p>Asegúrese que la terminal está conectada y encendida, asegúrese que se encuentra ejecutando un software de emulación de terminal en el puerto serie correcto.</p></div><div class=paragraph><p>Asegúrese que el cable está conectado firmemente tanto a la terminal como a la computadora FreeBSD. Asegúrese que es el tipo correcto de cable.</p></div><div class=paragraph><p>Asegúrese que la terminal y FreeBSD concuerdan en la tasa de bps y propiedades de paridad. Si tiene una terminal de desplegado de video, asegúrese que los controles de contraste y brillo estén encendidos. Si es una terminal de impresión, asegúrese que papel y tinta se encuentren en forma.</p></div><div class=paragraph><p>Asegúrese que un proceso <code>getty</code> esté corriendo y sirviendo la terminal. Por ejemplo, para obtener una lista de procesos <code>getty</code> con <code>ps</code>, teclée:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ps -axww|grep getty</span></code></pre></div></div><div class=paragraph><p>Debería ver una entrada para la terminal. Por ejemplo, el siguiente desplegado muestra que un <code>getty</code> está corriendo en el segundo puerto serie <code>ttyd1</code> y está utilizando la entrada <code>std.38400</code> en <span class=filename>/etc/gettytab</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>22189  d1  Is+    0:00.03 /usr/libexec/getty std.38400 ttyd1</code></pre></div></div><div class=paragraph><p>Si no hay un proceso <code>getty</code> corriendo, asegúrese que tiene habilitado el puerto en <span class=filename>/etc/ttys</span>. Recuerde también ejecutar <code>kill -HUP 1</code> despues de modificar el fichero <span class=filename>ttys</span>.</p></div><div class=paragraph><p>Si el proceso <code>getty</code> está corriendo pero la terminal todavía no despliega un prompt de login, o si despliega un prompt pero no le permite escribir, su terminal o cable tal vez no soporte inicialización por hardware. Trate cambiar la entrada en <span class=filename>/etc/ttys</span> de <code>std.38400</code> a <code>3wire.38400</code> recuerde correr <code>kill -HUP 1</code> despues de modificar <span class=filename>/etc/ttys</span>. La entrada <code>3wire</code> es similar a <code>std</code>, pero ignora la inicialización por harware. Tal vez necesite reducir la tasa de baudios o habilitar control de flujo por software cuando utilice <code>3wire</code> para prevenir desbordamientos de buffer.</p></div></div><div class=sect4><h5 id=_si_aparece_basura_en_lugar_de_un_prompt_de_login>24.3.3.2. Si aparece basura en lugar de un prompt de login<a class=anchor href=#_si_aparece_basura_en_lugar_de_un_prompt_de_login></a></h5><div class=paragraph><p>Asegúrese que la terminal y FreeBSD concuerdan en la tasa de bps y propiedades de paridad. Revise los procesos <code>getty</code> para asegurarse que el tipo correcto de <em>getty</em> está en uso. Si no es así, edite <span class=filename>/etc/ttys</span> y ejecute <code>kill -HUP 1</code>.</p></div></div><div class=sect4><h5 id=_los_caracteres_aparecen_doble_las_contraseñas_aparecen_cuando_se_escriben>24.3.3.3. Los caracteres aparecen doble; las contraseñas aparecen cuando se escriben<a class=anchor href=#_los_caracteres_aparecen_doble_las_contraseñas_aparecen_cuando_se_escriben></a></h5><div class=paragraph><p>Cambie la terminal (o el software de emulación de terminal) de "half duplex" o "local echo" a "full duplex."</p></div></div></div></div><div class=sect2><h3 id=dialup>24.4. Servicio dial-in<a class=anchor href=#dialup></a></h3><div class=paragraph><p>Configurar su sistema FreeBSD para servicio dial-in es muy similar a conectar terminales excepto que en lugar de lidiar con terminales se hace con modems.</p></div><div class=sect3><h4 id=_modems_externos_vs_internos>24.4.1. Modems externos vs. internos<a class=anchor href=#_modems_externos_vs_internos></a></h4><div class=paragraph><p>Los modems externos parecen ser más convenientes para dial-up, debido a que los modems externos con frecuencia pueden ser configurados semi permanentemente vía parámetros almacenados en RAM no volatil y usualmente proveen indicadores luminosos que despliegan el estado de señales importantes RS-232. Luces parpadeantes impresionan a los visitantes, pero las luces son también útiles para ver si un modem se encuentra operando adecuádamente.</p></div><div class=paragraph><p>Los modems internos usualmente carecen de RAM no volatil, entonces su configuración puede estar limitada a especificar DIP switches. Si su modem interno cuenta con algún indicador luminoso de señales, es probablemente dificil observar las luces cuando el sistema está cubierto y en su lugar.</p></div><div class=sect4><h5 id=_modems_y_cables>24.4.1.1. Modems y cables<a class=anchor href=#_modems_y_cables></a></h5><div class=paragraph><p>Si se encuentra utilizando un modem externo, entonces necesitará por supuesto un cable adecuado. Un cable serie estándar RS-232C debe ser suficiente mientras todas las señales normales sean cableadas:</p></div><div class=ulist><ul><li><p>Transmitted Data (TD)</p></li><li><p>Received Data (RD)</p></li><li><p>Request to Send (RTS)</p></li><li><p>Clear to Send (CTS)</p></li><li><p>Data Set Ready (DSR)</p></li><li><p>Data Terminal Ready (DTR)</p></li><li><p>Carrier Detect (CD)</p></li><li><p>Signal Ground (SG)</p></li></ul></div><div class=paragraph><p>FreeBSD necesita las señales RTS y CTS para control de flujo a velocidades mayores a 2400 bps, la señal CD para detectar cuando una llamada ha sido respondida o la línea ha sido colgada, y la señal DTR para reiniciar el modem despues de completar una sesión. Algunos cables son hechos sin incluir todas las señales necesarias, así que si tiene problemas, como cuando una sesión no finaliza cuando la línea es colgada, tal vez el problema se deba al cable.</p></div><div class=paragraph><p>Como otros sistemas operativos tipo UNIX®, FreeBSD utiliza las señales de hardware para saber cuando una llamada ha sido contestada o una línea ha sido colgada y poder colgar y reiniciar el modem despues de una llamada. FreeBSD evita enviar comandos al modem o esperar por reportes de estado del modem. Si está familiarizado con la conexión de modems una PC funcionando como BBS, tal ves esto parezca extraño.</p></div></div></div><div class=sect3><h4 id=_consideraciones_de_interfaces_serie>24.4.2. Consideraciones de interfaces serie<a class=anchor href=#_consideraciones_de_interfaces_serie></a></h4><div class=paragraph><p>FreeBSD soporta interfaces de comunicación NS8250-, NS16450-, NS16550-, y NS16550A-basado en EIA RS-232C (CCITT V.24). Los dispositivos 8250 y 16450 tienen buffers de un solo caracter. El dispositivo 16550 brinda un buffer de 16 caracteres, el cual permite un mejor desempeño del sistema. (Errores en 16550 simple impiden el uso del buffer de 16 caracteres, así que utilice 16550A si es posible). Debido a que los dispositivos de buffer de un solo caracter requieren más trabajo del sistema operativo que los dispotivos de buffer de 16 caracteres, las tarjetas de interfaz serie basadas en 16550A son mayormente preferidas. Si el sistema tiene muchos puertos serie activos o tendrá una carga elevada, las tarjetas basadas en 16550A son mejores para comunicaciones con baja tasa de error.</p></div></div><div class=sect3><h4 id=_revisión_rápida>24.4.3. Revisión rápida<a class=anchor href=#_revisión_rápida></a></h4><div class=paragraph><p>Como con las terminales, <code>init</code> engendra un proceso <code>getty</code> para cada puerto serie configurado para conexiones dial-in. Por ejemplo, si un modem está conectado a <span class=filename>/dev/ttyd0</span>, el comando <code>ps ax</code> podría mostrar esto:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>4850 ??  I      0:00.09 /usr/libexec/getty V19200 ttyd0</code></pre></div></div><div class=paragraph><p>Cuando un usuario marca la línea del modem y el modem conecta, la línea CD (Carrier Detect) es reportada por el modem. El kernel nota que se ha detectado una portadora y completa la apertura de <code>getty</code> del puerto. <code>getty</code> manda un prompt <code>login:</code> a la velocidad inicial de línea especificada. <code>getty</code> observa si se reciben caracteres válidos, y, en una configuración típica, si encuentra basura (probablemente debido a que la velocidad de conexión del modem es diferente a la velocidad de <code>getty</code>), <code>getty</code> trata de ajustar la velocidad de la línea hasta que recibe caracteres razonables.</p></div><div class=paragraph><p>Despues que el usuario entra su nombre de login, <code>getty</code> ejecuta <span class=filename>/usr/bin/login</span>, que completa la entrada preguntando por la contraseña del usuario y entonces inicia el shell del usuario.</p></div></div><div class=sect3><h4 id=_archivos_de_configuración>24.4.4. Archivos de configuración<a class=anchor href=#_archivos_de_configuración></a></h4><div class=paragraph><p>Existen tres ficheros de configuración del sistema en el directorio <span class=filename>/etc</span> que probablemente necesitará editar para permitir acceso de dial-up a su sistema FreeBSD. El primero, <span class=filename>/etc/gettytab</span>, contiene información de configuración para el daemon <span class=filename>/usr/libexec/getty</span>. El segundo, <span class=filename>/etc/ttys</span> contiene información que le dice a <span class=filename>/sbin/init</span> que dispositivos <span class=filename>tty</span> deben tener procesos <code>getty</code> corriendo. Por último, puede incluir comandos de inicialización de puerto en el script <span class=filename>/etc/rc.serial</span>.</p></div><div class=paragraph><p>Existen dos escuelas de pensamiento en relación a modems dial-up en UNIX®. Un grupo gusta de configurar sus modems y sistemas para que sin importar a que velocidad un usuario remoto marque, la interfaz local RS-232 computadora-a-modem corra a una velocidad fija. El beneficio de esta configuración es que el usuario remoto siempre obtiene un prompt de login del sistema inmediátamente. La desventaja es que el sistema no sabe cual es la tasa de datos verdadera del usuario, así que programas a pantalla completa como Emacs no ajustarán sus métodos de dibujado de pantalla para mejorar sus respuestas en conexiones más lentas.</p></div><div class=paragraph><p>La otra escuela configura sus modems de interfaz RS-232 para variar su velocidad basado en la velocidad de conexión del usuario remoto. Por ejemplo, conexiones V.32bis (14.4 Kbps) al modem podrían hacer al modem correr su interfaz RS-232 a 19.2 Kbps, mientras que conexiones 2400 bps hacen correr la interfaz RS-232 del modem a 2400 bps. Debido a que <code>getty</code> no entiende el reporte de velocidad de conexión de cualquier modem, <code>getty</code> brinda un mensaje <code>login:</code> a una velocidad inicial y observa los caracteres que regresan en respuesta. Si el usuario recibe basura, se asume que sabe que debe presionar la tecla <kbd>Enter</kbd> hasta que reciba un prompt reconocible. Si la tasa de datos no concuerda, <code>getty</code> trata todo lo que el usuario escriba como "basura", trata yendo a la siguiente velocidad y brinda el prompt <code>login:</code> de nuevo. Este procedimiento puede continuar hasta el cansancio, pero normalmente solo toma un teclazo o dos antes que el usuario reciba un prompt correcto. Obviamente, esta secuencia de login no parece tan limpia como el anterior método de "velocidad fija", pero un usuario en una conexión de velocidad baja podría recibir una respuesta interactiva mejor desde programas a pantalla completa.</p></div><div class=paragraph><p>Esta sección tratará de dar información de configuración balanceada, pero está cargada hacia tener la tasa de datos del modem siguiendo la tasa de conexión.</p></div><div class=sect4><h5 id=_etcgettytab>24.4.4.1. <span class=filename>/etc/gettytab</span><a class=anchor href=#_etcgettytab></a></h5><div class=paragraph><p><span class=filename>/etc/gettytab</span> es un fichero tipo <a href="https://man.freebsd.org/cgi/man.cgi?query=termcap&amp;sektion=5&amp;format=html">termcap(5)</a> de información de configuración para <a href="https://man.freebsd.org/cgi/man.cgi?query=getty&amp;sektion=8&amp;format=html">getty(8)</a>. Por favor vea la página de manual <a href="https://man.freebsd.org/cgi/man.cgi?query=gettytab&amp;sektion=5&amp;format=html">gettytab(5)</a> para información completa del formato del fichero y la lista de capacidades.</p></div><div class=sect5><h6 id=_configuración_de_velocidad_fija>24.4.4.1.1. Configuración de velocidad fija<a class=anchor href=#_configuración_de_velocidad_fija></a></h6><div class=paragraph><p>Si está fijando la tasa de comunicación de datos de su modem a una velocidad particular, probablemente no necesitará ningún cambio a <span class=filename>/etc/gettytab</span>.</p></div></div><div class=sect5><h6 id=_configuración_de_velocidad_concordante>24.4.4.1.2. Configuración de velocidad concordante<a class=anchor href=#_configuración_de_velocidad_concordante></a></h6><div class=paragraph><p>Necesitará crear una entrada en <span class=filename>/etc/gettytab</span> para darle información a <code>getty</code> acerca de las velocidades que desea usar para su modem. Si tiene un modem 2400 bps, puede probablemente utilizar la entrada existente <code>D2400</code>.</p></div><div class="literalblock programlisting"><div class=content><pre>#
# Fast dialup terminals, 2400/1200/300 rotary (can start either way)
#
D2400|d2400|Fast-Dial-2400:\
        :nx=D1200:tc=2400-baud:
3|D1200|Fast-Dial-1200:\
        :nx=D300:tc=1200-baud:
5|D300|Fast-Dial-300:\
        :nx=D2400:tc=300-baud:</pre></div></div><div class=paragraph><p>Si tiene un modem de mayor velocidad, probablemente necesite agregar una entrada en <span class=filename>/etc/gettytab</span>; aquí está una entrada que puede utilizar para un modem 14.4 Kbps con una velociad de interfaz máxima de 19.2 Kbps:</p></div><div class="literalblock programlisting"><div class=content><pre>#
# Additions for a V.32bis Modem
#
um|V300|High Speed Modem at 300,8-bit:\
        :nx=V19200:tc=std.300:
un|V1200|High Speed Modem at 1200,8-bit:\
        :nx=V300:tc=std.1200:
uo|V2400|High Speed Modem at 2400,8-bit:\
        :nx=V1200:tc=std.2400:
up|V9600|High Speed Modem at 9600,8-bit:\
        :nx=V2400:tc=std.9600:
uq|V19200|High Speed Modem at 19200,8-bit:\
        :nx=V9600:tc=std.19200:</pre></div></div><div class=paragraph><p>esto resultará en una conexión de 8 bits, sin paridad.</p></div><div class=paragraph><p>El ejemplo de arriba inicia la tasa de comunicaciones a 19.2 Kbps (para conexiones V.32bis), entonces cicla a través de 9600 bps (para V.32), 2400 bps, 1200 bps, 300 bps, y de vuelta a 19.2 Kbps. El ciclado de la tasa de comunicaciones es implementado con la capacidad <code>nx=</code> ("siguiente tabla"). Cada una de las líneas usa una entrada <code>tc=</code> ("continuación de tabla") para recoger el resto de las propiedades "estándar" para una tasa de datos en particular.</p></div><div class=paragraph><p>Si tiene un modem 28.8 Kbps y/o quiere tomar ventaja de la compresión en un modem 14.4 Kbps, necesita utilizar una tasa de comunicaciones mayor a 19.2 Kbps. Aquí hay un ejemplo de una entrada <span class=filename>gettytab</span> iniciando a 57.6 Kbps:</p></div><div class="literalblock programlisting"><div class=content><pre>#
# Additions for a V.32bis or V.34 Modem
# Starting at 57.6 Kbps
#
vm|VH300|Very High Speed Modem at 300,8-bit:\
        :nx=VH57600:tc=std.300:
vn|VH1200|Very High Speed Modem at 1200,8-bit:\
        :nx=VH300:tc=std.1200:
vo|VH2400|Very High Speed Modem at 2400,8-bit:\
        :nx=VH1200:tc=std.2400:
vp|VH9600|Very High Speed Modem at 9600,8-bit:\
        :nx=VH2400:tc=std.9600:
vq|VH57600|Very High Speed Modem at 57600,8-bit:\
        :nx=VH9600:tc=std.57600:</pre></div></div><div class=paragraph><p>Si tiene un CPU lento o un sistema muy cargado y no tiene puertos serie basados en 16550A, tal vez reciba errores en <code>sio</code> "silo" a 57.6 Kbps.</p></div></div></div><div class=sect4><h5 id=dialup-ttys>24.4.4.2. <span class=filename>/etc/ttys</span><a class=anchor href=#dialup-ttys></a></h5><div class=paragraph><p>La configuración del fichero <span class=filename>/etc/ttys</span> fué cubierto en <a href=#ex-etc-ttys>Agregando entradas de terminal a <span class=filename>/etc/ttys</span></a>. La configuración para modems es similar pero debemos pasar un argumento diferente a <code>getty</code> y especificar un tipo diferente de terminal. El formato general tanto para configuración de velocidad fija y velocidad concordante es:</p></div><div class="literalblock programlisting"><div class=content><pre>ttyd0   &#34;/usr/libexec/getty xxx&#34;   dialup on</pre></div></div><div class=paragraph><p>El primer componente de la línea de arriba es el fichero de dispositivo especial para esta entrada - <code>ttyd0</code> significa que <span class=filename>/dev/ttyd0</span> es el fichero que <code>getty</code> estará vigilando. El segundo componente <code>"/usr/libexec/getty xxx"</code> (<em>xxx</em> será reemplazado por la capacidad inicial de <span class=filename>gettytab</span>) es el proceso que <code>init</code> ejecutará en el dispositivo. El tercer componente, <code>dialup</code>, es el tipo de terminal por omisión. El cuarto parámetro, <code>on</code>, le indica a <code>init</code> que la línea es operacional. Puede existir un quinto parámetro, <code>secure</code>, pero solo debería ser utilizado para terminales que estén físicamente seguras (como la consola del sistema).</p></div><div class=paragraph><p>El tipo de terminal por omisión (<code>dialup</code> en el ejemplo de arriba) puede depender de preferencias locales. <code>dialup</code> es el tipo de terminal tradicional por omisión en líneas dial-up para que los usuarios puedan personalizar sus scripts de login para reconocer cuando la terminal es <code>dialup</code> y ajustar sus tipos de terminal automáticamente. De toda maneras, el autor encuentra más sencillo especificar en su sitio <code>vt102</code> como el tipo de terminal por omisión, puesto que los usuarios solo utilizan emulación VT102 en sus sistemas remotos.</p></div><div class=paragraph><p>Despues de realizar los cambios a <span class=filename>/etc/ttys</span>, puede enviar al proceso <code>init</code> una señal HUP para que relea el fichero. Puede utilizar el comando</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kill -HUP 1</span></code></pre></div></div><div class=paragraph><p>para mandar la señal. Si esta es su primera vez instalando el sistema, tal vez quiera esperar hasta que su(s) modem(s) estén configurados y conectados correctamente antes de señalizar a <code>init</code>.</p></div><div class=sect5><h6 id=_configuración_de_velocidad_fija_2>24.4.4.2.1. Configuración de velocidad fija<a class=anchor href=#_configuración_de_velocidad_fija_2></a></h6><div class=paragraph><p>Para una configuración de velocidad fija, su entrada <span class=filename>ttys</span> necesita tener una entrada de velocidad fija provista en <code>getty</code>. Para un modem cuya velocidad de puerto está fijada en 19.2 Kbps, la entrada <span class=filename>ttys</span> podría verse así:</p></div><div class="literalblock programlisting"><div class=content><pre>ttyd0   &#34;/usr/libexec/getty std.19200&#34;   dialup on</pre></div></div><div class=paragraph><p>Si su modem está fijado a un velocidad de datos diferente, sustituya el valor apropiado por <code>std.velocidad</code> en lugar de <code>std.19200</code>. Asegúrese de usar un tipo válido listado en <span class=filename>/etc/gettytab</span>.</p></div></div><div class=sect5><h6 id=_configuración_de_velocidad_concordante_2>24.4.4.2.2. Configuración de velocidad concordante<a class=anchor href=#_configuración_de_velocidad_concordante_2></a></h6><div class=paragraph><p>En una configuración de velocidad concordante su entrada <span class=filename>ttys</span> necesita referenciar el inicio de la entrada "auto-baud" (sic) en <span class=filename>/etc/gettytab</span>. Por ejemplo, si agregó la entrada sugerida arriba para un modem con velocidad concordante que inicia a 19.2 Kbps (la entrada <span class=filename>gettytab</span> conteniendo el punto de inicio <code>V19200</code>), su entrada <span class=filename>ttys</span> podría verse como esta:</p></div><div class="literalblock programlisting"><div class=content><pre>ttyd0   &#34;/usr/libexec/getty V19200&#34;   dialup on</pre></div></div></div></div><div class=sect4><h5 id=_etcrc_serial>24.4.4.3. <span class=filename>/etc/rc.serial</span><a class=anchor href=#_etcrc_serial></a></h5><div class=paragraph><p>Modems de alta velocidad, como V.32, V.32bis, y V.34, necesitan usar control de flujo por hardware (<span class=filename>RTS/CTS</span>). Puede agregar comandos <code>stty</code> a <span class=filename>/etc/rc.serial</span> para activar la bandera de control de flujo por hardware en el kernel de FreeBSD para los puertos del modem.</p></div><div class=paragraph><p>Por ejemplo para activar la bandera <code>termios crtscts</code> de dispositivos de inicialización dial-in y dial-out en el puerto serie #1 (<span class=filename>COM2</span>), las siguientes líneas pueden agregarse a <span class=filename>/etc/rc.serial</span>:</p></div><div class="literalblock programlisting"><div class=content><pre># Serial port initial configuration
stty -f /dev/ttyid1 crtscts
stty -f /dev/cuaia1 crtscts</pre></div></div></div></div><div class=sect3><h4 id=_propiedades_del_modem>24.4.5. Propiedades del modem<a class=anchor href=#_propiedades_del_modem></a></h4><div class=paragraph><p>Si tiene un modem cuyos parámetros pueden ser activados permanentemente en RAM no volatil, necesitará utilizar un programa de terminal (como Telix en MS-DOS® o <code>tip</code> en FreeBSD) para activar los parámetros. Conecte al modem usando la misma velocidad de comunicación como velocidad inicial que <code>getty</code> usará y configure la RAM no volatil del modem para que concuerde con estos requerimientos:</p></div><div class=ulist><ul><li><p>CD activado cuando esté conectado</p></li><li><p>DTR activado para operación; tirar DTR cuelga la línea y reinicia el modem</p></li><li><p>CTS control de flujo de datos transmitidos</p></li><li><p>Deshabilitar control de flujo XON/XOFF</p></li><li><p>RTS control de flujo de datos recibidos</p></li><li><p>Modo silencioso (sin códigos resultantes)</p></li><li><p>Sin eco de comandos</p></li></ul></div><div class=paragraph><p>Por favor lea la documentación de su modem para saber que comandos y/o switches DIP necesita proporcionarle.</p></div><div class=paragraph><p>Pro ejemplo, para activar los parámetros de arriba en un modem U.S. Robotics® Sportster® 14,400 externo, uno podría dar estos comandos al modem:</p></div><div class="literalblock programlisting"><div class=content><pre>ATZ
ATC1D2H1I0R2W</pre></div></div><div class=paragraph><p>Tal vez quiera también tomar esta oportunidad para ajustar otras propiedades en el modem, como si utilizará compresión V.42bis y/o MNP5.</p></div><div class=paragraph><p>El modem U.S. Robotics® Sportster® 14,400 externo también posee switches DIP que necesitan activarse; para otros modems, tal vez pueda utilizar estas propiedades como un ejemplo:</p></div><div class=ulist><ul><li><p>Switch 1: ARRIBA - DTR Normal</p></li><li><p>Switch 2: N/A (Códigos resultantes verbales/Códigos resultantes numéricos)</p></li><li><p>Switch 3: ARRIBA - Suprimir códigos resultantes</p></li><li><p>Switch 4: ABAJO - No eco, comandos offline</p></li><li><p>Switch 5: ARRIBA - Auto respuesta</p></li><li><p>Switch 6: ARRIBA - Detección de señal Normal</p></li><li><p>Switch 7: ARRIBA - Cargar valores NVRAM por omisión</p></li><li><p>Switch 8: N/A (Modo inteligente/Modo tonto)</p></li></ul></div><div class=paragraph><p>Códigos resultantes deberían ser deshabilitados o suprimidos para modems dial-up para evitar problemas que pueden ocurrir si <code>getty</code> erroneamente ofrece un prompt <code>login:</code> a un modem que se encuentra en modo de comandos y el modem hace eco del comando o regresa un código resultante. Esta secuencia puede resultar en una conversación larga y tonta entre <code>getty</code> y el modem.</p></div><div class=sect4><h5 id=_configuración_de_velocidad_fija_3>24.4.5.1. Configuración de velocidad fija<a class=anchor href=#_configuración_de_velocidad_fija_3></a></h5><div class=paragraph><p>Para una configuración de velocidad fija necesitará configurar el modem para mantener una tasa de datos constante modem-a-computadora independiente de la tasa de comunicaciones. En un modem U.S. Robotics® Sportster® 14,400 externo estos comandos fijarán la tasa de datos modem-a-computadora a la velocidad utilizada para pasar los comandos:</p></div><div class="literalblock programlisting"><div class=content><pre>ATZ
ATB1W</pre></div></div></div><div class=sect4><h5 id=_configuración_de_velocidad_concordante_3>24.4.5.2. Configuración de velocidad concordante<a class=anchor href=#_configuración_de_velocidad_concordante_3></a></h5><div class=paragraph><p>Para una configuración de velocidad variable necesitará configurar su modem para ajustar la tasa de datos de su puerto serie para que coincida con la tasa de llamada entrante. En un modem U.S. Robotics® Sportster® 14,400 externo estos comandos fijarán la tasa de corrección de errores de datos a la velocidad usada para pasar los comandos, pero le permite a la tasa del puerto serie variar para conexiones que no corrigen errores:</p></div><div class="literalblock programlisting"><div class=content><pre>ATZ
ATB2W</pre></div></div></div><div class=sect4><h5 id=_revisando_la_configuración_del_modem>24.4.5.3. Revisando la configuración del modem<a class=anchor href=#_revisando_la_configuración_del_modem></a></h5><div class=paragraph><p>La mayoría de los modems de alta velocidad brindan comandos para ver los parámetros actuales de operación del modem en un modo entendible para humanos. En el modem U.S. Robotics® Sportster® 14,400 externo, el comando <code>ATI5</code> despliega los parámetros que están almacenados en la RAM no volatil. Para ver los parámetros reales de operación del modem (influenciado por los parámetros de los switches DIP del modem), utilice el comando <code>ATZ</code> y entonces <code>ATI4</code>.</p></div><div class=paragraph><p>Si tiene una marca diferente de modem, revise el manual de su modem para ver como checar doblemente los parámetros de configuración de su modem.</p></div></div></div><div class=sect3><h4 id=_determinando_errores>24.4.6. Determinando errores<a class=anchor href=#_determinando_errores></a></h4><div class=paragraph><p>Aquí hay unos cuantos pasos que puede seguir para revisar en sus sistema el modem dial-up.</p></div><div class=sect4><h5 id=_revisando_el_sistema_freebsd>24.4.6.1. Revisando el sistema FreeBSD<a class=anchor href=#_revisando_el_sistema_freebsd></a></h5><div class=paragraph><p>Conecte su modem a su sistema FreeBSD, arranque el sistema, y, si su modem tiene luces de indicación de estado, mire si el indicador DTR del modem enciende cuando el prompt <code>login:</code> aparece en la consola del sistema - si enciende, eso debería significar que FreeBSD ha iniciado un proceso <code>getty</code> en el puerto de comunicaciones apropiado y está esperando a que el modem acepte la llamada.</p></div><div class=paragraph><p>Si el indicador DTR no enciende, entre al sistema FreeBSD a travás de la consola y ponga un <code>ps ax</code> para ver si FreeBSD está tratando de correr un proceso <code>getty</code> en el puerto correcto. Debería ver líneas como estas entre los procesos desplegados:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>  114 ??  I      0:00.10 /usr/libexec/getty V19200 ttyd0
  115 ??  I      0:00.10 /usr/libexec/getty V19200 ttyd1</code></pre></div></div><div class=paragraph><p>Si ve algo diferente, como esto:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>  114 d0  I      0:00.10 /usr/libexec/getty V19200 ttyd0</code></pre></div></div><div class=paragraph><p>y el modem no ha aceptado una llamada todavía, esto significa que <code>getty</code> ha completado su apertura en el puerto de comunicaciones. Esto puede indicar un problema con el cableado o un modem mal configurado, debido a que <code>getty</code> no podría abrir el puerto de comunicaciones hasta que un CD (detección de señal) sea afirmado por el modem.</p></div><div class=paragraph><p>si no ve ningún proceso <code>getty</code> esperando para abrir el puerto <span class=filename>ttydN</span> deseado, revise de nuevo sus entradas en <span class=filename>/etc/ttys</span> para ver si existe algún error ahí. También revise el fichero de log <span class=filename>/var/log/messages</span> para ver si existe algún mensaje de <code>init</code> o de <code>getty</code> relacionados a cualquier problema. Si existe cualquier mensaje, revise nuevamente los ficheros de configuración <span class=filename>/etc/ttys</span> y <span class=filename>/etc/gettytab</span>, así como los ficheros especiales de dispositivo <span class=filename>/dev/ttydN</span>, por cualquier error, entradas faltantes, o ficheros especiales de dispositivo faltantes.</p></div></div><div class=sect4><h5 id=_trate_de_llamar>24.4.6.2. Trate de llamar<a class=anchor href=#_trate_de_llamar></a></h5><div class=paragraph><p>Trate de llamar al sistema; asegúrese de usar 8 bits, sin paridad, y 1 bit de parada en el sistema remoto. Si no obtiene un prompt inmediatamente, o recibe basura, trate presionando <kbd>Enter</kbd> una vez por segundo. Si continua sin ver un prompt de <code>login:</code> despues de un tiempo, trate enviando un <code>BREAK</code>. Si está usando un modem de alta velocidad para realizar la marcación, trate marcando de nuevo despues de fijar la velociad de interfaz del modem (por medio de <code>ATB1</code> en un modem U.S. Robotics® Sportster®, por ejemplo).</p></div><div class=paragraph><p>Si todavía no puede obtener un prompt de <code>login:</code>, revise <span class=filename>/etc/gettytab</span> de nuevo y revise nuevamente que</p></div><div class=ulist><ul><li><p>El nombre de capacidad inicial especificado en <span class=filename>/etc/ttys</span> para la línea coincida con un nombre de una capacidad en <span class=filename>/etc/gettytab</span></p></li><li><p>Cada entrada <code>nx=</code> coincida con otro nombre de capacidad de <span class=filename>gettytab</span></p></li><li><p>Cada entrada <code>tc=</code> coincida con otro nombre de capacidad de <span class=filename>gettytab</span></p></li></ul></div><div class=paragraph><p>Si marca pero el modem en el sistema FreeBSD no contesta, asegúrese que el modem está configurado para contestar el teléfono cuando DTR sea detectado. Si el modem parece estar configurado correctamente, verifique que DTR sea detectado revisando las luces indicadoras del modem (si tiene alguna).</p></div><div class=paragraph><p>Si ha revisado todo varias veces y todavía no funciona, tome un descanso y regrese a eso depues. Si todavía continua sin funcionar, tal vez puede mandar un correo electrónico a <a href=https://lists.FreeBSD.org/subscription/freebsd-questions>Lista de correo para preguntas generales sobre FreeBSD</a> describiendo su modem y su problema, y las buenas personas en la lista tratarán de ayudarle.</p></div></div></div></div><div class=sect2><h3 id=dialout>24.5. Servicio dial-out<a class=anchor href=#dialout></a></h3><div class=paragraph><p>Los siguientes son tips para que su equipo pueda conectarse a otra computadora mediante el modem. Esto es apropiado para establecer una sesión de terminal con un equipo remoto.</p></div><div class=paragraph><p>Esto es útil para entrar a una BBS.</p></div><div class=paragraph><p>Este tipo de conexión puede ser extremadamente útil para obtener un fichero del Internet si tiene problemas con PPP. Si necesita mandar por FTP algo y PPP no funciona, utilice la sesión de terminal para mandarlo por FTP. Entonces use zmodem para transferirlo a su máquina.</p></div><div class=sect3><h4 id=_mi_modem_hayes_no_está_soportado_que_puedo_hacer>24.5.1. ¿Mi modem Hayes no está soportado, que puedo hacer?<a class=anchor href=#_mi_modem_hayes_no_está_soportado_que_puedo_hacer></a></h4><div class=paragraph><p>En realidad, la página de manual para <code>tip</code> no está actualizada. Existe un marcador Hayes genérico incluido. Solo utilice <code>at=hayes</code> en su fichero <span class=filename>/etc/remote</span>.</p></div><div class=paragraph><p>El controlador Hayes no es lo suficientemente inteligente para reconocer algunas de las funciones avanzadas de nuevos modems como <code>BUSY</code>, <code>NO DIALTONE</code>, o <code>CONNECT 115200</code> y solamente se confundirá. Debería apagar esos mensajes cuando utilice <code>tip</code> (usando <code>ATX0W</code>).</p></div><div class=paragraph><p>También, la pausa de marcado para <code>tip</code> es de 60 segundos. Su modem debe utilizar un poco menos, o de otra manera tip pensará que existe un problema de comunicación. Trate con <code>ATS7=45W</code>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Así como se envía, <code>tip</code> todavía no soporta modems Hayes completamente. La solución es editar el fichero <span class=filename>tipconf.h</span> en el directorio <span class=filename>/usr/src/usr.bin/tip/tip</span>. Obviamente necesita las fuentes de la distribución para hacer esto.</p></div><div class=paragraph><p>Edite la línea <code>#define HAYES 0</code> a <code>#define HAYES 1</code>. Entonces haga un <code>make</code> y <code>make install</code>. Todo funciona bien despues de eso.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=direct-at>24.5.2. ¿Como se espera que yo entre estos comandos AT?<a class=anchor href=#direct-at></a></h4><div class=paragraph><p>Haga lo que se llama una entrada "directa" en su fichero <span class=filename>/etc/remote</span>. Por ejemplo, si su modem está conectado al primer puerto serie, <span class=filename>/dev/cuaa0</span>, entonces ponga la siguiente línea:</p></div><div class="literalblock programlisting"><div class=content><pre>cuaa0:dv=/dev/cuaa0:br#19200:pa=none</pre></div></div><div class=paragraph><p>Utilice la tasa más alta de bps que su modem soporte en la capacidad br. Entonces, escriba <code>tip cuaa0</code> y estará conectado a su modem.</p></div><div class=paragraph><p>Si no existe un fichero <span class=filename>/dev/cuaa0</span> en su sistema, haga esto:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /dev</span>
<span class=c># sh MAKEDEV cuaa0</span></code></pre></div></div><div class=paragraph><p>O use <code>cu</code> como <code>root</code> con el siguiente comando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cu -lline -sspeed</span></code></pre></div></div><div class=paragraph><p><em>line</em> es el puerto serie (ejem.<span class=filename>/dev/cuaa0</span>) y <em>speed</em> es la velocidad (ejem.<code>57600</code>). Cuando termine de meter los comandos AT presione <kbd>~.</kbd> para salir.</p></div></div><div class=sect3><h4 id=_el_signo_para_la_capacidad_pn_no_funciona>24.5.3. ¡El signo <code>@</code> para la capacidad pn no funciona!<a class=anchor href=#_el_signo_para_la_capacidad_pn_no_funciona></a></h4><div class=paragraph><p>El signo <code>@</code> en la capacidad número de teléfono le dice a tip que busque en <span class=filename>/etc/phones</span> por un número de teléfono. Pero el signo <code>@</code> también es un caracter especial en ficheros de capacidad como <span class=filename>/etc/remote</span>. Escápelo con una diagonal invertida:</p></div><div class="literalblock programlisting"><div class=content><pre>pn=\@</pre></div></div></div><div class=sect3><h4 id=_como_puede_marcar_un_número_de_teléfono_en_la_línea_de_comando>24.5.4. Como puede marcar un número de teléfono. en la línea de comando?<a class=anchor href=#_como_puede_marcar_un_número_de_teléfono_en_la_línea_de_comando></a></h4><div class=paragraph><p>Ponga lo que se llama una entrada "generica" en su fichero <span class=filename>/etc/remote</span>. Por ejemplo:</p></div><div class="literalblock programlisting"><div class=content><pre>tip115200|Dial any phone number at 115200 bps:\
        :dv=/dev/cuaa0:br#115200:at=hayes:pa=none:du:
tip57600|Dial any phone number at 57600 bps:\
        :dv=/dev/cuaa0:br#57600:at=hayes:pa=none:du:</pre></div></div><div class=paragraph><p>Entonces puede hacer cosas como:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># tip -115200 5551234</span></code></pre></div></div><div class=paragraph><p>Si prefiere <code>cu</code> y no <code>tip</code>, use una entrada <code>cu</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>cu115200|Use cu to dial any number at 115200bps:\
        :dv=/dev/cuaa1:br#57600:at=hayes:pa=none:du:</pre></div></div><div class=paragraph><p>y escriba:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cu 5551234 -s 115200</span></code></pre></div></div></div><div class=sect3><h4 id=_tengo_que_teclear_la_tasa_de_bps_cada_vez_que_haga_eso>24.5.5. ¿Tengo que teclear la tasa de bps cada vez que haga eso?<a class=anchor href=#_tengo_que_teclear_la_tasa_de_bps_cada_vez_que_haga_eso></a></h4><div class=paragraph><p>Ponga una entrada para <code>tip1200</code> o <code>cu1200</code>, pero utilice cualquier tasa bps que sea apropiada con la capacidad br. <code>tip</code> piensa que una buena opción por omisión es 1200 bps es por eso que busca una entrada <code>tip1200</code>. Aunque no tiene que usar 1200 bps.</p></div></div><div class=sect3><h4 id=_acceso_a_un_número_de_equipos_a_través_de_un_servidor_de_terminales>24.5.6. Acceso a un número de equipos a través de un servidor de terminales<a class=anchor href=#_acceso_a_un_número_de_equipos_a_través_de_un_servidor_de_terminales></a></h4><div class=paragraph><p>en lugar de esperar hasta que esté conectado y teclear <code>CONNECT host</code> cada vez, use la capacidad de tip <code>cm</code>. Por ejemplo, estas entradas en <span class=filename>/etc/remote</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>pain|pain.deep13.com|Forrester&#39;s machine:\
        :cm=CONNECT pain\n:tc=deep13:
muffin|muffin.deep13.com|Frank&#39;s machine:\
        :cm=CONNECT muffin\n:tc=deep13:
deep13:Gizmonics Institute terminal server:\
        :dv=/dev/cuaa2:br#38400:at=hayes:du:pa=none:pn=5551234:</pre></div></div><div class=paragraph><p>Le permitirá teclear <code>tip pain</code> o <code>tip muffin</code> para conectar a los equipos pain o muffin, y <code>tip deep13</code> para accesar al servidor de terminales.</p></div></div><div class=sect3><h4 id=_puede_tip_tratar_más_de_una_línea_para_cada_sitio>24.5.7. ¿Puede Tip tratar más de una línea para cada sitio?<a class=anchor href=#_puede_tip_tratar_más_de_una_línea_para_cada_sitio></a></h4><div class=paragraph><p>Eso es a menudo un problema donde una universidad tiene varias líneas de modems y varios miles de estudiantes tratando de usarlas.</p></div><div class=paragraph><p>Haga una entrada para su universidad en <span class=filename>/etc/remote</span> y use <code>@</code> para la capacidad <code>pn</code> :</p></div><div class="literalblock programlisting"><div class=content><pre>big-university:\
        :pn=\@:tc=dialout
dialout:\
        :dv=/dev/cuaa3:br#9600:at=courier:du:pa=none:</pre></div></div><div class=paragraph><p>Entonces liste los números de teléfonos para la universidad en <span class=filename>/etc/phones</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>big-university 5551111
big-university 5551112
big-university 5551113
big-university 5551114</pre></div></div><div class=paragraph><p><code>tip</code> tratará cada uno en el orden listado, entonces se rendirá. Si quiere seguir tratando, ejecute <code>tip</code> en un ciclo while.</p></div></div><div class=sect3><h4 id=_porqué_tengo_que_presionar_ctrlp_dos_veces_para_mandar_un_ctrlp>24.5.8. ¿Porqué tengo que presionar <span class=keyseq><kbd>Ctrl</kbd>+<kbd>P</kbd></span> dos veces para mandar un <span class=keyseq><kbd>Ctrl</kbd>+<kbd>P</kbd></span> ?<a class=anchor href=#_porqué_tengo_que_presionar_ctrlp_dos_veces_para_mandar_un_ctrlp></a></h4><div class=paragraph><p><span class=keyseq><kbd>Ctrl</kbd>+<kbd>P</kbd></span> es el caracter de "forzado" por omisión, usado para decirle a <code>tip</code> que el siguiente caracter es un dato literal. Puede establecer el caracter de forzado a cualquier otro caracter con el escape <code>~s</code>, el cual significa "establecer una variable."</p></div><div class=paragraph><p>Escriba <code>~sforce=single-char</code> seguido por una nueva línea. <em>single-char</em> es cualquier caracter. Si no especifica <em>single-char</em>, entonces el caracter de forzado es el caracter nulo, el cual puede obtener tecleando <span class=keyseq><kbd>Ctrl</kbd>+<kbd>2</kbd></span> o <span class=keyseq><kbd>Ctrl</kbd>+<kbd>Espacio</kbd></span>. Un buén valor para <em>single-char</em> es <span class=keyseq><kbd>Shift</kbd>+<kbd>Ctrl</kbd>+<kbd>6</kbd></span>, es cual solamente es usado en algunos servidores de terminales.</p></div><div class=paragraph><p>Puede hacer que el caracter de forzado sea cualquiera que usted quiera especificando lo siguiente en su fichero <span class=filename>$HOME/.tiprc</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>force=single-char</pre></div></div></div><div class=sect3><h4 id=_de_repente_todo_lo_que_escribo_está_en_mayúsculas>24.5.9. ¿¿De repente todo lo que escribo está en mayúsculas??<a class=anchor href=#_de_repente_todo_lo_que_escribo_está_en_mayúsculas></a></h4><div class=paragraph><p>Debe haber presionado <span class=keyseq><kbd>Ctrl</kbd>+<kbd>A</kbd></span>, el"caracter de mayúsculas" de <code>tip</code> especialmente diseñado para personas con teclas caps-lock dañadas. Use <code>~s</code> como se ve arriba y establezca la variable <code>raisechar</code> a algo razonable. De hecho, puede establecerla a la misma del caracter de forzado, si nunca espera utilizar ninguna de estas funciones.</p></div><div class=paragraph><p>Aquí hay un ejemplo de fichero .tiprc perfecto para usuarios de Emacs que necesitan teclear <span class=keyseq><kbd>Ctrl</kbd>+<kbd>2</kbd></span> y <span class=keyseq><kbd>Ctrl</kbd>+<kbd>A</kbd></span> con frecuencia:</p></div><div class="literalblock programlisting"><div class=content><pre>force=^^
raisechar=^^</pre></div></div><div class=paragraph><p>El ^^ es <span class=keyseq><kbd>Shift</kbd>+<kbd>Ctrl</kbd>+<kbd>6</kbd></span>.</p></div></div><div class=sect3><h4 id=_como_puedo_realizar_transferencias_de_ficheros_con_tip>24.5.10. ¿Como puedo realizar transferencias de ficheros con <code>tip</code>?<a class=anchor href=#_como_puedo_realizar_transferencias_de_ficheros_con_tip></a></h4><div class=paragraph><p>Si esta hablando con otro sistema UNIX®, puede mandar y recibir ficheros con <code>~p</code> (put) y <code>~t</code> (take). Estos comandos ejecutan <code>cat</code> y <code>echo</code> en el sistema remoto para aceptar y envíar ficheros. La sintaxis es:
<code>~p</code> fichero-local [ fichero-remoto ]
<code>~t</code> fichero-remoto [ fichero-local ]</p></div><div class=paragraph><p>No existe revisión de errores, así que probablemente debería usar otro protocolo, como zmodem.</p></div></div><div class=sect3><h4 id=_como_puedo_ejecutar_zmodem_con_tip>24.5.11. ¿Como puedo ejecutar zmodem con <code>tip</code>?<a class=anchor href=#_como_puedo_ejecutar_zmodem_con_tip></a></h4><div class=paragraph><p>Para recibir ficheros, inicie el programa de envío en el extremo remoto. Entonces escriba <code>~C rz</code> para empezar a recibirlos localmente.</p></div><div class=paragraph><p>Para enviar ficheros, inicie el programa de recepción el extremo remoto. Entonces escriba <code>~C sz files</code> para enviarlos al sistema remoto.</p></div></div></div><div class=sect2><h3 id=serialconsole-setup>24.6. Configurando la consola serie<a class=anchor href=#serialconsole-setup></a></h3><div class=sect3><h4 id=serialconsole-intro>24.6.1. Introducción<a class=anchor href=#serialconsole-intro></a></h4><div class=paragraph><p>FreeBSD tiene la habilidad de arrancar en un sistema con solo una terminal tonta como consola. Tal configuración podría ser útil para dos clases de gente: administradores de sistema que quieran instalar FreeBSD en máquinas que no tienen teclado o monitor conectado, y desarrolladores que quieran corregir errores en el kernel o controladores de dispositivos.</p></div><div class=paragraph><p>Como se describe en <a href=./#boot>El proceso de arranque en FreeBSD</a>, FreeBSD emplea un sistema de arranque de tres estados. Los primeros dos estados se encuentran en el código del bloque de arranque el cual es almacenado al principio del slice en el disco de arranque. El bloque de arranque entonces cargará y ejecutará el cargador de arranque (<span class=filename>/boot/loader</span>) como la tercera etapa de código.</p></div><div class=paragraph><p>Para poder configurar la consola serie debe configurar el código del bloque de arranque, el código del cargador de arranque y el kernel.</p></div></div><div class=sect3><h4 id=serialconsole-howto-fast>24.6.2. Configuracióm de consola serie, versión breve<a class=anchor href=#serialconsole-howto-fast></a></h4><div class=paragraph><p>Esta sección asume que está usando la configuración por omisión y solo quiere una rápida revisión de la configuración de la consola serie.</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Conecte el cable serie a COM1 y la terminal controladora.</p></li><li><p>Para ver todos los mensajes de arranque en la consola serie escriba el siguiente comando mientras está firmado como superusuario:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># echo &#39;console=&#34;comconsole&#34;&#39; &gt;&gt; /boot/loader.conf</span></code></pre></div></div></li><li><p>Edite <span class=filename>/etc/ttys</span> y cambie <code>dialup</code> a <code>vt100</code> para la entrada <code>ttyd0</code>. De otra manera una contraseña no será requerida para conectar por medio de la consola serie, resultando en un agujero de seguridad potencial.</p></li><li><p>Reinicie el sistema para ver si los cambios tuvieron efecto.</p></li></ol></div></div></div><div class=paragraph><p>Si una configuración diferente es requerida, una explicación mas detallada existe en <a href=#serialconsole-howto>Configuración de la consola serie</a>.</p></div></div><div class=sect3><h4 id=serialconsole-howto>24.6.3. Configuración de la consola serie<a class=anchor href=#serialconsole-howto></a></h4><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Prepare un cable serie.</p><div class=paragraph><p>Necesitará ya sea un cable null-modem o un cable serie estándar y un adaptador null-modem. Vea <a href=#serial-cables-ports>Cables y puertos</a> para una discusión sobre cables serie.</p></div></li><li><p>Desconecte su teclado.</p><div class=paragraph><p>La mayoría de sistemas PC buscan el teclado durante la autoprueba de encendido (POST) y generarán un error si el teclado no es detectado. Algunas máquinas se quejan fuerte sobre la falta de un teclado y no continuarán arrancando hasta que este contectado.</p></div><div class=paragraph><p>Si su computadora se queja con este error, pero arranca de todos modos, entonces no tiene que hacer nada especial. (Algunas máquinas con BIOS Phoenix instalado solo mostrarán <code>Keyboard failed</code> y continuarán arrancando normalmente.)</p></div><div class=paragraph><p>Si su computadora se niega a arrancar sin un teclado conectado, entonces tendrá que configurar el BIOS para que ignore este error (si es posible). Consulte el manual de su tarjeta madre para los detalles de como hacer esto.</p></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Poniendo el teclado como "No instalado" en el BIOS <em>no</em> significa que no podá usar su teclado. Todo lo que hace es decirle al BIOS que no busque un teclado al momento de encender, asi no se quejará si el teclado no se encuentra conectado. Puede dejar el teclado conectado incluso si esta bandera está puesta a "No instalado" y el teclado todaía funcionará.</p></div></td></tr></tbody></table></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Si su sistema tiene un ratón PS/2® es muy probable que también tenga que desconectar su ratón junto con el teclado. Esto se debe a que los ratones PS/2® comparten algún hardware con el teclado y dejandolo conectado puede ocasionar que el sistema piense que el teclado sigue conectado. Se dice que un sistema Gateway 2000 Pentium 90 MHz con un AMI BIOS se comporta de esta manera. En general, esto no representa un problema puesto que el ratón no es muy útil sin el teclado de todas maneras.</p></div></td></tr></tbody></table></div></li><li><p>Conecte una terminal tonta a <span class=filename>COM1</span> (<span class=filename>sio0</span>).</p><div class=paragraph><p>Si no tiene una terminal tonta, puede utilizar una PC/XT vieja con un programa de modem, o el puerto serie en otro equipo UNIX®. Si no tiene un <span class=filename>COM1</span> (<span class=filename>sio0</span>), consiga uno. En este momento, no existe manera de seleccionar un puerto diferente a <span class=filename>COM1</span> para los bloques de arranque sin recompilar los bloques de arranque. Si ya está utilizando <span class=filename>COM1</span> para otro dispositivo, necesitará remover temporalmente ese dispositivo e instalar un nuevo bloque de arranque y kernel una vez que tenga a FreeBSD arriba y funcionando. (Se asume que <span class=filename>COM1</span> estará disponible en un fichero/computadora/servidor de terminales de todas maneras; si realmente necesita <span class=filename>COM1</span> para algo más (y no puede cambiar ese algo a <span class=filename>COM2</span> (<span class=filename>sio1</span>)), entonces probablemente no debería de molestarse con todo esto en primer lugar.)</p></div></li><li><p>Asegúrese de que el fichero de configuración de su kernel tenga las banderas apropiadas activadas para <span class=filename>COM1</span> (<span class=filename>sio0</span>).</p><div class=paragraph><p>Las banderas relevantes son:</p></div><div class=dlist><dl><dt class=hdlist1><code>0x10</code></dt><dd><p>Habilita el soporte de consola para esta unidad. Las otras banderas de consola son ignoradas a menos que ésta está activada. Actualmente, al menos una unidad puede tener soporte de consola; la primera (en orden de configuración) con esta bandera activada es preferida. Esta opción por si sola no hará del puerto serie una consola. Active la siguiente bandera o utilice la opción <code>-h</code> descrita abajo, junto con esta bandera.</p></dd><dt class=hdlist1><code>0x20</code></dt><dd><p>Obliga a esta unidad a ser la consola (a menos que exista otra consola de mayor prioridad), sin importar la opción <code>-h</code> discutida abajo. Esta bandera reemplaza la opción <code>COMCONSOLE</code> en las versiones 2.<em>X</em> de FreeBSD. La bandera <code>0x20</code> debe ser utilizada junto con la bandera <code>0x10</code>.</p></dd><dt class=hdlist1><code>0x40</code></dt><dd><p>Reserva esta unidad (en conjunto con <code>0x10</code>) y hace esta unidad no disponible para acceso normal. No debería activar esta bandera en la unidad de puerto serie la cual desee utilizar como la consola serie. El único uso de esta bandera es designar la unidad para corección de errore remota del kernel. Revise "El manual del desarrollador" para mayor información sobre corrección de errores remotamente.</p><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>En FreeBSD 4.0 o posterior la semántica de la bandera <code>0x40</code> es ligeramente diferente y existe otra bandera para especificar un puerto serie para corrección de errores remotamente.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Ejemplo:</p></div><div class="literalblock programlisting"><div class=content><pre>device sio0 at isa? port IO_COM1 flags 0x10 irq 4</pre></div></div><div class=paragraph><p>Vea la página de manual <a href="https://man.freebsd.org/cgi/man.cgi?query=sio&amp;sektion=4&amp;format=html">sio(4)</a> para más detalles.</p></div><div class=paragraph><p>Si las banderas no fueron activadas, necesita correr UserConfig (en una consola diferente) o recompilar el kernel.</p></div></dd></dl></div></li><li><p>Cree <span class=filename>boot.config</span> en el directorio raíz de la partición <code>a</code> del disco de arranque.</p><div class=paragraph><p>Este fichero instruirá al código del bloque de arranque como le gustaría arrancar el sistema. Para activar la consola serie, necesita una o más de las siguientes opciones- si quiere opciones múltiples inclúyalas todas en la misma línea:</p></div><div class=dlist><dl><dt class=hdlist1><code>-h</code></dt><dd><p>Cambia entre consola interna y serie. Puede usar esto para cambiar los dispositivos de consola. Por ejemplo, si arranca desde la consola interna (video), puede utilizar <code>-h</code> para dirigir el cargador de arranque y el kernel a que usen el puerto serie como su dispositivo de consola. Alternativamente, si arranca desde el puerto serie, puede utilizar <code>-h</code> para decirle al cargador de arranque y al kernel que usen el video como consola.</p></dd><dt class=hdlist1><code>-D</code></dt><dd><p>Cambia entre configuración de consola simple y dual. En la configuración simple la consola será ya sea la consola interna (video) o el puerto serie, dependiendo del estado de la opción <code>-h</code> de arriba. En la configuración de consola dual, el video y el puerto serie se convertirán en la consola al mismo tiempo, sin importar del estado de la opción <code>-h</code>. De todas maneras, note que la configuración de consola dual toma efecto solamente mientras el bloque de arranca está corriendo. Una vez que el cargador de arranque toma el control, la consola especificada por la opción <code>-h</code> se convierte en la única consola.</p></dd><dt class=hdlist1><code>-P</code></dt><dd><p>Hace que el bloque de arranque busque el teclado. Si no se encuentra un teclado, la opción <code>-D</code> y <code>-h</code> son activadas automátivamente.</p><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Debido a problemas de espacio en la versión actual del bloque de arranque, la opción <code>-P</code> es capaz de detectar unicamente teclados extendidos. Teclados con menos de 101 teclas (y carentes de teclas F11 y F12) no pueden ser detectados. Algunos teclados en laptops puede que no sean correctamente encontrados debido a esta limitación. Si este es el caso con su sistema, debe abandonar el uso de la opción <code>-P</code>. Desafortunádamente no hay una solución para este problema.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Utilice ya sea la opción <code>-P</code> para seleccionar la consola automáticamente, o la opción <code>-h</code> para activar la consola serie.</p></div><div class=paragraph><p>Puede incluir otras opciones descritas en <a href="https://man.freebsd.org/cgi/man.cgi?query=boot&amp;sektion=8&amp;format=html">boot(8)</a> también.</p></div><div class=paragraph><p>Las opciones, excepto por <code>-P</code>, serán pasadas al cargador de arranque (<span class=filename>/boot/loader</span>). El cargador de arranque determinará si el video interno o el puerto serie debería convertirse en la consola examinando el estado de la opción <code>-h</code> solamente. Esto significa que si especifica la opción <code>-D</code> pero no la opción <code>-h</code> en <span class=filename>/boot.config</span>, puede utilizar el puerto serie como consola solamente durante el bloque de arranque; el cargador de arranque usará el video interno como consola.</p></div></dd></dl></div></li><li><p>Arranque la máquina.</p><div class=paragraph><p>Cuando inicia su equipo FreeBSD, los bloques de arranque mostrarán los contenidos de <span class=filename>/boot.config</span> a la consola. Por ejemplo:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>/boot.config: <span class=nt>-P</span>
Keyboard: no</code></pre></div></div><div class=paragraph><p>La segunda línea aparece solamente si pone <code>-P</code> en <span class=filename>/boot.config</span> e indica la presencia/ausencia del teclado. Estos mensajes van a la consola serie o a la interna, o a ambas, dependiendo de la opción en <span class=filename>/boot.config</span>.</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Opciones</th><th class="tableblock halign-left valign-top">Mensaje va a</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>ninguna</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>consola interna</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>-h</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>consola serie</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>-D</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>consola serie e interna</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>-Dh</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>consola serie e interna</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>-P</code>, teclado presente</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>consola interna</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>-P</code>, teclado ausente</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>consola serie</p></td></tr></tbody></table><div class=paragraph><p>Despues de los mensajes de arriba, existirá una pausa pequeña antes que los bloques de arranque continuen cargando el cargador de arranque y antes de que cualquier mensaje posterior sea impreso en la consola. Bajo ciertas circunstancias, no necesita interrumpir los bloques de arranque, pero tal vez quiera hacerlo para asegurarse que las cosas están configuradas corréctamente.</p></div><div class=paragraph><p>Presione cualquier tecla, diferente a <kbd>Enter</kbd>, en la consola para interrumpir el proceso de arranque. Los bloques de arranque entonces esperarán una entrada para determinar como continuar. Debe ver algo como esto:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>FreeBSD/i386 BOOT
Default: 0:ad<span class=o>(</span>0,a<span class=o>)</span>/boot/loader
boot:</code></pre></div></div><div class=paragraph><p>Verifique que el mensaje de arriba aparece en la consola serie o en la interna o en ambas, de acuerdo a las opciones que puso en <span class=filename>/boot.config</span>. Si el mensaje aparece en la consola correcta, presione <kbd>Enter</kbd> para continuar el proceso de arranque.</p></div><div class=paragraph><p>Si quiere usar la consola serie pero no ve el prompt en la terminal serie, algo está mal con su configuración. Mientras tanto, entre <code>-h</code> y presione Enter/Return (si es posible) para decirle al bloque de arranque (y entonces al cargador de arranque y al kernel) que elija el puerto serie como consola. Una vez que el sistema arranque, regrese y revise que fué lo que estuvo mal.</p></div></li></ol></div></div></div><div class=paragraph><p>Despues que el cargador de arranque ha cargado y usted se encuentra en la tercera etapa del proceso de arranque todavía puede cambiar entre la consola interna y la consola serie activando las variables de entorno apropiadas en el cargador de arranque. Vea <a href=#serialconsole-loader>Cambiando la consola desde el cargador de arranque</a>.</p></div></div><div class=sect3><h4 id=serialconsole-summary>24.6.4. Resumen<a class=anchor href=#serialconsole-summary></a></h4><div class=paragraph><p>aquí está el resumen de varias configuraciones discutidas en esta sección y la consola seleccionada eventualmente.</p></div><div class=sect4><h5 id=_caso_1_activó_las_banderas_a_0x10_para_sio0>24.6.4.1. Caso 1: Activó las banderas a 0x10 para <span class=filename>sio0</span><a class=anchor href=#_caso_1_activó_las_banderas_a_0x10_para_sio0></a></h5><div class="literalblock programlisting"><div class=content><pre>device sio0 at isa? port IO_COM1 flags 0x10 irq 4</pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:25%><col style=width:25%><col style=width:25%><col style=width:25%><thead><tr><th class="tableblock halign-left valign-top">Opciones en /boot.config</th><th class="tableblock halign-left valign-top">Consola durante bloques de arranque</th><th class="tableblock halign-left valign-top">Consola durante cargador de arranque</th><th class="tableblock halign-left valign-top">Consola en kernel</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>ninguna</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>interna</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>interna</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>interna</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>-h</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>serie</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>serie</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>serie</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>-D</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>serie e interna</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>interna</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>interna</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>-Dh</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>serie e interna</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>serie</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>serie</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>-P</code>, teclado presente</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>interna</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>interna</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>interna</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>-P</code>, teclado ausente</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>serie e interna</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>serie</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>serie</p></td></tr></tbody></table></div><div class=sect4><h5 id=_caso_2_activó_las_banderas_a_0x30_para_sio0>24.6.4.2. Caso 2: Activó las banderas a 0x30 para sio0<a class=anchor href=#_caso_2_activó_las_banderas_a_0x30_para_sio0></a></h5><div class="literalblock programlisting"><div class=content><pre>device sio0 at isa? port IO_COM1 flags 0x30 irq 4</pre></div></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:25%><col style=width:25%><col style=width:25%><col style=width:25%><thead><tr><th class="tableblock halign-left valign-top">Opciones en /boot.config</th><th class="tableblock halign-left valign-top">Consola durante bloques de arranque</th><th class="tableblock halign-left valign-top">Consola durante cargador de arranque</th><th class="tableblock halign-left valign-top">Consola en kernel</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>ninguna</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>interna</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>interna</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>serie</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>-h</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>serie</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>serie</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>serie</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>-D</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>serie e interna</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>interna</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>serie</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>-Dh</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>serie e interna</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>serie</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>serie</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>-P</code>, teclado presente</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>interna</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>interna</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>serie</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>-P</code>, teclado ausente</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>serie e interna</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>serie</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>serie</p></td></tr></tbody></table></div></div><div class=sect3><h4 id=serialconsole-tips>24.6.5. Consejos para la consola serie<a class=anchor href=#serialconsole-tips></a></h4><div class=sect4><h5 id=_configurando_un_velocidad_de_puerto_serie_más_rápida>24.6.5.1. Configurando un velocidad de puerto serie más rápida<a class=anchor href=#_configurando_un_velocidad_de_puerto_serie_más_rápida></a></h5><div class=paragraph><p>Por omisión, la configuración del puerto serie es: 9600 baud, 8 bits, sin paridad, y 1 bit de parada. Si desea cambiar la velocidad, necesita recompilar al menos los bloques de arranque. Agregue la siguiente línea a <span class=filename>/etc/make.conf</span> y compile nuevos bloques de arranque:</p></div><div class="literalblock programlisting"><div class=content><pre>BOOT_COMCONSOLE_SPEED=19200</pre></div></div><div class=paragraph><p>Vea <a href=#serialconsole-com2>Usando puertos serie para consola diferentes a <span class=filename>sio0</span></a> para instrucciones detalladas sonre construir e instalar nuevos bloques de arranque.</p></div><div class=paragraph><p>Si la consola serie está configurada de alguna otra manera que arrancando con <code>-h</code>, o si la consola serie usada por el kernel es diferente de la usada por los bloques de arranque, entonces también debe agregar la siguiente opción al fichero de configuración del kernel y compilar un nuevo kernel:</p></div><div class="literalblock programlisting"><div class=content><pre>options CONSPEED=19200</pre></div></div></div><div class=sect4><h5 id=serialconsole-com2>24.6.5.2. Usando puertos serie para consola diferentes a <span class=filename>sio0</span><a class=anchor href=#serialconsole-com2></a></h5><div class=paragraph><p>Utilizar un puerto serie diferente a <span class=filename>sio0</span> como consola requiere cierta recompilación. Si quiere usar otro puerto serie por la razón que sea, recompile los bloques de arranque, el cargador de arranque y el kernel como sigue.</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Consiga las fuentes del kernel. (Vea <a href=./#cutting-edge>Lo último de lo último</a>)</p></li><li><p>Edite <span class=filename>/etc/make.conf</span> y ponga <code>BOOT_COMCONSOLE_PORT</code> a la dirección del puerto que quiera usar (0x3F8, 0x2F8, 0x3E8 o 0x2E8). Solamente de <span class=filename>sio0</span> hasta <span class=filename>sio3</span> (<span class=filename>COM1</span> hasta <span class=filename>COM4</span>) pueden usarse; tarjetas multipuertos serie no funcionarán. No se necesita especificar interrupción.</p></li><li><p>Cree un fichero personalizado de configuración de kernel y agrege las banderas apropiadas para el puerto serie que desee utilizar. Por ejemplo, si desea hacer de <span class=filename>sio1</span> (<span class=filename>COM2</span>) la consola:</p><div class="literalblock programlisting"><div class=content><pre>device sio1 at isa? port IO_COM2 flags 0x10 irq 3</pre></div></div><div class=paragraph><p>o</p></div><div class="literalblock programlisting"><div class=content><pre>device sio1 at isa? port IO_COM2 flags 0x30 irq 3</pre></div></div><div class=paragraph><p>Las banderas de consola para otros puertos serie no deben activarse.</p></div></li><li><p>Recompile e instale los bloques de arranque y el cargador de arranque:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /sys/boot</span>
<span class=c># make clean</span>
<span class=c># make</span>
<span class=c># make install</span></code></pre></div></div></li><li><p>Reconstruya e instale el kernel.</p></li><li><p>Escriba los bloques de arranque al disco de arranque con <a href="https://man.freebsd.org/cgi/man.cgi?query=disklabel&amp;sektion=8&amp;format=html">disklabel(8)</a> y arranque desde el nuevo kernel.</p></li></ol></div></div></div></div><div class=sect4><h5 id=serialconsole-ddb>24.6.5.3. Accesando DDB Debugger desde la línea serie<a class=anchor href=#serialconsole-ddb></a></h5><div class=paragraph><p>Si desea entrar al modo kernel debugger desde una consola serie (útil para diagnósticos remotos, !pero también peligroso si genera un BREAK ilegítimo en el puerto serie!) entonces debe compilar con las siguientes opciones:</p></div><div class="literalblock programlisting"><div class=content><pre>options BREAK_TO_DEBUGGER
options DDB</pre></div></div></div><div class=sect4><h5 id=_obteniendo_un_prompt_de_login_en_la_consola_serie>24.6.5.4. Obteniendo un prompt de login en la consola serie<a class=anchor href=#_obteniendo_un_prompt_de_login_en_la_consola_serie></a></h5><div class=paragraph><p>Aunque esto no es requerido, tal vez quiera obtener un prompt de <em>login</em> a través de una línea serie, ahora que puede ver los mensajes de arranque y puede entrar a una sesión en modo kernel debug a través de la consola serie. Aquí está como hacerlo.</p></div><div class=paragraph><p>Abra el fichero <span class=filename>/etc/ttys</span> con un editor y localice las líneas:</p></div><div class="literalblock programlisting"><div class=content><pre>ttyd0 &#34;/usr/libexec/getty std.9600&#34; unknown off secure
ttyd1 &#34;/usr/libexec/getty std.9600&#34; unknown off secure
ttyd2 &#34;/usr/libexec/getty std.9600&#34; unknown off secure
ttyd3 &#34;/usr/libexec/getty std.9600&#34; unknown off secure</pre></div></div><div class=paragraph><p><code>ttyd0</code> hasta <code>ttyd3</code> corresponde a <span class=filename>COM1</span> hasta <span class=filename>COM4</span>. Cambie <code>off</code> a <code>on</code> para el puerto deseado. Si ha cambiado la velocidad del puerto serie, necesita cambiar <code>std.9600</code> para que concuerde con los parámetros actuales, ej. <code>std.19200</code>.</p></div><div class=paragraph><p>Tal vez tambien desee cambiar el tipo de terminal de <code>unknown</code> al tipo actual de su terminal serie.</p></div><div class=paragraph><p>Despues de editar el fichero, debe hacer un <code>kill -HUP 1</code> para que este cambio surta efecto.</p></div></div></div><div class=sect3><h4 id=serialconsole-loader>24.6.6. Cambiando la consola desde el cargador de arranque<a class=anchor href=#serialconsole-loader></a></h4><div class=paragraph><p>Secciones anteriores describieron como instalar la consola serie manipulando el bloque de arranque. Esta sección muestra que puede especificar la consola especificando algunos comandos y variables de entorno en el cargador de arranque. Como el cargador de arranque es invocado en la tercera etapa del proceso de arranque, despues del bloque de arranque, las propiedades en el cargador de arranque sobreescribirán las del bloque de arranque.</p></div><div class=sect4><h5 id=_instalando_la_consola_serie>24.6.6.1. Instalando la consola serie<a class=anchor href=#_instalando_la_consola_serie></a></h5><div class=paragraph><p>Puede facilmente especificarle al cargador de arranque y al kernel que utilicen la consola serie escribiendo solamente una línea en <span class=filename>/boot/loader.rc</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>set console=&#34;comconsole&#34;</pre></div></div><div class=paragraph><p>Esto tendrá efecto sin importar las opciones del bloque de arranque discutidas en la sección previa.</p></div><div class=paragraph><p>Es mejor que ponga la línea de arriba como la primera línea en <span class=filename>/boot/loader.rc</span> para ver los mensajes de arranque en la consola serie tan pronto como sea posible.</p></div><div class=paragraph><p>De igual manera, puede especificar la consola interna como:</p></div><div class="literalblock programlisting"><div class=content><pre>set console=&#34;vidconsole&#34;</pre></div></div><div class=paragraph><p>Si no activa la variable de entorno <code>console</code>, el cargador de arranque, y por consecuencia el kernel, utilizarán cualquier consola que esté indicada por la opción <code>-h</code> en el bloque de arranque.</p></div><div class=paragraph><p>En versiones 3.2 o posteriores, puede especificar la consola en <span class=filename>/boot/loader.conf.local</span> o <span class=filename>/boot/loader.conf</span>, en lugar de <span class=filename>/boot/loader.rc</span>. En este método su <span class=filename>/boot/loader.rc</span> debe verse como:</p></div><div class="literalblock programlisting"><div class=content><pre>include /boot/loader.4th
start</pre></div></div><div class=paragraph><p>Entonces, puede crear <span class=filename>/boot/loader.conf.local</span> y ponerle la siguiente línea.</p></div><div class="literalblock programlisting"><div class=content><pre>console=comconsole</pre></div></div><div class=paragraph><p>o</p></div><div class="literalblock programlisting"><div class=content><pre>console=vidconsole</pre></div></div><div class=paragraph><p>Vea <a href="https://man.freebsd.org/cgi/man.cgi?query=loader.conf&amp;sektion=5&amp;format=html">loader.conf(5)</a> para mayor información.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Hasta el momento, el cargador de arranque no tiene una opción equivalente a la opción <code>-P</code> del bloque de arranque, y no existe una manera de seleccionar automáticamente la consola interna y la consola serie basandose en la presencia del teclado.</p></div></td></tr></tbody></table></div></div><div class=sect4><h5 id=_utilizando_un_puerto_serie_para_la_consola_diferente_a_sio0>24.6.6.2. Utilizando un puerto serie para la consola diferente a <span class=filename>sio0</span><a class=anchor href=#_utilizando_un_puerto_serie_para_la_consola_diferente_a_sio0></a></h5><div class=paragraph><p>Necesita recompilar el cargador de arranque para usar un puerto serie diferente a <span class=filename>sio0</span> para la consola serie. Siga el procedimiento descrito en <a href=#serialconsole-com2>Usando puertos serie para consola diferentes a <span class=filename>sio0</span></a>.</p></div></div></div><div class=sect3><h4 id=serialconsole-caveats>24.6.7. Advertencias<a class=anchor href=#serialconsole-caveats></a></h4><div class=paragraph><p>La idea aquí es permitir a las personas configurar servidores dedicados que no requieran hardware de gráficos o teclados conectados. Desafortunádamente, mientras la mayoría de los sistemas le permitirán arrancar sin un teclado, existen bastantes que no le permitirán arrancar sin un adaptador de gráficos. Máquinas con BIOS AMI pueden configurarse para arrancar sin adaptadores de gráficos instalados cambiando simplemente la opción "graphics adapter" en la configuración del CMOS a "Not installed."</p></div><div class=paragraph><p>De cualquier manera, muchas máquinas no soportan esta opción y se negarán a arrancar si no tiene algún hardware de gráficos instalado en el sistema. Con estas máquinas, debe dejar algún tipo de tarjeta gráfica instalada, (incluso si solamente es una tarjeta mono barata) aunque no tendrá que conectarle un monitor. También puede tratar instalando un BIOS AMI.</p></div></div></div></div></div><div class=sect1><h2 id=ppp-and-slip>Capítulo 25. PPP y SLIP<a class=anchor href=#ppp-and-slip></a></h2><div class=sectionbody><div class=sect2><h3 id=_sinopsis_5>25.1. Sinopsis<a class=anchor href=#_sinopsis_5></a></h3><div class=paragraph><p>FreeBSD cuenta con un gran numero de formas para conectar una computadora a otra. Para establecer una red o una conección a Internet por medio de un módem, o bien, permitir a otras computadoras conectarse por medio de este, se requiere del uso de PPP o SLIP. Este capítulo describe en detalle como configurar los servicios de comunicación para llevar esto a cabo.</p></div><div class=paragraph><p>Una vez que haya leido este capítulo, usted sabrá:</p></div><div class=ulist><ul><li><p>Como configurar User PPP.</p></li><li><p>Como configurar Kernel PPP.</p></li><li><p>Como configurar PPPoE (PPP over Ethernet*).</p></li><li><p>Como configurar PPPoA (PPP over ATM*).</p></li><li><p>Como instalar y configurar un cliente y servidor SLIP.</p></li></ul></div><div class=paragraph><p>Nota del Traductor.: En estricto sentido esto se refiere a contar con la conexión por medio de un dispositivo Ethernet, o bien ATM, pero debido a que usted encontrará estos metodos en su sistema, como PPPoE o bien PPPoA, se han dejado los conceptos "literales" del documento original. Espero que no sea un problema.</p></div><div class=paragraph><p>Antes de leer este capítulo, usted debiese:</p></div><div class=ulist><ul><li><p>Estar familiarizado con la terminología básica de redes.</p></li><li><p>Comprender lo básico y el propósito de una conección por módem SLIP y/o PPP.</p></li></ul></div><div class=paragraph><p>Puede ser que usted se pregunte cual es la principal diferencia entre User PPP y kernel PPP. La respuesta es sencilla; el método User PPP procesa la entrada y salida de datos en userland (ver nota siguiente) en lugar de hacerlo en el kernel. Esto es algo desgastante, en términos del manejo de datos entre userland y el kernel, pero permite, por mucho, un mejor desempeño e implementación de PPP. User PPP utiliza el dispositivo <span class=filename>tun</span> para comunicarse con el mundo exterior, mientras que kernel-ppp, utiliza el dispositivo <span class=filename>ppp</span>.</p></div><div class=paragraph><p>En el desarrollo de este capítulo, se hará referencia a User PPP, simplemente como <em>ppp</em>, a menos de que sea necesaria hacer una distinción entre este y otro software de PPP, como es el caso de <code>pppd</code>. Así mismo, si en el desarrollo del capítulo no se señala lo contrario, todos los comandos explicados, deberán ser ejecutados como <code>root</code>.</p></div><div class=paragraph><p>Nota del Traductor : Cuando se habla de "userland" se hace referencia a todo aquello que <strong>no</strong> forma parte del kernel y que en el caso de código de programa, se ejecuta en modo usuario, ya que el código del kernel se ejecuta en modo kernel, supervisor, o bien en modo privilegiado de ejecución. En lo sucesivo este término será utilizado tal cual.</p></div></div><div class=sect2><h3 id=userppp>25.2. Uso de User PPP<a class=anchor href=#userppp></a></h3><div class=sect3><h4 id=_user_ppp>25.2.1. User PPP<a class=anchor href=#_user_ppp></a></h4><div class=sect4><h5 id=_aclaraciones>25.2.1.1. Aclaraciones<a class=anchor href=#_aclaraciones></a></h5><div class=paragraph><p>Este documento asume que usted cuenta con lo siguiente:</p></div><div class=ulist><ul><li><p>Una cuenta activa con un Proveedor del Servicio de Internet (ISP-por sus siglas en inglées), que usted utliza para conectarse.</p></li><li><p>Adicionalmente, un módem o algún otro dispositivo, conectado a su sistema, y configurado correctamente, que le permite realizar la conexión con su ISP.</p></li><li><p>El número telefónico de su proveedor.</p></li><li><p>Su nombre de usuario y contraseña. (Ya sea un nombre de usuario y/o contraseña estilo UNIX, o bien para uso por medio de PAP o CHAP)
*n La dirección IP de uno o más servidores de nombres (DNS). Normalmente, estos serán provistos por su proveedor de Internet. Si su proveedor no le ha dado esta información, puede utilizar la opción <code>enable dns</code> en su fichero <span class=filename>ppp.conf</span>, para indicarle a ppp que configure el DNS por usted. Esta característica depende del sistema de negociación de DNS que mantenga su proveedor de Internet.</p></li></ul></div><div class=paragraph><p>La siguiente información puede ser que haya sido provista por su proveedor de servicios de internet, pero no es completamente necesaria:</p></div><div class=ulist><ul><li><p>La dirección IP del gateway (pasarela de salida) de su PSI. El gateway es la máquina a la cual usted se conectará y será la <em>ruta por default</em>. Si usted no cuenta con esta información, puede inventar uno y al intentar conectarse, el servidor de su PSI, este nos indicará cual es el valor correcto.</p><div class=paragraph><p>Esta dirección IP, es referida por ppp como <code>HISADDR</code>.</p></div></li><li><p>La mascara de red (netmask) que debe utilizar. Si su PSI no le ha provisto de una, puede utilizar sin problema <code>255.255.255.255</code>.</p></li><li><p>Si su PSI, le ha provisto de una dirección de IP estática y un nombre de host, puede capturarla. De otra forma podemos dejar que el servidor asigne cualquier IP que corresponda.</p></li></ul></div><div class=paragraph><p>Si usted no cuenta con alguna de la información que hemos comentado, le recomendamos contactar con su PSI para requerirla.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>En el transcurso de la presente sección, algunos ejemplos muestran el contenido de archivos de configuración los cuales presentan una numeración. Estos números sirven como ayuda y referencia a cada línea, pero estos no deben de estar presentes en el archivo original. Una sangría adecuada, así como espacios adecuados, también son de suma importancia.</p></div></td></tr></tbody></table></div></div><div class=sect4><h5 id=_preparando_el_kernel>25.2.1.2. Preparando el Kernel<a class=anchor href=#_preparando_el_kernel></a></h5><div class=paragraph><p>Como se comento anteriormente, la aplicación ppp utiliza el dispositivo <span class=filename>tun</span>. Si este dispositivo no ha sido compilado dentro del kernel, ppp lo cargará como módulo cuando sea requerido. El dispositivo tun es dinámico, de tal forma que se generara de acuerdo a la demanda que tenga (usted no esta limitado por el kernel).</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Vale la pena hacer notar que el controlador tun, crea los dispositivos de acuerdo a sus necesidades, por lo que el comando <code>ifconfig -a</code>, no necesariamente mostrará los dispositivos <span class=filename>tun</span>.</p></div></td></tr></tbody></table></div></div><div class=sect4><h5 id=_verificando_el_dispositivo_tun>25.2.1.3. Verificando el dispositivo <span class=filename>tun</span><a class=anchor href=#_verificando_el_dispositivo_tun></a></h5><div class=paragraph><p>Bajo circunstancias normales, la mayoría de los usuarios sólo utilizaran un dispositivo <span class=filename>tun</span> (<span class=filename>/dev/tun0</span>). En lo sucesivo podemos hacer referencia a <span class=filename>tun0</span> con la expresión <span class=filename>tunN</span> donde <code>N</code> es el número que corresponde en su sistema.</p></div><div class=paragraph><p>Para instalaciones de FreeBSD que no tienen el habilitado el DEVFS la existencia de <span class=filename>tun0</span> debe ser verificada (esto no es necesario si se cuenta habilitada la opción DEVFS ya que los nodos de dispositivos seán creados en función a las necesidades).</p></div><div class=paragraph><p>La forma más sencilla de verificar si el dispositivo <span class=filename>tun0</span> se encuentra configurado correctamente, es la de rehacer el dispositivo. Para hacer esto simplemente siga los siguientes pasos:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /dev</span>
<span class=c># sh MAKEDEV tun0</span></code></pre></div></div><div class=paragraph><p>Si usted necesita 16 dispositivos tun en su kernel, deberá crearlos. Esto puede hacerse de la siguiente manera:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /dev</span>
<span class=c># sh MAKEDEV tun15</span></code></pre></div></div></div><div class=sect4><h5 id=_configuración_de_la_resolución_de_nombres>25.2.1.4. Configuración de la Resolución de Nombres<a class=anchor href=#_configuración_de_la_resolución_de_nombres></a></h5><div class=paragraph><p>La resolución es la parte del sistema que busca una dirección IP en los nombres de servidores (host) y viceversa. Puede ser configurado para que busque en "mapas" que describen la IP del servidor en uno de dos lugares, el primero es un archivo llamado <span class=filename>/etc/hosts</span>. Lea <a href="https://man.freebsd.org/cgi/man.cgi?query=hosts&amp;sektion=5&amp;format=html">hosts(5)</a> para más información al respecto. El segundo es el Servicio de Nombres de Dominio de Internet (DNS-Internet Domain Name Service), el cual es una base de datos de distribución. Para mayor información con respecto a los DNS, referirse a dns.</p></div><div class=paragraph><p>La resolución de nombres es un sistema que por medio de llamadas, realiza el mapeo de nombres, pero es necesario inidicarle donde debe buscar la información. Para versiones de FreeBSD anteriores a la 5.0, esto es hecho al editar el archivo <span class=filename>/etc/host.conf</span>. La versión 5.0 de FreeBSD utiliza el archivo <span class=filename>/etc/nsswitch.conf</span>.</p></div><div class=sect5><h6 id=_edición_del_archivo_etchost_conf>25.2.1.4.1. Edición del archivo <span class=filename>/etc/host.conf</span><a class=anchor href=#_edición_del_archivo_etchost_conf></a></h6><div class=paragraph><p>Para versiones de FreeBSD anteriores a la 5.0, este archivo debe contener las siguientes dos líneas (en este orden):</p></div><div class="literalblock programlisting"><div class=content><pre>hosts
bind</pre></div></div><div class=paragraph><p>Esto le indica a la resolución que busque en primer término en el archivo <span class=filename>/etc/hosts</span>, y posteriormente en el DNS, si el nombre no fué localizado</p></div></div><div class=sect5><h6 id=_editando_el_archivo_etcnsswitch_conf>25.2.1.4.2. Editando el archivo <span class=filename>/etc/nsswitch.conf</span><a class=anchor href=#_editando_el_archivo_etcnsswitch_conf></a></h6><div class=paragraph><p>Para versiones de FreeBSD 5.0 y posteriores, este archivo debe contener, al menos, la siguiente línea:</p></div><div class="literalblock programlisting"><div class=content><pre>hosts: files, dns</pre></div></div><div class=paragraph><p>Esto le indica a la resolución de nombres, que busque en primer lugar en el archivo <span class=filename>/etc/hosts</span>, y en caso de que el nombre no haya sido localizado, busque en el DNS.</p></div></div><div class=sect5><h6 id=_editando_el_archivo_etchosts>25.2.1.4.3. Editando el archivo <span class=filename>/etc/hosts</span><a class=anchor href=#_editando_el_archivo_etchosts></a></h6><div class=paragraph><p>Este archivo puede contener direcciones IP, así como el nombre de las máquinas de su red local. Como mínimo debe contar con la información de la máquina que correrá ppp. Asumiendo que su ordenador se llama <code>foo.bar.com</code> con la dirección IP <code>10.0.0.1</code>, el archivo <span class=filename>/etc/hosts</span> debiese contener:</p></div><div class="literalblock programlisting"><div class=content><pre>127.0.0.1	localhost.bar.com	localhost
::1	localhost.bar.com	localhost
10.0.0.1	foo.bar.com		foo</pre></div></div><div class=paragraph><p>Las primeras dos líneas definen el alias del <code>localhost</code>, como sinónimo de la maquina actual. Independientemente de su propia dirección IP, la dirección IP en estas líneas siempre debe ser <code>127.0.0.1</code> y <code>::1</code>. La última línea especifica el nombre <code>foo.bar.com</code> (asi como <code>foo</code> para acortarlo), para la dirección <code>10.0.0.1</code>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>La dirección <code>127.0.0.1</code> y el nombre <code>localhost</code> son conocidos como direcciones "loopback" las cuales hacen un "loopback" (salto de regreso) a la maquina local.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Si su proveedor de Internet, le asigna una dirección IP fija, asín como un nombre, y usted no lo utiliza como nombre del host, añada esto también al archivo <span class=filename>/etc/hosts</span>.</p></div></div><div class=sect5><h6 id=_editando_el_archivo_etcresolv_conf>25.2.1.4.4. Editando el archivo <span class=filename>/etc/resolv.conf</span><a class=anchor href=#_editando_el_archivo_etcresolv_conf></a></h6><div class=paragraph><p>El archivo <span class=filename>/etc/resolv.conf</span>, le indica a la resolución de nombres, como comportarse. Normalmente deberá de incluir la(s) siguiente(s) línea(s):</p></div><div class="literalblock programlisting"><div class=content><pre>domain ejemplo.com
nameserver x.x.x.x
nameserver y.y.y.y</pre></div></div><div class=paragraph><p>Donde <em>x.x.x.x</em> y <em>y.y.y.y</em> deben reemplazarse con las direcciones IP de los servidores DNS, de su ISP. Puede ser que esta información se la hayan entregado al suscribirse o no, pero una rápida llamada a su ISP debe resolver esto.</p></div><div class=paragraph><p>Tambié puede configurar su sistema, de tal forma que <a href="https://man.freebsd.org/cgi/man.cgi?query=syslog&amp;sektion=3&amp;format=html">syslog(3)</a> provee de un login para su conección por PPP. Sólo añada:</p></div><div class="literalblock programlisting"><div class=content><pre>	  !ppp
	  *.*        /var/log/ppp.log</pre></div></div><div class=paragraph><p>al fichero <span class=filename>/etc/syslog.conf</span>. En la mayoría de los casos esto funciona bien.</p></div></div></div><div class=sect4><h5 id=_configuración_automática_de_ppp>25.2.1.5. Configuración Automática de PPP<a class=anchor href=#_configuración_automática_de_ppp></a></h5><div class=paragraph><p>Ambos, <code>ppp</code> así como <code>pppd</code> (la implementación del kernel para PPP), utilizan la configuración de los archivos localizados en el directorio <span class=filename>/etc/ppp</span>. Ejemplos para ppp, pueden encontrarse en: <span class=filename>/usr/shared/examples/ppp/</span>.</p></div><div class=paragraph><p>Para efecto de configurar correctamente <code>ppp</code>, es necesario editar varios ficheros, dependiendo de sus necesidades. La manera en que edite dichos archivos, depende en la forma que utilice su PSI (Proveedor de Servicios de Internet) para brindarle conexión, ya sea por medio de una dirección IP estática o bien una IP dinámica (ya sea que cada vez que se conecta obtiene una nueva dirección).</p></div><div class=sect5><h6 id=userppp-staticIP>25.2.1.5.1. PPP y direcciones de IP estáticas (fijas)<a class=anchor href=#userppp-staticIP></a></h6><div class=paragraph><p>Será necesario editar el archivo de configuración; <span class=filename>/etc/ppp/ppp.conf</span>. Y deberá quedar de una manera similar al ejemplo que se describe a continuación.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Las líneas que terminan con <code>:</code>, deben comenzar en la primer columna del archivo - el resto de las líneas deberán utilizar sangría como se muestra, utilizando espacios o bien el tabulador. La mayor parte de la información que requiere ingresar aqui, se mostro en el marcado manual anterior.</p></div></td></tr></tbody></table></div><div class="literalblock programlisting"><div class=content><pre>1     default:
2       set log Phase Chat LCP IPCP CCP tun command
3       ident user-ppp VERSION (built COMPILATIONDATE)
4       set device /dev/cuaa0
5       set speed 115200
6       set dial &#34;ABORT BUSY ABORT NO\\sCARRIER TIMEOUT 5 \
7                 \&#34;\&#34; AT OK-AT-OK ATE1Q0 OK \\dATDT\\T TIMEOUT 40 CONNECT&#34;
8       set timeout 180
9       enable dns
10
11    provider:
12      set phone &#34;(123) 456 7890&#34;
13      set authname foo
14      set authkey bar
15      set login &#34;TIMEOUT 10 \&#34;\&#34; \&#34;\&#34; gin:--gin: \\U word: \\P col: ppp&#34;
16      set timeout 300
17      set ifaddr x.x.x.x y.y.y.y 255.255.255.255 0.0.0.0
18      add default HISADDR</pre></div></div><div class=dlist><dl><dt class=hdlist1>Línea 1</dt><dd><p>Identifica la entrada por omisión a utilizar. Los comandos descritos en esta parte, serán ejecutados de manera automática cuando se ejecute ppp.</p></dd><dt class=hdlist1>Línea 2</dt><dd><p>Habilita los parámetros de acceso. Cuando la configuración trabaja sin problemas, esta línea deberá quedar de la siguiente forma:</p><div class="literalblock programlisting"><div class=content><pre>set log phase tun</pre></div></div><div class=paragraph><p>para efecto de evitar avisos masivos del sistema (logs).</p></div></dd><dt class=hdlist1>Línea 3</dt><dd><p>Esta línea le indica a PPP como identificarse ante el puerto. PPP se identifica, si tiene algun problema para efecto de establecer la conexión, en esta identificación, PPP provee de cierta información que puede resultar util para detectar el probelma.</p></dd><dt class=hdlist1>Línea 4</dt><dd><p>Le indica a PPP cual es el dispositivo a utilizar para realizar la conexión, o bien al que esta conectado el módem. El dispositivo <span class=filename>COM1</span> es <span class=filename>/dev/cuaa0</span> y <span class=filename>COM2</span> es <span class=filename>/dev/cuaa1</span>.</p></dd><dt class=hdlist1>Línea 5</dt><dd><p>Establece la velocidad a utilizar en la conexión. Si la velocidad de 115200 no trabaja correctamente (la cual deberia con cualquier módem normal), intente con una velocidad inferior, como puede ser 38400.</p></dd><dt class=hdlist1>Líneas 6 y 7</dt><dd><p>La cadena de inicialización. El modo User PPP, utiliza y espera enviar-recibir, la información utilizando una sintaxis similar a la descrita en el programa <a href="https://man.freebsd.org/cgi/man.cgi?query=chat&amp;sektion=8&amp;format=html">chat(8)</a>. Favor de consultar la página de ayuda para conocer las opciones de este lenguaje.</p><div class=paragraph><p>Nota: Este comando continua en la siguiente línea, para facilitar su lectura. Cualquier comando en el archivo <span class=filename>ppp.conf</span> puede utilizar este formato, siempre y cuando el último caracter de la línea sea una diagonal invertida "\".</p></div></dd><dt class=hdlist1>Línea 8</dt><dd><p>Establece el tiempo de espera que debe tratar de realizar la conexión. Por omisión se establecen 180 segundos, por lo que esta línea se deja por pura estética.</p></dd><dt class=hdlist1>Línea 9</dt><dd><p>Esta línea le indica a PPP, que solicite confirmación al puerto, sobre la configuración de la resolución local. Si usted esta corriendo un servidor local de nombres, deberá comentar o eliminar esta línea.</p></dd><dt class=hdlist1>Línea 10</dt><dd><p>Una línea en blanco, para facilitar la lectura. Las líneas en blanco son ignoradas por PPP.</p></dd><dt class=hdlist1>Línea 11</dt><dd><p>Identifica el incio de datos para un "proveedor" determinado, de servicios de internet. Este podrá ser cambiado por el nombre de su ISP, de tal forma que en lo sucesivo utilice la opción <code>load ISP</code>, para iniciar una sesión.</p></dd><dt class=hdlist1>Línea 12</dt><dd><p>Indica el numero telefónico del proveedor. Pueden indicarse varios numeros a utilizar, utilizando el signo de dos puntos (<code>:</code>) o bien la barra (<code>|</code>) como separador. La diferencia entre estos dos separadores, es detallada en el <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a>. Pero en resumen, se puede decir que si se desean utilizar varios numeros de manera aleatoria se debe utilizar los dos puntos, pero si se desea siempre utilizar el primer numero y en caso de falla el siguiente y así sucesivamente, se debe utilizar la barra. Es importante que todo lo que se refiere a numeros telefonicos, este entre comillas como se muestra. Es importante que si piensa usar espacios en los numeros, haga uso de estas comillas (<code>"</code>). La falta de estas pueden ocasionar un simple error.</p></dd><dt class=hdlist1>Líneas 13 y 14</dt><dd><p>Identifica el nombre de usuario y su contraseña. Cuando uno se conecta utilizando un login de tipo Unix, estos valores hacen referencia al comando <code>set login</code>, utilizando las variables \U y \P. Cuando la conexión es utilizando algún metodo como PAP o CHAP, estos valores, son utilizados al momento de la autentificación.</p></dd><dt class=hdlist1>Línea 15</dt><dd><p>Si usted esta utilizando el metodo PAP o CHAP, no habrá un login en este punto, y esta línea deberá ser comentada (utilizando el símbolo <code>#</code> al principio de la línea) o bien eliminada por completo. Vea la parte <a href=#userppp-PAPnCHAP>Autentificación con PAP y CHAP </a>para más detalles.</p><div class=paragraph><p>La cadena de acceso (login), utiliza la misma sintáxis que se utiliza en la cadena de marcado. En este ejemplo, la cadena sirve para un servicio, en el cual el inicio de sesión se ve algo así como lo siguiente:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Proveedor de servicios X
login: foo
password: bar
protocol: ppp</code></pre></div></div><div class=paragraph><p>Es recomendable editar el script, para que se ajuste a sus propias necesidades. Cuando cree este script por primera vez, asegurese de haber habilitado la parte que se refiere a al acceso por medio de "chat", para efecto de poder dar seguimiento al curso de la conexión y la resolución de la misma.</p></div></dd><dt class=hdlist1>Línea 16</dt><dd><p>Establece el tiempo por defecto en el que se perderá la conexión (en segundos). En este caso la conexión será cortada de forma automática, después de 300 segundos de inactividad. Si no desea habilitar esta función establezca este valor en cero o bien utilice el comando en línea <code>-ddial</code>.</p></dd><dt class=hdlist1>Línea 17</dt><dd><p>Indica la dirección de la interfaz. La cadena que aparece como <em>x.x.x.x.</em>, debe se cambiada por la dirección asignada por su PSI. La línea que aparece como <em>y.y.y.y.</em>, debe se substituida por la direcció IP especificada por su PSI, como servidor de salida o pasarela (gateway)(la maquina a la cual se va a conectar). Si su PSI no le ha indicado una dirección de este tipo, puede utilizar <code>10.0.0.2/0</code>. Si usted necesita utilizar una dirección "aleatoria", asegurese de crear el fichero <span class=filename>/etc/ppp/ppp.linkup</span>, siguiendo las instrucciones de <a href=#userppp-dynamicIP>PPP y las direcciones de IP Dinámicas</a>, para su llenado. Si esta línea es omitida, <code>ppp</code>, no podrá ejecutarse en el modo <code>-auto</code>.</p></dd><dt class=hdlist1>Línea 18</dt><dd><p>Añade una ruta por omisión al servidor de salida de su PSI. La palabra especial <code>HISADDR</code> se reemplaza con la dirección del gateway indicado por su PSI, que esta en la línea 9, de otra forma <code>HISADDR</code> no será inicializado.</p><div class=paragraph><p>Si no desea ejecutar <code>ppp</code> en modo <code>-auto</code>, esta línea deberá pasar al archivo <span class=filename>ppp.linkup</span>.</p></div></dd></dl></div><div class=paragraph><p>No hay necesidad de editar el archivo <span class=filename>ppp.linkup</span> si usted cuenta con una dirección IP estática y se esta ejecutando ppp en modo <code>-auto</code>, en virtud de que para efecto de realizar la conexión sus mapas de ruteo debe estar correctas. De cualquier forma puede ser que usted desee ejecutar algun programa/comando, posterior a la conexión. Este es explicado con más detalle posteriormente, cuando se vea el ejemplo de sendmail.</p></div><div class=paragraph><p>Ejemplo de los archivos de configuración, se pueden encontrar en el directorio; <span class=filename>/usr/shared/examples/ppp</span>.</p></div></div><div class=sect5><h6 id=userppp-dynamicIP>25.2.1.5.2. PPP y direcciones de IP Dinámicas (Variables)<a class=anchor href=#userppp-dynamicIP></a></h6><div class=paragraph><p>Si su proveedor de servicios, no le asigna una dirección de IP fija, será necesario configurar a <code>ppp</code>, de tal forma que al momento de realizar la conexión, negocie tanto la dirección local, como la remota. Esto se lleva a cabo al "adivinar" una dirección IP y permitiendo a <code>ppp</code> que la establezca correctamente, usando el Protocolo de Configuración de IP (IPCP), una vez que se ha conectado. La configuración que debe tener el archivo <span class=filename>ppp.conf</span>, es la misma que la utilizada en <a href=#userppp-staticIP>PPP y direcciones de IP fijas</a>, salvo el siguiente cambio:</p></div><div class="literalblock programlisting"><div class=content><pre>17      set ifaddr 10.0.0.1/0 10.0.0.2/0 255.255.255.255</pre></div></div><div class=paragraph><p>Una vez más, no debe incluir el numero de línea, este sólo es una referencia. Así mismo deberá existir sangrado, de cuando menos 1 espacio.</p></div><div class=dlist><dl><dt class=hdlist1>Línea 17</dt><dd><p>El numero siguiente a la diagonal (<code>/</code>), es el numero de bits de la dirección en la cual ppp insistirá en conectarse. Puede ser que usted desee utilizar numeros de IP que sean más apropiados, para ajustar a sus necesiadades, pero el ejemplo descrito anteriormente siempre podrá utilizarse.</p><div class=paragraph><p>El último argumento (<code>0.0.0.0</code>), le indica a PPP, que inicie las negociaciones, utilizando como dirección <code>0.0.0.0</code>, en lugar de que utilice <code>10.0.0.1</code>, lo cual es necesario con algunos proveedores. No utilice la dirección <code>0.0.0.0</code> como el primer argumento, para el comando <code>set ifaddr</code>, ya que impide que PPP configure de forma correcta el sistema, cuando se utiliza en modo <code>-auto</code>.</p></div></dd></dl></div><div class=paragraph><p>Si usted no esta ejecutando PPP en modo <code>-auto</code>, deberá editar su archivo <span class=filename>/etc/ppp/ppp.linkup</span>. El archivo <span class=filename>ppp.linkup</span>, es utilizado una vez que se ha realizado la conexión. En este punto, <code>ppp</code> habrá negociado una dirección de interfaz, y será posible ahora, añadir las entradas para la las tablas de ruteo:</p></div><div class="literalblock programlisting"><div class=content><pre>1     provider:
2      add default HISADDR</pre></div></div><div class=dlist><dl><dt class=hdlist1>Línea 1</dt><dd><p>Al establecer (<code>ppp</code>) una conexión, buscará en <span class=filename>ppp.linkup</span> una entrada, de acuerdo a las siguientes reglas. Primero, tratar de encontrar una entrada que sea igual a la utilizada en el archivo <span class=filename>ppp.conf</span>. Si esto falla, buscar una IP con la dirección de nuestro gateway. Esta entrada es una etiqueta de tipo IP, de cuatro-octetos. Si aun después de esto no se ha detectado la entrada correcta, buscar la entrada <code>MYADDR</code>.</p></dd><dt class=hdlist1>Línea 2</dt><dd><p>Esta línea le indica a <code>ppp</code> que añada una ruta por omisión, que este dirigida hacia <code>HISADDR</code>. <code>HISADDR</code> será reemplazada, con la IP del gateway, como se negocio por IPCP.</p></dd></dl></div><div class=paragraph><p>Para ver un detalle más preciso de esto, puede consultar la entrada de <code>pmdemand</code> en los archivos de ejemplo <span class=filename>/usr/shared/examples/ppp/ppp.conf.sample</span> así como <span class=filename>/usr/shared/examples/ppp/ppp.linkup.sample</span>.</p></div></div><div class=sect5><h6 id=_recibiendo_llamadas_externas>25.2.1.5.3. Recibiendo Llamadas Externas<a class=anchor href=#_recibiendo_llamadas_externas></a></h6><div class=paragraph><p>Cuando se configure ppp, para recibir llamadas externas, en una maquina conectada a un LAN (Red de Area Local), debe decidir si se va a permitir el envío de paquetes a la LAN. Si es así, debe asignar un numero de IP de su red local y utilizar el comando <code>enable proxy</code> en el archivo de configuracion <span class=filename>/etc/ppp/ppp.conf</span>. También deberá asegurarse que en su archivo <span class=filename>/etc/rc.conf</span> cuente con la línea:</p></div><div class="literalblock programlisting"><div class=content><pre>gateway_enable=&#34;YES&#34;</pre></div></div><div class=sect6><h7 id=_qué_getty_utilizar>25.2.1.5.3.1. ?Qué getty utilizar?<a class=anchor href=#_qué_getty_utilizar></a></h7><div class=paragraph><p>El enlace Configurando FreeBSD para Servicios de Marcado provee de una buena descripció, sobre la configuración de estos servicios, basado en <a href="https://man.freebsd.org/cgi/man.cgi?query=getty&amp;sektion=8&amp;format=html">getty(8)</a>.</p></div><div class=paragraph><p>Una alternativa para el comando <code>getty</code> es <a href=http://www.leo.org/~doering/mgetty/index.html>mgetty </a>, el cual es una versión más inteligente de getty diseñada para servicios de marcado telefonico.</p></div><div class=paragraph><p>Una de las principales ventajas de <code>mgetty</code> es que, de hecho <em>platica</em> con los modems, esto es, significativo, ya que si el puerto esta desactivado en su <span class=filename>/etc/ttys</span> el modem no responderá el llamado.</p></div><div class=paragraph><p>Las últimas versiones de <code>mgetty</code> (de la 0.99beta y sucesivas), también cuentan con soporte para la detección automática de llamados de PPP, permitiendo el acceso a servidores de una manera más sencilla (sin uso de tanto scripts).</p></div><div class=paragraph><p>Puede referirse a <a href=#userppp-mgetty>Mgetty y AutoPPP</a> para más información con respecto al comando <code>mgetty</code>.</p></div></div><div class=sect6><h7 id=_permisos_de_ppp>25.2.1.5.3.2. Permisos de PPP<a class=anchor href=#_permisos_de_ppp></a></h7><div class=paragraph><p>El comando <code>ppp</code> normalmente debe ser ejecutado por root (superusuario). Si de cualquier forma, usted desea permitir que <code>ppp</code> pueda ser ejecutado en modo servidor, por un usuario regular, como se describe a continuación, deberá otorgar los permisos necesarios a ese usuario al añadirlo al grupo <code>network</code>, en el fichero <span class=filename>/etc/groups</span>.</p></div><div class=paragraph><p>También será necesario darle acceso a una o más partes del archivo de configuración, haciendo uso del comando <code>allow</code>, como se ve a continuación:</p></div><div class="literalblock programlisting"><div class=content><pre>allow users fred mary</pre></div></div><div class=paragraph><p>Si el comando es utilizado en la sección <code>default</code>, esto le dará a el(los) usuario(s) especificado(s), acceso a todo.</p></div></div><div class=sect6><h7 id=_shells_de_ppp_para_usuarios_de_ip_dinámica>25.2.1.5.3.3. Shells de PPP para Usuarios de IP Dinámica<a class=anchor href=#_shells_de_ppp_para_usuarios_de_ip_dinámica></a></h7><div class=paragraph><p>Cree un fichero llamado: <span class=filename>/etc/ppp/ppp-shell</span> y que contenga lo siguiente:</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
IDENT=`echo $0 | sed -e &#39;s/^.*-\(.*\)$/\1/&#39;`
CALLEDAS=&#34;$IDENT&#34;
TTY=`tty`

if [ x$IDENT = xdialup ]; then
        IDENT=`basename $TTY`
fi

echo &#34;PPP for $CALLEDAS on $TTY&#34;
echo &#34;Starting PPP for $IDENT&#34;

exec /usr/sbin/ppp -direct $IDENT</pre></div></div><div class=paragraph><p>Este script deberá ser ejecutable. Ahora cree un enláce simbólico llamado <span class=filename>ppp-dialup</span> a este script, utilizando los siguientes comandos:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ln -s ppp-shell /etc/ppp/ppp-dialup</span></code></pre></div></div><div class=paragraph><p>Deberá utilizar este script como <em>shell</em> para todos los usuarios que realicen conexión. Este es un ejemplo del fichero <span class=filename>/etc/password</span> para un usuario con acceso a PPP, con nombre de usuario <code>pchilds</code> (recuerde no editar directamente el fichero password, utilice <code>vipw</code>).</p></div><div class="literalblock programlisting"><div class=content><pre>pchilds:*:1011:300:Peter Childs PPP:/home/ppp:/etc/ppp/ppp-dialup</pre></div></div><div class=paragraph><p>Cree un directorio llamado <span class=filename>/home/ppp</span> que contenga los siguentes archivos de 0 bytes:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=nt>-r--r--r--</span>   1 root     wheel           0 May 27 02:23 .hushlogin
<span class=nt>-r--r--r--</span>   1 root     wheel           0 May 27 02:22 .rhosts</code></pre></div></div><div class=paragraph><p>los cuales impiden que <span class=filename>/etc/motd</span> sea desplegado.</p></div></div><div class=sect6><h7 id=_shells_de_ppp_para_usuarios_de_ip_estática>25.2.1.5.3.4. Shells de PPP para Usuarios de IP Estática<a class=anchor href=#_shells_de_ppp_para_usuarios_de_ip_estática></a></h7><div class=paragraph><p>Cree el fichero <span class=filename>ppp-shell</span> al igual que el mencionado con anterioridad, y por cada cuenta donde se tenga asignada una IP estática, cree un enlace simbólico al fichero <span class=filename>ppp-shell</span>.</p></div><div class=paragraph><p>Por ejemplo, si usted cuenta con tres usuarios que utilicen este servicio; <code>fred</code>, <code>sam</code> y <code>mary</code>, los cuales redirecciona a una red de clase C, habria que hacer lo siguiente:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ln -s /etc/ppp/ppp-shell /etc/ppp/ppp-fred</span>
<span class=c># ln -s /etc/ppp/ppp-shell /etc/ppp/ppp-sam</span>
<span class=c># ln -s /etc/ppp/ppp-shell /etc/ppp/ppp-mary</span></code></pre></div></div><div class=paragraph><p>Cada uno de los usuarios señalados, deberán de contar con el enlace a su shell-script como se indicó (por ejemplo, el usuario <code>mary</code>, debe contar con su enlace al fichero <span class=filename>/etc/ppp/ppp-mary</span>).</p></div></div><div class=sect6><h7 id=_configurando_ppp_conf_para_usuarios_de_ip_dinámica>25.2.1.5.3.5. Configurando <span class=filename>ppp.conf</span> para Usuarios de IP-Dinámica<a class=anchor href=#_configurando_ppp_conf_para_usuarios_de_ip_dinámica></a></h7><div class=paragraph><p>El archivo <span class=filename>/etc/ppp/ppp.conf</span> deberá contener algo similar a lo siguiente:</p></div><div class="literalblock programlisting"><div class=content><pre>default:
  set debug phase lcp chat
  set timeout 0

ttyd0:
  set ifaddr 203.14.100.1 203.14.100.20 255.255.255.255
  enable proxy

ttyd1:
  set ifaddr 203.14.100.1 203.14.100.21 255.255.255.255
  enable proxy</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Tomar en cuenta el sangrado, ya que es importante.</p></div></td></tr></tbody></table></div><div class=paragraph><p>La sección <code>default:</code> es cargada para cada sesión. Para cada línea que exista y habilite el marcado, en el fichero <span class=filename>/etc/ttys</span>, se deberá crear una entrada similar a la línea <code>ttyd0:</code> mencionada arriba. Cada línea debera contar con su propia dirección IP, de sus direcciones IP disponibles para asignar dinámicamente.</p></div></div><div class=sect6><h7 id=_configurando_ppp_conf_para_usuarios_de_ip_estática>25.2.1.5.3.6. Configurando <span class=filename>ppp.conf</span> para Usuarios de IP Estática<a class=anchor href=#_configurando_ppp_conf_para_usuarios_de_ip_estática></a></h7><div class=paragraph><p>Junto con el contenido del fichero de ejemplo <span class=filename>/usr/shared/examples/ppp/ppp.conf</span> mencionado anteriormente, deberá agregar una sección para cada usuario asignado estáticamente. Continuaremos con nuestro ejemplo con los usuarios <code>fred</code>, <code>sam</code> y <code>mary</code>.</p></div><div class="literalblock programlisting"><div class=content><pre>fred:
  set ifaddr 203.14.100.1 203.14.101.1 255.255.255.255

sam:
  set ifaddr 203.14.100.1 203.14.102.1 255.255.255.255

mary:
  set ifaddr 203.14.100.1 203.14.103.1 255.255.255.255</pre></div></div><div class=paragraph><p>El archivo <span class=filename>/etc/ppp/ppp.linkup</span> deberá de contener también información del ruteo, para cada IP estática, si es necesario. Las líneas a continuación añadirán una ruta a la dirección <code>203.14.101.0</code> de clase C, por medio del ppp link del cliente.</p></div><div class="literalblock programlisting"><div class=content><pre>fred:
  add 203.14.101.0 netmask 255.255.255.0 HISADDR

sam:
  add 203.14.102.0 netmask 255.255.255.0 HISADDR

mary:
  add 203.14.103.0 netmask 255.255.255.0 HISADDR</pre></div></div></div></div><div class=sect5><h6 id=_algo_más_de_mgetty_autoppp_y_extensiones_ms>25.2.1.5.4. Algo más de <code>mgetty</code>, AutoPPP, y Extensiones MS<a class=anchor href=#_algo_más_de_mgetty_autoppp_y_extensiones_ms></a></h6><div class=sect6><h7 id=userppp-mgetty>25.2.1.5.4.1. <code>mgetty</code> y AutoPPP<a class=anchor href=#userppp-mgetty></a></h7><div class=paragraph><p>Configurando y compilando <code>mgetty</code> con la opción <code>AUTO_PPP</code> habilitada, permite a <code>mgetty</code> detectar la fase LCP de conexiones PPP y automáticamente enviarlo a un shel de ppp. Aun con esto, y debido a que no se ingresa el nombre de usuario y contraseña, es necesario autntificarse por medio de PAP o CHAP.</p></div><div class=paragraph><p>Esta sección asume que el usuaio ha configurado, compilado e instalado correctamente una versión de <code>mgetty</code>, con la opción <code>Auto_PPP</code> (v0.99beta o posterior).</p></div><div class=paragraph><p>Asegurese de que su fichero <span class=filename>/usr/local/etc/mgetty+sendfax/login.conf</span> contiene la siguiente línea en él:</p></div><div class="literalblock programlisting"><div class=content><pre>/AutoPPP/ -     -		      /etc/ppp/ppp-pap-dialup</pre></div></div><div class=paragraph><p>Esto le indicará a <code>mgetty</code> que ejecute el script <span class=filename>ppp-pap-dialup</span>, para efecto de detectar conexiones de tipo PPP.</p></div><div class=paragraph><p>Cree un fichero llamado <span class=filename>/etc/ppp/ppp-pap-dialup</span> que contenga las siguientes líneas (el fichero deberá ser ejecutable):</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
exec /usr/sbin/ppp -direct pap$IDENT</pre></div></div><div class=paragraph><p>Para cada línea de marcado habilitada en <span class=filename>/etc/ttys</span>, cree la entrada correspondiente en <span class=filename>/etc/ppp/ppp.conf</span>. Esto co-existirá pacíficamente con las definiciaones que se hayan hecho, de acuerdo a lo mostrado en la parte de arriba.</p></div><div class="literalblock programlisting"><div class=content><pre>pap:
  enable pap
  set ifaddr 203.14.100.1 203.14.100.20-203.14.100.40
  enable proxy</pre></div></div><div class=paragraph><p>Cada usuario que ingrese al sistema utilizando este metodo, deberá de contar con su clave de usuario, así como su contraseña, en el archivo <span class=filename>/etc/ppp/ppp.secret</span>, o bien agrege la siguiente opción, para efecto de que se pueda realizar la autentificación por medio de PAP, directamente del fichero <span class=filename>/etc/password</span>.</p></div><div class="literalblock programlisting"><div class=content><pre>enable passwdauth</pre></div></div><div class=paragraph><p>Si desea asignar una dirección IP fija a algunos usuarios, puede especificar el número como un tercer argumento en el fichero <span class=filename>/etc/ppp/ppp.secrets</span>. Vea el archivo <span class=filename>/usr/shared/examples/ppp/ppp.secret.sample</span> para obtener ejemplos más detallados de esto.</p></div></div><div class=sect6><h7 id=_extensiones_de_ms>25.2.1.5.4.2. Extensiones de MS<a class=anchor href=#_extensiones_de_ms></a></h7><div class=paragraph><p>Es posible configurar PPP, para efecto de que brinde a DNS y a NetBIOS, direcciones de servidores de nombres de forma automática.</p></div><div class=paragraph><p>Para efecto de habilitar estas extensiones con PPP versión 1.x, las siguientes líneas deberán añadirse a la sección relevante de <span class=filename>/etc/ppp/ppp.conf</span>.</p></div><div class="literalblock programlisting"><div class=content><pre>enable msext
set ns 203.14.100.1 203.14.100.2
set nbns 203.14.100.5</pre></div></div><div class=paragraph><p>Y para versiones de PPP 2 y posteriores:</p></div><div class="literalblock programlisting"><div class=content><pre>accept dns
set dns 203.14.100.1 203.14.100.2
set nbns 203.14.100.5</pre></div></div><div class=paragraph><p>Esto le indicará a los clientes, las direcciones del servidor primario y secundario y el servidor-host para NetBIOS.</p></div><div class=paragraph><p>Si la línea <code>set dns</code>, es omitida en versiones 2 y posteriores, PPP utilizará los valores que encuentre en <span class=filename>/etc/resolv.conf</span>.</p></div></div></div><div class=sect5><h6 id=userppp-PAPnCHAP>25.2.1.5.5. Autentificación por medio de PAP y CHAP<a class=anchor href=#userppp-PAPnCHAP></a></h6><div class=paragraph><p>Algunos proveedores de internet tienen su sistema configurado para que cada usuario al conecatrse sean autentificados por medio de PAP o CHAP. Si este es el caso, al momento de realizar la conexion, no aparecerá un <code>login:</code>, sino que comenzará a comunicarse PPP inmediatamente.</p></div><div class=paragraph><p>El metodo PAP es menos seguro que CHAP, pero la seguridad normalmente no se toma mucho en cuenta en este tipo de conexiones, en funcion de que al enviarse la información de contraseña en texto plano, por medio de una línea serial, no deja mucho espacio para que los crackers "husmeen".</p></div><div class=paragraph><p>Haciendo referencia a lo que vimos de <a href=#userppp-staticIP>PPP y Direcciones de IP Fijas</a> o bien <a href=#userppp-dynamicIP>PPP y Direcciones de IP Dinámicas</a>, habría que aplicar los siguientes cambios:</p></div><div class="literalblock programlisting"><div class=content><pre>7       set login
...
12      set authname MiNombreDeUsuario
13      set authkey MiContraseña</pre></div></div><div class=dlist><dl><dt class=hdlist1>Línea 7</dt><dd><p>Su PSI normalmente requerirá que usted ingrese al sistema, cuando se utiliza PAP o CHAP. Por esta razón debemos deshabilitar la línea que corresponde a "set login".</p></dd><dt class=hdlist1>Línea 12</dt><dd><p>Esta línea especifíca a PAP/CHAP su nombre de usuario. Usted deberá cambiar el valor a quedar el nombre correcto en el campo; <em>MiNombreDeUsuario</em>.</p></dd><dt class=hdlist1>Línea 13</dt><dd><p>Esta línea especifíca su contraseña de PAP/CHAP. Es necesario que usted cambie el valor a quedar el dato correcto, en el campo; <em>MiContraseña</em>. Quizás sea recomendable que añada una línea a quedar:</p><div class="literalblock programlisting"><div class=content><pre>15      accept PAP</pre></div></div><div class=paragraph><p>o</p></div><div class="literalblock programlisting"><div class=content><pre>15      accept CHAP</pre></div></div><div class=paragraph><p>la intención de esto es para hacerlo obvio, aunque en realidad PAP y CHAP son aceptadas por omisión.</p></div></dd></dl></div></div><div class=sect5><h6 id=_cambiando_la_configuración_de_ppp_sobre_la_marcha_al_vuelo>25.2.1.5.6. Cambiando la configuración de <code>ppp</code> sobre la marcha (al vuelo)<a class=anchor href=#_cambiando_la_configuración_de_ppp_sobre_la_marcha_al_vuelo></a></h6><div class=paragraph><p>Es posible hablar con el programa <code>ppp</code> mientras se esta ejecutando en segundo plano, pero sólo si se ha habilitado un puerto de diagnóstico. Para hacer esto, añada lo siguiente a su configuración:</p></div><div class="literalblock programlisting"><div class=content><pre>set server /var/run/ppp-tun%d DiagnosticPassword 0177</pre></div></div><div class=paragraph><p>Esto le indicará a PPP que preste atención al socket del dominio-Unix, solicitando a los usuarios su contraseña, antes de permitir el acceso. La variable <code>%d</code> deberá ser reemplazada por el numero de dispositivo <span class=filename>tun</span> que este utilizando (ej. <span class=filename>tun0</span>).</p></div><div class=paragraph><p>Una vez que se a configurado el socket, se puede utilizar <a href="https://man.freebsd.org/cgi/man.cgi?query=pppctl&amp;sektion=8&amp;format=html">pppctl(8)</a> en scripts que deseen manipular el programa.</p></div></div></div><div class=sect4><h5 id=userppp-final>25.2.1.6. Configuración Final del Sistema<a class=anchor href=#userppp-final></a></h5><div class=paragraph><p>Ahora usted cuenta con un <code>ppp</code> configurado, pero es necesario hacer algunas cosas, antes de que este disponible para trabajar. Todas ellas giran entorno a la edición del fichero <span class=filename>/etc/rc.conf</span>.</p></div><div class=paragraph><p>En primer lugar es importante que se asegure que ha asignado un nombre a su maquina. Esto se hace asignandolo en la línea de <code>hostname=</code>, por ejemplo:</p></div><div class="literalblock programlisting"><div class=content><pre>hostname=&#34;foo.ejemplo.com&#34;</pre></div></div><div class=paragraph><p>Si su Proveedor de Servicios de Internet (PSI), le ha provisto de una dirección fija y un nombre de host, es recomendable que utilice este como su <code>hostname</code>.</p></div><div class=paragraph><p>Localice la línea que se refiera a sus dispositivos de red, la cual es <code>network_interfaces</code>. Si desea configurar su sistema para marcar a su PSI a petición, asegurese de que el dispositivo <span class=filename>tun0</span> este en la lista, de otra forma eliminelo.</p></div><div class="literalblock programlisting"><div class=content><pre>network_interfaces=&#34;lo0 tun0&#34; ifconfig_tun0=</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>La variable <code>ifconfig_tun0</code> debe permanecer en blanco (vacia), y deberá crearse un fichero llamado <span class=filename>/etc/start_if.tun0</span> que contenga la siguiente línea:</p></div><div class="literalblock programlisting"><div class=content><pre>ppp -auto MiSistema</pre></div></div><div class=paragraph><p>Este script se ejecuta cuando se esta configurando la red, inicializando el demonio de ppp de modo automático. Si usted cuenta con una LAN (red de área local), de la cual esta maquina sea la pasarela (gateway), es tambien recomendable que utilice la opción <code>-alias</code>. Referirse a la página de ayuda (man) para mayores detalles.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Especifique el programa router a <code>NO</code>, con la siguiente línea en su fichero <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>router_enable=&#34;NO&#34;</pre></div></div><div class=paragraph><p>Es importante que el demonio <code>routed</code> no se inicialice por default, en virtud de que <code>routed</code> tiende a eliminar las variables creadas por <code>ppp</code>.</p></div><div class=paragraph><p>Probablemente valga la pena asegurarse de que la línea <code>sendmail_flags</code>, no incluya la opción <code>-q</code>, ya que de ser así <code>sendmail</code> intentará localizar los parámetros de la red de vex en cuando, ocasionando que realice llamados al exterior. Puede intentar esto:</p></div><div class="literalblock programlisting"><div class=content><pre>sendmail_flags=&#34;-bd&#34;</pre></div></div><div class=paragraph><p>La parte negativa de esta conifguración es que tiene que forzar a <code>sendmail</code> a re-examinar los llamados del servidor de correo, cada vez que <code>ppp</code> realiza una conexión, con el siguiente comando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /usr/sbin/sendmail -q</span></code></pre></div></div><div class=paragraph><p>Puede utilizar el comando <code>!bg</code> en el fichero <span class=filename>ppp.linkup</span> para hacer esto de manera automática:</p></div><div class="literalblock programlisting"><div class=content><pre>1     provider:
2       delete ALL
3       add 0 0 HISADDR
4       !bg sendmail -bd -q30m</pre></div></div><div class=paragraph><p>Si usted no desea hacer esto, es posible establecer un "dfilter" (filtro), para bloquear el tráfico al servidor de salida de correo (SMTP). Favor de referirse a los archivos de ejemplos para mayor detalle al respecto.</p></div><div class=paragraph><p>Ahora lo único que queda pendiente de hacerse es reiniciar el equipo. Una vez reiniciado el equipo, puede teclear:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ppp</span></code></pre></div></div><div class=paragraph><p>y posteriormente <code>dial proveedor</code> para iniciar la sesión, o bien si desea que <code>ppp</code> inicie la sesión automáticamente, cuando haya una petición de salida (y no haya creado el fichero <span class=filename>start_if.tun0</span>), puede teclear:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ppp -auto proveedor</span></code></pre></div></div></div><div class=sect4><h5 id=_summario>25.2.1.7. Summario<a class=anchor href=#_summario></a></h5><div class=paragraph><p>A manera de recapitulación, podemos decir que para configurar ppp por primera ocasión, debemos:</p></div><div class=paragraph><p>Por parte del Cliente:</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Asegurese de que existe el dispositivo <span class=filename>tun</span> dentro de su kernel.</p></li><li><p>Asegurses de que el dispositivo <span class=filename>tunX</span>, se encuentra disponible, bajo el directorio <span class=filename>/dev</span>.</p></li><li><p>Cree una entrada en su fichero <span class=filename>/etc/ppp/ppp.conf</span>. Con el fichero de ejemplo <span class=filename>pmdemand</span> debe ser suficiente para la mayoria de proveedores.</p></li><li><p>Si cuenta con una dirección de IP dinámica, cree una entrada en el fichero <span class=filename>/etc/ppp/ppp.linkup</span> .</p></li><li><p>Actualice su fichero <span class=filename>/etc/rc.conf</span>.</p></li><li><p>Cree un archivo script llamado <span class=filename>start_if.tun0</span> si requiere servicio de conexión a solicitud.</p></li></ol></div></div></div><div class=paragraph><p>Por parte del Servidor:</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Asegurese de que dentro de su kernel exista el dispositivo <span class=filename>tun</span>.</p></li><li><p>Asegurses de que el dispositivo <span class=filename>tunX</span>, se encuentra disponible, bajo el directorio <span class=filename>/dev</span>.</p></li><li><p>Cree una entrada en el fichero <span class=filename>/etc/passwd</span> (usando el programa <a href="https://man.freebsd.org/cgi/man.cgi?query=vipw&amp;sektion=8&amp;format=html">vipw(8)</a>).</p></li><li><p>Cree un perfil en el directorio home de este usuario, que ejecute <code>ppp -direct direct-server</code> o algo similar.</p></li><li><p>Cree una entrada en el fichero <span class=filename>/etc/ppp/ppp.conf</span>. El fichero de ejemplo <span class=filename>direct-server</span> debe ser suficiente para darse una idea.</p></li><li><p>Cree una entrada en el fichero <span class=filename>/etc/ppp/ppp.linkup</span>.</p></li><li><p>Actualice su fichero <span class=filename>/etc/rc.conf</span>.</p></li></ol></div></div></div></div></div></div><div class=sect2><h3 id=ppp>25.3. Uso de Kernel PPP<a class=anchor href=#ppp></a></h3><div class=sect3><h4 id=_configurando_kernel_ppp>25.3.1. Configurando Kernel PPP<a class=anchor href=#_configurando_kernel_ppp></a></h4><div class=paragraph><p>Antes de comenzar a configurar PPP en su maquina, asegurese de <code>pppd</code> se localiza en <span class=filename>/usr/sbin</span> y de que existe el directorio <span class=filename>/etc/ppp</span>.</p></div><div class=paragraph><p><code>pppd</code> puede trabajar de dos maneras</p></div><div class="olist arabic"><ol class=arabic><li><p>Como un "cliente" - cuando desea conectar su maquina al mundo exterior utilizando PPP, por medio de una conexión serial o bien una línea de modem.
.</p><div class=paragraph><p>como un "servidor" - cuando su maquina esta conectada a una red y es utilizada para que otras maquinas se conecten utilizando ppp.</p></div></li></ol></div><div class=paragraph><p>En ambos casos, será necesario configurar un fichero de opciones (<span class=filename>/etc/ppp/options</span> o bien <span class=filename>~/.ppprc</span> si se cuenta con más de un usuario que utilizará ppp en la misma maquina.</p></div><div class=paragraph><p>También deberá de contar con un software para hacer la conexión por medio de módem (de preferencia kermit), de manera que pueda hacer la conexión con un host remoto.</p></div></div><div class=sect3><h4 id=_uso_de_pppd_como_cliente>25.3.2. Uso de <code>pppd</code> como Cliente<a class=anchor href=#_uso_de_pppd_como_cliente></a></h4><div class=paragraph><p>El siguiente archivo de configuración <span class=filename>/etc/ppp/options</span> puede utilizarse para realizar la conexión a una terminal CISCO, por medio de PPP.</p></div><div class="literalblock programlisting"><div class=content><pre>crtscts         # habilita el flujo de controls de hardware
modem           # línea de control del modem
noipdefault     # el servidor PPP remoto asignará la dirección IP
                # si el servidor no envia una dirección IP durante IPCP
                # remueva esta opción.
passive         # espere por los paquetes LCP
domain ppp.foo.com      # escriba su nombre de dominio aqui

:&lt;remote_ip&gt;    # escriba la IP del host remoto aqui
                # este será utilizado para el ruteo de paquetes por medio
                # de PPP, si no especifica esta opción, cambie la
                # línea a quedar  &lt;local_ip&gt;:&lt;remote_ip&gt;

defaultroute    # establezca esta opción si el servidor su ruteador
                # por default</pre></div></div><div class=paragraph><p>Para conectarse:</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Realice el llamado al host remoto, utilizando kermit (o cualquier otra aplicación de este tipo), ingrese su nombre de usuario y contraseña (o cualquier info que sea necesaria para habilitar PPP en el host remoto).</p></li><li><p>Salga de kermit (sin colgar la línea).</p></li><li><p>Ingrese lo siguiente:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># /usr/src/usr.sbin/pppd.new/pppd /dev/tty01 19200</span></code></pre></div></div><div class=paragraph><p>Asegurese de utilizar el dispositivo y la velocidad adecuados.</p></div></li></ol></div></div></div><div class=paragraph><p>Ahora su computadora esta conectada por medio de PPP. Si la conexión falla, puede añadir la opción <code>debug</code> en el fichero <span class=filename>/etc/ppp/options</span> de tal forma que pueda verificar la que esta ocurriendo y pueda resolver el problema.</p></div><div class=paragraph><p>El siguiente script; <span class=filename>/etc/ppp/pppup</span> realizará los 3 pasos de forma automática:</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
ps ax |grep pppd |grep -v grep
pid=`ps ax |grep pppd |grep -v grep|awk &#39;{print $1;}&#39;`
if [ &#34;X${pid}&#34; != &#34;X&#34; ] ; then
        echo &#39;killing pppd, PID=&#39; ${pid}
        kill ${pid}
fi
ps ax |grep kermit |grep -v grep
pid=`ps ax |grep kermit |grep -v grep|awk &#39;{print $1;}&#39;`
if [ &#34;X${pid}&#34; != &#34;X&#34; ] ; then
        echo &#39;killing kermit, PID=&#39; ${pid}
        kill -9 ${pid}
fi

ifconfig ppp0 down
ifconfig ppp0 delete

kermit -y /etc/ppp/kermit.dial
pppd /dev/tty01 19200</pre></div></div><div class=paragraph><p>El fichero <span class=filename>/etc/ppp/kermit.dial</span> es un script de kermit, uqe realiza el marcado y negocia la autorización necesaria con el host remoto (un ejemplo de este script se encuentra al final de este documento).</p></div><div class=paragraph><p>Utilice el siguiente script, llamado <span class=filename>/etc/ppp/pppdown</span> para desconectar la línea PPP:</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
pid=`ps ax |grep pppd |grep -v grep|awk &#39;{print $1;}&#39;`
if [ X${pid} != &#34;X&#34; ] ; then
        echo &#39;killing pppd, PID=&#39; ${pid}
        kill -TERM ${pid}
fi

ps ax |grep kermit |grep -v grep
pid=`ps ax |grep kermit |grep -v grep|awk &#39;{print $1;}&#39;`
if [ &#34;X${pid}&#34; != &#34;X&#34; ] ; then
        echo &#39;killing kermit, PID=&#39; ${pid}
        kill -9 ${pid}
fi

/sbin/ifconfig ppp0 down
/sbin/ifconfig ppp0 delete
kermit -y /etc/ppp/kermit.hup
/etc/ppp/ppptest</pre></div></div><div class=paragraph><p>Verifique que su PPP aun se esta ejecutando, por medio de <span class=filename>/usr/etc/ppp/ppptest</span>, que deberá verse algo similar a esto:</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
pid=`ps ax| grep pppd |grep -v grep|awk &#39;{print $1;}&#39;`
if [ X${pid} != &#34;X&#34; ] ; then
        echo &#39;pppd running: PID=&#39; ${pid-NONE}
else
        echo &#39;No pppd running.&#39;
fi
set -x
netstat -n -I ppp0
ifconfig ppp0</pre></div></div><div class=paragraph><p>Para colgar el módem, ejecute <span class=filename>/etc/ppp/kermit.hup</span>, que deberá contener:</p></div><div class="literalblock programlisting"><div class=content><pre>set line /dev/tty01	; aqui va el dispositivo del modem
set speed 19200
set file type binary
set file names literal
set win 8
set rec pack 1024
set send pack 1024
set block 3
set term bytesize 8
set command bytesize 8
set flow none

pau 1
out +++
inp 5 OK
out ATH0\13
echo \13
exit</pre></div></div><div class=paragraph><p>He aqui un metodo alterno, donde se utiliza <code>chat</code> en lugar de utilizar <code>kermit</code>.</p></div><div class=paragraph><p>Los siguientes dos ficheros deben ser suficiente, para realizar una conexión por medio de <code>pppd</code>.</p></div><div class="literalblock programlisting"><div class=content><pre>/dev/cuaa1 115200

crtscts		# habilita el control de flujo por medio de hardware
modem		# línea de control del módem
connect &#34;/usr/bin/chat -f /etc/ppp/login.chat.script&#34;
noipdefault	# el servidor remoto debe asignar la dirección IP.
	        # si el servidor no asigna una IP durante la negociación
                # IPCP , remueva esta línea y espere por los
passive         # paquetes LCP
domain &lt;your.domain&gt;	# aqui va su dominio

:		# escriba la IP del host remoto aqui
                # si no ha especificado la opción noipdefault
                # cambie esta línea a quedar &lt;local_ip&gt;:&lt;remote_ip&gt;

defaultroute	# escriba esto, si desea que el servidor PPP sea su
	            # router por default</pre></div></div><div class=paragraph><p><span class=filename>/etc/ppp/login.chat.script</span>:</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Lo siguiente debe ir en una sola línea.</p></div></td></tr></tbody></table></div><div class="literalblock programlisting"><div class=content><pre>ABORT BUSY ABORT &#39;NO CARRIER&#39; &#34;&#34; AT OK ATDT&lt;numero.de.telefono&gt;
  CONNECT &#34;&#34; TIMEOUT 10 ogin:-\\r-ogin: &lt;nombre.usuario&gt;
  TIMEOUT 5 sword: &lt;contraseña&gt;</pre></div></div><div class=paragraph><p>Una vez que estos ficheros han sido modificados correctamente e instalados, todo lo que necesita es ejecutar el comando <code>pppd</code>, algo como:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pppd</span></code></pre></div></div></div><div class=sect3><h4 id=_uso_de_pppd_como_servidor>25.3.3. Uso de <code>pppd</code> como Servidor<a class=anchor href=#_uso_de_pppd_como_servidor></a></h4><div class=paragraph><p>El fichero <span class=filename>/etc/ppp/options</span> debe contener algo similar a lo siguiente:</p></div><div class="literalblock programlisting"><div class=content><pre>crtscts   # control de flujo por Hardware
netmask 255.255.255.0           # mascara de red (no es requisito)
192.114.208.20:192.114.208.165  # direcciones ip del host local y remoto
                                # la dirección ip local debe ser
                                # diferente a la que le haya asignado a su
                                # dispositivo de red ethernet (u otro)
                                # la dirección ip remota que será
                                # asignada a la maquina remota
domain ppp.foo.com              # su dominio
passive                         # espera por LCP
modem                           # línea de modem</pre></div></div><div class=paragraph><p>El siguiengte script, llamado <span class=filename>/etc/ppp/pppserv</span> habilitará pppd, para que actue como servidor:</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
ps ax |grep pppd |grep -v grep
pid=`ps ax |grep pppd |grep -v grep|awk &#39;{print $1;}&#39;`
if [ &#34;X${pid}&#34; != &#34;X&#34; ] ; then
        echo &#39;killing pppd, PID=&#39; ${pid}
        kill ${pid}
fi
ps ax |grep kermit |grep -v grep
pid=`ps ax |grep kermit |grep -v grep|awk &#39;{print $1;}&#39;`
if [ &#34;X${pid}&#34; != &#34;X&#34; ] ; then
        echo &#39;killing kermit, PID=&#39; ${pid}
        kill -9 ${pid}
fi

# reset ppp interface
ifconfig ppp0 down
ifconfig ppp0 delete

# enable autoanswer mode
kermit -y /etc/ppp/kermit.ans

# run ppp
pppd /dev/tty01 19200</pre></div></div><div class=paragraph><p>Utilice el script <span class=filename>/etc/ppp/pppservdown</span> para detener el servidor:</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
ps ax |grep pppd |grep -v grep
pid=`ps ax |grep pppd |grep -v grep|awk &#39;{print $1;}&#39;`
if [ &#34;X${pid}&#34; != &#34;X&#34; ] ; then
        echo &#39;killing pppd, PID=&#39; ${pid}
        kill ${pid}
fi
ps ax |grep kermit |grep -v grep
pid=`ps ax |grep kermit |grep -v grep|awk &#39;{print $1;}&#39;`
if [ &#34;X${pid}&#34; != &#34;X&#34; ] ; then
        echo &#39;killing kermit, PID=&#39; ${pid}
        kill -9 ${pid}
fi
ifconfig ppp0 down
ifconfig ppp0 delete

kermit -y /etc/ppp/kermit.noans</pre></div></div><div class=paragraph><p>El siguiente script de kermit (<span class=filename>/etc/ppp/kermit.ans</span>) habilita/deshabilita el modo de autorespuesta en su módem. Y debe verse algo similar a lo siguiente:</p></div><div class="literalblock programlisting"><div class=content><pre>set line /dev/tty01
set speed 19200
set file type binary
set file names literal
set win 8
set rec pack 1024
set send pack 1024
set block 3
set term bytesize 8
set command bytesize 8
set flow none

pau 1
out +++
inp 5 OK
out ATH0\13
inp 5 OK
echo \13
out ATS0=1\13   ; cambiar esto a quedar out ATS0=0\13 si desea deshabilitar el modo
                ; de autorespuesta
inp 5 OK
echo \13
exit</pre></div></div><div class=paragraph><p>Un script llamado <span class=filename>/etc/ppp/kermit.dial</span> es utilizado para llamar y autentificarse en un host remoto. Es necesario que edite este fichero, de acuerdo a sus necesidades. Escriba su nombre de usuario (login) y contraseña (password) en este fichero, también será necesario cambiar su metodo de conexión, de acuerdo a lo que se ajuste a sus necesidades.</p></div><div class="literalblock programlisting"><div class=content><pre>;
; ingrese el dispositivo que esta apuntando a su módem:
;
set line /dev/tty01
;
; escriba la velocidad del módem:
;
set speed 19200
set file type binary            ; full 8 bit file xfer
set file names literal
set win 8
set rec pack 1024
set send pack 1024
set block 3
set term bytesize 8
set command bytesize 8
set flow none
set modem hayes
set dial hangup off
set carrier auto                ; Posteriormente SET CARRIER si es necesario
set dial display on             ; despues SET DIAL si es necesario
set input echo on
set input timeout proceed
set input case ignore
def \%x 0
goto slhup

:slcmd                          ; cambio a modo de comando
echo Put the modem in command mode.
clear                           ; Limpieza del buffer de entrada
pause 1
output +++
input 1 OK\13\10                ; esperar para OK
if success goto slhup
output \13
pause 1
output at\13
input 1 OK\13\10
if fail goto slcmd              ; si el modem no responde Ok, intentar de nuevo

:slhup                          ; colgar el teléfono
clear                           ; Limpieza del buffer de entrada
pause 1
echo Hanging up the phone.
output ath0\13
input 2 OK\13\10
if fail goto slcmd              ; si no hay un OK como respuesta, poner el modem en modo de comando

:sldial                         ; marcar el numero telefonico
pause 1
echo Dialing.
output atdt9,550311\13\10               ; escriba el numero de telefono
assign \%x 0                    ; asignar cero al contador

:look
clear                           ; Limpieza del buffer de entrada
increment \%x                   ; Conteo de segundos
input 1 {CONNECT }
if success goto sllogin
reinput 1 {NO CARRIER\13\10}
if success goto sldial
reinput 1 {NO DIALTONE\13\10}
if success goto slnodial
reinput 1 {\255}
if success goto slhup
reinput 1 {\127}
if success goto slhup
if &lt; \%x 60 goto look
else goto slhup

:sllogin                        ; login
assign \%x 0                    ; asignar cero al contador
pause 1
echo Looking for login prompt.

:slloop
increment \%x                   ; Conteo de segundos
clear                           ; Limpieza del buffer de entrada
output \13
;
; escriba su login prompt aqui:
;
input 1 {Username: }
if success goto sluid
reinput 1 {\255}
if success goto slhup
reinput 1 {\127}
if success goto slhup
if &lt; \%x 10 goto slloop         ; intentar 10 veces para obtener un login
else goto slhup                 ; colgar y empezar de nuevo si a la decima falla

:sluid
;
; escriba su nombre de usuario:
;
output ppp-login\13
input 1 {Password: }
;
; escriba su contraseña:
;
output ppp-password\13
input 1 {Entering SLIP mode.}
echo
quit

:slnodial
echo \7No dialtone.  Check the telephone line!\7
exit 1

; local variables:
; mode: csh
; comment-start: &#34;; &#34;
; comment-start-skip: &#34;; &#34;
; end:</pre></div></div></div></div><div class=sect2><h3 id=pppoe>25.4. Uso de PPP sobre Ethernet (PPPoE)<a class=anchor href=#pppoe></a></h3><div class=paragraph><p>En esta sección veremos como configurar PPP sobre una red Ethernet (PPPoE).</p></div><div class=sect3><h4 id=_configurando_el_kernel>25.4.1. Configurando el kernel<a class=anchor href=#_configurando_el_kernel></a></h4><div class=paragraph><p>Ya no es necesario realizar una configuración especial para que nuestro kernel cuente con soporte para PPPoE. Siempre y cuando el soporte de redes necesario se encuentre en él, ppp se encargará de cargarlo de una manera dinámica.</p></div></div><div class=sect3><h4 id=_editando_el_fichero_ppp_conf>25.4.2. Editando el fichero <span class=filename>ppp.conf</span><a class=anchor href=#_editando_el_fichero_ppp_conf></a></h4><div class=paragraph><p>He aqui un ejemplo de un fichero de configuración <span class=filename>ppp.conf</span> completamente funcional:</p></div><div class="literalblock programlisting"><div class=content><pre>default:
  set log Phase tun command # puede añadir más dispositivos si lo desea
  set ifaddr 10.0.0.1/0 10.0.0.2/0

nombre_del_proveedor_del_servicio_de_internet:
  set device PPPoE:xl1 # sustituya xl1 con su dispositivo ethernet
  set authname SuNombreDeUsuario
  set authkey SuContraseña
  set dial
  set login
  add default HISADDR</pre></div></div></div><div class=sect3><h4 id=_ejecutando_ppp>25.4.3. Ejecutando PPP<a class=anchor href=#_ejecutando_ppp></a></h4><div class=paragraph><p>Estando en modo <code>superusuario</code> (root) puede ejecutar:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ppp -ddial nombre_del_proveedor_de_inet</span></code></pre></div></div></div><div class=sect3><h4 id=_ejecutando_ppp_al_inicio_de_sesión>25.4.4. Ejecutando PPP al inicio de sesión<a class=anchor href=#_ejecutando_ppp_al_inicio_de_sesión></a></h4><div class=paragraph><p>Añada las siguientes líneas a su archivo <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>ppp_enable=&#34;YES&#34;
ppp_mode=&#34;ddial&#34;
ppp_nat=&#34;YES&#34;	# siempre y cuando desee habilitar nat para su red local
ppp_profile=&#34;nombre_del_proveedor_de_inet&#34;</pre></div></div></div><div class=sect3><h4 id=_diferenciando_el_uso_del_servicio_de_pppoe>25.4.5. Diferenciando el uso del Servicio de PPPoE<a class=anchor href=#_diferenciando_el_uso_del_servicio_de_pppoe></a></h4><div class=paragraph><p>En ocasiones es necesario utilizar una pequeña marca para diferenciar el servicio que vamos a utilizar para establecer la conexión. Las marcas ("tags")de servicio son utilizadas para distinguir entre diferentes servidores de una red, a los que nos podemos conectar utilizando PPPoE.</p></div><div class=paragraph><p>Su proveedor de internet debe haberle provisto de la información necesaria para crear esta marca. Si esto no fué así, puede solicitar a su proveedor que le brinde esta información.</p></div><div class=paragraph><p>Como último recurso, puede intentar el método sugerido por el programa <a href=http://www.roaringpenguin.com/pppoe/>Roarging Penguin PPPoE</a>, que puede encontrarse en la <a href=./#ports>colección de ports</a>. Al utilizar este programa debe tener en mente, que este puede desconfigurar su módem por completo, por esta razón piense biena antes de utilizarlo. Simplemente instale el programa controlador del módem, provisto por su porveedor. Posteriormente, debe acceder al menú de <code>Sistema</code> del programa. El nombre de su perfil debe aparecer listado. Que normalmente es <em>ISP</em>.</p></div><div class=paragraph><p>El nombre del perfil (marca del servicio) será utilizada por la configuración de PPPoE en el fichero de configuración <span class=filename>ppp.conf</span> como el proveedor para la opción del comando <code>set device</code> (puede ver la página de ayuda <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> para más detalles). Esto debe verse algo similar a lo siguiente:</p></div><div class="literalblock programlisting"><div class=content><pre>set device PPPoE:xl1:ISP</pre></div></div><div class=paragraph><p>No olvide cambiar <em>x11</em> por el dispositivo Ethernet que este utilizando.</p></div><div class=paragraph><p>No olvide cambiar <em>ISP</em> por el nombre del perfil que le fué descrito anteriormente (por lo general el nombre de su Proveedor de Servicio de Internet).</p></div><div class=paragraph><p>Para información adicional consulte:</p></div><div class=ulist><ul><li><p><a href=http://renaud.waldura.com/doc/freebsd/pppoe/>Cheaper Broadband with FreeBSD on DSL</a> por Renauld Waldura.</p></li></ul></div></div><div class=sect3><h4 id=ppp-3com>25.4.6. Uso de PPPoE en Casa con un Modem Dual ADSL 3Com<a class=anchor href=#ppp-3com></a></h4><div class=paragraph><p>Este módem no sigue el estandar establecido en el <a href=http://www.faqs.org/rfcs/rfc2516.html>RFC 2516</a> (<em>Un metodo que describe el uso de PPP por medio de un dispositivo Ethernet (PPoE)</em>, escrito por L. Mamakos, K. Lidl, J. Evarts, D. Carrel, D. Simone y R. Wheeler). En su lugar, el código de diferentes tipos de paquetes ha sido utilizado para el manejo del entorno Ethernet. Si cree que esto es incorrecto y que se debiera ajustar a las especificaciones de PPPoE, por favor comentelo en <a href=http://www.3com.com/>3Com</a>.</p></div><div class=paragraph><p>Para poder hacer que FreeBSD sea capaz de comunicarse con este dispositivo, se debe establecer un control de sistema (sysctl). Esto puede hacerse de forma automática al momento del arranque, editando el fichero <span class=filename>/etc/sysctl.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>net.graph.nonstandard_pppoe=1</pre></div></div><div class=paragraph><p>o bien pude hacerse desde la línea de comandos, para un efecto inmediato, por medio del comando <code>sysctl -w net.graph.nonstandard_pppoe=1</code>.</p></div><div class=paragraph><p>Desafortunadamente y dado que esto implica una configuración general del sistema, por lo que no es posible comunicarnos con un dispositivo cliente - servidor que utilice PPPoE y con un módem casero 3Com ADSL, al mismo tiempo.</p></div></div></div><div class=sect2><h3 id=pppoa>25.5. Uso de PPP sobre ATM (PPPoA)<a class=anchor href=#pppoa></a></h3><div class=paragraph><p>Lo siguiente describe como configurar PPP utilizando ATM, alias PPPoA. PPPoA es una alternativa muy común entre proveedores de DSL en Europa.</p></div><div class=sect3><h4 id=_uso_de_pppoa_con_un_alcatel_speedtouch_usb>25.5.1. Uso de PPPoA con un Alcatel Speedtouch USB<a class=anchor href=#_uso_de_pppoa_con_un_alcatel_speedtouch_usb></a></h4><div class=paragraph><p>El soporte bajo FreeBSD para este dispositivo se puede encontrar como un port, por que el firmware es distribuido bajo <a href=http://www.alcatel.com/consumer/dsl/disclaimer_lx.htm>la licencia de Alcatel</a>.</p></div><div class=paragraph><p>Para instalar este software, simplemente utilice la <a href=./#ports>colección de ports</a>. Instale el port <a class=package href=https://cgit.freebsd.org/ports/tree/net/pppoa/>net/pppoa</a> y siga las instrucciones provistas por el port.</p></div></div><div class=sect3><h4 id=_uso_de_mpd>25.5.2. Uso de mpd<a class=anchor href=#_uso_de_mpd></a></h4><div class=paragraph><p>Puede usar mpd para conectarse a una gran variedad de servicios, en particular servicios pptp. Puede encontrar mpd en la colección de ports, bajo <a class=package href=https://cgit.freebsd.org/ports/tree/net/mpd/>net/mpd</a>.</p></div><div class=paragraph><p>Primero debe instalar el port, y posteriormente configurar mpd para que se ajuste a sus necesidades y a la configuración del proveedor. El port instala un conjunto de ficheros de configuración de ejemplo, que estan bien documentados en <span class=filename>PREFIX/etc/mpd/</span>. Note que <em>PREFIX</em> se refiere al directorio donde sus ports son instalados, que normalmente es en <span class=filename>/usr/local</span>. Una guía completa en formato HTML, esta disponible una vez que se ha instalado el port. Esta se localiza en <span class=filename>PREFIX/shared/mpd/</span>. Aqui tenemos un ejemplo simple de configuración para conectarse a un servicio ADSL con mpd. La configuración se divide en dos ficheros, primero tenemos el fichero <span class=filename>mpd.conf</span>.</p></div><div class="literalblock programlisting"><div class=content><pre>default:
     load adsl

 adsl:
     new -i ng0 adsl adsl
     set bundle authname usuario <i class=conum data-value=1></i><b>(1)</b>
     set bundle password contraseña <i class=conum data-value=2></i><b>(2)</b>
     set bundle disable multilink

     set link no pap actcomp protocomp
     set link disable chap
     set link accept chap
     set link keep-alive 30 10

     set ipcp no vjcomp
     set ipcp ranges 0.0.0.0/0 0.0.0.0/0

     set iface route default
     set iface disable on-demand
     set iface enable proxy-arp
     set iface idle 0

     open</pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>El nombre de usuario para autentificar con su proveedor.</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td>La contraseña para autentificar con su proveedor.</td></tr></tbody></table></div><div class=paragraph><p>El fichero <span class=filename>mpd.links</span> contiene información a cerca de la, o las conecciones, que desee establecer. Un ejemplo de <span class=filename>mpd.links</span> y que sea acompañante del ejemplo anterior, se muestra a continuación.</p></div><div class="literalblock programlisting"><div class=content><pre>adsl:
     set link type pptp
     set pptp mode active
     set pptp enable originate incoming outcall
     set pptp self 10.0.0.140
     set pptp peer 10.0.0.138</pre></div></div><div class=paragraph><p>La conexión es fácil de inicializarla, al ingresar los siguientes comandos como <code>root</code>.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mpd -b adsl</span></code></pre></div></div><div class=paragraph><p>El estatus de la conexión la puede ver con el comando.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ifconfig ng0
 : <span class=nv>flags</span><span class=o>=</span>88d1&lt;UP,POINTOPOINT,RUNNING,NOARP,SIMPLEX,MULTICAST&gt; mtu 1500
      inet 216.136.204.117 <span class=nt>--</span><span class=o>&gt;</span> 204.152.186.171 netmask 0xffffffff</code></pre></div></div><div class=paragraph><p>Usar mpd es la forma recomendada para conectarse con servicios ADSL con FreeBSD.</p></div></div><div class=sect3><h4 id=_uso_de_pptpclient>25.5.3. Uso de pptpclient<a class=anchor href=#_uso_de_pptpclient></a></h4><div class=paragraph><p>También es posible usar FreeBSD para conectarse a otros servicios PPPoA por medio de <a class=package href=https://cgit.freebsd.org/ports/tree/net/pptpclient/>net/pptpclient</a>.</p></div><div class=paragraph><p>Para conectarse por medio de <a class=package href=https://cgit.freebsd.org/ports/tree/net/pptpclient/>net/pptpclient</a> a un servicio DSL, instale el port o paquete y edite el fichero <span class=filename>/etc/ppp/ppp.conf</span>. Debe ser <code>root</code> para hacer estas operaciones. Un ejemplo de la sección de <span class=filename>ppp.conf</span>, se muestra a continuación. Para mayor información sobre las opciones de <span class=filename>ppp.conf</span>, consulte la página de ayuda de ppp; <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a>.</p></div><div class="literalblock programlisting"><div class=content><pre>adsl:
  set log phase chat lcp ipcp ccp tun command
  set timeout 0
  enable dns
  set authname usuario <i class=conum data-value=1></i><b>(1)</b>
  set authkey contraseña <i class=conum data-value=2></i><b>(2)</b>
  set ifaddr 0 0
  add default HISADDR</pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>Nombre de usuario de la cuenta DSL.</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td>La contraseña de su cuenta.</td></tr></tbody></table></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Debido a que debe poner su contraseña en el fichero <span class=filename>ppp.conf</span> en texto plano, debe asegurarse que nadie tenga acceso de lectura a este fichero. Los siguientes comandos se aseguran de que el fichero solo pueda se leido por <code>root</code>. Ve las páginas de ayuda <a href="https://man.freebsd.org/cgi/man.cgi?query=chmod&amp;sektion=1&amp;format=html">chmod(1)</a> y <a href="https://man.freebsd.org/cgi/man.cgi?query=chown&amp;sektion=8&amp;format=html">chown(8)</a> para mayor información.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># chown root:wheel /etc/ppp/ppp.conf</span>
<span class=c># chmod 600 /etc/ppp/ppp.conf</span></code></pre></div></div></td></tr></tbody></table></div><div class=paragraph><p>Esto abrirá una sesion por medio de PPP con su ruteador DSL. Los módems Ethernet DSL cuentan con una dirección IP de LAN preconfigurada a la cual se puede conectar. En el caso del Alcatel Speedtouch, esta dirección es <code>10.0.0.138</code>. La documentación de su equipo debe indicarle que dirección utiliza. Para abrir el "tunel" e iniciar la sesión ppp, ejecute el siguiente comando.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># pptp dirección proveedor</span></code></pre></div></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><div class=paragraph><p>Puede añadir un símbolo de ampersand ("&") al final de este comando, ya que pptp no retorna al shell por default.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Un dispositivo virtual <span class=filename>tun</span> será creado, para interactuar con los procesos de pptp y ppp. Una vez que regrese al shell puede examinar la conexión por medio del siguiente comando.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% ifconfig tun0
 tun0: <span class=nv>flags</span><span class=o>=</span>8051&lt;UP,POINTOPOINT,RUNNING,MULTICAST&gt; mtu 1500
         inet 216.136.204.21 <span class=nt>--</span><span class=o>&gt;</span> 204.152.186.171 netmask 0xffffff00
         Opened by PID 918</code></pre></div></div><div class=paragraph><p>Si no le es posible conectarse, verifique la configuración de su ruteador, que normalmente es accesible por medio de telnet o de su navegador web. Si aun no puede conectarse examine la salida que da el comando pptp y el contenido del fichero de registro (log) de ppp; <span class=filename>/var/log/ppp.log</span>.</p></div></div></div><div class=sect2><h3 id=slip>25.6. Uso de SLIP<a class=anchor href=#slip></a></h3><div class=sect3><h4 id=slipc>25.6.1. Configurando un cliente SLIP<a class=anchor href=#slipc></a></h4><div class=paragraph><p>Lo siguiente es una forma de configurar FreeBSD para que utilice SLIP, en un red con dirección estática. Para direcciones dinámicas (esto es, donde su dirección cambia cada vez que se conecta), probablemente sea necesario realizar algunos ajustes que complican la configuración.</p></div><div class=paragraph><p>En primer término, es necesario determinar a que puerto serial esta conectado nuestro módem. Mucha gente opta por} contar con un enláce simbólico, tal como <span class=filename>/dev//modem</span>, que apunta al nombre real del dispositivo, <span class=filename>/dev/cuaaN</span>. Esto permite abstenerse de usar el nombre real del dispositivo, en caso de que sea necesario cambiar de puerto nuestro módem. Lo cual puede ser de mucha ayuda, ya que puede ser un fastidio tener que editar un monton de ficheros en <span class=filename>/etc</span> y ficheros de tipo <span class=filename>.kermrc</span> en todo el sistema!.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p><span class=filename>/dev/cuaa0</span> es <span class=filename>COM1</span>, <span class=filename>cuaa1</span> es <span class=filename>COM2</span>, etc.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Asegurese de contar con la siguiente opción en la configuración de su kernel:</p></div><div class="literalblock programlisting"><div class=content><pre>pseudo-device   sl      1</pre></div></div><div class=paragraph><p>Esta opción esta incluida en el archivo del kernel <span class=filename>GENERIC</span>, así que no debe haber problema, claro esta, a menos que lo haya borrado intencionalmente.</p></div><div class=sect4><h5 id=_cosas_que_tiene_que_hacer_solo_una_vez>25.6.1.1. Cosas Que Tiene Que Hacer Solo Una Vez<a class=anchor href=#_cosas_que_tiene_que_hacer_solo_una_vez></a></h5><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Añada el nombre de su maquina, gateway, servidores de nombre a su fichero <span class=filename>/etc/hosts</span>. Este es un ejemplo de mi fichero:</p><div class="literalblock programlisting"><div class=content><pre>127.0.0.1               localhost loghost
136.152.64.181          water.CS.Example.EDU water.CS water
136.152.64.1            inr-3.CS.Example.EDU inr-3 slip-gateway
128.32.136.9            ns1.Example.EDU ns1
128.32.136.12           ns2.Example.EDU ns2</pre></div></div></li><li><p>Asegurese de que cuenta con la opción <code>hosts</code> antes de la opción <code>bind</code>, en su fichero <span class=filename>/etc/host.conf</span>. De lo contrario pueden ocurrir cosas graciosas en su sistema.</p></li><li><p>Edite el fichero <span class=filename>/etc/rc.conf</span>.</p><div class="olist loweralpha"><ol class=loweralpha type=a><li><p>Especifique su nombre host al editar la línea que dice:</p><div class="literalblock programlisting"><div class=content><pre>hostname=minombre.mi.dominio</pre></div></div><div class=paragraph><p>El nombre completo de su sistema para internet, debe ser escrito en este punto.</p></div></li><li><p>Añada el dispositivo <span class=filename>sl0</span> a la lista de dispositivos de red, al cambiar la línea que dice:</p><div class="literalblock programlisting"><div class=content><pre>network_interfaces=&#34;lo0&#34;</pre></div></div><div class=paragraph><p>a quedar:</p></div><div class="literalblock programlisting"><div class=content><pre>network_interfaces=lo0 sl0</pre></div></div></li><li><p>Añada los parámetros de inicialización del dispositivo sl0, al añadir la línea:</p><div class="literalblock programlisting"><div class=content><pre>ifconfig_sl0=&#34;inet ${hostname} slip-gateway netmask 0xffffff00 up&#34;</pre></div></div></li><li><p>Especificque cual será su ruteador por omisión al editar la línea:</p><div class="literalblock programlisting"><div class=content><pre>defaultrouter=NO</pre></div></div><div class=paragraph><p>a quedar:</p></div><div class="literalblock programlisting"><div class=content><pre>defaultrouter=slip-gateway</pre></div></div></li></ol></div></li><li><p>Edite su fichero <span class=filename>/etc/resolv.conf</span> (si no existe debe crearlo), a que contenga lo siguiente:</p><div class="literalblock programlisting"><div class=content><pre>domain CS.Ejemplo.EDU
nameserver 128.32.136.9
nameserver 128.32.136.12</pre></div></div><div class=paragraph><p>Como puede ver, lo anterior define el nombre de host, de su servidor de nombres. Claro esta, el nombre de dominio y las direcciones IP, dependen de su sistema específico.</p></div></li><li><p>Establezca la contraseña del superusuario <code>root</code> y de su símil <code>toor</code> (y de cualquier otro usuario que aun no cuente con la misma).</p></li><li><p>Reinicie su sistema y asegurese que cuenta con el nombre de host (hostname) correcto.</p></li></ol></div></div></div></div><div class=sect4><h5 id=_haciendo_una_conexión_con_slip>25.6.1.2. Haciendo una Conexión con SLIP<a class=anchor href=#_haciendo_una_conexión_con_slip></a></h5><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Marque el número, teclee en el signo de comando <code>slip</code>, ingrese el nombre y la contraseña. Lo que se requiere ingresar, depende de su sistema. Si utiliza kermit, puede utilizar un script similar al siguiente:</p><div class="literalblock programlisting"><div class=content><pre># kermit setup
set modem hayes
set line /dev/modem
set speed 115200
set parity none
set flow rts/cts
set terminal bytesize 8
set file type binary
# El siguiente macro se encarga de llamar e ingresar al sistema
define slip dial 643-9600, input 10 =&gt;, if failure stop, -
output slip\x0d, input 10 Username:, if failure stop, -
output silvia\x0d, input 10 Password:, if failure stop, -
output ***\x0d, echo \x0aCONNECTED\x0a</pre></div></div><div class=paragraph><p>Claro esta, que debe cambiar el nombre y contraseñ a quedar de acuerdo a sus necesidades. Después de hacer esto, puede simplemente teclear <code>slip</code> en el símbolo de sistema (prompt) de kermit, para realizar la conexión.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>El dejar su contraseña en texto plano, en cualquier parte del sistema, generalmente es una <em>mala</em> idea. Hágalo bajo su propio riesgo.</p></div></td></tr></tbody></table></div></li><li><p>Dejé a kermit en ese punto trabajando (puede suspenderlo tecleando <span class=keyseq><kbd>Ctrl</kbd>+<kbd>z</kbd></span>) y como <code>root</code>, teclee:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># slattach -h -c -s 115200 /dev/modem</span></code></pre></div></div><div class=paragraph><p>Si puede hacer <code>ping</code> a cualquier host que se encuentre del otro lado del ruteador, usted esta conectado!. Si esto no funciona, puede intentar como argumento del comando <code>slattach</code>, la opción <code>-a</code> en lugar de utilizar la optción <code>-c</code>.</p></div></li></ol></div></div></div></div><div class=sect4><h5 id=_como_terminar_la_conexión>25.6.1.3. Como Terminar la Conexión<a class=anchor href=#_como_terminar_la_conexión></a></h5><div class=paragraph><p>Para terminar la conexión haga lo siguiente:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kill -INT `cat /var/run/slattach.modem.pid`</span></code></pre></div></div><div class=paragraph><p>esto terminaraá <code>slattach</code>. Recuerde que para hacer esto, usted debe estar firmado como superusuario (root). Posteriormente dirijase a kermit (puede hacer esto con <code>fg</code> si lo envio a segundo plano) y salga (tecleando <code>q</code>).</p></div><div class=paragraph><p>La página de ayuda de <code>slattach</code> indica que debe utilizar el comando <code>ifconfig sl0 down</code>, para marcar como terminado el uso del dispositivo, pero tal parece que esto no hace una gran diferencia para mi. (<code>ifconfig sl0</code> da el mismo resultado.)</p></div><div class=paragraph><p>En algunas ocasiones, puede que su módem se niegue a cortar la comunicación (el mio lo hace a veces). Si ese es el caso, simplemente inicie de nuevo kermit y vuelva a salir. Normalmente en el segundo intento hay exito.</p></div></div><div class=sect4><h5 id=_problemas_comunes>25.6.1.4. Problemas Comunes<a class=anchor href=#_problemas_comunes></a></h5><div class=paragraph><p>Si esto no funciona, sientase libre de preguntarme. Lo siguiente es una recapitulación de los problemas que más comunmente se presentan:</p></div><div class=ulist><ul><li><p>El no utilizar la opción <code>-c</code> o <code>-a</code> con el comando <code>slattach</code> (Esto debiera se fatal, pero algunos usuarios han reportado que esto ha solucionado sus problemas.</p></li><li><p>Usar la opción <code>s10</code> en vez de usar la opción <code>sl0</code> (puede ser difícil ver la diferencia con algunos tipos de letras).</p></li><li><p>Intente <code>ifconfig sl0</code> para visualizar el estatus de sus dispositivos de red. Por ejemplo, puede ser que obtenga algo similiar a lo siguiente:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig sl0</span>
sl0: <span class=nv>flags</span><span class=o>=</span>10&lt;POINTOPOINT&gt;
        inet 136.152.64.181 <span class=nt>--</span><span class=o>&gt;</span> 136.152.64.1 netmask ffffff00</code></pre></div></div></li><li><p>También el comando <code>netstat -r</code> le mostrará la tabla de ruteo, en caso de que obtenga el mensaje "no route to te host", al hacer <code>ping</code>. Un ejemplo de esto se muestra a continuación:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># netstat -r</span>
Routing tables
Destination      Gateway            Flags     Refs     Use  IfaceMTU    Rtt    Netmasks:

<span class=o>(</span>root node<span class=o>)</span>
<span class=o>(</span>root node<span class=o>)</span>

Route Tree <span class=k>for </span>Protocol Family inet:
<span class=o>(</span>root node<span class=o>)</span> <span class=o>=&gt;</span>
default          inr-3.Example.EDU  UG          8   224515  sl0 -      -
localhost.Exampl localhost.Example. UH          5    42127  lo0 -       0.438
inr-3.Example.ED water.CS.Example.E UH          1        0  sl0 -      -
water.CS.Example localhost.Example. UGH        34 47641234  lo0 -       0.438
<span class=o>(</span>root node<span class=o>)</span></code></pre></div></div><div class=paragraph><p>Esto es después de que el sistema ha estado conectado por un tiempo. Los numeros pueden variar en su sistema.</p></div></li></ul></div></div></div><div class=sect3><h4 id=slips>25.6.2. Estableciendo un Servidor SLIP<a class=anchor href=#slips></a></h4><div class=paragraph><p>Este documento provee sugerencias, para establecer un servidor de SLIP, bajo FreeBSD, lo que generalmente significa configurar su sistema, para que de manera automática inicie los servicios, al firmarse usuarios-clientes remotos en su sistema.</p></div><div class=sect4><h5 id=slips-prereqs>25.6.2.1. Prerequisitos<a class=anchor href=#slips-prereqs></a></h5><div class=paragraph><p>Esta sección es de naturaleza muy técnica, así que contar con antecedentes sobre esto es requerido. Este documento supone que usted cuenta con conocimientos sobre el protocolo de redes TCP/IP, y particularmente, redes y direcciones de nodos, mascaras de red, subneteo, ruteo y protocolos de ruteo, tal como RIP. El configurar servicios SLIP, en un servidor, requiere un conocimiento de estos conceptos, y si usted no esta familiarizado con estos, puede leer una copia, ya sea del libro de Craig Hunt; <em>TCP/IP Networking Administration</em>, publicado por O’Reilly & Associates, Inc. (Numero ISBN 0-937175-82-X), o alguno de los libros de Douglas Comer, sobre protocolos TCP/IP.</p></div><div class=paragraph><p>Se da por un hecho, que usted ha instalado y configurado correctamente su(s) módem(s), así como la configuración de su sistema, para efecto de utilizar el mismo para realizar la conexión. Si usted no lo ha hecho, por favor lea el tutorial sobre configuración de estos servicios; si cuenta con un navegador para la World-Wide Web, puede ver los tutoriales disponibles en <a href=../../../../index.html></a><a href=http://www.FreeBSD.org/ class=bare>http://www.FreeBSD.org/</a>.</p></div><div class=paragraph><p>Puede ser que también desee revisar las páginas de ayuda (<em>man</em>), <a href="https://man.freebsd.org/cgi/man.cgi?query=sio&amp;sektion=4&amp;format=html">sio(4)</a> para información referente a los controladores de dispositivos de puertos en serie, y <a href="https://man.freebsd.org/cgi/man.cgi?query=ttys&amp;sektion=5&amp;format=html">ttys(5)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=gettytab&amp;sektion=5&amp;format=html">gettytab(5)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=getty&amp;sektion=8&amp;format=html">getty(8)</a>, & <a href="https://man.freebsd.org/cgi/man.cgi?query=init&amp;sektion=8&amp;format=html">init(8)</a>, para ver información relevante, sobre la configuración de su sistema, para efecto de que acepte accesos (logins) por medio de un módem, y quizás <a href="https://man.freebsd.org/cgi/man.cgi?query=stty&amp;sektion=1&amp;format=html">stty(1)</a> para información sobre los parámetros de configuración de puertos en serie (tal como <code>clocal</code>, que se utiliza para la conexión directa por medio de puertos seriales).</p></div></div><div class=sect4><h5 id=_echemos_un_vistazo>25.6.2.2. Echemos un Vistazo<a class=anchor href=#_echemos_un_vistazo></a></h5><div class=paragraph><p>En su configuración típica, el desarrollo de FreeBSD como un servidor SLIP, funciona de la siguiente manera: un Usuario SLIP, se conecta del Servidor SLIP FreeBSD e ingresa al sistema con una identificación especial, que utiliza <code>/usr/sbin/sliplogin</code> como shell del usuario. El programa <code>sliplogin</code> busca en el fichero <span class=filename>/etc/sliphome/slip.hosts</span> la línea que haya sido creada especialmente para el usuario, conecta la línea serial a una interfaz SLIP disponible y posteriormente ejecuta el script <span class=filename>/etc/sliphome/slip.login</span>, para configurar la interfaz SLIP.</p></div><div class=sect5><h6 id=_un_ejemplo_de_acceso_al_servidor_slip>25.6.2.2.1. Un Ejemplo de Acceso al Servidor SLIP<a class=anchor href=#_un_ejemplo_de_acceso_al_servidor_slip></a></h6><div class=paragraph><p>Por ejemplo si la clave de acceso de un usuario SLIP fuese <code>Shelmerg</code>, la entrada del usuario <code>Shelmerg</code>, en el fichero <span class=filename>/etc/master.passwd</span> se vera algo similar a lo siguiente:</p></div><div class="literalblock programlisting"><div class=content><pre>Shelmerg:password:1964:89::0:0:Guy Helmer - SLIP:/usr/users/Shelmerg:/usr/sbin/sliplogin</pre></div></div><div class=paragraph><p>Cuando <code>Shelmerg</code> accese al sistema, el comando <code>sliplogin</code>, buscará en el fichero <span class=filename>/etc/sliphome/slip.hosts</span>, una línea, en la cual el ID (identificación) del usuario coincida, por ejemplo, puede ser que en el fichero <span class=filename>/etc/sliphome/slip.hosts</span> exista una línea simliar a la siguiente:</p></div><div class="literalblock programlisting"><div class=content><pre>Shelmerg        dc-slip sl-helmer       0xfffffc00		  autocomp</pre></div></div><div class=paragraph><p>El comando <code>sliplogin</code> encontrará la línea que coincida, enganchará la línea serial a cualquier interfaz SLIP disponible y posteriormente ejecutará <span class=filename>/etc/sliphome/slip.login</span> de manera similar a:</p></div><div class="literalblock programlisting"><div class=content><pre>/etc/sliphome/slip.login 0 19200 Shelmerg dc-slip sl-helmer 0xfffffc00 autocomp</pre></div></div><div class=paragraph><p>Si todo marcha bien, <span class=filename>/etc/sliphome/slip.login</span> creará una configuración, por medio de <code>ifconfig</code>, para la interfaz SLIP, a la cual <code>sliplogin</code> se ha adjuntado (la interfaz slip 0, que era el primer parámetro dado en la lista de <span class=filename>slip.login</span>), para establecer la dirección local IP (<code>dc-slip</code>), la interfaz de la direción IP Remota (<code>sl-helmer</code>), la submascara de red para la interfaz SLIP (<code>0xfffffc00</code>) y cualquier otra opción adicional (<code>autocomp</code>). Si algo no va del todo bien, normalmente <code>sliplogin</code> guarda bastante información para depurar, por medio del <code>demonio</code> (<code>daemon</code>) syslog, que usualmente guarda dicha infomración en <span class=filename>/var/log/messages</span> (vea la página de ayuda <a href="https://man.freebsd.org/cgi/man.cgi?query=syslogd&amp;sektion=8&amp;format=html">syslogd(8)</a> así como <a href="https://man.freebsd.org/cgi/man.cgi?query=syslog.conf&amp;sektion=5&amp;format=html">syslog.conf(5)</a> y quizas el fichero <span class=filename>/etc/syslog.conf</span>, para ver que es lo que <code>syslogd</code> esta almacenando y donde es que lo almacena.</p></div><div class=paragraph><p>OK, basta de ejemplos - entremos de lleno en la configuración del sistema.</p></div></div></div><div class=sect4><h5 id=_configuración_del_kernel_3>25.6.2.3. Configuración del Kernel<a class=anchor href=#_configuración_del_kernel_3></a></h5><div class=paragraph><p>El kernel de FreeBSD, por omisión, cuenta con 2 dispositivos SLIP definidos (<span class=filename>sl0</span> y <span class=filename>sl1</span>); usted puede utilizar <code>netstat -i</code>, para verificar si estos dispositivos se encuentran en el kernel de su sistema.</p></div><div class=paragraph><p>Un ejemplo del resultado de <code>netstat -i</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Name  Mtu   Network     Address            Ipkts Ierrs    Opkts Oerrs  Coll
ed0   1500  &lt;Link&gt;0.0.c0.2c.5f.4a         291311     0   174209     0   133
ed0   1500  138.247.224 ivory             291311     0   174209     0   133
lo0   65535 &lt;Link&gt;                            79     0       79     0     0
lo0   65535 loop        localhost             79     0       79     0     0
sl0<span class=k>*</span>  296   &lt;Link&gt;                             0     0        0     0     0
sl1<span class=k>*</span>  296   &lt;Link&gt;                             0     0        0     0     0</code></pre></div></div><div class=paragraph><p>En este ejemplo vemos que existen dos dispositivos SLIP en el kernel, que son; <span class=filename>sl0</span> y <span class=filename>sl1</span> (el asterisco que aparece después de <code>sl0</code> y <code>sl1</code> indica que los dispositivos no estan "trabajando".)</p></div><div class=paragraph><p>Aun cuando el kernel cuente con los dispositivos, por omisión el kernel de FreeBSD, no viene configurado para enviar paquetes (de hecho su sistema FreeBSD no trabajara como ruteador, por default) esto en base a los requerimientos para Internet, establecidos por los RFCs ( vea 1009 [Requerimentos para Pasarelas (Gateway) en Internet], 1122 [Requerimientos para hosts de Internet - Capas de comunicación] y quizás 1127 [RFC sobre Una Perspectiva de los Requerimientos de Hosts]). Si usted desea que su servidor SLIP sobre FreeBSD, opere como un ruteador, será necesario que edite el fichero <span class=filename>/etc/rc.conf</span> y cambie la opción <code>gateway_enable</code>, a quedar <code>YES</code>, esto habilitará esta función.</p></div><div class=paragraph><p>Será necesario que reinicie su sistema, para efecto de que estos cambios surtan efecto.</p></div><div class=paragraph><p>Al verificar su fichero de configuración del kernel (<span class=filename>/sys/i386/conf/GENERIC</span>), podrá notar que cerca del final, hay una línea como la siguiente:</p></div><div class="literalblock programlisting"><div class=content><pre>pseudo-device sl 2</pre></div></div><div class=paragraph><p>Esta línea es la que define el numero de dispositivos SLIP disponibles en el kernel; el numero al final de la línea es el numero máximo de conecciones SLIP que puede manejar el servidor simultaneamente.</p></div><div class=paragraph><p>Para ayuda con relación a la configuración y compilación del kernel en su sistema FreeBSD, por favor refierase <a href=./#kernelconfig>Configuración del kernel de FreeBSD</a> al apartado correspondiente.</p></div></div><div class=sect4><h5 id=_configuración_de_sliplogin>25.6.2.4. Configuración de Sliplogin<a class=anchor href=#_configuración_de_sliplogin></a></h5><div class=paragraph><p>Como se menciono anteriormente, existen tres ficheros en el directorio <span class=filename>/etc/sliphome</span>, que son parte de la configuración de <span class=filename>/usr/sbin/sliplogin</span> (vea la pagina de ayuda <a href="https://man.freebsd.org/cgi/man.cgi?query=sliplogin&amp;sektion=8&amp;format=html">sliplogin(8)</a> de para ver la ayuda del comando <code>sliplogin</code>): <span class=filename>slip.hosts</span>, que es el fichero que define a los usuarios SLIP, así como sus direcciones IP correspondientes; <span class=filename>slip.login</span>, que normalmente es utilizado para configurar la interfaz de SLIP; y (opcionalmente) <span class=filename>slip.logout</span>, que hace lo opuesto a <span class=filename>slip.login</span>, cuando la conexión serial ha terminado.</p></div><div class=sect5><h6 id=_configuració_de_slip_hosts>25.6.2.4.1. Configuració de <span class=filename>slip.hosts</span><a class=anchor href=#_configuració_de_slip_hosts></a></h6><div class=paragraph><p>El fichero <span class=filename>/etc/sliphome/slip.hosts</span> contiene líneas, que al menos cuentan con cuatro partes, separadas por espacios en blanco:</p></div><div class=ulist><ul><li><p>Identificador (nombre) del usuario SLIP</p></li><li><p>Dirección Local (local para el servidor SLIP) de la liga a SLIP</p></li><li><p>Dirección Remota de la liga a SLIP</p></li><li><p>Mascara de red</p></li></ul></div><div class=paragraph><p>Las direcciones local y remota, pueden ser nombres del host (la resolución de los mismos, es llevada a cabo, por medio de <span class=filename>/etc/hosts</span> o por el servidor de nombres de dominio (DNS), dependiendo de lo que haya especificado en el fichero <span class=filename>/etc/host.conf</span>), y la mascara de red puede ser un nombre, que puede ser resuelto revisando <span class=filename>/etc/networks</span>. En un sistema de ejemplo, el fichero <span class=filename>/etc/sliphome/slip.hosts</span>, puede verse así:</p></div><div class="literalblock programlisting"><div class=content><pre>#
# login local-addr      remote-addr     mask            opt1    opt2
#                                               (normal,compress,noicmp)
#
Shelmerg  dc-slip       sl-helmerg      0xfffffc00      autocomp</pre></div></div><div class=paragraph><p>Al final de la línea puede ver que existen una o más opciones.</p></div><div class=ulist><ul><li><p><code>normal</code> - sin compresión de los encabezados.</p></li><li><p><code>compress</code> - compresión de los encabezados.</p></li><li><p><code>autocomp</code> - compresión automática, si el host remoto lo permite.</p></li><li><p><code>noicmp</code> - deshabilitar los paquetes ICMP (de tal forma que cualquier paquete enviado por "ping" seráa rechazado, en lugar de ocupar de su ancho de banda).</p></li></ul></div><div class=paragraph><p>La elección sobre la dirección local y remota depende si usted va a utilizar una conexión TCP/IP dedicada o bien si va a utilizar una conexión por medio de "proxy ARP" en su servidor SLIP (no es correcto "proxy ARP", pero es la terminología utilizada en esta sección para describirlo). Si usted no esta seguro que metodo manejar o como asignar la dirección IP, por favor refierase a alguno de los libros sobre TCP/IP, que se mencionan en los Prerequisitos de SLIP (<a href=#slips-prereqs>Prerequisitos</a>) y/o consulte al administrador de IP de su red.</p></div><div class=paragraph><p>Si usted piensa subnetear para los diferentes clientes SLIP, será necesario que la dirección de la subred (subnet), salga de la dirección IP que tenga asignada su red, y el numero de cada cliente, del numero que asigne a su subred. Posteriormente puede que sea necesario, o bien configurar una ruta estática a la subred SLIP, por medio de su servidor SLIP en su ruteador más cercano por IP.</p></div><div class=paragraph><p>De otra forma, si usted piensa utilizar un metodo "proxy ARP", será necesario que a sus clientes SLIP, se les asigne una dirección IP, que se encuentre dentro del rango que este utilizando para su subred Ethernet, y tambié será necesario que haga algunos ajustes en los ficheros script <span class=filename>/etc/sliphome/slip.login</span> y en <span class=filename>/etc/sliphome/slip.logout</span>, para que usen <a href="https://man.freebsd.org/cgi/man.cgi?query=arp&amp;sektion=8&amp;format=html">arp(8)</a>, para que maneje la tabla ARP del servidor SLIP y llamados del proxy-ARP.</p></div></div><div class=sect5><h6 id=_slip_login_configuración>25.6.2.4.2. <span class=filename>slip.login</span> Configuración<a class=anchor href=#_slip_login_configuración></a></h6><div class=paragraph><p>El típico fichero <span class=filename>/etc/sliphome/slip.login</span> se ve de la siguiente manera:</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh -
#
#       @(#)slip.login  5.1 (Berkeley) 7/1/90

#
# generic login file for a slip line.  sliplogin invokes this with
# the parameters:
#      1        2         3        4          5         6     7-n
#   slipunit ttyspeed loginname local-addr remote-addr mask opt-args
#
/sbin/ifconfig sl$1 inet $4 $5 netmask $6</pre></div></div><div class=paragraph><p>This <span class=filename>slip.login</span> file merely runs <code>ifconfig</code> for the appropriate SLIP interface with the local and remote addresses and network mask of the SLIP interface.</p></div><div class=paragraph><p>If you have decided to use the "proxy ARP" method (instead of using a separate subnet for your SLIP clients), your <span class=filename>/etc/sliphome/slip.login</span> file will need to look something like this:</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh -
#
#       @(#)slip.login  5.1 (Berkeley) 7/1/90

#
# generic login file for a slip line.  sliplogin invokes this with
# the parameters:
#      1        2         3        4          5         6     7-n
#   slipunit ttyspeed loginname local-addr remote-addr mask opt-args
#
/sbin/ifconfig sl$1 inet $4 $5 netmask $6
# Answer ARP requests for the SLIP client with our Ethernet addr
/usr/sbin/arp -s $5 00:11:22:33:44:55 pub</pre></div></div><div class=paragraph><p>La línea adicional, <code>arp -s $5 00:11:22:33:44:55 pub</code> del script <span class=filename>slip.login</span>, crea una entrada ARP en la tabla del servidor SLIP. Esta entrada le indica al servidor SLIP que debe responder con la dirección MAC de su dispositivo Ethernet, cuando cualquier otro nodo IP en la red, solicite información a la IP del cliente SLIP.</p></div><div class=paragraph><p>Al tomar en cuenta el ejemplo anterior, es importante que sustituya la dirección Ethernet MAC (<code>00:11:22:33:44:55</code>), con la dirección que corresponde a su tarjeta de red, o definitivamente su "proxy ARP" no va a funcionar!. Para efecto de conocer cual es la dirección MAC del dispositivo Ethernet (tarjeta de red), de su servidor SLIP, puede ejecutar el comando <code>netstat -i</code>, el cual tendrá como resultado algo similar a lo siguiente:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>ed0   1500  &lt;Link&gt;0.2.c1.28.5f.4a         191923	0   129457     0   116</code></pre></div></div><div class=paragraph><p>Esto indica que la dirección MAC de su dispositivo Ethernet, en este sistema es <code>00:02:c1:28:5f:4a</code> - los puntos que aparecen en la salida del comando <code>netstat -i</code> deben cambiarse por dos puntos, así mismo deberá de anteponerse un cero, a cada dígito hexadecimal que aparezca sólo (no en pares), de tal forma que convirtamos la dirección en lo que <a href="https://man.freebsd.org/cgi/man.cgi?query=arp&amp;sektion=8&amp;format=html">arp(8)</a> requiere para trabajar; vea la página de ayuda <a href="https://man.freebsd.org/cgi/man.cgi?query=arp&amp;sektion=8&amp;format=html">arp(8)</a>, para ver información completa sobre su uso.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Recuerde que cuando cree los ficheros <span class=filename>/etc/sliphome/slip.login</span> y <span class=filename>/etc/sliphome/slip.logout</span>, deben contar con permisos de ejecución (<code>chmod 755 /etc/sliphome/slip.login /etc/sliphome/slip.logout</code>), de otra forma estos scripts no podrán llevar a cabo su función.</p></div></td></tr></tbody></table></div></div><div class=sect5><h6 id=_configuración_de_slip_logout>25.6.2.4.3. Configuración de <span class=filename>slip.logout</span><a class=anchor href=#_configuración_de_slip_logout></a></h6><div class=paragraph><p>El fichero <span class=filename>/etc/sliphome/slip.logout</span> no es indispensable (a menos que vaya a utilizar "proxy ARP"), pero si aun así decide crearlo, el siguiente es un ejemplo básico del script <span class=filename>slip.logout</span> :</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh -
#
#       slip.logout

#
# logout file for a slip line.  sliplogin invokes this with
# the parameters:
#      1        2         3        4          5         6     7-n
#   slipunit ttyspeed loginname local-addr remote-addr mask opt-args
#
/sbin/ifconfig sl$1 down</pre></div></div><div class=paragraph><p>Si usted esta utilizando "proxy ARP", es recomendable que le indique a <span class=filename>/etc/sliphome/slip.logout</span>, que desea eliminar la entrada ARP, para el cliente SLIP:</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh -
#
#       @(#)slip.logout

#
# logout file for a slip line.  sliplogin invokes this with
# the parameters:
#      1        2         3        4          5         6     7-n
#   slipunit ttyspeed loginname local-addr remote-addr mask opt-args
#
/sbin/ifconfig sl$1 down
# Dejar de solicitar respuesta ARP al cliente SLIP
/usr/sbin/arp -d $5</pre></div></div><div class=paragraph><p>El comando <code>arp -d $5</code>, elimina la entrada ARP, que <span class=filename>slip.login</span> de "proxy ARP" añadió al cliente SLIP al ingresar al sistema.</p></div><div class=paragraph><p>Para esta más seguros: asegurese de que el fichero <span class=filename>/etc/sliphome/slip.logout</span> cuenta con los permisos adecuados para su ejecución, una vez que lo ha creado (ej. <code>chmod 755 /etc/sliphome/slip.logout</code>) .</p></div></div></div><div class=sect4><h5 id=_consideraciones_sobre_el_enrutamiento>25.6.2.5. Consideraciones sobre el Enrutamiento<a class=anchor href=#_consideraciones_sobre_el_enrutamiento></a></h5><div class=paragraph><p>Si usted no esta utilizando el metodo "proxy ARP", para efecto de rutear los paquetes entre sus clientes SLIP y el resto de la red (y quizás Internet), deberá de hacer una de las siguientes dos acciones, o bien añadir direcciones estáticas, a su(s) ruteador(es) más cercanos, para que se reenvien los paquetes de la subred de sus clientes SLIP, por medio de su servidor SLIP, o bien tendrá que instalar y configurar <code>gated</code> en su servidor SLIP (que corre FreeBSD!), de tal forma que le indique a su(s) ruteador(es), por medio del protocolo correcto, a cerca de su subred SLIP.</p></div><div class=sect5><h6 id=_direcciones_de_enrutamiento_estáticas>25.6.2.5.1. Direcciones de Enrutamiento Estáticas<a class=anchor href=#_direcciones_de_enrutamiento_estáticas></a></h6><div class=paragraph><p>Añadir direcciones estáticas de enrutamiento puede ser un problema (o imposible si usted no cuenta con la autoridad para hacerlo…​). Si usted cuenta con una red de ruteo-múltiple en su organización, algunos ruteadores, tales como los fabricados por Cisco y Proteon, puede ser que no sea suficiente con el hecho de configurar las rutas estáticas de su subred SLIP, sino que sea necesario indicar que rutas utilizar para informar a cerca de otras rutas, así que algo de experiencia así como determinación para la resolución de problemas serán necesarias para poner la ruta basada-en- ruteo-estático a trabajar.</p></div></div><div class=sect5><h6 id=_ejecutando_gated>25.6.2.5.2. Ejecutando <code>gated</code><a class=anchor href=#_ejecutando_gated></a></h6><div class=paragraph><p>Una alternativa para los dolores de cabeza que pueden dar las redes con ruteo estático, es intalar <code>gated</code> en su servidor SLIP bajo FreeBSD y configurarlo, para que utilice los protocolos de ruteo apropiados (RIP/OSPF/BGP/EGP) para informar a otros ruteadores, a cerca de su subred SLIP. Una vez que lo ha compilado e instalado, deberá crear el fichero <span class=filename>/etc/gated.conf</span>, que configurará a <code>gated</code>; aqui hay un ejemplo, similar al que el autor utilizó en un servidor SLIP FreeBSD:</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p><code>gated</code> es un software propietario y su código fuente no estará disponible al público más (más información en el sitio <a href=http://www.gated.org/>gated</a>). Esta sección solo existe para asegurarse de la compatibilidad con aquellos que usan la versió antigua.</p></div></td></tr></tbody></table></div><div class="literalblock programlisting"><div class=content><pre>#
# gated configuration file for dc.dsu.edu; for gated version 3.5alpha5
# Only broadcast RIP information for xxx.xxx.yy out the ed Ethernet interface
#
#
# tracing options
#
traceoptions &#34;/var/tmp/gated.output&#34; replace size 100k files 2 general ;

rip yes {
  interface sl noripout noripin ;
  interface ed ripin ripout version 1 ;
  traceoptions route ;
} ;

#
# Turn on a bunch of tracing info for the interface to the kernel:
kernel {
  traceoptions remnants request routes info interface ;
} ;

#
# Propagate the route to xxx.xxx.yy out the Ethernet interface via RIP
#

export proto rip interface ed {
  proto direct {
      xxx.xxx.yy mask 255.255.252.0 metric 1; # SLIP connections
  } ;
} ;

#
# Accept routes from RIP via ed Ethernet interfaces

import proto rip interface ed {
  all ;
} ;</pre></div></div><div class=paragraph><p>En el ejemplo anterior, el fichero de configuración <span class=filename>gated.conf</span> transmite información sobre la subred SLIP <em>xxx.xxx.yy</em>, por medio de RIP al dispositivo Ethernet; si usted esta utilizando un dispositivo de red, diferente de <span class=filename>ed</span>, será necesario que modifique el parámetro <span class=filename>ed</span> por el correspondiente. En este ejemplo, el fichero también realiza una busqueda por el fichero <span class=filename>/var/tmp/gated.output</span>, que es un fichero que nos sirve para depurar cualquier error que se presente en la actividad de <code>gated</code>; usted puede desactivar la opción de depuración (debug), si es que <code>gated</code> esta funcionando correctamente. Será necesario que modifique <em>xxx.xxx.yy.</em>, a quedar con la dirección correcta de su subred SLIP (asegurese de modificar también la máscara de red, en la cláusula <code>proto direct</code> también).</p></div><div class=paragraph><p>Una vez que ha instalado y configurado <code>gated</code> en su sistema, necesitará indicarle a FreeBSD que al iniciar el sistema, ejecute el script para <code>gated</code>, en lugar de ejecutar <code>routed</code>. La forma más fácil de hacer esto, es editar las variables de <code>route</code> y <code>router_flags</code>, en el fichero <span class=filename>/etc/rc.conf</span>. Por favor vea la página de ayuda de <code>gated</code>, para ver información sobre los parámetros de la línea-de-comandos.</p></div></div></div></div></div></div></div><div class=sect1><h2 id=mail>Capítulo 26. Electronic Mail<a class=anchor href=#mail></a></h2><div class=sectionbody><div class=sect2><h3 id=mail-synopsis>26.1. Sinopsis<a class=anchor href=#mail-synopsis></a></h3><div class=paragraph><p>El "Correo Electrónico", o "email", es una de las formas de comunicación más usadas hoy en dia. Este capítulo es una introducción básica de cómo poner en marcha un servidor de correo en FreeBSD, aunque no es una guía completa y se han omitido muchos conceptos importantes. Si se necesita información exhaustiva sobre el tema puede recurrirse a los libros listados en <a href=./#bibliography>Bibliografía</a>.</p></div><div class=paragraph><p>Después de leer este capítulo usted sabrá:</p></div><div class=ulist><ul><li><p>Qué software está involucrado en el envío y recepción de correo electrónico.</p></li><li><p>Dónde se encuentran en FreeBSD los ficheros básicos de configuración de sendmail.</p></li><li><p>Cómo bloquear a los "spammers" y evitar el uso no autorizado de su servidor de correo.</p></li><li><p>Cómo instalar y configurar agentes de transferencia de correo (MTA) en su sistema, para reemplazar sendmail.</p></li><li><p>Cómo resolver problemas comunes en servidores de correo.</p></li><li><p>Cómo usar SMTP con UUCP.</p></li><li><p>Cómo usar correo con una conexión dialup.</p></li><li><p>Cómo configurar SMTP con autentificación para más seguridad.</p></li></ul></div><div class=paragraph><p>Antes de leer este capítulo debería usted:</p></div><div class=ulist><ul><li><p>Configurar apropiadamente su conexión de red (<a href=./#advanced-networking>Networking avanzado</a>).</p></li><li><p>Configurar apropiadamente la información de DNS de su servidor de correo (<a href=./#advanced-networking>Networking avanzado</a>).</p></li><li><p>Saber como instalar software adicional (<a href=./#ports>Instalación de aplicaciones: «packages» y ports</a>).</p></li></ul></div></div><div class=sect2><h3 id=mail-using>26.2. Utilización del correo electrónico<a class=anchor href=#mail-using></a></h3><div class=paragraph><p>Existen varios elementos relacionados con el intercambio de correo electrónico. A saber: <a href=#mail-mua>El agente de usuario (Mail User Agent o MUA)</a>, <a href=#mail-mta>El agente de transporte de correo (Mail Transport Agent o MTA)</a>, <a href=#mail-dns>El DNS</a>, <a href=#mail-receive>Las carpetas de correo (Mailboxes)</a>, y por supuesto, <a href=#mail-host>la máquina servidora de correo (mail host)</a>.</p></div><div class=sect3><h4 id=mail-mua>26.2.1. El Agente de Usuario<a class=anchor href=#mail-mua></a></h4><div class=paragraph><p>Entre las opciones más conocidas tenemos: mutt, pine, elm, y <code>mail</code>, junto con programas con interfaz gráfica del estilo de balsa o xfmail por nombrar unos pocos. También existen lectores de correo basados en navegadores web. Los programas de correo basados en navegadores web actúan de pasarela para las transacciones de correo electrónico, entregando dichas transacciones al <a href=#mail-host>"servidor de correo"</a> local, llamando a uno de los <a href=#mail-mta>agentes de transporte de correo</a> disponibles en la máquina local, o entregando dichas transacciones a un agente de transporte remoto utilizando el protocolo TCP.</p></div></div><div class=sect3><h4 id=mail-mta>26.2.2. Agente de Transporte de Correo<a class=anchor href=#mail-mta></a></h4><div class=paragraph><p>FreeBSD viene con sendmail por defecto, pero también se soportan otros dæmones, entre los cuales se encuentran:</p></div><div class=ulist><ul><li><p>exim;</p></li><li><p>postfix;</p></li><li><p>qmail.</p></li></ul></div><div class=paragraph><p>El agente de transporte de correo normalmente posee dos funcionalidades, por un lado se responsabiliza de la recepción y por otro se encarga de entregar el correo de salida. <em>No</em> es responsable de la recolección automática de correo mediante la utilización de protocolos como POP o IMAP, ni se utiliza para que el usuario pueda acceder a las carpetas de correo locales. Para realizar estas otras tareas, se necesitan <a href=#mail-receive>dæmons</a> adicionales.</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Versiones antiguas de sendmail poseen varios problemas de seguridad que pueden facilitar a un atacante el acceso local o remoto a la máquina que ejecuta sendmail. Para evitar dichos problemas de seguridad se recomienda utilizar una versión actualizada de sendmail. Tiene más opciones a la hora de elegir MTA en los <a href=./#ports>Ports de FreeBSD</a>.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=mail-dns>26.2.3. Correo electrónico y DNS<a class=anchor href=#mail-dns></a></h4><div class=paragraph><p>El Sistema de Nombres de Dominio (en inglés DNS) y su correspondiente dæmon (llamado <code>named</code>) constituyen una parte fundamental del procedimiento de entrega de correo electrónico. Para entregar el correo electrónico al destinatario adecuado el dæmon servidor de correo busca el sitio remoto dentro del sistema de DNS.</p></div><div class=paragraph><p>El DNS es la entidad responsable de asociar nombres con direcciones IP, pero además se encarga de almacenar información específica relacionada con la entrega de correo mediante registros de tipo MX. Los registros MX (Mail eXchanger) especifican qué máquina o máquinas están encargadas de recibir correo electrónico para un determinado nombre de dominio. En caso de no existir ningún registro MX para el dominio del destinatario, se busca información almacenada en registros de tipo A para enviar el correo al destino final.</p></div><div class=paragraph><p>Se pueden consultar los registros MX para cualquier dominio utilizando el comando <a href="https://man.freebsd.org/cgi/man.cgi?query=host&amp;sektion=1&amp;format=html">host(1)</a>, como se puede observar en el siguiente ejemplo:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% host <span class=nt>-t</span> mx FreeBSD.org
        FreeBSD.org mail is handled <span class=o>(</span><span class=nv>pri</span><span class=o>=</span>10<span class=o>)</span> by mx1.FreeBSD.org</code></pre></div></div></div><div class=sect3><h4 id=mail-receive>26.2.4. Recepción de correo<a class=anchor href=#mail-receive></a></h4><div class=paragraph><p>La recepción de correo electrónico para su dominio se realiza mediante lo que se conoce como la máquina de correo (mail host). Ésta máquina recoge todo el correo dirigido a su dominio y lo almacena en <span class=filename>mbox</span> (el método por defecto para el almacenamiento de correo) o en formato Maildir, dependiendo de la configuración de la máquina. Una vez que el correo ha sido almacenado con éxito se puede leer en local utilizando aplicaciones como <a href="https://man.freebsd.org/cgi/man.cgi?query=mail&amp;sektion=1&amp;format=html">mail(1)</a> o como mutt, o de forma remota mediante un conjunto de protocolos tales como POP o IMAP. Esto significa que si usted va a leer el correo de forma local no necesita instalar ningún servidor de POP o IMAP.</p></div><div class=sect4><h5 id=pop-and-imap>26.2.4.1. Acceso a carpetas de correo remotas mediante POP e IMAP<a class=anchor href=#pop-and-imap></a></h5><div class=paragraph><p>Para poder acceder a carpetas de correo de forma remota se necesita tener acceso a un servidor de POP o IMAP. Éstos protocolos permiten a los usuarios conectarse a sus carpetas de correo desde ubicaciones remotas de una forma sencilla. Aunque ambos, POP y IMAP, permiten este acceso remoto IMAP ofrece algunas ventajas añadidas, algunas de las cuales son:</p></div><div class=ulist><ul><li><p>El acceso mediante IMAP permite almacenar los correos en el servidor remoto sin necesidad de extraerlos y tener que almacenarlos en local.</p></li><li><p>IMAP soporta actualizaciones concurrentes.</p></li><li><p>IMAP resulta ser extremadamente útil bajo enlaces de baja velocidad puesto que permite a los usuarios recuperar la estructura de los mensajes sin necesidad de bajarse todo el contenido. Además puede realizar tareas tales como búsquedas directas en el servidor con el fin de minimizar la utilización de la red.</p></li></ul></div><div class=paragraph><p>Para instalar un servidor de POP o de IMAP se deben dar los siguientes pasos:</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Seleccionar el servidor IMAP o POP que mejor cumpla a sus necesidades. Los siguientes servidores POP e IMAP son bien conocidos y son firmes candidatos para ello:</p><div class=ulist><ul><li><p>qpopper;</p></li><li><p>teapop;</p></li><li><p>imap-uw;</p></li><li><p>courier-imap;</p></li></ul></div></li><li><p>Instalar el dæmon POP o IMAP de su elección desde el árbol de "ports".</p></li><li><p>Modifique donde sea necesario <span class=filename>/etc/inetd.conf</span> para que el servidor POP o IMAP se ejecute automáticamente.</p></li></ol></div></div></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Tenga en cuenta que tanto POP como IMAP transmiten información, en especial el usuario y la contraseña, en texto plano. Eso significa que si se desea seguridad en la transmisión de la información a través de la red se deben considerar mecanismos adicionales como por ejemplo el encapsulado de la sesión mediante <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh&amp;sektion=1&amp;format=html">ssh(1)</a>. El encapsulado de sesiones se explica en <a href=./#security-ssh-tunneling>Túneles SSH</a>.</p></div></td></tr></tbody></table></div></div><div class=sect4><h5 id=local>26.2.4.2. Acceso a carpetas de correo locales<a class=anchor href=#local></a></h5><div class=paragraph><p>Las carpetas de correo pueden abrirse de forma local utilizando un agente de correo de usuario (MUA) en el servidor donde reside la carpeta. Se suelen usar los programas mutt or <a href="https://man.freebsd.org/cgi/man.cgi?query=mail&amp;sektion=1&amp;format=html">mail(1)</a>.</p></div></div></div><div class=sect3><h4 id=mail-host>26.2.5. El Servidor de Correo (Mail Host)<a class=anchor href=#mail-host></a></h4><div class=paragraph><p>El servidor de correo es el nombre que se usa para identificar a la máquina responsable de la entrega y recepción de correo electrónico dentro de una organización. Ésta máquina puede recibir correo de varios usuarios dentro de su dominio.</p></div></div></div><div class=sect2><h3 id=sendmail>26.3. Configuración de sendmail<a class=anchor href=#sendmail></a></h3><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=sendmail&amp;sektion=8&amp;format=html">sendmail(8)</a> es el agente de transporte de correo (MTA) por defecto de FreeBSD. La responsabilidad de sendmail consiste en aceptar correo de agentes de correo de usuario (MUA) y en entregar dichos correos al agente de transporte de correo apropiado, según se especifique en su archivo de configuración. Sendmail también acepta conexiones de red provinientes de otros agentes de transporte y puede depositar el correo recibido en carpetas locales o o entregarlo a otros programas.</p></div><div class=paragraph><p>sendmail utiliza los siguientes ficheros de configuración:</p></div><table class="tableblock frame-all grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Filename</th><th class="tableblock halign-left valign-top">Function</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/etc/mail/access</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Base de datos de accesos de sendmail</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/etc/mail/aliases</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Carpeta de alias</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/etc/mail/local-host-names</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Listados de máquinas para las que sendmailacepta correo</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/etc/mail/mailer.conf</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Configuración del programa de correo</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/etc/mail/mailertable</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Tabla de entregas de correo</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/etc/mail/sendmail.cf</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Archivo de configuración principal de sendmail</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><span class=filename>/etc/mail/virtusertable</span></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Usuarios virtuales y tablas de dominio</p></td></tr></tbody></table><div class=sect3><h4 id=_etcmailaccess>26.3.1. <span class=filename>/etc/mail/access</span><a class=anchor href=#_etcmailaccess></a></h4><div class=paragraph><p>La base de datos de accesos define qué máquinas o direcciones IP pueden acceder al servidor de correo y quée clase de acceso tienen permitido. Las máquinas se listan junto con las opciones <code>OK</code>, <code>REJECT</code>, <code>RELAY</code> o simplemente junto con un mensaje de error que se entrega a la rutina de gestión de excepciones de sendmail. Las máquinas que se listan junto con la opción <code>OK</code>, que es el valor por defecto, tienen permiso para enviar correo a la máquina servidora siempre y cuando la dirección de correo de destino sea la máquina servidora de correo. Las máquinas listadas junto con la opción <code>REJECT</code> tienen el acceso prohibido a conexiones de correo electrónico con el servidor. Por último las máquinas que poseen la etiqueta <code>RELAY</code> para sus nombres tienen permitido enviar correo para cualquier destino a través de la máquina servidora de correo.</p></div><div class=exampleblock><div class=title>Ejemplo 32. Configuración de la base de datos de acceso de sendmail</div><div class=content><div class="literalblock programlisting"><div class=content><pre>cyberspammer.com                550 We don&#39;t accept mail from spammers
FUENTE.DE.CORREO.INDISCRIMINADO@ 550 We don&#39;t accept mail from spammers
otra.fuente.de.spam             REJECT
okay.cyberspammer.com           OK
128.32                          RELAY</pre></div></div></div></div><div class=paragraph><p>En el ejemplo se pueden observar cinco entradas. Los generadores de correo que coinciden con la parte izquierda de la tabla se ven afectados por la parte acción especificada en la parte derecha. Los primeros dos ejemplos emiten un código de error para la rutina de excepciones de sendmail. El mensaje de error se transmite a la máquina remota cuando se recibe un correo que coincide con la parte izquierda de la tabla. La siguiente entrada rechaza correo de una determinada máquina de internet, <code>otra.fuente.de.spam</code>. La siguiente entrada acepta conexiones de correo de la máquina <code>okay.cyberspammer.com</code>, lo cual es más exacto que la línea de arriba de <code>cyberspammer.com</code>. Las coincidencias más completas tienen precedencia sobre las menos específicas. La última entrada permite actuar como "relay" o pasarela de correo electrónico para aquellas máquinas que posean una dirección IP que comience por <code>128.32</code>. Éstas máquinas podrían enviar correo destinado a otros servidores de correo utilizando el nuestro.</p></div><div class=paragraph><p>Cuando se actualiza este fichero se debe ejecutar <code>make</code> dentro de <span class=filename>/etc/mail/</span> para que se actualice la base de datos.</p></div></div><div class=sect3><h4 id=_etcmailaliases>26.3.2. <span class=filename>/etc/mail/aliases</span><a class=anchor href=#_etcmailaliases></a></h4><div class=paragraph><p>La base de datos de alias contiene una lista de directorios virtuales que son traducidas a otros usuarios, ficheros, programas o incluso otros alias. A continuación se muestran unos pocos ejemplos de la sintáxis que se puede utilizar dentro del fichero <span class=filename>/etc/mail/aliases</span>:</p></div><div class=exampleblock><div class=title>Ejemplo 33. Mail Aliases</div><div class=content><div class="literalblock programlisting"><div class=content><pre>root: usuariolocal
ftp-bugs: joe,eric,paul
bit.bucket:  /dev/null
procmail: &#34;|/usr/local/bin/procmail&#34;</pre></div></div></div></div><div class=paragraph><p>El formato del fichero es sencillo; el nombre de la carpeta de correo que aparece a la izquierda de los dos puntos se traduce al/los destinos de la derecha. El primer ejemplo simplemente traduce la carpeta <code>root</code> a la carpeta <code>usuariolocal</code>, la cual se examina de nuevo utilizando la misma base de datos de alias, y si no existe ninguna otra coincidencia el mensaje se entrega al usuario local <code>usuariolocal</code>. En el ejemplo siguiente se muestra una lista de correo. Todo correo que se envía a la carpeta <code>ftp-bugs</code> se traduce en un envío para tres carpetas locales diferentes: <code>joe</code>, <code>eric</code> y <code>paul</code>. Es importante señalar que también se pueden especificar carpetas remotas mediante la forma <code>usuario@ejemplo.com</code>. El siguiente ejemplo muestra la escritura del correo a un fichero, en este caso en <span class=filename>/dev/null</span>. El último ejemplo muestra el envió de correo a un programa; en este caso el mensaje de correo se escribe en la entrada estándar del programa <span class=filename>/usr/local/bin/procmail</span> utilizando una tubería (o " pipe") de UNIX®.</p></div><div class=paragraph><p>Cuando se actualiza este fichero se debe ejecutar <code>make</code> dentro de <span class=filename>/etc/mail/</span> para actualizar la base de datos.</p></div></div><div class=sect3><h4 id=_etcmaillocal_host_names>26.3.3. <span class=filename>/etc/mail/local-host-names</span><a class=anchor href=#_etcmaillocal_host_names></a></h4><div class=paragraph><p>Este archivo es una lista de nombres de máquinas que <a href="https://man.freebsd.org/cgi/man.cgi?query=sendmail&amp;sektion=8&amp;format=html">sendmail(8)</a> acepta como nombres locales. Se suele utilizar para escribir aquellos dominios o máquinas de los cuales sendmail va a recibir correo. Por ejemplo, si nuestro servidor de correo va a aceptar correo proveniente del dominio <code>ejemplo.com</code> y también de la máquina <code>mail.ejemplo.com</code> nuestro <span class=filename>local-host-names</span> debería ser algo así:</p></div><div class="literalblock programlisting"><div class=content><pre>ejemplo.com
mail.ejemplo.com</pre></div></div><div class=paragraph><p>Cuando se actualiza este fichero <a href="https://man.freebsd.org/cgi/man.cgi?query=sendmail&amp;sektion=8&amp;format=html">sendmail(8)</a> necesita ser reiniciado para que tenga en cuenta los cambios.</p></div></div><div class=sect3><h4 id=_etcmailsendmail_cf>26.3.4. <span class=filename>/etc/mail/sendmail.cf</span><a class=anchor href=#_etcmailsendmail_cf></a></h4><div class=paragraph><p>Archivo de configuración principal de sendmail, controla el comportamiento global de sendmail, incluyendo cualquier tarea desde la reescritura de direcciones de correo electrónico hasta la devolución de mensajes de error a los servidores de correo remotos. Es evidente que con un abanico tan diverso el fichero de configuración acaba por ser bastante complejo y sus detalles quedan fuera de los objetivos de esta sección. Afortunadamente este fichero raras veces necesita ser modificado, al menos en lo que respecta a servidores de correo estándar.</p></div><div class=paragraph><p>El fichero de configuración principal de sendmail se puede construir a partir de <a href="https://man.freebsd.org/cgi/man.cgi?query=m4&amp;sektion=1&amp;format=html">m4(1)</a>, es decir, macros que se utilizan para definir características y comportamientos específicos de sendmail. Se ruega al lector consultar <span class=filename>/usr/src/contrib/sendmail/cf/README</span> para obtener más detalles acerca de las distintas macros que se pueden utilizar.</p></div><div class=paragraph><p>Cuando se realizan cambios a este fichero sendmail debe ser reiniciado para que los cambios surtan efecto.</p></div></div><div class=sect3><h4 id=_etcmailvirtusertable>26.3.5. <span class=filename>/etc/mail/virtusertable</span><a class=anchor href=#_etcmailvirtusertable></a></h4><div class=paragraph><p>El fichero <span class=filename>virtusertable</span> asocia direcciones de correo pertenecientes a dominios y carpetas virtuales con carpetas reales. Estas carpetas pueden ser locales, remotas, alias definidos en <span class=filename>/etc/mail/aliases</span> o incluso ficheros.</p></div><div class=exampleblock><div class=title>Ejemplo 34. Ejemplo de asociación de correo de dominio virtual</div><div class=content><div class="literalblock programlisting"><div class=content><pre>root@ejemplo.com                root
postmaster@ejemplo.com          postmaster@noc.ejemplo.net
@ejemplo.com                    joe</pre></div></div></div></div><div class=paragraph><p>En el ejemplo superior se observa una asociación para el dominio <code>ejemplo.com</code>. Este fichero se procesa de arriba a abajo buscando la primera coincidencia. La primera entrada asocia <code>root@ejemplo.com</code> con la carpeta de correo local denominada <code>root</code>. La siguiente entrada asocia <code>postmaster@ejemplo.com</code> con la carpeta <code>postmaster</code> situada en la máquina <code>noc.ejemplo.net</code>. Por último, si no se ha encontrado ninguna coincidencia para <code>ejemplo.com</code> se le asigna la última asociación, la cual asocia cualquier mensaje de correo proveniente de <code>ejemplo.com</code> con la carpeta de correo local denominada <code>joe</code>.</p></div></div></div><div class=sect2><h3 id=mail-changingmta>26.4. Sustitución del Agente de Transferencia de Correo<a class=anchor href=#mail-changingmta></a></h3><div class=paragraph><p>Como ya se ha comentado FreeBSD viene con sendmail ya instalado como agente de transferencia de correo por defecto. De esta forma sendmail se encarga de gestionar el correo entrante y saliente.</p></div><div class=paragraph><p>No obstante, debido a distintas razones algunos administradores de sistemas prefieren utilizar otro MTA. Estas razones varían desde simplemente querer probar otros programas de transferencia de correo, hasta la necesidad de utilizar un determinado programa que hace uso de una función específica de un agente determinado. Por suerte cualesquiera que sean estas razones FreeBSD posee un sencillo procedimiento para sustituir a sendmail.</p></div><div class=sect3><h4 id=_instalación_de_un_nuevo_mta>26.4.1. Instalación de un nuevo MTA<a class=anchor href=#_instalación_de_un_nuevo_mta></a></h4><div class=paragraph><p>Existen una amplia gama de MTA alternativos a sendmail. Un buen punto de partida es el <a href=./#ports>Sistema de Ports de FreeBSD</a>, donde se pueden localizar varios. Por supuesto el usuario tiene libertad para utilizar cualquier MTA, siempre y cuando se pueda ejecutar en FreeBSD sin problemas.</p></div><div class=paragraph><p>Lo primero es instalar el nuevo MTA. Una vez que está instalado normalmente se tiene la oportunidad para decidir si realmente cubre las necesidades y también se tiene la oportunidad de configurar el nuevo software antes de sustituir a sendmail. El usuario debe tener en cuenta que el nuevo MTA puede sobreescribir algunos binarios del sistema como por ejemplo <span class=filename>/usr/bin/sendmail</span>. En cualquier caso el nuevo software de correo suele entrar en funcionamiento con una configuración por defecto.</p></div><div class=paragraph><p>Por favor, recuerde que se recomienda leer la documentación del MTA seleccionado para obtener más información.</p></div></div><div class=sect3><h4 id=_desactivación_de_la_aplicación_sendmail>26.4.2. Desactivación de la aplicación sendmail<a class=anchor href=#_desactivación_de_la_aplicación_sendmail></a></h4><div class=paragraph><p>El procedimiento utilizado para ejecutar sendmail cambió significativamente entre las releases 4.5-RELEASE y 4.6-RELEASE. De esta forma el procedimiento utilizado para la desactivación hoy en día es sutílmente distinto al utilizado en dichas distribuciones.</p></div><div class=sect4><h5 id=_freebsd_4_5_stable_antes_de_200244_y_anteriores_incluyendo_4_5_release_y_anteriores>26.4.2.1. FreeBSD 4.5-STABLE antes de 2002/4/4 y anteriores (Incluyendo 4.5-RELEASE y anteriores)<a class=anchor href=#_freebsd_4_5_stable_antes_de_200244_y_anteriores_incluyendo_4_5_release_y_anteriores></a></h5><div class=paragraph><p>Introducir:</p></div><div class="literalblock programlisting"><div class=content><pre>sendmail_enable=&#34;NO&#34;</pre></div></div><div class=paragraph><p>dentro de <span class=filename>/etc/rc.conf</span>. Esta variable desactiva el servicio de recepción de correo de sendmail, pero salvo que se modifique (ver más adelante) el fichero <span class=filename>/etc/mail/mailer.conf</span> sendmail todavía será la aplicación elegida para enviar correo electrónico.</p></div></div><div class=sect4><h5 id=_freebsd_4_5_stable_desde_de_200244_incluyendo_4_6_release_y_posteriores>26.4.2.2. FreeBSD 4.5-STABLE desde de 2002/4/4 (Incluyendo 4.6-RELEASE y posteriores)<a class=anchor href=#_freebsd_4_5_stable_desde_de_200244_incluyendo_4_6_release_y_posteriores></a></h5><div class=paragraph><p>Para poder desactivar completamente sendmail haga lo siguiente:</p></div><div class="literalblock programlisting"><div class=content><pre>sendmail_enable=&#34;NONE&#34;</pre></div></div><div class=paragraph><p>dentro del fichero <span class=filename>/etc/rc.conf.</span></p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Se desactiva el servicio de correo de salida de sendmail. Es importanque que se reemplace con un sistema de entrega de correo alternativo que sea totalmente funcional. En caso contrario funciones del sistema FreeBSD tales como <a href="https://man.freebsd.org/cgi/man.cgi?query=periodic&amp;sektion=8&amp;format=html">periodic(8)</a> no podrán entregar sus resultados por correo eletrónico tal y como normalmente hacen. Varias partes del sistema FreeBSD esperan disponer de un sistema de correo funcional compatible con sendmail. Si las aplicaciones continúan utilizando los binarios de sendmail para realizar envíos de correo después de su desactivación el correo podría ser almacenado en una cola inactiva de sendmail, en cuyo caso nunca se entregaría.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Si sólo se quiere desactivar el servicio de correo de entrada de sendmail, basta con establecer la variable:</p></div><div class="literalblock programlisting"><div class=content><pre>sendmail_enable=&#34;NO&#34;</pre></div></div><div class=paragraph><p>dentro de <span class=filename>/etc/rc.conf</span>. En <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.sendmail&amp;sektion=8&amp;format=html">rc.sendmail(8)</a> tiene más información sobre las opciones de arranque de sendmail.</p></div></div></div><div class=sect3><h4 id=_ejecución_del_nuevo_mta_en_el_arranque>26.4.3. Ejecución del nuevo MTA en el arranque<a class=anchor href=#_ejecución_del_nuevo_mta_en_el_arranque></a></h4><div class=paragraph><p>Existen dos métodos alternativos para ejecutar el nuevo MTA en el arranque, dependiendo de la versión de FreeBSD que se esté ejecutando.</p></div><div class=sect4><h5 id=_freebsd_4_5_stable_antes_de_2002411_incluyendo_4_5_release_y_anteriores>26.4.3.1. FreeBSD 4.5-STABLE antes de 2002/4/11 (Incluyendo 4.5-RELEASE y anteriores)<a class=anchor href=#_freebsd_4_5_stable_antes_de_2002411_incluyendo_4_5_release_y_anteriores></a></h5><div class=paragraph><p>Se debe añadir un script en <span class=filename>/usr/local/etc/rc.d/</span> cuyo nombre termine en <span class=filename>.sh</span> y que sea ejecutable por <code>root</code>. El script debe aceptar los parámetros <code>start</code> y <code>stop</code>. Cuando el sistema FreeBSD se está inicializando, los scripts de arranque ejecutarán el siguiente comando:</p></div><div class="literalblock programlisting"><div class=content><pre>/usr/local/etc/rc.d/supermailer.sh start</pre></div></div><div class=paragraph><p>La misma orden se puede utilizar también para ejecutar el servidor de forma manual. Cuando el sistema se está reiniciando los scripts del sistema ejecutan los ficheros ubicados en <span class=filename>/usr/local/etc/rc.d/</span> utilizando la opción <code>stop</code>, en nuestro caso:</p></div><div class="literalblock programlisting"><div class=content><pre>/usr/local/etc/rc.d/supermailer.sh stop</pre></div></div><div class=paragraph><p>Dicho comando tambíen se puede utilizar para detener el servidor de correo de forma manual cuando el sistema FreeBSD se ejecuta con normalidad.</p></div></div><div class=sect4><h5 id=_freebsd_4_5_stable_después_de_2002411_incluyendo_4_6_release_y_posteriores>26.4.3.2. FreeBSD 4.5-STABLE después de 2002/4/11 (Incluyendo 4.6-RELEASE y posteriores)<a class=anchor href=#_freebsd_4_5_stable_después_de_2002411_incluyendo_4_6_release_y_posteriores></a></h5><div class=paragraph><p>Con las últimas versiones de FreeBSD se puede utilizar el método anterior pero también se puede especificar</p></div><div class="literalblock programlisting"><div class=content><pre>mta_start_script=&#34;nombre_de_fichero&#34;</pre></div></div><div class=paragraph><p>dentro de <span class=filename>/etc/rc.conf</span>, donde <em>nombre_de_fichero</em> es el nombre de algún script que se ejecuta en tiempo de arranque para inicializar el nuevo MTA.</p></div></div></div><div class=sect3><h4 id=_sustitución_de_sendmail_como_el_agente_de_transporte_de_correo_predeterminado>26.4.4. Sustitución de sendmail como el agente de transporte de correo predeterminado.<a class=anchor href=#_sustitución_de_sendmail_como_el_agente_de_transporte_de_correo_predeterminado></a></h4><div class=paragraph><p>El programa sendmail es tan imprescindible y es utilizado por tal multitud de programas en los sistemas UNIX® que algunos programas simplemente asumen que sendmail se encuentra instalado y configurado dentro del sistema. Por esta razón varios MTAs alternativos proporcionan su propia implementación de la interfaz de línea de comandos que posée sendmail; esto facilita que se puedan utilizar como sustitutos de sendmail sin mayores dificultades.</p></div><div class=paragraph><p>Por lo tanto si desea utilizar un agente de transporte de correo alternativo debe asegurarse de que todo software que intente ejecutar binario de sendmail estándar, <span class=filename>/usr/bin/sendmail</span>, realmente ejecute el nuevo MTA en su lugar. Por fortuna FreeBSD proporciona un sistema llamado <a href="https://man.freebsd.org/cgi/man.cgi?query=mailwrapper&amp;sektion=8&amp;format=html">mailwrapper(8)</a> que realiza precisamente esta tarea.</p></div><div class=paragraph><p>Cuando sendmail está funcionando se debe localizar algo como lo siguiente dentro del fichero <span class=filename>/etc/mail/mailer.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>sendmail	 /usr/libexec/sendmail/sendmail
send-mail	/usr/libexec/sendmail/sendmail
mailq		/usr/libexec/sendmail/sendmail
newaliases	/usr/libexec/sendmail/sendmail
hoststat	/usr/libexec/sendmail/sendmail
purgestat	/usr/libexec/sendmail/sendmail</pre></div></div><div class=paragraph><p>Esto significa que cuando cualquiera de estos comandos (por ejemplo <span class=filename>sendmail</span> mísmamente) se ejecutan el sistema ejecutará en su lugar una copia del el sistema ejecuta en su lugar una copia del " mailwrapper" denominada <span class=filename>sendmail</span> que chequea el fichero <span class=filename>mailer.conf</span> y ejecuta <span class=filename>/usr/libexec/sendmail/sendmail</span>. Este sistema permite cambiar de una forma sencilla los binarios que se ejecutan realmente cuando se invocan las funciones de <span class=filename>sendmail</span>.</p></div><div class=paragraph><p>Si se quiere que ejecutar <span class=filename>/usr/local/supermailer/bin/sendmail-compat</span> en lugar de sendmail se puede cambiar el fichero <span class=filename>/etc/mail/mailer.conf</span> para que contenga lo siguiente:</p></div><div class="literalblock programlisting"><div class=content><pre>sendmail	 /usr/local/supermailer/bin/sendmail-compat
send-mail	/usr/local/supermailer/bin/sendmail-compat
mailq		/usr/local/supermailer/bin/mailq-compat
newaliases	/usr/local/supermailer/bin/newaliases-compat
hoststat	/usr/local/supermailer/bin/hoststat-compat
purgestat	/usr/local/supermailer/bin/purgestat-compat</pre></div></div></div><div class=sect3><h4 id=_últimos_pasos>26.4.5. Últimos Pasos<a class=anchor href=#_últimos_pasos></a></h4><div class=paragraph><p>Una vez que todo estáconfigurado a su gusto hay que matar los procesos de sendmail que ya no se necesitan y ejecutar los procesos pertenecientes al nuevo software de MTA, o utilizar la opción más sencilla: reiniciar la máquina. Reinicar la máquina nos brinda la oportunidad de comprobar que se ha configurado correctamente el arranque del sistema para que ejecute de forma automática el nuevo MTA.</p></div></div></div><div class=sect2><h3 id=mail-trouble>26.5. Depuración de Problemas<a class=anchor href=#mail-trouble></a></h3><div class=sect3><h4 id=_por_qué_tengo_que_utilizar_el_fqdn_para_las_máquinas_de_mi_organización>26.5.1. ?Por qué tengo que utilizar el FQDN para las máquinas de mi organización?<a class=anchor href=#_por_qué_tengo_que_utilizar_el_fqdn_para_las_máquinas_de_mi_organización></a></h4><div class=paragraph><p>Probablemente se deba a que la máquina de correo se encuentra en un dominio diferente; si por ejemplo la máquina de correo se encuentra en <code>foo.bar.edu</code> y se desea alcanzar una máquina llamada <code>mumble</code> en el dominio <code>bar.edu</code> se tiene que referir a ella mediante un nombre de dominio completo ("fully-quailified domain name" o FQDN), en éste caso <code>mumble.bar.edu</code> en lugar de referirse a ella simplemente como <code>mumble</code>.</p></div><div class=paragraph><p>Tradicionalmente, la referencia incompleta era posible utilizando "resolvers" de BSD BIND. No obstante la versión de BIND que en la actualidad se ofrece con FreeBSD ya no permite por defecto el uso de dichas abreviaturas salvo para aquellas máquinas que pertenecen al dominio al que su sistema pertenezca. Una máquina como <code>mumble</code> será buscada como <code>mumble.foo.bar.edu</code> o la búsqueda será redireccionada al servidor de dominio raíz del DNS.</p></div><div class=paragraph><p>Esto es distinto a lo que ocurría en versiones anteriores de BIND, donde la búsqueda se producía a través de <code>mumble.bar.edu</code> y de <code>mumble.edu</code>. Se recomienda consultar a la RFC 1535 para conocer el motivo que se considerara una práctica errónea o incluso un agujero de seguridad.</p></div><div class=paragraph><p>Una buena solución a este problema puede ser incluír la siguiente línea</p></div><div class="literalblock programlisting"><div class=content><pre>search foo.bar.edu bar.edu</pre></div></div><div class=paragraph><p>en lugar de</p></div><div class="literalblock programlisting"><div class=content><pre>domain foo.bar.edu</pre></div></div><div class=paragraph><p>dentro del fichero <span class=filename>/etc/resolv.conf</span>. No obstante se debe asegurar de que el orden de búsqueda no se expande más allá del "límite entre la administración local y la administración pública", tal y como se le denomina en la RFC 1535.</p></div></div><div class=sect3><h4 id=_sendmail_dice_mail_loops_back_to_myself_el_correo_vuelve_a_mis_manos>26.5.2. sendmail dice mail loops back to myself (el correo vuelve a mis manos)<a class=anchor href=#_sendmail_dice_mail_loops_back_to_myself_el_correo_vuelve_a_mis_manos></a></h4><div class=paragraph><p>Esta pregunta se responde en las FAQ de sendmail de la siguiente forma:</p></div><div class="literalblock programlisting"><div class=content><pre>Estoy obteniendo los siguientes mensajes de error:

553 MX list for domain.net points back to relay.domain.net
554 &lt;user@domain.net&gt;... Local configuration error

¿Cómo puedo solucionar esto?

Usted ha especificado que el correo para el dominio (por ejemplo,
para el dominio dominio.net) sea reenviado a una máquina determinada
(en este caso relay.dominio.net), para lo que se utiliza un registro
de DNS de tipo MXMX record,
pero la máquina que actúa de relay no se
reconoce a sí misma como perteneciente al dominio dominio.net.
Se debe añadir dominio.net al fichero /etc/mail/local-host-names,
que recibe el nombre de /etc/sendmail.cw en versiones de sendmail previas
a la 8.10.  Se puede utilizar la macro FEATURE(use_cw_file) para indicar
dónde se encuentra el fichero local-host-names; también se
puede añadir Cw dominio.net directamente
al fichero /etc/mail/sendmail.cf</pre></div></div><div class=paragraph><p>Las FAQ de sendmail se pueden encontrar en <a href=http://www.sendmail.org/faq/>http://www.sendmail.org/faq/</a> y son de lectura obligada si se quiere depurar el comportamiento y la configuración de sendmail.</p></div></div><div class=sect3><h4 id=_cómo_puedo_ejecutar_un_servidor_de_correo_utilizando_una_máquina_que_se_conecta_a_internet_mediante_modem_analógico_dial_up>26.5.3. ?Cómo puedo ejecutar un servidor de correo utilizando una máquina que se conecta a internet mediante modem analógico (dial-up) ?<a class=anchor href=#_cómo_puedo_ejecutar_un_servidor_de_correo_utilizando_una_máquina_que_se_conecta_a_internet_mediante_modem_analógico_dial_up></a></h4><div class=paragraph><p>Se quiere conectar una máquina FreeBSD dentro de una LAN a Internet. La máquina FreeBSD será una pasarela de correo para dicha LAN. La conexión mediante PPP no es dedicada.</p></div><div class=paragraph><p>Existen al menos dos formas distintas de hacerlo. Una de ellas consiste en utilizar UUCP.</p></div><div class=paragraph><p>Otra forma consiste en hacerse con un servidor de internet a tiempo completo para proporcionar servicios de agente de transporte secundario para nuestro dominio. Si por ejemplo el dominio de nuestra compañía es <code>ejemplo.com</code>, nuestro proveedor de acceso a internet puede instalar lo siguiente en el DNS:</p></div><div class="literalblock programlisting"><div class=content><pre>ejemplo.com.          MX        10      ejemplo.com.
                      MX        20      ejemplo.net.</pre></div></div><div class=paragraph><p>Nótese que el agente de correo primario es nuestro dominio, ejemplo.com, y además se encuentra configurado un agente de transporte secundario en la máquina ejemplo.net. En este caso sólamente se debe especificar una máquina como receptor final de correo (añadiendo <code>Cw ejemplo.com</code>) al fichero <span class=filename>/etc/mail/sendmail.cf</span> de la máquina <code>example.com</code>)</p></div><div class=paragraph><p>Cuando el <code>sendmail</code> que está enviando el correo trata de entregar dicho correo primero intentará conectarse con nosotros (<code>ejemplo.com</code>) utilizando el enlace de modem. Lo más probable es que la operación termine después de un tiempo de espera debido a que el enlace modem esté caído. La aplicación sendmail automáticamente entregará el correo al servidor especificado como agente de transporte de correo secundario (segundo registro MX), es decir, entregará el correo a nuestro proveedor de servicios de internet (<code>ejemplo.net</code>). El sitio MX secundario tratará de conectarse con nuestra máquina de una forma periódica con el objeto de entregar el correo a la máquina que actúa como agente servidor de correo primario (<code>ejemplo.com</code>).</p></div><div class=paragraph><p>Puede ser de mucha utilidad un script de "login" como el que se muestra a continuación:</p></div><div class="literalblock programlisting"><div class=content><pre>#!/bin/sh
# Ponme en /usr/local/bin/pppmiconexion
( sleep 60 ; /usr/sbin/sendmail -q ) &amp;
/usr/sbin/ppp -direct pppmiconexion</pre></div></div><div class=paragraph><p>Si vamos a crear un script de "login" separado para un usuario determinado se puede utilizar <code>sendmail -qRejemplo.com</code> en lugar del script anterior. Esto obliga a que se procesen de forma inmediata todos los correos que se encuentren en la cola de <code>ejemplo.com</code>.</p></div><div class=paragraph><p>Vamos a dar una vuelta más de tuerca a la situación:</p></div><div class=paragraph><p>Mensaje robado a la <a href=https://lists.FreeBSD.org/subscription/freebsd-isp>Lista de correo de Proveedores de Servicios de Internet en FreeBSD</a>.</p></div><div class="literalblock programlisting"><div class=content><pre>&gt; Nosotros proporcionamos servicio de MX secundario a un cliente nuestro.
&gt; El cliente se conecta a nuestro servidor varias veces al día
&gt; de  forma automática para recoger sus correos para almacenarlos en
&gt; su servidor MX primario (nosotros no llamamos a su organización
&gt; justo cuando nos llega un correo suyo).
&gt; Nuestro sendmail envía la cola de correos cada 30 minutos. En
&gt; estos momentos nuestro cliente tiene que estar al menos 30 minutos
&gt; conectado para asegurarnos de que todo su correo ha sido enviado al
&gt; servidor MX primario.
&gt;
&gt; ?Existe algún comando que permita indicar a sendmail que
&gt; envíe todos los correos de la cola cuando quiera el cliente?
&gt; El cliente no tiene permisos de superusuario en la máquina que
&gt; alberga nuestro agente de transporte, por supuesto.

En la sección de privacy flags del fichero sendmail.cf
existe una definición como ésta:
Opgoaway,restrictqrun

Basta con eliminar restrictqrun para permitir que usuarios sin permisos de
superusuario arranquen el procesamiento de la cola.
Sería conveniente además que reordenaran los registros MX.
Nosotros somos el primer MX para nuestros clientes.
Además de esto hay que especificar:

# Si somos el mejor MX para una determinada máquina, intenta
# utilizarnos directamente en vez de generar un error de
# configuración local.
OwTrue

en el archivo de configuración de sendmail.
Mediante la configuración anterior,
una organización remota entregará sus correos directamente a
usted, sin necesidad de intentar conectarse primero a través de
la conexión del cliente.  La etiqueta &#34;OwTrue&#34; se necesita para evitar
que sendmail genere un mensaje de error.
A continuación ustedes se encargan de entregar el
correo a su(s) respectivo(s) cliente(s) tal como vienen haciendo.

Esta configuración sólo funciona para
máquinas individuales,
de tal forma que se necesita que el cliente especifique su servidor de correo
mediante entradas de tipo A en el DNS.  En concreto se necesita una entrada de
tipo A en el DNS para el dominio del cliente (cliente.com).</pre></div></div></div><div class=sect3><h4 id=_por_qué_me_siguen_saliendo_mensajes_de_error_del_tipo_relaying_denied_cuando_se_trata_de_enviar_correo_proveniente_de_otras_máquinas>26.5.4. ?Por qué me siguen saliendo mensajes de error del tipo Relaying Denied cuando se trata de enviar correo proveniente de otras máquinas?<a class=anchor href=#_por_qué_me_siguen_saliendo_mensajes_de_error_del_tipo_relaying_denied_cuando_se_trata_de_enviar_correo_proveniente_de_otras_máquinas></a></h4><div class=paragraph><p>En las instalaciones del sistema FreeBSD por defecto sendmail se configura para enviar correo sólamente desde la máquina en la cual se está ejecutando. Por ejemplo si un servidor POP está disponible los usuarios serán capaces de consultar su correo desde la universidad, el trabajo u otras localizaciones remotas, pero dichos usuarios podrán enviar correo desde dichas ubicaciones. Es habitual que unos instantes después del envío del correo dichos usuarios reciban un mensaje proveniente del MAILER-DAEMON con un error como <code>5.7 Relaying Denied</code>.</p></div><div class=paragraph><p>Existen varias formas de solventar este problema. La más sencilla consiste en escribir la dirección IP de su proveedor de servicios dentro del fichero <span class=filename>/etc/mail/relay-domains</span>. Una forma rápida de hacerlo sería:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># echo &#34;un.isp.ficticio.com&#34; &gt; /etc/mail/relay-domains</span></code></pre></div></div><div class=paragraph><p>Después de crear o editar dicho fichero se debe reiniciar sendmail. Esto funciona perfectamente si usted es el administrador del servidor y no desea enviar correo localmente o si prefiere utilizar un cliente de correo o cualquier otro sistema en otra máquina distinta a la que alberga el servidor de correo. Es muy útil sobre todo cuando sólamente se tienen una o dos direcciones de correo eletrónico. Si hay en liza un gran número de direcciones de correo, edite el fichero anterior con su editor de texto favorito y añada uno a uno los correspondientes dominios.</p></div><div class="literalblock programlisting"><div class=content><pre>un.isp.ficticio.com
otro.isp.ficticio.net
y.otro.isp.ficticio.org
www.ejemplo.org</pre></div></div><div class=paragraph><p>Ahora, cualquier correo enviado a través de su sistema por cualquier máquina que se encuentre en este fichero (siempre y cuando el usuario tenga una cuenta en nuestro sistema) podrá ser enviado con éxito. Es una manera elegante de permitir a los usuarios enviar correo eletrónico desde nuestro servidor de correo sin permitir al resto del mundo que haga lo mismo (lo que se conoce como SPAM).</p></div></div></div><div class=sect2><h3 id=mail-advanced>26.6. Conceptos Avanzados<a class=anchor href=#mail-advanced></a></h3><div class=paragraph><p>La siguiente sección trata conceptos más específicos relacionados con la configuración del correo y la implantación del servicio de correo en una organización.</p></div><div class=sect3><h4 id=mail-config>26.6.1. Configuración Básica<a class=anchor href=#mail-config></a></h4><div class=paragraph><p>Por defecto debemos ser capaces de enviar correo a máquinas externas, siempre y cuando tengamos nuestro <span class=filename>/etc/resolv.conf</span> bien configurado o ejecutemos nuestro propio servidor de nombres. Si queremos que el correo para nuestra máquina se nos entregue en nuestra propia máquina, es decir, a nuestro propio sendmail, en lugar de tener que ir a recogerlo al servidor de correo de nuestra organización, podemos usar dos métodos:</p></div><div class=ulist><ul><li><p>Ejecutar nuestro propio servidor de nombres y comprar nuestro propio dominio. Por ejemplo <code>FreeBSD.org</code></p></li><li><p>Conseguir la entrega de correo directa hacia nuestra máquina. Esto se logra entregando el correo a la dirección IP que se asocia al nombre de DNS de nuestra máquina. Por ejemplo <code>ejemplo.FreeBSD.org</code>.</p></li></ul></div><div class=paragraph><p>Independientemente de la opción elegida para tener entrega directa en nuestra máquina debemos poseer una dirección IP estática (a diferencia de las direcciones dinámicas, que son utilizadas en configuraciones donde se utiliza el protocolo PPP). Si nos encontramos detrás de un cortafuegos se debe permitir el tráfico SMTP (puerto 25) hacia nuestra máquina. Si además queremos recibir correo directamente en nuestra máquina se deben cumplir los siguientes requisitos:</p></div><div class=ulist><ul><li><p>Asegurar que el registro MX de menor numeración de nuestro DNS apunta a la dirección IP de nuestra máquina.</p></li><li><p>Asegurar que no existe ninguna entrada MX en nuestro DNS para nuestra máquina. Es decir, mientras que el registro MX del punto anterior hace referencia al dominio administrativo que gestionamos con nuestro servidor de nombres, en este apartado se quiere destacar que no debe existir ningún registro MX específico para el nombre concreto de nuestra máquina.</p></li></ul></div><div class=paragraph><p>Cumpliendo las dos puntualizaciones anteriores podemos recibir correo electrónico mediante entrega directa en nuestra máquina.</p></div><div class=paragraph><p>Por ejemplo:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># hostname</span>
ejemplo.FreeBSD.org
<span class=c># host ejemplo.FreeBSD.org</span>
ejemplo.FreeBSD.org has address 204.216.27.XX</code></pre></div></div><div class=paragraph><p>Si se observa esta configuración la entrega directa de correo para <a href=mailto:su_login@ejemplo.FreeBSD.org>su_login@ejemplo.FreeBSD.org</a> debería funcionar sin problemas (suponiendo que sendmail se está ejecutando correctamente en <code>ejemplo.FreeBSD.org</code>).</p></div><div class=paragraph><p>Si en lugar de lo anterior ve algo como esto:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># host ejemplo.FreeBSD.org</span>
ejemplo.FreeBSD.org has address 204.216.27.XX
ejemplo.FreeBSD.org mail is handled <span class=o>(</span><span class=nv>pri</span><span class=o>=</span>10<span class=o>)</span> by hub.FreeBSD.org</code></pre></div></div><div class=paragraph><p>Todos los correos enviados a nuestro host (<code>ejemplo.FreeBSD.org</code>) serán recogidos por <code>hub</code> bajo el mismo nombre de usuario en lugar de ser enviados directamente a nuestra máquina.</p></div><div class=paragraph><p>La información anterior se gestiona utilizando el servidor de DNS. El registro de DNS que transporta la información de encaminamiento de correo eletrónico es el registro <em>M</em>ail e<em>X</em>change. Si no existe ningún registro MX el correo se entregará a la dirección IP que se obtenga de resolver el nombre de dominio que se encuentre a continuación del nombre de usuario en la dirección de correo de destino (esto es, (después de la @).</p></div><div class=paragraph><p>En un cierto momento la entrada MX para <code>freefall.FreeBSD.org</code> tenía este aspecto:</p></div><div class="literalblock programlisting"><div class=content><pre>freefall		MX	30	mail.crl.net
freefall		MX	40	agora.rdrop.com
freefall		MX	10	freefall.FreeBSD.org
freefall		MX	20	who.cdrom.com</pre></div></div><div class=paragraph><p>Como se puede observar, <code>freefall</code> tenía varias entradas MX. El número de MX más bajo es la máquina que recibe correo directamente si se encuentra disponible; si dicha máquina no está accesible por algún motivo las otras máquinas (llamadas también "MXs de backup") aceptarán los mensajes temporalmente, y los transmitirán de nuevo cuando alguna máquina perteneciente a alguna entrada MX de numeración más baja se encuentre disponible y el proceso se repetirá hasta que se alcance la máquina que tenga el registro MX más bajo.</p></div><div class=paragraph><p>Las organizaciones donde residen los servidores (MX) de backup deberían poseer acceso a internet de una forma independiente para minimizar el riesgo de pérdida de conectividad. Nuestro ISP o cualquier otra organización independiente debería poder proporcionarnos este servicio sin problemas.</p></div></div><div class=sect3><h4 id=mail-domain>26.6.2. Correo para Nuestro Dominio<a class=anchor href=#mail-domain></a></h4><div class=paragraph><p>Para establecer un "mailhost" (servidor de correo) en nuestra organización debemos ser capaces de redirigir el correo destinado a cualquier máquina de nuestra organización hacia nuestro servidor de correo. Básicamente queremos "reclamar" como nuestro cualquier correo destinado a cualquier máquina de nuestro dominio (en este caso <code>*.FreeBSD.org</code>) y desviarlo a nuestro servidor de tal forma que los usuario lean su correo utilizando nuestra máquina servidora.</p></div><div class=paragraph><p>Para hacer las cosas lo más sencillas posible se debe crear una cuenta de usuario (con el mismo <em>nombre de usuario</em>) tanto en el servidor de correo como en la máquina del usuario o destinatario final del correo. <a href="https://man.freebsd.org/cgi/man.cgi?query=adduser&amp;sektion=8&amp;format=html">adduser(8)</a> puede usarse para ello.</p></div><div class=paragraph><p>El servidor de correo debe funcionar como el agente de transporte predeterminado para todas las máquinas de nuestra organización. Esto se realiza mediante la siguiente configuración del DNS:</p></div><div class="literalblock programlisting"><div class=content><pre>ejemplo.FreeBSD.org	A	204.216.27.XX		; Workstation
			MX	10 hub.FreeBSD.org	; Mailhost</pre></div></div><div class=paragraph><p>Esta configuración redirigirá el correo para cualquier estación de trabajo hacia nuestro servidor de correo sin que tengan importancia las direcciones IP asignadas mediante el registro de tipo A. Recordemos que el correo siempre se encamina utilizando primero los registros de tipo MX.</p></div><div class=paragraph><p>Normalmente no podremos realizar esta configuración salvo que estemos ejecutando nuestro propio servidor de DNS para nuestro dominio. Si no es el caso y no es posible ejecutar nuestro propio servidor de DNS debemos comunicarnos con nuestro proveedor de servicios o con quien pueda proporcionarnos servicio de DNS y solicitarle una modificación como la anterior.</p></div><div class=paragraph><p>Si además ofrecemos servicios de alojamiento virtual de correo la siguiente información puede resultar útil. Asumiremos que tenemos un cliente con su propio dominio, por ejemplo <code>cliente1.org</code> y queremos que todo el correo enviado a <code>cliente1.org</code> sea redirigido hasta nuestro servidor de correo, <code>mail.nuestroservidor.com</code>. La entrada necesaria en el DNS debería ser la siguiente:</p></div><div class="literalblock programlisting"><div class=content><pre>cliente1.org		MX	10	mail.nuestroservidor.com</pre></div></div><div class=paragraph><p>No necesitamos <em>ningún</em> registro de tipo A para <code>cliente1.org</code> si sólamente queremos gestionar el correo para ese dominio.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Tenga en cuenta que un ping a <code>cliente1.org</code> no funcionará a menos que exista un registro de tipo A para dicha máquina.</p></div></td></tr></tbody></table></div><div class=paragraph><p>La última cosa que debemos realizar en nuestro servidor de correo es comunicar a sendmail para qué dominios y/o máquinas debe aceptar correo. Existen varias formas en las que se puede realizar esta tarea. Cualquiera de las siguiente funcionará:</p></div><div class=ulist><ul><li><p>Añadir las máquinas deseadas al fichero <span class=filename>/etc/mail/local-host-names</span> si se está utlizando la macro <code>FEATURE(use_cw_file)</code>. Si se está utilizando una versión de sendmail anterior a la 8.10 el fichero que se debe utilizar es <span class=filename>/etc/sendmail.cw</span>.</p></li><li><p>Añadir la línea <code>Cwsu.servidor.com</code> al fichero <span class=filename>/etc/sendmail.cf</span> o <span class=filename>/etc/mail/sendmail.cf</span> si se está utilizando una versión de sendmail posterior a la versión 8.10.</p></li></ul></div></div></div><div class=sect2><h3 id=SMTP-UUCP>26.7. SMTP con UUCP<a class=anchor href=#SMTP-UUCP></a></h3><div class=paragraph><p>La configuración de sendmail que se proporciona con la distribución de FreeBSD está diseñada para organizaciones que se conectan directamente a internet. Las organizaciones que deseén enviar y recibir sus correos utilizando UUCP deben instalar otro fichero de configuración para sendmail.</p></div><div class=paragraph><p>El ajuste de forma manual del archivo <span class=filename>/etc/mail/sendmail.cf</span> es un tema para expertos. La versión 8 de sendmail genera ficheros de configuración mediante el preprocesador <a href="https://man.freebsd.org/cgi/man.cgi?query=m4&amp;sektion=1&amp;format=html">m4(1)</a>, gracias al que las opciones de configuración se pueden escribir utilizando un nivel de abstracción mayor. Los archivos de configuración de <a href="https://man.freebsd.org/cgi/man.cgi?query=m4&amp;sektion=1&amp;format=html">m4(1)</a> se pueden encontrar en <span class=filename>/usr/src/usr.sbin/sendmail/cf</span>.</p></div><div class=paragraph><p>Si no se instaló el sistema base con todas las fuentes el conjunto de ficheros de configuración de sendmail se puede obtener a partir de un paquete de fuentes determinado. Suponiendo que tengamos el CDROM con el código fuente de FreeBSD montado se puede ejecutar:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /cdrom/src</span>
<span class=c># cat scontrib.?? | tar xzf - -C /usr/src/contrib/sendmail</span></code></pre></div></div><div class=paragraph><p>Este comando extrae sólamente unos pocos cientos de kilobytes. El fichero <span class=filename>README</span> que hay en el directorio <span class=filename>cf</span> puede servirle como una introducción básica a la configuración mediante <a href="https://man.freebsd.org/cgi/man.cgi?query=m4&amp;sektion=1&amp;format=html">m4(1)</a>.</p></div><div class=paragraph><p>La mejor forma de soportar la entrega de correo mediante UUCP es utilizando la característica <code>mailertable</code>. Esta característica crea una base de datos que sendmail utiliza para tomar decisiones de encaminamiento.</p></div><div class=paragraph><p>En primer lugar creamon el fichero <span class=filename>.mc</span>. El directorio <span class=filename>/usr/src/usr.sbin/sendmail/cf/cf</span> alberga varios ejemplos del mismo. Suponiendo que nuestro fichero configuración se llama <span class=filename>foo.mc</span> para convertir dicho archivo en un fichero <span class=filename>sendmail.cf</span> válido basta con ejecutar lo siguiente:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/src/usr.sbin/sendmail/cf/cf</span>
<span class=c># make foo.cf</span>
<span class=c># cp foo.cf /etc/mail/sendmail.cf</span></code></pre></div></div><div class=paragraph><p>Un fichero <span class=filename>.mc</span> suele tener este aspecto:</p></div><div class="literalblock programlisting"><div class=content><pre>VERSIONID(`Su número de versión&#39;) OSTYPE(bsd4.4)

FEATURE(accept_unresolvable_domains)
FEATURE(nocanonify)
FEATURE(mailertable, `hash -o /etc/mail/mailertable&#39;)

define(`UUCP_RELAY&#39;, su.relay.uucp)
define(`UUCP_MAX_SIZE&#39;, 200000)
define(`confDONT_PROBE_INTERFACES&#39;)

MAILER(local)
MAILER(smtp)
MAILER(uucp)

Cw    alias.de.su.servidor
Cw    nombredesunodouucp.UUCP</pre></div></div><div class=paragraph><p>Las líneas que contienen <code>accept_unresolvable_domains</code>, <code>nocanonify</code>, y <code>confDONT_PROBE_INTERFACES</code> prohíben la utilización del DNS durante la entrega de correo. La cláusula <code>UUCP_RELAY</code> es necesaria para soportar entrega mediante UUCP. Lo único que hay que hacer es escribir un nombre de máquina en ese punto. Dicha máquina debe ser capaz de gestionar las direcciones del pseudo-dominio .UUCP; en la mayoría de los casos se escribe en este punto el nombre de la máquina perteneciente al proveedor de servicios que hace de relay.</p></div><div class=paragraph><p>Una vez que tenemos esto configurado se necesita un fichero <span class=filename>/etc/mail/mailertable</span>. Si solamente tenemos un enlace con el exterior, que usamos para todos nuestro correos, basta una configuración como la que se muestra a continuación:</p></div><div class="literalblock programlisting"><div class=content><pre>#
# makemap hash /etc/mail/mailertable.db &lt; /etc/mail/mailertable
.                             uucp-dom:su.relay.uucp</pre></div></div><div class=paragraph><p>Un ejemplo más complejo puede parecerse al siguiente:</p></div><div class="literalblock programlisting"><div class=content><pre>#
# makemap hash /etc/mail/mailertable.db &lt; /etc/mail/mailertable
#
horus.interface-business.de   uucp-dom:horus
.interface-business.de        uucp-dom:if-bus
interface-business.de         uucp-dom:if-bus
.heep.sax.de                  smtp8:%1
horus.UUCP                    uucp-dom:horus
if-bus.UUCP                   uucp-dom:if-bus
.                             uucp-dom:</pre></div></div><div class=paragraph><p>Las primeras tres líneas se encargan de manejar casos especiales en los que el correo dirigido directamente al dominio no se envía a la ruta por defecto sino a algún vecino UUCP para acortar el número de saltos involucrados en la entrega de dichos correos. La siguiente línea gestiona el correo para el dominio ethernet local, el cual puede ser entregado utilizando SMTP. Finalmente los vecinos UUCP se mencionan en la notación de pseudo-dominio .UUCP para permitir que un <code>vecino UUCP receptor</code> de correo pueda sobreescribir las reglas por defecto. La última línea siempre es un punto; se asocia con cualquier otra cosa que no ha sido tratada en reglas anteriores y donde se realiza entrega UUCP a un vecino UUCP que sirve como pasarela de correo universal para todo el mundo. Todos los nombres de máquinas bajo la clave <code>uucp-dom:</code> deben ser vecinos UUCP válidos, lo cual se puede verificar utilizando el comando <code>uuname</code>.</p></div><div class=paragraph><p>Recuerde que este fichero debe convertirse en una base de datos DBM antes de que usarse. El comando que se utiliza para realizar esta tarea se suele especificar como un comentario al principio del fichero <span class=filename>mailertable</span>. Cada vez que se modifique el fichero <span class=filename>mailertable</span> se debe ejecutar dicho comando.</p></div><div class=paragraph><p>Un consejo final: si dudamos sobre una determinada ruta de encaminamiento de correo se puede ejecutar sendmail con el parámetro <code>-bt</code>. Este parámetro ejecuta sendmail en <em>modo prueba de direcciones</em>; simplemente basta con escribir <code>3,0</code> seguido por la dirección de correo de la que queremos comprobar su correcto encaminamiento. La última línea nos dice el agente de correo interno que se utiliza, la máquina de destino con que el agente será invocado y la dirección (posiblemente traducida) de correo. Se puede abandonar este modo de funcionamiento escribiendo <span class=keyseq><kbd>Ctrl</kbd>+<kbd>D</kbd></span>.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% sendmail <span class=nt>-bt</span>
ADDRESS TEST MODE <span class=o>(</span>ruleset 3 NOT automatically invoked<span class=o>)</span>
Enter &lt;ruleset&gt; &lt;address&gt;
<span class=o>&gt;</span> 3,0 prueba@ejemplo.com
canonify           input: foo @ example <span class=nb>.</span> com
...
parse            returns: <span class=nv>$# </span>uucp-dom <span class=nv>$@</span> su.relay.uucp <span class=nv>$:</span> prueba &lt; @ ejemplo <span class=nb>.</span> com <span class=nb>.</span> <span class=o>&gt;</span>
<span class=o>&gt;</span> ^D</code></pre></div></div></div><div class=sect2><h3 id=outgoing-only>26.8. Configuración para sólamente enviar correo<a class=anchor href=#outgoing-only></a></h3><div class=paragraph><p>Existen multitud de casos en los que puede bastarnos con enviar nuestro correo a través de una pasarela o relay. He aquí algunos de ellos:</p></div><div class=ulist><ul><li><p>Nuestra computadora es una máquina de escritorio, pero queremos ser capaces de utilizar programas como <a href="https://man.freebsd.org/cgi/man.cgi?query=send-pr&amp;sektion=1&amp;format=html">send-pr(1)</a>. Para ello se debería utilizar el relay de nuestro ISP.</p></li><li><p>Nuestra computadora es un servidor que no gestiona correo de forma local, si no que necesita pasar todos los correos recibidos una pasarela que se encarga de su procesamiento y entrega final.</p></li></ul></div><div class=paragraph><p>Casi cualquier MTA es capaz de actuar como pasarela o relay. Por desgracia configurar un MTA para que sólo gestione correo saliente puede ser muy complicado. Programas del estilo de sendmail y postfix son demasiado pesados para realizar sólamente esta tarea.</p></div><div class=paragraph><p>Si además estamos utilizando un servicio de acceso a internet típico nuestro contrato puede prohibir explícitamente la ejecución de un servidor de correo (o los puertos pueden estar filtrados).</p></div><div class=paragraph><p>La forma más sencilla de utilizar un servicio de pasarela es mediante la instalación del port <a class=package href=https://cgit.freebsd.org/ports/tree/mail/ssmtp/>mail/ssmtp</a>. Basta con ejecutar el siguiente comando como <code>root</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/ports/mail/ssmtp</span>
<span class=c># make install replace clean</span></code></pre></div></div><div class=paragraph><p>Una vez que ha sido instalado <a class=package href=https://cgit.freebsd.org/ports/tree/mail/ssmtp/>mail/ssmtp</a> podemos configurarlo mediante un fichero de sólo cuatro líneas ubicado en <span class=filename>/usr/local/etc/ssmtp/ssmtp.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>root=sudireccionrealdecorreo@ejemplo.com
mailhub=mail.ejemplo.com
rewriteDomain=ejemplo.com
hostname=_HOSTNAME_</pre></div></div><div class=paragraph><p>Debemos asegurarnos de que se utiliza una dirección de correo real para <code>root</code>. Se debe introducir nuestra pasarela de correo en lugar de <code>mail.ejemplo.com</code> (algunos ISP llaman a la pasarela "servidor de correo saliente" o simplemente "servidor SMTP").</p></div><div class=paragraph><p>Debemos asegurarnos de que se desactiva sendmail mediante <code>sendmail_enable="NONE"</code> en <span class=filename>/etc/rc.conf</span>.</p></div><div class=paragraph><p><a class=package href=https://cgit.freebsd.org/ports/tree/mail/ssmtp/>mail/ssmtp</a> acepta algunas otras opciones. Consulte el fichero de ejemplo que encontrará en <span class=filename>/usr/local/etc/ssmtp</span>; consulte también la página de manual de ssmtp, en la que hay más ejemplos e información al respecto.</p></div><div class=paragraph><p>Ejecutar ssmtp de esta forma permite que cualquier software de nuestra computadora que necesite enviar correo funcione sin problemas y a la vez poder cumplir con las normas estipuladas en el contrato con nuestro ISP. Al mismo tiempo evitamos el uso de nuestro servidor de correo por parte de " spammers".</p></div></div><div class=sect2><h3 id=SMTP-dialup>26.9. Utilización del correo con una conexión mediante módem analógico (dial-up)<a class=anchor href=#SMTP-dialup></a></h3><div class=paragraph><p>Si se dispone de una dirección IP privada no es necesario realizar ningún ajuste a partir de la configuración por defecto. Basta con asignar como nombre de nuestra máquina el nombre que tenemos registrado en el DNS y sendmail se encargará del resto.</p></div><div class=paragraph><p>Por otra parte si utilizamos una conexión temporal a internet mediante PPP y se nos asigna una dirección IP de forma dinámica, lo más normal es tener nuestras carpetas de correo alojadas en el servidor de correo de nuestro proveedor de servicios. Supongamos que el dominio de nuestro ISP es <code>ejemplo.net</code> y que nuestro nombre de usuario es <code>usuario</code>; además hemos llamado a nuestra <code>user</code>, además, hemos llamado a nuestra máquina <code>bsd.home</code>, y nuestro ISP nos ha comunicado que debemos utilizar como pasarela la máquina <code>relay.ejemplo.net</code>.</p></div><div class=paragraph><p>Para recuperar correo de nuestra carpeta de correo se debe instalar un agente de recuperación automática de correo. fetchmail es una buena elección puesto que permite utilizar varios protocolos. Este programa está disponible como un paquete y también desde la colección de ports (<a class=package href=https://cgit.freebsd.org/ports/tree/mail/fetchmail/>mail/fetchmail</a>). Normalmente nuestro ISP proporciona POPPOP. Si utilizamos ppp a nivel de usuario se puede recuperar automáticamente el correo cuando se establece la conexión ppp utilizando el fichero <span class=filename>/etc/ppp/ppp.linkup</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>MYADDR:
!bg su user -c fetchmail</pre></div></div><div class=paragraph><p>Si utilizamos sendmail (como se muestra más adelante) para entregar correo a cuentas remotas probablemente queramos que sendmail procese nuestras colas de correo tan pronto como nuestra conexión de internet se establezca. Para ello escriba el siguiente comando tras el comando de <code>fetchmail</code> que hemos escrito antes en el fichero <span class=filename>/etc/ppp/ppp.linkup</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>  !bg su user -c &#34;sendmail -q&#34;</pre></div></div><div class=paragraph><p>Asumiendo que tenemos una cuenta para el usuario <code>usuario</code> en <code>bsd.home</code>. En el directorio "home" del usuario <code>usuario</code> en la máquina <code>bsd.home</code> debemos crear un fichero <span class=filename>.fetchmailrc</span> con el siguiente contenido:</p></div><div class="literalblock programlisting"><div class=content><pre>poll ejemplo.net protocol pop3 fetchall pass Secr3To</pre></div></div><div class=paragraph><p>Este fichero debe tener permisos de lectura sólo para el propio dueño ya que contiene la contraseña de acceso a nuestra cuenta de POP en nuestro ISP (<code>Secr3To</code>).</p></div><div class=paragraph><p>Para poder enviar correo con la cabecera <code>from:</code> correcta, debemos decir a sendmail que utilice <code>usuario@ejemplo.net</code> en vez de <code>usuario@bsd.home</code>. Siguiendo con nuestro ejemplo es necesario decirle a sendmail que envíe todo el correo a través de la pasarela <code>relay.ejemplo.net</code>.</p></div><div class=paragraph><p>El siguiente fichero de configuración <span class=filename>.mc</span> debe ser suficiente para cumplir con las anteriores tareas:</p></div><div class="literalblock programlisting"><div class=content><pre>VERSIONID(`bsd.home.mc version 1.0&#39;)
OSTYPE(bsd4.4)dnl
FEATURE(nouucp)dnl
MAILER(local)dnl
MAILER(smtp)dnl
Cwlocalhost
Cwbsd.home
MASQUERADE_AS(`ejemplo.net&#39;)dnl
FEATURE(allmasquerade)dnl
FEATURE(masquerade_envelope)dnl
FEATURE(nocanonify)dnl
FEATURE(nodns)dnl
define(`SMART_HOST&#39;, `relay.ejemplo.net&#39;)
Dmbsd.home
define(`confDOMAIN_NAME&#39;,`bsd.home&#39;)dnl
define(`confDELIVERY_MODE&#39;,`deferred&#39;)dnl</pre></div></div><div class=paragraph><p>En la sección anterior se explica cómo convertir este fichero <span class=filename>.mc</span> en un fichero de configuración para sendmail, <span class=filename>sendmail.cf</span>. No debemos olvidar reiniciar sendmail después de mofidificar el fichero <span class=filename>sendmail.cf</span>.</p></div></div><div class=sect2><h3 id=SMTP-Auth>26.10. Autentificación utilizando SMTP<a class=anchor href=#SMTP-Auth></a></h3><div class=paragraph><p>La autentificación mediante SMTP puede proporcionarnos diversas ventajas. Añade una capa adicional de seguridad a a sendmail y además proporciona a los usuarios móviles (usuarios que cambian de máquina) la posibilidad de mantener el mismo servidor de correo sin necesidad de reconfigurar sus agentes de usuario de correo cada vez que se trasladan.</p></div><div class="exampleblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Instalar <a class=package href=https://cgit.freebsd.org/ports/tree/security/cyrus-sasl/>security/cyrus-sasl</a> desde los ports. Se puede encontrar dicho port en <a class=package href=https://cgit.freebsd.org/ports/tree/security/cyrus-sasl/>security/cyrus-sasl</a>. <a class=package href=https://cgit.freebsd.org/ports/tree/security/cyrus-sasl/>security/cyrus-sasl</a> posée varias opciones en tiempo de compilación pero para el método en particular que se va a explicar en esta sección basta con asegurarse de seleccionar la opción <code>pwcheck</code>.</p></li><li><p>Después de instalar <a class=package href=https://cgit.freebsd.org/ports/tree/security/cyrus-sasl/>security/cyrus-sasl</a>, edite <span class=filename>/usr/local/lib/sasl/Sendmail.conf</span> (o créelo si no existe) y añada la siguiente línea:</p><div class="literalblock programlisting"><div class=content><pre>pwcheck_method: passwd</pre></div></div><div class=paragraph><p>Este método activa la autentificación de sendmail contra nuestra base de datos de FreeBSD, <span class=filename>passwd</span>. Esto nos evita el problema de tener que crear un nuevo conjunto de usuarios y contraseñas para cada usuario que necesite validarse mediante SMTP y además nos permite mantener el mismo "login" y contraseña que los usuarios utilizan para acceder a sus cuentas para el acceso al correo electrónico.</p></div></li><li><p>Editar <span class=filename>/etc/make.conf</span> y añadir las siguientes líneas:</p><div class="literalblock programlisting"><div class=content><pre>SENDMAIL_CFLAGS=-I/usr/local/include/sasl1 -DSASL
SENDMAIL_LDFLAGS=-L/usr/local/lib
SENDMAIL_LDADD=-lsasl</pre></div></div><div class=paragraph><p>Estas líneas proporcionan a sendmail las opciones de configuración necesarias para enlazar con <a class=package href=https://cgit.freebsd.org/ports/tree/cyrus-sasl/>cyrus-sasl</a> en tiempo de compilación. Debemos asegurarnos de que <a class=package href=https://cgit.freebsd.org/ports/tree/cyrus-sasl/>cyrus-sasl</a> ha sido instalado correctamente recompilar sendmail.</p></div></li><li><p>Recompile sendmail utilizando el siguiente comando:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cd /usr/src/usr.sbin/sendmail</span>
<span class=c># make cleandir</span>
<span class=c># make obj</span>
<span class=c># make</span>
<span class=c># make install</span></code></pre></div></div><div class=paragraph><p>La compilación de sendmail no debería dar problemas siempre y cuando <span class=filename>/usr/src</span> no haya cambiado sustancialmente y siempre y cuando las bibliotecas compartidas necesarias se encuentren disponibles.</p></div></li><li><p>Una vez que sendmail se ha compilado y reinstalado con correctamente debemos editar el fichero <span class=filename>/etc/mail/freebsd.mc</span> (o el fichero que se utilice como <span class=filename>.mc</span> de referencia. Hay administradores que escogen utilizar la salida de <a href="https://man.freebsd.org/cgi/man.cgi?query=hostname&amp;sektion=1&amp;format=html">hostname(1)</a> como el nombre del fichero <span class=filename>.mc</span> que se utiliza para la configuración de sendmail por motivos de uniformidad ). Añada las siguientes líneas a dicho fichero:</p><div class="literalblock programlisting"><div class=content><pre>dnl set SASL options
TRUST_AUTH_MECH(`GSSAPI DIGEST-MD5 CRAM-MD5 LOGIN&#39;)dnl
define(`confAUTH_MECHANISMS&#39;, `GSSAPI DIGEST-MD5 CRAM-MD5 LOGIN&#39;)dnl
define(`confDEF_AUTH_INFO&#39;, `/etc/mail/auth-info&#39;)dnl</pre></div></div><div class=paragraph><p>Estas opciones configuran los distintos métodos de que dispone sendmail para validar a los usuarios de correo. Si se desea utilizar otro método distinto a pwcheck por favor consulte la documentación.</p></div></li><li><p>Para terminar ejecutamos <a href="https://man.freebsd.org/cgi/man.cgi?query=make&amp;sektion=1&amp;format=html">make(1)</a> mientras nos encontramos dentro de <span class=filename>/etc/mail</span>. Este comando trata el fichero <span class=filename>.mc</span> y crea el fichero <span class=filename>.cf</span> correspondiente (con el mismo nombre que el anterior pero terminado en .cf). A continuación se utiliza el comando <code>make install restart</code>, el cual copia el fichero .cf recién generado al fichero <span class=filename>sendmail.cf</span> y a continuación reinicia sendmail. Para más información sobre este proceso puede consultarse el contenido de <span class=filename>/etc/mail/Makefile</span>.</p></li></ol></div></div></div><div class=paragraph><p>Si todo lo anteriormente comentado ha funcionado correctamente deberíamos ser capaces de introducir la información de nuestro "login" en nuestro cliente de correo y enviar un mensaje de prueba. Para investigar más a fondo estos temas se puede habilitar la opción <code>LogLevel</code> de sendmail al valor 13 y observar detenidamente el archivo <span class=filename>/var/log/maillog</span> en busca de posibles mensajes de error.</p></div><div class=paragraph><p>Puede ser necesario añadir las siguientes líneas al fichero <span class=filename>/etc/rc.conf</span> de modo que el servicio explicado en esta sección se encuentre disponible automáticamente desde el arranque:</p></div><div class="literalblock programlisting"><div class=content><pre>sasl_pwcheck_enable=&#34;YES&#34;
sasl_pwcheck_program=&#34;/usr/local/sbin/pwcheck&#34;</pre></div></div><div class=paragraph><p>Esto permite que la inicialización de SMTP_AUTH se produzca durante el arranque del sistema.</p></div><div class=paragraph><p>Para más información por favor visite la página <a href=http://www.sendmail.org/~ca/email/auth.html>autentificación SMTP</a> de sendmail·</p></div></div><div class=sect2><h3 id=mail-agents>26.11. Agente de Correo de Usuario<a class=anchor href=#mail-agents></a></h3><div class=paragraph><p>Un agente de correo de usuario (MUA en inglés Mail User Agent) es una aplicación que se utiliza para enviar y recibir correo. Coomo el correo electrónico está en constante evolución y cada vez se vuelve más complejo y con más opciones, los MUAs son cada vez más complejos y potentes. Esto permite a los usuarios disponer de mayor flexibilidad y funcionalidad. FreeBSD admite para muchísimos agentes de correo de usuario, todos los cuales pueden instalarse desde los <a href=./#ports>Ports</a>. Los usuarios pueden elegir entre lientes de correo con interfaz gráfica como evolution o balsa o entre clientes basados en consola como mutt, pine o <code>mail</code>, e incluso utilizar interfaces web.</p></div><div class=sect3><h4 id=mail-command>26.11.1. mail<a class=anchor href=#mail-command></a></h4><div class=paragraph><p><a href="https://man.freebsd.org/cgi/man.cgi?query=mail&amp;sektion=1&amp;format=html">mail(1)</a> es el agente de correo de usuario (MUA) que viene por defecto con FreeBSD. Es un MUA de consola que ofrece toda la funcionalidad básica necesaria para enviar y recibir correos, aunque resulta limitado limitado en su capacidad para manejar adjuntos y sólamente soporta carpetas de correo locales.</p></div><div class=paragraph><p>Aunque <code>mail</code> no soporta de forma nativa la interacción con servidores de correo mediante POP o IMAP estas carpetas de correo remotas pueden descargarse a un fichero <span class=filename>mbox</span> local utilizando una aplicación de descarga como fetchmail, que se describe en este mismo capítulo en (<a href=#mail-fetchmail>Manejo de fetchmail</a>).</p></div><div class=paragraph><p>Para enviar y recibir correo eletrónico basta con ejecutar el comando <code>mail</code>. Veamos un ejemplo:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% mail</code></pre></div></div><div class=paragraph><p>El contenido de la carpeta de usuario en el directorio <span class=filename>/var/mail</span> se leen automáticamente. Si la carpeta se encuentra vacía la aplicación termina su ejecución con un mensaje que indica que no ha podido encontrar correo. Una vez que la carpeta ha sido leída la interfaz de la aplicación entra en funcionamiento y se muestra por pantalla un listado de los mensajes recuperados. Los mensajes se numeran automáticamente y pueden leerse como se observa en el siguiente ejemplo:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>Mail version 8.1 6/6/93.  Type ? <span class=k>for </span>help.
<span class=s2>&#34;/var/mail/marcs&#34;</span>: 3 messages 3 new
<span class=o>&gt;</span>N  1 root@localhost        Mon Mar  8 14:05  14/510   <span class=s2>&#34;test&#34;</span>
 N  2 root@localhost        Mon Mar  8 14:05  14/509   <span class=s2>&#34;user account&#34;</span>
 N  3 root@localhost        Mon Mar  8 14:05  14/509   <span class=s2>&#34;sample&#34;</span></code></pre></div></div><div class=paragraph><p>Los mensajes se pueden leer utilizando el comando <kbd>t</kbd> de <code>mail</code> escribiendo a continuación el número del mensaje que queremos leer. En este ejemplo vamos a leer el primer correo:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% t 1
Message 1:
From root@localhost  Mon Mar  8 14:05:52 2004
X-Original-To: marcs@localhost
Delivered-To: marcs@localhost
To: marcs@localhost
Subject: <span class=nb>test
</span>Date: Mon,  8 Mar 2004 14:05:52 +0200 <span class=o>(</span>SAST<span class=o>)</span>
From: root@localhost <span class=o>(</span>Charlie Root<span class=o>)</span>

This is a <span class=nb>test </span>message, please reply <span class=k>if </span>you receive it.</code></pre></div></div><div class=paragraph><p>Como podemos observar en el ejemplo anterior el comando <kbd>t</kbd> muestra el contenido del correo eletrónico con todas sus cabeceras. Para mostrar el listado con todos los correos de nuevo, se debe utilizar la tecla <kbd>h</kbd>.</p></div><div class=paragraph><p>Si el correo eletrónico requiere una contestación se puede utilizar la aplicación <code>mail</code> para responder utilizando la tecla <kbd>R</kbd> o <kbd>r</kbd>. La tecla <kbd>R</kbd> indica a <code>mail</code> que conteste sólo al origen (remitente) del correo, mientras que la tecla <kbd>r</kbd> tanto al remitente a los otros usuarios receptores del mensaje original. Además ambos comandos se pueden ejecutar escribiendo a continuación el número que identifica al mensaje que se quiere responder. Tras esto la respuesta puede redactarse , y se debe indicar el final del mensaje mediante un punto (<kbd>.</kbd>) a continuación de un salto de línea. Veamos un ejemplo:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% R 1
To: root@localhost
Subject: Re: <span class=nb>test

</span>Thank you, I did get your email.
<span class=nb>.</span>
EOT</code></pre></div></div><div class=paragraph><p>Para enviar nuevos correos eletrónicos se debe utilizar la tecla <kbd>m</kbd> seguida de la dirección de de correo del destinatario. Se pueden especificar varios destinatarios de correo separando cada dirección de correo con una coma ( <kbd>,</kbd> ). El asunto del mensaje de correo se puede escribir a continuación seguido por el cuerpo del mensaje. El final del mensaje se especifica como en el caso anterior, utilizando un <kbd>.</kbd> tras un saldo de línea y pulsando la tecla "enter".</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% mail root@localhost
Subject: I mastered mail

Now I can send and receive email using mail ... :<span class=o>)</span>
<span class=nb>.</span>
EOT</code></pre></div></div><div class=paragraph><p>Mientras nos encontremos dentro de la <code>mail</code> el comando <kbd>?</kbd> puede utilizarse para mostrar la ayuda en línea aunque la principal fuente de información detallda sobre esta aplicación es la página man <a href="https://man.freebsd.org/cgi/man.cgi?query=mail&amp;sektion=1&amp;format=html">mail(1)</a>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Tal y como se ha dicho ya la aplicación <a href="https://man.freebsd.org/cgi/man.cgi?query=mail&amp;sektion=1&amp;format=html">mail(1)</a> no fue diseñada originalmente para gestionar adjuntos, por lo que su forma de gestionarlos resulta ser extremadamente mala. MUA más modernos como mutt gestionan los adjuntos de correo de una forma mucho más inteligente. Si se desea utilizar el comando <code>mail</code> el port <a class=package href=https://cgit.freebsd.org/ports/tree/converters/mpack/>converters/mpack</a> le puede resultar bastante útil.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=mutt-command>26.11.2. mutt<a class=anchor href=#mutt-command></a></h4><div class=paragraph><p>mutt es un agente de correo de usuario pequeño pero muy potente, funcional y con excelentes características; veamos algunas:</p></div><div class=ulist><ul><li><p>La habilidad de agrupar mensajes en hilos.</p></li><li><p>Soporte de PGP para cifradon y firma digital de correos eletrónicos.</p></li><li><p>Soporte de tipos MIME.</p></li><li><p>Soporte de gestión de correo en formato Maildir.</p></li><li><p>Altamente configurable por el usuario.</p></li></ul></div><div class=paragraph><p>Toda estas características hacen de mutt uno de los agentes de correo más avanzados del momento. Consulte <a href=http://www.mutt.org>http://www.mutt.org</a> para más información sobre mutt.</p></div><div class=paragraph><p>La versión estable de mutt se puede instalar usando el port <a class=package href=https://cgit.freebsd.org/ports/tree/mail/mutt/>mail/mutt</a> mientras que la versión de desarrollo está en <a class=package href=https://cgit.freebsd.org/ports/tree/mail/mutt-devel/>mail/mutt-devel</a>. Una vez que se ha instalado el port, mutt puede ejecutarse mediante el siguiente comando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% mutt</code></pre></div></div><div class=paragraph><p>mutt lee automáticamente el contenido de la carpeta de correo del usuario dentro del directorio <span class=filename>/var/mail</span> y muestra por pantalla su contenido. Si el directorio está vacío mutt quedará a la espera de los comandos que pueda pasarle el usuario. En el ejemplo que se muestra a continuación puede verse cómo mutt facilita la lista de mensajes al usuario:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/mail/mutt1.png alt=mutt1></div></div><div class=paragraph><p>Para leer un correo basta con seleccionarlo usando las teclas de cursor, y presionando la tecla <kbd>Enter</kbd>. Veamos cómo muestra mutt un correo electrónico:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/mail/mutt2.png alt=mutt2></div></div><div class=paragraph><p>Al igual que ocurre con <a href="https://man.freebsd.org/cgi/man.cgi?query=mail&amp;sektion=1&amp;format=html">mail(1)</a> mutt permite que los usuarios contesten al remitente de cualquier mensaje así como a los demás receptores. Para responder sólo al remitente se puede utilizar la tecla <kbd>r</kbd>. Para responder a un grupo, es decir a todos los receptores y al remitente del correo eletrónico pulse <kbd>g</kbd>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>mutt tiene <a href="https://man.freebsd.org/cgi/man.cgi?query=vi&amp;sektion=1&amp;format=html">vi(1)</a> como editor por defecto para crear y responder a los mensajes de correo eletrónico. Si prefiere emplear otro editor modifique el valor de la variable <code>editor</code> en <span class=filename>.muttrc</span>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Para escribir un mensaje de correo presione la tecla <kbd>m</kbd>. Después de escribir el asunto mutt ejecuta <a href="https://man.freebsd.org/cgi/man.cgi?query=vi&amp;sektion=1&amp;format=html">vi(1)</a> y el cuerpo del mensaje puede escribirse. Una vez escrito el correo salga de <code>vi</code> y mutt se ejecutará de nuevo mostrando por pantalla un resumen del correo que está a punto de ser enviado. Para enviar ese correo hay que pulsar <kbd>y</kbd>. Este es un ejemplo de uno de esos resúmenes:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/mail/mutt3.png alt=mutt3></div></div><div class=paragraph><p>mutt también contiene una amplia ayuda a la que se accede desde la mayoría de los menús pulsando la tecla <kbd>?</kbd>. La primera lína de la pantalla también muestra las teclas de método abreviado cuando es posible utilizarlas.</p></div></div><div class=sect3><h4 id=pine-command>26.11.3. pine<a class=anchor href=#pine-command></a></h4><div class=paragraph><p>pine es una aplicación de correo enfocada a los usuarios principiantes o inexpertos pero también incluye algunas características avanzadas.</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><i class="fa icon-warning" title=Warning></i></td><td class=content><div class=paragraph><p>Se han descubierto en pine varias vulnerabilidades que pueden explotarse de forma remota. Esas vulnerabilidades permiten que atacantes remotos puedan ejecutar código como si fueran usuarios locales del sistema mediante el envío de correos con un formato determinado. Todos los problemas <em>conocidos</em> se han resuelto pero el código de pine está escrito de una forma insegura y el "Security Officer" de FreeBSD opina que es probable que existan todavía vulnerabilidades sin descubrir. Si decide instalar pine debe asumir los riesgos que ello puede implicar.</p></div></td></tr></tbody></table></div><div class=paragraph><p>La versión actual de pine se puede instalar utilizando el port <a class=package href=https://cgit.freebsd.org/ports/tree/mail/pine4/>mail/pine4</a>. Una vez que se ha instalado pine se puede ejecutar mediante el siguiente comando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% pine</code></pre></div></div><div class=paragraph><p>La primera vez que se ejecuta pine se muestra un mensaje de bienvenida con una pequeña introducción a la herramienta junto con una petición del equipo de desarrollo de pine en la que se solicita que se envíe un correo de forma anónima un correo de forma anónima para que puedan hacerse una idea s de cuántos usuarios están utilizando la herramienta. Para enviar dicho correo hay que presionar la tecla <kbd>Enter</kbd>, o bien puede pulsar la tecla <kbd>E</kbd> para salir de la ventana de bienvenida sin enviar dicho correo. A continuación se muestra un ejemplo de la página de bienvenida:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/mail/pine1.png alt=pine1></div></div><div class=paragraph><p>Los usuarios disponen de un menú principal, que puede navegarse utilizando las flechas. Este menú proporciona atajos para la composición de nuevos correos, para navegar a través de las carpetas de correo, e incluso para la administración de la libreta de direcciones. Justo debajo del menú principal, se muestran las teclas de método abreviado (atajos) que pueden utilizarse en cada momento.</p></div><div class=paragraph><p>El directorio por defecto que pine intenta abrir es <span class=filename>inbox</span>. Para ver el índice de todos los mensajes recibidos pulse la tecla <kbd>I</kbd> o seleccione la opción de menú denominada <span class=guimenuitem>MESSAGE INDEX</span> como se muestra a continuación:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/mail/pine2.png alt=pine2></div></div><div class=paragraph><p>El índice muestra los mensajes en el directorio actual y puede navegarse en él utilizando las teclas del cursor. El mensaje seleccionado se puede leer presionando la tecla <kbd>Enter</kbd>.</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/mail/pine3.png alt=pine3></div></div><div class=paragraph><p>En la captura de pantalla que se muestra a continuación se muestra un mensaje de ejemplo. Las teclas de atajo se muestran como referencia en la parte baja de la pantalla. Un ejemplo de dichas teclas de método abreviado es la tecla <kbd>r</kbd> que permite responder al mensaje que se muestra en dicho momento.</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/mail/pine4.png alt=pine4></div></div><div class=paragraph><p>La contestación a un mensaje de correo eletrónico en pine se realiza mediante el editor pico, que se instala por defecto junto con pine. pico permite navegar de forma sencilla por los distintos mensajes de correo y es ligeramente más sencilla de manejar que <a href="https://man.freebsd.org/cgi/man.cgi?query=vi&amp;sektion=1&amp;format=html">vi(1)</a>, sobre todo para los usuarios noveles. Una vez que se ha escrito la réplica al correo se envía pulsando la tecla <span class=keyseq><kbd>Ctrl</kbd>+<kbd>X</kbd></span>. pine pedirá confirmación antes de enviarlo.</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/mail/pine5.png alt=pine5></div></div><div class=paragraph><p>pine puede configurarse utilizando la entrada <span class=guimenuitem>SETUP</span> del menú principal. Se ruega consultar <a href=http://www.washington.edu/pine/>http://www.washington.edu/pine/</a> para obtener más información.</p></div></div></div><div class=sect2><h3 id=mail-fetchmail>26.12. Manejo de fetchmail<a class=anchor href=#mail-fetchmail></a></h3><div class=paragraph><p>fetchmail es un cliente de IMAP y POP que permite a los usuarios descargar automáticamente el correo de cuentas remotas en servidores IMAP y POP y almacenarlos en carpetas de correo locales; una vez en local, se puede acceder a los correos de una forma más sencilla y utilizando multitud de programas cliente. fetchmail se puede instalar a partir del port <a class=package href=https://cgit.freebsd.org/ports/tree/mail/fetchmail/>mail/fetchmail</a>. Veamos algunas de sus características más útiles:</p></div><div class=ulist><ul><li><p>Suporte de POP3, APOP, KPOP, IMAP, ETRN y ODMR.</p></li><li><p>Puede reenviar correo utilizando SMTP lo que permite que las reglas de filtrado, reenvío y "aliasing" funcionen correctamente.</p></li><li><p>Se puede ejecutar en modo dæmon comprobar periódicamente el correo entrante.</p></li><li><p>Puede recuperar correo de múltiples carpetas y reenviarlos, en función de la configuración establecida, a varios usuarios locales.</p></li></ul></div><div class=paragraph><p>Queda fuera del objetivo de este documento explicar todas las características de fetchmail pero algunas de ellas se exponen a ontinuación. fetchmail usa un fichero de configuración denominado <span class=filename>.fetchmailrc</span>. Este fichero incluye información sobre el servidor de correo remoto y los datos necesarios para poder hacer login en él. Debido a la naturaleza sensible de la información que se almacena en dicho fichero se recomienda modificar los permisos para que sea de sólo sea legible por su propietario. Lo conseguirá mediante el siguiente comando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% <span class=nb>chmod </span>600 .fetchmailrc</code></pre></div></div><div class=paragraph><p>El siguiente ejemplo muestra un fichero de configuración <span class=filename>.fetchmailrc</span>. Este ejemplo sirve para automatizar la descarga del correo de un determinado usuario mediante POP. El fichero de configuración hace que fetchmail se conecte a <code>ejemplo.com</code> utilizando como nombre de usuario <code>joesoap</code> y como contraseña <code>XXX</code>. En el ejemplo se asume que el usuario <code>joesoap</code> también es un usuario válido en el sistema local.</p></div><div class="literalblock programlisting"><div class=content><pre>poll ejemplo.com protocol pop3 username &#34;joesoap&#34; password &#34;XXX&#34;</pre></div></div><div class=paragraph><p>El siguiente ejemplo permite a fetchmail conectarse a múltiples servidores POP e IMAP y redirige los correos a diferentes usuarios locales en función de la configuración establecida:</p></div><div class="literalblock programlisting"><div class=content><pre>poll ejemplo.com proto pop3:
user &#34;joesoap&#34;, with password &#34;XXX&#34;, is &#34;jsoap&#34; here;
user &#34;andrea&#34;, with password &#34;XXXX&#34;;
poll ejemplo.net proto imap:
user &#34;john&#34;, with password &#34;XXXXX&#34;, is &#34;myth&#34; here;</pre></div></div><div class=paragraph><p>fetchmail se puede ejecutar en modo dæmon mediante el parámetro <code>-d</code> seguido seguido por un intervalo de tiempo (expresado en segundos) que indica cada cuánto tiempo debe fetchmail interrogar a los distintos servidores listados en <span class=filename>.fetchmailrc</span>. El siguiente ejemplo hace que fetchmail interroge cada 60 segundos:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% fetchmail <span class=nt>-d</span> 60</code></pre></div></div><div class=paragraph><p>Se puede encontrar más información sobre fetchmail en <a href=http://www.catb.org/~esr/fetchmail/>http://www.catb.org/~esr/fetchmail/</a>.</p></div></div><div class=sect2><h3 id=mail-procmail>26.13. Uso de procmail<a class=anchor href=#mail-procmail></a></h3><div class=paragraph><p>procmail es una aplicación increíblemente potente que se utiliza para filtrar el correo de entrada. Permite a los usuarios definir "reglas" que se asocian con correos entrantes y que realizan funciones concretas, como reencaminar el correo a carpetas o direciones alternativas. procmail se puede instalar utilizando el port <a class=package href=https://cgit.freebsd.org/ports/tree/mail/procmail/>mail/procmail</a>. Una vez instalado, se puede integrar directamente en la mayoría de los MTAs; por favor, consulte la documentación del MTA que utilice para saber más sobre la integración entre ambos. Por otro lado procmail se puede integrar con el MTA que prefiera de una forma sencilla añadiendo la siguiente línea al fichero <span class=filename>.forward</span> dentro del directorio home del usuario que desée usar procmail:</p></div><div class="literalblock programlisting"><div class=content><pre>&#34;|exec /usr/local/bin/procmail || exit 75&#34;</pre></div></div><div class=paragraph><p>La siguiente sección muestra algunas reglas básicas de procmail, junto con una breve descripción de las acciones que realizan. Estas reglas, y muchas otras se deben insertar dentro del fichero <span class=filename>.procmailrc</span> ubicado en el directorio home del usuario.</p></div><div class=paragraph><p>En la página man de "procmailex" se explica la mayoría de estas reglas.</p></div><div class=paragraph><p>Reenvío de todo el correo proveniente de <code>usuario@ejemplo.com</code> hacia la dirección externa <code>correodefiar@ejemplo.com</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>:0
* ^From.*usuario@ejemplo.com
! correodefiar@ejemplo.com</pre></div></div><div class=paragraph><p>Reenvío de todos los correos que ocupen menos de 1000 bytes a la dirección <code>corredefiar@ejemplo2.com</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>:0
* &lt; 1000
! correodefiar@ejemplo2.com</pre></div></div><div class=paragraph><p>Envío de todos los correos dirigidos a <code>opcional@ejemplo.com</code> hacia una carpeta de correo llamada <span class=filename>opcional</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>:0
* ^TOopcional@ejemplo.com
opcional</pre></div></div><div class=paragraph><p>Envío de todos los correos con un asunto que contenga la palabra "Spam" al dispositivo <span class=filename>/dev/null</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>:0
^Subject:.*Spam
/dev/null</pre></div></div><div class=paragraph><p>Una útil receta para examinar mensajes de correo provenientes de listas de distribución de <code>FreeBSD.org</code> y poner cada mensaje en el directorio apropiado en función del origen del mensaje:</p></div><div class="literalblock programlisting"><div class=content><pre>:0
* ^Sender:.owner-freebsd-\/[^@]+@FreeBSD.ORG
{
	LISTNAME=${MATCH}
	:0
	* LISTNAME??^\/[^@]+
	FreeBSD-${MATCH}
}</pre></div></div></div></div></div><div class=sect1><h2 id=network-servers>Capítulo 27. Networking avanzado<a class=anchor href=#network-servers></a></h2><div class=sectionbody><div class=sect2><h3 id=network-servers-synopsis>27.1. *<a class=anchor href=#network-servers-synopsis></a></h3><div class=paragraph><p>Pendiente de traducción. Este capítulo incluye también parte del contenido del <a href=./#advanced-networking>Networking avanzado</a>, "networking" avanzado.</p></div></div></div></div><div class=sect1><h2 id=firewalls>Capítulo 28. Cortafuegos<a class=anchor href=#firewalls></a></h2><div class=sectionbody><div class=sect2><h3 id=firewalls-intro>28.1. *<a class=anchor href=#firewalls-intro></a></h3><div class=paragraph><p>Pendiente de traducción</p></div></div></div></div><div class=sect1><h2 id=advanced-networking>Capítulo 29. Redes Avanzadas<a class=anchor href=#advanced-networking></a></h2><div class=sectionbody><div class=sect2><h3 id=advanced-networking-synopsis>29.1. Sinopsis<a class=anchor href=#advanced-networking-synopsis></a></h3><div class=paragraph><p>Este capítulo cubre cierto número de temas avanzados de redes.</p></div><div class=paragraph><p>Después de leer este capítulo, sabrás:</p></div><div class=ulist><ul><li><p>Lo básico acerca de gateways y rutas.</p></li><li><p>Cómo configurar tethering por USB.</p></li><li><p>Cómo configurar dispositivos IEEE® 802.11 y Bluetooth®.</p></li><li><p>Cómo hacer que FreeBSD actúe como un puente.</p></li><li><p>Cómo configurar arranque por red PXE.</p></li><li><p>Cómo habilitar y utilizar las características del Common Address Redundancy Protocol (CARP) en FreeBSD.</p></li><li><p>Cómo configurar múltiples VLANs en FreeBSD.</p></li><li><p>Configurar unos auriculares con micrófono vía bluetooth.</p></li></ul></div><div class=paragraph><p>Antes de leer este capítulo, deberías:</p></div><div class=ulist><ul><li><p>Comprender lo básico acerca de los scripts <span class=filename>/etc/rc</span>.</p></li><li><p>Estar familiarizado con la terminología básica de red.</p></li><li><p>Entendiendo la configuración básica de red en FreeBSD (<a href=./#network>FreeBSD network</a>).</p></li><li><p>Saber cómo configurar e instalar un nuevo kernel de FreeBSD (<a href=./#kernelconfig>Configurando el Núcleo de FreeBSD</a>).</p></li><li><p>Cómo instalar software adicional de terceros (<a href=./#ports>Instalando Aplicaciones: Paquetes y Ports</a>).</p></li></ul></div></div><div class=sect2><h3 id=network-routing>29.2. Gateways y Rutas<a class=anchor href=#network-routing></a></h3><div class=paragraph><p><em>Routing</em> es el mecanismo que permite a un sistema encontrar el camino de red a otro sistema. Una <em>ruta</em> es un par de direcciones definido las cuales representan el "destino" y el "gateway". La ruta indica que cuando se trata de llegar a un destino especificado, se deben enviar los paquetes a través del gateway especificado. Hay tres tipos de destinos: hosts individuales, subredes, y "default". La "ruta por defecto" se utiliza si no se puede aplicar ninguna otra ruta. También hay tres tipos de gateways: hosts individuales, interfaces, también llamados enlaces, y direcciones Ethernet (MAC). Las rutas conocidas se almacenan en una tabla de enrutamiento.</p></div><div class=paragraph><p>Esta sección proporciona una visión general de aspectos básicos de enrutado. Luego muestra cómo configurar un sistema FreeBSD como un router y proporciona algunas pistas para resolver problemas.</p></div><div class=sect3><h4 id=network-routing-default>29.2.1. Enrutamiento Básico<a class=anchor href=#network-routing-default></a></h4><div class=paragraph><p>Para ver la tabla de enrutamiento de un sistema FreeBSD, usa <a href="https://man.freebsd.org/cgi/man.cgi?query=netstat&amp;sektion=1&amp;format=html">netstat(1)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% netstat <span class=nt>-r</span>
Routing tables

Internet:
Destination      Gateway            Flags     Refs     Use     Netif Expire
default          outside-gw         UGS        37      418       em0
localhost        localhost          UH          0      181       lo0
test0            0:e0:b5:36:cf:4f   UHLW        5    63288       re0     77
10.20.30.255     <span class=nb>link</span><span class=c>#1             UHLW        1     2421</span>
example.com      <span class=nb>link</span><span class=c>#1             UC          0        0</span>
host1            0:e0:a8:37:8:1e    UHLW        3     4601       lo0
host2            0:e0:a8:37:8:1e    UHLW        0        5       lo0 <span class=o>=&gt;</span>
host2.example.com <span class=nb>link</span><span class=c>#1            UC          0        0</span>
224              <span class=nb>link</span><span class=c>#1             UC          0        0</span></code></pre></div></div><div class=paragraph><p>Las entradas en este ejemplo son como sigue:</p></div><div class=dlist><dl><dt class=hdlist1>Defecto</dt><dd><p>La primera ruta en esta tabla especifica la ruta por defecto (<code>default</code>). Cuando el sistema local necesita conectarse a un host remoto, comprueba la tabla de enrutamiento para determinar si existe un camino. Si el host remoto tiene una entrada en la tabla, el sistema comprueba si puede conectar utilizando el interfaz especificado en dicha entrada.</p><div class=paragraph><p>Si el destino no tiene una entrada, o si todos los caminos conocidos fallan, el sistema utiliza la entrada para el enrutamiento por defecto. Para hosts en la red de área local, el campo <code>Gateway</code> en la ruta por defecto se establece al sistema que tiene una conexión directa a Internet. Cuando se lee esta entrada, verifica que la columna <code>Flags</code> indica que el gateway se puede usar (<code>UG</code>).</p></div><div class=paragraph><p>La ruta por defecto para una máquina que está funcionando como gateway para el mundo exterior será la máquina gateway del Proveedor de Servicio de Internet (ISP).</p></div></dd><dt class=hdlist1>localhost</dt><dd><p>La segunda ruta es <code>localhost</code>. El interfaz especificado en la columna <code>Netif</code> para <code>localhost</code> es <span class=filename>lo0</span>, también conocido como el dispositivo loopback. Esto indica que todo el tráfico para este destino debería ser interno, en lugar de enviarlo a través de la red.</p></dd><dt class=hdlist1>Dirección MAC</dt><dd><p>Las direcciones que comienzan con <code>0:e0</code> son direcciones MAC. FreeBSD identificará automáticamente cualquier host, <code>test0</code> en el ejemplo, en el Ethernet local y añadirá una ruta para ese host sobre el interfaz Ethernet, <span class=filename>re0</span>. Este tipo de ruta tiene un timeout, mostrado en la columna <code>Expire</code>, que es usado si el host no responde en un tiempo determinado. Cuando esto sucede, la ruta a este host será automáticamente borrada. Estos hosts se identifican usando el Routing Information Protocol (RIP), que calcula rutas a los hosts locales basándose en la determinación del camino más corto.</p></dd><dt class=hdlist1>subred</dt><dd><p>FreeBSD añadirá rutas para la subred local. En este ejemplo, <code>10.20.30.255</code> es la dirección de broadcast para la subred <code>10.20.30</code> y <code>example.com</code> es el nombre de dominio asociado con esa subred. La designación <code>link#1</code> hace referencia a la primera tarjeta Ethernet de la máquina.</p><div class=paragraph><p>Hosts en la red local y subredes locales tienen sus rutas configuradas automáticamente por un demonio llamado <a href="https://man.freebsd.org/cgi/man.cgi?query=routed&amp;sektion=8&amp;format=html">routed(8)</a>. Si no se está ejecutando, sólo existirán las rutas que hayan sido configuradas estáticamente por el administrador.</p></div></dd><dt class=hdlist1>host</dt><dd><p>La línea <code>host1</code> hace referencia al host mediante su dirección Ethernet. Puesto que es el host que envía, FreeBSD sabe que tienen que usar el interfaz loopback (<span class=filename>lo0</span>) en lugar del interfaz Ethernet.</p><div class=paragraph><p>Las dos líneas <code>host2</code> representan alias que se crean utilizando <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a>. El símbolo <code>⇒</code> después del interfaz <span class=filename>lo0</span> indica que se ha establecido un alias además de la dirección de loopback. Estas rutas sólo se muestran en el host que suporta el alias y el resto de hosts en la red local tendrán una línea <code>link#1</code> para esas rutas.</p></div></dd><dt class=hdlist1>224</dt><dd><p>La última línea (subred de destino <code>224</code>) tiene que ver con multicasting.</p></dd></dl></div><div class=paragraph><p>Se pueden ver varios atributos para cada ruta en la columna <code>Flags</code>. <a href=#routeflags>Flags Habituales de la Tabla de Enrutado</a> resume algunos de estos flags y sus significados:</p></div><table id=routeflags class="tableblock frame-none grid-all stretch"><caption class=title>Tabla 7. Flags Habituales de la Tabla de Enrutado</caption><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Flag</th><th class="tableblock halign-left valign-top">Propósito</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>U</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>La ruta está activa (up).</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>H</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>La ruta de destino es un único host.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>G</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Envía cualquier cosa a este destino a través de este gateway, que averiguará a dónde enviarlo a continuación.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>S</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Esta ruta se ha configurado de forma estática.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>C</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Clona una nueva ruta basada en esta ruta para que las máquinas puedan conectarse. Este tipo de ruta se usa normalmente para redes locales.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>W</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>La ruta ha sido auto configurada basada en una ruta (clonada) de una red de área local.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>L</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>La ruta incluye referencias a hardware Ethernet (link).</p></td></tr></tbody></table><div class=paragraph><p>En un sistema FreeBSD, la ruta por defecto se puede configurar en <span class=filename>/etc/rc.conf</span> especificando la dirección IP del gateway por defecto:</p></div><div class="literalblock programlisting"><div class=content><pre>defaultrouter=&#34;10.20.30.1&#34;</pre></div></div><div class=paragraph><p>También es posible añadir la ruta de forma manual usando <code>route</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># route add default 10.20.30.1</span></code></pre></div></div><div class=paragraph><p>Date cuenta de que las rutas añadidas manualmente no persisten entre reinicios. Para más información sobre la manipulación manual de tablas de enrutamiento de red, consulta <a href="https://man.freebsd.org/cgi/man.cgi?query=route&amp;sektion=8&amp;format=html">route(8)</a>.</p></div></div><div class=sect3><h4 id=network-static-routes>29.2.2. Configurando un Router con Rutas Estáticas<a class=anchor href=#network-static-routes></a></h4><div class=paragraph><p>Un sistema FreeBSD se puede configurar como el gateway por defecto, o router, para una red si es un sistema "dual-homed". Un sistema "dual-homed" es una máquina que está en al menos dos redes diferentes. Típicamente cada red se conecta a un interfaz de red separada, aunque se puede usar IP aliasing para enlazar múltiples direcciones, cada una en una subred diferente, a una única interfaz física.</p></div><div class=paragraph><p>Para que el sistema pueda reenviar paquetes entre interfaces, FreeBSD debe ser configurado como un router. Los estándares de Internet y las buenas prácticas de ingeniería evitan que el Proyecto FreeBSD active esta característica por defecto, pero se puede configurar en el arranque añadiendo esta línea a <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>gateway_enable=&#34;YES&#34;          # Set to YES if this host will be a gateway</pre></div></div><div class=paragraph><p>Para habilitar el enrutado, establece la variable <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> <code>net.inet.ip.forwarding</code> a <code>1</code>. Para parar el enrutado, restablece esta variable a <code>0</code>.</p></div><div class=paragraph><p>La tabla de enrutamiento de un router necesita rutas adicionales para saber cómo llegar a otras redes. Las rutas se puede añadir manualmente utilizando rutas estáticas o se pueden aprender automáticamente usando un protocolo de enrutamiento. Las rutas estáticas son apropiadas para redes pequeñas y esta sección describe cómo añadir una ruta estática para una red pequeña.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Para redes grandes, las rutas estáticas pronto se vuelven impracticables. FreeBSD incluye el demonio de enrutamiento BSD estándar <a href="https://man.freebsd.org/cgi/man.cgi?query=routed&amp;sektion=8&amp;format=html">routed(8)</a>, que proporciona los protocolos de enrutamiento RIP, versiones 1 y 2, y IRDP. Se puede instalar soporte para los protocolos de enrutado BGP y OSPFS usando el paquete o port <a class=package href=https://cgit.freebsd.org/ports/tree/net/quagga/>net/quagga</a>.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Considera la siguiente red:</p></div><div class=imageblock><div class=content><img src=../../../../images/books/handbook/advanced-networking/static-routes.png alt="static routes"></div></div><div class=paragraph><p>En este escenario, <code>RouterA</code> es una máquina FreeBSD que está actuando como un router para el resto de Internet. Tiene una ruta por defecto establecida a <code>10.0.0.1</code> que le permite conectarse con el mundo exterior. <code>RouterB</code> ya está configurado para utilizar <code>192.168.1.1</code> como su gateway por defecto.</p></div><div class=paragraph><p>Antes de añadir ninguna ruta estática, la tabla de enrutamiento de <code>RouterA</code> tiene este aspecto:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% netstat <span class=nt>-nr</span>
Routing tables

Internet:
Destination        Gateway            Flags    Refs      Use  Netif  Expire
default            10.0.0.1           UGS         0    49378    xl0
127.0.0.1          127.0.0.1          UH          0        6    lo0
10.0.0.0/24        <span class=nb>link</span><span class=c>#1             UC          0        0    xl0</span>
192.168.1.0/24     <span class=nb>link</span><span class=c>#2             UC          0        0    xl1</span></code></pre></div></div><div class=paragraph><p>Con la tabla de enrutamiento actual, <code>RouterA</code> no tiene una ruta a la red <code>192.168.2.0/24</code>. El siguiente comando añade la red <code>Internal Net 2</code> a la tabla de enrutamiento de <code>RouterA</code> usando <code>192.168.1.2</code> para el siguiente salto:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># route add -net 192.168.2.0/24 192.168.1.2</span></code></pre></div></div><div class=paragraph><p>Ahora, <code>RouterA</code> puede alcanzar cualquier host en la red <code>192.168.2.0/24</code>. Sin embargo, la información de enrutamiento no persistirá si el sistema FreeBSD se reinicia. Si una ruta estática necesita ser persistente, añádela a <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre># Add Internal Net 2 as a persistent static route
static_routes=&#34;internalnet2&#34;
route_internalnet2=&#34;-net 192.168.2.0/24 192.168.1.2&#34;</pre></div></div><div class=paragraph><p>La variable de configuración <code>static_routes</code> es una lista de cadenas separadas por un espacio, donde cada cadena referencia el nombre de una ruta. La variable <code>route_internalnet2</code> contiene la ruta estática para el nombre de esa ruta.</p></div><div class=paragraph><p>Usar más de una cadena en <code>static_routes</code> crea múltiples rutas estáticas. Lo siguiente muestra un ejemplo de cómo añadir rutas estáticas para las redes <code>192.168.0.0/24</code> y <code>192.168.1.0/24</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>static_routes=&#34;net1 net2&#34;
route_net1=&#34;-net 192.168.0.0/24 192.168.0.1&#34;
route_net2=&#34;-net 192.168.1.0/24 192.168.1.1&#34;</pre></div></div></div><div class=sect3><h4 id=network-routing-troubleshooting>29.2.3. Resolución de problemas<a class=anchor href=#network-routing-troubleshooting></a></h4><div class=paragraph><p>Cuando se asigna un espacio de direcciones a una red, el proveedor de servicio configura sus propias tablas de enrutamiento de forma que todo el tráfico para la red se enviará a través del enlace para el sitio. Pero ¿cómo saben los sitios externos que tienen que enviar sus paquetes al ISP de la red?</p></div><div class=paragraph><p>Hay un sistema que lleva el control de todos los espacios de direcciones asignados y define sus puntos de conexión a la red principal de Internet, o las líneas troncales que llevan el tráfico por todo el país y alrededor del mundo. Cada máquina troncal tiene una copia de un conjunto maestro de tablas, las cuales dirigen el tráfico para una red particular hacia un portador troncal específico, y de ahí bajando por la cadena de proveedores de servicio hasta que alcanza una red particular.</p></div><div class=paragraph><p>Es tarea del proveedor de servicio avisar a los sitios troncales de que son el punto de conexión, y por tanto el camino de entrada, para un sitio. Esto se conoce como propagación de ruta.</p></div><div class=paragraph><p>A veces, hay algún problema con la propagación de ruta y algunos sitios son incapaces de conectar. Quizás el comando más útil para intentar averiguar dónde se rompe la ruta es <code>traceroute</code>. Es útil cuando <code>ping</code> falla.</p></div><div class=paragraph><p>Cuando uses <code>traceroute</code>, incluye la dirección del host remoto al que conectar. La salida mostrará el gateway junto con el camino que sigue el intento, eventualmente alcanzando el destino, o terminando debido a la falta de conexión. Para más información, consulta <a href="https://man.freebsd.org/cgi/man.cgi?query=traceroute&amp;sektion=8&amp;format=html">traceroute(8)</a>.</p></div></div><div class=sect3><h4 id=network-routing-multicast>29.2.4. Consideraciones para Multicast<a class=anchor href=#network-routing-multicast></a></h4><div class=paragraph><p>FreeBSD soporta de forma nativa tanto aplicaciones multicast como enrutamiento multicast. Las aplicaciones multicast no necesitan ninguna configuración especial para ejecutarse en FreeBSD. El soporte para enrutamiento multicast requiere que la siguiente opción esté incluida en un kernel personalizado:</p></div><div class="literalblock programlisting"><div class=content><pre>options MROUTING</pre></div></div><div class=paragraph><p>El demonio de enrutamiento multicast, mrouted se puede instalar usando el paquete o port <a class=package href=https://cgit.freebsd.org/ports/tree/net/mrouted/>net/mrouted</a>. Este demonio implementa el protocolo de enrutamiento multicast DVMRP y se configura editando el fichero <span class=filename>/usr/local/etc/mrouted.conf</span> para configurar los túneles y DVMRP. La instalación de mrouted también instala map-mbone y mrinfo, así como sus páginas de manual. Consúltalas para ver ejemplos de configuración.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>DVMRP ha sido ampliamente sustituido por el protocolo PIM en muchas instalaciones multicast. Consulta <a href="https://man.freebsd.org/cgi/man.cgi?query=pim&amp;sektion=4&amp;format=html">pim(4)</a> para más información.</p></div></td></tr></tbody></table></div></div></div><div class=sect2><h3 id=configtuning-virtual-hosts>29.3. Hosts Virtuales<a class=anchor href=#configtuning-virtual-hosts></a></h3><div class=paragraph><p>Un uso habitual para FreeBSD es el de proporcionar alojamiento virtual de sitios, donde un servidor aparece en la red como muchos servidores. Esto se consigue asignando múltiples direcciones de red a una única interfaz.</p></div><div class=paragraph><p>Una interfaz dada tiene una dirección "real", y puede tener un determinado número de direcciones "alias". Estos alias se añaden normalmente poniendo entradas alias en <span class=filename>/etc/rc.conf</span>, como se ve en este ejemplo:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysrc ifconfig_fxp0_alias0=&#34;inet xxx.xxx.xxx.xxx netmask xxx.xxx.xxx.xxx&#34;</span></code></pre></div></div><div class=paragraph><p>Las entradas de alias deben empezar con <code>alias<em>0</em></code> usando un número secuencial como <code>alias0</code>, <code>alias1</code>, y así sucesivamente. El proceso de configuración terminará en el primer número que falte.</p></div><div class=paragraph><p>El cálculo de las máscaras de red de los alias es importante. Para una interfaz data, debe haber una dirección que represente correctamente la máscara de la red. Cualquier otra dirección que esté en esta red tiene que tener una más cara con todo <code>1</code>s, expresada como <code>255.255.255.255</code> o <code>0xffffffff</code>.</p></div><div class=paragraph><p>Por ejemplo, considera el caso donde la interfaz <code>fxp0</code> está conectada a dos redes: <code>10.1.1.0</code> con máscara de red <code>255.255.255.0</code> y <code>202.0.75.16</code> con máscara de red`255.255.255.240`. El sistema está configurado para aparecer en los rangos <code>10.1.1.1</code> hasta <code>10.1.1.5</code> y <code>202.0.75.17</code> hasta <code>202.0.75.20</code>. Sólo la primera dirección en un rango de red dado debería tener una máscara de red real. Todas las demás (<code>10.1.1.2</code> hasta <code>10.1.1.5</code> y <code>202.0.75.18</code> hasta <code>202.0.75.20</code>) se deben configurar con máscara de red <code>255.255.255.255</code>.</p></div><div class=paragraph><p>Las siguientes entradas de <span class=filename>/etc/rc.conf</span> configuran correctamente el adaptador para este escenario:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysrc ifconfig_fxp0=&#34;inet 10.1.1.1 netmask 255.255.255.0&#34;</span>
<span class=c># sysrc ifconfig_fxp0_alias0=&#34;inet 10.1.1.2 netmask 255.255.255.255&#34;</span>
<span class=c># sysrc ifconfig_fxp0_alias1=&#34;inet 10.1.1.3 netmask 255.255.255.255&#34;</span>
<span class=c># sysrc ifconfig_fxp0_alias2=&#34;inet 10.1.1.4 netmask 255.255.255.255&#34;</span>
<span class=c># sysrc ifconfig_fxp0_alias3=&#34;inet 10.1.1.5 netmask 255.255.255.255&#34;</span>
<span class=c># sysrc ifconfig_fxp0_alias4=&#34;inet 202.0.75.17 netmask 255.255.255.240&#34;</span>
<span class=c># sysrc ifconfig_fxp0_alias5=&#34;inet 202.0.75.18 netmask 255.255.255.255&#34;</span>
<span class=c># sysrc ifconfig_fxp0_alias6=&#34;inet 202.0.75.19 netmask 255.255.255.255&#34;</span>
<span class=c># sysrc ifconfig_fxp0_alias7=&#34;inet 202.0.75.20 netmask 255.255.255.255&#34;</span></code></pre></div></div><div class=paragraph><p>Una forma más sencilla de expresar esto es con una lista de rangos de direcciones IP separadas por espacios. A la primera dirección se le asignará la máscara de subred indicada y las demás direcciones tendrán una máscara de subred de <code>255.255.255.255</code>.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sysrc ifconfig_fxp0_aliases=&#34;inet 10.1.1.1-5/24 inet 202.0.75.17-20/28&#34;</span></code></pre></div></div></div><div class=sect2><h3 id=network-advanced-wireless>29.4. Autenticación Inalámbrica Avanzada<a class=anchor href=#network-advanced-wireless></a></h3><div class=paragraph><p>FreeBSD soporta distintas formas de conectarse a una red inalámbrica. Esta sección describe como realizar autenticación avanzada en una Red Inalámbrica.</p></div><div class=paragraph><p>Para hacer una conexión y autenticación básica a una red inalámbrica la sección <a href=./#wireless-authentication>Conexión y Autenticación a una Red Inalámbrica</a> en el Capítulo de Red describe como hacerlo.</p></div><div class=sect3><h4 id=network-wireless-wpa-eap-tls>29.4.1. WPA with EAP-TLS<a class=anchor href=#network-wireless-wpa-eap-tls></a></h4><div class=paragraph><p>La segunda forma de utilizar WPA es con un servidor de autenticación 802.1X. En este caso, WPA se llama WPA Enterprise para diferenciarlo del WPA Personal menos seguro. La autenticación en WPA Enterprise se basa en el Extensible Authentication Protocol (EAP).</p></div><div class=paragraph><p>EAP no viene con un método de encriptación. En su lugar, EAP se introduce dentro de un túnel encriptado. Hay muchos métodos de autenticación EAP, pero EAP-TLS, EAP-TTLS, y EAP-PEAP son los más comunes.</p></div><div class=paragraph><p>EAP con Transport Layer Security (EAP-TLS) es un protocolo de autenticación inalámbrica bien soportado ya que fue el primer método EAP certificado por la <a href=http://www.wi-fi.org/>Wi-Fi Alliance</a>. EAP-TLS requiere tres certificados para funcionar: el certificado de Certificate Authority (CA) instalado en todas las máquinas, el certificado de servidor para el servidor de autenticación, y un cliente de certificado para cliente inalámbrico. En este método EAP, tanto el servidor de autenticación como el cliente inalámbrico se autentican entre sí presentando sus respectivos certificados, y luego verificando que estos certificados están firmados por la CA de la organización.</p></div><div class=paragraph><p>Como antes, la configuración se hace mediante <span class=filename>/etc/wpa_supplicant.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>network={
  ssid=&#34;freebsdap&#34; <i class=conum data-value=1></i><b>(1)</b>
  proto=RSN  <i class=conum data-value=2></i><b>(2)</b>
  key_mgmt=WPA-EAP <i class=conum data-value=3></i><b>(3)</b>
  eap=TLS <i class=conum data-value=4></i><b>(4)</b>
  identity=&#34;loader&#34; <i class=conum data-value=5></i><b>(5)</b>
  ca_cert=&#34;/etc/certs/cacert.pem&#34; <i class=conum data-value=6></i><b>(6)</b>
  client_cert=&#34;/etc/certs/clientcert.pem&#34; <i class=conum data-value=7></i><b>(7)</b>
  private_key=&#34;/etc/certs/clientkey.pem&#34; <i class=conum data-value=8></i><b>(8)</b>
  private_key_passwd=&#34;freebsdmallclient&#34; <i class=conum data-value=9></i><b>(9)</b>
}</pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>Este campo indica el nombre de la red (SSID).</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td>Este ejemplo utiliza el protocolo RSN IEEE® 802.11i también conocido como WPA2.</td></tr><tr><td><i class=conum data-value=3></i><b>3</b></td><td>La línea <code>key_mgmt</code> hace referencia al protocolo de gestión de claves que se utiliza. En este ejemplo, es WPA con autenticación EAP.</td></tr><tr><td><i class=conum data-value=4></i><b>4</b></td><td>Este campo indica el método EAP para la conexión.</td></tr><tr><td><i class=conum data-value=5></i><b>5</b></td><td>El campo <code>identity</code> contiene la cadena de identidad para EAP.</td></tr><tr><td><i class=conum data-value=6></i><b>6</b></td><td>El campo <code>ca_cert</code> indica la ruta al fichero del certificado de CA. Este fichero es necesario para verificar el certificado de servidor.</td></tr><tr><td><i class=conum data-value=7></i><b>7</b></td><td>La línea <code>cliente_cert</code> da la ruta al fichero de certificado del cliente. Este certificado es único para cada cliente inalámbrico de la red.</td></tr><tr><td><i class=conum data-value=8></i><b>8</b></td><td>El campo <code>private_key</code> es la ruta al fichero de clave privada del certificado del cliente.</td></tr><tr><td><i class=conum data-value=9></i><b>9</b></td><td>El campo <code>private_key_passwd</code> contienen la contraseña para la clave privada.</td></tr></tbody></table></div><div class=paragraph><p>Después, añade las siguientes líneas a <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>wlans_ath0=&#34;wlan0&#34;
ifconfig_wlan0=&#34;WPA DHCP&#34;</pre></div></div><div class=paragraph><p>El siguiente paso es levantar la interfaz:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service netif start</span>
Starting wpa_supplicant.
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 7
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 15
DHCPACK from 192.168.0.20
bound to 192.168.0.254 <span class=nt>--</span> renewal <span class=k>in </span>300 seconds.
wlan0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
      ether 00:11:95:d5:43:62
      inet 192.168.0.254 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet DS/11Mbps mode 11g
      status: associated
      ssid freebsdap channel 1 <span class=o>(</span>2412 Mhz 11g<span class=o>)</span> bssid 00:11:95:c3:0d:ac
      country US ecm authmode WPA2/802.11i privacy ON deftxkey UNDEF
      AES-CCM 3:128-bit txpower 21.5 bmiss 7 scanvalid 450 bgscan
      bgscanintvl 300 bgscanidle 250 roam:rssi 7 roam:rate 5 protmode CTS
      wme burst roaming MANUAL</code></pre></div></div><div class=paragraph><p>También es posible levantar la interfaz manualmente utilizando <a href="https://man.freebsd.org/cgi/man.cgi?query=wpa_supplicant&amp;sektion=8&amp;format=html">wpa_supplicant(8)</a> y <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a>.</p></div></div><div class=sect3><h4 id=network-wireless-wpa-eap-ttls>29.4.2. WPA with EAP-TTLS<a class=anchor href=#network-wireless-wpa-eap-ttls></a></h4><div class=paragraph><p>Con EAP-TLS, tanto la autenticación de servidor como la de cliente necesitan un certificado. Con EAP-TTLS, el certificado de cliente es opcional. Este método es similar a un servidor web que crea un tunel SSL seguro incluso cuando los visitantes no tienen certificados de cliente. EAP-TTLS utiliza un túnel encriptado con TLS para el transporte seguro de los datos de autenticación.</p></div><div class=paragraph><p>La configuración necesaria se puede añadir a <span class=filename>/etc/wpa_supplicant.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>network={
  ssid=&#34;freebsdap&#34;
  proto=RSN
  key_mgmt=WPA-EAP
  eap=TTLS <i class=conum data-value=1></i><b>(1)</b>
  identity=&#34;test&#34; <i class=conum data-value=2></i><b>(2)</b>
  password=&#34;test&#34; <i class=conum data-value=3></i><b>(3)</b>
  ca_cert=&#34;/etc/certs/cacert.pem&#34; <i class=conum data-value=4></i><b>(4)</b>
  phase2=&#34;auth=MD5&#34; <i class=conum data-value=5></i><b>(5)</b>
}</pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>Este campo especifica el método EAP para la conexión.</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td>El campo <code>identity</code> contiene la cadena de identidad para la autenticación EAP dentro del túnel encriptado con TLS.</td></tr><tr><td><i class=conum data-value=3></i><b>3</b></td><td>El campo <code>password</code> contiene la contraseña para la autenticación EAP.</td></tr><tr><td><i class=conum data-value=4></i><b>4</b></td><td>El campo <code>ca_cert</code> indica la ruta al fichero del certificado de CA. Este fichero es necesario para verificar el certificado de servidor.</td></tr><tr><td><i class=conum data-value=5></i><b>5</b></td><td>Este campo especifica el método de autenticación usado en el túnel TLS encriptado. En este ejemplo, se utiliza EAP con MD5-Challenge. La fase de "autenticación interna" se llama habitualmente "phase2".</td></tr></tbody></table></div><div class=paragraph><p>Después, añade las siguientes líneas a <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>wlans_ath0=&#34;wlan0&#34;
ifconfig_wlan0=&#34;WPA DHCP&#34;</pre></div></div><div class=paragraph><p>El siguiente paso es levantar la interfaz:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service netif start</span>
Starting wpa_supplicant.
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 7
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 15
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 21
DHCPACK from 192.168.0.20
bound to 192.168.0.254 <span class=nt>--</span> renewal <span class=k>in </span>300 seconds.
wlan0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
      ether 00:11:95:d5:43:62
      inet 192.168.0.254 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet DS/11Mbps mode 11g
      status: associated
      ssid freebsdap channel 1 <span class=o>(</span>2412 Mhz 11g<span class=o>)</span> bssid 00:11:95:c3:0d:ac
      country US ecm authmode WPA2/802.11i privacy ON deftxkey UNDEF
      AES-CCM 3:128-bit txpower 21.5 bmiss 7 scanvalid 450 bgscan
      bgscanintvl 300 bgscanidle 250 roam:rssi 7 roam:rate 5 protmode CTS
      wme burst roaming MANUAL</code></pre></div></div></div><div class=sect3><h4 id=network-wireless-wpa-eap-peap>29.4.3. WPA with EAP-PEAP<a class=anchor href=#network-wireless-wpa-eap-peap></a></h4><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>PEAPv0/EAP-MSCHAPv2 es el método PEAP más común. En este capítulo, el término PEAP se usa para referirnos a ese método.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Protected EAP (PEAP) se diseñó como una alternativa a EAP-TTLS y es el segundo estándar EAP más usado por detrás de EAP-TLS. En una red con sistemas operativos variados, PEAP debería ser el estándar más soportado por detrás de EAP-TLS.</p></div><div class=paragraph><p>PEAP es similar a EAP-TTLS ya que utiliza un certificado de servidor para autenticar clientes mediante la creación de un túnel TLS encriptado entre el cliente y el servidor de autenticación, el cual protege el subsiguiente intercambio de información de autenticación. La autenticación PEAP es diferente de EAP-TTLS ya que emite el usuario sin encriptar y sólo la contraseña se envía por el túnel TLS encriptado. EAP-TTLS utilizará el túnel TLS tanto para el nombre de usuario como para la contraseña.</p></div><div class=paragraph><p>Añade las siguientes líneas a <span class=filename>/etc/wpa_supplicant.conf</span> para configurar los parámetros relacionados con EAP-PEAP:</p></div><div class="literalblock programlisting"><div class=content><pre>network={
  ssid=&#34;freebsdap&#34;
  proto=RSN
  key_mgmt=WPA-EAP
  eap=PEAP <i class=conum data-value=1></i><b>(1)</b>
  identity=&#34;test&#34; <i class=conum data-value=2></i><b>(2)</b>
  password=&#34;test&#34; <i class=conum data-value=3></i><b>(3)</b>
  ca_cert=&#34;/etc/certs/cacert.pem&#34; <i class=conum data-value=4></i><b>(4)</b>
  phase1=&#34;peaplabel=0&#34; <i class=conum data-value=5></i><b>(5)</b>
  phase2=&#34;auth=MSCHAPV2&#34; <i class=conum data-value=6></i><b>(6)</b>
}</pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>Este campo especifica el método EAP para la conexión.</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td>El campo <code>identity</code> contiene la cadena de identidad para la autenticación EAP dentro del túnel encriptado con TLS.</td></tr><tr><td><i class=conum data-value=3></i><b>3</b></td><td>El campo <code>password</code> contiene la contraseña para la autenticación EAP.</td></tr><tr><td><i class=conum data-value=4></i><b>4</b></td><td>El campo <code>ca_cert</code> indica la ruta al fichero del certificado de CA. Este fichero es necesario para verificar el certificado de servidor.</td></tr><tr><td><i class=conum data-value=5></i><b>5</b></td><td>Este campo contiene los parámetros para la primera fase de autenticación, el túnel TLS. Según el servidor de autenticación utilizado, especifica una etiqueta concreta para la autenticación. La mayoría de las veces la etiqueta será "cliente EAP encryption" que se establece usando <code>peaplabel=0</code>. Se puede encontrar más información en <a href="https://man.freebsd.org/cgi/man.cgi?query=wpa_supplicant.confg&amp;sektion=5&amp;format=html">wpa_supplicant.confg(5)</a>.</td></tr><tr><td><i class=conum data-value=6></i><b>6</b></td><td>Este campo especifica el protocolo de autenticación utilizado en el túnel encriptado con TLS. En el caso de PEAP, es <code>auth=MSCHAPV2</code>.</td></tr></tbody></table></div><div class=paragraph><p>Añade lo siguiente a <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>wlans_ath0=&#34;wlan0&#34;
ifconfig_wlan0=&#34;WPA DHCP&#34;</pre></div></div><div class=paragraph><p>Después, levanta la interfaz:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service netif start</span>
Starting wpa_supplicant.
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 7
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 15
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 21
DHCPACK from 192.168.0.20
bound to 192.168.0.254 <span class=nt>--</span> renewal <span class=k>in </span>300 seconds.
wlan0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
      ether 00:11:95:d5:43:62
      inet 192.168.0.254 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet DS/11Mbps mode 11g
      status: associated
      ssid freebsdap channel 1 <span class=o>(</span>2412 Mhz 11g<span class=o>)</span> bssid 00:11:95:c3:0d:ac
      country US ecm authmode WPA2/802.11i privacy ON deftxkey UNDEF
      AES-CCM 3:128-bit txpower 21.5 bmiss 7 scanvalid 450 bgscan
      bgscanintvl 300 bgscanidle 250 roam:rssi 7 roam:rate 5 protmode CTS
      wme burst roaming MANUAL</code></pre></div></div></div></div><div class=sect2><h3 id=wireless-ad-hoc-mode>29.5. Modo Ad-hoc Inalámbrico<a class=anchor href=#wireless-ad-hoc-mode></a></h3><div class=paragraph><p>El modo IBSS, también llamado modo ad-hoc, está diseñado para comunicaciones punto a punto. Por ejemplo, para establecer una red ad-hoc entre las máquinas <code>A</code> y <code>B</code>, escoge dos direcciones IP y un SSID.</p></div><div class=paragraph><p>En <code>A</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0 create wlandev ath0 wlanmode adhoc</span>
<span class=c># ifconfig wlan0 inet 192.168.0.1 netmask 255.255.255.0 ssid freebsdap</span>
<span class=c># ifconfig wlan0</span>
  wlan0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
	  ether 00:11:95:c3:0d:ac
	  inet 192.168.0.1 netmask 0xffffff00 broadcast 192.168.0.255
	  media: IEEE 802.11 Wireless Ethernet autoselect mode 11g &lt;adhoc&gt;
	  status: running
	  ssid freebsdap channel 2 <span class=o>(</span>2417 Mhz 11g<span class=o>)</span> bssid 02:11:95:c3:0d:ac
	  country US ecm authmode OPEN privacy OFF txpower 21.5 scanvalid 60
	  protmode CTS wme burst</code></pre></div></div><div class=paragraph><p>El parámetro <code>ad-hoc</code> indica que el interfaz está funcionando en modo IBSS.</p></div><div class=paragraph><p>Ahora <code>B</code> debería ser capaz de detecta a <code>A</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0 create wlandev ath0 wlanmode adhoc</span>
<span class=c># ifconfig wlan0 up scan</span>
  SSID/MESH ID    BSSID              CHAN RATE   S:N     INT CAPS
  freebsdap       02:11:95:c3:0d:ac    2   54M <span class=nt>-64</span>:-96  100 IS   WME</code></pre></div></div><div class=paragraph><p>La <code>I</code> en la salida confirma que <code>A</code> está en modo ad-hoc. Ahora, configura <code>B</code> con una dirección IP diferente:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0 inet 192.168.0.2 netmask 255.255.255.0 ssid freebsdap</span>
<span class=c># ifconfig wlan0</span>
  wlan0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
	  ether 00:11:95:d5:43:62
	  inet 192.168.0.2 netmask 0xffffff00 broadcast 192.168.0.255
	  media: IEEE 802.11 Wireless Ethernet autoselect mode 11g &lt;adhoc&gt;
	  status: running
	  ssid freebsdap channel 2 <span class=o>(</span>2417 Mhz 11g<span class=o>)</span> bssid 02:11:95:c3:0d:ac
	  country US ecm authmode OPEN privacy OFF txpower 21.5 scanvalid 60
	  protmode CTS wme burst</code></pre></div></div><div class=paragraph><p>Ahora <code>A</code> y <code>B</code> están listas para intercambiar información.</p></div><div class=sect3><h4 id=network-wireless-ap>29.5.1. Puntos de Acceso Host FreeBSD<a class=anchor href=#network-wireless-ap></a></h4><div class=paragraph><p>FreeBSD puede actuar como un Punto de Acceso (AP) lo que elimina la necesidad de comparar un hardware AP o montar una red ad-hoc. Esto puede ser particularmente útil cuando una máquina FreeBSD está actuando como gateway a otra red como Internet.</p></div><div class=sect4><h5 id=network-wireless-ap-basic>29.5.1.1. Configuración Básica<a class=anchor href=#network-wireless-ap-basic></a></h5><div class=paragraph><p>Antes de configurar una máquina FreeBSD como un AP, el kernel se tiene que configurar con el soporte de red apropiado para la tarjeta inalámbrica así como con los protocolos de seguridad que se utilizarán. Para más detalles, consulta <a href=#network-wireless-basic>[network-wireless-basic]</a>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>El adaptador de controladores NDIS para controladores de Windows® actualmente no soporta operar en modo AP. Sólo los controladores inalámbricos nativos de FreeBSD soportan modo AP.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Una vez que se ha cargado el soporte para redes inalámbricas, comprueba si el dispositivo inalámbrico soporta el modo de punto de acceso basado en host, también conocido como modo hostap:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0 create wlandev ath0</span>
<span class=c># ifconfig wlan0 list caps</span>
<span class=nv>drivercaps</span><span class=o>=</span>6f85edc1&lt;STA,FF,TURBOP,IBSS,HOSTAP,AHDEMO,TXPMGT,SHSLOT,SHPREAMBLE,MONITOR,MBSS,WPA1,WPA2,BURST,WME,WDS,BGSCAN,TXFRAG&gt;
<span class=nv>cryptocaps</span><span class=o>=</span>1f&lt;WEP,TKIP,AES,AES_CCM,TKIPMIC&gt;</code></pre></div></div><div class=paragraph><p>Esta salida muestra las capacidades de la tarjeta. La palabra <code>HOSTAP</code> confirma que la tarjeta inalámbrica puede actuar como un AP. También se listan varios encriptadores soportados: WEP, TKIP, y AES. Esta información indica qué protocolos de seguridad se pueden utilizar con el AP.</p></div><div class=paragraph><p>El dispositivo inalámbrico sólo puede ser puesto en modo hostap durante la creación del pseudo-dispositivo de red, de forma que si hay una dispositivo creado anteriormente se tiene que destruir primero:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0 destroy</span></code></pre></div></div><div class=paragraph><p>después regenerado con la opción correcta antes de establecer otros parámetros:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0 create wlandev ath0 wlanmode hostap</span>
<span class=c># ifconfig wlan0 inet 192.168.0.1 netmask 255.255.255.0 ssid freebsdap mode 11g channel 1</span></code></pre></div></div><div class=paragraph><p>Usa <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a> de nuevo para ver el estado de la interfaz <span class=filename>wlan0</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0</span>
  wlan0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
	  ether 00:11:95:c3:0d:ac
	  inet 192.168.0.1 netmask 0xffffff00 broadcast 192.168.0.255
	  media: IEEE 802.11 Wireless Ethernet autoselect mode 11g &lt;hostap&gt;
	  status: running
	  ssid freebsdap channel 1 <span class=o>(</span>2412 Mhz 11g<span class=o>)</span> bssid 00:11:95:c3:0d:ac
	  country US ecm authmode OPEN privacy OFF txpower 21.5 scanvalid 60
	  protmode CTS wme burst dtimperiod 1 <span class=nt>-dfs</span></code></pre></div></div><div class=paragraph><p>El parámetro <code>hostap</code> indica que el interfaz está funcionando en modo punto de acceso basado en host.</p></div><div class=paragraph><p>La configuración del interfaz se puede hacer de forma automática al arrancar añadiendo las siguientes líneas a <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>wlans_ath0=&#34;wlan0&#34;
create_args_wlan0=&#34;wlanmode hostap&#34;
ifconfig_wlan0=&#34;inet 192.168.0.1 netmask 255.255.255.0 ssid freebsdap mode 11g channel 1&#34;</pre></div></div></div><div class=sect4><h5 id=_punto_de_acceso_basado_en_host_sin_autenticación_o_encriptación>29.5.1.2. Punto de Acceso basado en Host Sin Autenticación o Encriptación<a class=anchor href=#_punto_de_acceso_basado_en_host_sin_autenticación_o_encriptación></a></h5><div class=paragraph><p>Aunque no se recomienda ejecutar un AP sin ninguna autenticación o encriptación, es una forma simple de comprobar que el AP funciona. Esta configuración también es importante para depurar problemas en el cliente.</p></div><div class=paragraph><p>Una vez que el AP está configurado, inicia un escaneo desde otra máquina inalámbrica para encontrar el AP:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0 create wlandev ath0</span>
<span class=c># ifconfig wlan0 up scan</span>
SSID/MESH ID    BSSID              CHAN RATE   S:N     INT CAPS
freebsdap       00:11:95:c3:0d:ac    1   54M <span class=nt>-66</span>:-96  100 ES   WME</code></pre></div></div><div class=paragraph><p>La máquina cliente ha encontrado el AP y se puede asociar con él:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0 inet 192.168.0.2 netmask 255.255.255.0 ssid freebsdap</span>
<span class=c># ifconfig wlan0</span>
  wlan0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
	  ether 00:11:95:d5:43:62
	  inet 192.168.0.2 netmask 0xffffff00 broadcast 192.168.0.255
	  media: IEEE 802.11 Wireless Ethernet OFDM/54Mbps mode 11g
	  status: associated
	  ssid freebsdap channel 1 <span class=o>(</span>2412 Mhz 11g<span class=o>)</span> bssid 00:11:95:c3:0d:ac
	  country US ecm authmode OPEN privacy OFF txpower 21.5 bmiss 7
	  scanvalid 60 bgscan bgscanintvl 300 bgscanidle 250 roam:rssi 7
	  roam:rate 5 protmode CTS wme burst</code></pre></div></div></div><div class=sect4><h5 id=network-wireless-ap-wpa>29.5.1.3. Punto de Acceso WPA2 basado en Host<a class=anchor href=#network-wireless-ap-wpa></a></h5><div class=paragraph><p>Esta sección se centra en configurar un punto de acceso FreeBSD usando el protocolo de seguridad WPA2. Se pueden encontrar más detalles acerca de WPA y de la configuración de clientes inalámbricos basados en WPA en <a href=#network-wireless-wpa>[network-wireless-wpa]</a>.</p></div><div class=paragraph><p>El demonio <a href="https://man.freebsd.org/cgi/man.cgi?query=hostapd&amp;sektion=8&amp;format=html">hostapd(8)</a> se usa para manejar la autenticación del cliente y la gestión de la clave en el AP con WPA2 habilitado.</p></div><div class=paragraph><p>Una máquina FreeBSD configurada como AP realiza las siguientes operaciones de configuración. Una vez que el AP está funcionando correctamente, se puede iniciar <a href="https://man.freebsd.org/cgi/man.cgi?query=hostapd&amp;sektion=8&amp;format=html">hostapd(8)</a> durante el arranque con esta línea en <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>hostapd_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Antes de intentar configurar <a href="https://man.freebsd.org/cgi/man.cgi?query=hostapd&amp;sektion=8&amp;format=html">hostapd(8)</a>, primero configura los parámetros básicos presentados en <a href=#network-wireless-ap-basic>Configuración Básica</a>.</p></div><div class=sect5><h6 id=_wpa2_psk>29.5.1.3.1. WPA2-PSK<a class=anchor href=#_wpa2_psk></a></h6><div class=paragraph><p>WPA2-PSK está pensado para pequeñas redes donde no se puede o no es deseable utilizar un servidor de autenticación.</p></div><div class=paragraph><p>La configuración se hace en <span class=filename>/etc/hostapd.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>interface=wlan0                  <i class=conum data-value=1></i><b>(1)</b>
debug=1                          <i class=conum data-value=2></i><b>(2)</b>
ctrl_interface=/var/run/hostapd  <i class=conum data-value=3></i><b>(3)</b>
ctrl_interface_group=wheel       <i class=conum data-value=4></i><b>(4)</b>
ssid=freebsdap                   <i class=conum data-value=5></i><b>(5)</b>
wpa=2                            <i class=conum data-value=6></i><b>(6)</b>
wpa_passphrase=freebsdmall       <i class=conum data-value=7></i><b>(7)</b>
wpa_key_mgmt=WPA-PSK             <i class=conum data-value=8></i><b>(8)</b>
wpa_pairwise=CCMP                <i class=conum data-value=9></i><b>(9)</b></pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>Interfaz inalámbrica utilizada para el punto de acceso.</td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td>Nivel de verbosidad utilizado durante la ejecución de <a href="https://man.freebsd.org/cgi/man.cgi?query=hostapd&amp;sektion=8&amp;format=html">hostapd(8)</a>. Un valor de <code>1</code> representa el nivel mínimo.</td></tr><tr><td><i class=conum data-value=3></i><b>3</b></td><td>Ruta del directorio utilizado por <a href="https://man.freebsd.org/cgi/man.cgi?query=hostapd&amp;sektion=8&amp;format=html">hostapd(8)</a> para almacenar ficheros de sockets de dominio para comunicación con programas externos como <a href="https://man.freebsd.org/cgi/man.cgi?query=hostapd_cli&amp;sektion=8&amp;format=html">hostapd_cli(8)</a>. En este ejemplo se usa el valor por defecto.</td></tr><tr><td><i class=conum data-value=4></i><b>4</b></td><td>El grupo que tiene permitido el acceso a los ficheros de control del interfaz.</td></tr><tr><td><i class=conum data-value=5></i><b>5</b></td><td>El nombre de la red inalámbrica, o SSID, que aparecerá en los escaneos inalámbricos.</td></tr><tr><td><i class=conum data-value=6></i><b>6</b></td><td>Activa WPA y especifica qué protocolo de autenticación WPA se requerirá. Un valor de <code>2</code> configura el AP para WPA2 y es el recomendado. Establécelo a <code>1</code> sólo si se necesita el obsoleto WPA.</td></tr><tr><td><i class=conum data-value=7></i><b>7</b></td><td>Contraseña ASCII para la autenticación WPA.</td></tr><tr><td><i class=conum data-value=8></i><b>8</b></td><td>El protocolo de gestión de claves a usar. Este ejemplo establece WPA-PSK.</td></tr><tr><td><i class=conum data-value=9></i><b>9</b></td><td>Algoritmos de encriptación aceptados por el punto de acceso. En este ejemplo, sólo se acepta el encriptador CCMP (AES). CCMP es una alternativa a TKIP y se prefiere siempre que se a posible. TKIP sólo debería permitirse cuando las estaciones con incapaces de usar CCMP.</td></tr></tbody></table></div><div class=paragraph><p>El siguiente paso es arrancar <a href="https://man.freebsd.org/cgi/man.cgi?query=hostapd&amp;sektion=8&amp;format=html">hostapd(8)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service hostapd forcestart</span></code></pre></div></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0</span>
wlan0: <span class=nv>flags</span><span class=o>=</span>8943&lt;UP,BROADCAST,RUNNING,PROMISC,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
	ether 04:f0:21:16:8e:10
	inet6 fe80::6f0:21ff:fe16:8e10%wlan0 prefixlen 64 scopeid 0x9
	nd6 <span class=nv>options</span><span class=o>=</span>21&lt;PERFORMNUD,AUTO_LINKLOCAL&gt;
	media: IEEE 802.11 Wireless Ethernet autoselect mode 11na &lt;hostap&gt;
	status: running
	ssid No5ignal channel 36 <span class=o>(</span>5180 MHz 11a ht/40+<span class=o>)</span> bssid 04:f0:21:16:8e:10
	country US ecm authmode WPA2/802.11i privacy MIXED deftxkey 2
	AES-CCM 2:128-bit AES-CCM 3:128-bit txpower 17 mcastrate 6 mgmtrate 6
	scanvalid 60 ampdulimit 64k ampdudensity 8 shortgi wme burst
	dtimperiod 1 <span class=nt>-dfs</span>
	<span class=nb>groups</span>: wlan</code></pre></div></div><div class=paragraph><p>Una vez que el AP está funcionando, los clientes se pueden asociar a él. Consulta <a href=#network-wireless-wpa>[network-wireless-wpa]</a> para más detalles. Es posible ver las estaciones asociadas con el AP usando <code>ifconfig <em>wlan0</em> list sta</code>.</p></div></div></div></div></div><div class=sect2><h3 id=network-usb-tethering>29.6. Tethering USB<a class=anchor href=#network-usb-tethering></a></h3><div class=paragraph><p>Muchos teléfonos móviles proporcionan la opción de compartir su conexión de datos a través de USB (habitualmente llamado "tethering"). Esta característica usa uno de los protocolos RNDIS, CDC o el protocolo personalizado Apple® iPhone®/iPad®.</p></div><div class=ulist><ul><li><p>Los dispositivos Android™ normalmente utilizan el controlador <a href="https://man.freebsd.org/cgi/man.cgi?query=urndis&amp;sektion=4&amp;format=html">urndis(4)</a>.</p></li><li><p>Los dispositivos Apple® usan el controlador <a href="https://man.freebsd.org/cgi/man.cgi?query=ipheth&amp;sektion=4&amp;format=html">ipheth(4)</a>.</p></li><li><p>Dispositivos más antiguos usarán habitualmente el controlador <a href="https://man.freebsd.org/cgi/man.cgi?query=cdce&amp;sektion=4&amp;format=html">cdce(4)</a>.</p></li></ul></div><div class=paragraph><p>Antes de conectar un dispositivo, carga el controlador apropiado en el kernel:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload if_urndis</span>
<span class=c># kldload if_cdce</span>
<span class=c># kldload if_ipheth</span></code></pre></div></div><div class=paragraph><p>Una vez que el dispositivo está conectado <code>ue</code><em>0</em> estará disponible para que lo usemos como un dispositivo de red normal. Asegúrate de que el dispositivo tiene la opción "USB tethering" activada.</p></div><div class=paragraph><p>Para hacer este cambio permanente y cargar el controlador como un módulo en el arranque, escribe la línea apropiada de las siguientes en <span class=filename>/boot/loader.conf</span>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=nv>if_urndis_load</span><span class=o>=</span><span class=s2>&#34;YES&#34;</span>
<span class=nv>if_cdce_load</span><span class=o>=</span><span class=s2>&#34;YES&#34;</span>
<span class=nv>if_ipheth_load</span><span class=o>=</span><span class=s2>&#34;YES&#34;</span></code></pre></div></div></div><div class=sect2><h3 id=network-bluetooth>29.7. Bluetooth<a class=anchor href=#network-bluetooth></a></h3><div class=paragraph><p>Bluetooth es una tecnología inalámbrica para crear redes personales que operen en la banda sin licenciar de 2.4 GHz, con un rago de 10 metros. Las redes se forman normalmente como ad-hoc a partir de dispositivos portátiles como teléfonos móviles, tabletas, y portátiles. A diferencia de la tecnología inalámbrica Wi-Fi, Bluetooth ofrece perfiles de servicio de más alto nivel, como servidores de fichero tipo FTP, envío de ficheros, transporte de voz, emulación de línea serie, y más.</p></div><div class=paragraph><p>Esta sección describe el uso de un conector USB Bluetooth en un sistema FreeBSD. Después describe varias de las utilidades y protocolos de Bluetooth.</p></div><div class=sect3><h4 id=_cargando_soporte_bluetooth>29.7.1. Cargando Soporte Bluetooth<a class=anchor href=#_cargando_soporte_bluetooth></a></h4><div class=paragraph><p>La pila Bluetooth en FreeBSD está implementada utilizando el framework <a href="https://man.freebsd.org/cgi/man.cgi?query=netgraph&amp;sektion=4&amp;format=html">netgraph(4)</a>. Una gran variedad de conectores USB Bluetooth se soporta con <a href="https://man.freebsd.org/cgi/man.cgi?query=ng_ubt&amp;sektion=4&amp;format=html">ng_ubt(4)</a>. Los dispositivos Bluetooth basados en Broadcom BCM2033 se soportan mediante los controladores <a href="https://man.freebsd.org/cgi/man.cgi?query=ubtbcmfw&amp;sektion=4&amp;format=html">ubtbcmfw(4)</a> y <a href="https://man.freebsd.org/cgi/man.cgi?query=ng_ubt&amp;sektion=4&amp;format=html">ng_ubt(4)</a>. La tarjeta 3Com Bluetooth PC Card 3CRWB60-A está soportada por el controlador <a href="https://man.freebsd.org/cgi/man.cgi?query=ng_bt3c&amp;sektion=4&amp;format=html">ng_bt3c(4)</a>. Los dispositivos serie y UART Bluetooth están soportados por <a href="https://man.freebsd.org/cgi/man.cgi?query=sio&amp;sektion=4&amp;format=html">sio(4)</a>, <a href="https://man.freebsd.org/cgi/man.cgi?query=ng_h4&amp;sektion=4&amp;format=html">ng_h4(4)</a>, y <a href="https://man.freebsd.org/cgi/man.cgi?query=hcseriald&amp;sektion=8&amp;format=html">hcseriald(8)</a>.</p></div><div class=paragraph><p>Antes de conectar un dispositivo, determina cuál de los controladores anteriores utiliza, después carga el controlador. Por ejemplo, si el dispositivo utiliza el controlador <a href="https://man.freebsd.org/cgi/man.cgi?query=ng_ubt&amp;sektion=4&amp;format=html">ng_ubt(4)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload ng_ubt</span></code></pre></div></div><div class=paragraph><p>Si el dispositivo Bluetooth se va a conectar al sistema durante el arranque, éste se puede configurar para cargar el módulo durante el arranque añadiendo el controlador a <span class=filename>/boot/loader.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>ng_ubt_load=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Una vez que el controlador está cargado, conecta el dispositivo USB. Si el controlador se cargó de forma correcta, en la consola y en <span class=filename>/var/log/messages</span> debería aparecer una salida similar a la siguiente:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>ubt0: vendor 0x0a12 product 0x0001, rev 1.10/5.25, addr 2
ubt0: Interface 0 endpoints: <span class=nv>interrupt</span><span class=o>=</span>0x81, bulk-in<span class=o>=</span>0x82, bulk-out<span class=o>=</span>0x2
ubt0: Interface 1 <span class=o>(</span>alt.config 5<span class=o>)</span> endpoints: isoc-in<span class=o>=</span>0x83, isoc-out<span class=o>=</span>0x3,
      <span class=nv>wMaxPacketSize</span><span class=o>=</span>49, <span class=nv>nframes</span><span class=o>=</span>6, buffer <span class=nv>size</span><span class=o>=</span>294</code></pre></div></div><div class=paragraph><p>Para iniciar y parar la pila Bluetooth, utiliza su script de arranque. Es una buena idea parar la pila después de desconectar el dispositivo. Arrancar la pila bluetooth podría necesitar que se arranque <a href="https://man.freebsd.org/cgi/man.cgi?query=hcsecd&amp;sektion=8&amp;format=html">hcsecd(8)</a>. Cuando se arranca la pila, la salida debería ser similar a la siguiente:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service bluetooth start ubt0</span>
BD_ADDR: 00:02:72:00:d4:1a
Features: 0xff 0xff 0xf 00 00 00 00 00
&lt;3-Slot&gt; &lt;5-Slot&gt; &lt;Encryption&gt; &lt;Slot offset&gt;
&lt;Timing accuracy&gt; &lt;Switch&gt; &lt;Hold mode&gt; &lt;Sniff mode&gt;
&lt;Park mode&gt; &lt;RSSI&gt; &lt;Channel quality&gt; &lt;SCO <span class=nb>link</span><span class=o>&gt;</span>
&lt;HV2 packets&gt; &lt;HV3 packets&gt; &lt;u-law log&gt; &lt;A-law log&gt; &lt;CVSD&gt;
&lt;Paging scheme&gt; &lt;Power control&gt; &lt;Transparent SCO data&gt;
Max. ACL packet size: 192 bytes
Number of ACL packets: 8
Max. SCO packet size: 64 bytes
Number of SCO packets: 8</code></pre></div></div></div><div class=sect3><h4 id=_encontrando_otros_dispositivos_bluetooth>29.7.2. Encontrando Otros Dispositivos Bluetooth<a class=anchor href=#_encontrando_otros_dispositivos_bluetooth></a></h4><div class=paragraph><p>El Host Controller Interface (HCI) proporciona un método uniforme para acceder a las capacidades de la banda base de Bluetooth. En FreeBSD, se crea un nodo HCI de netgraph para cada dispositivo Bluetooth. Para más detalles, consulta <a href="https://man.freebsd.org/cgi/man.cgi?query=ng_hci&amp;sektion=4&amp;format=html">ng_hci(4)</a>.</p></div><div class=paragraph><p>Una de las tareas más comunes es el descubrimiento de dispositivos Bluetooth dentro del rango de proximidad de RF. Esta operación se llama <em>inquiry</em> (pregunta). Inquiry y otras operaciones HCI relacionadas se ejecutan con <a href="https://man.freebsd.org/cgi/man.cgi?query=hccontrol&amp;sektion=8&amp;format=html">hccontrol(8)</a>. El ejemplo de abajo muestra cómo encontrar dispositivos Bluetooth que están dentro de rango. La lista de dispositivos debería mostrarse en unos pocos segundos. Ten en cuenta que un dispositivo remoto sólo contestará a la pregunta si está en modo <em>descubrible</em>.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% hccontrol <span class=nt>-n</span> ubt0hci inquiry
Inquiry result, <span class=nv>num_responses</span><span class=o>=</span>1
Inquiry result <span class=c>#0</span>
       BD_ADDR: 00:80:37:29:19:a4
       Page Scan Rep. Mode: 0x1
       Page Scan Period Mode: 00
       Page Scan Mode: 00
       Class: 52:02:04
       Clock offset: 0x78ef
Inquiry complete. Status: No error <span class=o>[</span>00]</code></pre></div></div><div class=paragraph><p><code>BD_ADDR</code> es la dirección única de un dispositivo Bluetooth, similar a la dirección MAC de una tarjeta de red. Esta dirección es necesaria para la comunicación posterior con el dispositivo y es posible asignarle un valor que se amigable de leer. Hay información acerca de los hosts Bluetooth conocidos en <span class=filename>/etc/bluetooth/hosts</span>. El siguiente ejemplo muestra cómo obtener un nombre legible por las personas que ha sido asignado a un dispositivo remoto:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% hccontrol <span class=nt>-n</span> ubt0hci remote_name_request 00:80:37:29:19:a4
BD_ADDR: 00:80:37:29:19:a4
Name: Pav<span class=s1>&#39;s T39</span></code></pre></div></div><div class=paragraph><p>Si se realiza una pregunta a un dispositivo Bluetooth remoto, encontrará tu ordenador como "your.host.name (ubt0)". El nombre asignado al dispositivo local se puede cambiar en cualquier momento.</p></div><div class=paragraph><p>Se puede asignar alias a los dispositivos remotos en <span class=filename>/etc/bluetooth/hosts</span>. Se puede encontrar más información acerca de <span class=filename>/etc/bluetooth/hosts</span> en <a href="https://man.freebsd.org/cgi/man.cgi?query=bluetooth.hosts&amp;sektion=5&amp;format=html">bluetooth.hosts(5)</a>.</p></div><div class=paragraph><p>El sistema Bluetooth proporciona conexión punto a punto entre dos unidades Bluetooth, o punto a multipunto que se comparte entre varios dispositivos Bluetooth. El siguiente ejemplo muestra cómo crear una conexión con un dispositivo remoto:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% hccontrol <span class=nt>-n</span> ubt0hci create_connection BT_ADDR</code></pre></div></div><div class=paragraph><p><code>create_connection</code> acepta <code>BT_ADDR</code> así como los alias encontrados en <span class=filename>/etc/bluetooth/hosts</span>.</p></div><div class=paragraph><p>El siguiente ejemplo muestra cómo obtener la lista de conexiones activas en la banda base para el dispositivo local:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% hccontrol <span class=nt>-n</span> ubt0hci read_connection_list
Remote BD_ADDR    Handle Type Mode Role Encrypt Pending Queue State
00:80:37:29:19:a4     41  ACL    0 MAST    NONE       0     0 OPEN</code></pre></div></div><div class=paragraph><p>Un <em>manejador de conexión</em> es útil cuando se requiere la terminación de una conexión de la banda base, aunque normalmente no es necesario hacer esto a mano. La pila terminará automáticamente las conexiones de banda base inactivas.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># hccontrol -n ubt0hci disconnect 41</span>
Connection handle: 41
Reason: Connection terminated by <span class=nb>local </span>host <span class=o>[</span>0x16]</code></pre></div></div><div class=paragraph><p>Teclea <code>hccontrol help</code> para obtener un listado completo de los comandos HCI disponibles. La mayoría de los comandos HCI no requieren privilegios de súper usuario.</p></div></div><div class=sect3><h4 id=_emparejamiento_de_dispositivos>29.7.3. Emparejamiento de Dispositivos<a class=anchor href=#_emparejamiento_de_dispositivos></a></h4><div class=paragraph><p>Por defecto, la comunicación Bluetooth no está autenticada, y cualquier dispositivo puede hablar con cualquier otro. Un dispositivo Bluetooth, como un teléfono móvil, podría decidir requerir autenticación para proporcionar un servicio particular. La autenticación Bluetooth se hacer normalmente con un <em>código PIN</em>, una cadena ASCII de hasta 16 caracteres. Se requiere que el usuario introduzca el mismo código PIN en ambos dispositivos. Una vez que el usuario ha introducido el código PIN, ambos dispositivos generarán una <em>clave de enlace</em>. Después de eso, la clave de enlace se puede almacenar en los dispositivos o en almacenamiento persistente. La siguiente vez, ambos dispositivos utilizarán las claves de enlace generadas previamente. Este procedimiento se llama <em>emparejamiento</em>. Ten en cuenta que si alguno de los dispositivos pierde la clave de enlace, se tiene que repetir el emparejamiento.</p></div><div class=paragraph><p>El demonio <a href="https://man.freebsd.org/cgi/man.cgi?query=hcsecd&amp;sektion=8&amp;format=html">hcsecd(8)</a> es el responsable de manejar las peticiones de autenticación Bluetooth. El fichero de configuración por defecto es <span class=filename>/etc/bluetooth/hcsecd.conf</span>. A continuación se muestra un ejemplo de sección para un teléfono móvil con el PIN establecido a <code>1234</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>device {
        bdaddr  00:80:37:29:19:a4;
        name    &#34;Pav&#39;s T39&#34;;
        key     nokey;
        pin     &#34;1234&#34;;
      }</pre></div></div><div class=paragraph><p>La única limitación de los códigos PIN es la longitud. Algunos dispositivos, como los auriculares Bluetooth, podrían tener un código PIN fijo de fábrica. La opción <code>-d</code> fuerza a <a href="https://man.freebsd.org/cgi/man.cgi?query=hcsecd&amp;sektion=8&amp;format=html">hcsecd(8)</a> a permanecer en primer plano, de forma que es fácil ver lo que está pasando. Establece el dispositivo remoto para que reciba emparejamientos e inicia la conexión Bluetooth con el dispositivo remoto. El dispositivo remoto debería indicar que el emparejamiento ha sido aceptado y solicitar el código PIN. Introduce el mismo código PIN listado en <span class=filename>hcsecd.conf</span>. Ahora el ordenador y el dispositivo remoto están emparejados. De forma alternativa, el emparejamiento puede ser iniciado por el dispositivo remoto.</p></div><div class=paragraph><p>Se puede añadir la siguiente línea a <span class=filename>/etc/rc.conf</span> para configurar que <a href="https://man.freebsd.org/cgi/man.cgi?query=hcsecd&amp;sektion=8&amp;format=html">hcsecd(8)</a> arranque automáticamente cuando se inicia el sistema:</p></div><div class="literalblock programlisting"><div class=content><pre>hcsecd_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Lo siguiente es una muestra de la salida del demonio <a href="https://man.freebsd.org/cgi/man.cgi?query=hcsecd&amp;sektion=8&amp;format=html">hcsecd(8)</a>:</p></div><div class="literalblock programlisting"><div class=content><pre>hcsecd[16484]: Got Link_Key_Request event from &#39;ubt0hci&#39;, remote bdaddr 0:80:37:29:19:a4
hcsecd[16484]: Found matching entry, remote bdaddr 0:80:37:29:19:a4, name &#39;Pav&#39;s T39&#39;, link key doesn&#39;t exist
hcsecd[16484]: Sending Link_Key_Negative_Reply to &#39;ubt0hci&#39; for remote bdaddr 0:80:37:29:19:a4
hcsecd[16484]: Got PIN_Code_Request event from &#39;ubt0hci&#39;, remote bdaddr 0:80:37:29:19:a4
hcsecd[16484]: Found matching entry, remote bdaddr 0:80:37:29:19:a4, name &#39;Pav&#39;s T39&#39;, PIN code exists
hcsecd[16484]: Sending PIN_Code_Reply to &#39;ubt0hci&#39; for remote bdaddr 0:80:37:29:19:a4</pre></div></div></div><div class=sect3><h4 id=_acceso_a_la_red_con_perfiles_ppp>29.7.4. Acceso a la Red con Perfiles PPP<a class=anchor href=#_acceso_a_la_red_con_perfiles_ppp></a></h4><div class=paragraph><p>Es posible utilizar un perfil DUN (Dial-Up Networking) para configurar un teléfono móvil como un módem inalámbrico para conectarse a un servidor de acceso a Internet. También se puede utilizar para configurar un ordenador para recibir llamadas de datos desde un teléfono móvil.</p></div><div class=paragraph><p>Se puede usar el acceso a la red mediante un perfil PPP para proporcionar acceso LAN para uno o varios dispositivos Bluetooth. También puede proporcionar conexión PC a PC usando PPP sobre emulación de cable serie.</p></div><div class=paragraph><p>En FreeBSD, estos perfiles se implementan con <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> y el adaptador <a href="https://man.freebsd.org/cgi/man.cgi?query=rfcomm_pppd&amp;sektion=8&amp;format=html">rfcomm_pppd(8)</a> que convierte la conexión Bluetooth en algo que PPP puede usar. Antes de que se pueda usar el perfile, se debe crear una nueva etiqueta PPP en <span class=filename>/etc/ppp/ppp.conf</span>. Consulta <a href="https://man.freebsd.org/cgi/man.cgi?query=rfcomm_pppd&amp;sektion=8&amp;format=html">rfcomm_pppd(8)</a> para ver ejemplos.</p></div><div class=paragraph><p>En este ejemplo, se usa <a href="https://man.freebsd.org/cgi/man.cgi?query=rfcomm_pppd&amp;sektion=8&amp;format=html">rfcomm_pppd(8)</a> para abrir una conexión con un dispositivo remoto con un <code>BD_ADDR</code> de <code>00:80:37:29:19:a4</code> en un canal DUNRFCOMM:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># rfcomm_pppd -a 00:80:37:29:19:a4 -c -C dun -l rfcomm-dialup</span></code></pre></div></div><div class=paragraph><p>El número de canal real se obtendrá del dispositivo remoto usando el protocolo SDP. Es posible especificar el canal RFCOMM a mano, y en este caso <a href="https://man.freebsd.org/cgi/man.cgi?query=rfcomm_pppd&amp;sektion=8&amp;format=html">rfcomm_pppd(8)</a> no realizará la consulta SDP. Usa <a href="https://man.freebsd.org/cgi/man.cgi?query=sdpcontrol&amp;sektion=8&amp;format=html">sdpcontrol(8)</a> para averiguar el canal RFCOMM en el dispositivo remoto.</p></div><div class=paragraph><p>Para proporcionar acceso a la red con el servicio PPPLAN, se debe estar ejecutando <a href="https://man.freebsd.org/cgi/man.cgi?query=sdpd&amp;sektion=8&amp;format=html">sdpd(8)</a> y se tienen que crear una nueva entrada para clientes LAN en <span class=filename>/etc/ppp/ppp.conf</span>. Consulta <a href="https://man.freebsd.org/cgi/man.cgi?query=rfcomm_pppd&amp;sektion=8&amp;format=html">rfcomm_pppd(8)</a> para ver ejemplos. Finalmente, arrancar el servidor RFCOMMPPP en un número de canal RFCOMM válido. El servidor RFCOMMPPP registrará automáticamente el servicio LAN Bluetooth con el demonio SDP local. El ejemplo de abajo muestra cómo arrancar el servidor RFCOMMPPP.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># rfcomm_pppd -s -C 7 -l rfcomm-server</span></code></pre></div></div></div><div class=sect3><h4 id=_protocolos_bluetooth>29.7.5. Protocolos Bluetooth<a class=anchor href=#_protocolos_bluetooth></a></h4><div class=paragraph><p>Esta sección proporciona un resumen de varios protocolos Bluetooth, sus funciones, y sus utilidades asociadas.</p></div><div class=sect4><h5 id=_logical_link_control_and_adaptation_protocol_l2cap>29.7.5.1. Logical Link Control and Adaptation Protocol (L2CAP)<a class=anchor href=#_logical_link_control_and_adaptation_protocol_l2cap></a></h5><div class=paragraph><p>El Logical Link Control and Adaptation Protocol (L2CAP) proporciona servicios de datos orientados a conexión así como no orientados a conexión a los protocolos de las capas superiores. L2CAP permite a los protocolos y aplicaciones de niveles más altos transmitir y recibir paquetes de datos L2CAP de hasta 64 kilobytes de longitud.</p></div><div class=paragraph><p>L2CAP se basa en el concepto de <em>canales</em>. Un canal es una conexión lógica construida sobre una conexión de banda base, donde cada canal está asociado a un sólo protocolo en una forma muchos-a-uno. Se pueden asociar múltiples canales al mismo protocolo, pero un canal no se puede asociar a múltiples protocolos. Cada paquete L2CAP recibido en un canal es redirigido al protocolo de nivel superior apropiado. Varios canales pueden compartir la misma conexión de banda base.</p></div><div class=paragraph><p>En FreeBSD, se crear un nodo L2CAP de netgraph para cada dispositivo Bluetooth. Este nodo normalmente se conecta con el nodo HCI Bluetooth inferior y los nodos socket Bluetooth superiores. El nombre por defecto para el nodo L2CAP es "devicel2cap". Para más detalles consulta <a href="https://man.freebsd.org/cgi/man.cgi?query=ng_l2cap&amp;sektion=4&amp;format=html">ng_l2cap(4)</a>.</p></div><div class=paragraph><p>Un comando útil es <a href="https://man.freebsd.org/cgi/man.cgi?query=l2ping&amp;sektion=8&amp;format=html">l2ping(8)</a>, que puede ser usado para hacer ping a otros dispositivos. Algunas implementaciones Bluetooth podrían no devolver todos los datos que se les envía, de forma que los <code>0 bytes</code> en el siguiente ejemplo es algo normal.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># l2ping -a 00:80:37:29:19:a4</span>
0 bytes from 0:80:37:29:19:a4 <span class=nv>seq_no</span><span class=o>=</span>0 <span class=nb>time</span><span class=o>=</span>48.633 ms <span class=nv>result</span><span class=o>=</span>0
0 bytes from 0:80:37:29:19:a4 <span class=nv>seq_no</span><span class=o>=</span>1 <span class=nb>time</span><span class=o>=</span>37.551 ms <span class=nv>result</span><span class=o>=</span>0
0 bytes from 0:80:37:29:19:a4 <span class=nv>seq_no</span><span class=o>=</span>2 <span class=nb>time</span><span class=o>=</span>28.324 ms <span class=nv>result</span><span class=o>=</span>0
0 bytes from 0:80:37:29:19:a4 <span class=nv>seq_no</span><span class=o>=</span>3 <span class=nb>time</span><span class=o>=</span>46.150 ms <span class=nv>result</span><span class=o>=</span>0</code></pre></div></div><div class=paragraph><p>La utilidad <a href="https://man.freebsd.org/cgi/man.cgi?query=l2control&amp;sektion=8&amp;format=html">l2control(8)</a> se utiliza para realizar varias operaciones sobre los nodos L2CAP. Este ejemplo muestra cómo obtener la lista de conexiones lógicas (canales) y la lista de conexiones de banda base para el dispositivo local:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% l2control <span class=nt>-a</span> 00:02:72:00:d4:1a read_channel_list
L2CAP channels:
Remote BD_ADDR     SCID/ DCID   PSM  IMTU/ OMTU State
00:07:e0:00:0b:ca    66/   64     3   132/  672 OPEN
% l2control <span class=nt>-a</span> 00:02:72:00:d4:1a read_connection_list
L2CAP connections:
Remote BD_ADDR    Handle Flags Pending State
00:07:e0:00:0b:ca     41 O           0 OPEN</code></pre></div></div><div class=paragraph><p>Otra herramienta de diagnóstico es <a href="https://man.freebsd.org/cgi/man.cgi?query=btsockstat&amp;sektion=1&amp;format=html">btsockstat(1)</a>. Es similar a <a href="https://man.freebsd.org/cgi/man.cgi?query=netstat&amp;sektion=1&amp;format=html">netstat(1)</a>, pero para estructuras de datos de red Bluetooth. El ejemplo de abajo muestra la misma conexión lógica como <a href="https://man.freebsd.org/cgi/man.cgi?query=l2control&amp;sektion=8&amp;format=html">l2control(8)</a> arriba.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% btsockstat
Active L2CAP sockets
PCB      Recv-Q Send-Q Local address/PSM       Foreign address   CID   State
c2afe900      0      0 00:02:72:00:d4:1a/3     00:07:e0:00:0b:ca 66    OPEN
Active RFCOMM sessions
L2PCB    PCB      Flag MTU   Out-Q DLCs State
c2afe900 c2b53380 1    127   0     Yes  OPEN
Active RFCOMM sockets
PCB      Recv-Q Send-Q Local address     Foreign address   Chan DLCI State
c2e8bc80      0    250 00:02:72:00:d4:1a 00:07:e0:00:0b:ca 3    6    OPEN</code></pre></div></div></div><div class=sect4><h5 id=_comunicación_por_radio_frecuencia_rfcomm>29.7.5.2. Comunicación por Radio Frecuencia (RFCOMM)<a class=anchor href=#_comunicación_por_radio_frecuencia_rfcomm></a></h5><div class=paragraph><p>El protocolo RFCOMM proporciona emulación de puertos serie sobre el protocolo L2CAP. RFCOMM es un protocolo de transporte simple, con soporte adicional para emular los 9 circuitos de los puertos serie RS-2332 (EIATIA-232-E). Soporta hasta 60 conexiones simultáneas (canales RFCOMM) entre dos dispositivos Bluetooth.</p></div><div class=paragraph><p>Para los propósitos de RFCOMM, un camino de comunicación completo incluye dos aplicaciones ejecutándose en los extremos de la comunicación con un segmento de comunicación entre ellos. RFCOMM está pensado para cubrir aplicaciones que hace uso de los puertos serie de los dispositivos en los que se encuentra. El segmento de comunicación es una enlace de conexión Bluetooth directa desde un dispositivo a otro.</p></div><div class=paragraph><p>RFCOMM sólo se preocupa de la conexión entre los dispositivos en el caso de una conexión directa, o entre un dispositivo y un módem en el caso de red. RFCOMM puede soportar otras configuraciones, como módulos que se comunican vía tecnología inalámbrica Bluetooth en un lado y proporciona un interfaz por cable en el otro lado.</p></div><div class=paragraph><p>En FreeBSD, RFCOMM está implementado en la capa de sockets Bluetooth.</p></div></div><div class=sect4><h5 id=_protocolo_de_descubrimiento_de_servicios_sdp>29.7.5.3. Protocolo de Descubrimiento de Servicios (SDP)<a class=anchor href=#_protocolo_de_descubrimiento_de_servicios_sdp></a></h5><div class=paragraph><p>El Protocolo de Descubrimiento de Servicios (SDP) proporciona los medios para que las aplicaciones cliente descubran la existencia de servicios proporcionados por aplicaciones servidoras así como los atributos de dichos servicios. Los atributos de un servicio incluyen el tipo o clase del servicio ofrecido y el mecanismo o protocolo de información necesario para utilizarlo.</p></div><div class=paragraph><p>SDP incluye comunicación entre un servidor SDP y un cliente SDP. El servidor mantiene una lista de registros de servicio que describe las características de los servicios asociados con el servidor. Cada registro de servicio contiene información acerca de un único servicio. Un cliente puede recuperar información de un registro de servicio mantenido por el servidor SDP realizando una petición SDP. Si el cliente, o una aplicación asociada con el cliente, decide usar un servicio, debe abrir una conexión separada con el proveedor del servicio para poder utilizarlo. SDP proporciona un mecanismo para descubrir servicios y sus atributos, pero no proporciona un mecanismo para utilizar esos servicios.</p></div><div class=paragraph><p>Normalmente, un cliente SDP busca servicios basándose en alguna característica deseada de los servicios. Sin embargo, a veces es preferible descubrir qué tipos de servicios están descritos por los registros de servicio de un servidor SDP sin ninguna información previa acerca de los servicios. Este proceso de buscar cualquier servicio ofrecido se llama <em>navegación</em> (browsing).</p></div><div class=paragraph><p>El servidor SDP Bluetooth, <a href="https://man.freebsd.org/cgi/man.cgi?query=sdpd&amp;sektion=8&amp;format=html">sdpd(8)</a>, y cliente en línea de comando, <a href="https://man.freebsd.org/cgi/man.cgi?query=sdpcontrol&amp;sektion=8&amp;format=html">sdpcontrol(8)</a>, están incluidos en la instalación estándar de FreeBSD. El siguiente ejemplo muestra cómo realizar una petición de navegación SDP.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% sdpcontrol <span class=nt>-a</span> 00:01:03:fc:6e:ec browse
Record Handle: 00000000
Service Class ID List:
        Service Discovery Server <span class=o>(</span>0x1000<span class=o>)</span>
Protocol Descriptor List:
        L2CAP <span class=o>(</span>0x0100<span class=o>)</span>
                Protocol specific parameter <span class=c>#1: u/int/uuid16 1</span>
                Protocol specific parameter <span class=c>#2: u/int/uuid16 1</span>

Record Handle: 0x00000001
Service Class ID List:
        Browse Group Descriptor <span class=o>(</span>0x1001<span class=o>)</span>

Record Handle: 0x00000002
Service Class ID List:
        LAN Access Using PPP <span class=o>(</span>0x1102<span class=o>)</span>
Protocol Descriptor List:
        L2CAP <span class=o>(</span>0x0100<span class=o>)</span>
        RFCOMM <span class=o>(</span>0x0003<span class=o>)</span>
                Protocol specific parameter <span class=c>#1: u/int8/bool 1</span>
Bluetooth Profile Descriptor List:
        LAN Access Using PPP <span class=o>(</span>0x1102<span class=o>)</span> ver. 1.0</code></pre></div></div><div class=paragraph><p>Ten en cuenta que cada servicio tiene una lista de atributos, como el canal RFCOMM. Dependiendo del servicio, el usuario podría necesitar anotar algunos de los atributos. Algunas implementaciones de Bluetooth no soportan la navegación de servicios y podrían devolver una lista vacía. En este caso, es posible buscar un servicio específico. El ejemplo inferior muestra cómo buscar el servicio OBEX Object Push (OPUSH):</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% sdpcontrol <span class=nt>-a</span> 00:01:03:fc:6e:ec search OPUSH</code></pre></div></div><div class=paragraph><p>Ofrecer servicios de FreeBSD a clientes Bluetooth se hace con el servidor <a href="https://man.freebsd.org/cgi/man.cgi?query=sdpd&amp;sektion=8&amp;format=html">sdpd(8)</a>. Se puede añadir la siguiente línea a <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>sdpd_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>El demonio <a href="https://man.freebsd.org/cgi/man.cgi?query=sdpd&amp;sektion=8&amp;format=html">sdpd(8)</a> se puede arrancar con:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service sdpd start</span></code></pre></div></div><div class=paragraph><p>La aplicación servidora local que quiera proporcionar un servicio Bluetooth a clientes remotos registrará el servicio en el demonio SDP local. Un ejemplo de dicha aplicación es <a href="https://man.freebsd.org/cgi/man.cgi?query=rfcomm_pppd&amp;sektion=8&amp;format=html">rfcomm_pppd(8)</a>. Una vez iniciado, registrará el servicio LAN Bluetooth con el demonio local SDP.</p></div><div class=paragraph><p>Se puede obtener la lista de servicios registrados en el servidor SDP local realizando una petición de navegación SDP mediante el canal de control local:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># sdpcontrol -l browse</span></code></pre></div></div></div><div class=sect4><h5 id=_obex_object_push_opush>29.7.5.4. OBEX Object Push (OPUSH)<a class=anchor href=#_obex_object_push_opush></a></h5><div class=paragraph><p>Object Exchange (OBEX) es un protocolo ampliamente utilizado para transferencias de ficheros sencillas entre dispositivos móviles. Su principal uso está en la comunicación infrarroja, donde se usa para transferencias de ficheros genéricas entre portátiles o PDAs, y para enviar tarjetas de negocios o entradas de calendario entre teléfonos móviles y otros dispositivos con aplicaciones PIM (Personal Information Manager).</p></div><div class=paragraph><p>El servidor y cliente OBEX están implementados por obexapp, que se pude instalar usando el paquete o port <a class=package href=https://cgit.freebsd.org/ports/tree/comms/obexapp/>comms/obexapp</a>.</p></div><div class=paragraph><p>El cliente OBEX es utilizado para subir y/o bajar objetos del servidor OBEX. Un objeto de ejemplo es una tarjeta de negocio o una cita. El cliente OBEX puede obtener el número de canal RFCOMM del dispositivo remoto vía SDP. Esto se puede hacer especificando el nombre del servicio en lugar del número de canal RFCOMM. Los nombres de servicios soportados son: <code>IrMC</code>, <code>FTRN</code>, y <code>OPUSH</code>. También es posible especificar el canal RFCOMM como un número. Abajo hay un ejemplo de una sesión OBEX donde el objeto de información del dispositivo se descarga desde un teléfono móvil, y un nuevo objeto, la tarjeta de negocio, se sube al directorio del teléfono.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% obexapp <span class=nt>-a</span> 00:80:37:29:19:a4 <span class=nt>-C</span> IrMC
obex&gt; get telecom/devinfo.txt devinfo-t39.txt
Success, response: OK, Success <span class=o>(</span>0x20<span class=o>)</span>
obex&gt; put new.vcf
Success, response: OK, Success <span class=o>(</span>0x20<span class=o>)</span>
obex&gt; di
Success, response: OK, Success <span class=o>(</span>0x20<span class=o>)</span></code></pre></div></div><div class=paragraph><p>Para proporcionar el servicio OPUSH, <a href="https://man.freebsd.org/cgi/man.cgi?query=sdpd&amp;sektion=8&amp;format=html">sdpd(8)</a> debe estar en ejecución y se debe crear una carpeta raíz donde se almacenarán todos los objetos recibidos. La ruta por defecto de la carpeta raíz es <span class=filename>/var/spool/obex</span>. Por último, inicia el servidor OBEX en un número de canal RFCOMM válido. El servidor OBEX registrará automáticamente el servicio OPUSH con el demonio SDP local. El ejemplo de abajo muestra cómo iniciar el servidor OBEX.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># obexapp -s -C 10</span></code></pre></div></div></div><div class=sect4><h5 id=_perfil_de_puerto_serie_spp>29.7.5.5. Perfil de Puerto Serie (SPP)<a class=anchor href=#_perfil_de_puerto_serie_spp></a></h5><div class=paragraph><p>El Perfil de Puerto Serie (SPP) permite a los dispositivos Bluetooth realizar emulación de cable serie. Este perfile permite a aplicaciones heredadas utilizar Bluetooth como un sustituto del cable, a través de una abstracción de puerto serie.</p></div><div class=paragraph><p>En FreeBSD, <a href="https://man.freebsd.org/cgi/man.cgi?query=rfcomm_sppd&amp;sektion=1&amp;format=html">rfcomm_sppd(1)</a> implementa SPP y un pseudo tty es usado como abstracción de puerto serie virtual. El ejemplo de abajo muestra cómo conectarse al servicio de puerto serie de un dispositivo remoto. No se tiene que especificar un canal RFCOMM ya que <a href="https://man.freebsd.org/cgi/man.cgi?query=rfcomm_sppd&amp;sektion=1&amp;format=html">rfcomm_sppd(1)</a> puede obtenerlo del dispositivo remoto vía SDP. Para cambiar esto, especifica un canal RFCOMM en la línea de comando.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># rfcomm_sppd -a 00:07:E0:00:0B:CA -t</span>
rfcomm_sppd[94692]: Starting on /dev/pts/6...
/dev/pts/6</code></pre></div></div><div class=paragraph><p>Una vez conectado, el pseudo tty puede ser usado como un puerto serie:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># cu -l /dev/pts/6</span></code></pre></div></div><div class=paragraph><p>El pseudo tty se imprime en stdout y se puede leer mediante scripts:</p></div><div class="literalblock programlisting"><div class=content><pre>PTS=`rfcomm_sppd -a 00:07:E0:00:0B:CA -t`
cu -l $PTS</pre></div></div></div></div><div class=sect3><h4 id=_resolución_de_problemas_2>29.7.6. Resolución de problemas<a class=anchor href=#_resolución_de_problemas_2></a></h4><div class=paragraph><p>Por defecto, cuando FreeBSD está aceptando una nueva conexión, intenta realizar un cambio de roles y convertirse en maestro. Algunos dispositivos Bluetooth más antiguos que no soportan el cambio de roles no serán capaces de conectar. Puesto que el cambio de roles se realiza cuando se establece una nueva conexión, no es posible preguntar al dispositivo remoto si soporta el cambio de roles. Sin embargo, hay una opción HCI para deshabilitar el intercambio de roles en el lado local:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># hccontrol -n ubt0hci write_node_role_switch 0</span></code></pre></div></div><div class=paragraph><p>Para mostrar paquetes Bluetooht, usa el paquete de terceros hcidump, que se puede instalar mediante el paquete o port <a class=package href=https://cgit.freebsd.org/ports/tree/comms/hcidump/>comms/hcidump</a>. Esta utilidad es similar a <a href="https://man.freebsd.org/cgi/man.cgi?query=tcpdump&amp;sektion=1&amp;format=html">tcpdump(1)</a> y se puede usar para mostrar el contenido de los paquetes Bluetooth en el terminal y para volcarlos a un fichero.</p></div></div></div><div class=sect2><h3 id=network-bridging>29.8. Bridging<a class=anchor href=#network-bridging></a></h3><div class=paragraph><p>A veces es útil dividir una red, como un segmento Ethernet, en segmentos de red sin tener que crear subredes IP y utilizar un router para conectar los segmentos entre ellos. Un dispositivo que conecta dos redes juntas de esta forma se llama "bridge".</p></div><div class=paragraph><p>Un bridge funciona aprendiendo las direcciones MAC de los dispositivos en cada una de sus interfaces de red. Reenvía tráfico entre las redes sólo cuando las direcciones de origen y destino están en diferentes redes. En muchos aspectos, un bridge es como un switch Ethernet con muy pocos puertos. Un sistema FreeBSD como varias interfaces de red puede ser configurado para funcionar como un bridge.</p></div><div class=paragraph><p>Un bridge puede ser útil en las siguientes situaciones:</p></div><div class=dlist><dl><dt class=hdlist1>Conectar Redes</dt><dd><p>La operación básica de un bridge es juntar dos o más segmentos de red. Hay muchas razones para usar un bridge basado en host en lugar de un equipamiento de red, como restricciones en el cableado o los firewalls. Un bridge también puede conectar una interfaz inalámbrica funcionando en modo hostap con una red cableada y actuar como punto de acceso.</p></dd><dt class=hdlist1>Filtrado/Firewall the Modelado de Tráfico</dt><dd><p>Se puede usar un bridge cuando se necesita funcionalidad de firewall sin enrutado o traducciones de direcciones de red (NAT, Network Address Translation).</p><div class=paragraph><p>Un ejemplo es una pequeña compañía que está conectada a un ISP mediante DSL o ISDN. Hay trece direcciones IP públicas del ISP y diez ordenadores en la red. En esta situación, usar un firewall basado en un router es difícil por problemas con las subredes. Un firewall basado en bridge se puede configurar sin ningún problema con las direcciones IP.</p></div></dd><dt class=hdlist1>Network Tap</dt><dd><p>Un bridge puede unir dos segmentos de red para inspeccionar todas las tramas Ethernet que pasan entre ellos usando <a href="https://man.freebsd.org/cgi/man.cgi?query=bpf&amp;sektion=4&amp;format=html">bpf(4)</a> y <a href="https://man.freebsd.org/cgi/man.cgi?query=tcpdump&amp;sektion=1&amp;format=html">tcpdump(1)</a> en la interfaz bridge, o enviando una copia de todas las tramas hacia un interfaz adicional conocido como un puerto span.</p></dd><dt class=hdlist1>VPN en la Capa 2</dt><dd><p>Dos redes Ethernet se pueden unir mediante un enlace IP uniendo las redes a un túnel EtherIP o a una solución basada en <a href="https://man.freebsd.org/cgi/man.cgi?query=tap&amp;sektion=4&amp;format=html">tap(4)</a> como OpenVPN.</p></dd><dt class=hdlist1>Redundancia en la Capa 2</dt><dd><p>Una red puede estar conectada con múltiples enlaces y usar el Spanning Tree Protocol (STP) para bloquear caminos redundantes.</p></dd></dl></div><div class=paragraph><p>Esta sección describe cómo configurar un sistema FreeBSD como un bridge usando <a href="https://man.freebsd.org/cgi/man.cgi?query=if_bridge&amp;sektion=4&amp;format=html">if_bridge(4)</a>. También hay disponible un driver bridge de netgraph, y se describe en <a href="https://man.freebsd.org/cgi/man.cgi?query=ng_bridge&amp;sektion=4&amp;format=html">ng_bridge(4)</a>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Se pude usar filtrado de paquetes con cualquier paquete de firewall que se enganche en el framework <a href="https://man.freebsd.org/cgi/man.cgi?query=pfil&amp;sektion=9&amp;format=html">pfil(9)</a>. El bridge se puede usar como un perfilador de tráfico con <a href="https://man.freebsd.org/cgi/man.cgi?query=altq&amp;sektion=4&amp;format=html">altq(4)</a> o <a href="https://man.freebsd.org/cgi/man.cgi?query=dummynet&amp;sektion=4&amp;format=html">dummynet(4)</a>.</p></div></td></tr></tbody></table></div><div class=sect3><h4 id=_habilitando_el_bridge>29.8.1. Habilitando el Bridge<a class=anchor href=#_habilitando_el_bridge></a></h4><div class=paragraph><p>En FreeBSD, <a href="https://man.freebsd.org/cgi/man.cgi?query=if_bridge&amp;sektion=4&amp;format=html">if_bridge(4)</a> es un módulo del kernel que se carga automáticamente cuando <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a> crea un interfaz bridge. También es posible compilar soporte para bridge en un kernel personalizado añadiendo <code>device if_bridge</code> al fichero de configuración del kernel personalizado.</p></div><div class=paragraph><p>El bridge se crea clonando una interfaz. Para crear la interfaz bridge:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig bridge create</span>
bridge0
<span class=c># ifconfig bridge0</span>
bridge0: <span class=nv>flags</span><span class=o>=</span>8802&lt;BROADCAST,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        ether 96:3d:4b:f1:79:7a
        <span class=nb>id </span>00:00:00:00:00:00 priority 32768 hellotime 2 fwddelay 15
        maxage 20 holdcnt 6 proto rstp maxaddr 100 <span class=nb>timeout </span>1200
        root <span class=nb>id </span>00:00:00:00:00:00 priority 0 ifcost 0 port 0</code></pre></div></div><div class=paragraph><p>Cuando se crea una interfaz bridge, se le asigna automáticamente una dirección Ethernet generada de forma aleatoria. Los parámetros <code>maxaddr</code> y <code>timeout</code> controlan cuántas direcciones MAC puede mantener el bridge en su tabla de reenvío y cuántos segundos deben pasar para eliminarla desde la última vez que han sido vistas. Los otros parámetros controlan cómo opera STP.</p></div><div class=paragraph><p>Después, especifica qué interfaces de red añadir como miembros del bridge. Para que el bridge sea capaz de reenviar paquetes, todas las interfaces y el bridge necesitan estar levantadas:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig bridge0 addm fxp0 addm fxp1 up</span>
<span class=c># ifconfig fxp0 up</span>
<span class=c># ifconfig fxp1 up</span></code></pre></div></div><div class=paragraph><p>El puente ahora puede reenviar tramas Ethernet entre <span class=filename>fxp0</span> y <span class=filename>fxp1</span>. Añade las siguientes líneas a <span class=filename>/etc/rc.conf</span> de forma que el bridge se cree al arrancar:</p></div><div class="literalblock programlisting"><div class=content><pre>cloned_interfaces=&#34;bridge0&#34;
ifconfig_bridge0=&#34;addm fxp0 addm fxp1 up&#34;
ifconfig_fxp0=&#34;up&#34;
ifconfig_fxp1=&#34;up&#34;</pre></div></div><div class=paragraph><p>Si la máquina bridge necesita una dirección IP, establécela en la interfaz del bridge, no en las interfaces que son miembro. La dirección puede establecerse estáticamente o vía DHCP. Este ejemplo establece una dirección IP estática:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig bridge0 inet 192.168.0.1/24</span></code></pre></div></div><div class=paragraph><p>También es posible establecer una dirección IPv6 al interfaz del bridge. Para hacer los cambios permanentes, añade la información de la dirección a <span class=filename>/etc/rc.conf</span>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Cuando el filtrado de paquetes está habilitado, los paquetes que van por el bridge pasarán a través del filtro de entrada en la interfaz de origen en el interfaz del bridge, y de salida en las interfaces apropiadas. Cualquiera de las dos fases puede deshabilitarse. Cuando la dirección de un paquete es importante, es mejor aplicar el firewall en las interfaces que forman el bridge que en el bridge en sí mismo.</p></div><div class=paragraph><p>El bridge tiene varios valores configurables para pasar paquetes IP y no IP, y firewall the capa 2 con <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfw&amp;sektion=8&amp;format=html">ipfw(8)</a>. Consulta <a href="https://man.freebsd.org/cgi/man.cgi?query=if_bridge&amp;sektion=4&amp;format=html">if_bridge(4)</a> para más información.</p></div></td></tr></tbody></table></div></div><div class=sect3><h4 id=_activando_spanning_tree>29.8.2. Activando Spanning Tree<a class=anchor href=#_activando_spanning_tree></a></h4><div class=paragraph><p>Para que una red Ethernet funcione adecuadamente, sólo debe existir un camino activo entre dos dispositivos. El protocolo STP detecta bucles y pone enlaces redundantes en un estado bloqueado. Si uno de los enlaces activos fallara, STP calcula un árbol diferente y activa uno de los caminos bloqueados para restaurar la conectividad a todos los puntos de la red.</p></div><div class=paragraph><p>El protocolo Rapid Spanning Tree (RSTP o 802.1w) proporciona compatibilidad hacia atrás con el STP antiguo. RSTP proporciona una convergencia más rápida e intercambia información con switches vecinos para transicionar rápidamente a modo reenvío sin crear bycles. FreeBSD soporta como modos de operación RSTP y STP, siendo RSTP el modo por defecto.</p></div><div class=paragraph><p>Se puede activar STP en las interfaces miembro usando <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a>. Para un bridge con <span class=filename>fxp0</span> y <span class=filename>fxp1</span> como interfaces actuales, activa STP con:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig bridge0 stp fxp0 stp fxp1</span>
bridge0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        ether d6:cf:d5:a0:94:6d
        <span class=nb>id </span>00:01:02:4b:d4:50 priority 32768 hellotime 2 fwddelay 15
        maxage 20 holdcnt 6 proto rstp maxaddr 100 <span class=nb>timeout </span>1200
        root <span class=nb>id </span>00:01:02:4b:d4:50 priority 32768 ifcost 0 port 0
        member: fxp0 <span class=nv>flags</span><span class=o>=</span>1c7&lt;LEARNING,DISCOVER,STP,AUTOEDGE,PTP,AUTOPTP&gt;
                port 3 priority 128 path cost 200000 proto rstp
                role designated state forwarding
        member: fxp1 <span class=nv>flags</span><span class=o>=</span>1c7&lt;LEARNING,DISCOVER,STP,AUTOEDGE,PTP,AUTOPTP&gt;
                port 4 priority 128 path cost 200000 proto rstp
                role designated state forwarding</code></pre></div></div><div class=paragraph><p>Este bridge tiene un spanning tree con un ID de <code>00:01:02:4b:d4:50</code> y una prioridad de <code>32768</code>. Como el <code>root id</code> es el mismo, eso indica que es el bridge raíz del árbol.</p></div><div class=paragraph><p>Otro bridge en la red tiene STP activado:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>bridge0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        ether 96:3d:4b:f1:79:7a
        <span class=nb>id </span>00:13:d4:9a:06:7a priority 32768 hellotime 2 fwddelay 15
        maxage 20 holdcnt 6 proto rstp maxaddr 100 <span class=nb>timeout </span>1200
        root <span class=nb>id </span>00:01:02:4b:d4:50 priority 32768 ifcost 400000 port 4
        member: fxp0 <span class=nv>flags</span><span class=o>=</span>1c7&lt;LEARNING,DISCOVER,STP,AUTOEDGE,PTP,AUTOPTP&gt;
                port 4 priority 128 path cost 200000 proto rstp
                role root state forwarding
        member: fxp1 <span class=nv>flags</span><span class=o>=</span>1c7&lt;LEARNING,DISCOVER,STP,AUTOEDGE,PTP,AUTOPTP&gt;
                port 5 priority 128 path cost 200000 proto rstp
                role designated state forwarding</code></pre></div></div><div class=paragraph><p>La línea <code>root id 00:01:02:4b:d4:50 priority 32768 ifcost 400000 port 4</code> muestra que el bridge raíz es <code>00:01:02:4b:d4:50</code> y que tiene un camino con coste <code>400000</code> desde este bridge. La ruta al brige raíz es vía <code>port 4</code> que es <span class=filename>fxp0</span>.</p></div></div><div class=sect3><h4 id=_parámetros_de_la_interfaz_del_bridge>29.8.3. Parámetros de la Interfaz del Bridge<a class=anchor href=#_parámetros_de_la_interfaz_del_bridge></a></h4><div class=paragraph><p>Varios parámetros de <code>ifconfig</code> son únicos de las interfaces del bridge. Esta sección resume algunos casos comunes para estos parámetros. <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a> describe la lista completa de parámetros disponibles.</p></div><div class=dlist><dl><dt class=hdlist1>private</dt><dd><p>Una interfaz privada no reenvía nada de tráfico a otro puerto que no esté designado como una interfaz privada. El tráfico se bloquea incondicionalmente de forma que las tramas Ethernet no serán reenviadas, incluyendo los paquetes ARP. Si se necesita bloquear el tráfico de forma selectiva, se tiene que usar un firewall.</p></dd><dt class=hdlist1>span</dt><dd><p>Un puerto span transmite una copia de cada trama Ethernet recibida en el bridge. El número de puertos span configurados en el bridge es ilimitado, pero si una interfaz es designada como un puerto span, no puede ser usada también como un puerto regular en el bridge. Esto es muy útil para husmear en una red con bridge de forma pasiva en otro host conectado a uno de los puertos span del bridge. Por ejemplo, para enviar una copia de todas las tramas obtenidas de la interfaz <span class=filename>fxp4</span>:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig bridge0 span fxp4</span></code></pre></div></div></dd><dt class=hdlist1>sticky</dt><dd><p>Si una interfaz del bridge es marcada como sticky, las entradas de direcciones aprendidas dinámicamente se tratan como entradas estáticas en la caché de reenvío. Las entradas sticky no envejecen nunca en la caché ni son reemplazadas, incluso si la dirección es vista en otra interfaz. Esto ofrece el beneficio de las entradas de direcciones estáticas sin la necesidad de poblar la tabla de reenvío con antelación. Los clientes que se han aprendido de un segmento del bridge en particular no pueden moverse a otro segmento.</p><div class=paragraph><p>Un ejemplo de uso de direcciones sticky es combinar el bridge con VLANs para aislar redes cliente sin gastar espacio de direcciones IP. Considera que <code>CustomerA</code> está en <code>vlan100</code>, <code>CustomerB</code> está en <code>vlan101</code>, y el bridge tiene la dirección <code>192.168.0.1</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig bridge0 addm vlan100 sticky vlan100 addm vlan101 sticky vlan101</span>
<span class=c># ifconfig bridge0 inet 192.168.0.1/24</span></code></pre></div></div><div class=paragraph><p>En este ejemplo, ambos clientes ven <code>192.168.0.1</code> como su gateway por defecto. Puesto que la caché del bridge es sticky, un host no puede falsear la dirección MAC de otro cliente para interceptar su tráfico.</p></div><div class=paragraph><p>Cualquier comunicación entre las VLANs se puede bloquear utilizando un firewall o, como se ve en este ejemplo, usando interfaces privadas:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig bridge0 private vlan100 private vlan101</span></code></pre></div></div><div class=paragraph><p>Los clientes están completamente aislados entre sí y el rango de direcciones completo <code>/24</code> se puede reservar sin necesidad de crear subredes.</p></div><div class=paragraph><p>Se puede limitar el número direcciones MAC fuente únicas detrás de una interfaz. Una vez que se alcance el límite, los paquetes que tengan una dirección de origen desconocida serán descartados hasta que una entrada existente de caché en el host que expire o que sea eliminada.</p></div><div class=paragraph><p>El siguiente ejemplo establece el número máximo de dispositivos Ethernet a 10 para <code>CustomerA</code> en <code>vlan100</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig bridge0 ifmaxaddr vlan100 10</span></code></pre></div></div></dd></dl></div><div class=paragraph><p>Las interfaces del bridge también soportan modo monitor, donde los paquetes son descartados después de haber sido procesados por <a href="https://man.freebsd.org/cgi/man.cgi?query=bpf&amp;sektion=4&amp;format=html">bpf(4)</a> y no se procesan más ni se reenvían. Esto se puede usar para multiplexar la entrada de dos o más interfaces en un único flujo <a href="https://man.freebsd.org/cgi/man.cgi?query=bpf&amp;sektion=4&amp;format=html">bpf(4)</a>. Esto es útil para reconstruir el tráfico de redes que transmiten las señales RX/TX hacia fuera usando dos interfaces separadas. Por ejemplo, para leer la entrada desde cuatro interfaces de red como un único flujo:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig bridge0 addm fxp0 addm fxp1 addm fxp2 addm fxp3 monitor up</span>
<span class=c># tcpdump -i bridge0</span></code></pre></div></div></div><div class=sect3><h4 id=_monitorización_snmp>29.8.4. Monitorización SNMP<a class=anchor href=#_monitorización_snmp></a></h4><div class=paragraph><p>El interfaz bridge y los parámetros STP se pueden monitorizar con <a href="https://man.freebsd.org/cgi/man.cgi?query=bsnmpd&amp;sektion=1&amp;format=html">bsnmpd(1)</a> que se incluye con el sistema base FreeBSD. Las MIBs del bridge exportadas siguen el estándar IETF de forma que se puede usar cualquier cliente SNMP o paquete de monitorización para recuperar los datos.</p></div><div class=paragraph><p>Para habilitar la monitorización en el bridge, descomenta esta línea en <span class=filename>/etc/snmpd.config</span> eliminando el símbolo <code>#</code> al comienzo:</p></div><div class="literalblock programlisting"><div class=content><pre>begemotSnmpdModulePath.&#34;bridge&#34; = &#34;/usr/lib/snmp_bridge.so&#34;</pre></div></div><div class=paragraph><p>Podría ser necesario modificar en este fichero otros valores de configuración, como los nombres de la comunidad y listas de acceso. Consulta <a href="https://man.freebsd.org/cgi/man.cgi?query=bsnmpd&amp;sektion=1&amp;format=html">bsnmpd(1)</a> y <a href="https://man.freebsd.org/cgi/man.cgi?query=snmp_bridge&amp;sektion=3&amp;format=html">snmp_bridge(3)</a>. Una vez guardados los cambios, añade esta línea a <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>bsnmpd_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Después, arranca <a href="https://man.freebsd.org/cgi/man.cgi?query=bsnmpd&amp;sektion=1&amp;format=html">bsnmpd(1)</a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service bsnmpd start</span></code></pre></div></div><div class=paragraph><p>Los siguientes ejemplos usan el software Net-SNMP (<a class=package href=https://cgit.freebsd.org/ports/tree/net-mgmt/net-snmp/>net-mgmt/net-snmp</a>) para consultar un bridge desde un sistema cliente. También se puede usar el port <a class=package href=https://cgit.freebsd.org/ports/tree/net-mgmt/bsnmptools/>net-mgmt/bsnmptools</a>. Desde el cliente SNMP que está ejecutando Net-SNMP, añade las siguientes líneas a <span class=filename>$HOME/.snmp/snmp.conf</span> para importar las definiciones MIB del bridge:</p></div><div class="literalblock programlisting"><div class=content><pre>mibdirs +/usr/share/snmp/mibs
mibs +BRIDGE-MIB:RSTP-MIB:BEGEMOT-MIB:BEGEMOT-BRIDGE-MIB</pre></div></div><div class=paragraph><p>Para monitorizar un sólo bridge usando IETF BRIDGE-MIB (RFC4188):</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% snmpwalk <span class=nt>-v</span> 2c <span class=nt>-c</span> public bridge1.example.com mib-2.dot1dBridge
BRIDGE-MIB::dot1dBaseBridgeAddress.0 <span class=o>=</span> STRING: 66:fb:9b:6e:5c:44
BRIDGE-MIB::dot1dBaseNumPorts.0 <span class=o>=</span> INTEGER: 1 ports
BRIDGE-MIB::dot1dStpTimeSinceTopologyChange.0 <span class=o>=</span> Timeticks: <span class=o>(</span>189959<span class=o>)</span> 0:31:39.59 centi-seconds
BRIDGE-MIB::dot1dStpTopChanges.0 <span class=o>=</span> Counter32: 2
BRIDGE-MIB::dot1dStpDesignatedRoot.0 <span class=o>=</span> Hex-STRING: 80 00 00 01 02 4B D4 50
...
BRIDGE-MIB::dot1dStpPortState.3 <span class=o>=</span> INTEGER: forwarding<span class=o>(</span>5<span class=o>)</span>
BRIDGE-MIB::dot1dStpPortEnable.3 <span class=o>=</span> INTEGER: enabled<span class=o>(</span>1<span class=o>)</span>
BRIDGE-MIB::dot1dStpPortPathCost.3 <span class=o>=</span> INTEGER: 200000
BRIDGE-MIB::dot1dStpPortDesignatedRoot.3 <span class=o>=</span> Hex-STRING: 80 00 00 01 02 4B D4 50
BRIDGE-MIB::dot1dStpPortDesignatedCost.3 <span class=o>=</span> INTEGER: 0
BRIDGE-MIB::dot1dStpPortDesignatedBridge.3 <span class=o>=</span> Hex-STRING: 80 00 00 01 02 4B D4 50
BRIDGE-MIB::dot1dStpPortDesignatedPort.3 <span class=o>=</span> Hex-STRING: 03 80
BRIDGE-MIB::dot1dStpPortForwardTransitions.3 <span class=o>=</span> Counter32: 1
RSTP-MIB::dot1dStpVersion.0 <span class=o>=</span> INTEGER: rstp<span class=o>(</span>2<span class=o>)</span></code></pre></div></div><div class=paragraph><p>El valor <code>dot1dStpTopChanges.0</code> es dos, lo que indica que la topología STP ha cambiado dos veces. Un cambio de topología significa que uno o más enlaces en la red han cambiado o fallado y se ha tenido que calcular un nuevo árbol. El valor <code>dot1dStpTimeSinceTopologyChange.0</code> mostrará cuándo sucede esto.</p></div><div class=paragraph><p>Para monitorizar múltiples interfaces del bridge, se puede usar el BEGEMOT-BRIDGE-MIB privado:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% snmpwalk <span class=nt>-v</span> 2c <span class=nt>-c</span> public bridge1.example.com
enterprises.fokus.begemot.begemotBridge
BEGEMOT-BRIDGE-MIB::begemotBridgeBaseName.<span class=s2>&#34;bridge0&#34;</span> <span class=o>=</span> STRING: bridge0
BEGEMOT-BRIDGE-MIB::begemotBridgeBaseName.<span class=s2>&#34;bridge2&#34;</span> <span class=o>=</span> STRING: bridge2
BEGEMOT-BRIDGE-MIB::begemotBridgeBaseAddress.<span class=s2>&#34;bridge0&#34;</span> <span class=o>=</span> STRING: e:ce:3b:5a:9e:13
BEGEMOT-BRIDGE-MIB::begemotBridgeBaseAddress.<span class=s2>&#34;bridge2&#34;</span> <span class=o>=</span> STRING: 12:5e:4d:74:d:fc
BEGEMOT-BRIDGE-MIB::begemotBridgeBaseNumPorts.<span class=s2>&#34;bridge0&#34;</span> <span class=o>=</span> INTEGER: 1
BEGEMOT-BRIDGE-MIB::begemotBridgeBaseNumPorts.<span class=s2>&#34;bridge2&#34;</span> <span class=o>=</span> INTEGER: 1
...
BEGEMOT-BRIDGE-MIB::begemotBridgeStpTimeSinceTopologyChange.<span class=s2>&#34;bridge0&#34;</span> <span class=o>=</span> Timeticks: <span class=o>(</span>116927<span class=o>)</span> 0:19:29.27 centi-seconds
BEGEMOT-BRIDGE-MIB::begemotBridgeStpTimeSinceTopologyChange.<span class=s2>&#34;bridge2&#34;</span> <span class=o>=</span> Timeticks: <span class=o>(</span>82773<span class=o>)</span> 0:13:47.73 centi-seconds
BEGEMOT-BRIDGE-MIB::begemotBridgeStpTopChanges.<span class=s2>&#34;bridge0&#34;</span> <span class=o>=</span> Counter32: 1
BEGEMOT-BRIDGE-MIB::begemotBridgeStpTopChanges.<span class=s2>&#34;bridge2&#34;</span> <span class=o>=</span> Counter32: 1
BEGEMOT-BRIDGE-MIB::begemotBridgeStpDesignatedRoot.<span class=s2>&#34;bridge0&#34;</span> <span class=o>=</span> Hex-STRING: 80 00 00 40 95 30 5E 31
BEGEMOT-BRIDGE-MIB::begemotBridgeStpDesignatedRoot.<span class=s2>&#34;bridge2&#34;</span> <span class=o>=</span> Hex-STRING: 80 00 00 50 8B B8 C6 A9</code></pre></div></div><div class=paragraph><p>Para cambiar la interfaz del bridge que está siendo monitorizada mediante el subárbol <code>mib-2.dot1dBridge</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% snmpset <span class=nt>-v</span> 2c <span class=nt>-c</span> private bridge1.example.com
BEGEMOT-BRIDGE-MIB::begemotBridgeDefaultBridgeIf.0 s bridge2</code></pre></div></div></div></div><div class=sect2><h3 id=network-aggregation>29.9. Agregación de Enlaces y Conmutación<a class=anchor href=#network-aggregation></a></h3><div class=paragraph><p>FreeBSD proporciona la interfaz <a href="https://man.freebsd.org/cgi/man.cgi?query=lagg&amp;sektion=4&amp;format=html">lagg(4)</a> que se puede usar para agregar múltiples interfaces de red en una interfaz virtual para proporcionar tolerancia a fallos ("failover") y agregación de enlaces. El failover permite que el tráfico continúe fluyendo mientras haya al menos una interfaz de red que tenga establecido un enlace. La agregación de enlaces funciona mejor en switches que soportan LACP, ya que este protocolo distribuye el tráfico de forma bidireccional a la vez que responde al fallo de enlaces individuales.</p></div><div class=paragraph><p>Los protocolos de agregación soportados por el interfaz lagg determinan qué puertos se usan para tráfico saliente y si un puerto específico acepta o no tráfico de entrada. Los siguientes protocolos están soportados por <a href="https://man.freebsd.org/cgi/man.cgi?query=lagg&amp;sektion=4&amp;format=html">lagg(4)</a>:</p></div><div class=dlist><dl><dt class=hdlist1>failover</dt><dd><p>Este modo envía y recibe tráfico sólo a través del puerto maestro. Si el puerto maestro no está disponible, se usa el siguiente puerto activo. La primera interfaz añadida a la interfaz virtual es el puerto maestro y todas las interfaces añadidas posteriormente se usan como dispositivos redundantes. Si se produce un cambio a un puerto no maestro, el puerto original se convierte en maestro una vez que esté disponible de nuevo.</p></dd><dt class=hdlist1>loadbalance</dt><dd><p>Esto proporciona una configuración estática y no negocia agregación con los pares o intercambia marcos para monitorizar el enlace. Si el switch soporta LACP, se debería usar en su lugar.</p></dd><dt class=hdlist1>lacp</dt><dd><p>El protocolo IEEE® 802.3ad Link Aggregation Control Protocol (LACP) negocia un conjunto de enlaces agregables con el par en uno o más grupos "Link Aggregated Groups" (LAGs). Cada LAG se compone de puertos con la misma velocidad, conjunto de operaciones full-duplex, y el tráfico se balancea entre los puertos en el LAG con la velocidad total mayor. Típicamente, sólo hay un LAG que contiene todos los puertos. En el caso de cambios en la conectividad física, LACP convergerá rápido a una nueva configuración.</p><div class=paragraph><p>LACP balancea el tráfico de salida a lo largo de los puestos activos basándose en un hash de la cabecera de información del protocolo y acepta tráfico de entrada de cualquier puerto activo. El hash incluye la fuente Ehternet y la dirección de destino y, si está disponible, la etiqueta VLAN, y las direcciones de fuente y destino IPv4 o IPv6.</p></div></dd><dt class=hdlist1>roundrobin</dt><dd><p>Este modo distribuye el tráfico de salida utilizando un planificador round-robin entre todos los puertos activos y acepta tráfico de entrada desde cualquier puerto activo. Puesto que esto viola el orden de las tramas Ethernet, debería ser usado con precaución.</p></dd><dt class=hdlist1>broadcast</dt><dd><p>Este modo envía tráfico de salida a todos los puertos configurados en la interfaz lagg, y recibe tramas desde cualquier puerto.</p></dd></dl></div><div class=sect3><h4 id=_ejemplos_de_configuración>29.9.1. Ejemplos de Configuración<a class=anchor href=#_ejemplos_de_configuración></a></h4><div class=paragraph><p>Esta sección muestra cómo configurar un switch Cisco® y un sistema FreeBSD para hacer balanceado de carga LACP. Después muestra cómo configurar dos interfaces Ethernet en modo failover así como cómo configurar el modo failover entre una interfaz Ethernet y otra inalámbrica.</p></div><div id=networking-lacp-aggregation-cisco class=exampleblock><div class=title>Ejemplo 35. Agregación LACP con un Switch Cisco®</div><div class=content><div class=paragraph><p>Este ejemplo conecta dos interfaces Ethernet <a href="https://man.freebsd.org/cgi/man.cgi?query=fcp&amp;sektion=4&amp;format=html">fcp(4)</a> en una máquina FreeBSD con los dos primeros puertos Ethernet en un switch Cisco® como un enlace único de balanceo de carga y tolerante a fallos. Se pueden añadir más interfaces para incrementar la productividad y la tolerancia a fallos. Reemplaza los nombres de los puertos Cisco®, dispositivos Ethernet, número de grupo del canal, y dirección IP como se muestra en el ejemplo para adaptarlo a la configuración local.</p></div><div class=paragraph><p>El orden de las tramas es obligatorio en los enlaces Ethernet y cualquier tráfico entre dos estaciones siempre debe fluir por el mismo enlace físico, limitando la velocidad máxima a aquella de un interfaz. El algoritmo de transmisión intenta usar la mayor cantidad de información posible para distinguir entre distintos flujos de tráfico y balancear los flujos entre las interfaces disponibles.</p></div><div class=paragraph><p>En el switch Cisco®, añade las interfaces <em>FastEthernet0/1</em> y <em>FastEthernet0/2</em> al grupo del canal <em>1</em>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>interface FastEthernet0/1
 channel-group 1 mode active
 channel-protocol lacp
<span class=o>!</span>
interface FastEthernet0/2
 channel-group 1 mode active
 channel-protocol lacp</code></pre></div></div><div class=paragraph><p>En el sistema FreeBSD, crea el interfaz <a href="https://man.freebsd.org/cgi/man.cgi?query=lagg&amp;sektion=4&amp;format=html">lagg(4)</a> usando las interfaces físicas <em>fxp0</em> y <em>fxp1</em> y levanta las interfaces con la dirección IP <em>10.0.0.3/24</em>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig fxp0 up</span>
<span class=c># ifconfig fxp1 up</span>
<span class=c># ifconfig lagg0 create</span>
<span class=c># ifconfig lagg0 up laggproto lacp laggport fxp0 laggport fxp1 10.0.0.3/24</span></code></pre></div></div><div class=paragraph><p>Después, verifica el estado de la interfaz virtual:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig lagg0</span>
lagg0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        <span class=nv>options</span><span class=o>=</span>8&lt;VLAN_MTU&gt;
        ether 00:05:5d:71:8d:b8
        inet 10.0.0.3 netmask 0xffffff00 broadcast 10.0.0.255
        media: Ethernet autoselect
        status: active
        laggproto lacp
        laggport: fxp1 <span class=nv>flags</span><span class=o>=</span>1c&lt;ACTIVE,COLLECTING,DISTRIBUTING&gt;
        laggport: fxp0 <span class=nv>flags</span><span class=o>=</span>1c&lt;ACTIVE,COLLECTING,DISTRIBUTING&gt;</code></pre></div></div><div class=paragraph><p>Los puertos marcados como <code>ACTIVE</code> forman parte del LAG que se ha negociado con el switch remoto. El tráfico será transmitido y recibido a través de estos puertos activos. Añade <code>-v</code> al comando de arriba para ver los identificadores LAG.</p></div><div class=paragraph><p>Para ver el estado del puerto en el switch Cisco®:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>switch# show lacp neighbor
Flags:  S - Device is requesting Slow LACPDUs
        F - Device is requesting Fast LACPDUs
        A - Device is <span class=k>in </span>Active mode       P - Device is <span class=k>in </span>Passive mode

Channel group 1 neighbors

Partner<span class=s1>&#39;s information:

                  LACP port                        Oper    Port     Port
Port      Flags   Priority  Dev ID         Age     Key     Number   State
Fa0/1     SA      32768     0005.5d71.8db8  29s    0x146   0x3      0x3D
Fa0/2     SA      32768     0005.5d71.8db8  29s    0x146   0x4      0x3D</span></code></pre></div></div><div class=paragraph><p>Para más detalles, teclea <code>show lacp neighbor detail</code>.</p></div><div class=paragraph><p>Para mantener esta configuración entre reinicios, añade las siguientes entradas en el fichero [.filename]#/etc/rc.conf#del sistema FreeBSD:</p></div><div class="literalblock programlisting"><div class=content><pre>ifconfig_fxp0=&#34;up&#34;
ifconfig_fxp1=&#34;up&#34;
cloned_interfaces=&#34;lagg0&#34;
ifconfig_lagg0=&#34;laggproto lacp laggport fxp0 laggport fxp1 10.0.0.3/24&#34;</pre></div></div></div></div><div id=networking-lagg-failover class=exampleblock><div class=title>Ejemplo 36. Modo Failover</div><div class=content><div class=paragraph><p>El modo failover se puede usar para cambiar a un interfaz secundario si se pierde el enlace en el interfaz maestro. Para configurar failover, asegúrate de que las interfaces físicas están levantadas, después crea el interfaz <a href="https://man.freebsd.org/cgi/man.cgi?query=lagg&amp;sektion=4&amp;format=html">lagg(4)</a>. En este ejemplo, <em>fxp0</em> es la interfaz maestra, <em>fxp1</em> es la interfaz secundaria, y el interfaz virtual tiene asignada la dirección IP <em>10.0.0.15/24</em>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig fxp0 up</span>
<span class=c># ifconfig fxp1 up</span>
<span class=c># ifconfig lagg0 create</span>
<span class=c># ifconfig lagg0 up laggproto failover laggport fxp0 laggport fxp1 10.0.0.15/24</span></code></pre></div></div><div class=paragraph><p>La interfaz virtual debería tener un aspecto parecido a este:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig lagg0</span>
lagg0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        <span class=nv>options</span><span class=o>=</span>8&lt;VLAN_MTU&gt;
        ether 00:05:5d:71:8d:b8
        inet 10.0.0.15 netmask 0xffffff00 broadcast 10.0.0.255
        media: Ethernet autoselect
        status: active
        laggproto failover
        laggport: fxp1 <span class=nv>flags</span><span class=o>=</span>0&lt;<span class=o>&gt;</span>
        laggport: fxp0 <span class=nv>flags</span><span class=o>=</span>5&lt;MASTER,ACTIVE&gt;</code></pre></div></div><div class=paragraph><p>El tráfico será transmitido y recibido en <em>fxp0</em>. Si se pierde el enlace en <em>fxp0</em>, <em>fxp1</em> se convertirá en el enlace activo. Si se restaura el enlace en la interfaz maestra, se convertirá de nuevo en el enlace activo.</p></div><div class=paragraph><p>Para mantener esta configuración entre reinicios, añade las siguientes entradas en <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>ifconfig_fxp0=&#34;up&#34;
ifconfig_fxp1=&#34;up&#34;
cloned_interfaces=&#34;lagg0&#34;
ifconfig_lagg0=&#34;laggproto failover laggport fxp0 laggport fxp1 10.0.0.15/24&#34;</pre></div></div></div></div><div id=networking-lagg-wired-and-wireless class=exampleblock><div class=title>Ejemplo 37. Modo Failover Entre Interfaces Ethernet y Wireless</div><div class=content><div class=paragraph><p>Para los usuarios de portátiles, normalmente es deseable configurar el dispositivo inalámbrico como un secundario que sólo usa cuando la conexión Ethernet no está disponible. Con <a href="https://man.freebsd.org/cgi/man.cgi?query=lagg&amp;sektion=4&amp;format=html">lagg(4)</a>, es posible configurar un failover que prefiera la conexión Ethernet tanto por rendimiento como por razones de seguridad, mientras que se mantiene la posibilidad de transferir datos por la conexión inalámbrica.</p></div><div class=paragraph><p>Esto se consigue sobrescribiendo la dirección MAC del interfaz Ethernet con el de la interfaz inalámbrica.</p></div><div class=sidebarblock><div class=content><div class=paragraph><p>En teoría, cualquiera de las dos direcciones MAC (Ethernet o inalámbrica) se puede cambiar para igualarse a la otra. Sin embargo, algunas interfaces inalámbricas populares carecen del soporte para sobrescribir la dirección MAX. Por lo tanto para este propósito recomendamos sobrescribir la dirección MAC Ethernet.</p></div></div></div><div class=sidebarblock><div class=content><div class=paragraph><p>Si el controlador para el interfaz inalámbrico no está cargado en el kernel <code>GENERIC</code> o en el personalizado, y el ordenador está ejecutando FreeBSD12.1, carga el <span class=filename>.ko</span> correspondiente en <span class=filename>/boot/loader.conf</span> añadiendo <code><strong>driver_load="YES"</strong></code> a ese fichero y después reiniciando. Otra forma mejor es cargar el driver en <span class=filename>/etc/rc.conf</span> añadiéndolo a <code>kld_list</code> (consulta <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a> para los detalles) en ese fichero y reiniciando. Esto es necesario porque de otra forma el controlador no está todavía cargado en el momento en el que se configura el interfaz <a href="https://man.freebsd.org/cgi/man.cgi?query=lagg&amp;sektion=4&amp;format=html">lagg(4)</a>.</p></div></div></div><div class=paragraph><p>En este ejemplo, el interfaz Ethernet, <em>re0</em>, es el maestro y el interfaz inalámbrico, <em>wlan0</em>, es el recambio. El interfaz <em>wlan0</em> ha sido creado a partir del interfaz inalámbrico físico <em>ath0</em>, y el interfaz Ethernet se configurará con la dirección MAC del interfaz inalámbrico. Primero, levanta el interfaz inalámbrico (reemplaza <em>FR</em> con tu código de país de dos letras), pero no establezcas una dirección IP. Reemplaza <em>wlan0</em> con el nombre del interfaz inalámbrico del sistema:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0 create wlandev ath0 country FR ssid my_router up</span></code></pre></div></div><div class=paragraph><p>Ahora puedes saber la dirección MAC del interfaz inalámbrico:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig wlan0</span>
wlan0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
	ether b8:ee:65:5b:32:59
	<span class=nb>groups</span>: wlan
	ssid Bbox-A3BD2403 channel 6 <span class=o>(</span>2437 MHz 11g ht/20<span class=o>)</span> bssid 00:37:b7:56:4b:60
	regdomain ETSI country FR indoor ecm authmode WPA2/802.11i privacy ON
	deftxkey UNDEF AES-CCM 2:128-bit txpower 30 bmiss 7 scanvalid 60
	protmode CTS ampdulimit 64k ampdudensity 8 shortgi <span class=nt>-stbctx</span> stbcrx
	<span class=nt>-ldpc</span> wme burst roaming MANUAL
	media: IEEE 802.11 Wireless Ethernet MCS mode 11ng
	status: associated
	nd6 <span class=nv>options</span><span class=o>=</span>29&lt;PERFORMNUD,IFDISABLED,AUTO_LINKLOCAL&gt;</code></pre></div></div><div class=paragraph><p>La línea <code>ether</code> contendrá la dirección MAC del interfaz especificado. Ahora, cambia la dirección MAC del interfaz Ethernet para que concuerde:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig re0 ether b8:ee:65:5b:32:59</span></code></pre></div></div><div class=paragraph><p>Asegúrate de que el interfaz <em>re0</em> está levantado, luego crea el interfaz <a href="https://man.freebsd.org/cgi/man.cgi?query=lagg&amp;sektion=4&amp;format=html">lagg(4)</a> con <em>re0</em> como maestro con <em>wlan0</em> como recambio:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig re0 up</span>
<span class=c># ifconfig lagg0 create</span>
<span class=c># ifconfig lagg0 up laggproto failover laggport re0 laggport wlan0</span></code></pre></div></div><div class=paragraph><p>La interfaz virtual debería tener un aspecto parecido a este:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig lagg0</span>
lagg0: <span class=nv>flags</span><span class=o>=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        <span class=nv>options</span><span class=o>=</span>8&lt;VLAN_MTU&gt;
        ether b8:ee:65:5b:32:59
        laggproto failover lagghash l2,l3,l4
        laggport: re0 <span class=nv>flags</span><span class=o>=</span>5&lt;MASTER,ACTIVE&gt;
        laggport: wlan0 <span class=nv>flags</span><span class=o>=</span>0&lt;<span class=o>&gt;</span>
        <span class=nb>groups</span>: lagg
        media: Ethernet autoselect
        status: active</code></pre></div></div><div class=paragraph><p>Después, arranca el cliente DHCP para obtener una dirección IP:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># dhclient lagg0</span></code></pre></div></div><div class=paragraph><p>Para mantener esta configuración entre reinicios, añade las siguientes entradas en <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>ifconfig_re0=&#34;ether b8:ee:65:5b:32:59&#34;
wlans_ath0=&#34;wlan0&#34;
ifconfig_wlan0=&#34;WPA&#34;
create_args_wlan0=&#34;country FR&#34;
cloned_interfaces=&#34;lagg0&#34;
ifconfig_lagg0=&#34;up laggproto failover laggport re0 laggport wlan0 DHCP&#34;</pre></div></div></div></div></div></div><div class=sect2><h3 id=network-diskless>29.10. Operación sin Disco con PXE<a class=anchor href=#network-diskless></a></h3><div class=paragraph><p>El Preboot eXecution Environment (PXE) de Intel® permite a un sistema operativo arrancar por red. Por ejemplo, un sistema FreeBSD puede arrancar sobre la red y operar sin un disco local, usando sistemas de ficheros montados desde un servidor NFS. El soporte de PXE normalmente está disponible en la BIOS. Para usar PXE cuando arranca la máquina, selecciona la opción <code>Arrancar desde la red</code> en la configuración de la BIOS o teclea una tecla de función durante la inicialización del sistema.</p></div><div class=paragraph><p>Para proporcionar a un sistema operativo los ficheros necesarios para que arranque sobre la red, la configuración de PXE también necesita configurar apropiadamente DHCP, TFTP y los servidores NFS, donde:</p></div><div class=ulist><ul><li><p>Parámetros iniciales, como una dirección IP, el nombre del fichero ejecutable de arranque y su localización, el nombre del servidor, y la ruta raíz se obtienen del servidor DHCP.</p></li><li><p>El fichero del cargador del sistema operativo se obtiene mediante TFTP.</p></li><li><p>Los sistemas de ficheros se cargan usando NFS.</p></li></ul></div><div class=paragraph><p>Cuando un ordenador arranca mediante PXE, recibe información a través de DHCP sobre dónde obtener el fichero inicial del cargador de arranque. Después de que el ordenador recibe esta información, descarga el cargador de arranque vía TFTP y después ejecuta el cargador de arranque. En FreeBSD, el fichero del cargador de arranque es <span class=filename>/boot/pxeboot</span>. Después de que <span class=filename>/boot/pxeboot</span> se ejecute, se carga el kernel de FreeBSD y el resto de la secuencia de arranque de FreeBSD prosigue su curso como se describe en <a href=./#boot>El Proceso de Arranque de FreeBSD</a>.</p></div><div class=paragraph><p>Esta sección describe cómo configurar estos servicios en un sistema FreeBSD de forma que otros sistemas puedan arrancar mediante PXE en FreeBSD. Consulta <a href="https://man.freebsd.org/cgi/man.cgi?query=diskless&amp;sektion=8&amp;format=html">diskless(8)</a> para más información.</p></div><div class="admonitionblock caution"><table><tbody><tr><td class=icon><i class="fa icon-caution" title=Caution></i></td><td class=content><div class=paragraph><p>Como se ha descrito, el sistema que proporciona estos servicios no es seguro. Debería vivir en un área protegida de la red y otros hosts no deberían confiar en él.</p></div></td></tr></tbody></table></div><div class=sect3><h4 id=network-pxe-nfs>29.10.1. Configurando el Entorno PXE<a class=anchor href=#network-pxe-nfs></a></h4><div class=paragraph><p>Las pasos que se muestran en esta sección configuran los servidores NFS y TFTP incluidos. La siguiente sección muestra cómo instalar y configurar el servidor DHCP. En este ejemplo, el dirección que contendrá los ficheros usados por los usuarios PXE es <span class=filename>/b/tftpboot/FreeBSD/install</span>. Es importante que este directorio exista y que el nombre del directorio esté configurado tanto en <span class=filename>/etc/inetd.conf</span> como en <span class=filename>/usr/local/etc/dhcpd.conf</span>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Los ejemplos de comandos que siguen asumen el uso del shell <a href="https://man.freebsd.org/cgi/man.cgi?query=sh&amp;sektion=1&amp;format=html">sh(1)</a>. Los usuarios de <a href="https://man.freebsd.org/cgi/man.cgi?query=chs&amp;sektion=1&amp;format=html">chs(1)</a> y <a href="https://man.freebsd.org/cgi/man.cgi?query=tcsh&amp;sektion=1&amp;format=html">tcsh(1)</a> tendrán que iniciar un shell <a href="https://man.freebsd.org/cgi/man.cgi?query=sh&amp;sektion=1&amp;format=html">sh(1)</a> o adaptar los comandos a la sintaxis de <a href="https://man.freebsd.org/cgi/man.cgi?query=csh&amp;sektion=1&amp;format=html">csh(1)</a>.</p></div></td></tr></tbody></table></div><div class="olist arabic procedure"><ol class=arabic><li><p>Crea el directorio raíz que contendrá la instalación de FreeBSD que será montada por NFS:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># export NFSROOTDIR=/b/tftpboot/FreeBSD/install</span>
<span class=c># mkdir -p ${NFSROOTDIR}</span></code></pre></div></div></li><li><p>Activa el servidor NFS añadiendo esta línea a <span class=filename>/etc/rc.conf</span>:</p><div class="literalblock programlisting"><div class=content><pre>nfs_server_enable=&#34;YES&#34;</pre></div></div></li><li><p>Exporta el directorio raíz del sistema sin disco vía NFS añadiendo lo siguiente a <span class=filename>/etc/exports</span>:</p><div class="literalblock programlisting"><div class=content><pre>/b -ro -alldirs -maproot=root</pre></div></div></li><li><p>Arranca el servidor NFS:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service nfsd start</span></code></pre></div></div></li><li><p>Activa <a href="https://man.freebsd.org/cgi/man.cgi?query=inetd&amp;sektion=8&amp;format=html">inetd(8)</a> añadiendo la siguiente línea a <span class=filename>/etc/rc.conf</span>:</p><div class="literalblock programlisting"><div class=content><pre>inetd_enable=&#34;YES&#34;</pre></div></div></li><li><p>Descomenta la siguiente línea en <span class=filename>/etc/inetd.conf</span> asegurándote de que no comienza con un símbolo <code>#</code>:</p><div class="literalblock programlisting"><div class=content><pre>tftp dgram udp wait root /usr/libexec/tftpd tftpd -l -s /b/tftpboot</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Algunas versiones de PXE necesitan la versión TCP de TFTP. En este caso, descomenta la segunda línea <code>tftp</code> que contiene <code>stream tcp</code>.</p></div></td></tr></tbody></table></div></li><li><p>Arranca <a href="https://man.freebsd.org/cgi/man.cgi?query=inetd&amp;sektion=8&amp;format=html">inetd(8)</a>:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service inetd start</span></code></pre></div></div></li><li><p>Instala el sistema base en <span class=filename>${NFSROOTDIR}</span>, bien descomprimiendo los archivos oficiales o recompilando el kernel de FreeBSD y el espacio de usuario (consulta <a href=./#makeworld>“Actualizando FreeBSD desde las Fuentes”</a> para instrucciones más detalladas, pero no olvides añadir <code>DESTDIR=<em>${NFSROOTDIR}</em></code> cuando ejecutes los comands <code>make installkernel</code> y <code>make installworld</code>.</p></li><li><p>Comprueba que el servidor TFTP funciona y que puede descargar el cargador de arranque que se obtendrá vía PXE:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># tftp localhost</span>
tftp&gt; get FreeBSD/install/boot/pxeboot
Received 264951 bytes <span class=k>in </span>0.1 seconds</code></pre></div></div></li><li><p>Edita <span class=filename>${NFSROOTDIR}/etc/fstab</span> y crea una entrada para montar el sistema de ficheros raíz sobre NFS:</p><div class="literalblock programlisting"><div class=content><pre># Device                                         Mountpoint    FSType   Options  Dump Pass
myhost.example.com:/b/tftpboot/FreeBSD/install       /         nfs      ro        0    0</pre></div></div><div class=paragraph><p>Reemplaza <em>myhost.example.com</em> con el nombre de la máquina o la dirección IP del servidor NFS. En este ejemplo, el sistema de ficheros raíz está montado como solo lectura para evitar que los clientes NFS puedan borrar los contenidos del sistema de ficheros raíz.</p></div></li><li><p>Establece la contraseña de root en el entorno PXE para las máquinas cliente que están arrancando mediante PXE:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># chroot ${NFSROOTDIR}</span>
<span class=c># passwd</span></code></pre></div></div></li><li><p>Si es necesario, habilita el inicio de sesión de root en <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh&amp;sektion=1&amp;format=html">ssh(1)</a> para las máquinas cliente que arrancan con PXE editando <span class=filename>${NFSROOTDIR}/etc/ssh/sshd_config</span> y habilitando <code>PermitRootLogin</code>. Esta opción está documentada en <a href="https://man.freebsd.org/cgi/man.cgi?query=sshd_config&amp;sektion=5&amp;format=html">sshd_config(5)</a>.</p></li><li><p>Realiza cualquier otra personalización del entorno PXE en <span class=filename>${NFSROOTDIR}</span>. Estas personalizaciones podrían incluir cosas como instalación de paquetes o editar el fichero de contraseñas con <a href="https://man.freebsd.org/cgi/man.cgi?query=vipw&amp;sektion=8&amp;format=html">vipw(8)</a>.</p></li></ol></div><div class=paragraph><p>Cuando se arranca desde un volumen raíz NFS, <span class=filename>/etc/rc</span> detecta el arranque NFS y ejecuta <span class=filename>/etc/rc.initdiskless</span>. En este caso se necesita que <span class=filename>/etc</span> y <span class=filename>/var</span> estén cargados den memoria de forma que estos directorios sean escribibles pero el directorio raíz NFS sea de sólo escritura:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># chroot ${NFSROOTDIR}</span>
<span class=c># mkdir -p conf/base</span>
<span class=c># tar -c -v -f conf/base/etc.cpio.gz --format cpio --gzip etc</span>
<span class=c># tar -c -v -f conf/base/var.cpio.gz --format cpio --gzip var</span></code></pre></div></div><div class=paragraph><p>Cuando el sistema arranca, los sistemas de fichero en memoria para <span class=filename>/etc</span> y <span class=filename>/var</span> se crearán y montarán y el contenido de los ficheros <span class=filename>cpio.gz</span> se copiará dentro de ellos. Por defecto, estos sistemas de ficheros tienen una capacidad máxima de 5 megabytes. Si tus archivos no caben, que es habitualmente el caso para <span class=filename>/var</span> cuando se han instalado paquetes binarios, solicita más tamaño poniendo el número de sectores de 512 bytes necesarios (por ejemplo, 5 megabytes es 10240 sectores) en <span class=filename>${NFSROOTDIR}/conf/base/etc/md_size</span> y <span class=filename>${NFSROOTDIR}/conf/base/var/md_size</span> para los sistemas de ficheros <span class=filename>/etc</span> y <span class=filename>/var</span> respectivamente.</p></div></div><div class=sect3><h4 id=network-pxe-setting-up-dhcp>29.10.2. Configurando el Servidor DHCP<a class=anchor href=#network-pxe-setting-up-dhcp></a></h4><div class=paragraph><p>El servidor DHCP no necesita estar en la misma máquina que los servidores de TFTP y NFS, pero necesita estar accesible en la red.</p></div><div class=paragraph><p>DHCP no es parte del sistema base de FreeBSD pero se puede instalar usando el port o paquete <a class=package href=https://cgit.freebsd.org/ports/tree/net/isc-dhcp44-server/>net/isc-dhcp44-server</a>.</p></div><div class=paragraph><p>Una vez instalado, edita el fichero de configuración, <span class=filename>/usr/local/etc/dhcpd.conf</span>. Configura las opciones <code>next-server</code>, <code>filename</code>, y <code>root-path</code> como se ve en este ejemplo:</p></div><div class="literalblock programlisting"><div class=content><pre>subnet 192.168.0.0 netmask 255.255.255.0 {
   range 192.168.0.2 192.168.0.3 ;
   option subnet-mask 255.255.255.0 ;
   option routers 192.168.0.1 ;
   option broadcast-address 192.168.0.255 ;
   option domain-name-servers 192.168.35.35, 192.168.35.36 ;
   option domain-name &#34;example.com&#34;;

   # IP address of TFTP server
   next-server 192.168.0.1 ;

   # path of boot loader obtained via tftp
   filename &#34;FreeBSD/install/boot/pxeboot&#34; ;

   # pxeboot boot loader will try to NFS mount this directory for root FS
   option root-path &#34;192.168.0.1:/b/tftpboot/FreeBSD/install/&#34; ;

}</pre></div></div><div class=paragraph><p>La directiva <code>next-server</code> se usa para especificar la dirección IP del servidor TFTP.</p></div><div class=paragraph><p>La directiva <code>filename</code> define la ruta a <span class=filename>/boot/pxeboot</span>. Se usa un nombre de fichero relativo, lo que significa que <span class=filename>/b/tftpboot</span> no está incluido en la ruta.</p></div><div class=paragraph><p>La opción <code>root-path</code> define la ruta al sistema de ficheros raíz NFS.</p></div><div class=paragraph><p>Una vez salvados los cambios, activa DHCP durante el arranque añadiendo la siguiente línea a <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>dhcpd_enable=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Después inicia el servicio DHCP:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># service isc-dhcpd start</span></code></pre></div></div></div><div class=sect3><h4 id=_depurando_problemas_en_pxe>29.10.3. Depurando problemas en PXE<a class=anchor href=#_depurando_problemas_en_pxe></a></h4><div class=paragraph><p>Una vez que todos los servicios están configurados y arrancados, los clientes PXE deberían ser capaces de cargar automáticamente FreeBSD a través de la red. Si un cliente particular no es capaz de conectar, cuando ese cliente arranque, entra en el menú de configuración de la BIO y confirma que está configurado para arrancar desde la red.</p></div><div class=paragraph><p>Esta sección describe algunos consejos para resolución de problemas para aislar la fuente del problema de configuración si los clientes no fueran capaces de arrancar mediante PXE.</p></div><div class="sidebarblock procedure"><div class=content><div class="olist arabic"><ol class=arabic><li><p>Usa el paquete o port <a class=package href=https://cgit.freebsd.org/ports/tree/net/wireshark/>net/wireshark</a> para depurar el tráfico de red involucrado en el proceso de arranque de PXE, el cual se ilustra en el diagrama inferior.</p><div class=imageblock><div class=content><img src=../../../../images/books/handbook/advanced-networking/pxe-nfs.png alt="pxe nfs"></div><div class=title>Figura 63. Proceso de Arranque de PXE con Punto de Montaje Raíz NFS</div></div><div class="olist arabic"><ol class=arabic><li><p>El cliente emite un mensaje DHCPDISCOVER.</p></li><li><p>El servidor DHCP responde con los valores para la dirección IP, next-server, filename y root-path.</p></li><li><p>El cliente envía una solicitud TFTP a next-server, pidiendo recuperar un nombre de archivo.</p></li><li><p>El servidor TFTP responde y envía el fichero al cliente.</p></li><li><p>El cliente ejecuta el fichero, que es pxeboot(8), que luego carga el kernel. Cuando el kernel se ejecuta, el sistema de ficheros raíz especificado por root-path es montado a través de NFS.</p></li></ol></div></li><li><p>En el servidor TFTP, lee <span class=filename>/var/log/xferlog</span> para asegurar que se está recuperando <span class=filename>pxeboot</span> desde el lugar correcto. Prueba con este ejemplo de configuración:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># tftp 192.168.0.1</span>
tftp&gt; get FreeBSD/install/boot/pxeboot
Received 264951 bytes <span class=k>in </span>0.1 seconds</code></pre></div></div><div class=paragraph><p>La sección <code>BUGS</code> en <a href="https://man.freebsd.org/cgi/man.cgi?query=tftpd&amp;sektion=8&amp;format=html">tftpd(8)</a> y <a href="https://man.freebsd.org/cgi/man.cgi?query=tftp&amp;sektion=1&amp;format=html">tftp(1)</a> documentan algunas limitaciones con TFTP.</p></div></li><li><p>Asegúrate de que el sistema de ficheros raíz se puede montar vía NFS. Puedes probar con esta configuración de ejemplo:</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># mount -t nfs 192.168.0.1:/b/tftpboot/FreeBSD/install /mnt</span></code></pre></div></div></li></ol></div></div></div></div></div><div class=sect2><h3 id=carp>29.11. Common Address Redundancy Protocol (CARP)<a class=anchor href=#carp></a></h3><div class=paragraph><p>El protocolo CARP (Common Address Redundancy Protocol) permite a múltiples hosts compartir la misma dirección IP y VHID (Virtual Host ID) para proporcionar <em>alta disponibilidad</em> para uno o más servicios. Este significa que uno o más hosts pueden fallar, y los otros hosts se harán cargo de forma transparente de forma que los usuarios no verán un fallo de servicio.</p></div><div class=paragraph><p>Además de la dirección IP compartida, cada host tiene su propia dirección IP para gestión y configuración. Todas las máquinas que comparten una dirección IP tienen el mismo VHID. El VHID para cada dirección IP virtual debe ser única en el dominio broadcast del interfaz de red.</p></div><div class=paragraph><p>La alta disponibilidad con CARP está incluida en FreeBSD, aunque los pasos para configurarla varían ligeramente dependiendo de la versión de FreeBSD. Esta sección proporciona la misma configuración de ejemplo para versiones anteriores, iguales o posteriores a FreeBSD 10.</p></div><div class=paragraph><p>Este ejemplo configura soporte para failover con tres hosts, todos con una única dirección IP, pero proporcionando el mismo contenido web. Tiene dos maestros diferentes llamados <code>hosta.example.org</code> y <code>hostb.example.org</code>, con un respaldo compartido llamado <code>hostc.example.org</code>.</p></div><div class=paragraph><p>Estas máquinas están balanceadas con un DNS con figurado en Round Robin . Las máquinas maestro y el respaldo están configuradas de forma idéntica excepto por los nombres de host y las direcciones IP de gestión. Estos servidores deben tener la misma configuración y ejecutar los mismos servicios. Cuando se produce un failover, las peticiones al servicio en la dirección IP compartida sólo pueden ser contestadas correctamente si el servidor de respaldo tiene acceso al mismo contenido. La máquina de respaldo tiene dos interfaces CARP adicionales, una para cada dirección IP de los servidores maestros. Cuando ocurre un fallo, el servidor de respaldo pillará la dirección IP de la máquina del maestro que haya fallado.</p></div><div class=sect3><h4 id=carp-10x>29.11.1. Usando CARP en FreeBSD 10 y Posterior<a class=anchor href=#carp-10x></a></h4><div class=paragraph><p>Activa el soporte de CARP en el arranque añadiendo una entrada para el módulo del kernel <span class=filename>carp.ko</span> en <span class=filename>/boot/loader.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>carp_load=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Para cargar el módulo ahora sin reiniciar:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload carp</span></code></pre></div></div><div class=paragraph><p>Para los usuarios que prefieren usar un kernel personalizado, incluye la siguiente línea en el fichero de configuración del kernel personalizado y compila como se describe en <a href=./#kernelconfig>Configurando el Kernel de FreeBSD</a>:</p></div><div class="literalblock programlisting"><div class=content><pre>device	carp</pre></div></div><div class=paragraph><p>El nombre de host, dirección IP de gestión y su máscara de subred, la dirección IP compartida, y el VHID se configuran añadiendo entradas en <span class=filename>/etc/rc.conf</span>. Este ejemplo es para <code>hosta.example.org</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>hostname=&#34;hosta.example.org&#34;
ifconfig_em0=&#34;inet 192.168.1.3 netmask 255.255.255.0&#34;
ifconfig_em0_alias0=&#34;inet vhid 1 pass testpass alias 192.168.1.50/32&#34;</pre></div></div><div class=paragraph><p>El siguiente conjunto de entradas es para <code>hostb.example.org</code>. Puesto que representa un segundo maestro, utiliza una dirección IP compartida y VHID diferentes. Sin embargo, la contraseña especificada con <code>pass</code> debe ser idéntica ya que CARP sólo escuchará y aceptará notificaciones de las máquinas que tengan la contraseña correcta.</p></div><div class="literalblock programlisting"><div class=content><pre>hostname=&#34;hostb.example.org&#34;
ifconfig_em0=&#34;inet 192.168.1.4 netmask 255.255.255.0&#34;
ifconfig_em0_alias0=&#34;inet vhid 2 pass testpass alias 192.168.1.51/32&#34;</pre></div></div><div class=paragraph><p>La tercer máquina, <code>hostc.example.org</code>, está configurada para manejar el failover de cualquiera de los maestros. Esta máquina está configurada con dos CARPVHIDS, uno para manejar cada dirección IP virtual de cada host maestro. El desvío de notificaciones CARP, <code>advskew</code>, está configurado para asegurar que el host de respaldo notifica más tarde que el maestro, puesto que <code>advskew</code> controla el orden de precedencia cuando hay varios servidores de reemplazo.</p></div><div class="literalblock programlisting"><div class=content><pre>hostname=&#34;hostc.example.org&#34;
ifconfig_em0=&#34;inet 192.168.1.5 netmask 255.255.255.0&#34;
ifconfig_em0_alias0=&#34;inet vhid 1 advskew 100 pass testpass alias 192.168.1.50/32&#34;
ifconfig_em0_alias1=&#34;inet vhid 2 advskew 100 pass testpass alias 192.168.1.51/32&#34;</pre></div></div><div class=paragraph><p>Tener dos CARPVHIDs configurados significa que <code>hostc.example.org</code> se dará cuenta si alguno de los maestros no se encuentra disponible. Si un maestro no es capaz de notificar antes que el servidor de reemplazo, el servidor de reemplazo usará la dirección IP compartida hasta que el maestro esté disponible de nuevo.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>Si el maestro original vuelve a estar disponible, <code>hostc.example.org</code> no liberará la dirección IP virtual automáticamente. Para que esto suceda, se tiene que habilitar la preemptividad. Esto está deshabilitado por defecto, está controlado mediante la variable <code>net.inet.carp.preempt</code> de <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a>. El administrador puede forzar a que el servidor de reemplazo devuelva la dirección IP al maestro:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig em0 vhid 1 state backup</span></code></pre></div></div></td></tr></tbody></table></div><div class=paragraph><p>Una vez completada la configuración, reinicia la red o reinicia cada sistema. Ahora la alta disponibilidad está habilitada.</p></div><div class=paragraph><p>La funcionalidad CARP se puede controlar mediante varias variables de <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> que están documentadas en las páginas de manual <a href="https://man.freebsd.org/cgi/man.cgi?query=carp&amp;sektion=4&amp;format=html">carp(4)</a>. Se pueden disparar otras acciones a partir de eventos CARP usando <a href="https://man.freebsd.org/cgi/man.cgi?query=devd&amp;sektion=8&amp;format=html">devd(8)</a>.</p></div></div><div class=sect3><h4 id=carp-9x>29.11.2. Usando CARP en FreeBSD 9 y Anteriores<a class=anchor href=#carp-9x></a></h4><div class=paragraph><p>La configuración para estas versiones de FreeBSD es similar a la descrita en la sección previa, excepto que se tiene que crear primero un dispositivo CARP y hacer referencia a él en la configuración.</p></div><div class=paragraph><p>Activa el soporte de CARP al arrancar cargando el módulo del kernel <span class=filename>if_carp.ko</span> en <span class=filename>/boot/loader.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>if_carp_load=&#34;YES&#34;</pre></div></div><div class=paragraph><p>Para cargar el módulo ahora sin reiniciar:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># kldload carp</span></code></pre></div></div><div class=paragraph><p>Para los usuarios que prefieren usar un kernel personalizado, incluye la siguiente línea en el fichero de configuración del kernel personalizado y compila como se describe en <a href=./#kernelconfig>Configurando el Kernel de FreeBSD</a>:</p></div><div class="literalblock programlisting"><div class=content><pre>device	carp</pre></div></div><div class=paragraph><p>Después, en cada host, crea un dispositivo CARP:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig carp0 create</span></code></pre></div></div><div class=paragraph><p>Establece el nombre de host, dirección IP de gestión, dirección IP compartida, y VHID añadiendo las líneas necesarias a <span class=filename>/etc/rc.conf</span>. Puesto que se usa un dispositivo CARP virtual en lugar de un alias, se usa la máscara de subred <code>/24</code> en lugar de <code>/32</code>. Aquí están las entradas para <code>hosta.example.org</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>hostname=&#34;hosta.example.org&#34;
ifconfig_fxp0=&#34;inet 192.168.1.3 netmask 255.255.255.0&#34;
cloned_interfaces=&#34;carp0&#34;
ifconfig_carp0=&#34;vhid 1 pass testpass 192.168.1.50/24&#34;</pre></div></div><div class=paragraph><p>En <code>hostb.example.org</code>:</p></div><div class="literalblock programlisting"><div class=content><pre>hostname=&#34;hostb.example.org&#34;
ifconfig_fxp0=&#34;inet 192.168.1.4 netmask 255.255.255.0&#34;
cloned_interfaces=&#34;carp0&#34;
ifconfig_carp0=&#34;vhid 2 pass testpass 192.168.1.51/24&#34;</pre></div></div><div class=paragraph><p>La tercera máquina, <code>hostc.example.org</code>, se configura para manejar el failover de cualquiera de los hosts maestros:</p></div><div class="literalblock programlisting"><div class=content><pre>hostname=&#34;hostc.example.org&#34;
ifconfig_fxp0=&#34;inet 192.168.1.5 netmask 255.255.255.0&#34;
cloned_interfaces=&#34;carp0 carp1&#34;
ifconfig_carp0=&#34;vhid 1 advskew 100 pass testpass 192.168.1.50/24&#34;
ifconfig_carp1=&#34;vhid 2 advskew 100 pass testpass 192.168.1.51/24&#34;</pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>La preemptividad está deshabilitada en el kernel <span class=filename>GENERIC</span> de FreeBSD. Si la preemptividad se ha habilitado con un kernel personalizado <code>hostc.example.org</code> podría no devolver la dirección IP al servidor original. El administrador puede forzar que el servidor de reemplazo devuelve al dirección IP al maestro con el comando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig carp0 down &amp;&amp; ifconfig carp0 up</span></code></pre></div></div><div class=paragraph><p>Esto se debería hacer en la interfaz <span class=filename>carp</span> que se corresponda con el host correcto.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Una vez completada la configuración, reinicia la red o reinicia cada sistema. Ahora la alta disponibilidad está habilitada.</p></div></div></div><div class=sect2><h3 id=network-vlan>29.12. VLANs<a class=anchor href=#network-vlan></a></h3><div class=paragraph><p>VLANs son una forma de dividir una red de forma virtual en muchas subredes diferentes, también llamado segmentación. Cada segmento tendrá su dominio broadcast y está aislado de otras VLANs.</p></div><div class=paragraph><p>En FreeBSD, las VLANs tienen que estar soportadas por el controlador de la tarjeta de red. Para ver qué controladores soportan vlans, consulta la página de manual <a href="https://man.freebsd.org/cgi/man.cgi?query=vlan&amp;sektion=4&amp;format=html">vlan(4)</a>.</p></div><div class=paragraph><p>Cuando se configura una VLAN, se tienen que conocer un par de datos. Primero, ¿qué interfaz de red? Segundo, ¿cuál es la etiqueta de la VLAN?</p></div><div class=paragraph><p>Para configurar una VLAN en tiempo de ejecución, con un NIC de <code>em0</code> y una etiqueta de VLAN de <code>5</code> el comando se parecería a este:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig em0.5 create vlan 5 vlandev em0 inet 192.168.20.20/24</span></code></pre></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content><div class=paragraph><p>¿Te has fijado en cómo el nombre de la interfaz incluye el nombre del controlador del NIC y la etiqueta VLAN, separados por un punto? Esta es la mejor forma de mantener la configuración de la VLAN sencilla cuando hay muchas VLANs en la máquina.</p></div></td></tr></tbody></table></div><div class=paragraph><p>Para configurar VLANs en el arranque, se tiene que actualizar <span class=filename>/etc/rc.conf</span>. Para duplicar la configuración de arriba, se tiene que añadir lo siguiente:</p></div><div class="literalblock programlisting"><div class=content><pre>vlans_em0=&#34;5&#34;
ifconfig_em0_5=&#34;inet 192.168.20.20/24&#34;</pre></div></div><div class=paragraph><p>Se pueden añadir VLANs adicionales, simplemente añadiendo la etiqueta al campo <code>vlans_em0</code> y añadiendo una línea adicional configurando la red en la interfaz de esa etiqueta VLAN.</p></div><div class=paragraph><p>Es útil asignar un nombre simbólico a una interfaz de forma que cuando el hardware asociado cambie, sólo se necesiten actualizar unas pocas variables de configuración. Por ejemplo, las cámaras de seguridad necesitan ejecutarse sobre VLAN 1 en <code>em0</code>. Después, si la tarjeta <code>em0</code> es reemplazada con una tarjeta que utiliza el controlador <a href="https://man.freebsd.org/cgi/man.cgi?query=ixgb&amp;sektion=4&amp;format=html">ixgb(4)</a>, no habrá que cambiar a <code>ixgb0.1</code> todas las referencias a <code>em0.1</code>.</p></div><div class=paragraph><p>Para configurar la VLAN <code>5</code>, en el NIC <code>em0</code>, asigna el nombre de interfaz <code>cameras</code>, y asignar al interfaz la dirección IP <code><em>192.168.20.20</em></code> con un prefijo de <code>24</code> bits, usa este comando:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig em0.5 create vlan 5 vlandev em0 name cameras inet 192.168.20.20/24</span></code></pre></div></div><div class=paragraph><p>Para un interfaz llamado <code>video</code>, usa lo siguiente:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell><span class=c># ifconfig video.5 create vlan 5 vlandev video name cameras inet 192.168.20.20/24</span></code></pre></div></div><div class=paragraph><p>Para aplicar los cambios en el arranque, añade las siguientes líneas a <span class=filename>/etc/rc.conf</span>:</p></div><div class="literalblock programlisting"><div class=content><pre>vlans_video=&#34;cameras&#34;
create_args_cameras=&#34;vlan 5&#34;
ifconfig_cameras=&#34;inet 192.168.20.20/24&#34;</pre></div></div></div></div></div><h1 id=appendices class=sect0>Parte V: Apéndices<a class=anchor href=#appendices></a></h1><div class=sect1><h2 id=mirrors>Apéndice A: Cómo obtener FreeBSD<a class=anchor href=#mirrors></a></h2><div class=sectionbody><div class=sect2><h3 id=mirrors-ftp>A.1. Servidores FTP<a class=anchor href=#mirrors-ftp></a></h3></div><div class=sect2><h3 id=cvsup>A.2. Uso de CVSup<a class=anchor href=#cvsup></a></h3><div class=sect3><h4 id=cvsup-install>A.2.1. Instalación<a class=anchor href=#cvsup-install></a></h4></div><div class=sect3><h4 id=cvsup-mirrors>A.2.2. Servidores<a class=anchor href=#cvsup-mirrors></a></h4><div class=sect4><h5 id=cvsup-refuse-file>A.2.2.1. El fichero <span class=filename>refuse</span><a class=anchor href=#cvsup-refuse-file></a></h5></div></div></div></div></div><div class=sect1><h2 id=bibliography>Apéndice B: Bibliografía<a class=anchor href=#bibliography></a></h2><div class=sectionbody><div class=paragraph><p>Aunque las páginas del manual proveen la referencia definitiva para partes individuales del sistema operativo FreeBSD, son notorias por no ilustrar como poner todas las piezas juntas para hacer que todo el sistema operativo funcione fácilmente. Debido a esto, no hay sustituto para un buen libro de administración de sistemas UNIX y un buen manual de usuario.</p></div><div class=sect2><h3 id=_libros_y_revistas_específicas_sobre_freebsd>B.1. Libros y revistas específicas sobre FreeBSD<a class=anchor href=#_libros_y_revistas_específicas_sobre_freebsd></a></h3><div class=paragraph><p><em>Libros y revistas internacionales:</em></p></div><div class=ulist><ul><li><p><a href=http://freebsd.csie.nctu.edu.tw/~jdli/book.html>Usando FreeBSD</a> (en Chino).</p></li><li><p>FreeBSD for PC 98’ers (en japonés), publicado por SHUWA System Co, LTD. ISBN 4-87966-468-5 C3055 P2900E.</p></li><li><p>FreeBSD (en japonés), publicado por CUTT. ISBN 4-906391-22-2 C3055 P2400E.</p></li><li><p><a href=http://www.shoeisha.co.jp/pc/index/shinkan/97_05_06.htm>Introducción completa a FreeBSD</a> (en japonés), publicado por <a href=http://www.shoeisha.co.jp/>Shoeisha Co., Ltd</a>. ISBN 4-88135-473-6 P3600E.</p></li><li><p><a href=http://www.ascii.co.jp/pb/book1/shinkan/detail/1322785.html>Kit personal del principiante UNIX FreeBSD</a> (en japonés), publicado por <a href=http://www.ascii.co.jp/>ASCII</a>. ISBN 4-7561-1733-3 P3000E.</p></li><li><p>Manual FreeBSD (traducción del japonés), publicado por <a href=http://www.ascii.co.jp/>ASCII</a>. ISBN 4-7561-1580-2 P3800E.</p></li><li><p>FreeBSD mit Methode (en alemán), publicado por Computer und Literatur Verlag/Vertrieb Hanser, 1998. ISBN 3-932311-31-0.</p></li><li><p><a href=http://www.pc.mycom.co.uk/FreeBSD/install-manual.html>Manual de instalación y utilización de FreeBSD</a> (en japonés), publicado por <a href=http://www.pc.mycom.co.jp/>Mainichi Communications Inc.</a>.</p></li></ul></div><div class=paragraph><p><em>Libros y revistas en inglés:</em></p></div><div class=ulist><ul><li><p><a href=http://www.cdrom.com/titles/freebsd/bsdcomp_bkx.phtml>The Complete FreeBSD</a>, publicado por <a href=http://www.cdrom.com/>Walnut Creek CDROM</a>.</p></li></ul></div></div><div class=sect2><h3 id=_guías_de_usuario>B.2. Guías de usuario<a class=anchor href=#_guías_de_usuario></a></h3><div class=ulist><ul><li><p>Computer Systems Research Group, UC Berkeley. <em>4.4BSD User’s Reference Manual</em>. O’Reilly & Associates, Inc., 1994. ISBN 1-56592-075-9</p></li><li><p>Computer Systems Research Group, UC Berkeley. <em>4.4BSD User’s Supplementary Documents</em>. O’Reilly & Associates, Inc., 1994. ISBN 1-56592-076-7</p></li><li><p><em>UNIX in a Nutshell</em>. O’Reilly & Associates, Inc., 1990. ISBN 093717520X</p></li><li><p>Mui, Linda. <em>What You Need To Know When You Can’t Find Your UNIX System Administrator</em>. O’Reilly & Associates, Inc., 1995. ISBN 1-56592-104-6</p></li><li><p>La <a href=http://www-wks.acs.ohio-state.edu/>Ohio State University</a> ha escrito un <a href=http://www-wks.acs.ohio-state.edu/unix_course/unix.html>Curso de introducción a UNIX</a> disponible en línea en formato HTML y postscript.</p></li><li><p><a href=http://www.jp.FreeBSD.org/>Jpman Project, Japan FreeBSD Users Group</a>. <a href=http://www.pc.mycom.co.jp/FreeBSD/urm.html>FreeBSD User’s Reference Manual</a> (traducción japonesa). <a href=http://www.pc.mycom.co.jp/>Mainichi Communications Inc.</a>, 1998. ISBN4-8399-0088-4 P3800E.</p></li></ul></div></div><div class=sect2><h3 id=_guías_de_administrador>B.3. Guías de administrador<a class=anchor href=#_guías_de_administrador></a></h3><div class=ulist><ul><li><p>Albitz, Paul and Liu, Cricket. <em>DNS and BIND</em>, 2nd Ed. O’Reilly & Associates, Inc., 1997. ISBN 1-56592-236-0</p></li><li><p>Computer Systems Research Group, UC Berkeley. <em>4.4BSD System Manager’s Manual</em>. O’Reilly & Associates, Inc., 1994. ISBN 1-56592-080-5</p></li><li><p>Costales, Brian, et al. <em>Sendmail</em>, 2nd Ed. O’Reilly & Associates, Inc., 1997. ISBN 1-56592-222-0</p></li><li><p>Frisch, Æleen. <em>Essential System Administration</em>, 2nd Ed. O’Reilly & Associates, Inc., 1995. ISBN 1-56592-127-5</p></li><li><p>Hunt, Craig. <em>TCP/IP Network Administration</em>. O’Reilly & Associates, Inc., 1992. ISBN 0-937175-82-X</p></li><li><p>Nemeth, Evi. <em>UNIX System Administration Handbook</em>. 2nd Ed. Prentice Hall, 1995. ISBN 0131510517</p></li><li><p>Stern, Hal <em>Managing NFS and NIS</em> O’Reilly & Associates, Inc., 1991. ISBN 0-937175-75-7</p></li><li><p><a href=http://www.jp.FreeBSD.org/>Jpman Project, Japan FreeBSD Users Group</a>. <a href=http://www.pc.mycom.co.jp/FreeBSD/sam.html>FreeBSD System Administrator’s Manual</a> (traducción japonesa). <a href=http://www.pc.mycom.co.jp/>Mainichi Communications Inc.</a>, 1998. ISBN4-8399-0109-0 P3300E.</p></li></ul></div></div><div class=sect2><h3 id=_guías_de_programadores>B.4. Guías de programadores<a class=anchor href=#_guías_de_programadores></a></h3><div class=ulist><ul><li><p>Asente, Paul. <em>X Window System Toolkit</em>. Digital Press. ISBN 1-55558-051-3</p></li><li><p>Computer Systems Research Group, UC Berkeley. <em>4.4BSD Programmer’s Reference Manual</em>. O’Reilly & Associates, Inc., 1994. ISBN 1-56592-078-3</p></li><li><p>Computer Systems Research Group, UC Berkeley. <em>4.4BSD Programmer’s Supplementary Documents</em>. O’Reilly & Associates, Inc., 1994. ISBN 1-56592-079-1</p></li><li><p>Harbison, Samuel P. and Steele, Guy L. Jr. <em>C: A Reference Manual</em>. 4rd ed. Prentice Hall, 1995. ISBN 0-13-326224-3</p></li><li><p>Kernighan, Brian and Dennis M. Ritchie. <em>The C Programming Language.</em>. PTR Prentice Hall, 1988. ISBN 0-13-110362-9</p></li><li><p>Lehey, Greg. <em>Porting UNIX Software</em>. O’Reilly & Associates, Inc., 1995. ISBN 1-56592-126-7</p></li><li><p>Plauger, P. J. <em>The Standard C Library</em>. Prentice Hall, 1992. ISBN 0-13-131509-9</p></li><li><p>Stevens, W. Richard. <em>Advanced Programming in the UNIX Environment</em>. Reading, Mass. : Addison-Wesley, 1992 ISBN 0-201-56317-7</p></li><li><p>Stevens, W. Richard. <em>UNIX Network Programming</em>. 2nd Ed, PTR Prentice Hall, 1998. ISBN 0-13-490012-X</p></li><li><p>Wells, Bill. "Writing Serial Drivers for UNIX". <em>Dr. Dobb’s Journal</em>. 19(15), December 1994. pp68-71, 97-99.</p></li></ul></div></div><div class=sect2><h3 id=_el_sistema_operativo_por_dentro>B.5. El sistema operativo por dentro<a class=anchor href=#_el_sistema_operativo_por_dentro></a></h3><div class=ulist><ul><li><p>Andleigh, Prabhat K. <em>UNIX System Architecture</em>. Prentice-Hall, Inc., 1990. ISBN 0-13-949843-5</p></li><li><p>Jolitz, William. "Porting UNIX to the 386". <em>Dr. Dobb’s Journal</em>. January 1991-July 1992.</p></li><li><p>Leffler, Samuel J., Marshall Kirk McKusick, Michael J Karels and John Quarterman <em>The Design and Implementation of the 4.3BSD UNIX Operating System</em>. Reading, Mass. : Addison-Wesley, 1989. ISBN 0-201-06196-1</p></li><li><p>Leffler, Samuel J., Marshall Kirk McKusick, <em>The Design and Implementation of the 4.3BSD UNIX Operating System: Answer Book</em>. Reading, Mass. : Addison-Wesley, 1991. ISBN 0-201-54629-9</p></li><li><p>McKusick, Marshall Kirk, Keith Bostic, Michael J Karels, and John Quarterman. <em>The Design and Implementation of the 4.4BSD Operating System</em>. Reading, Mass. : Addison-Wesley, 1996. ISBN 0-201-54979-4</p></li><li><p>Stevens, W. Richard. <em>TCP/IP Illustrated, Volume 1: The Protocols</em>. Reading, Mass. : Addison-Wesley, 1996. ISBN 0-201-63346-9</p></li><li><p>Schimmel, Curt. <em>Unix Systems for Modern Architectures</em>. Reading, Mass. : Addison-Wesley, 1994. ISBN 0-201-63338-8</p></li><li><p>Stevens, W. Richard. <em>TCP/IP Illustrated, Volume 3: TCP for Transactions, HTTP, NNTP and the UNIX Domain Protocols</em>. Reading, Mass. : Addison-Wesley, 1996. ISBN 0-201-63495-3</p></li><li><p>Vahalia, Uresh. <em>UNIX Internals — The New Frontiers</em>. Prentice Hall, 1996. ISBN 0-13-101908-2</p></li><li><p>Wright, Gary R. and W. Richard Stevens. <em>TCP/IP Illustrated, Volume 2: The Implementation</em>. Reading, Mass. : Addison-Wesley, 1995. ISBN 0-201-63354-X</p></li></ul></div></div><div class=sect2><h3 id=_referencia_de_seguridad>B.6. Referencia de seguridad<a class=anchor href=#_referencia_de_seguridad></a></h3><div class=ulist><ul><li><p>Cheswick, William R. and Steven M. Bellovin. <em>Firewalls and Internet Security: Repelling the Wily Hacker</em>. Reading, Mass. : Addison-Wesley, 1995. ISBN 0-201-63357-4</p></li><li><p>Garfinkel, Simson and Gene Spafford. <em>Practical UNIX Security</em>. 2nd Ed. O’Reilly & Associates, Inc., 1996. ISBN 1-56592-148-8</p></li><li><p>Garfinkel, Simson. <em>PGP Pretty Good Privacy</em> O’Reilly & Associates, Inc., 1995. ISBN 1-56592-098-8</p></li></ul></div></div><div class=sect2><h3 id=_referencia_de_hardware>B.7. Referencia de hardware<a class=anchor href=#_referencia_de_hardware></a></h3><div class=ulist><ul><li><p>Anderson, Don and Tom Shanley. <em>Pentium Processor System Architecture</em>. 2nd Ed. Reading, Mass. : Addison-Wesley, 1995. ISBN 0-201-40992-5</p></li><li><p>Ferraro, Richard F. <em>Programmer’s Guide to the EGA, VGA, and Super VGA Cards</em>. 3rd ed. Reading, Mass. : Addison-Wesley, 1995. ISBN 0-201-62490-7</p></li><li><p>La corporación Intel publica documentación sobre sus CPUs, chipsets y estándares en su <a href=http://developer.intel.com/>web para desarrolladores</a>, normalmente en archivos con formato PDF.</p></li><li><p>Shanley, Tom. <em>80486 System Architecture</em>. 3rd ed. Reading, Mass. : Addison-Wesley, 1995. ISBN 0-201-40994-1</p></li><li><p>Shanley, Tom. <em>ISA System Architecture</em>. 3rd ed. Reading, Mass. : Addison-Wesley, 1995. ISBN 0-201-40996-8</p></li><li><p>Shanley, Tom. <em>PCI System Architecture</em>. 3rd ed. Reading, Mass. : Addison-Wesley, 1995. ISBN 0-201-40993-3</p></li><li><p>Van Gilluwe, Frank. <em>The Undocumented PC</em>. Reading, Mass: Addison-Wesley Pub. Co., 1994. ISBN 0-201-62277-7</p></li></ul></div></div><div class=sect2><h3 id=_historia_de_unix>B.8. Historia de UNIX<a class=anchor href=#_historia_de_unix></a></h3><div class=ulist><ul><li><p>Lion, John <em>Lion’s Commentary on UNIX, 6th Ed. With Source Code</em>. ITP Media Group, 1996. ISBN 1573980137</p></li><li><p>Raymond, Eric S. <em>The New Hacker’s Dictionary, 3rd edition</em>. MIT Press, 1996. ISBN 0-262-68092-0. Also known as the <a href=http://www.ccil.org/jargon/jargon.html>Jargon File</a></p></li><li><p>Salus, Peter H. <em>A quarter century of UNIX</em>. Addison-Wesley Publishing Company, Inc., 1994. ISBN 0-201-54777-5</p></li><li><p>Simon Garfinkel, Daniel Weise, Steven Strassmann. <em>The UNIX-HATERS Handbook</em>. IDG Books Worldwide, Inc., 1994. ISBN 1-56884-203-1</p></li><li><p>Don Libes, Sandy Ressler <em>Life with UNIX</em> - special edition. Prentice-Hall, Inc., 1989. ISBN 0-13-536657-7</p></li><li><p><em>The BSD family tree</em>. 1997. <a href=ftp://ftp.FreeBSD.org/pub/FreeBSD/FreeBSD-current/src/shared/misc/bsd-family-tree>ftp://ftp.FreeBSD.org/pub/FreeBSD/FreeBSD-current/src/shared/misc/bsd-family-tree</a> o <a href=file://localhost/usr/shared/misc/bsd-family-tree>local</a> on a FreeBSD-current machine.</p></li><li><p><em>The BSD Release Announcements collection</em>. 1997. <a href=http://www.de.FreeBSD.org/de/ftp/releases/>http://www.de.FreeBSD.org/de/ftp/releases/</a></p></li><li><p><em>Networked Computer Science Technical Reports Library</em>. <a href=http://www.ncstrl.org/>http://www.ncstrl.org/</a></p></li><li><p><em>Antiguas releases BSD procedentes del Computer Systems Research Group (CSRG)</em>. <a href=http://www.mckusick.com/csrg/>http://www.mckusick.com/csrg/</a>: El paquete de 4 CDs cubre todas las versiones de BSD desde la 1BSD hasta la 4.4BSD y 4.4BSD-Lite2 (pero no la 2.11BSD, desafortunadamente). El último disco contiene el código fuente final y los archivos SCCS.</p></li></ul></div></div><div class=sect2><h3 id=_diarios_y_revistas>B.9. Diarios y revistas<a class=anchor href=#_diarios_y_revistas></a></h3><div class=ulist><ul><li><p><em>The C/C++ Users Journal</em>. R&amp;D Publications Inc. ISSN 1075-2838</p></li><li><p><em>Sys Admin - The Journal for UNIX System Administrators</em> Miller Freeman, Inc., ISSN 1061-2688</p></li></ul></div></div></div></div><div class=sect1><h2 id=eresources>Apéndice C: Recursos en Internet<a class=anchor href=#eresources></a></h2><div class=sectionbody><div class=paragraph><p>La velocidad del desarrollo de FreeBSD hace imposible el uso de medios impresos como forma de seguir los últimos desarrollos. Los recursos electrónicos son la mejor, y con frecuencia la única, manera de estar informados de los últimos avances. Dado que FreeBSD es sacado adelante mediante el trabajo de voluntarios la propia comunidad de usuarios suele ejercer las funciones de lo que sería un "departamento de soporte técnico", siendo el correo electrónico y USENET la manera más efectiva de contactar con esa comunidad.</p></div><div class=paragraph><p>Las formas de contacto con la comunidad de usuarios de FreeBSD están detalladas a continuación. Si usted sabe de algún otro medio que no figure aquí envíelo por favor a <a href=https://lists.FreeBSD.org/subscription/freebsd-doc>Lista de correo del proyecto de documentación de FreeBSD</a> para que pueda ser incluída.</p></div><div class=sect2><h3 id=eresources-mail>C.1. Listas de correo<a class=anchor href=#eresources-mail></a></h3><div class=paragraph><p>Aunque la práctica totalidad de los desarrolladores de FreeBSD léen USENET no podemos garantizar de modo rotundo que recibiremos sus dudas rápidamente (o siquiera que las recibamos) si usted las envía a uno de los grupos de <code>comp.unix.bsd.freebsd.*</code>. Enviando sus dudas a la lista de correo apropiada cumplirá dos objetivos, llegar a los desarrolladores y a una audiencia específica, lo que le asegurará la mejor (o al menos la más rápida) respuesta.</p></div><div class=paragraph><p>Las normas de las diversas listas están al principio de éste documento. <em>Por favor, léa las normas antes de suscribirse o enviar correo a ninguna lista</em>. Muchos suscriptores de nuestras listas reciben varios cientos de mensajes relacionados con FreeBSD cada día y estableciendo las normas de uso de las listas intentamos mantener alto el interés de los mensajes que en ella circulan. Bajarlo haría fallar a las listas de correo como un medio de comunicación efectivo para el proyecto.</p></div><div class=paragraph><p>Todas las listas de correo son archivadas y se pueden hacer búsquedas en ellas desde el servidor WWW de FreeBSD usando <a href=https://www.FreeBSD.org/search/>éste enlace</a>. El archivo ofrece la posibilidad de usar palabras clave, lo que lo convierte en una excelente manera de buscar respuestas a preguntas frecuentes y debería ser consultado antes de enviar ninguna duda.</p></div><div class=sect3><h4 id=eresources-summary>C.1.1. Índice de listas<a class=anchor href=#eresources-summary></a></h4><div class=paragraph><p><em>Listas generales:</em> Las siguientes son listas generales de suscripción libre (y muy recomendable):</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Lista</th><th class="tableblock halign-left valign-top">Propósito</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>cvs-all</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Cambios realizados en el árbol de código de FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>freebsd-advocacy</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Proselitismo de FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>freebsd-announce</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Sucesos importantes e hitos del proyecto</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>freebsd-arch</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Debates de arquitectura y diseños</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>freebsd-bugs</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Informes de errores</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>freebsd-chat</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Temas no técnicos relacionados con la comunidad FreeBSD.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>freebsd-config</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Desarrollo de herramientas de instalación y configuración de FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>freebsd-current</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Debates acerca del uso de FreeBSD-current</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>freebsd-isp</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Consultas de Proveedores de Servicios de Internet que usan FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>freebsd-jobs</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Oportunidades de trabajo y consultoría bajo FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>freebsd-newbies</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Actividades y discusiones de nuevos usuarios de FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>freebsd-policy</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Decisiones estratégicas del Core Team de FreeBSD. Bajo volumen y sólo lectura</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>freebsd-questions</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Preguntas de usuarios y soporte técnico</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>freebsd-stable</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Debates acerca del uso de FreeBSD-stable</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>freebsd-test</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Un sitio al que mandar sus mensajes de prueba en lugar de a una de las demás listas</p></td></tr></tbody></table><div class=paragraph><p><em>Listas Técnicas:</em> Las siguientes listas son para debates técnicos. Debería leer cuidadosamente las normas de cada lista antes de suscribirse o enviar correos, dado que hay normas estrictas en cuanto a su uso y contenidos.</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Lista</th><th class="tableblock halign-left valign-top">Propósito</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>freebsd-afs</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Porte de AFS a FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>freebsd-alpha</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Porte FreeBSD a Alpha</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>freebsd-arm</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Porte de FreeBSD para procesadores ARM</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>freebsd-atm</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Uso de redes ATM con FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>freebsd-audit</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Proyecto de auditoría del código fuente</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>freebsd-binup</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Diseño y desarrollo del sistema de actualización binaria</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>freebsd-cluster</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Uso de FreeBSD en entornos cluster</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>freebsd-database</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Debates sobre uso de bases de datos y su desarrollo bajo FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>freebsd-doc</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Creación de documentación sobre FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>freebsd-emulation</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Emulación de otros sistemas como Linux/DOS/Windows</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>freebsd-firewire</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Debates técnicos sobre Firewire (iLink, IEEE 1394)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>freebsd-fs</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Sistemas de ficheros</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>freebsd-hackers</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Debates técnicos generales</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>freebsd-hardware</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Debates generales sobre harware y su uso en FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>freebsd-i18n</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Internacionalización de FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>freebsd-ia64</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Porte de FreeBSD a los próximos sistemas IA64 de Intel</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>freebsd-ipfw</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Debates técnicos sobre el rediseño del código del cortafuegos IP</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>freebsd-isdn</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Desarrolladores de RDSI</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>freebsd-java</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Desarrolladores de Java y personas portando los JDK a FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>freebsd-libh</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>La segunda generación del sistema de instalación y paquetes</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>freebsd-mobile</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Debates sobre equipos portátiles</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>freebsd-mozilla</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Porte de mozilla a FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>freebsd-multimedia</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Aplicaciones multimedia</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>freebsd-new-bus</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Debates técnicos sobre la arquitectura de bus</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>freebsd-net</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Debates sobre el código fuente de Redes y TCP/IP</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>freebsd-platforms</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Específica sobre plataformas de arquitectura no Intel</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>freebsd-ports</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Debates sobre la colección de ports</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>freebsd-ppc</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Porte de FreeBSD a PowerPC</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>freebsd-qa</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Debates sobre Control de Calidad, generalmente al salir una nueva release</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>freebsd-realtime</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Desarrollo de extensiones en tiempo real en FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>freebsd-scsi</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>El subsistema SCSI</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>freebsd-security</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Temas de seguridad</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>freebsd-security-notifications</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Avisos de seguridad</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>freebsd-small</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Uso de FreeBSD en aplicaciones embebidas</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>freebsd-smp</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Debates sobre diseño de Multiproceso [A]Simétrico</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>freebsd-sparc</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Porte de FreeBSD a sistemas Sparc</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>freebsd-standards</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Cumplimiento de las normas C99 y POSIX en FreeBSD</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>freebsd-tokenring</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Soporte de Token Ring en FreeBSD</p></td></tr></tbody></table><div class=paragraph><p>_Listas limitadas:_Las siguientes listas son para una audiencia más especializada (e interesada)y probablemente no son de interés para el público en general. Es una buena idea tener una presencia estable en las listas técnicas antes de suscribirse a alguna de las limitadas, de modo que se pueda entender la etiqueta de la comunicación que en ellas se usa.</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Lista</th><th class="tableblock halign-left valign-top">Propósito</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>freebsd-core</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>FreeBSD Core Team</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>freebsd-hubs</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Mantenimiento de mirrors (mantenimiento de infraestructuras)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>freebsd-install</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Desarrollo de la Instalación</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>freebsd-user-groups</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Coordinación de grupos de usuarios</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>freebsd-www</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Mantenimiento de <a href=https://www.FreeBSD.org>www.FreeBSD.org</a></p></td></tr></tbody></table><div class=paragraph><p><em>Listas Compendio:</em> La mayoría de las listas citadas son accesibles como compendio. Los nuevos mensajes enviados a la lista son guardados y enviados como un único correo cuando el archivo llega a un tamaño cercano a los 100 Kb. Las listas accesibles como compendio son:</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:100%><thead><tr><th class="tableblock halign-left valign-top">Lista</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>freebsd-afs-digest</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>freebsd-alpha-digest</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>freebsd-chat-digest</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>freebsd-current-digest</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>freebsd-cvs-all-digest</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>freebsd-database-digest</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>freebsd-hackers-digest</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>freebsd-ia64-digest</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>freebsd-isdn-digest</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>freebsd-java-digest</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>freebsd-questions-digest</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>freebsd-security-digest</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>freebsd-sparc-digest</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>freebsd-stable-digest</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>freebsd-test-digest</p></td></tr></tbody></table><div class=paragraph><p><em>Listas CVS:</em> Las siguientes listas son para gente interesada en llevar un seguimiento de los mensajes en el registro para conocer los cambios hechos en las diferentes áreas del árbol de código fuente. Son listas <em>de sólo lectura</em> y no se debe enviar correo a ellas.</p></div><table class="tableblock frame-none grid-all stretch informaltable"><col style=width:33.3333%><col style=width:33.3333%><col style=width:33.3334%><thead><tr><th class="tableblock halign-left valign-top">Lista</th><th class="tableblock halign-left valign-top">Área de código</th><th class="tableblock halign-left valign-top">Descripción de área de código (código fuente)</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>cvs-all</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>/usr/src</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Todos los cambios al árbol de código (superconjunto)</p></td></tr></tbody></table></div><div class=sect3><h4 id=eresources-subscribe>C.1.2. Cómo suscribirse<a class=anchor href=#eresources-subscribe></a></h4><div class=paragraph><p>Todas las listas de correo están en <code>FreeBSD.org</code>, de manera que para enviar correo a la lista "nombredelista" simplemente hay que escribir a &lt;<a href=mailto:_nombredelista_@FreeBSD.org>_nombredelista_@FreeBSD.org</a>>. Desde ahí será redistribuído a los miembros de la lista de correo a lo largo y ancho del mundo.</p></div><div class=paragraph><p>Para suscribirse a una lista envíe un correo a <a href=mailto:majordomo@FreeBSD.org>majordomo@FreeBSD.org</a> incluyendo</p></div><div class="literalblock programlisting"><div class=content><pre>subscribe &lt;listname&gt; [&lt;optional address&gt;]</pre></div></div><div class=paragraph><p>en el cuerpo del mensaje. Por ejemplo, para suscribirse a <code>freebsd-announce</code> usted haría esto:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% mail majordomo@FreeBSD.org
subscribe freebsd-announce local-announce@ejemplo.com
^D</code></pre></div></div><div class=paragraph><p>Si quisiera suscribirse bajo otro nombre o enviar una petición de suscripción para una lista de correo local (un sistema muy eficiente si dispone de varias personas interesadas que tengan cuentas de correo en un mismo servidor ¡esto nos facilita mucho el trabajo!) ésto es lo que debe hacer:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% mail majordomo@FreeBSD.org
subscribe freebsd-announce local-announce@ejemplo.com
^D</code></pre></div></div><div class=paragraph><p>Por último, también es posible desuscribirse de una lista, obtener una lista de los suscriptores de una lista u obtener una lista de las listas de correo disponibles enviando otro tipo de mensajes de control a majordomo. Para obtener una lista completa de las órdenes disponibles haga esto:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=shell>% mail majordomo@FreeBSD.org
<span class=nb>help</span>
^D</code></pre></div></div><div class=paragraph><p>De nuevo quisiéramos pedirle que procure mantener los debates de las listas técnicas dentro de temas técnicos. Si lo único que usted quiere es recibir avisos importantes le sugerimos que se suscriba a freebsd-announce, que está pensada para tener un tráfico muy bajo.</p></div></div><div class=sect3><h4 id=eresources-charters>C.1.3. Normas de las listas<a class=anchor href=#eresources-charters></a></h4><div class=paragraph><p><em>Todas</em> las listas de correo de FreeBSD tienen ciertas normas elementales que han de ser respetadas por cualquiera que las use. Quien no se atenga a ellas recibirá hasta dos (2) advertencias escritas del Postmaster de FreeBSD <a href=mailto:postmaster@FreeBSD.org>postmaster@FreeBSD.org</a>, después de las cuales, a la tercera falta, el suscriptor será borrado de todas las listas de correo de FreeBSD y filtrado para evitar futuros envíos. Lamentamos que esas normas y medidas sean necesarias, pero la Internet de hoy es, según parece, un entorno bastante conflictivo, y mucha gente no se da cuenta de cuán frágiles son algunos de sus mecanismos.</p></div><div class=paragraph><p>Normas a respetar:</p></div><div class=ulist><ul><li><p>El tema de cualquier envío debe atenerse al fin básico de la lista a la que se escribe, esto es, si la lista es sobre temas de debate técnico sus envíos deberían versar sobre temas técnicos. Enviar mensajes irrelevantes o insultos sólo sirve para deteriorar el valor de la lista de correo para sus miembros y no será tolerado. Para discusiones libres sin un tema en particular está la lista de correo freebsd-chat <a href=mailto:freebsd-chat@FreeBSD.org>freebsd-chat@FreeBSD.org</a>, que es libremente accesible y hecha para éste propósito.</p></li><li><p>No se debería enviar el mismo mensaje a más de dos listas, y sólamente a 2 cuando exista una necesidad manifiesta de escribir a ambas listas. Hay una gran cantidad de personas suscritas a más de una lista y excepto para las mezclas más esotéricas (digamos "-stable & -scsi") no hay razón para enviar un mensaje a más de una lista al mismo tiempo. Si le envían un mensaje en el que aparecen múltiples listas de correo en la línea "Cc" de la cabecera, dicha línea debe ser recortada antes de que envíe una respuesta. <em>Usted es el _responsable</em> de sus propios envíos cruzados, independientemente de quién fuese el remitente original._</p></li><li><p>No están admitidos los ataques personales ni la blasfemia (dentro del contexto o como argumento) y eso incluye tanto a usuarios como a desarrolladores. Violaciones graves de la netiqueta, como reenviar o extractar mensajes privados sin permiso ni visos de tenerlo, está mal visto, aunque no prohibido específicamente. Sin embargo, hay pocos casos en los que algo así encaje en la temática de una lista, por lo cual lo más probable es recibir una advertencia (o ser expulsado) tan sólo a causa de ello.</p></li><li><p>El anuncio de productos o servicios no relacionados con FreeBSD están estrictamente prohibidas y conllevarán la inmediata expulsión de la lista si queda demostrado que el autor está practicando el "spam" o envío de correo no solicitado.</p></li></ul></div><div class=paragraph><p><em>Normas de las listas individuales:</em></p></div><div class=dlist><dl><dt class=hdlist1>FREEBSD-AFS</dt><dd><p><em>Sistema de Ficheros Andrew</em></p><div class=paragraph><p>Ésta lista es para debates sobre el porte y uso de AFS, de CMU/Transarc</p></div></dd><dt class=hdlist1>FREEBSD-ANNOUNCE</dt><dd><p><em>Sucesos importantes / hitos</em></p><div class=paragraph><p>Ésta es la lista de correo para gente interesada en recibir exclusivamente avisos de sucesos importantes dentro de FreeBSD. Ésto incluye anuncios sobre SNAPSHOTS y otras versiones. Puede incluír también peticiones de voluntarios, etc. Es una lista de bajo volumen y estrictamente moderada.</p></div></dd><dt class=hdlist1>FREEBSD-ARCH</dt><dd><p><em>Debates sobre arquitectura y diseño</em></p><div class=paragraph><p>Ésta lista es para debates sobre la arquitectura de FreeBSD. Los mensajes deberían mantenerse dentro del ámbito técnico para el que fué creada la lista. Serían ejemplos de temas aptos para ésta lista:</p></div><div class=ulist><ul><li><p>Como reorganizar el sistema de construcción ("build") para poder tener varios procesos de construcción personalizados funcionando simultáneamente.</p></li><li><p>Qué se necesita arreglar en el VFS para que funcionen las capas de Heidemann.</p></li><li><p>Cómo cambiar el dispositivo de control de interfaces para que sea posible utilizar los mismos controladores directamente en la mayoría de los buses y arquitecturas.</p></li><li><p>Cómo escribir un controlador de red.</p></li></ul></div></dd><dt class=hdlist1>FREEBSD-AUDIT</dt><dd><p><em>Proyecto de auditoría del código fuente</em></p><div class=paragraph><p>Ésta es la lista de correo del proyecto de auditoría del código fuente de FreeBSD. Aunque en principio fué puesta en marcha para cambios motivados por la seguridad su ámbito fué ampliado a la revisión de cualquier cambio en el código.</p></div><div class=paragraph><p>En ésta lista circula una gran cantidad de parches y probablemente no sea de interés para el típico usuario de FreeBSD. Las discusiones de seguridad que no estén relacionadas con una parte específica del código deben tener lugar en freebsd-security. Por otra parte se ruega a todos los desarrolladores que envíen sus parches a ésta lista para su revisión, especialmente si atañen a una parte del sistema donde un error pudiera afectar seriamente a la integridad del sistema.</p></div></dd><dt class=hdlist1>FREEBSD-BINUP</dt><dd><p><em>Proyecto de Actualización Binaria de FreeBSD</em></p><div class=paragraph><p>Ésta lista existe para facilitar el debate sobre el sistema de actualizacion binaria o binup. Características de diseño, detalles de implementación, parches, informes de error, informes de estado, peticiones de características, "commit logs" y en general todo lo relacionado con binup es bienvenido.</p></div></dd><dt class=hdlist1>FREEBSD-BUGS</dt><dd><p><em>Informe de errores</em></p><div class=paragraph><p>Ésta es la lista de correo para informar de errores en FreeBSD. Siempre que sea posible los errores deberían ser enviados mediante <a href="https://man.freebsd.org/cgi/man.cgi?query=send-pr&amp;sektion=1&amp;format=html">send-pr(1)</a> o el <a href=https://www.FreeBSD.org/send-pr/>interfaz WEB</a></p></div></dd><dt class=hdlist1>FREEBSD-CHAT</dt><dd><p><em>Temas no técnicos relacionados con la comunidad FreeBSD</em></p><div class=paragraph><p>Ésta lista contiene todos los mensajes sobre información no técnica y social, contenidos que no tienen cabida en las demás listas. Eso incluye discusiones sobre si Julio Iglesias parece una gárgola, sobre si escribir o no en mayúsculas, quién está bebiendo demasiado café, dónde se elabora la mejor cerveza, quién está fabricando cerveza en su sótano y así sucesivamente. Pueden hacerse anuncios sobre actos importantes (como próximas fiestas, congresos, bodas, nacimientos, nuevos trabajos, etc.), pero las respuestas deben ser dirigidas a ésta misma lista.</p></div></dd><dt class=hdlist1>FREEBSD-CORE</dt><dd><p><em>FreeBSD Core Team</em></p><div class=paragraph><p>Ésta es la lista de correo interna para uso de los miembros del Core Team. Los mensajes pueden ser enviados a ésta lista cuando un problema serio relacionado con FreeBSD necesite un estudio o arbitraje de alto nivel.</p></div></dd><dt class=hdlist1>FREEBSD-CURRENT</dt><dd><p><em>Debates sobre el uso de FreeBSD-current</em></p><div class=paragraph><p>Ésta es la lista de correo para usuarios de freebsd-current. Esto incluye advertencias sobre nuevas características a ser incluídas en -current que afecten a todos los usuarios e instrucciones paso por paso que deben ser seguidas para mantener una instalación -current. Cualquier usuario de "current" debería suscribirse a ésta lista. Ésta es una lista de correo técnica en la que se esperan contenidos estrictamente técnicos.</p></div></dd><dt class=hdlist1>FREEBSD-CURRENT-DIGEST</dt><dd><p><em>Debates sobre el uso de FreeBSD-current</em></p><div class=paragraph><p>Éste es el compendio de la lista freebsd-current. Consiste en que todos los mensajes enviados a freebsd-current son empaquetados y enviados periódicamente como un solo mensaje. Ésta lista es de <em>Sólo-Lectura</em> y no debería recibir correo.</p></div></dd><dt class=hdlist1>FREEBSD-DOC</dt><dd><p><em>Proyecto de Documentación</em></p><div class=paragraph><p>Ésta lista de correo está destinada a discusiones relacionadas con cuestiones y proyectos relacionados con la creación de documentación de FreeBSD. Los miembros de ésta lista son llamados "El Proyecto de Documentación de FreeBSD". La lista es abierta; ¡suscríbase y contribuya!.</p></div></dd><dt class=hdlist1>FREEBSD-FIREWIRE</dt><dd><p><em>Firewire (iLink, IEEE 1394)</em></p><div class=paragraph><p>Ésta lista de correo es para debates sobre diseño e implementación del subsistema Firewire(también conocido como IEEE o iLink) en FreeBSD. Los temas incluyen de modo específico los "standards", dispositivos de bus y sus protocolos, adaptación de placas base, tarjetas y chips y la arquitectura e implementación de código para soporte nativo.</p></div></dd><dt class=hdlist1>FREEBSD-FS</dt><dd><p><em>Sistemas de ficheros</em></p><div class=paragraph><p>Debates acerca del sistema de ficheros de FreeBSD. Ésta es una lista de correo técnica en la que se espera un contenido estríctamente técnico.</p></div></dd><dt class=hdlist1>FREEBSD-GNOME</dt><dd><p><em>GNOME</em></p><div class=paragraph><p>Debates acerca del Entorno de Escritorio GNOME para sistemas de ficheros FreeBSD. Ésta es una lista de correo técnica en la que se espera un contenido estrictamente técnico.</p></div></dd><dt class=hdlist1>FREEBSD-IPFW</dt><dd><p><em>Cortafuegos IP</em></p><div class=paragraph><p>Éste es el foro de discusión técnica dedicado al rediseño del código del cortafuegos IP de FreeBSD. Ésta es una lista de correo técnica en la que se espera un contenido exclusivamente técnico.</p></div></dd><dt class=hdlist1>FREEBSD-IA64</dt><dd><p><em>Porte de FreeBSD a IA64</em></p><div class=paragraph><p>Ésta es una lista de correo técnica para personas que están trabajando en el porte de FreeBSD a la plataforma IA-64 de Intel, para intercambiar problemas y soluciones alternativas. Cualquier persona interesada en seguir las discusiones técnicas es bienvenida.</p></div></dd><dt class=hdlist1>FREEBSD-ISDN</dt><dd><p><em>Comunicaciones RDSI</em></p><div class=paragraph><p>Ésta es la lista de correo para quienes participan en el desarrollo del soporte RDSI para FreeBSD.</p></div></dd><dt class=hdlist1>FREEBSD-JAVA</dt><dd><p><em>Desarrollo Java</em></p><div class=paragraph><p>Ésta es la lista de correo sobre el desarrollo de aplicaciones Java importantes para FreeBSD y el porte y mantenimiento de los JDK.</p></div></dd><dt class=hdlist1>FREEBSD-HACKERS</dt><dd><p><em>Debates técnicos</em></p><div class=paragraph><p>Éste es un foro de debate técnico relacionado con FreeBSD. Ésta es la lista de correo técnica primaria. Es para personas que están trabajando en FreeBSD, solucionando problemas o para discutir soluciones alternativas. Las personas interesadas en seguir las discusiones técnicas también son bienvenidas. Ésta es una lista de correo técnica en la cual se espera un contenido estrictamente técnico.</p></div></dd><dt class=hdlist1>FREEBSD-HACKERS-DIGEST</dt><dd><p><em>Technical discussions</em></p><div class=paragraph><p>Éste es el compendio de la lista de correo freebsd-hackers. Consiste en que todo el correo enviado a freebsd-hackers es empaquetado y enviado en un sólo mensaje. Ésta lista es de <em>Sólo Lectura</em> y no se debería enviar correo a ella.</p></div></dd><dt class=hdlist1>FREEBSD-HARDWARE</dt><dd><p><em>Discusiones generales sobre hardware y FreeBSD</em></p><div class=paragraph><p>Discusiones generales sobre tipos de hardware que funciona en FreeBSD, diferentes problemas y sugerencias sobre qué comprar y qué no.</p></div></dd><dt class=hdlist1>FREEBSD-HUBS</dt><dd><p><em>Réplicas</em></p><div class=paragraph><p>Avisos y discusiones para personas que administran sitios réplica.</p></div></dd><dt class=hdlist1>FREEBSD-INSTALL</dt><dd><p><em>Discusiones sobre la instalación</em></p><div class=paragraph><p>Ésta lista de correo es para discusiones sobre el desarrollo de la instalación de FreeBSD en próximas versiones.</p></div></dd><dt class=hdlist1>FREEBSD-ISP</dt><dd><p><em>Cuestiones de Proveedores de Servicios de Internet</em></p><div class=paragraph><p>Ésta lista de correo es para debates sobre temas relevantes para Proveedores de Servicios de Internet (ISP) que usan FreeBSD. Es una lista de correo técnica y en ella se esperan contenidos estríctamente técnicos.</p></div></dd><dt class=hdlist1>FREEBSD-NEWBIES</dt><dd><p><em>Debates sobre actividades de los novatos</em></p><div class=paragraph><p>Cubrimos todas las actividades de los novatos que no quedan cubiertas por ninguna de las otras, incluyendo: aprendizaje autodidacta y técnicas de resolución de problemas, búsqueda y uso de recursos y peticiones de ayuda, cómo usar las listas de correo y qué lista usar, charla en general, meter la pata, jactarse, compartir ideas, historias, soporte moral (pero no técnico) e implicación en la comunidad FreeBSD. Usamos freebsd-questions para enviar nuestros problemas y peticiones de soporte y usamos freebsd-newbies para conocer a gente que está haciendo lo mismo que nosotros cuando éramos novatos.</p></div></dd><dt class=hdlist1>FREEBSD-PLATFORMS</dt><dd><p><em>Porte a plataformas no Intel</em></p><div class=paragraph><p>Cuestiones sobre plataformas diversas, debates generales, y propuestas para portes de FreeBSD para plataformas no Intel. Es una lista de correo técnica y en ella se esperan contenidos estríctamente técnicos.</p></div></dd><dt class=hdlist1>FREEBSD-POLICY</dt><dd><p><em>Decisiones de funcionamiento interno del Core Team</em></p><div class=paragraph><p>Es una lista de sólo lectura y bajo volumen destinada a la toma de decisiones de funcionamento interno del Core Team de FreeBSD.</p></div></dd><dt class=hdlist1>FREEBSD-PORTS</dt><dd><p><em>Debates sobre "ports"</em></p><div class=paragraph><p>Debates acerca de la "colección de ports" (<span class=filename>/usr/ports</span>)de FreeBSD, propuestas de aplicaciones a portar, modificaciones a la infraestructura de ports y coordinación general de esfuerzos. Ésta es una lista de correo técnica en la cual se esperan contenidos exclusivamente técnicos.</p></div></dd><dt class=hdlist1>FREEBSD-QUESTIONS</dt><dd><p><em>Preguntas de los usuarios</em></p><div class=paragraph><p>Ésta es la lista de correo para preguntas sobre FreeBSD. No debería enviar preguntas del estilo de "cómo hacer" a las listas técnicas salvo que el contenido sea claramente técnico.</p></div></dd><dt class=hdlist1>FREEBSD-QUESTIONS-DIGEST</dt><dd><p><em>Preguntas de los usuarios</em></p><div class=paragraph><p>Éste es el compendio de la lista de correo freebsd-questions. Consiste en que todos los mensajes enviados a freebsd-questions son empaquetados y enviados en un único mensaje.</p></div></dd><dt class=hdlist1>FREEBSD-SCSI</dt><dd><p><em>Subsistema SCSI</em></p><div class=paragraph><p>Ésta es la lista de correo para la gente que está trabajando en el subsistema SCSI de FREEBSD. Ésta es una lista de correo técnica en la cual se esperan contenidos puramente técnicos.</p></div></dd><dt class=hdlist1>FREEBSD-SECURITY</dt><dd><p><em>Cuestiones de seguridad</em></p><div class=paragraph><p>Cuestiones de seguridad informática (DES, Kerberos, problemas de seguridad conocidos y sus soluciones, etc.) Ésta es una lista de correo técnica en la que se esperan contenidos puramente técnicos.</p></div></dd><dt class=hdlist1>FREEBSD-SECURITY-NOTIFICATIONS</dt><dd><p><em>Avisos de seguridad</em></p><div class=paragraph><p>Avisos de problemas de seguridad en FreeBSD y sus soluciones. Ésta no es una lista de discusión. La lista de discusión es freebsd-security.</p></div></dd><dt class=hdlist1>FREEBSD-SMALL</dt><dd><p><em>Uso de FreeBSD en aplicaciones embebidas</em></p><div class=paragraph><p>En ésta lista se debaten temas relacionados con instalaciones de FreeBSD inusualmente pequeñas y embebidas. Ésta es una lista de correo técnica en la cual se esperan contenidos estrictamente técnicos.</p></div></dd><dt class=hdlist1>FREEBSD-STABLE</dt><dd><p><em>Debates sobre el uso de FreeBSD-stable</em></p><div class=paragraph><p>Ésta es la lista de correo para los usuarios de freebsd-stable. Incluye avisos sobre nuevas características a incluír en -stable que afectan a los usuarios e instrucciones paso por paso para permanecer usando la versión -stable. Cualquiera que utilice FreeBSD "stable" debería suscribirse a ésta lista. Ésta es una lista técnica en la que se esperan contenidos puramente técnicos.</p></div></dd><dt class=hdlist1>FREEBSD-STANDARDS</dt><dd><p><em>Cumplimiento de C99 & POSIX</em></p><div class=paragraph><p>Éste es el foro para debates técnicos relacionadas con el Cumplimiento de las normas C99 y POSIX en FreeBSD.</p></div></dd><dt class=hdlist1>FREEBSD-USER-GROUPS</dt><dd><p><em>Lista de coordinación de de grupos de usuarios</em></p><div class=paragraph><p>Ésta es la lista de correo de los coordinadores de los grupos locales de usuarios para discutir cuestiones entre ellos o con personas elegidas del Core Team. Ésta lista de correo debería estar limitada a resúmenes de reuniones y coordinación de proyectos que atañen a los Grupos de Usuarios.</p></div></dd><dt class=hdlist1>FREEBSD-VENDORS</dt><dd><p><em>VENDORS</em></p><div class=paragraph><p>Debates para la coordinación entre el Proyecto FreeBSD y Distribuidores de software y hardware para FreeBSD.</p></div></dd></dl></div></div></div><div class=sect2><h3 id=eresources-news>C.2. Grupos de noticias de Usenet<a class=anchor href=#eresources-news></a></h3><div class=paragraph><p>Además de los dos grupos de noticias específicos de FreeBSD hay muchos otros en los cuales se habla sobre FreeBSD o son de algún modo interesantes para usuarios de FreeBSD.Hay un <a href=http://minnie.tuhs.org/BSD-info/bsdnews_search.html>archivo donde hacer búsquedas</a> donde pueden encontrarse algunos de esos grupos de noticias por cortesía de Warren Toomey <a href=mailto:wkt@cs.adfa.edu.au>wkt@cs.adfa.edu.au</a>.</p></div><div class=sect3><h4 id=_grupos_de_noticias_específicos_sobre_bsd>C.2.1. Grupos de noticias específicos sobre BSD<a class=anchor href=#_grupos_de_noticias_específicos_sobre_bsd></a></h4><div class=ulist><ul><li><p><a href=news:comp.unix.bsd.freebsd.announce>comp.unix.bsd.freebsd.announce</a></p></li><li><p><a href=news:comp.unix.bsd.freebsd.misc>comp.unix.bsd.freebsd.misc</a></p></li></ul></div></div><div class=sect3><h4 id=_otros_grupos_de_noticias_interesantes_sobre_unix>C.2.2. Otros grupos de noticias interesantes sobre Unix<a class=anchor href=#_otros_grupos_de_noticias_interesantes_sobre_unix></a></h4><div class=ulist><ul><li><p><a href=news:comp.unix>comp.unix</a></p></li><li><p><a href=news:comp.unix.questions>comp.unix.questions</a></p></li><li><p><a href=news:comp.unix.admin>comp.unix.admin</a></p></li><li><p><a href=news:comp.unix.programmer>comp.unix.programmer</a></p></li><li><p><a href=news:comp.unix.shell>comp.unix.shell</a></p></li><li><p><a href=news:comp.unix.user-friendly>comp.unix.user-friendly</a></p></li><li><p><a href=news:comp.security.unix>comp.security.unix</a></p></li><li><p><a href=news:comp.sources.unix>comp.sources.unix</a></p></li><li><p><a href=news:comp.unix.advocacy>comp.unix.advocacy</a></p></li><li><p><a href=news:comp.unix.misc>comp.unix.misc</a></p></li><li><p><a href=news:comp.bugs.4bsd>comp.bugs.4bsd</a></p></li><li><p><a href=news:comp.bugs.4bsd.ucb-fixes>comp.bugs.4bsd.ucb-fixes</a></p></li><li><p><a href=news:comp.unix.bsd>comp.unix.bsd</a></p></li></ul></div></div><div class=sect3><h4 id=_sistema_x_window>C.2.3. Sistema X Window<a class=anchor href=#_sistema_x_window></a></h4><div class=ulist><ul><li><p><a href=news:comp.windows.x.i386unix>comp.windows.x.i386unix</a></p></li><li><p><a href=news:comp.windows.x>comp.windows.x</a></p></li><li><p><a href=news:comp.windows.x.apps>comp.windows.x.apps</a></p></li><li><p><a href=news:comp.windows.x.announce>comp.windows.x.announce</a></p></li><li><p><a href=news:comp.windows.x.intrinsics>comp.windows.x.intrinsics</a></p></li><li><p><a href=news:comp.windows.x.motif>comp.windows.x.motif</a></p></li><li><p><a href=news:comp.windows.x.pex>comp.windows.x.pex</a></p></li><li><p><a href=news:comp.emulators.ms-windows.wine>comp.emulators.ms-windows.wine</a></p></li></ul></div></div></div><div class=sect2><h3 id=eresources-web>C.3. Servidores WWW<a class=anchor href=#eresources-web></a></h3><div class=ulist><ul><li><p><a href=https://www.FreeBSD.org>http://www.FreeBSD.org/</a> - Servidor Central.</p></li><li><p><a href=http://www.au.FreeBSD.org/>http://www.au.FreeBSD.org/</a> - Australia/1.</p></li><li><p><a href=http://www2.au.FreeBSD.org/>http://www2.au.FreeBSD.org/</a> - Australia/2.</p></li><li><p><a href=http://www3.au.FreeBSD.org/>http://www3.au.FreeBSD.org/</a> - Australia/3.</p></li><li><p><a href=http://freebsd.itworks.com.au/>http://freebsd.itworks.com.au/</a> - Australia/4.</p></li><li><p><a href=http://www.br.FreeBSD.org/www.freebsd.org/>http://www.br.FreeBSD.org/www.freebsd.org/</a> - Brasil/1.</p></li><li><p><a href=http://www2.br.FreeBSD.org/www.freebsd.org/>http://www2.br.FreeBSD.org/www.freebsd.org/</a> - Brasil/2.</p></li><li><p><a href=http://www3.br.FreeBSD.org/>http://www3.br.FreeBSD.org/</a> - Brasil/3.</p></li><li><p><a href=http://www.bg.FreeBSD.org/>http://www.bg.FreeBSD.org/</a> - Bulgaria.</p></li><li><p><a href=http://www.ca.FreeBSD.org/>http://www.ca.FreeBSD.org/</a> - Canadá/1.</p></li><li><p><a href=http://www2.ca.FreeBSD.org/>http://www2.ca.FreeBSD.org/</a> - Canadá/2.</p></li><li><p><a href=http://www3.ca.FreeBSD.org/>http://www3.ca.FreeBSD.org/</a> - Canadá/3.</p></li><li><p><a href=http://www.cn.FreeBSD.org/>http://www.cn.FreeBSD.org/</a> - China.</p></li><li><p><a href=http://www.cz.FreeBSD.org/>http://www.cz.FreeBSD.org/</a> - República Checa.</p></li><li><p><a href=http://www.dk.FreeBSD.org/>http://www.dk.FreeBSD.org/</a> - Dinamarca.</p></li><li><p><a href=http://www.ee.FreeBSD.org/>http://www.ee.FreeBSD.org/</a> - Estonia.</p></li><li><p><a href=http://www.fi.FreeBSD.org/>http://www.fi.FreeBSD.org/</a> - Finlandia.</p></li><li><p><a href=http://www.fr.FreeBSD.org/>http://www.fr.FreeBSD.org/</a> - Francia.</p></li><li><p><a href=http://www.de.FreeBSD.org/>http://www.de.FreeBSD.org/</a> - Alemania/1.</p></li><li><p><a href=http://www1.de.FreeBSD.org/>http://www1.de.FreeBSD.org/</a> - Alemania/2.</p></li><li><p><a href=http://www2.de.FreeBSD.org/>http://www2.de.FreeBSD.org/</a> - Alemania/3.</p></li><li><p><a href=http://www.gr.FreeBSD.org/>http://www.gr.FreeBSD.org/</a> - Grecia.</p></li><li><p><a href=http://www.hu.FreeBSD.org/>http://www.hu.FreeBSD.org/</a> - Hungría.</p></li><li><p><a href=http://www.is.FreeBSD.org/>http://www.is.FreeBSD.org/</a> - Islandia.</p></li><li><p><a href=http://www.ie.FreeBSD.org/>http://www.ie.FreeBSD.org/</a> - Irlanda.</p></li><li><p><a href=http://www.jp.FreeBSD.org/www.FreeBSD.org/>http://www.jp.FreeBSD.org/www.FreeBSD.org/</a> - Japón.</p></li><li><p><a href=http://www.kr.FreeBSD.org/>http://www.kr.FreeBSD.org/</a> - Corea/1.</p></li><li><p><a href=http://www2.kr.FreeBSD.org/>http://www2.kr.FreeBSD.org/</a> - Corea/2.</p></li><li><p><a href=http://www.lv.FreeBSD.org/>http://www.lv.FreeBSD.org/</a> - Letonia.</p></li><li><p><a href=http://rama.asiapac.net/freebsd/>http://rama.asiapac.net/freebsd/</a> - Malasia.</p></li><li><p><a href=http://www.nl.FreeBSD.org/>http://www.nl.FreeBSD.org/</a> - Holanda/1.</p></li><li><p><a href=http://www2.nl.FreeBSD.org/>http://www2.nl.FreeBSD.org/</a> - Holanda/2.</p></li><li><p><a href=http://www.no.FreeBSD.org/>http://www.no.FreeBSD.org/</a> - Noruega.</p></li><li><p><a href=http://www.nz.FreeBSD.org/>http://www.nz.FreeBSD.org/</a> - Nueva Zelanda.</p></li><li><p><a href=http://www.pl.FreeBSD.org/>http://www.pl.FreeBSD.org/</a> - Polonia/1.</p></li><li><p><a href=http://www2.pl.FreeBSD.org/>http://www2.pl.FreeBSD.org/</a> - Polonia/2.</p></li><li><p><a href=http://www.pt.FreeBSD.org/>http://www.pt.FreeBSD.org/</a> - Portugal/1.</p></li><li><p><a href=http://www2.pt.FreeBSD.org/>http://www2.pt.FreeBSD.org/</a> - Portugal/2.</p></li><li><p><a href=http://www3.pt.FreeBSD.org/>http://www3.pt.FreeBSD.org/</a> - Portugal/3.</p></li><li><p><a href=http://www.ro.FreeBSD.org/>http://www.ro.FreeBSD.org/</a> - Rumanía.</p></li><li><p><a href=http://www.ru.FreeBSD.org/>http://www.ru.FreeBSD.org/</a> - Rusia/1.</p></li><li><p><a href=http://www2.ru.FreeBSD.org/>http://www2.ru.FreeBSD.org/</a> - Rusia/2.</p></li><li><p><a href=http://www3.ru.FreeBSD.org/>http://www3.ru.FreeBSD.org/</a> - Rusia/3.</p></li><li><p><a href=http://www4.ru.FreeBSD.org/>http://www4.ru.FreeBSD.org/</a> - Rusia/4.</p></li><li><p><a href=http://freebsd.s1web.com/>http://freebsd.s1web.com/</a> - Singapur.</p></li><li><p><a href=http://www.sk.FreeBSD.org/>http://www.sk.FreeBSD.org/</a> - República Eslovaca.</p></li><li><p><a href=http://www.si.FreeBSD.org/>http://www.si.FreeBSD.org/</a> - Eslovenia.</p></li><li><p><a href=http://www.es.FreeBSD.org/>http://www.es.FreeBSD.org/</a> - España.</p></li><li><p><a href=http://www.za.FreeBSD.org/>http://www.za.FreeBSD.org/</a> - Sudáfrica/1.</p></li><li><p><a href=http://www2.za.FreeBSD.org/>http://www2.za.FreeBSD.org/</a> - Sudáfrica/2.</p></li><li><p><a href=http://www.se.FreeBSD.org/>http://www.se.FreeBSD.org/</a> - Suecia.</p></li><li><p><a href=http://www.ch.FreeBSD.org/>http://www.ch.FreeBSD.org/</a> - Suiza.</p></li><li><p><a href=http://www.tw.FreeBSD.org/www.freebsd.org/data/>http://www.tw.FreeBSD.org/www.freebsd.org/data/</a> - Taiwan.</p></li><li><p><a href=http://www.tr.FreeBSD.org/>http://www.tr.FreeBSD.org/</a> - Turquía.</p></li><li><p><a href=http://www.ua.FreeBSD.org/www.freebsd.org/>http://www.ua.FreeBSD.org/www.freebsd.org/</a> - Ucrania/1.</p></li><li><p><a href=http://www2.ua.FreeBSD.org/>http://www2.ua.FreeBSD.org/</a> - Ucrania/2.</p></li><li><p><a href=http://www4.ua.FreeBSD.org/>http://www4.ua.FreeBSD.org/</a> - Ucrania/Crimea.</p></li><li><p><a href=http://www.uk.FreeBSD.org/>http://www.uk.FreeBSD.org/</a> - Reino Unido/1.</p></li><li><p><a href=http://www2.uk.FreeBSD.org/>http://www2.uk.FreeBSD.org/</a> - Reino Unido/2.</p></li><li><p><a href=http://www3.uk.FreeBSD.org/>http://www3.uk.FreeBSD.org/</a> - Reino Unido/3.</p></li><li><p><a href=http://www6.FreeBSD.org/>http://www6.FreeBSD.org/</a> - USA/Oregón.</p></li><li><p><a href=http://www2.FreeBSD.org/>http://www2.FreeBSD.org/</a> - USA/Tejas.</p></li></ul></div></div><div class=sect2><h3 id=eresources-email>C.4. Direcciones de correo electrónico<a class=anchor href=#eresources-email></a></h3><div class=paragraph><p>Los siguientes grupos de usuarios de FreeBSD provéen a sus miembros de direcciones de correo. Dichos administradores se reservan el derecho de retirar el uso de la dirección si se abusa de ella de cualquier manera.</p></div><table class="tableblock frame-all grid-all stretch informaltable"><col style=width:25%><col style=width:25%><col style=width:25%><col style=width:25%><thead><tr><th class="tableblock halign-left valign-top">Dominio</th><th class="tableblock halign-left valign-top">Recursos que se suministran</th><th class="tableblock halign-left valign-top">Grupo de Usuarios</th><th class="tableblock halign-left valign-top">Administrador</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>ukug.uk.FreeBSD.org</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Sólo redirección</p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a href=mailto:freebsd-users@uk.FreeBSD.org>freebsd-users@uk.FreeBSD.org</a></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Lee Johnston <a href=mailto:lee@uk.FreeBSD.org>lee@uk.FreeBSD.org</a></p></td></tr></tbody></table></div><div class=sect2><h3 id=eresources-shell>C.5. Cuentas shell<a class=anchor href=#eresources-shell></a></h3><div class=paragraph><p>Los siguientes grupos de usuarios facilitan cuentas shell a gente que apoya activamente el proyecto FreeBSD. Sus respectivos administradores se reservan el derecho de cancelar la cuenta y si se abusa de ella de algún modo.</p></div><table class="tableblock frame-all grid-all stretch informaltable"><col style=width:25%><col style=width:25%><col style=width:25%><col style=width:25%><thead><tr><th class="tableblock halign-left valign-top">Servidor</th><th class="tableblock halign-left valign-top">Tipo de acceso</th><th class="tableblock halign-left valign-top">Servicios que se ofrecen</th><th class="tableblock halign-left valign-top">Administrador</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>storm.uk.FreeBSD.org</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>SSH only</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>CVS de sólo lectura, espacio web personal, correo electrónico</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Brian Somers &lt;<a href=mailto:brian@FreeBSD.org>brian@FreeBSD.org</a>></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>dogma.freebsd-uk.eu.org</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Telnet/FTP/SSH</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Correo electrónico, espacio web, FTP Anónimo</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Lee Johnston <a href=mailto:lee@uk.FreeBSD.org>lee@uk.FreeBSD.org</a></p></td></tr></tbody></table></div></div></div><div class=sect1><h2 id=pgpkeys>Apéndice D: PGP keys<a class=anchor href=#pgpkeys></a></h2><div class=sectionbody><div class=paragraph><p>En caso de que necesites verificar una firma o enviar un mail encriptado a alguno de los responsables o miembros del core team, aquí tienes una serie de claves para uso.</p></div><div class=sect2><h3 id=pgpkeys-officers>D.1. Responsables<a class=anchor href=#pgpkeys-officers></a></h3><div class=sect3><h4 id=_grupo_responsables_de_seguridad_security_officerfreebsd_org>D.1.1. Grupo Responsables de Seguridad <code>&lt;<a href=mailto:security-officer@FreeBSD.org>security-officer@FreeBSD.org</a>></code><a class=anchor href=#_grupo_responsables_de_seguridad_security_officerfreebsd_org></a></h4><div class="literalblock literal-block-margin"><div class=content><pre>pub   rsa4096/D9AD2A18057474CB 2022-12-11 [C] [expires: 2026-01-24]
      Key fingerprint = 0BE3 3275 D74C 953C 79F8  1107 D9AD 2A18 0574 74CB
uid                            FreeBSD Security Officer &lt;security-officer@freebsd.org&gt;
sub   rsa4096/6E58DE901F001AEF 2022-12-11 [S] [expires: 2025-01-15]
sub   rsa4096/46DB26D62F6039B7 2022-12-11 [E] [expires: 2025-01-15]</pre></div></div><div class="literalblock literal-block-margin"><div class=content><pre>-----BEGIN PGP PUBLIC KEY BLOCK-----

mQINBGOVdeUBEADHF5VGg1iPbACB+7lomX6aDytUf0k2k2Yc/Kp6lfYv7JKU+1nr
TcNF7Gt1YkajPSeWRKNZw/X94g4w5TEOHbJ6QQWx9g+N7RjEq75actQ/r2N5zY4S
ujfFTepbvgR55mLTxlxGKFBmNrfNbpHRyh4GwFRgPlxf5Jy9SB+0m54yFS4QlSd0
pIzO0CLkjHUFy/8S93oSK2zUkgok5gLWruBXom+8VC3OtBElkWswPkE1pKZvMQCv
VyM+7BS+MCFXSdZczDZZoEzpQJGhUYFsdg0KqlLv6z1rP+HsgUYKTkRpcrumDQV0
MMuCE4ECU6nFDDTnbR8Wn3LF5oTt0GtwS0nWf+nZ1SFTDURcSPR4Lp/PKjuDAkOS
P8BaruCNx1ItHSwcnXw0gS4+h8FjtWNZpsawtzjjgApcl+m9KP6dkBcbN+i1DHm6
NG6YQVtVWyN8aOKmoC/FEm1CWh1bv+ri9XOkF2EqT/ktbjbT1hFoFGBkS9/35y1G
3KKyWtwKcyF4OXcArl6sQwGgiYnZEG3sUMaGrwQovRtMf7le3cAYsMkXyiAnEufa
deuabYLD8qp9L/eNo+9aZmhJqQg4EQb+ePH7bGPNDZ+M5oGUwReX857FoWaPhs4L
dAKQ1YwASxdKKh8wnaamjIeZSGP5TCjurH7pADAIaB3/D+ZNl2a7od+C1wARAQAB
tDdGcmVlQlNEIFNlY3VyaXR5IE9mZmljZXIgPHNlY3VyaXR5LW9mZmljZXJAZnJl
ZWJzZC5vcmc+iQJSBBMBCgA8AhsBBAsJCAcEFQoJCAUWAgMBAAIeBQIXgBYhBAvj
MnXXTJU8efgRB9mtKhgFdHTLBQJjlXeQBQkF3u+rAAoJENmtKhgFdHTLOVoQALS3
cj7rqYkHiV4zDYrgPEp9O1kAyGI8VdfGAMkDVTqr+wP4v/o7LIUrgwZl5qxesVFB
VknFr0Wp5g9h0iAjasoI5sDd6tH2SmumhBHXFVdftzDQhrugxH6fWRhHs0SaFYCk
Qt5nFbcpUfWgtQ35XTbsL8iENdYpjKXsSFQrJneGSwxIjWYTFn6ps/AI3gwR8+Bn
OffEFdYugJ049O6Vu6YBFJHrnMO7NbF4v95dVYuLtpMIaXWM+V9KITmhaBzFz5fM
Q7UOzcLlbxOYKNIWcp8QQk429mayKW5VUeUExUD1ZzBHn+P6ZG7QTMDu/RmBqiHo
ewCMVz4n9uXT5BiOngE4CvS0WQwHzK+k9MLpG2u/Bo9+LT0Ceh9Ou1rfU5+0tRwl
GyOFFjf3INS7I7gkcAwxQ7dzDItN/UQPZpg8y9mABU2x4enz0AvTnb61d/1dnTEr
tdNgU433he0ZnD1HurZCjBEWC656wv6iMdWcD8gjhMbmEpPmjvXcYlTO6zhEygSM
DiwdQCWK2W4++YJerA6ULBi3niNWBpofOFH8XylV56ruhjtHCo7+/3carcMoPOJv
lVZ1zCKxLro3TRBT15JTFBGqblRyTopFK3PuxW//GTnZOtpQEOV6yL4RAXcWeC1d
1hb5k/YxUmRF6XsDNEH4b08T8ZO8dV3dAV43Wh1oiQEzBBABCAAdFiEEuyjUCzYO
7pNq7RVv5fe8y6O93fgFAmObXVYACgkQ5fe8y6O93fiBlwf/W8y1XXJIx1ZA3n6u
f7aS70rbP9KFPr4U0dixwKE/gbtIQ9ckeNXrDDWz0v0NCz4qS+33IPiJg1WcY3vR
W90e7QgAueCo5TdZPImPbCs42vadpa5byMXS4Pw+xyT+d/yp2oLKYbj3En4bg1GM
w71DezIjvV+e01UR++u1t9yZ8LOWM5Kumz1zyQLZDZ8qIKt1bBfpa+E0cEqtNQWu
iGhQE3AHI8eWV+jBkg5y2zHRIevbWb1UPsj43lgkFtAGHk9rrM8Rmgr4AXr531iD
srBwauKZ/MElcF3MINuLH+gkPPaFHw/YIpLRLaZXZVsw3Xi1RNXI2n2ea29dvs/C
Lcf1vYkCMwQQAQgAHRYhBPwOh4rlr+eIAo1jVdOXkvSep+XCBQJjm14FAAoJENOX
kvSep+XC0DcP/1ZB7k9p1T+9QbbZZE1PJiHby3815ccH3XKexbNmmakHIn3L6Cet
F891Kqt9ssbhFRMNtyZ/k/8y8Hv5bKxVep5/HMyK+8aqfDFN0WMrqZh0/CiR6DJh
gnAmPNw/hAVHMHaYGII9kCrFfPFJ02FKoc81g9F08odb7TV+UlvRjkErhRxF+dGS
wQoO0RCbf0Z1cs7nd0Vb2z4IJh4XMxBjWc/uQ2Q9dH/0uRzwpAnR4YX+MG5YrX7Z
zBvDyR0r76iQwRSDKgioNgkr6R3rq1NZGdaj+8b0LzdOqtzKJ/eupDe3+H67e/EN
qymtreGjrubpiU9bKvYArisUqhE5KtguryvR6Qz9bj87nPg33DT3WWGVrwFRxBox
dbWzjQFv0wug8m4GAwVF7fPR5/eW7IHw8zvgn0vSPcZz7MZ4e6Y5jN4kA5/xWJYZ
Sps54qQWB+FA30unIXN68KqdIzONIbtaY3W4/JjJUCm4T+wEjKaH+wJX8w1DMjlg
mkTmGh/UrTyC1vXbPgk9Sy3cRTICR1T9z7W8UlmTtnKrUklrjlFR7SXzrEXzLGOX
Fm+NEHpHNXqzcm6c3QfzY/yQ9HSAQ/t7SUQ9caRePbDz3/msyPxtGFor9roQv6VN
wRXCyRgkH4Y5tPhJAQ8G/FxX+VXFb93QL0lfelb23/BBu6cUwW63SRn5uQINBGOV
dskBEADqo8z6TFAhrvHhJV5wHdj67guoYvpXP8gvdCqos8SLluqi0AWgJEwlqu7L
mKQ6qMoJ+2DN6y+dEtvOVgBAgF63LLf3FQKq9FB/3uqeIiQlCIl3H43f8KttEZzf
/lbry4Y6QhS2OXM31Ut9Q+1IfTGwvs1E8/J1U4jQrAGqNKknXyQyMweJ0jvvcSLJ
nv3S7COUJVOT3cTgVeh3RIQlFzqK2rSQmygDpS8bT8MjCsZr+KGezKpbddKXio4a
QW/e6nCMyYR8bo0GQ9DpsyAOsaENnkghncQhA7GdPZK9xLMNQMCp0OdcZlqRVjRZ
OutuzNW6PPoczs/NQq02YWK4BPtSV7+ldS9gPZTLIpnRNQRzcnA0vnQTqSAfasVw
sAGm+MpH7zcaMf2Tw1K08u7+5gyObgzUzQmGLCgo9VIncnDis0s4gfTmtrr5jCeV
7LYDQX+2fApMtXbVXeKJem1PS+Z6LPbW2HklxYuG5nFgewCYlQjKujfiwW1Clhi4
JQeE1Naobbaar99V/VeoHrOYAEWP0bkUyrFcocLJ+0g3KpjSkctIptgGGpMBKe4U
9O7pWoTki8Yz/uYQn/p0iZcG8SfKM8I4283jdsi5SUiNNJJZCBQTVA7d8MxUVv5+
qpX/v5XqYM3pHza2DLXzwfAE9O2dgN1OMZYIld+OnWcpm2PxIwARAQABiQRyBBgB
CgAmFiEEC+MydddMlTx5+BEH2a0qGAV0dMsFAmOVdskCGwIFCQICKQACQAkQ2a0q
GAV0dMvBdCAEGQEKAB0WIQS2FSd+gQh991yBgztuWN6QHwAa7wUCY5V2yQAKCRBu
WN6QHwAa77gbEADpUBT14cesITuMsOWYsyEtNmB4UlTFWCktk/YzyCotasZxIhMP
Xih9G1tDo9ExIWT8jNjSSA+w0Viua/PirDLvI8JtX1JiK3nwMenwlXwlkRAk9TJW
y944YegHF/5ytntwZ/L4BMYc3MztyZbw+sDwnNBZKYmO8gwfYobtfoGxOR4Onb37
bbUVw62xHQIn2zafSmMQ4oMXZTm9EteIYwgcrC1h+Urv5IXCJZHrqmXCPE5g5XZ1
G9jqkwlaRYWjcLD0qxwc5m9LNrF6OBS9N6S7DncIYt9VupI5OCr1uRSqzqaBMFDC
lTTH+dAx3b6J1KFB0UiHP3FeTalFh8L3NE+dN9apNAgkUWv/v4oo/6dkRu3NZse2
RAo/o2X5r40qk/lhydQRZTSTFsiuH3VUWVsgmqAHnHW7pMMw8FAlKhyRSFnhbW7r
e0jj8XMIO7G5yjQKQCnYuPdXbx++bP1PzsEWDv9j/sph5arcosdo6tEXklWHED17
MEPIton1+NRfsU0peEVggQXlwdTcZN/h7FeCZ56dcwCWdCpSlv6CcWzRXSNUyJpK
a9qfIqBX/monjy7w5IHmhvLwAYI6IoT11h1QDEfGfhrwWPwOjnXsaYm5E7wv8w69
PxMbOJbMpWSg8L7xW3LXKR1VwXggUC1+b3y67E5Ggi1hf0lfTnTMpL2ClO2QD/oC
hMIafhzxbjh2WzgYahVHZH3gpHc1/0Bnc07s9+Pa6EYYM9r0XzezLW7bswOjVloR
FreQ3FIF/2OSN0OGdm7dyYl0OliTIDDDlwK/l8bcckUcpHNR1dw0P3KvDlmLmzZy
G4HmzzSBa9jiFirEfcg2rnGc6Zi382jGVALuYVplPXyMOUiChp0AAQZzTIYpXw/g
pBE6em2k740yuK6WqG4yXXgk67FoH10TQvMd4Q73K4zw+9DMpThlUHcfBmAoViZw
il7C0xl+ysHX8ZI3JU8s1r3XAnpqdHi4Wpixm/ctXbVnTSA3FQr2SctJYqR1VHRW
GMW+Ii2SQDS+t9bZTzOgAPLDtfy+JqhBpwCB1a1EHftkJEojpfZipaYGkf3yc+vN
wUeUHp/csF9CT7Qbqaj1t7fVWzv7jcVKpRwngIT4vTSzqbo6WC34FuUAH0t7tJ5K
eZ625AqEFLmtqtDo+ydJhZrVrXBNXPfkx5hSVW/I9hvckMNwA3t0KfQC2sz+Z1Q1
a4vDWQYRytfyrgZkWGbXMn6l1JyqIolgJZuax2kYs7Vu3t8KptqCbv0ZBAGoMm7r
RLgVodhI9voA8YxCirSChrueJYn+JKk8MIyk3DdXpBoocMIAjFJAUgXjV5NQpZMy
xR8BEiQnBcHRIKVWEEyhbLtHpmCEsnKNyKVGoxs31IkEcgQYAQoAJgIbAhYhBAvj
MnXXTJU8efgRB9mtKhgFdHTLBQJlhctvBQkD8n2mAkDBdCAEGQEKAB0WIQS2FSd+
gQh991yBgztuWN6QHwAa7wUCY5V2yQAKCRBuWN6QHwAa77gbEADpUBT14cesITuM
sOWYsyEtNmB4UlTFWCktk/YzyCotasZxIhMPXih9G1tDo9ExIWT8jNjSSA+w0Viu
a/PirDLvI8JtX1JiK3nwMenwlXwlkRAk9TJWy944YegHF/5ytntwZ/L4BMYc3Mzt
yZbw+sDwnNBZKYmO8gwfYobtfoGxOR4Onb37bbUVw62xHQIn2zafSmMQ4oMXZTm9
EteIYwgcrC1h+Urv5IXCJZHrqmXCPE5g5XZ1G9jqkwlaRYWjcLD0qxwc5m9LNrF6
OBS9N6S7DncIYt9VupI5OCr1uRSqzqaBMFDClTTH+dAx3b6J1KFB0UiHP3FeTalF
h8L3NE+dN9apNAgkUWv/v4oo/6dkRu3NZse2RAo/o2X5r40qk/lhydQRZTSTFsiu
H3VUWVsgmqAHnHW7pMMw8FAlKhyRSFnhbW7re0jj8XMIO7G5yjQKQCnYuPdXbx++
bP1PzsEWDv9j/sph5arcosdo6tEXklWHED17MEPIton1+NRfsU0peEVggQXlwdTc
ZN/h7FeCZ56dcwCWdCpSlv6CcWzRXSNUyJpKa9qfIqBX/monjy7w5IHmhvLwAYI6
IoT11h1QDEfGfhrwWPwOjnXsaYm5E7wv8w69PxMbOJbMpWSg8L7xW3LXKR1VwXgg
UC1+b3y67E5Ggi1hf0lfTnTMpL2ClAkQ2a0qGAV0dMsjqhAAorQ725G342raJ+os
6+E/EFNsr4SR5H+AeinlQ2ymNSeO/ODsV6dmyYD3hed0mAXvIJt2B46fFC4eAP9f
VOIbMMhPMpnJuZyLPDi8gXcZLgWSRhJ88R98KIsmKlh+/fdZM4RI1JLjICi7kyNR
4jtKCzLj0DYVBzp1mn0lTwtFzv7SC9djpqFLnO5YoGPWfQHHhY02Trh2posRwAHO
oacXSFvsoQv6k6XNlStJ4lnrkH6t+Od4kU3/TJ0eQXs7Zd2WEVnMe1IhbihsGcAY
mzZzZlLOhskHCeVE2taHiXC6h4tC3/69I16N8ICauxGY41clPhiNmVaAzmkunOPz
ry5utl6HkpZ5/3UMVHI1JIvsfJW+vSMUhdcQILAv6DbRWWHeax3ZZ6iAVGCtJS7U
glwZM1Xor0okGtIS+aJ/Cw7tZ8Nm18lutcrf2MVW+BWpzMQKnWFQYTn1NEWjzYnx
9Na22+E8AvW02TdS0NSiP0sG/0q7lBNEck9vH4WEbbEXktj51Dg4ISUhQyW8BWwW
X+kSiNeqtcaikUb8SFj5vpTDotTSzikfT/jisvR5goTMNFCVHFZdXCdsbUZd8Iub
egAOh6Db/06y3mFYDEfcGJipab400OY03a2xw9Vz+YxrKfELCTBo2tZv+3K8kXgq
XFcbyJnkXmjnYM/sw5kKqtzuc7i5Ag0EY5V3BwEQAMpFVczZo9ZPNsgW791UW5o6
wnrnd1nIO+S4rc37q2TEz8KGHCuxo5NwffZ2t6Ln04BI54pbapg17b7a0hPka37H
FkL28n4VyMdx0CsAm3QEfUsdK6xwKV2SucYeVcrV1upcN4PdXD7su1I7/A4CWXFJ
G047zJ0Z89lJZiQEiAq7ghvEoinC0sm+0a6ao/ocqCgWCKM1yCPOyzJXleRrv29S
RnYziMR+q2U0x9xg9Xl6GMwUmFwbJc9nORVvLH7fbU6/du8EgoAYrglFOFZG/TSo
lSGWRSMiavz0JSD/i+rEN4aIT4WfBe+L9Wy1AmrNxiAO+zKmzHQu3JSxDncr+y+h
cd+W0gqw10FoI9jWLcL7kR+6a0iOjuJSXSopq2l3DafiPxtCFmr4CGQhzBHM6e4/
v/NNd3F0XpVbJ6RQph7lkfvfz8q2lvUlHhezJ0p1xXmhff9CHjdVMhmAmz5+imBA
Xk2mottNfKb0pFEen1xY3K/UPA4g+oPsSj495MsvIg9eIMCcC3/z0SEUMWH/styy
JzPqfpyfGwZeTcIj9vg2o+RnGvmcLVYA/EGToPk905kv/cK73oy8bZyOB0zMg7T9
PaWgLUO0sqjqo0Mw3knFySg3oRXlcilPQvfPdX0JvwLpc9DWlr1+1GkCXJ08lWug
Jc96CJQupKRb1IbC0oUXABEBAAGJAjwEGAEKACYWIQQL4zJ110yVPHn4EQfZrSoY
BXR0ywUCY5V3BwIbDAUJAgIpAAAKCRDZrSoYBXR0ywwtD/wIDmEcHdFlyFRTomUB
jbeK2uzcZIhkkgL58lc63UPle5iJ2FBvmYS+0rQS53sVEsccn5KfkOwTryKllvWb
l0IzuiqfawxALcfWpfZJHzTMSnDHfgXvOOyFMQruqRDAHAr7PNC0CnbT0sEF2ZFz
ad8M9fLqtkXUx4mgECNGJ4CVqg75KY8uUzv/BmRwEf587FT5/iAIed5MjFB2VFDX
9GABcvTTbHxCZIxnxl3cs15SxT0lAofZ2ueU6kWYWZSXFeaEM/4ymPJws2mmV0Ak
bJghLXCn9Mx3nX6NTZZ9Harbru+RzW3/Hg3DZd0J9vko8PafP0l1NWtgyX74CqvT
gjzTxXTnqrRXzcczK7fhcC2u4i0prPtXXcyyi7SwpoLikaZCLFFhUmOx+mS5Tjtg
FyFZBNxnO7iAwkzfcTcC9sPoWaFmiQf6q5EIYzG+WQpncj80mxl3HWOP6oFj/hZJ
RYseKeMkvJzLTo87rFdM6CsMrLwETR6e+aWM0btPFil1rXVACNOjsy0bxTV8OJEf
yxnYmyjvnBvB0kdiaVEDdVhxgSqzLAX4mgXa49/V6M/uzMr+n3/A1Jdk4V6fVm8S
5cFIXxoUat3cB4xGaT9OWD3o1NPr6eS9Vo0EsJlRl81SG68fS+Qtk2fX27T68YG4
Aa3zMfZxUsVuFLtTuQbRC+fJpIkCPAQYAQoAJgIbDBYhBAvjMnXXTJU8efgRB9mt
KhgFdHTLBQJlhcuqBQkD8n1oAAoJENmtKhgFdHTLoO0QAJsTE9fkleb7YzPEuP9G
J3jx8PGdWm7n+8UNdr24kS6gOXVUfPZrWa5So21hcIwZb4PZDqHSVSQnRciKhSnG
7gplYPNGZ4+FWbLr/mBRYarjkVFLUuCPexSIjxV1KSGJnWs9YTVAKZAz75GpCML6
jD6biCOQCQ86wqOdWvZIZR8YvurrxR64ABB0rjbsaG8cNOUX1cwAfdLwthf64dS+
2m3lqNGDHkP5eNL0RIxC5gXYEp0lvmlMH3ZuO5WrfH73PTDg89bxXeuhrFmSEwf4
xWm603oi8/2qQvR9/7jb0o+t71NQuWrWIFONZWWgZBUGso+uyT3XgY4YqKGR3z2Q
zKHYnJ6M7SvSYpqS7RtcxcCXF0HGNfES8cAgtKVpFtbtSwXXp8O8oLyjmVIO/NjU
pbLOGdFIsarsezLFV9f2fqZ63J34hyUSg8LrYVV1fA5DJUpebbX4hLpdk0MMtgG4
3BwKIGlJTpL5RkQ/uQU3YW2kairy7o+1imDD0TRzQxtdjVOI5vnlTNcfJZIIfLx4
drABA12OvpX3dfPV62R+8BAlJFT430CG6AISJIBqJRFvuikmnZGUvEHmOUs/FLbb
aXTPkKc7tR2WIwljRvMV+Qk84cWcX6YchMslMuiDM1mtlQZig34WHGSE+zCWnXAs
lIHlSwox7qfdO0Kz2XncSbIA
=QvUh
-----END PGP PUBLIC KEY BLOCK-----</pre></div></div></div><div class=sect3><h4 id=_secretario_del_core_team_core_secretaryfreebsd_org>D.1.2. Secretario del Core Team <code>&lt;<a href=mailto:core-secretary@FreeBSD.org>core-secretary@FreeBSD.org</a>></code><a class=anchor href=#_secretario_del_core_team_core_secretaryfreebsd_org></a></h4><div class="literalblock literal-block-margin"><div class=content><pre>pub   rsa4096/4D632518C3546B05 2024-02-17 [SC] [expires: 2025-02-16]
      Key fingerprint = 1A23 6A92 528D 00DD 7965  76FE 4D63 2518 C354 6B05
uid                            FreeBSD Core Team Secretary &lt;core-secretary@FreeBSD.org&gt;
sub   rsa4096/CABFDE12CA516ED2 2024-02-17 [E] [expires: 2025-02-16]</pre></div></div><div class="literalblock literal-block-margin"><div class=content><pre>-----BEGIN PGP PUBLIC KEY BLOCK-----

mQINBGXQ1o8BEAC+Rcg8cmVxuP17Vu+q5KgCx/XiulQuqKXAqqBlYCH2jqk6DINP
yFrREGBhzd/qNmlAYEahQ4Zgl0bUZNTrZVDyzicOvPP0jH+KSTQwRs7NOawEdlVO
cyHrwDCPEqf5ZzD4NhfTriEOw+j0pEH/onitUGvoQRtx15xWyaJQxDEBMTYMLewE
86D1bltwnTNczE3UZb7oQLJXkAX5hcLtou70XJGgZITvJkK+kp/xot2eFjnqRz/u
WeXnKhYAmC07EKwZ1uw047eHKwMMRBYqzApLwoQtfE430Kxf2q8de64x8zDbi6YM
1J4r8OAxOtHVyfJ0j7Q23DEZz0VVb4b1Tx5OG2Re/KSNvqI0awJO4TcRmOR88OyY
dzyXgnX6Sa7GVQY1FXvn7vtFuDAt7egZOzeomSHL9bdX07LTQ4UtM88EV9wm3q4q
smoatV9jsvPQ1zxCU3aQD/5eWTJH2/kz1LIuBL/Qi5XQpJn91lBtUWJrCgkHWPGu
f//rnnXmsG7DAChW+yZ7cFO8lfNa8sFhPqSxCYphWmJTrvadyQtDngB8JakWdnmK
pfGS6y5lel+181vw38ZZKt04AKM+nDY8051lBM7Q9Q6kTLI33UZeImndx5xYukVD
kV6aQ31HYfEark15c7iEz+OAcwFnM2ntXMt7kKGd40CqzusiPcQkPqPbAQARAQAB
tDhGcmVlQlNEIENvcmUgVGVhbSBTZWNyZXRhcnkgPGNvcmUtc2VjcmV0YXJ5QEZy
ZWVCU0Qub3JnPokCVwQTAQoAQRYhBBojapJSjQDdeWV2/k1jJRjDVGsFBQJl0NaP
AhsDBQkB4TOACAsJDQgMBwsDBRUKCQgLBRYDAgEAAh4FAheAAAoJEE1jJRjDVGsF
nacP/3PSg8JPmWoBfWrgT287NZ7OAU16/uGpDxlBUoVeEtkEDqZVW8yBFzrMhbwj
bJs3CZ+L85HMUDLZoxSwVnPM8PLVRzHTybYV7agYYzMox5C/jp2aeAgy9KYVd0Tk
07GMTYrSh4fhHWpxXz7IBOxk0RXvQxTHlg1u0DASkibYb2UTDcUNG5Q9kP/8jaIZ
kVDX8a5LDdOCgWaYdKPg4blv/UMjkegJz+Ayp7gXTcux6koW5F6ysSw9sgLBWb2D
b/KNIi4MBMe46xyXB/dqGAR4ibrUXTcQ4OAZNq1L6uWG1A49XuSgykdIwr00MzQw
wfVpKT31ww4ayVHLgj7NuqPlab9S5/fPfJ4MAvGE4GqWQFgsPKgKImUMgnnxTGpv
l7Dqk2MnWqn+wEi0bRES0PVBG96G+sZJQeaxBhoB+HwUSFqoZQg166AJIl//4t2w
bx0a1aWQSS0DZt3wsQW3NW9AE6L+FnFfIc2pQVoLjmvcGalDuvnemRmEOgotiZmt
32bi2aWxg0/Qio2rjLS2LpV+fhwDSN3Agvtnu53yUdD1TFFjTSMloM4SKhiXoPbI
XgfCLiBLNMsZL0AvO7wQfSePzPYxDLyEcwsfPJ8be+eGG1L62RUyad+MdfyXMH/S
m0sgqW/MW6Nv10RyPQOq3Jbgmp2laRMzKTOvQt5WwQf2FEl9uQINBGXQ1o8BEAC9
1cBYn6Z0QmM0OFWdXQI6fMOeNokaa6ngPgt7bzW5NjryqTdwyHOPZdm4DWf1SO/0
+fJRCqxbICyuMAFrb9fDle8bodALjm5ZquTL3D61HpZD4+RwOzOjYP6wLm7h38HT
/yIyK882Ovlw4Xz/TeSiL/VUSWE9twW7yz3oreCeLUBAfzacS9y+syO+aquEd0/x
JBz+mPQbrqfS64rCZXMZEivgsjkQoE6RM+n1rF4kw4Eu3E2kPevVwsoAaY+MEUM8
JAXaJMaNcLIhbeMy7dO/z6z2I3h5bUw5KxfVwzYSzSeRpYh53dNaB4NY+f5/vTrL
4dZmqBcLgcV0zZ02dj/u0SiwWlUFUpFGuSiW16DN7+2zG1zOWi7Nl44JawM62Tlf
mO8zruVGEHaV3e8fFwBLRKM0Sc7e3aLECISsfYeC5ZbRRbpQ1KX+VQr3FBKAMzG4
l9Go7vZ+UcLKpQx2rVPTJt1vDnRV49X6CF2Q/lV9iafQ4MTy6ACdAloT1yfH/lhU
iWQo1qDyRCSlmNBDsYl8gLrwMp4gGQAv3imZHxnJF5ru3nUYGG0U08D5mf2sWv5P
Wh7By8Jm8bmaP8cUF86lO9BJXh2d9QN5jqrAtXqYzenZ+ABSoL1XrD/yv3270rH7
H4gAUtgP+vJ3uMyRu9055OC+ie/b613NojCW5nYN2QARAQABiQI8BBgBCgAmFiEE
GiNqklKNAN15ZXb+TWMlGMNUawUFAmXQ1o8CGwwFCQHhM4AACgkQTWMlGMNUawXh
7w/+KjbEWTwAhjm2HJ3w4tXtPC5URg+A+BzYYVH/q0+956c1QeD0LYafHBw4LEMI
lhRvHQnmzwjtY8v/DgmLOVDMiMWVHo0Q2iQyMvOT1WyEPcgOTJLhvyVzDqRZx7AS
B4G8uNVkKAdBZ7OSXAP27lR/2SEoG05esw8b7Y39pVtucC3aeiua+19PLJWadBjj
XuvXuSCho0km+nk4IgadYmxIDyiMeyKZ8wCl7CJkzECm83q2OtNsMe3k8lgEXybt
KlQxnYApZmhqLMV5ob8WOk3AgAVsif1m332CiEIb1Sfx6wt3nXy/410CXdDDucuj
ndJVfJ6Un33tn0irZ5scPA2HmzK1PGMfgOGtkM8B3LE/x8kEKeWKb3l9boB32Unm
iTfKgEna+JISEab3bzOPWdCQFB8LyGXuWlhtvqmRoX8GtiMRy/F4mzh+l3lYHjj3
4EvPVyippO5zwU+S9HElJ2G37K6zrOmd5cGBrw4aBDoO70QVrMN4O86uvC9kChDb
qyFF5UgXg29QxJjiSCv98ksDMqpJ5AFYrmrsBtwU64OANrxxJ4AZLQ1apYmG9RWD
VHZgfeI60FNBLfKwix9UffFT7piQ/MLrjSde8gPH5S6ezBMrYpfGEopaI9A5qXe3
LnHz88gfdmaBM77YDZM/p23nmCrUxlE3kkbgjTY8NRjYyF8=
=MkAH
-----END PGP PUBLIC KEY BLOCK-----</pre></div></div></div><div class=sect3><h4 id=_secretario_del_grupo_de_administración_de_ports_portmgr_secretaryfreebsd_org>D.1.3. Secretario del Grupo de Administración de ports <code>&lt;<a href=mailto:portmgr-secretary@FreeBSD.org>portmgr-secretary@FreeBSD.org</a>></code><a class=anchor href=#_secretario_del_grupo_de_administración_de_ports_portmgr_secretaryfreebsd_org></a></h4><div class="literalblock literal-block-margin"><div class=content><pre>pub   ed25519/E3C401F60D709D59 2023-03-06 [SC] [expires: 2027-03-05]
      Key fingerprint = BED4 A1D3 6555 B681 2E9F  ABDA E3C4 01F6 0D70 9D59
uid                            FreeBSD Ports Management Team Secretary &lt;portmgr-secretary@FreeBSD.org&gt;
sub   cv25519/2C92B55E27A641C3 2023-03-06 [E] [expires: 2027-03-05]</pre></div></div><div class="literalblock literal-block-margin"><div class=content><pre>-----BEGIN PGP PUBLIC KEY BLOCK-----

mDMEZAXJvxYJKwYBBAHaRw8BAQdASFAC20WL3R1T6uNyGMZbfJCxDkcP4C5vi3Op
tcZ2fbq0R0ZyZWVCU0QgUG9ydHMgTWFuYWdlbWVudCBUZWFtIFNlY3JldGFyeSA8
cG9ydG1nci1zZWNyZXRhcnlARnJlZUJTRC5vcmc+iJYEExYKAD4WIQS+1KHTZVW2
gS6fq9rjxAH2DXCdWQUCZAXJvwIbAwUJB4TOAAULCQgHAwUVCgkICwUWAwIBAAIe
BQIXgAAKCRDjxAH2DXCdWYN1AP43TjyfZtZ3DLYT++g0+SuPsoO/3yWVybA+UmFL
zb8MngEA+LLNUfvEwCuXS/soh+ww5bpfmi3UUmeGiQEAXug3iA+JATMEEAEKAB0W
IQT7N0XIbxXo7ayBMvzYKU7Du8TX1QUCZAXLkwAKCRDYKU7Du8TX1XHMB/9R1MX4
6zMgpKqPPt76GOI+eGEdBK6bY8aJZjQGdqTh9f6VtXVoTGIG7cvhc9X8tDBoB0PT
2KZWheF51AV1+NHU4HwLAQ1BMebrFvWSfkw4xg4fBGwDhz9/GN85No+Js772V5ey
8lRiL6meRVWxMlLyWcxGd8JjcC5yX/iAUQ3SBGCLqW7unWjjg7CTd+AMBwcqPGrv
ax8q6eFVguJcHJAjMnKf6HAy4cpK3s+uMoUBCGnszSN12B3ysKfyC4pNO/pix5tA
Q5v8aRqTeFPh5zmNhWo0KGPzplTPqRQSHDl7GDQC8Ru3MhzFkeWzHsexjZVwS6W2
DPcYpuuAsA0XOZIZiQIzBBABCgAdFiEEEBpxaxYrAOVb7eoFrbv4YQo3ibcFAmQF
0u0ACgkQrbv4YQo3ibccwg/9F2Xuic3nhKxRbB3mJeDo6SYQETa/Gh1qQ34+8zlt
8UMazOx67gnYQfy+pXjro6eQ2up0a4eUYezcNOudqAQD21nRz3HA6EQVNcE/TzEA
xl5CJntTaLOt7S+EDXFW5BuQIvhhoMGgm8+WNVgA0EJ7tfL0OcYBSvr19fqwChEn
9c14cSk6mgHSsleP5NvskYN053pxHwy0LTSb8YBBv52th37t/CRFC1363rS5q+D7
JixFopd1O5pKpA5ipvE4gGgRjPtwjx0SjjepwK/3fuhEJQQyKzTIKlMfu2Dj/iR2
Li1Sfccau5LQXOj9fUITU3u1YG7yrm8VGzT7ao4d+KRwgMLjd2pLqiGIbbJwGBiP
FRmtilWQoeIlmSlFX4obAA517DOK0pW1mH8+eEn4EJd3SekT3yzFyKTASv0J48Z8
3F928xg+eZvHxVC0t1J+J5IG0gt3EEncuWKIPQGR7PiQbti6R3FQVTz6WfMWOebP
Qi0E9F/Aqakr6Vj2sKGrDq+ebpaF5G8Yw1YrUl2IDiPzkCegp3ZbI0wh11Xvzhi8
LXPQGK4jBQas4G8cegfitzmtdGRHYrbMv0R9I4mvaL+WlOuD2AvyVG28lguqVhnN
AZP+ohdquYyX2CNCVvbKWAtXo6Ur0vWG8BL8m6defAtEkIwVBALaOHQOSI3aNUz4
lwy4OARkBcm/EgorBgEEAZdVAQUBAQdAsefmSfxEOdOr02+K/6noYCuJ1FeAWVz6
jFYQ+9w6jggDAQgHiH4EGBYKACYWIQS+1KHTZVW2gS6fq9rjxAH2DXCdWQUCZAXJ
vwIbDAUJB4TOAAAKCRDjxAH2DXCdWRl4AP9h5ot212BK29S6ZcMBhHvmtF5PG1oD
c7LnZycSRmbFiwEAndCMpAGOhDW8iVgDd0wLQq/ZMPe+xccfG1b3zFH2EgE=
=iiAT
-----END PGP PUBLIC KEY BLOCK-----</pre></div></div></div><div class=sect3><h4 id=_doceng_secretaryfreebsd_org>D.1.4. <code>doceng-secretary@FreeBSD.org</code><a class=anchor href=#_doceng_secretaryfreebsd_org></a></h4><div class="literalblock literal-block-margin"><div class=content><pre>pub   rsa2048/E1C03580AEB45E58 2019-10-31 [SC] [expires: 2022-10-30]
      Key fingerprint = F24D 7B32 B864 625E 5541  A0E4 E1C0 3580 AEB4 5E58
uid                            FreeBSD Doceng Team Secretary &lt;doceng-secretary@freebsd.org&gt;
sub   rsa2048/9EA8D713509472FC 2019-10-31 [E] [expires: 2022-10-30]</pre></div></div><div class="literalblock literal-block-margin"><div class=content><pre>-----BEGIN PGP PUBLIC KEY BLOCK-----

mQENBF27FFcBCADeoSsIgyQUY8vREwkTikwFFlNg31MVy5s/Nq1cNK1PRfRMnprS
yfB62KqbYuz16bmQKaA9zHN4FGfiTvR6tl66LVHm1s/5HPiLv8sP14GsruLro9zN
v72dO7a9i68bMw+jarPOnu9dGiDFEI0dACOkdCGEYKEUapQeNpmWRrQ46BeXyFwF
JcNx76bJJUkwk6fWC0W63D762e6lCEX6ndoaPjjLBnFvtx13heNGUc8RukBwe2mA
U5pSGHj47J05bdWiRSwZaXa8PcW+20zTWaP755w7zWe4h60GANY7OsT9nuOqsioJ
QonxTrJuZweKRV8fNQ1EfDws3HZr7/7iXvO3ABEBAAG0PEZyZWVCU0QgRG9jZW5n
IFRlYW0gU2VjcmV0YXJ5IDxkb2Nlbmctc2VjcmV0YXJ5QGZyZWVic2Qub3JnPokB
VAQTAQoAPhYhBPJNezK4ZGJeVUGg5OHANYCutF5YBQJduxRXAhsDBQkFo5qABQsJ
CAcDBRUKCQgLBRYDAgEAAh4BAheAAAoJEOHANYCutF5YB2IIALw+EPYmOz9qlqIn
oTFmk/5MrcdzC5iLEfxubbF6TopDWsWPiOh5mAuvfEmROSGf6ctvdYe9UtQV3VNY
KeeyskeFrIBOFo2KG/dFqKPAWef6IfhbW3HWDWo5uOBg01jHzQ/pB1n6SMKiXfsM
idL9wN+UQKxF3Y7S/bVrZTV0isRUolO9+8kQeSYT/NMojVM0H2fWrTP/TaNEW4fY
JBDAl5hsktzdl8sdbNqdC0GiX3xb4GvgVzGGQELagsxjfuXk6PfOyn6Wx2d+yRcI
FrKojmhihBp5VGFQkntBIXQkaW0xhW+WBGxwXdaAl0drQlZ3W+edgdOl705x73kf
Uw3Fh2a5AQ0EXbsUVwEIANEPAsltM4vFj2pi5xEuHEcZIrIX/ZJhoaBtZkqvkB+H
4pu3/eQHK5hg0Dw12ugffPMz8mi57iGNI9TXd8ZYMJxAdvEZSDHCKZTX9G+FcxWa
/AzKNiG25uSISzz7rMB/lV1gofCdGtpHFRFTiNxFcoacugTdlYDiscgJZMJSg/hC
GXBdEKXR5WRAgAGandcL8llCToOt1lZEOkd5vJM861w6evgDhAZ2HGhRuG8/NDxG
r4UtlnYGUCFof/Q4oPNbDJzmZXF+8OQyTNcEpVD3leEOWG1Uv5XWS2XKVHcHZZ++
ISo/B5Q6Oi3SJFCVV9f+g09YF+PgfP/mVMBgif2fT20AEQEAAYkBPAQYAQoAJhYh
BPJNezK4ZGJeVUGg5OHANYCutF5YBQJduxRXAhsMBQkFo5qAAAoJEOHANYCutF5Y
kecIAMTh2VHQqjXHTszQMsy3NjiTVVITI3z+pzY0u2EYmLytXQ2pZMzLHMcklmub
5po0X4EvL6bZiJcLMI2mSrOs0Gp8P3hyMI40IkqoLMp7VA2LFlPgIJ7K5W4oVwf8
khY6lw7qg2l69APm/MM3xAyiL4p6MU8tpvWg5AncZ6lxyy27rxVflzEtCrKQuG/a
oVaOlMjH3uxvOK6IIxlhvWD0nKs/e2h2HIAZ+ILE6ytS5ZEg2GXuigoQZdEnv71L
xyvE9JANwGZLkDxnS5pgN2ikfkQYlFpJEkrNTQleCOHIIIp8vgJngEaP51xOIbQM
CiG/y3cmKQ/ZfH7BBvlZVtZKQsI=
=MQKT
-----END PGP PUBLIC KEY BLOCK-----</pre></div></div></div></div></div></div></div><hr><div class=last-modified><p><strong>Last modified on</strong>: 11 de diciembre de 2021 by <a href="https://cgit.freebsd.org/doc/commit/?id=2b027dd017" target=_blank>Sergio Carlavilla Delgado</a></p></div><div class=buttons><div class=home><i class="fa fa-home" aria-hidden=true title=Inicio></i><div class=container><a href=../ class=direction>Inicio</a></div></div></div><label class="hidden book-menu-overlay" for=menu-control></label></div><aside class=toc><div class=toc-content><h3>Tabla de contenidos</h3><nav id=TableOfContents><ul><li><a href=#book-preface>Prefacio</a><ul><li><a href=#preface-audience>A quién va dirigido este texto</a></li><li><a href=#preface-changes-from2>Cambios desde la segunda edición</a></li><li><a href=#preface-changes>Cambios desde la primera edición</a></li><li><a href=#preface-overview>Cómo se organiza este libro</a></li><li><a href=#preface-conv>Convenciones usadas en este libro</a></li><li><a href=#preface-acknowledgements>Agradecimientos</a></li></ul></li><li><a href=#getting-started>Parte I: Primeros pasos</a><ul><li><a href=#introduction>Capítulo 1. Introducción</a></li><li><a href=#bsdinstall>Capítulo 2. Instalación de FreeBSD</a></li><li><a href=#basics>Capítulo 3. Conceptos básicos de Unix</a></li><li><a href=#ports>Capítulo 4. Instalación de aplicaciones: packages y ports</a></li><li><a href=#x11>Capítulo 5. El sistema X Window</a></li></ul></li><li><a href=#common-tasks>Parte II: Tareas comunes</a><ul><li><a href=#desktop>Capítulo 6. Aplicaciones de escritorio</a></li><li><a href=#multimedia>Capítulo 7. Multimedia</a></li><li><a href=#kernelconfig>Capítulo 8. Configuración del kernel de FreeBSD</a></li><li><a href=#printing>Capítulo 9. Imprimir</a></li><li><a href=#linuxemu>Capítulo 10. Compatibilidad binaria con Linux</a></li></ul></li><li><a href=#system-administration>Parte III: Administración del sistema.</a><ul><li><a href=#config-tuning>Capítulo 11. Configuración y Adaptación del Sistema</a></li><li><a href=#boot>Capítulo 12. El proceso de arranque en FreeBSD</a></li><li><a href=#users>Capítulo 13. Usuarios y administración básica de cuentas</a></li><li><a href=#security>Capítulo 14. Seguridad</a></li><li><a href=#jails>Capítulo 15. Jaulas</a></li><li><a href=#mac>Capítulo 16. Mandatory Access Control</a></li><li><a href=#audit>Capítulo 17. Auditoría de eventos de seguridad</a></li><li><a href=#disks>Capítulo 18. Almacenamiento</a></li><li><a href=#geom>Capítulo 19. GEOM: Marco de trabajo modular de transformación de discos</a></li><li><a href=#vinum-vinum>Capítulo 20. El Gestor de Volúmenes Vinum</a></li><li><a href=#virtualization>Capítulo 21. Virtualización</a></li><li><a href=#l10n>Capítulo 22. Localización - Uso y configuración de I18N/L10N</a></li><li><a href=#updating-upgrading>Capítulo 23. Lo último de lo último</a></li></ul></li><li><a href=#network-communication>Parte IV: Comunicaciones en red</a><ul><li><a href=#serialcomms>Capítulo 24. Comunicaciones serie</a></li><li><a href=#ppp-and-slip>Capítulo 25. PPP y SLIP</a></li><li><a href=#mail>Capítulo 26. Electronic Mail</a></li><li><a href=#network-servers>Capítulo 27. Networking avanzado</a></li><li><a href=#firewalls>Capítulo 28. Cortafuegos</a></li><li><a href=#advanced-networking>Capítulo 29. Redes Avanzadas</a></li></ul></li><li><a href=#appendices>Parte V: Apéndices</a><ul><li><a href=#mirrors>Apéndice A: Cómo obtener FreeBSD</a></li><li><a href=#bibliography>Apéndice B: Bibliografía</a></li><li><a href=#eresources>Apéndice C: Recursos en Internet</a></li><li><a href=#pgpkeys>Apéndice D: PGP keys</a></li></ul></li></ul></nav><hr><div class=resources><h3>Recursos</h3><ul class=contents><li><i class="fa fa-file-pdf-o" aria-hidden=true title="Descargar PDF"></i><a href=https://download.freebsd.org/doc/es/books/handbook/handbook_es.pdf>Descargar PDF</a></li><li><i class="fa fa-pencil-square-o" aria-hidden=true title="Editar esta página"></i><a href=https://github.com/freebsd/freebsd-doc/blob/main/documentation/content/es/book target=_blank>Editar esta página</a></li></ul></div></div></aside><a class=to-top href=#top><i class="fa fa-arrow-circle-up" aria-hidden=true></i></a></main><footer><div class=footer-container><section class=logo-column><img src=http://172.16.201.134:1313/images/FreeBSD-colors.svg width=160 height=50 alt="FreeBSD logo"><div class=options-container><div class=language-container><a id=languages href=http://172.16.201.134:1313/es/languages><img src=http://172.16.201.134:1313/images/language.png class=language-image alt="Elegir idioma">
<span>Spanish</span></a></div><div class=theme-container><select id=theme-chooser><option value=theme-system>System</option><option value=theme-light>Claro</option><option value=theme-dark>Oscuro</option><option value=theme-high-contrast>Alto contraste</option></select></div></div></section><section class=about-column><h3 class=column-title>About</h3><ul class=column-elements-container><li><a href=https://www.freebsd.org/about/ target=_blank class=column-element>FreeBSD</a></li><li><a href=https://freebsdfoundation.org/ target=_blank class=column-element>FreeBSD Foundation</a></li><li><a href=https://www.freebsd.org/where/ target=_blank class=column-element>Get FreeBSD</a></li><li><a href=https://www.freebsd.org/internal/code-of-conduct target=_blank class=column-element>Code of Conduct</a></li><li><a href=https://www.freebsd.org/security/ target=_blank class=column-element>Security Advisories</a></li></ul></section><section class=documentation-column><h3 class=column-title>Documentation</h3><ul class=column-elements-container><li><a href=/es class=column-element>Documentation portal</a></li><li><a href=https://man.FreeBSD.org target=_blank class=column-element>Manual pages</a></li><li><a href=https://papers.FreeBSD.org target=_blank class=column-element>Presentations and papers</a></li><li><a href=https://docs-archive.freebsd.org/doc/ target=_blank class=column-element>Previous versions</a></li><li><a href=https://docs-archive.freebsd.org/44doc/ target=_blank class=column-element>4.4BSD Documents</a></li><li><a href=https://wiki.freebsd.org/ target=_blank class=column-element>Wiki</a></li></ul></section><section class=community-column><h3 class=column-title>Community</h3><ul class=column-elements-container><li><a href=http://172.16.201.134:1313/es/articles/contributing class=column-element>Get involved</a></li><li><a href=https://forums.freebsd.org/ target=_blank class=column-element>Community forum</a></li><li><a href=https://lists.freebsd.org/ target=_blank class=column-element>Mailing lists</a></li><li><a href=https://wiki.freebsd.org/IRC/Channels target=_blank class=column-element>IRC Channels</a></li><li><a href=https://bugs.freebsd.org/bugzilla/ target=_blank class=column-element>Bug Tracker</a></li></ul></section><section class=legal-column><h3 class=column-title>Legal</h3><ul class=column-elements-container><li><a href=https://freebsdfoundation.org/donate/ target=_blank class=column-element>Donations</a></li><li><a href=https://www.freebsd.org/copyright/freebsd-license/ target=_blank class=column-element>Licensing</a></li><li><a href=https://www.freebsd.org/privacy/ target=_blank class=column-element>Privacy Policy</a></li><li><a href=https://www.freebsd.org/copyright/ target=_blank class=column-element>Legal notices</a></li></ul></section><section class=copyright-column><p>&copy; 1994-2024 The FreeBSD Project. All rights reserved</p><span>Made with <span class=heart>♥</span> by the FreeBSD Community</span></section></div></footer></body></html>